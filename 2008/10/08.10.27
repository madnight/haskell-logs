00:06:04 <alar> @help msg
00:06:04 <lambdabot> msg <nick or channel> <msg>
00:06:32 <kaizoku> @msg #haskell test
00:06:32 <lambdabot> Not enough privileges
00:06:35 <kaizoku> :/
00:07:13 <alar> @msg dons I have a question about a question about SQLite binding library
00:07:13 <lambdabot> Not enough privileges
00:07:37 <alar> @msg dons I have a question about a question about SQLite binding library
00:07:37 <lambdabot> Not enough privileges
00:07:46 <alar> :(
00:07:56 <alar> even registered users can
00:08:07 <alar> even registered users can't send msg via lambdabot
00:14:45 <electronx> alar: yup
00:15:00 <electronx> i tried ages ago and couldn't do it either
00:15:03 <alar> why?
00:15:07 <electronx> no idea
00:15:27 <electronx> @seen dons
00:15:27 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 2h 25m 49s ago.
00:22:30 <quicksilver> @tell alar testing
00:22:30 <lambdabot> Consider it noted.
00:22:34 <quicksilver> alar: works for me
00:23:31 <BMeph> alar: Same here - and I'm almost the resident goofball around here. :)
00:24:54 <rwbarton>  @msg /= @tell
00:25:55 <alar> .
00:25:55 <lambdabot> alar: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:26:02 <alar> @messages
00:26:02 <lambdabot> quicksilver said 3m 32s ago: testing
00:26:02 <lambdabot> BMeph said 2m 54s ago: Also testing.
00:26:16 <alar> @reply
00:26:17 <lambdabot> Unknown command, try @list
00:26:34 <alar> @msg quicksilver don't understand what's wrong with me
00:26:35 <lambdabot> Not enough privileges
00:27:18 <rwbarton> @tell #haskell test
00:27:18 <lambdabot> Consider it noted.
00:27:26 <aeolist> @tell alar use @tell
00:27:26 <lambdabot> Consider it noted.
00:27:32 <rwbarton> @help tell
00:27:33 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
00:30:21 <alar> @tell dons I have a question about SQLite binding library
00:30:22 <lambdabot> Consider it noted.
00:30:25 <alar> hm
00:30:26 <lambdabot> alar: You have 1 new message. '/msg lambdabot @messages' to read it.
00:30:33 <alar> I used wrong command
00:30:37 <alar> @messages
00:30:37 <lambdabot> aeolist said 3m 11s ago: use @tell
00:30:56 <alar> ah, I see
00:31:15 <alar> tell is restricted - it can't spam the whole channel
00:31:16 <aeolist> it would also make sense to actually ask the question instead of asking to ask a question :P
00:31:53 <alar> aeolist: actually I want to know why he didn't make his interface an instance of HXT database interface
00:32:03 <aeolist> dont ask me :) ask him!
00:32:24 <alar> when he catches my msg, we'll have a talk on this subject
00:32:38 <alar> maybe he has good reasons
00:32:55 <alar> then I want to hear full explanation of what I have missed
00:33:06 <alar> not short telegram-style lambdabot msgs
00:50:26 <Twey> @hoogle [a] -> [[a]] -> [a]
00:50:27 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
00:50:27 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
00:50:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
00:54:48 <Twey> @hoogle a -> [[a]] -> [a]
00:54:49 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
00:54:49 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
00:54:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:13:05 <olsner> @quote zonk
01:13:05 <lambdabot> ghc says: Step 3: Zonk the kinds
01:14:17 <olsner> haskell compilers <3
01:21:51 <electronx> just wandering why can some algorithms no be expressed recursivly?
01:21:56 <electronx> not*
01:22:11 <electronx> can't you use tail recursion or something
01:24:35 <Cale> electronx: Everything can be expressed recursively.
01:25:23 <mapreduce> Iteration is tail recursion.
01:25:38 <mapreduce> Depending on what your definition of "is" is.
01:25:52 <Cale> (at least, every computable mathematical function)
01:28:55 <pao> is there a way to identify the expression (thunk?) that raised an exception?
01:29:02 <mmorrow> http://www.cis.upenn.edu/~dimitriv/presentation-for-tfp.pdf
01:29:04 <lambdabot> Title: Dependent types: Easy as PIE
01:29:10 <mmorrow> http://www.cis.upenn.edu/~dimitriv/rtheorems-presentation.pdf
01:29:12 <lambdabot> Title: Free theorems and runtime type representations
01:29:26 <mmorrow> those two are interesting
01:29:29 <mmorrow> about to look at
01:29:31 <mmorrow> http://www.cis.upenn.edu/~dimitriv/gadt-dependent-presentation.pdf
01:29:33 <lambdabot> Title: Type system support for gadts - and some ideas towards practical dependently typ ..., http://tinyurl.com/6s6esr
01:32:19 <pao> did I pose the wrong question? :-)
01:32:23 <pao> I suspect so :-)
01:33:01 <hesselink> it's a good question
01:33:08 <hesselink> but I fear the answer is no
01:33:35 <Twey> Is Either a Monad?
01:33:38 <pao> hesselink: thanks ... I also suspected that that was the answer :-)
01:33:45 <Cale> Twey: for any e, Either e is a monad.
01:34:01 <Twey> Mmhm
01:34:09 <Cale> Twey: Unfortunately, the only instance we have in the libraries is a kind of sucky one in Control.Monad.Error
01:34:28 <Twey> Oh right
01:34:30 <Deewiant> sucky?
01:34:37 <Twey> What's wrong with it?
01:34:38 <Cale> The e is restricted.
01:34:54 <Twey> Oh, to Error.
01:35:02 <Cale> Yeah, to make fail work.
01:35:14 <Twey> Monads don't have to have fail, do they?
01:35:17 <Cale> Right.
01:35:35 <Deewiant> Many would say that it's absolutely horrible that they do :-P
01:35:39 <Cale> fail is an ugly hack introduced in Haskell 98 to make the translation for do-notation a little simpler.
01:35:40 <Twey> Heh
01:35:47 <Twey> I see
01:37:12 <pao> I'm getting Prelude.head: empty list from HDBC ... it's quite difficult to understand what's going on :-(
01:37:23 <Cale> pao: ah, that can be a real pain
01:37:32 <Cale> pao: Does your code call head from anywhere?
01:37:56 <pao> Cale: my code has been trimmed down to 10 lines to reproduce the problem... 10 lines not using head :-(
01:38:02 <Cale> pao: okay
01:38:10 <Cale> pao: So it must be in the library.
01:38:36 <Twey> Shouldn't we try to avoid using 'error' er, anywhere?
01:38:46 <Twey> Since it's uncatchable
01:39:07 <pao> Cale: It would be extremely useful to know which expression is causing the error...
01:39:21 <pao> Cale: but I suspect it's not that easy...
01:39:24 <Cale> Twey: I try to avoid it as far as possible
01:39:36 <Cale> pao: You could compile with -prof -auto-all
01:39:45 <Cale> and run the program with +RTS -xc
01:39:55 <Cale> (if I'm remembering my flags correctly)
01:40:01 <pao> Cale: does that work for ghci as well?
01:40:24 <Cale> That will give a cost centre backtrace, which sometimes is less useful than it ought to be, but it's something.
01:40:31 <Cale> There's also the ghci debugger.
01:40:38 <Cale> :set -fbreak-on-exception
01:40:50 <Twey> http://hpaste.org/11502 — Does this look like a reasonable Monad instance for Either?
01:40:52 <Cale> and run the program with  :trace foo
01:41:01 <mm_freak_> hmm, some syntactic sugar for 'lift' would be nice
01:41:25 <Twey> I'm getting kind errors.
01:41:31 * Twey doesn't like kind errors.
01:41:34 <Cale> mm_freak_: There's already so much semantic sugar for it that it's hard to sort out what's going on half the time :P
01:41:35 * Twey is baffled by them.
01:41:45 <Cale> instance Monad (Either e) where
01:41:53 <Twey> Ah
01:42:02 <Twey> Why is that?
01:42:13 <mm_freak_> Cale: some people write clean code =)
01:42:22 <Cale> Monads are type constructors which take single types to single types.
01:42:36 <mm_freak_> although some people write clean code, which still nobody understands (you) ;)
01:42:39 <Cale> Either takes two types to a type.
01:42:50 <Cale> :k Either
01:42:50 <pao> Cale: I'm willing to invest some time on ghc debugger... is it worthwhile?
01:42:51 <lambdabot> * -> * -> *
01:42:52 <Twey> Oh right.
01:43:06 <Cale> mm_freak_: hehe
01:43:10 <Twey> Hmm
01:43:19 <Twey> Is it possible to hide instances?
01:43:21 <Cale> mm_freak_: Well, it might be good, yes. :)
01:43:27 <Twey> When importing modules
01:43:32 <Twey> I don't think I've ever seen that done
01:43:32 <Cale> Twey: No :/
01:43:38 <Twey> Cale: :-\
01:43:48 <Twey> That leaves me a bit high-'n'-dry then
01:43:54 <Twey> Oh, I could always make a MonadEither.
01:44:16 <Cale> Twey: oh?
01:44:19 <Twey> But then I lose the Either functions :-\  Hmm
01:44:22 <Deewiant> I suspect monadlib or some other mtl-alternative already has a better Monad instance for Either
01:44:28 <Cale> Twey: You can simply not import Control.Monad.Error
01:44:30 <Twey> Cale: It's conflicting with the one from Control.Monad.Error
01:44:36 <Twey> I'm using bits of Control.Monad
01:44:43 <Twey> It seems to call in Control.Monad.Error
01:44:47 <Cale> oh...
01:44:50 <Deewiant> or is it in Control.Monad.Instances?
01:44:53 <Cale> I didn't realise that.
01:46:33 <Cale> Uh, hmm
01:46:41 <mm_freak_> Cale: although sometimes i found your code quite enlightening…  i like going less explored paths
01:46:42 <Cale> On 6.8.2 I have no problems with that.
01:47:15 <Cale> (Importing Control.Monad and writing an instance for Either e)
01:47:18 <Twey> I'm also using 6.8.2...
01:47:19 <Twey> Oh!
01:47:29 <Twey> I'm an idiot
01:47:39 <Twey> I was in GHCi with Control.Monad.Error imported.
01:47:46 <Cale> ah
01:48:59 <mm_freak_> (btw, writing C code after a few weeks of haskell sucks…  i often write "return ();" or "int main() = ")
01:49:40 <Twey> Heh, ouch, mm_freak_
01:50:11 <Cale> Hehe :)
01:50:19 <Cale> I can sympathise with that
01:52:11 <Twey> Oh dear
01:53:43 <Twey> Hm
01:53:46 <Twey> How peculiar
01:54:24 <Cale> What's up?
01:54:46 <Twey> No problems if I do `Left v >>= _ = Left v`, but if I do `v >>= _ = v` or `v@(Left _) >>= _ = v`, it doesn't like it at all — gives me a type error about types 'a' and 'b' not matching
01:54:51 <Cale> right
01:55:00 <Cale> Because there's more than one Left v
01:55:07 <Twey> Surely those should be identical?  A Left is all it can be
01:55:13 <Cale> I was surprised by that at first too :)
01:55:51 <Cale> Suppose that v :: t, then for every type a, there is Left v :: Either t a
01:55:52 <Twey> What are the types 'a' and 'b'?
01:55:57 <Twey> Right
01:56:12 <Cale> (>>=) :: Either e a -> (a -> Either e b) -> Either e b
01:56:34 <Cale> and so since your Left v :: Either e a, and you want Left v :: Either e b, you have to do that.
01:57:06 <Twey> ... hmn
01:57:22 <Twey> I see
01:57:24 <Twey> Sort of :-P
01:58:48 <Cale> I can imagine it working differently, but I suppose the typing rules would have to be different.
02:06:25 <Twey> How about: can I define a Show instance for a list-based type synonym?  It currently conflicts with the [a] instance
02:07:48 <C-Keen> a type synonym is just that: a synonym. you need data types for instances
02:08:02 <Twey> C-Keen: Not with -XTypeSynonymInstances :)
02:08:37 <C-Keen> ok
02:09:13 <pao> can anyone suggest the best solution for interfacing postgresql?
02:09:44 <pao> if I'm not wrong the contenders are HaskellDB+HSQL, HDBC, Takusen
02:09:45 <Cale> Twey: hmm... -XTypeSynonymInstances shouldn't let you do anything you couldn't have done by unravelling the synonym yourself first.
02:10:11 * Twey nods.
02:11:02 <Cale> pao: btw, if your program is something that I could run, I could try to find the bug in the library.
02:11:03 <mmorrow> pao: Takusen is worth the effort it takes to figure howtf to use it :)
02:11:31 <mmorrow> *..figure out howtf..
02:11:46 <pao> Cale: I'll try to pack a small db dump and 10 lines code... thanks...
02:12:53 <pao> mmorrow: is takusen so much complicated?
02:12:55 <mmorrow> pao: there a minimal SQLite example in the Takusen code somewhere. i played with that for a while and it got me bootstrapped
02:13:29 <Cale> pao: head and tail are extremely evil for this reason - it's why I basically always recommend pattern matching unless you are sure you could prove that they would always succeed
02:14:06 <pao> mmorrow: I feed I'm very inspired by iteratee, fold enumerator and stuff ... it feels so "functional" ... but I have to admit that I'm a newbie and haven't studied all that stuff yet...
02:14:33 <pao> Cale: lesson learned :-)
02:14:44 <mmorrow> pao: it's is fairly complicated when looking at the whole thing as one piece, but once you figure out how to actually make a query and get results, it's great. also you probably want to read the oleg msg about "turning left folds inside out" or some title like that
02:15:57 <pao> mmorrow: I wonder why the iteratee concept is not considered the "standard" way to do IO in haskell... is it too "complex" as API or it has drawbacks?
02:16:05 <mmorrow> i use takusen when i can, hsql when i can't, and haskelldb mostly for its ability to suck out a def of an entire db and encode everything in the typesystem
02:16:25 <mmorrow> and haskelldb has a bunch of SQL prettyprinting code as well
02:16:44 <Cale> mmorrow: I take it you do a lot of database interconnectivity stuff then?
02:16:45 <mmorrow> it's painful to use haskelldb to actually query the db though :)
02:16:48 <pao> mmorrow: thanks for the 2 line review :-) very helpful
02:17:09 <mmorrow> Cale: a fair amount
02:17:28 <pao> mmorrow: which database do you use mostly?
02:18:17 <mmorrow> if i can choose i'd use postgres, but sadly a lot of mysql recently
02:18:30 <Twey> pao: Iteratee?
02:18:33 <Cale> The problem with oleg is that he is so much more willing to deal with complicated types than almost anyone else. ;)
02:18:50 <pao> :-)
02:18:51 <mmorrow> i /really/ want to get the unixodbc thing setup so i can use takusen with mysql
02:18:52 <Twey> Hahaha
02:19:14 <pao> Twey:  http://okmij.org/ftp/Streams.html
02:19:15 <Cale> withCursor :: (Typeable a, Statement stmt sess q, QueryIteratee (DBM mark sess) q i seed b, IQuery q sess b) => stmt -> i -> seed -> DBCursor mark (DBM mark sess) seed -> DBM mark sess a -> DBM mark sess a
02:19:24 <lambdabot> Title: Streams and Iteratees
02:19:25 <Cale> :)
02:19:27 <pao> Cale: argh :-)
02:19:47 <Cale> It's probably not *so* bad when you actually understand what's going on :)
02:20:00 <Cale> It's not as complicated as some of that HList stuff.
02:20:10 <pao> Cale: maybe it's easy to use once you start ignoring the signature :-)
02:20:14 <Cale> yeah
02:20:24 <Twey> Woah
02:20:46 <Cale> Or session types :)
02:21:15 <Deewiant> A type class with 5 parameters? Not bad.
02:21:28 <mmorrow> session types look really interesting
02:21:45 <mmorrow> i know next to nothing about them though as of now
02:22:03 <mmorrow> other than the paragraph description
02:22:06 <Cale> They mostly scare the hell out of me :)
02:22:11 <mmorrow> heh
02:22:51 <pao> mmorrow: ... and what about HDBC... have you ever used it?
02:23:11 <Cale> Well, it's more the fact that people are willing to attempt that in Haskell's typesystem.
02:23:11 <RayNbow> hehehe... someone hating the /= operator in Haskell on reddit... :p
02:23:18 <pao> can anyone provide a link to session types? is it oleg's work?
02:23:18 <Cale> oh?
02:24:20 <mmorrow> pao: not really. i used hsql first, then moved on to the others, but never went back and tried hdbc
02:24:43 <mmorrow> i've read the code over a bunch though
02:25:23 <Cale> Hmm, I can't find the site which I'd originally seen...
02:26:16 <Cale> http://video.google.com/videoplay?docid=-2432086335458210931 -- this seems like an interesting talk on them
02:26:17 <lambdabot> Title: Jesse Tov: Haskell Session Types with (Almost) No Class
02:26:21 <Deewiant> Anybody know if this can be done without a 'data'? http://hpaste.org/11503
02:28:32 <pao> Cale: thanks
02:28:37 <Cale> Deewiant: hmm, I'm not sure if I fully understand what's being accomplished here :)
02:29:02 <pao> mmorrow: opinions on hdbc based on your code reviews?
02:30:45 <Deewiant> Cale: Basically I've got a type like Foo2 and I'd like to write some code which depends on an instance like Mapping2. Then I could have write instances Mapping2 for [(k,v)], Map k v, and (hopefully, though I think this requires more extensions if it's even possible) IntMap v.
02:30:53 <Cale> Deewiant: Is this Foo meant to be something like an automaton?
02:30:59 <Deewiant> s/have write/have /
02:31:18 <Deewiant> Cale: The actual type is a trie.
02:31:43 <Cale> ah, okay
02:31:45 <Deewiant> I'm writing a trie library and hoping to avoid preprocessor tricks to get fast tries depending on what instances can be provided for the key type.
02:32:21 <Deewiant> For Eq k, the mapping is a [(k,v)]; for Ord k, it's a Map k v.
02:33:31 <Cale> Ah, okay, I'm lazy enough that I would just insist on Ord, but let's see :)
02:33:51 <Deewiant> Cale: Ah, but using IntMap for Enums is even better. :-)
02:34:35 <Cale> Right (though it's possible that soon we won't have to worry about that)
02:34:45 <Deewiant> How's that?
02:34:55 <Deewiant> A massive number of RULES in Data.Map? :-P
02:35:10 <Cale> Well, the type families stuff seems to provide a cleaner way forward in that respect.
02:35:25 <Cale> Though I'm not sure if you're allowed to have fall-through cases with type families.
02:35:29 <pao> http://hpaste.org/11503#a1
02:36:15 <pao> Deewiant: I'm using that structure to store a trie... can it be of any help?
02:36:44 <Cale> pao: The trouble is automatically choosing between a few implementations of tries based on what's known about the key type.
02:37:02 <Cale> pao: See, you're assuming just Eq, which means you have to linearly search through the keys at each level.
02:37:20 <pao> Cale: point taken
02:37:21 <Deewiant> Cale: not necessarily automatically: I can provide 'type's for the 3 cases.
02:37:22 <Cale> pao: With Ord, you can do a binary search in log time, and with Enum, you could use an IntMap
02:37:43 <Cale> Deewiant: You mean newtypes?
02:37:44 <mmorrow> pao: hdbc does look nice, and i'd use it for sure if it wasn't for takusen
02:38:18 <mmorrow> pao: here's two useful cli utils using haskelldb along with a misc haskelldb code snippet http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=310
02:38:46 <pao> mmorrow: thanks
02:38:53 <Deewiant> Cale: No, just types. type EnumTrieSet x = TrieSet IntMap x, or so. Then you should be able to just pass it to all the functions which want (KeyList k) => TrieSet k x
02:39:36 <Cale> ah, okay
02:40:11 <mmorrow> the thing about haskelldb also (from a querying point of view) is that (aside from it being super heavyweight) you can't express complicated sql queries with it
02:41:00 <Cale> mmorrow: It would be nice to have a proper straightforward embedding of SQL into Haskell as a combinator library, just so you couldn't mess up queries, and things like injection attacks would be nearly impossible.
02:41:05 <mmorrow> like nested 3 levels deep with where + group by + having + order by + nest again type stuff
02:41:35 <Deewiant> Cale: and I think that means that I need to use some funky or nonexistent extensions to be able to carry the constraint for x in that KeyList.
02:41:42 <Deewiant> But I'm not sure. :-P
02:41:46 <quicksilver> mmorrow: it doesn't entirely help that SQL is a series of broken standards layered over very poor decisions by large corporations
02:42:09 <Cale> @remember quicksilver it doesn't entirely help that SQL is a series of broken standards layered over very poor decisions by large corporations
02:42:09 <lambdabot> It is forever etched in my memory.
02:42:20 <mmorrow> Cale: totally. i have an sql parser half-finished (it can do select stmts), and i have a bunch on nonorganized code that's related to that
02:42:29 <mmorrow> s/on/of/
02:42:31 <quicksilver> mmorrow: meaning that until rather recently the standard dialect was totally inexpressive; so all useful implementations had to come up with their own local extensions to paper over that.
02:42:39 <mmorrow> a combinator lib though would be sweet
02:42:50 <quicksilver> ...and that leaves in a mess of subtly incompatible SQL dialects.
02:42:55 <Cale> mmorrow: hehe, and we could even combine it with a quasiquoter for people who are more familiar with SQL :)
02:42:56 <mmorrow> quicksilver: lol. yeah, SQL is hell
02:43:19 <quicksilver> I have some illformed plans for a better query language
02:43:24 <quicksilver> which would map more comfortably to haskell
02:43:33 <quicksilver> it would have a similar style type system, for starters.
02:43:49 <mmorrow> Cale: yesh! that's on my todo eventually list
02:44:06 <flux> quicksilver, you still would like to interface with existing systems, no? or would you also implement that side to, say, postgresql and mysql?
02:44:26 <mmorrow> quicksilver: hmm, i'd be very interested to hear about your thoughts on that.
02:44:33 <flux> I remember reading that IBM had a relational query language, which seemed quite neat
02:44:44 <flux> it was wayyyy less verbose than sql, and made more sense too ;)
02:44:52 <flux> but since that I've forgotten what its name was and can't find it :(
02:47:37 <Cale> Deewiant: Well, you could make this a newtype in a cheesy way.
02:47:51 <Cale> Deewiant: I'm not sure it's actually useful to do so :P
02:48:03 <Deewiant> Cale: Yes, one such cheesy way is the PairList at the top. ;-P
02:49:02 <Deewiant> Cale: Because I /can/ use the version at the top - I know the type Foo in advance, and it will always be Foo. It's just ugly as hell IMHO. :-P
02:50:05 <Cale> I suppose with the extremely recent (6.10) extensions you could have something like...
02:50:20 <Cale> class Mapping m k where
02:50:20 <quicksilver> flux: no, not particularly.
02:50:25 <quicksilver> flux: I'd write a new RDBMs.
02:50:39 <quicksilver> flux: one which actually supports the things the others claim to, like atomicity.
02:50:40 <Cale>    type Foo m k -- ?
02:51:05 <Cale> It's been a while since I read the associated types paper
02:51:41 <Deewiant> hmm
02:52:52 <dancor> has anyone gotten gtk2hs to work under ghc 6.10rc
02:52:54 <flux> quicksilver, well, it's nice to have goals, but isn't that a rather large task?-)
02:53:10 <flux> of course, it doesn't need to cover everything to be usable to lots of people
02:53:12 <dancor> s/to work/to build
02:53:12 <pao> quicksilver: It would be nice to have something with exactly the same API/semantics that STM but with concurrent multi-process access and persistency
02:54:32 <Deewiant> dancor: yep, haven't tested it though to see if it actually works or not :-P
02:55:36 <dancor> Deewiant: did you modify the darcs gtk2hs?  i've got: gtk/Graphics/UI/Gtk/Gdk/EventM.hsc:190:26:Module `Control.Exception' does not export `Exception(PatternMatchFail, IOException)' on 6.10.0.20081019
02:55:45 <Cale> Deewiant: yeah, that's how it would go.
02:55:57 <Cale> Deewiant: and then in the instances, you can specify which type it is.
02:56:03 <Deewiant> Cale: I am getting strange and unknown errors when defining the instance :-)
02:56:08 <Cale> Deewiant: which GHC?
02:56:11 <quicksilver> flux: Yeah. I always set my sights rather high :)
02:56:15 <Deewiant> Cale: and don't I still have to specify Foo in every instance?
02:56:19 <Deewiant> Cale: 6.10.0.20081007
02:56:23 <quicksilver> pao: indeed.
02:56:24 <Cale> Deewiant: hmm
02:56:32 <Cale> Deewiant: This is *supposed* to be working in 6.10
02:56:39 <Cale> It's broken in 6.8.x
02:56:39 <Deewiant> Cale: I probably just don't know what I'm doing.
02:56:41 <quicksilver> pao: integration with STM would be a good part.
02:56:57 <Cale> Deewiant: You have to specify the type in the instances, but at least it's not pinned down.
02:57:09 <Cale> Deewiant: So you're picking a specific type Foo for each instance.
02:57:16 <Deewiant> dancor: I'm on windows, so the darcs version with its autoconf was a no-go (autoconf working on windows is more work than rewriting gtk2hs from scratch)
02:57:24 <Deewiant> dancor: I just grabbed the latest release and modified that.
02:57:29 <dancor> ok
02:57:38 <Deewiant> dancor: there were some patches on the sourceforge mailing list which I applied.
02:58:11 <Cale> I should really get 6.10 so I can try this...
02:58:16 <Deewiant> Cale: I'd like to specify Foo at the function definition, not the class or instance. :-)
02:58:20 <Cale> I was hoping to hold out for the release :)
02:58:54 <ahunter2> Weird question: is it possible to derive Show, while special casing one constructor?
02:59:06 <Cale> ahunter2: no.
02:59:25 <Cale> ahunter2: You either define the whole instance yourself, or you derive it.
02:59:25 <ahunter2> I've got a type with twenty or so constructors (AST) and nineteen of them work nicely; the last is effectively | Fun (Expr -> ExpR)
02:59:29 <ahunter2> ....nuts.
02:59:40 <Cale> ahunter2: You could wrap that function in a newtype though.
02:59:47 <Cale> ahunter2: and write an instance of Show for that.
03:00:03 <ahunter2> Cale, yeah, seems like the only good option here
03:00:37 <Deewiant> Cale: what the "instance Mapping MapType key value" has to do, as I see it, is: specify constraints for key (Eq,Ord,Enum) and operations on MapType key value, without knowing of the value, and without having to make MapType into a data. :-P
03:00:49 <rog> is there any difference between 'forall a. (Typeable a) => a' and Dynamic?
03:00:58 <dancor> omg this is hideous.. stopEvent = liftIO $ throw (PatternMatchFail "EventM.stopEvent called explicitly")
03:01:06 <Cale> rog: yes
03:01:17 <dancor> CompleteMismatchedFailUseFail
03:01:27 <rog> they both seem to express the same thing
03:01:38 <Cale> rog: There's not many values which fall into the first type.
03:01:58 <Saizan> rog: Dynamic is exists a. Typeable a => a
03:01:59 <Cale> rog: Dynamic is a little more like  exists a. (Typeable a, a)
03:02:09 <Cale> (if that were even valid syntax)
03:02:56 <Cale> Together with an otherwise impossible to write operation that extracts the value from the existential...
03:03:11 <mmorrow> quicksilver: integration with STM would be awesome.
03:03:30 <rog> Saizan: that sounds very similar to my first type?
03:03:59 <Saizan> rog: exists is dual to forall
03:04:19 <rog> Saizan: sorry - my forall there was an existential qualification.
03:05:02 <rog> so i had something like: data X = forall a. (Typeable a) => X a
03:05:10 <Cale> yeah, okay
03:05:20 <Cale> They're similar, but try to write fromDynamic
03:05:21 <Saizan> exists a. a == forall r. (forall a. a -> r) -> r, so yeah something like X
03:05:35 <rog> Cale: it's trivial - just use cast.
03:05:54 <Anchakor> hi, I am looking for a functional language which aims for highest reusability (of modules - classes - so probably object oriented) and allows simple manipulation with parts of code - run one part of code as different process, maybe on different machine... any idea what language fits this most? (don't tell me haskell :))
03:06:09 <papermachine> modules /= classes
03:06:39 <Cale> Anchakor: that's probably too vague to pick anything out.
03:06:45 <qebab> indeed
03:06:53 <papermachine> further, object oriented doesn't imply highest reusability
03:07:29 <qebab> Anchakor: erlang might be worth a look, for the 'run one part of code as different process, maybe on different machine' thing. it's very easy to do things like that in erlang
03:07:31 <Anchakor> papermachine: well from oop view yes. what do you think module is?
03:07:46 <papermachine> Anchakor: Seeing as this is #haskell, I think modules are modules.
03:07:48 <rog> Cale: get (X a) = let Just b = cast a in b
03:07:50 <Saizan> rog: however Dynamic uses a different representation so that it doesn't have to call typeOf each time
03:08:06 <Cale> rog: Might need that to be case, but yeah, okay.
03:08:18 <rog> Saizan: ok. that's what i was wondering.
03:08:23 <qebab> a module is usually a a bunch of code, functions or classes or otherwise, that naturally belongs together, put together into a unit you call a module
03:08:31 <Anchakor> papermachine: I haven't done anything in haskell yet, I was talking about modules as from general modular programming point of view
03:08:31 <Cale> rog: I always forget that cast is part of the Typeable module.
03:08:34 <qebab> my view, anyway
03:08:42 <Cale> rog: It's actually not writable in terms of the Typeable class.
03:08:57 <quicksilver> mmorrow: someone hacked together some STM primitives for one of the existing DB libraries.
03:08:58 <Cale> (alone)
03:09:02 <quicksilver> mmorrow: I don't remember who.
03:09:32 <Anchakor> qebab: for me module is every object in code
03:10:00 <rog> Saizan: the thing is if you're using Typeable instead of Dynamic, you can have other classes too (e.g. Show). but if Dynamic is much more efficient, maybe it's best to keep a tuple.
03:10:01 <qebab> Anchakor: what's on object, then?
03:10:06 <qebab> an*
03:10:23 <Anchakor> qebab: anything that has a value
03:10:31 <papermachine> Anchakor: I think your question is pretty much unanswerable.
03:11:03 <Saizan> rog: i'm actually wondering the same
03:11:11 <mmorrow> quicksilver: i think sclv said he was trying to sync up STM atomically and transactions in an external db when he ran into this: http://hackage.haskell.org/trac/ghc/ticket/2401
03:11:13 <lambdabot> Title: #2401 (unsafeIOToSTM discards exception handlers.) - GHC - Trac
03:11:16 <Anchakor> ok, can someone tell me differences between haskell, erlang and scala?
03:11:22 <qebab> Anchakor: so a module is everything that has a value. That's a pretty useless definition of module, in my opinion.
03:11:34 <quicksilver> mmorrow: yeah, that's right.
03:11:47 <mmorrow> quicksilver: oh neato..
03:11:48 <mmorrow> er
03:11:57 <jauaor> Anchakor:  Haskell is purely functional ... as one of the main differences
03:12:02 <mmorrow> is that who you were thinking of :(
03:12:05 <mmorrow> ?
03:12:34 <qebab> Anchakor: there are many... For one thing, Haskell uses a different typeinference algorithm than Scala, and Erlang is dynamically typed. (I *think* I got this right)
03:12:42 <Anchakor> qebab: well it was not exactly good definition, but I wanted to say that even one function is module for me
03:12:51 <Saizan> Anchakor: in general a module is a unit of a system with a well defined interface
03:13:05 * mmorrow consults the googlemachine just in case there's some STM-to-DB code lurking about
03:13:06 <Anchakor> Saizan: that sounds like class
03:13:10 <jauaor> Anchakor:  I see what you mean, but that can really leads to lot of confusions
03:13:51 <Saizan> Anchakor: a class is more than that, it's also a type, and has mutable state associated with it
03:14:42 <jauaor> Some academic (mainly software engineering) lectures tend to call module to a set of instructions .... that's very twisted for most of what you will find out there
03:14:46 <Cale> Don't objects have mutable state associated with them, and not classes?
03:15:00 <quicksilver> Cale: most languages allow classes to have mutable state
03:15:04 <Anchakor> Saizan: ok, that sounds like UML interface :)
03:15:10 <quicksilver> althoguh arguably they are just namespaced globals
03:15:22 <quicksilver> (unless that language supports creation of fresh classes at runtime)
03:17:39 <Saizan> yeah, the so needed global IORefs so that you can implement the singleton pattern, brr
03:18:07 <Saizan> s/needed/wanted/
03:18:20 <papermachine> Yay singleton
03:18:24 <papermachine> wait
03:20:09 <Anchakor> hmm what languages were designed by observing problem-solving process of normal humans? :)
03:20:58 <rog> quicksilver: you might be interested: i went with your suggestion about PValues, but with an open ended definition of imprecision functions. i'm still not entirely happy though. i've essentially lost all my static typing. i might as well be using lisp... http://hpaste.org/11504#a0
03:21:03 <Anchakor> even if functional programming seems more elegant, it isn't as natural as I want it... :)
03:21:17 <Deewiant> Cale: I'm not quite getting how this would work with associated types... what'd be the type signature of 'empty' in class Mapping, for instance?
03:21:41 <rog> Anchakor: numbers are unnatural...
03:22:07 <jsn> Anchakor: how long have you been working with it?
03:22:27 <jsn> Anchakor: programming seems unnatural to a lot of people...
03:23:22 <Anchakor> jsn: not much, what language you reccomend?
03:23:46 <jsn> Anchakor: well, can you tell me a little more about what you want to know?
03:23:51 * jauaor sees Cale coming with the dish-washer analogy
03:24:46 <jsn> Anchakor: if you are interested in distributed systems, for example, i would encourage you to look at Erlang
03:24:47 <Saizan> rog: where do you want more typedness? maybe you can recover some making PVaule a GADT
03:24:51 <jauaor> Anchakor: functional programming tend to be very natural ... more than imperative one
03:25:17 <jsn> Anchakor: if you are interested in understanding type systems and functional programming for its own sake, i recommend haskell
03:25:22 <quicksilver> rog: not quite my suggestion :)
03:25:29 <quicksilver> rog: my PValue had a parameter.
03:25:37 <Anchakor> jsn: I am interested at as modular, reusable, extensible, simple, human understandable, decentralized systems :)
03:25:38 <quicksilver> rog: so you could distinguish between PValue Double and PValue Int
03:25:45 * jauaor recommends Haskell if you want to learn programming in general
03:26:08 <jsn> Anchakor: well, there is no language for that, as yet
03:26:25 <jsn> Erlang has the libraries, for sure -- and a lot of nice concepts
03:26:45 <Anchakor> jsn: aah, you think the development is not there yet?
03:27:17 <rog> quicksilver: i tried that - the problem with that approach was that i had to explicitly mention all possible types of imprecision functions in the data type, and enumerate each of them in all the code.
03:27:17 <jsn> Anchakor: it doesn't even have hierarchical modules
03:27:55 <Anchakor> jsn: by it you mean erlang or all programming languages (or haskell?)
03:28:02 <jsn> Anchakor: i mean erlang
03:28:04 <Twey> @pl [0..6] >>= \a -> [0..6] >>= \b -> return (a, b)
03:28:04 <lambdabot> (`fmap` [0..6]) . (,) =<< [0..6]
03:28:28 <jsn> i learned a lot by learning Erlang but i also found it painful to program in
03:28:39 <rog> Saizan: i did manage to express the whole thing statically using HList. i just didn't manage to integrate it back into an existing module (the error messages were unmanageable, and the whole thing untenable)
03:29:09 <jsn> Anchakor: so, i leave you with that, i guess
03:29:27 <Saizan> rog: yeah, but GADT /= HList
03:29:55 <rog> Saizan: i haven't looked at GADTs yet...
03:30:58 <Anchakor> jsn: do you know which languages went further in where erlang is not what I want?
03:31:28 <jsn> Anchakor: uhm, i can't say i know what you want
03:31:53 <jsn> Anchakor: let's have this conversation in #haskell-blah
03:32:01 <Anchakor> ok
03:33:58 <Saizan> rog: this is a nice post about them http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
03:34:00 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
03:34:55 <rog> Saizan: ta
03:38:19 <Shurique> is there a function that converts a Day (from Data.Time.Calendar) to its respective weekday (0..6)?
03:38:40 <augustss> fromEnum?
03:39:51 <quicksilver> Shurique: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar-WeekDate.html
03:39:55 <lambdabot> Title: Data.Time.Calendar.WeekDate, http://tinyurl.com/59x3n5
03:40:03 <augustss> sorry, i was thinking of week days
03:40:22 <Shurique> quicksilver: ah, thanks
03:46:20 <mopped> Can anyone help explain a function to me? I'm just unable to understand how it gets the answer, comb 0 _ = [[]]
03:46:23 <mopped> woops
03:46:24 <mopped> sorry
03:46:26 <mopped> comb n l = [x:xs | x:ys <- tails l, xs <- comb (n - 1) ys]
03:46:29 <mopped> *Main> comb 1 [1..5]
03:46:39 <mopped> http://hpaste.org/11506 was supposedly the paste
03:47:20 <mopped> From what I can see, x would be [1, 2, 3, 4, 5] and it would cons onto [[]] (as n would be 0), which surely isnt [[1], [2], [3], [4], [5]]
03:47:41 <qebab> mopped: it's supposed to find 'n-choose-k' from the list yeah?
03:47:48 <mopped> yeah
03:48:07 <swiert> Shurique: toWeekDate?
03:48:56 <mopped> does (x:ys) <- tails l not behave like usual? I thought x would take the head of tails [1, 2, 3, 4, 5] and then cons it onto [[]], but eh
03:49:06 <rog> Saizan: that was a very interesting and relevant post, thanks. i still haven't quite worked out whether i can express my problem neatly with GADTs tho'.
03:54:32 <Cale> mopped: (x:ys) <- tails l  means to pick a tail of l and pattern match it against (x:ys)
03:54:47 <Cale> mopped: so x will be an element of l, and ys will be all the elements after it.
03:55:45 <mopped> so (x:ys) <- tails l itereates over every item in the list (tails l)?
03:57:11 <Cale> yes
03:58:08 <Cale> > [(x:ys) | (x:ys) <- tails [1..5]]
03:58:09 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
03:58:23 <mopped> aha
03:58:28 <Cale> > [(x:ys,y) | (x:ys) <- tails [1..5], y <- ys]
03:58:30 <lambdabot>   [([1,2,3,4,5],2),([1,2,3,4,5],3),([1,2,3,4,5],4),([1,2,3,4,5],5),([2,3,4,5]...
03:58:32 <pjdelport> mopped: "and then cons it onto [[]]" ?
03:58:39 <EvilTerran> > tails [1..5]
03:58:40 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
03:59:09 <Cale> > [(x,y) | (x:ys) <- tails [1..5], y <- ys]
03:59:11 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
03:59:47 <Cale> > [(x,y,z) | (x:ys) <- tails [1..5], (y:zs) <- tails ys, z <- zs]
03:59:48 <lambdabot>   [(1,2,3),(1,2,4),(1,2,5),(1,3,4),(1,3,5),(1,4,5),(2,3,4),(2,3,5),(2,4,5),(3...
03:59:51 <EvilTerran> > [(x,y,z) | x:ys <- tails [1..5], y:zs <- tails ys, z <- zs]
03:59:53 <lambdabot>   [(1,2,3),(1,2,4),(1,2,5),(1,3,4),(1,3,5),(1,4,5),(2,3,4),(2,3,5),(2,4,5),(3...
03:59:53 <EvilTerran> heh
04:00:04 <Axman6> does anyone have a nice way to get all the permutations of list? like [1,2,3] -> [[1,2,3],[1,3,2], [3,2,1]..]
04:00:14 <besiria> how can i write a large integer in multiple lines ?
04:00:36 <Cale> Axman6: Start with writing select :: [a] -> [(a,[a])] which gives each item from the list together with the remainder of the elements.
04:00:58 <rog> Saizan: looking at the source, it seems that cast and fromDyn would have very smiliar performance characteristics. Dynamic stores the type with the value, so it might be more efficient if you had a high fromDyn/toDyn ratio, i guess. depends on how efficient typeOf is.
04:01:02 <Cale> besiria: I suppose you could use read and concat.
04:01:15 <Cale> Or just read, with string gaps.
04:01:19 <Axman6> ah, i was more curious to see people's minds go wild on the problem, rather than needing a solution ;)
04:01:24 <romildo> Hi.
04:01:46 <Cale> hi
04:02:00 <mopped> hmm, the function does quite a lot for quite little
04:02:00 <EvilTerran> Axman6, unfortunately, that one seems to lack a particularly elegant solution
04:02:03 <romildo> I am needing help setting up a ComboBoxEntry widget with gtk2hs.
04:02:22 <EvilTerran> Axman6, so i think you may find it quite hard to drum up enthusiasm for that particular problem
04:02:35 <Axman6> lame
04:02:36 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
04:02:37 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
04:03:03 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (StateT select) [1,2,3]
04:03:04 <lambdabot>   [1,2,3]
04:03:15 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 2 (StateT select)) [1,2,3]
04:03:17 <lambdabot>   [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]
04:03:22 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 3 (StateT select)) [1,2,3]
04:03:23 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
04:03:31 <Saizan> rog: i'm inclined to think that if you're already using other typeclass methods packed in the existential typeOf won't add significant overhead
04:03:38 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM (StateT select) [1,2,3]) [1,2,3]
04:03:39 <lambdabot>   Couldn't match expected type `a -> StateT s m b'
04:03:54 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM (const (StateT select)) [1,2,3]) [1,2,3]
04:03:55 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
04:04:14 <Cale> There's my favourite way :)
04:04:45 <EvilTerran> i prefer the replicateM version, tbh :P
04:05:07 <Cale> But it requires finding the length.
04:05:07 <rog> Saizan: me too.
04:05:30 <romildo> I have written the test program at http://hpaste.org/11507 to text the ComboBoxEntry widget from gtk2hs. I anybody cares to test it and help me finish it, I will be gratefull.
04:05:33 <EvilTerran> true
04:05:49 <Cale> The replicateM version is handy in order to get permutations of k elements though.
04:05:50 <Axman6> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
04:05:51 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
04:05:55 <romildo> s/I anybody/If anybody/
04:06:51 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; perms [] = [[]]; perms xs = [(y:zs) | (y,ys) <- select xs, zs <- perms ys] in perms [1,2,3]
04:06:52 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
04:07:08 <Cale> There's another version which is perhaps more elementary :)
04:07:34 <mopped> Can you explain why the comb returns [[]] instead of []? (again, probably incorrect thinking) on comb 2 [1..5], 1:(head (tails [2, 3, 4, 5])) = 1:2:(comb 0 [..]) = 1:2:[[]], which doesnt seem right :P
04:07:48 <Cale> mopped: sorry?
04:08:15 <Cale> mopped: Why  comb 0 xs = [[]] ?
04:08:21 <mopped> yeah, as opposed to just []
04:08:27 <Cale> mopped: Because that's the list of all combinations of 0 elements of xs
04:08:36 <Cale> There is exactly one such combination.
04:08:40 <Cale> The empty one.
04:08:46 <mopped> hmm
04:09:01 <mopped> So how does it 'build' the list?
04:09:10 <Cale> Don't worry about how it builds it.
04:09:22 <Cale> :)
04:09:24 <mopped> ok ;)
04:09:35 <Cale> Let's have another look at the code and see what it means
04:09:44 <Twey> The thing that annoys me most about Haskell is how you write a few lines of beautiful pure code that hold basically all your logic, and you're thinking 'wow, this is such a short program!  <3 Haskell!' and then you start doing IO and it takes hundreds more lines :(
04:09:45 <Cale> comb n l = [x:xs | x:ys <- tails l, xs <- comb (n - 1) ys]
04:10:23 <quicksilver> Twey: I think you're doing it wrong :P
04:10:37 <Cale> It says that the combinations of n elements of l are the lists x:xs where x:ys is a tail of l, and xs is a combination of n-1 elements of ys
04:11:05 <Twey> quicksilver: Am not :(  I'll show you once I get this into a compileable state.
04:11:08 <Cale> Don't follow the recursion down. Just *trust* that it works.
04:11:19 <mopped> ok
04:12:28 <Baughn> Twey: In my experience, that IO code still takes far less code than in other languages. ;)
04:12:54 <Cale> Twey: Are you comfortable/familiar with all the stuff in Control.Monad yet?
04:13:13 <Cale> Twey: That's where all your control structures are. IO code can be tedious without them.
04:13:24 <Twey> Baughn: Oh, sure
04:13:35 <Baughn> Twey: Oh, and you'll want Control.Applicative.<$> too
04:13:35 <Twey> Baughn: Still enough to be irritating, though :-P
04:13:49 <Twey> Cale: Vaguely only, I'll have another browse :)
04:13:51 <Baughn> Which is just fmap, but it's handy
04:13:51 <Twey> Thanks both
04:15:11 <Philippa> Twey: sounds like you've got a fairly heavy UI over some fairly simple computation?
04:15:36 <Philippa> and yeah, the stuff about control structures is important. mapM and foldM are your friends
04:15:45 <Baughn> Twey: http://hpaste.org/11508 <-- It's not actually, IO, but here's an example of what I'd like to think is decent monadic code
04:15:50 <Baughn> (If it isn't, someone please tell me. :P)
04:16:34 <Philippa> seems to be fairly similar in style to mine
04:16:42 <Baughn> ..why does hpaste have an 157-line limit, anyway? That's so.. random.
04:18:03 <Twey> Philippa: It's not heavy at all -P
04:18:05 <Twey> :-P**
04:18:43 <Twey> It's a fairly small app.  A little CLI dominoes game, just for the sake of it.
04:18:47 <quicksilver> Baughn: 5k, rather than 'x' lines.
04:19:30 <Baughn> quicksilver: I wasn't planning to uuencode ascii art and use it as a file server, honest!
04:19:45 <Twey> Hahahaha
04:20:18 <quicksilver> Baughn: I think it's widely regarded (now) as being too small a limit.
04:20:23 <quicksilver> hpastetwo doesn't have it.
04:20:33 <quicksilver> I'm not sure what their reason was at the time.
04:25:52 <Axman6> Cale: heh, i think i came up with something, it works... but i have no idea how, i was just hacking :P perm [] = []; perm (x:xs) = (x:xs) : [y:zs | (y:ys) <- perm xs, zs <- perm (x:ys) ]
04:26:17 <Twey> @hoogle a -> [[a]] -> [a]
04:26:17 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:26:17 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
04:26:17 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
04:26:18 <Axman6> ah, seems to give duplicates
04:27:02 <Twey> Hm :(  Is there a function foo such that foo 'z' ["abc", "def", "ghi"] == "abczdefzghi"?
04:27:12 <RayNbow> :t intersperse
04:27:13 <lambdabot> forall a. a -> [a] -> [a]
04:27:20 <Twey> Not quite the same
04:27:38 <Twey> > intersperse 'z' ["abc", "def", "ghi"]
04:27:39 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
04:27:39 <Cale> Axman6: also, your base case seems wrong
04:27:44 <RayNbow> > concat $ intersperse ['z'] ["abc", "def", "ghi"]
04:27:45 <lambdabot>   "abczdefzghi"
04:27:46 <Twey> > intersperse 'z' "abcdefghi"
04:27:47 <lambdabot>   "azbzczdzezfzgzhzi"
04:27:51 <Axman6> it probably is
04:27:59 <Shurique> > intercalate "z" ["abc", "def", "ghi"]
04:28:00 <lambdabot>   "abczdefzghi"
04:28:04 <Twey> RayNbow: That's just intercalate :-P
04:28:11 <Cale> Axman6: there's one permutation of the empty list, it's the empty list :)
04:28:17 <Cale> Axman6: So it should be [[]]
04:28:33 <Saizan> Twey: intercalate . return
04:28:34 <Cale> This is related to the fact that 0! = 1
04:28:51 <Axman6> ah yes
04:30:53 <RayNbow> > (intercalate . (:[])) 'z' ["abc", "def", "ghi"]   -- monkey face :p
04:30:55 <lambdabot>   "abczdefzghi"
04:31:15 <quicksilver> OMG don't intercalate the monster.
04:31:18 <quicksilver> He doesn't like that.
04:34:58 <Twey> Hahahaha
04:35:24 <Twey> I was hoping for a way that didn't involve creating a new list around the character
04:35:30 <Twey> But OK, intercalate works I guess :)
04:52:35 <titto> I am looking for a 'prefix map', a map with a  "lookupByPrefix :: prefix -> map -> [(key,val)]" where all returned keys have prefix 'prefix', so that for example lookupByPrefix "has" might  return [('haskell',..),('hasky'..)] etc. Can anyone advice if there is already an implementation available somewhere?
04:53:28 <Deewiant> titto: I'm writing an implementation (the data structure is called a trie) but it'll probably be a while before it's done
04:55:36 <Cale> In the meantime, it is possible to use a Data.Set for this, I believe.
04:56:12 <mopped> What does the term: disjoint mean?
04:56:22 <Cale> mopped: having no elements in common
04:56:35 <Deewiant> Cale: in the meantime, can you help me with how associated types would work for me? What'd be the type signature of 'empty' in class Mapping, for instance?
04:56:48 <binarycodes> please recommend me a book to learn haskell from
04:57:09 <Deewiant> binarycodes: http://book.realworldhaskell.org/
04:57:09 <binarycodes> i know programming and data structures, just need to get going with haskell
04:57:10 <lambdabot> Title: Real World Haskell
04:57:16 <jsn> binarycodes: real world haskell
04:57:22 <binarycodes> ah, thanks
04:57:22 <SamB_XP> binarycodes: ohhoho!
04:57:30 <Cale> binarycodes: Well, if you're looking for a dead tree book, Graham Hutton's book is supposed to be very good.
04:57:38 <binarycodes> SamB_XP: huh?
04:57:39 <SamB_XP> little do you suspect !
04:57:47 <Cale> binarycodes: Online, there's RWH, as well as a new tutorial...
04:57:51 <Cale> @where lyah
04:57:51 <lambdabot> www.learnyouahaskell.com
04:57:51 <BONUS> real world haskell owns
04:58:07 <rog> @pl  (\ r k -> insert k () r)
04:58:07 <lambdabot> (line 1, column 22):
04:58:07 <lambdabot> unexpected " "
04:58:07 <lambdabot> expecting variable, "(", operator or ")"
04:58:10 <BONUS> theres that too, hehe
04:58:15 <Cale> and many others which you can find from the Books and Tutorials page from haskell.org
04:58:17 <rog> what's wrong with that?
04:58:26 <Cale> I suppose the most common are
04:58:30 <Cale> @where yaht
04:58:30 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:58:33 <Cale> @where wikibook
04:58:34 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:58:44 <Cale> as far as other tutorials go :)
04:59:00 <binarycodes> hmm, thanks guys
04:59:03 <rog> (i think it's lambdabot getting it wrong)
04:59:04 <BONUS> when learning haskell i found that its great to use a combination of resources
04:59:06 <BONUS> and not just one tutorial
04:59:11 <Deewiant> then there's of course www.haskell.org/tutorial
04:59:13 <BONUS> cause each tutorial puts it a bit differently
05:00:02 <dolio> Deewiant: empty :: Map k v
05:00:50 <Deewiant> dolio: Do you know the context? :-P
05:01:09 <BONUS> rog: I think you have to say Map.insert
05:01:38 <BONUS> otherwise it assumes insert from Data.List
05:01:39 <dolio> If it's in a class, you don't need a context for k.
05:01:47 <Deewiant> dolio: I meant the context of my question.
05:01:59 <BONUS> @pl (\r k -> Map.insert k () r)
05:01:59 <lambdabot> (line 1, column 25):
05:01:59 <lambdabot> unexpected " "
05:01:59 <lambdabot> expecting variable, "(", operator or ")"
05:02:05 <dolio> You're writing generalized tries?
05:02:18 <dolio> With type families?
05:02:25 <Deewiant> dolio: it's http://hpaste.org/11503 and what I talked to Cale about ~2 hours ago.
05:02:27 <Deewiant> sort of
05:02:32 <rog> @pl  (\ r k -> blahblah k () r)
05:02:32 <lambdabot> (line 1, column 24):
05:02:32 <lambdabot> unexpected " "
05:02:32 <lambdabot> expecting variable, "(", operator or ")"
05:02:34 <Cale> Deewiant: Um, that should be the same, I think.
05:02:54 <Cale> Deewiant: Because Foo isn't involved there?
05:03:16 <Deewiant> Cale: true, good point. and singleton?
05:03:36 <Cale> Well, it will depend on the type Foo which you define in your instance.
05:03:45 <rog> BONUS: it doesn't like the (). substitute 0 and it compiles ok. strange.
05:03:51 <rog> s/compiles/parses/
05:03:53 <BONUS> weird!!
05:03:58 <Cale> Deewiant: its type will look just the same
05:04:13 <Cale> Deewiant: k -> Foo m k -> m k, but now Foo is an associated type
05:04:45 <Cale> Or, perhaps this isn't quite what you're looking for.
05:04:47 <Deewiant> Cale: hmm, will PairList be the same newtype as well?
05:04:58 <Cale> There might be a more straightforward way to work this...
05:05:07 <mopped> What's the name of the 'count' function in standard prelude, ie count 1 [1,1,2,3,1] = 3?
05:05:08 <Deewiant> Cale: I'm wondering if this is actually going to help me at all over just my original newtype approach. :-P
05:05:28 <Cale> mopped: Combine filter with length
05:05:34 <BONUS> mopped: idk, just do length . filter
05:05:36 <BONUS> agh beaten
05:05:42 <mopped> aha ok :P
05:05:52 <BONUS> > length .filter (==1) $ [1,1,2,3,1]
05:05:53 <lambdabot>   3
05:09:21 <titto> I see that there are a few implementation of Trie floating around, but is there no 'standard' one?
05:09:35 <Deewiant> Cale: how is this actually different, in practice, from my newtype at http://hpaste.org/11503 ?
05:11:36 <Deewiant> titto: yeah, there's no library around AFAIK. (If there is, tell me and I won't necessarily have to write one! :-P)
05:12:44 <titto> deewiant: well, that's a scandal :-)
05:14:27 <dolio> I might have one on my hard drive...
05:14:31 <Cale> Deewiant: http://hpaste.org/11509
05:14:31 <dancor> isn't there MemoTrie?
05:14:47 <dolio> Someone was supposed to be making a nice trie library for their summer of code project.
05:14:49 <Cale> Deewiant: I'm not sure if that solves your problem.
05:15:05 <Deewiant> Cale: interesting, let's see.
05:15:20 <Cale> er, there might be an issue with that
05:15:32 <Cale> Might need more EqKey/OrdKey constructors
05:15:49 <Cale> (I didn't test it at all, and wrote it in the hpaste box)
05:15:59 <Deewiant> Cale: the type in Key fails due to no v
05:16:17 <Cale> ah
05:16:28 <dolio> Should be 'type Mapping k :: * -> *' I believe.
05:16:33 <Cale> hmm, actually, do you have a v in your cake?
05:16:35 <Cale> case*
05:16:41 <Deewiant> heh, cake
05:16:50 <Cale> hehe
05:17:09 <dolio> And in the instances, it should be 'type Mapping (EqKey k) v = ...' and such, I think.
05:17:28 <Cale> yeah
05:17:41 <Cale> (that's what I was referring to about the constructors ;)
05:17:44 <Deewiant> Well, the idea was that there would be a v, I'd just know that it's always the same and that class probably wouldn't be exported in such a form that it could take any v except the one I want (namely TrieSet/TrieMap)
05:17:54 <Deewiant> or something like that, anyway
05:18:30 <titto> Summer of code 2008 "Generic tries. Jamie Brandon is working on a library for efficient maps using generalized tries."
05:18:47 <Deewiant> dolio: no love, "Number of parameters must match family declaration; expected 1" :-/
05:19:06 <dolio> Which is that an error for?
05:19:17 <Deewiant> dolio: type Mapping (EqKey k) v
05:19:26 <Deewiant> and likewise for OrdKey
05:19:28 <dolio> Yeah. That one might be a problem.
05:19:36 <dolio> I think you can't actually use the v in your definition.
05:19:46 <dolio> So you need like 'type Mapping k = Map k'.
05:19:55 <dolio> But that's a problem for the [(k,v)] case.
05:20:28 <dolio> Er, 'type Mapping (OrdKey k) = Map k'.
05:20:32 <Deewiant> titto: I think that's somewhat different, but I'm not sure
05:20:48 <Deewiant> dolio: Yeah, I can't partially apply [(k,v)] :-/
05:20:55 <Deewiant> I need a type-level lambda
05:21:02 <dolio> Totally.
05:21:09 <Deewiant> :-P
05:21:28 <Deewiant> [] . (,) k
05:22:13 <dolio> Associated data might be the way to go.
05:22:27 <dolio> Unless you don't mind writing a newtype around [(k,v)] and that's the only case you need one.
05:22:40 <Deewiant> I don't mind newtypes, they have no overhead
05:22:56 <Deewiant> datas I do mind which is why I started this whole discussion :-)
05:23:27 <dolio> Well, you can use a newtype for associated data.
05:23:40 <Deewiant> So how would that look
05:24:29 <dolio> The question is really whether there are any cases for Key where you'll want a new data type, in which case it's probably easier to write it directly in the class than writing it separately and using an associated type.
05:24:52 <dolio> Hold on. Let me experiment a sec...
05:25:11 <Deewiant> dolio: Hmm, I'm not sure what you mean.
05:34:15 <titto> Brandon's generic map code is at: http://code.google.com/p/google-summer-of-code-2008-haskell/downloads/detail?name=Jamie_Brandon.tar.gz&can=2&q=
05:34:17 <lambdabot> Title: Jamie_Brandon.tar.gz - google-summer-of-code-2008-haskell - Google Code - GMap - ..., http://tinyurl.com/56quax
05:34:32 <Deewiant> titto: or at http://code.haskell.org/gmap/
05:34:33 <lambdabot> Title: Index of /gmap
05:34:42 <dolio> Deewiant: http://hpaste.org/11509#a2
05:34:46 <Deewiant> they don't look like tries at all, I don't know what those are. :-P
05:34:55 <Deewiant> definitely different from what I'm doing. :-P
05:35:39 <dolio> The summer of code thing didn't take the normal generalized trie tack.
05:36:09 <dolio> Instead it was breaking data down into bit streams or something, and using a trie on that.
05:36:29 <dolio> Which I guess they decided would optimize better?
05:36:57 <Deewiant> dolio: Hmm, is MaybeMap making Maps out of Sets or what is that?
05:37:11 <Deewiant> Looks weird :-P
05:37:28 <dolio> MaybeMap is just the generalized trie for Maybe.
05:37:59 <dolio> Trie(1 + k) v = Maybe v + Trie(k) v
05:38:02 <dolio> Er, *.
05:38:29 <dolio> MaybeMap is the constructor.
05:38:30 <Deewiant> Sounds like something I should be able to understand but am not :-P
05:38:48 <Deewiant> I'm just making fast maps/sets with list keys :-)
05:39:14 <dolio> Well, you can generalize from lists to arbitrary algebraic datatypes. :)
05:39:23 <dolio> Actually, let me write the list instance...
05:39:28 <Deewiant> I'm sure, but that's tricky. :-P
05:41:51 <dolio> http://hpaste.org/11509#a3
05:42:38 <Deewiant> I think this is going in a direction I'm not meaning to go :-P
05:43:37 <dolio> Does that not look like the trie you're used to?
05:43:49 <Deewiant> data TrieSet mapping a = Tr a (mapping a (TrieSet mapping a))
05:43:53 <Deewiant> that's a trie. :-P
05:44:46 <dolio> So, that's a type for sets of as?
05:44:52 <Deewiant> sets of [a]s
05:45:16 <dolio> Oh, right.
05:45:31 <dolio> And mapping is a map with as as keys.
05:45:37 <Deewiant> Yep.
05:45:39 <dolio> Or, some kind of map.
05:46:03 <dolio> Anyhow, TrieSet a = Mapping [a] () for my definition of mapping.
05:46:04 <SamB_XP> as as keys, mmm ;-P
05:46:19 <Deewiant> And I'm looking for a way to write my code so that they can expect "Mapping mapping => TrieSet mapping a", with instances of Mapping for [(k,v)], Map k v, IntMap v.
05:46:51 <SamB_XP> hmm
05:47:13 <SamB_XP> last time I tried something that resembled that at all ... I got a really loose type for map!
05:47:35 <mattam>  
05:47:36 <mattam>  
05:47:37 <Deewiant> http://hpaste.org/11503 outlines two possibilities which I think would work, but the former is ugly and the latter uses a data instead of a newtype. :-P
05:47:52 <SamB_XP> mattam: you speak a lot of nothings
05:47:57 <mattam> :)
05:50:29 <dolio> Deewiant: Anyhow, my and Cale's code defines maps for key types k to values v, and it uses type families to specialize the map structure based on the key structure.
05:50:52 <dolio> And a set of ks is more or less a map from ks to ().
05:51:02 <Cale> Once you can do that, you can base your Tries on such generalised maps.
05:51:04 <dolio> If it's in the set, () is in the map under key k. And if not, not.
05:51:27 <dolio> Then your trie-based list set is just Map [k] ().
05:51:59 <dolio> And, yeah, you don't need to parameterize your type by the mapping for the ks.
05:52:24 <dolio> Since you can just tell it to use your generalized map for them.
05:52:37 <Cale> dolio: Or  newtype Trie k = Trie (Map k (Trie k))
05:53:23 <dolio> Yeah.
05:53:50 <Deewiant> I just want a Data.Map/Set-like module, this is overkill ;-)
05:53:54 <Saizan> that doesn't look right
05:55:26 <Saizan> what's the (Trie k) stored for each key?
05:55:47 <Cale> Saizan: Most of the data is encoded in whether keys are present or absent.
05:55:59 <SamB_XP> Saizan: well, each key in the Map is an element of the alphabet
05:56:16 <dolio> Actually, I think it should be 'data Trie k = Trie Bool (Map k (Trie k))'.
05:56:31 <SamB_XP> Saizan: the Map maps first letters to rests of words
05:56:32 <Cale> dolio: Why the Bool?
05:56:33 <dolio> Unless you want all prefixes of any key you insert in the set.
05:56:39 <Cale> ah, right
05:56:44 <Saizan> SamB_XP: ah, ok, if k is the alphabet
05:56:46 <SamB_XP> dolio: good point
05:56:53 <Cale> Or you have to add something to the alphabet.
05:56:58 <Deewiant> I'm honestly not seeing how this works under that scheme. instance (Key k) => Key ([k]) where data Mapping [k] v = Trie Bool k (??? k (Mapping k v)), or what?
05:57:10 <Cale> Like, make it Maybe Char instead of Char, and use Nothing to signal the end of a word.
05:57:36 <SamB_XP> Cale: hmm. that doesn't sound particularly nice :-(
05:57:44 <Deewiant> I've also got Patricia tries: data TrieSet a = Tr !Bool [a] !(IntMap (TrieSet a)) deriving (Show,Eq)
05:57:50 <Cale> SamB_XP: well, it's better than using '$' or something ;)
05:58:01 <SamB_XP> Cale: sure!
05:58:23 <Deewiant> And that's probably the deal-breaker. I don't see how to fit those in here, without two externally-identical instances.
05:58:29 <SamB_XP> but what about [Just 1, Nothing, Just 2] ?
05:58:43 <Deewiant> Because they're both mappings from [k] to v, just done differently.
05:58:56 <SamB_XP> Deewiant: hmm ?
05:58:58 <dolio> Then use whichever is better.
05:59:04 <Cale> SamB_XP: Hm?
05:59:08 <SamB_XP> Deewiant: why can't you have two ?
05:59:12 <Deewiant> dolio: I want to export both.
05:59:18 <SamB_XP> Cale: I suppose the Bool approach would have some similar issues ...
05:59:19 <dolio> Why?
05:59:41 <Deewiant> I think which one you want can depend on your use case.
05:59:54 <Deewiant> I'm not sure that Patricia tries are better in all cases.
06:00:07 <SamB_XP> like you could have portion of the tree that had only False ...
06:00:34 <SamB_XP> Deewiant: what are you doing that prevents both from existing at the same time ???
06:00:50 <dolio> SamB_XP: Type classes.
06:00:53 <Deewiant> SamB_XP: I'm not doing anything, dolio is suggesting something weird. :-P
06:00:57 <Cale> SamB_XP: I mean that you'd construct the Trie such that the empty string is in it iff Nothing is in the Map, and a word (x:xs) is in the Trie if Just x is in the map, and xs is in the Trie for x.
06:01:03 <SamB_XP> Deewiant: er, well, whatever
06:01:05 <Deewiant> SamB_XP: Rather, overly-general compared to my original intentions.
06:01:21 <Deewiant> dolio: I just want a trie library, not a general map library.
06:01:26 <SamB_XP> Cale: OH
06:01:32 <SamB_XP> that works nicely than
06:01:40 <SamB_XP> wait ... no ...
06:01:44 <SamB_XP> I don't get it ...
06:01:49 <SamB_XP> what would be the VALUE for Nothing ?
06:02:05 <Cale> SamB_XP: Well, you have a Trie corresponding to Nothing, but it might as well always be the empty Trie.
06:02:16 <SamB_XP> hmm.
06:02:30 <Cale> (because you'll never do a lookup in it)
06:04:43 <Deewiant> dolio: Say I use your code for the children-map in my tries. How do I get a Show instance (or any other) for "data TrieSet mapping a = Tr a (mapping a (TrieSet mapping a))"?
06:05:28 * SamB_XP tries to think about the performance impact of each approach ...
06:07:46 <dolio> Deewiant: I'm pretty sure you should be able to write instances like 'instance Show v => Show (Mapping Int v) where ...'
06:11:16 <dolio> Deewiant: Why can't PairList2 be a newtype?
06:11:32 <dolio> If that's your main complaint.
06:11:41 * quicksilver demands associated newtypes!
06:11:58 <dolio> I don't see any reason for it to be forbidden.
06:12:28 <Deewiant> dolio: That's a good question. I could have sworn it didn't work 3 hours ago. :-P
06:12:46 <dolio> You can use newtypes as data instances.
06:13:03 <quicksilver> dolio: oh good stuff.
06:13:13 * quicksilver thanks the channel for supply his demand.
06:13:21 <dolio> :)
06:13:35 <Deewiant> But okay, before I go back to my nongeneric-and-all-too-simple implementation, I want to figure out how this /would/ work with your approach. :-P
06:14:37 <dolio> Deewiant: My code is for maps whose implementation is specialized for the key type.
06:15:02 <Deewiant> dolio: Quite. And that's exactly what I want for my child-maps in the trie.
06:15:34 <Deewiant> For the moment, I'm struggling with a reasonable Show instance for the TrieSet defined as above. :-P
06:15:39 <dolio> So, if you used that sort of thing, then 'Mapping Int = IntMap' and 'Mapping (OrdKey k) = Map k' and so on.
06:16:05 <dolio> Well, the show instance for that kind of thing is unsatisfying, because you can't do quantification in contexts.
06:16:36 <dolio> What you want to say is something like '(Show a, forall b. Show (mapping b)) => Show (Trie mapping a)'. But you can't.
06:16:59 <Deewiant> So the best I can do is 'show _ = "this is a trie"'? :-P
06:17:15 <Deewiant> Or defining a million show instances by hand
06:18:12 <dolio> In actuality, '(Show a, Show (mapping a (TrieSet mapping a))) => Show (TrieSet mapping a)' should work.
06:19:04 <BeelsebobWork> arse buiscuits
06:19:08 <dolio> Although defining Show instances for Mapping k forall k is a fair amount of work.
06:19:16 <dolio> I wonder if deriving works for associated data...
06:19:22 <BeelsebobWork> before spending all day debugging your type checker, check that the term you're giving it really is meant to type check in your type system
06:19:23 <BeelsebobWork> >.<
06:19:52 <dolio> Oh, it does.
06:19:54 <Deewiant> dolio: That actually seems to work!
06:20:00 <Deewiant> Nice work.
06:26:33 <Deewiant> dolio: Needs UndecidableInstances, though.
06:27:20 <dolio> That isn't particularly surprising.
06:45:47 <lilac> @type curry + (0/0) -- curry with NaN
06:45:48 <lambdabot> forall a b c. (Fractional (((a, b) -> c) -> a -> b -> c)) => ((a, b) -> c) -> a -> b -> c
06:49:30 <titusg> can someone help me get a package installed? Cabal seems to be confused, complaining about lack of QuickCheck & binary which are installed
06:49:36 <Cale> lilac: ahaha
06:50:55 <titusg> my ghc-pkg list: http://hpaste.org/11510
06:51:25 <Cale> titusg: Perhaps the dependencies are installed as user and you're trying to install the package globally?
06:51:49 <Cale> (I'm just waiting for that hpaste to load, my connection is slow atm)
06:51:56 <titusg> Cale: no, I'm running cabal as a user
06:53:02 <Cale> and you're doing  cabal install foo
06:53:07 <Cale> ?
06:53:22 <Cale> Which package is it?
06:53:39 <titusg> actually I lie (re cabal), I'm installing agda from darcs
06:53:43 <C-Keen> > randomIO
06:53:45 <lambdabot>   Add a type signature
06:53:58 <mav`> Hi. Anybody knows of a good library for client-side SOAP interfacing in Haskell? Thx.
06:54:01 <Cale> titusg: You can still use cabal install to install something from source
06:54:14 <Cale> titusg: just run cabal install with no other parameters from the given directory
06:54:20 <C-Keen> why does that work in ghci but when I do it in a do{} construct I get a type error because the type of IO a is not known?
06:54:27 <titusg> Cale: thanks, trying that
06:54:38 <Cale> C-Keen: GHCi has extended defaulting.
06:55:06 <Cale> C-Keen: normally in a do-block you'll have other stuff which uses the result which will pin the type down better.
06:55:26 <titusg> Cale: and it seems to work, thanks.
06:57:42 <jeffersonheard> I take it that Network.BSD isn't implemented on Windows GHC?  I ran into portability issues with getAddrInfo and addrFamily
06:57:58 <C-Keen> Cale: has this defaulting been subject to change since 6.2? Because I have a old ghc where this triggers the same error in ghci and it works with 6.8.2
06:58:26 <Cale> C-Keen: 6.2? Possibly.
06:58:38 <C-Keen> ok
06:59:01 <Cale> C-Keen: basically, in order to generate a random value, it needs to know which type of random value you want.
06:59:05 <Baughn> Before I reimplement it, I should probably ask - has anyone written a Network-like simple interface to UDP yet?
06:59:50 <C-Keen> Cale: ok
06:59:59 <Cale> C-Keen: In GHCi, it'll default it to Integer, I believe. You can make that work in your source code with {-# LANGUAGE ExtendedDefaultRules #-}
07:00:20 <C-Keen> Cale: I understand what causes the error I just did not understand why the behaviour is different
07:00:22 <quicksilver> Baughn: I was under the impressiong Network supported UDP.
07:00:30 <quicksilver> Baughn: although I'm now not entirely sure why I thought that.
07:00:44 <jeffersonheard> quicksilver:  I was just about to ask the same question
07:00:47 <Baughn> quicksilver: It would be the sane thing to do
07:00:52 <jeffersonheard> I take it that it doesn't...
07:00:57 <Baughn> But it doesn't. I'd be happy to write a patch for it.
07:01:12 <jeffersonheard> Baughn: I'd be happy to test your patch
07:01:22 <Baughn> Noted.
07:05:42 <jeffersonheard> My problem is that getAddrInfo doesn't seem to be implemented in the Windows version of Network.Socket
07:06:02 <jeffersonheard> am I nuts?  it compiles fine on GHC 6.8 on Ubuntu.  Using GHC 6.8 on Windows
07:08:16 <Zao> jeffersonheard: Implemented at all or just broken?
07:09:03 <jeffersonheard> not implemented.  As in I get a "not in scope" error during compile
07:09:31 <Zao> Neat. At least that's better than the fun time I got from http://hackage.haskell.org/trac/ghc/ticket/2250 :)
07:09:35 <lambdabot> Title: #2250 (unpackFamily on Windows fails match) - GHC - Trac
07:13:27 <jeffersonheard> I guess...  I happen to know this particular program will always run on localhost, so I suppose I could just input 127.0.0.1 and be done with it...
07:13:59 <mopped> > head $ sortBy (max) [3, 4, 5, 6, 9, 2, 3]
07:14:00 <lambdabot>       No instance for (Num Ordering)
07:14:00 <lambdabot>        arising from the literal `3' at <...
07:14:06 <mopped> Why doesn't that work?
07:14:20 <mopped> or wait, because max doesnt return a bool? :P
07:14:29 <mopped> or ordering..
07:14:34 <jeffersonheard> yes
07:15:44 <mopped> > head $ sortBy (\x y -> compare y x) [3, 4, 5, 6, 9, 2, 3]
07:15:45 <lambdabot>   9
07:21:46 <BONUS_> > head $ sortBy (flip compare) [3,4,5,6,9,2,3]
07:21:47 <lambdabot>   9
07:21:48 <lambdabot> BONUS_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:21:59 <BONUS_> a message??? for me?!?!? OH MY
07:22:08 <jeffersonheard> > head $ sortBy (flip compare) [3, 4, 5, 6, 9, 2, 3]
07:22:09 <lambdabot>   9
07:23:42 <Baughn> jeffersonheard: It's still not quite the ideal naming, but I can get away with just adding UDPPortNumber to the PortId ADT
07:24:29 <jeffersonheard> That's fine by me.
07:24:56 <jeffersonheard> I submitted a ticket to trac about the goofiness with Windows and getAddrInfo
07:25:38 <Baughn> jeffersonheard: While you're there, link to the tracker?
07:26:20 <jeffersonheard> http://hackage.haskell.org/trac/ghc/ticket/2726
07:26:21 <lambdabot> Title: #2726 (getAddrInfo and addrFamily not in scope on Windows GHC 6.8) - GHC - Trac
07:35:47 <saml> > let cout << a = put a in cout << "hello world\n"
07:35:48 <lambdabot>   Not in scope: `cout'
07:36:13 <Deewiant> > let cout = cout; cout << a = put a in cout << "hello world\n"
07:36:14 <lambdabot>       No instance for (Show (m ()))
07:36:14 <lambdabot>        arising from a use of `show' at <i...
07:37:44 <Saizan> cout << a = .. defines (<<) and cout is just a fresh variable name there
07:37:47 <jeffersonheard> Deewiant, I should think the proper thing would be to define << to do an hPutStr lhs, then return IO lhs
07:37:56 <jeffersonheard> and then define cout = stdout
07:38:00 <Deewiant> jeffersonheard: yep
07:42:53 <Cthulhon> Why would you want to emulate that syntax, though?  It's one of C++'s ugliest inventions. :\
07:43:44 <Saizan> code obfuscation contests?:)
07:43:59 <int-e> Cthulhon: that's a topic of religious debates, isn't it?
07:44:38 <Cthulhon> It's my opinion that it's objectively ugly.
07:45:20 <quicksilver> having a binary operator for 'send message to channel' doesn't seem particularly ugly to me.
07:45:41 <quicksilver> it gets a bit weird when they send control messages as well as data payloads, perhaps.
07:46:01 <Cthulhon> Re-using the shift operator is, I think.
07:46:44 <Apocalisp> ugly re-using the shift operator is
07:46:55 <dolio> C++ only has so many operators. :)
07:47:13 <quicksilver> reusing operators really doesn't bother me very much.
07:47:32 <quicksilver> using the same operators in 100 different meanings in the same project, sure, that would be confusion.
07:47:51 <quicksilver> But there is not much risk of confusing "cout << "hello"" and "2 >> 8"
07:47:55 <Apocalisp> operator overloading leads to fear...
07:48:27 <badsheepy> fear leads to doubt
07:48:32 <badsheepy> and then we are all sith all of a sudden :(
07:49:21 <Apocalisp> doubt leads to... null reference checks
07:51:17 <Cthulhon> Maybe it's that the operator seems like it operates in two different ways in the same statement.  I.e. the first argument is the target stream, and everything after that is semantically arguments to that, facilitated by overloading.  Something that looks more like Haskell's list comprehensions might look better.
07:51:20 <therp> anyone using ArchLinux?
07:51:44 <therp> it looks like dons generated a lot of arch's PKGBUILD files from Cabal, and I wonder what's the practical experience with that
07:53:35 <Saizan> therp: pratical experience about generating or using them?
07:53:57 <quicksilver> Cthulhon: that's just left associativity, isn't it?
07:54:08 <quicksilver> Cthulhon: plus the operation returning the stream again
07:54:14 <quicksilver> that kind of thing is a very common idiom
07:54:18 <quicksilver> like the
07:54:27 <quicksilver> foo.doThis().doThat().doSomethingElse() idiom
07:54:30 <Cthulhon> Well, that's how it works.  But I think it's why it doesn't look that great.
07:54:30 <quicksilver> (method chaining
07:54:45 <chrisdone> I've got a job working on the web sites for a non-web company, so I have freedom of what technology to use
07:55:05 <BeelsebobWork> woooo!
07:55:08 <chrisdone> I really want to use Haskell and formlets and all the delicious Haskelly goodness, but the person after me will have a hard time
07:55:09 <BeelsebobWork> HAppS time?
07:55:24 <BeelsebobWork> haha, jobsecurity++?
07:55:28 <chrisdone> hahaha
07:55:33 <quicksilver> chrisdone: s
07:55:37 <quicksilver> http://products.datamation.com/development/sd//953043910.html
07:55:38 <lambdabot> Title: Datamation Product Watch - cgiCOBOL (Egan Systems Inc)
07:55:41 <Cthulhon> Yeah, I know it's just like method chaining, but with method chaining the object is distinguished because it doesn't have the parentheses, so it's in line with the semantics.
07:55:56 <chrisdone> quicksilver: hahaha, brilliant
07:56:22 <quicksilver> Cthulhon: it's not if the method is returned by a function :P
07:56:36 <Cthulhon> Yeah, I thought of that.
07:56:50 <Cthulhon> But even so, it seems different.
07:58:29 <therp> Saizan: using
07:59:41 <therp> Saizan: gentoo's packaging quality is really declining over the last year, but the gentoo-haskell repository is really great
08:02:05 <alar> @seen dons
08:02:05 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 10h 12m 27s ago.
08:06:52 <saml> >  3 >> 1
08:06:54 <lambdabot>       No instance for (Num (m a))
08:06:54 <lambdabot>        arising from the literal `3' at <int...
08:07:30 <saml> > shiftL 3 2
08:07:31 <lambdabot>   Add a type signature
08:08:01 <BeelsebobWork> > shiftL 3 2 :: Word8
08:08:03 <lambdabot>   12
08:08:03 <saml> > shiftL (3 :: Int) 1
08:08:04 <lambdabot>   6
08:13:20 <tuomov> The pre-complied ghc 6.8.3 linux-x86 dies in SIGFPE on install
08:13:40 <tuomov> utils/pwd/pwd, but also some other tools under utils
08:14:14 <tuomov> could it be that it uses SSE crap or so?
08:14:23 <tuomov> so it's not pure generic x86
08:15:40 <Dr_K> x86 is hardly pure. ;)
08:15:53 * xHemi ducks *FLAMEWAR!*
08:16:10 <int-e> pure languages never get anything done ;-)
08:16:20 <tuomov> I've noticed..
08:16:29 <TSC> tuomov: Not good news, I reckon: http://hackage.haskell.org/trac/ghc/ticket/2211
08:16:32 <lambdabot> Title: #2211 (Installing latest GHC-6.8.2 stable: pwd with floating point exception) -  ...
08:16:32 <BeelsebobWork> int-e: :D
08:16:50 <tuomov> *sigh*
08:16:53 <tuomov> *typical* linux
08:17:02 <tuomov> to upgrade anything, you have to upgrade the entire OS
08:17:10 <tuomov> or suffer compiling shit yourself
08:17:30 <Dr_K> int-e: indeed
08:17:31 <tuomov> and there's no way I'm upgrading linux anymore, ever
08:17:33 <medfly> i never had to upgrade the entire OS for anything, and i've been using linux for a while.
08:18:25 <tuomov> a linux distro is obsolete even before release, while MS has 5-10 year obsoleteness cycles..
08:18:48 <Dr_K> tuomov: depends on the distribution
08:19:17 <tuomov> by definition, distros are obsolete, containing all the world..
08:19:29 <tuomov> a static snapshot of a world in flux
08:19:37 <osfameron> in theory you can upgrade ubuntu, but given how broken it is on laptop I always reinstall from scratch to see if it's improved in the meantime
08:19:57 <tuomov> having to upgade once a half a year is already too often, given how much things break
08:20:09 <tuomov> and given how much they shove shit like udev, fontconfig, etc. at you
08:20:15 <xHemi> tuomov: how is all this relevant in any way?
08:20:25 <Dr_K> I only have one machine that doesn't run MacOS X, I installed Fedora, it's pretty up to date and runs fine.
08:20:27 <tuomov> ha! ot-nazi strikes!
08:22:10 <tuomov> my poor machine just isn't up to compiling shit like ghc
08:22:11 <opqdonut> wow
08:22:14 <tuomov> and the distro provides obsolete shit
08:22:17 <opqdonut> nice quit message
08:22:40 <Twey> Hmm, is there a standard function to randomise a list?  In System.Random perhaps?
08:22:40 <tuomov> and the distros don't provide a base for installing third party software
08:23:00 <Twey> (I can make neither head nor tail of the docs for that thing...)
08:23:15 <quicksilver> Twey: oleg's perfect shuffle is a piece of haskell folklore
08:23:28 <Twey> Oh gods
08:23:41 <tuomov> and all the shit seems to require 6.8 already
08:23:53 <camio> Anyone know of a way to query ghci for the type of a function defined in a where clause?
08:24:02 <Dr_K> tuomov: the default ghc for Fedora is 6.8.2
08:24:08 <tuomov> I'm on etch
08:24:11 <Saizan> camio: you can't
08:24:15 <Twey> tuomov: Yeah, `shit` requires Anus 6.8 or later
08:24:17 <tuomov> and I'm not installing linux ever again
08:24:19 <camio> Saizan: Thanks
08:24:22 <chrisdone> Twey: I used a shuffler recently, http://chrisdone.com/blah.hs
08:24:29 <tuomov> when I get a new computer, it will run windows
08:24:40 <alar> Vista =))))))))))
08:24:49 <Dr_K> ha
08:24:56 <tuomov> preferrably XP, but Vista is still better than what linux has become
08:25:09 <alar> XP will be discontinued
08:25:23 <tuomov> they still have long term support for it to 2015 or so
08:25:24 <quicksilver> take the off-topic to -blah, please.
08:25:30 <tuomov> another ot nazi!
08:25:35 <tuomov> I just hate these channels
08:25:35 <quicksilver> correct.
08:25:35 <alar> right now XP licence is unavailable for purchase at some places
08:25:47 <tuomov> they still sell it for netbooks
08:25:48 <quicksilver> however I'm an OT nazi who is also an op.
08:25:51 <Twey> tuomov: Find another, then :)
08:25:52 <quicksilver> so you get to do what I say.
08:26:08 <alar> ot-nazi? what's that?
08:26:10 <quicksilver> thanks :)
08:26:12 <tuomov> yeah, fascists who don't like critique of their cherished Fascist Open Sore Software
08:26:22 <BONUS_> lol
08:26:24 <xHemi> lol
08:26:27 <BONUS_> nice trolling dude
08:26:58 <chrisdone> off-topic is usually not a problem in most channels until people are trying to talk about something on-topic and you are hindering it
08:27:18 <tuomov> but #foobar.overflow is a complete non-solution to that
08:27:29 <tuomov> threads are the solution
08:27:40 <chrisdone> Software Transactional Memory?
08:27:49 <alar> =)
08:27:51 <tuomov> like email, usenet, on irc
08:28:05 <tuomov> start a new discussion by creating a new thread/sub-channel that are visible to people on the channel
08:28:11 <tuomov> that way you can keep different discussions separate
08:28:20 <tuomov> and OT shouldn't confuse other discussions
08:28:49 <chrisdone> tuomov: is it on Hackage?
08:29:21 <tuomov> as far as I know, nobody's implemented it
08:29:31 <tuomov> nobody ever implements anything new and good
08:29:45 <tuomov> just quick&dirty hacks and clones of existing shit
08:29:55 <chrisdone> tuomov: implement it yourself
08:30:05 <chrisdone> otherwise your talk is uninteresting
08:30:11 <tuomov> I don't have the time to implement Everything
08:30:16 * alar imagines topicstarter fighting for op power
08:30:21 <tuomov> because nobody else can write anything worth shit
08:30:34 <Peaker> I think its a nice idea -- but it could be nice if discussions were labelled, not placed in a hierarchy of channels
08:30:50 <tuomov> that's what I said, basically
08:31:02 <tuomov> there's a hierarchy in this whatwasit..
08:31:31 <Surma> Could one of you guys be so kind and take a look at this?: http://hpaste.org/11511 Can't figure out how to solve this, type casts are obviously not a solution since google doesn't give useful results at all
08:31:32 <chrisdone> is the hpaste bot never coming back?
08:31:54 * alar wonders why topicstarters can't simple create a new channel "tuomov"
08:32:14 <tuomov> it's complicated, you have to join the channel and shit
08:32:30 <tuomov> advertise it, and everything
08:32:38 <flux> tuomov, actually I've never heard of the subchannels-idea
08:32:44 <tuomov> threads are automatically advertised and visible to the channel, without having to join a new channel
08:32:49 <dolio> Surma: What's the type of tobase?
08:32:53 <tuomov> but people who don't like them, can ignore them
08:32:55 <alar> tomov: any other solution is equal
08:32:59 <alar> tuomov
08:33:02 <chrisdone> :t ceiling
08:33:02 <flux> but threading-on-irc has been a tried idea: it doesn't quite work in plain irc
08:33:03 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
08:33:05 <dolio> Wait, never mind.
08:33:23 <xHemi> tuomov: but then you would have to start each message with a tag
08:33:24 <chrisdone> the problem is n/b, perhaps?
08:33:29 <tuomov> well, not threading in quite the sense of all messages being labelled with parents
08:33:35 <tuomov> but, yes, more like subchannels
08:33:36 <flux> but then again perhaps there should just be a channel announcement protocol, could work over CTCP
08:33:36 <dolio> Anyhow, the problem is that you're using (/) not div and mod.
08:33:39 <chrisdone> :t 1/2
08:33:40 <lambdabot> forall t. (Fractional t) => t
08:33:42 --- mode: ChanServ set +o quicksilver
08:34:08 <flux> you could request a new subchannel from a channel moderator and get assigned a new channel, and that information again is broadcasted by the operator to the channel ;)
08:34:16 <flux> (all this could be automated)
08:34:23 <tuomov> nah, nothing so complicated
08:34:27 <Twey> Hm, that's quite terrifying
08:34:28 <tuomov> you just start a new topic with a new sub-channel
08:34:37 <Surma> dolio: I'm doing that on purpose, since div 142 (-4) e.g. give -36, not -35 as I desire
08:34:41 <flux> tuomov, how would that work with current irc system?
08:34:48 <tuomov> I asked about GHC install SIGFPE, so I'd just hit a button to create a new sub-channel and start typing
08:34:50 <xHemi> it just sounds like to much work, tab-completing through your subchannels to find the right one?
08:34:52 <Surma> dolio: is there a way to typecast that?
08:34:53 <tuomov> just like opening a newn tab in a browser or so
08:34:54 <Saizan> Surma: you can use quot and rem then
08:34:58 <Twey> I think I'm going to go for the naïve approach: generate a list of random numbers and sort comparing by them :)
08:34:59 <dolio> Surma: Then you probably want quot and rem.
08:35:05 <Surma> ah, okay :D
08:35:07 <Surma> thanks alot
08:35:11 <quicksilver> Twey: I think that's quite a reasonable approach.
08:35:11 <tuomov> you could do MS comic chat type tagging..
08:35:37 <Saizan> Surma: however fromIntegral if often useful to convert between numeric types
08:35:39 <wjt> for the record, conversation threads roughly as described are supported by XMPP
08:35:42 <Saizan> ?type fromIntegral
08:35:43 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:35:51 <Saizan> ?type realToFrac -- also
08:35:54 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
08:36:18 <Surma> thanks a lot!
08:37:11 <Philonous1> Surma: Does that even terminate for n and b with equal sign?
08:37:14 <therp> Saizan: so, have you been using the arch-haskell?
08:38:23 <Saizan> therp: i'm using arch, but not the haskell packages, i don't see much value over cabal-install
08:38:50 <therp> Saizan: how do you like arch btw?
08:40:10 <Surma> Philonous1: I certainly hope so - didn't test that yet, to be honest
08:40:19 <Surma> but I don't see why it shouldn't
08:40:56 <jpcooper> hello
08:40:58 <Philonous1> Surma: For n anbd b both positive n never becomes 0 due to ceiling, does it?
08:41:13 <jpcooper> could anyone direct me to writing Read instances for data which are made up of other data?
08:41:18 <Saizan> therp: quite a lot, i've moved from ubuntu because it was too heavy for me, and arch seems to be in a nice spot between binary distributions and automated building
08:42:55 <therp> Saizan: hm interesting. did you have any contacts with developers? there are a few strange folks in #archlinux that I rather don't want to work with I guess
08:42:56 <Philonous1> Surma: It might depend on the type of n and b, but (/) isn't the integer division, so it should always give back nonszero results for n /= 0
08:43:51 <Surma> Philonous1:  that's why I put ceiling() there, which doesn't work, but quot isn't right for me either, since quot 35 8 give 8 instead of 9
08:44:50 <Saizan> therp: no, i'm just an anonymous user :)
08:44:59 <Deewiant> > 35 / 8
08:45:00 <lambdabot>   4.375
08:45:08 <Surma> ae
08:45:10 <Surma> 35 / 4
08:45:15 <Surma> sry
08:45:26 <Deewiant> > ceiling (35 / 4)
08:45:28 <lambdabot>   9
08:45:29 <Philonous1> > ceiling (4/5)
08:45:30 <lambdabot>   1
08:45:41 <Philonous1> > ceiling (1/5)
08:45:43 <lambdabot>   1
08:45:45 <quicksilver> jpcooper: did you try 'deriving Read' ?
08:45:50 <Philonous1> That's what I mean
08:45:53 <quicksilver> jpcooper: that's the simplest way in most cases :)
08:45:58 --- mode: quicksilver set -o quicksilver
08:46:05 <Surma> yeah, but then the error from above occurs again
08:46:13 <Philonous1> Maybe you could just add n=0 as a special case
08:46:26 <Surma> I did?!
08:46:28 <Philonous1> pardon, n=1
08:46:30 <Surma> oh
08:46:33 <jpcooper> quicksilver, I might actually try this
08:47:14 <Deewiant> > ceiling (fromIntegral 35 / fromIntegral 4)
08:47:15 <lambdabot>   9
08:47:35 <Surma> oh, the fromIntegral belongs there, alright
08:47:48 <Surma> I though it's supposed to be outside of ceiling()
08:47:58 <Surma> well then, let's try again ;)
08:48:42 <Surma> hey, it does compile :D
08:48:50 <Surma> ending up with a stack overflow though
08:48:52 <Surma> xD
08:49:50 <Deewiant> Surma: well, it's an infinite loop after all :-P
08:50:24 <Surma> I know I know, I though I could reach 0 somehow
08:50:48 <Surma> which I can, apparently ?!
08:51:03 <Surma> when n =1, the next step is n=0
08:51:07 <Surma> and I can always reach n=1
08:51:22 <Deewiant> when n = 1 the next is n = 1 as well
08:51:27 <Deewiant> > ceiling (1 / 2)
08:51:29 <lambdabot>   1
08:51:47 <Surma> hm, not for a negative Base, but even then I get a stack overflow
08:52:01 <Baughn> jeffersonheard: Since you asked, the patch's at http://brage.info/~svein/network.patch
08:52:32 <jeffersonheard> Excellent.  Thanks Baughn.  I'll test it later today
08:53:01 <Surma> epic fail! I got a c and a b mixed up -.-
08:54:13 <quicksilver> alphabet fail!
08:54:26 <Surma> so to speak ;)
08:55:46 <Baughn> Oh, does anyone here have a non-ipv6-cabable computer they can test my network patch on? Or a windows computer?
08:56:04 <jeffersonheard> I'll be testing on Windows, Baughn
08:56:27 <Zao> non-ipv6 boxen should be rather common, I'd say.
08:58:42 <Baughn> Zao: I don't mean without ipv6 connectivity; I mean without ipv6 headers/libraries
08:59:08 <Baughn> That code doesn't even get compiled otherwise, so there are probably all sorts of bugs in it now
09:01:48 * rog has got it working, but oh my god is it ever slow...
09:05:09 <jeffersonheard> rog: you mean the Network patch?
09:05:20 <Baughn> Presumably not. That wouldn't be slow.
09:05:30 <Baughn> jeffersonheard: Listening on UDP ports is broken. I'm looking into it.
09:05:50 <jeffersonheard> I can't imagine that it would be; shouldn't be anything in there to affect the speed at all
09:05:59 <jeffersonheard> okay, I'll wait.  Thanks, Baughn
09:06:01 <rog> no, "it" was of unspecified type...
09:06:02 <Surma> okay guys, once again, please take a look at this: http://hpaste.org/11513
09:06:44 <mauke> Surma: (c) is the same as c
09:07:10 <Surma> oh, thanks, then it does make sense
09:07:23 <Surma> gotta get use to this different type of parantheses
09:08:54 <camio> Surma: no
09:09:09 <camio> Surma: tobase (floor c) b
09:09:33 <Surma> camio: that's what I meant ;) I just changed it to that, and it works fine
09:09:34 <Surma> thanks
09:13:15 <jpcooper> could anyone suggest how I might define a read instance for PortNumber?
09:13:23 <jpcooper> from GHC's Network module
09:13:54 <jeffersonheard> everybody's doing network programming today
09:14:01 <jpcooper> how dare they!
09:14:03 <mauke> deriving instance Read PortNumber
09:14:05 <Saizan> rog: the Dynamic thing?
09:15:23 <jpcooper> mauke, would I have to edit the module code itself?
09:15:31 <mauke> no
09:16:19 <jpcooper> mauke, so you are saying that I just have to write this in a separate line?
09:16:38 <Saizan> jpcooper: yeah, it's called standalone deriving
09:16:43 <jpcooper> thank you
09:17:05 <mauke> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
09:17:07 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
09:17:44 <Ikkebr2> is there any way to use pattern matching in list comprehenshions? i.e: a is [('a',2),('b',3),('c',4)] and b is [('b',10),('a',45)] and i need [('a',90),('b',30)] as my resulting list
09:19:59 <jpcooper> Saizan, do you know how I might add the -XStandaloneDeriving to what is run when I use C-c C-l in haskell-mode?
09:20:07 <Ikkebr2> in python that would be easy
09:20:18 <Saizan> Ikkebr2: you want to group i guess?
09:20:35 <quicksilver> jpcooper: {-# LANGUAGE StandaloneDeriving #-}
09:20:37 <Saizan> jpcooper: put {-# LANGUAGE StandaloneDeriving #-} at the top of your file
09:20:44 <Ikkebr2> in python it would be [(z[0],x[1]*z[1]) for z in [('a',2),('b',3),('c',4)] for x in [('b',10),('a',45)] if z[0] == x[0]]
09:20:50 <jpcooper> thanks
09:21:01 <osfameron> python comprehensions make my eyes bleed
09:21:10 <Ferdirand> [ (la, a*b) | (la,a) <- as, (lb,b) <- bs, la == lb ]
09:21:52 <Peaker> osfameron: I prefer "for" and "if" to | and .. nothing
09:21:53 <mauke> > [(z0,x1*z1) | (z0,z1) <- [('a',2),('b',3),('c',4)], (x0,x1) <- [('b',10),('a',45)], z0 == x0]
09:21:54 <lambdabot>   [('a',90),('b',30)]
09:22:07 <Ikkebr2> thanks mauke
09:24:26 <orgthingy> !hello world
09:24:28 <orgthingy> hmm
09:25:13 <jpcooper> I'm having problems here with deriving the Read instance. It's saying that I can't do this because the needed constructors are not in scope, even though I've imported Network. Can anyone suggest how else I might read in a PortNumber?
09:26:19 <mauke> you could just read an Int, then use fromIntegral
09:26:24 <jpcooper> okay
09:26:27 <orgthingy> can you do GUI programming in haskell ?
09:26:36 <quicksilver> orgthingy: yes.
09:26:41 <lament> orgthingy: yes. :)
09:26:45 <jeffersonheard> orgthingy http://haskell.org/gtk2hs
09:26:45 <saml> orgthingy: i can't. but you can.
09:26:46 <lambdabot> Title: Gtk2Hs
09:26:47 <rog> Saizan: yes.
09:27:18 <orgthingy> nice
09:27:26 <orgthingy> then haskell isnt so-useless afterall
09:27:35 <saml> GUIs shouldn't be programed. They should be declared like HTML
09:27:38 <quicksilver> (or there is wx, or opengl)
09:27:44 <Peaker> How would 2 Data.Map's be zipWith'd?  How to implement:  (Maybe a -> Maybe b -> Maybe c) -> Map k a -> Map k b -> Map k c   ?
09:27:50 <orgthingy> sam1 : oh god.. o_O
09:27:51 <mauke> A++, would troll again
09:27:54 <lament> saml: XAML
09:28:00 <orgthingy> how about using everyday-language? :P
09:28:02 <lament> saml: guess what. It kinda sucks.
09:28:37 * jeffersonheard wishes he could just declare his socket code
09:28:44 <saml> > Maybe k a
09:28:46 <lambdabot>   Not in scope: data constructor `Maybe'
09:29:21 <Saizan> rog: damn, you've a benchmark or something small enough to show?
09:29:57 <lament> things that you "just declare" are impossible to debug
09:32:18 <Deewiant> lament: like all Haskell programs? ;-P
09:32:28 <lament> yes
09:32:32 <Deewiant> heh
09:33:20 <Ikkebr2> how do I convert from a list to a string? ["5","6","7","8"] to "5678"
09:33:28 <Deewiant> concat
09:34:00 <jeffersonheard> ikkebr2: however, if you have ['5','6','7','8'] you have a string
09:34:00 <Ikkebr2> thanks Deewiant
09:34:06 <int-e> > ['5','6','7','8'] -- strings are lists
09:34:07 <lambdabot>   "5678"
09:34:33 <rog> Saizan: not really. the whole thing is about 700 lines currently. i need to profile it to see where the time's going. it's all a bit of a black box at the moment. i'm now using Data.Map where i was using records. i have a feeling that might have something to do with it.
09:39:57 <Saizan> ?type  \f ma mb -> Data.Map.mapMaybe (uncurry f) $ Data.Map.unionWith (mplus *** mplus) (fmap ((,) Nothing . Just) ma) (fmap (flip (,) Nothing . Just) mb)
09:39:58 <lambdabot>     Couldn't match expected type `(m a, m1 a1) -> (m a, m1 a1)'
09:39:58 <lambdabot>            against inferred type `(m a -> m a, m1 a1 -> m1 a1)'
09:39:58 <lambdabot>     Probable cause: `***' is applied to too many arguments
09:45:33 <Peaker> @type alter
09:45:34 <lambdabot> Not in scope: `alter'
09:45:37 <Peaker> @type Data.Map.alter
09:45:39 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
09:45:51 <Peaker> why Maybe a -> Maybe a, and not Maybe a -> Maybe b?
09:46:19 <Deewiant> Peaker: because it changes only one value
09:46:27 <Ikkebr2> in file IO, how do I insert a \n into a file (and not a "\n") ?
09:46:29 <Peaker> ah, ok
09:46:30 <Deewiant> or rather, it might not change all values
09:46:39 <Peaker> Deewiant: yeah, silly to miss that ;)
09:46:49 <mauke> Ikkebr2: huh?
09:47:23 <Saizan> > ("\n", show "\n")
09:47:24 <lambdabot>   ("\n","\"\\n\"")
09:47:34 <quicksilver> Ikkebr2: use 'putStr' not 'print' ? ;)
09:47:52 <Ikkebr2> ah nevermind
09:47:52 <Ikkebr2> :p
09:47:53 <Ikkebr2> my bad
09:47:57 <Ikkebr2> was using show
09:48:03 <quicksilver> show is for losers!
09:48:11 <mauke> good show
09:52:05 <dylan> show is for the repl. ;)
09:53:15 <Ikkebr2> repl?
09:53:30 <mauke> (loop (print (eval (read))))
10:04:15 * alar wishes he could find numeric-prelude maintainer somewhere
10:04:21 <tuomov> Setup.lhs: HFuse.cabal:14: 'Executable' stanza starting with field 'library
10:04:21 <tuomov> build-depends'
10:04:24 <Peaker> Why does this not type-check http://hpaste.org/11515 ?
10:04:34 <Peaker> "cannot construct the infinite type: c = Maybe c"
10:04:35 <tuomov> and similar for *everything*
10:04:39 <tuomov> can't build latest ghc
10:04:40 <dons> tuomov: sounds like you have a very old version of cabal
10:04:44 <tuomov> 6.6.1
10:04:59 <dons> ok. so that's an old ghc, but you could first upgrade to cabal 1.6
10:05:07 <dons> or consider getting ghc 6.8.x
10:05:14 <dons> (6.10 is to be released this week)
10:05:25 <tuomov> where's a pastebot?
10:05:30 <Peaker> dons: cool! any idea when Ubuntu catch up with ghc's?
10:05:31 <dons> ?paste
10:05:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:05:37 <mauke> hpaste.org, rafb.net/paste
10:05:55 <dons> tuomov: hfuse definitely needs cabal 1.2 or newer
10:05:57 <Peaker> how do I go about debugging such a type error at all?
10:05:57 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HFuse
10:06:01 <tuomov> http://hpaste.org/11516
10:06:02 <lambdabot> Title: HackageDB: HFuse-0.2.1
10:06:08 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
10:06:09 <lambdabot> Title: HackageDB: Cabal-1.6.0.1
10:06:21 <tuomov> I just hate this linux shit
10:06:35 <dons> tuomov: not enough info in that to diagnose. you're trying to build ghc 6.6.x ?
10:06:38 <tuomov> on windows I'd be done already, with precompiled binaries
10:06:43 <tuomov> 6.8.3
10:06:47 <dons> why not use precompiled binaries?
10:06:49 <tuomov> I have 6.6.1, from etch
10:06:55 <tuomov> precompiled 6.8.3 doesn't even install
10:06:59 <tuomov> SIGFPE
10:07:11 <dons> http://haskell.org/ghc/dist/6.8.3/ghc-6.8.3-i386-unknown-linux.tar.bz2
10:07:13 <dons> ?
10:07:14 <lambdabot> http://tinyurl.com/5rfkqg
10:07:16 <mauke> hmm, that's a new one
10:07:20 <tuomov> thanks to linux being distro-dominated shit with no chance of ISVs distributing their software sanely
10:07:28 <mauke> even gentoo has working prebuilt binaries of ghc
10:07:48 <dons> tuomov: which binary did you use?
10:07:48 <tuomov> etch has 6.6.1, which is too old for shit
10:07:54 <tuomov> the one you pasted, I think
10:07:57 <tuomov> SIGFPE
10:08:06 <dons> that's very interesting.
10:08:08 <tuomov> somebody already pasted a link to a bug report... too old libc
10:08:14 <dons> ah ha.
10:08:25 <tuomov> linux: to upgrade a the most insignificant program, you have to upgrade the whole OS
10:08:40 <dons> tuomov: that's really distro specific. debian's the worst of breed.
10:08:49 <dons> anyway, to try #ghc for ghc issues.
10:08:49 <tuomov> etch is only 1.5 years old!
10:09:00 * quicksilver slaps dons for the troll
10:09:06 <tuomov> if this was windows, this would be brand new!
10:09:07 <Deewiant> yes, but it runs 15 year old stuff. :-P
10:09:08 <dons> and lots of other people seem to be running ghc on etch, so perhaps ask on the list.
10:09:08 <Cale> tuomov: That problem can occur on any OS>
10:09:16 <mauke> Peaker: >>= f v looks wrong
10:09:25 <tuomov> but linux distros are obsolete even before release
10:09:28 <Peaker> mauke: what's the difference between:   case x of { Nothing->Nothing ; Just v -> Just (f a v) }    and: x >>= (f a) ?
10:09:34 <Cale> tuomov: In my experience, it's even worse on Mac OS.
10:09:35 <tuomov> so you're constantly upgrading and constantly fixing broken shit
10:09:42 <mauke> Peaker: the Just
10:09:49 <quicksilver> Peaker: looks more like 'fmap (f a)' to me
10:10:01 <quicksilver> Peaker: or x >>= return . f a
10:10:07 <quicksilver> since >>= return is fmap
10:10:12 <Cale> tuomov: Different point releases of the operating system won't run software distributed for other point releases.
10:10:19 <tuomov> Cabal-1.6.0.1$ runhaskell Setup.hs configure
10:10:20 <tuomov> Distribution/ModuleName.hs:56:7:
10:10:20 <tuomov>     Could not find module `System.FilePath':
10:10:20 <tuomov>       Use -v to see a list of the files searched for.
10:10:32 <roconnor> looks more like liftM to me
10:10:44 <Peaker> fmap = liftM..
10:10:45 <quicksilver> technically of course roconnor is right ;)
10:10:47 <mauke> roconnor: liftM is fmap
10:10:50 <tuomov> Cale: and there's no stable point for linux, it's constantly in flux
10:10:52 <quicksilver> but I prefer the basic name.
10:10:56 <tuomov> ISVs can't distribute software sanely for linux
10:10:58 <Peaker> quicksilver: thanks
10:11:00 <tuomov> it's entirely distro-centric crap
10:11:15 <tuomov> you can only use what the distro provides without a lot of effort
10:11:23 <tuomov> and distros are megafrozen crap
10:11:33 <Cale> tuomov: I don't really have too much of a problem with it in practice.
10:11:56 <alar> tuomov: use BSD =))
10:12:02 <tuomov> well, here's one: etch provides ghc 6.6.1, and it's too old for shit
10:12:03 <sjanssen> @hackage filepath
10:12:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath
10:12:09 <alar> it's entirely non distro-centric
10:12:14 <quicksilver> I use 6.6.1 all the time
10:12:15 <tuomov> I don't want to upgrade, because that means spending a month fixing shit
10:12:17 <quicksilver> have done for years.
10:12:18 <Cale> tuomov: You're running debian etch?
10:12:25 <sjanssen> tuomov: if your GHC doesn't have filepath, you can install it from there (though it seems strange you don't have filepath)
10:12:32 <quicksilver> 6.6.1 had filepath.
10:12:35 <tuomov> yeah, endless dependency tracking..
10:12:52 <tuomov> just admit it, cabal-1.6.0 doesn't even work with ghc 6.6.1...
10:12:56 <sjanssen> tuomov: perhaps it is a separate package in the 6.6 days?
10:12:57 <Gabby> cabal install :)
10:13:01 <tuomov> but the 6.8.3 refuses to compile too
10:13:02 <quicksilver> /opt/local/lib/ghc-6.6.1/package.conf: ...  filepath-1.0 ...
10:13:04 <Cale> tuomov: I would recommend the generic linux GHC binary, and if that doesn't work, try to compile your way up to a recent release.
10:13:09 <Cale> mmm
10:13:13 <Peaker> yay, wrote: zipMaps :: (Ord k) => (a -> b -> c) -> (Map.Map k a) -> (Map.Map k b) -> (Map.Map k c)
10:13:14 <mauke> Cale: isn't that what he's doing?
10:13:20 <Cale> You might have to go through an intermediate release.
10:13:29 <Cale> (I haven't been following the conversation completely)
10:13:31 <tuomov> Cale: I tried. SIGFPE, too old libc
10:13:46 <tuomov> this is linux.
10:13:46 <sjanssen> tuomov: does the libghc6-filepath-dev package exist for you distro?
10:13:51 <tuomov> pain, suffering.
10:13:52 <alar> Gabby: to install cabal-install one must upgrade cabal first =)
10:14:05 <dylan> hrm, is there a way of applying HaXml CFilters to a Document *without* processXmlWith?
10:14:07 <dolio> @type intersectionWith
10:14:08 <lambdabot> Not in scope: `intersectionWith'
10:14:12 <dolio> @type M.intersectionWith
10:14:13 <lambdabot> forall a b c k. (Ord k) => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
10:14:15 <tuomov> can't install anything sanely not through the distro
10:14:23 <tuomov> and stable distros don't provide anything recent
10:14:23 <Cale> tuomov: Well, etch is over a year old...
10:14:27 <Gabby> Heh good point
10:14:32 <tuomov> you have to be constantly at the bleeding edge, and suffer the consequence
10:14:43 <malcolmw> dylan: yes, just look at the code for processXmlWith, copy/paste, and tweak it as you wish.
10:14:48 <Cale> tuomov: You could run Windows instead.
10:14:52 <Gabby> I had todo such rubbish to get everything working on linux :/
10:14:54 <quicksilver> yup, on etch you want libghc6-filepath-dev
10:14:54 <tuomov> I will, when I get a new computer
10:14:55 <dylan> malcolmw: that's rather sucky.
10:15:01 <sjanssen> tuomov: complaints about Linux are a off topic here, would you like us to help you install GHC?
10:15:14 <Peaker> dolio: ah, what kind of a name is that ;)
10:15:24 <sjanssen> or whatever you're trying to do, I'm having a hard time figuring that out
10:15:27 <Peaker> @hoogle (Ord k) => (a -> b -> c) -> (Map.Map k a) -> (Map.Map k b) -> (Map.Map k c)
10:15:27 <lambdabot> Parse error:
10:15:27 <lambdabot>   --count=20 "(Ord k) => (a -> b -> c) -> (Map.Map k a) -> (Map.Map k b) -> (Map.Map k c)"
10:15:27 <lambdabot>                                              ^
10:15:38 <Peaker> @hoogle (Ord k) => (a -> b -> c) -> (Map k a) -> (Map k b) -> (Map k c)
10:15:39 <tuomov> sjanssen: well tell me what's that problem: http://hpaste.org/11516
10:15:39 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
10:15:39 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
10:15:42 <alar> does HaXML have advantages over HXT?
10:15:43 <Peaker> heh cool ;)
10:15:52 <malcolmw> dylan: well, applying a CFilter is rather straightforward - the main job of processXmlWith is just plumbing the document to the right place
10:15:55 <tuomov> it doesn't even give an error message, just dies with 'Error 1'
10:16:15 <tuomov> Setup.hs: At least the following dependencies are missing:
10:16:15 <tuomov> filepath >=1 && <1.2
10:16:27 <tuomov> after installing libghc6-filepath-dev or so
10:16:35 <dylan> malcolmw: there seems to be no function Document -> Content, short of deconstructing with case or similar.
10:16:38 <malcolmw> alar: it has a lazy XML parser, so if your usage of the document is linear, HaXml will be faster and more space efficient for large documents
10:16:50 <sjanssen> tuomov: this is an error when building ghc 6.8.3 with ghc 6.6.1?
10:17:05 <tuomov> filepath stuff is about trying to install cabal 1.6.0 on ghc 6.6.1
10:17:08 <malcolmw> dylan: yep.  that is because there is no obviously best way of doing it
10:17:12 <tuomov> the paste is trying to compile ghc 6.8.3
10:17:37 <sjanssen> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath will get you a modern version of filepath
10:17:38 <lambdabot> Title: HackageDB: filepath-1.1.0.0, http://tinyurl.com/2kc9q2
10:17:49 <tuomov> which will have other deps I don't have.. surely
10:17:50 <malcolmw> dylan: processXmlWith was never meant to be the main interface - only ever an example of how to do it
10:17:56 <tuomov> I HATE this dependency tracking
10:17:59 <Samy> Is there a package that provides access to uname(2)?
10:18:04 <tuomov> always more, there's never an end to it
10:18:11 <Samy> or platform information (operating system, operating system release, etc...)?
10:18:21 <tuomov> "filepath-1.1.0.0.tar.gz (Cabal source package)"
10:18:28 <tuomov> yup, and that will refuse to build without cabal-1.6, I'm sure
10:18:28 <mauke> no, filepath only depends on base
10:18:47 <alar> malcolmw: really? I've heard complaints that the both fail to parse XML lazily enough. Complaint-reporters said that memory slowly leaks if one processes huge XML input file silently discarding most of it
10:18:55 <alar> they both
10:19:18 <sjanssen> tuomov: looking at the .cabal file, it should work with almost any version of Cabal
10:19:54 <tuomov> but it fails to install
10:20:01 <dons> i think tuomo hasn't upgraded cabal for his 6.6 system (if he's trying to just work with 6.6)
10:20:05 <Saizan> tuomov: what's the error?
10:20:06 <tuomov>    Bad interface file: /usr/local/lib/filepath-1.1.0.0/ghc-6.6/System/FilePath.hi
10:20:09 <tuomov>         /usr/local/lib/filepath-1.1.0.0/ghc-6.6/System/FilePath.hi: openBinaryFile: permission denied (Permission denied)
10:20:11 <alar> Samy: if I were you, I'd use System.Cmd("uname") or something like that
10:20:17 <sjanssen> tuomov: sudo
10:20:17 <tuomov> shit
10:20:22 <alar> or even FFI
10:20:33 <tuomov> that was trying to build cabal
10:20:33 <sjanssen> tuomov: or configure with --user
10:20:35 <tuomov> so it mis-installed
10:20:48 <Samy> alar, yeah, I think I'll use ffi
10:21:40 <Saizan> you installed filepath so that the interface files aren't globally readable?
10:21:43 <alar> Samy: it took the same amount of time for me to make FFI-binding for sleep and to find what library it is already in :))
10:21:51 <dylan> http://hackage.haskell.org/packages/archive/HaXml/1.13.3/doc/html/src/Text-XML-HaXml-Wrappers.html <-- onContent seems like it should be exported.
10:21:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5voer8
10:22:01 <tuomov> runhaskell Setup.hs install
10:22:05 <tuomov> it should get it right
10:22:10 <dylan> (it's currently annoying to play with haxml in the repl.)
10:22:15 <sjanssen> tuomov: which options did you give configure?
10:22:21 <tuomov> none, of couse
10:22:40 <tuomov> I hate this poorly documented Setup.hs crap
10:22:46 <tuomov> Makefile is standard!
10:22:51 <tuomov> make && make install
10:23:26 <tuomov> I for one will not touch cabal
10:23:31 <tuomov> in my projects
10:23:32 <mauke> http://mauke.ath.cx/stuff/haskell/Makefile
10:23:34 <malcolmw> dylan:  good idea.  I'll fix that
10:24:03 <tuomov> this just as bad a blackbox as autocrap
10:24:08 <alar> it is even worse eith HXT arrows in repl
10:24:15 <alar> with
10:24:29 <Saizan> tuomov: if you want to see what it does just pass -vN to the commands
10:24:42 <tuomov> yeah, poorly documented crap
10:24:47 <Saizan> tuomov: documentation also comes on the cabal site or thorugh --help
10:24:48 <tuomov> have to hunt such options somewhere
10:25:00 <Samy> tuomov, it isn't poorly documented.
10:25:04 <Samy> No
10:25:06 <Samy> Hold on
10:25:12 <Saizan> tuomov: --help is "hunt somewhere"?
10:25:20 <tuomov> I love makefiles, with documentation among the configuration
10:25:31 <tuomov> and they're self-documenting any many cases as well
10:25:37 <tuomov> with this autocrap all is spread all over the place
10:25:55 <Saizan> there's no auto-anything, all the information is in the .cabal file
10:26:05 <alar> at least the cabal is smart
10:26:06 <alar> it one told me "don't pass -lgfortran in c-options, put this dependency in extra-libraries"
10:26:11 <Samy> tuomov, http://www.haskell.org/cabal/
10:26:11 <lambdabot> Title: The Haskell Cabal
10:26:27 <alar> what other building system posess such an intelligence?
10:26:28 <tuomov> it's crap
10:26:36 <Samy> tuomov, when it comes to cabal-install, of course, as others said there is --help
10:26:37 <tuomov> I hate its strict version numbering crap too
10:26:47 <tuomov> why can't people just have free-form human-readable version numbers
10:26:56 <tuomov> and a running integer of the author's choosing for automated version comparisons
10:27:29 <Samy> So write your own package/package installation framework, tuomov.
10:27:31 * alar wonders what human-readable version should look like
10:27:35 <Samy> And show us that you could do better. :)
10:27:58 <dons> cabal install rocks, it's made life so much simpler.
10:28:05 <mauke> alar: filepath-hardy-heron-478232214
10:28:05 <tuomov> well, I e.g. use 3rc-20071003 style
10:28:06 <dons> sjanssen: we got darcs cabalised yesterday. no autotools required.
10:28:07 <mdmkolbe> Is there an array equivalent of STRef?
10:28:18 <dons> STUArray ?
10:28:24 <dons> or IORef ? depending on what you mean..
10:28:25 <tuomov> it doesn't fit the cabal idea of version numbers
10:28:41 * alar doesn't think 478232214 is very humen-readable
10:28:55 <mdmkolbe> @index STUArray
10:28:56 <lambdabot> Data.Array.ST
10:29:02 <sjanssen> dons: will those patches actually be accepted upstream?
10:29:28 <dons> sjanssen: since they're separate to whatever franchise/makefile combination, i think so
10:29:30 <sjanssen> dons: also, how did you do all the random tests darcs does at configure time without autoconf?
10:29:35 <dons> yes!
10:29:38 <mdmkolbe> thx dons, STUArray is what I was looking for
10:29:39 <dons> in Setup.hs
10:29:48 <dons> its quite cute, sjanssen
10:29:53 <sjanssen> hmm
10:29:58 <dons> sjanssen: http://hpaste.org/11483
10:30:07 <sjanssen> that is actually similar to the franchise approache, as I understand it
10:30:12 <dons> shorter than the franchise equivalent
10:30:14 <tuomov> all this separation into packages and modules is Utterly And Totally Fucked Up too
10:30:15 <dons> yes.
10:30:24 <tuomov> package=top-level module. period.
10:30:32 <sjanssen> tuomov: nobody wants to listen to your rants, stop.
10:30:32 <dons> its a lot faster than autoconf too
10:30:42 <tuomov> but now, you have one hierarchy of packages, which are spread all over the place into modules
10:30:58 <tuomov> try to find all the posix stuff.. no, it's not in Posix. It's somewhere under a gazillion places
10:31:05 <tuomov> (and doesn't even resemble posix / use the posix names)
10:31:24 <mauke> posix is obsolete. embrace the haskell way
10:31:28 <alar> =))
10:31:31 <tuomov> that was just an example
10:31:40 * alar agrees with mauke
10:31:48 * mauke disagrees with mauke
10:31:51 <tuomov> everything is done that way, a package is spread all over a Minutely Categorised Hiearchy Of How Things Should Be Classified
10:32:01 * alar likes the way haskell can be ported to Win and backwards
10:32:09 <mauke> except when it can't
10:32:16 <alar> exactly!
10:32:34 <saml> it's hard to install SDL wrapper on Windows
10:32:42 <saml> Vista
10:32:47 <FunctorSalad> is there a file for global ghc flags?
10:33:04 <quicksilver> FunctorSalad: there is some way to put them in you .cabal, if memory serves.
10:33:24 <dons> ghc-options: -O2
10:33:38 <FunctorSalad> quicksilver: I mean totally global, so I don't have to add {-# ... #-} in every file I write ;)
10:33:44 <lament> cabal packages are in the Category of Minute Hierarchies
10:33:58 <Cale> tuomov: A module is a unit of code which exposes various definitions when imported into another module. A package is a unit of distribution, which makes available either or both of a coherent set of modules, or one or more Haskell programs.
10:34:22 <tuomov> a package should make available a single matching top-level module.
10:34:22 <FunctorSalad> of course I could just make a wrapper script
10:34:26 <Cale> A package can also include hidden modules which are used internally but not made available to the rest of the system.
10:34:26 <quicksilver> FunctorSalad: no, that would be harmful
10:34:30 <tuomov> everything else is over-complication
10:34:32 <quicksilver> FunctorSalad: because then other people couldn't run your code.
10:34:35 <tuomov> with a gazillion overlapping hierarchies
10:34:46 <mauke> tuomov: ok, what if that single module uses several private modules internally?
10:34:48 <quicksilver> FunctorSalad: you should either put it in the file (so other people getting the file get it) or in the .cabal (so other pepole using your project get it)
10:34:51 <FunctorSalad> quicksilver: hmm, true
10:34:51 <lament> tuomov: It's a shame you weren't there when God was creating the Universe. He would really appreciate your advice.
10:34:53 <mdmkolbe> @index StorableArray
10:34:54 <lambdabot> Data.Array.Storable
10:35:00 <ushdf> is there a linux directx port yet
10:35:01 <tuomov> mauke: there can be stuff under that top-lvel module of course
10:35:06 <Cale> tuomov: I disagree. It is often natural to design a package with separate but related modules.
10:35:25 <quicksilver> ushdf: yes, as part of WINE. But that's distinctly off-topic here.
10:35:28 <mauke> all modules are top-level
10:35:30 <tuomov> it isn't natural to spread them all over the place..
10:35:45 <tuomov> random packages adding stuff to Data. etc.
10:35:53 <tuomov> Data. should be just the standard data structure package or so
10:36:01 <ushdf> that don't count
10:36:09 <Cale> For example, there is an xmonad package, which has lots of modules, each of which contributes something to the functionality of the window manager.
10:36:12 <FunctorSalad> tuomov: what's wrong with the 'contents' haddock page of a package? it lists all the modules
10:36:34 <Cale> Separating that into hundreds of packages would just make it far more complicated to install and use.
10:36:34 <mauke> tuomov: 'Data' is still available
10:36:38 <tuomov> it's a dirty complicated mess with a zillion overlapping hierarchies
10:36:45 <mauke> tuomov: 'Data.Map' is a completely separate top-level module
10:37:01 <tuomov> no, it's a sub-module of Data
10:37:05 <mauke> no
10:37:07 <Cale> tuomov: No it isn't.
10:37:09 <mauke> there are no submodules
10:37:14 <tuomov> that's you're twisted way of thinking
10:37:14 <lament> do a zillion overlapping hierarchies form a topology?
10:37:20 <tuomov> s/you're/your/
10:37:23 <mauke> tuomov: think of it as Data_Map if you want
10:37:32 <quicksilver> lament: well, only if the union of any set of open hierarchies is open.
10:37:40 * alar disagrees with tuomov
10:37:40 <alar> even the very basic Prelude is going to split off numeric part, so how fixed once and forever hierarchy of Data.something can be invented?
10:37:49 <tuomov> but it isn't Data_Map
10:37:51 <Cale> Modules are hierarchically *named* but the hierarchy itself is just a way of organising things and doesn't mean anything beyond that.
10:37:57 <tuomov> everyone disagrees with me
10:38:00 <tuomov> nobody ever agrees with me
10:38:06 <mauke> tuomov: what's the difference between . and _?
10:38:07 <quicksilver> that's probably because you're always wrong :P
10:38:10 <tuomov> everyone else is a fucking moron that follows the herd
10:38:13 <mauke> also, maybe you should stop being wrong then
10:38:18 <tuomov> which is why I'm having nothing to do with the foss herd anymore
10:38:29 <tuomov> everyone does everything exactly opposite teh way I'd do
10:38:29 <lament> the herd is the word
10:38:32 <Cale> tuomov: Data.Map is the same thing as DataMap, except it has an extra character in the name.
10:38:35 <tuomov> so I may just as well switch to windows
10:38:36 <mauke> tuomov: (psst, I think I agree with you wrt font antialiasing)
10:38:41 <ushdf>  tuomov: i know the feeling
10:38:50 <int-e> tuomov: you can always fork :-P
10:38:52 <ushdf> i come in here al the time talking about enrique iglesias
10:38:55 <ushdf> and nobody seems to care at all
10:39:06 <ushdf> it's like they couldn't be more brainwashed ;)
10:39:23 <dylan> what's an enrique iglesias?
10:39:30 <ushdf> did anybody here the new cd by enrique iglesias
10:39:47 <Cale> ushdf: I accidentally the whole cd.
10:39:47 <lament> i accidentally the new cd?
10:39:50 <lament> Cale: argh
10:39:51 <mauke> I accidentally the new enrique iglesias cd is this bad?
10:39:55 <ushdf> i am the television
10:40:00 <tuomov> if you thinkg of module hierarchy as being flat, then it's a complete mess
10:40:02 <mauke> I am the walrus
10:40:09 <ushdf> einstein for an eggman
10:40:13 <tuomov> again an anti-ISV setup, with everyone having to agree on where to place their shit
10:40:18 <dylan> goo-goo goochu.
10:40:25 <alar> enqueue eagles?
10:40:26 <lament> Cale, mauke: ...contrapuntal fugues...
10:40:32 <alar> what's that?
10:40:33 <cadabra> http://hpaste.org/11517  -- why is that illegal? There's never any ambiguity in the compiler about which to call, is there?
10:40:37 <tuomov> your stuff here, my stuff here... it would be simple to have a top-level scheme by package names... even unique ids...
10:40:44 <ushdf> contrapuntal music is for people with funny wigs
10:40:52 <mauke> cadabra: yes, there is
10:41:06 <tuomov> I'd most rather have
10:41:10 <cadabra> mauke: how so?
10:41:12 <mauke> cadabra: what is the type of xsum?
10:41:12 <tuomov> -package Posix=..../posix.so
10:41:19 <int-e> tuomov: you like Java, don't you? Me, I can never find anything in their libs.
10:41:34 <Cale> tuomov: You put everything on Hackage, you get everything from Hackage. Life is good :)
10:41:41 <tuomov> java has something a bit more sanely, but I think the org.foobar is a bit too clumsy too
10:41:44 <cadabra> mauke, There are two xsums, one for Tree and one for List
10:41:49 <int-e> also, ghc-pkg find-module  exists for a reason.
10:41:50 <mauke> cadabra: not to the compiler
10:41:52 <dylan> in fact, cabal hides modules from packages you don't say you're using
10:41:54 <tuomov> I like what I pasted, not adding yet another hierarchy over the FS too
10:41:58 <ushdf> > exception "offtopic"
10:41:59 <lambdabot>   Not in scope: `exception'
10:42:01 <tuomov> or whatever more generic package distribution system there was
10:42:02 <int-e> and ghc is usually helpful in pointing out which package to import
10:42:03 <mauke> cadabra: whenever it sees 'xsum' in an expression, it has to give it a type
10:42:04 <ushdf> > exception $ "offtopic"
10:42:05 <lambdabot>   Not in scope: `exception'
10:42:11 * ushdf gives up
10:42:11 <tuomov> -package Posix=AN_UUID_FOR_DISTRIBUTING_THE_POSIX_PACKAGE
10:42:22 <int-e> yuck
10:42:22 <ushdf> what a hard language
10:42:25 <quicksilver> ushdf: I accidentally the topic
10:42:37 <mauke> wait, did someone say eggman?
10:42:40 <alar> cadabra: to make functions with one name and with different types, you should make it class method
10:42:41 * ushdf gets worried
10:42:42 <Cale> cadabra: It sounds like you want a typeclass.
10:42:46 <cadabra> mauke, but it can make them from the definitions, and then decide which to call from the types of args
10:42:48 --- mode: ChanServ set +o Cale
10:42:54 <mauke> cadabra: no, it can't
10:43:00 <Cale> Let's get back on topic everyone :)
10:43:16 <quicksilver> cadabra: it could but that's not haskell's type system
10:43:17 <int-e> Cale: well, you could change the topic accordingly ;)
10:43:18 <ushdf> ok, what do you want to talk about
10:43:19 <quicksilver> cadabra: so, it doesn't.
10:43:23 <mauke> cadabra: consider foo f x = xsum (f x)
10:43:26 <Cale> int-e: The topic is Haskell. :)
10:43:29 <dancor> why didn't ppl use happs for hpaste2
10:43:32 <tuomov> it's a complete mess when every language author wants to reinvent the OS...
10:43:34 <mauke> cadabra: what are the types of f and foo?
10:43:38 <dancor> is happs too out-of-control
10:43:46 <Cale> Not rants about operating systems. :)
10:43:52 <mauke> tuomov: not my fault people keep using OSes!
10:43:53 <tuomov> haskell is an OS
10:43:58 <Cale> (it's starting to kill discussions about Haskell)
10:44:03 <cadabra> mauke, insufficient info
10:44:12 * alar wonders where did "language of choice for discriminating hackers" gone from the topic
10:44:15 <ushdf> cale: free market vs. 'benevolent' authoritarianism
10:44:22 <quicksilver> cadabra: one can imagine the type system you are describing yes.
10:44:22 --- mode: Cale set -o Cale
10:44:23 <mauke> alar: that's Perl now
10:44:30 <alar> wow!
10:44:30 <quicksilver> cadabra: it just happens, that is not the type system haskell has
10:44:33 <int-e> alar: no Haskell program won at the last ICFP contest.
10:44:34 <tuomov> bah, I think I'll write this shit in Lua
10:44:41 <tuomov> it's a nice and simple non-bloated language
10:44:44 <ushdf> who can better meat the kneads of the haskell community than its members
10:44:45 <Samy> You're very stupid tuomov.
10:44:46 <mauke> surely you're kidding
10:44:47 <quicksilver> cadabra: one of the properties of haskell's type system is that everything has a principle type.
10:44:50 <mauke> its array indices start from 1
10:44:51 <tuomov> that doesn't try to provide the entirey world in a hierarchy
10:44:55 <Cale> tuomov: Please don't force me to ban you.
10:45:05 * dancor has never seen such flames, is this #gentoo
10:45:08 <ushdf> don't ban him, Cale
10:45:14 <ushdf> he's my friend ;):0:0:0)
10:45:15 <Cale> ushdf: you too.
10:45:15 <alar> is Perl so powerful? Or maybe "discriminating hackers" posessed some sacret knowledge of robototechnics?
10:45:21 <Saizan> dancor: at the time when hpaste2 was written happs didn't have a stable api, that problem is solved since the release on hackage
10:45:24 <quicksilver> cadabra: the reasons for this are quite deep and I'm not sure I can explain them all in the margin of this IRC channel :)
10:45:37 <dancor> ah, ok.
10:45:39 <tromp_> indices starting at 1? that is so..... pascal
10:45:41 <quicksilver> cadabra: but suffice to say they are interesting trade-offs and there are reasons ot like the ML/Haskell approach.
10:45:52 <cadabra> quicksilver: okay, where did you learn about this?
10:45:59 <Cale> cadabra: in any event, you can get the effect you want using a typeclass.
10:46:13 <quicksilver> cadabra: personally? osmosis, many years programming, and a PhD in logic.
10:46:19 <int-e> > listArray (1,6) "Pascal"
10:46:21 <lambdabot>   array (1,6) [(1,'P'),(2,'a'),(3,'s'),(4,'c'),(5,'a'),(6,'l')]
10:46:22 <quicksilver> cadabra: there are other routes.
10:46:37 <quicksilver> the book 'TAPL' is pretty hard core, but interesting if you want to pursue the argument.
10:46:40 * alar feels jealous to PhD in logic
10:46:42 <cadabra> Cale: I know, I'm just thinking about it
10:47:09 <Samy> quicksilver, cool
10:47:11 <Cale> http://hpaste.org/11517#a1
10:47:12 <quicksilver> it's nice to have a composable system, in the sense that every term has a unique principal type
10:47:13 <tuomov> Cale: wouldn't be the first time to get banned here.. I'm kinda waiting for it
10:47:13 <Samy> quicksilver, where did you get your PHd?
10:47:18 <quicksilver> and when you compose terms
10:47:31 <lament> tuomov: you have strange priorities
10:47:31 <quicksilver> the type you form is always an 'instance' of that
10:47:36 <Cale> tuomov: We like to keep discussions here friendly and positive.
10:47:37 <quicksilver> Samy: QMUL
10:47:40 <tuomov> everyone is always "there's nothing wrong with our shit, it's great. you're a moron for liking things to be more beautiful"
10:47:51 <quicksilver> cadabra: so, I suppose composability is one good reason.
10:47:53 <Cale> tuomov: If you don't have anything nice or constructive to say, keep it to yourself :)
10:47:59 <therp> Cale++
10:48:02 <osfameron> alar: it's possible that the ICFP contest is determined more by the group of programmers than it is by the language
10:48:03 <quicksilver> tuomov: that's a very interesting summary
10:48:03 <lament> tuomov: i think people here are quite open to suggestions. Your arguments are just not very argumentative.
10:48:08 <tuomov> yeah, friendly and positive, "all is great, there's nothing wrong" back-patting
10:48:08 <ushdf> ++--
10:48:14 <quicksilver> I would characterise this IRC channel as precisely the opposite.
10:48:17 <ushdf> <3 tuomov
10:48:18 <Samy> My university has exactly 2 classes discussing logic :-(
10:48:19 <tuomov> the FOSS herd is full of that and nothing ever improves, only degrades at an accelerating pace
10:48:21 <Samy> That is, with any formalisms.
10:48:29 <ushdf> my university has exactly 1 inspection per packet ;)
10:48:37 <quicksilver> I would characterise this channel as one of the very few places on the internet where people really go out on a limb
10:48:40 <quicksilver> and look for beautiful solutions
10:48:41 <Samy> tuomov, the problem here is that talk is very cheap. :-)
10:48:49 <quicksilver> even when there are more ugly, popular ones.
10:48:49 <alar> osfameron: most of the time there is specific branch of knowledge that rules
10:48:49 <alar> With 06 being the exception
10:48:51 <mauke> preflex: be PoppaVic
10:48:51 <preflex>  You likely don't understand "shooting"., "reloading" or "cooking" - let alone C. I don't play executioner
10:49:17 <dylan> That is a very strange quote.
10:49:18 <therp> anyone tried NixOs?
10:49:21 <quicksilver> consider all the people pushing for FRP, even though imperative/GUI "works"
10:49:25 <tuomov> I find nothing beautiful about the haskell package/module mess
10:49:26 <lament> PoppaVic is a very strange person
10:49:32 <Samy> tuomov, haskell has problems...but your 5 minute experience with haskell doesn't really touch on the major issues.
10:49:35 <tuomov> file system, packages, modules, a zillion hierarchies
10:49:36 <dylan> therp: the thing with the functional-style package manager?
10:49:36 <quicksilver> or all the people pushing STM even though C threading works.
10:49:43 <tromp_> quicksilver: do you consider my Go rules in Haskell "beautiful" yet?
10:49:49 <tuomov> add to that the distro breaking shit in its own units
10:49:54 <Cale> tuomov: Then flesh out and write up a concrete design proposal.
10:49:57 <Samy> tuomov, so write your own package framework. :-)
10:49:58 <tuomov> it's called over-complexity
10:49:58 <therp> dylan: yep
10:49:59 <mauke> lament: any sufficiently advanced PoppaVic is indistinguishable from markov chains
10:50:03 <lament> tromp_: ooh, show
10:50:04 <Samy> tuomov, it's called open-source.
10:50:10 <dylan> therp: I've wanted to use that.
10:50:11 <Cale> tuomov: Along with properly reasoned arguments about what specific problems it solves.
10:50:22 <tuomov> yeah, FOSS can do nothing *designed*, only a steampile of kludges
10:50:24 <tromp_> http://www.cwi.nl/~tromp/go.html
10:50:29 <tuomov> intelligent design... *muahahaha*
10:50:31 <Cale> Other than "Waaah! I don't like this!"
10:50:33 <Samy> tuomov, surely it can be designed :-)
10:50:46 <therp> can we stop feeding the troll?
10:50:47 <Samy> tuomov, I think Cabal has a nice design. Have you even looked at the sourcecode?
10:50:48 <int-e> tuomov: funny.
10:50:50 <tromp_> middle of the page
10:50:57 <ushdf> can you stop labelling people as trolls
10:50:57 <lament> tuomov: the haskell community is not a typical FOSS community in the way it does things. Usually when people do stuff or suggest changes, they end up writing a paper about it.
10:51:24 <tuomov> even cabal is complicated by having to depend on both modules and packages...
10:51:27 <Cale> tuomov: Yeah, write a paper about a better design, and get it published, and then we'll listen to you ;)
10:51:30 * alar dislikes Cabal sourcecode, but likes the easy feeling of using it
10:51:39 <Samy> alar, why not?
10:51:55 <alar> Samy: why what?:
10:52:10 <tuomov> and I find the strict version numbering of cabal ugly too
10:52:16 <Samy> alar, nm.
10:52:22 * Samy ignores tuomov 
10:52:31 <sjanssen> tuomov: cabal essentially ignores modules.  Packages are the distribution unit, modules are the source unit
10:52:31 <Cale> tuomov: "strict version numbering"?
10:52:42 <tuomov> x.y.z-foo-bar iirc
10:52:53 <tuomov> doesn't include 3rc-20081003 or so
10:53:01 <tuomov> have to mangle into 3.20081003-rc or something
10:53:04 <tuomov> which isn't the version number
10:53:15 <alar> Cale: he probably means module version being [Int] instead of String =))))
10:53:16 <dylan> I enjoy releasing modules with decrementing version numbers, also.
10:53:16 <Cale> tuomov: Packages can depend on an arbitrary union of ranges of versions
10:53:18 <mauke> or you could start using sane version numbers
10:53:31 <tuomov> yeah, version numbering fascism strikes!
10:53:40 <tuomov> instead of providing a flexible way of specifying them
10:53:49 <tuomov> (human-readable, plus a running integer for computers, or so)
10:54:13 <ushdf> programs should be referred to as the sum of their parts, of each discrete algorithm contained within
10:54:18 <ushdf> unfortunately, programmers make mistakes
10:54:20 <sjanssen> tuomov: it seems useful to make the human readable version the same as the computer readable version
10:54:20 <ushdf> the morons
10:54:21 * alar likes cabal's ability to write complicated dependency rules, alike  Bar <5.4 || Bar == 4.0
10:54:28 <mauke> my version number is γωǹEEEEEEEE¡¤⊕¹²₅
10:54:33 <mauke> and you can't stop me!!
10:54:36 <lament> tromp_: very interesting... but i can't get the page to load :(
10:54:38 <int-e> mauke: bless you.
10:54:45 <sjanssen> tuomov: what should a user do when Cabal complains "needs base > 817959123"?
10:54:49 <tromp_> what error do you get?
10:55:06 <lament> "Firefox can't establish a connection to the server at www.cwi.nl."
10:55:10 <wjt> sjanssen: cabal should never give such an error. cabal should not exist. we should get all our software magically from the ether!
10:55:18 <tromp_> hmm, loads fine from here
10:55:27 <FunctorSalad> tuomov: packages don't form a hierarchy, it's flat. the file system directories just mirror the package names on my system
10:55:32 <tuomov> sjanssen: that's wrong! depending on versions!
10:55:44 <mauke> M-butterfly
10:55:45 <Samy> mauke, haha
10:55:49 <sjanssen> tuomov: what is the right way?
10:56:01 <Cale> tuomov: So every time I change my package, I should give it a completely new name?
10:56:01 <tuomov> something like I describe in "capable packages"
10:56:12 <int-e> tuomov: you know, people will agree with that. versions are just an approximation of supported interfaces.
10:56:19 <tuomov> i.e. depending on capabilities
10:56:28 <int-e> tuomov: but it's a hard problem and people recognize that as well.
10:56:37 <tromp_> blocking homepages... urls maybe?
10:56:37 <lament> versions are as stupid as age limits on liquor
10:56:52 <int-e> tuomov: if you can come up with a working proposal for this, or better yet, an implementation, you'll surely be loved.
10:56:54 <Cale> I don't want to have to care about specific capabilities when trying to figure out what version to download.
10:57:00 * alar would say that it is not just @hard problem@ but it is turing-complete
10:57:05 <tuomov> the computer-readable version number is only needed for version comparison for automated updates of commensurable packages
10:57:08 <tromp_> it maps to http://homepages.cwi.nl/~tromp/go.html
10:57:09 <lambdabot> Title: John's Go Page
10:57:10 <lament> tromp_: yay, it loaded
10:57:14 <tromp_> great
10:58:01 * alar wonders what should an implementation against age limits on liquor look like
10:58:32 <tromp_> do you play go, lament?
10:58:40 <tuomov> int-e: as if I had the time.. and really something like that should not be a one man job
10:58:43 <lament> tromp_: yes
10:58:46 <lament> a little
10:59:02 <tuomov> many essential core software is crap perhaps exactly because they're done by one man with a tunnel vision
10:59:12 <tuomov> and the herd just loves the shine still, and it's then difficult to fix later on
10:59:17 <tuomov> (udev, fontconfig, ...)
10:59:41 <mauke> ion
10:59:43 <lament> all the best software is designed by a committee!
10:59:43 <Samy> udev is a stupid concept.
10:59:44 <Samy> mauke, haha
10:59:51 <Samy> pwm
10:59:58 <tuomov> ion is not core software that everyone has to suffer from...
11:00:01 <Saizan> tuomov: do you have any idea about describing interfaces that packages expose/need in a pratical way?
11:00:12 <Cale> tuomov: You have exactly the wrong attitude for someone who is interested in actually changing things. Insulting the people who have designed the existing systems is not productive.
11:00:33 <tuomov> well, they refuse to fix their shit, so...
11:00:38 <bd_> tuomov: So fix it!
11:00:43 <bd_> Nobody's stopping you :)
11:00:46 <tuomov> I don't have the time
11:01:01 <tuomov> these dickheads and fuckwits get paid for writing their crap that ruins linux/*nix1
11:01:08 <bd_> tuomov: Then you hardly have any right to complain? At least the udev maintainer did /something/.
11:01:11 <Samy> Yet you have the time to write massive blog posts about cycling...
11:01:12 <Cale> Or calmly suggest something better. Maybe write something up in a way which is actually useful to an implementor.
11:01:13 <int-e> tuomov: then stop insulting people.
11:01:22 <Samy> and bitch and moan for many minutes in #haskell.
11:01:24 <mauke> Whiny nutfucker, go to /pr/ if you want real answers. We masturbate all over our copies of SICP while currying Haskell nomads with SUAVE LISP TOADS here in /prog/.
11:01:33 <tuomov> bd_: static dev would've been better without the scsi mapping insanity
11:01:33 <Cale> Insulting them will just make them stop listening to you and ignore your (potentially worthwhile) idea.
11:01:40 <alar> what's udev?
11:01:41 <tuomov> udev is a workaround to that
11:01:54 <cjb> Cale: tuomov's been having this conversation with anyone who'll listen for a couple of yeafs, so I think you're unlikely to change his mind about anything.
11:02:03 <Cale> cjb: I know.
11:02:06 <cjb> also years.
11:02:14 <tuomov> Samy: documenting some frustrations isn't even close to the amount of work of writing _good_ software
11:02:21 <bd_> tuomov: We've used static dev for ages. The problem is when you run out of device numbers. Or want to be able to name devices in a way that matches reality in some way (no, driver loading order is not reality...)
11:02:21 <jsn> cjb: about udev?
11:02:26 <Cale> cjb: I'm toying with the idea of just kickbanning him so that this channel can get back to normal.
11:02:40 <tuomov> actually, why I started looking into hFuse etc., is writing a quick&dirty udev replacement...
11:02:45 <jsn> Cale: you have my blessing
11:03:07 <Saizan> does freenode have akick?
11:03:18 <Cale> Saizan: yeah
11:03:19 * alar wonders if trolls ever perish from hunger
11:03:20 <Samy> tuomov, have you looked at FreeBSD's DevFS?
11:03:25 <tuomov> it's better
11:03:27 <Saizan> because it looks like this is not the first time tuomov comes here to get banned
11:03:34 <Cale> Saizan: I know, yes.
11:03:34 <jsn> hahaha
11:03:37 <Samy> tuomov, yes, by far.
11:03:42 <sjanssen> Saizan: what is akick?
11:03:44 <Cale> Saizan: Usually I'm willing to let bans expire.
11:04:06 <alar> the best devfs is in QNX
11:04:06 <Samy> bd_, have you?
11:04:16 <Saizan> sjanssen: chanserv bans that nick automatically for you on rejoins
11:04:21 <bd_> Samy: no, is there an overview of it somewhere I can read? :)
11:04:28 <Samy> bd_, sure, let me find one.
11:04:31 <Saizan> sjanssen: works well with registered nicks
11:04:59 <Samy> bd_, http://threads.seas.gwu.edu/cgi-bin/man2web?program=devfs.rules&section=
11:05:02 <lambdabot> Title: Man Page Lookup - devfs.rules, http://tinyurl.com/5cb368
11:05:04 <Samy> bd_, and there is a link to devfs(8) there
11:05:37 <tuomov> I might switch to frisbee if I didn't still have to suffer Xorg, fontconfig, and all the crap
11:06:08 <tuomov> so what I'm likely doing when I get a new computer, is switch to Windows, and run frisbee or netbsd, or some _old_ slackware in vmware for hacking (ion + xterm)
11:06:08 <Cale> tuomov: In any event, my advice to you if you actually care about seeing this stuff change is either to adopt a softer approach to suggesting it, or else just quit whatever else you're doing and do it yourself. People don't generally respond well to personal attacks, but if you can point out design problems and suggest useful fixes, they're usually willing to listen. There might be reasons they won't want to actually
11:06:08 <Cale> change things -- there are limitations on how much time they have to spend as well.
11:06:21 <tuomov> windows being the driver and gui platform.. providing e.g. hibernate that linux (and *bsd) fail to provide
11:06:49 <bd_> Samy: mmm, a bit short on details - it's hard to see how it's different/better than udev. The syntax certainly looks simpler, but also less powerful - but that could just be because the manpage is incomplete
11:07:27 <Samy> bd_, less powerful in what way?
11:07:29 <Cale> However, being that this discussion is mostly about things totally unrelated to Haskell, I'm going to have to ask you to stop now.
11:07:32 <tuomov> udev is too powerful...
11:07:42 * Samy nods at tuomov 
11:07:49 <tuomov> and the biggest problem is /dev is no longer the interface for symlinks and permissions
11:07:54 <Samy> bd_, what important functionality is missing?
11:07:56 --- mode: ChanServ set +o Cale
11:07:57 <tuomov> so you have to touch the ugly files for even basic things
11:08:07 <bd_> Samy: well, the only matching it shows in devfs.rules(5) is by device name. I can't say, 'give user X access to the device with serial Y, even if its driver gets loaded in a different order for some reason tomorrow'
11:08:23 <mauke> </Haskell please!g
11:08:24 --- mode: Cale set -b *!*@cpe-098-027-031-086.triad.res.rr.com
11:08:31 --- mode: Cale set +b *!*@jolt.modeemi.cs.tut.fi
11:08:33 * bd_ joins haskell-blah :)
11:08:38 --- kick: tuomov was kicked by Cale (Cale)
11:08:48 --- mode: Cale set -o Cale
11:09:13 <noZone> Haskell puts the Funk in functions.
11:09:27 <conal> @seen dcoutts_
11:09:27 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
11:09:52 <mauke> preflex: seen dcoutts_
11:09:52 <preflex>  dcoutts_ was last seen on #haskell 47 days, 13 minutes and 9 seconds ago, saying: fair enough
11:09:57 <mauke> oh wow
11:10:24 <Cale> preflex: seen dcoutts
11:10:24 <preflex>  dcoutts was last seen on #haskell 14 hours, 47 minutes and 16 seconds ago, saying: I've not been near a windows box for over a month so have not been able to make a binary to make it easier for people
11:10:37 * int-e eyes mauke suspiciously.
11:10:57 <mauke> ò_ó
11:11:03 <Cale> Perhaps dcoutts_ is his windows box ;)
11:11:22 <olsner> heh, that'd be fitting
11:12:11 <conal> is there a code.haskell.org op here?  i'd like to get a project added.
11:12:53 <dons> conal: malcolmw
11:13:09 <conal> dons: thx.
11:13:29 <malcolmw> conal: dons: I usually do the user-account reqs, don't know how to add projects
11:14:48 <conal> okay, i'll wait for dcoutts.
11:15:01 <dons> he's flying back to england
11:15:10 <conal> ah.  i wondered.
11:15:18 <dons> on his way to seattle on the train, currently. retracing your trip in reverse, conal :)
11:15:25 * malcolmw has just arrived back in england too
11:16:36 <rog> hi malcolmw...
11:16:56 <dons> mm. anyone see spj's questions about who would want ghc on the jvm or .net?
11:17:10 <malcolmw> rog: did I fix your bug in the end?
11:18:18 <rog> malcolmw: i'm not sure. i haven't had the time to spend trying again yet. i will!
11:18:28 <Samy> dons, .net
11:19:20 <dancor> should i think about things like the efficiency of (y1, y2) = (f1 x, f2 x) vs (y1, y2) = f1Andf2 x
11:19:34 <dancor> (e.g. f1 is head and f2 is tail)
11:19:51 <Deewiant> only think about efficiency if you think it matters
11:20:33 <dancor> ok, but what is the cost there?  usually first will be a constant worse if the compiler doesn't infer optimization?
11:21:00 <Deewiant> I'd've thought the second is worse :-)
11:21:07 <dancor> hah
11:21:41 <Deewiant> I think the first is the most optimal way that can be written
11:21:46 <dancor> i guess i should just test it out.  one case recently was f1 = map head and f2 = map tail
11:21:54 <malcolmw> dancor: if y1 and y2 get used at wildly different times, then there is a danger of holding onto the whole of x for the duration.
11:22:33 <Deewiant> dancor: ah, I think I may have misunderstood then
11:22:42 <dancor> here was the case: http://dzl.no-ip.org/lol/dia.hs
11:22:48 <Deewiant> dancor: and I would say that it depends very much on the function
11:22:54 <dancor> i wrote (restHeads, restTails) = unzip $ map (\ (x:xs) -> (x, xs)) restRows
11:22:55 <malcolmw> dancor: however, if f1 and f2 are pure selectors, ghc should be able to fix that space leak itself - if they are nor pure selectors, then the space leak is likelier to happen
11:23:49 <dancor> so in pure case simpler is probably better in gen?
11:24:17 <dancor> i.e. map head rest instead of restHeads
11:25:54 <Cale> dancor: If f1 is head and f2 is tail, why aren't you writing (y1:y2) = x ?
11:25:54 <malcolmw> "map head" is not a simple selector - it build a list too
11:26:38 <dancor> Cale: i agree, but wasn't sure for this other case where f1 = map head and f2 = map tail
11:26:44 <malcolmw> pure selector = only deconstructs a data value
11:27:11 <Cale> ah, I'd go with unzip in that case.
11:27:18 <dancor> ok
11:27:39 <Cale> It can be a concern, but worry about it only if it's actually a problem.
11:29:02 <Cale> That is, if it's likely that only one of the pair of results will actually be needed, then maybe there's some benefit to separating them like that, but I wouldn't bother trying to fix a problem until you're sure it's really there.
11:29:25 <Cale> (and it can be less efficient to separate them as well)
11:38:54 <lament> tromp_: nice rules
11:41:54 <vixey> ?where moonpaste
11:41:55 <lambdabot> I know nothing about moonpaste.
11:43:33 <Deewiant> ?where hpastetwo
11:43:34 <lambdabot> http://moonpatio.com:8080/
11:44:58 <lament> tromp_: I've seen your page before, the rules are nicely stated. I don't think you had a Haskell version then.
11:49:29 <sebaseba> @quote
11:49:30 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
11:50:26 <mauke> preflex: quote
11:50:26 <preflex>  <mjl69> I have no problem with legal gay porn and consulting adults.  As long as gay porn is between a man and a man or a woman and a woman.  I do not believe that gay can be between a woman and a man.
11:51:19 <Twey> Hahaha
11:51:25 <Twey> Nice quote
11:51:27 <vixey> @seen mmorrow
11:51:27 <lambdabot> mmorrow is in #ghc, #darcs and #haskell. I last heard mmorrow speak 8h 38m 21s ago.
12:01:51 <mmorrow> heya vixey
12:02:27 <vixey> hi
12:03:12 <vixey> mmorrow, I found some code which is doing that same 'shortest beta normalizer' stuff http://www.cs.nott.ac.uk/~nad/repos/simply-typed/
12:03:23 <lambdabot> Title: Index of /~nad/repos/simply-typed
12:04:02 <mmorrow> ooh, cool
12:05:39 <mmorrow> i also found some interesting code last night
12:05:48 <mmorrow> it's the code for the reference implem for http://research.microsoft.com/%7Esimonpj/papers/boxy/
12:05:49 <lambdabot> Title: Simon Peyton Jones: papers
12:06:13 <mmorrow> i got the tarball, and haddocked the files
12:06:35 <mmorrow> code is http://moonpatio.com/repos/fph-impl/
12:06:40 <lambdabot> Title: Index of /repos/fph-impl
12:06:45 <mmorrow> haddocks are http://moonpatio.com/repos/fph-impl/docs/
12:07:00 <mmorrow> build and run Main.lhs. neato
12:07:36 <mmorrow> (and it's 100% self-contained too, which is the best part)
12:07:56 <vixey> looks cool
12:08:04 <mmorrow> totally
12:08:19 <mmorrow> err, i meant
12:08:25 <mmorrow> ./Main < example.hs
12:09:03 <mmorrow> i'm also going to raid that parsec parser in there
12:09:32 <vixey> hehe
12:09:32 <vixey>   = TcEnv { uniqs          :: IORef Uniq,                    -- unique name supply
12:09:52 <vixey> you just never escape
12:10:04 <mmorrow> hehe
12:10:21 <mmorrow> the pdfs under "Presentations" here are interesting too http://www.cis.upenn.edu/~dimitriv/
12:10:25 <lambdabot> Title: dimitrios vytiniotis
12:10:32 <mmorrow> (that's the author of that ref implem)
12:10:52 <mmorrow> this one in partic http://www.cis.upenn.edu/~dimitriv/presentation-for-tfp.pdf
12:10:55 <lambdabot> Title: Dependent types: Easy as PIE
12:11:02 <mmorrow> ok, gotta run :)
12:11:07 <vixey> ttyl
12:11:25 <byorgey> vixey, mmorrow: whatcha working on?
12:12:10 <vixey> hey byorgey :)
12:13:10 <byorgey> I'm working with Stephanie Weirich on some of the same stuff that Dmitrios was working on, so I'm curious =)
12:13:44 <vixey> oh cool
12:13:45 <byorgey> although at this point I still don't know all that much...
12:13:52 <vixey> I have only just heard about this now
12:15:01 <byorgey> hm, ISTR Stephanie saying that the boxy types stuff is sort of superseded now
12:15:12 <vixey> byorgey, were you reading up on dependent pattern matching ?
12:15:18 <byorgey> vixey: yep
12:16:06 <Cale> byorgey: What were they superceded by?
12:16:16 <byorgey> that's the problem, I can't quite remember =P
12:16:18 <vixey> have you seen the method in Eliminating Dependent Pattern Matching ?
12:16:27 <byorgey> maybe look at the paper "Practical type inference for arbitrary-ranked types"?
12:16:30 <Cale> oh, FPH
12:16:39 <Cale> http://research.microsoft.com/~simonpj/papers/boxy/
12:16:40 <lambdabot> Title: Simon Peyton Jones: papers
12:17:01 <Cale> There are still boxes though :)
12:17:06 <byorgey> yeah, that's it
12:17:29 <byorgey> ok, maybe it was just that she told me not to bother reading the "boxy types" paper, rather than that the technique itself is superseded =)
12:18:25 <byorgey> ok, yes, reading the description of the boxy types paper, I think the "practical type inference" paper is what she told me to read instead
12:19:12 <byorgey> vixey: I don't think I've read that one yet
12:19:23 <dons> hehe http://offthelip.org/?p=116
12:19:26 <lambdabot> Title: Off The Lip » Worlds, Monads and Environment: a Side Effect Roundup
12:19:34 <dons> i love seeing the effects of our shootout work
12:19:36 <byorgey> hmm, that looks like a good one to read though
12:19:38 * byorgey prints it
12:19:41 <dons> "Haskell is and 12th and 21st on single processor architectures
12:19:42 <dons> (Intel and AMD). On a quad-core it’s in the 4th position"
12:20:03 <dons> actually, the 21st is only because the amd single core one isnt updated
12:20:05 <vixey> byorgey, It's super elegant how it works - I don't know about other ways though
12:20:24 <dons> and we're actually 7th on single core.
12:20:41 <C-Keen> I am currently trying yi. I have seen in the demo video that you can run ghci / ghc inside it, how do you do that?
12:21:48 <byorgey> vixey: yeah, me neither.  I'm currently trying to work through the beginning of Ulf Norell's thesis, but I'm not yet sure how the pattern matching in Agda compares/is related to that Epigram stuff
12:21:56 <dons> new scala book will be written in the open , a la RWH, http://www.al3x.net/2008/10/im-writing-book.html
12:21:58 <lambdabot> Title: Alex Payne: I'm Writing A Book
12:23:22 <swiert> byorgey: I didn't know you were on Stephanie's Pie grant. Cool!
12:24:20 <byorgey> swiert: indeed!  it's not official yet (advisor binding doesn't happen until the end of the year) but it seems to be going well so far.
12:25:01 <vixey> byorgey: I think the Agda way is like an interpreter for pattern matching (it has implemented the unification and all that in the implementation), but it can also be implemented as a compiler into eliminators
12:25:18 <swiert> byorgey: if it's of any use, Epigram's case/rec tactics are really quite clever. All the high-level language gets translated down to a small core calculus.
12:25:36 <vixey> byorgey: I'm really curious if it's possible to use universes to get the best of both world ..
12:25:46 <byorgey> vixey: ah, ok, that makes sense.
12:25:53 <byorgey> vixey: what do you mean?
12:26:01 <swiert> Agda takes pattern matching to be a primitive language construct.
12:27:02 <vixey> if you solve the unification problem and all this in the language itsself, your programs are pretty big and I suspect the execution can be a little slower than executing pattern matching by interpreting it in the way agda does
12:27:11 <swiert> byorgey: you may want to look at Conor's Epigram lecture notes for AFP 2004 (if you haven't done so already - it has a very comprehensible sketch of how the case tactic works)
12:27:22 <byorgey> swiert: ok, makes sense.  are they related in some way?  i.e. if you compose the surface -> core transformation and operational semantics of Epigram, do you get something similar to Agda?  or does no one really know?
12:27:46 <byorgey> swiert: I don't think I've seen those.  do you have a link?
12:28:08 <vixey> byorgey, the proof in that paper I mentioned pretty much shows that Agda is equivalent to desugaring into eliminators (except there is one really weird thing I found in Agda which could be a bug)
12:28:09 <Cale> What I want is the code for yi which makes it automatically adjust indentation :)
12:28:45 <jsn> C-Keen: the channels seems to have forgotten :)
12:29:03 <Cale> Which demo video, by the way?
12:29:26 <swiert> byorgey: http://www.e-pig.org/downloads/epigram-notes.pdf
12:29:32 <Cale> ah, this one perhaps :) http://video.google.com/videoplay?docid=4183423992181607417
12:29:34 <byorgey> thanks
12:29:38 <C-Keen> Cale: the one mentioned in the blog, but it is rather poor quality
12:29:38 <lambdabot> Title: Jean-Philippe Bernardy: Yi - An Editor in Haskell for Haskell (Demo)
12:29:39 <lambdabot> Title: Epigram: Practical Programming with Dependent Types
12:29:48 <C-Keen> Cale: yes that one
12:30:08 <swiert> byorgey: sections 2.3 and 3.2 are the ones to look for.
12:30:47 <vixey> oh
12:31:10 <vixey> sweirt, do you know what the <>plus, <plus x y : Nat>, return/call stuff is about?
12:31:20 <vixey> It is not just for clarity is itL
12:31:20 <vixey> ?
12:31:31 <Cale> C-Keen: I want the code which he demonstrates right away there :)
12:31:40 <byorgey> ah, yes, that's the stuff that confused me when I tried to read "the view from the left" =)
12:31:46 <C-Keen> Cale: yeah
12:32:02 <C-Keen> Cale: without it you just get a poor editor emulation
12:32:17 <Cale> oh, actually...
12:32:27 <swiert> byorgey: as for the relation, vixey answered that question. The Agda-style pattern matching is explained in Thierry Coquand's Pattern matching with Dependent types.
12:32:38 <swiert> vixey: No. There's more to it.
12:32:50 <Cale> My yi is doing that... but poorly.
12:33:03 <swiert> vixey: Epigram figured out the left-hand sides of the case branches for  you when you use the case tactic, for example.
12:33:37 <C-Keen> Cale: hm, how do I get the thing to do anything besides emulation vim/emacs behaviour that helps me editing haskell code?
12:34:17 <swiert> vixey: to ensure that it always knows what you're trying to compute the return/call stuff decorates the "compiled" code in the core language (think phantom types, but then the dependent version).
12:34:30 <vixey> oh so it stores the needed metadata?
12:34:33 <Cale> C-Keen: well... I stole my yi.hs from somewhere... but it's mostly the default stuff and vi emulation.
12:35:09 <mattam> vixey: it stores the current refinement of the initial signature.
12:35:12 <vixey> I guess it's actually implemented in Epigram 1?
12:35:22 <vixey> or not?
12:35:27 <dons> ?users
12:35:28 <lambdabot> Maximum users seen in #haskell: 547, currently: 513 (93.8%), active: 16 (3.1%)
12:35:39 <Cale> Yeah, there's nothing in this which specifies non-default behaviour.
12:35:40 <swiert> vixey: I wouldn't call it "metadata", but rather it records information about the program you're trying to write in its the type.
12:35:41 <mattam> It is. You just need to read it to get the patterns on the left actually :)
12:35:56 <vixey> ok I see
12:36:02 <mattam> My [Equations] command does it too.
12:36:13 <Cale> However, my yi doesn't seem to be aware of how far things need to indent...
12:36:21 <noZone> What module/function would I employ in Haskell to execute a shell command, and capture BOTH its output and exit code?
12:36:33 <mattam> It helps reunifying the specialized and the user-given method in specialization by unification.
12:37:00 <C-Keen> Cale: same here
12:37:57 <Cale> C-Keen: also, the block-indenting fails for edits more complicated than adding a few characters before the start of the block
12:38:00 <mattam> vixey: Conor seems to recollect it was called the "let-in" trick by McKinna is the LEGO days :)
12:38:09 <byorgey> noZone: check out the System.Process module
12:38:14 <Cale> (adding a newline breaks it, and deleting that newline again makes things not line up)
12:38:25 <swiert> mattam: hi, btw.
12:38:27 <C-Keen> Cale: and it really is slow here
12:38:34 <noZone> Thanks byorgey
12:38:36 <Cale> C-Keen: slow?
12:38:50 <mattam> swiert: hi! Finished?
12:39:03 <swiert> mattam: I have to submit before November...
12:39:12 <swiert> mattam: so nearly there now.
12:39:14 <C-Keen> Cale: yes, when I use "arrow" keys to scroll down, it sometimes hangs on a line then rushes on
12:39:20 <Cale> hmm
12:39:44 <swiert> mattam: yourself?
12:39:48 <Cale> C-Keen: how big of a file?
12:39:54 <mattam> The last week is great in my experience :)
12:40:32 <mattam> I submitted it almost 2 weeks ago.
12:40:38 <swiert> mattam: Well done!
12:40:50 <mattam> We'll see ;)
12:40:53 <pjdelport> noZone: runInteractiveProcess probbaly
12:40:56 <pjdelport> probably, even
12:40:58 <swiert> mattam: Right now, I'll be happy to get it out the door.
12:41:03 <Cale> C-Keen: For me, whenever it scrolls, it does so such that the cursor is centred.
12:41:17 <C-Keen> Cale: a couple hundred lines
12:41:45 <mattam> I had mixed feelings. That and also excitement to get comments by the examiners.
12:41:46 <Cale> I have a 250 line file here, and I'm not seeing any slowness like that...
12:42:45 <swiert> mattam: I can imagine.
12:42:48 <C-Keen> Cale: ok, my file in question is bigger. It got 2946 lines of literate haskell code
12:43:28 <noZone> pjdelport: thanks
12:43:31 <swiert> mattam: I think I just have to resign myself that my dissertation itself is never going to be perfect, but I have a thesis/ideas worth defending.
12:43:50 <mattam> swiert: You can have a look once you're done, it's on my webpage and it's got plenty of colors :)
12:44:07 <swiert> mattam: will do.
12:44:23 <mattam> Obviously I also think it is wrong in many ways but now it's too late :p
12:46:55 <jeffersonheard> http://hpaste.org/11521  ..  HELP.  I have what I think is the same code in both python and haskell.  Python works on windows, Haskell does not
12:47:14 <jeffersonheard> Baughn, sorry, but I haven't had time to test it yet.  Just trying something very low level first
12:50:28 <Saizan> jeffersonheard: try 50003 instead of PortNum 50003
12:51:32 <jeffersonheard> woo hoo!
12:51:48 <jeffersonheard> why did that work?   is this a network byte order thing?  PortNum should be in NBO?
12:52:02 <Saizan> yeah, i guess
12:52:04 <Saizan> Prelude Network.Socket> PortNum 50003
12:52:04 <Saizan> 21443
12:52:04 <Saizan> Prelude Network.Socket> 50003 :: PortNumber
12:52:04 <Saizan> 50003
12:52:20 <jeffersonheard> ow
12:52:23 <jeffersonheard> what a painful little problem
12:52:27 <jeffersonheard> thanks, Saizan
12:52:33 <jeffersonheard> I've been banging my head against that all day
12:52:35 <dolio> Awesome.
12:53:37 <Saizan> we should get this in the documentation, or maybe just hide the PortNum constructor
12:53:52 <Saizan> it looks quite weird from an API pov
12:54:11 <dolio> Hiding PortNum sounds pretty reasonable.
12:55:14 <dolio> Perhaps replace it with something clearer, like maybeShuffleMyBytes.
12:55:34 <Deewiant> heh
12:55:49 <Cale> heh
12:56:47 <Cale> Or just make everything work in a reasonable way with Integer :P
12:57:20 <Valodim> http://en.wikipedia.org/wiki/Tiling_window_manager
12:57:21 <Valodim> "No new tiling window managers for X were devleoped for some time"
12:57:22 <lambdabot> Title: Tiling window manager - Wikipedia, the free encyclopedia
12:57:25 <Valodim> [citation needed] .V.
12:57:26 <FunctorSalad> a chain of compositions of some sort with an application of some sort at the end is kinda ugly
12:57:35 <jeffersonheard> mask it, I think.
12:57:39 <FunctorSalad> like ( a <=< b <=< c ) =<< d
12:57:41 <Cale> FunctorSalad: hm?
12:57:50 <FunctorSalad> think I'll do a <=< b <=< c <=< const d from now on ;)
12:58:06 <dolio> You can write that as 'a =<< b =<< c =<< d'.
12:58:40 <FunctorSalad> hmm, that's right
12:58:48 <Saizan> Kleisli compositions really look like little fishes
12:59:06 <roconnor> @pl \f -> a . b f
12:59:06 <lambdabot> (a .) . b
12:59:36 <pmurias> why doesn't the FFI read the c header?
12:59:53 <Cale> pmurias: and do what with it?
13:00:07 <Baughn> pmurias: That's what c2hs is for
13:00:12 <dons> pmurias: the FFI is a set of calling conventions
13:00:20 <dons> not a tool for analysing C :)
13:00:20 <pmurias> check if the given FFI definition makes any sense
13:00:30 <dons> we do those separately. c2hs is one tool that analyses the headers to see if they make sense
13:00:53 <jeffersonheard> dons, what's the diff. between hsc2hs and c2hs?
13:01:14 <Baughn> dons: Would it be okay for Network to have a dependency on ByteString, or should I just make a separate package for Network.UDP?
13:01:24 <pmurias> doesn't c2hs convert the c header to an FFI definition?
13:02:02 <dons> hsc2hs doesnt look at the headers
13:02:05 <Baughn> ..or I suppose I could use Ptr like Network.Socket does. That just feels so wrong, though.
13:02:11 <dons> Baughn: separate package i think.
13:02:19 <dons> and network-bytestring is already on hackage?
13:02:38 <Baughn> dons: Well, true. I'm trying to fix up the existing network package a bit.
13:02:56 <dons> cool
13:03:12 <Cale> I should figure out how that layout-aware bit in yi works and fix it to work properly :)
13:03:12 <Baughn> Adding support for udp, etc. etc.
13:03:21 <Baughn> But doing it without breaking the old API is hard
13:04:28 <Baughn> ..also, I feel like having a listening UDP socket return an MVar
13:04:51 <jeffersonheard> Baughn, that would be really helpful
13:05:10 <Baughn> jeffersonheard: On reflection, returning a Handle was silly. :P
13:05:19 <Baughn> I got too caught up in "maintain the current API"
13:08:48 <Baughn> dons: So with that said, and when my purpose is to provide a simple UDP API to go with the TCP API already in Network.. still separate package?
13:09:40 <dons> it's a good place to start.
13:09:48 <dons> since merging code into network package requires using the libraries process
13:10:10 <Baughn> There's a process? ..right, then.
13:10:14 * Baughn is scared of processes.
13:10:25 <dons> well, the community maintains those inner sets of packages
13:10:29 <dons> so its harder to change them.
13:10:37 <dons> if you want to write entirely new modules, doing it on hackage is preferred
13:10:42 <dons> since there's no bottlenecks
13:11:26 <Baughn> I suppose the process I should be looking at here is haskell-platform anyway. There's no /need/ for it to be in Network
13:11:50 <dons> right.
13:12:01 <dons> you can write the Network.Socket.UDP or something and just put it on hackage
13:12:04 <dons> then propose it for the platform
13:12:24 <Baughn> Network.UDP, rather - Network.Socket already does udp just fine, but it's too low-level and easy to get wrong
13:12:42 <Baughn> Right, anyway, I'll get back to working
13:16:11 <jeffersonheard> wondering now... the packet that I get back is full of heterogenous types...  it's not a straight C Struct, it has headers that tell lengths, and all integers and doubles are in NBO.  What package should I be using to slice and dice this?
13:16:41 <Baughn> jeffersonheard: Can you grab the whole thing as an array of bytes?
13:17:07 <jeffersonheard> Yes.  I'm currently using mallocBytes to give me a Ptr to the packet I've received
13:17:16 <jeffersonheard> I was planning on using ByteString
13:17:23 <daf> sounds like a job for Binary
13:17:30 <Baughn> I imagine some combination of c2hs and Binary would do the trick
13:17:34 <jeffersonheard> so I'm doing recvBufFrom
13:17:57 <jeffersonheard> There is no C for this.  I'm reverse engineering some ugly C++ for the OSC protocol
13:18:07 <Baughn> Oh, it's a network protocol?
13:18:19 <Baughn> So it should be specified down to the bit, then
13:18:26 <jeffersonheard> well, it's more a message format than a protocol.  It's built on top of UDP
13:18:27 <Baughn> Then definitely Binary.
13:18:35 <jeffersonheard> k
13:18:41 <Baughn> Or rather, Binary if it's made at all well
13:18:52 <Baughn> Otherwise you might try Parsec-3, though performance will obviously suffer. :P
13:19:07 <marko> hi all
13:19:09 <jeffersonheard> It was written by audiophiles, so I doubt it, and this is fairly performance critical
13:19:28 <jeffersonheard> critical enough that I'm eventaully wrapping this in a forkOS and locking it to a core
13:19:46 <jeffersonheard> what I'm getting are multitouch hand-gestures, and I'm generating events from them
13:20:03 <marko> I have an issue with a library used in ghc. It might be installation related. can anyone help?
13:20:31 <dons> ask your question :)
13:20:32 <marko> Actuall, the library isused from ghc, not part of ghc install
13:21:07 <marko> I have Takusen installed and when I link against it I get errors of undefined symbols
13:21:33 <marko> when I include the path to Takusen libs I get something like this
13:21:46 <marko> marko@prpad:tmp% ghc -i/usr/pkg/lib/Takusen-0.8.3/ghc-6.8.3 example.hs
13:21:46 <marko> example.hs:3:0:
13:21:46 <marko>     Bad interface file: /usr/pkg/lib/Takusen-0.8.3/ghc-6.8.3/Database/PostgreSQL/Enumerator.hi
13:21:46 <marko>         Something is amiss; requested module  main:Database.PostgreSQL.Enumerator differs from name found in the interface file Takusen-0.8.3:Database.PostgreSQL.Enumerator
13:22:25 <olsner> jeffersonheard: sounds like something for Binary
13:22:56 <jeffersonheard> yeah, that's where I'm going with it.  Making Gesture an instance of binary now...
13:23:19 <marko> dons: would you have an answer?
13:23:28 <marko> anybody?
13:23:30 <rwbarton> marko: try ghc --make example
13:23:33 <dons> marko: likely means the library was built with a different version of ghc?
13:23:51 <marko> dons: was built with the same version
13:23:58 <marko> rwbarton: will try --make
13:24:23 <sjanssen> marko: -i/usr/pkg/lib/Takusen-0.8.3/ghc-6.8.3 is the wrong thing to do
13:24:46 <sjanssen> marko: use -package Takusen-0.8.3
13:24:59 * jeffersonheard just found the getWord**be functions and is in heaven.  Now...  can I treat a Word64 to a Double?
13:25:43 <roconnor> @hoogle getWord
13:25:44 <lambdabot> No results found
13:25:47 <mauke> ew, binary floats (I don't know)
13:26:00 <roconnor> jeffersonheard: what functions?
13:26:12 <jeffersonheard> like I said, written by squirrels (er. audiophiles)
13:26:17 <jeffersonheard> roconnor, in Binary
13:26:24 <jeffersonheard> inside the Get monad transformer
13:26:27 <marko> sjanssen: results in undefined references
13:26:30 <marko> marko@prpad:tmp% ghc -package Takusen-0.8.3 example.hs
13:26:30 <marko> example.o: In function `s1cc_info':
13:26:30 <marko> : undefined reference to `Takusenzm0zi8zi3_DatabaseziEnumerator_resultzq_closure'
13:26:30 <marko> example.o: In function `r1c1_info':
13:26:30 <marko> : undefined reference to `Takusenzm0zi8zi3_DatabaseziEnumerator_withSession_closure'
13:26:31 <marko> example.o: In function `r1c1_info':
13:26:33 <marko> : undefined reference to `Takusenzm0zi8zi3_DatabaseziPostgreSQLziEnumerator_zdf31_closure'
13:26:35 <marko> example.o: In function `s1cD_info':
13:26:37 <marko> : undefined reference to `Takusenzm0zi8zi3_DatabaseziPostgreSQLziEnumerator_zdf2_closure'
13:26:39 <marko> example.o: In function `s1cD_info':
13:26:44 <jeffersonheard> marko:  http://hpaste.org
13:26:46 <marko> and much more
13:26:46 <sjanssen> marko: please don't paste so much
13:26:47 <roconnor> ah
13:26:56 <dolio> Use --make
13:27:32 <sjanssen> marko: that probably means you're missing even more -packages.  You can skip specifying the packages by using --make as dolio suggests
13:27:59 <LarstiQ> BONUS_: hmm, your bit about 'fmap' isn't as clear as the rest of the tutorial
13:28:08 <LarstiQ> (to me)
13:28:57 <dons> missing --make
13:29:01 <dons> or not using cabal
13:29:56 <jeffersonheard> okay, def. stuck.  I have to convert binary doubles (word64s) in big endian byte order to doubles in Haskell. Only way I know to do this is to do a lot of pointer casting, and treat certain places as Ptr CDouble.
13:30:01 <dons> very cool, lemmih, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HODE
13:30:08 <lambdabot> Title: HackageDB: HODE-2008.10.27
13:30:27 <marko> using --make does not solve the issue
13:30:46 <marko> when I get to the linking phase I get the same unresolved references
13:30:48 <sjanssen> marko: same errors about undefined references?
13:30:57 <marko> sjanssen: yes
13:31:07 <sjanssen> marko: that seems to indicate that the package was not installed correctly
13:31:27 <marko> I installed it myself from source: so that's entirely possible
13:32:20 <marko> ;-)
13:33:39 <marko> sjansson, dons: will need to get back to this later. Have an appointment now
13:33:42 <marko> ...
13:35:04 <olsner> is there no untilM or whileM function in the standard libraries? I know I've used them both
13:35:35 <Baughn> Pretty sure there isn't. I've _looked_.
13:36:15 <olsner> bleh, so I've built them myself... shall I be forced to yet again build them anew?
13:36:44 <pao> can I install different versions of cabal package, one alongside the other?
13:36:50 <Baughn> pao: Yes
13:37:01 <pao> Baughn: thanks
13:37:09 <Baughn> pao: Though it may not be a good idea, since there are extreme restrictions on when you can mix multiple versions in one program
13:37:43 <Baughn> (That is, mostly, the types won't match. foo-1::Hyperbole is a different type from foo-2::Hyperbole)
13:37:58 <pao> Baughn: the problem is that hdbc-postgresql requires cabal-1.2.x for building... while on my user cache (--user) I have 1.4
13:38:12 <Baughn> pao: That won't be a problem. Install as many cabals as you like.
13:38:22 <Baughn> The build process will only use one, after all
13:38:28 <quicksilver> olsner: you are condemned to do so for all eternity.
13:38:38 <quicksilver> olsner: I wonder what sin you comitted to earn this punishment.
13:38:49 <pao> Baughn: there is an option to specify a version when I invoke cabal-install?
13:39:09 * Baughn wishes there was a way to search through hackage with hoogle
13:39:14 <quicksilver> olsner: I think the problem is that one can imagine a few versions and it's not entirely obvious what is the best.
13:39:39 <olsner> I used an unsafeInterleaveIO the other day, perhaps that's what has condemned me :S
13:39:56 <Baughn> pao: Try cabal install --help
13:40:03 <olsner> yeah, that's probably the problem...
13:40:55 <quicksilver> olsner: having said that, I think I'd opt for:
13:41:03 <quicksilver> whileM :: m Bool -> m a -> m [a]
13:41:12 <quicksilver> whileM_ :: m Bool -> m () -> m ()
13:41:19 * Baughn keeps rewriting splitAt', too
13:41:28 <olsner> mine was \c m -> c >>= (`when` (m >> whileM c m))
13:41:37 <olsner> i.e. your whileM_
13:41:46 <quicksilver> :t let whileM c m =  c >>= (`when` (m >> whileM c m)) in whileM
13:41:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m Bool -> m a -> m ()
13:41:53 <quicksilver> or, very nearly :)
13:42:47 <olsner> hmm, would there be any reason for forcing m to m ()?
13:43:06 <tromp_> whileM_  should be  :: m Bool -> m a -> m () ?!
13:43:12 <Baughn> olsner: So it can discard intermediate results before the whole thing is done?
13:43:44 <quicksilver> olsner: just slightly better type safety.
13:43:51 <quicksilver> olsner: FSOV "better"
13:44:08 <Baughn> Yeah, mine doesn't make sense. The GC should be able to do that anyway. :/
13:44:12 <quicksilver> this debate comes for any combiantor which uses m ()
13:44:14 <olsner> olsnerWhileM_ c m = quicksilverWhileM_ c (m >> return ())
13:44:25 <quicksilver> (any such combinator can use m a, by using >> return())
13:44:41 <quicksilver> so the question is, do we explicitly declare to the type system that we intended to discard the result.
13:44:56 <quicksilver> like the java warning "function called in a void context"
13:45:00 <quicksilver> (or was that C++?)
13:46:21 <olsner> heh, I'm lying though
13:46:30 <olsner> whileM :: Monad m => m Bool -> m () -> m ()
13:46:36 <olsner> says the line above my definition
13:49:31 <pao> if anyone can sugget a way to specify the desired version of the package to cabal-install ... it would be really appreciated :-)
13:51:03 <quicksilver> olsner: the reason I've never suggested it to libraries@ myself
13:51:09 <quicksilver> olsner: is that I never seem to need it in practice.
13:51:30 <quicksilver> in practice, all my programs factor into (takeWhile . map somethingPure $ aList)
13:51:39 <quicksilver> and then mapM somethingmonadic over that
13:52:00 <rwbarton> pao: are you looking for cabal install --cabal-lib-version=foo?  Or cabal install foo-0.1.0.1?
13:52:46 <pao> rwbarton: the second one... let me try... I was looking for a command line option :-(
13:55:07 <pao> rwbarton ... it worked... thanks :-)
13:58:02 <olsner> yeah, whileM doesn't crop up that often, and when it does it seems I usually need some slightly special variant of it anyway
14:01:28 <olsner> @pl \c m -> let x = c >>= (\b -> if b then return [] else liftM2 (:) m x) in x
14:01:28 <lambdabot> (fix .) . (. ((flip (flip if' (return [])) .) . liftM2 (:))) . (.) . (>>=)
14:07:35 <olsner> heh, do I get plus points for not realizing I was actually writing untilM and not whileM? :P
14:25:18 <roconnor> deriving Functors isn't H98 is it?
14:26:37 <rwbarton> does it exist in ghc at all?
14:26:50 <roconnor> oh, maybe not
14:27:11 <roconnor> I figured GHC was smart enough to do that in some cases. ... It seems pretty easy in many cases.
14:27:21 <rwbarton> the derive package can do it
14:27:36 <roconnor> derive package?
14:27:49 <rwbarton> @hackage derive
14:27:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
14:28:06 <byorgey> roconnor: ghc can derive Functor for newtypes, but that's it
14:33:22 <roconnor> aww
14:33:40 <roconnor> I bet clean can do it.
14:34:21 <sjanssen> clean has smarter deriving features?
14:34:25 <vixey> it would be cool if GHC just tried to derive everything it possibly could
14:34:29 <clogged> http://wikis.sun.com/display/WideFinder/Results
14:34:44 <sjanssen> roconnor: do you have a link?  Sounds interesting
14:34:47 <clogged> ocaml showing off, where is the haskell version?
14:34:59 <roconnor> sjanssen: nope.
14:35:19 <roconnor> I'm just guessing based on clean and generic programming being linked in my mind.
14:35:40 <vixey> clogged what is it though
14:37:09 <clogged> Wide Finder 2: processing 42GB of httpd logs, 300X faster than nave Ruby
14:37:34 <pumpkin> :o
14:40:07 <olsner> hmm, where's the depthTest disable-switch hidden in OpenGL? I've found ...OpenGL.GL.Capability.CapDepthTest, but that's in a hidden module
14:40:14 <pao> http://hpaste.org/11525
14:40:30 <pao> today has been a really frustrating haskell day... :-(
14:40:45 <pao> anyone willing to give me any support?
14:41:22 * opqdonut pats pao on the head
14:41:27 <int-e> pao: you have to find out which packages are using bytestring-0.9.1.0 and rebuild them.
14:41:33 <jsn> pao: well, if you could post the command line when you ran this, that would help
14:41:36 <pao> opqdonut: appreciated :-)
14:42:03 <vixey> faster than ruby lol
14:42:06 * int-e wonders whether it's possible to tickle ghc-pkg to divulge which packages those are.
14:42:07 <pao> int-e: yep ... i got to that... but HOW? :-)
14:42:43 <pao> jsn: ghci foo.hs
14:43:21 <jsn> pao: oh, dear
14:43:36 <pao> where foo.hs is http://hpaste.org/11525#a1
14:44:18 <salty-horse> hi. does anyone know if there is a similar origin for haskell's type system and that of "z notation"?
14:44:32 <pao> pao: wonders the same that int-e wonders
14:44:46 <byorgey> salty-horse: what is z notation?
14:44:59 <vixey> salty-horse: I think they're like.. polar opposites, rightL?
14:45:14 <rwbarton> pao: maybe cabal upgrade <whatever-package-provides-Database.HDBC>
14:45:16 <vixey> Z being based on Set theory
14:45:25 <salty-horse> byorgey, it's a formal specification language based on set theory, like vixey just said
14:45:42 * byorgey googles
14:45:52 <salty-horse> vixey, well, I've just started a course, and some of the rules of the type system seem similar to haskell
14:45:57 <salty-horse> http://en.wikipedia.org/wiki/Z_notation
14:45:59 <lambdabot> Title: Z notation - Wikipedia, the free encyclopedia
14:46:13 <rwbarton> pao: that might get you a more informative error message
14:46:37 <vixey> where are the type rules?
14:46:41 <jsn> clogged: where is the sample data?
14:47:09 <clogged> isnt cabal-install available via apt-get?
14:48:15 <jsn> salty-horse: i believe the origin of Haskell's type system is "System F"
14:48:33 <salty-horse> vixey, well, from what I already learned: sets can only be of one type, types are inferred (which may not be much, now that I think of it). other things like having having set comprehension and being lazy reminded me of haskell
14:48:55 <jsn> clogged: is there any? does bray really expect to have a benchmark like that and just post the regular expressions?
14:48:56 <byorgey> salty-horse: I think the answer is yes, in general they both come out of logic, set theory, type theory, and so on
14:49:07 <byorgey> you will likely find many similarities, or ways to translate one into the other
14:49:28 <pao> rwbarton: http://hpaste.org/11525#a2 ... something strange is happening...
14:49:32 <int-e> pao: hmm. here's a dirty hack to do it: make a backup of the (system global, I guess) package.conf file. then, unregister bytestring-0.9.1.0. type ghc-pkg -list - it'll now show some packages in curly braces - those will have to be reinstalled. finally, copy the backup back.
14:49:32 <byorgey> jsn: I think that's a bit more specific than what salty-horse is asking about
14:49:38 <byorgey> I could be wrong though
14:49:42 <salty-horse> since I don't know other language with strong type systems, I have immediately made a connection
14:49:49 <salty-horse> byorgey, I may have jumped to conclusions :)
14:49:59 <jsn> byorgey: it is at the very edge of my knowledge :)
14:50:03 <byorgey> salty-horse: no, I think you are right to see a connection
14:50:11 <byorgey> jsn: hehe, fair enough =)
14:50:31 <vixey> byorgey, so what will /you/ be working on? :)
14:50:36 <salty-horse> byorgey, well, it now seems to me that all strong type systems must have similar rules and properties
14:50:42 <pao> int-e: thanks... I'll try
14:50:47 <vixey> any implementing dependent type system?
14:51:08 <vixey> salty-horse, that lambda guy shows up pretty often :)
14:51:12 <byorgey> salty-horse: there are certain things that will probably be in common across many type systems, such as function types, sum and product types, etc.
14:51:36 <salty-horse> byorgey, I'll learn more in the coming weeks :)
14:51:40 <byorgey> vixey: well, eventually
14:51:48 <byorgey> vixey: right now I'm just doing a lot of reading =)
14:52:04 <salty-horse> too bad my college doesn't offer real courses on lambda calculus or functional programming yet :)
14:52:43 <rwbarton> pao: ok, first thing is I'm confused because there is no HDBC-postgresql-1.1.4.1 on hackage :)
14:52:46 <pao> int-e: sorry to bother again.. how do I unregister bytestring-0.9.1.0? ghc-pkg unregister bytestring-0.9.1.0 doesn't work
14:53:00 <dons> pao, sudo ?
14:53:00 <byorgey> jsn: in fact, GHC Core is based on System F omega, which is in turn based on System F (it's System F + type constructors)
14:53:18 <byorgey> System F is simply typed lambda calculus + polymorphism
14:53:23 <jsn> oh
14:53:33 <pao> dons: --user was missing
14:53:40 <jsn> yeah, i don't think i've really gotten past simply typed lambda calculus
14:54:02 <pao> rwbarton: I installed it from the source...
14:54:05 <jsn> i read a little bit about a year and a half ago
14:54:07 <vixey> jsn, there is a wonderful book
14:54:13 <jsn> vixey: oh?
14:54:22 <vixey> Lectures on the Curry-Howard Isomorphism
14:54:37 <jsn> what does it assume?
14:54:41 <vixey> nothing
14:54:49 <jsn> oh, i will have to have a look
14:54:52 <byorgey> that will give you a nice theoretical overview
14:54:57 <jsn> ah
14:55:00 <vixey> I read it from cover to cover when I first got it :)
14:55:13 <jsn> have any of you looked at "design concepts in programming languages"?
14:55:17 <byorgey> Types and Programming Languages would also be a good place to start
14:55:32 <vixey> It's good because you forget most if it that way.. and you can have the pleasure of reading it again
14:55:36 <rwbarton> debian testing has a newer version of hdbc-postgresql than hackage??
14:55:39 <jsn> i got a copy -- i am a book reviewer for USENIX and somehow this ended up on the pile
14:55:41 <byorgey> vixey: hehe =)
14:55:49 * rwbarton 's mind explodes
14:55:58 <jsn> i will keep those two books in mind
14:56:08 * byorgey picks up pieces of rwbarton's mind
14:56:13 <noZone> emacs haskell mode indentation seems a bit brain dead... could I be doing something horribly wrong or is it just daft?
14:56:23 <lament> noZone: horribly wrong
14:56:24 <byorgey> it's pretty daft
14:56:30 <lament> noZone: try pressing tab repeatedly
14:56:40 <SamB_XP> lament: still rather daft
14:56:52 <noZone> Yes and the tab key just keeps indenting in a silly way.
14:56:52 <byorgey> I think the correct answer was actually "both"
14:56:56 <rwbarton> the indentation mode by kuribas is significantly less daft
14:57:05 <lament> SamB_XP: don't need to try hard to persuade me, i hate emacs and everything to do with it :)
14:57:26 <quicksilver> noZone: use kuribas's indentation mode
14:57:29 <byorgey> vixey: are you a student somewhere?
14:57:35 <quicksilver> @where kuribas-indentation
14:57:35 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
14:57:40 <quicksilver> noZone: ^^ that one
14:57:49 <noZone> Thanks! I'll give it a spin!
14:57:53 <quicksilver> lambdabot: OMG you actually remembered sometimg.
14:59:55 <rwbarton> pao: maybe cabal upgrade -v will give more information
15:00:34 <pao> rwbarton: I'm trying to unregister packages to get dependencies...
15:00:50 <pao> int-e: your advices shed some light
15:01:04 <rog> is there a stock implementation (or generalisation of) the function with type Monad m => (a -> b) -> (a, a) -> m (b, b) ?
15:01:52 <rwbarton> The monad isn't doing much in that type.
15:02:05 <SamB_XP> @pl \f -> return . (f *** f)
15:02:05 <lambdabot> (return .) . join (***)
15:02:07 <rwbarton> @type join (***)
15:02:09 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:02:09 <therp> jsn: I just had a look at its website. I looks interesting.
15:02:28 <vixey> byorgey I mostly just self study things or ramble about it in IRC :)
15:02:42 <byorgey> vixey: ok, just curious =)
15:03:53 <rog> rwbarton: agreed. you're right. i've got the signature wrong.
15:04:26 <jsn> is there a mathematical structure for some type 'T' with a zero element such that '[t0] = [ ]' ? (and thus 't0 : [t1, t2] = [t1, t2]')
15:04:50 <jsn> i mean, i can make it up, of course -- but i thought it might have a name and be written up already
15:04:53 <vixey> jsn, huh ..... o_o
15:04:56 <rwbarton> "the free monoid on a pointed set"
15:05:03 <rog> rwbarton: i think i actually meant Monad m => (a -> m b) -> (a, a) -> m (b, b)
15:05:04 <nomeata> Hi. Is there a way to generate MIPS binaries from Haskell somehow? ghc doesn’t do cross-compiliation, right?
15:05:35 <jsn> vixey: i mean, adding the 0 element of T to a list of T returns the original list
15:05:44 <rwbarton> rog: in that case you might be interested in either Data.Traversable or the Kleisli type
15:06:04 <rwbarton> @type Data.Traversable.mapM
15:06:06 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
15:06:08 <dons> nomeata: ghc has been ported to the mips in the past
15:06:14 <int-e> jsn: no. no matter what t0 is, length (t0 : []) = 1 while length [] = 0.
15:06:15 <dons> there's binaries for 6.2 i think
15:06:23 <dons> nomeata: mips/irix works. probably linux/mips
15:06:38 <jsn> int-e: okay, then maybe i need a new list type
15:06:45 <jsn> or class
15:06:52 <jsn> no, type
15:07:01 <nomeata> dons: But can I generate mips code on my linux/i386 machine?
15:07:06 <dons> nope.
15:07:28 <jsn> (MPlus t) => List' t
15:07:28 <rog> rwbarton: ah. Data.Traversable looks right. is there a reference for "the Kleisli type", or is it just a technique?
15:07:37 <rwbarton> @src Kleisli
15:07:37 <lambdabot> Source not found. Do you think like you type?
15:07:51 <jsn> yeah, i guess that really is what i need to be thinking about -- the container
15:07:58 <int-e> jsn: something like  newtype MaybeList [a] = MaybeList [a]; cons Nothing l = l; cons (Just x) (MaybeList xs) = MaybeList (x:xs)  might do the trick.
15:08:02 <SamB_XP> dons: what about with qemu ?
15:08:09 <rwbarton> @type Control.Arrow.Kleisli
15:08:10 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
15:08:38 <rwbarton> rog: to every monad m there is associated an arrow "Kleisli m"
15:08:51 <jsn> int-e: oh, that is guaranteed to have the same representation as a list?
15:09:10 <Baughn> jeffersonheard: http://hpaste.org/11526 <-- Feel like commenting on this API before I start implementing it?
15:09:15 <rwbarton> rog: and join (***) for the Kleisli m arrow is like your (a -> m b) -> (a, a) -> m (b, b) function
15:09:21 <rwbarton> @type join (***)
15:09:23 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:09:34 <int-e> jsn: yes. but list construction and pattern matching on it won't be so nice.
15:09:37 <rwbarton> rog: imagine a b c == b -> m c
15:09:58 <int-e> @type catMaybes
15:10:00 <lambdabot> forall a. [Maybe a] -> [a]
15:10:28 <int-e> jsn: Intuitively, it's a list variant with a builtin catMaybes.
15:10:35 <pao> rwbarton: thanks... I did it :-)
15:10:44 <pao> int-e: very helpful :-)
15:10:57 <rog> rwbarton: i see. i really need to spend more time on Arrows. but Data.Traversable seems to encapsulate neatly what i was after.
15:11:05 <rog> rwbarton: (thanks)
15:11:22 <rwbarton> rog: (Either way, you'll need to introduce a newtype somewhere to use the existing abstractions.)
15:12:08 <jinjing> @bot
15:12:09 <lambdabot> :)
15:12:11 <int-e> pao: no problem. this will be easier with ghc-6.10:  ghc-pkg unregister bytestring complains: ghc-pkg: unregistering bytestring would break the following packages: haddock-2.2.2 ghc-6.10.0.20081017 regex-base-0.72.0.2 regex-posix-0.72.0.3 regex-compat-0.71.0.1 binary-0.4.3 zlib-0.4.0.5 bzlib-0.4.0.4 language-c-0.3.2 utf8-string-0.3.1.1 cairo-0.9.13 svgcairo-0.9.13 gtk-0.9.13 soegtk-0.9.13 glade-0.9.13 mozembed-0.9.13 gtkglext-0.9.13 gnomevfs-0.9
15:12:53 <jinjing> @bot
15:12:53 <lambdabot> :)
15:13:03 <pao> int-e: has 6.10 been released?
15:13:10 <vixey> 6.11 is out
15:13:11 <Baughn> pao: 6.10.0 has been
15:13:36 <int-e> pao: not yet, we're still in the release candidate phase.
15:14:15 <pao> are the 3 answers "compatible"? :-)
15:14:22 <int-e> pao: there is a ghc 6.10 tree on darcs.haskell.org and snapshots ... hmm, where?
15:14:31 <rog> rwbarton: ... unless i use flexible instances, i guess.
15:14:59 <int-e> pao: yes, actually - 6.11 is the new development branch and has been forked off (or rather, renamed from 6.9). 6.10.0 is the version of the rcs, the release will be 6.10.1
15:15:24 <rwbarton> rog: Yeah... there might already be a Traversable ((,) a) instance too
15:15:39 <pao> int-e: thanks so ghc has never a _._.0 release, right?
15:16:04 <int-e> ah, snapshots are here. http://www.haskell.org/ghc/dist/stable/dist/
15:16:05 <lambdabot> Title: Index of /ghc/dist/stable/dist
15:16:20 <int-e> (for the adventurous)
15:16:29 <int-e> pao: I don't know. I've never seen one :)
15:16:51 <int-e> but I haven't been paying attention before 6.4.1.
15:18:52 <kowey> anybody know what's up with Hac5?
15:19:49 <kosmikus> kowey: Hac5 will very likely be in Utrecht, in March 2009
15:20:32 <waern> kosmikus: cool
15:20:34 <kowey> kosmikus: cool! I think I would like the second darcs sprint to be in conjunction with Hac5
15:20:55 <kowey> (my idea is to have 2 sprints a year, one with Hac, one darcs-oriented)
15:21:31 <kowey> this way, darcs gets (a) the benefit of interacting with the wider Haskell community and (b) some attention all to darcs's own
15:21:35 <kosmikus> kowey: sure. darcs hackers are welcome, of course :)
15:21:46 <kowey> great!
15:22:05 <kosmikus> how many people are at the first?
15:22:32 <kowey> 3 at Brighton, 3 at Portland, 4 at Paris
15:22:41 <kowey> plus 5 or so people working on #darcs
15:22:45 <kosmikus> nice
15:22:56 <kowey> and for sprint 2, everybody in one place
15:23:14 <Cale> -_-; I upgrade GHC from 6.8.2 -> 6.8.3 because the Shim module for Yi apparently requires it, and then it turns out that it's uninstallable anyway, because of a bytestring version conflict.
15:23:36 <olsner> hmm, is there a function for conversion between floating types?
15:23:41 <vixey> software!
15:23:43 <Cale> realToFrac
15:23:51 <olsner> @ty realToFrac
15:23:52 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
15:24:03 <kosmikus> Cale: really generally uninstallable, or just conflicting on your system?
15:24:13 <vixey> rule 1 of software: It does not work
15:24:42 <Cale> kosmikus: I think probably the former. The rest of yi requires a newer bytestring than the GHC API uses.
15:25:01 <kosmikus> kowey: the date for Hac5 will probably be fixed in November. I've been talking to a couple of people during the last few weeks about organisational aspects ...
15:25:25 <nominolo> kosmikus: hac5 will be in november?
15:25:30 <nominolo> or later?
15:25:31 <kowey> ok! I'll forward details as I get them (will be in March)
15:25:45 <kosmikus> nominolo: no, the date will be fixed in November. the Hac will be in March.
15:26:01 <kowey> nominolo: your advice was helpful, btw, thanks!
15:26:02 <nominolo> ah, good
15:26:14 <nominolo> kowey: you were productive? :)
15:26:38 <kowey> well, not me personally, but let's just say we now have over a 100 patches to push into darcs.net
15:26:43 <kowey> :-D
15:26:50 <kosmikus> nominolo: I hope you'll come to Utrecht then :)
15:26:53 <nominolo> ... wow...
15:27:02 <kowey> plus some exciting optimisation plans on the wiki
15:27:03 <nominolo> kosmikus: i plan to, yes
15:29:29 <kosmikus> nominolo: good. how's MSR?
15:29:43 <nominolo> very nice
15:29:47 <ushdf> it's awful
15:29:48 <ushdf> i hated it
15:29:56 <kosmikus> nominolo: what's your project?
15:30:41 <nominolo> kosmikus: API-related.  I'm trying to write an IDE-backend library and add stuff to the API where needed
15:30:53 <nominolo> mostly it's hacking here and there, atm
15:30:54 <Igloo> kosmikus: Do you know what days you expect the hacking to cover? And do you have any plans for accommodation?
15:31:34 <nominolo> hm, is there a ferry from Dover to Holland?
15:32:24 <nominolo> Igloo: the university library ;)
15:32:32 <kosmikus> Igloo: the current plan is to have Friday to Sunday like in Gothenburg. If sufficiently many people are arriving on Thursday, we could have a day or afternoon of talks on Thursday. If some people stay until Monday, there could be some excursion on Monday.
15:32:43 <swiert> nominolo: your probably better off flying from Luton or Stansted.
15:33:03 <kosmikus> Igloo: regarding accomodation, we're checking options, but it's one of the unsolved problems. There are not many good and affordable options in Utrecht.
15:33:06 <swiert> nominolo: there's a boat to Belgium, but not to Holland I think.
15:33:11 <nominolo> swiert: hm, that's not that easy to get to from Canterbury, it al goes via London
15:33:45 <swiert> nominolo: Ah of course. I was thinking how to get to Utrecht from MSR.
15:35:56 <nominolo> swiert: I haven't checked trains, yet, since they are generally more expensive than bus
15:38:43 <Igloo> I think getting a useful ferry means going via Harwich (which means via London, for you and for me, I think)
15:39:44 <halberd> Suppose you have two formal systems A and B, each consisting of a set of well-formed sentences and a set of derivations (valid sequences of sentences)--let a "formal homomorphism" h be a mapping from sequences of sentences in A to sequences of sentences in B, such that "a is valid in A => h(a) is valid in B"
15:40:07 <Igloo> So train is probably a quicker and cheaper option
15:41:26 <nominolo> Igloo: k, thx
15:41:56 <rwbarton> Has anyone gotten wxcore to install from hackage?
15:43:11 <rwbarton> I'm getting what seem to be makefile bugs: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=314#a314
15:47:22 <olsner> hmm, so, I want to follow a file handle, and keep the last 44 thousand or so data items seen in something like an IORef
15:49:17 <rog> is there a way of finding out the mapping between the $f5-style labels found in ghc's profiler output and the actual lambdas they correspond to?
15:50:54 <nominolo> rog: use SCC annotations ?
15:51:22 <nominolo> or, perhaps get the -ddump-simpl output
15:51:35 <nominolo> but be careful, those may change
15:51:54 <nominolo> with every small change to the code, that is
15:52:40 <rog> nominolo: i'd prefer not to annotate every lambda with an annotation...
15:52:51 <rog> nominolo: i'll have a look at -ddump-simpl
15:55:02 <rog> nominolo: what is -ddump-simpl an argument to? it doesn't seem to be mentioned on the profiling page
15:55:12 <nominolo> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
15:55:14 <lambdabot> Title: 5.16.�Debugging the compiler, http://tinyurl.com/t96uq
15:55:35 <nominolo> it dumps the core after the simplifier
15:55:57 <rwbarton> ghc --make foo -ddump-simpl
15:56:37 <nominolo> alternatively, you could consult the typecheckecr output.  i tihnk $f5 could be a dictionary, but I'm not sure, since I thought those would start with d
15:57:00 <nominolo> ah, they're instances, I think
15:57:56 <rog> nominolo: hmm. -ddump-simpl produces... quite a lot of stuff!
15:58:07 <nominolo> they all do
15:58:09 <rwbarton> Yes, it's your whole program :)
15:58:22 <nominolo> maybe you only need the typechecker output
15:58:26 <rog> all i'm trying to do is find out where my infinite loop is...
15:58:35 <nominolo> grep is your friend
15:59:23 <nominolo> try compiling with -Wall, that sometimes gives you hints too
15:59:36 <rog> nominolo: well it certainly would be had i worked out the correlation between $f? and -ddump-simpl output...
16:00:04 <rwbarton> the -ddump-simpl output should have a line that begins  Main.$f5 = ...
16:00:56 <rog> nominolo: that seems a good plan anyway. i get quite a lot of warnings...
16:02:39 <jeffwheeler> Is it possible to install cabal-install 0.6 on ghc-6.10.1 right now? I am having trouble with network wanting base-3.0.3.0, which seems odd; isn't ghc-6.10.1 all base-4?
16:03:01 <dons> yes. network you need to get from darcs.
16:03:17 <dons> darcs.haskell.org/ghc-6.10/packages/network
16:03:19 <dons> iirc
16:03:30 <jeffwheeler> ah, okay; thanks
16:14:52 <noZone> Any thoughts on teaching a first programming language to an 11 year old? Is Haskell ok, or would something else be better?
16:15:57 <vixey> haskell is probably a good choice I think
16:16:06 <vixey> not having taught I can only really guess
16:18:25 <noZone> Well, I have an 11 year old who's pretty smart that I can teach programming. Just curious if there are any pitfalls in Haskell to avoid. I don't want to scar a child for life you know.
16:18:54 <Peaker> I think Haskell's learning curve may be steeper than say Python. However maybe its worth it
16:19:30 <vixey> noZone: Haskell has good foundation unlike e.g. BASIC or Python or whatever
16:19:34 <MarcWebe3> noZone: I'd say try it.. And don't blame haskell if he will refuse programming in another language for the rest of his life :)
16:19:42 <noZone> her
16:19:44 <sw17ch> Is any one here familiar with using the Win32 api from Haskell? Particularly ReadFile with the Overlapped nonsense
16:19:49 <Ikkebr> i would go for python
16:19:52 <Samy> or if she decides never to program, again :-)
16:20:31 <jeffwheeler> I started with BASIC, but I think Python is probably the easiest to start with. It has a various obvious syntax.
16:20:34 <noZone> :)
16:20:36 <MarcWebe3> noZone: And if you compare haskell to Java haskell is much easier because there are no simple types such is Int and Bool which you have to put into objects explicitely..
16:21:15 <jeffwheeler> I love Haskell, but some of the syntax is relatively non-obvious.
16:21:42 <MarcWebe3> jeffwheeler: so is python syntax or C or basic syntax if you haven't done any programming before
16:22:08 <jeffwheeler> MarcWebe3: Perhaps.
16:22:46 <jeffwheeler> Still, though, things like $ might be more complicated than simple parentheses following a function call in all cases.
16:22:47 <Ikkebr> MarcWebe3 atleast in python you can go for multiparadigms
16:22:59 <vixey> haskell is multiparadaigm too
16:23:25 <noZone> I've done my time in "C programmers Anonymous", so I've pretty much kicked the C habit, and I don't find most C descendants very appealing anymore.
16:23:51 * sw17ch still likes C
16:24:09 * jeffwheeler finds C somewhat frustrating, compared to the alternatives
16:24:13 * sw17ch also needs C for his ioctl calls.... Haskell isn't friends with ioctl yet...
16:24:36 <MarcWebe3> noZone: http://esoteric.voxelperfect.net/wiki/Main_Page Don't forget to present this list :-) (kidding)
16:24:38 <lambdabot> Title: Main Page - Esolang
16:24:45 * sw17ch thinks that the Win32 API couldn't have been designed to be worse than it is
16:25:09 <jeffwheeler> MarcWebe3: good thinking. BF is rather simple.
16:25:17 * rwbarton is fighting a C(++) program right now--and losing
16:25:21 <noZone> I've seen a number of the esoteric languages. My favorite is #irp.
16:25:53 * sw17ch begins to sob as he realizes there's no other way to do this...
16:25:59 <electronx> is it possible to use monads in pure functions but no IO monads?
16:27:21 <dons> electronx: sure
16:27:26 <Axioplase> electronx: of course you can use monads in pure functions.
16:27:35 <noZone> "C++ is to C as cancer is to the body.".... can't remember who said that.
16:27:51 <electronx> dons: and call those functions from put functions?
16:27:55 <electronx> pure*
16:28:19 <sw17ch> Data.Binary can run outside of IO just fine
16:28:26 <sw17ch> (i think, correct me if i'm wrong, dons)
16:28:31 <marko> dons, sjansson: I solved the issue I reported earlier with the unresolved symbols
16:28:36 <Axioplase> You know what monads are not pure when you use them.. (IO being one of them, but there isn't that many)
16:29:05 <electronx> so i can mix imperative in pure code
16:29:14 <electronx> with needing io monads
16:29:21 <electronx> without*
16:29:30 <rwbarton> electronx: define 'imperative'
16:29:38 <marko> dons, sjansson: it had been an error I introduced when installing the package for Takusen
16:29:54 <electronx> rwbarton: you know what i mean executes one thing after another
16:30:01 <rwbarton> electronx: No, I don't know what you mean
16:30:10 <electronx> lol
16:30:49 <electronx> say i want to write an imperative algo in haskell but still want to be able to use it from pure functions
16:30:49 <noZone> It is imperative that we be lazy.
16:31:06 <vixey> electronx: You can do that ..
16:31:20 <marko> sjanssen: sorry for clobbering your name...
16:31:21 <electronx> vixey: how?
16:31:21 <rwbarton> electronx: The ST monad is good for that
16:31:37 <electronx> ok
16:31:53 <marko> bye all
16:31:54 <sjanssen> marko: what was the problem?
16:31:59 <electronx> doesn't the rest of the code have to be st monad?
16:32:00 <marko> ahh
16:32:06 <rwbarton> electronx: no
16:32:08 <rwbarton> @type runST
16:32:09 <lambdabot> forall a. (forall s. ST s a) -> a
16:32:11 <MarcWebe3> noZone: No matter what you do you should not forget that you're talking to a kid. Don't overwhelm her. You also have to think about which tools to use (editor etc) and wether she already can do some type writing. if not maybe you should consider kind of chat first :)
16:32:30 <marko> sjansson: I was missing some dependencies from the cabal file I used
16:32:55 <rwbarton> I don't know whether there's an ST tutorial...
16:33:09 <MarcWebe3> If she reads lazy in each sentence here.. she'll be pleased :)
16:34:33 <marko> sjanssen: I started a package for pkgsrc and the INSTALL file calls ghc-pkg, but I forgot some libraries mentioned in the Takusen.cabal
16:35:18 <noZone> She can type, and use an editor. I had her play with a function the other day. Mostly she liked the fact that Haskell can handle enormous numbers, amusing for an 11 year old.
16:35:34 <vixey> not just 11 year olds :p
16:36:17 <Vq^> kicking up some turtle-gfx library for her can also be fun :)
16:36:51 <RayNbow> 11 years?
16:37:54 * RayNbow dabbled in VB5 or something at that age... (the horrors... :p)
16:38:19 <amz> 21:27:22 <noZone> "C++ is to C as cancer is to the body.".... can't remember who said that. <- probably somebody who couldn't get their heads around C++ ;)
16:38:34 <Peaker> amz: who can? :-)
16:38:54 <Vq^> amz: more probable someone who knew it well :P
16:38:59 <amz> I can! ...sorta. :)
16:39:09 <Pseudonym> I'd like to know who thinks C is pure and noble and good.
16:39:14 <amz> After 8 years working with all its insanities, I'm pretty confident that I have a good grasp of it :\
16:39:17 <amz> although sometimes it still surprises me
16:39:26 <electronx> lol C++
16:39:30 <amz> But I just started taking a look at Haskell this weekend
16:39:31 <Vq^> Pseudonym: a person who only has experience with C and C++
16:39:33 <electronx> oh the memories
16:39:59 <Pseudonym> You know, a lot of Haskellers have respect for C++.
16:40:00 <Vq^> :)
16:40:23 <noZone> Respect, like for a dangerous animal?
16:40:31 <Pseudonym> Even C++ experts don't like the syntax much, though.
16:40:33 <Vq^> Pseudonym: what kind of respect would that be?
16:40:35 <electronx> i remeber whatching the doc the hunt for ai and the guy was using C++ and they where complaining about the lots of bugs creeping up
16:40:58 <Pseudonym> OK, let me put it this way.
16:41:03 <vixey> electronx: This tends to happen when people write programs
16:41:11 <Pseudonym> Those who disrespect C++ have, in general, never written anything nontrivial in Modern C++.
16:41:24 <Peaker> Pseudonym: C is cute
16:41:26 <Pseudonym> I know this.  I used to be one of those who mouthed off at it.
16:41:37 <amz> C is... unpleasant
16:41:38 <electronx> vixey: i think if they used haskell or ocaml there would have been far fewer bugs
16:41:41 * RayNbow wouldn't even dare touching the C++ beast
16:41:41 <Peaker> Pseudonym: I hate C++ because of all the many unnecessary pitfalls
16:41:43 <Pseudonym> But now, I'd never choose C over C++ unless I had to.
16:41:49 <vixey> electronx: dunno
16:42:02 <amz> C should only be used for maintenance of legacy code and embedded software, IMO
16:42:06 <vixey> electronx: If _I_ used haskell or ocaml instead of C++ I'd probably do a better job
16:42:16 <amz> but too many people just don't want to go through the effort of learning C++
16:42:19 <Peaker> Pseudonym: and because its exception mechanism destroys the language's staticness, making them unusable for many things, destroying the usability of other features like a collapsing house of cards
16:42:46 <Pseudonym> What you call destroying staticness I call increasing modularity.
16:43:00 <Pseudonym> amz: I agree with that.
16:43:18 <Pseudonym> Most bad C++ code was written by C programmers or Java programmers who didn't bother to learn the language.
16:43:32 <Vq^> C++ feels like a weird lowlevel/highlevel compromise to me
16:43:40 <Peaker> Pseudonym: why modularity?  You cannot statically limit the exceptions that can be raised from methods
16:43:41 <amz> like the people dynamically allocating arrays manually in C++
16:43:43 <Pseudonym> And if anyone ever says "C/C++", you can be certain that they have no idea what they're talking about.
16:44:02 <Pseudonym> Peaker: C++ does have exception specifications, but like in Java, it breaks modularity.
16:44:03 <Peaker> Pseudonym: the throw() clause is IMO kind of a joke, because translating disallowed exceptions to std::undefined_exception is worse than nothing at all
16:44:11 <amz> Vq^: rather than compromise, you could say that C++ reaches all levels, from metaprogramming all the way down to assembly
16:44:12 <Peaker> Pseudonym: why do you say it breaks modualrity?
16:44:19 <Pseudonym> It exposes an implementation detail.
16:44:26 <Vq^> Pseudonym: that can be valid when talking about syntax for example
16:44:27 <amz> and that's part of why C++ is so complex
16:44:32 <Peaker> Pseudonym: No, exceptions can be at the interface level of abstraction
16:45:07 <Pseudonym> Does Haskell's exception system break abstraction?
16:45:11 <Peaker> Pseudonym: you don't throw a Map lookup error, you throw a higher-level error describing the kind of failure in interface-level terms
16:45:12 <Vq^> amz: right, i'd rather mix two languages
16:45:35 <vixey> Vq^: only two? :)
16:45:38 <Vq^> s/mix/use/
16:45:46 <Peaker> Pseudonym: I haven't gathered enough experience with Haskell's exception system, but I thought the concensus was that it was far from perfect
16:45:47 <Pseudonym> Peaker: OK, if your argument is that you can't statically check exception _translation_, I agree with you in part.
16:45:51 <Vq^> vixey: well, not if we need asm as well
16:46:16 <Peaker> Pseudonym: its quite useful to be able to have a throw() that really means no exceptions are thrown
16:46:22 <Vq^> vixey: and maybe not if it is a larger package
16:46:53 <Pseudonym> Peaker: OK, I see what you're getting at, and I have two comments about that.
16:47:29 <Pseudonym> First off, the times when you need real exception specifications like that is the exception, not the rule.
16:47:36 <Pseudonym> You need them at API boundaries, and nowhere else.
16:48:16 <Vq^> im very happy with "exceptions" in Haskell
16:48:24 <vixey> the Either Monad?
16:48:25 <Vq^> of course it isn't just one system
16:48:34 <vixey> or what exceptions
16:48:38 <Pseudonym> Second, this is a special case of a general problem, namely, proving that APIs are encapsulated.
16:48:46 <Vq^> and it doesn't always map directly between other languages exception-systems
16:48:57 <Pseudonym> In general, that's an undecidable problem, even in Haskell.
16:49:11 <vixey> you can formally state encapsulated ?
16:49:22 <vixey> I don't even know what that is really ..
16:49:40 <Peaker> Pseudonym: When we were code reviewing dependable software, it was important for us as code reviewers, to have as much staticness as possible. If every sub-expression in the code might raise exceptions, it is more difficult to reason about the correctness of the code
16:50:07 <Pseudonym> Peaker: I think that depends on the software.
16:50:34 <Pseudonym> I might also add that this seems like a job for static analysis tools that go beyond the compiler.
16:51:01 <Peaker> Pseudonym: My earlier point was that pitfalls like the copy constructor/assignment duality could have been checked by the compiler, but are not, and are repeatedly causing mistakes
16:51:10 <Peaker> Pseudonym: And there are probably hundreds of such little pitfalls
16:51:24 <Peaker> Pseudonym: And when you're living and breathing C++ you may know them all and avoid them and be very productive
16:51:26 <Pseudonym> Well, yes.  Not checking errno in enough places is yet another such pitfall.
16:51:52 <Peaker> Pseudonym: But it is difficult to live and breath a language for long periods of time.  You might do something else for a year, then see you come back and maintain that C++ code
16:51:54 <Pseudonym> But that's not something the compiler can check, realistically.
16:52:17 <vixey> any statement of what encapsulated is?
16:52:37 <Pseudonym> vixey: What I mean in this case is that an API shouldn't leak.
16:52:45 <vixey> idk what that is :S
16:52:49 <vixey> memory leak?
16:53:01 <Pseudonym> No, leak implementation detail.
16:53:02 <vixey> or like, being able to break some assumed invarient?
16:53:07 <Peaker> vixey: I think he meant abstraction leaks -- exposing implementation details to user code
16:53:25 <Pseudonym> The ideal is that you should be able to swap one implementation for another, and everything should just work.
16:54:03 <vixey> ok so it's just that you want to have invarients like .. this list I use internally is sorted .. can never be broken by someone using the library?
16:54:09 <vixey> invariants*
16:54:23 <Pseudonym> Not just that.
16:54:26 <vixey> (or is there more ?)
16:54:27 <vixey> oh
16:54:34 <Pseudonym> Consider a Set.
16:54:35 <Peaker> vixey: Yeah, but I think the more difficult ones are generally corner/error case handling
16:54:39 <vixey> what else is it?
16:54:44 <Pseudonym> It has operations like element membership, union, intersection etc.
16:54:51 <Pseudonym> Suppose you implement that with a sorted list.
16:55:01 <adu> hi
16:55:01 <Pseudonym> This fact shouldn't cross the API boundary.
16:55:08 <Vq^> hi adu
16:55:14 <adu> Vq^: how are you?
16:55:20 <Pseudonym> So if you wanted to implement it with a binary search tree later, y9ou should just be able to do that.
16:55:27 <Vq^> adu: i can't complain
16:55:39 <Vq^> adu: what can we help you with this fine evening? :)
16:55:41 <Pseudonym> So, for example, if you want to find the "least" element in a set, the error message shouldn't be that "head" was applied to [].
16:55:52 <adu> Vq^: I can, I tried installing the latest oo.org (3
16:55:57 <vixey> oh right I see
16:56:04 <vixey> so that's two things, and is there more?
16:56:04 <adu> (3.0) and the latest they have for my mac is 2.4
16:56:19 <Pseudonym> vixey: It's a general principle, but you get the idea I hope.
16:56:29 <adu> Vq^: actually I was hoping I could help, because I know Haskell so well
16:56:31 <vixey> I think I do
16:56:41 <Pseudonym> You also shouldn't expose operations which only make sense on some implementations.
16:56:53 <vixey> so ML modules?
16:57:03 <Peaker> vixey: reliability/error-handling.  An implementation you write the next day might have worse reliability and that easily leaks up to the user
16:57:07 <Vq^> adu: ehm, ok?
16:57:15 <Peaker> vixey: (worse reliability as in uses unreliable things like the network)
16:57:16 <Pseudonym> ML modules can still leak.  It's actually a question of specification and good taste.
16:57:22 <vixey> oh :(
16:58:09 <vixey> if you use something concrete for errors like Either String .. then ideally, you can specify that
16:58:18 <vixey> or Either CustomErrorDataType
16:58:27 <Pseudonym> Right.
17:01:13 <Pseudonym> The problem with statically checking such things is that formally specifying an API to the point where it _can_ be statically checked is actually just as hard as implementing it.
17:01:19 <Pseudonym> In general.
17:01:24 <vixey> I am getting that feeling :)
17:01:25 <Pseudonym> And also just as hard to debug.
17:01:33 <vixey> impression*
17:02:09 <adu> Vq^: is there anything you need help with?
17:04:14 <Vq^> adu: what i need is some sleep, and i think im on my own with that :)
17:11:37 <rwbarton> has anyone managed to install wxhaskell?
17:12:51 <MarcWebe3> rwbarton: os? on linux yes
17:13:02 <MarcWebe3> for win there are installers
17:13:09 <MarcWebe3> What is your problem?
17:13:13 <rwbarton> MarcWebe3: debian testing
17:13:30 <rwbarton> MarcWebe3: did you install it from hackage?
17:13:36 <MarcWebe3> no, nix
17:14:32 <MarcWebe3> And I got the source from sourceforge (0.10.3) maybe there are newer versions now
17:14:59 <rwbarton> what does 'wx-config --cxxflags' print on your system?
17:15:17 <juhp> is there a way to search hackage for what packages depend on a package?
17:15:23 <MarcWebe3> rwbarton: Hard to say :-( I would have to start the compilation procedure..
17:15:39 <dons> juhp: there used to be, but for some reason it is disabled.
17:15:44 <dons> juhp: i think cabal-install can do it though
17:15:51 <juhp> oh hm - ok thanks
17:15:52 <rwbarton> MarcWebe3: hmm?  I think wx-config should probably be installed in /usr/bin if you have wxWindows
17:16:01 <juhp> cool
17:16:06 <MarcWebe3> juhp: Maybe use wget to get all .html pages .. then use grep or get the .tar.gz and use a haskell program to output that info
17:16:25 <juhp> MarcWebe3: sounds painful :)
17:16:42 <dons> juhp: $ cabal install panda --dry-run
17:16:45 <MarcWebe3> rwbarton: nix is totally different. Everyting is installed in /nix/store/hash-package. And you only have it in path if you have installed it. Because wx is only a dep I don't have installed it correctly
17:16:54 <dons> juhp: add -v if you want to see it work out what is already on your system
17:17:50 <juhp> dons: I think that is the other way, no?  I want to know dependee's no dependencies
17:17:53 <MarcWebe3> rwbarton: Are you using tags?
17:17:53 <rwbarton> MarcWebe3: I see.  But you did have the package manager compile it on your machine?  (i.e. not install a binary)
17:17:58 <MarcWebe3> yes
17:18:03 <juhp> no->not
17:18:15 <rwbarton> MarcWebe3: tags?
17:18:24 <MarcWebe3> rwbarton: You don't know about hasktags?
17:18:34 <dons> oh, so that search might only be possible via the hackage search interface
17:18:37 <dons> which i think is disabled
17:18:39 <MarcWebe3> It's an index file telling an editor (emacs, vi) where a function is defined
17:18:44 <rwbarton> MarcWebe3: OK
17:18:49 <juhp> dons: ok
17:19:22 <juhp> was really just wondering which packages depends on zlib
17:19:53 <juhp> guess it would not be that hard to add such queries to cabal-install
17:20:53 <rwbarton> MarcWeber: It looks like wxhaskell is trying to build against a version of wx-config from an slightly different universe :P
17:21:42 <rwbarton> MarcWeber: It's looking for a -D__WXFOO__ symbol, but wx-config doesn't output one
17:23:00 <adu> juhp: probably quite a few
17:23:41 <juhp> :)
17:23:54 <juhp> I know cabal-install does anyway...
17:24:03 <MarcWeber> juhp: You can use hackport as example : http://haskell.org/~gentoo/hackport It does read the index file from hackage.
17:24:04 <lambdabot> Title: Index of /~gentoo/hackport
17:24:05 <byorgey> dcoutts_ probably knows =)
17:24:13 <adu> libz is like the glue of the interwebs
17:24:59 <MarcWeber> rwbarton: You have different choices: try nix (then you'll get a second system.. but you'll have wx tomorrow) or continue to try things. Maybe ask on the mailinglist
17:25:14 <MarcWeber> juhp: Maybe use google and site:<hackage url> as well
17:25:35 <juhp> ok thanks for all the ideas! :-)
17:26:51 <MarcWeber> rwbarton: Which editor are you using at the moment? Are you interested in using tags?
17:27:14 <adu> if i were rwbarton then I would be using emacs
17:27:22 <rwbarton> MarcWeber: emacs
17:27:27 <adu> :)
17:27:50 <rwbarton> MarcWeber: I probably should be interested in using tags, although I'm not sure whether it's related to the previous discussion :)
17:28:17 <MarcWeber> rwbarton: Maybe it is: nix is setup to automatically generate them for all isntalled packages.
17:28:33 <rwbarton> MarcWeber: Ah
17:28:45 <adu> MarcWeber: what do you mean by "nix"?
17:28:46 <rwbarton> MarcWeber: I have cabal set up to install haddocks locally, which is a start
17:29:05 <MarcWeber> www.nixos.org, its a pure package manager and build distribution system
17:29:34 <juhp> (reason for asking about zlib is that it is finally getting a package review for inclusion in fedora... and reviewer was asking if there is any testsuite, but i guess not?)
17:30:35 <rwbarton> "the type system is the test suite"
17:30:58 <adu> thats not quite true
17:31:02 <rwbarton> no, it's not :P
17:32:36 <adu> (Int == Int) does not imply 2 == L4unch 783 M155135
17:32:51 <pumpkin> lol
17:36:19 <adamvo> > 0 * undefined
17:36:20 <lambdabot>   * Exception: Prelude.undefined
17:37:15 <adamvo> for optimization purposes, say for determinants, I have to explicitly add a case for 0*x = 0, right?
17:38:14 <adu> adamvo: but if it is undefined, don't you want to know?
17:39:19 <adamvo> I guess the default * is probably least surprising
17:39:49 <rwbarton> adamvo: it might make sense in a determinant algorithm to define a new * locally
17:40:27 <adu> oic, like the determinant of [[a, 0], [undefined, 1]]
17:41:14 <adu> i have some determinant code if you want to see
17:41:35 <pumpkin> if I wanted to represent a matrix, a list of lists seems like the obvious way, but that allows for non-rectangular matrices... is there some way I can enforce dimensions using n-tuples of m-tuples?
17:41:42 <adamvo> adu: just the simple recursive definition?
17:42:09 * rwbarton also has a determinant function (using gaussian elimination)
17:42:14 <adu> adamvo: nope
17:43:56 <juhp> http://www.google.com/search?q=HackageDB+dependencies+zlib+-"HackageDB%3A+zlib"+site%3Ahackage.haskell.org lists about 30 packages
17:43:56 <lambdabot> http://www.google.com/search?q=HackageDB+dependencies+zlib+-"HackageDB%3A+zlib"+site%3Ahackage.haskell.org
17:48:12 <adu> adamvo: i think this is it: http://hpaste.org/11531
17:50:06 <MarcWeber> rwbarton: Have you received my private message?
17:50:59 <MarcWeber> I'll have a nap then
17:52:26 <adu> I want to see how my parallel gaussian elimination performs on the intel core duo
18:05:43 <sleven> anyone good with Coq? How do i get the latest command? arrow-up doesnt work
18:06:23 <SamB_XP> sleven: you are supposed to use Proof General or something
18:07:04 <sleven> can i apt-get it?
18:07:56 <SamB_XP> um, I'd use aptitude myself
18:10:27 <BMeph> Is there a special name for types that are polymorphic in a higher-kinded type?
18:17:40 <ddarius> Nope.
18:18:05 <dibblego> @type \m x f -> case m of Nothing -> Just x; Just y -> Just $ f x y -- is there a nicer way of writing this?
18:18:06 <lambdabot> forall t a. Maybe t -> a -> (a -> t -> a) -> Maybe a
18:19:12 <dibblego> I guess map then plus
18:19:52 <KatieHuber> hi all -- I'm trying to build an old program of mine that uses Control.Parallel.Strategies on Ubuntu Hardy, but it seems that module isn't available... can anyone confirm, or suggest how to get it?
18:19:56 <pastorn> i read some blogpost or what have you about default values for haskell, this could be seen like having duplicate java methods ( myFun(int x); myFun(int x, int y))
18:20:24 <KatieHuber> google's not being helpful :/
18:20:30 <rwbarton> KatieHuber: Right, ubuntu doesn't package that module at the moment
18:20:41 <rwbarton> KatieHuber: You can install it from hackage though
18:20:47 <dibblego> pastorn, except you don't have partial application in Java, hence the need for such silliness
18:21:14 <BMeph> ddarius: So what's the CT analog (or one "isomorphic, blah-blah-blah...") to it? :)
18:21:29 <pastorn> i want something like maybe, i just don't want to use maybe
18:22:19 <dibblego> pastorn, why don't you want to use maybe?
18:22:21 <pastorn> maybe i could do something like a -> (a -> a) -> a, where (a->a) would be id unless i say something else
18:22:27 <dibblego> @type \m x f -> fmap (f x) m `mplus` Just x
18:22:28 <lambdabot> forall a a1. Maybe a -> a1 -> (a1 -> a -> a1) -> Maybe a1
18:23:10 <KatieHuber> rwbarton: there's no cabal package for ubuntu either?  ('scuse me if that's a silly Q, I've not used cabal or hackage before)
18:23:14 <pastorn> dibblego: this code is already looking like shit, and with the uses of maybe it will look even more like shit
18:23:32 <dibblego> pastorn, code that *needs* maybe doesn't look any more shit than it needs to
18:23:36 <rwbarton> KatieHuber: cabal (the library) is included in the ghc6 package.  cabal install (the command-line program) is not packaged anyware
18:23:40 <rwbarton> *anywhere
18:23:42 <Peaker> KatieHuber: I think not, you can get cabal-install from darcs, and use its "bootstrap.sh" script to install it, and then you can use "cabal update ; cabal install name" like apt :)
18:24:33 <rwbarton> KatieHuber: you can also get cabal-install from hackage and follow those instructions
18:24:36 <rwbarton> @hackage cabal-install
18:24:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
18:25:23 <rwbarton> Definitely the way to go if you plan to install more than one package from hackage ever. :)
18:25:27 <pastorn> dibblego: f mx my g = maybe my (flip f y) mx
18:25:32 <pastorn> sorry
18:25:57 <pastorn> dibblego: f mx y g = maybe my (flip f y . fromJust) mx
18:26:34 <dibblego> pastorn, looks to me like you want >>=
18:27:11 <pastorn> dibblego: no, this is a function :: MyAwesomeDataStructure -> [StringsWithColour]
18:27:19 <pastorn> but not all strings are to be coloured
18:27:24 <pastorn> hence the maybe
18:27:27 <dibblego> pastorn, it doesn't look like it (you are being very vague)
18:27:48 <dibblego> maybe is not required; you can always pattern match
18:28:15 <pastorn> f :: MyAwesomeDataStructure -> CharSet -> [StringsWithColour] -- the charSet is just a giant record for rules, currently i have a utfSet, asciiSet being worked on...
18:29:12 <Peaker> @src Maybe (>>=)
18:29:12 <lambdabot> (Just x) >>= k      = k x
18:29:13 <lambdabot> Nothing  >>= _      = Nothing
18:29:21 <Peaker> @src Maybe mappend
18:29:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:29:30 <Peaker> @src Maybe mplus
18:29:31 <lambdabot> Nothing `mplus` ys = ys
18:29:31 <lambdabot> xs      `mplus` ys = xs
18:29:47 <Peaker> @type mappend
18:29:48 <lambdabot> forall a. (Monoid a) => a -> a -> a
18:30:32 <pastorn> so when i go from MyAwesomeDataStructure -> [String] , picking my representations of the data from my charSet then i COULD have it say Nothing everywhere where i don't want to have a colour and Just where i do, but there are a LOT of records, and i don't want this to look messier than it already is
18:30:39 <KatieHuber> thanks rwbarton et al, that worked great
18:31:02 <Peaker> hmm, where's Maybe's Monoid instance?
18:31:15 <Saizan> Data.Monoid i guess
18:31:20 <Peaker> > Just 5 `mappend` Just 6
18:31:21 <lambdabot>   Add a type signature
18:31:29 <rwbarton> > Just "foo" `mappend` Just "bar"
18:31:30 <Peaker> > (Just 5 `mappend` Just 6)::Maybe Int
18:31:30 <lambdabot>   Just "foobar"
18:31:31 <lambdabot>       No instance for (Monoid Int)
18:31:31 <lambdabot>        arising from a use of `mappend' at ...
18:31:42 <Peaker> oh, right
18:31:53 <Saizan> > Just (Sum 5) `mappend` Just (Sum 6)
18:31:54 <lambdabot>   Just (Sum {getSum = 11})
18:31:54 <dibblego> (Monoid a) => instance Monoid (Maybe a)
18:32:19 <pastorn> Saizan: instance (Monoid a) => Monoid (Maybe a) -- Defined in Data.Monoid
18:32:26 <Peaker> So that's why its useful to have Monad, MonadPlus and Monoid instances.. MonadPlus is not recursive, Monoid is, and Monad is just different
18:32:43 <pastorn> got that from :m +Data.Monoid; :i Monoid in ghci 6.8.2
18:32:52 <dibblego> MonadPlus is on Maybe, where Monoid is on (Maybe a)
18:32:52 <Peaker> Why is MonadPlus :: * -> * and not * ?
18:33:13 <Peaker> dibblego: yeah, but MonadPlus never uses anything but the (m a) form, which is just * ?
18:33:23 <Saizan> because Monad is on * -> *
18:34:16 <Peaker> Why does MonadPlus subclass Monad, why is it not a completely separate thing, maybe NotMonoid ? :)
18:34:36 <Saizan> this ensures that the instance is not special cased on 'a'
18:34:51 <Peaker> interesting
18:34:54 <dibblego> MonadPlus must satisfy left/right identity (mzero) and associativity, like Monoid
18:35:09 <Saizan> it subclass Monad because it's meant to work with Monad and has laws relates to Monad's methods
18:35:24 <Saizan> *related
18:36:29 <lispy> hey party people
18:36:45 <lispy> dons: so if I update my blog based no the darcs sprint, is now a bad time to post to reddit?
18:36:51 <lispy> dons: should I wait till the am?
18:37:32 <dons> do it tomorrow
18:38:12 <lispy> k
18:38:22 <lispy> I'm going to try to hashout some LANGUAGE pragmas
18:38:52 <lispy> I wish I was a sed guru, I could probably just automate this task
18:40:13 <thoughtpolice> lispy: oi, yeah. I had to change a LICENSE notice in one of my projects lately and sed saved me (same with a bunch of LANGUAGE pragmas, actually.)
18:40:24 <thoughtpolice> like 20 files or something
18:40:32 <thoughtpolice> and i'm lazy
18:40:42 <lispy> heh
18:40:48 * Peaker uses grep and a keyboard macro in emacs ;)
18:41:08 <Peaker> M-x grep-find -> find everything,   record macro, change one case,  run macro till beep
18:41:37 <Peaker> program-by-example is great ;)
18:42:13 <thoughtpolice> I surely do use "C-x ( ... C-x )" plenty :]
18:43:07 <thoughtpolice> i've really been wanting to try out yi since it seems to have gotten most of the memory issues fixed in 0.5, but afaics there is no equivilant macro functionality; plus i need to write myself a color scheme before I can tolerate it.
18:43:14 <Peaker> thoughtpolice: the next step is first specifying where to run the macro, and then specifying the macro. so you see it executing everywhere at once
18:43:55 <Peaker> thoughtpolice: then, the next step is to add conditionals and other stuff you can run in a macro. Then, that you can use it on non-strings for real programming ;)
18:45:14 <thoughtpolice> i should probably just bite the bullet and learn elisp probably
18:56:13 <lispy> thoughtpolice: heh, yeah I just used C-x ( ... C-x ) to do this :)
18:56:35 <Peaker> lispy: yay macros :)
18:56:37 <lispy> dons: I'm down to: Could not find module `Data.ByteString.Internal':
18:58:01 <lispy> dons: looks like we use, BI.toForeignPtr, BI.PS, BI.inlinePerformIO, BI.mallocByteString, BI.unsafeCreate and BI.c2w
19:04:43 <lispy> how do I find the haddock for the ghc 6.6 libraries?
19:06:39 <lispy> http://haskell.org/ghc/docs/6.6/html/libraries/index.html
19:06:40 <lambdabot> Title: Haskell Hierarchical Libraries
19:06:41 <lispy> found it
19:16:40 <lispy> dons: we need uncons
19:16:52 <lispy> dons: so, I guess I take it from Data.ByteString's source code :(
19:17:46 <lispy> ?hoogle peekByteOff
19:17:47 <lambdabot> Foreign.Storable peekByteOff :: Storable a => Ptr b -> Int -> IO a
19:25:59 <lispy> ?hoogle fromForeignPtr
19:26:00 <lambdabot> Data.ByteString.Internal fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
19:26:55 <bravedaun> let xs = randomRs (1,6) (mkStdGen 5) in xs
19:39:12 <dons> lispy: it's a one line function
19:39:15 <dons> lispy: so just cpp it
19:39:49 <dons> lispy: http://hpaste.org/11533
19:40:09 <lispy> dons: thanks, I did that
19:40:18 <lispy> dons: now I need a solution for fromForeignPtr
19:40:31 <lispy> dons: the existing code assumes that fromForeignPtr takes an offset
19:40:43 <lispy> but, the bytestring in 6.6 just takes the length
19:41:07 <dons> right, so thats easy enough.
19:41:17 <dons> fromForeignPtr fp s l = PS fp s l
19:41:20 <lispy> okay
19:41:23 <lispy> thanks
19:41:47 <dons> you're effectively writing a compat layer to give bytestring-current the 6.6 api
19:41:59 <lispy> yeah
19:45:09 <lispy> heh
19:45:09 <lispy> ghc-6.6.1: unrecognised flags: -fregs-graph
19:45:18 <lispy> so, 6.6 and 6.10 don't like that flag?
19:46:12 <dons> right.
19:46:14 <dons> don't use it :)
19:48:17 <lispy> someone must have added it during the sprint
19:49:04 <lispy> ?hoogle intercalate
19:49:05 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
19:49:05 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:49:05 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
19:49:43 <sereven> hmm, I have an f :: a -> IO (Maybe (a, a)) -- How can I construct a default IO (Maybe (a, a)) from an (a,a)
19:50:45 <sereven> or a (Just (a,a))
19:51:08 <EvilTerran> ?type return
19:51:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:51:43 <EvilTerran> ?type return $ Just (1,2)
19:51:45 <lambdabot> forall (m :: * -> *) t t1. (Num t1, Num t, Monad m) => m (Maybe (t, t1))
19:52:36 <thoughtpolice> lispy: re - darcs & ghc6.6 on -cafe, i would ask the same of 6.4 while you are at it (maybe eliminate some crust?)
19:53:09 <lispy> thoughtpolice: 6.4 is gone
19:53:23 <thoughtpolice> lispy: ah good
19:53:29 <lispy> :)
19:54:50 <lispy> thoughtpolice: sadly, I think we have to keep 6.6 support until debian pulls their head out of their package manager :)
19:55:54 <dons> perhaps a matrix could be constructed for which distro supports which compiler version?
19:55:57 <dons> makes these decisions easier
20:02:19 <adu> haskell.org/EnterTheDistroMatrix
20:02:21 <adu> :)
20:02:40 <dons> yes.
20:03:21 <chylli> how to get x ^ y in haskell ?
20:03:30 <chylli> sorry
20:03:34 <chylli> forget it
20:03:40 <tromp_> >x^y
20:04:04 <tromp_> > ()
20:04:05 <lambdabot>   ()
20:04:14 <dons> > 2 ^ 4
20:04:16 <lambdabot>   16
20:04:19 <dons> chylli: :)
20:04:29 <lispy> > x ** y
20:04:30 <lambdabot>   x**y
20:04:50 <tromp_> > x^y
20:05:13 <tromp_> > x ^ y
20:05:27 <tromp_> > x+y
20:05:41 <lambdabot>   mueval: Prelude.read: no parse
20:05:42 <lispy> dons: is hGetContents lazy io in bytestring like in haskell98?
20:05:47 <lambdabot>   x + y
20:06:12 <dons> lispy: nope.
20:06:17 <dons> Data.ByteString is a fully strict type.
20:06:17 <lispy> good
20:06:26 <lispy> I need to ratify it
20:06:28 <lispy> for the haskell policy
20:08:14 <dino-> I'm having some trouble building the contact manager packed with hscurses 1.3.0.1 sources. I wonder if anyone here can help.
20:08:50 <jekor> What's the easiest way to convert a String to a ByteString?
20:08:54 <dino-> GHC 6.8.3, hscurses 1.3.0.1, I have libncurses5 installed and have doinked the cm.cabal with extra-libraries:     ncurses
20:09:25 <jekor> dino-: Where does it fail?
20:09:30 <dino-> To get it past the undefined reference business.
20:09:44 <jekor> I can try building it myself.
20:09:57 <dino-> The error I get is: ghc15605_0.hc:(.text+0xebe6): undefined reference to `hs_curses_color_pair'
20:11:01 <dino-> error from ld
20:11:04 <dino-> jekor: Thank you
20:11:12 <thethethe> Hello I am trying to install a package from hackage - binary-0.2. When I go to runhaskell Setup.lhs build, I get an error saying Could not find module `Data.Sequence': it is a member of package containers-0.1.0.1, which is hidden. How do I un-hide this package so I may build binary-0.2?
20:11:25 <sereven> oh duh, I was trying to use fromMaybe on an (IO Maybe a) instead of on the maybeTuple <- f x ... the question wasn't even the question... no wonder return was using the "wrong" monad.
20:12:00 <dino-> thethethe: You may need to put containers in the build-depends: of that project's foo.cabal
20:13:08 <jekor> dino-: It built successfully for me. Must be an issue with how your libncurses is installed. What does ncurses5-config --libs tell you?
20:13:16 <rwbarton> thethethe: (you don't want a more recent version?)
20:13:23 <dino-> mm, I see now it has many build-depends:
20:13:54 <dino-> jekor: -L/usr/lib -lncurses
20:14:35 <thethethe> rwbarton I wasn't aware there was one
20:15:17 <jekor> dino-: Do you have a static version installed? (/usr/lib/libncurses.a, etc?)
20:15:26 <rwbarton> @hackage binary
20:15:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
20:16:25 <dino-> jekor: I do have that /usr/lib/libncurses.a, ++.a, .so, .so.5
20:16:43 <jekor> Apparently hs_curses_color_pair is an inline function. It's mentioned at http://www.haskell.org/haskellwiki/Upgrading_packages
20:16:45 <lambdabot> Title: Upgrading packages - HaskellWiki
20:17:20 <edwardk> @seen sbahra
20:17:20 <lambdabot> sbahra is in #ghc, ##logic, #haskell, ##freebsd and #haskell-blah. I don't know when sbahra last spoke.
20:17:22 <jekor> Which is weird, because that's mentioning GHC 6.10. And I just compiled without errors using 6.8.3.
20:17:41 <dino-> jekor: Yes, I had found that page too but I'm using 6.8.3
20:17:43 <lispy> I want to install ghc 6.10
20:17:49 <lispy> when will it be ready :)
20:18:03 <thethethe> thanks rwbarton, the newer version didn't give me an error =]
20:18:47 <sbahra> jekor, B.pack "string"
20:18:50 <jekor> Maybe it's not in the headers it's trying to include from, if it's an inline function.
20:18:57 <sbahra> jekor, err, pack that is :)
20:19:04 <sbahra> hi edwardk
20:19:18 <jekor> sbahra: pack is telling me that it wants [Word8].
20:19:33 <sbahra> jekor, import Data.ByteString.Char8
20:19:39 <jekor> Ah...Thanks.
20:19:40 <sbahra> jekor, import Data.ByteString.Lazy.Char8
20:19:45 <sbahra> jekor, depending on what you want.
20:20:14 <sbahra> jekor, some very simple code http://kerneled.org/dump/Porte/
20:20:14 <lambdabot> Title: Index of /dump/Porte
20:20:26 <sbahra> jekor, example usage of bytestrings there (look at Ports.hs)
20:20:46 <dino-> jekor: Thank you.
20:22:14 <sbahra> jekor, there is also an extension, -XOverloadedStrings, so you don't have to have packs everywhere
20:22:36 <thoughtpolice> OverloadedStrings is awesome
20:22:45 <jekor> Oh, neat.
20:22:48 <dons> thoughtpolice: what are you overloading?
20:24:38 <thoughtpolice> dons: in a proj. of mine I have a custom Atom datatype that represents names essentially, and making it an instance of IsString (very easily) means I don't have to clutter code with constructors or something like a 'toAtom' function all over the place
20:26:43 <dons> yeah.
20:27:01 <thoughtpolice> same goes for ByteStrings
20:29:24 <dino-> sbahra: oo, I didn't know about OverloadedStrings, thanks!
20:33:49 <sbahra> dino-, thoughtpolice and dons told me about them ;]
20:34:04 <dons> usual caveat about values whose type must be inferred.
20:34:22 <dons> you see a 7 or a "foo", but you'll need to do some type inference to check its not overloaded to something weird
20:37:59 <sleven> i havr coq installed, using ubuntu, how can i get the ide?
20:38:10 <sleven> like Proof General, is there an apt-get?
20:38:51 <lispy> dons: you'll be happy to know I've clean up our changes and it works on 6.6 again :)
20:39:15 <dons> yay.
20:39:18 <dons> so what had to change?
20:39:23 <dons> want me to check with 6.10?
20:39:29 <lispy> oh, please do
20:39:33 <dons> if you stick 'em in the lispy repo, i'll investigatify
20:39:46 <lispy> dons: they are in the lispy repo, need the url?
20:39:50 <dons> nope
20:40:02 <lispy> main thing is that I had to add 3 BS functions
20:40:19 <lispy> uncons, fromForeignPtr, and intercalate
20:40:52 * dons does a cabal install
20:40:54 <dons> oh, easy.
20:41:02 <lispy> muwhahahah!
20:41:05 <dons> and use the 'real' ones otherwise?
20:41:08 <sleven> i havr coq installed, using ubuntu, how can i get the ide?
20:41:26 <lispy> dons: kinda, I renamed them, uncons = B.uncons
20:41:44 <lispy> dons: and then {-# INLINE uncons #-}, I'm open to suggestions though
20:42:22 <dons> ah i see.
20:42:23 <dons> yeah, easy.
20:42:25 <lispy> dons: I'm hoping that GHC has a way to make that optimize away
20:42:30 <dons> builds with 6.10
20:42:33 <dons> yes. should be fine.
20:43:14 <dons> yes. looks good , looking at the patch.
20:43:15 <dons> onward!
20:43:19 <lispy> woot!
20:43:46 <lispy> I was really tired by Sunday night, but the sprint was a good thing.  I'm glad we could do it.
20:44:00 <dons> :)
20:45:22 * lispy keeps his hopes high that his pessimistic attitude about patch acceptance is WRONG
20:45:48 <lispy> I should start running the sprint darcs, to see if it's faster
20:53:49 <sleven> since #Coq isn't very helpful. Is there an apt-get for a Coq-IDE. Which IDE do you recommend? Is there an emacs-mode?
20:54:40 <sleven> i had to relogin, didnt someoen answer?
20:54:47 <geezusfreeek> sleven: there is an ide called coqide
20:54:55 <geezusfreeek> i don't know about an apt-get package for it though
20:56:38 <geezusfreeek> and that is probably all the help i can be :)
20:59:08 * shapr does 'make install' for ghc-6.8.3 on his ps3
20:59:17 <edwardk> good luck
20:59:32 <shapr> edwardk: How's code?
20:59:37 <edwardk> good actually
20:59:43 <edwardk> working on syscalls now
21:00:00 <shapr> nifty!
21:00:09 <edwardk> hard to find good documentation of the linux kernel abi since its not documented very clearly
21:00:16 <edwardk> er
21:00:26 <edwardk> hard to find out what to do with respect to it anyways
21:00:55 <shapr> Hey, did you get my email?
21:01:06 <ddarius> #haskell-blah perhaps?
21:01:12 <edwardk> i'm currently assuming i can dump reg contents for r10, r12- r15 and that anything else is dangerous
21:01:14 <edwardk> sure
21:01:15 <lispy> shapr: whoa
21:01:24 <shapr> lispy: Next I build darcs for the ps3
21:01:42 <lispy> shapr: with cabal install I hope
21:01:45 <dons> ?check \x -> let _ = x :: Double in round (1 + x) = 1 + round x
21:01:45 <lambdabot>   Parse error at "=" (column 44)
21:01:52 <shapr> I have to install cabal first...
21:01:52 <dons> ?check \x -> let _ = x :: Double in round (1 + x) == 1 + round x
21:01:53 <Nafai> Hey shapr!
21:01:53 <lambdabot>   "Falsifiable, after 1 tests:\n-0.5\n"
21:02:08 <shapr> hiya Nafai!
21:02:53 <lispy> shapr: you may also find you need some changes that aren't yet in the darcs HEAD
21:03:01 <shapr> oh?
21:03:02 <lispy> shapr: but there is a darcs cabalized on hackage
21:03:21 <lispy> shapr: yeah, we had a darcs hacking sprint this weekend and dcoutts gave us pure cabal support
21:03:32 <lispy> shapr: but, that's not in HEAD just yet
21:03:35 <shapr> oh
21:05:23 <lispy> shapr: if you have autotools then the one on hackage will work for you
21:06:46 <idnar> the brain fails at localising sounds
21:06:48 <shapr> ok waitasec... How do I build Cabal 1.6 if I don't have any Cabal at all?
21:06:55 <idnar> er, wrong window
21:07:23 * shapr manually grabs libraries...
21:09:47 * shapr sighs
21:09:54 <shapr> GHC 6.8.3 comes with Cabal 1.1.4
21:10:05 <lispy> yeah, that cabal is ancient
21:10:11 <lispy> shapr: bootstrap.sh
21:10:17 <lispy> shapr: in the cabal-install repo
21:10:20 <rictic> It seems like many times Haskell's powerful type system constrains you down to where there are very few options that would even compile.  Has anyone done any work to try and give suggestions like this?
21:10:46 <lispy> rictic: I'm not sure what you're asking
21:10:53 <shapr> lispy: Fortunately, I have darcs on my x86 box... otherwise this would be recursively irritating :-)
21:11:02 <lispy> rictic: definitely people do research about using the type system to make it hard to screw up
21:11:03 <lament> rictic: you mean like "Try changing x to y there?"
21:11:12 <rictic> Perhaps it's usually intractable, but, e.g. given the type (a -> a) the only values that could have that type are "id" or "undefined"
21:11:37 <lispy> rictic: there are free theorem that is related
21:11:38 <rictic> Yeah, I'm not expressing myself well here
21:11:38 <sjanssen> @djinn a -> a
21:11:39 <lambdabot> f a = a
21:11:48 <lispy> ?go theorems for free
21:11:52 <lambdabot> http://citeseer.ist.psu.edu/wadler89theorems.html
21:12:08 <lispy> ?free id :: a -> a
21:12:08 <lambdabot> f . id = id . f
21:12:38 <lispy> ?free map :: (a -> b) -> [a] -> [b]
21:12:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
21:12:52 <rictic> My thinking is that many times, if you specify a type there's only a handful of values that could possibly have that type.
21:12:58 <shapr> lispy: Thanks for pointing me to bootstrap.sh!
21:13:13 <shapr> argh
21:13:16 <lispy> shapr: you are welcome
21:13:25 <shapr> bootstrap.sh requires cabal >= 1.2 :-(
21:13:29 <lispy> doh!
21:13:34 <dmwit> rictic: In general, finding a term with a particular type is as hard as proving an arbitrary theorem.
21:13:51 <dmwit> rictic: This observation can be made very rigorous using the Curry-Howard isomorphism.
21:14:05 <dmwit> rictic: Also, the number of "values" is not so small as you might think.
21:14:14 <rictic> dmwit: Ha, fascinating.
21:14:25 <dmwit> rictic: For example, (a -> a) has f x = x, but it also has f x = (\y -> y) x.
21:14:40 <dmwit> rictic: To you and me, it's obvious that those "behave" the same, but proving it is rather more difficult.
21:14:49 <shapr> cabal-install's bootstrap.sh fails with a just-built ghc 6.8.3 - http://hpaste.org/11535
21:15:02 <ddarius> Crap, I still need to write a paper that Wadler never did.
21:15:16 <shapr> I built ghc 6.8.3 with the ghc 6.4.2 from fedora extras.
21:15:23 <shapr> ddarius: Yes, write it!
21:15:28 <rictic> dmwit: Ok, yeah, I see what you mean
21:16:20 <rictic> I'm kinda surprised that it's nontrivial to prove that those two are the same.
21:16:46 <dmwit> Well, any particular example is probably not too hard.
21:16:49 <lament> rictic: because that involves evaluating a function
21:16:57 <lament> rictic: which might not even terminate
21:16:58 <dmwit> It's generalizing the observation that is hard. =)
21:17:17 <lispy> shapr: I'm not really sure
21:17:18 <rictic> Heh, of course
21:17:23 <dmwit> Also, keep in mind that your prover has to be able to *not* spit out a proof for things that are not true. ;-)
21:17:44 <lispy> shapr: mainly you need a couple thinsg from hackage
21:17:49 <lispy> shapr: zlib and HTTP for sure
21:17:58 <rictic> dmwit: I suppose consistency is valued by some
21:20:14 <dino-> bleh, can't build hetris either, same hs_curses_color_pair thing
21:20:21 <rictic> Thanks a lot for the insight. As usual I feel much enlightened after only a few moments in #haskell
21:20:26 <shapr> My love for cabal increases dramatically when it doesn't work...
21:20:42 <shapr> I had totally forgotten how picky ghc can be without cabal.
21:21:10 * lispy nods
21:21:21 <lispy> shapr: can you get zlib and HTTP?
21:21:28 <lispy> shapr: or do you need to upgrade cabal first?
21:21:39 <shapr> I think I'll need filepath no matter what I do.
21:21:54 <sbahra> newsham, BTW, I'm not sure if someone directed you...
21:22:00 <edwardk> shapr: friends don't let friends use filepath
21:22:01 <sbahra> newsham, but there is a #win32 channel or similar.
21:22:07 <shapr> edwardk: System.FilePath?
21:22:10 <sbahra> newsham, maybe your answer can be found there.
21:22:22 <lispy> edwardk: why is that?
21:22:24 <newsham> sbahra: ty
21:22:25 <edwardk> oh my mistake
21:22:38 <edwardk> i thought you meant whatever that thing your former boss espoused was
21:22:44 <shapr> HAppS
21:22:48 <edwardk> no the other thing
21:22:51 <edwardk> the cabalish one
21:22:53 <shapr> Oh, that thing.
21:22:55 <shapr> um
21:22:57 <lispy> franchise?
21:23:00 <shapr> I forgot its name.
21:23:03 <edwardk> hah
21:23:03 <dino-> searchpath?
21:23:06 <shapr> yeah!
21:23:06 <edwardk> yeah
21:23:08 <edwardk> thats it
21:23:09 <edwardk> sorry
21:23:13 <edwardk> blotted it out ;)
21:23:19 <lispy> what is searchpath?
21:23:22 <thoughtpolice> lispy: oh i did finally get darcs 2.1 to build on os x with franchise
21:23:41 <edwardk> you were talking cabal and mentioned *path and my brain went the wrong way
21:23:46 <shapr> lispy: alexj's approach to cabal.
21:23:55 <lispy> thoughtpolice: ah, interesting.  I haven't tried.  Instead I just removed the franchise cruft and build with either cabal or autotools
21:24:12 <dino-> http://searchpath.org/
21:24:12 <edwardk> "franchise"?
21:24:21 <lispy> edwardk: droundy's version of cabal
21:24:23 <lambdabot> Title: SearchPath — Automatic import chasing across the Internet for Haskell modules
21:24:26 <edwardk> ah'
21:24:28 <shapr> searchpath has some interesting ideas, things that could be good to integrate into cabal.
21:24:41 <sjanssen> lispy: just sent you a patch on the darcs-sprint repo to review and test on ghc 6.6
21:24:56 <lispy> sjanssen: which repo, good sir?
21:25:16 <lispy> sjanssen: the one in my home dir?
21:25:19 <sjanssen> lispy: it's a small clean up of your 6.6 compat patch that just re-exports functions rather than wrapping them
21:25:23 <sjanssen> lispy: http://code.haskell.org/darcs/sprint/
21:25:23 <lambdabot> Title: Index of /darcs/sprint
21:25:27 <thoughtpolice> lispy: yeah it's moving pretty fast but i'm already using franchise for a project of mine
21:25:32 <thoughtpolice> mainly because createFile rocks
21:25:34 <sjanssen> lispy: is that the right thing?
21:25:37 <thoughtpolice> and makes things cleaner indeed
21:26:00 <sjanssen> lispy: I just started hacking on the repo that @google darcs sprint turned up :)
21:26:01 <lispy> thoughtpolice: ah, well I hope when franchise 2.0 gets released the announcement doesn't say you should have used cabal all along.  That would suck.
21:26:11 <lispy> sjanssen: oh did you email it?
21:26:15 <thoughtpolice> hah
21:26:28 <sjanssen> lispy: right, I sent it just now
21:26:33 <lispy> kk
21:27:11 <thoughtpolice> lispy: i like it because it's flexible; I've wanted a build system like franchise for a while tbh
21:27:30 <thoughtpolice> it's really pretty simple but you can do some arbitrarily complex things like in the darcs Setup.hs :p
21:27:42 <lispy> yeah, same with cabal
21:28:08 <lispy> sjanssen: I'm trying it out, thanks
21:29:24 <lispy> sjanssen: this will be one less thing to clean up when we drop 6.6
21:30:14 <sjanssen> lispy: is ByteStringUtils usually used qualified?  It might make sense to call it ByteStringCompat, and re-export the entire Data.ByteString module
21:30:41 <lispy> thoughtpolice: the few things that franchise doest that cabal doesn't have built in could be added to Cabal.  In fact, since they have compatible licenses I have no idea why franchise exists
21:31:13 <lispy> sjanssen: Well, other than this new bit I added to get 6.6 working it was all new stuff built on top of BS
21:31:32 <lispy> sjanssen: as for being qualified?  I'm not sure.  Most modules just use import lists without being qualified
21:31:47 <thoughtpolice> lispy: because competition is good?
21:31:49 <thoughtpolice> :p
21:32:13 <sjanssen> lispy: I guess the current method is best if you're thinking about dropping 6.6 support, less cruft to clean up later
21:34:16 <sjanssen> lispy: what about the biggest franchise feature (or mis-feature): not having to write a .cabal file with packages and version dependencies?
21:34:36 <lispy> sjanssen: I think I'll push your patches
21:34:48 <lispy> they build just fine and they don't make enough change to fail the tests
21:35:16 <sjanssen> good.  They should be no change for 6.6, but I wanted to make sure
21:35:38 <lispy> Applied.  Thanks!
21:36:51 <sjanssen> ooh, there are all kinds of darcs sprint repos!
21:36:56 * lispy is happy about the improved annotate, autotool-less cabal support and modern bytestring usage that resulted from the sprint
21:37:04 * sjanssen 's hacking voyeurism kicks in
21:37:29 <lispy> sjanssen: we had to fork the sprint repo when some (me) broke ghc 6.6 support
21:37:56 * lispy heads home
21:45:56 <twb> I have an Debian/Linux i386 (GNU libc) laptop.  I want a statically-linked Darcs binary for OpenWRT (MIPS architecture, uClibc).  How do I go about cross-compiling?
21:46:44 <dons> twb: you have to port ghc to the mips first
21:46:52 <twb> Bugger.
21:46:55 <dons> ghc is not currently a cross compiler
21:46:58 <twb> I was afraid of that.
21:47:00 <dons> ghc has been ported to the mips beforehand
21:47:09 <dons> and i would not be surprised if debian/mips has a ghc
21:47:10 <twb> I'll have to use sshfs instead of darcs push :-(
21:47:13 <sbahra> Does GHC work well on QNX?
21:47:19 <dibblego> was dcoutts_' talk at Galois recorded?
21:47:39 <dons> twb: http://packages.debian.org/lenny/mips/ghc6/download
21:47:47 <dons> twb: so just use the debian mips binaries
21:47:48 <dons> dibblego: no
21:47:50 <lambdabot> Title: Debian -- Package Download Selection -- ghc6_6.8.2-7_mips.deb
21:48:04 <twb> dons: hmm, so I can compile as long as I can find a MIPS machine that has enough CPU and memory to run GHC.
21:48:09 <dibblego> dons, bummer I'll just read the slides
21:48:27 <jekor> Is there a simple way to add a time interval to a ClockTime? Like, +1 day? I don't want to have to contstruct an entire TimeDiff manually.
21:48:29 <dons> twb: http://packages.debian.org/sid/mips/darcs/download
21:48:30 <lambdabot> Title: Debian -- Package Download Selection -- darcs_2.0.2-3_mips.deb
21:48:42 <dons> there are prebuilt binaries of darcs/mips/linux
21:48:45 <twb> dons: that's for libc
21:48:53 <twb> dons: and it won't be statically linked
21:48:58 <twb> (I assume.)
21:49:03 <dons> well, i'd check that first.
21:49:10 <twb> Good point.  I'll check.
21:49:11 <dons> but otherwise, you'll need to reproduce that build environment
21:49:33 <twb> Maybe I can do that by running qemu-system-mips and Debian/uclibc
21:50:16 <dmwit> jekor: I recommend switching to Data.Time rather than System.Time.
21:50:26 <dmwit> ?index ClockTime
21:50:27 <lambdabot> System.Time
21:50:30 <dmwit> yeah
21:50:42 <jekor> dmwit: Network.CGI requires it. Is there a way to convert a System.Time time to CalendarTime?
21:51:09 <dmwit> I don't know a good way of converting between System times and Data times.
21:51:13 <dmwit> But then, I've never looked for one.
21:51:25 <twb> Hmm, this is promising:
21:51:25 <twb> $ ldd usr/bin/darcs
21:51:25 <twb>         not a dynamic executable
21:51:49 <jekor> Thanks.
21:51:53 <twb> This isn't: $ file usr/bin/darcs ==> usr/bin/darcs: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.8, with unknown capability 0x41000000 = 0xf676e75, stripped
21:53:04 <dons> i'd trust ldd :)
21:56:58 <twb> scp usr/bin/darcs ymir.twb.ath.cx:/srv/
21:56:59 <twb> darcs       1%  416KB  18.1KB/s   25:24 ETA
21:57:02 <twb> Sigh.
21:57:40 <twb> At least I have a USB key in it now, since darcs is 5MB and the onboard SDD is 4MB.
22:00:44 <sleven> how do i install cabal and cabal-install on ubuntu? there doesnt seem to be an apt-get
22:01:35 <dmwit> No apt-get?
22:02:03 <dmwit> Anyway, I just grabbed the cabal-install package from hackage and sourced bootstrap.sh.
22:02:19 <sleven> and then you said booyakasha!
22:02:31 <dmwit> ?hackage cabal-install
22:02:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:02:38 <dmwit> (In case you didn't know where hackage was. ;-)
22:02:50 <twb> dmwit: apt-file search cabal-install ==> no hits
22:02:59 <edwardk> shapr: syscalls work
22:03:00 <rwbarton> Some day...
22:03:06 <dmwit> Ah, yeah, it's a bit new for Ubuntu, I guess.
22:03:16 <dmwit> Also, apt-file?  Not apt-cache?
22:03:19 <twb> I get the impression that all the Haskell hackers have abandoned Debian (and thus Ubuntu) in favour of Arch :-(
22:03:35 <twb> dmwit: apt-file, unlike apt-cache, search the list of files from packages that aren't installed.
22:03:48 <sleven> what is good about Arch?
22:03:52 <sleven> @seen spj
22:03:52 <lambdabot> I haven't seen spj.
22:03:53 <rwbarton> twb: nah, once you install cabal-install, it doesn't matter much what distrib you are on
22:03:55 <dmwit> twb: I have abandoned the repositories in favor of hackage. =)
22:03:57 <dolio> I tried to move to arch, but the installer crashed.
22:04:07 <dolio> @seen simonpj
22:04:08 <lambdabot> I haven't seen simonpj.
22:04:09 <edwardk> i use ubuntu because i don't have to think about it for the most part and it gets out of my way and lets me code
22:04:23 <twb> sleven: I think they have are less strict about packaging.
22:04:34 <dmwit> twb: Also, I have an apt-cache but no apt-file here, and apt-cache most definitely searches through packages that are not yet installed.  Maybe a version mismatch between us?
22:04:50 <twb> dmwit: apt-cache searches through package *descriptions* of all packages
22:04:54 <dolio> Arch is convenient for haskell hackers because everything on hackage automatically gets turned into an arch package, basically.
22:04:56 <rwbarton> dmwit: apt-file is awesome
22:05:08 <twb> dmwit: apt-file search through the list of files provided by those packages.
22:05:18 <twb> dmwit: "apt-get install apt-file; apt-file update"
22:05:46 <twb> dolio: is the existence of that hackage->arch code a symptom, or a cause? ;-)
22:06:03 <sleven> how can i check easily i i already have cabal?
22:06:28 <dolio> Well, it happened around when dons switched to arch, I think. I don't know which happened first.
22:06:58 <dmwit> sleven: ghc-pkg list cabal
22:07:00 <twb> I'm just grumpy because I'm not used to Debian not having packages.
22:07:13 <sleven> im nee to ubuntu/linux. can i run the Setup.hs from anywher and it will isntall where it should?
22:07:23 <dmwit> sleven: But note that cabal the binary is provided by the package cabal-install, not the package cabal.
22:07:31 <sleven> /usr/lib/ghc-6.8.2/package.conf:
22:07:46 <dolio> I doubt he'd have convinced the Debian folks to have all of hackage automatically stuck in their repository if that's where he'd wanted to switch to, though.
22:07:47 <sleven> so i only need cabal-install?
22:07:53 <dolio> But maybe I'm wrong.
22:08:09 <dmwit> sleven: If you run bootstrap.sh in the cabal-install tarball, it should grab all the dependencies for you.
22:08:22 <sleven> and how do i run it?
22:08:23 <twb> dolio: Debian people don't trust upstream to Not Fuck Up
22:08:32 <dmwit> sleven: "source bootstrap.sh"
22:09:05 <twb> dolio: so yeah, there'd pretty much have to be some (minimal) human review for packages getting from hackage into Debian
22:09:57 <twb> I suppose if you could make .dsc and .deb files from hackage that passed lintian without errors, that'd be close enough.
22:11:54 <rwbarton> You'd get most of the benefit just by packaging cabal-install.
22:12:17 * dmwit nods
22:13:38 <idnar> well, you could stick an apt repository on hackage or somewhere else that has automatically generated debs
22:13:53 <sleven> nice it goes on forever then crahses on the finish line
22:13:54 <idnar> I like cabal-install because I can install stuff locally
22:14:03 <sleven> Setup: At least the following dependencies are missing:
22:14:03 <sleven> HTTP >=3000 && <3002, network >=1 && <3
22:14:03 <sleven> Sorry, something went wrong.
22:14:49 <idnar> more to the point, I can install stuff locally (as in, for my own user), and it Just Works
22:15:07 <idnar> doing that with Python requires a lot more effort
22:15:36 <dmwit> sleven: Can you post the entire output to something like hpaste.org?
22:15:42 <dmwit> It would help us diagnose the problem.
22:16:47 <idnar> also, uhm
22:17:22 <idnar> hmm, I suppose Hackage packages have dependency / version information
22:18:06 <idnar> but I guess that's probably backwards-looking most of the time, not forwards-looking
22:18:12 <dmwit> idnar: I have found that things can sometimes not Just Work when mixing user and global libraries.
22:18:30 <sleven> http://hpaste.org/11538
22:18:34 <idnar> dmwit: oh, well, I'm sure there are all sorts of ways you can break your system
22:18:54 <idnar> dmwit: what I mean is that I don't need to spend an hour hacking the installer system just to get a locally installed copy
22:19:05 <dmwit> right
22:19:24 <dmwit> ?hackage cabal-install
22:19:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:19:29 <idnar> coming back to what I was saying, if a new version of A breaks B (which depends on A), that's probably not reflected in the dependency information
22:20:03 <dmwit> sleven: you got cut off (probably by hpaste.org's 5K limit)
22:20:04 <idnar> so there's always going to be some level of human oversight required when it comes to distribution packaging
22:20:12 <idnar> (or desired, if not required)
22:20:28 <dmwit> idnar: .cabal files have a way of specifying a maximum version.
22:21:16 <idnar> dmwit: sure, Debian dependencies have the same thing; but you don't always know in advance that some particular change is going to break your code
22:21:23 <sleven> http://hpaste.org/11539
22:21:42 <dmwit> true 'nuff
22:21:55 <idnar> anyhow, the less effort you have to duplicate between "upstream" and "Debian" packaging, the easier life is for the Debian maintainer of the package
22:22:03 <sleven> http://hpaste.org/11540
22:22:21 <idnar> so I think Debian package "generation" is still quite a useful thing, even if the packages aren't going to be automatically uploaded straight into Debian
22:22:47 <svar0g> question: why does http://hpaste.org/11541 begin to produce negative numbers after a certian number?
22:22:56 <svar0g> <- New to haskell
22:22:57 <twb> idnar: +1, definitely
22:23:00 <idnar> which is the whole point of cabal-debian, I guess
22:23:14 <twb> idnar: even if I had to add a sources.list entry, it'd be far less hassle than putting up with "sudo ./Setup.hs install"
22:23:19 <idnar> I'm not really involved with Haskell stuff in Debian at the moment, but it's something I'll be looking at once I'm a DD
22:23:19 <dons> svar0g: maxBound Int
22:23:27 <dons> > maxBound :: Int
22:23:29 <lambdabot>   9223372036854775807
22:23:30 <dons> > maxBound + 1 :: Int
22:23:30 <lispy> svar0g: it's because the values roll over
22:23:32 <lambdabot>   -9223372036854775808
22:23:36 <lispy> svar0g: change Int to Integer
22:23:40 <svar0g> ah thank you
22:23:50 <dons> svar0g: try using Integer :)
22:23:55 <twb> idnar: are you going through the NM process at the moment, or only thinking about it?
22:24:00 <idnar> twb: in NM
22:24:09 <svar0g> success!
22:24:11 <svar0g> thank you
22:24:13 <idnar> twb: although I've been on a bit of a hiatus for a few months, need to get things rolling again
22:24:25 <twb> idnar: you could become a DM in the meantime, like me
22:24:43 <lispy> this discussion reminds me
22:24:48 <idnar> twb: I could; I am nearly finished with NM, though
22:25:10 <lispy> dons: you said something recently about fixing this dreadful situation with Debian and Haskell.  Do you recall what you said?  something about getting packages in
22:25:26 <lispy> dons: is it that we just need a clone of you pumping packages into debian or is the problem deeper?
22:25:32 <sleven> dmwit: did u see i posted the other parts
22:25:51 <thetallguy> lispy: do you know about deb.seereason.com?
22:26:12 <lispy> no, I'm looking now
22:26:17 <dmwit> sleven: Wow, your system is very bare-bones.  How did you install GHC?
22:26:31 <dons> thetallguy: yeah, we need to get packages from deb.seereason.com into the real system :)
22:26:33 <thetallguy> seereason.com is comprised of the haskell people who used to be at Linspire
22:26:59 <lispy> hmm
22:26:59 <thetallguy> dons: pushing packages up into Debian is always hard.
22:27:01 <sleven> it runs on vmware, what do you mean bare-bones? i just did apt-get install ghc or haskell
22:27:12 <thetallguy> I've offered the tools and packages several times
22:27:19 <lispy> thetallguy: that's cool, but what did you have in mind?
22:27:22 <thetallguy> lispy: there is a package there called cabal-debian
22:27:47 <lispy> supposing someone here became a debian dev and could upload packages
22:27:51 <lispy> Would that solve the problem?
22:27:52 <thetallguy> which comes pretty close most times in creating a debian directory from cabal info
22:27:57 <dmwit> sleven: I'm surprised because you don't even have the base packages, like parsec and network.
22:28:05 <thetallguy> lispy: one would presume so...
22:28:09 <idnar> lispy: there are several debian devs here already, to my knowledge
22:28:17 <thetallguy> lispy: but Debian is a complicated beast.
22:28:22 <lispy> okay, so why is debian so far behind?
22:28:26 <twb> thetallguy: complex, not complicated
22:28:27 <lispy> I mean, take GHC for example
22:28:28 <sleven> its ghc-6.8.2  i think
22:28:32 <dmwit> sleven: Try apt-get'ing some libghc6-*-dev packages; I'm not sure which ones.
22:28:34 <thetallguy> twb: both.
22:28:45 <dmwit> sleven: Let me take a look at which ones I have...
22:29:10 <sleven> how should i write?
22:29:24 <thetallguy> twb: 1     : consisting of parts intricately combined <a complicated recipe>          2     : difficult to analyze, understand, or explain
22:29:25 <sleven> E: Couldn't find package libghc
22:29:28 <lispy> thetallguy: my understanding, although I don't have hard facts, is that debian is still on 6.6.  Which brings about pain for the haskell community.  It holds us back because people talk about and work on backwards compatibility when they should work on new features and bug fixes
22:29:34 <thetallguy> twb: both those apply ;-)
22:29:41 <sleven> sudo apt-get install libghc
22:29:49 <thetallguy> no, I think sid is on 6.8
22:29:51 <thetallguy> .2
22:29:51 <idnar> sleven: what are you looking for?
22:30:05 <dmwit> sleven: apt-get install libghc6-*-dev would work, but it would install a lot of cruft, too.
22:30:06 <thetallguy> If you are looking for a recent ghc in testing though...
22:30:12 <lispy> thetallguy: is sid unstable or testing?
22:30:19 <thetallguy> ...you are right out of luck.
22:30:19 <idnar> lispy, thetallguy: the current stable release of debian has ghc 6.6
22:30:21 <sleven> E: Couldn't find package libghc-*-dev
22:30:23 <thetallguy> lispy: unstable
22:30:28 <idnar> lispy, thetallguy: the next release (lenny) will have 6.8.2
22:30:34 <lispy> thetallguy: I understand that debian stale is only usable by people that are silly
22:30:40 <lispy> thetallguy: but testing should be fine :)
22:30:46 <dmwit> sleven: Try apt-get install libghc6-network-dev libghc6-mtl-dev
22:30:49 <thetallguy> idnar: Debian's release cycle is unbearably slow.
22:30:55 <dmwit> sleven: I'm not sure which package Parsec is in.
22:31:02 <idnar> thetallguy: that's a matter of perspective :)
22:31:04 <thetallguy> We actually use Ubuntu
22:31:08 <idnar> thetallguy: I wouldn't mind if it were faster, though
22:31:17 <idnar> thetallguy: on the other hand, I find Ubuntu's release cycle disruptively fast
22:31:23 <lispy> thetallguy: did you use to work at linspire?
22:31:30 <twb> Debian Stable is used for mission critical servers.
22:31:33 <thetallguy> idnar: indeed.  but the point at which it seems fast is a place I never wish to be.
22:31:35 <edwardk> hrmm in linux does anyone know a way to get a copy of your symbol table so you can know  a cheesy approximate name like gdb gives for each area of memory?
22:31:37 <thetallguy> lispy: yes.
22:31:42 <twb> That is, servers that not crashing is more important than being up to date.
22:31:44 <lispy> thetallguy: cool
22:31:50 <thetallguy> lispy: here's the thing
22:31:54 <idnar> I run stable on my servers, and it's not really a problem
22:32:14 <thomashartman1> is there a better way to handle IO errors than something like this?
22:32:17 <thomashartman1> darcssetup u sampleprojname = Prelude.catch (darcssetup' u sampleprojname) (return . Left . ioe_description)
22:32:18 <idnar> there are some dependencies that I "manage" myself
22:32:22 <thetallguy> lispy: if you wish to invest the time, you can learn to use the autobuilder and build your own repository based off of whatever release you like
22:32:25 <edwardk> am i stuck going through scanning every entry in /proc/self/maps for its file name then opening each looking for an ELF header and reading the symbol table from there?
22:32:27 <idnar> and so I have newer versions of those installed than are in Debian
22:32:44 <idnar> but those are only the dependencies I'm actively involved in developing, so I'm comfortable to take on that maintenance burden
22:33:04 <idnar> on my desktop machines I run sid everywhere
22:33:08 <thetallguy> If you get the source for the autobuilder package and look in the Example/build, you will see a big configuration file.
22:33:15 <twb> dons: the Debian MIPS binary for darcs didn't work on uclibc MISP
22:33:18 <twb> *MIPS
22:33:21 <edwardk> i realize thats rather off topic but i figure there is a good supply of smart people in here that might know the answer
22:33:26 <thetallguy> You can have packages in darcs repos, tarballs, you can add patches...
22:33:30 <idnar> (actually, I have one server that's running lenny with an etch chroot, because the hardware is too new to boot etch on it)
22:33:43 <lispy> thetallguy: I guess this started because I'm brainstorming about how to prevent the needs of debian stable users from holding back real-world haskell projects
22:33:56 <idnar> dmwit: libghc6-parsec-dev
22:34:18 <sleven> it says i ahve newest verion of parsec-dev
22:34:19 <thetallguy> lispy: I gave up on that.  I suffered and yelled and pleaded and begged and schemed...
22:34:38 <thetallguy> we just build our own add-on repository and life is fine.
22:34:53 <sleven> im trying to build caba-install again
22:34:58 <sjanssen> lispy: one solution is to reduce the speed of GHC and library development
22:34:58 <lispy> thetallguy: meaning Debian' ?
22:35:03 <idnar> lispy: that's something that confuses me
22:35:07 <thetallguy> We are running servers off of Hardy with these packages.
22:35:24 <idnar> I'm not sure why so many people are building their own versions of stuff on Debian stable
22:35:26 <thetallguy> lispy: yes.  That is, we worked hard to be both stable and cutting edge.
22:35:28 <lispy> thetallguy: I'm sorry, Hardy doesn't mean anything in my brain, I'm too ignorant
22:35:31 <idnar> it seems to defeat the point of running a stable distribution :P
22:35:47 <twb> idnar: theoretically it's "stable except for <important package>"
22:35:47 <thetallguy> lispy: Ubuntu from last April.
22:35:55 <idnar> Hardy Heron is Ubuntu 8.04 (so April 2008)
22:36:03 <twb> idnar: I do that to cherry-pick from sid into lenny
22:36:08 <idnar> twb: yeah, I guess
22:36:25 <idnar> lispy: anyhow, I guess the only way to prevent that in general is to get Debian to release faster
22:36:25 <sjanssen> thetallguy: is this repository online somewhere?
22:36:27 <thetallguy> idnar: as twb says, people who run production servers like the fact that Debian stable is really, really stable.
22:36:35 * lispy always runs his debian machines with testing as the default but unstable in the apt-sources so he can pick and choose
22:36:42 <thetallguy> sjanssen:  Sigh.
22:36:51 <thetallguy> sjanssen: deb.seereason.com
22:36:58 <sleven> thanks dmwit, cabal-install installed now. i can trash the download i ahve on my desktop right?
22:37:05 <twb> lispy: echo >>/etc/apt/apt.conf 'APT::Default-Release "testing";' is your friend
22:37:15 <thetallguy> I feel like I've yammered about this for forever.
22:37:17 <lispy> twb: yeah, that's what I'm talking about
22:37:26 <thetallguy> src.seereason.com for darcs repos
22:37:29 <idnar> thetallguy: write a book!
22:37:31 <idnar> ;)
22:37:31 <sleven> how do i then run cabal-install?
22:37:34 <dmwit> sleven: Yes, that should be fine.
22:37:40 <sleven> i want to download GLUT
22:37:46 <dmwit> sleven: You should have a binary named "cabal" in ~/.cabal/bin.
22:37:53 <sleven> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GLUT
22:37:54 <lambdabot> Title: HackageDB: GLUT-2.1.1.2
22:37:56 <thetallguy> idnar: I wrote an experience report for ICFP, I figured that would be enough... ;-)
22:37:57 <dmwit> sleven: (bootstrap.sh should tell you this at the end)
22:38:12 <sleven> yes it did
22:38:17 <dmwit> sleven: If you put ~/.cabal/bin in your $PATH, you can just type "cabal install GLUT" and be done with it.
22:38:18 <sleven> i hve to cd there?
22:38:19 <lispy> thetallguy: thanks though for saying it all one more time
22:38:23 <thetallguy> we would be happy to see people use, improve, wrest completely from our grasp...
22:38:47 <lispy> thetallguy: you're in PDX right?
22:39:04 <thetallguy> lispy: no, SAN
22:39:13 <sleven> nice how do i add to my path permanently?
22:39:35 <thetallguy> lispy: La Jolla, actually
22:39:50 <lispy> thetallguy: I'll be honest, not sure where that is :)
22:39:52 * lispy loosp it up
22:39:57 <thetallguy> San Diego
22:40:06 <dmwit> sleven: Put it in your .profile, .bashrc, .zshrc, or whatever your particular shell uses.
22:40:18 <sjanssen> lispy: it seems like the solution to the Debian problem is to point users at http://deb.seereason.com/debian/dists/etch-seereason/
22:40:23 <lambdabot> Title: Index of /debian/dists/etch-seereason
22:40:25 <thetallguy> http://picasaweb.google.com/clifford.beshers/20081019_2258270700#5259120204982702402
22:40:27 <lambdabot> Title: Picasa Web Albums - Clifford Beshers - 2008-10-19_22..., http://tinyurl.com/6pbev6
22:40:33 <thetallguy> There, that ought to help
22:40:38 <sjanssen> and perhaps have that hosted at hackage, with somebody interested in maintaining it
22:41:06 <thetallguy> sjanssen: our etch repository may be funky
22:41:43 <thetallguy> sjanssen: we use the hardy-seereason one extensively, we think the sid-seereason is good, anything else has not been tested.
22:41:45 <lispy> sjanssen: hmm
22:42:08 <idnar> on the bright side, it looks like lenny will release way faster than etch did
22:42:38 <thetallguy> idnar: lenny is currently testing?
22:42:50 <idnar> thetallguy: yes
22:43:02 <thetallguy> idnar: what's the (vague) eta?
22:43:10 <idnar> thetallguy: well, it's currently frozen
22:43:23 <thetallguy> idnar: oh, cool.
22:43:30 * idnar checks the most recent release update
22:43:36 <thetallguy> by the way, we have 6.8.3 in ours
22:43:46 <idnar> it froze on 2008-Jul-27
22:43:59 <thetallguy> ghc 6.8.3, that is, with haddock 2.x
22:44:14 <lispy> very nice
22:44:26 <thetallguy> idnar: which means it will move glacially for another three months...
22:44:27 <lispy> When the Haskell Platform lands, I don't want to see debian left out
22:44:56 <idnar> thetallguy: I think all of the big changes are out of the way, so it's "just" a matter of fixing the remaining RC bugs
22:45:31 <thetallguy> idnar: Oh, sorry.  Six months.
22:46:12 <thetallguy> idnar: is the current DPL on top of things?
22:46:43 <idnar> thetallguy: depends on what you mean by "on top of things"
22:46:50 <thetallguy> idnar: heh.
22:46:52 <idnar> but heck, I don't even know who the current DPL is
22:47:04 <idnar> the DPL doesn't really have much to do with getting a release out the door, on this scale
22:47:39 <thetallguy> idnar: Debian nearly turned me into a despot.
22:48:12 <idnar> looks like there are 179 odd RC bugs left in lenny (assuming I'm looking at the right information)
22:48:48 <jekor> Is there information somewhere on how to write a readPrec function or otherwise make your type an instance of Read without deriving?
22:48:51 <thetallguy> on a pure haskell note, how is it that I've for years missed the fact that you can write:  [ x | Just x <- xs]
22:49:16 <idnar> thetallguy: isn't that just catMaybes?
22:49:28 <dmwit> jekor: The Int argument to readsPrec is a precedence argument.
22:49:33 <sjanssen> thetallguy: 'tis a rarely used feature
22:49:39 <dmwit> jekor: Take a look in the Report for more info.
22:49:43 <thetallguy> idnar: indeed, but much lovelier syntax
22:50:01 <jekor> Do I need to worry about that with readPrec? (Parsec?)
22:50:04 <idnar> in that particular case, I think I'd prefer "catMaybes xs" to the listcomp
22:50:07 <idnar> but in general, sure
22:50:08 <sjanssen> thetallguy: another neat trick is [x | p] -- returns [] or [x], if p is False or True
22:50:15 <thetallguy> sjanssen: so I must assume, though I can't figure why, because I'm quite taken with it.
22:50:21 <idnar> I've been using the list monad a whole bunch solving Project Euler problems
22:50:33 <sjanssen> @undo [ x | Just x <- xs]
22:50:33 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
22:50:41 <thetallguy> sjanssen: the list monad is weird beast
22:50:50 <idnar> @pl \xs -> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
22:50:50 <lambdabot> (line 1, column 36):
22:50:51 <lambdabot> unexpected "{"
22:50:51 <lambdabot> expecting variable, "(", operator or ")"
22:51:00 <idnar> aw
22:51:02 <sjanssen> > filterM (const [True, False]) "abc" -- strange indeed
22:51:03 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
22:51:21 <thetallguy> sjanssen: yes, I've seen that one.
22:51:43 <rwbarton> that version runs in constant memory right?
22:51:46 <thetallguy> sjanssen: can't say as I would ever use it in anger
22:51:50 <idnar> heh
22:52:09 <thetallguy> but the pattern match could be quite nice
22:52:16 <idnar> well, if there were a conditional or something
22:53:04 <idnar> [x * 5 | Just x <- xs, x <= 50] is probably nicer than (map (*5)) . (filter (<= 50)) $ catMaybes xs
22:54:04 <twb> 16:37 <thetallguy> sjanssen: deb.seereason.com
22:54:14 <twb> thetallguy: that doesn't have quickcheck2?
22:54:19 <twb> I can't see it there.
22:54:39 <dmwit> jekor: It sounds to me like you may be abusing Read.
22:54:40 <thetallguy> twb: no, haven't pushed that yet because we are still using qc1
22:54:51 <twb> I want it for Darcs :-(
22:54:55 <jekor> Possibly. Maybe it's just easier to write a parser.
22:54:57 <thetallguy> We're keeping things stable while we head for release.
22:54:57 <dmwit> jekor: Read/Show are really supposed to be for things you could potentially just drop straight into Haskell source.
22:55:11 <jekor> Ah. OK. That makes sense.
22:55:16 <thetallguy> twb: could easily be built
22:55:21 <dmwit> jekor: Anything else shouldn't use the names "read" and "show"; I recommend "parse" and "pprint" instead. =)
22:55:31 <twb> thetallguy: do you have long-term plans for migrating packages from seereason into Debian proper?
22:55:35 <thetallguy> run cabal-debian on the source tree
22:56:02 <thetallguy> twb: yes.  Keep yammering about them until someone adopts them.
22:56:38 <thetallguy> twb: Ian has just quit.  The core packages are a pain to manage because it is so hard to build them on all the arch's.
22:57:12 <thetallguy> twb: so there's a new maintainer and a couple of other interested parties, I think, but it's always slow going.
22:57:31 <thetallguy> twb: join the debian-haskell mailing list.  John G just moved it over to Debian proper.
22:57:44 <sleven> A number of features in the Perl 6 language now show similarities with Haskell, and Perl 6 has been embraced by the Haskell community as a potential scripting language
22:57:51 <twb> thetallguy: I'm the DM for Darcs, so I have tangential interest in keeping Haskell integration not-shit.
22:57:54 <sleven> http://en.wikipedia.org/wiki/Perl
22:57:59 <sleven> lol
22:58:06 <lambdabot> Title: Perl - Wikipedia, the free encyclopedia
22:58:10 <sleven> haskell can do it s scripting by itself no?
22:58:20 * twb jumps into gnus/gmane
22:58:30 <idnar> thetallguy: moved what, the mailing list?
22:58:44 <idnar> ah, yes
22:58:54 <idnar> cool
22:58:57 <araujo> sleven, that's true at some point .. though, if the community already embraced it as the 'scripting language' ... that isn't clear yet , hah
23:00:06 <thetallguy> twb: gotcha.  You should definitely join.  We're happy to help with stuff as long as it doesn't distract us from our main project.
23:00:32 <sjanssen> sleven: at least there is a "citation needed" comment :)
23:01:26 <adu> :t indexOf
23:01:27 <lambdabot> Not in scope: `indexOf'
23:01:30 <adu> :t index
23:01:31 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
23:01:45 <adu> :t elemIndex
23:01:46 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
23:01:49 <adu> thats the one
23:01:52 <idnar> :t (!)
23:01:53 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
23:02:02 <idnar> huh
23:02:20 <idnar> > index (1, 10) 5
23:02:21 <lambdabot>   4
23:02:26 <idnar> > index (4, 10) 5
23:02:28 <lambdabot>   1
23:02:30 <idnar> oh, I see
23:02:50 <idnar> > index ((0,0),(10,10)) (3,7)
23:02:51 <lambdabot>   40
23:03:20 <idnar> I guess that's an Ix method, silly me
23:04:18 <idnar> why is there an Ix instance for ()?
23:04:24 <dmwit> Why not?
23:04:44 <idnar> well, let me rephrase; what are the practical applications of that instance? :)
23:04:58 <dmwit> I doubt it gets much use.
23:05:10 <dmwit> But it's so easy to write that you might as well just do it for completeness. =)
23:06:33 <pjdelport> idnar: if you want to pass non-array values to generic array code, a ()-indexed array is the obvious lifter
23:08:57 <dmwit> Actually, they probably didn't even write that instance.  It probably falls right out of the code for deriving Ix.
23:09:05 <mmorrow> should i put this on hackage?  http://moonpatio.com/repos/c-io/      http://moonpatio.com/repos/c-io/docs
23:09:06 <lambdabot> Title: Index of /repos/c-io
23:09:44 <dmwit> I'm surprised there's no library doing that already!
23:09:50 <mmorrow> me too
23:09:59 <dmwit> ?hackage unix
23:09:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix
23:10:35 <dmwit> There's a System.Posix.Unistd, but it doesn't do that.
23:10:42 <mmorrow> err, yeah. this is slightly lighter weight though
23:10:57 <idnar> pjdelport: ah, I suppose that makes sense
23:11:08 <dmwit> mmorrow: right
23:11:20 <mmorrow> hmm, ok. i'll upload it.
23:11:22 <pjdelport> idnar: similar deal as the Identity monad
23:11:28 <pjdelport> etc.
23:11:32 <rwbarton> System.Posix.IO does it.
23:12:04 <dmwit> yeah
23:12:14 <dmwit> Just barely beat me to it. =)
23:12:18 <rwbarton> mmm, Ptr Word8 :)
23:12:28 <rwbarton> How about ByteString?   That could be useful
23:13:58 <lispy> well, what would be nice is if someone would make a library that uses arrays of characters instead of String = [Char]
23:16:44 <dmwit> lispy: Interesting!
23:16:52 * dmwit ponders
23:17:15 <lispy> I was thinking we could call it WordString
23:17:29 <dmwit> That implies that it uses Words.
23:17:49 <lispy> CharString?
23:17:53 <pjdelport> ByteArray?
23:17:54 <lispy> CharVector
23:17:56 <dmwit> CharArray ;-)
23:17:58 <lispy> CharMander?
23:18:05 <dmwit> pjdelport: This is emphatically not bytes.
23:18:13 <dmwit> lispy: I like CharMander. =)
23:18:25 <lispy> dmwit: hehe, I've been alluding to ByteString this whole time...
23:18:33 <lispy> I wasn't really serious :)
23:18:38 <dmwit> Oh.
23:18:50 <mmorrow> done
23:18:51 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c-io
23:18:51 <lambdabot> Title: HackageDB: c-io-0.1.0
23:18:52 <dmwit> I thought you wanted a mix of String's Unicode-ness and ByteString's efficiency.
23:19:02 <dmwit> lispy: ...which could be nice at times.
23:19:02 <mmorrow> darcs repo with html docs http://moonpatio.com/repos/c-io/
23:19:03 <lambdabot> Title: Index of /repos/c-io
23:19:16 <twb> I had an argument with a C programmer a while back; he felt that the term "String" meant "a byte vector".
23:19:24 <lispy> dmwit: yes, it would be nice.  We could have UTF-16 and UCS-4 versions of bytestring
23:19:47 <mmorrow> rwbarton: ah, just saw your suggestion. hmm, that could be useful
23:19:55 <rwbarton> Doesn't String mean "a vector of non-zero bytes"?
23:19:57 * rwbarton ducks
23:20:02 <lispy> how do I implement fmap in terms of a monad instance again?
23:20:05 * mmorrow loves mallocBytes ;)
23:20:15 <pjdelport> @src liftM
23:20:15 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:20:24 <twb> rwbarton: well, in Haskell the String datatype is a linked list of Unicode codepoints (which are emphatically NOT bytes)
23:20:26 <pjdelport> @pl . src liftM
23:20:26 <lambdabot> (line 1, column 1):
23:20:27 <lambdabot> unexpected "."
23:20:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:20:31 <pjdelport> @. pl src liftM
23:20:31 <lambdabot> (line 1, column 1):
23:20:31 <lambdabot> unexpected end of input
23:20:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:20:44 <mmorrow> , maxBound :: Char
23:20:48 <lispy> ?undo \f m1 -> do { x1 <- m1; return (f x1) }
23:20:48 <lambdabot> \ f m1 -> m1 >>= \ x1 -> return (f x1)
23:20:51 <lunabot>  '\1114111'
23:20:54 <twb> rwbarton: and in R6RS Strings are pretty much immutable atomic objects.
23:20:59 <dmwit> ?. pl . undo src liftM
23:20:59 <twb> ...I think.
23:20:59 <lambdabot> (line 1, column 3):
23:20:59 <lambdabot> unexpected "\n"
23:20:59 <lambdabot> expecting variable, "(", operator or end of input
23:21:17 <rwbarton> @. undo src liftM
23:21:17 <lambdabot> ()
23:21:20 <lispy> ?. pl undo \f m1 -> do { x1 <- m1; return (f x1) }
23:21:21 <lambdabot> fmap
23:21:24 <lispy> lol
23:21:30 <dmwit> rwbarton: O_o
23:21:52 <rwbarton> @undo liftM f m1 = do { x1 <- m1; return (f x1) }
23:21:52 <lambdabot> liftM f m1 = m1 >>= \ x1 -> return (f x1)
23:21:59 <rwbarton> curious...
23:22:03 <adu> @index getOpt
23:22:04 <lambdabot> Distribution.GetOpt, System.Console.GetOpt
23:23:09 <adu> @index exitWith
23:23:10 <lambdabot> System.Exit
23:23:40 <mmorrow> <rwbarton> System.Posix.IO does it.
23:24:05 <mmorrow> System.Posix.IO reeealy needs to be updated to use ByteString instead of Strings
23:24:58 <rwbarton> It would seem to be more useful.
23:24:58 <mmorrow> because until then, all String IO functions are useless (from a not-slow-program perspective)
23:25:14 <mmorrow> totally
23:25:16 <lispy> mmorrow: right, we do need to do something like that
23:25:54 <mmorrow> hmm, maybe i'll add a Ptr Word8 and a ByteString version of all the functions in System.IO.Posix to c-io's System.C.IO
23:25:58 <rwbarton> (Although I don't know exactly when you'd want to use the system read/write/etc.)
23:26:38 <mmorrow> when you're doing system programming :)
23:26:53 <mmorrow> (i couldn't help myself)
23:27:44 <lispy> one thing we could really use, is a ghc-lite, that is embeddable
23:27:51 <lispy> like how python is embeddable
23:27:54 <mmorrow> yes!!
23:28:03 <Korollary> who embeds python? (serious question)
23:28:09 <rwbarton> embeds in what?
23:28:13 <lispy> Korollary: we do at my day job
23:28:19 <lispy> Korollary: it makes for a decent extension language
23:28:32 <lispy> Korollary: but not because python rocks, but because the implemenation lends itself to that
23:28:45 <Korollary> I understand. I am not sure if that's common, tho.
23:28:50 <mmorrow> i've been trying to get a ghc built with -fhpc for a few days now, and keep getting build errors. i think i got it figured out though now how to build successfully
23:29:42 <mmorrow> so then with -fhpc, you can write a prog that uses the ghc-api, ghc -fhpc --make Main.hs, and then get pretty html graphs and highlighted code with what parts of ghc are actually being used
23:30:12 <mmorrow> so then maybe, the whole 20MB+ binary penalty for linking with ghc could be made smaller
23:30:14 <idnar> lispy: heh, looks like you have OpenBSD problems too :P
23:30:51 <idnar> Korollary, lispy: I think in general, it's recommended to embed your C code in Python, rather than than your Python code in C
23:31:49 <mmorrow> -fhpc awesomeness http://blog.unsafeperformio.com/?p=18
23:31:50 <lambdabot> Title: 13 Functional Thinking 36 » The Haskell Program Coverage Toolkit (part 1) 47
23:32:22 <lispy> idnar: I have OpenBSD problems?
23:32:46 <lispy> idnar: oh I see
23:38:26 <lispy> idnar: the thing is, with embedding interpreters, is that sometimes you have nice big application and you want to make it more flexible
23:38:38 <lispy> idnar: at work we do this the the shrinkwrap stuff we sell
23:38:48 <lispy> idnar: very handy to users
23:39:39 <lispy> idnar: they write a python script to pull some data out of the application, screw it up, reinsert it and then they have a reason to use their maintenance contract ;)
23:39:54 <lispy> it's brilliant ;)
23:43:21 <mmorrow> zomg.
23:43:23 <quicksilver> lispy: First law of consulting: Give customer enough rope to hang themselves. Put a keen price on rope-cutting gear.
23:43:24 <mmorrow> read it and weep
23:43:28 <mmorrow> i just got
23:43:29 <mmorrow> unsafecoerce.com
23:43:33 <mmorrow> ahahaha
23:43:35 <qwr> lua is meant for embedding iirc
23:43:45 <quicksilver> yeah, lua's pretty fun.
23:43:46 <mmorrow> and .org .net .info
23:43:59 <quicksilver> mainly for it's very light-weight interface with C
23:45:06 <quicksilver> (and also it's smallness)
23:48:11 <clop> hi, total haskell newbie -- how can i define a function?  using ghci/hugs i just get parse error after parse error when writing things like this:
23:48:22 <clop> foo x = x + 3
23:48:31 <mmorrow> let foo x = x + 3
23:49:13 <clop> ah thanks, that seems to work in ghci; hugs says unexpected end of input (maybe i need a semicolon or something)
23:49:17 <mmorrow> and if you want to get the `a' out of an (IO a), do (here IO String):
23:49:29 <mmorrow> a <- readFile "/etc/passwd"
23:49:37 <mmorrow> because if you did
23:49:44 <mmorrow> let a = readFile "/etc/passwd"
23:50:02 <mmorrow> then `a' isn't a String with the contents, but the action itself
23:50:07 <ski> clop : usually you define things in a source file, though
23:50:09 <mmorrow> b <- a
23:50:16 <mmorrow> b then is the String
23:50:39 <ski> (mmorrow : preemptive answering ?)
23:50:46 <mmorrow> heh
23:53:09 <clop> how might i read a file in?
23:54:00 <mmorrow> heh
23:54:12 <mmorrow> thecontents <- readFile "/etc/passwd"
23:54:49 <clop> er... sorry, i was unclear... how might i read a haskell file filled with definitions
23:54:53 <clop> and have them loaded
23:55:29 <ski> :load MyModule.hs
23:55:48 <clop> ah thanks
23:56:01 <ski> also see the `:?' command for help on commands like this
23:56:33 <mmorrow> ghci> writeFile "a.hs" ("f = " ++ show [0..9] ++ "\n")
23:56:40 <mmorrow> ghci> :l a.hs
23:56:45 <mmorrow> ghci> f
23:56:45 <mmorrow> [0,1,2,3,4,5,6,7,8,9]
23:56:46 <mmorrow> :)
23:57:07 <mmorrow> @type appendFile
23:57:08 <lambdabot> FilePath -> String -> IO ()
23:58:10 <mmorrow> @type [appendFile, writeFile, readFile]
23:58:11 <lambdabot>     Couldn't match expected type `String -> IO ()'
23:58:11 <lambdabot>            against inferred type `IO String'
23:58:11 <lambdabot>     Probable cause: `readFile' is applied to too many arguments
23:58:18 <mmorrow> wuh
23:58:33 <idnar> :t writeFile
23:58:34 <lambdabot> FilePath -> String -> IO ()
23:58:35 <idnar> :t appendFile
23:58:36 <lambdabot> FilePath -> String -> IO ()
23:58:37 <idnar> :t readFile
23:58:38 <lambdabot> FilePath -> IO String
23:58:41 <mmorrow> :t [appendFile, writeFile, readFile]
23:58:42 <lambdabot>     Couldn't match expected type `String -> IO ()'
23:58:42 <lambdabot>            against inferred type `IO String'
23:58:42 <lambdabot>     Probable cause: `readFile' is applied to too many arguments
23:58:46 <mmorrow> goo
23:58:52 <idnar> readFile is the odd one out
23:59:22 <mmorrow> ohhhhh
23:59:24 <mmorrow> hah
23:59:33 <mmorrow> @type (appendFile, writeFile, readFile)
23:59:34 <lambdabot> (FilePath -> String -> IO (), FilePath -> String -> IO (), FilePath -> IO String)
23:59:43 <idnar> oh, heh
