00:00:03 <dmwit> ?pl \go -> getLine >>= \l -> when (l /= ":q") (print "eval" >> go)
00:00:03 <mmorrow> dmwit: this little paste turned out 100x more interesting than i thought it would starting out
00:00:04 <lambdabot> (getLine >>=) . flip (when . (":q" /=)) . (print "eval" >>)
00:00:05 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=79#a79
00:00:20 <mmorrow> i think i just "got" something
00:00:26 <mmorrow> @nixon
00:00:26 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
00:00:55 <LeCamarade> @nixon
00:00:55 <lambdabot> Your boys will be home for Christmas.
00:01:08 <dmwit> mmorrow: That does not require a newtype.
00:01:43 <mmorrow> can you rewrite it to not have one? (i would be very interested in seeing this)
00:02:00 <dmwit> I think you can just drop the Fix and change it to runFix = fix.
00:02:02 <dmwit> Let's see.
00:02:14 <mmorrow> the types a and b though
00:02:16 <mmorrow> @fix
00:02:17 <lambdabot> Maybe you meant: bid faq ft id thx
00:02:20 <mmorrow> @type fix
00:02:22 <lambdabot> forall a. (a -> a) -> a
00:02:29 <mmorrow> that's the problem i ran into
00:02:31 <dmwit> :t fix :: ((a -> b) -> (a -> b)) -> (a -> b)
00:02:32 <lambdabot> forall a b. ((a -> b) -> a -> b) -> a -> b
00:02:40 <dmwit> ;-)
00:02:49 <mmorrow> i kept hitting infinite type errors
00:03:02 <Jedai> mmorrow: Yes, fix works perfectly for this case, consider :
00:03:25 <dmwit> ?index fix
00:03:25 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
00:03:36 <Jedai> > let fib = fix (\k n -> if n == 0 then 1 else n * k n) in fib 6
00:03:39 <lambdabot>   * Exception: stack overflow
00:03:56 <Jedai> > let fib = fix (\k n -> if n == 0 then 1 else n * k (n - 1)) in fib 6
00:03:58 <lambdabot>   720
00:04:02 <mmorrow> hmm
00:04:02 <dmwit> http://hpaste.org/10908 mmorrow
00:04:34 <Jedai> mmorrow: fix is very simple but cover all case of recursion
00:04:39 <mmorrow> ok. suppose i want to do something like (gimme a sec):
00:05:09 <dmwit> A newtype is only required for recursive *types*.
00:05:23 <Jedai> (and its definition is very nice thanks to lazyness)
00:05:45 <thoughtpolice> y ftw
00:05:57 <Olathe> Is there a way to be especially evil and replace (^) for one type ?
00:06:06 <Jedai> thoughtpolice: It's not exactly Y though
00:06:21 <rwbarton> Olathe: Yes, using RULES
00:06:32 <rwbarton> Olathe: although it depends on the optimizer
00:06:39 <Jedai> Olathe: It's in a typeclass so you can (if it doesn't already have an instance)
00:06:46 <dmwit> It is not in a type class.
00:06:57 <Jedai> @src (^)
00:06:57 <lambdabot> x ^ 0            =  1
00:06:57 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
00:06:57 <lambdabot>   where f _ 0 y = y
00:06:57 <lambdabot>         f x n y = g x n
00:06:57 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
00:06:59 <lambdabot>                       | otherwise = f x (n-1) (x*y)
00:07:01 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
00:07:14 <Olathe> Ahh, thanks, I'll try that.
00:07:37 <Jedai> dmwit: Ah no, but you can redefine (*) ;-)
00:07:42 <dmwit> yep
00:07:54 <dmwit> But you can't define (^) to be, say, xor that way.
00:08:01 <dmwit> (In case that's what Olathe wanted to do. =)
00:08:09 <Jedai> Right, you can't but that would be evil
00:08:19 <rwbarton> < Olathe> Is there a way to be especially evil
00:08:37 <Olathe> Oh.
00:08:44 <Olathe> I wanted to do (^) = Power
00:08:52 <dmwit> heh
00:08:55 <Olathe> But if it can't do it, that's OK.
00:09:03 <dmwit> eh, what?
00:09:08 <dmwit> (^) is *already* power.
00:09:12 <dmwit> > 5 ^ 3
00:09:13 <lambdabot>   125
00:09:15 <Olathe> Power is a constructor.
00:09:15 <Jedai> You probably can with RULES
00:09:20 <mmorrow> ok
00:09:22 <dmwit> aah
00:09:24 <rwbarton> RULES should be able to do it, but it can be finicky
00:09:33 <Jedai> dmwit: I think he is working on symbolic computation
00:09:35 <rwbarton> (says someone who's never tried it)
00:09:39 <Olathe> Jedai: Yes.
00:09:43 <mmorrow> can fix do something like this, where the type don't happen to be the same?
00:09:45 <mmorrow> http://hpaste.org/10908#a1
00:09:54 <mmorrow> s/type/types/
00:10:00 <Jedai> rwbarton: It wouldn't work at all with GHCi
00:10:04 <dmwit> mmorrow: yes
00:10:11 <mmorrow> excellent
00:10:19 <Olathe> I suppose I could make (*) smarter.
00:10:21 <dmwit> mmorrow: Anything you can do with the Fix newtype you showed earlier can be done with fix.
00:10:42 <dmwit> mmorrow: However, if you had newtype Fix a = Fix (a -> Fix a), *then* fix would not cover that case.
00:11:05 <mmorrow> ah. ok, i think i see the situation now.
00:11:13 <dmwit> mmorrow: i.e. fix doesn't make infinite types possible, just infinite *terms*.
00:11:15 <Olathe> Hmm...that would only work for enumerable powers anyway, I think.
00:11:38 <rwbarton> , eval $ map toLower $ "Fix (\\k i -> if i > 100 then show i else k (i * 3))" -- :)
00:11:39 <lunabot>  luna: parse error (possibly incorrect indentation)
00:11:50 <rwbarton> , eval $ map toLower $ "Fix (\\k i -> if i > 100 then show i else k (i * 3))"
00:12:03 <lunabot>  <<Integer -> [Char]>>
00:12:19 <dons> nice
00:12:28 <dmwit> > fix (\k i -> if i > 100 then show i else k (i * 3)) 2
00:12:30 <lambdabot>   "162"
00:12:37 <mmorrow> rwbarton: haha. nice.
00:12:39 <rwbarton> dons: I parallelized the fannkuch benchmark
00:12:47 <dmwit> rwbarton: eval? O_o
00:13:23 <mmorrow> dmwit: i'm trying to get straight mutual recursion/coroutining/related currently
00:13:36 <rwbarton> dmwit: ask mmorrow
00:13:40 <dmwit> Ah, mutual recursion is more fun.
00:14:04 <rwbarton> @pl let x = 1 : y ; y = 1 : x in x
00:14:05 <lambdabot> fst (fix (uncurry (flip ((,) . (1 :)) . (1 :))))
00:14:14 <dmwit> Actually, I take it back, it's not that much more interesting.
00:14:18 <sbahra> :t fix
00:14:20 <lambdabot> forall a. (a -> a) -> a
00:14:37 <Baughn> shapr: You should see the latest HWN for that. :P
00:14:44 <mmorrow> , (fromDynamic ((fromDynamic . fromDynamic) (eval "eval \"eval\"") :: Maybe (String -> Dynamic)) "42") :: Maybe Integer
00:14:46 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
00:14:46 <lunabot>         against inferred type `Data.Maybe.Maybe a'
00:15:03 <mmorrow> hehe, a little too ambitious there
00:15:27 <mmorrow> , (fromDynamic . fromDynamic) (eval "eval \"eval 42\"") :: Maybe Integer
00:15:28 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
00:15:28 <lunabot>         against inferred type `Data.Maybe.Maybe a'
00:15:33 <mmorrow> , (fromDynamic . fromDynamic) (eval "eval \"eval 42\"") :: Maybe Dynamic
00:15:34 <lunabot>  luna: Couldn't match expected type `Data.Dynamic.Dynamic'
00:15:34 <lunabot>         against inferred type `Data.Maybe.Maybe a'
00:15:43 <mmorrow> oh
00:16:07 <mmorrow> , let fromJust = maybe undefined id in (fromDynamic . fromJust . fromDynamic) (eval "eval \"eval 42\"") :: Maybe Dynamic
00:16:08 <dmwit> :t fix (\(odd, even) n -> if n == 0 then (False, True) else (even (n-1), odd (n-1)))
00:16:09 <lambdabot>     Couldn't match expected type `t1 -> t'
00:16:09 <lambdabot>            against inferred type `(a, b)'
00:16:09 <lambdabot>     In the pattern: (odd, even)
00:16:12 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Base.String)
00:16:12 <lunabot>    arising from the literal `42' at <interactive>:1:48-49
00:16:12 <lunabot>  Possible fix:
00:16:13 <dmwit> :t fix
00:16:14 <lambdabot> forall a. (a -> a) -> a
00:16:30 <mmorrow> , let fromJust = maybe undefined id in (fromDynamic . fromJust . fromDynamic) (eval "eval \"eval \\\"42\\\"\"") :: Maybe Dynamic
00:16:34 <lunabot>  Just <<Integer>>
00:16:37 <mmorrow> heh
00:16:49 <dons> rwbarton: woo!!
00:16:57 <dons> rwbarton: details! any speedup?
00:17:47 <rwbarton> dons: the serial program does all the permutations ending in n-1, then all the permutations ending in n-2, etc.
00:17:47 <dmwit> :t fix (\(odd, even) -> (\n -> if n == 0 then False else even (n-1), \n -> if n == 0 then True else odd (n-1)))
00:17:47 <LeCamarade> Wow. When did lunabot come? Obviously, I've been away for too long.
00:17:48 <lambdabot> forall a. (Num a) => (a -> Bool, a -> Bool)
00:17:53 <dmwit> There we go.
00:18:06 <rwbarton> dons: so I just do each chunk in parallel.
00:18:08 <Olathe> LeCamarade: A few weeks ago.
00:18:08 <glguy> ?bot
00:18:09 <lambdabot> :)
00:18:12 <glguy> > 1
00:18:13 <mmorrow> LeCamarade: within the last two weeks
00:18:14 <lambdabot>   1
00:18:21 <dmwit> > let (o, e) = fix (\(odd, even) -> (\n -> if n == 0 then False else even (n-1), \n -> if n == 0 then True else odd (n-1))) in (o 5, e 5)
00:18:23 <glguy> :t ()
00:18:25 <lambdabot> ()
00:18:33 <mmorrow> , src ''Maybe
00:18:36 <lambdabot>   thread killed
00:18:37 <lunabot>  data Maybe a = Nothing
00:18:37 <lunabot>               | Just a
00:18:50 <rwbarton> dons: the speedup should be roughly linear for 4 processors
00:18:51 <mmorrow> , src 'InfixE
00:18:54 <glguy> oh, commas trigger lunabot
00:18:56 <lunabot>  luna: Not in scope: type constructor or class `InfixE'
00:19:05 <mmorrow> glguy: oh, heh yeah
00:19:18 <mmorrow> , src '(:)
00:19:23 <lunabot>  luna: parse error on input `:'
00:19:29 <mmorrow> glguy: of ']'
00:19:33 <mmorrow> s/of/or/
00:19:49 <mmorrow> damn, i though i fixed that
00:20:19 <LeCamarade> Difference 'twixt lunabot and lambdabot?
00:20:22 <dons> rwbarton: awesome. where's the code?
00:20:43 <dons> rwbarton: i can test on a quad core for you :)
00:21:13 <rwbarton> dons: http://www.haskell.org/haskellwiki/Shootout/Parallel/Fannkuch as of just now
00:21:20 <lambdabot> Title: Shootout/Parallel/Fannkuch - HaskellWiki
00:21:28 <mmorrow> lunabot uses the ghc-api to directly compile code, and it can do template-haskell as well
00:21:33 <dmwit> a HA!
00:21:40 <dmwit> > let (o, e) = fix (\ ~(odd, even) -> (\n -> if n == 0 then False else even (n-1), \n -> if n == 0 then True else odd (n-1))) in (o 5, e 5)
00:21:41 <lambdabot>   (True,False)
00:22:00 <mmorrow> lunabot also has the /same/ eval function it's using at the /top/ level imported infinitely deep within itself..
00:22:04 <mmorrow> , eval "42"
00:22:06 <lunabot>  luna: /usr/local/ghc/ghc-6.10.0.20080927/lib/ghc-6.10.0.20080927/ghc-6.10...
00:22:06 <lunabot>  luna: luna: unable to load package `ghc-6.10.0.20080927'
00:22:09 <mmorrow> shit
00:22:12 <dons> rwbarton: ok. awesome. i'll try it out.
00:22:39 <mmorrow> , eval "42"
00:22:43 <lunabot>  <<Integer>>
00:22:54 <dmwit> , eval "eval \"42\""
00:22:59 <lunabot>  <<Dynamic>>
00:23:04 <dmwit> yum
00:23:29 <mmorrow> i had a translation of this lisp quine to TH, which then could be done with eval and dynamic. lemme find it
00:23:36 <dmwit> , eval (fix (\s -> concat ["eval \"", s, "\""]))
00:23:41 <lunabot>  luna: out of memory (requested 1048576 bytes)
00:23:44 <dons> rwbarton: what systems have you tried it on?
00:24:00 <rwbarton> dons: Just my 2-core laptop.  10.5 s -> 5.75 s
00:24:06 <dmwit> , fix (\s -> concat ["eval \"", s, "\""])
00:24:07 <dons> oh, and awesome, you parallelised the faster one.
00:24:08 <lunabot>  "eval \"eval \"eval \"eval \"eval \"eval \"eval \"eval \"eval \"eval \"ev...
00:24:15 <dons> ok. trying on quad core
00:24:24 <rwbarton> dons: yeah, it was a bit tricky to figure out what it was doing :)
00:24:25 <dmwit> Oh, that's not even right.
00:25:11 <dmwit> , fix (\s -> concat ["eval \"", show s, "\""])
00:25:13 <lunabot>  "eval \"\"eval \\\"\\\"eval \\\\\\\"\\\\\\\"eval \\\\\\\\\\\\\\\"\\\\\\\\...
00:25:24 <dons> well, its some experimental code i wrote while learning primop programming :)
00:25:43 <dmwit> , fix (\s -> "eval " ++ show s)
00:25:45 <lunabot>  "eval \"eval \\\"eval \\\\\\\"eval \\\\\\\\\\\\\\\"eval \\\\\\\\\\\\\\\\\...
00:25:53 <dmwit> hehehe
00:26:34 <dmwit> Oh, hey, there's a haskell.reddit.com!
00:26:47 <dons> rwbarton: awesome. perfect parallelisation.
00:26:52 <dons> rwbarton++ fannkuch king.
00:27:06 <dons> this is how you do it kids.
00:27:08 <dons> before: ./B 11  6.48s user 0.02s system 99% cpu 6.522 total
00:27:17 <dons> after : ./B 11 +RTS -N2  7.28s user 0.01s system 195% cpu 3.727 total
00:28:12 <dmwit> Now do -N4!
00:28:17 * dmwit waits with bated breath
00:28:33 <dmwit> come oooon 1.8 total
00:29:38 <dons> N1, 10.2. N2, 6.19, N3, 6.6, N4, 6.3, N5, 5.686,
00:29:44 <dons> (had to move to the quad core)
00:29:53 <dons> so... does well on two cores
00:30:01 <dons> but not much after that. work increases though.
00:30:07 <TSC> 3 and 4 are worse than 2
00:30:08 <dmwit> mm
00:30:13 <dons> 367% cpu 4.788 total
00:30:18 <dons> ah, could be load issues on the machine.
00:30:30 <dons> let me find a less busy machine.
00:30:31 <sbahra> hm
00:30:41 <sbahra> I can run it on a machine
00:30:52 <sbahra> if you give me the command you're using for compilation, dons
00:31:00 <dons> ghc -O2 --make -threaded B.hs
00:31:07 <sbahra> k
00:31:08 <dons> ./B +RTS -N5 -RTS 11
00:31:11 <dons> on quad core.
00:31:22 <sbahra> I'll paste results, sec
00:31:42 <rwbarton> On 4 cores it should theoretically run in about 30% of the time as on 1 core, I think, because the parallelism is not that finely grained
00:32:08 <dons> so we do have access to forkOnIO
00:32:14 <dons> which lets us nail a thread to a core.
00:32:30 <dons> 344%
00:32:55 <rwbarton> That seems about right
00:34:43 <dons> looks like the right parallelisation strategy
00:35:38 <rwbarton> I could do the same thing with the last two values.  Then there would be 90 tasks instead of 10, and probably not too much extra overhead
00:35:48 * dons tries forkOnIO
00:36:12 <dons> 'bout the same.
00:36:33 <dons> well, i think this is worth submitting though. then we need to think about the scaling.
00:38:27 <dons> all the fannkuch stuff could run in ST now.
00:38:41 <sbahra> real	0m6.204s, real	0m4.184s, real	0m3.258s, real	0m2.203s, real	0m2.154s, real	0m2.256s, real	0m2.223s, real	0m1.959s
00:38:54 <sbahra> 2.6.18-92.1.10.el5 #1 SMP Tue Aug 5 07:42:41 EDT 2008 x86_64 x86_64 x86_64 GNU/Linux
00:38:58 <sbahra> 2xQuad Core
00:39:10 <sbahra> Quad-Core AMD Opteron(tm) Processor 2354
00:39:16 <dons> what flags? what do each set of numbers represent?
00:39:23 <sbahra> -N1 ... -N8
00:39:28 <dons> ah ha.
00:39:32 <sbahra> Same flags as you provided.
00:39:33 <dons> looking good.
00:39:49 <dons> so similar trail off.
00:39:50 <dons> 'sok.
00:40:07 <dons> rwbarton: i'll submit it as-is.
00:40:28 <rwbarton> dons: You can try http://hpaste.org/10910 too
00:41:23 <dons> ok
00:42:36 <dons> rwbarton: oh, that looks better.
00:43:16 <rwbarton> dons: oh, cool.
00:43:49 <dons> 1: 9.655s,  2: 8.353,  3: 5.323, 4: 4.285, 5: 4.025
00:44:08 <dons> sbahra: want to try http://hpaste.org/10910 ? needs the chunk of below-the-line code from the last one.
00:47:58 <ivanm> is there an implementation of "find" in haskell? I know there's wc, grep, etc....
00:50:44 <solrize_> hey dons, i have an idea for quickcheck, which is to hook it into the profiler so one can write properties like "this function runs in constant space" or "this function runs in n log n time".  quickcheck would profile the function on args of a few different sizes and make sure the growth pattern looked like what was claimed.
00:51:53 <dons> rwbarton: submitted.
00:52:01 <dons> solrize_: yeah, that'd be awesome.
00:52:14 <dons> we've done a few extensions (like 'this function is lazy in 'x')
00:52:29 <dons> which look for runtime issues. so you'd need to look at the ticks in the profiler
00:52:29 <solrize_> oh cool
00:53:12 <solrize_> hmm
00:55:22 <solrize_> does it sound feasible?  i don't understand the profiler enough to see how to implement such a thing, i mainly wanted to toss the idea out there and ask if it made sense
00:56:56 <dons> well, it would need the new hooks that hpc provides
00:56:58 <dons> for accessing ticks
00:57:07 <dons> so it's approaching feasibiliyt
00:58:27 <solrize_> neat, i think it would be pretty handy
00:59:06 <dons>  ->(f){f.(3)}.(->(x){x+2})
00:59:12 <dons> new ruby syntax for    1.
00:59:13 <dons>       (λ f. f 3) (λ x. x + 2)
00:59:18 <dons> curious.
01:00:39 <dons> hmm. can't i use lambda as actual lambda now?
01:00:51 <dons> not -XUnicodeSyntax ?
01:00:59 <ivanm> @src partition
01:00:59 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
01:00:59 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
01:00:59 <lambdabot>                               | otherwise = (ts, x:fs)
01:01:03 <ivanm> what does the ~ mean here?
01:01:27 <Gilly> are there any total functional languages that could be used for serious application development?
01:02:08 <dmwit> ivanm: It's a lazy pattern match.
01:02:17 <dmwit> ivanm: i.e. the match always succeeds.
01:02:27 <ivanm> oh?
01:02:29 <dmwit> It's not as obvious why this might be important when the pattern is a tuple.
01:02:36 <ivanm> yeah :s
01:02:40 <dmwit> But if I write it this way, it makes more sense:
01:02:46 <dmwit> data Tuple a b = Tuple a b
01:02:58 <dmwit> ... where select p x ~(Tuple a b) | ...
01:03:27 <dmwit> So, the important part is that we *don't have to find out that the constructor is Tuple* before moving on to the function body.
01:04:03 <ivanm> dmwit: why is that relevant here though?
01:04:29 <dmwit> For infinite lists.
01:04:30 <int-e> ivanm: try calling partition on an infinite list without the ~
01:04:32 <ivanm> since we know that there's only one constructor for Tuple, and static typing ensures we used the right type
01:04:42 <ivanm> int-e: oh, it tries to evaluate the list?
01:04:58 <dmwit> Basically, yes.  Trace through what it would have to do.
01:04:59 <rwbarton> dons: Looks like it's only ::, =>, forall, ->, <-, ..
01:05:32 <dons> yup
01:05:33 <int-e> ivanm: the pattern match in  select p x (ts,fs)  would make select strict in its 3rd argument, but we want it to be lazy.
01:05:37 <dons> due to lower case lambda
01:05:49 <ivanm> *nod*
01:05:50 <dons> > (\ f → f 3) (\ x → x + 2)
01:05:51 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 13}
01:05:51 <lambdabot> ...
01:05:54 <dons> boo
01:06:04 <dmwit> , (\ f → f 3) (\ x → x + 2)
01:06:06 <lunabot>  5
01:06:15 <dmwit> \o/
01:06:54 <int-e> ivanm: equivalently to using ~, you could write select p x res | p x       = (x:fst res, snd res) | otherwise = (fst res, x:snd red)
01:07:05 <dons> go lunabot
01:07:12 <ivanm> int-e: *nod*
01:07:30 <ivanm> dmwit: how did you type those chars?
01:07:38 <dmwit> I copied dons.
01:08:12 <ivanm> heh
01:08:20 <ivanm> dons: in that case, how did _you_ type those chars?
01:08:34 <int-e> they're \lambda \rightarrow with scim and latex table. λ → :)
01:09:03 <dmwit> scim = StarCraft input method?
01:09:20 <int-e> "Smart Common Input Method"
01:09:47 <dmwit> People should be shot for putting "smart" in the name of any software.
01:10:55 <dmwit> ...gently, of course
01:11:08 <ivanm> dmwit: well, I worked on an assignment generator called "SmartAss"...
01:11:18 <ivanm> the guy in charge thought he was funny ;-)
01:11:20 <int-e> dmwit: in slow motion?
01:11:21 <musiKk> smart windows!
01:11:35 <dmwit> heehee
01:11:36 <ivanm> then again, seeing as how he's my supervisor, I suppose I can't badmouth him too much ... >_>
01:11:54 <dmwit> I can generate assignments!
01:11:57 <dmwit> x := 3
01:12:01 <dmwit> y := x + 2
01:12:09 * dmwit is a SmartAss
01:12:29 <ttt--> hi, is it possible to have a list like [1,"hi"] of type Show a => [a] ?
01:12:48 <Olathe> ttt--: Not directly.
01:12:50 <dmwit> Yes, but not with that type.
01:12:58 <dmwit> And you need to enable some extensions.
01:13:02 <Olathe> ttt--: You have to use dynamic type or something.
01:13:07 <dmwit> [Show a => a]
01:13:07 <ttt--> what would the type be?
01:13:11 <int-e> ttt--: not without a wrapper type (like data Showable where Showable :: Show a => a -> Showable a)
01:13:21 <dmwit> Or maybe [forall a. Show a => a], I'm not sure.
01:13:29 <ivanm> how can I convert say "Data.Graph.Inductive" into ("Data.Graph","Inductive") ?
01:13:30 <int-e> dmwit: no, that's a different type
01:13:41 <dons> ivanm: copy'n'paste from ghc/Lexer.x
01:13:44 <Olathe> You could always just show everything and have a list of strings.
01:13:45 <dons> rwbarton: ok, how about nbody then...
01:13:47 <ivanm> dons: oh?
01:13:58 <dmwit> int-e: Surely that last 'a' in your Showable type shouldn't be there.
01:14:01 <Olathe> ["1", "\"hi\""]
01:14:09 <int-e> dmwit: right.
01:14:36 <int-e> :t [shows 1, shows "hi"]
01:14:37 <dmwit> ttt--: But Olathe is right.  For the specific case of Show, the only thing you can do with such a list is show the elements anyway, so just use a [String] instead.
01:14:37 <lambdabot> [String -> String]
01:15:08 <int-e> :t [\p -> showsPrec p 1, \p -> showsPrec p "hi"]
01:15:09 <lambdabot> [Int -> String -> String]
01:15:10 <dons> rwbarton: no one's parallelised it yet, http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=all
01:15:10 <ivanm> dons: any idea what the function would be called?
01:15:13 <lambdabot> Title: n-body benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language Benc ..., http://tinyurl.com/46wmj6
01:15:16 <ttt--> Is there an example of this somewhere that i can take a look at?
01:15:29 <Olathe> @pl \f (a, b) -> (f a, f b)
01:15:29 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
01:15:35 <Olathe> @pl \(a, b) f -> (f a, f b)
01:15:36 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
01:15:54 <dmwit> Olathe: f &&& f
01:16:11 <dmwit> :t join (&&&)
01:16:13 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
01:16:20 <Olathe> > join (&&&) reverse ("test", "omg")
01:16:21 <lambdabot>   Couldn't match expected type `[a]'
01:16:34 <dmwit> oops
01:16:39 <elliottt> ttt--: http://haskell.org/haskellwiki/Existential_type
01:16:41 <dmwit> > join (***) reverse ("test", "omg")
01:16:41 <lambdabot> Title: Existential type - HaskellWiki
01:16:42 <lambdabot>   ("tset","gmo")
01:16:57 <elliottt> ttt--: i think that there's an example that matches your question on there :)
01:17:01 <dmwit> Olathe: Sorry, I always get (&&&) and (***) mixed up.
01:17:29 <dmwit> Olathe: However, note this:
01:17:39 <dmwit> > (reverse *** reverse) ("test", [1..5])
01:17:40 <lambdabot>   ("tset",[5,4,3,2,1])
01:17:48 <dmwit> > join (***) reverse ("test", [1..5])
01:17:49 <lambdabot>       No instance for (Num Char)
01:17:49 <lambdabot>        arising from the literal `1' at <inte...
01:18:45 <ttt--> thanks
01:18:46 <int-e> :t showList
01:18:48 <lambdabot> forall a. (Show a) => [a] -> String -> String
01:19:07 <ivanm> dons: any idea whaat "FastString" in lexer.x is meant to be?
01:19:38 <Olathe> > let separate x = (first reverse.f "".reverse) x where f rs "" = ("", rs); f rs ('.':xs) = (xs, rs); f rs (x:xs) = f (x:rs) xs in separate "omg.omg.hi"
01:19:40 <lambdabot>   ("omg.omg","hi")
01:19:43 <Olathe> > let separate x = (first reverse.f "".reverse) x where f rs "" = ("", rs); f rs ('.':xs) = (xs, rs); f rs (x:xs) = f (x:rs) xs in separate "hi"
01:19:44 <lambdabot>   ("","hi")
01:20:46 <Olathe> > let separate x = (f "".reverse) x where f rs "" = ("", rs); f rs ('.':xs) = (reverse xs, rs); f rs (x:xs) = f (x:rs) xs in separate "omg.omg.hi"
01:20:47 <lambdabot>   ("omg.omg","hi")
01:20:50 <Olathe> Even better.
01:21:35 <dmwit> > let separate = (init . reverse *** reverse) . break (=='.') . reverse in separate "a.b.c"
01:21:37 <lambdabot>   ("","a.b.")
01:21:50 <dmwit> > let separate = (reverse *** init . reverse) . break (=='.') . reverse in separate "a.b.c"
01:21:52 <lambdabot>   ("c","a.b")
01:22:20 <dmwit> > let separate = (first &&& second) . (reverse *** init . reverse) . break (=='.') . reverse in separate "a.b.c"
01:22:21 <lambdabot>       No instance for (Arrow (,))
01:22:21 <lambdabot>        arising from a use of `second' at <i...
01:22:37 <dmwit> > let separate = (fst &&& snd) . (reverse *** init . reverse) . break (=='.') . reverse in separate "a.b.c"
01:22:39 <lambdabot>   ("c","a.b")
01:22:46 <dmwit> duh
01:22:52 <dmwit> > let separate = (snd &&& fst) . (reverse *** init . reverse) . break (=='.') . reverse in separate "a.b.c"
01:22:54 <lambdabot>   ("a.b","c")
01:23:11 <int-e> dmwit: use  reverse . tail  instead of  init . reverse, please ;)
01:23:22 <dmwit> oh, definitely
01:23:39 <dmwit> > let separate = (snd &&& fst) . (reverse *** reverse . drop 1) . break (=='.') . reverse in separate "a.b.c"
01:23:40 <lambdabot>   ("a.b","c")
01:25:15 <int-e> > let separate = (snd &&& fst) . (reverse *** reverse . drop 1) . break (=='.') . reverse in separate "abcdef"
01:25:16 <lambdabot>   ("","abcdef")
01:25:40 <dmwit> Good thing I snuck that (drop 1) in there at the last second. ;-)
01:25:53 <Olathe> > (snd &&& fst) (x, y)
01:25:54 <lambdabot>   (y,x)
01:26:46 <sbahra> :t (***)
01:26:47 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:27:02 <sbahra> :t (&&&)
01:27:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:27:07 <dmwit> > (length "(snd &&& fst)", length "uncurry (flip (,))")
01:27:09 <lambdabot>   (13,18)
01:27:11 <sbahra> @src (***)
01:27:11 <lambdabot> f *** g = first f >>> second g
01:27:12 <Olathe> @unpl (&&&)
01:27:12 <lambdabot> (&&&)
01:27:24 <sbahra> @src (>>>)
01:27:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:27:27 <sbahra> hker
01:27:37 <dmwit> sbahra: It's a class function.
01:27:41 <dmwit> ?src (>>>) (->)
01:27:42 <lambdabot> Source not found. Sorry.
01:27:46 <dmwit> ?src (->) (>>>)
01:27:46 <lambdabot> f >>> g = g . f
01:27:55 <Olathe> @src Maybe (>>>)
01:27:55 <lambdabot> Source not found. There are some things that I just don't know.
01:28:02 <Olathe> @type (>>>)
01:28:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
01:28:09 <dmwit> ?src Kleisli (>>>)
01:28:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:28:09 <Olathe> @instances Arrow
01:28:10 <lambdabot> (->), Kleisli m
01:28:20 <dmwit> ?src (Kleisli Maybe) (>>>)
01:28:20 <lambdabot> Source not found. Where did you learn to type?
01:28:26 <dmwit> I didn't really expect that to work. =P
01:28:28 <Olathe> @src Kleisli Maybe (>>>)
01:28:28 <lambdabot> Source not found. I feel much better now.
01:28:34 <Olathe> @src (Kleisli Maybe) (>>>)
01:28:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
01:28:54 <dmwit> ?src (Kleisli m) (>>>)
01:28:54 <lambdabot> Source not found. Maybe you made a typo?
01:29:27 <dmwit> Anyway, (>>>) is basically a funky form of (>>=)
01:29:30 <Jedai> Olathe: Maybe you could do that in a private discussion with lambdabot ?
01:29:38 <dmwit> (for Kleisli-lifted monads).
01:29:54 <dmwit> :t (>=>)
01:29:56 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:30:04 <dmwit> Yeah, that one.
01:31:29 <EvilTerran> "src Kleisli (>>>)" = (>=>)
01:32:24 <sbahra> You people and your formalisms.
01:38:55 <musiKk> i have a beginner question: what is the difference between "(f . g) x" and "f $ g x"?
01:40:17 <dons> well, one uses function composition,
01:40:19 <int-e> musiKk: none, besides the precedence of the involved infix operators
01:40:19 <dons> ?src (.)
01:40:19 <lambdabot> (f . g) x = f (g x)
01:40:24 <dons> and the other uses application, ($)
01:40:26 <dons> ?src ($)
01:40:27 <lambdabot> f $ x = f x
01:40:56 <dons> so, f $ g x --> f (g x), and, (f . g) x --> f (g x)
01:41:02 <int-e> you'll even find  f . g $ x
01:41:10 <musiKk> so using one or the other is merely a matter of taste?
01:41:13 <dons> yep
01:41:25 <dons> there's no side effects :)
01:41:30 <dons> so just pick the style you like.
01:41:35 <musiKk> i see, thank you :)
01:54:42 <glark> how do i make lambdabot remember a quote?
01:55:10 <TSC> It's "@remember nick <quote>", I think
01:55:41 <Olathe> @quote lambdabot
01:55:41 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
02:03:30 <int-e> @. elite quote
02:03:31 <lambdabot> Gphunk SAyS: [7|-|E /\/\Ain aD\/an+A93 0F FUn(TiOn41 proGr4/\/\z0rz 4r3 T|-|4T theY'RE] inc0rr3(t tHE fiRz7 1000 7IM3s joo TRY 7o (o/\/\pI13 IT!
02:05:48 <Olathe> @type 1.1.1
02:05:49 <lambdabot> forall b c a. (Num (a -> b), Fractional (b -> c)) => a -> c
02:09:55 <Beelsebob> @quote Beelsebob
02:09:55 <lambdabot> beelsebob says: <lambdabot> Parse error <beelsebob> where bitch?
02:10:12 <ivanm> is there any way of telling if a FilePath is a directory?
02:10:25 <Beelsebob> directoryExists
02:11:07 <mjrosenb> morning all
02:11:38 <mjrosenb> i'm trying to get ghc on my powermac g5.  any suggestions?
02:12:30 <Baughn> ivanm: That can be a bit tricky. Why do you need to know, exactly?
02:12:39 * Baughn is worried about race conditions
02:12:40 <Beelsebob> mjrosenb: sudo port install ghc
02:13:50 <mjrosenb> Beelsebob: erruh right
02:13:56 <mjrosenb> i'm running linux on this
02:14:29 <Beelsebob> sudo <insert package manager> install ghc
02:14:31 <Beelsebob> then
02:14:53 <Baughn> mjrosenb: Well, obviously there isn't a binary package for ppc. Hmm..
02:14:54 <mjrosenb> Beelsebob: no distro has packages for ghc on a ppc64
02:14:55 <ivanm> Baughn: so I can start searching for files from that point
02:15:09 <mjrosenb> Baughn: worse, it's ppc64
02:15:09 <ivanm> atm, I'm using "null . takeFileName . normalise", which seems to work
02:15:15 <ivanm> is there a better way?
02:15:26 <Baughn> ivanm: Nah, it'll do. No way to make it atomic, of course
02:15:30 * Beelsebob was about to say that's okay OS X can run 32 bit binaries in a 64 bit install >.<
02:15:34 <ivanm> Baughn: atomic?
02:15:40 <Baughn> ivanm: Just keep in mind that, whatever conclusions you draw, they may be wrong by the time you try to use them
02:15:46 <Baughn> ivanm: That goes for all filesystem operations
02:15:54 <ivanm> heh
02:15:55 <Baughn> It's really rather annoying - no transactions
02:16:15 <Baughn> Beelsebob: Yeah, that works. Annoyingly, it can't run 64-bit binaries on a 64-bit install.
02:16:19 <mjrosenb> Beelsebob: so this box has 16G of ram (or at least it will) i'd like ghc to be able to use them all if negessary
02:16:27 <Baughn> Or rather, lots of the system libraries haven't been ported to 64-bitness yet
02:16:28 <Beelsebob> Baughn: uh? sure it can?
02:16:33 <ivanm> run program; freeze filesystem; do stuff with filesystem; unfreeze filesystem; end program ;-)
02:16:41 <ivanm> Baughn: ^^ that what you mean? :p
02:16:57 <Beelsebob> Baughn: all of the system libraries have been ported to 64 bit, other than a deprecated GUI library
02:17:01 <Beelsebob> (Carbon)
02:17:04 <Baughn> ivanm: Transactions are usually a bit more fine-grained than that, but that'd work. :P
02:17:18 <ivanm> heh
02:17:18 <Baughn> ivanm: It's the fabled database filesystem of dreams
02:17:32 <ivanm> WinFS? :o
02:17:40 <Baughn> Reiser4, more like. :P
02:17:57 <Baughn> Beelsebob: A few functions are missing. I don't quite recall which, but it was something relating to stopping the screensaver from activating
02:18:25 <Baughn> Beelsebob: I spent some time trying to port mplayer recently. No go, but that's mostly because of the assembly - Apple doesn't support non-PIC addressing in 64-bit mode
02:18:30 <Beelsebob> Baughn: yeh, the screensaver engine is currently written in carbon
02:18:55 <Baughn> Beelsebob: Yeah. See, you can't have a movie player that can't stop the screensaver.
02:19:09 <Beelsebob> oh, you do that with an apple event
02:19:18 <Beelsebob> no need to actually link against the screen saver engine in your app
02:19:20 <Baughn> Oh? How?
02:20:09 <Beelsebob> well, the dumb way to do it is to occasionally simulate a mouse shuggle event
02:20:21 <Baughn> ..not gonna happen.
02:20:28 <Beelsebob> I'm sure there's an apple event to send to system prefs to tell it to stop screensaving
02:20:33 <Baughn> ...
02:20:45 <Beelsebob> mostly because VLC has a 64 bit build that does so
02:20:45 <Baughn> Carbon has a perfectly fine "Stop the screensaver timer for now" call.
02:21:32 <Beelsebob> ah
02:21:44 <Beelsebob> register with the default notification center
02:21:45 <Baughn> mjrosenb: Oh, and by a cursory examination, ghc *used* to work on ppc64/linux at one point
02:22:00 <Beelsebob> and when you recieve com.apple.screensaver.willstart return NO
02:22:10 <Baughn> mjrosenb: Still, you may need to port it. Should be easy, since both the OS and architecture are already supported.
02:22:23 <Baughn> Ah
02:23:23 <ivanm> Baughn: looks like that way of telling if a FilePath is a directory isn't good enough... because functions like getDirectoryContents remove the trailing "/" :s
02:24:11 <Beelsebob> @hoogle directoryExists
02:24:11 <lambdabot> No results found
02:24:15 <Beelsebob> o.O
02:24:39 <Beelsebob> I'm sure I've used that before
02:25:01 <Baughn> ivanm: System.Directory.doesDirectoryExists?
02:25:08 <ivanm> yeah, just found that ;-)
02:25:10 <ivanm> thanks Baughn
02:25:19 * ivanm doesn't know why he missed that one before
02:25:28 <ivanm> *sigh* if only it wasn't in IO
02:25:44 <Baughn> That one actually checks the fs, the other one appears to just check the filename for trailing /
02:25:47 <Baughn> That's /why/ it's in IO
02:25:54 <ivanm> yeah, I know
02:26:09 <Beelsebob> ah, that's what it was called
02:26:14 <Baughn> Of course, you can use unsafePerformIO if you can be sure it won't change in the lifetime of the program (you can't), but you'd be better off learning to deal with IO. :P
02:26:57 <Beelsebob> tbh, I see no reason why using unsafePerformIO is any less safe here
02:26:58 <ivanm> yeah, I know
02:27:17 <ivanm> hmmmm.... how can I use that function in a filter?
02:27:22 <Baughn> filterM?
02:27:28 <Beelsebob> or unsafePerformIO
02:27:31 <ivanm> @hoogle filterM
02:27:31 <Baughn> Or some such
02:27:31 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
02:27:39 <ivanm> oh? it _does_ exist! :o
02:27:42 <Baughn> @src filterM
02:27:43 <lambdabot> Source not found. You type like i drive.
02:27:54 <ivanm> @hoogle partitionM <-- what I really wanted
02:27:55 <lambdabot> Warning: Unknown type <--
02:27:55 <lambdabot> No results found
02:27:59 <ivanm> @hoogle partitionM -- what I really wanted
02:28:00 <lambdabot> Parse error:
02:28:00 <lambdabot>   --count=20 "partitionM -- what I really wanted"
02:28:00 <lambdabot>                         ^
02:28:00 <Baughn> ..right. Well, filterM = mapM . filter, or thereabouts
02:28:03 <ivanm> dugh
02:28:04 <ivanm> *duh
02:28:08 <Baughn> It's not like you'd have trouble implementing it. :P
02:28:09 <ivanm> @hoogle partitionM
02:28:09 <lambdabot> No results found
02:28:15 <ivanm> grrrr.....
02:30:16 <ivanm> Baughn: you sure that's right? the source doesn't use that...
02:30:24 <ivanm> @type mapM . filter
02:30:26 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
02:30:36 <ivanm> @type \ f -> mapM . filter f
02:30:37 <lambdabot>     Couldn't match expected type `a -> m b'
02:30:37 <lambdabot>            against inferred type `[a1]'
02:30:37 <lambdabot>     Probable cause: `filter' is applied to too many arguments
02:33:33 <mjrosenb> Baughn: yeah, but i've had compilation errors with every version of ghc that i try to bootstrap
02:33:53 <Baughn> ivanm: Nope, it probably isn't
02:34:05 <Baughn> ivanm: But hey, it's pretty close
02:34:09 <ivanm> heh
02:34:36 <ivanm> I'm trying to convert partition to a monadic form.... except that partition uses foldr, and there isn't a foldr on monads! :s
02:35:02 <Baughn> ..liftM?
02:35:29 <ivanm> @type liftM partition
02:35:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> ([a], [a]))
02:36:03 <ivanm> Baughn: no, I want to use that doesDirectoryExists function as the predicate
02:36:17 <ivanm> @type liftM
02:36:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:36:23 <ivanm> ^^ doesn't really match
02:38:39 <Baughn> ivanm: Have some imagination. ;_;
02:38:51 <ivanm> heh
02:38:53 <ivanm> I think I've got it...
02:39:52 <ivanm> whatever happened to the hpaste bot, anyway?
02:40:25 <ivanm> Baughn: does this look right to you? http://hpaste.org/10911
02:42:11 <Baughn> @type partition
02:42:13 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
02:42:29 <TSC> @hoogle partition
02:42:29 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
02:42:29 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
02:42:29 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
02:42:36 <Baughn> ivanm: Yes, but I'm pretty sure you could do without the redefinition. If I wasn't so tired..
02:42:48 <ivanm> heh
02:45:08 <Baughn> "do dirs <- doesDirectoryExist <$> dirList; return $ partition id dira
02:45:17 <Baughn> *partition id dirs
02:46:56 <Baughn> ivanm: How about that?
02:47:34 <ivanm> ummm.... what's dirList?
02:47:51 <ivanm> and what's <$>
02:47:53 <ivanm> ?
02:47:57 <Beelsebob> <$> is applicative apply
02:48:10 <Beelsebob> and presumably dirList is all the paths you want to test
02:48:12 <Baughn> dirList is the list of possible directories you wanted to check for existence
02:48:14 <ivanm> where is it from?
02:48:16 <Beelsebob> @type <$>
02:48:17 <lambdabot> parse error on input `<$>'
02:48:22 <Beelsebob> @type (<$>)
02:48:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:48:25 <Baughn> Control.Applicative
02:48:26 <Beelsebob> ivanm: Control.Applicative
02:48:31 <ivanm> Baughn: no, I'm trying to recursively find all files from a base directory
02:48:44 <Baughn> @hoogle walk
02:48:45 <lambdabot> No results found
02:49:04 <Baughn> Hmmph. Well, you could use that line in place of partitionM, at least
02:50:08 <ivanm> Baughn: how does "partition id dirs" give me directories and files?
02:50:34 <Baughn> ivanm: Oh, it doesn't. Did I mention I'm tired? Let's see..
02:50:39 <ivanm> heh
02:51:31 <Baughn> "do dirs <- doesDirectoryExist <$> dirList; return $ partition fst (zip dirs dirList)"
02:51:47 <ivanm> gah!
02:51:49 <Baughn> Actually, that's still wrong
02:52:16 <Baughn> "do dirs <- mapM doesDirectoryExist dirList; return $ partition fst (zip dirs dirList)"
02:52:20 <Baughn> There.
02:53:39 * ivanm thinks he'll stick with his partitionM function
02:53:42 <ivanm> thanks anyway though
02:53:54 <ivanm> @type liftM
02:53:55 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
02:54:13 <Baughn> ..but mine's simpler. ;_;
02:54:16 <ivanm> heh
02:54:27 <ivanm> @hoogle (Monad m) => (a -> m b) -> m a -> m b
02:54:40 <ivanm> duh, that's >>=, isn't it
02:54:40 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:54:42 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:54:44 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:55:41 <Baughn> ivanm: No. :P
02:56:02 <ivanm> or =<<, whatever
02:56:14 <Baughn> Still no, though
02:58:37 <ivanm> oh? why not?
02:59:11 <Baughn> Well, the types are different
02:59:35 <Baughn> =<< . return, perhaps
03:00:07 <ivanm> ummmm.... what I hoogled for is the type of =<< ...
03:02:28 <Baughn> ivanm: Right, ignore me. Going to sleep now.
03:02:34 <ivanm> heh
03:09:30 <_zenon_> @type (>>=)
03:09:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:09:42 <_zenon_> m a -> (a -> m b) - > m b
03:22:01 <ivanm> hmmmm.... doesn't System.Directory understand ~/ notation for home directories?
03:22:43 <r3m0t> isn't there an environment variable for that?
03:22:51 <ivanm> $HOME?
03:23:07 <ivanm> I meant in terms of the FilePath that it's passed
03:23:15 <besiria> :t getHomeDirectory
03:23:16 <lambdabot> Not in scope: `getHomeDirectory'
03:23:32 <ivanm> besiria: yeah, I know that exists
03:23:47 <ivanm> but I'm talking about doing something like: getDirectoryContents "~/"
03:24:15 <besiria> ivanm: it doesn't work last time i tried
03:24:28 <ivanm> yeah, doesn't work here either
03:24:29 <ivanm> oh well
03:24:30 <r3m0t> getHomeDirectory >>= getDirectoryContents
03:25:21 <ivanm> r3m0t: yes, but that doesn't work if I'm using ghci to debug something and I try a path like "~/foo/" ;-)
03:27:26 <kig> ~ is shell magic
03:27:35 <besiria> i think this decision has been made because windows doesn't have the ~
03:27:41 <besiria> maybe i'm wrong
03:27:53 <ivanm> nah, IIRC kig is right
03:28:22 <ivanm> because I've had issues in xfce when I tried to use ~/bin/foo.sh for a keyboard shortcut instead of /home/ivan/bin/foo.sh
03:28:28 <pstickne> bash substitutes ~ with $HOME, thankfully, so do many open dialogs in *ix
03:28:54 <pstickne> but it's not consistent--and not part of the low-level IO API
03:29:19 <pstickne> (and it makes me grumpy when it's not implemented)
03:30:47 <kig> you could do the equivalent of replace (regex "^~([^/]+)?") (\match -> getHomeDir (maybe (currentUser) id (match !! 1))) my_path, but that sounds like a bit of work :)
04:19:24 <_zenon_> netsplit?
04:19:33 <Beelsebob> no
04:26:35 <jpcooper> could anyone propose a way to select from a set of MVars of different types?
04:26:47 <jpcooper> I guess that it isn't really possible
04:26:52 <Beelsebob> what type would the resulting thing have?
04:27:08 <jpcooper> well, it would depend on which was first available
04:27:56 <jpcooper> I think that I could just create a type which would encompass all the different types which I would want to put into these mvars
04:28:31 <Beelsebob> in that case, create the type, and store values of *that* type in the MVars
04:28:37 <jpcooper> yes
04:29:11 <jpcooper> it just seems bad to me that I should have to create another type and then constructors with the names of the types which I will be held
04:30:01 <jpcooper> is there no better way to do this?
04:31:29 <Beelsebob> think about your design a bit
04:31:34 <Beelsebob> but other than that, probably no
04:32:37 <jpcooper> Beelsebob, this is actually my first foray into concurrency, so I don't really know how to go about things. All I know is that I have commands of different types which I would like a listener thread to receive, and work on its data accordingly
04:33:38 <Beelsebob> that sounds actually like it would be rather nice to do as data Command = LaunchMissiles Coords | FireLasers Person | ...
04:33:44 <Beelsebob> and pattern match on the commands
04:34:18 <jpcooper> what I have is actually that, and also a Result type
04:34:29 <jpcooper> and I have written according Read and Show instances
04:34:42 <jpcooper> I would rather not have commands and results in the same type
04:35:02 <Beelsebob> but don't commands go one way, and results the other?
04:35:23 <int-e> jpcooper: so your problem is with the result type?
04:35:28 * int-e wonders
04:36:07 <jpcooper> but this thread needs to know about results from other places before it can give results to a command which it has received
04:36:48 <jpcooper> I guess I'll think about the design a bit more though
04:49:36 * Baughn wonders when he started reading #haskell to relax
04:50:05 <plutonas> could someone please help me understand this type error: http://pastebin.ca/1219801
04:50:10 <plutonas> what exactly causes th
04:50:14 <plutonas> the problem*
04:50:22 <vixey> do you eat monad transformers for breakfast too?
04:51:20 <Baughn> vixey: Not yet
04:51:22 <vixey> plutonas: you basically put []'s around something but shouldn't have
04:52:03 <Baughn> plutonas: What type does attachHeads return?
04:52:26 <plutonas> [(String,String)]
04:54:57 <int-e> jpcooper: one idea is to pass fresh MVars for the replies along with requests. I.e. to call another thread, do reply <- newEmptyMVar; putMVar server (Command, reply); result <- takeMVar reply
04:56:04 <jpcooper> thanks
05:01:34 <papermachine> Is there a version of Data.ByteString that will build on 6.6?
05:02:52 <matthew-_> be careful when passing mvars around in general than you force evaluation before putMVar'ing. Otherwise it'll just put the whole thunk into the mvar and the wrong thread will end up doing the work
05:02:52 <Baughn> Perhaps the very old ones in darcs. We're about to hit 6.10, you know..
05:03:19 <jpcooper> int-e, there will be one thread which tracks all requests (selects and inserts). The result that the programme gives depends on the results it receives, though. So somehow I have to send both results and commands to this thing
05:04:13 <papermachine> Baughn, Debian insists on carrying 6.6 in stable for some reason. I guess I could look at what's in unstable, but that's such a pain.
05:04:35 <Baughn> papermachine: That's debian. You might want to look at arch, or else compile your own.
05:04:55 <Baughn> papermachine: Alternately, you can stay stuck on 6.6 for the next two years at least
05:05:02 <papermachine> :)
05:05:55 <matthew-_> speaking of distributions, is anyone using nixos?
05:07:01 <Baughn> Hum. Now that looks intriguing.
05:07:08 <Baughn> Not yet, will be soon. ;)
05:07:19 <matthew-_> I keep wanting to use it
05:07:32 <matthew-_> but have lacked the energy to set up kvm/qemu with it
05:12:37 <kaol> Baughn: now, now. Lenny may still get released this year and then people will happily be stuck with 6.8 for two years. ;-)
05:13:51 <besiria> is 6.10 coming soon?
05:13:55 <Baughn> kaol: You don't think there's a chance they'll get 6.10.1 in it?
05:15:00 <matthew-_> is it not frozen already?
05:15:01 <kaol> none. it's in deep freeze now.
05:16:41 <papermachine> Arch looks sufficiently interesting to try out.
05:17:05 <kaol> and "they" being me in this case, since I'm the ghc6 package maintainer
05:17:21 <besiria> i think Arch's installation is very straight-forward
05:18:13 <matthew-_> I do get confused by this "let's try out a new distribution" stuff. I spend about a week configuring a machine properly. Where do you all get your time from to set up other distributions correctly?!
05:18:33 <Baughn> matthew-_: I keep most of my configuration in $HOME
05:18:59 <Baughn> A /week/?
05:19:17 <Baughn> Unless you are counting user settings and such there, that's way too much just to configure hardware drivers
05:19:35 <matthew-_> yeah, ish. on and off. And it's mainly software
05:20:13 <matthew-_> but, eg, things like I have 3 soundcards, two of which are USB. Making sure they always appear in the same order is annoyingly tricky
05:20:47 <Baughn> Right. I think maybe we just have simpler hardware setups.
05:21:13 <matthew-_> ok, how about installing custom fonts? That is a major pita, esp with LaTeX integration too
05:21:31 <int-e> When I tried out 'nix' (NixOS's package manager) it reparsed all its package descriptions each time I ran it, which was unbearably slow. If there's any caching, I didn't find the right knob to activate it.
05:22:15 <matthew-_> int-e: mmm, that seems a strange mistake given their focus on memoisation of every expression in their functional language
05:22:40 <Baughn> Memoizing *everything*?
05:23:01 <Baughn> Right..
05:23:04 <matthew-_> yeah, I think so. It's in their recent ICFP paper. I've not read it, I must admit, but I was told that's what they did
05:23:21 <Baughn> GCing memoizations, then?
05:23:33 <matthew-_> *shrug* maybe
05:23:39 <matthew-_> LRU cache
05:23:44 <matthew-_> that could  work
05:24:00 <int-e> matthew-_: mind you that was a few (2?) months ago
05:27:06 <matthew-_> mind you, cabal list is slow due to reparsing the ghc lists of installed packages
05:27:11 <matthew-_> endless read instances
05:31:06 <matthew-_> is ghc-6.9.20080918-src.tar.bz2 really the latest source snapshot to build - in the ...->6.10 branch?
05:31:43 <thoughtpolice> tarballs on darcs.haskell.org?
05:32:00 <thoughtpolice> i'm not sure exactly how frequently they're updated - i stay up to date with darcs
05:33:48 <matthew-_> so the switch to git hasn't complicated matters wrt getting ghc source yet?
05:34:24 <matthew-_> and are you darcs-get'ing http://darcs.haskell.org/ghc
05:34:27 <lambdabot> Title: Index of /ghc
05:34:38 <matthew-_> or http://darcs.haskell.org/ghc-6.10 ?
05:34:39 <lambdabot> Title: Index of /ghc-6.10
05:38:24 <thoughtpolice> matthew-_: http://darcs.haskell.org/ghc is the HEAD branch so it's actually at 6.11 now
05:38:24 <lambdabot> Title: Index of /ghc
05:39:02 <thoughtpolice> otoh, ghc-6.10/ is naturally the 6.10 branch.
05:39:33 <thoughtpolice> matthew-_: also the switch to git is happening sometime soon i think, last I heard it was scheduled for after the branch which was a few weeks ago now...
05:40:10 <matthew-_> ok, and I'm really not knowledgeable of darcs: what is the difference between --partial and --lazy?
05:40:38 <thoughtpolice> matthew-_: if you want the HEAD, do not use --partial :/
05:40:54 <matthew-_> nah, I want 6.10
05:40:56 <thoughtpolice> actually you can if you just want the HEAD and e.g. you're not interested in any patches
05:41:13 <thoughtpolice> because applying/merging stuff from --partial repos is messy
05:41:24 <thoughtpolice> matthew-_: there's the 6.10 candidate
05:41:32 <matthew-_> yeah, I read that on the build guide. I'm not planning on hacking. I'm more interested in working out how much of my stuff has broken
05:42:05 <matthew-_> there's a 6.10 rc tarball?
05:42:20 <thoughtpolice> @go ghc 6.10 beta
05:42:23 <lambdabot> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-September/015539.html
05:42:23 <lambdabot> Title: ANNOUNCE: GHC 6.10.1 beta
05:42:41 <matthew-_> cheers
05:42:51 <thoughtpolice> yeah i've been messing around with it
05:43:17 <thoughtpolice> but uh, if you use cabal install, cabal install <pkg> --with-ghc=... --with-ghc-pkg=... no workee for me
05:43:30 <matthew-_> great
05:43:37 <thoughtpolice> yeah seriously
05:43:44 <thoughtpolice> i've been meaning to bug dcoutts about that
05:43:51 * matthew-_ abandons the darcs get of 6.10 seeing as it wanted to pull 19k patches
05:44:03 <thoughtpolice> yeah, will take a while
05:44:40 <matthew-_> I'll stick with the tarballs for the moment
05:44:45 <thoughtpolice> yeah probably a good idea
05:44:52 <thoughtpolice> 6.10.1 shouldn't be too far away now anyway
05:44:56 <matthew-_> cool
05:45:02 <thoughtpolice> hopefully this bytestring thing will get resolved and probably some other stuff
05:45:15 <thoughtpolice> cvs-ghc seems kinda slow recently
05:45:20 <matthew-_> so, I can do a perf build of 6.8.3 in 22 mins. Can I break that record with 6.10rc?
05:45:38 <thoughtpolice> not sure
05:45:42 <Igloo> If you want to get the 6.10 branch then you're best off starting with http://darcs.haskell.org/ghc-STABLE-2008-09-19-ghc-corelibs-testsuite.tar.bz2
05:45:44 <lambdabot> http://tinyurl.com/4n2rv2
05:47:16 <matthew-_> Igloo: which is two days _older_ than the snapshots in the email thoughtpolice linked to above?!
05:47:36 <sebaseba> @users
05:47:37 <lambdabot> Maximum users seen in #haskell: 516, currently: 511 (99.0%), active: 11 (2.2%)
05:48:11 <Igloo> matthew-_: Yes, but you can ./darcs-all pull once you have it
05:48:40 <matthew-_> Igloo: ahh, ok, thank you
05:49:12 <matthew-_> did the patches such that ghc --make can use > 1 core go in yet?
05:51:28 <Igloo> That's not even being worked on AFAIK. Simon M did have some patches a while ago, but they didn't work well
05:52:09 * matthew-_ expects great things of make -j 5
05:54:48 <matthew-_> I'm clearly being horrendously naive. How is it particularly difficult? Does GHC really maintain that much shared state across compiling different modules?
05:56:48 <Igloo> GHC does a lot of naughty things  :-)
05:57:19 <matthew-_> are you suggesting that it's not the pure, referentially transparent compiler that we all took it for? ;)
05:58:00 <plutonas> i want to have a non functional function, that goes through a list of strings and prints them one by one, what function do i need to use to do this?
05:58:27 <xerox> ?t mapM_ putStrLn
05:58:28 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:58:40 <hackage> Uploaded to hackage: unicode-prelude 0.1
05:58:40 <hackage> Uploaded to hackage: utf8-prelude 0.1.1
05:58:40 <hackage> Uploaded to hackage: utf8-prelude 0.1
06:03:05 <plutonas> thanks
06:07:45 <YurY_9> http://www.pennergame.de/change_please/7714722/
06:07:51 <lambdabot> Title: Pennergame
06:09:24 <EvilTerran> away with thee, spammer!
06:11:51 <vixey> hmf
06:13:32 <kohwj> this is weird... runhaskell and a ghc-compiled program are behaving differently
06:14:32 <kohwj> runhaskell executes printStr and getLine in order, but not ghc
06:14:35 <kohwj> http://hpaste.org/10915
06:15:17 <papermachine> kohwj, it's I/O buffering, I think.
06:15:19 <Heffalump> they have different default buffering behaviours
06:15:21 <EvilTerran> kohwj, that'll be the IO buffering
06:15:28 <kohwj> ah
06:15:57 <Botje> ObUpgradeFromStereo: your IO is buffered differently
06:16:04 <papermachine> There's no flush in prelude, is there
06:16:19 <int-e> kohwj: so either set  hSetBuffering stdout NoBuffering, or do  hFlush stdout  before reading.
06:16:30 <int-e> papermachine: not in the prelude, but in System.IO
06:16:34 <papermachine> Right.
06:17:05 <opqdonut> what should i cite when referring to haskell?
06:17:06 <opqdonut> the report?
06:17:25 <Heffalump> the revised report, yes
06:17:38 <kohwj> thank you so much everyone
06:22:38 <matthew-_> err, what's MagicHash? http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html has few details on it, and http://haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html#options-language has even fewer
06:22:40 <lambdabot> Title: 5.17.�Flag reference, http://tinyurl.com/yod3gf
06:23:26 <Saizan> matthew-_: it's the language extension to use # in identifiers, iirc
06:23:47 <matthew-_> ahh, so you can indicate unboxed types?
06:23:59 <Saizan> yeah
06:24:44 <EvilTerran> or other internals-related stuff
06:24:57 <ivanm> has anyone ever experienced the problem with ghci where it refuses to load a file because it apparently can't find it, even though it's there?
06:25:46 <ivanm> this is using the emacs haskell-mode ... if I load it manually, it works
06:25:55 <ivanm> but trying to use C-c C-l, I get:
06:26:11 <ivanm> :load "../../../../University/2008/Honours/code/SourceGraph/Analyse/Software.hs"
06:26:12 <ivanm> <no location info>:
06:26:12 <ivanm>     can't find file: ../../../../University/2008/Honours/code/SourceGraph/Analyse/Software.hs
06:26:12 <ivanm> Failed, modules loaded: none.
06:26:12 <ivanm> Prelude> :! pwd
06:26:12 <ivanm> /home/ivan/University/2008/Honours/code/SourceGraph
06:26:42 <mauke> ivanm: University/Universty/ probably doesn't exist
06:26:42 <vixey> lol
06:27:03 <ivanm> mauke: ummm.... yes, but why is it looking in University.University?
06:27:11 <mauke> no idea
06:27:25 <ivanm> I had this problem a couple of hours ago, but killing it and restarting fixed it :s
06:27:46 <matthew-_> emacs: the new windows
06:27:50 <ivanm> I do have a symlink for University/2008 -> Uni, but I've never had this problem before
06:27:50 <mauke> you could try :cd ..
06:27:51 <ivanm> matthew-_: heh
06:27:55 <ivanm> mauke: no dice :(
06:29:52 <ivanm> OK, for some reason creating a new file worked :s
06:30:12 <_ar> ivanm: you have four ../ the first goes to code, then to Honours, then 2008 then the current dir is University you then go /University
06:30:26 <ivanm> _ar: yes, but _why_ is it doing that?
06:30:29 <_ar> unless i'm miscounting
06:30:34 <vixey> anything new going on ?
06:30:38 <vixey> what's new?
06:30:47 <_ar> because you need one more ../ ?
06:30:51 <_ar> are you picking the path?
06:30:55 <ivanm> _ar: nope
06:31:06 <ivanm> ghci/haskell-mode is
06:31:12 <_ar> ahh sorry, i misunderstood
06:31:42 <ivanm> heh
06:31:46 <ivanm> anyway, it's working now
06:33:50 * vixey bored
06:34:09 <vixey> hi
06:35:58 * matthew-_ loves the fact that in his freshly compiled ghc 6.10, Ctl-D does not send eof
06:36:12 <matthew-_> nor does backspace work
06:36:31 <vixey> editline.. progress!
06:37:07 <matthew-_> yeah
06:37:21 <ivanm> what's a word that I can use to describe either a program or a library ( in the code sense)... codebase?
06:37:33 <vixey> any new papers about fp out?
06:37:33 <mauke> project?
06:37:33 <matthew-_> though remind me how that is progress, rather than a silly amount of work to get round a licensing issue?
06:37:35 <ivanm> as in "Visualisation of the whole _____ "
06:37:42 <vixey> or old ones I didn't read
06:38:11 <dblazakis> vixey: what are you interested in?
06:38:47 <adekoba> wait, ctrl-d and backspace were removed from ghci because of licensing issues? Really?
06:39:09 <mauke> yes, they were patented by rms
06:39:14 <vixey> dblazakis, just bored..
06:39:30 <adekoba> that sneaky little man
06:39:41 <matthew-_> adekoba: I believe that the switch from libreadline (GPL only) to libeditline (BSD) was motivated by the desire to keep GHC under BSD
06:40:07 <matthew-_> strictly, statically linked versions of GHC prior to 6.10 were violating the GPL license
06:40:26 <matthew-_> but I might be wrong on that. I believe that's the case, but I'm not certain.
06:40:27 <adekoba> ah. Any chance of getting support for those things upstream?
06:40:48 <matthew-_> oh, my problem was that I didn't have libeditline installed. So I'm recompiling.
06:41:03 <matthew-_> and then I expect everything will work again
06:41:14 <adekoba> oh, nevermind then
06:45:28 <vixey> > let f 0 = 0 ; f n = f (f (n-1)) in map f [1..]
06:45:30 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:46:56 <vixey> yawn
06:47:23 <int-e> > let f 0 = 0 ; f n = 1 + f (f (n-2)) in map f [1..]
06:47:25 <lambdabot>   [* Exception: stack overflow
06:47:55 <RayNbow> f (-1) = undefined
06:48:27 <int-e> > let f 0 = 1 ; f 1 = 2; f n = 1 + f (f (n-2)) in map f [1..]
06:48:43 <lambdabot>   thread killed
06:49:01 <matthew-_> that still hits -1
06:49:06 <int-e> nope
06:49:11 <int-e> > let f 0 = 1 ; f 1 = 2; f n = 1 + f (f (n-2)) in map f [1..10]
06:49:14 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
06:49:39 <matthew-_> oops, sorry. I'm blind, dumb and possibly deaf
06:59:32 <matthew-_> ooo. ghc 6.10 rc is two mins faster at compiling ghc 6.10 than 6.8.3 at compiling 6.8.3 (perf builds, make -j4, quad core intel)
06:59:50 <Heffalump> what are the absolute times?
07:00:47 <matthew-_> 20:41 versus 22:something
07:01:41 * matthew-_ curses that it didn't seem to find libeditline and ghci is again unusable
07:04:21 <matthew-_> checking whether ghc has editline package... no
07:04:25 <Igloo> matthew-_: Is that with or without extralibs?
07:05:40 <matthew-_> Igloo: it's from the tarball you linked to, and then ./darcs-all --extra get and  ./darcs-all pull -a
07:06:17 <Igloo> OK, I think 6.10 has fewer extralibs, which will be one reason that it's faster
07:06:24 <matthew-_> mmm, and running the 6.10 rc on my tests eats up > 4GB memory
07:07:36 <matthew-_> where as 6.8.3 manages with about 0.5GB
07:09:15 <matthew-_> that's pretty terrifying actually
07:09:16 <Heffalump> that sounds bad
07:09:43 <Igloo> What do you mean by "my tests"?
07:09:50 <matthew-_> wget and unpack http://hackage.haskell.org/packages/archive/sessions/2008.7.18/sessions-2008.7.18.tar.gz. Then ghci Tests/Tests.hs
07:09:56 <lambdabot> http://tinyurl.com/3g9e69
07:10:05 <Igloo> Can you file a ticket please?
07:10:10 <matthew-_> yup
07:10:17 <Igloo> thanks
07:11:57 <dblazakis> @users
07:11:57 <lambdabot> Maximum users seen in #haskell: 516, currently: 515 (99.8%), active: 11 (2.1%)
07:12:23 <ivanm> with the Cabal library, is there an inbuilt function/module that parses an entire .cabal file?
07:12:33 <ivanm> I presume there woudl be, but I'm having trouble finding it :s
07:16:39 <int-e> ivanm: http://www.haskell.org/ghc/dist/current/docs/libraries/Cabal/Distribution-PackageDescription-Parse.html ... parsePackageDescription?
07:16:41 <lambdabot> Title: Distribution.PackageDescription.Parse, http://tinyurl.com/4pw67f
07:17:47 <ivanm> int-e: hmmm... that module doesn't appear on cabal's hackage page...
07:18:39 <ivanm> maybe they've changed it for 1.4.* ?
07:19:15 <ivanm> ahh, they've shifted it just to Distribution.PackageDescription
07:19:19 <ivanm> thanks int-e++ !
07:21:07 <Saizan> which version of Cabal are you looking at? it's Distribution.PackageDescription.Parse in 1.5
07:21:43 <matthew-_> Igloo: Ticket #2658
07:21:44 <int-e> ivanm: well, they've shifted it from Distribution.PackageDescription to a separate module
07:21:49 <int-e> Saizan: 1.4 vs. 1.5
07:22:05 <ivanm> ahhh....
07:22:16 * ivanm uses 1.4 for now
07:24:12 <Saizan> oh, i didn't realize there were both current and latest ghc docs
07:30:52 <ivanm> with exeModules, does that return _all_ modules or just those that become executables?
07:48:03 <maltem> Have the Haskell' people, at some point in time, considered syntactically nested modules? Or even some advanced module system stuff? (The Haskell' wiki lists only rather conservative module system extensions)
07:50:52 <Twey> I think the idea is that module = file
07:51:20 <Twey> So nested modules are rather out (except the directory modules, which are supported by GHC)
07:51:20 <Heffalump> that's not defined by the standard
07:58:21 <maltem> hmm
08:04:19 <dancor> @pl \ (x1, y1) (x2, y2) -> (x1 + x2, y1 ++ y2)
08:04:19 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (++)) . flip . (((.) . (,)) .) . (+))
08:04:28 <dancor> :t (+) &&& (++)
08:04:29 <lambdabot> forall a. (Num [a]) => [a] -> ([a] -> [a], [a] -> [a])
08:05:19 <vixey> @pl \(&)($) (x,y)(u,v) -> (x&u,y$v)
08:05:20 <lambdabot> (line 1, column 3):
08:05:20 <lambdabot> unexpected "&"
08:05:20 <lambdabot> expecting pattern
08:06:47 <vixey> @pl \(pl)(sucks) (x,y)(u,v) -> (pl x u,sucks y v)
08:06:50 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
08:07:02 <Axman6> ha
08:07:20 <skorpan> makes perfect sense
08:07:31 <Axman6> eah i can follow that
08:08:27 <Axman6> that's pretty impressive in the input/output ratio
08:08:33 <skorpan> :)
08:08:36 <Axman6> english me speak well
08:08:54 <dancor> this feels like (***) but isn't
08:09:40 <dancor> it's like `on` fst and `on` snd at the same time
08:10:22 <ivanm> how does one print out an error message (i.e. a StdErr version of putStrLn) ?
08:10:24 <dancor> maybe i'll call it on2
08:10:33 <vixey> I don't like that name
08:10:40 <vixey> @src on
08:10:41 <lambdabot> (*) `on` f = \x y -> f x * f y
08:10:41 <int-e> @pl \(pl)(sucks)u v -> uncurry (***) ((pl *** sucks) u) v
08:10:42 <lambdabot> ((uncurry (***) .) .) . (***)
08:10:55 <Igloo> ivanm: hPutStrLn stderr
08:11:04 <ivanm> *nod*
08:11:05 <int-e> @type ((uncurry (***) .) .) . (***)
08:11:07 <lambdabot> forall (a :: * -> * -> *) b c b' c' b1 b'1. (Arrow a) => (b1 -> a b c) -> (b'1 -> a b' c') -> (b1, b'1) -> a (b, b') (c, c')
08:12:27 <Igloo> matthew-_: Do you know why this is so hard to typecheck?
08:12:59 <matthew-_> Igloo: err, well I'm doing reasonably insane type level hackery
08:13:12 <Igloo> matthew-_: In which module?
08:13:19 <matthew-_> and there are mixed fundeps and type families and associated data types in there
08:13:31 <matthew-_> Igloo: oh, throughout the system really
08:13:37 <Igloo> OK
08:13:53 <matthew-_> but just loading Control.Concurrent.Session is fine in both 6.10 and 6.8.3
08:14:10 * Heffalump has observed GHC being very slow to typecheck that kind of code too, though I don't have code that works in 6.8.3 so can't report it as a regression.
08:14:15 <matthew-_> it's only when it's doing the type checking of the test programs that it goes nuts
08:14:48 <Heffalump> my laptop doesn't have 4GB of RAM for it to use, though :-)
08:15:18 <matthew-_> Heffalump: one of the main reasons I replaced my system a few months ago was to make the type checker run faster ;)
08:24:05 * matthew-_ remembers he has access to a machine with 8GB RAM
08:27:10 <mauke> @oeis 1 1 2 4 9 21 51 127
08:27:11 <lambdabot>  Motzkin numbers: number of ways of drawing any number of nonintersecting cho...
08:27:11 <lambdabot>  [1,1,2,4,9,21,51,127,323,835,2188,5798,15511,41835,113634,310572,853467,2356...
08:28:54 <plutonas> when i want to match a non empty list i use (x:xs), right?
08:29:10 <int-e> plutonas: right.
08:29:14 <plutonas> strange then
08:29:21 <plutonas> i get a stack overflow
08:29:57 <plutonas> an empty one would be matched with [] i guess?
08:30:55 <Saizan> yes
08:31:12 <int-e> > let f [] = 0; f (x:xs) = 1 + f xs in (f [], f [1,2,3,4,5,7,8,9,9])
08:31:14 <lambdabot>   (0,9)
08:31:23 <plutonas> http://pastebin.ca/1219907 <-- could someone please give me a hint why calling this function causes stack overflow?
08:32:11 <int-e> plutonas: similarityScore [] (x:xs) = similarityScore "-" (x:xs)
08:32:31 <plutonas> int-e: yes, this should produce a call to the first definition
08:32:47 <plutonas> until we end up having both lists empty
08:32:48 <Beelsebob> plutonas: your lists never get shorter
08:32:59 <int-e> plutonas: but it increases the total length of the lists involved
08:33:16 <plutonas> hm, i got confused
08:33:26 <plutonas> i think it only increases the length of the shorter list
08:33:27 <Beelsebob> plutonas: which of your rules shortens the lists involved?
08:33:32 <plutonas> the first rule
08:33:36 <Beelsebob> no it doesn't
08:33:44 <Beelsebob> the first rule involves both (x:xs) and (y:ys)
08:34:02 <plutonas> if i substitute the last three definiton by similarityScore _ _ = 0
08:34:11 <plutonas> it gives a result
08:34:26 <plutonas> which i guess means that first rule does shorten the lists as expected
08:34:31 <plutonas> am i wrong?
08:34:32 <Saizan> plutonas: similarityScore "-" (x:xs) calls similarityScore [] (x:xs) so you get a loop
08:34:33 <Beelsebob> no it doesn't
08:34:55 <Beelsebob> it means that the first rule shortens *one* list in each case -- the problem is that if only one list gets shortened, the rest of the rules make it longer again
08:35:53 <plutonas> if the maximum is the first element, then it would shorten both lists no?
08:35:53 <ivanm> when declaring an executable in Cabal, what is the other-modules field for?
08:36:01 <sclv> anyone care to implement this in haskell: http://www.reddit.com/r/programming/comments/75bxi/multidimensional_analog_literals_the_reason_why_c/
08:36:04 <lambdabot> Title: Multi-Dimensional Analog Literals (the reason why C++ has maximum powers) : prog ..., http://tinyurl.com/3t3mjd
08:36:09 <plutonas> hm Saizan i see
08:36:14 <Beelsebob> plutonas: but it needs to compute the other ones to figure out which one is the maximum
08:36:22 <plutonas> yes, you're right
08:36:25 <plutonas> i understand the problem now
08:36:31 <plutonas> no idea how to fix it though...
08:37:18 <plutonas> by substituting the last 3 lines with similarityScore _ _ = 0 it works, except of the cases, when there need to be added '-''s on the end of one list, thats what i tried to accomplish
08:37:33 <int-e> plutonas: the recursive call should have the same form as in the first rule -  similarityScore ? ? + score ?
08:38:49 <plutonas> :) thanks int-e
08:44:02 <Saizan> ivanm: the modules it uses to compile
08:44:14 <Saizan> ivanm: just like other-modules in libraries
08:44:14 <ivanm> OK, so I need to include them all in...
08:44:33 <ivanm> it won't just bring them all in?
08:44:46 <Saizan> yeah, at least the ones that are not part of the Library part
08:45:33 <Saizan> well, build will work since ghc finds them automatically, but sdist doesn't
08:46:04 <ivanm> ahhh
08:46:22 <ivanm> if I have a plain executable, do I need a library part?
08:47:04 <ivanm> so other-modules are those that _aren't_ listed in exposed-modules/Main-Is ?
08:47:32 <Saizan> yeah
08:47:48 <Saizan> and no, you don't need a Library part
08:47:55 <ivanm> good-o
08:50:27 <ivanm> so if I want README, etc. files included, I'll need to put them in extra-source-files ?
08:50:59 <ivanm> if so, how can I include an entire directory?
08:52:55 <Saizan> i think you can use some sort of wildcard like dir/* but i'm not sure
08:53:08 <ivanm> *nod*
09:00:50 <mauke> why can putMVar receive asynchronous exceptions even in 'block'?
09:02:39 <mauke> yeah, because it blocks :/
09:21:37 <ivanm> *sigh* I just found out the reason that my code crashes is because of a printf error :@
09:22:05 <mauke> heh
09:22:30 <ivanm> except that as far as I can tell, it's right! :o
09:22:46 <ivanm> oh, wait, I did %m instead of %s for one time...
09:22:50 <ivanm> (the variable is called m)
09:22:51 <ivanm> :s
09:25:10 <TomMD> ivanm: I was helping a junior programmer debug a 'C' program once.  I was just talking about a story in which the dumbest error I made was in dereferencing a null in my debug printf.  It was a poor choice of story given what the bug turned out to be...
09:25:55 <Spark> that sort of error is trivial to debug
09:27:13 <TomMD> Yes, but there were some other factors that were confusing the poor guy.
09:27:25 <ivanm> heh
09:27:39 <TomMD> In otherwords: non-trivial bugs that caused incorrect operation ontop of the trival bug that caused crashes.
09:32:18 <waern> hc
09:41:45 <adekoba> htop
09:42:36 * adekoba wrote to the wrong terminal
09:50:02 <ski> hm .. `forall a. Foo (Foo a) -> Foo a' .. `concatFoo' or `joinFoo' ?
09:58:04 <dolio> muFoo?
09:58:06 <kpreid> ski: perhaps concatFoo would be [Foo a] -> Foo a?
09:58:40 <hackage> Uploaded to hackage: Graphalyze 0.3
09:58:40 <hackage> Uploaded to hackage: SourceGraph 0.1
09:59:59 <mml`> :k Foldable
10:00:00 <lambdabot>     Not in scope: type constructor or class `Foldable'
10:00:54 <allbery_b> :k Data.Foldable.Foldable
10:00:56 <lambdabot> Class `Data.Foldable.Foldable' used as a type
10:01:00 <allbery_b> oh well
10:01:17 <allbery_b> @instances-importing Data.Foldable Foldable
10:01:18 <lambdabot> Maybe, []
10:17:51 <Olathe> :k *
10:17:52 <lambdabot> parse error on input `*'
10:20:43 <byorgey> Olathe: * already  is a kind
10:21:00 <byorgey> and Haskell doesn't go any higher than that
10:22:58 <matthew-_> it would be nice to do a staged system where you can have an arbitrary number of type levels
10:23:20 <matthew-_> but sadly haskell's type system and value system have such different syntax that you can't really do it
10:23:47 <matthew-_> the only possibility would be to have the type system as the highest ever level and then layers of "value level" beneath
10:24:40 <Deewiant> and what would you possibly do with such a system :-P
10:26:29 <matthew-_> I dunno, but it'd be awesome
10:26:45 <matthew-_> Omega is pretty close to what I'm describing
10:34:15 <ski> (kpreid : hm, possibly ..)
10:41:53 <byorgey> matthew-_: yeah, that would be cool
10:42:53 <matthew-_> but I think really you need a single syntax for both types and values, otherwise it's a bit crazy
10:43:24 <matthew-_> if you could use TH to output splices (err, I can't remember, can you?) then you could do it that way, but it'd be fugly as hell
10:43:54 <dmwit> Agda has such a type system.
10:44:05 <dmwit> Setn : Set{n+1}
10:44:08 <lynx> hello
10:44:13 <lynx> everybody
10:44:24 <matthew-_> dmwit: ahh I see. I thought agda was fully dependent, but I've not really looked at it
10:44:55 <dmwit> Me neither, actually. =)  Just parroting what somebody else said the other day.
10:45:27 <lynx> could someone help me please
10:45:41 <dmwit> Don't ask to ask.  Just ask.
10:45:42 <byorgey> Agda *is* fully dependent.
10:46:01 <byorgey> which makes the 'you need a single syntax for types and values' thing really easy =)
10:46:22 <byorgey> but it does have a stratified kind system like dmwit says (otherwise you get an inconsistent logic.)
10:46:37 <lynx> ok
10:46:43 <lynx> here is the problem
10:46:43 <matthew-_> ahh, my logic is way too weak to know things like that
10:47:11 <Heffalump> what forms of dependency are there short of fully dependent?
10:47:32 <byorgey> matthew-_: I don't know the details, just that if you have things like * : * you can encode logical paradoxes
10:48:18 <dmwit> Heffalump: Well, I would say Coq's Prop universe might be considered not fully dependent.  But I haven't quite grokked all of Coq yet, so I could be just misunderstanding.
10:49:46 <dmwit> I'm also working on a language where there's a "proof" monad, and certain of the dependent types can only have values in that monad as dependencies.
10:49:58 <dmwit> So I think there's room for things short of fully dependent.
10:50:59 <dmwit> s/on a language/with a language/ maybe, it's not something I designed =P
10:51:12 <matthew-_> I'm wondering whether Heffalump's question was more about the work "dependent": either a type can depend on the value or it can't?
10:51:27 <matthew-_> and in languages where it can't, it's just not right to call them dependent
10:51:38 <matthew-_> *word
10:52:31 <dmwit> lunchtime!
10:52:43 * matthew-_ just finished dinner...
10:52:50 <newsham> the kind that includes all kinds is kinda like the set that contains all sets, no?
10:53:00 <lynx> i have a function that returns data... the data definition line in the code is: data BinTree a = Leaf | Node (BinTree a) a (BinTree a)... then, i have the function, it removes a node from the tree: delete a x = <body> ...this is the sign of the function:  delete :: BinTree a -> a -> BinTree a ... if i want to delete a node in a tree that is just a Leaf, i can't, because the only thing that matters here are nodes and note the leaves, the smallest tree is just a
10:53:08 <dmwit> newsham: Not if you use category theory. ;-)
10:53:25 <newsham> dmwit: explain
10:53:43 <matthew-_> lynx: I think you got cut
10:53:55 <matthew-_> lynx: your text ends with "smallest tree is just a"
10:54:02 <newsham> lynx: since leafs dont have values, it shouldnt matter.
10:54:08 <newsham> lynx: you'll never be deleting a leaf
10:54:30 <newsham> (at least not directly)
10:54:46 <plutonas> is there a way to time function calls?
10:54:55 <newsham> yes, using profiling
10:55:05 <plutonas> that is i have two functions doing the same thing, and want to check how much faster one is
10:55:09 <plutonas> newsham: hm, how do i do this?
10:55:20 <plutonas> (i have no problem to time in the intnerpreter)
10:55:40 <newsham> http://haskell.org/ghc/docs/latest/html/users_guide/profiling.html
10:55:43 <opqdonut> well the empty tree is Leaf
10:55:44 <lambdabot> Title: Chapter�6.�Profiling, http://tinyurl.com/2z559y
10:55:52 <opqdonut> so remove should be the indentity operation on it
10:56:22 <opqdonut> (or signal an error, depending on the semantics you want for remove)
10:56:55 <dmwit> newsham: The set of all sets poses theoretical problems with self-reference, but the category of all sets does not.
10:56:56 <plutonas> newsham: isn't there something simpler like "time (fn arguments)"
10:57:11 <newsham> plutonas: i dont know.
10:57:23 <dmwit> newsham: Often, formalizations of type systems use category theory for exactly that reason.
10:57:28 <opqdonut> err, "the category of all sets" has nothing to do with category theory :\
10:57:42 <opqdonut> it does have stuff to do with axiomatisations of set theory
10:57:45 <newsham> dmwit: hmm.. then why do coq and agda have an infinite heirarchy of sets?
10:57:57 <opqdonut> that use some sort of type systems to clear the russel paradox
10:57:59 <newsham> i thought it was exactly to prevent any set from being the set of all sets
10:58:05 <dmwit> And that's about as much as I can tell you, because it's about as much as I know about category theory.  I don't even know the terms they use. =P
10:58:16 <rwbarton> plutonas: There's a package that does something slightly fancier
10:58:22 <rwbarton> @hackage benchpress
10:58:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/benchpress
10:58:32 <dmwit> newsham: Coq doesn't have an infinite hierarchy of sets.
10:58:43 <kaol> @hoogle String -> Word8
10:58:43 <lambdabot> Prelude read :: Read a => String -> a
10:58:44 <lambdabot> Text.Read read :: Read a => String -> a
10:58:44 <lambdabot> Prelude error :: String -> a
10:58:56 <newsham> dmwit: i thought it had universe0 universe1 etc...
10:59:08 <dmwit> newsham: No, at the top is Type.
10:59:11 <dmwit> Type : Type
10:59:14 <lynx> newsham: i have a function that returns data... the data definition line in the code is: data BinTree a = Leaf | Node (BinTree a) a (BinTree a)... then, i have the function, it removes a node from the tree: delete a x = <body> ...this is the sign of the function:  delete :: BinTree a -> a -> BinTree a ... if i want to delete a node in a tree that is just a Leaf, i can't, because the only thing that matters here are nodes and note the leaves, the
10:59:40 <newsham> lynx: since leafs dont have values, it shouldnt matter.  you'll never be deleting leafs
10:59:51 <pastorn> @src Monad
10:59:52 <lambdabot> class  Monad m  where
10:59:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:59:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:59:52 <lambdabot>     return      :: a -> m a
10:59:52 <lambdabot>     fail        :: String -> m a
11:00:04 <lynx> newsham: the smallest tree is just a leaf and would be defined as Leaf, the next level would be, for example, (Nodo Hoja 5 Hoja)... anybody that wants to help me understand until this point??
11:00:18 <pastorn> hmm... where are the lines that say that (>>) and fail aren't mandatory+
11:00:19 <lynx> newsham: yes, i know, i'm only telling you the definition
11:00:19 <newsham> lynx: since leafs dont have values, it shouldnt matter.  you'll never be deleting leafs
11:00:20 <pastorn> ?
11:00:29 <pastorn> @src Monad
11:00:29 <lambdabot> class  Monad m  where
11:00:29 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
11:00:29 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
11:00:29 <lambdabot>     return      :: a -> m a
11:00:29 <lambdabot>     fail        :: String -> m a
11:00:33 <rwbarton> @src (>>)
11:00:33 <newsham> yes i know, i only repeat the answer to your repeated question
11:00:33 <lambdabot> m >> k      = m >>= \_ -> k
11:00:38 <rwbarton> @src fail
11:00:39 <pastorn> oh, i meant hoogle...
11:00:39 <lambdabot> fail s      = error s
11:00:42 <lynx> newsham: here is the question
11:01:40 <rwbarton> pastorn: I don't think hoogle or haddock knows, unless it is spelled out in the documentation for the class (which it often is)
11:02:05 <pastorn> okay...
11:02:23 <lynx> newsham: a case of the funcion delete is: delete (Node a b c) e | isTheNodeThere (Node a b c) == False = error "node not founD"
11:03:06 <Heffalump> (sorry to ask the "non-fully" dependent question and then disappear earlier)
11:03:14 <Heffalump> I was really trying to understand what the spectrum is.
11:03:26 <Heffalump> GADTs sort of let types depend on values, but AIUI fall short of full dependency.
11:04:20 <lynx> newsham: but i need to return the tree because i need into another function even if the node is not in the tree, then the funcion will be written as: delete (Node a b c) | isTheNodeThere (Node a b c) == False = Node a b c
11:04:28 <lynx> newsham: isn't it?
11:04:46 <newsham> sure, returning the same tree should be fine
11:04:57 <newsham> also    delete n@(Node a b c) | .... = n    works
11:05:06 <lynx> right
11:05:09 <newsham> it will call your argument "n", and let you return the same one
11:05:10 <matthew-_> Heffalump: a GADT can't really do that. The result type can only differ based on the types of the arguments to the constructor
11:05:22 <lynx> newsham: but i still want to return the error message
11:05:31 <lynx> newsham: so, how can i do that
11:05:43 <newsham> you can return two things in a tuple or some other data structure
11:05:47 <newsham> the error and the return value
11:06:01 <newsham> ie:  = (n, "not found")
11:06:22 <newsham> although this will make your code more complicated
11:06:35 <newsham> when the caller could have just as easily asked first if the node was present
11:06:41 <Heffalump> matthew-_: it can differ based on the constructor too, surely?
11:06:52 <Heffalump> a GADT constructor with no arguments can still refine the type
11:07:02 <lynx> newsham: i tried : delete (Node a b c) e | boolean expr = do print "node not found" <next line> Node a b c, but did not work out
11:07:02 <matthew-_> oh yeah, sorry, I forgot that
11:07:38 <newsham> lynx: you can do something like that, but you need to understand how IO works
11:08:03 <newsham> it will alter the way you have to write your code.  it wont be a "function" anymore
11:08:10 <newsham> or rather, it will be a function that results in an IO value
11:08:33 <lynx> but if i use that dupla ( i mean the (n, "not found") i speak spanish sorry) then the function will have return value conflicts
11:08:38 <lynx> remember the sign?
11:08:48 <newsham> you'll have to change the type
11:08:54 <lynx> delete :: BinTree a -> a -> BinTree a
11:09:11 <newsham> that type does not let you return both a message and a tree
11:10:21 <rwbarton> It might make more sense to return either a message or a tree, because the caller of your function still has the original tree around anyways
11:10:25 <lynx> yes but if i delete :: BinTree a -> a -> (BinTree a, String) will be worst because another case of the funcion call itself
11:10:27 <matthew-_> Heffalump: but that's really just a noiser version of having multiple data declarations with single constructors
11:10:46 <newsham> lynx: yup, it will make it messier, for sure.
11:10:49 <newsham> but still workable
11:10:52 <matthew-_> which is pretty typically how I do all my type level voodoo anyway
11:12:12 <lynx> newsham: for sure :( ... but the question simplified is: can i use that do expression in a way that work for what i want, i've heard that a do-block type is the same as the type of its last instruction
11:12:45 <newsham> a do block is for monadic code
11:12:55 <newsham> you cant just use it for any old code
11:13:29 <lynx> newsham: so do print "not f" <next line> Node a b c would be of type BinTree a isn't it
11:13:36 <rwbarton> lynx: so printing an error message is what you want to do?  You don't want to return it somehow to the calling function?
11:13:45 <lynx> newsham: mmmmmmmh, right
11:14:00 <newsham> the type of a do-block has to be m <something>  for some monad m
11:14:21 <newsham> and if you want to do "print", m has to be "IO"
11:14:29 <lynx> newsham: i don't handle monads very well, too bad :(
11:14:41 <newsham> so you'd need to have type   BinTree a -> a -> IO (BinTree a)
11:15:17 <lynx> newsham: no, i want both, the error message and the tree without changes (in the case of the node to delete is not found)
11:15:35 <newsham> like i said earlier, that type does not let you return both a message and a tree
11:16:33 <lynx> newsham: right... well, thank you newsham... let me read about monads and IO type to find a solution
11:16:50 <newsham> you're welcome
11:30:47 <musiKk_> i have another (i think) simple problem: i'm trying to calculate the maximum of three numbers with function composition and max
11:31:04 <musiKk_> my attempt so far is: ((max 3) . max) 1 2
11:31:17 <musiKk_> now this doesn't work but i don't understand why
11:31:32 <heatsink> It would be simpler to use a lambda abstraction.  Do you really want to use function composition?
11:31:36 <roconnor> > (((max 3) .) . max) 1 2
11:31:38 <lambdabot>   3
11:31:38 <heatsink> It's kind of pointless.
11:32:19 <heatsink> @pointless \x y z -> x `max` y `max` z
11:32:19 <lambdabot> (max .) . max
11:32:51 <roconnor> > (max .) . max 1 2 3
11:32:53 <lambdabot>       Overlapping instances for Show (a1 -> a -> b -> b)
11:32:53 <lambdabot>        arising from ...
11:32:54 <musiKk_> hm
11:33:03 <heatsink> > ((max .) . max) 1 2 3
11:33:05 <lambdabot>   3
11:33:33 <Olathe> > maximum [1, 2, 3]
11:33:34 <lambdabot>   3
11:33:35 <musiKk_> i still don't get why my attempt doesn't work :/
11:34:04 <roconnor> musiKk_:  you are essentially trying to do f . max where  f = max 3, to compose f with max
11:34:05 <ddarius> @unpl ((max 3) . max) 1 2
11:34:06 <lambdabot> max 3 (max 1) 2
11:34:06 <rwbarton> :t (max 3) . max
11:34:08 <roconnor> but that doesn't work
11:34:08 <lambdabot> forall a. (Ord a, Ord (a -> a), Num (a -> a)) => a -> a -> a
11:34:17 <roconnor> because . only composes unary function
11:34:22 <roconnor> and max is a "binary" function
11:34:29 <Olathe> @unpl ((max 3).max)
11:34:29 <lambdabot> (\ c -> max 3 (max c))
11:34:53 <roconnor> to compose a unary funciton with a binary function, you can do
11:34:58 <roconnor> (f .) . max
11:35:04 <musiKk_> oh
11:35:08 <Cale> musiKk_: Think of max as something which you pass a value, and it gives you a function which takes another value and returns the maximum of the two.
11:35:23 <roconnor> @type \f g -> (f .) . g
11:35:24 <lambdabot> forall b c a a1. (b -> c) -> (a1 -> a -> b) -> a1 -> a -> c
11:35:48 <musiKk_> ah, thanks a lot
11:35:55 <ddarius> :t (.) . (.)
11:35:55 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
11:35:56 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:36:04 <roconnor> musiKk_: I say "binary" function in quotes because, of course, a binary funciton is just a unary function that returns a unary function.
11:36:32 <musiKk_> so ((max 3) . (max 4)) 5 works... i know it's ugly but it's just for me for understanding
11:36:45 <roconnor> > ((max 3) . (max 4)) 5
11:36:46 <Heffalump> matthew-_: it seems a bit more general than just having multiple data declarations, because with a GADT they compose
11:36:47 <lambdabot>   5
11:36:51 <roconnor> musiKk_: yep
11:36:55 <Heffalump> in the sense that you have a single type that encompasses them all
11:37:03 <musiKk_> because now there are two unary functions composed
11:37:06 <Heffalump> since Haskell doesn't have union types, I don't see how you could get that otherwise
11:37:06 <Cale> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
11:37:31 <roconnor> musiKk_: yep
11:37:51 <musiKk_> thanks a bunch :)
11:38:25 <pastorn> @src unsafePerformIO
11:38:26 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
11:38:31 <pastorn> whoa
11:38:44 <Cale> heh
11:38:52 <heatsink> :t lazy
11:38:53 <lambdabot> Not in scope: `lazy'
11:39:06 <newsham> :t lazy -->  "I'll tell you later"
11:39:07 <ddarius> lazy = id
11:39:07 <lambdabot> Not in scope: `lazy'
11:39:08 <Cale> That definition depends on the particular hackery which GHC uses to implement IO though.
11:39:24 <pastorn> ah
11:39:28 <pastorn> cool
11:39:40 <pastorn> why just one case?
11:39:49 <pastorn> what's the deal with that?
11:39:53 <roconnor> @src IO
11:39:54 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
11:40:11 <roconnor> IO is a newtype according to GHC
11:40:18 <roconnor> so there is only one case.
11:40:22 <pastorn> oh
11:40:24 <heatsink> newsham: This is to make it non-strict in m?
11:40:25 <Cale> case is used to force the evaluation of the function inside the IO value (which is a side-effecting function
11:40:27 <roconnor> essentially it is doing a pattern match
11:40:34 <Cale> )
11:40:39 <pastorn> roconnor: ok
11:40:52 <roconnor> what Cale said
11:41:15 <roconnor> If I understand correctly GHC uses case statements on unboxed objects to order evaluation.
11:41:28 <Cale> It passes the function a RealWorld value (which is just a token normally used to keep time dependencies straight via data dependencies)
11:41:53 <roconnor> actually now I'm not sure what I said is entirely true
11:42:09 <pastorn> is realWorld a constant? (like e.g. stdin)
11:42:17 <TomMD> another day, another bytestring lib, another dependancy problem.  Does anyone know what changed in this version?
11:42:20 <Cale> realWorld# is, anyway
11:42:27 <newsham> State RealWorld
11:42:37 <Cale> @src RealWorld
11:42:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:43:13 <Cale> data RealWorld
11:43:14 <Cale> aha
11:43:23 <Cale> It doesn't even have any values :)
11:43:30 <pastorn> heh
11:44:27 <heatsink> So, an instance of State# a doesn't contain an a?
11:44:52 <Cale> Not necessarily.
11:44:55 <dons> ?bug
11:44:56 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:45:18 <heatsink> Well, you can't have an unboxed uninhabited type...
11:45:30 <Cale> It's a function-- | @State\#@ is the primitive, unlifted type of states.  It has
11:45:30 <Cale> -- 	one type parameter, thus @State\# RealWorld@, or @State\# s@,
11:45:30 <Cale> -- 	where s is a type variable. The only purpose of the type parameter
11:45:30 <Cale> -- 	is to keep different state threads separate.  It is represented by
11:45:30 <Cale> -- 	nothing at all.
11:45:30 <Cale> data State# s
11:45:43 <Cale> heh
11:46:15 <Cale> er, ignore that 'It's a function' :)
11:46:23 <ddarius> newsham: It's Sunday.  Don't you have a wife and a kid to interact with?
11:46:34 <newsham> ddarius: they're both asleep.
11:46:43 <newsham> also i have a poker game in an hr
11:47:09 <newsham> ?type interact
11:47:10 <lambdabot> (String -> String) -> IO ()
11:47:37 <newsham> ?type interact (const "yes, dear.")
11:47:38 <lambdabot> IO ()
11:47:54 <Cale> newtype IO a = GHC.IOBase.IO (State# RealWorld -> (# State# RealWorld, a #))
11:48:13 <TomMD> newsham: Your kid is going to get tired of being called 'dear' pretty quick.
11:48:19 <heatsink> Cale: Ah, so the State# RealWorld in (# State# RealWorld, a #) is a boxed uninhabited type that is never evaluated.
11:48:23 <Cale> So it's a function from a type which has no values to unboxed pairs of a type which has no values and results ;)
11:48:31 <newsham> his vocabulary is nonexistant, i dont think he'll notice
11:48:39 <TomMD> ahh
11:48:55 <Baughn> heatsink: Well, that's an implementation detail. It doesn't /have/ to work that way.. but it acts as if it did, regardless
11:49:09 <ski> the real world has no value !?
11:49:29 <heatsink> ski: Yes! Remember, this is the internet!
11:49:37 <ski> oh .. right
11:49:50 <Cale> I actually rather dislike this RealWorld nonsense. Especially in the context of explaining the IO monad to beginners.
11:49:58 * ski feels much calmer now
11:50:03 <Baughn> ski: The real world exists solely for the purpose of fooling the compiler into producing correct code
11:50:09 <Baughn> Cale: Agreed
11:50:33 <newsham> http://www.thenewsh.com/~newsham/lambda/prelude.lam  <- defines IO as State Int  which passes around a dummy int which isnt used.
11:51:06 <Cale> It's a very evil and hackish way of doing something which could be done in a theoretically clean way. (But possibly it results in better code.)
11:51:33 <newsham> whats the theoretically clean way that isnt used?
11:51:35 <Cale> The (->) type could be kept pure all the way down.
11:51:42 <Baughn> Compilers are /full/ of that stuff. Doesn't mean newbies need to know about it.
11:51:55 <Baughn> newsham: An IO interpreter written in non-haskell
11:52:02 <Cale> newsham: Representing IO values as data which describes stuff to do.
11:52:03 <Baughn> With the IO monad building up a program for same
11:52:18 <heatsink> With the IO monad, you're asking people to think of (>>=) and return as library functions that are not defined in the language.  The fact that they can be defined in Haskell is an implementation detail.
11:52:46 <ski> Cale : have you seen Clean ?
11:52:51 <Cale> ski: Yeah :)
11:53:00 <ski> (just checking .. :)
11:53:02 <newsham> heatsink: as opposed to other languages which dont ask people to think
11:53:18 <Cale> In fact, I think I would be very tempted to define an IO monad in Clean.
11:54:00 <Cale> There, you'd end up with something like the RealWorld solution of course, because that's how Clean does IO to begin with. :)
11:54:10 <ski> Cale : <http://clean.cs.ru.nl/Download/Download_Libraries/Std_Env/StdFunc/stdfunc.html>
11:54:10 <lambdabot> http://clean.cs.ru.nl/Download/Download_Libraries/Std_Env/StdFunc/stdfunc.html>
11:55:08 <Cale> I forgot how strange the Clean type language looked ;)
11:55:15 <ski> (note (`seq',)`seqList',`bind',`return')
11:55:19 <Cale> yeah.
11:55:47 <heatsink> newsham: IMO: Other languages give you a fairly simple operational semantics that makes very simple examples easy to explain.  Then you build an ad-hoc, informal, big-step semantics on top of that for reasoning about nontrivial pieces of code... but by that time people are familiar enough with the language that they don't notice how complicated it has become.
11:55:55 <Cale> They have typeclasses in Clean though, don't they?
11:56:02 <Cale> Why is that not an instance?
11:56:22 <ski> i'm not sure if they have constructor classes
11:56:33 <Cale> ah
11:56:50 <Baughn> heatsink: I like haskell's approach. You can *perfectly well* ignore monads until you understand the basic language, and just use IO as an imperative language; their full power will be there once you get to them.
11:56:52 <mrd> heatsink: big-step is operational
11:58:18 <heatsink> mrd, ah yeah.  I meant that the language defines a small-step semantics, and then people build their own big-step semantics around it.
11:58:57 <heatsink> Baughn: I agree.
11:59:39 <jdrake> Does ghc 6.8.3 have improvements over 6.8.2 that it would be worth it to upgrade? (where it might be some trouble to do so)
12:00:14 <dolio> I'd stick with 6.8.2.
12:00:18 <dons> yeah, no big deal.
12:00:24 <heatsink> jdrake: I think it has improvements to associated types, if you use those.
12:00:30 <Baughn> 6.10.1 will be out soon enough. One upgrade should be sufficient
12:00:37 <dolio> 6.8.3 actually had a regression in one of the optimizations.
12:01:16 <pastorn> what's coming in 6.10?
12:01:18 <mrd> i'm not sure how big-step is going to be more complicated than small-step there
12:01:22 <mrd> they should be equivalent
12:01:26 <Baughn> I'm wondering, though - given the amount of low-level work and outright replacement that's going on with 6.10, just what would it take to get to 7?
12:01:31 <jdrake> ok, I use debian so it is at 6.8.2, although I should figure out how to upgrade a package to a newer version for when that time comes.
12:01:34 <mrd> and most people think in terms of big-step semantics, since it most approximates an interpreter
12:01:46 <Baughn> pastorn: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
12:01:49 <lambdabot> Title: Status/Releases - GHC - Trac
12:01:53 <Botje> Baughn: ghc 7 will be smart enough to upgrade your code for you, of course.
12:02:22 <Baughn> jdrake: Actually,the usual solution for debian is to install your own, in /usr/local
12:02:41 <jdrake> Baughn, I would rather stick with the package manager as much as possible
12:02:45 <Baughn> jdrake: I suppose you could use one of the package-building make install wrappers, though
12:03:34 <jdrake> I am also wanting to learn more about the package manager, I have started to be able to build experimental packages from source for the testing. The next logical step is to see how to upgrade the package versions themselves.
12:03:44 <Baughn> pastorn: Parallel GC here doesn't mean the GC is incremental (sadly, not even an option), but it does mean the GC takes advantage of multiple cores so the stops are /shorter/
12:03:57 <jdrake> "We expect to release GHC 6.10 around ICFP 2008."  When is icfp 2008?
12:04:16 <Heffalump> it was a week and a bit ago :-)
12:04:21 <jdrake> perfect :-)
12:04:22 <Heffalump> they did get a beta out
12:04:26 <dons> busy busy.
12:04:57 <Baughn> Has anyone been looking at incremental gc, actually?
12:05:07 <jdrake> Hmm, it uses something haddock? I think I prefer catfish.
12:05:08 <Baughn> It doesn't seem to be much of an issue on modern systems, but it'd be nice
12:05:55 <ddarius> mrd: big-step "operational" semantics is for the most part just a notational variation on denotational semantics.
12:06:55 <jdrake> Apparently it is easy to upgrade the package version "uupdate upgrades a source code package from an upstream revision"
12:07:46 <jdrake> So I will look at ghc 6.10 with love, if I am still using ghc for my project :-). Right now it is a competition between ghc and python.
12:08:13 <heatsink> jdrake: What does the project do?
12:08:38 <jdrake> heatsink, best described here: http://www.techsociety.ca/doku.php
12:08:40 <jdrake> oops
12:08:41 <lambdabot> Title: start
12:08:47 <jdrake> http://www.techsociety.ca/programming:starz
12:08:48 <lambdabot> Title: programming:starz
12:08:50 <jdrake> rather that
12:09:07 <jdrake> "Starz is intended to be a basic game similar to an old dos game called 'Galactic'. The premise behind Starz is that you have a fixed grid that contains so many planets. These planets vary in such ways as production ability and a kill ratio. "
12:09:27 <jdrake> More details here: http://www.techsociety.ca/programming:starz:planning
12:09:28 <lambdabot> Title: programming:starz:planning
12:09:45 <dons> Cale: http://hackage.haskell.org/packages/archive/unicode-prelude/0.1/doc/html/Prelude-Unicode.html
12:09:47 <lambdabot> Title: Prelude.Unicode, http://tinyurl.com/3hj486
12:09:51 <pastorn> Baughn: oh, cool
12:10:01 * sw17ch wonders how to convert a Lazy ByteString to a Strict (and the reverse)
12:10:04 <pastorn> now i just need to get a multi core cpu
12:10:16 <jdrake> But the essential testing right now is in 'demo1a' which is a gtk+ program that draws a grid and places planets. Python is done, and I am converting it to haskell, and then comparing.
12:10:18 <sw17ch> i know (unpack . pack) will do it, but i'm hoping that operation is faster than i'm imagining it
12:10:25 <pastorn> > do { x <- Just 1; y <- Nothing; return x}
12:10:27 <lambdabot>   Nothing
12:10:45 <chrisdone> sw17ch: there's a function to do it, chunks or whatever. let me check
12:10:46 <dmwit> jdrake: If most of the program is in the GUI right now, I doubt you'll find much difference between the Python and Haskell code.
12:11:04 <dons> sw17ch: do not pack.
12:11:08 <pastorn> what monad should i use that MIGHT fail but doesn't bring down my whole result?
12:11:09 <dons> fromChunks/toChunks
12:11:10 <sw17ch> chrisdone: found it
12:11:14 <sw17ch> dons: ^^
12:11:17 <chrisdone> that's the one
12:11:36 <sw17ch> dons: (concat . toChunks) /
12:11:37 <sw17ch> ?
12:11:37 <dmwit> pastorn: MonadPlus
12:11:48 <jdrake> dmwit, got that right. It may be a determination of what makes my life easier too.
12:11:57 <dons> sw17ch: yup
12:12:02 <sw17ch> dons: excellent
12:12:10 <sw17ch> dons++ chrisdone++
12:12:48 <chrisdone> > map f [x,y,z]
12:12:50 <lambdabot>   Add a type signature
12:13:21 <chrisdone> @t x
12:13:21 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:13:24 <chrisdone> @type x
12:13:25 <lambdabot> Expr
12:13:38 <chrisdone> > x + y
12:13:40 <lambdabot>   x + y
12:13:49 <chrisdone> > fix (x:)
12:13:51 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
12:14:58 <Spark> > fix (x+)
12:14:59 <lambdabot>   x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (x + (...
12:15:05 <Spark> heh
12:15:11 <Olathe> > fix sqrt x
12:15:12 <lambdabot>       No instance for (Floating (Expr -> a))
12:15:12 <lambdabot>        arising from a use of `sq...
12:15:17 <Olathe> > fix (sqrt)
12:15:18 <lambdabot>   * Exception: stack overflow
12:15:30 <Olathe> > fix id
12:15:32 <lambdabot>   * Exception: stack overflow
12:15:38 <Spark> hmm
12:15:44 <dmwit> jdrake: (I might even go as far as to say you won't notice the difference between Python, Haskell, and *C* for mostly-Gtk code.)
12:15:46 <Spark> oh
12:15:55 <chrisdone> > fix (\n x -> n : n + x) 1
12:15:56 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
12:15:56 <lambdabot>      Prob...
12:16:08 <chrisdone> > fix (\n x -> n : x) 1
12:16:13 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t -> t1]
12:16:15 <lambdabot>        ...
12:16:25 <dmwit> > fix (\n -> x : n)
12:16:27 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
12:16:30 <Olathe> > let f x = x:f (sqrt x) in f x
12:16:31 <lambdabot>   [x,sqrt x,sqrt (sqrt x),sqrt (sqrt (sqrt x)),sqrt (sqrt (sqrt (sqrt x))),sq...
12:16:34 <RayNbow> > fix ([x]++)
12:16:36 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
12:16:40 <Olathe> > let f x = x:f (omg x) in f x
12:16:41 <lambdabot>   Not in scope: `omg'
12:16:43 <dmwit> > fix (\n -> x : n + head x)
12:16:43 <jdrake> If I have this line:  import Graphics.UI.Gtk.Glade  then I use xmlNew, but xmlNew doesn't actually describe what it does where something like Glade.xmlNew might. Is there a way to do this in a way that I can use more descriptive names?
12:16:44 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
12:16:50 <Olathe> > let omg = omg in let f x = x:f (omg x) in f x
12:16:53 <chrisdone> > fix f
12:16:55 <lambdabot>   Add a type signature
12:17:05 <lambdabot>   thread killed
12:17:08 <dmwit> jdrake: import Graphics.UI.Gtk.Glade as Glade
12:17:15 <Olathe> > let omg :: a -> a; omg = omg; f x = x:f (omg x) in f x
12:17:17 <lambdabot>   [x,* Exception: stack overflow
12:17:18 <jdrake> dmwit, thanks
12:17:33 <Olathe> How does it know not to evaluate sqrt ?
12:17:47 <dmwit> jdrake: You might want to stick a "qualified" in there if Glade defines names that might conflict with other modules.
12:17:51 <Olathe> > let omg = sqrt; f x = x:f (omg x) in f x
12:17:53 <lambdabot>   [x,sqrt x,sqrt (sqrt x),sqrt (sqrt (sqrt x)),sqrt (sqrt (sqrt (sqrt x))),sq...
12:18:18 <Olathe> @type (x :: Expr)
12:18:19 <lambdabot> Expr
12:18:24 <olsner> > let omg = sqrt; f x = x:f (omg x) in f 1
12:18:25 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
12:18:35 <Heffalump> Olathe: it's working in a special type called Expr, which just displays abstract syntax trees
12:18:47 <Olathe> Expr must be an instance of Num.
12:18:48 <Olathe> Or something.
12:18:55 <Olathe> Whatever sqrt is in.
12:19:13 <Olathe> Hmm.
12:19:17 <dmwit> yes
12:19:22 <dmwit> ?where simple-reflect
12:19:22 <lambdabot> I know nothing about simple-reflect.
12:19:26 <dmwit> ?where simplereflect
12:19:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:19:33 <jdrake> Does the qualified require the use of the entire Graphics.UI.Gtk.Glade?
12:19:39 <Olathe> Does it leave all functions in classes unevaluated ?
12:19:54 <daf> jdrake: not if you use "as" as well
12:20:12 <pastorn> Baughn: on that link a new records interface is mentioned, do you know anything about that?
12:20:16 <chrisdone> Olathe: I think it leaves all functions which have not been defined unevaluated
12:20:18 <jdrake> daf, then what does qualified do specifically then. The wikibooks page doesn't say that much.
12:20:39 <Olathe> > let f x = x:f (negate x) in f x
12:20:43 <lambdabot>   [x,negate x,negate (negate x),negate (negate (negate x)),negate (negate (ne...
12:20:53 <Olathe> negate is defined, I think.
12:21:26 <chrisdone> then it must be the presence of `x' at the last column that infers it as an Expr
12:21:31 <Baughn> pastorn: http://hackage.haskell.org/trac/ghc/wiki/Status/Nov07
12:21:33 <lambdabot> Title: Status/Nov07 - GHC - Trac
12:21:43 <dmwit> jdrake: An import line always imports the fully qualified name.  "qualified" just stops the unqualified name from being imported.
12:21:51 <chrisdone> > let f x = x:f (negate x) in f 0
12:21:55 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
12:21:58 <chrisdone> > let f x = x:f (negate x) in f x
12:21:58 <dmwit> jdrake: "as" imports an additional name under a different (usually shorter) qualification.
12:21:59 <Olathe> chrisdone: Why does it evaluate omg ?
12:22:00 <daf> jdrake: by default, import Foo imports all the names in Foo into the current module's namespace
12:22:02 <vixey> > gcd 384 541 :: Expr
12:22:02 <lambdabot>   [x,negate x,negate (negate x),negate (negate (negate x)),negate (negate (ne...
12:22:04 <Olathe> > let omg = sqrt; f x = x:f (omg x) in f x
12:22:06 <lambdabot>   abs 541 `rem` (abs 384 `rem` abs 541) `rem` (abs 384 `rem` abs 541 `rem` (a...
12:22:08 <vixey> > gcd 384 5410 :: Expr
12:22:08 <lambdabot>   [x,sqrt x,sqrt (sqrt x),sqrt (sqrt (sqrt x)),sqrt (sqrt (sqrt (sqrt x))),sq...
12:22:12 <lambdabot>   abs 384 `rem` abs 5410 `rem` (abs 5410 `rem` (abs 384 `rem` abs 5410)) `rem...
12:22:16 <Olathe> Ooh !
12:22:29 <daf> jdrake: import qualified Foo means that only the name Foo is imported
12:22:41 <daf> jdrake: you have to qualify all access to its members with "Foo."
12:22:44 <Olathe> > x^y :: Expr
12:22:55 <vixey> > 3^8 :: Expr
12:22:58 <daf> jdrake: I think the Haskell 98 report's description of the details is actually pretty readable
12:23:08 <daf> jdrake: http://www.haskell.org/onlinereport/modules.html
12:23:09 <Olathe> @bot
12:23:15 <jdrake> Doesn't that what import Foo as Foo do the same thing though?
12:23:20 <Olathe> @wakeup
12:23:25 <scodil> you killed it
12:23:37 <chrisdone> murdar1!
12:23:41 <daf> jdrake: no
12:23:42 <Olathe> :o
12:23:59 <daf> jdrake: "as" and "qualified" are orthogonal
12:24:23 <pastorn> Baughn: thanks :D
12:24:48 <daf> jdrake: you can always access via the full name
12:24:55 <daf> jdrake: as controls what the full name is
12:24:57 <dmwit> jdrake: "as" *adds* a name, but does not remove any.
12:25:05 <pastorn> Baughn: heh, i looked at that page but didn't scroll down, it looked like just boring statistics...
12:25:06 <dmwit> jdrake: "qualified" *removes* a name, but does not add any.
12:25:18 <daf> dmwit: nicely put
12:25:21 <chrisdone> > fix id 1 2 3 4 5 6 7 8 9 10
12:25:35 <jdrake> ok, now what does orthogonal mean in this context? (does it mean you can use both at the same time?)
12:25:44 <daf> jdrake: it means they are independent
12:26:06 <jdrake> ok. There seems to be so many different meanings to 'orthogonal'
12:26:07 <daf> jdrake: the report includes examples of various combinations
12:26:20 <scodil> the inner product of "as" and "qualified" is zero
12:27:32 <jdrake> scodil, inner product?
12:27:40 <scodil> joking
12:27:42 <scodil> dot product
12:27:43 <jdrake> Do we have dot products of as and qualified too?
12:27:44 <scodil> scalar product
12:28:23 <jdrake> scodil, considering that haskell seems to be computed math, it would not surprise me if there was some kind of mathematical basis for it all.
12:28:41 <vixey> like lambda calculus?
12:29:03 <sbahra> @ask Cale May you add ##FreeBSD to the list of channels lambdabot should join, please? I am a channel operator there.
12:29:09 <sbahra> vixey, yes.
12:29:12 <sbahra> vixey, do you?
12:29:29 <chrisdone> λ_λ
12:29:45 <jdrake> Is there any way of doing this in less code? http://hpaste.org/10919
12:29:53 <Olathe> sbahra: The poor bot is currently dead.
12:30:03 <vixey> jdrake: You could use maybe
12:30:17 <scodil> fromMayb
12:30:18 <scodil> e
12:30:24 <vixey> maybe not fromMaybe
12:30:45 <scodil> maybe id?
12:30:49 <sbahra> Olathe, damn it :(
12:30:51 <sbahra> > id
12:31:16 <sbahra> What's the point of living anymore
12:31:36 <rwbarton> windowXml <- fromMaybe (error "...") <$> Glade.xmlNew "..."
12:31:38 <chrisdone> fromMaybe (error "Can't find the UI definition \"demo1.glade\".") `liftM` Glade.xmlNew "demo1.glade"
12:31:50 <jdrake> fromJust?
12:31:59 <rwbarton> @src fromJust
12:32:00 <chrisdone> no, not fromJust
12:32:02 <vixey> jdrake: maybe
12:32:16 <jdrake> vixey, haha
12:32:56 * chrisdone raises eyebrow
12:33:15 <Olathe> , 1 + 2
12:33:17 <lunabot>  3
12:33:20 <Olathe> Yay !!
12:33:25 <Olathe> , x :: Expr
12:33:27 <lunabot>  luna: Not in scope: type constructor or class `Expr'
12:33:27 <lunabot>  Not in scope: `x'
12:33:32 <scodil> oh great now you can kill another one
12:33:36 <sbahra> , sum [1 .. 10]
12:33:37 <lunabot>  55
12:33:38 <Olathe> Heheh, it doesn't have Expr.
12:33:43 <Olathe> So, we might be safe.
12:33:43 <sbahra> Expr is really cool.
12:33:49 <Philonous> @type (max .)
12:33:56 <sbahra> ,type (max .)
12:33:57 <lunabot>  luna: parse error on input `type'
12:33:57 <scodil> bots are never safe when Olathe is on the prowl
12:34:00 <Olathe> Heheh
12:34:05 <rwbarton> , eval "(max .)"
12:34:14 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
12:34:14 <lunabot>    `Data.Typeable.Typeable a'
12:34:14 <lunabot>      arising from a use of `Data.Dynamic.toDyn' at <interactive>:1:23-50
12:34:19 <Olathe> , (max .)
12:34:20 <lunabot>  luna: No instance for (GHC.Show.Show ((a -> b) -> a -> b -> b))
12:34:20 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-57
12:34:20 <lunabot>  Possible fix:
12:34:28 <Olathe> , eval "(max .)"
12:34:33 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
12:34:33 <lunabot>    `Data.Typeable.Typeable a'
12:34:33 <lunabot>      arising from a use of `Data.Dynamic.toDyn' at <interactive>:1:23-50
12:34:37 <ddarius> , eval "max 1 2" :: Int
12:34:39 <Olathe> , show.eval "(max .)"
12:34:41 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
12:34:41 <lunabot>         against inferred type `Data.Dynamic.Dynamic'
12:34:42 <lunabot>  luna: Couldn't match expected type `a -> b'
12:34:42 <lunabot>         against inferred type `Data.Dynamic.Dynamic'
12:34:44 <Olathe> , show.eval $ "(max .)"
12:34:48 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
12:34:48 <lunabot>    `Data.Typeable.Typeable a'
12:34:48 <lunabot>      arising from a use of `Data.Dynamic.toDyn' at <interactive>:1:23-50
12:34:56 <sbahra> , putStrLn "Hello world"
12:34:58 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
12:34:58 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-72
12:34:58 <lunabot>  Possible fix:
12:35:09 <sbahra> Too much noise. :)
12:35:10 * sbahra stops
12:35:24 <chrisdone> needs moar (unwords . words)
12:36:24 <pcc1> does haskell have a date data type?
12:36:27 <eth01> eww
12:36:38 <eth01> that looks messy.
12:36:48 <dmwit_> pcc1: Data.Time
12:36:49 * eth01 gets his glasses
12:37:52 <sbahra> jdrake,
12:37:55 <sbahra> , maybe 0 (+ 2) (Just 4)
12:37:57 <lunabot>  6
12:38:00 <heatsink> Greeting, name.
12:40:14 <maxote> @google Quine McCluskey
12:40:46 <abbe> Quine McCluskey method of simplifying boolean expressions, hmm...?
12:42:15 <chrisdone> list nil cons [] = nil; list nil cons xs = cons xs
12:42:21 <chrisdone> is this defined in any libraries?
12:43:32 <heatsink> if null xs then nil else cons xs
12:44:36 <chrisdone> heatsink: that's longer
12:46:07 <heatsink> I don't think there's an abbreviation.
12:46:40 <pcc1> does haskell have a (specialised) monetary data type?
12:46:46 <dmwit> no
12:47:03 <dmwit> There's Integer and CReal, choose the one that makes you least uncomfortable as your base.
12:47:03 <Olathe> pcc1: You can use the wonderful world of CReal for exactness.
12:47:11 <chrisdone> heatsink: I define it in pretty much every project
12:48:08 <heatsink> chrisdone: What kind of situation calls for it?
12:48:37 <chrisdone> heatsink: the same kind as for `maybe'
12:48:53 <pcc1> dmwit, Olathe: thanks
12:49:09 <Olathe> pcc1: You're welcome.
12:49:32 <rwbarton> chrisdone: but the second argument to maybe doesn't accept a Maybe a.  Whereas your 'list' just takes a function [a] -> b and changes its behavior on the empty list in a weird way.
12:49:49 <dmwit> Yeah, that function is a bit odd.
12:50:08 <heatsink> I'm curious because in my experience, the 'z' parameter of a fold is already what you want for an empty list, so there's no need to special-case it.
12:50:12 <dmwit> chrisdone: Maybe you should take a look at foldr.
12:50:15 <dmwit> right
12:50:17 <chrisdone> the whole point is “I want to do something with this value, but if it's empty, then use this value instead”
12:50:30 <Olathe> , 1 :+ 0
12:50:31 <lunabot>  luna: Not in scope: data constructor `:+'
12:50:35 <Olathe> :(
12:50:40 <Olathe> , 1 :( 0
12:50:40 <rwbarton> chrisdone: I'd think you want to fix the "do something" function then.
12:50:42 <lunabot>  luna: parse error (possibly incorrect indentation)
12:50:45 <dmwit> chrisdone: Then you should be using Maybe.
12:50:58 <chrisdone> not really
12:51:20 <dmwit> chrisdone: It would help us a lot if we had a concrete use case to talk about.
12:51:48 <dmwit> (And if it's a good use case, then your argument suddenly becomes a lot stronger. =)
12:52:10 <chrisdone> yes
12:53:01 <chrisdone> lunabot: help
12:53:16 <chrisdone> ok
12:53:40 <rwbarton> lunabot just evaluates expressions
12:53:56 <dmwit> lambdabot: No, don't go! =(
12:54:14 <chrisdone> , let list nil cons xs = if null xs then nil else cons xs in list "" head $ lines "I've got a lovely bunch of coconuts\ndiddily dee"
12:54:16 <lunabot>  "I've got a lovely bunch of coconuts"
12:54:23 <chrisdone> , let list nil cons xs = if null xs then nil else cons xs in list "" head $ lines ""
12:54:25 <lunabot>  ""
12:54:45 <dmwit> > take 1 . lines $ "coconuts\ndiddily dee"
12:54:55 <lambdabot>   ["coconuts"]
12:54:55 <dmwit> , take 1 . lines $ "coconuts\ndiddily dee"
12:54:57 <lunabot>  ["coconuts"]
12:55:03 <dmwit> , take 1 . lines $ ""
12:55:04 <chrisdone> list (cmdProc cmdDef terms) replies out
12:55:05 <lunabot>  []
12:55:10 <chrisdone> it's hard to think of a good example
12:55:13 <chrisdone> it's all over my code
12:55:44 <chrisdone> msgTo :: Msg -> String
12:55:44 <chrisdone> msgTo = list "" head . msgPs
12:56:08 <dmwit> Msg = [String] ?
12:56:31 <dmwit> :t concat . take 1
12:56:32 <chrisdone> msgPs :: Msg -> [String]
12:56:33 <lambdabot> forall a. [[a]] -> [a]
12:56:57 <dmwit> concat . take1 . msgPs
12:57:42 <chrisdone> list "" ((" "++) . parens . head) (valsiGloss v)
12:57:48 <rwbarton> chrisdone: take a look at the Safe package
12:57:53 * chrisdone looks
12:58:41 <hackage> Uploaded to hackage: Pipe 2.1.0
12:58:48 <jdrake> Without going into details, I have heard somethings on arrows, and seen some application to javascript (UI events). I was wondering if these have any application to gtk2hs programming.
12:58:53 <maltem> maybe "" id . listToMaybe . msgPs -- not really shorter
12:59:01 <dmwit> chrisdone: Basically all of these are ideal uses of the Maybe monad.
12:59:28 <dmwit> jdrake: Yes, there are several higher-level libraries that use Arrows to make GUIs.
12:59:29 <heatsink> list nil (f . head) = maybe nil f . listToMaybe
12:59:32 <rwbarton> @hoogle [a] -> Maybe (a, [a])
12:59:32 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
12:59:33 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
12:59:33 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:00:45 <chrisdone> emacs crashed
13:00:58 <dmwit> jdrake: http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
13:01:00 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yttdtd
13:01:27 <rwbarton> @hoogle uncons
13:01:28 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
13:01:28 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
13:01:28 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
13:02:10 <chrisdone> list "" ((" "++) . parens . head) (valsiGloss v)
13:02:27 <chrisdone> maybe "" ((" "++) . parens . head) . listToMaybe $ (valsiGloss v)
13:03:01 <dmwit> (" "++) . parens . head . (++[""]) . valsiGloss
13:03:26 <dmwit> Although I don't really think that particular incarnation is better.
13:03:33 <rwbarton> dmwit: Clever but gross :)
13:03:38 <dmwit> right
13:03:41 <chrisdone> I prefer `list' because it expresses a kind of idea in a clear way
13:03:52 <chrisdone> but having to define it is annoying so I guess I'll use maybe
13:05:13 <heatsink> Do you use `list' without `head'?
13:05:37 <chrisdone> yes, I gave examples above
13:06:00 <chrisdone> list (cmdProc cmdDef terms) replies out
13:06:04 <chrisdone> this code says
13:06:26 <heatsink> Yeh, but I don't know what the other variables in that expression mean :)
13:06:29 <chrisdone> if `out' is not empty, send them all somewhere, if it is empty, then try something else
13:07:52 <chrisdone> a less specific example might be: list querySomethingElse (mapM putStrLn) results
13:09:22 <rwbarton> I don't understand why I would want to see all of the results if there are any, but only try some other way to get results if there are none.
13:09:31 <rwbarton> The examples with head make a lot more sense to me
13:09:47 <heatsink> chrisdone: In this latter context, I agree with whoever said it looks like a Maybe monad.
13:10:20 <chrisdone> how is it a monad?
13:10:28 <Itkovian> Anybody any idea if something similar to scipy is in the works for Haskell?
13:10:32 <chrisdone> it's just the `maybe' function
13:11:16 <chrisdone> rwbarton: you don't see why you would want that, so I must be wrong?
13:11:36 <rwbarton> chrisdone: No, but I'm not surprised if the library designers didn't see why you would want it either :)
13:11:45 <heatsink> chrisdone: (x `mplus` y :: Maybe a) means "execute x and return its value, except if it had no results, then execute y and return its value"
13:12:03 <chrisdone> heatsink: I know
13:12:07 <heatsink> ...which sound like what you're doing.
13:12:39 <rwbarton> It sounds like you want    listToMaybe' [] = Nothing; listToMaybe' x = Just x
13:12:54 <rwbarton> (listToMaybe' :: [a] -> Maybe [a])
13:12:59 <rwbarton> and then msum those together
13:13:24 <chrisdone> I don't want that because it's just another thing I have to define
13:13:43 <dmwit> rwbarton: No, I think he needs to push the Maybe farther up his stack.
13:13:49 <dmwit> (i.e. deeper in the calls)
13:15:45 <chrisdone> it seems to me like all your suggestions to use Maybe make my code bigger and less abstract
13:16:54 * kaol wishes that ghc supported splicing in types with TH
13:20:10 <Cale> chrisdone: Use Maybe instead of what?
13:20:17 <heatsink> less abstract is better, as long as you can hide the plumbing within a function.  In this situation, I would probably define your `list' function in terms of Maybe and then use `list' as you're already doing.
13:20:42 <chrisdone> heatsink: O_O
13:21:04 * Cale tries to find chrisdone's paste :)
13:21:35 <chrisdone> Cale: well, I have a function “list nil cons xs = if null xs then nil else cons xs”
13:22:03 <chrisdone> Cale: it expresses an idea, when a list is populated, do something with it, when it is empty, do something else
13:22:09 <Cale> okay
13:22:25 <kaol> or perhaps I could make do with something like data Peano = Zero | Succ Peano
13:22:48 <mauke> I'd write that as list nil cons xs = case xs of [] -> nil; h:t -> cons h t
13:22:49 <Cale> I've seen something like  list nil cons [] = nil; list nil cons (x:xs) = cons x xs
13:22:53 <chrisdone> Cale: I asked if it was defined anywhere but apparently I should be using Maybe in some clever way
13:23:08 <mauke> I don't think it's predefined
13:23:09 <BMeph> chrisdone: My guess is, everyone objecting to your function does it because they already have an idea of what "cons" means, and your use of it conflicts with what they know. Other than that, it's perfectly legitimate. :)
13:23:09 <Cale> Well, that's possible, though it won't cover every case.
13:23:26 <Cale> chrisdone: To be honest, I usually just pattern match using case.
13:23:31 <Cale> case xs of
13:23:33 <Cale>    [] -> ...
13:23:38 <Cale>    (x:xs) -> ...
13:23:38 <chrisdone> okay, s/cons/foobar
13:24:02 <Riastradh> Something like foldr?
13:24:03 <Cale> (though if I was thinking I wouldn't have shadowed xs of course ;)
13:24:24 <dmwit> but his is "case xs of [] -> ...; _ -> ..."
13:24:32 <Cale> foldr is like this, only it replaces every cons in the list.
13:24:33 <dmwit> i.e. it doesn't split a non-empty list at all
13:24:42 <chrisdone> I don't always want the first element of the list..
13:25:04 <mauke> then you are evil
13:25:08 <Cale> hehe
13:25:27 <Cale> chrisdone: Probably I would just use case expressions.
13:25:33 <BMeph> case ma of { mzero -> f1 ; _ -> f ma } -- more useful, maybe? ;)
13:25:45 <Cale> BMeph: overlapped cases
13:25:52 <dmwit> ...except that mzero isn't a pattern
13:26:03 <dmwit> but yeah
13:26:06 <Cale> 'mzero' is a variable and hence as a pattern, matches anything
13:26:30 <dons> Cale: tried the unicode prelude yet?
13:26:35 <Cale> dons: nope
13:26:37 <chrisdone> I thought of that a while ago but couldn't think of a name for it, and there's only [] and Maybe where I need this kind of thing
13:26:38 <dons> Cale: i think it is in need of more symbols.
13:26:40 <BMeph> Cale: ... that's kind of annoying. :|
13:26:49 <dmwit> chrisdone: There's MonadPlus.
13:26:52 <dons> Cale: http://hackage.haskell.org/packages/archive/unicode-prelude/0.1/doc/html/Prelude-Unicode.html
13:26:53 <lambdabot> Title: Prelude.Unicode, http://tinyurl.com/3hj486
13:26:57 <Cale> BMeph: mzero isn't a constructor in general, so there's no way that could work
13:27:00 <dons> it's asking for your help.
13:27:19 <selmanj> I'm having trouble with lists and haskell.  If I had a list [(1,3),MyAction,[(2,3),(3,3)]] and I wanted to apply some function that takes two coords and an action, and store the result alongside the second coord... how would I do that?
13:27:20 <chrisdone> dmwit: I am aware of MonadPlus
13:27:21 <rwbarton> BMeph: If your program uses x in a case somewhere, and then you make a top-level binding for x, do you want your program to suddenly stop working?
13:27:26 <heatsink> Any advice on unicode text editors?
13:27:35 <dmwit> vim
13:27:51 <dmwit> selmanj: That is not a valid list to begin with.
13:27:53 <Cale> heatsink: Almost anything will do so long as you have an IME capable of generating the characters you want.
13:28:05 <Cale> I recommend SCIM + LaTeX mode.
13:28:11 <dmwit> selmanj: All elements of a list must have the same type.
13:28:23 <selmanj> dmwit: doh, i mean [((1,3),MyAction,[(2,3),(3,3)]]]
13:28:28 <selmanj> fuck
13:28:30 <selmanj> dmwit: doh, i mean [((1,3),MyAction,[(2,3),(3,3)])]
13:28:41 <selmanj> (its much easier to type with whitespace)
13:28:47 <dmwit> Okay, and what do you want to do with that?
13:29:01 <dmwit> (I'm not sure I understood your second part.)
13:29:13 <selmanj> I want to apply function t that takes a Coord, an Action, and another Coord, and returns a float
13:29:17 <chrisdone> maybe I'm looking at the problem of this function in the wrong way
13:29:17 <selmanj> and end up with something like
13:29:18 <chrisdone> http://hpaste.org/10920
13:29:25 <chrisdone> it uses `list' and `maybe' extensively
13:29:43 <dmwit> selmanj: type Coord = (Int, Int) -- or something like that?
13:29:46 <selmanj> [((1,3),MyAction,[((2,3), 0.1), ((3,3), 0.2)])]
13:29:46 <heatsink> Cale: Thx, I'll check out scim.
13:29:53 <selmanj> yes, where Coord = (Int, Int)
13:30:00 <selmanj> and MyAciton is an instance of action
13:30:03 <selmanj> MyAction*
13:30:12 <Heffalump> does the GHC RTS have a way of indicating the GHC version I compiled with?
13:30:25 <Deewiant> +RTS --info?
13:30:33 <bbs> :t f g x = g(g(x))
13:30:35 <lambdabot> parse error on input `='
13:30:39 <selmanj> Basically I'm calculating probabilities and want to pick the one that's the largest.  maybe storing it all in a really complicated list/tuple structure isn't such a great idea.
13:30:45 <bbs> :t g(g(x))
13:30:46 <lambdabot> forall t t1. (SimpleReflect.FromExpr (t -> t1), SimpleReflect.FromExpr (Expr -> t)) => t1
13:30:47 <Deewiant> :t f g x = g(g(x)) in f
13:30:48 <lambdabot> parse error on input `='
13:30:49 <Deewiant> :t let f g x = g(g(x)) in f
13:30:50 <Heffalump> not with whatever version of GHC I compiled with
13:30:50 <dmwit> selmanj: Okay, the first task is to write a function that takes a single element of the outer list (of type (Coord, Action, [Coord])), and returns the value of type (Coord, Action, [(Coord, Double)]).
13:30:51 <lambdabot> forall t. (t -> t) -> t -> t
13:30:55 <BMeph> rwbarton: Sorry to reply so late, but: I'm not a fan of dynamic binding, and I think it's the most confusing and stupid convention EVAR. :|
13:30:57 <dmwit> selmanj: Then you can just map that over the outer list.
13:31:01 <bbs> Deewiant: i don't get it
13:31:03 <tibbe> @seen dons
13:31:03 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 4m 3s ago.
13:31:04 <bbs> ita ll of type a
13:31:09 <chrisdone> any thoughts on that paste?
13:31:11 <bbs> since i'm calling the same function over and over right?
13:31:11 <Deewiant> bbs: what should it be
13:31:16 <dmwit> selmanj: For the single-element function, you'll probably also use map, along with a partially applied function.
13:31:23 <tibbe> dons: wassup? :)
13:31:23 <bbs> Deewiant: lol all of one type
13:31:25 <Cale> heatsink: If you're using Ubuntu, you can install it easily through the Administration -> Language Support dialog box by simply checking the box which says "Enable support to enter complex characters"
13:31:29 <bbs> since its only one functions
13:31:38 <Deewiant> Heffalump: works for 6.8.2, 6.8.3, and 6.10.0 at least
13:31:50 <heatsink> Cale: There appears to be a debian package for it.
13:31:51 <sw17ch> is ByteString.Lazy.hPut strict?
13:31:54 * sw17ch thinks it is
13:31:57 <dmwit> selmanj: But I might recommend that you start using better data types than Tuples, as they can often be easier to reason about (even though they are identical in power).
13:32:10 <dons> hey tibbe
13:32:12 <dons> busy busy
13:32:16 <Cale> heatsink: yeah, I'm not sure if installing that package will configure it as your default input method though.
13:32:24 <selmanj> dmwit: What would you use instead?  a new Data type?
13:32:46 <dmwit> yup
13:32:48 <bbs> Deewiant: so what type is it?
13:32:55 <Deewiant> :t let f g x = g(g(x)) in f
13:32:56 <lambdabot> forall t. (t -> t) -> t -> t
13:33:04 <tibbe> dons: yeah, I've been very busy too, almost no actual haskell hacking
13:33:15 <tibbe> dons: want to put together a release of hyena
13:33:38 <selmanj> dmwit: I didn't think about writing extra functions, I was trying to write a sequence of maps and (,) applications and failing miserably...  I'll try that, thanks :)
13:33:44 <heatsink> Cale: Since we're on the subject, I recently discovered OS X's awesome character palette, which organizes characters by language and by unicode code tables and shows characters in all available fonts.  Does SCIM have a similar feature?
13:33:55 <Deewiant> bbs: it's exactly what lambdabot says it is :-)
13:33:57 <Cale> heatsink: Gnome does.
13:34:05 <Cale> gucharmap
13:34:08 <rwbarton> selmanj: I tend to use list comprehensions in this kind of situation   [ (a, b, [ (c, f a b c) | c <- cs ]) | (a, b, cs) <- input ]
13:34:20 <Cale> Or, if you're on Ubuntu at least, Applications -> Accessories -> Character Map
13:34:21 <bbs> Deewiant: yea i get that part but what i don't get is why haskell infers it like that
13:34:34 <bbs> Deewiant: its a mathematical approach and i like that -- i just odn't know enough about haskell
13:34:39 <heatsink> Cale++
13:34:47 <mauke> bbs: what else could it be?
13:34:59 <bbs> mauke: not sure
13:35:00 <Deewiant> well, for starters, you have g (g x) -- you're calling g on itself which means g must have type (t -> t)
13:35:08 <Deewiant> i.e. the return type and parameter type must be the same
13:35:17 <chrisdone> xmodmap++
13:35:20 <selmanj> rwbarton: Hey, I like that!  That expresses what I want in a pretty readable form
13:35:25 <mauke> > show (show 42)
13:35:25 <Deewiant> and then, you have (g x) so x must be of type t.
13:35:26 <lambdabot>   "\"42\""
13:35:27 <Deewiant> and that's it.
13:35:31 <dons> tibbe: soon, after ghc comes out?
13:35:31 <Cale> Well, you're not calling g on *itself*, but on its result, anyway :)
13:35:42 <Deewiant> bah, semantics :-P
13:35:48 <tibbe> dons: that would be great, things are crazy at work atm
13:35:59 <tibbe> dons: I was thinking about releasing it with the current performance
13:36:05 <Cale> That would be something like g g which is different (and not so easy to type ;)
13:36:21 <bbs> lol
13:36:24 <tibbe> dons: and hopefully get some other people hacking on it by setting up mailing lists, easily accessible repo, bug tracker, tutorial, etc
13:36:56 <dons> yes. i think time to get it out.
13:37:28 <Heffalump> Deewiant: thanks, that tells me it's probably 6.6
13:37:28 <tibbe> dons: yes
13:37:55 <tibbe> dons: and we can see if we have time to write a more optimal implementation after, better http parser, epoll, etc
13:38:05 <dons> yep
13:38:07 <tibbe> dons: I've spent some time reading up on web servers at work
13:46:22 <Cale> chrisdone: One way to break up this function and use Maybe would be to have valsoSelma'o, etc. inform their caller as to whether data is available not just by returning an empty list on failure, but by giving Nothing.
13:46:56 <kaol> I want to have a Channel that I'll put an MVar through and put a tuple in it on the receiving end of the Channel - only that the tuple is one that I generate with TH. It's going to have different types, depending on the context... How could I make that MVar generic enough?
13:47:11 <Cale> chrisdone: You could then use fmap instead of your list function, and either use mappend or catMaybes
13:48:24 <mmorrow> kaol: are you going to be generating said tuple at compile time? if so, then generate the code at the other end of the chan at the same time.
13:49:01 <mmorrow> so at run time there will only be a single type of tuple going through, right?
13:49:24 <mmorrow> , everywhere (mkT (+1)) (0,0)
13:49:26 <Cale> kaol: That sounds a bit strange. :) What is it that you're really doing?
13:49:26 <lunabot>  (1,1)
13:49:42 <mmorrow> , everywhere (mkT (+1)) (((0,0),0),(0,(0,0)))
13:49:44 <lunabot>  (((1,1),1),(1,(1,1)))
13:50:20 <mmorrow> those are the two options as i see them
13:50:41 <kaol> it's an intermediate form that I generate XML from or process it as it is
13:51:01 <Cale> kaol: What is the template haskell doing?
13:51:20 <mmorrow> yeah, i'm unclear on that too
13:51:29 <Cale> and are you certain that it must be done at compile time?
13:51:43 <rwbarton> kaol: I don't know what you mean by "generic enough"... is the problem that you need to do type inference between several top-level definitions?
13:52:06 <kaol> I'm using TH for marshalling user's data to the intermediate form and generating XSLT processors for it at compile time
13:53:31 <njbartlett> Anybody compiled Yhc for Intel Mac OSX?
13:54:17 <mmorrow> kaol: if you're doing it at compile time, then you shouldn't have any problems, since you can generate arbitrary code
13:54:30 <Cale> (it's just annoying to do ;)
13:54:43 <Cale> TH is usually more trouble than it's worth, unfortunately.
13:55:20 <Cale> (there are some cases where it saves you trouble, but they seem to be more rare than one might think)
13:56:18 <rwbarton> Cale: Data.Derive saves me trouble.
13:56:25 <rwbarton> Cale: It might not have saved its authors trouble, though :)
13:56:43 <mmorrow> i think it's most useful when you are generating massive amounts of derived code based on input code
13:56:46 <kaol> the receiving end of my Chan caches and possibly generates the XML, but if I try to use a single type of MVar to query it, it's going to constrain needlessly the types that I can get through it
13:57:00 <Cale> I've actually never used Data.Derive
13:57:00 <ddarius> What kind of operations would you guys like for a color manipulation library?  E.g. things like rgb->hsl conversion and also basic operations like saturating addition, but not "global" things like equalization.
13:57:20 <kaol> perhaps I'll just make one big tuple that has all the possible types of tuples as its members and leave the ones I'm not interested in as undefined
13:58:15 <mmorrow> kaol: Data.Generics sounds more appropriate for the tuple (if you /must/ use tuples) issue
13:58:57 <Cale> kaol: Are you designing a library or a program?
13:59:03 <kaol> a library
13:59:07 <Cale> okay.
13:59:24 <mmorrow> ddarius: nice
13:59:30 <kaol> if I could splice in types, I could just make a data type as usual for this and pattern match on it
14:00:45 <Cale> kaol: hmm... there isn't some typeclass of operations you could design to capture all the operations that are needed on data before your library will be able to do whatever work it's doing with them?
14:01:46 <kaol> hmm... I should look into that.
14:02:00 <bbs> i'm trying to write a function to go through a list and delineate if all elements are true
14:02:05 <bbs> andAll lis = map (&&) lis
14:02:15 <bbs> using a higher function -- this doesn't work -- do i have to define a map?
14:02:28 <Cale> Perhaps it's not universal, but it seems to me that any library function which takes an arbitrary piece of data and does something with it can only need finitely many operations on that data, and hence doesn't actually need to know the full type of the thing, only a finite collection of the operations it supports.
14:02:44 <Cale> (which is precisely captured by typeclasses)
14:02:46 <rwbarton> bbs: Take a look at foldr
14:03:06 <mmorrow> rwbarton: totally. sometimes certain TH code is a bitch to write, but once written, pays for itself a million times over.
14:03:12 <bbs> rwbarton: will do
14:03:17 <Beelsebob> > all id [True, False, True, True]
14:03:18 <lambdabot>   False
14:03:27 <Beelsebob> > all id [True, True, True, True]
14:03:28 <lambdabot>   True
14:03:31 <bbs> rwbarton: great ides
14:03:33 <Cale> > and [True, False, True, True]
14:03:35 <lambdabot>   False
14:03:38 <Cale> hehe :)
14:03:38 <rwbarton> bbs: also, you can look at the source for the library function 'and' :)
14:03:42 <Beelsebob> > all (>5) [6,7,8,9,10]
14:03:43 <lambdabot>   True
14:03:50 <Beelsebob> bbs: that answer your question?
14:03:50 <bbs> rwbarton: lol thats cheating
14:03:53 <bbs> i want to understand it
14:03:58 <bbs> Cale: whats the link to ur wiki again
14:04:02 <Cale> bbs: Do you know about foldr?
14:04:04 <bbs> it had some _super_ useful stuff in there
14:04:06 <Cale> cale.yi.org
14:04:09 <bbs> kk
14:04:09 <bbs> thx
14:04:18 <Cale> bbs: I'll describe foldr if you'd like :)
14:04:41 <Beelsebob> > foldr f z [a,b,c]
14:04:42 <lambdabot>   f a (f b (f c z))
14:04:48 <Beelsebob> that should about answer it
14:05:06 <mmorrow> @src and
14:05:06 <lambdabot> and   =  foldr (&&) True
14:05:11 <Cale> Basically, foldr f z replaces each (:) in a list with f, and the [] at the end with z
14:05:16 <mmorrow> sry
14:05:58 <Cale> So if we have something like  True : (False : (True : []))
14:06:06 <bbs> yea
14:06:10 <bbs> hmm
14:06:12 <Cale> and we replace each : with &&
14:06:17 <Cale> and then [] with True
14:06:26 <mmorrow> (&&,True),(||,False),(+,0),(*,1),(++,[]),(mempty,mappend),(mzero,mplus)
14:06:36 <Cale> We get  True && (False && (True && True))
14:06:58 <bbs> Cale: so cons goes away and puts &&
14:07:01 <bbs> and then put
14:07:02 <Cale> yeah
14:07:05 <Beelsebob> mmorrow: surely you want mappend and mempty; and mzero and mplus the other way round there
14:07:11 <bbs> so i can do something like head lis tail list with a fold
14:07:14 <bbs> r
14:07:18 <Cale> hmm
14:07:25 <mmorrow> Beelsebob: hehe, yeah
14:08:07 <Cale> > foldr (:) [] [1,2,3,4]
14:08:09 <lambdabot>   [1,2,3,4]
14:08:15 <Cale> > foldr (+) 0 [1,2,3,4]
14:08:16 <lambdabot>   10
14:08:21 <Cale> > foldr (*) 1 [1,2,3,4]
14:08:22 <lambdabot>   24
14:08:30 <bbs> Cale: wait wait wait
14:08:31 <bbs> so like
14:08:34 <bbs> foldr (&&) True
14:08:38 <bbs> lololol
14:08:39 <mmorrow> exactly
14:08:49 <Cale> yes
14:08:53 <Beelsebob> > foldr (&&) True [True,True,True,True]
14:08:54 <lambdabot>   True
14:08:59 <Beelsebob> > foldr (&&) True [True,True,True,False]
14:09:00 <lambdabot>   False
14:09:10 <bbs> andAll lis = foldr (&&) True lis
14:09:14 <bbs> does that make sense then?
14:09:16 <olsner> @src and
14:09:16 <lambdabot> and   =  foldr (&&) True
14:09:16 <Cale> yes
14:09:17 <Deewiant> > foldr (&&) True (repeat False)
14:09:17 <bbs> or can i just skip lis
14:09:18 <lambdabot>   False
14:09:23 <Cale> or even with the 'lis' deleted
14:09:27 <Beelsebob> bbs: you can miss out lis, yes
14:09:27 <mmorrow> @src or
14:09:28 <lambdabot> or    =  foldr (||) False
14:09:31 <Cale> andAll = foldr (&&) True
14:09:32 <mmorrow> @src sum
14:09:32 <lambdabot> sum = foldl (+) 0
14:09:32 <bbs> Cale: because it just does it under the hood with the input
14:09:35 <bbs> instead of cons
14:09:47 <Beelsebob> @src product
14:09:47 <lambdabot> product = foldl (*) 1
14:09:59 <Deewiant> @src concat
14:10:00 <lambdabot> concat = foldr (++) []
14:10:05 <Deewiant> @src reverse
14:10:05 <lambdabot> reverse = foldl (flip (:)) []
14:10:08 <Beelsebob> @src msum
14:10:08 <lambdabot> msum =  foldr mplus mzero
14:10:16 <mmorrow> @src mconcat
14:10:16 <lambdabot> Source not found. Where did you learn to type?
14:10:23 <Beelsebob> bbs: you may note, this is a useful function :D
14:10:26 <mmorrow> foldr mappend mempty
14:10:28 <Deewiant> @src sequence
14:10:28 <lambdabot> sequence []     = return []
14:10:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:10:28 <lambdabot> --OR
14:10:30 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:10:35 <bbs> Beelsebob: its kinda useful i would say
14:10:38 <bbs> Cale: great explaination btw
14:10:39 <bbs> thx
14:10:42 <TSC> @tell ivanm I had to add "import Distribution.Configuration" to Main.hs to make SourceGraph compile; is that expected?
14:10:42 <lambdabot> Consider it noted.
14:11:03 <Cale> bbs: another way to see how foldr arises is to write enough functions like:
14:11:06 <Cale> sum [] = 0
14:11:09 <Cale> sum (x:xs) = x + sum xs
14:11:14 <Cale> product [] = 1
14:11:21 <Cale> product (x:xs) = x * product xs
14:11:29 <Cale> concat [] = []
14:11:37 <Cale> concat (x:xs) = x ++ concat xs
14:11:39 <Cale> and so on :)
14:11:45 <Beelsebob> and [] = True
14:11:45 <Beelsebob> and (x:xs) = x && and xs
14:11:51 <Cale> and eventually you get tired of writing out that pattern over and over
14:11:53 <bbs> yea
14:11:57 <bbs> i found that out the hard way
14:12:01 <Cale> and so you write:
14:12:05 <Cale> foldr f z [] = z
14:12:05 <bbs> Cale: ^ when i had to write all of those function w/o this
14:12:13 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
14:12:13 <bbs> yea :/ -- he likes to make us struggle
14:13:01 <bbs> Cale: weird!
14:13:06 <bbs> doesn't work without lis
14:13:08 <mmorrow> the hard way is the only way it's possible to ffully ind out anything ;)
14:13:13 <bbs> andAll lis = foldr (&&) True
14:13:15 <mmorrow> *fully find
14:13:16 <bbs> ^ fails
14:13:17 <Baughn> Is there a "type families for dummies" thing anywhere? That is, something that explains them for someone who doesn't know much about non-haskell98 types at all?
14:13:19 <Beelsebob> bbs: you have to remove it from the left hand side too
14:13:23 <Cale> bbs: get rid of the other lis
14:13:23 <bbs> andAll lis = foldr (&&) True lis <-- works
14:13:27 <bbs> ahh
14:13:28 <bbs> duh
14:13:30 <bbs> sry
14:17:59 <pcc1> DrIFT doesn't recognise record types :(
14:19:05 <Kalianyia> paste bin isnt working for me atm - how do i recombine (x:xs) into a list to pass is as it as an argument recursively?
14:19:06 <Kalianyia> setUnion :: [Integer] -> [Integer] -> [Integer]
14:19:06 <Kalianyia> setUnion [] a = a
14:19:06 <Kalianyia> setUnion a [] = a
14:19:06 <Kalianyia> setUnion (x:xs) (y:ys)
14:19:07 <Kalianyia> 	| x < y = x:(setUnion xs (y:ys))
14:19:09 <Kalianyia> 	| x > y = y:(setUnion (x:xs) ys)
14:19:11 <Kalianyia> 	otherwise x:(setUnion xs ys)
14:19:13 <mmorrow> pccl: Data.Derive seems to have more support for record types thab non, so maybe it would be useful
14:20:18 <heatsink> Kalianyia: looks correct to me.
14:20:34 <rwbarton> just needs a | before otherwise
14:20:49 <heatsink> and a = after otherwise
14:20:58 <pcc1> mmorrow: unfortunately it doesn't seem to support haskell2xml, which is what I need
14:21:07 <mmorrow> ah dang
14:21:22 <Kalianyia> hmmm ok maybe my haskell eclipse plugin is complainning over nothing - thanks
14:21:41 <mmorrow> you can drop some parens also
14:21:53 <mmorrow>  | x < y = x : setUnion xs (y:ys)
14:22:48 <sbahra> Hi Cale
14:22:59 <sbahra> Cale, could you add ##FreeBSD to the lambdabot channel list?
14:23:46 <rwbarton> You know, soon when people ask about well-known programs written in Haskell, lambdabot will be up there :)
14:23:47 <Cale> sure
14:23:57 <Cale> sbahra: permanently?
14:24:09 <sbahra> Yes
14:24:35 <Cale> lambdabot: @join ##FreeBSD
14:24:46 <Cale> I've added it to the online.rc, so it should be there
14:24:55 <Cale> (if lambdabot gets restarted)
14:25:10 <sbahra> Cool, thanks.
14:25:17 <mauke> s/if/when/ :/
14:25:40 <bbs> Cale: i'm a freebsd user too :)
14:25:56 <Cale> I'm not though :)
14:26:15 <Cale> (I'm a Debian/Ubuntu user.)
14:26:24 <mmorrow> bbs: i think you meant s/Cale/sbahra/
14:26:40 <sbahra> Cale.
14:26:47 <sbahra> How come cabal isn't provided as a package in Ubuntu?
14:26:50 <bbs> mmorrow: no i didn't
14:26:57 <mmorrow> bbs: oops :)
14:27:08 <Cale> sbahra: I don't know. I don't even use Ubuntu's package for GHC
14:27:10 <bbs> sbahra: have you ever tried to get a bug looked at ;p
14:27:19 <sbahra> bbs, hm?
14:27:24 <sbahra> Cale, ok.
14:27:34 <sbahra> bbs, what do you mean?
14:27:34 <Cale> sbahra: The generic linux binary provided on the GHC website works fine.
14:27:41 <sbahra> Cale, yes.
14:27:45 <njbartlett> @seen ndm
14:27:45 <lambdabot> I haven't seen ndm.
14:27:49 <bbs> sbahra: i mean -- that i had a few bugs that i reported and they were never looked at
14:27:49 * sbahra was considering creating a FreeBSD port for cabal
14:27:53 <bbs> Xorg bugs ;p
14:27:55 <sbahra> But I'd like to talk to obraun first.
14:27:56 <mauke> preflex: seen ndm
14:27:56 <preflex>  ndm was last seen on #xmonad 38 days, 4 hours, 53 minutes and 43 seconds ago, saying: cool :)
14:27:57 <mmorrow> preflex: seen ndm
14:27:58 <preflex>  ndm was last seen on #xmonad 38 days, 4 hours, 53 minutes and 44 seconds ago, saying: cool :)
14:28:05 <sbahra> bbs, Xorg bugs are Xorg bugs, not FreeBSD bugs.
14:28:11 <mmorrow> mauke: heh, beat me to it
14:28:13 <Cale> Cabal itself is included in the GHC package in Ubuntu though.
14:28:14 <bbs> sbahra: i'm not talking about freebsd
14:28:20 <Cale> But not cabal-install.
14:28:20 <bbs> freebsd is great with bugs
14:28:22 <bbs> :)
14:28:24 <njbartlett> Oh we have a new bot??
14:28:25 * sbahra nods
14:28:30 <Cale> The real question is why cabal-install is not included with GHC.
14:28:31 <bbs> i'm talking about ubuntu
14:28:40 <mmorrow> njbartlett: there has been bot proliferation
14:28:42 <sbahra> bbs, ah.
14:28:46 <bbs> :)
14:28:56 <sbahra> bbs, Ubuntu users scare me, generally. Too many have little value for time :)
14:29:02 <bbs> sbahra: i mean -- for code quality BSD > linux
14:29:03 <mmorrow> njbartlett: skynet approves this
14:29:04 <sbahra> Atleast here in DC, they blabber too much.
14:29:17 <Cale> sbahra: hm?
14:29:20 <bbs> lol
14:29:23 <sbahra> Cale, :-P
14:29:51 <Cale> sbahra: I use Ubuntu because I value my time too much. :)
14:30:07 <bbs> would it be wise to use map to do this : take a list of functions and a value -- and then return a list of results of the applied functions based on the paramenter specified originally
14:30:08 <Cale> sbahra: (to bother setting things up properly by hand)
14:30:13 <sbahra> It's the community here, Cale. A lot of Ubuntu groupies.
14:30:20 <Cale> sbahra: ah
14:30:26 <Cale> bbs: sure
14:30:29 <sbahra> They'll waste a day talking about software they can't comprehend, etc...
14:30:37 <Cale> bbs: map ($ x) fs
14:30:45 <blakmatrix> fredro how did you get administrator privlages, you silly goose
14:30:45 <fredro> you get administrator privlages, you silly goose
14:31:07 <Cale> what?
14:31:08 <mauke> sequence fs x
14:31:35 <Cale> administrator privileges?
14:31:43 <mauke> > sequence [f,g,h] x
14:31:44 <lambdabot>   Add a type signature
14:32:13 <mmorrow> Cale: hehe, some is boThaxxoring
14:32:23 <mmorrow> *someone
14:32:54 <Cale> > sequence [f,g,h] x :: [Expr]
14:32:56 <lambdabot>   [f x,g x,h x]
14:33:06 <blakmatrix> fredro is haxxor?
14:33:07 <fredro> sure
14:33:25 <ddarius> hmm, I'll get to do a 3D Delaunay polyhedralization
14:34:02 <mmorrow> ddarius: heh
14:35:47 <heatsink> @nonsequitur
14:35:47 <lambdabot> Unknown command, try @list
14:37:19 <Cale> @keal
14:37:19 <lambdabot> i need math friendly compiler to compile for jvm or flash
14:37:27 <Cale> @yow
14:37:27 <lambdabot> Don't worry, nobody really LISTENS to lectures in MOSCOW, either! ...
14:37:28 <lambdabot> FRENCH, HISTORY, ADVANCED CALCULUS, COMPUTER PROGRAMMING, BLACK
14:37:28 <lambdabot> STUDIES, SOCIOBIOLOGY! ...  Are there any QUESTIONS??
14:37:39 <mauke> preflex: quote
14:37:39 <preflex>  <mrd> deforestation is killing millions of endangered cons cells
14:39:14 * ddarius wonders if cylerp is a "word"
14:40:05 <olsner> definitely sounds more like a "word" than a word
14:40:30 <ddarius> olsner: In analogy with slerp
14:41:51 <ziman> what's the origin of the term `deforestation'?
14:41:56 <ziman> are there any trees involved?
14:42:07 <Philippa_> ziman: it removes intermediate values, which were at the time (and in general) tree-structured
14:42:28 <ziman> i see, thanks
14:42:40 <Kalianyia> what is a good approach for me to take to debug haskell? I know how to debug other imperative languages - but im pretty new to functional programming and haskell
14:43:31 <Philippa_> Kalianyia: evaluating subexpressions in ghci or hugs is often useful
14:43:37 <ziman> i usually decompose the program into small, simple, easily-debuggable functions and run some sanity tests in ghci
14:43:42 <Philippa_> exactly
14:44:18 <Philippa_> for anything in a monad you can slap a WriterT on top to add printf-like debugging. Or in a pinch, Debug.Trace - though there you're subject to evaluation order weirdness
14:44:38 <Philippa_> finally, there's the ghci debugger that may prove useful
14:44:45 <ddarius> Reading Wadler's paper, it seems like he introduced the term.
14:45:37 * ddarius recommends not writing bugs in the first place.
14:54:30 <bbs> Cale: add_to_all x (y:ys) = (x:y):add_to_all x ys
14:54:35 <bbs> thats the function
14:54:41 <bbs> how would map work with that
14:54:45 <Cale> map (x:)
14:54:59 <Cale> > map (1:) [[2,3,4], [5,6,7]]
14:55:01 <lambdabot>   [[1,2,3,4],[1,5,6,7]]
14:55:20 <mauke> > map (x :) [[2,3,4], [5,6,7]]
14:55:21 <lambdabot>   [[x,2,3,4],[x,5,6,7]]
14:55:33 <mauke> Expr++
14:56:10 <sbahra> ye
14:58:41 <hackage> Uploaded to hackage: lojban 0.2
15:05:04 <jdrake> In Data.HashTable new takes a (key -> key -> Bool) for equality comparison. I am just doing this with strings for keys. Is there a way I do this simply?
15:05:19 <mauke> (==)
15:46:53 <Xenoblitz> @hackage HGL
15:46:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL
15:48:14 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:16 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:20 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:23 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:26 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:29 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:31 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:36 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:39 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:41 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:44 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:46 <bbs> please kick him lol
15:48:47 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:49 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:49 <bbs> or ban him
15:48:52 --- mode: ChanServ set +o Cale
15:48:53 * olu fack you pakair xD fack you pakair xD fack you pakair xD fack you pakair xD
15:48:55 --- mode: Cale set +b *!*@88.227.109.137
15:48:56 <bbs> @ban lambdabot
15:48:57 <lambdabot> Maybe you meant: bf bid brain bug faq map run wn
15:49:00 <bbs> lol
15:49:01 --- kick: olu was kicked by Cale (Cale)
15:49:05 <mmorrow> @brain
15:49:06 <lambdabot> Pinky, I am in considerable pain.
15:49:09 <mmorrow> omfg
15:49:10 --- mode: Cale set -o Cale
15:49:11 <mmorrow> @brain
15:49:11 <lambdabot> I think so, Brain, but we're already naked.
15:49:14 <bbs> Cale: thx
15:49:18 <Cale> np
15:49:21 <mmorrow> @brain
15:49:21 <lambdabot> I think so, Brain, but if they called them 'Sad Meals', kids wouldn't buy them!
15:49:21 <bbs> lol
15:49:26 <bbs> @Pinky
15:49:26 <lambdabot> Unknown command, try @list
15:49:32 <bbs> @pinky
15:49:32 <lambdabot> Maybe you meant: ping pointy
15:49:38 <bbs> aww
15:49:46 <mmorrow> looks like pinky is included in brain
15:49:48 <mmorrow> @brain
15:49:49 <lambdabot> Has it ever occurred to you, Pinklet, that your scarf is
15:49:49 <lambdabot> constricting the bloodflow to your head?
15:50:56 <jdrake> I get a parse error on line 7 of http://hpaste.org/10921?lines=true  where it says demo1.hs:45:7: parse error (possibly incorrect indentation) but I am not sure what it could be. I took this part of the code from 'memory.pdf' showing how to do gtk2hs code.
15:51:17 <mauke> you need to indent it more
15:51:39 <jdrake> How much more?
15:51:50 <mauke> at least one space more
15:52:13 <mauke> (it can't line up with "windowXml" above)
15:52:33 <jdrake> ok, I get that now
15:55:34 <ziman> @pointy stick
15:55:35 <lambdabot> stick
15:56:22 <ziman> @brain make me a sandwich
15:56:22 <lambdabot> I think so, Brain, but I don't think Kaye Ballard's in the union.
16:00:44 <jdrake> Now that I have that parse problem worked out, now I get to deal with the errors. I have never done this before, so I do not explicitly know what is wrong beyond the error. The code: http://hpaste.org/10922?lines=true  The error:  `Hash.HashTable' is not applied to enough type arguments on line 27 (more details at end of paste). Utterly confusing to a simple soul such as I.
16:01:17 <mauke> HashTable is not a complete type
16:01:32 <mauke> if it's anything like Map, it requires a key and value type
16:01:42 <mauke> yep
16:02:02 <jdrake> ok, how do I specify that?
16:02:23 <mauke> which types do you want?
16:02:39 <mauke> in general, Hash.HashTable key value
16:03:09 <jdrake> String and WidgetClass
16:03:19 <jdrake> So the type has to be Hash.HastTable String WidgetClass?
16:03:21 <mauke> ... -> IO (Hash.HashTable String WidgetClass)
16:03:24 <jdrake> ok
16:03:44 <mmorrow> just like   (*) 2 8
16:03:57 <mmorrow> where 2->String, ...
16:04:01 <jdrake> Class `WidgetClass' used as a type
16:04:07 <mmorrow> oh
16:04:23 <mauke> so WidgetClass is not a type
16:04:36 <jdrake> http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-Abstract-Widget.html#t%3AWidgetClass
16:04:40 <lambdabot> Title: Graphics.UI.Gtk.Abstract.Widget, http://tinyurl.com/3paasd
16:04:47 <mmorrow> you maybe can do what you want with something like:
16:05:02 <jdrake> I notice this: toWidget :: WidgetClass o => o -> Widget
16:05:20 <mauke> ah, probably an existential wrapper
16:05:20 <mmorrow> ... -> IO (Hash.HashTable String (forall w. (WidgetClass w) => w))
16:05:34 <mauke> ... -> IO (Hash.HashTable String Widget)
16:05:54 <mmorrow> yeah, wrapping would be the sane thing to do for sure
16:06:28 <mmorrow> newtype Widget = Widget (forall w. (WidgetClass w) => w)
16:06:43 <mauke> that looks wrong
16:07:07 <rwbarton> newtype Widget = forall w. WidgetClass w => Widget w
16:07:10 <mmorrow> i think he wants a /universal/ wrapper so he can actually have widgets of /different types/ in the Hash
16:07:13 <mauke> better
16:07:21 <pcc1> I have "-main-is GenCode.main" in my cmd line but still the linker is looking for Main.main
16:07:28 <jdrake> yes that is correct
16:07:38 <mmorrow> mine is equiv to
16:07:40 <mauke> pcc1: shouldn't that be --main-is?
16:07:50 <rwbarton> But, it sounds like this toWidget thing might be more convenient...
16:07:58 <jdrake> How does this function get away with it? toWidget :: WidgetClass o => o -> Widget
16:07:58 <pcc1> mauke: unrecognised flag
16:08:01 <mauke> :-(
16:08:09 <pcapriotti> how can I find out the point where a "no parse" exception occurred?
16:08:17 <rwbarton> jdrake: It's probably a class method
16:08:25 <mauke> no, it isn't
16:09:06 <rwbarton> hmm, maybe it's just an existential wrapper then
16:09:12 <rwbarton> no source links in the haddock...
16:09:31 <mmorrow> oh, i didn't know thjere /already/ was a Widget type
16:10:25 <dolio> Looks existential.
16:10:35 <jdrake> What is existential?
16:11:14 <jdrake> Is it just 'indicating existence'?
16:11:35 <rwbarton> When you have a value of an existentially quantified type, like Widget here, all you know is there exists *some* type which is an instance of WidgetClass which the value is a member of.
16:11:53 <paczesiowa> dblazakis: I saw your hpaste from few days ago, have you sorted those extensible unions out?
16:12:28 <dblazakis> paczesiowa: i followed the functional pearl and it worked out nicely (for the most part)
16:12:55 <jdrake> newtype Widget = forall w. WidgetClass w => Widget w     demo1.hs:27:17: Not a constructor: `forall'
16:13:09 <mauke> jdrake: er. Widget is already defined for you
16:13:15 <jdrake> ok
16:13:31 <rwbarton> jdrake: You have to turn on some extensions to make that definition yourself
16:14:02 <dblazakis> paczesiowa: why?
16:14:04 <rwbarton> (I wish ghc could give a better error message about this.  Usually it's pretty good about suggesting what extensions to enable)
16:14:32 <jdrake> rwbarton, they might be willing to add in a string "Ask somebody in #haskell about this"
16:15:11 <rwbarton> jdrake: :)
16:15:15 <dolio> Also, you can't use newtype.
16:15:19 <rwbarton> jdrake: This one the compiler should be able to figure out though.
16:15:23 <dolio> You need to use data to make an existential type.
16:15:25 <rwbarton> Oh, oops.
16:15:49 <dolio> If you have ExistentialTypes on it'll tell you that, though.
16:16:32 <jdrake> I have it compiling down to two errors now
16:17:17 <paczesiowa_> damn windows machine pretending to be router:/
16:17:38 <paczesiowa_> dblazakis: just wondernig what were you trying to solve
16:17:40 <rwbarton> Hmm, now that I've installed hugs, emacs haskell-mode is starting that rather than ghci...
16:17:42 <jdrake> paczesiowa, I thought windows machines were cast into the lake of fire
16:18:06 <jdrake> rwbarton, the sin of emacs
16:18:14 <jdrake> Praise Vi!
16:18:25 <paczesiowa_> dblazakis: and wanted to ask if you tried polymorphic variants
16:19:19 <paczesiowa_> jdrake: my regular linux router fried its psu, so until I get new psu, I have to improvise with windows laptop
16:20:38 <rwbarton> Aw, even if I use ∀ instead of forall I get a bad error message
16:20:47 <dblazakis> paczesiowa_: i was following along with the modular interpreters paper and wanted to implement the examples in Haskell
16:20:59 <dblazakis> just as a personal exercise
16:21:18 <paczesiowa_> dblazakis: what paper?
16:21:27 <jdrake> paczesiowa, rough
16:21:48 <dblazakis> http://web.cecs.pdx.edu/~mpj/pubs/modular-interpreters.ps
16:23:06 <mmorrow> shit, i think my idea about the universal widget needs more machinery than just that newtype
16:23:31 <paczesiowa_> dblazakis: looks just like your code, overlapping-instances helped?
16:23:40 <ddarius> type UniversalWidget = exists a. a
16:23:53 <mmorrow> i wanted something like what Quasi/Q does, but it's a slightly different situation http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/src/Language-Haskell-TH-Syntax.html
16:23:54 <dblazakis> i don't think overlapping will work with that example, but i hadn't tried
16:23:55 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/67ddnk
16:24:15 <dblazakis> the functional pearl used a Mu like fixed point for the implementation of the extensible union
16:24:24 <mmorrow> ddarius: yeah, that's easy. but not easy is being able to recover info
16:24:25 <mmorrow> newtype Widget = Widget (forall w. (WidgetClass w) => w)
16:24:45 <mmorrow> class WidgetClass w where
16:24:45 <mmorrow>   wName :: w -> String
16:24:51 <mmorrow> nam :: Widget -> String
16:24:54 <mmorrow> *name
16:25:08 <ddarius> Widget ~ String
16:25:36 <BMeph> So, has anyone played with Greif's Thrist type?
16:25:41 <mmorrow> yeah, it needs some more machinery
16:25:51 <dblazakis> I had something that played with
16:25:57 <mmorrow> (@ddarius)
16:26:09 <eu-prleu-peupeu1> hello people from planet haskell
16:26:25 <dblazakis> BMeph: i also did some type level stuff to get type checking on the thrist interpreter example
16:26:47 <dblazakis> BMeph: and later saw a Epigram pearl that did something similar
16:27:34 <BMeph> dblazakis: That makes sense, considering he used Omega in the code frags.
17:12:03 <jdrake> Yet another typing problem. http://hpaste.org/10924   castToWindow returns a Window, and all the other castTo functions return their own type. I don't know how to make this definition any better than Widget, because I need something that they each can be.
17:26:02 <paczesiowa> jdrake: isn't that xml type from glade collection of name,widget pairs that you want?
17:26:20 <BMeph> jdrake: Did you mean... http://hpaste.org/10924#a1
17:27:41 <jdrake> BMeph, looks like it, but still has an error: http://hpaste.org/10924#a2
17:27:57 <jdrake> paczesiowa, can you clarify what you mean?
17:28:24 <paczesiowa> jdrake: you want collection of widgets that can be queried by name, right?
17:29:04 <jdrake> paczesiowa, essentially. I am trying to translate what I did in python, and this method was quite useful in python.
17:29:55 * sw17ch excitedly reports that his Haskell based VPN proof-of-concept is working!
17:29:56 <paczesiowa> jdrake: iirc that xml type that you get when you read .glade file is essentially what you need
17:30:00 <dmwit> jdrake: Do you ever use anything but a literal string to do the indexing?
17:30:10 <harrison_partch> clanehin: are you around presently?
17:30:11 <dmwit> jdrake: (Is the string ever the result of a computation?)
17:30:12 <jdrake> dmwit, no
17:30:21 <dmwit> jdrake: Then I suggest creating a new sum type.
17:30:27 <dmwit> This is exactly what they were made for.
17:30:35 <harrison_partch> jdrake: not the jdrake  of the NO mailing list?
17:30:42 <dmwit> err... s/sum/product/
17:30:50 <jdrake> harrison_partch, 'NO' ml?
17:31:04 <harrison_partch> native oberon
17:31:17 <harrison_partch> different i guess
17:31:23 <jdrake> I have never looked into oberon :-)
17:31:46 <harrison_partch> think he  went by jmdrake
17:32:04 <harrison_partch> has clanehin been around?
17:32:33 * sw17ch notes that Oberon is a fantastic beer...
17:32:34 <dmwit> jdrake: http://hpaste.org/10924#a3
17:32:45 <BMeph> @seen clanehin
17:32:46 <lambdabot> clanehin is in #xmonad, #haskell-overflow, #haskell-blah, #haskell, #ghc and #darcs. I don't know when clanehin last spoke.
17:32:55 <mmorrow> sw17ch: rad!
17:32:56 <BMeph> harrison_partch: ^^
17:33:06 <dmwit> jdrake: *something* like that.
17:33:08 <jdrake> dmwit, can you explain this?
17:33:18 <harrison_partch> ^^?
17:33:23 <dmwit> jdrake: Do you grok record syntax?
17:33:30 <syscrash> at
17:33:31 <BMeph> harrison_partch: clanehin is "here," just not *Here*... ;)
17:33:32 <sw17ch> mmorrow, only problem is that i need to do all the interface setup stuff in C :(
17:33:35 <jdrake> dmwit, not yet
17:33:36 <mmorrow> sw17ch: what Binary instances did you end up making over the course of writing it?
17:33:47 <sw17ch> mmorrow, omg... only one i think :)
17:33:51 <sw17ch> the Ethernet Header
17:34:01 <mmorrow> sw17ch: do you think that C can be easily translated to haskell?
17:34:04 <sw17ch> i had two, but the binary instances weren't doing what i expected
17:34:07 <dmwit> jdrake: Okay.  Here's how they work.
17:34:08 <sw17ch> mmorrow, not really
17:34:12 <sw17ch> tons of ioctl's
17:34:13 <mmorrow> sw17ch: dang
17:34:25 <sw17ch> and i haven't seen any ioctl implementations in haskell
17:34:35 <mmorrow> sw17ch: hmmm
17:34:51 <sw17ch> newsham was talking about libdnet a day or two ago, but i don't think it does what i want
17:35:05 <dmwit> jdrake: (data Foo b = Foo { a :: b }) defines a constructor (Foo :: b -> Foo b) and a "destructor" (a :: Foo b -> b).
17:35:10 <dmwit> jdrake: That's about it.
17:35:23 <dmwit> jdrake: It also defines an "update operator", but let's leave that aside for the moment.
17:35:44 <dmwit> jdrake: The destructor has exactly the implementation you might think it has: "a (Foo b) = b".
17:36:00 <dmwit> jdrake: This automates pulling out the nth position of a multi-positional constructor.
17:36:23 <sw17ch> mmorrow, my (non-cabalized) source package is sitting at http://sw17ch.com/code/haskvpn.tar.gz if you're interested
17:36:28 <jdrake> dmwit, I am not entirely sure of constructor/destructor in this context
17:36:29 <sw17ch> and have two computers to try it on :)
17:36:29 <dmwit> jdrake: (And has the advantage of being robust to changes in how many constructor arguments there are/what order they come in.)
17:36:34 <dmwit> jdrake: ok
17:36:36 <sw17ch> (relies on network-bytestring and binary)
17:36:48 <dmwit> jdrake: Let me post some code to hpaste.
17:36:52 <jdrake> ok
17:37:17 <mmorrow> sw17ch: hell yesh, i was just about to ask after i finished browsing $ find /usr/include/ | grep -i ioctl ;)
17:37:32 <sw17ch> mmorrow, it's not fun :\
17:37:36 <sw17ch> very similar to printf
17:37:41 <mmorrow> heh
17:37:53 <cads> friends, I am on windows at the moment and was wondering what you guys would suggest for setting up a unix like environment with the familiar commandline tools
17:38:05 <sw17ch> ...buuutt... i've been hacking at this all day and im going to go play video games for a while :)
17:38:12 <paczesiowa> cads: cygwin
17:38:15 <sw17ch> mmorrow, if you look at it, and find bad stuff, let me know :)
17:38:18 <mmorrow> hehe, nice
17:38:20 <mmorrow> for sure
17:38:49 * sw17ch leaves to go play WarCraft III
17:39:32 <cads> paczesiowa: may I indegrate the windows binaries for GHC into cygwin, or would it be best to build it with the tools available?
17:39:41 <dmwit> jdrake: http://hpaste.org/10925
17:40:04 * BMeph misses the hpaste announcer...
17:40:10 * dmwit too
17:40:38 <jdrake> dmwit, I think I can dig the comparison made
17:40:42 <dmwit> Great!
17:40:43 <dmwit> okay
17:40:56 <dmwit> jdrake: So, the idea is, you want to map a name to a particular type of widget.
17:41:10 <dmwit> jdrake: So let the names be record selectors into a data type that just holds all the widgets.
17:41:10 <jdrake> yes
17:41:21 <dmwit> (At their specific type.)
17:41:43 <dmwit> Since the data type can hold many values, each of a different type, you can hold each widget at its own specific type.
17:41:49 <mmorrow> sweet
17:41:51 <dmwit> ...let me know if that's still confusing.
17:42:03 <mmorrow> data EthernetFrame = EthernetFrame EthernetHeader EthernetPayload EthernetChecksum
17:42:19 <mmorrow> (from sw17ch's haskell vpn)
17:42:41 <mmorrow> http://sw17ch.com/code/haskvpn.tar.gz
17:42:59 <jdrake> dmwit, I think I am ok for now
17:43:36 <mmorrow> hehe
17:43:37 <mmorrow> readNet :: Socket -> IO (EthernetHeader,BS.ByteString)
17:43:47 <mmorrow> writeNet :: Socket -> SockAddr -> (EthernetHeader,BS.ByteString) -> IO ()
17:44:12 <dmwit> jdrake: See my most recent annotation, http://hpaste.org/10924#a4, which matches more closely the intuition I gave in the English above.
17:45:00 <jdrake> dmwit, have you seen how many controls I have? That function would be a pain in the ass to make
17:45:38 <dmwit> But... it's the same amount of work as writing the list "controls" that you started with.
17:45:42 * dmwit blinks
17:46:33 <jdrake> dmwit, I would agree with you, if the mkControls function wasn't there
17:46:40 <dmwit> ah, yes
17:46:47 <dmwit> It's *double* the work.
17:46:50 <dmwit> That is unfortunate.
17:46:59 <dmwit> hum
17:47:26 <jdrake> dmwit, I would love to keep this reader syntax under my hat, but I would love to get a working version of this code I am trying to make with the hash :-)
17:47:36 <jdrake> s/reader/record
17:48:19 <dmwit> jdrake: The problem is that if I tell you how to do exactly what you're asking to do, you'll end up with a pretty useless list.
17:48:20 <mmorrow> anyone know how to create a tap interface so i can test this thing?
17:48:39 <dmwit> In particular, you'll only be able to use functions that work on *all widgets* on any particular element of the list.
17:48:48 <dmwit> (So, no more label-specific functions, for example.)
17:48:53 * mmorrow is sure it's a one-liner that he'll have to spend 20 minutes figuring out what to say
17:49:14 <jdrake> I don't see why I can't have specific functions that satisfy the class more finely
17:50:07 <dmwit> jdrake: In vanilla Haskell, each element of a list has to have the same type.
17:50:26 <jdrake> dmwit, is there any chocolate haskell?
17:50:31 <mmorrow> dmwit: is that like how every nilla wafer in the box is delicious?
17:50:33 <dmwit> jdrake: The list can be polymorphic only in the sense that, once you nail down the type of the first element, the rest of the elements must also have that type.
17:50:44 <dmwit> jdrake: So, they offered later a different thing.
17:50:59 <jdrake> and that being the thing you wanted to show me?
17:51:12 <dmwit> jdrake: What they offer is to let you say, "all of these elements satisfy the interface specified in this class, but you're not allowed to know anything more than that."
17:51:29 <mmorrow> jdrake: you'd use a structure that's made to handle what you want, rather than lists since they're not made for that
17:51:38 <dmwit> right
17:51:48 <dmwit> Say... a record. ;-)
17:51:59 <dmwit> I can't think of any better way, sadly.
17:52:24 <dmwit> Here's what I recommend.
17:53:10 <jdrake> dmwit, I should note that I am just using this as a way of making a HashTable
17:53:22 <mmorrow> so i guess what i'm saying is that you can't translate object oriented methods directly to haskell. you have to do thing in a completely different way
17:53:36 <dmwit> Keep a separate (non-.hs) file that looks like "mainWindow Window castToWindow\nscrollingView ViewPort castToViewPort\n...".
17:53:40 <rwbarton> At least you can abbreviate mkControls obj = Controls (castToWindow obj) (castToViewPort obj) ... as mkControls = Controls <$> castToWindow <*> castToViewPort <*> ...
17:53:51 <dmwit> Then write a sed script that converts that to a Haskell file of the form I showed you.
17:54:01 <dmwit> It kind of sucks, but it will be a lot less work than doing it by hand.
17:54:18 <mmorrow> yeah, generating code (by whatever means) is always ftw
17:54:25 <dmwit> rwbarton: Right, it can be simplified with the Reader monad, as I mentioned there.
17:54:33 <rwbarton> Ah, I see
17:54:40 <dmwit> But jdrake's just learning Haskell (if I understand the situation correctly), so I left that off. =)
17:54:47 <jdrake> dmwit, can you do an example with the reader monad?
17:55:00 <dmwit> rwbarton: Plus, I might argue that the right way to write it would be Controls { mainWindow = castToWindow obj, ... }.
17:55:07 <dmwit> jdrake: Oh, no problem!
17:55:35 <dmwit> jdrake: Conceptually, the Reader monad supplies an "environment" as the last argument to each function in the do block.
17:55:53 <dmwit> > do { x <- (+1); y <- show; return (x, y) } 50
17:55:53 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 51}
17:55:54 <lambdabot> ...
17:56:04 <dmwit> um
17:56:18 <dmwit> > liftM2 (,) (+1) show 50
17:56:20 <lambdabot>   (51,"50")
17:56:37 <dmwit> > do { x <- (+1); y <- show; return (x, y) } $ 50 -- maybe this?
17:56:38 <lambdabot>   (51,"50")
17:56:40 <dmwit> ah
17:56:46 <mmorrow> > let eval vars = runReader (ask >>= \env -> return (map (\v -> lookup v env) vars))) ([("x",4),("y",42)]
17:56:47 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 90}
17:56:47 <lambdabot> ...
17:57:12 <dmwit> jdrake: So, for mkControls, each argument to "Controls" is a function that reads from the "obj" environment.
17:57:22 <mmorrow> > let eval vars = runReader (ask >>= \env -> return (map (\v -> lookup v env) vars)) ([("x",4),("y",42)]
17:57:23 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
17:57:23 <lambdabot>  ...
17:57:31 <mmorrow> > let eval vars = runReader (ask >>= \env -> return (map (\v -> lookup v env) vars)) [("x",4),("y",42)]
17:57:32 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
17:57:32 <lambdabot>  ...
17:57:33 <jdrake> dmwit, I am not sure what that thing you just did does
17:57:35 <mmorrow> grrr
17:57:42 <dmwit> jdrake: So you could write mkControls as "return Controls `ap` castToWindow `ap` castToViewPort `ap` ...".
17:57:59 <dmwit> jdrake: In my example, the environment is 50.
17:58:04 <mmorrow> > let eval vars = runReader (ask >>= \env -> return (map (\v -> lookup v env) vars)) [("x",4),("y",42)] in eval ["x","y","x"]
17:58:05 <lambdabot>   [Just 4,Just 42,Just 4]
17:58:12 <dmwit> jdrake: So the function (+1) acts on 50, and the function show acts on 50.
17:58:17 <dmwit> jdrake: Then we return the result.
17:59:20 <mmorrow> runReaderT (ask >>= \h -> liftIO (hGetLine h) >>= \line -> return (something line)) stdin
17:59:20 <rwbarton> How is the record solution worse?  You have to specify the type of each field, but you're going to have to do that with more pain elsewhere with the list + existentials method.
17:59:40 <rwbarton> And using ap/<*> there's very little typing besides the (field name, field type, cast function) for each field.
17:59:42 <dmwit> rwbarton: It's worse than the Python dynamic typing way.
17:59:55 <rwbarton> dmwit: I disagree :)
18:00:06 <dmwit> rwbarton: Not as safe.  But certainly more long-winded.
18:00:19 <rwbarton> The only additional cost is specifying each field type once
18:00:43 <dmwit> No, the additional cost is having the list of names and conversion functions separated.
18:00:51 <dmwit> (IMO)
18:01:51 <jdrake> dmwit, perhaps you can give me a suggestion here; I need to be able to reference these controls in my event functions. I wanted to have a global HashTable. Using your method, the function method is too difficult.
18:02:06 <rwbarton> (I wasn't following the whole discussion so I don't really know what these "castToWindow" functions are)
18:02:21 <dmwit> rwbarton: http://hpaste.org/10924
18:02:50 <rwbarton> Right, I'm looking at that, but what are they for
18:03:07 <rwbarton> Oh, these are gtk2hs functions...
18:03:10 <dmwit> rwbarton: They convert a (void *) to a (label *).
18:03:10 <dmwit> yep
18:04:25 <dmwit> jdrake: I really think the syntax I give at the bottom is the best Haskell has to offer for this application.
18:04:50 <rwbarton> Hmm, now I'm even more confused
18:04:54 <dmwit> jdrake: As rwbarton said, the extra work is not much -- one type annotation for each element -- though it is unfortunate that you can't keep things together the same way.
18:05:31 <dmwit> jdrake: You can even keep things together in a nice way if you like, but then it's even just a bit more work than just applying Controls.
18:05:43 <rwbarton> This looks like an XY problem except I don't know what either X or Y are :) so I should probably just shut up.
18:06:01 <jdrake> I am not sure if haskell wouldn't just be a really big PITA for this whole thing :-(
18:06:20 <jdrake> rwbarton, I can show you the python code I am trying to make a similar convenience for
18:06:32 <dmwit> (Specifically: the syntax Controls { mainWindow = castToWindow obj, viewPort = castToViewPort obj, ... } would at least let you specify the correspondence between the names and their conversion functions.)
18:06:35 <rwbarton> jdrake: Sure
18:06:48 <dmwit> Alternatively!
18:06:49 <dmwit> Ah!
18:06:53 <dmwit> jdrake: You'll like this.
18:07:01 <dmwit> jdrake: Just drop the data type totally!
18:07:06 <dmwit> jdrake: define functions
18:07:10 <dmwit> mainWindow = castToWindow
18:07:22 <jdrake> rwbarton, http://hpaste.org/10926
18:07:36 <dmwit> jdrake: Then wherever you did a lookup on the string "main_window" in your Python code, just use the function "mainWindow" in Haskell!
18:07:41 <dmwit> man, this is totally what you want
18:07:52 <dmwit> It's less work, and more type-safe.
18:08:03 <jdrake> dmwit, but cast *what* to window...
18:08:11 <jdrake> Have you seen the function I am working with these on?
18:08:14 <dmwit> jdrake: Its argument!
18:08:18 <dmwit> jdrake: Nope, let me take a look...
18:08:42 <jdrake>     window <- Glade.xmlGetWidget windowXml castToWindow "main_window"
18:08:50 <jdrake> That is the generic version
18:08:56 <rwbarton> I think these strings "main_window" etc. are actually in the xml file
18:09:00 <rwbarton> jdrake: is that right?
18:09:03 <jdrake> rwbarton, absolutely
18:09:42 <dmwit> urk, gotta run
18:09:55 <jdrake> dmwit, talk later :p
18:09:56 <dmwit> Sorry... if you're still playing with it in an hour or so, I'll be back.
18:09:58 <dmwit> yep =)
18:21:26 <amoeba_ninja> ello?
18:21:45 <amoeba_ninja> ?
18:21:49 <amoeba_ninja> anyone here?
18:22:16 <dino-> Hello.
18:22:25 <amoeba_ninja> hi
18:22:45 <Cale> hello :)
18:22:53 <Cale> amoeba_ninja: learning Haskell?
18:23:13 <amoeba_ninja> so can haskell do shell script stuff? or bad idea?
18:23:13 <mmorrow> jdrake, dmwit, rwbarton: just exploring the design space: http://hpaste.org/10924#a5
18:23:26 <Cale> amoeba_ninja: It can... there are libraries to help make it simpler
18:23:42 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH
18:23:42 <lambdabot> Title: HackageDB: HSH-1.2.6
18:23:44 <Cale> in particular
18:23:44 <dino-> I do a bit of this as well, for some scripting.
18:23:51 <amoeba_ninja> what name of good lib for this?
18:23:53 <Cale> http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH.html has some examples
18:23:54 <lambdabot> Title: HSH, http://tinyurl.com/5olmj5
18:24:00 <dblazakis> http://nellardo.com/lang/haskell/hash/
18:24:05 <lambdabot> Title: HaSh - The Haskell Shell (Home Page)
18:24:09 <dblazakis> but, to be fair, I've never used this
18:24:12 <dblazakis> just heard about it
18:24:32 <dblazakis> hah, nevermind
18:24:49 <paczesiowa> there's also h4sh
18:24:57 <Cale> h4sh is going in the other direction :)
18:25:06 <dblazakis> "No code has yet been written."
18:25:07 * rwbarton is unable to reason in the presence of unsafeCoerce
18:25:16 <Cale> HSH is a usable and decent library
18:25:20 <Cale> rwbarton: hehe
18:25:48 <chreekat> Hey guys I've got an easy one for you
18:25:57 <mmorrow> rwbarton: heh. that is one of the few ways where it's safe that i know of
18:26:01 <chreekat> The 'yet another haskell ' tutorial says to use the 'data' keyword
18:26:13 <mmorrow> *way _to use it_ that...
18:26:14 <Cale> chreekat: Put the declarations in a file and load that
18:26:23 <Cale> chreekat: (I'm guessing your question :)
18:26:33 <paczesiowa> more like mind reading
18:26:34 <chreekat> Cale: nailed it
18:26:43 <chreekat> Told you ti was easy :)
18:26:53 <paczesiowa> Cale: do me next:>
18:27:10 <Cale> chreekat: Yeah, I generally like to keep an editor window open alongside ghci, and just do :r in ghci whenever I save my file
18:28:17 <rwbarton> mmorrow: You should be able to write this program without unsafeCoerce by moving the forall b. outside the Obj constructor
18:28:31 <Cale> paczesiowa: hehe
18:28:33 <rwbarton> and then getting rid of all the casts
18:28:47 <mmorrow> rwbarton: but the objective was to be able to have a /list/ of Obj String
18:29:05 <rwbarton> I think that would still work
18:29:43 <mmorrow> hmm it may, i may have confused myself. but in general, on the inside is the only way to do certain things
18:29:57 <mmorrow> (like Data.Dynamic type stuff)
18:30:51 <mmorrow> (and those certain things == things that aren't possible in the haskell type system)
18:31:23 <rwbarton> Right.  But ordinary existential types should handle this case
18:31:35 <mmorrow> sweet
18:32:00 * mmorrow checks it out
18:32:25 <chreekat> Can i get readline capabilities in ghcii? I am sorely missing C-p
18:32:34 <nha__> whats the preferred way to update fields in a nested record?
18:32:50 <rwbarton> chreekat: Probably, what OS and what ghc version?
18:33:31 <paczesiowa> chreekat: like in prev command?
18:33:37 <chreekat> cygwin, .. checking version
18:33:48 <chreekat> 6.8.3
18:34:24 <chreekat> paczesiowa: yeah. course i also want M-b and C-a and C-e and all the other goodies
18:34:33 <paczesiowa> chreekat: it works in linux
18:34:43 <paczesiowa> chreekat: maybe rlwrap/rlfe it?
18:34:55 <chreekat> yeah just saw that on google, never heard of it before
18:34:58 <chreekat> i'll check it out
18:36:52 <chreekat> neato
18:37:16 <paczesiowa> which one works?
18:37:22 <chreekat> rlwrap
18:39:09 <paczesiowa> tab completion works with that?
18:39:48 <chreekat> i was just trying that out :-P doesn't work immediately
18:41:50 <chreekat> oh. first off, i just realized i'm using the windows-packaged haskell
18:41:57 <chreekat> *ghc
18:47:24 <idnar> @src FilePath
18:47:25 <lambdabot> type FilePath = String
18:47:55 <idnar> why isn't that a newtype?
18:49:11 <allbery_b> because you'd have to either duplicate or derive all the string ops, plus provide a way to map between strings and filepaths, at which point there's not much reason to mnake it a newtype
18:49:40 <allbery_b> (unless you want to impleemnt something likeperl/ruby taint mode, which woiuld require even more work)
18:50:02 <idnar> you'd only need the string ops that are relevant for paths
18:50:58 <idnar> anyhow, I guess it's not a big deal, I just thought a newtype would make it harder to write incorrect code
18:52:01 <clanehin> BMeph: hey
18:52:36 <clanehin> let me try again
18:52:41 <clanehin> harrison_partch: hey
18:53:05 <BMeph> clanehin: ? Someone else asked for you, I was just pointing the way. :)
18:53:58 <BMeph> clanehin: Specifically, harrison_partch  is the seeker. :)
18:54:13 <clanehin> BMeph: yep, I was just slow on the figure out
19:00:43 <dons> rwbarton: http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=all
19:00:48 <dons> rwbarton++ you rock :)
19:00:50 <lambdabot> Title: fannkuch benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language Be ..., http://tinyurl.com/48zwqp
19:01:11 <harrison_partch> clanehin hey! i was just editing some video.
19:01:30 <harrison_partch> in cinelerra. keyframes. wow.
19:01:45 <harrison_partch> I sent you mail.
19:02:07 <rwbarton> dons: sweet :)
19:02:27 <rwbarton> dons: I noticed there are several parallel benchmarks up on the wiki that haven't shown up in the rankings yet.
19:02:35 <rwbarton> dons: is that because of the Control.Parallel issue?
19:02:59 <clanehin> harrison_partch: did you have a question or just trouble getting your build environment set up?
19:03:14 <dons> rwbarton: which ones?
19:03:19 <dons> they're all there, afaik.
19:03:24 <dons> some not so effective, e.g. binary-trees
19:03:24 <rwbarton> oh let me check again
19:04:59 <harrison_partch> no, i was explaining why i hadn't installed your software yet
19:05:07 <harrison_partch> despite my  interest in it
19:05:22 <rwbarton> hmm.  binary-trees was one of the examples.  Why is Haskell GHC #2 under Interesting alternative programs?
19:05:45 <rwbarton> (I didn't notice it down there before)
19:08:13 <dons> harrison_partch: are you in the wrong channel?
19:08:36 <dons> rwbarton: it requires disabling the garbage collector to get good speedup.
19:08:59 <rwbarton> dons: ah ok
19:09:01 <scodil> garbage collection is overrated anyway
19:09:30 <chreekat> I'm still trying to work through 'yet another haskell tutorial', which keeps giving exercises before explaining all the necessary conceps
19:09:32 <rwbarton> dons: Never mind then, I also didn't take a careful enough look at chameneos.
19:09:41 <harrison_partch> clanehin's web page says that he can be found here. i wanted to meet him. i am interested in developing an experimental 3d renderer. I should say, another one. This time I think I will use Haskell.
19:09:55 <harrison_partch> Are you implying that I am unwelcome here?
19:10:13 <harrison_partch> dons:?
19:10:22 <scodil> harrison_partch: what do you mean by 3d renderer? like ray tracing?
19:10:26 <dons> harrison_partch: you should contact clanehin in a side channel then.
19:10:44 <clanehin> I think he had questions related to roguestar.
19:11:46 <byorgey> chreekat: that sounds annoying =(
19:11:58 <byorgey> chreekat: if you have questions, feel free to ask!
19:12:44 <harrison_partch> scodil: Not ray tracing, or actually, mostly not ray tracing this time. I am thinking of a hybrid polygon renderer with voxel tracing for visibility culling. So the tracing part won't color pixels.
19:12:56 <scodil> so like a game engine then?
19:13:19 <scodil> or fancy-pants scanline, a la pixar?
19:13:49 <harrison_partch> realtime. so more like a game. or second life. i don't consider sl a game exactly.
19:14:03 <clanehin> harrison_partch: I think that would just be a bounding box
19:14:17 <chreekat> byorgey: yeah, thanks. i was about to ask another but i've stopped to catalog previous questions
19:14:26 <chreekat> if possible
19:14:32 <byorgey> sounds good
19:14:35 <clanehin> harrison_partch: and yet I want to do that somewhere around when 32/64 cores becomes commonplace, I think
19:14:38 <harrison_partch> sigh. perhaps you think that i have not written a realtime voxel tracer before.
19:14:58 <harrison_partch> nothing like a bounding box.
19:15:29 <harrison_partch> think of a world of opaque cubes, only some are missing.
19:15:42 <harrison_partch> then the stuff in the voids is polys.
19:16:07 <clanehin> harrison_partch: this is a bit off-topic, lets #haskell-overflow
19:16:12 <harrison_partch> well, we had better start then. did you look at the films?
19:16:24 <harrison_partch> ok. bye everyone sorry.
19:16:36 <scodil> np
19:17:02 <harrison_partch> scodil come to overflow if you like
19:18:11 <ac> are there arbitrary fixed precision numbers in Haskell, or should I just use Integer?
19:18:36 <dblazakis> what's a good idiom for taking a random element from a list?
19:18:37 <BMeph> ac: You mean like... Data.Fixed? ;)
19:20:37 <idnar> @src (<) Maybe
19:20:38 <lambdabot> Source not found. There are some things that I just don't know.
19:21:14 <paczesiowa> :t \list -> (list !!) `fmap` randomIO
19:21:15 <lambdabot> forall a. [a] -> IO a
19:21:23 <idnar> @src Maybe (<)
19:21:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:21:34 <ac> er, I meant Integers
19:21:35 <chreekat> I remember the first question. I still don't understand it though (i.e., given the same problem I'd solve it the same, broken way)
19:22:30 <chreekat> one of the exercizes requires a function that prints the factorials of a list of numbers. My original base case is "print_facts [] = []"
19:22:42 <chreekat> turns out it needs to be "print_facts [] = return ()"
19:23:14 <paczesiowa> separate calculating factorials from printing
19:23:27 <Nafai> Is there an isInfixOf for Strings that is case-insensitive?
19:23:29 <byorgey> chreekat: well, if the function is actually supposed to print something (i.e. have an I/O effect), then the result will need to be an IO action
19:23:42 <byorgey> chreekat: return () is the IO action which does nothing.
19:23:55 <chreekat> byorgey: ah, that explains it
19:23:57 <idnar> Nafai: "isInfixOf `on` map toLower" or something?
19:24:08 <Nafai> idnar: Probably
19:24:10 <byorgey> chreekat: but as paczesiowa suggests, it is probably best to have one function to calculate factorial, and then make another function which just calls it and prints the result
19:24:25 <chreekat> oh, i do
19:24:33 <byorgey> ok, good =)
19:24:41 <idnar> @src on
19:24:41 <lambdabot> (*) `on` f = \x y -> f x * f y
19:24:45 <idnar> I love that definition
19:24:59 <chreekat> print_facts (x:xs) = do { print (factorial x); print_facts xs; } -- don't know if i got the brackets and semicolons right, but you get the idea
19:25:28 <Nafai> idnar: Just wondering if there is something built in, though I can write it myself
19:25:30 <chrisdone> I'm installing “wx” with cabal, big build process. it really concerns me when a build process shows errors but continues anyway... makes you wonder if it's ignorable or will bite you in the ass later
19:25:47 <idnar> Nafai: I don't know of anything, although I'm hardly a guru
19:25:55 <chrisdone> I'll probably have to wait until the end of the build process for it to say “failed”
19:26:03 <paczesiowa> chreekat: separate doing things to list of things from printing:>
19:27:15 <rwbarton> forcing an Integer (say, a*b where a and b are large) should cause the all the libgmp stuff to happen right?
19:27:31 <dblazakis> paczesiowa: how does that limit the integer to the size of the list?
19:29:07 <chreekat> paczesiowa: k
19:29:14 <idnar> chreekat: that's just "mapM_ (factorial . print)" I believe
19:31:11 <paczesiowa> dblazakis: by pure chance
19:33:10 <paczesiowa> :t \list -> (list!!) `fmap` curry randomRIO 0 (length list)
19:33:11 <lambdabot> forall a. [a] -> IO a
19:33:34 <idnar> @type randomRIO
19:33:35 <lambdabot> forall a. (Random a) => (a, a) -> IO a
19:33:45 <chreekat> ok, on to the next problem with the tutorial: it asks me to create a datatype that holds four elements, two each of two types
19:33:55 <byorgey> chreekat: I would write that as  print_facts xs = mapM_ print (map factorial xs)
19:34:04 <idnar> why thu curry?
19:34:12 <paczesiowa> I forgot
19:34:17 <ddarius> byorgey: Why?
19:34:29 <paczesiowa> :t \list -> (list!!) `fmap` randomRIO (0, length list -1)
19:34:31 <lambdabot> forall a. [a] -> IO a
19:34:38 <paczesiowa> that one should work
19:34:51 <byorgey> I'm just showing how to use recursion combinators like map and mapM_ instead of explicit recursion
19:35:07 <dblazakis> paczesiowa: yep, thanks!
19:35:11 <chreekat> but all it has explained is how to create a data type with independent types: "data Pair a b = Pair a b"
19:35:13 <scodil>  there's a very neat way to pick a random element from a linked list, traversing it only once, and only up to the picked element
19:35:18 <dmwit> mapM_ (print . factorial) xs
19:35:32 <scodil> i forget exactly... hard to google for
19:35:33 <ddarius> byorgey: Yes, but the map is unnecessary.
19:36:01 <dmwit> scodil: Yup, you use probability 1/n of replacing your current candidate, where 'n' is the number of nodes you've already looked at.
19:36:03 <ddarius> Except that idnar switched factorial and print, he already demonstrated the most reasonable way.  dmwit has again stated it (correctly)
19:36:13 <byorgey> ddarius: oh, indeed, but I was just taking it one step at a time
19:36:28 <byorgey> I guess I lied a bit, I wouldn't actually write it that way =)
19:36:35 <chrisdone> wow wx built. bravo
19:36:42 <chreekat> p.s. this *is* a tutorial, which means doing things the hard way to learn basics. :) I don't know about mapM_ yet (though i cas easily guess what it is)
19:36:45 <scodil> dmwit: yeah that's it. I remember it was a decision to be made at each element, I just forgot what that decision was :)
19:37:10 <byorgey> chreekat: oh, sure, there's nothing wrong with doing things the hard way the first time =)
19:37:12 <chreekat> although i appreciate learning about it of coure
19:37:17 <idnar> ddarius: argh, whoops; I always compose functions in the wrong order
19:37:17 <byorgey> chreekat: yup
19:37:22 <dmwit> scodil: You can actually generalize pretty easily to choosing 'm' random elements from a linked-list of which you don't know the length ahead of time.
19:38:01 <chreekat> hopefully I can give some useful feedback to the tutorial author, which is why i'm being a stickler for solving exercises only given what has been introduced in the tutorial so far..
19:38:12 <byorgey> chreekat: mapM_ is like map (applies a function to each element of a list), but it then takes a list of actions (i.e. monadic values) and makes it into one action.
19:38:16 <dblazakis> scodil: that's actual a google interview question
19:38:23 <dblazakis> or it was 3 years ago
19:38:27 <ivanm> is there any way I can force the evaluation of all elements in a list?
19:38:30 <byorgey> chreekat: I'm sort of waving my hands but you get the idea.
19:38:35 <chreekat> yeah
19:38:49 <dmwit> ivanm: Take a look at Control.Parallel.Strategies or so.
19:38:54 <scodil> dblazakis: wait didn't you just ask it?
19:39:04 <dmwit> ivanm: If your elements are in the RNF class, then yes. =)
19:39:05 <ivanm> dmwit: even though I'm not doing anything in parallel?
19:39:10 <dmwit> yes
19:39:12 <chreekat> so what about the next question? a data type with four elements, constricted to two of two types
19:39:13 <dblazakis> i asked for a haskell way to grab a random element from a list
19:39:16 <ivanm> RNF?
19:39:36 <dblazakis> the interview question was a general algorithm question
19:39:39 <dmwit> dblazakis: Are you happy with computing the length of the list first?
19:39:41 <paczesiowa> ....normal form
19:39:43 <ivanm> dblazakis: http://osfameron.vox.com/library/post/random-pain-in-haskell.html
19:40:00 <dmwit> dblazakis: If you are, just use randomR and (!!).
19:40:03 <ivanm> dmwit: what's RNF?
19:40:11 <dmwit> Some strong normal form.
19:40:16 <dmwit> I'm not sure what the R is for.
19:40:29 <scodil> ivanm: instance RNF (Foo a) where rnf (Foo a) = seq a Done    or something
19:40:30 <chreekat> best I can figure out from what's been given in the tutorial is that "data Pair a b = ..." says "i'm defining a datatype with two elements of independent types"
19:40:30 <dmwit> reduced, maybe
19:40:40 <ivanm> scodil: hmmm.....
19:40:48 <dmwit> chreekat: That sounds about right.
19:41:07 <ivanm> or would mapping (id $!) do the trick?
19:41:07 <dblazakis> dmwit: for now it's fine, when i was speed i'll move away from lists anyway
19:41:08 <chreekat> but then "data Dbldbl a a b b = ..." is apparently *not* the way to say "i'm defining a datatype with 4 variables with 2 independent types"
19:41:10 <dmwit> chreekat: Well... actually, not quite.
19:41:10 <scodil> ivanm: its an overloaded function to force an entire data structure
19:41:18 <ddarius> The "R" is for "reduce"
19:41:23 <dmwit> chreekat: Right.
19:41:31 <ddarius> The class is NFData
19:41:39 <dmwit> chreekat: So, on the left of the equal signs, you're just binding some type variables.
19:41:51 <dmwit> chreekat: It's the RHS of the equals sign that tells how they're used.
19:42:05 <chreekat> aha that makes sense
19:42:17 <dmwit> chreekat: So, "data Pair a b = ..." says you're defining a type that *depends* on two other types, but doesn't say how it depends on them yet.
19:43:07 <Olathe> Is it common to have a structure like a tree wrapped by something else so that Eq and Ord and so on can be done based on either structure or value ?
19:43:09 <dmwit> I'm actually being a bit loose here, since it isn't required that a and b be actual type variables... they could be type constructors.  (I think?)  But it's not that common.
19:43:14 <rwbarton> Does par ever just decide its first argument is too small to evaluate in parallel?
19:43:21 <dmwit> yes
19:43:29 <ddarius> Olathe: Yes, it is called a wrapper type.
19:43:38 <scodil> rwbarton: how would it know that?
19:43:38 <dmwit> rwbarton: But you can't rely on it to make good decisions.
19:43:46 <rwbarton> scodil: Beats me
19:43:49 <Olathe> dmwit: You can use type constructors in that ?
19:43:57 <rwbarton> dmwit: there's no reallyPar?
19:44:11 <ivanm> scodil: OK, so what function do I use after i've made my data type an instance of NFData?
19:44:28 <scodil> force x = rnf x, i think
19:44:33 <scodil> reduce to normal form
19:44:43 <scodil> there's also "rwhnf" which is just seq and r0 which is just id
19:44:58 <rwbarton> ivanm: You don't actually need the NFData class.  You can write deepSeq = foldr (\x y -> (:) $! x $! y) [], if that's the level of forcing you want
19:45:17 <dmwit> Olathe: Empirically, yes.
19:45:44 <dmwit> rwbarton: par schedules a spark; there's no guarantees that your machine even actually has true concurrency.
19:45:45 <rwbarton> Olathe: e.g. newtype StateT s m a = ...
19:45:46 <ivanm> rwbarton: that will force every element?
19:46:10 <rwbarton> ivanm: It should force the spine of the list and every element of the list, yes.
19:46:32 <chreekat> ok, so what's the syntax for saying "4 args, 1st two of type a, 2nd tw of type b"?
19:46:32 <dons> rwbarton: so which one next.
19:46:44 <rwbarton> dons: I'm looking at pidigits, but I don't have much hope
19:46:48 <dmwit> chreekat: data Quad a b = Quad a a b b
19:46:54 <dons> rwbarton: yeah. hmm.
19:47:04 <dons> rwbarton: some kind of spec eval, where we start racing ahead evaluating things.
19:47:08 <rwbarton> dons: It's pretty intrinsically serial, just seeing whether I can do the multiplies for a given step in parallel
19:47:13 <dons> hmm.
19:47:13 <dmwit> chreekat: or type Quad a b = Pair (Pair a a) (Pair b b) ;-)
19:47:16 <dons> rwbarton: yes.
19:47:18 <rwbarton> dons: That might work too
19:47:31 <ivanm> rwbarton: that doesn't seem to type :s
19:47:36 <ivanm> @type foldr (\x y -> (:) $! x $! y) []
19:47:37 <lambdabot>     Couldn't match expected type `[b] -> [b]'
19:47:37 <lambdabot>            against inferred type `[a]'
19:47:37 <lambdabot>     In the second argument of `foldr', namely `[]'
19:47:40 <byorgey> dmwit: probably less confusing to use different names for the type and data constructor
19:47:46 <dmwit> byorgey: good point
19:47:51 <byorgey> like data Quad a b = MkQuad a a b b
19:47:51 <chreekat> cool, thanks. now let me see if i could have figured that out on my own from the tutorial..
19:47:58 <rwbarton> dons: I tried just par'ing together all the arguments to F, but it decided to perform all the computation in one thread
19:48:11 <dons> rwbarton: hmm. need some pseq/rnf goodness
19:48:11 <chreekat> byorgey: true, but the tutorial does point that out
19:48:12 <rwbarton> dons: even if I increase N to make the multiplications pretty expensive
19:48:17 <chreekat> type vs ctor
19:48:18 <byorgey> chreekat: oh, ok, good
19:48:28 <dons> rwbarton: but that might be a good approach.
19:48:29 <byorgey> that's something that often trips people up when they're first learning
19:49:05 <chreekat> ok thanks! time to go
19:51:18 <dmwit> ?quote
19:51:18 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
19:53:28 <paczesiowa> but what we would code then?
19:53:56 <dmwit> something to materialize cheetos
19:54:49 <paczesiowa> how did you get from porn downloader to cheetos?
19:55:11 <scodil> what? porn and cheetos are like peas and carrots
19:55:31 <dmwit> Man, you never get the munchies after?
19:55:37 <dmwit> What kind of muenster ARE you?
19:55:46 <dmwit> whoops, Freudian slip
19:56:38 <dcoutts> chrisdone: wx still builds using make :-(
19:57:30 <scodil> dcoutts: whats the news with gtk2hs on the mac? Can it use the native Imendio port?
19:57:48 <dcoutts> scodil: I believe so, someone said they tried it
19:57:50 <chrisdone> dcoutts: eek :)
19:57:57 <scodil> rad
19:58:04 <dcoutts> scodil: unfortunately I've no way of testing it
19:58:10 <dcoutts> silly proprietary software
19:58:13 <scodil> yeah me neither actually :)
19:58:41 <scodil> no I take that back I have an ibook in the closet. would take about a day to compile everything on it, tho
19:59:46 <paczesiowa> isn't gtk ugly on macs (I know, like it's pretty anywhere else...)?
19:59:57 <scodil> its just different
19:59:59 <chrisdone> pretty ugly on windows
20:00:08 <dmwit> It's no worse on Macs than anywhere else, it just doesn't fit in harder.
20:00:28 <chrisdone> that's why I'm investigating wx
20:00:34 <dmwit> Mac applications are pretty homogeneous in terms of appearance, so anything different makes them whine.
20:00:37 <paczesiowa> do themes work on mac version?
20:00:40 <chrisdone> at least it looks like it should be on an OS
20:01:31 <ozy`> paczesiowa: you're not supposed to be using a mac
20:01:43 <ozy`> you should be using emacs as your OS
20:01:55 <paczesiowa> I think that qt looks the best on every platform (wx looks bad under kde)
20:02:00 <scodil> chrisdone: you should also check out the qt haskell port. It's not stable but at least its more actively developed than wx. Your more likely to see bugfixes
20:02:33 <paczesiowa> ozy`: emacs is a great editor with crappy os:>
20:02:47 <paczesiowa> ozy`: and not the other way around
20:03:15 <chrisdone> scodil: cool =)
20:03:35 <scodil> paczesiowa: doesn't wx use gtk on linux?
20:03:58 <paczesiowa> scodil: yes and that's why it looks bad under kde
20:04:21 <scodil> I thought the whole qt/gtk theme consistency issue was solved like 5 years ago
20:04:25 <chrisdone> paczesiowa: PROTIP: use XMonad
20:04:30 <scodil> I used to run kde and I never had a problem with it
20:04:47 <chrisdone> scodil: I guess you have to get a matching theme?
20:04:56 <paczesiowa> scodil: if you like qtcurve then yes, it's solved
20:05:14 <jdrake> Can anyone agree with this statement? "It is better to rely on the human programmer to compensate for unintended states, than it is for the computer [language/compiler] to do so."
20:05:49 <paczesiowa> there are themes for gtk that emulate qt theme but last time I checked they can't even make regular scrollbars behave like native ones
20:06:04 <dons> no, since humans are more fallible. they forget things with the slightest disruption.
20:06:48 <paczesiowa> Attention Deficit Lets go Ride Bikes
20:07:54 <scodil> paczesiowa: so then, qt looks the best on every platform except gnome :)
20:08:28 <paczesiowa> scodil: there is theme for qt that emulates gtk theme. it is developed by trolltech
20:09:04 <scodil> which one is that? clearlooks?
20:09:29 <ivanm> paczesiowa: oh? I know there's a gtk engine to make it emulate the current qt theme...
20:09:31 <chrisdone> kde and gnome have things I wish were merged together into one
20:09:41 <ivanm> scodil: and gnome isn't a platform :p
20:09:59 * ivanm likes kde apps, but prefers the look of gtk+ to qt
20:10:22 <scodil> ivanm: paczesiowa referred to kde as a platofrm, so gnome is too, and I kind of agree with him. Also, the gtk engine doesn't eumlate qt, it actually uses it
20:10:33 <paczesiowa> ivanm: that's what I'm talking about
20:10:42 <paczesiowa> http://labs.trolltech.com/page/Projects/Styles/GtkStyle
20:10:45 <lambdabot> Title: Qt Labs - Projects/Styles/GtkStyle
20:10:47 <ivanm> paczesiowa: ahhh
20:10:48 <scodil> I thought there was something for qt going the other way, but I guess I'm mistaken. its just theme copying
20:11:33 <paczesiowa> there are things that work the other way but they aren't developed by some company and from my tests they are of poor quality
20:11:53 <paczesiowa> at least qt4 ones, qt3 were better (depending on app)
20:14:12 * scodil is satisfied if all the fonts are anti-aliased. stopped caring about anything beyond that. 
20:15:38 * sw17ch yawns
20:16:02 <dblazakis> :t insertWith (:)
20:16:03 <lambdabot> Not in scope: `insertWith'
20:16:14 <dblazakis> :t Map.insertWith (:)
20:16:15 <lambdabot> Couldn't find qualified module.
20:16:21 <chrisdone> :t Data.Map.insertWith (:)
20:16:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
20:16:23 <lambdabot>       Expected type: a -> a -> a
20:16:23 <lambdabot>       Inferred type: a -> [a] -> [a]
20:16:33 <chrisdone> :t Data.Map.insertWith (const (:))
20:16:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
20:16:34 <lambdabot>     Probable cause: `const' is applied to too few arguments
20:16:34 <lambdabot>     In the first argument of `M.insertWith', namely `(const (:))'
20:16:58 <chrisdone> neeeeds moooore (unwords . words)
20:17:13 <scodil> :t Data.Map.insertWith (0:)
20:17:14 <lambdabot>     Couldn't match expected type `[t] -> [t]'
20:17:14 <lambdabot>            against inferred type `[t]'
20:17:14 <lambdabot>     Probable cause: `:' is applied to too many arguments
20:17:23 <chrisdone> :t Data.Map.insertWith
20:17:24 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
20:17:25 <dblazakis> a->a->a
20:17:52 <chrisdone> :t (:)
20:17:53 <lambdabot> forall a. a -> [a] -> [a]
20:18:07 <dblazakis> :t Data.Map.insertWith ((:) . head)
20:18:09 <lambdabot> forall a k. (Ord k) => k -> [a] -> M.Map k [a] -> M.Map k [a]
20:18:43 <dblazakis> @src (++)
20:18:43 <lambdabot> []     ++ ys = ys
20:18:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:18:43 <lambdabot> -- OR
20:18:43 <lambdabot> xs ++ ys = foldr (:) ys xs
20:19:24 <chrisdone> =]
20:19:51 * Nafai dives into gtk2hs
20:20:04 <dcoutts> @arr!
20:20:04 <lambdabot> Yo ho ho, and a bottle of rum!
20:20:32 <chrisdone> Real World gtk2hs
20:20:33 <dmwit> Nafai: It can be fun!
20:20:56 <Nafai> I hope so!
20:21:07 <chrisdone> gt2hs irl
20:21:27 <Nafai> Is there a signal that gets called for every keypress in an entry?
20:21:42 <scodil> dcoutts: any plans in the distant future for custom widgets or gobject subclassing? Would it even be possible?
20:22:55 <rwbarton> What does this mean in ghc core?  a_s1rE [ALWAYS Just L] :: Integer
20:23:19 <dcoutts> scodil: sure quite possible to make your widgets an instance of any of the gobject or widget classes
20:23:28 <dcoutts> scodil: though we could make it easier
20:24:09 <dcoutts> rwbarton: first bit is just a name, the last bit is obviously the type, the middle bit is extra analysis
20:24:28 <rwbarton> Yeah, I'm interested in the analysis
20:24:31 <dcoutts> rwbarton: the L is strictness annotation, I'm not sure about the other two
20:24:35 <dmwit> Nafai: onKeyPress ;-)
20:25:53 <scodil> dcoutts: you're talking about implementing a gobject subclass in C, then exporting to Haskell and making an instance of the gtk2hs classes?
20:26:21 <dcoutts> scodil: ah, to make it appear as a subclass on the C side? that's a tad harder
20:26:38 <dcoutts> scodil: making it an instance of the class on the Haskell side is considerably easier
20:26:47 <Nafai> dmwit: Duh :)
20:26:50 <Nafai> dmwit: Thanks
20:27:01 <dmwit> scodil: You can do it all without leaving Haskell; you don't *need* C.
20:27:14 <dmwit> scodil: (Unless of course you need to interop with some C code.)
20:27:38 <Nafai> So is it typical way to write gtk2hs code is to have a type that contains all of your widgets and pass that around?
20:28:25 <dcoutts> Nafai: pretty common yes
20:28:26 <scodil> dcoutts, dmwit: so, if I wanted a custom tree model, would that not have to be implemented in C? Doesn't the Gtk TreeView object want to call C code to access the model?
20:28:54 <dcoutts> scodil: for a custom tree model we have already implemented the C side, you just need to make your type an instance of a class
20:28:56 <Nafai> dcoutts: Is there a more common / better way?
20:29:05 <dcoutts> Nafai: no, that's a fine approach
20:29:16 <Nafai> Cool
20:32:27 <scodil> dcoutts you're referring to ModelView.CustomStore ?
20:32:57 <dejones> in a "case" statement, such as "case x of" can you do, case x of 0..10 -> 1
20:33:03 <dmwit> dejones: no
20:33:05 <dejones> particularly, is the 0..10 allowed?
20:33:07 <dmwit> dejones: But you can do:
20:33:14 <dejones> dmwit: any suggestion to accomplish that?
20:33:20 <dejones> :)
20:33:23 <dmwit> case () of () | x `elem` [0..10] ->
20:33:34 <dmwit> It's kind of gross, but it's the best thing we've got for now.
20:33:40 <dejones> dmwit: ahh.
20:33:40 <scodil> case x of x | 0 <= x && x <= 10 -> 1
20:33:48 <EvilTerran> x `inRange` (0,10)
20:33:52 <scodil> there you go
20:33:57 <dejones> EvilTerran: I like that the best, thanks!
20:34:04 <scodil> :t inRange
20:34:06 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
20:34:07 <dmwit> Right, specify any test you like, of course.
20:34:19 <dmwit> Ew, inRange is backwards.
20:34:20 <dejones> Thanks dmwit, scodil, and EvilTerran
20:34:20 <EvilTerran> ah, meant to be used prefix, not infix
20:34:29 <dcoutts> scodil: right, the custom store
20:34:46 <dejones> :)
20:34:46 <dcoutts> scodil: you'll notice two existing implementations in Haskell
20:35:00 <jdrake> dmwit, Q: Is there any 'non-pain-in-the-ass' method of being able to access some widgets from a gtk event handler? I figure it would involve passing some datastructure to the function. I cannot handle something that requires tedious ordering of types, but I can handle something that is more generic.
20:35:39 <dmwit> I'm not sure what you mean.
20:35:41 <EvilTerran> something that might be useful in some cases when you want "case | ... ->" is that you can use guards on even unparameterised bindings
20:35:50 <dmwit> But you do have to pass a reference to any data you want to use.
20:35:52 <EvilTerran> "let foo | ... = ... | ... = ..."
20:36:10 <rwbarton> EvilTerran: Oh, I never thought of that!
20:36:22 <dmwit> EvilTerran++
20:36:24 <dmwit> very clever
20:36:24 <EvilTerran> yeah, i only thought of it recently :)
20:37:10 <EvilTerran> there's a proposal to add "case | ... -> ... | ... -> ..." as syntax
20:37:22 <scodil> jdrake: a non-scalable way is to just define your handlers in the same scope as the widgets they refer to. i.e.,  do x <- newWidget ; y <- newOtherWidget ; x `onEvent` (\e -> doSomething x y e)
20:37:33 <jdrake> dmwit, in python, this is convenient: http://hpaste.org/10926  The method you showed me earlier required a very tedious thing to make something similar. Is there another way, a haskell way, to allow my events to handle such.
20:37:37 <scodil> but that falls down once functions get to big
20:37:47 <EvilTerran> i like the look of the "case of ... = \x -> case x of ..." one, too
20:37:49 <jdrake> scodil, it would never work for me :-)
20:37:52 <dejones> EvilTerran: should this work: let test x = case x of x `inRange` (0,10) -> 0; _ -> 1; test 5
20:37:53 <dejones> ?
20:38:08 <dejones> I get a pattern error...
20:38:22 <EvilTerran> that's because x `inRange` (0,10) isn't a pattern
20:38:51 <EvilTerran> let test x | inRange (0,10) x = 0 | test _ = 1
20:38:55 <EvilTerran> in test 5
20:39:13 <EvilTerran> er, "let test x | inRange (0,10) x = 0; test _ = 1", rather
20:39:13 <dmwit> jdrake: I'm sorry, I just don't know enough about Glade.  I've never used it.
20:39:41 <scodil> jdrake: you can treat your glade file as a "widget store." It only creates each widget once so when you fetch them out again you get the same widget
20:40:15 <jdrake> dmwit, it doesn't have to be glade specific. Are there any data structures that would hold data that is of different type, but within the same class of types?
20:40:38 <rwbarton> jdrake: Sure, you could just call the appropriate castToFoo function in your handler.
20:41:05 <dejones> EvilTerran: thanks
20:41:06 <dmwit> scodil: Oh, clever.
20:41:13 <rwbarton> jdrake: i.e. Map String Widget
20:41:22 <scodil> forall a. WidgetClass a => Map String a   ... ?
20:41:38 <dmwit> Not quite.
20:43:05 <Nafai> Is there a typical naming convention (all caps, start with caps, etc) for types?
20:43:23 <scodil> whats wrong with that? I'm aware of this heterogeneous lists, but I've never actually used them
20:43:33 <jdrake> Nafai, start with caps
20:44:10 <Nafai> jdrake: Thanks
20:44:16 <chrisdone> :t map read
20:44:17 <lambdabot> forall a. (Read a) => [String] -> [a]
20:44:40 <Nafai> Is there a good style guide somewhere?
20:45:27 <scodil> Nafai: style is enforced by the language pretty much. Types and constructors have to be upper case. functions and variables have to be lower case. Don't use underscores in names, useCamelCase instead. That's pretty much it.
20:45:36 <scodil> although that last one is not a rule
20:45:50 <dmwit> Use layout, not {;}.
20:46:06 <scodil> except when you case out like 50 things
20:46:17 <scodil> for some unfortunate reason
20:46:23 <mauke> write pointless code~
20:47:26 <bbs> lol
20:47:50 <sereven> http://www.haskell.org/haskellwiki/Category:Style has some fun stuff
20:47:51 <lambdabot> Title: Category:Style - HaskellWiki
20:49:28 <jdrake> Looking at this code again: http://hpaste.org/10927  can I do it with just 'Widget' which is defined in the documentation form like http://hpaste.org/10927#a1 I am fully willing to cast stuff if I need to do it like that.
20:50:45 <dmwit> Yes, that is possible.
20:51:02 <dmwit> I'm sorry that you have to cast everywhere.
20:51:13 <Cale> jdrake: sorry, I wasn't there for what you're trying to do? castToWidget?
20:52:23 <jdrake> Cale, I am trying to have a data structure that I can address widgets in by name and pass it to an event handler. The different widgets are of different types, but of the same class (WidgetClass).
20:52:39 <scodil> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:52:41 <lambdabot> http://tinyurl.com/f9umb
20:52:46 <Cale> Yeah, you could cast them all to widgets, if that's how you want to work with them.
20:53:01 <Cale> No need for existential types, since this is already provided.
20:53:17 <scodil> oh right
20:53:21 <jdrake> I will need to be able to cast them using something like castToWindow at some point.
20:53:28 <jdrake> But I am willing to do that if necessary
20:53:37 <Cale> Yeah, that's slightly dangerous of course.
20:53:42 <Cale> But you can do it.
20:53:49 <scodil> that's how its done in C
20:53:53 <Cale> Yeah.
20:54:01 <jdrake> IT would be my preference for the HashTable to store it as the actual type.
20:54:17 <Cale> Oh, you should never use Data.HashTable, unless absolutely forced to, btw.
20:54:23 <rwbarton> jdrake: How about something like this: http://hpaste.org/10927#a2
20:54:28 <jdrake> It looks nice for me cale
20:54:41 <Cale> Data.Map is far nicer, and performs and scales better
20:54:44 <rwbarton> jdrake: and then castToFoo the widget later
20:55:07 <jdrake> rwbarton, looks nice
20:55:16 <chrisdone> ?quote Cale
20:55:16 <lambdabot> Cale says: Types are a bit like the nubs on lego bricks which provide structural integrity while suggesting how the bricks should fit together.
20:55:17 <Cale> Data.HashTable is only in the libraries for historical reasons.
20:56:02 <dmwit> The other thing you could do is typeclass it on its way out of the list, rather than on its way in.
20:56:34 <dmwit> But then you need to make sure that when you use it, there's enough information to pin down its type, since it would use return-type polymorphism.
20:56:57 <rwbarton> jdrake: untested Data.Map version: http://hpaste.org/10927#a3
20:57:01 <dmwit> I don't know, it's a little weird.
20:57:04 <mmorrow> rwbarton: that Obj thing from earlier gave me some ideas which then lead to experimenting which resulted in the realization that the half-formed-in-my-head things i'm trying to do are impossible without dependent types
20:58:01 <mmorrow> so, i've decided to find a way to be able to use dependent types while being able to integrate that code seamlessly with haskell.
20:58:11 <dmwit> Cayenne?
20:58:28 <Cale> forM might look nicer there.
20:58:28 <mmorrow> yes. i'm reading about it more.
20:59:16 <mmorrow> i still have to finish cabalizing it. i'm struggling figuring out how to get cabal to do what i want in the final installation stage
20:59:21 <Cale> oh, but the function needs to change a little
20:59:45 <Cale> (regardless)
20:59:56 <rwbarton> Oh yeah, I screwed that up
21:00:00 <mmorrow> pretty much though, i just need to suck it up and hack it into working
21:00:21 <Cale> It's presently of type  String -> (String, IO Widget), rather than String -> IO (String, Widget)
21:00:29 <rwbarton> yeah
21:00:51 <rwbarton> @hoogle (a, m b) -> m (a, b)
21:00:51 <lambdabot> No results found
21:01:18 <dmwit> ?pl \(a, b) -> fmap ((,) a) b
21:01:18 <lambdabot> uncurry (fmap . (,))
21:01:41 <rwbarton> Hmm, should (,) t be Traversable?
21:01:49 <jdrake> rwbarton, thank you sir
21:02:09 <Cale> rwbarton: yes.
21:02:19 <Cale> (It should be, but is not)
21:02:23 <rwbarton> jdrake: The only problem with this solution is that when you take the widgets out of the Map, you need to castToFoo them to the right type.
21:02:28 <Cale> oh, maybe...
21:03:16 <Cale> nope...
21:03:22 <jdrake> rwbarton, now that would be true if I need to use something that is specific to that type, but not if I can do it with the generalized widget type right?
21:03:31 <rwbarton> jdrake: Yes
21:03:42 <jdrake> Which is fine
21:04:06 <scodil> jdrake: why won't a record of widgets work?
21:04:40 <mmorrow> scodil: hey. how's Vec coming along?
21:04:44 <Cale> jdrake: A common way to build Gtk2Hs applications which avoids multiply casting things like this, is to do the glade loading in one place in main, and do all the appropriate casts there, then declare event handlers in a let-block following that.
21:05:04 <Cale> (where you have access to all the controls everywhere in the interface)
21:05:25 <jdrake> Cale, that is ugly and potentially evil in anything that is large
21:05:45 <jdrake> scodil, the solution from earlier was not using the generalized type and this looks like a decent solution.
21:05:50 <rwbarton> jdrake: So is detecting this kind of type error at runtime
21:06:00 <rwbarton> jdrake: but, maybe not in the same way
21:06:40 <scodil> mmorrow: ok I guess. I haven't done much with it. I started writing a program that writes a library that declares all the vector types and functions, sort of like a poor mans TH. But that effort stalled
21:06:49 <mmorrow> yeah, that's the tradeoff. constant runtime type checking XOR staticly determining everything and erasing all type info
21:06:53 <Cale> Well, you might *still* have such runtime failures anyway, since the glade file might not have the right kind of control to begin with, but that solution at least makes you aware of the problem right off the bat, rather than hitting at some later point.
21:07:08 <mml`> apropos of nothing: i think an accessible web guide to pure functional algorithms would sure be a nice thing to have around.
21:07:39 <Cale> mml`: Yeah. As would be a general tutorial for translating imperative programs into purely functional ones.
21:07:56 <mauke> ... by transforming RealWorld!
21:08:01 <Cale> (Which I know how to do, but I'm not quite sure exactly how to convey in an ideal way)
21:08:05 <dcoutts> jdrake: you really have to cast the widgets all together when you load the .glade file, you can of course pack them into a record and pass them round the program so you don't need to mix the loading with the use
21:08:39 <mmorrow> scodil: dang. i have a TH utility lib that i have to clean up a bit + add a bunch of stuff that's written but elsewhere to. i'll link you when it gets done. i never did send you that TH stuff now that i think of it.
21:08:46 <rwbarton> Cale: just point them at this: http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
21:08:47 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
21:08:59 <Cale> rwbarton: heh
21:09:00 <mmorrow> scodil: any other haskell projects in the works?
21:09:10 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs
21:09:20 <dcoutts> jdrake: it should be equivalent to if you had a big ugly function that manually constructed and packed all the UI and put relevant widgets into a record
21:09:27 <mmorrow> mauke: i /love/ that file
21:09:37 <scodil> mmorrow: you did, I just didn't understand it. I peeked at TH and it seemed like they didn't support a lot of the more advanced features I've grown fond of, so I gave up.
21:10:02 <jdrake> dcoutts, but the record example dmwit had earlier had a big ugly tedious function, and this solution doesn't.
21:10:28 <mauke> :-)
21:10:38 <dcoutts> jdrake: sure loading from a .glade file is great, but you can still pass round a record of widgets
21:10:51 <dcoutts> keeping the .glade file widgets in a map is a bit evil
21:10:51 <ahunter> Can someone simplify the function classify here? http://hpaste.org/10928 ...feels like I should be able to use mplus or something similar here, but I'm a bit lost as to how (lift is{X,Y,Z} into Maybe somehow?)
21:10:53 <mmorrow> scodil: hmm. what sort of "advanced features"?
21:10:55 <Cale> rwbarton: But that article doesn't really describe how to translate things such that they're purely functional.
21:11:02 <dmwit> jdrake: On the other hand, this version pushes type checking much later in the program.
21:11:04 <scodil> mmorrow: fundeps, associated types
21:11:06 <mmorrow> here's code inspired by hell.hs http://code.haskell.org/~morrow/code/haskell/misc/Call.html
21:11:10 <dcoutts> dmwit: right and that's bad
21:11:20 <dmwit> I agree in principle.
21:11:31 <dmwit> But practically speaking... he's right, it is annoying to write that whole damn thing by hand.
21:11:35 <dcoutts> dmwit: the casting should be in the same place as the loading, so the two sets of errors are essentially equivalent
21:11:40 <mmorrow> scodil: oh, /haskell/ advanced features. totally. the TH ast needs to be updated badly.
21:11:43 <Cale> rwbarton: The transformation I'm thinking of is one where you pull all the state into function parameters, and then transform various control structures into calls to higher order functions.
21:11:47 <dmwit> dcoutts: Right.
21:12:00 <dmwit> dcoutts: It's a shame there isn't a glade to Haskell compiler.
21:12:04 <dcoutts> the possibility of the file loading failing and of it having missing widgets or ones of the wrong concrete type
21:12:14 <mauke> see also http://mauke.ath.cx/stuff/c/hell.c and http://mauke.ath.cx/stuff/perl/japh8.pl
21:12:16 <dcoutts> dmwit: no, it's a good thing or people would be tempted to use it :-)
21:12:18 <dmwit> dcoutts: Then everything could be static. =)
21:12:23 <rwbarton> It seems in practice the tediosity (?) of writing that big function gets scattered all over your program and most likely gets larger in total size
21:12:27 <dmwit> dcoutts: Why would that be bad?
21:12:41 <mmorrow> that Call.hs (calling helloworld) works in ghci 6.9, but it segfaults in 6.10 ghci
21:12:44 <rwbarton> TH parsing the glade file?
21:12:46 <dcoutts> dmwit: they would inevitably be tempted to edit the generated code
21:12:53 <Cale> I wonder whether such a thing could be written easily in Template Haskell?
21:12:54 <mmorrow> i'm not cure what changed
21:12:57 <mmorrow> *sure
21:13:01 <jdrake> dcoutts, if you could give me an easy data structure to use that would be in the right type already... I would use it.
21:13:07 <scodil> mmorrow: I've got 90% of what I want currently, using an associated type of a PackedVec class. So if v is an polymorphic, linked list vector, then Packed v is a packed type with {-#UNPACK#-} pragmas (slight misnomer there) and I can define all the operations on the packed type generically, and it all optimizes great.
21:13:14 <dmwit> rwbarton, Cale: Right, it seems like such a great place to use TH.
21:13:20 <dmwit> dcoutts: Well... yeah, maybe.
21:13:24 <paczesiowa_> rwbarton: you want to translate glade to regular haskell? and then write everything in that one function?
21:13:28 <dcoutts> jdrake: the type of the data structure depends on what widgets you have
21:13:44 <dcoutts> jdrake: it's part of the UI code design
21:13:48 <jdrake> dcoutts, all widgets are of WidgetClass membership.
21:14:01 <dcoutts> jdrake: but they're all different types for good reason
21:14:13 <jdrake> dcoutts, to make it a pain in the ass for me
21:14:41 <dcoutts> jdrake: you're used to untyped programs?
21:14:55 <rwbarton> jdrake: You really don't need to call widget-type-specific functions much?  That seems a little surprising
21:14:57 <paczesiowa_> it would be nice to have all those widgets from glade as toplevel values
21:15:00 <jdrake> dcoutts, the source code I am converting is in python
21:15:13 <dcoutts> jdrake: ok, that makes sense then
21:15:54 <jdrake> dcoutts, a person I respect highly is dead against me using haskell for this, I am trying to do it to see for myself if I want to commit to a larger program in haskell or python.
21:16:16 <dcoutts> jdrake: so part of the conversion is to introduce types, and that means making a structure with names for the various widgets and that'd also involve giving them types
21:16:28 <dcoutts> jdrake: but it's only one place, not everywhere
21:16:50 <dcoutts> just a single record type definition (or more if you really want to split them up)
21:17:10 * dmwit notes that in the amount of time spent discussing this problem here, jdrake probably could have gone and written all the code
21:17:17 <mmorrow> scodil: sweet. is any of the code-generating code you were working on in the latest Vec? i'd love to see it. i'm realizing more and more the power that that can give. example use-case: (1) write a mini-sqlite in haskell. (2) the types of columns are determined at compile time (they're whatever haskell types one chooses), then generate all the code related to columns/etc that are parameterized by the column types at compile time.
21:17:21 <dcoutts> right, it's really not that much code
21:17:30 <jdrake> dmwit, it wouldn't compile and I would be back here
21:17:35 <dmwit> =)
21:18:00 <mmorrow> scodil: essentially, you can do something like parameterized modules
21:19:06 <rwbarton> It looks like no one has written TH code for glade... I'm surprised
21:19:32 <dmwit> I wonder if anybody has written any Gtk2Hs app big enough to warrant such a thing.
21:19:40 <scodil> mmorrow: yeah this is sort of "by hand" though. You would have to run a program, say "generateModule -type SomeType -otheroption foo" and that would spit out ModuleSomeType.hs
21:19:44 <jdrake> dmwit,  just wait :-)
21:19:55 <scodil> lets so how far this gets in hpaste...
21:20:01 <paczesiowa_> glade itself isn't that complicated, wouldn't be too hard to rewrite it
21:20:34 <mmorrow> scodil: cool. yeah, since TH can't create modules, that part would need to be by hand anyway. then you just insert some TH code that writes that file in a runIO or something
21:20:47 <scodil> http://hpaste.org/10929
21:20:57 <scodil> its pretty nasty, actually
21:21:03 <scodil> needs some factorization
21:21:39 <mmorrow> scodil: Text.PrettyPrint.HughesPJ is a huge time-saver
21:21:53 <schoenfinkel> I was wondering, can someone who uses a mac help me with the wreck I seem to have made installing GHC 6.8.3. GHCi is being very cruel to me in "Terminal"   It must be completely trivial, like all of my problems
21:21:56 <chrisdone> wow, runghc is great for launching wx programs
21:22:20 <jdrake> schoenfinkel, how terrible?
21:22:24 <chrisdone> at least, my first ever wx program =)
21:23:22 <schoenfinkel> i cant move back and forth in the text to make corrections, it reads the little scroll keys as >>D or something
21:23:44 <mmorrow> > let func args stmts = text "function" Text.PrettyPrint.<+> parens (hcat . punctuate comma . fmap text $ args) <> text "{" $+$ nest 2 (vcat . punctuate semi . fmap text $ stmts) $+$ text "}" in func ["x","y"] ["return(x*y)"]
21:23:44 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
21:23:48 <jdrake> schoenfinkel, find something called rlwrap
21:23:50 <mmorrow> um
21:23:53 <scodil> schoenfinkel: that's a readline issue I think
21:23:54 <mauke> missing readline?
21:24:05 <jdrake> http://freshmeat.net/projects/rlwrap/
21:24:05 <mmorrow> > let func args stmts = text "function" Text.PrettyPrint.HughesPJ.<+> parens (hcat . punctuate comma . fmap text $ args) <> text "{" $+$ nest 2 (vcat . punctuate semi . fmap text $ stmts) $+$ text "}" in func ["x","y"] ["return(x*y)"]
21:24:10 <lambdabot> Title: freshmeat.net: Project details for rlwrap
21:24:11 <lambdabot>   function (x,y){
21:24:11 <lambdabot>    return(x*y)
21:24:11 <lambdabot>  }
21:24:15 <schoenfinkel> i see, or maybe it can't find it?  I will study.  thanks
21:24:24 <mmorrow> hmm, semi didn't work
21:24:25 <jdrake> apple doesn't ship readline because its gpl
21:24:40 <mmorrow> > let func args stmts = text "function" Text.PrettyPrint.HughesPJ.<+> parens (hcat . punctuate comma . fmap text $ args) <> text "{" $+$ nest 2 (vcat . fmap (<>semi) . fmap text $ stmts) $+$ text "}" in func ["x","y"] ["return(x*y)"]
21:24:42 <lambdabot>   function (x,y){
21:24:42 <lambdabot>    return(x*y);
21:24:42 <lambdabot>  }
21:26:12 <jdrake> Where does <$> come from?
21:26:16 <scodil> the fed!
21:26:25 <paczesiowa> Applicative
21:26:53 <rwbarton> @src (<$>)
21:26:53 <lambdabot> f <$> a = fmap f a
21:27:00 <mauke> @index (<$>)
21:27:00 <lambdabot> bzzt
21:27:01 <jdrake> demo1.hs:23:46: Not in scope: `<$>'
21:27:11 <mauke> @hoogle <$>
21:27:11 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
21:27:41 <scodil> mmorrow: yeah I like this way of doing it, but I've already got something working, and it hasn't proven to be a bottle neck for me yet, so I haven't bothered to re-write it this way just for the sake of speed
21:27:52 <scodil> er, and error message readability
21:28:06 <mmorrow> scodil: sweet (just ran it)
21:28:46 <jdrake> rwbarton, errors   http://hpaste.org/10927#a4
21:29:11 <jdrake> I am not entirely sure what the code does (with stuff like monads involved)
21:29:32 <rwbarton> jdrake: Yeah, Cale and I mentioned that before, you could write \x -> (,) x <$> Glade.xmlWidget.... in my (some would say obfuscated style)
21:29:55 <rwbarton> jdrake: or \x -> do widget <- Glade.xmlWidget... \n return (x, widget)
21:30:09 <jdrake> clarity is golden
21:30:24 <mauke> s/\\n/;/
21:30:43 <jdrake> rwbarton, if you were to call that function something (\x) what would it be?
21:30:47 <scodil> mmorrow: yeah so map, fold and zipWith get me most of basic linear algebra, some odds and ends missing like Storable. I don't yet know how to deal with functions that are recursive (inductive?) w.r.t. the dimensionality of the vector, like determinants and gaussian elimination. Those are easier to do with lists. Since this was for speed I'd probably just drop to C
21:30:49 <jdrake> I am farming it out for clarity.
21:30:54 <mmorrow> scodil: nice. i think this method though would be useful in general for being able to "write" code that's both completely general type-wise (chosen at compile-time) /and/ still have fast code with the then specialized type. it'll cut down on dev time hugely i think.
21:31:03 <Cale> jdrake: it's the body of a forM loop
21:31:13 <Cale> forM controls $ \x -> do ...
21:31:26 <Cale> So, it's not really something you'd normally give a name to.
21:31:48 <mmorrow> scodil: a library for this would be awesome. i'm working toward this.
21:32:12 <mauke> for (i = 0; i < n; ++i) theBody: { ... }  // valid C code
21:32:39 <jdrake> mauke, evil C code
21:32:41 <mauke> I should start doing that
21:33:38 <mmorrow> scodil: hmm. those are interesting problems. i'm not sure how to solve that otoh, but i think the solution to those issues would be applicable to that general situation which'd probably come up a lot. i'm gonna think about that.
21:33:39 <rwbarton> jdrake: you can also write that \ expression as  (return &&& Glade.xmlGetWidget xml castToWidget)  using &&& from Control.Arrow
21:34:16 <scodil> mmorrow: I'm pretty happy with using an associated type and some SpecializeIt class. Define a generic structure, say [a], then a specialized version, say "data IntList = ICons {-#UNPACK#-} !Int IntList | INil", then have a class, with methods like specialize / unspecialize. Then you can define stuff with the generic type, and GHC will mostly take care of the rest.
21:34:27 <rwbarton> jdrake: it's just trying to build some pairs to pass to M.fromList.
21:34:55 <dons> scodil: have you done this in practice?
21:35:09 <scodil> yeah I did this in my vector library, its on hackage
21:35:11 <scodil> works great
21:35:12 * dons thinks using associated types for this is ... awesome. good thinking.
21:35:14 <Cale> jdrake: the translation of  for (i = 0; i <= n; i++) { ... } into monadic Haskell code looks like  forM [0..n] $ \i -> do { ... }
21:35:16 <jdrake> rwbarton, how is this? http://hpaste.org/10927#a5
21:35:31 <dons> scodil: yes, hmm. working around the lack of specialisation.  a new strict, unboxed list class.
21:35:51 <Cale> (forM is just the same thing as mapM with its parameters flipped)
21:36:27 <mmorrow> scodil: hmm, if the code minimally (preferably not at all) mentions the specialized type explicitly, then it seems like you could just generate the type you happen to want for that binary at compile time, along with the appropriate class instance(s).
21:36:28 <scodil> dons: yeah, then you declare a function "mapI f = specialize . map f . unspecialize" and it specializes to whatever type of list its declared as, so long as that type is an instance of the class
21:36:29 <rwbarton> jdrake: too many underscores :) but otherwise good
21:36:40 <rwbarton> jdrake: I guess you could call get_widget nameAndWidget, or something
21:36:49 <thoughtpolice> scodil: which package?
21:36:58 <mmorrow> scodil: innntterresting...
21:37:09 <scodil> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Vec
21:37:14 <lambdabot> Title: HackageDB: Vec-0.9.2
21:37:22 <Cale> http://hpaste.org/10927#a6
21:37:42 <mauke> > join (<*) "argh"
21:37:44 <lambdabot>   "aaaarrrrgggghhhh"
21:38:01 <mmorrow> @type (<*)
21:38:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
21:38:22 <Cale> oh, heh, that might not parse quite right...
21:38:36 <jdrake> I also get to figure out how to subclass a widget in haskell
21:39:08 <scodil> dons, mmorrow: I'm not sure it would work for "big" structures like lists though. It works for my things because they are small and are fully inlined everywhere
21:39:21 <dons> scodil: i think this would be doable for lists though.
21:39:34 <dons> it would mean rewriting the list library in terms of an ATs class that provides cons and nil for you type
21:39:37 <mmorrow> scodil: i wrote a super simple pure-haskell fft the other day which you may find interesting/useful http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pure-fft
21:39:38 <lambdabot> Title: HackageDB: pure-fft-0.1.0, http://tinyurl.com/3o8dgp
21:39:52 <dons> much like uvector's approach to generic arrays specialised like mad
21:39:59 <dons> but for lists
21:40:11 <scodil> mmorrow: yeah I saw that, looks awesome. I was going to mentions (convenient that dons is here) that you should re-write it using uvector
21:40:17 <scodil> it would probably scream
21:40:33 <mmorrow> i'd like to eventually add a selection of super-fast haskell ffts to that package
21:40:44 <mmorrow> and other similar transforms as well
21:41:04 <mmorrow> scodil: sweet, yeah. i should do that.
21:41:15 <scodil> it shouldn't be much work, since its very list-like
21:41:26 * mmorrow looks at the uvector haddocks
21:41:31 <scodil> and I noticed a (!!) in there, so you'd get a big speed up at least in that one spot
21:41:54 <Cale> (yeah, you need a paren around the whole second parameter to <$> unfortunately)
21:42:45 <mmorrow> i need to optimize that existing version as well. in particular, it shouldn't need to use (!!) like it does.
21:42:54 <Cale> Heh, or you could write  fmap Map.fromList . forM controls $ \x -> ...
21:43:14 <mmorrow> scodil: heh, i just saw your prev comment
21:43:28 <scodil> dons: if it turns out to work, I think you'd see big dividends in Data.Map too, specializing the key type, getting rid of Ord dictionaries. (Although I've not verified my suspicion that they linger in compiled code.)
21:43:50 <Cale> http://hpaste.org/10927#a7 -- the correction :)
21:44:01 <mmorrow> scodil: if i reorder that part slighlty, i can do it in only on pass over the list
21:44:08 <mmorrow> s/on/one/
21:44:27 <rwbarton> Cale: This is an example where I feel f $ g $ x can be much easier to read than f . g $ x for some reason
21:44:37 <Cale> really?
21:44:38 <Cale> hmm
21:45:14 <scodil> mmorrow: I actually know _nothing_ about fft / dft algorithms. I'm even only vaguely familiar with the Fourier series in general
21:45:31 <scodil> missed out on a lot of that math in a comp. sci. undergrad
21:45:53 <Cale> For me, they're similar, only the latter avoids a certain amount of ambiguity.
21:45:57 <mmorrow> scodil: plot a .wav's freq spectrum in ghci http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=73
21:46:27 <scodil> nice
21:46:33 <rwbarton> @type fmap Data.Map.fromList . forM ?controls
21:46:34 <lambdabot> forall k a a1 (m :: * -> *). (Monad m, ?controls::[a1], Functor m, Ord k) => (a1 -> m (k, a)) -> m (M.Map k a)
21:46:35 <Cale> (not that the former is ambiguous, but you have to know what the associativity of $ is for it to make sense)
21:46:57 <jdrake> What would be the correct way to build a program with gtk2hs (ghc command)?
21:47:11 <jdrake> I get a lot of link errors
21:47:15 <Cale> jdrake: --make is probably the most important commandline option :)
21:48:05 <jdrake> merci. Now, half a mb for what I just did...
21:48:26 <jdrake> Not exactly a tight app
21:48:40 <jdrake> 354k stripped
21:48:42 <Cale> Or else, use cabal, and make sure to include the gtk package.
21:48:46 <ddarius> scodil: Read dspguide.com
21:48:46 <rwbarton> jdrake: Smaller than the Python distribution :)
21:48:53 <Cale> jdrake: There's a large constant term (not factor)
21:49:01 <jdrake> rwbarton, true that
21:49:06 <Cale> jdrake: It statically links against the Haskell runtime.
21:49:12 <ddarius> mmorrow: When it comes to FFTs, super fast means counting assembly instructions.
21:49:24 <jdrake> Cale, can I get it to do it dynamically?
21:49:27 <scodil> ddarius: I think I downloaded this like 2 or 3 years ago, planning to read it but never did :)
21:49:30 <Cale> Not at present.
21:49:45 <ddarius> scodil: It's a very easy read.
21:49:46 <mmorrow> ddarius: that's true. but only needed for truly massive inputs.
21:49:51 <Cale> At some point, you could get it to do it on Mac OS X. I'm not sure if that's still there.
21:50:06 <Cale> It's one of those things which would be nice, but nobody wants enough to implement.
21:50:13 <jdrake> May I presume that it will not increase in size very fast when adding things?
21:50:15 <scodil> ddarius: yeah I skimmed it, enough to know what the Fourier series is, but not enough to really use it.
21:50:18 <Cale> jdrake: right.
21:50:20 <ddarius> mmorrow: No, usually they don't count each instruction for large FFTs since it would take a long time for that.  It's more for -many- FFTs rather than big ones.
21:50:29 <Cale> jdrake: It's just a constant term.
21:50:37 <mmorrow> ddarius, scodil: hmm. i just realized that TH specialization could be put to excellent use for ffts
21:50:41 <jdrake> Cale, fixed cost :p
21:50:44 <Cale> yes.
21:50:47 <ddarius> mmorrow: Look at FFTW
21:51:16 <mmorrow> ddarius: they transform only chunks at a time
21:51:31 <mmorrow> i'm talking about the input data
21:52:28 <mmorrow> ddarius: i will look at that though, as i don't know how any particulars about it :)
21:52:36 <mmorrow> s/how//
21:53:09 <ddarius> I would think the problem is more real-time requirements rather than scale.  In many DSP applications, real-time => fast (though that's not true in general)
21:53:21 <Olathe> s/./o/
21:53:27 <Cale> http://xkcd.com/ -- ahaha
21:53:27 <lambdabot> Title: xkcd - A Webcomic - Depth
21:53:36 <mmorrow> ah, i see. i think when it's that critical, the transform is usually in hardware
21:53:44 <mmorrow> ooh
21:53:58 <ddarius> mmorrow: Somewhat.  There are many, many DSP chips.
21:54:03 <mmorrow> Lava+TH == custom FPGA fft circtuis
21:54:30 <Cale> He misspelled Brian Greene's name though.
21:54:37 <ddarius> A specialized FPGA chip would probably be slower than a "general purpose" DSP chip.
21:54:47 <mmorrow> most definitely.
21:54:55 <mmorrow> but /much/ faster than software :)
21:55:23 <mmorrow> and programmable an a moment's notice
21:55:38 <mmorrow> so if you have a pci fpga, you're golden
21:56:11 <scodil> my pillow calls. night, mmorrow
21:56:18 <mmorrow> scodil: night
21:56:52 <mmorrow> i can't wait until the start putting fpgas on whatever the form factor is that's used for wireless cards in notebook.
21:57:02 <mmorrow> i've got an open slot, and would buy one in a second
21:57:42 <ddarius> mmorrow: Make your own.
21:58:02 <Axman6> what's an FPGA?
21:58:12 <ddarius> field programmable gate array
21:58:12 <Elly> field-programmable gate array
21:58:19 <mmorrow> heh. i wonder if that would be feasible. if so and you know how to go about any part of that, do tell.
21:58:37 <Axman6> right...
21:58:43 <ddarius> mmorrow: There are companies that will make custom chips for you.
21:59:25 <mmorrow> ddarius: ah ok, i gotcha now. hmm. what sort of min quantities do such companies usually require?
22:01:59 <mmorrow> hmm. does anyone know an appropriate google query to even find such companies?
22:02:51 <dmwit> I think there are even a few projects to have an FPGA near the processor.
22:03:01 <mmorrow> ok, now i'm getting some results
22:03:22 <mmorrow> dmwit: sweet. link/any googleable info?
22:03:39 <dmwit> errr... just hearsay from my architecture prof, really.
22:03:47 <ddarius> I believe you can have as low as one, though you'd probably prefer a handful and it probably would be about the same cost.
22:04:35 <mmorrow> oh snap. http://www.customcircuitsolutions.com/
22:04:36 <lambdabot> Title: Custom Circuit Solutions - The FPGA, CPLD, and Prototype Experts
22:06:05 * mmorrow becomes giddy http://www.customcircuitsolutions.com/fim-ep3c5.html
22:06:06 <lambdabot> Title: Custom Circuit Solutions - FPGA Integrated Modules
22:06:18 <mmorrow> "The FPGA Integrated Module (FIM-EP3C5) provides everything needed in a DIP package to quickly utilize the most advanced FPGAs on the market."
22:06:43 <mmorrow> look how small that guy is :)
22:07:21 <mmorrow> zomg, i'm about to order a few
22:09:49 <schoenfinkel> scodil and jdrake, thanks for the readline advice, I think I see what's going on.  The result is that ghc 6.8.3 is busily compiling itself, so ... I'll see what happens in the morning.
22:10:07 <jdrake> np
22:10:33 <mmorrow> schoenfinkel: scodil just quit a bit ago
22:11:09 <BMeph> mmorrow: Xilinx and Altera are the two FPGA mass producers I know of through my work. They have a wide selection, and generally evenly-matched products. :)
22:12:16 <mmorrow> BMeph: i have a Xilinx one already http://www.charmedlabs.com/index.php?page=shop.product_details&category_id=6&flypage=shop.flypage&product_id=17&option=com_virtuemart&Itemid=1
22:12:18 <lambdabot> Title: CharmedLabs - 150K Xport 2.0 with SDRAM Devkit, http://tinyurl.com/3mbcho
22:12:19 <znutar> fpga producers will usually cut sweet deals for students/eval boards too since they want people to get comfortable with their design flow as early and often as possible
22:14:10 <mmorrow> what's the name of the formfactor that notebooks use for their wifi cards?
22:14:28 <mmorrow> (new notebooks ==> the smaller of the two possibilities it could be)
22:14:40 <mmorrow> PCI-Express?
22:14:47 <BMeph> mmorrow: Yeah - my shop uses Altera exclusively - but it's a special-order item we make. :)
22:15:42 <mmorrow> BMeph: holy crap.
22:16:12 <znutar> ExpressCard?
22:17:14 <mmorrow> BMeph: ok. so i want an fpga on a PCI-thesmallone that i can stick in my latop and use from linux at will. how do you suggest i go about this?
22:18:16 <mmorrow> znutar: i think it has a "PCI-" prefix
22:18:18 <BMeph> mmorrow: Why not get a module with a USB port? :)
22:18:19 * mmorrow google
22:18:20 <mmorrow> s
22:18:50 <mmorrow> BMeph: hmm. that'd definitely do i suppose.
22:18:55 <mmorrow> any suggestions?
22:19:03 <BMeph> mmorrow: No, I think znutar got it - "Express Card" seems to be it. :)
22:19:29 <znutar> http://www.picocomputing.com/products/cards.php  this has expresscard/34 and older cardbus form factors
22:19:30 <lambdabot> Title: Pico Computing, Inc - Products
22:19:52 <mmorrow> ah, nice. do you think it'd be very painful to get one/more-but-only-a-few such cards made?
22:19:53 * Nafai scratches his head
22:20:20 <mmorrow> oh. i meant the smaller one
22:20:36 <mmorrow> hmm, wait.
22:20:46 <mmorrow> that's it for sure
22:21:07 <mmorrow> heh, the fact that it's only half as tall as a wifi one threw my sense of scale off
22:21:22 <Nafai> I need some advice.  I've got this code:
22:21:23 <Nafai> http://hpaste.org/10930
22:21:38 <mmorrow> znutar: omg. that's /exactly/ what i'm looking for. thx10 :)
22:22:02 <BMeph> mmorrow: The stuff I work with is all on CCAs with -232 and PPI connectors. Well, with the ports from them, 'cause we straight-wire the boards together. :)
22:22:04 <Nafai> In the entryKeyPressHandler function, I was to update the list that is backing the tree view model
22:22:08 <Nafai> But I'm not sure how to do that
22:22:15 <znutar> no prob.  Googling for expresscard fpga probably shoudl get you a few others too
22:22:58 <mmorrow> oh. the one i thought was oddly shaped wasn't even the formfactor i was looking for.
22:23:04 <BMeph> Nice - Virtex, eh? That's a new one, have to check them out...
22:23:43 <mmorrow> znutar: dang, i've looked a bunch of times and found nothing. probably since i had the formfactor name :p
22:24:03 <mmorrow> *had the _wrong_ formfactor ...
22:24:34 <znutar> yeah, that'd do it
22:24:52 <Nafai> dcoutts: Any advice?
22:27:17 <chrisdone> can a function like map be implemented in λ-calculus?
22:28:14 <chrisdone> wait, unicode prelude?
22:28:49 <chrisdone> hawt
22:28:53 <sjanssen> chrisdone: yes
22:29:47 <dons> can map be written the unicode prelude?
22:30:10 <chrisdone> > ∅
22:30:10 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
22:30:11 <lambdabot>  ...
22:30:17 <dons> , ∅
22:30:21 <lunabot>  luna: Not in scope: `'
22:30:37 <chrisdone> we have no chance to survive, make your time
22:31:02 <mmorrow> znutar: i think that company Pico is one-of-the/the first to offer fpga cards with those formfactors. nothing else comes up (i thought i was crazy for a second there ;).
22:31:04 <chrisdone> do things like
22:31:07 <chrisdone> case foo of
22:31:21 <chrisdone>  bar → ..
22:31:26 <chrisdone> work in any extension?
22:31:27 * mmorrow just emailed Pico's sales
22:32:16 <mmorrow> , let (∅) = [] in (∅)
22:32:19 <lunabot>  []
22:32:27 <rwbarton> chrisdone: yes, -XUnicodeSyntax
22:32:44 <chrisdone> it must be christmas
22:32:50 <chrisdone> :O
22:33:14 <dcoutts> Nafai: are you asking how to modify the list model?
22:33:28 <mmorrow> chrisdone: no, christmas isn't for a few months.
22:33:47 <chrisdone> mmorrow: ·_·
22:33:52 <mmorrow> hehe
22:34:37 <Nafai> dcoutts: Yeah
22:35:04 <dcoutts> Nafai: did you look at the list store api? or take a look at one of the list store demos
22:38:11 <chrisdone> can't find a page about “-XUnicodeSyntax”
22:38:47 <chrisdone> anyone got a link?
22:39:01 <Nafai> dcoutts: Yeah, I'm looking at the list store api right now
22:39:43 * mmorrow starts getting ideas like having a metacircular interp on an fpga which can modify not only its software but its hardware as well...
22:39:54 <Nafai> The problem is getting at the list store, I think
22:40:15 <rwbarton> chrisdone: well, compiler/parser/Lexer.x in the ghc source tree
22:42:01 <dcoutts> Nafai: you have to keep a reference to it
22:42:11 <novas0x2a> uh huh
22:43:06 <dcoutts> Nafai: you tell the view which store to use, but at that point you must not forget which store or you'll be unable to make changes to it later.
22:43:49 <Nafai> dcoutts: So I need to clear everything from the store and then add the new list to it one by one?
22:44:02 <Nafai> (given that I have passed a reference to it around)
22:44:14 <dcoutts> Nafai: you can modify the existing store
22:44:30 <dcoutts> Nafai: no need to delete it and make a new one, it's a mutable store
22:45:18 <jdrake> If I have a structure such as let blah = blah in ...  and ... consists of multiple functions to be called, what is the best way of doing these more than one function call in sequence?
22:46:53 <Axman6> f .g . h .i ... $ blah?
22:47:18 <jdrake> Nafai, does your nick happen to come from a fictional character who wears a starmaster's cloak?
22:48:38 <jdrake> I can say that this is what the code would look like in how I want to do it:  http://hpaste.org/10931   I can't say what is correct to do though :-)
22:49:17 <Saizan> jdrake: those are probably monadic fuctions, so use do-notation
22:49:17 <Nafai> jdrake: Yes indeed
22:49:37 <rwbarton> jdrake: This is probably in a do block.  Delete "in", unindent the following two lines
22:49:48 <jdrake> Saizan, indeed they are
22:50:07 <jdrake> rwbarton, does removing in maintain the function of in?
22:50:20 <Saizan> http://hpaste.org/10931#a1
22:50:25 <jdrake> Nafai, wonderful series, finished the whole series in about 100 hours
22:50:31 <jdrake> Make that 50 :p
22:50:32 <Nafai> Yeah, I really enjoyed it
22:50:47 <rwbarton> jdrake: Well, "let foo = bar" in a do-block brings foo into scope for the entire remainder of that do block
22:51:08 <jdrake> rwbarton, I would like to be able to limit the scope of the item in question
22:51:12 <rwbarton> jdrake: If you don't want window to be in scope after these two lines, you can just add do after the in
22:51:19 <jdrake> ok
22:51:35 <rwbarton> also you'll need to indent those lines a bit more
22:51:39 <jdrake> Nafai, did you happen to have any suggestions for continued reading?
22:52:05 <jdrake> rwbarton, that one thing is annoying ! I like consistent indentation
22:52:15 <rwbarton> You could also replace the do block with  onDelete window deleteEvent >> onDestroy window deleteEvent
22:52:23 <rwbarton> jdrake: consistent indentation for consistent things.
22:52:35 <rwbarton> jdrake: in this case consistent indentation means you're let-ting another variable.
22:52:41 <jdrake> rwbarton, mind I just came from python
22:52:47 <Saizan> rwbarton: if he puts the do on the same line as in he doesn't have to indent further
22:53:12 <Cale> jdrake: It's really consistent alignment which matters
22:53:16 <rwbarton> Oh, yeah. Sorry
22:53:29 <jdrake> What is a multiline comment I can use?
22:53:34 <rwbarton> (I was thinking of a similar situtation)
22:53:35 <Cale> jdrake: all the statements inside a do-block have to start on the same column
22:53:41 <Cale> {- multiline
22:53:45 <Cale>    comment -}
22:53:55 <jdrake> I was trying to use (*, but that must have been pascal
22:54:30 <Cale> Or O'Caml.
22:54:37 <Cale> Or perhaps mathematica?
22:54:59 <rwbarton> Hmm, actually O'Caml syntax is quite reminiscent of Pascal
22:55:05 <rwbarton> I never thought of that
22:55:17 <jdrake> But ugly
22:55:51 <Cale> actually, I think all the ML's use (* *) style comments
22:56:13 * mmorrow orders two http://www.customcircuitsolutions.com/fim-ep3c5.html , emails sales for an FPGA on an Express Card, wgets Lava from hackage
22:56:14 <lambdabot> Title: Custom Circuit Solutions - FPGA Integrated Modules
22:56:30 <Cale> mmorrow: hehe
22:56:46 <Nafai> Hrm
22:56:59 <jdrake> mm_freak, LOVE IT
22:57:05 <Nafai> Actually I don't need a key press handler, I want an "entry changed" signal
22:57:17 <Nafai> jdrake: Not really that I can think of
22:58:07 <jdrake> mmorrow, think that could use the JTAG off of an avr dragon?
23:01:58 * Saizan cries everytime he sees a (unit -> a) type in ML
23:02:03 <mmorrow> jdrake: i'm not familiar enough with JTAG to know. BMeph or znutar may know though.
23:02:42 <jdrake> Is onUpdate controls self = do return ()  valid enough for something that does nothing?
23:03:02 <mmorrow> you don't even need the do
23:03:37 <jdrake> Its an -> IO ()
23:03:45 <mmorrow> yeah
23:04:03 <mmorrow> @type \x y -> return ()
23:04:04 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => t -> t1 -> m ()
23:04:20 <Saizan> do is only useful when you've to compose more monadic actions together
23:04:26 <jdrake> ok
23:06:22 <jdrake> Python would be useful with currying
23:07:48 <mmorrow> heh, after haskell i wish every language had currying
23:08:42 <mmorrow> (and a whole slew of other things too)
23:10:15 <jdrake> Another error...  http://hpaste.org/10932   I can't seem to translate this one
23:10:56 <BMeph> jdrake: About the JTAG question: Yes. :)
23:11:12 <jdrake> BMeph, awesome
23:12:10 <mmorrow> @tell ddarius http://www.cs.chalmers.se/~bjesse/fftpaper.ps.gz
23:12:11 <lambdabot> Consider it noted.
23:12:42 <rwbarton> jdrake: what is onUpdate?
23:13:14 <jdrake> onUpdate controls self = return ()
23:13:52 <rwbarton> I don't know what you're trying to do here; I'm guessing buttonClicked isn't the function you want
23:14:27 <rwbarton> maybe onClicked?
23:15:32 <jdrake> oh you might be right
23:16:15 <rwbarton> (I can't tell from the documentation what that does, but it has a more plausible type)
23:16:45 <jdrake> It assigns an event
23:16:56 <jdrake> But now I get this:  Couldn't match expected type `IO ()'          against inferred type `t -> m ()'
23:17:13 <jdrake> for onClicked (castToButton update) (onUpdate controls)
23:17:29 <rwbarton> That's because you wrote onUpdate to take two parameters, but you've only passed it one
23:18:34 <jdrake> The other events that I had before had a different prototype
23:19:49 <mmorrow> wow, the Lava code is cool. the one on hackage isn't the fpga one, but the fomal verification one (supposedly they're going to be merged soon). so there's all kinds of symbolic eval, cool datatypes, etc  http://www.cs.chalmers.se/~emax/darcs/chalmers-lava2000/
23:19:50 * BMeph wonders how tough it would be to translate Lava to an Altera chip...
23:19:50 <lambdabot> Title: Index of /~emax/darcs/chalmers-lava2000
23:20:03 <jdrake> rwbarton, thank you. I better go to bed now before I make even more mistakes :-)
23:21:00 <rwbarton> Yeah, there are so many fiddly things with these GUI programs :/
23:21:30 <mmorrow> BMeph: here's the page for the Lava for things fpga http://research.microsoft.com/~satnams/lava/
23:21:31 <lambdabot> Title: The Lava Hardware Description Language
23:21:37 <jdrake> It runs, but doesn't do anything really yet
23:26:04 <mmorrow> BMeph: i've been trying to find the xilinx-lava src code for about 10 minutes. i /really/ hope xilinx isn't sitting on it and not opensourcing it
23:27:08 <mmorrow> if they are, i guess we'll have to use lava-2000 and write what needs to be written to use it for fpgas :)
23:28:05 <mmorrow> the reducer(2) used lava2000 only it seems. so i'm not sure what exactly xilinx-lava does yet
23:28:18 <mmorrow> http://www.cs.york.ac.uk/fp/darcs/reduceron2
23:28:22 <lambdabot> Title: Index of /fp/darcs/reduceron2
23:28:26 <mmorrow> (darcs repo)
23:29:41 <mmorrow> i need read up on vhdl
23:29:49 <mmorrow> ++to++
23:30:04 <rwbarton> @karma ++to
23:30:04 <lambdabot> ++to has a karma of 1
23:30:43 <mmorrow> heh
23:31:02 <mmorrow> looks like karma isn't down with preops
23:37:55 <jdrake> Anyone having trouble with haskell.org?
23:41:49 <thoughtpolice> http://downforeveryoneorjustme.com/haskell.org
23:41:51 <lambdabot> Title: It's just you.
23:47:15 <jdrake> What does this code ` ` do? canvas `onSizeRequest` return (Requisition 40 40)
23:47:55 <mmorrow> > let plus = (+) in 4 `plus` 9
23:47:56 <lambdabot>   13
23:48:18 <mmorrow> onSizeRequest canvas (return (Requisition 40 40))
23:48:50 <jdrake> Interesting way of doing it
23:48:57 <mmorrow> > (*2) `map` [0..]
23:48:58 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
23:50:15 <BMeph_> > (*2)<$>[0..]
23:50:16 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
23:50:31 <BMeph_> Woot, Haskell obfuscation FTW! ;p
23:50:58 <glguy> > join(+)<$>[0..]
23:50:59 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
23:52:36 <Axman6> jdrake: useful for things like 10 `div` 5
23:52:53 <Axman6> > (div 10 5, 10 `div` 5)
23:52:54 <lambdabot>   (2,2)
23:53:09 <Beelsebob> and 5 `elem` [1,2,3,4,5,6,7]
23:53:09 <BMeph_> So, how does laziness annotation in strict languages work? Besides ad-hoc, anyway... ;)
23:53:11 <Axman6> :t (<*>)
23:53:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:56:18 <Saizan> BMeph_: usually something like (\() -> expr) instead of expr
23:58:59 <Xenoblitz> < needs idiot's guide to GHC compiling
23:59:36 <dons> Xenoblitz: don't compile it, use your distro package.
