00:00:01 <lunabot>  newtype State s a = State {runState :: (s -> (a, s))}
00:00:07 <Cale> glguy: It's annoying because ((,) s) is a Haskell Functor, while (/\a -> (a,s)) is not.
00:00:36 <Cale> (because we don't have a lambda at the type level)
00:01:20 <rwbarton> a -> State s b == a -> s -> (b, s) == (a, s) -> (b, s)
00:01:26 <rwbarton> Seems like the sensible order to me
00:01:37 <Cale> Moreover, you can even write an instance Monoid s => Monad ((,) s)
00:02:00 <Cale> rwbarton: I like the state to be the *first* element of the pair.
00:02:27 <rwbarton> Cale: Do you also like to write curry :: ((a, b) -> c) -> b -> a -> c?
00:02:56 <Cale> Not particularly.
00:03:21 <rwbarton> Then the uncurried version of the Kleisli arrow in your convention is (a, s) -> (s, b)
00:03:49 <Cale> The Kleisli arrow isn't something that we can work with explicitly.
00:04:09 <Cale> and even when it is, we can make things line up however we like there.
00:04:29 <rwbarton> , src ''Writer
00:04:35 <lunabot>  newtype Writer w a = Writer {runWriter :: ((a, w))}
00:05:19 <Cale> I would define an instance of Monad for ((,) w), and then use newtype deriving ;)
00:06:11 <rwbarton> > join (Writer (Writer ((), [1]), [2])
00:06:12 <lambdabot>   <no location info>: parse error on input `;'
00:06:18 <rwbarton> > join (Writer (Writer ((), [1]), [2]))
00:06:20 <lambdabot>       No instance for (Show (Writer [t] ()))
00:06:20 <lambdabot>        arising from a use of `sh...
00:06:26 <rwbarton> > runWriter $ join (Writer (Writer ((), [1]), [2]))
00:06:27 <lambdabot>   ((),[2,1])
00:06:40 <rwbarton> I'm with you on this one :)
00:08:30 <rwbarton> mtl doesn't have an equivalent to BaseM, does it?
00:08:36 <Cale> s -> (s,a) makes more sense in light of the fact that it's the composite of two functors.
00:08:40 <Cale> newtype State s a = S (s -> (s,a))
00:08:40 <Cale> instance Functor (State s) where
00:08:40 <Cale>     fmap f (S g) = S (fmap (fmap f) g)
00:09:21 <Cale> rwbarton: No, it just has MonadIO
00:09:59 <rwbarton> I should have looked at monadlib longer.  I've already found two features which would have been useful in my most recent project :)
00:11:00 <Cale> I was just looking at MonadPrompt today, and it seems rather awesome :)
00:11:18 <rwbarton> BaseM and a WriterM that's not too big not to go through a ContT
00:11:21 <Cale> (though I'm unconvinced that it has support for certain kinds of effects)
00:11:39 <Cale> It's still very nicely general.
00:13:00 <Cale> It's just a little out of reach for beginners I think though... but it's possible that a large helping of proper documentation would fix this. :)
00:13:22 <Cale> (and a good large number of examples)
00:13:44 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html
00:13:45 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5zzxue
00:14:24 <Cale> It lets you write actions in terms of an abstract interface defined by whatever datatype you like (usually a GADT)
00:14:43 <Cale> and then provides a run function which allows you to supply the interpretations of those actions.
00:15:05 <Cale> This lets you have multiple run functions with vastly different meanings for the same monadic actions.
00:15:38 <rwbarton> It looks like a continuation-transformed version of the free monad
00:16:34 <Cale> For instance, you can construct the state monad in terms of get and put (like in the comment there), and rather than providing the interpretation which threads the state along, you can provide one where 'put' displays the value for the user, and 'get' asks the user for a value.
00:19:26 <dancor> i want to have a redraw thread redraw my window graphics whenever they change (as indicated by a shared var).  is MVar () best for this?
00:19:49 <dancor> TVar Bool might allow me to combine redraw events if two happen very rapidly?
00:20:06 <dancor> but blocking on it is more awkward?
00:21:22 <olsner> depending on what kind of windowing toolkit you're using, there may be much better ways than to manage your own repainting explicitly
00:22:12 <olsner> and in a classic bait-and-switch, I'll just go poof now :)
00:25:02 <dancor> lolsner
00:25:08 <Cale> dancor: There are a number of options...
00:25:27 <dancor> i'll give MVar () a go
00:25:37 <Cale> dancor: You could use a Chan holding the updates, probably together with a QSem which would allow you to bound the number of updates waiting to be drawn.
00:25:47 <dancor> i guess i was curious if there is a nice way to block on TVar Bool until it becomes True
00:25:59 <dancor> hm CHan
00:26:08 <Cale> Many GUI libraries hate it if you make calls to them from multiple threads, I should warn you.
00:26:13 <rwbarton> dancor: I think so, using retry or something...
00:26:25 <Cale> dancor: absolutely.
00:27:04 <Cale> atomically (do b <- myTVarBool; unless b retry)
00:27:58 <Cale> er
00:28:04 <Cale> readTVar of course ;)
00:35:33 <Cale> rwbarton: Oh, and liftP is rather cool :)
00:35:51 <Cale> liftP :: Prompt p r -> PromptT p m r
00:36:22 <RayNbow> @hoogle Prompt
00:36:22 <lambdabot> package MonadPrompt
00:41:41 <zeno> > ["hi"]==replicate 100000000 "gg"
00:41:42 <lambdabot>   False
00:41:50 <rwbarton> Cale: I bet you could make something interesting out of this and HList
00:41:52 <zeno> does that just check the first gg?
00:42:03 * RayNbow adds MonadPrompt to the ToStudy list
00:42:25 <Cale> RayNbow: When you study it, look at the source code, since all the documentation is in there.
00:42:35 <Cale> (It's not properly haddocked)
00:42:42 <RayNbow> yeah, I already took a quick peek at the code
00:42:57 <rwbarton> I almost missed the documentation entirely
00:43:21 <RayNbow> I have to work on some other things this morning though
00:43:35 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247 -- here's an example I was playing around with today.
00:44:04 <Cale> (the backwards state stuff was twanvl I think...)
00:44:15 <Cale> oh, he had a second go at it :)
00:44:43 <RayNbow> hpastetwo?
00:45:19 <Cale> yep
00:45:31 <Axman6> zeno: it checks as much as it needas to know that it's not equal, so probable gets to the first g and returns false
00:45:38 <Cale> It's nicer... we really should be using it for the main hpaste.
00:46:40 <Axman6> @src [] (==)
00:46:40 <lambdabot> []     == []     = True
00:46:40 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
00:46:40 <lambdabot> _      == _        = False
00:49:05 <RayNbow> heh... using MonadRandom gives rise to long type signatures :p
00:49:06 <rwbarton> I guess I don't mean HList, but rather an extensible sum type.
00:49:54 <dancor> RayNbow: bc of RandomGen g => .. g .. ?  i think you could just do .. StdGen .. if you wanted
00:50:39 <RayNbow> poisson :: (Floating a, MonadRandom f, Random a, Functor f) => a -> f [a]
00:50:50 <RayNbow> ^ inferred type :p
00:55:44 <dancor> should i feel verbose or superior for preferring: data GfxFrontend = GfxFrontend; instance Frontend GfxFrontend where dispF = .. and similarly for TextFrontend   to qualified imports for namespacing?
00:58:13 <rwbarton> Does the type of dispF mention GfxFrontend at all?
00:58:24 <dancor> no
00:58:47 <rwbarton> I think you'll find it difficult to call then, no?
00:59:59 <dancor> it ends up being like maxBound right?
01:00:05 <dancor> :t maxBound
01:00:06 <lambdabot> forall a. (Bounded a) => a
01:00:20 <dancor> but IO a
01:00:28 <dancor> let me make sure i'm making sense here..
01:01:33 <rwbarton> I mean, if the class method dispF has a type like Frontend a => Foo (where a is not a free variable in Foo) it's more like show . read
01:01:37 <rwbarton> :t show . read
01:01:38 <lambdabot> String -> String
01:02:04 <rwbarton> Ack, stupid generalized defaulting
01:02:10 <rwbarton> or...?
01:02:20 <dancor> maybe it does have that problem..
01:11:24 <BeelsebobWork> you use tilde to get an irrifutable pattern match, don't you?
01:11:59 <rwbarton> Yes
01:12:37 <BeelsebobWork> does f ~(Foo a (Bar b c)) force it to match against the Bar too?
01:12:45 <BeelsebobWork> i.e. what I want is only the Foo section to be irrifutable
01:13:30 <BeelsebobWork> or would I need to do (~(Foo a) (Bar b c))
01:14:21 <rwbarton> I don't think you can do that
01:14:23 <BeelsebobWork> I guess the latter one is slightly more strict in that it requires it to figure out that there is indeed an application of some constructor first
01:14:29 <BeelsebobWork> hmm?
01:14:41 <BeelsebobWork> as in, the tilde says the entire rest of the pattern match is irrifutable?
01:14:42 <rwbarton> ~(Foo a (Bar b c)) is a pattern that matches any value
01:14:50 <BeelsebobWork> okay
01:14:55 <rwbarton> there's no way to give up when the Bar is demanded
01:15:10 <rwbarton> or, the thing that might have been a Bar
01:15:23 <BeelsebobWork> yeh, I'm gonna have to play with cases here to get the necessary lazyness out of it
01:17:00 <rwbarton> I don't understand how you could force the Bar without forcing the Foo first
01:17:15 <BeelsebobWork> well, the thing is that I *know* I'm gonna get a Foo
01:17:40 <BeelsebobWork> but it takes a long time to get computed
01:17:49 <BeelsebobWork> and I want to produce partial output
01:17:49 <rwbarton> ah, I think I get it now
01:18:32 <BeelsebobWork> I think what I need is f ~(Foo a b) = LazyBit (case b of (Bar b c) -> ...)
01:18:46 <rwbarton> Yes, that's exactly what I was about to write
01:19:18 <BeelsebobWork> damn strictness, always trips up efficiency ;)
01:23:06 <linolium> Can I have a case expression that distinguishes between three possibilities: given variable > 0, == 0, or < 0?
01:23:28 <Baughn> Yes, using guard expressions
01:23:43 <Baughn> > case 2 of n | n < 0 -> 1; n | n > 0 -> 2
01:23:45 <lambdabot>   2
01:23:45 <BeelsebobWork> case x of {_ | x > 0 -> exp1; 0 -> exp2; _ | x < 0 -> exp3}
01:23:56 <rwbarton> case compare var 0 of GT -> exp1; EQ -> exp2; LT -> exp3
01:24:05 <BeelsebobWork> that too
01:24:12 <Baughn> rwbarton: Ha. You win.
01:24:17 <rwbarton> Hooray!
01:24:18 <BeelsebobWork> that's much nicer in fact
01:24:46 <rwbarton> It reminds me oddly of assembly language
01:25:08 <linolium> hmm, what is the strange | you're using, Baughn ?
01:25:16 <Baughn> linolium: A guard expression.
01:25:23 <linolium> ah?
01:25:34 <Baughn> linolium: It allows you to predicate a branch on an arbitrary.. predicate.
01:25:41 <linolium> ah...
01:25:50 <BeelsebobWork> you can use them in function definitions too
01:26:13 <Baughn> linolium: A predicate is just a function that returns Bool
01:26:17 <BeelsebobWork> > let f x | x > 5 = 10; | otherwise = 3 in f 20
01:26:17 <lambdabot>   <no location info>: parse error on input `|'
01:26:23 <BeelsebobWork> bugger
01:26:28 <BeelsebobWork> not sure you can do it to \bot though
01:26:49 <Baughn> > let f x | x > 5 = 10; f x = 3 in f 20
01:26:50 <lambdabot>   10
01:27:00 <Baughn> You can, but not with the unioc independence thing.
01:27:02 <BeelsebobWork> ah, okay, gotta have a new rule for each
01:27:18 <Baughn> Yeah. Layout rules aren't in effect.
01:28:48 <quicksilver> Baughn: "union independence thing" ?
01:29:04 <quicksilver> > let f x | x > 5 = 10 | otherwise = 3 in f 20
01:29:04 <Baughn> quicksilver: unioc independence
01:29:06 <lambdabot>   10
01:29:13 <quicksilver> what's a unioc?
01:29:23 <Baughn> A kind of alien with only one eye
01:29:32 <Baughn> I swear it made sense at the time
01:29:42 <quicksilver> BeelsebobWork: | isn't a layout construct, no need for a ; before |
01:30:10 <Axman6> how would one go about getting something into hackage?
01:30:30 <Baughn> Axman6: Contact the guy running it, get a username and password, install cabal-uploade
01:30:56 <linolium> I'm getting an infinite type error, can anyone take a look? let minChips k c count = case (compare (c - (head $ sort k)) 0) of LT -> (catch (minChips (tail $ sort k) c count) (-1)); GT -> minChips k (c - head $ sort k) (count + 1); EQ -> count
01:30:58 <Saizan> cabal-upload is included in cabal-install now, no?
01:31:13 <Axman6> this isn't cabalised yet... because i have no idea what doing so means
01:31:19 <Baughn> Hm. Yeah, so it is.
01:31:21 <Saizan> oh
01:31:27 <Baughn> Axman6: cabal install mkcabal might help
01:31:39 <Axman6> righto
01:31:53 <rwbarton> linolium: what's 'catch'?
01:31:55 <Baughn> Axman6: Well, it basically just means specifying dependencies and exposed modules so it'll behave like a nice, fluffy library.
01:32:20 <Axman6> it's not really something that library like, though it could be i guess
01:32:24 <Saizan> Axman6: http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html
01:32:26 <lambdabot> Title: Creating a package, http://tinyurl.com/5bk455
01:32:43 <linolium> rwbarton: it's for catching the exception where head doesn't return an element
01:32:53 <rwbarton> linolium: that won't work
01:33:06 <Baughn> linolium: You can only catch exceptions in IO
01:33:20 <linolium> oh, really?
01:33:20 <Baughn> linolium: Instead, make sure it *will* return an element, or use listToMaybe
01:33:35 <rwbarton> linolium: better to use pattern matching to eliminate that case if possible
01:33:51 <rwbarton> linolium: also, head . sort == minimum and tail . sort == maximum
01:34:00 <Baughn> linolium: It's not a big issue. If you don't want to track errors manually, as values, there's the Error monad too.
01:34:16 <linolium> ah, minimum and maximum work on lists?
01:34:21 <rwbarton> @type minimum
01:34:23 <lambdabot> forall a. (Ord a) => [a] -> a
01:34:24 <rwbarton> @type min
01:34:25 <lambdabot> forall a. (Ord a) => a -> a -> a
01:34:36 <Baughn> @src minimum
01:34:37 <lambdabot> minimum [] = undefined
01:34:37 <lambdabot> minimum xs = foldl1 min xs
01:34:38 <Saizan> > tail . sort $ [1..5]
01:34:40 <lambdabot>   [2,3,4,5]
01:34:45 <rwbarton> erm, oops
01:34:59 <linolium> hmm, how do I get all but the largest element in the list
01:35:42 <rwbarton> tail . sort isn't the worst way to do that.
01:35:51 <Saizan> > drop 1 . sortBy (flip compare) $ [1..5]
01:35:53 <lambdabot>   [4,3,2,1]
01:36:03 <Saizan> > drop 1 . sortBy (flip compare) $ []
01:36:05 <lambdabot>   []
01:36:30 <RayNbow> http://hpaste.org/11352 <-- room for improvements?
01:36:46 * RayNbow made a small function useful for histograms
01:37:07 <linolium> > tail . flip . sort [1..5]
01:37:08 <lambdabot>   Couldn't match expected type `a -> a1 -> b -> c'
01:37:16 <rwbarton> linolium: maybe it's easiest just to declare that minChips will operate on sorted lists and write a wrapper function to perform the sorting once at the beginning
01:37:35 <Axman6> hmm, would hackage be the right place for an ARM emulator?
01:37:44 <linolium> rwbarton: that's what I was thinking.. also I don't want to pass in the count of "0" each time
01:37:45 <Baughn> Axman6: Yes
01:37:51 <Axman6> ok
01:37:59 <Axman6> well, i might get onto cabalising it
01:38:00 <Baughn> Axman6: *All* haskel packages should go on hackage. It's our problem to organize it properly later. :P
01:38:11 <Axman6> heh
01:38:35 <rwbarton> linolium: then you can write a much nicer minChips (k:ks) c count = ...
01:38:40 <glguy> http://hpaste.org/11353 What would we do without seq to keep things interesting?
01:38:42 <Baughn> Axman6: Oh, and cabalizing is useful even locally - you can then use just "cabal build" to re-install any dependencies, build and install your pcakage.. I don't know what you're doing now, but..
01:38:57 <Baughn> Axman6: Er. s/abal build/abal install/
01:39:10 <Axman6> well, at the moment, i'm just using "ghci arm" ;)
01:39:17 <linolium> rwbarton: can I have two minChips, one with 2 arguments and one with 3?
01:39:24 <Axman6> it's not all that useful outside ghci
01:39:31 <rwbarton> linolium: no
01:39:34 <Axman6> it coulld be though...
01:39:34 <linolium> ah
01:39:58 <rwbarton> linolium: Often people will write   minChips k c = minChips' (sort k) c 0 where minChips' ...
01:40:02 <Axman6> hmm, i could make a pair of executables, one for running the program, and one for debugging it
01:40:32 <Baughn> glguy: You tell me. Attempt to make secure data structures in an insecure language? :P
01:40:52 <Baughn> Axman6: Yes. Yes, you could.
01:41:03 <Baughn> See, it's useful already. ^_^
01:41:13 <linolium> rwbarton: ah, I see
01:41:13 <Axman6> ok, sounds good. i might give that a go :)
01:41:16 <Saizan> glguy: "interesting"?
01:42:53 <Axman6> Baughn: since this isn't all that complete, might community.haskell.org be better?
01:43:28 <Axman6> i guess it's complete enough though
01:43:54 <Baughn> Axman6: Different purposes. c.h.o is for hosting repositories and general development; hackage is a repository for users.
01:44:19 <Baughn> Axman6: And most people who might feel like helping you will start out by trying it with "cabal install arm". ;)
01:44:36 <Axman6> im' thinking harm might be a better name ;)
01:44:58 <Baughn> Hehe
01:45:17 <glguy> I've been playing with some code that presents an interface to some opaque data types which are bound to a certain scope in the way that STRefs are bound to a scope. the run function for the scope randomly generates a keypair that it doesn't reveal but that can  be used to serialize the opaque types securely, allowing them to be written out to file or network without making them less opaque or useable in other sessions
01:47:18 <Baughn> glguy: You probably shouldn't try to make them opaque to the *host program*. The language isn't designed for it, and you risk thinking you've succeeded.
01:47:36 <Baughn> A newtype hiding the implementation from a cooperating programmer, sure
01:47:50 <glguy> Baughn, yeah , its a whole program, not a library
01:48:01 <glguy> it tries to detect accidental leaks
01:48:21 <Baughn> "update (error. show)" is hardly /accidental/
01:48:59 <glguy> I just thought that was worth sharing. I'm not losing sleep over it
01:49:51 <glguy> error and seq are in the prelude, always in scope. it seemed more interesting than a unsafeCoerce# style example
01:49:57 <glguy> "always"
01:50:41 <rwbarton> > 1/256^(length "update (error. show)") :: Rational
01:50:43 <lambdabot>   1%1461501637330902918203684832716283019655932542976
01:50:55 <rwbarton> could happen :)
01:51:38 * Baughn wants a 256-exabyte hard disk already. ;_;
01:58:48 <linolium> hmm, I'm having some trouble with what seems to be infinite recursion.  Can anyone take a look? http://pastebin.com/d138394d4
01:59:15 <dancor> rwbarton: ok, you do need to have like the first arg be GfxFrontend (and ignored in actual definition of dispF)
01:59:45 <quicksilver> linolium: in the GT case it does appear to call itself with exactly the same aprameters, no?
02:00:18 <dancor> .. where dispF _ a b = something a b
02:00:47 <rwbarton> dancor: yeah.  This seems like a slightly silly thing to do :)
02:00:51 <linolium> quicksilver: ah, you're right... I meant to do count - k
02:00:53 <glguy> compare (chips - k) 0 --> compare chips k ?
02:00:54 <dancor> heh
02:00:59 <linolium> quicksilver: I mean chips - k
02:01:20 <Saizan> linolium: also, "length ks > 0" is best written as "not (null ks)"
02:01:49 <linolium> ah, cool
02:02:17 <Saizan> rwbarton: "phantom parameters"
02:03:03 <linolium> hmm, so I got a stack overflow with a number that isn't terribly large.. how does one deal with this in Haskell?
02:03:22 <Axman6> what were you doing?
02:03:26 <glguy> add strictness or allocate on the heap
02:03:29 <Axman6> length [1..10^8]?
02:03:54 <linolium> I tried minChips [1..18] 10000000
02:04:22 <Axman6> yeah, you'll want to add strictness somewhere
02:04:26 <linolium> what's that?
02:04:48 <glguy> its that seq thing I was complaining about earlier ;)
02:04:50 <glguy> goodnight!
02:05:04 <quicksilver> linolium: you're probably building a large thunk in the 'count' parameter
02:05:15 <Axman6> a `seq` b = b, but evaluates a before returning b
02:05:18 <quicksilver> which as far as I can see you never inspect (which would force it)
02:05:46 <quicksilver> linolium: can you post the code you're actually using?
02:05:50 <Axman6> $! is pretty useful for adding strictness
02:06:26 <Axman6> @src ($!)
02:06:26 <lambdabot> f $! x = x `seq` f x
02:06:55 <linolium> quicksilver: http://pastebin.com/de1b0e1c
02:07:06 <quicksilver> yup.
02:07:11 <quicksilver> building up a huge thunk in 'count'
02:07:14 <quicksilver> which you never demand.
02:07:17 <linolium> what is a huge thunk?
02:07:48 <Axman6> > foldl1 f [q,w,e,r,t,y,u,i,o,p]
02:07:50 <lambdabot>   f (f (f (f (f (f (f (f (f q w) e) r) t) y) u) i) o) p
02:07:50 <quicksilver> http://www.haskell.org/haskellwiki/Thunk
02:07:51 <lambdabot> Title: Thunk - HaskellWiki
02:07:57 <quicksilver> linolium: that page should explain.
02:08:09 <quicksilver> I would suggest you add "count `seq`" just before the case
02:08:09 <Axman6> that's a thunk basically, it's an unevaluated expression
02:08:21 <quicksilver> count `seq` case compare ....
02:08:23 <Axman6> > foldl' f a [q,w,e,r,t,y,u,i,o,p]
02:08:25 <lambdabot>   f (f (f (f (f (f (f (f (f (f a q) w) e) r) t) y) u) i) o) p
02:08:40 <Axman6> bleh, yes that makes sense...
02:09:00 <linolium> what does the count `seq` do?
02:09:09 <Axman6> it evaluates count
02:09:17 <quicksilver> linolium: it forces count to be evaluated before the case is evaluted
02:09:25 <quicksilver> which means count can't build up as a big thunk.
02:09:35 <Axman6> stops it being 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1... and turns it into 21564641362 or whatever
02:09:45 <linolium> but I thought a problem with the stack overflowing was from too many recursions
02:09:53 <quicksilver> sort of.
02:10:02 <quicksilver> the stack actually overflows when the thunk is evaluated.
02:10:08 <RayNbow> perhaps it's best to start with a simple example in which large thunks are built up?
02:10:12 <quicksilver> so it's a stack overflow in (1+1+1+1+1+1+1+1+1+1+1+1+1+1+....)
02:10:14 <RayNbow> fac n = fac' n 1
02:10:14 <RayNbow> fac' 0 a = a
02:10:14 <RayNbow> fac' n a = fac' (n-1) (n*a)
02:10:19 <RayNbow> ^ like this example?
02:10:22 <rwbarton> basically you want to be reducing 1+1+1+1... in parallel with your other computation
02:10:25 <quicksilver> not precisely a stack overflow in minChips
02:10:55 <linolium> well, that certainly seems to have helped a lot
02:11:04 <quicksilver> linolium: the recursion in minChips' is tail recursion so doesn't actually consume any stack.
02:11:28 <linolium> my other question was, what would be the easiest way to implement memoization in this case?
02:11:49 <linolium> quicksilver: ah, that's right.. my friend was explaining that to me
02:14:01 <quicksilver> yi-- # misuse of word 'beta'
02:19:43 <niklaus> i've a stream of numbers (unsorted positive), if i want to calculate the median each time when a new element is added , which is the best way to do it . there are around 6*10^5 elements. so each time a new element comes sorting is slow.
02:20:56 <quicksilver> use a better data structure so that sorting is not slow :P
02:21:10 <Axman6> if i need to import Word, would i be better using Data.Word or just Word?
02:21:16 <quicksilver> Axman6: Data.Word
02:21:28 <Axman6> and would that be more or less portable?
02:21:32 <quicksilver> the one-part module names are for h98 compatibility.
02:21:36 <quicksilver> less portable, but better.
02:21:37 <Axman6> not that i care too m uch
02:21:39 <quicksilver> no one cares about h98.
02:21:43 <Axman6> heh, ok
02:21:49 <Axman6> and Int?
02:21:51 <Axman6> same thing?
02:21:54 <quicksilver> Data.Int
02:22:00 <Deewiant> I try to stay in H98 apart from module names
02:22:17 <quicksilver> Deewiant: h98 the language is worth thinking about
02:22:25 <quicksilver> Deewiant: h98 the standard library isn't, really.
02:22:29 <quicksilver> why not use newer libraries?
02:22:33 <Deewiant> yes, right.
02:22:37 <quicksilver> that would just be reinventing wheels.
02:22:58 <quicksilver> I try to minimise use of language extensions.
02:23:15 <quicksilver> but existentials are a very natural extension and I happily use thouse.
02:26:35 <solrize> what about gadt's
02:27:06 <quicksilver> they seem natural enough but I've never found a use for them.
02:27:57 <solrize> they seem like a generalization of existentials
02:28:22 <Axman6> if this project doesn't need any external libs, just things included with ghc, do i need a Build-Depends: section in my .cabal file?
02:28:24 <quicksilver> they don't seem like that ot me.
02:28:33 <quicksilver> they seem completely orthogonal to existentsials.
02:28:46 <solrize> hmm
02:29:25 <RayNbow> hmm, hscolour's mirc color output is not very useful... it uses the color black which is problematic for people using a black background :p
02:31:08 <BONUS> @pl \x -> sequence (replicate x ['a'..'z'])
02:31:09 <lambdabot> sequence . flip replicate ['a'..'z']
02:31:45 <Axman6> also, how do i a) decide what modules i want exposed, and b) lay them out, so i get somthing like VARM.Arm, VARM.CPU etc?
02:32:10 <Axman6> in a cabal package*
02:32:18 <BONUS> @pl \x a b -> sequence (replicate x [a..b])
02:32:19 <lambdabot> ((sequence .) .) . (. enumFromTo) . (.) . replicate
02:37:37 <Axman6> could someone help me with http://hpaste.org/11354 ?
02:39:48 * Axman6 wonders if he has been muted for some reason...
02:43:31 <Axman6> :t (. (.) .)
02:43:32 <lambdabot> parse error on input `)'
02:43:42 <Axman6> :t (f . (.) . g)
02:43:43 <lambdabot>     Ambiguous type variable `c' in the constraints:
02:43:43 <lambdabot>       `SimpleReflect.FromExpr c'
02:43:43 <lambdabot>         arising from a use of `g' at <interactive>:1:11
02:45:21 <rog> is there some kind of tutorial or documentation for HList besides the paper http://homepages.cwi.nl/~ralf/HList/paper.pdf (which doesn't seem to accurately reflect the API)?
02:45:23 <lambdabot> Title: Strongly Typed Heterogeneous Collections
02:45:50 <rog> is HList actually much used, in fact?
02:46:06 <hcube> hi! I have this problem: I've got this error when installing zlib haskell package: Setup.hs: Error: Could not find module: Codec.Compression.GZip with any suffix: ["hi"]
02:46:32 <nominolo|msr> hcube: are you on windows?
02:46:41 <hcube> I'm on ubuntu hardy
02:46:45 <hcube> (linux)
02:46:56 <nominolo|msr> hm, that's weird
02:47:32 <rog> i get the feeling that in using HList (or implementing similar functionality independently), i'm venturing into some fairly twisty haskell backwaters...
02:47:46 <hcube> i used this version: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.4
02:47:48 <lambdabot> Title: HackageDB: zlib-0.4.0.4, http://tinyurl.com/2yr4xl
02:48:11 <nominolo|msr> hcube: what did you do?
02:48:14 <rog> oh well. on with the type-level naturals.
02:48:19 <nominolo|msr> just runhaskell Setup.hs configure?
02:48:50 <hcube> download, extract source, cd dir, runhaskell Setup.hs configure, build, install -> error
02:49:11 <nominolo|msr> can you try install again?
02:49:13 <hcube> configure seemd ok
02:49:33 <nominolo|msr> on 6.8.3 there were some weird heisenbugs (fixed now)
02:49:49 <rog> my more specific question at this time is: what's first/nextLabel called these days?
02:50:24 <hcube> nominolo|msr: same when i try to install again
02:50:48 <hcube> my ghc version is: 6.8.2
02:50:58 <nominolo|msr> hcube: can you verify that the file exists in dist/build/ ?
02:51:28 <hcube> empty. there are no hi files
02:51:47 <hcube> (after build)
02:52:12 <nominolo|msr> hcube: and no subdirectories?
02:52:24 <hcube> subidr exists
02:52:27 <hcube> *subdirs
02:52:44 <nominolo|msr> ok, the .hi files should be in there
02:53:09 <hcube> dist/build/Codec/Compression/Zlib is empty
02:53:25 <hcube> i dont know why :(
02:53:25 <quicksilver> rog: HList is not widely used, no.
02:53:27 <nominolo|msr> what was the output of the build command?
02:53:32 <hcube> no
02:53:41 <quicksilver> rog: some people use it or similar tricks; happs certainly does.
02:53:45 <hcube> sorry. there was no output
02:54:04 <quicksilver> rog: if it helps to de-mystify, HList is "just" nested tuples. With a framework of typeclasses to manage them.
02:54:08 <Plareplane> do you have zlib1g-dev installed?
02:54:15 <nominolo|msr> hcube: build should at least print [1 of 5] or similar
02:54:42 <hcube> i have zlib1g-dev installed
02:55:07 <nominolo|msr> hcube: could you do runhaskell Setup clean; then configure, build, install and paste all the output?
02:55:20 <nominolo|msr> http://hpaste.org/new
02:55:26 <Plareplane> maye try rm -r the dir, then untar and do again?  i sometimes get weird things happening that magically disappear when i redo it again
02:56:22 <rog> quicksilver: i kind of get the idea. but i can't decide if it's possible to use it to do what i want to do, which is treat it both as a labeled HList and as a set of nested tuples implementing a particular type class of my own.
02:56:57 <hcube> here is teh output http://hpaste.org/11355
02:56:59 <hcube> *the
02:57:07 <rog> quicksilver: the paper mentions firstLabel and nextLabel, but these aren't defined in the source. and there's no other documentation, so i can't yet work out how labels are supposed to be done currently.
02:57:39 <rog> quicksilver: i feel i might be better just doing it all from scratch, taking ideas from the paper.
02:57:40 <hcube> Plareplane: i've already tried rm -r and untar
02:58:59 <hugo__> hello
02:59:35 <rog> quicksilver: this kind of trick certainly feels like the right kind of thing for my problem (where i want constant labels for fields of a record that are transformed in a type-specific way)
03:05:04 <cajun-rat> is there a way to find the directory that the current program is in?
03:05:12 <Deewiant> @hoogle getCurrentDirectory
03:05:13 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
03:05:52 <cajun-rat> i mean the directory the executable is in, rather than cwd
03:06:58 <Deewiant> impossible to do in general, I think
03:07:18 <cajun-rat> grr, that's a pain
03:07:29 <Axman6> why do you need it?
03:08:22 <cajun-rat> in this case i've got a script that builds some stuff, and i want to find the resources relative to the exe location
03:09:06 <cajun-rat> i _could_ pass the root dir to it, but finding it automatically would be neater
03:10:40 <Saizan> rog: something like firstLabel :: Proxy HZero, nextLabel :: Proxy n -> Proxy (Succ n)
03:12:47 <rog> Saizan: but unless there's some strange trickery going on, grep -i firstlabel Data/HList/*.hs gives no result.
03:13:06 <rog> Saizan: so i can't see where firstLabel would come from!
03:14:13 <rog> Saizan: (unless i'm supposed to define them myself, i guess_
03:14:13 <Saizan> rog: i was giving you the definitions :)
03:14:27 <hugo__> im quite fond of "haskell versus C" code revisions :)
03:14:47 <rog> Saizan: you gave me the type signatures... in my ignorant state, the definitions aren't obvious to me.
03:15:11 <hugo__> "look, in haskell you can do this in three readable lines, whilist in C you need 100 lines that leak memory like there is no tomorrow and dont scale for shared-mem multiprocessors"
03:16:06 <hcube> hcube: i've solved zlib package building :)  the problem was a half installeg ghc version in /usr/local dir
03:16:16 <hcube> i'vew removerd i
03:16:19 <hcube> *it
03:16:29 <Saizan> rog: you could also look at the original darcs repo darcs get http://darcs.haskell.org/HList/
03:16:30 <lambdabot> Title: Index of /HList
03:17:14 <Axman6> "cabal: cannot configure HUnit-1.2.0.2. It requires base >=4 && <5
03:17:18 <rog> Saizan: ah, examples!
03:17:19 <Axman6> how do i fix that? :\
03:18:18 <Saizan> rog: the implementation is simply undefined, labels are only type-level contructs, unless you attach descriptions to them
03:20:57 <rog> Saizan: ok. my mind is still boggling somewhat. i'm sure it'll settle down eventually.
03:22:01 <Axman6> urgh, did i do something wrong? -_-
03:24:16 <rog> Axman6: i guess it's 'cos nobody knows immediately how to answer your question.
03:24:48 <Deewiant> Axman6: what is there to be 'fixed'? You don't have base >= 4 but that version of HUnit wants it. :-P
03:24:50 <Saizan> rog: oh, i've tested against the hlist on hackage and you've to use HZero/Succ n, i.e. without Proxy, because of the available instances for HEq
03:24:52 <Axman6> i;'ve asked about 5 questions in the last hour and haven't got a single reply about any of them
03:26:20 <rog> Saizan: like firstLabel :: HZero, nextLabel :: n -> Succ n ?
03:26:28 <Saizan> rog: yup
03:26:28 <Deewiant> Axman6: if you just want HUnit, get an older version which works with base-3. Or get GHC 6.10 which has base-4.
03:26:30 <Axman6> Deewiant: well is it part of ghc 6.10 or what? i'm just trying to run cabal upgrade --installed, and i can;t upgrade anything like that at the moment
03:26:44 <Deewiant> It is my understanding that 'cabal upgrade' isn't necessarily a good idea.
03:26:51 <Saizan> rog: HSucc
03:27:04 <Axman6> hmm
03:27:39 <rog> Saizan: i think one of the things that makes HList hard (for me at least) is that the exposed API is really very large, and it's not easy to see what its contraints are.
03:28:14 <Saizan> rog: i don't like how the package on hackage has lumped everything in a single module
03:28:16 <rog> Saizan: a usual list API has about 3 three entry points :-)
03:28:26 <Saizan> rog: most of the classes are implementation details
03:28:41 <rog> Saizan: i guess so. but the modules all export everything!
03:29:46 <rog> Saizan: ... making it really hard to know what bits one is supposed to use, and how.
03:30:21 <Saizan> rog: the paper should give a quite clear idea about that
03:30:59 <rog> Saizan: clear... except that the API has changed somewhat. and the paper is as much about implementation as use.
03:32:09 <rog> Saizan: in general, it's nice to have proper documentation, not, here's an example: extrapolate from that.
03:32:36 <Saizan> rog: i guess, but it's a library with no maintainer :)
03:33:24 <rog> Saizan: yeah. maybe i should write up a page on the wiki about my novice experiences with it...
03:33:52 <Axman6> is there an easy way to get cabal (install) to build a few binary programs and instsall them in ~/.cabal/bin?
03:34:27 <Saizan> Axman6: specify them in Executable stanzas in the .cabal file
03:34:55 <Saizan> rog: nice
03:43:45 <Axman6> hmm
03:48:19 <DukeDave> Erm, is there a version of lines/words which lets you specify your own delimiter? :o
03:49:54 <Axman6> urgh. anyone know why a program that should show a prompt, then recieve input would expect the input first, then ask fpr the output?
03:50:04 <Axman6> works fine in ghci, but compiled it doesn't
03:50:35 <DukeDave> Axman6: Buffering problem?
03:50:36 <Axman6> basically it should be doing putStr then getLine, but it's doing it the other way
03:51:10 <Axman6> wonder if it's my terminal...
03:51:23 <DukeDave> ?type hSetBuffering
03:51:24 <lambdabot> Not in scope: `hSetBuffering'
03:52:01 <DukeDave> ?type System.IO.hSetBuffering
03:52:02 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
03:52:09 <DukeDave> Yey
03:52:37 <quicksilver> DukeDave: no.
03:52:53 <DukeDave> quicksilver: No to my first question?
03:53:19 <quicksilver> yeah, no to a custom delimeter for lines/words
03:53:43 <DukeDave> Aw, but that's so preludeolicious :(
03:54:11 <Axman6> DukeDave: any tips on how i'd use that?
03:54:37 <Saizan> Axman6: hSetBuffering stdout LineBuffering
03:54:38 <DukeDave> Axman6: Sure, are you using 'do' notation to sequence?
03:55:14 <DukeDave> Or, yeah, like that :)
03:55:19 <Axman6> i believe so, it's not my code, but i was hoping it'd work the same in ghci as compiled
03:55:57 <quicksilver> hSetBuffering stdout NoBuffering
03:56:04 <quicksilver> (if the prompt doesn't end in a newline)
03:56:17 <DukeDave> Axman6: You can probably get away with sticking that ^ before  the putStr
03:56:52 <Axman6> quicksilver: that seems to fix it. thanks, and thanks DukeDave :)
03:57:38 <DukeDave> Np
04:01:04 <Axman6> hmm, is importing System enough to get System.IO.hSetBuffering?
04:01:17 <dobblego> no
04:01:27 <quicksilver> System.IO
04:01:38 <quicksilver> and don't use the the one-word libraries
04:01:43 <Axman6> well cabal doesn't seem to like that
04:01:50 <quicksilver> exception Numeric, which didn't get hierarchicaled.
04:02:05 <quicksilver> cabal doesn't like it in what way?
04:02:18 <Axman6> ./runarm.hs:4:7:
04:02:18 <Axman6>     Could not find module `System.IO':
04:02:19 <Axman6>       it is a member of package base, which is hidden
04:02:42 <quicksilver> you must be running it in haskell98 dependency mode.
04:02:48 <quicksilver> AIUI.
04:02:55 <quicksilver> make base a dependency of it
04:03:43 <Saizan> Axman6: you've to add all the packages you use to your build-depends
04:04:16 <Axman6> urgh, lameness
04:04:32 * quicksilver slaps Axman6 with a moldy trout.
04:04:32 <Axman6> see, i asked this over an hour ago, and got no responses at all
04:04:42 <quicksilver> thou shalt not confuse lameness with sensible design.
04:04:57 <Axman6> well, everything that it needs comes with ghc -_-
04:05:04 <quicksilver> making you declare your dependencies correctly is how cabal makes sure your code will run on another system.
04:05:57 <Axman6> so i need to declare things like Data.Array, Data.Bits ...?
04:06:09 <quicksilver> no.
04:06:14 <quicksilver> you declare the packages.
04:06:22 <quicksilver> most of those are in package "base"
04:06:22 <Axman6> so, Data?
04:06:34 <Axman6> and System needs to be declared too?
04:06:44 <quicksilver> System in the package "base"
04:06:48 <quicksilver> well, no.
04:06:53 <quicksilver> System.IO is in "base"
04:07:08 <quicksilver> System is in "haskell98"
04:07:11 <quicksilver> you shouldn't use System.
04:07:27 <Axman6> wherte else do i get getArgs then? :\
04:07:27 <quicksilver> Data.Array in is "array"
04:07:45 <quicksilver> System.Environment
04:07:50 <quicksilver> @index getArgs
04:07:50 <lambdabot> System.Environment
04:07:55 <quicksilver> botsnack
04:07:59 <quicksilver> @botsnack
04:07:59 <lambdabot> :)
04:08:17 <jesnor> why is ":t [0]" = (Num t) => [t], but "let v = [0]" ":t v" = [Integer] ?
04:08:54 <quicksilver> jesnor: dreaded monomorphism restriction.
04:09:04 <quicksilver> @go haskellwiki monomorphism
04:09:07 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
04:09:07 <lambdabot> Title: Monomorphism restriction - HaskellWiki
04:09:57 <jesnor> quicksilver: ok, thanks
04:11:30 <jesnor> quicksilver: why is Integer chosen as type? arent all Num types equally applicable?
04:11:30 <Japsu> The monomorphism restriction is in place for the sake of your own safety! By lifting it, you risk permanent damage to your sanity!
04:11:43 <quicksilver> jesnor: defaulting.
04:11:56 <quicksilver> defaulting is put there so you don't just get annoying error messages.
04:12:07 <jesnor> quicksilver: and where is this default rule defined?
04:12:12 <quicksilver> in the haskell report.
04:12:22 <quicksilver> you can choose your own default if you want.
04:12:22 <jesnor> ok, compiler builtin
04:12:28 <quicksilver> no, not really.
04:12:32 <quicksilver> just a default default.
04:12:32 <Axman6> well... i think i have a working cabalised project...
04:16:26 <jeffz> hm, it'd be cool if hackage had some sort of bug tracker functionality per package
04:16:57 <quicksilver> jeffz: And Lo, it was thus!
04:17:33 <quicksilver> ..by which I mean, that would be nice, somebody please do it ;)
04:18:20 <quicksilver> jeffz: community.haskell.org provides bug tracking facilities for projects hosted there.
04:24:38 <jeffz> I think I've found a bug in the glfw package, which might explain http://www.reddit.com/r/programming/comments/77xcs/on_haskell_and_c_open_game_programming/ even though the person on the blog didn't give any code or details about what they were doing, it doesn't work very smoothly on linux because cabal builds it without pthreads, building a sample program under wine with ghc produces a much better result.
04:24:40 <lambdabot> Title: On Haskell and C++ « Open game programming : programming, http://tinyurl.com/6y4sht
04:31:48 <quicksilver> jeffz: interesting.
04:32:09 <jeffz> I guess I'll email the maintainer
04:32:15 * quicksilver nods
04:37:29 <rog> is it possible to alias a constructor? i thought just giving it a type synonym would do the job, but it doesn't seem to.
04:39:07 <matthew-_> err, any lhs2TeX gurus here?
04:40:16 <Saizan> rog: a type-constructor?
04:41:06 <matthew-_> rog: a data type constructor is a function, not a type, so a type alias wouldn't work. (assuming you mean C in data Foo = C)
04:41:14 <rog> Saizan: yes. so that i can pattern-match against it. i'm just coming to the conclusion that the reason may be just that the constructor isn't exported.
04:41:41 <rog> (but finding the list of actual exported names from HList is a bit twisty)
04:41:46 <swiert> matthew-_: I'm hardly a guru, but ask away.
04:42:17 <Saizan> rog: are you getting an error?
04:43:21 <matthew-_> swiert: actually, I'm just reading the Faq in the manual and that has some answers - it's the standard "my thesis is split across many files, how do I work around this %include prelude problem"
04:43:32 <rog> Saizan: i'm getting "Tst3.hs:65:9: Not in scope: data constructor `Record'"
04:43:50 <rog> Saizan: (and the same for HCons and LVPair)
04:44:04 <rog> Saizan: i think i should perhaps avoid the pattern-matching approach
04:44:20 <Saizan> rog: if it says 'data constructor' it means you're trying to use it at the value-level
04:45:00 <Saizan> rog: i thought by pattern-matching you meant in class instance heads
04:45:04 <rog> Saizan: yes, i am. i thought that should be ok. but perhaps not.
04:45:10 <rog> Saizan: both
04:46:15 <rog> here's an excerpt from my code, although it proably doesn't make a great deal of sense out of context. http://hpaste.org/11356#a0
04:46:27 <swiert> matthew-_ ok. feel free to ask away if you have questions. kosmikus (Andres Loeh) also hangs out in here.
04:46:51 <BeelsebobWork> A simple matter of style... how would you guys lay out a long type signature? http://hpaste.org/11357
04:47:06 <BeelsebobWork> more suggestions are welcome :)
04:47:08 <Saizan> rog: do you import Data.HList ?
04:47:42 <Deewiant> BeelsebobWork: I use the style second from the bottom
04:47:50 <quicksilver> BeelsebobWork: option 4 or later.
04:48:01 <quicksilver> BeelsebobWork: I put the => on the previous line, thouhg.
04:48:05 <quicksilver> but that's a pretty minor point.
04:48:05 <BONUS> i think option 5 is used in Haddock?
04:48:26 <BeelsebobWork> http://hpaste.org/11357#a1 <-- this QS?
04:48:28 <quicksilver> option 4 for that signature but degenerating to option 5 as the signature itself gets longer.
04:48:50 <quicksilver> BONUS: I think in haddock it depends if you have documented the parts of the type
04:49:02 <BeelsebobWork> http://hpaste.org/11357#a2 <-- or this?
04:49:03 <BONUS> ah
04:49:04 <quicksilver> BeelsebobWork: no, just the =>, not any part of the type
04:49:10 <quicksilver> yes, that.
04:49:13 <rog> Saizan: originally, no, hence my question about constructor aliasing. but now that you remind me of it, i had forgotten to import Record(Record) rather than just Record.
04:49:19 <BeelsebobWork> hmm, okay
04:49:28 <BeelsebobWork> do you guys have a rationale behind the one you chose?
04:49:41 <BeelsebobWork> the reason I'm asking is that I can't really see a good reason to prefer any of them
04:49:46 <rog> Saizan: so it does now work. but i'm still interested to know whether it's possible to alias a data constructor...
04:49:55 <rog> Saizan: (thanks)
04:50:08 <quicksilver> BeelsebobWork: well, options 1 and 3 "waste" horizontal space.
04:50:23 <quicksilver> BeelsebobWork: I don't have strong reasons to choose between the others
04:50:26 <BeelsebobWork> that's true
04:50:42 <quicksilver> normally I balance "clarity" which is subjective, with space consumed, horizontal + vertical.
04:50:54 <BeelsebobWork> yeh
04:50:59 <BeelsebobWork> cool
04:51:08 <BeelsebobWork> that mostly confirms what I do... I think
04:51:13 <Saizan> rog: no, for a data-constructor there's no facility for direct aliasing, but view patterns are very close to that
04:51:48 <rog> woohoo. it now compiles. that's by far the most complicated class instance i've declared yet.
04:51:58 <rog> s/declared/defined/
04:52:04 <BeelsebobWork> quicksilver: http://hpaste.org/11357#a3 <-- would you ever use the top one?
04:52:29 <Saizan> rog: they are new in 6.10, however you could still define a RecordView datatype and provide a function :: Record x -> RecordView x
04:53:14 <rog> i'd looked at view patterns, but not tried to use them (i didn't know they were brand new).
04:53:29 <rog> for the moment, i'll just stick to the import, i guess.
04:54:11 <quicksilver> BeelsebobWork: I think not. Once I'd decided I had to split lines I think I'd do one parameter per line.
04:54:22 <quicksilver> BeelsebobWork: but if some of the parameters were very small and logically groupd
04:54:29 <quicksilver> "Int -> Int -> Int ->"
04:54:31 * quicksilver shrugs
04:54:32 <Saizan> rog: that's fine, views are for when you want to hide the implementation but still offer the convenience of pattern matching
04:54:34 <BeelsebobWork> cool, I think we pretty much agree on it then, I just hadn't managed to get any rationale behind my choices
04:54:44 <BeelsebobWork> quicksilver: ah, yeh, that makes sense
04:55:00 <BeelsebobWork> I guess I would be almost inclined to introduce a new data type for that though
04:55:21 <explicitjelly> can I name an operator .\ ?
04:55:33 <SamB_XP> Beelsebob: well, if it was a recurring theme ...
04:55:52 <dmwit_> > let a .\ b = a + b in 3 .\ 5
04:55:53 <rog> Saizan: yeah, i like them. i've used a similar facility in F#. it's really pleasant.
04:55:54 <lambdabot>   8
04:56:05 <dmwit_> explicitjelly: The easiest way to find out is usually to try. ;-)
04:56:39 <dmwit_> explicitjelly: (But in general, any combination of Unicode punctuation characters is allowed, provided it does not start with ':' and is not something reserved like -- or -> or so.)
04:56:40 <explicitjelly> dmwit_, true 8) thanks!
04:57:35 <matthew-_> swiert: cheers. I've sorted it out actually.
04:58:24 <SamB_XP> or \
05:07:48 <dmwit_> :t hPrint
05:07:49 <lambdabot> Not in scope: `hPrint'
05:09:10 <Peaker> trying to use the installed wxcore, ghc --make something with wx creates an executable depending on shared library: libwxc-gtk2.8.7-0.10.5.so which doesn't exist.  Any idea how come?
05:10:01 <Peaker> oh ok, I do have 0.10.3, just not 0.10.5
05:10:13 <Peaker> why would it generate a dependency for something that wasn't there when it was compiled?
05:20:38 <int-e> Peaker: did you install a binary package?
05:21:55 <Peaker> int-e: nope, I used a system-wide cabal install of wxcore
05:22:08 <Peaker> but never mind, I'll work with SDL, which is far easier to install and more flexible in what it can do ;)
05:22:13 <Peaker> (and I know it well)
05:23:12 <quicksilver> althought totally different.
05:23:29 <quicksilver> since one is a simple graphics wrapper and the other is a widget tookit :P
05:25:17 <rog> in Oleg's original paper, there seems to be a Show instance for HList records that prints the records with field names. does anyone know how to make this work? (it doesn't by default, AFAICS)
05:28:35 <rog> oh i see, he gives first/nextLabel a string argument. i should be able to do that. i still can't believe that those functions aren't in the package anyway.
05:30:50 <rog> i can't see how he can have different namespaces though, as surely all firstLabels will have the same type, and therefore associate with the same string. maybe it was an artifact of the previous implementation. maybe it's not now possible. hmm.
05:36:18 <dmwit_> Is there a way to get the list of packages that have profiling versions?
05:37:50 <dmwit_> Also, how come after "cabal install --global --enable-library-profiling bytestring", I still get "Could not find module `Data.ByteString.Lazy': Perhaps you haven't installed the profiling libraries for package bytestring-0.9.1.2"?
05:43:46 <dmwit_> ?hackage bytestring
05:43:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring
05:44:19 <rog> hmm. looks like you can't do it with Hackage's HList. in the original version, there are 5 implementations of labelling, only two of which allow field descriptions. (which require more template-haskell hackery to do conveniently). i don't think i'll bother!
05:47:26 <gal_bolle> @hoogle (m a -> m a) -> (ReaderT b m a -> ReaderT b m a)
05:47:26 <lambdabot> Control.Monad.Reader mapReaderT :: (m a -> n b) -> ReaderT w m a -> ReaderT w n b
05:48:47 <dmwit_> Ah, got it!
05:49:02 <explicitjelly> ok, I'm getting it all confused with SML. are binary operators in haskell always infix?
05:49:15 <dmwit_> I had bytestring installed both as user and global, and the user version didn't have the profiling libraries, and was hiding the global version, which did.
05:49:19 <dmwit_> Does this qualify as a bug? =P
05:49:25 <explicitjelly> can I not name an operator .\ and use it in a prefix manner?
05:49:29 <explicitjelly> .\ 5 3
05:49:36 <dmwit_> explicitjelly: You can, but you need to "section" it.
05:49:40 <dmwit_> > (+) 1 2
05:49:41 <lambdabot>   3
05:49:47 <dmwit_> > (+1) 2
05:49:48 <lambdabot>   3
05:49:55 <dmwit_> > (/10) 2
05:49:56 <lambdabot>   0.2
05:49:58 <explicitjelly> hmm. not sure if I want that.
05:50:01 <dmwit_> > (10/) 2
05:50:02 <lambdabot>   5.0
05:50:21 <dmwit_> explicitjelly: If you want to use it prefix, just give it a non-punctuation alias. ;-)
05:50:27 <dmwit_> > let p = (+) in p 1 2
05:50:28 <lambdabot>   3
05:50:39 <explicitjelly> I'd probably have to do that...
05:50:43 <explicitjelly> what about precedence?
05:50:54 <dmwit_> There's precedence declarations.
05:50:58 <explicitjelly> there is? nice.
05:51:25 <dmwit_> infixl 6 + -- for example
05:51:35 <dmwit_> There's also infixr and infix.
05:51:47 <explicitjelly> exactly what I need, thanks.
05:51:48 <dmwit_> l/r/blank tells associativity; the number ranges from 1-9 and tells precedence.
05:55:43 <hugo__> check this out: http://hackaday.com/2008/10/20/bjork-teaches-you-about-electronics/
05:55:45 <lambdabot> Title: Björk teaches you about electronics - Hack a Day, http://tinyurl.com/6dmq5d
05:57:19 <jeffz> hugo__: mm... nothing about haskell?
05:58:39 <hugo__> nop :P
05:58:54 <hugo__> just bjork in a high technical explanation of electronics
06:00:17 <Peaker> BeelsebobWork: Hey, how does Reactive handle loops? (Reactive values that depend directly/indirectly on themselves) Is any special casing needed for this? Can wrong hookup of reactive values cause infinite propagation of changes?
06:00:48 <BeelsebobWork> Peaker: good question -- last time I asked conal that he said he knew how to deal with it, but hadn't done it yet
06:00:54 <BeelsebobWork> I don't know if that situation has changed
06:01:05 <BeelsebobWork> I take it you're wanting to do things like recursive integrals?
06:01:38 <BeelsebobWork> camio: do you know any better than me on that front?
06:01:39 <Peaker> BeelsebobWork: I'm trying to see how to model sort of a revision control system I created before, on top of something like Reactive values
06:01:53 <BeelsebobWork> ohhh yay
06:01:54 <BeelsebobWork> tell conal
06:01:57 <BeelsebobWork> he'll get all excited
06:02:35 <Peaker> BeelsebobWork: I think its too initial to get excited about yet ;)
06:02:50 <BeelsebobWork> hehe
06:03:48 <Peaker> BeelsebobWork: I want to create a powerful code editor, and I believe revision control should be integrated (undo/redo are really just revision control).. I had a working design in Python, which was also pretty declarative, and I'm trying to see how to translate that design to Reactive
06:04:07 <BeelsebobWork> yeh, that sounds rather lovely
06:04:28 <camio> Hey Peaker. What do you mean by loops exactly? What are you trying to do there?
06:04:49 <Peaker> camio: I'm not entirely sure I have loops here, yet, I started drawing and I think I might :)
06:05:25 <Peaker> camio: basically reactive values depend on future values that may come from anywhere. The inputs of these futures may actually be outputs from that same reactive value
06:05:27 <dmwit_> Peaker: I am also interested in this.  What's your interface to revision-control-based undo/redo look like?
06:05:40 <dmwit_> (Have you thought about it?  That part seems hard to me.)
06:06:13 <camio> Peaker: That ought to work, but your going to have to think hard about laziness.
06:06:27 <Peaker> dmwit_: In the Python one, we just had global undo/redo for the simple case. We planned a DAG (mostly tree)-widget to show the revision history of any particular object that you can drag about and see animated changes as you do (similar to timelapse view in Perforce)
06:07:26 <dmwit_> Ah, that's an interesting idea.
06:07:50 <dmwit_> Since I was mostly focusing on keyboard-based interfaces, I hadn't considered the possibility of a tree widget.
06:08:14 <quicksilver> I wonder if Peaker really wants a Reactive to depend on itself, or on previous values of itself.
06:08:23 <quicksilver> the latter is fine, and there are combinators for that.
06:08:30 <quicksilver> the former you do obviously have to be careful
06:08:33 <quicksilver> (as with all recursive values)
06:08:34 <Peaker> quicksilver: I'm not sure yet I have more drawing to do ;)
06:09:10 <kowey> dcoutts: are you around?
06:09:27 <kowey> hmm... i'm guessing not with timezones
06:09:40 <Peaker> dmwit_: I think most of the revision tree will be linear (only undo/split+modification causes branching), so keyboard up/down is probably enough for most.  Then when you do have branching you can probably just use numbering or so to jump to the right one. I don't think a keyboard interface should be a problem
06:09:42 <dmwit_> ?localtime dcoutts
06:09:43 <lambdabot> Local time for dcoutts is Tue Oct 21 06:09:48
06:10:09 <kowey> so, I am working on getting some sort of reasonable darcs.cabal file
06:10:18 <dmwit_> Peaker: An intuitive keyboard interface *without a view of the hierarchy* is likely to be a problem. =P
06:10:23 <kowey> do these dependencies seem sane to people? http://hpaste.org/11360
06:10:41 <kowey> I don't really understand what the smart thing to do with package versions is
06:11:01 <kowey> I guess for some stuff, we want to have really tight requirements because we don't want any surprises (regex)
06:11:01 <Peaker> dmwit_: yeah, and the view of the hierarchy that is required is only the stuff very near the current revision
06:11:36 <Peaker> dmwit_: how did you plan to implement the UI?
06:11:51 <dmwit_> I hadn't thought of anything very good yet.
06:12:25 <Peaker> BeelsebobWork: I was thinkinga bout implementing reactive values as infinite delta streams -- which means that they are not Functor, Applicative, or Monads
06:12:30 <dmwit_> But a tree view with keystrokes for parent, next/previous sibling, and first child seems pretty reasonable.
06:12:42 <Peaker> BeelsebobWork: Maybe they can be values that contain or based on reactive values somehow, I am not sure
06:13:08 <BeelsebobWork> Peaker: why would they no longer be functors etc then?
06:13:24 <Peaker> dmwit_: yeah, when there are multiple siblings they are probably named, so you can search tags/names too
06:13:38 <quicksilver> Peaker: that sounds bogus.
06:13:38 <BeelsebobWork> the semantics of a reactive value says that it's a functor etc, so if your implementation says they aren't the implementation is wrong
06:13:54 <quicksilver> how you implement them doesn't change the fact they are Functors (for example)
06:13:55 <Peaker> BeelsebobWork: because I would like to expose an IntDelta stream as if it was a stream of ints
06:14:07 <quicksilver> being a Functor is a semantic property
06:14:14 <quicksilver> it is independent of implementation
06:14:20 <BeelsebobWork> Peaker: I don't see how that stops them being functors
06:14:20 <quicksilver> unless you've implemented something different :)
06:14:22 <Peaker> BeelsebobWork: I know, they can't be Reactive values if they are not Functor
06:14:35 <camio> Peaker: Reactive's really ought not be used. Consider using an "Event Diff" type. That, combined with an intial value can give you a "Behavior Document" type.
06:15:03 <Peaker> BeelsebobWork: If I apply fmap on a reactive delta, my function will get a delta, not an int
06:15:31 <BeelsebobWork> Peaker: hmm? the fmap applies functions to the values inside the reactive
06:15:34 <BeelsebobWork> not to the time values
06:16:01 <quicksilver> if you imagine a Reactive as an initial value plus a stream of 'deltas'
06:16:21 <Peaker> BeelsebobWork: I should have used a different example.  I want to represent an animation as a (Reactive ImageDiff) rather than (Reactive Image)
06:16:40 <BeelsebobWork> oh, well that's still a functor
06:16:43 <quicksilver> I'm pretty sure you mean (Event ImageDiff)
06:16:48 <BeelsebobWork> just functor has a less useful meaning
06:16:51 <quicksilver> (Reactive ImageDiff) probably doesn't make sense.
06:17:02 <geezusfreeek> Peaker: in the implementation of fmap you would basically have to convert to the non-delta version and back again
06:17:08 <Peaker> quicksilver: Yeah, you're right
06:17:32 <camio> Peaker: accumE on your Event Diff will produce an Event Image.
06:17:37 <Peaker> BeelsebobWork: you won't be able to fmap it as if it was an image stream, you'll be exposed to the fact its a diff stream
06:18:05 <BeelsebobWork> Peaker: yes -- but that's nothing to do with reactive -- that's to do with your choice of data structure to put in the Event
06:18:12 <Peaker> camio: lets say that for efficiency reasons, I want to deal with images only via diffs, always
06:18:13 <BeelsebobWork> and as camio says, you can use accumE
06:19:10 <BeelsebobWork> Peaker: it's still a functor -- just fmap isn't such a useful function when talking about deltas rather than each value
06:19:10 <Peaker> BeelsebobWork: Well, if I'm willing to expose the fact I'm using diffs to all the code, I guess there's little problem
06:19:13 <camio> Peaker: That efficiency I would expect to be in your Image data structure, not in the behavior.
06:21:04 <Peaker> BeelsebobWork: Another thing that I'm trying to solve/think about, is how to save the minimal amount of data that can still reproduce all the values that I want. Lets say my revision control is implemented via a Reactive value that contains the history of an object. If I store the entire history tree/DAG with all of the diffs, I may be storing a lot more data than just storing whatever is needed to regenerate the reactive inputs that built that tree
06:21:26 <BeelsebobWork> sure
06:21:41 <BeelsebobWork> but that just means you have to think very carefully about the function you want to fmap
06:21:41 <Peaker> So another thing I am wondering about, is how to have a Reactive value that can also retain history in some way, perhaps
06:21:54 <BeelsebobWork> it's equivalent to saying that list is no longer a functor because fmap isn't useful when you store a list of diffs
06:21:55 <BeelsebobWork> > scanl1 (+) (fmap (`div` 2) [1,1..])
06:21:56 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:22:26 <Peaker> BeelsebobWork: Yeah, I was operating under the assumption that the diffs are hidden from the framework user
06:22:27 <BeelsebobWork> > fmap (`div` 2) $ scanl1 (+) [1,1..]
06:22:28 <lambdabot>   [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,...
06:22:48 <BeelsebobWork> sure -- so at some point you're gonna need to run that accum/scan
06:22:53 <quicksilver> I think this may be a complete mis-use of Reactive.
06:23:01 <quicksilver> Reactive is for values which change in "real time"
06:23:12 <quicksilver> your talking about values which change according to some "abstract time"
06:23:13 <BeelsebobWork> quicksilver: I'm not sure that's true
06:23:20 <quicksilver> (that is, revision history)
06:23:25 <BeelsebobWork> I don't think that reactive has any notion of what time means
06:23:27 <quicksilver> BeelsebobWork: I'm not sure, that's why I said "may"
06:23:35 <Peaker> quicksilver: the revision history is indeed not a Reactive value history, that part is clear
06:23:38 <BeelsebobWork> in fact, in the semantics it doesn't have any notion of time -- only of ordering
06:23:45 <quicksilver> with explicit access to the past
06:23:54 <quicksilver> (a pretty fundamental notion in RCSes)
06:24:06 <quicksilver> I think that's a sufficiently different set of constraints from that which motivated Reactive
06:24:12 <quicksilver> that the same solution may not apply.
06:24:14 <Peaker> quicksilver: I was thinking of an explicit History type (for example containing a tree of diffs) used as: (Reactive History)
06:24:35 <quicksilver> I"m not tring to discourage and I'm by no means sure I'm right.
06:24:40 <quicksilver> just pointing out the key differences
06:25:12 <Peaker> quicksilver: Well, the idea is that the history is built and viewed in "real time" by UI operations.  The history value itself contains notions of abstract time, but those are manipulated in real time
06:26:20 <Axman6> what would be a good hackage category for an (ARM) emulator?
06:26:42 <quicksilver> Peaker: OK, well I don't think I have a clear enough view of what you want?
06:26:57 <quicksilver> are the reactives grounded in abstraact time or real time?
06:27:04 <Peaker> quicksilver: Real time
06:27:06 <quicksilver> (this may be my own stupidity impeding communication)
06:27:17 <Peaker> quicksilver: Think about a real time editor, that just happens to try to retain a history of all the editing
06:27:49 <quicksilver> Ah. Now you're talking.
06:28:09 <Peaker> quicksilver: now, this editor has a little inefficiency problem:  It wants to be able to serialize the complete history (or what's necessary to get that history later)
06:28:45 <Peaker> quicksilver: I can easily envision the smallest data that makes that possible as the keyboard event stream, as an example, which was the input to the generation of that history in the first place
06:29:47 <Peaker> quicksilver: Serializing the history itself may be easy, but may be very wasteful, if its a reactive value that is computed from other much smaller reactive values (a small reactive value is one whose entire stream integrates to a smaller serialization)
06:30:10 <Saizan> Axman6: Compilers/Interpreters looks like the closest
06:30:17 <inimino> usually people don't care about (and don't want to be able to undo) individual keystrokes
06:30:25 <Axman6> sounds good to me :)
06:30:32 <quicksilver> Peaker: I agree that is a an interesting problem domain ;)
06:30:48 <Peaker> inimino: I often want to undo a couple of keystrokes. I agree that for old key strokes, you can lower the granularity of undo
06:31:46 <inimino> Peaker: that's what backspace is for ;-)
06:31:57 <Peaker> quicksilver: Maybe I want something like HistoricReactiveValue -- that also generates a serialization stream that can regenerate all of its history later
06:32:08 <inimino> but lowering the granularity after some time works too
06:32:09 <Axman6> hmm...
06:32:09 <Axman6> Distribution quality errors:
06:32:09 <Axman6> 'license: MIT' is not a recognised license.
06:32:10 <Axman6> Note: the public hackage server would reject this package.
06:32:28 <quicksilver> Peaker: I think you will want to use some kind of domain-specific compression on the history.
06:32:30 <Axman6> that's the licence the author wants used
06:32:33 <Axman6> s*
06:32:49 <quicksilver> Peaker: so a totally general solution would be hard.
06:33:36 <scook0> there's always OtherLicense I guess
06:33:52 <Peaker> quicksilver: Yeah, I might want different types of reactive values that can serialize things differently
06:34:04 <Peaker> quicksilver: ideally, they could also choose to serialize themselves or their inputs, according to which is cheaper to store
06:34:37 <Peaker> quicksilver: It means I need sort of historic reactive values that are completely aware of what their inputs are, can ask questions such as "what's the serialization size of my inputs, and of me", etc
06:34:49 <Peaker> Which does not sound to me like it is a Reactive value at all, but perhaps it can be based on one
06:34:50 <jeffersonheard> anyone have a suggestion for making a [CString] into a Ptr CString ?  That is, a char **?
06:37:19 <Axman6> scook0: cheers, seems to work fine
06:37:24 <Saizan> jeffersonheard: Foreign.Marshal.Array.newArray
06:38:14 <jeffersonheard> right, I should have known that
06:54:23 <osfameron> gah, I just read first 2 chapters of to mock a mockingbird: I think the part of my brain that used to like and be able to do puzzles is broken :-(
06:55:34 <dmwit_> Gah.  This memory profiling is useless.
06:55:39 <dmwit_> How do people find space leaks?
06:55:56 <BeelsebobWork> dmwit_: pretty-hat
06:56:01 <Zao> Magic.
06:56:06 <dmwit_> pretty-hat?
06:56:09 <EvilTerran> submerge the universe in water and see where the bubbles are leaking out from
06:56:21 <jeffersonheard> dmwit_, if all else fails, strictify things incrementally and THEN use the memory profiler
06:56:33 <jeffersonheard> it's a pain, but it's worked for me in the past
06:56:40 <BeelsebobWork> dmwit_: one of the Hat tools that draws heap-graphs
06:56:49 <BeelsebobWork> all you need to do is spot what's landed everywhere on the graph
06:56:54 <EvilTerran> ?where hat
06:56:54 <lambdabot> http://www.haskell.org/hat/
06:56:57 <dmwit_> It takes half an hour to get a reasonably representative profiling.  I don't want to repeat this too many times...
06:57:15 <dmwit_> Also, I've never gotten Hat to work on any sizable program. =/
06:57:42 <BeelsebobWork> the only gotchas with hat are (a) don't use extensions (b) where defaulting comes in, you're gonna have to manually specify the type
06:58:01 <dmwit_> I'm using ST; so I guess (a) is right out.
06:58:09 <scook0> those are some massive freaking gotchas
06:58:21 <BeelsebobWork> yep, but (a) is fairly unavoidable
06:58:27 <BeelsebobWork> and (b) is fairly easy to sort out
06:58:41 <dmwit_> I'm happy specifying type annotations, yeah.
06:58:52 <BeelsebobWork> (a) actually is a semi-lie -- it's actually a don't use extensions that need the parser to change
06:59:07 <BeelsebobWork> (or even more accurately, don't use extensions that need the parser to change, and nhc doesn't support)
06:59:50 <Arnar> hi all
07:00:04 <Arnar> why can't I do ":m +Debug" in ghci?
07:00:04 <dmwit_> Alright, I'll give it a go...
07:00:08 <Saizan> BeelsebobWork: does hat use its own frontend or works on yhccore or?
07:00:13 <dmwit_> Arnar: Because Debug isn't a module?
07:00:19 <dmwit_> Arnar: Maybe you want Debug.Trace.
07:00:36 <dmwit_> Arnar: See also :m + Debug<TAB>
07:00:47 <Deewiant> dmwit_: but not on Windows
07:00:48 <BeelsebobWork> Saizan: Hat uses a source-to-source transform to create a program that traces itself
07:01:05 <Arnar> dmwit_: ah.. yes, I want Debug.Trace -- :index was confusing me
07:01:18 <EvilTerran> BeelsebobWork, ah, sounds like something you could do in TH
07:01:25 <BeelsebobWork> possible that
07:01:31 <Arnar> but tab-comletion doesn't seem to work in emacs :/
07:01:32 <dmwit_> hmake??
07:01:41 <BeelsebobWork> dmwit_: yep, it's from pre-cabal
07:01:47 <EvilTerran> actually, it'd have to be whole-program analysis, wouldn't it?
07:01:50 <BeelsebobWork> hat hasn't had any funding since cabal came about
07:02:02 <BeelsebobWork> EvilTerran: no, it can be done locally on a per-function basis
07:02:13 <EvilTerran> i guess
07:02:24 <dmwit_> hmake: The compiler 'ghc' is unknown. Stop.
07:02:24 <EvilTerran> you just wouldn't be able to introspect stuff TH couldn't look at
07:02:25 <dmwit_> =/
07:02:33 <BeelsebobWork> dmwit_: :/
07:02:40 <BeelsebobWork> worksforme
07:02:47 <BeelsebobWork> so I dunno what you're hitting there
07:03:01 <BeelsebobWork> EvilTerran: I believe  that some of the yhc team were planning on making yhc able to produce self-tracing code
07:03:04 <BeelsebobWork> or more accurately
07:03:07 <BeelsebobWork> make a tracing runtime
07:03:13 <BeelsebobWork> but I don't know how far that got
07:03:21 <EvilTerran> that'd make sense
07:03:53 <BeelsebobWork> the big problem with extensions is that every time someone dreams up a new one, you need to think up a little extension to the trace file format too
07:04:08 <BeelsebobWork> which is rather a pita
07:04:09 <EvilTerran> it'd be nice to be able to write $(trace [| ... |]) and have it logged hat-style
07:04:21 <EvilTerran> just for little bits of your code here-and-there
07:04:24 <Arnar> can "let" expressions in ghci not be polymorphic?
07:04:29 <BeelsebobWork> yeh, that *would* be nice
07:04:48 <dmwit_> http://hpaste.org/11361 a question about memory
07:04:52 <BeelsebobWork> last I checked malcolm wallace had plans to make hat-traced code able to link against non-hat-traced
07:05:00 <BeelsebobWork> but again, I don't know how far that got
07:05:01 <Saizan> Arnar: you're being bitten by the dreaded monomorphism restriction, probably
07:05:12 <scook0> Arnar: :set -fno-monomorphism-restriction
07:05:29 <scook0> hope your tab-completion works for that one :)
07:05:43 <Arnar> Saizan, scook0: yup.. that was it
07:05:46 <Arnar> scook0: hehe, nope :)
07:05:52 <EvilTerran> or :set -XNoMonomorphismRestriction
07:06:04 <EvilTerran> -X is trendier than -f
07:06:05 <EvilTerran> :P
07:06:21 <rog> how do people get around the monomorphism restriction when it's impractical to write out the types?
07:06:21 <Arnar> EvilTerran: any difference besides the spelling?
07:06:24 <scook0> crazy 6.8 people! I'll upgrade one of these days... ;)
07:06:28 <augustss_> and LANGUAGE is even trendier
07:06:31 <EvilTerran> Arnar, no, don't think so
07:06:40 <scook0> rog: by turning it off, I'd imagine
07:06:44 <rog> i'm currently being bitten. and the type of my function is: HCons (LVPair HZero (Const Integer)) (HCons (LVPair (HSucc HZero) (Const Double)) (HCons (LVPair (HSucc (HSucc HZero)) DNormal) (HCons (LVPair (HSucc (HSucc (HSucc HZero))) DNormal) (HCons (LVPair (HSucc (HSucc (HSucc (HSucc HZero)))) (Const Double))
07:06:47 <rog> :-)
07:06:50 <Deewiant> O_O
07:06:55 <Arnar> dude
07:06:56 * EvilTerran thinks -XMPTCs and -XNoDMR as short-form names for -XMultiParameterTypeClasses and -XNoMonomorphismRestriction
07:06:59 <EvilTerran> would be nice
07:07:10 <Deewiant> EvilTerran: DMR? heh.
07:07:13 <EvilTerran> rog, er, use some "type"s to make that manageable?
07:07:15 <dmwit_> rog: {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file. ;-)
07:07:21 <Arnar> EvilTerran: why DMR?
07:07:27 <Deewiant> Dreaded, I imagine
07:07:27 <quicksilver> Dreaded
07:07:28 <Arnar> "dreaded" ?
07:07:28 <EvilTerran> "type HOne = HSucc HZero" etc
07:07:33 <EvilTerran> yup, dreaded :P
07:07:41 <dmwit_> "Damn"
07:07:47 <rog> EvilTerran: can't really, as the types are all inferred from the HList data constructors.
07:08:04 <rog> EvilTerran: if i wrote out the types, i'd lose code flexibility
07:08:13 <EvilTerran> rog, you can still have aliases for HOne, HTwo, etc, surely?
07:08:51 <Saizan> also :=: for LVPair
07:08:56 <rog> EvilTerran: ... but HZero just *happens* to be the type of the first field i've declared.
07:09:00 <Saizan> and :*: for HCons
07:09:03 <EvilTerran> ah
07:09:40 <EvilTerran> i imagine you're using some ghc extension or three already
07:09:47 <rog> EvilTerran: if i changed the field order (and it is totally arbitrary), all my code breaks.
07:09:56 <EvilTerran> in which case throwing in -XNoMR is forgivable
07:10:18 <Saizan> rog: that's possibly a reason to use named rather than numbered labels
07:10:29 <rog> EvilTerran: well, of course. HList uses most extensions in the book (despite what the paper says).
07:10:55 <rog> Saizan: i have to use numbered labels - that's the hinge on which the entire of HList records turn.
07:11:41 <rog> i was just under the impression that relaxing the M.R. might be dangerous...
07:11:53 <Deewiant> not at all
07:11:59 <Saizan> rog: well, you've seen that there are 5 different solutions for labels? and all of them work with HList's Record
07:12:02 <rog> that's ok then
07:12:06 <Deewiant> hell, it's going to be removed from haskell'
07:14:06 <rog> Saizan: but they all use type-numbering. the names are just a convenience, i think.
07:14:56 <rog> i'll just use noMMR :-)
07:18:14 <Saizan> rog: 4 and 5 don't *shrug*
07:18:56 <rog> 4 and 5 don't have labels
07:19:29 <rog> (well, not in the same way)
07:20:50 <rog> ahh, i see the point of label5 now. namespaces are easy; i can start from any old data declaration, not just HZero. cunning.
07:21:43 <rog> BTW, if anyone's curious, i got my code working; it's at http://hpaste.org/11362#a0
07:21:51 <rog> comments very welcome!
07:23:56 <quicksilver> rog: comment: how do I make the hurting stop?
07:24:03 <quicksilver> (that's the effect HList code generally has on me ;P)
07:24:42 <rog> quicksilver: i've come from a place where i was hurting deeply to one where i think i *almost* like it.
07:24:48 <quicksilver> seems nice apart from that.
07:25:15 <rog> :-)
07:25:42 <younder> The Haskell syntax still drives me crazy some times..
07:25:49 <dmwit_> Man, I wish for a monadic case.
07:26:14 <dmwit_> mcase foo of {xs} ==> foo >>= \tmp -> case tmp of {xs}
07:26:31 <EvilTerran> monadic subexpressions would do that
07:26:38 <EvilTerran> case (<- foo) of ....
07:26:50 <rog> quicksilver: you wouldn't believe the amount of (error-prone) code that that code will replace...
07:26:52 <dmwit_> o_O
07:26:52 <EvilTerran> and "if (<- foo) then ..." and so on
07:27:01 <dmwit_> Ah!
07:27:02 <Deewiant> EvilTerran: oh, you've had that idea too? :-P
07:27:10 <Deewiant> or is that well-known somehow
07:27:11 <quicksilver> everyone has that idea once.
07:27:13 <EvilTerran> Deewiant, what, monadic subexpressions? that's not my idea
07:27:14 <dmwit_> That's kind of neat.
07:27:16 <quicksilver> even SPJ.
07:27:23 <EvilTerran> someone talked about them at anglohaskell 07
07:27:27 <dmwit_> That's harder to parse, though, I guess.
07:27:29 <Deewiant> I had that idea with that exact syntax a month or two ago
07:27:39 <Deewiant> and am still thinking that if I ever hack GHC it'll be to implement that.
07:27:39 <EvilTerran> (with that syntax)
07:27:40 <quicksilver> eventually they are forced to realise it's a descent into a fruitless desert of semantic nonsense.
07:27:57 <quicksilver> or maybe I meant syntactic nonsense.
07:27:57 <Deewiant> Heh. How's that?
07:27:57 * rog had that idea too, of course.
07:28:03 <sheijk> uhm, ist there any support for glDrawPixels in HOpenGL? i can only find readPixels and copyPixels..
07:28:08 <EvilTerran> quicksilver, well, the existing suggestions do. i think, with a little tweaking, it could work
07:28:18 <quicksilver> a fruitless dessert of semantic nonsense, sprinkled with chocolate bits of syntactic nonsense.
07:28:23 <EvilTerran> quicksilver, ie, you'd need some kind of indicator to say "the following MSEs go here"
07:28:38 <Deewiant> What's so wrong with it?
07:28:38 <quicksilver> yes.
07:28:42 <EvilTerran> "do <-; case (<- foo) of ...; if (<- bar) then ..."
07:28:45 <EvilTerran> or something
07:29:02 <quicksilver> Deewiant: choosing which of the (potentially many) enclosing monadic scopes to execute them in.
07:29:15 <Arnar> sorry for the noobism.. but if I have WriterT t (STM a)  -- what's the proper way to lift operations like orElse ?
07:29:20 <Deewiant> I'd just pick the innermost
07:29:30 <EvilTerran> i was thinking either "do <-" as a new way of opening a do-block, meaning "MSEs de-sugar to the line above where they appear in this block"
07:29:36 <quicksilver> Deewiant: then you break equational reasoning.
07:29:49 <Deewiant> how's that
07:30:06 <quicksilver> do { a ; do { b ; c} }
07:30:13 <quicksilver> is no longer equivalent
07:30:16 <quicksilver> to do {a ; b ; c}
07:30:23 <EvilTerran> or "<-;" as a do-block line in their own right, meaning "MSEs between this <-; and the next <-; go here"
07:30:44 <Saizan> Arnar: e.g. m `mplus` n = WriterT $ runWriterT m `mplus` runWriterT n
07:30:52 <EvilTerran> or even <- at the start of a do-block line meaning MSEs from that line go there
07:30:58 <EvilTerran> that would work well, actually
07:31:11 <Arnar> Saizan: right, makes sense.. thanks
07:31:14 <EvilTerran> "do <- do ..." would put all the MSEs in the inner do block at the top
07:31:42 <Deewiant> quicksilver: I'm still not seeing it. Why wouldn't it be?
07:31:49 <EvilTerran> of it, and yet you could still have an intuitive ordering of side-effects with "do <- case (<- foo) of ...; <- if (<- bar) then ..."
07:32:21 <EvilTerran> and i think the extra syntactic noise still makes it nicer than having to think up laods of one-off names
07:32:42 <quicksilver> Deewiant: because the former would inject these monadic sub expressions after the "a"
07:32:46 <quicksilver> Deewiant: instead of before it.
07:33:16 <EvilTerran> Deewiant, it'd make "do a; (<- b)" different from "do a; do (<- b)"
07:33:27 <quicksilver> yes, for example.
07:34:16 <Deewiant> The way I see it the subexpression would be evaluated immediately prior to the expression it's in: "case (<- a)" becomes "a >>= case" and so on.
07:34:52 <quicksilver> yes. I do understand what you said, Deewiant
07:34:55 <quicksilver> ah.
07:34:59 <quicksilver> no, that's different.
07:35:03 <Deewiant> So I don't see how those two would be different.
07:35:21 <EvilTerran> in that case, "do f (<- x)" would be potentially different to "do f (do (<- x))", say
07:35:21 <quicksilver> that's another choice, yes
07:35:33 <quicksilver> and it causes different problems.
07:35:57 <quicksilver> (similar idea, slightly different example)
07:36:08 <quicksilver> it's all about exactly where you insert the action
07:36:08 <EvilTerran> in that x might get run repeatedly, or not at all, in the second version
07:36:20 <EvilTerran> quicksilver, hence my suggestion that an explicit marker for such be added
07:36:28 <quicksilver> and how that breaks equatioanal rewriting of do expressions.
07:37:26 <quicksilver> EvilTerran: yes, that solves it in a sense.
07:37:27 <Deewiant> okay, true. I was originally thinking of this only for "case" and "if", though.
07:37:45 <Deewiant> in which case I don't think it could break anything.
07:37:53 <quicksilver> Deewiant: special cases for those two constructs are not problematic, no.
07:38:00 <quicksilver> the interesting problems are thinks like
07:38:17 <Deewiant> Maybe for guards as well.
07:38:26 <quicksilver> f (g (<- foo)) (h a b (<- bar) c) (j (do c x (<- baz)))
07:38:35 <Arnar> in ghci, is there a way to persist my "let"-defined stuff across :load-s ?
07:38:48 <Deewiant> Arnar: aside from putting them in a file, no.
07:39:05 <Arnar> Deewiant: ok.. I guess it makes sense as they might refer to thunks from the old module
07:39:08 <quicksilver> use your commandline history :)
07:39:16 <quicksilver> Arnar: and types from the old module, too
07:39:19 <Arnar> quicksilver: yeah.. that's my current method :)
07:39:35 <quicksilver> ocaml allows it and gives you weird errors like
07:39:41 <quicksilver> "type Foo does not match type Foo"
07:39:42 <Arnar> btw.. I'm trying to get used to emacs - any way to search in the command line history there?
07:39:53 <quicksilver> C-r and M-R
07:40:00 <quicksilver> sorry, small "r" in both cases
07:40:25 <Arnar> quicksilver: ah.. M-r is exactly what I wanted
07:40:30 <Arnar> thx
07:49:11 <dons> woo. http://www.reddit.com/r/programming/comments/78fxq/keep_your_cores_busy_ghcs_new_vectorisation_pass/
07:49:12 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
07:49:20 <lambdabot> Title: Keep your cores busy! GHC's new vectorisation pass for automatic parallel nested ..., http://tinyurl.com/54qg7j
07:49:39 <EvilTerran> ...
07:49:43 <EvilTerran> "YOU BROKE REDDIT"
07:49:50 <EvilTerran> "you've done enough damage, please don't hit reload"
07:49:51 <tibbe> dons: will read the paper tomorrow :)
07:49:59 <dons> EvilTerran: huh.
07:50:03 * EvilTerran hits reload
07:50:09 <dons> EvilTerran: works for me
07:50:10 <EvilTerran> ... and it worked. phew.
07:50:15 <dons> yo tibbe
07:50:31 <tibbe> dons: how are things?
07:50:34 * tibbe is home sick
07:50:34 <EvilTerran> ... reddit sends me to a blog post, sends me to an abstract
07:50:38 <thoughtpolice> hi tibbe
07:50:43 <EvilTerran> circles within circles!
07:50:44 <dons> EvilTerran: and to a .pdf!
07:50:46 <tibbe> thoughtpolice: hey :)
07:51:32 <thoughtpolice> tibbe: how goes the code?
07:52:04 <idnar> so is that already in GHC?
07:52:09 <dons> yeah, in ghc 6.10
07:52:21 <dons> 'technology preview' (i.e. alpha), but it's in.
07:52:37 <dons> so add yet another way to write multicore programs to the pile
07:52:54 <tibbe> thoughtpolice: code goes well, still hacking on hyena whenever I get the time
07:53:04 <JaffaCake> dons: I've just been putting together a little parallelism benchmark suite
07:53:04 <tibbe> thoughtpolice: had to rethink some stuff but it's getting there
07:53:10 <thoughtpolice> tibbe: fun :]
07:53:10 <EvilTerran> we seem to be accumulating concurrency paradigms at a fantastic rate
07:53:13 <JaffaCake> ghc 6.10.1 is ~10% faster on 4 cores than 6.8.3
07:53:13 <thoughtpolice> idnar: http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTreesDPH
07:53:16 <dons> JaffaCake: we needs it. there was a SoC proposal for this too
07:53:17 <lambdabot> Title: Shootout/Parallel/BinaryTreesDPH - HaskellWiki
07:53:19 <younder> Excuse my ignorance, but what is a multicore program?
07:53:30 <thoughtpolice> idnar: i'm going to try to get around to moving more of the parallel shootout benchmarks to DPH sometime this week
07:53:31 <dons> JaffaCake: huh... we should try the shootout quad core programs
07:53:37 <EvilTerran> especially compared to imperative languages that've been stuck on mutexes, semaphores, and streams for who knows how long
07:53:38 <JaffaCake> yeah
07:53:51 <JaffaCake> I was able to get a little speedup on binary-trees, but not much
07:53:58 <dons> binary-trees is a pain on quad core :)
07:54:09 <dons> with the 'no disable gc' rule
07:54:23 <JaffaCake> parallel gc can help a bit
07:54:36 <dons> oh, we can try that in the head now?
07:54:42 <JaffaCake> also, 6.10.1's GC is faster even single-threaded
07:54:48 <dons> mmm. awesome
07:55:10 <younder> Ok so the GC handles multiple cores
07:55:17 <thoughtpolice> younder: a program which utilizes multiple processor cores - like GHC can create :]
07:56:04 <younder> gotcha
07:56:23 <thoughtpolice> younder: the GC is now parallel but taking advantage of multiple cores is part of the RTS
07:56:25 <tibbe> I want to see some benchmarks on programs that are embarrassingly parallel
07:56:29 <tibbe> i.e. easy to paralyze
07:56:40 <EvilTerran> ... i think you mean parallelize
07:56:50 <tibbe> yes...
07:56:53 <younder> lol
07:56:53 <dons> tibbe: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
07:56:55 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
07:57:01 <dons> some are easy, some are hard (and some are not parallelised)
07:57:04 <EvilTerran> @wn paralyse
07:57:05 <lambdabot> *** "paralyse" wn "WordNet (r) 2.0"
07:57:07 <lambdabot> paralyse
07:57:09 <lambdabot>      v 1: make powerless and unable to function; "The bureaucracy
07:57:11 <lambdabot>           paralyzes the entire operation" [syn: {paralyze}]
07:57:12 <JaffaCake> tibbe: I have some...
07:57:13 <lambdabot>      2: cause to be paralyzed and immobile; "The poison paralyzed
07:57:16 <lambdabot>         him"; "Fear paralyzed her" [syn: {paralyze}]
07:57:35 <younder> don't rub it in..
08:00:35 <tibbe> dons: I was more thinking of something map/reduce like
08:00:42 <tibbe> dons: written with parallelism in mind
08:00:52 <idnar> are there ghc 6.10 snapshots somewhere, or should I just whip out darcs?
08:01:14 <tibbe> dons: to see how much performance we can get when in theory you could get close to 4x speed-up for e.g. 4 cores
08:01:17 <younder> Ok like google's map-reduce algorichm?
08:01:40 <dons> there's benchmarks for thos kind of things in the dph suite (and papers)
08:01:43 <Zao> idnar: http://www.haskell.org/ghc/dist/stable/dist/
08:01:44 <lambdabot> Title: Index of /ghc/dist/stable/dist
08:01:47 <younder> http://labs.google.com/papers/mapreduce.html
08:01:48 <lambdabot> Title: Google Research Publication: MapReduce
08:01:50 <tibbe> younder: like a program you would write using map-reduce
08:01:56 <tibbe> lunch time!
08:02:46 <nicknull> @seen spj
08:02:46 <lambdabot> I haven't seen spj.
08:02:58 <nicknull> @seen simonpj
08:02:59 <lambdabot> I haven't seen simonpj.
08:03:03 <nicknull> @seen simon-pj
08:03:04 <lambdabot> I haven't seen simon-pj.
08:03:11 <Taggnostr> is the 'if' special or it is like all the other function (if it's a function)?
08:03:22 <EvilTerran> nicknull, SPJ doesn't come in here, as far as i know
08:03:34 <EvilTerran> nicknull, but he does post to the mailing lists
08:03:58 <EvilTerran> ...
08:04:19 <int-e> Taggnostr: 'if' is part of the language syntax
08:04:30 <abbe> hi all, any xmonad hackers here ?
08:04:49 <Taggnostr> instead in lisp, is it a normal function?
08:04:55 <int-e> > let if' p a b = if p then a else b in if' True 0 1
08:04:58 <lambdabot>   0
08:05:00 <EvilTerran> Taggnostr, it's special syntax, however, you could write "cond True tru fls = tru; cond False tru fls = fls" and it'd have exactly the same properties
08:05:03 <EvilTerran> aside from syntax
08:05:09 <EvilTerran> Taggnostr, isn't it a macro in lisps?
08:06:10 <Taggnostr> I don't really know lisp, but I know that you call it as you call the other function, like (if cond tru fls)
08:06:29 <quicksilver> Taggnostr: lisp doesn't syntactically distinguish between functions and forms
08:06:34 <quicksilver> (one of the things I find confusing about lisp)
08:06:39 <ski> `if' usually is a special form in lisps
08:06:40 <Taggnostr> whereas in haskell there are then/else in between
08:06:45 <quicksilver> where a  "form" can be a macro, or something special and built in.
08:06:56 <ski> special forms can either be primitive ones, or defined ones (macros)
08:06:58 <younder> special-form-p
08:07:50 <ski> (in agda2 `if_then_else' is a defined function :)
08:07:58 <int-e> Taggnostr: Haskell would work just fine without 'if' - you can use 'case' to implement the functionality.
08:08:10 <Taggnostr> btw we were discussing about "pure-OO", and I was trying to understand if *everything* (that is, including if/for and other things) have to be an object
08:08:22 <EvilTerran> "case p of True -> x; False -> y"
08:08:58 <Taggnostr> I know that you can do it with (+) and (-) for example in haskell but you can't in other languages
08:10:02 <Taggnostr> like in "let abs n = (if n > 0 then (+) else (-)) 0 n in abs (-3)"
08:10:20 <BMeph> Haskell: Where other languages imitate case statements with nested ifs, we decided to cut to the chase. ;)
08:10:47 <ski> (s/chase/cheese/ ?)
08:11:24 <int-e> unsaferPerformIO launchRocketToMoonAndGetCheese
08:11:43 <EvilTerran> heh, "unsafer"
08:11:59 <int-e> woops, that wasn't even intentional :)
08:12:10 <younder> BMeph: Common Lisp
08:12:13 <ski> Taggnostr : i'm not sure what you're here claiming haskell can do, but not others ?
08:12:34 <Taggnostr> "return" + or -
08:12:51 <ski> MLs, Lisps sure can do that
08:12:55 * EvilTerran ponders the practicality of defining the semantics of a language with algebraic data types and case statements in terms of de-sugaring to CPS
08:12:57 <Taggnostr> yep
08:12:57 <younder> (the special-form-p was a glip. should go to #lisp)
08:13:05 <ski> probably several others i don't care to think of, too
08:13:07 <Deewiant> the definition of a functional language is pretty much the ability to do that :-P
08:13:31 <Taggnostr> but you can't with python for example
08:13:47 <EvilTerran> well, you can do something similar, but it's less direct
08:14:04 <EvilTerran> (+) would look like (lambda x, y: x + y) or something
08:14:32 <dblazakis> i think there's an operator library in python that gives you functions for many of the operators
08:14:45 <Taggnostr> yep, but you can return the + itself
08:14:52 <Deewiant> EvilTerran: can you return a lambda?
08:14:54 <EvilTerran> dblazakis, i'd've expected you to be able to get those out of the standard stuff with introspection
08:15:11 <EvilTerran> Deewiant, i think so. i'm not a python programmer, i just talk to them frequently
08:15:12 <Taggnostr> and yes, you can return a lambda
08:15:31 <ski> let l = \ in l x -> x*x
08:15:35 <EvilTerran> Taggnostr, it's indistinguishable for just returning (+), though
08:15:41 <EvilTerran> *from just
08:16:27 <Taggnostr> you can actually do foo(1,2) where foo returns (lambda x, y: x + y) or (lambda x, y: x - y)
08:17:04 <idnar> the main thing is that operators in Python aren't functions
08:17:04 <Taggnostr> but you can't do it with the + itself because it's not a "normal function" but it's something special
08:17:24 <idnar> they're special syntax that gets compiled down to a complex sequence of method invocations
08:17:25 <dblazakis> they are
08:17:38 <dblazakis> __iplus__
08:17:40 <dblazakis> or something like that
08:17:49 <idnar> yes, but x + y isn't equivalent to x.__add__(y)
08:17:53 <idnar> it's more like
08:18:10 <ski> (in O'Caml, constructors are not expressions by themselves, either .. so you need to eta-expand to pass them anywhere)
08:18:21 <quicksilver> (I hate that about ocaml)
08:19:05 <idnar> result = x.__add__(y); if result is NotImplemented: result = y.__radd__(x); if result is NotImplement: raise TypeError("unsupported operand type(s) for +: '%s' and '%s'" % (type(x), (type(y)))
08:19:16 * quicksilver nods.
08:19:18 <dblazakis> idnar: ahh
08:19:19 <hugo__> idnar: isn't that a good thing ?
08:19:27 <quicksilver> in some ways yes, in someways no.
08:19:28 <Cale> That is something which I've found baffling about the vast majority of programming languages, even long before I'd learned about Haskell or functional languages. Mathematical operators are just functions like any other, why treat them so differently just because they have slightly different syntax?
08:19:29 <idnar> oh, sorry, include some try:/except AttributeError: there
08:19:44 <idnar> that's mainly necessary because python doesn't have multimethods
08:19:44 <quicksilver> typeclasses are a much nicer answer for (+)
08:19:49 <quicksilver> than OO methods.
08:19:57 <hugo__> :)
08:20:09 <hugo__> i always have difficulty explaining type classes to my friends
08:20:11 <idnar> you don't need (+) and (r+) in Haskell, for example, because the first argument to (+) isn't any more special than the second argument
08:20:15 <ski> (Cale : the lisp answer is to (mostly) deny them special syntax :)
08:20:15 <quicksilver> dual/multiple dispatch tends to be clumsy.
08:20:56 <dblazakis> in any case, the operator library exports the actual add function, that *is* equivalent to +
08:20:58 <Cale> ski: well, yeah, functional languages tend to take enlightened approaches to things.
08:21:14 <idnar> dblazakis: it's not "the actual add function", it's just a function that invokes the + operator
08:21:19 <Taggnostr> how can you tell to (+) how to add two things that I defined in some fancy way?
08:21:32 <dblazakis> idnar: how is that different?
08:21:35 <Cale> Taggnostr: in Haskell?
08:21:38 <Taggnostr> yes
08:21:49 <EvilTerran> idnar, they're equivalent, if not necessarily equal in terms of implementation
08:21:49 <Cale> Taggnostr: by defining an instance of the typeclass Num
08:21:52 <idnar> dblazakis: calling it the "actual" add function makes it sound like operator.add is somehow involved in the evaluation of the code "x + y"
08:21:55 <Cale> instance Num MyType where
08:22:02 <Cale>   x + y = ...
08:22:12 <Cale>   ... other numeric operations ...
08:22:30 <idnar> I'm just being picky about it because that's not the case
08:22:42 <idnar> ie. operator.add is implemented in terms of the + operator, not vice-versa
08:23:00 <dblazakis> idnar: gotcha
08:23:18 <Cale> Note that this includes an operation fromInteger, which specifies how integer literals get converted to your fancy type as well, which is rather nice (though it would be nicer still if the typeclass hierarchy was a bit finer here)
08:23:29 <idnar> whereas in Haskell, ((+) x y) and (x + y) are syntactically equivalent
08:23:36 <dons> ?users
08:23:36 <lambdabot> Maximum users seen in #haskell: 539, currently: 521 (96.7%), active: 20 (3.8%)
08:24:14 <Taggnostr> but assume that I define my type that is a string, I create 2 vars of that type, say, 'foo' and 'bar' and I want to have 'fboaor' when I add them, how can I tell to (+) that I want 'fboaor' as result of 'foo' + 'bar'?
08:24:33 <Cale> instance Num String where
08:24:40 <Deewiant> (+) = interleave
08:25:04 <Deewiant> modulo the fact that you can't do that
08:25:08 <therp> any idea how to elegantly use combinators to construct \(a,b) (a',b) -> (a+a',b+b') ?
08:25:18 <Deewiant> because 'instance Num String' is an error
08:25:18 <Cale>   [] + ys = ys; (x:xs) + ys = x : (ys + xs)
08:25:31 <Cale> Deewiant: oh?
08:25:36 <Cale> Am I that tired?
08:25:53 <Deewiant> Cale: Isn't it? It's why we don't have instance Show String, but rather the showList function
08:26:03 <Cale> Oh, in Haskell 98.
08:26:03 <EvilTerran> he's got a point
08:26:07 <Deewiant> Making a newtype would be fine.
08:26:11 <Taggnostr> I don't get why there's a 'Num' there if I only have strings
08:26:13 <Cale> Nobody cares about Haskell 98 anymore though.
08:26:27 <Deewiant> I'll say this for the second time today: I do. ;-)
08:26:57 <Deewiant> I'm like this kitty: http://arcanux.org/lambdacats/undecidable.jpg
08:27:01 <Cale> Taggnostr: Num is the name of the typeclass which captures the numeric operations (+), (*), negate, fromInteger, and things you can get from those.
08:27:03 <idnar> @type showList
08:27:05 <lambdabot> forall a. (Show a) => [a] -> String -> String
08:27:16 <Deewiant> ?src Show
08:27:16 <lambdabot> class  Show a  where
08:27:16 <lambdabot>     showsPrec :: Int -> a -> ShowS
08:27:16 <lambdabot>     show      :: a   -> String
08:27:16 <lambdabot>     showList  :: [a] -> ShowS
08:27:28 <Cale> Deewiant: You don't need undecidable instances.
08:27:38 <Deewiant> Cale: You don't? What do you need?
08:27:42 <Cale> Deewiant: You just need FlexibleInstances, which everything can do.
08:28:13 <Cale> It's one of those places where Haskell 98 was way too conservative because they weren't so certain about how things were going to work out with regard to typeclasses yet.
08:28:28 <Deewiant> Ah, okay.
08:28:55 <Deewiant> So, anybody got a Prelude without showList? :-P
08:29:36 <quicksilver> showList solves a different problem, Deewiant
08:29:38 <Cale> They said that instance heads had to be in the form of a type constructor followed by possibly some distinct type variables (and possibly some typeclass constraints)
08:29:39 <cads> what's a simple way to convert a string into a unique integer for applying an encryption function?
08:29:42 <Saizan> Deewiant: showList is another problem
08:29:47 <Cale> Is it?
08:29:50 <Deewiant> It is?
08:30:00 <quicksilver> it solves the problem that we want to add a HORRIBLE HACK to make a non-parametric Show instance for [Char]
08:30:21 <Saizan> to write both instance Show a => Show [a], and instance Show String you want OverlappingInstances
08:30:22 <Cale> Oh, right, that would involve undecidable instances there. :)
08:30:30 <Cale> er, Overlapping, rather
08:30:32 <quicksilver> the hack is for the non-parametricity, really.
08:30:45 <quicksilver> the syntactic form of the instance head is a (relative) minor problem.
08:31:16 <Cale> But you can still deny overlaps while allowing definitions of instances which aren't completely parametric.
08:31:45 <quicksilver> it's particularly horrible (or clever) in that it perverts the "default method" mechanism into providing the backup definition.
08:31:51 <quicksilver> so you don't need to write showList at all types.
08:31:56 * quicksilver shudders at the horror of it all.
08:32:13 <Cale> It is a pretty clever workaround though :)
08:32:14 <Deewiant> What's a good alternative? OverlappingInstances? :-P
08:32:17 <quicksilver> really 'String' should be a newtype. Of course the reason that it isn't is that you want to reuse list functions on it.
08:32:43 <quicksilver> Cale: one man's clever workaround is another man's cthulhic abuse.
08:32:50 <RayNbow> @where hayoo
08:32:51 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
08:33:12 <younder> Do any of you have a example of a context free language parser written in haskell? (URL or something)
08:33:34 <Cale> younder: Specifically context free?
08:33:48 <Cale> younder: Or would parsing a larger class of languages be okay as well?
08:33:55 <younder> Well not a regualr grammar or context sensitive
08:34:17 <younder> a one pump for simplicity
08:34:34 <Cale> See, Parsec technically can parse some context sensitive languages, but degrades to LL(1) if you don't use 'try'.
08:35:14 <younder> No I don't see. But perhaps you can explain
08:35:40 <Cale> okay
08:35:50 <EvilTerran> Cale, surely it can parse all computable languages, at least if you use try?
08:36:00 <EvilTerran> owing to haskell being turing-complete an' all
08:36:08 <quicksilver> EvilTerran: that's a false inference.
08:36:11 <quicksilver> hmm.
08:36:25 <Cale> I didn't want to have to think too hard about that in my present state ;)
08:36:29 <Cale> younder: Okay...
08:36:33 <quicksilver> or is it?
08:36:36 <Cale> younder: Do you know about any monads yet?
08:36:42 <EvilTerran> quicksilver, i wasn't sure about the validity of it, hence "surely ... ?" instead of stating it as fact
08:36:57 <younder> Yes fine.. I'll get back to it later. Juust a few holes here and there
08:37:03 <quicksilver> EvilTerran: the inference is valid if Parsec exposes a construct which lets you plug other parsing methods into it.
08:37:23 <quicksilver> EvilTerran: ...as taken separately from the question of whether parsec, as designed, can parse all computable languages.
08:37:28 <Cale> younder: Parsec gives you an operation >>= which takes a parser on the left, and a function on the right
08:37:30 <EvilTerran> seeing as you could just read in the entire input into a list and parse it any way you like
08:37:43 <EvilTerran> in that way, it's trivially able to handle any computable language
08:37:43 <quicksilver> but would that still be a parsec parser?
08:37:45 <quicksilver> yes, I guess so
08:37:46 * quicksilver nods
08:38:00 <quicksilver> since Parsec implements Functor
08:38:04 <Cale> younder: It produces the parser which parses the thing on the left, and takes the result of that, and passes it to the function (an arbitrary function) which produces a parser for parsing the rest of the text.
08:38:10 <quicksilver> you're "allowed" to fmap anyparser into it.
08:38:33 <younder> I saw a enlightening FSM the other day and realized it could be written as a grammar.
08:38:37 <EvilTerran> but, if you restrict yourself to just parsec and some other primatives, there may be a smaller class of languages it fits
08:38:57 <younder> Cale: lfold style
08:39:03 <Cale> younder: So, if parsers are allowed to do lookahead, that's clearly giving you context sensitivity -- it's almost the definition of context sensitive
08:39:28 <younder> No it doesn't
08:39:40 <Cale> Well, okay, you might not have nondeterminism or something.
08:40:16 <younder> LALR(2)  looks to sumbols ahead and is not context sensitive
08:40:42 <Cale> But it gives you a way for the rest of the parser to depend on what was parsed initially
08:40:48 <Cale> which is what I'm focusing on :)
08:41:18 <younder> foldr gives you a opertunity to look ahead and push unresolved enteties on the steack
08:41:35 <quicksilver> there is a duality here causing confusion, I think?
08:41:36 <Cale> So you could initially parse a grammar, say, and then construct the parser which parses that grammar, and parse the rest of the text with that.
08:41:46 <younder> which is why I feel there should be a elegant way to do this in Haskell. I just don't see it
08:41:51 <quicksilver> a class of languages may include some context-sensitive features
08:42:00 <quicksilver> but not include the entire class of context-sensitive languages
08:42:00 <Cale> (But you'd need some nondeterminism at some point for that to work, of course)
08:44:13 <younder> All context free grammars contain some hack of procedural restriction to meke them work..
08:44:38 <younder> usually described as a RETE graph
08:45:16 <Cale> But the disjunction (<|>) of parsers in Parsec is slightly unfair: If the first parser eats a character before failing, the second parser won't be tried. There's a primitive called 'try' which alters a parser such that if it fails, it is as if it had consumed no input.
08:45:27 <younder> well this is more AI than haskell, sorry..
08:46:00 <Cale> But this default means that it can be predictive.
08:46:29 <Cale> (and by restricting the extent to which you use 'try', you get LL(k) for any given k you want.)
08:46:45 <younder> OK
08:47:01 <younder> But I was thinking LR(N)
08:48:15 <Cale> I don't know of any parser combinator libraries which do LR parsing. Happy is a GLR parser generator.
08:48:45 <Cale> er, or does Happy do LALR by default? I forget...
08:49:55 <Cale> aha, yeah, LALR(1) by default, and they have GLR support as well.
08:50:55 <younder> OK I'll look at it
08:51:37 <Cale> LL is similar in terms of capability to LR, from what I understand though.
08:52:02 <younder> Not quite
08:52:47 <younder> but procedural restrictions tend to glaze over the difference
08:53:27 <younder> the R bit let's you rememember the last state
08:53:41 <younder> You just pushed it on the stack
08:54:01 <younder> in a LL world you see only what is in front ofyou
08:54:05 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.7698 -- this seems to indicate that you can always transform an LR(k) grammar into an LL(k) one.
08:54:06 <lambdabot> Title: LR Parsing Grammar Transformation + LL Parsing Making LR Parsing More Understand ...
08:55:53 <younder> I'll look at it
08:56:19 <Cale> With parsec in particular, things are a bit hazy, since you're always determining the future parser in terms of what you last parsed anyway.
08:57:41 <Cale> That is, if you write parsers in do notation, you use  x <- p  to parse p, and bind the result of that parsing to the value x, which can be used further on to determine what needs to be parsed and what result to produce.
08:58:07 <Cale> (where p is any parser)
08:58:52 <tromp_> @hoogle StateMonad
08:58:53 <lambdabot> No results found
08:59:20 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- this is slightly out of date with regard to the location of the library (it's now at Text.ParserCombinators.Parsec) but otherwise is a good introduction :)
08:59:27 <tromp_> @hoogle get
08:59:31 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
08:59:31 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
08:59:31 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
08:59:32 <lambdabot> Title: Parsec, a fast combinator parser
09:02:11 <Cale> I should also mention that there are other parsing libraries like ReadP (as that hoogle search inadvertently showed ;) which vary in features and performance, but for the most part have a very similar interface to Parsec.
09:02:48 <simony> hey, why does Applicative need "pure" to be defined, why not use "fmap (const val) some_functor_value" ?
09:03:10 <Cale> simony: because there might not be such a value
09:03:27 <Cale> simony: Also, not all values of the functor type will produce the same result there.
09:03:35 <Cale> So you're picking one out with special properties.
09:03:56 <Cale> (something particularly simple usually)
09:04:12 <simony> Cale, I understand
09:04:38 <younder> threre is a type of logic inference called Hoare Logic which can deal with non applicative languages, but finding the invariants, particularly in loops is difficult and dosn't lend well to automation
09:05:17 <quicksilver> simony: I could answer it this way: you could define it like that; but choosing the right value of "some_functor_value" is just as hard as defining "pure" ;)
09:05:50 <younder> The state space in functional languages is much simpler
09:06:00 <Cale> younder: this is true :)
09:11:08 <lilac> Cale: i thought the recent parsec (parsec3) was now at Text.Parsec ?
09:11:33 <Cale> lilac: If that's true, that's nicer.
09:12:23 <lilac> the last time i downloaded parsec from hackage, the Text.ParserCombinators.Parsec bits were a parsec2 interface around parsec3 (in Text.Parsec); it's possible it's changed since
09:14:14 <Cale> Cool.
09:14:30 <Cale> I haven't had a chance to look closely at Parsec3
09:14:51 <Cale> The Hackage documentation agrees with you :)
09:15:36 <zachk> would i be wrong in assuming this is a Tautology: GHC > Hugs > drugs ?
09:16:32 <Deewiant> where do bugs fit in
09:17:00 <zachk> ghc>hugs>drugs>bugs
09:17:02 <zachk> ?
09:17:43 <younder> lisp>speech impediment>language impediment> bug
09:18:27 <younder> go I love using Modus Ponens in the wrond direction.. I can deduce anything ;)
09:22:34 <BMeph> @remember younder  lisp>speech impediment>language impediment> bug
09:22:34 <lambdabot> I will never forget.
09:22:38 <BMeph> :)
09:23:35 <simony> weird: join [1,2,3] fails with what seems to be a wrong error message in ghci:  instead of saying 1 is not a Monad, or something about it not being m (m a), it says that [Int] is not a Num instance. How come?
09:24:20 <vegai> @hoogle join
09:24:21 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:24:21 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
09:24:21 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
09:24:35 <idnar> @src takeWhile
09:24:35 <lambdabot> takeWhile _ []                 =  []
09:24:35 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
09:24:35 <lambdabot>                    | otherwise =  []
09:25:58 <simony> > join [1,2,3]
09:25:59 <lambdabot>       No instance for (Num [a])
09:25:59 <lambdabot>        arising from the literal `1' at <inter...
09:26:11 <simony> this error makes no sense to me ;)
09:26:15 <Saizan> simony: join :: Monad m => m (m a) -> m a, [1,2,3] :: Num x => [x], so x = m a, m = [] which implies x = [a]
09:26:46 <Saizan> and at that point it complains that there's not Num [a]
09:26:52 <Saizan> "no"
09:27:04 <simony> but wouldn't it first realize that x is not a list at all?
09:27:15 <simony> before realizing that the non-list is not matching x's class constraints?
09:27:21 <Saizan> it has no way to tell that
09:27:34 <ddarius> 1 can be a list
09:27:37 <Saizan> you could have defined a Num [a] instance
09:28:05 <simony> and then 1 could become a list?
09:28:11 <Saizan> yes
09:28:15 <simony> ah, cool! :)
09:31:56 <heatsink> Is there a library for math expressions that does things like normalize expressions into sum-of-products form?  I want to write bindings to the Omega Presburger arithmetic library. I could make my own expressions, but integrating with an existing library would be better.
09:32:11 <heatsink> *an existing math expression library
09:33:10 * heatsink didn't see anything relevant in the math section of hackage
09:35:17 <hugo__> what is a "rose tree" data structure ?
09:35:22 <hugo__> i can't understand it :(
09:35:27 <hugo__> my brain is not recursive enough
09:35:34 <cjb> huh, that's a new one on me
09:35:41 <heatsink> It's a tree where each tree node can have a list of children IIRC.
09:36:16 <Deewiant> yep
09:36:18 <Deewiant> Data.Tree
09:36:34 <hugo__> hmm, they define it like this: data Ntree a = Ntree a [Ntree a]
09:36:35 <Deewiant> data RoseTree = Node a [RoseTree a]
09:36:41 <Deewiant> yep
09:36:50 <hugo__> Deewiant: yes, that makes more sense
09:37:18 <Deewiant> well, it makes the same amount of sense, yours just uses the same name for the constructor and the type
09:37:23 <hugo__> is it a binary tree that always grows to the right side ? :/
09:37:56 <Deewiant> it's more like an n-ary tree where the n can be different at each node
09:37:58 <heatsink> data BinTree a = Node a (BinTree a) (BinTree a) -- infinite binary tree
09:38:05 <heatsink> data RoseTree a = Node a [RoseTree a]
09:38:29 <quicksilver> RoseTrees don't need a 'Leaf' case because they can just use an empty list of children
09:38:37 <quicksilver> you may or may not find that a convenient hack.
09:38:47 <quicksilver> (compared to some other tree structures)
09:39:24 <hugo__> hmm, now im feeling like i shouldn't have skipped those data structures boring classes :/
09:42:54 <hugo__> ok, so in a rose tree, when i have an empty list, its like i've hit the bottom of the tree, right ?
09:43:05 <Deewiant> yeah, that's a leaf node
09:43:10 <hugo__> hmm
09:43:12 <hugo__> nice
09:43:13 <Deewiant> (it has no children)
09:43:16 <hugo__> clean
09:43:37 <hugo__> its easy, just my brain wasn't catching this recursive data declaration style
09:43:39 <idnar> @pl \b x -> if b then Just x else Nothing
09:43:40 <lambdabot> flip flip Nothing . (. Just) . if'
09:43:42 <idnar> bleh
09:43:53 <idnar> @type \b x -> if b then Just x else Nothing
09:43:54 <lambdabot> forall a. Bool -> a -> Maybe a
09:44:00 <idnar> @hoogle Bool -> a -> Maybe a
09:44:00 <lambdabot> Control.Exception assert :: Bool -> a -> a
09:44:00 <lambdabot> Prelude asTypeOf :: a -> a -> a
09:44:00 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
09:44:31 <Deewiant> idnar: it helps to define a helper function bool :: a -> a -> Bool -> a
09:44:58 <Deewiant> ?pl \b x -> bool (Just x) Nothing b
09:44:58 <lambdabot> flip (flip bool Nothing . Just)
09:45:08 <Deewiant> not as bad :-P
09:45:22 <Deewiant> ?pl \x -> bool (Just x) Nothing b
09:45:22 <lambdabot> flip (flip bool Nothing . Just) b
09:46:21 <int-e> @type \b x -> guard b >> return x
09:46:22 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
09:46:36 <int-e> @pl \b x -> guard b >> return x
09:46:36 <lambdabot> (. return) . (>>) . guard
09:47:26 <Deewiant> I really should learn when to use guard :-P
09:47:49 <idnar> @type compare
09:47:50 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:48:43 <quicksilver> @djinn a -> a -> Bool -> a
09:48:43 <lambdabot> f a b c =
09:48:43 <lambdabot>     case c of
09:48:43 <lambdabot>     False -> b
09:48:43 <lambdabot>     True -> a
09:48:50 <quicksilver> hah! @djinn ftw.
09:49:24 <Deewiant> @djinn (a -> b) -> b -> a -> Bool -> b
09:49:24 <lambdabot> f a b c d =
09:49:24 <lambdabot>     case d of
09:49:24 <lambdabot>     False -> a c
09:49:24 <lambdabot>     True -> b
09:49:33 <int-e> @djinn Bool -> a -> Maybe a
09:49:34 <lambdabot> f a b =
09:49:34 <cajun-rat> is it because there is an implicit fromIntegral in front of a literal '1'
09:49:34 <lambdabot>     case a of
09:49:34 <lambdabot>     False -> Nothing
09:49:34 <lambdabot>     True -> Just b
09:49:39 <int-e> neat.
09:50:13 <ziman> why didn't it just do `f a b c = a'?
09:50:14 <Deewiant> hmm, would (a -> b) -> (a -> b) -> a -> Bool -> b be more useful
09:50:38 <cajun-rat> grr stupid scrollback
09:50:39 <Deewiant> ziman: I think it's nice that it tries to use more parameters in a useful way if it can :-P
09:51:15 <int-e> Deewiant: looks artificial
09:51:18 <Roey> question
09:51:24 <Roey> is haskell an appropriate language for gui apps
09:51:37 <Roey> or is it better suited for math research
09:51:38 <Roey> ?
09:52:26 <cjb> Roey: see gtkhs
09:52:29 <thoughtpolice> why can't it be both?
09:52:30 <thoughtpolice> :]
09:52:39 <Roey> cjb:  ah
09:52:40 <Roey> I mean,
09:52:43 <cajun-rat> gtk2hs is pretty good, but watch for the event loop
09:52:57 <Deewiant> cajun-rat: what do you mean?
09:53:06 <Roey> thoughtpolice:  because sure you can write a radiosity renderer in PostScript but is it unwieldly? yes
09:53:23 <cjb> Roey: take a look at the gtk2hs tutorial
09:53:27 <cjb> it's not unwieldy
09:53:29 <Deewiant> Roey: well, it's not that unwieldy, at least. :-P
09:53:33 <Roey> cjb:  ah
09:53:35 <cajun-rat> the gtk event loop didn't play nice with the haskell threading
09:53:37 <Roey> Deewiant:  :)
09:53:46 <Roey> cjb:  I wonder if there are kde bindings in that case
09:53:47 <leimy> gtk is pants anyway :-)
09:53:52 <cjb> any more than IO in general is unwieldy in a functional language
09:54:08 <cjb> Roey: probably, but I've never used them
09:54:09 <Deewiant> gtk2hs seems to be the most wieldy thing with decent functionality
09:54:33 <thoughtpolice> Roey: gtk2hs is pretty decent both in API and functionality
09:54:34 <Deewiant> wx requires you to do some memory management yourself, so I've heard
09:54:36 <cajun-rat> for straightforward gui tools i love gtk2hs
09:55:04 <Roey> (like I said, I'm personally biased in favor of Qt and KDE APIs)
09:55:22 <cajun-rat> but be warned that it doesn't work with the -threaded rts
09:55:24 <thoughtpolice> Roey: I just don't see why it's always between "math" and "real things" - you can accomplish both.
09:55:25 <Roey> http://swik.net/Qt+haskell
09:55:28 <lambdabot> Title: Qt + haskell - SWiK
09:55:37 <leimy> neat
09:55:38 <Deewiant> cajun-rat: at all? Can't you just make sure that you do gtk calls from one thread?
09:55:46 * leimy always preferred Qt to GTK
09:55:52 <cajun-rat> i'm pretty sure you can't
09:55:55 <Samy> i have to say, gtk2hs seems nice
09:56:00 <leimy> Never tried WxWindows
09:56:09 <int-e> cajun-rat: you can.
09:56:38 <thoughtpolice> Roey: but currently (off the top of my head) there is
09:56:41 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/wx (wxwidgets)
09:56:42 <lambdabot> Title: HackageDB: wx-0.10.5
09:56:47 <thoughtpolice> http://haskell.org/gtk2hs/
09:56:48 <lambdabot> Title: Gtk2Hs
09:56:53 <thoughtpolice> and http://qthaskell.berlios.de/
09:56:58 <lambdabot> Title: qtHaskell
09:57:10 <Roey> cool thanks
09:57:21 <Roey> yeah I was browsing that
09:57:23 <cajun-rat> int-e: have you seen an example?
09:57:42 <Samy> Roey, did you look at the Gtk2hs example?
09:57:50 <Roey> not yet
09:57:51 <leimy> QtHaskell can produce javascriptable stuff
09:57:52 <Samy> Roey, http://www.haskell.org/gtk2hs/documentation/#hello_world
09:57:53 <lambdabot> Title: Gtk2Hs » Documentation
09:57:53 <Deewiant> Gtk has the advantage with Glade, I think
09:57:59 <Roey> I'm still trying to get a grip of haskell's syntax
09:58:06 <Roey> so different from what I am used to
09:58:16 <leimy> QtHaskell will let you use their GUI designer too
09:58:18 <Samy> Roey, the memory management makes it very nice, I have to say.
09:58:28 <Roey> like mouse <-> colony of ants
09:58:31 <Roey> ah
09:59:06 <leimy> I may have to spend some time with this qtHaskell thing... quite interesting.
09:59:19 <Samy> Roey, http://darcs.haskell.org/gtk2hs/demo/ has some demos
09:59:20 <lambdabot> Title: Index of /gtk2hs/demo
09:59:24 <Roey> ah thanks
10:00:22 <int-e> cajun-rat: I have. It's not pretty, admittedly. Use forkOS to start a GUI thread. Set up a Chan or similar to put GUI actions in. Add an idle handler to the GUI thread that processes the Chan.
10:00:37 <Roey> Samy:  ok, I looked at the Calc .hs code
10:00:57 <Roey> like I said, it's interesting because it looks like something out of a Michael Chrichton novel
10:01:09 <Roey> i.e. nothing like any other programming language I know ;0
10:01:12 <Roey> * ;)
10:01:20 <Samy> Well
10:01:27 <Samy> You can have multiple threads modify the event loop
10:01:31 <Roey> hehe
10:01:32 <Roey> aye
10:01:39 <Roey> TomMD:  hi
10:01:44 <Roey> I was just in Baltimore yesterday
10:01:46 <thoughtpolice> Roey: it's fun. :]
10:01:46 <Roey> my condolences
10:01:48 <Samy> As int-e said, you could add a callback to the idle loop
10:01:51 <Deewiant> int-e: It has to be a forkOS?
10:01:56 <Roey> thoughtpolice:   :)
10:02:01 <Deewiant> Yeah, I guess it has to be
10:02:06 <Samy> The above is threadsafe
10:02:16 <Samy> however, you can also modify state directly by making use of some gdk locks
10:02:23 <cajun-rat> int-e: I've just seen http://osdir.com/ml/lang.haskell.gtk2hs/2007-01/msg00026.html. not sure why I couldn't find that when I needed it a couple of months ago
10:02:27 <Deewiant> It's guaranteed that everything in a forkOS'd thread runs in only that thread (modulo it doing forkIO/OS itself)?
10:02:32 <lambdabot> Title: Re: [Gtk2hs-devel] threaded RTS: msg#00026
10:02:38 <int-e> Deewiant: yes, forkIO threads are scheduled on the RTS' thread pool.
10:03:11 <NikkiWhitecraft> Hi, I'm looking for a basic Beginners Guide on Haskell, or the link that was posted a few days ago that I lost if anyone can help
10:03:33 <Deewiant> int-e: so all forkIOs share a pool and forkOS's just automatically become threads of their own
10:03:50 <Deewiant> int-e: ... where "automatically" is the wrong word
10:03:59 <int-e> cajun-rat: http://hpaste.org/11364 ... I believe this works. (It's been a while since I used it - it *is* somewhat unwieldy)
10:04:56 <int-e> cajun-rat: it uses an MVar, not a Chan, but that would be easy to change. I'm not sure which I like better for these purposes.
10:05:06 <dcoutts> kowey: hia
10:05:17 <jeffz> NikkiWhitecraft: this one? http://learnyouahaskell.com/
10:05:28 <lambdabot> Title: Learn You a Haskell for Great Good!
10:05:38 <leimy> phear
10:05:41 <NikkiWhitecraft> yeah that's it, thanks.  here's hoping it can help
10:05:58 <kowey> dcoutts: hi! so... darcs now has a cabal file :-)
10:06:28 <kowey> or rather a darcs.cabal.in template with @DARCS_VERSION@ being replaced by franchise
10:07:08 <kowey> dcoutts: http://hpaste.org/11360 - I didn't really know what the wisest way to handle dependencies was, so I just plugged in something sort of arbitrary and a bit haphazard
10:07:09 <cajun-rat> int-e: thanks. I'll put that under my pillow
10:08:50 <dcoutts> kowey: tip #1, do not use ==
10:09:15 * kowey listens
10:09:15 <dcoutts> kowey: use version ranges
10:09:15 <Deewiant> dcoutts: == is fine with * ;-)
10:09:26 <Cale> NikkiWhitecraft: Of course, if you have any questions about Haskell, feel free to ask here :)
10:09:27 <dcoutts> Deewiant: indeed, because it's a version range
10:09:52 <Deewiant> dcoutts: just saying that "do not use ==" is a bit too strict, but fine as a tip :-)
10:09:59 <dcoutts> kowey: it's quite possible to encode the optional stuff like your libcurl or whatever optional deps
10:10:10 <dcoutts> Deewiant: aye right
10:10:25 <NikkiWhitecraft> I want to try and work it out first hence the asking for the tutorial, but thank you ^^
10:11:11 <dcoutts> kowey: the problem with using a .in file of course is that the dev version it will not work straight off using the standard cabal tools
10:11:26 <kowey> right
10:11:35 <dcoutts> kowey: I presume the distributed versions will have an actual .cabal file
10:11:39 <kowey> the idea is that tarballs will have darcs.cabal
10:11:43 <dcoutts> ok
10:11:55 <dcoutts> so it's just harder for developers
10:12:09 <kowey> right (who will be mostly using franchise anyway)
10:12:15 <dcoutts> yep, fine
10:12:23 <kowey> so darcs.cabal right now is seen as just packaging
10:12:49 <dcoutts> kowey: so how does the configure part communicate how to do the conditional building? cpp right?
10:13:04 <dcoutts> kowey: eg enableing libcurl passes some cpp define I presume
10:13:49 <dcoutts> kowey: is this .cabal.in file going to be in the mainline darcs repo? perhaps I should help work on that at the hackathon
10:14:06 <kowey> dcoutts: it is
10:14:29 <dcoutts> kowey: great, btw what was the resolution about the Setup.hs, is it cabal or franchise?
10:15:36 <dcoutts> kowey: ie will they clash or be ok?
10:16:12 <thoughtpolice> dcoutts: currently in http://darcs.net/unstable it's franchise
10:16:21 <kowey> dcoutts: well, as it stands franchise is doing all the work
10:16:31 <kowey> and the darcs.cabal file is just there for cabal-install
10:16:34 <thoughtpolice> dcoutts: also I figured out that really weird ld issue, it turned out to be a case sensitivity issue.
10:16:48 <dcoutts> thoughtpolice: heh, crazy :-)
10:16:50 <kowey> it's also now franchise in stable
10:16:57 <dcoutts> thoughtpolice: any lasting lessons we can take away?
10:17:10 <dcoutts> kowey: sure but Cabal needs a Setup.hs too right
10:17:22 <thoughtpolice> dcoutts: don't have binaries outputted to a directory which have the same name as a folder in that directory :P
10:17:51 <dcoutts> thoughtpolice: ahh :-)
10:18:01 <kowey> dcoutts: right... so right now a more cabal-based darcs would need its own Setup.hs
10:18:02 <thoughtpolice> i speculated case sensitivity was the problem because something like that has bitten me before (it worked on linux, then on OSX things just didn't) but the ld problem just threw me off
10:18:10 <kowey> and possibly it's own darcs.cabal
10:18:26 <kowey> I'm hoping we can do things in such a way that we maximise sharing
10:18:40 <kowey> for example, using Distribution.Darcs to do things that both approaches would need
10:18:46 <dcoutts> kowey: I'm not sure I understand. Is the aim to be able to use either, at least in distro packages
10:19:01 <dcoutts> kowey: if so why would it need a different .cabal file?
10:19:07 <kowey> for now, Cabal will not be in mainline darcs
10:19:24 <kowey> so it's just if this is something people feel strongly enough to want to maintain on the side
10:19:25 <dcoutts> kowey: but mainline darcs does contain a .cabal file?
10:19:29 <kowey> yes
10:19:34 * dcoutts is confused
10:19:40 <kowey> for cabal-install (which doesn't seem to care if we use Cabal or not)
10:19:57 <kowey> think of franchise as just a custom build method
10:20:08 <kowey> oh maybe I'm mistaken in my terminology
10:20:10 <dcoutts> sure sure
10:20:22 <Igloo> AIUI, cabap-install looks at the Cabal file, works out which deps to install, then runs Setup.hs(franchise) which completely ignore what cabal-install decided and does its own thing
10:20:34 <kowey> right
10:20:46 <dcoutts> which seems like a recipe for requiring lots of testing
10:20:58 <kowey> ayup
10:21:00 <dcoutts> to make sure they actually are in sync
10:21:12 <kowey> hopefully with the hackage infrastructure, this won't be so bad
10:21:24 <dcoutts> kowey: so in a cabalised darcs tarball it might use a standard Setup.hs? is that the idea?
10:22:25 <kowey> it's /possible/, but what is likely to happen is that we just ship with the franchise-based one
10:22:28 <dcoutts> or is the plan seriously to make darcs a cabalised package using franchise as the custom build system?
10:22:51 <kowey> I think that is the plan right now... well let's put it this way:
10:23:09 <kowey> droundy doesn't really think that cabalisation should be part of the darcs darcs effort
10:23:24 <kowey> but he can accept that darcs.cabal could be useful for packaging
10:23:37 <dcoutts> kowey: well ok, but I might need some help in smoothing out the rough edges, we've not actually had multiple custom build systems, except for make based ones
10:23:42 <kowey> so it's a sort of compromise
10:23:57 * kowey is crossing his fingers
10:23:59 <dcoutts> kowey: if you expect to be able to stick it on hackage and have it actually work
10:24:12 <kowey> fwiw, franchise's own install works like this
10:24:14 <kowey> and it seems to be fine
10:24:27 <dcoutts> kowey: I know, I fixed it. But it's pretty fragile.
10:24:40 <dcoutts> because the approaches to configuration are so radically different
10:24:54 <dcoutts> franchise can add or remove deps compared to what the .cabal file states
10:25:06 <kowey> right now I'm also suggesting on the franchise list that somebody post a howto on using franchise to check for non-Haskell deps as a cabal configure hook
10:25:36 <dcoutts> or perhaps I could do that in Cabal at the hackathon
10:25:41 <dcoutts> it's an open ticket
10:26:20 <dcoutts> the info about non-haskell deps is already in the .cabal file
10:26:33 <dcoutts> it just needs to be taken into account
10:27:36 <kowey> will cabal be able to do things like "if the user has libwww on his machine, then use that, else use libcurl, if it's available, else fall back to the HTTP package or in the worst case, wget"?
10:27:56 <dcoutts> kowey: yes, but the user has full insight into those decisions
10:28:50 <Igloo> dcoutts: Oh, I meant to ask you: Does Cabal do backtracking for the pkg-config deps as well as the Cabal deps?
10:29:05 <dcoutts> so they are controllable by flags so the user can force a preference or the system will find a flag assignment that works
10:29:14 <dcoutts> Igloo: not yet but that is the plan
10:29:24 <dcoutts> Igloo: so extending it to all the kinds of deps
10:29:29 <dcoutts> not just build-depends
10:30:15 <dcoutts> Igloo: http://hackage.haskell.org/trac/hackage/ticket/342
10:30:16 <lambdabot> Title: #342 (Allow automatic resolving of conditionals on more than just build-depends) ...
10:30:16 <Igloo> OK
10:36:24 <wchogg> I just noticed that in the 6.10 rc, Data.Map.lookup is no longer polymorphic over the monad m but is fixed to Maybe.  Why the change?
10:36:44 <bos> because it used fail, which was wrong in most monads.
10:36:55 <NikkiWhitecraft> what does it mean when you get this error --> Parse Error (possibly incorrect indentation)?
10:37:01 <vixey> wchogg: this totally sucks
10:37:09 <bos> huh?
10:37:10 <vixey> I had to change a bunch of code :/
10:37:17 <bos> no, it's a very good idea.
10:37:52 <vixey> Data.MapThatDoesn'tUseFail would be a good idae
10:38:12 <vixey> but replacing the current one breaks existing code
10:38:17 <wchogg> bos:  I can see the reasoning.  I know there's a movement to getting rid of fail forever.
10:38:22 <idnar> why not make it use MonadPlus?
10:38:42 <bos> MonadPlus isn't good enough.
10:38:47 <idnar> (of course, that should be MonadZero, but...)
10:38:50 <bos> its semantics aren't well defined.
10:39:06 <vegai> wchogg: what type did you use instead of Maybe?
10:39:11 <heatsink> What's ambiguous in MonadPlus?
10:39:18 <idnar> heatsink: mplus
10:39:29 <Deewiant> vixey: the one in 6.10 returns a Maybe
10:39:35 <Deewiant> ah
10:39:37 <bltrout> The real world Haskell book suggests the use of mini-http, but it's marked deprecated in hackage. Is it being deprecated a big deal?
10:39:38 <Deewiant> I see that was the point
10:39:45 <idnar> heatsink: should [5] `mplus` [6] be [5,6] or [6]?
10:39:59 <wchogg> vegai:  Actually, it's not my code but the library I tried to build was using IO instead of Maybe.
10:40:02 <vixey> :t mplus
10:40:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
10:40:05 <Deewiant> > [5] `mplus` [6]
10:40:06 <lambdabot>   [5,6]
10:40:29 <idnar> (at least, that's what I understand the ambiguity to be)
10:40:31 <vixey> what are the expected properties about mplus?
10:40:51 <kowey> for the interested, http://www.haskell.org/haskellwiki/Package_versioning_policy was the missing link for me
10:40:52 <lambdabot> Title: Package versioning policy - HaskellWiki
10:40:55 <dcoutts> vixey: it broke very little existing code in the scheme of things
10:40:57 <heatsink> idnar: How is that worse than the ambiguity of instance Monoid (Endo a)?
10:41:06 <Deewiant> idnar: really, the reason MonadPlus wasn't chosen was that Maybe captures exactly what is done: Just (a value) is returned, or Nothing is.
10:41:07 <kowey> and now I think I have a better idea how to write dependencies
10:41:30 <vixey> dcoutts: It break one program I wrote :p
10:41:47 <idnar> Deewiant: well, I guess you can always lift it back into MonadPlus or whatever
10:41:47 <vixey> the worse thing is Error changing
10:42:02 <vixey> I have to import OldError or whatever in all this code I wanted to use
10:42:12 <dcoutts> vixey: or to stick to base 3
10:42:26 <wchogg> What changed in Error?
10:42:32 <wchogg> I'm obviously a little behind the times.
10:42:52 <vixey> it's not a big deal I just don't get why it goes
10:42:57 <Deewiant> idnar: exactly.
10:42:58 <vixey> Error -> Error and OldError
10:43:00 <vixey> instead of
10:43:05 <Deewiant> Exception, not Error
10:43:08 <vixey> Error -> NewError and Error
10:43:39 <vixey> the second change breaks no existing code ...
10:59:13 <jeffersonheard> there are convenience functions for converting cInt to Int and CFloat to Float, etc...  I can't remember their names nor what module they're in
10:59:27 <wjt> @ty fromIntegral
10:59:28 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:59:28 <heatsink> fromIntegral and fromRational?
10:59:34 <jeffersonheard> I know thoe
10:59:52 <jeffersonheard> those, but there was something I thought that was more efficient.  like cIntToInt
11:00:08 <jeffersonheard> plus it covered things like Bools as well
11:00:15 <jeffersonheard> set of functions instead of a generic function
11:00:33 <heatsink> :type CIntToInt#
11:00:45 <vixey> jefferson: why would cIntToInt be more efficient that fromIntegral?
11:00:48 <jeffersonheard> :t cIntToInt
11:00:49 <lambdabot> Not in scope: `cIntToInt'
11:00:59 <heatsink> :t cIntToInt#
11:01:01 <lambdabot> Not in scope: `cIntToInt#'
11:01:19 <epictetus> Sup guys
11:01:28 <epictetus> 13:38 < epictetus> 13:34 -!- Irssi: Join to ##java was synced in 1 secs
11:01:34 <epictetus> 13:38 < epictetus> 13:34 < epictetus> http://www.efactusa.com http://www.greatestate.com http://www.cyberoppression.org http://www.westonmass.net
11:01:37 <jeffersonheard> It shouldn't be, but I'd seen it used in TH code instead of fromRational and fromIntegral, and I thoght there had to be a reason for it
11:01:38 <epictetus> whoops
11:01:39 <epictetus> accidental cutpaste
11:01:40 <epictetus> sorry
11:01:44 <lambdabot> Title: Efact: Paperless Office!
11:02:03 <Zao> epictetus: You probably had most the ops halfway to banning you as a bot there :)
11:02:14 <epictetus> hah
11:02:19 <jeffersonheard> :t realToFrac
11:02:20 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
11:02:21 <epictetus> but maybe I AM a bot
11:02:23 <jeffersonheard> :t fromRational
11:02:24 <lambdabot> forall a. (Fractional a) => Rational -> a
11:02:28 <epictetus> maybe they should ban me
11:02:46 <epictetus> maybe the bots should ban the people, did you ever think of that
11:02:52 <Botje> ban :: Nickname -> IO ()
11:03:25 <opqdonut> ban :: Nickname -> Channel -> Channel
11:03:26 <opqdonut> ;)
11:03:53 <mux> ban :: MonadFail m => Nickname -> Channel -> m ()
11:03:55 <jeffersonheard> nice, opqdonut
11:04:04 <lilac> ban :: IRCArrow a => a (Nickname, Channel) Channel
11:04:11 <idnar> IRCArrow? :(
11:04:14 <Botje> i meant the kind of banning you get from an ICBanningM
11:04:17 <bd_> Perhaps the channel itself is the arrow?
11:04:24 <bd_> ban :: Channel Nickname ()
11:04:27 <opqdonut> lilac: :D
11:04:41 <heatsink> opqdonut: ban nick = filter ((nick /=) . sender)
11:05:07 <Botje> so, are there decent event-based irc frameworks yet?
11:05:10 <lilac> ban :: (BanContext b, UserIdentifier u) => u -> b u
11:05:31 <heatsink> lilac: ban :: (BanContext no, UserIdentifer u) => u -> no u
11:05:38 <lilac> lol
11:05:38 <Botje> lol
11:06:44 * lilac waits for someone to do it in the type system
11:07:42 <bd_> instance [...] => BannableProof channel nick channelprime | channel nick -> channelprime ?
11:07:48 <BMeph> @remember heatsink ban :: (BanContext no, UserIdentifer u) => u -> no u
11:07:48 <lambdabot> I will remember.
11:10:07 * glguy notices "11:02 < epictetus> maybe they should ban me"
11:10:15 <idnar> @src nub
11:10:16 <lambdabot> nub = nubBy (==)
11:10:16 <glguy> can do!
11:10:18 <idnar> @src nubBy
11:10:19 <lambdabot> nubBy eq []             =  []
11:10:19 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:11:09 <tromp_> i am getting rather confused by the ErrorT monad transformer
11:11:56 <tromp_> i have a State monad (call it m) that I'm trying to add error handling to
11:12:41 <tromp_> i used to call execState on this monad, and now I want to do the equivalent on ErrorT e m
11:13:22 <tromp_> but runErrorT returns its result in monad m
11:14:50 <Deewiant> I think you want StateT with Error instead of ErrorT with State, if I understood you correctly
11:15:02 <Deewiant> ?unmtl StateT s Error a
11:15:02 <lambdabot> s -> Error (a, s)
11:15:20 <Deewiant> ?unmtl StateT x (Either String a)
11:15:20 <lambdabot> err: `StateT x (Either String a)' is not applied to enough arguments, giving `/\A. x -> Either String a (A, x)'
11:15:23 <heatsink> tromp_: If there is an error, do you want to get rid of the state?
11:15:31 <Deewiant> ?unmtl StateT x (Either String) a
11:15:31 <lambdabot> x -> Either String (a, x)
11:16:07 <tromp_> i want to get either an errormsg or the final state
11:16:08 <Deewiant> hm
11:16:09 <Deewiant> ?unmtl ErrorT b (State x) a
11:16:09 <lambdabot> x -> (Either b a, x)
11:16:43 <heatsink> tromp_: Then Deewiant's suggestion is right.
11:17:31 <tromp_> but conceptually, that's backward
11:17:45 <tromp_> i have a working State monad. and want to add error handling to it
11:18:14 <mux> I want monad lifting inference, or whatever it should be called :)
11:18:36 <heatsink> But you don't want to just add error handling on top of state.  You want the error handling to decide what to do with the state (drop the state when an error occurs).
11:19:44 <tromp_> i want runErrorT to give type Either e s rather than m (Either e s)
11:21:03 <tromp_> let me ponder this some more...
11:21:04 <heatsink> Where did m go?
11:21:16 <BMeph> tromp_: Exactly, you want StateT of Either. :)
11:21:22 <Baughn> Has anyone noticed that haskell-mode seems not to grok {-- comments?
11:21:39 <Baughn> {-, I mean
11:22:01 <tromp_> i hoped ErrorT would proveide an equivalent to execState, that gets me out of the monad
11:22:15 <tromp_> but seems it doesn't
11:22:26 <BMeph> tromp_: "evalStateT :: Monad m => StateT s m a -> s -> m a"
11:22:57 <tromp_> ok, looks like i have to reorder my monads
11:25:09 <vixey> :t ErrorT
11:25:10 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
11:25:16 <vixey> :k ErrorT
11:25:17 <lambdabot> * -> (* -> *) -> * -> *
11:25:20 <vixey> @src ErrorT
11:25:20 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
11:25:42 <vixey> :t execState
11:25:43 <lambdabot> forall s a. State s a -> s -> s
11:26:35 <BMeph> tromp_: Consider that there is no IOT - you can't add things "inside" IO; you /can/ add IO inside other things, though. :)
11:26:51 <heatsink> Baughn: They work for me.  It doesn't understand nested block comments though.
11:27:02 <tromp_> i'm not using IO at all
11:27:33 <BMeph> tromp_: What, not ever? ;) -- I was using IO as an example, not a suggestion
11:27:58 <Asoni> bang head, bang head ....
11:28:08 <tromp_> just not in this program: http://homepages.cwi.nl/~tromp/go/Go.hs
11:28:37 * BMeph points Asoni to the AC/DC display - great fun for all the head-bangers... ;)
11:29:50 <Baughn> heatsink: I get mismatch errors when it tries to match parens. Then I get "illegal token: layout-next" when I attempt to press enter when the point is on one.
11:30:01 <Baughn> heatsink: I think it might only happen with the haskell-indentation module, though, not haskell-indent
11:30:08 <BMeph> tromp_: While I love all the great work CWI does, my company proxy forbids looking at anything in the homepages sub-domain; it things it's pr0n. :\
11:30:22 <Asoni> Thanks AC/DC might chill me out. :)   Have to ask: is keeping GHC, cabal, packages up to date this difficult?
11:30:22 <heatsink> Ah.  I use haskell-indent.
11:31:23 <tromp_> BMeph: http://www.cwi.nl/~tromp/go/Go.hs
11:31:55 <tromp_> i never liked the homepages name either...
11:32:40 <roconnor> how come my hackage upload didn't generate haddock documenation?
11:32:53 <tromp_> i just want to replace the three errors in there with data GoError = Occupied | GameOver | Superko
11:33:22 <tromp_> hope it doesn't require a big rewrite:(
11:33:48 <Deewiant> roconnor: if there's no "Built on" yet it means it hasn't tried to build it yet
11:35:33 <TomMD> Scanning over the recent DPH paper, I don't see any benchmarks.  Are performance numbers forthcoming?  Is there still significant work needed on this?
11:35:37 <BMeph> Asoni: You mean "cabal update && cabal upgrade"? :)
11:35:44 <roconnor> Deewiant: oh, is there a queue?
11:36:09 <BMeph> tromp_: No dice, it still goes to the homepages, and gets flagged for pr0n. :(
11:36:28 <Deewiant> roconnor: I don't know, but it doesn't do it instantaneously. Maybe it checks every hour or something.
11:36:33 <tromp_> ok, let me hpaste it
11:36:39 <roconnor> Deewiant: thanks
11:36:43 * BMeph prefers his pr0n with ketchup and horseradish
11:37:11 <tromp_> http://hpaste.org/11366
11:53:45 <tromp_> ok, i managed with the original ErrorT State approach
11:57:07 <BMeph> tromp_: Conga-rats. :)
12:07:07 <tromp_> thanks!
12:09:59 <jeffersonheard> you know what I wish Haskell had...  a way to specify functions to use when particular types are required.  Like some way to say that whenever inside this function, you see a need for a (CInt -> Int), use fromIntegral to fulfill it
12:10:21 <mauke> please no
12:10:30 <BONUS_> usually typeclasses are used to solve stuff like that
12:10:33 <Baughn> @hoogle Fractional a => a -> a -> a
12:10:33 <lambdabot> Prelude (/) :: Fractional a => a -> a -> a
12:10:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
12:10:34 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
12:10:45 <mauke> C++ does that, and it likes to explode in your face
12:11:57 <Apocalisp> @djinn f x = f f x
12:11:58 <lambdabot> Cannot parse command
12:12:13 <Apocalisp> @pl f x = f (f x)
12:12:13 <lambdabot> f = fix (join (.))
12:12:34 <luqui> that is "proof search"
12:12:34 <heatsink> @quote
12:12:35 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
12:12:44 <luqui> which is handy, but nonmodular.  it would well in an interactive envt
12:12:51 <Apocalisp> oh yea, djinn works on types
12:13:01 <Apocalisp> duh
12:13:11 <TomMD> @pl (\x -> x) -- truly pointless programming.
12:13:11 <lambdabot> id
12:13:33 <opqdonut> Apocalisp: it works in a variant of strongly-typed lambda-calculus without fix and undefined
12:13:36 <luqui> @pl \x -> x * 1
12:13:36 <lambdabot> id
12:13:45 <Apocalisp> what do you call that combinator? fix (join (.)) ?
12:13:56 <TomMD> @pl flip (\x y -> x) undefined
12:13:56 <lambdabot> id
12:14:02 <TomMD> smart, too.
12:14:05 <BONUS_> how come it does id for \x -> x * 1
12:14:09 <BONUS_> hmm
12:14:10 <roconnor> Apocalisp: YWB
12:14:14 <BONUS_> :t (\x -> x * 1)
12:14:14 <mauke> Apocalisp: 'error'
12:14:14 <lambdabot> forall a. (Num a) => a -> a
12:14:15 <roconnor> er
12:14:18 <BONUS_> :t id
12:14:19 <TomMD> BONUS_: I assume it defaults x :: Int
12:14:20 <lambdabot> forall a. a -> a
12:14:22 <BONUS_> ah
12:14:26 <luqui> BONUS_, freaked me out too.  but it's probably just a hardwired ident
12:14:27 <roconnor> Apocalisp: BYWB ?
12:14:28 <opqdonut> :t fix (join (.))
12:14:29 <lambdabot> forall b. b -> b
12:14:36 <heatsink> @pl \x -> x * x >= 0
12:14:36 <lambdabot> (>= 0) . join (*)
12:14:38 <Apocalisp> BYOB?
12:14:45 <roconnor> :D
12:15:07 <TomMD> Haskell is BYOT (Bring your own type).
12:15:18 <TomMD> *types
12:15:23 <luqui> @pl \x y -> x + y == y + x
12:15:24 <lambdabot> ap (ap . ((==) .) . (+)) (+)
12:15:35 <luqui> @pl \x y -> x + 0 + y
12:15:35 <lambdabot> (+)
12:15:44 <Apocalisp> @type join fmap
12:15:46 <lambdabot> forall a. (a -> a) -> a -> a
12:15:54 <luqui> @pl \x -> x - x
12:15:54 <lambdabot> const 0
12:15:57 <luqui> sweeet
12:16:13 <jeffersonheard> Oh, and yeah, I know that what I suggested is evil, but it's so CONVENIENT
12:16:35 <jeffersonheard> and it would only go in a where clause and be function specific, I promise :)
12:16:44 <vixey> jeffersonheard: typeclasses
12:16:49 <luqui> > fmap fix return 42
12:16:50 <lambdabot>   42
12:16:53 <vixey> class Cast a b where cast :: a -> b
12:17:13 <jeffersonheard> vixey: FFI -- typeclasses are no help when you need to return an int and you get a CInt
12:17:16 <vixey> 12 * (cast) "3"
12:17:39 <luqui> jeffersonheard, I think you actually want a nice ide.
12:17:41 <jeffersonheard> or really, you just don't want to return a CInt and have it pollute your code later
12:17:43 <vixey> jeffersonheard: That didn't make any sense
12:18:01 <luqui> ad-hoc convenience features are best not hardwired into the syntax, since they are not modular, so they are brittle to modifications
12:18:20 <jeffersonheard> luqui:  yeah, lekseh is too much of a pain to build on windows right now, but I'm waiting for the next release
12:18:43 <Deewiant> > (\x -> x - x) (0 / 0)
12:18:45 <lambdabot>   NaN
12:18:47 <Deewiant> > const 0 (0 / 0)
12:18:48 <lambdabot>   0
12:18:49 <Deewiant> luqui: ^
12:18:57 <Deewiant> lambdabot fails at floating point
12:19:12 <luqui> yes indeed...
12:19:24 <luqui> but I think that's more because floating point fails.
12:19:32 <Deewiant> well, it fails at math too
12:19:35 <Deewiant> > (\x -> x - x) (1 / 0)
12:19:36 <lambdabot>   NaN
12:19:44 <Deewiant> infinity - infinity is undefined
12:19:53 <heatsink> :t limit
12:19:54 <lambdabot> Not in scope: `limit'
12:19:57 <heatsink> :t lim
12:19:58 <lambdabot> Not in scope: `lim'
12:20:00 <luqui> so there aren't additive inverses.
12:20:02 <rwbarton> > (\x -> x - x) (1 / 0) :: Rational
12:20:03 <lambdabot>   * Exception: Ratio.%: zero denominator
12:20:04 <jeffersonheard> vixey: You've never run into the situation where you get a function that returns a bunch of CInts that you need to manipulate with Haskell functions that require Ints as parameters?  Yes, I know I can type fromIntegral a bunch of times, or throw them into a list and call map and pattern match out, but that seems so common a pattern that there should be a more convenient way to do it
12:20:19 <simony> cabal-install's "Setup configure --user" spits out "** Exception: lexical error at character '\DEL'"
12:20:31 <simony> what does that mean?
12:20:36 <vixey> jeffersonheard: so don't use the function that returns a CInt
12:20:37 <jeffersonheard> my argument is not that it would be a good thing.  Just that I want it
12:20:45 <luqui> jeffersonheard, really, that's common?  I come across stuff like that every once in a while
12:20:46 <vixey> jeffersonheard: instead use a function that gives Int
12:21:14 <rwbarton> jeffersonheard: sounds like you're doing lots of FFI?  aren't there specific tools for this kind of problem?
12:21:24 <Vulpyne> Are there currently any Haskell projects that use readline in an asynchronous fashion?
12:21:35 <jeffersonheard> rwbarton: yes, that's exactly what I'm doing
12:21:53 <jeffersonheard> and I'm using hsc2hs, but the documentation I've found is fairly lacking
12:27:02 <simony> weird. cabal-install's Setup configure --user    managed to fail on a silly lexical error, then afterwards completely hang the machine (by thrashing memory), and then later, when I compiled Setup with -O2, it just quietly succeeded
12:28:36 <RayNbow> hmm, there's an error in Data.IntSet's documentation...
12:29:37 <Deewiant> RayNbow: what's the error
12:30:31 <RayNbow> http://hackage.haskell.org/packages/archive/containers/0.1.0.1/doc/html/Data-IntSet.html#v%3Asplit
12:30:38 <RayNbow> "split 3 (fromList [1..5]) == (fromList [1,2], fromList [3,4])"
12:30:40 <RayNbow> should be:
12:30:50 <RayNbow> "split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])"
12:30:53 <lambdabot> Title: Data.IntSet, http://tinyurl.com/5qn5tl
12:30:57 <Deewiant> yeah, true
12:31:00 <Deewiant> file a ticket :-)
12:31:10 <LynxAba> hello everybody!
12:31:12 <RayNbow> I'm registering an account :p
12:31:16 <LoneTech> maxView and minView could use something to separate the sentences.
12:31:18 <LynxAba> i have a doubt with this sintax
12:31:33 <mauke> preflex: ? .ve
12:31:33 <preflex>  Venezuela
12:31:57 <LynxAba> preflex: hola! justamente soy de Venezuela, tu también?
12:32:25 <preflex> I'm just a bot!
12:32:26 <sebaseba> lol
12:32:30 <vinicius> LynxAba: it's a bot answering mauke's query
12:32:41 <LynxAba> for real? XD
12:32:43 <LynxAba> so lame...
12:32:46 <LynxAba> anyway
12:33:03 <LynxAba> i have a doubt with the \ symbol in this line:
12:33:04 <LynxAba> map (\class -> Unit (class, 100, Jugador1)) ["Infanteria", "Infanteria", "Infanteria", "Tanque", "Tanque", "Artilleria", "Carnicero"]
12:33:18 <SamB_XP> vinicius: any clue why it said "I'm just a bot!"?
12:33:36 <LoneTech> SamB: unknown command
12:33:43 <LynxAba> hehe maybe that's its default answer when he doesn't understand something
12:33:46 <vinicius> ^
12:34:08 <LynxAba> *when it ...
12:34:18 <sebaseba> ?users
12:34:19 <lambdabot> Maximum users seen in #haskell: 543, currently: 542 (99.8%), active: 30 (5.5%)
12:34:23 <LoneTech> LynxAba: that looks like an ordinary lambda expression
12:34:47 <LynxAba> yes but what i don't understand is the backslash... what is for?
12:34:49 <preflex> @vixen a/s/l?
12:34:50 <lambdabot> 19/f/California
12:35:09 <LoneTech> LynxAba: in place of a lambda. it creates an unnamed function
12:35:25 <Deewiant> who can access preflex like that :-P
12:35:25 <LoneTech> in this case, it accepts one argument (class) and its value is what's after the arrow.
12:35:51 <RayNbow> > (\x y -> x + y) 3 4
12:35:53 <lambdabot>   7
12:35:53 <dobblego> LynxAba, if you were to replace lambda with an ASCII character what would you use?
12:35:54 <LynxAba> hhmmmm interesting, is like the "where" then ?
12:36:13 <dobblego> no where is for something different; a lambda is like a function without a name
12:36:25 <mauke> > (\class -> (class, "wat")) 42
12:36:26 <lambdabot>   <no location info>: parse error on input `class'
12:36:28 <LynxAba> ok, i get it, thanks
12:36:29 <LoneTech> that line is something like [Unit (x, 100, Jugador1) | x <- ["Infanteria", ...]]
12:36:31 <dobblego> the -> part of the expression is also crucial in understanding it
12:36:42 <heatsink> LynxAba: The military employs butchers?
12:37:05 <LynxAba> hahaha it's just a crazy definition from a project i have to develop
12:37:16 <LynxAba> it's called HWars XD
12:37:26 <LynxAba> like a litlle warcraft but in haskell
12:37:32 <heatsink> Hm, interesting.
12:37:35 <LynxAba> yup
12:38:11 <LynxAba> do you want to read the pdf? the only thing is that is written in spanish
12:40:22 <heatsink> LynxAba: sure
12:40:25 <LoneTech> btw, I tried using HGL's timer tick feature. It seems not to work properly unless the program is built with -threaded.
12:41:47 <LynxAba> this is the main pdf: http://www.ldc.usb.ve/~caperez/ci3661/sd08/haskell/proy2.pdf, and this are some aclaration of the previous document: http://www.ldc.usb.ve/~caperez/ci3661/sd08/haskell/aclaratorias-proy2.txt
12:41:54 <lambdabot> Title: cache:http://www.ldc.usb.ve/~caperez/ci3661/sd08/haskell/proy2.pdf - Google Sear ...
12:41:59 <LynxAba> **aclarations
12:43:43 <luqui> ahh, aclaration = explanation :-)
12:44:16 <LynxAba> excuse my bad english  i meant clarifications
12:44:35 <luqui> ah.
12:44:40 <LynxAba> in spanish is "aclaraciones"
12:44:44 <LynxAba> hehe ^^'
12:44:51 <luqui> I can't help but to do the same thing going from english to spanish...
12:45:07 <LynxAba> yup, is a common issue
12:45:12 <luqui> so many words are similar, it's easy to get lazy
12:45:22 <LynxAba> hehehe right
12:46:08 <LynxAba> well, i have to go
12:46:15 <LynxAba> goodbye and thanks!
12:50:55 <Apocalisp> Idempotence! Phew. That was driving me crazy.
12:51:38 <mauke> in perl 'return' is idempotent
12:51:46 <idnar> @src gcd
12:51:47 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
12:51:47 <lambdabot> gcd x y = gcd' (abs x) (abs y)
12:51:47 <lambdabot>    where gcd' a 0  =  a
12:51:47 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
12:51:57 <luqui> mauke, that's just because it escapes right?
12:52:08 <luqui> er, returns immediately
12:52:14 <mauke> yeah :-)
12:52:39 <mauke> see also: die, last, next, redo, die
12:52:48 <mauke> -die
12:55:33 <vinicius> > gcd 4 2
12:55:35 <lambdabot>   2
12:55:43 <vinicius> > gcd 9128391829389182 8172381782738172837
12:55:44 <lambdabot>   1
12:55:50 <badger> heh
12:55:51 <vinicius> nice
12:55:53 <conal> @pl \ ((a,b),(c,d)) -> ((a,c),(b,c))
12:55:54 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . (. (,)) . ap . ((,) .) . (,)))
12:55:59 <conal> wow
12:56:15 <Deewiant> @pl \((a,b),(c,d)) -> ((a,c),(b,d))
12:56:16 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
12:56:20 <vinicius> is there a @ command for arrows and applicative?
12:56:37 <camio> That's incredible.
12:56:40 <vinicius> *pretty-arrows pretty-applicative
12:56:42 <luqui> Does anyone know of a lazy Map implementation, or how one might make it?
12:56:59 <conal> luqui: lazy in the keys?
12:57:01 <luqui> lazy = spine-lazy, so it can store infinitely many assocs
12:57:02 <luqui> yeah
12:57:13 <Deewiant> luqui: [(key,value)]
12:57:22 <luqui> I forgot to say efficient :-)
12:57:26 <Deewiant> :-P
12:57:53 <conal> there are papers on "lazy memo functions".  one by john hughes and one by byron cook.
12:58:26 <conal> oops.
12:58:28 <conal> @pl \ ((a,b),(c,d)) -> ((a,c),(b,d))
12:58:29 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,)))
12:58:41 <luqui> yeah that's a pretty one :-)
12:58:42 <conal> wowzers
12:59:15 <conal> yeah, it has some pretty repeated structure
12:59:15 <camio> Is there anything that can't be done?
12:59:20 <vixey> @let swap (x,y) = (y,x)
12:59:22 <lambdabot>  Defined.
12:59:23 <vixey> :t swap `on` swap
12:59:24 <lambdabot>     Couldn't match expected type `(t, t1) -> c'
12:59:24 <lambdabot>            against inferred type `(t1, t)'
12:59:24 <lambdabot>     Probable cause: `swap' is applied to too many arguments
12:59:30 <luqui>  @pl isn't perfect, there might be ways you could make it slightly better... but that kind of function is really meant for pointful programming
12:59:48 <luqui> camio, what do you mean?
13:00:07 <conal> @ty ((.) .) . (. (,))
13:00:08 <lambdabot> forall b c a a1 b1. ((b1 -> (a1, b1)) -> b -> c) -> a1 -> (a -> b) -> a -> c
13:00:08 <luqui> write an algorithm that finds whether an untyped LC term has a normal form?
13:00:12 <camio> I wonder if it has the full expressitivity of something like DeepArrows.
13:00:17 <BMeph> conal: We need better names for pair-flipping tricks like that and (***). :)
13:00:28 <conal> BMeph: yeah
13:00:43 <conal> @ty flip flip fst
13:00:44 <lambdabot> forall a c a1 b. (a -> ((a1, b) -> a1) -> c) -> a -> c
13:01:27 <luqui> camio, are you asking whether every function has a pointfree repr?
13:01:34 <Deewiant> ?ty join (***) fst &&& join (***) snd
13:01:35 <lambdabot> forall a b. ((a, b), (a, b)) -> ((a, a), (b, b))
13:01:36 <Deewiant> darn
13:01:46 <BMeph> conal: Of course, I think of uncurry (***) as a pair/(->) transpose. ;)
13:01:47 <Deewiant> ?ty (fst *** fst) &&& (snd *** snd)
13:01:48 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> ((a, a1), (b, b1))
13:01:55 <Deewiant> conal: there you go
13:02:07 <luqui> oh wow, I am amazed
13:02:11 <conal> oh, of course.
13:02:12 <luqui> that's very pretty
13:02:19 <camio> luqui: Yes. And if the answer is yes, I want to know if it is possible.
13:02:31 <camio> Hey that's awesome. I've got my transpose function :)
13:02:33 <luqui> camio, what do you mean possible?
13:02:42 <camio> possible with @pl
13:02:47 <luqui> camio, and I won't have to kill you
13:02:53 <luqui> camio, oh to derive it?
13:02:55 <BMeph> ?ty uncurry ((fst *** fst) &&& (snd *** snd))
13:02:56 <lambdabot>     Couldn't match expected type `b -> c'
13:02:56 <lambdabot>            against inferred type `((a, a1), (b1, b2))'
13:02:56 <lambdabot>     Probable cause: `&&&' is applied to too many arguments
13:03:00 <camio> It's a shame. Today is a good day to die.
13:03:06 <BMeph> Boo! :\
13:03:11 <conal> Deewiant: thanks.  very pretty!
13:03:11 <camio> luqui: yeah
13:03:12 <Deewiant> BMeph: it's already uncurried :-P
13:03:26 <luqui> camio, the answer is yes.  straightforward SK+Y factorization
13:03:38 <Deewiant> conal: no problem, took a while to work out though :-P
13:03:40 <luqui> (you need Y because of the type system)
13:03:53 <BMeph> Deewiant: Yeah, I always have to think of currying a horse to remember that. :)
13:04:07 <BMeph> ?ty curry ((fst *** fst) &&& (snd *** snd))
13:04:08 <lambdabot> forall a b a1 b1. (a, b) -> (a1, b1) -> ((a, a1), (b, b1))
13:04:34 <camio> Deewiant: What was your process for figuring it out?
13:04:45 <Apocalisp> ?ty (curry . curry) ((fst *** fst) &&& (snd *** snd))
13:04:46 <Deewiant> camio: argh, let's see :-P
13:04:47 <lambdabot> forall a b a1 b1. a -> b -> (a1, b1) -> ((a, a1), (b, b1))
13:05:14 <Deewiant> camio: Right, I started from \(x,y) -> ((fst x, fst y), (snd x, snd y))
13:05:47 <Deewiant> which is \x -> ((fst *** fst) x, (snd *** snd) x)
13:05:51 <luqui> camio, actually writing a @pl which converts to SK calculus is a fun little exercise.
13:05:54 <Apocalisp> ?ty (((join (.)) curry) ((fst *** fst) &&& (snd *** snd))
13:05:54 <Deewiant> which is what I then said.
13:05:55 <lambdabot> parse error (possibly incorrect indentation)
13:06:15 <Apocalisp> ?ty ((join (.)) curry) ((fst *** fst) &&& (snd *** snd))
13:06:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
13:06:16 <lambdabot>     Probable cause: `curry' is applied to too few arguments
13:06:16 <lambdabot>     In the first argument of `(join (.))', namely `curry'
13:06:31 <camio> Deewiant: Thanks for the insight!
13:11:24 <Apocalisp> @type (curry .) . curry (curry ((fst *** fst) &&& snd *** snd))
13:11:25 <lambdabot> forall a a1 a2 b. a1 -> a -> a2 -> b -> ((a1, a2), (a, b))
13:11:43 <vixey> ?djinn a1 -> a -> a2 -> b -> ((a1, a2), (a, b))
13:11:44 <lambdabot> f a b c d = ((a, c), (b, d))
13:12:11 <Apocalisp> @pl f a b c d = ((a, c), (b, d))
13:12:11 <lambdabot> f = (. (,)) . flip . (((.) . (,)) .) . (,)
13:12:14 <Apocalisp> hah
13:12:46 <luqui> I still don't know whether ((fst  *** fst) &&& (snd *** snd)) is clearer than transpose ((a,b),(c,d)) = ((a,c),(b,d))
13:12:56 <luqui> in fact, yeah, I like the tuple version much better
13:13:05 <luqui> er, the pointful version
13:14:00 <luqui> @pl f ((a,b),(c,d)) = (((a,b),c),d)
13:14:01 <lambdabot> f = uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . ((,) .) . (,)) .) . (,)))
13:14:06 <camio> luqui: Do you like it that it is shorter?
13:14:15 <luqui> no, I like that it says exactly what it is
13:14:31 <luqui> a total noob understands in seconds
13:14:46 <luqui> the former requires quite a deal of sophistocation
13:14:57 <vixey> someone experinced thinks "why the hell are you futzing around with tuples and that"
13:15:16 <Apocalisp> Haskell exercise: Prove that  (. (,)) . (((.) . (,)) .) . (,) is equivalent to (((.) . (,)) .) . (. (,)) . (,)
13:15:31 <vixey> :t (. (,)) . (((.) . (,)) .) . (,)
13:15:32 <lambdabot> forall a b b1 a1 a2. a2 -> a -> (a1 -> b1) -> a1 -> ((a2, b -> (a, b)), b1)
13:15:35 <vixey> :t (((.) . (,)) .) . (. (,)) . (,)
13:15:36 <lambdabot> forall b a a1 b1 a2. a2 -> a1 -> (a -> b) -> a -> ((a2, b1 -> (a1, b1)), b)
13:15:39 <vixey> QED.
13:15:58 <luqui> by parametericity.  the free thoerem will guarantee uniqueness :-)
13:15:59 <Apocalisp> :)
13:16:14 <opqdonut> :D
13:16:37 <vixey> @free gobble :: a2 -> a -> (a1 -> b1) -> a1 -> ((a2, b -> (a, b)), b1)
13:16:38 <lambdabot> k . q = f1 . h => (forall u v. (forall f3. (forall f4 f5. $map_Pair g p . f4 = f5 . p                                        =>                                         f3 f4 = f5)
13:16:38 <lambdabot>      =>                          $map_Pair f f3 u = v)             =>              f2 u = v) => $map_Pair f2 k (gobble x y q z) = gobble (f x) (g y) f1 (h z)
13:16:47 <camio> luqui: Can one learn haskell by starting with arrows and such and then later learning how to do pointful form?
13:17:00 <int-e> > const 42 $ ((. (,)) . (((.) . (,)) .) . (,)) `asTypeOf` ((((.) . (,)) .) . (. (,)) . (,))
13:17:02 <lambdabot>   42
13:17:06 <luqui> camio, presumably, but have you tried to learn category theory?
13:17:38 <luqui> it is *really hard* to learn to think that way.  points provide a nice crutch, to ease you from your old way of thinking into a new one
13:18:12 <luqui> and some things are just nicer with points.  e.g. the quadratic formula :-)
13:18:24 <int-e> > const 42 $ flip (,) `asTypeOf` (,)
13:18:25 <lambdabot>   42
13:18:28 <int-e> :(
13:18:33 <camio> luqui: Well, we only know it is hard after learning the pointful way first.
13:18:36 <Vulpyne> Is there a nicer way to make this function/types? http://hpaste.org/11369
13:18:44 <luqui> camio, could be
13:18:56 <vixey> Vulpyne: Use real names
13:19:04 <Vulpyne> For the type variables?
13:19:12 <plutonas> i'm going through old exam questions and can't solve one, perhaps one can help me: The standard prelude contains the following function (here the source for lookup appears). Define f and i so that the expression foldl (f key) i is an equivalent definition of lookup key.
13:19:13 <vixey> Vulpyne: I don't know what an "Rd" is
13:19:15 <vixey> for example
13:19:19 <camio> I'm curious what would the world be like if the "liberated from Von Numan" guy got his way.
13:19:41 <Vulpyne> Well, that's not the part I was talking about. :) (Although it's a way to hook up functions to a channel with an establish, read, send, close method.)
13:19:52 <vixey> Vulpyne: That's the most important thing here
13:19:56 <Vulpyne> I was just wondering if there was a nicer way to do it without so much passing of cthe type variables.
13:20:08 <vixey> "forall a b c d." is superflousao
13:20:54 <luqui> Vulpyne, I would use a record for those arguments
13:20:58 <mauke> plutonas: consider foldl (f key) i []
13:21:22 <Vulpyne> Okay, thanks.
13:21:36 <plutonas> oh i thought i should be the list applied
13:21:37 <luqui> @pl conj f f' x = f . x . f'
13:21:37 <lambdabot> conj = (. flip (.)) . (.) . (.)
13:21:56 <rwbarton> Vulpyne: can you give the type variables a b c d descriptive names?
13:22:04 * luqui dares camio to convert conj, a very nice function for writing pointfree functions, to nice pointfree form
13:22:25 <vixey> @let conj f f' x = f . x . f'
13:22:26 <lambdabot>  Defined.
13:22:27 <Vulpyne> I could, it would make the function definition really long though.
13:22:27 <vixey> :t conj
13:22:28 <lambdabot> forall c1 c a b. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
13:22:35 <BMeph> luqui: Point-free style is all the rage...in Forth/Factor. ;)
13:22:40 <vixey> :t \f f' -> (f .) . (. f')
13:22:41 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
13:22:48 <vixey> @pl \f f' -> (f .) . (. f')
13:22:48 <lambdabot> (. flip (.)) . (.) . (.)
13:22:52 <vixey> :/
13:23:03 <camio> @impl conj
13:23:03 <lambdabot> Maybe you meant: pl unpl
13:23:15 <vixey> :t (. flip (.))
13:23:17 <lambdabot> forall c b c1 a. (((b -> c1) -> a -> c1) -> c) -> (a -> b) -> c
13:23:32 <camio> Hrm, I forget how to query the implementation of a function.
13:23:34 <vixey> that's interesting
13:23:42 <vixey> camio: just scroll up a bit
13:23:43 <luqui>  conj f f' x = f . x . f'
13:24:00 <Vulpyne> I guess it doesn't really matter.
13:24:18 <vixey> Vulpyne: Using meaningful names in programming does matter!
13:24:49 * camio cowardfully refuses the dare stating that he could do it if he felt like it ;-)
13:24:50 <Vulpyne> vixey: I use them most of the time. :)
13:25:04 <luqui> moreso in FP than imperative IMO.
13:25:09 <Vulpyne> In this case, it's just a couple of functions that are plumbing and won't be accessed directly.
13:25:24 <rwbarton> Vulpyne: Are you sure you don't want a type class?
13:26:00 <Vulpyne> Hmm, I don't think so.
13:26:00 <plutonas> is there a function that takes a function as argument and retuns the inverse? that is it takes the result as argument, and returns the argument of the original?
13:26:04 <BMeph> camio: By the "liberation" guy, do you mean John Backus? :)
13:26:11 <vixey> plutonas: hahah no
13:26:15 <Vulpyne> I guess it could be made to work that way, but I'm not sure if it would be an advantage.
13:26:20 <Baughn> plutonas: Absolutely impossible
13:26:22 <camio> BMeph: yeah
13:26:28 <vixey> plutonas: If the function is total and has a finite domain you could implement it
13:26:42 <luqui> plutonas, also in a few other specific cases
13:26:47 <plutonas> perhaps i missunderstood my problem
13:27:11 <plutonas> i want to construct a function of type ((b -> a) -> c) -> ((a -> b) -> c)
13:27:13 * luqui ponders.   inverse fix :: a -> (a -> a)
13:27:24 <vixey> ?djinn ((b -> a) -> c) -> ((a -> b) -> c)
13:27:24 <lambdabot> -- f cannot be realized.
13:27:28 <luqui> plutonas, that's called "flip"
13:27:30 <vixey> don't bother
13:27:35 <vixey> it cannot be done
13:27:35 <luqui> er no
13:27:37 <plutonas> no it's not called flip
13:27:44 <luqui> right wrong associativity :-)
13:27:48 <vixey> what would you use this function for?
13:27:52 <plutonas> ok, then perhaps i didn't compute the type correctly?
13:27:55 <plutonas> the question says
13:27:58 <Heffalump> luqui: inverse fix = const
13:28:06 <plutonas> flip (curry f) = curry (f.swap)
13:28:08 <luqui> ah that's a nice inverse...
13:28:09 <plutonas> i have to write swap
13:28:35 <vixey> :t (flip (curry ?f)) `asTypeOf` curry (?f . swap)
13:28:36 <lambdabot> forall c a b. (?f::(b, a) -> c) => a -> b -> c
13:28:39 * luqui wonders if there is some nice domain theory about inverses.  you know how fixed points became computable by computing the least one...
13:28:54 <mauke> :t swap
13:28:55 <lambdabot> forall t t1. (t, t1) -> (t1, t)
13:29:04 <dolio> @type fix . const
13:29:05 <lambdabot> forall a. a -> a
13:29:15 <dolio> @type const . fix
13:29:16 <lambdabot> forall b a. (a -> a) -> b -> a
13:29:20 <plutonas> so i calculated the type wrongly?
13:29:25 <luqui> @type fix <$> const
13:29:26 <lambdabot> forall a. a -> a
13:29:38 <plutonas> i thought that hte left side is (b -) a -> c)
13:29:47 <plutonas> and i should have the same on the right side
13:30:04 * BMeph is disappointed that Category got invented as a module, but 'swap' is still not top-level.
13:30:23 <idnar> are there Debian packages for ghc 6.10 yet?
13:30:30 <dolio> What do you mean top level?
13:30:31 <luqui> BMeph, oh category made it into base?
13:30:37 <vixey> ***type level
13:30:38 <vixey> :D
13:31:04 <rwbarton> Vulpyne: something like class Chan est snd rd chan where establish :: est -> IO chan; send :: chan -> snd -> IO (); read :: chan -> IO (Maybe rd); close :: chan -> IO ()
13:31:06 <BMeph> vixey: Hush. ;p
13:31:26 <rwbarton> Vulpyne: but then, I'm not really sure what you're trying to do, so feel free to ignore me :)
13:31:39 <Vulpyne> rwbarton: I annotated my original paste with the whole scary chunk of code. :)
13:31:42 <vixey> that's crazy
13:31:44 <BMeph> dolio: I mean it's used as an aux function in C.Arrow, but hasn't seen fit to be declared as a top-level function.
13:31:45 <luqui> @info Category
13:31:46 <lambdabot> Category
13:31:55 <vixey> 21 upvotes on reddit for coq tutorial :S
13:32:01 <Vulpyne> rwbarton: Basically, I'm trying to make a STM TChan interface for IO.
13:32:03 <dolio> BMeph: Oh. It should be in Data.Tuple in 6.10, I think.
13:32:04 <luqui> :t (>>>)
13:32:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:32:08 <luqui> :t (.)
13:32:09 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:32:12 <dolio> Along with fst3 and company.
13:32:16 <vixey> I thought they hated that stuff
13:32:18 <dolio> At least, I thought that was going in.
13:32:41 <BMeph> vixey: Ladies love the Coq? ;p
13:32:45 <luqui> Vulpyne, what do you mean by that?
13:32:53 * luqui loves Coq extensions
13:33:16 * BMeph snorts all over the workbench
13:33:16 * Baughn wonders if, given sufficient spam mail, Coq can reach FTL speeds
13:33:48 <Vulpyne> luqui: Basically, for network applications, you can't use orElse from STM on IO, because it blocks. But you can use it for multiplexing TChans.
13:34:05 * BMeph wonders if Coq will need extra...stiffening to withstand the speed
13:34:10 <Vulpyne> luqui: So basically, it's for making something like a network stream look like a TChan that just sends events.
13:34:34 <luqui> Vulpyne, ah nice.  hmm, I just wrote a module that might be of interest to you
13:34:40 <SamB_XP> luqui: do you know of any ?
13:34:46 <Vulpyne> luqui: Really? What is it?
13:34:47 <vixey> http://www.ucalgary.ca/~rzach/logblog/2008/04/linear-logic-is-pseudoscience.html
13:34:48 <vixey> amusing
13:34:49 <lambdabot> Title: LogBlog: Linear Logic is Pseudoscience? | Richard Zach | Philosophy | University ..., http://tinyurl.com/5pzsq7
13:35:00 <luqui> Vulpyne, data-ivar. I'm not sure how applicabile it is, but it's kind of the same idea
13:35:10 <Vulpyne> luqui: Did you look at my code?
13:35:25 <luqui> Vulpyne, you mean that crazy complicated type signature?
13:35:28 <dolio> vixey: That title doesn't make any sense.
13:35:42 <Vulpyne> luqui: I annotated that with the whole module.
13:35:47 <luqui> ah
13:35:48 <vixey> the article is funny
13:35:50 <vixey> to me
13:35:56 <Vulpyne> Write once variables doesn't really sound similar to me.
13:36:27 <Vulpyne> Wouldn't that be sort of like blocking on a bunch of tchans?
13:36:48 <luqui> Vulpyne, oh my god.
13:36:53 <luqui> that code almost made me go blind
13:36:58 <sjanssen> Vulpyne: hmm, that could be rather useful, actually
13:37:12 <luqui> Vulpyne, yeah it is.  maybe I misunderstood what you're doing.
13:37:45 <sjanssen> Vulpyne: though I would recommend using a TMVar rather than a TChan
13:37:59 <Vulpyne> luqui: Well, my main motivation was to try to combine Readline and network connections.
13:39:08 <Vulpyne> Sorry about your blindness. :P
13:39:21 <Vulpyne> monthread is pretty scary, the rest isn't too bad.
13:39:52 <dolio> vixey: Girard puts pictures of skunks in his papers?
13:40:00 <plutonas> who can go with me through that and tell where i'm wrong?
13:40:42 <plutonas> curry has type ((a->b)->c)->(a->b->c) so (curry f) means that f has type ((a->b)->c)
13:40:45 <plutonas> is that right?
13:40:53 <vixey> have you seen the ludics thing? It's bizarre..
13:41:11 <vixey> plutonas:
13:41:12 <vixey> :t curry
13:41:13 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:41:15 <dolio> vixey: I think I have it somewhere. I haven't read it, though.
13:41:17 <vixey> :t (flip (curry ?f)) `asTypeOf` curry (?f . swap)
13:41:19 <lambdabot> forall c a b. (?f::(b, a) -> c) => a -> b -> c
13:41:25 <vixey> plutonas: ^ see how it has the type of f there
13:42:16 * RayNbow just found out the hard way that repeatedly using deleteFindMin on an IntSet is a bad idea...
13:42:38 <vixey> "Ludics was proposed by the logician Jean-Yves Girard. His paper introducing Ludics, Locus solum: from the rules of logic to the logic of rules, has some features that may be seen as eccentric for a publication in mathematical logic (such as illustrations of Positive Skunks)."
13:42:40 <vixey> hehe
13:42:42 <plutonas> vixey: i don't exactly understand this question marks and stuff
13:42:57 <Elly> vixey: "positive skunks"?
13:43:09 <plutonas> neither the forall stuff
13:43:10 * vixey better try again to read this
13:43:20 <plutonas> it's not like my ghci gives types...
13:43:21 <vixey> I gave up first time
13:45:27 <Baughn> murklins: So I've got you, xgas, and hopefully syao soon. If I manage to convert quickshot as well, we'll be able to abandon #nanoha. ^_^
13:45:42 <Baughn> (Fear my evil plan)
13:46:23 <murklins> Baughn:  Your plan will never work.  We're all far too lazy.
13:46:28 <dolio> Ah, found it. And there are the skunks.
13:46:40 <Baughn> murklins: See, that's why it's a good plan. Lazy is perfect for haskell.
13:46:49 <dolio> There's an illustration of a fax machine, too.
13:46:59 <dolio> And boots.
13:47:02 <murklins> walked into that one
13:48:02 <idnar> what are generalised list comprehensions?
13:48:10 <Baughn> Monad comprehensions?
13:48:35 <idnar> hmm, no, looks like http://hackage.haskell.org/trac/ghc/wiki/SQLLikeComprehensions
13:48:36 <lambdabot> Title: SQLLikeComprehensions - GHC - Trac
13:48:42 <rwbarton> idnar: it's this weird feature that's added in 6.10 that lets you sort and group in list comprehensions
13:48:47 <Baughn> Oh. That thing.
13:49:14 <Baughn> ..it makes some sense, but it feels too much like LOOP to be entirely comfortable
13:49:21 <rwbarton> Baughn: my thoughts exactly
13:49:29 <rwbarton> we are losing the moral high ground :P
13:49:49 <LarstiQ> hehe :)
13:49:58 <LarstiQ> dare I say, LINQ?
13:51:10 <leimy> sounds neat
13:51:54 <vixey> actually embed SQL in haskell
13:51:58 <leimy> LOOP is really great for those who master it :-)
13:52:05 <vixey> real SQL
13:52:08 <leimy> and a PITA for everyone else
13:52:11 <leimy> SQL is garbage
13:52:14 <leimy> I hate it
13:52:18 <Baughn> leimy: The same could be said about C++
13:52:20 <vixey> SQL is beautiful
13:52:22 <leimy> I prefer the queries in Erlang's MNesia :-)
13:52:36 <vixey> leimy: do you know any good intro to that?
13:52:41 <leimy> SQL is terrible.  you want relational algebra or relational calculus instead :-)
13:53:03 <leimy> Baughn: I guess... I'm good with C++ but wouldn't choose to write new code in it.
13:53:16 <rwbarton> relational calculus?  "DIFFERENTIATE TABLE users WITH RESPECT TO name"
13:53:29 <vixey> haha
13:53:48 <leimy> rwbarton: maybe in cobol :-)
13:54:06 <earthy> SQL sucks and blows chunks at the same time
13:54:35 <vixey> I thought SQL is one really great example of a declarative language
13:54:41 <earthy> ah. not so.
13:54:44 <earthy> no abstraction.
13:54:49 <Baughn> leimy: Part of what attracted me to Haskell was the extreme perpendicularness (er.. maybe) of the concepts. Those generalized list comprehensions feel like they break with that principle..
13:54:58 <Baughn> leimy: By the same token, I'm all for monad comprehensions. :P
13:55:02 <leimy> Baughn: heh :-)
13:55:17 <vixey> I wrote game of life and some linear algebra things in it
13:55:33 <vixey> it reminds me of Haskell to program in
13:55:48 <earthy> vixey: if I want to e.g. make a couple of new tables with a slightly different set of fields from a join over a couple of existing tables I have *no* way of abstracting out that join
13:56:10 <Baughn> earthy: A temporary table?
13:56:13 <vixey> earthy, yeah I'm sure it has limitations like any language around
13:56:26 <earthy> baughn: that is not abstracting out
13:56:30 <earthy> that is chickening out
13:56:31 <luqui> @remember rwbarton relational calculus?  "DIFFERENTIATE TABLE users WITH RESPECT TO name"
13:56:31 <lambdabot> Nice!
13:56:32 <leimy> vixey: http://www.erlang.org/doc/man/qlc.html  perhaps?
13:56:34 <lambdabot> Title: qlc
13:56:35 <leimy> I've got Joe's bok.
13:56:38 <leimy> er book
13:56:53 <leimy> Querys look just like list comprehensions
13:56:58 <leimy> and the DB can store any Erlang term.
13:57:03 <leimy> is my understanding
13:57:22 <earthy> otoh, sql is much much better than many languages. :)
13:57:36 <leimy> there's a lot of crappy languages out there to compare to :-)
13:57:42 <earthy> :)
13:58:10 <vpalle> hi, does anyone here know of an EOPL like book, with haskell as the implementation language instead of scheme.. ?
13:58:41 <earthy> vpalle: why?
13:58:58 <conal> wow - http://www.computerhistory.org/babbage/
13:58:59 <lambdabot> Title: The Babbage Engine | Computer History Museum
14:00:07 <vpalle> because I'm not to crazy about scheme, feels like I'm looking directly at an ast when reading it..
14:01:38 <earthy> that is because you basically are
14:01:46 <vpalle> yep
14:01:55 <earthy> this is not a bad thing if you want to learn about the essentials of programming languages.
14:02:03 <vixey> vpalle: It's not EOPL but TAPL is a really great book
14:02:18 <vixey> vpalle: the essentials of programming aren't that essential though
14:02:22 <dolio> Actually, Wadler argued that it is quite some time ago.
14:02:37 <dolio> At least, that's part of the badness.
14:02:51 <earthy> dolio?
14:03:05 <leimy> yeah there's a good paper about how computing is better than scheming :-)
14:03:08 <leimy> worth a read
14:03:16 <dolio> @go calculating-is-better-than-scheming
14:03:19 <lambdabot> http://www.citeulike.org/user/jkominek/article/72198
14:03:19 <lambdabot> Title: CiteULike: A critique of Abelson and Sussman or why calculating is better than s ...
14:03:27 <earthy> oh, right
14:03:29 <vpalle> vixey, thx, actually I already own a copy of TAPL :) guess I'm just being spoiled.. I'm just looking around for programming language theory books, there aren't that many around
14:03:31 <earthy> 1987. :)
14:03:34 <leimy> was on lambda-the-ultimate :-)
14:03:39 <vixey> vpalle: oh and Algebra of Programming too
14:03:52 <vixey> vpalle: PLT is kind of a big field.. :)
14:04:00 <vixey> vpalle: aren't you interested in specific areas?
14:04:33 <leimy> The relational calculus and relational algebra I was speaking of is in C. J. Date's books on DBs
14:04:35 <dolio> Good luck finding The Algebra of Programming.
14:05:31 <younder> From each according to his abilities, to each according to his needs. Comments?
14:05:32 <vpalle> vixey, sure, I'm just looking for good books on writing interpreters
14:05:57 <leimy> younder: my abilities don't include commenting.
14:06:08 <dolio> Sounds like communism.
14:06:23 <leimy> smells like coffee though
14:06:27 * leimy goes and gets some
14:07:11 <younder> Indeed 'carl amkz'
14:07:17 <younder> lol
14:07:55 <vixey> vpalle: SICP
14:08:55 <younder> Have any of you read 'Atlas Shrugged' by Ain Rand
14:09:23 <leimy> AYn?
14:09:28 <leimy> and no :-)
14:09:31 <lament> not planning to, but i've heard you absolutely must read it if you want to succeed in life
14:09:49 <leimy> I thought that was Dyanetics
14:10:02 <leimy> Er Dianetics
14:10:04 <therp> vpalle: try Lisp in Small Pieces if you are not afraid of brackets
14:10:11 <vpalle> vixey, thx again, seems like theres no way of avoiding scheme.. :)
14:10:19 <younder> I have it in my bookshelf
14:10:25 <vixey> vpalle: Scheme is wonderful, avoiding it would be a mistake
14:10:37 <younder> along so amny other things
14:10:37 * leimy thinks the lack of syntax in scheme/lisp is a feature.
14:10:59 <vixey> vpalle: Concepts Techniques and Models of Computer Programming does not use Scheme and has lots of details about implementating language feauters
14:11:00 <vpalle> vixey, you are probably right
14:11:09 <younder> leimy: It's it's greatest streangth
14:11:45 <lament> Any Lisp implementation contains an ad hoc informally-specified bug-ridden slow implementation of half of Common Lisp.
14:11:53 <earthy> lament: then how did Franklin succeed at life? he had no Ayn Rand to read...
14:11:55 <leimy> heh
14:12:03 <vpalle> vixey, that was a new one for me, I'll take a look at it
14:12:03 <lament> earthy: franklin did not succeed at life
14:12:10 <leimy> it's that simple
14:12:19 <leimy> no one succeeded at life before that book was written
14:12:25 <younder> I thought as much
14:12:28 <leimy> by the way, I no longer say succeed
14:12:30 <leimy> I only say fail
14:12:35 <jeffersonheard> lament: franklin had a lot of fun, helped start a country, and womanized in France throughout his best years
14:12:40 <younder> to much lickour for you
14:12:43 <leimy> I like to express things in the form of failure
14:12:45 <dolio> Any Lisp program contains an ML program in the comments.
14:12:45 <younder> lol
14:12:55 <lament> jeffersonheard: a typical Moocher.
14:12:58 <leimy> haskell has failed to make me less interested in haskell
14:13:14 <leimy> programs don't work, the fail to crash.
14:13:14 <younder> leimy: me too
14:13:20 <leimy> s/the/they
14:13:40 <ddarius> They don't usually fail to crash.
14:14:01 <leimy> true
14:14:07 <leimy> sometimes my computer fails to stay on
14:14:10 <shapr> @users
14:14:10 <lambdabot> Maximum users seen in #haskell: 544, currently: 526 (96.7%), active: 26 (4.9%)
14:14:21 <leimy> This channel is lurktastic!
14:14:24 <gal_bolle> does quickcheck have a bugtracker?
14:14:35 <shapr> gal_bolle: You can send patches. What's broken?
14:15:09 <gal_bolle> it seems quickcheck 2.1 is either getting into infinite loops generating data
14:15:18 <shapr> or?
14:15:21 <gal_bolle> or generating very big testcases
14:15:46 <gal_bolle> i'm not sure what happens, i wanted to browse for reports with similar problems
14:15:50 <shapr> qc 2+ generates larger test cases than 1.x, by default.
14:16:00 <gal_bolle> it's between 2.0 and 2.1
14:16:06 <gal_bolle> context follows
14:16:07 <shapr> oh
14:16:11 <shapr> You have a paste?
14:16:18 <gal_bolle> darcs has a qc 2.0 test suite
14:16:25 <gal_bolle> which runs all right
14:16:44 <gal_bolle> i ported it on qc 2.1 and i get random stuckages
14:17:04 <gal_bolle> darcs code is darcs get http://darcs.net
14:17:05 <lambdabot> Title: darcs
14:17:23 <gal_bolle> (this can be checked with qc 2.0 by using make unit_test)
14:17:51 <shapr> Who release 2.1? I forget..
14:17:55 <shapr> Koen and somebody else?
14:18:03 <gal_bolle> then you can apply the patch there: http://bugs.darcs.net/issue1119 to try with 2.1
14:18:04 <lambdabot> Title: Issue 1119: quickCheck test don't work with quickcheck 2.1.0.1 - Darcs bug track ...
14:18:15 <Heffalump> Andy Gill I imagine
14:18:15 <gal_bolle> i don't know
14:18:33 <gal_bolle> i'm not sure which is the «right» version of qc
14:18:35 <shapr> @seen andyjgill
14:18:36 <lambdabot> I saw andyjgill leaving #haskell and #ghc 4h 8m 35s ago, and .
14:18:41 <shapr> gal_bolle: You just missed him...
14:18:46 <gal_bolle> but 2.0 is hard to get the hand on
14:18:46 <Heffalump> we should definitely be on 2.1
14:19:44 <gal_bolle> is it possible to use trace to know at each instant whether qc is generating data or running tests?
14:20:02 <Heffalump> I'd suggest using the ghci debugger
14:20:38 <gal_bolle> is darcs friendly to ghci? I've never tried it
14:22:15 <C-Keen> I did try today and it worked somehow
14:24:46 * vixey hugs shapr :)
14:25:00 * shapr hugs vixey
14:25:01 <shapr> hiya!
14:26:33 <vixey> I want to find some new science fiction now...
14:26:42 * roconnor needs a hug
14:27:26 <shapr> vixey: ooh, I can point you to LOTS!
14:27:39 <shapr> vixey: Already read http://baencd.thefifthimperium.com/ ?
14:27:44 <lambdabot> Title: baencd at the Fifth Imperium
14:28:05 <skorpan> i loved "the nine billion names of god", but that's about the only sci-fi i didn't despise.
14:28:20 <shapr> I read too much sci-fi and fantasy.
14:29:09 <skorpan> for those of you interested, here it is: http://lucis.net/stuff/clarke/9billion_clarke.html
14:29:14 <lambdabot> Title: The Nine Billion Names of God
14:31:56 <younder> Try this one 'pandoras star' hamilton
14:32:18 <younder> and it's follow up 'judas unchained'
14:34:12 <pao> http://hpaste.org/11373
14:34:26 <pao> any quick workaround for utf8 and regexp?
14:35:34 <rwbarton> pao: well in this simple case, you could use isInfixOf
14:36:06 <pao> rwbarton: yep... it was just a simple example :-) I'd need a general solution...
14:36:32 <rwbarton> pao: Yeah, I figured, but thought I'd suggest it
14:36:51 <pao> rwbarton: thanks
14:39:16 <idnar> is there a function that turns [1, 2, 3] into 123?
14:39:49 <mauke> > foldr (\x z -> x + z * 10) 0 [1,2,3]
14:39:51 <lambdabot>   321
14:39:51 <ziman> > concatMap read [1, 2, 3]
14:39:52 <lambdabot>       No instance for (Num String)
14:39:52 <lambdabot>        arising from the literal `1' at <in...
14:40:03 <idnar> @pl (\x z -> x + z * 10)
14:40:03 <lambdabot> (. (10 *)) . (+)
14:40:07 <idnar> yuck
14:40:12 <ziman> > concatMap show [1, 2, 3]
14:40:13 <lambdabot>   "123"
14:40:15 <idnar> the lambda works fine, though
14:40:25 <Botje> > folrl (\a b -> a*10+b) 0 [1..3]
14:40:26 <lambdabot>   Not in scope: `folrl'
14:40:28 <Botje> > foldl (\a b -> a*10+b) 0 [1..3]
14:40:29 <lambdabot>   123
14:40:35 <mauke> > foldl' (\z x -> x + z * 10) 0 [1,2,3]
14:40:37 <lambdabot>   123
14:40:37 <idnar> ziman: I'm looking for 123 not "123" :P
14:40:44 <mauke> idnar: read
14:40:44 <ziman> i see ;)
14:41:08 <mauke> > read . map intToDigit $ [1,2,3]
14:41:09 <lambdabot>   * Exception: Prelude.read: no parse
14:41:22 <mauke> > read . map intToDigit $ [1,2,3] :: Integer
14:41:23 <lambdabot>   123
14:43:51 <vixey> skorpan: what does the ending mean?
14:44:15 <skorpan> vixey: that the world ends
14:44:20 <skorpan> the monks were right
14:49:21 <mm_freak> @src all
14:49:21 <lambdabot> all p =  and . map p
14:50:45 <vixey> yuuuuck
14:51:01 <vixey> do they call Monads "Computation Workflows" in F#
14:51:08 <vixey> that's really horrible
14:53:30 <ziman> what do they have against `warm fuzzy little things' :)
14:55:00 * Baughn wonders if, by analogy, we could rename functors to "fuzzy things"
14:55:54 <cjay> what would arrows be named then? :)
14:56:03 <Botje> stabby things?
14:56:10 <cjay> heh
14:56:19 <Botje> piercy things!
14:56:34 <shapr> shapr things!
14:56:40 <Botje> we have to be forward compatible with Spears, you know.
14:56:43 <mauke> @shapr shapr
14:56:44 * lambdabot loves shapr, so no slapping
14:56:45 <shapr> right on!
14:56:49 <shapr> @quote spears
14:56:50 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:56:50 <Botje> :)
14:56:52 <shapr> bah
14:57:33 <shapr> arrows can be generalized to spears.
14:57:53 <mauke> I WANT TO BACKSTAB HIM WITH A BALLISTA
14:57:57 <Botje> yeah, they're just really tiny
14:58:19 <lament> wow, f# monads are something
14:58:32 <C-Keen> mauke: that's a f'ing siege weapon
14:58:56 <vixey> @w80 BALLISTA
14:58:57 <lambdabot> *** "ballista" wn "WordNet (r) 2.0"
14:58:57 <lambdabot> ballista
14:58:57 <lambdabot>      n : medieval artillery used during sieges; a heavy war engine
14:58:57 <lambdabot>          for hurling large stones and other missiles [syn: {catapult},
14:58:57 <lambdabot>           {arbalest}, {arbalist}, {bricole}, {mangonel}, {onager},
14:58:59 <lambdabot>           {trebuchet}, {trebucket}]
14:59:01 <lambdabot>      [also: {ballistae} (pl)]
14:59:10 <vixey> @w80 onager
14:59:11 <lambdabot> *** "onager" wn "WordNet (r) 2.0"
14:59:11 <lambdabot> onager
14:59:11 <lambdabot>      n 1: medieval artillery used during sieges; a heavy war engine
14:59:11 <lambdabot>           for hurling large stones and other missiles [syn: {catapult},
14:59:11 <lambdabot>            {arbalest}, {arbalist}, {ballista}, {bricole}, {mangonel},
14:59:13 <lambdabot> [3 @more lines]
14:59:17 <vixey> oh.
14:59:33 <shapr> Arbalest is more common than arbalist.
14:59:43 <shapr> Trebuchets are fun to make in your back yeard.
14:59:45 <shapr> yard
14:59:48 <shapr> Man, I should be working
14:59:50 * shapr sighs and goes to work
15:02:18 <mokus> trebuchets are fun to make using knex
15:02:27 <mokus> it's really tough to make the axle strong enough
15:03:17 <C-Keen> just use  > Trebuchet a :)
15:03:34 <plutonas> please one that can go through me for one type at least? i know i have asked several times but lambdabot confuses me, i mostly want the way of thought
15:03:47 <plutonas> i have a simpler one map (const (++))
15:03:57 <plutonas> i know that (++) is of type [a]->[a]->[a]
15:04:08 <plutonas> and const is of type a -> b -> a
15:04:33 <plutonas> so i gather that (const (++)) is of type b->[a]->[a]->[a]
15:04:34 <mauke> btw, those are different a's
15:04:44 <shapr> plutonas: do you know the type of const?
15:04:49 <C-Keen> :t const
15:04:50 <lambdabot> forall a b. a -> b -> a
15:04:59 <mauke> plutonas: ok
15:05:03 <plutonas> shapr: C-Keen didn't i just write it down
15:05:04 <Saizan> plutonas: right so far
15:05:05 <ddarius> shapr: Aren't you supposed to be working?
15:05:13 <shapr> ddarius: dammit
15:05:15 * shapr runs away
15:05:17 <plutonas> don't confuse me with lambda bots types again please
15:05:23 <plutonas> so then i know that map has type
15:05:28 <mauke> write once, run away
15:05:53 <plutonas> (a -> b -> c) -> [a]-> [b]-> [c]
15:06:09 <mauke> no
15:06:13 <Baughn> :t map
15:06:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:06:16 <mauke> map :: (a -> b) -> [a] -> [b]
15:06:19 <Baughn> :t zipWith
15:06:20 <roconnor> @type zipWith
15:06:20 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:06:21 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:06:29 <C-Keen> heh
15:06:29 <plutonas> ooh sorry
15:06:30 <plutonas> oops
15:06:49 <Baughn> #haskell: Now in glorious techno-stereo
15:06:51 <roconnor> zipWith++
15:07:02 <plutonas> sorry, just a sec, i think i might understand it now
15:08:04 <mauke> :t flip (.) zip . (map . uncurry)
15:08:05 <lambdabot>     Couldn't match expected type `[b] -> [(a, b)]'
15:08:05 <lambdabot>            against inferred type `[(a1, b1)]'
15:08:05 <lambdabot>       Expected type: (a1 -> b1 -> c1) -> ([b] -> [(a, b)]) -> c
15:08:09 <mauke> nooo
15:08:55 <plutonas> ok i'm now getting (on paper) that (map (const (++))) has type b -> [a] -> [a] -> [a]
15:09:11 <plutonas> the only position i disagree with ghci, is that it has [a1] in position of my b
15:09:16 <plutonas> which means that b should be a list
15:09:17 <plutonas> why?
15:09:18 <mauke> what happened to map?
15:09:29 <mauke> b -> [a] -> [a] -> [a] looks like the type of const (++)
15:09:40 <plutonas> mauke: it's also
15:09:41 <plutonas> :)
15:09:45 <mauke> impossible
15:10:30 <plutonas> so does't b-> [a] -> [a] -> [a] translated into k -> l mean that k = b and l = ([a]->[a]->[a])
15:10:56 <Saizan> right
15:11:15 <chrisdone> beep
15:11:16 <sheijk> hm, how can I create a (Ptr Float) which represents an array? (I intend to pass it to Graphics.Rendering.OpenGL.GL.drawPixels so I suspect it should point to a native array?)
15:11:19 <Saizan> so you've map :: (k -> l) -> [k] -> [l]
15:11:38 <plutonas> yeap
15:11:51 <plutonas> but the (k->l) argument is already given to map
15:11:55 <Saizan> ok
15:11:57 <plutonas> ooooh
15:12:13 <Saizan> so substitute in the rest..
15:12:22 <plutonas> it's [b]->[[a]->[a]->[a]]
15:12:25 <chrisdone> map :: (k -> l) -> [] k -> [] l, fmap :: (k -> l) -> a k -> a l
15:12:27 <plutonas> which agrees with ghci
15:12:28 <chrisdone> om nom nom
15:12:31 <plutonas> alright thanks a lot
15:12:42 <vixey> (f -> f') -> (g f -> g f')
15:13:00 <Saizan> sheijk: see Foreign.Marshal.Array
15:14:18 <Baughn> > let f ((+2) -> x) = x in f 3
15:14:19 <lambdabot>   <no location info>: parse error on input `->'
15:14:54 <mauke> :t (. zip) . (.) . map . uncurry
15:14:55 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:15:38 <chrisdone> Baughn: hur?
15:16:25 <vixey> > let f (succ -> x) = x in f 3
15:16:26 <lambdabot>   <no location info>: parse error on input `->'
15:16:28 <chrisdone> is that special arrow notation?
15:16:40 <vixey> ♪ let f (succ -> x) = x in f 3
15:16:46 <Baughn> chrisdone: View patterns
15:16:47 <lunabot>  4
15:16:52 <vixey> ♪ let f ((+2) -> x) = x in f 3
15:16:53 <chrisdone> omfg
15:16:54 <lunabot>  5
15:17:05 <Baughn> chrisdone: GHCi doesn't seem to support them, so I thought I'd try here..
15:17:12 <vixey> ghci does support them
15:17:13 <Baughn> vixey: Also, what
15:17:15 <mauke> ♪ let f ((+2) -> x@5) = x in f 3
15:17:17 <vixey> ghci -XViewPatterns
15:17:17 <lunabot>  5
15:17:20 <mauke> ♪ let f ((+2) -> x@4) = x in f 3
15:17:21 <vixey> btw
15:17:22 <lunabot>  luna: <interactive>:1:54-72: Non-exhaustive patterns in function f
15:17:25 <Baughn> ..
15:17:29 <vixey> cat .ghcirc
15:17:29 <vixey> :set -XViewPatterns
15:17:29 <Baughn> Doh. I was missing the plural.
15:17:32 <Saizan> lambdabot is still on 6.8.*
15:17:43 <vixey> except that actually should be in .ghci
15:17:56 <Baughn> Right, but why is luna suddenly so musical?
15:18:09 <chrisdone> lambdabot has nomed all of the other namespaces
15:18:12 <mm_freak> \x -> f >>= f >>= f >>= f >>= f
15:18:18 <mm_freak> any way to express this more elegantly?
15:18:41 <mauke> const (f >>= ...
15:18:49 <chrisdone> const $ f >>= ..
15:18:52 <chrisdone> optimisation
15:18:53 <rwbarton> @type \f -> f >>= f >>= f >>= f >>= f
15:18:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
15:18:54 <lambdabot>     Probable cause: `f' is applied to too many arguments
15:18:54 <lambdabot>     In the second argument of `(>>=)', namely `f'
15:19:07 <chrisdone> @_@
15:19:10 <Saizan> mm_freak: i guess 'x' shouldn't be ignored there?
15:19:18 <vixey> :t iterate (?f >>=)
15:19:19 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
15:19:19 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
15:19:19 <lambdabot>     In the first argument of `iterate', namely `(?f >>=)'
15:19:26 <vixey> :t iterate (>>= ?f)
15:19:27 <lambdabot> forall (m :: * -> *) b. (Monad m, ?f::b -> m b) => m b -> [m b]
15:19:28 <mauke> :t (>=>)
15:19:30 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:19:34 <rwbarton> @type \x f -> x >>= f >>= f >>= f >>= f
15:19:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> (a -> m a) -> m a
15:19:40 <rwbarton> is that what you meant?
15:20:10 <Baughn> , (\((+2) -> x) -> x) 2
15:20:12 <lunabot>  4
15:20:13 <mm_freak> Saizan: oh yes, sorry
15:20:23 <mm_freak> \x -> f x >>= f >>= f >>= f >>= f
15:20:29 <mc__> > gcd 123^232 323^221
15:20:30 <lambdabot>       No instance for (Num (t -> t))
15:20:30 <lambdabot>        arising from a use of `^' at <int...
15:21:04 <mm_freak> > gcd (123^232) (323^221)
15:21:05 <lambdabot>   1
15:21:33 <Saizan> ?type \f -> foldr (>=>) return $ replicate 4 f
15:21:34 <lambdabot> forall (m :: * -> *) c. (Monad m) => (c -> m c) -> c -> m c
15:21:42 <Saizan> yay
15:22:02 <vixey> doTimes 4 (>=> ?f) :D
15:22:10 <rwbarton> There should be an (Arrow (~>)) => [a ~> a] -> (a ~> a)
15:22:23 <mm_freak> thanks
15:22:45 <vixey> :t msum
15:22:46 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:22:54 <vixey> :t asum
15:22:55 <lambdabot> Not in scope: `asum'
15:23:01 <Saizan> rwbarton: called sequenceArr ? :)
15:23:03 * vixey complaint
15:23:24 <rwbarton> Saizan: more like 'compose'
15:23:37 <Saizan> msum would generalize to something using ArrowPlus, not >>>
15:23:39 <rwbarton> Saizan: just foldr (.) id I suppose
15:23:54 <Peaker> Has anyone here used Reactive?  I'm trying to toy with it with simple examples.  How do I create an event source? "mkEvent" is gone...
15:24:06 <Saizan> ?type foldr (>>>) (arr id)
15:24:07 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => [a b b] -> a b b
15:24:19 <eu-prleu-peupeu> hi
15:24:25 <eu-prleu-peupeu> is there any english spelling software ?
15:25:14 <rwbarton> There should also be an Arrow version of Endo
15:27:01 <sheijk> can anyone help me find the problem with this code: http://pastie.caboo.se/paste/297570
15:27:13 <sheijk> or even better: how can I debug such type errors?
15:27:49 <mauke> sheijk: looks like you want 'let' there
15:28:00 <sheijk> in ocaml i would add type annotations until i hit the expression whose type isn't what i expect, but in haskell i'm a bit lost
15:28:19 <Saizan> sheijk: the error message is pretty accurate in this case
15:28:26 <mauke> well, PixelData RGBA Float pixels has the type PixelData a
15:28:33 <mauke> but this do block is in IO t
15:28:43 <mauke> so it can't appear on the RHS of <-
15:29:03 <sheijk> ah, i see. that makes sense
15:29:44 <mauke> 'let image = PixelData RGBA Float pixels', 'image <- return (PixelData RGBA Float pixels)'
15:31:32 <BMeph> rwbarton: (Category (~>)) => [a~>a] -> (a ~> a)? ;p
15:32:47 <Saizan> , src'' ''Category
15:32:48 <lunabot>  luna: Not in scope: `src'''
15:32:55 <Saizan> , src' ''Category
15:32:57 <lunabot>  luna: Not in scope: `src''
15:33:06 * Saizan fails
15:33:09 <BMeph> , src "Category
15:33:10 <lunabot>  luna: lexical error in string/character literal at end of input
15:33:23 <rwbarton> , src ''Category
15:33:25 <BMeph> , src "Category"
15:33:25 <lunabot>  luna: Not in scope: type constructor or class `Category'
15:33:27 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
15:33:35 <BMeph> , src "Control.Category
15:33:36 <lunabot>  luna: lexical error in string/character literal at end of input
15:33:39 <BMeph> , src "Control.Category"
15:33:41 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
15:33:53 <Saizan> BMeph: you're using double quotes instead of two '
15:33:55 <rwbarton> the syntax:
15:33:58 <rwbarton> , src ''Reader
15:34:09 <lunabot>  newtype Reader r a = Reader {runReader :: (r -> a)}
15:34:16 <BMeph> , src ''Category
15:34:18 <lunabot>  luna: Not in scope: type constructor or class `Category'
15:34:28 <BMeph> , src ''Control.Category
15:34:29 <lunabot>  luna: Not in scope: type constructor or class `Control.Category'
15:35:02 <BMeph> rwbarton: Eh, well thx for showing the proper form for it, anyway. :|
15:36:54 <Peaker> conal: Hey, are you there?
15:37:13 <conal> Peaker: yep.
15:37:27 <Peaker> conal: I want to toy with Reactive's darcs latest. I see you've removed mkEvent and pals
15:37:36 <Peaker> conal: How do I create event sources?
15:39:17 <conal> Peaker: in flux.  i'm working on it right now, tidying things up for simplicity.  expect to announce in a few days, with mailing list, trac, and wiki.  if you really want to try now, you might have some temporary luck with FRP.LegacyAdapters.
15:39:59 <conal> Peaker: what sort of app?  and what sort of external inputs & outputs?
15:40:15 <Peaker> conal: Well, at this stage, just toying around (first use of Reactive)
15:40:35 <Peaker> conal: I wanted to make an immitation of Phooey based on command-line dialogs, and perhaps later also SDL
15:40:44 <Peaker> (Mostly for educational purposes)
15:40:50 <conal> sounds fun
15:41:20 <conal> Peaker: SDL on which OS?
15:41:37 <Peaker> conal: Later I want to implement with Reactive a non-textual code editor, with revision control (I have implemented it in Python, OO style, and I think it would work quite well with FRP :)
15:41:42 <Peaker> conal: Ubuntu
15:43:15 <conal> Peaker: sounds fun.  i asked about SDL, because we flailed about quite a lot with which opengl toolkit to use.  sdl looked the nicest but was problematic on windows & macos.  so we're using glut for now.  (we == anygma folks.)
15:43:43 <vixey> why did anygma start up?
15:43:44 <Peaker> conal: I've used SDL on Windows before
15:43:55 <vixey> how
15:43:56 <Peaker> conal: Via pygame, though, and it worked ok
15:44:39 <vixey> Peaker: have you code online?
15:45:04 <Peaker> vixey: Not Haskell code. I have Python code for the revision controlled non-textual C code editor (prototype), though
15:45:17 <vixey> yeah is it online
15:45:59 <Peaker> with dyndns it is (my machine) :)  a bzr branch http://nextflow.dyndns.org/bzr/nf-experiment/main
15:46:11 <eu-prleu-peupeu> is there any haskell template meta programming ?
15:46:12 <vixey> cool
15:46:35 <Saizan> eu-prleu-peupeu: yeah, Template Haskell
15:46:35 <Pseudonym> eu-prleu-peupeu: YEs.
15:46:48 <Peaker> vixey: if you have Python/pygame, you can run livec.py
15:46:55 <Pseudonym> Also, a lot of things that you'd use templates for in C++ are done with type classes, fundeps and type families in Haskell.
15:47:03 <vixey> there's actually no .py in there
15:47:17 <Pseudonym> We talk about typeclass metaprogramming, too.
15:47:38 <Peaker> vixey: its a bzr repo (only .bzr), you can bzr get it
15:47:42 <Saizan> oh, i misunderstood the question
15:47:49 <Pseudonym> And, of course, simple cases of C++ templates are covered by parametric polymorphism possibly with simple typeclasses.
15:48:03 <vixey> ok
15:48:13 <Peaker> vixey: I can put a tarball of an older version that worked a little quicker too
15:49:56 <Peaker> vixey: http://nextflow.dyndns.org/main-2007-11-4.tgz
15:50:37 <Peaker> vixey: its just a prototype (that particular version includes about 3 weeks of work in it), that shows some very nice things a non-textual editor can do to editing code
15:52:47 * Peaker 's upload pipe is exhausted
15:57:25 <Peaker> conal: btw, this reminds me, our Python work also reversed the dependency relation in the GUI (i.e, we created a declarative GUI toolkit in Python)
15:57:49 <Peaker> I thought I was inventing the wheel, but apparently people have done it before ;)
15:58:03 <conal> Peaker: neat
15:59:26 <Peaker> The C model which was being edited, for example, had in a C function, a list of statements.  The GUI used something like :   Box(Map(to_widget, statement_list))  which then showed the statement list and correctly updated automatically when elements added/removed, or when a statement had in-place changes
16:02:19 <vixey> A lot of people in #haskell are actually interested in this text editor stuff
16:02:22 <glguy> Is there a {-# pragma I can put at the top of my .hs file to tell GHCi to link it with a shared library?
16:02:42 <vixey> I wonder if they all worked together would it get something really great written or just cause a lot of trouble? :p
16:03:58 <vixey> collaborative programming sometimes works brilliantly, sometimes .. doesn't
16:04:28 <Peaker> vixey: I'd love to work together with people about this. But I live thousands of miles away, and work very irregularly..  For ideas that are as preliminary as what I think I have, physical proximity is probably important
16:09:56 <eu-prleu-peupeu> is there any bug database for haskell ? (that runs on top of darcs?)
16:11:00 <eu-prleu-peupeu> something like trac but for haskell instead...
16:14:49 <eu-prleu-peupeu> im going to start a movement called: "say no to corporate software!"
16:15:31 <lament> NO!
16:16:24 <lucca> corporate software is a bad term
16:16:44 <SamB_XP> does that mean I can't use CUPS or ghostscript anymore?
16:17:04 <lucca> exactly; lots of great corporate software is free.
16:17:05 <Peaker> closed-source -> bitrot software ?
16:17:16 <lucca> in the rms sense
16:17:28 <SamB_XP> root mean sqaure?
16:17:33 <eu-prleu-peupeu> :D
16:18:00 <vixey> yes
16:18:04 <lucca> as you like
16:18:48 <SamB_XP> there's also a heck of a lot of non-corporate software available only as win32 binaries ...
16:20:54 <Peaker> Closed-source software is also to blame for slower CPU/processor advancements.  You can't just recompile Ubuntu for the new processor.  We don't even have a 64-bit Flash plugin yet
16:21:31 <SamB_XP> we don't ?
16:21:58 <lament> say maybe to corporate software!
16:22:00 <SamB_XP> and I was hoping for a process-isolation-friendly one ...
16:22:29 <vixey> rms matthew stallman
16:23:18 <Peaker> SamB_XP: At least I don't know of any, and am still using the nsplugin wrapper crap for Ubuntu
16:23:21 <eu-prleu-peupeu> hmm
16:23:37 <SamB_XP> nsplugin wrapper?
16:23:42 <eu-prleu-peupeu> and what about the haskell but trac software ?
16:23:52 <vixey> > 1+3
16:23:54 <lambdabot>   4
16:24:10 <Peaker> SamB_XP: 32-bit plugins' wrapper for 64 bit firefox
16:24:23 <Peaker> because closed-source is polluting my setup
16:25:24 <pcc1> anyone know anything about alex? I have something like this: "\123" { const TokenFoo } however alexScanTokens "\123" gives a lexical error. ideas?
16:31:59 <pcc1> pcc1: remove the quotes
16:32:24 <pcc1> pcc1: thanks
16:32:50 <EvilTerran> what?
16:32:57 <pcc1> I thanked myself
16:33:05 <EvilTerran> ok
16:33:07 <EvilTerran> ...
16:39:58 <sebaseba> #haskell: where people are so polite they even thank themselves
16:54:09 <Plouj> hi
16:54:33 <BMeph> 'lo
16:54:37 <Plouj> howcome the writeChar example: http://en.wikibooks.org/wiki/Haskell/YAHT/Io#The_IO_Library does not say something like 'hClose fp', but just 'hClose' as the 2nd arg to bracket?
16:55:22 <EvilTerran> ?hoogle bracket
16:55:23 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
16:55:23 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
16:55:23 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
16:55:50 <EvilTerran> er
16:56:21 <Plouj> yeah, the 1st one
16:56:22 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Abracket disagrees
16:56:27 <EvilTerran> on the type
16:56:28 <lambdabot> Title: Control.Exception, http://tinyurl.com/sqmlj
16:56:55 <EvilTerran> Plouj, ah, actually, have a look at that link - that might explain sufficiently for you
16:56:58 <BMeph> That's not the signature. Hold on...
16:57:10 <rwbarton> @type Control.Exception.bracket
16:57:11 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:57:15 <EvilTerran> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:57:17 * Plouj doesn't see the difference
16:57:19 <BMeph> bracket  ::  IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:57:30 <EvilTerran> stereo etc!
16:57:42 <BMeph> bracket takes three arguments. hClose is the second of those three.
16:57:47 <Plouj> I need stero glasses to see the difference?
16:57:49 <EvilTerran> Plouj, the parentheses are significant
16:58:00 <Plouj> EvilTerran: oh
16:58:08 <EvilTerran> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:58:08 <EvilTerran> not
16:58:10 <Plouj> EvilTerran: maybe lambdabot omits them :p
16:58:15 <EvilTerran> bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
16:58:17 <BMeph> hClose's entire type is a -> IO b
16:58:31 <EvilTerran> lambdabot appears to be slightly broken in a new way since i last looked
16:58:39 <Plouj> but isn't hClose supposed to be told what handle to close?
16:58:56 <BMeph> It just assigns/assumes/pretends that 'Handle' is 'a'. :)
16:59:03 <Plouj> do I take from this that bracket tells hClose what Handle to close?
16:59:22 <Plouj> BMeph: a is just a type in that type specification, AFAIK
16:59:35 <BMeph> Plouj: bracket will use hClose correctly, as long as the types fit together right. :)
16:59:50 <rwbarton> @src bracket
16:59:51 <lambdabot> bracket before after thing = block $ do
16:59:52 <lambdabot>     a <- before
16:59:54 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
16:59:56 <lambdabot>     after a
16:59:58 <lambdabot>     return r
17:00:08 <BMeph> Plouj: Handle is just a type in hClose's specification.
17:00:09 <Plouj> BMeph: in that case, why pass arguments to openFile in the same bracket call?
17:00:10 <Plouj> :p
17:00:21 <Plouj> bracket should guess what it is too!
17:00:39 <Plouj> (after all, Haskell has psychic powers)
17:00:54 <BMeph> Plouj: Here's a tough question: what's openFile's type? :)
17:01:11 <chessguy> @hoogle openfile
17:01:12 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
17:01:14 <Plouj> openFile     :: FilePath -> IOMode -> IO Handle
17:01:26 * chessguy giggles
17:01:34 * BMeph respects Haskell's psychic powers.
17:01:34 <Plouj> oh
17:01:35 <TomMD> :type "openFile"
17:01:51 <Plouj> so, the first argument of bracket isn't a "function"
17:01:56 * BMeph has also stopped locking his keys in the car, for some strange coincidental reason
17:01:58 * chessguy rolls his eyes at TomMD 
17:02:04 <Plouj> it's just an "IO a" "value"
17:02:23 <TomMD> chessguy: I beg forgiveness - stuck in an airport.
17:02:23 * edwardk waves hello.
17:02:24 <Plouj> I see
17:02:40 <Plouj> it's as if they are passing an hClose function pointer to bracket()
17:02:52 * chessguy visualizes TomMD  sitting inside his wireless port and giggles again
17:03:01 <chessguy> hiya edwardk
17:03:05 <Plouj> BMeph: right?
17:03:22 <BMeph> Plouj: Haskell's so powerful, that it pretends that function pointers are as good as functions. ;)
17:03:33 <Plouj> BMeph: yeah, but for the sake of understanding things
17:03:52 <Plouj> that's why I double quoted everything
17:04:09 <BMeph> Plouj: For the sake of understanding...sure, bracket's getting hClose's "function pointer". ;)
17:04:12 <Plouj> I think the earlier chapters of YAH are coming back to me
17:04:21 <Plouj> YAHT*
17:04:58 <edwardk> heya chessguy
17:05:37 <edwardk> chessguy: heh. found a use for a trick from a chess program the other day when handling wadler-like views. ;)
17:06:17 <BMeph> Plouj: So, do you get why bracket doesn't just get openFile straight up? :)
17:06:34 <edwardk> er i should say wadler style, i think a wadler like view would be kinda scary - very 'hair shirt'
17:06:43 <Plouj> BMeph: yeah, it uses the value returned by a "call" to openFile
17:06:58 <chessguy> edwardk:  hm?
17:07:28 <BMeph> Plouj: Ah, but /why/ does it use a call to openFile, but uses hClose's pointer directly? :)
17:08:28 <Plouj> BMeph: because that call contains the Handle which hClose (a -> IO b) can later operate on
17:08:34 <rwbarton> edwardk: Check this out:
17:08:35 <rwbarton> , let (a, b) = $(lift =<< oldtype =<< [t| Free Maybe Int |]) in ppDoc a $$ ppDoc b
17:08:39 <edwardk> wound up using the basic idea of the lockless hashing from http://www.cis.uab.edu/hyatt/hashing.html to implement a view cache. so if + is a constructor, then, i store a pair of slots on the constructor itself as an inline view cache, and store the forwarding pointer and the forwarding pointer hashed with the view
17:08:40 <lunabot>  X_0
17:08:40 <lunabot>  newtype X_0 = X_0 (Either Int (Maybe X_0))
17:08:40 <lambdabot> Title: hashing
17:09:04 * BMeph gives Plouj a "YAHT"-sized high-five
17:09:19 <Plouj> Am I right in guessing that there is no need for an arrow (->) between "IO" and "a" because IO is something called a monad?
17:09:23 <Plouj> BMeph: thanks :)
17:09:24 <edwardk> rwbarton hah
17:09:43 <edwardk> rwbarton++
17:09:43 <rwbarton> edwardk: oldtype -- it expands newtypes :)
17:10:16 <rwbarton> edwardk: It's sufficiently complicated that it's probably broken in some cases, though. :(
17:10:56 <edwardk> does it just do one layer of them? i.e. if i pass it a newtype Mu f = In (f (Mu f)) does it do the right thing?
17:11:14 <edwardk> oh of course it does you used free
17:11:38 <rwbarton> edwardk: it's basically a lambda calculus interpreter that tried to detect recursion
17:11:45 <roconnor> in Hackage package documenataions, the links to the base library are all broken. :(
17:12:10 <BMeph> Plouj: Short answer, yes; long answer, it's not just because it's a monad, it could've been a Sequence. ;)
17:12:40 <edwardk> chessguy: er rather forwarding pointer to the result of applying the view, and the forwarding pointer xored with the view. then you can check if the view you want xored with the (fwd ^ view) = the forwarding pointer as a conservative check and you just need write ordering not barrier synchronization for view safety
17:12:57 <edwardk> worst case you get a result mid-write and you just recompute it
17:13:14 <twanvl> BMeph: Sequence is also a monad :)
17:13:40 <BMeph> Plouj: There's no need for an arrow between 'IO' and 'a', because it's not a function, but a compound type. Just like 'Seq a' is. :)
17:13:57 <Plouj> sure
17:13:58 <EvilTerran> or Maybe a
17:14:00 <edwardk> rwbarton: makes sense. so it opens up as many newtypes as it can until it finds a potential cycle? what about non uniform recursion?
17:14:03 <Plouj> but for now, I'm satisfied
17:14:34 <BMeph> twanvl: ...and if I'd used Set, someone'd complain about doing IO with a Set. Ssh, I'm "Illustrating"... ;)
17:14:53 <rwbarton> edwardk: It can't detect non uniform recursion, it will just expand forever
17:15:05 <Plouj> oh, hey
17:15:23 <Plouj> that means I've already defined compounds types by doing some of the excercise questions
17:16:15 <edwardk> rwbarton thats kinda what i figured. could it cheat and check for recursion either nominally or structurally? i.e. only expand each newtype by name once?
17:17:32 <edwardk> or maybe once on each 'path' from the root that way if you have newtype Foo a = Foo (Bar (Baz a) (Baz (Int)) it could get both Baz'es
17:18:38 <rwbarton> edwardk: Yeah, that would be an easy change actually, but then you wouldn't eliminate all newtypes with parameters.
17:19:00 <edwardk> true enough but it'd terminate easier ;)
17:19:56 <rwbarton> Currently every time it expands a newtype it pushes it on a stack along with the current continuation
17:20:14 <rwbarton> then if it expands the same newtype again it returns a fresh variable to that continuation
17:24:08 <plutonas> who can explain me why do [1,2,3]; "lambda" gives the output it does?
17:25:13 <twanvl> > do {[1,2,3];"lambda"}
17:25:14 <lambdabot>   "lambdalambdalambda"
17:25:30 <roconnor> > [1,2,3] >> "lambda"
17:25:31 <lambdabot>   "lambdalambdalambda"
17:25:33 <rwbarton> maybe it helps a little first to rewrite it as  do x <- [1, 2, 3]; "lambda"
17:25:38 <roconnor> > [_,_,_] >> "lambda"
17:25:39 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
17:25:55 <roconnor> > (replicate 3 undefined) >> "lambda"
17:25:56 <lambdabot>   "lambdalambdalambda"
17:26:11 <roconnor> > (\x -> replicate 3 undefined) >>= "lambda"
17:26:12 <lambdabot>   Couldn't match expected type `[a] -> t -> b'
17:26:15 <plutonas> roconnor: why do you use >> in position of ; is this what do does? applies then between it's commands?
17:26:19 <twanvl> > concatMap (\_ -> "lambda") [1,2,3] -- it is desugared to this
17:26:20 <lambdabot>   "lambdalambdalambda"
17:26:23 <roconnor> > (replicate 3 undefined) >>= (\_ -> "lambda")
17:26:24 <lambdabot>   "lambdalambdalambda"
17:26:30 <rwbarton> @undo do [1,2,3]; "lambda"
17:26:30 <lambdabot> [1, 2, 3] >> "lambda"
17:26:34 <plutonas> guys all this lambdabot stuff doesn't help me at all
17:26:35 <roconnor> ... then what twavl said
17:26:49 <roconnor> plutonas: oh sorry.  Are you aware of the list monad?
17:27:13 <plutonas> hm, just read a couple of tutorials on monads, but don't know the list one
17:27:33 <roconnor> plutonas: your comands are being evaluated in the list monad.
17:27:53 <plutonas> because the first "argument" of do is a list?
17:27:58 <roconnor> check your faviourite monad tutorials about the list monad
17:28:11 <roconnor> plutonas: because all your arguments are lists.
17:28:19 <dolio> There are so many, how could I possibly choose a favorite?
17:28:20 <plutonas> ok
17:28:21 <Pseudonym> plutonas, you know about list comprehensions, right?
17:28:25 <edwardk> I feel like a cop out. I'm running xmonad on a virtual machine which can take up one of my monitors, but running cygwin/x in multiwindow mode so i can run more traditional applications like 'ddd' that do jumpy things with focus.
17:28:28 <plutonas> Pseudonym: yes
17:28:33 <roconnor> > "lambda" == ['l','a','m','b','d','a']
17:28:35 <lambdabot>   True
17:28:36 <Pseudonym> COmprehensions are just another way of writing monads.
17:28:48 <Pseudonym> > do { x <- [1,2,3], return (x+1) }
17:28:49 <lambdabot>   <no location info>: parse error on input `,'
17:29:03 <Pseudonym> > do { x <- [1,2,3]; return (x+1) }
17:29:04 <lambdabot>   [2,3,4]
17:29:09 <roconnor> > ["lambda"| _<-[1,2,3]]
17:29:10 <lambdabot>   ["lambda","lambda","lambda"]
17:29:12 <Pseudonym> > [ x+1 | x <- [1,2,3] ]
17:29:13 <lambdabot>   [2,3,4]
17:29:18 <roconnor> hmm
17:29:19 <Pseudonym> Right.
17:29:51 <plutonas> i see
17:29:57 <roconnor> > [x | _<-[1,2,3], x <- "lambda"]
17:29:59 <lambdabot>   "lambdalambdalambda"
17:30:11 <plutonas> (kind of)
17:30:12 <roconnor> that is the equivalent in list comprehension form
17:30:42 <roconnor> but you should read about the list monad if you want to understand what is being produced.
17:30:54 <plutonas> ok, thanks...
17:31:13 <roconnor> > [x | [1,2,3], x <- "lambda"]
17:31:14 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
17:31:21 <roconnor> :)
17:31:26 <dolio> The list monad is kind of like nondeterministic computation.
17:31:52 <dolio> And at the end, it returns all possible computations.
17:32:43 <Peaker> > (+) <$> [1,2,3] <*> [10,20,30]
17:32:45 <lambdabot>   [11,21,31,12,22,32,13,23,33]
17:32:55 <dolio> So 'do x <- [1,2,3] ; "lambda"' is 'pick from 1,2,3, then pick from "lambda" and return the character.'
17:34:50 <dolio> Oh, and since you're not using x, that's of course equivalent to 'do [1,2,3] ; "lambda"'
17:39:35 <dolio> @seen vixey
17:39:35 <lambdabot> I saw vixey leaving #haskell, #rosettacode and ##logic 1h 1m 31s ago, and .
17:40:08 <dolio> @yow!
17:40:09 <lambdabot> Yow!  I just went below the poverty line!
17:40:36 <dolio> Heh, how apropos.
17:40:47 <lament> ouch?
17:44:50 * lispy wonders if there is a programming language named rosetta
17:45:27 <sjanssen> gotta be
17:45:34 <sjanssen> @google rosetta programming language
17:45:37 <lambdabot> http://citeseer.ist.psu.edu/213772.html
17:45:37 <lambdabot> Title: Knowledge Systems Group - CiteSeerX
17:45:37 <lispy> So, .hi files in GHC serve a similar purpose as .h files in C?  Just that they are autogenerated and managed by the compiler?
17:45:44 <timemage> lispy, likely.  there's probably one called babel or babelfish.
17:46:06 <lispy> I was just thinking if you have a PL named rosetta then you're always working on the rosetta code...
17:46:52 <sjanssen> lispy: yes, they're somewhat similar
17:47:08 <plutonas> i have a question here, saying: what has to be done in order to use values of type Maybe in arithmetic expressions. What would you answer to that?
17:47:34 <lispy> plutonas: you need instance Num a => Maybe a, presumably
17:47:39 <Peaker> plutonas: you could have Maybe be an instance of Num, but you wouldn't want to do that
17:47:55 <plutonas> lispy: what exactly does this mean?
17:48:05 <lispy> plutonas: is this a homework question?
17:48:29 <sjanssen> plutonas: write an instance of the Num class for the Maybe type
17:48:41 <thoughtpolice> lispy: .hi files contain a lot of assorted information
17:48:44 <sjanssen> for help on writing instances, see your favorite Haskell tutorial
17:48:46 <thoughtpolice> and they change very rapidly
17:48:49 <plutonas> lispy: no question in last exams
17:48:56 <plutonas> exam of 2003 actually
17:49:20 <plutonas> sjanssen: what exactly does instance mean in this context?
17:49:36 <thoughtpolice> for example they list dependencies, exported functions from a module, type and ABI information (with ghc 6.10 there is now also hashing of the ABI) and it also contains stuff like vectorisation information
17:49:50 <sjanssen> plutonas: it means the Haskell keyword "instance"
17:49:52 <lispy> thoughtpolice: indeed.  I was just thinking about how C and Haskell must have some similar problems.  It seems that in the Haskell case that the solution was to let the compiler do more work for you.
17:50:12 <lispy> plutonas: I suspect you need to read up a bit on type classes
17:50:27 <sjanssen> plutonas: I really do recommend you read about this from a tutorial, #haskell isn't going to do the subject justice
17:50:53 <lispy> plutonas: it's a rather good example actually, making Maybe into a number
17:51:06 <lispy> you'll learn a lot
17:51:27 <plutonas> i can do Maybe into a number
17:51:39 <plutonas> mkNum (Num x) = x
17:51:49 <plutonas> sorry (Just x)
17:52:07 <plutonas> and mkNum Nothing = 0 or something
17:52:25 <plutonas> what i don't understand is how to make it genarally
17:52:39 <sjanssen> that probably isn't the most useful definition
17:54:19 <pjdelport> plutonas: the answer to that probably involves using the Maybe Functor or Monad
17:54:57 <pjdelport> > liftA2 (+) (Just 2) (Just 2)
17:54:59 <lambdabot>   Just 4
17:55:03 <pjdelport> > liftA2 (+) (Just 2) (Nothing)
17:55:05 <lambdabot>   Nothing
17:55:39 <plutonas> :t liftA2
17:55:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
17:55:42 <lispy> :t (+)
17:55:43 <lambdabot> forall a. (Num a) => a -> a -> a
17:55:44 <pjdelport> > fmap (+2) (Just 2)
17:55:45 <lambdabot>   Just 4
17:55:49 <pjdelport> > fmap (+2) (Nothing)
17:55:50 <lambdabot>   Nothing
17:55:52 <lispy> plutonas: do you know what the type signature of (+) means?
17:55:59 <plutonas> again these lambdabot stuff...
17:56:01 <plutonas> lispy: yes sure
17:56:21 <plutonas> i don't get the forall a. part, but it doesn't matter, i understand the signature my ghci gives
17:56:26 <lispy> plutonas: how would you explain the Num part?
17:56:48 <plutonas> that a has to be of class Num
17:57:07 <plutonas> that is either Float, or Double, or Int or integer
17:57:13 <lispy> plutonas: suppose we replace a with Maybe a
17:57:18 <plutonas> ok
17:57:18 <pjdelport> ... an instance of class Num, to be exact
17:57:34 <lispy> plutonas: do you know how we would turn Maybe a, into a Num?
17:59:10 <plutonas> lispy: the way i described before?
17:59:36 <plutonas> using matcing on Just or Nothing?
17:59:45 <lispy> plutonas: I want to write, (Just 1) + (Just 2), and get Just 3
17:59:54 <lispy> plutonas: and I want to use (+) because that's for Nums
18:00:25 <pjdelport> (i'm not sure that's what plutonas's question was looking for...)
18:00:45 <plutonas> i think thats what i'm looking for
18:00:51 <plutonas> but lispy, i don't know how to do this
18:01:04 <lispy> plutonas: so what is Num?
18:01:30 <plutonas> a class
18:01:53 <lispy> okay, so we should be able to put things in this class, right?
18:01:55 <pjdelport> plutonas: this goes a bit beyond just doing arithmetic with Maybe
18:02:08 <lispy> pjdelport:
18:02:11 <lispy> oops
18:02:22 <lispy> pjdelport: I guess it comes down to how the Q is worded
18:02:32 <pjdelport> right
18:02:39 <lispy> pjdelport: it wants to know how to use values of type Maybe in arithmetic
18:02:50 <pjdelport> but probably using the functor/monad should be covered before discussing writing a new Num instance :)
18:02:53 <plutonas> pjdelport: it asks, how to use values of type Maybe in arithmetic expressions
18:03:09 <plutonas> lispy: yeap
18:03:21 <plutonas> we would like to unwrap the justs make the addition and put the Just back
18:03:29 <pjdelport> plutonas: well, lifting (i.e. working within the functor/monad) accomplishes that
18:04:35 <pjdelport> > let myfunc mx my = do { x <- mx; y <- my; return x + y } in myfunc (Just 2) (Just 3)
18:04:36 <lambdabot>       No instance for (Num (Maybe t))
18:04:36 <lambdabot>        arising from a use of `myfunc' a...
18:05:05 <pjdelport> d'oh
18:05:23 <sjanssen> pjdelport: parens around x + y
18:05:28 <pjdelport> oh, right
18:05:33 <pjdelport> > let myfunc mx my = do { x <- mx; y <- my; return (x + y) } in myfunc (Just 2) (Just 3)
18:05:34 <lambdabot>   Just 5
18:06:02 <pjdelport> > liftA2 (+) (Just 2) (Just 3)
18:06:04 <lambdabot>   Just 5
18:06:14 <pjdelport> plutonas: those are essentially identical
18:06:23 <pjdelport> different ways of spelling the same thing
18:06:40 <pjdelport> (you can also substitute liftA2 with liftM2)
18:06:51 <plutonas> pjdelport: how does mx beeing (Just 2) gets assigned to x as 2?
18:07:01 <plutonas> in x <- mx;
18:07:10 <pjdelport> plutonas: yes, that unwraps it
18:07:14 <pjdelport> so to speak
18:07:17 <pjdelport> it's do syntax
18:07:27 <plutonas> is it because Just is monadic, and we need to go to something non monadic?
18:07:59 <pjdelport> yes, that's using Maybe as a monad
18:08:33 <sjanssen> @undo do { x <- mx; y <- my; return (x + y) }
18:08:33 <lambdabot> mx >>= \ x -> my >>= \ y -> return (x + y)
18:08:46 <lispy> > do { x <- Just 1; y <- Just 3; return (x+y) } :: Maybe Expr
18:08:47 <lambdabot>   Just (1 + 3)
18:09:17 <pjdelport> :t fmap (+2)
18:09:18 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
18:09:37 <pjdelport> fmap is the simplest function for this kind of thing
18:10:04 <pjdelport> it applies a function "inside" a functor (such as Maybe)
18:10:23 <pjdelport> hence:
18:10:23 <pjdelport> > fmap (+2) (Just 3)
18:10:25 <lambdabot>   Just 5
18:10:44 <pjdelport> note the similarity to:
18:10:45 <pjdelport> > map (+2) [3]
18:10:46 <lambdabot>   [5]
18:10:52 <lispy> If Y is the combinator for general recursion, is there a combinator for general co-recursion and if so, what does it look like?
18:11:30 <dolio> I don't think there's a difference.
18:11:31 <lispy> > fmap (+2) Nothing
18:11:32 <lambdabot>   Nothing
18:11:35 <lispy> > map (+2) []
18:11:36 <lambdabot>   []
18:12:06 <lispy> dolio: I think that's because general recursion is also corecursive.  But, I thought I'd ask
18:12:10 <plutonas> ok, i think i see
18:12:12 <plutonas> thanks a lot
18:12:38 <pjdelport> plutonas: liftA2/liftM2 are just versions of fmap for functions of two parameters instead of one
18:13:07 <lispy> > liftM2 (+) 1 `ap` 2
18:13:09 <lambdabot>       Overlapping instances for Show ((a -> a1) -> a1)
18:13:09 <lambdabot>        arising from a ...
18:13:11 <pjdelport> in other words, you can think of fmap as liftA1 or liftM1
18:13:13 <lispy> doh!
18:13:27 <dibblego> or (<$>) or ...
18:13:29 <lispy> :index ap
18:13:37 <lispy> ?index ap
18:13:37 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
18:13:37 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
18:13:42 <pjdelport> yes, many names :)
18:14:02 <pjdelport> a bit unnecessarily confusing, but there you go
18:14:24 <dibblego> I just wish it were (.) and be done with it
18:14:25 <lispy> > liftM2 (+) `ap` 1 2
18:14:26 <lambdabot>       Overlapping instances for Show (m a1 -> m a1)
18:14:26 <lambdabot>        arising from a use...
18:14:56 <pjdelport> > (+2) . (Just 3)
18:14:57 <lambdabot>   Couldn't match expected type `a -> b'
18:15:01 <pjdelport> aww
18:15:28 <lispy> > liftM(+) (return 1) `ap` (return 2)
18:15:29 <lambdabot>       No instance for (Show (m a1))
18:15:29 <lambdabot>        arising from a use of `show' at <i...
18:15:36 <lispy> that works in ghci
18:15:58 <lispy> > liftM(+) (return 1) `ap` (return 2) :: Maybe Int
18:16:00 <lambdabot>   Just 3
18:16:11 <lispy> oh, because ghci probably allows IO Int
18:16:46 <sjanssen> yep
18:17:10 <lispy> ?pl \mx my -> liftm (+) mx `ap` my
18:17:10 <lambdabot> ap . liftm (+)
18:17:19 <lispy> ?pl \mx my -> liftM (+) mx `ap` my
18:17:19 <lambdabot> liftM2 (+)
18:17:34 <lispy> ?pl \mx my mz -> liftM (+) mx `ap` my `ap` mz
18:17:35 <lambdabot> (ap .) . liftM2 (+)
18:17:50 <lispy> Oh, right I need a 3 arg function
18:18:00 <Asztal> (,,)?
18:18:00 <lispy> ?pl \f mx my mz -> liftM f mx `ap` my `ap` mz
18:18:01 <lambdabot> ((ap .) .) . liftM2
18:18:52 <pjdelport> return f `ap` mx `ap` ...
18:19:43 <lispy> ?t \f mx my mz -> liftM f mx `ap` my `ap` mz
18:19:43 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:19:48 <lispy> :t \f mx my mz -> liftM f mx `ap` my `ap` mz
18:19:49 <lambdabot> forall a1 a a11 b (m :: * -> *). (Monad m) => (a1 -> a -> a11 -> b) -> m a1 -> m a -> m a11 -> m b
18:19:52 <lispy> :t liftM3
18:19:53 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
18:19:55 <lispy> some right?
18:20:03 <lispy> er same I mean
18:20:22 <sjanssen> lispy: you probably mean return f `ap` mx `ap` my `ap` mz
18:20:37 <sjanssen> though I suppose they're the same
18:20:51 <lispy> yeah, it seems that lambdabot needs a new rule :)
18:21:11 <lispy> ?pl \f mx my mz -> return f `ap` mx `ap` my `ap` mz
18:21:11 <lambdabot> ((ap .) .) . liftM2
18:21:24 <lispy> she doesn't recognize liftM3
18:41:11 <kupopo> I'm having some funny behavior with GHCi - I've installed a package that exports System.Process and promptly hidden it with ghc-pkg hide.  Nevertheless, ":m System.Process" in GHCi fails.  I then make a simple program that uses System.Process, compile it with "ghc --make", and the next time I load System.Process in GHCi, it ignores the hidden one and works fine.
18:48:21 <lispy> This is probably my favorite lambdacat: http://arcanux.org/lambdacats/dumb.jpg
18:48:58 <ddarius> That knowledge enlightens us all, lispy.
18:49:13 <lispy> ddarius: bask in it!
18:49:19 <rwbarton> kupopo: It sounds like what's wrong is that ghc --make compiles the program, right?
18:49:59 <lispy> kupopo: I think rwbarton is on to something.  After it in complied the next load into ghci will load from the compiled version
18:50:14 <lispy> "it in" -> "it is"
18:55:26 <kupopo> yes, it compiled, but I'm not loading the program into GHCi, I'm just running it bare
18:56:49 <rwbarton> oh, you have a separate package besides 'process' providing System.Process?
18:57:19 <kupopo> i.e. $ ghci => Prelude> :m System.Process => module main:System.Process is not loaded => $ ghc --make foo => $ ghci => Prelude> :m System.Process => Prelude System.Process> => ?
18:57:29 <kupopo> yes... process-backport :-)
18:58:12 <rwbarton> ugh
18:58:33 <kupopo> I figure as long as it stays hidden, it shouldn't break anything internally but then other software can depend on it without upgrading to 6.10
18:59:30 <kupopo> i.e. I want to write software that only works in the new API, but I don't want to require everyone to upgrade right now, since it'll take a while for 6.10 to work its way into the distros
19:15:03 <kupopo> so was that an "I can't believe this guy wants to do that" ugh?
19:15:28 <rwbarton> No, it was "that's a really weird behavior" ugh
19:15:44 <kupopo> ah, I see
19:15:49 <kupopo> that's okay then
19:16:55 <kupopo> I wish I knew what GHCi was doing so that it was less black magic-y.  I mean, I could just run ghc --make after hiding the package and hope that takes care of it
19:17:25 <kupopo> Or I could put it in System.Process.Backport...
19:49:21 <mm_freak> i'm trying to implement the State monad myself
19:49:25 <mm_freak>   State f >>= g = \s -> let (a, s') = f s in g a s'
19:49:30 <mm_freak> what's wrong here?
19:50:19 <dmwit_> Well, for one thing, there's a State constructor on only one side.
19:50:22 <dolio> Your return value isn't a State s a.
19:50:31 <kupopo> What is the type of State?  I think you probably need something like g (a,s')
19:50:43 <mm_freak> ah, indeed
19:50:52 <dmwit_> kupopo: I don't think so.
19:51:00 <dmwit_> kupopo: (I don't even think it depends on the type of State.)
19:51:13 <dmwit_> kupopo: Check the type of (>>=):
19:51:15 <dmwit_> :t (>>=)
19:51:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:51:18 <kupopo> dmwit: you're probably right
19:51:46 <dmwit_> kupopo: The second argument to (>>=) can't be restricted to only take tuples; you're not allowed to put any restrictions on it at all.
19:52:31 <lispy> ?hoogle mkDir
19:52:32 <lambdabot> System.Posix.Internals mkdir :: CString -> CInt -> IO CInt
19:52:39 <lispy> posix...
19:52:40 <lispy> hmm
19:53:02 <dmwit_> ?hoogle createDirectory
19:53:03 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
19:53:03 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
19:53:03 <lambdabot> Distribution.Simple.Utils createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
19:54:12 <lispy> how would I create that directory with perms 0750, would I have to do that as a separate step?
19:55:00 <kupopo> Does djinn get state binding right?
19:55:49 <mm_freak>   State f >>= g = State $ \s -> let (a, s') = f s in runState (g a) s'
19:55:56 <mm_freak> now it works
19:56:41 <kupopo> cool
19:57:23 <Roey> what does this mean
19:57:27 <Roey> State $ ... $ ... $
19:57:29 <Roey> ?
19:57:33 <Roey> what is the significance of the $ ?
19:57:39 <kupopo> :t ($)
19:57:40 <lambdabot> forall a b. (a -> b) -> a -> b
19:57:54 <mm_freak> f $ x $ y $ z = f (x (y z))
19:58:13 <kupopo> $ is the slowest-acting operator, so it eliminates a lot of parentheses for the last argument to a function
19:58:14 <mm_freak> and ($) is very low priority, so you save a lot of parenthesis
19:59:05 <mm_freak> kupopo: for the last argument of a function, it eliminates exactly one pair of parenthesis, unless you write something like f (((x))) =)
20:00:39 <kupopo> Haha, yes.  My plurals and adjectives apparently have the wrong fixity
20:01:22 <Roey> eh?
20:01:32 <Roey> forall a b. (a -> b) -> a -> b
20:01:34 <kupopo> In fact, I would probably do a lot better to have a "type"checker debugging the things that I type
20:01:37 <lispy> :t setPermissions -- how do you get 0755 out of this api?
20:01:38 <Roey> what does this /mean/ ?
20:01:38 <lambdabot> Not in scope: `setPermissions'
20:01:44 <lispy> ?hoogle setPermissions
20:01:45 <lambdabot> System.Directory setPermissions :: FilePath -> Permissions -> IO ()
20:02:00 <Roey> -> means 'returns' no?
20:02:08 <Roey> (btw I come from Python)
20:02:10 <kupopo> that's the type of ($).  It means that for any types a and b, ($) is a function of two arguments
20:02:55 <kupopo> Yes, -> sort of means returns.  More precisely, "a -> b" means "a function from a to b"
20:02:57 <Roey> how would you do it without $
20:03:04 <Roey> mapping from a to b, ok.
20:03:05 <dmwit_> f $ x = f x
20:03:15 <Roey> so that means...
20:03:19 <Roey> f(x) = f x
20:03:20 <dmwit_> $ is a sort of no-op.
20:03:20 <Roey> ?
20:03:30 <kupopo> but functions in haskell are curried, so f(x,y) is written as (f x) y
20:03:34 <kupopo> or just f x y
20:03:39 <koninkje> I seem to recall seeing a generalized syntax for numeric literals of any radix, but I can't seem to find it. Am I hallucinating?
20:03:40 <Roey> all functions are curried??
20:03:48 <dmwit_> Roey: Function calls are denoted as silently as possible in Haskell.  f(x) is not necessary, as plain old "f x" will do. =)
20:03:57 <Roey> ahhh
20:04:00 <kupopo> yes, always (I think)
20:04:01 <mm_freak> Roey: ($) applies its second (right) argument to its first (left) argument
20:04:06 <Roey> but why are functions always curried
20:04:16 <mm_freak> it's simply function application, nothing else
20:04:18 <Roey> mm_freak:  aah
20:04:20 <dmwit_> Roey: Do you know what "curried" means?
20:04:23 <Roey> yes
20:04:30 <kupopo> So if you want to write f(g(x)), you can write f (g x), but not f g x since that means f(g,x)
20:04:37 <dmwit_> Okay.  Why wouldn't you want currying, then? =)
20:04:41 <Roey> right
20:04:48 <mm_freak> koninkje: nope
20:04:48 <Roey> dmwit_:  I'm still stuck on why to use it in the first place.
20:04:55 <mm_freak> f g x means (f g) x
20:04:57 <Roey> I mean, I see it as shorthand
20:04:59 <koninkje> mm_freak: alas. thanks though
20:05:13 <kupopo> you don't have to.  You can always use parens if you want.
20:05:18 <dmwit_> Roey: It's a convenient way to construct functions to pass to higher-order functions.
20:05:31 <mm_freak> koninkje: sorry, was not meant for you, but for kupopo
20:05:33 <mm_freak> typo =)
20:05:34 <yaru1022> hi, is there a function like map but that preserves the original input? For example, if we are given, func (+3) [1,2,3,4] [(4,1),(5,2),(6,3),(7,4)]
20:05:37 <dmwit_> Since HOFs are pretty important in Haskell, it follows that currying is pretty important in Haskell. =)
20:05:54 <dmwit_> > map (id &&& (+3)) [1..4]
20:05:55 <lambdabot>   [(1,4),(2,5),(3,6),(4,7)]
20:06:02 <Roey> dmwit_:  I've seen the trivial examples, but I haven't seen something more complex where currying simplifies things considerably
20:06:09 <yaru1022> dmwit_, thanks
20:06:19 <kupopo> mm_freak: was trying to speak a python-haskell pidgin.  Maybe would be better to just speak haskell though
20:06:27 <kupopo> or to use ""
20:06:33 <Roey> &&&.  omg.
20:06:52 <dmwit_> What did I tell you about HOFs? ;-)
20:06:54 <LynxAba> hello everybody! here is my Q : here is a code http://pastebin.com/d7339d37f, as you can see is a instance of print for the data Terrain, so if i have the input [[NonTransitable,NonTransitable] , [NonTransitable,NonTransitable]] ghci would print [[*,*],[*,*]], but what i really want to do is to print "**\n**\n" for that input... i tried to do something like  "instance Show [[Terrain]] where ... " but didn't work... heeeelp
20:07:13 <mm_freak> kupopo: yes, since f (g,x) is something completely different in haskell
20:07:14 <sjanssen> Roey: sort . map f . filter p -- write that without currying
20:07:20 <kupopo> Roey: The Haskell culture is sort of the opposite of the Lisp culture - there, everything is parens, while many of us go out of our way to avoid them... it may not be well justified, but that's how it is
20:07:35 <Roey> somehow . I . don't . see . it. &&& it . looks $ frustrating
20:07:36 <Roey> (so far)
20:07:37 <Roey> ;)
20:07:46 <Roey> kupopo:  ah
20:07:46 <sjanssen> (\xs -> sort (map (f, filter (p, xs)))) -- rather annoying
20:07:56 <Roey> what does \ mean in this context
20:08:01 <sjanssen> lambda
20:08:04 <kupopo> lambda xs:...
20:08:04 <Roey> oh.
20:08:07 <Roey> ah
20:08:35 <Roey> pizza, finally something I can readily understand.
20:08:50 <pizza> ;-D
20:08:56 <Roey> :)
20:08:58 <roconnor> Data.Colour.Names> aqua == cyan
20:08:58 <roconnor> True
20:09:05 <dmwit_> LynxAba: It's common to have a pretty printer that is not called "show".
20:09:22 <Roey> So Haskell and LISP are both functional languages, or is LISP a different kind of functional language?
20:09:24 <dmwit_> LynxAba: I recommend it to you; common practice is to reserve Read and Show for Haskell-style printing.
20:09:30 <Roey> or that LISP is imperative
20:09:35 <dmwit_> ?quote dcnstrct
20:09:35 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
20:09:40 <Roey> Haskell, Caml and the like are functional,
20:09:42 <johnnowak> Roey: functions in lisp aren't referentially transparent
20:09:47 <Roey> ah
20:09:54 <Roey> how so referentially
20:09:56 <Roey> ?
20:10:01 <mm_freak> Roey: haskell is sort of derived from lisp
20:10:05 <Roey> ah
20:10:14 <sjanssen> mm_freak: very distantly
20:10:17 <Roey> since when was lisp about lazy evaluation though
20:10:20 <dmwit_> There's a lot of differences: laziness, purity, allowing syntax, Hindley-Milner types, ...
20:10:21 <sjanssen> Haskell is derived from the ML family
20:10:23 <mm_freak> but that doesn't mean the two languages are even remotely comparable =)
20:10:35 <johnnowak> "allowing syntax"
20:10:41 <dmwit_> ;-)
20:10:52 <Roey> what do hindley-milner types have that distinguishes them from other types
20:10:56 <mm_freak> allowing syntax?
20:11:02 <kupopo> Roey: Referential transparency means that if you call a function with the same input, you'll always get the same output - basically, it's the "pure" when we say that HAskell is a "pure" functional language
20:11:05 <LynxAba> dmwit_: so what can i do exactly?
20:11:12 <johnnowak> mm_freak: just go with it, it's easier
20:11:13 <Roey> kupopo:  ok
20:11:23 <lispy> why is setEnv in posix, but getEnv exists in non-posix?
20:11:26 <dmwit_> LynxAba: Just write yourself a function of type [[Foo]] -> String.
20:11:31 <Roey> kupopo:  so it means that the function doesn't rely on globals, then.
20:11:31 <mm_freak> > let (/&∑) = (+) in 3 /&∑ 4
20:11:32 <sjanssen> Roey: HM allows type inference -- the benefits of static typing without the hassle of explicitly annotating the types
20:11:32 <lambdabot>   7
20:12:02 <kupopo> Roey: In part - it also makes guarantees about not having side effects
20:12:05 <LynxAba> dmwit_: ok, let me try it, thanks
20:12:09 <Roey> kupopo:  oh, ok
20:12:10 <mm_freak> > let 1 + 1 = 3 in 1 + 1
20:12:12 <lispy> ?users
20:12:12 <lambdabot>   3
20:12:12 <lambdabot> Maximum users seen in #haskell: 544, currently: 482 (88.6%), active: 20 (4.1%)
20:12:14 <Asztal> > let 2 + 2 = 5 in 2 + 2 -- my favourite
20:12:15 <lambdabot>   5
20:12:19 <mm_freak> hehe
20:12:30 <dmwit_> mm_freak, johnnowak: Lisp has basically one piece of syntax: parentheses.  All the rest are identifiers.  Haskell has many more pieces of syntax: case, do, if, where, let, in, =, |, {}, .., and so on.
20:12:32 <lament> > let 2 + 2 = 5 in 2 + 2 + 2 + 2
20:12:33 <lambdabot>   * Exception: /tmp/4535981703054944645:69:64-72: Non-exhaustive patterns in ...
20:12:42 <Roey> dmwit_:  ok
20:12:42 <lament> > let 2 + 2 = 5 in (2 + 2) + (2 + 2)
20:12:43 <lambdabot>   * Exception: /tmp/5033669216692366810:69:64-72: Non-exhaustive patterns in ...
20:12:59 <Roey> Asztal:  can you really redefine mathematicaly assumptions like that in haskell??
20:13:00 <dmwit_> lambdabot: What's 5+5?
20:13:08 <dmwit_> lament: That was meant for you.
20:13:09 <Roey> astrobunny:  heh, nice nick
20:13:14 <johnnowak> dmwit_: those identifiers can become syntax.
20:13:16 <lament> dmwit_: yes.
20:13:17 <Roey> lament:  it's all your fault!
20:13:21 <Roey> lament:  btw happy holiday
20:13:26 <lament> thanks
20:13:28 <lament> what holiday is it?
20:13:32 <Roey> simchat torah
20:13:37 <lament> oh
20:13:37 <mm_freak> Roey: yes, you can
20:13:40 <lament> i didn't realize :)
20:13:44 <Roey> ah!
20:13:49 <Roey> simchas toyres time
20:13:51 * Roey dances.
20:14:19 <Roey> Obama:  Yes, you can! [learn haskell]
20:14:26 <johnnowak> dmwit_: you just have to wrap your where/if/let/match/etc in parentheses :)
20:14:28 <mm_freak> > let a + b = a Prelude.+ b Prelude.+ 1 in 2 + 2
20:14:29 <lambdabot>   5
20:14:33 <mm_freak> > let a + b = a Prelude.+ b Prelude.+ 1 in 2 + 2 + 2
20:14:34 <lambdabot>   8
20:15:08 <Roey> http://www.youtube.com/watch?v=65I0HNvTDH4
20:15:09 <lambdabot> Title: YouTube - Barack Roll
20:15:25 <mm_freak> haskell could even thread world state, if we made RealWorld explicit =)
20:15:38 <mm_freak> so you can turn your PC into a time machine
20:16:03 <sjanssen> data RealWorld = ????
20:16:15 <kupopo> Now if you use the ReverseState monad...
20:16:18 <mm_freak> !faq Can Haskell turn my computer into a time machine?
20:16:24 <mm_freak> @faq Can Haskell turn my computer into a time machine?
20:16:24 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:32 <sjanssen> where programming meets theoretical physics
20:16:33 <Roey> http://www.youtube.com/watch?v=_TiQCJXpbKg
20:16:34 <lambdabot> Title: YouTube - John McCain Gets BarackRoll'd
20:16:43 <mm_freak> sjanssen: main :: RealWorld -> RealWorld
20:17:56 <mm_freak> getTwoChars w = let (c1, w') = getChar w; (c2, _) = getChar w' in (c1, c2)
20:18:05 <mm_freak> read two characters, then go back in time =)
20:18:13 <mm_freak> like it never happened
20:18:29 <sjanssen> mm_freak: I wanna see a definition of RealWorld :)
20:19:01 <mm_freak> easy
20:19:03 <mm_freak> data RealWorld = RealWorld [Particle]
20:19:33 <mrd> so most of the universe doesn't exist, until you need it?
20:19:59 <kupopo> realWorld :: MTV -> ... -> Profit
20:20:08 <mm_freak> yeah, think of why quantum mechanics is the way it is
20:20:20 <mm_freak> maybe Haskell is the unified theory of everything
20:20:28 <mrd> QM is fine.  people are wacky.
20:20:31 <Asztal> data Multiverse = Tree (RealWorld [Particle])
20:20:39 <kupopo> We should make RealWorld strict, then
20:20:57 <mm_freak> kupopo: nope, that would drive god (or whatever) crazy
20:21:12 <mm_freak> i think he's busy enough with a lazy universe =)
20:23:46 <mrd> no wonder I feel like a thunk
20:25:59 <Samy> thunk life
20:27:40 <ddarius> mm_freak: Your computer is steadily progressing forward in time.
20:28:12 <lament> mine is stuck in the 80s :(
20:29:03 <mm_freak> @faq Can Haskell prevent my computer from steadily progressing forward in time?
20:29:03 <lambdabot> The answer is: Yes! Haskell can do that.
20:29:45 * ddarius writes a new module, Control.Time
20:30:10 <sclv> the universe isn't lazy, its in the list monad
20:31:10 <sclv> the all possible worlds quantum interpretation would be a comonad, I guess?
20:32:04 <mm_freak> proceed :: RealWorld -> TimeInterval -> [RealWorld]
20:32:23 <Pseudonym> sclv: http://sigfpe.blogspot.com/2007/02/monads-for-vector-spaces-probability.html
20:32:24 <lambdabot> Title: A Neighborhood of Infinity: Monads for vector spaces, probability and quantum me ..., http://tinyurl.com/68yrx3
20:33:58 <sclv> I guess I'd believe the universe was lazy if the hubble looked at that stuff way at the edge of the big bang diaspora and when we magnified the picture we saw "stack overflow"
20:34:10 <sclv> ?poll-show IsHaskellGreat?
20:34:10 <lambdabot> ["WTFWhyAreYouEvenAskingThis?","PrettyGreat","TheGreatest"]
20:34:31 <sclv> ?poll-result IsHaskellGreat?
20:34:31 <lambdabot> Poll results for IsHaskellGreat? (Open): WTFWhyAreYouEvenAskingThis?=0, PrettyGreat=0, TheGreatest=1
20:36:09 <vinicius_> ?pool-vote 3
20:36:10 <lambdabot> Unknown command, try @list
20:36:35 <sclv> ?vote IsHaskellGreat? TheGreatest
20:36:35 <lambdabot> voted on "TheGreatest"
20:36:40 <sclv> ^^ like so
20:36:58 <vinicius_> ?vote IsHaskellGreat? WTFWhyAreYouEvenAskingThis
20:36:58 <lambdabot> "WTFWhyAreYouEvenAskingThis" is not currently a candidate in this poll
20:37:26 <vinicius_> ?vote IsHaskellGreat? WTFWhyAreYouEvenAskingThis?
20:37:26 <lambdabot> voted on "WTFWhyAreYouEvenAskingThis?"
20:48:22 <kupopo> :t bracket
20:48:24 <lambdabot> Not in scope: `bracket'
20:48:33 <kupopo> :t System.IO.bracket
20:48:34 <lambdabot> Not in scope: `System.IO.bracket'
20:48:56 <kupopo> :hoogle bracket
20:49:25 <lispy> ?hoogle bracket
20:49:25 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
20:49:25 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
20:49:25 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
20:49:50 <kupopo> thanks
20:51:50 <lispy> kupopo: the reason :t works for type is that people who use ghci a lot started typing that on accident.  it was so common we made an exception for :t :)
20:52:07 <kupopo> Aha... :-)
20:52:25 <sjanssen> @remember sclv I guess I'd believe the universe was lazy if the hubble looked at that stuff way at the edge of the big bang diaspora and when we magnified the picture we saw "stack overflow"
20:52:25 <lambdabot> Nice!
20:54:19 <kupopo> Why did lambdabot just say "Nice!"?
20:54:33 <sjanssen> kupopo: in response to the @remember command
20:54:43 <sjanssen> it says a random response
20:57:39 <zeno> whats a good type for this?  "list" with quick random access, about 350 long, quick entire array copying? steam fusion?
20:57:56 <sjanssen> stream fusion doesn't really do random access
20:58:22 <sjanssen> zeno: perhaps a Data.Array, or Data.Sequence
20:58:33 <zeno> ah ok thanks
20:58:52 <zeno> sequence would be for non-random access though right?
20:59:27 <sclv> sequence is good at the front and back
20:59:42 <sjanssen> it is logarithmic for any other element
21:00:08 <sclv> in general I think log is the best you can get for a random access functional list?
21:00:46 <lispy> sequence is a deque?
21:00:49 <sjanssen> zeno: will you be modifying the list often?
21:01:01 <zeno> sjanssen: nope just making coppies
21:01:07 <sjanssen> lispy: it is a finger tree
21:01:08 <sclv> sequence is a specialization of a fingretree
21:01:27 <zeno> front and back will be used not any more often than rest
21:01:47 <sclv> if you want real random access you need an array
21:03:21 <roconnor> Hmm, maybe my Data.Colour should be Graphics.Colour.
21:04:01 <sjanssen> it should be Data.Color :P
21:04:24 <roconnor> sjanssen: nah
21:05:45 <roconnor> I give you Data.Colour.Names.gray.  That's good enough. :P
21:06:21 * sjanssen forks the library and posts color-0.0.0 to hackage :)
21:06:34 <roconnor> :)
21:06:47 <roconnor> that'd be awesome
21:06:57 <ddarius> %s/Colour/Color/g
21:07:05 <roconnor> You should fork my darcs repo and simply add a token replace patch
21:07:16 <sjanssen> it would probably be an easy fork, assuming 'darcs replace' is smart enough
21:07:56 <zeno> i guess a diffArray would be good
21:08:09 <sjanssen> zeno: will you be using it in a single-threaded manner?
21:08:10 <zeno> i get to use array interface with fast updating for free
21:09:10 <zeno> sjanssen: my program will have multiple threads but diffarray will jsut one once per thread that is ok right
21:11:35 <dmwit_> If an object is only accessed from one thread, how could it be a problem?
21:12:04 <dmwit_> Then again, I've gotten myself in trouble before with that kind of question, so maybe I'll just take that snarkiness back.
21:12:43 <sjanssen> I don't mean threads as in Control.Concurrent, I mean linearly
21:12:58 <sjanssen> it is rather expensive to update the same DiffArray twice
21:14:40 <zeno> sjanssen: ah ok, ill just use data.array then
21:15:29 <roconnor> zeno: um, make sure you understand what sjanssen means by updating the _same_ DiffArray twice.
21:15:48 <sjanssen> (a // foo) // bar -- okay
21:16:16 <sjanssen> let x = a // foo; y = a // bar in stuff using x and y -- not okay
21:16:21 <yaru1022> hi, can anyone tell me how I can change my program to use Monad? http://hpaste.org/11381
21:16:52 <zeno> sjanssen: ah ok i didnt get that, now i do
21:16:54 <yaru1022> it looks like I have to use Monad but it's slightly different from other cases... so I'm not sure how I should modify my code..
21:17:25 <dmwit_> My eyes!
21:17:34 <sjanssen> WALL OF CODE
21:18:13 <sjanssen> yaru1022: did you know that the record syntax you use for ArgList automatically makes functions to extract those values?
21:18:14 <zeno> how does it provide arrayIO with array interface? does it use unsafeperform io or some such
21:18:29 <sjanssen> yaru1022: so you can skip getOC and just use oc instead
21:18:40 <sjanssen> zeno: yeah, it does use unsafePerformIO
21:18:54 <sjanssen> but in a safe way
21:19:09 <dmwit_> I think you need to get rid of Value altogether.
21:19:31 <sjanssen> yeah, split it up
21:19:42 <dmwit_> data ArgList = ArgList { oc :: Maybe Bool, fraud :: Maybe Bool, trav :: Maybe Bool, fp :: Maybe Bool, ip :: Maybe Bool, crp :: Maybe Bool }
21:19:47 <sjanssen> or just use Bool :)
21:19:51 <dmwit_> right
21:20:04 <dmwit_> I'm not sure what all this Null business is about.
21:20:14 <Baughn> Or 'data ArgList = ArgList { oc, fraud, trave, fp, ip, crp :: Maybe Bool }|
21:20:31 <dmwit_> Oooor, keep Value (without Null), and set type ArgList = [Value].
21:20:34 <dmwit_> That's probably the best one.
21:20:41 <Baughn> It does seem like an awfully convoluted way to get trinary
21:20:55 <kaizoku> I'm having trouble with this excercise in a tutorial, how do you create a datatype with four elements where the first two and the last two are of the same type
21:21:11 <kaizoku> "Quadruple a a b b = Quadruple a a b b" gives me an error
21:21:16 <kaizoku> And I can't think of any other way to do it
21:21:31 <dmwit_> Quadruple a b = ...
21:21:43 <kaizoku> Ah, thanks
21:21:52 <dmwit_> kaizoku: The variables on the left just declare what are variables.
21:22:01 <dmwit_> It's kind of like a scoping declaration.
21:22:08 <yaru1022> sjanssen, oh, i didn't know about that. Thanks for pointing that out
21:22:11 <dmwit_> (But more like binders, if you're familiar with that term.)
21:22:55 <kaizoku> Ahh, okay
21:23:24 <yaru1022> hm.. yeah making it Maybe Bool sounds much better
21:23:31 <yaru1022> how about the type Factor?
21:23:39 <yaru1022> I defined it as type Factor = ArgList -> (Double, VarList)
21:23:51 <yaru1022> it looks somewhat similar to Monad... would there be a way tomake it a monad?
21:24:12 <dmwit_> What do you meant by that?
21:24:15 <Baughn> yaru1022: Would there be a point?
21:24:15 <kaizoku> YARRRR
21:24:33 <yaru1022> if you look at my functions such as multiply, sumout, normalize, etc.
21:24:44 <yaru1022> I use it like let (_, vars1) = factor1 argList
21:24:51 <yaru1022> in blah blah
21:25:01 <yaru1022> aren't they typical monad structure..?
21:25:09 <kaizoku> Oh, whoops
21:25:19 <byorgey> @arr
21:25:19 <lambdabot> I want me grog!
21:25:24 <kaizoku> hehe
21:25:42 <Baughn> yaru1022: No, that's not very essence of monad-y
21:25:42 <kaizoku> YARRRR
21:25:45 <kaizoku> Crap
21:25:59 <kaizoku> I should fix that pattern
21:26:07 <Baughn> yaru1022: What would bind be?
21:31:32 <dmwit_> roconnor: Rec601? Rec709?  ...in MY Haskell?
21:32:09 <Baughn> dmwit_: She's not yours. If you love her, set her free.
21:33:44 <dmwit_> ?ask roconnor to name the modules something more descriptive, like Data.Colour.TV and Data.Colour.HDTV or something, pretty please?
21:33:45 <lambdabot> Consider it noted.
21:33:54 <blargh> anyon using coq?
21:34:05 <blargh> i dont get i it
21:34:08 <dmwit_> I just got started, it's kind of neat.
21:34:11 <blargh> is it a programing langauge
21:34:19 <blargh> or is it a verification system?
21:34:28 <dmwit_> It's mostly a proof system.
21:34:32 <blargh> can i veriyf the pure parts of haskell in it?
21:34:40 <blargh> or ML
21:34:44 <dmwit_> It can emit code, but I feel like that was kind of thrown on at the end.
21:34:53 <blargh> emit?
21:34:53 <dmwit_> blargh: You can, with enough work. =)
21:35:11 <blargh> but what lang is i for then? ML?
21:35:15 <dmwit_> blargh: But usually, it goes the other way: you prove something about an algorithm, then have Coq write code that conforms to your proof.
21:35:25 <pumpkin_> what converts from a list to a string?
21:35:32 <dmwit_> blargh: It's for its own language.
21:35:39 <dmwit_> blargh: For writing machine-checkable proofs.
21:35:48 <dmwit_> pumpkin_: Lots of things; show is a great example.
21:35:50 <dolio> A string is a list.
21:35:54 <pumpkin_> I mean
21:35:56 <rwbarton> @hoogle [a] -> String
21:35:57 <lambdabot> Prelude cycle :: [a] -> [a]
21:35:57 <lambdabot> Prelude init :: [a] -> [a]
21:35:57 <lambdabot> Prelude reverse :: [a] -> [a]
21:36:02 <dmwit_> hoogle--
21:36:06 <pumpkin_> from [1, 2, 3] to "[1, ,2, 3]"
21:36:12 <dmwit_> That would be show.
21:36:13 <rwbarton> enh, it wasn't a very specific question.
21:36:14 <pumpkin_> cool
21:36:17 <pumpkin_> thanks :)
21:36:33 <blargh> dmwit: ah i see
21:36:50 <blargh> is the coide fast?
21:37:20 <dmwit_> What code?
21:37:24 <rwbarton> yaru1022: your hpaste got cut off
21:38:19 <rwbarton> yaru1022: making it hard to tell what you're trying to do
21:38:26 <blargh> does it use genetic programming or something?
21:38:46 <blargh> the code genrted by coq
21:39:06 <dmwit_> WTF
21:39:12 <blargh> !
21:39:37 <blargh> post again yaru
21:39:37 <kaizoku> YARRRR
21:40:14 <rwbarton> Data.Colour.Rec601 toY'CbCr -- looks like Klingon
21:43:39 <Baughn> rwbarton: Clingon? My first thought was actuallly some sort of blasphemous, lovecraftian elder language
21:43:39 <HerrSchnapps> hi, newbie here...
21:43:55 <HerrSchnapps> I've just been learning Haskell, but I need some help
21:44:34 <yaru1022> rwbarton: oops, sorry about that. here's the rest http://hpaste.org/11382
21:44:53 <dmwit_> HerrSchnapps: Awesome!  What's up?
21:45:19 <HerrSchnapps> um, well I have a list, which contains a couple of tuples and other lists
21:45:42 <dmwit_> No you don't!  That wouldn't be well-typed. ;-)
21:46:00 <HerrSchnapps> well, its whats been supplied...
21:46:15 <Baughn> A list can only contain /one/ type. Of course, that type can be arbitrarily complex..
21:46:51 <dmwit_> "supplied"?
21:47:04 <HerrSchnapps> but what about something like: [1,2,3,["cheese","apples"],"chicken"]
21:47:10 <dmwit_> Sorry, no.
21:47:12 <bd_> HerrSchnapps: Nope.
21:47:14 <Baughn> No can do
21:47:15 <bd_> You can have a tuple:
21:47:31 <bd_> (1,2,3,["Cheese","apples"],"chicken") :: (Int, Int, Int, [String], String)
21:47:35 <rwbarton> > [1,2,3,["cheese","apples"],"chicken"]
21:47:36 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:47:38 <bd_> but the length is fixed
21:47:43 <HerrSchnapps> oops, right sorry
21:47:49 <dmwit_> You could have [1,2,3,"chicken"], but only if you declared a Num instance for String. =P
21:48:04 <dmwit_> (Ignore me.)
21:48:23 <Baughn> Or you could define a wrapping data structure, and have [Num 1, Num 2, Num 3, Fruit ["cheese, "apples"], Poultry "chicken"]
21:48:28 * rwbarton carefully checked that this example wouldn't produce a "Missing instance" error
21:48:40 <johnnowak> HerrSchnapps: the way you do that is to declare a new data type that can be either type A or type B
21:48:40 * dmwit_ too
21:49:08 <johnnowak> data Foo = FooInt | FooString
21:49:08 <johnnowak> [FooInt 5, FooString "hello"]
21:49:08 <Baughn> data Produce = Num Integer | Fruit [String] | Poultry String
21:49:09 <dmwit_> I call silence, until HerrSchnapps gets to his real question! ;-)
21:49:14 <rwbarton> HerrSchnapps: Anyways, so you have a tuple?  Or...?
21:49:28 <johnnowak> er.. data Foo = FooInt Integer | FooString String
21:49:45 <HerrSchnapps> okay, well I have a supplied list similar to this: [("comp200",["brian
21:49:49 <HerrSchnapps> oops...
21:49:56 <Baughn> HerrSchnapps: Who's supplying?
21:50:24 <Baughn> HerrSchnapps: Oh, and that should be fine. Notice how the list is just containing one type; that type happens to be (String,[String]).
21:50:34 <HerrSchnapps> [("comp200",["brian"],[("bob",'A'),("charles",'C')], 6]
21:51:03 <Baughn> @type [("comp200",["brian"],[("bob",'A'),("charles",'C')], 6]
21:51:04 <lambdabot> parse error on input `]'
21:51:05 <HerrSchnapps> sorry, I hit enter while still typing
21:51:30 <dmwit_> @type [("comp200",["brian"],[("bob",'A'),("charles",'C')], 6)]
21:51:31 <lambdabot> forall t. (Num t) => [([Char], [[Char]], [([Char], Char)], t)]
21:53:35 <HerrSchnapps> sorry, back
21:53:56 <HerrSchnapps> so, this is a homework like question, but I'm not trying to get an answer, just to understand what I'm doing
21:54:16 <HerrSchnapps> anyway, so this is a fictional course database
21:54:37 <HerrSchnapps> so there'll be several more "courses"
21:55:19 <HerrSchnapps> but I'm having trouble trying to extract out say [("bob",'A'),("charles",'C')]
21:55:38 <Baughn> Are bob and charles supposed to be course names?
21:55:46 <HerrSchnapps> no, student names
21:55:50 <dmwit_> HerrSchnapps: Do you know about pattern matching?
21:55:52 <HerrSchnapps> with their corresponding grades
21:56:14 <dmwit_> HerrSchnapps: You can pattern match on (almost) arbitrarily long tuples.
21:56:33 <Baughn> HerrSchnapps: Brian, then? Teacher?
21:56:37 <HerrSchnapps> yeah
21:56:53 <HerrSchnapps> and 6 the credit
21:57:01 <HerrSchnapps> but thats really redundent
21:57:16 <Baughn> Right. Now it's starting to look reasonable, though you might want to make a record of it later.
21:57:31 <HerrSchnapps> what I need to do is take each of the students marks, convert to an int value, then compute the average for each course
21:57:40 <Baughn> As dmwit_ points out, you should use pattern matching to extract the fields. Actually, that's what you /have/ to do
21:57:52 <Baughn> Then define some functions that do so based on said matching
21:58:22 <Baughn> > case (1,2,3,4) of (_,x,_,_) -> x
21:58:23 <lambdabot>   2
21:58:47 <Baughn> > let f (a,b,c,d) = b in f (1,2,3,4)
21:58:48 <lambdabot>   2
21:59:06 <HerrSchnapps> oh yeah, so I have done that: courseStudents :: Course -> [Student]
21:59:14 <HerrSchnapps> courseStudents (_, _, ss, _) = ss
21:59:43 <Samy> HerrSchnapps, are you having problems with the list?
21:59:46 <Baughn> Righto. And then you'll have to extract the grades, I suppose
21:59:47 <HerrSchnapps> but what I can't seem to do, is iterate through each of the courses, extract out the students into a list
21:59:50 <HerrSchnapps> yeah
21:59:53 <HerrSchnapps> which is done
21:59:57 <Samy> @type (:)
21:59:58 <lambdabot> forall a. a -> [a] -> [a]
22:00:06 <Samy> > 1 : 2 : 3 : []
22:00:07 <lambdabot>   [1,2,3]
22:00:08 <Baughn> HerrSchnapps: You know about the map function?
22:00:20 <Samy> > (1 : 2 : 3 : []) == [1, 2, 3]
22:00:22 <lambdabot>   True
22:00:38 <HerrSchnapps> so I can do things like [courseStudents a| a <- courseList]
22:00:59 <Baughn> You could. That's the same as "map courseStudents courseList", by the way
22:01:04 <HerrSchnapps> ah okay
22:01:28 <Samy> or don't bother actually learning what a list is
22:01:57 <Samy> HerrSchnapps, try writing the function first without using map or list comprehensions.
22:02:10 <Samy> If you would like a better understanding
22:02:16 <Baughn> Explicit recursion? I suppose that'd be a good learning exercise, yes.
22:02:32 <Samy> @src map
22:02:32 <lambdabot> map _ []     = []
22:02:32 <lambdabot> map f (x:xs) = f x : map f xs
22:02:47 <Samy> HerrSchnapps, that is the source for map, for example.
22:02:59 <HerrSchnapps> okay, I'll go brush up on map
22:03:14 <HerrSchnapps> heh, I just know I'm in a java/c mindset still...
22:03:23 <Baughn> HerrSchnapps: You /should/ be able to do this via explicit recursion
22:03:28 <Samy> So first try this without using map, HerrSchnapps.
22:03:30 <Baughn> HerrSchnapps: If you can't, go skim SICP until you can. ;)
22:03:41 <Samy> Baughn, SICP?
22:03:45 <Baughn> @where sicp
22:03:46 <lambdabot> http://mitpress.mit.edu/sicp/
22:03:57 <Samy> ohhh, yes
22:04:01 <Samy> That has been on my todo list
22:04:12 <dmwit_> HerrSchnapps: (:) and [] are constructors that you can pattern match on for lists, in case you didn't know.
22:04:37 <dmwit_> (Much like the (,,,,,,) constructor for 7-tuples.)
22:05:41 <Samy> > (,) 1 2
22:05:43 <lambdabot>   (1,2)
22:06:00 <HerrSchnapps> okay, I'll be back, thanks for pointing me off to somewhere new :)
22:06:28 <Samy> Enjoy :]
22:06:30 <dmwit_> HerrSchnapps: We're here 24/7. =)
22:08:55 <Baughn> HerrSchnapps: We probably won't speak before you ask actual questions, though. We're lazy like that.
22:09:15 <HerrSchnapps> heh, no problem!
22:09:37 <roconnor> dmwit_: sounds fair.
22:09:37 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
22:10:10 <dmwit_> roconnor: It does look like a really cool library, though.
22:10:16 <roconnor> Data.Colour.Rec601 -> Data.Colour.SDTV
22:10:26 <roconnor> Data.Colour.Rec709 -> Data.Colour.HDTV
22:10:35 <dmwit_> I hate always having to write a gradient function, and if yours takes into account things more than just linearly mixing RGB... =)
22:11:05 <roconnor> it does?
22:11:11 <Baughn> type Colour = [(Frequency,Intensity)]
22:11:43 <dmwit_> roconnor: I don't know.  You claim to.
22:11:58 <roconnor> I support other colour spaces
22:12:01 <Baughn> type Colour = [(Frequency,Intensity,Phase)] -- Whoops. I keep forgetting.
22:12:04 <roconnor> and compositing :)
22:12:18 <dmwit_> Compositing is what I mean by gradient.
22:12:31 <roconnor> dmwit_: blending is what you mean by gradient :)
22:12:37 <roconnor> which I also support
22:12:42 <dmwit_> ah, hm.  You might be right.
22:12:46 <roconnor> those are basically the only two opertations
22:12:52 <dmwit_> What's the difference between blending and compositing?
22:12:52 <roconnor> I couldn't think of any others
22:13:09 <roconnor> blending creates an affine combination of colours
22:13:23 <roconnor> compositing takes an AlphaColour and places it over top of an existing colour
22:13:39 <roconnor> they are similar
22:14:14 <dmwit_> I'm still not sure I see the difference.
22:14:36 <rwbarton> an AlphaColour is canonically a (colour, alpha) pair right?  There's no weird conversion between color spaces which mixes those two factors?
22:14:41 <dmwit_> How is compositing a colour with transparency alpha different from blending with mixing coefficient alpha?
22:14:46 <roconnor> rwbarton: right
22:15:10 <roconnor> dmwit_: it is a bit different when the lower colour is also an AlphaColour
22:15:37 <dmwit_> ah
22:15:43 <roconnor> but I suppose blending a pure colour is the same as turning it into an alpha color and comsiting
22:15:48 <dmwit_> I don't see why immediately, but I'm also very tired.
22:15:52 <roconnor> ... I should add that to quickcheck
22:16:16 <roconnor> well, you can blend two AlphaColours to get an average, that will be average opacity
22:16:50 <roconnor> but compositing two alphaColours will give the "product" of their transparencies
22:16:51 <dmwit_> ooooh
22:16:53 <yaru1022> hi, if I have a function of type "[Factor] -> [Function] -> [Factor]" and I'd like the function to apply the list of functions to each and every factors. How can I do that?
22:17:26 <dmwit_> yaru1022: Have a look at list comprehensions.
22:18:23 <dmwit_> :t flip ap :: [a] -> [a -> b] -> [b]
22:18:24 <lambdabot> forall a b. [a] -> [a -> b] -> [b]
22:18:28 <dmwit_> or that
22:18:49 <roconnor>   (c1 `withOpacity` o) `over` c2 == blend o c1 c2 -- passes 100 tests
22:18:55 <yaru1022> dmwit_: thanks :)
22:19:00 <zeno_> ok stupid question: why does array use array (1,3) [(1,11),(2,12),(3,13)] instead of array (1,3) [11,12,13]
22:19:27 <Baughn> zeno_: See listArray
22:19:50 <dmwit_> zeno_: It's likely for the more exotic Ix instances, where it's not as obvious right off what the right order should be.
22:19:58 <allbery_b> hm.  ghc 6.8.3 online manual says -fdisambiguate-record-fields exists.  my binary (from the OS installer) thinks otherwise
22:20:20 <dmwit_> zeno_: Also, as a human, you can jump to the middle and know "where" you are in the array.
22:20:27 <dmwit_> (For long arrays, this can be *very* helpful.)
22:20:33 <zeno_> doesnt it use double the storage though?
22:20:48 <dmwit_> zeno_: Well, it isn't stored like that, I don't think.
22:20:53 <dmwit_> zeno_: It's just printed that way.
22:21:06 <allbery_b> I even copy-pasted from the manual to make sure I didn't typo
22:21:28 <rwbarton> zeno_: I imagine it is stored as an array :)
22:21:36 <younder> the xs@ teqnique must be critial to effective array management yes?
22:22:00 <dmwit_> What?
22:22:11 <zeno_> dmwit_: ah ok thanks.  also i want to store a value with about 10 types in the array, should i just use int or make an array instance?
22:22:33 <dmwit_> A value with 10 types?
22:22:39 <dmwit_> That's a lot of types!
22:22:44 <dmwit_> You better just pick one. ;-)
22:22:51 <rwbarton> younder: no, you can't pattern match on an array
22:23:13 <younder> ok, my bad
22:23:23 <dmwit_> zeno_: ...I'm not sure I understand the question.
22:23:23 <zeno_> dmwit_: mean something like data foo = a | b | c | d
22:23:36 <pumpkin_> :t flip
22:23:37 <younder> I am still trying to grok Haskell
22:23:37 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:24:23 <rwbarton> zeno_: that looks more like a type with 10 values
22:24:33 <zeno_> what i meant sry
22:24:38 <rwbarton> zeno_: I think you can have the compiler derive an Ix instance for you
22:24:39 <dmwit_> zeno_: I still don't understand.  What do you mean by "array instance"?  And will this enumerated type with 10 values be the index of the array, or the contained type of the array?
22:24:50 <rwbarton> (guessing wildly what you mean here :)
22:24:55 <dmwit_> yeah
22:24:56 <zeno_> contained value
22:25:03 <rwbarton> Oops, I guessed wrong
22:25:09 <pumpkin_> how can I get a list of available predefined colors for X windows drawing ?
22:25:19 <dmwit_> I see no reason not to put that in an array, if an array is what you need.
22:25:38 <dmwit_> pumpkin_: Dunno; have you had a look through the Graphics.X11 documentation?
22:25:50 <pumpkin_> I was wondering if there was any funky runtime way to do it :P
22:25:55 <zeno_> so just :: Array Int Foo will work?
22:25:58 <pumpkin_> or rather, way to get a list from ghci
22:26:04 <roconnor>   blend o (c `withOpacity` a) transparent == c `withOpacity ` (o*a)  -- passes 100 tests
22:26:24 <HerrSchnapps> okay, I'm really just stuck
22:26:26 <roconnor> This is bringing back all my old memories of how Adobe Photoshop used to suck
22:26:39 <HerrSchnapps> what should I try doing?
22:26:39 <roconnor> And how blending with transparent would make colours turn blackish.
22:26:55 <sjanssen> pumpkin_: there isn't a programatic way
22:27:01 <pumpkin_> okay :)
22:27:06 <sjanssen> pumpkin_: but there is a list of colors in /etc/X11 somewhere
22:27:11 <pumpkin_> ah
22:27:13 <sjanssen> named colors, that is
22:27:16 <pumpkin_> I'll look around
22:27:31 <rwbarton> pumpkin_: I thought there was a program that prints that list, but I can't find it now.  It had something like rgb in its name
22:27:35 <dmwit_> HerrSchnapps: What's the goal?  Same as before?
22:27:52 * roconnor has a list of colours in Data.Colour.Names
22:28:12 <rwbarton> pumpkin_: showrgb
22:28:22 <pumpkin_> thanks
22:28:30 <sjanssen> /etc/X11/rgb.txt
22:28:53 <HerrSchnapps> "Write a function to compute a meanGrade across all  of a college’s courses. What should be returned is a  list of items, each of which represents a numeric average of the grades for all students in a course."
22:29:39 <roconnor> http://hackage.haskell.org/packages/archive/colour/0.0.0/doc/html/Data-Colour-Names.html
22:29:42 <lambdabot> Title: Data.Colour.Names, http://tinyurl.com/5ahaq9
22:30:01 <HerrSchnapps> okay, so would creating a list like so: [(A,C,B,D),(C,A,A,E,D,B),(B,B,A,C,B)] be the right way to go?
22:30:36 <dibblego> @djinn (a -> b) -> (b -> a -> c) -> a -> c
22:30:36 <lambdabot> f a b c = b (a c) c
22:38:29 <lispy> roconnor: you could have modules Data.Color that export all the same types/values :)
22:38:41 <lispy> roconnor: as in you could have both Colour and Color :)
22:38:49 <lispy> roconnor: just like you probably have both grey and gray
22:40:47 <byorgey> roconnor: nice!  I look forward to porting the Diagrams library to use your colour library.
22:40:58 <byorgey> just as soon as I find some more time to work on it, that is. =)
22:43:06 <byorgey> HerrSchnapps: as the input?  better do [[A,C,B,D],[C,A,A,E,D,B]... and so on
22:43:11 <byorgey> use lists of grades, not tuples
22:43:28 <byorgey> but sure, you could make a grade data type
22:47:30 <roconnor> lispy: that is true, and is tempting.
22:48:06 <roconnor> module Data.Color (module Data.Colour) where import Data.Colour.
22:48:11 <roconnor> I think that is all that is needed
22:48:14 <roconnor> and one for every file.
22:48:42 <roconnor> .. or I could make a second package that depends on it :D
22:48:49 <roconnor> and does that
22:49:39 <roconnor> me uses darcs replace for the first time
22:49:48 <roconnor> darcs replace Rec709 HDTV
22:50:22 <yaru1022> :t and
22:50:23 <lambdabot> [Bool] -> Bool
22:50:26 <yaru1022> :t xor
22:50:27 <lambdabot> forall a. (Bits a) => a -> a -> a
22:50:46 <roconnor> :t (&&)
22:50:47 <lambdabot> Bool -> Bool -> Bool
22:50:53 <yaru1022> :t (^)
22:50:55 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
22:50:59 <roconnor> :t (.&.)
22:51:01 <lambdabot>     Ambiguous occurrence `.&.'
22:51:01 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
22:51:01 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
22:51:01 <quicksilver> roconnor: module Data.Color where aqua = error "That's not how you spell Colour";
22:51:10 <roconnor> :D
22:51:29 <roconnor> :t (Data.Bits..&.)
22:51:30 <lambdabot> forall a. (Bits a) => a -> a -> a
22:53:21 <roconnor> wow, I think this darcs replace is all I needed to do.
22:53:28 <roconnor> and moving the files
22:57:30 <roconnor> byorgey: let me know what you think of the interface if you try to use it.  Best to fix it as early as possible.
22:58:24 <byorgey> roconnor: sure thing.
22:59:18 <roconnor> ... I wrote this lib without having used it for anything.
22:59:36 <byorgey> hehe
22:59:42 <byorgey> what inspired you to write it, then?
22:59:51 <roconnor> a combo of things.
23:00:01 <roconnor> I recently wanted a bunch of names of colours
23:00:17 <roconnor> It belongs in a colour package
23:00:38 <roconnor> so then I had to write a colour package.
23:00:47 <mm_freak> i need GHC extensions to make my State s monad a MonadState instance
23:00:56 <roconnor> I used to write software for a video software company
23:01:02 <mm_freak> is it impossible to create a State monad in haskell 98?
23:01:05 <roconnor> so I'm familiar with what needs to be written
23:01:12 <roconnor> ... and how bad software used to be.
23:01:50 * roconnor grumbles more about Adobe Photoshop in the past.
23:01:53 <byorgey> roconnor: well, sounds perfect.
23:02:33 <byorgey> as you may or may not know, the 0.1 release of the diagrams library also contains a module full of color names, stolen from... somewhere
23:02:47 <byorgey> but I would be very glad to get rid of it.
23:02:54 <roconnor> :D
23:03:15 <sclv> mmfreak: a state monad sure, but a state monad transformer needs mptcs
23:03:56 <byorgey> so instead of telling users 'here's a list of colors I threw together', I can say 'colors are provided by the colors library, which defines not only a bunch of colors, but nice combinators for doing things like transparency, blending, blah blah' =)
23:04:04 <mm_freak> sclv: the MonadState class is a MPTC
23:04:08 <roconnor> yep
23:04:20 <mm_freak> further if i wanted to write it myself, i'd need fundeps
23:04:26 <sclv> right -- but you can define a state monad as such without the monadstate class
23:04:40 <sclv> furthermore monadstate would work perfectly fine without fundeps
23:04:51 <sclv> they're sort of extraneous in this instance.
23:04:53 <mm_freak> well…  a state monad without 'get' and 'put'? =)
23:05:37 <sclv> if you wrote just a plain state monad then you wouldn't need mptcs. you only need that because you have the monadstate class to abstract over monad transformers.
23:06:13 <mm_freak> ah, i understand
23:06:47 <mm_freak> so if i wouldn't need MTs, i could just as well define get :: State s a, right?
23:07:11 <sclv> essentially
23:07:19 <zeno_> on errors like whatever.hs:109:33: what does the second number mean
23:07:28 <mauke> column
23:07:30 <mm_freak> zeno_: column
23:07:34 <zeno_> thanks
23:07:37 <mauke> starting from 0, apparently
23:07:51 <sclv> everything starts from zero.
23:08:04 <sclv> for some definitions of zero.
23:08:05 <mm_freak> line numbers start at 1, apparently
23:08:09 <mauke> not vim's quickfix mode
23:08:56 <mm_freak> > iterate (\x -> x*pi + 0.2) 1.1
23:08:57 <lambdabot>   [1.1,3.655751918948773,11.684883371916253,36.90914375926563,116.15349488439...
23:10:13 <mm_freak> however, what about StateT?  without MPTCs and fundeps, i'd need a separate getT :: Monad m => StateT s m a, am i on the right track?
23:10:16 <sclv> ?oeis 1 3 11 36
23:10:16 <lambdabot>  Sum binomial(n,k)3^(n-2k), k=0..floor(n/2).
23:10:16 <lambdabot>  [1,3,11,36,123,408,1370,4560,15235,50760,169326,564336,1881582,6271632,20907...
23:10:43 <sclv> I think you need mptcs?
23:11:20 <sclv> Oh... I see, encode the transformer in an ADT
23:11:21 <mm_freak> i mean, if i don't have them (i.e. h98), i cannot unify 'get' for both state monads, can i?
23:12:06 <mm_freak> i'd need get :: State s a and a separate getT :: Monad m => State s m a, right?
23:12:18 <sclv> mm_freak: I think so.
23:12:28 <mm_freak> ok, thanks
23:12:31 <sclv> but note that you can get rid of fundeps and everything still just works.
23:12:56 <sclv> the fundep on the class doesn't really seem to be accomplishing that much in this case.
23:13:47 <mm_freak> i didn't understand fundeps well anyway…  it was related to having functions, which don't use all type variables or something, IIRC
23:14:26 <sclv> on the other hand... if you go with an "only transformer" approach and don't have State at all, but only StateT and State is just StateT over Identity, then you could unify that way?
23:15:09 <mm_freak> yeah, seems more natural
23:15:21 <mm_freak> although in practice i think it will have a performance hit
23:15:46 <sclv> rewrite rules could take care of that + compiler cleverness in general.
23:16:04 <mm_freak> could =)
23:16:20 <sclv> especially since Identity is frequently done as a newtype, I think?
23:17:10 <mm_freak> essentially it doesn't need 'data', but nevertheless it's still sort of a container type
