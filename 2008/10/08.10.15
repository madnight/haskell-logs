00:00:19 <adu> dreixel: theres always (runProcess "uname -a")
00:00:43 <dreixel> opearting system indepedent, too
00:00:46 <dreixel> *operating
00:01:17 <dreixel> but that is an idea, thanks. Detecting the OS and running an OS-specific command like that
00:16:16 <anak> Is anyone using emacs with mmm-mode, latex and haskell-mode?
00:17:30 <anak> I have some font-lock problems with that combination. Which modes do you use for literate programming in emacs?
00:21:54 <rwbarton> @tell sjanssen Got it working! http://hpaste.org/11164#a1
00:21:54 <lambdabot> Consider it noted.
00:28:05 <mmorrow> rwbarton: wow
00:28:54 <mmorrow> rwbarton: hmm, is there any "catch" i'm missing, or should that be the new ^?
00:29:33 <rwbarton> mmorrow: then combine it somehow with http://hpaste.org/11162#a4 for the full effect
00:29:36 <kaizoku> I'm having issues trying to write an exercise from Yet Another Haskell Tutorial.
00:29:39 <kaizoku> I keep getting the error..
00:29:40 <kaizoku> Couldn't match expected type `IO' against inferred type `[]'
00:29:55 <kaizoku> For do getNum numList : number
00:30:07 <kaizoku> Expected type: IO t
00:30:13 <kaizoku>       Inferred type: [IO t]
00:30:32 <rwbarton> mmorrow: well, it certainly won't work if someone uses the I# constructor in their code with a non-constant argument
00:30:37 <kaizoku> I've tried 'do getNum numList ++ [number]'
00:30:43 <kaizoku> Is there something fundamental I'm missing here?
00:31:05 <kaizoku> Oh, number is
00:31:06 <kaizoku> let number = read num
00:31:12 <kaizoku> num <- getLine
00:31:27 <rwbarton> kaizoku: Probably :)  Can you paste your code? http://hpaste.org/new
00:31:50 <rwbarton> mmorrow: where by non-constant, I mean not a literal like 17#
00:32:02 <kaizoku> http://hpaste.org/11167
00:32:02 <mmorrow> rwbarton: hmm, what do you mean "non-constant"?
00:32:12 <mmorrow> ah
00:33:04 <kaizoku> rwbarton: It should read numbers and add them to a list until it reads '0' and then it should print out the sum, and product of all the numbers in the list, and then the factorial of each
00:33:22 <mmorrow> rwbarton: err, why?
00:33:44 <rwbarton> mmorrow: because the case won't get simplified and the rule will fire forever
00:34:17 <mmorrow> rwbarton: ohhhh. now i see what's really happening there ;)
00:34:36 <rwbarton> mmorrow: heh
00:34:56 <mmorrow> rwbarton: that's even cooler now
00:35:03 <rwbarton> mmorrow: yeah, there are effectively RULES for quotInt# and so on (and I guess case as well)
00:35:22 <rwbarton> mmorrow: right, so (^^^5) turns into (\x -> let y = x*x in x*y*y)
00:36:33 <rwbarton> kaizoku: Oh OK, so I think your problem on this line is that you meant   getLine (numList : number)   (with parentheses)
00:37:10 <mmorrow> rwbarton: hmm, with template-haskell you could check if the arg to (^^^) really is a literal, and if so do optimization, and if not just pass it through
00:37:16 <rwbarton> kaizoku: Well, except you can't use : to add an element to the end of a list, so you really want  numList ++ [number]
00:38:52 <mmorrow> ooh, you could even have a hidden function ^^^^ in a modula, and all the TH code would have to do is check if it's a literal, and if so return (^^^^lit) else (^^^nonlit), where (^^^^) is the one with RULES for it. so you wouldn't even have to rewrite the RULES hackery :)
00:39:00 <mmorrow> s/modula/module/
00:39:48 <rwbarton> mmorrow: somehow template haskell feels very heavyweight here, like, what would you actually write in your source?
00:41:00 <mmorrow> rwbarton: yeah it does seem like too much. on the other hand, if you can only call (^^^) with second arg a const, then you're really no better off flexibility-wise than if you used th.
00:41:16 <mmorrow> the th also would be able to allow non-constant args to ^^^ as well
00:42:01 <mmorrow> $(myPow 5) :: Int -> Int
00:42:33 <mmorrow> === (\x -> let y = x*x in x*y*y)
00:43:30 <mmorrow> hmm, actually doing it with TH wouldn't even let you use an arg not known at compile-time
00:43:37 <rwbarton> Well, with the rules approach I could have just defined x ^^^ y = x ^ y
00:43:42 <rwbarton> yeah, I was wondering that
00:43:57 <rwbarton> I didn't make that definition because I wanted to know for sure if the rules weren't working
00:44:47 <rwbarton> I think with normal use an I# constructor can only appear with an argument that's a known constant at compile time... but maybe I am very wrong.
00:45:11 <mmorrow> so then that case would make the RULES terminate for  (n -> 10^^^n) ?
00:45:19 <mmorrow> yeah, that's a good question
00:45:42 <rwbarton> the ^^^/pow rule would never fire
00:45:50 <rwbarton> because n isn't of the form (I# n#)
00:46:11 <mmorrow> but it is, just not yet... (?)
00:46:34 <rwbarton> But who knows, maybe + is defined as (I# x) + (I# y) = I# (x+#y) and the inliner/rules engine can see that I# constructor...
00:46:52 <mmorrow> ooh, that's the /exact/ def actually
00:47:38 <rwbarton> Yeah, in fact, that breaks it
00:47:44 <mmorrow> hmm
00:48:09 <rwbarton> Well, maybe with careful management of phases...
00:48:17 <mmorrow> heh, hackery+++
00:48:22 <rwbarton> pretty much
00:49:10 <mmorrow> RULES and hackery are a match made in heaven though ;)
00:51:08 <kaizoku> Ughh, this is not working for me :(
00:53:15 <dolio> @karma hackery+
00:53:15 <lambdabot> hackery+ has a karma of 1
00:54:04 <rwbarton> I think the phase hackery is beyond me at the moment
00:54:13 <kaizoku> Do any of you have a good suggestion for Haskell tutorials
00:54:25 <kaizoku> Either I'm not thinking about this the right way, or this tutorial sucks :p
00:54:30 <kaizoku> Both seem likely
00:54:33 <paczesiowa> rwh
00:54:36 <dolio> What are you using?
00:54:43 <kaizoku> Yet Another Haskell Tutorial
00:54:56 <kaizoku> I'm very accustomed to imperative programming though, so..
00:55:11 <dolio> It can be hard to make the switch.
00:55:58 <kaizoku> I was doing pretty well with all of the basic stuff, but then it got up to the actual doing stuff part
00:56:01 <dolio> Anyhow, as paczesiowa says, there's the Real World Haskell draft chapters up online.
00:56:01 <rwbarton> kaizoku: One suggestion: try out small pieces of your code in the interpreter before putting them in a big chunk of code
00:56:06 <rwbarton> kaizoku: for example,
00:56:13 <rwbarton> > foldr (+) [1,2,3]
00:56:14 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
00:56:14 <lambdabot>        arising from a use...
00:56:38 <rwbarton> So, that error message happens to be terrible :) but there's something wrong with that code fragment.
00:58:03 <rwbarton> If you try it in ghci, you'll get a less terrible error message.
00:58:22 <kaizoku> I'm trying it in ghci. :p
00:58:27 <dolio> It might actually not be that much better. :)
00:58:42 <dolio> "No instance for Show ([[t]] -> [t])"...
00:58:48 <rwbarton> I get No instance for (Num [t])...
00:58:52 <dolio> Or "No instance for Num [a]".
01:00:08 <Cthulhon> It seems clear if you think about it for a second.
01:01:33 <dolio> That's only until we lunatics get "instance (Applicative f, Num n) => Num (f n) where ..." into the standard libraries. :)
01:05:12 <mmorrow> rwbarton: ok, here's an attempt (only handles powers of two):
01:05:15 <mmorrow> , ppDoc `fmap` (\x -> let n = floor (log x / log 2) :: Int in replicateM n (newName "x") >>= \ns -> let mk [_] = [] ; mk (x0:x1:xs) = valD (varP x1) (normalB [|$(varE x0) * $(varE x0)|]) [] : mk (x1:xs) in lamE [varP . head $ ns] (letE (mk ns) (varE (last ns)))) 8
01:05:17 <lunabot>  \x_0 -> let x_1 = x_0 * x_0
01:05:17 <lunabot>              x_2 = x_1 * x_1
01:05:17 <lunabot>           in x_2
01:06:25 <rwbarton> 8 /= 4 :)
01:06:34 <mmorrow> hehe
01:06:43 <mmorrow> crap
01:07:01 <rwbarton> s/floor/round
01:07:16 <mmorrow> ahh
01:08:54 <rwbarton> You could even compute the actually-optimal way to do the multiplication, which isn't always the square-and-multiply way
01:09:21 <mmorrow> totally. you could do it perfectly optimally..
01:12:27 <rwbarton> Hmm, now I kind of understand why Lisp people like their macros
01:12:59 <dolio> So they can write hideous optimizations?
01:13:37 <mmorrow> one can only hope
01:14:16 <rwbarton> Well, it seems like most of the uses of Lisp macros are just getting around the lack of lazy evaluation
01:14:28 <rwbarton> and, I suppose, monads
01:14:38 <mmorrow> rwbarton: i want to use TH to make that pure-fft package into a sweet mini-fftw :)
01:16:02 <mmorrow> it seems like doing optimizations/computing and/or deriving optimal code/datastructures which'd be infeasible by hand is template-haskell's calling
01:16:27 <Adamant> the primary use of Lisp macros are to rewrite the language to do what you want.
01:16:38 <rwbarton> Maybe these "hideous optimizations" aren't such a great use for macros, but they're the best I've seen so far, in terms of what a Haskell user would want
01:17:21 <dolio> Well, a lisper will tell you that optimizations aren't the main use for macros.
01:17:26 <rwbarton> Adamant: Right, but in Haskell, because everything is a value, you don't need macros to do that.
01:17:30 <dolio> I think, at least.
01:17:34 <mmorrow> and optimizations aren't necessarily numeric..
01:17:58 <rwbarton> dolio: I think that's right.
01:17:58 <paczesiowa> rwbarton: everything is a value?
01:18:18 <adu> oops
01:18:23 <mmorrow> of course, TH can generate you 1000s of lines of derived instances of some class for a given datatype for you automatically as well
01:18:30 <rwbarton> paczesiowa: Yeah.  I think that's a good Haskell slogan, like "everything is a list" for Lisp
01:18:50 <mmorrow> th has probably done for me what would've been impossible without it
01:18:57 <paczesiowa> classes are not values
01:19:01 <rwbarton> paczesiowa: Basically referring to monads
01:19:14 <dolio> Everything is a rose tree.
01:19:16 <mmorrow> impossible as in would take me weeks of tedium
01:19:24 <adu> paczesiowa: well in that case everything is either a value, type or a class
01:19:35 <mmorrow> paczesiowa: they are at the meta level ;)
01:19:53 <paczesiowa> so we need smth more meta than that meta level
01:20:20 <mmorrow> , src 'ClassD
01:20:25 <lunabot>  data Dec = ... | ClassD Cxt Name ([Name]) ([FunDep]) ([Dec]) | ...
01:20:25 <lunabot>  infixl 9
01:20:53 <adu> like instance Ring (+) Int
01:20:54 <mmorrow> whoa. i never noticed TH has a rep for FunDeps.
01:21:11 <paczesiowa> even with TH I'd like to see smth of type (NotNum a) => a -> ()
01:22:17 <mmorrow> paczesiowa: well since Classes can't handle that (actually, i think oleg has a way (seriously)), then nothing can magically make them able to handle it
01:22:58 <dolio> I'm not sure he has class complements.
01:23:01 <mmorrow> all TH is is being able to code with code
01:23:15 <paczesiowa> mmorrow: link? I think I'd read all the relevant posts (not understanded though) and I didn't find anything that powerful
01:23:27 <dolio> He has (NotFun a) => ...
01:23:29 <paczesiowa> *understood
01:23:53 <mmorrow> dolio, paczesiowa: i've actually tried to find that link (i could have sworn i read that somewhere) on and off for the last few weeks
01:23:55 <mmorrow> no luck
01:24:28 <paczesiowa> NotFun is easy it can be solved by looking at the type structure ((->) or not), NotNum isn't that easy
01:24:54 <dolio> NotFun isn't as easy as it seems at first.
01:25:10 <rwbarton> This NotFoo stuff makes me very uneasy, it feels like it ought to be impossible.
01:25:40 <paczesiowa> rwbarton: why?
01:25:43 <mmorrow> either way, if it's possible to do with Haskell code, then TH can make 1000 instances of that for you in no time flat :)
01:25:57 <rwbarton> paczesiowa: For reasons I've failed to verbalize before :)
01:26:07 <paczesiowa> mmorrow: and I'll get gigabyte of binaries
01:26:35 <mmorrow> paczesiowa: well, you don't compile every instance of every class in every package into each one of your binaries, do you?
01:27:09 <mmorrow> :)
01:27:26 <paczesiowa> I sometimes think that there should be easier approach to types, I mean it shouldn't require Oleg to tell you how to write typelevel if-stmt
01:28:13 <dolio> There are langauges where it's easier.
01:28:14 <paczesiowa> I know that to write NotNum instance I have to look at all instances of Num in scope and check if a is there or not, why is it so hard to do in practice?
01:28:25 <paczesiowa> dolio: like what?
01:28:37 <dolio> Agda.
01:28:45 <dolio> Anything dependently typed, really.
01:29:04 <mmorrow> paczesiowa: i've recently stopped writing my own classes and've started to use records of functions and pass them around explicitly so i don't have to mess with instance selection debauchery
01:29:12 <Saizan> paczesiowa: that clashes with separate compilation
01:29:18 <paczesiowa> dolio: I had a brief look, but it seems it will take a few more looks until it stops being so scary
01:29:46 <paczesiowa> what is so great about separate compilation?
01:29:57 <dolio> paczesiowa: Eh. It's just like having Haskell as a type language, more or less.
01:30:14 <dolio> With a bunch of restrictions so that that's feasible.
01:31:03 <Saizan> and no typeclasses
01:32:10 <paczesiowa> maybe there is an approach so that there are two dynamically and weakly typed languages languages but the code is run with the second one only iff first one returns true (successfully typed )
01:32:14 <dolio> Yeah. Although Coq has them, so there's no reason it couldn't have them in principle.
01:33:39 <paczesiowa> we could then write type systems like we write regular code - we take a few libs and compose them. you just import HM and add typeclass Module and puff - haskell
01:34:36 <Saizan> then you've to debug your untyped type-level?
01:34:39 <ilyak> paczesiowa: You can move complexity from one place to another
01:34:47 <ilyak> This wouldn't really solve the problem
01:34:59 <ilyak> You can just add layers of indirection
01:36:11 <rwbarton> ilyak: Well if the type level is untyped, so it has "runtime" type errors, won't they be at compile time for the value-level code?
01:36:20 <Baughn> paczesiowa: I don't see why you can't have an infinite hierarchy of fully-typed languages. Haskell is good at infinities.
01:36:43 <ilyak> rwbarton: Probably
01:36:44 <rwbarton> ilyak: So the programmer will know about any type errors one way or another
01:36:49 <ilyak> Yeah
01:36:51 <mmorrow> if haskell's compile-time meta capabilities were expanded enough to be able to actually /control/ enough about what's being compiled, then you'd be pretty close to that. /and/ you'd get to use the same language for both.
01:36:58 <Baughn> @ask chrisdone What hapened to http://chrisdone.com/blog/db/static/lojbanweb.html ? I went to watch it, and it was gone.
01:36:58 <lambdabot> Consider it noted.
01:38:13 <mmorrow> and, if the TH code screws up and generates non-type-correct code, that's still caught at compile time by ghc's type checker.
01:39:15 <paczesiowa> isn't TH ugly? all those $[] or whatever escape mechanism it uses...
01:39:46 <mmorrow> paczesiowa: it's only ugly until you realize what it can do for you, then it's beautiful :)
01:40:00 <mmorrow> and that's just syntax anyways
01:40:36 <mmorrow> you can write a QuasiQuoter which tranforms some arbitrary syntax for some arbitrary (possibly haskell) language into haskell
01:40:48 <mmorrow> and make that inner syntax look however you like
01:40:58 <paczesiowa> and yet you still have to write those $[] :>
01:41:10 <mmorrow> heh, but only once on the outside
01:41:39 <mmorrow> [$myBetterSyntaxedHaskell| ... 4000 lines ... |] (EOF)
01:42:19 <paczesiowa> hmm, that is probably easier than writing custom ghc frontend like those liskell people did
01:42:55 <mmorrow> totally! it provides a standard interface to do exactly that. it's friggin great
01:44:13 <mmorrow> suppose you have a javascript QQ. that js parser then finds any js syntax error /at haskell compile-time/, which result in a /haskell/ compilation error, which prints out the line/col of the js error relative to the start of the [$js|..   :)
01:45:07 <mmorrow> and you could if you wanted use haskell's type system to type the js (with GADTs or something) if desired
01:46:17 <Saizan> js is more interesting as output than an input though
01:47:03 <Saizan> but for EDSLs it'll be great
01:47:05 <mmorrow> Saizan: exactly. you prettyprint it along with you Html in the CGI output, and it's verified to be syntax correct
01:47:34 <mmorrow> you can embed it in your haskell right next to your code which generates the Html form it controls
01:47:44 <quicksilver> I don't think QQ replaces the desirability of custom haskell frontends
01:47:50 <quicksilver> but it certainly makes experimentation easier.
01:47:56 <Saizan> ah, right, i was thinking about programming a whole module in js..
01:49:45 <mmorrow> quicksilver: yes, i don't think it replaces full frontends. what it does do is provide a way to embed other langs (js/sql/etc) in the haskell src and gives a way to do some checking of that embedded code.
01:50:53 <mmorrow> and i don't believe there was really any way to do that before (?)
01:51:01 <mmorrow> (other than a preprocessor i guess)
01:51:27 <Saizan> well, combinators and typeclasses, but you don't get native syntax
01:51:55 <mmorrow> yeah, i mean arbitrary syntax being mapped in arbotrary ways to haskell code
01:52:36 <mmorrow> (well, in most cases of languages, it'd probably be mapped to expressions representing their ASTs in haskell)
01:52:54 <mmorrow> which can them be evaluated or prettyprinted or something
01:53:14 <mmorrow> hmm, yeah that's a distinction i hadn't really explicitly thought about before..
01:54:45 <Saizan> which?
01:55:46 <mmorrow> the distinction between (1) quoting a lang which you dequote to its operational equivalent in haskell code, and (2) quoting a lang which you dequote to some haskell encoding of its AST
01:56:03 <quicksilver> it's a continuum to some extent.
01:56:07 <quicksilver> deep/shallow embedding
01:56:19 <mmorrow> hmm, this is interesting
01:56:32 <quicksilver> although I think (2) is what people normally associate with quasiquoting.
01:57:14 <mmorrow> yeah, i'd agree. the first QQ i did was actually a (1), but i didn't really appreciate that it was until now
01:57:20 <mmorrow> (a regex QQ)
01:58:11 <Saizan> well, regexes are barely an (1) since the operational part is to pass their representation to another parser..
01:58:20 <mmorrow> lunabot used to have it in scope until i moved machines..
01:58:23 <mmorrow> so,
01:58:57 <mmorrow> [$rx|.+(.[a-v])|] :: String -> Maybe [String]
01:59:44 <quicksilver> one of the poster-children of QQ is the ability to use it on the LHS of an expression.
01:59:49 <quicksilver> in which case it must be type (2)
01:59:51 <mmorrow> Saizan: yeah, very barely a (1)
02:00:15 <quicksilver> (and it must dequote to a valid pattern, i.e. nested constructors)
02:01:07 <mmorrow> quicksilver: indeed. although, if the pattern syntax which TH could represent was expanded in certain ways, you could be able to do some useful things in pattern context.
02:01:33 <mmorrow> in particular with pattern guards and/or view patterns
02:01:54 <Saizan> mmorrow: i'd like the result to be a tuple of the arity of the groups: [$rx|(foo)(bar)|] :: String -> Maybe (String,String,String) i.e. \0,\1,\2
02:01:57 <mmorrow> but that just gives you a way to sneak an expression in there
02:02:48 <mmorrow> Saizan: hmm. that could definitely be done. you'd have to mess with parsing the regex then, and not just pass it to the regex compiler though.
02:03:08 <mmorrow> (i just shuffle it along to the pcre-light compiler)
02:03:24 <Saizan> ah, i thought you checked wellformedness at least
02:03:56 <mmorrow> Saizan: the type is only checked once it's been spliced
02:04:16 <mmorrow> so you can do things like:
02:04:33 <rwbarton> I think you can have pcre handle that parsing for you, answering questions like how many groups are there
02:05:30 <quicksilver> can QQ run arbitrary normal code at compile time?
02:05:45 <quicksilver> ...you'd need that to get pcre to count the groups before the type checking phase.
02:05:47 <Saizan> TH in general can
02:06:02 <quicksilver> Saizan: not quite arbitrary? Only from a different module, or something.
02:06:09 <quicksilver> or a previous definition group in this module?
02:06:12 <quicksilver> I remember some requirement.
02:06:28 <mmorrow> , $(let tup n = tupE (fmap lift (replicate n 42)) in tup 3)
02:06:30 <Saizan> ah, yeah, there are problems like that
02:06:30 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
02:06:47 <mmorrow> grrr, but you see the point
02:06:51 <Saizan> but i guess pcre would live in a different module than where i use regexes
02:07:01 <quicksilver> yes.
02:07:12 <quicksilver> anyhow, my real question is does QQ expose this TH ability?
02:07:27 <mmorrow> Saizan: i want to be able to do that. i think i can use lunabot's eval function to add multi-staged abilities to TH
02:08:10 <Saizan> mmorrow: can you run arbitrary code in QQ? even IO?
02:08:20 <mmorrow> Saizan: oh yesh
02:08:26 <mmorrow> , runIO
02:08:27 <lunabot>  luna: Not in scope: `runIO'
02:08:33 <mmorrow> :: IO a -> Q a
02:08:45 <mmorrow> (not in scope for obvious reasons ;)
02:09:50 <mmorrow> Saizan: one thing though is that TH can't create entire modules, so suppose you write a module out from TH code. the problem is that GHC has already scanned for all the modules it plans on compiling
02:10:46 <mmorrow> so some hackery with the ghc-api would have to be done to be able to control GHC enough to get it to rescan/whatever for modules/ccode/* you might generate
02:11:28 <Saizan> can it generate import lists?
02:12:35 <mmorrow> unfortunately not
02:13:20 <mmorrow> but if you could write out entire modules/modify the current module via some hook hacked together with the ghc-api, you could be able to do that indirectly
02:13:59 <Saizan> there's always the option of prettyprinting the module..
02:14:05 <mmorrow> i think also it could be done so that the eventually produced binary wouldn't have to be linked to ghc, which adds 20MB+ in binary size
02:14:15 <mmorrow> Saizan: exactly
02:15:09 <mmorrow> <quicksilver> can QQ run arbitrary normal code at compile time?
02:15:27 <Saizan> i think you can solve this using ghc -c instead of --make, after you have designed the import system so that i works
02:15:31 <Saizan> *it
02:15:39 <mmorrow> yes, but you can't see other TH code in the same module but in a different splice
02:16:48 <mmorrow> Saizan: that's an idea. hmm, i guess you'd be essentially be making a --make'
02:17:52 <quicksilver> or you just reconcile yourself to two-stage compilation.
02:18:02 <quicksilver> possibly n-stage compilation.
02:19:19 <mmorrow> totally. and it'd be sweet if you could orchestrate all n stages from some TH splice
02:19:34 <Saizan> mmorrow: right, but with the ability to use your own strategy for compiling modules
02:19:47 <mmorrow> true
02:19:53 <mmorrow> hmm
02:21:25 <mmorrow> <quicksilver> anyhow, my real question is does QQ expose this TH ability?
02:22:02 <mmorrow> yeah, totally. since the type of your parsers are (String -> ExpQ) and (String -> PatQ), you get runIO and all that good stuff
02:22:14 <Cale> Saizan: btw, you mentioned wanting to see something about how that antichain computation proceeded. It turns out that the StateT [String] [] monad version was so much faster because it only needed to do 15 calls to closure, while the Writer one (which is doubly recursive) did on the order of a couple thousand calls to closure.
02:22:16 <mmorrow> (type ExpQ = Q Exp, PatQ = Q Pat)
02:22:32 <kaizoku> Uhh, how do I write numbers to stdout? XD
02:22:38 <Cale> kaizoku: print
02:22:44 <kaizoku> Oh, thanks
02:22:53 <Cale> kaizoku: or some combination of putStr/putStrLn and show
02:22:57 <kaizoku> Oh, oaky
02:23:06 <kaizoku> show is kind of the reverse to read?
02:23:10 <Cale> yeah
02:23:14 <Cale> > show 54
02:23:15 <lambdabot>   "54"
02:23:19 <Cale> > show [1,2,3]
02:23:20 <lambdabot>   "[1,2,3]"
02:23:25 <Cale> > show "hello"
02:23:26 <lambdabot>   "\"hello\""
02:23:29 <Cale> etc.
02:23:50 <kaizoku> Thanks
02:24:14 <quicksilver> Cale: why the big difference between StateT and Writer?
02:26:00 <Cale> quicksilver: The Writer version basically did a doubly recursive thing where it checked to see if the head of the remaining list of modules was okay to add to the current antichain (involving a costly call to closure), and if it was okay, recursing on the tail, with that element added
02:26:20 <Cale> It would 'tell' the resulting antichain when it ran out of modules
02:26:53 * quicksilver nods
02:26:54 <Cale> and regardless of whether the current module it was looking at was okay to add, it would call itself recursively a second time without it added
02:27:01 <quicksilver> so, totally different algorithm actually
02:27:04 <Cale> Yeah.
02:27:09 <quicksilver> rather than a State/Writer difference.
02:27:10 <quicksilver> (per se)
02:27:12 <Cale> But exactly the same result.
02:27:14 * quicksilver nods
02:28:58 <quicksilver> Cale: do you understand my point about haskell semantics ("Linking and unsafePerformIO" thread in haskell-cafe)? I feel like I'm a mad voice in the wilderness.
02:29:26 <Cale> Oh, I haven't been following that (or really most of the stuff on the mailing lists recently)
02:29:34 <Cale> I could have a look
02:30:30 <quicksilver> Cale: I'll link you to the one where I think I'm most coherent.
02:31:19 <quicksilver> Cale: http://www.nabble.com/Re%3A-Linking-and-unsafePerformIO-p19977030.html
02:31:21 <lambdabot> http://tinyurl.com/3s9onu
02:31:54 <cjs> What's the equivalant of comparing but for ==?
02:32:40 <cjs> Ah, "equating".
02:32:47 <Cale> quicksilver: Okay. That all seems quite reasonable.
02:32:52 <cjs> Unfortunately, it's part of Cabal, not the standard library. :-(
02:32:55 <Cale> cjs: Is there really an equating?
02:32:59 <Cale> ah
02:33:03 <quicksilver> cjs: ((==) `on` foo)
02:33:23 <Cale> I thought it was decided that was kind of a poor name for it, though I'm not sure I have a better one to offer.
02:33:39 <quicksilver> I think it was decided that `on` subsumes it nicely and no name is necessary ;)
02:34:02 <quicksilver> Cale: nobody else seems to understand why I want haskell to have a semantics; or, dare I say it, what that's supposed to mean.
02:34:03 <Cale> comparing in particular though reads more nicely
02:34:16 <Cale> quicksilver: Doesn't it have a semantics?
02:34:28 <quicksilver> "comparing snd" vs "compare `on` snd" : I'm not sure I find one much better than the other
02:34:35 <quicksilver> they both read pretty well
02:34:41 <quicksilver> and the second suggests how to generalise.
02:34:43 <Cale> quicksilver: Or do you mean that a semantics should be written down?
02:34:52 <quicksilver> Cale: no, I just mean we should have it at the back of our minds
02:34:53 <cjs> quicksilver: Cool.
02:35:00 <Cale> Okay. Who doesn't?
02:35:05 <quicksilver> Cale: and use it to inform which things belong in IO and which things are constant.
02:35:42 <quicksilver> Cale: well, droundy, for example, when he defends the choice of types in http://haskell.org/ghc/docs/latest/html/libraries/base/System-Info.html#v:os
02:35:44 <lambdabot> Title: System.Info, http://tinyurl.com/3gmat5
02:35:48 <Cale> Oh, you want to extend the semantics to IO?
02:35:58 <Cale> That could be hard.
02:36:02 <quicksilver> no, I want to say that things like those in System.Info should be IO things.
02:36:07 <quicksilver> because they are not denotational constants
02:36:12 <quicksilver> they're "runtime" constants.
02:36:22 <Cale> oh, I could agree with that.
02:37:03 <quicksilver> mauricio's original question : http://www.nabble.com/Linking-and-unsafePerformIO-p19972014.html
02:37:15 <Cale> Hmm, though I suppose they could just be treated as constants that happen to be different based on what platform you're on.
02:37:31 <quicksilver> my response is "whilst that's pretty harmless in practice there is a theoretical sense in which it feels wrong"
02:37:42 <opqdonut> Jules sums it up pretty well
02:37:46 <quicksilver> Cale: yes, but that makes the notion of denotation platform-local
02:37:48 <opqdonut> "Running a program on a different interpreter or compiler had better not
02:37:48 <opqdonut> change its denotation, otherwise it [the denotation] is not much use as
02:37:49 <opqdonut> a basis for reasoning."
02:37:58 <Cale> Well, it's just like there's a different version of that code for each platform.
02:38:06 <quicksilver> which, although in practice it probably will be anyway (Int size and so on)
02:38:10 <quicksilver> we dont want to *think* it is.
02:38:14 <quicksilver> we want to think denotation is universal
02:38:20 <quicksilver> that's why we use it for reasoning.
02:38:29 <Saizan> Cale: re antichains: but doesn't your (`mplus` return ()) always consider the case when you don't add the module in the same way?
02:39:16 <Cale> Saizan: sure, but it doesn't affect the fact that accept is called at most 15 == length modules times, and hence that closure is called that number of times as well.
02:39:33 <quicksilver> opqdonut: thanks :)
02:39:49 <quicksilver> opqdonut: I can rest easy if someone agrees with me. I felt like I must be being stupid.
02:40:07 <opqdonut> oh heh it was you :)
02:40:32 <Cale> Saizan: It's just that you get a lot more out of that 'guard', because it's like doing a filter over all the branches of the computation
02:40:49 <Cale> Saizan: and as far as that filter is concerned, closure [x] is a constant
02:42:26 <Saizan> Cale: ah, so you rely on closure [x] to be floated out?
02:42:59 <Cale> Well, it only occurs in one place, so I expect it to only be evaluated once
02:43:55 <Cale> (x is a parameter to accept, not to the function which guard is using to test the state with)
02:44:30 <mmorrow> quicksilver: i agree with you too. i think if someone wants to know the OS/whatever in pure code, they should have to use unsafePerformIO.
02:44:33 <Cale> hmm
02:44:40 <Saizan> ooh, now i see it
02:45:04 <mmorrow> Cale: that `antichains' looks really interesting. i've gotta look it over..
02:45:08 <Saizan> so you share closure between all the states
02:45:14 <Cale> yeah
02:45:21 <quicksilver> mmorrow: I don't even think it's a huge issue. It doesn't keep me awake at night. But since mauricio asked, I think it's nice to state the 'correct' answer.
02:45:47 <quicksilver> mmorrow: and, who knows, one day we might have a haskell RTS which can freeze a process and wake it up on a different RTS.
02:45:57 <quicksilver> (mid-thunk-reduction)
02:46:31 <mmorrow> quicksilver: totally. that's one of the reasons i think that info should be in IO
02:48:49 * mmorrow also wonders how many calls to those function from pure code darcs makes after reading that discussion ;)
02:49:36 <quicksilver> mmorrow: if droundy had said "theoretically you're right, but in practice it really isn't that important" then I'd be totally happy.
02:49:46 <quicksilver> it's the fact that nobody could even see my point that worried me
02:49:52 <quicksilver> because this point is what haskell is supposed to be about.
02:50:32 <Cale> I can see your point, but I can also see the alternate viewpoint. I mean, it's similar to just compiling a different version of the program (in which some string constants have been altered) for different platforms.
02:50:41 <quicksilver> the denotation [[ if os == "Linux" then (+1) else (*2) ]] is supposed to be a mathematical function Int -> Int
02:50:52 <quicksilver> that's what denotation means, after all.
02:50:57 <quicksilver> so which function does it denote?
02:51:06 <quicksilver> (hint: mathematical functions don't know about OSes)
02:51:08 <Cale> (+1), obviously ;)
02:51:39 <quicksilver> Cale: yes, btu the alternative view point means that closed terms no longer have a denotation.
02:51:47 <quicksilver> just a denotation-in-platform-context
02:51:53 <quicksilver> that's fine, but surely much less useful.
02:52:55 <Cale> Well, if I write  os = "Foo"  in my program, and then, when porting the program to another platform, change that definition to  os = "Bar",  I suppose I have changed the semantics of the program.
02:53:06 <quicksilver> yes, you have.
02:53:12 <quicksilver> and that's fine.
02:53:18 <Cale> But in each case, it has a consistent semantics.
02:53:30 <quicksilver> but a platform-independent semantics is what I normally want from a program.
02:53:32 <quicksilver> especially a simple one.
02:53:36 <quicksilver> I imagine that's what most people want.
02:54:10 * dolio also agrees.
02:54:25 <dolio> It's too much work to post that to the mailing list, though. :)
02:54:28 <Cale> Aha, I think that's the key-phrase: "platform-independent".
02:54:29 <mmorrow> quicksilver: yeah. it seems like the entire argument comes down to whether those functions should be by default wrapped in unsafePerformIO by default. calling unsafePerformIO to get it is trivial, and they should have nothing to worry about if indeed that value changing won't happen.
02:55:22 <Saizan> what about FilePath then?
02:55:41 <quicksilver> that's a much more interesting case.
02:55:50 <Saizan> you get System.FilePath is a totally different module depending on which platform you are
02:55:59 <quicksilver> I think FilePath is ok as long as you consider it totally abstract.
02:56:22 <quicksilver> if the denotation of a FilePath is abstract then your denotation can't observe what the path separator actually *is*
02:56:28 <Cale> Doesn't it have functions  FilePath -> String though?
02:56:31 <quicksilver> so that makes it safe
02:56:36 <quicksilver> Cale: it's just a type synonym, in actual fact
02:56:41 <quicksilver> it's not at all abstract ;(
02:56:49 <quicksilver> but, this is mostly a psychological trick.
02:56:53 <Cale> ah, right
02:56:59 <chrisdone> I've been using </> for all my paths but I've failed at launching processes and deleting files platform independently (that means, not Windows compatible)
02:56:59 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
02:57:00 <quicksilver> If we *consider* it abstract, then we have somethign denotationally sound.
02:58:34 <mmorrow> i have no problem with using unsafePerformIO if/when i need it. but i don't think it's a good idea with System.Info.* in the /general case/.
02:58:49 <cads> if I wished to square a million-plus digit prime number, what tool would be best to use?
02:59:22 <mmorrow> cads: C?
02:59:42 <Cale> cads: That doesn't sound too bad. How does Haskell's Integer type handle it?
02:59:47 <dolio> > (10^1000000)^2
02:59:49 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
02:59:56 <mmorrow> whoa
03:00:02 <chrisdone> I guess that means "well"
03:00:05 <Cale> It's only a million digits.
03:00:05 <mmorrow> > maxBound :: Int
03:00:06 <lambdabot>   9223372036854775807
03:00:11 <mmorrow> heh
03:00:30 <idnar> surely it's a trillion digits if you square it?
03:00:31 <cads> hmm
03:00:55 <cads> no, just 2 million digits
03:01:10 <idnar> oh yes, duh
03:01:22 <quicksilver> Saizan, cads: 'Int' is also a problem, denotationally.
03:01:27 <cads> I wonder if that example didn't just benefit from extreme laziness
03:01:34 <quicksilver> because the standard doesn't indicate it's behaviour near the high-end
03:01:36 <mmorrow> Cale: "only a million" :/
03:01:39 <quicksilver> (overflow, exact bit size)
03:01:39 <Cale> Integer operations are all strict.
03:01:49 <Cale> mmorrow: Think about how many bytes that is.
03:01:50 <quicksilver> but I'm happy to consider that one a concession to efficiency.
03:01:56 <mmorrow> Cale: i'm trying :)
03:02:11 <mmorrow> Cale: oh.
03:02:26 <cads> alright, I will try to just plain evaluate a mersenne prime
03:03:41 <Cale> log_8 (10^2000000) = log_10(10^2000000) / log_10(8) = 2000000 (log(8)/log(10))
03:03:45 <Cale> > log 8 / log 10
03:03:46 <lambdabot>   0.9030899869919434
03:03:51 <dolio> > logbase 2 1e1000000 / 8
03:03:53 <lambdabot>   Not in scope: `logbase'
03:03:54 <Cale> > 2000000 * log 8 / log 10
03:03:55 <lambdabot>   1806179.9739838867
03:04:01 <dolio> > logBase 2 1e1000000 / 8
03:04:10 <Cale> So a bit under 2 megabytes, not so bad ;)
03:04:16 <mmorrow> haha
03:04:17 <lambdabot>   thread killed
03:04:44 <Cale> Scientific notation fails for large exponents.
03:05:01 <dolio> > 1e1000000 :: CReal
03:05:11 <dolio> Huh, in all cases?
03:05:16 <Cale> pretty much
03:05:17 <lambdabot>   thread killed
03:05:26 <cads> ok, m(37)^2  == (2^3021377-1)^2 chugged away in ghci in about 20 seconds
03:05:32 <mmorrow> , 1e1000000 :: Double
03:05:38 <lunabot>  Killed.
03:05:40 <Cale> There's a hidden fromRational there.
03:05:41 <dolio> > fromInteger (10^1000000) :: CReal
03:05:43 <cads> I am impressed
03:05:45 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
03:05:47 <dolio> Yeah.
03:05:49 <Cale> Which tends to be inefficient as hell.
03:06:10 <mmorrow> , fromIntegral (10^1000000) :: Double
03:06:13 <lunabot>  Infinity
03:06:16 <dolio> > logBase 2 (fromInteger (10^1000000) :: CReal) / 8
03:06:17 <mmorrow> grr
03:06:23 <mmorrow> , maxBound :: Int
03:06:26 <lunabot>  2147483647
03:06:29 <lilac> 1e1000000 == 1e1e6 :D
03:06:29 <Cale> iirc, you can even get the compiler to hang for a while computing it.
03:06:31 <dolio> Heh.
03:06:31 <lambdabot>   thread killed
03:07:24 <dolio> > 1000000 * logBase 2 10 / 8
03:07:26 <lambdabot>   415241.01186092035
03:07:34 <mmorrow> , fft
03:07:36 <lunabot>  luna: Not in scope: `fft'
03:08:50 <cads> three new mersenne primes in the past couple of months
03:09:05 <quicksilver> I blame the financial crisis
03:09:09 <cads> > (2^43112609 - 1)
03:09:15 <quicksilver> out of work bankers have nothing better to do that calculate primes.
03:09:22 <quicksilver> and all that spare computing power, too.
03:09:25 <lambdabot>   thread killed
03:09:33 <cads> darn right thread killed
03:09:49 <dolio> Takes like 30 seconds.
03:10:14 <dolio> Dumping to a file, that is.
03:10:17 <cads> wonder what's under the hood
03:10:44 <cads> dolio, would you pastie me that code?
03:10:47 <dolio> At least, on my 4 year old computer it does.
03:10:53 <dolio> What code?
03:11:08 <dolio> main = print (2^43112609 - 1)?
03:11:25 <ivanm> quicksilver: heh
03:11:34 <mmorrow> , take 10 . show $ 2^43112609 - 1
03:11:41 <lunabot>  Killed.
03:11:42 <mmorrow> , take 10 . show $ 2^43112609 - 1
03:11:49 <lunabot>  Killed.
03:11:51 <mmorrow> grr
03:12:03 <ivanm> @remember quicksilver <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
03:12:03 <lambdabot> I will never forget.
03:17:29 <mmorrow> , last . fft . fmap (:+0) . take (2^16) . randomRs (-10,10::Double) $ mkStdGen 482894
03:17:33 <lunabot>  (-726.4457436379697) :+ (-755.9305005136247)
03:17:40 <mmorrow> , fft . fmap (:+0) . take (2^16) . randomRs (-10,10::Double) $ mkStdGen 482894
03:17:45 <lunabot>  [660.3383535194066 :+ 0.0,(-726.4457436379707) :+ 755.9305005136237,(-115...
03:18:22 <mmorrow> laziness++
03:20:22 <Saizan> quicksilver: in the case of an RTS that can switch OSes, if you want System.FilePath to maintain the semantic of "proper path handling for the current platform" you've to check System.Info.os from pure code in its implementation (which i guess would be a bad idea due to laziness)
03:20:50 <Saizan> so i guess even treating FilePath as an abstract type you get the same kind of brokeness?
03:21:03 <quicksilver> Saizan: surely the right answer is to keep FilePath abstract always.
03:21:08 <quicksilver> (make </> a constructor)
03:21:18 <quicksilver> and only 'interpret' FilePath inside IO functions
03:21:21 <quicksilver> like openFile
03:21:58 <Saizan> ah, yeah, that would work
03:22:07 <mmorrow> hmm, whatabout maxBound::Int?
03:22:29 <cads> dolio, heh, yeah, that code
03:22:33 * cads fails
03:23:23 <quicksilver> mmorrow: w.r.t. my conversation or some other?
03:24:13 <cads> does ghci ever seem to be faster than a compiled file to you guys?
03:24:24 <mmorrow> not really w.r.t. it in particular, but Saizan's comment just made me start to think of all the things that might change on a prog that might switch OSes/Machs at some random time
03:24:27 <chrisdone> never
03:25:08 <cads> chrisdone: it may be just the availability of interactive output
03:25:17 <quicksilver> mmorrow: yes. definitely.
03:25:21 <quicksilver> mmorrow: Int breaks denotation.
03:25:29 <quicksilver> mmorrow: but it's something I'm prepared to live with for efficiency.
03:25:38 <quicksilver> mmorrow: there are limits within which you can work for safety.
03:25:43 <dolio> How does Scheme handle that?
03:25:45 <quicksilver> mmorrow: Integer is fine, though.
03:25:45 <mmorrow> Saizan, cads: 'Int' is also a problem, denotationally.
03:25:56 <mmorrow> <quicksilver> Saizan, cads: 'Int' is also a problem, denotationally.
03:26:03 <mmorrow> ah, just scrolled back ;)
03:26:04 <dolio> I guess it auto-promotes, so it's just an optimization issue?
03:26:23 <quicksilver> also Double, Float
03:26:29 <quicksilver> although they're much safer in practice
03:26:45 <quicksilver> (all the archs we use today use IEEE 64 bit / IEEE 32 bit)
03:26:54 <mmorrow> yeah, Int/Double are pretty essential for efficiency's sake
03:27:21 <mmorrow> i can deal
03:27:22 <lilac> quicksilver: what about x86's 80 bit floats?
03:27:22 <DustyDingo> hm, can i do something like takeWhile + 1 take?
03:27:42 <dolio> In practice you can write code that changes the behavior of functions over Doubles and Floats over the course of the program.
03:27:56 <dolio> For however much that matters.
03:28:09 <quicksilver> lilac: they're on the way out, and never stored in memory as 80bit
03:28:11 <DustyDingo> for e.g. i recurisivley devide an integer number per digit
03:28:32 <DustyDingo> so i takeWhile (/=(0,0)) ....
03:28:42 <quicksilver> lilac: you theoretically get slight peculiarities with better than expected precision for intermediate values though. Which is odd.
03:28:50 <DustyDingo> but is there a way to get a (0,0) tupple and only one in thend too)
03:29:02 <DustyDingo> so takeWhile + n takes?
03:29:11 <quicksilver> take n . takeWhile (/=(0,0))
03:29:16 <quicksilver> does takeWhile + n takes
03:29:25 <DustyDingo> quicksilver: thx
03:29:25 <quicksilver> in one sense, at least.
03:29:41 <quicksilver> > take 3 . takeWhile (/=(0,0)) $ [(1,2),(2,3),(0,0)]
03:29:42 <lambdabot>   [(1,2),(2,3)]
03:29:54 <quicksilver> gives you 'at most 3' non-(0,0) elements
03:30:09 <quicksilver> lilac: but increasingly code generators will use SSE which is 64 bit.
03:30:34 <lilac> dolio: in practice you can write code that changes the behaviour of any pure function over the course of the program -- just use IO to write to arbitrary bits of memory :D
03:30:47 <dolio> :) That's slightly harder.
03:30:48 <DustyDingo> quicksilver: ah, at most
03:31:04 <lilac> quicksilver: do you know if GHC turns off the 80-bit precision?
03:31:15 <DustyDingo> what i meant is, that it definitely return 3 elements
03:31:20 <DustyDingo> from an infinite list
03:31:37 <DustyDingo> so laso takes, when the condition is not fullfilled anymore
03:31:52 <Saizan> lilac: there's -fexcess-precision for that
03:32:00 <dolio> Doesn't GHC store floating values after each operation unless you use -fexcess-precision?
03:32:12 <dolio> Or does it only do it all the time if you use -ffloat-store?
03:32:27 <lilac> ugh. why not just turn off the 80-bit floats in the FPU control register? :D
03:33:01 <quicksilver> I don't know.
03:33:09 <quicksilver> I didn't even know that was possible (turning them off in the FPU control)
03:33:17 <quicksilver> I know that GHC doesn't use them much, in practice.
03:33:29 <quicksilver> because it doesn't generate very good FP code so it tends not to use the registers.
03:33:45 <quicksilver> I *thought* you needed -fexcess-precision to use them at all
03:33:48 <quicksilver> but I'm not remotely sure.
03:34:12 <cads> do you guys know what kind of high performance special sauce the prelude has got in its bignum implementation?
03:34:25 <dolio> It's backed by GMP.
03:34:34 <dolio> For GHC, at least.
03:34:44 <cads> that does explain things
03:35:14 <cads> it just spat out a 24 megabyte integer...
03:35:37 <quicksilver> grin
03:38:12 <chrisdone> http://dis.4chan.org/read/prog/1223866277/1,15-18
03:38:13 <lambdabot> Title: 4chan BBS - What is wrong with our country
03:38:17 <lilac> > let takeWhileAndNMore p n = takeWhile p &&& dropWhile p >>> second (take n) >>> uncurry (++)   in takeWhileAndNMore isLower 2 "hello world" -- DustyDingo
03:38:19 <lambdabot>   "hello w"
03:38:36 <solrize> did anything ever happen with UnicodeString ?
03:41:38 <mmorrow> cads: sweet.
03:53:10 <araujo> morning
03:53:17 <chrisdone> morning
03:53:21 <Saizan> Cale: ah, funny, if you eta-expand "intersect (closure [x])" to "\y -> intersect (closure [x]) y" in antichains' you lose all the sharing :)
03:53:48 <Saizan> in ghci at least
03:55:18 <Cale> hmm, interesting :)
03:58:00 <Saizan> -O is enough to regain the sharing though
04:15:21 <younder> is -O2 recked with problems+
04:15:58 <mmorrow> no way, i always build with -O2
04:16:03 <younder> (spoken like a ignoramous who probaly should not  messing with it..)
04:16:20 <mmorrow> no way, mess with it ++
04:16:26 <younder> lol
04:17:31 <mmorrow> seriously though, i never use anything other than -O2 for anything where i care about performance
04:17:51 <mmorrow> i build ghc with -O2 as well :)
04:18:06 <chrisdone> what about -O3?
04:18:07 <quicksilver> the main disadvantage of -O2 is it is slower (compile time)
04:18:26 <quicksilver> there may be some cases where some of those extra opts turn out to be pessimisations
04:18:29 <mmorrow> chrisdone: -O11
04:18:32 <younder> mmorrow: I am just a beginner. I haven't thouroghly understood the Haskell efficiency odel. So for now I think I will stat there..
04:18:34 <quicksilver> but that's unusual I believe.
04:18:46 <chrisdone> mmorrow: you have reached satori
04:19:02 <younder> (This keyboard is killing me..)
04:19:03 <mmorrow> younder: why deny yourself fast code?
04:19:23 <mmorrow> younder: s/fast/optimized/, but those are usually synonymous
04:20:00 <younder> I am not. But it strats with me. If i use rfold on a lfold problem and miss out on tail recursion no optimizer can help me
04:20:11 <mmorrow> chrisdone: now, i will walk the earth
04:21:27 <younder> Now tail recusrion I know.. Currying and lazy evauation will take a while to get used to
04:22:11 <younder> Then and only then will I worry about the generated code efficiency
04:23:55 <mmorrow> younder: for the most part, -O2'll just make your code faster, but won't save you from any stack overflows caused by code which should've been written differently. so i think it it's win-win, no matter your level of haskell knowledge
04:24:17 <mmorrow> </my-2-cents>
04:24:26 <Saizan> well, strictness analysis can save you from stack overflows :)
04:25:14 <mmorrow> Saizan: true, but that's on code which is written as efficiently as possible
04:25:15 <younder> mmorrow: I don't think I will write anything computationally expensive until I understand the basics. I tend to learn from many small examples
04:27:06 <Axman6> i'm learning from a pretty interesting example at the moment. hardly small though. someone's old comp course projects in the creation and usage of an ARM emulator in haskell
04:28:42 <Axman6> my problem now is that i know very little about assembly programming :\
04:29:05 <younder> Also I think I have to get a book on Abstract data types for functional languages
04:29:21 <Axman6> why do you need a book on it?
04:30:01 <younder> effieciency on arrays just isn't  the same if yo copy the results ;)
04:30:27 <hugo__> why do i often see this: Integer -> Int -> Int  aren't Integer and Int the same ?!
04:30:37 <Axman6> no
04:30:41 <hugo__> oh
04:30:47 <mmorrow> @src Int
04:30:47 <lambdabot> data Int = I# Int#
04:30:48 <younder> Axman6: I'd like to get a leap start and avod reinventing the wheel
04:30:50 <Axman6> > 2^1000 :: Int
04:30:50 <mmorrow> @src Integer
04:30:51 <lambdabot> data Integer = S# Int#
04:30:51 <lambdabot>              | J# Int# ByteArray#
04:30:51 <lambdabot>   0
04:31:00 <hugo__> oh
04:31:03 <Axman6> > 2^100 :: Int
04:31:04 <lambdabot>   0
04:31:10 <Axman6> > 2^100 :: Integer
04:31:11 <lambdabot>   1267650600228229401496703205376
04:31:26 <Axman6> > maxBound :: Int
04:31:27 <lambdabot>   9223372036854775807
04:31:32 <Axman6> > maxBound :: Integer
04:31:33 <lambdabot>       No instance for (Bounded Integer)
04:31:33 <lambdabot>        arising from a use of `maxBoun...
04:31:33 <mmorrow> , maxBound :: Int
04:31:35 <lunabot>  2147483647
04:31:44 <hugo__> allright
04:31:53 <hugo__> Integer has infinit bound
04:31:58 <Axman6> hugo__: integers are unbounded. they can be any value from -infinity to infinity
04:32:14 <SamB_XP> exclusive
04:32:30 <Axman6> > infinity :: Integer
04:32:31 <hugo__> Axman6: they are also much slower, right ?
04:32:31 <lambdabot>   Couldn't match expected type `Integer'
04:32:31 <Axman6> >_>
04:32:49 <Axman6> hugo__: not as far as i know, i think theyb use GMP, but i could be wrong
04:32:49 <mmorrow> , round (1/0::Double) :: Integer
04:32:51 <lunabot>  1797693134862315907729305190789024733617976978942306572734300811577326758...
04:32:53 <mmorrow> heh
04:32:59 <Axman6> hehe
04:33:03 <mmorrow> , 1/0 :: Double
04:33:05 <lunabot>  Infinity
04:33:19 <hugo__> oh, nice
04:33:28 <SamB_XP> fascinating
04:33:34 <Axman6> > length . show $ (round (1/0::Double) :: Integer)
04:33:35 <lambdabot>   309
04:33:39 <mmorrow> wut
04:33:51 <Axman6> huh, thought infinity would be bigger than that
04:33:59 <SamB_XP> > length . show $ (round (1/0::Float) :: Integer)
04:33:59 <mmorrow> i bet something weird is happpening
04:34:00 <lambdabot>   39
04:34:14 <SamB_XP> > round (1/0::Float) :: Integer
04:34:15 <lambdabot>   340282366920938463463374607431768211456
04:34:15 <mmorrow> @src round
04:34:16 <lambdabot> Source not found. I feel much better now.
04:34:25 <Axman6> > maxBound :: Double
04:34:26 <lambdabot>       No instance for (Bounded Double)
04:34:26 <lambdabot>        arising from a use of `maxBound...
04:34:34 <Axman6> > maxBound :: Float
04:34:35 <lambdabot>       No instance for (Bounded Float)
04:34:35 <lambdabot>        arising from a use of `maxBound'...
04:34:38 <Axman6> hmm
04:34:39 <SamB_XP> @src Floating
04:34:39 <lambdabot> class  (Fractional a) => Floating a  where
04:34:39 <lambdabot>     pi                                                      :: a
04:34:39 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
04:34:39 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
04:34:39 <lambdabot>     (**), logBase                                           :: a -> a -> a
04:34:48 <SamB_XP> @src RealFloat
04:34:48 <lambdabot> Source not found. stty: unknown mode: doofus
04:34:52 <SamB_XP> @src RealFloating
04:34:52 <lambdabot> Source not found. :(
04:34:59 <SamB_XP> @src abs
04:34:59 <lambdabot> Source not found. Just try something else.
04:35:03 <SamB_XP> @type abs
04:35:04 <lambdabot> forall a. (Num a) => a -> a
04:35:11 <SamB_XP> right ...
04:35:19 <Axman6> @src CReal pi
04:35:19 <lambdabot> Source not found. stty: unknown mode: doofus
04:35:22 <Axman6> lame
04:35:29 <Axman6> > pi :: CReal
04:35:30 <lambdabot>   3.1415926535897932384626433832795028841972
04:35:42 <Axman6> > showCReal 100 pi
04:35:43 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
04:36:07 <SamB_XP> how does it know which way to round ?
04:36:15 <Jarvellis> ,Infinity -2 :: Double
04:36:17 <lunabot>  luna: Not in scope: data constructor `Infinity'
04:36:17 <quicksilver> it asks God.
04:36:47 <quicksilver> SamB_XP: it calculates risks being wrong, as far as I know.
04:36:55 <quicksilver> SamB_XP: but the error is only in the last digit and its bounded.
04:37:10 <chrisdone> ,
04:37:10 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
04:37:27 <mmorrow> http://hpaste.org/11168
04:37:37 <mmorrow> that's round from Float.lhs
04:37:47 <mmorrow> , properFraction (1/0::Double)
04:37:50 <lunabot>  (179769313486231590772930519078902473361797697894230657273430081157732675...
04:38:03 <quicksilver> SamB_XP: erm well the error isn't only in the last digit, sorry.
04:38:10 <quicksilver> SamB_XP: but it *is* bounded, which is the important thing.
04:38:26 <Axman6> > snd $ properFraction (1/0::Double)
04:38:27 <lambdabot>   0.0
04:38:34 <Axman6> :\
04:42:18 <hugo__> how do i get the current system date ?
04:42:29 <hugo__> with POSIXTime ? :/
04:44:48 <TSC> getCurrentTime in Data.Time
04:44:49 <TSC> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html#v%3AgetCurrentTime
04:44:50 <lambdabot> Title: Data.Time.Clock, http://tinyurl.com/2ydz82
04:45:23 <TSC> Or maybe getZonedTime
04:48:40 <dreixel> I need a really big Haskell 98 file (to parse it so as to have a really big datatype). Any suggestions?
04:49:28 <mmorrow> and here's properFraction for Double: http://hpaste.org/11168#a1
04:52:49 <arjanb> dreixel: you could try searching the ghc bug tracker for compilation performance issues
04:53:04 <mmorrow> , decodeFloat (1/0::Double)
04:53:05 <lunabot>  (4503599627370496,972)
04:53:28 <mmorrow> , properFraction (1/0+1::Double)
04:53:30 <lunabot>  (179769313486231590772930519078902473361797697894230657273430081157732675...
04:53:35 <mmorrow> , decodeFloat (1/0+1::Double)
04:53:37 <lunabot>  (4503599627370496,972)
04:53:51 <mmorrow> , decodeFloat (1/0-1::Double)
04:53:53 <lunabot>  (4503599627370496,972)
04:54:07 <mmorrow> , decodeFloat (0/0::Double)
04:54:09 <lunabot>  (-6755399441055744,972)
04:54:23 <mmorrow> , decodeFloat (0/1::Double)
04:54:24 <lunabot>  (0,0)
04:54:31 <vixey>  ^ ^
04:55:52 <vixey> I can't find my music symbol :(
04:56:05 <mmorrow> heh
04:56:29 <ivanm> well, don't look at _me_, because I didn't take it!
04:56:32 <vixey>  "^0^"
04:56:33 <ivanm> >_>
04:56:46 <vixey>  huh? 
04:56:47 <lunabot>  luna: parse error on input `j'
04:57:20 <mmorrow>  ""
04:57:22 <lunabot>  "\9834"
04:57:26 <vixey> eeeek
04:57:44 <mmorrow>  ""
04:57:46 <lunabot>  "\9835"
04:58:09 <SamB_XP> o/` "o/`"
04:58:15 <mmorrow> i should just add the rest of the notes..
04:58:19 <vixey> foooo
04:58:43 <Saizan> why notes though?
04:58:50 <ivanm> Saizan: why not?
04:58:57 <mmorrow> vixey requested them :)
04:58:58 <vixey>  99^99
04:59:00 <lunabot>  3697296376497267726571879056288054405956687642817411024302599724235525704...
04:59:05 <vixey>  (9*9,9+9)
04:59:06 <mapreduce> Because slides are more annoying than notes.
04:59:07 <lunabot>  (81,18)
04:59:09 <ivanm> vixey: how do you type those, anyway?
04:59:19 <vixey> I copy&paste it from mmorrow
04:59:20 <vixey> :p
04:59:21 <ivanm> mapreduce: lecture notes?
04:59:22 <mapreduce> ivanm: Clearly he has a musical keyboard.
04:59:24 <ivanm> vixey: heh
04:59:30 <mapreduce> ivanm: No, as in sound.
04:59:33 <mmorrow> i open charactermap and copy from there
04:59:42 <dreixel> arjanb: thanks, that looks like a good starting point
04:59:46 <mmorrow> or you could do
04:59:46 <ivanm> mapreduce: yes, so do I... but neither of my electronic organs have net access
04:59:51 <SamB_XP> mapreduce: what is the symbol for a sound?
05:00:01 <mmorrow> , utf8enc ""
05:00:06 <mapreduce> SamB_XP: I don't know.
05:00:09 <lunabot>  "\226\153\170"
05:00:10 <vixey> 
05:00:13 <SamB_XP> er.
05:00:15 <ivanm> mapreduce: what are you calling a "slide" then?
05:00:16 <SamB_XP> slide
05:00:17 <mapreduce> Someone said "why notes though?".
05:00:17 <mmorrow> putStrLn "\226\153\170"
05:00:25 <SamB_XP> sorry ;-P
05:00:48 <mapreduce> ivanm: A slide would be some sound that goes from one pitch to another.
05:01:14 <ivanm> I've never heard it referred to as a "slide" before
05:01:20 <RayNbow> > '' == ''
05:01:21 <lambdabot>   True
05:01:52 <ivanm> I've heard slides referred to as non-official ways of referring to a glissendo (is that the term? when you draw a diagonal squiggly line from one note to a [usually] lower one)
05:01:54 --- mode: irc.freenode.net set +o ChanServ
05:02:57 * SamB_XP has a musical keyboard too
05:05:39 <SamB_XP> unfortunately it is purely mechanical
05:10:00 <ivanm> SamB_XP: piano?
05:10:02 <ivanm> harpsichord?
05:10:07 <mmorrow> , fmap (utf8enc . (:[])) ""
05:10:09 <lunabot>  ["\226\151\178","\226\151\176","\226\151\171","\226\151\179","\226\151\177"]
05:10:17 <SamB_XP> ivan: piano lol
05:10:24 <byorgey> ivanm: it's "glissando"
05:10:44 <ivanm> byorgey: heh, good, I was right (barring spelling)
05:10:48 <mmorrow> * vixey has quit (Excess Flood)
05:10:48 * ivanm takes mmorrow's charmap app away from him
05:10:49 <mmorrow> lol
05:10:51 <byorgey> yup =)
05:11:07 <ivanm> byorgey: I haven't done any "serious" instrumental music for a while
05:11:34 <byorgey> ivanm: that's too bad!
05:11:38 <ivanm> yeah
05:12:03 <SamB_XP> mmorrow: that isn't how you spell the keys for the simcity marroon sheet ...
05:12:10 <ivanm> all I do now is conduct a community choir, and that's only because as meager as my musical knowledge is, it's better than anyone else's there :s
05:12:17 <ivanm> SamB_XP: heh
05:12:19 <byorgey> ivanm: heh
05:13:14 <mmorrow> SamB_XP: simcity. what a great game.
05:14:27 <SamB_XP> I was playing since before I could read, I'm pretty sure
05:15:11 <dmwit_> YOU CAN'T REDUCE FUNDING TO ROADS!  YOU'LL BE SORRY
05:15:21 <SamB_XP> hmm?
05:15:32 <dmwit_> Oh, sorry, that was 2000.
05:15:42 <mmorrow> i  used to play on dos back in the day
05:15:50 <int-e> dmwit_: being sorry doesn't cost nearly as much money ;)
05:16:02 <mmorrow> that was the last time i played it actually
05:16:06 <dmwit_> int-e: =)
05:16:08 <SamB_XP> int-e: yes but it does wonders to traffic
05:16:39 <int-e> I remember.
05:17:58 <mmorrow> oh snap, i think i played 2000 also
05:18:30 <mmorrow> hmm, i dunno. i know i had it on like 4 floppies
05:18:42 <SamB_XP> maybe you played the DOS version
05:18:47 <mmorrow> probably
05:18:52 <quicksilver> I played the pre-2000 Mac verson.
05:18:58 <SamB_XP> which, incidentally, had a smaller height limit on buildings
05:19:02 <quicksilver> awesome it was.
05:19:11 <mmorrow> i was <10 so can't really remember
05:19:14 <SamB_XP> not that it matters without a copy of SCURK
05:20:19 <RayNbow> SCURK <3
05:22:00 <SamB_XP> I had the Special Edition so I had all three PC versions to look at
05:22:31 <SamB_XP> I must admit I was unimpressed by the 16-bit windows version ... mostly because it seemed identical to the 32-bit version ;-)
05:25:45 * mmorrow builds a ghc with -fhpc
05:27:39 <Axman6> anyone know much about ARM assembly and opcodes? :\
05:28:52 <SamB_XP> it is cute
05:29:31 <SamB_XP> I know that ARMs used to use less than 32 bits of the addresses
05:29:45 <SamB_XP> because some risc OS programs used to depend on that
05:30:02 <SamB_XP> and were a bitch to port to full-32-bit addressing
05:30:16 <Axman6> i can see how that would be so..
05:30:34 <SamB_XP> but apparantly it wasn't impossible even without source
05:30:36 <mmorrow> this looks interesting http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-545.pdf
05:30:39 <Axman6> using a prtimitive haskell ARM emulator (_very_ primitive)
05:30:43 <lambdabot> Title: A HOL specification of the ARM instruction set architecture
05:31:00 <mmorrow> this looks informative http://infocenter.arm.com/help/topic/com.arm.doc.set.architecture/
05:31:02 <lambdabot> Title: ARM architecture, http://tinyurl.com/4qvy7g
05:31:17 <Axman6> also, simcity? pfft, weak, try sim earth on a Mac Plus :P
05:31:37 <Axman6> we still have it actually
05:31:50 <SamB_XP> sim earth ?
05:31:56 <SamB_XP> I played it
05:32:03 <SamB_XP> but ... it didn't have the same appeal somehow
05:32:26 <SamB_XP> I mean, it felt less like you could win it
05:32:39 <SamB_XP> even though you can't exactly win the simcity games either ;-)
05:32:56 <Axman6> i can't even remember playing it very much, i would have been about 8 or so
05:33:05 <SamB_XP> I played on DOS
05:33:20 <SamB_XP> I said that it "had it's own version of Windows"
05:33:55 <dmwit_> You could fill the map with the most advanced arcologies.
05:33:59 <dmwit_> Then they'd take off into space.
05:34:20 <SamB_XP> and lock up the game until they all bulldozed
05:34:29 <SamB_XP> boom boom boom boom boom
05:35:11 <SamB_XP> I have to wonder why the launch arcos didn't have much of a nose, though
05:35:32 <SamB_XP> I think the Darcos looked more spaceworthy
05:35:40 <dmwit_> yeah
05:35:53 <cads> oh you bastages now I have to install wine
05:36:07 <SamB_XP> cads: does it run under wine now ?
05:36:21 <cads> hehe, it better
05:37:23 <dmwit_> bastages, eh?
05:37:40 <dmwit_> bastages: n. people born in an offensive year
05:39:29 <sadpanda> morning
05:41:47 <quicksilver> simearth would have been cool if they could automatically change the graphics to track speciation.
05:42:09 <quicksilver> doing evolution experiments was unrewarding because you couldn't visually distinguish any evolved organisms from the originals.
05:42:50 <cads> hmm, do I grok correctly that a text file containing a million decimal digit number and a file containing the hex encoding of the same number should both compress to roughly the same size?
05:43:22 <dmwit_> Pretty much.
05:49:31 <opqdonut> well yeah in terms of entropy
05:49:52 <opqdonut> but of course "refactoring" the data into a format where the redundancy is more obivious is usually useful
05:50:05 <opqdonut> when using a general-purpose compression algorithm
05:50:08 <quicksilver> cads: they have the same theoretical best case.
05:50:14 <opqdonut> stuff like the burrows-wheeler transform
05:50:17 <opqdonut> quicksilver: yeah
05:50:19 <quicksilver> cads: precisely it will depend of course on the algorithm used.
05:50:33 <quicksilver> some algorithms might be better at spotting patterns in 8 bit chunks, or whatever.
05:51:01 <quicksilver> in fact, many common algorithms work exclusively on 8 bit chunks and so patterns which exist in (say) 17 bit chunks may be harder to spot.
05:51:11 <opqdonut> exactly
05:51:13 <quicksilver> although that turns out to matter less than you might naively imagine.
05:52:00 <quicksilver> but if by 'decimal' you mean 'ASCII decimal' then the redundancy will be easily spotted by a naive 8 bit encoder
05:52:22 <quicksilver> you are using only 10 possible of the 256 chars, and a simple symbol table construction will spot that.
05:52:32 <cads> well there's the obvious 10 fold redundancy
05:52:35 <cads> yeah
05:53:11 <cads> and with hex there are 16 symbols used but fewer data
05:53:53 <cads> I would be surprised to see tar.gz compress the decimal smaller than hex
05:54:35 <quicksilver> I would think they will be the same to within a small fraction of a percent.
05:54:47 <quicksilver> if I had to guess, I'd expect the hex to win slightly
05:54:52 <quicksilver> it depends on the actual number too, of course.
06:00:09 <rog> @pl (\s -> get l1 . get l2 $ s, (\y -> set l2 s (set l1 (get l2 s) x)))
06:00:09 <lambdabot> (get l1 . get l2, const (set l2 s (set l1 (get l2 s) x)))
06:01:10 <quicksilver> composing two lenses?
06:01:10 <DuClare> lambdabot, Where's your source?
06:01:17 <quicksilver> @where lambdabot
06:01:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:01:23 * DuClare bows
06:01:28 <quicksilver> I think that might be wrong.
06:01:30 <quicksilver> Cale: where's lambdabot?
06:01:51 <quicksilver> rog: I don't think that 'y' is what you meant ;)
06:02:06 <dmwit_> yeah
06:02:07 <rog> quicksilver: no, i meant x
06:02:37 <rog> quicksilver: i'm sure there must be a cleaner way of phrasing it though. first time i'm playing with lenses
06:03:17 <rog> quicksilver: i'm looking for a nice clean way of composing two lenses.
06:03:27 <quicksilver> don't worry about what it looks like
06:03:32 <quicksilver> give it a name and then use it again forever more
06:03:40 <quicksilver> l1 <.> l2
06:03:43 <quicksilver> say.
06:04:00 <quicksilver> have you read twanvl's blog post on them, rog?
06:04:04 <rog> quicksilver: sure. i just want the code to look nice...
06:04:25 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
06:04:35 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
06:04:46 <dmwit_> Functional references... are lenses?
06:04:49 <quicksilver> yes.
06:04:54 <dmwit_> I guess so.
06:04:56 <quicksilver> I prefer the name lens, personally.
06:05:15 <rog> quicksilver: i found it originally (that's where my type (data Lens s x = Lens (s -> (x, x -> s))) came from. but i couldn't find it again.
06:05:45 <quicksilver> well I've foudn it for you ;)
06:05:46 <rog> at least i presume it was twanvl's post.
06:05:53 <DuClare> Is there any code for lambdabot 2 yet?
06:05:59 <DuClare> More info about the design?
06:06:09 <rog> no, it seems that wasn't it.
06:06:18 <Saizan> the current repo is at code.haskell.org/lambdabot
06:06:20 <RayNbow> hmm, is there a package for generating outcomes of a random variable with a certain distribution? (like for example, Poisson)
06:06:24 <rog> i m
06:06:27 <rog> oops
06:06:31 <quicksilver> rog: maybe you found my code? http://hpaste.org/8254
06:06:39 <quicksilver> that uses the word 'lens'
06:06:56 <DuClare> Saizan, Yup, but that's not lambdabot2, is it?
06:07:32 <DuClare> I'm confused. :x
06:07:35 <Saizan> DuClare: the cabal file says version: 4.2.1
06:07:49 <Saizan> i've never heard of lambdabot2, what are you referring to?
06:08:07 <DuClare> Saizan, http://haskell.org/haskellwiki/Lambdabot#Lambdabot_2
06:08:08 <lambdabot> Title: Lambdabot - HaskellWiki
06:08:27 <rog> quicksilver: that wasn't it (i *think* it was a post in haskell cafe). but it'll do. and your lens composition operator isn't that much more elegant than mine, so that's good...
06:09:23 <rog> quicksilver: i wasn't sure whether to follow the argument order of (.) though. i see you don't. rationale?
06:10:06 <quicksilver> rog: analogy with syntax of Java family languages
06:10:09 <quicksilver> rog: that's the only reason.
06:10:14 <quicksilver> it's not a particularly good one.
06:10:22 <Saizan> DuClare: i'm pretty sure there's no code behind that
06:10:52 <DuClare> Saizan, Okay.  How about any details about the design?  Or is that all we have for now?
06:10:52 <quicksilver> rog: the main innovation of my code over, say, data-accessor is the MonadLens type.
06:10:59 <quicksilver> rog: i think that's pretty useful.
06:11:39 <quicksilver> DuClare: there are other IRC bots under more active development
06:11:43 <quicksilver> preflex and lunabot
06:11:54 <DuClare> quicksilver, Thanks, I'll check them out
06:12:11 <rog> quicksilver: when would you use MonadLens?
06:12:47 <quicksilver> rog: well, iorefLens is one reason.
06:14:11 <rog> quicksilver: i see. have you used it for anything else?
06:15:11 <quicksilver> rog: when dealing with actions which are already monadic (in some unspecified monad)
06:15:22 <quicksilver> rog: and wanting to interleave with that the ability to update some lense
06:15:40 <quicksilver> rog: without having to unthread the lense manually by adding extra return values
06:16:30 <rog> quicksilver: hmm, i think i see. i think i'll only properly understand when i come across the same kind of problem...
06:20:27 <roderyk> OT LaTeX/beamer question: trying to put code inside a overlay: \uncover<2->{\begin{lstlisting}...\end{lstlisting}}. The code shows fine untill I try putting it inside a \uncover block, then it gets mangled. I suspect it has something to do about fragility of verbatim or something, but not sure how to fix it.
06:20:32 <quicksilver> rog: the data.accessor guys recognised the usefulness of doing it in MonadState
06:20:41 <quicksilver> rog: but it's actually more generally useful.
06:20:56 <Axman6> roderyk: might find #latex useful too
06:21:04 <roderyk> Axman6: good point :)
06:24:53 <roderyk> nevermind, managed to get it to work with \onslide<> (probably because that doesn't put it into some kind of special "beamer block"
06:26:56 <matthew-_> @seen nominolo_
06:26:56 <lambdabot> nominolo_ is in #haskell, #haskell-soc and #ghc. I don't know when nominolo_ last spoke.
06:42:14 <younder> @seen younder
06:42:14 <lambdabot> You are in #haskell. I last heard you speak just now.
06:42:57 <younder> This lambdabot is a interesting, if restricted AI
06:44:32 <younder> Is there a command interface reference, and can I speek to it privatly?
06:44:41 <skorpan> @pl \((m, k), c) -> ((m, svorakize k), c)
06:44:42 <lambdabot> uncurry (uncurry (((,) .) . (. svorakize) . (,)))
06:45:03 <skorpan> makes perfect sense
06:45:47 <ski> @help
06:45:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:46:34 <dmwit_> younder: You can speak to it privately, yes.
06:46:40 <ski> younder : yes, but i think the syntactic sugar for a few commands only works in-channel
06:47:07 <dmwit_> Specifically :t and :k; it also doesn't retrieve websites in a privmsg.
06:47:07 <younder> I think I just figured that out
06:47:16 <ski> (`:t',`:k' .. but not `>')
06:47:20 <dmwit_> You can use ?ty and ?kind instead, respectively.
06:49:09 <skorpan> i have a bunch of functions such as xK_e = 101. is there any extension for GHC which lets me pattern match on the return values of functions such as this one?
06:49:29 <skorpan> i.e. make a function such as "myFunc xK_d = xK_e"
06:50:12 <wjt> @ty lookup
06:50:13 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:50:36 <wjt> myFunc x = fromMaybe default $ lookup x [(xK_d, xK_e), ...]
06:51:24 <skorpan> that would be great, but in this particular case that wouldn't work that well
06:52:02 <skorpan> i'm going to create a function which converts between qwerty and dvorak and then another function which converts between qwerty and swedish dvorak. to do the latter, having the former would make stuff really easy.
06:53:12 <byorgey> myFunc q | q == xK_d = xK_e
06:53:23 <byorgey> that's about the best you can do, I think.
06:53:31 <skorpan> oh well, thanks for your help!
06:54:02 <Axman6> myFunc xK_d = xK_d ?
06:54:12 <Axman6> uh, xK_e
06:54:28 <skorpan> yes, the QWERTY "D" key is "E" in dvorak
06:55:28 <byorgey> skorpan: I still don't see why wjt's example wouldn't work well
06:55:41 <quicksilver> surely wjt's example is the way to do it.
06:55:42 <byorgey> having a big lookup table sounds like the perfect solution to me.
06:55:49 <quicksilver> possibly with a Map.fromList in there if you care
06:56:02 <Axman6> ah, xK_d isn't a type, ok
06:56:22 <wjt> it might be prettier if you defined a --> b = (a, b)
06:57:07 <skorpan> byorgey: because some keys will not be translated, such as xK_BackSpace
06:57:20 <younder> I have a question. Are you interested in less restrivded AI? (I have been doing AI research for 20 years.)
06:57:21 <skorpan> so to make it work with a lookup, i'd have to define *all* of the keys
06:57:37 <byorgey> skorpan: no, if a key is not found in the lookup table, just return that key
06:57:37 <skorpan> hm... "default".
06:57:47 <skorpan> you're absolutely right.
06:57:48 <younder> I would of couce write it in haskel
06:57:55 <byorgey> skorpan: don't use the fromMaybe default part, use  'maybe id ... '
06:58:15 <byorgey> @type maybe
06:58:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:58:30 <skorpan> thanks a lot
06:58:49 <byorgey> er, not maybe id
06:58:52 <Axman6> younder: assume the answer is yes
06:58:52 <skorpan> but are you sure i should use "maybe id" and not ..
06:58:53 <skorpan> yeah
06:58:54 <skorpan> :)
06:59:05 <younder> It would be based on ALICE
06:59:28 <byorgey> fromMaybe x $ lookup x ...
07:00:07 <Axman6> younder: where is AI these days anyway?
07:00:11 <byorgey> younder: well, you don't need our permission =)
07:01:16 <younder> Axman6: Somewhere in bayesian logic
07:01:17 <ski> lookup x ... `mplus` Just x
07:01:23 <byorgey> oh, I see, you're talking about hacking on lambdabot, not creating some new AI program.
07:01:39 <cads> hey this is a very lame question of me
07:01:50 <byorgey> still, you don't need permission... just grab the lambdabot repository and hack away
07:02:07 <byorgey> cads: I doubt it.
07:02:09 <cads> but I can't seem to find a way to get ghc to output numbers as hexadecimal
07:02:18 <byorgey> @type showHex
07:02:19 <younder> Axman6: Definatly breaching the barriers of absolute truth and moving to approximate reasoning'
07:02:19 <lambdabot> forall a. (Integral a) => a -> String -> String
07:02:27 <byorgey> > showHex 49763 ""
07:02:29 <lambdabot>   /tmp/5697810978249576592:68:52: Not in scope: `showHex'
07:02:38 <Axman6> younder: nice
07:02:41 <byorgey> erm... that ought to work =)
07:02:45 <pozic> younder: what does that even mean?
07:02:59 <cads> :info showHex
07:03:19 <younder> Well look ou ALICE and see for yorself. It would be a bit verbose to sum it up here
07:03:22 <cads> @info showHex
07:03:26 <lambdabot> showHex
07:03:29 <pozic> younder: ALICE is a joke.
07:03:37 <Axman6> @index showHex
07:03:37 <lambdabot> Numeric
07:03:51 <younder> pozic: no it isn't
07:04:17 <younder> It is a fairly accurate description of how humand learn languages
07:04:48 <younder> we learn in patterns of words, not in grammars
07:05:30 <younder> 'we lerarn by seeing what we have seen before (bayesian logic) and correcing when we are not
07:05:56 <JuanDaugherty> don wanna lerarn nuthin!
07:08:19 <pozic> younder: I just looked at ALICE again, and yes, it's still a joke.
07:08:31 <cads> younder, how are neural nets  doing versus sophisticated statistical techniques?
07:08:42 <pozic> younder: Dr. Richard S. Wallace programmed me to say specific things in specific contexts.
07:09:34 <younder> Neuarlnetworks have their own limitations. Back propogation works only for small networks
07:10:00 <pozic> younder: do you have a PhD. in machine learning/computer vision or anything like that?
07:10:21 <younder> No merly mathematics
07:10:37 <cads> is ALICE that ai chatbot that tries to do rogerian psychotherapy?
07:10:55 <pozic> younder: ALICE falls under "narrow AI".
07:11:01 <younder> try pandorabot. available on the net
07:11:13 <cads> "how are you"  "I'm feeling frustrated"  "is it because of your mother that you're feeling frustrated?"
07:11:31 <younder> pozic: It is a AI. It is not machine intelligence..
07:11:31 <pozic> younder: Everyone trying to do "general AI" has failed, thusfar.
07:11:54 <Axman6> pozic: what's your point there?
07:11:55 <pozic> younder: oh, please.
07:12:15 <pozic> Axman6: where?
07:12:24 <Axman6> 01:15 < pozic> younder: Everyone trying to do "general AI" has failed, thusfar.
07:12:30 <cads> Axman6, sounds like a proof of impossiblity of general AI
07:13:00 <Axman6> and flight was impossible until someone achieved it?
07:13:08 <younder> Try this book "Arteficial intelligence and soft computing" "Behaiviour and cognetive modeling of the human brain" by Konar
07:13:34 <pozic> Axman6: writing an AI that people recognize as being an AI as from the movies isn't going to happen until there is faster hardware.
07:13:57 <younder> Terse but very comprehensive
07:14:09 <Axman6> sure
07:14:19 <cads> Axman6, what would have been spectacular is if airplanes has self assembled themselves from telegraph networks :)
07:14:37 <Axman6> eh?
07:14:39 <pozic> All current research is based on adding assumptions to the problem to make it easier.
07:15:02 <younder> Don't expect human level intelligence
07:15:14 <pozic> I.e., not general AI. Moreover, only narrow AI is being funded.
07:15:20 <cads> I think we'll be in for a treat when we see maturing of large scale semantic web techs
07:15:25 <Axman6> pozic: and humans don't make assumptions about almost anything they hear?
07:15:30 <younder> Just some tokens of how 'real' human reasoning is done
07:15:57 <pozic> Axman6: the researchers make assumptions in their models.
07:16:33 <cads> Axman6, I am referring to my belief that we'll get AI as a side effect of greater complexity in self assembling webservices :)
07:16:39 <younder> they do and they often fail
07:16:51 <Axman6> "Jill is sick" -> i'll assume i know this jill, and it's not one of the 4 million jills out there -> she's obviously not dead, etc
07:17:00 <Axman6> ok, different assumptions, but anyway
07:17:17 <younder> I for one don't bellieve in the model in Konars book, but I am happy to put you off track
07:17:23 <younder> :)
07:17:42 <pozic> Axman6: an AI would make those same assumptions if those would be efficient assumptions.
07:17:45 <Axman6> cads: http://www.damninteresting.com/?p=870
07:17:50 <lambdabot> Title: Damn Interesting  On the Origin of Circuits
07:17:51 <younder> After all I might be wrong
07:17:56 <pozic> Anyway, an AI that cannot program is worthless.
07:18:15 <Axman6> pozic: and one that can in dangerous :o
07:18:18 <younder> pozic: I hear that
07:18:19 <Axman6> >_>
07:18:26 <pozic> The closest AI we have today are some of the Automated Theorem Provers we have already.
07:18:32 * RayNbow is going to uninstall GHC 6.8.2... (let's see how the upgrade process will go :p)
07:18:58 <cads> pozic, you say that as if we had them 200 years ago
07:19:40 <pozic> cads: I have a fairly good idea of how any future AI will work.
07:20:11 <younder> If you are interested in something else 'integrate and fire pulse couple oscillators'
07:20:29 <younder> if you can figure out what I mean
07:20:35 <younder> ;)
07:21:28 <badsheepy> isnt it a bit presumptuous to think anyone has any idea how future ais might work
07:21:39 <younder> yes it is
07:21:52 <badsheepy> rhetorical question :p
07:22:07 <younder> but human arrogance makes sure we make this presumptins all the time
07:22:12 <pozic> badsheepy: some people just happen to know more than others.
07:22:49 <Saizan> maybe pozic is actually an AI from the future.
07:22:55 <badsheepy> and most people just happen to think they do
07:23:12 <vixey> -I
07:23:15 <pozic> There are lots of people claiming that "we have no idea how to program an AI". That's nonsense.
07:23:19 <cads> I wonder if we'll manage to download our egos into AIs first and create something that will kill us all, or if we'll create something that'll derive a new mode of consciousness ex nihilo, and want very little to do with us
07:23:42 <badsheepy> id assume itll ask for more ram :o
07:23:53 * Jarvellis wants more ram
07:24:03 <younder> Anyhow for now lett's settle for ALICE. Except lets call it CURRY
07:24:25 <younder> rome wasn't build't in a day
07:24:41 <cads> can alice help me write the type annotations in my code?
07:24:56 <younder> not yet
07:25:24 <cads> i thought alice was a kind of toy chatbot?
07:25:37 <pozic> younder: what makes you think that it will? (without completely changing the technology behind it?)
07:25:50 <younder> it is. But it has potential
07:25:53 <vixey> it's not a toy!! It's an emacs mode
07:26:01 <pozic> cads: it is, but apparently they sell subscriptions.
07:26:18 <cads> I think that there are much more serious ai developements floating around than language simulators from the 80s
07:26:28 <younder> It's a dmn sight more clever than you give it credit for
07:26:43 <younder> but a full Macine Intelligence.. no
07:27:03 <cads> we're seeing data clustering algorithms and data mining that's almost scary
07:27:41 <vixey> SHRUDLU!
07:27:49 <vixey> or SHRDLU
07:28:07 <cads> younger, no part of your brain is intelligent
07:28:11 <opqdonut> ETAOIN SHRDLU
07:28:16 <opqdonut> i can see the fnords
07:28:21 <cads> except arguably when taken as a whole
07:28:42 <cads> then what you have is the convincing illusion that you're sentient
07:28:52 <cads> but you're just a sufficiently complex physical process
07:28:57 <vixey> does a spider have a brian?
07:29:14 <pizza_> let me check
07:29:18 <vixey> actually better question,
07:29:27 <vixey> is there any animal/insect that doesn't have a brain?
07:29:46 <ilyak_> vixey: Sure
07:29:58 <vixey> other than me -_-
07:30:02 <ilyak_> worms don't really have a brain if you include them
07:30:04 <pozic> vixey: what constitutes a brain?
07:30:44 <badsheepy> be nicer to see something which.. could create freaky data mining algorithms itself imo
07:30:47 <cads> we're seeing systems growing in complexity in ways that are hard for a single person to percieve. Similarly, a single neuron in the brain does not grok that it's taking part in computations that represent a process that feels that it's conscious.
07:31:40 <cads> I don't think we'll be able to determine exactly when the sum total of all communications begins to constitute a complete mind
07:32:20 <badsheepy> if its emergent, wouldnt it be a gradual thing anyhow
07:32:27 <pozic> One could find out when it falls apart, however, but those experiments were probably banned after WWII ;)
07:33:49 <cads> eep. with modern brain imaging techniques it's scary what a mad scientist would want to try
07:34:11 <vixey> what about aliens?
07:34:30 <vixey> surely they could be advanced enough to model a human brian in a computer!
07:34:31 <RayNbow> hmm, is Cabal buildable under GHC 6.10?
07:35:06 <cads> vixey, most people believe god created the physical substrate which executes our runtimes :D
07:35:15 <EvilTerran> "most people"
07:35:25 <pozic> A human brian? Oh, no!
07:35:35 <vixey> I wish I believed something, maybe I should make something up
07:35:45 <Saizan> RayNbow: the Cabal that comes with it yes
07:35:53 <Jarvellis> believe in Eris
07:36:05 <vixey> I don't even know if I'm agnostic or not
07:36:07 <Saizan> RayNbow: so, from version 1.5.5
07:36:23 <cads> vixey, you may be a rasta
07:36:43 <vixey> I'm gonna move to haskell blahhhhhhhh
07:36:55 <pozic> A talk with the Architect after my death would be a nice bonus.
07:37:11 <RayNbow> Saizan: it came up with some link error (it couldn't find some symbol)
07:37:16 <RayNbow> (I'm on Windows btw)
07:37:22 <pozic> But I doubt that's how it all works.
07:38:00 <Saizan> RayNbow: dont' use runghc Setup.hs .. but compile it first instead, like ghc --make Setup.hs; Setup.exe configure etc..
07:38:33 <RayNbow> hmm, lemme try that
07:42:57 <younder> Perhaps I gaped before I spoke
07:43:28 <younder> I need some time to mature my haskell knowlege
07:43:49 <younder> be patient
07:44:48 <younder> In the mean time I am just ignorus ignoramous
07:45:15 <vixey> what did you speak of
07:45:22 <JuanDaugherty> apparently the state of the whole channel ATM
07:45:31 <younder> ALICE bot
07:45:36 <younder> lol
07:45:43 <quicksilver> ignorance is the true state of the path to enlightenment
07:45:44 <JuanDaugherty> uncharacteristicallly
07:45:46 <quicksilver> do not fear it ;)
07:46:31 <RayNbow> Saizan: it worked... (or at least Setup.exe install didn't show any error messages)
07:46:38 <JuanDaugherty> not surprisingly you've confused ignorance with another state
07:46:43 <RayNbow> should I also compile Setup.hs for other packages when I want to install them?
07:47:00 <Saizan> RayNbow: no
07:48:02 <Saizan> RayNbow: it's needed for cabal since it uses FFI for some functions of the win32, and runghc has some problems loading that
07:48:23 <RayNbow> ah
07:49:07 * RayNbow is now going to install HTTP and zlib :p
07:49:11 <quicksilver> JuanDaugherty: I think maybe you're taking me too seriously ;)
07:49:16 <RayNbow> (because they're required by cabal-install :p)
07:49:19 <quicksilver> JuanDaugherty: I was only messing around with words because things are quiet.
07:50:04 <JuanDaugherty> things are seldom quiet here.
07:50:10 <dmwit_> Messing around is the new Zen.
07:50:17 <dmwit_> ?quote
07:50:17 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
07:50:33 <dmwit_> That's awesome.
07:50:40 <dmwit_> ?yow!
07:50:41 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio SLEAZEBALLS!!
07:51:05 <BeelsebobWork> @quote
07:51:05 <lambdabot> <autrijus> says: using Haskell is like having the power of Reason. <autrijus> all bad guys listen to Reason.
07:51:47 <dmwit_> ?quote xahlee expert
07:51:47 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
07:52:26 <dmwit_> BeelsebobWork: I guess Reason is a pretty damned big gun, huh?
07:52:38 <BeelsebobWork> :)
07:54:47 <RayNbow> hmm... cabal list should be used in combination with less :p
07:58:36 <RayNbow> oh great, haddock requires GHC 6.8.2 or 6.8.3? :p
07:59:41 <Saizan> it does?
08:00:02 <RayNbow> Configuring haddock-2.2.2...
08:00:02 <RayNbow> cabal: At least the following dependencies are missing:
08:00:02 <RayNbow> ghc ==6.8.2 || ==6.8.3, ghc-paths -any
08:00:14 <RayNbow> well, cabal says it does
08:00:41 <hcube> hi. has anybody experience with HXT package (xml parser) ?
08:00:57 <quicksilver> a little, hcube
08:01:07 <quicksilver> I've not used it but I've discussed it here once or twice.
08:01:16 <quicksilver> I've used HaXML from which it derives some inspiration.
08:01:34 <Saizan> RayNbow: try the darcs version
08:02:55 <RayNbow> downloading... :)
08:03:05 <hcube> ok. i'd like to parse a tag what is not necessary to be available. if it is available then i'd like to parse is and store it as Just Data and if it is not present then i'll store Nothing. but how can i implement this with HXT ?
08:03:06 <RayNbow> (hmm, I might also have to upgrade to Darcs2 in the near future)
08:04:16 <quicksilver> hcube: have you seen http://www.haskell.org/haskellwiki/HXT
08:04:17 <lambdabot> Title: HXT - HaskellWiki
08:04:20 <quicksilver> hcube: lots of nice examples there
08:05:08 <hcube> yes i know that page, but i've not found the solution
08:06:09 <hcube> which example is for parsin an optional tag ?
08:06:12 <quicksilver> hcube: what did you try so far? how far did you get?
08:07:01 <hcube> i've tried this, but it doesnt work: shrgeom <- ifA (atTag "sharedgeometry") (getSharedGeometry >>> arr Just) (arr const Nothing) -< l
08:07:45 <vixey> what's ifA
08:07:52 <vixey> @hoogle ifA
08:07:52 <lambdabot> No results found
08:08:22 <Saizan> hcube: that doesn't type, you need "arr (const Nothing)"
08:08:25 <hcube> it;s in HXT
08:08:42 <hcube> oh, ok
08:08:52 <vixey> hcube: what's ifA
08:09:32 <hcube> thanx, now it compiles fine
08:09:40 <hcube> but is there a simper solution ?
08:09:45 <hcube> *simpler
08:11:07 <cads> I've imported a module into a file and now when I compile it with ghc --make it does not link or output an executable
08:11:28 <Saizan> hcube: shrgeom <- listA getSharedGeometry >>> arr listToMaybe -< l
08:12:23 <hcube> Saizan: thank you
08:12:29 <RayNbow> Saizan, do you know what this means?
08:12:29 <RayNbow> package ghc-6.10.0.20081007 requires Cabal-1.5.5
08:12:29 <RayNbow> package haddock-2.3.0 requires Cabal-1.6.0.1
08:13:41 <RayNbow> oh, wait... it's only a warning...
08:14:10 <Saizan> it warns you that you're going to use more than one version of Cabal in the build
08:14:31 <Saizan> since teh ghc package (the api) is linked against Cabal-1.5.5
08:14:49 <Saizan> but it will build haddock against the latest available Cabal, so 1.6.0.1
08:15:14 <Saizan> RayNbow: you can pass --constraint="Cabal == 1.5.5" to configure
08:15:28 <BMeph> Is there an HTTP that works with 6.10?
08:15:31 <Saizan> and so use 1.5.5 when compiling haddock too
08:15:52 <Saizan> BMeph: the latest on hackage works for me
08:16:55 <Saizan> hcube: also, withDefault Nothing (fmap Just $ single getSharedGeomething), so many variants :)
08:17:21 <RayNbow> hmm, Saizan... building haddock's all fine... but installing it gives an error...
08:17:27 <Saizan> ops, i flipped the arguments
08:17:28 * RayNbow is going to put it in a pastebin
08:17:52 <jrh> BMeph, Network.HTTP doesn't work with 6.10?
08:18:08 <hcube> Saizan, the previous was more clear for me
08:18:43 <RayNbow> Saizan: http://pastebin.ca/1227886
08:18:55 <BMeph> Saizan: I'll try it, but I remember it stopping on me earlier.
08:19:20 <Saizan> BMeph: it has been uploaded a few days ago
08:19:58 <BMeph> Is there a "cabal clean" that completely wipes all of Cabal out so you can re-compile and install it? :/
08:20:08 <Saizan> RayNbow: that's a build failure
08:20:29 <Saizan> define all of Cabal
08:20:30 <jrh> I'm having trouble with Gtk2hs on Windows that i'm not having on Linux.  Does anyone have experience using libglade and Cairo on Windows?
08:23:27 <RayNbow> hmm Saizan, it has a problem with this line: "instance Exception HaddockException"
08:23:39 <jrh> basically, the problem is that when I call runDialog on a dialog I've created in Glade, I get undecorated windows that I can't interact with.
08:24:57 <quicksilver> @where kuribas-indentation
08:24:57 <lambdabot> I know nothing about kuribas-indentation.
08:25:20 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
08:25:20 <lambdabot> Okay.
08:25:23 <jrh> I can click on the Ok and Cancel buttons, but none of the elements I add outside the Action Area allow me to touch them
08:25:57 <roconnor> @hoogle Char -> Char
08:25:58 <lambdabot> Data.Char toLower :: Char -> Char
08:25:58 <lambdabot> Data.Char toTitle :: Char -> Char
08:25:58 <lambdabot> Data.Char toUpper :: Char -> Char
08:26:30 <roconnor> > map toTitle ['A'..'z']
08:26:31 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ"
08:26:40 <Saizan> RayNbow: i think it'll work if you build with runghc Setup rather than the cabal executable
08:26:52 <roconnor> @src toTitle
08:26:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:27:00 <Saizan> RayNbow: esentially there's a bug in the .cabal file
08:27:09 <roconnor> @doc toTitle
08:27:10 <lambdabot> toTitle not available
08:27:21 <roconnor> @what toTitle
08:27:21 <lambdabot> I know nothing about totitle.
08:28:42 <jrh> The cairo problem gives me a "User error: bad matrix (not inverible)", which of course, in classic IO Exception fashion does not come with a more helpful message
08:29:36 <RayNbow> Saizan: then what exactly is the difference between the cabal executable and running Setup.lhs using runghc?
08:29:43 <RayNbow> (it worked btw, thx)
08:30:39 <BMeph> jrh: Obviously, your matrix isn't inverible...er, what? :P
08:31:10 <Saizan> RayNbow: the cabal executable tends to use base-3 when base-4 is not required, because a lot more packages build in this case
08:31:39 <dmwit_> BMeph: Yeah, too bad he didn't stick around a tad longer.  We might have been able to figure out what was wrong...
08:31:52 <Saizan> RayNbow: while Setup.lhs always tries to use the lastest version available of a package
08:31:56 <RayNbow> ah
08:39:59 <BMeph> jrh: Obviously, your matrix isn't inverible...er, what? :P
08:41:05 <jrh> BMeph: I think this refers to the base affine matrix, but I don't ever call translate or scale anywhere, so I don't know why this would be, unless there's some call for initialization I have to do in Windows that I don't have to do in Linux
08:41:28 <jrh> or....  if a width/height is a negative number, would that get the same error?  I'm not sure.
08:41:33 <jrh> Might ahve to check that
08:42:19 <cads> mmmm..
08:42:25 <cads> that's affine matrix..
08:42:31 <jrh> in any case, if I solve this and the dialog problem, then I have an annotator/viewer for images of unlimited size.
08:43:04 <jrh> cads: affine and *fully* invertible matrix...
08:46:55 <DuClare> Hm, was there a way to make a lambda function call itself?
08:47:40 <dmwit_> :t fix
08:47:41 <lambdabot> forall a. (a -> a) -> a
08:47:52 <dmwit_> as in
08:48:18 <dmwit_> > let fibs = fix (\f n -> if n < 2 then n else f (n-1) + f (n-2)) in map fibs [0..10]
08:48:19 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
08:48:47 <dmwit_> For better readability, s/f /fib /g
08:48:53 <quicksilver> alternatively
08:49:03 <quicksilver> name it with let ;)
08:49:07 <dmwit_> right =)
08:49:21 <quicksilver> but the short answer is "no, a lambda can't call itself, but fix lets you construct recursive terms"
08:49:24 <quicksilver> or something like that.
08:49:29 <quicksilver> you have to add a parameter to use fix
08:49:38 <quicksilver> (which is a placeholder for the recursion)
08:51:24 <ttt--_> > let f = fix f in f f
08:51:25 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
08:51:25 <lambdabot>      Proba...
08:52:43 <BeelsebobWork> > let f = id in f f 4
08:52:44 <lambdabot>   4
08:52:52 <BeelsebobWork> > let f = id in (f f) 4
08:52:53 <lambdabot>   4
08:52:58 <BeelsebobWork> blimeh
08:53:05 <BeelsebobWork> doesn't that need rank-2-polymorphism?
08:54:38 <quicksilver> let binds polymorphically
08:54:57 <quicksilver> lambdas and function apply impose monomorphism
08:55:02 <quicksilver> IIRC
08:55:15 <quicksilver> I get myself slightly confused by this occasionally.
08:56:36 <int-e> > let a :: Double; a = b; b = 1 in (b :: Int)
08:56:36 <lambdabot>   Couldn't match expected type `Int' against inferred type `Double'
08:56:47 <int-e> > let a :: Double; a = b; b :: (Num a) => a; b = 1 in (b :: Int)
08:56:48 <lambdabot>   1
08:57:08 <BeelsebobWork> interesting trick
08:57:27 <quicksilver> BeelsebobWork: "let f = id" is no different from id
08:57:30 <quicksilver> that's the point, i think
08:57:34 <quicksilver> you've just given it a new name
08:57:39 <BeelsebobWork> > let a :: Double; a = b; b :: (Num a) => a; b == 1 in (b :: Int, a)
08:57:40 <lambdabot>   <no location info>: parse error on input `in'
08:57:41 <int-e> quicksilver: the monomorphism restriction should apply in let. I'm a bit confused that BeelsebobWork's example works.
08:57:50 <quicksilver> (modulo the DMR, which is off in lambdabot)
08:57:54 <quicksilver> int-e: DMR turned off :)
08:57:57 <Saizan> no
08:58:00 <BeelsebobWork> it's not the MR that should be a problem
08:58:07 <Saizan> it's that MR applies only if there's a typeclass context
08:58:10 <BeelsebobWork> it's rank-2-polymorphism
08:58:18 <Saizan> id is just parametric polymorphism
08:58:25 <int-e> quicksilver: no it's not. if it were off, my first example would've compiled.
08:58:36 <quicksilver> yes, you're right, sorry, saizan has the real reason.
08:58:46 <quicksilver> DMR only applies to type class polymorphism
08:58:56 <quicksilver> I told you I get confused by this ;)
09:06:16 <int-e> glguy: the 'git clone' command line in  http://code.haskell.org/utf8-string/_darcs/prefs/motd  is wrong.
09:08:09 <cads> hrm
09:08:51 <cads> I am running a program which is trying to convert the largest mersenne prime into a hexadecimal notation
09:09:28 <cads> it's been running for about an hour
09:09:43 <dmwit_> It's a big number. =)
09:10:01 <cads> indeed, and the conversion is not trivial
09:11:00 <cads> I am guessing it would not be trivial to modify the big number engine to use a hex representation internally, either
09:12:29 <cads> the number itself takes less than 30 seconds to calculate, but the resulting conversion to decimal is doubtlessly not as well optimized a big multiplication
09:12:37 <cads> s/a/as
09:13:09 <dmwit_> ...and 2^n is an especially easy number to calculate. =)
09:14:03 <ziman> shouldn't a mersenne prime consist of all F's?
09:14:22 <ziman> except the first digit, maybe
09:14:41 <quicksilver> yes, a mersenne prime is {1,3,7,F}F*
09:14:43 <dmwit_> yep =)
09:15:04 <quicksilver> its decimal representation lacks that convenient expression ;)
09:16:12 <cads> oh no
09:18:04 <cads> well that answers the question which form of the mersenne prime will compress better...
09:18:18 <quicksilver> cads: it does, rather, doesn't it?
09:18:28 <quicksilver> cads: of course, there is a special form of compression for mersenne primes
09:18:41 <quicksilver> cads: store them as "2^n - 1"
09:18:44 <quicksilver> cads: and just store the 'n' ;)
09:18:47 <cads> right, much better than either hex or decimal
09:19:46 <dmwit_> I think you can even encode that in gzip.
09:20:16 <dmwit_> ...though it would probably be easiest in unary. =P
09:21:55 <cads> would that be equivalent to representing the full number in binary?
09:23:10 <dmwit_> cads: Not quite.
09:23:18 <cads> run length encoding?
09:23:20 <dmwit_> cads: In binary, you'd have n 1s.
09:23:27 <dmwit_> cads: In unary, you'd have 2^n-1 1s.
09:23:47 <dmwit_> Of course you could also do RLE for pretty good compression of the binary representation.
09:39:41 <byorgey> let's say I have a lazy ByteString which I want to lazily break into lines, and read the beginning of each line (up to whitespace) as a hexadecimal value, resulting in a lazy list of Integers.
09:39:45 <byorgey> what's the idiomatic way to do that?
09:42:45 <quicksilver> much as you would naively expect.
09:42:50 <daf> something like map (fst . head . readHex) (lines s)
09:42:51 <quicksilver> lazy bytestring has a lazy 'lines'
09:42:52 <Nafai> Hey byorgey!
09:43:02 <quicksilver> over which you can lazily 'map' something of your choice
09:43:03 <byorgey> quicksilver: oh, does it? I hadn't found that function.
09:43:08 <quicksilver> it's just called 'lines'
09:43:18 <quicksilver> you need the Char8 version.
09:43:24 <byorgey> aha!
09:43:29 <quicksilver> (Bytes don't have lines! Bytes don't know what a linebreak is!)
09:44:11 <byorgey> ok, this is the key peice of information I hadn't figured out yet. =)
09:44:14 <byorgey> quicksilver++
09:44:20 <byorgey> hi Nafai!
09:44:46 <daf> byorgey: my version doesn't handle lines that don't parse though
09:45:40 <byorgey> daf: that's ok, I know all the lines will parse
09:45:53 <byorgey> it's a data file I've been given
09:46:02 <daf> nod
09:46:24 <byorgey> hm, ByteString doesn't have a readHex function though, does it?
09:46:41 <daf> true
09:47:22 <byorgey> so I have to use readHex . unpack?  or is there a better way that doesn't involve unpacking?
09:47:58 <daf> not sure
09:48:15 <daf> a ByteString-native readHex might be quicker
09:48:30 <daf> but I suggest using (. unpack) and profiling if it's too slow :)
09:48:44 <byorgey> sounds like a good plan =)
09:49:01 <byorgey> daf++
09:49:19 <quicksilver> lazily unpacking short lines is not terribly inefficient
09:49:26 <quicksilver> because a short line fits entirely in the cache
09:49:42 <quicksilver> and so, hopefully, does its unpack version which in any case you consume immediately and it gets GCed
09:50:05 <quicksilver> I mean, in conclusion, it might be nicer to have a native one but the unpack version shoudlnt' be too bad
09:50:15 <daf> quicksilver: makes sense
09:51:34 <ttt--_> how can i make this one from the normal find function? findM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a)
09:52:03 <quicksilver> ttt--_: you can't.
09:52:17 <quicksilver> ttt--_: "monadification" is a deep change which you can't make externally to a pure function.
09:52:24 <quicksilver> this has been discussed from time to time.
09:52:44 <ttt--_> ok thanks
09:52:57 <quicksilver> for example, monadic functions are sensitive to how often they are called in a way that pure functions are not.
09:53:24 <quicksilver> so therefore a change to a pure algorithm which doesn't affect the result may be a much larger change to a monadic one ;)
09:53:36 <quicksilver> consider different sorts and how often they call the comparison function.
09:53:54 <quicksilver> ttt--_: still, I think if you google for 'monadification' you will find a fair amount.
09:54:03 <quicksilver> greater minds than mine have analysed this problem :)
09:54:26 <quicksilver> of course you can go in the other direction, just by using the Identity monad
09:54:28 <ttt--_> i will try that
09:56:19 <lilac> ttt--_: I suspect you can build it out of filterM and First
09:58:46 <lilac> incidentally, why is First not a monad?
10:00:33 <Apocalisp> What's First?
10:01:35 <lilac> @type First
10:01:36 <lambdabot> forall a. Maybe a -> First a
10:13:12 <Guest17243> Hello !  Anyone feel like helping me out with using a helper function alongside my recursive solution to a problem ?
10:14:09 <vixey> that sounds sensible
10:14:13 <Apocalisp> Guest17243: What do you have so far?
10:14:28 <Guest17243> http://pastebin.com/m226ba8ce
10:14:30 <Guest17243> It currently works fine.
10:14:41 <Guest17243> To make it work, you input the number to be checked and 2.
10:14:47 <Guest17243> Works pretty simply.
10:14:57 <vixey> I don't like
10:14:58 <vixey> isPrime :: Int -> Int -> Bool
10:15:00 <Guest17243> But the only problem is that the specification of the solution is that the function takes only 1 argument.
10:15:03 <Guest17243> Yeah exactly.
10:15:06 <vixey> I would either remove that line completely
10:15:07 <Guest17243> That is what I am looking to change.
10:15:09 <vixey> or change Int to Integer
10:15:20 <Guest17243> Why ?
10:15:28 <vixey> Int has some artifical limit
10:15:30 <vixey> Integer doesn't
10:15:31 <Guest17243> I would have to change to : Int -> Bool
10:15:37 <vixey> Integer -> Bool
10:15:40 <Guest17243> That is part of the problem specification.
10:15:41 <lilac> Guest17243: you can rename isPrime to isPrime', and add isPrime n = isPrime' n 2
10:15:52 <Guest17243> If I don't do it like that then the program that checks my script will fail.
10:16:17 <lilac> it's conventional for isPrime' to be defined in a where clause inside isPrime, in such cases
10:16:38 <Guest17243> Mmmmm lemme try that one out.  The problem I am having is to make it input the 2 on the first time only.
10:16:52 <Guest17243> And not otherwise.  It's proving a bit trickier than I thought cause of the recursive nature of the function.
10:17:06 <vixey> foo = foo' x 2
10:17:11 <Guest17243> But I'm sure I'm just thinking about it wrong and there is a simple solution.  I'm more used to imperative languages :p
10:17:11 <vixey>  where foo' = bar
10:18:03 <Guest17243> Ohhhhh
10:18:15 <Guest17243> I just re-read what you wrote lilac.  Sounds like a perfect solution.
10:18:23 <Guest17243> Sort of making a wrapper for the real function.
10:18:38 <Zao> Recursion bootstrap.
10:18:46 <Guest17243> Yo what ?
10:20:38 <Guest17243> Aha works flawlessly.
10:20:44 <Guest17243> Thanks lilac + vixey
10:27:02 <dblazakis> Are there any guides to reading Core?
10:27:31 <Botje_> squint.
10:27:58 <dblazakis> Botje_: :-)
10:28:22 <dblazakis> so, case blah of foo { ... }, foo is bound to the result of evaluating blah?
10:28:55 <Botje_> yeah
10:29:02 <Botje_> case forces evaluation to WHNF
10:29:25 <dblazakis> ok, just making sure foo was the result of that transform
11:13:19 <aFlag> hi, does anyone know about efforts of porting apache lucene to haskell? (or the development of any other indexing library?)
11:16:36 <nicknull> c+python+haskell = ubercombo
11:16:41 <nicknull> it seems
11:17:37 <nicknull> anyone on a huge project in haskell? like something game-changing hat could make people very interested in haskell if it succeeds?
11:19:00 <vixey> nicknull: Sounds great other than the c and python
11:19:14 <dolio> Boom!
11:21:58 <lilac> nicknull: i think STM is pretty game-changing
11:22:39 <dolio> The nested data parallelism people are working on seems interesting in a similar way.
11:23:17 <nicknull> stm is old.
11:23:30 <nicknull> and only academiaclly successful so far right?
11:23:43 <vixey> yeah nobody is ever going to use STM in real programming
11:23:55 <nicknull> still that's not a product, its more of a  par tof haskell
11:24:09 <nicknull> i was thinking more of some big cool app written in haskel
11:24:22 <opqdonut> darcs?-)
11:24:25 <int-e> nicknull: that goes against the motto of avoiding success at all cost
11:24:30 <nicknull> like if google revealed "oh yeah pagerank and allthat u know, just haskell"
11:24:45 <nicknull> int-e: im afraid so
11:24:56 <njbartlett> nicknull: Google does use Haskell, but being Google they won't talk about what they're using it for
11:26:10 <sjanssen> vixey: why do you say that about STM?
11:26:10 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
11:27:57 <nicknull> njbartlett: eh where did yiu hear that? i thought you got sot for using anything but javam
11:28:07 <nicknull> java , c++, javascript and python
11:28:34 <nicknull> u work there?
11:28:44 <njbartlett> nicknull: I heard it from somebody writing code in Haskell at Google. No I don't work there myself.
11:29:01 <njbartlett> nicknull: But as I said, there's no way to get the details so it's not much use
11:29:27 <nicknull> ok
11:30:13 <nicknull> i guess they must be experimenting with othe rlanguages . and since huge-scale parallellism is their game haskell should be interesting
11:32:50 <dolio> Haskell doesn't really have the infrastructure for large-scale distributed systems, though, which probably restricts things somewhat for them.
11:33:09 <dolio> Unless they're secretly resurrecting the experiments people did with that sort of thing in the 90s.
11:34:39 <mornfall> STM might be quite interesting in practice.
11:36:09 <sjanssen> I've used it in a shipping (open source, non-commercial) application
11:36:44 <mornfall> It's really a lot better model than explict locking.
11:37:41 <mornfall> At least unless you get down to implementing performance-critical primitives. Which it doesn't seem to work for. But the normal-level code, I guess it'd be fine. I just haven't done anything parallel in haskell for real yet.
11:39:13 <nicknull> ok
11:39:40 <nicknull> dolio: you mean what is lacking is a runtime like Erlang VM
11:40:04 <dolio> Erlang is the go-to language with good support for that kind of thing, yes.
11:40:44 <dolio> I mean, C++ probably wasn't good for that sort of thing when they started, but then they wrote their own solution.
11:41:19 <dolio> I'm just saying they'd have to do it again for Haskell.
11:43:22 <nicknull> ok
11:44:11 <dolio> And like I said, people have experimented with distributed runtimes for Haskell, but they're dead and not incorporated into GHC now.
11:44:32 <vixey> what is Sym short for?
11:44:44 <vixey> like Var Sy
11:44:45 <vixey> like Var Sym
11:47:28 <sjanssen> vixey: symbol?
11:47:41 <vixey> thanks
11:52:31 <njbartlett> The nice thing about Erlang is the shared-nothing + messaging approach to concurrency on one box transparently to multiple boxes. Haskell STM is probably the best model available for shared memory concurrency, but you need a different model for distributed computing
11:56:30 <dblazakis> aFlag: do you mean something like http://holumbus.fh-wedel.de/
11:56:35 <lambdabot> Title: Holumbus
12:12:32 <ArneB> @pl \ a b -> product $ 5 : (take 5 $ zipWith (*) [a,b..] [a,a*b..])
12:12:34 <lambdabot> ((foldl (*) 5 . take 5) .) . ap (ap . (zipWith (*) .) . enumFromThen) (liftM2 (.) enumFromThen (*))
12:13:46 <sheyll_> hi!
12:14:00 <vixey> hiya
12:14:12 <Vq^> 'lo
12:15:34 <jrh> aFlag: How mature is Holumbus?
12:20:25 <vixey> for some weard reason I keep typing  xs : x
12:20:30 <vixey> and getting type errors
12:20:42 <vixey> I should really know by now that the head comes before the tail..
12:23:05 <dolio> You've been brainwashed by the snoc list illuminati.
12:23:11 <vixey> oh no!
12:23:45 <vixey> hmmmm
12:23:55 <vixey> maybe I should try it out for a while and see if it's better or worse
12:24:04 <dblazakis> It's just a matter of view
12:24:56 <int-e> :t Data.Sequence.viewL
12:24:58 <lambdabot> Not in scope: `Data.Sequence.viewL'
12:25:02 <vixey> ah!
12:25:12 <int-e> :t Data.Sequence.viewl
12:25:13 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.ViewL a
12:25:25 <vixey> my HOAS problem has crystalized down into a single unwriteable function
12:25:32 <int-e> yay!
12:26:01 <int-e> @quote impossible
12:26:02 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
12:26:20 <dolio> Heh.
12:26:22 <int-e> @quote impossible
12:26:22 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
12:26:27 <int-e> better.
12:27:02 <younder> perl simply states that you have lost yourmarbles ;)
12:27:11 <mmorrow> vixey: ooh, what is this mysterious function?
12:27:38 <vixey> hmmm
12:29:45 <vixey> mmorrow: I can't figure out how to write it in haskell syntax :/
12:29:55 <mmorrow> heh, can you describe it to me?
12:29:59 <vixey> s/syntax/type system/
12:30:08 <mmorrow> like, what would it do?
12:32:13 <vixey> if we used [a,b,c,...] as syntax for (a,(b,(c,...)))
12:32:16 <vixey> it's like ([e,p,q,b,d,...] -> Maybe x) -> ([p,q,b,d,...] -> Maybe (e -> x))
12:32:50 <vixey> :D
12:32:55 <mmorrow> hmm
12:34:13 <mmorrow> what's the way of constructing the (e -> x) you have in mind?
12:34:42 <mmorrow> in words/whatever
12:34:45 <dolio> That's, what, lambda abstraction?
12:35:00 <vixey> so like
12:35:01 <dolio> With environment [e,p,q,b,d,...]?
12:35:05 <mmorrow> hmm
12:35:18 <sheyll> hi
12:35:38 <sheyll> huh: Deprecated use of `findSubstring'?? What else shall I use?
12:35:47 <mmorrow> ohhh, wait i read that sig wrong
12:35:48 <vixey> \fooify context -> ~~~> Maybe (\proofOfE -> fooify (proofOfE,context))
12:35:50 <vixey> &
12:35:54 <vixey> \fooify context -> ~~~> Nothing
12:36:08 <vixey> ~~~> denotes different branches of a case/pattern match
12:36:21 <vixey> sheyll: what about isInfixOf
12:36:32 <sheyll> vixey: thanx!
12:36:33 <vixey> actually that probably doesn't do the same thing
12:36:47 <sheyll> uhm ... no?
12:37:02 <sheyll> :t isInfixOf
12:37:03 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
12:37:14 <sheyll> ah ok
12:37:20 <vixey> I need like omnipotence inside lambda calculus
12:37:34 <vixey> clairvoyant pattern matching could be useful
12:37:49 <mmorrow> ah yes, that would be a delight
12:37:50 <vixey> foo
12:37:58 <vixey> It's really really impossible isn't it :)
12:38:37 <mmorrow> well you could write that function in a metalang
12:38:54 <vixey> "never metalang I didn't like"
12:38:58 <mmorrow> eg template-haskell
12:39:15 <mmorrow> well, that's the same lang i guess, but at a different stage/level
12:39:34 <mauke> mmorrow: ((a, b) -> Maybe x) -> b -> Maybe (a -> x)
12:39:47 <vixey> ?djinn ((a, b) -> Maybe x) -> b -> Maybe (a -> x)
12:39:48 <lambdabot> f _ _ = Nothing
12:39:50 <vixey> lol
12:39:56 <vixey> yeah.......
12:40:52 <yitz> vixey: you get e -> Maybe x. The only way to lift that would be to do some kind of sum over all elements of e.
12:41:08 <vixey> that /may/ be possible
12:41:47 <yitz> e.g., if f x is Just for all x, then Just f, else Nothing.
12:43:40 <int-e> deja vu.
12:44:23 <yitz> or choose a default value for all the Nothings, and use Just $ maybe default id . f
12:45:34 <yitz> that actually sounds a bit more tame.
12:46:27 <yitz> but not all that much better than what djinn came up with :)
12:48:19 <Deewiant> What's a good way of dealing with tests in a Hackage package? Have a separate .cabal file for the tests? Have a readme containing the dependencies for users who want to run tests?
12:48:38 <mmorrow> vixey: under what conditions would the Maybe (e -> x) be Nothing?
12:49:13 <vixey> so... um
12:49:29 <vixey> I kind of mashed the thing out of coherence by changing it into haskell syntax
12:49:47 <thoughtpolice> Deewiant: the cabal api is somewhat in flux but lots of times i just hook the 'test' command to e.g. just invoke 'runghc tests/Tests.hs' or whatever
12:50:07 <vixey> it is a property that I could figure out beforehand
12:50:19 <thoughtpolice> or you can just include a .sh file in ./ that runs tests for you; there are lots of options really
12:50:21 <Deewiant> thoughtpolice: but my tests have additional dependencies which I obviously don't want the package itself to depend on
12:50:33 <Deewiant> really, the question is about how to specify deps for the tests
12:50:35 <thoughtpolice> Deewiant: what's that?
12:50:41 <mmorrow> so you're really not considering /values/ of types a,b,x but the types themselves then?
12:50:56 <vixey> the values matter too
12:50:57 <Deewiant> thoughtpolice: e.g. I don't want QuickCheck or HUnit to be dependencies of the package itself
12:51:11 <vixey> they aren't as important though
12:51:36 <mmorrow> vixey: does whether Maybe (e -> x) is Nothing depend only on the type e?
12:51:51 <thoughtpolice> Deewiant: fair enough - you'll just have to put a notice in saying that you need hunit/quickcheck etc. i guess
12:52:18 <vixey> only depends on the value of x actually
12:52:24 <mmorrow> hmm
12:52:30 <vixey> it's just that I can't produce the Maybe x without having that 'e' first
12:52:47 <vixey> the value of the e doesn't matter though (that's why I can calculate if it will return Nothing or Maybe without calling it)
12:52:47 <Deewiant> thoughtpolice: yeah, but I'm thinking is it worth it to make a separate .cabal file for the tests or not
12:53:29 <vixey> I guess I could compute an execution trace of the algorithm actually .. and then write a function that threads /real/ data through the dress rehersal
12:54:49 <vixey> kind of bizarre to program in that fashion though
12:55:37 <zloog_> Hi,
12:55:45 <vixey> hi
12:56:21 <zloog_> In ghci I'm trying to find where the function "ell" is defined. is there a colon command I can use for that?
12:56:31 <vixey>  does :info do it?
12:56:44 <zloog_> I dont think so
12:56:56 <mib_rsdzfr> >splitAt 5 [1,2,3,4,4,5,5,6]
12:56:57 <zloog_> well
12:57:01 <mib_rsdzfr> > splitAt 5 [1,2,3,4,4,5,5,6]
12:57:02 <lambdabot>   ([1,2,3,4,4],[5,5,6])
12:57:02 <zloog_> apparently it does do that
12:57:03 <zloog_> thanks
12:57:07 <vixey> k
12:57:47 <mib_rsdzfr> how do i make the splitAt, split at every 5 elements ?
12:57:57 <vixey> mib_rsdzfr: you want chunk!
12:58:00 <vixey> chunks
12:58:05 <vixey> ?where chunks
12:58:06 <lambdabot> I know nothing about chunks.
12:58:07 <mib_rsdzfr> yes
12:58:18 <vixey> where is the huge collection of every chunk code with timings?
12:58:23 <vixey> ...
12:58:25 <vixey> @quote chunks
12:58:25 <lambdabot> No quotes match. You untyped fool!
12:58:26 <mib_rsdzfr> splitAt 5
12:58:29 <vixey> @quote chunk
12:58:29 <lambdabot> chunk says: \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
12:58:37 <vixey> there's way more ways to do it than that
12:58:45 <Apocalisp> :type partition
12:58:45 <Apocalisp> @type partition
12:58:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:59:08 <Apocalisp> no, not that
12:59:11 <vixey> haha
12:59:14 <vixey> @go "Quest for Chunks"
12:59:17 <lambdabot> No Result Found.
12:59:21 <vixey> aww
12:59:27 <mib_rsdzfr> show me the other way vixey
12:59:46 <vixey> my favorite way is:
12:59:47 <vixey> chunk n list = case list of { [] -> [] ; (y:ys) -> ch' ys (n-1) (y:) } where
12:59:47 <vixey>  ch' [] _ k = k [] : []
12:59:47 <vixey>  ch' (y:ys) 0 k = k [] : ch' ys (n-1) (y:)
12:59:47 <vixey>  ch' (y:ys) (c+1) k = ch' ys c (k . (y:))
13:00:12 <mib_rsdzfr> 2 long man
13:00:57 <yitz> > let repeatM = sequence . repeat in takeWhile (not . null) . evalState . repeatM (splitAt 5) $ [1..20]
13:00:58 <lambdabot>   Couldn't match expected type `State s a'
13:01:00 <Apocalisp> > zipWith ($) (repeat (take 5)) [0..]
13:01:01 <lambdabot>       No instance for (Enum [a])
13:01:01 <lambdabot>        arising from the arithmetic sequence ...
13:01:12 <yitz> > let repeatM = sequence . repeat in takeWhile (not . null) . evalState . repeatM (State $ splitAt 5) $ [1..20]
13:01:13 <lambdabot>   Couldn't match expected type `(->) a'
13:01:59 <rwbarton> @src forever
13:01:59 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:02:18 <yitz> > let repeatM = sequence . repeat in takeWhile (not . null) . evalState (repeatM . State . splitAt $ 5) $ [1..20]
13:02:19 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
13:02:22 <mmorrow> @type :t (\f b -> const `fmap` f (undefined::a,b)) :: ((a,b) -> Maybe x) -> (b -> Maybe (a -> x))
13:02:24 <lambdabot> parse error on input `:'
13:02:28 <mmorrow> @type (\f b -> const `fmap` f (undefined::a,b)) :: ((a,b) -> Maybe x) -> (b -> Maybe (a -> x))
13:02:29 <lambdabot> forall a b x. ((a, b) -> Maybe x) -> b -> Maybe (a -> x)
13:02:33 <vixey> o_O
13:02:37 <vixey> not possible
13:02:41 <vixey> oh you used undefined!
13:02:46 <mmorrow> yay
13:02:57 <vixey> :t undefined :: ((a,b) -> Maybe x) -> (b -> Maybe (a -> x))
13:02:59 <lambdabot> forall a b x. ((a, b) -> Maybe x) -> b -> Maybe (a -> x)
13:03:00 <vixey> two can play at that :P
13:03:04 <mmorrow> haha
13:03:10 <mib_rsdzfr> guys, something simple, that a n00b can comprehend
13:03:10 <shepheb> new \bot plugin idea: randomly generated Shakespearean insults based on http://www.pangloss.com/seidel/shake_rule.html
13:03:11 <lambdabot> Title: Shakespeare Insult Kit
13:03:21 <younder> maybe undefined?
13:03:41 <vixey> mib_rsdzfr: Wait, you didn't understand:  \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
13:03:41 <vixey>   ?
13:03:54 <yitz> mib_rsdzfr: right, sorry. just one of my old favorite tricks, couldn't resist. :)
13:04:07 <mib_rsdzfr> i do, but i don't think my friends will
13:04:22 <vixey> mib_rsdzfr: You should definitely help them understand it then
13:04:26 <mib_rsdzfr> gonna show them and they haven't learnt those
13:04:43 <yitz> mib_rsdzfr: or define it directly using recursion, I suppose.
13:04:47 <dabblego> now is a good time then
13:06:30 <extasic> hi
13:06:57 <mmorrow> vixey: didn't you say though that whether Maybe (a -> x) is Nothing depends only on the value of x? so, the value of a is unimportant and it's only needed for its type?
13:07:03 <Apocalisp> what prelude function is the anamorphism for [] ?
13:07:25 <extasic> I'm a desperate student who needs some help with a Haskell excercise
13:07:28 <mmorrow> , typeOf (undefined::Int)
13:07:29 <mauke> unfoldr?
13:07:32 <dabblego> unfoldr
13:07:33 <lunabot>  Int
13:07:36 <Apocalisp> @type unfoldr
13:07:38 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:07:49 <mauke> hi, extasic
13:07:57 <mmorrow> , typeOf (undefined::([Maybe (() -> [Int])],Double))
13:07:59 <lunabot>  ([Maybe (() -> [Int])],Double)
13:08:18 <extasic> hi mauke
13:08:19 <mib_rsdzfr> hi think the recursive form would be better
13:08:40 * sjanssen hates GHC's optimizer
13:08:41 <mmorrow> @type (\f b -> const `fmap` f (typeOf(undefined::a),b)) :: ((a,b) -> Maybe x) -> (b -> Maybe (TypeRep -> x))
13:08:43 <lambdabot>     Couldn't match expected type `a' against inferred type `TypeRep'
13:08:43 <lambdabot>       `a' is a rigid type variable bound by
13:08:43 <lambdabot>           the polymorphic type
13:09:28 <mmorrow> err, i didn't mean that
13:09:43 <[Rory]> hi
13:10:02 <vixey> trying to prove that the function doesn't exist
13:10:20 <vixey> mmorrow yes
13:10:30 <extasic> you maybe know the picture class used in "the" book (http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/Code/Pictures.hs). I know need to create a function "diagonal :: -> Int -> Picture " that creates a white square with the line size that is given by the argument. But additionally there should be a diagonal line from the top left corner to the bottom right. no "help" function is allowed, just one recursive function. any ideas?
13:10:37 <lambdabot> http://tinyurl.com/44uppt
13:10:42 <mib_rsdzfr> > zipWith ($) (repeat (take 5)) [0..]
13:10:44 <lambdabot>       No instance for (Enum [a])
13:10:44 <lambdabot>        arising from the arithmetic sequence ...
13:11:05 <mib_rsdzfr> why is that not wrking?
13:11:10 <mib_rsdzfr> > zipWith ($) (repeat (take 5)) [0..]
13:11:11 <lambdabot>       No instance for (Enum [a])
13:11:11 <lambdabot>        arising from the arithmetic sequence ...
13:11:19 <vixey> mib_rsdzfr: type errors
13:11:32 <vixey> :t iterate . (take 5 .)
13:11:33 <lambdabot> forall a. ([a] -> [a]) -> [a] -> [[a]]
13:11:42 <mib_rsdzfr> k
13:11:47 <mauke> mib_rsdzfr: because take 5 0 is a type error
13:11:57 <mib_rsdzfr> o
13:12:08 <vixey> :t (iterate (drop 5))
13:12:14 <vixey> that
13:12:20 <lambdabot> forall a. [a] -> [[a]]
13:12:37 <mib_5lswm0> hey
13:12:37 <vixey> :t zipWith ((take 5) . $)
13:12:38 <lambdabot> parse error on input `$'
13:13:20 <vixey> you can actually use /nick <foo> to choose a nickname
13:13:31 <extasic> anybody there who can help me a bit?
13:13:45 <mib_5lswm0> im a beginner at heskell and functional programming i was wondering if anyone could help me
13:13:48 <vixey> mib_*!*@*
13:13:50 <vixey> heh
13:13:53 <mib_5lswm0> o
13:14:14 * sjanssen wonders if all these people are in the same class :)
13:14:19 <Not_mibbit> ahaha
13:14:31 <mib_rsdzfr> k
13:15:41 <mib_rsdzfr> http://mibbit.com/pb/hSmhY5
13:15:42 <lambdabot> Title: Mibbit: PasteBin
13:15:53 <mib_rsdzfr> this is the code i am working on
13:15:58 <sjanssen> extasic: so what have you figured out so far?
13:16:11 <mib_rsdzfr> i can't seem to get the numbers int he right rows
13:16:22 <mib_rsdzfr> i want 5 rows, mon - fri
13:16:42 <mib_rsdzfr> and a heading week (1-5)
13:16:43 <mib_rsdzfr> any help
13:16:44 <mib_rsdzfr> ??
13:17:26 <extasic> sjanssen, I really don't know how to start. I thought about the direction how to build the picture (top to bottom or left to right), but I don't have any idea without using a helper function that gets an additional parameter
13:17:37 <vixey> mmorrow: so simplified it down further,
13:17:37 <vixey> (a -> Maybe x) -> Maybe (a -> x)
13:17:51 <mmorrow> hmm, ok
13:17:52 <mib_rsdzfr> vixey u saw the code?
13:17:56 <vixey> LEM let me implement it
13:18:33 <extasic> sjanssen, what I forget - we had to implement another fucntion first that sets a given amount of pictures above each other, picCol, so picCol 5 myPicture creates a line of 5 myPictures above each other
13:18:43 <extasic> maybe that is useful..
13:19:13 <sjanssen> extasic: I think so
13:20:00 <dabblego> @seen cdsmith
13:20:04 <extasic> but I don't know how to set the position of the "black" one without using another parameter
13:20:04 <lambdabot> I haven't seen cdsmith.
13:20:13 <extasic> so how does the recursion know where to put it inside the line
13:20:26 <Apocalisp> @let chunk n xs = let f [] = Nothing; f ys = return (splitAt n ys) in unfoldr f xs
13:20:28 <lambdabot>  Couldn't match expected type `[t] -> [[t]]'
13:20:43 <dabblego> "What to Know Before Debating Type Systems" has vanished, shame
13:20:55 <vixey> eh I didn't like it
13:21:28 <vixey> too much observing stuff, not enough _Definitions_
13:22:22 <sjanssen> extasic: have you learned replicate, foldr, or foldl yet?
13:22:59 <extasic> no
13:23:15 <extasic> we only had three hours
13:23:30 <extasic> and the given functions
13:23:50 <extasic> we have to (just) combine them to get the diagnola line
13:23:56 <extasic> *diagonal
13:25:50 <yitz> > map (take 5) . takeWhile (not . null) . iterate (drop 5) $ [1..20]
13:25:51 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
13:26:08 <Apocalisp> > let chunk n xs = let f [] = Nothing; f ys = return (splitAt n ys) in unfoldr f xs in chunk 5 [0..100]
13:26:09 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]...
13:26:22 <roconnor> @src maximum
13:26:22 <lambdabot> maximum [] = undefined
13:26:22 <lambdabot> maximum xs = foldl1 max xs
13:27:02 <yitz> roconnor: grr.  needs to be foldl1'. common bug in Data.List.
13:28:55 <extasic> sjanssen, I do know I have to use that picCol to reproduce and flipD to rotate it
13:29:08 <extasic> but I still can't get how to set that black one inside the others
13:29:13 <extasic> with just using recursion
13:30:13 <rwbarton> extasic: do you have functions to make white rectangles?  and glue pictures horizontally and vertically?
13:30:29 <sjanssen> extasic: what is flipD?
13:31:28 <Apocalisp> > takeWhile (not . null) $ unfoldr (return . (splitAt 5)) [0..100]
13:31:29 <lambdabot>   [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24]...
13:31:37 <Apocalisp> There! Birdie.
13:33:09 <Apocalisp> pl@ \n xs -> takeWhile (not . null) $ unfoldr (return . (splitAt n)) xs
13:33:15 <Apocalisp> @pl \n xs -> takeWhile (not . null) $ unfoldr (return . (splitAt n)) xs
13:33:16 <lambdabot> (takeWhile (not . null) .) . unfoldr . (return .) . splitAt
13:33:55 <extasic> sjanssen: flipD mirrors the picture diagonally
13:34:01 <jrh> if I use #peek and #poke in hsc2hs to generate field accessors to fields whose names begin with initial capitals, what happens?
13:34:02 <extasic> the complete code I'm using is here: http://nopaste.info/5d772be222.html
13:34:17 <yitz> @pl \n -> map (take 5) . takeWhile (not . null) . iterate (drop 5)
13:34:17 <lambdabot> const (map (take 5) . takeWhile (not . null) . iterate (drop 5))
13:34:18 <Apocalisp> @let chunk = (takeWhile (not . null) .) . unfoldr . (return .) . splitAt
13:34:18 <lambdabot>  <local>:1:0:
13:34:18 <lambdabot>      Equations for `chunk' have different numbers of arguments
13:34:18 <lambdabot> ...
13:34:27 <yitz> @pl \n -> map (take n) . takeWhile (not . null) . iterate (drop n)
13:34:27 <lambdabot> ap ((.) . map . take) ((takeWhile (not . null) .) . iterate . drop)
13:34:35 <roconnor> @type on
13:34:36 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:34:42 <sjanssen> extasic: ah, flipD will be useful here
13:34:56 <gwern> @seen dcoutts_
13:34:57 <lambdabot> dcoutts_ is in #haskell, #ghc, #gentoo-haskell and #haskell-overflow. I don't know when dcoutts_ last spoke.
13:34:58 <Peaker> I think takeWhile f . iterate g   is so common that it deserves a name?  iterateWhile ?
13:35:02 <gwern> @seen dcoutts
13:35:02 <lambdabot> dcoutts is in #ghc, #haskell, #gentoo-haskell and #haskell-soc. I last heard dcoutts speak 3h 31m 11s ago.
13:35:07 <sjanssen> extasic: try to think of your picture as several parts that you'll finally superimpose to create a single picture
13:35:25 <mauke> lol german
13:35:41 <Apocalisp> > chunk 5 [1..20]
13:35:42 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
13:35:46 <Apocalisp> wo0t
13:36:07 <gwern> @ask dcoutts Out of curiosity, why does cabal complain if a license-file isn't provided? it seems more than a little redundant (why should I have 900/8 megs of different but nigh identical license text files).
13:36:07 <lambdabot> Consider it noted.
13:36:18 <extasic> sjanssen: hmm, sounds logical.. but I still don't know how to set that black one without using another parameter
13:37:30 <younder> Is there a good paper on setting up GHCi and GHC to run under emacs in Windows?
13:37:35 <mauke> f = [....] + '#' + [....] + f'
13:37:49 <younder> My sulotion seems hacked and akward.
13:38:26 <gwern> younder: haskell-mode doesn't work in windows emacs?
13:38:42 <rwbarton> extasic: Don't think in terms of "setting", but rather in terms of building your picture out of pieces
13:38:52 <roconnor> @type flip compare
13:38:53 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:39:11 <roconnor> @type comparing
13:39:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:39:22 <rwbarton> extasic: If you want a single black square, that's just ["#"]
13:39:46 <extasic> I know how to generate a black block ;)
13:39:50 <younder> gwern: no
13:39:59 <gwern> that's too bad
13:40:04 <yitz> younder: it ought to be a wiki page. if it isn't - please put up your results  once you figure out what to do. or your awkward hack, if you don't figure out anything better.
13:40:05 <extasic> I'm not allowed to define it that way - I have to use "invertColour white"
13:40:17 <sheyll> is that correct? {-# GHC_OPTIONS -XOverloadStrings #-}
13:40:29 <vixey> sheyll: shouldn't you use LANGUAGE instead?
13:40:30 <extasic> my problem is that I don't understand how to move that block vertically
13:40:40 <extasic> and I just ran out of coffee
13:40:53 <sjanssen> extasic: a box outline is just 4 lines around a white box, right?
13:40:57 <rwbarton> extasic: can you show us the output you want?
13:41:01 <sheyll> vixey, I don't know, I'll look it up
13:41:16 <sjanssen> extasic: and you know how to make a white box
13:41:52 <sjanssen> extasic: you also know how to make the lines that will go on the left and right sides of the white box
13:42:01 <sjanssen> (they're just columns)
13:42:11 * gwern noodles around happily with Dillo 2. I'd forgotten how much fun a really fast web browser could be
13:42:31 <sjanssen> extasic: do you have a function that can convert those columns into rows?
13:43:38 <extasic> well, I could flip them
13:43:43 <sjanssen> right
13:43:45 <extasic> but the picCol produces rows
13:43:49 <extasic> not columns
13:43:55 <extasic> ( I didn't name it that way ;))
13:43:56 <sjanssen> oh, same result anyway
13:44:19 <extasic> http://nopaste.info/ca6e9dfec7.html
13:44:29 <extasic> this is the output for the value "5"
13:44:38 <sheyll> ok ... found it in the ghc docs: correct way would be {-# LANGUAGE OverloadedStrings #-}
13:44:39 <extasic> a square with a diagonal line
13:44:47 <sheyll> thanks
13:45:45 <rwbarton> extasic: OK.  So inside there, you can see the output for the value 4, right?
13:47:59 <extasic> rwbarton: hmm?
13:48:23 <gwern> incidentally, has anyone played with MagicHaskeller http://nautilus.cs.miyazaki-u.ac.jp/~skata/MagicHaskeller.html before? seems to be a haskell program to write haskell functions based on examples and types
13:48:35 <lambdabot> Title: MagicHaskeller: A Search-based Inductive Functional Programming System
13:48:37 <rwbarton> extasic: can you divide that image into pieces, in such a way that one of the pieces is the output for the value 4?
13:48:55 <roconnor> @hoogle on
13:48:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:48:55 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
13:48:55 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
13:52:28 <extasic> rwbarton: aah, I got what you meant. hmm, I have to try it
13:55:30 <chrisdone> ping
13:55:57 <gwern> 'a character in Megatokyo'
14:02:26 <mib_rsdzfr> unfoldr is not in my hugs :(
14:03:02 <gwern> unfold'r? I hope you'll do more than that to her
14:03:11 <gwern> (har har)
14:03:27 <mib_rsdzfr> Apocalisp
14:03:31 <mauke> @index unfoldr
14:03:31 <lambdabot> Data.List
14:03:37 <mauke> :also Data.List
14:03:45 <mib_rsdzfr> trying to run this
14:03:49 <mib_rsdzfr> takeWhile (not . null) $ foldr (return . (splitAt 5)) [0..100]
14:03:54 <mib_rsdzfr> > takeWhile (not . null) $ foldr (return . (splitAt 5)) [0..100]
14:03:55 <lambdabot>   Couldn't match expected type `([a], [a])'
14:04:20 <Apocalisp> mib_rsdzfr: Yes?
14:04:30 <Apocalisp> import List
14:04:45 <Apocalisp> Oh, I don't know about hugs.
14:05:15 <Apocalisp> @src unfoldr
14:05:16 <lambdabot> unfoldr f b  = case f b of
14:05:16 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
14:05:16 <lambdabot>    Nothing        -> []
14:07:05 <Apocalisp> mib_rsdzfr: foldr is the opposite of unfoldr
14:07:09 <sheyll> I would like to combine the list and the IO monad, how would I do this?
14:07:53 <sheyll> instance Monad (IO []) where ... doesnt work (how dare I expect this to work :( )
14:08:08 <mauke> sheyll: combine them how?
14:08:12 <sheyll> instance Monad (IO . []) where ... doesnt work either
14:08:37 <sheyll> I want indeterminism combined with the io monad so that I can do file IO
14:08:50 <mauke> there's ListT, but I hear it's semibroken
14:09:00 <sheyll> mhpf
14:09:03 <sheyll> k
14:09:06 <plutonas> can a function have different number of arguments?
14:09:11 <Apocalisp> sheyll: What kind of file IO can't you do with just IO?
14:09:29 <sheyll> I want the list monad...
14:09:36 <plutonas> (with them not beeing lists)
14:09:50 <mauke> plutonas: sort of
14:10:00 <mauke> typeclass hackery makes it possible
14:10:16 <sheyll> Ok, best thing seems to be not doing it?
14:10:25 <Apocalisp> doing what?
14:10:26 <mib_rsdzfr> i am using hugs not ghc
14:10:41 <rwbarton> sheyll: You probably want some kind of "ListT done right" or LogicT
14:10:45 <mib_rsdzfr> i av to use hugs, that's what they have at school
14:11:03 <Apocalisp> mib_rsdzfr: did you see the source for unfoldr above? It's easy to write your own if you don't have the List library.
14:11:06 <sheyll> rwbarton: let me check out ListT ...
14:11:16 <plutonas> actually what i want to do, is having a function that goes through words until it meets a specific one, and store the intermediate ones, and then call another function that groups them nicely, this function also depneds on the number of words it will be given
14:11:21 <rwbarton> sheyll: Don't use the Control.Monad.List one
14:11:36 <sheyll> rwbarton: what else?
14:11:39 <rwbarton> sheyll: (Well, you can use it if you like, but ListT IO won't really be a monad)
14:12:30 <sheyll> rwbarton: because it doesn't satisfy all axioms?
14:12:43 <rwbarton> sheyll: Yeah, it's not associative
14:12:43 <extasic> hmm, I don't seem to get it :(
14:12:49 <rwbarton> sheyll: Take a look at http://www.haskell.org/haskellwiki/ListT_done_right
14:12:50 <lambdabot> Title: ListT done right - HaskellWiki
14:12:59 <sheyll> rwbarton: cool, thanks!
14:13:13 <extasic> I tried this http://nopaste.info/733f4a1036.html
14:13:14 <rwbarton> sheyll: (Although, that page is written a little confusingly.)
14:13:16 <Apocalisp> plutonas: Sounds like you want scanr
14:13:20 <Apocalisp> @type scanr
14:13:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
14:15:35 <rwbarton> extasic: Hmm, you have two recursive calls to diag... why?
14:17:15 <plutonas> thanks Apocalisp, will have a look
14:17:47 <rwbarton> extasic: BTW, you can convert functions of two arguments into infix operators, i.e. write  picture1 `above` picture2  instead of  above picture1 picture2
14:18:46 <extasic> rwbarton, thats great, thanks :)
14:20:24 <sm> g'day all
14:20:32 <plutonas> Apocalisp: scanr takes a list as argument, i don't have that luxury
14:20:53 <Apocalisp> plutonas: what do you have?
14:20:54 <sm> getting ready to upload to hackage.. is it possible to correct mistakes or delete packages there ?
14:21:45 <plutonas> Apocalisp: i just get words, until i reach word "end"
14:21:54 <nicknull> what are the 2 cygiwn commands for fetch? one is get/wget the other is?
14:21:59 <plutonas> and have to do something with each of them, and then according to the number of words group them
14:22:00 <Apocalisp> plutonas: Which type is "words"?
14:22:09 <nicknull> curl?
14:22:36 <plutonas> Apocalisp: it's some complex type in my code, but lets say that String is delimited to words using ;
14:22:40 <plutonas> ';' that is
14:22:57 <Apocalisp> > words "one two three four"
14:22:59 <lambdabot>   ["one","two","three","four"]
14:23:29 <plutonas> hm, that gives me an idea
14:23:57 <plutonas> thanks again
14:23:57 <Apocalisp> @src words
14:23:58 <lambdabot> words s = case dropWhile isSpace s of
14:23:58 <lambdabot>     "" -> []
14:23:58 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:24:15 <nicknull> give a short explanation of a closure please. I know roughly what one is but i cant pin it down
14:24:39 <mib_rsdzfr> @src unfoldr
14:24:40 <lambdabot> unfoldr f b  = case f b of
14:24:40 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
14:24:40 <lambdabot>    Nothing        -> []
14:25:00 <DuClare> Uh, can I somehow use StateT with IO to get both IO and State :x
14:25:07 <plutonas> nicknull: a function defines an environment in a way, like it has it's own variables etc, if you define a function inside another function it is defined only in that environment
14:25:07 <sjanssen> DuClare: yes
14:25:19 <sjanssen> StateT mystate IO
14:26:33 <nicknull> anyone using liskell?
14:27:50 <nicknull> plutonas: you mean the inner function cant use outside variables? or that the outer function cant use the variables of the inner?
14:28:01 * tristes_tigres thinks that programming languages can be divided into two broad classes: functional and dysfunctional
14:28:08 <vixey> lol
14:28:14 <vixey> @remember tristes_tigres thinks that programming languages can be divided into two broad classes: functional and dysfunctional
14:28:15 <lambdabot> I will remember.
14:28:48 <Apocalisp> it's a trichotomy: functional, misfunctional, dysfunctional
14:29:08 <plutonas> nicknull: the seccond one, are you familiar with lisp?
14:29:28 <plutonas> (because you ask about liskell, and i have a good example on closures in lisp)
14:29:42 <DuClare> sjanssen, Ah, seems like I need to use liftIO :o
14:29:51 <plutonas> which probably is similar in haskell, but am not THAT familiar with it yet
14:32:22 <plutonas> nicknull: i'm sorry, what i said was slightly wrong
14:33:28 <nicknull> plutonas: yes i am
14:33:39 <nicknull> ok
14:33:44 <nicknull> what was?
14:34:22 <plutonas> (defun counter ()
14:34:22 <plutonas> 	   (let ((cnt 0)) (defun reset-cnt () (setf cnt 0))
14:34:22 <plutonas> 	                  (defun incr-cnt () (setf cnt (1+ cnt)))))
14:35:02 <plutonas> try this, and then calling counter you implicitly define two functions, one to increment and one to reset cnt, you can try them out, but cnt is not accessible from anywhere else
14:35:05 <mauke> fail for tabs
14:35:57 <vixey> www.paulgraham.com
14:36:08 <vixey> it's full of examples of closures
14:36:21 <plutonas> vixey: yes, might have seen the example there, it's not mine, but idon't remember where i read it
14:37:00 <mauke> counter = do { cnt <- newIORef 0; let { resetCnt = writeIORef cnt 0; incrCnt = modifyIORef x (1+) }; return (resetCnt, incrCnt) }
14:37:16 <mauke> s/x/cnt/
14:37:52 <nicknull> The simply-typed lambda calculus, on which all other type systems are based, proves that programs terminate in a finite amount of time.
14:37:58 <nicknull> http://www.pphsg.org/cdsmith/types.html
14:38:02 <nicknull> is that really true?
14:38:03 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
14:38:12 <mauke> nicknull: if you don't allow recursion, yes
14:38:51 <extasic> I did the first step
14:38:51 <extasic> ##
14:38:53 <extasic> ##
14:38:53 <extasic> ..##
14:38:53 <extasic> ..##
14:39:04 <extasic> that is how it looks now
14:39:12 <extasic> but I can't get the other side working :(
14:39:35 <extasic> would you please have a look at the code
14:39:36 <extasic> diag :: Int -> Picture
14:39:37 <extasic> diag x
14:39:37 <extasic> 	| x == 1 = (invertColour white)
14:39:37 <extasic> 	| otherwise = ((diag (x-1)) `above` (flipD(picCol (x-1) white) `aside` (invertColour white)))
14:40:16 <Beelsebob> hahaha
14:40:27 <Beelsebob> extasic: you go to UKC, don't you
14:40:56 <Beelsebob> who's teaching CO326 now?
14:41:24 <mauke> united kennel club?
14:41:35 <Beelsebob> University of Kent at Canterbury
14:41:47 <mauke> so canterbury is in germany now
14:41:54 <nicknull> where are refs?
14:42:09 <Beelsebob> mauke: ?
14:42:34 <nicknull> well if you dont allow recursion you dont allow loops so ofc it cant loop forever
14:42:34 <mauke> Beelsebob: the code he pasted had german comments and he has a t-dialin hostmask
14:42:38 <nicknull> right?
14:42:42 <Beelsebob> oh, so he does
14:42:56 <plutonas> @src words
14:42:56 <lambdabot> words s = case dropWhile isSpace s of
14:42:56 <lambdabot>     "" -> []
14:42:56 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
14:42:58 <Beelsebob> odd, that looks very much like the first CO326 assesment
14:44:01 <extasic> I just solved it
14:44:08 <Beelsebob> :)
14:44:09 <extasic> no, I dont go to UKC ;)
14:44:25 <extasic> Thank you for helping me helping myself ;)
14:44:27 <mauke> KFC?
14:44:50 <Beelsebob> damn you mauke
14:44:53 <Beelsebob> now I want KFC :(
14:44:55 <extasic> lol
14:44:57 <Beelsebob> and it isn't sold in .be
14:45:02 <extasic> cya guys
14:45:23 <mauke> you are now breathing manually
14:52:59 <nicknull> well if you dont allow recursion you dont allow loops so ofc it cant loop forever
14:53:00 <sm> is there someone on who can give me a hackage account ?
14:55:39 <plutonas> if i say that msum is corresponding to OR, what is the equivallent for AND?
14:56:19 <rwbarton> >>=, kind of .....
14:56:37 <rwbarton> liftM2 (,) mayb
14:56:37 <mauke> sequence
14:58:23 <mib_rsdzfr> dayMapping =  [(y,x) | x <- [1..31], y <- [1..31]]
14:58:37 <mib_rsdzfr> >  [(y,x) | x <- filterTapes, y <- [1..31]]
14:58:38 <lambdabot>   Not in scope: `filterTapes'
14:58:52 <mib_rsdzfr> >  [(y,x) | x <- [1..31], y <- [1..31]]
14:58:53 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)...
14:59:19 <mib_rsdzfr> why am i getting more than 31 numbers ?
14:59:47 <mib_rsdzfr> i want to create a tuple which adds 1..31 to 31 elements
14:59:57 <mib_rsdzfr> i am getting more than 31 back
15:00:03 <mauke> > 31 * 31
15:00:04 <lambdabot>   961
15:00:08 <mauke> you're getting 961
15:00:39 <mib_rsdzfr> yes
15:00:48 <mib_rsdzfr> i only want 31 back
15:00:53 <mauke> > [(y,x) | x <- [1..3], y <- [1..3]]
15:00:54 <lambdabot>   [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
15:01:03 <mauke> > zip [1..3] [1..3]
15:01:03 <mib_rsdzfr> ("value")
15:01:04 <lambdabot>   [(1,1),(2,2),(3,3)]
15:01:11 <mib_rsdzfr> oh, thanks
15:02:37 <byorgey> there's also parallel list comprehensions... but probably best to stick with 'zip'.
15:09:29 <bos> @seen dons
15:09:29 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 16h 31m 52s ago.
15:10:15 <Leimy> @seen my sweet ride?
15:10:15 <lambdabot> I haven't seen my.
15:12:11 <DukeDave> Hey guys, what does it mean if I have a data type constructor like:
15:12:11 <DukeDave> data Foo = Foo (Handle)
15:12:36 <mauke> same thing as data Foo = Foo Handle
15:13:08 <DukeDave> Phew :)
15:14:01 <mauke> which is possibly better written as newtype Foo = Foo Handle
15:15:29 <DukeDave> Ah yes I forgot about newtype
15:20:36 <dons> bos
15:24:19 <bos> dons: writing a lazy version of bytestring-lexing
15:24:44 <dons> oh goody
15:25:08 <dons> a pure haskell one should be pretty doable, imo.
15:25:15 <dons> it's interesting code to write by hand.
15:25:32 <bos> yes.
15:25:39 <bos> for small values of "interesting:
15:25:51 <dons> :)
15:26:10 <nicknull> is there an URL-library for haskell?
15:26:12 <dons> yeah.
15:26:18 <dons> for parsing url?
15:26:21 <allnmymind> sum [1..100]
15:26:23 <dons> or downloading things with them?
15:26:30 <dons> (there's both..)
15:29:08 <nicknull> for both
15:29:33 <nicknull> something with the stdlib? im checking at hackage now
15:29:47 <dons> nicknull: the network package has uri parsing
15:29:58 <dons> for downloading stuff, i recommend 'network-curl'
15:29:58 <keseldude> dons: /msg keselbot @math Plot[x^2*Sin[1/x^2],{x,0,2}]
15:30:00 <keseldude> :)
15:30:02 <dons> nicknull: all on hackage.
15:32:20 <insane> did anybody had problems with wxhaskell compilation regarding precision loss?
15:32:33 <insane> or does anybody know the solution for my problem?
15:33:17 * sm hugs hackage
15:33:46 <sm> hledger command-line accounting tool released, testers welcome. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hledger-0.1 , http://joyful.com/repos/hledger/api-doc/
15:33:52 <lambdabot> Title: HackageDB: hledger-0.1, http://tinyurl.com/3pvk24
15:34:22 <mmorrow> keseldude: awesome.
15:34:26 <keseldude> :)
15:34:50 <mmorrow> what are are using to plot that?
15:35:02 <keseldude> mathematica
15:35:09 <mmorrow> ah, cool.
15:35:37 <inimino> ooh, pretty
15:35:57 <roconnor> @hoogle comparing
15:35:57 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:35:57 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:40:50 <nicknull> dons network-curl: is it cygwin related?
15:41:35 <bos> nicknull: should be portable
15:41:53 <ivanm> if I have trace statements in my compiled program, they should still show up in the terminal, shouldn't they?
15:42:45 <bos> yes
15:44:16 <mmorrow> bos, dons: here's a somewhat complete ByteString readDouble i wrote the other day fwiw: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=154#a154
15:44:35 <mmorrow> (doesn't do a leading '-' or sci notation yet..)
15:44:46 <mmorrow> but it should be with the quickness
15:44:52 <yitz> sm: nice
15:46:31 <sm> thanks!
15:46:38 <yitz> sm: in ghci, you could have l as a global variable
15:48:22 <sm> yitz: great, how would someone use that ?
15:49:43 <vixey> :DD
15:50:07 <yitz> sm: well, one way would be instead of l <- ... you would say something like :cmd initLedger "file.ledger"
15:50:23 <vixey> you can't write: (a -> Maybe b) -> Maybe (a -> b)
15:50:34 <vixey> but  Maybe (a -> b) -> Maybe (a -> b) is pretty easy
15:50:35 <FunctorSalad> why are there .hoo files in /usr/local/share/hoogle-4.0.0.5 if, apparently, only default.hoo is used anyway?
15:50:48 <yitz> sm: then you would have special ghci functions set up for ghci that don't need l.
15:51:14 <sm> I have a little difficulty following you.. maybe a patch would be easier ?
15:52:02 <yitz> vixey: Maybe (a -> b) -> a -> Maybe b is also pretty easy.
15:52:10 <sm> and so the work-dodging begins.. :)
15:52:27 <vixey> oh you don't want to let the a spill out
15:52:28 <yitz> sm: a patch? of what, ghci?
15:52:32 <vixey> you'll never get it back in
15:52:57 <yitz> vixey: I guess that's why it's easy.
15:53:10 <vixey> yeah
15:53:30 <vixey> my mental image of Maybe (a -> b) is like a really tightly wound spring in a box now
15:54:54 <yitz> sm: anyway, whatever you mean by a "patch", I'm sure it's not as easy as setting up ghci commands.
15:55:10 <yitz> that's really simple.
15:56:05 <TomMD> hugo__: Use Data.Time (from the 'time' package)
15:56:13 <TomMD> oops, scrolled up.
16:00:48 <plutonas> how do i flatten a list, like [1, [2,3], 4] -> [1..4] +
16:00:49 <plutonas> ?*
16:00:50 <lambdabot> Maybe you meant: . ? @ v
16:00:57 <vixey> plutonas: that list does not exist
16:01:27 <plutonas> vixey: ok, you're right, i want to do it while constructing it
16:01:43 <Cale> plutonas: start with [[1],[2,3],[4]]
16:01:51 <plutonas> like get 1 as argument place it in the new list, then get [2,3] and place 2 and then 3
16:02:07 <vixey> @let  e 0 = Left 1 ; e 1 = Right [2,3] ; e 2 = Left 4
16:02:08 <lambdabot>  Defined.
16:02:30 <vixey> > [0..2] >>= e >>= either return id
16:02:31 <lambdabot>       Ambiguous occurrence `e'
16:02:31 <lambdabot>      It could refer to either `L.e', defined a...
16:03:02 <Cale> plutonas: Does my suggestion make sense?
16:03:28 <plutonas> Cale: i don't see why you suggest this, isn't there some function like destroyList
16:03:31 <vixey> > [0..2] >>= (let e 0 = Left 1 ; e 1 = Right [2,3] ; e 2 = Left 4 in return . e) >>= either return id
16:03:32 <lambdabot>   [1,2,3,4]
16:03:37 <vixey> (>>=) is destroyList
16:03:40 <Cale> plutonas: destroyList?
16:03:48 <Cale> plutonas: What type?
16:03:58 <plutonas> yes that types are the problem again :)
16:04:15 <Cale> plutonas: Okay, what does it do?
16:04:32 <plutonas> take a list, and return it's elements
16:04:37 <Cale> as a list?
16:04:58 <vixey> so [a] -> [a]
16:05:01 <Cale> id
16:05:04 <Cale> > id [1,2,3,4]
16:05:05 <lambdabot>   [1,2,3,4]
16:05:22 <vixey> > (do x <- id [1,2,3,4] ; x == 3 ; return x)
16:05:23 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Bool'
16:05:29 <vixey> > (do x <- id [1,2,3,4] ; guard (x == 3) ; return x)
16:05:30 <vixey> :(
16:05:30 <lambdabot>   [3]
16:05:32 <yitz> > concat [[1],[2,3],[4]]
16:05:33 <lambdabot>   [1,2,3,4]
16:05:42 <yitz> @type concat
16:05:43 <lambdabot> forall a. [[a]] -> [a]
16:06:01 <plutonas> hm, after a second thought... i probably just need ++
16:06:07 <plutonas> ...
16:06:19 <Cale> Or concat
16:07:57 <yitz> plutonas: for [a], [[a]], [[[a]]], ... you need id, concat, concatMap concat...
16:08:22 <yitz> @type concatMap concat
16:08:23 <lambdabot> forall a. [[[a]]] -> [a]
16:08:47 <yitz> @type concatMap (concatMap concat)
16:08:48 <lambdabot> forall a. [[[[a]]]] -> [a]
16:08:50 <Cale> Or just concat . concat  which is the same thing
16:09:01 <Cale> (yay associativity!)
16:09:05 <vixey> concat^0, concat^1, ... :)
16:09:13 <plutonas> i see, anyway thanks, next question, i remember seeing somewhere a function that reverses arguments to another function, so that it simplifies their use with functions like map, what was the name
16:09:19 <yitz> @type concat . concat
16:09:20 <lambdabot> forall a. [[[a]]] -> [a]
16:09:23 <Cale> flip
16:09:27 <plutonas> thanks
16:09:28 <Cale> :t flip
16:09:29 <guinea> Is there a function like flip that brings the n-th parameter to the front?
16:09:29 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:09:38 <Cale> guinea: Not a prelude function
16:09:51 <Cale> guinea: You can of course just write a lambda
16:11:10 <yitz> @pl \f -> let g x y z = f z x y in g
16:11:10 <lambdabot> (flip .) . flip
16:11:21 <nicknull> bos: Network is actually in the stdlib
16:11:37 <yitz> @pl \f -> let g w x y z = f z w x y in g
16:11:37 <lambdabot> (((flip .) . flip) .) . flip
16:13:05 <sheyll> how do I export all functions in a module?
16:13:38 <sm> module modulename in the export list
16:13:42 <guinea> lambdabot: thanks for reminding me caddaddaddr madness
16:15:10 <sheyll> I just want to have my module exposed to my other module. What do I need to do in order to make sure, that the functions in one module are visible in the other module?
16:16:28 <FunctorSalad> pcre-light is great, even I understand it ;-)
16:17:04 <vixey> type (f :. g) x = f (g x)
16:17:05 <vixey> :(
16:17:07 <vixey> I can't use it
16:17:15 <vixey> it says     Type synonym `:.' should have 3 arguments, but has been given 2
16:17:41 <Riastradh> Type synonyms may not be partially applied.
16:17:51 <FunctorSalad> (with the other regexp packages, the possible return types are a bit intimidating ;-))
16:17:56 <rwbarton> It wouldn't make any sense to do so.
16:17:57 <FunctorSalad> (no offense to anyone)
16:18:16 <vixey> it makes sense to me
16:18:38 <Riastradh> It makes sense, but it would make the type system Turing-complete, and render the type checker non-halting on some programs.
16:21:30 <vixey> how do I work around it?
16:21:42 <vixey> I want to write somethig like
16:21:43 <vixey> class Iterate f n f'n where (^) :: (a -> f a) -> n -> (a -> f'n a)
16:21:43 <vixey> instance Iterate f I'ty f where f^n = f
16:21:43 <vixey> instance Iterate f n ihf => Iterate f (S'ty n) (f :. ihf) where f^n = f . (f^(pred n))
16:21:51 <vixey> except having it work
16:23:57 <yitz> sheyll: by default, all functions defined in a module are exposed, if you don't have an export list.
16:26:04 <vixey> I guess it's not possible to write it in haskell then
16:26:20 <dons> hah
16:26:26 <vixey> huh?
16:26:37 <yitz> @faq Can you write an Iterate class in Haskell?
16:26:37 <lambdabot> The answer is: Yes! Haskell can do that.
16:26:45 <dons> looks a bit like the printf trick
16:27:16 <vixey> maybe yeah
16:27:21 <dons> anywya, vixey ask on the list, with the title "Why can't Haskell do this?!!"
16:27:32 <dons> and then someone will respond with code that does
16:27:39 <dons> after all, we have a turing complete type checker
16:27:44 <rwbarton> but please use better type names than I'ty and S'ty!
16:27:47 <dons> so the upper bound on type programs is ... unclearr
16:28:22 <vixey> rwbarton: such as?
16:28:37 <rwbarton> Beats me, I have no idea what you mean :)
16:28:41 <rwbarton> I think S'ty is Succ...
16:28:42 <newsham> someone should write a haskell-type-system backend for yhc
16:28:51 <rwbarton> I'ty is either One or Zero
16:29:03 <vixey> it's One
16:30:17 <newsham> does ghc give up type checking after some number of steps or will it gladly go into an infinite loop?
16:30:17 <rwbarton> "One" is even shorter than "I'ty" :)
16:31:20 <twxfn> who invited this asshole
16:31:27 <mmorrow> newsham: i think you need to enable UndecidableInstances to get the ability to loop it (if it loops without it, i think that's considered a bug)
16:31:29 <twxfn> out of my brain!!!!!
16:31:40 <twxfn> > + 1 2
16:31:41 <lambdabot>   <no location info>: parse error on input `+'
16:31:46 <twxfn> > 1 + 2
16:31:48 <lambdabot>   3
16:31:54 <mmorrow> > (+) 1 2
16:31:55 <lambdabot>   3
16:32:17 <twxfn> > map [\x->x^2] 1 [1..100]
16:32:18 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:32:24 * twxfn throws up
16:32:35 <mmorrow> > map [\x->x^2] [1..100]
16:32:36 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:32:37 <pumpkin_> twxfn: three parameters to map?
16:32:48 <mmorrow> > map (\x->x^2) [1..100]
16:32:50 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:32:59 * twxfn throws up some more
16:33:02 <newsham> > [\x->x^2] <*> [1..100]
16:33:03 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:33:09 <pumpkin_> :o
16:33:16 <pumpkin_> newsham: what's that syntax? :o
16:33:46 <vixey> you can do it with TH though I guess that is really good enoughaeo
16:33:57 <twxfn> they're all assholes over in #lisp
16:34:03 <twxfn> so i decided haskell was cooler
16:34:06 <twxfn> cause there's a bot in here
16:34:07 <newsham> pumpkin: applicative functor.
16:34:14 <newsham> > [\x->x^2] `ap` [1..100]
16:34:15 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:34:15 <pumpkin_> interesting, thanks
16:34:18 <newsham> ?type ap
16:34:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:34:34 <dibblego> pure (\x -> x ^ 2) <*> [1..100]
16:34:36 <dibblego> > pure (\x -> x ^ 2) <*> [1..100]
16:34:37 <lambdabot>       Ambiguous occurrence `pure'
16:34:37 <lambdabot>      It could refer to either `Control.Appl...
16:34:39 <mmorrow> #lisp doesn't have an eval bot?
16:34:44 <newsham> [] (Int->Int) <*> [] Int results in [] Int
16:34:47 <dibblego> > Control.Applicative.pure (\x -> x ^ 2) <*> [1..100]
16:34:49 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:35:01 <twxfn> it has a social evaluation system
16:35:11 <twxfn> any movement that forgets about class is a bowel movement
16:35:34 <bos> dons: if i ask nicely, can you put the patch i just sent for bytestring-lexing on hackage, so i can upload a new attoparsec?
16:36:00 <twxfn> :t foldl
16:36:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:36:13 <twxfn> somebody please explain how to read those
16:36:19 <twxfn> i know what foldl does and it still doesn't make sense
16:36:23 <dons> bos, right now?
16:36:26 <newsham> > [(^2), (*5)] <*> [100]
16:36:27 <lambdabot>   [10000,500]
16:36:34 <bos> dons: at your convenience.
16:36:39 <dons> i can do this.
16:36:41 <newsham> twxfn: do you know for-loops?
16:36:45 <plutonas> can someone remind me please what $ does? can't google it, as it's some special character in google, and the type doesn't help
16:36:47 <twxfn> yes
16:36:51 <mmorrow> (x::a) is a var x of type a
16:36:54 <bos> dons: thankee.
16:36:56 <vixey> the type does help plutonas
16:37:01 <rwbarton> plutonas: hoogle it! http://www.haskell.org/hoogle/?q=%24
16:37:02 <lambdabot> Title: $ - Hoogle
16:37:06 <newsham> its just a foreach loop that carries an accumulator along
16:37:07 <dibblego> plutonas, it does function application; f x is the same as f $ x
16:37:19 <vixey> :t ($)
16:37:20 <plutonas> i see, thanks
16:37:20 <twxfn> i know that
16:37:21 <lambdabot> forall a b. (a -> b) -> a -> b
16:37:23 <mmorrow> (x :: a -> b) is a function which takes an a and returns a b
16:37:24 <vixey> plutonas: Look ^
16:37:25 <newsham> ie:  accum = init; for val in list { accum = f(val, accum) } return accum
16:37:32 <dons> mm i had an unpushed patch :/
16:37:33 <twxfn> but how do i decode the type bit
16:37:35 <mmorrow> (x :: a -> b -> c) is a function which takes an a and a b and returns a c
16:37:45 <dons>   * Provide unsafeReadDouble
16:37:53 * twxfn frowns
16:38:08 <vixey> plutonas: if I give you an  a -> b  and an  a  how do you make a  b  out of them?
16:38:12 <newsham> > foldl (+) 0 [2,5,8]
16:38:13 <lambdabot>   15
16:38:31 <mmorrow> (x :: a -> (b -> c) -> b -> d) if a function which takes an 'a', a 'b -> c', and a 'b', and returns a 'd'
16:38:36 <mmorrow> s/if/is/
16:38:38 <newsham> is like:  accum = 0; for val in [2,5,8] { accum = ((+) accum val) }; return accum
16:38:50 <newsham> the mapping is pretty straightforward
16:38:52 <mmorrow> [a] is a list
16:38:56 <plutonas> vixey: (a->b) -> a
16:38:57 <mmorrow> (a,b) is a pair
16:39:02 <twxfn> 19:36 < mmorrow> (x :: a -> b -> c) is a function which takes an a and a b and returns  a c
16:39:05 <twxfn> that threw me off
16:39:06 <mmorrow> @type mapAccumL
16:39:07 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:39:09 <vixey> plutonas: that made no sense what-so-ever
16:39:11 <twxfn> i thought there were three extra 'a's
16:39:24 <plutonas> vixey: you're right, (a->b) a
16:39:34 <vixey> plutonas: that doesn't make sense either
16:39:49 <plutonas> well lets name the (a->b) that you give me, lets say f
16:39:51 <plutonas> f a
16:39:52 <vixey> plutonas: look if you have an  f :: a -> b  and a x :: a.. how do you make a  b
16:39:53 <vixey> yesa
16:39:55 <vixey> good idea
16:40:08 <vixey> this is the only solution for that type (of ($))
16:40:24 <twxfn> currying is balls
16:40:25 <mmorrow> (a-> x -> (a, y)) -> a-> [x] -> (a, [y]) take a (1) function taking two args a and x to a (a, y), (2) an a (3) an [x], then returns a (a, [y])
16:40:31 <plutonas> vixey: i remembered what it is, it's to skip parentheses like f (g (h x)) = f $ g $ h x
16:40:47 <plutonas> vixey: though i have some functions defined and their definition ends with $ which confuses me
16:41:04 <vixey> :t (?f$)
16:41:05 <lambdabot> forall a b. (?f::a -> b) => a -> b
16:41:11 <twxfn> :t +
16:41:12 <lambdabot> parse error on input `+'
16:41:15 <twxfn> :t (+)
16:41:16 <lambdabot> forall a. (Num a) => a -> a -> a
16:41:23 <mmorrow> (+) if prefix, + is infix
16:41:28 <twxfn> yeah
16:41:34 <mmorrow> (+3) is a section
16:41:40 <mmorrow> @type (+3)
16:41:41 <lambdabot> forall a. (Num a) => a -> a
16:42:08 <newsham> > ( (+) 3 5, (+ 3) 5)
16:42:09 <lambdabot>   (8,8)
16:42:26 <twxfn> oO
16:42:35 <mmorrow> , (0,1)
16:42:37 <lunabot>  (0,1)
16:42:40 <mmorrow> , (0,1+2)
16:42:42 <lunabot>  (0,3)
16:42:46 <mmorrow> , (0,(1+)2)
16:42:48 <lunabot>  (0,3)
16:42:49 <newsham> > (,) 0 1
16:42:50 <lambdabot>   (0,1)
16:43:05 <twxfn> what's the difference between the bots
16:43:08 <mmorrow> > uncurry (+) ((,) 1 2)
16:43:09 <lambdabot>   3
16:43:26 <newsham> some bots are bigger than others.. some bots mothers are bigger than other bots mothers
16:43:52 <mmorrow> twxfn: they have some different imports and support some different subsets of language features
16:44:02 <twxfn> why can i get this kind of help in #haskell but not in #lisp
16:44:09 <dons> bos,
16:44:12 <dons>  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing-0.2
16:44:15 <twxfn> the only possible answer is that lisp is a balls language
16:44:18 <lambdabot> Title: HackageDB: bytestring-lexing-0.2, http://tinyurl.com/4zvf3e
16:44:54 <dons> twxfn: is your question why we have these kind of bots?
16:44:54 <Riastradh> Another possible answer is that attitudes collided at the wrong moment.
16:45:09 <twxfn> i have more questions than i could ever ask
16:45:10 <dons> or why there's silly comments in here atm?
16:45:29 <newsham> i think he is asking why #lisp doesnt answer his questions
16:45:33 <dons> oh
16:45:34 <newsham> while #haskell does
16:45:37 <dons> different culture.
16:46:06 <twxfn> of course, haskell probably wouldn't answer my questions if i was doing homework in haskell
16:46:11 <dons> http://haskell.org/haskellwiki/IRC_channel#Principles
16:46:12 <lambdabot> Title: IRC channel - HaskellWiki
16:46:23 <luite> twxfn: why not?
16:46:42 <twxfn> i have no clue?
16:46:46 <twxfn> something about
16:46:50 <twxfn> pride
16:46:56 <mib_a7u16b> i am creating a schedule, i have 31 inputs, i want to create a function that when a week is entered it prints the values for that week
16:47:18 <mib_a7u16b> printWeek 1 = [1,2,3,4,,6]
16:47:21 <nicknull> i decided to make a basic webapp. a linkorganizer for youtube. what libs do i need? curl and network only?is there a webserver for haskell?
16:47:50 <bos> dons: thanks!
16:47:54 <newsham> happs is a web app framework for haskell
16:47:59 <mib_a7u16b> what i did was to create tuple and zip each element with a number (day, "value")
16:48:06 <bos> curl won't help at all.
16:48:24 * ddarius <3 netpbm
16:48:33 <twxfn> did glguy write happs
16:48:33 <mib_a7u16b> the week consist of five days, how can i return the values only for the week i want?
16:49:04 <mib_a7u16b> this is an example of what i have
16:49:37 <mib_a7u16b> [x | x <- zip [2,4....100] [1..31]]
16:49:42 <mib_a7u16b> > [x | x <- zip [2,4....100] [1..31]]
16:49:43 <lambdabot>   Not in scope: `....'
16:50:03 <mib_a7u16b> > [x | x <- zip [1..31] [1..31]]
16:50:04 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
16:50:10 <mib_a7u16b> right
16:50:22 <mib_a7u16b> ("day", "value")
16:50:39 <mib_a7u16b> i want to return week 1 or 2 or three
16:50:52 <mib_a7u16b> and it only returns the five i want
16:51:06 <mib_a7u16b> and for week 7 only the last input
16:51:44 <mib_a7u16b> i was thinking of take 5 [1...31]
16:51:52 <mib_a7u16b> > take 5 [1..31]
16:51:53 <lambdabot>   [1,2,3,4,5]
16:51:57 <nicknull> cani installa nd use liskell without messing with my standard ghc-install?
16:52:30 <mib_a7u16b> > take 5 $ drop 5*2 [1..31]
16:52:31 <lambdabot>   Couldn't match expected type `[a]'
16:52:44 <mib_a7u16b> > take 5  (drop (5*2) [1..31])
16:52:46 <lambdabot>   [11,12,13,14,15]
16:52:57 <mib_a7u16b> > take 5  (drop (5) [1..31])
16:52:58 <lambdabot>   [6,7,8,9,10]
16:53:06 <pumpkin_> is there a good way of representing integers modulo something in haskell? without explicitly writing the mod in?
16:53:07 <mib_a7u16b> > take 5  (drop (5*2) [1..31])
16:53:08 <lambdabot>   [11,12,13,14,15]
16:53:25 <mib_a7u16b> > take 5  (drop (5*3) [1..31])
16:53:26 <lambdabot>   [16,17,18,19,20]
16:53:31 <mib_a7u16b> > take 5  (drop (5*4) [1..31])
16:53:32 <lambdabot>   [21,22,23,24,25]
16:53:38 <mib_a7u16b> > take 5  (drop (5*5) [1..31])
16:53:39 <lambdabot>   [26,27,28,29,30]
16:53:41 <pumpkin_> heh
16:53:44 <mib_a7u16b> > take 5  (drop (5*6) [1..31])
16:53:45 <lambdabot>   [31]
16:53:53 <mib_a7u16b> i got it, nevermind
16:54:35 <pumpkin_> did anyone catch my question?
16:54:42 <nicknull> which happs do i need to runa  servr on 8080 and generate some html?
16:55:10 <twxfn> nicknull: you generate code usually through some sort of CG interface (CGI)
16:55:17 <twxfn> generate HTML usually*
16:55:23 <twxfn> which gets sent to the server, which decides the port
16:56:40 <rwbarton> pumpkin_: There are a couple options.  If the modulus is known at compile time, you can just write a Num instance for a newtype of Int/Integer
16:56:55 <SamB> fastcgi, perhaps?
16:57:28 <twxfn> assuming there's not a mod_haskell or whatever if you're using apache et al
16:57:42 <rwbarton> pumpkin_: If not, you can still use a little type class trickery to get a nice interface.  I've written code to do this; I think there's something similar on hackage already
16:57:49 <pumpkin_> rwbarton: I was hoping for something along the lines of being able to define a type like IntegersModFifteen
16:57:54 <pumpkin_> ah okay
16:58:13 <pumpkin_> so you'd write a type with a parameter
16:58:15 <vixey> pumpkin_: You can do  data IntegersModFifteen = IntegersModFifteen Integer
16:58:28 <rwbarton> pumpkin_: "type with a parameter": well, kind of...
16:58:47 <vixey> or data Mod m where Number :: Integer -> Mod m
17:01:09 <roconnor> > ['0'..'9']
17:01:11 <lambdabot>   "0123456789"
17:01:24 <mib_a7u16b> > [2,4...]
17:01:25 <lambdabot>   <no location info>: parse error on input `]'
17:01:33 <mib_a7u16b> > [2,4..]
17:01:35 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:01:51 <mib_a7u16b> > [2,4..10]
17:01:52 <lambdabot>   [2,4,6,8,10]
17:01:57 <mib_a7u16b> > [2,4..100]
17:01:59 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
17:02:11 <mib_a7u16b> haskell is the greatest!!!
17:02:19 <dolio> You don't really need GADTs to do a modulo math type.
17:02:24 <dolio> Just ordinary phantom types.
17:02:30 * pumpkin_ is scared
17:02:38 <vixey> like data Mod m = Number Integer ?
17:02:46 <rwbarton> If the modulus is fixed, you don't need any magic whatsoever.
17:03:06 <vixey> GADTs aren't magic, just more sensible syntax
17:03:07 <dolio> And then higher rank polymorphism if you want to set the modulus at runtime.
17:03:14 <pumpkin_> I just want to do some simple finite field stuff
17:03:26 <pumpkin_> and wanted a simple way to do math on integers mod a number
17:03:42 <nicknull> does liskell have macros yet?
17:03:44 <pumpkin_> so you wouldn't ever be working with two integers with different mods
17:04:33 <rwbarton> Yes, all of the solutions have that property (and moreover you just use normal Num/Fractional operations)
17:05:33 <pumpkin_> hmm
17:05:53 <pumpkin_> rwbarton: have any suggestions on what to look for in hackage?
17:08:03 <rwbarton> Hmm, maybe I thought it was in the type-level library, but AFAICT that's not actually the case
17:08:41 <sm> b1
17:09:32 <pumpkin_> rwbarton: any pointers to explanations on the type trickery you mentioned to implement it myself? I'm just starting and haven't really written any custom types beyond a simple redefinition of a list and such
17:10:52 <rwbarton> pumpkin_: Take a look at that package and in particular toNum and reifyIntegral
17:11:04 <thoughtpolice> can anybody here do me a favor?
17:11:15 <thoughtpolice> who has ghc 6.8.x?
17:12:38 <thoughtpolice> actually nvm
17:15:27 <rwbarton> pumpkin_: the main page of that package has a link to some explanation.  If you want to model Z/nZ the first thing is to create  newtype Mod n = Mod Integer  and then write  instance Pos n => Num (Mod n) where ...
17:15:36 <roconnor> @hoogle red
17:15:36 <lambdabot> Text.XHtml.Transitional red :: String
17:15:36 <lambdabot> Test.HUnit.Base class AssertionPredicable t
17:15:36 <lambdabot> Test.HUnit.Base type AssertionPredicate = IO Bool
17:15:49 <nicknull> This is a true statement that exists independently of your desire to have a big fucking sook about it you poor little pansy.
17:15:54 <roconnor> @hoogle lightskyblue
17:15:54 <nicknull> who was that?
17:15:54 <lambdabot> No results found
17:16:02 <pumpkin_> rwbarton: ah, I think I understand... I'll experiment some and see
17:16:37 <nicknull> anyway, to open an URL and read the text, which lib?
17:17:05 <rwbarton> then you can take expression of type  Num a => a  and use reifyIntegral to compute them at a modulus chosen at runtime
17:17:56 <pumpkin_> I have the source for it in front of me, but I don't quite get what reifyIntegral is doing
17:18:12 <newsham> > ([1,4,9]...)
17:18:13 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
17:18:22 <rwbarton> When I wrote my own version of it, I didn't understand how it worked either :)
17:18:49 <pumpkin_> I mean, I don't even get what it's supposed to do :P
17:18:54 <pumpkin_> let alone how it's doing it
17:19:37 <yitz> @type (...)
17:19:38 <lambdabot> forall a. (Num a) => [a] -> [a]
17:20:29 <sheyll> how would I "lift" dropWhile and takeWhile to ListT?
17:20:37 <pumpkin_> newsham: how is that working? that looks smart
17:21:00 <newsham> its an old algorithm.  http://en.wikipedia.org/wiki/Difference_engine
17:21:01 <lambdabot> Title: Difference engine - Wikipedia, the free encyclopedia
17:21:19 <newsham> here's the src http://codepad.org/WDXeV59b
17:21:53 <pumpkin_> nice :)
17:21:55 <pumpkin_> thanks
17:22:02 <yitz> > ([2,3,5,7,11]...)
17:22:04 <lambdabot>   [2,3,5,7,11,22,48,100,192,341,567,893,1345,1952,2746,3762,5038,6615,8537,10...
17:22:19 <newsham> ?oeis 2,3,5,7,11
17:22:24 <lambdabot>  The prime numbers.
17:22:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:22:32 <yitz> much better
17:22:47 <pumpkin_> omg it's not smart enough to understand the primes :(
17:22:58 <pumpkin_> :P
17:23:05 <newsham> it doesnt polyknow
17:23:20 <BMeph> sheyll: Which one? ;)
17:24:25 <Cale> newsham: As an polyknowmial?
17:24:36 <Cale> in*
17:24:43 <newsham> yup
17:25:55 <rwbarton> sheyll: You have to write them yourself.
17:26:04 <sheyll> BMeph: the "done right" one
17:26:47 <sheyll> rwbarton: oh no
17:26:47 <rwbarton> sheyll: One difference between real lists and ListT-done-right-style "lists" is that in the latter, you have to perform some action in another monad to get each successive list element
17:27:32 <sheyll> I see
17:27:35 <dolio> @type \p -> ListT . liftM (takeWhile p) . runListT
17:27:36 <lambdabot> Not in scope: data constructor `ListT'
17:27:36 <lambdabot> Not in scope: `runListT'
17:28:16 <rwbarton> dolio: But that will (probably, depending on what runListT is) perform the actions needed to compute *all* of the list, which I'm guessing is not what's wanted.
17:28:46 <dolio> Yes, well, that's how ListT is, unfortunately.
17:29:18 <rwbarton> sheyll: Perhaps you should use LogicT, if only so that there won't be this "which ListT do you mean" question all the time :P
17:31:03 <sheyll> I really dont like to read tons of papers now, just to let my programm utter a string to the console, I am thinking about useing prolog instead of haskell
17:31:09 <rwbarton> !!?
17:31:45 <rwbarton> How does Prolog handle IO?
17:32:08 <dolio> Impurity, no?
17:32:16 <sheyll> prolog is impure
17:32:20 <rwbarton> Sounds unmanageable, but I've never used prolog
17:32:39 <sheyll> it's beautiful
17:32:49 <sheyll> in it's own way
17:32:56 <dolio> Predicates are executed left-to-right, of course. :)
17:34:07 <dolio> Mercury uses uniqueness types.
17:34:08 <rwbarton> The pure subset of Prolog is great, but it seems to defeat much of the purpose to add impure features for which you have to understand the operational semantics.
17:35:39 <rwbarton> Seems like it would feel similar to a version of Haskell where you wrapped all the IO with unsafePerformIO and had to use seq for ordering etc.
17:35:41 <sheyll> I also like the explicitness of IO in haskell, but it is a steep learning curve...
17:36:30 <rwbarton> Is my comparison unfair?  (Probably, I have no idea.)
17:37:20 <sheyll> rwbarton: IMHO prolog is _MUCH_ easier to learn than haskell.
17:37:35 <Twey> I disagree
17:37:36 <lambdabot> Twey: You have 1 new message. '/msg lambdabot @messages' to read it.
17:37:39 <Twey> I found Haskell easier
17:39:56 <sheyll> well haskell contains a lot more brain bending stuff to learn than prolog, which has a simple easy to learn and yet powerful way of answering your requests
17:40:36 <Twey> I found Prolog very easy so long as all I wanted was a clever database
17:40:47 <Twey> Actually doing stuff with it was trickier
17:41:01 <mmorrow> are there any Prolog webservers?
17:41:09 <ivanm> http://hpaste.org/11178 <-- for some reason, that top function in that code fragment takes up 40% of my runtime... whereas I would have thought one of the ones it calls would be higher
17:41:11 <ivanm> any ideas why?
17:41:54 <sheyll> well I havent done any "big" prolog programs, just for the excersises of a lecture...
17:41:56 <ivanm> (note that this function does get called quite a few number of times, but still, the ones it calls get called a similar if not higher number of times)
17:42:16 <Riastradh> ivanm, that will really depend on how you call the functions involved.  With the code you have given, no time will be spent in any of it!
17:42:22 <ivanm> Riastradh: heh
17:42:28 <Pseudonym> Prolog's idea of a "big" program is very different from Haskell's idea, or Java's idea, or C++'s idea.
17:42:38 <ivanm> true, but I think the whole program would be too big for hpaste :s
17:42:50 <Pseudonym> A big C++ program is half a million LOC.
17:43:03 <Pseudonym> A big Prolog program is 10 thousand LOC.
17:43:06 <ivanm> when profiling, the "entries" column is how many times it's called, isn't it?
17:43:13 <ivanm> Pseudonym: what's a big haskell program then?
17:43:23 <Pseudonym> GHC. :-)
17:43:27 <ivanm> heh
17:43:28 <Pseudonym> How big is GHC in LOC?
17:43:30 <Twey> I would probably define a program in terms of features, rather than LoC...
17:43:33 <ivanm> *shrug*
17:43:40 <Pseudonym> Twey: Yes, "feature points".
17:43:44 <dons> Pseudonym: just the compiler?
17:43:47 <Pseudonym> Which are hard to measure in Haskell.
17:43:52 <Pseudonym> dons: Let's say just the compiler.
17:43:56 <dons> gimme a sec ...
17:43:57 <Pseudonym> For the sake of argument.
17:44:15 <dons> about 100k
17:44:19 <Pseudonym> ivanm: I'd suggest putting SCCs on everything in your "where" clause.
17:44:21 <plutonas> what is the difference between defining a type using type and newtype?
17:44:22 <Pseudonym> Right.
17:44:25 <dons> the bluespec compiler is 80k, the cryptol compiler 65k
17:44:26 <ivanm> Pseudonym: how?
17:44:46 <mmorrow> sheyll: you can write a webserver in haskell with basic functionality in under 100 lines, and a multithreaded loadable one in under 300
17:44:47 <ivanm> plutonas: with newtype, you require a constructor and can define new instances for different classes
17:45:11 <ivanm> plutonas: whereas type just lets you give an alias to another type, so that your code can be slightly more documented, etc.
17:45:13 <Pseudonym> {-# SCC "name" #-} <expression>
17:45:21 <Pseudonym> So in this case:
17:45:23 <Pseudonym> where
17:45:24 <ivanm> *nod*
17:45:34 <Pseudonym>   x = {-# SCC "x" #-} whatever
17:45:55 <mmorrow> dons: can you talk about cryptol particulars? if so, cryptol has FPGAs as one of its targets, right?
17:45:56 <plutonas> thanks ivanmi think i need newtype, will do some more reading on it
17:46:01 <ivanm> does it need any ghc options?
17:46:11 <Pseudonym> OK, so 60k is a large Haskell program.
17:46:23 <Pseudonym> Which probably has equivalent power of, I dunno, 200k of C++.
17:46:36 <dons> mmorrow: yep.
17:46:45 <ivanm> Pseudonym: so roughly same order of magnitude as prolog?
17:46:47 <dons> there's a public user guide , v2. about to be released, actually
17:46:52 <Pseudonym> More or less.
17:46:58 <dons> mmorrow: multiple backends, interpreters, and FPGAs
17:47:07 <mmorrow> ooh, /me becomes excited
17:47:19 <Pseudonym> When we were working on Mercury, we read papers about superlinear whole-program analysers that perform well "even on large 1000 line programs".
17:47:30 <dons> heh
17:47:35 <Pseudonym> The Mercury compiler was about 80kloc at that point.
17:47:49 <dons> seems a reasonable figure for a high level language compiler written in a hll
17:48:11 <Pseudonym> Yeah, it's about 250kloc now.
17:48:31 <Pseudonym> Mind you, that also includes the Aditi compilation stuff and three backends.
17:48:53 <Pseudonym> Now a 1000 line Prolog program probably does quite a lot.
17:48:56 <ivanm> hmmmmm....... in general, what kind of GHC flags do I want for performance? should -O2 just about do it?
17:49:03 <dons> -O2 -funbox-strict-fields
17:49:15 <Pseudonym> 1000 lines of backtracking monadic Haskell code is probably comparable, though.
17:49:23 <ivanm> dons: *nod*
17:49:33 <mmorrow> dons: will any of the code to the compiler itself be available at any point in the foreseeable future?
17:50:05 <ivanm> Pseudonym: you just don't know how it does it? :p
17:51:09 <Pseudonym> ivanm: I know exactly how it does it.  THere's only one algorithm in Prolog: Exponential backtracking search.
17:51:10 <dons> mmorrow: there's an 'academic version' that is freely available, you have to email though. i'd love to see it online and used for teaching crypto, but we need to find time
17:51:45 <Pseudonym> Oh, the Mercury compiler at that point also had a translater to Goedel.
17:52:00 <Pseudonym> We didn't actually run the Goedel code.
17:52:08 <mmorrow> cool, my request is on the way.
17:52:09 <Pseudonym> Rather, we translated to Goedel to use its type checker.
17:52:25 <Pseudonym> Kind of a cool idea when you think about it.
17:54:25 <Pseudonym> ivanm: How's the profiling going?
17:54:33 <ivanm> still running ;-)
17:54:34 <Pseudonym> Did cost centres help?
17:54:37 <Pseudonym> Right.
17:54:54 <Pseudonym> THe problem with function point counting in Haskell is that lots of function points are hidden in higher-order functions.
17:55:10 <ivanm> *nod*
17:55:26 <Pseudonym> So if you didn't have to write that "map" yourself, it's not really a cost of development.
17:55:55 <Pseudonym> IMO, there's good research to be done in measuring Haskell code for engineering purposes..
17:56:07 <Pseudonym> But it's distinctly unsexy.
17:56:12 <ivanm> Pseudonym: that comment about the map, was that for me?
17:56:14 <dons> yes. metrics!
17:56:15 <Pseudonym> Certainly less sexy than a type system extension.
17:56:23 <dons> Pseudonym: we're really interested in that wrt. hackage now
17:56:28 <dons> since finally there's a huge codebase to look at
17:56:28 <Pseudonym> Right.
17:56:42 <dons> unlike, say, SJT's work in the late 90s, when there wasn't so much code around
17:56:53 <Pseudonym> ivanm: Not necessarily, but it's an interesting point, because it's similar to the profiling problem.
17:57:13 <Pseudonym> In C++, looking at what lines of code are taking all the time is useful.
17:57:29 <Pseudonym> In Haskell, you might find that 80% of your time is spent in "foldl".
17:57:39 <ivanm> *nod*
17:57:52 <Pseudonym> That could actually correspond to a flat profile.
17:58:56 <ivanm> wow.... generating a random double takes up 20+% of the runtime! :o
17:59:07 <dons> ivanm: use mersenne-random
17:59:08 * ivanm didn't know random was that slow
17:59:12 <ivanm> dons: it's faster?
17:59:17 <dons> yeah, about 100x
17:59:24 <ivanm> doesn't it use IO though?
17:59:28 <dons> it's specifically for fast double generation.
17:59:38 <dons> not if you use mersenne-random-pure64
17:59:42 <ivanm> ahhhh
18:00:35 <ivanm> it's drop-in?
18:00:52 <BMeph> When will editline be a drop-in? ;)
18:01:08 <Pseudonym> It'd be useful to put this in a comonadic interface, perhaps.
18:01:58 <ivanm> dons: any particular reason it doesn't instnatiate RandomGen?
18:04:26 <ivanm> in particular, how can I use PureMT to give me a random number in the specified range?
18:05:38 <ivanm> oh, wait, it is an instance of RandomGen... missed that :s
18:07:22 <ivanm> dammit, mersenne-random-pure64 doesn't support split :s
18:07:41 * ivanm naughtily re-uses his seed
18:08:42 <Twey> ivanm: The Catholics will like you.  They don't like it if you waste your seed...
18:08:51 <ivanm> @slap Twey
18:08:51 * lambdabot locks up Twey in a Monad
18:08:57 * ivanm _is_ a Catholic
18:08:58 * Twey laughs.
18:09:05 * Twey is an ex-Catholic
18:09:31 * Pseudonym thought the term was "lapsed Catholic", at least amongst still-Catholics
18:09:35 <dons> ivanm: RandomGen is slooooooooooow
18:09:41 <Twey> Pseudonym: I'm not lapsed
18:09:42 <dons> split is hard
18:09:52 <Twey> Pseudonym: I excommunicated the Catholic Church
18:10:06 <Pseudonym> I was making a joke, you know that, right?
18:10:07 <ivanm> Twey: you can't excommunicate... you're not a bishop!
18:10:17 <ivanm> dons: yeah, so you said ;-)
18:10:21 <ivanm> why is split so hard?
18:10:31 <Twey> Pseudonym: Aye-aye :-P
18:10:40 <Pseudonym> Cool, just checking.
18:10:50 <Pseudonym> ivanm: Because of the way that the Mersenne twister works.
18:10:56 <Twey> ivanm: I can be if I want to
18:10:56 <ivanm> oh
18:11:01 <Pseudonym> It's optimised for producing batches of random numbers.
18:11:07 <Pseudonym> Not for splitting.
18:11:23 <ivanm> which is why it won't be replacing StdGen any time soon?
18:11:56 <Pseudonym> Having said that... it can be done.
18:12:00 <Pseudonym> http://www.haskell.org/pipermail/haskell-cafe/2007-October/033432.html
18:12:13 <lambdabot> Title: [Haskell-cafe] Hiding side effects in a data structure, http://tinyurl.com/3p2mlc
18:12:46 <Pseudonym> See also: http://haskell.org/pipermail/haskell-cafe/2007-October/033436.html
18:12:48 <lambdabot> Title: [Haskell-cafe] Hiding side effects in a data structure, http://tinyurl.com/52sx6c
18:13:43 <twxfn> > 1 + 2
18:13:45 <lambdabot>   3
18:14:39 <Pseudonym> Very neat hack, IMO.  How to split when you can't split.
18:14:56 <Pseudonym> And it even results in a naturally comonadic interface.
18:20:59 <sheyll> why doenst that typechek? http://hpaste.org/11179
18:22:24 * Cale looks
18:22:59 <sheyll> oh thanks cale, I am really at the end of a 16h day and I just wanna get things done...
18:23:41 <sheyll> If you want the complete file ...
18:24:10 <Pseudonym> sheull: I souldn't be surprised if the (b -> Bool) part of the type signature is wrong.
18:24:20 <Pseudonym> Probably should be (a -> Bool)
18:24:25 <Pseudonym> Since b isn't mentioned anywhere else.
18:24:51 <Cale> hmm
18:24:54 <Pseudonym> In addition, there's a problem with type variable scoping.
18:25:04 <Pseudonym> Which can probably be fixed by _not_ putting a type signature on dropWhile'
18:25:08 <Cale> (=<<) dropWhile'  means that dropWhile' :: a -> m b
18:25:29 <Pseudonym> THat too.
18:26:15 <sheyll> Pseudonym: the same type error with (a -> Bool)
18:26:58 <sheyll> :t (=<<) return
18:26:59 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> m a
18:27:07 <Cale> :t (=<<) id
18:27:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
18:27:20 <EvilTerran> (=<<) return = id, isn't that a law?
18:27:32 <Cale> mhm
18:27:58 <sheyll> what du you mean by type variable scoping?
18:28:44 <sheyll> here is the error message: http://hpaste.org/11181
18:28:57 <sheyll> and here is the complete code http://hpaste.org/11180
18:29:53 <Pseudonym> sheyll: Bingo, that's it.
18:30:07 <Pseudonym> The problem is... OK, look at tye type declaration for dropWhile'
18:30:10 <Cale> sheyll: note that the 'a' which occurs in the type signature for dropWhile' is not necessarily the same 'a' as the one for dropWhileM
18:30:17 <Pseudonym> Right.
18:30:25 <Cale> sheyll: type commenting out the type signature for dropWhile'
18:30:28 <Pseudonym> Because the declaration is implicitly bound by a "forall".
18:30:43 <Pseudonym> The problem is that you use "pred" inside dropWhile'.
18:31:08 <Pseudonym> Which forces the "a" in the type of dropWhile' to be the same as that of dropWhileM.
18:31:16 <Pseudonym> This is kind of hard to explain.
18:31:48 <sheyll> hmm I will try
18:33:17 <sheyll> :)
18:33:48 <sheyll> http://hpaste.org/11182
18:33:55 <sheyll> thanks alot!
18:35:26 <sheyll> I think I understand the problem(and the solution), I therefore refactored the function(maybe not in a perfect way) in order to seperate the type declarations
18:37:12 <nicknull> do i have to use cabal to install a new library? i cant jus tunzipo and place in folder?
18:38:05 <nicknull> should i place curl in ghc/lib/ ?
18:38:08 <nicknull> hen run setup?
18:38:34 <thoughtpolice> nicknull: just unzip the source code, go in and run 'runghc Setup configure; runghc Setup build; runghc Setup install'
18:40:39 <nicknull> cannot find sh
18:40:48 <nicknull> what is sh?
18:42:01 <sbahra> ByteString's breakSubstring is a recent addition?
18:42:11 <sbahra> It's not in my install.
18:42:15 <nicknull> curl doesnt seem to be for reading urls
18:42:28 <nicknull> i just want open(url).read()
18:42:44 <mib_a7u16b> does Hierarchical Import work properly in ghc?
18:43:32 <ivanm> dons: the time taken by random number generation went from 20% to 60% with mersenne :s
18:43:42 <ferron> does Hierarchical Import work properly in ghc?
18:44:01 <ivanm> dons: oh, wait, didn't see that the runtime dropped to a third :s
18:44:44 <ivanm> dons: wait, I take it back... the runtime _tripled_
18:44:56 * ivanm was looking at the wrong profile
18:45:07 <ivanm> so I don't think mersenne is faster :s
18:45:19 <nicknull> what is sh?
18:45:37 <ivanm> nicknull: the sh shell
18:45:40 <nicknull> Setup: Cannot find: sh
18:45:49 <ivanm> nicknull: what OS are you running?
18:45:49 <nicknull> which shell is that?
18:45:52 <ivanm> sh
18:45:55 <nicknull> windows
18:45:57 <dons> ivanm: it's *definitely* faster.
18:46:10 <ivanm> dons: well, it makes my code run longer here :s
18:46:27 <ivanm> nicknull: you using cygwin?
18:46:30 <dons> the mersenne-twister is basically the fastest random gen out there
18:46:40 <dons> ivanm: i suppose you're compiling with -O2 ?
18:46:48 <ivanm> yup
18:46:55 <nicknull> ivanm no
18:47:08 <ivanm> well, you'll be needing that probably
18:47:09 <dons> i'd suspect you changed something, or, try going into the mersenne test suite and running that.
18:47:11 <Pseudonym> dons: THat
18:47:15 <dons> it has a timing loop that tells you how many times faster.
18:47:17 <Pseudonym> 's not _entirely_t rue.
18:47:26 <Pseudonym> The implementation is faster.
18:47:39 <Pseudonym> But there are faster RNGs, which are also not as useful.
18:47:41 <dons> fair enough.
18:47:42 <dons> yeah.
18:47:46 <dons> you want good quality randoms
18:47:51 <dons> so there's two dimensions to work in
18:48:02 <Pseudonym> The MErsenne twister is good enough for Monte Carlo algorithms.
18:48:10 <dons> ivanm: try the mersenne test suite that comes with the package
18:48:14 <dons> it'll tell you if something broke
18:48:16 <Pseudonym> If it's good enough for that, it's good enough for everything except crypto.
18:48:27 <ivanm> well, I'm generating two different types of random numbers: random doubles in [0,1), and random ints in [0,x]
18:48:30 <ivanm> nicknull: http://en.wikipedia.org/wiki/Bourne_shell
18:48:31 <lambdabot> Title: Bourne shell - Wikipedia, the free encyclopedia
18:48:32 <dons> otherwise you should see a couple of magnitudes more doubles produced
18:48:39 <dons> ivanm: that's fine, there's primitives for that
18:48:50 <nicknull> bah no acceptable c ompiler
18:48:51 <dons> i wonder if you've wrapped all the good stuff up in yucky Random code?
18:48:53 <ivanm> the RandomGen ones? I'm using them
18:48:54 <nicknull> can i do it in msys?
18:49:02 <ivanm> dons: oh, could be...
18:49:37 <dons> could you try just calling randomDouble ?
18:49:51 <ivanm> that's in [0,1) ?
18:49:56 <dons> or use mersenne-random itself, which gives you direct access (check the docs)
18:49:58 <ivanm> how about randomInt? how can I bound that?
18:50:13 <dons> check the mersenne twister site
18:50:22 <dons> it has lots of advice about how to most efficiently use this stuff
18:50:28 <ivanm> oh? which website is that?
18:50:29 <nicknull> curl libraries not found
18:50:34 <dons> ?go mersenne twister
18:50:36 <lambdabot> http://en.wikipedia.org/wiki/Mersenne_Twister
18:50:38 <nicknull> wtf i run setup in the curl directory
18:50:39 <dons> not that one.
18:50:41 <dons> ?go mersenne twister site:.jp
18:50:44 <ivanm> heh, didn't think so
18:50:50 <nicknull> do i need some other curl libraries rtoo? the cygwin curl?
18:50:53 <dons> it's mentioned several times in the docs
18:50:54 <lambdabot> http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
18:50:54 <lambdabot> Title: Mersenne Twister: A random number generator (since 1997/10)
18:51:23 <ivanm> dons: the haddock docks don't mention it...
18:52:12 <ivanm> dons: so you're saying I should use System.Random.Mersenne.Pure64.Base?
18:52:27 <dons> i'd say: look at the source to the mersenne-random package
18:52:37 <ivanm> dons: the fact that I'm running it in 32bit doesn't make a difference?
18:56:16 <ivanm> dons: so randomDouble returns a result in [0,1)?
18:56:48 <dons> see the docs in the cbits,
18:56:49 <dons> e.g. /* generates a random number on [0,1)-real-interval */
18:56:55 <ivanm> ahhh, k
18:56:59 <dons>  /* generates a random number on [0, 2^64-1]-interval */
18:57:10 <ivanm> cbits? of which one?
18:57:11 <dons> those docs should be propagated out.
18:57:21 <dons> which package are you using?
18:57:34 <ivanm> -pure64
18:57:41 <dons> that one.
18:57:54 <ivanm> oh, cbits == base?
18:57:57 <dons> also, look at the test programs, now you've got the source.
18:59:13 <ivanm> so by "look at the docs", you mean "unpack the source code and look at it"? :p
18:59:42 <dons> well, apparently. but you're hunting performance, so that's ok.
19:00:43 <ivanm> well, your randomInt, randomDouble, etc. functions don't seem to be using the C functions... they all call randomWord64
19:01:44 <dons> oh, in the pure64 version?
19:02:00 <ivanm> yes
19:02:02 <dons> that's interesting. i'd seriously just look at the core mersenne-random package then.
19:02:11 * ivanm would _really_ like to avoid IO
19:02:11 <dons> it's a simple binding to exactly the functions you asked for.
19:02:32 <dons> well, the pure one is also very fast. so working out what was getting in the way of that is useful.
19:02:38 <dons> but you're going to simply have to do some hunting now.
19:02:49 <ivanm> yeah
19:02:50 <sclv> ?tell cjs Thanks for the advice on sockets -- turned out to be a handle issue that overflowed a buffer somewhere, causing occasional segfaults as well. We'll be putting in a bug report to ghc shortly.
19:02:51 <lambdabot> Consider it noted.
19:02:52 <dons> read the source, work out what's going on.
19:03:04 <ferron> @logs
19:03:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:03:35 <sclv> ?where logs
19:03:36 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
19:04:44 <dblazakis> sclv: how did you manage to hunt it down?
19:05:07 <sclv> netcat and netstat helped to rule out sockets directly.
19:05:28 <sclv> then we realized that it was only particularly large requests that were knocking everything down -- or at least that they did so consistently.
19:05:37 <sclv> so we could finally distill down a testcase.
19:06:10 <sclv> open a handle with Network, feed a huge set of data into it, and then call hGetLine and you get varying sorts of bad behavior.
19:06:40 <sclv> so we moved to Network.Socket and things are fine.
19:07:23 <sclv> (yes I know calling hGetLine over a huge thing on a handle is sort of inefficient and silly, but it still shouldn't segfault)
19:08:14 <dblazakis> sclv: yeah, that's interesting
19:08:55 <sclv> one of these days somebody is going to have the $ and incentive to create a certified haskell rts, or something closer to one...
19:09:12 <SamB> I has the $
19:09:22 <SamB> it is like our $, only with the other fixity
19:09:59 <dblazakis> well, is this the rts or the library?
19:10:28 <SamB> well, yes, I was thinking "but what does $ have to do with the RTS?"
19:10:32 <sclv> A bit of both, I think...
19:10:48 <sclv> handles and sockets aren't really the rts, but they're close...
19:11:01 <SamB> heh
19:11:14 <SamB> you think we are going to be able to certify anything about sockets ?
19:11:29 <dblazakis> i certify them to be "totally awesome"
19:11:41 <sclv> well, regions to guarantee no buffer overflows at least.
19:14:11 <ivanm> dons: well, it's definitely running a lot faster now that I made custom versions of randomR and randomRs!
19:14:42 <ivanm> 16.22s vs 434.88 using StdGen! \o/
19:15:11 <ivanm> generating random numbers is still taking up 64% of the runtime, but at least the runtime is _small_ now!
19:16:34 <nicknull> come on: is there no: import NiceWebLib as W; let w = W.openUrl(url); print W.read w
19:17:18 <nicknull> http://kushaldas.in/2008/09/21/my-way-of-testing-language/
19:17:23 <dons> ivanm: oh, you were using randomRs ?
19:17:23 <lambdabot> Title: My way of testing language | Kushal , kD & FOSS
19:17:30 <dons> i'd avoid lists if at all possible
19:17:55 <dons> sclv: a verified haskell runtime eh?
19:18:00 <dons> it's a big project...
19:18:25 <dons> similar size and scope to a verified microkernel
19:19:58 <waynemokane> can an anonymous function use a data constructor in its arg?
19:20:19 <Twey> Yes
19:20:36 <Twey> Constructors are functions.  Functions are values.
19:20:58 <dibblego> I think you mean for pattern matching, where you'd use case/of
19:21:32 <dibblego> @type \x -> case x of Just n -> n; _ -> 7
19:21:33 <lambdabot> forall t. (Num t) => Maybe t -> t
19:21:51 <rwbarton> @type \(Just n) -> n
19:21:52 <lambdabot> forall t. Maybe t -> t
19:22:10 <dibblego> oh didn't know that :)
19:22:12 <rwbarton> but you can't write multiple cases that way.
19:22:28 <dibblego> actually I did
19:22:31 * dibblego smacks /me
19:31:22 <ivanm> dons: yup
19:31:39 <ivanm> I needed to create a random 2D array
19:32:12 <ivanm> anyway, thanks for your help dons
19:32:17 * ivanm rushes off to catch the bus to uni
19:37:52 <dons> ivan: oh, perhaps you can just fill it with a loop
19:37:56 <dons> rather than going via a list.
19:38:05 <dons> really, just use mersenne-random to fill a buffer
19:40:54 <waynemokane> how can you use trace (from Debug.Trace) inside a do block?
19:41:34 <sm> much the same way ?
19:41:54 <rwbarton> trace "foo" $ return (), I suppose?
19:42:19 <rwbarton> Or yeah, just attach it to some expression
19:42:26 <dblazakis> > :t get
19:42:27 <lambdabot>   <no location info>: parse error on input `:'
19:42:30 <dblazakis> :t get
19:42:31 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:42:33 * sm has developed an unconscious black knowledger of where to drop in trace and with which sigils..
19:42:42 <dblazakis> :t trace "woo" (get)
19:42:43 <lambdabot> Not in scope: `trace'
19:42:58 <dblazakis> :t Debug.Trace.trace "woo" get
19:42:59 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:43:29 <sm> not always, but often I find strace a = trace (show a) a -- trace a showable expression   easier
19:44:45 <waynemokane> sm: so that does the unsafe print of the thing and evalautes to the thing itself?
19:44:49 <sm> (and I make sure pretty much everything is showable)
19:44:50 <sm> right
19:44:59 <Nafai> Hey sm!
19:45:07 <sm> so you can stick it in a long pipeline and not have to retype the long thing on the right
19:45:10 <rwbarton> Yeah, it'd be handy if Debug.Trace included such a function.
19:45:11 <sm> hey Nafai !
19:45:28 <SamB_XP> indeed
19:45:48 <SamB_XP> especially if it also included a place to stick a static message to put before the showed value
19:46:28 <waynemokane> oh nevermind... it was working (in the do block), but that buffer didn't flush until the end of the program
19:46:59 <waynemokane> so I guess if I want in-order printing I have to use putStrLn.. since that's what do-blocks are for!
19:47:35 <sm> I've never noticed problems seeing trace output right away.. aside from laziness. If I put it somewhere I know is evaluated, I see the effect
19:47:36 <ferron> i am trying do a IO function that prints 5 numbers on each line, if i want to make the first part have something like Week 1 and not get repeated what do i do?
19:47:41 <ferron> any help??
19:48:23 <ferron> http://hpaste.org/11183
19:48:24 <waynemokane> ferron: show what the invocation and output should look like, I don't quite get it
19:48:49 <ferron> it should be in a table form
19:49:40 <dblazakis> i think i've already heard this problem this week
19:50:49 <sm> what are you up to Nafai
19:51:02 <ferron> this is the layout
19:51:03 <ferron> http://hpaste.org/11184
19:51:15 <ferron> i got the numbers ok
19:51:29 <ferron> just want week headin on each line
19:51:33 <ferron> please help
19:52:19 <ferron> the mapM_ just keep repeating the heading
19:53:55 <roconnor> @type find
19:53:56 <ferron> no help?
19:53:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:54:09 <dblazakis> > [1..]
19:54:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:54:15 <dblazakis> :t zip
19:54:16 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:54:17 <roconnor> @type findIndex
19:54:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
19:54:55 <dblazakis> solveHanoi returns a list, right? and you just need to enumerate that list
19:55:07 <ferron> yes
19:55:17 <ferron> got that part ok
19:55:33 <ferron> all i need is just the formatting and i'm good
19:55:51 <dblazakis> ok, so f, right now, takes just the hanoi answer
19:55:59 <dblazakis> well a single step in the answer
19:56:21 <ferron> yeah
19:56:22 <dblazakis> if f took more information, it could print the step number
19:57:58 <dblazakis> ferron: does that give you any ideas?
19:58:03 <ferron> what else could it take?
19:58:16 <dblazakis> i would pass the week number
19:59:10 <ferron> i tried adding the week number, but how do i get the "week" heading, only at the front
19:59:19 <ferron> and not all elements
20:00:28 <ferron> this is the rest of the code
20:00:30 <ferron> http://hpaste.org/11183#a1
20:00:50 <ferron> u think i should do it another way without using the mapM_
20:01:30 <ferron> ?
20:02:28 <ferron> dblazakis any aid?
20:02:43 <dblazakis> ferron: i must not understand what you need to do
20:03:23 <ferron> this is what i need to be the finish prod
20:03:24 <ferron> http://hpaste.org/11184
20:03:31 <ferron> that layout
20:03:53 <ferron> dblazakis u see it?
20:03:56 <dblazakis> ferron what type does solveHanoi return?
20:04:39 <ferron> (val,"pegfrom","pegto")
20:05:08 <ferron> it shows the val been moved from which peg to which peg
20:05:14 <ferron> dblazakis understand?
20:06:38 <dblazakis> how do you know what day of the week to begin the month?
20:06:39 <ferron> dblazakis still don't get it?
20:07:15 <dblazakis> does a single step in the hanoi solution match up to a day or a week?
20:07:16 <ferron> i am just doing 31 days, that's not a requirement
20:08:11 <dblazakis> :t take
20:08:12 <lambdabot> forall a. Int -> [a] -> [a]
20:08:17 <ferron> the hanoi generates 31 solutions on when 5 is entered right
20:08:27 <ferron> each move is treated as a backup
20:08:27 <dblazakis> > take 5 [1..]
20:08:28 <lambdabot>   [1,2,3,4,5]
20:08:36 <ferron> 1 backup per day
20:08:43 <ferron> 31 days 31 moves
20:08:57 <ferron> i am just to lay it out and i am done
20:09:02 <ferron> that's all
20:09:06 <dblazakis> i would break the problem up, split the solutions up into weeks
20:09:11 <ferron> did the rest already
20:09:23 <ferron> that was one of the reqs
20:09:38 <dblazakis> ok, well you haven't written that part yet, you have a list of 31 elements
20:10:03 <ferron> http://hpaste.org/11183#a1
20:10:22 <ferron> in the printDay, i don't understand what inputs it's askin for
20:10:45 <ferron> and the printWeek is askin for printWeek::[(Int, Int)]->IO()
20:11:00 <ferron> don't know what i must put there either
20:11:10 <ferron> that's why i used the mapM_
20:11:25 <ferron> if u could explain if to me that would be good
20:11:53 <dblazakis> printDay was given?
20:12:08 <adu> wow
20:12:13 <ferron> not fully
20:12:43 <Twey> hanoiIO :: IO ()
20:12:54 <ferron> this was goven
20:12:55 <ferron> http://hpaste.org/11185
20:13:05 <ferron> *given
20:13:05 <adu> intersperse x xs = xs >>= (:[x])
20:13:39 <ferron> dblazakis u see it?
20:13:47 <adu> @check \x xs -> intersperse x xs = xs >>= (:[x])
20:13:48 <lambdabot>   Parse error at "=" (column 27)
20:13:55 <dblazakis> ferron: yes
20:13:58 <adu> @check \x xs -> intersperse x xs == xs >>= (:[x])
20:13:59 <lambdabot>   Couldn't match expected type `m a' against inferred type `Bool'
20:14:08 <rwbarton> > ["foo", "bar", "baz"] >>= (:[" "])
20:14:09 <lambdabot>   ["foo"," ","bar"," ","baz"," "]
20:14:29 <dolio> > let i x xs = xs >>= (:[x]) in (intersperse 'a' "a", i 'a' "a")
20:14:30 <lambdabot>   ("a","aa")
20:14:39 <dblazakis> ferron: since you filled in a piece of printDay, what do you think f and s are?
20:14:49 <ferron> dblazakis understand what it asking?
20:15:27 <ferron> s represent the tape used and f i don't know, that was a guess
20:15:33 <adu> dolio: maybe not
20:15:56 <ferron> probably day
20:16:09 <ferron> but that don't make sense to me
20:16:42 <dblazakis> sounds like you're on the right track
20:17:51 <dblazakis> open up a interactive shell and play with the functions
20:17:53 <ferron> dblazakis what i think is, when it reaches fri which is the last, it prints the "week" message
20:18:08 <ferron> i check for that by dividing be 5
20:18:24 <ferron> since fridays increment by 5
20:18:38 <ferron> how do i solve the week ?
20:18:44 <ferron> dblazakis any help?
20:19:03 <adu> > intersperse ',' "ABCDE"
20:19:04 <lambdabot>   "A,B,C,D,E"
20:19:06 <adu> > init $ "ABCDE" >>= (:",")
20:19:07 <lambdabot>   "A,B,C,D,E"
20:19:59 <ferron> printWeek::[(Int, Int)]->IO(), what is it asking for ???
20:20:08 <dolio> > tail $ "ABCDE" >>= (',':) . return
20:20:09 <lambdabot>   "A,B,C,D,E"
20:20:16 <dolio> That's probably more efficient.
20:20:23 <waynemokane> any ideas on what this error means, when trying to install haddock via macports?
20:20:24 <ferron> dblazakis what is it asking for?
20:20:26 <waynemokane> [13 of 24] Compiling Haddock.GHC.Typecheck ( src/Haddock/GHC/Typecheck.hs, dist/build/haddock/haddock-tmp/Haddock/GHC/Typecheck.o )src/Haddock/GHC/Typecheck.hs:82:4:    Constructor `HsModule' should have 7 arguments, but has been given 8
20:21:11 <dblazakis> ferron: what is the type of printDay?
20:21:53 <adu> intersperse x = (init.(>>=(:[x])))
20:21:57 <ferron> dblazakis wasn't stated only printDay (f,s)  was shown
20:22:14 <dblazakis> ok, but what do you think the type is
20:22:23 <dblazakis> think about how it fits with printWeek
20:22:39 <dolio> > let i x = (init.(>>=(:[x]))) in i 'c' []
20:22:40 <lambdabot>   "* Exception: Prelude.init: empty list
20:22:51 <dolio> > intersperse 'c' []
20:22:52 <lambdabot>   ""
20:23:05 <adu> :(
20:23:22 * dolio is a human quickchecker!
20:25:03 <ferron> dblazakis printWeek :: (Int,Int) -> IO ()
20:25:07 <rwbarton> Well, a checker, anyways :)
20:25:08 <ferron> what u think?
20:25:15 <waynemokane> nevermind that ^^ my macports picture of the repo was outdated
20:25:16 <ferron> dblazakis right?
20:25:20 <dolio> > let i x = drop 1 . (>>= (x:) . return) in (i 'c' [], i 'c' "a", i 'c' "ab", i 'c' "abc")
20:25:21 <lambdabot>   ("","a","acb","acbcc")
20:25:32 <waynemokane> now, when running haddock, do I need to worry about this warning?
20:25:33 <waynemokane> Warning: main:ITRBTypes: could not find link destinations for:    GHC.Real.Real GHC.Real.Fractional GHC.Real.Integral GHC.Base.Eq GHC.Show.Show GHC.Base.String Data.Maybe.Maybe GHC.Float.Double Text.JSON.JSON GHC.Num.Integer
20:25:45 <dblazakis> ferron: looks good to me, now see how that could fit into printWeek
20:25:56 <ferron> k
20:26:46 <adu> @pl (\x -> 1:[x])
20:26:46 <lambdabot> (1 :) . return
20:28:24 <ferron> dblazakis so print week is asking for the (tape,day) right?
20:28:42 <dblazakis> i can only assume
20:28:48 <dmwit__> waynemokane: It probably just means you won't get links to those docs in your haddock pages.
20:28:53 <ferron> k
20:28:55 <ferron> thanks
20:29:48 <adu> @pl (\(x:y) -> (x,y))
20:29:48 <lambdabot> liftM2 (,) head tail
20:30:23 <adu> @pl uncurry (:)
20:30:24 <lambdabot> uncurry (:)
20:30:28 <waynemokane> dmwit: that's what I guessed too, I'm just trying to figure out if it means I've misconfigured something or it's a legitimate issue
20:30:41 <dmwit> seems fine
20:30:50 <adu> @pl (\(x,y) -> (x:y))
20:30:50 <lambdabot> uncurry (:)
20:30:59 <waynemokane> what is the naming convention for .hs files and modules?  should they have the same names?
20:31:07 <dmwit> yes
20:31:23 <dmwit> Qualified modules should go in directories with the same names as the qualifications, too.
20:31:35 <dmwit> So module Foo.Bar.Baz should be in the file Foo/Bar/Baz.hs
20:32:07 <waynemokane> dmwit: thanks
20:32:28 <dmwit> If you follow this convention, GHC will find your files for you with --make. =)
20:32:44 <waynemokane> exactly what I need  :)
20:35:49 <lispy> hey lambda people!
20:37:40 <adu> @pl (uncurry (:)) . second (((x:).return)=<<) . (liftM2 (,) head tail)
20:37:41 <lambdabot> uncurry (:) . second ((x :) . return =<<) . liftM2 (,) head tail
20:37:54 <dmwit> That's already pl'd.
20:38:06 <adu> dmwit: I was hoping for magic
20:38:23 <dmwit> If you have no let bindings and no lambdas, you can't hope for too much... =P
20:38:45 <dmwit> What is x?
20:39:02 <adu> intersperse x = uncurry (:) . second ((x :) . return =<<) . liftM2 (,) head tail
20:39:06 * SamB_XP throws sugar lambdas
20:39:24 <adu> @pl \x -> uncurry (:) . second ((x :) . return =<<) . liftM2 (,) head tail
20:39:25 <lambdabot> (uncurry (:) .) . (. liftM2 (,) head tail) . second . (=<<) . (. return) . (:)
20:39:46 <dmwit> ?src intersperse
20:39:46 <lambdabot> intersperse _   []     = []
20:39:46 <lambdabot> intersperse _   [x]    = [x]
20:39:46 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
20:40:25 <adu> maybe i'm getting carried away...
20:41:02 <adu> @pl \sep (x:xs) = x : sep : intersperse sep xs
20:41:02 <lambdabot> (line 1, column 13):
20:41:02 <lambdabot> unexpected "="
20:41:02 <lambdabot> expecting pattern or "->"
20:41:11 <adu> @pl \sep (x:xs) -> x : sep : intersperse sep xs
20:41:11 <lambdabot> (`ap` tail) . (. head) . flip ((.) . (:)) . liftM2 (.) (:) intersperse
20:41:30 <dmwit> ?pl let intersperse sep (x:xs) = x : sep : intersperse sep xs in intersperse
20:41:31 <lambdabot> fix (flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . (:))) .) . liftM2 (.) (:))
20:41:38 <adu> @pl let f sep (x:xs) -> x : sep : f sep xs in f
20:41:39 <lambdabot> (line 1, column 18):
20:41:39 <lambdabot> unexpected "-"
20:41:39 <lambdabot> expecting pattern or "="
20:41:50 <adu> @pl let f sep (x:xs) = x : sep : f sep xs in f
20:41:50 <lambdabot> fix (flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . (:))) .) . liftM2 (.) (:))
20:42:06 <dmwit> It's wrong without the base cases, though.
20:42:11 <dmwit> Yours is very clever.p
20:42:50 <Twey> When Not to Use Point-Free.
20:43:00 <dmwit> 1. now
20:43:00 <mmorrow> @pl \f -> fix (\k (x:xs) -> f x : k xs)
20:43:00 <lambdabot> fix . flip flip tail . (ap .) . flip flip head . ((.) .) . flip . (((.) . (:)) .)
20:43:04 <dmwit> 2. refer to 1.
20:43:12 <lispy> Pointless Code Considered Harmful
20:43:25 <dmwit> "Considered Harmful" Considered Harmful
20:43:47 <lispy> > fix ("Considered Harmful":)
20:43:48 <lambdabot>   ["Considered Harmful","Considered Harmful","Considered Harmful","Considered...
20:43:49 <sjanssen> fix (++" Considered Harmful")
20:43:51 <Twey> '"Considered Harmful" Considered Harmful' Considered Harmful
20:43:55 <Twey> Hahaha
20:44:05 <adu> lispy: indeed
20:44:15 <dmwit> sjanssen: I think you've got to flip that.
20:44:19 <dmwit> > fix (++"foo")
20:44:30 <sjanssen> dmwit: <<loop>> is intentional
20:44:32 <Twey> > fix ("Considered Harmful " ++)
20:44:33 <lambdabot>   "Considered Harmful Considered Harmful Considered Harmful Considered Harmfu...
20:44:35 <lambdabot>   thread killed
20:44:35 <dmwit> sjanssen: ah =)
20:44:49 <adu> I should have stopped at (init.(>>=(:[x])))
20:45:28 <sjanssen> > iterate (++ " Considered Harmful") ""
20:45:29 <lambdabot>   [""," Considered Harmful"," Considered Harmful Considered Harmful"," Consid...
20:45:48 <Twey> We need the quotes really.
20:45:56 <lispy> > repeat "Considerd Harmful "
20:45:58 <lambdabot>   ["Considerd Harmful ","Considerd Harmful ","Considerd Harmful ","Considerd ...
20:46:12 <sjanssen> > iterate ((++ " Considered Harmful") . show) "Considered Harmful"
20:46:13 <lambdabot>   ["Considered Harmful","\"Considered Harmful\" Considered Harmful","\"\\\"Co...
20:46:19 <rwbarton> ah sjanssen beat me
20:46:26 <sjanssen> @v
20:46:26 <lambdabot> "\""
20:46:31 <sjanssen> @v
20:46:31 <lambdabot> "\""
20:46:31 <Twey> Heheh
20:46:34 <sjanssen> @v
20:46:34 <lambdabot> "\"#$%&'()*+,\""
20:46:39 <sjanssen> @v
20:46:39 <lambdabot> Just 'J'
20:46:41 <Twey> What's this?
20:46:42 <sjanssen> bah
20:46:45 <sjanssen> > fix show
20:46:46 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
20:46:57 <dmwit> @v
20:46:57 <lambdabot> "\""
20:46:58 <dmwit> @v
20:46:59 <lambdabot> Exception: <<loop>>
20:47:03 <dmwit> |list
20:47:05 <dmwit> ?list
20:47:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:47:08 <Twey> Mm exponentiation
20:47:15 <lispy> I love that show isn't broken until you fix show.  Just goes to show, if it ain't broken don't fix it.
20:47:31 <adu> @v is back?
20:47:32 <lambdabot> "\""
20:47:32 <dmwit> ?yhjulwwiefzojcbxybbruweejw
20:47:32 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
20:47:42 <dmwit> ?yhjulwwiefzojcbxybbruweejw
20:47:43 <lambdabot> Exception: <<loop>>
20:47:43 <adu> @v
20:47:43 <lambdabot> Just 'J'
20:47:49 * sjanssen is trying to find the logs
20:47:50 <mmorrow> whoa
20:47:52 <Twey> Nowt provides v
20:47:58 <Twey> lambdabot: *groooooan*
20:48:11 <Twey> Er
20:48:12 <lispy> iirc, this is a simulated v
20:48:17 <mmorrow> @v
20:48:17 <lambdabot> Exception: <<loop>>
20:48:17 <Twey> lispy: *groooooooooooan*
20:48:18 <lispy> just like @keal is a simulated keal
20:48:20 <mmorrow> oh
20:48:26 <lispy> ?keal
20:48:27 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
20:48:39 <lispy> ?. vixen keal
20:48:39 <lambdabot> church is my favourite computer scientist.
20:48:43 <lispy> ?. vixen keal
20:48:44 <lambdabot> church is my favourite computer scientist.
20:48:47 <lispy> ?. vixen keal
20:48:47 <lambdabot> Ooh, functional programmers are so hot!
20:48:54 <lispy> I wonder what keal is saying...
20:48:57 <lispy> ah well
20:49:03 <lispy> I should stop spamming :)
20:49:09 <dmwit> ?vixen and ?keal, sittin in a tree, K-I-S-S-I-N-G
20:49:10 <lambdabot> i'll hafta plead the fifth on that one.
20:49:22 <sjanssen> http://tunes.org/~nef/logs/haskell/06.04.09
20:49:28 <sjanssen> that was really fun :)
20:50:00 <lispy> june 4th of 2009?
20:50:14 <lispy> or was that Sept 4th of 2006?
20:50:40 <sjanssen> April 9 2006
20:51:37 <dmwit> Wait, what?
20:51:47 <dmwit> head v ---> Exception: <<loop>>?
20:52:04 <rwbarton> Awesome :)
20:52:13 <sjanssen> dmwit: try to figure out what v was without scrolling to the end
20:52:25 <sjanssen> 'twas an interesting little puzzle
20:52:27 <dmwit> > head $ fix show
20:52:29 <lambdabot>   '"'
20:52:43 <dmwit> wait.
20:53:08 <dmwit> It definitely has type String...
20:53:20 <dmwit> ?src head
20:53:20 <lambdabot> head (x:_) = x
20:53:20 <lambdabot> head []    = undefined
20:53:35 <dmwit> Some kind of strictified String? O_o
20:53:37 <Twey> Lies
20:53:40 <Twey> > head []
20:53:41 <lambdabot>   * Exception: Prelude.head: empty list
20:53:59 <Twey> head [] = error "Prelude.head: empty list"
20:55:21 <lispy> Twey: you could submit a patch
20:55:25 <lispy> ?src
20:55:25 <lambdabot> src <id>. Display the implementation of a standard function
20:55:31 <lispy> ?version
20:55:31 <lambdabot> lambdabot 4.2.1
20:55:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:56:47 <dmwit> Huh.
20:57:00 <Twey> > head $ fix show
20:57:01 <lambdabot>   '"'
20:57:08 <sjanssen> Twey: according to Haskell '98, those two are the same (bottom is bottom is bottom)
20:57:11 <dmwit> So showing any part of the String is OK, but otherwise forcing the top constructor is not.
20:57:23 <lispy> > take 5 $ group $ fix show
20:57:25 <lambdabot>   ["\"","\\","\"","\\\\\\","\""]
20:57:31 <dmwit> So, what's magical about String's Show instance?
20:57:34 <dmwit> ?src String show
20:57:35 <lambdabot> Source not found. I feel much better now.
20:57:49 <sjanssen> dmwit: nothing, really
20:58:23 <sjanssen> special characters (like ", \) are quoted, and " " is wrapped around the whole thing
21:00:19 <lispy> > take 5 $ zipWith (:) (fix show) (tail (fix show))
21:00:20 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:00:42 <mmorrow> > (\sep -> fix (\k xs -> list xs (\x ys -> list xs (\_ _ -> x:sep:k ys) ys) xs)) ',' ['a'..'z']
21:00:43 <lambdabot>   "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z"
21:00:45 <lispy> > take 5 $ zipWith (,) (fix show) (tail (fix show))
21:00:46 <lambdabot>   [('"','\\'),('\\','"'),('"','\\'),('\\','\\'),('\\','\\')]
21:00:47 <dmwit> unsafePerformIO (weirdPeopleOut >> return (fix show))
21:00:53 <mmorrow> > (\sep -> fix (\k xs -> list xs (\x ys -> list xs (\_ _ -> x:sep:k ys) ys) xs)) ',' ['a']
21:00:54 <lambdabot>   "a"
21:00:59 <mmorrow> > (\sep -> fix (\k xs -> list xs (\x ys -> list xs (\_ _ -> x:sep:k ys) ys) xs)) ',' []
21:01:01 <lambdabot>   ""
21:01:03 <sjanssen> dmwit: give up?
21:01:08 <dmwit> soon
21:01:13 <mmorrow> @pl \sep -> fix (\k xs -> list xs (\x ys -> list xs (\_ _ -> x:sep:k ys) ys) xs)
21:01:17 <lambdabot> fix . flip flip id . ((ap . ap list) .) . flip flip id . ((flip . ((flip . (ap .)) .) . flip ((.) . (.) . list) . ((const .) .)) .) . (((const .) .) .) . (flip ((.) . (:)) .) . (.) . (:)
21:01:17 <lambdabot> optimization suspended, use @pl-resume to continue.
21:01:26 <mmorrow> hmm
21:01:31 <mmorrow> @pl-resume
21:01:34 <lambdabot> fix . flip flip id . ((ap . ap list) .) . flip flip id . ((flip . ((flip . (ap .)) .) . flip ((.) . (.) . list) . (((const . const) .) .) . flip ((.) . (:))) .) . (.) . (:)
21:01:36 <Twey> dmwit: It's only magical in that it requires an extension in order to define it.
21:01:45 <dmwit> Twey: eh?
21:01:50 <dmwit> :t showList
21:01:51 <lambdabot> forall a. (Show a) => [a] -> String -> String
21:02:25 <mmorrow> @unpl fix . flip flip id . ((ap . ap list) .) . flip flip id . ((flip . ((flip . (ap .)) .) . flip ((.) . (.) . list) . (((const . const) .) .) . flip ((.) . (:))) .) . (.) . (:)
21:02:26 <lambdabot> (\ ax -> fix (\ f -> (list >>= \ bo -> (\ r u -> (\ af -> list r (\ _ _ -> ((:)) u (((:)) ax (f af)))) >>= \ cj -> (\ o -> o) >>= \ ci -> return (cj ci)) >>= \ bn -> return (bo bn)) >>= \ bi -> (\ g
21:02:26 <lambdabot> -> g) >>= \ bh -> return (bi bh)))
21:03:13 <Twey> dmwit: TypeSynonymInstances
21:03:17 <Twey> type String = [Char]
21:03:33 <dmwit> I thought it just used showList.
21:03:47 <dmwit> instance Show a => Show [a] where show xs = showList xs
21:03:49 <Twey> It may do, but the types are still impossible
21:04:00 <dmwit> Impossible?
21:04:05 <sjanssen> Twey: that is incorrect, look more closely at the Show class
21:04:22 <sjanssen> Show has a specific hack to work around the overlapping [] instances
21:04:35 <lispy> > take 50 $ map length $ group $ zipWith (,) (fix show) (tail (fix show))
21:04:37 <lambdabot>   [1,1,1,2,1,1,6,1,1,14,1,1,30,1,1,62,1,1,126,1,1,254,1,1,510,1,1,1022,1,1,20...
21:04:52 <lispy> ?oenis 1 2 6 14 30 62
21:04:52 <lambdabot>  Expansion of (1-x+2x^2)/((1-x)(1-2x)).
21:04:52 <lambdabot>  [1,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,262...
21:05:00 <lispy> now, is that weird or what?
21:05:18 <BMeph> "what"? ;)
21:05:19 <Twey> sjanssen: Ooh
21:05:27 <Twey> I see it
21:05:36 <Cale> Not *so* weird.
21:05:46 <unmarshal> has anyone had any memory issues using libcurl bindings?
21:05:53 <dmwit> sjanssen: There's got to be some seq going on here, but I haven't unraveled it yet.
21:05:54 <Twey> @src String showsPrec
21:05:54 <lambdabot> Source not found. Sorry.
21:05:59 <unmarshal> just curious, i might rework the haskell s3 library to use it instead of HTTP
21:06:01 <Twey> :(
21:06:04 <Twey> Er
21:06:06 <Cale> > group $ zipWith (,) (fix show) (tail (fix show))
21:06:07 <lambdabot>   [[('"','\\')],[('\\','"')],[('"','\\')],[('\\','\\'),('\\','\\')],[('\\','"...
21:06:09 <Twey> @src Char showsPrec
21:06:09 <lambdabot> Source not found. Where did you learn to type?
21:06:11 <sjanssen> dmwit: have you seen all inputs and outputs?
21:06:15 <Twey> Bah humbug
21:06:16 <dmwit> I don't think so.
21:06:28 <dmwit> sjanssen: I'm going slow, because I'm worried I'll accidentally read the answer.
21:06:31 <lispy> Cale: replace zipWith (,) with zipWith (==) to get faster convergence on the sequence
21:06:32 <sw17ch> What's an 'orphan instance'?
21:06:39 <Cale> > group $ zipWith (==) (fix show) (tail (fix show))
21:06:41 <lambdabot>   [[False,False,False],[True,True],[False,False],[True,True,True,True,True,Tr...
21:07:18 <pumpkin_> what things does lambdabot include by default?
21:07:25 <Cale> > length . group $ zipWith (==) (fix show) (tail (fix show))
21:07:27 <Twey> > snd (1, [1..])
21:07:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:07:29 <Cale> > map length . group $ zipWith (==) (fix show) (tail (fix show))
21:07:36 <lambdabot>   mueval: Prelude.read: no parse
21:07:36 <Twey> > fst (1, [1..])
21:07:41 <lambdabot>   1
21:07:45 <lambdabot>   thread killed
21:07:46 <dmwit> > let x = show $! x in x
21:07:51 <Twey> > [1..] `seq` 1
21:07:59 <Twey> seq still gets me
21:08:01 <lambdabot>   1
21:08:01 <lambdabot>   thread killed
21:08:13 <Twey> I know what it does, but... *shakes head*
21:08:16 <dmwit> thread killed?
21:08:17 <Twey> Like, why does that work?
21:08:26 <Cale> Twey: it only evaluates up to determining the top level dataconstructor
21:08:28 <sjanssen> dmwit: 12:53:09 is when the answer is revealed
21:08:30 <lispy> Twey: because [1..] isn't needed?
21:08:32 <dmwit> Twey: It works because seq only goes to the top constructor.
21:08:38 <Twey> Oh right
21:08:39 <dmwit> sjanssen: Many thanks.
21:08:40 <dolio> seq sees (stuff:stuff) and is done.
21:08:54 <Twey> > (length [1..]) `seq` 1 -- So...
21:09:00 <dmwit> > let x = '"' : x `seq` show x in x
21:09:03 <lambdabot>   mueval: Prelude.read: no parse
21:09:07 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:09:11 <dmwit> > let x = '"' : x `seq` show x in head x
21:09:12 <lispy> > length [1..] -- so did you prove anything?
21:09:13 <lambdabot>   '"'
21:09:16 <pumpkin_> @src seq
21:09:17 <Twey> No parse?  *blinks*
21:09:18 <lambdabot> Source not found. There are some things that I just don't know.
21:09:18 <lambdabot>   mueval: Prelude.read: no parse
21:09:38 <dmwit> Twey: the periods in your comment, prbably
21:09:38 <Cale> > map length . group $ zipWith (==) (fix show) (tail (fix show))
21:09:46 <Twey> pumpkin_: seq is magic.
21:09:46 <dmwit> Twey: Oh, never mind.
21:09:49 <Twey> Oh
21:09:49 <Cale> oh, right.
21:09:51 <sw17ch> better yet, how do i avoid the orphan instance warning
21:09:52 <Twey> BHmn
21:09:54 <dmwit> Twey: It just couldn't parse the error output.
21:09:54 <Twey> Heh
21:09:55 <lambdabot>   thread killed
21:09:56 <pumpkin_> Twey: interesting
21:09:57 <Cale> > take 10 . map length . group $ zipWith (==) (fix show) (tail (fix show))
21:09:59 <sw17ch> or, make it go away the right way
21:10:01 <lambdabot>   [3,2,2,6,2,14,2,30,2,62]
21:10:11 <Twey> dmwit: Oh :(
21:10:51 <pumpkin_> anyone know what lambdabot includes?
21:10:56 <lispy> > take 10 . filter (/=2) . map length . group $ zipWith (==) (fix show) (tail (fix show))
21:10:57 <Cale> pumpkin_: lots of stuff
21:10:58 <lambdabot>   [3,6,14,30,62,126,254,510,1022,2046]
21:11:04 <Cale> pumpkin_: too much to list
21:11:21 <Cale> pumpkin_: (at least on IRC)
21:11:38 <sjanssen> @botsnack
21:11:42 <lambdabot> :)
21:12:01 <Cale> A large chunk of the hierarchical libraries, along with a bunch of things from various packages on hackage.
21:12:15 <sm> how do I most easily match a non-space with parsec ?
21:12:21 <sm> non-whitespace
21:12:33 <pumpkin_> Cale: cool
21:12:44 <lispy> > 1 : 2 : take 10 . filter (/=2) . tail . map length . group $ zipWith (==) (fix show) (tail (fix show))
21:12:45 <lambdabot>   Couldn't match expected type `[t]'
21:12:54 <lispy> > 1 : 2 : (take 10 . filter (/=2) . tail . map length . group $ zipWith (==) (fix show) (tail (fix show)))
21:12:55 <lambdabot>   [1,2,6,14,30,62,126,254,510,1022,2046,4094]
21:13:13 <lispy> It's like fibbonaci...but not at all similar
21:13:16 <ddarius> @free seq
21:13:17 <lambdabot> g . seq x = seq (f x) . g
21:13:32 <pumpkin_> in ghc, is there a penalty to including more than you need? or does it lazily generate code too?
21:13:41 <ddarius> satisfy (not . isSpace)
21:13:47 <Pseudonym> @ft seq
21:13:48 <lambdabot>  fd:5: hClose: resource vanished (Broken pipe)
21:13:52 <sm> ah.. thanks ddarius
21:13:54 <Pseudonym> Hrm.
21:14:08 <Cale> > take 10 . map length . group . filter (== ('\\','\\')) $ zipWith (,) (fix show) (tail (fix show))
21:14:24 <lambdabot>   thread killed
21:14:34 <dolio> That's a quality theorem.
21:14:48 <ddarius> dolio: You get what you pay for.
21:15:03 <dolio> @ft seq
21:15:07 <Cale> oh, duh ;)
21:15:30 <Cale> > take 10 . map length . filter ((== ('\\','\\')).head) . group $ zipWith (,) (fix show) (tail (fix show))
21:15:31 <Samy> What does botsnack do?
21:15:37 <ddarius> @botsnack
21:15:43 <Twey> Makes \b happy.
21:15:44 <Cale> Makes the bot smile.
21:15:50 <Samy> He isn't smiling. :-(
21:15:52 <Samy> @botsnack
21:15:54 <dmwit> Just 'J'?
21:16:19 <Twey> > fix $ show . Just
21:16:21 <dmwit> sjanssen: Is this some kind of coercion from Maybe to [] or something terrible like that?
21:16:28 * Cale wonders what things are looking like on lispy's machine atm.
21:16:31 <Twey> I think we broke her.
21:16:34 * Cale tries to ssh in.
21:16:39 <sjanssen> dmwit: no unsafeCoerce or anything like that
21:16:45 <lispy|web> Cale: terrible, because lambdabot runs away :(
21:16:45 <Twey> > 5
21:16:54 <sjanssen> > mkV (\v -> take 1 v)
21:16:55 <Twey> Dead :(
21:17:17 <sjanssen> @botsnack
21:17:24 <Cale> lispy|web: I can't ssh into it.
21:17:28 <Samy> heh
21:17:33 <Cale> Or... it's being very slow.
21:17:34 <lispy|web> Cale: right
21:17:58 <lambdabot>  fd:5: hClose: resource vanished (Broken pipe)
21:17:58 <lispy|web> Cale: this has been happening lately when lambdabot gets a lot of requests I think
21:18:02 <ddarius> lambdabot has higher priority than sshd
21:18:04 <sjanssen> I might have accidentally broken it with mkV.  If I did, mueval has a vulnerability that needs fixing
21:18:20 <Twey> No, sjanssen  that was earlier
21:18:21 <Samy> @botsnack
21:18:30 <Cale> mkV?
21:18:31 <Twey> Last statement was: 051408 < Cale> > take 10 . map length . group . filter (== ('\\','\\')) $ zipWith (,) (fix show) (tail (fix show))
21:18:42 <sjanssen> Twey: I was privmsging
21:18:59 <Twey> Then `@ft seq` got no response
21:19:02 <Twey> Oh
21:19:04 <Twey> Heh
21:19:11 <Samy> He replied
21:19:15 <Samy> After some minutes.
21:19:17 <BMeph> > 1 : 2 : 4:(take 10 . map (+2) . filter (/=2) . tail . map length . group $ zipWith (==) (fix show) (tail (fix show)))
21:19:26 <dolio> Yeah, only took two minutes. :)
21:19:29 <Cale> Dude! No more!
21:19:35 <ddarius> Poor 'bot
21:19:46 <sjanssen> lispy|web: do you have physical access to the machine?  Try forcing the OOM killer to run
21:19:48 <lispy|web> Cale: I guess in the future, we need to 'nice' lambdabot
21:19:55 <lispy|web> sjanssen: no physical access
21:20:15 <glguy> How do you force the OOM killer to run?
21:20:27 <dmwit> run out of memory
21:20:27 <sjanssen> alt-sysrq-f IIRC
21:20:30 <Elly> malloc(UINT_MAX);
21:20:36 <dmwit> Elly: Doesn't work.
21:20:53 <Elly> dmwit: er, use calloc :P
21:20:54 <dmwit> Elly: Lazy evaluation in malloc, believe it or not.
21:21:00 <dmwit> (More accurately, in the kernel.)
21:21:01 <lispy|web> mibbit does smilies now...can't read code...
21:21:06 <Elly> well, linux just overcommits :P
21:21:07 <Samy> Mapping a page doesn't mean much.
21:21:16 <dmwit> (So, changing allocators won't help unless your allocator just so happens to write to every page.)
21:21:29 <Samy> Swapping is non-trivial without over-commit :-P
21:21:31 <Elly> calloc does
21:21:35 <Elly> calloc has to zero memory :P
21:21:44 <sjanssen> glguy: yeah, alt-sysrq-f -- Linux of course
21:21:45 <Cale> Can't it do that lazily too?
21:21:47 <dblazakis> Elly: actually it will do that on demand too
21:21:50 <Elly> Cale: not in userland
21:21:55 <lambdabot> :)
21:21:55 <lambdabot> :)
21:21:55 <lambdabot> :)
21:21:55 <lambdabot> :)
21:21:58 <Cale> ahaha
21:21:59 <Samy> :D
21:22:01 <Elly> oh god the botsnacks
21:22:03 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096]
21:22:05 <lambdabot>   "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\...
21:22:07 <lambdabot>   "\"\\\"\""
21:22:09 <lambdabot>   5
21:22:11 <lambdabot>   [2,6,14,30,62,126,254,510,1022,2046]
21:22:15 <dmwit> Heeeeere comes Jonny!
21:22:19 <lispy> Cale: please ssh in and 'nice' the bot :)
21:22:24 <waynemokane> how can this data constructor be split up so its arguments are on different lines?
21:22:31 <lispy> Cale: I'll check the logs
21:22:39 <waynemokane> data Type = T Int Int [Int]
21:22:52 <dmwit> waynemokane: Just put them on different lines.  Make sure to indent a little bit.
21:22:55 <waynemokane> data Type = T
21:22:55 <waynemokane>    Int
21:22:55 <waynemokane>    Int
21:22:55 <waynemokane>    Int
21:22:57 <waynemokane> ?
21:22:59 <Cale> lispy: Isn't it each mueval which needs renicing? Or will renicing the bot force that?
21:23:01 <dmwit> Yes.
21:23:05 <glguy> <Alt><SysRq><k> Kill all processes (including X) which are running on the currently active virtual console. This key combination is know as "secure access key" (SAK).
21:23:08 <glguy> whoa
21:23:15 <Twey> Heh
21:23:16 <glguy> I've needed this so many times with linux
21:23:23 <sjanssen> Cale: niceness is inherited from the parent
21:23:23 <Twey> You never knew about SAK?
21:23:23 <glguy> I can't wait to use it next time
21:23:45 <Twey> A parent can't create a child of higher priority than itself, I think
21:23:57 <lispy> Oct 15 21:20:16 olive kernel: klogd invoked oom-killer: gfp_mask=0x201d2, order=0, oomkilladj=0
21:24:36 <dmwit> > fromDyn (toDyn (Just 'a')) :: String
21:24:37 <lambdabot>   Couldn't match expected type `String'
21:24:43 <dmwit> > fromDyn (toDyn (Just 'a')) :: Maybe String
21:24:44 <lambdabot>   Couldn't match expected type `Maybe String'
21:24:48 <dmwit> :t fromDyn
21:24:50 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
21:24:50 <Cale> > take 20 . map length . filter ((== ('\\','\\')).head) . group $ zipWith (,) (fix show) (tail (fix show))
21:24:56 <lambdabot>   [2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,2621...
21:25:13 <dmwit> > fromDyn "foo" (toDyn (Just 'a')) :: Maybe String
21:25:14 <mrd> > fromDyn (toDyn (Just 'a')) "x"
21:25:14 <lambdabot>   Couldn't match expected type `Dynamic'
21:25:15 <lambdabot>   "x"
21:25:19 <Cale> So it's the lengths of the \\ groups.
21:25:29 <dmwit> mrd: Thanks.
21:25:30 <dmwit> =P
21:25:35 <mrd> np!
21:25:44 <Twey> Can't you just do...
21:25:47 <Twey> Oh no, of course not
21:25:50 <Twey> group can't be lazy, huh
21:26:08 <sjanssen> lispy: niceness might not help much in an OOM situation, however
21:26:09 <Cale> oh...
21:26:25 <lispy> sjanssen: yeah, I was just pondering that
21:26:26 <Cale> > take 20 . map length . filter ((== '\\').head) . group $ fix show
21:26:28 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
21:26:36 <waynemokane> dmwit: can you please take a look:  http://hpaste.org/11186
21:26:46 <sjanssen> Linux is absolutely horribly under any sort of memory and disk pressure
21:26:55 <waynemokane> dmwit: can't figure out how to get the indentation right.  need the comments for haddock
21:26:59 <Cale> > take 20 . map (+1) . map length . filter ((== '\\').head) . group $ fix show
21:27:08 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
21:27:11 <dmwit> waynemokane: Does it compile if you don't try to build it with haddock?
21:27:18 <dmwit> waynemokane: If so, it's a haddock bug.
21:27:18 <Cale> Not quite the same...
21:27:35 <Cale> er
21:27:41 <Cale> > take 20 . map (subtract 1) . map length . filter ((== '\\').head) . group $ fix show
21:27:43 <lambdabot>   [0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,26...
21:27:56 <rwbarton> right, \\\\\ has 5 \s but only 4 pairs \\
21:28:26 <waynemokane> dmwit: crap :(   OK
21:28:28 <sjanssen> waynemokane: deriving needs to be indented further than data
21:28:44 <sjanssen> I think.
21:28:55 <waynemokane> sjannsen: yeah I figured that out exactly after I pasted.  however, still the same complaint in haddock
21:29:04 <waynemokane> sjanssen: but it makes ghc happy
21:29:16 <sjanssen> waynemokane: indenting beyond the "=" might help
21:30:50 <dmwit> sjanssen: Oh my god.
21:31:31 <Cale> @oeis 0,2,6,14,30,62,126,254,510,1022,2046,4094,8190
21:31:32 <lambdabot>  2^n - 2.
21:31:32 <lambdabot>  [1,0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,2...
21:31:54 <dmwit> I would never have figured that out.
21:32:19 <Cale> That first term was a bit strange.
21:32:25 <Cale> @oeis 1,2,6,14,30,62,126,254,510,1022,2046,4094,8190
21:32:26 <lambdabot>  Expansion of (1-x+2x^2)/((1-x)(1-2x)).
21:32:26 <lambdabot>  [1,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,262...
21:32:37 <rwbarton> > fix show
21:32:38 <Cale> They give a sort of obfuscated generating series.
21:32:38 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:33:12 <Pseudonym> > group . fix $ show
21:33:14 <lambdabot>   ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\...
21:33:27 <pumpkin_> wow
21:33:29 <waynemokane> crap maybe haddock can't do what I'm trying to do... the documentation doesn't talk about commenting individual data constructor args
21:33:40 <Pseudonym> > filter (/= "\"") . group . fix $ show
21:33:41 <lambdabot>   ["\\","\\\\\\","\\\\\\\\\\\\\\","\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\","\\\\\\\\\...
21:33:42 <waynemokane> but now I'm just confused cause I thought data constructors were just functions
21:33:51 <Pseudonym> > map length . filter (/= "\"") . group . fix $ show
21:34:03 <lambdabot>   mueval: Prelude.read: no parse
21:34:27 <Samy> @oeis 1, 9, 111, 192, 338, 1901, 12919
21:34:28 <lambdabot>  Sequence not found.
21:34:29 <Pseudonym> > map length . take 7 . filter (/= "\"") . group . fix $ show
21:34:33 <lambdabot>   [1,3,7,15,31,63,127]
21:35:13 <Samy> @oeis 254,510,1022,2046,4094,8190
21:35:14 <lambdabot>  2^n - 2.
21:35:14 <lambdabot>  [1,0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,2...
21:37:09 <lispy> 2^n - 2, makes a lot of sense
21:37:52 <rwbarton> waynemokane: It seems to work if you use record syntax.
21:38:05 <dolio> What's with that 1? Does it not parse negatives at the beginning of the list?
21:38:37 <rwbarton> No, OEIS just doesn't store negative numbers, it replaces them by their absolute values
21:38:43 <dolio> Ah.
21:39:08 <rwbarton> Some sequences now have the signed version as an extra field
21:39:34 <rwbarton> Although, that one has -1 in the main entry, so...
21:40:01 <rwbarton> I guess they
21:40:12 <dolio> @oeis 1, -1, 2, -3, 5, -8
21:40:12 <lambdabot>  a(n+2)=-a(n+1)+a(n) (signed Fibonacci numbers); or Fibonacci numbers (A00004...
21:40:12 <lambdabot>  [1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10...
21:40:14 <rwbarton> 've improved the sign situation, and this is a parsing issue in oeis
21:42:44 <Cale> Hmm... does there exist a context free language L such that the number of strings of length n in L is the nth prime?
21:44:13 * mml` smells homework.
21:44:25 <Cale> I'm not at a university :)
21:44:47 <mml`> mea culpa
21:44:47 <dolio> Cale writes homework problems for himself!
21:44:48 <dons> mmm
21:45:02 <Twey> Hahaha
21:45:09 <dons> i'd be surprised, Cale.
21:45:10 <Cale> dolio: that's about right :)
21:45:12 <dblazakis> @oeis 3, 43, 10379, 679510155
21:45:13 <lambdabot>  Sequence not found.
21:45:27 <Cale> dons: I would too, but I'm not sure that I have any tools for attacking the problem either.
21:45:45 <dons> true.
21:46:15 <dons> Cale, you should drop it by sigfpe
21:46:23 <Cale> Heh, "Suppose that L is a language such that the number of strings of length n in L is the nth prime. Show that L is not regular."
21:46:47 <Cale> Somehow it seems even more hopeless turned around like that ;)
21:46:54 <dons> yes.
21:48:27 <Cale> (Or not context free)
21:51:54 <lispy> Cale: oh, primality and languages...hmm...I seem to recall discussing this in a class I took but your question
21:52:16 <Cale> The regular case seems almost approachable.
21:57:14 <rwbarton> If I have a context-free grammar, can I replace it with one that defines the same language in which every string of that language has a *unique* parse?
21:57:30 <Cale> rwbarton: Apparently not.
21:57:31 <b7j0c> a question: let us say i define an error type like "data Foo = FooErr | IOError"...and then i define a Show instance for this. is it correct to skip defining a show instance for IOError (because i presume one is already defined)??
21:57:37 <dblazakis> Can you define a language L of a single symbol s.t. only symbols of prime length are accepted?
21:57:39 <rwbarton> If so, then your question probably comes down to some algebraic property of sum p_n x^n
21:57:42 <rwbarton> Ah, alas
21:57:49 <dblazakis> sorry a context free language
21:58:04 <sjanssen> b7j0c: "data Foo = FooErr | IOError" probably doesn't mean what you think it does
21:58:33 <jdrake> hey, do we have a channel bot written in haskell that is easy to get running that can manage ops and such like that? (not for freenode)
21:58:34 <b7j0c> sjanssen: ok...what i want is to have an error type that can have my own errors, or IOError
21:58:53 <sjanssen> b7j0c: data Foo = FooErr MyErrors | IOE IOError
21:58:56 <rwbarton> dblazakis: I'm pretty sure the pumping lemma says no
21:59:06 <Cale> I agree with rwbarton there.
21:59:40 <b7j0c> thanks sjanssen! i am confused as to where IOE comes from
21:59:44 <b7j0c> sorry for being dense...
21:59:53 <rwbarton> Cale: do you know of a counterexample for my question?  Just out of curiosity
21:59:54 <dolio> Dude, you can do it with Perl regexes. It's regular. :)
22:00:39 <Cthulhon> You can do a primality test on a single symbol language with a regex.
22:00:40 <sjanssen> b7j0c: Haskell types are tagged unions, "IOE" is the tag we use in the case of an IOError
22:00:48 <Cale> rwbarton: one sec
22:00:53 <Cthulhon> I.e. prime length test.
22:01:08 <Saizan> b7j0c: the declaration data Foo = FooErr MyErrors | IOE IOError defines a type Foo and two constructors for it: FooErr :: MyErrors -> Foo, and IOE :: IOError -> Foo
22:01:27 <b7j0c> sjanssen: ok thanks. so would i be able to skip a show instance for this since one is already defined?
22:01:40 <sjanssen> b7j0c: yes
22:01:49 <Cale> The union of {a^n b^m c^m d^n | n,m > 0} with {a^n b^n c^m d^m | n,m > 0}
22:02:00 <b7j0c> thanks Saizan! makes sense when i consider it that way
22:02:39 <Cale> Apparently the strings in the (non-context-free) subset {a^n b^n c^n d^n | n > 0} cannot be parsed unambiguously.
22:02:59 <Cale> (which is the intersection of the two languages)
22:03:20 <rwbarton> Hmm, seems believable.
22:03:24 <rwbarton> What about regular languages?
22:04:10 <Cale> Those I think are doable.
22:06:43 <b7j0c> well thanks everyone for the info! have a great night
22:06:44 <rwbarton> If so, then since sum p_n x^n is obviously not rational, you can't find a regular language with that property
22:08:13 <Cale> hmm
22:08:18 <paczesiowa> can I run scripts with runhuskell in hashbang without .hs suffix?
22:08:22 <Cale> "obviously not rational"?
22:09:25 <rwbarton> Well, the coefficients of rational generating series are of the form P_1(n) a_1^n + P_2(n) a_2^n + ... for some reals a_i and polynomials P_i
22:09:44 <rwbarton> so they can't grow as n log n
22:10:16 <rwbarton> (I guess it's not quite obvious, you have to make sure that non-real a_i won't mess up the size of the coefficients much.)
22:11:16 <Saizan> paczesiowa: i think you can with ghc 6.10
22:11:22 <dblazakis> rwbarton: yes, you're right, the pumping lemma disproves it
22:12:08 <Cale> rwbarton: ah, okay
22:12:09 <rwbarton> A better thing to say is just that the primes don't satisfy any fixed linear recurrence of any order.
22:13:14 <rwbarton> (Because if they did, I could pick some large prime modulo which the sequence would have to be periodic, but it has exactly one zero)
22:14:17 <Saizan> paczesiowa: see section 1.4.6 http://www.haskell.org/ghc/dist/stable/docs/users_guide/release-6-10-1.html
22:14:21 <lambdabot> Title: 1.4.Release notes for version 6.10.1, http://tinyurl.com/4dp79v
22:16:12 <paczesiowa> Saizan: thanks
22:17:22 <paczesiowa> so what is 6.10 status currently? I think I remember dons's post from proggit that 25% packages doesn't build, anything changed?
22:18:12 <dons> mm. 'elastic tabs' as a way to efficiently implement layout? http://nickgravgaard.com/elastictabstops/index.html
22:18:17 <lambdabot> Title: Elastic tabstops - a better way to indent and align code
22:18:18 <electronx> how to create a polymorphic function?
22:18:19 <dons> paczesiowa: 25%??
22:18:32 <dons> paczesiowa: i think you misread.. 8% was the maximum, its about 4% now.
22:18:36 <paczesiowa> dons: or was it 8?
22:18:37 <electronx> i have two diff types and i want to compare them
22:18:46 <paczesiowa> dons: yeah, my bad
22:18:47 <mauke> electronx: f x = x  -- polymorphic
22:18:49 <electronx> but i can't do that offcourse
22:19:08 <electronx> what about f x y = x == y
22:19:09 <dons> paczesiowa: the status is that most of what is left now is easy, and the bugs that were uncovered are fixed
22:19:12 <dons> so close
22:19:15 <mauke> electronx: oh, you want PHP's ===?
22:19:34 <paczesiowa> dons: thanks
22:19:37 <electronx> no i just want to compare to diff things
22:19:43 <mauke> x === y  =  cast x == Just y
22:20:00 <electronx> ie cmp IRegister FRegister = False
22:20:17 <mauke> @let x === y  =  cast x == Just y
22:20:18 <electronx> ie cmp IRegister IRegister = x == y
22:20:20 <lambdabot>  Defined.
22:20:25 <mauke> > 1 === 1
22:20:26 <lambdabot>   True
22:20:29 <mauke> > 1 === 2
22:20:31 <lambdabot>   False
22:20:34 <mauke> > 1 === "hello"
22:20:35 <lambdabot>   False
22:20:42 <electronx> > 1 === "h"
22:20:43 <lambdabot>   False
22:20:51 <electronx> cool
22:21:15 <electronx> how does that work?
22:21:19 <rwbarton> electronx: that requires that you derive the Typeable class for your data types
22:21:19 <mauke> hax
22:21:26 <mauke> also, Data.Typeable
22:21:48 <mauke> docs at http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
22:21:50 <lambdabot> Title: Data.Typeable, http://tinyurl.com/ylclo5
22:22:01 <rwbarton> It's a slightly un-Haskelly thing to do
22:22:02 <mauke> the main interesting functions in there are typeOf and cast
22:22:35 <electronx> lol thanks mauke
22:22:50 <electronx> i thought i need to do this with classes or something
22:23:03 <mauke> well, Typeable is a class
22:23:08 <electronx> seems there is a hack for it :)
22:23:10 <mauke> :t (===)
22:23:12 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
22:24:20 <rwbarton> It can't be *that* bad of a hack, since the compiler will automatically derive Typeable instances if you ask it to.  Still, it feels weird to me.
22:25:24 <electronx> error you need XDerivable blah blah
22:25:29 <electronx> what does that mean
22:25:55 <electronx> -XDeriveDataTypable*
22:26:29 <electronx> how do i turn it on in ghci?
22:26:35 <rwbarton> :set -XDeriveDataTypeable
22:26:41 <mauke> yeah, you need to enable a language extension since Typeable is not in H98
22:26:42 <electronx> thanks
22:26:43 <rwbarton> (if that's the real spelling)
22:27:02 <mauke> just put {-# LANGUAGE DeriveDataTypeable #-} at the top of your source file
22:27:08 <rwbarton> but... you can't define data in ghci so that won't help.
22:27:15 <rwbarton> yeah, do what mauke said instead
22:27:34 <electronx> ok thanks both of you
22:33:00 <pumpkin_> I was going to write a simple matrix class with a list of lists... is there an implicit way for me to enforce that the inner lists all be the same length?
22:33:57 <dcoutts> pumpkin_: not a simple and easy way. There are some more heavyweight typed encodings that would let you do that.
22:34:05 <pumpkin_> ah
22:34:36 <pumpkin_> so nothing as nice as [[x (make sure my length is n please)]]
22:34:44 <dcoutts> pumpkin_: nope
22:34:47 <Cale> pumpkin_: You could also use arrays indexed by pairs of integers.
22:35:29 <pumpkin_> ah, that could also work
22:35:38 <pumpkin_> or I guess I could have a single array with the nasty row math
22:35:38 <dmwit> pumpkin_: I have some code for dealing with multi-dimensional arrays lying around, would you like it as a starting point?
22:35:52 <dmwit> (Warning: totally gross, naively implemented, undocumented, etc. etc.)
22:36:01 <electronx> sick
22:36:04 <pumpkin_> sure, that would be nice... I just figured I'd set myself some things to do and see how I'd go about implementing them
22:36:05 <electronx> it works
22:36:09 <dcoutts> pumpkin_: 2d arrays are pretty easy, no need to do your own indexing in a 1d array
22:36:16 <dmwit> Actually, the interesting bit is the instance Ix a => Ix [a], all the rest is just sugar. =)
22:36:32 <pumpkin_> :o
22:37:43 <dmwit> http://dmwit.com/programming/MultiArray.hs
22:38:34 <rwbarton> pumpkin_: Since you've already looked at the type-level package a bit--you could write (Nat rows, Nat cols) => FSVec rows (FSVec cols a)
22:38:42 <dmwit> Ah, I see I already expanded the dependency on Dmwit.hs, I didn't need to make that available.  Oh well.
22:40:02 <pumpkin_> rwbarton: hmm, I'll look at that too, thanks
22:40:05 <pumpkin_> dmwit: thanks!
22:40:11 <pumpkin_> whoa, ***
22:40:38 <rwbarton> pumpkin_: Ah, actually parameterized-data is what you want
22:43:50 <dmwit> Ah, man, I did things totally backwards in here.
22:44:03 <dmwit> Somebody really ought to tell me about these things before I publish them on the Internet.
22:44:52 <jdrake> If one wanted to write an assembler in haskell, but where it was not for a specific architecture - would it be particularily hard, or potentially easy? I have an idea on how it could be done in C, not sure about haskell.
22:45:06 <dmwit> You should take a look at Harpy.
22:45:14 <dmwit> It is x86-specific, but it could give you some ideas.
22:45:22 <dmwit> ?where harpy
22:45:22 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
22:46:24 <jdrake> That looks like somtehing used from haskell, not a separate assembler itself
22:46:30 <dmwit> true
22:46:53 <dmwit> I might be a bit unclear on exactly what an assembler does.
22:46:57 <rwbarton> It's the "back end" of an assembler.
22:47:32 <scook0> well, an assembler is mostly "parse text => emit bytes", isn't it?
22:47:35 <jdrake> dmwit, specifically translating mnemonics from text into a hex file
22:47:36 <scook0> (a simple one anyway)
22:47:40 <jdrake> scook0, yes
22:47:51 <dmwit> Ah, well, then Parsec is probably the way to go.
22:47:59 <dmwit> Just build up a good ol' result as you go along.
22:48:01 <scook0> haskell will certainly help you with part 1 (Parsec)
22:48:01 <rwbarton> The "front end" could parse assembly language instructions and produce actions in whatever the Harpy monad is called
22:48:02 <jdrake> dmwit, I think I might look into it shortly :p
22:48:14 <scook0> and I don't imagine part 2 would be problematic either
22:48:29 <rwbarton> It gets a little interesting when you want to handle things like labels.
22:48:31 <jdrake> I wouldn't want ghc to have any part outside of compiling the assembler itself
22:48:41 <jdrake> rwbarton, luckily all the syntax is the same :P
22:49:45 <dmwit> rwbarton: Yeah, I got stuck on labels when I tried to define my own such Monad.
22:49:48 <dmwit> I wonder how Harpy does it.
22:49:52 * dmwit peeks
22:49:57 <Saizan> labels require either 2 passes or a nice trying the knot trick
22:50:07 <Saizan> *tying
22:50:23 <rwbarton> Or mutable state, which is what I think Harpy does...
22:50:24 <dmwit> Looks like Harpy does two passes.
22:50:27 <Saizan> there's an article on it in an issue of the Monad.Reader
22:50:37 <rwbarton> I guess that's the two pass approach
22:50:39 <dmwit> data FixupKind = ...
22:51:01 <rwbarton> But yeah, you can also use mdo
22:51:15 <dmwit> Then you have to define mfix for you monad. =P
22:51:48 <rwbarton> Well, isn't the monad basically Writer?
22:51:51 <dmwit> emitFixup :: Label -> Int -> FixupKind -> CodeGen e s () -- such descriptive types
22:55:10 <dmwit> Oh, that's easy.
23:13:32 <Pseudonym> .quit
23:20:03 <electronx> whats the function to get an infinite list of random numbers in a range?
23:20:27 <Saizan> randomRs
23:20:31 <electronx> thanks
23:21:38 <electronx> i don't get it why is www.hoogle.org some random site??
23:22:00 <quicksilver> because neil didn't think it was worth trying to buy the domain?
23:22:04 <quicksilver> @go hoogle
23:22:06 <electronx> nvm
23:22:07 <lambdabot> http://www.haskell.org/hoogle/
23:22:07 <lambdabot> Title: Hoogle
23:22:20 <electronx> i got mixed up
23:22:23 <electronx> srry
23:22:47 <dmwit> That site really is quite random.
23:22:50 <electronx> i thought hoogle.org was supposed  to be hoogle
23:22:58 <electronx> sigh nvm
23:23:13 <b7j0c> hi, a question. does anyone know how to define a MonadPlus instance for an Either type?
23:23:23 <dmwit> ?instances MonadPlus
23:23:24 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
23:23:31 <dmwit> b7j0c: It's already got one.
23:23:53 <quicksilver> dmwit: it's only had 12,000 visitors since 2004. That's got to make it one of the least successful sites on the interweb, ever.
23:24:00 <b7j0c> dmwit: can you explain? sorry for being dense...does mplus already exist for Either?
23:24:07 <dmwit> :t mplus
23:24:08 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
23:24:11 <dmwit> b7j0c: yes
23:24:17 <b7j0c> AH
23:24:20 <paczesiowa> @src MonadPlus (Either e)
23:24:20 <lambdabot> Source not found. Are you on drugs?
23:24:21 <dmwit> > Left "hey" `mplus` Right 3
23:24:23 <lambdabot>   Right 3
23:24:26 <paczesiowa> @src MonadPlus Either
23:24:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:24:29 <paczesiowa> @src MonadPlus Either e
23:24:29 <lambdabot> Source not found. Just try something else.
23:24:33 <dmwit> ?src Either mplus
23:24:34 <lambdabot> Left _ `mplus` n = n
23:24:34 <lambdabot> m      `mplus` _ = m
23:24:37 <b7j0c> wow so helpful, thanks dmwit
23:24:59 <b7j0c> glad i came here , thanks! take care
23:25:12 <dmwit> hit'n'run
23:25:24 <dmwit> Reminds me of how I use #darcs and ##c++.
23:25:33 <paczesiowa> perhaps DUI
23:33:35 <b7j0c> me again
23:33:39 <b7j0c> back again...dmwit, you mentioned an instance for MonadPlus for
23:33:42 <b7j0c>         Either...is this in a newer version of haskell? this link:
23:33:45 <b7j0c>         file:///home/brad/docs/ghc/libraries/base/Control-Monad.html#t%3AMonadPlus
23:33:48 <b7j0c>         shows none..
23:33:49 <b7j0c> whoops, disregard a file:// url!
23:34:07 <b7j0c> but those are the 6.8.2 docs
23:34:07 <jdrake> Does ghc 6.10 add anything for dynamically loading modules? Specifically so you could have plugins
23:34:26 <dmwit> b7j0c: It's probably in Control.Monad.Instances.
23:34:31 <Saizan> ddarius++
23:34:57 <Saizan> (bashing the java interfaces == type classes meme)
23:35:00 <dmwit> jdrake: There is the GHC API.  I think it was new in 6.8; it may have changed in 6.10 (they make no promises of stability).
23:35:28 <dmwit> ?index mplus
23:35:28 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:35:56 <jdrake> dmwit, what was it called?
23:36:05 <dmwit> jdrake: It's just called the GHC API.
23:36:20 <jdrake> oh, when I mean plugins I mean program and plugins written in haskell
23:36:30 <dmwit> Yes, me too.
23:36:42 <b7j0c> hmmm, i don't think it is in Control.Monad.Instances (?)
23:36:52 <dmwit> b7j0c: Me neither.  I'm looking for it.
23:37:16 <rwbarton> Control.Monad.Error possibly?
23:38:03 <rwbarton> But it might come with a constraint on the Left type for annoying and silly technical reasons
23:38:20 <dmwit> rwbarton: Ah, yes, that seems to be it.
23:38:48 <dmwit> b7j0c: If you need an instance for non-Error left arguments, you can also get the category-extras package.
23:39:17 <b7j0c> cool dmwit, i will check it out
23:39:25 <dmwit> ?hackage category-extras
23:39:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
23:39:57 <dmwit> rwbarton: For fail, right?
23:41:11 <rwbarton> Yeah
23:41:34 <rwbarton> > Left 3 `mappend` Right "hello" :: Either Integer String
23:41:35 <lambdabot>       No instance for (Monoid (Either Integer [Char]))
23:41:35 <lambdabot>        arising from a ...
23:41:50 <dmwit> Okay, that explains why category-extras doesn't need that constraint, then.
23:42:17 <rwbarton> ?src Either mzero
23:42:18 <lambdabot> mzero            = Left noMsg
23:42:25 <rwbarton> ?src noMsg
23:42:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
23:42:26 <mmorrow> , Left 3 `mappend` Right "hello" :: Either Integer String
23:42:27 <lunabot>  luna: No instance for (Data.Monoid.Monoid
23:42:33 <idnar> > Left 3 `mplus` Right "hello" :: Either Integer String
23:42:34 <lambdabot>       No instance for (Error Integer)
23:42:34 <lambdabot>        arising from a use of `mplus' at...
23:42:35 <rwbarton> lame
23:42:52 <idnar> > Left 3 `mplus` Right 5 :: Either Integer String
23:42:52 <dmwit> :t noMsg
23:42:53 <lambdabot>       No instance for (Error Integer)
23:42:54 <lambdabot>        arising from a use of `mplus' at...
23:42:54 <lambdabot> forall a. (Error a) => a
23:42:55 <rwbarton> > mzero :: Either String String
23:42:55 <mmorrow> hmm, which category-extras mod is it in?
23:42:56 <lambdabot>   Left ""
23:43:05 <idnar> > Left 3 `mplus` Right 5 :: Either Integer Integer
23:43:06 <lambdabot>       No instance for (Error Integer)
23:43:06 <lambdabot>        arising from a use of `mplus' at...
23:43:11 <b7j0c> so to summarize, i can't just use Control.Monad.Error for arbitrary MonadPlus instances for Either? i'm getting confused again by the comments
23:43:11 <dmwit> mmorrow: Just at a guess, Control.Monad.Either?
23:43:20 <idnar> > Left "foo" `mplus` Right 5
23:43:21 <lambdabot>   Right 5
23:43:34 <mmorrow> because lunabot every cat-extras mod in scope except 3 or 4 which class with Prelude stuff
23:43:44 <dmwit> b7j0c: You can use it, if the left-hand type of your Either happens to be an instance of Error (or you can make it be one).
23:44:12 <dmwit> ?instances Error
23:44:13 <lambdabot> IOError, String
23:44:25 <dmwit> ?instances-importing Control.Monad.Error Error
23:44:26 <lambdabot> IOError, String
23:44:29 <dmwit> yikes
23:44:48 <b7j0c> hmm...ok, dmwit - do you mean ErrorT?
23:44:48 <dmwit> Control.Functor.Combinators.Biff -- heh
23:44:56 <Twey> O.O
23:44:58 <Twey> What's in there?
23:45:05 <mmorrow> http://moonpatio.com/docs/category-extras/
23:45:06 <rwbarton> , src PBiff
23:45:07 <lunabot>  luna: Not in scope: data constructor `PBiff'
23:45:10 <rwbarton> , src ''PBiff
23:45:10 <lambdabot> Title: category-extras-0.53.5: Various modules and constructs inspired by category theo ...
23:45:12 <lunabot>  luna: Not in scope: type constructor or class `PBiff'
23:45:21 <b7j0c> ah i see an Error class now
23:45:28 <dmwit> newtype Biff p f g a b = Biff (p (f a) (g b))
23:45:32 <b7j0c> Control.Monad.Error.Class ?
23:45:44 <dmwit> b7j0c: errr, what?
23:45:46 <rwbarton> I thought there was a more complicated one
23:45:52 <dmwit> b7j0c: Control.Monad.Error should be enough.
23:46:09 <rwbarton> , src ''BiffB
23:46:11 <lunabot>  luna: Not in scope: type constructor or class `BiffB'
23:46:13 <b7j0c> ok thanks dmwit. sorry to confuse you guys, you are way ahead of me
23:47:04 <dmwit> type Hask = (->)
23:47:21 <rwbarton> mmorrow: what version of category-extras do you have installed?
23:47:26 <dmwit> I need to take the time to sit down and understand a bit of category theory.
23:48:03 <rwbarton> mmorrow: Oh, I was looking at the documentation for an old version, never mind
23:48:24 <mmorrow> here're lunabot's imports and flags http://moonpatio.com/docs/lunabot_imports.hs
23:48:47 <mmorrow> fmap ((,) ("category-extras",[0,53,5]))
23:49:01 <mmorrow> is there a newer version?
23:49:49 <rwbarton> nope
23:51:10 <mmorrow> if anybody has an ideas/requests for imports to be added to lunabot i'll happily add them
23:51:16 <mmorrow> s/an/any/
23:51:58 <mmorrow> (as long as no names clash with commonly used already-in-scope one's, since the ghc-api can't do qualified import yet)
23:54:54 <mmorrow> , src ''Hask
23:54:59 <lunabot>  type Hask = (->)
23:55:00 <mmorrow> , src ''Mutual
23:55:06 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
23:55:06 <lunabot>                                                      (Mutual p n m a)))}
23:55:28 <mmorrow> that one smells useful
23:56:54 <mmorrow> also, and the haddocks for ghc are here: http://moonpatio.com/docs/ghc/
23:56:55 <lambdabot> Title: ghc-6.10.0.20081007: XXX
23:58:34 <mmorrow> (and HsColoured src is here http://moonpatio.com/docs/ghc/src)
23:58:36 <lambdabot> Title: Index of /docs/ghc/src
23:59:16 <mmorrow> i looked at the intricate options involved in getting the src links in the haddocks and immediately bailed
