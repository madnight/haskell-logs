00:07:38 <jganetsk> anyone here to answer a n00b question?
00:08:19 <shrughes> no
00:08:27 <shrughes> we are all here to answer experienced questions :)
00:08:53 <jganetsk> ok, i'm having trouble with ghc
00:08:55 <jganetsk> i'm getting errors like this
00:08:56 <jganetsk> lambda.o: In function `r10U_info':
00:08:56 <jganetsk> (.text+0x127e): undefined reference to `containerszm0zi1zi0zi1_DataziMap_insert_closure'
00:08:56 <jganetsk> lambda.o: In function `r110_info':
00:08:56 <jganetsk> (.text+0x3812): undefined reference to `containerszm0zi1zi0zi1_DataziMap_zn_closure'
00:08:57 <jganetsk> lambda.o: In function `r112_info':
00:08:59 <jganetsk> (.text+0x46d4): undefined reference to `containerszm0zi1zi0zi1_DataziMap_empty_closure'
00:09:03 <jganetsk> i just have one .hs file
00:09:07 <jganetsk> an it's importing Data.Map
00:09:32 <dolio> Use --make
00:10:00 <jganetsk> thank you!
00:10:24 <Cale> --make should be the default, I think
00:10:49 <dons> jganetsk: missing --make
00:11:11 <dolio> Yeah. It comes up a lot.
00:11:24 <dons> Cale: yeah, maybe people used to scripting/interpreters don't think about linking
00:11:26 <enolan> why does ghc have inconsistent dashing in its options? --make, but -prof -auto-all -package etc
00:11:37 <dons> it has its own unique perspective
00:12:02 <Cale> dons: Well, it's more that it clearly knows what package that thing is from.
00:12:18 <Cale> dons: It's stupid that one should have to specify it.
00:12:39 <dons> right, but if you're used to gcc , this is no surprise
00:12:43 <dolio> Most of the dashing is pretty good. Only a few outliers.
00:12:50 <Cale> Yeah, but there's a lot which is wrong with gcc.
00:12:56 <Cale> And C in general ;)
00:13:02 <dons> right, so more people are used to think like perl or python now
00:13:09 <dons> and the system looks up the package db
00:13:26 <dons> no one should use --make anyway, cabal forever!
00:13:46 <Cale> For small programs which you're not going to run more than once, cabal is silly :)
00:14:00 <dolio> I'm not going to write a .cabal for every Project Euler problem.
00:14:15 <dcoutts> in future cabal will not need .cabal files for simple projects
00:14:38 <dcoutts> it'll do what ghc --make does, but with more cool
00:14:51 <dolio> Well, that'll be nice.
00:15:03 <dons> right, small programs don't need --make
00:15:11 <dons> well, i guess sometimes they do
00:15:44 <Cale> dcoutts: Hehe, will it find and install appropriate packages from hackage if necessary? :)
00:16:02 <Cale> I suppose that could be hard to do unambiguously.
00:17:55 <Cale> But I suppose you could list the packages on hackage with that module, and ask the user to supply a -package option with one of them.
00:18:39 <mmorrow> sclv: how does this look for the unsafePerformIO case (in particular, using Data.Sequence won't skew results somehow(?)) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=301#a302
00:18:55 <rwbarton> Could not find module 'Foo': it is a member of package bar, which is on hackage
00:19:31 <mmorrow> he says "I made a small benchmark program which inserts and removes an element from a global queue 1,000,000 times."
00:19:56 <Cale> rwbarton: Installing bar...
00:20:50 <mmorrow> realtime ascii progress bar ++
00:22:26 <sclv> hheh.
00:22:56 <sclv> don't see why a sequence should matter.
00:24:06 <sclv> for the simple case, there should probably be a version explicitly threaded too.
00:24:59 <Cale> mmorrow: How about with the other methods?
00:26:50 <mmorrow> i'm coding those up now
00:27:00 <mmorrow> holy crap, the implicit params is /way/ faster
00:27:02 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=301#a303
00:27:36 <mmorrow> (faster than the unsafePerformIO version. i haven't done the monadic version yet)
00:28:36 <mmorrow> over twice as fast on my laptop
00:28:39 <score> http://hpaste.org/11464 HALP
00:28:44 <mmorrow> {-# OPTIONS_GHC -O2 -fglasgow-exts #-}
00:28:51 * Cale halps
00:29:25 <Cale> score: previous values of what?
00:29:28 <ivanm> mmorrow: I thought it was recommended not to use -fglasgow-exts and just apply the extensions you actually do use... :s
00:29:37 <Cale> score: hmm...
00:29:39 <mmorrow> ivanm: i'm lazy ;)
00:29:55 <Cale> score: Is this effectively like a nonempty list monad?
00:30:00 <score> Cale: like it starts as 3 and then (+1) changes the current value to 4 and we store 3 as a previous value.
00:30:08 <Cale> score: uh...
00:30:18 <Cale> score: What if we apply 'show'?
00:30:22 <ivanm> mmorrow: heh
00:30:28 <score> Cale: like Version currentvalue [all previous values in here]
00:30:47 <Cale> score: Are you thinking of a versioned state monad perhaps?
00:31:39 <score> Cale: start as 3. after (+1), it's Version 4 [3]. after another (+1), it's Version 5 [4, 3].
00:31:50 * mmorrow thinks he'll put the monadic version off until "later"
00:31:51 <Cale> score: The problem is that your implementation of >>= has type V a -> (a -> a) -> V a
00:32:01 <score> Cale: yeah, but how to fix?
00:32:11 <Cale> When it should have type V a -> (a -> V b) -> V b
00:32:22 <Cale> Think about how you might implement that...
00:32:45 <Cale> The type of all the previous versions of the element is going to have to change.
00:33:13 <rwbarton> score: how do you envision using this monad?
00:33:28 <score> rwbarton: just a learning exercise.
00:33:40 <Cale> score: Do you know the state monad?
00:33:42 * mmorrow 's going to be using implicit parameters a lot more than he currently does (which is not at all)
00:33:52 <score> Cale: yeah.
00:34:09 <rwbarton> score: no, I just mean, what is some code that would use this monad and what should it do
00:34:10 <Cale> score: You could do a state monad where you had a log of previous values.
00:34:15 <Cale> (and an undo operation)
00:34:43 <Cale> score: But I don't see a way for your current approach to work *as a monad*
00:34:57 <Cale> Of course you can define an operation which does this.
00:35:01 <Cale> It just won't be a monad.
00:35:26 <score> ok. picked a bad problem for a monad exercise.
00:35:54 <Cale> score: Try doing a state monad which retains old versions of the state.
00:36:25 <Cale> and has an operation 'undo' which undoes successive previous calls to 'put'
00:36:51 <score> okay, thanks
00:47:47 <Cale> mmorrow: Personally, I still don't see the need for global variables. :)
00:48:25 * dolio isn't very surprised that unsafePerformIO is slower.
00:48:50 <Cale> Global variables tend to just create inflexible designs where you make the assumption you'll only ever need one of something, or impose this restriction on your users.
00:49:25 <Cale> One particularly glaring stupid example is in System.Random
00:50:03 <Cale> What is the purpose of keeping a global StdGen when we have newStdGen anyway?
00:52:27 <dolio> Not sure I follow that.
00:52:38 <dolio> You mean, instead of seeding from the time or something?
00:53:12 <mmorrow> Cale: heh. i totally agree that they're a bad idea in general. they are handy on occasion though. but yes, (imo) any task which uses a global could be converted to not use a global (but sometimes at the cost of pita, which is definitely costly when you're in a hurry and/or writing throwaway code)
00:54:29 <mmorrow> like generating uniq vars is soooo much easier with a global MVar, but i guess stylistically not as appealing
00:55:56 <mmorrow> (but much more appealing if you don't want to have to wrap everything that needs uniq vars in some state monad)
00:56:21 <Cale> I think it's nicer to either pass a unique supply explicitly, or use a monad which has that additional operation. If you have a global MVar, you have at most one unique supply...
00:56:42 <mmorrow> yeah, as of now i'm an implicit params convert :)
00:57:36 <Cale> (while I suppose technically the sequence of values that each thing using the supply will get will be unique, but it'll use up values potentially a lot faster than you'd want)
00:58:56 <mmorrow> Cale: how do you mean "it'll use up values potentially a lot faster than you'd want"?
01:00:54 <Cale> Well, sometimes it's nice to have the smallest possible set of values when you're generating unique ones.
01:01:05 <Cale> (especially if a user is going to have to look at them)
01:02:48 <mmorrow> hmm, that's true. i'm thinking of unique var generation in particular (where you don't care what the uniq is, just that it's uniq)
01:03:41 <Cale> Sometimes you can care that the unique vars you generate are readable.
01:04:11 <mmorrow> but of course bear in mind that i'm not claiming this use-case is a reason to have/use global vars to begin with. just that it's a convenient short cut which may or may not come back to haunt you ;)
01:04:22 <Cale> hehe
01:04:49 <mmorrow> , show `fmap` replicateM 10 (newName "x")
01:04:53 <lunabot>  [x_0,x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]
01:04:57 <mmorrow> , show `fmap` replicateM 10 (newName "x")
01:04:59 <lunabot>  [x_0,x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]
01:05:00 <Cale> Wow, someone made a calculator with addition, multiplication, and the numbers 1 through 5 with the powder game.
01:05:24 <mmorrow> haha, it's only starting over since the evaluator doesn't persist across lunabot evals
01:05:51 <Cale> http://dan-ball.jp/en/javagame/dust/search/
01:05:58 <Cale> search for NumPad
01:06:00 <rwbarton> , replicateM 2 (show `fmap` replicateM 10 (newName "x"))
01:06:01 <lunabot>  luna: No instance for (GHC.Show.Show
01:06:02 <lambdabot> Title: Powder Game Save data - web games site DAN-BALL
01:06:04 <Cale> and change the time to "All"
01:06:32 <Cale> (of course, you need Java to run it)
01:06:35 <mmorrow>     No instance for (Show (Q [String]))
01:07:05 <mmorrow> i only made four or five instances of Show for Q <something>
01:07:51 <mmorrow> i'm sure there's a much better solution though to showing Q _ s than i'm using though
01:08:14 <mmorrow> the only sticking point is that you need to use unsafePerformIO to show a Q a
01:08:16 <Cale> I am incredibly amused :)
01:09:54 * mmorrow doesn't have the java plugin
01:10:23 <mmorrow> , show `fmap` replicateM 2 (show `fmap` replicateM 10 (newName "x"))
01:10:25 <lunabot>  ["[x_0,x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9]","[x_10,x_11,x_12,x_13,x_14,x...
01:11:18 <mmorrow> it's implem in Language.Haskell.TH.Syntax with
01:11:20 <mmorrow> -- Global variable to generate unique symbols
01:11:25 <mmorrow> counter :: IORef Int
01:11:25 <mmorrow> {-# NOINLINE counter #-}
01:11:25 <mmorrow> counter = unsafePerformIO (newIORef 0)
01:11:54 <mmorrow> not even an MVar...
01:11:56 <mmorrow> hmm
01:17:04 <mmorrow> "the only sticking point is that you need to use unsafePerformIO to show a Q a"
01:17:34 <mmorrow> (since the bot can't do IO, so (print =<<) . runQ is out)
01:18:18 <mmorrow> ((which is what one would use in ghci))
01:24:57 <Cale> mmorrow: http://cale.yi.org/share/2-op-calc.png -- that's what it looks like, anyway :)
01:25:17 <Cale> (I triggered the 3 and 5, and then the multiplication button :)
01:26:14 <mmorrow> oh cool
01:28:12 * mmorrow recalls a freshman circuit lab where he had to make a circuit that'd display those segmented numbers. pita x10
01:28:35 <dermiste> hi folks
01:28:43 <Cale> In this case, the numbers are made of C4, and the calculator blows up the parts which aren't supposed to display :)
01:29:06 <Cale> dermiste: hey :)
01:29:36 <Cale> dermiste: How's Haskell?
01:30:02 <mmorrow> lol C4
01:30:38 <dermiste> trying to port 6.10.1 snapshot on OpenBSD
01:30:42 <dermiste> fun stuff
01:30:47 <dermiste> :)
01:33:55 <C-Keen> I have doesFileExist and want to test that in a when () part, how do I handle the IO monad here?
01:34:35 <Cale> b <- doesFileExist "foo"
01:34:40 <Cale> when b $ do ...
01:35:38 <C-Keen> hm, true
01:35:43 <C-Keen> thanks Cale
01:36:33 <Deewiant> ?ty doesFileExist "foo" >>= (flip when $ do ...)
01:36:34 <lambdabot> Empty 'do' construct
01:36:41 <Deewiant> oops
01:36:45 <Deewiant> but anyway :-P
01:37:13 <xmux> Does anybody else have terminal problems entering an editor (vim in my case) from ghci?
01:37:48 <xmux> It's as if the emulation is wrong, or the terminal is the wrong size or something
01:38:05 <Cale> hmm, it works okay for me, after setting my editor.
01:38:17 <Cale> I usually like to edit from another window, though.
01:38:40 <Cale> :r will reload the file
01:39:19 <xmux> working in the same window seems more convenient, and if :e worked perfectly it would be great
01:39:56 <Cale> What seems to be the problem?
01:40:08 <Cale> It displays strangely or something?
01:41:25 <xmux> It's hard to describe.  Vim doesn't display all the lines that it should
01:41:43 <xmux> vertical scrollling works in a strange way
01:42:42 <Cale> hmm
01:43:08 <xmux> This is on OS X btw.  I tried ssh into a linux box from the same terminal and it seems to work perfectly like that.
01:43:14 <Cale> ah
01:43:31 <xmux> So maybe the problem is specific to OS X
01:43:39 <Cale> Maybe it's not getting the LINES environment variable?
01:43:46 <dermiste> Cale: :r are you sure ? I thought it was Ctrl-L
01:44:00 <Cale> dermiste: Or just :
01:44:20 <dermiste> oh, wait, Ctrl-L is to redraw the screen
01:44:55 <electronx> on a side note what is haskell bad for?
01:45:01 <Cale> xmux: If you know how many lines the terminal has, you can :set lines 24
01:45:11 <jsn> xmux: i use OS X
01:45:13 <xmux> Is LINES even used anymore?  I think curses applications get the terminal size by calling an ioctl
01:45:24 <jsn> xmux: I have not had that particular problem
01:45:35 <Cale> xmux: Well, perhaps that then ;)
01:45:36 <electronx> all languages have weaknesses what is haskell bad for?
01:45:45 <jsn> xmux: i get weird syntax coloring
01:45:50 <jsn> electronx: no here documents
01:45:51 <Cale> electronx: Well, I'm not sure it's absolutely terrible at anything in particular, but not having a proper polymorphic record system is one.
01:46:07 <jsn> electronx: no inline regular expressions
01:46:15 <Cale> hehe
01:46:26 <jsn> electronx: don't try to write little one off shell scripts in it
01:46:28 <Cale> jsn: But Text.Regex.Posix and friends are pretty cool
01:46:36 <jsn> Cale: they are pretty nice
01:46:37 <electronx> na those are not shortcomings
01:46:40 <Cale> and HSH
01:46:42 <Deewiant> inline regular expressions could be done to an extent with overloaded-strings
01:46:46 <Cale> (for shell scripts)
01:46:52 <jsn> Cale: with quasi-quoting, i may be able to retire my sed skeelz
01:47:20 <jsn> Deewiant: well, then we'd have the backslash plague, right?
01:47:27 <Deewiant> we already do :-P
01:47:33 <Cale> electronx: Well, the lack of a proper record system means that certain tasks involving records with lots of fields are very awkward.
01:47:39 <xmux> It seems that my vim is convinced that there are about 28 rows instead of the real height of my terminal which is 51
01:47:51 <jsn> xmux: are you using screen?
01:47:56 <electronx> i remeber dons said something that it was really hard do in haskell
01:47:56 <xmux> jsn: nope
01:48:00 <jsn> xmux: are you using Terminal.app ?
01:48:10 <electronx> can't remeber
01:48:17 <Cale> electronx: If you get to choose your data layout, you can usually avoid this, by breaking your types down so that any given constructor only has a manageable number of fields.
01:48:38 <electronx> Cale does 6.10 solve this?
01:48:41 <xmux> jsn: yes, Terminal.app, maximized
01:48:41 <Cale> no.
01:48:43 <Deewiant> Cale: what kind of tasks?
01:48:48 <electronx> {...}
01:48:51 <Saizan> extensible variants are harder instead..
01:48:52 <Cale> But there are papers which describe solutions.
01:48:55 <electronx> or is it {..}
01:49:03 <xmux> jsn: Try loading some long file into ghci, then :e
01:49:04 <jsn> electronx: hmm?
01:49:35 <Cale> electronx: The record syntax is sugar around algebraic datatypes, and when the records get large, it starts to show.
01:49:56 <electronx> okay
01:50:04 <electronx> that can be fixed though
01:50:09 <electronx> something more
01:50:27 <Cale> The module system is a little weak.
01:50:48 <Cale> It's better than most languages, but it's weak compared to most ML variants.
01:50:51 <electronx> i want to know what i should not waste my time doing in haskell
01:50:59 <xmux> jsn: Did you install the ghc package or build it from ports?
01:51:06 <jsn> xmux: ah, well
01:51:13 <jsn> xmux: so i have some rather odd behaviour
01:51:19 <electronx> sometimes i do something in haskell that can be done in another language faster
01:51:27 <jsn> never really used a big file in this thing, i guess
01:51:34 <Cale> electronx: I can't think of a particular application which you should not be able to do, given appropriate libraries/work.
01:51:35 <Deewiant> depends on your speed with [another language]
01:51:36 <electronx> thus want to avoid situations like this
01:51:44 <Deewiant> and your speed with Haskell, of course. :-P
01:51:58 <jsn> xmux: i used the package
01:52:20 <electronx> Deewiant: my haskell is a little weak but i'm pretty much expert C++, java, python, ruby
01:52:21 <jsn> xmux: what i get is this weird thing where the bottom half of the file is gone
01:52:31 <xmux> jsn: Yes, that's the problem
01:52:44 <jsn> xmux: but i page up and then page down and the text shows up again
01:52:58 <jsn> or rather, page down and then page up
01:52:58 <electronx> Deewiant: does php count as a language?
01:53:00 <xmux> right, also if you do :sh, then exit the shell it might be fixed
01:53:09 <jsn> aha
01:53:15 <jsn> xmux: okay, this is weird
01:53:18 <Deewiant> electronx: no. ;-)
01:53:24 <jsn> electronx: yes
01:53:27 <electronx> hehe thought so
01:53:45 <xmux> yes, :sh then ctrl-d seems to completely fix it
01:53:56 <jsn> electronx: if you mean, what application area is haskell not able to support well, i would say shell scripting
01:54:09 <jsn> xmux: interesing
01:54:12 <electronx> jsn: thats what i was after
01:54:13 <Cale> Last time I checked, the database libraries for Haskell were a little weak, though I think this has more to do with our high standards in Haskell than anything else. Also, things might have changed since then.
01:54:13 <Deewiant> and I would disagree
01:54:27 <Deewiant> hell, I've written two libraries to make shell scripting easier :-P
01:54:59 <jsn> Deewiant: you need to change the language definition to support shell scripting well
01:55:07 <Deewiant> define "well"
01:55:13 <jsn> Deewiant: libraries can't do it
01:55:13 <electronx> can we say haskell is bad for games?
01:55:21 <Cale> electronx: nope :)
01:55:32 <jsn> electronx: well, you have to consider that carefully
01:55:48 <jsn> electronx: if you just want to write a game, haskell and python are equally good
01:55:48 <electronx> i read the thesis by the frag author
01:55:50 <Cale> electronx: It's relatively untested in that area, but seems to handle it well as far as people have tried.
01:56:04 <jsn> electronx: if you want to write Halo 3.5, you will need C++
01:56:09 <electronx> lol
01:56:20 <jsn> as that's where all the libraries are, and porting would be a lot of work
01:56:23 <electronx> haskell can do that no prob
01:56:30 <jsn> Deewiant: shell scripting is all about syntax
01:56:32 <Cale> jsn: If only because the game console APIs use C++?
01:56:35 <dermiste> electronx: with haskell you have all the framework for reactive programming
01:56:46 <jsn> Cale: and OGRE, Bullet, &c.
01:56:51 <Deewiant> jsn: not IMO
01:57:02 <Cale> So it might be a bit of work porting those first ;)
01:57:25 <jsn> Deewiant: well, then i can say, haskell only supports overly verbose shell scripting
01:57:35 <Deewiant> that's fine
01:57:44 <Deewiant> I don't mind being verbose if it prevents bugs
01:57:49 <Deewiant> as it often does
01:57:50 <Cale> I think that once the library support is in place though, Haskell could be a totally awesome game programming language.
01:58:01 <jsn> Deewiant: excuse me
01:58:13 <jsn> Deewiant: _needlessly_ verbose shell scripting
01:58:22 <Deewiant> I don't think it's needless :-)
01:58:25 <jsn> there is no upside to haskell's verbosity in this area
01:58:34 <Deewiant> I disagree
01:58:39 <jsn> lack of HERE documents and regex syntax is just a niusance
01:58:46 <jsn> it doesn't buy us anything
01:59:00 <Saizan> uhm
01:59:18 <jsn> Deewiant: there is certainly no safety coming out of that, as far as i can tell
01:59:29 <Cale> jsn: I'm not sure about this claim that it's verbose.
01:59:39 <dermiste> jsn: I don't see what you mean by haskell shell scripting
01:59:43 <Cale> It's not that much more verbose, with the right libraries.
01:59:43 <Deewiant> granted, but I don't think those are such big problems either
01:59:50 <Saizan> a good experiment would be to write a perl-looking quasiquoter for shell scripting :)
01:59:51 <dermiste> d you mean using haskell a la python ?
02:00:04 <Deewiant> I admit alternative string syntaxes would be nice
02:00:11 <Cale> It's certainly not as verbose as perl for shell scripting.
02:00:11 <dermiste> for gluing pieces together ?
02:00:14 <jsn> dermiste: python is terrible for shell scripting, too
02:00:26 <dermiste> indeed
02:00:28 <jsn> Cale: it is far more verbose than perl or ruby or reia
02:00:33 <Cale> oh?
02:00:36 <jsn> sure
02:00:37 <Cale> Have you tried HSH?
02:00:42 <dermiste> but it's widely used as software glue anyway
02:01:14 <jsn> to obtain the output of a command in perl or ruby or whatever -- `command`
02:02:52 <jsn> not 'import NonStandard.SortOfUndocumentedThing ; main = do { (i, o, e, p) <- runIt "command" ; s <- hGetContents o ; putStrLn s }'
02:02:59 <Cale> Okay, how about taking (the equivalent of) a list of strings, and using that as input for the command?
02:03:29 <Cale> For the case of getting the output of a command, it's just  v <- run "command"
02:03:32 <Deewiant> jsn: with the right library that's 'import NonStandard.SortOfUndocumentedThing ; main = f "command"'
02:03:37 <Cale> If v is a String, you get the output.
02:03:40 <Saizan> in ghc 6.10, import System.Process; do o <- readProcess "command"
02:03:56 <Cale> You can also pipe input into it
02:04:07 <dermiste> for starters, do we really want to turn haskell into a glue language ?
02:04:14 <Saizan> where o :: String
02:04:17 <jsn> dermiste: well, hold on
02:04:33 <jsn> dermiste: i was just trying to answer electronx's question
02:04:43 <jsn> what do i think haskell is not so good at?
02:04:51 <dermiste> oh, right
02:04:59 <jsn> and certainly, i've found haskell a hassle for shell scripting
02:05:07 <dermiste> yes, I do agree with you
02:05:27 <jsn> Deewiant: okay, that's a great improvement
02:05:36 <jsn> Saizan: that's good to know
02:05:55 <jsn> i'm sure all this stuff will get boiled away soon enough
02:06:31 <jsn> and quasi-quoting will finally bring us HERE documents and the ability to embed multi-line sed scripts, &c.
02:06:51 <Cale> jsn: You should really try HSH ;)
02:06:59 <jsn> Cale: it is not usual, by the way, to feed a list of strings to a process
02:07:08 <jsn> Cale: you feed it a string full of newlines
02:07:13 <Cale> jsn: Well, okay, or a single string.
02:07:25 <jsn> so HERE documents play into all this
02:07:40 <Cale> HERE documents are really ugly.
02:07:59 <jsn> multi-line string literals are a good idea tm
02:08:02 <Cale> I much prefer unlines
02:08:11 <jsn> at least, they certainly are are for shell scripting
02:08:22 <dolio> Haskell has multi-line string literals.
02:08:26 <Cale> that way, the document can be indented properly with the rest of the source.
02:08:43 <jsn> Cale: that is not desirable when i am writing a USAGE statement
02:08:51 <Cale> Why?
02:08:56 <dolio> Although you need to write the \ns yourself at the end of each line, unfortunately.
02:09:08 <Deewiant> unlines requires ["foo","bar","","baz"] which is a bit annoying
02:09:16 <jsn> indeed
02:09:19 <jsn> totally annoying
02:09:20 <Cale> It's not annoying at all :)
02:09:21 <Deewiant> i.e. the constant "," is noise
02:09:39 <jsn> other languages have had this better for a long time
02:09:40 <Cale> Deewiant: the idea is that there is only one , per line :)
02:09:47 <Deewiant> Cale: yes, but it's still noise
02:10:06 <cinimod> Is there a ghc option which tells you which modules you are importing but which you don't use?
02:10:22 <Cale> If HERE documents were added to Haskell, I would want them to require an indent to the column after the "
02:10:26 <jsn> Cale: in my haskell now, i write the USAGE in the first comment in the file and use template haskell to extract it at compile time
02:10:33 <Cale> So that your text formed a nice block.
02:10:44 <Cale> jsn: That's... ridiculous :)
02:10:47 <jsn> Cale: well, thankfully, the quasi-quoter does not require that
02:10:55 <jsn> Cale: it's perfectionist
02:11:03 <Cale> Why would you do that?
02:11:16 <Saizan> cinimod: -Wall tells you that, so there should be a specific warning flag
02:11:40 <jsn> well, there are two good reasons
02:11:55 <cinimod> Saizan: I thought there was I couldn't remember its name. I'll have a hunt through the docs.
02:12:37 <dolio> http://hpaste.org/11465 -- multi-line strings
02:12:38 <jsn> first of all, i want the usage to look right in an 80 column layout -- might as well lay it out once, with vim doing the layout (vim can not munge the commas and quotes, obviously)
02:13:37 <jsn> and now that i have the macro, i have a nice convention that allows me to put the USAGE right at the top of the file
02:14:04 <jsn> which i can user over and over and over again
02:14:15 <cinimod> Saizan: obvious really -fwarn-unused-imports
02:14:48 <BMeph> jsn: Why 80 column? You got stock in Hollerith, and you plan on bringing back punch cards? ;p
02:15:11 <jsn> BMeph: uhm, because i have to read it in that environment a lot of the time, and so do other people?
02:16:06 <jsn> BMeph: what environment do you program in?
02:16:54 <BMeph> jsn: An electronic one. :)
02:16:59 <jsn> ah, okay
02:17:15 <jsn> BMeph: you seem to be using mIRC
02:17:27 <jsn> BMeph: obviously this stuff isn't relevant to you at all
02:17:46 <BMeph> jsn: Sometimes I use an IDE like Eclipse or VS. Sometimes I telnet. Sometimes I use a PDA; it depends on the problem.
02:18:08 <Cale> Prelude HSH> xs :: [String] <- run $ ("grep",["abra","/usr/share/dict/words"]) -|- ("grep",["ive"])
02:18:08 <Cale> Prelude HSH> xs
02:18:08 <Cale> ["abrasive","abrasive's","abrasively","abrasiveness","abrasives","nonabrasive"]
02:18:14 <Wild_Cat> even with real OSes, honestly, who still uses 80*24 text-only mode to program?
02:18:19 <Cale> I'd say that's not so bad :)
02:18:33 <vixey> that is pretty awful
02:18:37 <jsn> Cale: there is a lot of noise in there
02:18:50 <jsn> it's just a syntax thing
02:19:07 <vixey> anywhere, where is abracadabra?
02:19:14 <Cale> vixey: I grepped again.
02:19:42 <jsn> Cale: and if that had been `sh` it would have been clear as day
02:19:58 <Deewiant> HSH is POSIX-only, no?
02:19:59 <jsn> BMeph: i always use vim, and always at 80 columns
02:20:16 <jsn> BMeph: and always in screen
02:20:42 <jsn> BMeph: and i didn't just pull this out of 4chan, alright
02:20:53 <Wild_Cat> vim does word wrapping, though. And nothing forces you to use it at 80 columns. Heck, you could go crazy and use gvim.
02:21:51 <jsn> look, i am not going to argue this with you all
02:22:04 <Wild_Cat> While maintaining line width below 80 chars is usually a good thing as it makes your code more readable, it's ridiculous to *enforce* that limit based on ancient technical limitations that have no meaning anymore.
02:22:14 <Cale> jsn: This is reasonably clear (and it should be noted that the only reason I'm forced to give an explicit type signature for xs is that I'm on the GHCi prompt.)
02:22:24 <jsn> you go to Google, the Python project, GHC, &c. and read the coding standards
02:22:33 <jsn> Wild_Cat: you can't have standards you don't enforce
02:22:49 <Cale> Deewiant: yes, basically.
02:22:51 <jsn> 80 columns actually has as much to do with ancient human eye limitations as with anything else
02:23:10 <Cale> jsn: More like ancient punchcard formats ;)
02:23:15 <Deewiant> Cale: Then use my Pipe library instead! ;-)
02:23:21 <jsn> Cale: no, really
02:23:27 <Wild_Cat> no, 80 columns have to do with bloody VT-100 terminals -- possibly even older stuff.
02:24:18 <vixey> :t (.)`on`
02:24:19 <lambdabot> parse error (possibly incorrect indentation)
02:24:23 <vixey> :t ((.)`on`)
02:24:24 <lambdabot> forall b a. (a -> b -> b) -> a -> a -> b -> b
02:25:24 <Cale> http://en.wikipedia.org/wiki/Punched_card#IBM_80_column_punch_card_format
02:25:26 <lambdabot> Title: Punched card - Wikipedia, the free encyclopedia, http://tinyurl.com/4e3ap8
02:27:39 <jsn> look into formulas for ideal line length in typography
02:27:53 <jsn> it's actually shorter than eighty
02:28:56 <Cale> Terminals have other typographical problems though.
02:29:15 <jsn> Cale: one subject at a time
02:29:18 <Cale> If you're going to complain about that, you might as well complain that there are no margins.
02:29:27 <jsn> i have margins
02:29:31 <Cale> and that the font is monospaces
02:29:37 <Cale> monospaced*
02:30:10 <Wild_Cat> not to mention that typography has different rules on screen and in print
02:30:17 <jsn> i set that margins at two columns in all my USAGE statements, for example
02:30:20 <Wild_Cat> (e.g. the serif VS sans serif debate)
02:30:23 <jsn> s/that/the/
02:30:48 <jsn> line length has held up for a relatively long time, across typographic styles
02:30:53 <jsn> but i digress
02:30:53 <Cale> jsn: I mean for the terminal as a whole.
02:31:10 <jsn> i am not going to take issue with it
02:31:17 <jsn> it does not  need to be changed
02:31:27 <jsn> it is the way god made it and we must accept that
02:31:34 <Cale> Actually, we don't.
02:31:35 <jauaor> hello
02:31:36 <jsn> so we need the HERE documents
02:31:43 <Cale> Most of my terminals are 100 columns.
02:31:54 <jsn> well, that is bad and wrong
02:31:55 <Cale> jauaor: hi!
02:32:01 <Cale> jsn: No it isn't.
02:32:07 <jsn> i bet you even use tabs
02:32:12 <Cale> Nope.
02:32:18 <Cale> Spaces only.
02:32:24 <jauaor> Hello Cale !!!, how it goes?
02:32:31 <Cale> jauaor: fine :)
02:32:34 <jauaor> :-)
02:32:54 <Cale> aha, jauaor = araujo
02:32:57 <jsn> i mean, the ideal, of course, is to send everything through `fmt` and let it sort this stuff out
02:33:06 <jauaor> Cale: yes!
02:33:12 <jauaor> Cale: my alter ego
02:33:13 <jsn> at least for USAGE statements
02:34:17 <Cale> jsn: You could use a pretty printer to generate the usage statements from a description of the flags that the program takes, which is also used to parse the commandlines ;)
02:34:45 <jsn> but i still have to actually write all the text describing the usage
02:35:05 <jsn> and i'd rather not deal with all those goofy commas, unlines, all that stuff
02:35:09 <jsn> bleah
02:35:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#v%3AusageInfo
02:35:12 <lambdabot> Title: System.Console.GetOpt, http://tinyurl.com/yyvufm
02:35:26 <jsn> it doesn't really add anything positive to have those commas and junk in there
02:35:41 <Cale> In this case it does.
02:35:49 <Cale> Because the usage info is also the commandline parser.
02:36:12 <jsn> that's no what i'm talking about
02:36:28 <jsn> i'm talking about the many lines of text that describe my shell script and what it does
02:36:40 <jsn> what you get when you run `-h`
02:36:44 <Cale> yeah.
02:36:47 <Cale> I'm talking about that too.
02:37:05 <jsn> no, it doesn't generate my explanations for me :)
02:37:08 <Cale> That describe the various flags which your script takes, and what they do.
02:37:28 <Cale> Look at the OptDescr data type.
02:37:30 <jsn> oh, sure
02:37:34 <Cale> You put the description in there.
02:37:41 <jsn> Cale: i've used that thing
02:37:56 <jsn> if i could put a HERE document there, it'd be so much better
02:38:09 <Cale> I disagree. HERE documents always look ugly.
02:38:32 <jsn> Cale: that is not really a statement i can understand the reasoning behind
02:38:32 <Cale> Because they're out of band with the rest of the source code.
02:38:44 <Cale> and spoil the flow of indentation.
02:38:46 <Saizan> btw, if you use a tool to do formatting anyway why doing that in the sources instead of letting the printer deal with it?
02:38:58 <jsn> Saizan: i have to ship to windows, too
02:38:59 * jauaor would like to remember the HERE document syntax for once in his life
02:39:08 <Saizan> jsn: so?
02:39:08 <jsn> Saizan: i don't have `fmt` on Windows
02:39:37 <jsn> oh you mean, why don't i ship a pretty printer with my application!!?!?!?!?!?!
02:39:38 <Saizan> jsn: you can have a formatter in haskell
02:40:02 <jsn> okay, we see why that is not so good for shell scripting, i hope
02:40:08 <Saizan> why?
02:40:14 <jsn> ah, okay
02:40:42 <Saizan> i mean, it's just a String -> String function
02:40:50 <Saizan> cabal does it already iirc
02:41:05 <Cale> There are a number of pretty printers on Hackage.
02:41:41 <jsn> okay, so let's try this another way
02:41:46 <Cale> I like wl-pprint.
02:41:51 <jsn> do you guys see any cons to this proposal?
02:42:05 <Cale> To what proposal?
02:42:06 <vixey> cons? :)
02:42:12 <jsn> 'con' as in 'pro and con'
02:42:24 <jsn> to ship a pretty printer with my little scripts
02:42:42 <vixey> is it the same pretty printer? why not put it in a library
02:42:48 <Cale> If you're shipping as an executable, it'll make no difference.
02:42:58 <Cale> If not, it's available on Hackage.
02:43:02 <jsn> okay, but...do you see any cons at all?
02:43:11 <Cale> Not in that case.
02:43:15 <jsn> ah, okay
02:43:21 <vixey> I don't really know what it is
02:43:23 <jsn> well, you are just not trying very hard
02:43:24 <Cale> What cons do you see?
02:43:24 <Deewiant> bigger executable size? :-P
02:43:31 <Cale> Heh, slightly :)
02:43:42 <jsn> i appreciate that shell scripting is not an important issue for haskellers
02:43:56 <jsn> i am not going to try to convince you to change things to accomodate it
02:44:05 <Cale> I mean, what is the problem?
02:44:20 <Cale> You just don't like having a pretty printer linked in there?
02:44:32 <Cale> It's only a few lines of Haskell code imported from a library.
02:45:00 <Cale> You worry about the performance relative to a string? :P
02:45:19 <jsn> Cale: i don't think the absence of HERE documents is justifiable by the presence of a pretty printer
02:45:46 <Cale> Well, I agree with this much, but I think they are justifiable by the presence of unlines :P
02:46:14 <vixey> what's a HERE?
02:46:21 <jsn> and sometimes, i just want to send a little script to someone with ubuntu and GHC 6.6 to run -- and i want it to have nice usage, &c.
02:46:24 <Cale> vixey: He's referring to multiline strings.
02:46:31 <vixey> haskell has that ..
02:46:44 <Cale> vixey: Yeah, with automatic newlines, that ignore the indentation.
02:46:48 <jsn> Cale: i do not want to send them a bunch of instructions about downloading cabal, &c.
02:47:10 <Cale> jsn: Well, don't worry, cabal will soon be included.
02:47:30 <Cale> Though, with ubuntu, who knows :P
02:47:35 <jsn> Cale: i don't want to have to ask them to install anything to use a shell script
02:47:59 <Cale> Then distribute it as a binary.
02:48:26 <jsn> oh, thank you
02:48:29 <vixey> all this just so you don't have to type n\?
02:48:42 <jsn> that is the same thing as saying, no shell scripting for you
02:48:47 <vixey> jsn, you are aware of this?
02:48:47 <vixey> test = "  foo      \n\
02:48:47 <vixey>        \  bar      \n\
02:48:50 <vixey> ?
02:48:55 <Cale> jsn: You'll probably need/want other libraries as well.
02:49:08 <jsn> Cale: for shell scripting, no
02:49:13 <jsn> generally not
02:49:17 <jsn> sometimes, sure
02:49:24 <Cale> jsn: Probably, if you want to interact with other programs.
02:49:42 <jsn> well, most scripting languages don't require any libs for that
02:49:53 <vixey> hellooo
02:49:59 <Deewiant> if you want to survive with a minimum of libs just use GolfScript :-P
02:50:05 <jsn> so you see this is just an annoyance, relative to other scripting langauges
02:50:25 <vixey> jsn, is that not what you are talking about or what?
02:50:37 <jsn> vixey: are you familiar with HERE documents in Ruby, Reia or Bourne shell?
02:50:40 <Cale> jsn: I'm telling you that you, the programmer, have to download an extra library.
02:50:58 <vixey> jsn, no...... that's why I was asking what it was a second ago
02:51:07 <Cale> jsn: If you simply distribute your program as a binary, your user doesn't need anything.
02:51:12 <jsn> vixey: well, those are what i am talking about
02:51:40 <vixey> oh haskell has this
02:51:49 <vixey> [$HERE|
02:51:52 <vixey> oops
02:51:57 <vixey> [$here|
02:52:02 <jsn> vixey: they'll have it soon
02:52:04 <vixey> 1. Salad mix.
02:52:04 <vixey> 2. Strawberries.*
02:52:05 <vixey> etc
02:52:13 <vixey> why not now?
02:52:20 <vixey> this is like a one liner or something
02:52:20 <_dolio> I don't see what the significant difference is between here documents and haskell's multi-line strings, except that you have to type \n for the latter.
02:52:26 <jsn> vixey: not in any standard distribution
02:52:46 <vixey> jsn: ghc 6.9 or better + one line of code :)
02:52:47 <jsn> Cale: that's really not so great for shell scripting
02:52:51 <Cale> jsn: Why?
02:53:04 <jsn> vixey: ubuntu does not have that
02:53:09 <jsn> vixey: i don't work in a lab
02:53:15 <vixey> jsn, OK
02:53:26 <Cale> jsn: What's the difference between a shell script and any other program?
02:53:29 <vixey> jsn, I guess you do not have the luxuries I do
02:53:33 <_dolio> And that here documents include all indentation instead of having each line start wherever you want on the line.
02:53:39 <jsn> vixey: i have no idea what those are
02:53:41 <vixey> jsn, afaict the best solution with your setup is what I pasted earlrier
02:53:47 <vixey> those what?
02:53:50 <jsn> vixey: i maybe have constraints that you don't
02:53:59 <jsn> vixey: luxuries
02:54:06 <vixey> newer GHC
02:54:13 <Cale> jsn: There's a release candidate for 6.10 available.
02:54:17 <vixey> anyway this isn't a problem
02:54:50 <jsn> Cale: as for the matter of difference between script and compiled binary -- i hardly can open up such a large can of worms at present
02:55:04 <jsn> vixey: i think you missed the beginning of the conversation
02:55:34 <vixey> idk you just seem to be arguing pointlessly
02:55:46 <vixey> why not upgrade ghc or just get used to typing \n?
02:56:26 <jsn> i hope that you all appreciate that, when i spoke to electronx earlier about haskell as a shell scripting language, it was not out of ignorance or lack of searching that i had come to my conclusions -- rather, i have examined the options and found them wanting
02:57:00 <jsn> if you do not agree with me, well, what can i say? i hardly expected to say anything but what i thought and be done with
02:57:02 <jsn> it
02:57:12 <Cale> Well, people *do* use it as a shell scripting language.
02:57:24 <Cale> Including a linux distribution.
02:57:32 <jsn> if anyone asks me, i will still say, i do not think it is very good
02:57:43 <jsn> in short, i must respectfully disagree
02:58:10 <vixey> jsn, you disagree that GHC 6.9 or better supports this?
02:58:26 * araujo making himerge slightly more xmonad friendly
02:58:33 <flux> hmm, is there some hack to overcome the startup time of compiling+executing .hs-files, or do people just use hugs? (which I guess is faster for that kind of stuff)
02:59:09 <jsn> vixey: i look forward to future improvements
02:59:44 <jsn> flux: you mean, when using the shebang line, or?
03:00:09 <Saizan> flux: for which use case? for developement ghci is fast enough, especially if you keep the .hi .o of untouched files around
03:00:33 <flux> saizan, having .hs-files in ~/bin instead of .pl-files
03:01:00 <jsn> flux: you can put `#!/usr/bin/env runhaskell` in the top of the file and it should work fine
03:01:24 <flux> jsn, yes, I thoughth that works. so there is no considerable latency involved?
03:01:41 <jsn> flux: well, i have not tried that for very large scripts
03:01:48 <jsn> flux: i have not had any problems
03:02:33 <Cale> flux: Keep the program loaded into ghci
03:02:38 <Cale> flux: Edit in another window.
03:02:47 <Cale> flux: :r will reload the file whenever you update it :)
03:02:53 <flux> cale, the point was replacing the .pl-files with .hs-files in ~/bin
03:03:06 <Cale> ah, I would compile them
03:03:20 <flux> yes, but that just leads into losing the source at some point :)
03:03:26 <Cale> Really?
03:03:33 <Cale> Keep the source somewhere coherent :)
03:03:48 <flux> well, it can take years
03:04:02 <flux> but at times I copy stuff from ~/bin to other hosts
03:04:03 <jsn> Cale: you are not really helping
03:04:15 <flux> and I don't take the sources with me, if they happen to be somehwere else
03:04:33 <vixey> jsn, but seriously I would use perl for that kind of stuff not haskell :p
03:04:41 <Cale> Hehe, for things of general use, you can cabalise them and upload them to hackage
03:04:47 <Cale> Then they can never be lost :)
03:04:50 <jsn> vixey: well, too bad about perl-6-forever
03:04:58 <vixey> what about perl 6?
03:05:10 <jsn> vixey: will it ever ship?
03:05:33 <vixey> I think so.. it should be .. next christmas or something :)
03:05:59 <Cale> It seems pretty close to being done.
03:06:34 <vixey> can view powerpoint files with openoffice ..
03:06:44 <jsn> honestly, i have highest hopes for Reia
03:07:09 <jsn> it seems to bring together a lot of the niceties of ruby and python
03:07:25 <jsn> and ties them together with BEAM to allow clustered applications
03:07:36 <jsn> which is pretty nice for scripting
03:07:42 <vixey> jsn, really I thought Lua, Ruby, Python, Io, Falcon, Blue, Euphoria, ... were looking innovative and fresh...
03:08:51 <Debolaz> I have yet to find a language to replace perl.
03:09:21 <Debolaz> Being "fresh" (and "hip") just don't cut it.
03:09:36 <vixey> I wonder if this is the period-of-ad-hoc-algolish-script-languages
03:09:50 <vixey> people can't seem to stop 'inventing' them
03:10:05 <jsn> Debolaz: i fear that "getting the job done" just doesn't cut it, either
03:10:49 <dermiste> Debolaz: something wrong with ruby ?
03:10:58 <jsn> Debolaz: which languages have you looked at, and why have you rejected them?
03:11:03 <Cale> "Ensuring maintainability"?
03:11:05 <Debolaz> jsn: Well, the problem is that while it would be nice with something that's a bit more than "getting the job done", if it doesn't get the job done no matter how nice it are it just don't matter.
03:11:22 <Cale> Debolaz: is/doesn't
03:11:50 <vixey> Debolaz: Something is wrong in that all those languages I listed were 'invented' in the last couple of years, look almost exactly the same, admit the same programming style - but libraries written for one work with one that one..
03:12:01 <jsn> Debolaz: well, my point is only perl doesn't get the job done better than much anything else any more
03:12:08 <Debolaz> dermiste: Ruby is a nice language. But at least at the time I looked at it, the number of libraries/modules for it were insignificant compared to perl's CPAN. That matters.
03:12:13 <jsn> Debolaz: it's not like awk is it's only competitor
03:12:50 <Cale> I don't really need a language to have more libraries than I can learn.
03:12:51 <Deewiant> anything is insignificant compared to CPAN.
03:13:05 <jsn> Debolaz: doesn't really matter when you're writing web apps
03:13:12 <vixey> Cale, that doesn't make sense :S
03:13:20 <jsn> Debolaz: it sure matters for biology, though
03:13:34 <Cale> vixey: Well, I can imagine why some people might.
03:14:02 <vixey> usually if there is a library ? you pick the language which works well with it
03:14:23 <vixey> (or trick some other language into working with that library even better)
03:14:29 <Debolaz> jsn: I use perl regularily for more than just web apps.
03:14:36 <mmorrow> <_dolio> I don't see what the significant difference is between here documents and haskell's multi-line strings, except that you have to type \n for the latter.
03:14:51 <mmorrow> _dolio> And that here documents include all indentation instead of having each line start wherever you want on the line.
03:15:18 <mmorrow> yeah, the second part is what you gain with the QQ here docs
03:15:20 <Cale> vixey: But I don't personally program to solve real world problems so much :)
03:15:27 <vixey> mmorrow: But you also don't need to escape things like quiote
03:15:28 <Cale> vixey: I program because it's interesting to do so.
03:15:30 <vixey> quotes*
03:15:37 <mmorrow> since inside [$here| ... |] you don't have to respect haskell layout
03:16:00 <mmorrow> vixey: totally. that too is a huge plus imo
03:16:02 <Cale> vixey: So I don't really care what libraries there are, so long as learning about them expands my mind. :)
03:16:33 <jsn> Debolaz: the way you entered the conversation, i inferred that you felt there was some deep problem with these "hip" languages
03:16:48 <Saizan> mmorrow: i think ti would be nicer having a [$here| that understands the surrounding layout
03:16:52 <jsn> Debolaz: but i guess what you're saying is, they just don't have libraries that you want
03:17:02 <jsn> Debolaz: and need for your work
03:17:05 <mmorrow> Saizan: how do you mean "understands"?
03:17:15 <Cale> For example, learning about Parsec, or Reactive -- definitely worthwhile.
03:17:44 <Debolaz> But let's say there is another language that could match perl when it comes to CPAN. I don't mean neccesarily being of the same size, but have roughly the same functionality available.. Then there's still the fact that I already know perl and there wouldn't be any sense switching unless the other language offered me something that was a significant improvement.
03:17:44 <Saizan> mmorrow: that doesn't include the indentation used only to line it up with the rest of the code
03:18:07 <mmorrow> Saizan: could you paste a short example showing exactly how you mean? i'd be very interested to see it.
03:18:07 <Twey> Is there a package to install the docs of the various Haskell packages on Arch?
03:18:14 <Cale> Even if you never actually use either of those libraries, learning about them is valuable.
03:18:20 <Twey> By default it seems to only install the license into the appropriate doc directory :(
03:18:20 <jsn> Debolaz: well, you have to weigh that against the fact that things change
03:18:23 <Cale> That's the kind of libraries I want to see more of :)
03:18:30 <vixey> Debolaz: Is already knowing $language actually important, after you have a couple years experience using programming languages?
03:18:43 <Cale> Twey: hmm
03:18:47 <Cale> Twey: dons would know
03:18:54 * Twey looks to dons.
03:19:04 <Cale> @seen dons
03:19:04 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 2h 18m ago.
03:19:07 <jsn> Debolaz: Perl seems to be having a lot of trouble moving out of version 5, for example
03:19:08 <Cale> hmm :/
03:19:08 <Debolaz> vixey: It's not just learning the new language you know.
03:19:09 <mmorrow> Saizan: so something like you QQ parser getting passed the surrounding lexical context or something i guess
03:19:17 <mmorrow> s/you/your/
03:19:27 <Debolaz> jsn: How is that a problem?
03:19:40 <jsn> Debolaz: it will be a problem in ten years
03:19:52 <jsn> do you want to be ready?
03:20:05 <Cale> jsn: Surely in 10 years, we'll be on to Perl 6.
03:20:08 <Saizan> mmorrow: http://hpaste.org/11465#a1
03:20:13 <Debolaz> jsn: Because some arbitrary version of a language does not exist, then any previous version of the language must suck? That's basically your argument, or at least how it comes across.
03:20:17 <jsn> Cale: no, perl will just die
03:20:20 <Cale> jsn: The language is already in a mostly usable state, from what I understand.
03:20:34 <jsn> Debolaz: no, my point is, it's losing mind share
03:20:50 <Cale> Mindshare can be a bad thing as much as it is good.
03:21:02 <mmorrow> Saizan: that'd be nice, but it seems to me like it'd be totally hellish to deal with (since the definer of the quasiquoter would have to manually implement that dynamic taking-into-account-the-lexical-context ability)
03:21:06 * mmorrow looks at the paste
03:21:27 <Cale> Languages with lots of mindshare are effectively dead.
03:21:28 <Debolaz> jsn: Just for the sake of argument, let's say that's true and it's a serious problem: Making perl 6 instantly available now won't neccesarily change that in any significant way.
03:21:33 <dancor> what is the Console in System.Console.GetOpt
03:21:34 <Cale> In the sense that they will not change.
03:21:37 <jsn> Debolaz: right
03:21:50 <jsn> Debolaz: the lack of Perl 6 is just a symptom of the underlying problem
03:22:05 <jsn> Debolaz: it's a sign to to run now
03:22:23 <jsn> s/to to/to/
03:22:30 <Cale> Why is it important to use a language which is popular?
03:22:43 <Cale> You are in #haskell after all ;)
03:22:45 <Twey> Cale: I disagree â€” Python has a fair amount of mindshare, for example
03:22:55 <Twey> Because popular languages get bindings :-P
03:22:55 <jsn> Cale: yeah, i bet you the Clean guys are congratulating themselves on their lack of mindshare right now
03:23:08 <jsn> it's not about popularity
03:23:10 <Twey> And jobs
03:23:11 <Debolaz> There *are* problems with perl. That I don't have a problem to admit. And I would love to find a replacement. But so far, whenever I've tried a new language that someone recommended, I've hit roadblocks and when I asked how to solve the problem in the given language, the answer was usually either riddiculously more time consuming than the perl equivalent or simply "I don't know".
03:23:15 <Cale> Twey: There are lots of things about Python which would probably be better off changed, but won't because it's too big now.
03:23:19 <jsn> it's about engagement
03:23:23 <Twey> Cale: Such as?
03:23:38 <Twey> Python 3000 is set to break compatibility.  They're not too bothered about it.
03:24:04 <jsn> Debolaz: well, if you were learning perl coming from ruby, you'd have the same story to tell
03:24:13 <vixey> GHC currient version + 0.01 breaks compatability .. :p
03:24:25 <dancor> breaking compatibility is the new hotness
03:24:26 <Cale> vixey: hehe
03:24:27 <Twey> Only in tiny ways :-P
03:24:38 <Twey> Breaking compatibility sucks, but stagnating sucks more
03:24:42 <jsn> Debolaz: it doesn't mean you can't write your programs
03:24:51 <Cale> Twey: I agree.
03:25:06 <jsn> Debolaz: but maybe you can tell us more about what you've actually tried and what problems you've had
03:25:12 <Twey> Broken programs can be fixed.
03:25:37 <dancor> @hoogle Console
03:25:37 <lambdabot> System.Posix.Internals get_console_echo :: CInt -> IO CInt
03:25:37 <lambdabot> System.Posix.Internals set_console_buffering :: CInt -> CInt -> IO CInt
03:25:37 <lambdabot> System.Posix.Internals set_console_echo :: CInt -> CInt -> IO CInt
03:25:39 <Debolaz> jsn: It's funny actually, I've talked to several people who jumped ship from perl to ruby; Every single time I asked them why, the answer was always a reason that had more to do with lack of programming knowledge ("Perl don't do OO!") than the actual and real problems perl has.
03:25:42 <vixey> working programs can be bronke
03:25:58 <jsn> Debolaz: well, perl really can't do OO well
03:26:02 <Debolaz> Sure it can.
03:26:09 <Twey> Moose isn't bad, actually.
03:26:21 <Debolaz> Perl has probably some of the most advanced OO implementations amongst any language.
03:26:28 <jsn> Debolaz: really?
03:26:28 <Twey> Nah.
03:26:33 <Twey> CL still beats it.
03:26:34 <jsn> Debolaz: please go on
03:26:37 <Debolaz> Twey: That is true.
03:26:43 <Debolaz> Twey: But I didn't say it was the best. :)
03:26:48 <Twey> Heh, fair enough.
03:26:52 <Cale> Twey: How about fixing the way that infix operators are defined? Will they do that?
03:27:04 <Twey> Cale: For Python?
03:27:11 <Cale> yeah
03:27:22 <Twey> Cale: Probably not.  I think that that's about philosophy rather than an unwillingness to break it, though.
03:27:28 <jsn> Debolaz: does perl support mixins, for example?
03:27:31 <Twey> Custom operators aren't 'simple' enough for them.
03:27:40 <Twey> And to be fair, it's hard to do well with duck-typing.
03:27:49 <Debolaz> jsn: The thing is, when people look at perl, compare it with something else, they completely ignore all the extensions written to it, everything built on top of it, and compare that barebone and minimalistic language to something else. This is not the correct way to compare perl to another language, it gives you a very wrong impression of perl.
03:27:56 <Debolaz> jsn: Yes, it supports mixins.
03:28:53 <jsn> Debolaz: well, do you do that kind of in depth analysis of other languages when you are first trying them out?
03:29:24 <mmorrow> Saizan: here's a maybe hackish attempt http://hpaste.org/11465#a2
03:29:26 <Debolaz> jsn: Yes. I don't throw away Ruby just because it isn't bundled with RoR.
03:29:36 <mmorrow> Saizan: (i didn't test it)
03:29:38 <jsn> Debolaz: presumably it supports mixins as a library of some kind? or has it actually been baked in to the language?
03:30:01 <Cale> Twey: Well, they have special method names for overloading operators which always seemed ugly to me.
03:30:17 <Twey> Cale: It is ugly, but it is simple.
03:30:20 <mmorrow> Saizan: i guess you'd have to escape '|'s and check that case too or something
03:30:21 <Debolaz> jsn: As a library. Which some might consider inelegant, but doesn't make much of a difference from a real world perspective.
03:30:24 <Twey> And I'm not sure how else it would be done, really.
03:30:28 <Twey> Maybe a dictionary
03:30:35 <Twey> foo.operators['>']
03:30:53 <jsn> when a substantial portion of a language's architectural functionality comes in the form of libraries, it's probably time to move on
03:31:00 <electronx> lol
03:31:03 <Twey> jsn: No
03:31:07 <Debolaz> jsn: Why?
03:31:10 <Twey> That's how you know the language is good, generally
03:31:16 <vixey> what is architectural functionality
03:31:21 <jsn> Debolaz: it's no more "real world" to treat perl as some "forever language"
03:31:34 <Twey> If there's basic functionality in libraries, then it means that the language is a) minimal and b) powerful
03:31:53 <Twey> ... Perl just misses out on the 'minimal' bit a little
03:31:54 <jsn> vixey: if we get ML style modules grafted on top of Haskell modules, i would be upset
03:32:04 <Saizan> mmorrow: yup, that's not bad :)
03:32:08 <Cale> Twey: not something like   def x + y: ...
03:32:12 <Twey> (there are a bunch of weird-ass special-case functions in the base language)
03:32:18 <Twey> Cale: How are you going to do that?
03:32:27 <Twey> Cale: Duck-typing, remember?
03:32:32 <mmorrow> Saizan: oops, i just realized that'd zap the first line, but that'd be easy to handle..
03:32:32 <Twey> Cale: x could be anything.
03:32:56 <mmorrow> Saizan: this is interesting, i hadn't really thought of this general idea before..
03:33:05 <Cale> Twey: well, the same mechanism as the current way uses, just with special syntax
03:33:34 <Twey> Cale: The Python folks don't really like syntactic sugar
03:33:35 <Saizan> mmorrow: working nicely with the surrounding layout, you mean?
03:33:46 <Twey> 'Explicit is better than implicit'
03:33:49 <Debolaz> Instead of hardcoding all functionality into the language, the language instead evolves through CPANl, resulting in perl now having one of the best OO implementations. It has been the forerunner for working with databases, the most flexible database abstraction library I have seen is implemented in perl, and it has always been common for perl programs to support multiple databases while it was common to hardcode a certain database driver into prog
03:33:49 <Debolaz> rams written with most other languages at the time.
03:34:20 <jsn> Debolaz: that last bit is, of course, not special anymore
03:34:22 <Cale> Twey: Well, certainly they like hiding *some* things about the operation of the language ;)
03:34:33 <mmorrow> Saizan: yeah essentially, but having to somehow incorporate a way to convey the surrounding layout to the parser, since the layout context isn't available
03:34:46 <mmorrow> like here with '|'
03:34:52 <Twey> Cale: 'As few as possible without it becoming a Lisp' is the general principle, I think :-P
03:35:11 <jsn> i honestly don't expect to use the same language for the next ten years
03:35:35 <jsn> Debolaz: if you are a scientist or something, i guess i can understand that
03:35:50 <mmorrow> Saizan: so yes, working nicely with the surrounding layout i mean :)
03:35:52 <jsn> Debolaz: but i honestly don't think it's too tough to just start over in a new language
03:35:57 <unenough> who put the tion in funktion?
03:36:26 <jsn> and i'd rather be working with languages that are offer a cleaner core language
03:36:34 <jsn> s/that are/that/
03:36:45 <Cale> Twey: another thing I doubt they'll fix is the general incoherence of the standard libraries.
03:36:50 <Twey> Cale: I wouldn't say no to some sugar `def self > x: ...` to be equivalent to `cls.operators['>'] = lambda self, x: ...` though.
03:37:02 <Twey> Have you suggested it to them?
03:37:02 <jsn> no one really gets a chance to clean things up and try again if we all just hold on to perl
03:37:15 <Saizan> mmorrow: i wonder if passing the column to the quasiquoter would be enough in general
03:37:29 <Cale> Twey: yeah, that was essentially my idea (with x implicitly bound to self)
03:37:38 <Cale> Twey: I haven't suggested it.
03:37:38 <vixey> jsn, look what happens though .. all these new languages like I listed earlier
03:37:44 <vixey> jsn, Is any of _that_ progress?
03:37:46 <Debolaz> jsn: As I said, learning a new language isn't the problem. I can program ruby. I like the syntax of ruby. But I guess I'm just spoiled from being able to search on CPAN for whatever task I need solved instead of having to reinvent the wheel. Remember, I do more than just web and I'd like to be able to rely on the language and its community having a solution for whatever problem I might encounter. Perl has proven time and time again that it has.
03:37:50 <Twey> Cale: Try it :)  They might like it.
03:38:42 <jsn> Debolaz: of course that approach is going to make it very hard for new languages to grow and develop
03:38:50 <mmorrow> Saizan: i'm not sure, but either way you'd have to encode that somehow in the quoted part, since all you get to work with is (String -> ExpQ) (String -> PatQ)
03:38:50 <unenough> Debolaz. ouch, perl. Have you at least tried python?
03:39:11 <jsn> vixey: i honestly don't give my attention to every language that crops up
03:39:16 <vixey> jsn, well.. I don't think it is
03:39:37 * Twey does
03:39:39 * Twey loves programming languages
03:39:49 <jsn> vixey: those languages are mostly personal research projects
03:39:50 <mmorrow> Saizan: hmm
03:39:53 * dolio thought Common Lisp had The Best OO.
03:39:53 <unenough> but do they love Twey in return?
03:39:59 <Debolaz> unenough: Yes, but didn't find any convincing reason to switch. Unlike ruby, I don't really consider python's syntax to be a lot better. Different and simpler, yes, and perhaps a bit better, but it wasn't a huge win and perl was better in just about every other aspect.
03:40:06 <Twey> dons: Said it already :-D
03:40:12 <Twey> unenough: Haskell does.  Java's a bitch though.  :-P
03:40:14 <Cale> Another thing which Python could use is a reasonable (even if dynamic) type system. To be honest, I haven't looked at python for some time, but last I checked, types were a bit of a mess.
03:40:31 <Twey> Cale: It's meant to be duck-typed.  It works quite well.
03:40:32 <Cale> You could extend the set of types, but not from Python itself
03:40:45 <Twey> You're not really meant to extend the set of types.
03:40:51 <Twey> You're meant to ignore them as far as possible.
03:40:52 <steven_ashley> Sorry to interupt, can anyone here tell me if *currying* is supported for type declarations? I have the following line "type Hook a st m = Hook" and I want to do "type MyHook = Hook String" it seems like it should work but I get a missing type arguments error. Adding the extra args to both sides fixes the error but I would prefer not.
03:40:55 <jsn> vixey: are you proposing a future where new languages are specced out by the IETF?
03:40:58 <Cale> Yeah, you're probably meant to create objects :)
03:41:08 <Cale> But if that's the case, then why aren't all types object types?
03:41:09 <Twey> Aye
03:41:24 <Twey> Cale: They're aiming for that in 3000, I think
03:41:32 <Cale> Twey: Oh, that would be good :)
03:41:34 <unenough> i would like Python to have less transperancy, like modules not being magic globals but simply objects you get by calling an 'import' function, and other things to make python a capability language
03:41:40 <dolio> steven_ashley: You can't partially apply type synonyms.
03:41:44 <vixey> jsn, no O_o
03:41:53 <steven_ashley> ahh, cheers dolio
03:42:02 <Cale> steven_ashley: With extensions you can.
03:42:05 <Twey> unenough: They are objects you get by calling an __import__() function.
03:42:06 <dolio> steven_ashley: If you had 'data Hook a st m = ...' you could do 'type MyHook = Hook String' though.
03:42:15 <Cale> steven_ashley: But it doesn't let you do anything that you couldn't otherwise do
03:42:19 <jsn> vixey: well, i'm not sure what you think is wrong with all those edge-of-the-wedge languages cropping up is
03:42:25 <unenough> Twey, yes, but the whole global library does import, not __import__
03:42:37 <vixey> jsn, they're uninspiring and unorigional
03:42:38 <steven_ashley> Cale: what extension is that sorry?
03:42:40 <unenough> and also, __import__ returns the same object, not a new one
03:42:44 <jsn> s/cropping up is//
03:42:51 <Twey> unenough: Sure, but import x is just sugar for x = __import__('x')
03:42:55 <jsn> vixey: well, that is the way research is
03:43:03 <unenough> Twey the point is, that x is a singleton
03:43:05 <vixey> jsn, ? no it's not
03:43:07 <steven_ashley> ahh I see
03:43:10 <Twey> unenough: That's true, for fairly obvious performance reasons
03:43:13 <steven_ashley> Cale: dw
03:43:14 <Cale> LiberalTypeSynonyms / TypeSynonymInstances
03:43:18 <steven_ashley> yep :)
03:43:30 <Saizan> we're arguing on python's and perl's features in #haskell? compare them to haskell showing how it is so much better at least
03:43:36 <mmorrow> Saizan: i just realized that trimming all prefix whitespace would be another way to do here2
03:43:38 <jsn> vixey: if you take all of it at as a whole, yeah -- most of it is pretty bland and worthless
03:43:44 <Twey> Saizan: I thought that was implicit ;)
03:43:49 <mmorrow> Saizan: (trimming ... from each line)
03:44:10 <unenough> Twey, i would like to be able to push modules into modules I import, not let them import things magically and have access to whatever they want
03:44:12 <Twey> Python is my good-enough language.  If I'm embarking on a serious project I'll pull out Haskell.
03:44:20 <Cale> Twey: Are the standard libraries still not following any kind of coherent naming convention and all in one flat namespace?
03:44:25 <Saizan> mmorrow: end if i want "foo\n   bar"?
03:44:33 <unenough> Twey, on that, agreed. I'm learning haskell now :)
03:44:36 <mmorrow> Saizan: use here3 ;)
03:44:55 <Twey> Cale: Pretty much, yeah.  The namespacing thing is a design decision.
03:45:10 <Twey> (the Haskell/GHC namespace is fairly flat, too)
03:45:12 <mmorrow> Saizan: hmm, i think a library of here variants is in order
03:45:13 <Cale> Twey: I mean with regard to module names.
03:45:23 <Twey> Ah
03:45:25 <Twey> Yes.
03:45:50 <Saizan> mmorrow: i don't know if we care so much :)
03:45:55 <mmorrow> haha
03:46:03 <jsn> vixey: basically, if you have any kind of vibrant language culture, then of course you will have oodles of garbage surrounding it -- if the cost of entry is low
03:46:05 <mmorrow> Saizan: me neither
03:46:26 <jsn> vixey: so i don't really see how your comment is an indictment
03:46:39 <vixey> @w80 indictment
03:46:48 <jsn> ?
03:46:52 <lambdabot> *** "indictment" wn "WordNet (r) 2.0"
03:46:52 <lambdabot> indictment
03:46:52 <lambdabot>      n 1: a formal document written for a prosecuting attorney
03:46:52 <lambdabot>           charging a person with some offense [syn: {bill of
03:46:52 <lambdabot>           indictment}]
03:46:54 <lambdabot>      2: an accusation of wrongdoing; "the book is an indictment of
03:46:56 <lambdabot> Plugin `dict' failed with: thread killed
03:47:14 <mmorrow> lol
03:47:20 <mmorrow> Plugin `dict' failed with: thread killed
03:47:27 <unenough> ideally there would be only one language, that you get/derive ready-made DSL's for niche things
03:47:33 <vixey> eek it's happenin gto mmorrow too
03:47:50 <mmorrow> Plugin `mmorrow' failed with: thread killed
03:48:15 <jsn> unenough: i think ideally, there'd be an API for languages to communicate easily with one another
03:48:28 <jsn> the API would be less than the languages, not more
03:48:30 <unenough> jsn, why need more than one?
03:48:48 <unenough> oh, i forgot to mention that syntax should be volatile
03:48:57 <unenough> if that's what bothers you
03:50:24 <jsn> unenough: i don't think languages fit together in a  language
03:50:43 <unenough> jsn: what?
03:51:28 <jsn> i don't think you can create one language to rule them all that reserves adequate space for innovation
03:51:43 <vixey> jsn, set theory!
03:52:03 <jsn> then you essentially have a minimal API and not much a language at all
03:52:11 <jsn> s/much/much of/
03:52:11 <unenough> what's api got ot do with it?
03:52:28 <jsn> it's how the different languages communicate with one another
03:52:53 <unenough> they are all based on the same primitives, they don't need an api to communicate
03:52:54 <Twey> 105118 < jsn> i don't think you can create one language to rule them all that reserves adequate space for innovation
03:52:58 <jsn> unenough: i was referring to vixey's comment -- set theory would be a pretty harsh base language
03:52:59 <Twey> Lisp.
03:53:05 <jsn> Twey: no
03:53:20 <unenough> jsn, ok, i agree that set theory is too "low"
03:53:21 <jsn> Twey: list abandoned syntactic innovation
03:53:27 <unenough> Haskell maybe
03:53:29 <jsn> s/list/lisp/
03:53:38 <Twey> And?
03:53:42 <Twey> It works *shrug*
03:53:46 <vixey> "syntactic innovation" :?
03:53:47 <unenough> except that the syntax should be volatile
03:53:56 <unenough> but that's just cake icing
03:54:02 <jsn> Twey: well, i don't like it
03:54:19 <vixey> jsn, you don't know about lisp reader macros
03:54:22 <jsn> Twey: so hey, i'll use a different language that allows me to express, for example, plain text documents
03:54:36 <jsn> Twey: where i can use parentheses unquoted
03:54:53 <vixey> jsn, (they let you do this)
03:54:56 <Twey> jsn: Uhm, you can, in strings :-P
03:54:57 <unenough> i think you are confusing syntax with semantics
03:55:27 <jsn> unenough: would you care to explain why you think that?
03:55:43 <unenough> because allowing you to write things unquoted is just syntax
03:55:52 <vixey> jsn, this is a well known feature in common lisp at least.....
03:56:12 <Saizan> we already have a set of primitives all the languages are decomposed to, assembly
03:56:18 <jsn> unenough: why does what you send demonstrate that i am confusing syntax and semantics?
03:56:22 <Twey> Saizan: It's not global
03:56:27 <Twey> Try C--
03:56:30 <jsn> s/send/said/
03:56:58 <vixey> Twey, is C-- global?
03:57:16 <unenough> jsn, i'm just saying that these things are matters of syntax, and have nothing to do with the question of whether you can or cannot have a 'master language' with good high-level semantics
03:57:18 <Twey> vixey: It's designed to be portable
03:58:15 <vixey> usenough: If you program everything in one language, that does not mean it's easy to use different parts of different programs together
03:58:32 <jsn> unenough: i was only commenting on Lisp's particular area of inflexibility (which i guess is remedied)
03:59:01 <unenough> jsn, ok
03:59:30 <unenough> vixey: i'm not just saying to use one language, i'm saying to use one _good_ language
03:59:38 <unenough> which is obviously the great challenge
03:59:47 <vixey> jsn, I guess ou have never programmed in lisp then..
04:00:01 <jsn> vixey: only briefly
04:00:15 <jsn> vixey: i've talked with a few schemers
04:00:17 <vixey> jsn, ..because this is not inflexibility you can do any of this stuff with it easily
04:00:29 <jsn> vixey: for the most part, they seem to hate syntax, so...
04:00:40 <vixey> jsn, not sure what scheme has to do with lisp..
04:01:02 <jsn> vixey: well, you must not know anything about either of them
04:01:03 <unenough> syntax is the great illusion
04:01:34 <jsn> unenough: wow, you are like buddha!
04:01:36 <unenough> that said, i'll go back to writing PIC18F452 assembly code :( :(
04:01:59 <vixey> jsn, interesting conclusion.. :p
04:03:19 <jsn> unenough: i guess if you could express java and python and such in your language, it could work out
04:03:25 <ski> BMeph : `unfoldr' ?
04:04:00 <jsn> unenough: it sound like you want it to be pretty flexible
04:04:05 <unenough> jsn, that's close to what i was saying. except that not everything in python or java is good stuff you would even want
04:04:30 <unenough> i think limitations are good when they force you to work correctly
04:04:37 <mopped> How can I generate a random integer in in haskell (between two bounds)
04:04:47 <vixey> :t random
04:04:48 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
04:04:50 <jsn> unenough: you need to express these bad things you don't want though
04:04:51 <vixey> :t randomR
04:04:52 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
04:04:56 <vixey> that is it, randomR
04:04:59 <mopped> fromIntegral (getStdRandom (randomR (0, 1)) doesnt work that all
04:05:06 <jsn> unenough: or else you're just giving people a good reason to bail on your framework
04:05:22 <mopped> > randomR (0, 1)
04:05:23 <lambdabot>       Overlapping instances for Show (g -> (t, g))
04:05:24 <lambdabot>        arising from a use ...
04:05:24 <cpfr> jsn the point of scheme is to make syntax a moot point
04:05:31 <cpfr> or lisp rather
04:05:36 <jsn> unenough: it's one thing to be right and quite another to have folks agree with you
04:05:52 <unenough> jsn, agreed. but i'd rather be right.
04:06:01 <unenough> ()in this case)
04:06:27 <jsn> unenough: well, that is why i like the idea of an API that allows divergent languages to communicate with one another
04:06:58 <mopped> vixey: How do I turn it into an Integer/Int?
04:07:02 <jsn> unenough: because i just want to let all those wrong people go over there and do their own thing, and not worry about me over here
04:07:08 <vixey> mopped: What is it?
04:07:32 <mopped> getStdRandom (randomR (0, 1)) :: (Random t, Num t) => IO t
04:07:54 <vixey> mopped: so you have IO Integer
04:07:57 <cpfr> :t ofInteger
04:07:57 <jsn> cpfr: well, i think there's probably a lot of stuff going on there
04:07:57 <jsn> cpfr: i mean, i don't use those languages at all
04:07:57 <lambdabot> Not in scope: `ofInteger'
04:07:59 <vixey> and you want to use Integer?
04:08:10 <jsn> cpfr: macros are big in that family of languages, it seems
04:08:12 <vixey> do i <-  getStdRandom ( ....
04:08:20 <vixey>    something with (f i)
04:08:26 <vixey> f :: Integer -> whatever
04:08:34 <vixey> mopped: does that make sense?
04:08:50 <mopped> nope :|
04:08:51 <cpfr> jsn, the point is the simpler your syntax the easier it is to extend it and reason about it
04:09:04 <vixey> jsn, perhaps it is misguided to claim false things about them and the people that use them? :)
04:09:05 <mopped> I havn't used <- as asignment before, the closest is -> in lambda expressions
04:09:19 <cpfr> <- is not assignment
04:09:27 <cpfr> = is assignment
04:09:28 <vixey> mopped: <- is actually the same as ->
04:09:33 <jsn> vixey: it is generally misguided to claim false things
04:09:40 <jsn> vixey: good come back
04:09:45 <vixey> when you write,   do x <- f; y, this is turned into  f >>= \x -> y
04:10:12 <vixey> so that >>= \ _ -> pulls the Integer out of the IO Integer for anything in y to use
04:10:20 * unenough performs a tlbrd*+
04:11:06 <Saizan> mopped: have you read anything about IO/do-notation/Monads?
04:11:14 <mopped> not at all :P
04:11:33 <vixey> mopped: so did that make some sense?
04:11:34 <unenough> btw, the one thing i'm skeptical about in haskell is, the problem of purely functional data structures efficiency limit compared to modifiable ones, and in general, is the problem of side effects  + functional programming really, completely and absolutely solved in haskell?
04:11:48 <Saizan> @google haskellwiki monads as computations
04:11:51 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows
04:11:51 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki
04:12:22 <mopped> http://hpaste.org/11466 is what i'm trying to make work!
04:12:24 <mopped> ok, ill have a read
04:12:40 <vixey> mopped but you did not put it in 'do'
04:12:55 <Saizan> i was trying to get this :) http://www.haskell.org/haskellwiki/Monads_as_computation
04:12:57 <vixey> that's the only place where <- works
04:12:57 <lambdabot> Title: Monads as computation - HaskellWiki
04:13:52 <Saizan> mopped: you can't use getStdRandom in the middle of a pure function, but you could get a random seed in IO and pass it to your pure function
04:15:08 <mopped> hmm
04:15:19 <cnwdup> I'm trying to write a function with a variable number of arguments which i pass to the i18n library and thus indirectly to the printf library. Is there some documentation that helps me how this variable argument thing functions? I have trouble understanding the source code of Text.Printf.
04:15:38 <cpfr> mopped, i think its time we had a talk about the birds and monoids
04:15:46 <mopped> seems like it!
04:16:08 <vixey> cnwdup, eek ...
04:16:18 <cpfr> i think the rest of the channel can help
04:16:21 * dancor <3's Control.Monad.Random
04:16:27 <vixey> cnwdup, is there a interface to printf that doesn't use varargs?
04:16:31 <vixey> ?where Printf
04:16:31 <lambdabot> I know nothing about printf.
04:16:44 <Saizan> ?type printf
04:16:45 <lambdabot> forall r. (PrintfType r) => String -> r
04:16:51 <vixey> @src printf
04:16:51 <lambdabot> Source not found. My pet ferret can type better than you!
04:17:00 <Saizan> @source Text.Printf
04:17:01 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
04:17:08 <vixey> oh great, thank you
04:17:23 <vixey> does that work in general?
04:17:28 <vixey> @source Data.Map
04:17:29 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
04:17:32 <mopped> I'll have a look at these wikis, they helped with type classes last time
04:17:33 <vixey> :/
04:17:34 <vixey> how terrible
04:17:37 <steven_ashley> vixey: I have used it a few times
04:17:48 <steven_ashley> it works well
04:17:50 <cnwdup> vixey: Nope. But I can't make my function work. I want to write a function which takes a format string for printf, calls the i18n library on it and passes this along with the variable arguments to printf.
04:18:00 <Saizan> vixey: the index is not automatically refreshed
04:18:06 <vixey> cnwdup, data UPrintf = UChar Char | UString String | UInteger Integer Integer | UFloat Float | UDouble Double
04:18:06 <vixey> uprintf :: String -> [UPrintf] -> String
04:18:11 <vixey> uprintf why not use that?
04:18:35 <cnwdup> vixey: I'll try.
04:19:44 <steven_ashley> vixey: uprintf isn't exported from the Text.Printf module
04:19:50 <cnwdup> vixey: uprintf is not exported. )':
04:20:17 <steven_ashley> cnwdup, if you give the result of the printf statement a type it should work
04:20:28 <vixey> no export it :)
04:20:39 <vixey> edit the source cohe
04:20:50 <steven_ashley> that seems hacky :P
04:20:53 <vixey> this makes life easier
04:20:57 <cnwdup> vixey: That would make my code depend on non-standard libraries.
04:21:02 <vixey> cnwdup, good!
04:21:02 <ski> > [ x | x <- [()] ]
04:21:03 <lambdabot>   [()]
04:21:07 <vixey> I'm all for that
04:21:15 <steven_ashley> vixey: why is that a good thing :S?
04:21:27 <Saizan> cnwdup: upload it to hackage, than it's as standard as i18n :)
04:21:30 <vixey> because you don't have to do something so horrendously difficult with typeclasses
04:25:10 <dancor> anyone happen to know if any of the hoogle .hoo databases include HSH?
04:25:28 <dancor> i expected hackage.hoo to be like a hackage snapshot but looks like not
04:33:34 <RayNbow> oh nice, a new sigfpe blogpost
04:37:39 <electronx> can i have if without else?
04:37:45 <Saizan> no
04:37:48 <electronx> if then without else
04:38:01 <steven_ashley> you can use a pattern match should you be that way inclined
04:38:05 <ski> you may have `when' and `unless'
04:38:20 <electronx> never heard of when and unless
04:38:25 <ski> @type when
04:38:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:38:28 <dobblego> electronx, no thankfully, this is a pure language :)
04:38:31 <cnwdup> Ah, sweet. Actually Text.I18n.Printf exports uprintf. (-:
04:38:35 <ski>   do ...
04:38:44 <ski>      when foo $ do
04:38:46 <steven_ashley> cnwdup, it does?
04:38:47 <ski>        ...
04:38:49 <ski>      ...
04:38:53 <steven_ashley> ahh
04:38:57 <vixey> cnwdup: aww :p
04:39:16 <steven_ashley> :)
04:39:16 <Baughn> electronx: What's if supposed to do when the test fails, if it lacks an else?
04:39:19 <Baughn> electronx: Crash?
04:39:40 <electronx> Baughn: go to next instance
04:39:52 <electronx> execute next definition
04:39:59 <Baughn> electronx: if is a pure construct. It has no notion of "next statement".
04:40:00 <electronx> like pattern matching
04:40:14 <Baughn> electronx: You want when, definitely
04:40:21 <steven_ashley> ï»¿electronx: you can use a guard for that
04:40:28 <electronx> i mean skip definition and move to next one
04:40:28 <dancor> yeah guards ftw
04:41:03 <steven_ashley> foo x | x < 4 = 3
04:41:03 <steven_ashley>          | otherwise = 4
04:42:51 <ski>   foo x | x < 0 = -1 / x
04:42:52 <jsn> electronx: is there any language that actually does that?
04:42:58 <ski>   foo 0         = 0
04:43:06 <ski>   foo x | x > 0 =  1 / x
04:43:15 <jsn> uses pattern matching clauses for function definition and then falls through?
04:43:46 <vixey> jsn, Prolog can be thought of that way
04:44:03 <jsn> vixey: oh, interesting
04:44:11 <steven_ashley> vixey: prolog is incredibly insane :)
04:44:26 <ski> Prolog is quite nice
04:44:31 <steven_ashley> in a good way of course :)
04:44:51 <Igloo> Does anyone know how to fix or debug this (mingw/msys): http://hpaste.org/11468
04:48:49 <ski> > select "Prolog" `asTypeOf` []  where  select [    ] = do {mzero}; select (x:xs) = do {return (x,xs)} `mplus` do {(y,ys) <- select xs; return (y,x:ys)}
04:48:51 <lambdabot>   [('P',"rolog"),('r',"Polog"),('o',"Prlog"),('l',"Proog"),('o',"Prolg"),('g'...
04:49:17 <Baughn> @type select
04:49:18 <lambdabot> Not in scope: `select'
04:49:57 <ski> select :: MonadPlus m => [a] -> m (a,[a])
04:50:20 <opqdonut> ah
04:51:07 <electronx> why does toInteger (45 / 3) work?
04:51:12 <electronx> doesn't
04:51:19 <electronx> give error
04:51:22 <Twey> :t asTypeOf
04:51:23 <lambdabot> forall a. a -> a -> a
04:51:32 <Twey> @src asTypeOf
04:51:33 <lambdabot> asTypeOf = const
04:51:39 * Twey twitches.
04:51:47 <electronx> ambiguous
04:51:48 <ski> @type toInteger
04:51:49 <lambdabot> forall a. (Integral a) => a -> Integer
04:51:57 <Twey> What is this thing! x.x
04:52:18 <ski> it wants some integral value
04:52:22 <Twey> :t (/)
04:52:23 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:52:45 <Twey> The result of a division has to be a Fractional
04:52:49 <Saizan> electronx: you want round probably
04:52:55 <ski> @type round
04:52:56 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
04:52:57 <Twey> There's no type that is both Fractional and Integral
04:52:58 <ski> @type floor
04:52:59 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
04:53:01 <ski> @type ceiling
04:53:02 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
04:53:12 <electronx> > toIntegral (43/3) :: Int
04:53:13 <lambdabot>   Not in scope: `toIntegral'
04:53:30 <electronx> > fromIntegral (43/3) :: Int
04:53:31 <lambdabot>   Add a type signature
04:53:32 <ski> Twey : `asTypeOf' ?
04:53:38 <electronx> > (fromIntegral (43/3)) :: Int
04:53:39 <lambdabot>   Add a type signature
04:53:44 <electronx> woot
04:53:52 <ski> > (fromIntegral (43/3 :: Double)) :: Int
04:53:53 <lambdabot>       No instance for (Integral Double)
04:53:53 <lambdabot>        arising from a use of `fromInt...
04:53:54 <Twey> ski: You used it just there :-\
04:54:08 <ski> Twey : yes .. what about it ?
04:54:17 * electronx shoots self
04:54:36 <steven_ashley> ï»¿fromIntegral (ï»¿floor (43/3)) :: Int
04:54:39 <steven_ashley> > ï»¿fromIntegral (ï»¿floor (43/3)) :: Int
04:54:40 <lambdabot>   <no location info>: lexical error at character '\65279'
04:54:46 <ski> electronx : `fromIntegral' is (unsurprisingly) used to convert *from* an integral type .. `43/3' is probably not integral
04:54:49 <Twey> ski: What's it for?
04:55:07 <vixey> :t asTypeOf
04:55:08 <lambdabot> forall a. a -> a -> a
04:55:13 <Twey> ski: As far as I can see, "Prolog" `asTypeOf` [] means const "Prolog" []
04:55:22 <ski> Twey : convincing lambdabot that i want results in the list monad .. without having to spell out the full type of `select "Prolog"'
04:55:23 <vixey> :t const
04:55:24 <lambdabot> forall a b. a -> b -> a
04:55:25 <Twey> Oh, it's (select Prolog) []
04:55:37 <Twey> Er, "Prolog"
04:55:55 <Twey> Ohhh.
04:55:56 <Twey> I see.
04:55:59 <Twey> I see!
04:56:02 <Twey> It makes sense
04:56:14 <ski> @keal
04:56:14 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
04:56:38 <Twey> Haha
04:57:55 <haskell> is there any other way to extract data from my own datatype than by pattern matching?
04:58:13 <Axman6> use record syntax?
04:58:21 <vixey> not really no
04:58:35 <Twey> Well, record syntax is just free pattern matching.
04:58:36 <vixey> you can derive some functions automatically but they would have been defined by pattern matching
04:58:41 <Twey> Aye.
04:59:00 <haskell> where do i find info about that record syntax?
04:59:40 <ski> here, e.g.
04:59:54 <Twey> haskell: data MyType = MyType { foo :: Int } is the same as data MyType = MyType Int; foo :: MyType -> Int; foo (MyType x) = x
05:00:06 <Twey> Plus some special syntax for matching and updating
05:00:11 <Axman6> data T = T {something :: Integer, another :: String}; let x = T {something = 3, another = "hello"} in something x --> 3
05:06:21 <BONUS> hmmm
05:06:23 <BONUS> just wondering
05:06:41 <BONUS> can anyone maybe thing of a way to make data Z a = Z (a ()) an instance of, say, Functor?
05:06:46 <BONUS> s/thing/think
05:07:07 <vixey> function again, it's fmap :: (a -> b) -> (Z a -> Z b)
05:07:15 <vixey> and then you have the rules?
05:07:34 <vixey> fmap f . fmap g = fmap (f . g)?
05:07:36 <vixey> is that everything
05:07:59 <BONUS> yeah, but to implement the function
05:08:24 <vixey> :k Functor
05:08:25 <lambdabot> Class `Functor' used as a type
05:08:27 <BONUS> anyway, I think it just locks up with the kinds
05:08:34 <vixey> I was just thinking that
05:08:57 <vixey> yeah
05:08:57 <vixey> data Z a = Z (a ())
05:08:57 <vixey> instance Functor Z where fmap = undefined
05:09:10 <vixey> Kind mis-match Expected kind `* -> *', but `Z' has kind `(* -> *) -> *'
05:09:30 <BONUS> i was thinking maybe that because if you have: class Bar b where bar :: b a
05:09:41 <BONUS> does that mandate that b is * -> *
05:09:51 <BONUS> cause i think i could implement it with a (* -> *) -> *
05:10:05 <vixey> since bar is a value then b a must be a type i.e. b a :: *
05:10:21 <BONUS> yeah thats one way of thinking about it
05:10:34 <vixey> so that mean sit must be like you said
05:11:16 <BONUS> hmm yeah
05:11:29 <Saizan> no kind polymorphism
05:12:18 <BONUS> cause i was thinking that a doesn't have to really be *
05:12:25 <BONUS> what's important is that b a produces a concrete type
05:12:45 <BONUS> although it seems that GHC just defaults a to kind * and doesn't let you pass if it isn't
05:13:10 <Saizan> that wouldn't work, since 'a' is used in (a -> b') in the type of fmap, so a :: *
05:13:23 <arjanb> maybe you could make a FunctorFunctor class with something fmapf :: ((a :: * -> *) -> (b :: * -> *)) -> G a -> G b
05:13:29 <BONUS> yeah, but i was thinking of
05:13:34 <BONUS> class Bar b where bar :: b a
05:13:34 <arjanb> not sure on how to make ghc eat it
05:13:36 <BONUS> or something like that
05:13:52 <BONUS> all that should matter here imho is that b a is a concrete type, even if a isn't
05:14:00 <frevidar> is there a library that allows me to manipulate images in haskell?
05:14:08 <vixey> class Bar (b :: (* -> * -> * -> *) -> *) where bar :: b a
05:14:28 <frevidar> pretty much, make an image with a name and number added to it
05:14:42 <frevidar> basically trying to make student cards
05:15:06 <BONUS> but it looks like the kind inference doesn't let it pass. so i guess it's safe to assume that in the b a, the a is * if it isnt used as a type constructor somewhere else
05:15:29 <Saizan> BONUS: that's how it works, yes
05:15:54 <BONUS> yeah that's what i was thinking too, i was just looking if we could find some weird cases to prove me wrong
05:17:10 <Saizan> since you need to give a kind to b and you can't just say b :: forall k. k -> *, it defaults to taking an * argument
05:17:58 <BONUS> yeah that's what i was kind of thinking, if it could act like k -> *
05:18:30 <vixey> is it ok to be kind polymorphic?
05:18:40 <BONUS> hmm
05:23:51 <Twey> http://research.microsoft.com/~simonpj/Haskell/records.html â€” how would this do the point-free deconstruction problem?  If name :: Person -> String; clepe = (.name) would seem to be ambiguous
05:24:03 <Twey> Or does it distinguish (.name) from (. name)?
05:24:44 <Axman6> they're different?
05:26:07 <Twey> Axman6: foo.name is a proposed record deconstruction syntax to extract the field 'name'
05:26:24 <Axman6> hmm
05:26:28 <Twey> (if type Person = { name :: String })
05:27:08 <cnwdup> Since (PrintfArg a, PrintfType r) => (a -> r) is a valid PrinfType, I could use fold on it, right? How do I apply the function? My guess was: foldl (\f a -> f a) (printf format) args but it is being rejected by ghci.
05:27:36 <vixey> :t foldl (\f a -> f a) (printf ?format)
05:27:38 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
05:27:38 <lambdabot>     Probable cause: `f' is applied to too many arguments
05:27:38 <lambdabot>     In the expression: f a
05:27:42 <vixey> :t foldl (\f a -> f a)
05:27:43 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
05:27:43 <lambdabot>     Probable cause: `f' is applied to too many arguments
05:27:43 <lambdabot>     In the expression: f a
05:28:11 <cnwdup> Why isn't it working? I don't know why I'm wrong.
05:28:22 <vixey> I don't think foldl makes sense here
05:28:25 <vixey> why do you want to fold at all
05:29:15 <Saizan> ?type foldl
05:29:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:29:18 <Axman6> :t \f a ->  f a
05:29:19 <lambdabot> forall t t1. (t -> t1) -> t -> t1
05:29:55 <cnwdup> Mh, as far as I can see, in the expression printf format arg1 arg2 arg3, printf format builds a function of type (arg1 -> (arg2 -> (arg3 -> r))). I want to do the same since I still can't geht my function with variable arguments working.
05:29:59 <Saizan> cnwdup: you're trying to change the type of the accumulator through the evaluation of yhe foldl
05:30:13 <cnwdup> uprintf isn't working for me since the type UPrintf isn't exported.
05:30:18 <vixey> cnwdup: that's not printf that builds it up
05:30:25 <vixey> cnwdup: the typeclass dispatch does it
05:30:39 <vixey> I'm sure that if you use uprintf you will have no problems at all
05:31:11 <cnwdup> saizan: Do I? It's always (a -> r), isn't it?
05:31:24 <Saizan> cnwdup: with a different 'r' each time tough
05:31:26 <cnwdup> Since r can be (a -> r) as well.
05:32:07 <Saizan> see? you're trying to change what 'r' is :)
05:32:38 <vixey> I think it's possible to implement String -> [Either String (Either Integer (...))] -> String using Printf
05:32:40 <vixey> printf*
05:32:57 <vixey> but you have to do something tricky that makes typeclasses happen at runtime
05:33:09 <cnwdup> vixey: Then how can I wrap (almost) arbitrary types to UPrintf's?  toUPrintf isn't exported.
05:33:21 <vixey> (this is not easier than just exporting uprintf)
05:33:38 <cnwdup> uprintf is exported, but toUPrintf (member of the PrintfArg class) is not.
05:34:04 <vixey> cnwdup: hypotheticaly....... if it was exported would all the problems disappear?
05:34:22 <cnwdup> vixey: I guess so. (-;
05:34:35 <vixey> seems pretty clear what to do
05:37:22 <cnwdup> :info uInteger
05:54:25 <vixey> http://www.mail-archive.com/haskell@haskell.org/msg19908.html
05:54:26 <lambdabot> Title: [Haskell] Haskell with only one typeclass
05:57:32 <arjanb> you only have to look at the title to know it's from oleg..
05:59:06 <luite> how should I make a function, that given a list of values: [[a1,a2,a3],[b1,b2]] returns [a1*b1,a1*b2,a2*b1,a2*b2,a3*b1,a3*b2], it should also work for longer lists
05:59:29 <vixey> > liftM2 (*) [x,y,z] [a,b,c]
05:59:31 <lambdabot>   [x * a,x * b,x * c,y * a,y * b,y * c,z * a,z * b,z * c]
06:01:46 <luite> vixey: ah thanks. that will also work for longer lists ( [[..], [..], [..], ...] using a fold
06:02:21 <RayNbow> > let infixl 1 Â«, Â»; (Â«) = flip ($); (Â») = ($);    in    [a,b] Â«liftM2(*)Â» [x,y,z]
06:02:22 <lambdabot>   [a * x,a * y,a * z,b * x,b * y,b * z]
06:02:56 <vixey> > let infixl 1 Â«, Â»; (Â«) = flip ($) . liftM2; (Â») = ($);    in    [a,b] Â«(*)Â» [x,y,z]
06:02:57 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
06:04:09 <RayNbow> @pl leftarr x f = liftM2 f x
06:04:09 <lambdabot> leftarr = flip liftM2
06:04:23 <RayNbow> > let infixl 1 Â«, Â»; (Â«) = flip liftM2; (Â») = ($);    in    [a,b] Â«(*)Â» [x,y,z]
06:04:25 <lambdabot>   [a * x,a * y,a * z,b * x,b * y,b * z]
06:04:29 <vixey> > let infixl 1 Â«, Â»; x Â« y = liftM2 y x; x Â» y = x y;    in    [a,b] Â«(*)Â» [x,y,z]
06:04:31 <lambdabot>   [a * x,a * y,a * z,b * x,b * y,b * z]
06:04:46 <vixey> this is really good actually
06:05:02 <RayNbow> EvilTerran learnt me this trick :)
06:05:09 <RayNbow> *taught
06:05:34 <scook0> my god, that's horrible! ;)
06:08:02 <luite> I have to admit that I'm more on the 'horrible' than the 'that's really good' side on this ;)
06:08:14 <pjdelport> > product <$> sequence [[a,b,c],[m,n],[x,y,z]]
06:08:15 <lambdabot>   [1 * a * m * x,1 * a * m * y,1 * a * m * z,1 * a * n * x,1 * a * n * y,1 * ...
06:08:36 <pjdelport> luite: that works for longer lists
06:08:53 <luite> pjdelport: ah, thanks, that's even better
06:09:13 <pjdelport> (with (<$>) = fmap, just in case)
06:14:26 <Saizan> > let infixl 4 Â«, Â»; x Â« y = liftM2 y x; x Â» y = x y; in [a,b] Â«(\a b c d -> a * b * c * d)Â» [x,y,z] <*> [e] <*> [w]
06:14:28 <lambdabot>   [a * x * e * w,a * y * e * w,a * z * e * w,b * x * e * w,b * y * e * w,b * ...
06:15:59 <vixey> > let infixl 4 Â«, Â»; x Â« y = liftM2 y x; x Â» y = x y; in [a,b] Â«(\a b c d -> a * b * c * d)Â» [x,y,z] Â«($)Â» [e] Â«($)Â» [w]
06:16:01 <lambdabot>   [a * x * e * w,a * y * e * w,a * z * e * w,b * x * e * w,b * y * e * w,b * ...
06:22:16 <cnwdup> Which one is the new locale package?
06:22:23 <cnwdup> I can only find old-locale on hackage.
06:25:17 <tegguN> hey guys, quick question, i have a list of a list of strings (eg [["hello","hello"],["paul"]]) and i want to count the number of elements in each list, how could i do it?
06:25:40 <cnwdup> > map length [["hello", "hello"], ["paul"]]
06:25:40 <cnwdup> ?
06:25:41 <lambdabot>   [2,1]
06:25:50 <mmorrow> i just uploaded an alpha version of a pkg which translates haskell-src-exts syn to th syn
06:25:52 <mmorrow> http://www.haskell.org/pipermail/haskell-cafe/2008-October/049815.html
06:25:54 <lambdabot> Title: [Haskell-cafe] Haskell syntax inside QuasiQuote, http://tinyurl.com/5qcupb
06:26:13 <mmorrow> so haskell QuasiQuoters are teh easy now :)
06:26:26 <tegguN> hmm is there another way? I'm supposed to be doing my work based on stuff in my notes and I'm not sure maps have been mentioned
06:26:44 <vixey> just curious but what do you do with a haskell quasi quoter
06:27:01 <vixey> like a complete transform of the code inside it?
06:27:14 <pjdelport> tegguN: map is pretty basic and fundamental :)
06:27:24 <pjdelport> you could always implement it from scratch
06:27:28 <pjdelport> @scr map
06:27:29 <lambdabot> Maybe you meant: arr rc src
06:27:39 <mmorrow> you can hijack do notation for whatever purpose you see fit, you can enable using ++ in patterns (if you can sensibly translate that to something), you can recover monad comprehensions, you can...
06:27:59 <pjdelport> @src map
06:27:59 <lambdabot> map _ []     = []
06:28:00 <lambdabot> map f (x:xs) = f x : map f xs
06:28:08 <mmorrow> <vixey> like a complete transform of the code inside it?
06:28:11 <mmorrow> exactly
06:28:39 <mmorrow> the hs :: QuasiQuoter example there is the /identity/ haskell QuasiQuoter
06:28:58 <mmorrow> [$hs|\x -> (x,x)|] === \x -> (x,x)
06:30:04 <tegguN> is there anyway i can work on each individual element of a list? eg. apply length to the first element, second element and so on storing each value?
06:30:20 <vixey> tegguN: map
06:30:41 <tegguN> ahh thanks i guess i'll have to study map :D
06:30:51 <mmorrow> vixey: err, i don't think i've covered the do-notation case in Language.Haskell.Meta.Syntax.Translate yet..
06:31:25 <vixey> it would be cool to turn [$i| f x y z |] into f <$> x <*> y <*> z
06:32:24 <mmorrow> i'll add some that stuff to lunabot
06:40:39 <mmorrow> err, ok i just uploaded 0.0.2 of haskell-src-meta which fixes importing a module from haskell-src-exts which is hidden in all but my haskell-src-exts
06:41:58 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta-0.0.2
06:42:00 <lambdabot> Title: HackageDB: haskell-src-meta-0.0.2, http://tinyurl.com/58kdcj
06:42:48 <mmorrow> gah, i'm an idiot
06:42:57 * mmorrow uploads 0.0.3
06:44:55 <tegguN> what if I was to use zip/unzip for my problem above? I see that has map implemented somewhere in it
06:46:37 <Cale> tegguN: zip/unzip are often handy in conjunction with map, but you can't implement one with the other.
06:47:05 <vixey> :t zip ($) . replicate ?f
06:47:06 <lambdabot>     Couldn't match expected type `[a]'
06:47:06 <lambdabot>            against inferred type `(a1 -> b) -> a1 -> b'
06:47:06 <lambdabot>     In the first argument of `zip', namely `($)'
06:47:09 <vixey> oh
06:47:36 <Cale> tegguN: One of the most common uses of zip with map is to zip a list with the list [0..], so that the map can have something different happen based on the index of the element in the list.
06:47:42 <Cale> For instance...
06:48:35 <Cale> > map (\(k,x) -> if even k then toUpper x else toLower x) . zip [0..] $ "hello there"
06:48:36 <lambdabot>   "HeLlO ThErE"
06:49:46 <tegguN> ahh that makes sense
06:50:16 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta-0.0.3
06:50:17 <lambdabot> Title: HackageDB: haskell-src-meta-0.0.3, http://tinyurl.com/6kqmzh
06:50:21 <mmorrow> , parseExp "x"
06:50:24 <lunabot>  Right (VarE x)
06:50:33 <mmorrow> , parsePat "a@(_,x)"
06:50:35 <lunabot>  luna: Ambiguous occurrence `parsePat'
06:50:39 <mmorrow> sigh
06:51:12 <mmorrow> , Language.Haskell.Meta.Parse.parsePat "a@(_,x)"
06:51:15 <lunabot>  Right (AsP a (TupP [WildP,VarP x]))
06:51:56 <mmorrow> , let y = 99 in [$hs|\x -> (x,y)|] 42
06:51:58 <lunabot>  luna: Not in scope: `hs'
06:52:03 <mmorrow> oh
06:52:11 <mmorrow> (42,99)(
06:54:11 <vixey> are there any mixfix parser in haskell?
06:54:57 <mmorrow> <vixey> it would be cool to turn [$i| f x y z |] into f <$> x <*> y <*> z
06:55:39 <mmorrow> (wrt mixfix), how do you mean?
06:55:53 <mmorrow> , parseExp "f x y z"
06:55:55 <lunabot>  Right (AppE (AppE (AppE (VarE f) (VarE x)) (VarE y)) (VarE z))
06:55:56 <vixey> â™ª [$i| (,) "foo" "bar" |]
06:55:58 <lunabot>  luna: Not in scope: `i'
06:56:00 <mmorrow> , parseExp "f <$> x <*> y <*> z"
06:56:03 <lunabot>  Right (InfixE (Just (InfixE (Just (InfixE (Just (VarE f)) (VarE <$>) (Jus...
06:56:09 <mmorrow> hmm
06:56:16 <vixey> â™ª (,) <$> "foo" <*> "bar"
06:56:18 <mmorrow> , src 'InfixE
06:56:19 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
06:56:41 <lunabot>  data Exp = ... | InfixE (Maybe Exp) Exp (Maybe Exp) | ...
06:56:41 <lunabot>  infixl 9
06:57:07 <vixey> mmorrow: Something that can handle things like if/then/else and [[_]]
06:59:08 <vixey> you can guess why I don't  want ot write it :S
06:59:21 <mmorrow> heh
06:59:32 <mmorrow> i like ReadP a lot
06:59:32 <vixey> it's hard to write a pretty printer that works with it
06:59:54 <mmorrow> dunno if ReadP is what you're looking for though
07:00:04 <vixey> no it's not
07:00:33 <mmorrow> what is the difficulty with eg if/then/else ?
07:00:59 <vixey> none of it is especially hard, it's just having everything together
07:01:08 <mmorrow> ah, i gotcha
07:02:01 <vixey> I know how to parse and print infix operatiors and function application
07:02:30 <vixey> maybe mixfix is just the same as this
07:02:38 <mmorrow> oh, i think i see what you're going for now..
07:02:52 <mmorrow> how would you define "mixfix" though?
07:05:18 <mmorrow> , let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z")
07:05:21 <lunabot>  [VarE f,VarE x,VarE y,VarE z]
07:05:48 <vixey> oh very nice :)
07:06:54 <vixey> â™ª foldr1 AppE (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:06:57 <lunabot>  AppE (VarE f) (AppE (VarE x) (AppE (VarE y) (VarE z)))
07:07:25 <mmorrow> i'm trying to figure out a nice way to stick the <$> .. <*> .. <*> ... in now
07:07:36 <vixey> â™ª foldr1 AppE . (intersperse parseExp "Ã¸") $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:07:39 <lunabot>  luna: Couldn't match expected type `GHC.Base.String
07:07:45 <vixey> w:(
07:07:49 <mmorrow> hmm
07:07:55 <mmorrow> oh,
07:07:58 <mmorrow> , parseExp
07:08:00 <lunabot>  luna: No instance for (GHC.Show.Show
07:08:02 <mmorrow> grr
07:08:06 <vixey> â™ª foldr1 AppE . intersperse (parseExp "Ã¸") $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:08:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
07:08:18 <mmorrow> , src 'parseExp
07:08:21 <vixey> :t intersperse
07:08:22 <lambdabot> forall a. a -> [a] -> [a]
07:08:28 <lunabot>  parseExp :: String -> Either String Exp
07:08:36 <Saizan> mmorrow: why packedstring?
07:08:44 <vixey> â™ª foldr1 AppE . intersperse (either undefined (parseExp "Ã¸")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:08:46 <lunabot>  luna: Couldn't match expected type `b -> c'
07:08:50 <mmorrow> Saizan: template-haskell uses it sadly
07:08:53 <vixey> â™ª foldr1 AppE . intersperse (either undefined id (parseExp "Ã¸")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:08:56 <lunabot>  AppE (VarE f) (AppE (VarE
07:09:04 <mmorrow> Saizan: i guess for compat with GHC internals
07:09:16 <mmorrow> , src ''Name
07:09:21 <lunabot>  data Name = Name OccName NameFlavour
07:09:23 <mmorrow> , src ''OccName
07:09:24 <vixey> haha
07:09:28 <lunabot>  type OccName = PackedString
07:09:28 <vixey> mmorrow did you see that?
07:09:32 <mmorrow> whoa
07:09:35 <vixey> , parseExp "Ã¸"
07:09:38 <lunabot>  Right (VarE
07:09:41 <vixey> â™ª foldr1 AppE . intersperse (either undefined id (parseExp "!")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:09:44 <lunabot>  luna: Prelude.undefined
07:09:45 <mmorrow> hmm
07:10:00 <vixey> â™ª foldr1 AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:10:06 <lunabot>  AppE (VarE f) (AppE (VarE q) (AppE (VarE x) (AppE (VarE q) (AppE (VarE y)...
07:10:36 <vixey> â™ª foldr AppE (either undefined id (parseExp "h")) . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:10:39 <lunabot>  AppE (VarE f) (AppE (VarE q) (AppE (VarE x) (AppE (VarE q) (AppE (VarE y)...
07:10:52 <vixey> oh that's backwards...
07:10:54 <mmorrow> weird, that happens when i compile it too
07:11:07 <vixey> â™ª foldl (flip AppE) (either undefined id (parseExp "h")) . reverse . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:11:10 <lunabot>  AppE (VarE f) (AppE (VarE q) (AppE (VarE x) (AppE (VarE q) (AppE (VarE y)...
07:11:17 * vixey gives up :/
07:11:21 <mmorrow> vixey: heh, yeah it's tricky which way to fold those Apps
07:11:30 <vixey> â™ª foldl (flip AppE) (either undefined id (parseExp "h")) . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:11:33 <lunabot>  AppE (VarE z) (AppE (VarE q) (AppE (VarE y) (AppE (VarE q) (AppE (VarE x)...
07:11:42 <mmorrow> to see it, you can do
07:11:44 <vixey> I wanted h at the start... why do I try to put it in the fold ...
07:11:55 <mmorrow> â™ª ppDoc (foldl (flip AppE) (either undefined id (parseExp "h")) . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z")))
07:11:58 <lunabot>  z (q (y (q (x (q (f h))))))
07:12:00 <vixey> â™ª AppE (either undefined id (parseExp "h")) . foldr AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:12:03 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
07:12:18 <vixey> â™ª AppE (either undefined id (parseExp "h")) . foldr1 AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in either undefined unwind (parseExp "f x y z"))
07:12:21 <lunabot>  AppE (VarE h) (AppE (VarE f) (AppE (VarE q) (AppE (VarE x) (AppE (VarE q)...
07:12:31 <vixey> that should be it I think? if you replace h with <$> and q with <*>
07:12:35 <mmorrow> â™ª AppE (either undefined id (parseExp "h")) . foldr1 AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in ppDoc $ ither undefined unwind (parseExp "f x y z"))
07:12:37 <lunabot>  luna: Not in scope: `ither'
07:12:39 <mmorrow> â™ª AppE (either undefined id (parseExp "h")) . foldr1 AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in ppDoc $ either undefined unwind (parseExp "f x y z"))
07:12:41 <lunabot>  luna: Couldn't match expected type `[Language.Haskell.TH.Syntax.Exp]'
07:12:47 <mmorrow> gah
07:12:53 <vixey> can you run it?
07:13:03 <vixey> â™ª run (AppE "f" "x")
07:13:05 <lunabot>  luna: Not in scope: `run'
07:13:06 <mmorrow> â™ª AppE (either undefined id (parseExp "h")) . foldr1 AppE . intersperse (either undefined id (parseExp "q")) $ (let unwind (AppE e e') = unwind e ++ [e'] ; unwind e = [e] in fmap ppDoc $ either undefined unwind (parseExp "f x y z"))
07:13:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
07:13:23 <vixey> btw is there no fold on <whatever>E ?
07:13:30 <mmorrow> if you ran it, the f x y z wouldn't be in scope though
07:13:48 <mmorrow> vixey: no, there should be though
07:14:18 <mmorrow> i always let th [|...|] show me what i need to build
07:14:31 <mmorrow> , [|\f x y z -> f x y z|]
07:14:34 <lunabot>  LamE [VarP f_0,VarP x_1,VarP y_2,VarP z_3] (AppE (AppE (AppE (VarE f_0) (...
07:14:40 <mmorrow> foldr
07:14:47 <mmorrow> err
07:14:59 <vixey> ohhhh
07:15:03 <mmorrow> , (\(LamE _ e) -> e) `fmap` [|\f x y z -> f x y z|]
07:15:07 <lunabot>  AppE (AppE (AppE (VarE f_0) (VarE x_1)) (VarE y_2)) (VarE z_3)
07:15:12 <vixey> â™ª [| f <$> x <*> y <*> z |]
07:15:13 <lunabot>  luna: Not in scope: `f'
07:15:19 <vixey> â™ª [| \f x y z -> f <$> x <*> y <*> z |]
07:15:22 <lunabot>  LamE [VarP f_0,VarP x_1,VarP y_2,VarP z_3] (InfixE (Just (InfixE (Just (I...
07:15:27 <vixey> ;(
07:15:31 <mmorrow> , src 'LamE
07:15:36 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
07:15:36 <lunabot>  infixl 9
07:15:48 <mmorrow> , parseExp " f <$> x <*> y <*> z"
07:15:50 <lunabot>  Right (InfixE (Just (InfixE (Just (InfixE (Just (VarE f)) (VarE <$>) (Jus...
07:16:00 <mmorrow> the nice thing about parseExp is that the vars don't have to be in scope
07:16:26 <vixey> does lunabot understand let yet?
07:16:28 <vixey> and data
07:16:34 <vixey> â™ª let x = 3
07:16:36 <vixey> â™ª x
07:16:36 <lunabot>  luna: parse error on input `)'
07:16:38 <lunabot>  luna: Not in scope: `x'
07:17:12 <Saizan> , M.fromList []
07:17:14 <lunabot>  luna: Not in scope: `M.fromList'
07:18:03 <mmorrow> , let unInfix (InfixE (Just a) e (Just b)) = AppE (AppE e a) b ; unInfix e = e in either undefined (everywhere (mkT unInfix)) $ parseExp " f <$> x <*> y <*> z"
07:18:06 <lunabot>  AppE (AppE (VarE <*>) (AppE (AppE (VarE <*>) (AppE (AppE (VarE <$>) (VarE...
07:18:48 <mmorrow> heh, it looks like it's right folds inside an enclosing left fold
07:18:50 <vixey> that use of everywhere is really cool
07:19:05 <vixey> would never have thought of that ..
07:19:07 <mmorrow> totally, everywhere is sooo friggin handy
07:19:20 <vixey> I'd usually write like
07:19:55 <vixey> unInfix = foldE id id id id id id id id id (\e a b -> AppE (AppE e a) b) id id id id id id id id id id
07:20:01 <vixey> that kind of thing ..
07:20:04 <mmorrow> hah
07:20:29 <mmorrow> or:
07:20:46 <mmorrow> idFoldE { foldAppE = (\e a b -> AppE (AppE e a) b) }
07:20:55 <vixey> ooh
07:21:12 <vixey> ok I am getting some new tricks
07:21:32 <mmorrow> recordupdatesyntaxfordefaults++
07:22:45 <mmorrow> Saizan: that's next on my todo list
07:22:50 <mmorrow> <Saizan> , M.fromList []
07:28:53 <mmorrow> <vixey> does lunabot understand let yet?
07:28:58 <mmorrow> that's badly needed
07:31:57 <vixey> â™ª parseExp "let x = 3"
07:32:10 <lunabot>  Left "4\nSrcLoc {srcFilename = \"<unknown>.hs\", srcLine = 5, srcColumn =...
07:32:12 <vixey> â™ª parseExp "let x = 3                        in ()"
07:32:15 <lunabot>  Right (LetE [ValD (VarP x) (NormalB (LitE (IntegerL 3))) []] (ConE GHC.Un...
07:35:20 <elaC> HELLO :D !
07:35:24 <mmorrow> vixey: hmm, yeah the hackey abounds in parseHsExp
07:35:27 <elaC> my connection is lagging :S
07:35:31 <mmorrow> s/hackey/hackery/
07:35:33 <vixey> I'm not sure how to do it realllly..
07:35:53 <vixey> chop off the let, split on the =
07:36:08 <mmorrow> err, what are you going for?
07:36:15 <mmorrow> â™ª parseExp "let x = 3 in ()"
07:36:18 <lunabot>  Right (LetE [ValD (VarP x) (NormalB (LitE (IntegerL 3))) []] (ConE GHC.Un...
07:37:17 <daf> hmm, why is that (VarP x) and not (VarP "x")?
07:37:19 <mmorrow> , either undefined (text . pretty) $ parseExp "let x = 3 in ()"
07:37:22 <lunabot>  LetE [ValD (VarP x) (NormalB (LitE (IntegerL 3))) []]
07:37:22 <lunabot>    (ConE GHC.Unit . ())
07:38:11 <mmorrow> daf: the template-haskell Show instances for Name aren't the derived ones (which is a pain more than it helps imo)
07:38:30 <daf> oh
07:38:45 <mmorrow> , parseExp "x"
07:38:48 <lunabot>  Right (VarE x)
07:38:55 <daf> read . show /= id considered obnoxious :P
07:39:02 <mmorrow> , either undefined lift (parseExp "x")
07:39:05 <lunabot>  AppE (ConE VarE) (AppE (AppE (ConE Name) (AppE (VarE packString) (LitE (S...
07:39:26 <mmorrow> daf: totally
07:39:39 <mmorrow> , src ''Name
07:39:50 <lunabot>  data Name = Name OccName NameFlavour
07:39:54 <mmorrow> , src ''NameFlavour
07:39:59 <lunabot>  data NameFlavour = NameS
07:39:59 <lunabot>                   | NameQ ModName
07:39:59 <lunabot>                   | NameU Int#
07:40:07 <mmorrow> , src ''OccName
07:40:12 <lunabot>  type OccName = PackedString
07:40:27 <mmorrow> (there are more NameFlavours but they got chopped)
07:59:14 <Cale> d3mn0id: I suppose the purpose of Haskell is to be a good lazily evaluated pure functional programming language.
07:59:44 <Cale> d3mn0id: It has a lot of nice features and properties which make it enjoyable to program in.
08:00:09 <orgOfStudying> Cale : and no ugly C syntax :D
08:00:17 <Cale> Should I try and list some, or show some examples?
08:01:16 <Cale> One nice thing about Haskell is that it doesn't evaluate things unless it absolutely needs to (it's lazy), and this allows you some extra freedom in terms of how you express algorithms. It lets you work with infinite datastructures.
08:01:40 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
08:01:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:01:50 <Cale> That would be the infinite list of prime numbers.
08:02:17 <Cale> (it computes them as needed)
08:02:23 <d3mn0id> cool
08:02:26 <koninkje> that's one of the cleanest prime filters I've seen yet
08:02:40 <Taejo> koninkje: but it's slow
08:03:01 <Cale> d3mn0id: What programming languages are you already familiar with?
08:03:10 <koninkje> Taejo: oh indeed. But it's still prettier than the other slow implementations
08:03:20 <Taejo> koninkje: that's true
08:03:50 <koninkje> nubBy > iterative filtering
08:04:06 <Cale> nubBy captures iterative filtering
08:04:11 <Twey> That's impressive :-D
08:04:36 <d3mn0id> Python and C but I'm a n00b
08:04:38 <PeakerWork> I am looking at http://www.haskell.org/haskellwiki/Phooey -- I don't understand how "ui1 :: UI (IO ())" is the right type: Where does IO come from here? everything seems to be in the UI/Source monads?
08:04:40 <lambdabot> Title: Phooey - HaskellWiki
08:04:42 <Cale> d3mn0id: okay
08:04:54 <Cale> d3mn0id: So, you might know about list comprehensions from Python already?
08:05:13 <PeakerWork> Beelsebob: you there?
08:05:27 <Cale> You might have even run into functions like map and reduce
08:05:39 <Cale> > map (*2) [1..10]
08:05:41 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:05:58 <Twey> d3mn0id: http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
08:06:00 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/eogyw
08:06:12 <PeakerWork> I think that part of the wiki page might be wrong
08:06:13 <d3mn0id> in both
08:06:14 <Cale> > map reverse (words "Here's some stuff to reverse word by word.")
08:06:15 <lambdabot>   ["s'ereH","emos","ffuts","ot","esrever","drow","yb",".drow"]
08:06:29 <Cale> > unwords (map reverse (words "Here's some stuff to reverse word by word."))
08:06:30 <lambdabot>   "s'ereH emos ffuts ot esrever drow yb .drow"
08:06:49 <Twey> PeakerWork: Wrong?  Why?
08:06:51 <Twey> Oh
08:06:54 <Twey> *That* page.
08:07:42 <PeakerWork> Twey: Phooey, yeah. I think 'total = title "total" showDisplay' wouldn't type-check
08:08:02 * Twey nods.
08:08:32 <Cale> d3mn0id: Another thing which Haskell has, but which perhaps takes some time to fully appreciate is a really good static type system.
08:09:04 <Cale> d3mn0id: C++ has a static type system, but a lot of the time, it gets in your way without really helping much with program correctness.
08:09:33 <Cale> d3mn0id: Haskell has a very expressive type system, and most (if not all) types can be inferred by the compiler if you leave them out.
08:12:35 <Taejo> @pl \(x, y) -> ((1, x), (1, y))
08:12:36 <lambdabot> (,) 1 *** (,) 1
08:12:44 <Taejo> :t (***)
08:12:45 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:12:48 <Taejo> :t (&&&)
08:12:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:13:23 <Cale> (b -> c) -> (b -> c') -> (b -> (c,c'))
08:13:35 <Taejo> thanks Cale
08:13:49 <Cale> er, that was (&&&)
08:14:18 <Twey> What does (&&&) actually do?
08:14:25 <Taejo> Cale: yeah, got that
08:14:33 <Twey> All I've ever seen it used for is \x y z -> (x z, y z)
08:14:41 <Taejo> Twey: exactly
08:14:47 <Taejo> but for arbitrary arrows
08:14:48 <Cale> Twey: It's one of the arrow combinators.
08:14:52 <Twey> But it does more than that, right?
08:14:54 <Twey> Oh
08:16:09 <Cale> Twey: It's sort of like, given two arrows f and g, make a new one whose input flows into both f and g and whose output is pairs of f's output with g's output.
08:16:45 <Twey> And (->) is an arrow?
08:16:59 <Saizan> yup
08:17:16 <Cale> Sort of the most trivial arrow possible.
08:17:38 <Cale> Oh, the naming is a bit confusing though
08:17:49 <Cale> since we call things arrows on the type level as well as the value level
08:18:01 <Cale> and they're not quite the same as category theoretic arrows :P
08:19:00 <Taejo> Cale: aren't the arrows in the Haskell category exactly the Haskell functions?
08:19:04 <Cale> yes
08:20:00 <Saizan> (&&&) is also connected with Applicative, since instance Arrow a => Applicative (a r) where pure x = arr (const x); f <*> x = (f &&& x) >>> arr (uncurry ($))
08:20:02 <PeakerWork> hmm.. ghci accepts: let x <***> y = liftA2 (flip ($)) x y     but not: let (<***>) = liftA2 (flip ($))
08:20:10 <PeakerWork> how come?
08:20:17 <Saizan> PeakerWork: monomorphism restriction
08:20:37 <Cale> :set -XNoMonomorphismRestriction
08:20:57 <PeakerWork> But even if I specify the type signature it still doesn't work: let (<***>) = liftA2 (flip ($)) :: Applicative f => f a -> f (a->b) -> f b
08:21:02 <Cale> For something you have to turn off all the time, the MR has an annoyingly long name.
08:21:13 <Taejo> are there consequences to -XNoMonomorphismRestriction besides the removal of an irritating restriction?
08:21:24 <Cale> PeakerWork: You have to give the type signature as a separate declaration.
08:21:34 <PeakerWork> ah
08:21:35 <Saizan> PeakerWork: you need to specify it for (<***>), not for the expression in the body
08:21:57 <Cale> let (<***>) :: Applicative f => f a -> f (a->b) -> f b; (<***>) = liftA2 (flip ($))
08:22:25 <Cale> Taejo: basically not. Some more types might become ambiguous.
08:22:36 <PeakerWork> Cale, Saizan: ah cool, it works, thanks
08:22:50 <PeakerWork> I was wondering how to define <**> just using Applicative itself, so excercise successful :)
08:23:08 <Cale> Taejo: and there are cases where the polymorphism causes your program to run slower than you might expect
08:23:26 <Taejo> Cale: that's exactly what I was worried about
08:23:30 <Saizan> PeakerWork: what about flip (<*>) ?
08:23:41 <Saizan> Cale: or faster :)
08:23:42 <PeakerWork> Saizan: that performs the effects of the right side first, instead of left side
08:24:02 <Saizan> PeakerWork: oh, right
08:24:09 <Cale> Taejo: Well, it's just that typeclass polymorphism can turn values into functions under the covers.
08:24:20 <Cale> Taejo: (functions of the typeclass dictionary)
08:24:58 <Cale> Taejo: Normally if you write  x = product [1..1000], and don't give it a type signature, the MR will force it to be monomorphic, which means that it'll be defaulted to Integer
08:25:05 <Taejo> Cale: so only constant slowdown? no loss of sharing?
08:25:07 <Cale> and it'll be computed at most once
08:25:23 <Taejo> oh right, so that does cause loss of sharing
08:25:31 <Saizan> yeah, that's the whole point
08:25:37 <Cale> So if that's polymorphic, it'll be recomputed every time.
08:25:53 <Cale> But of course, you can just give it an explicit type signature.
08:26:02 <Cale> (and it'll be fast again)
08:26:35 <mopped> A Monad is just a combinator library, what's a combinator library? A library of functions that you use to create the 'bigger picture'? Such as open/save/draw dot in an image library or something?
08:27:07 <Taejo> mopped: yeah, something like that
08:27:43 <Cale> mopped: Basically a library where you have some simple values which represent computations, and then ways to combine them.
08:27:47 <Taejo> except maybe combinators for "circle", "line", "superimpose", "next_to" would be more Haskell-ish
08:27:59 <Taejo> see byorgey's Diagrams package for such an example
08:28:00 <Cale> yeah, more like that :)
08:28:24 <Cale> You have primitives, like shapes, and then ways to combine them like superimpose
08:28:53 <mopped> ok, thanks
08:29:07 <Cale> Maybe even higher order things, like a function which replaces all the lines in one drawing according to some function which takes a line and produces another picture.
08:31:06 <Taejo> > tails "Haskell"
08:31:07 <lambdabot>   ["Haskell","askell","skell","kell","ell","ll","l",""]
08:32:42 <Taejo> > zipWith (map . (,)) "Haskell" (tails "Haskell")
08:32:44 <lambdabot>   [[('H','H'),('H','a'),('H','s'),('H','k'),('H','e'),('H','l'),('H','l')],[(...
08:32:51 <Taejo> excellent
08:33:08 <Cale> hmm
08:33:58 <Cale> > [(x,y) | (x:xs) <- tails "Haskell", y <- xs]
08:33:59 <lambdabot>   [('H','a'),('H','s'),('H','k'),('H','e'),('H','l'),('H','l'),('a','s'),('a'...
08:34:42 <Cale> > [(x,y) | xs <- tails "Haskell", y <- xs]
08:34:44 <lambdabot>   [(x,'H'),(x,'a'),(x,'s'),(x,'k'),(x,'e'),(x,'l'),(x,'l'),(x,'a'),(x,'s'),(x...
08:34:53 <Cale> heh, oh right :)
08:35:06 <Taejo> [(x,y) | (x:xs) <- tails "Haskell", y <- x:xs]
08:35:12 <Taejo> > [(x,y) | (x:xs) <- tails "Haskell", y <- x:xs]
08:35:13 <lambdabot>   [('H','H'),('H','a'),('H','s'),('H','k'),('H','e'),('H','l'),('H','l'),('a'...
08:35:28 <Taejo> can lambdabot unsugar list comprehensions?
08:35:47 <ddarius> Yes.
08:35:48 <Cale> @undo [(x,y) | (x:xs) <- tails "Haskell", y <- (x:xs)]
08:35:49 <lambdabot> concatMap (\ a -> case a of { (x : xs) -> concatMap (\ y -> [(x, y)]) (x : xs); _ -> []}) tails "Haskell"
08:36:29 <Cale> @undo do (x:xs) <- tails "Haskell"; y <- (x:xs); return (x,y)
08:36:29 <lambdabot> tails "Haskell" >>= \ a -> case a of { (x : xs) -> (x : xs) >>= \ y -> return (x, y); _ -> fail ""}
08:36:45 * Cale shakes his fist at fail.
08:37:23 <Taejo> (fail "This list is empty") is my favourite synonym of []
08:39:45 <Cale> Mine is  [(x,y,z)| x <- [1..10^100], y <- [1..x], z <- [1..y], x^3 + y^3 == z^3]
08:44:16 <tegguN> okay guys i need some serious help with my coursework
08:44:41 <tegguN> the task is to create a text processing application, that takes input and outputs a histogram
08:45:34 <mopped> I thought <- only worked inside a 'do', does it have a different meaning in list comprehensions?
08:45:55 <tegguN> eg "hello hello i am stuck help" would produce "hello **/ni */nam */nstuck */nhelp *"
08:46:22 <tegguN> where the number of *'s relate to the number of times each word occurs in the string
08:46:55 <LarstiQ> tegguN: it seems you have all the information needed to tackle this problem.
08:47:21 <tegguN> i can do most of the coursework (removing duplicates, alphabetising the list, removing punctuation etc. etc.) but i'm stuck at one point
08:47:34 <tegguN> (hold on a sec I'm getting there :-) )
08:47:44 <Taejo> :t zipWith (map . (,)) [] $ tails []
08:47:45 <lambdabot> forall a a1. [[(a1, a)]]
08:48:01 <Taejo> :t zipWith (concatMap . (,)) [] $ tails []
08:48:02 <lambdabot>     Couldn't match expected type `[b]' against inferred type `(a1, a)'
08:48:02 <lambdabot>       Expected type: a1 -> a -> [b]
08:48:02 <lambdabot>       Inferred type: a1 -> a -> (a1, a)
08:48:19 <tegguN> I filter through the text by group (sort (words theText))
08:49:01 <tegguN> which gives me an ouput for example [["hello", "hello], ["help"], ["me"]]
08:49:37 <tegguN> but from here, how do I count the number of occurences of each word and append the appropriate number of *'s?
08:49:49 <tegguN> i know I'm supposed to use Length
08:51:21 <tegguN> sorry it should be something more like [["hello","hello"],["help"],["im"],["stuck"]] above
08:51:35 <tegguN> if there's any help anyone can give, i'd be very grateful
08:52:59 <tegguN> i want to take [["hello","hello"],["help"],["i'm"],["stuck"]] and produce something like this: ["hello **", "help *".. etc
08:56:06 <tegguN> anyone?
08:56:36 <Cale> mopped: It secretly has the same meaning, if the monad in question is the list monad :)
08:56:47 <Cale> mopped: But yeah, it picks an element from a list
08:56:55 <Cale> tegguN: looking...
08:57:07 <tegguN> thank you :)
08:57:27 <Cale> tegguN: map should do nicely :)
08:57:41 <tegguN> are you sure there's no other way?
08:57:42 <mopped> http://hpaste.org/11472 <-- So How do I convert by Int IO, i've already abstracted the IO part out
08:58:00 <Cale> tegguN: with an appropriate function to give you a pair consisting of the length of the list (number of occurrences), and the word in question
08:58:03 <tegguN> I think I'm approaching the task in the wrong way, because I'm sure we haven't covered map
08:58:23 <Cale> tegguN: well... you could write a recursive function directly then
08:58:30 <Cale> tegguN: It's just a bit awkward.
08:58:38 <tegguN> ahh i'm definately not allowed to use recursion
08:58:44 <Cale> tegguN: You're sure? map is one of the first things covered usually.
08:59:03 <Cale> map (*10) [1..10]
08:59:04 <tegguN> with map, something similar to this: map (\(k,x) -> if length x >=2 then x ++ [" **"] else x ++ [" *"]) . zip [0..] $ "hello hello etc."
08:59:06 <Cale> > map (*10) [1..10]
08:59:07 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
08:59:16 <tegguN> erm, I'm pretty sure we haven't
08:59:37 <Cale> > map reverse (words "a bunch of words")
08:59:38 <lambdabot>   ["a","hcnub","fo","sdrow"]
08:59:53 <tegguN> I'm supposed to use words, sort, group, length for the most part
09:00:27 <Cale> If you're not allowed to use map, there's no way you could be allowed to use foldr
09:00:46 <Cale> and if you can't use recursion either, then I'd be willing to bet that it's impossible
09:00:46 <tegguN> foldr?
09:01:00 <Cale> > foldr (+) 0 [1..10]
09:01:01 <lambdabot>   55
09:01:19 <tegguN> i can use zip?
09:01:22 <Cale> foldr f z  replaces each (:) in a list with f and the [] at the end with z
09:01:51 <tegguN> hmm
09:01:54 <Cale> tegguN: My advice is to ask a TA or the prof about the rules here.
09:02:02 <Cale> tegguN: Because that makes no sense.
09:02:12 <Cale> You must be either allowed to use recursion or map.
09:02:33 <Cale> Otherwise, there's no way you can even take the list apart.
09:02:58 <Cale> You can't do anything with its elements.
09:03:12 <tegguN> maybe there's a way without creating a list like [["hello","hello"],["help"],["im"],["stuck"]]
09:03:25 <tegguN> just operating on the string?
09:03:28 <Cale> There's a recursive way.
09:03:30 <mopped> isn't map one of the first things taught after explicit recursion?
09:04:09 <tegguN> we're on recursion at the moment, but this is to be done using work from the first 3 lectures only
09:04:25 <Cale> I would be surprised if that is true.
09:04:42 <plutonas> what is the function to remove a given element from a list?
09:05:05 <Cale> > delete 5 [1..10]
09:05:06 <lambdabot>   [1,2,3,4,6,7,8,9,10]
09:05:40 <Cale> > delete "word" (words "here is a word for you to delete")
09:05:41 <lambdabot>   ["here","is","a","for","you","to","delete"]
09:06:02 <Cale> > delete 'a' "abracadabra"
09:06:03 <lambdabot>   "bracadabra"
09:06:11 <Cale> > filter (/= 'a') "abracadabra"
09:06:12 <lambdabot>   "brcdbr"
09:06:30 <tuukkah> sounds like filter . (/=)
09:06:40 <Twey> @src delete
09:06:40 <lambdabot> delete = deleteBy (==)
09:06:47 <Twey> Tsk
09:06:53 <Twey> @src deleteBy
09:06:53 <Cale> @src deleteBy
09:06:54 <lambdabot> deleteBy eq x []        = []
09:06:54 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
09:06:54 <lambdabot> deleteBy eq x []        = []
09:06:54 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
09:06:58 <Twey> Close enough.
09:07:09 <Twey> Looks a bit like a reimplementation of filter, there...
09:07:22 <tuukkah> @src filter
09:07:22 <lambdabot> filter _ []     = []
09:07:22 <lambdabot> filter p (x:xs)
09:07:22 <lambdabot>     | p x       = x : filter p xs
09:07:22 <lambdabot>     | otherwise = filter p xs
09:07:38 <Deewiant> a bit, but deleteBy stops after deleting
09:08:03 <mopped> How can I turn an Int IO into an INT?
09:08:34 <Cale> mopped: An (IO Int) is like a program which if run, will produce an Int
09:08:54 <Cale> mopped: To run it, you use the syntax v <- myIOInt inside a do-block
09:08:55 <mopped> Yeah, i've abstracted the function and 'returned' the value
09:09:00 <mopped> hmm
09:09:12 <Cale> The do-block itself will evaluate to an IO action.
09:09:36 <Cale> (that is, another one of these programs)
09:09:38 <mopped> So how would I abstract generating a random number from 1 to n, and returning it as an integer?
09:09:45 <mopped> rn n = do r <- (getStdRandom (randomR (1, n))) return r
09:09:47 <mopped> is that I have
09:09:48 <plutonas> what do you think of my bubblesort:
09:09:52 <plutonas> bubblesort [] = []
09:09:52 <plutonas> bubblesort xs =
09:09:52 <plutonas>     (minimum xs):(bubblesort (delete (minimum xs) xs))
09:10:10 <plutonas> do you think i should perhaps also write an iterative version? how hard would this be?
09:10:19 <Cale> plutonas: isn't that more of a selection sort?
09:10:33 <Cale> plutonas: also it computes the minimum twice ;)
09:10:36 <plutonas> is it?
09:10:52 <plutonas> hm
09:10:55 <mopped> is what I have* even
09:11:09 <Cale> mopped: well, what should the type of rn be?
09:11:27 <mopped> Int
09:11:32 <mopped> (Or Integer..)
09:11:37 <Cale> Integer -> Integer?
09:11:42 <mopped> Yeah
09:11:43 <Cale> That's impossible.
09:11:46 <mopped> hm
09:12:13 <Cale> A function is abstractly just a pairing of inputs to outputs.
09:12:47 <jpcooper> @hoogle Maybe a -> b -> b -> b
09:12:48 <lambdabot> Language.Haskell.TH InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
09:12:48 <lambdabot> Language.Haskell.TH.Syntax InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
09:12:48 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
09:12:49 <Cale> That is, given the same input, they must give the same output.
09:13:12 <Cale> So in order for your random generator to generate anything like a random number, it must have some other input.
09:13:18 <jpcooper> is there a function that takes a maybe and according to whether or not it's a Just value, returns one of the other two inputs?
09:13:22 <jpcooper> apart from if + isJust
09:13:30 <opqdonut> jpcooper: maybe
09:13:32 <ddarius> maybe or fromJust
09:13:33 <opqdonut> :t maybe
09:13:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:13:36 <Cale> We usually let this be a StdGen, which is a pseudorandom number generator state.
09:13:39 <opqdonut> itä
09:13:40 <saftarn> isnt O(n log n) faster than O(n) ?
09:13:42 <ddarius> er fromMaybe
09:13:44 <ddarius> not fromJust
09:13:56 <opqdonut> grr, disregard that line
09:14:08 <ddarius> saftarn: Obviously not.
09:14:17 <Cale> mopped: You can make a new StdGen from inside IO, by running newStdGen
09:14:21 <jpcooper> opqdonut, I thought about that. I guess I'll have to use maybe + const
09:14:24 <Cale> mopped: g <- newStdGen
09:14:37 <opqdonut> jpcooper: you could just define your own combinator for that
09:14:37 <Cale> mopped: Then you pass g into the thing which needs to generate random numbers.
09:14:46 <mopped> into?
09:14:52 <saftarn> right hehe'
09:14:52 <jpcooper> okay
09:14:52 <Cale> mopped: As a parameter.
09:15:26 <Cale> mopped: When you call randomR, it'll give you a new g, to use for the next pseudorandom number.
09:15:37 <Cale> :t randomR
09:15:38 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
09:15:46 <Cale> :t randomR (1,6)
09:15:47 <lambdabot> forall t g. (RandomGen g, Random t, Num t) => g -> (t, g)
09:16:02 <Cale> > randomR (1,6) (mkStdGen 42)
09:16:03 <lambdabot>   (6,1720602 40692)
09:16:16 <mopped> aha
09:16:19 <Cale> > randomR (1,6) (mkStdGen 42)
09:16:20 <lambdabot>   (6,1720602 40692)
09:16:32 <Cale> Note that it gives the same result for the same input generator.
09:16:35 <saftarn> is naive fibonacci O(c^n) or O(n^n) ?
09:16:48 <ddarius> It is O(fib(n))
09:16:56 <saftarn> ?
09:16:59 <Cale> (which is O(c^n))
09:17:02 <ddarius> which is O(phi^n)
09:17:10 <saftarn> ok exponential
09:17:27 <saftarn> nit O(n^n) is also exponential right, so what do youc all it to separate the 2?
09:17:33 <ddarius> There are fibonacci steps in the naive fibonacci function.
09:17:43 <saftarn> ?
09:17:54 <Cale> > let (x,g') = randomR (1,6); (y,g'') = randomR (1,6) in (x+y)
09:17:55 <lambdabot>   Couldn't match expected type `(t, t1)'
09:17:55 <ddarius> n^n is b^(n log n)
09:18:06 <Cale> > let (x,g') = randomR (1,6) (mkStdGen 42); (y,g'') = randomR (1,6) g' in (x+y)
09:18:07 <lambdabot>   10
09:18:22 <Cale> If you just want lots of randoms, you can get an infinite list of them
09:18:22 <saftarn> O(fib(O(c^n))
09:18:30 <mopped> hmm ok
09:18:35 <mopped> And what does sequence do?
09:18:40 <Cale> > let xs = randomRs (mkStdGen 42) in xs
09:18:41 <lambdabot>   Couldn't match expected type `(a, a)'
09:18:47 <Cale> > let xs = randomRs (1,6) (mkStdGen 42) in xs
09:18:49 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
09:19:24 <Cale> mopped: sequence takes a list of actions and produces a single action which when run, runs all the actions and collects a list of results
09:19:42 <Cale> mopped: I think the source code for sequence is very enlightening:
09:19:47 <Cale> sequence [] = return []
09:20:02 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:21:00 <Cale> You can think of sequence as a kind of primordial loop: if we can decide beforehand what we want to do on each step of our loop, sequence will put the list of things together into a single action.
09:21:01 <saftarn> nit O(n^n) is also exponential right, so what do youc all it to separate the 2?
09:21:16 <jpcooper> @hoogle Map a b -> a -> Maybe (a, b)
09:21:17 <lambdabot> Data.Map elemAt :: Int -> Map k a -> (k, a)
09:21:29 <jpcooper> @hoogle Monad m => Map a b -> a -> m (a, b)
09:21:29 <lambdabot> Data.Map elemAt :: Int -> Map k a -> (k, a)
09:22:55 <mopped> How does that collect a list? I don't seen any concenation!
09:22:55 <Cale> saftarn: O(n^n) is factorial, or combinatorial time.
09:23:05 <Cale> saftarn: (not exponential)
09:23:13 <Cale> mopped: (v:vs)
09:23:23 <Cale> mopped: cons
09:23:40 <mopped> ahh
09:23:49 <mopped> I see
09:24:10 <Cale> do-notation glues smaller actions together into larger ones
09:24:30 <jpcooper> opqdonut, I may do that
09:24:33 <mopped> I'm still a bit confused of what makes something a Monad, and why they differ, and HOW they differ
09:24:43 <mopped> from what it looks like, they work more imperatively than functionally?
09:25:03 <Cale> mopped: Well, the do-notation gives them an imperative-seeming facade.
09:25:33 <Cale> But they can be wildly different from what's normal for imperative code.
09:25:47 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
09:25:48 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:26:19 <Cale> "running" a list in the list monad means picking one of its elements
09:26:26 <Cale> in all possible ways :)
09:26:50 <mmorrow> sequence is like taking a bunch of TODO lists and copying their contents onto a single todo list in order, and you end up with yet another TODO list
09:27:07 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
09:27:08 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
09:27:32 <mmorrow> heh, for various definitions of "TODO"
09:27:34 <mopped> So, if I'm unable to generate a non IO Integer, how would I select n random entities from a list?
09:28:12 <Cale> mopped: Well, there are two approaches.
09:28:16 <mmorrow> i would start with a list of indices i want to select, then run down the list grabbing those
09:28:29 <mmorrow> and that list that i start with would be randgen
09:28:55 <mmorrow> (but that's just one of many ways of course)
09:28:59 <Cale> mopped: One is to write a function which takes a StdGen, a list, and n, and produces another list.
09:29:16 <Cale> mopped: and another is to write a function which takes a list and n and produces an IO list
09:29:31 <Cale> (that is an action, which when run, will produce a random list of n elements)
09:29:58 <mopped> What makes an action different from a general function, it communicates with the 'outside?'
09:30:12 <Cale> an action isn't a function at all, since it takes no parameters
09:30:19 <nolraiWest> Is there a reason MonadLib doesn't define "asks", and "gets"?
09:30:25 <Cale> It simply describes something to be done
09:30:39 <mmorrow> of course an "action" could be implemented as a function (or not)
09:30:42 <Cale> (communicate with the user, and then maybe print something out, for example)
09:30:53 <Cale> mmorrow: Not as a Haskell function.
09:31:04 <Cale> well...
09:31:05 <mopped> right I understand
09:31:07 <jpcooper> say I'm importing Data.Map. How can I have its functions over-ride all other functions with the same name?
09:31:11 <mmorrow> oh, i'm not restricting "action" to IO
09:31:17 <Cale> mmorrow: Ah, okay
09:31:18 <mmorrow> i'm thinking in terms of any monad
09:31:33 <mmorrow> @unmtl Reader r a
09:31:34 <lambdabot> r -> a
09:31:37 <Cale> Yeah, okay, for some monads they're implemented as, or even *are* functions.
09:31:47 <mmorrow> yeah, *are* is a better word
09:32:11 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
09:32:12 <mmorrow> @unmtl State s a
09:32:12 <lambdabot> s -> (a, s)
09:32:13 <lambdabot>   ("Hello","olleH","HELLO")
09:32:22 <nolraiWest> jpcooper: I think you have to hide the other functions, either with hide or qualified.
09:32:23 <jeffz> jpcooper: you should import it qualified like the docs say.
09:32:25 <Cale> There's an example where the actions are functions :)
09:32:27 <mmorrow> GHC happens to implement IO as a state monad
09:32:32 <mmorrow> @src IO
09:32:32 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:32:34 <mmorrow> @src State
09:32:35 <lambdabot> Source not found.
09:32:37 <Cale> mmorrow: But it cheats!
09:32:40 <mmorrow> heh
09:32:55 <Cale> -> there is not the -> we know and love
09:33:17 <Cale> It's GHC's magic internal -> which is allowed to have all kinds of actual effects :)
09:33:21 <jpcooper> jeffz, yes, I've actually read the documents
09:33:33 <jpcooper> I would like not to have to write Data.Map in front of every function call
09:33:59 <mmorrow> the devilish and evil -> which microwaves baby flesh and eats grandmothers
09:34:00 <Cale> jpcooper: You could import the Prelude qualified...
09:34:02 <nolraiWest> jpcooper: use the "as" keyword then.
09:34:14 <Cale> jpcooper: Usually I do this:
09:34:19 <jpcooper> nolraiWest, I would like not to have to write anything in front
09:34:22 <mmorrow> hand prints stuff to the console ;)
09:34:22 <Cale> import qualified Data.Map as M
09:34:26 <mmorrow> s/hand/and/
09:34:27 <Cale> import Data.Map (Map)
09:34:40 <jpcooper> thanks
09:34:48 <Cale> That way you don't clutter up your type signatures
09:34:58 <Cale> and the functions are just  M.whatever
09:35:07 <Cale> 'as Map' also reads well
09:35:16 <Cale> Map.lookup
09:35:18 <Cale> etc.
09:35:23 <nolraiWest> jpcooper: then reimport the prelude with the overridenen functions hideing.
09:36:40 <mopped> What does !! do then, in the context of list!!x | x <- sequence ..
09:36:59 <PeakerWork> @type (!!)
09:37:00 <lambdabot> forall a. [a] -> Int -> a
09:37:19 <PeakerWork> it returns the n'th element of the list
09:37:24 <mmorrow> , sequence [[0,1],[2,3]]
09:37:28 <lunabot>  [[0,2],[0,3],[1,2],[1,3]]
09:37:59 <mmorrow> , sequence [[0,1],[2,3,4]]
09:38:01 <lunabot>  [[0,2],[0,3],[0,4],[1,2],[1,3],[1,4]]
09:38:08 <mmorrow> heh, polynomial multiplication
09:38:30 <mmorrow> um
09:38:40 <Cale> something like that ;)
09:40:24 <rwbarton> , (map sum . sequence) [[0,1],[2,3,4]]
09:40:26 <lunabot>  [2,3,4,3,4,5]
09:45:50 <mmorrow> right before my laptop dies, it lets out this distinctive beep that says "too late, now watch me helplessly turn off <goes into drawn out proper shutdown>"
09:46:29 <mmorrow> *now helplessly watch me ...
09:46:42 <plutonas> i'm trying to define bubblesort in haskell and have real trouble
09:46:44 <plutonas> any advise?
09:47:23 <mmorrow> hmm, that may be ugly
09:47:55 <plutonas> i'm writting a tutorial for a friends site. and the title is 7 popular sorting algorithms in lisp, haskell and python
09:48:11 <plutonas> i was expecting bubble sort to be really straightforward, but it doesn't seem to be the case
09:48:14 <Cale> plutonas: Write a recursive function which runs through a list swapping adjacent elements according to their order.
09:48:26 <Cale> and then use it until the list is sorted
09:48:33 <Cale> It's actually much harder than quicksort ;)
09:49:25 <jpcooper> isn't that what insertion sort is?
09:49:32 <jpcooper> or is it also called bubble sort?
09:49:36 <kosmikus> isn't bubble sort just a much more complicated algorithm?
09:50:00 <kosmikus> that also happens to be less efficient ;)
09:50:13 <ddarius> bubblesort isn't complicated
09:50:24 <plutonas> bubble sort goes through the list and if element x is larger than x+1 it swaps them
09:50:28 <jpcooper> oh right I remember the difference now
09:50:42 <plutonas> until the largest element ends up at the end, then again and again until all elements are sorted
09:50:53 <Cale> bubble' (x:y:xs) | x > y     = y : bubble' (x:xs)
09:50:53 <Cale>                  | otherwise = x : bubble' (y:xs)
09:51:08 <ddarius> With a base case, iterate that until fixpoint
09:51:10 <Cale> (plus trivial base cases)
09:51:44 <PeakerWork> is it theoretically possible to implement something like the ST monad (including STRefs) in pure Haskell code?
09:52:16 <Cale> PeakerWork: no.
09:52:35 <PeakerWork> because newSTRef is not possible?
09:52:41 <orgthingy> cale : what's "hello world!" in haskell ?
09:52:44 <Saizan> even using a Map you need unsafeCoerce
09:52:46 <Cale> PeakerWork: right.
09:52:55 <Cale> orgthingy: main = putStrLn "Hello, World!"
09:52:56 <ddarius> If you don't care about asymptotic complexities you kind of can but you can't type it the same.
09:53:25 <orgthingy> putStrLn ? why capital letters, Cale :S
09:53:38 <Cale> orgthingy: it's like put String Line
09:53:46 <plutonas> Cale: this is nice, but how do i decide if the list is sorted?
09:53:50 <PeakerWork> Cale: but something like:  Typeable a => newMyRef :: a -> MyState (MyRef a)  would be possible no? (Indexable by the type)
09:53:57 <Deewiant> plutonas: if zero swaps were performed
09:54:06 <plutonas> so i need to count the swaps somehow
09:54:21 <Cale> plutonas: bubble xs = if xs' == xs then xs' else bubble xs' where xs' = bubble' xs
09:54:36 <PeakerWork> oops, no, I still cannot have the various containers in a single type
09:54:42 <Cale> Or yeah, you could count the swaps as you go or something :)
09:55:10 <Cale> orgthingy:
09:55:13 <Cale> @where lyah
09:55:14 <lambdabot> www.learnyouahaskell.com
09:55:26 <Cale> ^^ I think you might like that tutorial :)
09:55:51 <Deewiant> the gentle introduction is out of vogue?
09:56:22 <Cale> LYAH is cute :)
09:56:31 <orgthingy> Cale :D
09:56:32 <Saizan> PeakerWork: yeah, you can use a Map Integer Dynamic then where the keys are unique ids associated with the refs
09:57:17 <Cale> Who could dislike it when it has art like this? :) http://learnyouahaskell.com/startingout.png
09:57:41 <Cale> http://learnyouahaskell.com/listmonster.png
09:57:53 <Cale> That's got to be my favourite illustration :)
09:58:02 <mmorrow> > let bubble [] = [] ; bubble [x] = [x] ; bubble (x:y:xs) | x < y = x : bubble (y:xs) | otherwise = y : bubble (x:xs) ; bsort xs = let xss = iterate bubble xs in snd . head . dropWhile (not . fst) $ zip (zipWith (==) xss (tail xss)) xss in bsort [6,3,5,2,2,4,6,4,5,3]
09:58:04 <lambdabot>   [2,2,3,3,4,4,5,5,6,6]
09:58:28 <mmorrow> that was kinda tricky
09:58:32 <mopped> This seems like a good tutorial Cale!
09:59:49 <mopped> Are there any functions I can use in conjunction with Int IO (on a different problem), can I use them all aslong as theyre inside a do block?
10:00:02 <ddarius> You only need a 1 bit counter if you count the swaps.
10:01:44 <mmorrow> > S.fromList [4,3]
10:01:45 <lambdabot>   /tmp/1275751021568576262:68:40: Not in scope: `S.fromList'
10:01:52 <mmorrow> > Set.fromList [4,3]
10:01:54 <lambdabot>   fromList [3,4]
10:01:54 <Cale> mopped: When you write v <- myIOInt  inside a do-block, then v :: Int
10:02:07 <Cale> mopped: and so you can then pass it to whatever might need an Int
10:02:17 <mmorrow> > let sort = Set.toList . Set.fromList in sort [5,76,3,2,4,56,4,2,2,3,43,2]
10:02:18 <lambdabot>   [2,3,4,5,43,56,76]
10:02:33 <mmorrow> er
10:02:51 <mmorrow> > M.fromList [(4,3)]
10:02:53 <lambdabot>   /tmp/8994225763454512769:68:40: Not in scope: `M.fromList'
10:02:55 <mmorrow> > Map.fromList [(4,3)]
10:02:56 <lambdabot>   fromList [(4,3)]
10:02:59 <Cale> mopped: If you're asking what you can do with just the action, well, you can use things like replicateM from Control.Monad
10:03:11 <mmorrow> > let sort = M.toList . foldl'
10:03:12 <lambdabot>   <no location info>: parse error on input `;'
10:03:25 <Cale> mopped: replicateM 16 x  will run the IO action x, 16 times over, and get a list of the results.
10:04:12 <Cale> mopped: If you add an _ to the end of the name, it'll drop the results on the floor, which is sometimes handy (this is a bit of a naming convention in Control.Monad and some other libraries)
10:04:36 <mmorrow> > let sort = concatMap (\(x,n)->replicate n x) . M.toList . foldl' (\m x Map.insertWith' (+) x 1 m) Map.empty $ [5,76,3,2,4,56,4,2,2,3,43,2]
10:04:37 <lambdabot>   <no location info>: Qualified variable in pattern: Map.insertWith'
10:04:38 <Cale> That is, like  replicateM_ 100 (putStrLn "Hello!!!")
10:04:42 <mmorrow> > let sort = concatMap (\(x,n)->replicate n x) . M.toList . foldl' (\m x Map.insertWith' (+) x 1 m) Map.empty in sort [5,76,3,2,4,56,4,2,2,3,43,2]
10:04:44 <lambdabot>   <no location info>: Qualified variable in pattern: Map.insertWith'
10:04:54 <mmorrow> > let sort = concatMap (\(x,n)->replicate n x) . M.toList . foldl' (\m x -> Map.insertWith' (+) x 1 m) Map.empty in sort [5,76,3,2,4,56,4,2,2,3,43,2]
10:04:55 <lambdabot>   /tmp/1638511471080906816:68:143: Not in scope: `M.toList'
10:05:07 <Cale> (since you're not interested in the *result* of putStrLn, just its effect.)
10:05:13 <mmorrow> > let sort = concatMap (\(x,n)->replicate n x) . Map.toList . foldl' (\m x -> Map.insertWith' (+) x 1 m) Map.empty in sort [5,76,3,2,4,56,4,2,2,3,43,2]
10:05:15 <lambdabot>   [2,2,2,2,3,3,4,4,5,43,56,76]
10:05:18 <mmorrow> woohoo
10:06:09 <mmorrow> is lambdabot using runplugs again?
10:06:13 <mmorrow> > fix id
10:06:14 <ddarius> A slow, but more general version of counting sort.
10:06:15 <lambdabot>   * Exception: stack overflow
10:06:19 <mmorrow> nope
10:06:36 <Deewiant> mmorrow: you shouldn't rely on toList = toAscList
10:06:40 <mmorrow> ddarius: heh
10:06:51 <mmorrow> Deewiant: ah, good point
10:07:06 <mopped> f [] = do return [], right? the do is needed even if its just return?
10:07:21 <Deewiant> if it's just one expression the 'do' is not needed
10:07:23 <mmorrow> > let sort = concatMap (\(x,n)->replicate n x) . Map.toAscList . foldl' (\m x -> Map.insertWith' (+) x 1 m) Map.empty in sort [5,76,3,2,4,56,4,2,2,3,43,2]
10:07:24 <lambdabot>   [2,2,2,2,3,3,4,4,5,43,56,76]
10:08:09 <ddarius> mopped: 'do' doesn't actually do anything.  It is just slight syntactic sugar over (>>=)
10:08:25 <mopped> ok
10:08:33 <mopped> @hoogle delete
10:08:33 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
10:08:33 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
10:08:33 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
10:09:27 <mmorrow> ahhhh, the /tmp/4783928343zmog3423 must be from the hackery involved in getting qualified imports
10:11:44 <mopped> Which of those deletes is the one Cale was using? :P
10:12:02 <Deewiant> @hoogle Data.List.delete
10:12:02 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
10:12:02 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:12:03 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:12:40 <mmorrow> mopped: one nice way to find the type of a subexpression is:
10:13:05 <mmorrow> > map (*2) (delete 4 [0..9])
10:13:07 <lambdabot>   [0,2,4,6,10,12,14,16,18]
10:13:08 <mmorrow> > map (*2) (?delete 4 [0..9])
10:13:09 <lambdabot>       Unbound implicit parameter (?delete::t -> [t1] -> [a])
10:13:09 <lambdabot>        arising f...
10:13:16 <ddarius> :t
10:13:21 <mmorrow> delete::t -> [t1] -> [a]
10:13:25 <Deewiant> :t \d -> map (*2) (d 4 [0..9])
10:13:26 <lambdabot> forall a t t1. (Enum t1, Num t1, Num t, Num a) => (t -> [t1] -> [a]) -> [a]
10:13:38 <mmorrow> wuh
10:13:44 <Deewiant> much easier :-P
10:13:47 <mmorrow> that type for ?delete is wack
10:14:03 <Deewiant> how's that
10:14:05 <mmorrow> > map (*2) (?delete 4 [0..9])
10:14:06 <lambdabot>       Unbound implicit parameter (?delete::t -> [t1] -> [a])
10:14:06 <lambdabot>        arising f...
10:14:12 <mmorrow> @type delete
10:14:13 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
10:14:19 <mmorrow> oh, n
10:14:22 <mmorrow> '/m
10:14:26 <Saizan> :t map (*2) (?delete 4 [0..9])
10:14:27 <lambdabot> forall a t t1. (Enum t1, Num t1, Num t, ?delete::t -> [t1] -> [a], Num a) => [a]
10:14:45 <mmorrow> yeah, i was presuming too much
10:15:01 <mmorrow> > map (*2) (?purplespaceship 4 [0..9])
10:15:02 <lambdabot>       Unbound implicit parameter (?purplespaceship::t -> [t1] -> [a])
10:15:02 <lambdabot>        ...
10:15:38 <mmorrow> > let ?purplespaceship = delete in map (*2) (?purplespaceship 4 [0..9])
10:15:40 <lambdabot>   [0,2,4,6,10,12,14,16,18]
10:15:56 <mopped> http://hpaste.org/11473 Any ideas on that error then? I changed the IO List to a List with the t <- l but that doesnt seem to help
10:18:51 <rwbarton> mopped: I didn't see your earlier paste--but the problem is now on the next line
10:19:14 <rwbarton> mopped: c <- t !! n means "Run the IO action t !! n, and bind c to the result"
10:19:35 <rwbarton> wait, no
10:19:44 <rwbarton> Well, that will be a problem too
10:19:47 <mmorrow> heh
10:20:05 <rwbarton> Anyways, <- is for "running" IO actions.
10:20:16 <mmorrow> you want
10:20:20 <mmorrow> let x = t !! n
10:20:36 <rwbarton> If you just want to bind a value to a name (though I don't know why you want to do so in this case 't <- l'), write let t = l
10:21:04 <mopped> I thought it was because t <- l, would allow me used to l as if it wasn't an IO List
10:21:12 <mmorrow> or correct but kinda odd would be:
10:21:17 <rwbarton> but l isn't an IO [a]
10:21:23 <mmorrow> c <- return (t !! n)
10:21:25 <rwbarton> it's a regular [a]
10:21:32 <rwbarton> I can tell by the previous line, permu [] = return []
10:21:33 <mmorrow> @type return 42 :: IO Int
10:21:34 <lambdabot> IO Int
10:21:38 <mmorrow> @type return 42 :: Maybe Int
10:21:39 <lambdabot> Maybe Int
10:21:42 <mmorrow> @type return 42 :: [Int]
10:21:43 <lambdabot> [Int]
10:21:59 <mmorrow> @type return 42 :: StateT () IO Int
10:22:01 <lambdabot> StateT () IO Int
10:22:56 <mmorrow> > (*2) `fmap` (return 42 :: IO Int)
10:22:57 <lambdabot>   * Exception: "<IO Int>"
10:23:05 <mmorrow> > (*2) `fmap` (return 42 :: Maybe Int)
10:23:06 <lambdabot>   Just 84
10:23:14 <mopped> removing t <- l, and changing it to c <- return (n !! l), gives me an error about IO Int
10:23:52 <mmorrow> @type (!!)
10:23:53 <lambdabot> forall a. [a] -> Int -> a
10:24:08 <mmorrow> l is not an Int
10:24:12 <davbo> Hey all, can I pattern match against the last element in a list in the signature of a function?
10:24:33 <mmorrow> mopped: ah, you meant  c <- return (l !! n)
10:24:47 <mopped> sorry, l !! n
10:24:48 <mopped> yeah :P
10:24:59 <mmorrow> that should work i believe
10:25:08 <ddarius> davbo: You can't pattern match against anything in the signature of the function.  But, no, you can't do that in the clauses.  You could use a guard or pattern guards or view patterns to get something similar.
10:25:08 <mmorrow> davbo: kinda
10:25:10 <Saizan> mopped: if n :: IO Int, then you've to do n' <- n; let c = l !! n; ...
10:25:11 <rwbarton> well, there's still a problem on the last line... is that where the error is now?
10:25:46 <mopped>    Couldn't match expected type `[t] -> m t1'
10:25:46 <mopped>            against inferred type `IO Int'
10:25:46 <mopped>     In a 'do' expression:
10:25:46 <mmorrow> > let f xs | x <- last xs = x in f [0..9]
10:25:46 <mopped>         n <- getStdRandom (randomR (1, ((length l) - 1))) l
10:25:47 <lambdabot>   9
10:25:56 <mopped> I'm still not that brilliant at understanding the error messages :P
10:26:02 <mmorrow> @getStdRandom
10:26:02 <lambdabot> Unknown command, try @list
10:26:06 <rwbarton> why is there an l at the end of that line?
10:26:06 <mmorrow> @type getStdRandom
10:26:08 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
10:26:15 <mopped> it returns an IO Int
10:26:21 <mmorrow> hmm, i didn't even know that function existed
10:26:31 <davbo> (sorry ddarius, just realised that's not a "function signature" is it...i'm pretty new to Haskell)
10:26:43 <Deewiant> > let f (last -> xs) = x in f [0..9]
10:26:44 <lambdabot>   <no location info>: parse error on input `->'
10:26:49 <Deewiant> :-/
10:26:57 <rwbarton> , let f (last -> xs) = x in f [0..9]
10:26:58 <mopped> hmm wait, why is there an l at the end of that line
10:26:58 <lunabot>  luna: Not in scope: `x'
10:27:00 <rwbarton> , let f (last -> xs) = xs in f [0..9]
10:27:02 <lunabot>  9
10:27:11 <Deewiant> is luna on 6.8.3 or 6.10?
10:27:15 <mmorrow> 6.10
10:27:17 <ddarius> 6.10
10:27:19 <Deewiant> nice
10:27:25 <mmorrow> yeehoo
10:28:13 <mopped> Ok, without the type it's complaing about IO [a] instead of [a] in the last line
10:28:16 <mopped> typo*
10:28:28 <rwbarton> right
10:28:54 <rwbarton> that's because the call to permu returns an action
10:29:26 <davbo> thanks mmorrow
10:29:31 <mmorrow> :)
10:30:47 <mmorrow> rwbarton: whoa, i just realized what you can do with view-patterns
10:31:05 <mmorrow> err, wait n/m
10:31:47 <mmorrow> pattern guards are strictly more general than view patterns, right?
10:31:54 <mopped> even if I have t <- l, (to change IO [a] to [a]), it complains
10:33:05 <mmorrow> > let f xs | x <- last xs , Just y <- x , [0,0,z,4] <- y = (z,y,x) in f [undefined,undefined, Just [0,0,42,4]]
10:33:07 <lambdabot>   (42,[0,0,42,4],Just [0,0,42,4])
10:33:22 <Saizan> mopped: the problem is that perm returns an IO [a], so you can't directly cons an element to it
10:33:23 <rwbarton> mmorrow: I think the point of view patterns is that you can nest them more directly
10:33:31 <mmorrow> hmm
10:33:50 <rwbarton> > let f (last -> (Just [0, 0, z, 4])) = z in f [undefined,undefined, Just [0,0,42,4]]
10:33:51 <lambdabot>   <no location info>: parse error on input `->'
10:33:58 <rwbarton> , let f (last -> (Just [0, 0, z, 4])) = z in f [undefined,undefined, Just [0,0,42,4]]
10:34:01 <lunabot>  42
10:34:09 <rwbarton> that's not a very interesting example
10:34:13 <mmorrow> hah
10:34:30 <mmorrow> oh, ok. how about this
10:35:00 <mopped> hmm right
10:35:07 <mmorrow> > let f xs | x <- last xs , Just y:_ <- reverse x , [0,0,z,4] <- y = (z,y,x) in f [undefined,undefined, [Nothing, Just [0,0,42,4]]]
10:35:08 <lambdabot>   (42,[0,0,42,4],[Nothing,Just [0,0,42,4]])
10:35:28 <mmorrow> is that doable with view patterns?
10:35:35 <mopped> So how do I indirectly cons onto it?
10:35:46 <mmorrow> reducing to a smaller example...
10:36:11 <Saizan> mopped: you can extract the list with <-
10:36:11 <rwbarton> , let f (last -> x@(reverse -> Just y@[0,0,z,4])) = (z,y,x) in f [undefined,undefined, [Nothing, Just [0,0,42,4]]]
10:36:13 <lunabot>  luna: Couldn't match expected type `[a]'
10:36:26 <rwbarton> , let f (last -> x@(reverse -> Just (y@[0,0,z,4]))) = (z,y,x) in f [undefined,undefined, [Nothing, Just [0,0,42,4]]]
10:36:28 <lunabot>  luna: Couldn't match expected type `[a]'
10:36:30 <mmorrow> ahhhh, nice
10:36:50 <mmorrow> i didn't appreciate what you really meant by /nest/ them
10:36:54 <Saizan> mopped: just like you extract n from getStdRandom etc..
10:38:09 <rwbarton> , let f (last -> x@(reverse -> Just y@[0,0,z,4] : _)) = (z,y,x) in f [undefined,undefined, [Nothing, Just [0,0,42,4]]]
10:38:11 <lunabot>  (42,[0,0,42,4],[Nothing,Just [0,0,42,4]])
10:39:13 <mopped> Thanks, I understand
10:39:50 <rwbarton> mmorrow: the wiki page says "Nesting is perhaps the biggest practical difference between view patterns and pattern guards"
10:40:03 * mmorrow needs to read the wiki
10:42:36 <davbo> umm, could I use a "put in" statement before a guard, it looks like I can't...I guess I'm being an idiot for trying to do this
10:42:53 <davbo> "let in" sorry
10:43:07 <mmorrow> zomg, i didn't know they had the ghc haddock up
10:43:09 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/ghc/index.html
10:43:10 <lambdabot> Title: ghc-6.11.20081024: The GHC API, http://tinyurl.com/5n62mj
10:43:26 <thoughtpolice> mmorrow: yeah there's a lot of initial documentation there for the time being
10:43:46 * davbo sighs, facepalm
10:44:00 <mmorrow> thoughtpolice: nice
10:45:20 <mmorrow> davbo: i bet you can
10:45:32 <rwbarton> davbo: you can use a where clause after a guard
10:46:17 <mmorrow> > let f xs | x <- let ys = tail xs in head ys  = x in f [0..9]
10:46:19 <lambdabot>   1
10:46:41 <mmorrow> > let f xs | x <- (let ys = tail xs in head ys) = x in f [0..9]
10:46:42 <lambdabot>   1
10:49:05 * davbo wasn't aware of "where", thanks
10:51:49 <insane> is it possible wxhaskell not clear my panel when calling repaint?
10:52:26 <insane> or event better redraw only the rect which i want?
11:11:06 <vixey> â™ª [$i| (,) "foo" "bar" |]
11:11:08 <lunabot>  luna: Not in scope: `i'
11:12:43 <sleven> is it possible to clone darcs repos with git?
11:13:09 <kowey> insane: you may be best off asking on wxhaskell-user
11:13:31 <kowey> insane: or look out for shelarcy if he's around
11:13:55 <kowey> insane: https://lists.sourceforge.net/lists/listinfo/wxhaskell-users
11:14:34 <user317> is there any documentaiotn on the ~/cabal/config file format?  how do i stick "--enable-library-profiling" option in there
11:15:02 <dcoutts> user317: the new format is mostly self-documenting, but you've probably got a config file generated by an older version
11:15:32 <dcoutts> user317: easy solution is to backup the old then delete the config file and let it be re-created
11:15:37 <dcoutts> then merge in your changes
11:16:20 <user317> thanks
11:16:45 <sleven> how do i cd from / ? liek if im in /desktop/ do i have to cd .. back or can i say cd from /
11:20:48 <sleven> hpw do i sudo inside emacs? i dont have access to overwrite a file in /usr/local/bin/
11:21:00 <sleven> wrong channel
11:23:08 <mopped> What's currying? I originally thought it's a function that returns a function, is it something more?
11:24:32 <ddarius> currying is what curry does
11:24:55 <mopped> lastbutone = last . init
11:24:58 <mopped> is that currying?
11:25:01 <mopped> as it returns a function..
11:25:02 <ddarius> No.
11:26:39 <mopped> I thought partial function application is currying, what is it exactly then?
11:27:17 <ddarius> Partial application is a bit fuzzy.  Currying is what the curry function does.
11:27:24 <mopped> @type curry
11:27:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:28:12 <mopped> So it takes a function with two paremeters, two values and does what?
11:28:42 <guinea> how do i compile a haskell function into a library that I can call from R? I tried using the cookbook recipe for making a function callable from C but it requires compiling the C with ghc. When I used R CMB SHLIB on the object file, and tried to load it into R, I get "hs_init" not found
11:28:42 <ddarius> It's better to view it as ((a,b) -> c) -> (a -> b -> c)
11:28:59 <birkenfeld> mopped: it converts a function with a tuple parameter into one with two parameters
11:29:46 <mopped> > curry fst
11:29:47 <lambdabot>       Overlapping instances for Show (a -> b -> a)
11:29:47 <lambdabot>        arising from a use ...
11:29:53 <mopped> > curry fst 1 2
11:29:55 <lambdabot>   1
11:30:03 <mopped> Is there any major uses of this?
11:30:08 <ddarius> curry turns a function that accepts a tuple into a function that accepts the first argument and returns a function that accepts the second argument.
11:30:26 <ddarius> It's theoretically important, but it tends not to be used much.
11:31:02 <ddarius> The Haskell libraries tend to have few functions that accept tuples so there isn't much that you would pass to curry.
11:31:35 <idnar> functions in Haskell are already curried
11:31:53 <rwbarton> They don't have to be, but by convention they are.
11:32:07 <rwbarton> It makes partial application easier in many cases.
11:32:12 <mopped> When I read TLS, I think it defined currying as returing a function, so you'd have a function like mk-rmember, or something - and it returns a function 'hardcoded' with a parameter, does this have a formal name?
11:32:39 <ddarius> That's partial application possibly, or just a function returning a function.
11:32:55 <ddarius> Most people would say partial application in either case, but there is a subtle distinction.
11:33:32 <mopped> Is it common to call it currying then - because i've also read it in real world haskell, perhaps they correct themselves once the reader learns more :P
11:33:34 <Beelsebob> there is?
11:33:49 <Beelsebob> what's the distinction ddarius?
11:34:29 <ddarius> Beelsebob: Here's a function that returns a function but arguably isn't partial application: f n = funArray ! n where funArray = some array of functions.
11:34:47 <ddarius> The distinction is very subtle in Haskell, it's less subtle in languages with side-effects.
11:35:12 <Beelsebob> I'd say that's a partial application
11:35:50 <ddarius> Beelsebob: What about: (define (f n) (begin (write '(foo)) id)) ?
11:36:13 <Beelsebob> uh, I have no idea why write does in scheme, so buh
11:36:26 <ddarius> Beelsebob: If you start calling such things partial applications, then partial application == application.
11:36:33 <Beelsebob> yeh
11:36:35 <Beelsebob> exactly
11:36:40 <Beelsebob> that's rather the point ;)
11:36:44 <ddarius> Then why even have the term partial application.
11:36:48 <ddarius> It's meaningless.
11:37:05 <Beelsebob> because it helps explain things to people who don't yet see the one-argument-functions thing
11:37:07 <rwbarton> Currying describes the relationship between two different functions, (+) :: Int -> Int -> Int and (\(x,y) -> x+y) :: (Int, Int) -> Int
11:37:27 <rwbarton> when people describe (+) as "curried", it means they have the other function in mind to compare (+) to.
11:37:51 <ddarius> Beelsebob: I agree it is often useful to use in a subjective way, but it does have more formal meanings.
11:38:11 <Beelsebob> ddarius: I'm not sure it does in Haskell
11:38:37 <Beelsebob> anyway, gtg
11:38:50 <ddarius> I wasn't talking about Haskell per se, the Report doesn't define "partial application"
11:39:29 <ddarius> However, one more formal definition is: f x is a partial application iff f x = (curry (uncurry f)) x
11:39:49 <mopped> I take it uncurry converts a function with two parameters into one that takes a tuple?
11:40:26 <ddarius> The idea behind that definition is that a partial application should do no work.
11:42:21 <ddarius> uncurry is the inverse of curry.
11:42:23 <PeakerWork> doh, I missed Beelsebob
11:43:00 <ddarius> (almost)
11:44:11 <PeakerWork> conal: are you here?
11:46:42 <PeakerWork> http://www.haskell.org/haskellwiki/Phooey -- I'm wondering why the Applicative Functor "ui1" is UI (IO ()) -- and whether the example code:    total = title "total" showDisplay      type checks
11:46:43 <lambdabot> Title: Phooey - HaskellWiki
11:51:39 <DavidS333> Anyone know of a library in which I can get a list of filenames from a directory sorted by modification time?
11:52:02 <monochrom> I just read the opening story in HWN. I was enlightened! :)
11:59:33 <jeffz> DavidS333: use you can use System.Directory's getDirectoryContents and getModificationTime
11:59:50 <DavidS333> Ok thanks
12:00:15 <jeffz> DavidS333: http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html
12:00:17 <lambdabot> Title: System.Directory, http://tinyurl.com/2vu2vv
12:00:53 <Gabby> Anyone here have experience with setting up lambdabot on another ircserver?
12:04:45 <vixey> â™ª [$i| (,) "foo" "bar" |]
12:04:47 <lunabot>  luna: Not in scope: `i'
12:07:05 <Gabby> It wont join channels /o\
12:14:16 <user317> does anyone know where i can find an example of making lists of instances, like list of different things that all implement Show
12:14:25 <Gabby> Joins the server fine and responds ok in queries.
12:15:11 <vixey> @instance Show
12:15:11 <lambdabot> Maybe you meant: instances instances-importing
12:15:14 <vixey> @instances Show
12:15:15 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
12:15:32 <vixey> user317: well you can look at lambdabot source code.... not sure how it is actually done though
12:15:52 <rwbarton> user317: you can also type :i Show in ghci
12:16:09 <user317> ah, i remember, its called existentially qualified types
12:16:12 <rwbarton> oh, that
12:16:26 <rwbarton> data Showable a = forall a. Show a => Showable a
12:16:45 <rwbarton> s/data Showable a/data Showable/
12:16:48 <user317> if they came up with simpler names, it would be a lot easier to use this stuff :), engineers hate reading math papers
12:20:45 <PeakerWork> I also think Haskell could use a facelift, it has lots of obscure names, imo.  Over-verbose is probably a little better over-all than obscure, especially for the learning curve (which is considered by many to be Haskell's greatest disadvantage)
12:21:27 <zachk> PEAKER
12:21:36 <zachk> i like the verbose words
12:21:55 <PeakerWork> > init "1234"
12:21:56 <lambdabot>   "123"
12:22:09 <PeakerWork> why not: exceptLast or so?
12:22:18 <PeakerWork> withoutLast
12:22:21 <mmorrow> â™ª [$i| (,) "foo" "bar" |]
12:22:25 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
12:22:28 <mmorrow> heh
12:22:32 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=304#a304
12:22:35 <vixey> !!!!!!!!
12:22:41 <vixey> great!!
12:22:50 <mmorrow> :)
12:23:03 <vixey> â™ª [$i| (+) (Just 3) (Just 7) |]
12:23:07 <lunabot>  Just 10
12:23:09 <vixey> this is actually brilliant
12:23:28 <mmorrow> the possibilities are just waiting to be thought of
12:23:51 <rwbarton> , [$i| Just 3 + Just 7 |]
12:23:51 <insane> is it possible to put the let in a do statement to assign some values so that they can be used in 'in' later ?
12:23:54 <vixey> I really like this everywhere thing
12:23:55 <lunabot>  luna: applicateQ fails.
12:24:13 <mmorrow> , (quoteExp i) "(,) \"foo\" \"bar\"
12:24:15 <lunabot>  luna: lexical error in string/character literal at end of input
12:24:15 <mmorrow> , (quoteExp i) "(,) \"foo\" \"bar\""
12:24:19 <lunabot>  InfixE (Just (InfixE (Just (ConE (,))) (VarE <$>) (Just (LitE (StringL "f...
12:24:25 <vixey> rwbarton, I had got stuck on something .. I thought you would know about it.. :)
12:24:31 <mmorrow> , ppDoc `fmap` (quoteExp i) "(,) \"foo\" \"bar\""
12:24:35 <lunabot>  ((,) <$> "foo") <*> "bar"
12:24:38 <vixey> do you think that: format :: String -> [Either Integer String] -> String
12:24:48 <vixey> can be written, that uses printf :: PrintfType r => r -> String internally ?
12:24:53 <mmorrow> , src ''QuasiQuoter
12:24:58 <lunabot>  luna: Overlapping instances for Language.Haskell.TH.Syntax.Lift
12:25:01 <mmorrow> grrgr
12:25:12 <vixey> it seemed like one of the forall. things you pasted before.. but I couldn't remember it
12:25:17 <rwbarton> ah... hmm
12:25:21 <insane> is it possible to put the let in a do statement to assign some values so that they can be used in 'in' later ?
12:25:23 <vixey> (someone was asking about this earlier)
12:25:43 <rwbarton> I suspect so, let me give it a shot
12:25:52 <PeakerWork> insane: "let" inside a "do" does not require an "in"
12:26:21 <insane> PeakerWork: so i can't assign few things in one let?
12:26:39 <insane> PeakerWork: do I have to do let in every line which i want to use <-/
12:26:41 <insane> ?
12:26:43 <PeakerWork> @undo do { x <- blah ; let { y = x ; z = y } ; o <- bleh z }
12:26:44 <lambdabot>  Parse error at "}" (column 54)
12:26:51 <PeakerWork> @undo do { x <- blah ; let y = x ; o <- bleh z }
12:26:52 <lambdabot>  Parse error at "<-" (column 32)
12:27:04 <ddarius> You can't end a do with a x <- m
12:27:09 <PeakerWork> oh
12:27:14 <PeakerWork> @undo do { x <- blah ; let { y = x ; z = y } ; o <- bleh z ; return o }
12:27:15 <lambdabot> blah >>= \ x -> let { y = x; z = y} in bleh z >>= \ o -> return o
12:27:47 <PeakerWork> insane: you can use the let'd stuff in all the do lines after the let, without an "in"
12:27:51 <ddarius> @. pl undo do x <- blah; let { y = x; z = y}; o <- bleh z; return o
12:27:51 <lambdabot> (line 1, column 21):
12:27:52 <lambdabot> unexpected "{"
12:27:52 <lambdabot> expecting "()", natural, identifier or "in"
12:27:52 <mmorrow> , src ''QuasiQuoter
12:27:57 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
12:27:57 <lunabot>                                  quotePat :: (String -> Q Pat)}
12:28:02 <mmorrow> , ppDoc `fmap` (quoteExp i) "(,) \"foo\" \"bar\""
12:28:07 <lunabot>  ((,) <$> "foo") <*> "bar"
12:28:12 <mmorrow> , [$i| (,) "foo" "bar" |]
12:28:16 <lunabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('...
12:28:22 <vixey> â™ª [$i| (++) (return "hask") (return "kell") |]
12:28:27 <lunabot>  luna: No instance for (GHC.Show.Show (f [GHC.Types.Char]))
12:28:30 <vixey> â™ª [$i| (++) (return "hask") (return "kell") |] :: Maybe String
12:28:35 <lunabot>  Just "haskkell"
12:28:39 <mmorrow> hah
12:28:55 <PeakerWork> what's the $i there for?
12:28:57 <DavidS333> http://hpaste.org/11481
12:29:01 <vixey> ?where idioms
12:29:01 <lambdabot> I know nothing about idioms.
12:29:02 <mmorrow> it's a quasiquoter
12:29:11 <vixey> lambdabot: yes you do
12:29:12 <mmorrow> PeakerWork: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=304#a304
12:29:24 <ddarius> @where idiom
12:29:25 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
12:29:27 <PeakerWork> mmorrow: oh, it refers to "i" there?
12:29:35 <mmorrow> exactly
12:29:57 <mmorrow> PeakerWork: it maps
12:29:58 <mmorrow> (,) "foo" "bar"
12:29:59 <mmorrow> to
12:30:04 <mmorrow> ((,) <$> "foo") <*> "bar"
12:30:14 <PeakerWork> yeah, short form for liftA2 ?
12:30:29 <mmorrow> in general ...     f x y z ===> f <$> x <*> y <*> z <*>
12:30:31 <Saizan> it scales to any N
12:30:37 <mmorrow> yeah, any N
12:30:45 <PeakerWork> yeah
12:30:54 <vixey> @instances Applicative
12:30:55 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:31:08 <vixey> @instances-importing Control.Applicative Applicative
12:31:09 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
12:31:16 * PeakerWork likes Applicative
12:31:25 <vixey> â™ª [$i| (*) (4,8) (6,8) |]
12:31:29 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
12:31:33 <vixey> :/
12:31:53 <rwbarton> Num t, Monoid t, I think?
12:31:58 <vixey> â™ª (\f g -> [$i| (&&) f g |]) (== True) (== False) True
12:32:04 <lunabot>  False
12:32:04 <mmorrow> â™ª [$i| (*) (4,8::Int) (6,8) |]
12:32:07 <vixey> :O
12:32:09 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
12:32:11 <vixey> that actually worked!
12:32:33 <PeakerWork> @pl ap f x y = f <$> x <*> y
12:32:34 <lambdabot> ap = (. (<*>)) . (.) . (<$>)
12:32:38 <mmorrow> â™ª let x = [$i| (*) (4,8) (6,8) |] in ?f x
12:32:42 <lunabot>  luna: Unbound implicit parameter (?f::(t, a) -> a1)
12:32:46 <ddarius> vixey: Why wouldn't it?
12:32:54 <vixey> ddarius: usually stuff doesn't work
12:32:59 <PeakerWork> liftA2 is still useful for points-free :-)
12:32:59 <vixey> â™ª map ((\f g -> [$i| (||) f g |]) (== 'X') (== 'Y')) "foXbar"
12:33:00 <rwbarton> . [$i| (*) ("foo", 8) ("bar", 12) |]
12:33:03 <rwbarton> , [$i| (*) ("foo", 8) ("bar", 12) |]
12:33:04 <lunabot>  [False,False,True,False,False,False]
12:33:08 <lunabot>  ("foobar",96)
12:33:22 <PeakerWork> For example: any better way to implement <**> than: liftA2 (flip ($))  ?
12:33:47 <mmorrow> @type liftA2 (flip ($))
12:33:48 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f (a -> b) -> f b
12:34:04 <PeakerWork> is there a name for (flip id)?
12:34:08 <mmorrow> @src Applicative
12:34:08 <lambdabot> class Functor f => Applicative f where
12:34:08 <lambdabot>     pure  :: a -> f a
12:34:08 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:34:09 <ddarius> :t flip ap
12:34:10 <vixey> :t flip id
12:34:10 <PeakerWork> is there a hoogle for source code?
12:34:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
12:34:11 <lambdabot> forall b c. b -> (b -> c) -> c
12:34:19 <ddarius> :t flip (<*>)
12:34:20 <vixey> @hoogle b -> (b -> c) -> c
12:34:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:34:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:34:21 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:34:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:34:34 <PeakerWork> flip <*> is not the same as <**> though
12:34:35 <ddarius> Not quite the same.
12:34:43 <mmorrow> is (<**>) not ..
12:34:47 <mmorrow> i was just about to ask that
12:34:55 <mmorrow> what's the diff
12:34:56 <mmorrow> ?
12:35:01 <PeakerWork> mmorrow: Applicative carries effects as well as the value inside
12:35:07 <ddarius> The execute the effects in different orders.
12:35:16 <mmorrow> could you give an example showing how they differ?
12:35:17 <PeakerWork> mmorrow: <*> and <**> carry out the effects of the left side first
12:35:31 <ddarius> One corresponds to do f <- mf; x <- mx; return (f x) the other to do x <- mx; f <- mf; return (f x)
12:35:40 <mmorrow> ah, i see
12:36:21 <ddarius> > length "liftA2 (flip ($))"
12:36:22 <lambdabot>   17
12:36:23 <rwbarton> vixey: http://hpaste.org/11482
12:36:35 <PeakerWork> I used:   (+) <$> (print 1 >> readLn) <*> (print 2 >> readLn)   vs.   (print 1 >> readLn) <**> ((+) <$> (print 2 >> readLn)) :)
12:36:51 <insane> so what should i do if my function return type is IO () but i want to make something like tmp = 20*20 and use tmp later in that function
12:37:08 <PeakerWork> insane: let tmp = 20*20
12:37:28 <vixey> rwbarton: *sigh* It took me about an hour to figure out I _couldn't_ do it.. :)
12:37:56 <rwbarton> vixey: It helps if you know the trick that printf uses, you essentially have to do that trick backwards
12:38:00 <vixey> rwbarton: that's actually so much simpler than I expected.. thanks very interesting to see ti
12:38:01 <rwbarton> vixey: (the reverse)
12:38:28 <insane> PeakerWork: and is there any nicer syntax if i want to assign 20 times using let?
12:38:51 <PeakerWork> insane: where's your code?
12:38:59 <insane> PeakerWork: so that i don't have to type let = ... 20 times?
12:39:02 <rwbarton> insane: you don't have to repeat the let
12:39:04 <rwbarton> let x = 3
12:39:05 <mmorrow> @type liftA2 (flip id)
12:39:06 <lambdabot> forall a c (f :: * -> *). (Applicative f) => f a -> f (a -> c) -> f c
12:39:07 <rwbarton>    y = 4
12:39:16 <mmorrow> @src liftA2
12:39:16 <lambdabot> liftA2 f a b = f <$> a <*> b
12:39:18 <rwbarton> erm, too slow and didn't line it up right...
12:39:56 <mmorrow> , [$i| (flip id) "foo" "bar" "baz"|]
12:40:00 <lunabot>  luna: Couldn't match expected type `(a -> a1 -> a2 -> b) -> a1'
12:40:00 <ddarius> rwbarton: That's actually an interesting application of polymorphic recursion
12:40:05 <mmorrow> , [$i| (flip id) "foo" "bar"|]
12:40:09 <lunabot>  luna: Couldn't match expected type `(a -> a1 -> c) -> a1'
12:40:13 <mmorrow> err, yeah
12:40:36 <PeakerWork> Is there a search tool that shows me how parts of my code already exist in their exact form in the library? (e.g (flip id) already having a name.. even (flip ($)) could find (flip id) as a name if the type wouldn't change)
12:41:13 <Saizan> PeakerWork: no, there isn't
12:41:22 <ddarius> You could grep the source
12:41:25 <PeakerWork> damn that thing would be kind of cool ;)
12:41:39 <PeakerWork> ddarius: well, I want it to ignore things like local names, and compare the structure
12:41:47 <insane> and what about if i'd like to use varUpdate in a normal function (without do block)
12:41:57 <insane> is there any way to achieve that?
12:42:12 <PeakerWork> ddarius: and do things like consider id and ($) identical for its comparison, unless the type would change (even then it could tell you about it)
12:42:34 <PeakerWork> insane: have you read a Haskell tutorial, that explains about IO and monads?
12:42:35 <sjanssen> PeakerWork: @pl can find some of these things
12:42:45 <sjanssen> @pl flip id
12:42:46 <lambdabot> flip id
12:42:53 <sjanssen> but not all of them
12:43:13 <PeakerWork> sjanssen: yeah. In an imperative language, such a tool is impossible/useless. In Haskell its at the very *least* a fun toy ;-)
12:43:36 <PeakerWork> If you let it run on the stdlib itself you might even compress it a little bit ;-)
12:43:40 <insane> PeakerWork: I have looked through it in hope I would learn the rest while coding
12:44:20 <insane> PeakerWork: So you suggest me to read the section about monads in haskell tutorial on wikibooks?
12:44:48 <PeakerWork> insane: Well, in Haskell, functions are pure, they cannot have effects.  To implement effects anyhow, Haskell asks the "main" function to please generate a description of what effects to perform. That description is a value of the (IO a) type
12:44:56 <mmorrow> Peaker: if i were thinking of writing such a thing, i'd look at the @pl src to start
12:45:12 <mmorrow> (i haven't gone through it extensively, but it looks /very/ interesting)
12:45:20 <rwbarton> PeakerWork: hmm, you could use haddock to extract type signatures, hoogle to find library functions with the same signatures, and quickcheck to see whether any of those library functions is the same :)
12:45:32 <PeakerWork> mmorrow: Yeah. I have little time to devote to Haskell a.t.m so I devote most of it to reading and a bit to try toying with modern FRP libs
12:45:38 <ddarius> mmorrow: pl is essentially just an optimizing compiler most likely via rewrite rules.
12:46:00 <mmorrow> ddarius: yeah, it seems like it's mostly rewrites
12:46:07 <PeakerWork> rwbarton: Quickcheck in that context sounds dangerous ;)
12:46:20 <PeakerWork> rwbarton: I think even exact structural identity between function sources is already interesting
12:46:48 <PeakerWork> rwbarton: maybe trying to @pl both pieces of code and compare that too
12:46:57 <ddarius> PeakerWork: There are plenty of Haskell parsers about.  Writing an equivalence up to alpha-conversion is relatively simple.
12:47:08 <PeakerWork> ddarius: what's alpha conversion?
12:47:19 <ddarius> Renaming bound variables.
12:47:28 <mmorrow> if all you're working with is non-messing-with-stuff (better-term?) functions like id, const, flip, ... then type equality should be ok i think
12:47:33 <PeakerWork> insane: I am not sure which tutorial explains the IO monad well, but I suggest reading that yeah. Also, if you want, I can try to explain
12:48:26 <PeakerWork> mmorrow: Generic functions without class contexts?
12:48:48 <ddarius> There are an infinite number of functions of type [a] -> [a]
12:48:49 <Saizan> parametricity/naturality
12:49:20 <PeakerWork> well, lists are specific, in a sense.   If you take generic to mean using only type variables?
12:49:30 <mmorrow> ddarius: are you collapsing function iso to id into id?
12:49:31 <PeakerWork> (and functions, of course)
12:49:38 <rwbarton> There are also an infinite number of functions of type (a -> a) -> (a -> a)
12:49:39 <mmorrow> s/function/functionS/
12:50:28 <PeakerWork> type equality + dependent types would be ok ;-)
12:50:32 <vixey> why infinite?
12:50:33 <ddarius> mmorrow: Define isomorphic.
12:50:35 <vixey> rae they actually different
12:50:46 <PeakerWork> vixey: you can re-apply (a->a) any number of times to get (a->a)
12:50:52 <ddarius> vixey: For rwbarton's example, there is one for each natural number n.
12:51:00 <vixey> oh right, I should have noticed that..
12:51:19 <mmorrow> ddarius: f `iso` id := forall x. f x == id x
12:51:20 <vixey> ($)^n
12:51:29 <mmorrow> ddarius: or something like that i guess
12:51:34 <PeakerWork> This might be an interesting consequence of dependent types --> the ability to identify identical code
12:51:53 <ddarius> mmorrow: That's equality and no, only one function in that type equals id (obviously, id)
12:52:08 <PeakerWork> ddarius: bottom :(
12:52:18 <mmorrow> ddarius: what about  uncurry (:) . (head &&& tail)  ?
12:52:27 <vixey> :t uncurry (:) . (head &&& tail)
12:52:28 <lambdabot> forall a. [a] -> [a]
12:52:29 <mmorrow> or foldr (:) []
12:52:55 <PeakerWork> :t foldr (:) []
12:52:56 <lambdabot> forall a. [a] -> [a]
12:52:57 <ddarius> mmorrow: The former doesn't equal id it equals \xs -> if null xs then undefined else xs
12:53:13 <ddarius> mmorrow: The latter is id.  I said functions not expressions.
12:53:16 <mmorrow> oops, ok right. but foldr (:) [] stands
12:53:41 <mmorrow> ddarius: ahh. what's your definition of "function"?
12:54:02 <ddarius> mmorrow: A value of function type.
12:54:28 <ddarius> id and id id are different expressions that denote the same value
12:54:42 <ddarius> id and undefined are different expressions that denote different values.
12:54:56 <mmorrow> i'd call them members of the same equivalence class which is "id"
12:55:21 <mmorrow> but i hear what you're saying ;)
12:55:27 <ddarius> Typically we talk about values so we don't get trivial differences like \x -> x is different from \y -> y
12:55:38 <ddarius> Which are two different expressions which denote the same value.
12:55:54 <ddarius> You could talk about equivalences on expressions under the semantic function.
12:55:58 <mmorrow> sure, but that's a different equivalence than id id
12:56:25 <ddarius> It doesn't need to be.
12:57:14 <ddarius> If D is the semantic function then D[id] = D[id id] = D[\x -> x] = D[\y -> y]
12:57:52 <mmorrow> ok, our definitions of equivalent are different
12:57:53 <ddarius> Well, when applied to environment where id x = x, say
12:58:23 <ddarius> mmorrow: I'm not using that definition, I just suggested it.  I'm saying I'm only talking about values not expressions.
12:58:59 <mmorrow> so functions (from earlier) := values, correct?
12:59:14 <ddarius> functions âŠ‚ values
12:59:15 <mmorrow> (or s/:=/===/)
12:59:30 <mmorrow> ah, cafs /= functions
12:59:46 <mmorrow> (i take it)
12:59:47 <ddarius> cafs are irrelevant
13:00:00 <mmorrow> well then what is a value that is not a function?
13:00:00 <ddarius> 3 (:: Int) is not a function
13:00:29 <mmorrow> it's iso to (\() -> 3)
13:00:54 <ddarius> No it is not.  They aren't even the same type.  It's certainly not the case for the definition of "iso" you gave before.
13:01:48 <ddarius> A value is something you can pass around, a CAF is a declaration.  You don't pass around CAFs.
13:01:50 <mmorrow> well, ok i'm using a slightly different notion now i guess. delete the symbol 3 and replace it by (\() -> 3)
13:02:09 <ddarius> And then your program no longer typechecks.
13:02:15 <mmorrow> or somesuch. all i'm trying to say is .
13:02:22 <mmorrow> yeah, i've left the typesystem
13:02:33 <mmorrow> oh dear
13:03:00 <ddarius> And values aren't "symbols" (though symbols could be values).  They are the mathematical entities.
13:03:02 <mmorrow> ok fine. 3 is a value and not a function. what were we talking about again?
13:03:21 <mmorrow> :)
13:04:18 <ddarius> That there are an infinite number of functions [a] -> [a].  id is one, so is reverse, so is drop n for every n and take n for every n.
13:04:22 <mmorrow> ah yes. i wonder what a good definition of equality for such a prog that Peaker was talking about would be
13:04:28 <ddarius> We can also add permutations.
13:04:59 <ddarius> mmorrow: A good definition would be expressions that are beta-eta-alpha-equivalent.
13:05:23 <mmorrow> ah, i thought you were continuing in the context of "id, const, flip, ... function-that-don't-mess-with-stuff"
13:05:25 <ddarius> Though that is not decideable so you'd approximate that in some way.
13:05:40 <ddarius> You'd have to define "mess with stuff"
13:06:03 <ddarius> flip messes with stuff
13:06:11 <mmorrow> ddarius: hmm, i don't think you have to actually examine the internals of a suitably defined "variety" (not using "type" since that is taken here) of function
13:06:22 <mmorrow> s
13:06:46 <lispy> woot woot!
13:06:50 <mmorrow> ddarius: it messes with types, but not the values of that type
13:06:55 <lispy> darcs hacking sprint is going well, people!
13:07:08 <ddarius> mmorrow: It messes with the value as much as reverse does.  It applies a function.
13:07:10 * lispy is waiting on some tests to finish
13:07:43 <ddarius> I.e. it uses the fact that it's first argument is a function.
13:07:57 <roconnor> mmorrow: I'm finding it difficult to convince myself to add `xor`
13:08:01 <mmorrow> whereas: flip' = (\f -> (\xs ys -> f ys (reverse xs))) "messes with stuff" by my hyphen-heavy definition
13:08:12 <rwbarton> Is the problem of determining whether a type is uniquely inhabited decidable?
13:08:17 <roconnor> oh you are right here
13:08:18 <ddarius> You haven't given a definition.
13:08:29 <mmorrow> ddarius: look for the hyphens
13:08:35 <roconnor> mmorrow: I didn't mean to interupt
13:09:07 <roconnor> How do I add Haddock for an instance declaration?  Is that possible?
13:09:18 <mmorrow> roconnor: heh. i'll have to look at the def of xor. is it covered by some other op(s)?
13:09:51 <ddarius> mmorrow: The only place you use hyphens is in phrases like: "function-that-don't-mess-with-stuff" which is clearly not a definition of "messes with stuff"
13:09:53 <roconnor> mmorrow: I don't think it is convered but the other ops.  It's just a dumb operation. :)
13:10:16 <roconnor> mmorrow: Maybe if I can find a good name for it.  I hesitate to take xor
13:10:40 <rwbarton> roconnor: what's the operation?
13:10:44 <roconnor> mmorrow: maybe if I put it in another module, or something.
13:10:52 <mmorrow> ddarius: exactly! (clearly i haven't come up with a definition yet)
13:12:09 <mmorrow> roconnor: heh, it very well may be :)
13:12:21 <ddarius> mmorrow: If I Church encode lists and then write reverse in that encoding, does it cease to "mess with stuff"?
13:12:29 <roconnor> rwbarton: given two alpha colours:  (c0,a0)  (c1,a1) return (c0*(1-a1) + c1*(1-a0), a0*(1-a1) + a1*(1-a0)) ... I think
13:13:17 <roconnor> mmorrow: They list atop and xor as "less useful"  atop seems plasibily useful to me, but xor ...
13:13:20 <insane> msg PeakerWork because that is the way how >>= works
13:13:27 <mmorrow> ddarius: hmm, that would still be a messy little function but a sly one
13:14:20 <mmorrow> rwbarton: http://code.haskell.org/~morrow/papers/p253-porter.pdf
13:14:21 <lambdabot> Title: cache:http://code.haskell.org/~morrow/papers/p253-porter.pdf - Google Search
13:14:33 <mmorrow> (the paper that coined "alpha" channel)
13:15:52 <mmorrow> roconnor: i guess if it can't be recovered via some combo of the other ops i consider adding it. i'm not sure of the big picture here though
13:16:00 <mmorrow> s/i/i'd/
13:16:15 <insane> query PeakerWork
13:17:21 <mmorrow> ddarius: hmm, i brush up on church encoding, but can you rep infinite lists under such an encoding?
13:17:34 <mmorrow> if not, then reverse . reverse === id
13:17:46 <mmorrow> *i need to brush ...
13:18:06 <ddarius> That's irrelevant.  reverse /= id and any way take 1 is even easier to write.
13:18:28 <mmorrow> (i said reverse . reverse)
13:18:42 <mmorrow> reverse alone "messes with stuff" any way you cut it
13:18:51 <ddarius> Yes, but the equality is forall x. reverse x = id x which does not hold.
13:19:01 <pao> can anyone provide a clever way to construct [-10..0] lazyly, without list comprehensions?
13:19:04 <ddarius> If reverse messes with stuff, then so does flip.
13:19:28 <mmorrow> oh, ok i see what you're talking about now.
13:19:39 <dobblego> > [-10,-9..0]
13:19:40 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0]
13:20:09 <pao> dobblego: that is not a valid solution :-)
13:20:14 <mmorrow> i guess flip should be excluded from my "messes with stuff" class
13:20:23 <dobblego> pao, why?
13:20:29 <rwbarton> > enumFromTo (-10) 0
13:20:30 <lambdabot>   [-10,-9,-8,-7,-6,-5,-4,-3,-2,-1,0]
13:20:34 <mib_r7g5kjyt> hey, someone sent me this snipet of code mWidth = maximum . map (length . fst) , whats it mean?
13:20:46 <pao> > let a = 10 : map (flip (-) 1) a in takeWhile (>=0) a
13:20:48 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
13:21:04 <ddarius> mmorrow: I think the only functions in your "doesn't mess with stuff" class are curried projections, i.e. functions of the form \v1 v2 v3 v4 ... vn -> vi
13:21:04 <mmorrow> but i don't think the ways flip and reverse mess with stuff are that analogous
13:21:10 <pao> dobblego: list comprehensions and [..] notation is forbidden :-)
13:21:14 <ddarius> They both just apply functions.
13:21:17 <mmorrow> ddarius: yes, that sounds right
13:21:41 <pao> the solution you see above is the best I've found
13:21:41 <mib_r7g5kjyt> it confused me
13:22:20 <ddarius> Then even then the type doesn't uniquely determine those, though the most general type does.  \a b -> a and \a b -> b can both have type a -> a -> a
13:22:32 <mib_r7g5kjyt> does it mean it finds the longest string and maps the length and sets it first?`
13:22:41 <mmorrow> hmm, maybe "curried and possibly braided/permuted/something projections"
13:22:42 <ddarius> This is all excluding bottom.
13:22:54 <mmorrow> that would include flip then
13:23:18 <ddarius> flip uses application, projections don't use application
13:23:30 <ddarius> permuting doesn't really add anything.
13:23:37 <mmorrow> hmm
13:23:54 <mib_r7g5kjyt> fst = first ryt?
13:23:57 <mmorrow> alright, i'm cutting flip loose
13:26:33 <davbo> I've got a list of tuples where fst is an int, is there an easy way to sort and find the tuple with the biggest int?
13:26:55 <bd_> :t sortBy
13:26:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:27:07 <bd_> :t sortBy (compareBy fst)
13:27:08 <lambdabot> Not in scope: `compareBy'
13:27:11 <bd_> hmm
13:27:23 <bd_> @hoogle Ord b => (a -> b) -> a -> a -> Ordering
13:27:24 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:27:24 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:27:24 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:27:30 <bd_> :t sortBy (comparing fst)
13:27:31 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
13:27:34 <bd_> there you go :)
13:27:40 <davbo> Thank you bd_!
13:29:37 <mib_r7g5kjyt> mWidth = maximum . map (length . fst) - finds the longest string for eg in a list?
13:29:55 <dobblego> @unpl mWidth = maximum . map (length . fst)
13:29:55 <lambdabot> mWidth c = maximum (map (\ f -> length (fst f)) c)
13:30:17 <mib_r7g5kjyt> whats unpl mean sorry
13:30:56 <bd_> un@pl :)
13:31:17 <mib_r7g5kjyt> im confused, no idea what that means
13:31:45 <plutonas> what is the best way to find the index of the "middle" element of a list?
13:31:52 <plutonas> i could divide the list length by 2
13:32:02 <plutonas> but this has a type problem sometimes
13:32:30 <dobblego> mib_r7g5kjyt, @unpl expands the expression; perhaps this one is easier to read
13:32:33 <Samy> @pl (\a b -> (a, b))
13:32:33 <lambdabot> (,)
13:32:40 <Samy> @unpl (,)
13:32:40 <lambdabot> (,)
13:32:43 <Botje> plutonas: use `div` instead of /
13:32:58 <Samy> > (\a b -> (a, b)) 1 2
13:32:59 <lambdabot>   (1,2)
13:33:00 <Samy> > (,) 1 2
13:33:01 <lambdabot>   (1,2)
13:33:06 <plutonas> hm, ok
13:33:29 <Samy> :t div
13:33:31 <lambdabot> forall a. (Integral a) => a -> a -> a
13:36:26 <mib_r7g5kjyt> is beelsebob about?
13:38:09 <user317> is there a way to #include a file in haskell?  bascially i want to embed a file in my program that i will output later as boilerplate for some generated code
13:38:31 <Jaak> yes
13:38:51 <Jaak> you need to give some option to enable C preprocessor
13:39:14 <rwbarton> or you can use Template Haskell
13:39:19 <vixey> hello
13:39:29 <Jaak> (-ccp perhaps)
13:39:33 <Jaak> or that
13:40:05 <user317> cool thanks
13:40:55 <rwbarton> something like   s :: String; s = $( runIO (readFile "foo") >>= lift )
14:04:23 <tegguN> hey guys, could someone help me out a bit?
14:04:38 <dobblego> tegguN, just ask away
14:05:35 <mofmog> so ive been trying to learn about functional reactive programming but it seems there are very few (if any) good resources
14:05:54 <nolraiWest> If wanted a function like try except the types of the two exceptions were different, how would i do that?
14:05:56 <roconnor> is Arbitrary an instance of MonadZero?
14:06:01 <roconnor> er MonadPlus?
14:06:32 <bd_> :t try
14:06:33 <lambdabot> Not in scope: `try'
14:06:39 <bd_> nolraiWest: what do you mean by that?
14:06:44 <mofmog> wrap the two in they're own class (sort of serious)
14:06:47 <mofmog> their
14:06:48 <dobblego> roconnor, I expect not; an (Arbitrary a) is essentially a Int -> Rand -> a
14:06:53 <tegguN> basically i need to turn something like this: [["help","help"],["me"],["im"],["stuck"]] into something like this ["help **", "me * .. etc. where the *'s relate to the number of occurences of each word in the original list of strings
14:07:21 <vixey> tegguN: First solve a simpler problem:
14:07:32 <nolraiWest> from MonadLib, its like local but for Exception instead of Reader.
14:07:33 <roconnor> dobblego: darn
14:07:50 <mofmog> by class i mean type
14:07:55 <vixey> tegguN: convert [(["help","help"],2),(["me"],1),(["im"],1),(1,["stuck"])] into ["help **", "me * .. etc.
14:08:05 <vixey> tegguN: once you've done that remember 'zip'
14:08:09 <nolraiWest> mofmog: talking to me?
14:08:10 <roconnor> dobblego: is there a way to make an Arbitrary instance and "guard" against bad data?
14:08:12 <mofmog> iyeah
14:08:26 <insane> @src varCreate
14:08:26 <lambdabot> Source not found. Take a stress pill and think things over.
14:08:31 <mofmog> i dont think it's the best solution
14:08:44 <mofmog> im sure there's a better on...
14:09:05 <tegguN> how can i count each element?
14:09:12 <mofmog> Either
14:09:16 <mofmog> would Either work?
14:09:22 <dobblego> roconnor, that's an interesing question, since I contribute to ScalaCheck where an Arbitrary[A] is essentially a Int => Rand => Option[A] and this allows you to write a filter function, however, a filter function for QC would have to sit in a loop and keep trying, perhaps never terminating (I think?)
14:09:26 <vixey> tegguN: You didn't already solve that? If not someone from your class asked about it already in this channel today
14:09:43 <roconnor> dobblego: that's what I want.
14:09:52 <vixey> tegguN: might be amusing to read the logs
14:09:54 <dobblego> roconnor, I've never found a reasonable solution for Int -> Rand -> a
14:09:58 <tegguN> nope, must have been someone else? :S
14:10:02 <tegguN> where are the logs located?
14:10:06 <dobblego> roconnor, for exactly your problem that is
14:10:10 <nolraiWest> mofmog: you mean the function either? that might work.
14:10:10 <roconnor> dobblego: I want to guard against data falling in a set of measure 0. :)
14:10:31 <dobblego> roconnor, you can always use implication for expresing the property
14:10:31 <roconnor> dobblego: I want to generate arbitrary colour spaces, but colour primaries must be distinct.
14:10:43 <tegguN> oh wait i see the logs :)
14:11:51 <tegguN> what time did they ask that question?
14:11:55 <roconnor> dobblego: I'd have to add (Good colourSpace) ==> in front of every property.  I should really not generate bad colour spaces.
14:12:06 <roconnor> (good colourSpace) ...
14:12:27 <dobblego> roconnor, you could write a function \n -> (Good colourSpace) ==> n perhaps
14:13:27 <tegguN> so how did that person solve that problem??
14:13:50 <sleven> i sudo get-apted ghc and haskell-mode, i put :  (load "~/lib/emacs/haskell-mode/haskell-site-file") in my .emacs. i now try to load the interpreter but it says function defuinition is void
14:14:02 <sleven> i didnt move the haskell-mode file anywhere, i just used sudo get-apt
14:14:12 <sleven> i have retsarted emacs
14:15:01 <Baughn> sleven: Hang on, you installed haskell-mode via apt-get?
14:15:02 <mofmog> so apparently the debian repositories for ghc dont include profiling tools -_-
14:15:14 <Baughn> mofmog: What makes you say that?
14:15:19 <mofmog> because they don't
14:15:33 <mofmog> i tried profiling and it told me i didn't have them
14:15:41 <rwbarton> mofmog: you just haven't installed the profiling packages
14:15:50 <mofmog> exactly
14:15:55 <rwbarton> what specifically did it complain about?
14:15:58 <Baughn> sleven: Um. First off, last I checked (load) doesn't interpret ~ properly. Furthermore, if you apt-got haskell-mode, /it won't be in your homedir/
14:16:16 <aluink> i'm trying to read up on Show and understand the class, i can't find a good definition for ShowS, what's ShowS?
14:16:17 <ushdf> who wants to hear a song i wrote
14:16:18 <mofmog> i dont remember, i installed the latest version of ghc from the website instead of sudo apt-get installing
14:16:20 <ushdf> about a year ago
14:16:20 <ushdf> :D
14:16:29 <mauke> aluink: type ShowS = String -> String
14:16:34 <ushdf> http://128.230.217.183/mll03/ometotchtli/singles/ometotchtli - ymjj - 02 - ymjj.mp3
14:16:37 <ushdf> enjoy
14:16:38 <Baughn> sleven: Not that apt-getting it is necessarily a good idea; it'll be an old version
14:17:26 <sleven> Baughn: yes haskell-mode via apt-get
14:17:27 <aluink> mauke: thanks ;)
14:17:43 <mauke> > shows 42 "suffix"
14:17:44 <lambdabot>   "42suffix"
14:18:02 <sleven> ok so where is haskell-mode if i apt-get? im new to ubuntu
14:18:24 <Baughn> sleven: I have no idea. But as I mentioned, you really should use the cvs version.
14:18:49 <sleven> ok
14:18:56 <sleven> can i fetch it with git?
14:19:00 <sleven> or i have to use cvs?
14:19:02 <Baughn> sleven: ...I said cvs.
14:19:09 <sleven> man there are too many control version systems
14:19:40 <johnnowak> better than not enough
14:20:16 <sleven> yes but it would be nice if they worked together a little
14:20:17 * jeffz doesn't use the cvs version of haskell-mode
14:20:34 <jeffz> sleven: the haskell-mode package on ubuntu works for me.
14:20:53 <sleven> jeffz: for me to but i want to use ghci in emacs
14:21:38 <jeffz> sleven: oh, yeah... that thing.  I just use an M-x ansi-term in a buffer alongside rather than use the ghci that haskell-mode provides
14:24:07 <sleven> huh?
14:24:16 <sleven> i want to be able to load a file into ghci
14:24:38 <LarstiQ> sleven: nowadays, the do
14:24:42 <LarstiQ> they do even
14:25:20 <sleven> do what?
14:25:25 <davbo> I've imported Data.List and Data.Ord but can't seem to get sortBy (comparing fst) to work, could someone give me an example of the usage?
14:25:31 <LarstiQ> sleven: vcsen work together a little
14:25:34 <sleven> anyway where idoes apt-get place ghci?
14:25:38 <mofmog> so i'm about to delve into my machine structure's class's project on making a processor in logisim
14:25:38 <vixey> :t liftM2 shows
14:25:39 <lambdabot> forall a1 (m :: * -> *). (Monad m, Show a1) => m a1 -> m String -> m String
14:25:43 <Baughn> :t sortBy
14:25:44 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:25:45 <sleven> LarstiQ, ok good
14:25:51 <Baughn> :t comparing fst
14:25:51 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
14:25:54 <mofmog> i was wondering what processor hacks/etc i could do to semi support fp
14:25:58 <LarstiQ> sleven: use 'dpkg -L <packagename>' to see where the files from a package end up
14:26:01 <tegguN> vixey: how do I go about solving that problem?
14:26:04 <rwbarton> > sortBy (comparing fst) [(2, "world"), (1, "hello")]
14:26:05 <lambdabot>   [(1,"hello"),(2,"world")]
14:26:25 <Baughn> :t comparing
14:26:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:26:42 <vixey> tegguN: Did you do the subproblem I suggested?
14:27:06 <tegguN> I can't, how can I use length on a [[String]]
14:27:33 <davbo> hmm thanks rwbarton & Baughn
14:27:33 <jeffz> tegguN: I solved your friends homework but he didn't seem to notice, http://hpaste.org/11432#a1
14:27:44 <Zao> > length ["omg, "wtf"]
14:27:45 <lambdabot>   <no location info>:
14:27:45 <lambdabot>      lexical error in string/character literal at chara...
14:27:46 <mofmog> tegunn: you want the length of ALL strings?
14:28:16 <tegguN> i mean length [["hello, hello", "paul"]] will return 2
14:28:21 <mofmog> oh i see
14:28:26 <tegguN> I'm not sure how I can check each one
14:28:30 <mofmog> so you count hello once and paul once?
14:28:41 <Zao> tegguN: Depends on what you mean. The length of an list is always quite defined.
14:28:52 <Axman6> map (map length) ?
14:28:55 <mofmog> what would [["hello","hello","paul"] ["lol","lol"]] return?
14:29:13 <mofmog> oh wait i was misreading that
14:29:15 <tegguN> well basically I want to go from [["help","help"],["me"],["im"],["stuck"]] to something like this ["help **", "me * .. etc.
14:29:26 <tegguN> where the *'s mean the number of words in each one
14:29:32 <jeffz> tegguN: did you look at that paste I just mentioned?
14:29:42 <mofmog> so each sub list will always have the same word?
14:29:58 <tegguN> nope just say it now
14:30:01 <tegguN> *saw
14:30:09 <mofmog> would you see [["help","help","lol"]]
14:30:11 <mofmog> ?
14:30:44 <tegguN> mofmog: how do you mean?
14:30:49 <mofmog> is it always
14:30:54 <mofmog> ["help","help"]
14:30:56 <mofmog> or can there be
14:30:56 <Axman6> > msum [Nothing, Just 4, Just 7, Nothing]
14:30:58 <lambdabot>   Just 4
14:31:03 <mofmog> ["help","help","lol"]
14:31:04 <Axman6> hmm
14:31:26 <tegguN> jeffz: thanks I don't really want to copy, I want to learn properly, could you explain that line by line so I can work through my own solution?
14:31:38 <Axman6> > msum [Nothing, Just 4, Just 7]
14:31:40 <lambdabot>   Just 4
14:31:42 <mauke> > mconcat [Nothing, Just 4, Just 7, Nothing]
14:31:43 <lambdabot>   Add a type signature
14:32:00 <Axman6> just trying to figure out the point of msum
14:32:08 <tegguN> mofmog: I'm confused
14:32:10 <mofmog> if it's always the same, you can map over length, map with head, zipwith together, then map once more converting the numbers into a certain number of asterisks and then concatenating that to each element
14:32:10 <nolraiWest> If I want a monad where errors stop computation and cause it to immeditly return with the state at the time of the error, whats the esay ist way to do that? Can you do it just using monad transformers?
14:32:26 <sleven> LarstiQ, that works for haskell-mode but not for ghc, ghci or haskell(which is what i wanted i came up with ater i thought baout it)
14:32:28 <mauke> > mconcat [Nothing, Just (Sum 4), Just (Sum 7), Nothing]
14:32:29 <lambdabot>   Just (Sum {getSum = 11})
14:32:50 <tegguN> mofmog: thanks
14:33:00 <mofmog> tegguN: you want to turn [["help","help"]] into [["help **"]] right?
14:33:03 <mofmog> well im wondering
14:33:05 <tegguN> mofmog: what do u mean by always the same?
14:33:11 <tegguN> mofmog: exactly!
14:33:21 <mofmog> can you have [["help","help","lol"]] => [["help **","lol *"]]
14:33:23 <mauke> @unmtl ErrorT e (State s) a
14:33:23 <lambdabot> s -> (Either e a, s)
14:33:25 <nolraiWest> > mconcat [Nothing, Just [], just [1,2], Just [2]]
14:33:26 <lambdabot>   Not in scope: `just'
14:33:27 <rwbarton> nolraiWest: sounds like ErrorT e (State s)
14:33:58 <nolraiWest> > mconcat [Nothing, Just [], Just [1,2], Just [2]]
14:33:59 <lambdabot>   Just [1,2,2]
14:34:04 <mofmog> if you error out at a certain point in your computation, can you do something tricky like return the arguments to the next function?
14:34:13 <mofmog> return the monadic "package" so to speak
14:34:33 <mofmog> which should be effectively the same as returning the computation
14:34:50 <LarstiQ> sleven: that is because those are not names of packages. To find out what package a file comes from, try dpkg -S. For ghci that is 'ghc6'
14:35:21 <nolraiWest> does "ErrorT e (State s)" keep the state where the error was encounted some where?
14:35:43 <nolraiWest> @unmtl "ErrorT e (State s)"
14:35:43 <lambdabot> err: Parse error
14:35:48 <jeffz> tegguN: I tried to split it into several functions so it was easier to read, but perhaps it's a bit daunting.  normalise filters any punctuation and converts the words to lowercase. process splits the words from the string, sorts and turns them into a list of tuples of string and the the count.  then I calculate the length of longest word and prepretty print the list with that in mind.
14:36:28 <nolraiWest> @unmtl ErrorT e (State s)
14:36:28 <lambdabot> err: `ErrorT e (State s)' is not applied to enough arguments, giving `/\A. s -> (Either e A, s)'
14:36:29 <monochrom> ErrorT e (State s) doesn't keep the state in case of error.
14:36:40 <rwbarton> monochrom: Are you sure?
14:36:46 <nolraiWest> @unmtl ErrorT e (State s) r
14:36:47 <lambdabot> s -> (Either e r, s)
14:37:01 * monochrom blinks
14:37:26 <rwbarton> If you're inside State s, you can runErrorT an ErrorT e (State s) r to get a State s (Either e r)
14:37:46 <monochrom> I was wrong.  *hide*
14:37:50 <rwbarton> whatever changes in the state have occurred "before" the error will occur in your surrounding block
14:38:06 <rwbarton> I always think of it like this, ErrorT e IO doesn't magically make IO effects go away if there's an error :)
14:38:21 <rwbarton> IOT (Error e) would, but there's no IOT
14:38:57 <mib_4dsty536> tegguN
14:40:04 <sleven> pastebin ?
14:40:05 <rwbarton> So that means ErrorT e (State s) keeps the state change and State s (Error e) is for computations that might fail that have their own local state
14:40:15 <sleven> @hpaste
14:40:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:40:30 <Axman6> what happened to the hpaste bot?
14:40:50 <mauke> preflex: seen hpaste
14:40:50 <preflex>  hpaste was last seen on #haskell 107 days, 5 hours, 42 minutes and 11 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
14:41:06 <ari> So, uh, cabal folks or lambdabot folks: I just installed lambdabot (again) via cabal-install. (it went mostly well except for not automatically going out installing oeis). But now I want to make changes to the dice plugin, and I don't know how to set stuff up so I can conveniently hack on it.
14:41:09 <Axman6> ohh, saw some haskell porn and escaped
14:41:27 <sleven> http://hpaste.org/11486 <- what i have in .emacs but it doesnt work
14:41:36 <sleven> syntax-mode works but i cant load ghci
14:42:04 <mofmog> teguN: http://hpaste.org/11487
14:42:23 <nolraiWest> will do {set 3; throwError 1; set 2; return 0} :: ErrorT Int (State Int) Int, result in (Left 1, 3) or (Left 1, 2)?
14:43:27 <rwbarton> > runState (runErrorT (do { put 3; throwError "1"; put 2; return 0 })) undefined
14:43:28 <lambdabot>   (Left "1",3)
14:43:30 <mofmog> tegguN: you can make it even shorter, so i guess that's your task :)
14:43:51 <mofmog> that seems to be doing what it should
14:43:59 <nolraiWest> Cool, thats just what I wanted.
14:44:09 <mofmog> if you were to hack up your own monad, couldn't you do the same by doing something to bind?
14:44:18 <mofmog> and either or something
14:44:28 <ari> I unpacked the lambdabot archive from .cabal/packages and made changes to it. If I do runhaskell Setup.hs configure in the source directory, it complains at me for not having a bunch of packages I installed with cabal-install (does it matter that I did this as myself and not as root?).
14:44:31 <mofmog> >:t >>=
14:44:58 <rwbarton> @src ErrorT (>>=)
14:44:59 <lambdabot> m >>= k  = ErrorT $ do
14:44:59 <lambdabot>     a <- runErrorT m
14:45:00 <lambdabot>     case a of Left  l -> return (Left l)
14:45:02 <lambdabot>               Right r -> runErrorT (k r)
14:45:20 <ari> Is there a way to either convince it that I have those packages, or perhaps to do some magic to make it build otherwise?
14:45:35 <mofmog> so ErrorT's bind operator is just a generalized way of doing what i just said
14:46:04 <PeakerWork> where is dons' blog about stream fusion optimizations, with the program that computes means?
14:46:27 <mofmog> PeakerWork: it should be searchable by google
14:46:33 <PeakerWork> mofmog: Yeah, I can't find it
14:46:47 <rwbarton> ari: Yes, the user/root thing matters here
14:46:56 <rwbarton> ari: But, you can just run 'cabal configure', 'cabal build' instead
14:47:09 <olsner> or cabal install to do it all in one command
14:47:10 <elliottt> PeakerWork: http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
14:47:12 <PeakerWork> I find http://cgi.cse.unsw.edu.au/~dons/blog, but I can't see that entry, not sure if its his
14:47:12 <lambdabot> Title: Haskell hacking
14:47:13 <lambdabot> Title: Haskell hacking
14:47:30 <PeakerWork> elliottt: thanks
14:47:33 <elliottt> np :)
14:47:37 <mopped> How would one make a nCr function such that it returns all possible combinations?
14:47:38 * ari tries that
14:47:48 * ari tries that
14:47:48 <mofmog> all possible combinations?
14:47:56 <ari> rwbarton: Cool! Thanks :)
14:47:56 <mofmog> wouldn't that be nPr?
14:48:05 <mofmog> oh
14:48:06 <mofmog> nvm
14:48:10 <tegguN> mofmog: this is how I'm attempting it at present: http://hpaste.org/11488
14:48:13 <mofmog> i'm very good at reading comprehension
14:48:22 <mofmog> tegguN: does my solution meet what you want?
14:48:27 <tegguN> mofmog: where countAppend and addSpaces need to be implemented
14:48:56 <tegguN> mofmog: I want to try it with List Comprehension? (I'm just looking at your solution now, one sec...)
14:49:09 <mofmog> i think i might have misunderstood what you got as input
14:50:09 <PeakerWork> I thought I remembered that post talked about automatic stream fusion, but its been done manually...
14:50:15 <x6d65> How should I go about getting the square root of an integer?
14:50:36 <mofmog> >sqrt 3
14:50:38 <mauke> sqrt (fromIntegral i)
14:50:53 <monochrom> @quote fromIntegral
14:50:53 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
14:51:16 <x6d65> Heh, thanks.
14:51:21 <mofmog> So what's the point of having Int and Integral
14:51:29 <mauke> premature optimization
14:51:42 <x6d65> How should I figure this out for myself?
14:51:42 <monochrom> The same point of having Int and Eq.
14:51:43 <vixey> yes :)
14:51:50 <rwbarton> @type sqrt
14:51:51 <lambdabot> forall a. (Floating a) => a -> a
14:51:53 <mofmog> it seems half of the functions want/return Integral and half of the want/return Int
14:51:55 <rwbarton> @hoogle Int -> Floating
14:51:56 <lambdabot> Warning: Unknown type Floating
14:51:56 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:51:56 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:51:58 <mofmog> i mean
14:51:59 <mofmog> Integer
14:52:01 <rwbarton> @hoogle Int -> Double
14:52:02 <lambdabot> Prelude toEnum :: Enum a => Int -> a
14:52:02 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
14:52:02 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
14:52:04 <mofmog> not Integral
14:52:05 * vixey 's cult of the irrational hatred of Int
14:52:07 <rwbarton> err
14:52:11 <monochrom> OK, Int vs Integer is optimization.
14:52:24 <mofmog> is that it?
14:52:29 <monochrom> Yes!
14:52:31 <rwbarton> I guess toEnum would technically work
14:52:33 <mofmog> seriously?
14:52:42 <monochrom> Seriously.
14:52:43 <Baughn> mofmog: Well, Int can easily be a dozen times faster then Integer
14:52:47 <Axman6> > [1..] !! 4294967297
14:52:59 <Baughn> (On a few operations, that most programs don't use too much)
14:53:01 <bd_> Baughn: And the compiler can easily use a specialized form when the type resolves to Int :)
14:53:07 <mofmog> so what's the difference
14:53:15 <Baughn> bd_: Not for Integer, it can't. :P
14:53:16 <lambdabot>   thread killed
14:53:24 <Axman6> > maxBound :: Int
14:53:27 <bd_> Baughn: Which is why it should use Integral n => n or Num n => n
14:53:28 <Axman6> > maxBound :: Integer
14:53:28 <lambdabot>   9223372036854775807
14:53:29 <lambdabot>       No instance for (Bounded Integer)
14:53:29 <lambdabot>        arising from a use of `maxBoun...
14:53:44 <Baughn> bd_: Oh, sure
14:54:03 <rwbarton> mofmog: Int is a machine word sized integer, it fits in a register and sometimes the compiler can even put it in one :)
14:54:31 <LarstiQ> 'sometimes'? :)
14:54:40 <mofmog> 16 bit machines
14:54:42 <bd_> rwbarton: Int can fit in a register, sometimes :) (if it's using the S# constructor, and the compiler can prove this statically)
14:54:50 <bd_> er
14:54:51 <bd_> Integer
14:54:57 <Baughn> mofmog: Good luck fitting the RTS in 64KiB
14:54:59 <LarstiQ> rwbarton: does that mean Int is not the same size across architectures?
14:54:59 <rwbarton> Does the compiler ever prove that statically?
14:55:13 <rwbarton> LarstiQ: It's not even the same size across different compilers on the same architecture.
14:55:26 <bd_> rwbarton: maybe with toInteger :: Int -> Integer...
14:55:31 <Baughn> LarstiQ: If you want constant-sized integers, try Data.Int/word
14:55:32 <monochrom> This is like asking "why do we have both non-strict pattern matching and strict pattern matching so I have a choice. I don't want a choice; no one does."
14:55:34 <mofmog> everyone has a right to 32 bit long integers
14:55:35 <tegguN> mofmog: your method is almost perfect! I just need to convert it from [["help**"],["me*"],["im*"],["stuck*"]] to ["help**", "me* .. etc
14:55:42 <mofmog> oh
14:55:49 <mofmog> then in the last let statement
14:55:52 <LarstiQ> Baughn: thanks
14:55:53 <mofmog> remove the []
14:55:53 <mofmog> s
14:56:00 <LarstiQ> rwbarton: oh
14:56:22 <Axman6> long's are 32 bits now?
14:56:35 <rwbarton> LarstiQ: Moreover, an Int can be an unevaluated expression--you can't fit that in a register :)
14:56:42 <Axman6> -'
14:57:02 <bd_> rwbarton: However if GHC can prove that the function overall is strict on that Int, it can force it into a register :)
14:57:17 <rwbarton> Yeah, exactly.  Hence 'sometimes'
14:57:27 <LarstiQ> rwbarton: right, right :)
14:57:37 <Baughn> rwbarton: Happily, that usually happens exactly in the tight loops you want it to happen in
14:57:37 <vixey> > [["help**"],["me*"],["im*"],["stuck*"]] >>= id
14:57:38 <lambdabot>   ["help**","me*","im*","stuck*"]
14:58:01 <mauke> > [["help**"],["me*"],["im*"],["stuck*"]] >>= ask
14:58:02 <lambdabot>   ["help**","me*","im*","stuck*"]
14:58:06 <mauke> just ask nicely
14:58:19 <roconnor> @info Monoid
14:58:19 <lambdabot> Monoid
14:58:38 <vixey> @info Monad
14:58:39 <lambdabot> Monad
14:58:40 <idnar> I was doing something the other day, where Integer seemed to be faster than Int
14:58:49 <idnar> can't remember what now, it was some Project Euler problem
14:58:57 <x6d65> So I actually wanted to compare an Integer to the sqrt of another Integer. Is the best way to do this (fromInteger a) > (sqrt (fromInteger b))?
14:59:16 <idnar> x6d65: what about a * a > b ?
14:59:25 <vixey> x6d65: with less ()'s though
14:59:26 <monochrom> Heh
14:59:53 <vixey> that you are computing a sqrt isn't a terrible sin really
14:59:54 <roconnor> > getSum (mconcat [1,2,3])
14:59:55 <lambdabot>       No instance for (Num (Sum a))
14:59:55 <lambdabot>        arising from the literal `1' at <i...
15:00:04 <vixey> > getSum (mconcat (map return [1,2,3]))
15:00:05 <lambdabot>       No instance for (Monad Sum)
15:00:05 <lambdabot>        arising from a use of `return' at <i...
15:00:08 <vixey> :/...
15:00:09 <roconnor> > getSum (mconcat (map Sum [1,2,3]))
15:00:10 <lambdabot>   6
15:00:12 <x6d65> idnar: Heh, good point.
15:00:19 <roconnor> :instances Monoid
15:00:21 <mofmog> you know how we have "a (c,d) = c+d"
15:00:22 <tegguN> :mofmog you my friend, are a genius!!
15:00:23 <x6d65> idnar: I like that much more.
15:00:27 <roconnor> @instances Monoid
15:00:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:00:45 <sleven> so i can compile from emacs but i cant start ghci. a bit annoying. is anyone using ghci+ubuntu+emacs. what do you have in your .emacs?
15:00:48 <mofmog> tegguN: it's not the perfect solution
15:00:54 <mofmog> it can be -shorter-
15:00:57 <vixey> sleven: I just use ghci in a terminal
15:00:58 <mofmog> by at least one line
15:01:03 <mofmog> 2 i should say
15:01:07 <vixey> sleven: editing the .hs file separately
15:01:07 <tegguN> mofmog: can it be done using list comprehensions?
15:01:14 <sleven> vixey: how do you send code to it then?
15:01:16 <mofmog> why?
15:01:20 <mofmog> you're not making a list
15:01:24 <vixey> sleven: in ghci, :load file.hs
15:01:41 <vixey> I don't really type ".hs" actually
15:01:42 <tegguN> i know but i believe we're supposed to be using those and not maps
15:01:47 <sleven> vixey: ok but i like C-c C-l better :) otherwise i might as well be compiling almost
15:02:55 <roconnor> what command does darcs rollback & darcs revert?
15:03:17 <sleven> anyone? use ghci+emacs+ubuntu?
15:04:17 <jeffz> sleven: yes, I do the same as vixey
15:05:32 <nolraiWest> Does where you put ReaderT in a tranformer chain matter?
15:05:40 <jeffz> sleven: have you read http://groups.google.com/group/linux.debian.bugs.dist/browse_thread/thread/3013a667e71cd8eb
15:05:42 <lambdabot> Title: Bug#492517: haskell-mode: Inferior haskell seems to not be loaded - linux.debian ..., http://tinyurl.com/5s9eh4
15:06:36 <sleven> ok i tried as you do and it works fine but it is just tha then i might need 2 terminals open.
15:06:40 <sleven> or maybe not
15:07:40 <nolraiWest> @unmtl ErrorT err (ReaderT env (State s)) r
15:07:41 <lambdabot> env -> s -> (Either err r, s)
15:08:04 <nolraiWest> @unmtl ReaderT env (ErrorT err (State s)) r
15:08:04 <lambdabot> env -> s -> (Either err r, s)
15:08:14 <nolraiWest> looks like no.
15:08:15 <jeffz> sleven: you don't need "two terminals open", just C-x 3, C-x o, M-x ansi-term RET ghci foo.hs, C-x o, C-x-f foo.hs RET
15:08:38 <rwbarton> I think it can matter, but it often doesn't, but I haven't thought of a counterexample
15:08:59 <Beelsebob> hah
15:09:13 <Beelsebob> and what jeffz said is exactly why emacs sucks :)
15:09:42 <Beelsebob> "why have two terminals open when you can do this really comlicated thing instead"
15:09:44 <vixey> cool I didn't know about ansi-term
15:09:51 <sleven> thanks jeffz ghci works n emacs now
15:10:11 <sleven> Beelsebob, you use Vim?
15:10:32 <Beelsebob> no, I open terminal windows to do things in a terminal, and I open a text editor to edit text
15:10:37 <Beelsebob> (SubEthaEdit fwiw)
15:10:40 <nolraiWest> I use gedit and am happy!
15:10:53 <mofmog> i use eclipse (for C and Java)
15:10:56 <sleven> jeffz: is your latest post a joke about emacs or something i could use? it is hard ly "just" doing all that
15:10:58 <mofmog> i use gedit for haskell
15:11:14 * Beelsebob never got the fascination with having a text editor do *everything* badly
15:11:19 <vixey> sleven: that's like 5 commands.. not hard to type 5 commands in
15:11:31 <mofmog> well the thing about emacs and vim is that they require no mouse
15:11:39 <mofmog> that's why uber nerds love it
15:11:48 <mofmog> (these are also the same people that use tiling window managers)
15:11:54 <Beelsebob> yeh -- and that's why they're so slow
15:12:04 <mofmog> no it's supposed to be faste
15:12:11 <mofmog> the only one i know decently is vim
15:12:17 <Beelsebob> mousing is *fast* you just think it's slow because it your brain is doing nothing at all while you're doing it
15:12:32 <Beelsebob> as opposed to using a bajillion key combos your brain is working hard trying to remember them all
15:12:37 <Beelsebob> and doesn't realise how long it's taking
15:12:43 <jeffz> Beelsebob: why does it suck that I was able to explain a sequence of commands with a few words?
15:12:45 <mauke> Beelsebob: [citation required]
15:12:49 <jeffz> Beelsebob: that's nonsense.
15:12:51 <vixey> why remember things when it only takes a couple hours to re-read the documentation
15:12:51 <vixey> ?
15:13:01 <Beelsebob> mauke: sec, I do have a citation for actual timed experiments that showed this
15:13:15 <lament> keyboard is fast! freedom is slavery! war is peace!
15:13:17 <mofmog> emacs and vim just have high learning curves *shrug*
15:13:27 <lament> mofmog: no, not "just"
15:13:40 <Axman6> Beelsebob: i think that's why i like things like TextMate (and SEE can be lumped here), they're not designed to be used just using the kb, but it makes some things fatser
15:13:49 <lament> in addition to sucking, they do, in fact, have high learning curves.
15:14:05 <mofmog> what did the symbolics machines use? my sicp professor always jerked off about them having damn good uis or something
15:14:09 <jeffz> lament: 15 minutes is hardly a high learning curve.
15:14:29 <Beelsebob> mauke: http://www.asktog.com/TOI/toi06KeyboardVMouse1.html
15:14:34 <lambdabot> Title: AskTog:
15:14:35 <Beelsebob> "Test subjects consistently report that keyboarding is faster than mousing.
15:14:36 <Beelsebob> The stopwatch consistently proves mousing is faster than keyboarding."
15:14:38 <osfameron> jeffz: in what reality can you learn vim or emacs in 15 minutes?
15:15:06 <mofmog> my only beef with vim is that ESC is wayyy too far away from everything else
15:15:07 <jeffz> osfameron: I taught someone the basics in 15 minutes when they were struggling with editing some lisp in an inferior editor
15:15:16 <osfameron> I *love* vim, and I can imagine loving emacs (though I don't), but they do have a curve
15:15:25 <LarstiQ> mofmog: with capslock mapped to escape that's not a huge problem anymore for me
15:15:28 <lament> mofmog: Ctrl-C does the same thing
15:15:34 <rwbarton> Beelsebob: Ah, but what matters is which one I *think* is faster :P
15:15:36 <Axman6> anyone see that article about the debian vim maintainer moving to emacs?
15:15:50 <mofmog> i hear the esc key was originally where the caps lock key was
15:15:53 <LarstiQ> Axman6: yeah, although trying out is more like it
15:15:55 <Beelsebob> rwbarton: heh, tbh, for me, what matters is what gives me more time to think about what I'm editing
15:15:59 <mofmog> and that's why it made sense way back whent o use esc
15:15:59 <osfameron> caps lock is an annoying key
15:16:00 <Beelsebob> which is mousing
15:16:05 <Beelsebob> i.e. I need to think less to mouse
15:16:09 <lament> mofmog: no, more like where the tilde is
15:16:16 <osfameron> it should be up with ScrLk and Pause and all the other keys that nobody understands what they do anymore
15:16:16 <Beelsebob> so I do more actual work, and less playing with an "editor"
15:16:18 <mofmog> still, that's a lot closer
15:16:28 <osfameron> Beelsebob: good point
15:16:31 <mofmog> like
15:16:37 <mofmog> what's the point of numlk on a laptop
15:16:50 <osfameron> that's why I liked gvim to start off with.  Great for just doing stuff until you're *ready* to optimize by learning the shortcuts
15:17:36 <earthy> yeah. unfortunately there's something called cream that completely messes up the shortcuts
15:17:43 <mofmog> i think someone needs to set up a vim script or emacs script which binds a lot of common things to common (ie Ctrl-C and V for copy and paste) shortcuts
15:18:02 <earthy> mofmog: cream. :)
15:18:11 <mofmog> hmm
15:18:12 <LarstiQ> mofmog: the windows mode for vim does that iirc, it's horrible
15:18:14 <earthy> but I detest it.
15:18:17 <jeffz> mofmog, that would be useless
15:18:27 <earthy> jeffz: actually, MacVim does it right
15:18:30 <Beelsebob> mofmog: actually on my laptop numlock does something different from normal -- it converts an area of the main keyboard into a numpad
15:18:35 <lilac> has anyone managed to get mueval to compile against GHC 6.10?
15:18:55 <Beelsebob> (specifically 7,8,9,u,i,o,j,k,l)
15:19:18 <jeffz> mofmog, people complain about the complexity of emacs as if it's a chore for people to remember, but anyone who actually spends enough time to get familiar with it performs the actions unconciously
15:19:37 <mofmog> that's true
15:19:47 <monochrom> Ctrl-C is common shortcut for aborting a program.
15:19:50 <LarstiQ> right, vim is in my fingers, not my mind
15:20:03 <monochrom> Ctrl-V is common shortcut for escaping Ctrl-whatever.
15:20:07 <osfameron> jeffz: I found the number of keyboard shortcuts required to get back to a normal state confusing in emacs (in vim it's just a case of hitting Esc enough times)
15:20:18 <osfameron> I'd get stuck in the "minibuffer" or whatever it's called
15:20:23 <earthy> jeffz: it's the spending that time in the first place that is helped by having common UI shortcuts
15:20:50 <rwbarton> osfameron: just hit Esc enough times
15:21:10 <monochrom> Ctrl-G
15:21:11 <LarstiQ> earthy: mja, 'common' in what environment?
15:21:14 <Will\home> well hai there osfameron!
15:21:23 <sleven> hmm: cool investigation Beelsebob . funny result. I just thinall IDEs suck ass. In emacs i can run anything. it does have quite a learning curve but what i most like is that i can take away everything i dont like. just text everywhere.
15:21:31 <osfameron> yo Will\home
15:21:44 <mofmog> Will::home
15:21:44 <sleven> eclipse, netbeans they ar ejust big and heavy, do everything i dont need and nothin of what i want
15:21:48 <jeffz> osfameron: it's not hard to jump out of the minibuffer if you don't want to answer its question
15:21:50 <Will\home> haha mofmog
15:21:51 <Beelsebob> sleven: actually, "I can run anything" is my main complaint about emacs
15:22:00 * mofmog takes a swipe at PHP
15:22:02 <Beelsebob> the UNIX ideal was meant to be a set of simple small orthogonal tools
15:22:07 <mofmog> the inventor of PHP came to my school
15:22:12 <Beelsebob> emacs and vim both completely destroy that mantra
15:22:26 <mofmog> when i talked about ML style pattern matching he shivered and went "OOOOH nooo"
15:22:34 <mofmog> but then i realised this was the guy who did PHP
15:22:38 <Valodim> did you deliver the well-deserved kick in the nuts?
15:22:59 <mofmog> he works for yahoo apparently?
15:23:52 <mauke> Beelsebob: "Using Microsoft Word on a Macintosh, I typed in a paragraph of text, then replaced every instance of an "e" with a vertical bar (|). The test subject's task was to replace every | with an "e." Just to make it even harder, the test subjects, when using the mouse, were forbidden to just drop the cursor to the right of the | and then use the delete key to get rid of it. Instead, they had to actually drag the mouse pointer across the one-pixel widt
15:23:58 <mauke>  of the character t o select it, then press the "e" key to replace it.
15:24:17 <mofmog> um
15:24:23 <bd_> mauke: Was find and replace acceptable?
15:24:25 <mofmog> isn't there an emacs command for that
15:24:26 <mofmog> AND a vim command
15:24:30 <mauke> bd_: no, only cursor keys
15:24:39 <bd_> mauke: oh :|
15:24:50 <LarstiQ> mauke: :%s/e/|/g
15:24:58 <mauke> LarstiQ: :%s/|/e/g
15:25:01 <mauke> oh, oops
15:25:01 <ziman> or qwf|re100@w :)
15:25:03 <mauke> yeah, right
15:25:26 <mofmog> ummmmm that's like saying "let's compare this rocket launcher to this rifle but you can't use rockets"
15:25:31 <LarstiQ> mauke: so yeah, I don't have much faith in that "test"
15:25:32 <Beelsebob> bd_: the object was to find out whether the *same* task could be done with equal speed, similarly, one might ask what's faster, select search and replace from a menu, type in your search and replace and press okay, or typing /e/|/g
15:25:53 <vixey> Âµ
15:26:01 <Beelsebob> hehe
15:26:01 <lament> by the way, the fact that you have to end every search and replace command in vim with a /g is proof that vim was not designed for human beings
15:26:06 <Beelsebob> well said vixey
15:26:06 <mofmog> the whole point of emacs and vim is that you have all these powerful features in terms of commands
15:26:18 <vixey> @seen shapr
15:26:19 <lambdabot> I saw shapr leaving #haskell-soc, #haskell-blah, #scannedinavian and #haskell 5d 8m 49s ago, and .
15:26:25 <ziman> and you can combine them
15:26:32 <LarstiQ> lament: no, most of my replaces do not use /g
15:26:35 <roconnor> can Haddock document instance declarations?
15:26:40 <Baughn> The point of using a keyboard instead of a mouse is that you can have commands that wouldn't /fit/ in a menu
15:26:41 <Beelsebob> ziman: no, that's exactly what's wrong with vim and emacs
15:26:45 <Beelsebob> I can't combine them with *anything*
15:26:48 <mofmog> exactly, it's like why using the command line in unix is superior to using a windowing manager
15:26:49 <x6d65> lament: :help gdefault
15:26:50 <Beelsebob> because they're huge monoliths
15:26:56 <Beelsebob> rather than sets of simple orthogonal tools
15:27:12 <jeffz> your mantra is wrong :P
15:27:23 <LarstiQ> Beelsebob: eh, the vim philosophy is entirely what you claim
15:27:28 <Baughn> Beelsebob: Being monolithic would imply them being rock-solid. I prefer to think of emacs as a pile of goo.
15:27:36 <LarstiQ> Beelsebob: it is built on motions, objects and operations
15:27:43 <vixey> Baughn: as is any big lisp program :)
15:27:43 <Beelsebob> LarstiQ: yep, that's why it's easy to get the vim to give output into another unix  tool
15:27:45 <Beelsebob> wait... no
15:28:01 <vixey> sticky goo mind.. that you can make stuff with
15:28:04 * Beelsebob runs off to sleep now
15:28:13 <mauke> :w !someprogram
15:28:39 <monochrom> |
15:28:44 <earthy> :)
15:28:54 <mofmog> what version of emacs works inside the terminal?
15:28:59 <mofmog> i hate the gui
15:29:06 <rwbarton> emacs -nw
15:29:12 <mofmog> thx
15:29:12 <mauke> enjoy your useless menu bar
15:29:31 <mofmog> UGHHH
15:29:32 <Baughn> Emacs has a menu bar?
15:29:33 * araujo greets
15:29:36 <mofmog> yes
15:29:44 <mofmog> it does but apparently without the gui it doesn't do anything
15:29:46 <mauke> Baughn: and it's not clickable
15:29:49 <monochrom> esc `  or   meta-`
15:29:54 <earthy> baughn: it can has
15:29:59 <mofmog> ok fine, how do i un uglify the gui
15:30:03 <mofmog> this is why i prefer vim -_-
15:30:09 <mofmog> purely aesthetic reasons lol
15:30:23 <rwbarton> it's "clickable" if you turn on M-x xterm-mouse-mode
15:30:24 <monochrom> Pure misinformation in this channel on editors.
15:30:27 <earthy> learning both emacs and vim is slightly too much effort. :)
15:30:44 <lament> i agree, and haskell
15:30:52 <vixey> yikes
15:30:59 <ddarius> "Haskell: Even The Misinformation Is Pure"
15:31:00 <mofmog> screw it, i'm writing my own text editor
15:31:01 <mauke> why does it display a menu bar if you have to enter a special command to make it do anything?
15:31:03 <vixey> The Semantics of Reflected Proof -- and the sequel Reflecting the semantics of reflected proof
15:31:07 * vixey wonders what comes next
15:31:09 <monochrom> "I can't get out of the minibuffer in emacs!"  ctrl-g
15:31:13 <Baughn> mauke: I remember having to explicitly turn it on in mine.. and I'm on os x, so I don't really have a choice about using screen space for it
15:31:28 <lament> vixey: probably The Semantics of Reflected Proof?
15:31:35 <ddarius> "Reflecting reflecting the semantis of reflected proof"
15:31:37 <monochrom> "I can't invoke the menus in emacs -nw!"  esc ` or meta-`
15:31:51 <mauke> how "obvious"
15:31:56 <mofmog> i'm writing my own text editor
15:31:58 <monochrom> "vim doesn't combine with other tools!"  :| or something
15:32:03 <mofmog> it will have such things as
15:32:08 <mofmog> saving files and opening them
15:32:17 <mauke> srsly, menus are for interactive discoverability
15:32:32 <mofmog> i always felt the emacs menus were worthless anyways
15:33:09 <lament> nah
15:33:16 <lament> _software_ is for interactive discoverability
15:33:37 <ddarius> Nah, the world is for interactive discoverability.
15:33:51 <monochrom> "haskell doesn't mutate variables!"  ST
15:33:56 <lament> the world is not man-made so we can forgive the occasional unclearness
15:34:01 <Peaker> kind of weird that C-- is supposed to be closer to assembly, but has "accurate GC"?
15:34:05 <mofmog> text editor in emacs?
15:34:10 <ziman> mutilated variables
15:34:13 <sleven> to whoever used gedit: dont you miss syntax-highlighting?
15:34:15 <Peaker> mofmog: I disable the emacs menu
15:34:20 <mauke> emacs has other issues by default, like leaving backup files everywhere and not terminating the last line in a file
15:34:24 <mofmog> sleven: gedit has highlighting
15:34:27 <mofmog> for haskell even
15:34:56 <Twey> Is there a monad sort of like Maybe, but with an opposite >>=?  i.e. try a bunch of actions until one succeeds, then return that?
15:35:23 <mofmog> what if none succeeds
15:35:24 <ddarius> Use maybe, but use mplus/msum
15:35:33 <Twey> Ahh, yes, of course
15:35:35 <Twey> Thanks
15:35:47 <Axman6> @src reverse
15:35:47 <lambdabot> reverse = foldl (flip (:)) []
15:36:06 <monochrom> If I could modify the /topic line, I would: /topic Editors commentory by people who have spent 5 seconds or less on editors.
15:36:40 <Twey> Heh
15:36:41 <ahunter2> Can anyone help me out with a recursive import problem?   http://hpaste.org/11491
15:36:45 <sleven> mofmog: for all kinds of languages?
15:37:07 <mauke> my favorite emacs annoyance is that it puts the cursor in VERY VISIBLE mode
15:37:42 <ddarius> mauke: emacs knows what's best for you
15:37:58 <mauke> btw, this is hardcoded in the C part of its source
15:38:23 <rwbarton> mauke: what do you mean?
15:38:27 <mauke> I think this was the main reason I didn't start using emacs back when
15:38:43 <mofmog> sleven: you can make your own if it's not covered but they have a ton of languages supported now
15:38:46 <Axman6> @src foldl'
15:38:46 <lambdabot> foldl' f a []     = a
15:38:47 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:38:48 <monochrom> strange reason, but ok :)
15:38:53 <mofmog> haskell, i think vhdl even, and of course the big C like languages
15:38:59 <mauke> monochrom: it looked different than every other program in my terminal
15:39:16 <mofmog> from the monadplus wikibook
15:39:28 <mauke> rwbarton: terminfo has a special escape sequence (cvvis) to make the cursor "very visible"
15:39:34 <mofmog> http://en.wikibooks.org/wiki/Haskell/MonadPlus could you make binChar parallelized using par?
15:40:39 <mofmog> binChar s = (zero `par` one `par` (mplus zero one)) where {zero = digit 0 s; one = digit 1 s} and so on
15:41:01 <mofmog> im assuming that's how you do it
15:41:02 <mofmog> =/
15:42:17 <eu-prleu-peupeu> hello
15:42:20 <eu-prleu-peupeu> i am the keeper of books
15:42:32 <ddarius> mofmog:  For some monads that would more or less work.
15:44:10 <Peaker> is c-- a viable candidate for code generation, rather than C? or is it not as good as gcc?
15:44:35 <Botje> I found c-- to not quite work :p
15:44:43 <Peaker> Botje: at all?
15:44:58 <Botje> i'm not sure really
15:45:07 <vixey> Peaker: what code generation why?
15:45:09 <Botje> i gave up at some point trying to get my c-- programs to compile
15:45:23 <Baughn> Peaker: Have you looked at llvm?
15:45:29 <Peaker> Baughn: nope
15:45:44 <Peaker> vixey: ghc's code generation. Just curious (Reading about C-- now)
15:46:14 <mofmog> so apparently compiling to C intermediate code then using gcc produces better code than just ghc core -> machine?
15:46:22 <BONUS> hey guys, how would i ask lambdabot what the kind for z in class Z z where zoot :: u l p -> l m -> z l m p u
15:46:23 <BONUS> is
15:46:25 <Baughn> Peaker: LLVM looks very active, and more importantly, very useful
15:46:26 <mofmog> if im reading dons post right
15:46:33 <Baughn> Peaker: http://llvm.org/
15:46:34 <lambdabot> Title: The LLVM Compiler Infrastructure Project
15:46:34 <mofmog> HEY BONUS ARE YOU PROTECTED?
15:46:40 <badtruffle> apple uses it so it must be good
15:46:41 <Axman6> Apple are putting a lot of work into LLVM
15:46:42 <BONUS> I HAVE A STAIRS
15:46:48 <badtruffle> :P
15:47:02 <Axman6> they already use it in leopard to recompile OpenGL code for older GPUs on the fly
15:47:24 <monochrom> I generate code in Haskell.
15:47:25 <badtruffle> yup, and on the iphone
15:47:26 <tegguN> could somebody tell me how I could find the longest word from a list of words?
15:47:43 <mofmog> foldl
15:47:45 <badtruffle> tegguN: a fold should do it
15:47:46 <mauke> maximumBy (comparing length)
15:47:52 <Axman6> maximumBy (comparing length)?
15:47:54 <mofmog> or that
15:47:55 <Valodim> sortBy + length
15:47:56 <monochrom> what mauke says :)
15:48:03 <badtruffle> yeah, his sounds nicer
15:48:09 <tegguN> ahh thank you :)
15:48:12 <BONUS> or maximumBy (compare `on` length)
15:48:13 <Axman6> damn it mauke, BeelsebobWork'ed me
15:48:22 <Axman6> @src on
15:48:22 <lambdabot> (*) `on` f = \x y -> f x * f y
15:48:25 <Valodim> haha
15:48:27 <mauke> @src comparing
15:48:27 <lambdabot> Source not found. Are you on drugs?
15:49:29 <mofmog> @src maximumBy
15:49:29 <lambdabot> Source not found. That's something I cannot allow to happen.
15:49:47 <aeolist> does llvm have a garbage collector or is it true it really needs one?
15:50:05 <vixey> I think you can use various GCs with LLVM
15:50:18 <Axman6> yeah, it's lower level than that i believe
15:50:22 <Axman6> hence the LL
15:50:30 <aeolist> aha, but one hasnt been specifically designed for llvm?
15:50:40 <tegguN> im getting an error: Undefined variable "comparing"
15:50:44 <vixey> why would that mean anything
15:50:48 <mauke> @hoogle comparing
15:50:48 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:50:48 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:51:17 <Axman6> @src State
15:51:17 <lambdabot> Source not found. :(
15:51:31 <tegguN> ahh :)
15:51:37 <Axman6> is it 'data State a b = State {runstate :: (a -> (a,b))}'?
15:51:59 * EmielRegis http://failblog.org/2008/10/23/gun-safety-fail/
15:51:59 <monochrom> I forgot (a,b) or (b,a)
15:51:59 <lambdabot> Title: Gun Safety Fail Â« FAIL Blog: Pictures and Videos of Owned, Pwnd and Fail Moment ...
15:52:10 <mofmog> so apparently lambdabot has a brainfuck interpreter
15:52:13 <mauke> :t runState
15:52:14 <lambdabot> forall s a. State s a -> s -> (a, s)
15:52:22 <Axman6> there we go
15:54:13 <x6d65> What does @hoogle do, exactly?
15:54:25 <Axman6> the same as...
15:54:28 <Axman6> @where hoohle
15:54:28 <lambdabot> I know nothing about hoohle.
15:54:30 <Axman6> @where hoogle
15:54:30 <lambdabot> http://haskell.org/hoogle
15:54:34 <Axman6> ^^
15:54:47 <x6d65> Sweet, thanks :)
15:54:55 <x6d65> I was looking for hoogle.net, .com, etc.
15:55:18 <x6d65> Those aren't places you want to go.
15:55:33 <mauke> http://www.google.de/search?q=hoogle
15:55:34 <lambdabot> Title: hoogle - Google-Suche
15:56:26 <nolraiWest> do you guys like "(const x)" or "(\ _ -> x)" better?
15:56:36 <ahunter2> const x
15:59:56 <x6d65> mauke: Yes, silly me. I just keep trying to prove to myself that google isn't smarter than I am.
16:01:31 <ahunter2> So, if I put the wrong diffs into a darcs patch, I can use darcs amend-record to fix that...what if I put the right diffs in, but screwed up the description?
16:01:55 <roconnor> mmorrow: I realize now that any crazy function you want to define can be defined, including xor.
16:02:12 <roconnor> mmorrow: alphaChannel :: AlphaColour a -> a gives you the alpha channel
16:02:23 <Baughn> ahunter2: --edit-long-comment, or -m..
16:02:26 <Baughn> ahunter2: --help is useful.
16:02:27 <roconnor> and (`over` black) gives you the premultilpied colour channel
16:02:56 <nolraiWest> BONUS: I like your tutorial. Lots of cool and good examples. One thing that you might want to think about though: You use return to refer to what a function evaluates to, that's going to get confusing once you get to monads.
16:03:18 <roconnor> mmorrow: affineCombo allows you to add Colours, with a lot of work.  ... I've added a monoid instance for Colour to make adding colours a little easier.
16:03:19 <tegguN> how could I return the length of the longest word from a list of words?
16:03:43 <Baughn> tegguN: How would you find the longest word in a list of words?
16:03:51 <mauke> maximum . map length
16:03:58 <MarcWeber> tegguN head $ sortyBy length $ list or such
16:04:03 <roconnor> and (\c -> blend o c black) allows you to scale colours, but I've added darken to do this.
16:04:14 <Zao> mauke: That'd give you the length though.
16:04:21 <tegguN> Baughn: maximumBy (compare length)?
16:04:23 <mauke> Zao: wat
16:04:26 <Pseudonym> roconnor: Good stuff on the color library, BTW.
16:04:31 <rwbarton> Zao: that's what tegguN asked
16:04:34 <Zao> mauke: I was under the impression he wanted the word itself.
16:04:42 * Pseudonym can't wait to see full-spectrum manipulation
16:04:46 <Baughn> tegguN: Why, yes. Although mauke's version is better.. given that you now have the longest word, how hard is it to find its length?
16:04:48 <Zao> So yes, maximumBy.
16:05:06 <Zao> Bah, missed the first bit of the question.
16:05:14 <roconnor> mmorrow: Now I'm pondering if I should add an alphaColourPlus function.
16:05:14 <Zao> I blame all the code spammed in here :P
16:05:26 <tegguN> Baughn: ah.. im an idiot :) i'll get back to you if i still can't work it out
16:05:30 <Peaker> Baughn: C-- is SPJ's project?
16:05:54 <Baughn> Peaker: Wikipedia seems to think so, yes
16:06:06 <Peaker> Baughn: weird that ghc doesn't use it then? :)
16:06:36 <Pseudonym> Peaker: He's in the consortium, IIRC, but no.  It's owned by ML guys.
16:07:14 <Pseudonym> C-- is an agreement between modern-language implementors that C isn't always the best cross-platform assembler.
16:07:19 <tegguN> Baughn: length (maximumBy (compare length))?
16:07:53 <Baughn> tegguN: That seems like the obvious solution
16:08:01 <tegguN> Baughn :)
16:08:14 <Peaker> tegguN: you could   maximum . map length
16:08:15 <badtruffle> > (maximumBy (compare `on` length)) ["abc", "abcd", "ab"]
16:08:16 <lambdabot>   "abcd"
16:08:38 <Peaker> > maximum . map length ["abc", "abcd", "ab"]
16:08:38 <badtruffle> > (maximumBy (compare length)) ["abc", "abcd", "ab"]
16:08:40 <lambdabot>   Couldn't match expected type `a -> [a1]'
16:08:40 <lambdabot>   Couldn't match expected type `([a] -> Int) -> Ordering'
16:08:44 <Peaker> > maximum . map length $ ["abc", "abcd", "ab"]
16:08:46 <lambdabot>   4
16:09:24 <Peaker> tegguN: the point of using maximumBy is that you get access to the pre-comparison value. If you don't need anything other than the lengths, just use  map length
16:09:52 <tegguN> Peaker: hmm okay
16:13:53 <mofmog> badtruffle: you need comparing not compare
16:14:11 <mofmog> @src `on`
16:14:11 <lambdabot> Source not found. Where did you learn to type?
16:14:12 <badtruffle> @src comparing
16:14:12 <lambdabot> Source not found. :(
16:14:20 <mofmog> @src on
16:14:21 <lambdabot> (*) `on` f = \x y -> f x * f y
16:14:38 <mofmog> @src compare
16:14:38 <lambdabot> compare x y | x == y    = EQ
16:14:38 <lambdabot>             | x <= y    = LT
16:14:38 <lambdabot>             | otherwise = GT
16:14:42 <badtruffle> that's fun
16:14:51 <badtruffle> > (maximumBy (comparing length)) ["abc", "abcd", "ab"]
16:14:52 <lambdabot>   "abcd"
16:14:57 <badtruffle> almost reads like a sentence now
16:15:02 <mofmog> @hoogle on
16:15:02 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:15:03 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
16:15:03 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:17:30 <nolraiWest> monadLib used to have a ChoiceT didn't it?
16:18:50 <mofmog> wow
16:18:53 <mofmog> on is a cool function
16:19:37 <electronx> > fromIntegral (43 / 5)
16:19:38 <lambdabot>   Add a type signature
16:19:49 <electronx> can someone help me get that to work
16:19:57 <electronx> > fromIntegral (43 / 5) :: Int
16:19:58 <lambdabot>   Add a type signature
16:19:59 <mauke> what's that supposed to do?
16:20:07 <Saizan> electronx: you can't use fromIntegral on a non-Integral value
16:20:09 <electronx> return the integer val
16:20:15 <mauke> > 43 `div` 5
16:20:15 <Saizan> ?type round
16:20:16 <lambdabot>   8
16:20:17 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
16:20:34 <electronx> ?typ (43 / 5)
16:20:35 <lambdabot> forall t. (Fractional t) => t
16:20:46 <electronx> ?typ (43 / 5) :: Float
16:20:47 <lambdabot> Float
16:20:53 <mofmog> >((>) `on` (sqrt . fromInteger) ) 4 3
16:21:00 <electronx> > fromIntegral (43 / 5) :: Float
16:21:01 <lambdabot>   Add a type signature
16:21:06 <mofmog> > ((>) `on` (sqrt . fromInteger) ) 4 3
16:21:08 <lambdabot>   True
16:21:20 <Saizan> > round (43 / 5) :: Int
16:21:21 <lambdabot>   9
16:21:33 <mofmog> so it's like... you treat the arguments of the first function as a functor and then you map
16:21:43 <electronx> ok thats what i want now i want to know why that fromIntegral didn't work
16:21:53 <Saizan> electronx: fromIntegral works only on Int and Integer, not on Float
16:22:08 <Saizan> electronx: since Float is not an instance of the Integral typeclass
16:22:10 <rwbarton> :t 43 / 5
16:22:11 <lambdabot> forall t. (Fractional t) => t
16:22:12 <electronx> :type fromIntegral
16:22:13 <rwbarton> :t fromIntegral
16:22:14 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:22:32 <electronx> > fromIntegral 5
16:22:34 <lambdabot>   5
16:22:44 <electronx> ?type fromIntegral 5
16:22:45 <lambdabot> forall b. (Num b) => b
16:22:48 <mauke> :t 5
16:22:49 <lambdabot> forall t. (Num t) => t
16:22:50 <mofmog> > toInteger (3/4)
16:22:51 <lambdabot>   Add a type signature
16:22:52 <electronx> ?type fromIntegral 5 :: Integer
16:22:53 <lambdabot> Integer
16:22:59 <mauke> :t 5 :: Integer
16:23:00 <lambdabot> Integer
16:23:02 <electronx> ?type (fromIntegral 5) :: Integer
16:23:03 <lambdabot> Integer
16:23:08 <electronx> woot
16:23:13 <electronx> ?type (fromIntegral 5) :: Double
16:23:14 <lambdabot> Double
16:23:18 <rwbarton> um
16:23:22 <rwbarton> ?type 5 :: Integer
16:23:23 <lambdabot> Integer
16:23:24 <rwbarton> ?type 5 :: Double
16:23:28 <electronx> why did it work with integer
16:23:34 <lambdabot> Double
16:23:44 <Saizan> electronx: why not?
16:24:05 <electronx> what would be the point
16:24:29 <Saizan> > fromIntegral (5 :: Int) :: Integer
16:24:30 <lambdabot>   5
16:24:56 <electronx> (5 :: Int) ::Integer
16:25:02 <electronx> > (5 :: Int) ::Integer
16:25:04 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
16:25:24 <electronx> okay
16:25:26 <electronx> i get it
16:27:03 <Baughn> :t fromEnum
16:27:04 <lambdabot> forall a. (Enum a) => a -> Int
16:27:20 <Baughn> ...Int. Now there's a case of premature optimization if I've ever seen one.
16:28:02 * Baughn was trying to make Double an instance of Enum
16:28:25 <mofmog> well
16:28:27 <rwbarton> > fromEnum (3 :: Double)
16:28:29 <lambdabot>   3
16:28:45 <mofmog> Enum can only be used on countable numbers?
16:28:46 <Baughn> A *non-broken* instance of Enum
16:29:04 <Baughn> mofmog: Floating-pont numbers are countable, though
16:29:33 <rwbarton> Inasmuch as they are finite...
16:29:36 <mofmog> that's true
16:29:43 <mofmog> 32 bit width floating point right?
16:29:52 <Baughn> rwbarton: It's probably not an actual rule, but I feel that toEnum . fromEnum should be id
16:30:06 <Baughn> mofmog: Doubles are 64-bit, and Floats are a bad idea
16:30:12 <Baughn> (Except on GPUs)
16:30:40 <rwbarton> Baughn: I agree, probably Enum Double shouldn't exist, but then we wouldn't be able to write [0.5 ..]
16:30:41 <Baughn> The thing is, of course, that you can't have an Enum instance for Doubles when there are more doubles than ints
16:31:27 <Peaker> take 5 $ [0.5..]
16:31:30 <Peaker> > take 5 $ [0.5..]
16:31:32 <lambdabot>   [0.5,1.5,2.5,3.5,4.5]
16:31:40 <Baughn> rwbarton: No, I'm fine with there being an instance. I'm just not fine with the instance.
16:32:32 <Saizan> Baughn: hey, just switch to a 64-bit arch :)
16:32:44 <tegguN> mofmog: the solution you helped me with earlier, how could I apply that technique to add spaces infront of each word, calculated by subtracting the length of each word from the length of the largest word?
16:33:09 <Baughn> Saizan: That works for doubles, but how about my arbitrary-precision floating-point numbers?
16:33:37 <mofmog> find the length of the longest word
16:33:40 <Baughn> Saizan: Really, it's fromEnum returning Int that makes no sense. It should be Integer, or Integral if we must have backwards-compatibility
16:33:41 <Saizan> yeah, there's the same problem with Integer too
16:33:46 <mofmog> use concat and replicate
16:33:51 <mofmog> map appends
16:34:09 <mofmog> is this for homework?
16:34:14 <mofmog> this seems sort of silly
16:34:51 <mofmog> > concat $ replicate 4 " "
16:34:53 <lambdabot>   "    "
16:35:14 <pcc1> is it possible to have the return type of a happy parser to be Just a, where Nothing is returned if there's a parse error?
16:35:26 <pcc1> s/Just/Maybe/
16:35:28 <mofmog> map (\x -> x ++ (concat $ replicate 4 " ")) [" hi","lol"]
16:35:34 <mofmog> for example
16:35:43 <tegguN> this is my current attempt http://hpaste.org/11494
16:36:10 <mofmog> well in that case
16:36:15 <mofmog> len is the length of the current word
16:36:25 <mofmog> you want the difference between the longest and the current right?
16:36:39 <mofmog> so how do you find the longest word and save its length?
16:36:41 <tegguN> yeeah
16:36:49 <tegguN> *yeah
16:37:24 <tegguN> length (maximumBy (compare length) thats how im trying at the moment
16:37:51 <mofmog> mm
16:38:09 <rwbarton> just let it be
16:38:16 <tegguN> oh wait sorry im being silly i think i get it
16:38:18 <tegguN> thanks :)
16:38:41 <mofmog> yeah, what you're doing right now is just modifying lists
16:38:49 <mofmog> think of it like a matrix
16:38:56 <mofmog> and you do separate operations on each item
16:40:54 <mofmog> anyone know a tutorial for core haskell or whatever it's called? the best i can do is some haskell group in turkish
16:41:34 <nolraiWest> :t (-)
16:41:35 <lambdabot> forall a. (Num a) => a -> a -> a
16:42:23 <Saizan> core haskell?
16:43:37 <mofmog> haskell core?
16:43:38 <mofmog> ghc core?
16:43:53 <mofmog> the thing you get after ghc does all the optimizations
16:45:29 <nolraiWest> what does the Real type class refer to?
16:45:33 <Saizan> oh, ghc core, and i'm only aware of some papers by SPJ about it
16:46:26 <mofmog> dons stream fusion blog post made me interested in it
16:46:47 <Saizan> ?src Real
16:46:47 <lambdabot> class  (Num a, Ord a) => Real a  where
16:46:47 <lambdabot>     toRational      ::  a -> Rational
16:47:06 <nolraiWest> hmm
16:47:14 <nolraiWest> thanks
16:48:51 <user317> does the ghc api offer any hooks into the parse step?  i am trying to embedd ghc into another program, and i am trying to figure out how to extend it
16:49:09 <x6d65> Is there sugar or a convenient function for generating a list of numbers in reverse order?
16:49:16 <Cale> nolraiWest: a very unfortunately named class ;)
16:49:36 <Cale> > [67,66..30]
16:49:37 <lambdabot>   [67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43...
16:49:51 <x6d65> Ah, thank you.
16:49:52 <sbahra> > [30 .. 10]
16:49:53 <lambdabot>   []
16:50:03 <sbahra> > [31, 30 .. 10]
16:50:04 <Cale> > [30,29..10]
16:50:05 <lambdabot>   [31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10]
16:50:05 <lambdabot>   [30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10]
16:50:19 <sbahra> > [32, 30 .. 10]
16:50:20 <lambdabot>   [32,30,28,26,24,22,20,18,16,14,12,10]
16:50:31 <Cale> > ['a','c'..'z']
16:50:32 <lambdabot>   "acegikmoqsuwy"
16:50:33 <sbahra> cool
16:50:54 <x6d65> What function does that use to actually generate the list?
16:51:01 <Cale> enumFromThenTo
16:51:08 <Cale> :t enumFromThenTo
16:51:10 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
16:51:43 <x6d65> Cale: Thanks :)
16:53:17 <nolraiWest> Where is the docs for Data.Stream?
16:54:08 <ziman> @hoogle Data.Stream
16:54:09 <lambdabot> package Stream
16:54:09 <lambdabot> package stream-fusion
16:54:09 <lambdabot> package streamproc
16:54:35 <ziman> hm, you can get there via Hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Stream
16:54:37 <lambdabot> Title: HackageDB: Stream-0.2.6
16:54:57 <ziman> use the `Home page' link
16:57:56 <nolraiWest> hmm You'd think there would be a function to add a prefix to a Stream.
17:00:54 <Cale> Well, there's always foldr (<:>) str xs
17:01:22 <roconnor> Does haddock image links work?  They don't work for me.
17:03:00 <roconnor> googling "haddock images" ... doesn't help
17:04:20 <Cale> Hmm, I have never actually seen an image in Haddock documentation.
17:04:40 <roconnor> I wanted to document my colour names. :)
17:07:20 <roconnor> hmm, images are not part of the lastest documenation for haddock
17:07:26 <electronx> can someone help me fix this http://hpaste.org/11495
17:07:45 <electronx> can't get the types correct
17:08:01 <yav> what is the type error that you get?
17:08:03 <mauke> fromIntegral x / 2
17:08:50 <electronx> but if the result is integral
17:08:55 <rwbarton> x `div` 2
17:08:56 <electronx> no need for round?
17:09:16 <mauke> what?
17:09:23 <mauke> / never returns an integral value
17:09:34 <electronx> then why does round fail?
17:09:37 <yav> the operator (/) works only on Fractional types, and Int is not one of them.
17:09:43 <mauke> how does round fail?
17:09:44 <electronx> oh
17:09:53 <electronx> :t (/)
17:09:54 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:10:02 <yav> :t div
17:10:03 <lambdabot> forall a. (Integral a) => a -> a -> a
17:10:03 <electronx> oops
17:10:10 <electronx> i stuffed up
17:10:13 <electronx> srry
17:10:39 <electronx> thanks for your help peoples
17:10:45 <yav> sure
17:17:25 <dons> yay ,darcs is now bytestring-ised and cabalised.
17:18:20 <idnar> for a moment I was trying to figure out what ",darcs" was
17:18:30 <idnar> I was dredging up horrible memories of arch/tla
17:19:11 <mml`> (unquote 'darcs)
17:19:15 <yav> nice dons
17:20:43 * Peaker is watching the "Black Box Voting" video.  America is screwed :-(
17:23:36 <Peaker> one thing is clear -- in next elections, the guys doing election frauds will shred their documents before throwing them to the trash
17:27:45 <jsn> Peaker: happy to talk about this in #haskell-blah
17:31:28 <electronx> is this a bad thing to do in ghci? filter (\x -> x `mod` 600851475143 == 0) [1..600851475143]
17:32:06 <electronx> i executed that command and have no result
17:32:09 <jsn> electronx:  well, it won't be fast
17:32:22 <electronx> that was a minute ago
17:32:31 <jsn> maybe you could explicitly annotate it as Word64 ?
17:32:40 <Zao> Heat death of the universe slow :)
17:32:54 <mc__> Hi, im thinking of switching to windows. How is the status of haskell and windows, is it well supported?
17:33:02 <Zao> mc__: It's quite decent.
17:33:05 <electronx> mc__: its fine
17:33:28 <nolraiWest> Whats the fast way to find, say, a maching parens in a string?
17:33:30 <Zao> mc__: You may have some trouble with some third party packages that expect a msys environment to build, but most works out of the box.
17:33:44 <electronx> Zao: how long do ya think it will take?
17:33:46 <rwbarton> 600 billion? In ghci? You'll be waiting a while.
17:34:03 <electronx> should i compile it?
17:34:04 <rwbarton> Consider your processor probably does fewer than 3 billion operators a second...
17:34:10 <rwbarton> *operations
17:34:24 <mc__> Zao: what is msys?
17:34:26 <electronx> should i make a tail recursive loop?
17:35:12 <rwbarton> (1) you should compile it
17:35:24 <rwbarton> (2) you should make some back-of-the-envelope calculation about how long it is likely to take
17:35:25 <yav> electronx: ghci is not a good tool for executing large computations
17:35:35 <rwbarton> (3) you should find a better algorithm :)
17:35:40 <electronx> lol
17:35:56 <rwbarton> In this case, I can tell you the output will be [600851475143], if that saves you any time
17:35:56 <electronx> is there a better way to find factors of a number?
17:36:01 <rwbarton> Yes
17:36:10 <rwbarton> 600851475143 `mod` x == 0 for one thing
17:36:19 <electronx> hahah oops
17:36:29 <shrughes> nolraiWest: do you just have a random string, or do you want to maintain a data structure of matching parens?
17:36:34 <rwbarton> :)
17:36:54 <Zao> The largest factor not the number itself would be at most sqrt(n) large, for example.
17:36:56 <nolraiWest> hmm.
17:37:02 <Zao> That takes things down to quite more manageable levels.
17:37:32 <electronx> Zao: okay
17:37:34 <Zao> Erm, or not.
17:37:50 <Zao> Disregard that, I should sleep :)
17:37:53 <rwbarton> > head $ filter (\x -> 600851475143 `mod` x == 0) [2..]
17:37:54 <lambdabot>   71
17:38:02 <rwbarton> rinse, repeat
17:38:35 <nolraiWest> shrughs: I just have a random string. (well not a string, its realy a array, but..)
17:40:50 <nolraiWest> Is the basic recusive idea what i want? I think I almost see how that would work.
17:40:50 <electronx> filter isPrime $ filter (\x -> 600851475143 `mod` x == 0) [1..60085147514
17:40:51 <electronx> 3]
17:41:22 <electronx> returns [] straight away
17:41:28 <electronx> no idea why
17:41:44 <rwbarton> does isPrime expect an Int?
17:41:44 <electronx> filter (\x -> 600851475143 `mod` x == 0) [1..60085147514
17:41:44 <electronx> <electronx> 3]
17:41:52 <electronx> yes
17:42:04 <rwbarton> there's your problem, 600851475143 :: Int is probably negative
17:42:13 <idnar> > [1..60085147514] :: [Int]
17:42:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:42:14 <electronx> ah thanks
17:42:25 <rwbarton> (not in 64-bit-goodness lambdabot)
17:42:46 <idnar> uhm.
17:42:51 <idnar> guess I don't have any 32-bit systems handy
17:43:00 <rwbarton> Prelude> 600851475143 :: Int
17:43:01 <rwbarton> -443946297
17:43:12 <electronx> i think int only goes to 4 billion right?
17:43:32 <electronx> > 2**32
17:43:33 <lambdabot>   4.294967296e9
17:43:38 <nolraiWest> > 2 ** 31
17:43:40 <lambdabot>   2.147483648e9
17:43:53 <electronx> is int sighned?
17:44:02 <nolraiWest> > :t (-1)
17:44:03 <lambdabot>   <no location info>: parse error on input `:'
17:44:04 <yav> yes, you can use Word for unsigned
17:44:11 <yav> from Data.Word
17:46:36 <nolraiWest> @pl \x y -> f x y || g x y
17:46:36 <lambdabot> ap (ap . ((||) .) . f) g
17:46:55 <nolraiWest> hmm, not useful.
17:48:06 <TSC> Is there a variation of groupBy where the order of the input list doesn't matter?
17:48:23 <TSC> > groupBy (\ x y -> even x == even y) [1..10]
17:48:24 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
17:48:38 <TSC> I would prefer [[1,3,5,7,9], [2,4,6,8,10]]
17:48:45 <Zao> nubBy maybe?
17:49:05 <TSC> Like nubBy, but I don't want to remove any of the elements
17:49:27 <yav> TSC: for this particular example you could use 'partition'
17:49:50 <TSC> yav: Sure, but in general there will be more than two equivalence classes
17:50:27 <nolraiWest> @Hoogle Maybe a -> b -> Either a b
17:50:27 <lambdabot> Maybe you meant: google hoogle
17:50:29 <dolio> > partition even [1..10]
17:50:30 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
17:50:33 <nolraiWest> @hoogle Maybe a -> b -> Either a b
17:50:34 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
17:50:34 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
17:50:34 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
17:50:42 <rwbarton> TSC: You want something like connected components
17:50:52 <nolraiWest> @hoogle Maybe a -> b -> Either a b
17:50:53 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
17:50:53 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
17:50:53 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
17:50:59 <yav> TSC: right.  i can't think of a predefined function that does it.
17:51:09 <rwbarton> TSC: or are you assuming the relation is an equivalence relation?
17:51:12 <dolio> > partition odd [1..10]
17:51:13 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
17:51:21 <TSC> It's an equivalence relation in my case
17:52:24 <Nafai> How do I run haddock on a file that has #ifdef's in it?
17:52:33 <rwbarton> If your relation is of the form \x y -> f x == f y you can write something like M.values (M.fromListWith (++) [ (f x, [x]) | x <- xs ])
17:53:17 <TSC> Ah, I think I could make it in that form; that's a good idea
17:55:01 <Nafai> n/m
17:56:22 <TSC> @pl (\ x y -> f x == f y)
17:56:22 <lambdabot> (. f) . (==) . f
17:56:26 <ahunter2> I'm having some trouble with a monad transformer stack that stacks ReaderT on top of ReaderT.  Specifically, I'm using the MonadScope from here http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html on top of a ReaderT, and I need the overall stack to have an instance for MonadReader that matches the inner one.  Any help?
17:56:28 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
17:59:23 <yav> ahunter2: there are different things you could do.
17:59:33 <BMeph> Hello, everyone? What's the topic this hour? :)
17:59:46 <rwbarton> ahunter2: I think you just need to write a ~3-line instance like the one provided for MonadState s m => MonadState s (ScopeT k v m).
18:00:33 <yav> ahunter2: is your stack of monads defined with a newtype?
18:00:56 <ahunter2> rwbarton:  tried that.   instance MonadReader r m => MonadReader r (ScopeT k v m) where
18:00:56 <ahunter2>      ask = ScopeT . lift $ ask
18:00:56 <ahunter2>      local f a = ScopeT . (lift $ local f) . unScopeT $ a. but got: MonadScope.hs:38:26:
18:00:56 <ahunter2>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
18:00:56 <ahunter2>     When matching the kinds of `t :: (* -> *) -> * -> *' and
18:00:57 <ahunter2>                                `(->) :: ?? -> ? -> *'
18:00:59 <ahunter2>     Probable cause: `$' is applied to too many arguments
18:01:01 <ahunter2>     In the first argument of `(.)', namely `(lift $ local f)'
18:01:03 <ahunter2>  on the "local" line
18:01:05 <ahunter2> yav: yes, it is
18:01:09 <conal> nolraiWest: (liftA2.liftA2) (||) f g
18:01:13 <conal> (just tuned in)
18:01:24 <ahunter2> I'm using newtype deriving to derive Monad/MonadScope Name Expr
18:02:23 <BMeph> TSC: sounds like your problem is a perfect match for 'equating'. :)
18:03:07 <conal> liftAn can be composed with itself any number of times
18:03:09 <rwbarton> conal: on the Phooey page, there's a Plan at the bottom to create a web version
18:03:12 <BMeph> TSC: I.e., equating f = (==) `on` f
18:03:13 <ziman> :t ((==) `on` ?f)
18:03:14 <lambdabot> forall b a. (?f::a -> b, Eq b) => a -> a -> Bool
18:03:15 <rwbarton> conal: do you know whether anyone has tried this?
18:03:28 <yav> ahunter2: in your instance (1) "ask" for the context  (2) run the reader with that value (3) now use "local
18:03:28 <yav>  (4) lift the whole thing
18:03:35 <conal> rwbarton: i haven't heard of an attempt
18:03:46 <rwbarton> conal: OK.  I may give it a try some day
18:04:05 <conal> rwbarton: that'd be nifty.  if you do, i hope you'll show me.
18:04:09 <rwbarton> conal: sure thing.
18:04:18 <roconnor> should readColourName return m (Colour a) or Maybe (Colour a)?
18:04:28 <electronx> just wandering whats the best way to get the prime factors for a number?
18:04:43 <electronx> precomput a large table of primes?
18:04:58 <electronx> then test each one on a number?
18:05:40 <roconnor> electronx: depends on the size of the numbers you want.  Trial division is pretty good for small numbers.
18:05:44 <rwbarton> ahunter2: that error is truly perplexing
18:05:57 <electronx> roconnor: the number is about 6 billion
18:06:03 <ahunter2> yav:  I'm still a bit confused as to why the instance given there for MonadEnv doesn't work for MonadScope if I add it
18:06:05 <electronx> wait 600 billion
18:06:18 <BONUS> electronx: this piece of code served me pretty well when doing euler problems http://hpaste.org/11496
18:06:26 <BMeph> electronx: Yes, with perhaps some memoization thrown in if you're factoring a bunch of numbers.
18:06:35 <roconnor> electronx: that sounds small
18:08:00 <electronx> BONUS: thanks
18:08:14 <BONUS> using that code i pasted i get the prime factors of about 60 billion and some more pretty much instantly
18:08:15 <BONUS> hehe np
18:08:34 <Nafai> BONUS: Yeah, I ended up making a Primes module with those sorts of functions for my Euler attempts :)
18:08:43 <BONUS> yeah, same here heh
18:09:12 <BONUS> i made a module that has functions for primes and permutations
18:09:24 <yav> ahunter2: do you mean the instance for EnvT?
18:09:48 <ahunter2> yav: yeah, I'm trying to write the same instance  instance MonadReader r m => MonadReader r (ScopeT k v m) where ... that worked just find for EnvT
18:10:45 <electronx> BONUS: i don't like that code its hard for me to understand
18:10:53 <electronx> its like the fib function
18:11:01 <electronx> using lazy eval to much :)
18:11:05 <electronx> hehe
18:11:19 <yav> ahunter2: well, EnvT is defined by using a StateT, while ScopeT is defined with a ReaderT.  So your instance for ScopeT will have to "skip over" the ReaderT layer of your monad stack.
18:11:32 <rwbarton> electronx: You can just replace primes with 2 : [3,5..] without too much difference in speed
18:11:53 <yav> ahunter2: by the way, to do a simple type inference for Haskell, you really don't need all these complex classes and instances.
18:11:54 <BMeph> Nafai, BONUS: Mine is called Factors.hs, and includes totient as well as factors and primes. :)
18:12:11 <BONUS> yeah totient is really handy too
18:12:23 <BONUS> especially for stuff that deals with phi
18:12:30 <ahunter2> yav: I'm not doing type inference, I just need both a scope tracker and a reader for a few values while evaluating expressions in an interpreter I'm uising
18:12:38 <ahunter2> yav: ...oh, right.  the StateT defines an instance for MonadReader, doesn't it?
18:13:20 <yav> ahunter2: yes.  and so does ReaderT, but you want to tell the compiler to not use it.  this is why i was suggesting that you need to first "run" the Reader layer, to temporarily eliminate it.
18:14:26 <ahunter2> yav: that leaves me with a value of type (Context k v -> m a) (where m is the inner stack), though
18:14:35 <ahunter2> which still isn't quite right for passing to local
18:15:36 <yav> ahunter2: right. so you first "ask" for the context, so that you have a value, then you run with the value that you got.  that should give you an "m a" thing.
18:16:39 <yav> ahunter2: so something like this:
18:17:17 <yav> ahunter2: do { ctxt <- ask; lift (local f (runReaderT m ctxt)) }
18:18:56 <ahunter2> well, got it to compile...that means it works :P thanks
18:19:16 <yav> ahunter2: optimistic are we :-)
18:19:35 <ahunter2> yav: honestly, I don't see a way for this particular thing to typecheck and not work :P
18:19:47 <yav> you are probably right.
18:20:03 <yav> perhaps we should have started by using jinn and asked it to derive it :)
18:23:57 <_wu>  
18:42:09 <sbahra> @hoogle uname
18:42:09 <lambdabot> No results found
18:42:37 <sbahra> Is there some haskell package that provides access to uname(2) on POSIX systems?
18:44:22 <Zao> System.Info not rich enough?
18:44:50 <Zao> Dug around in System.Posix?
18:47:19 <_wu> System.Posix.Unistd has getSystemID
18:52:45 <ninboy> Hello everyone!
18:53:10 <yav> hi ninboy
18:53:39 <ninboy> Hope all of you are fine!
18:55:56 <ninboy> I have a question... I'm working with files (and hugs), and when I do a function that have a Handle and a hGetChar, the output value always is "IO -something-"
18:56:48 <ninboy> The thing is... I don't need that "IO" prefix, how can I delete it=
18:56:50 <electronx> ninboy: yes
18:57:10 <electronx> do char <- hGetChar
18:57:18 <electronx> needs to be used in do notation
18:57:25 <ninboy> Ok
18:57:31 <electronx> and assigned to var using <-
18:57:44 <electronx> that will unwrap value from the IO monad
18:58:08 <Botje> deleting it is just a matter of hitting the delete key three times
18:58:09 * Botje runs
18:58:45 <bd_> do notation doesn't 'get rid' of IO
18:58:53 <bd_> the only way to 'get rid' of IO is to execute it
18:58:59 <ninboy> See this: http://haskell.pastebin.com/m68f0fb6d
18:59:03 <bd_> in a standalone program, you'd do this by binding it to main eventually
18:59:17 <bd_> in interactive hugs... I don't know, I always use ghci  :)
18:59:48 <rwbarton> ninboy: looks almost perfect, you just need to add IO before Terreno
18:59:59 <Botje> ninboy: call leerCaracter from main
19:00:01 <Botje> something like
19:00:05 <Botje> main = leerCaracter stdin
19:00:10 <Botje> then call main in hugs
19:00:13 <Botje> that should work, i think
19:00:42 <bbx350> I need help with my homework !_!
19:00:45 <bd_> Botje: if you call main in hugs' command line, that'll have the same type as leerCaracter stdin :)
19:00:51 <bbx350> Lol
19:00:53 <bd_> whatever leerCaracter is
19:01:04 <Botje> bd_: yes, but it's less typing.
19:01:07 <bd_> ghci will automatically execute IO actions on the ocmmand line
19:01:07 <Botje> :P
19:01:09 <bd_> Botje: true
19:01:20 <Botje> bbx350: don't worry, we'll send it to your teacher for you :)
19:01:22 <Botje> what's the matter?
19:01:40 <bbx350> This one question for a project, I can't find it
19:01:51 <ninboy> Ok... But the problem is, I want to compare that output agains a "Terreno" data... Should I compare it like: (leerCaracter archivo)== "NoTransitable"
19:01:54 <bbx350> has to do with cellular respiration, where does the citric acid cycle take place
19:02:18 <rwbarton> ninboy: nope, you have to use leerCaracter the same way you used hGetChar.
19:02:18 <bbx350> biology=P
19:02:39 <ninboy> mmmm, I get it...
19:03:12 <ninboy> I have to use leerCaracter with a do... I can't inside a non-monadic function?
19:03:35 <rwbarton> Right
19:03:44 <rwbarton> leerCaracter does IO, and monads are how we keep track of IO
19:04:00 <ninboy> Ok, I'll have to rethink again the function... Thanks!!!!
19:04:02 <rwbarton> for example, how we keep track of what order effects take place in.
19:04:03 <dblazakis> an endomorphism is a function from a -> a, right?
19:04:14 <nolraiWest> Hey can some one look at my hpast.  I'm getting a cannot construct infiniteType type error.
19:04:25 <bd_> ninboy: There is no escaping a monad once you enter it :)
19:04:36 <Botje> nolraiWest: what paste?
19:04:53 <bd_> the IO thing at the end basically means 'this function will do IO'. If you could use it in a function not ending in IO - ie, a function which doesn't do IO, uses a function which does, that wouldn't make sense :)
19:04:57 <ninboy> bd_, that's bads news lol
19:05:00 <Botje> bbx350: is cellular respiration lazy or eager?
19:05:01 <rwbarton> dblazakis: yes
19:05:16 <bd_> ninboy: well, you have two choices - make the function which uses it be in IO as well, or do the IO somewhere else and pass in the results of the IO
19:05:36 <dblazakis> rwbarton: thanks, i always seem to get 4 branches away when reading a sigfpe post
19:06:11 <nolraiWest> Botje: the most recent one on hpaste.
19:06:18 <ninboy> bd_, Yes, I think I'll re-do the function with IOs
19:06:45 <bbx350> botje....what?...lol
19:07:19 <bbx350> Do you mean if it's anaerobic or aerobic?
19:07:46 <rwbarton> bbx350: you know this isn't #biology right?
19:08:15 <bbx350> I like to go into random channels and ask
19:08:34 <rwbarton> bbx350: OK, don't be surprised if you get strange responses :)
19:08:49 <bbx350> Because I don't really know any specific homework help channels/servers/etc
19:08:49 <Botje> bbx350: at least tell us which monad stack you're using :P
19:09:27 <bbx350> can anyone tell me any good homework help channels!
19:09:43 <bbx350> Or just certain topic channels
19:09:51 <bbx350> or servers
19:10:18 <Botje> heh
19:10:22 <Botje> nolraiWest: return (x:xs) is wrong
19:10:26 <Botje> should be just (x:xs)
19:10:38 <Botje> return adds an extra layer of []
19:10:44 <Botje> > return (1:[])
19:10:45 <lambdabot>       No instance for (Show (m [t]))
19:10:46 <lambdabot>        arising from a use of `show' at <...
19:10:49 <bbx350> ahh im leaving lol
19:10:54 <Botje> > return (1:[]) :: [[Int]
19:10:55 <lambdabot>   <no location info>: parse error on input `;'
19:10:59 <Botje> > return (1:[]) :: [[Int]]
19:11:00 <lambdabot>   [[1]]
19:11:01 <Botje> silly \bot
19:13:07 <nolraiWest> Botje: thanks!
19:14:07 <Botje> nolraiWest: i'd write that last bit as x:xs | isOpen x -> ... \n | isClose x -> ... | otherwise -> ...
19:19:31 <ninboy> bd_, Ok, now I have this: http://haskell.pastebin.com/m2e980850
19:19:47 <ninboy> But now it says: ERROR "Controlador.hs":94 - Last generator in do {...} must be an expression
19:20:37 <nolraiWest> Botje: yes thats much nicer.
19:22:28 <ninboy> Each if - then (return) else (return) isn't an expression?
19:22:47 <nolraiWest> They should be.
19:22:53 <rwbarton> ninboy: this code looks fine to me, are you sure this is where the error is coming from?
19:23:31 <ninboy> let me check...
19:25:24 <ninboy> rwbarton, I wasn't ending the do above that one with a return () xD
19:25:32 <ninboy> thanls
19:25:36 <ninboy> thanks*
19:33:24 <lispy> dcoutts_: ping?
19:33:27 <lispy> dons: ping?
19:35:44 <ivanm> lispy: ping?
19:35:47 <ivanm> ;-)
19:39:38 <lispy> dcoutts_: when I runghc Setup.hs build, I get: Setup.hs: darcs: runInteractiveProcess: does not exist (No such file or directory)
19:39:53 <lispy> dcoutts_: but Setup.hs doesn't use runInteractiveProcess
19:40:01 <lispy> dcoutts_: so this is in cabal?
19:41:20 <mmorrow> what's the/is there a flag to get find(1) to search breadth first?
19:41:41 <mmorrow> (it seems like i /always/ want bfs instead of dfs...)
19:42:31 * mmorrow pulls up the haddock to System.Directory...
19:42:51 <yav> lispy: something seems wrong: runInteractiveProcess is a function from System.Process and not a file
19:43:14 <lispy> yav: it's saying 'darcs' is not around
19:43:21 <yav> oh right
19:43:29 <lispy> I think I know how to fix it, it's a problem with autogeneration
19:44:18 <lispy> ?index when
19:44:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:49:25 <lispy> dcoutts_, dons: after tweaking Setup.hs to remove autogeneration and tweaking darcs.cabal to not need pkgconfig I'm now building darcs
19:50:13 <dcoutts> lispy: on windows right?
19:50:44 <sleven> how do i run coq?
19:50:52 <sleven> i apt-got it
19:51:32 <dcoutts> sleven: this isn't really the right channel but I think it's coqtop, check the tutorial
19:58:26 <roconnor> how do I use strictness flags in labeled fields in data declarations?
19:59:36 <ddarius> You put the ! on the type just as always.
20:00:33 <roconnor> ddarius: oh, I needed more brackets
20:05:33 <roconnor> @type curry
20:05:34 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:05:43 <roconnor> @type uncurry
20:05:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:06:48 <ddarius> :t \f -> fmap f . curry id
20:06:49 <lambdabot> forall b a b1. ((a, b1) -> b) -> a -> b1 -> b
20:08:33 <ddarius> As the types suggest, curry f = fmap f . curry id.  Exercise: Prove this.
20:10:46 <roconnor> @free curry
20:10:47 <lambdabot> h . k = p . $map_Pair f g => h . curry k x = curry p (f x) . g
20:11:17 <ddarius> @free curry id
20:11:17 <lambdabot> Extra stuff at end of line
20:13:15 * sw17ch wonders where the cabal executable goes when doing a runhaskell Setup install in the Cabal package
20:13:20 <sw17ch> in windows
20:14:10 <ddarius> (note that the result may not be quite true due to bottoms so ignore them)
20:14:15 <sm> away. It Goes Away.
20:16:02 <BMeph> @free willy
20:16:03 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `willy'\n\n"
20:21:06 <dcoutts> sw17ch: depends if you used --user or --global
20:21:17 <sw17ch> dcoutts, i didn't attach a flag
20:21:24 <dcoutts> sw17ch: and of course the Cabal package doesn't install any executable
20:21:37 <sw17ch> dcoutts, actually, now that i think of it.. that's true
20:21:47 <dcoutts> you're thinking of the cabal-install package which provides the 'cabal' command line program
20:21:47 <sw17ch> how does one get cabal-install working in windows?
20:21:53 <sw17ch> ohhh
20:22:00 <sw17ch> well, yes, that's giving me a hard time
20:22:03 <dcoutts> sw17ch: same way as any other cabalised package
20:22:10 <sw17ch> but i've given up on it for tonight
20:22:25 <dcoutts> sw17ch: where were you getting stuck?
20:22:35 <sw17ch> dcoutts, just chasing dependencies
20:22:40 <dcoutts> sw17ch: right
20:22:42 <sw17ch> it is quite a pain
20:23:09 <dcoutts> I've not been near a windows box for over a month so have not been able to make a binary to make it easier for people
20:23:22 <sw17ch> dcoutts, well, i'll see if i can get this working
20:23:41 <sw17ch> i'm just trying to port some code before i make an initial release of scurry
20:25:17 * BMeph waits for someone to hit sw17ch with the "chicken scurry" line...
20:25:50 * sw17ch isn't familiar with the reference BMeph has made
20:26:14 * ddarius thinks BMeph is just crazy.
20:26:39 * sw17ch notes that scurry supports N clients and emulates a local area network correctly
20:26:49 <Pseudonym> Woo.
20:26:52 <Pseudonym> Excellent.
20:26:52 * sw17ch also notes it lacks any security or efficiency
20:26:56 <sw17ch> =)
20:27:05 <Pseudonym> It's not version 1.0 yet.
20:27:12 <sw17ch> but the amount of effort needed to make it switch correctly is about 5 lines
20:27:20 <sw17ch> after i figure out how to make this last IOCTL call work...
20:31:19 <ivanm> what does one call those functions that are defined in class definitions?
20:31:42 <yav> ivanm: methods?
20:31:57 <ivanm> hmmmm.....
20:33:10 <ivanm> thanks yav! (/me just did a quick google to make sure)
20:36:06 <dblazakis> :t \f -> fmap f . curry id
20:36:07 <lambdabot> forall b a b1. ((a, b1) -> b) -> a -> b1 -> b
20:36:23 <dblazakis> :t \f -> (f .) . curry id
20:36:24 <lambdabot> forall c a a1. ((a1, a) -> c) -> a1 -> a -> c
20:36:27 <thoughtpolice> sw17ch: what is scurry? :]
20:36:43 <sw17ch> thoughtpolice, a VPN build in Haskell
20:36:50 <dblazakis> :t \f x -> f . (curry id x)
20:36:51 <lambdabot> forall c a a1. ((a, a1) -> c) -> a -> a1 -> c
20:36:57 <sw17ch> emulates a Local Area Network much the same way OpenVPN or Hamachi does
20:37:01 <dblazakis> :t \f x y -> f (curry id x y)
20:37:01 <sw17ch> but it's in the spirit of Hamachi
20:37:02 <lambdabot> forall a b t. ((a, b) -> t) -> a -> b -> t
20:37:04 <sw17ch> rather than OpenVPN
20:37:07 <thoughtpolice> hamachi is pretty awesome
20:37:13 <thoughtpolice> we used to LAN with that all the time
20:37:23 <sw17ch> thoughtpolice, i still do :)
20:37:29 <sw17ch> but it bothers me that the source isn't available
20:37:40 <sw17ch> and they *could* zap my networks if they wanted
20:37:48 <dblazakis> :t \f x y -> f (x, y)
20:37:49 <lambdabot> forall t t1 t2. ((t, t1) -> t2) -> t -> t1 -> t2
20:38:06 <dblazakis> :t curry
20:38:07 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:38:08 <sw17ch> thoughtpolice, actually, the first thing i tested was a LAN game. it worked great
20:38:16 <sw17ch> with scurry, that is
20:38:25 <thoughtpolice> nice :]
20:42:16 <dblazakis> :t (,)
20:42:17 <lambdabot> forall a b. a -> b -> (a, b)
20:42:25 <dblazakis> :t curry id
20:42:26 <lambdabot> forall a b. a -> b -> (a, b)
20:42:35 <aluink> i'm looking at hte class def for Show and i find "showsPrec :: Int -> a -> ShowS"
20:43:06 <sw17ch> well, that was easier than i expected ...
20:43:17 <aluink> is showsPrec supposed to return a (String -> String) or is it of type "Int -> a -> String -> String"?
20:44:22 <rwbarton> Yes.  (Those are the same thing)
20:44:42 <aluink> uhh, i don't understand how they are the same
20:44:53 <aluink> one seems to be returning a function and the other is returning a string
20:45:04 <aluink> while the first takes 2 args and the other takes 3
20:45:36 <rwbarton> In Haskell, a function that takes 3 arguments is really a function that takes 2 arguments and then returns a function which takes the third argument.
20:46:03 <aluink> oye...that's gonna take some mind training ;)
20:46:26 <rwbarton> Well, you don't have to worry about it much.
20:48:24 <aluink> i do when i'm trying to understand the example showlist in
20:48:25 <aluink> http://www.zvon.org/other/haskell/Outputprelude/Show_c.html
20:48:33 <lambdabot> Title: Haskell : Show
20:49:47 <roconnor> huh? haddock says:
20:49:48 <roconnor> Warning: Data.Colour.RGBSpace: the following names could not be resolved:
20:49:48 <roconnor>     uncurryRGB curryRGB
20:50:01 <roconnor> why have you failed?
20:50:27 <roconnor> I've done all sorts of crazy import re-export before
20:50:53 <rwbarton> aluink: You could also write  showsPrec _ x s   = show x ++ s  as  showsPrec _ x = (\s -> show x ++ s)
20:52:39 <eck> beginner question... i have this function foo :: a -> IO Bool , and I want to use it with the prelude function `all'
20:52:49 <eck> i tried to do something like: (liftM all) foo
20:53:03 <ddarius> You can't use it with all.
20:53:29 <aluink> rwbarton: yeah, i was testing that idea out just now
20:53:34 <ddarius> You can however easily construct allM in terms of mapM and all, though that would not be the most efficient way.
20:54:00 <eck> why would that not be efficient?
20:54:06 <ddarius> A more efficient approach would be to use foldM.  (Note these are semantically different, not just different performance-wise.)
20:54:25 <ddarius> all stops as soon as a False is returned, whereas mapM will execute all the actions.
20:54:56 <eck> ah, i see
20:55:37 <ddarius> Probably the easiest thing to do would be to make an explicit recursive version.
20:56:07 <roconnor> oh, I forgot the type signatures
20:56:49 <ddarius> (actually mapM and and is what you'd use, mimicing the simple definition of all)
20:58:55 <eck> ddarius, thanks, i ended up going with a recursive version (so it would stop at the first False)
20:59:19 <aluink> @type showl
20:59:20 <lambdabot> Not in scope: `showl'
21:19:01 <Nafai> I'm feeling silly
21:19:09 <Nafai> I'm trying to write a simple rotate function
21:19:22 <Nafai> Take the item at the head of a list and put it at the end
21:19:46 <Nafai> But whatever I try I'm getting type errors, and I'm wondering if this is because of laziness
21:20:06 <shrughes> you're probably using ++ or something
21:20:19 <shrughes> when you need to put the head element into a list (with just the head element)
21:20:27 <shrughes> > [1,2,3] ++ 4
21:20:28 <lambdabot>       No instance for (Num [t])
21:20:28 <lambdabot>        arising from the literal `4' at <inter...
21:20:33 <shrughes> > [1,2,3] ++ [4]
21:20:34 <lambdabot>   [1,2,3,4]
21:21:33 <Nafai> shrughes: Thanks.  I knew it was something obvious :/
21:21:42 <Nafai> That's what I get for trying to code when I'm tired and not feeling well
21:22:30 <dolio> > let swap (a,b) = (b,a) ; rotate n = uncurry (++) . swap . splitAt n in rotate 2 [1..10]
21:22:31 <lambdabot>   [3,4,5,6,7,8,9,10,1,2]
21:26:23 <ddarius> Laziness can't cause type errors.
21:27:05 <BMeph> ddarius: Well, not mechanical laziness... ;)
21:31:53 <sw17ch> yay! scurry is now aware of it's virtual hardware address
21:39:01 <ninboy> Hello everyone again!
21:40:10 <ninboy> I still have problem reading files, can someone help me?
21:40:43 <ninboy> http://haskell.pastebin.com/d4a3eceec I have this code, and hugs give me this error... Is pasted there too
21:43:32 <ninboy> is somebody here?
21:46:43 <dolio> The problem is at the end of the do portion.
21:46:55 <dolio> leerMapa archivo m p (i+1) :: IO Mapa
21:47:03 <dolio> So return (...) :: IO (IO Mapa)
21:47:42 <dolio> And return m :: IO Mapa, so the types mismatch, which isn't allowed in a conditional (both the true and false expressions have to have the same type).
21:48:35 <dolio> Arguably the error should be that the first part doesn't match the type you've declared for it, but those are the breaks.
21:48:49 * sw17ch checks in scurry rev 36 and goes to bed
21:49:11 <ninboy> Ok, thanks!
22:58:21 <roconnor> @pl (\x -> map (x*))
22:58:22 <lambdabot> map . (*)
23:07:01 <alar> @seen dons
23:07:01 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 1h 17m 23s ago.
23:11:23 <Axman6> @src on
23:11:24 <lambdabot> (*) `on` f = \x y -> f x * f y
23:11:37 <Axman6> :t comparing
23:11:38 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:12:07 <Axman6> > comparing `on` length :: Expr
23:12:08 <lambdabot>       Occurs check: cannot construct the infinite type: b = b -> a
23:12:08 <lambdabot>      Proba...
23:12:16 <Axman6> > (comparing `on` length) :: Expr
23:12:17 <lambdabot>       Occurs check: cannot construct the infinite type: b = b -> a
23:12:17 <lambdabot>      Proba...
23:12:31 <Axman6> 2pl (comparing `on` length)
23:12:34 <Axman6> @pl (comparing `on` length)
23:12:34 <lambdabot> comparing `on` length
23:12:42 <Axman6> @unpl (comparing `on` length)
23:12:42 <lambdabot> (on comparing length)
23:12:47 <Axman6> bah
23:12:49 <dibblego> compare `on` length
23:13:34 <dibblego> == comparing length
23:13:52 <pumpkin> anyone done inductive proofs on haskell programs before?
23:14:15 <Axman6> i've seen it done, and possibly did it in an exam
23:27:23 <DX|`NyaR> Very Sry for this message, but it is imperative that you click here: http://www.johnsrevenge.com/?id=85afb4469027c6a58d8db65a8235eece
23:27:23 <lambdabot> Title: johnsrevenge.com
23:27:26 <idnar> @src comparing
23:27:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:27:41 <idnar> hmm, didn't know about that
23:28:33 <pumpkin> DX|`NyaR: fuck off please
23:28:34 <DX|`NyaR> Very Sry for this message, but it is imperative that you click here: http://www.johnsrevenge.com/?id=85afb4469027c6a58d8db65a8235eece
23:28:34 <lambdabot> Title: johnsrevenge.com
23:28:36 <DX|`NyaR> pl
23:28:37 <DX|`NyaR> ok
23:28:38 <DX|`NyaR> i fuckoff
23:28:40 <DX|`NyaR> just click link
23:28:48 <DX|`NyaR> i need 15 more clicks !
23:28:48 <pumpkin> DX|`NyaR: I already told you
23:28:51 <pumpkin> if you google, you'll find the fucking pics
23:28:56 <pumpkin> and you won't have to spam people
23:29:09 <pumpkin> if you really need something like that to get yourself off in the first place
23:29:23 <DX|`NyaR> i am helping this man
23:29:25 <DX|`NyaR> who has been wronged
23:29:29 <DX|`NyaR> by this evil woman
23:29:43 <lament> Doomsday is coming! Repent, repent!
23:29:44 <DX|`NyaR> clearly you do not share feelings of sympathy as youve never been in a similar situation
23:29:46 <pumpkin> DX|`NyaR: it's a porn site
23:29:48 * lament hands out leaflets
23:29:59 <pumpkin> DX|`NyaR: with a viral element trying to make it look real
23:30:12 <DX|`NyaR> I will unlock the secretz of the site
23:30:21 <pumpkin> DX|`NyaR: but if you get past all the spamming, there'll be one of the typical "our models are over 18 thing"
23:30:21 <lament> DX|`NyaR: I'll click that link if you buy this penis enlargement medicine.
23:31:51 <araujo> pumpkin, please, watch your language
23:32:04 <araujo> Cale, dons anyone?
23:32:13 <pumpkin> araujo: he's  joining a variety of channels posting a porn site :P
23:32:20 <pumpkin> sorry for expressing my discontent that way
23:32:26 <araujo> pumpkin, we need an op to ban him
23:32:38 <aeolist> oh his nick is really pumpkin, for a moment i thought something intimate was going on
23:32:38 <pumpkin> yup
23:32:43 <pumpkin> :)
23:32:50 <DX|`NyaR> sorry for hurting your efeelings punkin
23:32:51 <lament> it's strange he's not booted from the server yet
23:32:58 <pumpkin> lol
23:33:03 <pumpkin> I tried in #freenode
23:33:06 <pumpkin> but no one's paying attention
23:33:19 <pumpkin> there he goes
23:36:17 <dolio> @yow!
23:36:18 <lambdabot> Please come home with me ... I have Tylenol!!
