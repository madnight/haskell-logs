00:00:16 <slava> (..+)\1+ or something
00:00:19 <Adamant> ozy`: the ironing of it happening on reddit was also noted.
00:00:24 <roconnor> Tested-with:         GHC == 6.8.2 seems to wrk
00:00:25 <roconnor> work
00:00:44 <dons> yeah, a bit matching thingy. so i guess that's what they're doing
00:01:20 <dons> http://jtauber.com/blog/2007/03/18/python_primality_regex/
00:01:26 <lambdabot> Title: James Tauber : Python Primality Regex
00:01:31 <dons> refers to the source (but site is down for me)
00:01:41 <lament> works for me
00:01:45 <dons> "as pointed out by a commenter on reddit, it's not actually a regular expression"
00:01:49 <dons> hehe.
00:01:53 <ivanm> roconnor: I based my .cabals off xmonad's :p
00:02:01 <dons> pre shark days :) when .ps.gz were on the front page.
00:02:14 <ivanm> hmmm..... is there any reason why most .cabal files are all lower-case?
00:02:17 <ivanm> laziness? :p
00:02:25 <dons> lower case is awesome.
00:03:05 <thoughtpolice> duh
00:03:17 <ivanm> why?
00:03:42 * ivanm can't stand to read blog posts/emails where the author obviously has never learned how to use the shift-key or -- barring that -- caps lock
00:03:56 <dons> the shift key is hard to use, that's true.
00:04:18 <lament> that is so pretty
00:04:22 <slava> reddit sucks these days
00:04:24 <lament> (the regex)
00:05:16 <dons> slava: there's 58k subscribers. changes things.
00:07:22 <lament> what is a backreference?
00:07:48 <slava> dons: did you see doug's blog post?
00:08:01 <ozy`> lament: literally, a reference to a previously matched piece of data
00:08:45 <lament> is that the \1+ part?
00:08:53 <Cale> Grammars with backreferences shouldn't be called regexes.
00:08:57 <ozy`> lament: yep
00:09:30 <Cale> (at least, imo)
00:09:43 <inimino> well, they are ;-)
00:10:21 <inimino> almost everything else is named what it is "for historical reasons" too
00:10:28 <ozy`> Cale: sure, they're not regular expressions anymore once you have stuff like backreferences... but what do you call them?
00:10:46 <Cale> ozy`: Parsing expressions?
00:11:05 <ozy`> Cale: that implies they're CFGs, which is even more inaccurate
00:11:18 <Cale> It does?
00:11:28 <ozy`> at least, to me
00:11:33 <thoughtpolice> slava: link?
00:12:12 <lament> do backreferences make regexes turing-complete?
00:12:19 <roconnor> how come haddock generates ??? a => Eq (Colour a) for my Eq instace documenation?
00:12:36 <lament> doesn't look like it...
00:12:48 <inimino> it's easy enough to tell people that modern regexes are no longer the same as true regular expressions
00:13:01 <slava> thoughtpolice: http://code-factor.blogspot.com/2008/10/introducing-factor-database-library.html
00:13:03 <lambdabot> Title: Doug Coleman's Factor Blog: Introducing the Factor database library, http://tinyurl.com/66cnbr
00:13:25 <inimino> but I'd be surprised if the name didn't stick
00:13:48 <slava> lament: no they do not
00:14:10 <slava> its not clear to me how a parser could be 'turing complete'
00:14:19 <slava> but if you meant 'can parse any grammar', they cnanot either
00:14:24 <slava> you cannot balance parantheses with regexes
00:15:38 <lament> oh no, of course it can't be turing-complete, because it halts
00:16:14 <slava> it doesn't really compute anything
00:16:19 <slava> it just outputs true or false
00:16:29 <lament> nobody would like a parser that would fail to terminate on some inputs
00:16:35 <slava> parser expression grammars are strictly more powerful than regexes even with backrefs
00:16:40 <slava> and they don't always terminate
00:16:47 <Cale> slava: Remember that complexity classes are usually defined in terms of decision problems.
00:17:06 <lament> what's a non-terminating parser?
00:17:40 <Cale> slava: You could turn any complicated output into a bunch of decision problems each of which determine a single bit of that output.
00:17:47 <slava> oh ok
00:17:49 <slava> fair enough
00:19:26 <lament> you can do that with an infinitely iterited s/// command, i think
00:19:35 <lament> *iterated
00:23:18 <tux91> hey guys! does haskell support OOP?
00:23:54 <Cale> tux91: No, not directly.
00:24:12 <tux91> Cale: not directly??
00:24:31 <Cale> tux91: It has many features which effectively replace the various benefits of OOP.
00:24:48 <Cale> and you can design things in an object-oriented way, if you want to.
00:25:04 <Cale> But the language will not specifically help you do that.
00:25:23 <tux91> Cale: but will i have stuff like classes and objects and methods etc..?
00:25:52 <Cale> They're not language concepts, so if you're going to have them, you design them yourself.
00:26:23 <Cale> You can of course, have values which are records consisting of data and functions (functions are first class values and can be used anywhere that other values are)
00:26:30 <roconnor> @hoogle liftM3
00:26:31 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
00:26:44 <tux91> Cale: ok thanks
00:26:56 <vininim> damn, I love (lack of) numeric stability in physics simulation.
00:27:00 <papermachine> I'm guessing he's doing it wrong
00:28:33 <Cale> It bothers me slightly when people come on IRC to ask a question and then leave afterward. I'm used to people who will just go idle and stay in the channel after ;)
00:31:32 <Facedown> Cale - So is it more like ECMAScript which is prototypal and it doesn't use classical inheritance?
00:32:01 <Cale> Facedown: I suppose, if you use it like that.
00:32:22 <Facedown> I've actually never done classical inheritance, only prototypal and love it so far ;)
00:33:02 <rwbarton> Comparing Haskell to ECMAScript is pretty mind-bending
00:33:08 <inimino> it's not quite like either of those, really
00:33:38 <rwbarton> You have to imagine what a statically typed ECMAScript would look like... and it might be sorta kinda like haskell
00:33:49 <Cale> Well, the encoding of OO programming using record types is a bit like that.
00:34:21 <inimino> it would lose its character if it became statically typed
00:36:30 <rwbarton> So I'm trying to write a program to take a type and expand all the type aliases and newtypes in it.
00:36:53 <rwbarton> Deciding whether this process will terminate is the same as deciding termination in the lambda calculus and thus uncomputable, right?
00:37:15 <roconnor> No instance for (Arbitrary Word8)
00:37:20 <Cale> With respect to newtypes, perhaps.
00:37:20 <roconnor> how sad
00:37:24 <rwbarton> Right.
00:37:31 <rwbarton> Type aliases are fine
00:37:49 <rwbarton> I'd like to output something helpful if I can detect a loop, though.
00:38:00 <Cale> actually, I'm not sure if it's undecidable...
00:38:12 <Cale> After all, isn't that kind of what the occurs check is doing?
00:38:46 * BMeph htinks a statically-typed ECMAScript would be kinda sorta more like Erlang
00:39:12 <rwbarton> Hmm, possibly.
00:39:32 <Cale> I think the occurs check might be overzealous in what it excludes though.
00:39:39 <rwbarton> But I also have non-regular recursion to deal with, and I don't see how what that corresponds to in the occurs check
00:39:47 <Cale> Or it's possible I'm just not thinking clearly.
00:40:18 <rwbarton> Well, I have the simply-typed lambda calculus plus fix :: (* -> *) -> *
00:40:21 <BMeph> Heh-heh, 'data Natural  = Maybe Natural' :)
00:40:45 <rwbarton> Can't I write programs in that?
00:43:54 <BMeph> rwbarton: Well, you could write programs in Lisp, but a real friend would stop you befoe you went too far. ;)
00:45:24 <rwbarton> Right, the point is I can't always detect termination then
00:46:50 <ozy`> hmm, that reminds me
00:48:17 <ozy`> what's the best approach to a program that will expand CFGs, aborting if it detects recursion?
00:52:45 <ozy`> I mean, I know that's crazy
00:57:29 <jre2> can anyone here recommend the rjson vs. json libraries
00:59:04 <inimino> whoah, hackage looks different
00:59:50 <ozy`> inimino: new haircut
01:00:47 <inimino> ozy`: I like it
01:01:10 <Cale> It does?
01:01:33 <inimino> jre2: I've used json, it works but I found it slightly unwieldy
01:01:56 <inimino> Cale: modules are listed as a tree
01:03:07 <Cale> inimino: ah, yeah, I did notice that come to think of it :)
01:03:14 <jre2> inimino: yeah, I've inherited a codebase that uses json, and it looks rather ugly. On the other hand, it works while code generation can be buggy/tricky
01:03:18 <dons> inimino: yeah, the string overloading is not entirely satisfactory
01:03:37 <rwbarton> jre2: the advantage of rjson is that you don't have to do much work to serialize your custom data types
01:03:40 <dons> jre2: i've used json for a bunch of things
01:03:49 <rwbarton> jre2: the advantage of json is that you can yell at dons if it breaks :)
01:03:56 <dons> indeed.
01:04:24 <rwbarton> jre2: I'm working on a package to automatically derive instances for the json library, though it won't be very flexible
01:04:30 <dons> it's only just mildly past haskell98 too
01:04:40 <dons> rwbarton: using something like data.binary's 'deriving' tool?
01:04:46 <jre2> rwbarton: how will it differ from rjson?
01:04:50 <rwbarton> dons: Using Data.Derive
01:04:57 * dons likes deriving preprocessors
01:05:02 <rwbarton> jre2: It will use Template Haskell rather than SYB-with-class
01:05:18 <rwbarton> jre2: (SYB-with-class is ingenious, but also ingeniously complicated)
01:05:41 <jre2> I noticed
01:05:44 <mjg> hi -  I got a function (f :: Integer -> Integer) "f n = floor (sqrt n)" - why doesn't it work?
01:05:52 <rwbarton> dons: I think Data.Derive lets you either run a preprocessor or splice in an instance declaration with TH.  I've only used the latter
01:06:22 <rwbarton> jre2: Actually, my code basically exists already, it's only the documentation and packaging that's to be completed
01:06:35 <dons> mjg, sqrt works only on floating point values
01:06:44 <dons> :t sqrt
01:06:45 <lambdabot> forall a. (Floating a) => a -> a
01:06:49 <dons> ?instances Floating
01:06:50 <lambdabot> Double, Float
01:06:51 <jre2> rwbarton: any eta on when it'd be ready?
01:07:57 <rwbarton> jre2: I can put it on github now and if you're interested in using it I can try to get it on hackage soon
01:08:01 <inimino> mjg: try f n = floor (sqrt (fromIntegral n))
01:08:24 <inimino> :t floor
01:08:25 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
01:08:41 <jre2> rwbarton: I wouldn't mind trying it out
01:08:43 <mjg> thanks dons, inimino
01:12:37 <rwbarton> jre2: OK, check out git://github.com/rwbarton/json-derive.git
01:15:29 <rwbarton> jre2: Feel free to email me (my address is in the author field) with questions or comments
01:25:29 <thoughtpolice> rwbarton: yeah with derive you can use a preprocessor, but using TH is a lot nicer if you also want e.g. cabal
01:30:40 <Adamant> http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
01:30:42 <lambdabot> Title: A is 3QD
01:31:21 <Adamant> Miranda vs. Scheme comparison from Wadler and back in the day
01:33:17 <jre2> rwbarton: you there?
01:33:38 <Adamant> jesus, that must be a direct scan. trying to read it is incredibly slow on the refresh
01:36:32 <mmorrow> dons: what are your thoughts on the Binary instance Data.Derive derives for a datatype (here, the TH AST types): http://moonpatio.com/repos/DERIVED/THBinary.hs.html ?
01:36:33 <lambdabot> Title: Haskell code
01:37:05 <dons> not bad
01:37:23 <mmorrow> cool. so nothing you'd change or optimize or .. ?
01:37:37 <dons> well,
01:37:38 <dons> instance Binary Name where put (Name x1 x2) = return () >> (put x1 >> put x2)
01:37:41 <dons> is a bit weird.
01:37:46 * mmorrow looks
01:37:54 <dons> but compare with the derive script that comes with Data.Binary
01:37:58 <dons> it does the "expected" job
01:38:21 <mmorrow> yeah, totally. it could be a little smarter
01:39:04 <dons> http://hpaste.org/11281
01:39:12 <dons> DrIFT also derives binary
01:39:15 <mmorrow> so that's the "standard strategy" for binary instances then? are there any "alternate strategies" for encoding a datatype
01:39:27 <mmorrow> ooh, yeah i've been meaning to look at DrIFT's code
01:39:30 <dons> probably :)
01:39:55 <dons> there's only so many ways to break down sums and products into bits
01:39:56 <mmorrow> cool
01:40:41 <mmorrow> what about for encoding say a Map or [] so that you don't need to read the entire thing before you get any results
01:41:07 <dons> yeah, laziness is one thing you get to make decisions about
01:41:18 <dons> as well as endianness for atomic opaque things
01:41:21 <Saizan> mmorrow: see ndm's deferredbinary
01:41:30 <mmorrow> ah,
01:41:36 * mmorrow derives some samples of that
01:44:21 <mmorrow> http://moonpatio.com/repos/DERIVED/THBinaryDefer.hs.html
01:44:22 <lambdabot> Title: Haskell code
01:44:52 <mmorrow> interesting
01:46:49 <mmorrow> here's a massive file showing most of the instances Data.Derive does (here on the TH AST types) http://moonpatio.com/repos/DERIVED/THDerived.hs.html
01:46:50 <lambdabot> Title: Haskell code
01:49:15 <jsn> can an ondisk, single-threaded data structure be treated as "pure" even though lookup and insertion involves IO ?
01:50:04 <jsn> well, i guess i can treat it sort of like a DiffArray
01:51:31 <mmorrow> just make sure you really are writing to disk when you want to be if you use unsafePerformIO
01:52:01 <jsn> oh yes, eeek
01:52:11 <jsn> it is append only
01:52:19 <jsn> this data structure
01:52:47 <mmorrow> hmm, is it some sort of log or something?
01:52:51 <jsn> yes, exactly
01:53:31 <mmorrow> there're a few loggin packages which may or may not be what you want, but at the least might give you ideas
01:53:40 <mmorrow> ?hackage hlogger
01:53:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlogger
01:53:43 <mmorrow> and
01:53:56 <jsn> well, i was more interested in the theory, at this point
01:54:07 <mmorrow> http://repetae.net/recent/out/ErrorLog.html
01:54:13 <lambdabot> Title: ErrorLog
01:54:20 <jsn> the log is rather specialized -- a log of changesets -- so i expect to roll my own
01:55:10 <mmorrow> jsn: oh i gotcha. i'd just test out various ways to do it (including unsafePerformIO if that does what you want), then see which ones work i guess
01:55:10 <jsn> i suppose it's just as well if i put the log in IO
01:55:34 <mmorrow> jsn: yeah, it seems like you'd want to
01:56:08 <jsn> the pure operations are really on the revision graph constructed from the log, and not the log itself
01:56:14 <mmorrow> then you could have one thread that writes to disk and sits on a Chan, then give that chan out to whoever needs logging abilities
01:57:32 <jsn> well, there needs to be some kind of log handle
01:57:51 <jsn> because clients need to be able to check with the log allocate a fresh revision number and such
01:58:18 <jsn> (hence my decision to roll my own in this case)
01:58:51 <jsn> so really, it's more of a disk-backed, append only DAG
01:59:03 <mmorrow> jsn: could they request a new num from the logger thread who then deals with the log, instead of accessing the log individually?
01:59:29 <jsn> yeah, that seem reasonable, but how would that actually work? i would use haskell message passing?
01:59:48 <mmorrow> ah yeah, so a Chan will be perfect
01:59:53 <jsn> ah
02:00:00 <jsn> thanks for pointing me in that direction
02:00:15 <mmorrow> and MVars for mutexes
02:00:31 <jsn> MVars are atomic, right?
02:01:16 <mmorrow> so an MVar can either be empty or full, and if you takeMVar on an empty one, you'll block (sleep) until it gets filled
02:01:28 <jsn> ah, got it, okay
02:01:34 <mmorrow> if you putMVar on a full one, you'll block until it's empty
02:01:56 <mmorrow> and threads queue up fifo order blocking on a single MVar
02:01:58 <jsn> and no two processes can simultaneously put and succeed
02:02:03 <jsn> right
02:02:03 <mmorrow> exactly
02:03:04 <jsn> to be honest, that is much better than hiding all this stuff behind unsafePerformIO
02:03:11 <mmorrow> totally :)
02:03:48 <mmorrow> but there are times when unsafePerformIO is the only way to do something
02:04:24 <jsn> for example, if you have a huge chinese dictionary as a C array and want you look ups into it to be pure...
02:04:25 <Saizan> using Writer to accumulate the log can be nice too
02:04:48 <mmorrow> Saizan: it's on disk though apparently
02:04:55 <jsn> yes
02:05:04 <jsn> it is going to be a really huge log
02:05:17 <jsn> or DAG, really
02:05:27 <jsn> so, there is a DAG of changes
02:05:42 <jsn> and you may add to the DAG -- adding branches or even shortcuts
02:05:55 <mmorrow> hmm, interesting
02:05:58 <jsn> you may not rewrite the contents of log entries, though
02:06:51 <jsn> i suppose you should be allows to "clip" the log, though -- so you must be able to delete log entries (and it's better if this is in band, don't want to have to restart to do it)
02:07:08 <mmorrow> don't know if this fits in anywhere or is useful for what you're doing, but there's a bytestring-mmap package also
02:07:14 <mmorrow> ?hackage bytestring-mmap
02:07:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap
02:07:43 <mmorrow> (i think it's *nix only?)
02:08:49 <jsn> MMAP will probably be important, since I've got to walk the graph while it's on disk (when it is really big)
02:09:16 <jsn> but i can also ignore that at present
02:09:42 <mmorrow> and if you have to do a lot of seeking on a Handle/Fd, maybe someone else can give you some advice on the best module/package to use for that since i'm not really sure
02:10:30 <mmorrow> System.Posix.IO lets you get at Fd's
02:10:54 <mmorrow> and you can always use the FFI to wrap C functions super easy
02:36:37 <luqui> are there some typical patterns in FP used to factor out the need for unique identifiers?
02:40:32 <mopped> @src break
02:40:32 <lambdabot> break p =  span (not . p)
02:41:01 <Saizan> luqui: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Supply.html
02:41:11 <lambdabot> Title: Control.Comonad.Supply, http://tinyurl.com/5suy6f
02:41:24 <Saizan> luqui: or you could just pass an infinite list of identifiers around
02:41:56 <luqui> Saizan, no, I don't mean using unique identifiers, I mean getting rid of the need for them
02:42:13 <Saizan> oh, i see
02:42:32 <luqui> uh, here's a specific example
02:43:16 <luqui> let's say I'm doing a EDSL thing.    you define foo = ...;
02:43:35 <luqui> I want to, say, associate a memory address with foo, and have it be the same at all uses
02:43:47 <luqui> which looks like it would violate ref trans.
02:44:08 <Saizan> hah, i've the same need, more or less :)
02:44:13 <luqui> (or require comparing ASTs, which in my case can't be done)
02:44:39 <luqui> I know there was some oleg thingy that did something like this...
02:44:46 <luqui> maybe something like it.  my memory is fuzzy
02:44:59 <Saizan> this is for transparent caching?
02:45:15 <luqui> okay, I guess you could call it that.
02:45:33 <luqui> (it's a bit more involved than canonical examples, but it amounts the same thing I think)
02:51:33 <luqui> GAAH  I can't find it for the life of me!
02:53:26 <Saizan> http://okmij.org/ftp/Computation/Generative.html#staged-monad ?
02:53:31 <lambdabot> Title: Generative Programming
02:53:43 <Saizan> i've never read it, but it looks somewhat relevant
02:54:21 <luqui> I think that is the one I recall.  thanks :-)
02:54:35 <luqui> oh it's not available?
02:55:20 <Saizan> the link to the paper works for fe
02:55:37 <Saizan> "me"
02:56:02 * luqui is an idiot
03:16:30 <krokodil> Hi, is Bonus here? I'm reading his tutorial
03:17:12 <mauke> preflex: seen BONUS
03:17:13 <preflex>  BONUS was last seen on #haskell 17 hours, 55 minutes and 7 seconds ago, saying: hmm
03:17:32 <krokodil> thanks hehe
03:17:48 <TSC> krokodil: What do you think of the tutorial?
03:18:28 <krokodil> TSC, I'm liking it so far but I'm only in the first chapter. Previously I watched a Simon Peyton-Jones video but didn't really get it
03:19:11 <krokodil> well, I'm liking it in the sense that it whets my appetite :)
03:19:41 <Cale> krokodil: If you have any questions, be sure to ask :)
03:20:17 <Cale> Hehe, look at that, you say BONUS' name and he joins the channel :)
03:20:18 <krokodil> yep sure :)
03:21:00 <krokodil> ah, bonus! hi. I just wanted to tell you about a typo, you write "sorround" everywhere but it's spelled surround
03:21:32 <Gilly> I'm wondering how strict the languages can become before it starts to be too heavy for the programmer... thinking about dependent types or requiring termination for example...
03:21:33 <mauke> perl -pi -e 's/sorround/surround/g' *
03:22:37 <ozy`> @pl (\x -> x * x <= 12)
03:22:38 <lambdabot> (<= 12) . join (*)
03:22:52 <ozy`> @src join
03:22:52 <lambdabot> join x =  x >>= id
03:22:54 <mopped> What's the difference between isInfixOf and elem?
03:23:06 <mauke> :t elem
03:23:07 <ozy`> @src isInfixOf
03:23:07 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
03:23:07 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:23:11 <mauke> :t isInfixOf
03:23:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
03:23:15 <mauke> :t elem
03:23:16 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
03:23:19 <luqui> the type says it all :-)
03:23:38 <mopped> aha
03:23:49 <mopped> Is there an overloaded function that does both?
03:23:54 <luqui> > ("foo" `isInfixOf` "my foot", 'f' `elem` "my foot")
03:23:55 <lambdabot>   (True,True)
03:24:00 <mauke> I hope not
03:24:16 <luqui> mopped, overloaded?  you mean using a type class?
03:24:32 <luqui> haskell folks don't do overloading like that.
03:24:42 <luqui> we prefer our overloading to be meaningful, rather than just reusing names
03:24:44 <mopped> I don't know what type classes are, I'm just guessing a function that uses elem/isInfixOf depending on the input
03:24:47 <mopped> ok
03:24:59 <mauke> why? they're different operations
03:25:21 <mopped> arnt they both just testing if a is in b?
03:25:34 <mauke> depends on your definition of "is in"
03:25:38 <luqui> yeah, they have the same meaning on the surface.  look deeper, and they have different meaning.
03:25:57 <C-Keen> :t Data.Map
03:25:58 <lambdabot> Couldn't find qualified module.
03:26:03 <C-Keen> :t Data.Hashtable
03:26:03 <ozy`> @pl partFor m l@(q:qs) = (map (q:) $ filter (not . null) $ partFor (m - q) l) ++ partFor m qs
03:26:04 <lambdabot> (line 1, column 20):
03:26:04 <lambdabot> unexpected "="
03:26:04 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
03:26:04 <lambdabot> Couldn't find qualified module.
03:26:09 <mopped> elem checks for an element, and isinfixof checks for subsets?
03:26:10 <ozy`> whoops
03:26:13 <mauke> you could also say "lqi" is in "luqui"
03:26:22 <mauke> no, isInfixOf checks for substrings
03:26:28 <C-Keen> what's the difference between a Data.Map and a Data.Hashtable?
03:26:37 <luqui> > "foo" `isInfixOf` "follow"
03:26:38 <lambdabot>   False
03:26:40 <mauke> C-Keen: a Map is a balanced binary tree
03:26:46 <mopped> aha
03:26:48 <mauke> C-Keen: and it has a pure interface
03:27:11 <luqui> subset is a reasonably hard thing to check for  (not terribly, but not linear like isInfixOf)
03:27:18 <C-Keen> mauke: but my keys need to be a member of Ord a as a result right?
03:27:24 <mauke> C-Keen: yes
03:27:29 <luqui> > Set.fromList "foo" `Set.subset` Set.fromList "follow"
03:27:30 <lambdabot>       Failed to load interface for `Set':
03:27:30 <lambdabot>        Use -v to see a list of the ...
03:27:42 <luqui> > Data.Set.fromList "foo" `Data.Set.subset` Data.Set.fromList "follow"
03:27:43 <lambdabot>   Not in scope: `Data.Set.subset'
03:27:49 <luqui> daft!
03:28:00 <mauke> > null ("foo" \\ "follow")
03:28:01 <lambdabot>   True
03:28:16 <luqui> ah nice.
03:28:33 <luqui> not subbag like I was thinking, but Set didn't do that anyway
03:29:43 <ozy`> :t join
03:29:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:30:20 <luqui> :t join :: (r -> r -> a) -> (r -> a)
03:30:20 <lambdabot> forall r a. (r -> r -> a) -> r -> a
03:31:07 <mauke> :t flip ap id
03:31:08 <lambdabot> forall b a. (a -> a -> b) -> a -> b
03:31:28 <mauke> :t flip (>>=) id
03:31:29 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
03:31:38 <ozy`> @pl join
03:31:38 <lambdabot> join
03:31:43 <ozy`> @unpl join
03:31:43 <lambdabot> (\ b -> b >>= \ a -> a)
03:32:16 <luqui> gee thanks lambdabot =P
03:32:30 <luqui> join f x = f x x
03:32:50 <cjs> @seen dcoutts
03:32:50 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #haskell and #ghc. I last heard dcoutts speak 9h 58m 33s ago.
03:34:33 <ivanm> cjs: now to see if lambdabot's magical spell of summoning works! :p
03:34:43 <cjs> Hee hee.
03:34:43 <lambdabot> cjs: You have 1 new message. '/msg lambdabot @messages' to read it.
03:43:20 <xenoblitz> guys is there a place where i can find a list of good WORKING up-to-date GUI/Graphics haskell libraries?
03:45:48 <mopped> @src (++)
03:45:49 <lambdabot> []     ++ ys = ys
03:45:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
03:45:49 <lambdabot> -- OR
03:45:49 <lambdabot> xs ++ ys = foldr (:) ys xs
03:52:39 <mopped> @src reverse
03:52:40 <lambdabot> reverse = foldl (flip (:)) []
03:53:51 <Taejo> @pl comb a b (c, d) e = (a c e, b d e)
03:53:51 <lambdabot> comb = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . liftM2 (,)) .)
03:55:32 <mopped> should one refrain from measuring lists length incase the list is infinite?
03:55:48 <Taejo> mopped: if the list might be infinite, certainly
03:56:11 <Taejo> mopped: but even if they aren't, length is not very efficient
03:56:16 <mopped> hmm
03:56:31 <mopped> could you explain how let x = [1..10] in zipWith const x (drop 3 x) works?
03:56:46 <mopped> I can use that to bypass my use of length (in writing myReverse)
03:56:59 <mauke> do you know how zipWith works?
03:57:30 <mopped> iirc, it takes a function and two lists, then it does f x y?
03:57:35 <lispy> agda style function definitons are kinda cool.  You can use _ as a place holder for parameters.  So instead of (.) in haskell you could define, _o_ :: (b -> c) -> (a -> b) -> a -> c, and then you can use it as f o g
03:57:41 <mauke> yeah, walking the lists in parallel
03:57:51 <mauke> and it stops as soon as one list runs out of elements
03:58:08 <thoughtpolice> i should take a look at agda one of these days
03:58:10 <thoughtpolice> seems neat
03:58:22 <mauke> > zipWith f [1 ..] [a,b,c,d,e]
03:58:23 <lambdabot>   Add a type signature
03:58:26 <lispy> thoughtpolice: http://www.cs.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf
03:58:29 <mauke> > zipWith f [1 ..] [a,b,c,d,e] :: [Expr]
03:58:31 <lambdabot>   [f 1 a,f 2 b,f 3 c,f 4 d,f 5 e]
03:58:33 <lambdabot> Title: Dependently Typed Programming in Agda, http://tinyurl.com/6xshnb
03:58:33 <mopped> what does const do?
03:58:33 <thoughtpolice> lispy: ty
03:58:39 <mauke> @src const
03:58:39 <lambdabot> const x _ = x
03:58:40 <lispy> thetallguy: very gentle intro
03:58:47 <mauke> > const 42 ()
03:58:48 <lambdabot>   42
03:58:52 <mauke> > const 42 "whatever"
03:58:54 <lambdabot>   42
03:59:08 <Taejo> :t let {f :: a -> b -> a; g :: c -> b -> c} in (&&&) . (uncurry $ f *** g)
03:59:09 <lambdabot>     Misplaced type signature: f :: a -> b -> a
03:59:10 <lambdabot>     You cannot give a type signature for an imported value
03:59:10 <lambdabot>     Misplaced type signature: g :: c -> b -> c
03:59:15 <mauke> > zipWith const [1 ..] [a,b,c,d,e] :: [Expr]
03:59:17 <lambdabot>   [1,2,3,4,5]
03:59:33 <mopped> ah i see
03:59:35 <mauke> it always returns its first argument
03:59:36 <mopped> that's neat :)
04:00:00 <bd_> > const 42 (1 / 0)
04:00:01 <lambdabot>   42
04:00:06 <bd_> without evaluating the second :)
04:00:36 <lispy> thetallguy: although it's not all pretty
04:00:39 <lispy> oops
04:00:45 <mauke> flip const == const id
04:00:46 <lispy> thoughtpolice: I meantto say that to you :)
04:00:47 <lispy> _
04:00:47 <lispy> ◦_ : {A : Set}{B : A -> Set}{C : (x : A) -> B x -> Set}
04:00:47 <lispy> (f : {x : A}(y : B x) -> C x y)(g : (x : A) -> B x)
04:00:47 <lispy> (x : A) -> C x (g x)
04:00:49 <lispy> (f
04:00:52 <lispy> ◦ g) x = f (g x)
04:00:56 <lispy> gah, that didn't paste right
04:01:11 <lispy> but, more or less, that's the type of function composition in agda
04:01:25 <thoughtpolice> lispy: yeah so i've seen
04:04:04 <Taejo> can quickcheck generate random functions?
04:04:18 <mopped> http://hpaste.org/11283#a1 can anyone explain why i'm getting that error? :P
04:04:37 <mauke> @check \f -> f False == f True
04:04:38 <lambdabot>       Overlapping instances for Show (Bool -> a)
04:04:38 <lambdabot>        arising from a use of...
04:05:00 <mauke> @check \f -> (f :: Bool -> Bool) False == f True
04:05:01 <lambdabot>       Overlapping instances for Show (Bool -> Bool)
04:05:01 <lambdabot>        arising from a use...
04:05:04 <mauke> :(
04:05:31 <mauke> mopped:  tail l :
04:05:34 <Taejo> mopped: what is the type of (tail l)?
04:05:37 <mauke> that can't be right
04:06:34 <mopped> doh
04:06:35 <mopped> i meant last
04:06:44 <lispy> it's crazy that in agda you can define if as, if_then_else_, and use it as function.  That seems like you could accidentally obfuscate code :)
04:07:59 <mauke> I just accidentally the whole codebase, is this bad?
04:08:18 <pandamine> does anyone know if kernels are compiled with ICONFIG_INOTIFY to true by default?
04:10:48 <lispy> mauke: accidentally what?
04:11:01 * EvilTerran sees what mauke did thar
04:11:04 <mauke> the whole codebase
04:11:48 <LarstiQ> BONUS: in case it is not reported yet, on http://learnyouahaskell.com/starting-out [ x*y | x <- [2,5,10], y <- [8,10,11], x*y < 50] should be > 50 to match the text and output
04:11:51 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
04:11:57 <vininim> lol
04:15:50 * lispy doesn't get mauke's joke
04:16:51 <mauke> lispy: http://macrochan.org/search.py?tag=Neutral%3AI%20accidentally%20the%20whole%20X
04:16:57 <lambdabot> Title: Macrochan, http://tinyurl.com/5r3c6x
04:18:57 <lispy> mauke: hahah, okay.  That's awesome.
04:19:06 * lispy is still laughing
04:21:25 <luqui> now that more people are awake, maybe I can ask again.   Are there FP patterns for eliminating the need for unique identifiers?
04:21:51 <EvilTerran> identifiers as in names, or as in values, or what?
04:22:12 <luqui> the case I'm thinking of, you're building and AST in an EDSL, and you want sharing in the source to carry over to sharing in the AST
04:23:09 <luqui> i.e. so let x = node 1 `plus` node 1 ; y = x `plus` x ; z = y `plus` y ; ...    should not result in gigantic huge awful generated code
04:23:50 <rog> i'm trying to do something that i think is similar to what HList does, and i couldn't get it to work, so i thought i'd try with some code from the HList paper. oleg says he gets by with just multi-param classes and fn-deps, but the code (http://hpaste.org/11284#a0) seems to require undecidable instances. what am i doing wrong?
04:24:01 <luqui> Obviously that code itself is not possible because of RT (it's equationally the same as a huge awful program), but something very close to it?
04:24:08 <EvilTerran> make the AST a Map Node (Set Node) for some appropriate Node type?
04:24:48 <luqui> I don't really follow...
04:24:59 <EvilTerran> er, that's not what i meant
04:25:03 <scook0> luqui: I seem to recall some kind of olegian paper or such on that topic
04:25:11 <scook0> but I can't remember any of the details, sadly
04:25:37 <EvilTerran> i mean, you could have a Map from some indexing type to your actual AST node type
04:25:44 <luqui> scook0, I definitely recall an olegian paper on that topic. and cannot find it.  or there is one about metaocaml and staging, but I recall a different one
04:26:02 <luqui> EvilTerran, would that not be a unique identifier, what I am trying to eliminate? ;-)
04:26:07 <EvilTerran> ah, i see
04:27:00 <vixey> luqui: You know HOAS?
04:27:05 <luqui> vixey, no
04:27:13 <vixey> ?where moonpaste
04:27:14 <lambdabot> I know nothing about moonpaste.
04:27:16 <vixey> ugh
04:27:18 <vixey> lambdabot--
04:27:28 <vixey> so example,
04:28:23 <scook0> pretty sure it was in a haskell context, but my google-fu fails me
04:28:51 <luqui> scook0, I would be impressed if it did not.  I have been looking for about an hour.
04:29:07 <scook0> fair enough :)
04:29:50 <vixey> data HTerm = HLam (HTerm -> HTerm) | HApp HTerm HTerm
04:30:05 <rog> my own code is at http://hpaste.org/11284#a1; it gets a similar error. do i need allow-undecidable-instances? that sounds  potentially dangerous.
04:30:10 <luqui> vixey, yep :-)
04:30:13 <vixey> eval (HLam body) = HLam body
04:30:13 <vixey> eval (HApp p q) = eval (eval p * q)
04:30:29 <Taejo> is it possible to create one's own derivable classes (using TH, SYB, or something)?
04:30:30 <luqui> well kindof.
04:30:34 <vixey> HLam body * term = body term
04:30:44 <luqui> Taejo, see Data.Derive for one
04:30:48 <scook0> luqui: "Designing DSL with explicit sharing" on haskell-cafe?
04:30:57 <scook0> seems to be what I was thinking of
04:31:06 <vixey> you use the metalanguage binders to represent your own
04:31:43 <vixey> no need to gensym at all
04:31:54 <vixey> but if you want to check equality modulo alpha conversion,,
04:32:01 <vixey> you must convert to de bruijn terms
04:32:18 <luqui> scook0, me too!  thanks!
04:32:27 <scook0> glad to help
04:33:02 <vixey> so,, data DeBruijn freeVars where Var :: BDeBruijn (Maybe a) | BLam :: DeBruijn (Maybe a) -> DeBruijn a | BApp :: DeBruijn a -> DeBruijn a -> DeBruijn a
04:33:13 <vixey> & this rep. also needs to gensymming
04:33:23 <luqui> vixey, my structure is more deeply embedded in haskell than that, unfortunately
04:33:32 <luqui> I do not have the luxury to see a variable :-)
04:34:03 <vixey> what do you mean?
04:34:10 <luqui> oh nice, that's a pretty clever encoding
04:34:11 <vixey> oops
04:34:14 <luite_> is there a standard function to parse a floating point number in a parsec char parser?
04:34:25 <vixey> Var :: DeBruijn a -> DeBruijn (Maybe a)
04:34:29 <luqui> vixey, I mean real haskell functions get to be a part of my data structure
04:34:56 <vixey> you can convert from HOAS <=> DeBruijn by recursion
04:34:57 <luqui> not just functions from Term -> Term, but functions a -> b...
04:35:06 <Deewiant> luqui: Parsec.Token.float?
04:35:19 <vixey> these thinsg from a -> b aren't syntactic binders though?
04:35:20 <Deewiant> er
04:35:21 <Deewiant> luite_: ^
04:35:24 <luqui> luite_, Deewiant meant to talk to you
04:35:32 <vixey> just black box computations right?
04:35:37 <luqui> righ
04:35:38 <luqui> t
04:36:06 <vixey> I don't know any other representations that those two which don't require gensymming though
04:36:17 <luite_> Deewiant: ah, I thought you needed another type of parser for that
04:36:36 <luqui> that's understandable.  it's possible that there exists an implementation with gensymming, but my guess is that there's no "generic" technique
04:36:49 <luqui> that I have to look really really deeply into what I'm doing to find it
04:37:09 <vixey> sorry, an implementations of what without gensyms?
04:37:35 <vixey> what are you doing beyond just representing syntax
04:37:52 <scook0> luite_: if you don't want to mess around with the TokenParser stuff you could just peek in the source code, see how they implement float, and copy that
04:39:49 <luqui> vixey, I'm representing functions which can be more efficiently calculated if all the points at which they are evaluated are known together.
04:40:10 <nicknull> ? hoogle unfold
04:40:16 <nicknull> ?hoogle unfold
04:40:17 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
04:40:17 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
04:40:17 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
04:40:18 <luqui> i.e.  it is more efficient to calculate [a] -> [b] than a -> b
04:40:32 <vixey> I see
04:40:45 <nicknull> where is unfold?
04:40:49 <vixey> a^n -> b^n :))
04:40:56 <mauke> nicknull: there is no unfold
04:41:19 <nicknull> mmorrow coded : (unfold chunk inp)
04:41:20 <luqui> there's a big attribute grammar solution I've got, but it's littered with unique identifiers, and I find that ugly (also probably inefficient compared to this vacuous better way :-)
04:41:21 <scook0> Data.List.unfoldr
04:41:41 <luqui> vixey, ah yes.  I've been in haskell mode for too long, got to start thinking dependently again :-)
04:41:44 <vixey> attribute grammars, great!
04:41:53 <scook0> @src unfoldr
04:41:53 <lambdabot> unfoldr f b  = case f b of
04:41:53 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:41:53 <lambdabot>    Nothing        -> []
04:43:43 <RayNbow> hmm, are there any example use cases of scanr?
04:43:56 <vixey> :t scanr
04:43:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
04:43:57 <RayNbow> I can see the use of scanl...
04:44:09 <RayNbow> but I cannot think of an example when you want to use scanr
04:44:11 <vixey> > scanr (flip (:)) [] "foobar"
04:44:12 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
04:44:12 <lambdabot>        Expect...
04:44:19 <vixey> > scanr ((:) [] "foobar"
04:44:19 <vixey> > scanr (:) [] "foobar"
04:44:20 <lambdabot>   <no location info>: parse error on input `;'
04:44:21 <lambdabot>   ["foobar","oobar","obar","bar","ar","r",""]
04:44:31 <vixey> hm.....
04:45:09 <vixey> > scanr (const ((1+).(1/))) 1 "foobar"
04:45:10 <lambdabot>   [1.6153846153846154,1.625,1.6,1.6666666666666665,1.5,2.0,1.0]
04:45:20 <vixey> idk it seems useless
04:45:28 <vixey> it probably only exists for completeness
04:45:43 <RayNbow> > scanr (+) 0 [1..]
04:45:45 <lambdabot>   [* Exception: stack overflow
04:45:51 <RayNbow> > scanl (+) 0 [1..]
04:45:52 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
04:46:38 <luqui> > tails "foobar"
04:46:39 <lambdabot>   ["foobar","oobar","obar","bar","ar","r",""]
04:47:15 <luqui> > tails (cycle "foobar")
04:47:16 <lambdabot>   ["foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf...
04:47:20 <Deewiant> > scanr f z [a,b,c]
04:47:21 <lambdabot>   [f a (f b (f c z)),f b (f c z),f c z,z]
04:47:31 <luqui> > scanr (:) [] (cycle "foobar")
04:47:32 <lambdabot>   ["foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarf...
04:47:45 <scook0> > scanr (\x xs -> x:'!':xs) [] "foo"
04:47:46 <lambdabot>   ["f!o!o!","o!o!","o!",""]
04:48:17 <Deewiant> > scanl (\xs x -> x:'!':xs) [] "oof"
04:48:19 <lambdabot>   ["","o!","o!o!","f!o!o!"]
04:50:10 <luqui> > map ($ 0) $ scanr (.) id (map (+) [1..10])
04:50:11 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
04:58:35 <nicknull> is there seriously no way to just close a readFile?
04:58:44 <mauke> no
04:59:29 <nicknull> http://hpaste.org/11276
04:59:35 <nicknull> seems a bit much for something so simple
04:59:46 <nicknull> System.IO.Strict
04:59:50 <nicknull> i cant import
05:00:20 <ac> is there something like forever with a signature of "IO Bool -> IO ()" that repeats IO action until it's False?
05:01:33 <ac> @hoogle IO Bool -> IO ()
05:01:33 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
05:01:33 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
05:01:33 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
05:02:46 <nicknull> is there soemthing that just reads and closes a effing file for me?
05:03:38 <scook0> readFile and then rnf perhaps?
05:03:38 <ac> nicknull: you want to slurp a whole file?
05:03:51 <scook0> the lack of a strict slurp function is a known annoyance
05:04:56 <ac> especially problematic with FIFOs, right?
05:05:17 <luqui> nicknull, readFile?
05:05:19 <pyNem> I have to implement a Pascal to C translator as part of a course .. I was thinking of doing it in haskell. I have just started understanding monads .. Is it a doable task?
05:05:31 <luqui> nicknull, oh you probably want it to be strict
05:05:38 <luqui> (right?)
05:05:46 <mauke> pyNem: writing a compiler? sounds nontrivial
05:05:47 <ivanm> Cale: with the whole CReal thing... I've resorted to just using a smaller dataset with smaller numbers :p
05:05:52 <scook0> untilFalseDo action = do { result <- action; when result (untilFalseDo action) }
05:06:19 <Deewiant> ?pl foo a = a >>= \b -> if b then (return ()) else foo a
05:06:19 <lambdabot> foo = fix (ap (>>=) . (flip (flip if' (return ())) .))
05:06:32 <ac> scook0: thanks, that's not in the standard libs anywhere?
05:06:40 <Deewiant> ac: nope
05:06:40 <scook0> not that I know of
05:06:44 <luqui> > rnf [1,2,undefined,3]
05:06:45 <lambdabot>   * Exception: Prelude.undefined
05:07:13 <ac> :t rnf
05:07:14 <luqui> nicknull, fmap rnf readFile should do the job if you need it strict.
05:07:15 <lambdabot> forall a. (NFData a) => a -> Done
05:07:22 <Deewiant> > let x = [1,2,undefined,3] in rnf x `seq` head x
05:07:23 <lambdabot>   * Exception: Prelude.undefined
05:08:52 <nicknull> luqui: i get complint using too many resources when opening +2000 files
05:08:54 <pyNem> mauke .. a lexer + parser + transalator
05:09:00 <nicknull> so i need to close them after i have read them
05:09:05 <mauke> pyNem: ... = a compiler
05:09:24 <luqui> nicknull, ah, you should close them.
05:09:37 <pyNem> mauke,  Agreed... The thing is that I have worked out my grammar and lexemes pretty well.. it is onw a matter of implementing them
05:10:02 <pyNem> mauke, what is scaring me wrt to haskell is that even If I have to add exceptions, Ill have to modify/add monads?
05:10:04 <luqui> nicknull, obviously you shouldn't have them all open at once :-)
05:10:24 <luqui> nicknull, oh sorry missed your latter comment.
05:10:26 <mauke> pyNem: yes, at least that's what I'd do
05:10:44 <pyNem> mauke, I am not very comfortable yet ..
05:10:53 <scook0> readFile should close the file once it's read the whole thing
05:11:12 <vixey> pyNem: Don't worry about being comfortable just work hard
05:11:14 <pyNem> mauke, But the other alternative is the 'routine' lex and yacc and C (which is what I have been coding in all semester anyway)
05:11:24 <scook0> so if you use fmap rnf readFile it should close the file immediately
05:11:25 <luqui> nicknull, strictReadFile file = do { contents <- readFile file ; rnf contents `seq` return contents }
05:11:33 <pyNem> vixey, you think Ill be able to handle it ok with Parsec? (hope ..)
05:11:43 <vixey> yes
05:11:55 <nicknull> but hat doesnt close does it?
05:12:04 <scook0> or what luqui wrote, because that will actually typecheck :)
05:12:08 <Deewiant> nicknull: readFile automatically closes
05:12:19 <pyNem> vixey, :) ... any pointers?
05:12:22 <nicknull> deewiant: not the normal one
05:12:28 <mauke> mmorrow: having fun? :-)
05:12:37 <Deewiant> nicknull: well, rather, the GC closes it.
05:12:41 <vixey> yeah the Parsec tutorial is very good
05:12:42 <scook0> readFile automatically closes, but only when you reach the end of the stream
05:12:44 <luqui> nicknull, you do know that readFile doesn't actually read the file immediately, right?
05:13:28 <pyNem> vixey, _the_ Parsec tutorial? You mean the one that comes with the documentation?
05:13:46 <scook0> somebody needs to give the standard lecture about how lazy I/O is evil ;)
05:13:51 <nicknull> luqui: ah i see now
05:13:55 <luqui> LAZY IO IS EVIL
05:14:01 <nicknull> yes lay io seems evil
05:14:03 <luqui> iteratee is cool :-)
05:14:12 <luqui> it should be on hackage.
05:14:26 <luqui> i should make it proper and put it on hackage :-)
05:15:13 <luqui> free monads are awesome.
05:15:45 <scook0> you haven't been accepting monads from strangers now have you?
05:15:57 <mauke> free the mallocs!
05:16:33 <luqui> oh ballocs
05:18:05 <mmorrow> mauke: lol
05:18:12 <mmorrow> yes indeed :)
05:19:47 <nicknull> laziness seems overall evil
05:20:06 <cjs> Hm. Would it make sense for a GHC threaded runtime to just figure out how many cores are present and default to a -N of that, rather than default to one unless told otherwise?
05:20:08 <nicknull> or i jut dont notice the good stuff it gives me, just the bad
05:20:12 <scook0> lazy IO is evil to the point of brokenness
05:20:34 <cjs> lazy IO is not the right thing under many circumstances.
05:20:35 <mmorrow> mauke: at least 3 segfaults so far :)
05:20:36 <scook0> regular laziness has its ups and downs, but is overall pretty nice
05:20:45 <mauke> mmorrow: for what?
05:20:55 <mmorrow> heh, hell.c
05:20:58 <cjs> You just need to know when to use it. If you're not sure, "never" is a good answer. :-0
05:21:11 <mauke> mmorrow: tested on x86 linux
05:21:22 <mmorrow> hmm odd, really?
05:21:30 <mauke> yes
05:21:50 <mmorrow> huh, i'm on x86 linux. i wonder how i botched it
05:22:12 <mauke> is your data segment execute-protected or something?
05:22:28 <mmorrow> oh i've got SELinux on
05:23:35 <mmorrow> heh, i always forget about that end up spending hours trying to figure out wtf is happening
05:23:59 <mauke> btw, have you seen hell.hs?
05:24:04 <mauke> er
05:24:06 <mmorrow> mauke: oh yesh indeed
05:24:23 <luqui> nicknull, it takes a while to get used to.  early on it's all stack overflows.  but once it sinks in, you can write stuff that is practically impossible in a strict language.
05:24:29 <mauke> one of the japhs does the same thing in perl
05:25:32 <luqui> (also it has nice enginnering properties, such as being able to factor out any piece of code you want into a function and know it will be okay)
05:25:38 <mmorrow> hell.hs causes new ghci to segfault unfortunately. it seems to be on account of a change in a func that used to be in ByteCodeFFI.lhs and got moved to ByteCodeSomething.lhs and allocates mem differently..
05:25:58 <mauke> oh, I've never tried it in ghci
05:27:39 <luqui> it doesn't work compiled for me
05:28:07 <luqui> just exit 0s.
05:29:20 <mauke> weird
05:30:19 <mmorrow> mauke: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=221#a221
05:30:29 <mmorrow> i think that's the code responsible
05:30:56 <mmorrow> (it changed within the last few months)
05:31:34 <mmorrow> luqui: heh
05:31:56 <nicknull> seriously i read ~3000 files, about 2MB of text from html-files and it causes the memory-us to rise to 500MB, eating uip all available memory almost making the computer freeze
05:32:18 <nicknull> http://hpaste.org/11285
05:32:24 <nicknull> ^^ what i use to read
05:32:54 <nicknull> strings: http://hpaste.org/11286
05:32:59 <Botje_> "Strings" ?
05:33:05 <Botje_> ah :)
05:33:08 <mmorrow> nicknull: someone else was having a similar problem with the combo of tagsoup+regexes a while back
05:33:10 <scook0> for that kind of heavy lifting you probably want to be using bytestrings
05:34:38 <luqui> mmorrow, foldl1!?
05:35:00 <luqui> that should definitely be foldr
05:35:04 <luqui> (or foldr1)
05:35:20 <Deewiant> ?ty foldl1 (++)
05:35:21 <lambdabot> forall a. [[a]] -> [a]
05:35:23 <Deewiant> ?ty concat
05:35:24 <lambdabot> forall a. [[a]] -> [a]
05:36:28 <luqui> nicknull, ^ see the mmorrow comment.
05:36:28 <mmorrow> luqui: fold!1!!
05:36:29 <Deewiant> nicknull: foldl (++) is a very, very, bad idea. That's an O(n^2) algorithm.
05:36:49 <mmorrow> mauke: got it japh8.pl
05:37:00 <mauke> mmorrow: do you know perl?
05:37:20 <mmorrow> yeah, but i haven't used it for a while
05:37:29 <mauke> if so, you might appreciate the hidden WTFs in this code :-)
05:37:45 <mmorrow> hehe, i'll be on teh lookout
05:39:00 <nicknull> deewiant: is there another way?
05:39:12 <Deewiant> nicknull: concat. It's in the prelude, and is just foldr (++).
05:39:12 <ivanm> why does printf have so much trouble understanding that it returns a String? *sigh*
05:39:31 <mauke> ivanm: because it can also return IO a
05:39:34 <Deewiant> ivanm: because you're not telling it that it returns a String? :-P
05:39:42 <mauke> or (PrintfType a) => a
05:39:44 <ivanm> mauke: it can? :o
05:39:49 <ivanm> yeah, I know
05:39:55 <Deewiant> ivanm: yes, so you can use it to print to stdout.
05:40:14 <nicknull> wher eare bytestrngs again
05:40:18 <Deewiant> nicknull: Data.ByteString
05:40:21 <ozy`> @src concat
05:40:21 <lambdabot> concat = foldr (++) []
05:40:22 <nicknull> Data.Char.ByteString doesn work
05:40:24 <ivanm> oh, wait, type analysis fails because the only time I use that String, is to put it inside another printf statment :s
05:40:29 <luqui> nicknull, a ++ b is O(length a).  so ((a ++ b) ++ c) ++ d  is quadratic, but a ++ (b ++ (c ++ d)) is linear;  i.e. use right folds on lists
05:40:32 <ozy`> @src foldr
05:40:32 <lambdabot> foldr f z []     = z
05:40:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:41:18 <ozy`> @src (++)
05:41:19 <lambdabot> []     ++ ys = ys
05:41:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:41:19 <lambdabot> -- OR
05:41:19 <lambdabot> xs ++ ys = foldr (:) ys xs
05:41:54 <luqui> woah, is ++ subject to a foldr fusion?
05:42:02 <luqui> (I have no idea how fold fusion works =P)
05:42:10 <vixey> (++) = flip (foldr (:))
05:42:22 <ozy`> I think you can implement the destruction of the world as we know it in terms of foldl and foldr
05:42:22 <nicknull> No instance for (Control.Parallel.Strategies.NFData DBS.ByteString)
05:42:24 <mmorrow> infixr 5 ++
05:42:24 <mmorrow> infixr 9 .
05:42:24 <mmorrow> infixl 6 +
05:42:24 <mmorrow> infixl 7 *
05:42:35 <mauke> nicknull: no need for rnf or seq there
05:42:40 <vixey> @free foldr
05:42:41 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
05:42:41 <mmorrow> a rule of thumb is to use the fold that corresponds to that op's fixity
05:42:49 <mauke> nicknull: ByteStrings are strict by default
05:43:01 <vixey> mmorrow: cool
05:43:02 <nicknull> deeewaitn how is foldr ++ any better tha foldl ++?
05:43:05 <Deewiant> mauke: except the lazy bytestrings. ;-)
05:43:06 <vixey> nice observation
05:43:25 <luqui> mauke, he's not using bytestrings...
05:43:29 <mmorrow> vixey: i'm not sure if that's true in general, but it'd be interesting to figure out
05:43:38 <mauke> luqui: <nicknull> No instance for (Control.Parallel.Strategies.NFData DBS.ByteString)
05:43:47 <luqui> ah.
05:44:00 <Deewiant> nicknull: consider ((a ++ b) ++ c), the result of foldl1 (++) [a,b,c]. First (a ++ b) is evaluated, so a is traversed. Then the (++ c) is evaluated, so (a ++ b) is traversed. Note that a is traversed twice.
05:44:41 <Deewiant> nicknull: Then, consider (a ++ (b ++ c)). To get (b ++ c), b needs to be traversed, and to get (a ++) that, a needs to be traversed. Both a and b are traversed only once.
05:44:53 <Deewiant> In a nutshell, that's why.
05:45:33 <nicknull> i see
05:45:34 <Deewiant> Given a list of length n, if you do foldl1 (++) on it, the first element is traversed n-1 times, the next n-2 times, and so on.
05:45:57 <Deewiant> With foldr, each is traversed once (apart from the last one).
05:46:01 <nicknull> but i will chagnge to bytestrings
05:46:11 <nicknull> and how do i strict-read bytestrings+
05:46:13 <nicknull> ?
05:46:24 <Deewiant> nicknull: they're strict by default, like mauke said.
05:46:27 <luqui> you just read them.  they are strict.
05:46:32 <nicknull> ok
05:46:36 <mauke> nicknull: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.3/doc/html/Data-ByteString.html#26
05:46:42 <lambdabot> Title: Data.ByteString, http://tinyurl.com/69bedx
05:47:28 <nicknull> i can regexp bytestrings too?
05:48:17 <luqui> *silence* :-)
05:48:20 <nicknull> i cant parseTags on bytestrings it seems
05:48:44 <Deewiant> nicknull: you can convert them to lists if necessary.
05:49:08 <mauke> specifically, Data.ByteString.Char8.unpack
05:50:32 <Deewiant> eww, Char8
05:50:40 <mauke> sry
05:50:59 <nicknull> but then what am i winning?
05:53:39 <cjs> Actually, you read strict ByteStrings and then convert them to lazy ones for further processing, typically.
05:55:07 <Deewiant> cjs: Not just read lazy bytestrings strictly?
05:55:19 <cjs> You can't do so, I don't think.
05:55:32 <Deewiant> Well, you can force the length or something, no?
05:55:32 <cjs> Maybe I missed a function somewhere.
05:56:32 <Deewiant> readFile "foo" >>= \bs -> length bs `seq` return bs ?
05:57:24 <RayNbow> :t getRandomR
05:57:25 <lambdabot> Not in scope: `getRandomR'
05:58:12 <Deewiant> ?ty randomR
05:58:13 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
05:59:20 <nicknull> it still seems to take forever
05:59:25 <mmorrow> nicknull: pcre-light'll take ByteStrings
05:59:31 <mmorrow> ?hackage pcre-light
05:59:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light
05:59:32 <nicknull> 999 files goes quickly but 3K
05:59:42 <nicknull> oh wait it finished
05:59:47 <nicknull> and didnt use a lot of memory
06:00:30 <RayNbow> Deewiant: I wanted to use getRandomR from MonadRandom
06:00:33 <RayNbow> @hoogle getRandomR
06:00:33 <lambdabot> No results found
06:00:43 <nicknull> haskell was metioned 3 times in 1/100 of the posts on Hacker News in september
06:01:17 <RayNbow> hmm, Hoogle doesn't search inside packages?
06:01:29 <nicknull> anything you want to know about hacker news?
06:01:38 <nicknull> that i can datamine fromt he september posts?
06:01:39 <mmorrow> haha
06:01:40 <Deewiant> RayNbow: only the standard ones, use Hayoo! for Hackage: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=getRandomR
06:01:41 <lambdabot> Title: Hayoo!
06:02:35 <nicknull> mmorrow was mentiond 322 times as a tremendous haskell-expert on hacker news in september
06:03:15 <cjs> Deewiant, I can't recommend using readFile. And why bother with the seq and all of that; the conversion is cheap.
06:03:15 <nicknull> im gonna watch true blood now
06:04:13 <Deewiant> cjs: I'll take your word for it, then :-)
06:05:35 <RayNbow> Deewiant: ah, thx
06:05:50 <nicknull> really make bytestrings the standard and make them regexable
06:07:19 <nicknull> i want to write a minisearchengine in haskell
06:07:26 <nicknull> so i need to parse text
06:07:32 <nicknull> so
06:09:27 <nicknull> to parse a text for python and  i want +- 100 chars for the search term
06:09:33 <scook0> Text.Regex.Posix.Bytestring?
06:09:35 <nicknull> is there a funcion to do that already?
06:09:49 <nicknull> i should use laziness for that or strictnss?
06:10:32 <scook0> (or whichever of the regex libs support bytestrings)
06:10:52 <Deewiant> Text.Regex.TDFA.ByteString
06:11:18 <scook0> what are you parsing, python source?
06:11:41 <scook0> or have I misunderstood?
06:12:53 <vixey> can't python print out the AST as haskell code
06:13:12 <nicknull> hacker news posts
06:14:16 <luqui> I have an infinite [(k,v)], with infinitely many different ks (but many repititions).
06:14:30 <luqui> I'm looking for a data structure that will allow me to access the list of vs associated with a given k
06:14:37 <luqui> (not just filter, many different ks)
06:15:11 <luqui> preferably with nice GC properties too; i.e. if I forget about the map and just have consumers hanging around, unused elements will get cleaned up
06:15:31 <Deewiant> Data.Map?
06:15:50 <nicknull> hmm i should prob use database
06:15:52 <luqui> Deewiant, there are two infinites in the above sentence, neither of which play well with Map :-)
06:15:52 <Deewiant> ah but I guess it can't handle infinite lists
06:16:05 <Deewiant> I think the second would be fine
06:16:11 <Deewiant> but the former isn't so it's moot. :-P
06:16:16 <nicknull> i can store index-word -> text in a databse right?
06:16:28 <luqui> fair nuff :-)
06:16:46 <luqui> after all, who cares if you have infinitely many ks if you can only store finitely many entries anyway :-)
06:17:17 <vixey> luqui: a possibility is k -> [v] but I don't know how it interacts with GC
06:17:40 <luqui> vixey, you mean with filter?
06:18:00 <luqui> yeah, tis no good.  too slow.  (assuming there *is* a faster one; otherwise it would be about what I would do)
06:18:53 <luqui> but ultimately yes, k -> [v] is what I'll end up with.  just what data structure does *it* use underneath :-)
06:23:05 <mjg> anyone know if there is a line-length limit in winhugs?
06:24:11 <Deewiant> there is in GHCi, at least
06:24:45 <mjg> ok, so maybe that is why it is crashing then..
06:24:48 <mjg> thanks
06:25:10 <Deewiant> 254 chars, to be exact
06:25:24 <luqui> that's archaic...
06:25:26 <mjg> ya - my line is over 1024
06:25:41 <vixey> put it in a file
06:25:55 <Deewiant> looks like no such limit exists in linux
06:26:02 <int-e> wee. ERROR - Maximum token length (4000) exceeded
06:26:04 <Deewiant> it's either longer or nonexistent
06:26:27 <luqui> and which of the two is undecidable without looking at the source
06:26:36 <luqui> (and maybe even *with* looking at the source :-)
06:26:59 <int-e> (perl -e 'print "\"" . " "x4001 . "\""' | hugs)
06:28:15 <luqui> you mean, ghc -e 'putStr $ "\"" ++ repeat 40001 ++ "\""' | hugs
06:28:56 <luqui> er, modulo typo
06:29:32 <int-e> ghc -e "print (replicate 4001 ' ')" ... now that would've saved a bit of typing.
06:29:52 <luqui> lol duh
06:30:08 <luqui> woah, haskell just won at small-program terseness!
06:30:28 <luqui> perl almost always wins at < 10 lines
06:41:25 <pyNem> vixey, suppose I can implement a good deal of the Pascal to C compiler with Haskell, using Parsec. Can I add Exceptions and Error Handling (of line numbers) easily later?
06:41:56 <vixey> pyNem: If you read this PDF then certainly
06:42:09 <pyNem> vixey, er.. which one?
06:42:15 <vixey> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
06:42:18 <lambdabot> Title: Monad Transformers Step by Step
06:42:55 <luqui> pyNem, uh, what sort of exception / error handling do you intend?
06:43:11 <luqui> i.e. what's a concievable error?
06:43:33 <luqui> Parsec already does parse errors.
06:44:01 <luqui> so what other kind of exception do you expect?  (not being confrontational, just probing)
06:44:16 <pyNem> luqui, simple stuff like .. which line number the error occured.. what token it was parsing when it got stuck?
06:44:33 <luqui> I think parsec already has good support for that kind of thing.
06:44:40 <vixey> pyNem: oh that's even easier than what I thought you mean
06:44:43 <pyNem> luqui, I am trying to write a Pascal-like language (with a lot of simplifications) to C compiler
06:44:58 <vixey> pyNem: Maybe I have some example code that could be useful
06:45:04 <pyNem> vixey, oh ok :) ... Can I do something to not crash at the first error?
06:45:11 <pyNem> vixey, sure that would help a lot :)
06:45:23 <vixey> pyNem: what do you mean crash?
06:45:44 <luqui> pyNem, ah yeah, then parse errors and type errors or something.  type errors are easy, just return an Either Error AST or whatever...  it is a monad, but who cares?
06:45:56 <pyNem> vixey, luqui It would be nice if the lexer/parser kept reading through the entire file, and reported all the obvious errors,
06:46:19 <luqui> ah that's error recovery.  you could probably get that to work with some combinators...
06:46:23 <pyNem> vixey, luqui by crash I mean .. it should not stop at the first token that mismatches some rule and say, "eror here .."
06:46:42 <luqui> instead it should do what most compilers do and skip the rest of the line then continue
06:46:46 <luqui> right?
06:46:50 <pyNem> yeah
06:47:05 <luqui> it shouldn't be that hard to say that directly in parsec, but I'm not really a parsec whiz
06:47:35 <pyNem> luqui, vixey error recovery would actually be a bonus.. :) .. I want to implement a simplistic thing first.. I have only about 20 days for this project..
06:47:41 <pyNem> luqui, parsec can do that too?
06:48:06 <vixey> pyNem: I'd tokenize the whole page, split it into sections and attempt to parse each section
06:48:20 <vixey> you get a list of errors that way
06:48:24 <luqui> pyNem, well it's a combinator library.  so you just don't worry about it being an error and pretend it's just data instead
06:48:26 <vixey> (or a list of successes)
06:48:40 <pyNem> yeah .. makes sense .. since obvious sections are begin and end in a pascal program.. @ vixey
06:48:59 <vixey> so,
06:49:08 <vixey> data Term a = Var a Ident | Ctr a Name | App a (Term a) (Term a) | Lam a Ident (Term a)
06:49:12 <pyNem> luqui, you mean create an error token or something like that .. ? (hm.. great food for thought)
06:49:14 <luqui> this is an AST node "ParseError", and its parse rule is "read until a newline"...
06:49:16 <vixey> if you have some little functional laungage
06:49:21 <vixey> your AST might be like that Term a
06:49:49 <luqui> something like that.  I'm sure there are reasons that's not a great approach, but you get the drift, ya?
06:49:50 <vixey> now parsing can return  Term Position  where Position is the source filename, line and column number
06:49:59 <pyNem> luqui, yeah .. I get the drift
06:50:03 <pyNem> vixey, oh .. :)
06:50:08 <vixey> do ... pos <- getPosition ; ... ; return (Var pos "x) ...
06:50:27 <luqui> vixey, why oh why would you label each node separately?
06:50:29 <vixey> and then when you are say, typechecking or scope checking whatever.. you easily extract line numbers
06:50:43 <vixey> I label every node because
06:50:49 <vixey> 1) you can be exact about where things are
06:50:56 <luqui> data Term a = Label a | Var Ident | Ctr Name | ...   -- what I'd do...
06:51:02 <vixey> 2) it also serves other purpose for example Term (Position,(Type,(...,())))
06:51:04 <luqui> er, Label a (Term a)
06:51:09 <vixey> where Type is a logic variable
06:51:18 <luqui> ah clever :-)
06:51:49 <luqui> but ultimately you'd like to have different labels for each type of node.  but that's getting complicated.
06:52:15 <pyNem> vixey, I think I get the flow ..
06:52:23 <pyNem> vixey, can you show me the example code you were talking about?
06:52:31 <vixey> pyNem: sure, everything I said is directly from this http://rascal-haskell.googlecode.com/svn/trunk/
06:52:32 <lambdabot> Title: Revision 2: /trunk
06:54:46 <pyNem> vixey, err.. curiosity  .. I see no makefile ?
06:54:53 <pyNem> vixey, and how long did that take to write?
06:55:38 <vixey> pyNem: ghc --make or something
06:57:21 <vixey> pyNem: I don't know how long it took
06:59:49 <pyNem> vixey, Parsec seems very powerful .. I am looking at the Language Reference .. there is a ParserPos primitve module ...
07:02:12 <nicknull> but i ahve Parsec isnt ready for "production"
07:02:19 <nicknull> too slow or something, is that true?
07:04:33 <jeffz> nicknull: no.
07:04:37 <Saizan> nicknull: that's true for parsec3
07:04:56 <olsner> besides, nothing can be "too slow" out of the box, something can only be too slow for some specific case where you actually need it to go faster :)
07:05:12 <jeffz> parsec-2 is fine, I've found parsec-3 to use about 4x time and memory as a drop-in replacement for parsec-2
07:05:17 <luqui> olsner, amen
07:05:59 <younder> In a function Adler32 I see (ord x .&. 0xFF). what does the ord do?
07:06:06 <Deewiant> > ord 'a'
07:06:07 <lambdabot>   97
07:06:24 <luqui> > ord '*'
07:06:26 <lambdabot>   42
07:06:47 <younder> But if x is a integer why isn't x .&. 0xFF a integer?
07:06:57 <Deewiant> x is not an integer
07:07:09 <luqui> :t (42::Integer) .&. 0xFF
07:07:10 <lambdabot>     Ambiguous occurrence `.&.'
07:07:10 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
07:07:10 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
07:07:16 <Deewiant> ?ty ord
07:07:16 <luqui> :t (42::Integer) Data.Bits..&. 0xFF
07:07:17 <lambdabot> Char -> Int
07:07:17 <lambdabot> Integer
07:08:23 <younder> I see. Thanks
07:08:26 <ivanm> unzipN++
07:09:13 <mopped> @src all
07:09:14 <lambdabot> all p =  and . map p
07:10:05 <mopped> Is it just from practice that one creates short functions like the one above? ie myAnd used pattern matching and recursion :P
07:10:16 <mopped> myAll*
07:10:26 <Botje_> what does HOAS stand for?
07:10:30 <Botje_> Haskell on a Stick? :)
07:11:01 <Saizan> Higher Order Abstract Syntax
07:11:26 <Botje_> close enough :)
07:12:12 <olsner> mopped: meditation and reflection :)
07:12:16 <olsner> also, @pl
07:12:41 <Botje_> mopped: it comes with experience :)
07:12:48 <Saizan> @quote true haskell form
07:12:49 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
07:12:57 <Saizan> @quote true.haskell.form
07:12:57 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
07:13:14 <Botje_> after a while you barely notice you're doing it
07:13:56 * Botje_ reads some more about quantum computation
07:14:43 <mopped> what does @pl do?
07:15:18 <Botje_> @pl \x -> (show x) == (reverse $ show x)
07:15:18 <lambdabot> liftM2 (==) show (reverse . show)
07:15:23 <ski> @help pl
07:15:24 <lambdabot> pointless <expr>. Play with pointfree code.
07:15:25 * Badger wishes there was ogre in haskell.
07:15:36 <Botje_> ogre the 3D engine?
07:15:37 <Saizan> ogre?
07:15:40 <Badger> indeed
07:15:58 <Japsu> data Ogre = Ogre [Layer] -- onions have layers! ogres have layers!
07:16:01 <Botje_> someone challenged me to make a haskell port some time ago
07:16:06 <Badger> hah
07:16:09 <Botje_> rofl :)
07:16:27 <Botje_> @remember Japsu data Ogre = Ogre [Layer] -- onions have layers! ogres have layers!
07:16:27 <lambdabot> It is forever etched in my memory.
07:19:52 * Badger challenges Botje_ to make a haskell port :P
07:19:59 <olsner> hmm, given an interpreter for a arbitrary language, written in that language itself, is it possible to derive the semantics of the language?
07:20:38 <olsner> in some kind of metacircular reverse-engineering
07:21:28 <vixey> olsner: I think not
07:22:15 <vixey> You could usually come up with something sensible by thinking really hard and extrapolating
07:22:41 <vixey> but I don't think there can be a unique solution in general
07:22:47 <mopped> @src splitAt
07:22:47 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
07:23:29 <Deewiant> splitAt = liftM2 (&&&) take drop
07:24:04 <olsner> @ty liftM2 (&&&) take drop
07:24:05 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:24:34 <olsner> @ty liftM2 (&&&)
07:24:35 <lambdabot> forall (a :: * -> * -> *) b c c' (m :: * -> *). (Monad m, Arrow a) => m (a b c) -> m (a b c') -> m (a b (c, c'))
07:24:52 <Botje_> Badger: i challenge you to a duel! with banjos!
07:26:10 <Badger> Botje_: if I win, you port? :P
07:26:25 * Badger dusts off his war banjo
07:26:26 <Botje_> after my thesis, perhaps :)
07:26:53 <olsner> hmm, so that's m = (Int ->), with (a b c) == (a b c') == ([a] -> [a]) in the arrow parts?
07:27:04 <olsner> slightly mindboggling :)
07:27:17 <vixey> if you rewrite a into (~>) it is much more readable
07:27:20 <mopped> Is there a website with all the @src so I don't spam the channel? :P
07:27:32 <vixey> m (b ~> c) -> m (b ~> c') -> m (b ~> (c, c'))
07:27:38 <Deewiant> mopped: you can talk with lambdabot in private
07:27:42 <mopped> aha
07:28:00 <ketil> @seen bos
07:28:00 <lambdabot> I saw bos leaving #haskell and #ghc 12h 27m 27s ago, and .
07:28:06 * ketil grumbles.
07:28:24 <olsner> btw, what's up with that extra ", and " at the end of the @seen output
07:28:40 <Badger> Botje_: I'll hold you to that ;)
07:28:40 <Deewiant> preflex: seen ndm
07:28:41 <preflex>  ndm was last seen on #xmonad 51 days, 21 hours, 54 minutes and 28 seconds ago, saying: cool :)
07:29:59 <Botje_> Badger: now i have an incentive to fail my thesis! :p
07:33:27 <ketil> olsner, no idea.  It's been there for some time now.
07:34:02 <sam__> How to reload new functions to ghci without starting a new ghci?
07:34:16 <Botje_> :r
07:34:26 <Badger> Botje_: excellent! It's always satisfying to know I've ruined a life. :P
07:34:32 <Botje_> :)
07:35:14 <dmwit> ox
07:35:26 <dmwit> errr... sorry
07:39:46 <pyNem> I am on ubuntu. How do I compile a program, so that I can include Data.List? ghc -package ___ ?
07:39:53 <dmwit> ghc --make
07:39:55 <sam__> How to get syntax highlighting to Haskell in Mac?
07:40:01 <Deewiant> vim
07:40:03 <dmwit> sam__: Use vim or emacs.
07:40:05 <vixey> you put import Data.List in the actualy module
07:40:05 <thoughtpolice> sam__: I use 'carbon emacs'
07:40:15 <vixey> :/
07:40:23 <thoughtpolice> sam__: it comes with haskell-mode for emacs and a whole bunch of other nice-to-have packages
07:40:32 <sam__> dmwit: I am using vim but I do not have the highlighting
07:40:40 <Botje_> :syn on
07:40:49 <Deewiant> sam__: http://www.vim.org/scripts/script.php?script_id=2062
07:40:54 <lambdabot> Title: haskell.vim - Syntax file for Haskell : vim online
07:41:19 <sam__> Deewiant: thanks!
07:42:10 <pyNem> vixey, I put it in the actually module? I dint quite get that
07:46:35 <sam__> Where is the syntax folder for vim by default in mac?
07:47:51 <dpowers> I come seeking help with some confusion I am having with deriving Read
07:48:19 <dmwit> ~/.vim/syntax
07:48:29 <dmwit> dpowers: shoot
07:49:00 <dmwit> sam__: You can also find where it's looking for stuff by doing :echo $VIMRUNTIMEPATH from inside vim.
07:49:06 <dpowers> I have a fairly simple Stack type - basically Stack a as a functional queue
07:49:12 <dpowers> deriving Read
07:49:21 <dmwit> sam__: errr... :set rtp? is more like it
07:49:46 <Deewiant> dmwit: :echo $VIMRUNTIME is probably what you were thinking of
07:49:47 <dpowers> when I put it in a file with some simple code writing a stack to disk (using show) and then reading it back - all works as expected
07:50:04 <dmwit> Deewiant: It's what I was thinking of, but it's not what I wanted. =)
07:50:18 <Deewiant> dmwit: yes, :set rtp? is better :-)
07:50:38 <dmwit> sam__: Check also that the correct filetype is getting set.
07:50:46 <dpowers> when I put the Stack in a module (Data.Stack), the compiler complains that it has no instance of Read (Stack Int).  despite 'import Data.Stack'
07:50:49 <dmwit> sam__: While editing your file, check that :set ft? responds
07:50:55 <dpowers> oddly though, show works still
07:51:11 <dmwit> sam__: ...responds filetype=haskell.
07:51:13 <dpowers> so I have some confidence that the import is reasonable
07:51:27 <pyNem> when I compile this http://hpaste.org/11290 .. using ghc --package parsec filename.hs, I get these errors - http://hpaste.org/11290#a1
07:51:42 <Deewiant> pyNem: use ghc --make.
07:51:54 <pyNem> Deewiant, that does not give me a.out
07:52:03 <pyNem> it just creates filename.hi and filename.o
07:52:08 <dmwit> pyNem: It gives you filename as an executable.
07:52:14 <Deewiant> pyNem: well, er, you don't have a main function.
07:52:19 <sam__> dmwit: set fb responds,; :set rtp works
07:52:29 <Deewiant> pyNem: which would explain the link errors from the other one as well.
07:52:35 <pyNem> Deewiant, oh freak
07:52:41 <Deewiant> :-D
07:52:41 <nicknull> i tired to install sqlite and sqlite 3 bindinfs. FAIL
07:52:41 <pyNem> Deewiant, I feel soooo foolish
07:52:48 <nicknull> i tired to install sqlite and sqlite 3 bindinfs. FAIL
07:53:00 * dpowers pasted http://pastie.textmate.org/private/ysawemggm9q5ujykykqvda
07:53:01 <dmwit> sam__: What does :set ft? respond?  And what do you mean by ":set rtp works"?
07:53:02 <dpowers> to be very clear this works:
07:53:18 <sam__> dmwit: filetype =
07:53:30 <dmwit> sam__: That's your problem.
07:53:35 * dpowers pasted http://pastie.textmate.org/private/lqbggm28e0ezrxdpmuggla
07:53:36 <dpowers> but this doesn't
07:54:10 <dmwit> dpowers: It would also help to have the exact error.
07:54:29 * dpowers pasted http://pastie.textmate.org/private/mwu06dkixbzwobc6ultsgq
07:54:30 <sam__> dmwwit: :set rtp gives me this "~/.vim,/usr/share/vim/vimfiles,/usr/share/vim/vim72,/usr/share/vim/vimfiles/after,~/.vim/after"
07:54:32 <dpowers> your wish...
07:55:00 <dmwit> huh, that's odd
07:55:12 <sam__> dmwit: for runtimepath
07:55:16 <dmwit> sam__: Try, when editing a haskell file, typing ":set ft=haskell".
07:55:23 <dpowers> I'm stumped - I thought there was basically no way to avoid pulling in instances from an import
07:55:33 <dmwit> sam__: (Possibly followed by :syntax on)
07:55:50 <dmwit> sam__: If that gives you syntax highlighting, then we can get started solving your problem. =)
07:56:00 <dmwit> dpowers: What happens if you remove the context requirements from Stack?
07:56:07 * dpowers pasted http://pastie.textmate.org/private/yevuqbbioey0rqlvktrg
07:56:20 <dpowers> further adding to the confusion - that works
07:56:27 <dmwit> Okay.
07:56:30 <dpowers> dmwit: same error
07:56:37 <dmwit> Wait, what?
07:56:45 <sam__> dmwit: :set tp=haskell does nothing
07:56:51 <dmwit> sam__: ft, not tp
07:57:07 <dpowers> I added them thinking originally that my problem was that I was asking for a general Read for a possible unreadable a
07:57:25 <dmwit> dpowers: If you write data Stack a = Stack { front :: [a], back :: [a] } deriving (Eq, Read, Show) -- this doesn't work??
07:57:31 <sam__> dmwit: Yes, with ft, it gives nothing
07:57:33 <dpowers> it works
07:57:44 <dpowers> dmwit: but breaks in the same way in an external module
07:57:58 * dmwit goes off to try reproducing
07:58:19 <Botje_> making lambda babies, eh?
07:58:51 <sam__> dmwit: I moved to a different HS file and now when I type :set ft: it gives me filetype=haskell
08:00:12 <dmwit> dpowers: I cannot reproduce this issue.  Can you paste the module that you've written, too, in case there's discrepancies?
08:00:20 <dpowers> sure
08:00:29 * dpowers pasted http://pastie.textmate.org/private/dooso8onh9c1ajjoftgxgg
08:00:35 <dpowers> GHC 6.8.3 on OS X
08:01:00 <dmwit> dpowers: module Data.Stack where -- your first problem, dunno if it's related
08:01:21 <dpowers> fixed - no love
08:01:57 <sam__> dmwit: when I put :syntax on in the working HS file, it makes nothing
08:02:27 * dpowers pasted http://pastie.textmate.org/private/ynavadpdl11l9dtvan4qwg
08:02:28 <dmwit> sam__: Okay, make sure the syntax file Deewiant pointed you at is called haskell.vim and is located in ~/.vim/syntax
08:02:35 <dpowers> dmwit: cabal I'm using
08:03:54 <dpowers> Data.Stack is held in a subdir Data... which also seems like it wouldn't matter
08:04:56 <nicknull> ould not find module `Text.PrettyPrint.HughesPJ':
08:05:04 <nicknull> when trying to install haskelldb
08:05:05 <mohbana> who initially thought of the idea of parser combinators?
08:05:53 <dmwit> dpowers: I can't repro this problem at all.  When I just paste the files you've given into mystack.hs, mystack.cabal, and Data/Stack.hs respectively, cabal builds it just fine.
08:06:03 <dpowers> dmwit: dang
08:06:10 <dmwit> dpowers: (I also touched LICENSE, of course.)
08:06:14 <dpowers> heh
08:06:17 <dmwit> dpowers: What version of ghc are you on?
08:06:22 <dpowers> 6.8.3
08:06:26 <dmwit> same
08:06:39 <dpowers> crazy
08:06:43 <dmwit> What command are you running to build it?
08:07:08 <dpowers> runhaskell Setup.lhs build
08:07:23 * dpowers pasted http://pastie.textmate.org/private/zkufdl2rttqon8cjsnl5nq
08:07:29 <dpowers> Setup.lhs
08:07:37 <dmwit> right
08:07:41 <dmwit> totally standard
08:07:52 <dpowers> dmwit: hope so - I swiped it from the wiki
08:08:00 <dmwit> dpowers: You're doing everything right.  I don't know what to say.
08:08:02 <dmwit> OS?
08:08:06 <dpowers> OS X
08:08:20 <dpowers> 10.5.4 to be specific
08:08:20 <dmwit> Not that that tells me anything... =P
08:08:24 <nicknull> ould not find module `Text.PrettyPrint.HughesPJ':
08:08:31 <sam__> dmwit: I have had difficulties in finding the directory /.vim/ syntax. locate vim gives me this "usr/share/vim" but I cannot get into the folder by "cd usr/share/vim"
08:08:36 <dmwit> dpowers: Okay, one last attempt at fixing this.
08:08:46 <dpowers> hrm - I'm going to recreate the project from scratch
08:08:49 <Saizan> dpowers: tried runhaskell Setup.lhs clean first?
08:08:52 <dmwit> dpowers: If you go to another directory, and run ghci, and try to load up Data.Stack, does it work?
08:09:07 <dmwit> dpowers: (i.e. is there a Data.Stack coming from somewhere else?)
08:09:20 <dpowers> I hope not - the data structure looks correct in show
08:09:31 <dmwit> sam__: Create the directory if it doesn't exist. "mkdir -p ~/.vim/syntax"
08:10:06 <nicknull> seriously, i give up haskell soon. even with cabal-install most packages dont install
08:10:07 <Deewiant> dpowers: try also running ghci in your directory, and see what :i Stack says.
08:10:19 <dpowers> I'll give that a shot
08:10:21 <Deewiant> nicknull: Text.PrettyPrint.HughesPJ comes with GHC.
08:10:35 <dpowers> copying the basics over to a clean foo directory
08:10:44 <nicknull> so what is the problem?
08:10:44 <nicknull> haskell only works with linux properly?
08:10:50 <Deewiant> nicknull: but also, haskelldb is old.
08:11:02 <Deewiant> nicknull: no, I use it pretty much only on Windows and fairly successfully.
08:11:04 <nicknull> well i want interface to sqlite3
08:11:31 <nicknull> i want to be able to create, insertn, search, jojn databses from haskell programs
08:11:34 <Saizan> nicknull: you need to install the sqlite3 C header files first
08:11:55 <Deewiant> nicknull: you can use haskelldb, but you just need to mess around with the build process because it hasn't been updated in over a year.
08:12:13 <Deewiant> nicknull: might be easier to get HDBC instead.
08:12:15 <Saizan> and yeah, it would be much easier to do that on linux, pretty much like anything else involving developing..
08:12:18 <dpowers> mohbana: http://en.wikipedia.org/wiki/Parser_Combinator
08:12:29 <Deewiant> nicknull: which looks like it has sqlite3 support and also compiles with 6.8.
08:12:32 <sclv> hdbc is the basic easy to use database binding
08:13:10 <sclv> its actually also a backend for haskelldb anyway
08:14:54 <nicknull> thnks hdbc worked to install
08:15:43 <nicknull> it has no binding to mysql?
08:15:44 <dpowers> dmwit: nuts - *Data.Stack> :i Stack
08:15:45 <dpowers> data Stack a = Stack {front :: [a], back :: [a]}
08:15:45 <dpowers>   	-- Defined at Data/Stack.hs:4:5-9
08:15:45 <dpowers> instance (Show a) => Show (Stack a)
08:15:45 <dpowers>   -- Defined at Data/Stack.hs:4:5-9
08:15:57 <sclv> mysql should be done via odbc
08:16:13 <dpowers> it's gone and lost my other derived instances somehow...
08:16:30 <dmwit> dpowers: I suggest doing ./Setup.lhs clean, configure, and build again, as Saizan suggested.
08:16:39 <dpowers> did it.  :(
08:16:48 <dpowers> also copied all the files to a clean dir
08:16:49 <sclv> I think the darcs repo of haskelldb might work right, btw. but if you're just getting started in haskell hdbc will make more sense.
08:17:00 <sclv> (and once you want to get fancier, takusen might be a better choice to move on to)
08:17:05 <Botje_> is there still not a general equivalent to perl's DBI?
08:17:14 <nicknull> compiling dist\build\Database\HDBC\Sqlite3\Statement_hsc_make.c failed
08:17:22 <Botje_> (general meaning not bound to any language)
08:17:28 <nicknull> when installng hdbc-sqlite3
08:17:30 <nicknull> hdbc worked though
08:18:06 <Saizan> nicknull: can you paste the full error on hpaste.org ?
08:18:19 <dpowers> got it
08:18:34 <dpowers> thanks dmwit / Saizan
08:18:44 <Saizan> dpowers: what was the problem?
08:19:02 <sam__> Deewiant: It works! How can I force vim always to run ":syntax on" when I start a HS file?
08:19:41 <dpowers> sigh - badly cached file in my editor of all things.  The file was not getting flushed to disk somehow
08:19:59 <dpowers> caught it with ghci as per suggestion
08:20:10 <Saizan> hah, i suspected something like that
08:20:24 <dpowers> works like a charm.  :)
08:20:40 <Botje_> sam__: put "syntax on" in ~/.vimrc
08:20:44 <Botje_> without the quotes
08:20:59 <Botje_> of course you might want to spend some time crafting your own .vimrc (or stealing somebody elses)
08:21:14 <dpowers> Sadly, my Haskell foo was too weak for me to be certain that the behavior wasn't expected.  :)
08:22:55 <sclv> nicknull -- do you have the sqlite3 headers installed on yr system?
08:23:06 <sclv> getting the bindings right can be mildly tricky with windows.
08:23:27 <sclv> odds are you need to tell ghc where to find the headers so that it can link properly.
08:24:59 <sam__> Botje_: How to find and open the file .vimrc?
08:25:26 <sam__> Botje_:  locate gives me nothing for .vimrc
08:25:39 <nicknull> hdbc i cna install but hdbc-sqlitee and postgresql fails
08:25:39 <Botje_> sam__: that's okay
08:25:41 <Botje_> just create it
08:25:45 <Botje_> vim ~/.vimrc
08:26:30 <sam__> Botje_: I run this "mkdir ~/.vimrc". What should I do to make the "syntax on" on?
08:26:34 <nicknull> http://hpaste.org/11291
08:26:35 <Botje_> no, not mkdir
08:26:40 <Botje_> mkdir creates a directory, not a file
08:26:53 <Botje_> rm -r ~/.vimrc; echo "syntax on" > ~/.vimrc
08:27:00 <Botje_> just copypaste that line
08:27:12 <Botje_> and you should have automatic syntax highlighting in vim
08:27:18 <BONUS> also do :set ai
08:27:18 <BONUS> imho
08:27:27 <Botje_> of course if you're a mac user, i'm pretty sure textmate has a haskell mode too
08:27:51 <sam__> Botje_: It works! Thanks!
08:28:23 <Botje_> note: for haskell editing you probably want some other options too
08:28:36 <Badger> err
08:28:37 <Badger> interact f      =   do s <- getContents putStr (f s)
08:28:47 <Badger> what would f be?
08:28:55 <Botje_> a function String -> String
08:28:57 <sam__> Botje_: Which options do you mean?
08:28:57 <vixey> :t let interact f      =   do s <- getContents putStr (f s) in interact
08:28:58 <lambdabot> The last statement in a 'do' construct must be an expression
08:29:09 <Botje_> sam__: smart indent and tab expansion, for one
08:29:40 <Botje_> vim .vimrc
08:29:42 <Botje_> err
08:29:44 <Botje_> vim ~/.vimrc
08:29:47 <sam__> Botje_: sure
08:30:07 <Botje_> and add the lines "set smartindent" and "set expandtab"
08:30:12 <Badger> hmm
08:30:17 <BONUS> i thought that was autoindent?
08:30:18 <Badger> that doesn't seem to make sense.
08:30:20 <Botje_> without the quotes, again
08:30:49 <Botje_> smartindent can use indentation l-plugins
08:30:54 <Botje_> s/ l//
08:31:11 <BONUS> ah
08:31:12 <Botje_> Badger: there's a newline between the getcontents and putStr
08:31:22 * Badger is trying to work out how to print SDL.getError's result, and was told it could be done with interact
08:31:30 <Badger> Botje_: indeed
08:31:32 <BONUS> also i'd set: tabstop=4, expandtab, shiftiwdth=4, softtabstop=4
08:31:47 <Botje_> BONUS: blah. I have ts=2
08:31:51 <BONUS> haha
08:31:56 <Botje_> among other things
08:31:59 <tux91> hey guys! what's wrong with this: fact x = x * fact (x - 1)??
08:32:10 <nicknull> i onyl have the binaries, the executabe command jne interface.
08:32:11 <vixey> tux91: Nothing
08:32:11 <sam__> Botje_: Done. Thanks!
08:32:12 <Botje_> tux91: nothing, except it will keep on looping
08:32:19 <BONUS> whathappens on fact 0?
08:32:24 <Botje_> you probably want a base case fact 1 = 1
08:32:28 <tux91> well, i have: let fact 1 = 1
08:32:33 <sam__> Botje_: What is that?
08:32:35 <Botje_> then that should work
08:32:37 <nicknull> sclv: i onyl have the binaries, the executabe command jne interface.
08:32:44 <nicknull> saizan: ^^ posted link
08:32:50 <tux91> Botje_: it doesn't, says stack overflow
08:32:54 <Botje_> sam__: it tells vim a tab is equal to two spaces, instead of 8
08:32:59 <LarstiQ> BONUS: did you see the comment I made about http://learnyouahaskell.com/ ?
08:33:01 <lambdabot> Title: Learn You a Haskell for Great Good!
08:33:03 <nicknull> Database\HDBC\Sqlite3\Statement.hsc:40:21: sqlite3.h: No such file or directory
08:33:06 <nicknull> ah yes
08:33:08 <BONUS> LarstiQ: what comment?
08:33:11 <Botje_> tux91: can you put your code on http://hpaste.org?
08:33:15 <vixey> tux91: You have probably put them in the wrong order
08:33:16 <LarstiQ> BONUS: I'll take that as a no :)
08:33:19 <BONUS> i just have irc open in the background :)
08:33:26 <tux91> vixey: i put the base case before
08:33:29 <LarstiQ> BONUS: found some typos
08:33:31 <sam__> Botje_: Whtat do I need to add to vimrc?
08:33:35 <sam__> *what
08:33:35 <BONUS> ooh, cool!
08:33:40 <BONUS> where are they
08:33:43 <Botje_> sam__: what BONUS said above
08:33:47 <LarstiQ> BONUS: But I'm not currently at home, and I don't recall off the top of my head
08:33:48 <Botje_> 17:31 < BONUS> also i'd set: tabstop=4, expandtab, shiftiwdth=4, softtabstop=4
08:33:55 <BONUS> ah
08:33:56 <nicknull> tux91: fact x = if x > 1 then x * fact (x-1) else 1
08:34:05 <BONUS> LarstiQ when you get home can you just tell lambdabot to tell me or shoot me a mail?
08:34:08 <Badger> BONUS: haha, nice tutorial
08:34:10 <BONUS> i'd appreciate that a lot!
08:34:10 <LarstiQ> BONUS: sure
08:34:12 <BONUS> haha thanks
08:34:17 <Deewiant> nicknull: fact x = product [1..x]
08:34:21 <sam__> Botje_: What did he say?
08:34:40 <Botje_> 17:31 < BONUS> also i'd set: tabstop=4, expandtab, shiftiwdth=4, softtabstop=4
08:34:46 <tux91> http://hpaste.org/11292
08:35:01 <Botje_> tux91: hmm, that should work.
08:35:11 <Botje_> what number are you feeding fact?
08:35:19 <tux91> Botje_: it really does give me stack overflow
08:35:19 <Botje_> and in which environment? (hugs, ghci, ghc)
08:35:25 <tux91> Botje_: 5, ghci
08:35:33 <Botje_> that sounds weird
08:35:42 <Botje_> you put that in a file and you loaded that, right?
08:35:43 <Deewiant> 5 shouldn't stack overflow :-P
08:35:51 <BONUS> sam__: try giving this vimrc a try: http://hpaste.org/11293
08:36:04 <Deewiant> BONUS: s/\$/4/
08:36:04 <nicknull> tuc it works
08:36:15 <tux91> can anybody confirm my code is working fine?
08:36:16 <Botje_> % wc -l .vimrc
08:36:16 <Botje_> 389 .vimrc
08:36:19 <BONUS> yeah haha
08:36:19 * Botje_ whistles
08:36:30 <Botje_> tux91: yeah, that code works for me
08:36:37 <tux91> Botje_: oh crap
08:36:50 <nicknull> product [1..n] soesnt build an intermediate lsit right?
08:36:54 <Deewiant> BONUS: 268 here
08:36:56 <BONUS> > let fact 1 = 1; fact x = x * fact (x -1) in fact 5
08:36:57 <lambdabot>   120
08:37:00 <Badger> BONUS: needs more monads :P
08:37:05 <BONUS> haha
08:37:07 <Deewiant> nicknull: certainly not if optimized
08:37:08 <BONUS> they will come, no worries
08:37:28 <int-e> tux91: what did you type?
08:37:42 <hoknamahn> hi guys. what is the usual practice in Haskell when you have two overlapping names of functions (one function defined in Prelude and another one - in your custom module). For example we have a length function defined in the Prelude and one of our custom classes has name with same method. Is it good idea to use same names or better to rename custom method to make unique name?
08:37:46 <tux91> int-e: the link is above
08:37:56 <BONUS> hoknamahn: do a qualified import
08:38:05 <BONUS> for instance if you do
08:38:09 <sam__> BONUS: Thanks!
08:38:13 <BONUS> import qualified Data.Map as Map then you can do
08:38:17 <BONUS> Map.filter
08:38:19 <BONUS> np :)
08:38:28 <Deewiant> hoknamahn: don't rename it, maybe put a note saying that it conflicts with Prelude functions
08:38:30 <hoknamahn> BONUS thanks :)
08:38:44 <BONUS> so filter will refer to the normal filter and Map.filter to the one from the module
08:39:01 <tux91> what are decent compilers for linux besides ghc?
08:39:05 <hoknamahn> sounds good :)
08:39:33 <int-e> tux91: well, the code works fine. the only way I can imagine that you got a stack overflow is that you typed 'let fact 1 = 1' and then 'let fact x = x * fact (x - 1)' in ghci.
08:40:01 <tux91> int-e: i did
08:40:09 <int-e> tux91: see, that's what I asked.
08:40:21 <BONUS> you either gotta write that in a file and then load the file (without the let)
08:40:26 <BONUS> or do
08:40:38 <BONUS> let fact 1 = 1; fact x = x * fact (x-1)
08:40:46 <int-e> tux91: now what you've got there is two definitions, the second shadowing the first. what you should've typed is ... what BONUS just wrote.
08:41:07 <sclv> nicknull: did you figure out the sqlite issue?
08:41:13 <nicknull> tux91: yes it works fine, but will loop infintely for x< 0
08:41:20 <sclv> the binaries aren't very important -- its an embedded library.
08:41:29 <tux91> it says  parse error on input `='
08:41:30 <nicknull> also it is not tailrecursive and not strict
08:41:34 <sclv> they're just conveniences for accessing the database.
08:42:13 <nicknull> hok: import qualified SomeModule as SM; SM.length
08:42:57 <tux91> what is the problem now?
08:43:07 <Botje_> tux91: works for me, i think you typo'd
08:43:17 <tux91> fact x = x * fact (x - 1)
08:43:18 <Botje_> try copying BONUS' line
08:43:27 <vixey> same problem as before
08:43:49 <Botje_> tux91: the problem is you first defined fact 1 = 1, and then _overwrote_ that definition with let fact x = ...
08:43:50 <plutonas> having a function that takes another function lets say named f2 as it's argument, and uses it as (compare `on` f2), can i replace that call to not use `on` as it's ghc specific?
08:43:58 <plutonas> (i mean without implementing it myself)
08:44:00 <Botje_> thus ghci doesn't find a base case
08:44:15 <Botje_> plutonas: you can define on yourself if you're worried
08:44:26 <tux91> Botje_: 1) let fact 1 = 1 2) fact x = x * fact (x-1)
08:44:27 <plutonas> @src on
08:44:27 <lambdabot> (*) `on` f = \x y -> f x * f y
08:44:32 <Botje_> tux91: don't do that.
08:44:36 <Botje_> 17:40 < BONUS> let fact 1 = 1; fact x = x * fact (x-1)
08:44:38 <Botje_> do that
08:44:39 <Botje_> in one line
08:44:46 <mopped> Is the only difference between id and const is that const takes two argumetns?
08:44:48 <hoknamahn> cool guys qualified import roks :) thanks
08:44:49 <Botje_> or write your definitions into a file and :l that
08:45:06 <Botje_> mopped: pretty much
08:45:12 <Botje_> it discards its second argument
08:45:14 <tux91> oh now it works
08:45:19 <tux91> thanks guys!
08:45:29 <Botje_> yeah
08:45:36 <Botje_> putting stuff in a file and :l that is generally best :)
08:45:46 <int-e> tux91: it's really often easier to put the declarations in a file and :load it in ghci (:r reloads the latest file)
08:47:27 <tux91> ok, so now i'm trying to compile that... http://hpaste.org/11294
08:47:39 <tux91> and it gives me a parse error
08:47:50 <Saizan> mopped: that's an usual way to put it but it looks right :) const x y = x
08:47:54 <int-e> tux91: main = print (fact 5)
08:49:12 <tux91> int-e: ok that works thanks
08:49:22 <int-e> tux91: ghci is special. it acts similar to an implicit do block, so it accepts expressions as well as 'let' bindings. in haskell modules, you can only put bindings. 'main' is the function that is executed when a haskell program is run.
08:49:26 <tux91> how fast is compiled haskell compared to python?
08:49:31 <Deewiant> faster
08:49:34 <nicknull> tux: much faster
08:49:49 <nicknull> but u have to know what can cause problems
08:49:57 <LarstiQ> compared to what form of python?
08:49:59 <nicknull> laziness can be a curse and a blessing
08:50:10 <nicknull> lazy evaluation that is
08:50:14 <tux91> are there any system-level libraries, like the 'os module' in python?
08:50:27 <Deewiant> tux91: yes, the System hierarchy
08:50:30 <Zao> tux91: Unsurprisingly, they're in the System hierarchy :)
08:50:42 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/index.html
08:50:43 <lambdabot> Title: Haskell Hierarchical Libraries
08:51:11 <tux91> what the hell is hierarchy?
08:51:24 <jeffz> tux91: you can use a dictionary if you don't know the meaning of a word
08:52:23 <tux91> jeffz: oh i just thought it was used in some special haskell-related meaning
08:52:33 <jeffz> tux91: no, there's nothing specific to haskell about the meaning.
08:52:37 <bohdan> hi all;
08:52:44 <thoughtpolice> @users
08:52:44 <lambdabot> Maximum users seen in #haskell: 521, currently: 519 (99.6%), active: 23 (4.4%)
08:52:45 <bohdan> I'm very new to haskell
08:52:49 <BONUS> omg
08:52:56 <thoughtpolice> close :]
08:53:09 <bohdan> I'm trying to solve the 3n+1 problem from UVA (http://acm.uva.es/p/v1/100.html) in haskell
08:53:11 <lambdabot> Title: The 3n + 1 problem
08:53:13 <thoughtpolice> @users
08:53:13 <lambdabot> Maximum users seen in #haskell: 521, currently: 520 (99.8%), active: 23 (4.4%)
08:53:22 <BONUS> @users
08:53:22 <lambdabot> Maximum users seen in #haskell: 521, currently: 521 (100.0%), active: 23 (4.4%)
08:53:29 <BONUS> ok one more
08:53:34 <BONUS> invite a friend guys
08:53:44 <BONUS> i dont have any
08:53:47 <bohdan> but the problem so far if that I don't know how to efficiently implement memoization
08:54:03 <bohdan> can you point me to a tutorial that would explain how to do it?
08:54:15 <BONUS> w000t
08:54:16 <BONUS> @users
08:54:16 <lambdabot> Maximum users seen in #haskell: 522, currently: 522 (100.0%), active: 23 (4.4%)
08:54:27 <bohdan> I found http://www.haskell.org/haskellwiki/Memoization, but it's a bit complicated for my current understanding of haskell
08:54:29 <lambdabot> Title: Memoization - HaskellWiki
08:54:31 <BONUS> cinema congratulations you're the 522th user
08:54:38 <bohdan> anyone?
08:54:41 <BONUS> bohdan
08:54:42 <hoknamahn> guys is it possible to specify which functions I'd like to make qualified?
08:54:51 <BONUS> depends on the problem
08:55:10 <BONUS> if that's too advanced for you, it's good to look at the exact problem that needs memoization
08:55:20 <bohdan> i've posted the link
08:55:24 <BONUS> rather than just trying to think of how to generally memoize everything
08:55:28 <BONUS> i'm sorry i wasnt following earlier
08:55:30 <BONUS> could you repost
08:55:37 <bohdan> http://acm.uva.es/p/v1/100.html
08:55:38 <lambdabot> Title: The 3n + 1 problem
08:55:44 <conal> bohdan: see http://conal.net/blog and http://luqui.org/blog for three recent posts about memoization
08:55:46 <lambdabot> Title: Conal Elliott
08:56:02 <BONUS> hoknamahn: you can do import SomeModule hiding (foo, bar) and then do import qualified SomeModule (foo, bar) as SM
08:56:05 <BONUS> i think..
08:56:30 <hoknamahn> BONUS, thanks
08:56:34 <BONUS> oh, that's a collatz sequence isnt it?
08:57:25 <BONUS> bohdan, do you know how to deal with arrays?
08:57:33 <bohdan> mmm no :)
08:57:52 <bohdan> right now i've almost finished http://learnyouahaskell.com/
08:57:53 <BONUS> basically an array is like a list, only it has a fixed length, but you can quickly jump to any index in an array
08:57:53 <lambdabot> Title: Learn You a Haskell for Great Good!
08:58:02 <BONUS> hmm thats a nice tutorial, i'll have to check it out
08:58:11 <Botje_> :p
08:58:13 <BONUS> anyway, you can do something like this then
08:59:18 <BONUS> instead of following the chain, you check if you have it in the array
08:59:36 <BONUS> for instance if you get a 34 for 3n + 1, you check the 34th index of the array
08:59:57 <bohdan> actually my function has 2 parameters, but I guess it's all the same
09:00:00 <BONUS> if it's there, just use the length from it, otherwise follow it
09:00:05 <BONUS> hmm it's kind of hard to explain
09:00:12 <bohdan> wait
09:00:18 <Saizan> BONUS: there's a way simple solution using lazy arrays
09:00:22 <Saizan> *simpler
09:00:22 <bohdan> but I don't know the max size
09:00:58 <Botje_> you can't
09:01:12 <Botje_> but you could memoize for all numbers <= m
09:01:17 <conal> BONUS: i like your tutorial!  one suggestion so far: in http://learnyouahaskell.com/starting-out/#babys-first-functions, i'd use the word "function" to mean a value of function type.  sometime you say "function" where i'd say "definition" or "name", e.g. conanO'Brien.
09:01:18 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
09:01:30 <Botje_> or j, even
09:01:47 <Botje_> and for all numbers above j use the normal way
09:01:54 <BONUS> conal: thanks! yeah, i think you're right, i'll have to look at standardizing the terminology
09:02:02 <C-Keen> I got a question to http://hpaste.org/11295#a0
09:02:47 <bohdan> also while I'm here, how do I write unit tests?
09:03:12 <thoughtpolice> bohdan: quickcheck is good, but it is for pure functions
09:03:25 <thoughtpolice> for testing that needs IO  you should check out HUnit
09:03:29 <bohdan> thoughtpolice: would work for me
09:03:33 <bohdan> url?
09:03:40 <Botje_> C-Keen: addSymbol is probably returning a Nothing value
09:03:45 <Botje_> @src fromJust
09:03:45 <lambdabot> fromJust Nothing  = undefined
09:03:45 <lambdabot> fromJust (Just x) = x
09:03:50 <Saizan_> bohdan: a simple example of memoization with arrays http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
09:03:51 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
09:03:54 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:03:54 <lambdabot> Title: HackageDB: QuickCheck-2.1.0.1, http://tinyurl.com/6nf83l
09:03:57 <Botje_> and fromJust Nothing = undefined
09:04:01 <thoughtpolice> ^^ quickcheck is awesome, seriously
09:04:12 <C-Keen> Botje_: hm...
09:04:18 <Botje_> but i can't help you further without knowing how addSymbol works :p
09:05:41 <C-Keen> Botje_: oh sorry I forgot to add it
09:06:06 <bohdan> ok thanks everyone I'll report on my progress when I'm though with it :)
09:06:16 <bohdan> s/when/if/
09:06:54 <C-Keen> Botje_: http://hpaste.org/11295#a1
09:07:28 <C-Keen> Botje_: getDict is missing which extracts the Map out of the Dict data type
09:07:38 <C-Keen> s,Dict,Grammar,
09:07:56 <BONUS> bohdan if you want, i have the solution for http://projecteuler.net/index.php?section=problems&id=14
09:07:57 <lambdabot> Title: Problem 14 - Project Euler
09:07:59 <hoknamahn> guys can we overload a lenght function for work with custom type?
09:07:59 <BONUS> which is basically the same thing
09:08:12 <BONUS> it's not optimal, i did it when i was just beginning to learn haskell, but it does work
09:08:19 <BONUS> and uses memoization
09:08:59 <bohdan> BONUS: yes, it's a subproblem; but no thanks I'm more interested in *why* then in *how*, so I'd rather get through it myself :)
09:09:12 <BONUS> haha, ok :D
09:10:00 <Botje_> C-Keen: well, the obvious conclusion is that somehow the nonterm t is already present in the map
09:10:15 <Botje_> so your function returns Nothing and all hell breaks loose
09:10:18 <mauke> hoknamahn: class HasLength a where length :: a -> Int
09:10:21 <C-Keen> Botje_: it can't.  addSymbol emptyGrammar (Term 'a') []
09:10:21 <C-Keen> Just (fromList *** Exception: Prelude.undefined
09:10:28 <C-Keen> Botje_: gets me the same
09:10:30 <hoknamahn> mauke thx
09:11:05 <BONUS> @users
09:11:06 <lambdabot> Maximum users seen in #haskell: 522, currently: 520 (99.6%), active: 25 (4.8%)
09:11:40 <Saizan_> we need to be more successful at avoiding success
09:11:44 <Botje_> C-Keen: uh. your paste doesn't show what happens when you pass it a Term
09:11:48 <bohdan> BONUS: also FYI for your tutorial, in os X you can do 'apt-get install hugs' if you have fink installed.
09:11:50 <BONUS> haha
09:12:03 <BONUS> hmm, really?
09:12:10 <Botje_> osx has apt-get?
09:12:19 <bohdan> not ghc though :(
09:12:26 <BONUS> ah
09:12:28 <bohdan> Botje_: there's apt-get for os x, yes
09:12:44 <bohdan> Botje_: i'd bet there's one for windows too
09:12:49 <Botje_> *shiver*
09:13:56 <C-Keen> Botje_: oh *duh* Thanks I am an idiot...
09:15:41 <C-Keen> Botje_: I forgot some bla c = undefined in my code elsewhere
09:15:43 <C-Keen> *sigh*
09:15:46 <Botje_> :)
09:15:57 <Botje_> use error "TODO" instead
09:16:11 <Botje_> that'll make it a bit more obvious :)
09:17:24 <aCiD2> Hi, I'm trying to write a FFI to mpg123 - mainly as an exercise to learn how FFI works. I have tried http://hpaste.org/11296, but I can't get it to compile - output of ghc is at the bottom of that paste. Can anyone see what I'm doing wrong?
09:18:14 <C-Keen> Botje_: ah nice hint, thanks! I just wanted the type checker to be happy really quick
09:18:54 <pyNem> @users
09:18:54 <lambdabot> Maximum users seen in #haskell: 524, currently: 524 (100.0%), active: 25 (4.8%)
09:19:53 <mauke> aCiD2: there is no Main.main
09:20:45 <cinema> BONUS: we need 2 more users to be in the top ten
09:20:53 <BONUS> top ten channels?
09:21:06 <BONUS> aCiD2: try compiling like this: ghc --make Mpg132
09:21:10 <cinema> BONUS: yes, we are the 11th
09:21:12 <pyNem> I need to be able to use Parsec effectively.  Does anyone know any good tutorials?
09:21:25 <BONUS> where do you see the top 10 channels
09:21:28 <aCiD2> BONUS: thanks, trying that now
09:21:31 <BONUS> @where RWH
09:21:32 <lambdabot> http://www.realworldhaskell.org/blog/
09:21:40 <BONUS> pyNem: look at this book
09:21:47 <pyNem> BONUS, will do :)
09:21:51 <BONUS> it has a cool chapter on the parsec library
09:21:51 <cinema> BONUS: I have it in my 'Channels' menu, sorted by users
09:22:01 <BONUS> haha
09:22:06 <mopped> http://hpaste.org/11297 can anyone lend a hand why it doesnt like this function?
09:23:17 <Deewiant> mopped: looks like the code the message is complaining about is not the same as the code you pasted
09:23:36 <aCiD2> BONUS: aha, that got it all working, thanks
09:23:40 <mopped> yeah, its pretty dumb not to save your work
09:23:41 <mopped> :D
09:24:22 <BONUS> kewl
09:26:16 <Deewiant> gah, gmane is over 5 hours behind
09:30:18 <C-Keen> hm, I have a function that takes [a] -> b -> [a] and I want to map this to a function a -> b -> [a]. How do I pass the b here in the map call?
09:30:27 <Facedown> wait - haskell's only unary is the -? what about +? is it classified as arithmetic?
09:30:47 <Facedown> hm, seems that + requires 2 operands
09:31:29 <BONUS> - is kind of strange in haskell, yeah
09:31:34 <mauke> C-Keen: huh?
09:40:28 <BONUS> @users
09:40:28 <lambdabot> Maximum users seen in #haskell: 529, currently: 529 (100.0%), active: 17 (3.2%)
09:46:23 <nullified> anyone good with sqlite3+windows+ghc?
09:46:57 <jeffz> nullified, I set it up once, several months ago and it appeared to work.
09:49:15 <nullified> hdbc works
09:49:33 <nullified> hdbc-sqlite complains couldnt find sqlite3.h
09:49:34 <nullified> http://hpaste.org/11291
09:49:55 <nullified> how did u install sqlite3?
09:51:15 <jeffz> I downloaded the packages, built and installed them without cabal, I see you're using cygwin, I didn't use that either.
09:51:39 <mopped> http://hpaste.org/11298 any ideas on whats going wrong? I cant find out :\
09:52:38 <Botje_> mopped: you promise primeFactors has type [Integer]
09:52:43 <Botje_> but you return n in the first case
09:52:49 <Botje_> did you mean [n] ? :)
09:53:59 <mopped> sure do
09:54:27 <mopped> i should read the errorm essage better
09:54:31 <mopped> I was checking primeFac' :P
09:54:36 <Botje_> :)
09:55:03 <arjanb> mopped: it might help to give functions in a where clause explicit signatures
09:56:20 <pyNem> @users
09:56:21 <lambdabot> Maximum users seen in #haskell: 530, currently: 528 (99.6%), active: 14 (2.7%)
09:57:20 <mopped> what do you mean arjanb?
09:57:48 <nullified> jeffz: are yout alkin about the sqlite3 sources? that doesnt hav anything to do with haskell? but where does ghc and cabal look for sqlite3 sources?
09:59:17 <jre2> is there an easy way to do hGetLine but with a timeout?
09:59:31 <jeffz> nullified: it looks wherever the standard search path is for includes
09:59:48 <arjanb> mopped: adding primeFac' :: [Integer] -> Integer -> Integer -> [Integer]
09:59:56 <mopped> aha
10:00:30 <mopped> Is it possible to iterate digits of numbers and if not, how do I convert numbers into a list?
10:01:31 <mopped> or to a string, either! :P
10:03:02 <nullified>  undefined reference to `WinMain@16'
10:03:02 <nullified> collect2: ld returned 1 exit status
10:03:10 <nullified> hwn i gcc sqlite3.c
10:03:30 <arjanb> mopped: just use show
10:03:54 <Botje_> @hoogle digit
10:03:55 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
10:03:55 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
10:03:55 <lambdabot> Data.Char digitToInt :: Char -> Int
10:04:03 <Botje_> map digitToInt $ show x
10:04:08 <Botje_> or
10:04:21 <Botje_> map (read . return) $ show x
10:05:12 <jeffz> nullified: that's not how you build sqlite3
10:06:02 <jeffz> nullified: I don't think you need to build it either, I don't remember doing so, possibly I just provided the header and used a binary dist of sqlite
10:14:27 <nullified> how do you mean provide the header?
10:17:10 <alson> quick question about the GHC RTS: is there any way to find out which functions are bound/in-scope while inside a program?  For example, in a web server, it's easy to check the URI and then check the filesystem for files, but how would I [programatically] do the same thing for functions?
10:18:40 <jeffz> alson: you could keep a list of them or maybe a Map.
10:19:51 <jeffz> alson: why do you want to do this anyway?
10:19:56 <alson> jeffz: yeah, I'm trying to avoid having to do that configuration work...  I'd love for the program to be able to determine which URIs are valid.  Also, I could use the plugin mechanism to load-on-demand, but I was hoping that there was a straightforward way to inspect the RTS.
10:19:59 <mopped> foldr (\x y -> (sumDigits x) + (sumDigits y)) 0 [65837, 5, 5, 3] <-- This works on some lists, others it doesn't, sumDigits works correctly, am I using foldr incorrectly?
10:20:05 <jeffz> ah
10:20:21 <alson> jeffz: to serve webapps...
10:22:02 <Botje_> mopped: what do you mean "doesn't work"
10:22:40 <jeffz> alson: it's not much configuration work to write foo = Map.fromList [("bar", bar),...and so on, if it suits your purpose.
10:23:41 <alson> jeffz: I'm starting to think that that's the best short-term solution until I get back to using the runtime loader...
10:24:17 <Facedown> is there a boolean constructor of some sort, to convert say 1 to True? or is that just not how it works in Haskell
10:24:33 <mopped> Gives an incorrect answer Botje_
10:24:43 <Facedown> I want to write a conditional where any number that is not 0 evaluates to True
10:24:50 <int-e> mopped: what would the correct answer be?
10:25:03 <mrd> Facedown: what's wrong with (/=0)?
10:25:11 <Facedown> :o.
10:25:25 <Facedown> well i'm used to C, if ( num ) { } but i guess that'lld o
10:25:41 <mrd> well Haskell is a strongly typed language, so you don't get to mix up booleans and numbers
10:25:55 <mrd> say what you mean, in other words
10:26:01 <Facedown> so there are no constructors/conversions that you can explicitly do?
10:26:01 <mopped> 6+5+8+3+7 + 5 + 5 + 3
10:26:02 <Botje_> mopped: oh.
10:26:03 <mauke> eh, you can easily implement that yourself
10:26:08 <mrd> explicit sure
10:26:09 <mauke> just write your own "if"
10:26:14 <rwbarton> Facedown: (/=0) is exactly that conversion
10:26:14 <mrd> that's what (/=0) is :)
10:26:16 <Botje_> mopped: you keep counting the separate digits of the intermediate results too
10:26:17 <Facedown> heh
10:26:21 <mrd> > (/=0) 1
10:26:22 <lambdabot>   True
10:26:29 <mrd> > 1 /= 0
10:26:31 <lambdabot>   True
10:26:34 <Botje_> you probably want \x y -> sumDigits x + y
10:26:36 <mopped> yeah
10:26:44 <mopped> ah, probably
10:26:59 <Botje_> alternatively, you could map sumDigits over your list first and then just sum it
10:27:06 <mopped> smart
10:27:07 <rwbarton> mopped: no, you probably want a map and a sum.  (Which is equivalent, but again, say what you mean)
10:27:08 <DuClare> Is 2 spaces too short for a tab?
10:27:17 <int-e> mopped: foldr (\x y -> (sumDigits x) + y) 0 [65837, 5, 5, 3]  should do what you want, but   sum (map sumDigts [...]) will be easier to write and understand.
10:27:20 <Botje_> both are equivalent, but that shows the intent better, i think
10:27:55 <int-e> @quote fugue
10:27:55 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:27:56 <rwbarton> alson: You want to take a string and at runtime turn it into the value of the function with that name?
10:28:08 <alson> nwbarton: yep
10:28:12 <arjanb> DuClare: just don't use tabs :)
10:28:40 <DuClare> arjanb, I prefer to hit tab once rather than space a dozen times.  But my editor inserts spaces
10:28:49 <DuClare> I was just wondering what's the smallest amount of spaces that works
10:28:50 <DuClare> :o
10:28:54 <rwbarton> alson: Yeah, a map is the only way.  The RTS doesn't even know about arbitrary functions in scope, they may be inlined, or not compiled in at all
10:30:45 <alson> rwbarton: seems as though the other way to go is to use hs-plugins.
10:31:22 <alson> rwbarton: that way I can automatically build the Map String WebFunction
10:32:07 <Cale> ivanm: I'm pretty sure for the type of calculation you're doing it seems reasonable to just filter the dataset so that only the numbers significantly affecting the result are present in the first place.
10:32:25 <hoknamahn> guys, how to avoid this message
10:32:30 <hoknamahn> Vector2.hs:34:0:
10:32:30 <hoknamahn>     Warning: No explicit method nor default method for `Vector.zComp'
10:32:30 <hoknamahn>     In the instance declaration for `Vector Vector2'
10:32:38 <rwbarton> alson: yeah, effectively by having a module export list
10:32:46 <hoknamahn> should I use hiding when import module?
10:32:59 <mauke> hoknamahn: by defining zComp for Vector2
10:33:14 <hoknamahn> zComp doesn't have any sense for Vector2
10:33:22 <hoknamahn> it's 2d space
10:33:38 <mauke> then you're screwed
10:33:44 <hoknamahn> hmmm
10:33:48 <hoknamahn> why?
10:34:00 <rwbarton> then either (1) don't make Vector2 an instance of Vector or (2) zComp = error "programmer error blah blah blah"
10:34:15 <linolium> can I do this in a main do block? catch ([r, w, l] <- doReadCase) (return ())
10:34:40 <hoknamahn> hummm both 1 and 2 don't seem to be  good solutions
10:34:53 <rwbarton> (3) figure out what type class you actually want
10:34:57 <ddarius> linolium: That's not syntactically correct
10:35:33 <linolium> ddarius: ah, I see.  How do I say, "If things go well, take the three numbers from doReadCase and put them in r, w, l.  Otherwise, end the program."
10:36:15 <rwbarton> linolium: If you're not picky about exactly how the program ends, just write   [r, w, l] <- doReadCase
10:36:26 <linolium> rwbarton: I would like it to end silently
10:36:34 <hoknamahn> rwbarton, i'm defining generic vector class which can be useful for 2d, 3d, 4d vectors and instances of this class... so for 2d vectors zComp doesn't have any sense as well as wComp for 3d vectors
10:36:37 <ddarius> :t catch
10:36:38 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
10:36:57 <mauke> hoknamahn: then why is zComp part of the class?
10:37:02 <rwbarton> linolium: alternatively   [r, w, l] <- catch doReadCase (\_ -> exitWith exitSuccess)
10:37:04 <ddarius> linolium: catch returns a value, so use exitWith in the catch block if you want to exit the program on an exception
10:37:13 <ddarius> linolium: As rwbarton demonstrated.
10:37:17 <dmwit_> linolium: You may just need an extra "do" inside the first argument to catch.
10:37:30 <ddarius> Incidentally, return is not like return in C.  It doesn't cause a function to return.
10:37:41 <dmwit_> linolium: Note that r, w, and l will not be bound outside of the catch, of course.
10:37:41 <ddarius> > do return 1; return 2; return 3;
10:37:42 <hoknamahn> mauke so you want to say that I can define only common methods in Vector and add specific in each instance?
10:37:42 <lambdabot>       No instance for (Show (t t1))
10:37:43 <lambdabot>        arising from a use of `show' at <i...
10:38:03 <mauke> hoknamahn: yeah, that's how interfaces work
10:38:04 <dmwit_> > do return 1; return 2; return 3 :: [Int]
10:38:05 <lambdabot>   [3]
10:38:24 <ddarius> dmwit: I was also going to use [Int] but then I said screw it.
10:38:34 <hoknamahn> mauke thank you man now it's clear :)
10:38:44 <rwbarton> hoknamahn: what's the point of zComp?  You want to be able to apply it to either a Vector3 or a Vector4?
10:39:03 <hoknamahn> rwbarton yes to both of them but not to vector2
10:39:13 <rwbarton> hoknamahn: what would the type of zComp be?
10:39:19 <dmwit> Sounds like you need to split your class up a little. =)
10:39:22 <hoknamahn> it's scalar
10:39:25 <rwbarton> no
10:39:27 <rwbarton> it is a function
10:39:34 <linolium> rwbarton: how does that work?  doesn't it need to return a list of threee integers to be correct?
10:39:40 <hoknamahn> yep with scalar result
10:39:49 <rwbarton> what is the type of that function?  e.g.,
10:39:51 <rwbarton> :t show
10:39:52 <lambdabot> forall a. (Show a) => a -> String
10:39:58 <zeno> how do i make cabal use 6.8.2?
10:40:16 <hoknamahn> zComp :: v -> Scalar
10:40:32 <rwbarton> linolium: "it"?
10:40:49 <rwbarton> hoknamahn: what is zComp "hello"?
10:41:11 <linolium> rwbarton: catch returns one of two things, right? if success, its first argument, and if failure, its second
10:41:26 <rwbarton> linolium: ok, so success is ok right?
10:41:31 <ddarius> :t exitWith
10:41:32 <lambdabot> Not in scope: `exitWith'
10:41:32 <linolium> rwbarton: yeah
10:41:49 <rwbarton> linolium: on failure, it passes the exception to the second argument.  now exitWith can "return" any type, since it never really returns at all.
10:42:02 <hoknamahn> rwbarton, zComp doesn't work with strings
10:42:13 <rwbarton> hoknamahn: the type signature you wrote says it does
10:42:20 <ddarius> In fact, the fact that it returns "anything" implies that.
10:42:44 <dmwit> linolium: Are you worried that the list you get from doReadCase might not have three elements?
10:42:49 <linolium> hmm, is it possible to catch when the user inputs 2 values and there is a Pattern match failure?  I guess that isn't an exception
10:42:57 <rwbarton> linolium: oh, hmm
10:43:07 <linolium> do I need to do this in more than one statement?
10:43:11 <dmwit> Yeah, then you need to wrap the pattern match up.
10:43:18 <hoknamahn> rwbarton, okay precisely zComp :: (Vector v) => v -> Scalar
10:43:38 <rwbarton> hoknamahn: OK, what is zComp (Vector2 3 5)?
10:43:44 <hoknamahn> 5
10:43:48 <dmwit> linolium: [l, r, w] <- catch (do [_, _, _] <- doReadCase) (\_ -> exitWith ExitSuccess)
10:43:49 <hoknamahn> oops
10:44:01 <ddarius> dmwit: Syntactically incorrect.
10:44:05 <rwbarton> dmwit: Unfortunately, you then also have to return a value from the inner do block
10:44:09 <hoknamahn> for Vector2 it shouldn't be defined
10:44:12 <dmwit> Oh, right.
10:44:16 <linolium> dmwit: you can do the <- twice?
10:44:30 <rwbarton> linolium: Maybe it's possible to wrap more of your program in catch?
10:44:31 <ddarius> And you might as well take that opportunity to convert it to a triple to better declare intent.
10:44:38 <dmwit> [l, r, w] <- catch (do x@[_, _, _] <- doReadCase; return x) (\_ -> exitWith ExitSuccess)
10:44:44 <hoknamahn> rwbarton even more I don't want to have zComp for Vector2 instance
10:45:03 <rwbarton> hoknamahn: Right, so you need some class of which Vector3 is an instance, but not Vector2
10:45:09 <dmwit> linolium: It might make sense to do this differently.
10:45:13 <dmwit> linolium: For example:
10:45:13 <Cale> hoknamahn: So you need a typeclass, it sounds like
10:45:21 <hoknamahn> aha, okay
10:45:26 <Cale> hoknamahn: With instances for each of the types which it supports.
10:45:27 <hoknamahn> i'll check it guys
10:45:39 <dmwit> do { xs <- doReadCase; case xs of [l, r, w] -> success; _ -> return () }
10:45:47 <Cale> class ZComp a where
10:45:55 <dmwit> linolium: (Assuming doReadCase doesn't throw other exceptions.)
10:45:55 <Cale>   zComp :: a -> Scalar
10:46:04 <Cale> instance ZComp Vector3 where
10:46:14 <Cale>   zComp v = ...
10:46:17 <Cale> and so on.
10:46:28 <linolium> dmwit: ah, and if it does, just replace doReadCase with the catch we had before?
10:46:38 <dmwit> right
10:47:10 <dmwit> catch doReadCase (\_ -> exit)
10:47:23 <Cale> hoknamahn: Of course, it's a good question to ask whether zComp really can't be defined in terms of more general operations on vectors (and you'd make those operations the methods of the class instead)
10:48:15 <ddarius> In that case I'd recommend try.
10:48:15 <hoknamahn> for the first look it sounds a bit complicated
10:48:16 <ddarius> :t try
10:48:17 <lambdabot> Not in scope: `try'
10:48:26 <ddarius> :t Control.Exception.try
10:48:27 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
10:49:20 <dons> here's your news for the day guys,
10:49:22 <dons>  http://www.reddit.com/r/programming/comments/782fo/harnessing_the_multicores_nested_data_parallelism/
10:49:24 <lambdabot> Title: Harnessing the Multicores: Nested Data Parallelism in Haskell (GHC's brand new v ..., http://tinyurl.com/64dy5o
10:49:29 <dons> ghc's brand new ndp vectoriser
10:49:43 <ddarius> Then you get: do xs <- try doReadCase; case xs of Right [l,r,w] -> success; _ -> return ()
10:51:36 <ddarius> 32 pages
10:52:29 <nicknull> case x of BIG FUCKING FAILT O GET A DATABASE GOING WITH HASKELL
10:53:05 <dons> nicknull?
10:53:12 <dons> no hdbc or takusen or sqlite3 for you?
10:53:12 <Cale> Hehe, now when I read SPJ's papers, I have trouble not hearing them in SPJ's voice :)
10:53:50 <nicknull> hdbc installed but hdbc-sqlite3 fails becausei it cant find sqlite3.h
10:53:52 <mauke> *** you are now reading everything in Sean Connery's voice ***
10:54:06 <nicknull> but i dont now where to put sqlite3.h (which i have now downlaoded)
10:54:20 <dons> nicknull: that means your C library, sqlite3 isn't installed properly, of course.
10:54:29 <maltem> mmm, another DPH paper :)
10:54:32 <dons> man, windows is a pain in the butt development environment.
10:54:42 <Cale> nicknull: you have to install the sqlite3 library properly, not just the .h file
10:54:47 <dons> nicknull: where do your other 3rd party C libs go?
10:55:51 <dons> nicknull: you should have something like,
10:55:52 <dons> $ ls /usr/lib/libsqlite3.so
10:55:52 <dons> libsqlite3.so@        libsqlite3.so.0@      libsqlite3.so.0.8.6*
10:56:03 <dons> $ ls /usr/include/sqlite3
10:56:03 <dons> sqlite3.h     sqlite3ext.h
10:56:09 <dons> to complete the set.
10:56:30 <dons> i think galois's low level sqlite3 binding bundles the C lib too, fwiw.
10:56:35 <dons> its much lower level than hdbc though
10:56:49 <nicknull> im on windows
10:57:08 <nicknull> should i put sqlite3.h in gcc's path?
10:57:22 <dons> you'll need to install the complete sqlite C lib, not just the header file.
10:58:10 <Cale> nicknull: The sqlite3 Haskell library is just a binding to the C library of the same name, so both have to be installed.
11:00:31 <rwbarton> No numbers in this paper?
11:02:30 <Cale> There are numbers in the subscripted p's ;)
11:02:48 <nicknull> o how do i install sqlite3 manually? i have binary-version wih the command line, now i downloaded the sourcefiles, the amalgamtion. how do install that?
11:02:55 <nicknull> dosnt work with gcc
11:03:05 <dons> sqlite3 the C library?
11:03:20 <Cale> nicknull: hmm... it might be good if there were another windows user around.
11:03:39 <dons> i see binaries here, http://www.sqlite.org/download.html
11:03:58 <Cale> I forget, is sjanssen a windows user?
11:04:11 <dons> noep
11:04:33 <Cale> Someone with an 's'-name used windows at least part of the time :)
11:04:51 <Cale> I wonder where ndm is :)
11:05:36 <Cale> It would be interesting to know what the OS usage statistics are for #haskell.
11:06:31 <mauke> /ver #haskell
11:06:48 <Cale> aha
11:07:06 <Cale> There's an FAQ for installing HDBC on windows which explains what to do.
11:07:14 <Cale> Put "sqlite3.h" from sqlite-source-3*.zip into `ghc --print-libdir`/include.
11:07:14 <Cale> Put "sqlite3.dll" from sqlitedll-3*.zip into ghc --print-libdir and into %windir%\system32.
11:07:35 <Cale> http://software.complete.org/software/wiki/hdbc/FrequentlyAskedQuestions
11:07:37 <lambdabot> http://tinyurl.com/6omdyj
11:08:03 <nicknull> i have installed hdbc
11:08:07 <nicknull> ah
11:09:27 <Cale> I don't know how there are so many programs written for windows when it's so developer-unfriendly :P
11:10:06 <Cale> "No, we don't have a standard place for libraries and header files."
11:10:14 <Kerris4> the programs are written for users instead of developers :\
11:10:31 <Cale> Kerris4: Yes, but most programs are written by developers...
11:10:34 <Kerris4> sorry, rhetorical question detector broken
11:11:54 <Kerris4> Cale: most developers have higher-ups telling them what to write. Comes with the paycheck?
11:12:23 <Cale> That's true, that probably has a lot to do with it.
11:13:21 <nicknull> `ghc --print-libdir`/include.
11:13:34 <nicknull> means c:/ghc-6.8.3/include?
11:13:53 <Cale> if c:/ghc-6.8.3 is what ghc --print-libdir  outputs
11:13:58 <C-Keen> hm, when implementing an instance Show Foo a where Foo a = "Foo " ++ show as, why is that wrong?
11:14:07 <C-Keen> s,as,a,
11:14:19 <Cale> Haha, actually that's pretty funny as well... using unix shell syntax to tell windows users where to put files :P
11:14:20 <mauke> where Foo looks like a syntax error
11:14:45 <dolio>  instance Show (Foo a) where show (Foo a) = ...
11:14:47 <Cale> C-Keen: parens
11:15:24 <C-Keen> ok
11:16:34 <dolio> It probably also displays wrong for certain things.
11:16:47 <dolio> Like 'show (Foo (Just a)) = "Foo Just a"'
11:18:09 <Cale> C-Keen: Note that a very similar instance would be written by just adding "deriving (Show)" to the end of your data/newtype declaration for Foo.
11:18:21 <Cale> (just in case you didn't know about that)
11:18:22 <dolio> > "Foo " ++ show (Just 9)
11:18:23 <lambdabot>   "Foo Just 9"
11:18:50 <C-Keen> Cale: that's what I had before
11:19:08 <dolio> > "Foo " ++ showsPrec 10 (Just 9) ""
11:19:10 <lambdabot>   "Foo Just 9"
11:19:16 <dolio> > "Foo " ++ showsPrec 11 (Just 9) ""
11:19:18 <lambdabot>   "Foo (Just 9)"
11:19:49 <nicknull> boom!
11:20:36 <nicknull> maybe (Success, Fail) Just Success
11:23:42 <LynxAba> hello everyone, i can't understand the MAybe type, could someone tell what does this mean: data Terr = NoTrans | Trans (Maybe Unid) Bool
11:25:16 <Cale> LynxAba: If t is any type, then a value of type Maybe t is either the value Nothing, or it is a value of the form (Just x), where x has type t.
11:25:33 <Cale> LynxAba: that is,  data Maybe t = Nothing | Just t
11:26:04 <LynxAba> mmmh, and the type Just is used for...?
11:26:13 <Cale> Just is a data constructor, not a type
11:26:26 <Cale> > Just 5
11:26:27 <lambdabot>   Just 5
11:26:47 <Cale> :t [Just 1, Just 3, Nothing, Just 7]
11:26:48 <lambdabot> forall t. (Num t) => [Maybe t]
11:27:20 <Cale> Maybe types are useful when you might or might not have a value.
11:27:34 <LynxAba> i get it now
11:29:04 <ski> > lookup "perhaps" [("maybe",0),("mayhaps",1),("perchance",2)]
11:29:05 <lambdabot>   Nothing
11:29:19 <ski> > lookup "mayhaps" [("maybe",0),("mayhaps",1),("perchance",2)]
11:29:20 <lambdabot>   Just 1
11:30:55 <LynxAba> >
11:31:02 <LynxAba> > 2+2
11:31:03 <lambdabot>   4
11:31:13 <LynxAba> hehe i was just trying it
11:31:28 <Cale> :)
11:31:42 <BONUS_> haha is anyone counting how many times lambdabot does 2+2 :D
11:31:53 <BONUS_> i recall doing it myself once haha
11:32:13 <dons> ?users
11:32:13 <lambdabot> Maximum users seen in #haskell: 535, currently: 534 (99.8%), active: 17 (3.2%)
11:32:16 <dons> huh
11:32:21 <dons> 540 is actually the record.
11:32:22 <LynxAba> hahaha really?
11:32:27 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
11:32:28 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
11:32:37 <dons> btw, guys, enjoy reading about ghc's new automatic vectoriser, http://www.reddit.com/r/programming/comments/782fo/harnessing_the_multicores_nested_data_parallelism/
11:32:40 <lambdabot> Title: Harnessing the Multicores: Nested Data Parallelism in Haskell (GHC's brand new v ..., http://tinyurl.com/64dy5o
11:32:45 * ski does `> ()' now that `@hello' doesn't give a proper answer
11:33:05 <dolio> @botcrack
11:33:05 <lambdabot> :)
11:33:09 <mauke> @hello
11:33:15 <lambdabot> Maybe you meant: help tell
11:33:32 <LynxAba> c'mon this bot is wonderful! XD
11:33:36 <ski> see ! it's being a rude fellow
11:33:51 <mauke> @slap LynxAba
11:33:51 * lambdabot pushes LynxAba from his chair
11:34:18 <LynxAba> XD is there a manual?
11:34:29 <int-e> @list
11:34:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:34:34 <LynxAba> tnx
11:34:37 <Cale> Not really a proper one.
11:34:48 <int-e> @list modules
11:34:48 <lambdabot> No module "modules" loaded
11:35:51 <mauke> @list module" "loaded
11:35:52 <lambdabot> No module "module" "loaded" loaded
11:36:01 <dons> ?users
11:36:02 <lambdabot> Maximum users seen in #haskell: 537, currently: 537 (100.0%), active: 17 (3.2%)
11:36:26 <mauke> my client says 536
11:36:30 <int-e> @dice 5d6
11:36:30 <lambdabot> 5d6 => 22
11:36:32 <ahunter> mine as well
11:36:43 <LynxAba> mine says 537
11:36:54 <dmwit> 536+ChanServ?
11:37:02 <LynxAba> possibly
11:37:04 <mauke> -!- Irssi: #haskell: Total of 537 nicks [1 ops, 0 halfops, 0 voices, 536 normal]
11:37:06 <vixey> @foo
11:37:07 <lambdabot> Maybe you meant: faq ft todo yow
11:37:12 <ski> int-e : i believe you want `@list-modules' or `@list <module>'
11:37:36 <int-e> ski: list-modules it is. thanks.
11:39:03 <nicknull> Cale ++
11:39:39 <Cale> nicknull: Get sqlite3 working?
11:42:09 <sbahra> @yow
11:42:09 <lambdabot> I have the power to HALT PRODUCTION on all TEENAGE SEX COMEDIES!!
11:43:24 <noZone> @yow
11:43:24 <lambdabot> Thousands of days of civilians ... have produced a ... feeling for the
11:43:24 <lambdabot> aesthetic modules --
11:43:48 <dolio> @keal
11:43:48 <lambdabot> 99% of my book has been erased by faulty hdd's
11:46:05 <C-Keen> Cale: What I really want to do is to 'strip of' my data type again. Say, I have data S a = This a | That a; I want to just show a on show and not have "This " ++ show a
11:46:38 <ski> strip :: S a -> a
11:46:40 <mauke> .oO( Either a a =~= (Bool, a) )
11:47:19 <C-Keen> ski: what would the implementation look like then?
11:47:19 <ski> C-Keen : you write the implementation of `strip', all fine ?
11:47:46 <C-Keen> ski: sorry I am confused
11:47:50 <ski> you haven't done much pattern-matching, yet ?
11:48:25 <Peaker> I like the "looks like you haven't run CMD" errors in ghc's compilation. Much nicer than a manual ;)
11:48:41 * vixey (a,a,a,a) =~= (4 -> a)
11:49:32 <mauke> lambda calculus tuple encoding rurgher hetnaminacumeribunketful Koebitulergillean
11:49:32 <ski> C-Keen : a value of type `S a' must either be of form `This x' for some value `x' of type `a', or of form `That y' for some value `y' of type `a'
11:49:36 <Peaker> (a,a,a,a) =~= a   no?
11:49:43 <vixey> lllol
11:49:57 <C-Keen> ski: right
11:49:58 <vixey> mauke schonfinkel
11:50:04 <ski> C-Keen : so, we want `strip' to just give the `x' alternatively `y' value, as return value, agree ?
11:50:10 <C-Keen> ski: right
11:50:16 <ski> so that is just what is written
11:50:45 <ski> C-Keen : can you imagine how to sat that `strip' converts `This x' into `x' ?
11:50:52 <ski> s/sat/write/
11:51:11 <C-Keen> strip (This x) = x ?
11:51:16 <ski> yes :)
11:51:23 <ski> now try the other case
11:51:33 <ski> (hint : it is quite similar)
11:51:43 <C-Keen> s,This,That,
11:51:53 <ski> that should work, yes
11:51:58 <ski> all fine ?
11:52:03 <C-Keen> ski: aye
11:52:54 <C-Keen> ski: I have already written something like this, I wanted to combine it with an instance of Show so that on show it would get stripped
11:53:17 <anonymouz666> is that hard to write a function to intersect two lists? without using intersect lib
11:54:14 <anonymouz666> doit [1,2,3] [3,2,4] [2,3]
11:54:59 <ski> what should `intersect [0,1,1,0,1] [0,0,1,0]' give ?
11:55:29 <anonymouz666> I'd something like that: inter :: [Int] -> [Int] -> [Int] inter a b = intersect a b
11:55:30 <nicknull> any good examples using hdbc-sqlite3 ?
11:56:09 <Sadache> there is something i dont understand in the use of monads, sometimes I see examples where functions that are passed to monads written first letter in capital, any explaination?
11:56:14 <anonymouz666> ski: 0 1 ONLY
11:56:22 <mauke> Sadache: those are constructors
11:56:43 <rwbarton> Sadache: like Just
11:56:44 <ski> anonymouz666 : why not `[0,1,0]' ?
11:56:55 <Baughn> ski: Depends. It would be reasonable for intersect to demand that its parameters are /sets/
11:57:00 <anonymouz666> 'cause I can't repeat values
11:57:02 <Baughn> In which case it's undefined
11:57:25 <Peaker> anonymouz666: then you don't want lists, you want sets
11:58:09 <Peaker> Sadache: In the value world, capital-first means its a data-constructor (which means you can use it to pattern-match).  In the type world, capital-first means its an actual type or class, and not a type variable
11:58:13 * ski thinks that *list* intersection possibly should just drop elements from both lists so that they become equal (and give some maximal such result .. hm which ?)
11:59:03 <Sadache> hmmm
11:59:06 <anonymouz666> sets?
11:59:11 <C-Keen> ski: to illustrate my initial problem, I wanted to do something like this: http://hpaste.org/11301#a1
11:59:12 <anonymouz666> sorry I don't know this
11:59:13 <Sadache> look at http://hpaste.org/5958
11:59:43 <Sadache> checkAndAdd
11:59:54 <anonymouz666> I am searching for examples
11:59:55 <Peaker> anonymouz666: Data.Set implements sets
12:00:03 <Peaker> @src Data.Set.Set
12:00:03 <lambdabot> Source not found. stty: unknown mode: doofus
12:00:10 <Peaker> @hoogle Set
12:00:10 <lambdabot> module Data.Set
12:00:10 <lambdabot> Data.Set data Set a
12:00:10 <lambdabot> System.Posix.Internals set_console_buffering :: CInt -> CInt -> IO CInt
12:00:17 <anonymouz666> but it is using intersect I won't be allowed to use that in the test
12:00:26 <Sadache> inside you ll see that IsUser is used with capital first letter whereas it is not defined so
12:00:29 <anonymouz666> I Think
12:00:47 <ski> Sadache : you need to use `show' on the `t' values to convert them to strings
12:00:48 <Peaker> C-Keen: why not use data Symbol a = Symbol Bool a ?
12:00:57 <rwbarton> Sadache: Ah, isUser and IsUser are a priori unrelated names to ghc
12:01:13 <ski> Sadache : and then you also need to replace `instance Show (Symbol a)' with `instance Show a => Show (Symbol a)', to say that you require `Show' on the `a' type there
12:01:19 <Peaker> C-Keen: in your example, you want: show (Term t) = show t
12:01:21 <rwbarton> Sadache: IsUser is a constructor of some data type
12:01:33 <Peaker> C-Keen: the result of show isn't t, but (show t), unless t is a string that you want to return
12:01:44 <C-Keen> Peaker: right, but the compiler does not like this either
12:02:04 <C-Keen> Peaker: I don't understand the error message
12:02:07 <rwbarton> C-Keen: right, because t might not have been something that can be showed.
12:02:38 <Peaker> C-Keen: the compiler is complaining that your show function is not returning a string, but the stuff inside your Term/NonTerm constructors which is an "a" and not necessarily a String
12:02:46 <Sadache> the strange thing is that the whole program is two files http://softwaresimply.blogspot.com/2008/02/finished-happs-application.html , it compiles and runs fine without any IsUser defined anywhere!
12:02:51 <lambdabot> Title: Software Simply: Finished HAppS Application, http://tinyurl.com/6bhvxk
12:03:02 <C-Keen> rwbarton: How can I enforce this?
12:03:05 <ski> C-Keen : erm, s/Sadache/C-Keen/ ..
12:03:06 <rwbarton> Sadache: It must be defined in one of the HApps modules you're importing
12:03:19 <rwbarton> C-Keen: with a class constraint on the instance,  instance Show a => Show (Symbol a) where ...
12:03:29 <C-Keen> rwbarton: ah!
12:04:03 <ski> Sadache : sorry for confusion
12:04:36 <mopped> Why do things like foldl exist when foldl' does?
12:04:52 <Peaker> @src foldl'
12:04:53 <lambdabot> foldl' f a []     = a
12:04:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:04:55 <Sadache> i am not sure, there is a isUser defined, as well as addUser and authUser, and all are used with first letter as capital
12:05:02 <Peaker> mopped: if you want laziness?
12:05:04 <mauke> Sadache: no
12:05:10 <anonymouz666> ERROR file:.\1.hs:2 - Undefined variable "intersect"
12:05:12 <C-Keen> rwbarton: ski Peaker many thanks, I am getting used to this.... I just remembered that instance types will generate functions to map the right instance, of course it then need to be one with the same properties...
12:05:13 <rwbarton> Sadache: I promise you there is no magic (de)capitalization going on
12:05:14 <Sadache> i am sure there is something i am missing
12:05:16 * ski wonders whether "confusion" is etymologically realted to "Confucius" ..
12:05:19 <anonymouz666> hugs does not have the intersect
12:05:24 <mopped> hmm ok Peaker
12:05:24 <anonymouz666> great
12:05:30 <mauke> Sadache: that's like saying "there's a squirrel defined, but it's used as 'typewriter'"
12:05:33 <dons> ?users
12:05:33 <lambdabot> Maximum users seen in #haskell: 539, currently: 535 (99.3%), active: 25 (4.7%)
12:05:53 <rwbarton> mopped: Also because the Haskell report specifies the existence of foldl, but not foldl'
12:06:07 <shapr> 535 isn't too bad.
12:06:15 <rwbarton> @yow
12:06:16 <lambdabot> Can you MAIL a BEAN CAKE?
12:06:27 <shapr> @quote
12:06:27 <lambdabot> mauke says: trees are hierarchical
12:06:47 <mauke> @vixen aspicatinal apodyl awoforess Guestubeetly
12:06:47 <lambdabot> When i get kinky, i have been known to engage in watersports... Does that turn you on as well?
12:06:57 <ski> > 2 * 5 * 53
12:06:58 <lambdabot>   530
12:07:49 <Sadache> when i delete the addUser the program does not compile anymore, and there is no addUser in both files but there is only the AddUser defined
12:08:17 <Sadache> and the compiler points me to the AddUser when i delete the addUser function!
12:09:20 <Sadache> actually it is an Happs application, aint there any precompiler doing something in code, or am i getting crazy?
12:09:50 <mauke> preflex: 8ball is Sadache going crazy?
12:09:50 <preflex>  it is certain
12:10:09 <nicknull> anyone have some haskell sqlite code they can show? like create new database, insert some rows, save/commit , query etc
12:11:34 <Sadache> i guess i found it, there is a magical $(mkMethods statement that does something i dont really understand
12:11:36 <rwbarton> Sadache: Well, there is some template haskell
12:11:44 <rwbarton> Sadache: Try compiling with -ddump-splices
12:11:53 <mauke> nicknull: http://mauke.ath.cx/dserve-sqlite-hs/
12:11:54 <lambdabot> Title: Index of /dserve-sqlite-hs
12:12:04 <Sadache> $(mkMethods ''State ['addUser, 'authUser, 'isUser, 'listUsers,
12:12:09 <conal> is there a standard empty (other than bottom) type somewhere, such as "data Void" ?
12:12:27 <Peaker> conal: why not () ?
12:12:36 <mauke> Peaker: () is not empty
12:12:39 <ski> conal : i think there used to be in 1.4 or something ..
12:12:46 <Peaker> oh, 0 values, not 1 value
12:12:51 <conal> yeah
12:12:55 <rwbarton> conal: there's one in category-extras
12:12:59 <rwbarton> , src ''Data.Void
12:13:00 <lunabot>  luna: Not in scope: type constructor or class `Data.Void'
12:13:13 <conal> thx
12:13:13 <ski> (conal : i have used such a type myself, and wished it were standard ..)
12:14:26 <mauke> .oO( newtype Void = Void Void )
12:15:30 <conal> mauke: would have fix Void, i think
12:15:49 <mauke> fix Void is all recursion, no constructors
12:15:52 <vixey> are newtypes are strict
12:15:55 <vixey> ?
12:16:08 <ski> newtype constructors are strict
12:16:11 <conal> oh yeah, newtype
12:16:21 <ski> but matching against a newtype constructor doesn't force
12:16:31 <tromp> hmm, why does my ghci 6.8.2 under Ubuntu 8.04 complain Could not find module `Control.Monad.State'?
12:16:41 <mauke> do you have mtl?
12:16:46 <ski> (but yes, i think `fix Void' would be bottom)
12:17:00 <rwbarton> so actually, newtype Void = Void Void is quite like data Void then
12:17:18 <ski> except it's not an algebraic data type
12:17:48 <tromp> > ()
12:17:49 <lambdabot>   ()
12:17:54 <vixey>   () <
12:18:21 <ski>         ()
12:18:54 <tromp> @hoogle execState
12:18:55 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
12:18:55 <lambdabot> Control.Monad.State.Strict execState :: State s a -> s -> s
12:18:55 <lambdabot> Control.Monad.State.Lazy execStateT :: Monad m => StateT s m a -> s -> m s
12:20:36 <nicknull> Right 5
12:20:47 <nicknull> fromRight (Right x) = x
12:20:55 <nicknull> what is the real fromRight function?
12:21:15 <mauke> @src fromRight
12:21:15 <lambdabot> Source not found. Are you on drugs?
12:21:16 <Botje_> that's probably it
12:21:22 <Baughn> nicknull: head . rights . (:[])
12:21:31 <Botje_> with an optional fromRight (Left _) = undefined
12:21:56 <mmorrow> either undefined id
12:22:43 <mopped> can you use guards/pattern matching in lambdas?
12:22:54 <BONUS_> pattern matching, sure
12:23:00 <mauke> at most one of them
12:23:00 <BONUS_> guards, i'd say no
12:23:05 <ddarius> Yes, but you only have one alternate
12:23:12 <mauke> > (\x | x == 2 -> ()) 2
12:23:13 <lambdabot>   <no location info>: parse error on input `|'
12:23:20 <mauke> > (\ 2 -> ()) 2
12:23:21 <lambdabot>   ()
12:23:23 <mauke> > (\ 2 -> ()) 3
12:23:25 <lambdabot>   * Exception: /tmp/7979604861367114686:69:41-49: Non-exhaustive patterns in ...
12:23:50 <BONUS_> > (\(x:xs) -> x) "HAHA"
12:23:51 <lambdabot>   'H'
12:23:53 <ski> > (\ 2 -> ()) (2::Float)
12:23:54 <lambdabot>   ()
12:23:57 <ski> > (\ 2 -> ()) (2::CReal)
12:23:59 <lambdabot>   ()
12:24:06 <vixey> > (\ 2 -> ()) (pi::CReal)
12:24:07 <lambdabot>   * Exception: /tmp/7706660852134090774:69:37-45: Non-exhaustive patterns in ...
12:24:15 <vixey> > (\22%7 -> ()) (pi::CReal)
12:24:16 <lambdabot>   <no location info>: parse error on input `%'
12:24:26 <vixey> how does it know
12:24:43 <vixey> > 2 == (2::CReal)
12:24:44 <lambdabot>   True
12:24:49 <vixey> > 2 == (2.000000000000000000000000001::CReal)
12:24:50 <lambdabot>   False
12:24:51 <ski> you should possibly wrap the quotient in parens
12:24:56 <rwbarton> vixey: try more 0s
12:25:03 <vixey> > 2 == (2.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001::CReal)
12:25:05 <lambdabot>   True
12:25:08 <vixey> > 2 == (2.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001::CReal)
12:25:09 <lambdabot>   True
12:25:26 <ddarius> % isn't a constructor
12:25:32 <vixey> > 2 == (2+0::CReal)
12:25:33 <lambdabot>   True
12:25:39 <vixey> > 2 == (2+10^-999::CReal)
12:25:41 <lambdabot>   Not in scope: `^-'
12:26:00 <vixey> @let ten ^- three = 10 ** (- three)
12:26:01 <lambdabot>  Defined.
12:26:02 <vixey> > 2 == (2+10^-999::CReal)
12:26:03 <lambdabot>   True
12:26:05 <vixey> > 2 == (2+10^-9999::CReal)
12:26:07 <lambdabot>   True
12:26:10 <vixey> > 2 == (2+10^-999999999::CReal)
12:26:21 <rwbarton> > 2^-1
12:26:23 <lambdabot>   0.1
12:26:25 <lambdabot>   thread killed
12:26:47 <vixey> rwbarton: the first parameter should be 10 :p
12:26:48 <ski> you've broken math !
12:27:08 <Baughn> > [ (n, 2 == 2 + 2^(-n)) | n <- [0..]]
12:27:14 <lambdabot>   [(0,False),(1,* Exception: Negative exponent
12:27:22 <Baughn> > [ (n, 2.0 == 2 + 2^(-n)) | n <- [0..]]
12:27:24 <lambdabot>   [(0,False),(1,* Exception: Negative exponent
12:27:27 <mauke> ^^
12:27:37 <mmorrow> heh
12:27:41 <Baughn> Right.. um, what's with vixey's exponents?
12:27:46 <Baughn> > [ (n, 2.0 == 2 + 2^^(-n)) | n <- [0..]]
12:27:47 <lambdabot>   [(0,False),(1,False),(2,False),(3,False),(4,False),(5,False),(6,False),(7,F...
12:27:55 <ski> @let 20 ^- three = 10 ** (- three)
12:27:58 <lambdabot>  Defined.
12:28:09 <roconnor> Ugh, I can't figure out how to use Data.Vec.LinAlg.
12:28:11 <mauke> > 2 ^- 3
12:28:12 <lambdabot>   * Exception: <local>:1:0-28: Non-exhaustive patterns in function ^-
12:28:31 <roconnor> oh oops
12:28:40 <Baughn> > [ (n, 2.0 == 2 + 2^^(-n)) | n <- [50..]]
12:28:41 <lambdabot>   [(50,False),(51,False),(52,True),(53,True),(54,True),(55,True),(56,True),(5...
12:28:55 <ski> (actually the `2' should have been a `1' .. :)
12:29:01 <vixey> Data.Vec.LinAlg looks horrible
12:29:13 <Baughn> So, doubles had.. how many exponent bits?
12:29:21 <roconnor> Ah I need to terminate my vectors with :. ()
12:29:26 <dmwit> If I newtype a Word32, can I still build an STUArray with it?  (Can I get GHC to derive the right instance?)
12:29:36 <Baughn> dmwit: Yes, you can use newtype deriving
12:29:49 <Baughn> dmwit: (Which is to say, a newtype can derive anything, even things ghc doesn't know how to derive)
12:29:49 <dmwit> Baughn: In this particular case, how?
12:30:12 <dmwit> (I've already got LANGUAGE GeneralizedNewtypeDeriving for a Num instance.)
12:30:36 <dmwit> But it looks like the class I need to derive an instance for has several parameters, and the Word32 goes in the middle parameter...
12:30:46 <nicknull> mauke: i cant find Database.SQLite
12:30:46 <Baughn> Well, just instance IArray UArray YourNewType, I guess
12:30:54 <nicknull> import Database.SQLite hiding seems tom work though but the next row fails
12:31:00 <rwbarton> Maybe standalone  deriving instance ...?
12:31:06 <roconnor> vixey: I need to compute the rational inverse of a 3x3 matrix
12:31:12 <roconnor> and my stupid maple license says it is expired
12:31:22 <mauke> nicknull: what?
12:31:24 <dmwit> rwbarton: Oh, how does that work?
12:31:56 <Baughn> dmwit: Hm, that doesn't look right. Tell me if it works?
12:32:07 <rwbarton> dmwit: I don't know *if* it works, but try writing the part of an instance declaration before the where, and put deriving before it
12:32:23 <rwbarton> dmwit: and turn on something like StandaloneDeriving
12:32:28 <dmwit> ok
12:32:52 <sbahra> Anyone know if there are facebook platform bindings for haskell?
12:33:04 <sbahra> I couldn't find any on hackage.
12:33:06 <Baughn> dmwit: rwbarton is referring to http://www.haskell.org/haskellwiki/GHC/Stand-alone_deriving_declarations, I believe
12:33:08 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki, http://tinyurl.com/5upqal
12:33:18 <sbahra> Oh, nm
12:33:27 <sbahra> http://groups.google.com/group/fa.haskell/browse_thread/thread/fc2a55c38efe20a6
12:33:28 <lambdabot> Title: haskell & facebook - fa.haskell | Google Groups, http://tinyurl.com/63hfyb
12:34:29 <dmwit> rwbarton: It doesn't seem to work, but I think it's not the standalone-deriving's fault:
12:34:44 <dmwit> "The data constructors of `ST' are not all in scope so you cannot derive an instance for it"
12:35:01 <rwbarton> dmwit: hpaste the code and error message?
12:35:09 <dmwit> okey-doke
12:35:17 <rwbarton> dmwit: I had this error message recently and it was a lot easier to work around than I expected.
12:35:33 <rwbarton> dmwit: But maybe the problem is that ST is the last parameter (is it?) in which case I guess this won't work
12:36:01 <dmwit> http://hpaste.org/11302
12:36:05 <dmwit> Yeah, it's the last parameter.
12:36:39 <rwbarton> Oh, yeah, the manual says it always tries to derive an instance for the last parameter
12:36:51 <dmwit> ah
12:37:10 <dmwit> Okay, I'll play fast and loose with the type system and just eradicate the newtype.
12:37:16 <dmwit> It's the simplest thing here, I think.
12:38:11 <vixey> nothing new on types.reddit ;/
12:42:50 <dons> ?users
12:42:51 <lambdabot> Maximum users seen in #haskell: 539, currently: 533 (98.9%), active: 21 (3.9%)
12:48:56 <nicknull> mauke: i mean i cna use Database.HDBC.Sqlite3 but not Database.SQLite
12:49:20 <mauke> interesting
12:49:27 <mauke> do you have the sqlite package?
12:49:40 <nicknull> yes
12:49:45 <nicknull> hackage: sqlite
12:49:47 <nicknull> hdbc
12:49:49 <nicknull> hdbc-sqlite3
12:49:53 <mauke> wat
12:50:03 <nicknull> i have all those
12:50:07 <mauke> ah, ok
12:50:13 <mauke> I only have sqlite-0.4.1
12:50:42 <nicknull> yes i have that too
12:50:50 <nicknull> but i cant import it like you do
12:53:03 <dons> what package provides Database.SQLite ?
12:53:22 <dons> galois' sqlite3 package?
12:53:28 <nicknull> sqlite-0.4.1
12:53:29 <dons> how many db packages are you installing? :)
12:53:37 <nicknull> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sqlite
12:53:38 <lambdabot> Title: HackageDB: sqlite-0.4.1
12:53:39 <dons> right, that's yet another binding to sqlite3.
12:53:41 <nicknull> all :)
12:53:43 <dons> you only need one. :)
12:53:48 <nicknull> can they interfer with each other?
12:53:53 <dons> nope
12:53:55 <nicknull> yes but i neeed examples
12:54:14 <dons> ok. did you read the realworldhaskell chapter on hdbc?
12:54:19 <nicknull> anyone with examples of hdbc-sqlite3 use?
12:54:25 <nicknull> no
12:54:31 <dons> there's a book, online :)
12:54:39 <nicknull> i will then
12:54:40 <dons> http://book.realworldhaskell.org/read/
12:54:41 <lambdabot> Title: Real World Haskell
12:54:47 <dons> ch 21.
12:54:50 <dons> all about hdbc
12:55:09 <dons> docs are good :)
12:56:51 <bohdan> I'm confused, some tutorials mention the 'layout', but e.g. YAHT just has an empty section about it
12:56:57 <bohdan> where can i read about it?
12:57:08 <dons> about haskell's layout syntax?
12:57:39 <mauke> 'layout' is indentation-based parsing
12:57:50 <bohdan> dons, yes
12:57:52 <dons> http://www.haskell.org/onlinereport/lexemes.html#lexemes-layout
12:57:53 <lambdabot> Title: Haskell 98 Lexical Structure
12:58:01 <bohdan> thanks
13:00:04 <nicknull> very nice
13:01:48 <dons> nicknull: enjoy!
13:04:21 <nicknull> doi need to do qualified imports?
13:06:54 <nicknull> a great turorial on databases as well, better than the normal ones
13:09:48 <nicknull> r cannot be used at all, when dealing with a complex data format
13:09:48 <nicknull> on regexes ^^
13:09:55 <nicknull> because they can hav exponential behaviour?
13:10:23 <nicknull> or just get way to complicated(ive seen the url-validating ones)
13:11:09 <plutonas> how can i generate a pdf file from an *.lhs?
13:12:28 <jao> lambdaTex?
13:12:30 <jao> http://gernot-heiser.org/~patrykz/lambdaTeX/
13:12:32 <lambdabot> Title: lambdaTeX
13:13:12 <rwbarton> @hackage lhs2TeX
13:13:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lhs2TeX
13:14:51 <anonymouz666> @src intersect
13:14:51 <lambdabot> intersect = intersectBy (==)
13:15:06 <anonymouz666> what
13:15:16 <anonymouz666> @src intersectBy
13:15:16 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:15:39 <plutonas> rwbarton: error page not found
13:15:40 <anonymouz666> xs ys are two different lists, right?
13:15:43 <anonymouz666> and x?
13:15:48 <plutonas> 404 Not Found
13:15:48 <plutonas> The requested resource was not found: no such package 'lhs2TeX'
13:15:55 <rwbarton> sorry, lhs2tex
13:16:14 <nicknull> would sqlite scale for something like netflix dataset? 17770movies, 500K customers, their reviews
13:18:00 <mmorrow> plutonas: here a darcs repo with a short hackable haskell.sty and a Makefile demonstrating how to go .lhs -> .pdf (or .ps) http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/
13:18:01 <lambdabot> Title: Index of /~morrow/code/haskell/cont-lhs-eg
13:18:52 <mmorrow> i believe lispy added a bunch to haskell.sty for darcs, so you may want to ask him about that
13:20:05 <mmorrow> but the relevant Makefile (assuming you have a .sty taking care of \begin{code} .. \end{code}) is http://code.haskell.org/~morrow/code/haskell/cont-lhs-eg/Makefile
13:20:44 <jeffz> nicknull: I think the sqlite faq answers that.
13:21:26 <dons> sqlite is our db of first resort
13:22:25 <anonymouz666> can someone help me to implement the intersect function?
13:22:42 <ddarius> lambdabot can
13:22:52 <mmorrow> @src
13:22:52 <lambdabot> src <id>. Display the implementation of a standard function
13:23:08 <mmorrow> @src union
13:23:08 <lambdabot> union = unionBy (==)
13:23:12 <anonymouz666> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:23:12 <nicknull> what data cn i store as parameter. lets say i make a mini-search engine and i want to index by certain words and i want to store all the posts containing that word so i want kind of like a Map where i can query the database with lets say "haskell" and gte allt he posts ontaining haskell. can i save a list of strings in the database?
13:23:12 <mmorrow> @src unionBy
13:23:13 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
13:23:23 <nicknull> anon: what does it do?
13:23:50 <anonymouz666> nicknull: == intersect
13:24:05 <anonymouz666> but I didn't understand well
13:24:06 <vixey> @hoogle By
13:24:07 <lambdabot> System.Posix.Types type ByteCount = CSize
13:24:07 <lambdabot> module Data.ByteString
13:24:07 <lambdabot> module Text.Parsec.ByteString
13:24:22 <anonymouz666> xs ys are the two given lists right ?
13:24:36 <mmorrow> yes
13:24:56 <anonymouz666> wait, I am confused
13:24:59 <anonymouz666> this eq
13:25:25 <mmorrow> [x | x <- xs, any (eq x) ys]  gives you all the x in xs such that there is some y in ys where x==y
13:25:28 <dmwit_> Clearly I do not understand the ST monad/STArrays.
13:25:52 <mmorrow> and eq is the function that defines "equality"
13:25:57 <mib_qvlk9g> finally have my own computer with a net connection again
13:26:20 <rwbarton> mib_qvlk9g: now you just need an IRC client? :)
13:26:30 <anonymouz666> mmorrow: thanks
13:26:37 <mmorrow> np
13:27:05 <mmorrow> err, i should have said .... in ys where  x `eq` y == True
13:27:28 <dmwit_> :t map
13:27:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:28:18 <anonymouz666> ERROR file:.\1.hs:2 - Undefined variable "eq"
13:28:19 <anonymouz666> nice
13:29:32 <anonymouz666> why is that?
13:29:48 <mauke> because you used a variable called 'eq' without defining it
13:29:58 <anonymouz666> I am taking more than 2 hours to solve a problem that is probably 2 lines
13:30:15 <bd_> wait
13:30:24 <vixey> anonymouz666: that sounds like a waste of time
13:30:36 <anonymouz666> I wish I could finish that
13:30:57 <nicknull> lol i get the same with haskell sometimes
13:31:03 <bd_> anonymouz666: can you paste the code into hpaste?
13:31:05 <zachk> programming in haskell is an amazing book
13:31:05 <zachk> this happens anonymouz666
13:31:05 <zachk> whats the problem
13:31:08 <bd_> (hpaste.org)
13:31:10 <nicknull> can be furstratingkly hard to do something simple, something isnt really a prolem
13:31:33 <nicknull> say the type of intersect
13:31:33 <anonymouz666> I just need to compile a program that given two lists [Int] -> [Int] returns the intersect [Int]
13:31:40 <nicknull> is it 2 lists?
13:31:48 <nicknull> but what is the intersect?
13:31:55 <zachk> all i need is functions that can take functions as an argument, a garbage collector, and something to make cons with
13:31:59 <bd_> anonymouz666: have you looked at Data.Set?
13:32:01 <nicknull> [1,2,3] intersect [4,5,6] =?
13:32:22 <bd_> nicknull: [] I'd assume
13:32:24 <anonymouz666> intersect [1,2,3,4] [2,4] = [2,4]
13:32:38 <bd_> although, what would: intersect [2,2,3] [3,3,2] be?
13:32:47 <nicknull> aha
13:33:10 <nicknull> and [1,2,3,] [4,2] is ?
13:33:13 <nicknull> and [1,2,3,4] [4,2] is ?
13:33:36 <mmorrow> , intersectBy (<) [0..9] [5..]
13:33:37 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
13:33:43 <mmorrow> oops
13:33:46 <zachk> what module is intersect from?
13:33:50 <mmorrow> , intersectBy (>) [0..9] [5..]
13:33:53 <lunabot>  luna: out of memory (requested 1048576 bytes)
13:33:56 <mmorrow> heh
13:34:08 <anonymouz666> I just want the intersection nothing more than that
13:34:10 <mmorrow> , intersectBy (>) [0..9] [5..20]
13:34:12 <lunabot>  [6,7,8,9]
13:34:32 <mmorrow> , intersectBy (==) [0..9] (1:[5..20])
13:34:34 <lunabot>  [1,5,6,7,8,9]
13:34:36 <anonymouz666> [1,2,3,4,5,1] [1,2,2,2,4] = [1,2,4]
13:34:37 <mmorrow> , intersect [0..9] (1:[5..20])
13:34:39 <lunabot>  [1,5,6,7,8,9]
13:34:46 <anonymouz666> I just can't repeat values in the result
13:34:57 <mmorrow> , nub $ intersect [1,2,3,4,5,1] [1,2,2,2,4]
13:34:57 <mauke> yes, you can
13:34:58 <lunabot>  [1,2,4]
13:35:00 <mauke> believe in yourself!
13:35:04 <mmorrow> heh
13:35:14 <mmorrow> @src nub
13:35:14 <lambdabot> nub = nubBy (==)
13:35:20 <mmorrow> @src nubBy
13:35:21 <lambdabot> nubBy eq []             =  []
13:35:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:35:41 <bd_> anonymouz666: can it sort the values?
13:35:55 <anonymouz666> bd_: yes
13:36:30 <mmorrow> , let (/\) = \xs ys -> nub (xs `intersect` ys) in [1,2,3,4,5,1] /\ [1,2,2,2,4]
13:36:32 <lunabot>  [1,2,4]
13:37:02 <mmorrow> , let (/\) = \xs ys -> (map head . group . sort) (xs `intersect` ys) in [1,2,3,4,5,1] /\ [1,2,2,2,4]
13:37:03 <bd_> , intersect [3,2,1] [4,3,2]
13:37:04 <lunabot>  [1,2,4]
13:37:06 <lunabot>  [3,2]
13:37:06 <zachk> rmdups or something like that
13:37:06 <zachk> Data.List has nub in it right?
13:37:16 <dmwit_> http://hpaste.org/11303 Who knows more than me about ST? =P
13:37:18 <bd_> @hoogle intersect
13:37:18 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
13:37:18 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:37:18 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
13:37:38 <bd_> although if this is a class exercise you're probably meant to reimplement it
13:37:44 <bd_> in which case data.set should make it easy
13:37:50 <nicknull> http://hpaste.org/11304
13:37:52 <anonymouz666> yes, correct
13:37:57 <dmwit_> I annotated with the error, too.
13:38:08 <nicknull> ^^ , might be innefficent though
13:38:22 <anonymouz666> mmorrow: and how to make these two lists dynamic?
13:38:34 <mmorrow> what do you mean?
13:38:35 <anonymouz666> ohh
13:38:38 <anonymouz666> sorry
13:38:40 <mmorrow> hehe
13:38:42 <anonymouz666> misunderstand
13:39:10 <dmwit_> Maybe I'm confused.
13:39:33 <nicknull> intersect xs ys = concat $ map (\z -> (filter (==z) xs)) ys
13:40:06 <dons> ?pl \z -> (filter (==z) xs
13:40:07 <lambdabot> (line 1, column 23):
13:40:07 <lambdabot> unexpected end of input
13:40:07 <lambdabot> expecting variable, "(", operator or ")"
13:40:15 <mmorrow> runST (return 42 :: ST Int) == 42
13:40:19 <nicknull> ?
13:40:19 <anonymouz666> nicknull: thanks for the pastebin but I don't have idea on how to compile this in Hugs... I have to add the parameters and the result etc.
13:40:19 <dons> ?pl \z -> (filter (== z) xs)
13:40:19 <lambdabot> flip filter xs . (==)
13:40:33 <anonymouz666> sorry guys I am wasting your time, I am just a beginner
13:40:36 <dons> anonymouz666: perhaps you can use ghc instead of hugs?
13:40:40 <nicknull> no worries
13:40:42 <dons> ghc's a lot lot better
13:41:09 <nicknull> the pastebin was unncessary 2 lines: the 1lner was nough
13:41:10 <nicknull> intersect xs ys = concat $ map (\z -> (filter (==z) xs)) ys
13:41:16 <nicknull> is that innefficient?
13:41:36 <nicknull> intersect xs ys = concat $ map (\z -> filter (==z) xs) ys
13:42:21 <anonymouz666> inter :: [Int] -> [Int] -> [Int] inter xs ys = concat $ map (\z -> filter (==z) xs) ys ?
13:42:24 <rwbarton> dmwit_: weird
13:42:28 <anonymouz666> oh no
13:42:30 <nicknull> wait it double matches
13:42:34 <tromp_> how does ghc find module Control.Monad.State ? my dir ghc-6.8.2/lib/base-3.0.1.0/Control/Monad has only Fix, Instances, and ST stuff in it
13:42:36 <anonymouz666> i miss the intersection function
13:42:44 <anonymouz666> ahhhh
13:42:52 <anonymouz666> nevermind... I hate haskell
13:43:00 <nicknull> it doesnt work correctly le tm see
13:43:10 <dons> :t intersect
13:43:12 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:43:12 <dmwit_> rwbarton: Even "runST (newArray (0, 0) 0)" dies, so I must be misunderstanding how to use this library.
13:43:52 <rwbarton> dmwit_: Step 1, turn on Rank2Types :)
13:43:58 <dons> tromp_: it looks in ghc-pkg list
13:43:58 <ddarius> dmwit_: The st variable escapes in that example.
13:44:02 <pdani> hi
13:44:12 <sjanssen> dmwit_: you probably need to be specific about the array's type
13:44:14 <dons> anonymouz666: what's your problem, precisely?
13:44:31 <tromp_> dons: where is that list defined?
13:44:44 <nicknull> intersect xs ys = concat $ L.nub $ map (\z -> filter (==z) xs) ys
13:44:53 <dons> tromp_: ghc-pkg list
13:44:56 <rwbarton> dmwit_: the result of the action passed to runST can't have a type involving the phantom type s.
13:44:59 <dons> its in the package.conf associated with ghc
13:45:07 <dons> ?users
13:45:08 <lambdabot> Maximum users seen in #haskell: 539, currently: 527 (97.8%), active: 24 (4.6%)
13:45:11 <rwbarton> dmwit_: runST (cache >> return 1)  works fine
13:45:29 <tromp_> ah, ghc-pkg is a shell command
13:45:35 <anonymouz666> dons: I have an exercise to do in Hugs. I need to pass the parameters and see the result. So... I need to write a program to, given two lists, return another list with the intersect.
13:46:07 <dmwit_> rwbarton, ddarius: hmmm
13:46:32 <dmwit_> rwbarton: It doesn't run fine here.
13:46:41 <dons> > intersect "haskell "pascal" -- for example?
13:46:43 <lambdabot>   <no location info>:
13:46:43 <lambdabot>      lexical error in string/character literal at chara...
13:46:49 <dons> > intersect "haskell" "pascal" -- for example?
13:46:50 <lambdabot>   "asll"
13:47:01 <rwbarton> dmwit_: Turn on Rank2Types in your ghci
13:47:10 <dons> anonymouz666: so yes, doing some programming. you'll need to think about an algorithm.
13:47:26 <dmwit_> rwbarton: Still no joy after ":set -XRank2Types".
13:47:28 <mauke> > intersperse '/' . nub $ intersect "haskell" "pascal"
13:47:29 <lambdabot>   "a/s/l"
13:47:39 <dons> heh
13:47:39 <dmwit_> rwbarton: (I also put a LANGUAGE pragma in the file.)
13:47:46 <nicknull> does id have to be an INT? or can be a string?
13:47:46 <nicknull> in sqlite3
13:48:00 <tromp_> dons: is there an easy way to findd out which of those packages has Control.Monad.State?
13:48:03 <anonymouz666> dons: I think I can do it using the pre-defined function called intersect. But I need to use in such way to run in hugs
13:48:05 <rwbarton> dmwit_: OK, also add a type signature for cache.  (Not sure exactly why it's necessary)
13:48:17 <int-e> @src intersect
13:48:17 <lambdabot> intersect = intersectBy (==)
13:48:21 <int-e> @src intersectBy
13:48:21 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:48:54 <plutonas> trying to install lhs2tex i get
13:48:57 <plutonas> ileNameUtils.lhs:11:9:
13:48:57 <plutonas>     Could not find module `System.IO.UTF8':
13:48:59 <tromp_> dons: oh, I already found out using find
13:49:03 <plutonas> anyone can help me out?
13:49:18 <dmwit_> rwbarton: Okay, something like (forall s. ST s (Cache s))?
13:49:22 <dmwit_> seems to work
13:49:29 <rwbarton> dmwit_: Right (the forall s. isn't necessary since it's at toplevel)
13:49:31 <dons> anonymouz666: import Data.List and use it then. :m + Data.List
13:49:43 <dons> tromp_: the mtl package.
13:49:53 <dons> plutonas: that's in the utf8-string package
13:49:59 <dons> plutonas: cabal install utf8-string
13:50:05 <dons> gosh, sure is a busy time of day today
13:50:37 <mmorrow> dmwit: ghci> :t newArray (0,0) 0 :: forall s. (MArray (STUArray s) Word32 (ST s)) => ST s (STUArray s Word32 Word32)
13:50:41 <plutonas> don's where do i give this command?
13:50:53 <mmorrow> runST :: forall a. (forall s. ST s a) -> a
13:51:03 <rwbarton> plutonas: if you're using cabal install to install lhs2tex, you'll have to add utf8-string to the dependencies of lhs2tex's cabal file
13:51:04 <dons> plutonas: do you have cabal-install installed?
13:51:07 <mmorrow> so you can't runST the first one because the s escapes
13:51:24 <plutonas> didn't install it myself
13:51:25 <dons> rwbarton: oh, lhs2tex is broken wrt. utf8-string?
13:51:35 <plutonas> don't know if it comes with other packages i installed
13:51:37 <dons> seems unlikely ?
13:51:37 <rwbarton> dons: Sounds like it, it's not listed anyways
13:51:52 <dons> plutonas: the package is on hackage.haskell.org
13:51:54 <dons> go grab it.
13:51:58 <rwbarton> dons: but, I don't get any such error
13:52:04 <rwbarton> dons: it's not broken
13:52:41 <nicknull> if i do: let a = map (\x -> x*x) [1..1000000], a !! 100000, then only that index will be evaluated right?
13:53:07 <nicknull> will in python, what would happen, list would be built then get the item
13:53:14 <nicknull> or with xrange maybe not?
13:53:18 <rwbarton> dmwit_: I think the type signature is necessary because ghc doesn't know there's not an instance MArray (STUArray s) Word32 (ST s') -- there's no functional dependency between s and s' (could there be?)
13:54:27 <int-e> nicknull: it will still be rather expensive -- the code will traverse the whole list to find the yet unevaluated 1000000 * 1000000 and then evaluate that.
13:54:52 <pdani> i tried to composite length with filter (length . filter) but ghci says Couldn't match expected type `[a]' against inferred type `[a1] -> [a1]'. why is this?
13:55:47 <Baughn> pdani: To put it crudely (and incorrectly, really), . only works with functions of one argument
13:55:48 <int-e> pdani: because filter takes two arguments
13:55:55 <andrewsw> pdani: I think it's because the type of filter is [a]->[a]
13:56:06 <Baughn> :t filter
13:56:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:56:10 <int-e> pdani: (length . filter p) where p is a predicate will work.
13:56:12 <Baughn> andrewsw: Well, no.
13:56:19 <nicknull> let lf pred = length . filter pred
13:56:20 <andrewsw> pdani: and you're trying to apply length to filter and not the result of filtering?
13:56:25 <int-e> @type (length .) . filter
13:56:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
13:56:36 <Baughn> @pl \p l -> length (filter p l)
13:56:36 <lambdabot> (length .) . filter
13:56:40 <nicknull> u need the predicate it seems
13:56:53 <int-e> > (length . filter even) [1..10]
13:56:54 <lambdabot>   5
13:56:55 <pdani> oh thx
13:57:10 <nicknull> ah nice, you dont: let lf = (length .) . filter
13:57:19 <andrewsw> Baughn: yeah, sorry. But it's trying to apply length to the function filter instead of to the results of filter?
13:57:22 <dmwit> rwbarton++ got it working, thanks!
13:57:51 <andrewsw> Baughn: so that length $ filter ... works but length . filter ... doesn't?
13:58:00 <Baughn> @type length . filter
13:58:01 <lambdabot>     Couldn't match expected type `[a]'
13:58:01 <lambdabot>            against inferred type `[a1] -> [a1]'
13:58:01 <lambdabot>     Probable cause: `filter' is applied to too few arguments
13:58:01 <dmwit> mmorrow: Right, that was a conceptual error that appeared in the "boil down to a minimal test case" phase.  Good spot.
13:58:08 <Baughn> andrewsw: ..yeah.
13:58:18 <dmwit> It's a shame I can't use function composition, though.
13:58:29 <dmwit> (\as -> runST (foo as)) -- works
13:58:35 <dmwit> runST . foo -- doesn't work
13:58:38 <dmwit> =/
13:58:45 <Baughn> Wasn't there a ".2" function somewhere?
13:58:47 <mmorrow> ah, yeah i've noticed that with runST
13:58:50 <rwbarton> You could write your own . ...
13:58:53 <int-e> dmwit: welcome to the wonderful world of rank 2 types
14:00:12 <pdani> and is there a function in prelude, which does something like (\x list -> (((length .) . filter) ((==) x) list) > 0)
14:00:13 <pdani> ?
14:00:25 <rwbarton> @unpl (\x list -> (((length .) . filter) ((==) x) list) > 0)
14:00:25 <lambdabot> (\ x list -> (length (filter ((==) x) list)) > 0)
14:00:39 <dmwit> :t \x list -> (((length .) . filter) (==x) list) > 0)
14:00:41 <lambdabot> parse error on input `)'
14:00:43 <rwbarton> \x -> any ((==) x)
14:00:44 <sjanssen> pdani: no
14:00:57 <sjanssen> ah, any
14:01:06 <rwbarton> elem
14:01:15 <rwbarton> :t (\x list -> (((length .) . filter) ((==) x) list) > 0)
14:01:16 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:01:19 <rwbarton> :t elem
14:01:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:01:42 <andrewsw> so what is the difference between length $ filter even [1..10] and (length . filter even) [1..10]?
14:01:56 <andrewsw> just preference? some concept of readability?
14:02:09 <dmwit> Preference, yeah.
14:02:15 <rwbarton> andrewsw: Mostly, yeah
14:02:33 <rwbarton> andrewsw: The latter displays (length . filter even) as a unit, which probably makes sense here but doesn't make sense in every case
14:02:51 <rwbarton> andrewsw: (IMHO, some people differ)
14:02:59 <andrewsw> okay, so it's really a readability issue.
14:03:04 <andrewsw> ISTM
14:03:34 <mmorrow> well, you can also do
14:03:40 <pdani> thx very much
14:03:43 <rwbarton> length . filter even $ [1..10]   -- another option
14:03:45 <mmorrow> , let foo = length . filter even in foo [0..10]
14:03:47 <lunabot>  6
14:04:07 <mmorrow> but without (.), you'd have to do
14:04:18 <mmorrow> , let foo xs = length (filter even xs) in foo [0..10]
14:04:20 <lunabot>  6
14:04:31 <mmorrow> (or with $ to save parens)
14:04:53 <int-e> dmwit: it's not (.) to blame btw. The point is that for  runST . f to work, f must have an explicit type signature, f :: b -> (forall s . ST s c), instead of the inferred f :: b -> ST s c
14:05:03 <plutonas> how do i install utf8-string using cabal?
14:05:09 <andrewsw> okay. I find in my total noobishness that I try to do a lot of foo . bar . baz something
14:05:14 <mauke> 'cabal install utf8-string'
14:05:16 <plutonas> cabal fetch utf8-string doesn't seem to find it
14:05:16 <andrewsw> and that typically doesn't work so I replace it with
14:05:20 <plutonas> neither install
14:05:24 <mmorrow> \xs -> length (filter even xs) ==> \xs -> length $ filter even xs ==> \xs -> length . filter even $ xs ==> length . filter even
14:05:25 <lispy> mmorrow: everytime I add something to haskell.sty I endup removing it because it makes something else look bad
14:05:26 <andrewsw> foo . bar $ baz something
14:05:27 <mauke> plutonas: try 'cabal update' first
14:05:38 <lispy> mmorrow: so I have a pretty minimal one again :)
14:05:39 <plutonas> oh yes, thanks
14:05:44 <mmorrow> lispy: heh, context sensitivity is a bitch!
14:05:50 * lispy nods
14:06:27 <lispy> mmorrow: and I found that even with all the same defining bits inline vs. environment gives different output in some cases :(
14:06:35 <lispy> mmorrow: so I had to remove those symblos
14:07:03 <lispy> mmorrow: it's essentially just \begin{verbatim} ... \end{verbatim} now
14:08:45 <mmorrow> urg, latex is so hellish when you have to add something to a perfectly layed out arrangement
14:08:55 <mmorrow> you end up having to change everything
14:09:35 <andrewsw> oh!!! (.) takes only one argument! d'oh... a light dimly flickers in the recesses of my skull...
14:10:52 <dons> plutonas: cabal update ; cabal install utf8-string
14:10:58 <dons> we need a cabal tutorial, dcoutts_
14:11:11 <plutonas> works now, thanks all
14:11:16 <dons> BONUS_: want to add a section on cabal install?
14:13:15 <nicknull> would it be possible to run a company using haskell? would there be enough people to hire? i mean its kind of a catch 22, fi no companies are usijg it people cant get experience and if companies cant find people with experience they wont use it in the first place
14:13:36 <mauke> http://galois.com/
14:13:37 <lambdabot> Title: Galois: Home
14:13:57 <plutonas> though i have some trouble running lhs2tex
14:13:58 <dons> ?users <-- lots of people have experience, actually.
14:13:59 <lambdabot> Maximum users seen in <-- lots of people have experience, actually.: 1, currently: 0 (0.0%), active: 0 (NaN%)
14:14:01 <plutonas> *** Error in file ./AutoComp.lhs line 5:
14:14:01 <plutonas> `verbatim' is not defined;
14:14:01 <plutonas> perhaps you forgot to include "lhs2TeX.fmt"?
14:14:04 <dons> ?users
14:14:04 <lambdabot> Maximum users seen in #haskell: 539, currently: 520 (96.5%), active: 25 (4.8%)
14:14:05 <dons> hehe
14:14:15 <plutonas> what does it mean to include lhs2TeX.fmt?
14:14:17 <dons> the problem is actually pruning all the job seekers :/
14:14:48 <dons> nicknull: we've a commercial users page and conference, http://haskell.org/haskellwiki/Haskell_in_industry
14:14:51 <lambdabot> Title: Haskell in industry - HaskellWiki
14:15:02 <dons> where we discuss haskell/industry things. it's a lot of fun.
14:15:34 <newsham> hypothetical abortions on imaginary daughters
14:15:39 <plutonas> does anyone use lhs2tex here?
14:15:40 <newsham> err, sorry, wrong channel
14:16:12 <rwbarton> mmorrow: you can get untype :: Type -> Q Type from git://github.com/rwbarton/oldtype.git -- it expands type synonyms
14:16:19 <lucca> imaginary daughters would be a Complex problem
14:16:25 <Kerris4> dons: pruning?
14:16:58 <rwbarton> mmorrow: it'd be awesome if you could give it a frontend in lunabot
14:17:14 <dons> Kerris4: yeah, galois for one gets too many applicants.
14:17:21 <nicknull> ycnews/%03d/%03d.html"
14:17:33 <nicknull> ^^ cant be just with printf to replace with digits
14:17:39 <nicknull> "CREATE TABLE %table_name (id INTEGER NOT NULL, desc VARCHAR(80))" []
14:17:51 <nicknull> i want to replace table_name, how?
14:18:19 <mauke> "CREATE TABLE %table_name ..." [("%table_name", whatever)]
14:18:21 <mauke> I presume
14:18:50 <Kerris4> that's nice to know, dons
14:20:06 <dons> it makes sense, right? there's 2.5k people on haskell-cafe, 500 in here. it's not hard to find haskellers.
14:23:18 <plutonas> ok, i managed to produce a tex file using lhs2tex, but the file completely sucks and won't run on pdflatex :P
14:23:28 <plutonas> i think i had enough trying to produce pdf from my lhs file
14:23:28 <mmorrow> rwbarton: awesome! i will.
14:24:13 <plutonas> it didn't even define \begin{document}
14:25:19 <nicknull> when ocnnecting with a db ina do i dont have to return right? it s a destructive update
14:27:13 <astrolabe> nicknull: That's difficult to read.
14:27:55 <ddarius> And what astrolabe means is he has no idea what you just asked.
14:28:06 <astrolabe> That too :)
14:28:17 <dons> "with a db ina do i dont have to" <-- parse error
14:28:57 <mauke> when connecting to a DB in a do-block, I don't have to return, right?
14:29:53 <mauke> the cotton socks are made of grows in egypt
14:32:49 <astrolabe> mauke: Ha.  I just parsed that.
14:33:22 <mauke> :-D
14:36:50 <rwbarton> Does this :i behavior make sense to anybody? http://hpaste.org/11305
14:38:47 <rwbarton> It doesn't happen if I delete the first line (that is, both types show as newtypes as expected)
14:39:04 <RayNbow> rwbarton: which GHC version?
14:39:29 <RayNbow> here it shows the correct information (GHC 6.10.0.20081007)
14:39:47 <rwbarton> ghc 6.8.2
14:40:24 <rwbarton> OK, I guess it's a bug that's been fixed then.  I can work around it easily enough
14:40:46 * RayNbow has recently uninstalled 6.8.2
14:41:01 * int-e sees the same behaviour in 6.10.0.20081017
14:41:05 <RayNbow> hmm
14:41:22 <RayNbow> <-- WinXP btw
14:41:22 <rwbarton> Same as me, or as RayNbow ?
14:41:33 <int-e> rwbarton: same as you
14:41:54 <RayNbow> wait, lemme check again to be sure :p
14:41:58 <rwbarton> It doesn't make any sense, does it?
14:43:21 <RayNbow> http://hpaste.org/11305#a1
14:43:25 <eu-prleu-peupeu> hello ppl from haskell
14:44:06 <mmorrow> rwbarton:
14:44:07 <mmorrow> , ppDoc $(lift =<< untype =<< [t|Cofree (Coideal Maybe) Int|])
14:44:08 <rwbarton> RayNbow: Aha, if I do that I get the same results.
14:44:11 <lunabot>  Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int
14:44:19 <mmorrow> there may be a slight bug:
14:44:31 <mmorrow> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t killsyns (issyn n) ; killsyn0 t = t ; killsyns = everywhere (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
14:44:36 <lunabot>  Fix (Biff p Identity (,) f) (Lift_ p Identity (,) Maybe) Int
14:44:46 <mmorrow> i'm not sure the deal thith that 'p'\
14:45:01 <RayNbow> rwbarton: what did I do different then?
14:45:12 <rwbarton> RayNbow: I was running from emacs, let me try to replicate it without that
14:45:23 * RayNbow doesn't have emacs :p
14:45:58 <rwbarton> oh never mind, I was trying the version without the module line.
14:46:08 <mmorrow> oh, hmm i think i see what's happening (maybe)..
14:46:39 <rwbarton> mmorrow: your code doesn't handle the possibility that a type synonym may have arguments
14:47:18 <rwbarton> , typeOf (undefined :: Cofree (Coideal Maybe) Int)
14:47:19 <lunabot>  luna: No instance for (Data.Typeable.Typeable1
14:47:22 <RayNbow> Btw, let's say I have an infinite list of x=[(arrival,departure)] times and I want to to turn it into a list of y=[arrival/departure] times. (type Time = Double; data Event = Arrival Time | Departure Time; instance of Ord)
14:47:22 <RayNbow> (fst $ unzip x) is monotonically increasing, but (snd $ unzip x) is most likely not. To construct list y, I was thinking of using an intermediate (ordered) Set to temporarily store departure times until I encounter a larger arrival time.
14:47:22 <RayNbow> Is this a good approach or are there better solutions?
14:47:31 <rwbarton> , (undefined :: Cofree (Coideal Maybe) Int) :: (Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int)
14:47:33 <lunabot>  luna: No instance for (GHC.Show.Show
14:47:46 <rwbarton> mmorrow: Seems like mine must be close to right then :)
14:49:26 <mmorrow> heh, wuh
14:49:41 <rwbarton> RayNbow: I get the same behavior I originally described with your procedure: http://hpaste.org/11305#a2
14:49:43 <mmorrow> weird. where's that p and f coming from?
14:49:50 <nicknull> what do you guys think of Scala(im not gonna sk about clojure since it is heresy! dynamic)?
14:50:06 <rwbarton> , src ''Cofree
14:50:11 <lunabot>  type Cofree f = Fix (PCofree f)
14:50:11 <mmorrow> , [t|forall p f. Fix (Biff p Identity (,) f) (Lift_ p Identity (,) Maybe) Int|]
14:50:13 <lunabot>  luna: Kind error: `Control.Functor.Fix.Fix' is applied to too many type a...
14:50:16 <rwbarton> , src ''PCofree
14:50:20 <mmorrow> hmm
14:50:21 <lunabot>  type PCofree = PAp (,)
14:50:26 <rwbarton> , src ''PAp
14:50:28 <mmorrow> ohhh
14:50:31 <lunabot>  type PAp p = Biff p Identity
14:50:49 <mmorrow> the killsyns isn't actually performing the necessary substitutions
14:51:08 <luite_> RayNbow: sounds ok, but you may want to use a priority queue instead of a sorted set. it's probably faster for the operations you need
14:51:10 <mmorrow> so yours is the correct one
14:51:29 <rwbarton> mmorrow: yeah, this is basically like writing a little lambda calculus interpreter
14:51:50 <mmorrow> hehe, totally
14:52:55 <RayNbow> luite_: a Priority Queue contains key:->value bindings, in my case key=value so I can just use a Set which internally orders its items :)
14:53:20 <nicknull> what do you guys think of Scala(im not gonna sk about clojure since it is heresy! dynamic)?
14:54:07 <ddarius> nicknull: Martin Odersky knows what he's talking about.
14:54:15 <ddarius>  / doing
14:54:43 <int-e> rwbarton: it gets weirder: :i C2 works.
14:55:32 <rwbarton> int-e: blah
14:55:40 <rwbarton> int-e: maybe I should email glasgow-haskell-users
14:55:53 <rwbarton> int-e: unless it's clearly a bug
14:58:33 <RayNbow> :t Data.Set.minView
14:58:35 <lambdabot> forall a (m :: * -> *). (Monad m) => S.Set a -> m (a, S.Set a)
14:58:42 <RayNbow> ^ why isn't m = Maybe?
14:58:47 <RayNbow> fail is evil :p
14:58:47 <int-e> rwbarton: http://hpaste.org/11305#a3
14:59:40 <plutonas> how do i find the documentation on `on`?
14:59:48 <nicknull> rwbarton: why are u using 6.8.2? its experimental and old
15:00:03 <RayNbow> @hoogle on
15:00:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:00:04 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
15:00:04 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
15:00:16 <RayNbow> @src on
15:00:16 <lambdabot> (*) `on` f = \x y -> f x * f y
15:00:21 <plutonas> RayNbow: not the type, or the source
15:00:29 <plutonas> but an explanation using words of what it does
15:00:30 <int-e> rwbarton: and you get the same information if you load the module compiled - so I guess ghc leaks the information that T1 is really an Int outside - perhaps to allow optimizations.
15:00:51 <rwbarton> int-e: oh, hmm
15:01:17 <RayNbow> plutonas: there's an example usage in the docs at http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html#v%3Aon
15:01:19 <lambdabot> Title: Data.Function, http://tinyurl.com/yrwgjc
15:01:30 <int-e> rwbarton: it's definitely odd though.
15:01:41 <RayNbow> you can find the docs by using the web interface of Hoogle: http://www.haskell.org/hoogle/?hoogle=on
15:01:42 <lambdabot> Title: on - Hoogle
15:02:17 <plutonas> there is no description though
15:02:20 <plutonas> i know how to use it
15:02:40 <plutonas> but was wondering if there is a formal definition, so that i don't write it  myself...
15:03:25 <rwbarton> plutonas: There is a description on that page
15:03:32 <int-e> rwbarton: indeed, the constructor is mentioned in the .hi file. http://hpaste.org/11305#a4
15:04:34 <plutonas> rwbarton: it sais typical usage, and algebraic properties
15:04:40 <plutonas> it's not exactly description
15:04:55 <plutonas> what i'm looking for is something like `on` takes these arguments, and returns that
15:05:15 <lispy> plutonas: on takes two functions and builds a new function.  The new function takes 2 parameters.  on will apply the first function it took to both of those parameters and then apply the other function it took to the results.
15:05:43 <plutonas> lispy: thats what i needed :)
15:05:58 <rwbarton> plutonas: Note how this is less comprehensible than the description on that page :)
15:06:10 <plutonas> i know but i'm writting in lhs
15:06:18 <plutonas> and it goes well with the rest of the document
15:06:34 <rwbarton> I see
15:07:14 <lispy> plutonas: hehe, it looks like I got the details wrong
15:07:17 <plutonas> hate to do this stuff, but i have to...
15:07:26 <plutonas> oops
15:07:29 <lispy> plutonas: (*) `on` f = \x y -> f x * f y
15:07:39 <lispy> clearly it applies the second function to both parameters
15:07:47 <lispy> (f x) * (f y)
15:09:06 <lispy> > ((*) `on` ord) 'a' 'b'
15:09:07 <lambdabot>   9506
15:09:14 <nicknull> filter (>=12) [1..14]
15:09:22 <lispy> you multiply on the ordinals of charaters in that example
15:09:27 <nicknull> why does lambdabot never obey me?
15:09:33 <nicknull> @seen nicknull
15:09:34 <lambdabot> You are in #haskell. I last heard you speak just now.
15:09:35 <lispy> nicknull: hi nicknull
15:09:43 <nicknull> hi
15:09:49 <plutonas> lispy: yeap thanks
15:09:53 <lispy> nicknull: you forgot to put a '>' character at the start of the line
15:09:58 <lispy> > 1
15:09:59 <lambdabot>   1
15:10:00 <astrolabe> nicknull: You need to start with a '>' and a space
15:10:04 <nicknull> > filter (>=12) [1..14]
15:10:06 <lambdabot>   [12,13,14]
15:10:09 <nicknull> ah
15:10:22 <int-e> @run 1
15:10:23 <lambdabot>   1
15:10:28 <int-e> @eval 0
15:10:35 <int-e> @help eval
15:10:35 <lambdabot> eval. Do nothing (perversely)
15:10:45 <lispy> ?evil one
15:11:08 <lispy> eval exists to prevent lambdabot from responding to expressions meant for other bots, right?
15:11:32 <int-e> I think so.
15:11:34 <mauke> yes
15:11:37 <lispy> ?fun 1
15:11:38 <lambdabot>   1
15:12:04 <mauke> @info 1 + 2 * 3
15:12:04 <lambdabot> 1 + 2 * 3
15:12:19 <tromp> getting errors trying to install cabal-install
15:12:32 <tromp> Stream.hsc:74:18: error: zlib.h: No such file or directory
15:12:40 <lispy> tromp: are you on windows?
15:12:48 <tromp> no, ubuntu 8.04
15:13:08 <lispy> tromp: then you may need something like, zlib-dev
15:13:14 <lispy> tromp: as a package from your distro
15:13:46 <tromp> it doesn't know package zlib-dev
15:14:11 <rwbarton> probably libzX-dev where X is some digit
15:15:06 <younder> I hear there is some support for multiple argument functions. Where can I read about it?
15:15:22 <lispy> tromp: I'm not an ubuntu user so i'm not really sure what they call it.  But, what you need to do is install zlib
15:15:23 <mauke> > (+) 2 2  -- multiple arguments
15:15:25 <lambdabot>   4
15:15:45 <andrewsw> tromp: aptitude search zlib | grep dev
15:15:52 <lispy> younder: you mean functions that take a different number of arguments depending on how you call them?
15:16:01 <younder> well like n where n is unkown arguments
15:16:05 <tromp> wait, instructions say i need *Haskell* package zlib
15:16:10 <tromp> from hackage
15:16:23 <lispy> tromp: yes, you'll need that too.
15:16:41 <lispy> tromp: but, I don't know if it provides zlib.h on ubuntu
15:16:42 <tromp> but it claims bootstrap.sh will download and install it
15:16:50 <lispy> well, there you go :)
15:16:56 <rwbarton> tromp: oh, I think it's zlib1g-dev
15:17:01 <younder> (sumN 5 1 2 3 4 5) like
15:17:09 <mauke> @where oleg
15:17:09 <lambdabot> http://okmij.org/ftp/
15:17:29 <rwbarton> younder: this isn't really a good idea... also, it doesn't work by passing the number of arguments first
15:17:41 <rwbarton> younder: but, you can do it if you must
15:17:56 * twfxfnf likes lisp :D
15:18:00 <mauke> younder: http://okmij.org/ftp/Haskell/types.html#polyvar-fn
15:18:01 <lambdabot> Title: Haskell Programming: Types
15:18:14 <younder> More like in a printf like function I suppose
15:18:36 <younder> thanks mauke
15:18:37 <lispy> younder: we have printf
15:19:15 <lispy> > printf "%s %s %s %s" "hey" "look" "at" "me" :: String
15:19:17 <lambdabot>   "hey look at me"
15:19:26 <lispy> > printf "%s %s %s" "hey" "look" "at":: String
15:19:27 <lambdabot>   "hey look at"
15:19:32 <mauke> > ""++ printf "%-020s ! %020s" "" ""
15:19:34 <lambdabot>   "00000000000000000000 ! 00000000000000000000"
15:19:46 <loop_> > printf "%s %d" "hey" "ho"::String
15:19:47 <lambdabot>   "hey * Exception: Printf.printf: bad argument
15:20:13 <lispy> :t printf
15:20:14 <lambdabot> forall r. (PrintfType r) => String -> r
15:20:22 <loop_> is typesafe printf possible?
15:20:30 <vixey> loop_: yes
15:20:42 <mauke> loop_: not if the format string is a string
15:20:49 <vixey> ?go type safe printf delimited continuations
15:20:54 <lambdabot> http://lambda-the-ultimate.org/node/2626
15:20:54 <lambdabot> Title: Type-safe printf using delimited continuations, in Coq | Lambda the Ultimate
15:21:23 * lispy was just thinking dependent types would help with type-safe printf
15:21:32 <younder> ok so for format t "~%~S:~{~A~^,~}" "hello" ["John" "Frank" "Joe"]
15:21:37 <loop_> mauke: well, i think it kind of works in gcc. the compiler does some checking on the format string at compile-time ;)
15:21:45 <luqui> lispy, I think they did that in agda.
15:22:02 <mauke> loop_: only if the format string is a string literal
15:22:03 <loop_> but that's just as a special case in the compiler..
15:22:09 <mauke> yeah, OCaml does that
15:22:10 <loop_> mauke: yes
15:22:27 <lispy> luqui: I was looking at agda last night.  It seems like high order functions are a real pain in agda due to specifying the types :(
15:23:29 <kosmikus> plutonas: looks like you have the wrong expectations regarding lhs2TeX. it's not supposed to create a valid TeX file, you are ... lhs2TeX only transforms the code ...
15:23:33 <tromp> zlib1g-dev did the trick
15:23:40 <luqui> lispy, I'm a coq user, but they're pretty similar.  I've found most of the time it can infer anything inferrable in Haskell.
15:23:52 <lispy> luqui: the type of function composition was way longer than the definition, but the type was required :(
15:24:06 <lispy> luqui: ah.  agda doesn't infer types
15:24:09 <luqui> lispy, the difference is that it's monomorphic, so it doesn't automatically generalize
15:24:17 <vixey> lispy: yes it does
15:24:20 <luqui> lispy, yes it does.  :-)
15:24:24 <vixey> hehe
15:24:33 <tromp> Configuring HTTP-3001.1.3 still complains about missing dependencies network -any, parsec -any
15:24:38 <lispy> weird, the tutorial I was reading said you have to give type signatures
15:24:53 <luqui> hmm, maybe you need top level sigs.
15:24:59 <vixey> you don't always have to put top level sigs
15:25:04 <vixey> when it can't figure it out it requires you to
15:25:05 <lispy> http://www.cs.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf
15:25:10 <lambdabot> Title: Dependently Typed Programming in Agda, http://tinyurl.com/6xshnb
15:25:24 <vixey> you can still leave gaps in the type signatures though (which is something I miss in haskell)
15:25:24 <mattam> lispy: you can code in Agda as you would in Haskell except you have to give signatures of polymorphic functions (it's only considered good practice in Haskell for the most part).
15:25:25 <kosmikus> you have to give type signatures when you use dependent pattern matching
15:25:26 <Plouj> hi
15:25:46 <Plouj> can someone help me understand the CPS in this cfold example: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Continuation_Passing_Style ?
15:25:50 <lambdabot> Title: Haskell/YAHT/Type basics - Wikibooks, collection of open-content textbooks, http://tinyurl.com/y8w64d
15:26:06 <luqui> in coq:    compose A B C (f : B->C) (g : A->B) x = f (g x).   (* the best you can do, because it's monomorphic *)
15:26:47 <mattam> Mostly, you're using higher-order polymorphism, and GADTs all the time so you have to give signatures like in Haskell.
15:26:58 <lispy> it seemed like in agda you can get Haskell style parametric polymorphism by encoding system F manuall.
15:27:01 <luqui> but polymorphism is what's expensive, not writing type signatures.
15:27:17 <nicknull> run conn "CREATE TABLE proglangs (id INTEGER NOT NULL, desc VARCHAR(80))" []
15:27:21 <vixey> Plouj: what about it?
15:27:31 <mattam> Expensive?
15:27:34 <nicknull> i want the key to be "string" and the values to be [String]
15:27:46 <luqui> lispy, yep that's how it goes.  but it can infer a lot; but the parameters need to *be there*
15:28:01 <vixey> lispy: did you see mattams typeclasses in Coq?
15:28:23 <lispy> vixey: no, I haven't really looked at Coq
15:28:43 <vixey> that would be a cool addition to agda
15:28:45 <Plouj> vixey: I'm not quite sure how it works in general. The part with y being undefined in cfold' f z (x:xs) = f x z (\y -> cfold' f y xs)
15:28:48 <luqui> mattam, I mean, you have to write stuff explicitly in polymorphic functions because... well, because there are no polymorphic functions.
15:28:48 <Plouj>  confuses me
15:28:57 <Plouj> same with g being undefined in cfold f z l = cfold' (\x t g -> f x (g t)) z l
15:29:02 <lispy> luqui: I guess...agda looks interesting, but programming in agda looks hard and uncomfortable.
15:29:12 <luqui> lispy, are you using an IDE?
15:29:13 <Plouj> I think I know what CPS is in general
15:29:20 <vixey> Plouj: Well it (\y -> cfold' f y xs) is just a function that does cfold' on the rest of the list with 'y' as the accumulator
15:29:25 <Plouj> but I don't know how the continuation in cfold' works
15:29:32 <vixey> Plouj: This is a really really bizarre and strange way to introduce CPS though
15:29:32 <lispy> luqui: I've just been reading the tutorial
15:29:37 <mattam> Anyway, it would be trivial to do HM-style generalization in Coq or Agda. The ssreflect extension of Coq does it for example.
15:29:38 <luqui> lispy, do not, I repeat, DO NOT program with dependent types with a regular text editor.  it is a pitfa
15:29:40 <lispy> luqui: I coludn't sleep so I was reading
15:29:40 <Plouj> vixey: ok, I see that, but I don't see how they came up with that
15:29:51 <Plouj> vixey: should I just ignore it and move on in teh book?
15:30:00 <vixey> Plouj: CPS is actually dead simple but this description is pretty awful
15:30:11 <Plouj> ok, I'll move on then
15:30:13 <vixey> Plouj: yeah skipping this can't hurt
15:30:28 <luqui> lispy, if there's an ide for agda, figure it out.  otherwise go use coqide  (most of your knowledge will transfer).  coq is pretty awesome :-)
15:30:33 <lispy> luqui: heh yeah.  Which language was it that uses the 2d syntax for data declarations?  That one looked insane to program in
15:30:40 <luqui> epigram
15:30:42 <vixey> For agda there is emacs
15:31:03 <vixey> I don't know if you are supposed to reload the entire file everytime you write a new definition but it's a bit slow
15:31:11 <mattam> Epigram was truely interactive, it was nice as ever.
15:31:21 <kosmikus> mattam: do you think HM-style generalization is particularly useful, though, for languages like Coq and Agda? I think I prefer to be explicit about generalization ...
15:31:45 <luqui> The concept of epigram is great!  it has the potential to be my favorite, but its lack of local undo, etc., is a killer
15:31:47 <mattam> No, I don't. I think implicit arguments are much better than that.
15:31:58 <kosmikus> ok :)
15:32:07 <kosmikus> then we agree
15:32:13 <lispy> luqui: please explain more, why is epigram your favorite?
15:32:28 <luqui> lispy, because I can program in combination programming and proof mode.
15:32:34 <vixey> epigram has some great papers :)
15:32:43 <luqui> i.e. I can say   foo x = x + *I Don't Know*
15:33:02 <luqui> and then get a dump of my context in the *I Don't Know*, and help filling out what it is.
15:33:14 <lispy> luqui: oh cool
15:33:17 <kosmikus> luqui: that's no different in Agda. You can use goals there and show the context.
15:33:17 <vixey> this is true of coq and agda as well
15:33:48 <luqui> vixey, how in coq?
15:33:59 <luqui> I mean while seeing the program, not switching to proof mode
15:34:05 <luqui> where the program disappears.
15:34:11 <vixey> the tactic refine
15:34:16 <twfxfnxfnf> > ((+) 1 2)
15:34:17 <lambdabot>   3
15:34:30 <twfxfnxfnf> > ((((((((((+))))))))) 1 2)
15:34:31 <lambdabot>   3
15:34:33 <lispy> luqui: oh, the pay as you go proofs sound interesting
15:34:50 <maxote> i know coq, isabelle, agda. is there more?
15:34:55 <lispy> luqui: that was actually what I was thinking last night reading about agda, "Oh this is cool.  But gosh the start up cost is high."
15:35:00 <vixey> maxote: yeah
15:35:09 <luqui> vixey, yeah, that's not quite right.  I write the missing part of the function after the function, not in it.
15:35:39 <vixey> luqui; you can just do refine (_) like that and then fill in the holes in there and keep working on it
15:36:02 <luqui> vixey, yeah, I do that frequently.  It's not entirely easy to use.
15:36:27 <mattam> maxote: twelf has got some dependent types too.
15:36:43 <luqui> It's not expressivity I have a problem with, or the general mechanics.  It's the fine details of the interface that would make epigram my favorite.
15:36:49 <maxote> thanks mattam, i forgot twelf
15:36:51 <luqui> and actually I want to write a new interface to coq
15:37:04 <mattam> me too :)
15:37:05 <vixey> makote: Omega - http://www.rosettacode.org/wiki/Evens_Sum_To_Even
15:37:10 <lambdabot> Title: Evens Sum To Even - Rosetta Code
15:37:21 <vixey> makote: sadly Isabelle is missing from here
15:37:27 <luqui> that does this sort of stuff.  but I got to get my frp stuff going so that it doesn't completely suck to write guis :-)
15:37:53 <maxote> http://en.wikipedia.org/wiki/Omega_language too
15:37:54 <lambdabot> Title: Omega language - Wikipedia, the free encyclopedia
15:38:00 <vixey> luqui: You are actually writing a FRP GUI in Coq?
15:38:06 <nicknull> what unsigned mean in unsigned int?
15:38:19 <luqui> vixey, no, an GUI *for* coq *in* FRP.
15:38:25 <nicknull> haskells interface to sqlite3 ++
15:38:25 <luqui> but not FRP *in* coq :-)
15:38:28 <mattam> luqui: in the mean time, Program will get some niceties to do sort-of-refinement.
15:38:28 <maxote> http://en.wikipedia.org/wiki/HOL_theorem_prover too
15:38:29 <lambdabot> Title: HOL theorem prover family - Wikipedia, the free encyclopedia
15:38:30 <vixey> why not writing it in coq?
15:38:36 <luqui> (though I have formalized a lot of frp stuff in coq)
15:38:40 <nicknull> is coq a miniproglang?
15:38:54 <luqui> vixey, well maybe eventually.  got to get an efficient impl in haskell first.
15:39:08 <luqui> vixey, that the coq will compile down to.
15:39:08 <mattam> It's a complete purely functionnal programming language.
15:39:10 <nicknull> and dont' french people know enough english not to name it coq?
15:39:20 <mattam> nicknull: quite the opposite :)
15:39:20 <nicknull> so useless then :)
15:39:45 <lispy> nicknull: unsigned means it's always positive
15:39:53 <vixey> luqui: regardless, that will be really cool to try out - do you think it will be suitable for any other systems to use than coq?
15:40:14 <luqui> nicknull, seriously.  the name for my extension will be either "Hancoq" or "Fondle"
15:40:28 <maxote> briefly, coq, isabelle, agda, twelf, omega, hol4, ..
15:40:37 <lispy> I thought Coq was "coke" not "cock"
15:40:37 <luqui> vixey, don't know.  depends on the approach I take.
15:40:47 <luqui> (it's kind of in between)
15:40:58 <vixey> I wish someone would put up an isabelle example
15:40:59 <mattam> It's pronounced like the later.
15:41:21 <luqui> vixey, probably, though, since I plan to abandon coq's syntax.  then it's just a matter of backend.
15:41:28 <maxote> why none of them is written in haskell?
15:41:34 <vixey> maxote: agda 2 is
15:41:36 <luqui> Agda in haskell
15:41:44 <maxote> sorry ;)
15:41:46 <vixey> maxote: epigram is
15:41:54 <luqui> ah right, that too :-)
15:41:56 <vixey> ivor, idris too
15:42:20 <vixey> the lambda pi paper uses haskell
15:42:41 <luqui> the smart folks know how to pick their non-dependent languages :-)
15:43:02 <maxote> it's as a folklore :D
15:43:15 * lispy waits for agda to be written in agda
15:43:16 <mattam> In some respects, haskell should be part of the list.
15:43:32 <ddarius> maxote: And Yarrow
15:43:45 <vixey> I hope we will see some completely metacircular ones
15:43:59 <nicknull> lispy: ah i see, but why thename unsigned?
15:44:07 <vixey> (soon)
15:44:13 <luqui> mattam, yeah, it's just not a very good one among that list.
15:45:10 <lispy> nicknull: I'm not sure.  I think the tradition must have started in C or sooner
15:45:11 <mattam> With Ynot, we'll get an efficient Coq-in-Coq some day soon. And there's also the whole Coq-Caml-CompCert-PPC translation that's being certified.
15:45:39 <rwbarton> Hmm, I can't naively use a Reader [(Name, Value)] monad for call-by-name evaluation the same way I can for call-by-value evaluation, can I
15:45:41 <vixey> this is an extention of
15:45:43 <vixey> CompCert?
15:45:47 <vixey> I hadn't heard of it
15:45:57 <rwbarton> Because I have to worry about variable name shadowing (Values can contain Names)
15:46:04 <maxote> http://hol.sourceforge.net/
15:46:04 <lambdabot> Title: HOL 4 Kananaskis 4
15:46:16 <nicknull> lispy: are u sure? i just tried a c program, did unsigned int = -1; and printed it, it said -1. no warnings from gcc either
15:46:34 <lispy> what I wish we had was a way to write guaranteed total code inside of haskell code.
15:46:34 <luqui> nicknull, how did you print it?
15:46:37 <mattam> The CompCert project aims at building a certified compiler from ML (currently Cminor) to PPC.
15:46:43 <vixey> on this topic, does anyone know some good texts on implementation of HOL and LCF?
15:46:45 <catechu> I have a silly question -- I have a haskell project with multiple files, one of which contains a main. How can I compile it?
15:46:48 <luqui> nicknull, also gcc will warn you if you ask it to with -Wall
15:46:49 <nicknull> unsigned int i = -1;
15:46:55 <nicknull>  printf("\n%d", i);
15:47:00 <vixey> mattam: oh cool! I thought they were just doing C
15:47:02 <luqui> %d prints a signed int
15:47:03 <nicknull> -Wall means what?
15:47:07 <mauke> nicknull: invalid. %d takes a signed int
15:47:09 <luqui> -W(arnings) all
15:47:16 <nicknull> ok
15:47:17 <mauke> -Wall enables some warnings
15:47:20 <mattam> vixey: Paulson's papers are nice
15:47:35 <lispy> catechu: lots of ways
15:47:36 <nicknull> ok how do i print an unsigned?
15:47:40 <mauke> use -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -Wdisabled-optimization -O2 for great justice
15:47:46 <mauke> nicknull: %u
15:47:47 <catechu> lispy: help me find one of them :)
15:47:48 <vixey> great, thank you :)
15:47:49 <lispy> catechu: ghc --make, is one way.  Another way is to use cabal.
15:47:59 <lispy> ?where cabal
15:48:00 <lambdabot> http://www.haskell.org/cabal
15:48:03 <nicknull> i see the dangers of implicit conversions :)
15:48:04 <luqui> nicknull, you are seeing why C sucks at this very moment :-)
15:48:07 <rwbarton> -Wgentoo
15:48:08 <lispy> catechu: I would go with cabal :)
15:48:20 <nicknull> ah, fail
15:48:25 <catechu> lispy: ghc --make does the trick for now, but I'll look into cabal. Thanks!
15:48:33 <luqui> Warnings: you are using gentoo.  I'll take my time since you obviously don't mind waiting.
15:49:00 <vixey> I hope we can get more programs in agda coq etc though
15:49:11 <vixey> like I wish some people would write some programs I can use in them :p
15:49:32 <vixey> text editor, music player or anything like that
15:49:35 <luqui> you could write them :-)
15:49:47 <badsheepy> 3~
15:49:50 <badsheepy> oops sorry
15:49:55 <mattam> :) It's still researchy stuff. Consider avoiding success at all costs also.
15:50:05 <luqui> vixey, yeah.  none of them are incredibly good at generating real-world code though.
15:50:10 <nicknull> control reaches end of non-void function
15:50:17 <nicknull> oh well this is not c...
15:50:25 <lispy> catechu: if you create a .cabal file then you'll be able to share your code with the rest of the haskell community via hackage :)
15:50:25 <mauke> nicknull: missing return statement
15:50:28 <lispy> ?where hackage
15:50:28 <lambdabot> http://hackage.haskell.org/
15:51:06 <luqui> vixey, my plan of attack for real things in coq is to axiomatize what I want to use, and model it in Coq.  Then also model in Haskell efficiently (eg. using Integer instead of inductive nat), and use the latter for my programs.
15:51:15 <mattam> luqui: the extracted compiler from Leroy's proof needed only small tinkering to get it to have reasonnable performance.
15:51:17 <luqui> where the former is just to prove that my axioms are consistent.
15:51:23 <catechu> lispy: oh, ok. this is more of an exercise for myself, but I'll keep that in mind once I'm proficient and contributing. ;)
15:51:45 <nicknull> gcc -Wall -o pyext pyext.c
15:51:51 <luqui> mattam, that's not quite what I mean.  I mean re: using external libs, machine integers, etc.
15:51:58 <maxote> the problem is that the size of the axiomatized program is too small or too simple!
15:52:03 <vixey> a very efficient correct compiler would be useful twofold
15:52:14 <ddarius> luqui: Presumably you've looked at the L4 stuff?
15:52:14 <mattam> You know, the current version of Coq is able to use machine integers during conversion instead of nats :)
15:52:34 <vixey> the second reason is you can have complicated proof search running _efficiently_ in the type system
15:52:36 <luqui> ddarius, possibly, though the name doesn't ring a bell.
15:52:41 <maxote> e.g.,  search succ(....) such its value matches 999'999'999'999
15:52:46 <nicknull> no complains on %d and unsigned int = -1
15:52:46 <nicknull> not when using %u eithe ro %i
15:52:53 <luqui> ddarius, is that that coq extension (giggle) that adds monads and crap?
15:53:04 <luqui> where by monads I mean IO monad
15:53:15 <mauke> nicknull: gcc -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline -O2
15:54:13 <mattam> luqui: L4 is a microkernel being verified using HOL
15:54:24 <luqui> oh, I think FRP might be one of the keys to bringing real world programming to DT languages, because FRP actually has a model :-)
15:54:32 <luqui> mattam, ah then no I haven't.
15:54:53 <mattam> Interesting monadey stuff.
15:54:53 <vixey> what does it mean to have a model? I read lambda calculus didn't have a model
15:55:16 <ddarius> @google "Running the Manual"  L4
15:55:20 <lambdabot> http://nicta.com.au/research/project_list/completed_projects/secure_embedded_l4
15:55:20 <lambdabot> Title: NICTA | Secure Embedded L4
15:55:22 <twfxfnxfnf> does anybody else think programming is like looking into the face of the universe
15:55:25 <luqui> vixey, scott gave LC a model.
15:55:35 <vixey> :S
15:55:53 <luqui> vixey, but you know what doesn't have a model?  readFile
15:56:01 <luqui> or putStr.
15:56:16 <ddarius> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.61.7252
15:56:17 <lambdabot> Title: Running the manual: An approach to high-assurance microkernel development - Cite ...
15:56:32 <luqui> simply because they aren't about a mathematical domain, they are about 'the real world', and wtf is that?
15:56:47 <vixey> what is the model of FRP?
15:56:51 <luqui> time functions.
15:56:54 <vixey> have you constructed it?
15:57:01 <mattam> luqui: you know Swierstra's work on modelling IO?
15:57:16 <luqui> vixey, uh huh.  many times (slight variations).
15:57:44 <luqui> vixey, it's about a partial order (on times), with "quasitotality" (two times can be compared only after one of them).  it looks a lot like temporal logic.
15:57:53 <luqui> mattam, no
15:58:43 <luqui> mattam, google-fu-fail!  got a re?
15:58:45 <luqui> *ref?
15:58:55 <mattam> @google Beauty In The Beast
15:58:58 <lambdabot> http://www.imdb.com/title/tt0101414/
15:58:58 <lambdabot> Title: Beauty and the Beast (1991)
15:59:12 <mattam> http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
15:59:14 <lambdabot> Title: Beauty in the Beast
15:59:16 <mattam> Too bad :)
16:00:01 <xenoblitz> hi guys! any gtk2hs guru online?
16:00:26 <luqui> mattam, ah very nice.  this is precisely what I've been claiming hasn't been done, and is my argument for why the IO monad is evil :-).  perhaps, oh my, perhaps I was... MISTAKEN
16:01:22 <luqui> IO is still evil, because the model isn't simple, but not nearly as evil.
16:02:11 <mattam> Yeah, it's just the right way to do it I think.
16:03:05 <luqui> yeah.  I'd like the IO monad to be called the FFI monad, and then use a more meaningful domain (like frp) for most programs.
16:03:26 <luqui> but this is future talk, we don't have the technology to do that just yet.  working on it! :-)
16:03:35 <vixey> heh
16:04:04 <nicknull> vixey: what sorts of programs for what?
16:04:38 <xenoblitz> how possible is it to make gtk do something every say x milliseconds?
16:04:46 <nicknull> you want programs in coq that you can prove to be correct or not?
16:05:14 <luqui> xenoblitz, you could just have a thread do it.  or is that not what you're asking.
16:05:21 <mattam> luqui: You want to look at "Data type à la Carte" by Wouter to do that as well. The technology is there.
16:05:52 <plutonas> does the function type have to be before the function, or could it appear after as well?
16:05:59 <xenoblitz> luqui: i need a redraw of a canvas to occur every say 1 second
16:06:04 <vixey> plutonas: why not try it
16:06:06 <int-e> xenoblitz: you can use  timeoutAdd  for that, and install a handler that always returns True.
16:06:21 <luqui> mattam, well, I mean the missing technology is a suitable frp implementation, rather :-)
16:06:28 <xenoblitz> int-e: greek :P but i'll look it up
16:06:43 <mattam> haha. What are you doing reading literature then! :)
16:07:21 <luqui> :-)
16:07:34 <xenoblitz> int-e: thanks that function seems exactly what I should need!
16:07:50 <maxote> model it in Turing Machine, hahaha
16:07:57 <luqui> mattam, I am actually quite excited as I believe I have found a plan for a very nice, flexible frp implementation  (which far surpasses Reactive in its expressivity)
16:08:08 <luqui> but the implementation will be.... hard.
16:08:24 <luqui> subtle. lots of reliance on laziness.
16:08:39 <int-e> xenoblitz: then use widgetQueueDraw to get the drawing function called.
16:08:50 <dmwit> luqui: "I have found a remarkable proof, but the margin is too small." ;-)
16:09:02 <luqui> dmwit, quite :-)
16:09:15 <luqui> I have written it up in an imprecise handwavey way
16:09:45 <luqui> hm, I'll move that writeup to a public place.
16:10:05 <xenoblitz> int-e: I'll see how to add a handler and use widgetQueueDraw :)
16:11:18 <nicknull> if i want a database-table where i can lookup a word and get all the phrases it is used in, what is the best way to organize that? im noob do databases. one table for each word cant be right? then id have loads of them. i want basically to do in a table id=='haskell' then get a list of strings
16:11:23 <mm_freak> luqui: btw, do you know a good introduction into FRP?  i've only found papers about how to improve/implement it, not how to use it or what it is at all
16:12:11 <luqui> mm_freak, well, it's hard to introduce something which hardly exists.
16:12:29 <luqui> mm_freak, the paper about Fran is nice though, even though it is still implementation-centric
16:12:36 <mm_freak> seems like it's kind of another abstraction of impure things like events
16:12:39 <luqui> mm_freak, (finding link)
16:12:52 <luqui> mm_freak, kindof, except for it puts it on a very simple, pure footing
16:13:02 <luqui> eg. an event (in fran) is just a time, value pair
16:13:28 <mm_freak> hmm…  is it worth reading it for a real world-oriented programmer?
16:13:39 <luqui> http://www.haskell.org/yale/papers/icfp97/index.html
16:13:50 <lambdabot> Title: ICFP 97 - Functional Reactive Animation
16:14:14 <luqui> mm_freak, yeah.  the thing is that such time value pairs can be compared, and used, before their times and values are known
16:14:30 <luqui> so it corresponds to real times, not just some magical thing.
16:14:50 <luqui> mattam, http://luqui.org/icfp97_frp.pdf  -- a pdf of the same, in case you like those better
16:15:01 <lambdabot> Title: Functional Reactive Animation
16:15:19 <mm_freak> is it just a concept or does it need library/code support in some way?
16:15:32 <luqui> mm_freak, needs library support
16:15:40 <mm_freak> ok, thanks, i'll have a look at it
16:15:54 <luqui> and it must be the devil, since such a library is proving very hard to create efficiently
16:16:06 <luqui> it has evaded us for 10 years!
16:16:42 <lispy> luqui: java doesn't exactly have an efficient GUI either it would seem :)
16:16:59 <luqui> true, but that's not the kind of efficiency we're talking about
16:17:05 <lispy> oh
16:17:06 <luqui> _asymptotic_ efficiency!
16:17:47 <luqui> anyway, Conal Elliott's Reactive library (code.haskell.org/reactive) is efficient and usable.
16:18:00 <luqui> well, variations on it.  that library itself is in somewhat of a borked state.
16:18:19 <luqui> but its expressiveness is limited.
16:19:38 <AWizzArd> I would like to map over a list of numbers, and every time when I see a 100 I want to replace it by another number, beginning from 1... the second 100 should be replaced by a 2, the third by a 3 and so on. Any ideas?
16:19:59 <mauke> you need to keep some state
16:20:10 <vixey> :t groupBy
16:20:11 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
16:20:29 <vixey> :t groupBy (\x y -> y == 100) [6,9,100,5,8,4,7,100,3,2,5,100]
16:20:31 <lambdabot> forall a. (Num a) => [[a]]
16:20:43 <ivanm> Cale: well, even when I filtered the dataset it was extremely slow (the first bit I did wasn't too bad, but then I had to calculate the mean and variance as well, which was a _lot_ slower, if it didn't hang)...
16:21:26 <vixey> :t zip [1..] . groupBy (\x y -> y /= 100) $ [6,9,100,5,8,4,7,100,3,2,5,100]
16:21:27 <lambdabot> forall t a. (Num a, Enum t, Num t) => [(t, [a])]
16:22:09 <AWizzArd> vixey: oh hmm, I must look up what all this means, thanks :-)
16:22:37 <lispy> > groupBy (\x y -> y == 100) [6,9,100,5,8,4,7,100,3,2,5,100]
16:22:39 <lambdabot>   [[6],[9,100],[5],[8],[4],[7,100],[3],[2],[5,100]]
16:22:40 <vixey> (\(t,_:y)->y++[t]) =<< (zip [1..] . groupBy (\x y -> y /= 100) $ [6,9,100,5,8,4,7,100,3,2,5,100])
16:22:42 <vixey> > (\(t,_:y)->y++[t]) =<< (zip [1..] . groupBy (\x y -> y /= 100) $ [6,9,100,5,8,4,7,100,3,2,5,100])
16:22:43 <lambdabot>   [9,1,5,8,4,7,2,3,2,5,3,4]
16:22:44 <vixey> > [6,9,100,5,8,4,7,100,3,2,5,100]
16:22:45 <lambdabot>   [6,9,100,5,8,4,7,100,3,2,5,100]
16:23:07 <mauke> f n [] = []; f n (x : xs) | x == 100 = n : f (n + 1) xs | otherwise = x : f n xs
16:23:46 <RayNbow> merge (a:as) (d:ds) = a : insert d (f as ds)   -- is this efficient for infinite argument lists? (a:as) is sorted, (d:ds) is not
16:23:46 <mauke> :t scanl
16:23:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:24:06 <vixey> > (\(o,_:xs)->xs++[o]) =<< (zip [1..] . groupBy (\x y -> y /= 100) . (100:) $ [6,9,100,5,8,4,7,100,3,2,5,100])
16:24:07 <lambdabot>   [6,9,1,5,8,4,7,2,3,2,5,3,4]
16:24:14 <mauke> :t mapAccumL
16:24:16 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:24:24 <vixey> :t (\(o,_:xs)->xs++[o])
16:24:25 <lambdabot> forall t. (t, [t]) -> [t]
16:25:06 <mauke> > mapAccumL (\a x -> if x == 100 then (a + 1, a) else (a, x)) 1 [6,9,100,5,8,4,7,100,3,2,5,100]
16:25:07 <lambdabot>   (4,[6,9,1,5,8,4,7,2,3,2,5,3])
16:25:31 <mm_freak> > snd $ mapAccumL (\a x -> if x == 100 then (a+1,a) else (a,x)) 0 [1,2,3,100,100,123,100]
16:25:32 <lambdabot>   [1,2,3,0,1,123,2]
16:25:45 <mauke> @pl \a x -> if x == 100 then (a + 1, a) else (a, x)
16:25:46 <lambdabot> ap (ap . flip (if' . (100 ==)) . ((,) =<< (1 +))) (,)
16:25:57 <mm_freak> @src if'
16:25:57 <lambdabot> Source not found.
16:26:11 <mm_freak> :t if'
16:26:13 <lambdabot> Not in scope: `if''
16:26:21 <ozy`> when it's all scrunched up into one-liners like this, Haskell looks kind of like an in-progress game of four-dimensional Tetris where the blocks are coming from all directions simultaneously
16:26:38 <ozy`> also they have arrows drawn all over them
16:27:01 <lispy> chmod a-r #haskell
16:27:06 <mauke> mm_freak: if' c t e = if c then t else e
16:27:15 <mm_freak> ah, k
16:27:35 <dmwit> lispy: Aaah!  Where did everything go, I can't see what people are saying!
16:27:43 <dons> yes, you need to remember that haskell is actually a 4 dimensional programming language, you're trying to view on a 2d screen
16:27:47 <dons> so no wonder it looks a bit weird :)
16:27:52 <mmorrow> rwbarton: got it
16:27:53 <mmorrow> , (ppDoc . elimSyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
16:27:58 <lunabot>  Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int
16:28:03 <rwbarton> mmorrow: nice
16:28:11 <lispy> Biff?
16:28:17 <rwbarton> what's elimSyns?
16:28:23 <mauke> boolean iff
16:28:23 <dmwit> ffiB!
16:28:33 <lispy> mmorrow: I read that as Coffee not Cofree :)
16:28:34 <mmorrow> i implemented it also
16:28:40 <mmorrow> lispy: heh
16:29:17 <rwbarton> The coffee comonad
16:30:18 <mmorrow> i used ForallT like it was LamE kinda
16:30:20 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=227
16:31:04 <lispy> mmorrow: is ForallT a monad trans?
16:31:20 <mmorrow> , src 'ForallT
16:31:25 <lunabot>  data Type = ... | ForallT ([Name]) Cxt Type | ...
16:31:25 <lunabot>  infixl 9
16:31:35 <rwbarton> ForallT is the type constructor corresponding to universally quantified types
16:31:38 <mmorrow> it's a constructor from the TH type Type
16:31:43 <lispy> oh
16:32:38 <mmorrow> , let a = mkName "a" in ppDoc (ForallT [a] [] (ConT ''Maybe `AppT` VarT a))
16:32:40 <lunabot>  forall a . Maybe a
16:33:02 <mmorrow> , let a = mkName "a" in text . pretty . cleanNames $ (ForallT [a] [] (ConT ''Maybe `AppT` VarT a))
16:33:04 <lunabot>  ForallT [a] [] (AppT (ConT Maybe) (VarT a))
16:33:08 <luqui> mmorrow, care to summarize what you're doing?
16:33:19 <luqui> looks interesting
16:33:48 <mmorrow> rwbarton and i were getting down how to expand type syns
16:34:07 <luqui> ah. more boring than I thought ;-)
16:34:24 <Peaker> mmorrow: expand type synonyms to include..?
16:34:28 <mmorrow> i overlooked at first that you have to substitute the tyvars in the types you're applying the expanded type to
16:34:39 <mmorrow> so
16:34:47 <rwbarton> Peaker: expand as in replace with their definitions
16:34:54 <mmorrow> type A a b = (a, [b])
16:34:59 <mmorrow> then
16:35:37 <mmorrow> err, that's not the best one
16:35:47 <mmorrow> type A f a b = f (a, [b])
16:36:18 <mmorrow> A IO (A Maybe (Either Int Bool) Double) ===>
16:36:23 <mmorrow> crap
16:36:35 <mmorrow> A IO (A Maybe (Either Int Bool) Double) () ===>
16:37:14 <mmorrow> IO (Maybe (Either Bool Int, [Double]), ())
16:37:23 <mmorrow> oops
16:37:25 <mmorrow> IO (Maybe (Either Bool Int, [Double]), [()])
16:38:20 <mmorrow> the "coolest" part of it i thought is how you defined expand
16:39:00 <mmorrow> (assuming you're using everywhere, but you have to do the same thing any way)
16:39:01 <mmorrow> expand0 t@(ConT n) = maybe t expand (isSyn n) ; expand0 t=t
16:39:07 <mmorrow>         expand = everywhere (mkT expand0)
16:39:20 <mmorrow> (didn't mean to indent that)
16:39:25 <nicknull> replace100 : http://hpaste.org/11306
16:41:41 <nicknull> http://hpaste.org/11307 <- for any N
16:41:42 <mmorrow> so expand reifies the declaration for a constructor's name, checks if it's a type syn, if not returns Nothing, and if so wraps the expanded type in Just (ForallT [the quantified names] (the expanded type))
16:42:02 <skorpan> hm... implicit arguments would be pretty nice for haskell.
16:42:14 <skorpan> don't you agree?
16:42:35 <zachk> what are implicit arguments
16:42:43 <mmorrow> then after everything is fully expanded, you fold the tree into a single type by substituting those quantified names with the types that ForallT is applied to
16:42:59 <skorpan> arguments that are implicit in the sense that you don't have to write it out
16:43:20 <Peaker> there is elegance in the curried style, and the ease of partial application is appealing. But I am not sure its worth the lack of optional and keyword arguments...
16:43:21 <skorpan> i'm quite the newbie when it comes to agda, but i think agda has them
16:43:24 <mmorrow> so ForallT [tyvar names] (type) is analogous to LamE [patterns] (expression)
16:44:45 <mmorrow> rwbarton used a slightly different strategy: git://github.com/rwbarton/oldtype.git
16:46:04 <Peaker> actually, even with multi-arg functions, Haskell could allow very similar syntax including partial application, and support for keyword args
16:46:24 <mmorrow> rwbarton also did error checks that i didn't
16:46:48 <mmorrow> my code assumes the incoming Type isn't malformed/illegal
16:48:47 <capotej> does anyone here use haskell-mode for emacs? I'm trying to make C-c C-l automatically steal focus into the ghci buffer
16:48:58 <DuClare> Hum, does stdout have a handle, is there something that returns the handle?
16:49:01 <rwbarton> mmorrow: try  type A x = [x]; type B f = f x;  expand B A
16:49:13 <rwbarton> er, s/f x/f Int/
16:50:21 <mauke> :t stdout
16:50:22 <lambdabot> Not in scope: `stdout'
16:50:24 <DuClare> Aha
16:50:25 <DuClare> Yeah
16:50:32 <DuClare> I got it a second before you responded
16:50:32 <mauke> :t System.IO.stdout
16:50:33 <DuClare> :)
16:50:34 <lambdabot> GHC.IOBase.Handle
16:50:42 <mmorrow> hmm, that brings up a good side-point. since we're using reify, we can't just manufacture  TySynD name [names] type, but can only expand type syns that are already in scope
16:51:07 <mmorrow> i'll add a module of type syn defs though to mess with
16:53:53 <dons> ?users
16:53:53 <lambdabot> Maximum users seen in #haskell: 539, currently: 495 (91.8%), active: 23 (4.6%)
16:54:22 <DuClare> Hm.  Anybody got a good name for a generic "object" which does input and output via various means (sockets, fifos, etc.)
16:57:40 <DuClare> I guess "stream" is close
16:58:33 <mmorrow> rwbarton: ok
16:58:35 <mmorrow> , src ''A
16:58:37 <mmorrow> , src ''B
16:58:40 <lunabot>  type A x = [x]
16:58:44 <lunabot>  type B f = forall x . f x
16:59:17 <mmorrow> , (ppDoc . elimSyns) `fmap` [t|B A|]
16:59:22 <lunabot>  [] x_0 x_1
16:59:28 <mmorrow> heh
16:59:40 <mmorrow> , (ppDoc . normalizeT . elimSyns) `fmap` [t|B A|]
16:59:45 <lunabot>  [] x_0 x_1
16:59:55 <mmorrow> , (pretty . elimSyns) `fmap` [t|B A|]
16:59:59 <lunabot>  AppT (AppT ListT (VarT x_1627432301)) (VarT x_1627431552)
17:00:35 <mmorrow> that's on account of my not checking for cycles ;)
17:00:59 <mmorrow> , ppDoc $(lift =<< untype =<< [t|B A|])
17:01:03 <lunabot>  forall x_0 . [] x_0
17:01:18 <mmorrow> oh, i didn't mean cycles
17:01:46 <nicknull> capotej ye i do that , i would be nice but C-x o works ok
17:02:05 <mmorrow> oh, heh. i need to distinguish ForallT wrappers i introduce from ForallT wrappers that are there to begin with
17:02:26 <rwbarton> Well, try changing B to type B f = f Integer
17:02:40 <rwbarton> for now
17:02:46 <mmorrow> oh crap
17:03:25 <mmorrow> what would that do? (i have to recompile each change ;)
17:03:53 * mmorrow clearly hasn't tested or thought about this yet
17:04:55 <rwbarton> I don't know, that's kind of a tricky case because it includes a partially applied type synonym
17:06:26 <mmorrow> ah, i see. just added it as C (wait 30seconds for link)
17:06:33 <mmorrow> (link as in ld)
17:07:10 <mmorrow> ld is /so/ slow on this hosted webserver
17:07:35 <mmorrow> , src ''C
17:07:39 <lunabot>  type C f = f Integer
17:08:27 <mmorrow> rwbarton: it'd be cool to get a bunch of interesting cases/test cases together in a module. here it is so far..
17:08:29 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=227#a228
17:08:39 <mmorrow> , tysyn_dict
17:08:42 <lunabot>  [Luna.TySynPlayground.A,Luna.TySynPlayground.B,Luna.TySynPlayground.C]
17:08:50 <rwbarton> , (ppDoc . elimSyns) `fmap` [t|C A|]
17:08:52 <lunabot>  luna: Type synonym `Luna.TySynPlayground.A' should have 1 argument, but h...
17:09:04 <mmorrow> ooh
17:09:11 <rwbarton> , undefined :: C A
17:09:13 <lunabot>  luna: Type synonym `Luna.TySynPlayground.A' should have 1 argument, but h...
17:09:19 <mmorrow> hehe, ghc typechecking ftw
17:09:34 <rwbarton> But, I think it's actually legal with some ghc extension
17:09:47 <mmorrow> do you know which? i'll add it
17:10:29 <mmorrow> (unfortunately there's no -fglasgow-exts equiv)
17:11:19 <rwbarton> Hmm, the manual doesn't say.  (-fglasgow-exts works)
17:11:46 <mmorrow> crap
17:12:07 <rwbarton> -XLiberalTypeSynonyms
17:12:29 <mmorrow> this is the whole list http://moonpatio.com/docs/ghc/DynFlags.html
17:12:34 <lambdabot> Title: DynFlags
17:12:36 <mmorrow> ah nice, i'll add that now
17:13:32 <rwbarton> , ppDoc . elimSyns (AppT (ConT ''C) (ConT ''A))
17:13:34 <lunabot>  luna: Couldn't match expected type `a -> b'
17:13:35 <rwbarton> , ppDoc . elimSyns $ (AppT (ConT ''C) (ConT ''A))
17:13:40 <lunabot>  [] x_0 Integer
17:14:28 <mmorrow> heh, nice
17:14:57 <mmorrow> , (ppDoc . elimSyns) `fmap` [t|C A|]
17:15:04 <lunabot>  [] x_0 Integer
17:15:31 <mmorrow> hmm
17:15:41 <mmorrow> , undefined :: C A
17:15:42 <lunabot>  luna: Prelude.undefined
17:16:14 <mmorrow> , [3] :: C A
17:16:16 <lunabot>  [3]
17:16:33 <mmorrow> oh i see how to fix it
17:20:38 <mmorrow> maybe
17:25:16 <luqui> I think partition should be (a -> Either b c) -> ([b],[c])
17:25:31 <luqui> I end up needing that a lot more often than the standard one
17:25:51 <luqui> er, [a] -> ([b],[c]), of course
17:27:24 <mmorrow> i agree
17:27:57 <mauke> @hoogle [Either a b] -> ([a],[b])
17:27:57 <lambdabot> No results found
17:28:17 <luqui> oh duh, that's a nicer way to put it :-)
17:28:47 <luqui> what would be a good name for that function?
17:29:02 <rwbarton> @hoogle eithers
17:29:02 <lambdabot> No results found
17:29:22 <dolio> It's been discussed on libraries@ at length.
17:29:23 <rwbarton> I think there was a discussion on libraries@ about this function
17:29:39 <mauke> catEithers
17:30:29 <dolio> I thought they were adding something for 6.10, in fact.
17:31:42 <dolio> I like demux, but apparently that isn't popular.
17:32:31 <dolio> , Data.Either.lefts [Left 1, Right 'c']
17:32:33 <lunabot>  [1]
17:32:44 <dolio> , Data.Either.unzipEithers [Left 1, Right 'c']
17:32:46 <lunabot>  luna: Not in scope: `Data.Either.unzipEithers'
17:33:37 <sjanssen> , Foreign.unsafePerformIO (return ())
17:33:39 <dolio> , Data.Either.partitionEithers [Left 1, Right 'c']
17:33:39 <lunabot>  luna: Not in scope: `Foreign.unsafePerformIO'
17:33:41 <lunabot>  ([1],"c")
17:33:47 <dolio> There we go.
17:34:04 <sjanssen> mmorrow: how do you manage that?
17:34:37 <dolio> , Data.Either.partitionEithers [Right 'h', Left 1, Right 'e', Left 2, Right 'l', Left 3, Right 'l', Left 4, Right 'o']
17:34:39 <lunabot>  ([1,2,3,4],"hello")
17:35:08 <dolio> , Data.Either.rights [Right 'h', Left 1, Right 'e', Left 2, Right 'l', Left 3, Right 'l', Left 4, Right 'o']
17:35:10 <lunabot>  "hello"
17:35:18 <luqui> huh.
17:35:25 <luqui> why didn't hoogle find that?
17:35:29 <dons> ghc 6.10?
17:35:36 <dolio> It's probably still indexing 6.8.
17:36:10 <dolio> Or, whatever version of base comes with it.
17:36:11 <mmorrow> sjanseen: i'm compiling expressions directly instead of using runStmt, so with expressions you can not have everything visible
17:36:51 <mmorrow> , partitionEithers [Right 'h', Left 1, Right 'e', Left 2, Right 'l', Left 3, Right 'l', Left 4, Right 'o']
17:36:53 <lunabot>  ([1,2,3,4],"hello")
17:36:58 <sjanssen> mmorrow: oh, duh :)
17:37:11 <mmorrow> heh
17:37:34 <sjanssen> I just assumed that Data.Either wasn't imported
17:37:54 <sjanssen> I wonder if lunabot's approach should be adopted for lambdabot
17:38:15 <luqui> @pl \z -> first (z:) t
17:38:15 <lambdabot> flip first t . (:)
17:38:31 <sjanssen> mmorrow: do you handle memory and time leaks, segfaults and such?
17:38:34 <mmorrow> sjanssen: it definitely could. i just looked at hint's code yesterday, and it's using runStmt
17:38:54 <mmorrow> i have the evaluator in a separate program than the bot, and communicate over a pipe
17:39:25 <mmorrow> the evaluator only runs for seconds at a time, and has its cpu and mem usage controlled by System.Posix.Resource
17:39:40 <mmorrow> , error (fix id)
17:39:43 <lunabot>  luna: out of memory (requested 2097152 bytes)
17:39:52 <mmorrow> , last [0..]
17:39:58 <lunabot>  Killed.
17:40:05 <mmorrow> (a time limit too)
17:40:28 <sjanssen> lunabot's eval seems nicer than mueval
17:40:35 <dolio> fix id eats memory?
17:40:47 <sjanssen> , []
17:40:48 <lunabot>  []
17:40:53 <mmorrow> mueval uses hint's, and imo it's better than hint's :)
17:41:07 <mmorrow> unfortunately lunabot is compiling to bytecode at the moment
17:41:20 <rwbarton> I want a monad where I can store several continuations in state somewhere
17:41:21 <mmorrow> until i figure out how to compile straight to machine code
17:41:22 <rwbarton> Is this possible?
17:42:00 <rwbarton> Something like newtype R a = R { unR :: ReaderT [(Type, R a)] (ContT Type Q) a } deriving (Monad)
17:42:03 <mmorrow> also, finding a way to do that is a fairly high priority of mine
17:42:08 <rwbarton> But ghc won't let me derive Monad for that type
17:42:30 <sjanssen> rwbarton: that isn't a Monad
17:42:58 <sjanssen> or, at least, it isn't a ReaderT Monad
17:42:59 <mmorrow> <dolio> fix id eats memory?
17:43:00 <rwbarton> sjanssen: True, but I think newtype deriving is supposed to figure out what I mean
17:43:19 <rwbarton> sjanssen: wait, what do you mean?
17:43:21 <dolio> mmorrow: Due to the bytecode?
17:43:23 <sjanssen> rwbarton: I think that is expecting far too much
17:43:26 <mmorrow> dolio: i'm not sure exactly which optimization stages are left out when going to bytecode, but that's surely one of them
17:43:29 <mmorrow> dolio: yeah
17:43:44 <dolio> Sounds plausible.
17:44:02 <rwbarton> It works if I change the inner 'R a' to 'Int'
17:44:18 <sjanssen> rwbarton: 'a' is mentioned in both type parameters to ReaderT
17:44:27 <rwbarton> oh, hmm.
17:44:59 <rwbarton> All right, I changed it to 'R Type' and now I get "the newtype may be recursive"
17:46:21 <sjanssen> yeah, GHC refuses to newtype derive recursive newtypes
17:50:09 <nicknull> can a data have a function as attribute(what is the hskell-term?) so when i call is_spam i computs the value of spam / (spam+ham) ?
17:50:55 <sjanssen> nicknull: functions are data, so yes a function can be a component in a data declaration
17:51:18 <pjdelport> nicknull: can you expand on that a bit?
17:51:20 <mmorrow> sjanssen: actually, runStmt too can have only what is explicitly imported in scope (this may be new with 6.10?)
17:51:30 <sjanssen> data Foo = Foo {x :: Int, y :: String -> String}
17:52:07 <sjanssen> mmorrow: possibly, I'm not too familiar with the code
17:52:18 <pjdelport> nicknull: what exactly do you mean by "data having a function as attribute"?
17:52:22 <nicknull> http://hpaste.org/11308 , can i ahve an attribute spam / (spam+ham)::Float inside?
17:52:24 <mmorrow> sjanssen: neither am I until very recently
17:53:33 <pjdelport> nicknull: you can have is_spam x = spam x / (spam x +ham x)
17:53:50 <sjanssen> nicknull: you're clearly tainted by OO thinking :)
17:54:11 <nicknull> guess i cant
17:54:21 <sjanssen> nicknull: what we'd do in Haskell is keep the function separate from the data, as pjdelport suggests
17:54:32 <nicknull> yes, ugly :)
17:54:39 <pjdelport> nicknull: there's no need or point in putting it "inside"
17:54:43 <sjanssen> I don't see how that is ugly
17:55:02 <pjdelport> nicknull: the spam and ham accessors are not "inside" either
17:55:08 <pjdelport> they are just plain functions
17:55:11 <luqui> I think the difference is that nicknull probably wants a default that can be overridden
17:55:25 <luqui> otherwise it wouldn't be an "attribute"
17:56:25 <pjdelport> nicknull: the record syntax is just a shortcut for defining the spam and ham functions; the result is the same as defining them normally like is_spam above
17:56:42 <luqui> nicknull, oh you probably don't want to parameterize the type on spam and ham... just my guess
17:56:57 <luqui> nicknull, i.e. data Word spam ham  -- probably wrong, should be just data Word
17:57:22 <nicknull> luqui: dont undestand
17:57:40 <luqui> nicknull, what's you're background, so I can explain this easiest?
17:57:53 <nicknull> python, some lisp, java
17:58:01 <pjdelport> nicknull: he means it should be data Word = Word { ... }
17:58:03 <luqui> you know java generics?
17:58:45 <nicknull> nope
17:59:03 <luqui> hm.  I'll try anyway.  data Word spam ham is not a type, it is a type *function*
17:59:08 <luqui> i.e. it takes two types and returns a type
17:59:15 <luqui> so you could say, for example, Word Int [Float]
17:59:20 <luqui> and that would be atype
17:59:28 <nicknull> i know python inside out
17:59:28 <nicknull> i see it was pointless havingparmeters
17:59:50 <luqui> yeah, python is not statically typed, though, so this doesn't make sense at all
18:01:03 <pjdelport> nicknull: there's also probably not much point in declaring Spam and Ham type synonyms
18:02:36 <nicknull> no i see
18:02:56 <nicknull> i ws mostly looking for a reason to declare new types rather than having a rea reason to do so :=)
18:04:26 <pjdelport> ok
18:04:44 <pjdelport> do you know the difference between type, data, and newtype?
18:05:07 <luqui> heh.  the difference between data and newtype might be a bit much for a noob.
18:05:53 <pjdelport> actually, i didn't understand type and data without newtype
18:05:56 <conal> has the haddock syntax for bold changed?  '''foo''' is coming out '''foo'''.
18:07:06 <luqui> pjdelport, that's... odd
18:07:15 <luqui> can you give me an intuition why
18:08:37 <pjdelport> luqui: type and newtype share the property of not having run-time representation, newtype and data share the property of being distinct in the type system
18:09:36 <nicknull> what is instance used ofr? instance is an instance of a type?
18:09:44 <pjdelport> luqui: so understanding newtype as that intersection makes the relationship between type and data clearer too
18:10:12 <nicknull> tell me the diff
18:10:38 <luqui> instance of a type*class*
18:10:38 <pjdelport> nicknull: type classes have instances
18:10:50 <nicknull> do you use newtype and data a lot?
18:10:53 <pjdelport> nicknull: they're not really related to instances in OO languages
18:10:59 <luqui> so for example, Eq is the typeclass of things that support equality
18:11:17 <pjdelport> luqui: in Python terms, a type class is like a protocol
18:11:18 <luqui> there is an instance Eq Int, for example, since Int supports equality (there is an operation (==) :: Int -> Int -> Bool)
18:11:36 <mm_freak> data Mod where Mod :: (?n::Integer) => Integer -> Mod   -- what do you think about this "solution" for modular arithmetic?  it works well (besides that fromInteger doesn't work)
18:11:50 <pjdelport> luqui: and a type class instance is a particular implementation of that protocol
18:11:58 <luqui> pjdelport, thanks for translating.  I don't know python well.
18:12:08 <pjdelport> err, oops
18:12:16 <pjdelport> that was supposed to be addressed to nicknull
18:12:21 * luqui knows
18:12:25 <pjdelport> nicknull: see above :)
18:12:27 <luqui> but he might like to know that :-)
18:12:40 <sjanssen> mm_freak: why not just data Mod = Mod (Integer -> Integer)?
18:13:07 <rwbarton> sjanssen: Then computation won't be shared
18:13:53 <luqui> mm_freak, so that is essentially using definitional equality.
18:13:58 <pjdelport> nicknull: so in Python, int, float, complex and so on all implement the number protocol
18:14:03 <luqui> so you have to do arithmetic elsewhere, and then import it into mod.
18:14:28 <luqui> mm_freak, actually I don't follow.  How do you prevent operations between different classes
18:14:30 <pjdelport> nicknull: in Haskell terms, they are instances of the Num type class
18:14:35 <pjdelport> @src Int
18:14:35 <lambdabot> data Int = I# Int#
18:14:36 <mm_freak> sjanssen: honestly i just haven't thought of that, i'll give it a try
18:14:46 <pjdelport> @instance Num Int
18:14:46 <lambdabot> Maybe you meant: instances instances-importing
18:14:53 <mm_freak> luqui: wait
18:14:58 <pjdelport> @src Num
18:14:58 <lambdabot> class  (Eq a, Show a) => Num a  where
18:14:58 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:14:58 <lambdabot>     negate, abs, signum     :: a -> a
18:14:58 <lambdabot>     fromInteger             :: Integer -> a
18:15:03 <pjdelport> @instances Num
18:15:04 <lambdabot> Double, Float, Int, Integer
18:15:05 <rwbarton> mm_freak: x^n won't run in log n multiplications with that definition
18:15:16 <rwbarton> mm_freak: unless you memoize the Integer -> Integer function
18:15:25 <sjanssen> rwbarton: hmm, are you sure?
18:15:37 <sjanssen> rwbarton: I also don't think mm_freak's solution is any different in that respect
18:15:41 <rwbarton> sjanssen: pretty sure...
18:15:45 <mm_freak> http://hpaste.org/11309 ⇐ this is what i've got so far
18:15:51 <rwbarton> sjanssen: I don't really know what the semantics of mm_freak's solution are
18:16:04 <rwbarton> (I just use the type class magic)
18:16:09 <mm_freak> rwbarton: it seems to
18:16:46 <rwbarton> mm_freak: Hmm, are you compiling with -O2?  Maybe the compiler is being clever
18:16:48 <mm_freak> sjanssen is right…  i think the function-based solution is equivalent
18:16:58 <mm_freak> rwbarton: i always compile with -O2
18:17:10 <rwbarton> mm_freak: Can you try without as a sanity check for me?
18:17:11 <rwbarton> :)
18:17:25 <mm_freak> uhm, sorry
18:17:34 <mm_freak> this is without -O2, because i'm trying it in GHCi
18:17:43 <rwbarton> oh
18:19:06 <sjanssen> how should one implement (==) on Mod?
18:19:14 <mml`> i have produced some applescript that attempts to tile all my application windows on OS X in a similar way as a tiling window manager.  anybody know of a completed project of this sort?
18:19:32 <mml`> i suppose this is OT, strictly speaking... but xmonad made me do it!
18:21:04 <Cale> hmm, odd: In the yi 0.5 release, it says "if you want unix console support, pass the -fvty option to cabal install", but it also sayd that the Gtk2Hs frontend is not supported in this release. Does this mean that Yi has a third frontend, or that installing without -fvty gives you something essentially useless?
18:21:27 <rwbarton> > take 30 $ iterate (\y -> (y * y) `mod` 7) 5
18:21:29 <lambdabot>   [5,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4]
18:21:36 <rwbarton> > let a ^*^ b = \p -> (a p * b p) `mod` p in let x p = 5 `mod` p in take 30 . map ($ 7) $ iterate (\y -> y ^*^ y) x
18:21:39 <sjanssen> rwbarton: http://hpaste.org/11309#a1 multiplications are shared
18:21:41 * sjanssen must go
18:21:48 <ozy`> Cale: the yi documentation is generally nonsensical from what I've seen
18:21:48 <mm_freak> sjanssen: is it even possible?  (==) results in Bool, not in a function
18:21:51 <lambdabot>   thread killed
18:21:53 <ozy`> but I haven't looked in a while
18:21:58 <sjanssen> mm_freak: see my annotation for a stupid solution
18:22:09 <Cale> says*
18:22:23 <sjanssen> mm_freak: it would be possible if operating on a bounded type (just use the largest value as modulus)
18:22:55 <mm_freak> sjanssen: i don't think that a bounded type is a solution, because the point of the Mod type is to allow dynamic moduli
18:23:15 <loki> what is the syntax for haskell with the { and ; ? or somewhere i can see an example
18:23:24 <tomet> I have a big (finite) array and I want to find the smallest element in that array
18:23:34 <tomet> what's the best parallel way to do this
18:23:53 <Cale> loki: braces and semicolons can be used instead of indentation after 'of', 'let', 'where', or 'do'
18:24:15 <mm_freak> sjanssen: i think, Eq doesn't even make sense for Mod, since (==) is equality, not equivalence, but unfortunately Num needs Eq
18:24:18 <loki> okay
18:24:20 <Cale> loki: The semicolons separate the items, rather than terminate them.
18:24:32 <Cale> (that is, the last item doesn't need a semicolon after it.)
18:24:34 <nicknull> im using msys, can i create a script so i can do just "ghc file" instead of "ghc --make -O2 file" ?
18:24:41 <tomet> using something like smallest (x:l) = pseq b (if a < b then a else smallest b) makes it slower
18:24:47 <Cale> You can also have just semicolons, when putting more than one item on a line.
18:24:54 <rwbarton> Hmm, what's the difference between what sjanssen is doing and what I did above with ^*^?
18:25:21 <nicknull> lol lazy IO wtf, why doesnt haskell print when i say it should ina  do?
18:25:50 <mm_freak> nicknull: it does, usually
18:26:23 <mm_freak> lazy IO is something like getContents, where the contents of a file are read lazily
18:26:29 <tomet> anyone have any ideas about how best to find the smallest element of a list using parallel haskell?
18:26:46 <mm_freak> if you have a putStr somewhere and it doesn't print anything, it may be related to buffering
18:27:01 <zachk> hFlush stdout
18:27:08 <rwbarton> sjanssen: you pay the cost when you try to actually evaluate the function.
18:27:32 <rwbarton> sjanssen: try (5 :: Mod)^(2^30)
18:35:09 <twfxfnxfnf> humans are code's worst enemy
18:35:15 <mmorrow> loki:
18:35:18 <mmorrow> , either undefined (prettyPrintWithMode (defaultMode{layout=PPNoLayout})) . parseHsExp $ "let x = case y of [z] -> let x = (z,z) in (z,x) in x where y = [42]"
18:35:21 <lunabot>  "let { x = case y of { [z] -> let { x = (z, z)} in (z, x)}} in x"
18:35:48 <mmorrow> (that's using haskell-src-exts for parsing and prettyprinting)
18:36:29 <mmorrow> um, i guess the where just got the inexplicable chop or something
18:37:05 <vixey> @hoogle inexplicableChop
18:37:05 <lambdabot> No results found
18:37:06 <mmorrow> oh, i think that's my fault without how i defined parseHsExp
18:37:24 <vixey> this is a good name for an algorithm
18:37:37 <mmorrow> haha, totally
18:38:21 <Cale> unsafeInexplicableChop#
18:38:49 <mmorrow> and all computer within 40 meters just melt
18:40:10 <Cale> unsafeHaltAndCatchFire
18:40:19 <mmorrow> lol#
18:40:50 <mmorrow> i had a powerbook G4 that did exactly the latter part of that
18:41:02 <ddarius> It kept running?
18:41:18 <dons> nice, http://www.reddit.com/r/programming/comments/7849r/implementing_vector_space_bases_via_type_families/
18:41:20 <lambdabot> Title: Implementing vector space bases via type families : programming, http://tinyurl.com/5bop2z
18:41:21 <dons> go conal
18:42:31 <Cale> If we get enough military applications of Haskell, I wonder how long it will be before there is a monad of operations defined explicitly to obliterate sensitive parts of the system hardware.
18:42:35 <mmorrow> one of the hinges for the display cracked, then over a week or two wore through the sheath of the wire supplying it power, then shorted it and caught the some cloth part of the wire once-protective-sheath on fire
18:42:53 <mmorrow> s/the// + wire's
18:43:23 <mmorrow> ddarius: yeah, it actually did. i pulled the battery out asap though
18:43:44 <dons> Cale: calling the special 'melt my hd with fire' instruction?
18:43:46 <maxote> Cale, for .mil spec, Ada is the recommendation
18:44:17 <conal> dons: :)
18:44:27 <lament> iirc ada is no longer the recommendation?
18:44:31 <ozy`> mmorrow: right, I'm gonna watch out for that with my powerbook now...
18:44:54 <dons> maxote: how current is your data? Ada's heyday was a decade ago, from what i've seen.
18:44:58 <conal> dons: thx for the reddit.
18:45:12 <dons> i like the new blog format, conal. very readable
18:45:20 <Cale> dons: yeah, something like that :)
18:45:21 <mmorrow> , runMILSPECT (releaseTheHoundsWith prejudice >>= \scent_trail -> coerceMissiles# `withGuidance` scent_trail >> return True)
18:45:22 <lunabot>  luna: parse error on input ``'
18:45:59 <conal> dons: thx.  too bad it's not as pretty on haskell planet.
18:46:09 <dons> ah well
18:47:01 <loki> for some reason my program in producing \ESC in the output but I can't tell from where
18:48:44 <loki> it generates a ^[[?1034h when i redirect to file
18:48:47 <vixey> I spent like an hour or something running the unification algorithm by hard
18:48:51 <vixey> hand*
18:48:53 <loki> at the very end of output
18:51:17 <conal> another: http://www.reddit.com/r/programming/comments/784b1/simpler_more_efficient_functional_linear_maps/
18:51:19 <lambdabot> Title: Simpler, more efficient, functional linear maps : programming, http://tinyurl.com/6homb5
18:53:57 <Cale> conal: I like the observation regarding the basis and logarithms :)
18:55:24 <conal> Cale: thx. :)  it jumped out at me while i was writing.
18:56:24 <SamB_XP> conal: scary
18:57:08 <grkz> would "last" be more efficient than "head $ reverse"?
18:59:20 <ozy`> hmm, is reverse tail recursive?
18:59:34 <ozy`> (that being one of the places where it -would- count...)
18:59:39 <ozy`> @src reverse
18:59:39 <lambdabot> reverse = foldl (flip (:)) []
18:59:51 <grkz> nevermind, doing :set +s shows that "last" seems to be more efficient :)
19:00:04 <ozy`> @src last
19:00:04 <lambdabot> last [x]    = x
19:00:05 <lambdabot> last (_:xs) = last xs
19:00:05 <lambdabot> last []     = undefined
19:00:15 <mmorrow> @src foldl
19:00:16 <lambdabot> foldl f z []     = z
19:00:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:01:36 <dancor> @where hpaste2
19:01:37 <lambdabot> I know nothing about hpaste2.
19:01:46 <vixey> ?where moonpaste
19:01:46 <lambdabot> I know nothing about moonpaste.
19:01:46 <dancor> is there a newer hpaste that is less bitrotted?
19:01:53 <vixey> lambdabot--
19:02:06 <dons> dancor: hpaste2 is on git hub
19:02:20 <vixey> why lambdabot forgets everything I tell it
19:02:22 <dancor> oh but no one is running one?
19:02:33 <ozy`> @unpl flip (:)
19:02:33 <lambdabot> (\ b c -> (:) c b)
19:02:37 <Cale> Another kind of funny logarithm which I used to use quite a bit in 1st year classical algebra is the map which sends a nonzero rational number to the sequence of integers (with finite support) which are the exponents in its prime factorisation. Picturing numbers as 'vectors' in that way is a handy way to get some visual intuition for how various number theoretic operations work.
19:03:12 * dancor guesses/realizes that hpaste.org will switch to it when it is ready
19:03:45 <vixey> why is that a logarithm?
19:04:04 <shrughes> log(xy) = log(x) + log(y) i guess
19:04:08 <lament> i'm guessing the length of that sequence is the funny logarithm?
19:04:14 <Cale> Well, it sends 1 to the zero sequence, it sends a product to the sum of the associated sequences, and it sends a power to the scalar multiple.
19:04:15 <vixey> ok
19:04:44 <Cale> lament: No, the sequence itself is :)
19:05:06 <mmorrow> dancor: http://moonpatio.com:8080/
19:05:31 <mmorrow> (which redirects immediately to http://moonpatio.com:8080/fastcgi/hpaste.fcgi/)
19:06:00 <lament> what's wrong with hpaste?
19:06:38 <dancor> lament: it doesn't remember me which angers me
19:06:39 <dons> it's been working reliably for too long
19:07:02 <dancor> it doesn't announce either which i guess is ok but it shouldn't pretend to be able to then
19:07:28 <mmorrow> hpaste2 has * better syntax highlighting * SEARCH * an option to higlight/unhighlight (w/ yellow background) lines of pastes by line no
19:08:07 <mmorrow> and its syntax highlighting support probably around 30+ languages
19:09:09 * mmorrow has issues with being able to reach the 's' key at the end of words or something
19:09:51 <mmorrow> and you just need fastcgi+sqlite to run it
19:10:02 <Cale> mmorrow: also, hpaste2 puts keywords in bold which throws alignment way off ;)
19:10:16 <Cale> mmorrow: (Would be nice to see that fixed ;)
19:10:26 <mmorrow> heh, yeah and line numbers don't line up
19:11:06 <mmorrow> hmm, i hadn't noticed the bold keywords alignment thing, but yes i should try to fix those
19:11:36 <mmorrow> (assuming a newer release of hpaste2 hasn't already ;)
19:12:35 <Cale> Another feature which I'd like to see is direct editing, for those cases where I only notice some small typo after the fact.
19:12:39 <ozy`> Cale: if bold keywords mess up your browser, that's a font/browser problem, not an issue with the software...
19:12:53 <mmorrow> Cale: yes. me too definitely.
19:13:24 <vixey> How do you go from heuristic method --> algorithm?
19:13:26 <mmorrow> Cale: i guess then user accounts w/passwd would have to be added
19:13:33 <Cale> ozy`: Well, yes, technically. But it's probably easier to change it just to colour and not bold them than to get patches into FreeType2/Firefox.
19:14:05 <Cale> mmorrow: possibly... though it probably would not be so bad just to allow anyone to edit anything
19:14:54 <mmorrow> Cale: yeah, that sounds reasonable if updates don't actually destructively update the db table
19:15:47 <mmorrow> (and that'd be many times easier than first learning how everything fits together, then adding login/accounts ...)
19:19:10 <mmorrow> Cale: could you possibly take a screenshot showing bold keywords throwing alignment off in your browser?
19:19:15 <Cale> sure
19:19:21 <mmorrow> thx
19:20:23 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=145 -- actually, if you could just have a look at main here, the alignment appears off by a whole character.
19:20:29 <joed> Hmm, is anyone here interested in large breed dogs? Rotties? If so I could recommend a fresh batch of full German / German full of personality pupps..
19:20:37 <Cale> (If you don't see it there, I'll just make a screenshot)
19:20:47 * mmorrow looks
19:22:14 <mmorrow> hmm, i think i'm either not understanding what i'm looking for or it doesn't happen in my browser
19:23:10 <Cale> mmorrow: okay
19:23:58 <Cale> the SDL.init should line up with the setVideoMode
19:24:09 <Cale> I'll take a screenshot of how it looks here
19:25:38 <rwbarton> Cale: it looks fine for me
19:26:49 <mmorrow> Cale: is this how you see it? http://moonpatio.com/images/hpaste_align_0.png
19:26:50 <Cale> http://cale.yi.org/share/alignmentproblem.png
19:26:52 <nicknull> @src flip
19:26:56 <Cale> no
19:26:57 <lambdabot> flip f x y = f y x
19:27:10 <mmorrow> oh yuck, weird
19:27:50 <mmorrow> i'm using firefox 2.0.0.16 on linux
19:28:11 <mmorrow> Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.16) Gecko/20080715
19:28:17 <Cale> Ah, it's the specific font that I use for monospace type.
19:28:27 <mmorrow> ah
19:28:36 <Cale> The bold version of the font has wider characters than the regular one.
19:28:40 <SamB_XP> Cale: I don't think there are many people who don't have that problem
19:28:51 <SamB_XP> to some degree or another
19:29:00 <Cale> Well, anyone who uses Andale Mono...
19:29:14 <mmorrow> SamB_XP: you mean you see it like http://cale.yi.org/share/alignmentproblem.png also?
19:29:36 <SamB_XP> oh, wait
19:29:42 <mmorrow> is Andale Mono (or another with this behaviour) a common default?
19:29:46 <SamB_XP> no I have a different aligment problem
19:30:08 <SamB_XP> mine has to do with differing height metrics for bold and normal
19:30:11 <SamB_XP> not width
19:30:13 <mmorrow> compared to this, what is messed up on yours? http://moonpatio.com/images/hpaste_align_0.png
19:30:35 <SamB_XP> that is, the line numbers are misaligned from the code
19:30:49 <mmorrow> oh yeah, i think everyone has that
19:30:56 <Cale> I don't have the height problem.
19:31:01 <mmorrow> haha
19:31:14 <SamB_XP> Cale: you probably just haven't noticed it yet
19:31:29 <mmorrow> Cale: really? you mean the line nos don't start to become unaligned over the course of tens of lines?
19:31:30 <SamB_XP> jt's a bit more subtle
19:31:36 <Cale> How long does the file have to be in order to see it?
19:31:47 <mmorrow> it also depends on your magnification
19:31:50 <SamB_XP> depends on the details of font size and font, presumably
19:31:52 <Cale> I don't see it happening in that starfield paste.
19:31:59 <Cale> (at all)
19:32:01 <mmorrow> files over 100-200 lines make it very apparent
19:32:08 <SamB_XP> also browser
19:32:11 <mmorrow> short ones not so much
19:32:24 <SamB_XP> I've seen it in maybe a 15 line program
19:33:10 <rwbarton> There's a MonadState s m => MonadState s (ContT r m), but no MonadWriter w m => MonadWriter w (ContT r m)?
19:33:31 <Cale> I don't see any misalignment on a 137 line paste...
19:33:35 <dolio> rwbarton: You can't write one, because of pass.
19:33:45 <mmorrow> SamB_XP: yeah true. if i zoom in it'll go away in certain situations
19:33:52 <rwbarton> dolio: Yeah, that just occurred to me.  Fortunately I only care about tell
19:33:58 <dolio> At least, not one that works right.
19:34:07 <rwbarton> I guess I'll just use StateT instead
19:34:18 <dolio> That's why censor is so much better. :)
19:36:05 <Cale> Bitstream Vera Sans Mono and DejaVu Sans Mono both seem to be fine in both dimensions.
19:36:19 <dolio> Of course, censor doesn't do the same thing. But then, I'm not sure I've ever seen someone really need pass.
19:36:23 <Cale> Andale Mono is fine vertically but not horizontally.
19:36:54 <Cale> I haven't found a font with the vertical problem... perhaps I'll try some courier-like fonts.
19:37:15 <SamB_XP> Cale: it's not too surprising that those fonts would be the same ... considering that DejaVu was Vera
19:37:56 <Cale> Okay, Nimbus Mono has a severe version of the vertical problem :)
19:38:37 <SamB_XP> I think I use Courier New
19:38:57 <Cale> Lucida Sans typewriter seems okay, and so does Courier New for me.
19:39:20 <SamB_XP> maybe you're at a size where it behaves better ;-)
19:47:07 <nolraiWest> Is there any way to have a function that takes as in input a function that works on any list? and only functions that work on any list? The naive way of doing this dosn't compile.
19:47:34 <rwbarton> nolraiWest: what have you tried?
19:47:59 <rwbarton> nolraiWest: It could just be that you need to turn on some extension
19:49:17 <Cale> nolraiWest: With extensions.
19:49:23 <nolraiWest> aOrb bool f = if bool then modifyA f else modifyB f
19:49:51 <nolraiWest> {-# LANGUAGE GeneralizedNewtypeDeriving, EmptyDataDecls, PatternSignatures, MultiParamTypeClasses, FlexibleContexts,  TypeSynonymInstances #-}
19:49:59 <rwbarton> what's the type signature you want to write?
19:51:21 <Cale> nolraiWest: Speculatively, it sounds like you want a higher rank type.
19:52:17 <nolraiWest> hmm, I don't know. I'm not sure the type system handles it. Something like Bool -> (forall a. List a -> List a) -> MyType ()
19:52:54 <rwbarton> That's right, just turn on Rank2Types
19:52:54 <Cale> Yep, you want RankNTypes
19:53:18 <Cale> (or Rank2Types, I suppose)
19:53:35 <Cale> I'm not sure why there's a separate Rank2Types extension.
19:53:47 <Cale> Does Hugs support Rank2Types but not RankNTypes?
19:54:08 <dons> it supports ST, so certainly Rank2
19:54:16 <nolraiWest> Ok cool.
19:54:21 <Cale> It doesn't seem to me that it should be much harder to support one if you support the other.
19:56:24 <nicknull> does sqlite support full text search?
19:56:59 <SamB_XP> what the what now ?
19:57:37 <dolio> Cale: The hugs manual appears to say it has rank-2 but not rank-n.
19:57:48 <Cale> dolio: aha, so that would be it then.
19:58:37 <dolio> GHC apparently actually does just rank-2 when it's specified.
19:58:46 <dolio> And errors out for rank-3 and above.
19:59:13 <SamB_XP> dolio: it would be kind of bad if it didn't!
19:59:26 <dolio> Yeah, I guess.
20:02:18 <dolio> It wasn't that long ago that {-# LANGUAGE Foo #-} would turn on a whole bunch of stuff besides Foo, so it wouldn't have surprised me if they didn't bother limiting it to 2.
20:05:12 <SamB_XP> well, RankNTypes presumably turns on Rank2Types as well ;-P
20:05:41 <dolio> Well, I assume it's the same code, with an if expression somewhere. :)
20:06:03 <Cale> It would be kind of funny if the code was completely separate :)
20:06:10 <dolio> Heh.
20:07:48 <litb> hello all
20:08:01 <litb> would it be difficult to write a c parser with haskell and parsec ?
20:08:30 <SamB_XP> litb: import Language.C or something like that
20:08:36 <litb> i see this channel has lost many nicks !
20:08:37 <litb> :p
20:08:37 <shrughes> define 'difficult'.  why do you want to write your own?
20:08:49 <litb> shrughes: because i want to learn
20:08:53 <shrughes> oh
20:09:02 <litb> how much knowledge of haskell is required?
20:09:05 <shrughes> so if we answer yes you'll do it, no then you won't?
20:09:27 <dons> litb: there's already a library for C parsing
20:09:34 <shrughes> more knowledge of C is required than of Haskell
20:09:38 <litb> dons: i want to get the hang of all this
20:09:39 <SamB_XP> I wouldn't use C for learning that
20:09:56 <SamB_XP> it's rather a pain to write parsers for, as I understand it
20:09:57 <dons> litb: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c
20:09:57 <litb> i know c quite well enough to to this i think
20:09:59 <lambdabot> Title: HackageDB: language-c-0.3.1, http://tinyurl.com/6xtat7
20:10:06 <litb> but the problem is on the haskell side
20:10:10 <dons> so you could start with that, if you want to write another C parser.
20:10:22 <dons> well, try writing a parser in parsec for something smaller
20:10:38 <SamB_XP> you could write one for a simplified C I guess
20:10:56 <litb> oh
20:10:58 <shrughes> C is not that bad
20:11:07 <SamB_XP> if you were just looking to learn parsing rather than actually making something usable
20:11:12 <litb> i think c is quite clean?
20:11:16 <shrughes> says me with my 0 experience.  It's no C++
20:11:17 <lament> writing a parser for c sounds like a lot of boring, repetitive, fairly mindless effort
20:11:23 <lament> in short, stuff people normally get paid for
20:11:32 <lispy> litb: if the goal is to parse C, I guess it makes sense to start with the little bits.  Like using parsec to parse the lexical tokens instead of some other form of lexing.
20:11:55 <litb> oh lament
20:12:04 <dons> a parser for a language we don't have a parser for would be good :)
20:12:19 <lispy> yeah, write me a python parser for greater good
20:12:24 <SamB_XP> in fact I believe at least two summer of code students were paid to deliver Language.C ... and this was AFTER the parser was written
20:12:25 <litb> dons: what would that be for example ?
20:12:30 <lament> a parser for Scheme :)
20:12:36 <SamB_XP> (it already existed for c2hs)
20:12:37 <litb> lament: isnt there already one?
20:12:48 <SamB_XP> litb: that isn't the point
20:12:49 <litb> this 48h stuff i mean
20:12:55 <litb> oh i see
20:13:05 <litb> well so i try to do a scheme parser
20:13:09 <litb> but im a scheme novice
20:13:30 <lament> that wasn't a serious suggestion
20:13:33 <SamB_XP> the point is that scheme is not likely to be more than you can chew
20:13:40 <SamB_XP> lament: why not ?
20:13:50 <lispy> write a parser for the English language.  Bonus points if it can generate grammatically correct output in other languages that preserves the original meaning.
20:13:56 <lament> SamB_XP: a -parser- for Scheme?
20:14:03 <lament> You have five minutes. Go.
20:14:05 <litb> SamB_XP: oh i see
20:14:07 <litb> so it is easy?
20:14:09 <shrughes> start with Scheme, then C.  it's like learning a year of Esperanto before a year of another foreign language
20:14:12 <SamB_XP> (of course, if you want to do full RnRS, that actually is a bit difficult)
20:14:24 <SamB_XP> (the numbers are kind of a pain to get right)
20:14:38 <litb> oh
20:15:10 <SamB_XP> lament: despite my frequent statements that lisp has no syntax, lisp actually has a syntax
20:15:18 <SamB_XP> even the kind you can parse
20:15:24 * lispy has a syntax
20:15:24 <litb> i guess when i want to write an intepreter for c with haskell, i have to use the mutable stuff?
20:15:33 <litb> i.e the non-pure things?
20:15:42 <lament> no.
20:15:52 <litb> oh
20:15:56 <lament> you never "have" to use the non-pure things
20:16:10 <litb> oh i see
20:16:14 <lispy> ?faq Can I program with mutable state?
20:16:15 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:24 <lament> lambda calculus is turing-complete without them
20:16:25 <litb> -.-
20:16:26 <SamB_XP> ?faq can I write a C interpreter without doing so?
20:16:27 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:46 <litb> ?faq can i not write a C interpreter without doing so?
20:16:46 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:48 <litb> -.-
20:16:51 <shapr> ?faq Is haskell teh awesome of programming?
20:16:51 <lambdabot> The answer is: Yes! Haskell can do that.
20:16:59 <litb> neat
20:17:01 <SamB_XP> ?faq is lament a jerk?
20:17:01 <lambdabot> The answer is: Yes! Haskell can do that.
20:17:11 <SamB_XP> ?faq what is six times seven ?
20:17:11 <lambdabot> The answer is: Yes! Haskell can do that.
20:17:22 <litb> ?faq can't haskell do that?
20:17:23 <lambdabot> The answer is: Yes! Haskell can do that.
20:17:25 <litb> lol
20:17:27 <lispy> ?faq Can we solve the halting problem?
20:17:27 <lambdabot> The answer is: Yes! Haskell can do that.
20:17:47 <lispy> > let x = x in x
20:18:03 <lambdabot>   thread killed
20:18:12 <lament> ?faq The answer is: No! Haskell can not do that.
20:18:13 <lambdabot> The answer is: Yes! Haskell can do that.
20:18:14 <lispy> oh, must not be compiled with -Wnon-halting
20:18:53 <shrughes> > let (thread, killed) = (thread, killed) in thread killed
20:19:09 <lambdabot>   thread killed
20:19:13 <litb> oO
20:20:36 <lispy> > let 1 + 2 = 7 in 1 + 2
20:20:37 <lambdabot>   7
20:20:47 <litb> i guess i should start with something as simple as an INI-file , and then go further
20:21:03 <lispy> litb: write a parser for floating point numbers
20:21:05 <litb> lol lispy
20:21:23 <lispy> litb: no, I'm serious, it's a good exercise if you're learning parsec
20:21:40 <litb> i meant that 1 + 2 thingy :p
20:22:05 <lispy> ah :)
20:22:10 <litb> hold on. what do you mean by parsing floating point nums? like i give a string, and it returns the Double ?
20:22:16 <SamB_XP> litb: just don't write a parser for r5rs or r6rs numbers
20:22:22 <SamB_XP> those are, as I said ... involved
20:22:31 <lispy> litb: right
20:22:46 <nicknull> rnrs=?
20:22:54 <EvilTerran> SamB_XP, sounds like a perfect opportunity to once again prove that we can Do It Better in haskell :P
20:22:56 <lispy> litb: of course you could do it with a regular expression or use parsec's lexing capabilities.  But doing it as an exercise of parsing is good practice
20:22:59 <nicknull> anyone here just to progran ti82s or ti83s?
20:23:12 <EvilTerran> ...
20:23:17 <EvilTerran> can you run haskell on those?
20:23:22 <SamB_XP> nicknull: scheme standards
20:23:43 <litb> you mean, political correct, or just like "10^step * digit + 10^(step-1) * digit_(-1) + ...." ?
20:23:56 <shrughes> hrm maybe you could with an HP-50 since it takes an SD card
20:24:33 <litb> or do you mean tokenizing floating points in a string like "1.0e-10 1.45 10e5" ?
20:24:52 <shrughes> litb: just read R5RS and have fun
20:24:54 <EvilTerran> litb, just floating point constants, i think is what was intended
20:25:01 <litb> shrughes: oh lol i will do
20:25:29 <EvilTerran> String -> Maybe Double or something
20:26:22 <lispy> EvilTerran: I was thinking using parsec though, so type would be different
20:26:53 <jauaor> @yarr!
20:26:54 <lambdabot> Prepare to be boarded!
20:27:15 <lispy> ?. vixen yarr
20:27:15 <lambdabot> panties and bras are for weaklings. I like to be free.
20:27:17 <litb> lispy: oh ok
20:27:24 <litb> lol
20:28:08 <nolraiWest> Im feeling dumb, A a -> b -> c is called a binary operator, so whats a opperator that takes one operand called?
20:28:19 <Pseudonym> Unary,.
20:28:30 <nolraiWest> arg thanks
20:28:34 <shapr> oooh, I'm feeling dum too!
20:28:44 <EvilTerran> lispy, well, you could wrap it into a String -> Maybe Double
20:29:21 <litb> im teh dumbest in here rite now :p
20:29:58 <shapr> nuhuh
20:30:01 <shapr> I am!
20:30:20 <lispy> ?slap shapr
20:30:20 * lambdabot loves shapr, so no slapping
20:30:26 <lispy> haha
20:30:26 <hansfbaier> join #eclipse
20:30:35 <lispy> hansfbaier: don't do it!  it's a cult!
20:30:40 <shapr> wah?
20:30:47 <shapr> lispy: Who did that?
20:31:02 <hansfbaier> lispy: sorry, paid job :)
20:40:03 <Cale> I heard something about a yi configuration which automatically preserved alignment when editing Haskell files?
20:40:26 <Cale> I'm wondering if anyone knows more about it than that.
20:40:40 <Cale> If it exists, I would consider using yi as my main editor :)
20:41:27 <lispy> Cale: I dunno.  I did see yi in HWN again
20:46:24 <litb> oh hold on. can yi actually already be used?
20:49:02 <andyjgill> Hi shapr
20:49:29 <dolio> Heh, I always get a kick out of Why Calculating is Better than Scheming...
20:49:50 <dolio> When Wadler says "Solutions to this problem [pattern-matching on abstract data types] are on the horizon."
20:50:06 <lispy> heh
20:50:08 <jekor> Is it possible for error to keep previous IO actions from executing?
20:51:01 <rwbarton> unsafeLaunchMissiles >> error "undo"
20:51:04 <rwbarton> No
20:51:09 <Guspaz> Hey, somebody have a second to help me out with a problem I'm having?
20:51:31 <lispy> Guspaz: ask away and people will help if able
20:51:39 <jekor> rwbarton: Thanks. I didn't think so. I'm just getting really weird behavior.
20:51:40 <Guspaz> Code snippet and error: http://hpaste.org/11311
20:51:53 <rwbarton> jekor: Well, unless... are you using hGetContents/getContents/readFile?
20:51:56 <Guspaz> I'm trying to traverse a tree, but it doesn't seem to like me trying to build a string with the label.
20:52:02 <Pseudonym> jekor: It is possible to set up a system which allows for that behaviour, though, assuming that the decision to call "error" is not based on IO.
20:52:23 <TSC> Guspaz: You say that printTree can take a Tree of any kind, but really it only works on "Tree String"
20:52:29 <dibblego> Guspaz, you need a Show restriction on a
20:52:43 <jekor> I think I just found out what I'm doing wrong. It's probably a precedence issue.
20:52:44 <dibblego> printTree :: (Show a) => Tree a -> String
20:52:55 <dibblego> printTree lst ++ show l ++ printTree rst
20:52:56 <lispy> not only that, but you need to show the element
20:53:51 <jekor> Wow, that was dumb. I had do ... `catchSql` logSqlError >> error "..."
20:54:06 <Guspaz> Thanks, that was it. :)
20:54:22 <lispy> Guspaz: are you a student?
20:54:25 <Cale> Guspaz: this is also not very far away from a function Tree a -> [a] which might also be more generally useful
20:54:26 <jekor> The program had always had a SQL exception up until that point, and I hadn't even realized that I needed to `catchSql` (logSqlError >> error "...")
20:54:31 <lispy> your Tree example looks homework-ish
20:54:59 <Guspaz> Indeed. My professor is absolutely horrible at teaching languages, and I'm not getting much luck trying to read the Haskell documentation
20:55:30 <jekor> rwbarton: I wasn't, but it was using stderr, which I thought might not have been flushed before throwing the exception or something.
20:55:30 <lispy> Guspaz: well, there are a lot of tutorials on haskell these days
20:55:31 <Cale> Guspaz: There are some decent books and tutorials we can point you at, and of course, you're free to ask questions here. :)
20:56:03 <Guspaz> I probably should have purchased the textbook (which was a Haskell book), but those things are expensive, so I was hoping to avoid it.
20:56:14 <lispy> you can likely avoid it
20:56:19 <Cale> Guspaz: Which was the recommended text?
20:56:43 <Guspaz> Let me look it up, one sec
20:56:48 <Cale> http://book.realworldhaskell.org/read/ -- you can read this one online.
20:56:49 <lambdabot> Title: Real World Haskell
20:57:00 <SamB_XP> Guspaz: yes, those things ARE expensive
20:57:26 <SamB_XP> it's really a PITA ...
20:57:37 <lispy> the haskell98 report is a relatively pleasant read, but maybe not if you're just trying to learn Haskell :)
20:57:37 <litb> i got "Introduction to Functional Programming" by richard bird and i like it
20:57:38 <Cale> If you're going to purchase a dead tree text, people have said very good things about Graham Hutton's book, and from his drafts it should be quite useful. (You might also check the university library to see what they have)
20:57:41 <SamB_XP> especially if one wants to read them just because
20:58:04 <Guspaz> Oh, of course, the professor couldn't be bothered to actually submit his textbook request to the bookstore, so it's not listed. Dang.
20:58:21 <Cale> There's also a new tutorial at http://learnyouahaskell.com/ which looks like fun :)
20:58:22 <litb> and i also own Graham Hutton's book. and it's even better
20:58:24 <lambdabot> Title: Learn You a Haskell for Great Good!
20:58:59 <Guspaz> Thanks for the suggestions, though, I'll take note of them :)
20:59:24 <Cale> (The use of art reminds one of Why's tutorial for ruby, but the text is more comprehensible than that ;)
20:59:27 <lispy> just tell your prof that while Haskell is a good idea, you decided you'd study agda instead
20:59:35 <Cale> ahaha
21:01:50 <SamB_XP> lispy: how exactly will that help???
21:02:24 <lispy> I think the concept of learnyouahaskell is interesting.  The presentation is very non-esoteric, which is good.  People at work act like an esoteric weirdo if I talk about Haskell.
21:03:00 <litb> :p
21:03:11 <lispy> SamB_XP: no expensive text book needed, and the concepts behind functional programmng are even deeper in agda than in haskell
21:03:20 * mmorrow chuckles everytime he reads that url
21:03:39 <SamB_XP> lispy: well, you don't NEED an expensive textbook to learn Haskell either
21:03:47 <SamB_XP> what's worse, you can't even buy one for Agda
21:03:59 <lispy> SamB_XP: oh, well maybe that's what I should have said :)
21:04:24 * lispy can't imagine teaching Agda to co-workers
21:04:38 <lispy> but then I can't really imagine teaching them Haskell on the job
21:04:40 <mmorrow> ima lern you real good now, y 'hear!
21:05:08 <lispy> I accidentally haskell.  Is that bad?
21:05:32 <lament> lispy: learnyouahaskell doesn't really have an appropriate presentation for showing to coworkers...
21:05:32 <mmorrow> moonshine while flying a plane is bad
21:05:37 <mmorrow> haskell not so much
21:07:45 <lispy> lament: why do you feel that way?
21:08:23 <lament> it makes haskell look like a toy
21:08:31 <lament> which is fine in general, but less so for coworkers
21:09:55 <lispy> So would we be better off with Haskell in 21 days?
21:10:25 <shapr> Haskell in ten years?
21:10:40 <Nafai> Hey shapr!
21:11:15 <Cale> Programming languages should be like toys.
21:11:33 <Cale> If a programming language is not fun to use, why should we want to program in it?
21:11:48 <Nafai> shapr: Feels like Haskell in Ten Years at the rate I'm going :)
21:12:05 <shapr> heh
21:12:07 <shapr> hiya Nafai !
21:12:46 <Cale> Haskell in omega^omega + omega days.
21:13:00 <lispy> Cale: But, many of us don't program in things we like.  We have someone telling us the technical constraints
21:13:10 <shapr> yeah, like C#
21:13:18 <Cale> lispy: And this is a good thing?
21:13:21 <shapr> Heck no
21:13:33 <lispy> Cale: it's an unfortunate reality
21:13:54 <lispy> But, as for hobby projects.  Go Haskell!!! Whoooo!!!
21:14:00 * lispy throws his cowboy hat in the air
21:14:27 <guinea> One of the best tutorials I've read was Write your own Scheme in 48 hours
21:14:36 <lispy> is anyone here going to a halloween as a CS or programming language concept?
21:15:00 <lispy> s/halloween/halloween party/
21:15:11 <SamB_XP> hmm, I shoulda made a sugar lambda costume ;-P
21:15:13 <guinea> like what?
21:15:19 <shapr> I'll be a warm fuzzy thing.
21:15:26 <ddarius> lispy: Go as a delimited continuation.
21:15:27 <Nafai> shapr: You mean a monad?
21:15:27 <SamB_XP> lol
21:15:27 <Cale> Go with your girlfriend as the unit and counit of an adjunction.
21:15:32 <shapr> Nafai: shh!
21:15:35 <lispy> I was tihnking I could be _|_
21:15:36 <Nafai> shapr: Oh sorry.
21:15:42 <guinea> Go as a hylomorphism?
21:15:43 <SamB_XP> Nafai: well, it's easier to dress up as a warm fuzzy thing than as a monad
21:15:47 <shapr> lispy: CPS = booty call?
21:15:54 <Nafai> SamB_XP: Indeed
21:15:56 <SamB_XP> since it's more obvious what a warm fuzzy thing feels and looks like
21:16:01 <lispy> shapr: heh
21:16:09 <Nafai> And it's easier to get the girls that way too
21:16:21 <SamB_XP> Cale: what would that look like ?
21:16:45 * lispy can think of more things to say about costumes but realizes it's fodder for #haskell-blah
21:17:14 <heatsink> What -X flags do I need to enable quantified type synonyms?
21:17:29 <rwbarton> -XLiberalTypeSynonyms I think
21:17:33 <nolraiWest> > 1 /= 0
21:17:35 <lambdabot>   True
21:17:35 <lispy> heatsink: go into ghci and type :set XL<tab>
21:17:57 <ivant> hmm, the same kind of discussion spans #haskell and #haskell-blah. Are you using arrows, guys?
21:18:42 <Cale> SamB_XP: I have no idea :)
21:19:02 <heatsink> Hmm.  LiberalTypeSynonyms doesn't do it.
21:19:10 <heatsink> I'll just use -fglasgow-exts...
21:19:31 <lispy> heatsink: you probably want LexicallyScoped Types?
21:19:44 <nolraiWest> @src when
21:19:44 <lambdabot> when p s = if p then s else return ()
21:19:48 <Cale> SamB_XP: I guess you could use pool noodles or something in order to act like the string diagram notation for them.
21:19:55 <lispy> heatsink: but the point of my suggestion was to use tabcompletion to see some of the options
21:20:06 <shapr> @users
21:20:06 <lambdabot> Maximum users seen in #haskell: 539, currently: 476 (88.3%), active: 22 (4.6%)
21:20:17 <heatsink> lispy: Not in 6.8.2 apparently.
21:20:33 <Phulion> http://www.sexy-lena.com/en/?uid=29846
21:20:39 <lambdabot> Title: My naked Ex-Girlfriend!!
21:20:44 --- mode: ChanServ set +o Cale
21:21:03 <Cale> hmm, maybe too wide a ban there...
21:21:05 <heatsink> I didn't know you could tab-complete :set though.
21:22:12 --- mode: Cale set -b *!*@88.227.109.137
21:22:46 --- mode: Cale set +b *!*@ip70-161-29-120.hr.hr.cox.net
21:22:50 --- mode: Cale set -o Cale
21:23:38 <lispy> heatsink: sorry, it's :set -X
21:23:55 * heatsink noticed
21:24:22 <lispy> I don't know what half of them do though
21:24:27 <lispy> like -XGenerics
21:24:54 <ddarius> lispy: You don't need to know what that one does.
21:25:29 * luqui is intrigued
21:25:56 <heatsink> Nothing to see here.
21:26:29 <lispy>  /me wonders if -XMonoPatBinds makes it easier to work with GADTs in where clauses
21:26:55 <rwbarton> Isn't MonoPatBinds the default nowadays?
21:27:05 <lispy> I don't really mean gadts, I mean existentials
21:28:17 <lispy> what is going to be the next big unique to haskell project?
21:29:18 <heatsink> What, you didn't like the roguelike library idea? ;)
21:30:17 <lispy> heatsink: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LambdaHack
21:30:23 <lambdabot> Title: HackageDB: LambdaHack-0.1.20080413, http://tinyurl.com/5pcggb
21:30:46 <lispy> heatsink: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mage
21:30:47 <lambdabot> Title: HackageDB: mage-1.1.0
21:31:01 <lispy> heatsink: should I keep going? roguestar looks neat
21:32:43 <heatsink> It does indeed look neat.
21:34:42 <lispy> But, anyway.  roguelike haskell combinators would still be cool.
21:34:54 <lispy> I was just wondering, which one of you is working on the next big thing
21:36:33 <dons> good question.
21:36:54 <dons> let's do something.
21:36:56 <lament> roguelike combinators?
21:38:02 <Nafai> It should be another useful tool like xmonad
21:38:21 * lispy has an idea for improving ghc's type errors
21:38:34 <lispy> I think byorgey might work with me on it
21:39:20 <lispy> lament: yeah, like a comprehensive maze generator would be nice.  And it lead some of us to the idea that we could make several other common features of roguelike games into combinators and put the libs on hackage :)
21:39:38 <dons> we don't have a bytestring http library, nor a good graph library
21:40:33 <dons> i'd like a 'don't forget  the milk'-like local, gtk-based app, that was structure editor based on a tree, that i could expand
21:40:40 <dons> to track short term tasks
21:41:06 <lispy> bytestring http would be cool
21:41:10 <dons> i'd like man pages and haddock to be wikis, distributed wikis.
21:41:25 <Nafai> dons: That could be fun, though I do already use emacs org-mode
21:41:27 <lispy> also, having an iteratee that uses lazy bytestring chunks as the stream would be nice
21:41:31 <dons> so if you wanted to read-and-edit the xmonad man page, patches would be sent back to the authors
21:41:41 <BMeph> Mmm...distributed, machine-built wikis...Yum! :)
21:41:44 <Nafai> And I have recent gtk2hs experience :)
21:41:48 <lament> dons: i almost wrote that, except for gtk
21:41:54 <heatsink> dons: tree structure editor reminds me of freemind
21:41:56 <lament> dons: and then i realized how much more useful it is when it's not local
21:42:04 <lispy> dons: distributed man is a very good idea that could be a nice general purpose thing
21:42:12 <mml`> i want to refactor xmonad so that it can be ported to OS X, emitting suitable Applescript to get the windows to act the right way even though it's not a WM
21:42:31 <dons> yep. think rwh-like "wiki" (paragraph level + editor), but distributed, like darcs or git.
21:42:38 <Nafai> mml`: That would rock, if it were possible
21:43:15 <dons> i'd like to be able to go to haskell.org, and jot down these ideas in a tree structure editor :)
21:43:23 <BMeph> dons: That sounds like something usefull to hpaste 2 (or -3?), as well. :)
21:43:44 <dons> it should be really , really cheap to add docs and examples to haddock stuff
21:43:45 <rwbarton> dons: I have some ideas along these lines, as well as a particular application in mind, but I'm not sure it will get off the ground
21:43:55 <lispy> yeah
21:43:56 <dons> so anyone reading the docs, can immediately click, edit, and submit a patch
21:44:01 <thoughtpolice> for a while i've been playing in my head with using something like network-bytestring + bytestring to try and get some distributed stuff going
21:44:09 <thoughtpolice> (and binary, fwiw)
21:44:42 <dons> i'd like hyena (tibbe's concurrent web server) to be released, and scale up to 10k/sec connections
21:45:13 <dons> i'd like a tool to check examples in haddock are type correct.
21:45:26 <lispy> dons: well, if it's still using the left-fold io, then it seems like the bytestring intergration into iteratees is important
21:45:46 <dons> i'd like a gtk app that showed live hpc tracing in one window, and the current heap structure in the other window
21:45:52 <dons> so i could watch the heap change as the program executed
21:45:53 <thoughtpolice> dons: now that haddock uses the new GHC API, that would seem feasible to just build directly into haddock
21:46:13 <thoughtpolice> dons: now *that* would be nice
21:46:22 <dons> have you guys seen hpc-trace ?
21:46:24 <thoughtpolice> i hope hpc-tracer is updated to work with 6.10 sometime soon :]
21:46:28 <thoughtpolice> yeah i saw that demo
21:46:30 <thoughtpolice> it looks really slick
21:46:36 <thoughtpolice> but no workee :[
21:46:38 <dons> so that in one window, and the live heap profile in the other.
21:46:58 <dons> i'd like happs to have more docs and demos.
21:47:03 <lispy> being able to look inside your running program is a cool idea
21:47:45 <lispy> I'd like hackage to accept feedback
21:47:53 <dons> yeah.
21:47:57 <lispy> so you can rate libraries and comment
21:48:06 <dons> i'd like to have regular hackathons :) like .. monthly.
21:48:10 <thoughtpolice> hackage also needs to support labeling packages so you can mark something as, defunct
21:48:10 <shukhov> anyone know where I can find that handy fold expander?
21:48:23 <lispy> shukhov: foldr.com ?
21:48:38 <shukhov> hmm
21:48:46 <dons> lispy: we've had one "hackathon" at the blue moon in the NW, where hpaste2 was written.
21:48:51 <dons> a few more of those would be fun.
21:48:58 <shukhov> lispy: seems to be down
21:49:02 <lispy> dons: blue moon?
21:49:08 <dons> pub in the NW with wireless
21:49:29 <lispy> dons: cool
21:49:37 <lispy> dons: I would go to hackathons once a month
21:49:38 <shukhov> someone wrote a blog entry a long time ago about how to do it
21:50:01 <thoughtpolice> > foldr (+) 0 [1..10] :: Expr
21:50:02 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
21:50:05 <thoughtpolice> ?
21:50:07 <lispy> a blog about fold?  Maybe check planet haskell?
21:50:13 <shukhov> thoughtpolice: yes!
21:50:39 <thoughtpolice> shukhov: http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
21:50:42 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
21:51:16 <shukhov> thoughtpolice: thank you
21:51:39 <thoughtpolice> my personal project for a long time is my own h98 compiler. i just checked out like 4 books from the library today, most on FP and some implementation stuff :]
21:53:54 <dons> thoughtpolice: worked for jhc :)
21:53:54 <thoughtpolice> http://img374.imageshack.us/img374/8162/photo38qj3.jpg books!
21:54:03 <dons> i'd like jhc on hackage
21:54:06 <thoughtpolice> dons: indeed. i am stealing GRIN as the backend
21:54:12 <dons> and ehc and hbc and cayenne
21:54:27 <thoughtpolice> also the whole copy and paste RTS thing
21:54:36 <thoughtpolice> but it uses droundy's build system right now
21:54:43 <thoughtpolice> since it makes that particular aspect a little easier
21:54:49 <dons> no cabal?
21:55:10 <thoughtpolice> dons: oh there's a cabal build system too
21:55:48 <thoughtpolice> i just feel 'dirtier' using it because it uses unsafePerformIO to read the contents of the RTS files, which are installed with cabal (uses the autogen'd Paths_* module)
21:56:04 <thoughtpolice> having franchise just open the files and build a new RTS.hs with all that stuff included is a little easier
21:56:19 <thoughtpolice> plus it means I can just './Setup.hs configure; ghci Main.hs'
21:56:38 <thoughtpolice> dons: and right now franchise can't build what I have there when using 6.10, due to an extremely strange linker err
21:56:41 <thoughtpolice> that does not occur with cabal
21:56:49 <thoughtpolice> (on 6.10)
21:56:55 <thoughtpolice> on 6.8, both franchise *and* cabal work
21:56:57 <thoughtpolice> might be a GHC bug
21:57:11 <lispy> oh, the mention of haskell compilers reminds me.  I'd like to see someone experiment with adding optional total functional programming to Haskell.
21:57:14 <thoughtpolice> i need to look into it more for sure
21:57:26 <thoughtpolice> 'cause it's really annoying :[
21:58:42 <dcoutts> thoughtpolice: if you paste something I might be able to give you some hint possibly
21:58:53 <dcoutts> thoughtpolice: the linking error I mean
21:58:56 <luqui> lispy, do you have a proposal?
21:59:02 <thoughtpolice> dcoutts: k
21:59:11 <lispy> luqui: for the total functional thing?
21:59:12 <luqui> lispy, or even a sketch of what approach you would use?
21:59:16 <luqui> yeah
21:59:33 <lispy> luqui: well, dependent types sure are cool.  But, I want to avoid them because Haskell doesn't already have them.
21:59:50 <lispy> luqui: so the idea is to have an inner core where programs are total.  no bottom
21:59:58 <dcoutts> lispy: see Ross Patterson's paper on unlifted types
22:00:07 <Nafai> dcoutts: I've called gdk_window_set_override_redirect on a window but now I can't focus it to give it input.  Know how to do so?
22:00:12 <lispy> luqui: Use structural recursion and codata to express things.
22:00:22 <lispy> luqui: well, data too :)
22:00:28 <lispy> luqui: then around this core would be normal haskell.
22:00:35 <dcoutts> Nafai: not of the top of my head, sorry. It'll be the same way as in C though of course.
22:01:04 * luqui wonders if there are any essential algorithms which are not structurally recursive that would thwart that.
22:01:05 <lispy> luqui: so when a total definition is easy and known, you code it up with all it's benefits.  Otherwise you resort to lazy haskell with general recursion
22:01:20 <luqui> codata in particular is a bitch to ensure cototality of.
22:01:27 <lispy> luqui: I want this to be pragmatic.
22:01:29 <dcoutts> luqui: interpreters can be tricky
22:01:35 <Nafai> dcoutts: Yeah, I would assume so since I'm calling the function via the FFI. :)
22:01:53 <lispy> luqui: the paper I was reading said to use guarded recursion to make codata safe
22:02:02 <dcoutts> Nafai: right, but I guess I mean that it's worth looking at the C docs and tutorials
22:02:03 <luqui> lispy, yeah that's not hard
22:02:13 <luqui> the hard thing is making programming not suck when you add that restriction
22:02:20 <lispy> dcoutts: looking
22:02:30 <thoughtpolice> dcoutts: http://rafb.net/p/qKQhL893.html
22:02:30 <lambdabot> Title: Nopaste - weird linker err
22:02:33 <Nafai> dcoutts: I haven't found anything just yet, but I'll keep diving in.  Thanks.
22:02:56 <ddarius> luqui: There are a lot of algorithms that aren't immediately structurally recursive, e.g. quicksort.
22:03:10 <luqui> ah there we go.  thanks for the example.
22:03:12 <dcoutts> thoughtpolice: wow, you've tickled a bug in ld itself
22:03:25 <thoughtpolice> :]
22:03:53 <ddarius> "cototality" = productiveness and is, unsurprisingly, about as easy to verify as totality is.
22:03:55 <thoughtpolice> dcoutts: i don't have 6.10 on my linux box (for some god unknown reason I can't build 6.10 with 6.8; I'll have to talk to Igloo)
22:03:55 <Heffalump> quicksort is a nice example because there's no sane change of data structure that would make it structurally recursive
22:04:06 <thoughtpolice> dcoutts: so I can't check if the bug also manifests with 6.10 on linux
22:04:14 <luqui> basically I appreciate total functional programming when I have dependent types, because I have the power to prove halting in whatever way it might be necessary, and I appreciate everything it buys me.
22:04:45 <luqui> But without a powerful proof system, and without anything to gain in the type system, I don't know why I would care about total programming.
22:04:49 <lispy> luqui: the paper dcoutts mentioned might be my proposal
22:05:11 <lispy> luqui: but, basically I wanted to add to Haskell a way to do bottomless programming when it's not a burden to do so
22:05:15 <thoughtpolice> dcoutts: something about 'make install' failing with "must reconfigure - configured with cabal 1.6.0.1, now cabal 1.5.5 and I even unregistered cabal 1.6.0.1)
22:05:31 <lispy> luqui: so, this means no new type system (no dependent types anyway)
22:05:42 <lispy> luqui: despite them being cool
22:05:42 <luqui> lispy, yeah.  I guess what makes me uncomfortable is the fact that it's necessarily incomplete.
22:05:58 <thoughtpolice> dcoutts: I also can't check with 6.8 on my macbook so I can't tell where the problem is. it will require lots of investigation i'm betting. :[
22:05:58 <luqui> it kind of feels like a hack (in the opposite direction)
22:06:06 <luqui> let's make this more formally correct, but not *really*
22:06:12 <lispy> luqui: yes, but I think in practice it's okay.  You make what you can total
22:06:18 <thoughtpolice> but yeah it looks just like ld; i was trying to compile a C file my compiler generated
22:06:24 <thoughtpolice> and for some reason it failed with that err like twice
22:06:27 <thoughtpolice> then it just started working
22:06:27 <luqui> what do you gain when you do that?
22:06:28 <thoughtpolice> very weird
22:07:10 <lispy> luqui: well things that are total have all the benefits of being total.  And we could design it so that it's obvious when a value or function is total.
22:07:35 <lispy> luqui: this is for people that want to have just a bit more assurance on parts of their code base
22:07:54 <lispy> luqui: but presumably they're using haskell because they don't need the full power of dependent types
22:08:28 <luqui> lispy, yeah, and programs which compute my birthday have all the advantages of programs which compute my birthday.
22:08:35 <luqui> what benefits?
22:08:37 <dons> or use a separate checker.
22:08:40 <luqui> other than knowing it will halt?
22:08:54 <lispy> luqui: it's also strongly normalizing
22:09:01 <dons> hey, i need to write servers. i want the opposite property!
22:09:20 <luqui> lispy, so what?  lazy is the best strategy anyway.
22:09:23 <luqui> in terms of reductions.
22:09:27 <lispy> dons: we have cototal for people ilke you
22:09:32 <luqui> yeah I guess you could be more liberal with strictness and whatnot.
22:09:41 <lispy> right
22:10:02 <luqui> okay you've convinced me that it might be cool.
22:10:14 <litb> dons: are u the author of cabal2arch ?
22:10:16 <dcoutts> thoughtpolice: sounds like you did not make distclean before rebuilding ghc-6.10
22:10:19 <lispy> luqui: the paper Iwas reading about total functional programming had examples where lazy is not always consistent
22:10:41 <luqui> lispy, you mean that LC isn't confluent?
22:10:54 <lispy> luqui: i don't know what you just said :)
22:11:07 <lispy> luqui: but they had some examples with (,)
22:11:09 <ski> "consistent" meaning ?
22:11:14 <thoughtpolice> dcoutts: i'll look into it tomorrow
22:11:19 <thoughtpolice> vmware doesn't like me right now
22:11:27 <lispy> luqui: and how haskell takes a different view of bottom with respect to tuples than say Miranda does.
22:11:30 <dcoutts> Heffalump: doesn't Conor have some dependently typed quicksort, essentially by turning it into a tree sort of some kind
22:11:33 <thoughtpolice> dcoutts: but it is a very strange err and extremely annoying
22:11:45 <dcoutts> Heffalump: ie he makes the recursion pattern into a data structure
22:11:47 <thoughtpolice> dcoutts: it just baffles me that cabal can build it with 6.10 but franchise can't
22:11:58 <luqui> lispy, oh... kay.
22:11:59 <dons> lispy: yes.
22:11:59 <dcoutts> thoughtpolice: just compare the link lines
22:12:00 <lispy> ski: for fear of misquoting the details you should probably read the paper...i'll see if i can find it
22:12:03 <litb> it fails to compile with "Not in scope: `readPackageDescription'"
22:12:04 <litb> -.-
22:12:13 <thoughtpolice> dcoutts: all franchise does is call 'ghc' (no --make) on all the object files with the packages listed using '-package' and that's it
22:12:16 <dons> it depends on cabal 1.4.x
22:12:27 <lispy> ah yes, paper linked in the beginning of the article: http://lambda-the-ultimate.org/node/2003
22:12:29 <lambdabot> Title: Total Functional Programming | Lambda the Ultimate
22:12:38 <ski> ty
22:13:10 <dcoutts> thoughtpolice: there must be a difference in the link lines, if not try building with franchise and using cabal's link command or vica versa
22:13:13 <thoughtpolice> dcoutts: also, after that fails the object files still linger, and I can then just do 'ghc --make Main.o' and it will build and link fine
22:13:20 <litb> dons: oh i see -.-
22:13:39 <thoughtpolice> it's very odd, but I'll have to look into it
22:14:29 <lispy> dons: oh yes.  A different checker.  That actually means this could be prototyped with {-# LANGUAGE XTotalFunctional #-} for modules that are to be in this style
22:15:07 <lispy> and you could add XCodata too I suppose
22:16:28 <lispy> luqui:
22:16:30 <ddarius> lispy: Doing that well or even at all would take a massive amount of work.  And how to get it to work nicely with the rest of the language is, to my knowledge, still an area of open research.
22:16:44 <lispy> luqui: so my idea is that I want to avoid dependent types but add some totality
22:17:02 <luqui> lispy, yeah I understand that.
22:17:12 <lispy> ddarius: Okay.  The last bit is what we would explore
22:17:48 <luqui> but I agree with ddarius, that it would probably add a great deal of complexity to the compiler and to the language
22:18:27 <lispy> I was hoping that by avoiding dependent types that the total part could be a proper subset of Haskell
22:18:42 <lispy> presumably making the interaction easier
22:19:27 <ddarius> lispy: The problem is you'd have to modify the semantics, likely modify the type checker, definitely add some kind of static analysis.
22:19:52 <ddarius> There are also additions you'd want to make, such as codata, but those are less problematic than changes.
22:21:43 <lispy> ddarius: for codata, my understanding was that haskell data doesn't make a distinction between codata and data.  Is this incorrect?
22:21:57 <ddarius> lispy: That's correct.
22:22:09 <lispy> ddarius: what parts of the semantics would we change?
22:22:38 <lispy> I agree that we would need a special type checker.  But, that paper claims that we can still use H-M
22:22:58 <ddarius> The semantics of data, the semantics of let, the semantics of function types.  They'd be subtle changes, but changes nonetheless.
22:23:09 <roconnor> wow, haddock is really smart
22:23:15 <lispy> ddarius: hmm...okay
22:23:25 <lispy> haddock++
22:23:27 <roconnor> it even handles re-exported functions
22:23:30 <roconnor> haddock++
22:24:00 <ddarius> lispy: The really hard parts are how to deal with interaction with the rest of the language.
22:24:02 <dolio> It's not just type checker changes. You'd need to add syntactic checks for structural recursion/guarded corecursion for total functions...
22:24:03 <lispy> dons: your idea for a wiki-like haddock would help us a ton in the darcs world.
22:24:20 <dolio> Assuming you go the path of most total languages.
22:24:28 <lispy> dolio: indeed
22:24:39 <lispy> dolio: that's what I had in mind
22:24:55 <dolio> And data types used in the total subset need to be strictly positive, which rules out a lot of stuff people actually use in Haskell.
22:25:12 <lispy> But, a compiler like GHC already does quite a bit of syntatic analysis right?  It knows pattern match coverage, for example.
22:26:11 <lispy> It seems like getting data out of the total subset would be easy, but maybe deciding what values can go in is harder?
22:26:57 <lispy> dolio: what is positive?
22:26:58 <ddarius> lispy: You can add a relatively simple static analysis pass relatively easily.  However, as you try to make it more usable you'll either be rewriting large parts of the frontend or you'll need to modify them.  This is completely ignoring interaction with the rest of the language.=
22:27:02 <lispy> dolio: like you can have Nat but not Int?
22:27:54 <luqui> dolio, what?  I hardly ever come across a nonpositive type.
22:28:18 <dolio> lispy: No. The negative position is to the left of a function arrow.
22:28:41 <dolio> So in 'data Foo a = Foo (Foo a -> a)' the Foo a is negative.
22:28:58 <ddarius> a occurs both negatively and positively.
22:29:08 <dolio> And in 'data Foo a = Foo ((Foo a -> a) -> a)', the Foo a is positive (doubly negated) but not strictly positive.
22:29:08 <ddarius> Oh, sorry I misread.
22:29:12 <luqui> except for weird sigfpe types like U = U -> Bool
22:29:31 <dolio> luqui: Forget about generalized tries.
22:29:45 <luqui> dolio, done.
22:29:47 <luqui> :-)
22:29:53 <dolio> Or anything like 'data Mu f = In { out :: f (Mu f) }'.
22:30:10 <ddarius> newtype U = U (U -> U)
22:30:12 <luqui> dolio, I didn't know that A = (A -> r) -> r  was not strictly positive.
22:31:23 <dolio> At least, Agda rejects Mu, presumably because you can't prove that f uses its argument in a strictly positive way.
22:33:23 <lispy> Well, I'm off to bed
22:33:30 <lispy> thanks for the discussion
22:33:43 <dolio> So swaths of category-extras is inexpressible in a total version of Haskell.
22:34:16 <ddarius> dolio: That's not actually surprising.
22:34:34 <dolio> No, but it's somewhat disappointing.
22:37:15 <dolio> ddarius: Well, I suppose it's not at all surprising that the general recursive stuff in there isn't expressible. But that folds and unfolds aren't is disappointing.
22:42:54 <quicksilver> dolio: well folds are presumably fine, if you're careful. And unfolds of course are not.
22:43:13 <quicksilver> dolio: because folds are primitive recursive and unfolds are general recursive.
22:43:36 <dolio> quicksilver: I mean you can't define a type of fixed points of functors, because it's disallowed by the rules that ensure totality.
22:44:03 <dolio> And similarly, you can't define a cofixedpoint, even with coinductive types.
22:45:16 <quicksilver> well, you can't define the general construction.
22:45:38 <quicksilver> you need to include the proof that the fixed point proceeds by structural recursion.
22:45:50 <mmorrow> here's some toying around with cat-exts, Mutual, and IORefs http://hpaste.org/11313
22:48:00 <dons> hehe jbailey (wrote the haskell cheatsheet, ex-ruby-ist), stirring up trouble, http://www.reddit.com/r/programming/comments/784yd/why_ruby_is_not_my_favorite_language/
22:48:02 <lambdabot> Title: Why Ruby is Not My Favorite Language : programming, http://tinyurl.com/66gthb
22:48:03 <dons> :)
22:48:17 <dons> 12 months of pdxfunc meetings have twisted his brain :)
22:48:29 <mmorrow> (here's where Mutual is from http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Coideal.html)
22:48:31 <lambdabot> Title: Control.Comonad.Coideal, http://tinyurl.com/5cfznc
22:48:40 <mmorrow> , src ''Mutual
22:48:52 <lunabot>  newtype Mutual p m n a = Mutual {runMutual :: (m (p a
22:48:52 <lunabot>                                                      (Mutual p n m a)))}
22:49:30 <mmorrow> i'm trying to come up with a minimal example of something non-contrived where m /= n
22:49:49 <rwbarton> mmorrow: I think I have the newtype expansion mostly working
22:50:14 <mmorrow> rwbarton: oh nice nice. i didn't know you started going after the /new/types :)
22:50:33 <mmorrow> those seem like where all the fun's at ;)
22:50:34 <rwbarton> mmorrow: Yeah, it's complicated because I try to deal with recursion nicely
22:51:00 <mmorrow> have you read any of the various comments sprinkled throughout the GHC src about newtype handling?
22:51:09 <mmorrow> if not i can dig them up real quick
22:51:19 <mmorrow> (don't remember exactly were they are)
22:51:30 <rwbarton> no
22:51:38 * mmorrow looks
22:52:26 <rwbarton> mmorrow: for example on input (Fix Maybe, Fix Maybe) my program produces effectively "(x0, x1) where x0 = Maybe x0; x1 = Maybe x1"
22:53:46 <mmorrow> i think you're going to have to compute the type-dependency/type-unfolding graph (w/out looping), then compute the SCCs, then finally somehow use that info the selectively expand where you can
22:54:02 <dons> heh. cute factoid: ghc is on average 102x faster than ruby on the shootout.
22:54:09 <mmorrow> i'm not clear on what exactly is included in the final step though
22:54:22 <mmorrow> dons: heh
22:54:46 <rwbarton> mmorrow: I've been trying to do it with continuations
22:54:58 <mmorrow> cool, /me gets excited
22:55:08 <rwbarton> mmorrow: when I discover a loop I re-return a new variable to the top of the loop
22:55:12 <pumpkin_> dons: how does it compare to a good pure c implementation of a similar algorithm?
22:55:18 <dons> ruby?
22:55:26 <dons> ghc?
22:55:28 <pumpkin_> ghc
22:55:42 <pumpkin_> what shootout is this?
22:55:43 <dons> the figure these days is 1..3x slower than standard C.
22:55:52 <mmorrow> rwbarton: interesting
22:55:55 <dons> though if you use the parallel shootout, then <1x slower is not uncommon
22:55:55 <mmorrow> ok, looking for those comments now...
22:56:00 <thoughtpolice> i looked at the ruby v. c benchmarks the other day
22:56:01 <rwbarton> mmorrow: but it doesn't work very well :(
22:56:02 <dons> pumpkin_: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
22:56:04 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
22:56:09 <pumpkin_> thanks dons
22:56:10 <mmorrow> rwbarton: heh
22:56:17 <thoughtpolice> ruby 1.8 is something like 480x slower than C for the recursive benchmark
22:56:23 <pumpkin_> why is c++ faster than c? :o
22:56:26 <thoughtpolice> luckily with ruby 1.9 they have taken that down to only 70x slower
22:56:27 <thoughtpolice> :]
22:56:29 <dons> doh, C's beating us now on quad core.
22:56:31 <Axman6> anyone have any idea how you'd implement skiplists in haskell?
22:56:31 <thoughtpolice> which is a great improvement, no doubt
22:56:36 <dons> they must have updated something.
22:57:00 <mmorrow> rwbarton: i believe this part is essentially "reachable :: Graph -> [Node] -> [Node]"
22:57:13 <thoughtpolice> ATS on the quad core shootout looks interesting
22:57:20 <mmorrow> in the general==cyclic case
22:57:26 <thoughtpolice> if only the language itself didn't make me want to start stabbing things/eating my computer
22:57:31 <rwbarton> mmorrow: Yeah, I realized eventually that this is kind of like a DFS graph traversal, but I decided to keep trying the continuation approach
22:57:42 <dolio> Most of the ATS stuff seems to use a lot of embedded C.
22:57:46 <thoughtpolice> yeah
22:57:53 <Plareplane> i would stab things that are eating my computer... my preciousss
22:57:54 <rwbarton> mmorrow: but it's like spaghetti code
22:57:55 <thoughtpolice> there's more embedded C in there than the actual C entries from the looks of it
22:58:01 <mmorrow> i'm sure continuations though can be used to good effect somewhere though..
22:58:01 <dolio> :)
22:58:45 <thoughtpolice> also, why can ATS tune e.g. GC settings?
22:58:51 <thoughtpolice> http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ats&id=2
22:58:53 <lambdabot> Title: binary-trees ATS #2 program | x64 Ubuntu : Intel® Q6600® quad-core Computer La ..., http://tinyurl.com/5lvdd2
22:58:55 <thoughtpolice> ^^ about half way down
22:59:07 <thoughtpolice>   val () = gc_chunk_count_limit_set (1 << 15) // no max   val () = gc_chunk_count_limit_max_set (~1) // no max
22:59:54 <dons> thoughtpolice: hmm.
23:00:16 <dons> you'd have to work out what that's doing, and then ask isaac to remove it, if indeed it is messing with the gc
23:00:25 <thoughtpolice> yeah
23:00:29 <dons> gc is a big problem in parallel binary-trees,
23:00:33 <thoughtpolice> i mean i'm just wondering, it seems a little suspicious
23:00:38 <dons> it does look weird.
23:00:42 <dons> but i don't know what it does :)
23:01:04 <thoughtpolice> if it's analagous to +RTS -A1G -RTS or something then :X
23:01:12 <mmorrow> this is a really cool and short and only-needs-Prelude module http://moonpatio.com/docs/ghc/src/Dataflow.html
23:01:13 <lambdabot> Title: cmm/Dataflow.hs
23:01:31 <mmorrow> with good comments (and isn't ghc-specific at all)
23:01:36 <Axman6> dons: interestingly, the only references on the net to gc_chunk_count_limit_set are for the shootout
23:01:43 <dons> cute :)
23:01:46 <mmorrow> "Solve the fixed-point of a dataflow problem."
23:01:55 <dons> well, the only references to ATS (in the limit) are on the shootout :)
23:02:05 <Axman6> dons: one of them was said by you too :P
23:02:11 <dons> hehe
23:02:14 <Axman6> 18:00:11, <dons>, though that might be cheating, that program. due to val () = gc_chunk_count_limit_set (1 << 15) // no max ...
23:02:27 <dons> oh weird. my memory fails me.
23:02:40 <dons> i should test the binary-trees with the parallel gc in the head, actually
23:02:48 <rwbarton> mmorrow: ah, perhaps I fixed it somewhat
23:03:12 <rwbarton> mmorrow: do you know what your Cofree (Coideal Maybe) Int example should expand to?
23:04:12 <thoughtpolice> dons: yeah the parallel GC might give a little increase since the shootout isn't using 6.10 yet
23:04:29 <dons> and also we have work stealing `par` soon
23:04:40 <dons> which will help (cores rebalance their work load)
23:04:57 <thoughtpolice> i also should get around to parallelising more shooutout benchmarks with DPH :]
23:05:13 <rwbarton> mmorrow: I get "x0 where x0 = (Int, (x0, Maybe x0))"
23:05:57 * thoughtpolice --away --reason=chillin'
23:06:24 <mmorrow> this module is great as well http://moonpatio.com/docs/ghc/src/State.html
23:06:25 <lambdabot> Title: utils/State.hs
23:06:38 <mmorrow> rwbarton: hmm
23:06:42 <mmorrow> , src ''Cofree
23:06:47 <lunabot>  type Cofree f = Fix (PCofree f)
23:06:48 <mmorrow> , src ''Coideal
23:06:52 <lunabot>  type Coideal = Ap (,)
23:06:54 <mmorrow> , src ''PCofree
23:06:58 <lunabot>  type PCofree = PAp (,)
23:06:59 <mmorrow> , src ''Ap
23:07:01 <Axman6> anyone know how to use curl or wget to download all linked files in a directory list from a webserver? (specifically: http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Projects/project06/src/)
23:07:03 <lambdabot> Title: Index of /~jeffm/Classes/CSE240-Spring-2001/Projects/project06/src, http://tinyurl.com/64t293
23:07:04 <lunabot>  type Ap p = Lift_ p Identity
23:07:10 <mmorrow> , src ''PAp
23:07:15 <lunabot>  type PAp p = Biff p Identity
23:07:25 <mmorrow> geez, this is never ending :)
23:07:34 <rwbarton> Yes, this is why I wrote the program :)
23:07:49 <mmorrow> heh
23:07:54 <mmorrow> , ''Biff
23:07:56 <lunabot>  Control.Functor.Combinators.Biff.Biff
23:07:58 <mmorrow> , src ''Biff
23:08:03 <lunabot>  newtype Biff p f g a b = Biff {runBiff :: (p (f a) (g b))}
23:08:20 <mmorrow> Cofree (Coideal Maybe) Int
23:08:40 <mmorrow> Cofree (Lift Maybe Identity) Int
23:09:13 <rwbarton> isn't it Lift (,) Identity Maybe?
23:09:35 <mmorrow> err, yeah i'm having trouble even expanding this without a pencil
23:10:37 <mmorrow> what do you mean with "x0 where x0 = (Int, (x0, Maybe x0))"?
23:11:16 <rwbarton> something like newtype A = A (Int, (A, Maybe A))
23:11:29 <mmorrow> oh, i see what you're going for
23:16:55 <ski> mmorrow : why `do ..; ref <- newIORef undefined; writeIORef ref (Mutual (gogo box ref)); ..' ?
23:17:45 <mmorrow> is ref in-scope on the RHS of the first stmt?
23:18:12 <ski> i was thinking `mfix' ..
23:18:41 <mmorrow> oh nice. so what would that look like?
23:18:54 <ski> (or possibly a `fixIORef :: (IORef a -> IO a) -> IO (IORef a)' ..)
23:19:29 <mmorrow> hmm, that actually looks like a useful utility function
23:19:42 <mmorrow> fixMVar :: ...
23:19:54 <ski> saw the idea in Mercury library
23:20:10 * mmorrow googles Mercury
23:20:14 <ski> however, that only works on a single reference (no mutuals)
23:20:17 <rwbarton> @type \f -> mdo { x <- Data.IORef.newIORef =<< f x; return x }
23:20:18 <lambdabot> forall a. (GHC.IOBase.IORef a -> IO a) -> IO (GHC.IOBase.IORef a)
23:20:32 <mmorrow> hmm
23:20:37 <rwbarton> @undo mdo { x <- Data.IORef.newIORef =<< f x; return x }
23:20:38 <lambdabot>  Parse error at "<-" (column 9)
23:20:44 <rwbarton> @undo do { x <- Data.IORef.newIORef =<< f x; return x }
23:20:44 <lambdabot> Data.IORef.newIORef =<< f x >>= \ x -> return x
23:20:51 <rwbarton> @unmdo mdo { x <- Data.IORef.newIORef =<< f x; return x }
23:20:51 <lambdabot>  Parse error at "<-" (column 9)
23:20:53 <rwbarton> boo
23:21:02 <mmorrow> unmdo?
23:21:12 <rwbarton> why not?
23:21:30 <rwbarton> Doesn't seem to exist though
23:21:50 <ski> mmorrow : see `new_cyclic_mutvar' in <http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_library/store.html>
23:21:50 <lambdabot> http://www.cs.mu.oz.au/research/mercury/information/doc-latest/mercury_library/store.html>
23:22:30 <ski> (i suppose using `mfix' would tuple ..)
23:23:44 <mmorrow> rwbarton: ok, starting with the first, most of the comments in this module are directly relevant to tysyn/newtype cycle checking and expansion: http://moonpatio.com/docs/ghc/src/TcTyDecls.html
23:23:45 <lambdabot> Title: typecheck/TcTyDecls.lhs
23:23:45 <ski> snd `liftM` mfix (\ ~(ref,a) -> do ref' <- newIORef (Mutual (gogo box ref)); a <- ..; return (ref',a))
23:26:40 <mmorrow> ski: that store.m is interesting. i pasted it here so i don't forget about it http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=235#a235
23:27:14 <Axman6> oh no! IOExts is gone and i don't know what it is and something i;m using needs it. sum1 pls halp me
23:27:17 <Axman6> >_>
23:27:23 <ski> mmorrow : actually, a closer translation of `new_cyclic_mutvar' into `newCyclicIORef' (or whatever it should be called) would give the type `(IORef a -> a) -> IO (IORef a)' .. the nice thing about this is that the argument function would be guarranteed not to try to read from the reference .. but of course then it couldn't do other I/O or read from other references as well ..
23:27:51 <Axman6> @hoogle IOArray
23:27:52 <lambdabot> No results found
23:28:26 <mmorrow> ski: i guess you could give out a (IO a) instead of an (IORef a), where
23:28:32 <ski> mmorrow : `store' is more or less `ST' .. or rather the hidden state inside `ST'
23:28:45 <mmorrow> wrappedRef ref = readIORef ref
23:29:01 <Cale> Axman6: what code is this?
23:29:35 <rwbarton> Axman6: Data.Array.IO
23:29:38 <Axman6> Cale: it's in Memory.hs in the project code linbked form http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Projects/project06/
23:29:40 <lambdabot> Title: CSE240 Project 6, http://tinyurl.com/62age5
23:30:26 <ski> mmorrow : where ?
23:30:34 <Cale> Yeah, you'll want to change those imports to Data.Array.IO and Data.Word
23:30:38 <mmorrow> <mmorrow> wrappedRef ref = readIORef ref
23:30:40 <mmorrow> :)
23:30:53 <Axman6> Cale: Word seems to work fine, but i could do that
23:31:31 <Axman6> this looks like it might be a useful example of how to use arrays in hasekell, and also assembly... any many other wonderful things
23:31:45 <ski> mmorrow : no, where are these `IO a' and `IORef a' whereof you speak ?
23:31:46 <mmorrow> clarifying, i was saying that i guess you could wrap the IORef in an IO action that reads from it to ensure that the function you hand read capability to can't write to the Ref
23:32:09 <Axman6> anyone know what ParseLib became?
23:32:19 <mmorrow> oh, oops. disregard that whole comment.
23:32:48 <mmorrow> i misread something and explaining wouldn't be worth it :)
23:33:11 <Axman6> looks like parsec...
23:33:20 <Cale> Axman6: You might be able to use Parsec for that, but it would likely involve some playing around... probably better to look for a copy of ParseLib.hs on the web
23:33:42 <mmorrow> this is an interesting type `(IORef a -> a) -> IO (IORef a)'
23:33:43 <Cale> actually, it's a little closer in notation to ReadP, I think.
23:33:52 <Axman6> seems to use the same instructions ad parsec (from the one thing i've seen that i recognise, +++)
23:34:26 <mmorrow> (so my misreading/understanding was on account of me not seeing what that type was saying at first)
23:34:28 <Cale> If you google for ParseLib, you'll find some copies of it.
23:34:42 <Axman6> ok :)
23:34:46 <ski> mmorrow : yes .. hm, now that i think of it, it reminds of `loeb' ..
23:34:57 <mmorrow> rwbarton: this is the other module with directly relevant comment: http://moonpatio.com/docs/ghc/src/TcTyClsDecls.html
23:34:58 <lambdabot> Title: typecheck/TcTyClsDecls.lhs
23:35:02 <mmorrow> ski: totally
23:35:18 <Cale> http://www.fi.muni.cz/usr/skarvada/vyuka/IA014/ParseLib.hs -- this looks promising, but I can't connect to it atm.
23:35:20 <ski>   loeb :: Functor f => f (f a -> a) -> f a
23:35:56 <Cale> ah, just got through, yeah, this looks like it
23:36:05 <ski> (but i have no idea why passing the initializer inside a reference would be useful)
23:36:10 <mmorrow> , let loeb a = fmap ($ loeb a) a in loeb [const 42, (!!2), (!!0)]
23:36:12 <lunabot>  [42,42,42]
23:36:13 <rwbarton> @remember ghc Step 3: Zonk the kinds
23:36:13 <lambdabot> Done.
23:36:24 <mmorrow> ?ghc
23:36:24 <lambdabot> ghc says: ld64: WARNING 47 : This module contains branch instruction(s) that might degrade performance on an R4000 processor.
23:36:30 <mmorrow> haha
23:37:25 <Cale> ?ghc
23:37:25 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
23:37:51 <Cale> ?ghc
23:37:51 <lambdabot> ghc says: foreign declaration uses deprecated non-standard syntax
23:38:15 <rwbarton> @quote ghc construct
23:38:16 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
23:38:18 <rwbarton> @quote ghc construct
23:38:18 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
23:38:50 <rwbarton> @quote ghc PhD
23:38:50 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
23:39:19 <ski> (mmorrow : another downside i forgot is that with no `IO' in the initializer, you can't create new cells, either .. so only length-1 cyclic lists can be initialized)
23:43:26 <ski> mmorrow : `(*1)' ?
23:44:34 <mmorrow> ski: hehe
23:45:07 <rwbarton> @pl (*1)
23:45:08 <lambdabot> id
23:45:15 <luqui> woah!
23:45:18 <Axman6> @hoogle isHexDigit
23:45:18 <lambdabot> Data.Char isHexDigit :: Char -> Bool
23:45:31 <ski> (btw, i have no idea what `go' is supposed to do .. but the `m (Either a (n (..a..)))' pattern seemed maybe similar to a thing i did ..)
23:45:53 <luqui> ski, looks like a free monad
23:46:02 <luqui> er, no, since it's not recursive
23:47:05 <olsner> wow, does ghc really say the PhD message?
23:47:06 <Axman6> @hoogle digitToInt
23:47:06 <lambdabot> Data.Char digitToInt :: Char -> Int
23:47:30 <Cale> olsner: looks like it could be in a comment
23:47:35 <Cale> (in the sourcecode)
23:48:04 <luqui> aww, I thought they figured out a way to award PhDs with software
23:48:20 <olsner> oh, so the one who wrote that probably *did* get a PhD for writing it? :P
23:48:32 <kohwj> hi, how should I obtain Control.Parallel?
23:48:42 <luqui> kohwj, cabal install parallel?
23:49:06 <kohwj> thanks luqui
23:49:22 <kohwj> hooray
23:49:24 <ski> (mmorrow : fyi, i had `type Replay q r a = StateT (Future r) (ExnT (Play q r a) (Writer (History r))) a' with `Play q r a' a monad on top of `IO' .. and `ExnT' is an `EitherT' without the evil `Error' constraint)
23:50:53 <Axman6> @hoogle primIntegerToWord
23:50:53 <lambdabot> No results found
23:51:13 <mmorrow> cool. is there any link-to-able code up?
23:53:02 <Axman6> hmm
23:53:11 <mmorrow> `Future' ==> this is to do with Reactive, right?
23:53:16 <rwbarton> Axman6: probably in GHC.Exts
23:53:57 <Axman6> rwbarton: want to have a look in http://jeffmeunier.wikispaces.com/source+code+-+Haskell+-+Binary32.hs to see if that makes sense? it's usedf as the definition of fromInterger for Binary32
23:53:57 <mmorrow> Axman6: if you don't import any GHC.*, what names aren't in scope?
23:53:58 <rwbarton> Axman6: well, GHC.Exts probably has an equivalent function at least
23:53:59 <lambdabot> Title: Jeff Meunier » source code - Haskell - Binary32.hs, http://tinyurl.com/5tcbaz
23:55:17 <rwbarton> Axman6: You could just newtype derive that instance
23:56:05 <ski> mmorrow : moi ?
23:56:12 <Axman6> so mewtype Binary32 = ... deriving Num?
23:56:46 <rwbarton> right
23:56:54 <rwbarton> turn on the flag it tells you to turn on
23:57:31 <rwbarton> it looks like you could also do this for Eq, Ord, Bounded, Real, Integral, Ix, Enum, Bits
23:57:51 <Axman6> well, seems to not mind if i use -XGeneralizedNewtypeDeriving
23:58:31 <Axman6> meh, i just want the code to work/compile, i don't care if it's not up to the latest developments
23:58:38 <Axman6> or.. not so new ones
23:58:49 <mmorrow> ski: (about the Future ...?) do you have any snippets related to that type you gave?
23:58:58 <mmorrow> type Replay q r a = StateT (Future r) (ExnT (Play q r a) (Writer (History r)))
23:59:13 <Axman6> how do you put things like -XGeneralizedNewtypeDeriving in a comment up the top again?
23:59:20 <mmorrow> oh, are these standard reactive types or something?
23:59:21 <rwbarton> {-# LANGUAGE Gener.. #-}
23:59:40 * mmorrow needs to finish reading up on reactive
23:59:47 <pumpkin_> is there some dot file I can put in my home directory to tell ghci what to import by default?
