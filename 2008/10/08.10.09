00:04:02 <Baughn> (Also, I understand that 10.1 includes an exception revamp. I wonder what it'll be.)
00:04:11 <lispy> interesting
00:04:17 <lispy> So, the issue is of traning?
00:04:19 <lispy> training*
00:04:25 <lispy> getting the idioms out there in common usage?
00:05:29 <Baughn> That, and getting it into the standard library
00:05:35 <Baughn> readFile doesn't use dynamic exceptions, so..
00:05:38 <Saizan> Baughn: a proper extensible hierarchy of exceptions with subtyping
00:09:21 <Samy>  > let {t = [True,False]; True --> False = False; _ --> _ = True} in and [ ((p --> q) && (r --> s) && (not q || not s)) --> (not p || not r) | p <- t, q <- t, r <- t, s <- t]
00:09:25 <Samy> > let {t = [True,False]; True --> False = False; _ --> _ = True} in and [ ((p --> q) && (r --> s) && (not q || not s)) --> (not p || not r) | p <- t, q <- t, r <- t, s <- t]
00:09:27 <lambdabot>   True
00:11:22 <Cale> http://cale.yi.org/share/LambdaAsphalt.jpg :)
00:12:00 <lispy> gosh, it's late, I should maybe go home...
00:12:01 <rwbarton> @djinn ((p -> q), (r -> s), Either (Not q) (Not s)) -> Either (Not p) (Not r)
00:12:01 <lambdabot> f (a, b, c) =
00:12:01 <lambdabot>     case c of
00:12:01 <lambdabot>     Left d -> Left (\ e -> d (a e))
00:12:01 <lambdabot>     Right f -> Right (\ g -> f (b g))
00:12:23 <lispy> Cale: nice
00:12:46 <pastorn> how do i use the simple reflect function?
00:13:17 <lispy> What is Not?
00:13:43 <Samy> Cale, where could I find that lambda image?
00:13:54 <Saizan> lispy: type Not a = a -> Void
00:14:19 <lispy> Saizan: ah, so by the CH it's like, a implies False?
00:14:27 <pastorn> > map f [x,y,z]
00:14:27 <lambdabot>   Add a type signature
00:14:34 <pastorn> > map f [x,y,z] :: Expr
00:14:35 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
00:14:40 <pastorn> > map f [x,y,z] :: [Expr]
00:14:40 <rwbarton> @pl map f [x,y,z]
00:14:40 <lambdabot> map f [x, y, z]
00:14:41 <lambdabot>   [f x,f y,f z]
00:14:54 <QtPlatypus> @djinn String [String] -> String
00:14:55 <lambdabot> Error: Undefined type String
00:14:56 <rwbarton> @pl foldr f [x,y,z]
00:14:56 <lambdabot> foldr f [x, y, z]
00:15:05 <rwbarton> @pl foldr f z [x,y]
00:15:05 <lambdabot> f x (f y z)
00:15:24 <QtPlatypus> @djinn [Char] -> [[Char]] -> [Char]
00:15:24 <lambdabot> Error: Undefined type []
00:15:35 <Cale> Samy: It's the Monad Reader's logo.
00:16:00 <Cale> Samy: Someone posted a link to a nice clean png on the Haskell mailinglist.
00:16:08 <Cale> http://tonguc.name/images/lambda-1280x800.png
00:16:26 <Cale> I suspect there's an SVG version around somewhere though.
00:16:40 <Samy> that'll do
00:16:46 <Samy> thanks
00:17:13 <humasect> http://www.visualwalkthroughs.com/halflife2/routekanal1/d1_canals_01a0000.jpg
00:17:19 <lambdabot> http://tinyurl.com/4temyv
00:18:04 * Samy would rather not use Valve's logo ;-p
00:24:26 <Cale> humasect: :)
00:29:56 <rwbarton> ugh... trying to generate normal guards with template haskell, but it turns them into pattern guards and then gives me a warning when I don't have -XPatternGuards
00:30:59 <lispy> rwbarton: weird
00:31:19 <lispy> rwbarton: maybe you're using the abstractions incorrectly?
00:31:32 <rwbarton> it's quite possible
00:31:54 <rwbarton> but I'm using the NormalG constructor, not the PatG one, so unless the 'derive' machinery is turning one into the other...
00:32:20 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/2017
00:32:21 <lambdabot> Title: #2017 (Normal Guards are internally spliced as Pattern Guards causing compiler w ...
00:33:35 <rwbarton> well, it's not like I can't rewrite this to avoid guards.  Maybe for another day
00:34:21 <Cale> http://arcanux.org/lambdacats/fixed-in-head.jpg
00:34:55 <rwbarton> It's funny even without looking at it again :)
00:35:47 <lispy> nice
00:38:01 <pastorn> Cale: why is that funny? is it head as in (x:xs)?
00:38:22 <Cale> pastorn: It's HEAD as in the main branch of a repository.
00:38:31 <pastorn> oh, ok
00:38:34 <Cale> (in particular, the GHC repository :)
00:38:55 <pastorn> sorry for making you explain a joke :/
00:40:05 <glguy> GHC now uses libffi to implement parts of the FFI, replacing some of the home-grown and very architecture-specific code we had to do this. Amongst other benefits, this will ease the task of porting GHC in the future. Done; but maybe use it to solve the SE Linux paranoia problem?
00:40:14 <glguy> what is the selinux problem?
00:40:27 <glguy> execmem?
00:42:47 <jdrake> Does anyone know why there is a syntax error on the = of this paste http://hpaste.org/11029#a2 ?
00:42:56 <jdrake> parse error rather
00:44:06 <lispy> jdrake: maybe you need to indent the cases more?
00:44:23 <lispy> jdrake: I think the Just and the Nothing need to line up with the c of case
00:44:46 <jdrake> lispy, no difference
00:44:57 <rwbarton> is this in a do block?  I can make it compile
00:45:04 <rwbarton> Well, not compile.  Parse though
00:45:09 <jdrake> oops, I got the line number wrong
00:45:10 <BeelsebobWork> they need to be *more* indented than the c in case
00:45:31 <rwbarton> Actually they just need to be more indented than the k in key, it seems
00:45:55 <jdrake> nevermind, my eyes caught the wrong line
00:46:20 <jdrake> :t exitWith
00:46:22 <lambdabot> Not in scope: `exitWith'
00:46:32 <jdrake> :t System.Exit.exitWith
00:46:33 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
00:47:15 <rwbarton> That code, if it compiled, would just assign the action of quitting the program to key in the failure case
00:47:22 <rwbarton> It wouldn't do anything with that action
00:49:07 <jdrake> rwbarton, perhaps I should open this up to the whole function: http://hpaste.org/11029?lines=true#a3   line 9 I need to have something there, but it doesn't matter what. And I need to be able to exit at those positions. Any ideas?
00:50:41 <rwbarton> jdrake: the most straightforward option is to put the rest of the do block there
00:51:05 <rwbarton> actually, that's unnecessary
00:51:10 <rwbarton> you can just put  return ()
00:51:19 <jdrake> On which line
00:51:22 <rwbarton> Also, you can use when
00:51:27 <rwbarton> On line 9, after the ->
00:51:30 <rwbarton> @src when
00:51:30 <lambdabot> when p s = if p then s else return ()
00:52:16 <rwbarton> lines 11-15 are more interesting
00:52:34 <jdrake> when (not fileExists ) do ... lines 7 - 8?
00:52:55 <rwbarton> Right.  (You might need parentheses around the do)
00:53:02 <Cale> Is loadKey in scope?
00:53:09 <Baughn> Saizan: Is that what's coming in 10.1, or just your desire
00:53:13 <Baughn> ?
00:53:15 <jdrake> Cale, yes
00:53:42 <Cale> What type is it?
00:53:43 <rwbarton> lines 11-15 could be   key <- case loadKey of Just akey -> return akey; Nothing -> do {...}
00:53:59 <jdrake> Where is when
00:54:01 <Cale> (It just doesn't sound like something which would be a  Maybe t)
00:54:05 <rwbarton> Control.Monad
00:54:22 <Deewiant> when is such an obvious candidate for the Prelude :-/
00:54:31 <Cale> If it's in scope, then it must be constant too, which means that one or the other branch of that case is dead code?
00:54:34 <glguy> Bush definitely figured out the Golden Rule
00:54:37 <glguy> whoops
00:55:04 <glguy> this is why you shouldn't use split screen irssi ;)
00:55:25 <Cale> glguy: Do unto others what you fear they might do unto you?
00:55:40 <jdrake> Should something like <$> be able to help with the (do ...)?
00:55:55 <Cale> jdrake: Just plain $ perhaps?
00:56:07 <Cale> (If you're just referring to the parens)
00:58:17 <jdrake> http://hpaste.org/11029?lines=true#a4
00:58:32 <jdrake>     Couldn't match expected type `t -> IO ()'           against inferred type `IO a'
00:58:36 <jdrake> That is on line 7
00:59:08 <rwbarton> :t exitFailure
00:59:09 <lambdabot> Not in scope: `exitFailure'
00:59:16 <BeelsebobWork> caps E
00:59:20 <rwbarton> :t System.Exit.exitFailure
00:59:21 <lambdabot> forall a. IO a
00:59:24 <BeelsebobWork> also -- but the do on the next line
00:59:32 <BeelsebobWork> then the arguments to when get clearly seperated
00:59:46 <BeelsebobWork> and the do gets accociated with the putStrLn and ExitFailure
00:59:51 <rwbarton> exitWith (ExitFailure 2)
01:00:30 <BeelsebobWork> I'd even be inclined to write exitWithMessage mes code = putStrLn mes >> exitWith (ExitFailure code)
01:00:47 <rwbarton> Ha, exitWith (ExitFailure 0) throws an IOError :)
01:01:23 <jdrake> Now on line 9 I get an incorrect indentation
01:02:43 <BeelsebobWork> I'd do something like this... http://hpaste.org/11029#a5
01:03:14 <jdrake> Not bad, I shall do that
01:04:10 <BeelsebobWork> although exitWithMessage probably deserves to be moved to another module
01:04:33 <jdrake> Well that fixes the syntax error
01:04:43 <rwbarton> and then you can change putStrLn to hPutStrLn stderr
01:05:05 <BeelsebobWork> indeed, good point rwbarton
01:05:28 <jdrake> http://hpaste.org/11029?lines=true#a6
01:05:38 <jdrake>     Couldn't match expected type `IO (Maybe (Map.Map String Integer))'           against inferred type `Maybe a'
01:05:51 <jdrake> line 9
01:06:09 <BeelsebobWork> you want let key =
01:06:11 <BeelsebobWork> not bind
01:06:22 <BeelsebobWork> oh wait, loadKey is an action
01:07:03 <jdrake> I have updated it with your function on the Nothing with no change in error
01:07:17 <BeelsebobWork> jdrake: http://hpaste.org/11029#a7
01:07:33 <rwbarton> BeelsebobWork: You still want key <- not let key =
01:07:41 <BeelsebobWork> rwbarton: oh, good point
01:07:43 <BeelsebobWork> >.<
01:08:11 <BeelsebobWork> http://hpaste.org/11029#a8 <-- better
01:08:15 <jdrake> Now the branches of the case: are they actually the same type?
01:08:41 <jdrake> BeelsebobWork, what is the difference between that and just putting the function call in the case?
01:08:47 <BeelsebobWork> jdrake: they look like they are to me -- doesn't exitWith have type a?
01:09:12 <rwbarton> they're the same now
01:09:15 <BeelsebobWork> jdrake: that case expression expects to get a Maybe Key
01:09:23 <BeelsebobWork> but loadKey is an IO action
01:09:29 <BeelsebobWork> that when run will give back a Maybe Key
01:09:51 <BeelsebobWork> so you need to bind a variable to the result of running it
01:10:27 <jdrake> Well, now I get to have two errors for line 13 :-)
01:10:53 <jdrake> http://hpaste.org/11029#a9
01:11:45 <rwbarton> :t Data.Map.lookup
01:11:46 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
01:11:47 <BeelsebobWork> I *think* it's saying "I haven't got a clue what type is stored in this Data.Map
01:11:55 <BeelsebobWork> oh, no
01:11:58 <rwbarton> lookup is polymorphic in the monad m to fail in
01:12:02 <BeelsebobWork> it's saying "I don't know what monad it's gonna return in"
01:12:19 <jdrake> BS: case JSON.decodeStrict keyfileData :: JSON.Result (Map.Map String Integer) of
01:12:34 <rwbarton> What type do you want privkey to have?  (The compiler has no way of knowing yet)
01:12:55 <jdrake> Well, the data is all Integer and I specified that when making the map
01:13:22 <rwbarton> But lookup gives you a choice of how to fail when the key is not present
01:13:31 <BeelsebobWork> http://hpaste.org/11029#a10 <-- that should do the trick
01:13:36 <jdrake>     Couldn't match expected type `Integer'
01:13:37 <jdrake>            against inferred type `m Integer'
01:13:47 <BeelsebobWork> jdrake: lookup returns in a monad
01:13:56 <BeelsebobWork> because it's not guarenteed to find the key you're looking for
01:14:25 <rwbarton> The function that assumes it will find the key is called Map.!
01:14:31 <jdrake>     let privkey = (Map.lookup "pub" key, Map.lookup "priv" key) :: (Maybe Integer, Maybe Integer)
01:14:32 <rwbarton> :t (Data.Map.!)
01:14:33 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
01:14:41 <BeelsebobWork> jdrake: sounds hopeful
01:15:34 <jdrake> I don't know what 'Key' is
01:15:52 <BeelsebobWork> it's a type I made up meaning "whatever type your keys have"
01:16:03 <BeelsebobWork> it can be fixed by the sounds of it by adding type Key = Integer
01:16:14 <jdrake> But I am getting the values not the keys
01:16:28 <BeelsebobWork> no no -- you're getting a private *key*
01:16:46 <BeelsebobWork> I'm talking about your encryption key, not the key to your Data.Map
01:16:59 <jdrake> BeelsebobWork, are you trying to confuse me this late at night?
01:17:08 <BeelsebobWork> o.O 10:16 am?
01:17:16 <BeelsebobWork> :P
01:17:17 <jdrake> The private key is (Integer, Integer)
01:17:27 <BeelsebobWork> privkey certainly doesn't have that type
01:17:39 <jdrake> Well that is what it should :-)
01:17:41 <BeelsebobWork> privkey has (Maybe something, Maybe something)
01:17:47 <BeelsebobWork> or any monad in fact
01:18:04 <BeelsebobWork> if you *want* it to have (Integer, Integer), you want Map.! not Map.lookup
01:18:10 <jdrake> I predict I will be fighting haskell all the way through this program
01:18:23 <BeelsebobWork> and you need to be damn sure that "pub" and "priv" exist in that the Data.Map
01:18:40 <BeelsebobWork> jdrake: it's ensuring your safety -- it may not find "pub" in the map you throw at it
01:18:42 <rwbarton> You seem to be fighting the fact that you want to give different error messages to every thing that could go wrong
01:19:25 <jdrake> rwbarton, probably because it seems like errors are half baked in haskell
01:19:39 <rwbarton> I don't understand how it's different from any other language with exceptions
01:19:58 <rwbarton> (but admittedly, I usually don't worry about exceptions much)
01:20:13 <jdrake> a nice try block would be handy
01:20:40 <rwbarton> try block <-> Either e monad for the most part
01:21:38 <BeelsebobWork> jdrake: http://hpaste.org/11029#a11 <-- how's this?
01:21:41 <jdrake> In an case condition can I do something like  (Just x, Just y) :: Integer -> ...
01:23:04 <jdrake> BeelsebobWork, I might take that an just make it extractPrivateKey and extractPublicKey :-) Looks useful for that.
01:23:29 <jdrake> The map actually does contain everything except for a constant used
01:24:02 <jdrake> Why would you use Map.lookup as an operator?
01:25:45 <BeelsebobWork> jdrake: http://hpaste.org/11029#a12 <-- getting better?
01:25:58 <BeelsebobWork> oops, probably wanted public in the second error message
01:26:07 <BeelsebobWork> oh. and to call the right function
01:26:39 <rwbarton> and you need <- again :)
01:26:44 <BeelsebobWork> so I do
01:26:53 <jdrake> Last two functions aren't even close :-)
01:27:02 <BeelsebobWork> http://hpaste.org/11029#a13
01:27:08 <BeelsebobWork> that's a bit better
01:27:42 <jdrake> http://hpaste.org/11029#a14
01:28:15 <jdrake> I like possiblyFail
01:29:01 <jdrake> BeelsebobWork, I believe you are writing half of my permanent utility library
01:29:05 <jdrake> http://hpaste.org/11029#a14
01:29:11 <BeelsebobWork_> oops, scuse
01:29:13 <BeelsebobWork_> network exploded
01:29:25 <BeelsebobWork_> jdrake: the thing I'm hoping you're seeing here is that Haskell is powerful because every time you see the slightest bit of repeated code, you can yank it out into an abstraction
01:30:02 <jdrake> certainly
01:30:14 <jdrake> It is just getting things to the point where I can remember them and understand what they do
01:30:35 <jdrake> How can you fix possiblyFail to deal with the newer extractPrivateKey function in #a14?
01:30:53 <rwbarton> jdrake: how about http://hpaste.org/11029#a15
01:31:14 <jdrake> ok, I think that needs some explanation
01:31:19 <jdrake> @src (,)
01:31:19 <lambdabot> Source not found. :(
01:31:29 <BeelsebobWork_> looks good
01:31:30 <rwbarton> (,) is just the constructor for pairs
01:31:32 <BeelsebobWork_> but I'd wrap the line
01:31:32 <rwbarton> > (,) 3 5
01:31:33 <lambdabot>   (3,5)
01:31:47 <rwbarton> actually (3,5) is syntactic sugar for (,) 3 5
01:31:55 <BeelsebobWork_> http://hpaste.org/11029#a16 <-- something like that
01:32:06 <rwbarton> liftM2 is more interesting
01:32:13 <rwbarton> @src liftM2
01:32:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:32:35 <BeelsebobWork_> I prefer liftM2 f m1 m2 = f <$> m1 <*> m2
01:32:49 <nomeata> @seen gwern
01:32:49 <opqdonut> mhmm
01:32:49 <lambdabot> Last time I saw gwern was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
01:32:49 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 1m 10d 9h 50m 48s ago, and .
01:32:54 <BeelsebobWork_> there's nothing sequential about liftM2
01:32:59 <nomeata> @seen gwern0
01:32:59 <lambdabot> I haven't seen gwern0.
01:34:12 <jdrake> I think I am missing exactly what liftM2 does
01:34:26 <BeelsebobWork_> jdrake: it takes two monadic values
01:34:34 <BeelsebobWork_> it runs the monads and gets the values out
01:34:44 <BeelsebobWork_> it applies the function to the two values
01:34:52 <BeelsebobWork_> and it bundles up that back in the monad
01:35:36 <jdrake> So it takes (Maybe x, Maybe y) and turns it into Maybe (x,y)?
01:35:41 <BeelsebobWork_> yep
01:35:52 <jdrake> Monadic factoring?
01:36:01 <BeelsebobWork_> so (Just x, Just y) becomes Just (x,y), while (Just x, Nothing) becomes Nothing
01:36:24 <jdrake> How?
01:36:30 <jdrake> The latter case Id o not se
01:36:38 <papermachine> @djinn (Maybe a, Maybe a) -> Maybe (a, a)
01:36:38 <lambdabot> f (a, b) =
01:36:38 <lambdabot>     case a of
01:36:38 <lambdabot>     Nothing -> Nothing
01:36:38 <lambdabot>     Just c -> case b of
01:36:38 <lambdabot>               Nothing -> Nothing
01:36:40 <lambdabot>               Just d -> Just (d, c)
01:37:05 <BeelsebobWork_> jdrake: because that's how the Maybe monad works
01:37:11 <BeelsebobWork_> @src Maybe (>>=)
01:37:11 <lambdabot> (Just x) >>= k      = k x
01:37:12 <lambdabot> Nothing  >>= _      = Nothing
01:37:26 <BeelsebobWork_> if you get a Nothing anywhere, the result will be Nothing
01:37:58 <jdrake> Monads are still half pain and half headache right now, but I think I am doing fairly well
01:38:11 <BeelsebobWork_> do {x1 <- m1; x2 <- m2: return $ f x1 x2} desugars to m1 >>= \x1 -> m2 >>= \x2 -> return $ f x1 x2
01:38:32 <BeelsebobWork_> so, lets make m1 and m2 into Just x and Nothing
01:39:07 <BeelsebobWork_> Just x >>= \x1 -> Nothing >>= \x2 -> return $ f x1 x2
01:39:25 <BeelsebobWork_> -> (\x1 -> Nothing >>= \x2 -> return $ f x1 x2) x
01:39:27 <jdrake> do was just  applying  >>= to statement after statement right?
01:39:34 <BeelsebobWork_> yep
01:39:39 <BeelsebobWork_> that's what the desugaring step does
01:39:47 <BeelsebobWork_> -> Nothing >>= \x2 -> return $ f x x2
01:39:49 <BeelsebobWork_> -> Nothing
01:40:19 <jdrake> You know, if I really get into haskell and speak nothing but haskell, I might have nothing in common with anyone else I know who programs.
01:40:39 <BeelsebobWork_> haha
01:40:48 <BeelsebobWork_> you would become the enlightened one :)
01:42:03 <jdrake> Is there such a beast as a GUI monad?
01:42:15 <BeelsebobWork_> there are various such beasts
01:42:23 <jdrake> For my public key function:  possiblyFail (liftM2 (,) (Map.lookup "pub" key) (Just (65537::Integer))) ...
01:42:23 <BeelsebobWork_> but all of them are called IO
01:42:23 <rwbarton> It's lots of fun to pick a random monad and a random monad-using function and see what they do together.
01:42:37 <BeelsebobWork_> jdrake: yep
01:42:43 <rwbarton> For example, in the IO monad, sequence takes a list of values and runs them in turn, returning a list of the results
01:42:44 <BeelsebobWork_> or return instead of Just
01:42:46 <rwbarton> But also:
01:42:54 <rwbarton> > sequence [[1,2,3], [4,5,6]]
01:42:55 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
01:43:21 <jdrake> BeelsebobWork_, I am pleased that I get this code
01:43:38 <papermachine> I'm kind of sad that IO is so huge
01:44:15 <jdrake> papermachine, that makes me a sad panda
01:44:48 <jdrake>     Couldn't match expected type `Integer'         against inferred type `Maybe t'  In the third argument of `liftM2', namely `(Just 65537 :: Integer)'
01:44:58 <jdrake> I didn't think it would have trouble with this
01:45:05 <jdrake> nvm
01:45:07 <jdrake> I typed it wrong
01:45:36 <jdrake> ok, now to fix the rest to line up with BeelsebobWork_'s code
01:45:55 <rwbarton> jdrake: I think it's unlikely you need to keep repeating the :: Integer type annotation, the one in loadKey ought to be sufficient
01:46:18 <jdrake> rwbarton, this is a new tuple though
01:46:45 <jdrake> unless 65537 can map to both Int and Integer equally
01:46:46 <rwbarton> Ah, I guess here it matters
01:47:20 <jdrake> rwbarton, I was deflowered by Ocaml, so you might have to forgive me a little :-)
01:47:21 <rwbarton> (Well, yes, it will default to Integer right now)
01:47:29 <rwbarton> :t 65537
01:47:30 <lambdabot> forall t. (Num t) => t
01:47:41 <jdrake> :t 65537::Integer
01:47:42 <lambdabot> Integer
01:48:46 <idnar> :t 65537::Int
01:48:47 <lambdabot> Int
01:48:49 <rwbarton> It's kind of hard to demonstrate this, but when it needs a type t and the only constraint on that type is Num t, it will choose t = Integer
01:48:53 <idnar> > 65537::Int
01:48:54 <lambdabot>   65537
01:49:17 <rwbarton> > show (10^80)
01:49:19 <lambdabot>   "10000000000000000000000000000000000000000000000000000000000000000000000000...
01:49:21 <rwbarton> > show (10^80 :: Int)
01:49:22 <lambdabot>   "0"
01:50:20 <the_unmaker> http://www.geocities.com/tablizer/reustalk.htm#reuse_bloat
01:50:21 <lambdabot> Title: Reuse Issues
01:50:22 <the_unmaker> wow
01:50:29 <the_unmaker> this guy has some real oo sucks opinons
01:50:40 <the_unmaker> and makes bertandmeyer out to be a scammer
01:51:23 <jdrake> Well this is what it all looks like right now: http://hpaste.org/11029#a17
01:52:10 <pafcu> Anyone know how to implement options requiring multiple arguments with GetOpt? i.e ./foo -g 10 20 and the parser would realise that both "10" and "20" are arguments for the "-g" option
01:56:27 <jdrake> Thank you everyone for your help, but I must go to bed now and count monads until I sleep.
01:58:50 <hackage> Uploaded to hackage: yjftp 0.3
01:58:50 <hackage> Uploaded to hackage: hsConfigure 0.1
01:59:18 <the_unmaker> so can one run webapps without a realtional database and still kick ass performance wise using haskell?
01:59:48 <opqdonut> errr
01:59:52 <jeffz> if you don't need a relational database, sure
01:59:56 <opqdonut> can't see how the db affects performance
02:00:24 <vegai> usually the db slows you down, doesn't it?
02:00:42 <vegai> and this of course does NOT depend on which DB you are using :P
02:00:47 <vegai> nor how
02:01:00 <opqdonut> exactly
02:01:28 <opqdonut> an in-memory data structure chosen with your exact use case in mind is quite a bit faster
02:02:16 <vegai> with the exception that you have terabytes to store
02:02:45 <vegai> the_unmaker: but anyway. HAppS seems to be working towards that direction
02:03:29 <vegai> they 'just' serialize your internal state to the disk with acid guarantees
02:03:47 <the_unmaker> hmf
02:04:04 <the_unmaker> is thre any lindaspace work in haskell?
02:04:50 <opqdonut> vegai: well if you have terabytes of ram ;)
02:05:38 <the_unmaker> they seel a box with 506Gram now
02:05:53 <the_unmaker> but most of your data will be static images n movies
02:05:54 <the_unmaker> files
02:06:08 <the_unmaker> all you have to do is numbe them as refernce in the ram absed app
02:06:16 <the_unmaker> 99% of space static
02:06:21 <the_unmaker> just the commadn logic in ram
02:06:25 <the_unmaker> sounds doable
02:12:35 <BeelsebobWork_> jdrake: sorry, got yoinked by my boss
02:12:47 <jdrake> Beelsebob, yoinked?
02:12:55 <BeelsebobWork_> you need to watch more simpsons
02:13:20 <jdrake> I am not sure there is any value there.
02:13:29 <jdrake> I could barely watch the latest southpark
02:13:32 <the_unmaker> i fuking hate the simpsons
02:15:23 <jdrake> Although an amusing reference in the latest southpark to a certain raping of indiana jones by speelburg and lucas; then at the end raping a storm trooper. Sometimes their references are quite good.
02:17:59 <BeelsebobWork_> I'm not sure how people can realistically compare south park and the simpsons in terms of quality of comment of society
02:18:08 <BeelsebobWork_> not that either are high satire or anything
02:18:19 <jdrake> Interesting: an icon package for kde is almost 50mb.. [1 kde-icons-oxygen 1760373/49.4MB 3%]
02:19:01 <jdrake> BeelsebobWork_, I prefer the humour in south park because they do not hold anything back, they go after everyone.
02:19:25 <BeelsebobWork_> jdrake: I prefer the humor in the simpsons because they *do* hold back -- they go after everyone, but it's more subtle
02:19:31 <BeelsebobWork_> south park is way too american for me
02:20:08 * rwbarton is confused by how everyone is spelling "humor"
02:20:11 <jdrake> Well, you seem to be americanized enough in your spelling :-)
02:20:36 <BeelsebobWork_> heh
02:20:48 <jdrake> rwbarton, In the Queen's English it is spelt 'humour'
02:20:56 <BeelsebobWork_> it is indeed
02:20:58 <jdrake> The Queen being the Queen of Canada
02:21:01 <BeelsebobWork_> I feel somewhat embarrased
02:21:27 <jdrake> BeelsebobWork_, spell checkers are nice :-)
02:21:31 <rwbarton> jdrake: Sorry, I forgot about you guys up there! :)
02:21:48 <jdrake> rwbarton, that is why I must sleep now!
02:21:49 <BeelsebobWork_> jdrake: unfortunately, even when set to british english, OS X's spell checker still corrects things into US english
02:22:04 <BeelsebobWork_> (it's fecking irritating)
02:22:11 <jdrake> BeelsebobWork_, there must be a work around.
02:22:21 <jdrake> I am pretty sure that I used to use Canadian English in osx.
02:22:24 <BeelsebobWork_> jdrake: I think the closest there is is to modify the dictionary file
02:22:28 <jdrake> But that was many years ago
02:22:36 <jdrake> I am a fully converted gnomite now
02:22:57 <BeelsebobWork_> I just see no reason to use a platform that can't run half the apps I can on OS X
02:23:07 <BeelsebobWork_> while OS X can run 90% of the apps I would use on linux
02:23:21 <jdrake> BeelsebobWork_, Its not a bad thing :-)
02:23:36 <BeelsebobWork_> jdrake: sure it is -- I have various OS X apps that I *love*
02:23:42 <BeelsebobWork_> darchaeology for example
02:23:46 <jdrake> What is that?
02:23:53 <BeelsebobWork_> a *really* good darcs gui
02:24:02 <jdrake> OH, I swear by bzr :-)
02:24:31 <BeelsebobWork_> hehe, that's a rare one
02:24:53 <jdrake> It is used for launchpad, which I host my repository, and I can remember the commands easily with this one.
02:24:58 <BeelsebobWork_> from what I can tell, git is the emerging winnar in the distributed SCM setting
02:25:01 <jdrake> That is something rare for me and code versioning.
02:25:25 <jdrake> At least we still aren't using cvs.
02:25:34 <jdrake> cvs was really confusing for me
02:25:39 <jeffz> plenty of people still use cvs
02:25:40 <BeelsebobWork_> haha
02:25:45 <BeelsebobWork_> really?
02:25:50 <jeffz> annoyingly
02:25:51 <BeelsebobWork_> I know tons of people using svn
02:25:54 <BeelsebobWork_> but no one using cvs
02:26:47 <jdrake> I might actually start using bzr for my own school files too
02:27:04 <Taejo> my most-used VCS repo is CVS :( --- the project is run by a guy who is rather stuck in his ways
02:27:14 <jdrake> But I think I need to find something that does wordprocessing with ascii files, and latex isn't quite there for me.
02:27:47 <BeelsebobWork_> jdrake: LaTeX is by far the most advanced -- it's been bandied around in here though that a DSL for such documents would be cool
02:28:01 <jdrake> 'DSL'?
02:28:09 <BeelsebobWork_> domain specific language
02:28:21 <BeelsebobWork_> i.e. embed a language for doing page layout in Haskell
02:28:39 <jdrake> I hate that latex can throw an image pages away from where you need it.
02:28:48 <jdrake> BeelsebobWork_, maybe I might be tempted :-)
02:28:53 <jdrake> I love this thing called domtool
02:29:06 <BeelsebobWork_> yeh, that does irritate me too -- you can however force it to flush figures, and make it insert a figure page
02:29:17 <BeelsebobWork_> but it's by far not ideal
02:29:46 <jdrake> BeelsebobWork_, take a look at this DSL: http://wiki.hcoop.net/DomTool/Examples
02:29:49 <lambdabot> Title: DomTool/Examples - HCoop Wiki
02:30:55 <jdrake> BeelsebobWork_, would you be interested in talking more about this in the future? I would love to get ideas from you to see what might work and what might not :-)
02:32:23 <Xenoblitz> guys... if you have a type which is a synonym of Int... why am i getting these errors? No instance for (RealFrac My_Types.Gravity)
02:32:23 <Xenoblitz>   arising from a use of `round' at My_Game.hs:64:30-34
02:32:23 <Xenoblitz> Possible fix:
02:32:23 <Xenoblitz>   add an instance declaration for (RealFrac My_Types.Gravity)
02:32:48 <jdrake> :t RealFrac
02:32:49 <lambdabot> Not in scope: data constructor `RealFrac'
02:32:53 <jdrake> :t round
02:32:54 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
02:33:08 <jdrake> :t Int
02:33:09 <lambdabot> Not in scope: data constructor `Int'
02:33:29 <Saizan> ?type round (1 :: Int) -- Xenoblitz the problem is with Int
02:33:30 <lambdabot>     No instance for (RealFrac Int)
02:33:30 <lambdabot>       arising from a use of `round' at <interactive>:1:0-15
02:33:30 <lambdabot>     Possible fix: add an instance declaration for (RealFrac Int)
02:33:42 <quicksilver> Xenoblitz: in a ghci session, type :i RealFrac
02:33:51 <quicksilver> Xenoblitz: you're using one of those methods, most likely.
02:33:58 <jdrake> @src RealFrac
02:33:58 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
02:33:58 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
02:33:58 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
02:34:39 <Xenoblitz> what's bugging me is that if i write the expression in ghci and substitue an Int it works without complaining
02:34:42 <jdrake> wierd class
02:34:59 <Saizan> ?type 1
02:35:00 <lambdabot> forall t. (Num t) => t
02:35:00 <quicksilver> Xenoblitz: I doubt that.
02:35:09 <Xenoblitz> honestly... lemme give you the expression
02:35:11 <jdrake> Well night all
02:35:13 <quicksilver> Xenoblitz: you're calling 'round' on a Gravity, according to that error.
02:35:20 <quicksilver> you can't call 'round' on an Int.
02:35:26 <quicksilver> > round (3 :: Int)
02:35:27 <lambdabot>       No instance for (RealFrac Int)
02:35:28 <lambdabot>        arising from a use of `round' at ...
02:35:30 <Xenoblitz> yes but Gravity is a type for Int
02:35:36 <quicksilver> exactly.
02:35:47 <quicksilver> You can't call round on Gravity. or Int. because they are the same.
02:36:05 <Saizan> if you call round on a numeric literal in ghci it gets inferred to the right type, even if it has no decimal point
02:36:07 <Xenoblitz> so wait when i do this in ghci round $ recip ((abs 3) + 1) * 1000000 ... its actually using another type?
02:36:14 <quicksilver> yes.
02:36:16 <Saizan> exactly
02:36:17 <quicksilver> there are no Ints there.
02:36:22 <Xenoblitz> i c :/
02:37:14 <Saizan> however there's fromIntegral
02:37:38 <quicksilver> Xenoblitz: can you explain what you're actually trying to do? The solution will be simple :)
02:37:44 <Saizan> > round $ recip $ fromIntegral (5::Int)
02:37:45 <lambdabot>   0
02:38:38 <Xenoblitz> well basically find the absolute of a number, increment it by 1, do its reciprocal, multiply the result by 1 million and then finally round it up
02:38:47 <Xenoblitz> the number itself is an Int
02:40:11 <quicksilver> well to do a reciprocal, you have to move into a fractional type.
02:40:19 <quicksilver> reciprocal is not very interesting in integers.
02:40:43 <quicksilver> although why not just do 1000000 `div` (n+1)
02:40:50 <quicksilver> that's entirely integer math
02:41:24 <Xenoblitz> true
02:41:26 <Xenoblitz> hmmm
02:41:44 <quicksilver> so, the answer to you problem is you will want to 'fromIntegral' before the recip.
02:41:52 <quicksilver> because recip doesn't make sense for Ints
02:41:58 <Xenoblitz> yeah i see that now
02:41:59 <rwbarton> (Is My_Types.Gravity really a type synonym for Int?  Seems weird that ghc wouldn't expand the type synonym in that error message)
02:42:18 <quicksilver> however, a better answer to the algorithm is probably to use 1000000`div` ;)
02:42:34 <quicksilver> rwbarton: ghc deliberately does not expand type synonyms earlier than it has to.
02:42:34 <Xenoblitz> yeah i will give it a go, its much more simpler the way you wrote it
02:42:48 <Xenoblitz> and rwbarton: type Gravity = Int, that's the definition i am using
02:42:51 <quicksilver> rwbarton: to try to make error messages more useful :)
02:43:12 <rwbarton> quicksilver: makes sense
02:43:37 <rwbarton> quicksilver: it's just (1) I'm used to seeing No instance for (Num [Char]), but that's because apparently "foo" :: [Char] not :: String
02:45:17 <rwbarton> quicksilver: (2) you can't use a type synonym as an instance head in haskell 98
02:45:21 <Xenoblitz> thanks for helping me understand the problem guys... and quicksilver nice optimization... really saves alot of problems
02:48:53 <quicksilver> (1) yes (2) you're right, it is a strange error message for this reason  :)
02:55:30 <Saizan> it would be nice to just be able to write (assume Foo, Bar :: *) and let them be defined in another module, instead of getting type variables everywhere.. or, in other words, have ML functors
02:59:07 <hhiroavalon> Hi, can I get some assistance with my Haskell programming here?
02:59:24 <Saizan> sure
03:00:19 <hhiroavalon> Thanks. I'm having some problems with implementing a function that would take in a matrix (list of lists) and rotate them 90 degrees to the right.
03:01:42 <Saizan> ok, where's the problem?
03:02:15 <hhiroavalon> I currently have something that seems inefficient, and I wanted a third person's view of my code, and where I can improve it
03:02:24 <Saizan> @paste
03:02:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:02:38 <Saizan> paste the code there ^^^^
03:03:18 <hhiroavalon> http://hpaste.org/11036?lines=true#a0
03:04:55 <chrisdone> does cabal-install have a list somewhere of packages never to download?
03:05:16 <chrisdone> automatically, that is
03:05:38 <chrisdone> it downloaded `network' and now all the libraries using the distribution's `network' are giving link errors
03:05:59 <Saizan> hhiroavalon: first of all never use length x == 0, but rather (null x), since length has to traverse the whole list even if you can tell if it's empty just by looking at the first constructor
03:06:39 <mapreduce> > length [undefined, undefined, undefined]
03:06:41 <lambdabot>   3
03:07:04 <chrisdone> @src length
03:07:04 <lambdabot> Source not found. I am sorry.
03:07:12 <chrisdone> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
03:07:14 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/23ncyu
03:07:18 <chrisdone> len []     a# = I# a#
03:07:19 <hhiroavalon> Saizan: okay, got that
03:08:36 <chrisdone> oh, I see
03:08:38 <Saizan> hhiroavalon: for the rest it looks ok to me, even if there are some corner cases like [] or [[]]
03:09:16 <Saizan> chrisdone: the wasted work occurs when it's _not_ empty :)
03:11:02 <hhiroavalon> Gimme a second while I alter my code.....
03:11:25 <Xenoblitz> Guys... say i have a state monad of type State MyState Bool and I wish to have a function do_nothing of this type, which does as its name implies, nothing... would it be enough to write do_nothing = do return True... is this the right way to do it?
03:12:28 <Xenoblitz> i know this is a silly question but I'm still not 100% on the inner workings of monads...
03:12:57 <Saizan> Xenoblitz: you don't need the "do", and return is guaranteed to not have side-effects, so that action will simply return True ;)
03:13:20 <Botje> return () would be _REALLY_ doing nothing
03:13:23 <Xenoblitz> is MyState passed untouched that way?
03:13:28 <Botje> yes
03:13:30 <Saizan> yeah
03:13:37 <Xenoblitz> thanks for the clarification
03:13:54 <Xenoblitz> Botje: i kind of need it to be True
03:14:06 <Xenoblitz> Botje: but yes i get what you mean :)
03:14:13 <Botje> sure, return true is fine :p
03:14:48 <hhiroavalon> I've changed my code: http://hpaste.org/11036 It seems to be working fine :)
03:15:49 <Saizan> nice :)
03:24:15 <hhiroavalon> one more question please
03:27:37 <hhiroavalon> I have this hsew, which would "sew" together 2 subquilts into one horizontally. http://hpaste.org/11037
03:29:02 <hhiroavalon> I am guessing there is something more simpler that I can do for this function, since this function would only accept [[[a]]] -> [[a]]
03:29:27 <Xenoblitz> i think there is a function but i can't for the hell of me remember
03:29:49 <Xenoblitz> it would take the first of both lists, combine them, the second of both lists and combine them and so on
03:30:32 <Xenoblitz> something along the lines of zip?
03:31:02 <Xenoblitz> http://www.zvon.org/other/haskell/Outputprelude/zip_f.html maybe?
03:31:03 <lambdabot> Title: Haskell : zip
03:31:28 <quicksilver> > zipWith (++) [["/+","\\^"],["><","^v"]]
03:31:29 <lambdabot>       Overlapping instances for Show ([[[Char]]] -> [[[Char]]])
03:31:29 <lambdabot>        arisin...
03:31:41 <quicksilver> > zipWith (++) ["/+","\\^"] ["><","^v"]
03:31:42 <lambdabot>   ["/+><","\\^^v"]
03:31:50 <quicksilver> but that's only binary
03:31:56 <quicksilver> I assume you want it n-ary, hhiroavalon ?
03:32:14 <hhiroavalon> yeah, I would want it as an n-array
03:32:43 <Xenoblitz> is it possible to use zipWith and a foldr perhaps quicksilver?
03:32:43 <quicksilver> > foldr1 (zipWith (++)) [["/+","\\^"],["><","^v"],["!","?"]]]
03:32:44 <lambdabot>   mueval: Prelude.read: no parse
03:32:50 <quicksilver> yes.
03:32:57 <Xenoblitz> :D i IS learning xD
03:32:58 <Xenoblitz> lol
03:33:00 <quicksilver> but apparently not possible for me :)
03:33:16 <quicksilver> > foldr1 (zipWith (++)) [["/+","\\^"],["><","^v"],["!","?"]]
03:33:17 <lambdabot>   ["/+><!","\\^^v?"]
03:33:25 <quicksilver> hhiroavalon: is that what you would want?
03:33:26 <Botje> am i in #perl?
03:33:38 <quicksilver> but it will behave oddly on lists of unequal length
03:33:45 <quicksilver> I'm not sure what invariants your quilts have.
03:33:47 <hhiroavalon> gimme a sec
03:34:16 <hhiroavalon> yeah, this is what I wanted
03:34:23 * quicksilver nods
03:34:24 <hhiroavalon> thank you so much guys :)
03:34:27 <quicksilver> well the problem with zipWith
03:34:34 <quicksilver> is it cuts off at the shortest list
03:34:46 <quicksilver> so it's only appropriate if all lists are guaranteed same length
03:34:51 <quicksilver> (well, or if cutting-off is what you want!)
03:35:30 <hhiroavalon> basically, I would be making a "quilt" using these bits and pieces, so I think they would be all the same length
03:45:34 <nomeata> Hi. Is jcpetruzza sometimes here?
03:53:30 <waern> what's the general strategy to use when you want to fully evaluate something? Derive some DeepSeq class for all data types?
03:55:05 <hugo__> waern: use another language ? :P
03:57:26 <codacola> hello one and all
03:57:33 <codacola> in need of help....again :P
03:57:53 <int-e> waern: Control.Parallel.Strategies.rnf is the new deepSeq. (It involves a type class, NFData)
03:58:22 <codacola> holy hell this channels gotten big
03:58:30 <int-e> @users
03:58:31 <lambdabot> Maximum users seen in #haskell: 540, currently: 488 (90.4%), active: 16 (3.3%)
03:58:42 <Eridius> let's bump that active number
03:58:58 <codacola> anyways, http://pastebin.com/m5944e145 <- thats what ive got, and im confused about the error.
03:59:00 <Eridius> lambdabot: how do you measure active? at least one message sent in the last x minutes?
03:59:19 <codacola> http://pastebin.com/m501b5d63 <- the error
04:00:35 <waern> int-e: right
04:01:07 <int-e> Eridius: 30 minutes apparently.
04:01:23 <pjdelport> @hpaste
04:01:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:01:34 <pjdelport> codacola: you probably want to use that, by the way
04:01:41 <int-e> Eridius: (code: http://code.haskell.org/lambdabot/Plugin/Seen.hs)
04:01:54 <dmwit_> codacola: What is the type of distance (depth x) on the RHS of levels?
04:02:55 <codacola> as far as i know it should give a Tree a -> Int function, given the x is the first argument of the function...
04:03:27 <dmwit> codacola: Right.  And what is the type of x?
04:03:29 <Eridius_> ugh, I hate it when my computer does that
04:03:57 <codacola> tree a
04:03:59 <Eridius_> from dmwit's message I assume you're being helped, codacola?
04:04:09 <codacola> yup
04:04:12 <Eridius_> ok
04:04:31 <dmwit> codacola: Now, unify for me: mapTree (something :: Tree a -> Int) (Tree b).
04:04:38 <dmwit> What type is b, in terms of a?
04:04:59 <codacola> the same
04:05:04 <dmwit> try again ;-)
04:05:06 <codacola> oh wait
04:05:34 <codacola> now im confused
04:06:06 <hhiroavalon> I have yet another question, this time complicated... and long X(
04:06:47 <dmwit> codacola: Take your time.  This could very well be the start of a lightbulb moment. =)
04:07:04 <Eridius> come on dmwit, don't encourage him! We don't need another competent programmer in this world! :P
04:10:20 <codacola> dmwit: hm, so far seems no (ive been using prolog all day so that might have screwed with my mind a tad)
04:10:46 <dmwit> codacola: Okay.
04:10:59 <dmwit> codacola: We're missing one type above, so let's grab that while we're fresh.
04:11:05 <dmwit> codacola: What's the type of mapTree?
04:11:23 <codacola> mapTree :: (a -> b) -> Tree a -> Tree b
04:11:27 <dmwit> great
04:11:41 <dmwit> So, using all different type variables to begin with, we have:
04:12:06 <hhiroavalon> I have this whole source code, but the problem is happening at line 125. http://hpaste.org/11038
04:12:08 <dmwit> (foo :: (a -> b) -> Tree a -> Tree b) (bar :: Tree c -> Int) (baz :: Tree d).
04:12:13 <dmwit> codacola: Good so far?
04:12:54 <codacola> think so
04:13:29 <dmwit> codacola: We also have unification equations; these say that the arguments to a function have to match the type of the function.
04:14:29 <dmwit> So, we have (a -> b = Tree c -> Int) and (Tree a = Tree d).
04:15:05 <dmwit> So, what can we say?
04:15:14 <dmwit> We can say b = Int, that's the easy one.
04:15:23 <dmwit> What about a?
04:17:10 <Eridius> given that ghc seems to be the de facto compiler for haskell, for what reason do people still use hugs?
04:17:17 <dmwit> hhiroavalon: What's the problem, and which line is 125.
04:17:30 <rog_> what's the particular language feature name that enables existential types? i could use -fglasgow-exts, but i'd prefer to be more specific.
04:18:04 <rog_> Eridius: it's more portable?
04:18:05 <Saizan> rog_: {-# LANGUAGE ExistentialQuantification #-}
04:18:08 <Eridius> rog_: it is?
04:18:14 <dmwit> rog_: ExistentialQuanti...yeah
04:18:28 <rog_> Saizan: ta
04:18:37 <hhiroavalon> dmwit: it gives me an error whenever I want to construct a quilt. Line 125 is printquilt.  (you can number lines by checking the box on the lower part of the screen)
04:18:56 <codacola> ah think i see, im passing a "tree a" as the first "a", and then a tree a as the 2nd "a", while the first should simply be of type a, i think
04:19:13 <dmwit> codacola: Right! =)
04:19:31 <dmwit> You're getting one more layer of Tree than you want.
04:19:49 <Saizan> join!
04:21:07 <codacola> thank you
04:21:18 <int-e> hhiroavalon: give printquilt a type signature. then you'll notice that 'bquilt)
04:21:44 <int-e> hhiroavalon: that 'bquilt' is used as a function while you wanted it to be a plain value (a list of string)
04:25:46 <hhiroavalon> int-e: okay.... type error in application
04:26:55 <int-e> :t \f g x -> f . g . x
04:26:56 <lambdabot> forall c b c1 a. (c1 -> c) -> (b -> c1) -> (a -> b) -> a -> c
04:26:58 <int-e> :t \f g x -> f . g $ x
04:27:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:28:18 <rog_> Eridius: i believe so. i don't think it's a real compiler. but i'm probably mistaken. certainly i first started using hugs because it was the haskell implementation used in the book i was reading.
04:28:58 <Eridius> rog_: from what I understand, hugs is generally used for teaching, but the question is why?
04:29:39 <hhiroavalon> int-e: I guess I have to rewrite that line... <<;;;;
04:29:49 <quicksilver> Eridius: some poeople think it gives nicer error messages.
04:29:56 <quicksilver> Eridius: it is faster, in some circumstances.
04:30:38 <int-e> hhiroavalon: (vsew . (pam vlist)) . (hsew . (pam hlist) . bquilt)
04:30:54 <int-e> hmpf. where do those newlines come from ...
04:31:38 <int-e> hhiroavalon: also keep in mind that (vsew . (pam vlist)) . (hsew . (pam hlist) . bquilt) == vseq . pam vlist . hsew . pam hlist . bquilt  (because (.) is associative)
04:31:56 <int-e> hhiroavalon: maybe that makes the mistake a little more obvious.
04:32:50 <hhiroavalon> hmm... let me think
04:33:04 <rby> Hi all, anyone here recommends lenovo x300 for dev tasks? thx
04:34:08 <byorgey> rby: sure, as long as you use Haskell ;)
04:36:16 <rby> byorgey, I use haskell :) I'm just wondering if it has an acceptable performance for dev stuff
04:36:33 <quicksilver> most of my haskell dev doesn't require appreciable CPU
04:36:36 <quicksilver> it's horses for courses
04:36:50 <quicksilver> I was perfectly happy with a 800Mz G4, which is pretty slow by today's standards.
04:37:15 <quicksilver> if your work involves sequencing DNA whilst doing image recognition of live video, you probably want something faster :)
04:37:46 <byorgey> sequencing DNA... in the type system!
04:38:09 <byorgey> from now on I think I am going to add "in the type system" to the end of all my fortune cookies.
04:38:12 <hhiroavalon> :t me :)
04:38:13 <lambdabot> parse error on input `)'
04:38:16 <rby> quicksilver, thx and no AFAIK I don't sequence any DNA
04:38:45 <quicksilver> byorgey: sounds like a xkcd strip "My hobby : adding "in the type system" to the end of challenging tasks"
04:38:53 <byorgey> hehe, true =)
04:39:16 <quicksilver> byorgey: We will get humans to the moon, in the type system! We will build a grand unified theory of everything, in the type system!
04:39:19 <SamB_XP> hehehehe
04:39:47 <hhiroavalon> int-e: I'm stuck....
04:40:28 <hhiroavalon> int-e: I know that pam hlist . bquilt can't be legal becase bquilt is not a function
04:42:20 <int-e> hhiroavalon: you need to apply the chain of functions to the value. for example, you can write (vseq . pam vlist . hsew . pam hlist) bquilt
04:42:25 <Cale> hhiroavalon: are you the same, or a different person from bbs ?
04:42:37 <int-e> hhiroavalon: or  vseq . pam vlist . hsew . pam hlist $ bquilt
04:42:40 <hhiroavalon> Cale: which BBS?
04:43:09 <Cale> hhiroavalon: I'm guessing no, then. The user bbs here seems to be working on the same assignment :)
04:43:14 <int-e> hhiroavalon: or you can drop the 'bquilt' argument from printquilt:  printquilt vlist hlist = vseq . pam vlist . hsew . pam hlist
04:43:19 <Cale> Or was... I think he went to bed.
04:43:57 <int-e> hhiroavalon: but the important thing to realize is when you need function composition (.) and when function application. And types help a lot in that regard.
04:44:23 <MyCatVerbs> Is reallyUnsafePtrEquality# at least applicable for CAFs?
04:44:24 <SamB_XP> hhiroavalon: 555-1234
04:44:48 <quicksilver> MyCatVerbs: should be pretty safe at identifying the 'same' CAF, I think.
04:45:56 <MyCatVerbs> quicksilver: jah, I would've guessed since they're just about the most stable pointers I can get ahold of in a Haskell program. Just wondering if anyone who knew GHC's guts more intimately might yell "don't do that!", really. ^^
04:46:12 <int-e> hmm, do CAFs ever get inlined?
04:46:26 <MyCatVerbs> int-e: all the time. Er...
04:46:44 <quicksilver> yes, they definitely do.
04:46:55 <hhiroavalon> int-e: thanks, however, it's not quite working how its supposed to be
04:47:05 <MyCatVerbs> But I'm using it for an Eq instance where the datatype incorporates a function, so I think it's safe to assume they won't be inlined.
04:47:13 <hhiroavalon> SamB_XP: er.. what are those numbers?
04:47:25 <SamB_XP> fake telephone number ;-p
04:48:19 <quicksilver> MyCatVerbs: I think you may be walking down the pathway of sin!
04:48:39 <Cale> MyCatVerbs: Er, I don't think that reallyUnsafePtrEquality# is even guaranteed to give consistent results. Garbage collections can move things around and copy them.
04:49:04 <Cale> It's exactly the sort of thing you would never want to put in an Eq instance.
04:49:14 <MyCatVerbs> Cale: :)
04:49:47 <MyCatVerbs> Cale: the definition looks like Data Prob a = ... | Going Double a (a -> Prob a).
04:50:04 <SamB_XP> Cale: at least not except as a shortcut ...
04:50:30 <quicksilver> SamB_XP: it's technically possible for it to give a false positive
04:50:36 <quicksilver> although I imagine that's pretty unlikely.
04:50:38 <SamB_XP> quicksilver: what the HECK
04:50:40 <SamB_XP> ???
04:50:42 <SamB_XP> how?
04:50:44 <MyCatVerbs> Cale: the instance uses unsafe pointer equality for the last bit because I presume that people will use top-level functions for that.
04:51:07 <Saizan> maybe System.Mem.StableName is more appropriate? you can still get false negatives though
04:51:11 <Cale> mm... I would just not even try to compare the functions.
04:51:14 <MyCatVerbs> Cale: plus I have Doubles in there that get compared for equality, so it's very nearly useless anyway. I just want x == x to be true. :)
04:51:31 <Cale> Why is that important?
04:51:50 <Cale> (What are you using the instance of Eq for?)
04:51:51 <MyCatVerbs> It isn't. It's just nice.
04:52:03 <Beelsebob> MyCatVerbs: you're doin it rong -- using equality on doubles is a really really bad plan
04:52:05 <MyCatVerbs> Bugger all, really. Just so that I can have Ord defined.
04:52:07 <Cale> It's probably nicer just to say that it's impossible to compare them.
04:52:17 <MyCatVerbs> Beelsebob: I know, I already mentioned that. :P
04:52:18 * SamB_XP nearly attempts to eat his oatmeal with a fork
04:52:26 <Cale> You can totally order them when you can't compare them for equality?
04:52:42 * Beelsebob atempts to eat SamB_XP with a rusty spoon
04:53:00 <MyCatVerbs> Cale: yes. (That happens all the time with floating point, no?)
04:53:01 <int-e> quicksilver: uhm, how'd you get false positives?
04:53:08 <MyCatVerbs> Cale: though I order them by probability alone.
04:53:21 <Cale> MyCatVerbs: The Eq instance should agree with the Ord instance.
04:53:44 <hhiroavalon> now that i got it to work, I have a new problem... :(  http://hpaste.org/11038#a2
04:53:45 <Cale> That is, you should have x == y exactly when compare x y = EQ
04:55:05 <MyCatVerbs> Cale: jah, true 'dat.
04:56:30 <MyCatVerbs> Actually, come to think of it.
04:56:41 * MyCatVerbs throws the instances away and uses sortBy instead.
04:56:59 <quicksilver> SamB,int-e: the GC moving both objects after you have checked one
04:57:12 <quicksilver> such that the second object now occupies the address previously occupied by the first.
04:57:16 <SamB_XP> quicksilver: is that even possible ?
04:57:23 <quicksilver> I can't see a strong reason why not.
04:57:33 <quicksilver> it's obviously vanishingly unlikely.
04:57:35 <int-e> quicksilver: that can't happen unless the RTS is broken. The pointers that a primop works with must remain valid for reading throughout its execution.
04:57:41 <SamB_XP> well ... the GC isn't invoked premptively
04:57:48 <SamB_XP> er. +e
04:58:00 <MyCatVerbs> The GC is only invoked when you try to allocate memory, right?
04:58:06 <quicksilver> int-e: hmm, is that so?
04:58:16 <SamB_XP> or specifically invoke it
04:58:19 <SamB_XP> whichever
04:58:24 <quicksilver> then it's safe, yes.
04:58:29 <MyCatVerbs> But the task switcher could preempt you, and whichever thread has been switched to could cause a GC run.
04:58:47 <SamB_XP> hmm.
04:58:50 <int-e> MyCatVerbs: which will wait for the other threads before starting the GC
04:58:50 <hackage> Uploaded to hackage: cpphs 1.6
04:59:02 <SamB_XP> doesn't that only happen on allocation too ?
04:59:02 <MyCatVerbs> int-e: I didn't know that last bit. ^^
04:59:13 <MyCatVerbs> SamB_XP: yeah, but the other thread could be consing like Hell.
04:59:25 <SamB_XP> no, I meant task switching ;-)
05:00:35 <int-e> SamB_XP: in the parallel RTS you have several OS threads running in parallel
05:01:09 <MyCatVerbs> SamB_XP: oh right. I think the answer is "yes" for the non-threaded (cooperatively-multitasking) RTS, but maybe "yes" for the threaded RTS, because IIRC that one is properly preemptive.
05:01:22 <Saizan> GHC implements pre-emptive multitasking: the execution of threads are interleaved in a random fashion. More specifically, a thread may be pre-empted whenever it allocates some memory, which unfortunately means that tight loops which do no allocation tend to lock out other threads (this only seems to happen with pathological benchmark-style code, however).
05:01:37 <quicksilver> that's the non-threaded RTS.
05:01:46 <SamB_XP> Saizan: less and less true, that last bit
05:01:58 <quicksilver> the threaded RTS has real threads which can be pre-empted at *any* time, not just in memory allocation
05:02:02 <quicksilver> because that's up to the OS.
05:02:04 <SamB_XP> dons and dcoutts seem to have a habbit of writing that style of code ;-P
05:02:14 <quicksilver> However, all threads get their ducks in a row before a GC.
05:02:15 <int-e> MyCatVerbs: as far as I know, the latest story is that the worker threads synchronize before starting a gc, then do a parallelized gc, and then resum their work.
05:02:28 <quicksilver> so the GC will only happen at a safe point
05:02:32 <quicksilver> (memory allocation)
05:02:48 <MyCatVerbs> So you can break the whole RTS with one giant tight loop, huh.
05:03:01 <SamB_XP> it would be pretty hard to do a GC before all the threads at least get their ducks in a row
05:03:06 <int-e> MyCatVerbs: yeah :/
05:03:45 <MyCatVerbs> int-e: oh well. It's a price we pay. No different to the fact that you can effectively break your CPU by iterating down columns instead of along rows.
05:03:55 <SamB_XP> eh ?
05:03:59 <SamB_XP> break your CPU ?
05:04:06 <int-e> yay, flooding cache lines.
05:04:26 <MyCatVerbs> SamB_XP: make the cache useless, for sufficiently large data sets.
05:04:36 <MyCatVerbs> SamB_XP: anything over a few kilobytes, make the L1 cache useless.
05:04:52 <MyCatVerbs> SamB_XP: anything over a number of megabytes, make the L2 cache useless. 
05:04:55 <SamB_XP> I was going to say, I didn't think that CPUs were made so badly that they'd fry from that
05:05:17 <MyCatVerbs> SamB_XP: it's extra hilarious because if you're using tiny test images, you'll barely notice the performance hit.
05:05:42 <nornagon> So, the other day I got some Embedded ML compiler to generate C code that I could compile for the Nintendo DS (an arm-eabi system)... can GHC do that? :)
05:06:05 <int-e> @faq
05:06:06 <lambdabot> The answer is: Yes! Haskell can do that.
05:06:16 <SamB_XP> int-e: but WHEN?
05:06:27 <int-e> SamB_XP: I have no clue :)
05:06:30 <nornagon> Apparently jhc can do it.
05:06:34 <nornagon> But that wasn't my question ;)
05:07:08 <Saizan> nhc too, i seem to recall
05:11:53 <hhiroavalon> ...anyway thanks so much for the assistance
05:12:02 <hhiroavalon> I think I'll try what I can do from this point
05:14:41 <nornagon> Hm, jhc's HEAD is a bit uncompileable.
05:14:53 <SamB_XP> hehehe
05:17:22 <nornagon> aha. Got it by using -j1 and installing fgl...
05:17:33 <nornagon> but it also had a whole bunch of other undeclared dependencies.
05:25:41 <romildo> Hi.
05:26:37 <romildo> I have installed ghc 6.10.1 rc 1 from the haskell overlay on my gentoo ~x86 system. But ghc-updater fails to update the packages.
05:26:39 <romildo> For instance, I m getting the error message: /var/tmp/portage/dev-haskell/filepath-1.1.0.0/temp/environment: line 1094: /usr/lib/ghc-6.10.0.20081007/./ghc-pkg.bin: No such file or directory
05:26:45 <romildo> Any clues?
05:52:07 <eipi> would anyone know why I can see the regex-posix-0.72.0.2 among ghc package (using ghc-pkg) but install of lhs2tex with cabal fails because of dependency with this package?
05:52:24 <besiria> has common subexpression elimination anything to do with graph reduction?
05:53:00 <quicksilver> they relate to different phases.
05:53:15 <quicksilver> CSE is an optimisation which you can apply early, when the code is still an AST
05:53:20 <quicksilver> graph reduction is an evaluation technique.
05:54:25 <besiria> like an evaluation strategy?
05:59:36 <byorgey> besiria: right
06:10:55 <quicksilver> besiria: well, it's not so much a strategy as an implementation.
06:39:45 <roconnor> @src manyTill
06:39:46 <lambdabot> Source not found. My mind is going. I can feel it.
06:40:13 <roconnor> @src Text.ParserCombinators.Parsec.manyTill
06:40:13 <lambdabot> Source not found. My pet ferret can type better than you!
06:40:35 <quicksilver> @src doesn't have parsec.
06:40:35 <lambdabot> Source not found. Just try something else.
06:40:38 <quicksilver> ;)
06:41:17 <quicksilver> roconnor: the webternets has it, though
06:41:17 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html
06:41:19 <lambdabot> Title: Text.ParserCombinators.Parsec.Combinator, http://tinyurl.com/2zehtb
06:44:46 <roconnor> I want manyTill, but I want to get what was at the end, not the list of of the manys :)
06:46:15 <quicksilver> roconnor: well, the source of manyTill is at that link,that's why I said it ;)
06:50:15 <roconnor> quicksilver: thanks
06:50:41 <roconnor> ugh
06:50:44 <roconnor> so many trys
06:50:48 <roconnor> @hoogle try
06:50:48 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
06:50:48 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
06:50:48 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
06:51:25 * roconnor sprinkles hidings
06:53:17 <romildo> ghc-pkg does not accept the option -u on ghc 6.10 rc1. This option is used when emerging ghc packages on gentoo. What does this option mean?
06:54:55 <romildo> "ghc-pkg --help" does not mention -u.
06:55:41 <quicksilver> romildo: I'm not ignoring you per se, but I don't know.
06:55:45 <quicksilver> I wonder who does.
06:55:51 <quicksilver> lambdabot: summon dcoutts
06:55:55 <quicksilver> bah
06:55:58 <quicksilver> dcoutts_: about?
07:07:51 <roconnor> @src groupBy
07:07:51 <lambdabot> groupBy _  []       =  []
07:07:51 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:07:51 <lambdabot>     where (ys,zs) = span (eq x) xs
07:10:28 <MyCatVerbs> :74
07:10:35 <MyCatVerbs> Wrong window, sorry.
07:10:56 <smtms> what does :74 do in the right window? :-)
07:11:16 <shepheb> #xmonad has a spammer, if someone with \bot admin wants to help out
07:11:45 <shepheb> smtms: focuses line 74 in vi(m)
07:12:03 <roconnor> @hoogle Either a b -> b
07:12:03 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
07:12:04 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
07:12:04 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
07:12:43 <kohwj> greetings
07:13:42 <roconnor> @hoogle ParseError
07:13:42 <lambdabot> Text.Parsec data ParseError
07:13:42 <lambdabot> Text.Parsec.Error data ParseError
07:13:42 <lambdabot> Text.ParserCombinators.Parsec data ParseError
07:15:30 <byorgey> greetings kohwj
07:22:42 <gbacon> ?pl \x -> x * x
07:22:42 <lambdabot> join (*)
07:24:27 <gbacon> > (join (*)) 3
07:24:28 <EvilTerran> gbacon, i suggest (^2)
07:24:28 <lambdabot>   9
07:24:37 <EvilTerran> > (^2) 3
07:24:38 <lambdabot>   9
07:24:59 <EvilTerran> like it's nicer to write (*2) instead of join(+)
07:26:01 <gbacon> ghci doesn't like join (*)
07:26:07 <gbacon> complains about a missing Monad instance
07:26:13 <mauke> gbacon: :m + Control.Monad.Instances
07:26:25 <gbacon> mauke: makes sense :-)
07:27:04 <gbacon> ?src join
07:27:05 <lambdabot> join x =  x >>= id
07:27:06 <geezusfreeek> i don't get why those are there instead of just in Control.Monad
07:27:27 <Deewiant> so that stuff which doesn't need them doesn't leak unwanted instances, I guess
07:27:48 <quicksilver> some people thought that the instances for (->) and (,) shouldn't be visibel by default
07:27:50 <quicksilver> I have no idea why not.
07:28:04 <EvilTerran> geezusfreeek, because they define instances for a lot of common types, it can produce some very odd error messages if you typo with those instances in scope
07:28:06 <quicksilver> perhaps because it leads to weird error messages?
07:28:20 <geezusfreeek> oh i see
07:29:13 <geezusfreeek> hmm. i don't know how much that would bother me. it would only throw off newbies
07:29:40 <EvilTerran> yeah
07:29:53 <EvilTerran> so newbies will naturally avoid that module with the long scarey name
07:29:58 <EvilTerran> and pro's can use it
07:29:58 <geezusfreeek> heh
07:30:48 <DustyDingo> hi, just starting haskell
07:31:02 <DustyDingo> is there a way to convert a bool to an integer?
07:31:09 <Baughn> > fromEnum True
07:31:11 <lambdabot>   1
07:31:15 <EvilTerran> ?src Bool fromEnum
07:31:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:31:21 <Baughn> > fromEnum 'a'
07:31:22 <lambdabot>   97
07:31:42 <Baughn> > toEnum 97 :: Char -- Rather useful little class, really
07:31:42 <EvilTerran> i presume the src of that would be "deriving Enum", actually
07:31:43 <lambdabot>   'a'
07:32:11 <mauke> data BOOL = True | False | FileNotFound
07:32:16 <EvilTerran> "data Bool = False | True deriving (Read, Show, Eq, Ord, Bounded, Enum)"
07:32:22 <quicksilver> DustyDingo: if p then 42 else 94
07:32:31 <quicksilver> DustyDingo: is the generic way to convert a bool to an integer :)
07:32:33 <idnar> data BOOL = True | False | FileNotFound | Null
07:32:49 <Deewiant> geezusfreeek: the H98 libraries have to care about it more since they shouldn't make any non-H98 code compile
07:33:11 <Deewiant> so Monad can import Control.Monad but not Control.Monad.Instances, for instance, or something.
07:35:32 <EvilTerran> quicksilver, ah, you mean (|94,42|) :P
07:36:02 * EvilTerran would quite like bananas/barbed-wire syntactic sugar; it'd be possible with appropriate typeclasses
07:36:12 <idnar> bananas?
07:36:19 <EvilTerran> or, with no sugar, "cata (94,42) (x :: Bool)" could be made to work
07:38:29 <EvilTerran> with the MPTC "class Cata res fns typ | typ res -> fns where cata :: typ -> fns -> res" and "instance Cata a (a,a) Bool where ...", "instance Cata b (a -> b -> b, b) [a] where cata = uncurry foldr" etc
07:39:04 <EvilTerran> idnar, http://dbappl.cs.utwente.nl/Publications/PaperStore/db-utwente-40501F46.ps
07:39:05 <geezusfreeek> EvilTerran, have you looked at the fixpoint package? it might be close
07:39:08 <lambdabot> http://tinyurl.com/4ahsy9
07:41:56 <guenni> what solutions for Haskell are there when in-Memory handling no longer is feasable? (My app uses 250+ MB RAM right now)
07:42:23 <quicksilver> that sounds quite feasible.
07:42:46 <geezusfreeek> unless you only have 256 MB
07:42:55 <geezusfreeek> but then you're just screwed ;)
07:43:14 <quicksilver> it costs less to buy 2G of memory than to type a question on IRC and get an answer :P
07:43:18 <mauke>   
07:43:32 <guenni> quicksilver: I wish, but the app is still in the middle of dev and is using sofar only a 1/4 of the data it needs, so this will go up
07:43:39 <Baughn> quicksilver: ...you just killed my terminal.
07:44:02 <quicksilver> guenni: understood.
07:44:08 <quicksilver> Baughn: how?
07:44:15 <Asztal^_^> heheh, I don't think it was quicksilver.
07:44:23 <geezusfreeek> Baughn, do you mean whatever mauke did?
07:44:29 <Baughn> ..mauke spoke?
07:44:30 <idnar> get a better terminal
07:44:36 <geezusfreeek> Baughn, right after quicksilver
07:44:42 <idnar> one that does UTF-8
07:44:44 <Baughn> I see. That's him, then.
07:44:54 <quicksilver> guenni: anyhow, the answer to your first question is "the same solutions you have with any other language"
07:44:55 * geezusfreeek is using xchat on windows and it doesn't show them :
07:45:06 <quicksilver> guenni: store the data in a file, load it in on demand in some suitable fashion.
07:45:06 <Baughn> Mine does utf-8 just fine, but somewhere between Terminal, screen and irssi, double-width fonts get mangled
07:45:30 <quicksilver> use an specific DB server if that's a good solutionf or your problem space.
07:45:30 <guenni> quicksilver: understood
07:45:45 <Spark> xterm has the best unicode implementation i've seen so far
07:45:48 <Baughn> guenni: If you want GHC to handle working from swap better, turning on (or off) the compacting collector might help. Or not.
07:45:59 <guenni> quicksilver: I see a choice of mySql or sqllite
07:46:05 <Spark> you have to do some pretty hardcore stuff to separate rxvt and xterm though iircv
07:46:10 <Spark> *iirc
07:46:18 <Baughn> Of course no language really likes having to use swap, so ghc is hardly unique in that
07:47:19 <Baughn> guenni: Oh, and with sufficient use of unsafePerformIO, weak references, and clever coding you could implement a transparent LRU scheme for your data. Not that I'd recommend that. :P
07:48:34 <Spark> if you want low level then use a low level language
07:48:40 <Spark> or bind out to one
07:48:59 <guenni> Baughn: you could just have told me that I'm screwed :)
07:49:21 <Baughn> guenni: There are also a number of database libraries. ;)
07:49:35 <Baughn> guenni: Seriously, you have exactly the same options as in any /other/ language
07:49:52 <Baughn> By far the simplest and chepest of which is "get more ram". It's cheap.
07:50:09 <Baughn> You could also consider than regenerating data is often faster on modern CPUs than reading it from disk.
07:50:32 <guenni> Baughn: yep, thx
07:56:23 <idnar> EvilTerran: bleh, I can't follow the math
07:56:31 <idnar> or, well, I guess the notation is my problem
08:18:24 <RayNbow> hmm, anyone available who's good at probability stuff? (Poisson variables)
08:21:08 <dcoutts> chrisdone: file a feature request in the hackage trac, ask for a way to specify list of packages not to update ever, to always pick the installed versions
08:24:41 * RayNbow looks puzzled at http://img363.imageshack.us/img363/4923/poissonkd3.png
08:31:02 <byorgey> RayNbow: if l <= M, then cl - u_s' is <= 0
08:31:38 <byorgey> so the probability that P_1 is >= cl - u_s' is 1, since Poisson variables can only take on positive values.
08:32:12 <byorgey> so for l between 0 and M, that sum just becomes: sum_{l=0}^M P(P_2 = l), which is P(P_2 <= M)
08:33:50 <byorgey> and since P_1 and P_2 are independent, you can also drop the dependency  | P_2 = l  in the part that's left
08:36:03 <byorgey> I'm pretty sure I did that right... does that make sense?
08:36:20 <byorgey> oh, I should have said "nonnegative" instead of "positive values"
08:36:45 <osfameron> positive sounds less pretentious :-)
08:36:49 <vincenz> erm
08:37:01 <vincenz> isn't it strictly positive vs positive?
08:37:59 <RayNbow> byorgey: ah... thanks a lot! :)
08:38:02 <RayNbow> @karma byorgey
08:38:02 <lambdabot> byorgey has a karma of 5
08:38:06 <RayNbow> byorgey++
08:38:10 <RayNbow> @karma byorgey
08:38:10 <lambdabot> byorgey has a karma of 6
08:38:26 <mauke> preflex: karma byorgey
08:38:26 <preflex>  karma for byorgey: 27
08:38:31 <mauke> NEVAR FORGET
08:38:44 <byorgey> woah!
08:38:58 <byorgey> did you go through the logs looking for karma commands, or what?
08:39:02 <mauke> no
08:39:31 <byorgey> RayNbow: you're welcome =)
08:39:37 <mauke> preflex just records the usual ++ commands, like lambdabot
08:39:44 <byorgey> oh, I see =)
08:40:09 <mauke> but preflex never loses state
08:40:13 <byorgey> nice
09:18:50 * BMeph goes to find a copy of "Strictly Ballroom" to play while reading papers on Poisson distributions
09:22:47 <geezusfreeek> @karma geezusfreeek
09:22:47 <lambdabot> You have a karma of 0
09:22:50 <geezusfreeek> aw :(
09:23:00 <leimy> @karma leimy
09:23:00 <geezusfreeek> wait, i know somebody has given me karma before!
09:23:01 <lambdabot> You have a karma of 0
09:23:04 <leimy> WOOT!
09:23:07 <geezusfreeek> two people at least
09:23:10 <leimy> even steven
09:23:34 <quicksilver> geezusfreeek: lambdabot keeps losing state
09:23:36 <quicksilver> it's very saddening.
09:23:47 <quicksilver> lambdabot needs a maintainer with more time to spend on it.
09:27:04 <hugo__> hmm
09:27:21 <hugo__> it would be good if the Data module could convert between UNIX time :/
09:29:51 <quicksilver> you mean epoch, expressed as seconds?
09:30:15 <quicksilver> it can
09:30:16 <quicksilver> posixSecondsToUTCTime :: POSIXTime -> UTCTime
09:31:26 <lilac> preflex: karma lilac
09:31:27 <preflex>  karma for lilac: 1
09:31:30 <lilac> \o/
09:31:39 <Olathe> preflex: karma Olathe
09:31:39 <preflex>  Olathe has no karma
09:32:03 <Olathe> Karma doesn't exist for me.
09:33:27 <niklaus> if we consider primitive and non primitive pythagorean triplet, how do we generate nth triplet, well i don't find the nth triplet if we sort by c, i know the generator for primitives,scaling the primitives to find the nth is time consuming
09:35:50 <lilac> niklaus: nth in which ordering?
09:36:57 <niklaus> lilac, hypotenuse (c first , then a ,b )
09:37:07 <niklaus> lilac, a<b
09:38:39 <niklaus> lilac, if we bound n < 10^6 any thing ?
09:40:54 <QuietPurple> hey, i would like to construct a data type ([Int],Int). could anyone possibly show me how?
09:41:20 <wjt> > ([4,7], 5) :: ([Int], Int)
09:41:21 <lambdabot>   ([4,7],5)
09:41:47 <QuietPurple> so i needn't actually define the type... ok
09:43:41 <Olathe> @let tripleLists = map (\m -> map (\n -> (m^2 + n^2, m, n)) [m + 1..]) [1..]
09:43:42 <lambdabot>  Defined.
09:49:17 <glguy> hi
09:52:07 <sw17ch> QuietPurple, you mean like ... data T = T [Int] Int
09:52:08 <sw17ch> ?
09:52:45 <QuietPurple> i'm not sure. its working now if i just use (Int,[Int])
09:58:51 <hackage> Uploaded to hackage: http-shed 0.1
10:01:32 <niklaus> Olathe, this is just scaling right ?
10:12:42 <zachk> ok so i am trying to replace this: loop st    = catch (runReaderT run st) (const $ return ())          WITH this : loop st    = catch (runStateT run st) (const $ return ()) and loop goes into bracket in the io monad
10:13:25 <zachk> where am i going wrong?
10:15:43 <ptolomy2> My 'cabal install's are failing with "Cannot find module 'Distribution.Simple'".. isn't that module built-in?
10:17:25 <dons> ptolomy2: that's part of Cabal.
10:17:28 <dons> so I wonder.
10:20:03 <ptolomy2> Perhaps I need to upgrade or re-install my cabal..
10:20:34 <EnderMB> Hey all
10:20:37 <ptolomy2> *_*  "cabal install cabal-install" -> all sorts of action.
10:21:00 <mauke> cabal upgrade cabal-install -- even better
10:21:00 <EnderMB> Has anyone read the online version of Real World Haskell, and if so, would they recommend it above other books?
10:22:02 <dcoutts> mauke: it's not obviously better, it depends what one wants to do
10:22:21 <mauke> where "better" = even more action!
10:22:58 <ptolomy2> aurhg. Still can't find Distribution.Simple.
10:23:04 <dons> EnderMB: I'd recommend it over other books, if you're a competent programmer already.
10:23:14 <dons> might be biased though, but I think that's the general opinion
10:23:31 <dcoutts> ptolomy2: so ghc-pkg list Cabal says there are no versions of the Cabal lib installed at all?
10:23:46 <vinicius> disclaimer: dons is one of the authors. =)
10:24:01 <ptolomy2> dcoutts: 3 versions.
10:24:15 <EnderMB> Well I wouldn't really call myself competent. I can do some basic Java and C, but HTML was always my main area of expertise
10:24:42 <dcoutts> ptolomy2: so what are you actually doing? this isn't ghci or ghc --make, I'm guessing you're building a package but missing a build-depends on Cabal ?
10:24:47 <Olathe> > let merge xxs@(x:xs) yys@(y:ys) = if x <= y then x:merge xs yys else y:merge xxs ys in take 1 $ foldl1 merge $ map (\n -> [n..]) [1..]
10:25:21 <lament> i don't think there's a really good newbie haskell book
10:25:23 <Olathe> Why doesn't that work ?
10:25:37 <lament> "Haskell for HTML programmers"
10:25:40 <ptolomy2> dcoutts: I wanted to try out Yi, so I ran 'cabal install yi'. fingertree-0.0 and regex-base both don't build, failing with "Could not find module 'Distribution.Simple'". Other packages built fine.
10:26:15 <zachk> howdy doody i figured out my own questions, boy is ghci nice :D
10:26:28 <dcoutts> ptolomy2: perhaps one of your cabal lib instances, while registered is borked
10:26:38 <dcoutts> ptolomy2: so the ones that pick that version fail
10:26:45 <dcoutts> ptolomy2: it's hard to guess without more details
10:27:24 <dons> EnderMB: hmm. if you're just picking up general programming, "Programming in Haskell" might be a good start
10:27:28 <dons> hard to say
10:27:54 <zachk> my copy awaits me at borders
10:28:12 <EnderMB> Well, I've got the basics down in Java and C, but I'm a student that's looking to expand to other paradigms, so my knowledge is limited
10:28:25 <zachk> haskell is mind expanding
10:28:30 <EnderMB> Just looking for a new way of doing things really
10:28:52 <mauke> why not write programs in the whitespaceless subset of C?
10:29:34 <lament> at least it's C and not C/C++
10:29:47 <EnderMB> I knew someone would say that
10:29:56 <mauke> preflex: karma C/C
10:29:56 <preflex>  karma for C/C: 933
10:30:22 <lilac> zachk: loop st = catch (runStateT run st >> return ()) (const $ return ())
10:30:39 <EnderMB> To be honest, I thought that if I learn a number of paradigms then my overall programming ability would grow
10:30:41 <lilac> zachk: runStateT returns (s, a) whereas runReaderT returns a
10:30:45 <zachk> lilac: i made a function to do the same thing
10:30:59 <EnderMB> I go to a 'Java School', so for me there's only really one option handed to us
10:31:15 <zachk> i have lost all interest in my java school
10:31:31 <pjdelport> EnderMB: probably look at several sources
10:31:50 <pjdelport> EnderMB: Real World Haskell, the Haskell wikibook, and whatever else seems interesting
10:32:09 <pjdelport> you don't have to read just one of them like a novel :)
10:32:24 <lilac> EnderMB, zachk: if you go to a java school and nevertheless learn haskell, then there's hope for you yet... ;)
10:32:26 <EnderMB> I've tried the Wikibooks one, I just can't read any of them
10:32:58 <EnderMB> I don't know why, but the second I read anything from Wikibooks I lose interest
10:33:03 <zachk> im pretty sick of the sophist mindset of college
10:33:49 <kowey> building books with a wide-open wiki is pretty tricky
10:33:58 * ptolomy2 misses his silly college.
10:34:30 <EnderMB> My university wouldn't have been so bad if the CS programme hadn't have been dumbed down to accommodate music tech and graphic design students taking the same modules
10:34:48 <kowey> the wikibook does have some pretty stellar articles though... (interestingly, these being modules that were written by almost entirely one or two people)
10:34:58 <kowey> and refined with typos, etc by the wider community
10:35:59 * ptolomy2 went to a university that took the approach of "Well, if it seems too hard, there's a liberal arts college right over there".
10:36:27 <lament> EnderMB: try real world haskell, or YAHT, and when something is unclear just ask here
10:36:54 <Samy> A great book too is "Haskell: The Craft of Functional Programming" by Simon Thompson
10:37:00 <Samy> EnderMB.
10:37:07 <EnderMB> Ah, I noticed that book in my library today
10:37:16 <Samy> You won't regret checking it out.
10:37:20 <EnderMB> I'll have to get it out tomorrow
10:37:45 <EnderMB> Thanks for the help guys (and girls?)
10:38:20 <Samy> We're all beautiful girls.
10:39:38 <Olathe> I'm an ugly girl :(
10:39:41 <samUL> > ""
10:39:44 <lambdabot>   "\3061\3064\9731\9729\1284\3663\865\815\3663\64831\10004"
10:41:43 <Botje> unicode can do that?!
10:41:59 <lilac> @faq Can Haskell^Wunicode do that?
10:41:59 <lambdabot> The answer is: Yes! Haskell can do that.
10:44:55 * lispy <3 unicode
10:45:03 <Beelsebob> unicode is made of win
10:45:08 <Beelsebob> if only it was easier to type
10:45:20 * mauke  unicode
10:45:28 <lispy> keyboarding technology hasn't improved since qwerty?
10:45:34 <lispy> mauke: nice
10:45:50 * lispy is using dvorak now but from a qwerty fascade
10:46:08 <mauke> poun
10:46:11 <lament> a wolf in sheep's clothing!
10:46:11 <score> lispy: dvorak is optimized for english, no? not programming..
10:46:24 * Beelsebob ponders designing a "haskell" layout, with such exciting things as alt-letter getting you greek variants, and  bound
10:46:41 <Beelsebob> score: correct, but I find it better for programming than qwerty still
10:46:44 <lispy> score: I program in english and typing code isn't something should or need to do quickly :)
10:46:57 <lispy> s/should/I should/
10:47:16 <Beelsebob> lispy: I'm not sure that's true -- I tend to think for 20 minutes, then write 3 lines in not very long at all
10:47:18 <lilac> if you're writing code as fast as you can type, you're doing it wrong
10:47:48 <Olathe> > (.&.)
10:47:49 <lambdabot>       Ambiguous occurrence `.&.'
10:47:51 <lambdabot>      It could refer to either `Data.Bits..&....
10:47:55 <zachk> unless you did design first lilac
10:47:59 <score> lilac: or you're writing java
10:48:02 <lispy> Beelsebob: yeah, I meant to speak for myself there
10:48:07 <zachk> score: TRUE
10:48:10 <lilac> score: "doing it wrong" seems apt there
10:48:10 <dblazakis> oleg writes code faster than he can type
10:48:13 <Olathe> .&. got screwed up on lambdabot.
10:48:22 <Beelsebob> dblazakis: haha, it was inevitable that that came up
10:48:26 <mauke> @hoogle .&.
10:48:27 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
10:48:27 <lispy> dblazakis: I thought the code wrote itself in reverence
10:48:53 <Olathe> lambdabot can't determine whether it's Data.Bits or Test.Quickcheck
10:48:56 <lispy> ?quote OlegFacts
10:48:56 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
10:49:02 <dblazakis> lispy: oh, the code would, but it feels unworthy
10:49:02 <Beelsebob> in semi-seriousness -- oleg doesn't fix type errors, the type system bows to oleg's demands
10:49:11 <Beelsebob> hahahahaha
10:49:13 <Beelsebob> awesome lispy
10:49:16 <lilac> zachk: you're not continuously writing code as fast as you can type there. and you can design the next bit while your hands type in the bit you've already designed
10:49:42 <lispy> But um yeah.  Typing speed is not an issue for me.  I don't use dvork for that metric.
10:49:47 <zachk> i like paper and pen/cil
10:50:01 * lispy uses dvorak to reduce risk and symptoms of typing too much
10:50:03 <Beelsebob> lispy: indeed -- my principal reason for using dvorak is that it's good for RSI
10:50:07 <Beelsebob> heh
10:50:09 <zachk> i got off of dvorak cause i noticed a heavy programming language and unix bias towards qwerty
10:50:14 <Beelsebob> guess that's a snap
10:50:25 <score> zachk: example?
10:50:27 <lispy> ?quote contra
10:50:27 <lambdabot> edwardk says: the gf obeys a paraconsistent logic, so given a contradiction you can't actually go an really prove everything like you can in classical logic, which always makes it hard to refute a
10:50:27 <lambdabot> claim via contradiction.
10:50:27 <Beelsebob> zachk: I don't think that's true
10:50:30 <zachk> ls
10:50:33 <zachk> ;
10:50:36 <lispy> not the quote i wanted
10:50:37 <zachk> cp
10:50:41 <lispy> ?quote fugue
10:50:41 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
10:50:41 <lament> ls is a pain on dvorak; i have it aliased to 'u'
10:50:45 <dons> lispy: do you have an affiliation I should mention in the tech talk?
10:50:46 <lispy> that's the one
10:50:47 <dons> OSU or .. ?
10:50:55 <mauke> @quote trap
10:50:55 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
10:50:56 <Beelsebob> I don't find ls a pain on dvorak
10:50:57 <lilac> i think i saved more by remapping CapsLock to escape than i could from switching to dvorak :D
10:51:01 <zachk> also switching from qwerty to dvorak back and forth got annoying
10:51:21 <Beelsebob> I guess unix's "just drop the vowels from the name" thing actually is pretty anti-dvorak
10:51:27 <Beelsebob> it breaks the one letter on each hand thing
10:51:28 <lispy> dons: I tried to cover that in the bottom where it says, "Presenter:".  I'm an employee at PTV America and a graduate student at OSU.
10:51:31 <score> zachk: i feel that those would be the same even if everyone were using dvorak
10:51:48 <zachk> :q
10:51:49 <lament> 'ls' is particularly bad on dvorak
10:51:49 <zachk> oops
10:51:51 <Beelsebob> score: I don't think so -- ls would proably be li for example
10:52:15 <lament> (dvorak ls is qwerty p;)
10:52:27 <Beelsebob> either that, or it would be dir >.<
10:52:32 <Beelsebob> dir is actually pretty easy on dvorak
10:52:39 <lament> or it would be u :)
10:52:42 <Beelsebob> hehe
10:52:55 <Beelsebob> but what is u a nemonic for
10:53:05 <mauke> hmm, "database"
10:53:06 <lispy> I would agree that unix command names were chosen with qwerty in mid
10:53:06 <Beelsebob> I have to admit, I do alias l to ls -l
10:53:16 <Beelsebob> lispy: I don't think they were
10:53:17 <lament> lispy: i would not
10:53:18 <zachk> unlisting the catergorical dual of listing :-(~~~~~~<-drool
10:53:27 <Beelsebob> I think they were chosen to make them short, and a nemonic for what they were
10:53:36 <lilac> hmm. pressing between the p and ; key reliably gives me p; here -- that seems pretty easy :D
10:53:38 <Beelsebob> ls is as it is because you almost pronouce list while saying ls
10:53:40 <lament> lispy: they were just chosen without any consideration for ergonomics whatsoever
10:53:44 <dons> lispy: ok.
10:53:55 <mauke> I thought 'ls' stood for 'list shit'
10:53:59 <Beelsebob> haha
10:54:03 <lament> lilac: i suppose it's good pinky training
10:54:04 <Samy> heh
10:54:19 <lament> lilac: but consider that afterwards you have to press Enter with the same pinky
10:54:26 <lispy> dons: the downside is that PTV has nothing to do with this research, so it's a bit of a red herring to mention them :)
10:54:32 <lilac> lament: nah, Ctrl-M
10:54:39 <lament> heh
10:54:42 <Beelsebob> lament: heh, I have the very bottom left key on my kb bound to enter
10:54:42 <lilac> p;
10:54:47 <lispy> dons: Well, they fund it indirectly I guess via my paycheck
10:54:49 <dons> lispy: but they're letting you come give the talk?
10:54:49 <Beelsebob> so it's pressable with both pinkys
10:54:50 <dons> :)
10:54:51 <dons> right
10:55:38 <lispy> PTV America, unintentionally contributing to Haskell since 2006.
10:55:42 <dons> :)
10:55:59 <lispy> I wrote the bytestring version of HaXml while working on a project at PTV :)
10:56:20 <dons> oh nice. the bytestring components that are now *in* haxml?
10:56:52 <lispy> Well, I hacked up a version that solved my problems and then sent the patches to malcom, he applied them then polished them
10:57:18 <lispy> So, the current stuff is verly likely a direct derivative of my stuff but I haven't looked at it
10:58:05 <dons> cool
10:58:07 <lispy> I was also going to fix hdirect because it was buggy, but the project I was using it for was ... um...transitioned away from Haskell ;)
10:58:51 <ESphynx> hi ;)
10:58:58 <ESphynx> \o_ Samy
10:59:05 <Samy> Hi.
10:59:11 <Samy> ESphynx, so what were you saying? :-P
10:59:20 <ESphynx> well, first off I'm heavily biased :P
10:59:22 * Samy notes #haskell currently has more users than ##C.
10:59:27 <ESphynx> And i've grown up with C ;)
10:59:38 <ESphynx> I'm not saying Haskell isn't cool
10:59:45 <ESphynx> I think functional languages are cool, but they're still new :P
10:59:58 <sw17ch> ESphynx, what do you mean by 'new' :P
10:59:59 <mauke> omg lisp is new
11:00:00 <geezusfreeek> ESphynx, is this a conversation brought from another channel?
11:00:00 <Botje> eh
11:00:01 <Samy> New?
11:00:02 <Beelsebob> ESphynx: new?
11:00:03 <ESphynx> and I'm still quite stuck in procedural/OO programming :P
11:00:08 <Beelsebob> they've been around since the 70s
11:00:10 <Samy> Compared to...Java? Ruby? Python?
11:00:11 <Beelsebob> for longer than OO in fact
11:00:11 <lispy> dons: and I have to say, that project was here I first learned just how much more memory and time efficient Haskell is compared to python.  I had part of my prototype in both languages to compare.  Haskell was an order of magnitude better on my naive implementations!
11:00:14 <Samy> Perl?
11:00:16 <ESphynx> geezusfreeek Samy invited me here from #c :P
11:00:19 <geezusfreeek> aha
11:00:47 <dons> hehe
11:00:59 <mauke> preflex: be PoppaVic
11:00:59 <preflex>  ahh, so - you just toss out yer turds and based on input and get feedback, then play "confused"? Good to know.
11:01:04 <Beelsebob> ESphynx: C and Scheme are the same age
11:01:30 <lament> mauke: LOL
11:01:37 <ESphynx> Beelsebob but their number of adopters has been different :P
11:01:39 <geezusfreeek> yay a conversation to distract me from work
11:01:55 <lament> mauke: is that a markov chain or an actual quote? You can never tell!
11:01:59 <mauke> he'll feel right at home!
11:02:05 <ESphynx> but I do like some ideas of functional programming, in fact I hope to adopt some of them in my own language design :P
11:02:06 <geezusfreeek> functional programming's relative unpopularity probably is why it doesn't suck yet ;)
11:02:12 <Beelsebob> ESphynx: true, similarly, the number of adopters of windows and unix based systems has been different
11:02:25 <Samy> ESphynx, http://haskell.org/haskellwiki/Introduction
11:02:25 <Beelsebob> geezusfreeek: entirely plausable
11:02:27 <lambdabot> Title: Introduction - HaskellWiki
11:02:27 <ESphynx> Beelsebob: And i'll maintain that Windows is more productive than Unix :P
11:02:37 <lament> :P
11:02:39 <Beelsebob> ESphynx: really? I'm fairly confident I'm more productive on OS X
11:02:44 <dons> ?users
11:02:44 <lambdabot> Maximum users seen in #haskell: 540, currently: 505 (93.5%), active: 26 (5.1%)
11:02:54 <Samy> UNIX is dead. And I'm not sure what your metric for "productivity" is, ESphynx :-P (especially for an OS).
11:03:09 <mauke> also, vi or emacs?
11:03:11 <Samy> ESphynx, I suggest you look at some of the FAQ items there, "why haskell", etc...
11:03:27 <ESphynx> Samy : the amount of time doing what you're trying to do rather than doing stuff necessary to achieve what you want :P
11:03:31 <Samy> ESphynx, before using wrong reasons like "they're fairly new".
11:03:36 * sw17ch is only productive in windows when he has CygPutty and gVim
11:03:42 <Samy> ESphynx, I don't have this problem on Solaris or FreeBSD.
11:04:03 <lament> puttycyg
11:04:04 <Beelsebob> ESphynx: yep, still deffinately more productive on OS X, even by your metric
11:04:07 <geezusfreeek> usually the first thing i do when i have to work with windows is ssh home ;)
11:04:10 <ESphynx> in the last decade or so Unix has improved a lot :P
11:04:11 <Beelsebob> that puts UNIX ahead by my measure
11:04:11 <sw17ch> lament, err... yes
11:04:14 <ESphynx> in terms of efficiency
11:04:29 <mauke> geezusfreeek: that remind me, I have to learn about tunneling
11:04:38 * sw17ch loves ssh tunneling...
11:04:42 <ESphynx> But I've seen people stuck with Solaris and CDE
11:04:52 <Beelsebob> ESphynx: nothing wrong with Solaris
11:04:56 <Beelsebob> it's an excellent server OS
11:04:57 <ESphynx> and they are not productive.
11:05:10 <ESphynx> I meant as a desktop
11:05:16 <Beelsebob> ESphynx: most of the people I've seen using solaris for what it's designed for have been *way* more productive
11:05:19 <geezusfreeek> ssh -L <localport>:<hosttoforwardto>:<porttoforwardto> <host>
11:05:27 <Beelsebob> well, okay, that's their fault for using a server OS for a desktop machine
11:05:33 <Beelsebob> nothing to do with the OS
11:05:49 <Samy> ESphynx, so back to haskell... :-P
11:05:51 <ESphynx> well that's how UNIX have been for most of these years
11:05:52 <sw17ch> and people trying to use Windows for something other than a video game platform can't be held accountable for being unproductive :P
11:05:57 <ESphynx> not well suited for a desktop
11:06:08 <lament> moving on, abortions and Islam...
11:06:13 <Samy> ESphynx, http://haskell.org/haskellwiki/Introduction#What.27s_good_about_functional_programming.3F
11:06:15 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/jbwo6
11:06:17 <ESphynx> what do islam say on abortion ?
11:06:18 <ESphynx> i'm curious
11:06:25 <Samy> No abortion in Islam.
11:06:26 <mauke> lament: obama vs mccain
11:06:47 <ESphynx> I'm sort of against abortion myself, apart for exceptional cases
11:06:55 <ESphynx> I think abortions are way too common
11:06:59 * Samy failed at advocacting haskell to ESphynx 
11:06:59 <Beelsebob> ESphynx: bear in mind, that John Bakus (pretty much the guy who came up with the whole high level imperative languages thing), said "actually, that was a shit idea, lets all do functional programming"
11:07:05 <Beelsebob> (paraphrasing a little bit)
11:07:53 <Beelsebob> ESphynx: I would love to carry on that discussion, but in #haskell-blah instead of the main channel
11:08:19 <ESphynx> :)
11:08:38 <ESphynx> moving there ;) have a great haskell day you functional guys ;)
11:08:40 <geezusfreeek> the catchy topics always get moved around freenode
11:08:57 <sw17ch> Any one up for discussing Scurry? :D
11:10:42 <lispy> has one here looked at Oleg's region IO and his iteratee/enumerator stuff?  They seem to overlap a bit.
11:10:56 <lispy> I'm wondering if we can or should combine the overlapping bit.
11:11:07 <lispy> In particular, the region IO is about resource management and the iteratee stuff is more about how to do the IO but naturally delves into the issue of precise resource management
11:11:56 <geezusfreeek> that reminds me i need to read that stuff
11:12:23 <lispy> Well, the region IO stuff is mostly type level, but very cool.
11:12:33 <lispy> The iteratee stuff, I'm still not fully groking
11:15:56 <cpfr> is there a common function for partitioning
11:16:59 <lispy> cpfr: yes
11:17:00 <nottha_k> aren't a lot(most?) of the gnu libraries licenced under the LGPL? doesn't that pose a problem with the fact that ghc only produces staticly linked binaries?
11:17:11 <lispy> ?hoogle Eq a => [a] -> [[a]]
11:17:12 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
11:17:12 <lambdabot> Data.List inits :: [a] -> [[a]]
11:17:12 <lambdabot> Data.List tails :: [a] -> [[a]]
11:17:25 <lispy> cpfr: group and groupBy are the main ones.
11:17:45 <lispy> nottha_k: there is a thread on haskell-cafe in the last week or so debating this
11:17:52 <dons> http://www.galois.com/blog/2008/10/09/type-correct-changes-a-safe-approach-to-version-control-implementation/
11:17:53 <lambdabot> Title: Galois  Blog  Blog  Type Correct Changes: A Safe Approach to Version Con ..., http://tinyurl.com/4decec
11:17:56 <geezusfreeek> i wonder...
11:17:57 <BMeph> ?hoogle [a] -> ([a].[a])
11:17:57 <lambdabot> Parse error:
11:17:57 <lambdabot>   --count=20 "[a] -> ([a].[a])"
11:17:57 <lambdabot>                         ^
11:17:57 <geezusfreeek> @hoogle Data.Set.Set -> [Data.Set.Set]
11:17:58 <lambdabot> Parse error:
11:17:58 <lambdabot>   --count=20 "Data.Set.Set -> [Data.Set.Set]"
11:17:59 <lambdabot>                  ^
11:18:04 <BMeph> ?hoogle [a] -> ([a],[a])
11:18:04 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:18:04 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
11:18:05 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
11:18:05 <geezusfreeek> oh i suck
11:18:10 <cpfr> i think groupBy will work
11:18:36 <cpfr> hmm though not that i look at it, moertal's clusterby is what i want
11:18:37 <geezusfreeek> :t Data.Set.partition
11:18:38 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> (S.Set a, S.Set a)
11:18:49 <geezusfreeek> hmm
11:19:56 <geezusfreeek> seems like that should be called split rather than partition to me
11:20:06 <lispy> dons: that sounds like a cool talk.  I think I'll drop in ;)
11:20:42 * sw17ch is jealous of all those in the Portland area who can go to all the fun talks
11:20:59 <dons> lispy, yeah, looks awesome.
11:21:35 <mauke> @hoogle a" b
11:21:36 <lambdabot> Parse error:
11:21:36 <lambdabot>   --count=20 "a" b"
11:21:36 <lambdabot>               ^
11:36:35 <Samy> @ask obraun Any technical reason why we don't have a cabal-install FreeBSD port?
11:36:36 <lambdabot> Consider it noted.
11:39:49 <andyjgill> Hey, has anyone ever worked on a DSL for Ajax calls between Haskell and Javascript?
11:40:34 <lispy> andyjgill: I would expect HSP and the yhc javascript backends to be related, but I've never done the task you're asking about.
11:42:16 <andyjgill> I'm not considering generating Haskell on the fly, but can generate JavaScript, but do not want to reinvent the wheel (again).
11:43:01 <thetallguy> andyjgill: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HJScript
11:43:06 <Samy> cool
11:43:06 <lambdabot> Title: HackageDB: HJScript-0.4.4, http://tinyurl.com/3vdx6g
11:43:29 <thetallguy> andyjgill: that's the closest I know of
11:43:45 <andyjgill> Ahh. Great! This is exactly what I wanted to at least know about.
11:49:17 <thetallguy> andyjgill: it does have haddock docs, even though they don't appear on the hackage page
12:01:59 <zachk> > True and False
12:02:00 <lambdabot>   Couldn't match expected type `([Bool] -> Bool) -> Bool -> t'
12:02:09 <mauke> :t and
12:02:11 <lambdabot> [Bool] -> Bool
12:02:18 <zachk> > True && False
12:02:20 <lambdabot>   False
12:02:39 <mauke> > let True and False = True in   True and False
12:02:41 <lambdabot>   Couldn't match expected type `a -> Bool -> t'
12:02:51 <mauke> > let True `and` False = True in   True `and` False
12:02:53 <lambdabot>   True
12:03:20 <Cthulhon> ...
12:03:32 <Cthulhon> True and false is now true?
12:03:39 <mauke> kind of
12:03:43 <Cthulhon> > True `and` False
12:03:44 <lambdabot>   Couldn't match expected type `[Bool]' against inferred type `Bool'
12:04:16 <mauke> > True .&. False
12:04:17 <lambdabot>       Ambiguous occurrence `.&.'
12:04:17 <lambdabot>      It could refer to either `Data.Bits..&....
12:10:42 <ttt--> > let { foo = True && False; True && False = True } in foo
12:10:43 <lambdabot>   True
12:11:21 <ttt--> :(
12:12:21 <Deewiant> > let 1 + 1 = 1 in foldl1 (+) [1,1,1,1,1]
12:12:22 <lambdabot>   1
12:13:10 <ttt--> how come the real definition of && isnt used in foo?
12:13:30 <mauke> because you overrode it
12:13:34 <Deewiant> because you redefined it, definition order doesn't matter
12:13:50 <mauke> mutually recursive bindings group
12:14:54 <ttt--> > let foo = True && False in (let True && False = True in foo)
12:14:55 <lambdabot>   False
12:15:09 <tibbe> @seen dcoutts
12:15:10 <lambdabot> dcoutts is in #ghc, #haskell, #gentoo-haskell and #haskell-soc. I last heard dcoutts speak 1h 48m 24s ago.
12:15:28 <tibbe> where are the options for the cabal install config file listed?
12:16:47 <mauke> in the cabal-install config file installed by cabal-install when there is none
12:17:52 <tibbe> mauke: it only lists a few flags
12:18:22 <mauke> hmm
12:18:40 <mauke> are you looking for something specific?
12:29:23 <agcorona> Hi, I want to program very long computations, that may take days to years to complete. For example, workflows. Each step result should be saved . On every machine restart, the proces must continue at the last checkpoint. What is the best solution from your point of view?
12:32:29 <Vulpyne> Are you having problem with any specific one of those steps?
12:32:41 <dblazakis> i just spent 45 minutes tracking down a stupid precedence error, >> binds harder than $ -- why can't i remember that??
12:33:00 <MarcWeber> agcorona: Have a look at HAppS-State library..
12:35:53 <Olathe> Is there anything that has a lower precedence than $ ?
12:36:08 <Mike> Hello
12:36:23 <Mike> Anyone free to give me a bit of a hand ?
12:36:40 <dblazakis> not that I know of, but then, for example something like "put x >> return $ Left y" was what got me, not quite so simple, but almost
12:36:54 <dblazakis> i know it's wrong, but it doesn't look wrong at first glance
12:36:56 * Olathe hands Mike a foam number-one hand.
12:36:56 <Guest91899> Oh right well I've just got a pretty simple problem actually.
12:36:58 <dblazakis> but that's just lack of experience
12:37:06 <Guest91899> ;)
12:37:26 <Guest91899> Well basically I was learning Haskell at school with Linux and using the Char library.
12:37:36 <Guest91899> I've got Windows installed on this machine though (at home)
12:37:50 <Guest91899> And I was wondering where I might obtain that same library.  For example, I was using functionsl ike ord and chr.
12:38:06 <Guest91899> I had a little search through the page with Ctrl-F but sort of got stuck !
12:38:08 <mauke> eh? that should be part of base
12:38:17 <Guest91899> Really ?
12:38:25 <mauke> yeah
12:38:27 <Olathe> @index ord
12:38:28 <lambdabot> Data.Char
12:38:35 <mauke> did you get an error for 'import Char'?
12:38:51 <Guest91899> Ahhhh thanks for that one !
12:38:54 <Guest91899> I was doing what I did at school
12:38:59 <Guest91899> Which was something like :also Hugs.Char
12:39:07 <Guest91899> Thanks very much !
12:39:25 <mauke> whoa
12:39:34 <Guest91899> I gotta say I'm sort of growing on Haskell.  I completely hated it at first but it's definitely growing on me now.
12:39:40 <Olathe> preflex: karma hugs
12:39:40 <preflex>  karma for hugs: 1
12:39:46 <Olathe> preflex: karma ghc
12:39:46 <preflex>  ghc has no karma
12:39:49 <Olathe> :o
12:39:59 <mauke> ghc++
12:40:00 <Guest91899> Hahaha
12:40:08 <Olathe> ghc++
12:40:11 <Olathe> There :)
12:40:21 <Guest91899> Mmmmmm
12:40:36 <Guest91899> So what would you guys class MASM32 (my favourite language) ?  Anti-Christ ?
12:40:53 <mauke> inferior to GNU as
12:41:01 <Guest91899> Blasphemy !!
12:41:14 <mauke> AT&T syntax, dude
12:41:34 <Olathe> An interesting exercise: Create a disassembler and assembler in Haskell.
12:41:45 <Guest70325> Naw too much like HLA
12:41:50 <Samy> Olathe, yes
12:41:54 <Samy> Olathe, haskell would be great for that
12:41:55 <Guest70325> Mreh I'll stick with this name
12:42:01 <Cthulhon> I wrote half a disassembler in Haskell.
12:42:01 <Guest70325> Yeah that would be.. hard from what I have learnt so far.
12:42:15 <Olathe> The assembler wouldn't be so hard, I think.
12:42:21 <Cthulhon> That is, it got the code into semantic data types, but didn't make it easy to read.
12:42:22 <Samy> The problem with such projects is that generating the opcode list is very boring.
12:42:23 <mmorrow> check out harpy
12:42:26 <Samy> very very boring
12:42:39 <Guest70325> I think Intel actually has a list of them you can use
12:42:45 <Olathe> Make an opcode doc reader that generates code ;)
12:42:46 <Guest70325> Mapping opcode to mnemonic.
12:42:49 <Cthulhon> There are plenty of lists around.
12:42:52 <Samy> Guest20327, in text format?
12:43:00 <Cthulhon> In nice XML format, even.
12:43:07 <Samy> And up to date?
12:43:09 <Guest70325> I think you can get them in many formats.
12:43:12 <Guest70325> Up to date ?
12:43:23 <Cthulhon> The ones I saw covered up to x86-64, so I would assume they're up to date.
12:43:31 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy
12:43:32 <lambdabot> Title: HackageDB: harpy-0.4
12:43:32 <Guest70325> Oh I never looked at 64 bit subset yet.
12:43:39 <Guest70325> Can't afford a 64 bit processor to develop on.
12:44:00 <mmorrow> harpy needs someone to add 64bit support :)
12:44:02 <Samy> nod, looking at it
12:44:03 <Samy> Cool.
12:44:16 * Samy wrote a static analysis tool a while ago
12:44:16 <rwbarton> @type put ?x >> return $ Left ?y
12:44:17 <lambdabot> forall s (m :: * -> *) a b. (?y::a, Monad m, MonadState s ((->) (Either a b)), ?x::s) => m (Either a b)
12:44:33 <Samy> and there was no such list.
12:44:50 <Samy> I wrote an awk script for libdisasm
12:45:15 <Cthulhon> http://ref.x86asm.net/
12:45:16 <lambdabot> Title: X86 Opcode and Instruction Reference
12:45:36 <yitz> rwbarton: that' messed up
12:45:43 <pafcu> Anyone here have experince with the DevIL bindings?
12:46:14 <dblazakis> @type put ?x >> return (Left ?y)
12:46:15 <lambdabot> forall s (m :: * -> *) a b. (?y::a, MonadState s m, ?x::s) => m (Either a b)
12:46:15 <pafcu> I can't seem to load images correctly
12:46:38 <rwbarton> dblazakis: was it at least a compile error?
12:46:40 <yitz> @type \x y -> put x >> return $ Left y
12:46:41 <lambdabot> forall s (m :: * -> *) a b. (Monad m, MonadState s ((->) (Either a b))) => s -> a -> m (Either a b)
12:46:48 <yitz> still borked
12:46:57 <dblazakis> rwbarton: definitely, but my eyes kept sliding over it
12:47:08 <rwbarton> dblazakis: right
12:47:13 <dblazakis> the error asking for an instance of MonadState for some bogus type
12:47:41 <rwbarton> yeah, I make that mistake too
12:48:52 <Guest70325> Can I ask where GHC looks for the .hs file ?
12:49:11 <mauke> which .hs file?
12:49:17 <Guest70325> I tried putting it into ghc\ghc-6.8.3 but it's saying "Failed to load interface"
12:49:21 <Guest70325> One I make myself
12:49:24 <gbacon> Dow below 8,700
12:49:30 <mauke> er
12:49:34 <yitz> rwbarton: should be MonadState a m => a -> b -> m (Either b c)
12:49:36 <mauke> how are you running ghc?
12:49:57 <Guest70325> Through the shortcut it created in the start menu
12:50:26 <mauke> hmm, can't help you with that
12:51:11 <Guest70325> Oh right, it's just at school I had to make a .hs file that had several functions.  I just named it *.hs and put it in the 'home' location and Haskell was able to find it and I could use the functions perfectly.
12:51:20 <Guest70325> I will have a poke around then, thanks !
12:51:37 <rwbarton> Guest70325: ghc or ghci?  Are you trying to 'import' it from ghci?
12:51:42 <yitz> Guest70325: even on windows, most people run ghc from the command prompt I think.
12:51:44 <Guest70325> Oh sorry GHCi
12:52:11 <yitz> ah, ghci. ok.
12:52:25 <Guest70325> Not really trying to import it.  At school, I was able to do : hugs *.hs
12:52:35 <Guest70325> and then I would be able to use the functions from that hs file.
12:52:59 <yitz> Guest70325: same thing works on windows, and with ghci.
12:53:25 <Guest70325> Well I created a .hs file in the folder ghc-6.8.3
12:53:29 <Guest70325> Not sure how to 'load' it though
12:53:37 <rwbarton> Guest70325: try   :load filename
12:53:57 <Guest70325> "can't find file"
12:53:59 <yitz> Guest70325: put it in your home folder instead
12:53:59 <mauke> Guest70325: uh, don't
12:54:00 <mauke> that's ghc's installation directory
12:54:16 <Guest70325> I'm on Windows, there isn't a home folder :p
12:54:31 <yitz> Documents and Settings
12:54:40 <Guest70325> oh right I see, let me try that now
12:54:42 <yitz> for older windows. something else for vista
12:54:47 <Deewiant> %USERPROFILE% to be exact
12:55:01 <Deewiant> (the equivalent to $HOME)
12:55:19 <Guest70325> fantastic
12:55:24 <Guest70325> works flawlessly
12:55:25 <yitz> Deewiant: it's not at all the equivalent to HOME, but that's an old argument. :)
12:55:45 <Guest70325> Yes yes yes !
12:55:46 <Deewiant> how not?
12:55:51 <Guest70325> Thanks very much
12:55:54 <SamB_XP> %HOME% is though ;-P
12:56:08 <pafcu> Hmm... OK, so nobody knows about DevIL. Any other library that can load .gif files?
12:56:09 <SamB_XP> but not in a very useful way, sadly
12:56:09 <yitz> Deewiant: it serves different purposes.
12:56:18 <SamB_XP> yitz: how so ?
12:56:24 <Guest70325> Okay time to do the Haskell assignment.  Thanks for all your help guys ;)
12:56:37 <SamB_XP> yitz: IMO it's just a lot harder to find ...
12:56:41 <yitz> Deewiant: but it's the only user-specific folder that is almost always there, so we use it.
12:56:53 <yitz> SamB_XP: yeah, that too.
12:57:25 <Deewiant> hmm, actually %HOMEDRIVE%%HOMEPATH% is probably $HOME
12:57:59 <yitz> generally people don't put init files or config files there (like .foo on unix), not do they put working files there, generally.
12:58:01 <SamB_XP> actually you can type SERPROFILE% in the Run dialog ...
12:58:13 <SamB_XP> yitz: sure they do
12:58:21 <SamB_XP> My Documents is in there, as is the desktop
12:58:35 <SamB_XP> hmm
12:58:40 <yitz> SamB_XP: nah. often on the desktop. or in app-specific locations.
12:58:48 <SamB_XP> apparantly I have to escape my %Us in future
12:58:51 <Deewiant> yitz: like he said, the desktop /is/ in there
12:58:51 <hackage> Uploaded to hackage: data-memocombinators 0.1
12:58:59 <SamB_XP> otherwise I get underlining
12:59:07 <Deewiant> yitz: and app-specific locations = %HOMEDRIVE%%HOMEPATH%\Application Data
12:59:51 <Deewiant> many apps do write to %PROGRAMFILES% (or, far worse, C:\Program Files) but that's wrong and evil
12:59:59 <yitz> Deewiant: ok. but you wouldn't look in the root of D&S. Except a lot of unix-alikes do use that place.
13:00:01 <Deewiant> at least as a default behaviour
13:00:19 <yitz> Deewiant: or C:\. horrors!
13:00:53 <Deewiant> or C:\Documents and Settings
13:01:34 <Deewiant> C:\Windows is another place, common for pre-win32 apps at least
13:02:08 <yitz> Deewiant: on windows I usually work in something like \Projects\<project name>\
13:02:24 <Deewiant> yeah, as do I
13:02:40 <yitz> it would be hard for ghc to guess that though.
13:02:44 <Deewiant> still, I've moved all the standard directories except for C:\Windows to another drive.
13:02:58 <Deewiant> amusingly, I see now that C:\Documents and Settings and C:\Program Files exist nevertheless
13:03:06 <yitz> Deewiant: right, another common technique.
13:03:12 <Deewiant> ah
13:03:13 <Deewiant> C:\Program Files\Microsoft SQL Server
13:03:16 <Deewiant> great
13:03:20 <yitz> hehe
13:14:08 <mmorrow> @nixon
13:14:08 <lambdabot> Don't try to take on a new personality; it doesn't work.
13:14:16 <mmorrow> @nixon
13:14:16 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
13:14:19 <vixey> o/
13:14:26 <mmorrow> @nixon
13:14:26 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
13:15:46 <mmorrow> 
13:16:08 <mmorrow> @nixon
13:16:08 <lambdabot> A man is not finished when he is defeated. He is finished when he quits.
13:16:42 <mmorrow> @remember nixon A man is not finished when he is defeated. He is finished when he quits.
13:16:42 <lambdabot> Done.
13:18:19 <dons> ?users
13:18:20 <lambdabot> Maximum users seen in #haskell: 540, currently: 511 (94.6%), active: 20 (3.9%)
13:21:25 <mmorrow> dons: where do these nixon quotes come from? they're alternately hillarious, scary, embarassing, and genious.
13:21:41 <mmorrow> *genius
13:22:14 <dons> they're not mine. i thought you added them.
13:22:32 <mmorrow> hah, not me.
13:24:27 <vixey> mmorrow: want a problem in group theory? :) possibly unsolveable
13:26:20 <mmorrow> vixey: hehe, sure.
13:27:09 <vixey> so if you have a semigroup S, the two rules: forall a b, exists x, ax=b & forall a b, exists y, ya=b  -- show S is a group
13:27:19 <vixey> I thought about for two days :/
13:27:39 * vixey maybe write a program to try and find counterexamples soon
13:28:39 <mmorrow> well it would be easy if you assumed S was a monoid
13:30:05 <tristes_tigres> no GHC 6.10, *sniff* *sniff*
13:30:12 <mmorrow> i'm not sure if S being a semigroup though is enough though, afaict those rules don't imply it has an identity
13:30:19 <mmorrow> s/though//
13:30:53 <vixey> mmorrow: yeah that's what I think, .. really frustrating doing self study with text books that don't have solutions :/
13:31:31 <mmorrow> tristes_tigres: http://www.haskell.org/ghc/dist/stable/dist/?C=M;O=D  ??
13:31:32 <lambdabot> Title: Index of /ghc/dist/stable/dist
13:32:16 <mmorrow> vixey: heh, that can be a pain. i'll make a list of some good algebra books for you if you'd like.
13:32:25 <vixey> oh I've already read 3
13:32:33 <mmorrow> cool. which ones?
13:32:36 <tristes_tigres> mmorrow: Thanks, look there regularly, but since it's not released, I assume it's pretty buggy &
13:32:43 <vixey> I'v really got to stop buying books.. I've got way too many
13:33:02 <vixey> umm, Introduction to group theory, group theory - an introduction, ... :p
13:33:02 <mmorrow> tristes_tigres: i'm using it and haven't seen any bugs  yet :)
13:33:07 * vixey is working through this section of the library
13:33:16 <mmorrow> vixey: haha, me too. sooo many books :)
13:33:36 <tristes_tigres> vixey: and if you stop buying books, HOW you are going to waste money ? women ?
13:34:02 <tristes_tigres> mmorrow: seems it's being rebuilt daily
13:34:17 <mmorrow> tristes_tigres: of course ;)
13:34:38 <mmorrow> tristes_tigres: but yes, the official 6.10 is not here yet.
13:35:47 <maltem> Talking 6.10, do they have a plan now for base-3/base-4 dependencies?
13:36:05 <mmorrow> vixey: wait. it does say it's a group. take a and b to be the same element ==> x is id.
13:36:17 <vixey> mmorrow: Oh! one I really liked was Rings Modules and Categories
13:36:44 <vixey> mmorrow: I only read half actually but it's really funny reading the set theory stuff at the start, it seems so esoteric
13:37:03 <Olathe> mmorrow: Can you prove that the left and right identities for an element are the same ?
13:37:06 <vixey> no just a semigroup, it's supposed to be provable that its a group
13:37:36 <mmorrow> Olathe: hmm, good point. not sure yet..
13:37:40 <tristes_tigres> mmorrow: doesn't seem to be any summary of what still is being fixed
13:37:51 <vixey> Olathe: I know _I_ can't
13:38:06 <Olathe> ax = a, ya = a
13:38:41 <vixey> also tried some pigeonhole stuff with the assumption the set is finite.. didn't go anywhere, and it may be infinity
13:39:48 <tristes_tigres> but there is already 6.10.1-rc
13:40:30 <Olathe> ay /= ya -> aya /= yaa, but ya = a -> aya = yaa, so ay /= ya must be false.
13:41:03 <Olathe> Thus, ay = ya.
13:41:20 <Olathe> ya = a, so ay = a.
13:41:56 <rwbarton> vixey: You can start by picking a and x so that ax = a, and then show that x is a right identity for every element
13:42:06 <Olathe> So, the left and right identities for each element must be the same.
13:42:17 <mmorrow> yes
13:43:07 <Olathe> Now, are the identities for every element the same ?
13:44:11 <mmorrow> yes
13:44:19 <Olathe> ax = xa = a. by = yb = b.
13:44:45 <vixey> a1 = 1a = a
13:45:52 <Olathe> Hmm, first prove uniqueness of an element's identity, I think.
13:46:43 <Olathe> e /= e' -> ae /= ae', but ae = a = ae', so e /= e' is false.
13:47:43 <Olathe> x /= y -> axb /= ayb. But ab = ab -> axb = ayb. So, x /= y is false.
13:48:02 <Olathe> So, there's one identity for the whole semigroup.
13:48:06 <rwbarton> Olathe: where are you getting "e /= e' -> ae /= ae'"
13:48:17 <Olathe> Hmm...
13:48:22 <Olathe> That's a good question.
13:58:08 <hoknamahn> hey guys is x ^ 2 faster than x ** 2.0?
13:58:49 <rwbarton> hoknamahn: probably x * x is best
13:59:19 <hoknamahn> rwbarton yep you're right
13:59:49 <hoknamahn> but
14:00:15 <hoknamahn> shoul this Vector.length (V3 x y z) ^ 2 be faster than Vector.length (V3 x y z) * Vector.length (V3 x y z)?
14:00:43 <rwbarton> both of those are likely very slow because they're taking a square root
14:00:46 <rwbarton> (I assume)
14:01:36 <tromp__> doesnt Vector offer something like lengthSquared?
14:02:02 <hoknamahn> yea, i know i could implement length2 same as length but without root but just want to know how haskell works
14:02:16 <Botje> i think ^2 gives the compiler a better chance at cancelling (^2) . sqrt
14:02:18 <hoknamahn> yes it's squared length
14:02:29 <rwbarton> hoknamahn: The second one will be slower because it won't share the computation of Vector.length (V3 x y z) (I think)
14:02:42 <hoknamahn> what if i'll use let?
14:02:48 <rwbarton> hoknamahn: let l = Vector.length (V3 x y z) in l * l will share it
14:02:48 <tromp__> write x*x+y*y+z*z or define a function for it
14:02:53 <hoknamahn> to calculate Vector.length onse?
14:02:57 <Botje> hoknamahn: check the core generated to be sure
14:02:59 <rwbarton> hoknamahn: or, you can define square x = x*x
14:03:55 <rwbarton> @remember ghc Can't make a derived instance of `Show Void' (`Void' has no data constructors)
14:03:55 <lambdabot> It is stored.
14:04:49 <s0567134> hi guys
14:04:51 <s0567134> wait
14:05:12 <jadrian> better ;)
14:05:15 <jadrian> hi guys
14:05:39 <jadrian> I'm getting a bit confused with 2nd order polymorphis again
14:06:14 <vixey> oh what's thatpa
14:06:22 <vixey> is that having forall  ?
14:06:32 <vixey> forall a. (forall b. ...
14:06:36 <rwbarton> @type runST
14:06:37 <lambdabot> forall a. (forall s. ST s a) -> a
14:07:32 <eu-prleu-peupeu> hello ppl from planet haskell
14:07:34 <jadrian> h : (forall a. (a->a)->[a]->[a])) -> (Int->Int) -> (Char-> Char) ->  ( [Int]->[Int] , [Char]-> [Char])
14:07:46 <vixey> hey jadrian: what's the point of that forall
14:07:47 <vixey> ?
14:08:03 <jadrian> h m f1 f2 = (m f1, m f2)
14:08:07 <vixey> so basically,
14:08:11 <vixey> Don't add a type signature
14:08:14 <jadrian> ok so suppose I have this function
14:08:24 <vixey> :t let h m f1 f2 = (m f1, m f2) in h
14:08:26 <lambdabot> forall t t1. (t -> t1) -> t -> t -> (t1, t1)
14:08:26 <jadrian> it takes a forall like function
14:08:30 <vixey> :t \m f1 f2 = (m f1, m f2)
14:08:31 <lambdabot> parse error on input `='
14:08:39 <vixey> :t \m f1 f2 -> (m f1, m f2)
14:08:40 <lambdabot> forall t t1. (t -> t1) -> t -> t -> (t1, t1)
14:08:42 <jadrian> opss
14:08:47 <jadrian> it takes a map like function
14:09:10 <jadrian> and applies it to two different first order functions f1 and f2 of different types
14:09:21 <jadrian> that is clearly 2nd order polymorphism
14:09:28 <vixey> is it??
14:09:30 <rwbarton> right
14:09:48 <jadrian> vixey: yes... gimme just a sec, let me clear my doubt first
14:09:54 <jadrian> rwbarton: exactly
14:09:56 <jadrian> so now consider
14:09:59 <vixey> I don' tthink it's second order..
14:10:18 <jadrian> h : (Int->Int) -> (Char-> Char) ->  ( [Int]->[Int] , [Char]-> [Char])
14:10:41 <jadrian> h f1 f2 = (m f1, m f2)
14:10:49 <jadrian> so I removed the m from the argument
14:10:56 <rwbarton> m is in the environment?
14:11:07 <jadrian> m is for instance the map function
14:11:17 <jadrian> a first order polymorphic function
14:11:22 <rwbarton> sure
14:11:36 <jadrian> so now what is h ?
14:11:44 <jadrian> h is monomorphic?
14:11:52 <jadrian> looking at the type it is... right?
14:12:03 <rwbarton> Yeah, it's just a regular monomorphic function
14:12:30 <rwbarton> If you like, you can think of those two ms as not really being the same value
14:13:00 <jadrian> hmmm I see
14:13:17 <jadrian> yes I was trying to figure out the semantic difference
14:16:26 <vixey> I don't really understand jadrian..
14:16:28 <vixey> what are you doing?
14:17:14 <jadrian> studying semantics for higher order polymorphism
14:17:44 <jadrian> and wanted to understand the difference between passing a FO polymorphic function around
14:17:45 <vixey> hte whole typechecking nonsense is purely syntatic
14:18:16 <jadrian> and just caling a constant constant FO polymorphic function more than once
14:18:28 <rwbarton> Yeah, at least in GHC, your two functions h will be translated to very similar things in the core language
14:19:57 <rwbarton> both will take m, which is a polymorphic function, and evaluate it at the types Char and Int
14:20:06 <vixey> you can erase all the types and run the thing in scheme
14:21:01 <rwbarton> The major difference is that type checking becomes undecidable when you allow enough higher-rank polymorphism, but that's a syntactic issue as vixey says
14:21:33 <vixey> did you mean type inference?
14:21:58 <vixey> or are they equivalent in that case?
14:22:05 <rwbarton> Maybe.  (But I was also careful to say "enough higher-rank polymorphism" and I thought that the statement would still be true then)
14:22:14 <EvilTerran> *enough*, yes
14:23:02 <EvilTerran> because "(x :: P) :: Q" implies that P \subseq Q
14:23:35 <EvilTerran> in a sufficiently-complex type system, even typechecking such an expression becomes undecidable
14:27:22 <mgsloan> hey, is there a list of requested haskell libraries / gaps in current lib support somewhere?
14:28:51 <ozy`> tangential question time, folks! anyone know of a language that's as close to the hardware as C is, but with better string support, including a separate string type?
14:29:10 <vixey> ozy`: C
14:29:38 <vixey> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.6483
14:29:38 <ozy`> vixey: sadly, C does not seem to have better string support than C
14:29:39 <lambdabot> Title: Typability and type checking in System F are equivalent and undecidable - CiteSe ...
14:29:45 <mgsloan> ozy`: C++?
14:30:04 <vixey> ozy`: Do you know lisp streams? Just implement that, it makes working with strings in C much less horrible
14:30:14 <Olathe> Where is a good list of papers for understanding the basics of Haskell's type system ?
14:30:17 <vixey> msgloan; Are you really suggesting someone use C++ ..?
14:31:00 <dons> Olathe: hmm. "Typing Haskell In Haskell" ?
14:31:07 <geezusfreeek> ozy`, D?
14:31:11 <mgsloan> well.. you can get a decent string class with C++
14:31:52 <vixey> ozy`: (I am speaking from experience by the way)
14:31:58 <Olathe> dons: Thanks :)
14:32:00 <mib_8epxq5> hi! anyone there willing to help me?
14:32:15 <EvilTerran> ozy`, there are alternative string libraries available for C
14:32:31 <ozy`> vixey: I'll keep that in mind... dunno how lisp streams work but I'll look into it
14:32:36 <EvilTerran> i think that's what vixey meant
14:33:10 <vixey> ozy`: Well you start with some struct { int length; int allocated_size; char *buffer; }
14:33:40 <vixey> ozy`: with some tools to work with that, things quickly become sensible and reasonably efficient (doublying the allocation size each time you hit the limit)
14:34:49 <mib_8epxq5> i've got a little problem with my types, could anyone help me find the problem?
14:34:59 <vixey> mib______, what is the problem?
14:35:16 <mib_8epxq5> im coding the binomial distribution
14:35:21 <vixey> cool
14:35:32 <mib_8epxq5> ill paste the code
14:35:40 <vixey> ?hpaste
14:35:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:36:40 <mib_8epxq5> http://hpaste.org/11044#a0
14:37:31 <mib_8epxq5> well it refers to the binomialcoefficient but it should be clear that the result of that is either an Integer or Int
14:37:56 <mmorrow> just found out that '-' is rebindable with rebindable sytax
14:40:06 <mib_8epxq5> in case you want the whole code: http://hpaste.org/11045
14:41:20 <rwbarton> mib_8epxq5: I think you just need to wrap the call to binomialCoeff in fromIntegral
14:41:23 <rwbarton> :t fromIntegral
14:41:24 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:41:32 <hoknamahn> guys could you explainwhy haskell forces me to use V3 (-1.5) 2.0 0.5 instead of V3 -1.5 2.0 0.5?
14:42:16 <dons> V3?
14:42:23 <mib_8epxq5> let me try that rwbarton! thanks i will let you know how it goes
14:42:24 <dons> oh, i see.
14:42:33 <dons> hoknamahn: (-) is a prefix operator
14:42:37 <dons> :t (-)
14:42:38 <lambdabot> forall a. (Num a) => a -> a -> a
14:42:51 <dons> so you need to scope the application
14:43:02 <hoknamahn> dons okay thanks
14:43:32 <dons> so think of it like, V3 (f 1.5) 2.0 0.5
14:43:33 <rwbarton> :t ?V3 -1.5 2.0 0.5
14:43:35 <lambdabot> parse error on input `?'
14:43:41 <dons> btw, in Haskell, you can leave off the redundant .0
14:43:42 <rwbarton> :t ?v3 -1.5 2.0 0.5
14:43:43 <lambdabot>     Ambiguous type variable `t' in the constraint:
14:43:43 <lambdabot>       `Fractional t'
14:43:43 <lambdabot>         arising from the literal `2.0' at <interactive>:1:9-11
14:43:51 <dons> V3 (-1.5) 2 0.5
14:44:13 <hoknamahn> i like those .0
14:44:23 <hoknamahn> because i see the number is fractional
14:44:31 <dons> fair enough
14:44:32 <mib_8epxq5> rwbarton! thank you very much... so simple!
14:44:58 <Philonous> > 2+3
14:45:00 <lambdabot>   5
14:45:13 <Philonous> I wonder why the type checker doesn't complain about ambiguous types
14:45:23 <Philonous> :t 2
14:45:25 <dons> why would it?
14:45:25 <lambdabot> forall t. (Num t) => t
14:45:34 <mib_8epxq5> haskell is much simpler with a comunnity like this! highly indebted
14:45:34 <Cale> Numeric defaulting
14:45:47 <Philonous> Because he doesn't know what instance of Num 2 would be?
14:45:57 <hoknamahn> yes community is awesome
14:45:59 <EvilTerran> it doesn't need to
14:46:06 <Cale> It does need to.
14:46:08 <EvilTerran> until you ask for the value of it, rather than just the type
14:46:09 <Philonous> How so?
14:46:25 <EvilTerran> if you never ask for a value, it never has to select an instance
14:46:29 <paczesiowa> default Integer
14:46:36 <mmorrow> > (1 :: Int, 1 :: Double)
14:46:36 <Cale> (in order to actually add 2 and 3, you need a typeclass dictionary for Num)
14:46:37 <paczesiowa> > let default = 2 in default
14:46:37 <lambdabot>   (1,1.0)
14:46:38 <lambdabot>   mueval: Prelude.read: no parse
14:46:40 <EvilTerran> because all that varies from instance to instance is types
14:46:42 <Philonous> So there is a default type for a class?
14:46:54 <Cale> Philonous: Only for numerics.
14:47:09 <EvilTerran> (modulo multi-parameter classes and/or type families)
14:47:20 <Philonous> I see. Can I definy a default type for my own classes?
14:47:24 <Cale> No.
14:47:25 <EvilTerran> sadly not
14:47:40 <Cale> It only applies to Num and the other Prelude numeric classes.
14:47:44 <mmorrow> @type (1,1)
14:47:45 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
14:47:47 <EvilTerran> you might be able to do something with the overlapping instances extension
14:47:54 <mmorrow> would be (Integer,Integer)
14:48:03 <mmorrow> after defaulting
14:48:15 <Cale> and defaulting will only occur if the only class constraints applying to the variable are Prelude classes.
14:49:12 <Cale> However, you can change the list of types which it will try to satisfy the constraints with when defaulting, using a default declaration.
14:49:27 <Philonous> Ok, thanks
14:50:44 <Cale> It's a little ugly, but in order to generalise it in a reasonable way, you'd have to make it much more complicated.
14:51:38 <Cale> and yet you probably wouldn't want to remove it altogether, since numeric literals are inherently ambiguous, which would make things rough for people wanting to use GHCi as a calculator, for instance.
14:52:16 <Cale> So it's a bit of an awkward design point, but it's understandable.
14:52:51 <Philonous> Well, I guess literals of user defined types aren't ambiguous because of their unique constructors. So it isn't that big an issue anyway
14:53:02 <EvilTerran> ?type minBound
14:53:03 <lambdabot> forall a. (Bounded a) => a
14:53:04 <ddarius_> Remove it from the language.  It can be an implementation convenience.
14:53:14 <EvilTerran> ^ that's pretty much a user-defined literal
14:53:35 <EvilTerran> > (minBound :: Bool, minBound :: Char, minBound :: Int, minBound :: Ordering)
14:53:36 <lambdabot>   (False,'\NUL',-9223372036854775808,LT)
14:53:47 <EvilTerran> ...
14:53:52 <EvilTerran> > 2^63
14:53:53 <lambdabot>   9223372036854775808
14:54:01 <EvilTerran> 64-bit lambdabot! :)
14:54:08 <EvilTerran> lambdabot++
14:54:32 <ddarius_> minBound isn't a literal
14:54:37 <EvilTerran> well, no
14:54:47 <paczesiowa> :t 2^63
14:54:48 <EvilTerran> but neither are integer "literals", i'd say
14:54:49 <lambdabot> forall t. (Num t) => t
14:55:04 <paczesiowa> > 2^63::Int
14:55:05 <lambdabot>   -9223372036854775808
14:55:18 <paczesiowa> > 2^63::Integer
14:55:20 <lambdabot>   9223372036854775808
14:55:28 <EvilTerran> seeing as they de-sugar into "fromInteger <a genuine literal Integer>"
14:55:31 <paczesiowa> > "snake"
14:55:33 <lambdabot>   "snake"
14:55:55 <rwbarton> :t "snake"
14:55:56 <lambdabot> [Char]
14:56:01 <paczesiowa> EvilTerran: how is that 64 bit?
14:56:05 <EvilTerran> and... guards, in patterns, isn't it?
14:56:36 <aprocter> > 2^65
14:56:37 <Olathe> > maxBound :: Int
14:56:39 <lambdabot>   36893488147419103232
14:56:39 <lambdabot>  Terminated
14:56:42 <EvilTerran> paczesiowa, because minBound :: Int is -(2^63), so Int has 2^64 values
14:56:45 <Olathe> > logBase 2 (maxBound :: Int)
14:56:48 <lambdabot>       No instance for (Floating Int)
14:56:48 <lambdabot>        arising from a use of `logBase' a...
14:56:57 <Olathe> > logBase 2 $ fromIntegral (maxBound :: Int)
14:56:59 <lambdabot>   63.0
14:57:04 <ddarius_> > length [minBound :: Integer .. maxBound]
14:57:05 <lambdabot>       No instance for (Bounded Integer)
14:57:05 <lambdabot>        arising from a use of `minBoun...
14:57:08 <Olathe> > floor.logBase 2.fromIntegral $ (maxBound :: Int)
14:57:09 <lambdabot>   63
14:57:13 <ddarius_> > length [minBound :: Int .. maxBound]
14:57:16 <Olathe> > (+1).floor.logBase 2.fromIntegral $ (maxBound :: Int)
14:57:18 <lambdabot>   64
14:57:29 <lambdabot>   thread killed
14:57:37 <EvilTerran> > fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int) :: Integer
14:57:40 <lambdabot>   18446744073709551615
14:57:40 <rwbarton> > floor (logBase 2 $ fromIntegral (maxBound :: Int) :: CReal)
14:57:42 <lambdabot>   62
14:58:03 <paczesiowa> EvilTerran: that was in Integers, they don't care about bits, right?
14:58:23 <EvilTerran> paczesiowa, how was that integers?
14:58:24 <Olathe> > length $ takeWhile (>0) $ iterate (flip div 2) (fromIntegral (maxBound :: Int) - fromIntegral (minBound :: Int) :: Integer)
14:58:26 <lambdabot>   64
14:58:27 <EvilTerran> that was ints
14:58:34 <EvilTerran> <lambdabot>       No instance for (Bounded Integer)
14:58:43 <paczesiowa> > 2^63 defaults to Integer
14:58:45 <lambdabot>   mueval: Prelude.read: no parse
14:58:45 <Olathe> > length $ takeWhile (>0) $ iterate (flip div 2) (fromIntegral (maxBound :: Word8) - fromIntegral (minBound :: Word8) :: Integer)
14:58:47 <lambdabot>   8
14:58:50 <EvilTerran> so?
14:59:06 <EvilTerran> i've been using explicit types
14:59:21 <EvilTerran> i haven't been saying 2^63, anyway. i've been saying (minBound :: Int) and (maxBound :: Int)
14:59:36 <EvilTerran> those're really quite... *specifically* Ints
14:59:54 <paczesiowa> [23:54] <EvilTerran> > 2^63
14:59:54 <paczesiowa> [23:54] <lambdabot>   9223372036854775808
14:59:54 <paczesiowa> [23:54] <EvilTerran> 64-bit lambdabot! :)
15:00:03 <EvilTerran> ...
15:00:12 <EvilTerran> <EvilTerran> > (minBound :: Bool, minBound :: Char, minBound :: Int, minBound :: Ordering)
15:00:12 <EvilTerran> <lambdabot>   (False,'\NUL',-9223372036854775808,LT)
15:00:20 <EvilTerran> I was comparing it to the figure there
15:00:26 <paczesiowa> EvilTerran: I see
15:00:50 <Olathe> > takeWhile (/= 0) $ iterate (*2) (1::Int)
15:00:52 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:00:57 <Olathe> > length $ takeWhile (/= 0) $ iterate (*2) (1::Int)
15:00:58 <paczesiowa> because for a moment I thought that someone was wrong on the internet
15:00:59 <lambdabot>   64
15:01:05 <Olathe> Much better :)
15:01:10 <Olathe> > length $ takeWhile (/= 0) $ iterate (*2) (1::Word16)
15:01:13 <lambdabot>   16
15:01:20 <EvilTerran> Olathe, beautifully done
15:01:26 <EvilTerran> Olathe++
15:01:29 <Olathe> Thanks :)
15:01:49 <loop> olathe' = olathe+1
15:01:51 <loop> :P
15:02:02 <paczesiowa> succ
15:02:04 <EvilTerran> runOlathe (modify succ)
15:04:30 <EvilTerran> or should that be "modifyIORef olathe succ"?
15:04:47 <paczesiowa> unsafePerformIO $
15:05:45 <EvilTerran> the first could easily be pretty much the same as the second, if Olathe is a MonadState wrapping an IORef
15:06:04 <EvilTerran> (sorry for all the beeping, Olathe :P)
15:06:13 <Olathe> Heheh.
15:06:14 <slarba_> what do you think, will ABN AMRO be saved from this financial turmoil? :) (they use haskell to "measure counterparty risk on portfolios of financial derivatives") ;)
15:07:38 <luite_> slarba_: apparently not on their own, they were taken over by fortis last year, the dutch part of which is now nationalized by the dutch government
15:08:46 <mml`> > length $ takeWhile (/= 0) $ iterate (`Data.Bits.shift` 1) (1::Int)
15:08:49 <lambdabot>   64
15:10:05 <Olathe> > shiftL 1 1
15:10:13 <lambdabot>   Add a type signature
15:10:18 <Olathe> > shiftL
15:10:20 <lambdabot>       Overlapping instances for Show (a -> Int -> a)
15:10:20 <lambdabot>        arising from a us...
15:10:29 <mml`> :t shiftL
15:10:32 <lambdabot> forall a. (Bits a) => a -> Int -> a
15:10:37 <ddarius_> olathe = Ce^-t - 1
15:11:06 <mml`> > 1 `shiftL` 1
15:11:08 <lambdabot>   Add a type signature
15:11:10 <ddarius_> er Ce^t
15:11:15 <mml`> > (1::Int) `shiftL` 1
15:11:17 <lambdabot>   2
15:12:25 <mml`> @src shiftL
15:12:25 <lambdabot> Source not found. My mind is going. I can feel it.
15:28:44 <noZone> To Monad, or not to Monad, that is the question... Maybe.
15:29:29 <Olathe> Maybe is Nothing.
15:29:40 <noZone> To Either Monad or not to Monad, that is the question.
15:30:25 <vixey> Mu Maybe
15:35:54 <Boney> There are Just 1 types of people in the world, those that understand monads and Nothing.
15:36:24 <noZone> lol
15:36:24 <Boney> that's not original, I can't remember where I heard it,  probably here.
15:36:40 <noZone> It's a variation on an old joke, but a good one.
15:36:56 <Boney> yep,  that's one of the reasons why it's funny.
15:37:56 <olsner> wouldn't Just () be more appropriate?
15:38:30 <olsner> I mean Maybe () has two values (not counting bottoms...), while Num a => Just a has quite a few values
15:39:25 <Boney> but saying "Just 1" reads like 'just 1" and even "1", which is good since many people won't expect a monad joke.
15:39:39 <Boney> YOU'RE RUINING IT!!
15:40:59 <vixey> there are In (Just (In (Just (In Nothing)))) :: Mu Maybe types of people in the world ...
15:41:59 <Olathe> length typesOfPeople :: Maybe Integer
15:42:09 <olsner> ... those that are crazy, those who are sane and those whose sanity is undecidable?
15:42:37 <lanaer> is anyone really sane?
15:42:37 <Boney> olsner: heh,
15:42:51 <Boney> lanaer: I am!
15:43:06 <lanaer> Boney: so *you* say
15:43:13 <Boney> ok, since you're willing to ruin that joke.
15:43:37 <lanaer> ?
15:43:38 <Boney> I ask you.  How many Haskell programmers does it take to change a light bulb?
15:43:48 <noZone> These and other jokes can be ruined by putting them up on #haskell.
15:43:56 <vixey> oh how many
15:43:57 <vixey> ?
15:44:03 <rwbarton> _|_, the lightbulb is immutable?
15:44:06 <Boney> noZone: I think this was my mistake.
15:44:13 <Boney> rwbarton: well done.
15:44:18 <dons> ?users
15:44:19 <lambdabot> Maximum users seen in #haskell: 540, currently: 498 (92.2%), active: 20 (4.0%)
15:44:26 <Boney> vixey: I don't know,  but I like rwbarton's answer.
15:44:34 <Valodim> is it a monadic light bulb?
15:44:48 * lanaer is too much of a haskell noob to play along with the jokes
15:44:52 <Olathe> None, you can't change lightbulb because it's not a typeclass function.
15:45:10 * Olathe grumbles at (^).
15:45:18 <olsner> None, the haskell programmer is lazy enough to let office maintenance take care of the light bulb.
15:45:43 <lament> @quote bulb
15:45:44 <lambdabot> No quotes match. My mind is going. I can feel it.
15:45:50 <lament> @quote light
15:45:50 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
15:45:50 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
15:46:25 <Boney> I used to code in C drunk.
15:46:31 <Boney> it mostly worked.
15:46:42 <dons> mostly
15:46:46 <lanaer> mostly is a dangerous word
15:46:47 <Boney> Being drunk while using Java made it more barable.
15:46:49 <dons> at least, it compiled.
15:46:50 <Valodim> we woke the dons
15:47:02 <Boney> lanaer: exactly.
15:47:15 <Boney> I could do it,  I just wasn't as productive as normal.
15:47:17 <olsner> "mostly works" meaning that it only *maybe* formats your hard drive?
15:47:32 <Olathe> Maybe (IO ())
15:47:50 <lanaer> or you add an extra 0 someplace, and charge the customer $1000 instead of $100
15:48:17 <olsner> or you lose one someplace, and charge $10 instead of $100 :P
15:48:34 <lanaer> even worse!
15:50:14 <lanaer> or you leave test-mode on in production, and dont take any money at all
15:51:03 <olsner> or bill imaginary customers for imaginary work done
15:52:01 <lanaer> indeed
15:53:25 <olsner> or keep you up way past your bedtime, like now... and that's only a *hypothetic* maybe-working C program
15:53:31 * olsner goes *poof*
16:02:09 <SamB_XP> these days it's a bit hard to write a C program that even just accidentally corrupts your hard drive
16:03:32 <SamB_XP> something to do with the invention of the manned maneuvering unit
16:03:35 <BMeph> SamB_XP: s/even/only/ ? ;)
16:09:37 <mdmkolbe> I have a list of pairs.  How do I find the pair where the second element is the smallest?
16:09:51 <vixey> :t minimumBy snd
16:09:53 <lambdabot>     Occurs check: cannot construct the infinite type:
16:09:53 <lambdabot>       b = (a, b) -> Ordering
16:09:53 <lambdabot>     Probable cause: `snd' is applied to too many arguments
16:09:58 <vixey> :t minimumBy (comparing snd)
16:09:59 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
16:10:12 <mdmkolbe> @index minimumBy
16:10:13 <lambdabot> Data.List
16:10:16 <EvilTerran> :t foldr1 (min`on`snd)
16:10:17 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
16:10:18 <lambdabot>       Expected type: (a, b) -> (a, b) -> (a, b)
16:10:18 <lambdabot>       Inferred type: (a, b) -> (a, b) -> b
16:10:21 <EvilTerran> er
16:10:40 <Olathe> @src on
16:10:40 <lambdabot> (*) `on` f = \x y -> f x * f y
16:10:47 <EvilTerran> of course
16:10:54 <Olathe> zomg, it uses (*) as a variable.
16:10:58 <EvilTerran> :D
16:11:04 <mdmkolbe> @index comparing
16:11:04 <lambdabot> bzzt
16:11:16 <Olathe> @type comparing
16:11:17 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:11:27 <dmwit> mdmkolbe: It's in Data.Ord, I think.
16:11:32 <EvilTerran> comparing = (compare `on`)
16:11:42 <mdmkolbe> dmwit: that worked
16:11:49 <EvilTerran> some people also define equating = ((==)`on`)
16:12:13 <EvilTerran> nubBy (equating snd) or whathaveyou
16:18:55 <enderbean> Does anyone here know wxHaskell?
16:19:21 <EvilTerran> i think most people tend to use gtk2hs instead, tho there may still be someone
16:19:36 <enderbean> Any particular reason why?
16:19:56 <EvilTerran> dcoutts' evangelism :P
16:20:15 <EvilTerran> or, as he'd put it, that it's more maintained and polished, i believe
16:20:43 <enderbean> Oh. Well that would be good. :) I mostly just picked one to try.
16:20:47 <dmwit> Plus it actually uses garbage collection! =)
16:21:01 <EvilTerran> dmwit, yeah, that sounds like a "more polished" to me
16:21:32 <dmwit> Not that it really matters.  How often do you actually make and then later drop enough widgets for the GC to even notice?
16:21:50 <enderbean> I'm almost done though.. so I'm not going to give up yet! The randomly rewriting it with other libraries step will come next.
16:21:54 <EvilTerran> gtk2hs is a rather higher-level interface than the C one
16:22:18 <EvilTerran> fits in well with Haskell... i don't know if the same is the case for wxWidgets
16:22:28 <EvilTerran> although, from what dmwit is saying, it may not be
16:22:32 <EvilTerran> dmwit, spreadsheet app?
16:22:52 <dmwit> Yeah, that's possible.
16:23:09 <EvilTerran> i guess you could make the extra effort to re-use existing widgets, but it'd be easier to have an array of them for each sheet you have open
16:25:37 <enderbean> I was thinking about trying one of the frp based gui libraries, once I got this to work. Are any of them particularly outstanding?
16:26:44 <EvilTerran> i don't think any of them are particularly viable for big projects, they're mostly proof of concept
16:26:48 <EvilTerran> altho i may be wrong
16:29:04 <enderbean> That was the impression I had.
16:29:17 <igel> I've got a problem with cabal install
16:29:30 <dcoutts> igel: only one? I've got several!
16:29:37 <enderbean> I'm playing around and experimenting mostly.
16:29:40 <igel> "Could not find module 'Distribution.Simple.Program'"
16:29:52 * EvilTerran wonders if dcoutts has a beep for "cabal install" set up or something
16:29:54 <igel> Cabal-1.4 is installed
16:30:04 <igel> ghc-pkg check does not report any errors
16:30:12 <EvilTerran> i was about to suggest a @get-dcoutts to go with @get-shapr, but it may not even be necessary :)
16:30:17 <dcoutts> heh heh
16:30:33 <dcoutts> igel: can you load  Distribution.Simple.Program in ghci ?
16:30:36 <igel> dcoutts: is cabal that buggy?
16:30:55 <igel> nope
16:31:01 <dcoutts> igel: no, but there are about 150 open feature requests :-)
16:31:11 <EvilTerran> dcoutts, i was just talking to enderbean about gtk2hs, too, if you want to try to recruit hir :P
16:31:15 <igel> i even tried cabal install Cabal, but it didn't help
16:31:17 <dcoutts> igel: saying it cannot find the .hi file right?
16:31:22 <igel> s/help/work
16:31:31 <igel> ghci?
16:31:33 <mmorrow> just built haddock docs for ghc http://moonpatio.com/docs/ghc/
16:31:34 <lambdabot> Title: ghc-6.10.0.20080927: XXX
16:31:40 <igel> "could not find module..."
16:31:52 <dcoutts> igel: I bet the .hi file is missing
16:31:57 <igel> shall i manually install cabal?
16:32:13 <EvilTerran> your code needs to get .hi-er :P
16:32:16 <hackage> Uploaded to hackage: data-memocombinators 0.1
16:32:17 <hackage> Uploaded to hackage: http-shed 0.1
16:32:17 <hackage> Uploaded to hackage: cpphs 1.6
16:32:17 <hackage> Uploaded to hackage: yjftp 0.3
16:32:19 <hackage> Uploaded to hackage: hsConfigure 0.1
16:32:21 <dcoutts> igel: my hypothesis is that you've got a Cabal registered, but all the files got deleted
16:32:43 <EvilTerran> or moved
16:32:54 <igel> i'll install it by hand
16:32:57 <igel> (cabal)
16:33:02 <igel> give me a minute :)
16:33:05 <stepcut> is there a way to get GHC to output all my imports as explicit. for example, Data.List (nub,head,tail), depending on what I actually used ?
16:33:05 <dcoutts> igel: check if the files exist for your Cabal lib
16:33:26 <dcoutts> stepcut: I think there is actually, I can't remember the option, check the ghc user guide
16:35:50 * stepcut checks
16:36:37 <stepcut> -ddump-minimal-imports perhaps
16:36:51 <igel> dcoutts: you're right
16:37:19 * dcoutts wishes ghc-pkg check would look for these missing files
16:37:19 <igel> i manuall reinstall Cabal, then "cabal install Cabal" and now it seems to work
16:37:36 <igel> i thought it did...
16:37:43 <dcoutts> igel: no, only missing dependencies
16:37:56 <igel> it just checks the deptree???
16:38:55 <dcoutts> igel: yes
16:38:59 <igel> :]
16:39:42 <igel> alex and happy have finished, the problem is solved
16:39:44 <igel> thanks dcoutts
16:40:17 <dcoutts> igel: http://hackage.haskell.org/trac/ghc/ticket/2445
16:40:18 <lambdabot> Title: #2445 (better error message needed for missing package files) - GHC - Trac
16:40:20 <dons> ?bug
16:40:21 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:40:23 <dcoutts> igel: add your vote
16:45:20 <igel> dcoutts: i don't see where/how... or is it just too late over here?
16:45:48 <dmwit> You have to log in.
16:46:06 <dmwit> There's a guest account... user name guest, password... password?
16:46:09 <dmwit> Something like that.
16:46:13 <dmwit> It says on their home wiki page.
16:47:21 <dmwit> guest/guest
16:48:10 <igel> i see
16:48:12 <igel> thanks
16:49:44 <igel> talking about cabal-install... is the "optimization" option supposed not to work?
16:51:10 <dcoutts> igel: what do you think is wrong?
16:51:36 <dcoutts> igel: we don't have very many features that are deliberately supposed not to work
16:51:51 <dons> hehe
16:51:53 <dcoutts> just chucked in there to get your hopes up and then cruelly dash them
16:51:57 <dcoutts> muwahahaha
16:52:15 <dons> -fomg-awesome
16:52:25 <dons> Exception: haha
16:52:31 <dcoutts> hah hah hah
16:52:40 <dcoutts> I should definitely add that feature
16:54:23 <igel> when uncommenting the "-- optimization: True" line in ~/.cabal/config, cabal install fails saying "cabal: Command.optionToFieldDescr: feature not implemented"
16:55:06 <dcoutts> igel: oh, heh, ok. A bug in the command line / config file stuff
16:55:16 <dcoutts> igel: the command line variant of that works
16:55:38 <dcoutts> igel: feel free to report that btw
17:01:32 <TomMD> Are you two chatting in IRC while in the same city or are did dcoutts fly back already?
17:01:46 <dcoutts> TomMD: dons is behind me
17:01:53 <dcoutts> about 2 meters away
17:01:57 <dons> wassup?
17:02:02 <dcoutts> @arr?
17:02:02 <lambdabot> Avast!
17:02:05 <dons> ?yow!
17:02:05 <lambdabot> I can't think about that.  It doesn't go with HEDGES in the shape of
17:02:05 <lambdabot> LITTLE LULU -- or ROBOTS making BRICKS ...
17:02:08 <igel> dcoutts: [x] done
17:02:36 <dcoutts> igel: ta
17:02:46 <dcoutts> dons: http://hackage.haskell.org/packages/archive/preferred-versions
17:03:07 <dons> sweet.
17:03:11 <dons> in the index yet?
17:03:41 <dons> nice, you can see the constraints being propagated from my local index,
17:03:42 <dons> /tmp/TMPX11-1.4.3/X11-1.4.3/dist/setup/setup configure --verbose=2 --ghc
17:03:43 <dons> --prefix=/home/dons/.cabal --disable-optimization --user --constraint=base
17:03:43 <dons> ==3.0.3.0
17:07:07 <igel> good night
17:07:25 <romildo> Regarding tree views in gtk2hs, is it possible to get the corresponding row of the underlying list store on the cursor-changed signal? If so, how?
17:12:56 <dcoutts> romildo: you can convert from a tree iter to a path, which gives you the int index for the list store
17:13:03 <Sadache> Are there any special effecient list comparer functions?
17:14:11 <Sadache> My question can be also: Are there some special kind of lists that can be effeciently compared
17:14:31 <EvilTerran> in what way efficiently?
17:14:40 <EvilTerran> the comparison is O(n)
17:14:41 <Sadache> What I want is to find difference between containers to generate sql script to update the database
17:15:16 <EvilTerran> so you want some kind of container type that keeps a hash of each value it contains or something?
17:15:16 <sjanssen> Sadache: try a Set, perhaps?
17:15:47 <Sadache> @sjanssen are there functions that compare sets ?
17:15:47 <lambdabot> Unknown command, try @list
17:15:54 <EvilTerran> heh
17:16:01 <EvilTerran> @botsnack
17:16:01 <lambdabot> :)
17:16:15 <sjanssen> Sadache: sure, there are difference, intersection, and union functions
17:16:30 <romildo> dcoutts, ok, now it seems easy. thanks.
17:16:53 <EvilTerran> as well as subset comparisons etcetc
17:17:07 <Sadache> that is good i guess
17:17:13 <EvilTerran> although you *can* express subset in terms of difference
17:17:37 <EvilTerran> x `subset` y = empty (s `subtract` y)
17:17:42 <Sadache> i guess this is what i need
17:18:09 <Sadache> what is "empty"?
17:18:28 <EvilTerran> empty x = x is the empty set
17:18:31 <sjanssen> actually called null, I believe
17:18:33 <EvilTerran> i'm speaking in pseudocode here
17:18:37 <Olathe> What is s ?
17:18:43 <EvilTerran> Olathe, it's x
17:18:44 <EvilTerran> :P
17:18:47 <Sadache> ok
17:18:48 <Olathe> Oh, what is subtract ?
17:18:54 <EvilTerran> ...
17:19:07 <EvilTerran> asymmetric difference
17:19:14 <dmwit> Olathe: He mistakenly wrote subtract when he meant \setminus.
17:19:15 <sjanssen> one must also note that EvilTerran's function is properSubset
17:19:16 <Olathe> Ahh.
17:19:34 <dmwit> sjanssen: Are you sure?
17:19:36 <EvilTerran> S `subtract` T = { x | x <- S, x </- T }
17:19:55 <dmwit> sjanssen: I think it's normal subset.
17:19:57 <sjanssen> dmwit: nevermind
17:20:13 <EvilTerran> writing <- for \elem and </- for \notelem, for those of you who still think tex is a good idea :P
17:21:17 * EvilTerran notes he should've written that { x <- S | x </- T }, though, seeing as you can't implicitly use the universal set like that in rigorous set theory :P
17:22:09 <Sadache> ok, I guess in my case i need to do a type class that takes two containers and produces a list of actions that describe the difference
17:22:22 <Sadache> thank you for help
17:22:23 <EvilTerran> ah, you're making diffs (of a sort)?
17:22:50 <Sadache> i am making diffs yes
17:23:00 <EvilTerran> yes, you could have a typeclass that (like read) recursively called different instances of itself
17:23:49 <EvilTerran> class Diff a where diff :: a -> a -> a -> a -- diff a b a = a
17:24:10 <EvilTerran> or returning something more concrete than (a -> a)
17:24:34 <Sadache> [a->a] ?
17:24:47 <EvilTerran> that'd be a little more concrete, yes
17:25:02 <EvilTerran> i was thinking it could just proceed recursively
17:26:52 <mm_freak> @index poly
17:26:53 <lambdabot> bzzt
17:27:08 <mm_freak> @src poly
17:27:09 <lambdabot> Source not found.
17:27:16 <EvilTerran> "instance Diff a => Diff (Maybe a) where diff Nothing Nothing = id; ...; diff (Just x) (Just y) = Just . diff x y
17:27:25 <EvilTerran> " kinda thing
17:28:21 <Sadache> maybe i could even need a DSL so that I can return a list of actions that have directly the semantics
17:28:50 <EvilTerran> some kind of recursive type representing only the changes would work
17:29:22 <Sadache> ok, i guess i ll try that, thanks EvilTerran :)
17:29:28 <EvilTerran> ideally, your normal recursive type would be Fix Foo, and your diff type could be Fix (Maybe `O` Foo)
17:29:29 <EvilTerran> :P
17:29:53 <EvilTerran> ?src Mu
17:29:54 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:30:13 <EvilTerran> some call it Mu, some call it Fix...
17:32:16 <Sadache> yeah, i guess it is used for memorizing if i am not mistaken
17:33:20 <EvilTerran> actually, that Mu (Maybe `O` Foo) thing wouldn't really work
17:33:55 <EvilTerran> it is easy to make an abstract representation as a function, but it's quite a bit harder as a datatype
17:36:31 <EvilTerran> for "data Foo = Bar Int Foo | Baz Foo Char | Eek", say, you'd need "data DiffFoo = DiffBar (Maybe Int) DiffFoo | DiffBaz DiffFoo (Maybe Char) | Replace Foo | NoDiff" or something
17:37:34 <Sadache> that is why i thought of a DSL, i need an abstract representation of differences
17:37:43 <EvilTerran> er, concrete?
17:38:16 <ddarius_> D[Foo]
17:38:46 <Sadache> but then i would need a type per type
17:39:26 <ddarius_> Write a polytypic program.
17:44:02 <Sadache> ddarius can this be done in haskell without extensions?
17:44:21 <Sadache> i should try to imagine that
17:56:51 <chrisdone> @vixen harder, better, faster, stronger
17:56:51 <lambdabot> :)
17:57:12 <Olathe> @vixen @vixen
17:57:12 <lambdabot> we all have a little vixen in us
17:57:15 <Olathe> @@ @vixen @vixen
17:57:15 <lambdabot>  nope, i'm a girly
17:57:23 <Olathe> @@ @vixen @vixen
17:57:23 <lambdabot>  so, what do you think of me?
17:58:15 <nottha_k> i've got a queue of events that have timestamps and callback functions. I need to insert new events in the appropriate locations in the queue and periodically iterate over it and call all the callbacks. I have no idea where I would even begin tackling the former in haskell. In C or python I would just throw a mutable doubly linked list together and call it a day.
17:58:34 <cpfr> has anyone ever needed a function that takes a list of functions and applys each to a certain value
17:58:44 <dmwit> cpfr: zipWith ($)
17:58:50 <ddarius_> nottha_k: You could just throw a mutable doubly linked list together and call it a day.
17:58:54 <Apocalisp> cpfr: sequence
17:59:12 <dmwit> cpfr: Or sequence if the argument is the same for all the functions, yeah.
17:59:56 <Apocalisp> > sequence [(*3), (+1), (*2)] 4
17:59:57 <lambdabot>   [12,5,8]
18:00:02 <dmwit> nottha_k: I guess this is for some multi-threading code?
18:00:09 <dmwit> nottha_k: In which case, you may be interested in Chans.
18:00:36 <cpfr> No instance for (Monad ((->) a))
18:00:43 <dmwit> import Control.Monad.Reader
18:00:47 <Apocalisp> import Control.Monad.Instances
18:00:53 <Apocalisp> :)
18:01:17 <dmwit> Reader is nicer, you get liftM and friends.
18:01:27 <cpfr> what did Reader and Instances add that i needed
18:01:43 <dmwit> An instance for (Monad ((->) a)).
18:01:44 <dmwit> ;-)
18:01:44 <dolio> > sqrt (10^2 + 12^2)
18:01:45 <ddarius_> > (1+) `liftM` (3*) $ 5 -- oh yeah!
18:01:46 <lambdabot>   15.620499351813308
18:01:47 <lambdabot>   16
18:01:47 <Apocalisp> cpfr: an instance for the (->) monad
18:01:52 <cpfr> thanks
18:02:18 <mmorrow> nottha_k: erm, so by "appropriate locations in the queue", you mean at arbitrary locations in the "queue"?
18:02:36 <ddarius_> mmorrow: The timestamps are presumably ordered.
18:02:41 <nottha_k> dmwit: nope not for multithreaded code, but it definitely seems like threads would work naturally here
18:02:47 <mmorrow> (ie is this really a queue)
18:02:48 <Apocalisp> more specifically, an instance of the Monad typeclass for the (a -> b) type, for all a, b.
18:02:49 <nottha_k> mmorrow: yes ordered by timestamps, sorry
18:02:57 <mmorrow> ah, gotcha
18:03:01 <cpfr> nice, functions are monads?
18:03:45 <ddarius_> Apocalisp: The instance is what GHC said it was ((->) a)
18:03:50 <mmorrow> @src (>>=) (a->b)
18:03:50 <lambdabot> Source not found. :(
18:03:58 <mmorrow> @src (a->b) (>>=)
18:03:59 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:04:11 <dolio> @src (->) (>>=)
18:04:11 <lambdabot> f >>= k = \ r -> k (f r) r
18:04:14 <mmorrow> heh, i can't remember how you have to say the -> part
18:04:15 <mmorrow> ah
18:04:22 <Apocalisp> ddarius_: Oh yea, thanks.
18:04:34 <mmorrow> that's funny, since :k (->) /= * -> *
18:04:43 <nottha_k> I spent yesterday dealing with problems in python thinking over and over again, with static typing I wouldn't have gotten this far with these stupid problems. For me, the grass always seems to be greener in another language.
18:04:51 <mmorrow> hmm, is there a k
18:04:56 <dolio> Yeah, but @src doesn't care about kinds. :)
18:04:57 <mmorrow> :k
18:05:04 <mmorrow> dolio: oh, i see
18:05:10 <mmorrow> @kind (->)
18:05:11 <lambdabot> ?? -> ? -> *
18:05:14 <mmorrow> sweet
18:05:39 <mmorrow> @kind (->) Int
18:05:40 <lambdabot> ? -> *
18:05:44 <Olathe> @kind ness
18:05:44 <mmorrow> @kind (->) (->)
18:05:45 <lambdabot> Not in scope: type variable `ness'
18:05:46 <lambdabot>     `(->)' is not applied to enough type arguments
18:05:46 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
18:05:54 <nottha_k> I guess I need to learn how to make mutable objects in haskell.
18:06:21 <cpfr> zipWith ($) looks like itll be handy
18:06:24 <mmorrow> you probably want to look at MVar s first, since this sounds multithreaded
18:06:27 <ddarius_> You use IO/STRefs or M/TVars
18:06:28 <Olathe> nottha_k: I read some book about STM which seemed simple enough.
18:07:00 <mmorrow> STM is pretty simple and really nice. i've found that it slow things down a bit though
18:07:05 <mmorrow> *slows
18:07:16 <Olathe> Ahh.
18:07:18 <mmorrow> but there are some things which can't be done without it
18:07:32 <mmorrow> (well, anything /can/ be done, but ...)
18:08:45 <mmorrow> i haven't benchmarked it against the "equivalent" code with only MVars though, so that's just speculation of course :)
18:09:16 <cpfr> zipWith ($) looks like itll be handy too
18:09:37 <mmorrow> very
18:09:37 <Apocalisp> zapp!
18:10:15 <cpfr> im still wowed
18:10:18 <Apocalisp> @let zapp = zipWith ($)
18:10:20 <lambdabot>  Defined.
18:10:31 <cpfr> i never realized functions were monads
18:10:50 <Apocalisp> pretty cool, huh?
18:10:53 <cpfr> yes
18:11:20 <ddarius_> > getZipList $ ZipList [(1+),(2+),(3+)] <*> ZipList [6,7,9]
18:11:20 <Apocalisp> I thought so too. I'm not sure that "functions are monads" is completely accurate, but close enough.
18:11:21 <lambdabot>   [7,9,12]
18:11:25 <cpfr> since my definitions of monads were things that needed to be ordered
18:11:49 <dmwit> You can think of (.) as "ordering" functions.
18:12:02 <mmorrow> partially
18:12:07 <cpfr> zapp  [(1+),(2+),(3+)] [6,7,9]
18:12:12 <Apocalisp> yes, (.) is map for functions
18:12:14 <cpfr> > zapp  [(1+),(2+),(3+)] [6,7,9]
18:12:15 <lambdabot>   [7,9,12]
18:12:31 <mmorrow> (i meant partially as in a "partial ordering")
18:12:37 <cpfr> right
18:12:52 <cpfr> ok i see it
18:13:15 <Apocalisp> what's >>= for functions? S combinator?
18:13:43 <mmorrow> @src (->) (>>=)
18:13:43 <lambdabot> f >>= k = \ r -> k (f r) r
18:13:45 <dmwit> Apocalisp: Not quite, ap is s.
18:14:02 <Apocalisp> @src ap
18:14:02 <lambdabot> ap = liftM2 id
18:14:09 <mmorrow> @pl  \ r -> k (f r) r
18:14:09 <lambdabot> k =<< f
18:14:13 <mmorrow> grr
18:14:36 <cpfr> foo . bar . baz != baz . bar . foo
18:14:36 <dmwit> :t (>>=) :: (a -> b) -> (b -> a -> c) -> (a -> c)
18:14:37 <lambdabot> forall a b c. (a -> b) -> (b -> a -> c) -> a -> c
18:15:00 <mmorrow> cpfr: not in the general case
18:15:21 <cpfr> in the general case they are =?
18:15:51 <mmorrow> i mean, they can be equal depending on the types of foo,bar,baz and what exactly they do
18:16:22 <mmorrow> (assuming equality is defined as type-equality or type-equality+value-equality respectively)
18:17:09 <mmorrow> oh, i see. so i meant "yes, in the general case what you say is true"
18:17:09 <cpfr> oh yes
18:17:37 <mmorrow> not "no, what you say is false in the general case"
18:17:40 <cpfr> > sequence (sequence [(+), (*), (-)] 3) 4
18:17:41 <lambdabot>   [7,12,-1]
18:18:05 <mmorrow> hehe, the ambiguities in language
18:19:14 <cpfr> hmm i would have hoped i could make the line shorter
18:19:29 <dmwit> s = sequence
18:19:31 <dmwit> ;-)
18:19:39 <ddarius_> [7,12,-1]
18:20:24 <dmwit> > map ($4) . map ($3) $ [(+), (*), (-)]
18:20:25 <lambdabot>   [7,12,-1]
18:22:18 <mmorrow> oh i see. so source just consults this http://code.haskell.org/lambdabot/State/source
18:22:23 <cpfr> > map (\ x -> x 4 3) $ [(+), (*), (-)]
18:22:24 <lambdabot>   [7,12,1]
18:23:21 <dmwit> > map (($4).($3)) [(+), (*), (-)]
18:23:22 <lambdabot>   [7,12,-1]
18:23:31 <mmorrow> @fresh
18:23:31 <lambdabot> Haa
18:23:33 <mmorrow> @fresh
18:23:33 <lambdabot> Hab
18:23:39 <cpfr> lets golf
18:24:16 <dmwit> > let (.) = fmap in ($4).($3).[(+), (*), (-)]
18:24:17 <lambdabot>   Couldn't match expected type `(a1 -> a -> b) -> a1 -> a -> b'
18:24:39 <dmwit> huh
18:24:46 <dmwit> > let (.) = fmap in (($4).($3)).[(+), (*), (-)]
18:24:47 <lambdabot>   Couldn't match expected type `(a1 -> a -> b) -> a1 -> a -> b'
18:28:02 <Apocalisp> > [(+),(*),(-)]<*>[2]<*>[3]
18:28:03 <lambdabot>   [5,6,-1]
18:28:55 <Apocalisp> > [(+),(*),(-)]<*>[0..]<*>[0..]
18:28:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:29:01 <dmwit> :t (<$>)
18:29:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:29:09 <dblazakis_> @src (->) fmap
18:29:09 <lambdabot> fmap = (.)
18:29:19 <dmwit> :t (<*>)
18:29:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:29:50 <dblazakis_> :t fmap ($ 3) ($ 4)
18:29:51 <lambdabot> forall a b a1. (Num a1, Num a) => (a1 -> a -> b) -> b
18:30:06 <Apocalisp> > [(+),(*),(-)]<*>[2,3]<*>[4,5]
18:30:07 <lambdabot>   [6,7,7,8,8,10,12,15,-2,-3,-1,-2]
18:30:13 <Apocalisp> > [(+),(*),(-)]<$>[2,3]<$>[4,5]
18:30:14 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
18:30:23 <TomMD> Here is an odd benchmark: http://hpaste.org/11046
18:30:34 <Apocalisp> > (+)<$>[2,3]<$>[4,5]
18:30:35 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
18:30:42 <TomMD> For anyone interested, 1 thread == 4 seconds, 2 threads == 0.1 seconds
18:30:59 <Apocalisp> > (+2)<$>[2,3]<$>[4,5]
18:31:00 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
18:31:01 <Olathe> :o
18:31:12 <dblazakis_> TomMD: what's bm?
18:31:15 <Apocalisp> bah
18:31:18 <mmorrow> TomMD: time it without -threaded
18:31:21 <dmwit> TomMD: Magical!
18:31:45 <Olathe> bm is an abbr
18:31:48 <dmwit> TomMD: I don't suppose there were other users doing things on that machine at the time?
18:31:53 <Olathe> For benchmark.
18:32:06 <TomMD> dblazakis_: its now annotated with the code
18:32:08 <hackage> Uploaded to hackage: yjftp 0.3.1
18:32:09 <dblazakis_> Olathe: :-P -- what is the benchmark?
18:32:21 <TomMD> dmwit: This is on my personal (single user) laptop (core2)
18:32:27 <mmorrow> dmwit: i did this with a "mean" prog. using -N1 with a -threaded binary is /way/ slower that compiling without -threaded
18:32:28 <dblazakis_> TomMD: cool
18:32:57 <dmwit> mmorrow: interesting
18:32:58 <Apocalisp> > ($2)<$>[(*2),(+3)]
18:33:00 <lambdabot>   [4,5]
18:33:08 <TomMD> mmorrow: No -threaded is the same as -N1, 4 seconds
18:33:28 <TomMD> This is testing my latest producer/consumer control strat.
18:33:28 <mmorrow> ah, seeing your code it's probably a diff situation. i was using `par`
18:34:06 <TomMD> Which is in the Network.Engine module in the pasted code.
18:34:26 <mmorrow> dmwit: ok, ammending that stmt, with `par` that's the case ;)
18:34:46 <mmorrow> (or i should say "qualifying" ..)
18:36:50 <cpfr> :t (<$>)
18:36:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:37:49 <cpfr> @src (<$>)
18:37:50 <lambdabot> f <$> a = fmap f a
18:56:07 <romildo> What is the difference between the signals onCursorChanged and afterCursorChanged in a tree view?
18:59:32 <dmwit> romildo: after* is guaranteed to be called after *all* on* signals fire.
19:01:58 <jdrake> hey dmwit
19:02:19 <dmwit> Hiya!
19:02:28 <dmwit> Still fighting Haskell for the upper hand?
19:02:31 <jdrake> doing some rsa stuff :-)
19:02:58 <mmorrow> jdrake: nice, how's it coming?
19:03:05 <romildo> In the call back for the onCursorChanged I need the cursor position before and after the move. The later can be get with the treeViewGetCursor function. But how would I get the cursor before the move?
19:03:10 <jdrake> Let me upload the code
19:03:18 <mmorrow> jdrake: awesome
19:03:50 <romildo> Will I need a explict stateful variable for that?
19:04:01 <jdrake> http://hpaste.org/11029#a18
19:04:20 <jdrake> I am working on the sign function now, all of the rsa background stuff has a library I am doing
19:04:29 <jdrake> So it is only the outer part to prove an implementation
19:04:59 <jdrake> With out a few people in this channel this would not have been possible :-)
19:05:13 <sm> in a Utils module that reexports useful stuff, I have import qualified Data.Map as Map. Can that be exported as the qualified name ?
19:05:36 <dmwit> romildo: You might.  I'm not sure; I haven't used Gtk's trees very much.
19:05:52 <dmwit> sm: No.
19:06:11 <sm> thanks dmwit
19:07:08 <sm> can I at least export it qualified ?
19:07:52 <sm> it seems not.. "the export item module Data.Map exports nothing"
19:15:27 <Olathe> Is there an easy function from "31.25" -> 3125%100 ?
19:15:37 <Olathe> Or from 3125%100 -> "31.25" ?
19:15:51 <Olathe> read seems to expect a '%'.
19:16:29 <BMeph> > 31.25::Rational
19:16:30 <lambdabot>   125%4
19:17:01 <Paczesiowa> > read "31.25" :: Rational
19:17:01 <BMeph> > 125%4::Double
19:17:02 <lambdabot>   mueval: Prelude.read: no parse
19:17:03 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
19:17:03 <lambdabot>   Couldn't match expected type `Double'
19:17:23 <BMeph> > fromRational 125%4::Double
19:17:24 <lambdabot>   Couldn't match expected type `Double'
19:17:42 <BMeph> > fromRational (125%4)::Double
19:17:44 <lambdabot>   31.25
19:17:49 <Olathe> I got a parsing function made, but I don't like it.
19:18:02 <Olathe> > L.s "19823.129"
19:18:03 <lambdabot>   19823129%1000
19:19:58 <Plouj> hi
19:20:04 <Olathe> Hello.
19:20:05 <lispy> Plouj: welcome
19:20:40 <Plouj> I've noticed that haskell-mode (2.4) is unable to provide me with a valid indentation in one of the YAHT book examples
19:20:45 <Plouj> is this a know issue?
19:21:24 <sm> in the early stages of a project, when learning/prototyping/moving things around a lot, I want to avoid the use of explicit imports/exports for my code. I'll add them later when things stabilise. Is that resonable ?
19:21:52 <Plouj> line 18 seems to show the first problem http://codepad.org/LMthaj0O
19:21:52 <Paczesiowa> sure why not
19:21:53 <Axman6> sound reasonable to me
19:22:01 <Plouj> and that's the only indentation that haskell-mode gives me
19:22:04 <Plouj> (in Emacs)
19:22:29 <Paczesiowa> I never write explicit imports if it doesn't lead to disambiguity
19:22:37 <sm> great. I'm hoping I won't get into all kinds of avoidable dependency and poor design as a result
19:22:41 <Paczesiowa> or ambiguity
19:23:11 <Paczesiowa> sm: as long as it compiles you're safe:>
19:23:22 <Plouj> however, I don't actually understand the indentation rules, and I've seen an example where not indenting "then" farther than the "if" was ok
19:23:34 <sm> I think as long as I understand it I'm safe :)
19:24:12 <Plouj> humm, codepad seems to like the syntax, but not my ghci
19:24:21 <lispy> sm: explicit exports are not a bad idea
19:24:34 <Paczesiowa> Plouj: do you use tabs?
19:24:35 <lispy> sm: I can understand a reluctance on explicit imports during development
19:24:38 <Plouj> Paczesiowa: no
19:24:57 <Paczesiowa> Plouj: good
19:26:03 <dons> ok. for fun, if you want to see cabal-install install all of hackage, most of the haskell code in the world, here's what it looks like
19:26:06 <dons>  galois.com/~dons/tmp/install-everything.ogv
19:26:30 <dcoutts> well, not actually install, just decide what versions it's going to install
19:26:42 <lispy> dons: what is .ogv?
19:26:45 <dons> and start installing it.
19:26:47 <dcoutts> still, there's a lot of code there
19:26:53 <Paczesiowa> lispy: movie
19:26:54 <dons> lispy: ogg vorbis. so run it mplayer
19:26:59 <sm> ouch.. hung my safari
19:27:09 <dons> nice. go safari
19:27:11 <lispy> dons: I'm on osx, does mplayer even make sense?
19:27:18 <dons> no idea :-)
19:27:24 <Paczesiowa> movie from installing software?
19:27:30 <dons> yeah :-)
19:27:45 <dons> it's just fun to say 'install this' and watch cabal work out how to solve the install problem
19:27:47 <Plouj> http://codepad.org/EW7UNjvB
19:27:48 <Paczesiowa> why not post gzipped output so we can have some popcorn and grep it
19:27:53 <dons> hehe
19:27:57 <lispy> supposedly itunes can do it, possibly via a plugin
19:28:00 <sm> go cabal
19:28:24 <dons> anyone able to view the video? :)
19:28:47 <hansfbaier> lispy: http://www.vorbis.com/setup_osx/
19:28:57 <sm> not me.. on linux, I could view mpeg and ogg. on mac I can view quicktime. the more things change..
19:28:58 <Plouj> yeah, it's streaming for me
19:28:58 <lambdabot> Title: Vorbis.com: Mac OS X Setup
19:29:01 <hansfbaier> lispy: google is your friend :)
19:29:08 <Paczesiowa> lispy: mplayer works ok on osx and if you like qt4 there is great frontend smplayer
19:29:14 <dons> ok.
19:29:21 <dcoutts> Paczesiowa: better, we've got build summary reports (machine readable) and individual package build logs
19:29:31 <dons> the graph of deps it is constructing an install plan for looks like htis, btw, http://galois.com/~dons/tmp/hackage.png
19:29:36 <dons> that's why it is fun + hard.
19:29:38 <Plouj> wow, I forgot what big terminus looked like
19:30:20 <dblazakis_> dcoutts: have you started any work to phrase the cabal constraint problem as a SAT instance? i saw the galois talk thing dons linked
19:30:50 <dcoutts> dblazakis_: expressing the problem in terms of SAT is relatively easy
19:30:52 <lispy> hansfbaier: thanks.  I found that but the installation is non-trivial so I gave up
19:31:18 <dcoutts> dblazakis_: getting a solver that can give ok error messages is rather harder
19:31:20 <dblazakis_> dcoutts: any reason that method isn't used?
19:31:22 <dblazakis_> ahhh
19:31:30 <maxote> what's SAT?
19:31:34 <dmwit> dons: video works good here
19:31:39 <dcoutts> dblazakis_: and I'm really not sure how to get it to pick amongst valid solutions according to preferences
19:31:46 <maxote> !cabal
19:31:57 <maxote> @cabal
19:31:57 <lambdabot>   bzzt.
19:32:19 <dmwit> ?hackage cabal-install
19:32:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
19:32:28 <inimino> what's the thing in the upper left in that video?
19:32:41 <dmwit> That tells what workspace he's on.
19:32:52 <dmwit> xmonad + dzen, it looks like
19:33:16 <inimino> sorry, upper right
19:33:19 <Plouj> so, umm, does anyone know why I'm getting that ghci error?
19:33:24 <inimino> the status-looking thing
19:33:48 <dcoutts> dblazakis_: the best example of a preference is the difference between cabal install and upgrade, which is if we should prefer already installed packages, or prefer to upgrade all packages
19:33:55 <dmwit> Plouj: link?
19:33:58 <Paczesiowa> Plouj: what error?
19:34:04 <Plouj> http://codepad.org/EW7UNjvB
19:34:17 <Plouj> /home/plouj/programming/Guess.hs:18:2: parse error (possibly incorrect indentation)
19:34:23 <dons> inimino: oh, that's dzen + some gnome apps running in xmonad
19:34:43 <dmwit> Plouj: You have to indent "then" and "else" at least one space more.
19:34:44 <dblazakis_> maxote: boolean satisfiability -- the OG of NP problems
19:34:46 <Paczesiowa> Plouj: you have to indent ifs inside do a little bit different
19:35:13 <Plouj> codepad doesn't think so
19:35:18 <dmwit> Yes it does.
19:35:20 <Paczesiowa> ghci does
19:35:20 <maxote> what means OG and NP?
19:35:22 <dmwit> See the error at the bottom?
19:35:39 <dmwit> maxote: NP means non-deterministic polynomial time.
19:35:57 <maxote> dmwit, and OG?
19:36:00 <dmwit> not sure
19:36:10 <lispy> original gansta
19:36:12 <dblazakis_> maxote: bad joke -- original gansta , old skool
19:36:17 <Axman6> oh, heh. i thought you were talking about time in the other sense. i thought time was only linear :)
19:36:27 <dblazakis_> maxote: sorry :-)
19:36:30 <Plouj> Paczesiowa: the YAHT book shows that I should indent "if" as far as "let" : http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics#Interactivity
19:36:32 <lambdabot> http://tinyurl.com/297cq5
19:36:40 <maxote> is not NP non-polynomial?
19:36:42 <Adamant_> you pretty much equate everything to SAT or a variant if you're trying to prove it's NP
19:36:48 <Plouj> dmwit: for some reason haskell-mode for Emacs doesn't let me indent "then" and "else" any other way
19:36:54 <inimino> dons: which gnome apps?  I might try that
19:36:55 <Adamant_> nondeterministic polynomial
19:37:10 <maxote> but, is it polynomial or exponential?
19:37:15 <Adamant_> we don't know
19:37:39 <Adamant_> whether NP = P or not is a Millenium Problem math question
19:37:47 <Adamant_> solve it and get a million
19:37:48 <Paczesiowa> Plouj: same here
19:37:58 <maxote> Adamant_, no thanks
19:38:02 <Plouj> also, codepad doesn't mind my indentation: http://codepad.org/nrqQpY7B
19:38:02 <dmwit> maxote: All polynomial-time algorithms are alse NP algorithms.
19:38:07 <maxote> it's very chaotic
19:38:14 <dmwit> maxote: There is a class of NP problems called NP-complete problems.
19:38:25 <dmwit> maxote: These are "as hard as it gets" in the NP class.
19:38:34 <Adamant_> solve one, solve them all
19:38:36 <maxote> yes, from sr. Cook
19:38:46 <dmwit> If you can prove that any one of them can be done in polynomial time, it would be a very important result.
19:38:57 <dmwit> Similarly if you can prove any one of them can *not* be done in polynomial time.
19:38:57 <Paczesiowa> Plouj: emacs haskell-mode bug
19:39:02 <inimino> dons: your Apache is sending that file as text/plain
19:39:13 <dblazakis_> dcoutts: do efficient solvers with "weighted" literals exist? prefering to solve an instance with a given literal as true, that is
19:39:14 <maxote> dmwit, it's NP-co
19:39:19 <dons> inimino: hmm, so in trayer, gnome-power-manager and nm-applet
19:39:26 <Paczesiowa> Plouj: you can use "case cond of True ->; False -> ;" instead of if thenelse
19:39:48 <maxote> my question is
19:40:10 <inimino> dons: oh, trayer sounds like what I'm interested in.  it's the only thing I miss in xmonad
19:40:13 <Plouj> I'll try the ltatest release of haskell-mode
19:40:31 <maxote> is practical that solving P = NP costs you 1 million of dollars? what about $700'000 millions of dollars of the Bush bailout?
19:40:35 <Plouj> erm, it's 2.4 :(
19:40:50 <Paczesiowa> Plouj: what distro?
19:40:56 <Plouj> Fedora9
19:41:02 <Adamant_> maxote: it was donated by a millionare to a foundation that did the Millenium Problems
19:41:10 <mmorrow> would anyone happen to know what a "theta type" is in common usage
19:41:12 <mmorrow> ?
19:41:13 <Paczesiowa> Plouj: I have module Main
19:41:13 <Paczesiowa>     where
19:41:13 <Paczesiowa> import IO
19:41:13 <Paczesiowa> import Random
19:41:13 <Paczesiowa> main = do
19:41:14 <Paczesiowa>   hSetBuffering stdin LineBuffering
19:41:14 <Adamant_> I don't see how the government factors into it
19:41:16 <Paczesiowa>   num <- randomRIO (1::Int, 100)
19:41:18 <Paczesiowa>   putStrLn "I'm thinking of a number between 1 and 100"
19:41:20 <Paczesiowa>   doGuessing num
19:41:22 <Paczesiowa> doGuessing num = do
19:41:24 <Paczesiowa>   putStrLn "Enter your guess:"
19:41:24 <dmwit> stop it, please
19:41:26 <Paczesiowa>   guess <- getLine
19:41:28 <Paczesiowa>   let guessNum = read guess
19:41:30 <Paczesiowa>   if guessNum < num
19:41:32 <Paczesiowa>     then do putStrLn "Too low!"
19:41:34 <Paczesiowa>             doGuessing num
19:41:36 --- mode: ChanServ set +o Saizan
19:41:36 <Paczesiowa>     else if guessNum > num
19:41:38 <Paczesiowa>            then do putStrLn "Too high!"
19:41:40 <Paczesiowa>                    doGuessing num
19:41:41 --- mode: Saizan set +b *!*n=quassel@*.adsl.inetia.pl
19:41:49 <Axman6> idiot
19:41:53 <mmorrow> would anyone happen to know what a "theta type" is in common usage?
19:41:57 <mml`> @paste
19:41:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:42:06 <mml`> Paczesiowa: ^^
19:42:08 <Saizan> Paczesiowa: i'm going to unban you shortly
19:42:15 <maxote> feedback to the millionare that there is not the wanted answer to this question
19:42:19 <Saizan> Paczesiowa: make sure you're not still pasting a lot of lines
19:42:41 <Adamant_> maxote: if you prove it's not equal, you still get the million
19:42:51 --- mode: Saizan set -b *!*n=quassel@*.adsl.inetia.pl
19:43:03 <maxote> it hurts my brain much! no, thanks!
19:43:05 --- mode: Saizan set -o Saizan
19:43:16 <lispy> is eigentype a common phrase?
19:43:22 <lispy> I noticed it in an oleg paper
19:43:39 <Axman6> i've heard of eigen vectors and eigen values...
19:43:47 <lispy> it refers to fresh type names when you bind an existentially quantified type
19:43:52 <BMeph> lispy: I doubt anything in an Oleg paper is "common". ;)
19:43:58 <Axman6> heh
19:44:00 <jdrake> Is there a way I can do this without a parse error?     putStrLn ("n: " ++ (show n)) where (n, _) = privkey
19:44:01 <lispy> It's a really handy term
19:44:11 <Plouj> dang, Haskell indentation is really annoying
19:44:30 <Saizan> jdrake: use let
19:44:36 <Axman6> Plouj: how so?
19:44:49 <jdrake> Saizan, so this method won't work in any way?
19:45:13 <Saizan> jdrake: where only attaches to declarations, not expressions
19:45:14 <Plouj> Axman6: 1 - I still don't get it so I try to rely on automatic tools. 2 - automatic tools don't handle it well, because it's so complex.
19:45:21 <dblazakis_> Plouj: if it bothers you too much, then don't use layout, use semicolons and curly braces
19:45:33 <Axman6> just use let (n,_) = privkey in putStrLn ("n: " ++ (show n))
19:45:34 <jdrake> If I use let, I would want to assign both n and d, is there a way to have both commands follow each other?
19:45:55 <Axman6> Plouj: it's not complex, just need to remember tyhe offside rule
19:46:02 <lispy> Plouj: just to make sure, your editor is only emitting spaces right? no tab characters?
19:46:12 <Plouj> lispy: yes, spaces
19:46:24 <lispy> Plouj: good, otherwise it would be even worse :)
19:47:05 <Saizan> Plouj: indentation of if/then/else is broken in the standard haskell-mode, for the rest at least one of the alternatives work :)
19:47:06 <Plouj> this is really slowing down my learning process
19:47:31 <sm> haskell-mode made it really easy for me.. just keep hitting tab till it looks right
19:47:37 <Saizan> jdrake: can you rephrase?
19:47:47 <Plouj> Saizan: what's the alternative? I hope you don't mean Vim.
19:47:49 * sm still doesn't know the rules
19:47:52 <jdrake> nvm, it seems that do will work
19:47:52 <Paczesiowa> sm: we just found bug in it, so...
19:48:15 <Saizan> Plouj: i mean the various indentations you get by hitting tab repeadetly
19:48:16 <sm> I think my heuristic still works ?
19:48:19 <Paczesiowa> Plouj: if-then-statements are rare inside do-notation
19:48:42 <sm> or I've been lucky. Thanks for working on it
19:48:57 <mmorrow> Plouj: just imagine vertical lines going down the page from the first char on pretty much /every/ line. then any line which is a sub-part of that line's content cannot touch that initial vertical line.
19:49:25 <mmorrow> and by "touch" i mean:
19:49:29 <mmorrow> if asdfghj
19:49:32 <mmorrow> then fghyujki
19:49:37 <Plouj> what I imagine is the editor properly indenting my code as soon as I press [return], like it does for C code :)
19:49:42 <mmorrow> => the 't' in then is touching
19:50:02 <mmorrow> Plouj: i never use auto indenting with haskell code
19:50:07 <Paczesiowa> Plouj: is it even possible with layout-indentation?
19:50:08 <Plouj> mmorrow: I don't yet know what constitutes a "sub-part"
19:50:17 <inimino> but it's not actually every line, it's only 'let', 'where', 'do', and 'of'.
19:50:28 <Axman6> Plouj: C doesn't care about indentation, so it;s easy
19:50:56 <mmorrow> inimino: true, i was simplifying it with a "rule of thumb"
19:51:10 <mmorrow> which was very rough
19:51:22 <inimino> mmorrow: right
19:51:29 <Plouj> I can't believe haskell-mode uses a debian bug-tracker
19:51:40 <Plouj> it's not like it's installable only on Debian systems...
19:51:42 <inimino> but it is actually not bad once you get used to reading it
19:52:19 <inimino> it did take me a while though
19:52:34 <mmorrow> yeah, haskell indentation is friggin great. makes reading it easier imo
19:52:54 <inimino> yeah, I agree it is great for reading
19:53:19 <inimino> maybe as hard as monads to learn though :-)
19:53:34 <mmorrow> heh, i dunno about that..
19:54:16 <steven_ashley> is anyone aware of why parsec's 'buildExpressionParser' is restricted such that prefix and postfix operators of the same precedence can only occur once?
19:54:31 <mmorrow> Plouj: it's precisely specified here: http://www.haskell.org/onlinereport/lexemes.html
19:54:31 <lambdabot> Title: Haskell 98 Lexical Structure
19:54:35 <mmorrow> see section 2.7
19:54:53 <mmorrow> that describes it, and
19:55:02 <mmorrow> seciton 9.3 defines it precisely
19:55:09 <mmorrow> http://www.haskell.org/onlinereport/syntax-iso.html#layout
19:55:10 <lambdabot> Title: Haskell 98 Syntax
19:56:22 <dcoutts> dblazakis_: yes, they do. It's apparently possible with SAT, CP and SMT. It just needs a bit more investigating to work out which would be most easily doable.
19:56:38 <inimino> I think the biggest hangup is that when layout does something you don't expect, it can be hard to see from the compiler error messages what went wrong
19:57:14 <inimino> probably an editor with explicit Haskell support could make this go away
19:57:21 <jdrake> Stack space overflow: current size 8388608 bytes.
19:57:21 <jdrake> Use `+RTS -Ksize' to increase it.
19:57:26 <jdrake> Where do you use this?
19:57:43 <inimino> jdrake: on the command line when you run the program
19:57:49 <Paczesiowa> jdrake: ./myfile +RTS ...
19:58:02 <jdrake> What if I am passing my own parameters as well?
19:58:11 <Paczesiowa> jdrake: don't worry
19:58:22 <ozy`> <inimino> probably an editor with explicit Haskell support <== that would be emacs and... emacs?
19:58:24 <Paczesiowa> jdrake: ghc runtime doesn't pass RTS params to your code
19:58:37 <inimino> jdrake: use +RTS -Ksize -RTS [your params]
19:58:55 <inimino> ozy`: I don't know, Yi?
19:59:02 <jdrake> A simple signing of a 1.5mb file takes a long time
19:59:24 <jdrake> I am wondering if this is something that I really want :p
19:59:31 <ozy`> yi's all right as a layout tool but I wouldn't call it a text editor just yet...
19:59:32 <Saizan> jdrake: if you're getting a stack overflow you're probably doing something wrong
19:59:33 <inimino> ozy`: I don't think even emacs haskell-mode does what I was thinking of, which is make the vertical lines explicit
19:59:46 <jdrake> Saizan, everything of real interest is inside the RSA library
19:59:54 <jdrake> I didn't make that
20:00:16 <inimino> ozy`: or even optionally show the added braces and semicolons
20:00:42 <Saizan> jdrake: even a simple iteration on your part can cause a stack overflow
20:00:54 <jdrake> Saizan, I don't have any iterations
20:01:12 <Saizan> recursion? foldl? foldr?
20:01:24 <jdrake> nothing
20:01:47 <jdrake> and 16mb stack fixed the overflow problem
20:02:11 <newsham> are you signing the whole 1.5MB file data or signing a hash of the file data?
20:03:07 <jdrake> newsham, the library is doing it so I don't know. But given the output I think it would be the hash.
20:03:27 <jdrake> But if a hash was causing this much time, then it is a really crappy implementation
20:03:53 <newsham> thats what i'm thinking
20:04:06 <newsham> which lib?
20:04:08 <Saizan> how did you build it?
20:04:22 <jdrake> Saizan, imported and --make
20:04:33 * inimino wonders if he is the only one that tried to scroll up in that video
20:04:36 <Saizan> so you copied the sources in your tree?
20:04:39 <jdrake> yes
20:04:42 <jdrake> --Copyright 2001, 2002, 2003 David J. Sankel
20:04:43 <jdrake> --
20:04:43 <jdrake> --This file is part of rsa-haskell.
20:05:13 <Saizan> that's not how you usually install libraries.. however you might try compiling with -O2 then
20:05:27 <mmorrow> ALWAYS use -O2 :)
20:05:33 <Saizan> pass -fforce-recomp, so that you're sore everything is recompiled with optimizations
20:05:40 <Saizan> "sure"
20:06:15 <jdrake> I was just about to ask about that ;-)
20:06:54 <dblazakis_> dcoutts: sounds interesting, thanks
20:07:12 <jdrake> ok, that was faster
20:07:29 <jdrake> Saizan, thank you and I didn't even need the 16mb stack
20:07:58 <jdrake> Now I need to convert an arbitrary length string into a hex code form
20:09:01 <sm> ho ho ho.. this code just keeps compressing, I love it
20:10:04 <bd_> Saizan: is that a real option? It's not in gcc 4.2.3's info pages
20:10:29 <lispy> bd_: that's an option to ghc
20:10:34 <bd_> ahh
20:10:58 <jdrake> bd_, gcc also doesn't have --make, and that is what its for :-)
20:11:09 <bd_> here I was thinking this was some sort of joke about gentoo :)
20:11:14 <bd_> that's what I get for not scrolling up
20:11:48 <jdrake> bd_, making jokes about gentoo is really old by this point :-)
20:15:05 <jdrake> What are the haskell boolean operators?
20:15:41 <Saizan> ?hoogle Bool -> Bool -> Bool
20:15:41 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:15:43 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
20:15:45 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
20:15:54 <bd_> don't forget /=
20:15:54 <Saizan> ?hoogle Bool -> Bool
20:15:55 <lambdabot> Prelude not :: Bool -> Bool
20:15:55 <lambdabot> Data.Bool not :: Bool -> Bool
20:15:55 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:15:55 <bd_> (xor)
20:16:30 <jdrake> What about shifting
20:16:33 <Olathe> > let toBase _ 0 = "0"; toBase base n = reverse $ map (digit.flip mod base) $ takeWhile (> 0) $ iterate (`div` base) n where digit n = (['0'..'9'] ++ ['a'..'z']) !! n in toBase 16 19823
20:16:35 <lambdabot>   "4d6f"
20:16:49 <bd_> jdrake: That's the Bits class
20:16:55 <bd_> in Data.Bits
20:17:11 <jdrake> ok, now that i am thinking I shouldn't have to do anything with shifting
20:17:18 <bd_> why? :)
20:17:20 <bd_> :t shiftL
20:17:21 <lambdabot> forall a. (Bits a) => a -> Int -> a
20:17:26 <bd_> > 4 `shiftL` 1
20:17:27 <lambdabot>   Add a type signature
20:17:30 <bd_> > 4 `shiftL` 1 :: Int
20:17:32 <lambdabot>  Terminated
20:17:33 <jdrake> printf can do what I need
20:17:36 <bd_> terminated?!
20:17:37 <bd_> > 4 `shiftL` 1 :: Int
20:17:39 <lambdabot>   8
20:18:30 <jdrake> Can I map a function of a [Char] and having the function return two chars?
20:18:42 <jdrake> I need to convert the string to a hex representation
20:18:51 <jdrake> So it is 1 char in 2 out for hex
20:18:54 <Paczesiowa> concatmap
20:19:08 <jdrake> :t concatmap
20:19:09 <lambdabot> Not in scope: `concatmap'
20:19:20 <Paczesiowa> > concatMap (\c -> [c, c]) "hello"
20:19:21 <lispy> jdrake: you didn't like the read solution?
20:19:22 <lambdabot>   "hheelllloo"
20:19:45 <jdrake> lispy, I didn't see one
20:20:05 <lispy> > read "0xffffffffffffffffffffffffffffffffffffffffffffffffffff" :: Integer
20:20:07 <lambdabot>   411376139330301510538742295639337626245683966408394965837152255
20:20:39 <lispy> jdrake: or you wanted to go the other direction?
20:20:45 <jdrake> string to hex
20:20:55 <lispy> jdrake: what is a hex?
20:21:27 <lispy> jdrake: can you give me a few input/output pairs for your function?
20:21:30 <jdrake> Say I had "hello"
20:21:39 <jdrake> : ord 'h'
20:21:48 <jdrake> > ord 'h'
20:21:50 <lambdabot>   104
20:22:09 <jdrake> > printf "%x" 104
20:22:10 <lambdabot>   Add a type signature
20:22:15 <jdrake> > printf "%x" 104::Int
20:22:16 <lambdabot>       No instance for (PrintfType Int)
20:22:16 <lambdabot>        arising from a use of `printf' ...
20:22:23 <jdrake> > printf "%x" (104::Int)
20:22:24 <ddarius> "hello" >>= \c -> [c,c]
20:22:25 <lambdabot>   Add a type signature
20:22:31 <jdrake> > printf "%x" (104::Int)::String
20:22:32 <lambdabot>   "68"
20:22:33 <lispy> > printf "%x" 104 :: String
20:22:38 <lambdabot>   "68"
20:23:24 <jdrake> > concatMap (\x -> printf "%x" (ord x)::String) "Hello"
20:23:25 <lispy> > concatMap (\x -> printf "%x" (ord x)) "hello"
20:23:26 <lambdabot>   "48656c6c6f"
20:23:27 <lambdabot>   Add a type signature
20:23:39 <lispy> ?quote fugue
20:23:39 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:23:40 <jdrake> I win :p
20:24:16 <ddarius> > "hello" >>= printf "%x" . ord
20:24:17 <lambdabot>   Add a type signature
20:24:53 <jdrake> > "hello" >>= printf "%x"::String . ord
20:24:54 <lambdabot>   mueval: Prelude.read: no parse
20:25:04 <lispy> > printf "%x" 1 :: String
20:25:06 <lambdabot>   "1"
20:25:10 <jdrake> > "hello" >>= printf "%x" . ord :: String
20:25:11 <lambdabot>   "68656c6c6f"
20:25:12 <lispy> > printf "%x.2" 1 :: String
20:25:13 <Paczesiowa> "hello" >>= (printf "%x"::String) . ord
20:25:13 <lambdabot>   "1.2"
20:25:20 <lispy> > printf "%.2x" 1 :: String
20:25:43 <jdrake> Ok, so we have    concatMap (\x -> printf "%x" (ord x)::String) "Hello"  and > "hello" >>= printf "%x" . ord :: String
20:25:54 <jdrake> I am not sure I understand the latter
20:26:11 <inimino> >>= in the list monad is concatMap
20:26:18 <ddarius> The latter is exactly the same
20:26:24 <Axman6> @src [] >>=
20:26:35 <Axman6> @src [] (>>=)
20:26:36 <jdrake> So I will use mine then, I understand it
20:26:41 <Axman6> lambdabot!
20:26:47 <Olathe> > (printf "%x" . ord) "hello"
20:26:52 <Olathe> > map (printf "%x" . ord) "hello"
20:27:09 <Olathe> lambdabot is dead :(
20:27:15 * ddarius blames lispy.
20:27:35 <Paczesiowa> > concatMap (\x -> printf "%x" (ord x)) "Hello"
20:27:36 <Olathe> This is like a running gag that's not funny.
20:28:03 <Axman6> Cale: lambdabot seems to need resuscitation
20:28:23 <Olathe> We need a bot that can restart lambdabot.
20:28:41 <ddarius> We already have Cale.
20:28:43 <Olathe> With @zomg
20:28:55 <lambdabot>   thread killed
20:28:59 <dons> ?uptime
20:28:59 <lambdabot> Source not found. Maybe you made a typo?
20:28:59 <lambdabot> xs >>= f     = concatMap f xs
20:28:59 <lambdabot> uptime: 4d 7h 35m 10s, longest uptime: 1m 10d 23h 44m 29s
20:29:03 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
20:29:03 <lambdabot>   Add a type signature
20:29:05 <lambdabot>   Add a type signature
20:29:13 <Paczesiowa> laggy
20:29:16 <Axman6> @src [] (>>=)
20:29:16 <lambdabot> xs >>= f     = concatMap f xs
20:29:16 <Olathe> > map (printf "%x" . ord) "hello"
20:29:17 <lambdabot>   Add a type signature
20:29:24 <Olathe> > map (printf "%x" . ord) "hello" :: [String]
20:29:25 <lambdabot>   ["68","65","6c","6c","6f"]
20:29:30 <Olathe> What else would it be ?
20:29:40 <Olathe> @type map (printf "%x" . ord) "hello"
20:29:42 <Paczesiowa> Olathe: printf can also go in IO
20:29:43 <lambdabot> forall c. (PrintfType c) => [c]
20:29:46 <Olathe> Oh.
20:29:48 * adu <3 Haskell
20:29:53 <adu> it helped so much today
20:30:04 <Olathe> > concat $ map (printf "%x" . ord) "hello"
20:30:05 <lambdabot>   Add a type signature
20:30:10 <Olathe> @type concat $ map (printf "%x" . ord) "hello"
20:30:11 <lambdabot> forall a. (IsChar a) => [a]
20:30:23 <Olathe> @instances IsChar
20:30:24 <lambdabot> Couldn't find class `IsChar'. Try @instances-importing
20:30:50 <sm> adu: how so ?
20:30:50 <lispy> that was insane
20:30:54 <Paczesiowa> Olathe: that is for being h98 compatible
20:30:56 <lispy> while lambdabot was blocked I was too
20:31:13 <Paczesiowa> Olathe: you can't do instance String in h98
20:31:27 <lispy> whoa, load average: 2.08, 6.60, 3.58
20:31:28 <Paczesiowa> Olathe: so there is class IsChar with single instance Char
20:31:48 <Olathe> Ahh.
20:32:08 <hackage> Uploaded to hackage: uuid 1.0.0
20:32:13 <jdrake> Ok, now conversely, what could you do to consume two characters at a time and output 1?
20:32:14 <lispy> jdrake: so I don't know if you noticed, but you need to change the "%x" so that it outputs 2 chars per hex if you're not going to use delimiters
20:32:33 <lispy> > printf "%2x" 1 :: String
20:32:34 <lambdabot>   " 1"
20:32:37 <Paczesiowa> jdrake: split list to lists of two
20:32:43 <lispy> > printf "%0.2x" 1 :: String
20:32:45 <lambdabot>   "1"
20:32:47 <Olathe> @type "hello" >>= printf "%x" . ord
20:32:47 <lispy> hmm
20:32:48 <adu> sm: well, basically I had to fix an algorithm that had 2 implementations, and I couldn't figure out what either of them were doing, so I implemented in Haskell and it didn't match up with the outputs so I realized my understanding of the algorithm was wrong, so I kept reimplementing it in Haskell until it mached the outputs, and when it did, the Haskell was so very clear that I immediately understood the algorithm
20:32:48 <lambdabot> forall b. (IsChar b) => [b]
20:32:55 <Olathe> @type "hello" >>= printf "\\x%x" . ord
20:32:56 <lambdabot> forall b. (IsChar b) => [b]
20:33:05 <Olathe> > "hello" >>= printf "\\x%x" . ord :: String
20:33:06 <lambdabot>   "\\x68\\x65\\x6c\\x6c\\x6f"
20:33:13 <lispy> adu: I want to @quote that :)
20:33:20 <Eridius> can any emacs users tell me how to make emacs stop showing that intro window every time I launch it?
20:33:29 <adu> lispy: please do
20:33:43 <Paczesiowa> Eridius: launch it with parameter of source file
20:33:47 <adu> but for obvious reasons, I can't describe the algorithm
20:33:54 <Eridius> Paczesiowa: doesn't help. It opens up horizontally split
20:33:58 <Eridius> with the intro window on the lower half
20:34:16 <Paczesiowa> Eridius: sorry, works here
20:34:51 <Eridius> Paczesiowa: actually, that works with console emacs, but not with xemacs
20:34:53 <sm> nice.. I did that with a ruby app once
20:35:05 <Olathe> > "\x68\x65\x6c\x6f"
20:35:07 <lambdabot>   "helo"
20:35:11 <Paczesiowa> Eridius: I don't use xemacs - ugly
20:35:20 <sm> actually I was just writing out the data model, not even an algorithm
20:35:22 <Eridius> Paczesiowa: I do because I like to open up multiple frames
20:36:02 <Paczesiowa> Eridius: sounds like your environment can't handle lot of workspaces and windows
20:36:10 <Eridius> what do you mean?
20:36:11 <jeffz> Eridius: never leave emacs
20:36:37 <Eridius> I open up multiple frames so I can view multiple things at once without having one massive window covering my entire screen
20:36:42 <Paczesiowa> Eridius: I just think that handling windows and tabs shouldn't be handled by an app, but by window manager
20:36:52 <Eridius> Paczesiowa: which is why I open up multiple frames in emacs
20:37:03 <Eridius> remember that in emacs terms, a frame is an OS window
20:37:03 <Paczesiowa> Eridius: is that like a tab?
20:37:11 <Eridius> no tabs
20:37:17 <Eridius> it opens up a new OS window
20:37:29 <Paczesiowa> if it is a window why not fire up few emacs instances?
20:37:36 <Paczesiowa> those console ones
20:37:48 <Eridius> because then I have to open up several terminal windows and navigate to the right location
20:38:06 <Eridius> and besides, the appearance of xemacs is more customizable than console emacs
20:38:29 <Eridius> also, xemacs can use my  key as the meta key, while emacs has to use alt
20:38:38 <adu> jeffz: lolol
20:38:40 <lament> appearances can be deceiving... because they're customizable!
20:39:35 <adu> jeffz: so many times I C-z out to run a quick command, then I remember about M-x eshell and start feeling stupid
20:40:21 <jeffz> adu, can't say I exit emacs more than once a month, yeah, eshell is reasonable, I have a habit of using M-x ansi-term though.
20:41:40 <Paczesiowa> I admire you hardcore users
20:42:50 <jdrake> Can I use (a:b:xs) as a pattern to get the first two items out and leave the rest?
20:43:13 <Axman6> yes
20:43:55 <adu> Eridius: you should learn about C-x 2
20:43:55 <adu> jeffz: wow you can run 'man' in ansi-term...
20:43:56 <sm> System.Locale is in the old-locale package.. is there some newer place I should be getting it from ?
20:44:10 <sm> I guess not, for ghc 6.8
20:44:22 <Eridius> adu: I know how to split windows, but I like having multiple frames when I don't want to shrink my edit area
20:44:28 <Eridius> I want to reference another file, so I open up a new frame with that file
20:44:32 <jdrake> Is haskell vulnerable to endianness?
20:45:14 <Axman6> i doubt it
20:45:33 <dons> jdrake: if you serialise structures to some bit encoding.
20:46:16 <jdrake> dons, some encoding is necessary to pass two chr's ordinals to chr to produce a single character, I have to shift left
20:47:05 <jdrake> hmm, I have been thinking about this a little wrongly
20:47:15 <adu> sm: ask RossPaterson, he's the one to make locale => old-locale
20:47:29 <jdrake> time for a break
20:48:12 <dons> jdrake: you can certainly shift things into bytes in a endian dependent way
20:48:20 <dons> hence putWord16be :: Word16 -> Builder
20:48:26 <dons> and putWord16le :: Word16 -> Builder
20:48:30 <dons> in Data.Binary, for example.
20:49:00 <jdrake> Anything to convert a number in hex into a number in decimal?
20:49:10 <dons> to parse it?
20:49:22 <dons> and then pretty print it in a different format?
20:49:22 <jdrake> yeah, I really want an Int out of the string containing hex
20:49:30 <dons> :t readHex
20:49:31 <adu> my favorite endian model is scheme's (r6rs)
20:49:32 <lambdabot> forall a. (Num a) => String -> [(a, String)]
20:50:14 <jdrake> > readHex "7f"
20:50:15 <lambdabot>   mueval: Prelude.read: no parse
20:50:31 <jdrake> > readHex "0x7f"
20:50:32 <lambdabot>   mueval: Prelude.read: no parse
20:50:46 <TSC> @index readHex
20:50:46 <lambdabot> Numeric
20:50:48 <lispy> readHex probably isn't imported into mueval
20:51:02 <dons> > readHex "ff"
20:51:03 <lambdabot>   mueval: Prelude.read: no parse
20:51:03 <lispy> and mueval has some pretty terrible error messages
20:51:05 <sm> is Build-Depends: QuickCheck-1.1  valid cabal ?
20:51:07 <dons> yeah, mueval sux
20:51:12 <TSC> Prelude Numeric> readHex "7f"
20:51:12 <TSC> [(127,"")]
20:51:12 <TSC>  
20:51:31 <dons> sm: yeah, but overly precise
20:51:31 <jdrake> What is the string output?
20:51:35 <adu> sm: I don't know if you need the version number
20:51:36 <dons> the rest of the parse
20:51:51 <dons> sm, you probably mean QuickCheck==1.* or QuickCheck >= 1 && < 2
20:52:01 <dons> gives us a chance for future compat.
20:52:15 <TSC> readHex "7f blah" ==> [(127," blah")]
20:52:18 <sm> thanks!
20:52:19 <lispy> jdrake: so, a couple problems with what you're doing.  Char is much larger than just 1 byte.  So, printf "%x" could be several characters.  Or, printf "%x" 1, could be smaller than 2 characters.
20:52:44 <sm> I'm just trying to distinguish between 1 and 2 to fix a "Test.QuickCheck does not export test". It builds from my makefile, but not from cabal
20:53:05 <dblazakis_> what's a good way to maintain some statistics -- do i really have to thread a monad through now?
20:53:08 <lispy> jdrake: you need to convert the chars to something like Char8, but I don't think that exists.  Then you need to ensure that small values print with leading 0
20:53:23 <dons> dblazakis_: you want to collect what kind of information?
20:53:26 <lispy> :t Char8
20:53:27 <lambdabot> Not in scope: data constructor `Char8'
20:53:29 <dons> Word8
20:53:43 <jdrake> lispy, you mean in my old code above?
20:53:54 <lispy> jdrake: I admit, I haven't been following closely
20:54:07 <dblazakis_> a few counters, but i want to sprinkle the mutations over a few functions
20:54:41 <jdrake> Lispy, this is my function:  string2hex = concatMap (\x -> printf "%x" (ord x)::String)
20:55:25 <lispy> jdrake: right, so take a look at ord
20:55:29 <lispy> :t ord
20:55:29 <lambdabot> Char -> Int
20:55:52 <lispy> > maxBound :: Char
20:55:54 <lambdabot>   '\1114111'
20:56:07 <lispy> > maxBound :: Word8
20:56:08 <lambdabot>   255
20:56:28 <lispy> jdrake: so if you want to output 2 hex digits per Char, you might have a problem.
20:56:48 <jdrake> yes
20:57:32 <lispy> > printf "%x" 1 :: String
20:57:33 <lambdabot>   "1"
20:57:47 <lispy> jdrake: and here we have 1 hex digit instead of two, "01"
20:58:19 <Olathe> > printf "%02x" 1 :: String
20:58:21 <lambdabot>   "01"
20:58:26 <jdrake> lovely
20:58:26 <Olathe> Take that, Internet !
20:59:04 <lispy> Olathe: thanks, I was trying to put a . in there but I couldn't find my man page for printf :)
20:59:15 <lispy> "%0.2x" is what I thought the syntax was
20:59:22 <pjdelport> that's for floats
20:59:33 <lispy> > printf "%02x" 4000 :: String
20:59:35 <lambdabot>   "fa0"
20:59:42 <Olathe> zomg !
20:59:44 <lispy> jdrake: but you still have the maxBound issue :)
21:00:05 <Olathe> > printf "%02x".mod 256 $ 1 :: String
21:00:07 <lambdabot>   "00"
21:00:17 <Olathe> > printf "%02x".flip mod 256 $ 1 :: String
21:00:18 <lambdabot>   "01"
21:00:53 <lispy> Olathe: I think he needs a [Char] -> [Word8], and then [Word8] -> String
21:01:13 <lispy> ?hoogle Char -> [Word8]
21:01:13 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
21:01:14 <lambdabot> Data.Generics.Basics gmapQ :: Data a => (a -> u) -> a -> [u]
21:01:14 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
21:01:38 <Eridius> bahahah, I just managed to run emacs inside ansi-term mode in xemacs
21:01:41 <Eridius> doesn't quite work
21:01:50 <adu> > printf "%s = %d" "ten" $ sum [1,2,3,4]
21:01:51 <lambdabot>   Add a type signature
21:02:16 <Olathe> > map (\x -> printf "%02x" (fromIntegral (ord x) :: Word8)) "omg hi"
21:02:17 <lambdabot>   Add a type signature
21:02:21 <Olathe> > map (\x -> printf "%02x" (fromIntegral (ord x) :: Word8)) "omg hi" :: [String]
21:02:23 <lambdabot>   ["6f","6d","67","20","68","69"]
21:02:41 <adu> > printf "%s = %d" "ten" $ sum [1,2,3,4::Int]
21:02:42 <lambdabot>   Add a type signature
21:02:48 <lispy> Olathe: but that will kill any potential for unicode :)
21:02:53 <Olathe> > map (\x -> printf "%02x" (fromIntegral (ord x) :: Word8) :: String) "omg hi"
21:02:54 <lambdabot>   ["6f","6d","67","20","68","69"]
21:03:08 <Olathe> > map (\x -> printf "%02x" (fromIntegral (ord x) :: Word8) :: String) "omg unicorn code !"
21:03:10 <lambdabot>   ["6f","6d","67","20","75","6e","69","63","6f","72","6e","20","63","6f","64"...
21:03:16 <Olathe> Yeah, it will.
21:03:20 <Olathe> Unless you use UTF8.
21:04:05 <Olathe> > map (\x -> printf "%02x" (fromIntegral (ord x) :: Word8) :: String) $ utf8s "omg unicorn code !"
21:04:06 <lambdabot>   mueval: Prelude.read: no parse
21:04:09 <adu> > printf "%s = %d" "ten" $ sum [1,2,3,4] :: Int
21:04:09 <Olathe> Bah.
21:04:10 <lambdabot>       No instance for (PrintfType Int)
21:04:10 <lambdabot>        arising from a use of `printf' ...
21:04:39 <adu> > printf "%s = %d" "ten" (sum [1,2,3,4] :: Int)
21:04:40 <Olathe> > printf "%s = %d" "ten" $ sum ([1,2,3,4] :: [Int])
21:04:40 <lambdabot>   Add a type signature
21:04:41 <lambdabot>   Add a type signature
21:04:45 <Olathe> > printf "%s = %d" "ten" $ sum ([1,2,3,4] :: [Int]) :: String
21:04:46 <lambdabot>   "ten = 10"
21:05:01 <Axman6> :t printf
21:05:02 <lambdabot> forall r. (PrintfType r) => String -> r
21:05:21 <Axman6> :S
21:06:07 <adu> well it works in ghci, thats what matters
21:07:12 <adu> there should be a version of printf that isn't String/IO() polymorphic, like showf
21:07:27 <Olathe> sprintf
21:07:30 <Olathe> > sprintf
21:07:31 <lambdabot>   mueval: Prelude.read: no parse
21:07:34 <Olathe> :(
21:07:51 <BMeph> Is that...a Comonadic type? o.O
21:08:06 <Eridius> @pl \x -> x * x
21:08:07 <lambdabot> join (*)
21:09:41 <adu> @src join
21:09:41 <lambdabot> join x =  x >>= id
21:10:28 <dmwit> BMeph: which?
21:10:49 <Axman6> Eridius: (^2) would be better
21:11:06 <Eridius> Axman6: durrrr, thanks
21:11:08 <BMeph> dmwit: for printf
21:11:13 <Axman6> ?
21:11:30 * sbok notes that Haskell is allowed at the southeast ACM-ICPC regional, not sure about other regions :-D
21:11:55 <Eridius> Axman6: the durr was an audible expression of the fact that I was retarded, not an attempt to be sarcastic. Sorry
21:11:56 <dmwit> BMeph: err... what's comonadic about it?
21:12:06 <Axman6> ok :)
21:12:08 <dmwit> BMeph: Do you mean polymorphic?
21:13:18 <jdrake> lispy: How is this?  map (w2c . c2w)
21:13:31 <jdrake> map (w2c . c2w) :: [Char] -> [Char]
21:14:09 <sjanssen> sbok: why allow a language that isn't allowed at the final ICPC contest?
21:14:12 <BMeph> dmwit: No, I meant comonadic. Of course it's polymorphic. :)
21:14:31 <Olathe> There are languages they don't allow ?
21:14:48 <Eridius> huh, xemacs occasionally seems to get wedged doing something with the inferior-haskell
21:15:01 <sbok> sjanssen: Not sure.. I'm not part of the regional committee, just a participant. It'd be nice if the finals included a few more languages, too, though...
21:15:37 <sjanssen> sbok: sure
21:16:09 <mmorrow> Saizan: re theta type, here's a spec of that comment http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=101#a101
21:16:13 <Olathe> Wait.
21:16:22 <Olathe> Haskell was allowed at the ACM contest ?
21:16:54 <sjanssen> Olathe: not "the" contest, but apparently at a regional contest (the best regional teams go to the international contest)
21:17:04 <Olathe> Ahh.
21:18:52 <Eridius> damn, you can't force-wrap a number by backslash-escaping the newline?
21:19:03 <Eridius> I need to embed a 1000-digit number in my source
21:19:14 <Eridius> I suppose I can use a list of smaller numbers
21:19:29 <Eridius> especially since I'm gonna split it into digits anyway. Or I could just try embedding a string, it just doesn't look as good
21:20:15 <Eridius> huh, you can't backslash-escape a newline in a string either?
21:20:40 <dolio> You need an ending \ and a beginning \ on the next line.
21:20:45 <Olathe> "zomg" ++ \n "zomg"
21:20:46 <Eridius> a beginning \?
21:20:55 <Eridius> Olathe: I don't want a newline in the string, I want a newline in the source
21:21:00 <dolio> "foo\
21:21:03 <Olathe> Won't that work ?
21:21:03 <dolio> \bar"
21:21:11 <Olathe> The newline is in the source.
21:21:11 <Eridius> sweet, that worked
21:21:13 <Eridius> thanks dolio
21:21:22 <dolio> I don't think it adds an \n, either.
21:21:29 <Eridius> Olathe: oh you meant type a newline, not type \n
21:21:40 <Olathe> Yes :)
21:21:41 <Eridius> I suppose that would have worked, but dolio's solution is nicer for me
21:22:33 <ozy`> man, it's so hard to go back to scheme after learning haskell and having the top of my head fly off like a wacky volcano made of froot loops
21:22:58 <ozy`> too used to spewing lambdas and partial applications all over the screen
21:23:00 <Eridius> so why go back?
21:23:21 <rwbarton> jdrake: that will throw away the high-order bits of every Char
21:23:25 <rwbarton> jdrake: what are you trying to do?
21:23:28 <ozy`> Eridius: partly to see exactly how hard it is
21:23:33 <adu> i want to be in the ACM contest
21:23:47 <adu> why isn't Haskell allowed?
21:24:07 <ozy`> adu: because it's not imperative?
21:24:14 <jdrake> rwbarton, lispy has made mention about the possibility of a Char being more than 8 bits with this code: string2hex = concatMap (\x -> printf "%02x" (ord x)::String)
21:24:29 <sjanssen> adu: because programming languages don't matter very much in this sort of competition
21:24:34 <adu> ozy`: what does that have to do with anything?
21:25:12 <rwbarton> jdrake: that is true.  But it'd be easier to just take (ord x `mod` 256)
21:26:18 <jdrake> Something from before:
21:26:18 <jdrake> <Olathe> > printf "%02x".mod 256 $ 1 :: String
21:26:18 <jdrake> <lambdabot>   "00"
21:26:18 <jdrake> <Olathe> > printf "%02x".flip mod 256 $ 1 :: String
21:26:18 <jdrake> <lambdabot>   "01"
21:27:30 <Eridius> if I want to grab the 3 lowest elements in a list, I can simply say (take 3 $ sort list) and it won't perform a full sort, right?
21:27:45 <BMeph> ozy`: You think that's bad, I just finished a paper showing how to write Lisp in a "linear" style. Accompanying it was "code" that looks suspiciously like Factor... :)
21:27:57 <Eridius> what about the 3 highest? Is there any better solution than making my own custom reversed compare and using sortBy? I assume (reverse $ sort list) will end up doing a full sort
21:28:08 <ozy`> adu: well, I dunno. the illuminati?
21:28:16 <ozy`> BMeph: no idea what Factor looks like
21:28:18 <adu> lol
21:28:32 <pjdelport> Eridius: depends on the sort algorithm, really
21:28:41 <TSC> Eridius: For the 3 highest, just invert the comparison:
21:28:46 <TSC> > take 3 $ sortBy (flip compare) [1..10]
21:28:47 <lambdabot>  Terminated
21:28:51 <TSC> > take 3 $ sortBy (flip compare) [1..10]
21:28:53 <lambdabot>   [10,9,8]
21:28:54 <Eridius> ooh, flip compare. I never thought about that
21:29:02 <pjdelport> the canonical way to do that kind of thing is with a heap
21:29:08 <Eridius> I did this earlier and I wrote my own custom compare that swapped the LT and GT results
21:29:29 <TSC> Yeah, it's easier to swap the inputs (:
21:29:38 <Eridius> pjdelport: I've read that one of the classic examples of Haskell's laziness is you can just write (take 3 $ sort list) and it'll only sort the list just enough to extract the 3 least elements, and then stop
21:30:03 <pjdelport> right
21:30:03 <pjdelport> assuming the sort algorithm is lazy enough :)
21:30:13 <Eridius> right well, this would imply that it is lazy enough
21:30:25 <BMeph> ozy` Imagine Forth with brackets for quoting. :)
21:30:39 <Eridius> isn't Factor a stack-based language?
21:31:05 <pjdelport> Eridius: well, it depends on the implementation of sort
21:31:37 <pjdelport> Eridius: Haskell allows it to be lazy, but doesn't enforce it
21:31:48 <BMeph> Eridius: Yes, it is - just like Lisp, aparently... ;)
21:31:49 <Eridius> pjdelport: you're missing the whole point where the statement that (take 3 $ sort list) is lazy implies that Haskell's default sort is lazy enough to make this work
21:32:03 <pjdelport> the whole is only as lazy as the least strict part
21:32:06 <Olathe> > take 3 $ sort [1..]
21:32:17 <TSC> That won't work...
21:32:21 <Olathe> I know ;)
21:32:40 <pjdelport> Eridius: it doesn't imply it
21:32:40 <pjdelport> it permits it
21:32:40 <pjdelport> you can't say anything about it without knowing the implementation of sort
21:32:49 <Eridius> Olathe: the only way that could possibly work is if the sort knows that the list is already sorted
21:33:10 <Eridius> pjdelport: no, it implies it, because the statement would be completely false if Haskell's sort isn't lazy enough
21:33:36 <sjanssen> {-# RULES "sort/enumFrom" forall x. sort (enumFrom x) = enumFrom x #-} :)
21:33:39 <pjdelport> Eridius: i think we're talking past each other somewhere
21:33:57 <BMeph> ozy`: http://home.pipeline.com/~hbaker1/ForthStack.html
21:34:06 <Eridius> pjdelport: probably
21:34:07 <lambdabot> Title: ACM Sigarch Comp. Arch. News 22, 1 (Mar 1994), 34-43.
21:34:24 <Eridius> @hoogle Char -> Int
21:34:24 <lambdabot> Data.Char digitToInt :: Char -> Int
21:34:25 <lambdabot> Data.Char ord :: Char -> Int
21:34:25 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
21:34:34 <pjdelport> Eridius: whether the statement is true or false depends not just on Haskell, but also on the implementation of sort
21:34:39 <adu> how do I find out what the ACM problems were last year?
21:34:53 <Olathe> @hoogle a -> [a] -> Int
21:34:53 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
21:34:53 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
21:34:53 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:35:08 <Olathe> No general count function :(
21:35:12 <TSC> "take 3 $ sort [1..1000000]"  is much faster in ghci than  "last $ sort [1..1000000]", so I reckon ghc's sort is lazy enough
21:35:15 <sjanssen> @google acm icpc
21:35:18 <lambdabot> http://cm2prod.baylor.edu/
21:35:18 <lambdabot> Title: Redirect
21:35:50 <Axman6> Olathe: length . filter (/=element)?
21:36:03 <Eridius> pjdelport: the haskell report actually defines the implementation of sortBy
21:36:05 <pjdelport> Eridius: the general point is that whether a function is lazy or not is not just up to Haskell, but also depends on the algorithm
21:36:12 <Eridius> it's defined in terms of insertBy, which is also given
21:36:32 <Eridius> pjdelport: I understand your point, but you're missing the fact that the haskell report actually specifies the algorithm
21:36:58 <TSC> Eridius: I think the report's algorithm is lazy enough
21:37:00 <mmorrow> > maxBound :: Char
21:37:04 <lambdabot>   '\1114111'
21:37:21 <Eridius> TSC: that was my question. I assumed it was true, given the example of (take 3 $ sort list), but it's nice to know
21:37:24 <mmorrow> , utf8enc [maxBound]
21:37:26 <lunabot>  "\244\143\191\191"
21:37:28 <Axman6> minbound would be '\0' right?
21:37:34 <mmorrow> yeah
21:38:08 <pjdelport> Eridius: the report gives an example implementation
21:38:15 <rwbarton> Eridius: That definition in the Prelude specifies the semantics, but not the implementation
21:38:35 <pjdelport> Eridius: it specifies that it should be stable, but doesn't say anything about strictness
21:38:51 <Eridius> pjdelport: http://www.haskell.org/onlinereport/list.html
21:38:51 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
21:38:55 <rwbarton> Eridius: I hope no compiler contains a quadratic-time implementation of sort!
21:38:56 <Eridius> search for sortBy
21:38:57 <Eridius> go to the last match
21:39:19 <Heffalump> rwbarton: how about exponential time?
21:39:26 <adu> sjanssen: I actually understand that now :) just read up on rewrite rules last weekend
21:39:38 <pjdelport> Eridius: yes, i know
21:39:50 <sm> nice.. "In running a computer program, we are letting a piece of the programmer's past mind do things for us that we would not know how to do."
21:39:57 <mmorrow> , (take 3 . sort . take 100000 . randoms) (mkStdGen 0) :: [Int]
21:39:59 <lunabot>  [-2147363743,-2147298684,-2147296830]
21:40:08 <pjdelport> Eridius: that is the example implementation
21:40:08 <pjdelport> Eridius: what rwbarton said
21:40:46 <sjanssen> adu: can you spot the problem in that rewrite rule?
21:41:02 <pjdelport> Eridius: http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sort
21:41:03 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/392kwb
21:41:22 <Eridius> pjdelport: huh
21:41:41 <pjdelport> Eridius: GHC, for example, uses a different implementation
21:41:41 <pjdelport> unless you specify USE_REPORT_PRELUDE
21:41:52 <jdrake> @hoogle readHex
21:41:53 <lambdabot> Numeric readHex :: Num a => ReadS a
21:41:59 <mmorrow> ?instances Random
21:42:00 <TSC> sjanssen: Does the rule change the type?  (it might remove the Ord constraint)
21:42:01 <lambdabot> Couldn't find class `Random'. Try @instances-importing
21:42:36 <Eridius> pjdelport: do you know if that mergesort is lazy enough?
21:42:41 <Eridius> my guess is yes, but it would be nice to know
21:43:24 <jdrake> ?instances ReadS
21:43:26 <lambdabot> Couldn't find class `ReadS'. Try @instances-importing
21:43:44 <Olathe> > showCReal 10 $ sqrt(-1)
21:43:54 <sjanssen> TSC: rules fire after type checking
21:43:59 <lambdabot>   thread killed
21:45:08 <pjdelport> Eridius: yes, but i'm not sure how much extra work it does above the minimum
21:45:24 <mmorrow> , let 'x = 3 in 'x
21:45:25 <lunabot>  luna: Parse error in pattern
21:48:24 <jdrake> :t readHex
21:48:26 <lambdabot> forall a. (Num a) => String -> [(a, String)]
21:50:48 <Olathe> :t showHex
21:50:49 <lambdabot> forall a. (Integral a) => a -> String -> String
21:50:52 <Olathe> zomg
21:50:59 <Olathe> @src showHex
21:50:59 <lambdabot> Source not found. Wrong!  You cheating scum!
21:51:08 <Olathe> > showHex 5 "Hello"
21:51:13 <lambdabot>   mueval: Prelude.read: no parse
21:51:36 <Olathe> @type showHex 5 "Hello"
21:51:37 <Axman6> > showHex "1234"
21:51:37 <lambdabot> String
21:51:42 <lambdabot>       Overlapping instances for Show (String -> String)
21:51:43 <lambdabot>        arising from a...
21:51:56 <Axman6> > showHex "01234"
21:52:01 <lambdabot>       Overlapping instances for Show (String -> String)
21:52:01 <lambdabot>        arising from a...
21:52:07 <Axman6> > showHex "abcd"
21:52:07 <Olathe> > showHex 123
21:52:11 <lambdabot>       Overlapping instances for Show (String -> String)
21:52:11 <lambdabot>        arising from a...
21:52:13 <lambdabot>       Overlapping instances for Show (String -> String)
21:52:13 <lambdabot>        arising from a...
21:52:16 <Eridius> huh, a failing let pattern in the list monad doesn't fail, it triggers an exception?
21:52:17 <Olathe> > showHex 123 "\x"
21:52:21 <lambdabot>       lexical error in string/character literal at character '"'
21:52:23 <Olathe> > showHex 123 "\\x"
21:52:28 <lambdabot>   mueval: Prelude.read: no parse
21:52:36 <Olathe> > showHex 123 "%"
21:52:40 <Axman6> bleh, missed the a in the type sig. i wondered what you were doing Olathe
21:52:41 <lambdabot>   mueval: Prelude.read: no parse
21:52:54 <Eridius> > [a | Just a <- [Nothing]]
21:53:00 <lambdabot>   []
21:53:07 <Eridius> > [a | let Just a = Nothing]
21:53:13 <lambdabot>   mueval: Prelude.read: no parse
21:53:13 <lambdabot>  mueval: [*** Exception: /tmp/36082565886396...
21:53:19 <Olathe> > let Just a = Nothing in Just 5
21:53:25 <lambdabot>   Just 5
21:53:30 <Olathe> Wrong !
21:53:42 <Olathe> > let 4 = 5 in 4
21:53:46 <lambdabot>   mueval: Prelude.read: no parse
21:53:48 <Axman6> > let Just a = Nothing in Just a
21:53:50 <lambdabot>   mueval: Prelude.read: no parse
21:53:50 <lambdabot>  mueval: Just *** Exception: /tmp/6877054610...
21:54:02 <Eridius> huh, so let-bindings in general are irrefutable?
21:54:05 <Axman6> oi!
21:54:18 <jdrake> This is boggling my mind: http://hpaste.org/11047
21:54:51 <mmorrow> that was just a pattern match error
21:55:04 <mmorrow> > let 1 = 0 in 42
21:55:06 <lambdabot>   42
21:55:11 <mmorrow> err, bad example
21:55:13 <mmorrow> heh
21:55:24 <Olathe> jdrake: Remove the []s around the second argument to (++), namely ...
21:55:31 <Eridius> I was just hoping it would trigger fail like a failing <- does
21:55:35 <mmorrow> > let [] = [0..] in 1
21:55:36 <lambdabot>   1
21:55:41 <mmorrow> > let [x] = [0..] in x
21:55:43 <lambdabot>   mueval: Prelude.read: no parse
21:55:43 <lambdabot>  mueval: *** Exception: /tmp/503364175817568...
21:55:46 <mmorrow> finally
21:55:48 <jdrake> ok, I get it
21:55:51 <rwbarton> > let [x] = [0..] in y
21:55:52 <rwbarton> > let [x] = [0..] in 3
21:55:52 <lambdabot>   y
21:55:54 <lambdabot>   3
21:56:16 <mmorrow> hehe, i just found that out
21:56:16 <Olathe> jdrake [chr x] ++ hex2string xs (or, better: chr x:hex2string xs
21:56:21 <Olathe> )
21:56:45 <jdrake> yeah I like your other method there
21:56:59 <jdrake> The function works, but can it be done any better?
21:57:04 <mmorrow> err, actually i suppose i knew that, but didn't identify it in other contexts with this one
21:58:02 <mmorrow> , let f [x] = 3 in f [0..]
21:58:05 <lunabot>  luna: <interactive>:1:54-62: Non-exhaustive patterns in function f
21:58:18 <Olathe> @index readHex
21:58:18 <lambdabot> Numeric
21:58:22 <mmorrow> i think it may be because of the cse ghc does
21:58:44 * mmorrow checks if that works in yhc
22:01:44 <mmorrow> it does. ok, i guess it's not because of that
22:03:18 <mmorrow> hmm, i guess it probably gets completely eliminated in the output code
22:05:12 <rwbarton> Pattern (i.e., not function) bindings in a let are always irrefutable
22:07:13 <mmorrow> innnnteresting
22:07:26 <mmorrow> , let f ~[x] = 3 in f [0..]
22:07:27 <lunabot>  3
22:07:30 <mmorrow> heh
22:08:22 <mmorrow> hmm, this just changed the way i looked at uses for irrefutable patterns
22:08:29 <mmorrow> s/looked/look/
22:08:38 <Olathe> jdrake: http://hpaste.org/11047#a1
22:09:34 <jdrake> Olathe, that looks more complicated
22:10:38 <jdrake> and how can you use a and b in math when they are Char?
22:10:42 <mmorrow> rwbarton: i guess function bindings are only refutable if that particular case ever gets tested
22:11:32 <Olathe> jdrake: ord changes that.
22:11:32 <rwbarton> mmorrow: right. a pattern match can succeed, fail, or diverge
22:11:53 <jdrake> I have to admit, I am not quite seeing how this works
22:12:02 <rwbarton> mmorrow: and matching happens from left to right.  It's all written down in the report, but the details seldom matter
22:12:09 <mmorrow> yeah
22:12:36 <Olathe> > ord '0'
22:12:37 <lambdabot>   48
22:12:37 <rwbarton> Olathe: shouldn't 86 be 87?
22:12:56 <Olathe> > ((\x -> x - if x < 97 then 48 else 86).ord) '0'
22:12:57 <lambdabot>   0
22:13:00 <Olathe> > ((\x -> x - if x < 97 then 48 else 86).ord) 'f'
22:13:02 <lambdabot>   16
22:13:13 <Olathe> Ahh.
22:13:16 <Olathe> > ((\x -> x - if x < 97 then 48 else 87).ord) 'f'
22:13:17 <lambdabot>   15
22:13:22 <Olathe> Yay, 87 :)
22:13:26 <Olathe> Thanks rwbarton.
22:13:58 <Olathe> > map ((\x -> x - if x < 97 then 48 else 87).ord) "0123456789abcdef"
22:14:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
22:14:16 <jdrake> ok, so you convert to numbers, and then I see what you do
22:14:23 <Olathe> Yep.
22:14:27 <mmorrow> , let f ~xs@[x] = if length xs = 1 then x else [] in fmap f [[],[1],[0..]]
22:14:28 <lunabot>  luna: parse error on input `='
22:14:31 <rwbarton> jdrake: your original code is fine.  though you might want Word8 rather than Char for your purposes
22:14:34 <mmorrow> , let f ~xs@[x] = if length xs == 1 then x else [] in fmap f [[],[1],[0..]]
22:14:36 <lunabot>  luna: No instance for (GHC.Enum.Enum [a])
22:14:54 <mmorrow> , let f ~xs@[x] = if length xs == 1 then [x,x] else [] in fmap f [[],[1],[0..]]
22:14:56 <lunabot>  luna: <interactive>:1:54-101: Irrefutable pattern failed for pattern (xs@...
22:15:02 <jdrake> Olathe, is there anything in particular that would recommend your code?
22:15:10 <mmorrow> , let f xs@(~[x]) = if length xs == 1 then [x,x] else [] in fmap f [[],[1],[0..]]
22:15:13 <lunabot>  luna: out of memory (requested 1048576 bytes)
22:15:57 <Olathe> > let length [] = 0; length [x] = 1; length _ = 2 in length [1..]
22:15:59 <lambdabot>   2
22:16:03 <mmorrow> , let f xs@(~[x]) = if (not . null . drop 1) xs then [x,x] else [] in fmap f [[],[1],[0..]]
22:16:05 <lunabot>  luna: <interactive>:1:54-113: Irrefutable pattern failed for pattern [x]
22:16:11 <mmorrow> , drop 1 []
22:16:12 <lunabot>  []
22:16:34 <mmorrow> oh
22:16:34 <sm> multiline strings are not much fun in haskell
22:16:56 <mmorrow> , let f xs@(~[x]) = if (not . null . drop 1) xs && (not . null) xs then [x,x] else [] in fmap f [[],[1],[0..]]
22:16:57 <lunabot>  luna: <interactive>:1:54-132: Irrefutable pattern failed for pattern [x]
22:17:12 <mmorrow> guess that won't work
22:17:23 <jdrake> It works!
22:17:26 <mmorrow> , let f ~xs@([x]) = if (not . null . drop 1) xs && (not . null) xs then [x,x] else [] in fmap f [[],[1],[0..]]
22:17:28 <lunabot>  luna: <interactive>:1:54-132: Irrefutable pattern failed for pattern (xs@...
22:17:57 <mmorrow> sm: heh, are you being serious?
22:18:08 <sm> yes
22:18:10 <mmorrow> if you are, then there's a super easy way
22:18:18 <sm> I have a lot of \n\
22:18:20 <mmorrow> (you have to have ghc6.10 though)
22:18:39 <mmorrow> (which is only a release-candidate as of now)
22:18:40 <sm> oh, do tell
22:18:58 <mmorrow> http://hpaste.org/11027
22:19:29 <sm> yehoo!! good news, thanks :)
22:19:42 <mmorrow> :)
22:22:27 <jdrake> multiline strings look cool :-)
22:23:11 <mmorrow> rwbarton: hmm, what's an example of a divergent pattern match (not using undefined for divergence)?
22:23:32 <Axman6> jdrake: ?
22:23:42 <mmorrow> jdrake: yeah. that's an example of a so-called quasiquoter, which is new in ghc-6.10
22:24:08 <jdrake> Well, my module is 171 lines, and I need to farm it out to a few modules I think
22:24:24 <jdrake> How close is ghc 6.10 to being complete?
22:24:38 <lispy> jdrake: very
22:25:18 <mmorrow> , let x@(x,x) = ((),()) in x
22:25:18 <lispy> jdrake: the current release candidate looks pretty good for being the new stable release, as I understand it
22:25:19 <lunabot>  luna: Conflicting definitions for `x'
22:25:30 <mmorrow> , let x@(x,_) = ((),()) in x
22:25:32 <lunabot>  luna: Conflicting definitions for `x'
22:25:49 <jdrake> Is there anyone that does a debian package for it? As long as there weren't any debian specific patches in there, I can do it myself. I do prefer debian packages over custom ones.
22:28:32 <jeffz> jdrake: there's a mailing list that seems to cover packaging for debian http://news.gmane.org/gmane.comp.lang.haskell.debian
22:28:33 <lambdabot> Title: Gmane Loom
22:28:59 <mmorrow> , let f a@(g,x) = g a in f (f,0)
22:29:01 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = (t, t1) -> t2
22:29:16 <rwbarton> mmorrow: I'm pretty sure what I meant by "divergent" was just that the pattern match would try to match a constructor against _|_
22:29:47 <mmorrow> ah, i see. for a second there i thought there was some weird way to make it loop trying to match a pattern
22:31:08 <lispy> > let f :: a -> [a]; f = id in f
22:31:09 <lambdabot>       Overlapping instances for Show (a -> [a])
22:31:09 <lambdabot>        arising from a use of ...
22:31:13 <lispy> > let f :: a -> [a]; f = id in f 1
22:31:14 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
22:31:14 <lambdabot>      When gen...
22:31:41 <rwbarton> lispy: ??
22:32:08 <lispy> rwbarton: I was just thinking about infinite types
22:32:33 <lispy> rwbarton: if our types correspond to propositions, what is an infinite type?
22:33:36 <jdrake> Can I have a haskell module in / that imports RSA.RSA from RSA/RSA.hs and then have RSA.hs be able to import modules from RSA/ without needing to call them RSA.*?
22:33:55 <Heffalump> jdrake: no
22:34:00 <rwbarton> it seems like it would be a solution to some equation, which might have zero or multiple solutions, but in the "free" case you can't write any of them down
22:34:04 <lispy> rwbarton: is it a certain type of self-referential proposition?
22:34:37 <dolio> It kind of depends on the infinite type.
22:34:56 <lispy> dolio: let's take, a = Maybe a
22:35:01 <mmorrow> , fix (\k env@(m:n:_) (x:xs) -> if m < x || x < n then x : k (x:env) xs else k env xs) [0,1000] (randoms (mkStdGen 0))
22:35:04 <lunabot>  [2092838931,-2143208520,2034827062,2057855438,-126648133,1307778349,-2148...
22:35:16 <rwbarton> In proposition-land, a = Maybe a = True
22:35:23 <mmorrow> , fix (\k env@(m:n:_) (x:xs) -> if m < x || x < n then x : k (x:env) xs else k env xs) [0,1000] (randomRs (-100,100) (mkStdGen 0))
22:35:25 <lunabot>  [-47,-8,11,17,-51,-78,80,-86,-57,86,-76,-58,-24,47,100,18,-47,4,34,0,25,-...
22:35:32 <lispy> jdrake: did you know you can have RSA.hs in ./RSA, and then import it as just RSA, and still have sub modules?
22:36:03 <lispy> rwbarton: I just meant, the infinite type that would result from unifying a with Maybe a
22:36:05 <mmorrow> , fix (\k env@(m:n:_) (x:xs) -> if m < x || x < n then (x,(m,n)) : k (x:env) xs else k env xs) [0,1000] (randomRs (-100,100) (mkStdGen 0))
22:36:07 <lunabot>  [(-47,(0,1000)),(-8,(-47,0)),(11,(-8,-47)),(17,(11,-8)),(-51,(17,11)),(-7...
22:36:15 <lispy> rwbarton: like in the error message here it says a and [a]
22:36:19 <rwbarton> right
22:36:25 <lispy> rwbarton: but, I thought Maybe was easier to work with than [a]
22:36:27 <dolio> a = Maybe a is the natural numbers.
22:36:39 <lispy> dolio: please explain
22:36:42 <mmorrow> i like [a] instead of Maybe a myself
22:36:53 <jdrake> lispy, the problem right now is that this module that I want to carry around with my code was meant to be installed like any other package. But its availability is sketchy. I would rather not modify it too much, hense why I ask what I do.
22:37:20 <dolio> a = Maybe a ==> a = Fix Maybe
22:37:37 <dolio> = Nothing | Just Nothing | Just (Just Nothing) | ...
22:37:42 <lispy> dolio: okay, I was working up to a type level fix
22:38:05 <lispy> dolio: okay, and that is isomorphic to the peano numbers
22:38:12 <rwbarton> dolio: Now do, a = (a -> Void) :)
22:39:11 <rwbarton> I suppose you'll object that x |-> (x -> Void) is not a functor
22:39:17 <dolio> data Foo = Foo (forall b. Foo -> b)
22:40:01 <dolio> That's not a very useful type, though...
22:40:40 <dolio> It looks like it's essentialy Void.
22:40:45 <sm> my small set of hunit tests run lovely and quickly, for now.. how refreshing. What's a good way to have them running continuously and visibly for real-time feedback ?
22:41:29 <lispy> sm: watch -n0 ./mytests :)
22:41:36 <dolio> seq excepted.
22:41:50 <mmorrow> newtype C a = C (forall r. (a -> r) -> r)
22:41:53 <jdrake> Does ghc have a 'clean' method to get rid of all intermediate files?
22:42:02 <sm> lispy: good idea.. I recently discovered watch
22:42:04 <jdrake> To help with --make :-)
22:42:23 <mmorrow> hmm. that C with the hidden r might be extremely usefull.
22:42:41 <lispy> sm: you may want to toss in, runghc ./Setup.hs build, or something on that command line?
22:43:35 <sm> well, I'll just run the code interpreted
22:43:42 <dolio> Anyhow, Haskell already has infinite types. They just have to be wrapped in a certain way.
22:43:42 <rwbarton> dolio: x :: Foo; x = Foo $ \a@(Foo t) -> t a
22:43:50 <lispy> jdrake: if you're at that point, then your code base is ready to use make or cabal, I would say.  Using cabal is simple for 90% of projects.
22:44:02 <dolio> So you can ask what proposition [a] corresponds to and such.
22:44:15 <jdrake> lispy, got a friendly intro?
22:44:29 <lispy> jdrake: let's find one
22:44:59 <lispy> jdrake: how is this? http://en.wikibooks.org/wiki/Haskell/Packaging
22:45:00 <lambdabot> Title: Haskell/Packaging - Wikibooks, collection of open-content textbooks
22:46:22 <lispy> dolio: well, data [a] = [] | a : [a]
22:46:35 <jdrake> looks reasonable
22:46:39 <dolio> rwbarton: And what are we doing to do with that?
22:46:59 <jdrake> Now I have to convert everything in RSA/ into modules using the name RSA.____
22:47:07 <jdrake> So I can get rid of the ghc -iRSA line
22:47:08 <rwbarton> dolio: Well, it looks like a total term of type Foo to me, but...
22:47:27 <sm> lispy: while true; do app.hs selftest; sleep 1; done seems most practical so far
22:47:37 <dons> jdrake: generally, you'll move from using ghc --make to using cabal as your build system
22:47:37 <lispy> jdrake: I think so yes...Are you modifying the original RSA code or just adding to it?
22:47:56 <sm> it seems to take a minimum of 1s to start interpreted, surprising
22:47:58 <dons> which'll handle cleaning, dependencies and flags.
22:48:05 <jdrake> lispy, modifying the original
22:48:08 <dolio> rwbarton: The total languages I know of wouldn't allow Foo in the first place, because it's not strictly positive.
22:48:14 <jdrake> Essentially so it lives in my project
22:48:14 <lispy> sm: that's the same as 'watch -n1 app.hs selftest'
22:48:25 <dons> jdrake: and then things that you build with cabal can be distributed on hackage.haskell.org
22:48:29 <dolio> rwbarton: And precisely because it allows you to introduce bottom.
22:48:43 <rwbarton> I don't think you get anything useful in proposition-land by looking at recursive types, just like you don't get anything useful by looking at recursive terms.
22:48:47 <sm> in fact, you're right
22:49:01 <jdrake> dons, even whole apps?
22:49:01 <sm> I was hoping watch would stop the scrolling
22:49:10 <dons> jdrake: yep. esp. whole apps.
22:49:16 <dons> they all just build with cabal.
22:49:19 <Axman6> anyone have a nice haskell snippet that shows how nice haskell is to use, and does something cool?
22:49:31 <dons> so you can, e.g. , have users use 'cabal install foo' to get your stuff
22:49:37 <Axman6> a "look at how cool haskell is" snippet
22:49:40 <dons> or use automated tools to convert cabal packages into native packages
22:49:53 <lispy> sm: okay, then add a command to reset the terminal, watch -n1 'reset && app.hs selftest'
22:49:57 * Axman6 thinks dons must have many of said snippets
22:50:09 <dons> Axman6: hmm.
22:50:18 <lispy> I'm fond of fibs
22:50:19 <jdrake> Now everything that isn't an .hs file is pretty much a product of building like .o .hi, etc. right?
22:50:24 <lispy> But it's not terribly useful
22:50:25 <dons> yep.
22:50:28 <Axman6> oh yes, fibs is nice
22:50:34 <dons> jdrake: you should only really have .hs and .cabal files
22:50:42 <dolio> rwbarton: Since your x is essentially 'omega = \x -> x x'. And then you can write 'foo_Omega = unFoo x x'.
22:50:44 <lispy> > fix $ \fibs -> zipWith (+) fibs (tail fibs)
22:50:45 <jdrake> dons, this is after a --make
22:50:49 <jdrake> I am trying to clean it up
22:50:53 <rwbarton> dolio: Yes, I did that in ghci :)
22:50:56 <dons> jdrake: ok, rm *.hi *.o
22:50:59 <lambdabot>   thread killed
22:51:11 <sm> clear you mean.. but that leaves the screen blank most of the time
22:51:13 <dons> jdrake: or cabal clean
22:51:14 <lispy> > take 10 $ fix $ \fibs -> zipWith (+) fibs (tail fibs)
22:51:25 <lispy> sm: oh okay, yeah clear, sorry
22:51:29 <lambdabot>   thread killed
22:51:37 <sm> in fact it doesn't work with watch, but with while.. anyway
22:51:39 <lispy> oh hehe
22:51:51 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
22:51:52 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:52:01 <sm> seems like a very slick test runner is possible
22:52:40 <lispy> sm: did you put quotes around the whole command that you're watching?
22:52:43 <sm> one which watches for file changes would be better. I think happs comes with a tool for that
22:52:46 <sm> sure
22:52:55 <lispy> sm: watch 'clear && mytests'
22:53:01 <sm> yup
22:53:40 <Nafai> Hey sm
22:53:44 <Nafai> Whatcha working on?
22:53:48 <lispy> sm: another option is to setup a buildbot that runs of your repository, then as you make small patches you can push them to the buildbot
22:53:54 <sm> hey Nafai.. you know what
22:54:03 <mmorrow> dolio: interesting. this seems to be the same situation that came up with an expression in an SAPL paper i was reading http://hpaste.org/11048
22:54:23 <sm> eek, a buildbot would crush me in its jaws of steel
22:54:38 <Nafai> sm: ledger in hs?
22:54:43 <sm> yup
22:54:48 <Nafai> Cool
22:54:57 <jdrake> Love how everything was distributed as +x in the rsa tarball
22:54:58 <Nafai> I'm slowly getting more comfortable in Haskell
22:55:10 <sm> cool
22:55:50 <dolio> mmorrow: That's kind of an odd way to do things.
22:56:10 <mmorrow> i'll dig up the SAPL example i'm thinking of
22:56:20 <lispy> what is ledger?
22:56:38 <lispy> it's hard to google for :(
22:56:42 <Nafai> lispy: http://www.newartisans.com/software/ledger.html
22:56:43 <lambdabot> Title: Ledger: Command-line accounting
22:56:53 <mmorrow> (the context is "SAPL cannot be typed by hindley-milner")
22:57:25 <lispy> mmorrow: SAPL?
22:57:45 <mmorrow> Simple Applicative Programming Language
22:58:26 <mmorrow> Clean uses it as an intermediate rep (but that's not what it's known for)
22:59:02 <mmorrow> http://www.st.cs.ru.nl/papers/2005/janj2005-PatternMatchingByFunctionsIFL05.pdf
22:59:07 <mmorrow> http://www.st.cs.ru.nl/papers/2006/janj2006-TFP06-EfficientInterpretation.pdf
22:59:09 <lambdabot> Title: Data Types and Pattern Matching by Function Application, http://tinyurl.com/4kyxdv
22:59:10 <lambdabot> Title: Efficient Interpretation by Transforming Data Types and Patterns to Functions, http://tinyurl.com/5y5sge
22:59:16 <mmorrow> those are the two papers i have
22:59:48 <lispy> Nafai: ah, thanks for the link
23:00:39 <lispy> mmorrow: interesting.  "...cannot be typed by hindley-milner" sounds like you'd want to have a good reason for that given how powerful H-M is.
23:01:15 <jdrake> ok, everything is moved for proper directories in the modules, now I think I will move my utility functions out of the main module into their own and simplify the main a bit
23:01:19 <Eridius> hrm, which do you guys think is more efficient to do on an unsorted list with duplicates: nub . sort, or sort . nub
23:01:25 <Nafai> lispy: np
23:01:31 <Nafai> It's a very useful piece of software
23:01:50 * Eridius is guessing sort . nub, because nub doesn't take advantage of sorted lists
23:01:54 <jdrake> 17 imports, seems a lot
23:02:05 <mmorrow> dolio: here's that SAPL example in haskell http://hpaste.org/11048#a1
23:02:31 <sm> oh cool.. you can have haddock docs not attached to a particular definition
23:02:36 <lispy> Eridius: if you're going to sort it, you might as well not use nub, because I think it won't get faster?
23:02:51 <Eridius> lispy: what? I want to return a sorted list with duplicates removed
23:03:06 <mmorrow> and this shows the translation between SAPL and Haskell for lists http://hpaste.org/11048#a2
23:03:20 <lispy> Eridius: right, and I think nub is just going to be bad for you...I think sorting it won't make nub faster.
23:03:21 <inimino> Eridius: if you care about speed, write your own 'nub'-like
23:03:29 <Eridius> lispy: no, I'm suggesting that doing nub first might make sort faster
23:03:34 <Eridius> since sort will then operate on a smaller list
23:03:38 <sm> no, no.. I'm wrong. It merges with the next comment
23:03:39 <Eridius> but regardless, I need to remove duplicates, so I need to use nub
23:03:41 <lispy> ?hoogle Ord a => [a] -> [a]
23:03:41 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
23:03:41 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
23:03:41 <lambdabot> Prelude cycle :: [a] -> [a]
23:03:51 <inimino> nub will probably dominate sort
23:03:58 <mmorrow> lispy: the problem hindley-milner has with it is that SAPL uses infinite types
23:04:00 <lispy> Eridius: but sorting is asymptotically faster than nubing, but a fair bit
23:04:02 <Eridius> inimino: yeah, I was just asking out of curiosity
23:04:14 <Eridius> my lists aren't gigantic anyway
23:04:48 <Eridius> hrm, maybe I should use insert or some variant
23:04:50 <mmorrow> lispy: in SAPL everything is a function, even datatypes
23:04:56 <lispy> mmorrow: ah
23:05:01 <Eridius> there's no built-in way to merge two sorted lists into a new sorted one, right? I have to loop over one and insert into the other?
23:05:18 <dolio> mmorrow: Ah. I see. It gets around infinite types with unsafeCoerce.
23:05:27 <mmorrow> dolio: exactly
23:05:38 <Eridius> or maybe I should just be using union instead of ++
23:06:08 <rwbarton> Eridius: The good version of nub . sort is map head . group . sort
23:06:08 <lispy> Eridius: aren't Data.Maps what you want?  It's sorted and no duplicates
23:06:33 <Eridius> lispy: well, I'm really kinda overthinking this. I was just asking out of curiosity
23:06:36 <Eridius> it's not like performance matters here anyway
23:06:52 <lispy> Eridius: but, your algorithms do seem to hint that you want a Data.Map
23:06:59 <lispy> Eridius: then the merging becomes union
23:07:19 <Eridius> lispy: I suspect you mean Data.Set
23:07:22 <inimino> rwbarton is right though, there's no reason to ever use nub and sort together at all
23:07:27 <lispy> Eridius: doh, yes I mean Data.Set, thanks
23:08:05 * Eridius is working with divisors of numbers
23:08:15 <Eridius> I'm building the list of divisors out of the list of prime factors
23:08:28 <Eridius> but the way I do it ends up frequently duplicating divisors in the resulting list
23:08:32 <Eridius> and the resulting list is also unsorted
23:09:03 <lispy> Eridius: I'd totally use Data.Set.  And if you need a list when you're done, there are methods to convert back and forth
23:09:12 <Eridius> lispy: eh, fine. I'll give in
23:09:58 <lispy> Eridius: I don't thnk you'll be sorry :)
23:10:12 <Eridius> I think I just have to add a few "Set." prefixes to my operators
23:10:19 <Eridius> and turn [1] into Set.singleton 1
23:10:19 <mmorrow> dolio: one of those SAPL papers has a really cool pattern-match -> function compiler. i want to implem it in haskell
23:10:51 <Eridius> hrm, is Data.Set.elems === Data.Set.toList ?
23:10:54 <mmorrow> *_an algorithm for_ compiling ...
23:11:21 <lispy> ?hoogle Data.Set.elems
23:11:21 <lambdabot> Data.Set elems :: Set a -> [a]
23:11:35 <Eridius> elems: O(n). The elements of a set.
23:11:42 <Eridius> toList: O(n). Convert the set to a list of elements.
23:11:46 <Eridius> same type
23:11:55 <lispy> Eridius: oh weird
23:12:03 <Eridius> http://hackage.haskell.org/packages/archive/containers/0.1.0.1/doc/html/Data-Set.html#11
23:12:07 <lambdabot> Title: Data.Set, http://tinyurl.com/4eyjvx
23:12:47 <Eridius> bahaha, (divisors 0) hits stack overflow. Oops
23:12:54 <Eridius> not really sure what behavior it should exhibit there, though
23:13:13 <Eridius> of course, my (primeFactors 2) ends up creating an infinite list of 2's
23:13:29 <sm> lispy, next refinement: running that in an emacs shell with highlight-lines-matching-regexp showing Failures: 0 in green and failures in red
23:13:47 <lispy> sm: I'm not much help there
23:14:02 <sm> no problem, just reporting progress
23:14:20 <Nafai> sm: Are you rolling your own test system?
23:14:35 <sm> a test runner
23:14:38 <jdrake> What is wrong with this in the cabal file? Build-Depends:       base json
23:14:42 <jdrake> It doesn't like it
23:14:57 <sm> I've gone back to running make each time, it's less cpu intensive
23:15:22 <sm> now to use it for a while and see if it helps
23:15:26 <jdrake> nvm , helps
23:17:52 <Baughn> jdrake: You've failed to specify versions, too. That'll help, if you intend to have it compile with 6.10
23:18:35 <jdrake> Baughn, please describe
23:19:00 <jdrake> I am not sure it matters to me
23:19:06 <Baughn> jdrake: "base >= 3, base < 4" would do
23:19:25 <jdrake> Security.hs:28:7:
23:19:25 <jdrake>     Could not find module `System.FilePath':
23:19:25 <jdrake>       it is a member of package filepath-1.1.0.0, which is hidden
23:19:38 <jdrake> ghc never had a problem with this
23:19:47 <dons> jdrake: right, since --make picks whatever is on your system
23:19:51 <Baughn> ghc --make automatically pulls in the required packages
23:20:03 <dons> with .cabal you list explicitly the dependencies (and optional versions), and then it will contine to work into the future
23:20:09 <dons> so in this case, build-depends: base, json, filepath
23:20:12 <dons> (and maybe others)
23:20:19 <dons> now you know which packages you're implicitly using.
23:20:43 <jdrake> I am sure it will tell me by bitching at me until I put them all in :-)
23:20:58 <dons> yep.
23:21:03 <lispy> jdrake: you only go through this once though
23:21:06 <dons> but the benefit is, you'll be able to put the package on hackage
23:21:08 <jdrake> Should I put explicit versions in or >=?
23:21:10 <dons> then i can : $ cabal install foo
23:21:12 <lispy> jdrake: and you gain a lot afterwards :)
23:21:13 <dons> and it'll work.
23:21:30 <dons> jdrake: it's useful to set an upper range, but you can start by leaving them off.
23:21:39 <lispy> dons: does cabal install support a way of generating a 'likely' .cabal file for you?
23:21:40 <dons> cabal these days will pick something sensible.
23:21:48 <Baughn> jdrake: The packages will get upgraded, and mostly it'll continue to work. You could start by setting a lower version
23:21:52 <dons> lispy: no, but i think that would make a simple and easy web app
23:22:16 <Baughn> jdrake: It's just that base-4 is /known/ to be incompatible with base-3. ;)
23:22:16 <lispy> dons: why web?
23:22:29 <dons> lispy: so the kids can use it :-)
23:22:32 <jdrake> Baughn, understood
23:22:37 <dons> gimmeacabalfile.oorg
23:22:40 <lispy> dons: I was thinking something like mkcabal that you started.  You run it in the dir and you get an example .cabal file that is likely to work
23:22:46 <dons> yeah.
23:22:55 <dcoutts> lispy: I want to integrate dons's mkcabal into cabal-install, like cabal init
23:23:03 <lispy> it can crawl through your directory to figure stuff out :)
23:23:08 <lispy> dcoutts: right
23:23:14 <lispy> cabal guess-config
23:23:27 <lispy> dons: so does mkcabal still work?
23:23:29 <jdrake> RSA/StringUtils.hs:35:7:
23:23:29 <jdrake>     Could not find module `Random':
23:23:29 <jdrake>       it is a member of package haskell98, which is hidden
23:23:36 <Armored_Azrael> Hey, does anyone happen to know where in haskell OpenGL, the bindings for specifing uv texture coordinates are?
23:23:36 <jdrake> I have to include this too?
23:23:50 <dons> jdrake: so you are using the 'Random' module, which is in 'haskell98'
23:23:56 <sjanssen> jdrake: you should use System.Random instead
23:24:02 <dons> so likely you could just use System.Random, from the 'random' package
23:24:13 <jdrake> This is in the RSA that I am using, I am not buggering with it
23:24:27 <jdrake> If it were part of my own code, I would do what you say in a heartbeat
23:24:30 <dons> so then you need to depend on 'haskell98'
23:24:33 <lispy> Armored_Azrael: hmm...hoogle might have an index of that
23:24:50 <dons> it's really ok though, System.Random just provides the Random code that the haskell98 compat layer uses
23:24:58 <Armored_Azrael> lispy: Unfortunately no--I've been searching through the "Texturing" submodule under GL, but haven't found the releavent function yet.
23:25:09 <dons> jdrake: do you have a .cabal file to work from, btw?
23:25:14 <lispy> ?hoogle texture
23:25:14 <lambdabot> No results found
23:25:21 <jdrake> dons, yes, let me show it
23:25:32 <dons> 'sok. just checking.
23:25:38 <dons> i  was going to suggest http://hackage.haskell.org/packages/archive/cabal2arch/0.4/cabal2arch.cabal
23:25:40 <lambdabot> http://tinyurl.com/3khyxs
23:25:41 <jdrake> http://hpaste.org/11049
23:25:44 <lispy> Armored_Azrael: I'm not of much help here, my foray into HOpenGL didn't get that deep
23:26:20 <dons> ok. looking good. that's the old style cabal file, which is probably fine.
23:26:32 <dons> now, probably you don't really need filepath >= 1.1.0.0, but actually just 'filepath >= 1'
23:27:03 <lispy> dons: interesting, jdrake started from a tutorial linked from the cabal webpage
23:27:10 <dons> ok.
23:27:16 <Armored_Azrael> lispy: OK. It's kind of annoying, because the Texturing module in general isn't particularly well abstracted--for example, you need to construct a pointer to set the current texture.
23:27:19 <lispy> dons: so I guess the wikibook tutorial is a bit dated?
23:27:28 <dons> yeah. good call.
23:28:38 <lispy> Armored_Azrael: yeah, HOpenGL is a bit half-baked IMO.  It should be more layered...like a true plain opengl wrapper and then provide some Haskelly wrappers on top of that.  Instead what we have is just one layer that is Haskelly in places and just a primitive wrapper else where.
23:29:29 <quicksilver> Armored_Azrael: the constructing a pointer is hardly a hardship though
23:29:37 <quicksilver> Armored_Azrael: just use 'withArray'
23:30:15 <quicksilver> Armored_Azrael: and you specify UV coords with 'texCoord'
23:30:17 <Axman6> isn;t that what HGL is for? (i don't know much about either)
23:30:19 <quicksilver> (much like in C)
23:30:21 <Armored_Azrael> quicksilver: Yes, it's fine, I have that part working, it just doesn't seem like the kind of thing you want to still be in the type sigs when you're done writing bindings
23:30:28 <Armored_Azrael> quicksilver: Thanks!
23:30:52 <quicksilver> well, people who wrote openGL are often concerned with memory copy speed and memory bandwidth
23:30:57 <quicksilver> you don't want to hide the Ptr too much
23:31:06 <quicksilver> people might be very concerned with minimising copies.
23:31:12 <quicksilver> s/wrote/write/
23:31:44 <lispy> quicksilver: yes, and also I found it hard to translate from knowing some opengl to knowing any HOpenGL
23:31:58 * quicksilver shrugs.
23:31:59 <quicksilver> I didn't.
23:32:05 <jdrake> Ok, this thing makes the app binary go in dist/build/starz/starz when I need something like ./starz, what can I do to make this happen?
23:32:07 <Armored_Azrael> quicksilver: Elsewhere, the pointer version of a function is available by appending v, this seemed a bit better to me
23:32:08 <lispy> quicksilver: which is why I was surprised it's haskell-ish in places and direct in other places
23:32:10 <hackage> Uploaded to hackage: terminfo 0.2.2.1
23:32:13 <Armored_Azrael> (e.g. vertex vs vertexv)
23:32:19 <quicksilver> It clearly must be an issue because you're not the only one who has said this.
23:32:32 <quicksilver> but I found HOpenGL pretty obvious, for the most part.
23:32:44 <quicksilver> poorly documented and requiring the occasionaly grep to find the right function, sure.
23:33:08 <lispy> poorly documented is at the cruxt of my complaint to be sure
23:34:27 <lispy> I was also surprised with how often you have to give explicit types in HOpenGL, but now that I'm a more seasoned Haskell programmer I would probably just add more types anyway.
23:34:51 <lispy> my experience has been, the more rigid types you can give the better you're going to be :)
23:35:07 <Baughn> Hum. How /do/ you specify texture coordinates? I can't find it.
23:35:21 <sjanssen> jdrake: cp?
23:35:40 <jdrake> sjanssen, I mean automatically when building
23:35:43 <sjanssen> jdrake: do you really need it to be in .?
23:35:44 <lispy> Baughn: <quicksilver> Armored_Azrael: and you specify UV coords with 'texCoord'
23:35:51 <sjanssen> jdrake: symlink?
23:35:55 <Baughn> lispy: That's in C
23:36:01 <Baughn> Oh, wait
23:36:07 <jdrake> I suppose a symlink will survive a clean
23:36:23 <sjanssen> jdrake: why do you need the executable to be in .?
23:36:25 <jdrake> Ideally though,it would be nice to do it after built automatically for me
23:36:28 <Baughn> ..it's not in the texturing block, though
23:36:41 <jdrake> sjanssen, because I am just starting this thing and like to test it that way
23:37:09 <sjanssen> jdrake: there aren't very many good options (Cabal will only put generated files in dist/)
23:37:44 <mmorrow> dolio: awesome: http://hpaste.org/11048#a3
23:37:52 <sjanssen> jdrake: you could write a custom Setup.hs (ugly, probably a fair amount of work), you could fiddle with destination dirs and also run 'Setup install'
23:38:01 <Cale> http://img.thedailywtf.com/images/200810/errord/Nautilus_egg.jpg -- haha
23:38:16 <Baughn> @hoogle texCoord
23:38:16 <lambdabot> No results found
23:38:24 <mmorrow> Cale: heh
23:39:11 <jdrake> sjanssen, so cabal makes it easier in one way and more difficult in the other ;-(
23:39:18 <lispy> actually, I've often wanted cabal to dump the binary when it's executable into the same level as Setup.hs on many occassions too
23:39:47 <sjanssen> jdrake: Cabal is what we call opionated software
23:40:04 <sjanssen> opinionated
23:40:25 <lispy> jdrake: you just need an automated way to make it copy a file to ./, right?
23:40:31 <lispy> jdrake: then you wouldn't mind?
23:40:50 <sjanssen> jdrake probably also wants it to go away with "Setup clean"
23:41:00 <jdrake> yes
23:41:28 <quicksilver> Baughn: it's probably in vertex attributes
23:41:34 <lispy> jdrake: so you could make, make.sh and clean.sh, respectively they invoke cabal and do deal with the binary in .
23:41:36 <quicksilver> the blocks are based on the chapters of the OGL spec
23:41:37 <quicksilver> I think.
23:41:46 <Baughn> ..yeah, it is
23:41:57 <Baughn> Hm. How do I make hoogle index the opengl package?
23:42:09 <jdrake> lispy, gotcha, that can work
23:42:53 <lispy> jdrake: plus it will be less typing that runghc Setup.hs build, everytime you want to make
23:43:23 <dmwit> jdrake: I just symlink the executable for quick and dirty testing.
23:43:33 <lispy> jdrake: alternatively you could use a makefile with 2 targets :)
23:43:49 <lispy> symlink is a good solution too
23:43:50 <dmwit> Oh, I see you already thought of that (and discarded the idea, for some reason?).
23:44:11 <lispy> jdrake: and the makefile just invokes cabal and copies or deletes the file
23:44:42 <jdrake> I wonder if bzr will pick up on broken symlinks
23:44:54 <jdrake> If it won't, then it won't matter if it is there
23:45:28 <dmwit> I'm sure bzr has an ignore list, just like every other version control system out there.
23:45:39 <jdrake> I might be the only one in the haskell world not using darcs
23:45:46 * dmwit uses git
23:45:50 <dolio> mmorrow: Is that better than Church encoding and rank-2 polymorphism?
23:45:57 <lispy> jdrake: git is pretty popular across the board, so I don't think so
23:46:42 <lispy> and some people are using svn!
23:46:45 * Nafai also uses git
23:47:29 <dmwit> I doubt any Haskell people use svn over darcs.
23:47:34 <dmwit> ...on purpose.
23:47:47 <dolio> I'd certainly be partial to an encoding that doesn't use unsafeCoerce.
23:47:53 <jdrake> Isn't svn just a little less annoying than cvs?
23:48:25 <mmorrow> dolio: i'm not quite sure, but from those papers it seems like SAPL is /super/ fast to interpret because all after you've translated whatever to SAPL, all you have to do to eval it is essentially to call it.
23:48:52 <mmorrow> s/because all after you've/because after you've/
23:48:58 <Baughn> jdrake: svn is much better than cvs, sure
23:49:15 <Baughn> That's just not saying much, these days
23:49:16 <jdrake> How did cvs end up being used so heavily?
23:49:22 <Baughn> It was the only thing around
23:49:30 <jdrake> What about rcs?
23:49:41 <Baughn> rcs doesn't do networks
23:50:00 <Baughn> (And is, in general, even worse than cvs)
23:50:05 <idnar> cvs was basically built on top of rcs, wasn't it?
23:50:11 <Eridius> @hoogle put
23:50:11 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
23:50:11 <lambdabot> Prelude putChar :: Char -> IO ()
23:50:11 <lambdabot> System.IO putChar :: Char -> IO ()
23:50:31 <Baughn> idnar: That may have been how it started, but if so, it acquired features rcs didn't have
23:50:57 <Baughn> Well, never mind. cvs is thoroughly dead; we don't have to suffer anymore.
23:51:57 <mmorrow> dolio: i've been looking at ghci recently. so when you compile an expression to bytecode, you get an HValue back, where data HValue = HValue Any. then it's unsafeCoerced to the value you gave it. since it was checked to be that value by the compiler, it's safe. so i think as long as phantom types/GADTs are used, (and the basic translation is deemed correct/safe), it's safe.
23:52:08 <jeffz> Baughn, not quite dead, some projects still seem to use it on sourceforge
23:53:12 <dolio> Sure.
23:53:13 <lispy> if you're going to use an open source centralized vcs i don't see any reason to avoid svn.  But, then I tell everyone to use dvcs even if you have centralized development because it's a win.
23:53:29 <Eridius> git ftw
23:53:34 <mmorrow> dolio: also, apparently in ghc you have to use Any instead of (forall a. a) for a type to unsafeCoerce to, since if you're unsafeCoercing a function, it shouldn't be entered, and if the compiler thinks a value is a data, it may gen code to enter it, which'll then segfault
23:53:36 <jeffz> http://cia.vc/stats/vcs
23:54:17 <rwbarton> mmorrow: i've seen this statement before, but haven't understood it.  what does "enter" mean here?
23:54:51 <lispy> jeffz: that has a pretty strong selection bias though, as I understand it
23:55:12 <mmorrow> rwbarton: i believe it means that datas have an infotable then their payload, but functions have no infotable, just the code of the funciton.
23:55:18 <jeffz> lispy, yeah. cia.vc is opt-in
23:55:36 <lispy> mmorrow: unsafeCoerce on phantom types is just as dangerous as using it on non-phantom types
23:55:41 <mmorrow> so "entering" a function i think means trying to interpret arbitrary machine code at that functions starting address as an infotable
23:56:10 <Baughn> rwbarton: So, dethunk
23:56:14 <Baughn> Functions can't be thunks
23:56:17 <lispy> jeffz: plus, isn't .vc the vatican?
23:56:50 <jeffz> lispy: what if it is?
23:57:11 <mmorrow> lispy: i'm not saying it's any safer. but since you're tracking the type in the typesystem, you're doing nothing more or less than what ghci is doing.
23:57:21 <lispy> jeffz: I was going to make a joke in poor taste against catholocism wrt to cia :)
23:57:40 <Baughn> jeffz: One thing I've noticed about open source, most of the coders are extremely conservative. cvs worked, so they use cvs.
23:58:47 <jeffz> Baughn: that's about the same response I've received when asking why they're not interested in finding out what the new dcvs have to offer, it's what they know and they're fine with not knowing any better.
23:58:54 <dons> also, i'm not sure people (at least in the past) used to think about this stuff much
23:58:57 <dons> there was only cvs.
23:59:10 <dons> we didn't have huge open development teams, infrastructure and resources.
23:59:21 <Baughn> We couldn't
23:59:45 <dons> even the haskell guys have half a dozen servers, distributed build systems, centralised code and package hosting, irc channels with 100s . way way more organised, better tools.
23:59:47 <jdrake> open source coders being conservative?
23:59:54 <mmorrow> rwbarton: (probably that's not exactly correct, but it's something more or less along those lines)
