00:02:56 <jdrake> sjanssen, how about these two: http://hpaste.org/11632#a4
00:03:15 <jdrake> The first one fails with c not in scope
00:03:29 <jdrake> in the [c] line
00:04:27 <sjanssen> jdrake: this is why layout is tricky :)
00:04:44 <sjanssen> jdrake: indent <|> by one more space
00:04:45 <jdrake> I am trying to logically place the <|>
00:04:46 <sbahra> :t testBit
00:04:47 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
00:05:20 <jdrake> Was I right in assuming that <|> was the alternative for the inner do?
00:05:36 <Beelsebob> http://hpaste.org/11632#a5
00:05:49 <Beelsebob> oops, missd a <*>
00:05:51 <sjanssen> jdrake: in the example, yes
00:06:07 <Beelsebob> http://hpaste.org/11632#a6 <-- that one even
00:06:12 <sjanssen> jdrake: but in your edit it is the alternative to the outer do
00:06:38 <jdrake> Beelsebob, I am a beginner please do not try to wow me with tricks of fancy
00:07:00 <Beelsebob> it's not a trick of fancy
00:07:14 <Beelsebob> it's just using the applicative interface instead of the monadic one to clean up you code
00:07:16 <jdrake> It looks like I might have a chance at actually writing a parser for my target.
00:07:34 <jdrake> Beelsebob, its confusing, and it is late at night
00:07:34 <Beelsebob> and to remove the imperative code
00:07:50 <Beelsebob> well, I can explain it if you like
00:08:34 <rwbarton> http://hpaste.org/11632#a7 is in the same spirit, but less drastic
00:08:45 <Beelsebob> yep
00:09:15 <jdrake> rwbarton, I think if I were to choose I would go with your version
00:09:25 <Beelsebob> or use liftM2 (:) letter (word <|> return [])
00:09:31 <sjanssen> http://hpaste.org/11632#a8
00:09:32 <jdrake> But I need things to be laid out as easiest for me to see
00:09:46 <sjanssen> rwbarton: liftM is an abomination!
00:09:49 <sjanssen> liftM--
00:09:54 <rwbarton> Um
00:10:02 <jdrake> liftM ftw!
00:10:05 <Beelsebob> jdrake: I'd argue that the one that says "apply cons to a letter and a word" is the easiest to see ;)
00:10:09 <sjanssen> fmap is clearly superior
00:10:34 <rwbarton> Personally I use <$> most of the time, but I wanted the relation to the previous version to be as clear as possible
00:10:39 <Beelsebob> yep
00:10:57 <sm> an output buffering question. I print part of a line, then run a slow command, then the rest of the line. I'd like the first part to appear immediately. I've tried hFlush stdout after the first print, and hSetBuffering stdout NoBuffering - no joy. How come ?
00:11:23 <jdrake> Beelsebob, tell me - what would happen to a c++ programmer that just did his first cout <<... and you gave him full blown templates?
00:11:46 <Beelsebob> jdrake: note -- Applicatives are *less* powerful and complex than monads
00:11:53 <Beelsebob> they just produce neater code a lot of the time
00:12:01 <Beelsebob> so if you can get monads, you should be able to get this too
00:12:03 <sjanssen> jdrake: if the programmer accepts "cout <<" then he is clearly okay with parroting without understanding :)
00:12:05 <jdrake> Beelsebob, I will consider them once I understand these :p
00:12:08 <Beelsebob> plus, rwbarton showed you the relationship
00:12:20 <Beelsebob> all the <$> and <*> do is essentially a liftM2
00:13:02 <jdrake> sjanssen, you can understand syntax sometimes without understanding what is below it. I am not sure if that is the case with beelsebob's code.
00:13:04 <Beelsebob> you even have the progression from one to the other -- start with the monadic one, and fold one do into a liftM
00:13:28 <Beelsebob> jdrake: sure, it's possible with that code
00:13:35 <jdrake> Beelsebob, I will enquire some time turning the day after some sleep
00:13:48 <Beelsebob> (<$>) is just like ($) -- only it does it at a higher level
00:13:57 <thoughtpolice> applicatives are pretty much monads without the ability to wire names to values, and therefore more general - hence when you use them your code is 'applicative'
00:14:03 <Beelsebob> so instead of applying functions to values, it applies functions to values inside "applicatives"
00:14:32 <sjanssen> #haskell is attempting to forcibly teach applicatives, apparently
00:14:37 <Beelsebob> hehe
00:15:18 <Beelsebob> I think #haskell is getting worried by the guy who says "argh, it's more complex" when shown a simple one liner, instead of a nasty pair of nested monadic do blocks
00:15:38 <jdrake> Beelsebob, I can handle nested do blocks :p
00:15:51 <Beelsebob> yeh, and I'm *guessing* you can handle this too
00:15:58 <Beelsebob> in that all it is is function application
00:16:00 <jdrake> Probably after some sleep
00:16:18 <Beelsebob> it litterally says "apply (:) to letter and (word <|> (return []))"
00:16:23 <sbahra> :t <$>
00:16:24 <lambdabot> parse error on input `<$>'
00:16:30 <Beelsebob> :t (<$>)
00:16:30 <sbahra> :t (<$>)
00:16:31 <sjanssen> Beelsebob: there is also nothing wrong with focusing on learning one thing at a time
00:16:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:16:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:16:41 <jdrake> Beelsebob, I will take your explanation tomorrow
00:16:48 <Beelsebob> jdrake: fair enough
00:17:06 <sbahra> Useful
00:17:12 <jdrake> I can accept english explanations tonight and read another time ;p
00:17:17 <Beelsebob> sbahra: aka liftA, liftM and fmap
00:17:33 <jdrake> :t LiftA
00:17:34 <lambdabot> Not in scope: data constructor `LiftA'
00:17:36 <jdrake> :t liftA
00:17:37 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
00:17:47 <jdrake> :t liftM
00:17:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:18:01 <Beelsebob> sbahra: (<*>) is what really makes it useful
00:18:10 <sbahra> :t (<*>)
00:18:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:18:19 <Beelsebob> because it allows you to generate liftAn simply by inserting n-1 <*> operators
00:18:25 <jdrake> ok, what quite is liftA in difference to liftM?
00:18:43 <Beelsebob> jdrake: liftM is restricted to fewer things
00:18:48 <Beelsebob> because all monads are applicatives
00:18:52 <Beelsebob> but not all applicatives are monads
00:18:54 <sbahra> :t forM_
00:18:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
00:19:00 <Beelsebob> but otherwise, they do the same thing
00:19:01 <adu> @pl (f c [] = [c] ; f c (x:xs) = c : f (x+c) xs)
00:19:01 <lambdabot> (line 1, column 9):
00:19:02 <lambdabot> unexpected "="
00:19:02 <lambdabot> expecting variable, "(", operator or ")"
00:19:05 <sbahra> forM_ is really nice
00:19:09 <jdrake> Can can you use liftA in place of liftM?
00:19:19 <Beelsebob> jdrake: you can indeed
00:19:25 <adu> @pl let f c [] = [c] ; f c (x:xs) = c : f (x+c) xs in f
00:19:26 <lambdabot> (line 1, column 9):
00:19:26 <lambdabot> unexpected "["
00:19:26 <lambdabot> expecting pattern or "="
00:19:26 <jdrake> What is an applicative
00:19:38 <sbahra> jdrake, http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
00:19:51 <sjanssen> NEVER USE liftA OR liftM!!!!
00:19:54 <Beelsebob> jdrake: it's a similar concept to a monad, but the restrictions on them are slightly less tight
00:20:07 <sbahra> :t fmap
00:20:07 <sjanssen> fmap IS THE ONE TRUE fmap!!!!
00:20:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:20:12 <Beelsebob> which means that your interface is slightly more capable
00:20:13 <adu> @pl f where f c [] = [c] ; f c (x:xs) = c : f (x+c) xs
00:20:13 <lambdabot> (line 1, column 16):
00:20:13 <lambdabot> unexpected "="
00:20:13 <lambdabot> expecting variable, "(", operator or end of input
00:20:16 <rwbarton> sjanssen: I should never use (.) either, right?
00:20:22 <Beelsebob> sjanssen: <$> is the one true fmap!
00:20:24 <Beelsebob> :P
00:20:24 <sjanssen> rwbarton: no, (.) is okay :)
00:20:33 <rwbarton> sjanssen: Hmm, seems inconsistent :P
00:20:37 <sjanssen> Beelsebob: maybe, once it is in a Haskell standard
00:20:39 <jdrake> :t liftM2
00:20:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:21:02 <sjanssen> rwbarton: I don't find the (.)/fmap connection very compelling.  Besides, the necessary instance isn't in the Prelude
00:21:08 <sbahra> :t ad
00:21:09 <lambdabot> Not in scope: `ad'
00:21:11 <Beelsebob> :t liftAt
00:21:12 <lambdabot> Not in scope: `liftAt'
00:21:13 <Beelsebob> :t liftA2
00:21:14 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
00:21:30 <sbahra> :t ap
00:21:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:21:38 <Beelsebob> :t ?f <$> ?a <*> ?b
00:21:39 <lambdabot> forall a a1 b (f :: * -> *). (?b::f a1, Applicative f, ?a::f a, ?f::a -> a1 -> b) => f b
00:21:43 <sbahra> :t liftM
00:21:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:21:45 <sbahra> :t ap
00:21:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:22:31 <jdrake> I am going to bed before my head implodes
00:23:01 <sbahra> fmap is cool
00:23:35 <sbahra> :t pure
00:23:36 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:23:48 <jdrake> pure []
00:23:50 <jdrake> > pure []
00:23:51 <lambdabot>       Ambiguous occurrence `pure'
00:23:51 <lambdabot>      It could refer to either `Control.Appl...
00:24:05 <jdrake> help with that pls
00:24:13 <sbahra> @hoogle pure
00:24:13 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
00:24:13 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
00:24:13 <lambdabot> package pureMD5
00:24:20 <jinjing>   > pure [] :: []
00:24:25 <sjanssen> > Control.Applicative.pure [] :: [()]
00:24:26 <lambdabot>   Couldn't match expected type `()' against inferred type `[a]'
00:24:37 <jinjing> > pure [] :: []
00:24:38 <lambdabot>       Ambiguous occurrence `pure'
00:24:38 <lambdabot>      It could refer to either `Control.Appl...
00:24:44 <sjanssen> > Control.Applicative.pure [] :: [[()]]
00:24:45 <lambdabot>   [[]]
00:25:02 <sjanssen> jdrake: pure is just return, except it is in the Applicative class
00:25:10 <jdrake> wierd
00:25:15 <Beelsebob> yep
00:25:24 <Beelsebob> monads and applicatives are very similar
00:25:27 <jinjing> :t return
00:25:28 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:25:35 <sjanssen> @type Control.Arrow.pure
00:25:37 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
00:25:44 <sjanssen> just conflicting imports
00:25:57 <jinjing> :i pure
00:26:01 <Beelsebob> @type Control.Applicative.pure
00:26:02 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
00:26:50 * Beelsebob disapears to work
00:26:53 * sbahra sleeps
00:27:16 <jdrake> I will look into applicatives, I have mostly an understanding of monads
00:27:20 <sbahra> oh
00:27:47 <sjanssen> jdrake: if you've used Control.Monad.ap, you already understand Applicative
00:27:54 <sbahra> :t ?f <$> ?a <*> ?b
00:27:55 <lambdabot> forall a a1 b (f :: * -> *). (?b::f a1, Applicative f, ?a::f a, ?f::a -> a1 -> b) => f b
00:28:00 <sbahra> What is the purpose of the question marks in there?
00:28:00 <jdrake> I don't know if I have sjanssen
00:28:22 <sbahra> jdrake, http://book.realworldhaskell.org/read/monad-transformers.html
00:28:24 <lambdabot> Title: Chapter 18. Monad transformers
00:28:29 <sjanssen> sbahra: ?f is an implicit parameter
00:28:51 <sbahra> sjanssen, can you give me a very simple example?
00:29:46 <sjanssen> y = ?x + 1; main = print (let ?x = 100 in y)
00:30:07 <sbahra> Ah
00:31:03 <sjanssen> the type of y is "(?x :: Integer) => Integer"
00:31:27 <sjanssen> (I think, not sure how the MR interacts with implicit parameters)
00:31:31 <sbahra> cool
00:31:50 <sjanssen> sbahra: implicit parameters are not a very popular extension
00:31:58 * sbahra is looking at http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
00:32:03 <lambdabot> Title: Implicit parameters, http://tinyurl.com/35uxrh
00:32:17 <sjanssen> huh, I didn't even know hugs supported them
00:49:20 <adu> omg
00:49:32 <adu> I just fit a hello world into 4 byte
00:49:48 <adu> "e\184-\235"
00:52:36 <adu> lolol
00:54:41 <jsn> adu: whaaa??
00:56:18 <adu> http://hpaste.org/11635
00:57:05 <adu> its one of those things you write once, then look at it in the morning and say "what idiot wrote that?!?"
00:57:57 <adu> it requires Data.{Bits,Char,Word}
01:00:39 <StoneToad> I'm trying to fold a predicate over a list to check if it's sorted or not, currently I have rolled a sorta nasty recursive function to do it, but I feel like I'm missing something since it seems like it should be one of those obvious operations
01:01:02 <adu> StoneToad: "all"
01:01:16 <StoneToad> that only gives me a single argument predicate though
01:01:23 <ski> @quote aztec
01:01:24 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
01:01:51 <adu> StoneToad: oh, then nub? maybe?
01:02:09 <adu> what kind of checking are you doing?
01:02:12 <ski> > all (uncurry (<=)) ((zip `ap` tail) [1,3,5,6])
01:02:13 <lambdabot>   True
01:02:13 <StoneToad> what does zip `ap` tail?
01:02:16 <ski> > all (uncurry (<=)) ((zip `ap` tail) [1,3,7,5,6])
01:02:17 <lambdabot>   False
01:02:23 <ski> > (zip `ap` tail) [1,3,5,6]
01:02:24 <lambdabot>   [(1,3),(3,5),(5,6)]
01:02:26 <StoneToad> ohh wow
01:02:37 <StoneToad> that's exactly what I was looking for I think
01:02:46 <ski> > let xs = [1,3,5,6] in xs `zip` tail xs
01:02:47 <lambdabot>   [(1,3),(3,5),(5,6)]
01:03:02 <ski> however, beware passing empty lists to `tail'
01:03:07 <ski> > let xs = [] in xs `zip` tail xs
01:03:08 <lambdabot>   []
01:03:20 <ski> er, actually, it works out fine here :)
01:03:20 <sjanssen> @src zip
01:03:20 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
01:03:20 <lambdabot> zip _      _      = []
01:03:25 <StoneToad> now to try to understand how it works
01:03:47 <ski> (because of which order `zip' pattern-matches on its arguments)
01:04:10 <StoneToad> I can't seem to find ap in the prelude function index...
01:04:21 <ski> @type Control.Monad.ap
01:04:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:04:25 <Axman6_> StoneToad: i think i can see problems in that function
01:04:36 <Axman6_> like, [1,3,2,4] might be true
01:04:48 <ski> you don't need to use `ap' if you don't want to .. you can use the `xs `zip` tail xs' thing instead
01:05:30 <ski> (through if you don't have the list in a variable already, then you have to either invent a name or have code duplication)
01:05:56 <StoneToad> the list is already in a variable so it's not a problem :)
01:06:25 <ski> (.. unless you use `ap' or some similar thing)
01:10:03 <Axman6> oh, missed that it went to [(1,3),(3,2)...]
01:11:27 <StoneToad> ski: thanks a lot, knowing how to use uncurry is really cool
01:11:33 <StoneToad> uncurry + zip
01:12:07 <StoneToad> I feel like a total newbie again trying to learn functional programing, hehe
01:12:20 <StoneToad> so different from all the stuff I've done so far
01:15:56 <xenoblitz> guys if you have a list of list of Bool ([[Bool]]) where each [Bool] is considered as a row, how would one elegantly count the number of True's in the COLUMNs of such a structure? My solution is very messy and I should think its much easier than what I have
01:17:16 <sjanssen> map (length . filter id) . transpose
01:17:17 <andun> > map (length . filter (==True)) [[True,False],[False,True,True]]
01:17:18 <lambdabot>   [1,2]
01:17:48 <xenoblitz> sjanssen: wow
01:17:52 <andun> sorry, columns :)
01:17:59 <xenoblitz> still nice
01:18:11 <xenoblitz> but yes columns :/
01:18:21 <sjanssen> >  map (length . filter id) . transpose  $ [[True,False],[False,True,True]] -- columns, see?
01:18:22 <lambdabot>   [1,1,1]
01:18:24 <andun> xenoblitz: sjanssen's counts columns
01:19:21 <xenoblitz> lol i am lost to be honest hehe
01:19:45 <xenoblitz>  map (length . filter id) . transpose  $ [[True,False],[True,True,True]]
01:20:07 <xenoblitz> map (length . filter id) . transpose  $ [[True,False],[True,True,True]]
01:20:19 <BeelsebobWork_> > let (<^) = flip (<$>); (^>) = (<*>) in [2,3,4] <^ (*) ^> [3,4,5]
01:20:20 <lambdabot>   [6,8,10,9,12,15,12,16,20]
01:20:22 <BeelsebobWork_> :D
01:20:25 <xenoblitz> guys why isn't lambdadot working for meh?
01:20:32 <ivanm> xenoblitz: if you're trying to get lambdabot to evaluate it, you need to prepend "> " to your command
01:20:45 <xenoblitz> > map (length . filter id) . transpose  $ [[True,False],[True,True,True]]
01:20:46 <lambdabot>   [2,1,1]
01:20:51 <xenoblitz> thanks
01:20:54 <ivanm> she doesn't automatically run any and all haskell fragments she finds
01:21:01 <sjanssen> > tranpose [[True,False],[True,True,True]]
01:21:02 <lambdabot>   Not in scope: `tranpose'
01:21:07 <sjanssen> > transpose [[True,False],[True,True,True]]
01:21:08 <lambdabot>   [[True,True],[False,True],[True]]
01:21:25 <ivanm> BeelsebobWork_: hmmmm.... we need to create proper Haskell bra and ket operators! ;-)
01:21:39 <BeelsebobWork_> ivanm: yeh, but those are rather lovely anyway :)
01:21:44 <ivanm> yeah
01:21:55 <BeelsebobWork_> also... I declare them to be the cat ear brackets
01:21:56 <BeelsebobWork_> :P
01:22:00 <ivanm> lol
01:22:14 <xenoblitz> i am so amazed at haskell... and I am realizing that most of the things I am doing can be rewritten in 1 liners :S
01:22:33 <xenoblitz> its scary stuff!
01:24:55 <dabblego> > length $ filter id $ Data.Foldable.and <$> listToMaybe <$> [[True,False],[False,True,True],[True],[]]
01:24:56 <lambdabot>   3
01:26:32 <ivanm> <$> == fmap, doesn't it?
01:26:42 <ivanm> so that's going on each sublist?
01:27:00 <dabblego> yes it does
01:27:33 <dabblego> (<$> == fmap)
01:27:36 <ivanm> so why not just have: length $ filter id $ and $ <lists>
01:28:13 <sjanssen> dabblego: that doesn't go on each sublist
01:28:27 <sjanssen> oh, missed the <$>, ignore my comment
01:28:39 <sjanssen> but it still doesn't really do the right thing
01:28:41 <dabblego> I'm not sure what we're calling columns, so I just guessed
01:28:53 <sjanssen> that just measures the first column
01:29:08 <dabblego> oh I misread
01:29:30 <sjanssen> what we really want is transpose, which is happily included in Data.List
01:29:38 <dabblego> yes indeed
01:29:53 <sjanssen> @src transpose
01:29:54 <lambdabot> transpose []             = []
01:29:54 <lambdabot> transpose ([]   : xss)   = transpose xss
01:29:54 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
01:30:19 <saft> how do i install cabal on fedora?
01:30:42 <BeelsebobWork_> saft: install ghc
01:30:44 <sjanssen> saft: it is most likely installed with GHC
01:30:53 <saft> cabal-install i mean
01:30:54 <BeelsebobWork_> if you want cabal-install, then grab the package of hackage
01:31:09 <BeelsebobWork_> and runhaskell Setup configure etc
01:31:40 <saft> what is the name of the fedora yum package cabal-install?
01:31:52 <saft> sudo yum install cabal-install -> no such package
01:32:11 <BeelsebobWork_> yum list | grep -i cabal?
01:32:22 * BeelsebobWork_ has no idea if yum has a list command
01:32:42 <saft> | is or right?
01:32:51 <sjanssen> saft: there probably isn't a package for it
01:32:54 <saft> so if yum has no list command it does grep -i cabal instead?
01:32:57 <sjanssen> cabal-install is fairly new
01:33:19 <BeelsebobWork_> saft: no, | is pipe
01:33:23 <BeelsebobWork_> it's (.) but backwards
01:33:24 <sjanssen> saft: | is pipe, it sends the output of yum list to the input of grep -i cabal
01:33:28 <saft> ok
01:34:20 <quicksilver> BeelsebobWork_: woo, my openGL scaffold is finally useful! I have turned the mouse motion callback into a mousePos :: Behaviour (Int,Int)
01:34:31 <BeelsebobWork_> quicksilver: :D shiny
01:34:38 <BeelsebobWork_> quicksilver: have you tried reactive-glut btw?
01:34:39 <saft> if i want do combine filter and mapas (filter . map) ohow do i eite that?
01:34:55 <saft> with predicates and cuntions
01:34:58 <saft> functions
01:34:58 <quicksilver> BeelsebobWork_: no :) I'm sure it's got everything I have and much more besides.
01:35:00 <dabblego> saft, list comprehension perhaps?
01:35:08 <BeelsebobWork_> > filter (<5) . map (*2) $ [1,2,3,4,5]
01:35:09 <lambdabot>   [2,4]
01:35:12 <saft> well iw ant to use functioncomposition
01:35:15 <quicksilver> BeelsebobWork_: but, I'm just pleased to have implemented a clean frame rate independentGL scaffold of my own :)
01:35:17 <saft> i know
01:35:27 <saft> but im wondering about function compositiona ctually :)
01:35:41 <BeelsebobWork_> quicksilver: I'd be interested actually -- I'd love to see you compare the two and see if ideas can cross over
01:35:58 <quicksilver> BeelsebobWork_: is it in the main reactive repo?
01:36:25 <dabblego> @type (. map) . (.) . filter
01:36:26 <lambdabot> forall a a1. (a1 -> Bool) -> (a -> a1) -> [a] -> [a1]
01:36:32 <BeelsebobWork_> quicksilver: http://conal.net/repos/reactive-glut/
01:36:32 <lambdabot> Title: Index of /repos/reactive-glut
01:36:53 <saft> like let fun f p = (filter p . map f) ?
01:37:31 <BeelsebobWork_> quicksilver: this is how my obj-loading example comes out... http://hpaste.org/11604#a1
01:37:33 <quicksilver> BeelsebobWork_: looks very similar.
01:37:38 <BeelsebobWork_> it kinda enaples rather lovely code
01:37:41 <dabblego> let fun f p x = filter f (map f x)
01:37:52 <dabblego> let fun f p x = filter p (map f x)
01:38:16 <quicksilver> BeelsebobWork_: looks very nice.
01:38:27 <saft>  let fun f p = (filter p . map f)
01:38:29 <saft> yes
01:39:01 <BeelsebobWork_> quicksilver: I'm interested -- we had some issues with threads and starvation and timers, did you run into any of that?
01:41:41 <BeelsebobWork_> the other problem I've come across is that GLUT's timer granularity is only enough to allow 800fps -- so I can no longer find out how fast my code is running
01:42:04 <BeelsebobWork_> (I used to just be rendering again the second I'd finished the last one)
01:43:05 <IsoPallo_> You can always use the bordercolor-trick to find out how fast the code is.
01:43:17 <BeelsebobWork_> bordercolour?
01:44:07 <IsoPallo_> Sync on vsync and change something on the screen, start the code, at the end of code change back.
01:44:41 <IsoPallo_> You should see from the state of that something if the screen refresh got there or not.
01:44:55 <IsoPallo_> Won't work on TFT obviously :)
01:45:19 <BeelsebobWork_> oh, that's an interesting idea
01:45:40 <IsoPallo_> It used to be the trick with coding demos for the 8-bits when I was young(er) :)
01:45:59 <BeelsebobWork_> hehe
01:46:40 <IsoPallo_> With graphics you usually are interested in speed on respect to screenrefreshes anyway...
01:48:31 <saft> why do i ahve to enclose - ? like -12 i have to write (-12)
01:48:52 <BeelsebobWork_> saft: to disambiguate negative and subtraction
01:49:04 <saft> when is that ambiguos
01:49:59 * BeelsebobWork_ thinks
01:50:36 <BeelsebobWork_> I'm honestly not sure -- that's always the reason I've assumed
01:50:42 <BeelsebobWork_> but I can't think when the two are actually ambiguous
01:52:02 <Taejo> Beelsebob: is f - - 2 equal to (f $ 2) or (f + 2)?
01:52:33 <BeelsebobWork_> uh, no, it's a parse error
01:53:09 <Taejo> well, if it *did* parse, which would it parse to? isn't it ambiguous?
01:53:29 <BeelsebobWork_> no -- because the grammar says that it isn't ambiguous
01:53:33 <BeelsebobWork_> the grammar says it's a parse error
01:53:38 <BeelsebobWork_> unambiguously
01:54:08 <Taejo> but that's *why* the grammar says it's a parse error
01:54:12 <saft> lol
01:54:13 <BeelsebobWork_> otoh -- f - 2 actually points out the problem
01:54:16 <saft> whata did i start?
01:54:20 <StoneToad> BeelsebobWork_: code speed wise, couldnt you just render 2 frames before showing, then you'd get half the real frame rate (course you'd be wasting 1 of the renders...)
01:54:22 <BeelsebobWork_> f - 2 -- this is f applied to (-) and 2
01:54:33 <BeelsebobWork_> not f (-2)
01:54:56 <BeelsebobWork_> StoneToad: it would be rather a hack
01:55:01 <StoneToad> it would be
01:55:08 <BeelsebobWork_> I don't *really* care tbh that it renders at 800fps
01:55:11 <BeelsebobWork_> rather than 4000
01:55:15 <StoneToad> hehe
01:55:18 <jsn> to create a file, is there any other way than    openFile   ?
01:55:56 <Taejo> jsn: yes, getContents
01:56:07 <Taejo> I mean readFile
01:56:14 <jsn> that's weird
01:56:21 <BeelsebobWork_> readFile gives an error if it doesn't exist doesn't it?
01:56:33 <BeelsebobWork_> yes
01:56:34 <BeelsebobWork_> *** Exception: jam.hs: openFile: does not exist (No such file or directory)
01:56:44 <jsn> supposedly,     openFile    does as well
01:56:48 <Taejo> jsn: oh, to *create*, sorry didn't read properly
01:57:01 <Taejo> jsn: presumably writeFile does the trick
01:57:08 <jsn> in practice, you can use     openFile    to create a file
01:58:08 <StoneToad> is there a clean way to make a pattern match that matches on 2 data constructors but runs the same code?
01:58:30 <BeelsebobWork_> StoneToad: yes -- wrap the code in a function
01:59:04 <StoneToad> any way I can avoid having to name the function?
01:59:05 <BeelsebobWork_> or leave it to the end, and use an overlapping pattern match
02:01:55 <StoneToad> geh I hate how wikibooks doesnt seem to let you search inside a single book
02:03:03 <mapreduce> StoneToad: http://www.google.co.uk/search?q=site%3Aen.wikibooks.org%2Fwiki%2FHaskell+arrows
02:03:09 <lambdabot> Title: site:en.wikibooks.org/wiki/Haskell arrows - Google Search, http://tinyurl.com/5msnc3
02:03:52 * StoneToad smacks himself
02:15:58 <sm> hmm.. should system "cd /somewhere" work ?
02:16:06 <sm> getCurrentDirectory has not changed
02:25:43 <stanv> !
02:28:21 <dmwit> sm: It should not be an error, but it should also not really do anything.
02:28:51 <sm> why should it do nothing ?
02:29:30 <dmwit> "cd" doesn't change the process' working directory.
02:29:33 <Taejo> > let (!) n = product [1..n] in (10 !)
02:29:34 <lambdabot>   3628800
02:29:36 * dmwit shrugs
02:29:43 <dmwit> There's not many other ways to say it. =P
02:30:05 <harblcat> So is haskell really hard to learn?
02:30:13 <dmwit> No.
02:30:15 <Taejo> harblcat: no
02:30:19 <BeelsebobWork_> harblcat: no, everything else you know is really hard to unlearn
02:30:24 <sm> yes
02:30:30 <dmwit> It's probably easier to learn than any other language.
02:30:46 <BeelsebobWork_> it's just so consistant -- it's *very* easy to learn
02:30:56 <Taejo> the difficulty of unlearning depends on what you know
02:31:00 <BeelsebobWork_> true
02:31:03 <harblcat> I was just wondering, because I really just have a hard time of it...
02:31:11 <dmwit> Unfortunately, by the time you've learned another language, you find programming in that other language "easy as pie", so the learning process seems harder by comparison. =/
02:31:14 <mapreduce> harblcat: What do you struggle with?
02:31:14 <BeelsebobWork_> harblcat: what are you having a hard time with?
02:31:34 <mapreduce> dmwit: Unless you're solving Project Euler problems.
02:31:45 <sm> it takes time, unless you have already learned similar languages
02:32:02 <harblcat> dmwit: Ah, but I can speak perfect English if I want. So if I can master that, surely Haskell isn't so hard...
02:32:04 <sm> and it's very rewarding
02:32:20 <dmwit> harblcat: ;-)
02:32:26 <harblcat> I guess I just have a hard time with the whole 'thinking differently' bit.
02:32:29 <mapreduce> I've been looking for a perfect English speaker for a while.
02:32:39 <mapreduce> How do you spell "masters degree" in perfect English?
02:32:53 <mapreduce> including punctuation.
02:32:59 <BeelsebobWork_> like that
02:33:21 <harblcat> As in the degree, or the master possessing it?
02:33:33 <sm> system passes the command to the operating system.. my os has /usr/bin/cd .. I believe it should call that and change the current process' working directory, otherwise it's inconsistent
02:34:01 <Taejo> sm: but the current process is the "cd" process, not the parent process
02:34:07 <BeelsebobWork_> sm: it changes the working directory in the cd process
02:34:08 <dmwit> sm: I'd be *very* surprised if your OS has a /usr/bin/cd.
02:34:09 <BeelsebobWork_> not in its parent
02:34:12 <BeelsebobWork_> damn Taejo beat me to it
02:34:31 <BeelsebobWork_> dmwit: AnygmaMacPro:~ tatd2$ which cd
02:34:33 <Taejo> cd is a shell builtin
02:34:33 <sm> Taejo, Beelsebob: ah, I see what you mean. It's a short-lived process
02:34:37 <BeelsebobWork_> /usr/bin/cd
02:34:59 <dmwit> BeelsebobWork_: echo $SHELL?
02:34:59 <sjanssen> cd is useless as an actual executable
02:35:02 <harblcat> mapreduce: Master's degree, I suppose
02:35:12 <BeelsebobWork_> dmwit: /bin/bash
02:35:17 <dmwit> sjanssen: Yeah, that's what I thought.  But BeelsebobWork_ and sm seem to have one...
02:35:25 <mapreduce> harblcat: As in the degree, to answer your earlier question.
02:35:27 <sjanssen> dmwit: yeah, it is weird
02:35:29 <BeelsebobWork_> I think OS X maybe pretends its there
02:35:55 <sm> it's a shell script that calls the builtin
02:36:21 <dmwit> That's stupid.  Your shell scripts don't get called in their own shell?
02:36:32 <BeelsebobWork_> oh, so it is
02:36:37 <harblcat> Back to the topic before, would anyone say "Learn You a Haskell for Great Good" is at least a worthwhile read?
02:36:38 <BeelsebobWork_> it actually doesn't
02:36:46 <BeelsebobWork_> it's a shell script that runs cd in sh
02:36:47 <BeelsebobWork_> not bash
02:37:01 <dmwit> harblcat: YAHT, Gentle Intro, RWH, LYAH are all good.
02:37:35 <dmwit> ?where gentle
02:37:36 <lambdabot> http://www.haskell.org/tutorial/
02:37:38 <Adamant> RWH + LYAH are best
02:37:38 <dmwit> ?where RWH
02:37:38 <lambdabot> is http://www.realworldhaskell.org/blog/
02:37:51 <dmwit> No, Gentle Intro is best!
02:37:52 <dmwit> ;-)
02:37:54 <harblcat> dmwit: Thanks!
02:38:11 <Adamant> YAHT's ok, read Gentle Intro when you're done with the above
02:38:21 <sjanssen> I love that Gentle Intro is actually the least gentle of all the tutorials
02:38:40 <Adamant> it was a product of an earlier time
02:38:46 <sm> harblcat: yeah, I liked it
02:38:59 <vegai> don't read anything, start hacking and check reference when you have trouble
02:39:41 <Adamant> vegai: this is programming, not driving in a unfamiliar neighborhood
02:39:42 <Taejo> vegai: that's pretty much what I did, but I already knew functional programming
02:40:56 <sjanssen> Adamant: ha
02:41:08 <osfameron> HSOE gets no love these days does it?  What about Hutton's Haskell book?
02:41:10 <IsoPallo_> Don't think anything, write a test if it passes the test it is finished :)
02:42:16 <sm> Hutton's book is good, if you're buying
02:42:28 <xenoblitz> guys... i wish to find the index of the minimum element in a list... i got as far as using minimum but is there a function which given a value, searches said list for that value?
02:43:32 <Taejo> xenoblitz: what is the type of the function you want?
02:43:56 <sjanssen> xenoblitz: elemIndex?
02:44:11 <xenoblitz> [Int]->Int
02:44:15 <xenoblitz> elemIndex... lemme see
02:44:16 <BONUS> > zip [0..] [3,6,9,2,39,3,2,5,1,3]
02:44:17 <lambdabot>   [(0,3),(1,6),(2,9),(3,2),(4,39),(5,3),(6,2),(7,5),(8,1),(9,3)]
02:44:22 <Taejo> @hoogle [Int] -> Int
02:44:23 <lambdabot> Prelude maximum :: Ord a => [a] -> a
02:44:23 <lambdabot> Prelude minimum :: Ord a => [a] -> a
02:44:23 <lambdabot> Data.List maximum :: Ord a => [a] -> a
02:44:39 <Taejo> @hoogle Eq a => [a] -> Int
02:44:39 <lambdabot> Prelude length :: [a] -> Int
02:44:39 <lambdabot> Data.List length :: [a] -> Int
02:44:39 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
02:44:52 <BONUS> > minimumBy (compare `on` snd) $ zip [0..] [3,6,9,2,39,3,2,5,1,3]
02:44:53 <lambdabot>   (8,1)
02:45:36 <xenoblitz> BONUS: nice way to implement it... :)
02:45:57 <BONUS> hehe
02:45:58 <telexicon> haskell is a glorious language
02:46:02 <telexicon> but im too dumb :(
02:46:19 <Taejo> telexicon: doubtful
02:46:34 <BONUS> even better you could just do: minimum $ zip [3,4,5,9,2,19,53,29,19,3,1,2] [0..]
02:46:35 <xenoblitz> telexicon: I am in a similar situation... I am baffled at how some people here find such elegant solutions using the pre-existing functions
02:46:45 <xenoblitz> see what i mean!?
02:46:46 <xenoblitz> lol
02:47:03 <BONUS> eh, it's just practice
02:47:12 <BONUS> nothing to do with being smart imho
02:47:29 <sjanssen> practice, and learning a few common idioms
02:47:47 <sjanssen> eg. the zip [0 ..] trick is very widely used
02:48:46 <telexicon> eh
02:48:53 <xenoblitz> still its amazing stuff... I mean doing that in an imperative/oop language takes some code... in haskell its 1 line
02:49:08 <telexicon> why do the fold functions seem to mix concerns
02:49:23 <sjanssen> telexicon: what?
02:49:29 <telexicon> isnt there a function to operate solely on an accumulator
02:49:40 <telexicon> and another function to transform values
02:49:46 <telexicon> transform/reduce
02:49:58 <telexicon> why both at the same time
02:50:06 <telexicon> half the functions i use with fold only use one or the other
02:50:15 <quicksilver> I don't see how you could act any more "solely" on the accumulator than fold does
02:50:16 <xenoblitz> > minimum $ zip [1,2,3,4,1,0] [0..]
02:50:17 <lambdabot>   (0,5)
02:50:19 <quicksilver> :t foldr
02:50:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:50:29 <sjanssen> quicksilver: you could constrain the type
02:50:32 <quicksilver> how is "a -> b -> b" anything other than an action on the accumulator?
02:50:47 <xenoblitz> > minimum $ zip [0,1,2,3,4,1,0] [0..]
02:50:48 <lambdabot>   (0,0)
02:50:49 <telexicon> quicksilver, because you have access to the values and the previous accumlator
02:50:53 <telexicon> rather than just the accumulator
02:51:00 <quicksilver> ?
02:51:03 <quicksilver> you just want (b -> b) ?
02:51:06 <sjanssen> telexicon: how do you summarize the list if you don't have access to an element?
02:51:09 <saft> im just palyign aroun but can i pattern mathc inside a lambda?
02:51:11 <telexicon> yes
02:51:15 <xenoblitz> > snd $ minimum $ zip [0,1,2,3,4,1,0] [0..]
02:51:16 <lambdabot>   0
02:51:19 <saft>  let f x y = sum $ map (\x -> (case x of (a,b) -> a+b)) zip x y
02:51:22 <Taejo> telexicon: you only have access to the current element
02:51:23 <sjanssen> telexicon: try writing sum with that restriction
02:51:29 <quicksilver> if you just want (b -> b) then it has nothing to do with the list [a] at all.
02:51:35 <quicksilver> it because simply 'iterate'
02:51:38 <quicksilver> :t iterate
02:51:39 <lambdabot> forall a. (a -> a) -> a -> [a]
02:51:43 <telexicon> is the accumulator to make it tail recursive?
02:51:45 <quicksilver> s/because/becomes/
02:51:54 <quicksilver> no.
02:51:55 <telexicon> instead of just doing x + next xs
02:52:01 <sjanssen> telexicon: no, foldr is not tail recursive
02:52:05 <quicksilver> the accumulator is there because foldr is about accumulation
02:52:09 <telexicon> foldl
02:52:34 <quicksilver> you have map (pure transformation), iteration ("pure" accumulation i.e. just repetition) and foldr (accumulation over a list)
02:52:45 <telexicon> suml [] = 0; suml (x:xs) = x + suml xs
02:53:10 <saft>  let f x y = sum $ map (\x -> (case x of (a,b) -> a+b)) zip x y
02:53:12 <saft> im just palyign aroun but can i pattern mathc inside a lambda?
02:53:17 <sjanssen> telexicon: how is that any different from using foldr?
02:53:34 <sjanssen> (hint: it isn't, and one can mechanically turn your definition into foldr)
02:53:37 <quicksilver> telexicon: and the type of "\x xs -> x + suml xs" part is a -> b -> b
02:53:46 <quicksilver> well in this case a = b = Int
02:53:55 <telexicon> sjanssen, it doesnt have an explicit accumulator
02:54:15 <quicksilver> sorry, what i just said is wrong and slightly confusing ;)
02:54:19 <quicksilver> I retract that ;)
02:54:24 <sjanssen> telexicon: foldr doesn't really have an accumulator either
02:54:29 <Peaker> saft: functions (in both forms), let and cases can all pattern match
02:54:29 <quicksilver> telexicon: you suml has access to the entire previous list 'xs'
02:54:47 <quicksilver> telexicon: that's actually less restricted than the folds
02:54:55 <Peaker> saft: but lambda's have limited pattern-matching, you can't match multiple cases
02:54:56 <quicksilver> which only give you access to one element at a time
02:54:57 <sjanssen> telexicon: the function argument to foldr takes two arguments, an element of the list, and the result of folding the subsequent elements of the list
02:54:59 <saft> Peaker so if i map ona list of tuples, how do i get the tupleelemtns?
02:55:12 <Peaker> saft: map (\(x, y) -> ...)
02:55:22 <quicksilver> > map (\(x,y) -> x+y) [(1,1),(2,1),(1,-1)]
02:55:23 <lambdabot>   [2,3,0]
02:55:27 <quicksilver> saft: like that
02:56:28 <Peaker> saft: Only "case" and non-lambda functions can match an expression against multiple possible patterns, instead of just 1
02:56:46 <Peaker> saft: (non-lambda functions can be both top-level, or in a "let"/"where")
02:57:03 <Peaker> at least afaik
02:57:37 <telexicon> somehow this strayed from my original quesiton
02:57:41 <telexicon> oh well heh
02:57:48 <saft> ok  i see
02:57:56 <sjanssen> telexicon: I'm not sure that your original question made sense ;)
02:58:04 <telexicon> im not sure either
02:58:20 <telexicon> usually through the course of discussion i either refine my question or see the errors in my logic
02:58:59 <saft> let f x y = sum $ map (\(x,y) -> x+y) $ zip x y
02:59:14 <laziest> Peaker: I justed checked the Haskell 98 document for expressions superficially, and you seem to be right
02:59:33 <saft> so it is a bad chocie of avriables obv but ti works, what is it that lets me have x and y rep different things in that function depending on where they appear? is that closures?
03:00:17 <quicksilver> saft: no, just lexical scope.
03:00:17 <laziest> saft: why don't you use zipWith in this particular case?
03:00:26 <saft> because im donking around
03:00:35 <quicksilver> saft: the (\x ... -> ... ) is a new scope
03:00:47 <quicksilver> saft: the 'x' inside it masks (shadows) any xs outside
03:01:12 <saft> how does zipWith work? zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:01:17 <saft> so a functiona nd 2 lists
03:01:55 <saft> sum $ zipWith (\x y -> x+y) [1..3] [4..6]
03:02:00 <saft> aha!
03:02:57 * Baughn notes that ghci -package 3.0.3.0 first eats up all my memory, then crashes
03:03:00 <saft> can i see the source of a functon isnide ghci? like :s f?
03:03:03 <Baughn> *base-3.0.3.0
03:03:09 <saft> @src sum
03:03:09 <lambdabot> sum = foldl (+) 0
03:03:17 <Baughn> (Can anyone else test this? On 6.10?)
03:04:12 <quicksilver> saft: No.
03:04:20 <quicksilver> saft: they're all on the web pages though
03:04:29 <saft> yes
03:04:39 <saft> would such a thing be har dto implement?
03:04:44 <saft> would anyoen want it?
03:05:20 <Taejo> saft: personally, I just ask lambdabot
03:05:48 <laziest> saft: sorry I was on a phone call.
03:06:15 <laziest> saft: you got it.
03:06:31 <saft> yes
03:06:50 <xhanjian> :t 1
03:06:51 <lambdabot> forall t. (Num t) => t
03:07:12 <xhanjian> what's the type of the '1' here?
03:07:18 <xhanjian> Int? Integer?
03:07:30 <laziest> xhanjian: 1 is a polymorphic entity right now.
03:07:39 <laziest> as the type suggests.
03:07:43 <xhanjian> but to show 1
03:07:56 <xhanjian> 1 has to be some concrete type?
03:07:58 <laziest> you would say show (1 :: Int)
03:08:12 <xhanjian> > show 1
03:08:13 <lambdabot>   "1"
03:08:31 <telexicon> perhaps Num derives show
03:08:32 <laziest> xhanjian: ya, those work because of the default rules in case of numeric types.
03:08:41 <Baughn> xhanjian: Some polymorphic types (like Num a => a) will default when you try to use them without a more concrete type being forced
03:08:51 <laziest> telexicon: that is not enough
03:09:03 <telexicon> thats..
03:09:10 <telexicon> why?
03:09:23 <xhanjian> still don't understand telexicon ..
03:09:30 <laziest> finally one has to arrive at a concrete type
03:09:31 <telexicon> xhanjian, dont pay attention to me
03:09:47 <Baughn> telexicon: There is no Show instance for Num, no
03:09:52 <laziest> which 'Show' instance does not do.
03:09:53 <Baughn> @instances Show
03:09:54 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
03:10:08 <Taejo> :i Sum
03:10:13 <Taejo> @info Sum
03:10:13 <lambdabot> Sum
03:10:19 <Taejo> thanks, lambdabot
03:10:23 <Baughn> telexicon: (Which in any case would not help. It'd allow show to take any type in Num, but it'd still have to be a concrete type)
03:10:27 <telexicon> :t Sum
03:10:28 <lambdabot> forall a. a -> Sum a
03:10:30 <xhanjian> lambdabot: ye finally some one will implement show, but not Num right
03:10:51 <xhanjian> sorry not lambdabot, laziest
03:10:59 <Baughn> @src Sum
03:10:59 <lambdabot> Source not found.
03:11:10 <laziest> xhanjian: ya.
03:11:27 <laziest> Anyway, type classes are not implementers.
03:11:46 <laziest> They just assure you of certain entities associated with types in those classes
03:11:47 <quicksilver> Baughn: well, Show is a superclass of Num, so all nums are automatically showable. But this is not the point here, I think :)
03:11:55 <xhanjian> ye. What I want to know is when I tell ghci "show 1", whose implementation is used?
03:12:02 <quicksilver> xhanjian: Integer.
03:12:05 <quicksilver> xhanjian: because of defaulting.
03:12:08 <laziest> xhanjian: defaulting rules.
03:12:14 <Deewiant> xhanjian: use ghci -Wall and it'll warn you about the fact that it's defaulting
03:12:14 <xhanjian> oic..
03:12:30 <quicksilver> http://www.haskell.org/onlinereport/decls.html#sect4.3.4
03:12:31 <lambdabot> Title: The Haskell 98 Report: Declarations
03:12:35 <Baughn> quicksilver: Isn't @instances misleading, then?
03:12:51 <xhanjian> thanks guys
03:12:52 <laziest> quicksilver: some lines above, @instances does not show Num
03:12:55 <quicksilver> Baughn: @instances doesn't account for superclasses.
03:13:05 <quicksilver> laziest: Num isn't a type.
03:13:10 <quicksilver> what instances showed you was a list of types.
03:13:20 <laziest> quicksilver: ah.
03:13:23 <Baughn> It might have showed is Num a => a
03:13:27 <quicksilver> it might.
03:13:34 <laziest> quicksilver: ya, it's showing [a]
03:13:35 <Baughn> ..still, the defaulting rules were the real point, here
03:13:36 <quicksilver> but it would be a strange thing
03:13:51 <quicksilver> that would suggest an instance of the form instance Num a => Show a
03:13:56 <quicksilver> and, of course, there is no such thing.
03:14:31 <Baughn> Is "superclass" right, though?
03:14:49 <Baughn> ..er, never mind. Got your sentence backwards.
03:16:05 <quicksilver> a superclass is just a binding commitment on people who write Num instances.
03:16:23 <quicksilver> "If you write a Num instance, you must also write a Show instance"
03:16:28 <quicksilver> (and an Eq one, as it happens)
03:16:43 <quicksilver> but the Show instance is still a separate thing from the Num instance.
03:16:51 <quicksilver> it's just something you are required to provide.
03:17:10 <Baughn> Right, I somehow read it as "Num is a superclass of Show"
03:18:47 <laziest> quicksilver: the quoted line was illuminating. Baughn: it does mean that. Whatever type "belongs" to Num should belong to "Show".
03:19:27 <Baughn> laziest: That's not what "superclass" means
03:19:42 <Baughn> "a is a superclass of b" -> "Whatever type belongs to b should also belong to a"
03:19:43 <laziest> Baughn: are you talking about the OO terminology?
03:20:00 <Baughn> laziest: Well, it's useful to use the same terminology
03:20:21 <Taejo> Baughn: s/useful/dangerous/g :)
03:20:35 <laziest> Baughn: OH! I read your superclass statement backwords!
03:20:36 <Baughn> Taejo: Not as dangerous as deliberately doing the opposite thing. :P
03:20:46 <Baughn> laziest: And I read quickshot's backwards. Heh.
03:20:49 <laziest> Baughn: I actually read "Show is a superclass of Num"
03:21:02 <laziest> hah.
03:21:16 <quicksilver> well haskell and OO notions of superclass are compatible as far as that goes
03:21:23 <quicksilver> of course they're rather different notions of 'class'
03:21:27 <quicksilver> but the 'super' part is compatible.
03:24:29 <Baughn> quicksilver: Now, as I recall, I can't say anything like "If a is an instance of Foo, and there is no instance of Bar specifically for a, then use this default instance based on Foo here" in 6.8, at least not without horrible, horrible coding.
03:24:35 <Baughn> Would this be possible with type families?
03:24:50 <quicksilver> no.
03:24:55 <quicksilver> it's fundamentally broken.
03:25:05 <quicksilver> it's fundamentally in opposition to the idea of classes being open.
03:25:27 <Baughn> Only because you insist on hardcoding the dictionary at compile-time
03:25:38 <Baughn> I can see it disabling some optimizations, but still..
03:25:48 <Baughn> (Optimizations that could instead be done at link-time)
03:25:51 <quicksilver> it breaks a rather important monotonicity property.
03:25:59 <quicksilver> that adding new modules can't change the semantics of old code.
03:26:16 <Baughn> Oh, I'm aware of that. I still want to do it.
03:26:18 <quicksilver> it's pretty harmful if A and B work separately
03:26:36 <quicksilver> but they would break if they happened to be combined into a larger program C, even though they don't communicate directly in any way.
03:26:41 <Baughn> They'd be semantic equivalents. Eg. I'd like a default instance for Binary based on Show/Read
03:27:03 <quicksilver> I can appreciate pragmatic desire for it.
03:27:13 <quicksilver> I'm just explaining the sense in which it is a Bad Thing (TM)
03:27:26 <quicksilver> and it won't be solved by any minor type system enhancements
03:27:32 <quicksilver> it requires a major decision to change how class resolution works.
03:28:02 <Baughn> I imagine I'll live.
03:28:31 <Baughn> How about just "all instances of Foo are hereby instances of Bar"?
03:29:16 <quicksilver> I believe that hits the same monotonicity issue in a slightly more subtle way
03:29:26 <quicksilver> I can't quite construct the argument right now
03:29:30 <quicksilver> insuficient caffeine.
03:29:42 <quicksilver> I do think that one merits a good quality FAQ answer
03:29:50 * ivanm passes quicksilver a quadruple espresso
03:29:53 <Baughn> I don't see how it could. At worst you'd get an overlap, which would stop compilation
03:29:55 <quicksilver> because it is probably the most frequently asked 'good question' about type classes.
03:30:42 <Baughn> Well, I know I've asked it before. I'm just checking to see if it's changed with 6.10
03:31:36 <Taejo> I've asked it before too, when I was trying to get chained inequalities working
03:32:04 <Taejo> I basically needed to say "IneqResult is *not* an instance of Ord"
03:32:15 <quicksilver> Taejo: there is an Oleg for that.
03:32:33 <Taejo> quicksilver: yeah, I found out afterwards
03:32:42 <quicksilver> Taejo: if you want to encode not-being-instance, then you add one parameter to the class
03:33:03 <quicksilver> instance IneqResult foo becomes instance IneqResultNew foo HTrue
03:33:13 <quicksilver> and not-an-instance becaomes IneqResultNew foo HFalse
03:33:20 <quicksilver> then you have observable non-membership
03:33:26 <quicksilver> (FSOV of observable, at least)
03:33:34 <Taejo> quicksilver: ohk, cool
03:33:43 <quicksilver> oleg had a rather succint email in the cafe
03:33:46 <quicksilver> explaining this point
03:33:50 <quicksilver> let's see if I can find it.
03:34:00 <Taejo> quicksilver: thanks
03:41:08 <quicksilver> Taejo: http://www.mail-archive.com/haskell-cafe@haskell.org/msg41076.html
03:41:12 <quicksilver> that's the one I was thinkging of
03:41:14 <lambdabot> Title: [Haskell-cafe] Re: Trying to avoid duplicate instances, http://tinyurl.com/5ftsqm
03:41:27 <Taejo> quicksilver: thank you
03:42:35 <ivanm> I just want to check this: readPackageDescription comes in cabal's Distribution.PackageDescription module, doesn't it?
03:44:17 <ivanm> oh, wait, cabal's site only has the 1.4 docs, and I'm using 1.6
03:45:40 <ivanm> If I want to support multiple versions of cabal in my app, do I have to use cpp to import modules that only exist in newer versions?
03:49:41 <quicksilver> ivanm: the best way to support multiple versions of cabal is to talk to dcoutts_
03:49:52 <quicksilver> ivanm: there are version independent ways to access most functionality :)
03:49:56 <ivanm> yeah, except he's not online :s
03:49:57 <quicksilver> but it will depend what you're doing.
03:50:01 <quicksilver> heresy!
03:50:07 <ivanm> @seen dcoutts
03:50:07 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 14h 17m 21s ago.
03:50:08 <quicksilver> dcoutts_ is always watching, never sleeping.
03:50:09 <ivanm> @seen dcoutts_
03:50:10 <lambdabot> dcoutts_ is in #gentoo-haskell, #ghc, #haskell-overflow and #haskell. I last heard dcoutts_ speak 1d 19h 49m 29s ago.
03:50:11 <ivanm> heh
03:50:32 <ivanm> quicksilver: I'm trying to get information on which modules are used in a project
03:51:17 <ivanm> and there are two changes I've had to make from 1.4 to 1.6: import a new module, and a (relatively simple) change in datatype
03:51:54 <ivanm> take it back, I need to import two new modules
03:52:35 <ivanm> and dammit, he decided to call a datatype the same as something I'd already called :s
03:54:36 <telexicon> meh
04:00:29 <telexicon> has anyone ever went off and made a 'functional database' ?
04:01:55 <ivanm> telexicon: see mnesia, that comes with erlang's OTP
04:02:37 <ivanm> how can I work out which version of a library something is built with? cabal-install wants to reinstall Cabal because of filepath :s
04:02:48 <telexicon> oh yeah i tinkered with mnesia
04:03:04 <telexicon> wheres the cooler one for haskell.. strict typing and monads
04:03:09 <telexicon> and laziness
04:03:18 <ivanm> telexicon: waiting for you to write it ;-)
04:03:31 <ivanm> telexicon: http://burks.bton.ac.uk/burks/foldoc/25/46.htm
04:03:33 <C-Keen> I want to give runInteractiveProcess the working directory (which is a Maybe Filepath) and hand it the result of getCurrentDirectory avoiding the usual foo <- getCurrentDirectory; ....Just foo ... dance? I figured fmap might be a candidate but the type error confuses me
04:03:35 <lambdabot> Title: functional database
04:03:41 <telexicon> im not skilled enough to write anything like that
04:03:50 <ivanm> also, NixOS seems to use a functional database
04:04:10 <telexicon> i mean, using infinite lists
04:04:16 <telexicon> there could be some way no?
04:04:16 <ivanm> C-Keen: what's the error?
04:04:22 <ivanm> telexicon: that's probably a bad idea...
04:04:28 <telexicon> the relational model is mathy and cool though
04:04:39 <idnar> @type getCurrentDirectory >>= (runInteractiveProcess . Just)
04:04:40 <lambdabot> Not in scope: `getCurrentDirectory'
04:04:40 <lambdabot> Not in scope: `runInteractiveProcess'
04:04:42 <telexicon> i mean, stricter than whats around now though
04:04:52 <Saizan> ivanm: ghc-pkg field $pkg depends
04:04:55 <C-Keen> ivanm: http://hpaste.org/11637
04:05:10 <telexicon> ivanm, perhaps, im just generating ideas
04:05:15 <C-Keen> ivanm: I am not sure how to use fmap right
04:05:24 <telexicon> i haven't had time to investigate their practicality and effectiveness
04:05:42 <ivanm> Saizan: hmmmm..... Cabal apparently doesn't even require filepath :s
04:05:44 <saft> how do i get haskell-mode on fedora?
04:05:54 <saft> i tried sudo yum install haskell-mode
04:05:58 <saft> fished up nothing
04:06:15 <Saizan> ivanm: it does here
04:06:17 <ivanm> saft: install it manually?
04:06:22 <saft> heresy
04:06:23 <ivanm> Saizan: which version of Cabal?
04:06:28 <idnar> C-Keen: that looks fine, but I think you're using the result incorrectly; where's your code?
04:06:37 <ivanm> C-Keen: with your code?
04:06:49 <idnar> @type fmap Just System.Directory.getCurrentDirectory
04:06:50 <lambdabot> IO (Maybe FilePath)
04:07:05 <Saizan> ivanm: 1.5.5 and 1.6.0.1, but i'm pretty sure other versions do too
04:07:11 <ivanm> saft: well, it's not _my_ fault if you use such a dodgy distro :s
04:07:25 <ivanm> Saizan: hmmm.... I've got 1.6.0.1 and it doesn't list filepath :s
04:07:28 * ivanm rebuilds
04:07:29 <saft> well how do you do on ubuntu?
04:07:38 <saft> maybe im just using the wrong notation
04:07:46 <ivanm> saft: I use gentoo ;-)
04:07:46 <saft> ghc -haskellmode?
04:07:50 <C-Keen> ivanm: part of it: http://hpaste.org/11637#a1
04:07:55 <ivanm> saft: no, your package manager
04:07:57 <ivanm> nothing to do with ghc
04:08:15 <ivanm> saft: you talking about haskell-mode for emacs?
04:08:22 <idnar> C-Keen: hmm, I guess you're trying to pass the result straight to runInteractiveProcess, which won't work
04:08:35 <C-Keen> saft: see here http://www.haskell.org/pipermail/fedora-haskell/2005-February/000000.html
04:08:37 <lambdabot> Title: [Fedora-haskell] More Fedora RPMs available: WASH/CGI, Emacs Haskell mode, Haske ..., http://tinyurl.com/68xg2t
04:08:44 <ivanm> saft: http://www.haskell.org/pipermail/fedora-haskell/2005-February/000001.html
04:08:46 <lambdabot> Title: [Fedora-haskell] More Fedora RPMs available: WASH/CGI, Emacs Haskell mode, Haske ..., http://tinyurl.com/6e6o83
04:09:07 <C-Keen> idnar: hm, I thought that's what fmap is for?
04:09:15 <alexey_r> Hi! Why do I get a stack overflow exception here: foldl1' (\(x, y) (x', y') -> (max x x', min y y')) $ map (\x -> (x, x)) [1..1000000]?
04:09:18 <idnar> C-Keen: fmap can't turn an IO value into a non-IO value
04:09:25 <idnar> C-Keen: that's what unsafePerformIO is for :P
04:09:51 <idnar> you'll still need to do something like foo <- fmap Just System.Directory.getCurrentDirectory
04:10:25 <Saizan> C-Keen: you can't pass an IO Something to a function that's expecting Something, you've to extract the content with <- first
04:10:47 <C-Keen> alright I give in for the sake of purity :) Thank you all!
04:10:52 <Saizan> C-Keen: btw, if you're going to pass the current directory you could as well pass Nothing
04:11:17 <C-Keen> ok
04:12:34 <Saizan> flip (runInteractiveProcess cmd []) (Just env) =<< fmap Just getCurrentDirectory <-- or use this if you want to be pointsfree
04:12:50 <idnar> heh
04:17:12 <Cale> alexey_r: It's because pairs aren't strict, so the foldl1' only forces up to determining that the result is indeed a pair, which is not enough.
04:18:19 <alexey_r> Cale: thanks!
04:23:02 <saft> where should i put haskell-mode for emacs?
04:23:05 <hugo_> haskell allows for some really nice sintax :)
04:23:18 <saft> and what do i need to add to .emacs?
04:23:39 <ivanm> Saizan: hmmm..... even after I rebuild Cabal myself, cabal-install wants to rebuild it :s
04:23:46 <alexey_r> So, I've modified it to foldl1' (\(x, y) (x', y') -> (let {x'' = max x x'; y'' = min y y'} in x'' `seq` y'' `seq` (x'', y''))) $ map (\x -> (x, x)) [1..1000000] and it works now. But is there a simpler way? to write this?
04:23:46 <Stinger> rtfe
04:23:48 <hugo_> ctrl-m ctrl-h ctrl-a ctrl-alt-t ctrl-alt-shift-m ctrl-alt-shift-h  all at the same time
04:23:58 <hugo_> for emacs :)
04:24:30 <hugo_> i dont use emacs, my doctor told me to stop using it after the tendinitis
04:24:57 <ivanm> oh, wait, worked it out... in Gentoo we use a private version of filepath to prevent cyclic dependencies
04:24:58 <osfameron> vim++ # as recommended by doctors
04:26:01 <Stinger> how can functional programmers be so harsh against an editor built with lisp? :)
04:26:11 <hugo_> lol
04:26:26 <ivanm> hugo_: right...
04:26:33 * earthy laughs
04:26:45 <earthy> that's why we have yi, stinger
04:26:53 <jeffz> who uses yi?
04:27:00 <Stinger> yeah well I can't really fault the yi users on those grounds
04:27:10 <hugo_> im waiting for visual studio to suport haskell
04:27:12 <Stinger> but I can call the vi users heretics ;)
04:27:23 <shapr> @go Visual Haskell
04:27:24 <luite> saft: the source code seems to have better instructions than the readme file, you may look there
04:27:24 <Stinger> I thought there already was a vs pugin
04:27:25 <lambdabot> http://www.haskell.org/visualhaskell/
04:27:25 <lambdabot> Title: Visual Haskell
04:27:38 <hugo_> oh...
04:27:39 <jeffz> hasn't it bitrotted?
04:27:50 <Stinger> here's a nickel son, go get yourself a real editor
04:27:54 <shapr> jeffz: Yup, but it had support at one point :-)
04:27:55 <jeffz> I don't know why you'd want to use VS though.
04:28:11 <shapr> jeffz: I get paid to do so. Otherwise I use emacs :-)
04:28:19 <alexey_r> ((,) $! max x x') $! min y y' works too, but isn't much nicer.
04:28:42 <jeffz> shapr: uh erm, I mean, sure if you're using C++ or C# or whatever, but Haskell I'm not so sure :P
04:28:56 <earthy> visual haskell has bitrotted a bit
04:29:08 <earthy> it's not available for 6.8 or visual studio 2008
04:29:14 <earthy> however, it is perfectly serviceable
04:29:20 <luite> does it work in wine?
04:29:24 <shapr> Actually, I use emacs at work for most of my editing, I only use visual studio for a few things.
04:29:30 <earthy> luite: not that I know of
04:29:36 <earthy> haven't tested though
04:30:04 <Philippa> Stinger: elisp is more dysfunctional :-)
04:30:13 <Stinger> heh
04:30:38 <Philippa> I mean, you can't even bind a variable without violating referential transparency
04:31:14 <shapr> saft: (required 'haskell-mode)
04:31:31 <shapr> oops, "(require 'haskell-mode)"
04:32:21 <luite> is there a list somewhere, with all the shortcuts and commnds provided by haskell-mode?
04:34:05 <jeffz> luite: M-x describe-mode
04:34:11 <saft> it says i should put it in ~/lib/emacs
04:34:15 <saft> i dont have hat
04:34:23 <saft> i cant find emacs eithe ron ym system but is i there
04:34:29 <saft> i use fedora
04:34:55 <jeffz> saft, do you have a question?
04:35:02 <luite> jeffz: ah thanks
04:35:12 <saft> yes where should i put haskell-mode?
04:35:18 <jeffz> saft, anywhere you feel like.
04:35:38 <saft> ok but how do i point emacs to it?
04:35:43 <saft> require cant be enough
04:36:25 <luite> you can load the site file
04:36:58 <luite> (load "/path/to/haskell-site-file.el")
04:37:08 <saft> ok
04:38:18 <hugo_> how do i do a "sleep" with haskell ?
04:38:31 <hugo_> i want a recusive function to stop 1 seconde between each iteration
04:38:54 <hugo_> > sleep 1000
04:38:55 <lambdabot>   Not in scope: `sleep'
04:39:39 <Philippa> hugo_: you don't, in a pure function. And lambdabot wouldn't let you anyway
04:39:43 <Stinger> Control.Concurrent.threadDelay
04:42:59 <hugo_> how do i call unistd.h sleep C function ?
04:44:19 <Saizan> hugo_: if you're in IO i think threadDelay is the way to go
04:44:27 <hugo_> nice
04:45:44 <saft> cp: omitting directory `/home/saft/Download/haskell-mode-2.4'
04:46:45 <Saizan> saft: see cp --help, it will tell you to use -r
04:46:59 <Cale> hugo_: You can call sleep via the Posix API, but it's unlikely to really be what you want.
04:48:36 <hugo_> hmm ok
04:48:58 <hugo_> im doing web access, and i dont want to bombard the server...
04:49:08 <hugo_> thats why i need a delay between each recursive call
04:54:05 <Cale> hugo_: yeah, threadDelay is better. In case you want to add other threads to your program, it won't block all the other threads.
04:54:48 <hugo_> nice :)
04:56:52 <quicksilver> Cale: well, that's true of POSIX sleep too in the threaded rts :)
04:58:24 <Cale> Hmm, I wonder if it works properly at all in the threaded rts...
04:58:39 <quicksilver> hmm. Interesting point.
04:58:49 <quicksilver> I suppose it's not a normal blocking call
04:58:52 <quicksilver> I would think so though
05:08:32 * byorgey wishes a Good Morning to all
05:12:10 <ivanm> hey byorgey
05:12:19 <byorgey> hi ivanm
05:12:39 <byorgey> hey, your thesis is really cool =)
05:12:53 <byorgey> I skimmed it yesterday
05:13:22 <ivanm> thanks!
05:14:14 <saft> i downloaded cabal-install and untared it. it is now in ~/Download
05:14:25 <saft> should i run Setup there or move it somewhere?
05:14:29 <ivanm> no, you can't use cabal-install to install Haskell-mode ;-)
05:14:41 <ivanm> saft: IIRC, there's an all-in-one installation script for cabal-install
05:15:17 <saft> i have haskell-mode working already
05:15:34 <byorgey> saft: either way, you shouldn't have to move it.
05:15:44 <saft> i apparently need cabal,htt,zlib and libghc6-network-dev
05:16:03 <ivanm> saft: http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html#installing.haskell.software
05:16:05 <byorgey> right, this is where the all-in-one installation script comes in handy =)
05:16:05 <lambdabot> Title: Appendix A. Installing GHC and Haskell libraries, http://tinyurl.com/5w2tm3
05:16:19 <ivanm> take it back, I thought it covered cabal-install
05:16:21 <byorgey> dunno where to find it though
05:16:21 <ivanm> but it doesn't
05:16:52 <ivanm> saft: you on *nix?
05:16:58 <ivanm> if so, http://hackage.haskell.org/trac/hackage/wiki/CabalInstall says what you have to do
05:17:00 <lambdabot> Title: CabalInstall - Hackage - Trac
05:17:05 <ivanm> byorgey: it's in the tarball by the looks of things
05:17:16 <ivanm> @seen dons
05:17:17 <lambdabot> dons is in #concatenative, #darcs, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 5h 37m 48s ago.
05:17:26 <byorgey> saft: is there a bootstrap.sh?  If so, run that
05:17:46 <ivanm> @ask dons for RWH, how come you don't even cover your beloved arch when stating how to install ghc on different distros?
05:17:47 <lambdabot> Consider it noted.
05:18:48 <saft> nice, bootstrap.sh sparked some serious action :)
05:20:29 <hugo_> @seen Soul brother number 1
05:20:29 <lambdabot> I haven't seen Soul.
05:20:41 <hugo_> :P
05:21:12 <saml> ivanm, http://repos.archlinux.org/viewvc.cgi/ghc/repos/extra-x86_64/PKGBUILD?revision=11199&view=markup   this is how you build ghc on arch
05:21:17 <lambdabot> Title: Arch Linux Repositories [packages] View of /ghc/repos/extra-x86_64/PKGBUILD, http://tinyurl.com/56a5nc
05:21:26 <ivanm> saml: I don't care how you build it on arch
05:21:41 <ivanm> my point was, that RWH only covers ubuntu/debian and fedora out of all possible *nix distros
05:21:45 <saml> ivanm, ah, then write    pacman -S ghc
05:21:59 <ivanm> saml: do a /whois on me, and see which channels I'm in ;-)
05:22:45 <saml> irc is too complicated. i need to build VB GUI that traces /whois of you
05:23:02 <ivanm> *shudder*
05:23:39 <hugo_> when i have a function with lots of parameters, how do i split them in order to avoid the use of lots of screen columns ?
05:24:28 <quicksilver> hugo_: however you want to.
05:24:29 <hugo_> i usualy find myself giving explicit names to each parameter, and them watching the terminal word wrap everything in a ugly way
05:24:45 <quicksilver> hugo_: whitepsace is not significant in most of haskell code
05:24:50 <quicksilver> only the layout blocks
05:25:00 <quicksilver> can you paste an example of what you mean?
05:25:05 <hugo_> can i put the '=' on a single line ?
05:25:08 <hugo_> yes
05:25:37 <EvilTerran> yes
05:25:44 <quicksilver> f you can write
05:25:47 <quicksilver>   it like this
05:25:49 <quicksilver>      if you
05:25:52 <quicksilver>   really = want to
05:25:59 <saft> i have to instal zlib manually? anyway couldt it check that i ahve all packages first, THEN runt he script rather than run for 2 minutes then see that soemthing is missing?
05:26:23 <saml> hugo_, all functions take 1 argument only. so it's probably easy to split up
05:26:42 <ivanm> saft: probably a new dependency that the script wasn't updated to cover
05:26:54 <ivanm> or else it could be talking about the _real_ zlib (not the haskell bindings)
05:26:54 <hugo_> http://hpaste.org/11638
05:27:03 <ivanm> in which case, it's not so easy to check if it's available
05:27:06 <hugo_> hmm
05:27:23 <Saizan> the script covers the haskell zlib
05:27:23 <saml> hugo_, for that, I'd use custom data record
05:27:47 <hugo_> oh
05:27:50 <saml> data A = A BotType CurDayType ...
05:27:56 <EvilTerran> dear lord!
05:28:02 <saml> hugo_, no never mind it won't help for column length
05:28:11 <hugo_> yes :/
05:28:20 <saml> you would still have to do performSerach (A bot curr_day..
05:28:27 <quicksilver> hugo_: http://hpaste.org/11638#a1
05:28:27 <hugo_> yes, i see
05:28:31 <EvilTerran> you could use a record, tho
05:28:31 <quicksilver> hugo_: is one way of doing it.
05:28:40 <saml> let's try to  split  f a b c d e = ...     to 5 functions that take 1 argument each
05:28:45 <quicksilver> hugo_: (I pasted it)
05:28:49 <quicksilver> I disagree with saml.
05:28:55 <quicksilver> I wouldn't bother with a custom record
05:28:58 <quicksilver> if it's only used once.
05:29:06 <quicksilver> I would if you have many functions taking this set of arguments.
05:29:42 <EvilTerran> well, there's two functions taking very similar sets of arguments right there
05:29:44 <saml> is it possible to split f a b = ... into   g a = ...   h b = ..   f = g . h  or something?
05:29:54 <hugo_> yes, far more elegant
05:29:57 <hugo_> thanks
05:30:03 <saft> wtf...
05:30:11 <saft> (load "/path/to/haskell-site-file.el")
05:30:17 <EvilTerran> saml, you can split "f a b c = ..." into "f a = g where g b = h where h c = ..."
05:30:21 <saft> Setup.hs: Error: Could not find module: Codec.Compression.GZip with any
05:30:21 <saft> suffix: ["hi"]
05:30:38 <saml> EvilTerran, oh cool!
05:30:39 <saft> configure and build workd but with install i got that
05:31:26 <hugo_> lots of these noob functional problems keep rising up :)
05:31:39 <hugo_> as long as i keep the blocks, there is no stress about
05:31:41 <hugo_> nice
05:31:45 <saft> haskell seems a lot like C but just cleaner and bigger and safer
05:31:47 <Saizan> saft: you've to install the zlib haskell package
05:32:01 <saft> Saizan that what im doing
05:32:03 <byorgey> Saizan: saft was using the bootstrap script
05:32:10 <saml> > let performSearch bot = a where a curr_day = b; b in_day = 1 in performSearch 1 2 3
05:32:11 <lambdabot>   1
05:32:21 <Saizan> oh, i thought that was saml, sorry :)
05:32:36 <byorgey> saft: interesting, I've never heard anyone say "haskell seems a lot like C" before =)
05:32:44 <Badger> heh
05:33:17 <Saizan> saft: then that means something has gone wrong in the build phase, since it can't find the files it's supposed to install
05:33:24 <saft> [saft@localhost zlib-0.4.0.4]$ sudo runghc Setup install
05:33:24 <saft> Installing library in /usr/local/lib/zlib-0.4.0.4/ghc-6.8.2
05:33:24 <saft> Setup: Error: Could not find module: Codec.Compression.GZip with any suffix:
05:33:24 <saft> ["hi"]
05:33:39 <jeffz> saft, you should stop pasting messages and ask questions instead
05:33:50 <Saizan> saft: how did "build" go?
05:33:58 <saft> byrogey: well structs = data and functions = clean fucntions, haskell == immutable C
05:34:28 <jeffz> for someone who might not know either language, it would be an easy mistake to make such a comparison
05:34:35 <saml> haskell is just a C disguised as a functional langauge
05:34:37 <saft> so do i need to install Codec.Compression.GZip too?
05:35:09 <Saizan> saft: no, that's a module of the zlib package
05:35:17 <saft> jeffz: well obv im talkign superficially
05:35:19 <C-Keen> saft: if you are within an IO monad it can look similar zes
05:35:40 <saml> @info for
05:35:41 <lambdabot> for
05:35:42 <saft> Saiazan: yes so why doesnt Setup install find it then?
05:35:47 <Saizan> saft: the error is complaining that it can't find the interface file for that module, that should have been produced by runghc Setup build
05:35:57 <luite> saft: if you need to compile that module, you'll probably need to install the development files for zlib
05:36:01 <EvilTerran> byorgey, if you're most familiar with dynamically typed (at best) languages, haskell and C would seem similar by virtue of both being statically typed
05:36:12 <byorgey> EvilTerran: that's true
05:36:16 <saml> saft, i think there's a way to automatically install cabal dependancies from hackage
05:36:34 <Saizan> saft: so, did "runghc Setup build" ended successfully?
05:36:35 <dcoutts> saml: it's called cabal-install
05:36:35 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:36:43 <saml> but i just download each missing dependancy tarballs from hackage and install them manually
05:36:48 <saml> dcoutts, ah thanks
05:36:56 <saft> Saizan yes configure and build worked
05:37:09 <saft> saml: that what im trying to do
05:38:02 <Saizan> saft: can you paste the output of build?
05:38:11 <saft> wait actually build failed
05:38:16 <Saizan> heh
05:38:17 <saft> hard to see someotimes at a glance
05:38:37 <Saizan> i bet it's missing zlib.h
05:39:34 <saft> http://hpaste.org/11639
05:39:55 <saft> Saizan: correct
05:40:23 <Saizan> yeah, so you've to install the C zlib library via your distro
05:40:57 <dcoutts> who want's to implement the cabal ticket about finding C libs and .h files?
05:41:08 <saft> i get already install latest version
05:41:12 <saft> zlib-1.2.3
05:41:15 <dcoutts> so that we get decent error messages and not build failures like the above
05:41:29 <luite> saft: you need the development package, the normal package only includes the library itself
05:41:35 <dcoutts> saft: you need the dev version with the header files
05:41:42 <saft> zlib-dev?
05:41:45 <dcoutts> yep
05:41:50 <saft> not available
05:41:58 <luite> zlib1g-dev on ubuntu, probably debian as well
05:42:00 <saft> if that is the exact spelling
05:42:06 <saft> fedora here
05:42:26 <dcoutts> saft: search for zlib and pick the one that looks like it's a dev/devel version
05:42:35 <saft> how do i search lol?
05:42:49 <saft> can i do grep yum list ?
05:42:54 <saft> how did soemoen dot hat before?
05:43:48 <Saizan> saft: it looks like there's no fedora user around, you can always look at yum's documentation
05:45:18 <saft> ah ! grep is awesome
05:45:32 <saft> yum list | grep -i "zlib"
05:45:38 <saft> zlib-devel.i386
05:45:45 <saft> zlib-static.i386
05:48:57 <saft> seems to work now
05:51:55 <C-Keen> what could be the cause for this error? http://hpaste.org/11640
05:52:14 <marcot> Hello. When I use ghc-pkg list with a fresh new user I get a complete list.  With my user, I don't get some packages
05:52:30 <marcot> This is not about the user installed packages, is about system wide packages (packaged by debian)
05:54:44 <saft> booya! thanks for the pointers cabal is installed
05:54:59 <saft> wait cabal shouldit it be cabal-install?
05:55:20 <quicksilver> 'cabal' is the name of the executable provided by cabal-install
05:55:21 <C-Keen> do cabal update and cabal install $package then
05:55:24 <quicksilver> I agree that's pretty confusing.
05:55:33 <quicksilver> 'Cabal' itself is just a library
05:55:38 <saft> doesnt work
05:55:43 <saft> cabak: command not found
05:55:50 <saft> i need to add soemthing more, to path?
05:55:58 <dcoutts> saft: yep, ~/.cabal/bin
05:56:36 <saft> ok to .bashrc?
05:56:37 <Saizan> or /usr/local/bin if you installed globally
05:58:10 <romildo> Is there a better way of creating an IArray with all the elements initialized to the same value than the following?
05:58:11 <romildo>   listArray (minBound::Info,maxBound::Info) [""|i <- range infoBounds]
05:58:11 <romildo>  where Info is the type of indices.
05:58:42 <romildo> infoBounds = (minBound::Info,maxBound::Info)
06:00:15 <Saizan> > listArray (0,2) $ repeat ()
06:00:16 <lambdabot>   array (0,2) [(0,()),(1,()),(2,())]
06:00:46 <saft> anyone played witht he actor-package?
06:01:27 <saft> Internal.hsc:18:31: error: gsl/gsl_sf_result.h: No such file or directory
06:01:28 <romildo> Saizan, thanks for the tip.
06:01:44 <saft> Saizan et al, thansk for the help with cabal it works now
06:01:47 <Herbi> hi
06:01:53 <saft> hi!
06:02:14 <Herbi> I have a type data Expr = Con Int | Var String | Sum[Expr] | Prod[Expr] and a function simplify:: Expr -> Expr
06:02:29 <Herbi> how do I define a function for every element of Expr?
06:02:39 <mauke> manually
06:02:46 <Herbi> like simplify Con 5 = 5
06:02:57 <mauke> like that, except simplify (Con 5) = 5
06:03:01 <mauke> and that's a type error
06:03:06 <saft> Herbi: u write one, it it nos object-orientation where you attach a mtheod to eahc object
06:05:21 <Herbi> this way?
06:05:22 <Herbi> simplify (Con x) = Con x
06:05:23 <Herbi> simplify (Var x) = Var y
06:05:23 <Herbi> simplify (Sum x) = error "not impl"
06:05:23 <Herbi> simplify (Prod x) = error "not impl"
06:05:46 <mauke> yes
06:05:55 <maltem> except for the y :)
06:06:08 <ivanm> how does one get cabal-install to build haddock docs?
06:06:33 <Saizan> --enable-documentation
06:06:48 <ivanm> yeah, tried that, no difference :s
06:07:19 <Herbi> hmm, it does not to work that way
06:07:21 <Herbi> > simplify Con 4
06:07:21 <Herbi> <interactive>:1:9:
06:07:21 <Herbi>     Couldn't match expected type `Expr'
06:07:21 <Herbi>            against inferred type `Int -> Expr'
06:07:21 <Herbi>     In the first argument of `simplify', namely `Con'
06:07:22 <lambdabot>   Not in scope: `simplify'Not in scope: data constructor `Con'
06:07:22 <Herbi>     In the expression: simplify Con 4
06:07:24 <Herbi>     In the definition of `it': it = simplify Con 4
06:07:26 <ivanm> ahh, I need to do cabal haddock (I'm doing manual building to use --only when doing install)
06:08:09 <mauke> Herbi: simplify (Con 4)
06:08:37 <Herbi> > simplify (Con 4)
06:08:37 <Herbi> *<interactive>:1:0:
06:08:37 <Herbi>     No instance for (Show Expr)
06:08:37 <Herbi>       arising from a use of `print' at <interactive>:1:0-15
06:08:37 <Herbi>     Possible fix: add an instance declaration for (Show Expr)
06:08:38 <Jaak> simplify Con 4 is same as (simplify Con) 4
06:08:38 <Herbi>     In the expression: print it
06:08:38 <lambdabot>   Not in scope: `simplify'Not in scope: data constructor `Con'
06:08:40 <Herbi>     In a 'do' expression: print it
06:08:56 <Saizan> Herbi: don't paste multiple lines in channel like that
06:08:59 <mauke> Herbi: see? it works
06:09:11 <Herbi> kk, Saizan
06:09:24 <Herbi> hmm
06:09:33 <Herbi> and whats the point then? ;)
06:09:49 <Herbi> I am completly new to haskell ;)
06:10:06 <saft> Herbi: use hpaste.org
06:10:30 <saft> @hpaste
06:10:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:10:54 <saft> post your code, your errors and a description of what you want to do
06:11:43 <Saizan> Herbi: to print a value ghci requires it to be an instance of the Show typeclass, the easy way is to add "deriving Show" at the end of your data Expr = .. declaration
06:12:06 <C-Keen> how do I type the following: I want to take a function as an argument that can have arbitrary parameters as long as it has the right result type
06:12:30 <mauke> (a -> X) -> ...
06:13:14 <C-Keen> mauke: this would just match functions with one argument right?
06:13:28 <mauke> all functions have one argument
06:13:30 <int-e> C-Keen: how are you planning to use that function?
06:13:40 <Herbi> heres the deal ;) http://hpaste.org/11641
06:14:15 <C-Keen> mauke: hm right...
06:15:56 <ivanm> mauke: they can just be other functions? ;-)
06:16:03 <C-Keen> int-e: I need to run runInteractiveCommand and runInteractiveProcess but I don't want to duplicate the code around handlich the input/outputhandles, exceptions etc. I want to give that function either runInteractiveCommand or *Process. But since both have different parameter types I need to match both
06:16:38 <Herbi> does anyone have a good idea? or maybe an "outline" of the code, so that i only need to implement the given rules?
06:17:00 <int-e> C-Keen: so just pass the IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, ProcessHandle) action?
06:17:03 <Taejo> Herbi: I'll take a look
06:17:09 <Herbi> thx
06:17:33 <C-Keen> int-e: hm...of course...
06:18:35 <Taejo> Herbi: I'm assuming "data Expr = Con Int | Prod [Expr] | Sum [Expr]", right?
06:19:08 <Herbi> add Var String
06:19:19 <Taejo> Herbi: ok
06:19:26 <Taejo> right, missed that
06:19:30 <Herbi> you do not need to caculate the result, just simplify the term
06:20:42 <Taejo> Herbi: see what you can do with http://hpaste.org/11641#a1
06:20:51 <Taejo> fill in what you can
06:23:12 <Herbi> Couldn't match expected type `Expr' against inferred type `[a]'
06:23:33 <Herbi> in simplify (Prod x.xs)
06:23:54 <Taejo> Herbi: that should be a colon, not a dot
06:23:58 <BeelsebobWork_> How does one get a list of licenses that cabal understands
06:24:22 <BeelsebobWork_> putting MIT gets it to complain, but I don't know what the correct string for the MIT license is
06:24:22 <dcoutts> BeelsebobWork_: they're listed in Distribution.License
06:24:40 <Herbi> it is ;)
06:24:40 <dcoutts> BeelsebobWork_: MIT isn't there yet
06:24:48 <dcoutts> (for tedious reasons)
06:25:05 <BeelsebobWork_> ah, fail -- is there a way to suppress the complaint and just accept that I want it MIT licensed?
06:25:10 <Herbi> Taejo: wouldn't it be easier to map list instead of using x:xs?
06:25:15 <dcoutts> Beelsebob: OtherLicense
06:25:32 <Taejo> Herbi: well, if what you want can be expressed as a map
06:25:41 <Taejo> which I don't think it can be
06:25:46 <Herbi> we'll see :D
06:25:50 <Herbi> kk
06:25:54 <dcoutts> BeelsebobWork_: we couldn't add new ones yet without breaking old versions of the Cabal lib that had very fragile parsers
06:25:55 <Taejo> in the sum case, you could use filter
06:26:02 <BeelsebobWork_> oh, lame
06:26:12 <Taejo> Herbi: I just realised I left out the empty list cases
06:26:17 <dcoutts> BeelsebobWork_: I've fixed the parser now which is why you get the warning rather than a parse error
06:27:02 <dcoutts> BeelsebobWork_: but I was going to wait one release cycle before adding extra syntax that breaks old Cabal versions, though perhaps doing it with Cabal-1.6 is not so bad
06:27:17 <dcoutts> given that we did add some other new syntax with Cabal-1.6
06:27:27 <ivanm> dcoutts: is there a relatively simple/sane way of having support for multiple versions of Cabal when used as a library?
06:27:33 <ivanm> preferably without using cpp?
06:27:40 <dcoutts> it was 1.4 that I made sure added no new syntax so that people could not break older Cabal versions
06:27:52 <dcoutts> ivanm: for hackport?
06:27:55 <Herbi> Taejo: how do I solve this problem? http://hpaste.org/11641#a2
06:28:00 <BeelsebobWork_> dcoutts: one thing that would certainly be nice would be to have OtherLicense be parameterised
06:28:06 <ivanm> dcoutts: nah, for my SourceGraph app
06:28:24 <ivanm> but yes, kolmodin still needs to fix up hackport ;-)
06:28:24 <BeelsebobWork_> so that you could insert OtherLicense BobsWierdOpenSourceCrazyLicenseThatNeedsYouToPutAFishOnYourHead
06:28:27 <dcoutts> BeelsebobWork_: that has the same problem :-)
06:28:30 <BeelsebobWork_> yeh, sure
06:28:32 <Taejo> Herbi: put "deriving Show" at the end of the "data Expr" declaration
06:28:46 <BeelsebobWork_> but if you are changing it, that would be a nice change
06:28:49 <Herbi> lke ... = ... deriving Show ?
06:28:57 <Taejo> yes
06:29:01 <Herbi> kk
06:29:03 <dcoutts> BeelsebobWork_: hmm, maybe. I'm also going to add optional gpl versions
06:29:11 <BeelsebobWork_> yeh, that would be nice
06:29:23 <BeelsebobWork_> I tend to avoid GPL3ed stuff
06:29:39 <ivanm> BeelsebobWork_: oh? why?
06:29:56 <Taejo> Herbi: without an instance for "Show", Haskell doesn't know how to convert stuff to strings. "deriving Show" means "I'm too lazy to convert it to strings myself, do it the default way"
06:30:02 <BeelsebobWork_> ivanm: I'm politically opposed to people restricting how software gets used
06:30:02 <Herbi> thx!
06:30:09 <BeelsebobWork_> especially when they preach that they're opposed to it too
06:30:16 <ivanm> BeelsebobWork_: so gpl-3 is bad, but gpl-2 is OK?
06:30:33 <BeelsebobWork_> ivanm: I'm not keen on gpl-2 either, but it's not-quite-so-evil
06:30:59 * ivanm has no problem with gpl-x... if you get the privelage of looking through and using someone's code, why should other people not have the same privelage of looking through yours?
06:31:21 <BeelsebobWork_> ivanm: because I'm free to make my own mind up what the hell I want to do with *my* source code
06:31:52 <kosmikus> and indeed you're free not to use GPLed code, so we're all happy
06:31:58 <BeelsebobWork_> no I'm not
06:31:58 <ivanm> BeelsebobWork_: sure you are... but if you've got someone elses in there, you have no right not to let other people see it
06:32:02 * Taejo has no problem with gpl-x but ends up licensing most of his stuff under BSD3 to match the ecosystem (either FontForge or Haskell)
06:32:04 <ivanm> linking is a different story...
06:32:12 <ivanm> I can see how linking to GPL code can be a PITA
06:32:21 <BeelsebobWork_> ivanm: I'm not not letting other people see it
06:32:26 <BeelsebobWork_> I can't un-release it
06:33:08 <ivanm> well, if it's in your code (note that I'm only talking about forking or 'borrowing' code) then people should be able to access how its used in yours
06:33:18 <BeelsebobWork_> why?
06:33:25 <ivanm> since it isn't yours
06:33:35 <BeelsebobWork_> yes, but that doesn't mean I have to tell you how I use it
06:33:46 <badsheepy> it does if the license says so
06:33:47 <BeelsebobWork_> people are still welcome to go look at it
06:33:52 <BeelsebobWork_> they can get it from where I got it from
06:34:00 <BeelsebobWork_> but how *I* use it is *my* descision
06:34:04 <ivanm> BeelsebobWork_: yes, but you can't hide it in your code because you don't have the right to do so
06:34:13 <BeelsebobWork_> ivanm: why not?
06:34:13 <ivanm> the person who wrote it said anyone can see it
06:34:25 <Herbi> Taejo, why does simplify (Con x) = x not work?
06:34:39 <BeelsebobWork_> ivanm: yes -- and they still can
06:34:49 <Taejo> Herbi: for the exact reason the compiler says it doesn't work
06:34:55 <BeelsebobWork_> what they can't see is *my* additions
06:35:06 <Taejo> cannot match type "Int" with type "Expr"
06:35:15 <ivanm> well, yes... but at the very least, people should be able to see those functions inside _your_ code
06:35:18 <BeelsebobWork_> ivanm: note that I'm promoting the use of the MIT license here, so citing is still necessary
06:35:26 <BeelsebobWork_> but I do like BSD too
06:35:32 <Herbi> maybe simplify (Con x) = (Con x)
06:35:35 * ivanm thought MIT == BSD-2
06:35:47 <BeelsebobWork_> MIT == BSD + please cite me
06:36:08 <ivanm> BeelsebobWork_: though realistically, how can one tell if a closed-source app uses MIT-licensed stuff, without doing a binary inspection?
06:36:15 <BeelsebobWork_> you can't
06:36:18 <ivanm> oh? I thought they were equivalent...
06:36:22 <BeelsebobWork_> but you can't tell with GPLed stuff either
06:36:30 <ivanm> true
06:37:01 <ivanm> except with MIT/BSD stuff, it's easier to "fix" it by having an attribution hidden away somewhere in your voluminous documentation
06:37:05 <BeelsebobWork_> the other argument against GPLed code that I have is that it stops a lot of useful people contributing to it
06:37:18 <ivanm> whereas if someone finds GPL-code in your code, you have to either re-write or re-license
06:37:33 <ivanm> BeelsebobWork_: oh? as in people whose companies forbid them, etc.?
06:37:34 <BeelsebobWork_> e.g. the company I work for will use BSD/MIT code, and contribute back to the projects
06:37:47 <BeelsebobWork_> in fact, it's started several BSD/MIT licensed projects
06:37:58 <ivanm> oh? which company is this?
06:38:01 <BeelsebobWork_> Anygma
06:38:19 <BeelsebobWork_> but there's several GPLed libraries that we would have used, but can't becasue of the GPL
06:38:27 <BeelsebobWork_> so those libraries didn't get our contributions
06:38:36 <ivanm> BeelsebobWork_: MIT license looks identical to BSD-2 to me...
06:39:29 <teratorn> in practice, people simply avoid GPL'ed code if they don't want to comply with the restrictions it places on you
06:39:44 <Taejo> BeelsebobWork_: looks like an interesting company
06:40:09 <ivanm> hard to get any information about it from the website though :s
06:40:14 * nominolo|msr mostly ignores GPL'd code
06:40:18 <BeelsebobWork_> teratorn: exactly -- specifically the restriction we don't want to comply with is that we have large amounts of our own code that will get linked against the GPLed code, and will thus have to be open sourced
06:40:33 <teratorn> BeelsebobWork_: yeah that's the typical scenario
06:40:40 <BeelsebobWork_> thus, we'll quite happily contributed to BSD projects
06:40:41 <Taejo> ivanm: well it combines haskell and 3D, which interest me... therefore, I suspect it's interesting
06:40:44 <BeelsebobWork_> but not to GPLed ones
06:40:50 <nominolo|msr> BeelsebobWork_: unfortunately LGPL is tricky too
06:40:54 <ivanm> Taejo: heh
06:40:56 <BeelsebobWork_> nominolo|msr: indeed it is
06:40:56 <nominolo|msr> BeelsebobWork_: at least in the context of haskelll
06:41:01 <BeelsebobWork_> yeh
06:41:05 <teratorn> open source is here to stay, Now. and it doesn't need the GPL anymore, really
06:41:07 <BeelsebobWork_> damn static linking everywhere
06:41:15 <teratorn> perhaps it the past it was useful.. I'm not sure
06:41:17 <BeelsebobWork_> teratorn: yeh, that's roughly where I stand on it
06:41:18 <ivanm> nominolo|msr: because of static linking?
06:41:29 <nominolo|msr> ivanm: that and cross-module inlining
06:41:31 <Taejo> teratorn: I think it still has its place
06:41:33 <ivanm> teratorn: s/open source/free software/ :p
06:41:40 <teratorn> perhaps there are a few niches where it makes sense
06:41:44 <teratorn> Linux kernel might be one
06:41:50 <ivanm> Taejo: yeah... like stopping companies from ripping off the linux kernel
06:42:22 <teratorn> 5 or 10 years ago I can just imagine microsoft forking and extending linux
06:42:41 <teratorn> or one of the commercial unix vendors
06:42:48 <nominolo|msr> teratorn: unlikely, but, sure, possible
06:43:05 <BeelsebobWork_> my biggest problem with GPL is that it preaches that it's Free Software
06:43:12 <BeelsebobWork_> when in reality it's heavily restricted software
06:43:22 <teratorn> what I mean is, I can imagine them doing it *if* it wasn't GPL
06:43:30 <nominolo|msr> BeelsebobWork_: it's a different kind of "free" ;)
06:43:36 <teratorn> BeelsebobWork_: heh, yes
06:44:09 <teratorn> nominolo|msr: yes, it's a "free" that somehow is defined requiring government violence or the threat of violence to enforce
06:45:14 <nominolo|msr> teratorn: it's too politically motivated
06:45:50 <nominolo|msr> "you are allowed to use this software if you abide by our view of the world"
06:46:02 <quicksilver> s/use/make derived works of/
06:46:12 <quicksilver> there is no restriction on USE of gpled software.
06:46:30 <quicksilver> and there is no onerous restriction on copying it, either.
06:46:53 <quicksilver> I appreciate your points (and disagree entirely) but let's be clear on the basics :)
06:47:03 <BeelsebobWork_> indeed
06:47:18 <BeelsebobWork_> I think quicksilver and I already had this argument and agreed exactly that
06:47:27 <BeelsebobWork_> (to disagree)
06:47:55 <quicksilver> if nominolo|msr's quoted phrase was accurate, it would be iniquitous indeed.
06:48:03 <quicksilver> which is why I decided to speak up :)
06:48:08 <BeelsebobWork_> heh
06:48:25 <BeelsebobWork_> the problem I have is with the use of the term "make derivitive works of"
06:48:40 <BeelsebobWork_> in that that can often mean "change completely, but retain 3 files"
06:49:19 <BeelsebobWork_> in which case it's mostly the 3rd party's work and I see no reason why the 1st party should enforce the license terms
06:49:51 <BeelsebobWork_> or the alternative where you make only minor changes -- I see no reason why you *should* be made to release it
06:50:01 <BeelsebobWork_> after all, anyone else is equally capable of making the minor changes
06:50:19 <badsheepy> you arent forced to release it if you only used it yourself :o
06:50:50 <BeelsebobWork_> sure... what I'm saying is suppose person A writes project A'
06:50:57 <ivanm> BeelsebobWork_: if anyone can, why can't you release it?
06:51:04 <BeelsebobWork_> and then company B comes along and makes 2 1 line changes to it, and releases it
06:51:19 <ivanm> then release a patch to the original
06:51:45 <ivanm> at least it's better than the gnuplot license: "you can't fork this, all you can do is release patches" :s
06:51:47 <Philippa> Beelsebob: the problem is that it's tricky to define the differences in a way that works, legally
06:51:55 <BeelsebobWork_> I see no reason why they shouldn't be allowed to do that -- after all, all that will happen if its closed is that someone else will make the same changes and release it for free
06:52:12 <Philippa> right, so actually what you mean is you prefer the BSD license anyway
06:52:23 <Philippa> yeah, fair enough
06:52:31 <Philippa> but it does make some sense /if/ you understand the ideology
06:52:36 <mapreduce> I'd like to see the GPL defeated in court.
06:52:39 <BeelsebobWork_> Philippa: yeh, I think I fail at case analysis -- I was trying to analyse the cases in terms of company B making small, medium or large changes to the code -- and assert that I don't mind them closed sourcing their changes in any of the cases
06:52:39 <Philippa> you don't have to agree with it
06:53:00 <BeelsebobWork_> yeh, exactly -- and I don't
06:53:09 <Philippa> I tend to release BSD myself, partly because the community I grew up via had an important relationship with commercial release
06:53:19 <Philippa> like, no commercial release = massive limitations on what you can actually achieve
06:53:41 <quicksilver> BeelsebobWork_: I'm not sure I have the energy to carry out this argument in detail, since I'm busy with other stuff and I've burnt too much of my life on this argument, but having said that...
06:53:49 <Philippa> it's not true for a lot of software, but it's true for content-heavy stuff, especially where that content needs to be coherent or is supposed to form one work
06:54:04 <quicksilver> basically I believe in free software because software can be free, and it benefits all humanity, so the moral imperative is to share it with all humanity.
06:54:18 <EmielRegis> @src elements
06:54:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:54:22 <quicksilver> I can't share an omelette with all humanity because it is on finite size.
06:54:27 <EmielRegis> what does elements do?
06:54:34 <quicksilver> a piece of software can be copied for a cost of approximately zero...
06:54:39 <quicksilver> so the moral imperative is to share it because i can.
06:54:46 <quicksilver> EmielRegis: not a function name I recognise. What's the context?
06:54:52 <quicksilver> @hoogle elements
06:54:53 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
06:54:53 <lambdabot> Data.Array.Base getNumElements :: (MArray a e m, Ix i) => a i e -> m Int
06:54:53 <lambdabot> Data.Array.Base numElements :: (IArray a e, Ix i) => a i e -> Int
06:55:01 <mapreduce> Good.  But please don't force me to share my software.
06:55:06 <quicksilver> EmielRegis: perhaps you're looking at the quickcheck ones.
06:55:15 <EmielRegis> ye probably
06:55:27 <EmielRegis> so it generates a list full of elements of [a] for quickcheck:
06:55:28 <EmielRegis> ?
06:55:29 <ketil> mapreduce: Nobody can do that.
06:55:29 <quicksilver> it makes a 'Gen' which selects one at random from that list
06:55:33 <quicksilver> I believe.
06:55:34 <EmielRegis> ah ok
06:56:04 <mapreduce> ketil: If I link to GPL software, then my software is a derivative work, and then I'm forced to either not distribute, or make my software GPL.
06:56:17 <quicksilver> mapreduce: I don't force you to do anything, but I believe you to be morally wrong if you don't.
06:56:19 <mapreduce> Linking to software is quite normal and shouldn't have legal implications.
06:56:32 <quicksilver> and since copyright gives me some power to enforce that , I choose to use that
06:56:33 * quicksilver shrugs.
06:56:46 <quicksilver> I can't force you not to steal money from your neighbour either.
06:56:50 <quicksilver> I believe that to be wrong, as well.
06:56:52 <mapreduce> So you do force me then, despite you just saying you don't.
06:56:57 <ketil> So you want to make a derived work, to do with as you want?  Aren't you trying to force authors of said work to distribute *their* software to *your* terms?
06:56:59 <quicksilver> no I don't.
06:57:14 <quicksilver> all I'm doing is attempting to control what you do with what I made.
06:57:24 <quicksilver> On a background of a stated belief which applies to what everyone makes, too.
06:57:29 <mapreduce> ketil: I'm unsure who that's addressed to, largely because I don't know what it means.
06:57:29 <quicksilver> There are two related points.
06:57:35 <ketil> mapreduce, to you :-)
06:57:42 <quicksilver> (1) my strong belief that all software should be shared
06:57:54 <quicksilver> (2) the world we *actually* live in, and what tools I can use to promote my belief.
06:57:56 <mapreduce> ketil: I'm not trying to make a library developer distribute his software on my terms, no.
06:58:04 <quicksilver> (2) falls a long way short of (1), obviously.
06:58:12 <Philippa> you're merely asking for it
06:58:15 <quicksilver> Indeed I work a 40-hour week writing non-free software
06:58:19 <quicksilver> so I'm a hypocrit in a sense.
06:58:23 <Philippa> (in most cases I do think GPLed libraries are a bad idea...)
06:58:54 <ketil> mapreduce: but your worry is that you are not able to make derived works of GPL software under another license, no?
06:58:56 <mapreduce> Philippa: I think ideally all or at least most software should be able to be treated as bags of libraries.
06:59:22 <Philippa> mapreduce: I think enforcing /that/ is a really incredibly bad idea
06:59:38 <mapreduce> ketil: where derived works means "linked to", as in "project X uses functions from library Y".
06:59:52 <Philippa> but yes, a lot more software should be written with a significant collection of libraries involved
07:00:21 <Philippa> yeah. You can, of course, run library Y via a wrapper in another, GPLed, process...
07:00:30 <mapreduce> Yes.
07:00:36 <ketil> mapreduce, I don't think that suffices as "derived work", but whatever.  I don't see why anybody but the library author gets to decide its licensing.
07:00:46 <mapreduce> This is where the distinction between derive and use starts to look arbitrary.
07:00:49 <mapreduce> Because it is. :)
07:01:14 <ketil> mapreduce, and if you don't like the licensing, you are free to write a replacement library.
07:01:17 <Philippa> ketil: the problem is that you end up deriving from the interface, which is under the same license
07:01:41 <Philippa> (and part of the same work, of course)
07:01:46 <ketil> I'm not convinced using an API counts as deriving.
07:02:01 <Philippa> it's rather hard for it not to in C's case
07:02:03 <mapreduce> ketil: The library author should get to decide their own licence, but they shouldn't get to decide mine.
07:02:04 <dcoutts> if you make a new impl of that API then that's one thing
07:02:14 <quicksilver> ketil: nobody knows.
07:02:20 <quicksilver> ketil: it's never been tested in law.
07:02:23 <quicksilver> (as far as I can remember).
07:02:32 <Philippa> mapreduce: eh, they're perfectly in their right to decide they're only willing to make it available to projects licensed a certain way
07:02:33 <dcoutts> but if you say you're only using that API but then get the user to use the origianl impl then it just looks like you're trying to get around the license
07:02:50 <quicksilver> I think it's possible to argue that by packaging something as a 'library' and providing an 'API' for it you are giving implicit permission to link that API.
07:03:20 <Philippa> quicksilver: to the extent that the library is licensed, yes
07:03:25 <quicksilver> Philippa: *nods*
07:03:28 <mapreduce> Philippa: I don't think they should be allowed to do that.
07:03:29 <dcoutts> quicksilver: unless you're giving explicit permission under a specific license
07:03:50 <mapreduce> It's an unreasonable restriction, as the monster-EULAs for Windows and Apple stuff embody.
07:03:52 <ketil> mapreduce, you get to choose your own license, but you need to comply with the licenses on other software that you use.
07:04:07 <Philippa> mapreduce: no, it's not in the same class at all
07:04:27 <mapreduce> I wanted to ask RMS this question when I saw him speak, but didn't manage to..
07:04:32 <quicksilver> anyhow, I wasn't trying to convince anyone. Just clearly state the case.
07:04:32 <Philippa> for example, that would mean no "free to free projects, costs for commercial" licenses...
07:04:48 <ketil> mapreduce, I think it is unreasonable to expect to use software without respecting its licensing.
07:04:58 <quicksilver> the point that hadn't been made was the moral one: and free software was originally a moral thing.
07:05:16 <mapreduce> "If I invented an equivalent licence to the GPL, called FOO, would GPL and FOO be compatible?"
07:05:24 <xmux> No
07:05:27 <quicksilver> mapreduce: yes, they would.
07:05:41 <ketil> Sure, as long as you don't add any further restrictions.
07:05:59 <quicksilver> mapreduce: because the GPL merely requires that you abide by all its rules. If FOOs rules are the same rules, then abiding by the GPL rules is also abiding by the FOO rules and vice versa
07:06:19 <mapreduce> Ok.
07:06:25 <quicksilver> in generaly when you have a composite work containing N pieces of software
07:06:28 <xmux> The GPL requires you to license derivative works under the GPL not under an equivalent copyleft license
07:06:35 <quicksilver> you have to obey all of their licenses at once
07:06:44 <quicksilver> xmux: that's doesn't mean what you think it means.
07:06:44 <Philippa> xmux: yeah, but you effectively have the right to do that
07:06:49 <Philippa> you just have to distribute under /both/ licenses
07:07:04 <quicksilver> mapreduce: so the "compatibility" question is whether it is actually possible to obey all N licenses at once
07:07:14 <mapreduce> Ok, I see.
07:07:19 <quicksilver> mapreduce: if they somehow contradict each other, then you can't obey them all; that's what people mean by incompatibility
07:07:21 <Philippa> to put it another way: structural equivalence
07:09:29 <nominolo|msr> :t foldl
07:09:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
07:09:40 <ketil> mapreduce, do you have a specific problem - i.e. problems with a specific library?
07:10:19 <ketil> ...since I know that at least my GPL code is available for relicensing, if anybody, you know, asks nicely.   Presumably, this can be the case for others as well.
07:11:19 <nominolo|msr> quicksilver: that was no quote, more a paraphrase.  and i meant "use" in the sense of "use our code in your program"
07:11:51 <quicksilver> nominolo|msr: Yes. I only meant "quote" in the sense of "in quotation marks". And since I know you to not be stupid, I was fairly sure that's what you meant by use.
07:12:06 <quicksilver> nominolo|msr: but standing alone it was pretty deceptive and I wanted to correct it on the records
07:12:35 <nominolo|msr> k
07:13:32 <C-Keen> sorry for repeating myself:
07:13:37 <C-Keen> I don't understand what causes this error: http://hpaste.org/11644
07:13:43 <C-Keen> Initially I had find_bash :: String there but it resulted in a similar error of not being able to match [a] to String
07:13:48 <C-Keen> which is equally helpful
07:15:23 <nominolo|msr> C-Keen: there's an argument missing to process_wrapper, isn't there?
07:15:30 <Igloo> You want find_bash :: IO String (well, FilePath) presumbaly
07:15:34 <C-Keen> zep
07:15:45 <nominolo|msr> ah, no
07:16:23 <Igloo> Why not?
07:16:51 <quicksilver> C-Keen: your type error in the first instances is because process_wrapper takes two arguments and you only gave it one
07:16:54 <mapreduce> ketil: No, I don't have a problem with a specific library.
07:17:18 <nominolo|msr> Igloo: oh, indeed
07:17:28 <quicksilver> it's at times like this that it's pretty unhelpful that (->) is a monad, in fact ;)
07:17:36 <mapreduce> ketil: But in general I don't think the set of things a licence can impose should include the licence the user must use.
07:17:56 <nominolo|msr> C-Keen: it's typically helpful to add type signatures, since otherwise it's tricky to know where the actual error occurs
07:17:58 <C-Keen> Igloo: quicksilver nominolo|msr thanks!
07:18:08 <C-Keen> nominolo|msr: indeed
07:18:16 <quicksilver> mapreduce: s/user/developer of derived software/
07:18:22 <quicksilver> mapreduce: (sorry to be a scratched record)
07:18:27 <quicksilver> it *is* an important distinction to make thouhg.
07:18:47 <quicksilver> for example, buying a DVD from Wal-Mart does not give you a license to make derived works of it, either.
07:18:58 <quicksilver> the separation between use and derivation is pretty routine.
07:19:49 <nominolo|msr> quicksilver: indeed, i was trying to figure out how that kind of error could have occured
07:20:12 <ToRA|MSR> in a .cabal file, does it make any difference if you end your module-name lines (in e.g. exposed modules) with a , or not?
07:20:20 * nominolo|msr logs new feature for IDE ("show type of monad used by a do expression")
07:20:22 <quicksilver> nominolo|msr: partially applied function has function type, stick it in a do block and it assumes the do block is part of the -> monad, result : pretty weird error message.
07:20:28 <quicksilver> nominolo|msr: +1 on that
07:21:07 <Deewiant> that'd be the reason why instance Monad ((->) r) isn't in the prelude, I suppose
07:21:39 <nominolo|msr> @index instance Monad ((->) r)
07:21:39 <lambdabot> bzzt
07:21:51 <Deewiant> Control.Monad.Instances
07:21:58 <ronwalf> What's the trick to get ghci-10rc1 to use editline?
07:22:05 <ronwalf> I'm not seeing an obvious configure option
07:22:26 <nominolo|msr> ToRA|MSR: it shouldn't matter
07:22:26 <ronwalf> Only a bit in the config saying that the installed ghc doesn't have it
07:22:34 <quicksilver> Deewiant: yes, it is.
07:22:52 <quicksilver> Deewiant: it's *almost* enough of a reason for me to suggesting wrapping it in a newtyp
07:22:58 <quicksilver> newtype Reader r a = r -> a
07:23:02 <quicksilver> newtype Reader r a = Reader (r -> a)
07:23:08 <quicksilver> I'm not sure if that's really what I'd want.
07:23:11 <Deewiant> hmm, wat
07:23:14 <Deewiant> what am I confusing it with
07:23:14 <ronwalf> I can cd in to libraries/editline and build it by hand (though it takes some configure arg tweaking, since editline is installed to my homedir)
07:23:16 <C-Keen> how do i tell cabal to fetch a certain version?
07:23:24 <quicksilver> but I think the (->) annoys me more often in real code than it helps me.
07:23:31 <dcoutts> C-Keen: cabal fetch foo-1.0
07:23:42 <BrokenClockwork> I want to look up, how a prelude function is defined, where can I look this up?
07:23:52 <dcoutts> @src map
07:23:53 <lambdabot> map _ []     = []
07:23:53 <lambdabot> map f (x:xs) = f x : map f xs
07:24:08 <quicksilver> BrokenClockwork: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
07:24:08 <dcoutts> BrokenClockwork: or look it up in the language report
07:24:10 <lambdabot> Title: Prelude, http://tinyurl.com/y4wexy
07:24:17 <quicksilver> BrokenClockwork: (source link, top right)
07:24:19 <Deewiant> quicksilver: I really doubt it is
07:24:26 <Deewiant> quicksilver: my GHCi tells me "instance Monad ((->) r) -- Defined in Control.Monad.Instances"
07:24:31 <nominolo|msr> BrokenClockwork: the documentation that hoogle links to typically contains source links now
07:24:36 <quicksilver> Deewiant: yes, I wasn't disagreeing.
07:24:38 <Deewiant> or did I just misunderstand you
07:24:40 <Deewiant> yes, I did
07:24:41 <quicksilver> you did :)
07:24:43 <Deewiant> great, never mind then :-P
07:24:47 <quicksilver> I was just saying even in C.M.I I'm not sure I like it
07:24:52 <quicksilver> maybe it should be hidden in a newtype.
07:24:56 <Deewiant> yeah, gotcha
07:25:22 <BrokenClockwork> ok I will try to find
07:25:38 <nominolo|msr> anyone know why Network.Socket.recv throws an exception on eof instead of return something of length 0?
07:26:00 <Saizan> C-Keen: btw, you should start feed the input after forking the consuming threads in process_wrapper
07:26:24 <BrokenClockwork> perfect got it, the "Source"-link was kinda tricky to find
07:26:33 <Saizan> "feeding"
07:27:41 <quicksilver> nominolo|msr: I guess it doesn't.
07:27:47 <quicksilver> nominolo|msr: I guess your program is receiving SIGPIPE
07:27:51 <quicksilver> nominolo|msr: which ghc converts to an exception
07:28:01 <quicksilver> I'm not sure though.
07:28:37 <quicksilver> I know old GHCs just get the SIGPIPE, (and therefore quit) and I know JaffaCake decided to change this somehow. I'm not sure of the new mechanism he used.
07:29:36 <dcoutts> quicksilver: it's an async exception
07:29:43 <dcoutts> I think
07:30:01 <quicksilver> dcoutts: to which thread, I wonder.
07:30:09 <quicksilver> (that's what I wondered when JaffaCake was first discussing it)
07:30:11 <dcoutts> the main thread I expect
07:30:24 <quicksilver> if you ignore sigpipe explicitly does that stop the exception too?
07:30:41 <dcoutts> you mean if you override the signal handler?
07:30:46 <dcoutts> then yes
07:33:11 <nominolo|msr> quicksilver: hm, the docs say you get SIGPIPE on writing but not reading
07:33:14 <quicksilver> anyone speak dutch? what's the correct way to pronounce 'Rijndael' ?
07:33:37 <Deewiant> quicksilver: http://en.wikipedia.org/wiki/Rijndael links to a wav
07:33:39 <lambdabot> Title: Advanced Encryption Standard - Wikipedia, the free encyclopedia
07:33:54 <Deewiant> in footnote 4, to be exact
07:34:22 <idnar> While trying to retrieve the URL: http://rijndael.info/audio/rijndael_pronunciation.wav
07:34:26 <idnar> The following error was encountered:
07:34:26 <nominolo|msr> quicksilver: recv explicitly throws an eofError if the C call says it has read no bytes
07:34:28 <idnar>     * Connection to 68.60.247.157 Failed
07:34:37 <quicksilver> nominolo|msr: I think that's very strange in deed.
07:34:39 <Deewiant> darn
07:34:44 <Deewiant> ah well, it has the IPA as well :-)
07:34:48 <idnar> something vaguely like "rain-dull", I would have thought
07:34:50 <quicksilver> nominolo|msr: (that's quite inconsistent with "recv(2))
07:34:58 <quicksilver> nominolo|msr: I bet there is a reason, though
07:36:13 <Deewiant> idnar: yeah, looking at the IPA it seems that's about the closest you can get in english
07:36:52 <idnar> maybe "rai'n-dahl" would be a better informal transliteration
07:37:04 <idnar> although I guess these things are highly dependent on your accent
07:37:42 <idnar> I'm mostly going by my knowledge of Afrikaans, I'm not so good at reading IPA
07:38:34 <quicksilver> "dijkstra" is pronounced something very like "dike-stra"
07:38:44 <quicksilver> so I was expecting "rijn" to be "rhine"
07:39:16 <idnar> wikipedia has "ˈdɛɪkstra" for Dijkstra
07:39:17 <Deewiant> as was I, but the IPA disagrees
07:39:37 <quicksilver> I always think it's very ironic that dijkstra didn't invent tensors
07:39:41 <Deewiant> interestingly the two 'i's are different there
07:39:42 <quicksilver> he was clearly destined too.
07:39:58 <Twey> 'Rain-darl'
07:40:22 <idnar> "dike-stra" sounds weird
07:40:43 <quicksilver> well maybe it's wrong; but it's how I've heard it spoken in the UK.
07:41:00 <Deewiant> hm, now I'd really like to know if the 'dike' is an approximation for english-speakers who can't pronounce 'day-k' or some such
07:41:13 <quicksilver> that's quite possible.
07:41:19 <ivanm> anyone know what darcsum's "add changelog" option does?
07:41:30 <quicksilver> I think I can pronounce "day-k" but maybe I'm not pronouncing the thing you want me to pronounce ;)
07:41:30 <opqdonut> afaik it's "die-kshtra"
07:41:52 <idnar> http://forvo.com/word/dijkstra/
07:41:53 <quicksilver> ah the joys of tryiing to explain phonetics over IRC..
07:41:55 <Deewiant> it could also depend on your /dutch/ accent
07:41:58 <lambdabot> Title: dijkstra pronunciation: How to pronounce dijkstra in Nederlands (Dutch)
07:42:05 * quicksilver doesn't have much of a dutch accent.
07:42:10 <opqdonut> quicksilver: luckily IPA \subset unicode
07:42:32 <Deewiant> according to idnar's link it's definitely more like 'day-k'
07:42:46 <Deewiant> opqdonut: ⊆
07:42:51 <idnar> heh
07:42:57 <opqdonut> Deewiant: international phonetic alphabet
07:43:04 <quicksilver> opqdonut: unluckily I don't speak IPA very well either ;)
07:43:09 <opqdonut> :D
07:43:11 <Deewiant> opqdonut: I meant that \subset = ⊆
07:43:12 <idnar> that character looks awful on the same line as monospace text
07:43:21 <Deewiant> your font is just awful :-P
07:43:22 <earthy> dijkstra would most accurately be pronounced as dyke stra
07:43:33 <opqdonut> Deewiant: the character set IPA is a subset of the character set unicode
07:43:36 <earthy> but even then it's off
07:43:37 <quicksilver> that's how I pronounce, but not how idnar's dutchman does
07:43:54 <opqdonut> Deewiant: ah
07:43:55 <Deewiant> opqdonut: what I'm pasting is the subset-of character in unicode, I think you're seeing a question mark :-P
07:43:59 <opqdonut> Deewiant: yes
07:44:02 <idnar> I would expect it to be pronounced something like "dykstra" would be in Afrikaans
07:44:03 <arjanb> dijkstra is not really dutch but frisian
07:44:04 <opqdonut> now i realised
07:44:14 <opqdonut> and it's not my font, it's my charset (latin-1)
07:44:53 <earthy> arjanb: however, dijkstra was from brabant, afaict
07:45:02 <earthy> as in Edsger Wybe Dijkstra
07:45:25 <earthy> ah, born in Rotterdam, studied in Leiden
07:45:31 <earthy> yup. no frisian there.
07:45:44 <arjanb> yeah but the names are frisian
07:45:52 <earthy> originally
08:06:49 <iabal> hi, can I expect that fold1P will work in parallel? (doing reductions)
08:08:32 <Saizan> ?hoogle fold1P
08:08:33 <lambdabot> No results found
08:08:47 <iabal> there isn't doc about ndp library
08:09:01 <iabal> "Haddock doesn't support various language features used by the library at the moment and can't be used to generate documentation."
08:10:42 <nominolo|msr> iabal: hm, i wonder if that is still true
08:11:04 <iabal> nominolo|msr, is not trivial
08:11:34 <iabal> it's only correct in some cases, you must have a precondition over the first argument (e -> e -> e)
08:11:38 <nominolo|msr> iabal: haddock uses teh ghc api, so at least parsing is no longer the problem.  of course, it might be a problem in the output generation
08:11:39 <iabal> to be associative
08:12:36 <byorgey> iabal: right, there's no way to guarantee that in general
08:12:48 <byorgey> although I don't know the specifics of fold1P
08:13:52 <iabal> hmm
08:14:18 <byorgey> do you have the source?
08:16:14 <nominolo|msr> let f [a,b,c] = a in f [1,2,3]
08:16:22 <iabal> I was trying to find it in the ghc repository
08:16:30 <nominolo|msr> > let f [a,b,c] = a in f [1,2,3]				[15:16]
08:16:31 <nominolo|msr>  
08:16:32 <lambdabot>       No instance for (Num ([[t]] -> a))
08:16:32 <lambdabot>        arising from the literal `1' ...
08:16:32 <iabal> to see the comments
08:18:02 <alar> greetings
08:18:14 <alar> can somebody help me with GHC vs UTF-8
08:18:17 <alar> ?
08:18:43 <alar> I've found that GHC gladly consumes UTF-8 literals
08:18:58 <alar> but I don't know how to print them in actual locale
08:20:06 <Saizan> alar: Char represent unicode codepoints, so literals are translated to that when compiling
08:20:37 <quicksilver> alar: you need utf8string or a similar library
08:20:46 <quicksilver> to actually output utf8-encoded stuff
08:20:48 <alar> thanks
08:21:03 * alar is googling for utf8string now
08:21:11 <Saizan> ?hackage utf8-string
08:21:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
08:22:33 <iabal> ok, found
08:22:38 <iabal> byorgey,
08:22:50 <iabal> -- * the first argument must be associative; otherwise, the result is undefined
08:22:50 <iabal> --
08:22:50 <iabal> fold1P :: (e -> e -> e) -> [:e:] -> e
08:23:00 <iabal> perfect
08:24:04 <iabal> it's better when preconditions are part of the type
08:32:31 <mapreduce> Strongly agree.
08:33:34 <quicksilver> hard to do though.
08:33:44 <quicksilver> How do you write the type for associative binary functions?
08:34:10 <dolio> Pass around a proof.
08:34:15 <dolio> That's a pain, though.
08:34:33 <nominolo|msr> dolio: use an existential
08:34:41 <quicksilver> I appreciate the principle.
08:34:49 <nominolo|msr> dolio: this way you only need to provi it once
08:34:55 <quicksilver> But a proof of associativity is not a pleasant object
08:35:10 <dolio> Indeed.
08:35:45 <quicksilver> most proofs of associativity reduct the operation to some other operation which is known to be associative, in fact
08:35:47 <dolio> Plus, in Haskell, you can't even erase it at runtime.
08:36:10 <quicksilver> so they take the form of associativity-preserving homomorphisms onto a known something
08:36:35 <Saizan> where does the existential would help?
08:36:57 <ystael> (ignorance speaking) in Haskell wouldn't you rather just mark associativity with a type class, where the proof construction is a method which is never called in your actual program?
08:37:55 <Cale> Largely, we already use typeclasses this way, only the proofs are left out completely. :P
08:37:55 <quicksilver> ystael: yes, that would be the natural approach
08:37:59 <quicksilver> ystael: (e.g. Monoid)
08:38:06 <quicksilver> ystael: but the proof is entirely absent ;)
08:38:25 <Saizan> and you've to define a new type for each operation
08:38:58 <ystael> (i've spent the last couple months with Coq, so i expect that when i try again to learn Haskell properly it will feel a little odd :))
08:39:16 <dolio> You do a similar thing with dependent records in appropriate languages.
08:40:01 <dolio> record Foo where { op : a -> a -> a ; assoc : ((a `op` b) `op` c) == (a `op` (b `op` c)) }
08:40:27 <dolio> However, in Haskell, if you never ask for the proof, you can cheat by proving anything with bottom.
08:40:41 <iabal> quicksilver, Coq does
08:41:42 * alar thinks that proving properties in non-dependent-typed languages is a kind of magic
08:43:58 <dolio> Now that you mention it, proofs that a value-level function is associative might be really hairy in Haskell.
08:44:09 <iabal> ystael, a type-class mark a type, not a implementation
08:44:42 <iabal> an*
08:45:22 <iabal> ystael, Coq have type-classes now, if you don't know
08:49:30 <dolio> (Barring the external checkers that sort of add their own dependent typing that is.)
08:51:51 <quicksilver> iabal: coq does what?
08:52:15 <iabal> <quicksilver> hard to do though.
08:52:23 <iabal> have preconditions in types
08:52:28 <quicksilver> that's not the hard bit.
08:52:30 <iabal> and postconditions
08:52:37 <quicksilver> the hard bit is actually proving associativity.
08:52:47 <iabal> made the proof?
08:52:53 <quicksilver> as I said later, a proof of associativity is generally a horrible object.
08:53:01 <quicksilver> Yes, actually making the proof is the hard bit.
08:53:07 <quicksilver> not carrying it around once you've made it.
08:53:56 <Saizan> oh, evil, (IORef ()) used as an unique identifier
08:56:03 * dcoutts_ builds a cabal.exe by doing cabal install cabal-install
08:56:10 <quicksilver> Saizan: hee hee :)
08:56:25 <quicksilver> Saizan: that's so evil I can't believe I never thought of it myself.
08:56:25 <dcoutts_> la la la la, yay for package management, even on windows!
08:57:24 <dcoutts_> quicksilver: I believe it's a common trick in ml, but then refs are a bit easier to use in ml
08:57:51 <quicksilver> dcoutts_: aye. ml has drunk deeply of the dark side of the force
08:57:59 <dcoutts_> quite :-)
08:58:17 <dolio> Are IORefs Eq?
08:58:26 <dolio> @instances-importing Data.IORef Eq
08:58:27 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, IORef a, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:58:36 <dolio> Well I'll be.
08:59:17 <Saizan> noone worries about those little () trapped there? ;)
08:59:21 <quicksilver> dolio: I have quite often need it.
08:59:25 <quicksilver> I can't remember why, now ;)
08:59:31 <dolio> :)
08:59:40 <quicksilver> their ord instance is nice for inside-out extension
08:59:46 <dolio> nubbing a big list of them?
08:59:58 <quicksilver> Data.Map (IORef a) v
09:00:05 <quicksilver> yeah, nubbing is probably why.
09:00:14 <Saizan> are they Ord? haddock doesn't report that
09:00:22 <RayNbow> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020028.html <-- how bad are DiffArrays when you try n different updates and evaluate the "fitness" of the n new arrays?
09:00:24 <lambdabot> Title: [Haskell-cafe] 2D Array, http://tinyurl.com/6fkatd
09:00:27 <dolio> @instances-importing Data.IORef Ord
09:00:28 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:00:35 <C-Keen> cabal: Couldn't read cabal file "./Glob/0.1/Glob.cabal" what did I do wrong? I typed cabal install glob
09:01:00 <Deewiant> cabal --version?
09:01:04 <dolio> RayNbow: Probably not better than just plain immutable arrays.
09:01:18 <C-Keen> cabal-install version 0.5.2
09:01:18 <C-Keen> using version 1.4.0.2 of the Cabal library
09:01:26 <dolio> If I had to guess wildly.
09:01:36 <RayNbow> dolio: ah ok
09:02:26 <Saizan> C-Keen: you should update cabal-install, via "cabal install cabal-install"
09:02:36 <C-Keen> Saizan: aye!
09:02:37 <dcoutts_> C-Keen: mm, I should make cabal check that the "Cabal-Version:" field is accurate. That package is using features that require Cabal-1.6
09:02:37 <Deewiant> dcoutts_: does Cabal have a version history somewhere?
09:02:46 <dcoutts_> Deewiant: in the changelog
09:02:55 <Deewiant> and where's that
09:03:11 <dcoutts_> in the darcs repo, announcement and the tarball
09:03:20 <Deewiant> but not in the user's guide?
09:03:33 <dcoutts_> it's the link next to the user guide
09:04:09 <dcoutts_> Deewiant: but I take your point, please file a ticket so we do not forget
09:04:31 <Deewiant> I see 'API', "User's Guide", and "pdf,ps" at http://www.haskell.org/cabal/ and only the user's guide in my local docs
09:04:32 <lambdabot> Title: The Haskell Cabal
09:04:56 <dcoutts_> Deewiant: ah, it's on the download page
09:05:07 <Deewiant> gah, well hidden :-P
09:05:28 <Deewiant> okay, so the problem is my foo == 0.* usage
09:05:52 <dcoutts_> Deewiant: and the globbing in the extra-source-files
09:05:54 <Deewiant> /and/ my wildcards in extra-source-files
09:06:16 <dcoutts_> though that would not actually cause a parse error
09:06:18 <Deewiant> dcoutts_: I guess I can't specify a directory in extra-source-files and have it use the contents
09:06:22 <C-Keen> dcoutts_: having cabal update itself would be nice if required
09:06:25 <dcoutts_> Deewiant: nope
09:06:36 <Deewiant> meh
09:06:39 <dcoutts_> C-Keen: indeed, though in this case it doesn't know that it needs to
09:06:53 <Deewiant> dcoutts_: want to link Cabal with Glob and have it support arbitrary Glob syntax? ;-)
09:07:05 <C-Keen> Deewiant: heh
09:07:38 <dcoutts_> Deewiant: so if you're filing tickets, we want two: one for the user guide to mention changes, the other for cabal check to complain about uses of new features without the cabal-version requiring a later version
09:07:45 <dcoutts_> Deewiant: heh, sorry no. :-)
09:08:02 <Deewiant> dcoutts_: alright, you can have two tickets
09:08:07 <dcoutts_> Deewiant: I deliberately went for a conservative glob syntax & semantics.
09:09:29 <Deewiant> dcoutts_: I gathered as much... still, it's a bit annoying for something like my case
09:09:35 <Deewiant> but, I'm going to eat now ->
09:10:04 <ski> > "Cannibal" \\ "Cabal"
09:10:05 <lambdabot>   "nni"
09:10:17 <Riastradh> Ni!
09:10:27 <dcoutts_> Deewiant: well, it's considerably less annoying than not having it at all! :-)
09:10:53 <dcoutts_> Deewiant: a more powerful glob would only save you two lines, and in some ways it makes it clearer to the reader what you're including.
09:11:22 <ski> (Are you saying Ni to that old woman ?)
09:11:34 <Riastradh> Ni!  Noo!  Noo!
09:12:15 <ski> (sorry, i was just thinking "cannibal" might perchance be a nice name for some cabal-related thingy ..)
09:12:49 * dcoutts_ is wearing his "fetchez la vache" t-shirt
09:13:17 <dcoutts_> ski: well it's a better name than franchise ;-)
09:13:22 <C-Keen> Ni!
09:14:19 <dcoutts_> for windows users cabal-install-0.6.0: http://haskell.org/~duncan/cabal/cabal.exe
09:14:36 <dcoutts_> for easier bootstrapping
09:14:49 <dcoutts_> since it can re-install later versions of itself, it should be all you need
09:22:55 <dolio> RayNbow: Specifically, having just looked at the code, when you modify an old copy of a DiffArray, it copies to a new array. So if you're doing that a lot, all you're doing is putting off the copying a little bit (and maybe saving one array's worth of space) while doing some additional shuffling with difference lists.
09:25:38 <RayNbow> dolio: ah, thanks :)
09:27:59 <mopped> Is there a simple graphing lib for haskell?
09:33:51 <dcoutts_> mopped: do you mean charts? or visualising graphs, as in directed graphs of nodes
09:37:28 <mopped> charts, plotting points
09:40:50 <papermachine> write system calls to gnuplot
09:40:58 <papermachine> who needs libraries
09:41:28 <mopped> (noobs like myself!)
09:41:36 <mopped> Is there a way to iterate only x times?@
09:41:47 <Deewiant> take x . iterate f
09:41:53 <quicksilver> > head . drop 9 . iterate (+1) $ 5
09:41:54 <lambdabot>   14
09:42:16 <quicksilver> > take 9 . iterate (+1) $ 5
09:42:18 <lambdabot>   [5,6,7,8,9,10,11,12,13]
09:42:22 <quicksilver> (whichever you prefer)
09:49:25 <morgoth> Is there a downloadable version of the ghc-library docs?
09:51:30 <Botje> i believe you can generate them from the ghc distribution
09:51:47 <Botje> oh, he's gone already. tsk tsk.
09:57:21 <mofmog> urgh, intrepid ibex refuses to install
09:58:35 * Cale installed it a couple weeks early :)
09:59:02 * ddarius never keeps up with Ubuntu releases.
09:59:26 <bos> ubuntu never keeps up with non-desktop upstream anyway.
09:59:45 <bos> it's always hopelessly behind on things that aren't flashy bling.
09:59:57 <ddarius> So I'm doubly behind.
09:59:59 <quicksilver> flashy bling = win!
10:00:15 <proq> bos: what distro keeps up better than ubuntu?
10:00:17 <Cale> Well, most things I don't mind, but its support for Haskell stuff is painful.
10:00:28 * ddarius just uses cabal install
10:00:47 <Cale> Right, me too. Also: binary builds of GHC.
10:00:53 <bos> proq: fedora, arch (notably), even debian testing is far better
10:00:56 <Cale> (generic linux binary)
10:01:39 <Cale> I used to run debian unstable. It's good, but I actually rather like ubuntu on the desktop side of things.
10:01:53 <mopped> > foldr (\x f -> x:[' ']:f) [] ["foo", "bar"]
10:01:54 <lambdabot>   ["foo"," ","bar"," "]
10:01:56 <Cale> (even though I use plain metacity)
10:02:07 <mopped> hmm
10:02:23 <mopped> > concat $ foldr (\x f -> x:[' ']:f) [] ["foo", "bar"]
10:02:24 <lambdabot>   "foo bar "
10:02:30 <mopped> is there a better way than that?
10:02:43 <Cale> > unwords ["foo", "bar"]
10:02:43 <Saizan> do you want the space at the end?
10:02:44 <lambdabot>   "foo bar"
10:02:49 <mopped> aha :P
10:02:55 <thoughtpolice> > concat $ intersperse " " $ ["foo","bar"]
10:02:57 <lambdabot>   "foo bar"
10:02:59 <mopped> No Saizan, so I guess i'd need a init aswell
10:03:46 <mofmog> > words "MAKE ME A LIST LAMBDABOT!"
10:03:47 <lambdabot>   ["MAKE","ME","A","LIST","LAMBDABOT!"]
10:03:50 <Cale> > concat . intersperse " " $ ["foo","bar"]
10:03:52 <lambdabot>   "foo bar"
10:03:59 <Cale> > intercalate " " $ ["foo","bar"]
10:04:01 <lambdabot>   "foo bar"
10:04:09 <mofmog> why not just use unwords
10:04:21 <mofmog> intercalate? ok now you're just making up words
10:04:38 <ddarius> @wn intercalate
10:04:39 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
10:04:39 <lambdabot> intercalate
10:04:39 <lambdabot>      v : insert (days) in a calendar
10:05:06 <mofmog> @wn joke
10:05:07 <lambdabot> *** "joke" wn "WordNet (r) 2.0"
10:05:07 <lambdabot> joke
10:05:07 <lambdabot>      n 1: a humorous anecdote or remark intended to provoke laughter;
10:05:07 <lambdabot>           "he told a very funny joke"; "he knows a million gags";
10:05:07 <lambdabot>           "thanks for the laugh"; "he laughed unpleasantly at
10:05:09 <lambdabot> [11 @more lines]
10:10:38 <dblazakis> with parsec, is there a way to fail a current parse? pzero doesn't seem to do what i want in the case of the choice combinator
10:10:43 <dblazakis> contrived example: (anyChar >>= (\c -> if c /= 'a' then pzero else return c)) <|> char 'b'
10:11:03 <EvilTerran> fail?
10:11:10 <Saizan> you want try, probably
10:11:26 <EvilTerran> ah, yes, that does look like it wouldn't backtrack correctly without try
10:11:43 <dblazakis> oh duh
10:11:44 <dblazakis> damn
10:11:52 <Saizan> ?hoogle satisfy
10:11:52 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
10:11:52 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
10:11:52 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
10:12:08 <dblazakis> i couldn't understand why the pzero wasn't working
10:12:10 <EvilTerran> ?hoogle char
10:12:10 <lambdabot> Text.Parsec.Char char :: Stream s m Char => Char -> ParsecT s u m Char
10:12:10 <lambdabot> Text.ParserCombinators.ReadP char :: Char -> ReadP Char
10:12:10 <lambdabot> Text.PrettyPrint.HughesPJ char :: Char -> Doc
10:12:13 <sbahra>     Could not find module `Text.PrettyPrint.HughesPJ':
10:12:13 <sbahra>       it is a member of package pretty-1.0.0.0, which is hidden
10:12:19 <sbahra> I've been getting this for a lot of packages...why?
10:12:33 <dblazakis> thanks
10:12:35 <Saizan> "satisfy (/= 'a') <|> char 'b'" should also work
10:12:45 <Saizan> err, ==
10:12:56 <EvilTerran> as would "char 'a' <|> char 'b'"
10:13:06 <sbahra> So I reinstalled pretty-, and I get undefined references.
10:13:21 <sbahra> Is there a way to "wipe" my local package repository and have it reinstall everything?
10:13:28 <sbahra> Easily.
10:13:44 <Saizan> sbahra: those packages haven't been updated to base-3 so they don't specify dependencies like pretty
10:14:12 <sbahra> Saizan, ok.
10:14:16 <sbahra> Saizan, so what should I do?
10:14:57 <Saizan> did you install pretty as user or global?
10:15:00 <sbahra> cabal: cannot configure HUnit-1.2.0.2. It requires base ==4.*
10:15:03 <sbahra> Saizan, both.
10:15:48 <Saizan> so you overwritten the original global pretty?
10:16:33 <sbahra> Yes.
10:16:44 <sbahra> Because the global pretty was "hidden"
10:16:51 <sbahra> Oh.
10:16:55 <sbahra> Saizan, I didn't "overwrite" it.
10:17:15 <sbahra> However, it had the same issues...(I did global first, had undefined reference issue so thought I would try user).
10:17:44 <Saizan> the "hidden" error is reported when a package doesn't specify all of its dependencies, reinstalling packages doesn't help
10:18:50 <sbahra> Hrm.
10:19:05 <Saizan> so, you should add pretty in the build-depends of those packages
10:19:14 <sbahra> These are on hackage.
10:19:35 <Saizan> yeah, not all the packages on hackage build on all the versions of ghc
10:19:44 <sbahra> nod
10:19:50 <sbahra> haskelldb is missing pretty.
10:22:43 <Saizan> http://www.haskell.org/haskellwiki/Cabal/FAQ <- this may be a cleaner explanation
10:22:45 <lambdabot> Title: Cabal/FAQ - HaskellWiki
10:22:56 <Saizan> "clearer
10:22:57 <Saizan> "
10:24:13 <mopped> Say I have Type Colour = [Integer, Integer, Integer], and a function takes a parameter of type Colour, would the parameter have to be explicity declared as a Color or does it only have to be of the form [Integer, Integer, Integer]
10:24:32 <ddarius> [Integer, Integer, Integer] is not a type.
10:24:52 <idnar> do you mean [Integer] or (Integer, Integer, Integer)?
10:25:32 <idnar> anyhow, in general, a "type" declaration means that the two types are equivalent; anywhere you see what's on the RHS, you can replace it with what's on the LHS
10:25:44 <quicksilver> mopped: a 'type' is really just a shortcut or a synonym
10:25:53 <quicksilver> it saves you a little typing or it may be useful documentation
10:25:58 <quicksilver> but it has no "power" in the type system.
10:25:59 <sbahra> Hrm, a lot of packages aren't building. :(
10:26:02 <quicksilver> I rarately use them.
10:26:04 <mopped> I mean [Integer]
10:27:18 <Philonous> mopped: If you want to distinguis between [Integer] and Colour use newtype. If you want them to be interchangeable use type.
10:28:05 <sbahra> Saizan, same problem, even though I have added it to build-depends.
10:28:24 <sbahra> Setup.lhs: /usr/local/lib/Cabal-1.6.0.1/ghc-6.8.3/HSCabal-1.6.0.1.o: unknown symbol `prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl18_closure'
10:28:48 <sbahra> Now I have to think. :(
10:29:16 <Saizan> sbahra: oh, adding to build-depends will solve the "pretty is hidden" error, for the unknown symbol you have to recompile dependent packages against the new pretty you've installed
10:29:28 <Saizan> in this case this means rebuilding Cabal
10:29:43 <sbahra> hahaha
10:30:37 <Saizan> since building a package doesn't necessarily always export the same low-level symbols
10:31:05 <quicksilver> the fact that GHC doesn't *really* do separate compilation leaks out ;)
10:31:15 <sbahra> quicksilver, nod
10:31:18 <int-e> sbahra: uhm, does ghc --make Setup.lhs work?
10:31:45 <sbahra> I'll find out after Cabal recompiles.
10:32:53 <tromp__> :t > foldl
10:32:54 <lambdabot> parse error on input `>'
10:33:00 <tromp__> :t foldl
10:33:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:33:04 <vegai> does anyone have experience in teaching Haskell to average programmers in a business environment? Is there any hope?
10:33:11 <tromp__> > foldl f z [a,b,c]
10:33:13 <lambdabot>   f (f (f z a) b) c
10:33:58 <tromp__> > foldl (flip (:)) [] [a,b,c]
10:34:00 <lambdabot>   [c,b,a]
10:35:33 <sbahra> Hrm.
10:35:41 <sbahra> Is there an SQL library you guys recommend?
10:37:04 <jmelesky> vegai: there's always hope
10:37:11 <mopped> I've got a simple function that 'pads' out a list, such that if a list has 3 items, it would add another two items; if it has 2, adds another 3. The problem I'm having is the function adds one item even if the list has 5 items
10:37:22 <mopped> mkImg x y l = l ++ [[0, 0, 0] | x <- [0..t]] where t = x*y - (length l)
10:37:29 <vegai> jmelesky: but experience? :)
10:37:42 <sbahra> int-e, no, btw
10:38:00 <vegai> I suppose it might be interesting to be the first to try... if I didn't have mortgage...
10:38:06 <jmelesky> not practical experience. i've shown people haskell code and they've understood it, but adoption was nil
10:38:40 <sam___> What is alpha ekvivalent in Haskell?
10:39:03 <quicksilver> "add x = x+1" means the same thing as "add y = y + 1"
10:39:32 <quicksilver> sam___: that's what alpha equivalance means. that variable names can be changed without affecting the program
10:39:56 <sam___> quicksilver: thanks!
10:40:06 <quicksilver> jmelesky, vegai : to get people to adopt something and move away from something they are familiar with, you have to make it possible for them to do so in baby steps
10:40:15 <quicksilver> and each of those steps has to be "obviously an improvement"
10:40:29 <quicksilver> well, either that or threaten to break their fingers.
10:40:40 <vegai> haha
10:41:27 <lilac> mopped: mkImg x y l = take (x*y) $ l ++ repeat [0,0,0]
10:41:45 <jmelesky> quicksilver: agreed. i've not been in a position where it's made much business sense to switch, so i haven't made much effort
10:43:02 <mopped> nice, thanks
10:44:41 <lilac> mopped: your version is right, except that it's always off by one (not just when length l == x * y)
10:46:46 <Baughn> p_l: Right, that's four. Or was it five?
10:49:30 <profmakx> is haskell.org down?
10:49:41 <Baughn> No
10:49:57 <sam___> I have the following structure: λx y. y y (x λx. x y) x ; I do not know: Which variable does each abstraction binds in this lambda sequence?
10:50:48 <int-e> mmm http://downforeveryoneorjustme.com/q?domain=haskell.org
10:50:50 <lambdabot> Title: Huh?
10:52:05 <int-e> heh, downforeveryoneorjustme is broken.
10:52:29 <profmakx> hm. hackage.haskell.org is unreachable for me...
10:53:00 <profmakx> hmm
10:53:05 <profmakx> i will slap my isp
10:53:33 <p_l> Baughn: You mean the number of people from #nanoha being here?
10:54:09 <sbahra> Saizan, strange, I still get a similar error.
10:54:17 <Baughn> p_l: Yep
10:54:21 <sbahra> Saizan, well, relevant.
10:54:31 <Baughn> p_l: Conquering the world for haskell, one person at a time
10:54:40 <sbahra> /usr/local/lib/ghc-6.8.3/lib/Cabal-1.2.4.0/libHSCabal-1.2.4.0.a(PackageDescription__616.o)(.text+0x1fc): ...
10:54:48 <quuxman> p_l: which server is #nanoha on, and what's the channel about?
10:54:57 <p_l> Baughn: then you should go after murklins and Syao, cause they both want to learn, they simply don't have anyone to supervise them
10:55:19 <sbahra> pretty-related
10:55:27 <Saizan> sbahra: so, Cabal-1.2.4.0 is another package that was built against the old pretty
10:56:01 <sbahra> Saizan, but I installed a local Cabal, 1.6...
10:56:11 <sbahra> Saizan, and HDBC compiled fine against this.
10:56:28 <sbahra> Saizan, this was a user installation, I did the same for HDBC-postgresql.
10:56:42 <p_l> quuxman: Officially it's about an anime series, unofficially you there is SCIENCE, politics and all other stuff, in between general talk
10:56:50 <lilac> sam___: \x y -> y y (x \x -> x y) x == \x y -> y y (x \z -> z y) x
10:56:54 <p_l> s/you there/there/
10:56:59 <sbahra> Ah.
10:57:12 <Saizan> sbahra: when do you get that error? maybe the package you're compiling requires Cabal 1.2, or you're doing a global install this time
10:57:16 <quuxman> p_l: cool. Which network?
10:57:17 <Baughn> quuxman: Rizon, of course. I spend a lot of time evangelizing haskell there, too. :P
10:57:30 <lilac> @pl \x y z -> z y
10:57:31 <lambdabot> const (flip id)
10:57:36 <sbahra> Saizan, no, it's a user install
10:57:40 <sbahra> Saizan, configure stage
10:57:44 <lilac> @let nothingHappens = const (flip id)
10:57:46 <lambdabot>  Defined.
10:58:03 <quuxman> Baughn: of course? Never heard of Rizon
10:58:15 <sam___> lilac: Thanks! Your answer seems to make sense
10:58:33 <Saizan> sbahra: whcih package? and which command are you using exactly?
10:58:35 <Baughn> quuxman: Most fansubbing groups seem to use rizon, which means most anime-related chat in general tends to end up there
10:59:22 <Saizan> sbahra: or you may just unregister Cabal-1.2.4.0 and see what happens, that package is screwed anyway
10:59:37 <sbahra> Saizan, http://hpaste.org/11648
11:00:52 <sbahra> Apparently it requires Cabal 1.2.*
11:00:59 <Saizan> yeah, Cabal-Version: >=1.2 && < 1.3
11:01:13 <sbahra> hmm
11:01:13 <Saizan> that's why it can't use your 1.6
11:01:19 <sbahra> I doubt it really does *need* it
11:01:22 <sbahra> I'll update the package
11:01:47 <Saizan> ah, yeah, you can try that :)
11:10:41 <sam___> lilac: Does this mean: \x y -> y y ; that \y binds both y's?
11:11:29 <vixey> :t \x y -> y y
11:11:30 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
11:11:30 <lambdabot>     Probable cause: `y' is applied to too many arguments
11:11:30 <lambdabot>     In the expression: y y
11:12:36 <dolio> :t \x (y :: forall a. a -> b) -> y y
11:12:37 <lambdabot>     A pattern type signature cannot bind scoped type variables `b'
11:12:37 <lambdabot>       unless the pattern has a rigid type context
11:12:37 <lambdabot>     In the pattern: y :: forall a. a -> b
11:12:50 <dolio> :t \x (y :: forall a. a -> Int) -> y y
11:12:52 <lambdabot> forall t. t -> (forall a. a -> Int) -> Int
11:14:15 <vixey> :t \x (y :: forall a. a -> a) -> y y
11:14:17 <lambdabot> forall t a. t -> (forall a1. a1 -> a1) -> a -> a
11:14:34 <vixey> :t (\(u :: forall a. a -> a) -> u u) (\(u :: forall a. a -> a) -> u u)
11:14:35 <lambdabot>     Couldn't match expected type `forall a1. a1 -> a1'
11:14:35 <lambdabot>            against inferred type `a -> a'
11:14:35 <lambdabot>     In the first argument of `(\ (u :: forall a. a -> a)
11:19:41 <cads> man, C could make a grown man Cry
11:19:49 <lilac> @@ @unpl @pl \x y -> y y
11:19:49 <lambdabot>  (\ _ -> (\ b -> b) >>= \ c -> c)
11:20:00 <vixey> @@ @unpl @pl (\ _ -> (\ b -> b) >>= \ c -> c)
11:20:01 <lambdabot>  (\ _ -> (\ b -> b) >>= \ c -> c)
11:20:03 <vixey> @@ @unpl @pl (\ _ -> (\ b -> b) >>= \ c -> c)
11:20:03 <lambdabot>  (\ _ -> (\ b -> b) >>= \ c -> c)
11:20:19 <vixey> does anything diverge on @@ @unpl @pl
11:21:10 <lilac> @meta-qcheck @@ @unpl @pl @unpl @pl x == @@ @unpl @pl
11:21:11 <lambdabot> Unknown command, try @list
11:26:45 * EvilTerran notes that (\x -> x x) :: (mu a. a -> b) -> b, and i don't think this can be expressed in lambdabot
11:27:07 <vixey> what' mu ?
11:27:13 <EvilTerran> fixed-point
11:27:32 <dolio> @type (\x -> x x) :: (forall a. a -> b) -> b
11:27:34 <lambdabot> forall b. (forall a. a -> b) -> b
11:27:50 <EvilTerran> dolio, yes, but you can't then apply that to itself
11:27:56 <vixey> oh (Mu (-> b))
11:27:58 <dolio> Right.
11:28:23 <vixey> I'm not sure if that makes sense
11:30:52 <lilac> is there a flip for type constructors?
11:32:59 <dolio> @kind Flip
11:33:00 <lambdabot> Not in scope: type constructor or class `Flip'
11:33:23 <dolio> Looks like no.
11:33:47 <rwbarton> lilac: Not really.  You could define a type synonym  type Flip a b = b a,  but since you (usually) can't partially apply it, it's not very useful...
11:34:08 <vixey> why can't type synonyms be partially applied?L
11:34:20 <Deewiant> they can be
11:34:58 <dolio> Because the people who defined Haskell didn't want arbitrary type-level lambdas running around.
11:35:05 <sam___> What is the result of this sequence: (λx y. x (x y)) (λx y. x (x y)) (λx y z. y) ?  I got an empty set, but I do not know is  it correct.
11:35:34 <vixey> sam__: that didn't make sense..
11:36:03 <sam___> vixey: Could you explain why?
11:36:22 <vixey> that doesn't look like a sequence and I don't know where empty set could have come from
11:37:17 <Deewiant> ?ty (\x y -> x (x y)) (\x y -> x (x y)) (\x y z -> y)
11:37:19 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> t1 -> t
11:37:26 <Deewiant> ;-P
11:37:33 <sam___> vixey: I mean with empty set that the formula ends up nothing when it is beta reduced
11:37:36 <rwbarton> @pl  (\x y -> x (x y)) (\x y -> x (x y)) (\x y z -> y)
11:37:37 <lambdabot> join (.) (join (.)) (const const)
11:37:47 <vixey> sam__: that didn't make sense either..
11:37:54 <vixey> sam__: Do you mean "diverges"?
11:38:08 <EvilTerran> ?type let (?) = appEndo.out in (?)
11:38:10 <lambdabot> Mu Endo -> Mu Endo -> Mu Endo
11:38:12 <dolio> Anyhow, you can write 'newtype Flip f a b = Flip (f b a)' and partially apply that. It just takes some wrappers.
11:38:13 <EvilTerran> ehehehe
11:38:39 <sam___> vixey: I do not mean diverges. I mean the result when the formula is reduced
11:39:01 <vixey> sam__: well lambda terms reduce to lambda terms and they aren't sets, so I still don't understand you
11:39:24 <EvilTerran> ?type let (?) = appEndo.out in \x -> x ? x
11:39:26 <lambdabot> Mu Endo -> Mu Endo
11:39:50 <sam___> vixey: I see. Then, the formula must reduce to lambda terms.
11:40:12 <vixey> sam__: Do you have a calculation that ended up with empty set? I'd like to see that
11:40:29 <EvilTerran> ?type let (?) = appEndo.out in In . Endo $ \x -> x ? x
11:40:30 <lambdabot> Mu Endo
11:41:03 <EvilTerran> ?type let (?) = appEndo.out; u = In $ Endo (\x -> x ? x) in (u, u ? u)
11:41:04 <lambdabot> (Mu Endo, Mu Endo)
11:41:11 <sam___> vixey: I have a result which ends up nothing that is no variable is left.
11:41:14 <EvilTerran> i win!
11:41:51 <vixey> so can you paste this calculation or something ?
11:41:52 <EvilTerran> it seems that Mu Endo is the closest approximation lambdabot has to (forall b. Mu (Flip (->) b))
11:43:14 <sam___> vixey: I try to scan my tree which I make about the formula and paste it. It has the relations in it
11:43:24 <dolio> Someone should bug Cale to add Flip.
11:43:46 <vixey> , Mu
11:43:58 <lunabot>  luna: Not in scope: data constructor `Mu'
11:43:59 <dolio> , src ''Flip
11:44:26 <lunabot>  newtype Flip p a b = Flip {runFlip :: (p b a)}
11:44:38 <EvilTerran> , In
11:44:43 <lunabot>  luna: Not in scope: data constructor `In'
11:45:15 <rwbarton> , src ''Fix
11:45:15 <EvilTerran> , src ''Fix
11:45:22 <EvilTerran> heh
11:45:34 <lunabot>  newtype Fix s a = InB {outB :: (s a (Fix s a))}
11:45:39 <dolio> , let w = \x -> runFlip (out x) x ; omega = w (In (Flip w)) in 5
11:45:48 <EvilTerran> 'B'?
11:45:52 <lunabot>  newtype Fix s a = InB {outB :: (s a (Fix s a))}
11:45:57 <lunabot>  luna: Not in scope: `out'
11:46:52 <EvilTerran> , runFlip . outB
11:46:58 <lunabot>  luna: No instance for (GHC.Show.Show
11:47:33 <dolio> , let w x@(InF x') = runFlip x' x ; omega = w (InF (Flip w)) in 5
11:47:39 <lunabot>  5
11:47:44 <EvilTerran> , InB . Flip
11:47:50 <lunabot>  luna: No instance for (GHC.Show.Show
11:48:46 <EvilTerran> , src 'InF
11:49:05 <lunabot>  newtype FixF f = ... | InF (f (FixF f)) | ...
11:49:05 <lunabot>  infixl 9
11:49:09 <mauke> % ./main 'let fac n = if is-zero n then 1 else mul n (fac (pred n)) in fac 5'
11:49:09 <mauke> ((\fac -> (fac (succ (succ (succ (succ (succ false))))))) (fix (\fac -> (\n -> ((((if_ (is-zero n)) (\_ -> (succ false))) (\_ -> ((mul n) (fac (pred n))))) id)))))
11:49:13 <mauke> 120
11:49:23 <EvilTerran> , src 'FixF
11:49:28 <lunabot>  luna: Not in scope: data constructor `FixF'
11:49:32 <EvilTerran> , src ''FixF
11:49:40 <dolio> lunabot is sluggish.
11:49:50 <lunabot>  newtype FixF f = InF {outF :: (f (FixF f))}
11:50:19 <sam___> vixey: I do not get my scanner work. Nevertheless, is it possible to get from that formula nothing as a result after reduction?
11:50:33 <vixey> sam__, can't you type it?
11:51:07 <rwbarton> sam___: what do you mean "nothing"?  The empty string of symbols?  What reduction rule could possibly produce that?
11:51:25 <vixey> I want to actually see the derivation
11:51:51 <Deewiant> sam___: what's your next-to-last step
11:52:01 <Deewiant> or state, rather
11:52:15 <vixey> can you just post the whole derivation actually
11:53:00 <sam___> I will do that: it will post it soon
12:05:54 <sam___> vixey: rwbarton: Deewiant : Here are the methods: http://pastebin.com/m5284380
12:36:37 --- mode: ChanServ set +o Cale
12:36:39 --- mode: Cale set -b *!*@jolt.modeemi.cs.tut.fi
12:37:07 <flux> whee
12:37:17 <flux> cale, thank you
12:37:33 --- mode: Cale set +b *!*tuomov@jolt.modeemi.cs.tut.fi
12:37:39 <Cale> That should work better :)
12:37:42 --- mode: Cale set -o Cale
12:37:47 <flux> yes, I prefer that :)
12:38:20 <flux> quite a long ban list on the channel, actually, but perhaps they are never cleaned up :)
12:38:36 <vegai> heh, here too?
12:38:53 <Deewiant> tuomov has been flaming here?
12:39:44 <Feuerbach> http://www.cse.unsw.edu.au/~dons/code/irc-logs/07.12.03
12:39:48 <Cale> Yeah, he was causing trouble the other day. He wouldn't stop whining about operating systems.
12:40:21 <lispy> tuomov can be quite vocal
12:40:30 <Deewiant> ah right, I remember actually
12:40:41 <Deewiant> I just accidentally wiped my logs of the past week so a grep didn't find it
12:40:52 <SamB_XP> does any of us stop whining about operating systems ?
12:41:02 <Deewiant> when threatened with a ban, yes :-P
12:42:24 <BONUS> BUT BUT
12:42:27 <BONUS> OPEN SOURCE CONSPIRACY
12:42:49 <lispy> open source you a cospiracy for great good?
12:43:00 <BONUS> i'm already working on it!
12:43:02 <lispy> :)
12:43:19 <lispy> BONUS: it's nice BTW.  Keep up the good work :)
12:43:26 <BONUS> haha thanks
12:43:39 <lispy> BONUS++
12:43:45 <mauke> preflex: karma BONUS
12:43:45 <preflex>  karma for BONUS: 2
12:43:52 <mauke> BONUS++
12:44:02 <BONUS> yeah i'm a bit tight with time right now but work on the next chapter is being done, no worry
12:44:04 <BONUS> :]
12:44:18 <lispy> no rush, quality is important
12:44:33 <BONUS> yeah
12:49:30 <BONUS> @pl (\x y -> not x || y)
12:49:31 <lambdabot> (||) . not
12:51:47 <BONUS> man i love using sequence on the list monad
12:51:59 <BONUS> > sequence $ replicate 4 [True, False]
12:52:00 <lambdabot>   [[True,True,True,True],[True,True,True,False],[True,True,False,True],[True,...
12:52:12 <mauke> > replicateM 3 [True,False]
12:52:13 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
12:52:22 <Cale> > filterM (const [True,False]) [1,2,3,4]
12:52:23 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
12:52:45 <grul> > "wut"
12:52:47 <lambdabot>   "wut"
12:53:12 <camio> Anyone know of something like hasktags, but actually does a good job creating a tag file?
12:53:31 <Cale> > unwords . map (concatMap show) . filterM (const [True,False]) $ [1,2,3,4]
12:53:32 <lambdabot>   "1234 123 124 12 134 13 14 1 234 23 24 2 34 3 4 "
12:53:34 <BONUS> > replicateM ["Ww","Oo0","Oo0","t+T"]
12:53:35 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
12:54:05 <BONUS> > sequence ["Ww","Oo0","Oo0","t+T"]
12:54:06 <lambdabot>   ["WOOt","WOO+","WOOT","WOot","WOo+","WOoT","WO0t","WO0+","WO0T","WoOt","WoO...
12:54:15 <BONUS> keke
12:56:48 <sjanssen> @elite woot
12:56:48 <lambdabot> \/\/0O+
12:57:35 <conal> wchogg: thanks for the tip about graphicsFormats missing from hackage.  i'll zap it over there.
12:58:39 <hukolele> which is the problem if i get a Setup.o(.data+0x18):fake: undefined reference to `DistributionziSimple_defaultMa... error??
12:58:53 <hukolele> i cant compile anything... =?
12:59:23 <hukolele> i tryed with ghc reinstalling but no luck
13:00:39 <BONUS> oh man
13:00:46 <BONUS> you just gotta compile with --make
13:01:35 <BONUS> if you have a file called blah.hs
13:01:37 <BONUS> just do
13:01:40 <BONUS> ghc --make blah
13:02:12 <hukolele> oh, thx, it works =)
13:02:26 <hukolele> dunno why, but works
13:02:39 <BONUS> it has to do with linking and such
13:02:45 <BONUS> that had me baffled for a long time at first too
13:02:53 <hukolele> lol
13:02:54 <BONUS> cause the error message is basically just a bunch of nonsense
13:03:04 <hukolele> i agree
13:03:08 <Deewiant> basically ghc --make just figures out what libraries need to be linked in
13:03:24 <Deewiant> if you don't use it, you have to specify them by hand, but nobody does that :-P
13:03:28 <BONUS> like when you import stuff
13:03:41 <hukolele> haha
13:04:23 <Cale> Well, cabal packages specify them directly.
13:05:06 <Deewiant> for different reasons, though
13:05:41 <Cale> Well, partly the same reason.
13:05:49 <Deewiant> and not for non-haskell libraries
13:06:07 <Deewiant> usually a configure script does that (and gets it wrong on Windows)
13:06:23 <wchogg> conal:  Not a problem.  Also, it looks like the interface for reactive .83 has changed a good bit from 0.5.  Is there a canonical way to migrate code that I had working with the old version?
13:07:32 <conal> wchogg: oh, oops.  i don't have a migration guide.  if you send me some examples, i can probably help.
13:10:36 <conal> wchogg: graphicsFormats now on hackage: http://hackage.haskell.org/packages/archive/recent.html
13:10:39 <lambdabot> Title: HackageDB: recent additions
13:13:56 <wchogg> conal:  Thank you!
13:14:28 <conal> wchogg: i really appreciate all your help in fixing these details i miss.
13:21:27 <wchogg> conal:  Oh, it's no problem.  I do have a quick question though:  so FRP.Reactive doesn't seem to export mkEvent anymore.  So how should I be creating my instances of Event now?  I want to make my example from my blog about a simple chat server work again.
13:22:44 <conal> wchogg: it's exported in a different module.  the new package reactive-glut shows how to make adapters to reactive.  i'd be happy to work with you on making an adapter that suits you.
13:23:17 <conal> wchogg: doing so may point to usability improvements.
13:25:00 <wchogg> conal:  Cool, I'll look at it.
13:28:29 <conal> wchogg: the adapter stuff is brand new.  there's likely room for improving at least the packaging.  suggestions always welcome.
13:29:52 <dancor> 4lols: what is the coolest way to write f (x, y) = [x, y]
13:31:19 <rwbarton> > (:) <$> fst <*> ((:[]) <$> snd) $ (5,6)
13:31:21 <lambdabot>   [5,6]
13:31:22 <Deewiant> > (uncurry ((>>>) (:) (return >>>))) (3,4)
13:31:24 <lambdabot>   [3,4]
13:31:47 <rwbarton> > sequence [fst, snd] $ (5, 6)
13:31:48 <lambdabot>   [5,6]
13:32:01 <Deewiant> that's pretty cool
13:32:19 <alar> does anybody know the author of Data.PriorityQueue?
13:32:41 <Deewiant> James Cook? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/priority-queue
13:32:48 <lambdabot> Title: HackageDB: priority-queue-0.1, http://tinyurl.com/57jnrc
13:32:50 <alar> yes
13:33:05 <Deewiant> looks like it's mokus, who's been idle for a week
13:33:29 <alar> @seen mokus
13:33:30 <lambdabot> mokus is in #haskell. I don't know when mokus last spoke.
13:33:36 <alar> ok
13:33:37 <mauke> preflex: seen mokus
13:33:37 <preflex>  mokus was last seen on #haskell 7 days, 21 hours, 55 minutes and 42 seconds ago, saying: SamB_XP: or "which of these 35 howtos is actually helpful"
13:33:44 <alar> I'll try to reach him by email
13:37:55 <alar> @bot
13:37:55 <lambdabot> :)
13:38:04 <alar> preflex: bot
13:38:05 <preflex>  yes.
13:39:09 <Deewiant> preflex: human
13:39:17 <Deewiant> guess not
13:39:19 <Cale> preflex: what
13:42:06 <dobblego> what is a reasonable demonstration  usage for (>>=) on ((->) t) ?
13:42:46 <dobblego> or perhaps liftMX for((->) t)
13:42:48 <vixey> @seen sam___
13:42:49 <lambdabot> I saw sam___ leaving #haskell 1h 24m 12s ago, and .
13:43:03 <mauke> > liftM2 h f g x
13:43:04 <lambdabot>   Add a type signature
13:43:09 <mauke> > liftM2 h f g x :: Expr
13:43:10 <lambdabot>   Add a type signature
13:43:11 <vixey> dobblego: I try to use Applicative instead of Monad for ((->) t{
13:43:12 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
13:43:13 <lambdabot>   ("hello","olleh","HELLO")
13:43:14 <mauke> :-(
13:43:35 <Cale> > liftM3 (,,) id reverse (map toUpper) "hello"
13:43:36 <lambdabot>   ("hello","olleh","HELLO")
13:43:44 <Saizan> > (liftM2 (==) id reverse) "abba"
13:43:45 <lambdabot>   True
13:44:14 <vixey> :t sequence [id]
13:44:16 <lambdabot> forall a. a -> [a]
13:44:19 <idnar> dobblego: liftM is function composition
13:44:19 <mauke> > liftM2 (++) reverse show "hi"
13:44:21 <lambdabot>   "ih\"hi\""
13:44:25 <vixey> :t sequence [id, reverse, map toUpper] "hello"
13:44:27 <lambdabot> [[Char]]
13:44:31 <idnar> @type liftM (+5) (*2)
13:44:32 <lambdabot> forall a. (Num a) => a -> a
13:44:33 <dobblego> idnar, yes, but it does not use (>>=)
13:44:35 <idnar> > liftM (+5) (*2) 10
13:44:37 <lambdabot>   25
13:44:43 <vixey> @src liftM
13:44:46 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:45:20 <dobblego> theoretically that is; I mean liftMX for some X > 1
13:46:07 <idnar> liftM2 is a bit weird
13:46:22 <vixey> @src liftM2
13:46:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:46:31 <idnar> @unpl liftM2 (+)
13:46:31 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b + a))
13:46:39 <idnar> @unpl liftM2 (+) (+5) (*2)
13:46:39 <lambdabot> ((\ f -> f + 5) >>= \ b -> (\ g -> g * 2) >>= \ a -> return (b + a))
13:46:43 <idnar> no
13:46:45 <idnar> bah
13:46:52 <idnar> > liftM2 (+) (+5) (*2) x
13:46:54 <lambdabot>   x + 5 + x * 2
13:47:23 <idnar> > liftM2 (+) (*3) (*2) x
13:47:24 <lambdabot>   x * 3 + x * 2
13:47:27 <Cale> > liftM2 (*) (+1) (+2) x
13:47:29 <lambdabot>   (x + 1) * (x + 2)
13:47:50 <idnar> > (+2) >>= f $ x
13:47:51 <lambdabot>   Add a type signature
13:47:54 <idnar> > (+2) >>= f $ x :: Expr
13:47:55 <lambdabot>   f (x + 2) x
13:49:01 <alar> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/priority-queue-0.1
13:49:03 <lambdabot> Title: HackageDB: priority-queue-0.1, http://tinyurl.com/627pba
13:49:34 <alar> cabal install priority-queue says "no such package"
13:49:35 <dobblego> thanks for the responses
13:49:41 <alar> what am I doing wrong?
13:49:42 <Cale> alar: cabal update?
13:50:09 <alar> @karma+ Cale
13:50:09 <lambdabot> Cale's karma raised to 8.
13:50:14 <alar> thanks!
13:50:54 <Cale> no problem :)
13:51:01 <mauke> preflex: karma Cale
13:51:01 <preflex>  karma for Cale: 24
13:51:24 <alar> =))
13:51:28 <alar> 2 karmas
13:51:36 <alar> 2 reincarnations =)))
13:51:46 <alar> 2 cales in next life
13:52:11 <Cale> karmic bifurcation
13:53:03 <SamB_XP> fractalses ?
14:12:36 <lispy> okay, will someone write a nice robust kernel in Haskell for the SIP protocol?
14:12:43 <lispy> kthxbai
14:13:20 <sjanssen> @djinn IO SIP
14:13:20 <lambdabot> Error: Undefined type IO
14:13:39 <vixey> lol
14:13:57 <sjanssen> @djinn sip
14:13:58 <lambdabot> -- f cannot be realized.
14:15:55 <lispy> instance Monad VideoChat where ...
14:16:11 <lispy> http://en.wikipedia.org/wiki/Session_Initiation_Protocol
14:16:12 <lambdabot> Title: Session Initiation Protocol - Wikipedia, the free encyclopedia
14:17:03 <lispy> Really I just want ekiga/xmeeting to stop crashing every 10 minutes when I use it
14:17:36 <SamB_XP> lispy: well, grep the source for 10 and replace it with the desired number of minutes
14:18:11 <lispy> SamB_XP: oh, maybe I could make it a run-time parameter
14:19:01 <C-Keen> ekiga --crash-interval=10
14:23:17 * C-Keen learned just about Language.C
14:23:26 <C-Keen> this could actually make my work easier!
14:23:32 <C-Keen> thanks
14:23:40 * vixey noses in
14:23:48 <vixey> what is it you are to do with Language.C? :)
14:23:51 <lispy> C-Keen: oh, what are you working on that Lanuage.C is helpful?
14:23:55 <vixey> ahaha
14:24:20 <kaizoku> Oh, that looks interesting
14:24:41 <C-Keen> lispy: I have to verify code standard comliance, which is currently done with a flaky tool that crashes every now and then
14:25:13 <lispy> yes, that's a very good use of Language.C
14:25:16 <lispy> rock on
14:25:20 <lispy> hackage early and often :)
14:25:30 <vixey> what is  code standard comliance ?
14:25:31 <C-Keen> I need xdias compliance checks
14:25:46 <vixey> stuff like.. you have indented the code correctly, and never used return twice in a function body .. ?
14:26:34 <C-Keen> vixey: no stuff like type names and function names have a certain structure, there are certain functions implemented for each module etc..
14:26:35 <badsheepy> thats quite a harsh rule :o
14:26:46 <vixey> oh I see
14:27:01 <vixey> cool, static analysis!
14:27:06 <kaizoku> Gahh, that blog post linked from the site is hard to understand XD
14:27:10 <C-Keen> vixey: so I need basically a nice to use C parser :)
14:27:11 <vixey> which post?
14:27:12 <daf> C-Keen: I've been thinking about using it
14:27:17 <kaizoku> The one in Japanese
14:27:23 <daf> C-Keen: I'd be interested to know how you got on
14:27:33 <C-Keen> daf: using Language.C?
14:27:36 <daf> C-Keen: yes
14:27:56 <daf> the main problem I saw was outputtin the modified code using the style you prefer
14:28:24 <C-Keen> daf: I will have a closer look next week and tell you what I found out
14:29:45 <daf> C-Keen: cool :)
14:31:45 <gwern> @seen dons
14:31:46 <lambdabot> dons is in #concatenative, #darcs, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 22m 45s ago.
14:31:52 <gwern> bah
14:32:36 <gwern> @ask dons I noticed that http://haskell.org/haskellwiki/Xmonad/Config_archive/Don's_xmonad.hs differs slightly from the xmonad.hs you sent me a little bit ago. do you want to update? I could, while I'm at the wiki-editing
14:32:36 <lambdabot> Consider it noted.
14:33:22 <noZone> Is there a way to instruct "do" to employ ">>=" instead of ">>" by default? (this noob: me, may not be asking a question that makes sense  so....)
14:34:07 <wchogg> @seen conal
14:34:08 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 1h 5m 38s ago.
14:34:44 <rwbarton> noZone: Maybe... why would you want to do that though?  (can you give an example?)
14:35:12 <dons> gwern: go for it
14:35:12 <lambdabot> dons: You have 9 new messages. '/msg lambdabot @messages' to read them.
14:35:43 <noZone> I want to string together a bunch of expressions that pass monadic values to one another w/o using "x <- blah" notation
14:35:46 <conal> wchogg: hi
14:35:53 <gwern> dons: 'k
14:36:18 <conal> wchogg: i just pushed new reactive & reactive-glut with a simplified export/import for building adapters.
14:36:19 <dons> wchogg: visiting porltand i see?
14:38:10 <rwbarton> noZone: I don't think there's any way to have do { x ; y ; z } turn into x >>= y >>= z, if that's what you mean
14:38:23 <noZone> yes... that's it.
14:38:42 <wchogg> dons:  Yes.  I'm applying for the phd program for next year.
14:38:46 <rwbarton> Well, maybe..... but it would involve unspeakable evil
14:38:53 <Peaker> noZone: you know you can newline after every >>= ?
14:39:14 <noZone> I didn't think there was a way, but you clever folks usually know something I don't.
14:39:17 <dons> wchogg: cool. pdx is fast becoming haskell central.
14:39:34 <dons> wchogg: you could drop by galois, we've a few reactive fans , if that's what you're doing these days
14:39:37 <noZone> Peaker: yeah, but I wanted something cleaner.
14:39:52 <gwern> @seen nomeata
14:39:52 <lambdabot> I saw nomeata leaving #xmonad, #haskell and #darcs 21h 58m 45s ago, and .
14:40:01 <Peaker> noZone: why is ; or \n cleaner than >>=\n ?
14:40:52 <noZone> Well, probably for the same reason that \n is cleaner than >>\n?
14:40:53 <gwern> @tell nomeata btw, your listed xmonad config on the wiki is still 0.4 so I moved you to the 'old' section
14:40:53 <lambdabot> Consider it noted.
14:41:38 <Peaker> noZone: do saves more than a few >> signs
14:41:49 <wchogg> dons:  Well if I get accepted I'll probably have plenty of reason to talk to lads from Galois.  From what I understand, the project I'm looking at joining has ties to the company via Iavor.
14:41:52 <noZone> Yes, true enough.
14:42:02 <gwern> iavor?
14:42:30 * gwern looks at goerzen's xmonad.hs. ick: 'xmproc <- spawnPipe "/path/to/xmobarbinary /home/jgoerzen/.xmonad/xmobar"'
14:42:39 <noZone> I was just looking for a different flavour of "do"... maybe "sooperDo".  ;)
14:42:55 <gwern> scoobyDo
14:43:00 <noZone> yeah!
14:43:10 <dons> wchogg: ah i c.
14:43:23 <rwbarton> noZone: If the values you're passing through >>= are all the same type, you could instead have that stored in the monad as "state"
14:43:26 <gwern> 'do stuff `catch` (anotherScoobySnack >> stuff)'
14:43:43 * dons encourages lots of phd students to come to psu. 
14:43:53 <dons> we might reach critical mass
14:44:46 <wchogg> dons:  I don't suppose you guys are having an open talk at Galois between Nov 19th -21st?
14:45:10 <noZone> dons: ... and ride bicycles on the last Friday of each month?
14:45:25 <wchogg> noZone:  wat?
14:46:01 * gwern is impressed how big byorgey's xmonad.hs is!
14:46:16 <noZone> http://en.wikipedia.org/wiki/Critical_Mass
14:46:17 <lambdabot> Title: Critical Mass - Wikipedia, the free encyclopedia
14:46:28 <wchogg> for some pronunciations of "monad", that seems a more disturbing statement.
14:46:43 <gwern> @tell byorgey I am hurt - why didn't you send a patch for your hackage Search plugin? :( I'll do it meself I guess
14:46:43 <lambdabot> Consider it noted.
14:47:39 <dons> wchogg: looking...
14:48:04 <dons> wchogg: 18th and 25th
14:48:19 <wchogg> Damn!  Ah well.
14:48:23 <dons> noZone: riding bicycles is compulsory
14:48:32 <noZone> lol
14:49:24 <wchogg> But yeah, Mark Jones & co. are one of the only groups that does what I'm really passionate about.  So I'm really excited to meet them.
14:54:48 <gwern> @seen glguy
14:54:48 <lambdabot> glguy is in #haskell. I last heard glguy speak 2d 15h 12m 6s ago.
14:55:17 <gwern> @tell glguy both of your xmonad configs on the wiki don't work with darcs/0.8, so I've moved them to the 'old' section of the xmonad config archive
14:55:17 <lambdabot> Consider it noted.
14:58:02 <glguy> gwern, sounds good
14:58:03 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:58:54 <gwern> glguy: no no, the reply I was looking for was 'oh noes gwern, I'll go update it right this second!' -_-
14:59:20 <glguy> @messages
14:59:20 <lambdabot> gwern said 4m 3s ago: both of your xmonad configs on the wiki don't work with darcs/0.8, so I've moved them to the 'old' section of the xmonad config archive
14:59:32 <glguy> gwern, I'm not using xmonad at the moment
15:00:01 <dons> ... at the moment
15:00:05 * gwern amends my comment: *'oh noes gwern, I'll start using xmonad again and go update it, all right this second!' -_-
15:00:13 <dons> that's better
15:00:21 <Peaker> quicksilver: you there?
15:00:23 <dons> gwern: btw, you should hackage-ify 'nario bros'
15:00:26 <dons> did you see the code?
15:00:28 <gwern> huh, arossato's config is broken.
15:00:31 <gwern> dons: yes
15:00:38 <gwern> dons: I had trouble compiling hsdl and gave up for the night
15:00:40 <dons> in the japanese school of awesome haskell games
15:00:42 <dons> ah ok.
15:00:54 <dons> glguy: did you see nario bros?
15:00:56 * gwern reflects that it's odd arossato's config is broken, in as much as it's just importing his config from XMC
15:01:17 <glguy> no
15:02:20 <gwern> ah, it's exporting an IO (...lots of stuff...), but 'xmonad' expects an xconfig
15:02:33 <fabjan_> I'm also having trouble installing HSDL :/
15:02:52 <dons> the one on hackage?
15:03:04 <fabjan_> no, the one on infoseek.co.jp
15:03:05 <gwern> fabjan_: yeah, I fixed the include SDL problem, and then I discovered that the c-sources aren't there!
15:03:10 <rwbarton> If you install the SDL from hackage, I created a patch to build against that...
15:03:11 <dons> oh
15:03:15 <gwern> dons: no, the problem with super nario bros is the author has his own SDL bindings
15:03:16 <dons> rwbarton: ooh..
15:03:18 <rwbarton> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=336
15:03:20 <dons> gwern: yes, i see
15:03:21 <fabjan_> rwbarton: oh!
15:04:05 <gwern> dons: incidentally, for XMC, do we have a policy that anything in XMonad.Config.* must export a function such that one could go 'xmonad thatConfig'?
15:04:12 <gwern> cause the arossato one is broken in that sense
15:05:08 <gwern> he wrote it to be like 'xmonad =<< arossatoConfig'
15:08:58 <dons> http://www.reddit.com/r/programming/comments/7alz2/manipulate_transform_and_generate_erlang_with/  curious
15:09:00 <lambdabot> Title: Manipulate, transform and generate Erlang with Haskell : programming, http://tinyurl.com/5g2r38
15:09:40 <gwern> @seen ray
15:09:41 <lambdabot> I haven't seen ray.
15:09:49 <gwern> hm. anyone know who User:Ray is?
15:11:30 <fabjan_> rwbarton: thanks a bunch!
15:12:52 <evident> hello
15:13:11 <evident> anybody here?
15:13:40 <dons> ?users
15:13:41 <lambdabot> Maximum users seen in #haskell: 551, currently: 507 (92.0%), active: 22 (4.3%)
15:13:45 <dolio> @b52s
15:13:46 <lambdabot> His ear lobe fell in the deep. Someone reached in and grabbed it. It was a rock lobster!
15:13:52 <dons> 550. new high score
15:14:21 <evident> can anybody help me with a haskell problem pleas?
15:15:29 <evident> i have to write a haskell-function:
15:15:30 <evident> allEqual :: Eq a => [a] -> Bool
15:15:51 <Peaker> @hoogle Eq a => [a] -> Bool
15:15:52 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
15:15:52 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
15:15:52 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
15:15:54 <evident> which compares all elements of a list and if all elements are equal it returns True
15:16:24 <evident> but I have no idea what this "Eq a =>" means at all
15:16:32 <vixey> Eq is a typeclass
15:16:36 <mauke> evident: that's a class context
15:16:48 <evident> what does typeclass mean?
15:16:49 <vixey> it lets you use the function (==) on any 'a'
15:17:53 <Peaker> evident: it means that the "a" type variable cannot be any type at all, only types that support (==) operation
15:18:12 <evident> ahh ok
15:18:14 <Peaker> evident: types are instances of type-classes if they implement a set of operations for those types
15:18:28 <Peaker> (very badly worded, that was :-)
15:18:36 <evident> :D
15:18:42 <rwbarton> For example, the type of (==) is:
15:18:44 <rwbarton> :t (==)
15:18:45 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:18:47 <evident> well... i was thinking about solving the problem this way:
15:19:04 <rwbarton> meaning "you can compare any two values of the same type a, provided a is an instance of Eq"
15:19:28 <evident> allEqual a = if head a == head(tail a) then ( if tail a == [] then True else allEqual( tail a) ) else False
15:19:47 <vixey> that looks like lisp or something :p
15:20:06 <evident> this doesnt give me an error, but doesnt work... :(
15:20:12 <vixey> evident:  allEqual (x:xs) = every (==x) xs
15:20:18 <mauke> == [] better written as null
15:20:27 <mauke> head/tail better written as pattern matching
15:20:43 <mauke> if X then True else Y better written as X || Y
15:20:45 <rwbarton> == [] better written as pattern matching :)
15:20:50 <quicksilver> Peaker: apparently not.
15:22:11 <Peaker> quicksilver: Was wondering about why you needed dbgFutureSort, rather than deriving Show on Future?
15:22:21 <Peaker> quicksilver: to avoid Show requirement on the Future value?
15:23:04 <Peaker> quicksilver: also seemed a bit weird that you have: withTimeF that replicates the time information inside the future into the future value, but I guess I understand why you do that
15:24:47 <dobblego> @src Reader
15:24:47 <lambdabot> Source not found. Just try something else.
15:25:04 <gwern> @quote
15:25:05 <lambdabot> monochrom says: I know that one day you won't need to write the code for "interpret" yourself. You will just need to write the type signature, and add the word "catamorphism", and then the program
15:25:05 <lambdabot> will write itself.
15:26:04 <Apocalisp> @quote dobblego
15:26:05 <lambdabot> No quotes match. That's something I cannot allow to happen.
15:26:09 <vixey> what is interpret?
15:26:11 <Apocalisp> @quote dibblego
15:26:12 <lambdabot> dibblego says: I'm glad I googled it before going to see the doctor
15:26:19 <Apocalisp> tehehe
15:26:49 <Peaker> vixey: where's "every"?
15:27:01 <dobblego> @google gatorade green stools
15:27:08 <lambdabot> http://www.poopreport.com/Intellectual/Content/Dye/dye.html
15:27:08 <lambdabot> Title: Green Poop: The Implications Of Food Dye On Poop Color | PoopReport.com
15:27:16 <vixey> dunno, if it doesn't exist it's trivial to implement
15:27:40 <vixey> every = all -- one way
15:28:20 <Apocalisp> @google AAPL
15:28:25 <lambdabot> http://finance.google.com/finance?q=NASDAQ:AAPL
15:28:25 <lambdabot> Title: AAPL - Apple Inc. - Google Finance
15:28:31 <Apocalisp> aww
15:31:20 <gwern> disapointing. at this for a while, and I've only got 13 up to date xmonad.hss
15:39:13 <quicksilver> Peaker: because you can't really show a future :)
15:39:18 <quicksilver> Peaker: you can't meaningfully show IO actions
15:39:20 <Philonous> Is it possible that I have to delete my ~/.cabal folder to compile ghc?
15:39:30 <quicksilver> Peaker: it was really just to do some testing/debugging
15:39:41 <Peaker> quicksilver: could be nice to have a DebugShow everyone can derive.. Python has __repr__ which always exists
15:40:51 <heisenbug_> is there some jargon file that explains the word "zonking" in type inference setting?
15:41:27 <vixey> heisenbug_: where did you read that word?
15:41:31 <vixey> @jargon zonk
15:41:37 <lambdabot> No match for "zonk".
15:41:43 <vixey> @jargon zonking
15:41:44 <lambdabot> No match for "zonking".
15:42:27 <Cale> Probably in the GHC source code.
15:42:33 <heisenbug_> http://omega.googlecode.com/svn/trunk/src/RankN.hs
15:43:01 <heisenbug_> Cale: yes here too: http://darcs.brianweb.net/ghc/compiler/typecheck/TcMType.lhs
15:43:03 <vixey> interesting
15:43:08 <vixey> it's also in the FPH code
15:43:15 <vixey> so I wonder where this actually originates?
15:43:32 <medfly> cale!
15:43:37 <quicksilver> Peaker: yes, it would be.
15:44:28 <Peaker> quicksilver: it would also make ghci interactions more pleasant, I think... instead of evil "No Show instance" error dumps, you'd get a show of the function involved or such
15:45:38 <vixey> it seems to mean "eliminate any substitutions"
15:46:09 <vixey> (from http://research.microsoft.com/~simonpj/papers/higher-rank/putting.pdf )
15:46:12 <lambdabot> Title: Practical type inference for arbitrary-rank types, http://tinyurl.com/6xd2rd
15:47:16 <vixey> heisenbug_: Now I really want to know :/
15:47:40 <rwbarton> vixey: try #ghc maybe
15:51:02 <Peaker> There's tryTakeMVar, but no tryReadMVar?
15:56:38 <Peaker> is it possible to correctly/atomically implement tryReadMVar (in a way guaranteed not to block)
15:57:04 <Peaker> isEmpty + readMVar would not be atomic.  tryTakeMVar and putting it back might cause the put to wait...
15:58:19 <bd_> Peaker: hm, maybe swapMVar with mfix?
15:58:35 <bd_> wait no, that would probably block
15:58:42 <bd_> ... and it's not race-free
15:59:17 <bd_> You'd probably need to do MVar (MVar x) instead for it to be safe I guess
15:59:19 <Peaker> quoting quicksilver's code: "I think STM is the answer"
16:00:04 <Peaker> bd_: An MVar around the MVar to serve as sort of a mutex around the inner mvar?
16:00:11 <bd_> right
16:00:22 <bd_> or MVar (IORef (Maybe x))
16:00:31 <bd_> although that won't let you block I guess
16:00:41 <bd_> hm actually
16:00:44 <bd_> it's not that simple
16:01:00 <Peaker> sounds to me like (MVar (MVar a)) could work..?
16:01:09 <bd_> Peaker: yeah, but how do you block on that?
16:01:10 <vixey> (MVar (MVar (MVar a)))
16:01:21 <mauke> Mu MVar
16:01:22 <Peaker> bd_: block on the inner one
16:01:22 <bd_> takeNestMVar (outerVar) =  ???
16:01:31 <vixey> what's Mu MVar in C?
16:02:12 <bd_> hmm
16:02:18 <bd_> I'm not entirely sure it's safe
16:02:22 <bd_> it'd take some thought
16:02:30 <bd_> TMVar might be easier come to think of it
16:03:01 <bd_> that way you can just do isEmpty+readMVar
16:03:10 <bd_> well, isEmptyTMvar and readTMVar
16:03:16 <kaizoku> bd!
16:03:51 <Peaker> bd_: if you always takeMVar on the outer one to work on the inner one, then you can have atomic operations on the inner one
16:04:14 <bd_> Peaker: yes, I'm just worried about what happens when you operate on the inner when you're /not/ holding the outer
16:04:23 <Peaker> bd_: that's not allowed :P
16:04:33 <bd_> Peaker: Then takeMVar on an empty one will block forever :)
16:04:47 <bd_> Or rather, cause a deadlock exception in GHC
16:04:57 <bd_> since you have the outer one locked
16:04:59 <Peaker> bd_: you can allow working on the inner one only by giving an action to perform on the inner one, never actually exposing it
16:05:09 <bd_> oh certainly
16:05:20 <bd_> but my point is 'takeMMVar' will need to put the outer one back
16:05:22 <bd_> before blocking
16:05:30 <bd_> and that operation seems suspicious to me
16:05:37 <Peaker> bd_: Oh, indeed
16:05:53 <bd_> I wouldn't trust it without carefully analyzing any possible races, and it seems like it'll be easier just to do atomically $ isEmptyTMVar ....
16:06:16 <Peaker> bd_: STM is surely nicer,  I was wondering if it was possible without it though
16:06:50 <quicksilver> Peaker: no, you can't do it.
16:06:55 <quicksilver> Peaker: not in a way which is "safe"
16:07:01 <quicksilver> you have to wrap something up
16:07:12 <quicksilver> you can do it with (MVar (),Mvar a)
16:07:14 <quicksilver> for example
16:07:28 <bd_> quicksilver: is there a fundamental reason, or is it just a missing function in the implementation?
16:08:19 <quicksilver> bd_: in my opinion, it's a missing function.
16:08:31 <quicksilver> it seems to me it woudl be implementable using GHC's underlying implementation.
16:08:42 <quicksilver> but I don't exclude the possibility I've misunderstood someting :)
16:20:17 <pallino1961> ciao
16:25:11 <zloog> I understand that do is sugar to execute something in a monad. But how does the compiler know which monad to use?
16:25:54 <mauke> the compiler just desugars to calls to (>>=)
16:26:00 <mauke> the rest is normal type checking
16:26:15 <rwbarton> type inference, just like how the compiler knows which instance of Eq to use when you write a == b
16:26:45 <zloog> of course
16:26:46 <zloog> thanks
16:26:58 <zloog> obvious answer to a question bugging me for a couple days
16:28:17 <Peaker> @type (\x y -> do { a <- x ; b <- y ; return (a,b) })
16:28:19 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t t1 -> t t2 -> t (t1, t2)
16:28:32 <Peaker> zloog: it doesn't yet know which Monad it is, so it leaves it open in a type variable "t"
16:30:36 <zloog> Second question, is it possible to ask ghci to print out the definition of a function?
16:31:00 <zloog> you can use :i to show where it is defined, but does anyone know a way to just see its definition
16:31:13 <Peaker> zloog: I think there's a lambdabot extension to ghci, so you can do whatever you can here (i.e @src). I am not sure, though
16:31:24 <zloog> o cool
16:31:39 <byorgey> zloog: no, that's not possible.  in general ghci might not know the definition, since ghci works with compiled code (it is not an interpreter).
16:31:39 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
16:32:09 <byorgey> the @src only works for stuff in the standard libraries that have been put in the library of things you can look up with @src beforehand.
16:32:13 <zloog> @src map
16:32:14 <lambdabot> map _ []     = []
16:32:14 <lambdabot> map f (x:xs) = f x : map f xs
16:33:52 <byorgey> @seen gwern
16:33:53 <lambdabot> gwern is in #haskell. I last heard gwern speak 1h 2m 33s ago.
16:41:26 <jdrake> In an example from parsec.pdf, I have put together http://hpaste.org/11632#a9  but it seems to have an error about expecting type 'Char' over inferred type '[Char]'. Specific error is included, I am not sure what to make of tihs.
16:42:05 <gwern> byorgey: yo
16:42:05 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
16:42:33 <gwern> @messages
16:42:34 <lambdabot> byorgey said 5m 28s ago: heh, you know what, I have no idea why I never sent that in as a patch. In fact, at first I had no idea what you were talking about, I had to go look at my xmonad.hs. sorry
16:42:34 <lambdabot> about that.
16:44:21 <ddarius> jdrake: As the type error says words is a [String] not a String
16:45:53 <jdrake> ddarius, I see now thank you
16:55:11 <jacob_n> fibs :: [Int]
16:55:12 <jacob_n> fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs) ]
16:55:26 <jacob_n> when i type "fibs !! 50", it gives me a negative number
16:55:37 <dolio> Overflow.
16:55:47 <gwern> :( just 21 working xmonad configs in all
16:55:56 <dons> this exact question came up yesterday, jacob_n
16:56:00 <dons> weird.
16:56:00 <idnar> > let fibs = (0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs) ]) :: [Int] in fibs !! 50
16:56:02 <lambdabot>   12586269025
16:56:05 <dons> gwern: that's fine
16:56:12 <idnar> oh, guess it's only an overflow on 32-bit
16:56:29 <mmorrow> > maxBound :: Int
16:56:30 <lambdabot>   9223372036854775807
16:56:32 <mmorrow> , maxBound :: Int
16:56:34 <gwern> dons: means it'll be harder for me to find commonalities with that few
16:56:34 <lunabot>  2147483647
16:56:57 <dolio> ,  let fibs = (0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs) ]) :: [Int] in fibs !! 50
16:56:59 <lunabot>  -298632863
16:57:07 <jacob_n> so uh, how can i get it so it doesnt overflow before fibs hits 4 million?
16:57:08 <dolio> ,  let fibs = (0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs) ]) :: [Int] in fibs !! 49
16:57:10 <lunabot>  -811192543
16:57:23 <idnar> ,  let fibs = (0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs) ]) :: [Integer] in fibs !! 50
16:57:25 <lunabot>  12586269025
16:57:30 <rwbarton> jacob_n: use Integer, not Int
16:57:57 <jacob_n> rwbarton: thanks, worked like a charm
16:58:00 <mmorrow> , fromIntegral (maxBound::Int) + 1 :: Integer
16:58:03 <lunabot>  2147483648
16:58:14 <mauke> wait, what
16:58:17 <Peaker> @type fromIntegral
16:58:19 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:58:23 <Peaker> @type fromInteger
16:58:24 <lambdabot> forall a. (Num a) => Integer -> a
16:58:52 <jacob_n> tell me more about integer. does it have a limit on its precision?
16:58:54 <Peaker> are both needed? isn't fromIntegral enough?
16:59:01 <mmorrow> Peaker: in ghc, all the fromIntegrals are done with rewrite RULES instead of using the classes
16:59:06 <mauke> @src fromIntegral
16:59:07 <lambdabot> fromIntegral = fromInteger . toInteger
16:59:18 <mauke> jacob_n: no
16:59:18 <mmorrow> so fromIntegral is always the most efficient way guaranteed
16:59:18 <rwbarton> jacob_n: nope (just your computer's memory)
16:59:28 <Peaker> mmorrow: oh, cool
16:59:31 <jacob_n> thats so tight!
16:59:40 <Peaker> mmorrow: how do you write type-specific rewrite rules?
16:59:45 <mauke> > 2^1000
16:59:46 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
17:00:07 <mmorrow> Peaker: i'll find an example. (it's also in the GHC manual ;)
17:00:18 <Peaker> mmorrow: thanks
17:00:30 <maxote> > 2^(2^31337)
17:00:36 <dolio> rewrite rules only fire if they don't cause type errors.
17:00:46 <lambdabot>   thread killed
17:00:59 <dolio> So if you write 'fromIntegral = intToWord' it'll only fire in appropriate situations.
17:01:08 <maxote> > print "conspiracy theory"
17:01:10 <lambdabot>   * Exception: "<IO ()>"
17:01:29 <dolio> Assuming intToWord :: Int -> Word
17:02:17 <dolio> (At least, I'm pretty sure that's how it works.)
17:02:31 <jacob_n> using the fibs example, how can a create a list comprehension that contains all elements of fibs less than 6 thousand?
17:02:44 <mmorrow> peaker this file has a bunch of type-specific {-# RULES ... #-} in it http://code.haskell.org/~morrow/code/haskell/ghc/html/Int.hs.html
17:02:45 <lambdabot> Title: Haskell Code by HsColour
17:02:55 <sannysanoff> > 2+2
17:02:56 <lambdabot>   4
17:03:10 <Peaker> dolio: oh, simple
17:03:21 <sannysanoff> @pl \(i, xxs) -> map (i:) $ expandedTree xxs
17:03:22 <lambdabot> uncurry ((. expandedTree) . map . (:))
17:03:35 <mmorrow> that should the actual file is http://darcs.haskell.org/libraries/base/GHC/Int.hs
17:03:40 <mauke> jacob_n: use takeWhile
17:03:45 <mmorrow> s/that should//
17:04:48 <mmorrow> Peaker: also, dons has a blog post about using rewrite rules as "poor man's classes"
17:05:09 <mmorrow> clever
17:05:14 <Peaker> mmorrow: poor but quick :)
17:05:42 <jacob_n> thanks mauke
17:06:13 <mmorrow> Peaker: hehe
17:06:49 <mmorrow> Peaker: rrwbarton hpasted something a week or two ago also which used rewrite rules to optimize (^)
17:07:44 <Peaker> mmorrow: are these integer conversion rewrite rules essentially an "inlining" of the relevant classes?  Is there no way to generalize this optimization to other classes as well?
17:08:43 <rwbarton> Peaker: it was pretty broken though, using x^y where y was not a numeric literal usually caused the rewriter to diverge
17:08:53 <gwern> whew! done with that xmonad stuff
17:08:55 <gwern> yeesh
17:08:59 <gwern> night all
17:09:04 <sclv> happy haskellween everybody!
17:09:46 <mmorrow> Peaker: i believe the rewrite rules for fromIntegral are mostly so that the intermediate Integer is eliminated for efficiency reasons
17:09:55 <sclv> mmorrow: by the way, did you ever finish the timings comparing iorefs to implicit params?
17:10:19 <mmorrow> so any fromIntegral involving Integer as the src or target are probably the same as doing {from,to}Integer
17:10:37 <mmorrow> sclv: i never did the monadic case
17:12:04 <mmorrow> sclv: it'd be interesting to see some times when concurrency's involved too
17:13:07 <mmorrow> (i used an MVar instead of an IORef as well, i'm not sure if that changed anything since it never would have blocked in my single-threaded prog either)
17:13:43 <sclv> the implicit param was the quicker of the two?
17:13:53 <sclv> (i can't find your paste anymore)
17:14:00 <mmorrow> yeah, over twice as fast
17:14:09 <mmorrow> ah, i see. i'll find it :)
17:14:25 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=301
17:15:01 <sclv> cool.
17:15:29 <sclv> I've been puzzling over if there's any solution to the thread issue with ieee on and off all day.
17:16:01 <sclv> Short of just saying "forkIO breaks this" I don't think there's any good answer within what the runtime currently permits.
17:17:00 <mmorrow> yeah totally. i've thought about that too and don't see any way save control over the asm generated to be able to not bork other threads computations if one thread changes (eg) the rounding mode, then get suspended before changing it back
17:17:58 <mmorrow> (assuming those other threads aren't using the IEEEMonad and simply doing compuations with Double and/or Float and (+)/(*)/etc
17:17:59 <teratorn> sorry I don't know what you are talking about it, but presumable you can't put a big lock around it for some reason?
17:19:00 <Peaker> what's the IEEEMonad?
17:19:29 <Zao> A wild guess would be IEE754 conformant floating point numbers with the fp flags needed as state.
17:20:02 <mmorrow> teratorn: the only problem is other threads using the standard Double/Float with their Num instances wouldn't be be aware of any locks
17:20:19 <mmorrow> or any changes to the FPU state for that matter
17:20:37 <mmorrow> Peaker: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ieee-utils
17:20:39 <lambdabot> Title: HackageDB: ieee-utils-0.4.0, http://tinyurl.com/3q5p2h
17:20:43 <teratorn> so you have to suspend them until the FPU state is changed back to normal :)
17:20:52 * teratorn laughs evilly
17:20:57 <mmorrow> teratorn: haha
17:21:01 <sclv> sun's docs are explicit that "In a multithreaded program, the fegetenv() and fegetenv() functions affect the floating point environment only for the calling thread." and I guess that's the observed behavior.
17:21:22 <sclv> even though the gnu docs don't seem to say that.
17:21:29 <mmorrow> ooh, nice. hmm, maybe that assumes the C compiler taking care of that for you though?
17:22:31 <sclv> so we have the other problem now though -- the one just reported on the mailing list.
17:22:52 <sclv> run a program with -N2 and you've really only set the rounding mode in one of the two OS threads.
17:22:55 * mmorrow looks at the list
17:23:14 <sclv> but your lightweight threads are now bouncing around between executing on different OS threads depending on how GHC feels.
17:24:33 <sclv> http://www.haskell.org/pipermail/haskell-cafe/2008-October/050046.html
17:24:34 <lambdabot> Title: [Haskell-cafe] Re: Why 'round' does not just round numbers ?, http://tinyurl.com/69389q
17:25:54 <dons> sclv: forkOnIO ?
17:26:00 <dons> you can pin threads to desired cpus.
17:26:13 <dons> +RTS -qm   to disable migration too?
17:26:36 <sclv> dons -- oh, nice! I forgot all about that!
17:26:51 <dons> yeah, forkOnIO is woot-full
17:26:58 <mmorrow> heh
17:27:13 <dons> i was reminded of it (again) when looking at the gang threads impl. in dph, http://darcs.haskell.org/packages/dph/dph-prim-par/Data/Array/Parallel/Unlifted/Distributed/Gang.hs
17:27:15 <lambdabot> http://tinyurl.com/67qs3n
17:27:32 <sclv> so we can do things really right -- when we set the round mode, we can have a call that uses forkOnIO to ensure that the round mode is changed on every OS thread at once!
17:28:03 <dons> i think so, yes.
17:28:18 <dons> and you might or mightn't need to do something about thread migration?
17:28:37 <mmorrow> this sounds like fun ;)
17:29:01 <sclv> well, if we change it on every thread, then the library user can use forkIO innocently without even noticing there's a difference.
17:29:20 <mmorrow> hmm
17:29:34 <sclv> the other option is just to note this all in the documentation and pass the complexity along...
17:29:35 <dons>   -qm       Don't automatically migrate threads between CPUs
17:30:08 <sclv> so there's the lossy abstraction API and the nitty gritty API
17:30:32 <sclv> speaking of lossy abstractions, does anyone know of a way to catch the termination of a haskell program on windows?
17:31:00 <sclv> the console handlers will catch a ctrl-c, but not, e.g., closing the program explicitly by closing its console.
17:34:36 <sclv> hmmm.. with -qm the example program works fine too.
17:34:52 <sclv> which is maybe the simpler way.
17:35:26 <sclv> since you can't forkIO inside the IEEE monad anyway.
17:59:27 <mmorrow> sclv: hmm, you cna also set the default RTS opts for a prog by linking:
17:59:33 <mmorrow> char *ghc_rts_opts = "-qm";
17:59:37 <mmorrow> into the prog
18:00:15 <mmorrow> since ieee-utils has cbits anyways, maybe that can just be added to the .c as well
18:00:30 <mmorrow> (?)
18:01:29 <mmorrow> (i /think/ that'd behave the same way as linking that into the eventual Main.hs, but i'm not positive)
18:02:35 <Cale> hmm, I wonder if it would prevent the eventual user of the package from linking in their own choice of ghc_rts_opts though...
18:02:43 <dons> yep
18:02:44 <mmorrow> at the very least, that'd probably cause problems if the programmer does the same thing with some other options for Main.hs without knowing
18:02:45 <mmorrow> yeah
18:02:48 <mmorrow> dang
18:03:09 <Cale> It's a bit silly that there isn't an IO monad interface to runtime system options.
18:03:10 <dons> ghc would have to pick up package-vers-module-ghc_rts_opts
18:03:26 <dons> Cale: mmm. they /must/ be set at configuration time
18:03:44 <dons> you can read any number of them purely (numCapabilities == -Nk)
18:03:53 <dons> but setting them, problematic
18:04:31 <Cale> Theoretically, it seems like at least most of them ought to be tunable at runtime.
18:04:43 <dons> yeah
18:05:15 <dons> come up with a good use case (dynamically changing the schedule switching rate?) and talk to jaffacake
18:05:20 <mmorrow> a solution might be if packages were allowed to add RTS options to the set at Main.hs build-time
18:05:50 <mmorrow> (ie if there was some mechanism allowing packages to do that)
18:06:00 <mmorrow> s/allowing/enabling/
18:06:41 <mmorrow> and conflicting flags were dealt with somehow..
18:10:47 <zloog_> Can lambdabot twitter?
18:11:25 <mmorrow> (dynamically changing RTS flags at runtime would of course in addition be desirable)
18:11:45 <dolio> @vixen Can you twitter?
18:11:46 <lambdabot> isn't it obvious?
18:12:13 <mmorrow> but i bet there'd be a need to be able to do so at both compile-time /and/ runtime since there're probably flags which can't be changed at runtime due to how the rts works
18:52:01 <meoow> hello :)
18:52:12 <Cale> hey
18:52:41 <meoow> is the 64 bit code generator of ghc better than the 32 bit one?
18:52:56 <meoow> my code runs ~ 40% faster in 64 bit
18:53:05 <meoow> (core 2 duo, not athlon)
18:53:31 <Cale> Well, there are more bits available for pointer tagging, iirc.
18:53:39 <Cale> There are probably other differences as well :)
18:53:49 <heatsink> It might be taking advantage of the bigger arch register file for something.
18:54:02 <mmorrow> whoa, core 2 duo you say? can those run 64bit instructions?
18:54:20 <meoow> mmorrow: sure, they can.
18:54:21 <Axman6> yeah
18:54:35 <mmorrow> hmm, nice
18:54:54 <Axman6> core 2 basically means 64 bit
18:54:55 <meoow> mmorrow: athlon 64 is in 64 bit mode generally 30% faster
18:55:15 <meoow> mmorrow: but core 2 duos usually aren't.
18:55:21 <meoow> so i'm a bit surprised
18:55:49 <mmorrow> am i misunderstanding what a core2duo is, or can i run 64bit instrs on my laptop ? http://hpaste.org/11653
18:55:58 <mmorrow> (cat /proc/cpuinfo output)
18:56:19 <mmorrow> mines a "core 2" w/out the "duo"
18:56:25 <mmorrow> dunno if that means anything
18:56:55 <Axman6> Core 2 Solos only have one core, duos are dual core
18:57:31 <mmorrow> ah nice. so i take it then that i /can/ run 64bit code on my laptop given that /proc/cpuinfo (?)
18:57:59 <meoow> are there single-core core 2 cpus?
18:58:09 <mmorrow> haha, true
18:58:13 <meoow> i haven't seen any yet.
18:58:18 <mmorrow> Core Solo he must have meant
18:58:19 <Axman6> i'm not sure if they ever actually made any songle core core 2's
18:58:36 <Axman6> but... a Core 2 Solo would have one core, and be 64 bit :P
18:58:44 <Cale> meoow: Recent incarnations of GHC store information about which constructor a value evaluated to in the low-order bits of the pointer to it. If I'm remembering correctly, for 32 bits this works for up to 3-constructor types, and for 64 bits it works up to 7-constructor types.
18:58:52 <rwbarton> I don't know, but my /proc/cpuinfo is similar but says "Duo" between "2" and "CPU"
18:58:56 <Axman6> mmorrow: depends on your OS
18:58:59 <mmorrow> ah, so the "2" has to do with supporting /both/ 32 and 64 then?
18:59:12 <mmorrow> i always assumed it had to do with the number of corexs
18:59:16 <mmorrow> *cores
18:59:41 <mmorrow> Axman6: would it work on linux?
18:59:51 <meoow> Cale: i'm running some code which works quite a bit on a quad tree structure
18:59:53 <Axman6> if it's a 64 bit distro, then yes
19:00:00 <mmorrow> ohh, i see.
19:00:15 * mmorrow looks into installing a 64 bit distro
19:00:21 <meoow> i should have a look at the machine code
19:00:33 <mmorrow> meoow: ghc-core is handy for that
19:00:35 <meoow> though i'm lazy and it really doesn't matter
19:00:37 <meoow> :)
19:00:41 <mmorrow> heh
19:00:51 <meoow> ghc-core is on my yet-to-learn list
19:01:04 <Saizan_> ghc-core should give human-readable names to the variables
19:01:27 <mmorrow> ah, so ghc-core is a little cli tool that HsColours the Core and the ASM output by ghc
19:01:38 <meoow> are there supposed to be any differences in ghc-core?
19:01:53 <rwbarton> Cale: It seems like with 64-bit pointers, some of the higher bits could safely be used. :)
19:01:58 <meoow> i thought ghc-core is still independent of the code generator.
19:02:02 <mmorrow> it's a stripped down and different rep of haskell code than the AST it's parsed to
19:02:16 <mmorrow> ("it" there being "haskell source")
19:02:20 <Cale> rwbarton: hehe
19:02:28 <mmorrow> (the second "it" i meant)
19:02:38 <Cale> rwbarton: that feels rather evil, but yes :)
19:02:58 <Axman6> anyone know if it's possible to get 64 bit ghc on OS X?
19:03:08 <rwbarton> I'm surprised 64-bit pointers don't cause a big slow down just due to memory bandwidth.  (I just read a mini-rant by Knuth about this)
19:03:13 <meoow> it's waste not to use those upper bits :).
19:03:14 <Cale> Practically speaking, it seems unlikely for people to have that much memory any time soon :)
19:03:15 <meoow> +a
19:03:45 <meoow> Cale, actually it's unlikely to have as much memory on earth any time.
19:03:51 <mmorrow> yeah, core is indep of the codegen
19:03:59 <Axman6> Cale: how much memory?
19:04:05 <Saizan_> rwbarton: i've seen people complain about that, since haskell code uses lots of pointers
19:04:11 <dolio> > 2^64
19:04:12 <lambdabot>   18446744073709551616
19:04:18 <Cale> ^^ that much :)
19:04:33 <mmorrow> ghc does:    .hs ==> HsSyn ==> CoreSyn ==> StgSyn ==> Cmm ==> .s
19:04:35 <Axman6> 16 exabytes you mean?
19:04:40 <Axman6> exabytes? hmm
19:05:04 <rwbarton> 1 exabyte should be enough for anybody
19:05:06 <meoow> hmm, StgSyn is?
19:05:22 <dolio> > drop 3 . iterate (`div` 1024) $ 2^64
19:05:23 <lambdabot>   [17179869184,16777216,16384,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
19:05:48 <Cale> yeah, 16 exabytes
19:06:03 <mmorrow> it's syn for the lang the STG machine that ghc's eval strategy is based on uses
19:06:16 <mmorrow> Spineless Tagless GMachine
19:06:26 <mmorrow> (but it's not tagless anymore)
19:06:48 <StoneToad> rwbarton: why am I reminded of the 640k limit in dos?
19:07:07 <meoow> sounds like some abstract machine..
19:07:12 <mmorrow> exactly
19:07:45 <meoow> 640kb are enough for everybody.
19:07:56 <mmorrow> meoow: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
19:07:57 <lambdabot> Title: Commentary/Rts/HaskellExecution - GHC - Trac, http://tinyurl.com/2xet5k
19:08:12 <mmorrow> "The STG language has a clear operational model, as well as having a declarative lambda-calculus reading. ..."
19:09:16 <meoow> 16 exabyte is a LOT
19:09:40 <meoow> i suppose it's not impossible to build such large storage devices
19:09:45 <mmorrow> > maxBound::Int
19:09:47 <lambdabot>   9223372036854775807
19:09:48 <mmorrow> , maxBound::Int
19:09:49 <meoow> but 16 eb ram?
19:09:50 <lunabot>  2147483647
19:09:52 <meoow> nah...
19:10:49 <Axman6> 16 exabytes = 17 179 869 184 gigabytes according to google
19:11:29 <mmorrow> > maxBound::Int `div` (1024 * 1024 * 1024 * 1024)
19:11:30 <lambdabot>   <no location info>: parse error on input `*'
19:11:36 <mmorrow> > (maxBound::Int) `div` (1024 * 1024 * 1024 * 1024)
19:11:38 <lambdabot>   8388607
19:11:53 <meoow> axman6: = 17 179 869 184 minutes of porn? :)
19:12:04 <mmorrow> heh, sounds more like it
19:12:18 <mmorrow> i wonder where it got 17 179 869 18 from
19:12:33 <mmorrow> oh, n/m
19:12:54 <mmorrow> i'm trying to map exabytes to Int64-addressable range...
19:12:56 <Cale> Let's see, the mass of the Earth divided by the proton mass is on the order of 10^51, and the base 2 log of that is about 171.
19:13:23 <heatsink> mmorrow: google calculator is broken. 1.024 kibibytes == 1.024 kilobytes according to google.
19:13:35 <mmorrow> haha
19:13:37 <Cale> So, it's very doable, if we're willing to turn every particle in the Earth into storage for a bit.
19:14:27 <Axman6> quantum computing here we come
19:14:37 <mmorrow> we should just do that to the moon
19:15:09 <Axman6> heh, there was a Dr. Who episode about something like that
19:15:14 <Cale> actually, 1kg of matter would be more than enough to exceed 64bits
19:15:40 <mmorrow> a pound of flesh, no more no less?
19:15:49 <FunctorSalad> but who would watch the porn if the whole earth was turned into storage?
19:16:12 <Cale> a milligram would be about right
19:18:02 <Axman6> "ry ceiling to 264 addresses, equivalent to approximately 17.2 billion gigabytes, 16.8 million terabytes, or 16 exabytes of RAM." Wikipedia
19:18:14 <Axman6> The emergence of the 64-bit architecture effectively increases the memor*
19:19:16 <Cale> So maybe someday we'll have memories which use approximately every nuclear particle of a milligram of matter, each to store a single bit of information, and the total will be over 16 exabytes :)
19:20:30 <Axman6> then maybe we'll have enough!
19:20:43 <Axman6> 4GB is nowhere near enough
19:21:14 <meoow> Cale, then how do you store these particles at 0 kelvin and access them at the same time?
19:21:45 <Cale> Engineering details ;)
19:21:46 <meoow> Cale: decoherence quickly destroys the information.
19:21:46 <ddarius> @google spintronic
19:21:49 <lambdabot> http://en.wikipedia.org/wiki/Spintronics
19:21:49 <lambdabot> Title: Spintronics - Wikipedia, the free encyclopedia
19:22:09 <Axman6> IBM's System i stuff uses 128-bit addressing apparently
19:22:30 <telexicon> impossible
19:22:31 <Axman6> the hardware doesn't, but it means they can upgrade the hardware without any need for recomplication later
19:23:23 <maxote> i wanna 128 bits
19:23:29 <Axman6> "The IBM System i's instruction set defines all pointers as 128-bit."
19:23:39 <Axman6> it's a virtual instruction set
19:23:44 <Axman6> http://en.wikipedia.org/wiki/AS/400#Instruction_set
19:23:45 <lambdabot> Title: IBM System i - Wikipedia, the free encyclopedia
19:23:58 <Cale> maxote: I accidentally the whole 128 bits!
19:24:12 <jeffz> yeah, iirc, if you hack C on that platform, sizeof(void*) is 16.
19:24:44 <maxote> the pointers will be too longer, it's 16 bytes per pointer.
19:25:10 <andyjgill> evening all.
19:25:56 <dolio> 16 bytes?
19:26:00 <Cale> Hey, I have an idea. Let's design an architecture which uses IPv6 addresses to address memory.
19:26:29 <dolio> Geeze, that's right.
19:26:30 <rwbarton> Does it have broadcast addresses for memset()?
19:26:47 <ksandstr> one segfault takes out the african internet backbone
19:28:03 <Axman6> v6OS
19:28:32 <maxote> strcpy("african_bamboo.com","127:::::::::::::::1","Hello");
19:28:46 <heatsink> A 256-bit address space fits on a 10-km sphere, at just below the quantum-mechanical information density limit.
19:28:52 <dolio> > (/8) . logBase 2 . fromIntegral $ ord maxBound
19:28:53 <lambdabot>   2.5109326932901954
19:29:06 <maxote> Segfault. african_bamboo.com printed 404.
19:29:32 <dolio> Imagine String on there? 3 bytes of content and 32 bytes of overhead (at least) per character.
19:30:08 <bd_> maxote: ... what?
19:30:35 <Axman6> internal.kernel.com: 501 CPU error
19:33:25 <meoow> what do you think is the maximum clock rate we can reach with silicon?
19:33:47 <meoow> i think that's much more interesting than 2^64 bytes of ram.
19:34:09 * Axman6 takes a stab at 10GHz
19:34:12 <meoow> capacity? bah. speeeeeeeeeeeeeeeeed.
19:34:23 <Axman6> i was going to say 5, then realised i've seen it done
19:34:44 <meoow> my estimate lies between 10 ghz and 20 ghz.
19:35:13 <mmorrow> trying to get more speed out of silicon seems to me to be beating a dead horse more and more to see how dead it can get
19:35:59 <mmorrow> isn't there some silicon alternative i recently read about somewhere?
19:36:01 <ksandstr> IBM's power6 is said to be at 4.7ghz now
19:36:07 <heatsink> Speed is dead. Long live parallelism.
19:36:36 <maxote> heatsink, ++speed & ++parallelism
19:36:48 <Axman6> i'd like to know more about IBM's work these days. they seem to be quiet, and have a lot of cool stuff
19:36:53 <meoow> heatsink: i'd prefer one cpu with 64 ghz instead of 16 cpus with 4 ghz :).
19:37:02 <ksandstr> single threads are faster now than they have ever been. they're faster now than when the first dual-core x86 CPUs came out. they'll keep getting faster too
19:38:06 <mmorrow> meoow: i dunno, FPGAs can do many many things in the same clockcycle
19:38:35 <mmorrow> to 10*250MHz == a lot
19:38:49 <mmorrow> 20*500MHz == more
19:39:17 <meoow> i'm still waiting for the magic haskell to vhdl converter.
19:39:21 <heatsink> Speed is always easier, but we've seen the end of the time of exponential speed gains.
19:39:28 <mmorrow> meoow: ooh, me too :)
19:40:04 <ksandstr> right now it's memory bandwidth that's the main problem. a L2 miss already costs hundreds of instructions' worth of cpu cycles
19:40:12 <meoow> and the cheap and dirty laser printer for integrated circuits.
19:40:34 <meoow> insert silicon sheets, receive printed circuits.
19:40:42 <mmorrow> isn't that what FPGAs are, but better? ;)
19:41:11 <meoow> fpgas generally have higher internal latencies
19:41:11 <mmorrow> (well, "better" depending on stuff i guess)
19:41:18 <maxote> 32 MiB of L2 cache is not much, it's a stripped version of 2 GiB module.
19:41:33 <FunctorSalad> is "L2 miss" = "need to fetch from L2 cache" or "not even in L2 cache"?
19:41:36 <roconnor> @go 1 gallon in litre
19:41:38 <lambdabot> 1 US gallon = 3.78541178 litre
19:41:42 <meoow> an asic can have higher clock rates.
19:41:56 <bd_> FunctorSalad: not even in L2
19:41:59 <roconnor> @go 1 CAD / litre in USD / gallon
19:41:59 <ksandstr> FunctorSalad: not even in L2
19:42:00 <lambdabot> 1 (Canadian dollar / litre) = 3.15687823 U.S. dollars / US gallon
19:42:09 <mmorrow> true, i guess the tradeoff is that it can't dynamically reconfigure itself
19:42:10 <meoow> though todays fpgas are great, of course.
19:42:22 <ksandstr> FunctorSalad: but I meant a main memory access.
19:42:30 <FunctorSalad> I see
19:42:54 <mmorrow> dynamic reconfiguration of FPGAs by the FPGA itself is one of the possibilities i find so exciting about FPGAs
19:44:19 <mmorrow> and stuff like (eg) being able to generate a custom fft for a particular task, then creating that in an fpga immediately in order to do computations
19:44:48 <meoow> fpgas definitely have a lot of potential.
19:44:58 <ksandstr> there are non-fpga asymmetric architectures. the ps3's cell for one
19:45:26 <ksandstr> probably squeezes out more flops than a commercial fpga will three years from now
19:45:29 <ddarius> mmorrow: It's just like software only faster.
19:45:30 <meoow> i see fpgas as a kind of generic coprocessors.
19:45:36 <mmorrow> ddarius: totally!
19:45:48 <ddarius> mmorrow: That makes it rather uninteresting to me.
19:46:11 <meoow> ddarius: do you think so?
19:46:12 <mmorrow> ddarius: but it can also /run/ the software itself
19:46:17 <mmorrow> at the most basic level
19:46:30 <meoow> ddarius: it's a different way of working than with software.
19:46:31 <ddarius> I can run software with software.
19:46:39 <mmorrow> "generate me two cpus and an ethernet card"
19:47:06 <mmorrow> and that computation is done on the one cpu and some other stuff the previous config held
19:47:08 <ksandstr> verilog or vhdl sound like the exactly wrong thing for application programming
19:47:31 <meoow> verilog and vhdl are a mess :)
19:47:33 <maxote> "generate three FPGAS and two terabit ethernet cards"
19:47:39 <meoow> "debugging hell"
19:47:47 <mmorrow> maxote: hehe
19:48:09 <ksandstr> and the abstraction level is all wrong. gates and adders and concurrent assignments, yeah, sure, but what does it have to do with web browsing or word processing
19:48:24 <maxote> i want a ready FPGA-hypervisor controlling the FPGAs
19:49:55 <meoow> ksandstr: we have lots of VERY computation intensive stuff in our physics department.
19:50:01 <mmorrow> but couldn't that logic be located in the FPGAs themselves? and dynamically changeable/generateable at that
19:50:12 <maxote> if the resource that is owning the FPGA is idle much time then to backup it and free the idle FPGAs
19:50:14 <meoow> ksandstr: i think that's where fpgas can really shine.
19:50:35 <meoow> ksandstr: as an example
19:51:18 <ksandstr> meoow: yet the team that's just using MPI and piling on the iron will generally cross the finish line sooner
19:52:01 <maxote> if the resource want the FPGA again then the hypervisor will restore the previous backup's state and the resource could continue
19:52:34 <meoow> ksandstr: but what if the fpga is about a hundred times faster?
19:53:04 <meoow> ksandstr: that's not unreasonable for linear algebra stuff, for example.
19:53:11 <ksandstr> meoow: it isn't. typical fpgas today are clocked at tens or low hundreds of mhz
19:53:37 <maxote> the microprocessor are of the order of GigaHertzs
19:53:39 <ksandstr> commodity hardware for the same money gets you more clock cycles, more redundancy and more memory bus bandwidth
19:53:42 <meoow> there are ghz ones
19:53:49 <meoow> and they are not that expensive
19:54:10 <znutar_> their perf/watt is hideous though
19:54:37 <meoow> ok, i don't know about that. i have never used one.
19:56:12 <mmorrow> ksandstr: i think it's what FPGAs can do that's impossible with chiseled-in-stone circuits is what makes them amazing
19:56:42 <ksandstr> mmorrow: yet they're not programmable like general purpose CPUs are, i.e. with models that've been taught for the last 40 years
19:56:44 <mmorrow> s/amazing/the new black/
19:56:56 <mmorrow> ksandstr: the sooner that changes the better :)
19:57:04 <mmorrow> oh, no
19:57:07 <mmorrow> i misread you
19:57:19 <mmorrow> yes, FPGAs will require a new paradigm
19:57:26 <meoow> mmorrow: that's difficult.
19:57:35 <mmorrow> very much so
19:59:12 <maxote> one software emulator on GHz microprocessor can simulate the equivalent to one from FPGA
19:59:23 <meoow> programming general purpose cpus is a breeze compared to hardware development.
19:59:58 <FunctorSalad> wouldn't a compiler do that?
20:00:11 <mmorrow> maxote: it'll take days to break WEP on a cpu, but maybe an hour or two tops on a FPGA. it's stuff like this where they crush
20:00:12 <FunctorSalad> (or you mean that that's the hard part)
20:00:15 <ksandstr> java grinders are cheap, vhdl grinders don't exist -- they're all more like "highly paid professionals"
20:00:42 <mmorrow> creating a CPU in an FPGA is trying to carry the old paradigm into the new
20:00:53 <mmorrow> and they're incompatible
20:01:04 <meoow> mmorrow: not necessarily
20:01:16 <mmorrow> yeah, i was just about to qualify that
20:01:18 <meoow> mmorrow: you can add new special new instructions
20:01:27 <meoow> -new
20:01:30 <mmorrow> oh, that too for sure
20:01:36 <mmorrow> i was thinking along the lines of:
20:02:10 <mmorrow> "creating a CPU in an FPGA in order to use that CPU as the main thing which computes"
20:02:19 <mmorrow> and doing so in a non-parallel way
20:02:27 <ksandstr> WEP breaking is a bad example by the way, the main reason why it's slow on a general purpose CPU is because of the 256-byte RC4 state
20:02:50 <mmorrow> ksandstr: heh, ok. but you know what i mean ;)
20:02:55 <ksandstr> if one could bung the RC4 state on SRAM cache that was never written out through the bus, it'd be quicker
20:06:40 <meoow> i am tired, so i'll wander off to bed.
20:06:43 <meoow> night!
20:06:45 <mmorrow> night
20:11:18 <twb> main = iter where iter = do { l <- getLine; print $ words l; iter; }
20:11:33 <twb> If I type ^D^D^D^M, I get output: ["\EOT\EOT\EOT"]
20:11:44 <twb> That's kinda sucky, don'tcha think?
20:13:08 <mmorrow> if isEOF stdin then exitWith (ExitSuccess) else hGetLine stdin >>= \l ->
20:13:38 <twb> mmorrow: well, I expected it to throw an exception
20:13:57 <mmorrow> if isEOF stdin then throwDyn "asdfghjkl;" else hGetLine stdin >>= \l ->
20:14:01 <twb> Like $ hsh.hs </dev/null --error--> hsh.hs: <stdin>: hGetChar: end of file
20:14:14 <mmorrow> or s/throwDyn/throw <something>/
20:14:37 <rwbarton> twb: I think it depends on your OS and whether you've compiled it or are running in via runhaskell and maybe some other factor I've forgotten.
20:14:48 <twb> runhaskell.
20:14:57 <rwbarton> twb: I agree that it's quite annoying.
20:15:06 <rwbarton> twb: Try compiling it
20:15:19 <mmorrow> catchDyn (let go = if isEOF stdin then throwDyn "<stdin>: hGetChar: end of file" else hGetLine stdin >>= \l -> putStrLn l >> go) (\msg -> putStrLn msg)
20:15:27 <Axman6> @src Either (>>=)
20:15:28 <lambdabot> Left  l >>= _ = Left l
20:15:28 <lambdabot> Right r >>= k = k r
20:15:43 <TSC`> Yeah, only happens in runhaskell for me; if I compile it, it throws the exception
20:15:47 <twb> rwbarton: compiling it doesn't help.
20:15:59 <mmorrow> or just
20:16:00 <mmorrow> main = let go = if isEOF stdin then putStrLn "<stdin>: hGetChar: end of file" else hGetLine stdin >>= \l -> putStrLn l >> go in go
20:16:16 <twb> "let go" hee hee.
20:16:23 <mmorrow> heh
20:16:42 <rwbarton> twb: works for me; what OS are you on?
20:16:52 <TSC`> It did work compiled, now it doesn't.
20:16:53 <TSC`> ...
20:17:06 <twb> rwbarton: Debian
20:17:19 <rwbarton> twb: hmm, me too.
20:17:38 <rwbarton> twb: I have a suspicion that runhaskell sometimes messes with the terminal state in a weird way.
20:17:50 <TSC`> Yeah, I think runhaskell is involved
20:17:55 <rwbarton> and this can sometimes persist even after runhaskell has finished
20:17:59 <twb> Well, the problem is present even with ghc --make, so it can't be runhaskell's fault AFAICT
20:18:03 <TSC`> rwbarton: Same for me
20:18:10 <rwbarton> twb: try a freshly opened terminal
20:18:15 <TSC`> If I use runhaskell and then try the compiled one, it doesn't work any more
20:18:24 <twb> Oh ow
20:18:29 <TSC`> Resetting the terminal (with "reset") makes it work again
20:18:30 <twb> You're right; ^D doesn't exit the shell
20:18:45 <twb> That's bloody evil
20:19:16 <TSC`> It doesn't break my terminal to that extent, at least
20:19:25 <twb> I'm in a dumb terminal
20:19:31 <twb> As in, TERM=dumb
20:21:25 <twb> How do I do this without referring to x or ys?
20:21:25 <twb> let f xs@(x:ys) = (x,ys)
20:21:45 <twb> Oh, head/tail?
20:21:57 <twb> Yeah.
20:23:30 <Axman6> @src ap
20:23:31 <lambdabot> ap = liftM2 id
20:23:52 <Axman6> :t ap
20:23:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:24:10 <Axman6> @src on
20:24:11 <lambdabot> (*) `on` f = \x y -> f x * f y
20:24:36 <Axman6> bugger, now i forgot what i wanted to use that for >_<
20:25:15 <Axman6> :t (,) `on` head
20:25:16 <lambdabot> forall a. [a] -> [a] -> (a, a)
20:26:08 <lispy> :t (+) `on` map
20:26:09 <lambdabot> forall a b. (Num ([a] -> [b])) => (a -> b) -> (a -> b) -> [a] -> [b]
20:26:44 <lispy> :t map `on` (+)
20:26:45 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
20:26:45 <lambdabot>       Expected type: (a -> b) -> (a -> b) -> c
20:26:45 <lambdabot>       Inferred type: (a -> b) -> [a] -> [b]
20:28:33 <sereven> better ways to do this? http://hpaste.org/11654 need Data.List and format record for other stuff, but (.&.)  zip and filter to translate keyMask to string seems a little funky.
20:33:38 <twb> Now to learn about waitpid!
20:37:33 <twb> @hoogle IO a -> IO ()
20:37:33 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
20:37:33 <lambdabot> Control.Exception block :: IO a -> IO a
20:37:33 <lambdabot> Control.Concurrent runInBoundThread :: IO a -> IO a
20:38:30 <lispy> quick, someone say something in unicode
20:38:56 <twb> λικε τηισ?
20:39:04 <lispy> sweet, it works :) thanks
20:39:16 <lispy> but I can't seem to entry anything in unicode :(
20:39:32 <twb> ∀ x ∈ xs · yow! □
20:40:18 <twb> カワイイ？
20:40:22 <twb> Hmm, that didn't work.
20:40:30 <twb> I probably need "ka wa i -"
20:43:05 <twb> lispy: you ought to use Emacs for IRC, then you could use all of Emacs' input methods
20:46:39 <BMeph> ?????????
20:56:51 <mmorrow> , let xs = "∀ x ∈ xs · yow! □" in zip xs (fmap (utf8enc . (:[])) xs)
20:56:53 <lunabot>  [('\8704',"\226\136\128"),(' '," "),('x',"x"),(' '," "),('\8712',"\226\13...
20:57:18 <mmorrow> , let xs = "∀ x ∈ xs · yow! □" in zip xs (fmap (utf8enc . (:[])) . filter ((>127) . ord) . xs)
20:57:20 <lunabot>  luna: Couldn't match expected type `a -> [GHC.Types.Char]'
20:57:52 <mmorrow> , let xs = "∀ x ∈ xs · yow! □" in zip xs (fmap (utf8enc . (:[])) . filter ((>127) . ord) $ xs)
20:57:53 <twb> BMeph: that just showed up as question marks here.
20:57:54 <lunabot>  [('\8704',"\226\136\128"),(' ',"\226\136\136"),('x',"\194\183"),(' ',"\22...
20:58:10 <mmorrow> , utf8enc "□"
20:58:12 <lunabot>  "\226\150\161"
20:58:19 <rwbarton> , text "\12354"
20:58:20 <mmorrow> , ord "□"
20:58:21 <lunabot>  B
20:58:23 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
20:58:27 <rwbarton> > text "\12354"
20:58:28 <lambdabot>   あ
20:58:30 <mmorrow> , ord '□'
20:58:32 <lunabot>  9633
20:58:56 <mmorrow> oh nice.. HueghesPJ does utf8 now??
20:58:59 <mmorrow> s/e//
20:59:46 <mmorrow> > text "□"
20:59:48 <lambdabot>   □
21:00:15 <dolio> What did it used to do?
21:00:34 <mmorrow> hmm, i dunno. it must be utf8 encoding that though (i think)
21:00:47 <mmorrow> since
21:00:48 <mmorrow> > "□"
21:00:49 <lambdabot>   "\9633"
21:01:08 <rwbarton> I'd think that should be mueval's problem, not HughesPJ's
21:01:15 <dolio> @type text
21:01:15 <ivanm> I just found out that my connection disconnected... did anyone happen to reply to my question?
21:01:16 <lambdabot> String -> Doc
21:01:30 <mmorrow> ohh, yeah. it must be mueval
21:01:32 <pastorn> is there some special magic reason why i can't use top-level ifs in my StateT MagicalState IO a monad?
21:02:02 <mmorrow> pastorn: no. paste?
21:02:16 <mmorrow> well, i dunno what you mean by "top-level"
21:02:27 <dolio> show is what turns □ into \9633.
21:02:45 <rwbarton> > ç
21:02:46 <lambdabot>   Not in scope: `ç'
21:02:50 <mmorrow> but everything in mueval gets shown
21:02:52 <rwbarton> , ç
21:02:53 <lunabot>  luna: Not in scope: `
21:03:02 * dmwit_ bets on indentation
21:03:27 <dmwit_> pastorn: Make sure that the second and third line (if any) of an if clause are indented differently than the first line of the if clause.
21:03:35 <dmwit_> ...in any block.
21:03:38 <pastorn> http://hpaste.org/11655
21:03:46 <pastorn> mmorrow: there :)
21:03:52 <twb> What can I use in a do expression to get a no-op?
21:04:16 <twb> Something like putStr ""
21:04:17 <dmwit_> pastorn: It's that last case that's hosing you.
21:04:27 <dolio> return ()
21:04:28 <dmwit_> pastorn: You forgot the "do". ;-)
21:04:28 <rwbarton> twb: return () is often a good choice
21:04:33 <twb> Thanks.
21:04:41 <dmwit_> pastorn: (or just remove the "return ()" in the last line)
21:05:01 <pastorn> dmwit_: trying...
21:05:20 <pastorn> WORKED!
21:05:25 <pastorn> dmwit_: awsums
21:05:28 <pastorn> thanks!!
21:06:12 * pastorn is extatic
21:06:23 <pastorn> so extatic in fact that i will go home now
21:08:47 <lispy> hmmm
21:10:09 <twb> I would be "ecstatic", but whatever
21:11:41 * lispy can't quite get xterm settings right
21:12:05 <twb> I had that problem on OS X, too.
21:13:13 <lispy> I was able to use the nice monaco font and I was able to use utf8, but together I get gibberish
21:13:54 <twb> Does locale(1) indicate UTF-8?
21:14:21 <lispy> nope, maybe I should set that :)
21:14:30 <twb> locale -a will tell you what you can pick
21:14:46 <twb> LANG=en_AU.UTF-8 xterm -fa Monaco, for example.
21:15:14 <mmorrow> pastorn: it looks like it's the "return ()"
21:15:21 <twb> But note that locale names differ between places.
21:15:39 <mmorrow> pastorn: i don't think you need "return ()" at all
21:16:18 <mmorrow> and if you do, it needs to be either indented or unindented depending on how you mean it
21:16:54 <lispy> hmm...
21:17:00 <lispy> I think this is much closer
21:17:16 <mmorrow> pastorn: ah, just noticed it's already fixed :)
21:26:14 <lispy> ah, finally
21:26:21 <lispy> some settings i like via urxvt
21:26:35 <twb> http://twb.ath.cx/Preferences/.Xdefaults
21:27:07 <lispy> thatnks, I found a website that lists bunch of peoples ~/.* stuff.  I'll cehck yours too.
21:27:26 <lispy> dotfiles.org
21:29:14 <twb> Hmm, apparently emacs --daemon wasn't.
21:29:47 <lispy> heh
21:29:54 <lispy> that link was a 404 BTW :(
21:30:00 <twb> Try .Xresources
21:30:29 <twb> And yes, I know the content-type is wrong.  Busybox httpd isn't very smart.
21:42:29 <mmorrow> awesome! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CoreErlang-0.0.1
21:42:39 <mmorrow> looks like now i'll have to learn erlang
21:42:42 <twb> putStr is buffered; how do I output a prompt?
21:42:54 <dmwit_> hFlush
21:43:18 <mmorrow> or (hSetBuffering stdout NoBuffering) if you want to go there
21:47:54 <mmorrow> wow, haskell needs such a thing BAD http://www.it.uu.se/research/group/hipe/cerl/
21:48:00 <mmorrow> http://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf
21:48:08 <lambdabot> Title: The Core Erlang project
21:48:10 <lambdabot> Title: Core Erlang 1.0.3 language specification, http://tinyurl.com/644wpm
21:48:16 <mmorrow> Core Erlang is an intermediate representation of Erlang, intended to lie
21:48:16 <mmorrow> at a level between source code and the intermediate code typically found in
21:48:16 <mmorrow> compilers.
21:48:35 <mmorrow> Core Erlang should meet the following goals:
21:48:36 <mmorrow> ....
21:49:01 <mmorrow> (the goal i found most interesting:)
21:49:03 <mmorrow> Core Erlang should be straight-forward to translate to every interme-
21:49:03 <mmorrow> diate code used in any Erlang implementation; similarly, it should be
21:49:03 <mmorrow> straightforward to translate from Erlang programs to equivalent Core
21:49:03 <mmorrow> Erlang programs.
21:49:06 <mmorrow> </spam>
21:50:13 <ivanm> If I want to "darcs convert", do I have to clear and re-push to external repositories?
21:56:33 <teratorn> ivanm: I believe that is correct
21:56:43 * ivanm delays doing it for now then
22:17:49 <twb> dons: I'll paste how far I am with my shell...
22:24:02 <twb> http://hpaste.org/11656
22:25:46 <twb> I can't work out how to have a restricted import that includes ExitSuccess
22:25:58 <dmwit_> :t ExitSuccess
22:25:59 <lambdabot> Not in scope: data constructor `ExitSuccess'
22:26:07 <dmwit_> import TypeName(ExitSuccess)
22:26:23 <dmwit_> (Presumably ExitSuccess is a constructor for some data type.)
22:26:30 * twb tries
22:26:35 <dmwit_> well...
22:26:44 <dmwit_> import ModuleName (TypeName(ExitSuccess))
22:26:46 <twb> Works: import System.Exit (exitWith, ExitCode(ExitSuccess))
22:26:51 <dmwit_> yeah
22:34:00 <twb> OK, now I'm finally up to the hard part
22:34:10 <twb> Making my shell do I/O redirection
22:37:45 <DrSyzygy> Argh.
22:38:12 <DrSyzygy> My Game of Life implementation in Processing seems to have bad bugs, affecting the cellular automaton, but I can't locate the damn bugs.
22:39:13 <mmorrow> twb: if you're going to be working with Fds, you probably want System.Posix.IO
22:39:47 <lispy> XMonad.hs:1:0: file name does not match module name `Main'
22:39:48 <twb> Thanks, I was about to ask hayoo
22:39:50 <lispy> anyone seen that before?
22:40:01 <twb> lispy: are you using xmonad to recompile itself?
22:40:12 <twb> # Recompile (i.e. customize) xmonad without running it.
22:40:12 <twb> cd ~/.xmonad && ghc --make xmonad.hs -i -no-recomp -v0 -o xmonad-i386-linux
22:40:17 <dmwit_> lispy: Yes, but not with xmonad.
22:40:31 <lispy> I'm just trying to use the default xmonad.hs of import XMonad; main = xmonad defaultConfig
22:40:46 <mmorrow> twb: so you'll need (from System.Posix)
22:40:48 <mmorrow> createPipe :: IO (Fd, Fd)
22:40:52 <mmorrow> handleToFd :: Handle -> IO Fd
22:40:57 <mmorrow> fdToHandle :: Fd -> IO Handle
22:41:02 <mmorrow> it has dup and dupTo as well
22:41:21 <dmwit_> lispy: How are you compiling?
22:41:24 <mmorrow> the only catch when using fdToHandle is that the resulting Handle is in /nonblocking/ mode
22:41:28 <dmwit_> (Does xmonad --recompile complain?)
22:41:29 <mmorrow> so then you have to use
22:41:38 <mmorrow> hReady :: Handle -> IO Bool
22:42:07 <mmorrow> and do tests someway so you don't block forever by accident
22:42:15 <lispy> dmwit_: no it doesn't
22:42:19 <lispy> dmwit_: I was tring to use ghci
22:42:21 <twb> mmorrow: meh, kill -9 is right there
22:42:24 <mmorrow> hehe
22:42:30 <dmwit_> ok
22:42:53 <lispy> dmwit_: when I made any custom xmonad.hs xmonad refuses to start up
22:43:26 <dmwit_> I guess you're already complaining in #xmonad, right?
22:43:36 <twb> lispy: did you try the command I gave?
22:43:40 <lispy> dmwit_: oh hrm.  When I do xmonad --recompile instead of using ghci it doesn't crash on start up
22:43:50 <lispy> dmwit_: right, they didn't know
22:44:02 <dmwit_> lispy: I know.
22:44:09 <dmwit_> You can't exec two things in a row.
22:44:10 <lispy> twb: no because ghc has been givin me grief
22:44:10 <twb> That lets you skip and suck in xmonad --recompile and just run the command it would, directly.
22:44:15 <twb> Ah.
22:44:24 <dmwit_> lispy: "exec" replaces the current process.
22:44:30 <lispy> oh right
22:45:05 <twb> Strictly speaking, "exec" prevents the shell from fork(2)ing before it exec(2)s :-)
22:45:22 <dmwit_> Like I said. ;-)
22:48:56 <DrSyzygy> And there it works.
22:49:20 * DrSyzygy glares at obscure and shallow library array copy functions and the nasty java reference habits.
22:52:54 <lispy> dmwit_: I am totally lost as to why I effectively have no alt key under xmonad
22:53:22 <dmwit_> Alt is the mod key in the default settings.
22:53:48 <twb> dmwit_: I hate that, really I do.
22:53:50 <lispy> when I run xev and type my alt/option key it says Mode_switch
22:54:00 <dmwit_> twb: Me too.
22:54:01 <twb> dmwit_: a prefix of C-t would be less invasive.
22:54:18 <dmwit_> lispy: Check if one of your Ctrl keys is "stuck" down.
22:54:38 <lispy> dmwit_: and when I look at xmodmap I see mod1 Mode_switch (0x42), Mode_switch (0x45)
22:54:45 <dmwit_> (Mode_switch is usually the introduction to changing VTs.)
22:55:04 <dmwit_> Anyway, any more than that, and I'm firmly out of my league.
22:55:14 <lispy> how would I know if my ctrl key is stuck down?
22:55:15 <dmwit_> X's handling of the keyboard is never something I understood.
22:55:25 <dmwit_> lispy: Bang it a few times and try again. ;-)
22:55:38 <lispy> yeah, and I'm on osx, running x11, on dvorak, and ...
22:55:39 <dmwit_> (Happens to me every once in a while with shift.)
22:55:43 <lispy> oh, it's not stuck in that sense
22:58:06 <mmorrow> Mod(e_switch) :)
22:59:25 <lispy> what if I want to use KP_Enter, as my mod mask?
22:59:29 <lispy> any idea how to specify that?
23:00:00 <mmorrow> no (i haven't used xmonad for months, maybe a year now)
23:00:23 <dmwit_> You have to map it to one of the mod keys first.
23:00:35 <mmorrow> (not because it's not awesome, but because i upgraded my distro and was too lazy)
23:02:41 <lispy> ooooooo....I think I figured out the problem
23:03:57 <twb> KP_Enter is not a modifier, therefore it cannot be part of the mod mask.
23:04:12 <twb> Note that modifiers are not keys
23:04:28 <twb> e.g. Control is a modifier to which the keys (well, keysyms) Control_L and Control_R are typically bound.
23:05:31 <lispy> if I use mod2Mask things work
23:10:39 <lispy> yeah, kinda sucky to use mod2 because mod2+space brings up spotlight
23:11:17 <dmwit_> I like mod4.
23:11:22 <dmwit_> (win-key)
23:11:30 <dmwit_> But on a Mac...
23:13:02 <lispy> yeah, mod2 conflicts with everything...
23:17:04 <DrSyzygy> mod2 is apple?
23:27:05 <twb> On Apple USB keyboards, the ⌘ key sends the same code as the Windows key on a Microsoft USB keyboard.
23:27:14 <twb> Option = Alt
23:41:32 <DrSyzygy> twb: Ah.
23:52:30 <mmorrow> , utf8enc "⌘"
23:52:36 <lunabot>  "\226\140\152"
23:53:21 <Mzzz> Are there any explicit data constructors for type `IO a'?
23:53:51 <mmorrow> Mzzz: they're hidden, since if they were visible it'd be trivial to get unsafePerformIO
23:53:59 <rwbarton> , src ''IO
23:54:00 <mmorrow> , src ''IO
23:54:02 <mmorrow> haha
23:54:09 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
23:54:09 <lunabot>                     (#,#) (State# RealWorld) a)
23:54:14 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
23:54:14 <lunabot>                     (#,#) (State# RealWorld) a)
23:54:22 <mmorrow> cleaned up:
23:55:00 <mmorrow> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:55:46 <mmorrow> unsafePerformIO (IO f) = case f undefined of (# _, a #) -> a
23:56:28 <mmorrow> can "undefined" be used for unlifted values?
23:57:02 <mmorrow> either way though, the def would be similar
23:58:09 <rwbarton> it might be more like  case f realWorld# of (# _, a #) -> a
23:58:23 <Mzzz> Emm, I need some time do digest
23:58:26 <mmorrow> yeah i believe it is
23:58:51 <bd_> @src unsafePerformIO
23:58:51 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
23:58:52 <rwbarton> Mzzz: Anyways, the answer is "no" :)
23:59:20 <bd_> Mzzz: anything with # in is dark magic, deeply entwined with GHC's internals
23:59:21 <rwbarton> These are just implementation details in ghc
23:59:35 <mmorrow> Mzzz: so one thing the above def of IO means is that a value (IO a) isn't an a value wrapped in a box, but is a function from the current world state to a pair of a new state and an 'a'.
23:59:56 <mmorrow> (well, this is how GHC represents it)
