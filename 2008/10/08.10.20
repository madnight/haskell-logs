00:00:06 <rwbarton> StateT (Future r) -- We can change the future
00:00:12 <ski> mmorrow : `Future' there is not related to `Reactive', no
00:00:53 <ski> mmorrow : this was for a CGI laboration .. you can have a peek at the source if you want
00:01:07 <mmorrow> ski: i'd love to check it out. link?
00:01:48 <xinghua> @pf \x -> sum a b x d
00:01:49 <Axman6> @hoogle IORef
00:01:49 <lambdabot> Maybe you meant: bf pl
00:01:49 <lambdabot> module Data.IORef
00:01:49 <lambdabot> Data.IORef data IORef a
00:01:49 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
00:01:53 <jsn> pumpkin_: .ghci
00:01:53 <mmorrow> ReaderT (Past a) -- But we can't change the past
00:02:15 <pumpkin_> jsn: does that file just get executed at startup, or does it have a special syntax?
00:02:26 <jsn> just a second
00:02:27 <xinghua> @pf \x -> sum a b x d
00:02:27 <lambdabot> Maybe you meant: bf pl
00:02:38 <xinghua> @pl @pf \x -> sum a b x d
00:02:38 <lambdabot> (line 1, column 1):
00:02:38 <lambdabot> unexpected "@"
00:02:38 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:02:42 <xinghua> @ \x -> sum a b x d
00:02:42 <mmorrow> Cont (Future r) (Past a) -- Oh wait, just kidding
00:02:56 <xinghua> @pl \x -> sum a b x d
00:02:57 <lambdabot> flip (sum a b) d
00:03:16 <jsn> http://hpaste.org/11314
00:03:45 <jsn> pumpkin_: seems to be just the same
00:03:49 <jsn> so
00:03:56 <jsn> :m + <module>
00:04:01 <cads> have you guys heard of any low level languages (on the level of C) that make use of hindley-myer type inferrence and have first class functions and currying, and yet remain appropriate for systems programming?
00:04:15 <pumpkin_> jsn: great, thanks
00:04:25 <jsn> cads: maybe ATS? but i'm not sure
00:04:47 <rwbarton> ATS looks like a caml spit all over the screen
00:04:56 <pumpkin_> lol
00:05:08 <jsn> rwbarton: uhm, yes, so it's probably going to be pretty succesful
00:05:18 <mmorrow> cads: if one exists, it's probably written in haskell :)
00:05:19 <cads> hehe
00:05:30 <jsn> rwbarton: we are going to be writing it soon
00:05:48 <jsn> all of us
00:06:02 <jsn> it's the NBL that Steve Yeggie was talking about :)
00:06:10 <QtPlatypus> Isn't first class functions and currying contradictory with low leval?
00:06:12 * rwbarton hopes the next language he uses will be called 'Oleg'
00:06:23 <cads> QtPlatypus: probably :D
00:07:01 <QtPlatypus> Though c- has 1stclass functions IIRC
00:07:05 <QtPlatypus> c--
00:07:34 <jsn> javascript is suitably low level, and has first class functions
00:07:34 * quicksilver doesn't thinkg first class functions or currying are contradictory with low level.
00:07:48 <quicksilver> "low level" is a poorly defined term.
00:08:01 * jsn snickers
00:08:08 <quicksilver> I would say a language is "low level" if the programmer can predict with some accuracy what machine code will be produced.
00:08:23 <quicksilver> so that you can, for example, get hardware timing loops right.
00:08:30 <quicksilver> (according to this definition, C is pretty dire)
00:08:38 <mmorrow> http://moonpatio.com/docs/ghc/src/Cmm.html
00:08:39 <lambdabot> Title: cmm/Cmm.hs
00:08:48 <mmorrow> http://moonpatio.com/docs/ghc/src/CmmExpr.html
00:08:49 <lambdabot> Title: cmm/CmmExpr.hs
00:09:00 <cads> I just want to see a language other than C being used for mainstream kernel programming
00:09:17 <ski> (mmorrow : hang on .. trying to find out why i get `403 Forbidden' ..)
00:09:32 <mmorrow> ski: love those msgs
00:11:11 <Axman6> @hoogle boundsIOArray
00:11:11 <lambdabot> No results found
00:11:15 <Axman6> bleh
00:11:39 <Axman6> Data.Array.IO.getBounds doesn't seem to be what i want -_-
00:11:58 <Axman6> hmm, maybe it is
00:12:30 <Axman6> ok, it's not
00:13:45 <rwbarton> mmorrow: can you tell me what the NameFlavours NameU and NameL mean?
00:15:33 <inimino> uppercase and lowercase?
00:16:20 <ski> (mmorrow : ok, apparently i can't use an absolute symlink, relative works .. here it is <http://www.mdstud.chalmers.se/~md9slj/code/afp_lab2_s2.tar.gz>)
00:18:49 <crutcher> I'm looking for a function f such that : f 2 [0,1,2,3,4,5,6,..] == [[0,1],[2,3],[4,5],..]
00:19:04 <crutcher> I could write one, but am I overlooking something in the libs?
00:19:17 <rwbarton> crutcher: nope
00:20:13 <crutcher> does this come up all that often?
00:20:20 <Axman6> can't you use unfold for that?
00:20:44 <mmorrow> rwbarton: this paste and the one after it have the relevant parts of Syntax.hs: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=227#a244
00:20:53 <ski> mmorrow : btw, as this isn't the finished version, i'm not sure the whole thing works together at the moment (in the final version, i switched from shallow to deep embedding (or was it the other way around ? can't keep those straight), due to popular demand)
00:21:10 <rwbarton> crutcher: Yeah, it comes up reasonably often
00:21:17 <mmorrow> ski: cool
00:21:21 * mmorrow checks it out
00:21:54 <crutcher> Axman6: maybe? sorta what I'm asking, let me look
00:21:57 <Axman6> > let f n [] = Nothing; f n xs = Just (splitAt n xs) in unfold (f 2) [1..]
00:21:58 <lambdabot>   Not in scope: `unfold'
00:22:03 <Axman6> > let f n [] = Nothing; f n xs = Just (splitAt n xs) in unfoldl (f 2) [1..]
00:22:04 <lambdabot>   Not in scope: `unfoldl'
00:22:08 <Axman6> > let f n [] = Nothing; f n xs = Just (splitAt n xs) in unfoldr (f 2) [1..]
00:22:09 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
00:22:19 <Axman6> > let f n [] = Nothing; f n xs = Just (splitAt n xs) in unfoldr (f 2) [1..9]
00:22:21 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9]]
00:23:09 <Axman6> crutcher: look ok?
00:23:49 <crutcher> yeah, cept you probably want (f n) rather than (f 2)
00:24:22 <crutcher> wait, nevermind
00:24:38 <Axman6> crutcher: the f n part is in the in part of the let. like let x = 4 in x+x => 4
00:24:40 <Axman6> uh, 8
00:24:59 <crutcher> yeah, missread it.
00:25:18 <ski> mmorrow : the module of main interest is `Resume', btw
00:25:31 <crutcher> zip [1,2] [3]
00:25:56 <mmorrow> ski: wow, this is really interesting.
00:26:40 <ski> you're welcome :)
00:27:14 <mmorrow> ski: are you familiar with the (PLT?) scheme webserver that saves continuations somehow between requests? (i'm not), but what would you say the relationship between that general idea and the ideas in Resume/etc is?
00:27:55 <ski> i'm a bit familiar with the general idea
00:28:19 <Axman6> rawr, is there any way to get the bounds of an IOArray?
00:28:45 <ski> Wadler(?) did an `CGIArrow' in one of the arrow papers .. but here we were required to do a monad
00:29:29 <mmorrow> there's also this, but i haven't had time to go through it yet: http://okmij.org/ftp/Computation/Continuations.html#shift-cgi
00:29:29 <lambdabot> Title: Continuations and delimited control
00:29:54 <rwbarton> Axman6: getBounds?
00:29:55 <mmorrow> oh yeah, i do vaguely recall the CGIArrow
00:30:09 <Axman6> rwbarton: doesn't seem to like it :\
00:30:33 <rwbarton> Axman6: You might need some type signatures
00:30:49 <rwbarton> Axman6: getBounds a :: IO (Int, Int) or whatever
00:32:59 <Axman6> hooray! it was using a let clause (let (lo, hi) = bounds mem). needed to be (lo, hi) <- getBounds mem
00:33:07 <Axman6> thanks for the help rwbarton :)
00:33:22 <Axman6> it all compiles now. i wonder if i should tell the author...
00:35:03 <mmorrow> ski: in this one http://www.google.com/url?sa=U&start=3&q=http://www.cs.chalmers.se/~rjmh/Papers/arrows.ps&usg=AFQjCNFiBNd7B09yh8SeS9WMP5sKL3tfwg
00:35:06 <lambdabot> http://tinyurl.com/675qkl
00:35:13 <mmorrow> ugh
00:35:21 <mmorrow> www.cs.chalmers.se/~rjmh/Papers/arrows.ps
00:35:26 <ski> mmorrow : vague relation, i'd say  (it was some time ago i was writing this) .. this one caches/tables the results of all I/O operations (and only those) .. iirc `CGIArrow' stored the whole path to the `ask' operation (but maybe one could optimize, compressing out deterministic parts ..) .. (maybe unrelated, but these make me think of I/O-tabling in Mercury ..)
00:36:05 <ski> mmorrow : quite possibly (it was Hughes or Wadler, but i wasn't sure which)
00:36:29 <mmorrow> it's is in that one :)
00:36:31 <ac> @seen humasect
00:36:31 <lambdabot> I saw humasect leaving #haskell-overflow 3d 1h 44m 21s ago, and .
00:36:43 <rwbarton> mmorrow: the oldtype repository now has a function oldtype :: Type -> Q (Type, [Dec])
00:36:57 <mmorrow> ski: i'm reading about Mercury right now as well
00:37:07 <rwbarton> mmorrow: it outputs a list of newtype declarations and a type which (sometimes) uses them
00:37:10 <mmorrow> rwbarton: cool
00:37:39 <rwbarton> mmorrow: I wrote a simple front-end for my testing but it's not as good as the stuff in lunabot
00:38:14 <rwbarton> mmorrow: oh, but you can't just cleanNames all the declarations independently because the names are related between them
00:38:27 * mmorrow git pulls
00:39:17 <mmorrow> rwbarton: there's cleanNames and cleanNames' , cleanNames' will remove unique nums from tyvars, and cleanNames preserves them
00:39:43 <rwbarton> mmorrow: I see
00:40:01 <mmorrow> and then there's ppDoc and ppDoc'  etc
00:40:23 <ski> (mmorrow : re I/O-tabling .. in Prolog systems, in the interactive tracer/debugger, there's a common feature : `retry' that will "go back in time" from a predicate return node to when it's just about to be called (so you can skip and later retry if something interesting happened) ..)
00:41:58 <ski> (mmorrow : .. however, this is problematic in conjunction with I/O .. and since Mercury is pure, this needs to be taken care of, either by not handling it, or, with I/O-tabling which means that each I/O-state gets a unique identifier, and `get_char', etc store a table of what I/O already happened before, so retrying the I/O parts will just remember what has happened, instead of doing new I/O)
00:42:38 <mmorrow> ahh, so this is where ST comes in (?)
00:42:54 <ski> no, that's another thing
00:43:00 <mmorrow> oh
00:43:39 <ski> `store' is just Mercury:s adaption of `ST'
00:44:08 <rwbarton> mmorrow: forgot to push the last change, pull again
00:45:19 <mmorrow> oh, the I/O /state/ gets an ident, not the I/O thread getting a /type/
00:45:46 <mmorrow> ski: how does that work with parallelism?
00:46:08 <ski> (since they have uniqueness, they model the state directly, instead of as an abstract state thread, .. and so they use existential type for creating a new state `:- some [S] pred store.new(store(S)::uo) is det.' .. more or less `Store.new :: exists s. *(Store s)')
00:48:02 <moonpatio> rwbarton: cool types
00:48:04 <moonpatio> data ContTableEntry = Continuation (TypeOrPartial -> R TypeOrPartial) | Variable Name
00:48:04 <moonpatio> type ContTable = [((Env, Type), ContTableEntry)]
00:48:04 <moonpatio> newtype R a = R { runR :: ReaderT ContTable (ContT Type (StateT [Dec] Q)) a }
00:48:23 <moonpatio> data TypeOrPartial = Type Type | Partial Env [Name] Type
00:49:35 <ski> mmorrow : i don't know .. i haven't read much about parallelism in Mercury
00:54:01 * Saizan_ wonders what's the current topic
00:54:28 <mmorrow> , ppDoc $(lift . snd =<< oldtype =<< [t|Cofree (Coideal Maybe) Int|])
00:54:33 <lunabot>  newtype X_0 = X_0 ((,) Int ((,) X_0 (Maybe X_0)))
00:54:41 <mmorrow> , ppDoc $(lift . fst =<< oldtype =<< [t|Cofree (Coideal Maybe) Int|])
00:54:45 <lunabot>  X_0
00:54:51 <mmorrow> rwbarton: awesome
00:55:48 <mmorrow> Saizan_: ski has this interesting CGI code http://www.mdstud.chalmers.se/~md9slj/code/afp_lab2_s2.tar.gz
00:57:03 <mmorrow> ski: ah, so effectively representing states as closures
00:57:18 <ski> re ?
00:57:26 <mmorrow> nd so they use existential type for creating a new state `:- some [S] pred store.new(store(S)::uo) is det.' .. more or less `Store.new :: exists s. *(Store s)')
00:58:32 <ski> well, `Store s' would just be an abstract dummy type, representing the memory cells that has been (or will be) allocated relative to this state/store
01:00:16 <mmorrow> yeah, and the particular types of these memcells are unknown other than that they exist
01:00:53 <ski> there's also a typeclass `class Store' with `instance Store (Store s)' and `instance Store IOState', more or less
01:01:04 <mmorrow> hmm
01:01:11 <ski> (`class Store store' rather)
01:02:45 <mmorrow> , ppDoc $(lift =<< untype =<< [t|Cofree (Coideal Maybe) Int|])
01:02:49 <lunabot>  Fix (Biff (,) Identity (Lift_ (,) Identity Maybe)) Int
01:03:56 <ski> not using I/O-tabling, `Store s' and `IOState' would not be represented at all, or maybe as a dummy token value .. using I/O-tabling, it would be represented as some counter, that would be incremented at each atomic I/O-operation iirc  (don't recall if this tabling applied to `Store s' as well)
01:04:47 <mmorrow> oldtype and untype are rwbarton's and are at git://github.com/rwbarton/oldtype.git
01:05:02 <ski> (mmorrow : so i still don't know why you were saying "closures", there ..)
01:05:27 <mmorrow> hmm, i'm not so sure if i do anymore either
01:06:08 <mmorrow> well i do know what i meant, but i don't think it's very correct
01:06:27 <mmorrow> i've gotta read up on this "I/O-tabling" concept
01:07:53 <ski> (mmorrow : btw, there was some ugliness in `caseReplay' that i wasn't sure how to handle nicely .. at the time i was thinking of abstracting the interesting pattern out of `Replay' into a new monad transformer ..)
01:10:24 <ski> (mmorrow : <http://www.cs.mu.oz.au/research/mercury/information/papers.html#aadebug03-papeer> "Idempotent I/O for safe time travel" Zoltan Somogyi)
01:10:26 <lambdabot> Title: The Mercury Project: Papers and Presentations, http://www.cs.mu.oz.au/research/mercury/information/papers.html#aadebug03-papeer>
01:10:37 <Axman6> bleh, after all this work, finalkly got to something i have no idea how to fix -_-
01:11:47 <ski> (s/papeer/paper/)
01:14:06 <Axman6> anyone any good with parsing? i'm way out of my depth fixing this
01:14:30 <jsn> Axman6: link please
01:16:21 <Axman6> ok, sec. i'll have to paste a few things
01:18:15 <Axman6> ok, http://hpaste.org/11315 has the error, and Parser.hs (and ParseLib.hs)
01:19:33 <Axman6> if anyone thinks there's more code that's missing they need, i'll paste that too
01:20:36 <Axman6> "papply pProgram progString" is where the program string gets fed into the parser
01:23:28 <jsn> there does not appear to be a 'pProgram' in your post
01:24:44 <Axman6> line 503 of Parser.hs
01:25:15 <Axman6> hmm... maybe there's a line limit
01:25:49 <Axman6> well there's http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Projects/project06/src/Parser.hs i'm not surfe if i've modified the file since downloading it thouth
01:25:52 <lambdabot> http://tinyurl.com/6kmzsn
01:25:53 <Axman6> though*
01:26:13 <Axman6> i haven't apparent;y
01:26:24 <Axman6> rawr, really need to get used to this keyboard
01:26:54 <jsn> okay, it will help a lot if you can narrow the problem a bit
01:27:02 <jsn> 500 lines is a lot of lines
01:27:39 <Axman6> i know, but it's not my code, and i wouldn't know what to narrow for you :\
01:27:40 <jsn> what is the behaviour of '+++' ?
01:27:53 <Axman6> p +++ q            = first (p `mplus` q)
01:28:00 <jsn> if add another line to the assembly, what happens?
01:28:01 <ski> (mmorrow : i hope you manage to decipher at least some part of the code in `Resume' ..)
01:28:38 <Axman6> first (P p)        = P (\inp -> case p inp of []     -> []; (x:xs) -> [x]) (first :: Parser a -> Parser a)
01:29:40 <Axman6> jsn: it parses fine
01:29:42 <mmorrow> ski: heh, for sure. it's very clear and commented well :)
01:29:56 <jsn> Axman6: the whole thing parses fine?
01:30:10 <Axman6> yeah, there's no errors, it just parses incorrectly
01:30:18 <jsn> uhm, eh
01:30:35 <jsn> Axman6: it is hard for me to interpret the meaning of your utterance
01:30:52 <jsn> i mean, copy the line below BNE again
01:30:57 <jsn> and see what happens
01:31:34 <jsn> does it make the same mistake (failure on BNE) or a different one?
01:32:42 <Axman6> it seems to be all the branch instructions, bne, beq, bl
01:32:47 <Axman6> it's very odd...
01:32:59 <Axman6> hmm, i need some way to debug this better...
01:34:20 <Botje_> use parseTest to test your individual combinators?
01:35:04 <Axman6> huh, seems to parse it correctly. maybe i'm wrong about the parser
01:36:50 <Axman6> hmm, how do i add another module to be loaded in ghci? i need :l Assembler and :l ExecutionUnit at the same time
01:37:16 <Axman6> ah, found it. never knew you could use :l Aba Cdc
01:39:26 <Deewiant> There really should be a :l +Foo
01:39:35 <Axman6> yeah
01:39:38 <Zao> import Foo
01:39:58 <Zao> :m +Foo
01:40:03 <Deewiant> :m + is not the same thing
01:40:09 <Deewiant> import might be; am trying
01:40:26 <Deewiant> no, import is the same as :m +
01:40:44 <Zao> Deewiant: As Axman6 talked about modules, I assume he wanted :m semantics.
01:40:56 <Deewiant> Those give "module 'foo' is not loaded" if it's not loaded
01:41:17 <Deewiant> whereas what we wanted was specifically to load it
01:41:32 <Deewiant> without losing what was loaded previously
01:42:02 <quicksilver> ":m" is just about bringing things into scope
01:42:06 <quicksilver> it doesn't change what is loaded.
01:42:12 <Deewiant> Exactly.
01:42:31 <Deewiant> But there's no ":l +foo", only ":l foo" which unloads what used to be loaded.
01:46:10 <Axman6> hmm, ok, instructions aren't getting encoded as they should
01:49:33 <Axman6> ok, it might be time to email the author and see if he has any idea what he was thinking 8 years ago
01:55:04 <currycho> hi all
01:57:14 <currycho> i have this data type data Sequence a = Unit a | Nonunit (Sequence a) a , i need to make a function to return first element , anyone can help me please ?
01:58:10 <Botje_> what do you mean "first element" ?
01:59:47 <Deewiant> well, looks like Sequence is just a non-empty list
01:59:56 <currycho> really it 's the last element
02:01:34 <Botje_> and how is the "last" element defined?
02:01:38 <currycho> i have to "seek" in the sequence
02:02:04 <currycho> Deewiant: that's it
02:03:51 <Botje_> sounds like a simple recursive process to me
02:04:00 <Botje_> your base case is last (Unit x) = x
02:04:06 <currycho> if the sequence is Unit , last element is a , if sequence is nounit last element is a recursive call
02:04:16 <Botje_> great, so write it :)
02:05:05 <currycho> Botje_: mmm sorry but i am n00b yet , try to help me in the recursive call ;)
02:05:32 <Botje_> what's troubling you?
02:05:38 <Botje_> pattern matching on NonUnit ?
02:05:43 <currycho> yes
02:05:50 <Botje_> last (Nonunit seq x ) = ...
02:07:31 <Botje_> and the last bit of fish is *drumroll*
02:07:39 <Botje_> last (Nonunit seq x) = last seq
02:07:55 <Botje_> combine that with last (Unit x) = x from above and you have your function
02:09:31 <currycho> i got lost Botje_ :( sorry but i 'm beggining
02:10:08 <Botje_> where'd you get lost?
02:13:15 <currycho> here
02:13:16 <currycho> last :: Sequence -> a last :: (Nonunit a ) = a last Nonunit (Sequence a ) = last ....
02:13:44 <currycho> last Nonunit (Sequence a ) = last ....
02:19:58 <Botje_> last :: (Nonunit a ) = a is nonsense
02:20:06 <`Ash> someone assist me with haskell coursework pleaseee
02:21:57 <Botje_> currycho: okay
02:22:04 <Botje_> so you have a TYPE called Sequence a
02:22:11 <Botje_> with two DATA constructors Unit and Nonunit
02:22:28 <Axman6> `Ash: people will; help you if you ask thegir ht questions. they won't do your homework for you however
02:22:42 <`Ash> im not asking them to do my work
02:22:43 <`Ash> http://hpaste.org/11316
02:22:46 <`Ash> thats what i have so far ^
02:22:50 <Botje_> the Unit case has a single value attached to it
02:22:58 <Axman6> rawr, people will help you if you ask the right questions* -_-
02:23:03 <Botje_> and the Nonunit case has a Sequence a and an a
02:23:06 <Botje_> currycho: with me so far?
02:23:13 <`Ash> i need to be able to connect the functions together using a user inputted variable (message).
02:23:17 <Axman6> damn keyboard
02:23:22 <`Ash> so they just work auto
02:23:51 <Axman6> well "PutStrLn = "Enter Message:" message" doesn't make any sense
02:24:00 <`Ash> but i dont get how i can get my program to say "enter message here!"
02:24:07 <`Ash> yeah thats what i thought i needed to enter the message
02:24:08 <Axman6> PutStrLn "Enter Message: "
02:24:47 <Saizan_> putStrLn "Enter Message: " actually
02:24:59 <`Ash> but how do i then save whats been put in
02:25:19 <Saizan_> by using getLine, like on the second line
02:25:20 <`Ash> because the same thing needs to be passed through all the functions automatically
02:25:29 <currycho> Botje_: yes
02:25:37 <Axman6> `Ash: you need to then use that message in another function after the getLine
02:25:55 <Axman6> `Ash: does it get passed form one to the the next?
02:26:01 <`Ash> yeah thats what i need. but how do u do that? variables in haskell are laame compared to java lol
02:26:08 <Saizan_> nothing is going to happen "automatically"
02:26:17 <Axman6> there's no such thing as a variable in haskell ;)
02:26:40 <BeelsebobWork> `Ash: when you get further, you'll understand why variables as in Java are a bad thing (TM)
02:26:44 <`Ash> it needs to be a user friendly program tho. a random person isnt going to understand that they have to type in 'replaceDig message'
02:26:50 <`Ash> isnt there a way around it ?
02:27:08 <Axman6> `Ash: they're not going to have to do that
02:27:21 <`Ash> i have to do that atm to get it to work
02:28:01 <Axman6> well that's because you haven't told it do actually do anything except print a line of text and read a message
02:28:19 <Saizan_> if you put something like "print (replaceDig message)" as the last line of main, then the user just needs to enter the message
02:28:27 <currycho> Botje_: sorry i was reading
02:28:47 <Saizan_> `Ash: i think you're confusing the ghci repl with the frontend of your program
02:28:59 <`Ash> cheers saizan. but it needs to split the message into characters, then check the characters for a digit before then right ?
02:29:08 <Axman6> `Ash: so, what order do you need to use your functions?
02:29:41 <`Ash> the order is right. apart from i need to split the message before replaceDig
02:30:10 <Saizan_> there's no order in definitions
02:30:11 <Axman6> what order is right, do you mean you need replaceDig -> remNonAlpha -> ...?
02:30:20 <`Ash> yeah axman
02:30:32 <Axman6> well, you need to tell the program that
02:30:35 <`Ash> i havnt got anything to say 'go here' or 'use this variable'
02:30:38 <Botje_> currycho: okay
02:30:44 <Botje_> so given a value of type Sequence a
02:31:01 <Botje_> you can find out which case (Unit or Nonunit) you have by pattern matching
02:31:16 <BeelsebobWork> `Ash: just so you know repeatString can be replaced with repeatString secret password = take (length secret) (concat (repeat password))
02:31:17 <pao> Ash... maybe is better to study before doing homeworks :-)
02:31:21 <`Ash> overall the program is supposed to change a message from something like 'message 42: hello' to 'MESSAGEFOURTWOHELLO'
02:31:34 <`Ash> then encode it to a keyword, to turn it into random letters.
02:31:43 <BeelsebobWork> encodeListPairs = map encodePair
02:31:51 <`Ash> we've only been doing haskell for a couple weeks
02:32:34 <Axman6> `Ash: take a look at http://hpaste.org/11316#a1
02:32:35 <Botje_> currycho: so you can use eg "last (Unit x) = x" to get the value out
02:32:44 <Axman6> BeelsebobWork: you take a look too, make sure i got it right :P
02:32:50 <Saizan_> yeah, but you should be aware that if you want to apply a function to a value you've to do that, defining the functions in your module isn't going to feed the input through them
02:32:57 <Botje_> the Nonunit case is similar: "last (Nonunit seq x) = x"
02:33:03 <BeelsebobWork> Axman6: doesn't look like yours is gonna do anything much interesting ;)
02:33:10 <Botje_> so you just pattern match the data you get, assign to variables, and use them
02:33:12 <Botje_> eh
02:33:17 <Axman6> i know, but it shows what needs to be done next...
02:33:18 <currycho> mmmm
02:33:21 <Botje_> that should be last (Nonunit seq x) = last seq
02:33:21 <Botje_> :)
02:34:36 <currycho> Botje_: ok i 'm going to write it , please tell me if anything goes wrong
02:35:15 <gal_bolle> i've got a function f which takes many parameters, but directly uses only few of them, and whose body is made mainly of where clauses.
02:35:25 <`Ash> is it simular to programming in assembly language, where as i put all the function calls at the top ... it recognising them, runs through that function, then goes back up to the next ?
02:35:39 <gal_bolle> I'd like to turn it into a reader monad action, but then i can't use where clauses anymore
02:35:45 <Saizan_> `Ash: No.
02:35:52 <gal_bolle> is there a canonical solution to this situation
02:35:54 <gal_bolle> ?
02:35:58 <Axman6> `Ash: no, not at all
02:36:24 <`Ash> i dont get how its just gunna recognise which variable needs to be used
02:36:28 <gal_bolle> (most of its arguments are passed as such to auxiliary functions which i've already put inside the Reader monad)
02:36:41 <Axman6> `Ash: there arten't variables. did you have a look at what i pasted?
02:36:52 <Saizan_> `Ash: if you define function "foo" and "bar" and you need to call them on some string from the user you need to wrte something like do str <- getLine; print (foo (bar str))
02:37:04 <`Ash> yeah u put the putstrln message in
02:37:18 <Saizan_> `Ash: you don't set the value of variables, you can't do that. you just apply functions to values
02:37:19 <Axman6> and you see how i used that message 'variable'?
02:37:21 <`Ash> but theres noone below that (in my code) which says 'use message'
02:37:45 <gal_bolle> (I'd need to use things i get from asks in a where clause)
02:37:47 <Axman6> `Ash: it need to be in main to use that
02:38:03 <`Ash> im used to programming in java, where u have to say, bold, underlined, in bit flashy writing ... 'use this variable!'
02:38:19 <paulus> hi guys, anyone here using visual haskell?
02:38:28 <lispy> paulus: not recently
02:38:29 <Axman6> i've just finished writing Asteroids in java
02:38:45 <Saizan_> gal_bolle: use <- inside the do-block?
02:38:52 <lispy> gal_bolle: oh, so the problem is that you cannot reference things from the do block in the where clause?
02:38:56 <gal_bolle> yes
02:39:03 <Saizan_> `Ash: what you know about java doesn't apply here
02:39:08 <Saizan_> `Ash: just forget about it.
02:39:10 <lispy> gal_bolle: there was a thread about this on haskell-cafe in the last 2 months
02:39:29 <paulus> lispy: did you ever get it working?
02:39:55 <Axman6> `Ash: ok, have a look at this then: http://hpaste.org/11316#a4
02:40:35 <gal_bolle> lispy: i'm trying to make SelectChanges monadic in darcs (or at least, readable)
02:40:47 <lispy> paulus: yes for me it would work immediately
02:40:58 <lispy> gal_bolle: awesome
02:40:59 <`Ash> ok axman. so basically ... i just put that after every function, to start a using another function?
02:41:06 <lispy> gal_bolle: I'm trying to find that thread
02:41:14 <Axman6> `Ash: put what?
02:41:18 <`Ash> further down the line im gunna have different 'variables' to just message.
02:41:30 <`Ash> i dont get how the program is going to know which one i meen, without defining it
02:41:47 <Axman6> `Ash: well then you can use let clauses if you want
02:42:01 <paulus> lispy:It did work for the simple hello world, but as soon as I try to import some other modules i get "Could not find module `Char':
02:42:01 <paulus>       it is a member of package haskell98, which is hidden
02:42:13 <Saizan_> `Ash: does this make sense? http://hpaste.org/11316#a5
02:42:22 <ozy`> > 0 ^ 0 -- is this intentional?
02:42:24 <lambdabot>   1
02:42:35 <Axman6> :|
02:43:13 <Axman6> @src (^)
02:43:14 <lambdabot> x ^ 0            =  1
02:43:14 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
02:43:14 <lambdabot>   where f _ 0 y = y
02:43:14 <lambdabot>         f x n y = g x n
02:43:14 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
02:43:14 <Saizan_> `Ash: the only way to make the "program know which one you mean" is to pass values as arguments to other functions
02:43:16 <lambdabot>                       | otherwise = f x (n-1) (x*y)
02:43:18 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
02:43:24 <`Ash> i know what concat does, not too sure on map
02:43:28 <`Ash> unless map's just a pointer
02:43:33 <Axman6> no
02:43:41 <Axman6> > map (+1) [1..10]
02:43:42 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
02:43:46 <Axman6> > map (+5) [1..10]
02:43:48 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
02:44:00 <Axman6> > map toUpper "Hello, world!"
02:44:02 <lambdabot>   "HELLO, WORLD!"
02:44:08 <Botje_> paulus: try importing Data.Char
02:44:08 <Saizan_> `Ash: map applies the given function to all the elements in the list
02:44:11 <ozy`> > map tail (words "Haskell is pretty neat")
02:44:12 <`Ash> so maps like an action
02:44:12 <lambdabot>   ["askell","s","retty","eat"]
02:44:22 <Botje_> some time ago haskell's module hierarchy got reshuffled
02:44:25 <lispy> paulus: sounds like it's not working correctly with your version of cabal
02:44:30 <Axman6> `Ash: map applies a function to every element of a list
02:44:39 <`Ash> k
02:44:52 <ozy`> `Ash: more importantly, map returns a completely new list
02:44:53 <`Ash> so i'll need to use it when checking for digits before replaceDig
02:44:56 <hugo_> hello
02:45:04 <`Ash> ok so i wont need to use it :P
02:45:27 <Saizan_> `Ash: what's important, however, is that there's no mutation, no variables to set, you need to pass values into functions
02:45:29 <Axman6> well, you m ight notice i just rewrote one of your functions, capString ;)
02:45:37 <ozy`> `Ash: I for one have no idea what you'd be using it for, anyway...
02:45:51 <`Ash> ive been told to use capString as a function tho. I think i get marks for using it.
02:46:00 <`Ash> i know its the same as map toUpper
02:46:03 <chr1s> @seen dcoutts
02:46:03 <lambdabot> dcoutts is in #ghc, #haskell, #gentoo-haskell and #haskell-soc. I last heard dcoutts speak 4h 32m 52s ago.
02:46:10 <`Ash> BeelsebobWork did the same :P
02:46:26 <Axman6> `Ash: fair enough. but it's good to know, so you don't need to keep reinventing the wheel :)
02:46:44 <currycho> Botje_: please tell me if this is wrong http://rafb.net/p/YBANl636.html thanks :)
02:46:45 <lambdabot> Title: Nopaste - No description
02:46:46 <paulus> Botje: thanks that worked. A few months ago I got going with haskell 6.8.2 and emacs, seems the modules are in different places with ghc 6.6 which is shipped with visual shaskell
02:47:08 <Axman6> anyone know what happened to the hpaste bot?
02:47:34 <Botje_> currycho: uh, you misspelled Nonunit
02:47:43 <Botje_> and you can't use Sequence as a variable name
02:47:50 <Botje_> variables can only start with lowercase letters
02:48:13 <ozy`> `Ash: ha! you're here for homework help?
02:48:20 <`Ash> yeah :D
02:48:28 <xenoblitz> guys ... any one can help me with some gtk2hs problems I am having? I need my window to have a State variable which is updated say every 1second and then a drawingarea is redrawn... from help given to me yesterday i know i must use timeoutAdd I just have no idea where and how to write it using gtk2hs :S So its like this 1second has elapsed -> Update State -> Redraw -> Wait 1 second....
02:48:43 <xenoblitz> an example/tutorial would be awesome
02:49:55 <currycho> thanks Botje_
02:49:56 <xenoblitz> sorry about that big msg xD
02:51:02 <Axman6> `Ash: something else you might like to use with the replaceDig function, is replaceDig a = toUpper a, that way you can change capString to capString (x:xs) = (replaceDig x):capString xs
02:51:20 <gal_bolle> lispy: is it related to the 'monad subexpression' thread?
02:52:14 <Saizan_> xenoblitz: i think it's something like "timeoutAdd (updateState >> redraw) 1" in your main, before calling mainLoop
02:52:31 <`Ash> can i not just change the capstring anyways, since replaceDig does example the same as a = toUpper a
02:52:40 <quicksilver> Saizan_: perhaps it also has to re-add itself?
02:52:50 * quicksilver has never used gtk
02:53:12 <Axman6> `Ash: actually, i'm wrong, forget what i said ;)
02:53:12 <`Ash> ive been told to use the functions ive used, changing them/simplfying them would lose marks.
02:53:19 <Saizan_> quicksilver: it says it keeps calling the action as long as it returns True
02:53:22 <Axman6> fair enough
02:53:32 <`Ash> all i need is to be able to pass a 'variable' through each function
02:53:40 <Axman6> i see
02:53:49 <Axman6> well, maybe you want to look into (.)
02:53:50 <quicksilver> Saizan_: ah, ok :)
02:53:52 <Axman6> @src (.)
02:53:53 <lambdabot> (f . g) x = f (g x)
02:53:53 <`Ash> the code all works as seperate functions. but it doesnt work as 1 program.
02:54:19 <Axman6> > (f . g . h) x
02:54:20 <lambdabot>   Add a type signature
02:54:25 <xenoblitz> Saizan_: thanks but i still have no clue how to keep the state variable and update/refresh
02:54:26 <Axman6> > (f . g . h) x :: Expr
02:54:27 <lambdabot>   Add a type signature
02:54:32 <Axman6> -_-
02:54:34 <Saizan_> `Ash: we showed you multiple times how to pass values between functions, and it's very simple, you just apply them
02:54:39 <Axman6> > ((f . g . h) x) :: Expr
02:54:40 <lambdabot>   Add a type signature
02:55:02 <Saizan_> xenoblitz: it boils down to using an IORef in the end
02:55:24 <Axman6> bleh
02:56:20 <`Ash> would replaceDig work on a string of chars, or would i have to split it ?
02:56:25 <Axman6> `Ash: do you know about type signatures? "capString :: String -> String" etc.
02:56:33 <xenoblitz> Saizan_: how possible is it use IORef with more than one thread if the need arises?
02:56:33 <`Ash> yeah
02:56:45 <Axman6> `Ash: it works on a list of Char, which is a String
02:56:51 <Axman6> [Char] = String
02:57:13 <`Ash> so 'hello45' would automatically turn into 'hellofourfive' ... without me having to split?
02:57:17 <Axman6> xenoblitz: thought that was one of the things they were for
02:57:22 <quicksilver> xenoblitz: then you use an MVar
02:57:38 <`Ash> the function on its own works for 1 digit, but it doesnt work for more then 1.
02:57:40 <Axman6> what quicksilver said...
02:57:46 <xenoblitz> is there essentially a difference between MVar and IORef?
02:57:49 <quicksilver> yes.
02:57:59 <quicksilver> the essential difference is they have totally different APIs.
02:58:04 <quicksilver> ;)
02:58:13 <xenoblitz> ah but they work the same way?
02:58:14 <quicksilver> one has an API for sane threaded use, the other one does not.
02:58:27 <quicksilver> they are both mutable cells.
02:58:28 <xenoblitz> so MVar it is
02:58:43 <Axman6> :t (\c -> [c]) 'a'
02:58:44 <lambdabot> [Char]
02:58:57 <Axman6> `Ash: you might find that useful
02:59:43 <sereven> `Ash: main is the "program". The rest is definitions. So far you have only defined your functions, but haven't applied them to anything in main. You still need to use them all on values from the user or results from applying them like in http://hpaste.org/11316#a5
02:59:48 <wjt> :t (:[{- you have spurned the Box Monster! prepare to die! -}]) 'a'
02:59:49 <lambdabot> [Char]
02:59:52 <Axman6> > map (\c -> [c]) "abcde"
02:59:53 <lambdabot>   ["a","b","c","d","e"]
03:00:15 <Axman6> > concat (map (\c -> [c]) "abcde")
03:00:16 <lambdabot>   "abcde"
03:01:04 <ToRA|MSR> > "abcde" >>= return
03:01:06 <lambdabot>   "abcde"
03:01:37 <Axman6> ToRA|MSR: not very helpful for someone who's used to java, and has ony beren using haskell for two weeks ;)
03:02:19 <ac> anybody else ever have the problem of GHC just randomly GOBBLING memory during the linking phase?
03:02:32 <Axman6> hmm, i need to rewrite my first haskell assignment using all the things i've learned since then...
03:02:55 <ac> like every 100 times I compile a program, GHC gobbles all the available memory and then crashes
03:03:00 <pao> pls everyone... I don't think #haskell is the best place to write a gentle tutorial on haskell...
03:03:26 <quicksilver> pao: ?
03:03:37 <quicksilver> pao: surely helping people is exactly what #haskell is for?
03:03:46 <`Ash> pao: its for general haskell help right? ... does it matter that a problem is a basic one?
03:03:54 <quicksilver> `Ash: absolutely not.
03:04:02 <quicksilver> `Ash: please continue to ask questions ;)
03:04:40 <`Ash> the only question is switching between functions. my functions work seperately, but not together.
03:05:04 <`Ash> how would i, after a function is finished, put the message into the next function
03:05:16 <pao> quicksilver: do you think #haskell is the place to learn haskell from scratch? `Ash does seem to have _no_ idea of what haskell is all about...
03:05:16 <Axman6> f (g x)
03:05:21 <quicksilver> pao: Yes, I do.
03:05:27 <Axman6> g is called with x, then its result is passed to f
03:05:34 <quicksilver> pao: meta-discussion to #haskell-blah, please.
03:05:40 <ac> pretty much what I did... I mean I read a gentle introduction (hah), but I asked all sorts of stupid questions
03:06:04 <quicksilver> (Actually I don't claim it's the best place, but it's *a* place, and should remain so)
03:06:05 <Axman6> you can also use (f . g) x, or (f . g . h) x, which is the same as f (g (h x)))
03:06:24 <Axman6> "lives (Cell x y r pa life pLife) -- haha, yuck
03:06:39 <LeCamarade> #haskell is very nearly the only place to learn Haskell from scratch.
03:06:40 <ac> so nobody else has the random linking explosios issue?
03:07:24 <Baughn> LeCamarade: I'd like to think real world haskell is a good place, too
03:07:38 <`Ash> it isnt :P ive been there.
03:07:52 <hugo_> is there any work related to virtual machines in haskell ?
03:08:04 <lispy> hugo_: how do you mean?
03:08:04 <Baughn> hugo_: Virtual machines.. of what sort?
03:08:19 <LeCamarade> RWH is a bit heavy. Most people learning "from scratch" have never recursed. They don't get why map doesn't use a for loop, et cetera.
03:08:21 <Baughn> `Ash: Then the author would benefit from your unique perspective. Most of the ones who've looked it over already know haskell, after all.
03:08:22 <Axman6> hugo_: i've been playing with an ARM virtual machine for the last week written in haskell. it's pretty basic, but it works
03:08:24 <`Ash> not saying ive read them all cover to cover. but most online tutorials lack a lot of the basic stuff ... they go from downloading hugs, to maths problems, straight into serious coding.
03:08:28 <lispy> hugo_: there is lambdaVM where a special version of GHC emits java bytecode :)
03:08:31 <LeCamarade> In the channel, you can see them err and guide them well. With a bot.
03:08:37 <LeCamarade> ?bot
03:08:37 <lambdabot> :)
03:08:44 <ac> Baughn: are you Bryan O'Sullivan? :-P
03:08:49 <Baughn> `Ash: Well, you'd probably benefit from combining it with SICP. ;)
03:08:51 <Baughn> ac: No.
03:08:52 <Deewiant> ac: no, bos is.
03:08:57 <LeCamarade> Axman6: Source, friend. Source!
03:08:59 <Deewiant> preflex: seen bos
03:08:59 <preflex>  bos was last seen on #haskell 2 days, 11 hours, 27 minutes and 22 seconds ago, saying: it's an abstract sausage generator factory factory.
03:09:00 <LeCamarade> :o)
03:09:17 <LeCamarade> `Ash: You're home here. :o)
03:09:18 <Axman6> LeCamarade: http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Lectures/index.html
03:09:20 <lambdabot> Title: Lectures, projects, http://tinyurl.com/639v6u
03:09:36 <Axman6> once you get to project 6, it breaks though :\
03:09:39 <LeCamarade> `Ash: You wanted to return the value from calling funcition1 to use it in calling function2, right?
03:09:39 <quicksilver> `Ash: did you look at 'YAHT' or the gentle introduction?
03:09:40 <Axman6> i've emailed the author
03:10:05 <hugo_> allright, nice... i've been asked to study a virtual machine for a course im taking :/
03:10:08 <LeCamarade> Gentle intro: gentle in name only.
03:10:20 <`Ash> Baughn: the main problem with the tutorial, is its good for learning the very basics (which i learn at uni) - the maths stuff, etc ... and it's good for people who already know a lot of haskell, who need to solve a specific problem. There's nothing inbetween the two.
03:10:44 <LeCamarade> http://arcanux.org/lambdacats.html
03:10:45 <lambdabot> Title: Lambdacats
03:10:57 <Baughn> `Ash: I see what you mean, but I'm not sure how to solve it. What's between the two is.. experience with the language. It can't really be gained from a book.
03:11:07 <LeCamarade> I wish I could like #link to some cat there. There is one on "Gentle Intro".
03:11:21 <pao> `Ash: as it has been already pointed by quicksilver ... Yet Another Haskell Tutorial is very good ...
03:11:33 <`Ash> been there too
03:11:34 <Baughn> `Ash: Lurking in #haskell worked, too
03:11:43 <`Ash> and also looked at the one with weird pictures
03:11:49 <lispy> someone just said today that 48 hour scheme was very kind to them
03:11:51 <pao> `Ash: if you want to have a broader look try "real world haskell"
03:12:24 <quicksilver> pao: that's the book `Ash was just talking about.
03:12:52 <`Ash> the 3 books ive looked at are RWH, YAHT ... and the weird one with the pictures.
03:13:33 <`Ash> "learn you a haskell"
03:13:37 <Baughn> `Ash: With the ungrammatical name? That one's very new, and not really done
03:13:47 <`Ash> yeah that one
03:13:48 <lispy> lol, "the weird one with the pictures."
03:13:53 <`Ash> :D
03:14:05 <`Ash> they knew what i ment ;)
03:14:05 <lispy> say no more, we know the one :)
03:14:25 <Saizan_> `Ash: i guess they all contain examples of working programs, i remember yaht having a simple CLI guessing game in the first chapter, you could look at that for inspiration on how to structure your program, maybe?
03:14:46 <lispy> `Ash: a beginner told me today that this is a nice one: http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
03:14:47 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
03:14:59 <`Ash> i'll take a look
03:15:21 <osfameron> how long would it take to write a COBOL ?
03:15:25 <ac> anybody know how to turn on antialiasing in OpenGL?
03:15:45 <ac> "samples" is just a GettableStateVar
03:16:20 <Peaker> Would a class like Applicative without Functor as a base class, without pure (that only has <*>) be useful?   Conal's Futures require a Monadic interface to be able to use a future future, but I think something less expressive could work too
03:16:25 <ac> I've tried "multisample $= Enabled" but it's definitely not enabled. I definitely don't want subpixel antialiasing
03:16:43 <ac> and that's the only other thing in the docs
03:16:47 <Baughn> ac: #opengl should know
03:17:09 <quicksilver> ac: multisample $= Enabled is right.
03:17:13 <Baughn> The opengl binding is pretty much just a binding, so you do it the same way as in C
03:17:13 <quicksilver> Baughn: no, they won't.
03:17:21 <quicksilver> Baughn: ##opengl knows nothing about HOpenGL.
03:17:24 <Baughn> ..
03:17:27 <quicksilver> well, except me.
03:17:40 <quicksilver> ac: you also need to request a multi sampling buffer as your context, though.
03:17:41 <ac> quicksilver: ;). I can count on you for OpenGL help
03:17:46 <Saizan> Peaker: that's a bit like Monoid
03:17:51 <ac> quicksilver: that's what I'm missing
03:17:52 <Baughn> Right. How do you decide how /many/ samples to take?
03:18:04 <quicksilver> ac: that depends on what toolkit you're usin.g
03:18:12 <ac> quicksilver: GLFW
03:18:14 <Baughn> quicksilver: See, #opengl would've known that. ;)
03:18:16 <Peaker> Saizan: no mzero though
03:18:29 <quicksilver> Baughn: they'd have looked pretty blank at "multisample $= Enabled" though.
03:19:03 <quicksilver> ac: with glfw, I have no idea ;)
03:19:17 <Peaker> Saizan: I think the ability to manipulate a value inside the "container" with turing-complete code may hinder some kinds of useful things a library/framework can do, compared to one where you can only manipulate the value using the library's limited functions
03:19:17 <quicksilver> ac: but it is surely one of the parameters you pass when you ask for a context
03:20:21 <ac> the FSAASamples WindowHint looks prommising
03:21:52 <ac> quicksilver: what's an appropriate number?
03:22:01 <Baughn> Peaker: On the flip side, being able to manipulate a value inside a container (Functor?) is quite useful.
03:22:04 <Saizan> Peaker: i concur, but it so convenient for the user :)
03:22:14 <quicksilver> ac: 4? 8? ;)
03:22:35 <ac> depends on how fast your hardware is I presume
03:22:59 <Peaker> Saizan, Baughn: Ofcourse, I am not saying Functor is not useful. I am saying that I think perhaps a standard typeclass is missing for the case a library would want to provide features not possible with these available
03:23:20 <Baughn> Peaker: Not missing, per se. It exists in EdisonAPI
03:23:25 <Baughn> Now we just have to convince people to use that
03:23:28 <Peaker> Baughn: EdisonAPI?
03:23:33 <Baughn> Peaker: Hackage
03:24:00 <quicksilver> ac: note that under windows, at least, FSAA can be forced on at the driver level.
03:24:07 <quicksilver> ac: well, so I understand. I've never used windows :)
03:24:28 <`Ash> how do u define the ord function ?
03:24:46 <Axman6> what do you mean?
03:24:59 <`Ash> the error im getting from the compiler is 'undefined ord'
03:25:10 <Axman6> you need to import Data.Char
03:25:22 <`Ash> in main ?
03:25:31 <ac> quicksilver: I'm passing in the hint with 8, but "get samples" still says 0. Hrmmm
03:25:32 <Axman6> at the beginning of the file
03:25:37 <`Ash> ok thanks
03:25:38 <quicksilver> you put all theimports at the top yeah
03:25:49 <quicksilver> ac: I'm thinking you didn't request a multisample enabled context
03:26:30 <Baughn> `Ash: You could also use fromEnum (in the Enum typeclass), which is instanced to ord for Char and is already in the prelude
03:27:49 <Peaker> Baughn: it seems to be doing other stuff
03:28:10 <Peaker> Baughn: and I'm still trying to figure out whether "Observable" means you can just enumerate it, or whether it means you can get notifications about "changes"
03:28:12 <dancor> zipWith (=<<) is pretty sweet
03:28:12 <Baughn> Peaker: It does a lot of stuff, I was thinking of the ..X typeclasses
03:28:20 <`Ash> Baughn. i imported data.char, and it seems to work :D thanks
03:28:42 <ac> quicksilver: I don't see anything about that in the GLFW API :-/. What does "multisample enabled context" mean?
03:29:28 <`Ash> its still saying my message is a undefined variabl
03:29:29 <Peaker> Baughn: it kind of reminds me of Python's generalization of methods for various collections
03:29:50 <Baughn> Peaker: You have to check the source to see the actual functions defined, unfortunately
03:30:07 <Baughn> Peaker: ..or read his book, probably
03:30:35 <Baughn> Peaker: But it appears to me that non-observable classes just don't let you get a list of the elements they contain
03:30:57 <Baughn> ..hmm. That's not quite what you asked for; you can still change elements you know about.
03:30:59 <quicksilver> ac: I don't know how to answer that without rearranging the words.
03:31:18 <quicksilver> ac: a "multisample enabled context" is an OpenGL context within which the functionality for multisampling is enabled.
03:31:50 <Baughn> Peaker: Well, in any case, it's an awfully useful library. ^_^
03:32:15 <ac> quicksilver: lol. I'm just guessing here, but does "DisplayStencilBits" have anything to do with "multisamples"?
03:32:20 <Peaker> Baughn: I don't really want a "collection". I really like the Functor, Applicative, Arrow, Monad typeclasses because they can be generalized to so many things, including collections. However, if you have an Applicative, it cannot be used in certain ways unless you extend it with "join" and it becomes a monad.  I think a generic typeclass (regardless of collections) may fill the gap here
03:32:29 <Peaker> Baughn: Yeah, it seems pretty cool
03:33:00 <quicksilver> ac: No.
03:33:23 <Peaker> ghc takes a while to compile...
03:34:06 <Baughn> Peaker: Clearly you have an insufficiently advanced computer.
03:34:59 <quicksilver> ac: looking at the C docs, "glfwOpenWindow" is what sets up the context.
03:36:40 <thomashartman1> Is there some way of having all the docu I build with cabal haddock display nicely along the same lines as what you get with http://www.haskell.org/ghc/docs/latest/html/libraries/ ?
03:36:41 <lambdabot> Title: Haskell Hierarchical Libraries
03:36:50 <ac> quicksilver: yeah, but there's nothing about multisamples in the type signature of openWindow
03:37:13 <ac> openWindow :: Size -> [DisplayBits] -> WindowMode -> IO Bool
03:40:14 <Peaker> Baughn: btw: Another interesting example of the need I am talking about, is this definition of the GUI type:   Arrow (~>) => GUI a b = (a, (KeyboardInput, MouseInput)) ~> (b, Image)  -- AFAIK, it is impossible to have this arrow actually compose differential primitives that generate ImageDeltas rather than complete images
03:40:59 <Peaker> Baughn: because a pure function may process Image values, and be exposed to the fact that they are not deltas
03:41:53 <ac> there's this wiki page on GLFW: http://www.haskell.org/haskellwiki/GLFW, and it doesn't even pass in the WindowHint
03:41:54 <lambdabot> Title: GLFW - HaskellWiki
03:42:45 <ac> I mean the sample program on that page doesn't. I'm sure that doesn't work
03:43:48 <ac> oh duh
03:44:22 <ac> I needed to enable blend and set a blendFunc
03:44:35 <ac> but "get samples" still reports 0
03:46:25 <Peaker> when does one want to use MonadPlus, instead of say, Monoid?
03:46:40 <Axman6> marketing
03:46:42 <Axman6> >_>
03:51:27 <Baughn> @instances MonadPlus
03:51:28 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
03:51:31 <Baughn> @instances Monoid
03:51:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:52:25 <lilac> hmm. @instances could do with showing the context :)
03:52:36 <mmorrow> > fail "asdfdsa" :: Either () ()
03:52:37 <lambdabot>       No instance for (Error ())
03:52:37 <lambdabot>        arising from a use of `fail' at <inte...
03:52:43 <mmorrow> ah
03:53:04 <lilac> mmorrow: something like Error e => MonadPlus (Either e)
03:53:36 <mmorrow> ahh
03:53:59 <sc4r3> Hi, listen ive only done haskell for a couple of days and im stuck on a particular excercise with date, could any of you help me a bit?
03:54:00 <mmorrow> @instances Error
03:54:00 <lambdabot> IOError, String
03:54:11 <mmorrow> @src Error
03:54:12 <lambdabot> class Error a where
03:54:12 <lambdabot>     noMsg  :: a
03:54:12 <lambdabot>     strMsg :: String -> a
03:54:14 <lilac> FWIW, () could be an isntance of Error
03:54:28 <mmorrow> wow, i don't think i've ever used Error before
03:54:38 <mmorrow> i didn't even know that class existed
03:55:07 <mmorrow> oh, that's an mtl class right?
03:55:12 <mmorrow> i knew that existed ;)
03:59:02 <mmorrow> , flip runState (0,1) . replicateM 12 $ [$mc| [m | (m,n) <- get , () <- put (n,m+n)] |]
03:59:07 <lunabot>  ([0,1,1,2,3,5,8,13,21,34,55,89],(144,233))
03:59:45 <lilac> , src ''mc
03:59:47 <lunabot>  luna: Not in scope: type variable `mc'
03:59:59 <lilac> , src 'mc
04:00:09 <lunabot>  Killed.
04:03:21 <mmorrow> , src 'mc
04:03:26 <lunabot>  mc :: QuasiQuoter
04:04:03 <mmorrow> lunabot's running inside vmware or something (a hosted computer), no it's weird sometimes
04:05:25 <mmorrow> lilac: http://moonpatio.com/luna/luna.20081020/luna-meta/src/Luna/CompM.hs
04:05:27 <lambdabot> http://tinyurl.com/6dufun
04:06:13 <lilac> monad comprehensions ala Haskell 1.something ?
04:06:49 <mmorrow> heh, exactly ... but using template-haskell+a :: QuasiQuoter
04:06:53 <mmorrow> irony++
04:07:29 <lilac> @karma irony
04:07:29 <lambdabot> irony has a karma of 1
04:13:06 <mmorrow> it parses the incoming code with haskell-src-exts, then translates it to a valid do block and finally translates that to the TH Exp type
04:13:14 <mmorrow> , ppDoc' `fmap` (quoteExp mc) "[m | (m,n) <- get , () <- put (n,m+n)]"
04:13:19 <lunabot>  do (m, n) <- get
04:13:19 <lunabot>     () <- put (n, m + n)
04:13:19 <lunabot>     return m
04:14:34 <Axman6> whoot, getting this ARM emulator fixed!
04:14:43 <mmorrow> break a leg!
04:14:58 <Peaker> The docs of MonadPlus in wikibooks are saying: "v >> mzero   =  mzero" is a rule. And that IO is sometimes used as MonadPlus.  (launchMissiles >> mzero) does not launch missiles?
04:15:40 <mmorrow> oh it'll launch the missiles alright.... then throw an IOError (or whatever IO's fail does)
04:15:43 <mmorrow> delightful
04:16:05 <mmorrow> i think it's the same as IO's fail... (?)
04:16:13 <mmorrow> @src MonadPlus IO
04:16:13 <lambdabot> Source not found.
04:16:27 <mmorrow> @src mzero IO
04:16:27 <lambdabot> Source not found. Do you think like you type?
04:17:02 <Peaker> mmorrow: but then the law is broken, isn't it?  it should be equivalent to not launching missiles..
04:17:05 <mmorrow> oh, it's just defined in the mtl Control.Monad.Error
04:17:14 <mmorrow> Peaker: probably :)
04:17:22 <mmorrow> (as in probably broken)
04:17:26 * mmorrow looks
04:17:49 <mmorrow> you'd need ConT IO for that
04:17:54 <mmorrow> ContT
04:18:00 <mmorrow>            IO
04:18:02 <mmorrow> oops
04:18:45 <Peaker> mmorrow: didn't follow that...
04:19:10 <Axman6> hmm... anyone know how to convert an unsigned (Word8) into a signed int (Int8)?
04:19:10 <mmorrow> ghci> (print "42#EroRe" >> mzero) :: IO ()
04:19:11 <mmorrow> "42#EroRe"
04:19:11 <mmorrow> *** Exception: user error (mzero)
04:19:21 <Axman6> actually, don't worry.. i already know how to do it -_-
04:19:40 <Peaker> mmorrow: so that rule is not an equivalence rule, but just a rule about what the computation output is?
04:21:00 <`Ash> Hello Again. I've got the variables sorted ... but having a problem with my replaceDig function...
04:21:21 <`Ash> If i put in 'replaceDig 4' ... it works. but it wont work for a collection a characters.
04:21:32 <`Ash> Do i need to split the string, and read each digit seperately ?
04:22:09 <Saizan> `Ash: a String is just a list of characters in haskell
04:22:15 <`Ash> i want 'hello54' to return 'hellofivefour' ... but up to now it only replaces '5' with 'five'.
04:22:30 <Saizan> `Ash: experiment with map and concat from the Data.List module
04:22:37 <`Ash> yeah i know what a string is. but how do i split it into those seperate characters ?
04:22:52 <`Ash> it will only read a Char, not a [Char]
04:23:05 <Saizan> have you ever worked with lists in haskell?
04:23:13 <`Ash> only during this project
04:23:31 <mmorrow> Peaker: no it's an equivalence rule, but haskell's type system isn't powerful enough to be able to capture this requirement, so at best it can be put into a comment next to the code to be ignored :)
04:23:57 <Saizan> `Ash: so you know how pattern matching on a list work?
04:24:14 <`Ash> yeah. ive used lists in other languages
04:24:27 <Peaker> mmorrow: could a MonadPlus instance of IO follow that law at all?
04:24:29 <Saizan> > let (x:xs) = "foo" in "The first letter is "++ [x]
04:24:30 <lambdabot>   "The first letter is f"
04:24:39 <mmorrow> Peaker: no
04:24:44 <mmorrow> you can't take back IO
04:24:48 <Saizan> `Ash: experience with other languages isn't going to help
04:25:11 <mmorrow> (since it can change things out of your grasp)
04:25:16 <Saizan> `Ash: do you understand my code snippet above?
04:25:29 <Peaker> mmorrow: yeah, not all missiles can be called back
04:25:36 <`Ash> it is using the head/tail of ur message, and just outputting the head ?
04:25:50 <Saizan> yeah, exactly
04:26:12 <`Ash> i understand how to solve the problem i have. just not in haskell :P lol
04:26:12 <mmorrow> shutDownBreathingMachine >> threadDelay 1000000 >> selfDestruct >> threadDelay 100000 >> print "hey there" >> mzero >> return Success
04:26:22 <mmorrow> heh
04:27:04 <opqdonut> i feel my mind is going
04:27:05 <Saizan> `Ash: that's why you are here, no? you need to learn how to express your ideas in haskell, and also how to structure your program in a way that makes sense in a pure functional program
04:27:08 <opqdonut> ;)
04:27:09 <`Ash> Saizan, using ur code above, how would i used the 'f' in a function, rather then outputting it ?
04:27:19 <Peaker> (restoreSentientLife >> unWindTime 100000 >> rebuildSelf >> unwindTime 100000 >> clearScreen)
04:27:38 <`Ash> yeah pretty much. i have done the code for most of the project. and it works seperately.
04:27:45 <`Ash> it just doesnt work when i put it together.
04:28:10 <Saizan> > let (x:xs) = "foo" in toUpper x -- for example
04:28:12 <lambdabot>   'F'
04:28:15 <Axman6> Peaker: restoreSentientLife that sounds dangeroud to me :o
04:28:37 <`Ash> yeah but would that output the head?
04:28:38 <Saizan> `Ash: the only way to use something "in a function" is to make it an argument to that function
04:28:47 <Peaker> Axman6: a friend of mine says that _anything_ can be done with a time machine and genetic engineering
04:28:53 <Peaker> Axman6: this example just proves him right
04:29:07 <Axman6> you'll be the death of us all!
04:29:07 <Saizan> `Ash: what do you mean?
04:29:11 <`Ash> The problem is. Im trying to split a message (lets say 'hello5'), into seperate characters, so i can change the 5 into 'five'
04:29:16 <sc4r3> type Month = String
04:29:25 <sc4r3> type Year = Int
04:29:25 <`Ash> ive got the code to change 5 into 'five', and it works.
04:29:26 <Peaker> `Ash: a string is already a list of "separate characters"
04:29:39 <sc4r3> type date= (Int,Month, Year)
04:29:45 <`Ash> but i need to split the string into 'h' 'e' 'l' 'l' 'o' '5'. so i can find the 5, to change it.
04:29:51 <Saizan> `Ash: ok, so write the code to do so.. using pattern matching like (x:xs) above
04:29:56 <sc4r3> check whether the input date is valid
04:29:59 <Peaker> `Ash: "hello" == ['h', 'e', 'l', 'l', 'o']
04:30:07 <sc4r3> can anyone help me with that>?
04:30:08 <Axman6> fuck yes! finally debugged this ARM emulator, and for it working again!
04:30:10 <`Ash> i know Peaker. I need to change the [Char] into seperate Char's
04:30:23 <Saizan> they are already separate chars!
04:30:39 <Peaker> @type map
04:30:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:30:45 <quicksilver> `Ash: they already are separate : what you need is code to go through the list and do something to each character
04:30:53 <Peaker> sc4r3: valid in what way?
04:30:54 <`Ash> my program is actin like theyre together
04:31:01 <`Ash> it'll read '5', but it wont read '54'
04:31:02 <quicksilver> `Ash: possible prelude functions are 'map' and 'concatMap'
04:31:18 <Axman6> `Ash: what Peaker meant is that "hello" is the same as ['h', 'e', 'l', 'l', 'o']
04:31:20 <Peaker> sc4r3: the month string and year integer are within valid range? Or leap  year validation and all that?  The latter is not really a Haskell question
04:31:21 <Axman6> > ['h', 'e', 'l', 'l', 'o']
04:31:22 <lambdabot>   "hello"
04:31:28 <`Ash> yeah i know that
04:31:44 <sc4r3> whether the day number isnt bigger than the number of days in a month etc.
04:31:55 <Saizan> `Ash: you can't apply a function of type Char -> Something to [Char], you've to write code that takes a function like that and pplies it to each element of the list
04:32:02 <sc4r3> ive already done the number of days in all the months
04:32:09 <Peaker> `Ash: map lets you apply a function to each element in the list.  pattern-matching lets you split the list into its elements for access in a function.  list comprehensions let you use maps in a nicer syntax
04:32:21 <`Ash> i have replaceDigs to work if I enter '5' ... but it wont work for '54' or 'hello5'
04:32:43 <`Ash> i need to somehow seperate the chars (yes, theyre already seperate), but i need to be read them individually.
04:32:53 <Saizan> no
04:32:56 <Beelsebob> `Ash: you probably want concatMap
04:32:57 <Peaker> sc4r3: it changes according to leap years and various messy things
04:33:23 <Saizan> `Ash: you need to change the way in which you're thinking the algorithm
04:33:42 <`Ash> i cant see it working any other way
04:33:44 <Beelsebob> > let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
04:33:45 <lambdabot>   "jamonetwo"
04:34:03 <`Ash> thats what i needed ^
04:34:19 <Beelsebob> concatMap is like map
04:34:28 <Axman6> `Ash: the trick is you need to turn each of the non numbers into a string, you can't leave it as a Char
04:34:29 <Beelsebob> except that the function returns a list
04:34:34 <quicksilver> `Ash: we did tell you at least twice that you needed concatMap ;)
04:34:37 <Beelsebob> and it concatonates all of them together
04:34:39 <C-Keen> `Ash: searching for type signatures helped me a lot
04:34:50 <Axman6> > let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in  map replaceDigits "jam12"
04:34:52 <lambdabot>   ["j","a","m","one","two"]
04:34:53 <sc4r3> Peaker: yeah ive done the leap year and names of the month and number of days in every month, and now using these methods i have to check whether the date is valid
04:34:55 <C-Keen> hoogle is great for this
04:35:53 <sc4r3> Peaker: Months are strings ( e.g. validMonth "May" = true )
04:36:00 <Peaker> sc4r3: so you want something like: dateIsValid (day, year, month) = (1 <= day) and (day <= numOfDaysIn year month) and (1 <= month) and ... ?
04:36:06 <Saizan> quicksilver: twice per user :)
04:36:28 <Peaker> sc4r3: you'd probably want to translate the month string into an integer first
04:37:00 <sc4r3> Peaker: righto
04:37:14 <Axman6> jsn: i finally figured out what the problem with that ARM emulator i was working with was
04:37:19 <dmwit_> sc4r3: Are you committing the cardinal sin of writing your own date library?
04:37:26 <jsn> Axman6: oh?
04:38:26 <sc4r3> so ive done type Month = Int and type Year = Int and overall is type Date = (Int, Month, Year)
04:38:38 <Peaker> sc4r3: One method to do that would be:  monthNames = ["Jan", "Feb", ...]  ; monthIndex = (`elemIndex` monthNames)
04:38:52 <Peaker> sc4r3: ah, if you can just use ints in the first place, that's easier
04:39:05 <Axman6> jsn: it all came from some bessy bit fiddling stuff not being done correctly, because i'd changed a whole lot of things into fromIntegral blindly, without thinking about how they really worked. it was then or'ing the entire instruction with a negative Word32, which is basically all 1s
04:39:08 <Peaker> sc4r3: btw, you probably wrote functions to compute the number of days/etc, not methods
04:39:16 <Axman6> s/bessy/messy
04:39:29 <mornfall> Hi. Anyone know if there's a way to tell GHC not to look at userfiles?
04:39:32 <dmwit_> sc4r3: Just use Data.Time, and let it take care of all this for you...
04:39:33 <mornfall> Err.
04:39:36 <mornfall> I mean, -no-user-package-conf.
04:39:48 <mornfall> Is there a way to pass that from the environment, not the flags?
04:40:08 <dmwit_> That's an odd one.  Why would you want that?
04:40:10 <mornfall> I'd like to pass that to all dpkg builds.
04:40:13 <Axman6> {-# LANGUAGE -no-user-package-conf #-} maybe?
04:40:23 <Peaker> dmwit_: I think its an exercise
04:40:47 <dmwit_> Peaker: ah.  Messy exercise!
04:40:49 <sc4r3> dmwit_ : is that a boolean function?
04:41:14 <dmwit_> sc4r3: No, Data.Time is a module with various functions for munging dates and times.
04:41:15 <mornfall> The issue is that I can't (okey, don't want) to modify how ghc is called.
04:41:20 <mornfall> -to
04:41:26 <mornfall> And even less the files.
04:41:29 <Axman6> jsn: thanks for trying to help though :)
04:41:51 <dmwit_> sc4r3: But a validation function of type String -> Bool would be trivially easy to write with Data.Time in scope.
04:42:11 <thomashartman1> -- out of memory error
04:42:12 <thomashartman1> t1 = withFile "test" AppendMode (\h-> mapM_ (hPutStrLn h . show) [1..10^8] )
04:42:18 <thomashartman1> How can I make haskell dwiw?
04:42:29 <thomashartman1> which is to write a big file.
04:42:44 <dmwit_> thomashartman1: That looks fine, are you sure the error isn't elsewhere?
04:42:48 <`Ash> let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
04:42:49 <Peaker> is ghc-6.11 (darcs) generally in working condition?
04:43:02 <sc4r3> dmwit_ : what i need is a boolean function that returns true if you put in a valid date ( eg. 12 03 1998) and returns false if you  put in a invalid date (  34 13 203 )
04:43:12 <Peaker> > let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
04:43:13 <lambdabot>   "jamonetwo"
04:43:13 <thomashartman1> actually even if I do last [1..10^8] I get out of memory
04:43:14 <Axman6> `Ash: need to put > in front of it
04:43:17 <dmwit_> sc4r3: Yes, that should be very, very easy with Data.Time.
04:43:19 <quicksilver> dmwit_: isn't here / wasn't there a but in ".."
04:43:24 <`Ash> k
04:43:24 <quicksilver> dmwit_: in some version of the prelude
04:43:39 <dmwit_> sc4r3: Spend a little time in the docs for parseTime.
04:43:40 <thomashartman1> I have ulimitted virtual memory to 512M
04:43:49 <quicksilver> thomashartman1: I think it's a bug in ".."
04:43:59 <thomashartman1> ah I didn't think of that
04:44:09 <thomashartman1> maybe better with unfoldr?
04:44:12 <jsn> Axman6: yeah, it was not really clear where i should start with that...i'm glad you were able to get it sorted
04:44:25 <thomashartman1> gonna try that
04:44:26 <dmwit_> quicksilver: Oh, really? huh
04:44:28 <sc4r3> righto let me check on it
04:44:30 <dmwit_> > last [1..10^8]
04:44:34 <lambdabot>   100000000
04:44:45 <dmwit_> quicksilver: ?
04:45:22 <dmwit_> thomashartman1: What version of GHC?
04:45:25 <ac> ARHG! ghc is exploding again
04:45:43 <jsn> ac: oh?
04:45:49 <Axman6> ac: with random code or specific things?
04:46:56 <ac> I was complaining about it earlier. Every now and then when I compile something it gobbles all of my memory and completely bogs down my computer
04:47:03 <ac> And I think I was wrong about it being in the linking stage
04:47:19 <quicksilver> dmwit_: I just recall that there is some obscure strictness bug with Int and ..
04:47:22 <quicksilver> in some GHC version.
04:47:29 <`Ash> would i have to add a wildcard for this concatMap thing to work ?
04:47:34 <jsn> ac: can you tell us anything about the system you have, and what you are compiling?
04:47:48 <quicksilver> `Ash: yes, because you have to tell it what to do with the letters you don't want to change
04:47:54 <quicksilver> `Ash: (that is, do nothign with them)
04:47:54 <jsn> if it's bogging down your OLPC while you compile GHC...
04:48:04 <`Ash> and the wildcard is _ in haskell right ?
04:48:18 <mornfall> Hm, GHC_PACKAGE_PATH seems to do what I want. Nevermind then. : - )
04:48:36 <quicksilver> `Ash: _ is a pattern wildcard, yes. But it's not what you need here.
04:48:49 <`Ash> what do i need? x = [x] ?
04:49:12 * quicksilver nods
04:49:17 <Axman6> it turns the character into a string
04:49:17 <`Ash> :)
04:49:20 <thomashartman1> dmwit: 6.8.3
04:49:20 <Saizan> quicksilver: the bug was with unbounded intervals and Integer, iirc, since there's no check for maxBound
04:49:29 <camio> Axman: return
04:49:29 <thomashartman1> last $ unfoldr (\x -> if x <10^8 then Just (x+1,x+1) else Nothing ) 0
04:49:33 <thomashartman1> still gives out of memory
04:49:57 <Saizan> > last $ unfoldr (\x -> if x <10^8 then Just (x+1,x+1) else Nothing ) 0
04:50:06 <thomashartman1> wait a sec.
04:50:08 <dmwit_> thomashartman1: last [1..10^8] works fine here with 6.8.3 and no special memory flags.
04:50:12 <lambdabot>   thread killed
04:50:12 <dmwit_> thomashartman1: Just plain ol' ghci.
04:50:19 <Axman6> camio: i know that ;)
04:51:20 <Baughn> > last [1..10^8]
04:51:32 <lambdabot>   100000000
04:51:43 <Axman6> > last [1..10^9]
04:51:44 <Baughn> Hum. I was sure that'd give a stack overflow.
04:51:58 <lambdabot>   thread killed
04:52:12 <thomashartman1> > last [1..10^8]
04:52:25 <thomashartman1> it does take its sweet time.
04:52:26 <dmwit_> 100000000
04:52:27 <lambdabot>   thread killed
04:52:34 <dmwit_> ;-)
04:52:46 <Axman6> omg, the thread escaped into dmwit_!
04:52:48 <thomashartman1> why'd it let Baugh but not me?
04:52:53 <dmwit_> > "oh noes it's broken??"
04:52:56 <lambdabot>   "oh noes it's broken??"
04:53:14 <dmwit_> thomashartman1: lambdabot is in IO (), and hence a bit nondeterministic.
04:53:21 <thomashartman1> > last $ unfoldr (\x -> if x <10 then Just (x+1,x+1) else Nothing )
04:53:24 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> [b]'
04:53:28 <dmwit_> thomashartman1: Conditions on the target machine help decide whether a computation finishes or not. =P
04:53:31 <thomashartman1> > last $ unfoldr (\x -> if x <10 then Just (x+1,x+1) else Nothing ) :: Int
04:53:33 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> [b]'
04:54:00 <thomashartman1> > last $ unfoldr (\x -> if x <10 then Just (x+1,x+1) else Nothing ) 0 :: Int
04:54:01 <lambdabot>   10
04:54:03 <Axman6> :t unfoldr
04:54:05 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:54:51 <Saizan> thomashartman1: also, compiling with optimizations will help it speed up a lot, i guess, especilly if you specify Int instead of letting it default to Integer
04:55:54 <thomashartman1> is there some way to tell whether I'm getting linear stack usage, in ghci?
04:56:03 <thomashartman1> eg, when walking the big list to get last?
04:56:18 <thomashartman1> ghc doesn't have to allocate the entire list to do this right?
04:56:35 <Saizan> it doesn't
04:56:53 <Saizan> it should work in O(1) memory
04:56:59 <thomashartman1> actually.. then why do we get out of memory errors on 10^9 lists?
04:57:02 <ac> jsn: regular Ubuntu Linux system... 1.something ghz with a gig of ram, and I'm compiling something that links to OpenGL. The memory thing is only sometimes. This time it was just thrashing the disk, and I killed after 6 minutes
04:57:10 <quicksilver> thomashartman1: because there is a bug, somewhere.
04:57:13 <thomashartman1> it should just chug quietly away and not finish right?
04:57:17 <quicksilver> maybe it's in .. for Integer
04:57:27 <jsn> ac: hmm
04:57:27 <thomashartman1> or last?
04:57:32 <thomashartman1> @src last
04:57:32 <lambdabot> last [x]    = x
04:57:32 <lambdabot> last (_:xs) = last xs
04:57:32 <lambdabot> last []     = undefined
04:57:53 <Saizan> last is pretty hard to get wrong..
04:58:05 <thomashartman1> quicksilver: but I get the same behavior with unfoldr, so we can eliminate that
04:58:16 <Philonous> thomashartman1 I think when you acces the nth element it still hast to build up n thunks
04:58:34 <quicksilver> thomashartman1: no, your unfoldr example is totally different.
04:58:45 <quicksilver> thomashartman1: that builds up enormous thunks of (+)s
04:59:00 <thomashartman1> is there a way to use unfoldr and not do that
04:59:01 <thomashartman1> ?
04:59:02 <Saizan> oh, right
04:59:26 <Saizan> > last $ unfoldr (\x -> if x < 10^8 then let y = x +1 in  Just (y,y) else Nothing ) 0
04:59:41 <lambdabot>   thread killed
04:59:44 <quicksilver> y `seq`
05:00:04 <Saizan> shouldn't x < 10^8 force it?
05:00:09 <Saizan> > last $ unfoldr (\x -> if x < 10^8 then let y = x +1 in  y `seq` Just (y,y) else Nothing ) 0
05:00:25 <lambdabot>   thread killed
05:00:38 <ac> hum, every time I run it it just thrashes the disk. It's not actually using any CPU or memory
05:00:46 <hugo_> is there any way to dump a 24 bit colored png with haskell ?
05:00:46 <ac> sure is irritating how a lot of disk access will totally kill your machine
05:00:54 <quicksilver> Saizan: oh yes, good point.
05:01:36 <ac> what's the command to run to figure out what it's doing?
05:01:43 <ac> I mean to trace which files it's accessing?
05:02:00 <mapreduce> strace -o foo.txt myprogram
05:02:33 <hugo_> oh, there is this binding to sdl image, i guess ill use it to dump the png :)
05:02:45 <Saizan> thomashartman1: however these examples work in constant memory here, (even if i'm using 6.10)
05:03:16 <thomashartman1> How can I tell if it's using constant memory? top?
05:03:51 <thomashartman1> saizan: in ghci 6.10?
05:04:23 <Saizan> yes, top
05:04:28 <Saizan> and yes ghci 6.10
05:04:42 <thomashartman1> Saizan, so you could run last [1..] and it would just chug and use some memory, but never die on you?
05:05:15 <BeelsebobWork> thomashartman1: sure -- it's tail recursion
05:05:29 <thomashartman1> so why can't I do it?
05:06:15 <thomashartman1> Prelude> last [1..]
05:06:16 <thomashartman1> <interactive>: out of memory (requested 1048576 bytes)
05:06:28 <Axman6> ghci is different
05:06:45 <Axman6> i've found it's usually pretty crap with memory usage for things like that
05:06:48 <Saizan> i'm talking about ghci
05:06:57 <BeelsebobWork> ghci uses -Onot IIRC
05:07:03 <BeelsebobWork> so it won't optimise it out
05:07:04 <Saizan> thomashartman1: what about last [1..] :: Int ?
05:07:19 <quicksilver> BeelsebobWork: ghci doesn't compile at all; it uses bytecode
05:07:31 <idnar> > last ([1..] :: Int)
05:07:32 <quicksilver> I think thomashartman1 may be hitting this bug
05:07:33 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
05:07:34 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1997
05:07:39 <idnar> > last [1..] :: Int
05:07:40 <lambdabot> Title: #1997 (Stricter enumFrom instance for Integer, to match Int) - GHC - Trac
05:07:54 <lambdabot>   thread killed
05:08:06 <thomashartman1> I was using :: Ing in ghci
05:08:10 <thomashartman1> :: Int
05:08:10 <Axman6> > last [1..] :: Int32
05:08:26 <lambdabot>   thread killed
05:08:30 <Axman6> > last [1..] :: Int16
05:08:32 <lambdabot>   32767
05:08:35 <ac> GHC doesn't have it's own swapping code does it?
05:08:44 <Axman6> > last [1..] :: Word16
05:08:47 <lambdabot>   65535
05:09:20 <idnar> uhm, actually
05:09:41 <idnar> why would (last [1..]) ever run out of memory? garbage collection not kicking in soon enough?
05:10:17 <quicksilver> idnar: bug not forcing the thunks.
05:10:37 <BeelsebobWork> idnar: because it takes a lot of RAM to store *very* large Integers
05:10:43 <BeelsebobWork> and it has to store 2 of them at once
05:10:50 <BeelsebobWork> (x, and x+1)
05:11:08 <idnar> BeelsebobWork: oh, good point
05:11:12 <quicksilver> that's also a good point ;)
05:11:16 <jsn> ac: i have experienced this problem on one occasion
05:11:23 <quicksilver> although a bug oculd make it run out of memory much sooner ;)
05:11:27 <idnar> but last [1..] :: Int has constant memory usage in "GHCi, version 6.8.2" here
05:11:30 <Saizan> yeah, but they don't apply to last [1..] :: Int :)
05:11:39 <idnar> it's been running for a heck of a long time, though
05:11:50 <Saizan> yeah, same here with 6.10
05:11:59 <jsn> ac: i was trying to build a huge list -- all of CEDICT, a Chinese dictionary -- in GHC and it would run for ~30 minutes and then crash
05:12:05 <Saizan> could it be a bug only present in 6.8.3?
05:12:05 <BeelsebobWork> I'm surprised that last [1..] :: Int terminates actually
05:12:17 <thomashartman1> even when I compile without O2, compiled version has been running for a while with no problem.
05:12:20 <BeelsebobWork> I expected that to get desugared to last (enumFromTo 1 maxBound) :: Int
05:12:26 <thomashartman1> I guess it's a problem with ghci 6.8.3
05:12:31 <jsn> ac: i'm not sure if it was actually disk access -- but i remember it made my machine unusable the whole time
05:12:46 <thomashartman1> ac: amanda claire?
05:12:55 <idnar> when was 6.8.3 released, and why isn't it in sid?
05:13:29 <idnar> I guess maybe they're holding off because of the lenny freeze
05:13:49 <daf> presumably
05:14:23 <ac> thomashartman1: hah, no
05:14:28 <thomashartman1> I was reading amanda claire's notes on lazy vs strict at http://users.aber.ac.uk/afc/stricthaskell.html
05:14:32 <lambdabot> Title: Making Haskell programs faster and smaller
05:14:34 * idnar runs it on a faster box
05:14:36 <thomashartman1> when I started playing with this stuff
05:18:18 <Axman6> > unfoldr (\x -> if x == 0 then Nothing else Just (divMod x)) 123
05:18:20 <lambdabot>   Couldn't match expected type `(a, b)'
05:18:38 <Axman6> :t (\x -> if x == 0 then Nothing else Just (divMod x))
05:18:39 <lambdabot> forall a. (Integral a) => a -> Maybe (a -> (a, a))
05:18:46 <Axman6> ah, i know
05:18:52 <Axman6> :t (\x -> if x == 0 then Nothing else Just (divMod x 2))
05:18:54 <lambdabot> forall a. (Integral a) => a -> Maybe (a, a)
05:18:59 <Axman6> > unfoldr (\x -> if x == 0 then Nothing else Just (divMod x 2)) 123
05:19:01 <lambdabot>   [61,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:19:05 <thomashartman1> thanks for all the help.
05:19:39 <Axman6> > unfoldr (\x -> if x == 0 then Nothing else Just ((\(a,b) -> (b,a)) (divMod x 2)) 123
05:19:41 <lambdabot>   <no location info>: parse error on input `;'
05:20:37 <Axman6> > unfoldr (\x -> if x == 0 then Nothing else Just (let (a,b) = divMod x 2 in (b,a)) 123
05:20:39 <lambdabot>   <no location info>: parse error on input `;'
05:20:54 <Axman6> huh
05:22:03 <Axman6> > unfoldr (\x -> if x == 0 then Nothing else Just (let (a,b) = divMod x 2 in (b,a))) 123 -- missing a bracket...
05:22:03 <luite_> I've installed parsec 3.0 using the setup script, but I had installed 2.1 before (it came with ghc). should I uninstall the old version?
05:22:05 <lambdabot>   [1,1,0,1,1,1,1]
05:24:32 <Saizan> luite_: no
05:25:08 <luite_> hm, I'm having some problems compiling with the new version
05:25:24 <quicksilver> there are some subtle inconsistencies, luite
05:25:40 <quicksilver> they tried to make it backward compatible but IIRC some details about type synonyms mean it won't always work?
05:25:43 <quicksilver> I've not used it myself.
05:25:50 <luite_> hm, ok, I'll look into it
05:33:49 <pedrob> guys where can I find infor about how the GHC is implemented
05:33:49 <pedrob> ?
05:34:11 <quicksilver> pedrob: reading SPJ's papers is a good start
05:34:12 <Axman6> haskell.org/ghc ?
05:34:22 <quicksilver> they're out of date in the details but quite readable and give a good idea.
05:34:23 <pedrob> quicksilver: SPJ?
05:34:30 <quicksilver> simon peyton jones
05:34:35 <pedrob> thanks
05:37:32 <pedrob> quicksilver: thanks was just what I was looking for
05:38:52 <quicksilver> hurrah :)
05:39:55 <Baughn> @hoogle assert
05:39:56 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:39:56 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
05:39:56 <lambdabot> Test.HUnit.Base class Assertable t
05:44:48 <Axman6> @src Float
05:44:48 <lambdabot> data Float = F# Float#
05:45:06 <Axman6> hmm, are Floats 32 bit floats?
05:45:16 <Axman6> @instances Bits
05:45:17 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
05:45:32 <Axman6> @instances-importing Bits Bits
05:45:33 <lambdabot> Int, Integer
05:45:37 <Axman6> hmm
05:46:18 <Baughn> @src guard
05:46:19 <lambdabot> guard True  =  return ()
05:46:19 <lambdabot> guard False =  mzero
05:53:44 <quicksilver> Axman6: at least 32 bits, yes.
05:53:53 <quicksilver> Axman6: Float >= 32 bit, Double >= 64 bit
05:53:55 <Axman6> rihgto
05:54:09 <quicksilver> Axman6: in practice, on common platforms, they are mostly exactly that.
05:54:20 <quicksilver> except x86 might use higher precision registers for intermediate calculations.
05:54:47 <Axman6> just curious, might be interesting to stick floating point into this ARM emulator. i'm possibly already going to be writing Int24 for par of it...
05:55:09 <Axman6> t*
06:06:36 <nominolo|msr> @seen ndm
06:06:37 <lambdabot> I haven't seen ndm.
06:06:55 <Saizan> preflex: seen ndm
06:06:55 <preflex>  ndm was last seen on #xmonad 52 days, 20 hours, 32 minutes and 42 seconds ago, saying: cool :)
06:19:55 <camio> Anyone know why ghc seems to be skipping 6.9?
06:20:06 <Zao> camio: It's the usual odd/even versioning.
06:20:15 <ddarius> odd numbers are development branches
06:20:18 <Zao> Even versions are for release, odd versoins are for dev.
06:20:29 <camio> Oh, thanks.
06:25:12 <ziman> %GC time      74.9%  (75.0% elapsed)
06:25:48 <ziman> is there a general rule how to avoid such high time consumption by GC?
06:26:38 <zachk> tail recursion might help you
06:26:59 <mmorrow> ghci> :t fmap :: ((a -> b) -> b) -> (forall c. c -> a)
06:26:59 <mmorrow> *** Exception: No match in record selector Var.tcTyVarDetails
06:27:03 <BeelsebobWork> ziman: try fiddling with -A and -H in the runtime options
06:27:58 <ziman> BeelsebobWork, thanks, i'll try
06:29:00 <lightstep> i have a problem with cabal. i installed alex (version 2.3), but ghc-pkg list doesn't show it, and when installing yi, it complains that alex is not found
06:29:14 <ziman> %GC time       6.3%  (6.1% elapsed)
06:29:20 <ziman> wow! BeelsebobWork thanks!
06:29:27 <BeelsebobWork> :)
06:29:37 <BeelsebobWork> I wish ghc was capable of auto-tweaking that
06:29:38 <ziman> i've always underestimated those options ;)
06:30:40 <camio> Where can I see more info on those?
06:30:53 <BeelsebobWork> in the ghc manual
06:30:53 <quicksilver> camio: in the GHC user manual.
06:31:06 <camio> Yeah, that's what I'm browsing. It's a long manual.
06:31:22 <camio> Ah, flag reference. Found it :)
06:32:39 <Baughn> @hoogle Socket -> Handle
06:32:39 <lambdabot> Warning: Unknown type Socket
06:32:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:32:40 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:32:41 <ziman> camio, or use ./yourapp +RTS -h
06:33:01 <ziman> but that is rather brief
06:33:34 <BeelsebobWork> ziman: note that -A is broken on OS X
06:33:56 <BeelsebobWork> in that it takes a long time to start your process as it allocates a crap load of ram
06:34:28 <ziman> that's no problem for me, fortunately (no os x here)
06:34:59 <BeelsebobWork> yeh, it just makes -H a rather more tempting option
06:35:52 <lilac> is there a way to turn off the +RTS handling?
06:37:09 <BeelsebobWork> -RTS
06:37:19 <nominolo|msr> btw, you can get heap-profiling without recompilation via +RTS -hT
06:37:37 <camio> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
06:37:46 <nominolo|msr> lilac: do you mean completely disable it?
06:37:49 <lambdabot> Title: 5.14.Running a compiled program, http://tinyurl.com/d7dj4
06:37:59 <lilac> nominolo|msr: yes
06:38:13 <lilac> say my application wants all command-line arguments
06:38:47 <BeelsebobWork> ./yourApp -itsOption1 -itsOption2 +RTS -runtimeOption -runtimeOption -RTS -itsOption3
06:38:50 * lilac notes that a script which runs 'myapp --RTS "$@"' would do the trick, but that seems odorous
06:40:20 <nominolo|msr> lilac: so you want to disable the possibility that someone runs your program with certain RTS options?
06:40:57 <lilac> nominolo|msr: no, i'm happy with them using the GHCRTS environment variable. but i want all arguments.
06:41:27 <lilac> suppose i'm writing an 'rm' program. it'd be no good if it needed special handling to delete files named '+RTS'
06:41:45 <camio> I'm thinking of an 'echo' program.
06:42:15 <lilac> (no good because the convention is that the special string to turn off argument handling is -- not --RTS)
06:43:28 <nominolo|msr> lilac: haddock embeds ghc api args into -- ... -- parts
06:43:38 <nominolo|msr> lilac: perhaps you can look at how haddock does it
06:43:43 <nominolo|msr> oh, wait, no
06:43:58 <nominolo|msr> that won't work
06:44:20 <cajun-rat> isn't there an option that says 'this is the last option ever'?
06:45:04 <lilac> cajun-rat: --RTS says 'everything else on this line is for the application not the RTS'
06:45:35 <cajun-rat> that's the one
06:46:18 <lightstep> lilac, it's like gtk apps always taking some options
06:47:29 <lilac> lightstep: but that can be overridden; in gtk and Qt, you still write your own main.
06:48:49 <camio> Hrm, I'm kinda sad a about there being no way to disable the +RTS options. It forces certain command-line semantics on my executable.
06:49:06 <camio> I'd be comfortable knowing that it can be disabled, although I'd probably never disable it.
06:49:14 <magthe> @hoogle a->a
06:49:14 <lambdabot> Prelude id :: a -> a
06:49:14 <lambdabot> Data.Function id :: a -> a
06:49:14 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
06:49:46 <magthe> @hoogle (a->b)->(a->c)->(b,c)
06:49:47 <lambdabot> No results found
06:50:02 <nominolo|msr> camio: you should be able to write a (shell or C) wrapper that prefixes --RTS to your programs command line
06:50:42 <BeelsebobWork> magthe: &&&
06:50:43 <camio> nominolo|msr: Yeah, I realize that, but then I'm going outside the haskell universe.
06:50:54 <BeelsebobWork> > (id &&& (+2)) 5
06:50:55 <lambdabot>   (5,7)
06:51:06 <nominolo|msr> camio: yep.  if you want to find out the full command line you can use  GHC.Environment.getFullArgs
06:51:14 <nominolo|msr> but the options will still be interpreted
06:51:36 <nominolo|msr> if you write the wrapper in C it should even be portable
06:54:22 <SamB_XP> camio: so?
06:54:44 <cajun-rat> I'm using hxt, and I've got a function makeEntry Blog -> IOSArrow XMLTree XMLTree which stuffs data into a XML Template.
06:54:51 <cajun-rat> Is there an equivalent of 'concat map' that would take a [Blog], stuff the incoming XMLTree through the above filter lots of times and return a single XMLTree?
06:55:06 <magthe> BeelsebobWork: thanks, and I see I can just combine accessor functions of a type... cool
06:58:38 <camio> SamB_XP: I like the idea that one could write a replacement for the windows version of echo with a simple haskell program.
06:59:03 <camio> SamB_XP: Or the linux version too for that matter.
06:59:26 <SamB_XP> hmm
07:00:04 <SamB_XP> I suppose you can't exactly do one that works when passed +RTS --help, can you?
07:00:40 <camio> exactly.
07:04:54 <BeelsebobWork> > let alternate (x:xs) ys = x: alternate ys xs in sum (alternate [1,3..] [-2,-4..])
07:05:06 <lambdabot>   mueval: Prelude.read: no parse
07:05:28 <Deewiant> camio: one can't write a replacement for the windows version of echo, I don't think
07:05:29 <BeelsebobWork> > let alternate (x:xs) ys = x : alternate ys xs in sum (alternate [1,3..] [-2,-4..])
07:05:52 <BeelsebobWork> awww, not 1/4
07:05:58 <lambdabot>   mueval: Prelude.read: no parse
07:07:05 <camio> Deewiant: Do you mean in any language? It may be built in, but AFAICT the symantics are pretty simple.
07:07:56 <Deewiant> camio: I don't think there's any way of getting at the original command line in its entirety, at least not without using the Win32 API which already makes it less than simple IMO :-)
07:08:17 <Deewiant> camio: It has to preserve whitespace between arguments and quoting, you see.
07:08:40 <camio> Ah, good point.
07:12:41 <camio> @free (a,b) -> a
07:12:41 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
07:13:03 <camio> That's weird.
07:13:28 <Deewiant> @free (a,b)
07:13:29 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
07:13:42 <camio> @free a -> a
07:13:43 <lambdabot> Extra stuff at end of line
07:14:09 <camio> @djinn (a,b) -> a
07:14:10 <lambdabot> f (a, _) = a
07:22:36 <RayNbow> http://hpaste.org/11318 <-- any room for improvements? :)
07:24:46 <lightstep> RayNbow, you can sort the second part of each tuple separately: f ads = zip (map fst ads) (sort $ map snd ads)
07:25:32 <luite_> not with an infinite list
07:26:22 <lightstep> oh, zip is the wrong operation
07:26:22 <RayNbow> > sort [1..]
07:26:23 <lightstep> concat . zipWith (\x y -> [x,y])
07:26:39 <lambdabot>   mueval: Prelude.read: no parse
07:26:48 * RayNbow killed lambdabot :p
07:27:00 <pjdelport> RayNbow: compare = compare `on` time
07:27:28 <RayNbow> pjdelport: ah, right... thx :)
07:28:30 <RayNbow> lightstep: erm, would that result in a sorted list?
07:29:13 <RayNbow> :t concat . zipWith (\x y -> [x,y])
07:29:16 <lambdabot>     Couldn't match expected type `[[a]]'
07:29:16 <lambdabot>            against inferred type `[b] -> [[b]]'
07:29:16 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
07:30:52 <lightstep> RayNbow, no, it will give different results. i was wrong
07:46:28 <theunixgeek> lambdabot: [a,b,c|(a*a)+(b*b)==(c*c), a+b+c==1000]
07:46:36 <theunixgeek> hm...
07:46:40 <theunixgeek> Is that code correct?
07:46:52 <theunixgeek> It's supposed to return a Pythagorean triplet whose sum is 1000.
07:47:12 <Peaker> theunixgeek: try "> " prefix
07:47:13 <theunixgeek> Project Euler, problem 9
07:47:18 <Peaker> > [a,b,c|(a*a)+(b*b)==(c*c), a+b+c==1000]
07:47:19 <lambdabot>   <no location info>: parse error on input `|'
07:47:34 <theunixgeek> > pythagoras = [a,b,c|(a*a)+(b*b)==(c*c), a+b+c==1000]
07:47:35 <lambdabot>   <no location info>: parse error on input `='
07:47:44 <Peaker> theunixgeek: you're lacking the "x <- list" part..
07:47:49 <lilac> > [(a,b,c) | a <- [1..999], b <- [1..999-a], c <- [1..999-a-b], (a*a)+(b*b)==(c*c), a+b+c == 1000]
07:48:03 <theunixgeek> oh
07:48:04 <lambdabot>   thread killed
07:48:07 <theunixgeek> thanks, lilac
07:48:12 <theunixgeek> lol it's that big
07:48:24 <theunixgeek> I just began Haskell yesterday
07:48:37 <theunixgeek> I'm not sure I understand this list comprehension part very well
07:48:44 <theunixgeek> I'll google it
07:49:03 <lilac> > [(a,b,c) | a <- [1..999], b <- [1..999-a], c <- [1000-a-b], (a*a)+(b*b)==(c*c)]
07:49:08 <lambdabot>   [(200,375,425),(375,200,425)]
07:49:24 <theunixgeek> it's only supposed to return one triplet
07:49:39 <lilac> that's the same triplet twice
07:49:39 <theunixgeek> oh, I'll sum them up now to see if it returns 1000
07:49:44 <theunixgeek> true
07:49:49 <lilac> > [(a,b,c) | a <- [1..999], b <- [a+1..999-a], c <- [1000-a-b], (a*a)+(b*b)==(c*c)]
07:49:50 <theunixgeek> didn't notice that :P
07:49:53 <lambdabot>   [(200,375,425)]
07:50:12 <theunixgeek> woah, what are you doing? :/
07:50:14 <theunixgeek> I'm getting confused
07:50:32 <theunixgeek> ah, I see
07:50:46 <theunixgeek> > [(a,b,c)
07:50:47 <lambdabot>   <no location info>: parse error on input `;'
07:50:48 <theunixgeek> woops
07:51:42 <RayNbow> btw, you don't have to enumerate c
07:51:57 <RayNbow> you can compute c from a and b
07:51:58 <theunixgeek> > [(a,b,c) | a <- [1..500], b <- [1..500], c <- [a+b-500], (a*a) + (b*b) == (c*c)]
07:52:01 <lambdabot>   []
07:52:11 <lilac> RayNbow: i'm not enumerating c :)
07:52:15 <theunixgeek> guess my version didn't work :P
07:52:24 <theunixgeek> anyway, I'll research more about list comprehension
07:52:25 <int-e> theunixgeek: you can write 'let c = a+b-500' instead of 'c <- [a+b-500]'
07:52:25 <theunixgeek> thanks, lilac
07:52:28 <lilac> > [(a,b,c) | a <- [1..500], b <- [a+1..999-a], c <- [1000-a-b], (a*a)+(b*b)==(c*c)]
07:52:30 <lambdabot>   [(200,375,425)]
07:52:46 <theunixgeek> int-e: inside the command?
07:52:52 <int-e> theunixgeek: yes
07:52:52 <RayNbow> lilac: ah right, evil singleton list distracted me :p
07:52:53 <theunixgeek> int-e: or separately?
07:53:05 <theunixgeek> oh
07:53:05 <lilac> int-e: i didn't realise you could do that in a list comprehension :D thanks
07:53:35 <theunixgeek> can anyone explain what _ means?
07:53:40 <theunixgeek> it's sort of keeping me confused.
07:53:54 <lilac> it's a pattern that matches anything and ignores it
07:53:57 <Valodim> think of it as z, where you never use z
07:54:10 <theunixgeek> I think I sort of get it
07:54:12 <lilac> > let f _ _ = 42 in f 5 29
07:54:13 <theunixgeek> so
07:54:14 <lambdabot>   42
07:54:22 <theunixgeek> ah
07:54:22 <theunixgeek> I see
07:54:28 <lilac> > case Just x of Nothing -> 0; Just _ -> 1
07:54:29 <lambdabot>   1
07:54:30 <theunixgeek> so it's sort of like the "nothing" variable
07:54:44 <theunixgeek> lilac: I haven't learned the case command in Haskell yet
07:54:57 <theunixgeek> I'll try one now
07:55:47 * RayNbow wishes he could use the _ pattern match on constructors :p
07:55:48 <theunixgeek> > let x _ a = _ + a
07:55:49 <lambdabot>   <no location info>: parse error on input `;'
07:56:09 <theunixgeek> wait
07:56:20 <theunixgeek> > let x _ a = 10 in x 9 9
07:56:21 <lambdabot>   10
07:56:36 <theunixgeek> hm
07:56:38 <theunixgeek> interesting
07:56:41 <theunixgeek> what's it called?
07:56:43 <theunixgeek> _
07:57:29 <theunixgeek> well, it's time for lunch
07:57:38 <theunixgeek> I'll be back later (not necessarily today, though)
07:59:16 * rog wishes he could use the _ pattern match on type variables
08:00:56 <`Ash> concatMap '3' d = concat $ map '3' d
08:01:04 <`Ash> > concatMap '3' d = concat $ map '3' d
08:01:06 <lambdabot>   <no location info>: parse error on input `='
08:01:45 <Peaker> `Ash: '3' is a literal char, its not valid as a pattern element
08:02:41 <`Ash> barr :P
08:03:24 <Peaker> actually maybe it is, I am not sure
08:03:34 <`Ash> when ur defining concatMap, and use 'concatMap :: (a -> [b]) -> [a] -> [b]'...
08:03:46 <`Ash> are a and b random examples, or do they have to be variables in the program ?
08:04:19 <Peaker> `Ash: oops, my bad, it is valid. lambdabot probably wants a "let" before defining a function though
08:04:34 <`Ash> > let concatMap '3' d = concat $ map '3' d
08:04:35 <lambdabot>   <no location info>: parse error on input `;'
08:04:51 <Peaker> `Ash: you need "in"
08:05:02 <Peaker> > let concatMap '3' d = concat $ map '3' d in 5
08:05:02 <lambdabot>   Couldn't match expected type `a1 -> [a]'
08:05:24 <Peaker> now you are getting to the real problem here, that "map" wants a function, but is given a char
08:05:59 <`Ash> when i put 'in', it just returns 'cannot find function in'
08:06:23 <`Ash> let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
08:06:27 <`Ash> thats what i need ^
08:06:31 <`Ash> but the 'in' wont compile
08:06:40 <`Ash> > let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
08:06:41 <lambdabot>   "jamonetwo"
08:06:53 <`Ash> so i was trying to work around it with all this $ map stuff
08:07:56 <Peaker> `Ash: It does work, in a real .hs file, you'd use multiple lines and indentation instead of ;
08:08:02 <Goks> hi guy!
08:08:11 <`Ash> yeah but it wont complie in Hugs
08:08:28 <Peaker> `Ash: try   let { ... ; ... ; ... } in
08:08:42 <Peaker> `Ash: also, you could use ghci.. I think ghc is where all the exciting development is going
08:09:47 <`Ash> i use Hugs for my coursework tho. so it needs to complie there or i wont get the marks.
08:12:17 <Peaker> `Ash: does the let { .. } syntax work?
08:12:57 <`Ash> ERROR - Improperly terminated character constant
08:13:50 <`Ash> it'll only let me replace 1 character ... like '3' to 'three'
08:13:57 <`Ash> its not letting me replace 'd3' or '34'
08:15:04 <Peaker> `Ash: yes, if you iterate a string (list of chars) then you get it one char at a time
08:15:17 <Peaker> @hoogle String -> String -> String
08:15:18 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
08:15:18 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
08:15:18 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
08:15:35 <Peaker> @hoogle String -> String -> String -> String
08:15:36 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
08:15:36 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:15:36 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
08:16:19 <`Ash> im not doing that tho
08:17:57 <Peaker> `Ash: replacing subsequences is more difficult to do well
08:19:55 <`Ash> http://hpaste.org/11322
08:20:13 <`Ash> it works if my message is only 1 char '1' or 'a'.
08:20:23 <`Ash> but its not working if its more then 1 char.
08:20:39 <Peaker> the above example you used:
08:20:45 <Peaker> > let replaceDigits '1' = "one"; replaceDigits '2' = "two"; replaceDigits x = [x] in concatMap replaceDigits "jam12"
08:20:46 <lambdabot>   "jamonetwo"
08:21:06 <`Ash> yeah, but i have to let the user input the word they want changing.
08:21:31 <`Ash> so ive used x as the variable of the thing entered
08:21:32 <Peaker> `Ash: by "word", you mean the arg to replaceDigits?
08:21:54 <`Ash> I meen I cant just use the example above ^ because the jam12 is different everytime.
08:22:05 <`Ash> and its not working if i put a variable i
08:22:06 <`Ash> in*
08:22:27 <Peaker> `Ash: paste some code. I am not clear on what your question is
08:22:57 <Peaker> `Ash: you generally use a thin IO wrapper around a function like the above, and call it with the input from the user
08:23:06 <`Ash> I need a user to be able to enter a message, lets say 'hello5' and it be convered to 'hellofive'
08:23:15 <insane> hello did anyone try to install wxhaskell on gentoo?
08:23:24 <quicksilver> do x <- getLine; print (concatMap replaceDigits x)
08:23:27 <insane> because i get few errors while doing that
08:23:28 <quicksilver> ^^ something like that.
08:23:32 <`Ash> The problem Im having is being able to call the variable (the message tge user types in)
08:23:34 <quicksilver> `Ash: that's for you.
08:24:57 <`Ash> im still getting ERROR - Improperly terminated character constant
08:25:29 <pyNem> ok .. I think I have finally understood monads .. can someone verify? :) A monad is a "wrapper"/data constructor in some sense, which has two functions defined on it..  a) return - This just "lifts" a value into the wrapper (what, then is lift?) b) bind (>>=) bind acts as following. It takes in a monad of type a, x, and a function f :: (a->m b), breaks the monad x to give a, (remembers the other data in d1, say), then applies f x to get a monad y, breaks mon
08:25:29 <pyNem> ad y to get data d2, and value b ... appropriately merges data d2 and d1, and returns b wrapped with d1 and d2?
08:25:31 <quicksilver> `Ash: paste the ode.
08:25:37 <quicksilver> `Ash: hpaste.org
08:25:56 <`Ash> http://hpaste.org/11323
08:26:06 <pyNem> and of course there are the monadic laws
08:26:32 <Peaker> `Ash: Hugs surely supports indentation in a file.  Use indentation instead of {}
08:26:46 <quicksilver> `Ash: I don't understand why that would give the error about unterminated characte constant.
08:26:55 <quicksilver> `Ash: but I do wonder what that 'do' is supposed to be for.
08:26:58 <quicksilver> it has to have a name
08:27:04 <quicksilver> conventionally main = do....
08:27:16 <quicksilver> and you probably don't want the let on replaceDig
08:27:35 <`Ash> ive removed the let and brackets
08:27:37 <Peaker> `Ash: if you're not inside a "do" context, you should be able to define a name/value/function without the "let"
08:27:49 <`Ash> im inside the main do, i think
08:27:59 <quicksilver> `Ash: as in http://hpaste.org/11323#a1
08:28:01 <Baughn> What would be the best way to convert a lazy bytestring to a strict one? Just concat . chunks?
08:28:10 <quicksilver> Baughn: fromChunks, I believe
08:28:17 <quicksilver> may be the same thing.
08:28:37 <Baughn> quicksilver: Doesn't seem to exist
08:28:45 <Baughn> They'd be the same thing, if it did
08:28:57 <`Ash> comps taking ages to load. dam housemates downloading stuff. 2 secs.
08:29:28 <`Ash> im still getting the same error quick
08:29:35 <quicksilver> Baughn: it's in internal or something.
08:29:47 * Baughn has just written a dhcp relay in haskell. Now for the dns server...
08:29:52 <quicksilver> `Ash: that is your whole file?
08:30:06 <Baughn> quicksilver: Not in 6.10, it isn't
08:30:07 <quicksilver> `Ash: paste the whole file, if it isn't, and the exact error.
08:30:57 <quicksilver> Baughn: hmm. Maybe you're supposed to use foldrchunks now.
08:31:03 <`Ash> http://hpaste.org/11324
08:31:04 <quicksilver> or foldl chunks.
08:31:11 <quicksilver> that doesn't sound very efficient to me.
08:31:25 <`Ash> file:.\work.hs:22 - Syntax error in input (unexpected character literal)
08:31:40 <Baughn> concat has the exact type signature I want. I /expect/ it has the best implementation it can, so.. :)
08:31:43 <`Ash> line 22 being replaceDig '0' = "ZERO"
08:31:57 <Baughn> You may be overthinking this
08:32:23 <quicksilver> `Ash: you have broken indentation on line 22 and the following ones
08:32:23 <`Ash> it has to do other things further down in the program. not just change hello4 to hellofour
08:32:35 <`Ash> so they shud be same line at above ?
08:32:36 <quicksilver> `Ash: you don't want those to be indented.
08:32:42 <quicksilver> yes. they should be on the left margin.
08:32:56 <quicksilver> and my "main" function will break it because you already had a function called main ;)
08:33:00 <quicksilver> (I didn't know this)
08:33:05 <`Ash> the next error is the main function at the top yeah
08:33:13 <Peaker> does cabal-install and the rest of the stuff work with ghc-6.10 in general?
08:33:27 <`Ash> but i need the main at the top for the user to input right ?
08:33:38 <Baughn> Peaker: Does now
08:33:43 <Baughn> Peaker: Hackage is a different story
08:33:59 <Peaker> Baughn: without hackage, there's no use to it though?
08:34:31 <quicksilver> `Ash: you could call my "main" something else
08:34:35 <joey`> Can anyone point me in the direction of some papers/infomation on the implementation of haskell style type classes?
08:34:37 <Baughn> Peaker: It's just that a lot of hackage packages make assumptions that break in 6.10
08:34:51 <Baughn> Peaker: I see they've gotten preferred-versions in now, however. most things should work.
08:35:02 <quicksilver> `Ash: I also note you were inconsistent , calling it "replaceDig" in one place and "replaceDigits" in another.
08:35:19 <quicksilver> joey`: Not off hand. It's fairly simple in GHC; it passes the dictionary, in principle.
08:35:39 <quicksilver> joey`: the clever bit is that in practice the optimiser can normally remove the explicit dictionary pass.
08:35:41 <`Ash> now i get 'Last generator in do {...} must be an expression'
08:35:59 <`Ash> changed the inconsistancy
08:36:06 <quicksilver> you probalby broken the indentaion ;)
08:36:14 <quicksilver> "print" must line up with "x <-"
08:36:15 <Peaker> Baughn: I just removed all the Haskell-related debs, then installed ghc-6.10 on a clean setup, and now it seems I need to manually bootstrap cabal-install again
08:36:37 <Baughn> Peaker: Yeah, that happens. It's convenient to keep a binary around.
08:36:54 <Baughn> Peaker: Although you need the newest cabal-install for that to work with 6.10
08:37:10 <Baughn> Peaker: Oh, and the last version has some sort of bootstrap script, I believe
08:37:18 <`Ash> now we're back to the first error ... 'ERROR - Improperly terminated character constant'
08:37:18 <Peaker> Baughn: I think I had it but it complained about ghc-pkg failing.  I did mess up my install of ghc-pkg I suspect, though
08:37:19 <Baughn> Right, boostrap.hs
08:37:21 <Baughn> *.sh
08:37:35 <Peaker> ah cool
08:37:39 * Peaker runs it
08:37:40 <joey`> thanks quicksilver
08:38:00 <joey`> Google isn't throwing up a great deal, might just need to dig a little deeper
08:38:18 <quicksilver> joey`: try SPJ's papers
08:38:38 <quicksilver> `Ash: very odd. Paste current version again? and please paste exact error.
08:38:45 <therp> hm is "all about monads" on haskell.org still updated?
08:39:08 <`Ash> http://hpaste.org/11325
08:39:16 <`Ash> ERROR - Improperly terminated character constant
08:39:34 <joey`> quicksilver: Results, thanks!
08:39:49 <therp> http://www.haskell.org/all_about_monads/html/readermonad.html should be (Reader r) >>= f = Reader $ \e -> (runReader $ f (r e)) e
08:39:50 <lambdabot> Title: The Reader monad
08:40:23 <quicksilver> `Ash: there is nothign wrong with the code you pasted.
08:40:29 <quicksilver> `Ash: I copied it and ran it fine here.
08:40:37 <`Ash> its not compiling for me
08:41:03 <quicksilver> *Main> replace
08:41:03 <quicksilver> foo4bar5
08:41:03 <quicksilver> "fooFOURbarFIVE"
08:41:04 <dblazakis> `Ash: does it give a line/col on the error?
08:41:05 * Baughn frees up two gigabytes by deleting ~/.cabal - um, what?
08:41:12 <Baughn> Now I wish I hadn't. :/
08:41:19 <quicksilver> `Ash: the error must not be in the part you pasted.
08:41:35 <`Ash> thats the only thing in the file. i put it into a new file.
08:41:40 <Peaker> the bootstrap script of cabal-install: "*** Exception: lexical error at character '\DEL'" :-(
08:42:17 <`Ash> Main> replace '34'
08:42:17 <`Ash> ERROR - Improperly terminated character constant
08:42:30 * quicksilver slaps `Ash 
08:42:35 <quicksilver> that's not an error from your code.
08:42:40 <quicksilver> it's an error from the way you are caling it!
08:42:52 <quicksilver> '34' is illegal.
08:42:56 <`Ash> i called it the same way u did?
08:42:58 <quicksilver> no
08:43:01 <quicksilver> I just called replace
08:43:02 <quicksilver> no arguments
08:43:08 <quicksilver> it takes input from the user with getLine
08:43:13 <`Ash> when i just call replace i get an infinate loop
08:43:14 <quicksilver> (I thought that's what you wanted)
08:43:20 <quicksilver> no you don't. It's waiting for input
08:43:24 <quicksilver> type something.
08:43:58 <`Ash> it wont let me type anything till i interupt
08:44:34 <quicksilver> maybe it's letting you type, you just can't see it.
08:44:38 <quicksilver> I've never used hugs
08:44:40 <quicksilver> or winhugs
08:44:40 <pcc1> can anyone make sense of this error message: http://hpaste.org/11326
08:44:48 <quicksilver> `Ash: anyhow your error came from '34'
08:44:53 <quicksilver> '34' is not legal haskell syntax
08:44:58 <quicksilver> double quotes for strings "34"
08:45:03 <quicksilver> single quotes for characters '3'
08:45:08 <quicksilver> that's the thing to remember ;)
08:45:45 <`Ash> Main> replace
08:45:46 <`Ash> "hello45"
08:45:46 <`Ash> "\"helloFOURFIVE\""
08:45:49 <`Ash> i closed and reopened
08:46:08 <quicksilver> yay ;)
08:46:20 <`Ash> whats with the "\" ?
08:46:37 <quicksilver> you put quotes in (to the getLine)
08:46:52 <quicksilver> but I used print (not putStrLn)
08:47:00 <quicksilver> so it gets expressed as a haskell string
08:47:04 <quicksilver> has to escape the quotes.
08:47:12 <`Ash> k
08:47:13 <quicksilver> I should have use putStrLn really
08:48:36 <`Ash> thank functions done. thanks :D
08:48:37 <Peaker> "darcs get" is so slow...
08:48:39 <`Ash> that function*
08:50:01 <Goks> hi guy! i nee
08:50:04 <Goks> i need help
08:50:45 <Goks> i need to read an Int from keyboard, and i dont know any function to do that
08:51:48 <quicksilver> readLn
08:52:10 <catechu>  
08:52:14 <`Ash> ERROR file:.\work.hs:41 - Last generator in do {...} must be an expression
08:52:17 <`Ash> im guessing this is because i need another function ?
08:54:29 <lasts> `Ash, you should return something at the end of a do
08:54:44 <lasts> you can't end it with "x <- something" or "let x = something"
08:54:52 <`Ash> so right at the end of the program, since the only return i dont have is the main = do
08:55:34 <lasts> `Ash, well, return is just a function
08:55:43 <Ferdirand> return something does not mean you have to use return
08:56:05 <`Ash> ive already got what i want out of that function. how do i end it without doing anything else to it?
08:56:17 <lasts> `Ash, the block delimited by "do" should have a value
08:56:36 <`Ash> cap = do x <- getLine
08:56:40 <Ferdirand> if the last line in the do block is "x <- whatever", what is the point of x anyway ?
08:56:47 <`Ash> print (concatMap replaceDig x)
08:57:01 <`Ash> x is the variable that was typed in, to be replaced, i think.
08:57:06 <Ferdirand> oh, must be an indentation problem
08:57:21 <`Ash> i havnt closed the main, do get line at the top
08:57:32 <Baughn> "setup: The program happy is required but it could not be found" <-- While building happy. *groan*
08:57:37 <`Ash> unless printlnstring is closing it
08:58:08 <Ferdirand> the block gets closed by the first line who is less indented than the do keyword, iirc
08:58:31 <lasts> can you paste it `Ash ? :)
08:58:39 <`Ash> nvm i fixed it :D
08:58:46 <`Ash> it was an indentation problem
08:59:01 <luqui> Hey.  I'm making a module that provides references, LeftRef a and RightRef a, with an operation LeftRef a -> RightRef a -> IO a.
08:59:06 <luqui> so each pair can refer to a different value
08:59:27 <luqui> I'm wondering what I should call it.  I'm thinking ProductRef or QuotientRef, but I don't know which...
09:01:17 <badsheepy> why not ProvideReferences :o
09:01:27 <luqui> uh, what?
09:01:41 <luqui> oh, it was a joke.
09:01:46 <badsheepy> was not
09:02:01 <luqui> seriously?
09:02:02 <badsheepy> if your function provides references, why not call it that?
09:02:18 <luqui> no, my module provides -- i.e. implements -- them
09:02:26 <luqui> Data.IORef also provides references
09:02:32 <luqui> as does Data.MVar, Data.STRef, ...
09:04:51 <Ferdirand> ls
09:04:53 <Ferdirand> oops
09:05:13 <wchogg> So who exactly is responsible for Learn You a Haskell?  It's a rather cogent little tutorial so far.
09:05:29 <Asztal> BONUS, I think
09:06:17 <`Ash> Quicksilver: how would i get my program to do it automatically, instead of having to type 'replace' ?
09:06:27 <`Ash> because i have to do a few functions on the same message
09:06:39 <Baughn> Would any of you good people have an OS X binary of happy I could use?
09:06:42 <quicksilver> not sure what you mean by automatically, `Ash
09:07:03 <`Ash> well a user has to type in a message....
09:07:32 <`Ash> and i have functions to 'replace numbers' 'capitalise' and 'remove non letters'
09:07:48 <C-Keen> `Ash: well write a funciton that does IO and keeps calling your other function?
09:07:50 <`Ash> how can i get it so the user types 'message here' ... and it does the 3 functions, straight after each other ?
09:08:33 <rog> what can cause the "Invalid type signature" error message from GHC?
09:08:35 <quicksilver> replaceDigs ( capitalise ( removenonletter x ) )
09:08:36 <`Ash> can i do that without the user having to type anything c-keen?
09:08:41 <quicksilver> `Ash: like that ^^ ?
09:08:52 <Baughn> > 2 :: a,b
09:08:54 <rog> (it doesn't give any other clues....)
09:08:54 <lambdabot>   <no location info>: parse error on input `,'
09:09:03 <`Ash> kind of. but the user would still have to type something there?
09:09:18 <C-Keen> `Ash: where does your input come from?
09:09:18 <`Ash> you know in Hugs/GHCI where we typed 'remove' ... then it asked for input.
09:09:29 <`Ash> i dont want to have to type remove. i want to to just do it ... is it possible ?
09:09:31 <Baughn> rog: An interesting question, since it's mostly more verbose. What does?
09:09:46 <`Ash> im wanting the input to come frm the user, typing the message, to be used with the functions.
09:10:05 <C-Keen> `Ash: write a main and compile the program
09:10:10 <lilac> `Ash: do you know how to compile your program, rather than using ghci?
09:10:18 <rog> Baughn: i'll paste the code. could it have something to do with the fact that i'm using a record with 11 (yes, eleven) type parameters?
09:10:24 <quicksilver> lilac: he's using hugs
09:10:27 <`Ash> i thought using ghci was compiling lol :$
09:10:30 * quicksilver sigh
09:10:33 <quicksilver> or, I thought he was using hugs
09:10:36 <quicksilver> maybe you aren't?
09:10:39 <`Ash> yeah i use hugs
09:10:40 <Baughn> rog: Shouldn't. Arbitrary limits are bad, though that sounds hard to use.
09:10:46 <abbe> hi all
09:10:58 <`Ash> i have to use hugs. its coursework ... and its marked using hugs
09:10:58 <abbe> is '!' some haskell operator ?
09:11:08 <Baughn> abbe: Yep, array indexing usually
09:11:31 <rog> Baughn: it's not easy to use, but it's currently necessary...
09:11:53 <quicksilver> `Ash: like I said I've never used hugs
09:11:59 <abbe> Baughn: okay, can you tell me its significance in this haddock documentation of xmonad
09:12:01 <quicksilver> but you have to type *something* to start the program going
09:12:03 <abbe> Baughn: http://www.xmonad.org/xmonad-docs/xmonad/XMonad-Core.html
09:12:05 <lambdabot> Title: XMonad.Core
09:12:09 <quicksilver> is my understanding of hugs
09:12:24 <Baughn> abbe: Oh, that's a strictness annotation
09:12:44 <`Ash> so when compiled, i wouldnt have to type 'replace' ?
09:12:57 <abbe> Baughn: hmm...? something like perl's strict keyword ?
09:13:03 <Baughn> abbe: Basically saying "To reduce this value (data structure) to weak-head normal form, you also have to reduce this member to whnf"
09:13:47 <quicksilver> `Ash: well you'd still have to tell the computer to run the program
09:13:54 <quicksilver> you either have to type something or double click something
09:13:58 <rog> Baughn: it's at  http://hpaste.org/11328#a0
09:14:02 <quicksilver> psychic control is not very effective yet.
09:14:15 <abbe> Baughn: okay, what is weak-head normal form, if you didn't mind explaining ?
09:14:17 <Baughn> abbe: Which is.. um, whnf is basically the least amount of evaluation you can do on a value. For example evaluating a list to whnf would be evaluating its /first/ cell (but not the value of that cell); evaluating a number to whnf is (for all built-in numbers) equivalent to evaluating it to normal form, that is to say fully
09:14:26 <`Ash> i want to be able to do all 3 functions on the same variable, at the same time. without the user having to type 'remove' 'replace' etc..
09:14:42 <`Ash> i can run the program in hugs
09:15:05 <abbe> Baughn: is that some technique in functional languages ?
09:15:13 <Baughn> abbe: Implementation detail, more like
09:15:13 <quicksilver> rog: the problem is not with the type signature
09:15:24 <`Ash> atm its working, but im typing 'replace' 'message' 'remove' 'message' etc...
09:15:26 <quicksilver> rog: the problem is that you are trying to assing a type signature to a constructor, I think.
09:15:32 <abbe> Baughn: okay, thanks for the help :)
09:15:36 <`Ash> i want to be able to type 'message' ... then it replaces/removes/etc automatically
09:15:41 <Baughn> abbe: http://haskell.org/haskellwiki/Performance/Strictness <-- Details
09:15:42 <lambdabot> Title: Performance/Strictness - HaskellWiki
09:15:46 <quicksilver> `Ash: yes you can do that, and I told you how to do it.
09:15:56 <quicksilver>  < quicksilver> replaceDigs ( capitalise ( removenonletter x ) )
09:16:03 <quicksilver> ^^ make the message function do this
09:16:09 <`Ash> do i put that in main ?
09:16:19 <quicksilver> you put it wherever you want to.
09:16:23 <rog> Baughn: yes, i'm blind! wrong capitalisation. it was quite misleading error message though!
09:16:24 <`Ash> k thanks
09:16:25 <quicksilver> you put it in the action you want to call.
09:16:38 <quicksilver> you said 'message' not 'main'
09:16:42 <quicksilver> but whichever you want :P
09:16:44 <rog> Baughn: thanks for answering my triviality!
09:16:47 <abbe> Baughn: okay, thanks for the link
09:16:58 <Baughn> rog: Er, that was Mercury. ^^;
09:17:40 <C-Keen> `Ash: http://cvs.haskell.org/Hugs/pages/users_guide/faq.html#AEN1932 see also http://cvs.haskell.org/Hugs/pages/users_guide/others.html#RUNHUGS
09:17:41 <lambdabot> Title: Frequently Asked Questions about Hugs
09:18:07 <rog> Baughn: so it was. ta quicksilver.
09:18:22 <Peaker> yay, cabal is working again, with ghc-6.10
09:18:57 <rog> now i'm just back to working my way through 300 lines of compiler error messages...
09:19:04 <Baughn> abbe: Oh, and I know I said it's an implementation detail, but understanding it is very important for non-trivial haskell programs
09:19:12 <Peaker> rog: usually only the first one is interesting, and then recompile ;)
09:20:00 <Baughn> rog: You're on os x. Could you send me a binary of happy? *puppy-dog eyes*
09:20:28 <rog> Peaker: indeed. but in this case it's symptomatic of the fact that i've mutated and written too much code before compiling. well, it was kinda necessary.
09:20:39 <rog> Baughn: i'll see what i can do
09:21:00 <Baughn> rog: Please. I can't compile it, because it depends on itself
09:21:16 <rog> Baughn: it's compiling
09:21:31 <Baughn> rog: You're not on 6.10, probably. :P
09:22:10 <Peaker> Baughn: I just hit the same happy problem
09:22:12 <`Ash> im getting ERROR file:.\work.hs:107 - Type error in application when i use ur method quicksilver.
09:22:27 <Baughn> Peaker: At least we're happy about it
09:22:37 <Baughn> Peaker: Yeah, that'll teach me to keep the binary around
09:22:51 <quicksilver> `Ash: I've given you a lot of help, but I don't think you're really engaging with the problem here.
09:22:57 <Peaker> also network fails to build because it lacks Data.Generics, which is a member of package base-3.0.3.0, which is hidden
09:23:11 <quicksilver> `Ash: I'm not going to be able to guess the problem from the error message without seeing the exact code.
09:23:24 <quicksilver> `Ash: I've shown you how to apply a function to the results of another function.
09:24:01 <`Ash> yeah i know. the other functions are working perfectly now.
09:24:01 <Deewiant> Peaker: just give it an additional base<4 constraint
09:24:10 <`Ash> its when i put the functions together
09:24:18 <Peaker> Deewiant: how?
09:24:26 <`Ash> "print replaceDig ( remNonAlpha ( capString x ) )"
09:24:39 <Deewiant> Peaker: --constraint="base < 4"
09:24:49 <Deewiant> to setup configure or cabal-install, I think it's the same for both
09:24:59 <`Ash> ive just dont it in the same way i did them seperately ... do x <- getLine, with that underneath
09:25:04 <`Ash> done*
09:25:17 <Baughn> Peaker: That constraint should already be in preferred-versions
09:25:21 <Peaker> Deewiant: I tried: cabal install network --constraint="base < 4"   but it doesn't seem to have an effect
09:25:27 <Baughn> Peaker: Which means it'd work if you did a cabal update first
09:25:35 <Peaker> Baughn: I'm cabal-updated
09:25:55 <Baughn> Hmm
09:26:04 <Deewiant> Peaker: hmm, see what -v says at the beginning about choosing package versions
09:26:06 <Baughn> Peaker: Oh, actually, for network I think you'd be best off using the 6.10 branch
09:26:08 <quicksilver> `Ash: that calls print with two parameters
09:26:14 <quicksilver> `Ash: first being 'replaceDig'
09:26:19 <Baughn> Peaker: That is, install it as part of ghc, with darcs-all --extra get
09:26:25 <quicksilver> `Ash: second being '( remNonAlpha ( capString x ) )'
09:26:37 <quicksilver> `Ash: see how that is a problem?
09:26:38 <`Ash> isnt that what im wanting to do? ... im wanting to do the same as last time, but with more then 1 function.
09:26:45 <quicksilver> no.
09:26:51 <quicksilver> you're wanting to call print with one parameter
09:26:53 <Peaker> selecting base-3.0.3.0 (installed) and 4.0.0.0 (installed)
09:26:53 <Peaker> Dependency base -any && ==4.0.0.0: using base-4.0.0.0
09:26:56 <quicksilver> (print only takes one parameter)
09:27:00 <quicksilver> which is the string to print.
09:27:08 <quicksilver> well, the "whatever" to print.
09:27:15 <Peaker> Baughn: ghc from darcs doesn't build for me
09:27:19 <Peaker> Baughn: I use the ghc-6.10 release
09:27:25 <quicksilver> what you want is print (replaceDig ( remNonAlpha ( capString x ) ))
09:27:26 <Deewiant> Peaker: hmph, that could be odd
09:27:34 <quicksilver> `Ash: but the important point is, do you see the difference?
09:27:40 <Deewiant> -any && ==4
09:27:40 <`Ash> i have tried that, given me the same error
09:27:55 <`Ash> yeah the difference is its printing 1 parameter, with all function in
09:27:58 <`Ash> instead of 2
09:28:00 <Baughn> Peaker: You tried http://darcs.haskell.org/ghc-6.10/ghc?
09:28:01 <lambdabot> Title: Index of /ghc-6.10/ghc
09:28:14 <quicksilver> what exact error do you get, for what exact program?
09:28:21 <Peaker> Baughn: nope, I'll try that (it will take hours to download and compile, probably)
09:28:39 <Deewiant> Peaker: easiest thing to do is download the .tar.gz of network and modify the .cabal file.
09:28:42 <`Ash> ERROR - Type error in application
09:28:47 <`Ash> done not match a -> b
09:28:58 <Peaker> Deewiant: to use base 4?
09:29:09 * rog wishes that when GHC says "expected type ..., inferred type ..." he could find out where the expectation came from
09:29:11 <Deewiant> Peaker: I've managed to get network-2.2.0.0 installed with my 6.10, let me check :-P
09:29:26 <`Ash> nvm i fixed it
09:29:29 <`Ash> thanks for ur help quick.
09:29:36 <Peaker> Deewiant: there's no mention of versions in the network-2.2.0.0 network.cabal file
09:29:36 <Deewiant> Peaker: looks like it uses base-4, yes... probably I changed imports of Data.Generics to Data.Data (IIRC that was the fix)
09:29:48 <Peaker> Deewiant: ah
09:29:52 <Peaker> let me try..
09:30:00 <int-e> Peaker, Deewiant: http://darcs.haskell.org/ghc-6.10/packages/network/ claims to be 2.2.0.0 but has updates to make it build with 6.10
09:30:01 <lambdabot> Title: Index of /ghc-6.10/packages/network
09:30:03 <quicksilver> `Ash: you're welcome.
09:30:56 <Peaker> Deewiant: nice, I changed the tarball inplace (emacs can do that) and cabal fails checksum validation ;)
09:31:11 <Peaker> int-e: thanks
09:31:32 <Deewiant> Peaker: don't do that, untar it and runghc Setup :-P
09:31:37 <Peaker> Deewiant: heh ya
09:31:58 <Deewiant> didn't even know that cabal does checksum validation
09:33:03 <abbe> Baughn: do we need strictness to have assure tail recursion in recursive functions, hmm..?
09:33:13 <abbe> s/have a/a/
09:33:39 <quicksilver> no.
09:33:48 <quicksilver> tail recursion does not require strictness.
09:34:11 <quicksilver> however, tail recursion without appropriate strictness may cause problems later.
09:36:25 <abbe> quicksilver: okay, but it requires that there're no post evaluation needed after next invocation of the routine, it is like keeping the original return address on the stack, and instead of CALLing the next invocation, you're JMPing to the next invocation. (CALL, JMP - the x86 assembly mnemonics)
09:37:01 <abbe> quicksilver: like as shown in the factorial example on the http://haskell.org/haskellwiki/Performance/Strictness
09:37:02 <lambdabot> Title: Performance/Strictness - HaskellWiki
09:37:23 <dcoutts> Deewiant: what checksum validation? I don't know of any
09:37:33 <Deewiant> dcoutts: what Peaker said
09:37:34 <Peaker> I manually installed network-2.2.0.0 from that darcs repo, and "cabal" still wants to overwrite it with the hackage one
09:37:47 <quicksilver> abbe: well, yes but no.
09:37:57 <Peaker> dcoutts: I changed the network .tar.gz in-place and it failed to install on a checksum validation
09:38:04 <quicksilver> abbe: tail recursion doesn't require "no post evaluation at all"
09:38:16 <quicksilver> in a lazy language most constructs produce thunks
09:38:24 <quicksilver> which are obviously a kind of post-evaluation.
09:38:40 <abbe> quicksilver: yes, so you've to keep track of those thunks
09:38:46 <quicksilver> tail recursion simple requires that a call to the function reduces to another call to this function
09:38:48 <dcoutts> Peaker: oh, it must be that you constructed an invalid compresses .tar.gz file
09:38:53 <quicksilver> tail recursion is a syntactic property
09:39:01 <Peaker> dcoutts: I let emacs change a .tar.gz in-place
09:39:03 <quicksilver> and is itself totally orthogonal to strictness or thunks.
09:39:03 <abbe> quicksilver: which means you're not doing 100% tail-recursion
09:39:09 <quicksilver> no, it doesn't.
09:39:12 <Peaker> dcoutts: maybe that feature is broken
09:39:16 <quicksilver> you can't define tail recursion to mean something esle if you like
09:39:20 <quicksilver> (And then you'd be wrong)
09:39:24 <dcoutts> Peaker: decompressing with zlib uses a checksum
09:39:30 <quicksilver> s/can't/can/
09:39:37 <quicksilver> f x = f (x+1)
09:39:41 <quicksilver> ^^ this is tail recursive
09:39:43 <dcoutts> Peaker: if you use gunzip, it'll almost certainly tell you the same thing
09:39:49 <quicksilver> it may or may not still have a strictness problem.
09:39:57 <quicksilver> depending how smart your compiler is feeling today.
09:40:01 <quicksilver> but it's definitely tail recursiv.
09:40:19 <Peaker> dcoutts: a feature like in-place .tar.gz editing in emacs is not surprising if its unreliable :)
09:41:49 <maltem> abbe: there's a difference between tail recursion, and good optimization of tail recursion
09:41:55 <Peaker> dcoutts: I installed network-2.2.0.0 (fixed without version number change) with "darcs install" successfully, but "cabal upgrade" still wants to overwrite it with the broken "network" package from hackage. Any idea why?
09:42:06 <Peaker> s/darcs install/cabal install
09:43:00 <Peaker> dcoutts: from the darcs repo mentioned by int-e above
09:43:34 <Deewiant> Peaker: is it built against base-3? cabal-install may want to upgrade it to base-4
09:44:36 <abbe> maltem: okay
09:44:53 <abbe> maltem, quicksilver: thanks
09:45:45 <Peaker> Deewiant: yeah, int-e's link is base-3 indeed
09:45:50 <Peaker> (Data.Generics, that is)
09:46:01 <Deewiant> Peaker: yeah, so my way is better ;-)
09:46:14 <Deewiant> or rather, cabal upgrade is stupid
09:46:17 <int-e> Peaker: the link is not magical btw, it's the location of the 'network' extra library for the ghc-6.10 branch.
09:46:31 <int-e> Peaker: darcs-all --extra get  will fetch it.
09:46:57 <Peaker> I don't use ghc from darcs, it wouldn't build for me
09:48:39 <dcoutts> Peaker: run with --dry-run -v it'll tell you how it'll install network-2.2.0.0 differently. It'll probably be due to different deps.
09:49:25 <Peaker> trying to convert it to build with base 4, now I'm getting "Network.hs:260:29: Not in scope: `Exception.ioErrors'" what replaces that?
09:50:01 <Peaker> @hoogle ioErrors
09:50:02 <lambdabot> Control.Exception ioErrors :: Exception -> Maybe IOError
09:50:30 <Deewiant> Peaker: import Control.OldException
09:50:44 <Peaker> Deewiant: thanks, it builds!
09:50:53 <Deewiant> yay :-)
09:51:25 <Peaker> arrg, now "cabal install" decided to reconfigure/rebuild what already built, and now its hiding base, instead of the old base-3
09:51:51 <Peaker> if I configure --user, do I need to install --user as well?
09:52:31 <dcoutts> dons: you've not released the new network package?
09:52:35 <dcoutts> Peaker: no
09:53:24 <Peaker> dcoutts: why does "cabal install" restart from scratch, after cabal build finished successfully?
09:53:37 <Peaker> and why does it have different base hiding clauses
09:53:45 <dcoutts> Peaker: it's an all in one operation, configure + build + install
09:54:01 <dcoutts> Peaker: I don't know what you mean exactly
09:54:08 <Peaker> dcoutts: but I've already done the first 2, is there any way to do just the 3rd?
09:54:30 <dcoutts> Peaker: install --only
09:54:35 <Peaker> dcoutts: cabal configure --user && cabal build # finish successfully.  cabal install # redoes configure/build and fails because its using base-3 instead of base-4, it seems (it can't find OldException anymore)
09:54:54 <Baughn> Peaker: You don't have to run cabal build before install
09:55:00 <Peaker> dcoutts: ah, thanks. That worked, and cabal upgrade now doesn't try to overwrite network
09:55:22 <Peaker> now happy is failing because of that self-dep :)
09:55:25 <dcoutts> Peaker: yes, it picks base-3 because that's the sensible thing to do. If your package needs base 4 then add it as a constraint in the build-depends
09:55:48 <dcoutts> Peaker: defaulting to base 3 makes all the older packages work
09:55:50 <Peaker> dcoutts: but why is it picking a different base when I use "configure --user && build" vs "install" ?
09:56:22 <Baughn> Of course just getting a happy binary didn't help, since it needs some support files too.
09:56:28 <Baughn> How *are* you supposed to bootstrap it?
09:57:13 <dcoutts> Peaker: cabal configure uses the stupid method of picking versions of dependencies
09:57:34 <dcoutts> Peaker: it's currently only cabal install that uses the smart algorithm
09:58:24 <Peaker> dcoutts: oh
09:58:49 <Peaker> how can I tell what's keeping base-3 around?
09:59:53 <dcoutts> Peaker: loads of things will depend on base-3
10:00:01 <dcoutts> Peaker: it's not a problem
10:00:35 * olsner read "base-3" as the number system and went confused
10:01:06 <Peaker> dcoutts: why aren't version dependencies handled the Debian way, as in: Split the package into two names: libblah1 and libblah2 ?
10:02:02 <dcoutts> Peaker: because it's the wrong approach
10:02:25 <Peaker> dcoutts: works for Debian ;)
10:02:42 <dcoutts> Peaker: it's a hack. we can have multiple versions of a package installed at once without problem.
10:02:55 <dcoutts> Peaker: they have to do it because the only allow one at once
10:03:08 <dcoutts> so they move parts of the version number into the name
10:03:13 <Peaker> well, a single compilation cannot use two versions at the same time, right?
10:03:25 <Peaker> it has to "hide" some of them
10:03:49 <Saizan> but you can still use packages built against different versions of the same package
10:03:52 <dcoutts> Peaker: for the most part, yes. We can of course end up using two versions of base in a solution.
10:04:38 <Baughn> But that only works because base-3 actually uses code from base-4, right?
10:04:49 <Peaker> dcoutts: what's that warning message about relying on differing versions likely to cause compilation errors?
10:05:18 <dcoutts> Peaker: you mean why do we have that warning?
10:05:34 <Peaker> yeah, if its perfectly fine
10:06:09 <dcoutts> Peaker: it warns when it is appropriate to warn
10:06:17 <Peaker> I apt-got happy to bootstrap the install of happy, but it needs ghc-prim, which is hidden..
10:06:54 <dcoutts> Peaker: so it does not warn about two versions of base are in a solution, but it does warn about most other times when you get two versions of a package.
10:07:10 <dcoutts> Peaker: the warning is usually correct
10:07:25 <Peaker> dcoutts: ok. I thought the warning meant that in general you want to avoid mixing versions of the same package in a solution
10:07:52 <dcoutts> Peaker: of course you never get the warning with cabal install, because it finds valid solutions, you can get it with configure since it just picks highest versions of deps
10:08:06 <dcoutts> Peaker: that's correct you do want to avoid that
10:08:09 <nominolo|msr> dcoutts: do you happen to have your quick'n'dirty graphviz code still up somewhere?
10:08:30 <vixey> oh hi dcouttse
10:08:31 <dcoutts> Peaker: except for base 3 + 4 which are specifically designed to work together (base 3 depends on base 4)
10:08:37 <vixey> I wanted to ask you something about zlib
10:08:40 <Peaker> dcoutts: ah, its all clear now, thanks
10:08:53 <vixey> if you have a moment
10:08:54 <dcoutts> nominolo|msr: on my haskell.org/~duncan/ page
10:09:00 <dcoutts> vixey: aye
10:09:33 <Peaker> I have manually exposed ghc-prim, but its still complaining that it is hidden..
10:09:52 <nominolo|msr> dcoutts: thanks
10:11:18 <vixey> dcoutts: So I was trying to build Agda 2 but I have some zlib linking errors for inflateInit2 and deflateInit2 which are defined as macros in a header file. but then the .hsc tries to link them in as C.. so to fix it (and this is probably not the best possible fix but it does work at least) I defined inflate(deflate)Init2 in terms of inflate(deflate)Init2_ in haskell
10:11:44 <dcoutts> vixey: are you using the latest released zlib ?
10:11:47 <vixey> yes
10:11:55 <dcoutts> oh, I thought I fixed that already
10:12:09 <dcoutts> to make it work with -fasm
10:12:15 <dcoutts> and ghc-6.10
10:12:17 <vixey> I downloaded this tgz from hackage and bulit it with runhaskell setup
10:12:22 <vixey> oh I'm using 6.11 by the way
10:12:52 <dcoutts> vixey: what OS?
10:12:54 <hugo_> i have just managed to make another friend tryout haskell :D (he is a C++ programmer)
10:12:55 <Peaker> why would the cabal build process complain that an exposed package is hidden?
10:13:10 <dcoutts> Peaker: because it's not listed in the build-depends
10:13:14 <vixey> mac
10:13:48 <dcoutts> vixey: so preprocessing the .hsc is what fails is it?
10:14:17 <Peaker> dcoutts: thanks again
10:14:30 <vixey> oh also was wondering, _if_ cabal install worked
10:14:42 <vixey> and I used that, would I get the same problems or would it all work fine?
10:15:08 <Lemmih> dcoutts: Hiya, do you happen know what haddock annotations works on hackage?
10:15:11 <hugo_> if someone asked you "what are the advantages of recursion?" what would you answer ?
10:15:20 <dcoutts> vixey: I'd expect it'd give the same result
10:15:24 <vixey> ok
10:15:37 <dcoutts> vixey: are you absolutely sure you're using the latest zlib version?
10:15:53 <dcoutts> vixey: the latest version already imports inflateInit2_
10:16:01 <vixey> dcoutts: I just got the zlib source code built and installed it before compiling the haskell binding
10:16:42 <dcoutts> vixey: it's just that the changes you say you had to make sound like exactly the changes that have already been made, which is what is confusing me
10:16:58 <dcoutts> vixey: perhaps you can send me a patch against the version you're using
10:17:21 <dcoutts> Lemmih: do you mean in the .cabal file description?
10:17:23 <vixey> I'm using your zlib-0.4.0.3 (with a couple things edited)
10:17:34 <vixey> and the zlib-1.2.3 from zlib.org
10:17:36 <dcoutts> vixey: ah ok, so not the latest version then
10:17:47 <dcoutts> that makes a lot more sense
10:17:59 <vixey> arg!
10:18:02 <vixey> ok problem solved :)
10:18:14 <vixey> somehow I was on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.3 ...
10:18:18 <vixey> and I didn't notice there are other versions
10:18:19 <lambdabot> Title: HackageDB: zlib-0.4.0.3, http://tinyurl.com/5l6oaj
10:18:27 <dcoutts> vixey: np :-)
10:18:42 <dcoutts> vixey: so lemme know if that's working ok on osx then
10:19:00 <vixey> mm..
10:19:03 <vixey> I have everything working now
10:19:11 <ikegami__> mac had the old problem in zlib, and dcoutts kindly fixed it
10:19:13 <vixey> I'm kind of apprehensive to touch everything, it could all fall apart
10:19:26 <vixey> touch anything*
10:19:43 <theunixgeek> > [ (a,b,c) | a <- [1..500], b <- [1..500], c <-[1..500], a^2 + b^2 == c^2, a+b+c==1000]
10:19:51 <Peaker> I can't seem to find the checkers URL (A dependency of reactive)
10:19:58 <lambdabot>   thread killed
10:20:15 <ikegami__> it is nice if Agda works with GHC 6.10
10:20:21 <theunixgeek> > [ (a,b,c) | a <- [1..50], b <- [1..50], c <-[1..50], a^2 + b^2 == c^2, a+b+c==100]
10:20:24 <lambdabot>   []
10:20:38 <vixey> ikegami__: for me it is working (but very slow) with 6.11
10:20:58 <theunixgeek> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <-[1..10], a^2 + b^2 == c^2, a+b+c==14]
10:21:00 <lambdabot>   []
10:21:05 <theunixgeek> ?
10:21:20 <int-e> 3+4+5 is 12
10:21:22 <theunixgeek> Why isn't lambdabot returning [(3,4,5)] ?
10:21:23 <ikegami__> In this November, the developer team of Agda will visit Japan, and do hackathon
10:21:24 <theunixgeek> oh
10:21:25 <theunixgeek> woops
10:21:32 <theunixgeek> I was thinking 5, 5, 4
10:21:39 <theunixgeek> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <-[1..10], a^2 + b^2 == c^2, a+b+c==12]
10:21:41 <lambdabot>   [(3,4,5),(4,3,5)]
10:21:43 <lilac> theunixgeek: because lambdabot can add small numbers together with alarming accuracy :D
10:21:47 <theunixgeek> yay :)
10:21:54 <theunixgeek> lilac: lol :P
10:22:17 <theunixgeek> I have no idea what I was thinking... 5, 5, 4? :/
10:22:23 <theunixgeek> oh well
10:22:30 <theunixgeek> one of those sudden blank moments, I guess
10:22:58 <theunixgeek> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <-[1..10], a^3 + b^3 == c^3]
10:23:00 <lambdabot>   []
10:23:08 <theunixgeek> > [ (a,b,c) | a^3 + b^3 == c^3]
10:23:10 <lambdabot>   []
10:23:24 <theunixgeek> wow
10:23:27 <theunixgeek> it doesn't exist
10:23:32 <theunixgeek> either that or I'm typing something wrong
10:24:03 <younder> a=b=c=1
10:24:11 <lilac> theunixgeek: you didn't define a, b or c
10:24:13 <theunixgeek> I'm trying two find three integers that can properly fit into a^3+b^3=c^3
10:24:21 <lilac> theunixgeek: lambdabot is doing SimpleReflect magic
10:24:22 <theunixgeek> younder: three different integers
10:24:30 <int-e> theunixgeek: c = 0, a = -1, b = 1
10:24:38 <Deewiant> > [ (a,b,c) | a <- [1..], b <- [1..], c <-[1..], a^3 + b^3 == c^3]
10:24:44 <younder> You didn't spesify that
10:24:45 <Deewiant> ;-P
10:24:48 <theunixgeek> I*
10:24:52 <theunixgeek> positive ones
10:24:54 <lambdabot>   thread killed
10:24:58 <theunixgeek> Deewiant: oh, you can do [1..
10:25:04 <theunixgeek> ] ?
10:25:06 <theunixgeek> cool, I didn't know that
10:25:06 <int-e> theunixgeek: you know it can't be done, don't you?
10:25:06 <Peaker> hmm.. ghc-6.10 is claiming (>>>) is not a visible method of class Arrow (after a simple "import Control.Arrow" import). How come?
10:25:07 <Deewiant> yeah but it won't work
10:25:09 <lunabot>  luna: Not in scope: `?'
10:25:13 <Deewiant> Peaker: because it isn't
10:25:15 <theunixgeek> int-e: I was curious :)
10:25:23 <Deewiant> Peaker: I wrote in the wiki about this, let's see if I can find the page :-P
10:25:30 <Peaker> Deewiant: it changed in ghc 6.10?
10:25:33 <theunixgeek> for some reason I'm not that good at math today
10:25:36 <younder> By fermants little theorem this diophane equation  does'nt have one
10:25:47 <theunixgeek> this is weird
10:26:05 <int-e> Peaker: it's in a different type class, Control.Category.Category, now
10:26:06 <theunixgeek> I'll eat an apple to see if I can boost my energy up... I'm really sleepy right now :P
10:26:08 <Deewiant> Peaker: looks like it's been heavily edited, http://haskell.org/haskellwiki/Upgrading_packages#Arrow_instances
10:26:09 <lambdabot> Title: Upgrading packages - HaskellWiki
10:26:19 <Deewiant> int-e: no, (>>>) is not a class function
10:26:27 <Deewiant> it's defined as f >>> g = g . f
10:26:32 <lilac> theunixgeek: are you trying to disprove fermat's last theorem in haskell, because i think that might be a little hard for a haskell newbie ;)
10:26:33 <Deewiant> and (.) is in Category.
10:26:49 <int-e> Deewiant: oh I see, but close enough really.
10:27:10 * int-e isn't a fan of that change
10:27:25 <Peaker> Deewiant: do you have to define id = arr id? Is there no default id implementation?
10:27:27 <theunixgeek> lilac: what *is* Fermat's last theorem? :P
10:27:50 <Deewiant> Peaker: there is none. At the time of writing I didn't even know you could do that, I had to derive it myself whenever a package didn't build :-P
10:27:55 <Peaker> I thought Andrew Wiles already proved Fermet's last theorem
10:27:58 <theunixgeek> lilac: oh, that one
10:28:03 <Valodim> fermat proved fermat's last theorem
10:28:04 <lilac> theunixgeek: there exist no non-trivial solutions of a^n + b^n = c^n for n > 2
10:28:12 <lilac> Valodim: allegedly ;-)
10:28:21 <Peaker> Deewiant: what do you mean? didn't know about default methods?
10:28:31 <Deewiant> Peaker: I didn't know id = arr id would work.
10:28:58 <Deewiant> Peaker: so I just looked at the data type and figured something out which matched the type signature.
10:29:08 <Peaker> Deewiant: oh, ok
10:29:09 <lilac> id = arr id won't work :)
10:29:22 <Deewiant> id = arr Prelude.id would, I suppose
10:29:33 <Deewiant> I suppose that's what's meant, anyway :-P
10:29:48 <lilac> actually, id = arr id might work for Arrows where arr f doesn't force f
10:30:00 <lilac> i don't suppose those are popular though
10:30:07 <int-e> lilac: and why not? (->) is an instance of Category
10:30:09 <theunixgeek> > removeUppercaseLetters :: [
10:30:11 <lambdabot>   <no location info>: parse error on input `;'
10:30:14 <theunixgeek> woops
10:30:25 <theunixgeek> > removeUppercaseLetters :: [Char] -> [Char]
10:30:26 <lambdabot>   Not in scope: `removeUppercaseLetters'
10:30:32 <Deewiant> ?ty arr
10:30:33 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:31:04 <int-e> lilac: id = arr id  is not recursive; these are two different 'id' from two different instances of Control.Category.
10:31:09 <theunixgeek> > removeUppercaseLetters string = [c | c <- string, c `elem` ["a".."z"]]
10:31:10 <int-e> .Category.
10:31:10 <lambdabot>   <no location info>: parse error on input `='
10:31:21 <lilac> int-e: because arr f = f for (->), the definition is id = id, for (->)
10:31:34 <Peaker> Deewiant: "arr" is not an exposed method of Category either, what replaces that?
10:31:40 <lilac> pure?
10:31:42 <int-e> lilac: so it doesn't work for (->). Hmm, is that what you said, if so I missed that.
10:31:54 <Deewiant> Peaker: it's an exposed method of Arrow
10:32:08 <Deewiant> Peaker: Arrow still exists, some stuff just moved around :-)
10:32:09 <lilac> int-e: which in turn means it doesn't work for any Arrow which uses the argument to arr, since that's being passed (->)'s id
10:32:19 <Peaker> I don't get it. Arrow remains, but (>>>) became (.)? if so, what's Category?
10:32:26 <int-e> Peaker: it's part of the Arrow class
10:32:28 <Deewiant> (.) went in to Category
10:32:45 <Peaker> Class aliases are in ghc-6.10, and that's what's happening here?
10:32:51 <int-e> Peaker: (>>>) got renamed to (.) (flipping the arguments) and moved to its own class, Category.
10:32:55 <Deewiant> no, Arrow is just a subclass of Category
10:32:59 <Peaker> oh, ok
10:33:17 <Deewiant> man, now you made me all sad about the lack of class aliases :-P
10:33:26 <int-e> Peaker: the  id = arr id  advice is for converting existing Arrow instances to the new base lib.
10:33:43 <Deewiant> that whole section is, really.
10:35:00 <Peaker> backwards compatibility thrown to hell, I see ;)
10:35:21 <Deewiant> actually, they've done a pretty good job with backwards compatibility
10:35:29 <Deewiant> but that kind of change can't be made backwards compatible :-/
10:35:49 <lilac> are the 6.10 docs online somewhere?
10:36:00 <Deewiant> not to my knowledge
10:36:16 <C-Keen> hm cabal's error reporting is not really helpful: The exception was:
10:36:16 <C-Keen> exit: ExitFailure 1
10:36:20 <C-Keen> does not help a bit
10:36:22 <Deewiant> unless you count "in a .tar.gz incidentally containing a GHC binary" as "online somewhere" :-P
10:37:44 <dcoutts> C-Keen: yeah, sorry, for the moment you have to look higher up it the build log
10:38:25 <Peaker> hey, I got it to compile. No idea if the changes I made make any sense
10:38:55 <Deewiant> Peaker: that's pretty much how I felt but I guess static typing makes sure, I haven't run into problems yet :-P
10:39:19 <C-Keen> dcoutts: don't be :)
10:39:38 <Peaker> Reactive fails to compile: src/FRP/Reactive/VectorSpace.hs:11:7: Could not find module `Data.AdditiveGroup'
10:39:41 <Peaker> any idea where that is?
10:40:25 <Peaker> oh its in vector-space itself, which supposedly installed ok
10:41:01 <int-e> @google AdditiveGroup
10:41:03 <lambdabot> No Result Found.
10:41:18 <Peaker> I have vector-space installed, and it does declare such a module.
10:41:20 <int-e> lambdabot: oh?
10:41:36 <Peaker> "module Data.AdditiveGroup ..."
10:42:09 <int-e> Peaker: is that the whole error or does it continue?
10:42:23 <Peaker> ah, the cabal file of vector space does not specify that data module
10:42:42 <Peaker> int-e: its the whole thing
10:43:24 <Peaker> BeelsebobWork: hey, should I tell you or conal about a bug in the .cabal file in the darcs latest of vector-space?
10:44:18 <Peaker> I'm getting addicted to the darcs releases of everything ;)
10:44:49 <Peaker> Deewiant: with class alises, would it be possible for the arrow/category split to be backwards compatible?
10:45:18 <Deewiant> I don't think so but I'm not exactly an expert in the subject
10:45:49 <Peaker> I think the class aliases let them move the methods around, but not rename them easily (>>>) to (.)
10:46:01 <Peaker> Why was the rename done?
10:46:08 <Peaker> import hiding Prelude is no fun
10:47:00 <luqui> Peaker, well you could alias I think.
10:47:09 <luqui> you just couldn't remove one of them
10:49:21 <Peaker> Where is the package: http://www.haskell.org/haskellwiki/FieldTrip  itself?  Can't find a darcs/download page
10:49:22 <lambdabot> Title: FieldTrip - HaskellWiki
10:51:40 <dcoutts> Peaker: I think it got renamed actually, ask conal
10:52:04 <Peaker> Ok.  BeelsebobWork probably knows too (his example is using it)
10:54:43 <chrisdone> beep
10:54:54 <saml> > head [[a,b,c], x, y, z]
10:54:55 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
10:55:20 <olsner> it's amazing how much of agile development feels just like lazy evaluation of programming effort
10:55:23 <saml> > fst ((a,b,c), x, y, z)
10:55:24 <lambdabot>   Couldn't match expected type `(a, b)'
10:55:39 <saml> is there n-th function for n-tuples?
10:55:40 <luqui> > fst ((a,b,c),d)
10:55:41 <lambdabot>   (a,b,c)
10:55:45 <luqui> saml, unfortunately not
10:55:51 <olsner> only for n = 2 :P
10:56:47 <luqui> saml, just write the ones you need.  I like the naming scheme proj2_4 = \(x,y,z,w) -> y
10:57:01 <saml> > let nth n () = (); nth n (a) | n == 0 = a; nth n (a,b) = nth (n - 1) (b) in nth 3 (1,2,3)
10:57:02 <lambdabot>   Couldn't match expected type `()' against inferred type `(a, b)'
10:57:07 <Deewiant> just don't use anything bigger than triples :-P
10:57:34 <luqui> saml, it is impossible to write one which takes an Int
10:57:41 <luqui> the index must be known at compile time
10:57:51 <Peaker> if you need an n'th, maybe you really need a record, and not a tuple?
10:58:37 <Peaker> I have a friend who thinks positional tuples are evil, and only records should be allowed
10:58:54 <Philippa_> big positional tuples are evil, admittedly
10:59:05 <Philippa_> and even small ones really shouldn't be allowed to propagate too far
10:59:29 <Deewiant> on occasion a function needs to return more than one result: what should the return type of splitAt, for instance, be without tuples?
11:00:05 <mrd> { firstPart :: String, secondPart :: String } :)
11:00:15 <Deewiant> data SplitAtResultType? :-P
11:00:24 <olsner> tuples are mainly useful since they are isomorphic to the record type you can't be bothered defining for the one-off use
11:01:16 <saml> i think currying is faulty. (+) ::  (Int, Int) -> Int
11:01:41 <mrd> nooo
11:01:42 <saml> it's difficult to imagine internal diagram of Int -> Int -> Int
11:01:48 <Deewiant> nooo
11:01:49 <mrd> it is?
11:01:52 <olsner> nooo
11:02:02 <saml> 1 -> (1 +)   ->  ??
11:02:02 <olsner> :)
11:02:04 <Deewiant> > cycle "nooo "
11:02:05 <lambdabot>   "nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo nooo...
11:02:13 <mrd> 1+1 -> (1+)1 -> 2
11:02:18 <saml> (1,1) -> 2           -- internal diagram
11:02:23 <Peaker> { before :: String, after :: String } may be more informative in the case of splitAt
11:02:27 <mgsloan> anonymous smmation types would be fun
11:02:31 <olsner> > 'n':fix('o':)
11:02:33 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
11:02:33 <saml> i'm talking about those funciton diagrams where there is one arrow from domain to codomain
11:02:35 <Peaker> or: { before, after :: String }
11:02:48 <mrd> saml: (+) is a higher order function
11:03:17 <saml> i didn't learn that yet
11:03:28 <mrd> it returns a function
11:03:30 <saml> !go internal diagram of higher order functions
11:03:39 <mrd> I've never heard of "internal diagram"
11:03:58 <dolio> (+) is technically not higher order, is it?
11:04:05 <dolio> Or, not higher than 1.
11:04:20 <mrd> well it doesn't take a function as parameter, but it does return one
11:04:25 <olsner> you could make it higher order by making your numbers more esoteric, I guess
11:05:13 <dolio> Since I think the definition is usually 'order(a -> b) = max(1 + order a, order b)'
11:05:47 <dolio> (And order(a) = 0 for other things).
11:05:48 <mrd> dolio: base case?
11:05:51 <mrd> hehe
11:05:59 <saml> i mean, how would you plot (+) in x-y plane?
11:06:05 <saml> i can plot (1+)
11:06:15 <saml> (+) is so unintuitive
11:06:24 <mrd> > 1 + 1
11:06:26 <lambdabot>   2
11:06:29 <mrd> easy enough to me!
11:06:32 <saml> unless i make x-axix (Int, Int)
11:06:37 <int-e> > (+) 1 1
11:06:38 <lambdabot>   2
11:06:43 <dolio> You'd use 3 dimensions.
11:06:56 <int-e> saml: so think of it as (+) 0, (+) 1, etc. separately.
11:07:25 <saml> so, probably (+) is a template (in C++ sense)
11:07:29 <mrd> no
11:07:41 <mrd> it's a function.  period
11:07:50 <saml> i can't understand (+). my life is complete
11:08:00 <mrd> whatever floats your boat
11:08:26 <int-e> @type (+)
11:08:27 <lambdabot> forall a. (Num a) => a -> a -> a
11:09:00 <Peaker> which wx-dev should I have installed for wxcore to compile successfully?
11:11:42 <dolio> a -> a -> a might even lead you to notice that for any N, (+) N is a function whose graph is given by taking a slice out of the 3-dimensional graph, where x=N.
11:16:34 <saml> http://img440.imageshack.us/img440/2786/functionmr8.jpg  this is my question
11:17:01 <saml> oh darn. it's Int -> (Int -> Int)
11:17:14 <saml> let me update the picture.
11:17:33 <Peaker> saml: its the same, its right-associative
11:18:29 <lilac> saml: each of the things in the middle oval in the diagram on the right corresponds to a diagram like the one on the left
11:20:48 <roconnor> Miranda IM is probably not what I think it is.
11:20:59 <Valodim> huh?
11:21:15 <lament> roconnor: pervert
11:21:25 <roconnor> I think it is an instant messaging client written in Miranda
11:21:32 <Valodim> haha
11:22:13 <olsner> quite wrong indeed :)
11:23:10 <Valodim> not related to the language at all
11:23:13 <saml> http://img293.imageshack.us/img293/2169/function1bg5.jpg   now I understand (+)
11:23:32 <saml> lilac: exactly
11:23:51 <roconnor> saml:  it is the shape of a tree with infinite branching
11:24:05 <roconnor> but depth 2
11:25:02 <lament> Haskell, where it takes you _years_ to understand (+)
11:25:36 <Valodim> yeah but it _has_ (+)
11:26:08 <camio> Why years to understand (+)?
11:26:28 <camio> I'm questioning my understanding ATM.
11:27:25 <C-Keen> how should one use Data.Map.update? I don't understand how (a->Maybe a) should be used
11:27:41 <dolio> It's not really that hard.
11:27:44 <saml> currying is smart
11:27:57 <dolio> @type Data.Map.Update
11:27:58 <lambdabot> Not in scope: data constructor `Data.Map.Update'
11:27:59 <lament> camio: i'm joking, but (+) certainly has more depth to it than, say, + in C
11:28:00 <saml> i'd have settled with (+) :: (Int, Int) -> Int
11:28:01 <dolio> @type Data.Map.update
11:28:02 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
11:28:12 <camio> lament: indeed :)
11:28:20 <lament> of course + in C++ has, in a way, more depth
11:28:28 <lament> there it does take years to understand it
11:28:33 <dolio> C-Keen: I think the (a -> Maybe a) tells it what to replace the value with.
11:28:48 <lilac> saml: (Int, Int) -> Int is easy, it's ((a,b) -> c) -> a -> b -> c that's hard. ;-)
11:28:49 <dolio> If you return Just v, it replaces it with v, and if you return Nothing, it probably deletes it.
11:28:50 <Baughn> C-Keen: Given that one value of Maybe a is Nothing, I'd think it's intuitive
11:28:58 <camio> O(log n). The expression (update f k map) updates the value x  at k (if it is in the map). If (f x) is Nothing, the element is deleted. If it is (Just y), the key k is bound to the new value y.
11:29:04 <b_jonas> djinn?
11:29:29 <rwbarton> C-Keen: there are a lot of variants on update, if you don't need to be able to delete things with the same function
11:29:31 <saml> lilac: give me that function!
11:29:47 <dolio> > Data.Map.update (const Nothing) "a" $ Data.Map.fromList [("a", "b")]
11:29:48 <saml> @hoogle ((a,b) -> c) -> a -> b -> c
11:29:48 <lambdabot>   /tmp/815806664463998572:68:32: Not in scope: `Data.Map.update'/tmp/81580666...
11:29:48 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
11:29:48 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
11:29:53 <lilac> @src curry
11:29:53 <lambdabot> curry f x y = f (x, y)
11:29:55 <saml> haha i suspected
11:29:57 <dolio> , Data.Map.update (const Nothing) "a" $ Data.Map.fromList [("a", "b")]
11:29:59 <lunabot>  luna: Not in scope: `Data.Map.update'
11:30:05 <dolio> Hmm...
11:30:29 <lilac> saml: drawing a diagram of that would not be straightforward ;)
11:30:42 <dolio> Yes, Nothing removes the value.
11:30:57 <C-Keen> dolio: it evaluates to fromList [] here
11:30:57 <b_jonas> > M.update
11:30:59 <lambdabot>       Overlapping instances for Show
11:30:59 <lambdabot>                                  ((a -> ...
11:31:05 <saml> function diagram is always straighforward... oh no recursion
11:31:09 <rwbarton> @type Data.Map.insert
11:31:11 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
11:31:13 <saml> no it's not recursion
11:31:13 <dolio> C-Keen: Yeah.
11:31:24 <rwbarton> @type Data.Map.adjust
11:31:25 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
11:31:28 <saml> a function is two ellipses and arrows
11:31:40 <Baughn> Peaker: Did you get happy installed?
11:31:55 <Peaker> Baughn: yeah
11:32:07 <Peaker> Baughn: I used apt-get to bootstrap it
11:32:38 <Baughn> Peaker: I bootstrapped it on another system, then copied the .hs files it built over
11:32:47 <Baughn> Makes you wonder, though. Why they don't supply those.
11:33:15 <Peaker> Baughn: I released a package that accidentally depended on an installed instance of itself. Its not too hard to make that mistake :)
11:33:50 <Baughn> Yea, but it's a hard one not to get bug reports for. ;)
11:33:53 <Baughn> Which reminds me..
11:33:57 <C-Keen> thanks all, adjust fits my needs better
11:34:14 <Baughn> Peaker: Oh. It's a microsoft product.
11:38:19 <Deewiant> I just defined union, difference, and intersection for tries in four lines... Haskell scares me sometimes
11:38:45 <b_jonas> Deewiant: how wide is your terminal?
11:39:00 <Deewiant> b_jonas: 80-char lines, of course
11:39:07 <tromp_> my latest attempt at formalizing Go in Haskell: http://www.cwi.nl/~tromp/go/Go.hs
11:40:28 <Baughn> tromp_: Suicides are illegal, aren't they?
11:40:41 <tromp_> not in some rules
11:40:44 <Peaker> if you try to suicide, you get the death penalty
11:40:52 <vixey> tromp_: I can't really read that
11:41:20 <tromp_> can you elaborate?
11:41:29 <b_jonas> Deewiant: can you paste it?
11:41:44 <Deewiant> b_jonas: the whole thing?
11:41:48 <Deewiant> or the four lines? :-P
11:42:13 <Peaker> tromp_: why coord enum instead of an integer?
11:42:14 <Deewiant> which doesn't include type signatures and one 'where'
11:42:47 <b_jonas> Deewiant: the four lines with enough context to understand it
11:42:50 <tromp_> for safety and to allow xcoord and ycoords to show differently
11:43:13 <vixey> tromp_: I think it [the code] is too dense - so it's difficult to read it
11:43:49 <C-Keen> hm, when I have a sublist which is true with isInfixOf how can I delete that sublist from my original list?
11:44:08 <Peaker> tromp_: why not just wrap an int with a newtype, then?
11:44:12 <C-Keen> (\\) ?
11:44:22 <Peaker> tromp_: a go board is no 3 by 3, right?
11:44:23 <tromp_> i had that in an earlier iteration
11:44:53 <tromp_> but then you can still get errors by creating off board coords
11:45:15 <tromp_> -- (only 3x3 above for purposes of clarity)
11:45:39 <tromp_> 19x19 would make it harder to show a whole game
11:45:53 <tromp_> would be too much output:(
11:45:56 <Baughn> http://hpaste.org/11330 <-- Is this use of Enum a bad idea?
11:46:10 <lament> anyone wants to play 3x3 go? I take black.
11:46:17 <tromp_> also, now QuickChecvk can generate random Points
11:46:21 <b_jonas> tromp: you can write fromEnum instead of deriving
11:46:53 <tromp_> deriving is easier than defining a class instance
11:47:02 <vixey> Baughn: I don't _like_ it, but I can't think of any real reasons why it's a bad thing
11:47:15 <Deewiant> b_jonas: http://hpaste.org/11331
11:47:28 <Peaker> wow, just applying 20000 ghc patches is taking ages
11:47:37 <Baughn> Peaker: What's your darcs version?
11:47:39 <vixey> you are not using --partial
11:47:47 <Baughn> Or he's not using --hashed
11:47:50 <tromp_> or do you mean to avoid the offset by +/-1 ?
11:47:52 <Peaker> Baughn: 1.0.9 (release)
11:48:12 <Baughn> tromp_: Well, avoiding the offset would be nice, but that's basically the only place that uses it
11:48:13 <Peaker> vixey: right, because with --partial I was told I am limited in what I can do later
11:48:24 <b_jonas> Baughn: does it even compile?
11:48:28 <Peaker> vixey: can't even pull new revisions properly with --partial, I was told
11:48:33 <Baughn> b_jonas: Hm? Yea, of course
11:48:34 <b_jonas> Baughn: I thought it couldn't derive Enum for that
11:48:41 <b_jonas> oh, sorry
11:48:50 <b_jonas> you derive Enum for MessageType, not for Option
11:48:51 <b_jonas> sorry
11:48:56 <Baughn> It compiles, runs and answers dhcp requests. :P
11:49:14 <b_jonas> Deewiant: thanks.
11:49:20 <Peaker> who's writing a dhcp server?
11:49:30 <tromp_> Baughn: but then i'd have to introduce offset in [['A'..]!!(fromEnum x)]
11:49:31 <b_jonas> Deewiant: so it's four lines each, not union, difference, and intersection in four lines total
11:49:35 <mc__> Is it possible to direct the output of function to somewhere else?
11:49:47 <Baughn> Peaker: I am
11:49:48 <b_jonas> mc__: elaborate?
11:49:49 <Deewiant> b_jonas: without the type signatures and the 'where' it's four lines in total.
11:49:59 <Peaker> Baughn: cool, for what purpose?
11:50:09 <Baughn> Peaker: More of a distinctly lovecraftian dhcp relay. Right, the one-line overview..
11:50:19 <Deewiant> b_jonas: or darn, five. I forgot that intersection was broken over two lines (damn long function names)
11:50:28 <Peaker> lovercraftian?
11:50:38 <b_jonas> heh
11:50:58 <Baughn> Peaker: I get multiple IPs from my ISP, but they're not on the same subnet. I'm writing a relay to grab all four, hold on to them, and send them on to specific clients (plus some private IPs) with classless static routes set so they can also talk to each other
11:50:59 <C-Keen> did someone say C'thulhu?
11:51:09 <Baughn> C-Keen: You're pronouncing it wrong
11:51:31 <C-Keen> Baughn: intentionally, unspeakable horrors are well...unspeakabale right?
11:51:36 <Baughn> tromp_: Why would I write such a line?
11:51:52 <Peaker> Baughn: Why not just use an ARP hack and an IP alias for them to talk to each other?
11:52:01 <Peaker> Baughn: (arp table edit)
11:52:23 <Baughn> Peaker: This way seems cleaner. Classless static routes exist for precisely this purpose.
11:52:34 <Baughn> Peaker: It's a pity apple doesn't support them, but oh well.
11:52:37 <mc__> b_jonas: nevermind. After thinking about it I came to the conclusion that this is probably not a good idea in haskell anyways.
11:55:10 * Baughn rebuilds ghc for no particular reason
11:59:19 <tromp_> baughn: i have such a line to show x coordinates in the standard way (as letters)
12:00:59 <Baughn> tromp_: Er, right.. I think we're talking about different things
12:03:16 <tromp_> seems so:(
12:05:18 <eu-prleu-peupeu> hello friends and foes of haskell
12:06:33 <Baughn> No foes here
12:07:30 <jauaor> hi there
12:08:41 <b_jonas> Baughn: how do you know?
12:13:10 <Baughn> b_jonas: I ate them all
12:13:26 <Deewiant> you glutton!
12:13:58 <Baughn> Barely even an appetizer.
12:14:38 <b_jonas> scary
12:14:59 <Deewiant> we must be careful to not let Baughn into #ocaml
12:15:06 <b_jonas> eated
12:15:30 <musiKk> don't ocaml users like haskell?
12:15:42 <Baughn> Deewiant: Don't worry. My mouth uses foldr, so it tends to overflow in strict languages.
12:16:17 <b_jonas> lol
12:17:17 <b_jonas> we should add this conversation to @quote
12:18:39 <Baughn> @quote isn't that much of a glutton
12:18:40 <lambdabot> No quotes for this person. There are some things that I just don't know.
12:19:01 <eu-prleu-peupeu> im having problems installing sdl, is there any howto ?
12:19:57 <eu-prleu-peupeu> on windows :P
12:20:45 * chrisdone HAET the diamond dependency problem
12:26:14 <rog> if i get an undefined exception in GHC, is there a way to tell where it came from?
12:26:27 <b_jonas> I'm reading the parsec user's guide right now
12:26:32 <b_jonas> it looks nice
12:26:43 <Baughn> rog: Yes - compile with profiling support, then use +RTS -xc
12:26:59 <rog> Baughn: is it possible from ghci?\
12:27:15 <chrisdone> heh, I can't build my blog :-P http://rafb.net/p/wnT0E975.html
12:27:16 <lambdabot> Title: Nopaste - Ha ha! I am building the blog
12:27:28 <Baughn> rog: In GHCi you should be using the debugger/stepper. Read the manual. ;)
12:27:49 <rog> hmm.
12:28:34 <b_jonas> and there's also just adding printfs (Debug.Trace)
12:29:03 <Baughn> And there's making your functions total, and using descriptive errors instead of undefined
12:29:36 <Baughn> rog: Oh, and IIRC, GHCi *does* give source location for exceptions in 6.10, so you could upgrade
12:29:45 <rog> i used undefined 'cos the book i read that the compiler would probably annotate the error with location info
12:29:50 <Baughn> Well, 6.10 is still in beta, though
12:30:00 <Baughn> It does in 6.10
12:30:14 <chrisdone> I only use undefined for when I'm writing a function but I want to compile what I have so far
12:30:21 <rog> ... but i'll use error instead, then.
12:30:53 <rog> i used it for a field in a record that i want to ensure is always initialised.
12:31:02 <Baughn> rog: Well, ghci does, anyway
12:31:12 <b_jonas> I find it a bit strange though that it's called a parser _combinator_ library.
12:31:28 <chrisdone> rog: for that I use: error "no value for X provided"
12:31:38 <rog> Baughn: the initialisation is done with a stack of (dynamically created) lenses.
12:31:47 <rog> chrisdone: i think i'll do that.
12:33:21 <rog> Baughn: i have read the manual previously, but wasn't greatly enlightened as to how i'd use it to get a source-code location for an exception. trace + history doesn't do anything. would i need to set a breakpoint on undefined?
12:37:29 <b_jonas> oh, I see, "combinator" in this context wants to emphasize that the parsers are bulit in haskell, not in a sublanguage
12:37:32 <b_jonas> I see
12:37:37 <b_jonas> should have thought of that
12:41:27 <pao_> does iteratee in english sounds like "who is being iterated upon"?
12:45:38 <BMeph> pao_: Yes. :)
12:45:52 <pao_> BMeph: thanks :-)
12:46:27 <sebaseba> ?users
12:46:28 <lambdabot> Maximum users seen in #haskell: 539, currently: 532 (98.7%), active: 12 (2.3%)
12:46:35 <stulli> what does it mean when someone says "Haskells type system is undecidable"?
12:47:12 <Deewiant> it means they're not talking about Haskell 98
12:47:19 <Baughn> stulli: It's theoretically possible to write programs in it that can't be typechecked
12:47:24 <Baughn> Not in '98, though
12:47:26 <vixey> ??
12:47:30 <vixey> can't be typechecked
12:47:42 <Baughn> vixey: As in, it would lock the typechecker in a loop
12:48:04 <olsner> i.e. could be typechecked given infinite time and space :)
12:48:05 <vixey> stulli: Haskell type system is definitely decideable
12:48:22 <Peaker> cabal install wxcore fails because it tries to access stuff globally (rather than user stuff).  sudo cabal install wxcore succeeds, but then it tries to re-install it as soon as something depends on it
12:48:29 <stulli> hm, now im confused :)
12:48:47 <dolio> H98 is exponential worst case, I think.
12:48:54 <rwbarton> http://arcanux.org/lambdacats/undecidable.jpg
12:48:58 <olsner> there are unsafe extensions that allow you to write programs with undecidable types, but plain haskell is decidable
12:49:01 <dcoutts> Peaker: wxcore uses it's own build system and doesn't respect all the options sadly
12:49:04 <dolio> Aside from ambiguity like 'show . read'.
12:49:26 <vixey> :tlet f = (,); g = f.f; h = g.g in h
12:49:27 <vixey> :t let f = (,); g = f.f; h = g.g in h
12:49:29 <lambdabot> forall a b b1 b2 b3. a -> b -> (b1 -> (b2 -> (b3 -> (a, b3), b2), b1), b)
12:49:29 <Peaker> how can i convince cabal that a certain installation of wxcore is A.OK and it shouldn't try to overwrite it?
12:49:33 <dolio> But then, 'show . read' results in an error, so it's not undecidable.
12:49:40 <vixey> :t let f = (,); g x = f (f x); h x = g (g x) in h
12:49:42 <lambdabot> forall a b b1 b2 b3. a -> b -> (b1 -> (b2 -> (b3 -> (a, b3), b2), b1), b)
12:49:53 <vixey> :t let f = (,); g x = (f x,f x); h x = (g x,g x) in h
12:49:54 <lambdabot> forall a b b1 b2 b3. a -> ((b -> (a, b), b1 -> (a, b1)), (b2 -> (a, b2), b3 -> (a, b3)))
12:50:08 <vixey> How do you do it
12:50:25 <vixey> :t let f = (); g x = (f,f); h x = (g,g) in h
12:50:26 <lambdabot> forall t t1 t2. t -> (t1 -> ((), ()), t2 -> ((), ()))
12:50:28 <dolio> :t let f x = (x,x) ; g x = (f x, f x) ; h x = (g x, g x) in h
12:50:30 <lambdabot> forall t. t -> (((t, t), (t, t)), ((t, t), (t, t)))
12:50:33 <vixey> aha
12:51:30 <rwbarton> I tried typechecking the value of  unwords (replicate 125 "fmap")  in ghci once, and it consumed all my memory
12:51:37 <Peaker> when does cabal decide to reinstall something? How do I know why it wants to?
12:51:50 <Deewiant> :t unwords (replicate 125 "fmap")
12:51:51 <lambdabot> String
12:51:58 <b_jonas> Deewiant: the value
12:51:59 <dcoutts> Peaker: use --dry-run -v, it'll tell you the details
12:52:01 <b_jonas> as in
12:52:03 <Deewiant> ah
12:52:04 <b_jonas> > unwords (replicate 125 "fmap")
12:52:06 <lambdabot>   "fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap...
12:52:11 <b_jonas> @type fmap fmap fmap fmap fmap fmap
12:52:12 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
12:52:25 <Deewiant> hmm
12:52:31 <Deewiant> I can't even fit that much into GHCi
12:52:42 <sjanssen> @remember rwbarton I tried typechecking the value of  unwords (replicate 125 "fmap")  in ghci once, and it consumed all my memory
12:52:42 <lambdabot> Okay.
12:52:42 <Deewiant> > 254 / 5
12:52:44 <lambdabot>   50.8
12:52:46 <Peaker> "selecting wx-0.10.5 (hackage) and discarding wx-0.10.1, 0.10.2, 0.10.3, 0.10.4, wxcore-0.10.1, 0.10.2 and 0.10.3"
12:52:51 <sjanssen> byorgey: HWN material ^^^
12:52:53 <Peaker> why does cabal discard my installed packages?
12:52:58 <vixey> :t ($)($)($)
12:53:00 <lambdabot> forall a b. (a -> b) -> a -> b
12:53:02 <vixey> :t ($)($)($)($)($)($)($)($)($)($)($)($)($)($)
12:53:03 <lambdabot> forall a b. (a -> b) -> a -> b
12:53:18 <vixey> :t ($)(,)($)(,)($)(,)
12:53:19 <lambdabot>     Couldn't match expected type `((a -> b) -> a -> b)
12:53:19 <lambdabot>                                   -> (a1 -> b1 -> (a1, b1))
12:53:19 <lambdabot>                                   -> t'
12:53:19 <rwbarton> ($) = id
12:53:28 <vixey> :t ($)(.)($)(.)($)(.)
12:53:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:53:33 <b_jonas> @type let { f x = (x, x) } in f.f.f.f.f.f.f.f.f.f.f.f.f.f.f
12:53:35 <dcoutts> Peaker: because you're asking for the latest version of wx
12:53:43 <lambdabot> forall a. a -> (((((((((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a,
12:53:43 <lambdabot> a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a,
12:53:43 <lambdabot> a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a,
12:53:43 <lambdabot> a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a,
12:53:46 <lambdabot>  a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a),
12:53:49 <lambdabot> [820 @more lines]
12:53:51 <b_jonas> that's why it's exponential
12:53:55 <b_jonas> @type let { f x = (x, x) } in f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f
12:53:59 <vixey> I think that is square
12:54:02 <lambdabot> forall a.*** Exception: stack overflow
12:54:06 <b_jonas> is it?
12:54:09 <dolio> Heh.
12:54:10 <Peaker> dcoutts: it wants wxcore-0.10.5 which I have, but then it decides to reinstall it?
12:54:11 <vixey> :t let { f x = (x, x) } in f
12:54:12 <lambdabot> forall t. t -> (t, t)
12:54:13 <vixey> :t let { f x = (x, x) } in f.f
12:54:14 <dcoutts> Peaker: btw, you didn't tell me which versions were installed. Also that wasn't the output I meant. The summary of what it'll install at the end gives the reason for reinstalls.
12:54:14 <lambdabot> forall a. a -> ((a, a), (a, a))
12:54:15 <vixey> :t let { f x = (x, x) } in f.f.f
12:54:17 <lambdabot> forall a. a -> (((a, a), (a, a)), ((a, a), (a, a)))
12:54:22 <vixey> it looks O(n^)2
12:54:47 <b_jonas> @type let { f x = (x, x) } in f.f.f.f
12:54:48 <lambdabot> forall a. a -> ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))
12:55:00 <b_jonas> see, one more f and twice as much output
12:55:01 <Peaker> dcoutts: http://hpaste.org/11332
12:55:03 <b_jonas> it's exponential
12:55:06 <b_jonas> 2^n I think
12:55:50 <Peaker> dcoutts: http://hpaste.org/11333 is my pkg listing
12:55:51 <vixey> 4 8 16 ..
12:55:52 <vixey> isn't that n^2
12:56:04 <vixey> > map (^2) [1..]
12:56:05 <b_jonas> uh,
12:56:05 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
12:56:08 <vixey> > map (2^) [1..]
12:56:09 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
12:56:12 <vixey> oh ok
12:57:10 <dcoutts> Peaker: ok, so as you can see it's building wxcore against quite different dependencies. Though it's a little odd that it built before without those deps.
12:57:31 <dcoutts> Peaker: it could re-use the installed one if the deps were the same, but they're not
12:57:41 <Peaker> dcoutts: I see, its because I built it system-wide before
12:57:51 <Peaker> dcoutts: because it has a bug in the package that it can only be built system-wide
12:57:58 <brett_h> I don't understand the difference between pattern matching and having a bunch of if / else-ifs be the base of your function ... can anyone explain what pattern matching buys you vs that, if anything?
12:58:00 <Peaker> dcoutts: And my user-only deps weren't available, probably
12:58:27 <Peaker> dcoutts: maybe I'll rebuild all of wxcore's dependencies system-wide too
12:59:17 <dcoutts> Peaker: it's still odd though. What are the deps of the installed wxcore? ghc-pkg field wxcore depends
12:59:23 <Peaker> dcoutts: oh wait, these dependencies are system-wide already, not user-specific
12:59:33 <dcoutts> Peaker: erm ghc-pkg field wxcore-0.10.5 depends
12:59:43 <Peaker> dcoutts: depends: base-4.0.0.0 containers-0.2.0.0 haskell98-1.0.1.0 stm-2.1.1.1
12:59:53 <insane> i get the following error while compiling wxhaskell
12:59:55 <insane> error: cast from wxInputStream* to int loses precision
13:00:08 <Peaker> same result with the -0.10.5 suffix
13:00:39 <dcoutts> Peaker: so you see that is a bit weird because those are quite different deps from what cabal-install is picking
13:00:41 <insane> is it possible to repair this?
13:01:19 <Peaker> insane: possibly the library headers are of an incompatible version? It failed to build with 2.6 here, but succeeded with 2.8
13:01:36 <Peaker> dcoutts: what can be done, given that wxcore refuses to install --user ?
13:01:41 <dcoutts> Peaker: the wxcore.cabal file says it depends on parsec, yet your installed version does not depend on parsec.
13:02:01 <insane> Peaker: you mean the wxWidgets
13:02:05 <insane> ?
13:02:29 <dcoutts> Peaker: the solution is to bug the wx devs. The quick hack is to modify your local hackage index file and remove wxcore from it so that cabal-install is forced to pick the installed version.
13:02:41 <Peaker> insane: I mean wxcore, if that's a subbuild of wxhaskell. Otherwise, I am not sure
13:02:52 <Peaker> dcoutts: thanks
13:03:33 <Peaker> dcoutts: both a .tar and .tar.gz exist, which is the authoritive one?
13:04:02 <dcoutts> Peaker: the one that is used is the unpacked one
13:04:20 <dcoutts> Peaker: it downloads the compressed one and uncompresses it, then uses the .tar version thereafter
13:04:31 <Peaker> dcoutts: aha. Thanks! The hack works ;)
13:05:35 <eu-prleu-peupeu> hi
13:05:45 <eu-prleu-peupeu> in runhaskell how do i specify another include directory ?
13:05:54 <eu-prleu-peupeu> i want it to search in c:\mingw\include and also on the c:\msys\1.0\local\include
13:06:05 <dcoutts> Peaker: I've filed a ticket http://hackage.haskell.org/trac/hackage/ticket/376
13:06:06 <lambdabot> Title: #376 (Allow constraint on using installed package versions) - Hackage - Trac
13:06:11 <dcoutts> Peaker: feel free to add your comments there
13:08:31 <Peaker> dcoutts: I'd put a vote on it, but I'm not sure I have something to add...
13:09:50 <dcoutts> Peaker: give the example situation where this would have been beneficial, and the workaround you had to use instead.
13:12:52 <Peaker> Ok, added that
13:13:09 <eu-prleu-peupeu> can anyone help me plz ?
13:13:56 <dcoutts> Peaker: thanks
13:32:48 <b_jonas> where's the ask to ask staff?
13:32:57 <b_jonas> eu-prleu-peupeu: don't ask to ask, just ask
13:33:50 <theunixgeek> I'm trying to solve Project Euler's problem 7, to find the 10,001st prime.
13:34:02 <eu-prleu-peupeu> in runhaskell how do i specify another include directory ?
13:34:20 <eu-prleu-peupeu> i keep on getting: Graphics\UI\SDL\General.hsc:1:17:  SDL.h: No such file or directory
13:34:37 <theunixgeek> First, can I embed an if statement in a list comprehension?
13:34:53 <b_jonas> theunixgeek: yes
13:35:09 <int-e> > [x | x <- [1..10], x > 5]
13:35:10 <lambdabot>   [6,7,8,9,10]
13:35:24 <b_jonas> > [if x < 0 then -x else x | x <- [1..10]]
13:35:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:35:31 <b_jonas> > [if x < 5 then -x else x | x <- [1..10]]
13:35:33 <lambdabot>   [-1,-2,-3,-4,5,6,7,8,9,10]
13:36:04 <jensen_> eu-prleu-peupeu: -i ? (i'm not sure)
13:36:06 <theunixgeek> thanks, b_jonas
13:36:06 <theunixgeek> Secondly, why can't I embed an [1..] in a list comprehension?
13:36:06 <theunixgeek> like this: [p | p <- [4 .. 20], p `mod` [1..] /= 0]
13:36:06 <theunixgeek> b_jonas: sorry, I meant an if statement in the predicate of a list comprehension
13:36:14 <int-e> theunixgeek: did my example help?
13:37:08 <theunixgeek> int-e: not really :P
13:37:08 <theunixgeek> I'm planning on doing some sort of (pseudocode) if p length is blah blah then...
13:37:25 <tromp_> n `mod` 1 is definately 0!
13:37:47 <int-e> @type any
13:37:47 <badtruffle> theunixgeek: have you seen the simple prime expression that everyone throws around?
13:37:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:37:59 <int-e> @type all
13:38:00 <badtruffle> it's not a real sieve of eratosthenes but it works for small primes
13:38:00 <theunixgeek> badtruffle: no
13:38:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:38:11 <badtruffle> > take 10 primes
13:38:12 <lambdabot>   Not in scope: `primes'
13:38:14 <badtruffle> boo
13:38:22 <int-e> theunixgeek: then, not really. you can cheat to some extent, of course
13:38:48 <badtruffle> you could try this
13:38:59 <int-e> > [x | x <- [1..10], [] <- [y | y <- [1..x], x `mod` 3 == 0]]
13:39:01 <badtruffle> ah shit
13:39:05 <lambdabot>       No instance for (Integral [t])
13:39:07 <lambdabot>        arising from a use of `mod' at <i...
13:39:08 <int-e> oops
13:39:09 <badtruffle> how do I tell lambdabot to stop?
13:39:14 <badtruffle> it's giving me an infinite list!
13:39:21 <newsham> ?src (Floating CReal) pi
13:39:21 <lambdabot> Source not found. Take a stress pill and think things over.
13:39:25 <badtruffle> (in pm)
13:39:33 <badtruffle> > take 10 (nubBy(((>1) .) . gcd) [2..])
13:39:35 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
13:39:54 <int-e> > [x | x <- [1..10], [] <- [[y | y <- [1..x], y `mod` 3 == 0]]] -- very silly though
13:39:55 <lambdabot>   [1,2]
13:40:48 <b_jonas> badtruffle: ouch, that's scary
13:40:49 <badtruffle> > take 20 (nubBy (((==0) .) . (flip mod)) [2..])
13:40:50 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
13:40:51 <badtruffle> lol
13:40:55 <Heffalump> badtruffle: has it stopped yet?
13:41:13 <badtruffle> yeah, it gave up after 6 messages
13:41:21 <b_jonas> badtruffle: it's almost as scary as that perl6 one using junctions
13:41:25 <b_jonas> how was that...
13:41:38 <theunixgeek> int-e: true..
13:41:38 <theunixgeek> int-e: how'd you learn Haskell?
13:41:38 <theunixgeek> > [ (a,b,c) | c <- [1..500], b <- [1..c], a <- [1..b], a + b + c == 1000, a^2 + b^2 == c^2]
13:41:53 <lambdabot>   thread killed
13:41:55 <int-e> b_jonas: you mean the (..+)\1+ one?
13:41:55 <badtruffle> lol
13:42:05 <theunixgeek> lol
13:42:07 <badtruffle> theunixgeek: get it to prove fermant's last theorem for you
13:42:10 <badtruffle> -n
13:42:15 <int-e> b_jonas: wait you said perl6, hmm.
13:42:30 <badtruffle> b_jonas: don't blame me, I just searched on google! :P
13:42:39 <theunixgeek> ok
13:42:41 <theunixgeek> :P
13:42:41 <theunixgeek> goodbye, all, I have to go now
13:43:23 <b_jonas> and then there's a perl5 one using regexen
13:43:25 <b_jonas> that's scary too
13:43:26 <int-e> b_jonas: perl -le'1while(1x++$_)=~/^(11+)\1+$|^1$/||print' ;-)
13:43:28 <b_jonas> I'll search
13:43:35 <b_jonas> yeah, likely
13:43:46 <badtruffle> ugh
13:43:47 <int-e> or some variation of that
13:43:49 <badtruffle> yeah :P
13:44:17 <int-e> just trying to parse  1x++$_  is awful :)
13:44:31 <b_jonas> here's the perl6 one: http://www.perlmonks.com/?node_id=510912
13:44:37 <lambdabot> Title: Re: Simple primality testing
13:46:46 <b_jonas> also, if perl6 had a _very_ magical ... that tried to continue sequences so (2,3,5,7,11,...) just worked, that would be even more scary
13:47:04 <badtruffle> lol
13:47:21 <badtruffle> isn't there some large equation with 26 variables whose positive roots are all the primes?
13:47:23 <int-e> > oeis [2,3,5]
13:47:24 <lambdabot>   Not in scope: `oeis'
13:47:36 <encryptio> badtruffle: yes
13:47:48 <b_jonas> try /msg buubot oeis: 2,3,5
13:47:49 <badtruffle> aha yeah found it
13:47:56 <encryptio> well, the roots are primes, but you can't have *all the primes*
13:48:15 <b_jonas> > describe [2,3,5]
13:48:16 <lambdabot>   Not in scope: `describe'
13:48:20 <b_jonas> > description [2,3,5]
13:48:22 <lambdabot>   Couldn't match expected type `OEISSequence'
13:48:46 <badtruffle> encryptio:  from the wikipedia article "Jones et al. (1976) proved that a given number k + 2 is prime if and only if the following system of 14 Diophantine equations has a solution in the natural numbers"
13:49:04 <b_jonas> badtruffle: yes, though I'm not sure it's 26
13:49:16 <badtruffle> "A set of Diophantine equations in 26 variables can be used to obtain primes. Jones et al. (1976) proved that a given number k + 2 is prime if and only if the following system of 14 Diophantine equations has a solution in the natural numbers:"
13:49:24 <encryptio> "has a solution in the natural numbers" ... great.
13:49:31 <badtruffle> that justifies the english alphabet choice!
13:49:31 <lament> 26 variables, 26 letters of the alphabet, it's a conspiracy
13:49:34 <badtruffle> yup
13:49:38 <b_jonas> it's related to the negative solution of that problem
13:49:47 <badtruffle> I always knew there was a reason we had 26 letters
13:49:49 <b_jonas> whatever it's called
13:50:01 <b_jonas> badtruffle: no, the 26 letters is because of the vitamins
13:50:06 <badtruffle> oh I see
13:50:12 <badtruffle> but the vitamins are because of the primes
13:50:16 <badtruffle> since everything reduces to math
13:50:28 <b_jonas> badtruffle: the known vitamins at least, there are a few missing letters we have to discover and then we'll live forever
13:50:35 <b_jonas> might be, yeah
13:50:53 <lament> i discovered a new letter between P and R
13:51:03 <lament> it looks like an O with a little tail
13:52:00 <int-e> lament: between P and R you say? I have  O, I, U, Y, and T ;-)
13:52:21 <b_jonas> lament: http://people.cs.uchicago.edu/~dinoj/msglef.html
13:52:36 <lament> int-e: how unusual, i have Y, F, G, and C :)
13:53:02 <osfameron> dvorak using hippy!
13:53:03 <b_jonas> I have Q
13:53:16 <int-e> osfameron: there's one in every crowd. :)
13:53:25 <b_jonas> oh wait, you said "O with a little tail"
13:53:30 <b_jonas> so you referred to Q
13:53:37 <b_jonas> I thought you said P with a little tail
13:53:43 <lament> hehe
13:53:44 <b_jonas> half as large a tail as R has that is
13:54:37 <b_jonas> my fav part of that thing I linked to is "sitting about 2/3 of the way between the integers 5 and 6"
13:57:27 <lispy> dvorak++
13:59:49 <vixey> daoeuvorab
13:59:53 <vixey> :D
13:59:57 <ziman> i'm trying to parallelize a very simple program but it still makes use of a single thread only ( -threaded & -N2, http://hpaste.org/11335 ). Could anybody point me in the right direction?
14:00:15 <b_jonas> hmm
14:00:49 <quicksilver> ziman: don't you want a `par` b `seq` (a,b) ?
14:01:04 <b_jonas> so parsec has a builtin state, but not an IO or anything more... I guess this means you can't execute io actions during the parsing or exit early or anything like that
14:01:28 <quicksilver> b_jonas: not unless you install... *drumroll* parsec 3
14:01:38 <quicksilver> b_jonas: which has ParsecT
14:01:42 <quicksilver> so you can do ParsecT IO
14:01:52 <quicksilver> mind you, I should say that the idea of doing IO during parsing is fairly heinous.
14:01:56 <ziman> quicksilver, i had pseq there; i'd changed that to seq just before pasting. The result was the same.
14:02:11 <b_jonas> um...
14:02:19 <quicksilver> ziman: do you in fact have two cores?
14:02:25 <ziman> i do :)
14:02:29 <b_jonas> how do I figure out which version of parsec this pdf is documenting?
14:02:56 <ziman> i can clearly see only one core used in htop
14:02:58 <Baughn> ziman: You're using -O2. It's just about possible that ghc is constant-folding a and b into the same value.
14:03:14 <b_jonas> quicksilver: is parsec 3 stable released?
14:03:36 <b_jonas> quicksilver: because my ghc-6.8.3 comes with parsec-2.1.0.1
14:03:44 <Baughn> ziman: Of course a core dump would be a better way to check, but.. try b = [2..n]?
14:05:03 <ziman> Baughn, with -O2 and b = [2..n], only one core is used. *but*, when no -O option is given, both cores are used.
14:05:06 <ziman> that's interesting
14:05:47 <Baughn> ziman: Hum. It must be /very/ clever
14:06:12 <ziman> even with b = [n..n+n]
14:06:28 <Baughn> ziman: Or not. Say, what's the speed of the no-O version?
14:08:58 <quicksilver> ziman: `par` is only a hint, of course. I suspect the optimiser is inlining stuff and breaking it.
14:09:06 <ziman> hm, i forgot the -N2 option in the [2..n] case, sorry for the confusion. So when b = [2..n], it goes parallel.
14:09:34 <Baughn> And I bet when it's [1..n], it takes exactly the same amount of time as when it's parallel. Or possibly a little less.
14:11:02 <ziman> it takes half the time, in fact ;)
14:11:10 <ziman> of course there's no point in calculating it in parallel; the program is quite artificial
14:12:14 <tomet> does anyone know of a fast way to find the roots of an arbitrary function f: R^2 -> R^2 ?
14:12:48 <vixey> tomet: no
14:12:53 <b_jonas> not even a slow one
14:12:55 <ziman> i guess that's unsolvable for an arbitrary function
14:13:20 <ziman> i'm benchmarking what performance boost i can get from paralellism but so far the fastest versions were those non-parallel :\
14:13:33 <b_jonas> you need some more info about what the function is like
14:13:41 <tomet> b_jonas: smooth
14:13:44 <Cale> tomet: If you assume the function is continuous, or at least piecewise continuous, you can do something about it.
14:14:08 <ziman> Baughn, thanks for the hints
14:14:42 <Cale> (note that if you have an interval in which the function is positive on one end of the interval and negative on the other, then either there's a discontinuity in that interval, or a root.
14:14:44 <Cale> )
14:14:50 <Baughn> ziman: GHC is sufficiently smart that you have to do /non-trivial/ things for it to make sense to parallelize, yes. :)
14:15:00 <ziman> :)
14:15:05 <Baughn> ziman: But do take a look at the core output for that program. It's rather interesting.
14:15:16 <tomet> Cale: the functions are of the form f u v = Integral from -inf to +inf of e^-p^2 / sqrt(u^2 + v^2 e^-p^2) dp
14:15:47 <Cale> If you can assume that it's differentiable, then you could apply Newton's method.
14:16:59 <b_jonas> maybe look at what gsl has
14:17:13 <b_jonas> you might need to write the haskell binding for it though
14:17:56 <b_jonas> this gsl ---> http://www.gnu.org/software/gsl/
14:18:01 <lambdabot> Title: GSL - GNU Scientific Library - GNU Project - Free Software Foundation (FSF)
14:18:14 <chrisdone> hmm, cool. Panda has an RSS feed for every tag, so I've told lighttpd to redirect User-Agent =~ "Planet Haskell" to my blog's Haskell feed, so Planet Haskell only gets my haskell posts, not random posts about my cats ~_@
14:18:54 <Botje_> but but but!
14:18:59 <Botje_> now we're missing out on cats!
14:19:07 <ziman> well, i do have such things. As a benchmark, i have an md5 brute-force cracker that cracks two ~17000-element passwd groups in parallel but the overhead of parallelism seems to eliminate the gain from it (the non-parallel version is still faster)
14:19:13 <chrisdone> @quote cats
14:19:13 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
14:19:16 <b_jonas> gsl has some root finders which may or may not work well for your function
14:19:42 <tomet> yes
14:20:05 <tomet> problem however, is that i'de be giving it a function defined in terms of some integral... so i'de need to numerical integrate too
14:20:21 <tomet> where are the haskell bindings for gsl?
14:20:53 <tomet> ziman: cuda owns that sort of thing, if you have the time to code it :P
14:21:32 <b_jonas> tomet: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix has some, but probably not the ones for the solver
14:21:33 <lambdabot> Title: HackageDB: hmatrix-0.4.0.0, http://tinyurl.com/58d3eb
14:22:00 <b_jonas> tomet: fortunately numerical libraries are usually easy to wrap because they have sane types
14:22:14 <plutonas> does const just return its first argument?
14:22:17 <b_jonas> tomet: that applies less to the solver than to most of gsl though probably
14:22:19 <b_jonas> plutonas: yes
14:22:25 <b_jonas> plutonas: first of two
14:22:25 <plutonas> thanks
14:22:30 <b_jonas> @src const
14:22:30 <lambdabot> const x _ = x
14:22:42 <plutonas> oh didn't think to check the source
14:22:43 <plutonas> ok
14:23:29 <plutonas> am studying for exam, and i'm afraid i need to memorize most of prelude...
14:23:45 <plutonas> :(
14:23:57 <tomet> hence why exams on programming languages are plain stupid
14:24:13 <tomet> then again... you do the same thing for analysis
14:24:20 <tomet> so maybe all exams are stupid
14:24:23 <plutonas> tomet: i agree, the questions are quite simple, but i need to know what the functions he'll have does etc
14:24:37 <plutonas> tomet: in analysis you can have open book exam
14:24:38 <chrisdone> what is the type of foo in char *foo[0]?
14:24:56 <plutonas> chrisdone: no idea, is this valid syntax?
14:25:04 <plutonas> C syntax perhaps
14:25:05 <b_jonas> chrisdone: are you sure you're in the right channel?
14:25:05 <plutonas> :P
14:25:07 <chrisdone> well, it's C code
14:25:33 <Arnar> evenin' all
14:25:58 <plutonas> by the way i am taking a look at curry's type, does curry get applied automatically when arguments are missing?
14:26:11 <plutonas> i never remember using curry explicitly in my code, although i did a lot of currying
14:26:22 <plutonas> does the curry function have any use?
14:26:48 <Arnar> I'm reading Huges' paper "Generalizing Monads to Arrows" and I have a couple of questions ... let me be forward and just put them out there:
14:27:19 <Baughn> plutonas: The curry function does something else
14:27:28 <Arnar> 1. he says that functors can be formalized as classes.. but that requires much more powerful class system than Haskell has [in 1998] - is this still the case?
14:27:32 <ddarius> plutonas: As normally written, Haskell functions are in curried(adjective) form.  They are not curried(verb), as in curry is not applied to them.
14:27:54 <dolio> @type curry (succ *** pred)
14:27:55 <lambdabot> forall a b. (Enum b, Enum a) => a -> b -> (a, b)
14:28:20 <Arnar> 2. when defining MaybeFunctor - is there no way to do it without ||| ? (also, I think there's a typo in the paper)
14:28:46 <dolio> > zipWith (curry $ succ *** pred) [1..10] ['a'...'z']
14:28:47 <lambdabot>   Not in scope: `...'
14:28:51 <dolio> > zipWith (curry $ succ *** pred) [1..10] ['a'..'z']
14:28:52 <lambdabot>   [(2,'`'),(3,'a'),(4,'b'),(5,'c'),(6,'d'),(7,'e'),(8,'f'),(9,'g'),(10,'h'),(...
14:29:11 <plutonas> too complicated example
14:29:20 <Arnar> :t (***)
14:29:21 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:30:12 <plutonas> oh, got it
14:30:14 <guineapig> wow, "Learn You a Haskell" has amazing art work. I'm reading it just for that
14:33:17 <badtruffle> wow, that :t (***) meant nothing to me
14:33:21 <badtruffle> the response to it, that is
14:34:17 <ziman> > ((+1) *** (*5)) (5,6)
14:34:18 <lambdabot>   (6,30)
14:34:20 <plutonas> hm, and what exactly do from and toEnum do? i read their types and some examples but don't get it, it's like they take an integer, and return it
14:34:38 <nomeata> :t \f1 f2 (x,y) ->  (***) f1 f2 (x,y)
14:34:39 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
14:34:54 <Arnar> badtruffle: ignore the first part and look at the last (after =>) .. it says it takes two arrows, one from b to c and the other from b' to c'.. and gives you an arrow from (b,c) to (b',c')
14:35:08 <badtruffle> ah I see
14:35:14 <geezusfreeek> :toEnum
14:35:19 <geezusfreeek> :t toEnum
14:35:20 <lambdabot> forall a. (Enum a) => Int -> a
14:35:26 <badtruffle> Arnar: thanks, that make sa lot more sense
14:35:31 <Arnar> :)
14:35:38 <plutonas> geezusfreeek: i said that i read their types :)
14:35:51 <geezusfreeek> plutonas, the type above shows that toEnum takes an Int and returns whatever type it unifies with
14:36:07 <plutonas> whatever type it unifies with?
14:36:14 <geezusfreeek> > toEnum 33 :: Char
14:36:15 <lambdabot>   '!'
14:36:20 <geezusfreeek> see? ^
14:36:20 <Arnar> so.. no takers for my "Functors as class" question? :)
14:36:33 <geezusfreeek> > toEnum 33 :: Integer
14:36:35 <lambdabot>   33
14:37:04 <plutonas> oooh
14:37:09 <Arnar> @instances Enum
14:37:09 <plutonas> i see
14:37:10 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:37:29 <ddarius> @src Functor
14:37:29 <lambdabot> class  Functor f  where
14:37:29 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:37:33 <geezusfreeek> > toEnum 0 :: Bool
14:37:34 <lambdabot>   False
14:37:37 <geezusfreeek> > toEnum 1 :: Bool
14:37:38 <lambdabot>   True
14:37:48 <plutonas> i see i see, thanks
14:37:52 <geezusfreeek> no prob
14:37:57 <Arnar> ddarius: ah, ok.. so Hughes' comment only applied to 1998 then :)
14:38:26 <b_jonas> wait, why is @instances returning only the prelude ones?
14:38:36 <Arnar> ddarius: ah.. no, I'm talking about different functors
14:38:41 <b_jonas> > fromEnum 2 :: Word32
14:38:42 <lambdabot>   Couldn't match expected type `Word32' against inferred type `Int'
14:38:49 <b_jonas> > fromEnum 2 :: Word.Word32
14:38:50 <lambdabot>   Couldn't match expected type `Word32' against inferred type `Int'
14:38:54 <Arnar> ddarius: "Functors" in the sense that they are to arrows as monad transformers are to monads
14:38:57 <b_jonas> > toEnum 2 :: Word.Word32
14:38:58 <lambdabot>   /tmp/3214502624549710765:68:56:
14:38:58 <lambdabot>      Not in scope: type constructor or clas...
14:39:07 <b_jonas> > toEnum 2 :: Word32
14:39:08 <lambdabot>   2
14:39:13 <geezusfreeek> > toEnum 2 :: Data.Word.Word32
14:39:15 <lambdabot>   2
14:39:59 <b_jonas> of course, for numeric types you can use fromInteger or fromIntegral
14:40:08 <geezusfreeek> i know it probably isn't useful, but the math geek in me is still disappointed that Rational is not an instance of Enum
14:40:13 <ddarius> Arnar: I'm too lazy to get the paper.  What is the class declaration he wants to write?
14:40:22 <b_jonas> it's not?
14:40:29 <b_jonas> > toEnum 2 :: Rational Int
14:40:31 <lambdabot>       Kind error: `Rational' is applied to too many type arguments
14:40:31 <lambdabot>      In th...
14:40:34 <b_jonas> > toEnum 2 :: Rational
14:40:35 <lambdabot>   2%1
14:40:37 <geezusfreeek> oh
14:40:37 <b_jonas> it is
14:40:48 <geezusfreeek> i didn't see it in the docs on haskell.org
14:40:49 <b_jonas> it's just that instances listed only the ones in the prelude
14:40:51 * geezusfreeek check again
14:40:53 <tromp_> > succ 0 :: Rational
14:40:54 <lambdabot>   1%1
14:41:11 <tromp_> >  [0..] :: [Rational]
14:41:12 <lambdabot>   [0%1,1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1...
14:41:14 <geezusfreeek> > map toEnum [0..] :: [Rational]
14:41:15 <lambdabot>   [0%1,1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1...
14:41:22 <geezusfreeek> :P that works
14:41:42 <b_jonas> > [False..]
14:41:43 <lambdabot>   <no location info>: parse error on input `]'
14:41:44 <tromp_> >  [3%5..] :: [Rational]
14:41:46 <lambdabot>   [3%5,8%5,13%5,18%5,23%5,28%5,33%5,38%5,43%5,48%5,53%5,58%5,63%5,68%5,73%5,7...
14:41:48 <geezusfreeek> oh, it's not the diagonal way of enumerating the rationals though :(
14:41:48 <Arnar> ddarius: don't know exactly.. exactly what he says: "We note briefly that the concepts of monad transformers and functors can be formalized as classes, thus overloading the lifting operations, but that this requires a much more powerful class system than haskell currently supports"
14:41:53 <b_jonas> what?
14:41:59 <b_jonas> > [ False .. ]
14:41:59 <dolio> > [False ..]
14:42:00 <geezusfreeek> i guess this is the more useful way though
14:42:00 <lambdabot>   [False,True]
14:42:01 <lambdabot>   [False,True]
14:42:04 <b_jonas> oh
14:42:10 <geezusfreeek> http://www.homeschoolmath.net/teaching/rational-numbers-countable.php
14:42:11 <lambdabot> Title: Proof that rational numbers are countable - from Homeschool Math, http://tinyurl.com/2z7y5m
14:42:12 <b_jonas> that's funny
14:42:15 <ziman> :t fromEnum
14:42:16 <lambdabot> forall a. (Enum a) => a -> Int
14:42:28 <ziman> > fromEnum (2%3)
14:42:29 <lambdabot>   0
14:43:03 <Arnar> geezusfreeek: computing the diagonal-order is difficult if you don't want duplicates
14:43:14 <tromp_> it would be cool to have [0..] enumerate *all* Rationals
14:43:29 <b_jonas> so how does the builtin state in GenParser work? does it revert when the parser backtracks or does it keep the info from failed descensions?
14:43:35 <vixey> but there's infinity of them!
14:43:42 <tromp_> so?
14:43:50 <dolio> There are infinity naturals.
14:44:00 <b_jonas> well, you can still write a function to enumerate them explicitly
14:44:05 <b_jonas> even if it's not the enum method
14:44:18 <Arnar> you can enumerate them sure.. but not in their natural order
14:44:26 <tromp_> http://portal.acm.org/citation.cfm?id=1132893
14:44:28 <lambdabot> Title: FUNCTIONAL PEARL: Enumerating the rationals
14:44:35 <opqdonut> class WellOrdering a where ...
14:44:35 <ziman> @src (,) succ
14:44:36 <lambdabot> Source not found. My mind is going. I can feel it.
14:44:36 <opqdonut> ;)
14:44:50 <ziman> (,) could be diagonally ordered
14:45:07 <tromp_> http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/rationals.pdf
14:45:10 <lambdabot> Title: FUNCTIONAL PEARL Enumerating the Rationals, http://tinyurl.com/5rvqtv
14:45:11 <mattam> Q is not well-ordered is it?
14:45:35 <lament> it is, by the well-ordering principle :)
14:45:59 <lament> it's also countable, though
14:46:23 <lament> so there aren't any problems ordering it
14:46:32 <mattam> it's also ... though. You're trying to confuse me!
14:46:58 <vixey> I think that Q cannot be well ordered
14:47:07 <mattam> Hmm. Well-ordered means having a least element.
14:47:11 <Arnar> Q cannot be well ordered. coming up with a counterexample is easy
14:47:14 <vixey> { x | x^2 <= 2 }
14:47:14 <tromp_> @let nexrat = recip (fromInteger n+1y) where (n,y) = properFraction x
14:47:15 <lambdabot>  <local>:2:31: Not in scope: `'
14:47:18 <b_jonas> > nub (concatMap (\m -> concatMap (\k -> [(m-k)%k, (k-m)%k]) (enumFromTo 1 m)) (enumFrom 0))
14:47:19 <opqdonut> Arnar: :D
14:47:19 <lambdabot>   [0%1,1%1,(-1)%1,2%1,(-2)%1,1%2,(-1)%2,3%1,(-3)%1,1%3,(-1)%3,4%1,(-4)%1,3%2,...
14:47:22 <b_jonas> there
14:47:24 <vixey> it has an upper bound 2
14:47:34 <vixey> but no least upper bound in Q,
14:47:40 <lament> Arnar: yes? Give a counterexample then.
14:47:42 <vixey> does this mean it's not well ordered
14:47:43 <vixey> ?
14:47:51 <opqdonut> the natural ordering
14:47:55 <opqdonut> of rational numbers
14:47:58 <opqdonut> is not a wellordering
14:48:03 <lament> the natural ordering is not a well-ordering
14:48:04 <b_jonas> the normal ordering of Q is not a well-ordering, but Q as a set can be well-ordered
14:48:09 <lament> right
14:48:09 <b_jonas> (as every set can)
14:48:16 <opqdonut> glorious threereo
14:48:16 <lament> Q more so than some other "every sets"
14:48:17 <b_jonas> yeah, natural ordering
14:48:28 <lament> you don't need axiom of choice to show that Q is well-ordered
14:48:33 <agcorona> Hi, some tutorial about how to make a cabal package?
14:48:34 <vixey> oh right I see
14:48:42 <b_jonas> lament: oh
14:48:47 <ddarius> Arnar: He might be talking about multiparameter type classes and functional dependencies.
14:48:50 <b_jonas> I was puzzled at first what you meant by more so
14:48:51 <vixey> you you can put them <-> with N so a well order exists
14:48:59 <opqdonut> b_jonas: well the ordering can be constructed
14:49:00 <b_jonas> wait, how does that work
14:49:04 <opqdonut> as it has been even on this channel
14:49:18 <lament> b_jonas: it's a countable set
14:49:19 <b_jonas> I mean, do you need AC to well-order any set?
14:49:20 <Arnar> ddarius: ah ok.. so this is possible today (isn't there a class for monad transformers?)
14:49:50 <lament> b_jonas: the well-ordering theorem, that says that every set can be well-ordered, is equivalent to AC
14:49:55 <b_jonas> I'm not good in set theory but I thought you could have ordinals without AC, and ordinals are about well-ordering
14:50:13 <lament> b_jonas: the reals are not well-ordered in any way we can describe
14:50:28 <lament> although AC says that such an ordering must exist
14:51:13 <b_jonas> so you can't prove R can be well-ordered without the AC?
14:51:16 <mattam> AC is equivalent to the well-ordering theorem.
14:51:21 <b_jonas> from ZF that is
14:51:28 <b_jonas> I see
14:51:41 <Arnar> mattam: true
14:51:42 <b_jonas> makes sense
14:51:48 <Arnar> http://en.wikipedia.org/wiki/Well-ordering_theorem
14:51:49 <lambdabot> Title: Well-ordering theorem - Wikipedia, the free encyclopedia
14:52:07 <mattam> Q can be shown to have a well-order without resorting to AC just because it's countable?
14:52:13 <b_jonas> I should learn more logic
14:52:18 <Arnar> you can swap out AC for either wellorderingprinciple or zorn's lemma
14:52:19 <lament> mattam: yes
14:52:23 <opqdonut> well wellorderingprinciple<->AC does not imply Rcanbewellordered<->AC
14:52:38 <b_jonas> even this year I should have taken the nonstandard analysis course because it's by a very good teacher
14:52:48 <lament> mattam: if something is countable, it means you can apply the ordering of the naturals to it
14:52:53 <lament> mattam: naturals are well-ordered
14:52:59 <mattam> Infinity is so fascinating...
14:53:20 <Baughn> mattam: Yes, there's so much of it..
14:53:22 <Arnar> mattam: an enumeration of a set defines an order, which obviously is a well ordering
14:53:24 <vixey> haha
14:53:25 * olsner stands around for a while staring into infinity
14:53:43 <mattam> Is there a constructive proof for that?
14:53:57 <lament> mattam: sure, it's trivial
14:54:00 <vixey> would that be Acc ?
14:54:07 <vixey> for well ordering
14:54:08 <ddarius> olsner: Infinity doesn't exist.
14:54:11 * ddarius walks away.
14:54:22 <Arnar> mattam: hmm.. well, any non-empty subset of Q can be mapped to a non-empty subset of N, which has a least element... the corresponding element in Q is the least according to the enumeration order
14:54:24 <mattam> vixey: ye
14:54:37 <b_jonas> that reminds me to the djinn in GEB explaining how GOD does not exist
14:54:46 <b_jonas> s/how/in what way/
14:54:48 <lament> mattam: it's trivial to show that naturals are well-ordered; and "countable" means you can label every object in your set with a natural number, so you can sort them like you would sort the naturals
14:54:54 <lament> mattam: or did you mean a prove that Q is countable
14:54:55 <mattam> Ok ok.
14:54:57 <lament> *proof
14:55:02 <b_jonas> and the dragons from the Cyberiad which also don't exist
14:55:16 <tromp_> @hoogle (%)
14:55:16 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
14:55:32 <mattam> I mixed up with the "natural" ordering.
14:55:40 <ziman> :t gcd
14:55:41 <lambdabot> forall a. (Integral a) => a -> a -> a
14:56:13 <Arnar> mattam: ah, that one is not a well order, as witnessed by counterexamples such as {x \in Q : x > 0}
14:56:36 <vixey> and { x | x^2 <= 2 }?
14:56:37 <lament> or simply Q
14:56:51 <lament> no need to come up with complex counterexamples, Q doesn't have a least element
14:56:57 <Arnar> lament: hah.. right, of course
14:56:58 <b_jonas> yeah, each of those
14:57:25 <b_jonas> good night now
14:57:30 <Arnar> gn!
14:57:33 <mattam> Somehow I'm amazed that you can have another order on Q which "works" for infinite sets.
14:57:39 <tromp_> @et nextrat x = recip (fromInteger n+1 - y) where (n,y) = properFraction x
14:57:40 <lambdabot> Maybe you meant: ft let
14:57:52 <Arnar> mattam: what do you mean works?
14:57:57 <tromp_> @let rats = iterate nextrat 1 :: [Rational]
14:57:58 <lambdabot>  <local>:2:15: Not in scope: `nextrat'
14:58:04 <vixey> it's really strange that Q is dense in R & R is dense in Q
14:58:23 <mattam> It can order infinite sets.
14:58:42 <Arnar> vixey: yes, that is indeed strange
14:58:47 <lament> vixey: is it strange that even numbers are "dense" in the odd numbers? :)
14:58:48 <tromp_> @et nextrat = \x -> recip (fromInteger n+1 - y) where (n,y) = properFraction x
14:58:48 <lambdabot> Maybe you meant: ft let
14:58:57 <Arnar> mattam: you mean well-order infinite sets?
14:58:58 <vixey> no
14:59:01 <Arnar> because ordering them is no problem
14:59:03 <tromp_> ft let?
14:59:11 <RayNbow> hmm... is flatten an appropiate name for a function with type [(a,a)] -> [a]?
14:59:20 <skorpan> i'd call that unzip
14:59:22 <skorpan> :t unzip
14:59:23 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:59:26 <skorpan> no wat
14:59:27 <mattam> Yes.
14:59:30 <skorpan> fst . unzip
14:59:40 <skorpan> .
14:59:41 <skorpan> ...
14:59:44 <vixey> :t uncurry (++) . unzip
14:59:45 <Arnar> RayNbow: do you want both elements from the pairs in the list?
14:59:45 <lambdabot> forall b. [(b, b)] -> [b]
14:59:47 <skorpan> never mind me.
15:00:19 <RayNbow> Arnar: all items from the input list are included in the result list
15:00:56 <Arnar> RayNbow: yeah.. I meant, do you count each item of the pair as an item of the input list
15:01:05 <Arnar> i.e. do you want flatten (1,2) = [1,2] ?
15:01:21 <Arnar> sorry, flatten [(1,2)] = [1,2]
15:01:33 <RayNbow> flatten ((a,d):ads) = a : insert d (flatten ads)  -- this is the definition
15:01:36 <Arnar> I'd say flatten is as good a name as any
15:02:04 <vixey> RayNbow: I don't like that definition :/
15:02:12 <Arnar> RayNbow: ah.. note vixey's suggestion above   flatten = uncurry (++) . unzip
15:02:13 <RayNbow> (I actually have a more optimized definition using a multiset as an intermediate datastructure)
15:02:13 <vixey> RayNbow: I think that   uncurry (++) . unzip  is actually clearer
15:02:32 <vixey> will you paste the multiset one that is interesting
15:02:33 <RayNbow> vixey: that doesn't result in a sorted list
15:02:39 <vixey> sort . ...
15:03:10 <Arnar> or  concatMap (\(x,y) -> [x,y])
15:03:34 <vixey> yuck!
15:03:40 <Arnar> :P
15:03:41 <RayNbow> http://hpaste.org/11318 <-- in this version, flatten is called f or g
15:03:45 <vixey> @pl concatMap (\(x,y) -> [x,y])
15:03:45 <lambdabot> (uncurry ((. return) . (:)) =<<)
15:03:48 * vixey phew
15:03:51 <Arnar> haha
15:04:01 <Arnar> yeah.. that's much prettier  </sarcasm>
15:04:07 <vixey> oh... f and g are bad names ...
15:04:15 <lispy> import qualified Data.Set as Set, Not in scope: Set.intersect
15:04:18 <lispy> what am I doing wrong?
15:04:35 <vixey> :t Set.intersect
15:04:36 <lambdabot> Couldn't find qualified module.
15:04:41 <vixey> :t intersect
15:04:42 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:04:46 <RayNbow> vixey: I hadn't come up with a good names yet when I pasted that :p
15:04:51 <Arnar> :hoogle intersect
15:04:51 <dolio> f ((a,d):ads) = a : insert d (f ads) doesn't necessarily produce a sorted list, either.
15:05:16 <Arnar> :t Data.Set.intersect
15:05:17 <lambdabot> Not in scope: `Data.Set.intersect'
15:05:21 <RayNbow> dolio: I forgot to mention an assumption
15:05:25 <Arnar> @hoogle intersect
15:05:26 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
15:05:26 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
15:05:26 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
15:05:26 <dolio> :)
15:05:31 <RayNbow> the assumption is that fst . unzip is sorted
15:05:41 <Arnar> lispy: doesn't seem to be an intersect method
15:05:54 <luite_> @pl flatten ((a,d):ads) = a : insert d (flatten ads)
15:05:56 <lambdabot> flatten = fix ((`ap` tail) . (. head) . (`ap` snd) . (. fst) . flip ((.) . (.) . (:)) . flip ((.) . insert))
15:06:03 <RayNbow> and that for each (a,d) in the input list, a < d
15:06:10 <dolio> It's also conceivable that 'sort . uncurry (++) . unzip' is faster.
15:06:16 <Arnar> :t Data.Set.intersection
15:06:17 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
15:06:19 <Arnar> lispy: ^^
15:06:28 <RayNbow> dolio: but does sort work on infinite lists?
15:06:39 <lispy> oh, I'm spelling it wrong, thank you Arnar
15:06:49 <tromp_> no it doesnt
15:07:09 <dolio> No, but neither does f, necessarily.
15:07:14 <dolio> Beyond the first element.
15:08:57 <dolio> Of course, if your assumption holds, and you have access to the internal mergesort implementation, then 'merge . second sort . unzip' works equally well on infinite lists, and is probably faster.
15:09:26 <luite_> how does merge sort work for infinite lists?
15:09:40 <luite_> the second does not need to be ordered
15:09:44 <luite_> +list
15:09:58 <skorpan> no, it doesn't
15:10:03 <dolio> Oh, yeah, it doesn't work, my bad.
15:10:09 <skorpan> because with merge sort you split the list at the middle, which is index infinity
15:10:10 <dolio> Since it has to inspect the second list.
15:11:52 * RayNbow is going to paste some recent code + example
15:11:57 <dolio> Then '(\((a:as),ds) -> a : merge as (sort ds)) . unzip' :)
15:12:21 <RayNbow> http://hpaste.org/11318#a3
15:12:49 <vixey> how is multiset implemented
15:12:54 <luite_> dolio: f does work for infinite lists, because of the lazy evaluation of all the inserts
15:13:03 <vixey> ?where Multiset
15:13:03 <lambdabot> I know nothing about multiset.
15:13:10 <luite_> it will get slow after a while though
15:13:31 <dolio> luite_: It doesn't work if some d needs to be inserted after infinitely many as.
15:13:41 <RayNbow> @src insertBy
15:13:41 <lambdabot> insertBy _   x [] = [x]
15:13:42 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
15:13:42 <lambdabot>                                  GT -> y : insertBy cmp x ys'
15:13:42 <lambdabot>                                  _  -> x : ys
15:13:57 <vixey> oh how boring
15:14:01 <vixey> newtype MultiSet a = MS { unMS :: Map a Int }
15:14:02 <dolio> In practice it probably does. :)
15:14:12 <luite_> dolio: then the resulting list would just be infinitely many a's?
15:14:25 <dolio> Hmm...
15:14:41 <dolio> Oh, yes. I don't know what I was thinking.
15:15:18 <RayNbow> luite_: you'd run out of stackspace though after displaying those infinite a's :p
15:15:30 <dolio> Evidently I was thinking in ML or something.
15:15:34 <luite_> yeah, unless you have an infinite amoun of stack space
15:15:40 <mib_nkqw5k> hello all... I'm trying to combine two monads and it's not working... I was wondering if it's something obvious I'm doing wrong?  http://hpaste.org/11336
15:16:31 <mib_nkqw5k> (I'm trying to run a Logic computation inside a Prompt monad.  It works separately but it won't backtrack in the combined monad)
15:16:48 <RayNbow> vixey: you have to blame twanvl for the boring implementation? :p
15:17:47 <twanvl> vixey: did you expect something more exciting?
15:18:45 <vixey> I was sort of wondering if it would be a function from n -> a
15:44:32 <LoneTech> does mod expect lists?
15:44:45 <LoneTech> oops, never mind, disoriented in backlog.
15:49:27 <Cale> Hmm, MonadPrompt is interesting.
15:51:22 <wy> Hey!
15:51:33 <Cale> hey
15:51:43 <wy> Hi Cale!
15:51:44 <Pseudonym> We;'re
15:51:45 <Pseudonym> the
15:51:47 <Pseudonym> Monkees
15:52:00 <vixey> hey Wy
15:52:02 <tomet> strange that nobody has wrapped gsl yet for haskell
15:52:02 <wy> Where is the repository for GHC? I used to check it out with darcs
15:52:06 <wy> vixey: hey!
15:54:15 <wy> vixey: Long time no see!
15:54:21 <vixey> :)
15:54:45 <wy> I'm in Indiana now
15:55:50 <wy> I think I should look at GHC code. Where do I check it out?
16:00:20 <vixey> wy: I think the GHC code is pretty scary ..
16:00:31 <vixey> I wouldn't want to have to hack it :/
16:03:42 <lispy> wy: GHC repo may have moved to git officially
16:03:47 <lispy> wy: but I'm not certain
16:04:08 <lispy> wy: I know they wanted to do that around the time of the 6.10 release which is having release candidates
16:04:16 <vixey> why would you wanna look at ghc source though :p
16:04:42 * lispy has heard the darcs source is worse and he looks at it
16:06:26 <wy> I want to have a look at the intermediate language
16:10:09 <lispy> wy: you can make ghc dump the core language without having to look at GHC's source
16:11:11 <wy> lispy: Good idea... Does it still use the same core language as in SPJ's old book?
16:11:29 <lispy> wy: I have no idea :(
16:11:50 <lispy> wy: I haven't looked at either :)
16:14:16 <Cale> MonadPrompt needs Haddockising of the documentation for it, which is included in the source already.
16:14:46 <Cale> It is actually very interesting.
16:16:30 <Cale> (but it would be rather hard to work out exactly what it's for from the type signatures alone :)
16:17:09 <vixey> is MonadPrompt from LogicT?
16:17:13 <Cale> no
16:17:19 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
16:17:25 <lambdabot> Title: HackageDB: MonadPrompt-1.0.0.1, http://tinyurl.com/6yf7ow
16:17:26 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html
16:17:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5zzxue
16:20:58 <xenoblitz> quick question to anyone willing to answer... is it possible to create a totally stand alone exe with gtk2hs and ghc?
16:21:08 <Cale> xenoblitz: yes
16:21:09 <dcoutts> xenoblitz: yes
16:21:24 <xenoblitz> cale,dcoutts: any link for the steps needed?
16:21:28 <Cale> (It is hard not to do so.)
16:21:46 <Cale> Just compile your program as normal. It will be a standalone executable.
16:21:51 <xenoblitz> cale: what i mean is ... the exe works on a pc without gtk2hs installed
16:22:02 <dcoutts> xenoblitz: for example here is an installer for an app built with ghc + gtk2hs:
16:22:02 <dcoutts> http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
16:22:07 <Cale> All Haskell libraries are statically linked.
16:22:26 <dcoutts> xenoblitz: you can try that installer on a system without ghc, it works fine, try it
16:22:41 <xenoblitz> dcoutts: i'll check it out :)
16:22:51 <xenoblitz> cale: yes but when i sent an exe to my friend it complained about missing libraries
16:22:56 <plutonas> how should i think on finding the type of (map map) according to my own logic (:P) it should be ((a->b)->[a]) -> [a->b] -> [a], but it disagrees with ghci
16:23:12 <Cale> xenoblitz: It's possible that your friend is missing GTK2, though.
16:23:44 <xenoblitz> cale: yes cale, in fact i was wondering if its possible to have a totally stand alone exe without the use of gtk2 installed (example on a windows machine)
16:23:53 <Cale> plutonas: map :: (a -> b) -> ([a] -> [b])
16:24:00 <dcoutts> xenoblitz: if it uses C libs then those also need to be distributed with the .exe, you'll notice that the installer I just linked to installs a minimal set of gtk .dll files
16:24:12 <jgrimes> is there any way to mod after every multiplication in an exponential, or a fast fermat's little theorem implementation
16:24:41 <dcoutts> xenoblitz: so yes, that installer works on a system without ghc or gtk+ installed, it includes the .exe and all the necessary .dll files
16:24:41 <Cale> plutonas: so when figuring out the type of map map, we replace a with (a -> b), and b with ([a] -> [b])
16:24:55 <plutonas> Cale: why not ((a->b) -> [a]) -> [b] ? (thats where my answer was based on
16:25:03 <plutonas> hm
16:25:08 <Cale> plutonas: because -> is right associative.
16:25:32 <xenoblitz> dcoutts: I installed it :) I'll check out what files were included and try out something similar :), thanks
16:25:35 <xenoblitz> cale: also thanks
16:25:43 <plutonas> hm... i see, though i'm not sure i'd do it correct if i were asked for similar functions
16:25:54 <Cale> A value of type ((a->b) -> [a]) -> [b] would be a function which takes a function from functions of type (a -> b) to [a] and returns a list of type [b]
16:26:32 <lispy> jgrimes: I have a fast modular exponentiation implementation
16:26:36 <plutonas> hm, i see, thanks
16:26:38 <Cale> (It seems unlikely that a useful such function exists)
16:26:46 <plutonas> so first i need to add parens
16:26:54 <plutonas> and then find out
16:27:05 <jgrimes> lispy, is it available somewhere?
16:27:18 <Cale> It would be good to add parens first if you're not perfectly comfortable with how -> associates yet.
16:27:38 <lispy> jgrimes: http://hpaste.org/11341
16:27:41 <vixey> > 1+1
16:27:43 <lambdabot>   2
16:28:26 <jgrimes> lispy, cool, thanks
16:28:29 <lispy> jgrimes: if you remove my type signature and erplace with something more general you'd even be able to specialize it to more efficient types
16:29:17 <jgrimes> lispy, nice. :)
16:29:49 <lispy> jgrimes: as for a fast fermat...hmm...I don't have code for that :)
16:30:10 <wy> lispy: I found it. Looks a little different
16:30:16 <jgrimes> lispy, this is essentially what I was looking for
16:30:21 <lispy> jgrimes: I do havea strong pseudo primality test if you'd like
16:30:28 <xenoblitz> dcoutts:i don't know if its too much to ask... but how possible is it to know which lib files are required to be distributed with one's exe?
16:31:05 <jgrimes> lispy, thats what I'm sort of working on. experimenting with some probabilistic primality testing
16:32:00 <lispy> jgrimes: cool.  My code is some of the first stuff I wrote in Haskell so it's icky in a sense, but you're welcome to look at it: http://files.codersbase.com/miller-rabin.hs and http://files.codersbase.com/pollard-rho.hs
16:32:02 <wy> lispy: The longest line is 123... I have to maximize my editor
16:32:15 <lispy> jgrimes: the pollard-rho is nice to use as a comparison against the pseudo prime checker
16:32:26 <lispy> wy: heh
16:33:16 <xenoblitz> dcoutts: i apologize if my question is stupid or very very beginneresque... i just don't have any experience with this stuff
16:33:32 <lispy> jgrimes: I also have a type RSA implementation with some handy bits if you like: http://files.codersbase.com/rsa.hs
16:33:42 <lispy> jgrimes: I meant, toy not type :)
16:33:56 <jgrimes> lispy, :)
16:34:12 <lispy> RSA in the type system would be interesting.  But I didn't go that far :)
16:34:22 * lispy imagines encrypted types
16:35:19 <dcoutts> xenoblitz: no you're right it's not always that easy to know.
16:36:34 <wy> lispy: It's quite different from the old one. It's system F
16:36:53 <lispy> wy: the new stuff is sytem F you mean?
16:38:12 <wy> lispy: It's called system FC (System F with type equality Coersions)
16:38:27 <lispy> coo
16:38:45 <plutonas> what exactly does ($x) mean? i know that f x $ g x is equivallent to f x (g x) but ($x) confuses me
16:39:05 <dibblego> @unpl ($x)
16:39:06 <lambdabot> (\ a -> a x)
16:39:06 <BONUS> ($ x) is a section
16:39:11 <BONUS> like (+ x) is
16:39:16 <BONUS> so ($ x) f is f $ x
16:39:24 <Cale> It means the function which applies its argument to x
16:39:30 <dcoutts> xenoblitz: so what it needs is all the .dll files that are used by each of the packages used by the application
16:39:32 <BONUS> whats cool is that you can map ($ x) to a list of functions
16:39:39 <lispy> :t ($x)
16:39:41 <lambdabot>     Ambiguous occurrence `x'
16:39:41 <lambdabot>     It could refer to either `L.x', defined at <local>:2:0
16:39:41 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:72:0-32
16:39:50 <lispy> :t ($L.x)
16:39:52 <lambdabot> forall a b. (Num a) => (a -> b) -> b
16:40:28 <lispy> :t (id L.x)
16:40:29 <lambdabot> forall t. (Num t) => t
16:40:38 <lispy> :t (`id` L.x)
16:40:40 <dcoutts> xenoblitz: each package specifies 'extra-libraries'. These are the .dll files that have to be distributed.
16:40:40 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
16:41:26 <dcoutts> xenoblitz: if you've got visual studio then that comes with a dll tool to find all the dependencies of an exe. Or perhaps on mingw the ldd command does the same.
16:42:54 <xenoblitz> dcoutts: i'll try visual studio...
16:46:14 <plutonas> how would i write g x = map ($x) as a list comprehension?
16:47:11 <dolio> g x l = [ f x | f <- l ]
16:47:41 <electronx> just wandering anyone want to submit a parallel version of binary tree to the great language shootout
16:48:16 <plutonas> thanks dolio
16:48:21 <electronx> ghc seems to be lagging there because its not running in parallel whereas other language like java are
16:48:27 <electronx> http://shootout.alioth.debian.org/u32q/benchmark.php?test=binarytrees&lang=all
16:48:29 <lambdabot> Title: binary-trees benchmark | Ubuntu : Intel Q6600 quad-core Computer Language Be ..., http://tinyurl.com/56k7ql
16:48:45 <sjanssen> electronx: I've tried writing a parallel version, it is a bit tricky
16:49:02 <electronx> i would do it myself but i don't know how either :)
16:49:11 <electronx> still learning
16:52:20 <electronx> can it be that hard?
16:52:36 <electronx> i thought haskell was excellent for parallel stuff
16:53:08 <electronx> @seen
16:56:50 <plutonas> why is do [1,2,3]; "word" printing "wordwordword"?
16:58:00 <lispy> > do [1,2,3]; "word"
16:58:01 <lambdabot>   "wordwordword"
16:58:13 <lispy> > [1,2,3] >>= "word"
16:58:14 <lambdabot>   Couldn't match expected type `t -> [b]'
16:58:17 <lispy> > [1,2,3] >> "word"
16:58:18 <lambdabot>   "wordwordword"
16:58:35 <lispy> ?src Monad []
16:58:35 <lambdabot> Source not found. Wrong!  You cheating scum!
16:58:57 <plutonas> ough it has to d owith monads
17:00:28 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247#a247 -- fun :)
17:00:57 <Cale> Annoying that it needs extra explicit type signatures because of the GADT usage though.
17:02:48 <vininim_> > let ps = filterM (const [True, False]) in ps ps [1,2,3]
17:02:49 <lambdabot>   Couldn't match expected type `[a]'
17:03:04 <vininim_> > let ps = filterM (const [True, False]) in ps $ ps [1,2,3]
17:03:05 <lambdabot>   [[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]],[[1,2,3],[1,2],[1,3],[1],[2,3],...
17:04:02 <vininim_> > let ps = filterM (const [True, False]) in ps $ ps [1,2]
17:04:04 <lambdabot>   [[[1,2],[1],[2],[]],[[1,2],[1],[2]],[[1,2],[1],[]],[[1,2],[1]],[[1,2],[2],[...
17:05:04 <lispy> Cale: gadts are sadly unweildly at times :(
17:06:12 <vininim_> @pl \ x y -> compare (length x) (length y)
17:06:12 <lambdabot> (. length) . compare . length
17:06:38 <vininim_> @ap \ x y -> compare (length x) (length y)
17:06:38 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
17:06:42 <vixey> > 1+1
17:06:43 <lambdabot>   2
17:08:08 <Cale> hmm, I'm not sure how to handle the backwards-in-time state monad with Prompt yet though.
17:10:04 <Cale> I'm not sure that it's possible.
17:10:40 <Cale> But it's probably just that I'm insufficiently imaginative at the moment :)
17:11:00 <twanvl> Is backwards state really a monad at all?
17:11:05 <Cale> yes
17:11:32 <Cale> Does it fail any of the monad laws somehow?
17:11:59 <lispy> Cale: what is the exectutive summary of MonadPrompt?
17:12:20 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html -- see the comments here
17:12:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5zzxue
17:13:22 <Cale> It's basically a way to construct monads from sets of abstract operations, where the semantics of those operations is encoded in the run function.
17:18:15 <Cale> A nice thing about this approach is that the meanings of the operations can be determined later.
17:18:16 <lispy> why is it called prompt?
17:18:39 <Cale> I can't think of a particularly good reason, but then, I don't have a better name.
17:19:26 <Cale> It could be in the sense of "ask for the meaning of this operation"
17:21:11 <Cale> So, there should be a run function for, say, Prompt (PromptState Integer), which instead of carrying the state along, whenever a "Put" is done, it prints the integer to the screen, and whenever a "Get" is done, it asks the user for a value.
17:25:38 <Cale> *Main> runState (inc >> inc) 0
17:25:38 <Cale> (2,())
17:25:46 <Cale> *Main> runStateUser (inc >> inc)
17:25:47 <Cale> 5
17:25:47 <Cale> 6
17:25:47 <Cale> 10
17:25:47 <Cale> 11
17:25:51 <Cale> like so :)
17:26:03 <Cale> (where 5 and 10 were my inputs)
17:27:03 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247#a248
17:28:22 <Cale> Of course, something more in line with the State operations with regard to IO would be to specify an IORef to use as the state variable.
17:33:49 <Cale> *Main> r <- newIORef (0 :: Int)
17:33:49 <Cale> *Main> runStateIORef (inc >> inc) r
17:33:49 <Cale> *Main> readIORef r
17:33:49 <Cale> 2
17:33:52 <Cale> whee :)
17:34:36 <Cale> (of course, it's probably easier to imagine writing runStateIORef in terms of runState, rather than by replacing the semantics of get and put...
17:34:51 <Cale> but this way is pretty fun as well)
17:35:12 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247#a249
17:43:41 <roconnor> Running Haddock for colour-0.0.0...
17:43:41 <roconnor> Warning: The documentation for the following packages are not installed. No
17:43:41 <roconnor> links will be generated to these packages: rts-1.0
17:43:46 <roconnor> what does this warning mean?
17:44:43 <Cale> roconnor: That the generated haddock would have linked to the documentation for rts-1.0, but since you don't have that package installed, it won't.
17:45:43 <Cale> (or rather, since you don't have its documentation installed...)
17:46:18 <roconnor> what is rts?
17:46:27 <roconnor> Do I want it?
17:46:36 <roconnor> run time system?
17:47:10 <Cale> I'm not sure, but that's plausible
17:47:14 <roconnor> is this why my Eq instances are documented like: ??? a => Eq (AlphaColour a)
17:47:32 <Cale> What's the actual context?
17:48:23 <Cale> That package isn't on hackage, but it appears to come with GHC.
17:48:27 <roconnor> I'm building haddock for my own package
17:48:29 <Cale> I'm not sure where it's documented.
17:48:33 <roconnor> under ubuntu
17:48:35 <Cale> I know...
17:48:47 <Cale> But what is the actual class context for that instance?
17:48:53 <Cale> Eq a?
17:49:43 <LynxAba> hello evryone!
17:49:50 <Cale> hi!
17:50:11 <LynxAba> could someone tell me the dofference between type and newtype, please?
17:50:39 <LynxAba> *diff...
17:50:46 <roconnor> Cale: it should be Eq
17:51:08 <roconnor> it is generated by deriving (Eq)
17:51:13 <TSC> LynxAba: Have a look at: http://www.haskell.org/haskellwiki/Type#Type_and_newtype
17:51:15 <lambdabot> Title: Type - HaskellWiki
17:51:16 <roconnor> oh, wait
17:51:19 <roconnor> I have a bug
17:51:28 <Cale> LynxAba: newtype creates a properly new type in the type system, treated as different from other types
17:51:30 <roconnor> scratch that
17:51:32 <roconnor> I don't
17:51:40 <Cale> LynxAba: type defines a synonym for an existing type
17:51:42 <twanvl> Cale: it seems backwards state is possible with prompt, http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247#a250
17:51:46 <Cale> which is treated as the same
17:52:01 <Cale> twanvl: aha, good show :)
17:52:34 <Cale> er...
17:52:38 <Cale> hmm
17:52:48 <LynxAba> thanks everybody!
17:54:13 <Cale> ah, it does work, cool :)
17:57:15 <Cale> er...
17:57:41 <Cale> *Main> runStateB (do vs <- prompt Get; prompt (Put (1:vs))) []
17:57:42 <Cale> ((),[1])
17:58:32 <Samy> :t prompt
17:58:33 <lambdabot> Not in scope: `prompt'
17:58:40 <Samy> wat
17:58:57 <Cale> Samy: http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html
17:58:59 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5zzxue
17:59:07 <twanvl> that's not right...
18:05:25 <shapr> Hmm, I'm not the first person to want GHC on the PS3
18:05:41 <shapr> Seems that Tristran Allwood built GHC 6.6 for the PS3 in 2007!
18:05:48 <SamB_XP> what ? you mean people have actually purchased PS3s now?
18:05:53 <shapr> I got a used one.
18:05:53 <ivanm> heh
18:05:54 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:06:53 <shapr> I just got Ubuntu 7.10 installed on my PS3, but I've been less than impressed so far.
18:07:22 <ivanm> so, how does one navigate a DE using a gaming controller?
18:08:08 <shapr> DE?
18:08:24 <SamB_XP> shapr: what do you use for input ?
18:08:34 <shapr> A kinesis keyboard?
18:08:35 <Guspaz> Hi, I was wondering, every time I do "show c" where c is a Char, I get back the string 'x' (where x was the char in the var) rather than just x. As in, it's putting single quotes there. Anybody have an idea how to turn a char into a one-char string rather than a three-char string?
18:08:50 <SamB_XP> ivanm: I believe the answer is "you don't"
18:08:59 <shapr> SamB_XP: Seriously, I plugged in my USB keyboard and mouse.
18:09:37 <snhmib> Guspaz: [c] ?
18:09:56 <Cale> (you don't use show)
18:10:14 <Cale> (:[]) will do it, if you need a function  Char -> String
18:10:25 <SamB_XP> @quote eat
18:10:25 <lambdabot> fasta says: Ok, this is great, now it all appears to work. :(
18:10:33 <Guspaz> It doesn't seem to like [], gives a type error on compile. I should probably post the whole code chunk
18:10:34 <SamB_XP> @quote  eat
18:10:34 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
18:10:38 <Cale> But that's more readably written as snhmib wrote it if you have the character handy)
18:10:48 <SamB_XP> @quote \beat
18:10:48 <lambdabot> olliej says: <olliej> java is a great language <olliej> i like to eat toothpaste <olliej> :)
18:10:51 <Cale> [] is the empty list
18:10:52 <SamB_XP> @quote \beat
18:10:53 <lambdabot> ari says: The problem I have with grues is that although I know that currently, if it is very dark I am likely to be eaten by one... but how can I tell if grue suddenly became benign at, say, the
18:10:53 <lambdabot> year 2010? The evidence I've gathered so far can't support the idea that that *wouldn't* happen.~
18:11:14 <snhmib> but (:[]) looks like a smilie, in haskell that's like extra bonus points
18:11:32 <SamB_XP> @quote I once saw
18:11:32 <lambdabot> No quotes for this person. I feel much better now.
18:11:33 <Trinithis> can someone give me a chunk definition
18:11:39 <SamB_XP> @quote \bI once saw
18:11:39 <lambdabot> No quotes for this person. :(
18:11:57 <Guspaz> Code/error: http://hpaste.org/11345
18:13:10 <Trinithis> nevermind
18:15:59 <Guspaz> Any ideas what I'm doing wrong?
18:17:12 <Cale> Guspaz: printTree :: (Show a) => Tree a -> String
18:17:20 <Cale> but the code you've written assumes that a = Char
18:17:50 <Guspaz> So I should ditch the Show typeclass and just do Tree Char?
18:18:00 <Cale> If that's the code you want for printTree
18:18:21 <Cale> alternately, you should replace [l] with  show l
18:18:51 <Cale> Personally, I would factor this problem through a function of type  Tree a -> [a]
18:19:02 <Cale> That would handle both cases nicely.
18:19:46 <Guspaz> Cale: show l was the original problem, it was producing a three-character string: 'x' instead of x
18:20:15 <Cale> Guspaz: well, it was doing that because that's how individual characters are shown.
18:20:52 <Cale> similarly, Strings get quoted
18:21:30 <Cale> Guspaz: If you write a function to flatten the tree out separately, then both ways are easy.
18:25:26 <twanvl> Cale: this second attempt seems to work better
18:27:25 <Guspaz> Trying to build a list first gives the error "Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `treeToList'", which I'm not even sure what that means.
18:28:31 <Guspaz> From the code: http://hpaste.org/11346
18:33:04 <Asztal> Guspaz: the first : should probably be a ++
18:33:05 <yaru1022> hello haskellers
18:35:44 <Asztal> @src Data.Tree.flatten
18:35:44 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:35:49 <Asztal> :(
18:36:38 <yaru1022> I'm trying to do an assignment with Haskell, but I don't know what data I should define. I basically need to have a function (it would make more sense if I call it a look up table) f(X1, X2, X3, ..., Xk) that returns a probability given an assignment to those variables (e.g. X1=true, X2=buy, X3=car, ..., Xk=computer). Is there any suggestion?
18:36:56 <Guspaz> ++ produces the same error. Stupid professor's example code ALSO produces the same error. How am I to learn this when we're given invalid examples. Ugh.
18:37:05 <ivanm> why is there a version 1.4.4 of X11 on hackage, when the darcs src only has version 1.4.3?
18:37:42 <Eiler> anyone know if visual haskell works in VS 2008? and the express editions?
18:38:27 <ivanm> yaru1022: pattern matching?
18:38:54 <ivanm> f True False = 0.1, f True True = 0.2, etc.
18:40:05 <yaru1022> ivanm: but I need to make it so that it can have varying number of variables
18:40:09 <Asztal> Guspaz: hmm, what about "treeToList lst ++ (l : treeToList rst)"?
18:40:14 <ivanm> ummmmmm......... use a list then
18:40:20 <Samy> Guspaz, could we have a URL to your course's webpage?
18:40:32 <yaru1022> and later on, I need to make "product" function that accepts those two functions and produce another function
18:40:34 <ivanm> since that's pretty much the only data structure that supports a varying number of items
18:40:46 <Asztal> the problem is that : takes a single element on the left hand side, and a list on the right
18:40:51 <ivanm> note that all the values inside the list need to have the same type though
18:41:35 <mm_freak> what is more correct?  "typeclass" or "type class"?  i'd bet on the latter
18:41:55 <mm_freak> or even "type-class"?
18:42:16 <ivanm> with the hyphen would be my guess
18:43:52 <mm_freak> but it's a "gun holster", not a "gun-holster", isn't it?
18:44:26 <Guspaz> Samy: The professor, he doesn't use computers. At all.
18:44:31 <Riastradh> I always write `type class' or just `class'.
18:44:35 <sjanssen> ivanm: good question, you should ping dons about it
18:44:49 <ivanm> @ask dons why is there a version 1.4.4 of X11 on hackage, when the darcs src only has version 1.4.3?
18:44:49 <lambdabot> Consider it noted.
18:44:54 <ivanm> sjanssen: done
18:46:10 <mm_freak> i'll write "type class" for now
18:49:04 <blbrown> general question; if I have some haskell code that has a copyright (Copyright 2006 - Developer Name) and then the copyright message; if I change that code a lot...do I still have to keep the copyright message as is?
18:49:44 <ddarius> What does the license say?
18:49:44 <ivanm> blbrown: depends on the license
18:50:07 <ivanm> blbrown: all the BSD-based ones say you have to state that the original code was under that license
18:50:24 <blbrown> it is a new bsd license, http://www.opensource.org/licenses/bsd-license.php
18:50:25 <lambdabot> Title: Open Source Initiative OSI - The BSD License:Licensing | Open Source Initiative
18:51:06 <ivanm> blbrown: I'd say you have to state in your documentation that it's based off code by Foo under the BSD-3 licence
18:51:19 <ivanm> but then you can change the haddock copyright to your own
18:51:23 <ivanm> or else include both
18:53:44 <blbrown> gracias, sorry for straying off-topic
18:54:37 <blbrown> I guess it is easy to apologize after I got what I wanted
19:00:36 * adu <3 ByteString
19:01:05 <adu> I want to make bytestring parsers for everything
19:02:20 <adu> ByteString -> PNG, ByteString -> MPEG, ByteString -> DVD
19:02:27 <adu> the possibilities are endless :)
19:04:05 <shapr> Sounds like fun, how many already exist?
19:05:21 <adu> well, I just wrote one for the first block of UDF...
19:05:53 <adu> thats like 1% of ByteString -> DVD
19:06:06 <shapr> nifty!
19:07:09 <dancor> i can't tell from http://www.haskell.org/ghc/dist/stable/dist/6.10.1-rc-1/rc.html etc; what is the best source for ghc 6.10.1 with the -thread bug fixed?
19:07:09 <lambdabot> Title: GHC 6.10.1 RC 1
19:07:32 <dancor> i bet i can find 6.10 nightlies
19:09:04 <dancor> i'm terrible at finding things.  i guess i'll just try http://darcs.haskell.org/ghc-6.10/
19:09:09 <lambdabot> Title: Index of /ghc-6.10
19:11:24 <roconnor> @type maxbound
19:11:25 <lambdabot> Not in scope: `maxbound'
19:11:28 <roconnor> @type maxBound
19:11:29 <lambdabot> forall a. (Bounded a) => a
19:12:24 <lispy> if you have multiple executable sections cabal installs each?
19:13:16 * roconnor yawns
19:13:20 <roconnor> documenting is no fun
19:13:33 <roconnor> at least haddock is pleasent
19:13:36 <lispy> watcha documenting?
19:13:44 <dancor> the 6.10 branch is only darcs and not git?
19:13:47 <roconnor> lispy: my colour-0.0.0 lib
19:13:48 <lispy> I hear people say both things about haddock
19:13:53 <lispy> roconnor: oh night
19:14:11 <lispy> dancor: there was an unofficial git mirror.  I don't know what the official status is these days.
19:14:14 <dolio> What do colors have to do with constructive mathematics, anyway?
19:14:24 <lispy> roconnor: er, right I meant
19:14:26 <roconnor> dolio: computer graphics is my other passion
19:14:33 <ddarius> You need colors to color a graph.
19:14:35 <dolio> :)
19:14:58 <dancor> ok looks like serious git switchery isn't until after 6.10  http://www.haskell.org/pipermail/libraries/2008-September/010661.html
19:15:00 <lambdabot> Title: GHC version control, http://tinyurl.com/5kt53n
19:15:10 <roconnor> ... actually it all started because I wanted to use X11 colour names in my haskell code.
19:15:21 <lispy> roconnor: hah!
19:15:22 <roconnor> ... so I needed a module with colour names
19:15:28 <roconnor> ... so I needed a colour package
19:15:31 <lispy> X11 defines a lot of nice colors
19:15:45 <roconnor> ... so colour-0.0.0 was born
19:15:46 <lispy> ISTR enjoying thistle
19:16:12 * lispy notes how the world is, in fact, a better place
19:16:18 <lispy> lambda for all!
19:16:29 <lispy> even colorful folks
19:16:32 <roconnor> colour names need sRGB, which needs ITU-R Recommendation BT.709, which needs CIE ...
19:16:58 <roconnor> might as well throw in L*a*b* and L*u*v* while I'm at it
19:21:25 <lispy> the free people of middle earth thank!
19:21:33 <lispy> thank you, rather
19:23:16 <shapr> adu: Is your source online?
19:23:45 <adu> nope, you want me to post it?
19:24:25 <shapr> sure!
19:25:48 <adu> shapr: http://hpaste.org/11347
19:25:57 <adu> thats just the general parts
19:26:06 <adu> the UDF-specific stuff is boring
19:27:43 <shapr> cool!
19:27:54 <nicknull> anyone working on image-recognition?
19:29:45 <shapr> nicknull: Are you?
19:30:02 <shapr> nicknull: I've heard of FVision
19:30:33 <shapr> nicknull: http://portal.acm.org/citation.cfm?id=645771.758166
19:30:44 <lambdabot> Title: FVision
19:31:52 <ddarius> http://alberrto.googlepages.com/easyvision
19:31:52 <lambdabot> Title: - easyVision
19:35:03 <nicknull> is haskell suited for hardcore numerical computing?
19:35:16 <nicknull> like i normally prototype in python
19:35:20 <Pseudonym> It depends how hardcore you're talking about.
19:35:37 <nicknull> but most image processing seems to be done in c c++
19:35:40 <Pseudonym> If your program's bottleneck is that BLAS isn't fast enough, then probably not.  Or, at least, not yet.
19:35:40 <nicknull> for speed
19:35:52 <nicknull> is haskell as fast as C++ for such things?
19:36:21 <Samy> ivanm, traditionally you prefex your copyright, as well.
19:36:39 <Samy> ivanm, sounds kind of strange, but I've been required to do this for some projects.
19:36:43 <Pseudonym> Some people do image processing in Haskell.  They tend to call out to C libraries and write the more semantic stuff in Haskell.
19:36:57 <Samy> err, sorry
19:37:09 <shapr> My standard answer is that Haskell code is unlikely to execute as quickly as C++ code, but you can develop Haskell code in much less time.
19:37:10 <Samy> blbrown, those comments to ivanm were directed to you (assuming BSD-license)
19:37:13 <lispy> nicknull: it really depends on how you define things.  Take a look at the programming language shootout: http://shootout.alioth.debian.org/
19:37:14 <lambdabot> Title: The Computer Language Benchmarks Game
19:37:33 <Pseudonym> When we have full data parallelism, I thin kthe game will change a bit.
19:37:40 <shapr> Yeah, I'm looking forward to that.
19:38:10 <Pseudonym> It still won't be as fast as hand-optimised BLAS, but on multicore machines, it might be easier to write faster code.
19:38:32 <shapr> I'd like to get NDP working for the Cell cpu.
19:38:38 <Pseudonym> Or, I guess, code that completes earlier.
19:39:30 <Pseudonym> One more thing.  If GHC's single-precision Floats are still as slow as they've always been, then I wouldn't bet on usig those.
19:39:47 <Pseudonym> That can be important in some applications.
19:39:56 <nicknull> which of those reflect numerical computations?
19:39:58 <lispy> Don't you need to be in the rounding monad to use floats anyway ;)
19:40:08 <Samy> shapr, NDP?
19:40:17 <Pseudonym> nicknull: "Numeric programming" is a _huge_ area.
19:40:24 <nicknull> yes
19:40:36 <Pseudonym> So your question didn't have a simple answer.
19:41:07 <Pseudonym> But FWIW, saying that "numeric code is written in C or C++" is also not entirely accurate.
19:41:12 <nicknull> but linear algebra, computing eigenvectors and so ob
19:41:15 <nicknull> fortran
19:41:18 <Samy> ah, that ndp
19:41:28 <Pseudonym> Really fast numeric code galls out to BLAS, which is often written partly in assembler.
19:41:32 <Pseudonym> calls
19:41:35 <nicknull> but for me it would be c or c++
19:41:38 <nicknull> ah ok'
19:41:42 <shapr> Samy: Nested data parallelism
19:41:44 <Samy> Mitrionics developed BLAS cores for FPGAs.
19:41:52 <Pseudonym> Right, there you go.
19:42:13 <Pseudonym> So if you're doing, like, weather simulations, chances are that most of the runtime isn't spent in C, C++ or even Fortran.
19:42:28 <Pseudonym> But in some library that's shipped with the hardware.
19:42:32 <lispy> ah, Fortran
19:42:56 <nicknull> also intersting since it is embarassingly parallell
19:43:09 <Samy> Most weather simulations things I've seen was written in Fortran.
19:43:14 <Samy> Almost completely.
19:43:23 <mightybyte> Is Chris Eidhof ever in this channel?
19:43:26 <Pseudonym> Yes.  Most weather simulations things are legacy code.
19:43:30 <Samy> :(
19:43:46 <Samy> nicknull, what is embarassingly parallel?
19:43:50 <Pseudonym> But even in those cases, they spend a lot of time calling out to hand-optimised BLAS routines.
19:43:59 <nicknull> so you think haskells advantage will grow with multicores because it will be much easier to program code that can run on mutltiple cores? i mean will it be orders of magnitude easier? and since haskell-code is also safer... could it take over int he numeric computing business?
19:44:16 <Samy> Referential transparency is a big win, imho
19:44:33 <Pseudonym> I doubt that Haskell will ever take over the numeric computing business.  There's still too much legacy code in Fortran, and specialised tools like Fortress.
19:44:54 <lispy> nicknull: we can only speculate.  But, I have a hunch there will be a strong pull to keep going with the current trends even when they are hard to apply.  People change slowy after all.
19:44:56 <Samy> Even for HPC applications that mostly offload computations (FPGAs, GPUs, whatever) a functional language would allow you to easily construct arbitrary pipelines
19:45:01 <Pseudonym> I do see Haskell as part of the landscape, though.
19:45:07 <Samy> MS is also investing in this direction, but they haven't made a public release yet
19:45:25 <Samy> "Stream Framework" or something
19:47:43 <Pseudonym> I think where you'll find Haskell more useful is in other areas of scientific computing.
19:47:46 <lispy> are you guys familiar with "witness type" terminology?
19:47:53 <Pseudonym> Symbolic stuff.
19:48:11 <lispy> The definitions I found said that values act as evidence.  But, here in the stuff I use it for, the type themselves act as the evidence
19:48:27 <lispy> Is this still consistent with how you think of type witnesses?
19:48:39 <lispy> Or rather, we're using type witnesses instead of witness types?
19:50:25 <adu> i think BLAS should be reimplemented in Haskell
19:50:43 <lispy> BLAS is a standard right?
19:50:49 <adu> lispy: nope
19:51:05 <adu> lispy: BLAS is a bunch of linear algebra subprograms
19:51:07 <lispy> ah, i thought there were different implementations of it
19:51:40 <adu> nope, its pretty much a Fortran project that dozens of ppl write bindings to
19:52:07 <nicknull> i think haskell should be reimplemented in blas
19:52:22 <adu> lol
19:52:58 <nicknull> how are types and state related? is it possible to have type-inference in a stateful/OO-lang? it must be right? scala has ot to some degree(not a satisfying degree though)
19:53:37 <adu> nicknull: could you be more specific?
19:54:25 <adu> nicknull: also, you may be interested in Disciple, a variant of Haskell with explicit state typing... or something
19:54:50 <adu> nicknull: well, F# did it... i think
19:55:59 <lispy> explicit state typing?  like uniqueness types?  Are you thinking of Clean?
19:56:28 <lispy> nicknull: you can apply Haskell's type system to a stateful language
19:56:51 <adu> lispy: i don't know uniqueness types
19:56:52 <lispy> and yes, Scala is one possible outcome
19:57:40 <lispy> There are some people here who really like scala and could explain why it's a cool language.
19:57:52 <Samy> Why did Clean decide to use uniqueness types rather than Monads for things like I/O?
19:57:57 <adu> lispy: why is it so cool?
19:58:00 <lispy> I used it for a course project and I wasn't very impressed due to the bugs I was hitting in the implementation
19:58:08 <adu> what are uniqueness types?
19:58:27 <lispy> http://clean.cs.ru.nl/About_Clean/Clean_Language_Features/clean_language_features.html
19:58:29 <lambdabot> Title: Language Features, http://tinyurl.com/5lxhuc
19:58:45 <Samy> adu, http://en.wikipedia.org/wiki/Uniqueness_type
19:58:47 <lambdabot> Title: Uniqueness type - Wikipedia, the free encyclopedia
19:58:52 <lispy> Samy: I tihnk because then monads weren't needed
19:58:58 <lispy> Samy: the language could stay pure
19:59:14 <wy> I need one more example of type unsoundness in a real language, but obviously it's trivial to list C's typing... I may need a stronger one. Any ideas?
19:59:36 <Elly> wy: how about Java or Python?
19:59:47 <lispy> wy: in ghci: unsafeCoerce 1.01 :: String
19:59:53 <wy> Elly: I found one example of Java arrays
19:59:58 <Elly> in python '1 + "a"' generates a type error at runtime
20:00:02 <Samy> lispy, I don't understand. "Because then monads weren't needed" -> "the language could stay pure"?
20:00:05 <Elly> wy: or just arbitrary casting in java :P
20:00:35 <lispy> Samy: I don't know much about clean, but that page I pulled up said that uniqueness typing makes it so that you can do IO and whatnot in pure land
20:00:44 <Samy> lispy, nod
20:00:51 <Samy> lispy, but why this rather than Monads?
20:01:05 <lispy> Samy: not everyone likes Monads?
20:01:09 <lispy> Samy: I don't know
20:01:12 <Samy> I figured so :-)
20:01:24 <shapr> Actually, uniqueness typing lets you do safe mutation in place.
20:01:38 <Samy> ahhhh
20:01:41 <Samy> ok
20:01:43 <thoughtpolice> right, linear types
20:01:45 <Samy> That's nice
20:02:07 <wy> Elly: Can you do that in Java?
20:02:32 <dibblego> Elly, no it is not arbitrary
20:02:36 <nicknull> hmm discipl seems cool, i have a hard time with nondestructive updates on datastructs
20:02:48 <Elly> you can't just do an arbitrary cast in java?
20:02:52 <thoughtpolice> Samy: check out the paper 'uniqueness typing simplified'
20:03:00 <thoughtpolice> talks about adding uniqueness typing to a small language
20:03:03 <Elly> A a = (A)((Object)b); doesn't work?
20:03:11 <Elly> (at compiletime, anyway :P)
20:03:12 <lispy> Actually, casting and run-time exceptions are not supposed to be considered type unsoundness
20:03:16 <nicknull> damn everytime i jum into #haskell i get a lot of sutff ony my mind :) it s to interesting to learn haskell to actually do something :)
20:03:34 <lispy> Not in the real definition (or so I was told by my programming language prof when I brought them up)
20:03:35 <dibblego> yes, that works
20:03:36 <Samy> nicknull, yes, it's a problem :-)
20:03:52 <wy> Elly: It works! I didn't cast to Object first...
20:04:16 <nicknull> hmm, would it be hard to write a parser/typechecker for python in haskell?
20:04:32 <lispy> nicknull: parser no, typechecker yes
20:04:37 <dibblego> wy, an example, a Java byte cannot be assigned a value above 127, but it can be compared against any value less than 255 (this is specific to byte)
20:04:51 <adu> shapr: interesting
20:04:58 <dancor> nicknull: recently i've completed about one practical project a week, tho i'm probably doing everything wrong bc of neglecting all the theoretical concerns i should be paying more attention to and discussing in #haskell
20:05:51 <wy> dibblego: I'm done with Java... hehe
20:06:09 <Cale> lispy: That seems like a matter of opinion...
20:06:18 <lispy> nicknull: people have tried to write static analysis tools for python.  The most successful approach used a restricted dialect of python and left everything else unanalyzed
20:06:24 <Cale> (the bit about casts not being type unsoundness...)
20:06:49 <nicknull> lispy: but couldnt i just write: *variable has been used with  *these operators and then check against a Map that contains operators and the values they opeatr on
20:06:50 <wy> Cale: why not?
20:06:58 <lispy> Cale: Yeah, the cast bit seems odd right?  But the reasoning was that a cast is an explicit programming language feature.
20:07:11 * dancor heard erlang has advanced static analysis stuff that yells at you if it can't figure out your dynamicness
20:07:36 <Cale> I can understand measuring the type soundness of Java without casts. But Java with casts is unsound.
20:08:01 <dolio> A value of one type being treated as a value of another (non-parent) type is, like, the definition of unsoundness, is it not?
20:08:30 <dolio> Although, one could argue that in Java, it just causes an exception, unlike in, say, C.
20:08:31 <bd_> dolio: The types you use to declare variables are actually class constraints, perhaps?
20:08:35 <Samy> class exception
20:08:56 <lispy> But, are run-time exceptions really unsound?
20:09:04 <bd_> it's no more unsound than Dynamic really
20:09:17 <shapr> lispy: Starkiller was pretty cool.
20:09:25 <nicknull> dancor: u a student?
20:09:31 <lispy> I think of the classic example of C unsafety is that you go on about a computation not even realizing your mishandling the types.  No exceptions, no warnings, just undefined behavior.
20:09:34 <shapr> lispy: That did type inferencing based on the Self research that became the HotSpot VM.
20:09:44 <dolio> Yeah, that bad casts in Java result in runtime exceptions makes it arguable.
20:10:07 <qwr> but is this an example type unsoundness? http://linux.ee/~mzz/Unsound.java
20:10:10 <nicknull> a cast is: int(4.56634) right?
20:10:22 <wy> Cale: Java has one unsoundness I knew of. About arrays
20:10:25 <dibblego> nicknull, no that's unsound Java syntax
20:10:31 <dancor> nicknull: no, this is all after-work
20:10:31 <nicknull> its python
20:10:42 <qwr> i got quite intresting result running it with jdk1.6 :P
20:10:51 <qwr> jvm core dump...
20:11:09 <qwr> didn't expect it really to work so well :)
20:12:02 <Valodim> the results being?
20:12:14 <wy> qwr: Oh... This one is interesting
20:12:31 <dibblego> a core dump is because javac is a big pile of steaming poop
20:12:39 <nicknull> haskell has checkec explicit typecasting right?
20:12:48 <nicknull> and c has uncheck implicit?
20:13:06 <qwr> dibblego: no, javac was all happy. jvm died later when running the .class file generated ;)
20:14:37 <wy> qwr: Haha. Where did you get this?
20:14:50 <qwr> wy: thought up now
20:15:07 <qwr> wy: as what could make jvm unhappy... and tried it...
20:15:09 <dolio> qwr: What exactly does that code do?
20:15:11 <dibblego> qwr, because javac is a big steaming pile of poop
20:15:22 <wy> qwr: I also found one for scala. Is reflection naturally unsound?
20:15:38 <qwr> dolio: changes "immutable" string which happens to be used by java interpretator internally
20:15:51 <dolio> Heh.
20:16:26 <wy> qwr: Can you do more damage...? Say put it into a website?
20:16:31 <yaru1022> Can anyone advise me on the problem I'm working on? I'd like to program something I learned in an Introduction to AI course... but I have no idea how to even start...
20:16:38 <wy> Can that crash a browser?
20:16:39 <Valodim> into an applet, haha
20:16:41 <dibblego> wy, http://jqa.tmorris.net/
20:16:43 <lambdabot> Title: Java Questions and Answers
20:16:55 <dibblego> wy, sorry I misread your question
20:17:00 <Valodim> no I think reflection are part of the restricted functions :)
20:17:08 <qwr> wy: i don't know. brauser sandbox hopefully disables the setAccessible call
20:17:16 <dibblego> no you can't run that code in an unsigned applet
20:18:44 <nicknull> yaru: shoot
20:19:05 <qwr> s/brauser/browser/
20:19:10 <yaru1022> http://www.student.cs.uwaterloo.ca/%7Ecs486/slides/Lecture9.pdf
20:19:11 <lambdabot> Title: Microsoft PowerPoint - Lecture9
20:19:22 <yaru1022> slide 11 to 14...
20:19:25 <mdmkolbe> Evening all, I saw it claimed somewhere that HM inference is unsound in the presence of mutable refs.  Since (IIUC) Haskell uses a modified HM and has IORef, does Haskell have the same problem?
20:19:48 <yaru1022> I'm not sure if I should use class or data, etc.
20:20:40 <yaru1022> In order to get the product of two factors, I have to know what common variables there are between the two factors and multiply accordingly. Is it easily doable in Haskell? or something that would take a long time to do?
20:20:48 <wy> Any other cases, except those about Java? Is ML sound?
20:20:52 <qwr> wy: i think that reflection don't have to be unsound. jvm just don't enforce it's type system really by default
20:20:54 <roconnor> mdmkolbe: I think the unsoundness is only due to a misunderstanding of how to handle polymorphism in IORefs.
20:21:09 <qwr> s/don't have to be/has to be/
20:21:09 <nicknull> yaru: sounds easy if u know haskell
20:21:25 <qwr> damn. to sleepy
20:21:29 <roconnor> mdmkolbe: and I vaguely recall that Haskell gets this right.
20:21:41 <yaru1022> nicknull: is it? could you guide me a bit so I can get the feeling of it?
20:22:05 <roconnor> mdmkolbe: IORef a should really be seen as forall a. IORef a .. that is a dependent function from Types to IORefs
20:22:06 <nicknull> do you knw before hand the possible types?
20:22:07 <yaru1022> nicknull: I thought it would be straightforward, but once I started it, I'm puzzled :(
20:22:19 <yaru1022> nicknull: not really...
20:22:22 <nicknull> or how many?
20:22:39 <yaru1022> oh possible types?
20:22:40 <yaru1022> hm...
20:22:44 <roconnor> mdmkolbe: once polymorphic IORefs are seens as functions instead of static, all the problems go away. ... execpt you may find yourself without the behaviour you expect.
20:22:51 <yaru1022> nicknull: there are 6 of them
20:22:53 <yaru1022> 6 variables
20:23:00 <yaru1022> they are just binary variable
20:23:05 <roconnor> mdmkolbe: but take what I am saying with a grain of salt.  I haven't studied the issue.
20:23:32 <qwr> wy: I think ML can be. Ocaml isn't - marshall module.
20:23:41 <mdmkolbe> hmm, any suggestions on where to find classic examples of unsoundness (the best I could find were a few newsgroup postings)?
20:24:57 <yaru1022> nicknull: let's call the variables O, P, Q, R, S, T and each has only two values (i.e. o or not o, p or not p, q or not q, r or not r, etc.)
20:25:36 <yaru1022> then should I define that as data P = P | NotP
20:25:39 <dmwit_> mdmkolbe: Haskell is unsound already because it has fix:
20:25:40 <dmwit_> :t fix
20:25:41 <yaru1022> like that?
20:25:42 <lambdabot> forall a. (a -> a) -> a
20:26:34 <ajdhs> I have a question about the new exception modules
20:26:37 <mdmkolbe> dmwit_: how does that make it unsound?
20:26:44 <dmwit_> mdmkolbe: IORef's (+unsafePerformIO) are just icing on the cake.
20:26:51 <dmwit_> mdmkolbe: Because any proposition is provable.
20:27:02 <dmwit_> :t fix id
20:27:03 <lambdabot> forall a. a
20:27:16 <nicknull> what is the type of list?
20:27:20 <nicknull> :: List fails
20:27:27 <dmwit_> nicknull: [a]
20:27:40 <mdmkolbe> dmwit_: Kyle? Is that you?  ok, that makes it unsound as a logic, but as a type system that doesn't make it unsound (again IIUC)
20:27:43 <ajdhs> if one wanted to catch only "does not exist" IOErrors, are they still supposed to use the isDoesNotExistError predicate?
20:27:49 <ajdhs> or is there a better way?
20:27:56 <dmwit_> mdmkolbe: Ah, you're right.
20:28:05 <dmwit_> mdmkolbe: I thought you were talking about logical unsoundness.
20:28:19 <dmwit_> mdmkolbe: Also, I have no idea who Kyle is. =P
20:28:28 <nicknull> dmwit: { a :: [a], b :: [a] }
20:28:31 <nicknull> doesnt work
20:28:51 <dmwit_> nicknull: If you're making a record, you still need a constructor.
20:29:00 <nicknull> i have
20:29:02 <dmwit_> data Foo a = Foo { a :: [a], b :: [a] } -- this will work
20:29:11 <Samy> How is everything provable from (a -> a) -> a?
20:29:25 <dmwit_> :t fix id
20:29:26 <lambdabot> forall a. a
20:29:31 <dmwit_> Samy: id :: a -> a
20:30:02 <mdmkolbe> Samy: he's basically saying that you can produce a term (i.e. proof) for any type (i.e. proposition)
20:30:29 <Samy> But how does it make it unsound as a logic, mdmkolbe?
20:30:34 <qwr> wy: ocaml crash example: Marshal.from_string (Marshal.to_string 0 []) 0 ();;
20:30:36 <wy> mdmkolbe: hey :)
20:30:44 <Samy> mdmkolbe, do you consider classical logic to be "unsound"?
20:30:48 <dmwit_> Samy: You can treat types as propositions, and terms as proofs of the proposition.
20:30:51 <qwr> wy: this "casts" 0 to function
20:30:52 <nicknull> dmwit_:how would ic all that?
20:30:56 <mdmkolbe> Samy: do you know the curry howard isomorphism?
20:31:06 <shapr> ooh ooh I know it!
20:31:09 <dmwit_> nicknull: You don't call it, it's a data type. (?)
20:31:09 <Samy> mux told me about it.
20:31:10 <nicknull> wait lol
20:31:12 * shapr raises his hand
20:31:20 <Samy> mdmkolbe, no
20:31:51 <shapr> Hm, does the Curry-Howard isomorphism have something to do with Prawitz?
20:32:08 <mdmkolbe> Samy: basically what dmwit_ said, if you can construct a program for a type, then that program is also a proof for a proposition
20:32:17 <nicknull> yaru: why not 0 or 1?
20:32:18 <roconnor> does HackageDB require a LICENCE file in my package?
20:32:25 <mdmkolbe> Samy: if you can prove anything, then the system is unsound
20:32:35 <shapr> Russell-Prawitz?
20:32:37 <shapr> bah, whatever
20:32:49 <dmwit_> Samy: Things like "(:) :: a -> [a] -> [a]" are taken as axioms.
20:33:00 <yaru1022> nicknull, for the value? yeah sure that would work too. True or False, 0 or 1. It doesn't matter...
20:33:18 <yaru1022> nicknull, but the thing is factors might have different number of variables
20:33:22 <mdmkolbe> Samy: example, prove that "A & (A -> B) -> B" can be done by the term with type (A, A -> B) -> B.
20:33:51 <yaru1022> nicknull: first factor could be f1(X, Y, Z) and the second factor could be f2(Y, Q)
20:34:33 <yaru1022> nicknull: and I have to produce the third factor f3(Q, X, Y, Z) which multiplies f1 and f2 appropriately (like the one you see in the lecture note)
20:34:36 <mdmkolbe> Samy: However, in haskell you can construct terms that have any type you want.  Thus if you used it as a logic, your logic could "prove" anything even false things.  Thus it is unsound (as a logic, not to be confused with type soundness).
20:35:23 <Samy> mdmkolbe, ok. So according to this definition, "classical logic" is unsound (under a natural deduction system with production rules using RAA)?
20:35:53 <dmwit_> Samy: Errr, why would that make classical logic unsound?
20:36:07 <dmwit_> Samy: Can you prove False?
20:36:08 <mdmkolbe> Samy: no, Haskell is unsound.  Classical logic would not accept all the programs Haskell would
20:36:10 <Samy> Because "anything can be proven".
20:36:19 <Samy> dmwit_, yes.
20:36:26 * dmwit_ blinks
20:36:32 <mdmkolbe> Samy: what is "RAA"?
20:36:32 <dmwit_> Not in the classical logic *I* know.
20:36:45 <Samy> dmwit_, P -> P.
20:36:49 <Samy> dmwit_, yes, technically, I can't.
20:36:57 <Samy> But you could fix an interpretation.
20:37:02 <Samy> P -> P is an axiom
20:37:08 <Samy> mdmkolbe, reductio ad absurdum
20:37:12 <dmwit_> P -> P is not false.
20:37:23 <wy> :t fix id
20:37:24 <lambdabot> forall a. a
20:37:32 <DGMurdockIII> dose anyone now any free software that can turn a pocket pc in to a remote for a tv?
20:37:33 <DGMurdockIII> hi
20:37:39 <Samy> dmwit_, but P is atomic
20:37:39 <wy> What's wrong here?
20:37:46 <dmwit_> Samy: So?
20:37:52 <mdmkolbe> DGMurdockIII: wrong IRC channel?
20:38:00 <DGMurdockIII> oh
20:38:09 <dmwit_> Samy: P -> P is True for all values of P, so it should be no surprise that you can prove P -> P.
20:38:32 <Samy> Yes.
20:38:58 <dmwit_> I think maybe you are confused about what "anything can be proven" means.
20:39:02 <Samy> Yes.
20:39:03 <Samy> haha
20:39:25 <dmwit_> (The actual definition of unsoundness is just, "False can be proven.".)
20:39:35 <Samy> ahhhhhhh
20:39:36 <Samy> Ok
20:39:46 <dmwit_> But since most systems take (False -> a) as an axiom, it follows then that "anything can be proven".
20:39:48 <Samy> Now it clicked :-) (connections with id)
20:39:50 <nicknull> what is bc~ and b~c, what is the diff?
20:39:58 <wy> What's wrong with fix id :: forall a.a?
20:39:59 <dmwit_> nicknull: context?
20:40:05 <dmwit_> wy: It's bottom.
20:40:08 <Samy> thanks
20:40:21 <dmwit_> wy: What do you mean by "wrong"?
20:40:22 <wy> dmwit_: So what's wrong with that?
20:40:37 <wy> dmwit_: You gave this as an example of unsoundness?
20:40:55 <mdmkolbe> wy: in a logic "forall a. a" can be instantiated with "a=False" to prove "False.
20:41:27 * Samy has really only looked at unsoundness only in the context of a proof within a formal system (and not of the system)
20:42:18 <dolio> It's not unsoundness, it's inconsistency.
20:42:34 <wy> mdmkolbe: That's weird. So that's why fix is called paradoxical?
20:42:37 <mdmkolbe> dolio: no, it's not insonsistency, it's invalidity
20:42:50 <Samy> Yes, invalidity.
20:43:04 <dmwit_> No, it's not invalid, it's unsound. ;-)
20:43:08 * dmwit_ completes the circle
20:43:15 <Samy> But for a sound argument if A |- B then A -> B
20:43:30 <yaru1022> nicknull: b~c means B = True and C = False
20:43:46 <Samy> An argument could still be contingent (which isn't valid)
20:44:04 <dolio> Anyhow, it makes the type system less attractive as a proof system.
20:44:06 <mdmkolbe> dolio: valid = always true, inconsistent = can never be true.  A -> B is true if A = B and false if A != B (in a boolean logic) thus it is nether valid nor inconsistent
20:44:35 <Samy> mdmkolbe, some people say valid = true under certain conditions, sound = always true
20:44:49 <yaru1022> nicknull: so when you multiply f(A,B) and g(B,C), in order to calculate h(a,b,c), you do f(a,b) * g(b,c)
20:44:50 <mdmkolbe> err ... I think I messed up that example
20:44:53 <mdmkolbe> but you get the idea
20:45:05 <Samy> Atleast tomassi makes this distinction
20:45:18 <yaru1022> nicknull: similarly, h(a, ~b, c) = f(a,~b) * g(~b,c)
20:45:27 <mdmkolbe> Samy: I'll see your tommasi and raise you a quine
20:45:28 <Samy> inconsistency is a semantic thing
20:45:35 <Samy> mdmkolbe, haha
20:45:37 <wy> Where is fix? I can't find it in my ghc
20:45:43 <mdmkolbe> @index fix
20:45:43 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
20:45:49 <mdmkolbe> @src fix
20:45:49 <lambdabot> fix f = let x = f x in x
20:46:12 <dolio> fix should be in Data.Function, too.
20:46:24 <mdmkolbe> fix f = f (fix f) <-- "broken" un-optimized version
20:47:11 <dmwit_> dolio: it is
20:47:37 <dolio> That's what I meant, actually. :)
20:48:13 <dolio> I like to phrase things noncommittally
20:48:36 <dmwit> oh, heh
20:49:29 <BMeph> dolio: s/should be/should be listed as being/ ? :)
20:50:18 <dolio> @vera should
20:50:19 <lambdabot> No match for "should".
20:50:35 <dolio> @list dict
20:50:35 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:50:49 <dolio> @dict should
20:50:49 <lambdabot> Supported dictionary-lookup commands:
20:50:50 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:50:50 <lambdabot> Use "dict-help [cmd...]" for more.
20:50:56 <dolio> Hmmm.
20:51:03 <nicknull> what is the type of Data.Map?
20:51:06 <nicknull> data Fact a = Fact { vars_ :: M.Map k a1 }
20:51:19 <dolio> Anyhow, "2. (auxiliary) will likely (become or do something)"
20:51:39 <dmwit> nicknull: uh?  Data.Map is a module, it doesn't make sense to ask what its type is.
20:52:07 <yaru1022> nicknull, did you mean data Map k a?
20:52:32 <nicknull> so eahc variable can only be true or false or in other word s0 or 1
20:52:47 <nicknull> and you can have shifting amoutn of variables
20:53:01 <yaru1022> nicknull: oh.. i c
20:53:56 <nicknull> it was a question actually :)
20:54:30 <nicknull> Fact { vars_ :: M.Map k a1 }
20:54:38 <nicknull> how do declare the type of vars_?
20:54:40 <dmwit> nicknull: I'd love to help you, but you're not making a whole load of sense.
20:54:42 <nicknull> if itis a Map?
20:54:44 <sclv> vars_ is a type
20:54:53 <dmwit> nicknull: vars_ already has a type declaration there.
20:54:55 <sclv> Map is a type.
20:55:02 <dmwit> It's the (:: M.Map k a1) bit.
20:55:13 <sclv> it has a kind of * -> * -> *
20:55:14 <dmwit> M.Map k a1 is a type, don't listen to sclv.
20:55:19 <dmwit> ;-)
20:55:48 <sclv> Map k a1 is a fully applied type.
20:56:10 <sclv> so you can have Map Int String
20:56:14 <sclv> which associates numbers with strings
20:56:22 <sclv> or Map String  String which is a dictionary from strings to strings
20:56:23 <dmwit> nicknull: If you've made that definition yourself, probably the problem you're seeing is that 'k' isn't in scope on the RHS.
20:56:38 <sclv> or map String Int which will associate strings to numbers.
20:57:00 <dmwit> nicknull: All the type variables on the right-hand side need to appear once on the left-hand side.
20:57:09 <nicknull> Fact { vars_ :: M.Map (Var a) Int }
20:57:19 <dmwit> that's better =)
20:57:34 <dmwit> nicknull: There's one more caveat: vars_ actually has kind of a weird type.
20:57:49 <dmwit> In some cases, it has type (vars_ :: Fact a -> M.Map (Var a) Int).
20:58:17 <dmwit> In other cases, it is just a bit of syntax telling which part of the record to update, and so doesn't really have a type, per se.
20:59:16 <nicknull> yaru: do the variables have the same type of values? like can they all be true/false only or they could be 1,2,3 or 12 or "hello"?
20:59:36 <yaru1022> for my case, it's only true/false...
20:59:38 <roconnor> I think I'm ready to try to upload to hackage.
21:01:07 <wy> The definition fix f = let x = f x in x looks weird. How this gets evaluated? for example: (fix (\f -> \x-> if x == 0 then 1 else x * (f (x-1)))) 10
21:02:18 <lispy> wy: you can expand it out
21:02:37 <wy> lispy: But it seems I stuck somewhere around laziness...
21:02:41 <sclv> ?fix (1:)
21:02:42 <lambdabot> Maybe you meant: bid faq ft id thx
21:02:44 <Nafai> Hmm
21:02:45 <sclv> > fix (1:)
21:02:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:02:53 <Nafai> I'm finding Learn You a Haskell pretty readable
21:02:55 <ddarius> @help bid
21:02:56 <lambdabot> bid symbols.  Sum up the bid and ask prices for symbols.
21:02:58 <lispy> wy: I mean, you can use the equations to expand it out
21:03:44 <sclv> fix (1:) = let x = 1 : x in x, for example
21:03:58 <lispy> wy: we have this identity, x = f x, x = f x = f (f x) = f (f (f x))
21:04:01 <sclv> or let ones = 1 : ones in ones
21:04:08 <sclv> which is pretty readable.
21:04:23 <lispy> wy: on the far right I keep replacing x with (f x)
21:04:30 <lispy> wy: see how that keeps expanding?
21:04:58 <lispy> wy: try that with your example
21:05:03 <wy> lispy: Hmmm... better now
21:05:08 <sclv> > fix (const 1)
21:05:10 <lambdabot>   1
21:05:46 <sclv> fix (const 1) = let x = (const 1 $ x) in x = let whocares = (const 1 $ whocares) in whocares
21:06:30 <wy> lispy: What I was looking for is this: "The evaluator wants the value of x, so it evaluates f x, then it found that it needs the value of x... and so on. Interesting
21:07:04 <mdmkolbe> wy: the "fix f = f (fix f)" version may be easier to see it with (the "let" is just there to avoid extra thunk creation)
21:07:15 <dmwit> wy: Yup, so it only works if 'f' gives some kind of constructor before demanding 'x'.
21:07:50 <lispy> dmwit: that makes it cototal, if I understand cototality correctly
21:08:10 <dmwit> Okay!
21:10:11 <wy> mdmkolbe: Interesting. It seems we can't do this in a typed CBV language?
21:10:16 <lispy> :t \f -> \x -> if x == 0 then 1 else x * (f (x-1))
21:10:17 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
21:10:19 <dmwit> lispy: That's pretty neat, but considering I learned my first words of category theory just this afternoon, I don't think I can really appreciate it. =P
21:10:34 <dmwit> wy: CBV?
21:10:43 <wy> call-by-value
21:10:44 <lispy> dmwit: I'm making it all up.  I don't know cat. theory.  I just read sigfpe's blog :)
21:10:57 <sclv> cototal meaning that it promises to produce forever?
21:11:03 <dmwit> wy: Ah, yes, call-by-value needs a different combinator.
21:11:14 <lispy> sclv: yes, that's my intuitive understanding
21:11:19 <sclv> > fix (const 1)
21:11:21 <lambdabot>   1
21:11:22 <mdmkolbe> wy: well, you can, but not with that particular operator
21:11:31 <wy> dmwit: Can that be defined, say, in ML?
21:11:33 <mdmkolbe> wy: see the CBV Y-combinator
21:11:38 <dmwit> wy: yes
21:11:51 <lispy> ?quote sigfpe
21:11:51 <lambdabot> sigfpe says: It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
21:11:54 <dmwit> wy: As mdmkolbe already suggested, the thing to search for is the y combinator. =)
21:11:57 <wy> mdmkolbe: But that Y...can't be typed...
21:12:04 <lispy> ?quote sigfpe
21:12:04 <lambdabot> sigfpe says: It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
21:12:16 <sclv> ?quote loeb
21:12:16 <lambdabot> No quotes match. Are you on drugs?
21:12:28 <lispy> ah well, I wanted the quote about the shirt that says everything I learned I learned from sigfpe
21:12:38 <ddarius> lispy, dmwit: That has nothing to do with category theory.
21:12:59 <mdmkolbe> wy: good point ... There's probably a way around it somehow
21:13:04 <sclv> ?remember loeb loeb x = fmap (\a -> a (loeb x)) x
21:13:04 <lambdabot> Nice!
21:13:32 <mdmkolbe> wy: if you have a "mu" type operator that allows you to express infinite types, you could probably type the Y-combinator
21:13:47 <lispy> mdmkolbe: yes, it works like hat in Haskell if ou want
21:13:53 <sclv> ?remember uncyclopedia Haskell has only one control structure. Its type signature is: pSwitch :: Functor col => (forall sf . (a -> col sf -> col (b, sf))) -> col (SF b c)-> SF (a, col c) (Event d) -> (col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
21:13:53 <lambdabot> It is forever etched in my memory.
21:13:58 <sclv> ?quote uncyclopedi
21:13:59 <lambdabot> No quotes match. Sorry.
21:14:03 <sclv> ?quote uncyclopedia
21:14:03 <lambdabot> uncyclopedia says: Haskell has only one control structure. Its type signature is: pSwitch :: Functor col => (forall sf . (a -> col sf -> col (b, sf))) -> col (SF b c)-> SF (a, col c) (Event d) -> (
21:14:03 <lambdabot> col (SF b c) -> d -> SF a (col c)) -> SF a (col c)
21:14:33 <lispy> :t fix $ \f -> \x -> if x == 0 then 1 else x * (f (x-1))
21:14:34 <lambdabot> forall a. (Num a) => a -> a
21:14:39 <wy> mdmkolbe: Then it has something to do with folding and unfolding?
21:14:57 <mdmkolbe> wy: folding and unfolding infinite types, yes
21:16:09 <lispy> The thing that makes my noodle hurt, given that factorial definition, is that we have some f ... (f x), but how does it know when to stop?
21:16:23 <ddarius> lispy: You don't stop.
21:16:30 <telexicon> when x == 0
21:16:34 <mdmkolbe> lispy: it stops when "f" stops calling it's argument
21:16:35 <telexicon> it stops
21:16:46 <lispy> telexicon: well, certainly
21:17:35 <mdmkolbe> wy: consider the type level equivalent of fix.  data Fix f = Mu (f (Fix f)).  Putting on or taking off that extra "Mu" constructor is (sort of) like folding or unfolding an infinite type.
21:17:51 <dmwit> lispy: Note that 'a' here has type (Integer -> Integer), meaning that (fix :: ((I -> I) -> (I -> I)) -> (I -> I)).
21:18:17 <dmwit> lispy: So we're actually constructing a *function*, and we're allowed to look at its argument!
21:18:24 <dmwit> lispy: You can also think of it this way:
21:18:53 <lispy> :t show
21:18:54 <lambdabot> forall a. (Show a) => a -> String
21:18:59 <lispy> :t fix
21:19:00 <lambdabot> forall a. (a -> a) -> a
21:19:01 <Nafai> So when you are using 'infixr' you are just defining a priority?
21:19:20 <dmwit> lispy: Given any approximation f of the factorial function (let's assume that f is correct for all values up to n), then I can construct a "better" approximation f' that is correct up to (n+1) pretty easily.
21:19:54 <dmwit> lispy: We then apply this approximation improvement function infinitely many times, so that the result is correct for all n.
21:20:02 <mdmkolbe> Nafai: yes, you're defining the associativity "infixr" vs "infixl" and precidence (what you called priority)
21:20:09 <lispy> oh, right a = Int -> Int.  Yes.
21:21:19 <Nafai> mdmkolbe: How do I find out the precendence of a given operator?  Is that defined in the standard?  Or can I query a given operator to find out?
21:21:32 <ddarius> Nafai: Yes.
21:21:46 <mdmkolbe> Nafai: :info on the operator should give it, it should also be defined somewhere
21:22:05 <Nafai> mdmkolbe: Thanks
21:22:39 <Nafai> What's the difference between right and left associative?
21:22:41 <lispy> > fix $ \s x -> 'a': s x $ show
21:22:42 <lambdabot>   Couldn't match expected type `a -> b'
21:24:05 <lispy> > (fix $ \s x -> 'a': s x) show
21:24:07 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:24:41 <mdmkolbe> Nafai: 1 + 2 + 3 + 4 means (((1 + 2) + 3) + 4 if it is left assoc (notice the parens are all to the left) and it means 1 + (2 + (3 + 4))) if it is right assoc (notice parens all to the right)
21:24:47 <nicknull> let l = M.lookup R fm
21:24:54 <nicknull> Ambiguous type variable `m' in the constraint:
21:24:54 <nicknull>       `Monad m'
21:25:14 <mdmkolbe> Nafai: of course for + it doesn't matter so much but for / and - and others it matters a lot
21:25:17 <dmwit> nicknull: Choose a particular monad.  Maybe is a good choice.
21:25:28 <Nafai> mdmkolbe: Ah, makes sense
21:25:39 <nicknull> how choose?
21:25:42 <dmwit> Nafai: There's also non-associative.
21:26:03 <dmwit> nicknull: Stick a ":: Maybe a" at the end, where 'a' is the contained type.
21:26:19 <dmwit> Nafai: This means that "1 + 2 + 3" is a parse error.
21:26:29 <dmwit> > True == True == True
21:26:30 <lambdabot>       precedence parsing error
21:26:30 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
21:26:58 <Nafai> dmwit: How do you specify that?
21:27:04 <dmwit> infix
21:27:15 <dmwit> (Note that there's no 'l' or 'r' at the end.)
21:27:24 <Nafai> Ah
21:27:44 <lispy> oh, so is (+) defined left associative?
21:27:53 <dmwit> Of course, you can always put parentheses to explicitly tell the associativity. =)
21:27:57 <dmwit> > (True == True) == True
21:27:59 <lambdabot>   True
21:28:11 <mdmkolbe> @info +
21:28:11 <lambdabot> (+)
21:28:12 <nicknull> does  a moand have to return a type x? why not just Nothing or an Int?
21:28:17 <dmwit> lispy: It is here.
21:28:41 <dmwit> ?info do {x <- foo; y; return x}
21:28:41 <lambdabot> foo >>= \ x -> y >> return x
21:28:45 <dmwit> mdmkolbe: ;-)
21:29:00 <ddarius> > foldr (+) 0 [1,2,3] :: Expr
21:29:01 <lambdabot>   1 + (2 + (3 + 0))
21:29:09 <ddarius> > foldl (+) 0 [1,2,3] :: Expr
21:29:10 <lambdabot>   0 + 1 + 2 + 3
21:29:20 <lispy> oh neat
21:29:21 <dmwit> cute
21:29:35 <mdmkolbe> ddarius: how did you do that?
21:29:39 <dmwit> I guess that's just baked into the Expr instance, though.
21:29:40 <ddarius> Magics
21:29:44 <mdmkolbe> @info Expr
21:29:44 <lambdabot> Expr
21:29:46 <dmwit> ?where SimpleReflect
21:29:46 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
21:29:47 <mdmkolbe> @index Expr
21:29:48 <lambdabot> bzzt
21:29:52 <ddarius> dmwit: Indeed.
21:29:57 <dmwit> mdmkolbe: ?info spell-corrects to ?undo
21:30:13 <dmwit> mdmkolbe: But see that SimpleReflect link.
21:30:22 <lispy> Heh, that's a terrible correction
21:30:43 <mdmkolbe> yeah, lambdabot should tell you when it spell corrects
21:30:57 <dmwit> Somebody should just write an ?info that says, "sorry"
21:31:08 <ddarius> > let infixr 1 +; (+) = (*) in foldr (+) 0 [1,2,3] :: Expr
21:31:09 <lambdabot>   1 * (2 * (3 * 0))
21:31:59 <dmwit> > let infixl 1 +; (+) = (*) in foldr (+) 0 [1..3]
21:32:00 <lambdabot>   0
21:32:04 <dmwit> > let infixl 1 +; (+) = (*) in foldr (+) 0 [1..3] :: Expr
21:32:05 <lambdabot>   1 * (2 * (3 * 0))
21:32:08 <nicknull> how can i patternmatch in an expression without a function for it?
21:32:11 <dmwit> right
21:32:20 <dmwit> nicknull: case
21:32:29 <nicknull> like fromJust x, cant i do something else?
21:32:43 <dmwit> In that particular case, I recommend fromMaybe or maybe.
21:32:44 <dmwit> :t fromMaybe
21:32:45 <lambdabot> forall a. a -> Maybe a -> a
21:32:47 <dmwit> :t maybe
21:32:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:33:25 <dmwit> But "case" is the general way of doing a pattern match.
21:33:42 <dmwit> (In fact function definitions with pattern matching probably desugar into case statements.)
21:34:22 <nicknull> i se thanks
21:35:09 <electronx> just wandering whats the fastest xml parse for haskell?
21:35:14 <electronx> parser*
21:36:00 <mdmkolbe> electronx: fast in computer time or in programmer time?
21:38:05 <mdmkolbe> electronx: if you didn't already know there is quite a selection to choose from at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:XML
21:38:10 <lambdabot> Title: HackageDB: packages by category
21:38:13 <yaru1022> how do I return a function that is defined piecewisely?
21:38:25 <yaru1022> i mean how do I create one and return it on run time?
21:41:16 <Samy> yaru1022, please elaborate
21:42:55 <yaru1022> Samy: I have a function that accepts one function and returns another function. The returning function looks like this
21:43:05 <yaru1022> crpFactor (OC, NullFraud, NullTrav) = 0.3
21:43:10 <Cale> yaru1022: It's the same thing as writing a function which takes one more parameter.
21:43:11 <yaru1022> crpFactor (OC, NotFraud, NullTrav) = 0.2
21:45:06 <Cale> yaru1022: does that make sense?
21:45:17 <yaru1022> Cale: not really ^^;
21:45:46 <yaru1022> Cale: I guess my mind is not very functional programmingish... lol
21:45:57 <mauke> I fail to see the problem
21:46:02 <Cale> Well, what's the whole function you'd like to define?
21:46:04 <mauke> just return a function
21:46:32 <Cale> You could also define the function you're returning in a where clause.
21:46:36 <Cale> (or let expression)
21:46:43 <yaru1022> Cale: would you take a look at this? http://www.student.cs.uwaterloo.ca/%7Ecs486/slides/Lecture9.pdf
21:46:45 <lambdabot> Title: Microsoft PowerPoint - Lecture9
21:46:50 <trontonic> >[''..'']
21:46:51 <mauke> hahaha
21:47:05 <Cale> okay
21:47:11 <yaru1022> slide 11~14... I'd like to implement that variable elimination algorithm with haskell
21:47:22 <yaru1022> but i'm just failing to see how to approach it
21:48:19 <yaru1022> since factor is like a function, I was defining them like this -_-;
21:48:28 <yaru1022> fraudFactor (NullOC, Fraud, Trav, NullFP, NullIP, NullCRP) = 0.01
21:48:28 <yaru1022> fraudFactor (NullOC, NotFraud, Trav, NullFP, NullIP, NullCRP) = 0.99
21:48:28 <yaru1022> fraudFactor (NullOC, Fraud, NotTrav, NullFP, NullIP, NullCRP) = 0.004
21:48:31 <trontonic> > [''..'']
21:48:33 <lambdabot>   ""
21:49:06 <Cale> yaru1022: okay...
21:49:22 <yaru1022> but then, I don't know how to do product of two factors as described in slide 11 nor restricting a factor as described in slide 14
21:49:44 <yaru1022> am I approaching from a wrong direction?
21:49:52 <trontonic> why does haskell return "" as a result from [''..''] ?
21:50:10 <Cale> trontonic: perhaps '' comes after ''?
21:50:23 <mauke> > ['' .. '']
21:50:24 <lambdabot>   "\229\230"
21:50:32 <trontonic> Cale: no, it's abcdefghijklmnopqrstuvwxyz
21:50:42 <mauke> no, it isn't
21:50:49 <mauke> > succ 'z'
21:50:50 <lambdabot>   '{'
21:50:53 <trontonic> mauke: in my localization it is
21:50:55 <mauke> after 'z' comes '{'
21:51:02 <mauke> Haskell doesn't care about your collation order
21:51:06 <Cale> yaru1022: Well, you want to do this in a general way?
21:51:13 <Cale> yaru1022: or just for two specific things?
21:51:25 <trontonic> mauke: why not?
21:51:31 <nicknull> no it is 
21:51:34 <mauke> because it wouldn't make sense
21:51:47 <yaru1022> Cale: as general as possible..
21:51:57 <mauke> how would the Enum instance know which order to use?
21:52:26 <yaru1022> Cale: how would you approach it?
21:52:31 <trontonic> mauke: that depends if the type is a localized character, an ascii character or a number
21:52:36 <Cale> yaru1022: Well, there's a bit of difficulty in that you have so many parameters, not just two or three, so it's a little hard to write something which is perfectly general.
21:52:52 <mauke> trontonic: the type is Char, which is a unicode codepoint
21:53:06 <yaru1022> Cale: okay, let's say I have only 6 parameters...
21:53:27 <yaru1022> Cale: but still, once I write the function as I did above... I don't know how I can write product of the two factors...
21:53:29 <trontonic> mauke: I think the default type for '' is wrong
21:53:42 <Cale> yaru1022: Like, if you had just 2 and 3 parameter things, you could define   product f g x y z = f x y * g y z
21:54:06 <Cale> Mimicking the definition from the slides.
21:55:05 <trontonic> mauke: but thanks for the answers
21:55:08 <yaru1022> Cale: hm... but what if I don't know in advance that which parameter is in the factor?
21:56:06 <Cale> Well, you have to be sure about something about the structure of the things that your functions are taking and producing in order to work with them...
21:56:59 <Cale> You could always take the parts which are in common and restructure your functions so that this definition of product will apply.
21:58:05 <yaru1022> Cale: I mean, you have to accept two factors (for which parameters are not known in advance) and produce the product of the factors. When doing so, I need to figure out what the common variables are and have to figure out how to define the product based on the common variables...
21:58:14 <yaru1022> so I guess it is kinda dynamic rather than static...
21:58:55 <Cale> If you want to do that statically, it will be quite complicated, yeah.
22:00:10 <nicknull> yaru/cale: cant he just do it with permutations?
22:00:21 <yaru1022> Cale: i c... I thought this would be easily doable in Haskell because it is mathematicky lol but I guess not ;
22:00:26 <Cale> I suppose what you could do is have all your functions consume a Data.Map from keys (describing the meaning of the variables), to their values, assuming that they all have the same type.
22:00:30 <Trinithis> what would be a good algorithm for creating all the permutations of a given list?
22:00:52 <nicknull> http://hpaste.org/11349
22:00:55 <Cale> yaru1022: You could also just use that definition of product along with lambdas.
22:01:00 <nicknull> i was thinking along those lines
22:01:01 <nicknull> ^^
22:01:14 <nicknull> but i dont really know what it si you are doign more exacrtly
22:01:35 <trontonic> I wonder why 0.7+0.2 return 0.89999999999999991 in Python, but 0.8999999999999999 in Haskell
22:02:42 <mauke> > 0.7+0.2 :: Rational
22:02:44 <lambdabot>   9%10
22:02:49 <Cale> yaru1022: for example, if you have  f (u1,u2,u3,u4,u5,u6)  and  g(u4,u5,u6,u7,u8), then you can write something like their product using  product (\(u1,u2,u3) (u4,u5,u6) -> f (u1,u2,u3,u4,u5,u6)) (\(u4,u5,u6) (u7,u8) -> g (u4,u5,u6,u7,u8))
22:02:56 <yaru1022> nicknull, but your factor doesn't return any value when it is given variables?
22:03:11 <sjanssen> trontonic: is 0.7 single or double precision in Python?
22:03:17 <Cale> which is a mess, but then again, you're doing something fiddly to start with.
22:03:41 <trontonic> sjanssen: I'm not sure, I would have to check the python source
22:03:45 <Trinithis> oh wait, I know how to... nevermind
22:03:46 <Cale> If you want to determine what the intersection of the variables is in some automatic way, then you have to actually provide that information somehow.
22:04:02 <yaru1022> Cale: hm... okay. sounds complicated hehe
22:04:04 <trontonic> mauke: nice one :)
22:04:05 <Cale> Like, not just provide the values of the variables, but their description somehow as well.
22:04:29 <nicknull> let f = Factor (M.singleton O True)
22:04:29 <nicknull> *Main> f
22:04:32 <yaru1022> Cale: yeah that makes sense..
22:04:36 <nicknull>  M.lookup O $ vars f
22:05:28 <Cale> yaru1022: So, using a Data.Map would make a certain amount of sense, though it would mean that all your variables must be of the same type.
22:05:40 <yaru1022> nicknull, but the factor is like a function... for example 'factor O P' should return 0.38 or 'factor P Q' should return 0.99, etc..
22:06:05 <unmarshal> is haskelldb used much? what is the quintessential haskell sql lib
22:06:08 <yaru1022> Cale: i c... yeah I think I'm just approaching this problem from a totally wrong angle...
22:06:12 <trontonic> mauke: thanks for the answers
22:08:03 <nicknull> yaru: ok guess i misunderstood
22:08:26 <nicknull> maybe you could write in a language you already know then translate it to haskell? might be easier
22:09:02 <nicknull> so a factor should be a function and some variables?
22:09:11 <Cale> yaru1022: At the very least, it's easy to do these things if functions are as nicely abstract as the functions in the slides.
22:09:33 <nicknull> can a data "contain" a function?
22:09:58 <yaru1022> nicknull: I'm not sure if I understand your question. Which data are you talking about?
22:10:01 <nicknull> and can the type of the function be as general as take 2 inputs give one output?
22:10:16 <Cale> yaru1022: For instance, for summing out the second parameter:   sumOut dom f y = sum [f x y | x <- dom]
22:10:17 <nicknull> i was asking baout haskell in general
22:10:28 <mauke> data Waht x = F (x -> x -> x)
22:10:28 <Cale> er, first parameter, rather
22:10:55 <Cale> nicknull: Functions can be used anywhere that you can use other values.
22:11:07 <Cale> (In general)
22:11:41 <yaru1022> Cale: I guess the factors I'm dealing with right now are somewhat abstract as the functions in the slides
22:11:55 <yaru1022> Cale: but it has 6 variables instead...
22:12:33 <Cale> yaru1022: Yeah, so with 6 variables, things get a little more complicated, because there are lots of possible ways to form products and sum out variables.
22:13:03 <Cale> yaru1022: And there's basically no way to avoid telling the computer somehow which variables should be identified and which should be summed over.
22:13:37 <yaru1022> Cale: btw, if I define sumOut dom f y = sum [f x y | x <- dom], it doesn't return another function.. right? it just returns a value, doesn't it?
22:13:55 <Cale> depends how many of the parameters you supply
22:14:06 <Cale> Every function in Haskell has exactly one parameter, in reality.
22:14:27 <Cale> Functions which appear to have more parameters are functions which take the first and produce functions which take the rest.
22:14:34 <yaru1022> u mean.. currying?
22:14:37 <Cale> yes
22:14:46 <Cale> sumOut is curried
22:15:00 <yaru1022> i c.. that's right
22:15:39 <Cale> So it takes dom (the domain to sum over, represented as a list of values), and f, the function, and produces another function, which, for the value y, gives the sum of the values f x y for each x in dom
22:16:11 <mauke> y is redundant
22:16:25 <Cale> mauke: Only if you have magic instances of Num
22:16:38 <rwbarton> mauke: all the variables are redundant :)
22:16:39 <mauke> sumOut dom f y = sumOut' dom (\x -> f x y)
22:17:12 <Cale> Oh, you mean in that sense :)
22:17:41 <Cale> Yeah, we could write a function which just maps a function over a list and then sums it.
22:18:14 <mauke> sumOut'' = (sum .) . map
22:19:27 <Cale> yaru1022: As for restriction, we can get that simply as some combination of lambda and application.
22:20:13 <yaru1022> Cale: yeah.. I guess so ^^; I'm just not very fluent in Haskell so having a difficulty. But I'll try
22:20:47 <Cale> yaru1022: I think what would really make you happy here is if Haskell had a proper record system with row polymorphism, but sadly nobody has implemented that yet.
22:22:21 <Cale> (also, it seems uncommon to be able to specify a record type as consisting of the union or intersection of the rows in two other record types, though this example makes it clear why you might want that)
22:23:16 <yaru1022> Cale: yeah lol I'm dealing with some weirdo function haha
22:24:32 <Cale> It might also be possible, if you're daring/desperate enough to use the HList library, which does some fairly fancy tricks that could let you get exactly what you need here, but invoves some rather deep type hackery.
22:25:16 <NatLWalker> Hi all
22:25:17 <NatLWalker> :)
22:25:18 <Pseudonym> To be fair, most of that type hackery is to get around some stuff that really should probably be built in.
22:25:28 <Cale> NatLWalker: hello
22:26:12 <scriptdevil> http://hpaste.org/11350 I know this is a common error message.. But I followed the rules in http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output
22:26:24 <Cale> Pseudonym: I wonder how much clearer HList would look using the new type families stuff.
22:26:33 <Pseudonym> Probably not a lot.
22:27:04 <Cale> Well, at least you'd have a sort of functional notation for things.
22:27:13 <Pseudonym> Well, yes.
22:27:39 <Pseudonym> But then they'd look like C macros instead of M4 macros.
22:27:41 <Cale> scriptdevil: indentation
22:27:49 <Cale> scriptdevil: you have tabs in your file
22:28:00 <Pseudonym> BRB
22:28:04 <Cale> scriptdevil: tabs are evil, you should have your editor replace them with spaces automatically.
22:28:19 <Cale> (most editors have an option for this)
22:28:44 <scriptdevil> Cale: No wonder. I just switched from emacs to geany
22:28:50 <Cale> scriptdevil: ah
22:28:50 <scriptdevil> Thanks a lot!
22:28:59 <Cale> no problem :)
22:43:47 <score> does the release date for real world haskell keep getting pushed back?
22:45:43 <Cale> I thought that it had been released...
22:45:50 <Cale> It's not in beta anymore, anyway.
22:47:04 <jeffz> score, i think it's been "in time for christmas" for awhile
22:47:26 <Cale> The website says November.
22:48:50 <quicksilver> it's complete, in that the authors have finished their job.
22:48:57 <quicksilver> there may be some final editing the publisher wants to do.
22:49:39 <quicksilver> amazon are estimating november delivery.
22:49:50 <quicksilver> but amazon sometimes make dates up out of thing air.
22:51:44 <score> any idea what percentage the authors will actually see?
22:53:42 <yaru1022> hey Cale, is it possible to accept a field name as a parameter?
22:53:43 <yaru1022> for example,
22:53:54 <quicksilver> yaru1022: not directly, no.
22:54:02 <quicksilver> one of the more annoying things about haskell records.
22:54:08 <yaru1022> data ArgList =
22:54:08 <yaru1022>     ArgList { oc    :: OC,
22:54:08 <yaru1022>               fraud :: Fraud,
22:54:08 <yaru1022>               trav  :: Trav,
22:54:12 <yaru1022>               fp    :: FP,
22:54:15 <yaru1022>               ip    :: IP,
22:54:19 <mauke> stop pasting :(
22:54:20 <yaru1022>               crp   :: CRP
22:54:20 <yaru1022>             }
22:54:23 <yaru1022> quicksilver, is there any other way to get around with it then?
22:54:24 <quicksilver> for this reason I use lenses ("functional references")
22:54:29 <quicksilver> rather than field names
22:54:31 <yaru1022> mauke, sorry
22:55:15 <quicksilver> yaru1022: here is quite a good blog post about them
22:55:16 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
22:55:20 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
22:55:37 <quicksilver> there is an implementation on hackage called data-accessor
22:56:09 <yaru1022> thanks quicksilver
23:09:49 <yaru1022> hey quicksilver?
23:10:05 <yaru1022> so how would this functional reference help me solving my problem?
23:10:10 <yaru1022> so for the above ArgList data...
23:10:14 <yaru1022> what I want my function to do is
23:10:34 <yaru1022> restrict factor variable value = factor (argList {variable = value})
23:11:28 <yaru1022> I don't know how I can solve it with functional reference. Could you shed some light on this?
23:20:10 <roconnor> > (1+0.055)*1**2.4 - 0.055
23:20:11 <lambdabot>   0.9999999999999999
23:20:25 <roconnor> > 1+0.055 - 0.055
23:20:27 <lambdabot>   0.9999999999999999
23:26:13 <elliottt> yaru1022: what you're looking for is first class labels
23:26:29 <quicksilver> elliottt: yes, which I why I suggested FRs
23:26:34 <quicksilver> because they are first class labels :)
23:26:37 <elliottt> :)
23:26:42 <quicksilver> in fact, they're strictly better than first class labels.
23:26:57 <quicksilver> yaru1022: instead of the third parameter 'variable'
23:27:12 <quicksilver> yaru1022: you pass the corresponding FR for 'variable'
23:27:17 <quicksilver> sorry, that's the 2nd parameter.
23:27:19 * quicksilver can't count.
23:27:20 <elliottt> http://hackage.haskell.org/trac/haskell-prime/ticket/92
23:27:21 <lambdabot> Title: #92 (add First Class Labels) - Haskell Prime - Trac
23:27:31 <elliottt> looks like they're a 'maybe' for haskell'
23:29:03 <quicksilver> yaru1022: in twanvl's syntax it would be "restrict factor variable value = set variable argList value
23:29:30 <yaru1022> quicksilver: aha
23:33:36 <Cale> Aren't functional references going to be a difficult way to handle this because all the references you'd want to pass would be of different types?
23:34:18 <Cale> Though, up to that problem, they're a decent way to approach this...
23:35:04 <Plareplane> how do i arrange the link order in ghc when making static binaries?  i.e. using --make gives me undefined references, putting *.a gives me a different set of undefined references, and manually arranging the .a's lets me link properly
23:35:07 <yaru1022> Cale: hm... good point. gah~ I'm almost giving up on it lol
23:35:35 <jekor> How can I go about getting values of different types from a string? How intelligent is the type system? I have some code that compiles, but the readInput always returns Nothing. http://hpaste.org/11351
23:35:51 <Cale> yaru1022: There is almost certainly a way to manage this though... you just need to determine what's *really* important about all these different types of things which you have.
23:35:59 <jekor> I was hoping that it would figure out that I need a string from the context and read appropriately...oh wait...
23:36:03 <Cale> yaru1022: That is, what they have in common.
23:36:29 <jekor> Hah. Just figured out that it's looking for the "" in the string I input. The type system is intelligent!
23:36:41 <yaru1022> Cale: commong thing would be... hm.. that all the variables are binary random variable?
23:37:02 <Cale> yaru1022: aha, they're all binary?
23:37:03 <yaru1022> Cale: would that make things better?
23:37:13 <Cale> yaru1022: yes, that would make things much nicer :)
23:37:15 <electronx> is there software that automatically finds proofs for maths?
23:37:46 <Cale> electronx: yes, lots of it.
23:37:50 <sclv> depends what you mean by automatic
23:37:58 <jekor> I guess my next question is, is there a way to tell read to read from a string expecting a string type but without the quotes?
23:38:31 <sclv> at that point you shouldn't be calling "read"
23:38:49 <jekor> sclv: Then I'd need 2 functions, I guess.
23:38:59 <electronx> Cale, sclv: i need some software that would simplyfy math expressions and find derivitives and so forth and also be simple :)
23:39:03 <jekor> Makes sense. I was just hoping I was wrong ;)
23:39:06 <Cale> electronx: Doing searches for specific proofs (of an unrestricted variety) usually takes forever without some human guidance though.
23:39:07 <sclv> reading from a string expecting a string = id
23:39:19 <Cale> electronx: Oh, *that* kind of software certainly exists.
23:39:26 <electronx> :)
23:39:31 <Cale> electronx: That's very different though.
23:39:37 <sclv> > let stringread = id = stringread "like this for example?"
23:39:38 <lambdabot>   <no location info>: parse error on input `='
23:39:45 <jekor> Hm. Is there a way to extract type information at runtime?
23:39:47 <sclv> > let stringread = id in stringread "like this for example?"
23:39:49 <lambdabot>   "like this for example?"
23:39:58 <Cale> electronx: The best ones are Mathematica and Maple. If you're looking for something free, maybe try Maxima.
23:40:07 <electronx> thanks Cale
23:40:09 <jekor> I want the function to return an appropriate type to the caller, based on the caller's context.
23:40:14 <sclv> jekor: again, depends what you want to do. odds are that you're approaching the question wrong.
23:40:23 <Cale> electronx: (or check to see if your university provides Mathematica or Maple to students at reduced cost or free)
23:40:25 <sclv> ?ty read
23:40:27 <lambdabot> forall a. (Read a) => String -> a
23:40:34 <jekor> sclv: Can you take a look at http://hpaste.org/11351 please?
23:40:58 <Cale> jekor: It sounds like you want to define a typeclass (though I haven't looked at your paste yet)
23:41:06 <jekor> The idea is that I'd like a general purpose function to read CGI request parameters (into an appropriate type) and throw an exception based on different criteria.
23:41:31 <jekor> I already figured I'd need a bunch of functions that return tuples of different sizes...
23:41:36 <electronx> Cale: i'll try maxima
23:41:37 <sclv> so the readInput function is the one you want?
23:41:47 <sclv> ?ty reads
23:41:48 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:42:02 <sclv> it looks like maybeRead, which you can write using reads.
23:42:04 <Cale> jekor: er, isn't this code exactly what you're describing? Or you want to know how to write readInput?
23:42:24 <Cale> readInput should probably not be in the CGI monad
23:42:34 <jeffz> jekor: you know you can get all the parameters at once with getInputs
23:42:36 <Cale> so you should probably make that  let p' = readInput p
23:42:38 <jekor> Cale: I have readInput, I just need to direct it to do something a little different in the case of a string.
23:42:49 <sclv> > reads "not an integer" :: [(Int, String)]
23:42:50 <lambdabot>   []
23:42:51 <Cale> jekor: ah...
23:43:02 <Cale> jekor: You're trying to avoid the quoting?
23:43:11 <sclv> you should define another typeclass
23:43:13 <sclv> myread
23:43:17 <jekor> readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
23:43:37 <Cale> jekor: Or... what would it be?
23:43:39 <sclv> with an instance for strings that's just id.
23:43:43 <jekor> OK, so I'm going to get to learn how to make a new typeclass with read functions?
23:43:56 <sclv> and instance Read a => MyRead a where myread x = read x
23:43:58 <jekor> I was hoping to avoid learning how to do that ;)
23:44:03 <sclv> to catch the other default cases.
23:44:10 <elliottt> this sounds like overkill
23:44:16 <jekor> Thanks, sclv (and Cale).
23:44:24 <Cale> You could also just newtype String
23:44:50 <rwbarton> Cale: I was about to describe that as a "somewhat horrible idea" :)
23:45:06 <Cale> It's not so horrible.
23:45:10 <elliottt> jekor: have you looked into monad transformers yet?
23:45:12 <Cale> newtype StringU = SU String deriving (Eq, Ord)
23:45:24 <Cale> instance Read StringU where
23:45:25 <jekor> elliottt: I'm open to other suggestions. Or are you saying that it's not worth all the effort to pursue this abstraction?
23:45:26 <rwbarton> It would be less horrible if read were a class method
23:45:27 <Cale>    read = id
23:45:28 <elliottt> jekor: that would provide an easier solution to your read with exceptions problem
23:45:50 <Cale> read is a class method.
23:45:51 <elliottt> jekor: you could avoid throwDynamic, firstly
23:46:01 <jekor> elliottt: I don't fully understand monad transformers yet. I just got my head around monads last weekend.
23:46:04 <Cale> er...
23:46:10 <sclv> elliottt: its not the exceptions that's the issue so much as the "read everything as normal but not strings which when you want them just gobble all the input"
23:46:18 <Cale> oh, it's not, right.
23:46:18 <elliottt> and you could have, as a side effect, a cleaner implementation of the read function you're trying to write
23:46:21 <jekor> elliottt: How can I throw a custom exception? Is there a way to make my class part of the Exception class?
23:46:45 <elliottt> sclv: in that case, i'd just go with Cale's suggestion, and newtype string :)
23:46:46 <Cale>  readsPrec n s = [(s,"")]
23:46:47 <rwbarton> yaru1022: I bet you can do this elegantly with a monad
23:46:54 <elliottt> jekor: you'd use an exception monad
23:47:01 <elliottt> and run it from the top level
23:47:03 <Cale>  readsPrec n s = [(SU s,"")]
23:47:05 <Cale> rather
23:47:08 <glguy> elliottt, I wrote the left-fold version
23:47:11 <elliottt> essentially threading Either through
23:47:13 <glguy> its actually cleaner
23:47:14 <elliottt> glguy: awesome :)
23:47:18 <sclv> yeah -- newtyping is the saner way. but the really saner way for someone just starting out is to have a getParam method and a getStringParam method
23:47:34 <Cale> sclv: I could agree with that :)
23:47:42 <elliottt> sclv: agreed
23:47:55 <jekor> Yeh. elliottt's suggestion is interesting, but until I understand monad transformers better, I think I'm going with the 2 functions.
23:47:55 <sclv> and then once you know what you're doing more, you can decide what complexity tradeoffs to make.
23:48:06 <jekor> Thanks guys. I just hoped I was missing something more obvious.
23:48:27 <Cale> How did monad transformers get into this?
23:48:38 <sclv> side discussion on exceptions.
23:48:55 <Cale> hmm...
23:49:07 <sclv> although i'm increasingly of the opinion that 99% of the time putting an either on an IO stack is just silly.
23:49:17 <Cale> I agree.
23:49:21 <sclv> because now you have two layers of exceptions to deal with instead of one.
23:49:21 <Cale> IO already has exceptions.
23:49:35 <sclv> and you have to catch and bracket both of them, etc.
23:50:46 <elliottt> sclv: well, with some work, you can make a custom catch catch both IO and custom exceptions
23:50:47 <Cale> I rarely recommend using monad transformers lightly. They can be a useful way to get a particular monad that you want, but unless you go to the trouble of newtyping them and deciding on your operations and such, they make a big mess of your types.
23:50:49 <elliottt> it's gross though
23:51:37 <elliottt> Cale: yes indeed.  it requires some planning.
23:51:40 <sclv> elliottt: yeah, sure. but what do you gain? mainly i think just a feeling of more control because its easy to think about an Either compared to unwinding a call stack.
23:52:04 <Cale> Of course, there are some things which are most naturally defined by recognising that some function is secretly monadic :)
23:52:21 <elliottt> sclv: yeah.  it's also nice to be able to deal with application specific errors, only
23:52:31 <rwbarton> newtyping isn't that much trouble with generalized newtype deriving
23:52:41 <elliottt> rwbarton: it is if you use monadLib :0
23:52:42 <elliottt> :)
23:52:50 <rwbarton> elliottt: Hmm, haven't tried that :)
23:52:53 <elliottt> which is unfortunate, as I like it a lot more than mtl
23:53:36 <sclv> right -- that's the one issue -- when you actually want to treat the two layers differently. but that generally means you're doing control flow with exceptions...
23:53:42 <glguy> it generalizednewtype derives monad and functor fine
23:53:48 <rwbarton> elliottt: What do you prefer about it?  (I looked at it briefly but not long enough to tell how it differed from mtl)
23:53:55 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; perms xs = evalStateT (mapM (const (StateT select)) xs) xs in perms [1,2,3]
23:53:56 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
23:54:09 <elliottt> rwbarton: the ChoiceT transformer is really handy
23:54:23 <glguy> rwbarton, non-broken stacking, better typeclass granulatity, better strictness/laziness attention
23:55:44 * Cale uses LogicT usually
23:57:23 <glguy> the advantages are mtl are: everyone uses it, more helper functions
23:57:28 * Cale wishes that the monadLib State and Writer pairs weren't still backwards like the mtl ones.
23:57:34 <glguy> e.g. asks f = fmap f ask
23:59:31 <glguy> Cale, you are a mathematician, isn't equivalence up to isomorphism as good as any other?
23:59:40 <rwbarton> @src State
23:59:40 <lambdabot> Source not found. My pet ferret can type better than you!
23:59:45 <rwbarton> , src ''State
23:59:51 <glguy> :)
