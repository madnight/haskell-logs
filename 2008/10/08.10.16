00:14:55 <Saizan> yeah, using haddock seems kind of a black art to me
00:15:03 <Saizan> but i've never really tried
00:16:31 <sm> cabal will make it for you
00:16:49 <sm> or you can copy the make rules I laboriously added to darcs' makefile
00:17:06 <sm> or http://joyful.com/repos/hledger/Makefile , better
00:17:11 <ivanm> @seen dons
00:17:11 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 1h 57m 58s ago.
00:17:24 <sm> bonus, that one adds hoogle
00:17:42 <Saizan> cabal still doesn't build an aggregate index from multiple packages, nor add source links i think
00:17:50 <sm> ah
00:19:09 <sjanssen> Saizan: hackage has custom code to add the source links?
00:19:52 <sjanssen> Saizan: see the  --hyperlink-source option to Setup haddock
00:21:20 <Saizan> sjanssen: oh, ok :)
00:26:31 <mmorrow> this is amusing: http://hpaste.org/11188
00:29:55 <mmorrow> Saizan, sjanssen: yeah, it looks like it just takes about four diff flags, each of which needs either a path or some spec of how/where/? to link src to haddock stuff via a mini-template-lang
00:30:32 <mmorrow> my eyes glazed over, but it's on my list of "to-write-a-sh-script-hack-and-never-have-to-do-again"
00:34:10 <sm> mmorrow: did you look at the makefile I posted ? I did the work for you
00:36:04 <mmorrow> sm: whoa, i didn't see it yes. awesome.
00:36:06 * mmorrow looks
00:36:40 <mmorrow> friggin sweet, a hoogle index too..
00:37:34 * mmorrow goes to rebuild teh ghc haddocks w/ src links and generate a hoogle index for all of ghc
00:37:45 <sm> it looks like http://joyful.com/repos/hledger/api-doc/
00:37:46 <lambdabot> Title: hledger api docs
00:37:59 <mmorrow> omg
00:38:22 <telexicon> ghci does not work on sparc?
00:40:19 <mmorrow> it looks like it does according to this http://hackage.haskell.org/trac/ghc/wiki/Platforms
00:40:24 <lambdabot> Title: Platforms - GHC - Trac
00:41:21 <telexicon> mmorrow, hmm, i tried launching it but i get: ghc-6.8.2: not built for interactive use
00:41:45 <mmorrow> oh. is that a binary dist or did you build from src?
00:42:03 <telexicon> binary dist
00:42:07 <mmorrow> err, well i guess either way, the solution is probably to build from src
00:42:08 <telexicon> debian on ultrasparc
00:42:25 <mmorrow> where'd you get the bindist from?
00:42:29 <telexicon> debian
00:42:31 <telexicon> apt
00:42:49 <mmorrow> ah. try one from haskell.org/ghc first, then if that doesn't work try to build from src
00:43:13 <telexicon> ok
00:43:37 <mmorrow> (unless of course you'd like to just build from src anyway)
00:44:11 <telexicon> mmorrow, on the ghc website it says: All Debian platforms have ghc6 packages in the main Debian archive.
00:44:16 <telexicon> basically get it from apt
00:44:40 <mmorrow> heh, looks like those are borked :)
00:44:56 <telexicon> :(
00:45:01 <mmorrow> personally, i'd just build from src
00:45:04 <telexicon> i guess ill have to compile from source
00:45:11 <telexicon> wont that take ages though? :P
00:45:12 <mmorrow> it's no biggy
00:45:21 <mmorrow> ~20 min
00:45:27 <mmorrow> do
00:45:35 <mmorrow> err, how many cores do you have
00:45:37 <mmorrow> >1 ?
00:45:52 <telexicon> no just 1
00:46:00 <mmorrow> maybe do
00:46:02 <mmorrow> make -j2
00:46:07 <mmorrow> at least
00:46:17 <mmorrow> i have two cores and do for ghc building
00:46:19 <mmorrow> make -j10
00:46:38 <ivanm> I've read that in general, for n cores/cpus, you should use -j(n+1)
00:47:30 <mmorrow> i'm not sure if -j10 is optimal, but i'm pretty sure it's faster that -j3
00:47:35 <mmorrow> (on my box)
00:47:50 <ivanm> heh
00:47:50 <mmorrow> i'm gonna time it next time i build though
00:47:51 <ivanm> C2D?
00:47:56 <therp> telexicon: modify mk/build.mk to get a faster build
00:47:58 <ivanm> what's this? ghc?
00:48:03 <mmorrow> yeah
00:48:09 <telexicon> ok
00:48:13 <telexicon> im on a 333Mhz ultrasparc
00:48:20 <telexicon> :p
00:48:23 <BeelsebobWork> ivanm: I have a feeling that the actual formula is more like -j(ciel 1.25n)
00:48:26 <ivanm> takes around 22 minutes here on my 2GHz C2D
00:48:27 <mmorrow> i also add -O2 and super optims to mk/build.mk
00:49:05 <telexicon> ok, so i guess another question is
00:49:18 <telexicon> i just compiled a 'hello, world' with ghc on sparc, the resulting binary is 5.5MB
00:49:33 <ivanm> BeelsebobWork: ceil* ?
00:49:44 <BeelsebobWork> ivanm: cieling -- round up
00:49:59 <Saizan> that's ceiling
00:50:09 <Saizan> ?all-dicts ceiling
00:50:10 <lambdabot> *** "Ceiling" gcide "The Collaborative International Dictionary of English v.0.48"
00:50:10 <lambdabot> Ceil \Ceil\ (s[=e]l), v. t. [imp. & p. p. {Ceiled} (s[=e]ld); p.
00:50:10 <lambdabot>    pr. & vb. n. {Ceiling}.] [From an older noun, fr. F. ciel
00:50:10 <lambdabot>    heaven, canopy, fr. L. caelum heaven, vault, arch, covering;
00:50:10 <lambdabot>    cf. Gr. koi^los hollow.]
00:50:12 <BeelsebobWork> oh, fail
00:50:12 <lambdabot> [87 @more lines]
00:50:19 <BeelsebobWork> sorry, I didn't even see the spelling error
00:50:56 <telexicon> im guessing its statically linking some stuff
00:51:58 <jdrake> > (*) 2.0
00:51:59 <lambdabot>       Overlapping instances for Show (t -> t)
00:51:59 <lambdabot>        arising from a use of `s...
00:55:46 <jeffz`> telexicon: how big is it if you strip it?
00:55:54 <telexicon> 3.5MB
00:56:30 <jdrake> Any ideas why this doesn't quite work? http://hpaste.org/11189   It is part of: Show that lift f * lift g = lift (f.g)   from the you could have invented monads blog entry
00:56:48 * mmorrow darcs gets hledger
00:57:09 <jeffz`> I think I had a 350MHz ultrasparc once, it was veerry slow, starting Emacs would take several seconds
00:58:06 <telexicon> jeffz`, yeah pretty much
00:59:40 <rwbarton> jdrake: maybe * should be >>=?
00:59:45 <rwbarton> or =<<
01:01:31 <rwbarton> actually it's usually called <=<
01:01:37 <rwbarton> :t (<=<)
01:01:38 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
01:02:14 <jdrake> rwbarton, this is an exercise where all functions are invented
01:02:29 <jdrake> I am not sure why I would use anything but a regular operator
01:04:02 <rwbarton> Right, well, ghci doesn't know that you/sigfpe have invented this nontraditional meaning for *.
01:04:19 <rwbarton> (Maybe I don't understand what your question is)
01:06:14 <jdrake> WI shall restate it
01:06:24 <jdrake> * is the normal * operator
01:06:34 <jdrake> lift f * lift g :: (Num (a -> (a, [Char])), Fractional a) => a -> (a, [Char])
01:06:35 <jdrake> lift (f.g) :: (Fractional a) => a -> (a, [Char])
01:06:38 <jdrake> Why are those different
01:06:50 <rwbarton> Read the paragraph where sigfpe defines what he means by *
01:07:03 * jeffz` ah ha... just discovered {}
01:07:10 <jdrake> hmm
01:07:27 <rwbarton> (They're different because * is of type Num a => a -> a -> a, so you get a Num instance for the type of lift f which is a -> (a, String))
01:08:07 <jdrake> oh so it * is bind in his context?
01:08:48 <rwbarton> f' * g' = bind f' . g'
01:09:50 <jdrake> What about this one: lift f * lift g
01:10:29 <rwbarton> So, it is bind (lift f) . lift g
01:11:03 <rwbarton> Just read the whole thing mentally replacing * with some funny-looking symbol like <=<  :)
01:11:53 <jdrake> Why can't he just say it without using the * symbol to confuse me?
01:12:49 <rwbarton> Did you seriously think lift f and lift g were numbers? :)
01:13:21 <rwbarton> Multiplication and composition are the same thing, at some level, so it's logical notation, but it might be clearer to use new notation
01:13:42 <jdrake> no, but I am not knowledgeable enough to be able to directly question this tutorial - that is why I am reading this tutorial
01:14:01 <jdrake> Although tomorrow I hope to be back home in some nice assembly :p
01:15:45 <jdrake> I was curious how small I can write a sine function
01:16:03 <jdrake> Thank the lord for hardware multiply and divide
01:18:54 <mmorrow> jdrake
01:18:59 <mmorrow> : check out harpy
01:19:04 <mmorrow> very fun :)
01:19:22 <jdrake> mmorrow, you never asked what kind of hardware I would be doing assembly on :-)
01:19:30 <mmorrow> aww, i forgot
01:19:41 <mmorrow> well, add your platform ot harpy!! :)
01:20:27 <jdrake> mmorrow, that would be freaky, because you would have to port ghc there too
01:20:31 <mmorrow> jdrake: what hardware /would/ you be doing assembly on?
01:20:40 <mmorrow> jdrake: heh
01:20:51 <jdrake> and to be honest, I don't think it would fit on 16 kilobytes of flash :p
01:21:11 <mmorrow> jdrake: ok, the suspense is killing me.
01:21:11 <jdrake> Not that I need 16 kilobytes, because that is just freaking huge
01:21:26 <jdrake> 1k ought to be enough for any one
01:21:33 <jdrake> http://www.atmel.com/dyn/products/product_card.asp?part_id=3303
01:21:36 <lambdabot> Title: Atmel Products - Product Card
01:21:51 <jdrake> I believe it was that one anyways, I have so many ;P
01:22:14 <mmorrow> hmm, interesting
01:23:16 <jdrake> Monads are more complicated then those
01:24:37 <jdrake> How do you create a function for lambdabot and then execute it?
01:25:16 <mmorrow> > let f x = (x, x) in f 42
01:25:17 <lambdabot>   (42,42)
01:25:29 <mmorrow> > (\x -> (x, x)) 42
01:25:30 <lambdabot>   (42,42)
01:25:37 <mmorrow> > join (,) 42
01:25:38 <lambdabot>   (42,42)
01:25:39 <mmorrow> :)
01:25:52 <ziman> > (id &&& id) 42
01:25:54 <lambdabot>   (42,42)
01:25:55 <jdrake> How about mulitple patterns for functions?
01:26:07 <jdrake> > let fact 1 = 1
01:26:08 <lambdabot>   <no location info>: parse error on input `;'
01:26:24 <mmorrow> > let go [] = [] ; go (x:xs) = (x,x) : go xs in go [0..4]
01:26:26 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4)]
01:26:38 <jdrake> How about this:
01:26:40 <jdrake> fact 1 = 1
01:26:40 <jdrake> fact n = n * (fact $ n - 1)
01:27:00 <mmorrow> so you'd stick it in a let delimited by semis
01:27:16 <mmorrow> > let fact 1 = 1 ; fact n = n * (fact $ n - 1) in fact 400
01:27:18 <lambdabot>   640345228466238952623479703195030058507025830260029594586844459428023971691...
01:27:41 <jdrake> > let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7))
01:27:42 <lambdabot>   <no location info>: parse error on input `;'
01:27:47 <jdrake> wtf
01:27:49 <mmorrow> heh
01:28:02 <mmorrow> so you have to call sine on some value
01:28:03 <jdrake> I have no ; to parse!
01:28:21 <jdrake> eg?
01:28:32 <jdrake> > let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)); sin 3.14159
01:28:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:28:49 <mmorrow> > let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)) in map sine (iterate (+0.3) 0)
01:28:50 <lambdabot>   Not in scope: `fact'Not in scope: `fact'Not in scope: `fact'
01:29:05 <mmorrow> oh, i see
01:29:05 <jdrake> > let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)); sine 3.14159
01:29:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:29:13 <mmorrow> so you aren't making any lasting definitions
01:29:21 <mmorrow> you can though with:
01:29:38 <mmorrow> @let asdfgh = asdfgh
01:29:39 <lambdabot>  Defined.
01:29:43 <mmorrow> > asdfgh
01:29:49 <jdrake> @let fact 1 = 1 ; fact n = n * (fact $ n - 1)
01:29:50 <lambdabot>  Defined.
01:29:57 <jdrake> @let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7))
01:29:57 <mmorrow> > let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)) in map sine (iterate (+0.3) 0)
01:29:59 <lambdabot>   thread killed
01:29:59 <lambdabot>  Defined.
01:29:59 <lambdabot>   [0.0,0.29552020660714284,0.5646424457142857,0.7833258498214286,0.9320250514...
01:30:10 <jdrake> >sine 3.14159
01:30:18 <mmorrow> > map sine (iterate (+0.3) 0)
01:30:19 <lambdabot>   [0.0,0.29552020660714284,0.5646424457142857,0.7833258498214286,0.9320250514...
01:30:25 <jdrake> > sine 3.14159
01:30:27 <lambdabot>   -7.521740147192868e-2
01:30:36 <jdrake> > sin 3.14159
01:30:37 <lambdabot>   2.65358979335273e-6
01:30:37 <mmorrow> woohoo
01:30:47 <jdrake> Google must be wrong
01:30:51 <jdrake> wikipedia rather
01:30:52 <mmorrow> heh
01:32:08 <jdrake> @let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)) + (x^9/(fact 9))
01:32:09 <lambdabot>  <local>:10:0:
01:32:10 <lambdabot>      Warning: Pattern match(es) are overlapped
01:32:10 <lambdabot>               I...
01:32:19 <quicksilver> I've only just noticed that the order of dimensions in java arrays is backwards.
01:32:21 <jdrake> @forget sine
01:32:21 <lambdabot> Incorrect arguments to quote
01:32:24 <quicksilver> foo = new int[wid][height]
01:32:26 <jdrake> @help
01:32:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:32:33 <quicksilver> and then you access it as "foo[x][y]"
01:32:38 <jdrake> @help list
01:32:38 <lambdabot> list [module|command]
01:32:38 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
01:32:42 <mmorrow> > sine 0.000003
01:32:43 <lambdabot>   2.9999999999955002e-6
01:32:44 <jdrake> @list
01:32:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:32:47 <mmorrow> > sin 0.000003
01:32:48 <lambdabot>   2.9999999999955002e-6
01:32:54 <quicksilver> but really in that case it's (int[height])[width]
01:33:04 <mmorrow> so that's only accurate around 0
01:33:17 <jdrake> @undefine sine
01:33:31 <jdrake> @let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)) + (x^9/(fact 9))
01:33:31 <lambdabot>  <local>:1:19: Not in scope: `fact'
01:33:31 <lambdabot>  
01:33:31 <lambdabot>  <local>:1:36: Not in scope: `fact'
01:33:31 <lambdabot>  
01:33:31 <lambdabot>  ...
01:33:42 <jdrake> @let fact 1 = 1 ; fact n = n * (fact $ n - 1)
01:33:42 <lambdabot>  Defined.
01:33:45 <jdrake> @let sine x = x - (x^3/(fact 3)) + (x^5/(fact 5)) - (x^7/(fact 7)) + (x^9/(fact 9))
01:33:45 <lambdabot>  Defined.
01:33:47 <mmorrow> heh, so @undefined kills everything :)
01:33:51 <jdrake> yes
01:34:19 <jdrake> @let cosine x = sine (x - (3.14159/2))
01:34:20 <lambdabot>  Defined.
01:34:30 <jdrake> > cosine (-3.14159)
01:34:31 <lambdabot>   0.44437096623931893
01:34:37 <jdrake> Definitely screwy
01:35:01 <mmorrow> quicksilver: wow, i never noticed that either
01:35:18 <quicksilver> mmorrow: it's only really obvious if you try to work out how to do a "ragged" array.
01:35:29 <quicksilver> mmorrow: i.e. an array of arrays rather than a 2D array.
01:35:34 <mmorrow> ah, haskell++
01:35:39 <quicksilver> mmorrow: in the end I had to interpose a class.
01:35:43 <jdrake> quicksilver, I am not sure what you mean about java
01:35:54 <quicksilver> mmorrow: disclaimer, this is actually Processing, not Java, but I think this syntax is the same.
01:36:12 <quicksilver> jdrake: I mean logically you should list the indices in the reverse order in the type declaration as when you use it.
01:36:23 <quicksilver> jdrake: if you think about what partial application of indices should mean.
01:36:43 <mmorrow> quicksilver: ooh, i saw some stuff produced by that javascript processing.js and they were _awesome_
01:37:06 <mmorrow> i haven't looked at Processing itself though..
01:37:21 <jdrake> quicksilver, what was your example again?
01:38:01 <quicksilver> mmorrow: indeed, this was processing.js. But the syntax is the same.
01:38:06 <ivanm> @tell dons I was mistaken... the mersenne-pure64 version of my code is indeed 4-5x slower than the stdGen version... and the problem comes down to the random number generation (using randomDouble and randomInt)... could the fact that I'm on an x86 machine using -pure64 have something to do with it?
01:38:07 <lambdabot> Consider it noted.
01:38:10 <quicksilver> jdrake: foo = new int[width][height]
01:38:18 <quicksilver> jdrake: and yet you access it as foo[x][y]
01:38:25 <quicksilver> jdrake: foo[y][x] would be more logical.
01:38:51 <jdrake> quicksilver, I disagree
01:38:58 <quicksilver> mmorrow: I'm actually using processing.js as an 'animation viewer' for animations which are created by some haskell code.
01:39:10 <quicksilver> jdrake: think of foo as an array of arrays.
01:39:24 <quicksilver> jdrake: (int[width])[height])
01:39:32 <jdrake> When you say int[5] and then add [5] after it, you are doing an array off of each of the initial [5]
01:39:35 <quicksilver> then foo[0] should be the first row.
01:39:48 <quicksilver> not the first column
01:39:51 <mmorrow> quicksilver: that sounds really interesting. processing.js has been on my to-learn list for a while now.
01:39:57 <quicksilver> so foo[0][1] should be the second element of the first row
01:40:04 <quicksilver> whereas in fact is the first element of the second row.
01:40:07 <int-e> ivanm: The code generated by ghc for the Word64->Double conversion on x86 is horrible.
01:40:32 <quicksilver> mmorrow: I've come to the conclusion that it really isn't all that great :)
01:40:36 <paczesiowa> anyone has some extra HSH code laying around? perhaps (-&&-) ?
01:40:43 <mmorrow> quicksilver: really. why?
01:40:45 <quicksilver> mmorrow: nicer just to use the underlying javascript functionality (canvas object)
01:40:53 <quicksilver> mmorrow: because Java is a horrid language compared to javascript.
01:41:06 <jdrake> quicksilver, I am afaid you have to deal with reality here, not haskellish mathematical thoughts
01:41:12 <mmorrow> quicksilver: ah yeah totally, that's kinda why i've delayed learning it. ;)
01:41:14 <quicksilver> jdrake: what does that mean.
01:41:20 <quicksilver> jdrake: I am dealing with reality.
01:41:28 <ivanm> int-e: oh? that's probably my problem then
01:41:29 <quicksilver> jdrake: foo is an array of arrays
01:41:33 <ivanm> any idea how to fix it?
01:41:34 <quicksilver> so foo[0] should be a an array.
01:41:41 <jdrake> quicksilver, it is
01:41:58 <ivanm> int-e: as in how should I use it if I want to generate doubles in [0,1) as well as integers
01:42:02 <quicksilver> if foo has the type (ComplexType)[height]
01:42:09 <quicksilver> then foo[0] shoulud have type (ComplexType)
01:42:16 <quicksilver> that's true in Java if ComplexType is an object
01:42:22 <quicksilver> but if ComplexType is a native array
01:42:28 <quicksilver> e.g. ComplexType == int[width]
01:42:35 <quicksilver> then foo[0] is backwards.
01:42:38 <quicksilver> that's just inconsistent.
01:43:08 <mmorrow> quicksilver: i've gotta get this js QQ organized an put it on hackage asap. i find it /really/ helpful.
01:43:12 <jdrake> #define x = 10 && y = 5  int array[x][y], then you would argue that you should access it like array[y][x]
01:43:45 <mmorrow> you can use it to essentially use haskell to code the js
01:44:04 <quicksilver> jdrake: yes, that's what I'm arguing.
01:44:12 <int-e> ivanm: no. there's a TODO item for it, but I haven't taken the time to investigate further. oh, and the performance is fine on x86-64, because ghc has a primop for converting Word# to Double#, and there, Word# = Word64#
01:44:16 <quicksilver> jdrake: obviously I see the sense in which it is confusing.
01:44:20 <jdrake> quicksilver, completely backwards to anyone who would program it for a living :p
01:44:28 <quicksilver> jdrake: no. not to me.
01:44:28 <mmorrow> but you don't /have/ to use it that way. it's pretty flexible
01:44:32 <quicksilver> and I program for a living.
01:44:32 <ivanm> int-e: :(
01:44:43 <ivanm> so on x86, -pure64 is less than useless?
01:45:00 <quicksilver> jdrake: anyhow, yes I see the sense in which it is confusing, but I'm pointing out the sense in which the way java does it is broken.
01:45:08 <quicksilver> which I'd never noticed before today.
01:45:14 <quicksilver> just an interesting inconsistency.
01:45:22 <jdrake> I don't do java, at best C
01:47:37 <quicksilver> well what I'm suggesting is consistent with the way the C type (int**) behaves.
01:48:21 <int-e> ivanm: for generating doubles, right now, yes. the rest should be fine. I guess I can whip up a patch that should help.
01:48:36 <quicksilver> in C I never use the 2D array declaration syntax; I always declare pointers or double pointers or 1D arrays.
01:48:43 <jdrake> Not so sure about that
01:48:57 <quicksilver> I use the 2D array *access* syntax, of course. That's fine. With ** types it works perfectly.
01:49:02 <jdrake> I take it you use x * w + y kind of stuff
01:49:06 <ivanm> int-e: well, it's the double generating that's slowing it down the most
01:49:29 <quicksilver> jdrake: not necessarily. Sometimes, yes. For rectangles, I normally would.
01:49:37 <quicksilver> jdrake: for ragged arrays, of course, I'd use **
01:49:54 <quicksilver> and it's with ragged arrays that the stupidity of the java declaration becomes clear.
01:50:05 <ivanm> I'm implementing the Wang-Landau algorithm, which requires me to randomly pick an element from a 2D list, and then generate a double [0,1) to see if I should flip that cell
01:50:39 <ivanm> so if -pure64 can't generate doubles for me in an efficeant fashion, then it's useless to me
01:50:45 <jdrake> quicksilver, in my youth I was programming an interface for a joystick within gwbaisc, and I had an if statement that had a good number of branches testing for each line right border - I obviously didn't know about extracting the x coordinate then :P
01:50:53 <ivanm> how about the IO version? (as much as I'd hate to use it...)
01:51:41 <jdrake> What is scary is stuff like that ends up in commercial software and on thedailywtf :p
01:51:49 <quicksilver> ivanm: why not just generate an Int and pretend it's in [0,1) in the obvious way?
01:51:53 <quicksilver> ivanm: (if performance is a factor)
01:51:57 <ivanm> quicksilver: the "obvious" way?
01:52:09 <quicksilver> by mapping 0 to 0 and maxBound+1 to 1
01:52:11 <ivanm> you mean randomInt / maxInt kind of stuff?
01:52:19 <quicksilver> yes, but you don't actually divide it
01:52:24 <quicksilver> you multiply everything else up
01:52:28 <quicksilver> so you can use integer math.
01:52:52 <_Dae_> Official side effect of haskell #341: You'll feel soiled and dirty after writing c++
01:53:16 <ivanm> not sure if that would work too well... esp. since the numbers I'm comparing it to would most likely not scale well themselves (i.e. won't round)
01:53:28 <ivanm> _Dae_: s/c++/any imperative langauge/
01:53:48 <jdrake> _Dae_, I think you feel soiled and dirty with any c++ program regardless of exposure to haskell.
01:54:08 <_Dae_> ivanm: I don't know why, but c++ seems particularly bad. Sometimes c allows you to do things elegantly, not haskell elegant, but still....
01:54:17 <jdrake> Now don't get me started on what [it feelsLikeTo: @"Program" in: @"Objective C"]
01:54:37 <_Dae_> jdrake: I thouhgt object c was supposed to be c++'s good twin?
01:55:07 <dfranke> "good" is a bit strong.
01:55:30 <dfranke> maybe "detectably less painful, eventually".
01:55:34 <jdrake> _Dae_, it is better than c++ for sure, but it is verbose like a guy who doesn't stop talking
01:56:42 <quicksilver> C++ allows you to do some things elegantly, of course.
01:56:48 <quicksilver> most successful languages have their good points.
01:56:54 <mapreduce> They probably all do better than: public static <T> T identity(T t) { return t; }
01:57:05 <quicksilver> but overall, C++ has more than its fair share of hideous.
01:57:15 <quicksilver> in most cases you can see/understand the motivation behind the hideous though.
01:57:36 <telexicon> i thought it was kind of interesting
01:57:36 <_Dae_> quicksilver: sure c++ can be elegant, but I guess I've yet to see that comming from the non-c part
01:57:40 <telexicon> c++ 'concepts'
01:57:45 <telexicon> kind of remind me of type classes
01:58:20 <quicksilver> it will be interesting to see how they work out.
01:58:40 <quicksilver> they are probably more like java interfaces than typeclasses
01:58:55 <telexicon> huh, how
01:59:03 <quicksilver> but there is something very odd about the way templates are purely 'textual'
01:59:12 <quicksilver> with no interaction with the type system
01:59:18 <telexicon> what are you talking about
01:59:20 <quicksilver> ...well, not until you get horrendous compile time errors :)
01:59:29 <telexicon> it does type checking >.>
01:59:46 <mapreduce> A template is not type checked until it's instantiated.
01:59:55 <telexicon> i guess
02:00:17 <jdrake> Just use the stl and try decoding their errors
02:00:33 <jdrake> GHC is usually uber clear compared tot hem
02:00:59 <quicksilver> telexicon: I mean the fact you can write a template which uses T.foo
02:01:06 <mapreduce> > 3 + -1
02:01:07 <lambdabot>       precedence parsing error
02:01:07 <lambdabot>          cannot mix `(+)' [infixl 6] and prefi...
02:01:08 <quicksilver> and there is nothing to check that there is a method foo on T
02:01:14 <quicksilver> or, indeed even foo(T)
02:01:20 <mapreduce> Wow, the stl errors must be bad.
02:01:22 <quicksilver> which might be some hideous C++ overloaded thingy.
02:01:34 <quicksilver> mapreduce: they've got a little better in recent versions.
02:01:42 <quicksilver> mapreduce: they used to be hideous beyond belief.
02:02:01 <quicksilver> mostly because many of the standard templates have hidden default parameters like which allocator to use
02:02:02 <telexicon> quicksilver, well not until its instantiated
02:02:07 <telexicon> but it does check at that point
02:02:10 <quicksilver> and they all got expanded out at error reporting.
02:02:18 <quicksilver> telexicon: yeah, I know. That's all I meant by weird.
02:02:31 <quicksilver> and of course that's what concepts are intended to solve.
02:02:31 <telexicon> well
02:02:36 <telexicon> i think another part of the reason
02:02:41 <mapreduce> What does a function 'do'?  Convert?  Map?  Transform?
02:02:53 <quicksilver> SGI recognised this problem write back in the first version of the STL
02:02:57 <telexicon> was g++ reduces a bunch of crap in the lexer
02:03:04 <int-e> ivanm: you could try  http://int-e.home.tlink.de/tmp/mersenne-pure64-double-for-32bits.patch  (diff -U style patch, not a darcs patch. if you want a darcs patch, I can provide that too)
02:03:07 <lambdabot> http://tinyurl.com/46ofu6
02:03:09 <telexicon> it strips out all your typedefs
02:03:39 <quicksilver> and indeed "concepts" existed in very early versions of the STL documentation
02:03:48 <quicksilver> but they were only that: documentation.
02:03:54 <telexicon> quicksilver, actually
02:04:02 <telexicon> SGI did figure out how to write some template metaprograms
02:04:04 <quicksilver> If anything was ever a clue they needed a better type system, there it was ;)
02:04:06 <telexicon> to do 'concept' checking at compile time
02:04:24 <telexicon> and that code that does that exists in gnu's stdc++
02:05:30 <int-e> ivanm: (in the Unit test program, that's about 3 1/2 times faster in the Double test, on my computer, which is an Athlon XP)
02:05:44 <ivanm> int-e: thanks!
02:05:59 <ivanm> 3.5x faster than previous version, or of StdGen?
02:06:12 <int-e> ivanm: than the previous version.
02:06:17 <ivanm> *nod*
02:06:22 <ivanm> how about compared to StdGen?
02:07:03 <ivanm> is this patch still safe for other arch's? i.e. would  it be OK to make this a standard patch for the gentoo-haskell overlay for everyone, or should I keep it to myself?
02:08:10 <int-e> ivanm: it's safe if unsigned long long is a 64 bit type (which is an assumption already made elsewhere). I'd like to know whether it's a regression on x86-64 first though.
02:08:19 <ivanm> *nod*
02:08:55 <Saizan> so, it looks like make -jN just dumps the output of the various jobs on stdout letting the lines interleave, is this usually considered acceptable?
02:09:32 <Deewiant> better than letting the characters interleave :-P
02:09:42 <quicksilver> make -j is a fairly simplistic hack, I think ;)
02:10:07 <int-e> Saizan: I suspect it's the line buffering of libc (etc.) at work, not any magic that make does.
02:10:48 <Saizan> yeah, better than the characters :)
02:11:19 <Saizan> so, i guess my question is, could we any do better?
02:11:38 <_Dae_> There should be a law forcing physicist to have at least 6 months of computer science education before writing software *grumples
02:11:44 <Deewiant> what would be better? waiting until a job is complete and then give all its output at once?
02:12:02 <Saizan> Deewiant: yeah, that's the first tought
02:12:11 <quicksilver> _Dae_: I'm not convinced that 6 months would make a sufficient difference ;)
02:12:35 <Deewiant> is that really better, though? is there something badly wrong with just interleaving?
02:12:37 <Saizan> Deewiant: the problem is if some job have a very long output you get problems with memory
02:13:15 <_Dae_> quicksilver: heh, one could hope it would make the software they write slightly less Cthulu like....
02:13:15 <Deewiant> yep, that too
02:13:31 <Saizan> well, interleaving makes the resulting output quite hard to read
02:14:05 <Deewiant> how is it harder than ordinary output? it's the most accurate representation of what's going on
02:15:18 <Saizan> in ordinary output you 1) know from which program each line comes from 2) they are consecutive
02:15:36 <Deewiant> how is 1) changed by interleaving
02:15:48 <Philonous> You could just dump the output of every thread into it's own logfile
02:16:06 <Philonous> And still interleave them on the screen
02:16:42 <quicksilver> different colours from the different threads!
02:16:57 <Saizan> Deewiant: i should have said from which process, with interleaving you've to add a tag to each line to know that
02:17:30 <Deewiant> so true, you don't know which thread is running which job, but is that important information?
02:17:57 <mapreduce> _Dae_: I expect that writing bad software is an essential precursor to writing good software.
02:18:33 <Saizan> you might not know what a message is referring to if you don't know which program invocation it belongs to
02:19:04 <Saizan> but i guess compiler errors usually refer to the file in the message itself
02:19:11 <Deewiant> possibly, yes; I'd argue that the message is poor in that case ;-)
02:19:46 <ivanm> int-e: hmmmm..... I can't seem to apply your patch :s
02:20:19 <_Dae_> mapreduce: one might hope it would be possible to learn from the mistakes of others?
02:20:47 <mapreduce> _Dae_: I think it's easier to learn from your own.  That can be accelerated though.
02:21:04 * ivanm thinks the problem might be due to a conflict between int-e's file naming system and gentoo's
02:21:43 <int-e> ivanm: uhm, which version of mersenne-random-pure64 are you using?
02:21:44 <_Dae_> mapreduce: well, problem is most physicist never write enough software to learn from their mistakes
02:22:04 <mapreduce> Then they never write enough to be a problem. :)
02:22:28 <_Dae_> mapreduce: sadly, this is only true if you, yourself, do not happen to be one.....
02:22:31 <ivanm> int-e: 0.1.1
02:22:52 <int-e> ivanm: ouch. you want 0.2 or later. that also explains your abysmal performance numbers.
02:22:57 <ivanm> oh, whoops, didn't notice that there's higher versions :s
02:23:09 * ivanm should remember in future not to trust pre-existing ebuilds
02:23:41 <int-e> ivanm: the patch applies cleanly to 0.2.0.2, but chances are that you wouldn't have complained about that version in the first place.
02:23:53 <ivanm> yup
02:27:54 * ivanm re-profiles his code and sees how it works with 0.2.0.2
02:30:48 <ivanm> yay for two cores! I can run my app at full bore _and_ upgrade cabal & co at the same time! \o/
02:32:31 <Saizan> you should have parallelized your app!
02:34:08 <paczesiowa> is it normal that code executed through runghc can't be ctrl-c'ed ?
02:39:02 <telexicon> as long as haskell has good 64bit support
02:39:29 <lilac> nasloc__:
02:39:39 <kaizoku> Do any of you use xmonad? I'm having trouble compiling xmonad.hs
02:39:39 <kaizoku> xmonad.hs:82:4: parse error on input `{'
02:39:45 <kaizoku> http://pastebin.com/d591c5da7
02:39:56 <kaizoku> I can't figure out what's the matter though :/
02:39:56 <lilac> mapreduce: i think that reading good software is the most/only essential precursor to writing good software myself...
02:40:05 <paczesiowa> kaizoku: there is #xmonad channel
02:40:23 <kaizoku> Yes, but it's very inactive
02:40:35 <mapreduce> lilac: Ok.  I don't know of a person who began well.  Did you?
02:40:47 <kaizoku> This is more of a haskell syntax problem than an xmonad problem unless I'm mistaken
02:41:18 <lilac> mapreduce: i honestly can't remember, but i was writing code in QBASIC, and such code has limits to how good it can be :D
02:42:40 <int-e> kaizoku: indent the { terminal          = "urxvtc" and the lines below at least one more space
02:42:50 <mapreduce> Indeed.  I recall Pascal being preferable to QBASIC.
02:42:57 <mapreduce> But that might have been a speed concern.
02:43:53 <kaizoku> Ahh, thanks int-e
02:44:14 <kaizoku> I'm not used to this layout stuff. I'm used to C where I can format it however I want to. :p
02:44:22 <quicksilver> lilac: I've never found reading software particularly useful.
02:44:33 <quicksilver> lilac: *debugging* other people's software sometimes gives me an appreciation for it.
02:44:52 <lilac> mapreduce: i learned C before Pascal, and remember being constantly annoyed by how hard it made easy things. now I've learned Haskell, I find the same to be true of C++ and Python :D
02:45:25 <lilac> quicksilver: how do you develop an aesthetic for determining whether code is good or bad without having read lots of code?
02:46:30 <mapreduce> Bad code has noise.
02:46:33 <quicksilver> lilac: experience with what works (turns out to be easy to modify / deploy / debug )
02:46:50 <quicksilver> lilac: my main metric is "good code is code that makes my job easy"
02:47:01 <lilac> ah, i take it you mostly work alone?
02:47:42 <quicksilver> not really.
02:47:46 <lilac> my opinion: "good" vs "bad" is obviously subjective, and working with others, it's really their opinion which is crucial, so your aesthetic and theirs need to be calibrated
02:47:49 <pjdelport> good code is what you don't notice
02:48:06 <quicksilver> I have read lots of other people's code, I'm just saying I didn't find that the most educating thing.
02:48:24 <quicksilver> partly because, if I see something unusual I don't necessarily appreciate the implications of it until I've actually worked with it
02:48:29 <quicksilver> (as opposed to just reading it)
02:48:41 <quicksilver> and then at that point I gain an appreciation of whether than unusual thing was good or bad.
02:50:00 <badri> @pl \x  -> \ f g -> (f x, g x)
02:50:01 <lambdabot> ap (flip . (((.) . (,)) .) . flip id) (flip id)
02:50:29 <badri> @pl \f g x -> (f x, g x)
02:50:29 <lambdabot> liftM2 (,)
02:51:02 <badri> Wow!
02:54:20 <badri> @pl \f -> \x -> (id x, f x)
02:54:21 <lambdabot> ap (,)
02:55:29 <badri> Can someone help me with the above if f were not a monad?
02:55:47 <BONUS> functions are monads
02:55:58 <BONUS> so if you can do f x, f is a monad
02:56:30 <badri> Oh but when I try let inx = liftM2 (,) (scanl (const . (+1) 1)) id it does not work
02:56:53 <badri> the function scanl (const . (+1)) 1 will return a list of indices
02:56:58 <badri> id will return the list
02:57:00 <BONUS> check out &&&
02:57:06 <badri> oh ok, thanks
02:57:15 <BONUS> > (id &&& (+3)) 10
02:57:16 <lambdabot>   (10,13)
02:57:29 <BONUS> > map (id &&& (*2)) [1,2,3,4,5]
02:57:31 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10)]
02:57:41 <badri> &&& is defined in?
02:57:47 <BONUS> Control.Arrow
02:58:17 <badri> Thank you!
02:58:21 <quicksilver> "functions are monads" is a bit confusing.
02:58:21 <BONUS> np :)
02:58:28 <quicksilver> "the function type is *a* monad"
02:58:34 <badri> That was awesome, BONUS!
02:58:45 <BONUS> yeah, quicksilver, i agree, i should have said it like that
02:58:59 <paczesiowa> map (second (*2)) [1,2,3,4,5]
02:59:03 <paczesiowa> > map (second (*2)) [1,2,3,4,5]
02:59:04 <lambdabot>       No instance for (Num (d, b))
02:59:04 <lambdabot>        arising from the literal `1' at <in...
02:59:07 <badri> So, what is this function "type" is a Monad concept? If so, why does it not work?
02:59:24 <paczesiowa> :t second
02:59:25 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
02:59:39 <BONUS> > second (*2) (1,1)
02:59:40 <lambdabot>   (1,2)
02:59:57 <paczesiowa> yeah, O confused &&& with ***
03:00:03 <gal_bolle> badri: did you import Control.Monad.Instances?
03:00:03 <paczesiowa> I confused
03:00:35 <badri> gal_bolle: No, let me try that
03:00:52 <gal_bolle> then ghc does not know about the concept either
03:01:22 <gal_bolle> i tried your code with that import, there is another error, but i guess it's just misbracketing
03:01:34 <badri> oh yeah, it is just misbracketing!
03:02:58 <gal_bolle> as for the function type as monad, type Tob a = a -> b is a one parameter type
03:03:25 <badri> @type Tob
03:03:26 <lambdabot> Not in scope: data constructor `Tob'
03:03:35 <badri> oh type Tob!
03:03:38 <gal_bolle> badri: i just made up the name
03:03:55 <badri> gal_bolle: yeah got it - a new data type
03:04:27 <badri> So, is any type a Monad?
03:04:45 <badri> Should'nt it satisfy the Monad laws?
03:04:52 <gal_bolle> sorry, it's Froma b = a -> b, got confused for a while
03:05:06 <quicksilver> badri: lots of types are not monads.
03:05:12 <gal_bolle> yes, and so you have to define return and >>= properly
03:05:13 <quicksilver> badri: it just happens that (a -> b) is one.
03:05:20 <quicksilver> badri: it does indeed satisfy the laws ;)
03:05:44 <badri> quicksilver, gal_bolle: thank you! will think about it for a min!
03:07:19 <gal_bolle> so for Froma, you have to define return as const, and (f >>= g) x = g (f x) x
03:07:45 <gal_bolle> and check they satisfy the laws
03:07:58 <badri> gal_bolle: hmm!
03:08:01 <gal_bolle> then you forget about my stupid type synonym
03:09:15 <badri> Since it satisfies the Monad laws now, should I declare fns from a (parameterized by b) as an instance of Monad and explicitly define return and >>= now?
03:09:54 <ivanm> int-e: it works!
03:10:20 <ivanm> using mersenne-twister-pure64 now takes half the run-time of StdGen! \o/
03:10:36 <int-e> ivanm: good. :)
03:10:39 <ivanm> (and producing random numbers is now no longer the highest-cost function)
03:10:46 <ivanm> and this is still without the patch!
03:11:30 <ivanm> how does one use the strictify program?
03:12:00 <int-e> ivanm: don't forget to tell dons :)
03:12:49 <ivanm> oh, yeah
03:12:53 <badri> Ok, so I have "let inx = liftM2 zip (init . (scanl (const . (+1)) 1)) id" to turn a list into an indexed list. Ex: inx [3,2,5,1] is [(1,3),(2,2),(3,5),(4,1)]. Can you shorten this?
03:13:17 <opqdonut> > zip [1..] [3,2,5,1]
03:13:18 <lambdabot>   Not in scope: `ï¿½'
03:13:21 <opqdonut> wat
03:13:30 <ivanm> @tell dons nvm, I was using v 0.1.1 of -pure64... upgrading to 0.2.0.2 makes it now half the runtime of StdGen (and 1/8th the runtime of 0.1.0.1), with random number generation no longer the main bottleneck
03:13:30 <lambdabot> Consider it noted.
03:13:33 <opqdonut> > zip [1..] [3,2,5,1]
03:13:35 <lambdabot>   [(1,3),(2,2),(3,5),(4,1)]
03:13:37 <opqdonut> there
03:13:38 <badri> Oh oh lazy lists and zip!
03:13:57 <badri> opqdonut: Thank you!
03:13:59 <opqdonut> np
03:14:05 <opqdonut> standard trick
03:14:10 <badri> I see
03:15:07 <J-roen> For a practical assignment I'm looking for examples of combining Control.Monad.State and Data.Map. Can somebody help me?
03:16:04 <gal_bolle> look for an interpreter for a toy language
03:16:14 <gal_bolle> they might have that
03:16:16 <opqdonut> yeah
03:16:18 <Saizan> J-roen: do you know anything about type inference/unification?
03:16:57 <J-roen> Saizan: I don't know really. So Maybe Yes :o)
03:17:09 * ivanm now sees what effect int-e's patch has
03:19:13 <J-roen> I have the types DB = Map Name Table and type DBM = State DB, but I don't know how I can put a new table into the state.
03:20:01 <Cale> modify (Map.insert key value)
03:20:33 * BeelsebobWork wonders why that needs state at all
03:20:57 <Cale> Well, there's no way to tell from what's given ;)
03:21:31 <J-roen> Cale: Sounds good. Should I care about the message No instance for (Show (DBM ())) ?
03:21:56 <Cale> you could add "deriving Show" to your data decl.
03:22:58 <J-roen> Cale: I don't think that's going to work, because DB and DBM are 'type's, not 'data's. But I'm no expert.
03:23:10 <badri> @pl \(x,_) (y,_) -> compare x y
03:23:10 <lambdabot> (`ap` snd) . (. fst) . (const .) . compare . fst
03:23:32 <Cale> oh
03:23:35 <BeelsebobWork> that's a shame
03:23:44 <Cale> Silly me, that's DBM ()
03:23:46 <BeelsebobWork> badri: compare `on` fst
03:23:56 <Cale> There'll never be a Show for that, right.
03:24:00 <pjdelport> liftA2 compare fst fst
03:24:10 <badri> BeelsebobWork: that's cool. Can you tell lambdabot that?
03:24:21 <BeelsebobWork> badri: good question
03:24:25 <BeelsebobWork> I dunno
03:24:45 <badri> badri: No probs. Thank you for your help! Let me see if that's possible
03:24:47 <J-roen> Cale: Okay, thanks very much.
03:25:31 <badri> BeelsebobWork: No probs. Thank you for your help! Let me see if that's possible
03:26:05 <Cale> (you could write an instance, but it wouldn't be able to do so much of interest)
03:26:46 <BeelsebobWork> Cale: is it possible to tell \bot about `on` for the purposes of @pl?
03:27:14 <Cale> BeelsebobWork: By hacking on the @pl plugin
03:27:44 <BeelsebobWork> ah, lame
03:29:09 <badri> I am unable to locate where on is defined. Is there a way systematic way I can search for this, or perhaps ask lambdabot?
03:29:20 <Valodim_> "on"?
03:29:20 <MyCatVerbs> badri: Data.Function.
03:29:23 <quicksilver> @index on
03:29:23 <lambdabot> bzzt
03:29:29 <quicksilver> badri: that's the way, but it didn't work.
03:29:31 <quicksilver> odd.
03:29:33 <Valodim_> http://www.haskell.org/hoogle/?q=on
03:29:34 <lambdabot> Title: on - Hoogle
03:29:45 <quicksilver> badri: you could try hoogle, ah, like Valodim just showed.
03:29:55 <pjdelport> @hoogle on
03:29:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:29:55 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
03:29:55 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:30:19 <MyCatVerbs> badri: one place to hit is the haskell hierarchical libraries documentation and hit the "index" link. http://haskell.org/ghc/docs/latest/html/libraries/index.html
03:30:20 <lambdabot> Title: Haskell Hierarchical Libraries
03:30:25 * Saizan wonders what @index uses
03:30:32 <MyCatVerbs> badri: better thing to do is Hoogle.
03:30:40 <badri> Great! Thank you for the suggestions. Hoogle is great!
03:31:42 <MyCatVerbs> Indeed, it really is.
03:32:35 <pjdelport> @hoogle (y -> y -> z) -> (x -> y) -> (x -> x -> z)
03:32:35 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:32:35 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
03:32:35 <lambdabot> Data.Generics.Basics gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
03:33:35 <quicksilver> Saizan: An index built with manual intervention, I think
03:33:40 <quicksilver> Saizan: it probably just needs updating.
03:33:47 <badri> pjdelport: That's an even cooler way with just the signature!
03:34:16 <quicksilver> @djinn (y -> y -> z) -> (x -> y) -> (x -> x -> z)
03:34:16 <lambdabot> f a b c _ = a (b c) (b c)
03:34:17 <pjdelport> yeah
03:34:23 <pjdelport> and that's even cooler :)
03:34:27 <quicksilver> badri: @djinn can even write the function from the type :)
03:35:02 <badri> quicksilver: that's unbelievable. I should try it!
03:35:23 <MyCatVerbs> Except that it gave you f a b c _ = a (b c) (b c), when what you actually wanted was f a b c d = a (b c) (b d).
03:35:48 <J-roen> Cale: How can I get the table back from the state? I don't understand how the 'get' function works.
03:36:01 <pjdelport> Djinns are tricksy that way
03:36:05 <MyCatVerbs> djinn considers all things of equal types to be interchangable. :)
03:36:08 <badri> hmm!
03:36:12 <quicksilver> MyCatVerbs: that's odd, actually. @djinn has a simplistic relevance hack which is supposed to prefer using distinct parameteres.
03:36:18 <quicksilver> MyCatVerbs: I wonder why it didn't apply to this case.
03:36:21 <Cale> J-roen: 'get' is an action whose result is the current state
03:36:34 <MyCatVerbs> quicksilver: sounds like it's just a heuristic.
03:36:36 <pjdelport> @djinn (y -> y -> z) -> (x -> y) -> x -> x -> z
03:36:37 <lambdabot> f a b c _ = a (b c) (b c)
03:36:48 <quicksilver> @djinn a -> a -> (a,a)
03:36:48 <lambdabot> f a b = (b, a)
03:36:49 <lilac> quicksilver: is it reusing the previous "find me something of type 'x'" result?
03:36:51 <quicksilver> ^^ for example.
03:36:55 <MyCatVerbs> quicksilver: heuristics, by definition, have bugs. If they didn't have bugs, then they would be algorithms. ;)
03:37:04 <quicksilver> MyCatVerbs: in this case, if it didn't have a bug, it would be a logic.
03:37:13 <quicksilver> yes, I think it's a heuristic.
03:37:21 <quicksilver> who wrote it? for some reason I think it was sjanssen ?
03:37:41 <ivanm> MyCatVerbs: would you really refer to them as "bugs"?
03:37:50 <lilac> @djinn (y -> y -> z) -> (x -> y) -> (x -> y) -> (x -> x -> z)
03:37:50 <lambdabot> f a b c d _ = a (c d) (b d)
03:38:03 <ivanm> bugs imply a problem in the implementation, whereas with heuristics there mighn't be a "right" solution
03:38:31 <MyCatVerbs> ivanm: I was quoting someone else.
03:38:35 <ivanm> ahhh
03:38:41 <ivanm> int-e: using your patch dropped the runtime by about another 33%! \o/
03:38:44 <ivanm> thansk, int-e!
03:38:47 <badri> lilac: oh yeah
03:38:49 <MyCatVerbs> ivanm: perhaps the terms "fleas" or even "quirks" would be more appropriate.
03:38:55 <ivanm> heh
03:38:55 <int-e> ivanm: wow.
03:39:16 <ivanm> from 248.72s to 172s
03:39:18 <int-e> ivanm: you must be generating a lot of random doubles :)
03:39:25 <Cale> J-roen: that is, if you write do m <- get; ...
03:39:28 <ivanm> int-e: yup ;-)
03:39:33 <Cale> J-roen: then m will be your Map
03:39:45 <ivanm> int-e: at least a few hundred thousand probably...
03:40:37 <J-roen> Cale: Okay, that sounds hopeful. I'm beginning to get desperate about this assignment...
03:42:57 <int-e> ivanm: ok, food for thought. maybe I'll find a x86-64 box to do some measurements on. But I suspect that the patch is a loss there.
03:43:22 <gal_bolle> english speakers:Â what's the 's' in asks supposed to mean (in opposition to ask). I find this naming odd
03:43:22 <Cale> J-roen: Let me know if you have trouble with that
03:43:35 <ivanm> int-e: *nod*
03:43:47 <Cale> gal_bolle: It is a little odd
03:43:50 <ivanm> I'm applying the patch to the gentoo-haskell overlay, but only for x86 machines atm
03:44:02 <quicksilver> gal_bolle: it's by analogy with 'gets'
03:44:07 <Cale> gal_bolle: The idea is that it makes an action which asks for a given part of the environment.
03:44:10 <quicksilver> I think they're both a bit odd.
03:44:30 <gal_bolle> yes, me too, i'd have gone for askThe, or askBy
03:44:53 <quicksilver> nono! no capital letters in the prelude!
03:44:54 <quicksilver> ;)
03:44:57 <int-e> ivanm: (on x86, converting a Word64 to Double involves constructing an Integer (ouch) from the Word64 and then go through encodeFloat. On x86-64 all that is a single primOp which becomes a couple of machine operations (a littel setup, one load from memory) in the native code generator.)
03:44:58 <ivanm> int-e: but going from 1400s to 170s is a great improvement in my books!
03:45:08 <ivanm> int-e: *nod*
03:45:18 <ivanm> why does the generator use Word64 in the first place?
03:45:24 <gal_bolle> quicksilver: ask is not in the prelude :p
03:45:27 <ivanm> to hard to make it arch-word agnostic?
03:45:32 <int-e> littel? little.
03:45:47 <J-roen> Cale: Can I get the table back with: do m <- get      t <- m.lookup name ?
03:46:13 <Cale> let t = Map.lookup name m
03:46:16 <int-e> ivanm: that would make the results unreproducible between 32 and 64 bits. besides, for generating doubles, you really need 64 bits. (53 to be precise).
03:46:29 <ivanm> *nod*
03:46:37 <BONUS> Map.lookup returns a Maybe though
03:46:38 <Cale> (the map lookup is not a State computation so you don't use <- )
03:46:39 <ivanm> then again, do you really need reproducibility?
03:47:04 <J-roen> Cale: Okay, that sounds logical. Should I be able to just return t now?
03:47:09 <int-e> ivanm: need? perhaps not. But it's part of this particular library's promises.
03:47:16 <ivanm> ahhh, k
03:47:37 <Cale> J-roen: you may
03:47:59 <Cale> J-roen: the resulting do-block will be a State computation which gets that particular table from the state
03:48:17 <J-roen> Cale: That's what I want :). However, this looks scary: Couldn't match expected type `Table' against inferred type `m a'
03:48:36 <Cale> aha, can I see what you wrote?
03:48:46 <Cale> It means that you tried to use a table as an action.
03:49:05 <J-roen> Cale: Ah, okay. I wrote: return t
03:49:09 <badri> @pl \f -> f .f
03:49:09 <lambdabot> join (.)
03:49:24 <Cale> J-roen: hmm...
03:49:28 <badri> > join (+1) 4
03:49:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a1
03:49:30 <lambdabot>      Prob...
03:49:37 <Cale> J-roen: maybe use hpaste to paste a little more of the context
03:49:49 <J-roen> Cale: Okay, I will.
03:49:49 <badri> > join (.) (+1) 4
03:49:50 <lambdabot>   6
03:49:51 <Cale> http://hpaste.org/new
03:50:29 <J-roen> Cale: http://hpaste.org/11190
03:51:43 <BONUS> M.lookup name m returns a Maybe something, you have to take that into account
03:51:46 <Cale> ah
03:51:52 <Cale> yeah
03:52:07 <J-roen> BONUS: Sorry, I missed your first message. Thanks.
03:52:07 <Cale> J-roen: What should happen if the lookup fails to find something?
03:52:09 <BeelsebobWork> BONUS: does it, I thought it returned a Monad m => m a
03:52:23 <BONUS> BeelsebobWork: ah yeah, I always forget that
03:52:24 <Cale> BeelsebobWork: In the old version of the library.
03:52:28 <J-roen> Cale: Nothing should happen then.
03:52:38 <BONUS> still, it returns a m something instead of just that something
03:52:40 <Cale> J-roen: What should be returned from the computation?
03:52:46 <badri> I have a fn " let r = join (.) (\x -> map fst $ sortBy (compare `on` snd) $ zip [1..] x) " to get the ranking of a list so that  r [5,7,3,9,4] = [3,4,1,5,2]. Can I get rid of the lambda in def of r and make it point free? Is it a painful way of getting ranking?
03:52:58 <J-roen> Cale: What are the options? :$
03:53:07 <BONUS> StateT with Maybe is one of them
03:53:22 <Cale> J-roen: Well, you could have the thing give a  Maybe Table  rather than just a Table
03:53:30 <J-roen> Cale: That's okay.
03:53:49 <Cale> J-roen: Just change the type signature to getTable :: TName -> DBM (Maybe Table)
03:54:38 <J-roen> Cale: I did, this seems to work :). However, no I have a DBM (Maybe Table). I don't think I can print that.
03:55:00 <Cale> J-roen: Well, you have to run your state computation to get a result.
03:55:14 <Cale> The result that'll be produced depends on the initial state you pass in.
03:55:23 <J-roen> Cale: Is that the function runTable?
03:55:25 <J-roen> Ehh
03:55:27 <J-roen> runState?
03:55:33 <Cale> evalState (...) initialTablesMap
03:55:51 <Cale> where (...) is the DBM computation you'd like to run.
03:56:02 <Cale> Or runState
03:56:19 <Cale> (which will give you the final state as part of its result as well)
03:58:25 <badri> > (join (.) $ map fst . sortBy (compare `on` snd) . zip [1..] ) [5,7,3,9,4]
03:58:26 <lambdabot>   [3,4,1,5,2]
03:58:55 <badri> Can I compress that ranking function any further?
03:59:41 <pcapriotti> is this instance anywhere in the libraries? http://hpaste.org/11191
04:00:26 <lilac> > (join (.) $ map snd . sort . flip zip [1..]) [5,7,3,9,4]
04:00:27 <lambdabot>   [3,4,1,5,2]
04:00:49 <J-roen> Cale: So I should be able to apply runState to a DBM (Maybe Table)?
04:01:34 <Cale> J-roen: yep
04:01:44 <quicksilver> badri: sure. omit the unnecessary whitespace ;)
04:02:14 <Cale> badri: That join (.) is strange... you're sure you want to permute the rankings like that?
04:02:26 <badri> quicksilver: haha!
04:02:42 <Cale> er...
04:02:45 <badri> Cale: join (.) applies the fun twice
04:02:49 <Cale> yeah
04:03:07 <badri> Cale: cool. There must be a better way
04:03:24 <badri> Cale: I am using two sorts because I want to make this O(n log n) too
04:03:45 <badri> Cale: A more direct approach will be great, provided I can get it pointfree!
04:04:35 <badri> I googled some notes for this approach: http://www.stat.lsa.umich.edu/~kshedden/Courses/Stat606/Notes/sorting.pdf
04:04:40 <lambdabot> Title: Sorting, Ranking, Indexing, Selecting, http://tinyurl.com/53b6uu
04:04:46 <ivanm> int-e: can you suggest what would be faster/more efficient to get a random Int in a specified bound? getting a double and then scaling+rounding, or modding a randomInt?
04:05:39 <Cale> badri: aha, I see what you're doing
04:06:14 <Cale> badri: You want the ranking and not the permutation, so you apply the permutation to itself. Neat.
04:06:20 <int-e> ivanm: hmm, modding a randomWord is faster I suspect.
04:06:42 <ivanm> oh? didn't think of that...
04:07:32 <badri> Cale: Exactly. Not my original trick as I first thought :( because google showed me a notes doing precisely that!
04:10:37 <badri> Cale: The right way of stating it would be that I want the inverse permutation. So calling this the second time will find the permutation that resorts the permutation (hence, inverse). but yeah
04:10:47 <Cale> yeah.
04:11:04 <Cale> okay, yeah, I see that.
04:15:12 <Cale> > join (.) (map fst . sortBy (comparing snd) . zip [1..]) $ [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,5]
04:15:14 <lambdabot>   [1,10,2,14,3,11,4,16,5,12,6,15,7,13,8,17,9,18]
04:16:16 <Cale> Too bad $ isn't left associative ;)
04:16:35 <rog_> i have a feeling this is a really stupid question, but... does anyone know how to install a cabal package into the macports version of ghc. i tried the naive, "follow the instructions" approach (http://tinyurl.com/39kra4), and ghc didn't find it. i also tried copying the resulting dirs into /opt/local/lib/ghc-6.8.2/lib, which didn't work either.
04:16:47 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
04:17:15 <badri> Cale: Can you explain how left associativity would help? Thanks
04:17:27 <quicksilver> rog_: erm, you don't really explain to us what you mean.
04:17:33 <quicksilver> rog_: "ghc didn't find it"?
04:17:48 <quicksilver> rog_: I've had no trouble install cabalised packages into my macports
04:17:52 <Cale> you could put a $ after the join (.) in that expression and get rid of the parens around the second arg to join
04:17:54 <J-roen> Cale: Somehow I can't get Table out of DBM (Maybe Table). Can runState really help me with that?
04:18:13 <Cale> J-roen: evalState should get you a Maybe Table
04:18:42 <rog_> quicksilver: ok. i've got a cabal package i want to install. i tried untarring it, running Setup build, configure and install. which seemed to work. but i'm unable to import the package.
04:18:53 <J-roen> Cale: Okay, I'll try that.
04:18:54 <vininim> @hoogle (t,t) ->[t]
04:18:55 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
04:18:55 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
04:18:55 <lambdabot> Prelude snd :: (a, b) -> b
04:19:01 <Cale> :t runState
04:19:02 <quicksilver> rog_: did you sudo before the install?
04:19:03 <lambdabot> forall s a. State s a -> s -> (a, s)
04:19:04 <rog_> quicksilver: (ghc says "cannot find module"
04:19:07 <rog_> quicksilver: yes
04:19:09 <badri> > (join(.)$map fst.sortBy(compare `on` snd).zip[1..]) [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,4,1,5]
04:19:10 <quicksilver> rog_: does ghc-pkg list show it as installed?
04:19:10 <lambdabot>   [1,10,2,14,3,11,4,16,5,12,6,15,7,13,8,17,9,18]
04:19:32 <badri> Cale: Ah, I see what you mean
04:19:44 <quicksilver> rog_: what was the package? what module did you try to import? how are you calling ghc?
04:19:46 <Cale> J-roen: (which is the same as the first component of the result of runState)
04:20:07 <idnar> :t evalState
04:20:08 <lambdabot> forall s a. State s a -> s -> a
04:20:12 <rog_> quicksilver: ghc-pkg list does show it as installed.
04:20:27 <rog_> quicksilver: the packages were data-accessor and data-accessor-template
04:20:38 <rog_> quicksilver: i'm calling ghc as ghci
04:21:22 <quicksilver> have you restarted ghci?
04:21:58 <rog_> no.
04:21:59 <rog_> ah
04:22:06 <J-roen> Cale: :t evalState (getTable "name")   gives me   evalState (getTable "name") :: DB -> Maybe Table
04:22:07 <quicksilver> it reads the package database at startup.
04:22:46 <Cale> J-roen: yep
04:22:55 <J-roen> So that's a DB -> Maybe Table
04:22:56 <Cale> J-roen: so you need to pass in an initial DB
04:23:00 <J-roen> Cale: Okay
04:23:08 <hugo_> http://www.itjobswatch.co.uk/jobs/uk/haskell.do
04:23:10 <hugo_> :P
04:23:12 <lambdabot> Title: Haskell Jobs, Average Salary for Haskell Skills
04:24:03 <rog_> quicksilver: right, that works now (after i undid the bogus directory move). thanks! i'm used to dynamic searching...
04:24:13 <J-roen> Cale: How do I get an initial DB?
04:24:25 <quicksilver> rog_: remember GHC is a compiler :) it's actual object code.
04:24:27 <Cale> Well, it's a Data.Map right?
04:24:34 <quicksilver> rog_: and once it's loaded, it's not reloaded again that session.
04:24:35 <Cale> From TName to Table?
04:24:38 <J-roen> Cale: type DB = Map TName Table
04:24:44 <Cale> Yeah.
04:24:59 <Cale> J-roen: So what tables are in the state initially?
04:25:11 <Cale> J-roen: Should it perhaps just be  Map.empty ?
04:25:12 <quicksilver> rog_: of course, maybe ghci could check the modification data on the package list and restart the session when you've installed new packages but this doesn't happen often.
04:25:24 <J-roen> Cale: None, I add them at runtime.
04:25:41 <rog_> quicksilver: it could easily.
04:25:45 <badri> Suppose I have two 3-tuples and I want to sort first on the first attribute, then the next, and finally the third, how do I go about it?
04:25:51 <badri> I start with compare on
04:25:55 <Cale> J-roen: okay, then Map.empty
04:26:00 <rog_> quicksilver: i didn't realise that it maintained an independent package list.
04:26:12 <quicksilver> it's not really a question of maintaining naything
04:26:19 <quicksilver> just a question of reading DBs at startup time
04:26:22 <quicksilver> not before every operation :)
04:26:24 <J-roen> Cale: Okay, now it seems to do something.
04:26:48 <J-roen> Cale: Why do I need to pass an initial DB?
04:26:55 <rog_> quicksilver: the overhead is surely trivial, given how relatively rarely modules are loaded...
04:27:08 <Cale> J-roen: Well, what else would it use?
04:27:16 <rog_> quicksilver: all it would take would be a single stat/open...
04:27:29 <J-roen> Cale: I'd like to use the map that I'm working with.
04:27:42 <Cale> J-roen: Well then pass that in :)
04:27:43 <quicksilver> rog_: it's all the code to write to unload .o files and check symbol tables and reload everything, in a running RTS
04:27:48 <quicksilver> rog_: which would be a hassle.
04:27:57 <J-roen> Cale: Okay, so I have to use it in my getTable function (http://hpaste.org/11190).
04:28:12 <Cale> J-roen: what?
04:28:29 <Cale> J-roen: getTable produces a DBM computation
04:28:37 <rog_> quicksilver: i wouldn't expect unload/reloading of an already loaded module. just that if it can't find a module, it would go away and look for it.
04:28:39 <Cale> evalState will *run* a DBM computation
04:28:51 <J-roen> Cale: Okay, but how can I access my state then?
04:28:52 <badri> My first pass of compare by three attributes would be  cmp3 (x1,y1,z1) (x2,y2,z2) -> case compare x1 y1 of {EQ -> (case compare x2 y2 ..), y -> y}, but it quickly becomes clumsy
04:28:54 <rog_> quicksilver: (but i'm not complaining. i know what to do now!)
04:29:11 <Cale> J-roen: from inside a DBM computation, call get
04:29:19 <J-roen> Cale: I'm trying this now:   printTable (evalState (getTable "name") M.empty)
04:29:52 <Cale> J-roen:  (evalState (getTable "name") M.empty) should correctly give you Nothing
04:30:26 <Cale> Because there are no tables in the initial state to find "name" in.
04:30:30 <J-roen> Cale: That's right.
04:30:45 <J-roen> Cale: So how can I pass the map that I put into the state?
04:30:55 <Cale> Which map?
04:30:59 <quicksilver> badri: well it's already built in
04:31:04 <quicksilver> > (1,2,3) < (1,2,4)
04:31:05 <lambdabot>   True
04:31:26 <idnar> :t cmp
04:31:27 <badri> quicksilver:Didn't expect that! great
04:31:28 <lambdabot> Not in scope: `cmp'
04:31:33 <J-roen> Cale: Well, the map that I'm working with. At some other point I did this, right?   modify (M.insert name (Table columns []))
04:31:40 <badri> :t compare
04:31:41 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:31:52 <Cale> J-roen: Each DBM computation is internally a function from an initial  Map TName Table  to a pair consisting of a final  Map TName Table  and a result.
04:31:53 <idnar> > compare (1,2,3) (1,2,4)
04:31:55 <lambdabot>   LT
04:31:56 <quicksilver> badri: lexicographic
04:32:00 <quicksilver> badri: lists too
04:32:03 <idnar> oh duh
04:32:05 <quicksilver> > compare [1,2,3] [1,2,4]
04:32:07 <lambdabot>   LT
04:32:12 <idnar> @src Ordering
04:32:12 <lambdabot> data Ordering = LT | EQ | GT
04:32:13 <badri> quicksilver: wow!
04:32:29 <badri> quicksilver: how did they code this?
04:32:39 <J-roen> Cale: Okay, I don't get why this isn't documented anywhere.
04:32:44 <Cale> J-roen: it is
04:33:08 <J-roen> Cale: Well, I'm not that smart that I can interpret all the formulas. I'm better in understanding words.
04:33:35 <Cale> You'd probably like a tutorial on the state monad... there are quite a few of those, but many of them are terrible. ;)
04:33:50 <Cale> I suppose I could explain how it works.
04:34:00 <J-roen> Cale: Yeah, you're right :). I have looked for it already.
04:34:09 <J-roen> Cale: Well, if you have time for that...
04:34:18 <Cale> Come to #haskell-overflow so we have a little less distraction
04:34:23 <J-roen> Okay
04:35:02 <papermachine> Yay State
04:35:23 <quicksilver> badri: well the list one isn't hard.
04:35:32 <quicksilver> badri: the tuple one is a bit of a compiler trick.
04:36:02 <badri> quicksilver: list one is just coded as a recursion?
04:36:15 <badri> quicksilver: yeah, must be
04:38:40 <badri> I need to get a list of lines from a file as an array. So, in main, I do, myArray <- liftM lines (getArgs >>= (readFile . head)) -- This seems really ugly: Is there a standard trick for this, since it is so common?
04:40:22 <zachk> why do you need an array
04:40:25 <BONUS> you can put it into a separate function
04:40:32 <zachk> if thats ugly do as bonus says
04:40:59 <BONUS> usually its good to have functions that do IO and functions that do the logic separated
04:41:04 <badri> zachk: I am reading a set of DNA sequences separated by newline from a file into array
04:41:24 <badri> BONUS: thank you, I will do that.
04:41:29 <zachk> why do you need an array? speed?
04:41:39 <quicksilver> he isn't using an array
04:41:45 <quicksilver> I think that was a poor choice of words.
04:41:46 <quicksilver> it's a list.
04:41:57 <badri> quicksilver: yeah, it's a list
04:42:02 <zachk> but you get 0(n) for list!!index
04:42:15 <badri> then I am using listArray to construct an array.
04:42:33 <zachk> are you seeking patterns or modifying the array
04:44:43 <badri> zachk: I am constructing a list of pairs of this array which will be potential edges in a graph I am creating.
04:44:44 <electronx> hahah brilliant i'm brute forcing my uni project
04:45:01 <electronx> coming out so good i can't belive it
04:45:54 <badri> zachk:  I have coded out the whole thing so it will find a hamiltonian path in that graph, but I'm now using the wisdom of this channel to shorten the code. Thank you everybody!
04:46:42 <electronx> whenver in doubt brute force to the rescue
04:49:54 <electronx> anyone know how to put a process in the background so that i can leave it running on my uni comps overnight?
04:50:10 <electronx> so i can logoff and leave it running
04:50:50 <gal_bolle> electronx: man nohup
04:50:56 <electronx> thanks
04:51:50 <badri> @pl \xs -> listArray (1,length xs) xs
04:51:51 <lambdabot> listArray =<< (,) 1 . length
04:52:44 <badri> > (listArray =<< (,) 1 . length) [5,2,5,7,8]
04:52:46 <lambdabot>   array (1,5) [(1,5),(2,2),(3,5),(4,7),(5,8)]
04:54:45 <badri> Is there an idiomatic way of constructing an array from list of unknown size?
04:55:22 <badri> My current (ugly) solution is (listArray =<< (,) 1 . length) list
04:55:35 <quicksilver> :t listArray
04:55:36 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
04:56:00 <quicksilver> I think you may have become too keen on point free code :)
04:56:16 <badri> quicksilver: haha, true!
04:56:19 <quicksilver> I do not personally find that more readable than "listArray (1,length list) list"
04:56:56 <badri> quicksilver: You are right - I should kick that addiction. Thanks for reminding. I have been enlightened :)
05:07:46 <sheyll> hmm How do I get the submatches of a regular expression match?
05:09:24 <quicksilver> sheyll: by calling the right version of the match operator :)
05:09:29 <badri> I have a foldl where I'd like to stop reducing when a predicate is false instead of going all the way to the end of the list. One way I can think of is using takeWhile predicate scanl and extracting the last element. Is there a better method?
05:09:50 <quicksilver> sheyll: there are four thousand variants  returning different stuff.
05:10:06 <quicksilver> badri: dropWhile + scanl makes slightly more sense
05:10:08 <badri> takeWhile predicate scanr at least won't scan the entire list because of laziness I guess
05:10:16 <badri> oh yeah
05:10:25 <quicksilver> head . dropWhile (not . predicate) . scanl
05:10:36 <badri> thanks
05:11:10 <badri> and this is because it is easier to get the head compared to tail?
05:11:40 <badri> sorry, head easier than last...
05:11:42 <quicksilver> yes.
05:11:47 <quicksilver> doesn't force you to rescan the list
05:11:47 <badri> quicksilver: thanks
05:11:49 <lilac> badri: or you could use foldr
05:12:10 <lilac> (assuming that's appropriate in your case)
05:12:39 <badri> lilac: Must I use foldr to force laziness?
05:13:30 <lilac> it depends on whether your combining function is strict
05:13:57 <badri> lilac:In my case, both should work as it is a finite list
05:14:10 <badri> lilac: Does the combining fn matter in a finite list?
05:15:11 <lilac> badri: if the list is big enough, it can make a difference in practice.
05:15:31 <badri> lilac: one more thing, if I use foldr, I don't even have to do the scan, drop etc., to stop on a predicate?
05:15:39 <badri> lilac: ok thanks
05:15:51 <badri> lilac: actually ignore my q. It is quite silly!
05:16:00 <lilac> badri: if your foldr combining function doesn't use / force the right-side of the fold, it won't get computed
05:16:21 <badri> lilac: got it - thanks
05:16:44 <lilac> > foldr (\a b -> if a < 10 then (a:b) else []) [] [1..]
05:16:46 <lambdabot>   [1,2,3,4,5,6,7,8,9]
05:17:00 <sheyll> quicksilver: I want to get an array of submatches...can you give me a hint?
05:17:20 <badri> lilac: sweet! thanks for the example
05:18:33 <badri> There seem to be some excellent Haskellers here. Are you students/professors/professionals or just hobby programmers like me?
05:19:30 <badri> It will be nice to know what category *most* experts fall into. I understand there is a big mix here
05:19:43 <BONUS> wouldnt know, im not an excellent haskeller hehe. but me personally im a CS student doing haskell (its not in my university's cirriculum though)
05:20:28 <badri> BONUS: cool. We must encourage more Haskell in Univs! Unfortunately, I am not even a CS student
05:21:35 <BONUS> yeah, i wish my uni did haskell. imho you dont have to be a CS student to learn stuff, you just gotta be willing to learn
05:21:43 <Saizan> there was an high concentrantion of PhDs when the channel was smaller :)
05:21:55 <badri> hmm!
05:22:34 <badsheepy> my uni does haskell, and the vast majority of the year i was in hated every moment of it
05:22:56 <BONUS> i was just thinking today what my perception of haskell would be if i was forced to do it in uni
05:23:02 <badsheepy> not so much the language or anything i dont think, just the entire paradigm
05:23:05 <BONUS> with a limited timeframe and everything
05:23:16 <BONUS> versus just fiddling with it by myself like i did
05:24:09 <badri> hm. An advanced course in a univ can force you to learn at least vaguely in the first pass things you may never encounter by fiddline
05:24:13 <badri> fiddling(
05:24:19 <badri> converse is true too..
05:24:36 <BONUS> yeah, the thing with fiddling though is you have all the time in the world
05:24:52 <BONUS> so if you dont manage to grasp a concept, the cirriculum doesnt fly past you
05:24:53 <electronx> badri: its all about discipline
05:25:05 <badri> electronx: I agree!
05:25:08 <Saizan> i guess a lot of people can react badly if they feel evangelized by the teacher
05:25:11 <Valodim_> my uni does... java :"(
05:25:13 <electronx> if you have it you can learn anything taught at uni
05:25:27 <electronx> heh my uni does C
05:25:39 <badri> oh
05:25:45 <electronx> be happy with java
05:26:11 <BONUS> we do Java, C, prolog, R and a few other languages at uni
05:26:22 <badri> haha, I don't think we are going to have C vs Java here, unless we are discussing haskell-y features!
05:26:38 <Saizan> R?
05:26:45 <BONUS> yeah, R
05:26:45 <badri> statistcical language
05:26:57 <badri> www.r-project.org
05:27:06 <Saizan> thanks
05:27:15 <BONUS> its just for the statistics class though
05:27:41 <Saizan> i see
05:28:17 <badri> that reminds me: Does Haskell have any linear algebra library? I want to do a lot of statistics and lin alg. Do I have to write them myself?
05:28:32 <badri> oh cool - found Hblas!
05:28:33 <Saizan> there's hmatrix
05:28:57 <badri> hmatrix.. hmm must see. Thanks Saizan
05:30:42 <badri> Saizan: hmatrix fits my needs perfectly. Thanks Saizan
05:31:36 <badri> How wonderful it is if you can code everything in Haskell itself! Must give back to this community
05:32:16 <Saizan> hehe, ahackage is there for a reason :)
05:33:23 <badri> hmm, looks like CPAN for haskell. more like rubygems
05:39:23 <badri> @djinn (a -> b -> b) -> b -> [a] -> b
05:39:23 <lambdabot> Error: Undefined type []
05:39:40 <badri> (a -> b -> b) -> b -> M a -> b
05:39:57 <badri> @djinn (a -> b -> b) -> b -> M a -> b
05:39:57 <lambdabot> Error: Undefined type M
05:40:18 <chrisdone> M is not a type variable
05:40:41 <badri> hmm, I actually wanted to do lists, but then tried monads instead
05:40:46 <chrisdone> yeah
05:40:46 <badri> anyway I can fix this?
05:41:27 <chrisdone> dunno
05:41:28 <chrisdone> @djinn (a -> b -> b) -> b -> m a -> b
05:41:29 <lambdabot> f _ a _ = a
05:41:42 <badri> oh!
05:42:09 <gal_bolle> @hoogle (m Bool -> m a -> m a -> m a)
05:42:09 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
05:42:09 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
05:42:09 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
05:43:31 <gal_bolle> @pf (do x <- True ; return $ if x then b else c)
05:43:31 <lambdabot> Maybe you meant: bf pl
05:43:39 <gal_bolle> @pl (do x <- True ; return $ if x then b else c)
05:43:39 <lambdabot> (line 1, column 15):
05:43:39 <lambdabot> unexpected ";"
05:43:39 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
05:43:48 <Cale> badri: djinn doesn't know about recursion
05:43:52 <gal_bolle> @pl {do x <- True ; return $ if x then b else c}
05:43:52 <lambdabot> (line 1, column 1):
05:43:52 <lambdabot> unexpected "{"
05:43:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:44:12 <gal_bolle> @undo {do x <- True ; return $ if x then b else c}
05:44:13 <lambdabot>  Parse error at "{do" (column 1)
05:44:16 <badri> Cale: I see..
05:44:22 <gal_bolle> @undo do {x <- True ; return $ if x then b else c}
05:44:22 <lambdabot> True >>= \ x -> return $ if x then b else c
05:45:03 <gal_bolle> @undo do {x <- t ; return $ if x then b else c}
05:45:03 <lambdabot> t >>= \ x -> return $ if x then b else c
05:45:39 <gal_bolle> @undo do {x <- liftM p b ; return $ if x then b else c}
05:45:39 <lambdabot> liftM p b >>= \ x -> return $ if x then b else c
05:46:14 <BeelsebobWork> gal_bolle: if' <$> c <*> t <*> e is probably what you're looking for
05:46:24 <BeelsebobWork> though with a hoop or two more for you to jump through
05:46:35 <gal_bolle> thanks
05:46:47 <chrisdone> that's hot!
05:47:10 <gal_bolle> if' is not in the standard lib
05:47:19 <chrisdone> is it in MissingH?
05:47:22 <BeelsebobWork> gal_bolle: no, it's one of the biggest missing pieces
05:47:30 <BeelsebobWork> if' c t e = if c then t else e
05:47:52 <gal_bolle> yes, but it means that undoing is not worth it
05:48:02 <chrisdone> <condition> <subsequent> <what's the else part called?>
05:48:03 <BeelsebobWork> yeh
05:48:21 <BeelsebobWork> chrisdone: I always call them the condition, then branch and else branch
05:48:41 <BeelsebobWork> and I can't think of a word meaning "doesn't follow"
05:50:26 <mapreduce> otherwise
05:51:24 <chrisdone> if you call it otherwise you mean as well call the subsequent "then"
05:51:37 <mapreduce> Except that then is a keyword.
05:51:44 <BeelsebobWork> yeh, but if you call it the subsequent, then really you should call the condition the precident
05:51:53 <mapreduce> Or antecedent.
05:51:54 <BeelsebobWork> the thing required before the subsequent will happen
05:51:57 <badri> if <predicate> <consequent> <alternative>
05:52:07 <badri> SICP notation!
05:52:12 <chrisdone> that's the one
05:52:12 <ivanm> int-e: actually, modding randomWord proved slower than modding randomInt (it undid all the advantages of the patch!)
05:52:32 <mapreduce> Consequent and happen seem to have time embedded in them.
05:53:37 <badri> Subsequent does, Consequent only means logical conclusion...
05:53:44 <int-e> ivanm: hmm, odd. which ghc version are you using, 6.8.3?
05:53:49 <badri> debtable.
05:53:52 <badri> debatable*
05:53:52 <ivanm> int-e: yup
05:54:39 <badri> mapreduce: http://tfd.com/subsequent vs http://tfd.com/consequent
05:54:41 <lambdabot> Title: subsequent - definition of subsequent by the Free Online Dictionary, Thesaurus a ...
05:55:00 <badri> mapreduce: SICP Authors are very careful ;)
05:55:43 <chrisdone> the SICP definition was actually the one I was initially trying to think of
05:56:06 <ivanm> is there a rule of thumb for when inlining would be beneficial?
05:56:16 <quicksilver> ivanm: "always"
05:56:20 <quicksilver> is the rule of thumb ;)
05:56:29 <ivanm> heh
05:56:36 <ivanm> well, can't you over-inline your code?
05:56:49 <quicksilver> the specific advantages of inlining in GHC are that it enables other optimisations
05:57:01 <mapreduce> You can ask the JVM to inline everything, and that makes the resultant machine code slow.
05:57:01 <quicksilver> specifically RULES only trigger if they can 'see' the functions
05:57:10 <mapreduce> Probably because it's large.
05:57:27 <quicksilver> so RULES need inline to work, in many cases.
05:57:42 <ivanm> RULES?
05:57:44 <quicksilver> (but there are other specific optimisations other than RULES also affected)
05:57:49 * ivanm goes look up the RULES pragma
05:57:57 <quicksilver> things like map f . map g = map (f.g)
05:58:07 <ivanm> ahhhh
05:58:14 <ivanm> re-write rules?
05:58:23 <quicksilver> suppose foo = map f; bar = map g; foo.bar won't optimise
05:58:26 <quicksilver> unless foo and bar inline
05:58:33 <quicksilver> and then the maps are 'visible'
05:58:34 <ivanm> *nod*
05:58:40 <ivanm> quicksilver: even with fusion? :o
05:59:07 <ivanm> OK, what about UNPACK? what does that do?
05:59:15 <quicksilver> ivanm: this *is* fusion that I'm talking about.
05:59:19 <ivanm> ahhh
05:59:20 <chrisdone> do list comprehensions transform into functions that can be inlined or are they specially optimised by the compiler?
05:59:21 <quicksilver> a specific case of it.
05:59:24 <ivanm> oh, wait, just found the ghc docs for it
05:59:30 <quicksilver> chrisdone: they transform into normal functions.
05:59:36 <quicksilver> chrisdone: for which there are optimisation rules
05:59:49 <chrisdone> okay
05:59:55 <quicksilver> chrisdone: but, if you wrote the normal funcitons by hand in stead
05:59:57 <quicksilver> taht woudl be fine
06:00:25 <Cale> (mostly concatMap)
06:00:27 <ivanm> quicksilver: but there has to be some way of knowing when an INLINE would do some good...
06:00:39 <ivanm> surely you don't go and write INLINE for every function you define...
06:01:10 <chrisdone> :t concatMap
06:01:11 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:01:21 <Cale> I don't think I've ever seen an explicit INLINE pragma. Only NOINLINE.
06:01:35 <chrisdone> I've seen some in standard libs, IIRC
06:01:36 <ddarius> It's occasionally useful to have one.
06:01:48 <ivanm> Cale: oh? why wouldn't you want to inline something?
06:01:53 <Saizan> there are some in the binary package, for example
06:01:54 <ddarius> Most of the time the compiler does the right thing.
06:02:02 <ddarius> ivanm: The compiler inlines itself.
06:02:14 <Cale> ivanm: One reason is because it's doing evil things like unsafePerformIO, for example.
06:02:21 <ddarius> For example, foo and bar above would always inline when fully applied.
06:02:22 <ivanm> ddarius: so in most cases it knows what to inline?
06:02:24 <papermachine> Yay unsafePerformIO
06:02:29 <ivanm> Cale: ahhhhh
06:02:42 <ddarius> ivanm: It has some heuristics just like every other optimizing compiler.
06:02:45 <ivanm> ddarius: but if they're not fully applied?
06:02:48 <ivanm> ddarius: *nod*
06:03:07 <Cale> unsafePerformIO is hard enough to reason about without the inliner jamming it into other things :)
06:03:36 <ddarius> If they're not fully applied, there probably isn't anything to inline, but I'm not sure what the exact rules are.  You can always just look at the output of the optimizer.
06:03:47 <ddarius> :t inlinePerformIO
06:03:49 <lambdabot> Not in scope: `inlinePerformIO'
06:03:49 <quicksilver> the intermodule inlining threshold is different from the intRAmodule inlining threshold
06:04:07 <quicksilver> you generally see the pragma when someone wants to guarantee intERmodule inlining.
06:04:16 <quicksilver> AIUI.
06:11:44 <int-e> ivanm: Ok, I can't explain the difference. randomInt and randomWord are essentially the same functions. And in theory, `mod` does less work for Word than for Int. (for Int, it has to check whether the division produces a negative remainder and possibly adjust the result)
06:12:31 <ivanm> int-e: possibly because I've got to convert my bounds from Int to Word, and then convert the result from Word back to Int?
06:13:53 <int-e> ivanm: that should be a noop at runtime. but yes, it may affect optimization in odd ways.
06:14:18 <Saizan> OT: any good books on probability theory?
06:14:31 <ivanm> int-e: *nod*
06:16:30 <quicksilver> Saizan: bit of a big subject.
06:16:43 * RayNbow has the following book:
06:16:45 <RayNbow> http://books.google.nl/books?id=XLUMIlombgQC&dq=a+modern+introduction+to+probability+and+statistics&pg=PP1&ots=852o5MqjwU&sig=XA4Ql5oNKmnuluB4Ip-BVvWHgFA&hl=nl&sa=X&oi=book_result&resnum=4&ct=result
06:16:51 <lambdabot> Title: A Modern Introduction to Probability ... - Zoeken naar boeken met Google, http://tinyurl.com/4h7y2m
06:17:17 <RayNbow> ah, you might want to replace google.nl with google.com :p
06:17:28 <quicksilver> Saizan: I used this one : http://www.amazon.co.uk/Probability-Introduction-Oxford-Science-Publications/dp/0198532644/ref=sr_1_1?ie=UTF8&s=books&qid=1224163024&sr=8-1
06:17:31 <lambdabot> http://tinyurl.com/3w6hde
06:17:34 <Bleadof> zoeken!
06:18:47 <ToRA|MSR> ok, this is going to sound stupid, but do any windows users out there know how to change your username for (e.g. the ghc wiki) under internet explorer?
06:18:56 <ToRA|MSR> everytime i press login it just logs me in as guest
06:19:14 <quicksilver> Bleadof: bless you.
06:19:32 <ddarius> Saizan: "Probability Theory: The Logic of Science" by E. T. Jaynes
06:19:47 <Bleadof> quicksilver, thank you :9
06:19:56 * Saizan takes notes
06:20:24 <Saizan> thanks a lot :)
06:20:50 <dolio> ToRA|MSR: I don't actually know, but I'd look in the settings for saved passwords.
06:20:59 <ivanm> http://blog.tmorris.net/javaruby-does-not-generalise-to-staticdynamic/ <-- is this Pseudonym from this channel commenting here?
06:21:06 <lambdabot> Title: Î» Tonyâs blog Î» Â» Blog Archive Â» Java/Ruby does not generalise to static/d ..., http://tinyurl.com/4d78to
06:21:49 <dmwit> very likely
06:22:06 <dolio> Which is probably in a different spot from saved form data.
06:22:14 <ddarius> ivanm: Doesn't really sound like him.
06:22:26 <ivanm> ddarius: yeah
06:22:43 <dmwit> Although it doesn't really sound li...yeah.
06:22:47 <ivanm> I like the comment at the end though ;-)
06:23:00 <ivanm> (whoever that Pseudonym may be...)
06:26:14 <quicksilver> I thought pseudonym used his real name on blog posts.
06:26:21 <quicksilver> but, it seems likely to be him.
06:26:32 <quicksilver> still it doesn't seem like his style
06:26:52 <quicksilver> hmm that's what everyone else said.
06:26:55 <ivanm> quicksilver: yeah, that was what threw me at first
06:26:56 <quicksilver> well, at least we agree :)
06:26:58 <dolio> I wonder what sweet spot the Ruby type system hits that CL doesn't.
06:27:14 <ivanm> dolio: it uses real sugar rather than saccharin?
06:27:15 <ivanm> ;-)
06:27:21 <dolio> Heh.
06:27:23 <quicksilver> dolio: obsession with objections considered less harmful than obsession with lists?
06:27:27 <quicksilver> damn 'objects'.
06:27:48 <quicksilver> ruby has typed objects, at least, while CL has no integrity constraints at all
06:27:52 <quicksilver> unless you build your own smart constructors
06:29:11 <dolio> I suppose not having used CLOS at all would put me at a disadvantage for getting it.
06:29:26 <dolio> If that's what's being talked about.
06:30:42 <quicksilver> dolio: oh, well I assumed it meant just plain CL
06:30:45 <quicksilver> no CLOS.
06:30:49 <quicksilver> I haven't used CLOS either ;)
06:30:49 <badri> Based on lilac's suggestions, fold with predicate can be written as "let foldp1 f p z l = foldr (\a b -> if p a then f a b else a) z l" so that "foldp1 (+) (<100) 0 [1..] is 5050" where the predicate is on the incoming value. If I want foldp2 with predicate on the accumulated value, how do I accomplish it? Is it similarly a simple foldl?
06:31:11 <ddarius> Yes.
06:31:43 <ddarius> Well, kind of.
06:32:35 <badri> ddarius: I couldn't do it..
06:33:00 <dolio> quicksilver: Yeah, I suppose lispers do have a reputation of using lists of a certain implicit format rather than making new datatypes that people around here might find disagreeable.
06:33:15 <quicksilver> dolio: and, certainly, different from ruby.
06:33:20 <dolio> Yeah.
06:33:21 <maltem> quicksilver: The class of a Ruby object does not give any guarantee about it, though (but maybe you didn't even mean that)
06:33:30 <dmwit> > sum . takeWhile (<100) $ [1..]
06:33:31 <quicksilver> dolio: where the idiom is to make a new class for a new data type
06:33:32 <badri> I want say foldp2 (+) (<5100) 0 [1..] to be 5050
06:33:32 <lambdabot>   4950
06:33:46 <quicksilver> maltem: it's not a strong guarantee, no, but it's some kind of conventional guarantee :)
06:33:50 <dmwit> badri: I think 5050 should be 4950. ;-)
06:34:02 <badri> dmwit: I know using takeWhile . thank you thought..
06:34:22 <dmwit> :t foldr
06:34:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:34:27 <maltem> quicksilver: yeah sort of
06:34:40 <ddarius> badri: You can't use foldl over an infinite list.
06:34:56 <badri> ddarius: oh yes!
06:35:12 <ddarius> However you can use the same code for foldp1 just have if p b instead of if p a
06:35:20 <dmwit> > foldr (\x y -> if y > 5000 then y else x + y) 0 [1..]
06:35:20 <badri> right!
06:35:21 <lambdabot>   * Exception: stack overflow
06:35:43 <badri> > foldr (\x y -> if x > 5000 then y else x + y) 0 [1..]
06:35:53 <badri> oops
06:35:58 <lambdabot>   thread killed
06:36:03 <badri> > foldr (\x y -> if x > 10 then y else x + y) 0 [1..]
06:36:18 <lambdabot>   thread killed
06:36:33 <badri> > foldl (\x y -> if x > 400 then y else x + y) 0 [1..50]
06:36:37 <lambdabot>   50
06:37:20 <dmwit> > last . takeWhile (<5100) . scanl (+) 0 $ [0..]
06:37:24 <lambdabot>   5050
06:37:33 <badri> foldl (\x y -> if x > 400 then x else x + y) 0 [1..50]
06:37:40 <ddarius> until (<5100) tail
06:37:52 <ddarius> until ((<5100) . head) tail
06:38:05 <badri> hmm cool
06:38:15 <ddarius> well I guess that should be >=5100
06:38:28 <dmwit> > head . until ((>5000) . head) tail . scanl (+) 0 $ [0..]
06:38:32 <lambdabot>   5050
06:38:40 <dmwit> I find that code longer and less intuitive.
06:39:29 <ddarius> That's because I was "optimizing" for performance not readability.
06:39:35 <dmwit> > head . dropWhile (<5000) . scanl (+) 0 $ [0..]
06:39:38 <lambdabot>   5050
06:39:52 <dmwit> Does until perform better than dropWhile? ;-)
06:39:53 <badri> yeah, it is not satisfying. I came up with the scanl solution too in the channel. but don't like it as much as the neat foldr which works for predicate on incoming value
06:40:23 <badri> dmwit: thanks for your tries!
06:40:44 <ddarius> dmwit: They all probably perform the same or close enough in practice, but the until version and the dropWhile version should have very, very similar performance.  Though, the until version may still be slightly faster.
06:41:24 <BeelsebobWork> > let (!~) = (head .) . dropWhile in (scanl (+) 0 [0..]) !~ (<5000)
06:41:27 <lambdabot>   Couldn't match expected type `a -> Bool'
06:41:39 <BeelsebobWork> @type (head .) . dropWhile
06:41:43 <lambdabot> forall a. (a -> Bool) -> [a] -> a
06:41:57 <BeelsebobWork> oh, wrong way round
06:42:12 <BeelsebobWork> > let (!~) = flip $ (head .) . dropWhile in (scanl (+) 0 [0..]) !~ (<5000)
06:42:16 <lambdabot>   5050
06:43:03 <sidewinder128> Hello, Would anyone recommend me a good beginner Haskell book?.
06:43:18 <quicksilver> hutton's book is popular, sidewinder128
06:43:20 <BeelsebobWork> sidewinder128: Simon Thompsons or Graham Huttons
06:43:27 <badri> oh yeah on finite lists, foldl solution does have a pleasing symmetry
06:43:31 <badri> > foldl (\x y -> if x > 5000 then x else x + y) 0 [1..200]
06:43:33 <sidewinder128> ok thanks
06:43:35 <lambdabot>   5050
06:43:54 <jeffz`> sidewinder128: see also http://haskell.org/haskellwiki/Books_and_tutorials
06:43:56 <lambdabot> Title: Books and tutorials - HaskellWiki
06:44:11 <BeelsebobWork> > let (!~) = flip $ (head .) . dropWhile . not in (scanl (+) 0 [0..]) !~ (>=5000)
06:44:12 <lambdabot>   Couldn't match expected type `a -> Bool'
06:44:16 <BeelsebobWork> bah
06:44:21 <mmorrow>  /msg lunabot , 42
06:44:27 <BeelsebobWork> @type flip $ (head .) . dropWhile . not
06:44:30 <lambdabot>     Couldn't match expected type `a -> Bool'
06:44:30 <lambdabot>            against inferred type `Bool'
06:44:30 <lambdabot>     Probable cause: `not' is applied to too many arguments
06:44:34 <sidewinder128> thank you guys
06:44:36 <mmorrow> s/ //
06:44:37 <BeelsebobWork> @type not
06:44:40 <lambdabot> Bool -> Bool
06:44:44 <BeelsebobWork> oh, that doesn't do what I though
06:44:46 <BeelsebobWork> thouht*
06:44:49 <BeelsebobWork> thought*
06:45:18 <Cale> sidewinder128: Also notable is Real World Haskell, which is nicely browsable online :)
06:45:33 <Cale> http://book.realworldhaskell.org/read/
06:45:36 <sidewinder128> ok hehe :)
06:45:39 <lambdabot> Title: Real World Haskell
06:45:41 <quicksilver> with a bit less of a beginner's focus but a much wider choice of content
06:45:44 <BeelsebobWork> > let (!~) = flip $ (head .) . dropWhile . (not .) in (scanl (+) 0 [0..]) !~ (>=5000)
06:45:44 <badri> Cale: Great Recommendation!
06:45:48 <lambdabot>   5050
06:45:50 <quicksilver> and, as cale says, availabel online.
06:45:56 <quicksilver> but not in dead tree form yet :(
06:46:00 * quicksilver has a pre-order.
06:46:24 <BONUS> sidewinder128 im writing a haskell book thingie aimed at beginners, might want to check that out :):
06:46:26 <BONUS> ?where LYAH
06:46:26 <lambdabot> www.learnyouahaskell.com
06:46:41 <Cale> heh
06:46:51 <sidewinder128> BONUS what is the title?
06:46:59 <BONUS> yes
06:47:04 <BONUS> oh
06:47:06 <BONUS> its the link
06:47:15 <BONUS> learnyouahaskell.com
06:47:19 <sidewinder128> ah ok thanks
06:47:28 <BONUS> (sorry for the self-promotion everyone, haha)
06:47:41 <Cale> quite all right :)
06:47:50 <Cale> I hadn't noticed it yet :)
06:47:52 <quicksilver> it has cool pictures :)
06:48:06 <quicksilver> (Texas Range)++
06:48:08 <BONUS> haha
06:48:30 <BONUS> yeah some people find haskell a bit intimidating, the pretty pictures are there to put them at ease
06:50:21 <dmwit> On the other hand, some people are put off by extraneous silliness.
06:50:29 * dmwit was very put off by _why's guide to Ruby
06:50:32 <Cale> I like the boat which is labelled "BOAT"
06:50:41 <dmwit> LYAH doesn't seem to suffer from quite the same problem, though.
06:50:51 <sidewinder128> hehe looks easy to read your book BONUS, its cool, I think people put scary to noobs about Haskell the Monads stuff
06:51:11 <BONUS> dmwit: yeah i'm aware of that in why's book, that's why i try to keep the wackiness mostly to the pictures
06:52:08 <sidewinder128> but anyway is cool this stuff, thanks for the help
06:52:53 <Cale> http://learnyouahaskell.com/listmonster.png :)
06:53:24 <Bleadof> :D
06:53:28 <luite_> hehe :)
06:53:54 <maltem> BONUS: still... can you _please_ make the code snippets be the same font size as the main text, as I think I "requested" earlier? you know... whacky anti-aliasing and all that...
06:54:21 <sidewinder128> ah one more question, which editor is good for haskell, Im planning to use Textmate or better emacs?
06:54:22 <BONUS> hmmm, im sorry i didnt catch that request earlier
06:54:24 <BONUS> what OS are you on?
06:54:44 <dmwit> sidewinder128: Either of those is fine.  Vim works nicely, too.
06:54:50 <Cale> sidewinder128: anything which you can configure to convert tabs to spaces should be fine. Syntax colouring would also probably be nice :)
06:54:59 <maltem> BONUS: Linux/X11, but this might be a Firefox or an Eyes thing
06:55:02 <sidewinder128> ok :)
06:55:31 <Cale> (and make sure that you do configure your editor not to leave hard tabs in source files, because that gets confusing quickly)
06:55:39 <BONUS> ah, i'll look into that, thanks for pointing that out
06:55:50 <dmwit> http://learnyouahaskell.com/brain.png recursion! =D
06:55:56 <luite_> how does haskell-mode find the type of a function (C-c C-t)? it seems to be able to find types for some functions, but not all
06:56:09 <maltem> BONUS: or it's just due to my firefox monospace font looking less perfect if black-on-white
06:56:39 <BONUS> here's what it looks like when im on windows: http://www.vulomedia.com/images/82585screen.png
06:57:07 <BONUS> i also recall it not looking to strange when im in linux, but i'll test it out on some other configurations nevertheless
06:57:33 <jao> luite_, it asks the running ghci; the function needs to be successfully loaded in ghci for C-cC-t to work
07:00:01 <yitz> BONUS: Just saw your LYAH. Really nice. Fun stuff!
07:00:06 <luite_> jao: ah, I loaded the file in the ghci with C-c C-l, but it doesn't automatically load the imports when I do that?
07:00:12 <BONUS> hehe, thanks :)
07:00:28 <jeffz`> BONUS: I find it a little hard to read the code snippets too, otherwise it looks like a great resource http://img122.imageshack.us/img122/2664/screenshotlearnyouahaskir0.png
07:00:34 <DuClare> Uh
07:00:40 <lambdabot> http://tinyurl.com/52o6jt
07:00:49 <BONUS> HMMMMMMM
07:00:49 <maltem_> BONUS: right... it's just that if I enlarge the text size in firefox, the code snippets get easy on the eye, but everything else gets huge :)
07:00:57 <BONUS> ah
07:01:13 <BONUS> alright, no problem, i'll enlarge the font size then
07:01:17 <BONUS> on the code snippets
07:01:27 <maltem_> splendid :)
07:01:43 <DuClare> What would be a neat way to pass the result from a monadic computation to a non-monadic one, without binding the result to a variable? :o
07:01:45 <BONUS> hehe, BRB
07:01:58 <maltem_> fwiw jeffz`'s screenshot resembles what it looks like here
07:02:21 <maltem_> DuClare: >>= ?
07:02:52 <yitz> BONUS: the code snippets look great on the Mac. I see what jeffz` means for some other platforms though. Try a small change first.
07:02:53 <quicksilver> DuClare: fmap/liftM
07:03:02 <maltem_> DuClare: or rather, x >>= return . f  -- alias fmap, liftM, <$>, ...
07:03:03 <quicksilver> DuClare: liftM puref monadicf
07:03:14 <quicksilver> DuClare: a.k.a puref <$> monadicf
07:03:26 <DuClare> Right
07:03:48 <jao> luite_, i think it should. basically C-cC-t runs :t <exp> in the ghci prompt, so you can try there and see what happens
07:04:25 <luite_> ok
07:07:00 <luite_> jao: hm, strange, the type info is shown in the ghci window, but not in the echo area
07:09:29 <yitz> @tell BONUS I found a bug in "initials" in "Syntax in Functions" - (f,_) should be (f:_).
07:09:30 <lambdabot> Consider it noted.
07:10:28 <quicksilver> cdsmith++ # What to know before debating type systems
07:10:30 <quicksilver> that's awesome
07:10:34 <quicksilver> can't believe I hadn't read it before.
07:11:54 <BeelsebobWork> quicksilver: what's that?
07:12:16 <camio> http://www.pphsg.org/cdsmith/types.html
07:12:17 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
07:12:34 <BONUS> so i changed the code snippet size
07:12:35 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
07:12:42 <quicksilver> BeelsebobWork: yes, camio got the link right.
07:13:22 <BONUS> can someone on linux check to see what it looks like now?
07:17:37 <maltem_> BONUS: hm, not sure if this is a firefox bug... at 100% it's still as small as before, but 120% it's larger by more than one size
07:17:37 <lambdabot> maltem_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:18:42 <jeffz`> BONUS: http://img116.imageshack.us/img116/9726/screenshotlearnyouahaskpc3.png
07:18:44 <lambdabot> http://tinyurl.com/42vejf
07:18:52 <maltem_> I think before I had the code snippets being the same size at 100 and 120
07:19:01 <BONUS> hmmm
07:19:02 <BONUS> strange
07:19:11 <BMeph> quicksilver: Oh, yeah, I remember that, it's a nice introduction. Didn't Dominus write on the topic as well? :)
07:19:13 <BONUS> it was at 12 px befora and now i've set it to 14px
07:19:17 <jeffz`> BONUS: it's larger just unreadable :)
07:19:32 <BONUS> anyone got any tips as to what i should do to make it more readable?
07:19:53 <yitz> BONUS: Another bug - the Modules page has "isPostfixOf" (in red) instead of "isSuffixOf".
07:19:54 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
07:20:24 <BONUS> yitz: i'll fix that right away
07:21:13 <BONUS> there we go, fixed
07:21:40 <yitz> BONUS: maybe try a dark grey background instead of black?
07:22:09 <jeffz`> maybe a different font-family
07:22:27 <BONUS> hmm
07:22:30 <BONUS> let's give this a shot
07:23:02 <jeffz`> font-family: Monospace, is much more readable for me
07:23:04 <yitz> BONUS: looks like the main problem is with red characters. Maybe use a lighter shade of red.
07:23:23 <BONUS> ok i set monospace to have a higher precedence over courier new
07:23:27 <dmwit> BONUS: Don't you love all the nitpickers?  You provide all this content, and they want it a different shade of blue... ;-)
07:23:33 <BONUS> haha :D
07:23:45 <maltem_> you could also just not specify the font size, then it would be my (browser's) problem instead of yours :)
07:23:45 <yitz> dmwit: oh no, not at all, the blue is fine.
07:23:53 <maltem_> dmwit: heh
07:24:01 <BONUS> but i like consolas
07:24:01 <BONUS> haha
07:24:05 <BONUS> does it look better now
07:24:53 <BONUS> brb lunch
07:26:14 <hugo_> how do i get the third element of a tuple ? :P
07:26:39 <jeffz`> hugo_: pattern match against it
07:26:45 <quicksilver> \(_,_,c) -> c
07:26:54 <hugo_> hmm heheh
07:26:58 <hugo_> sweet
07:26:58 <hugo_> thanks
07:27:07 <hugo_> BONUS: add that to the tuples section of the book :D
07:30:40 <BONUS> haha yeah it's actually in there, only in the pattern matching section
07:30:44 <jeffz`> BONUS: it looks better but did you put it back to 12px? I find it much easier on the eye if I adjust it to 14px
07:30:52 <hugo_> :D
07:30:54 <BONUS> yeah i put it back to 12px
07:30:57 <BONUS> hmm ok i'll put it to 14
07:31:10 <jeffz`> yeah, makes me squint, perhaps I need glasses
07:31:27 <BONUS> there we go, 14 px
07:31:34 <BONUS> yeah i was afraid of lines being too long
07:31:46 <BONUS> but i forgot that if it's too long, a scrollbar becomes active, so that's a non issue
07:32:25 <BONUS> can someone just get me a screenshot of how it looks now on linux?
07:33:24 <schme> Hello #haskell
07:33:30 <hugo_> hello scheme
07:33:54 <schme> :)
07:34:16 <jeffz`> BONUS: original, change, final -- http://img122.imageshack.us/img122/2664/screenshotlearnyouahaskir0.png http://img116.imageshack.us/img116/9726/screenshotlearnyouahaskpc3.png http://img183.imageshack.us/img183/2224/screenshotlearnyouahaskpt6.png
07:34:18 <lambdabot> http://tinyurl.com/52o6jt
07:34:36 <schme> So where do I look for distributed haskell? I find some various stuff, but what is normally used?
07:35:33 <yitz> BONUS: your example ghci snippets for Map and Set won't work - use Data.Map and Data.Set.
07:35:52 <BONUS> hmm let's see
07:36:06 <hugo_> i want to become an haskell evangelizer, going through the world anouncing the good news
07:36:35 <yitz> hugo_:  yes! that's the spirit!
07:36:44 <schme> hugo_: What good news?
07:36:49 <quicksilver> schme: nothing is normally used.
07:36:53 <quicksilver> schme: (as far as I know)
07:36:53 <BONUS> yitz: could you elaborate?
07:37:15 <schme> quicksilver: bugger :S
07:37:18 <BONUS> cause here what i expect people to do is do a qualified import in a .hs script and then load that up with ghci
07:37:43 <schme> How about single host concurrency?
07:37:53 <yitz> BONUS: e.g., Map.fromList ... needs to be Data.Map.fromList ... unless you are sure they loaded a file with import qualified...
07:37:55 <schme> Will GHC hook me up?
07:37:56 <maltem_> BONUS: ah, the other font now is gorgeous!
07:38:10 <Saizan> schme: Control.Concurrent
07:38:21 <schme> Saizan: C'est bien. :)
07:38:23 <BONUS> yitz: yeah, i meant to do the import as a qualified one in the script. but you're right, i'll elaborate on that
07:38:25 <Saizan> schme: and other modules in that hierarchy
07:38:29 <BONUS> maltem_: cool :D
07:38:33 <jeffz`> BONUS, now it also looks much better on Opera too
07:38:39 <quicksilver> schme: yes, that's a fairly well trodden path.
07:38:45 <BONUS> jeffz: thanks for the screenshots btw
07:38:50 <jeffz`> BONUS: my pleasure
07:39:06 <BONUS> i think the problem was that you guys have msftcorefonts installed
07:39:12 <BONUS> heeh i always avoid installing that package
07:39:25 <BONUS> cause i found that the ms fonts look like crap on linux anyway
07:39:25 <jeffz`> yeah, I hack on wine now and then, I must have installed it at some point
07:39:26 <Saizan> schme: i've written a client library for the spread toolkit, if that's of any help for distribution :)
07:39:30 <BONUS> ah
07:41:03 <BONUS> ok, i also made it explicit that the import comes from the script and then you load the script at the Map part
07:42:07 <schme> Saizan: That depends on what on earth the spread toolkit is ;)
07:42:27 <jao> luite_, i had a similar problem and had to patch haskell-mode. it's a small modification; if you're comfortable with patch i can send it to you
07:44:33 <luite_> jao: I'm quite new to emacs and emacs lisp, but I can try to install it. is it small enough for a paste site?
07:44:57 <jao> luite_, yes
07:45:39 <yitz> BONUS: make sure that it will work for Data.Set also further down the page.
07:45:54 <quicksilver> Saizan: that's quite interesting
07:46:28 <jao> luite_, i'm using the CVS version of haskell-mode, so the diff is against it
07:46:38 <luite_> jao: me too
07:46:55 <jao> luite_, ok, where do i put it?
07:47:32 <BONUS> yitz: good idea, i made it more explicit there too
07:47:43 <luite_> jao: hpaste.org ?
07:49:33 <jao> http://hpaste.org/11196
07:50:05 <luite_> thanks
07:50:11 <jao> luite_, apply it, open inf-haskell.el and M-x eval-buffer
07:52:28 <Saizan> quicksilver: i've written it for supporting happs multimaster/sharding, i don't think it has been used elsewhere (hspread on hackage btw)
07:55:06 <luite_> jao: seems to work, thanks
07:55:23 <jao> luite_, cool. you're welcome
07:56:26 <quicksilver> Saizan: *nod* we use spread at work. It's quite cool if somewhat underdocumented.
07:56:30 <dbbddbdb> Hi!  I get Â« (.text+0x4c5): undefined reference to `__stginit_containerszm0zi1zi0zi1_DataziMap_'(.text+0x4c5): undefined reference to `__stginit_containerszm0zi1zi0zi1_DataziMap_' Â» when I try to build something with Data.Map (GHCi works fine).  GHC-6.8.2.
07:56:31 <quicksilver> (like a lot of opensource)
07:56:40 <quicksilver> dbbddbdb: use ghc --make
07:56:55 <jao> luite_, btw, what emacs version do you use?
07:57:24 <luite_> jao: 22.3.1, windows (mingw) version
07:58:01 <jao> luite_, ok, thanks (now i know that it's not something specific to emacs 23)
07:59:02 <dbbddbdb> quicksilver: thanks!  I totally forgot about --make.  Is it possible to make it always use this option?
07:59:09 <dbbddbdb> Also, make it use -XGADTs by default
08:00:42 <quicksilver> for the latter, you can put {-# LANGUAGE GADTs #-} at the top of the source file
08:00:52 <quicksilver> or if it's a larger file, put it in the .cabal
08:00:55 <quicksilver> and use cabal to build it
08:01:03 <quicksilver> (which kind of answers the first question then)
08:01:20 <dbbddbdb> Thanks!
08:03:15 <DuClare> These days the biggest problems I have with programming are in naming functions and variables, and in deciding which one of the hundred possible data structures suit my application the best. :x
08:04:07 <quicksilver> DuClare: pick the simplest, change if you have performance problems
08:04:15 <quicksilver> premature optimization is the root of all evil.
08:05:34 <DuClare> quicksilver, They're all simple, just extensible in different ways.  I always end up wanting to extend my program further, and at that point I notice the structures and organization I used isn't extensibleâ¦Â  Or I try to come up with something very extensible right from the start, but then I'm not so sure what'd work best
08:07:08 <quicksilver> DuClare: layer your primitives correctly to reduce the pain of changing later
08:07:18 <quicksilver> DuClare: and then, once you've done that, don't lose sleep that you might change later.
08:07:25 <DuClare> And as for naming, it's often about overlaps.  Modules help a little here, but it's still problematic.  IRC?  Connections, to irc networks or to external clients?  Channels as in IRC channels, or as in fifo channels between threads?  Fifo as in channels between threads or as in a way to interface with external binaries?  Messages as in ones sent to IRC, or as ones sent via channels?  All thatâ¦
08:07:40 <quicksilver> DuClare: because you very seldom know in advance what will work best.
08:07:45 <DuClare> Indeed
08:09:05 <DuClare> quicksilver, IIRC Paul Graham wrote that people should re-write often.  I totally agree, especially now that I use functional languages, which makes rewriting less painful :)
08:09:30 <DuClare> Software often turns into a mess if it keeps getting extended without a rewriteâ¦
08:10:54 <qebab> DuClare: it's important to not overengineer things too, though. a lot of people I know (myself included) have a habit of overdoing things when rewriting :)
08:11:19 <quicksilver> overengineering can be educational though :)
08:11:22 <quicksilver> even cathartic.
08:11:28 <qebab> of course
08:11:43 <qebab> most mistakes can be educational :p
08:12:03 <luite_> is there a good library for manipulating large graphs, with operations to quickly select or remove nodes with certain properties (like all nodes with degree one) from a graph?
08:14:48 <Baughn> luite_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl <-- This thing, maybe?
08:14:48 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
08:14:49 <lambdabot> Title: HackageDB: fgl-5.4.1.1
08:19:16 <luite_> Baughn: hmm, the documentation seems to be a bit out of date, but I'll try it. thanks
08:25:04 <kaomoji> Hello
08:27:40 <yitz> hi kaomoji
08:28:39 <kaomoji> I just wanted to say "Hello" to the Haskellians/Haskellites
08:28:52 <kaomoji> Haskell is a very good language.
09:02:09 <hugo_> is it preatty to use a let inside a where ? :P
09:03:21 <yitz> hugo_: to my taste, I try to avoid too much nesting of lets/wheres. But it does happen often enough.
09:03:31 <hugo_> hmm
09:04:10 <hugo_> im defining an auxiliary recursive function in a where, then in the function a let would help the readability a lot :/
09:04:30 <yitz> hugo_: besides beauty - it is much easier to debug functions when they are top-level than when they are inside a let or where.
09:04:40 <mml`> @src lshift
09:04:40 <lambdabot> Source not found. My pet ferret can type better than you!
09:04:43 <hugo_> oh
09:05:10 <mml`> @src shiftL
09:05:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:05:21 <hugo_> its just that in my mind its more "readable" if i define the aux function inside the proper function :/
09:05:26 <hugo_> im probably wrong
09:05:33 <yitz> hugo_: no, I agree.
09:07:11 <yitz> but when I succumb to that temptation, I sometimes regret it at debugging time.
09:08:10 <Saizan> it shouldn't be hard to float it at the toplevel when the time comes
09:08:23 <hugo_> oh... hmm
09:08:42 <hugo_> i'll post it in hpaste, in order to get feedback, im not sure if im doing things the most "elegant" way :/
09:09:15 <yitz> Saizan: not always, sometimes they use stuff that is scope within the where clause. It can get messy to float it.
09:09:23 <Baughn> @where house
09:09:24 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
09:09:40 <Baughn> Egh. Broken link.
09:11:18 <rog_> is it possible to write a version of interact without using unsafe io?
09:11:27 <Baughn> @src interact
09:11:27 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:11:31 <Baughn> That would be a yes.
09:11:39 <rog_> that would be a no...
09:11:49 <rog_> given that getContents uses unsafe io
09:11:51 <Baughn> Where's the unsafe in there?
09:12:05 <Baughn> Oh, it uses unsafe/Interleave/IO, not unsafePerformIO
09:12:16 <Baughn> unsafeInterleaveIO is perfectly safe if you know what you're doing
09:12:23 <quicksilver> rog_: yes, it's possible.
09:12:38 <rog_> Baughn: that's not what i've read
09:12:44 <Baughn> rog_: Now, if you want to not use unsafeInterleaveIO, you'd have to read all of stdin before invoking the function
09:12:51 <RayNbow> @pl interact f = do s <- getContents; putStr (f s)
09:12:51 <lambdabot> (line 1, column 33):
09:12:51 <lambdabot> unexpected ";"
09:12:51 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
09:12:54 <quicksilver> main =  do l <- getLine; let s = f l; putStrLn l; main
09:12:56 <Baughn> rog_: With obvious performance and usability issues.
09:12:59 <rog_> Baughn: indeed
09:13:00 <Saizan> yitz: yeah, still not hard most of the time
09:13:06 <hugo_> please comment: http://hpaste.org/11199
09:13:07 <quicksilver> oh, interact isn't line by line?
09:13:13 <quicksilver> somehow I thought it was
09:13:36 <Baughn> It uses whatever buffering (the guy on the other side of) stdin and stdout are set to
09:13:39 <rog_> quicksilver: indeed
09:13:55 <RayNbow> @undo interact f = do s <- getContents; putStr (f s)
09:13:55 <lambdabot> interact f = getContents >>= \ s -> putStr (f s)
09:14:01 <RayNbow> @pl interact f = getContents >>= \ s -> putStr (f s)
09:14:01 <rog_> Baughn: i thought it didn't use any buffering at all - you just got a string with all input in it
09:14:01 <lambdabot> interact = (getContents >>=) . (putStr .)
09:14:05 <Baughn> ..I don't see the issue. interact lets you write pipes, basically. It works exactly the way you'd expect.
09:14:41 <hugo_> can someone analize and make some critics to my code, please ?
09:14:51 <rwbarton> If you write main = interact f, I think it's impossible for the use of interact to be "unsafe" in any way
09:14:51 <Baughn> rog_: You don't get input before the writer writes it to stdin, and the writer is usually buffered. Now, if it isn't reading your /own/ output, then that doesn't matter and you'll basically get it all at once.. if it is, then you need to care about flushing, and interact is a bad idea
09:14:57 <rog_> Baughn: i was just wondering if was cheating behind the scenes, like hGetContents does.
09:15:09 <Baughn> rog_: Given that it's /using/ hGetContents..
09:15:36 <Baughn> I just don't understand why you consider lazy i/o to be "cheating" or "unsafe" in any fundamental way. It's just easy to get wrong.
09:16:21 <rog_> Baughn: it means that consuming a list can have side effects. it can lead to deadlock in some cases.
09:16:36 <Saizan> rwbarton, Baughn: it's good for things like grep or wc, it gets let "referentially transparent" if you have an interactive interface, since you've to take case of forcing the input in the right way to get sensible output
09:16:37 <rog_> Baughn: (in particular when using pipes/sockets)
09:16:37 <Baughn> rog_: That's why I mentioned it's easy to get wrong. ;)
09:16:57 <Baughn> rog_: Well, so long as your input and output aren't the same program, interact is fine.
09:17:12 <rog_> Baughn: ... but isn't that kind of "wrong" the whole raison d'etre of haskell!?
09:17:14 <Baughn> Oh, does anyone know where House has gone?
09:17:21 <yitz> @type lookup
09:17:23 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:17:28 <yitz> hugo_: ^
09:18:02 <rwbarton> rog_: If using unsafeInterleaveIO can lead to deadlocks, isn't *not* using guaranteed to lead to deadlocks?
09:18:10 <rwbarton> s/using/using it/
09:18:11 <rog_> Baughn: does unsafeInterleaveIO cope ok with blocking files?
09:18:16 <hugo_> hehehe
09:18:19 <hugo_> allright :)
09:18:50 <Baughn> rog_: unsafeInterleaveIO has no bearing on blocking or not. It merely allows lazy I/O; what happens when the I/O is triggered depends entirely on the IO function you pass to unsafeInterleaveIO.
09:19:13 <gal_bolle> i have a scoping/indentation problem
09:19:19 <gal_bolle> http://hpaste.org/11200
09:19:19 <yitz> hugo_: getCityId = fromMaybe 0 . flip lookup buildCityList
09:19:56 <rog_> Baughn: ok. but say you've got two threads. and one starts to read a list from hGetContents, and blocks. is the other thread still runnable?
09:20:06 <Baughn> rog_: Yes
09:20:20 <Baughn> Assuming it isn't reading the same list, of course
09:20:30 <gal_bolle> in a do block, how do you get kdo {a <-x ; b where c = a}'?
09:20:33 <rog_> Baughn: why assuming that?
09:20:35 <gal_bolle> 'do {a <-x ; b where c = a}'?
09:20:36 <rwbarton> gal_bolle: 'where' attaches to declarations, not expressions, so that parses kind of like tutu = (do s <- ask; return t) where t = s
09:20:46 <gal_bolle> so i have to use let
09:20:50 <rog_> sorry stupid question
09:20:52 <rwbarton> gal_bolle: Basically, yeah.
09:21:31 <gal_bolle> sucks, my where block is 100 lines long
09:22:04 <rwbarton> Hmm, maybe you should have tried compiling your code a while ago :)
09:22:13 <gal_bolle> do {a <- x ; do b c where c = a} would work
09:22:21 <pcc1> is there anything I can read about monadic graphs? can't find anything on google
09:22:21 <rwbarton> I'll annotate with the usual syntax
09:22:21 <gal_bolle> rwbarton: i'm refactoring it
09:22:41 <rwbarton> gal_bolle: http://hpaste.org/11200#a1
09:22:52 <rwbarton> gal_bolle: I see
09:24:24 <hugo_> "fixed it": http://hpaste.org/11199#a1  :P
09:24:42 <hugo_> yitz: why the flip ?
09:25:26 <yitz> hugo_: because the order of the arguments to lookup is inconvenient here.
09:25:28 <dons> lispy's talk and slides, http://www.reddit.com/r/programming/comments/77jfs/type_correct_changes_a_safe_approach_to_version/
09:25:29 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
09:25:30 <lambdabot> Title: Type Correct Changes: A Safe Approach to Version Control Implementation : progra ..., http://tinyurl.com/4qv55e
09:25:32 <dons> all about gadts in darcs.
09:26:07 <hugo_> oh, i see, point-free
09:26:08 <hugo_> nice
09:26:24 <hugo_> why can't my mind think of that ? :/
09:26:30 <yitz> hugo_: your way it doesn't matter. so yeah, go with it.
09:26:58 <yitz> hugo_: why do you still need where?
09:27:28 <hugo_> hmm
09:28:03 <hugo_> i thought that in order to apply a function there i would either bind it with a let/where, or use the '$'/'.' notation
09:28:06 <hugo_> guess im wrong :P
09:28:16 <yitz> hugo_: your original question about nesting wheres and lets, though interesting, has now become moot in this case :)
09:28:53 <hugo_> yes, hehe
09:29:01 <inv> hi all
09:29:03 <hugo_> i know it will rise up later, in some other "non-lookup" case
09:29:09 <rwbarton> hugo_: btw, you could have replaced those three lines of let with simply (elem_name, elem_value) = head lst
09:29:23 <hugo_> ahh
09:29:23 <inv> I have a problem with debug haskell programm
09:29:23 <yitz> hugo_: everything is a function.
09:29:27 <hugo_> nice improvement
09:29:38 <inv> observe "tag" "qweasd"
09:29:38 <rwbarton> hugo_: or really, just look at the source for find :)
09:29:44 <rwbarton> @src find
09:29:45 <lambdabot> find p          = listToMaybe . filter p
09:29:54 <rwbarton> Hmm, that wasn't what I was expecting
09:30:02 <hugo_> heheh
09:30:05 <inv> output "qweasd" like ('q' : 'w' : ' with spaces
09:30:22 <inv> in observe manual there is an example which output normal "qweasd"
09:30:31 <rwbarton> find p [] = Nothing; find p ((x,y):xs) | p x = y; | otherwise = find p xs
09:30:37 <yitz> hugo_: don't forget to import Data.Maybe to use fromMaybe. Or just use maybe 0 id instead, maybe is in the Prelude.
09:30:38 <inv> whare is the problem ? I'd like "qweasd" too :)
09:31:19 <inv> how to make observe to output strings not like list ?
09:31:22 <rwbarton> inv: "observe"?  Are you using Hat or something?
09:31:27 <inv> hugs
09:31:30 <inv> winhugs :)
09:31:34 <hugo_> yitz: thanks :)
09:31:52 <roderyk> Given a set of points, I need to find the coefficients of a polynomial that would estimate the curve. I've been doing a little reading, but I'm kind of struggling in the dark. Are there some algorithms that are almost defacto for this sort of problem-set? If not, can someone give me some pointers on what numerical analysis algorithms I should be looking at most likely?
09:31:53 <rog_> rwbarton: to reply to your earlier question: if using interleavedIO would lead to deadlocks, so would not using interleavedIO, but at least the deadlocks wouldn't be in "pure" code.
09:32:15 <rwbarton> rog_: Meh, I'm never very convinced by these arguments
09:32:23 <yitz> inv: paste your program so we can see it.
09:32:27 <yitz> @paste
09:32:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:32:42 <rog_> rwbarton: depends whether you care about side-effect-free code or not, i guess.
09:32:43 <rwbarton> rog_: You can write "deadlocks" in pure code too
09:32:53 <rog_> rwbarton: really?
09:33:06 <rwbarton> Sure, ever seen <<loop>>?
09:33:10 <rog_> rwbarton: well, i suppose, anything that returns bottom...
09:34:26 <roconnor> > fix id
09:34:27 <rwbarton> Using unsafeInterleaveIO just means you've decided to treat something as not a side-effect.
09:34:27 <lambdabot>   * Exception: stack overflow
09:35:39 <rwbarton> On Linux a program can access its memory by opening /proc/self/mem, does that mean garbage collection is a side-effect that needs to be tracked?
09:35:48 <rog_> rwbarton: i did come across an example recently (my first piece of concurrent haskell actually) where failing to force the entire of the results of hGetContents led to a deadlock. but that was perhaps a special case. http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=108#a111
09:36:19 <Baughn> rwbarton: Ah, but you can't access it without using side-effects. ;)
09:36:31 <inv> yitz: here it is: http://hpaste.org/11201?#a0
09:36:40 <quicksilver> rwbarton: it's a fair question, but we need to be honest about the consequences of that.
09:36:52 <quicksilver> rwbarton: IO errors are a pretty severe kind of side-effect to ignore
09:37:00 <inv> @paste
09:37:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:37:00 <quicksilver> that alone is probably a show-stopper in a 'serious' application.
09:37:28 <Baughn> quicksilver: Can't you catch the error in the interleaved IO and encode it as some special value (eg. Nothing) in the list it's producing?
09:37:37 <Baughn> Or whatever fits
09:37:56 <quicksilver> yes. But that's not what getContents and friends actually do.
09:38:19 <Baughn> That just means that getContents is a bad interface, not that lazy I/O in general is
09:38:28 <quicksilver> and if they did, they would lose a lot of their convenience.
09:38:35 <quicksilver> and convenience is their only selling point.
09:39:08 <Baughn> ..that's true. Monads are plenty convenient already, I guess.
09:39:54 <rwbarton> rog_: Yes, that is kind of a special case :)
09:40:16 <rog_> Baughn: i don't think they are, really. it's non-trivial converting from non-monad code to monad code.
09:40:22 <quicksilver> I also object to the name "lazy IO" for this concept.
09:40:33 <quicksilver> I keep meaning to post a polemic to the -cafe on the subject.
09:40:39 <dolio> Lazy IO is far more convenient than what you usually do to get the same effect.
09:40:41 <Baughn> quicksilver: I'd read it. ;)
09:40:48 <Baughn> But wouldn't a blog post be better?
09:41:24 <quicksilver> I don't have a blog.
09:41:29 <quicksilver> I don't think I really want one.
09:41:35 <quicksilver> the -cafe lasts forever, that's good enough for me.
09:41:39 <quicksilver> if I had a blog I'd only lose it.
09:42:13 * ddarius imagines quicksilver saying "Crap, where did I put my blog?" and looking under the couch cushions.
09:42:32 <yitz> inv: try observe "string" "qweased"
09:42:57 <DuClare> I wonder if I'm doing something wrongâ¦Â  Or does ghci just have a problem with threads
09:43:05 <inv> yitz: just a moment
09:43:13 <osfameron> to lose 2 blogs would be careless...
09:43:22 <rog_> this guy clearly thinks that "lazy IO" (or whatever quicksilver would like it called) isn't good: http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
09:43:24 <lambdabot> Title: Incremental multi-level input processing with left-fold enumerator predictable,  ...
09:43:26 <DuClare> ghci doesn't read every keypress after running a threaded program (one of the thread gets input)
09:43:30 <inv> yitz: string
09:43:31 <inv>   ('q' : 'w' : 'e' : 'a' : 's' : 'd' : [])
09:43:36 <inv> the same thing :)
09:44:06 <rwbarton> inv: This is kind of unsurpising--what if you only observed some of the characters of the string, what should it do then?
09:44:31 <rwbarton> inv: e.g. try putStrLn $ take 3 res
09:44:48 <inv> rwbarton: http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
09:44:49 <lambdabot> Title: Hugs debugging primitives
09:45:10 <inv> rwbarton : observe "string" ['a'..'d']
09:46:08 <inv> rwbarton: ('a' : 'b' : 'c' : _)
09:46:19 <inv> _ - means not calculated
09:46:22 <rwbarton> Right
09:46:41 <yitz> inv: hmm. the hugs manual says it should work that way - as a difference from standard Hood, which is supposed to do what you are seeing.
09:46:50 <yitz> @type observe
09:46:51 <lambdabot> forall a. Logic a -> a
09:46:57 <yitz> nah.
09:47:21 <inv> rwbarton: here it outputs normal string http://cvs.haskell.org/Hugs/pages/users_guide/observe.html
09:47:22 <lambdabot> Title: Hugs debugging primitives
09:47:30 <rwbarton> Oh, I didn't read that far
09:47:40 <inv> rwbarton: look at the line: Observe> observe "string" ['a'..'d']
09:47:55 <inv> output is "abcd"
09:48:31 <quicksilver> maybe that's because it's all forced?
09:48:41 <quicksilver> maybe the special shortcut notation is only used for fully forced strings.
09:49:04 <inv> ow, I don't know :)
09:49:12 <rwbarton> This manual says there's a different shortcut notation for strings that are not fully forced: "abc..."
09:49:13 <inv> I think not
09:49:34 <inv> quicksilver: there is ""ab..." - half calculated string example
09:49:49 <quicksilver> hmm.
09:49:53 <quicksilver> I withdraw my suggestion :)
09:50:44 <yitz> inv: observe "this also works" ('a':'b':'c':[])
09:51:14 <rwbarton> inv: my hugs does the same thing.  Maybe the manual is for an older version, or is just a lie...
09:51:19 <yitz> anyone know who works on Hugs these days?
09:51:29 <rwbarton> actually...
09:51:40 <yitz> wasn't ndm involved?
09:51:56 <quicksilver> ndm did some work on winhugs in particular
09:52:03 <quicksilver> but not on the underlying hugs I don't think.
09:52:14 <inv> wow!!!!
09:52:16 <quicksilver> ndm has the strange view that a GUI is actually a good thing.
09:52:19 <quicksilver> ;)
09:52:25 <inv> yitz: ! how is it possible ?
09:52:36 <inv> observe "string" ('a':'b':'c':'d':[])
09:52:50 <yitz> inv: looks very suspicious, doesn't it?
09:52:52 <inv> it works fine, but what the different ?
09:53:16 <rwbarton> That's truly bizarre
09:53:25 <inv> yitz: yes it does :)
09:53:48 <inv> yitz: do you know the answer?
09:53:58 <yitz> no, I think it's a bug.
09:54:06 <inv> heh
09:54:17 <inv> thx for the help anyway!
09:54:56 <Peaker> Is progress being made on Nested Data Parallelism? Is it available through cabal?
09:55:06 <yitz> quicksilver: it's a strange view, but at work it is sometimes helpful to pretend to hold it.
09:55:33 <inv> how is it possible to force expression in haskell ?
09:55:44 <quicksilver> yitz: that surely wasn't ndm's reason though. He was at uni (then).
09:55:51 <quicksilver> credit suisse now, I gather.
09:55:52 <inv> to be sure it's not lazy
09:56:08 <inv> maybe it would help
09:56:28 <yitz> quicksilver: heh, there you could actually survive with the opposite view.
09:57:09 <yitz> @type seq
09:57:10 <lambdabot> forall a t. a -> t -> t
09:57:15 <Peaker> inv: You can use strictness annotations, seq, or $!
09:57:23 <Kamina> hi
09:57:42 <inv> Peaker: thx
09:57:44 <Kamina> can anyone tell me, if there is a way in haskell to check if a value is bottom/undefined?
09:57:46 <yitz> inv: but I doubt that has anything to do with it here.
09:58:04 <Peaker> Kamina: a "bottom" may represent a non-halting execution, so not always
09:58:08 <yitz> Kamina: that is known as the halting problem.
09:58:36 <Peaker> Kamina: Sometimes, you can detect it is bottom because it already became an error, I think you can catch that as an exception. But not always
09:59:01 <Kamina> Peaker: but only in an IO Monad?
09:59:16 <Peaker> Kamina: I think so, I'm not sure
09:59:26 <Kamina> i'd like to use a function like:  ifDefinedUseFirstElseSecond value1 value2
09:59:35 <Kamina> and if value1 is known to be bottom, value2 is returned
09:59:37 <Kamina> otherwise value1
09:59:39 <dolio> Bottoms that come from the 'error' function are hooked into the runtime system to be catchable in the IO monad.
10:00:01 <sw17ch> i had a friend do an interesting experiment with the halting problem... he iterated a turing machine over all programs of length [1..n] and discovered taht for each n, the ratio of halting/non-halting programs could be described as a simple function.
10:00:02 <dolio> Those and blackhole detection.
10:00:25 <yitz> Kamina: the right way is to wrap your value in Maybe or Either so that you can test directly whether it is an error.
10:00:30 <sw17ch> where the input to the function, is the program length
10:00:50 <Kamina> yes, i could do that, but that would be a bit annoying, as there are several functions which would all have to be wrapped in Maybe then
10:01:20 <Kamina> so using a "bottom" detector would be a quick fix for my problem
10:01:41 <Peaker> sw17ch: surely you reach turing programs you cannot check pretty quickly?
10:02:23 <sw17ch> Peaker: yeah, it happens fairly quickly, but we ran it over several days and hit programs of length over 1000 if i remmeber correctly
10:02:29 <yitz> Kamina: I think you're asking for trouble. It's worth the effort.
10:02:29 <Kamina> so there is no way to catch those bottom/undefined values in a non IO monad function?
10:02:40 <sw17ch> the odd thing was, the function was incredibly accurate
10:02:43 <lekro> sw17ch: what do you mean by length?
10:02:45 <sw17ch> r^2 value of 0.99997 or so
10:03:06 <sw17ch> lekro: well, the non-blank length of your turing tape
10:03:17 <Baughn> sw17ch: The problem is, of course, that you can't be sure it's actually going to halt or not
10:03:27 <Baughn> sw17ch: Well, unless it starts repeating. See: Busy beaver
10:03:29 <lekro> sw17ch: but that's not the program of the turing machine, is it?
10:03:30 <sw17ch> Baughn: yes, but if you run the program for a certain distance, it's usually a good indicator
10:04:05 <sw17ch> we determined anything that ran more than some function of the program length steps to be non-halting
10:04:23 <sw17ch> Busy beaver numbers are fun :)
10:04:32 <sw17ch> any way, it was interesting
10:04:32 <Kamina> yitz: what do you mean with asking for trouble? That what i would like to do is "abusing" the undefined state for computations, which is a bad idea?
10:04:45 <Baughn> sw17ch: There's a large class of programs that run for a good long while and then stops, though. Like something that checks whether an unknown (but true) theorem is true by enumerating all possible proofs...
10:05:05 <Baughn> If you diagonalize that properly, it *will* eventually stop
10:05:15 <sw17ch> Baughn, yes, of course
10:05:19 <lekro> sw17ch: is that ratio the number that's more commonly known as Chaitin's constant?
10:05:36 <sw17ch> lekro, could be...
10:05:40 * sw17ch goes to look at the wikipedia page
10:05:48 <yitz> Kamina: that too. more simply - your program will start to get messier and messier, as what usually happens when you try a klugy "quick fix".
10:06:09 <sw17ch> lekro: yes! that's exactly it!
10:06:11 <sw17ch> :)
10:06:15 <sw17ch> nothing new under the sun
10:06:40 <Kamina> yitz: currently i'm not interested in a clean program, but in some concrete calculations, and doing that dirty trick would have helped me to decide if it's worth implementing it properly
10:06:58 <lekro> sw17ch: well, then it's not computable by some easy formula ;)
10:07:01 <yitz> Kamina: ok then. but yeah, it'll be IO.
10:07:05 <lekro> sw17ch: in fact, it's uncomputable
10:07:37 <sw17ch> lekro: oh... well, if all it does is tell you the probability a program will halt based on it's length... then i'm guessing his fucntion does it
10:07:45 <sw17ch> maybe i didn't read enough
10:07:46 <Kamina> okay, so thanks for the information!
10:09:05 <yitz> Kamina: you could use unsafePerformIO to be even quicker and dirtier :)
10:11:45 <mmorrow> Kamina: of course that'll only work for values of Prelude.undefined, and not for (e.g.)  fix id  or   fix error
10:13:16 <Kamina> yits: whats unsafePerformIO? it's not in the prelude?
10:13:26 <sw17ch> mmorrow, proof that "then" doesn't belong: http://arcanux.org/lambdacats/unit-testing.jpg
10:13:27 <_dolio> Thank goodness.
10:13:28 <Kamina> doing IO in a non IO Monad?
10:13:28 <mmorrow> since those don't even allocate any memory, the haskell runtime can't time them out or kill them without resorting to using rlimits or some other OS mechanism, which'll take down the whole program.
10:14:03 <rog_> sw17ch: have you looked at the lower limits for the sigma function in the wikipedia page. they're rather large, for any n > 4...
10:14:20 <rwbarton> dolio: Is blackhole detection the same as <<loop>>?
10:14:22 <dons> ?users
10:14:23 <lambdabot> Maximum users seen in #haskell: 518, currently: 496 (95.8%), active: 19 (3.8%)
10:14:26 <mmorrow> sw17ch: haha. very true.
10:14:30 <sw17ch> rog_: no, i merely donated computing power and vaguely understood what he was doing
10:14:31 <dolio> rwbarton: That's the error message it generates, yes.
10:14:45 <rwbarton> dolio: Neat, I didn't know you could catch that
10:14:55 <mmorrow> hmm
10:15:10 <rog_> sw17ch: basically - the answer is that you can't just say "it's gone over a certain number therefore it's not going to halt".
10:15:24 <Kamina> :t unsafePerformIO
10:15:24 <dolio> rwbarton: Now that you mention it, I'm not 100% sure, as I've never tried it before. But it seems like you'd be able to.
10:15:25 <lambdabot> Not in scope: `unsafePerformIO'
10:15:30 <rog_> sw17ch: 'cos the state on the tape can be arbitrarily complex
10:15:37 <sw17ch> rog_: ah, that much i know. the assumption which was made was that if it goes above a certain number, we don't think it will
10:16:20 <sw17ch> and hoped that we were wrong a minimal number of times
10:16:34 <Kamina> ah: unsafePerformIO :: IO a -> a
10:16:44 <Kamina> in System.IO.Unsafe
10:16:49 <Kamina> looks very dirty...
10:17:12 <sw17ch> Kamina, it's more scary
10:17:23 <rog_> sw17ch: well, for n = 6, the curretly known lower bound is 2.5 * (10 ^ 102879). i doubt you got that far :-)
10:17:36 <idnar> unsafeDestroyUniverse
10:18:01 <rog_> sw17ch: (that's for a 2-state TM). see http://www.logique.jussieu.fr/~michel/bbc.html
10:18:03 <lambdabot> Title: Busy Beaver Competitions
10:18:15 <rwbarton> dolio: Hmm, I guess it caught it, but...  http://hpaste.org/11202
10:19:10 <sw17ch> rog_: I'll point him to the logs for the last fwe minutes and see what he says :)
10:19:19 <mmorrow> rwbarton, dolio: hmm, it seems only compiled-to-machine-code is able to detect <<loop>>, but not bytecode-code.
10:19:41 <dolio> rwbarton: http://hpaste.org/11202#a1
10:19:53 <rog_> sw17ch: BTW, i pasted that number wrong. it's actually "only" 4.6 * (10 ^ 2879)
10:19:55 <dolio> mmorrow: Yeah, ghci doesn't do blackhole detection for some reason.
10:20:09 <Baughn> dolio: That's because it hooks ctrl-c
10:20:11 <dolio> I'm not sure if there's something actually preventing it or not.
10:20:16 <dolio> Ah.
10:20:24 <Baughn> dolio: Deadlock detection gets turned off if you register signal handlers. Any signal handlers.
10:20:37 <dolio> Ah, I see.
10:20:57 <dolio> rwbarton: You need to use evaluate to turn pure exceptions into IO exceptions, I believe.
10:21:05 <Baughn> I was going to make it switchable.. well, since I've got 6.10 working now, I guess...
10:21:41 <jdegoes> Hello, does anyone know what the name is for a relation that is symmetrical (aRb => bRa), but neither transitive nor antisymmetric? e.g. the relation, "is 1 cm away from"
10:22:22 <rwbarton> an undirected graph?
10:23:10 <jdegoes> Yes, in fact it is an undirected graph. Any name for the relation that holds for connected nodes on such a graph?
10:23:25 <rwbarton> dolio: My test works if I have the exception handler print to stderr rather than stdout.
10:23:33 <rwbarton> jdegoes: "adjacency"? :)  Not really.
10:24:16 <mmorrow> dolio: snap, if it did then (for instance) ghci would be able to survive a "fix id"
10:24:28 <jdegoes> OK :-) Now add one more property: you can measure the distance between nodes. Does that change the terminology?
10:24:58 <mmorrow> whereas currently i have to ^Z and kill -9
10:25:34 <dolio> rwbarton: I must admit, your output there is kind of weird.
10:26:12 <jdegoes> That is, for any two nodes a and b such that aRb, there exists a function d(a, b) which gives you the distance between a and b. For any arbitrary nodes d(a, b) is either undefined (if there is no path between them) or the minimum distance/list of distances.
10:26:20 <jdegoes> Surely there must be a name for that.
10:26:21 <mmorrow> <Baughn> dolio: That's because it hooks ctrl-c
10:26:45 <mmorrow> oh yeah, i think i know exactly where this is explained in a comment..
10:27:46 <Kamina> yitz/mmorrow/sw17ch: catch does not appear to catch "undefined" exceptions
10:28:07 <Kamina> yitz/mmorrow/sw17ch: catch (putStrLn undefined) (\err -> putStrLn "abc")   gives  *** Exception: Prelude.undefined
10:28:23 <dolio> Kamina: see http://hpaste.org/11202#a1
10:28:38 <sw17ch> Kamina: isn't taht because it's a prelude exception instaed of an IO Exception?
10:28:45 <dolio> catch (evaluate undefined) (\err -> ...) should evade the error.
10:28:46 <sw17ch> or are these the same thing :P
10:28:49 <Kamina> i found the solution
10:28:52 <Kamina> "Non-I/O exceptions are not caught by this variant; to catch all exceptions, use catch from Control.Exception."
10:28:55 <sw17ch> ah, never mind
10:28:57 <sw17ch> i'm stupid
10:29:32 <mmorrow> Kamina: "import Prelude hiding (catch)" is a commonly seen line
10:29:44 <mmorrow> (along with import Control.Exceptionm)
10:29:53 <rwbarton> jdegoes: I think it's sometimes called a weighted graph, or a metric graph
10:30:06 <Kamina> dolio/mmorrow: okay, i will try that with hiding catch from the Prelude
10:30:59 <Baughn> mmorrow: http://hackage.haskell.org/trac/ghc/ticket/2180 <-- Right, this is related
10:31:01 <lambdabot> Title: #2180 (Any installed signal handler stops deadlock detection, but XCPU never hap ...
10:31:03 <Baughn> Hum, it's been a while
10:31:39 <jdegoes> OK, thanks, that will give me something to Google.
10:33:23 <dolio> rwbarton: (evaluate loop >>= print) `catch` \_ -> putStrLn "Success." works.
10:33:40 <dolio> rwbarton: So, breaking out of the print call when it detects the pure exception must screw up stdout or something.
10:33:55 <rwbarton> dolio: Ah
10:34:03 <rwbarton> dolio: I wonder whether that is a bug
10:34:18 <dolio> Might be worth mentioning.
10:35:13 <rwbarton> It doesn't happen with exceptions generated by error.
10:35:18 <rwbarton> So, it may be fixable
10:36:24 <pozic> Which chapter in RWH covers GADT?
10:36:29 <rwbarton> Man, this will be the third bug I've filed, and I don't care about any of them getting fixed :P
10:36:39 <dolio> :)
10:37:04 <dolio> I'm not sure if it covers GADTs.
10:37:06 <pozic> Quoting the plan "# understand advanced parts of the language, such as GADTs and MPTCs."... Or was the plan never implemented?
10:40:10 <dons> pozic: GADTs aren't covered,a faik
10:41:12 <dolio> Nobody uses them for real stuff anyway. :)
10:41:59 <mmorrow> :)
10:42:13 <jdegoes> OK, for this "weighted graph", I'm trying to define a distance function, d :: T -> T -> R, where T is the type of node and R is the set of reals. Here's what I've got so far:
10:42:40 <jdegoes> 1. If a and b are related to each other (aRb), then d(a, b) = d(b, a).
10:42:52 <pozic> jdegoes: your type is already incorrect
10:43:06 <jdegoes> 2. If a and b are NOT related to each other, then d(a, b) is not defined.
10:43:42 <jdegoes> 3. If a and b are related to each other, and c is not related to a but is related to b, then d(a, b) <= d(a, b) + d(b, c)
10:43:52 <pozic> jdegoes: the distance function takes two nodes and a graph and returns a number.
10:44:17 <jdegoes> Let's assume the graph is implied since it's too much trouble to write. :-)
10:44:34 <jdegoes> Also should be R+ with 0, since distance function can't be negative.
10:45:03 <pozic> jdegoes: you can use memoization.
10:45:17 <jdegoes> OK
10:45:19 <pozic> jdegoes: (that's the lazy route)
10:45:24 <DuClare> Uhh, a bit off, but can you people suggest a good (g)vim theme for use with haskell?  :o
10:45:38 <pozic> jdegoes: the efficient route is figuring out whether you can do it while using less memory.
10:46:01 <jdegoes> Right now I'm mainly interested in whether or not the 3 conditions are sufficient for a distance function.
10:46:05 <jdegoes> Or should I add more?
10:46:34 <pozic> jdegoes: the "not defined" is simply 1/0
10:47:16 <pozic> jdegoes: and your equations do not give rise to a computation process.
10:47:35 <pozic> computational*
10:48:16 <jdegoes> No but they can validate one. But if they're bad conditions they won't do much good validating distance functions.
10:48:31 <rwbarton> jdegoes: I don't think axiom 3 is what you mean, of course d(a, b) <= d(a, b) + d(b, c) because 0 <= d(b, c).
10:49:08 <jdegoes> rwbarton: You're right.
10:49:35 <jdegoes> rwbarton: 1 and 2 seem so flimsy. It seems I should be able to require something else. Don't know what
10:50:06 <pozic> jdegoes: a validate "function" would  use an inefficient algorithm.
10:50:21 <rwbarton> jdegoes: Sometimes people require the triangle inequality--whether it matters depends on what you're doing with the graph
10:50:31 <jdegoes> pozic: I agree dude, but I'm more interested in the math at this point! :-)
10:50:58 <pozic> jdegoes: we don't speak "dude" here, try the beach.
10:51:03 <rwbarton> jdegoes: (I mean, a weighted graph is what you define by 1 and 2.  The triangle inequality axiom wouldn't be implicit)
10:51:25 <jensen> Hi, I'm trying to compile a Haskell program, which needs the module Data.UUID. Unfortunately, I have been unable to find this module anywhere. Any help would be very appreciated. Preferably as a package for ubuntu, but anything will do.
10:51:59 <jeffz> jensen: did you look on hackage?
10:52:09 <jensen> Part of the problem is, I guess, that I am not too familiar with Haskell, so I don't really know what I am looking for.
10:52:13 <dolio> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:Data.UUID
10:52:14 <lambdabot> Title: Hayoo!
10:52:20 <jdegoes> rwbarton: Ah, triangle inequality. d(a, b) + d(b, c) >= d(a, c)
10:52:28 <Deewiant> jensen: does the program perchance come with a .cabal file?
10:52:34 <jensen> jeffz, dolio: Wow, fast response! Thanks!
10:52:38 <Deewiant> if so, consider cabal-install
10:52:55 <jeffz> jensen: we never sleep :)
10:52:58 <pozic> jensen: google Data.UUID haskell also works.
10:52:59 <jensen> I just have the source code. Ill try jeffz and dolios suggestions.
10:53:00 <jensen> :)
10:53:24 <jensen> pozic: attempted that, but my google-fu must be weak, it did'nt lead me anywere.
10:53:27 <dolio> That page links to api documentation which says what package it's in on hackage.
10:53:50 <jensen> dolio: great, thanks! I'll take a look at it.
10:54:14 <jdegoes> rwbarton: The context is web pages, how close they are related to one another. I don't think the triangle inequality holds in this case. I'll think.
10:54:27 <anonymouz666> haskell test next monday
10:54:47 <rwbarton> jensen: You'll likely want to install cabal-install (sort of like CPAN) because it looks like the dependencies of uuid are a little complicated
10:55:02 <pozic> anonymouz666: and you sold your soul to the devil for answers already?
10:55:24 <anonymouz666> I am worried... functional programming is new to me
10:57:18 <jdegoes> rwbarton: If web page C has 50% of the content of B, which has 50% of the content of A. Then A could range from being identical with C to having nothing in common with C. So I don't think the triangle inequality holds.
10:57:48 <rwbarton> jdegoes: Yes, probably not
10:57:52 <anonymouz666> I am using winhugs to do my haskell programming
10:57:57 <anonymouz666> the syntax is pretty boring
10:58:02 <anonymouz666> Int ->
10:58:31 <anonymouz666> INT/int -> does not work
10:58:34 <anonymouz666> things like that
10:58:38 <anonymouz666> case sensitive
10:59:04 <pozic> anonymouz666: have you considered that maybe these things are there for a reason?
10:59:11 <rwbarton> What languages aren't case sensitive these days?  Pascal?
10:59:21 <dolio> VB.
10:59:25 <dolio> Maybe.
10:59:28 <pozic> rwbarton: Lisp
10:59:38 <jeffz> cobol?
10:59:40 <Deewiant> forth?
10:59:41 <Peaker> VB?
10:59:41 <rwbarton> pozic: Right, I know Lisp also, but assumed that anonymouz666 didn't :)
10:59:44 <Randroid> REBOL
11:00:26 <vixey> hi
11:00:34 <vixey> does agda 2 work with ghc 6.10
11:00:59 <pozic> Forth is not case-sensitive.
11:01:19 <Deewiant> thought so
11:01:24 <Randroid> SQL
11:01:43 <Deewiant> HTML :-P
11:01:51 <anonymouz666> the good about haskell is that you can do things things easily if you compare with other languages
11:02:04 <Randroid> Deewiant: I believe XHTML is case-sensitive, though. :)
11:02:14 <Deewiant> yes
11:02:20 <Deewiant> I should have said SGML, I suppose
11:03:59 <Randroid> I really like the fact that Haskell is not only case sensitive, but enforces rules about case. My day job is as a C# programmer, but I work with a lot of ex-VBers who consistently capitalize local variables and parameters, which drives me CRAZY. I once almost bludgeoned my therapist while discussing it. It's a sensitive topic.
11:04:03 <vixey> huh why did I think 6.10 was out
11:04:23 <anonymouz666> is there a pre-defined function that return the biggest value in a list?
11:04:24 <jdegoes> OK, now suppose I have this handy function d(a, b) that can measure the strength of the relationship between two web pages. Let's consider a *bundle* of web pages. If we're using Firefox, we have lots of tabs open, what's the 'distance' between you and me on the Internet?
11:04:31 <dolio> vixey: Because it was supposed to be released for ICFP? :)
11:04:33 <anonymouz666> [10, 50, 2, 3, 4]
11:04:37 <anonymouz666> return 50
11:04:58 <idnar> > maximum [10, 50, 2, 3, 4]
11:04:59 <lambdabot>   50
11:05:20 <Peaker> @type maximum
11:05:21 <anonymouz666> oh my god there's a bot!
11:05:21 <lambdabot> forall a. (Ord a) => [a] -> a
11:05:24 <anonymouz666> :D
11:05:26 <Peaker> @src Foldable
11:05:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:05:32 <Peaker> @hoogle Foldable
11:05:33 <lambdabot> module Data.Foldable
11:05:33 <lambdabot> Data.Foldable class Foldable t
11:05:41 <Peaker> @src Data.Foldable
11:05:41 <lambdabot> Source not found. Maybe you made a typo?
11:05:44 <Peaker> @src Data.Foldable.Foldable
11:05:44 <lambdabot> Source not found. Do you think like you type?
11:06:58 <Peaker> it could be nice if fold's type signature was Foldable f => (a -> b -> a) -> a -> f b -> a  and derived functions like maximum then worked on non-lists too
11:07:22 <rwbarton> @hoogle fold
11:07:22 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
11:07:22 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
11:07:22 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
11:07:31 <rwbarton> Interesting
11:07:37 <anonymouz666> how do I find the position of some value?
11:07:39 <rwbarton> @hoogle foldl
11:07:39 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
11:07:39 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
11:07:39 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
11:07:52 <sw17ch> anonymouz666, indexOf
11:07:57 <vixey> :t maximumBy
11:07:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:08:08 <rwbarton> @hoogle maximum
11:08:08 <lambdabot> Prelude maximum :: Ord a => [a] -> a
11:08:08 <lambdabot> Data.ByteString maximum :: ByteString -> Word8
11:08:08 <lambdabot> Data.Foldable maximum :: (Foldable t, Ord a) => t a -> a
11:08:10 <sw17ch> > indexOf 5 [1..10]
11:08:11 <vixey> :t maximumBy (comparing fst)
11:08:11 <lambdabot>   Not in scope: `indexOf'
11:08:12 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
11:08:19 <sw17ch> > Data.List.indexOf 5 [1..10]
11:08:20 <lambdabot>   Not in scope: `Data.List.indexOf'
11:08:22 <vixey> :t maximumBy (comparing fst) . zip [0..]
11:08:24 <lambdabot> forall a b. (Enum a, Num a, Ord a) => [b] -> (a, b)
11:08:47 <vixey> > maximumBy (comparing snd) . zip [0..] $ [10, 50, 2, 3, 4]
11:08:48 <lambdabot>   (1,50)
11:09:11 <anonymouz666> out of scope indexOf?
11:09:16 <vixey> anonymouz666
11:09:48 <anonymouz666> great
11:09:53 <sheyll> whats the most efficient way to read a text file line by line?
11:09:56 <andyjgill> Hey, has anyone written a substitution engine for the Template Haskell syntax yet? Is it on hackage? I can't find it if it is.
11:10:13 <anonymouz666> vixey: that's exactly what I was looking for the biggest and its position
11:11:19 <anonymouz666> I just realized that there's another function called elemIndex also
11:11:42 <ttt--_> andyjgill, what is a substitution engine?
11:11:52 <vixey> :t elemIndex
11:11:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
11:12:34 <anonymouz666> where I can test my codes in Linux?
11:12:40 <anonymouz666> or WinHugs is just fine?
11:16:54 <Botje_> how do you tell cabal the main function is in a C file?
11:17:16 <dcoutts> Botje_: you cannot
11:17:40 <Botje_> aww
11:18:07 <glguy> is cram-md5 implemented somewhere on hackage already?
11:18:41 <roconnor> @karma laziness
11:18:41 <lambdabot> laziness has a karma of 4
11:19:01 <dons> something small and cheap we could do, http://nitrogen-erlang.tumblr.com/?
11:19:01 <lambdabot> Title: Nitrogen Web Framework
11:19:09 <dcoutts> Botje_: the easiest thing would be for your Haskell main to call the C one, alternatively make a Haskell lib and link in your C main and do the final link manually
11:22:03 <Botje_> hmm
11:22:52 <Botje_> thanks dcoutts
11:22:55 <Botje_> i'll see what i can make of it
11:40:18 <nicknull> can i use unsafePerformIO in he middle of a pure function?
11:41:26 <nicknull> like : sq x = unsafePrint $ x*x
11:41:49 <Botje_> yes
11:41:52 <Botje_> however
11:41:56 <Botje_> if you're going to use it for that
11:41:58 <Botje_> use Debug.Trace :)
11:42:25 <Vq^> if by use you mean write then yes
11:42:52 <vixey> nicknull: That's a great idea
11:43:08 <vixey> nicknull: Using unsafePerformIO is really good programming style :p
11:43:45 <Botje_> vixey: is this reverse psychology? :p
11:43:48 <idnar> heh
11:43:53 <vixey> ... no :)
11:44:02 <Elly> hehe
11:44:10 <Elly> we need a reverse psychology programming guide
11:44:26 <Elly> "Fine. Go ahead and don't check the return value of malloc(). I don't care. I want you not to check it!"
11:44:29 <Vq^> "there was an unsafePerformIO all this time!?!" :o)
11:50:57 <sw17ch> having to check the return value of every freaking function call in C is what makes me love ErrorT
11:51:12 <sw17ch> catastrophic failure? no problem!
11:52:02 <sw17ch> Haskell: making catastrophic failures into nuisances since the mid 1970's
11:52:29 <sw17ch> bah, because some one will complain....
11:52:35 <sw17ch> Haskell: making catastrophic failures into nuisances since 1998.
11:53:59 <nicknull> vixey: the most basic and effective debugging tool is still inserting print-statements, that's why im wondering. not to actually use it in a real programs
11:55:29 <sm> that's what Debug.Trace is
11:55:51 <jensen> So, finally got cabal-install compiled, and attempted to install package uuid (to get Data.UUID), however, a dependency needs "base ==4.*", which is not available.
11:56:09 <jensen> Any ideas to what I can do to fix this? :/
11:56:11 <nicknull> where is unsafePerformIO ?
11:56:37 <dcoutts> jensen: try an older version of that dependency, base-4 only comes with 6.10, so any older version of that package would have worked with 6.8 and base-3
11:56:39 <maltem_> jensen: base-4 is introduced with ghc 6.10
11:56:57 <jensen> okay
11:57:33 <rwbarton> jensen: it's HUnit right?   cabal install uuid HUnit-1.2.0.0  should work
11:57:34 <maltem_> ... along with a set of headaches how to make the least packages break on base-3/4
11:57:36 <nicknull> ok what is unsafePerformIO for then?
11:57:36 <nicknull> Debug.Trace doesnt seem to work
11:57:36 <nicknull> i cant import Debug nor refer to Debug.Trace, not ghci at least
11:57:41 <jensen> rwbarton: correct, its HUnit
11:57:51 <jensen> rwbarton: thanks! i'll try it out
11:58:18 <nicknull> import Debug.Trace actually worked
11:59:22 <jensen> rwbarton: yeah, that seems to have done the trick, it's compiling the packages now.
12:00:50 <nicknull> the documentaion of haskell really needs some examples and not just a description of what stuff does
12:01:08 <sm> nicknull: that's it. Now put "trace (some string expression) ..." before some expression. You must be careful to preserve precedence and grouping of the code
12:01:10 <nicknull> sq x = x*x, how do i use trace on that?
12:01:45 <sm> sq x = trace (show $ x*x) $ x*x   eg
12:02:12 <sm> you will find it clunky at first. here's an easier variant you should define..
12:02:27 <sm> strace a = trace (show a) a -- trace and return a showable expression
12:02:51 <sm> with that one you can say sq x = strace $ x*x
12:03:26 <sm> maybe
12:04:40 <nicknull> yes thanks
12:07:35 <sbahra> Loading package parsec-2.1.0.1 ... linking ... <interactive>: /home/sbahra/software/lib/HTTP-3001.0.4/ghc-6.8.3/HSHTTP-3001.0.4.o: unknown symbol `networkzm2zi2zi0zi0_NetworkziSocket_a312_info'
12:07:35 <sbahra> ghc-6.8.3: unable to load package `parsec-2.1.0.1'
12:07:44 <sbahra> Any ideas what is going on?
12:08:27 <vixey> anyone writesa tableaux in haskell?
12:08:42 <dcoutts> sbahra: my guess is that network has been rebuilt without HTTP being rebuilt too
12:08:50 <dcoutts> sbahra: try rebuilding HTTP
12:09:28 <sbahra> dcoutts, ok, I'll try. Thanks.
12:10:03 <eu-prleu-peupeu> hello ppl from planet haskell
12:10:20 <mightybyte> @pl enumFrom minBound
12:10:21 <lambdabot> [minBound..]
12:10:52 <Deewiant> @unpl [minBound..]
12:10:53 <lambdabot> [minBound ..]
12:12:17 <Peaker> @unpl sucks
12:12:17 <lambdabot> sucks
12:13:11 <sbahra> dcoutts, works
12:13:33 <dcoutts> sbahra: great, we do need a better way of detecting and fixing these cases.
12:13:43 <dcoutts> sbahra: I've filed a couple tickets
12:14:29 <dcoutts> theses cases seem to be cropping up more frequently now, it's partly the fault of cabal-install but also because we do not track enough info in ghc's installed packages to detect these inconsistencies
12:16:24 <dcoutts> dons: we need to submit a proposal for ICFP next year for the hackathon
12:16:32 <dcoutts> dons: the deadline is the 19th next month
12:17:50 <soundy> hello, I just found this room, and wanted to as if someone maybe could answer a haskell beginner question about getting values out of a Map from a Monad.State
12:18:09 <soundy> or knows a good description?
12:18:39 <sbahra> soundy, you might be better off giving us an example of what you want to do (show us code)
12:18:47 <soundy> ok
12:19:00 <jensen> Hm, I am attempting to install the package 'hxt' with cabal-install, this requires curl which failes the configure step, because some libraries are not found. The output mentions a config.log-file, which is nowhere to be found. Anyone got an idea? :/
12:19:00 <roconnor> @hoogle collate
12:19:00 <lambdabot> No results found
12:19:09 <roconnor> @wn collate
12:19:12 <lambdabot> *** "collate" wn "WordNet (r) 2.0"
12:19:12 <lambdabot> collate
12:19:12 <lambdabot>      v 1: compare critically; of texts
12:19:12 <lambdabot>      2: to assemble in proper sequence; "collate the papers"
12:19:17 <nicknull> yeah i couldnt install curl either
12:19:28 <nicknull> im having problems alot when using cabal
12:19:29 <soundy> @sbahra: createTable :: TName -> Columns -> DBM ()
12:19:29 <soundy> createTable n c = do
12:19:29 <soundy>   v <- get
12:19:29 <soundy>   put (M.insert n (Table c []) v)
12:19:29 <lambdabot> Unknown command, try @list
12:19:31 <nicknull> using windows
12:19:38 <jensen> nicknull: hm, damn..
12:19:39 <soundy> for example
12:19:50 <rwbarton> jensen: you said ubuntu right?  Try installing libcurl4-dev
12:20:04 <nicknull> anyway i want a lib for opening a webpage and then reading in all the text. is there one(other than network or curl)?
12:20:07 <soundy> @sbarha I want to look if the values are stored succesfully
12:20:07 <lambdabot> Unknown command, try @list
12:20:48 <soundy> @sbarha but I can't find out how to reach them becaus I get a function returne s -> (s,a)
12:20:48 <lambdabot> Unknown command, try @list
12:21:29 <yitz> soundy: don't use @ at beginning of msg except for bot commands.
12:21:37 <soundy> k
12:21:39 <nicknull> jensen: being sarcastic about windows are we?
12:22:56 <jensen> nicknull: heh, nah, not really, it was to the curl-problem.
12:23:20 <jensen> rwbarton: Jep, Ubuntu, I'm trying that right now.
12:24:37 <nicknull> should downloaded libs be in /lib along with the stanbdard libraries?
12:27:22 <jensen> rwbarton: Spot on. That worked.
12:29:21 <yitz> soundy: you mean for debugging, while your program is running?
12:29:27 <kowey> cool, hackage now displays modules hierarchically
12:29:53 <Deewiant> wow
12:30:33 <soundy> yitz: no just to see if the state actually did change and what has been added, so as helper during development
12:32:01 <soundy> yitz: actually I want to use M.lookup but the monad stays between ;)
12:33:02 <yitz> soundy: put it inside the monad - just like the code that you posted before. but then - what do you want to do with the value you look up?
12:33:30 <yitz> soundy: it sounds to me like you are looking for trace
12:33:32 <mightybyte> Could someone give me a hand getting http://hpaste.org/11208 to compile?
12:33:36 <yitz> @type trace
12:33:37 <lambdabot> Not in scope: `trace'
12:33:47 <soundy> yitz: the value is a table and I have to do some checks before inserting new tables
12:33:48 <yitz> @index trace
12:33:48 <lambdabot> Debug.Trace
12:34:26 <soundy> yitz: ok, I'll check that
12:34:31 <soundy> yitz: thx
12:35:37 <mightybyte> What do you do when adding a concrete type doesn't resolve an "Ambiguous type variable" error?
12:35:59 <yitz> ah. so - do v <- get; let table = M.lookup key v; {- do your checks -}; modify $ M.insert newKey newVal
12:36:20 <yitz> something like that?
12:36:29 <rwbarton> mightybyte: paste the type error too
12:36:44 <rwbarton> mightybyte: oh, never mind
12:37:23 <mightybyte> rwbarton: Done
12:37:36 <soundy> yitz: jep exactly
12:37:42 <nicknull> should downloaded libs be in /lib along with the stanbdard libraries?
12:37:43 * mml` asks of no one in particular, "i don't suppose these galois tech talks ever end up as videos?"
12:37:43 <rwbarton> mightybyte: It doesn't know what type to use in the expression map show [minBound..]
12:38:10 <nicknull> yitz: trace :: String -> a -> a
12:38:50 <mightybyte> rwbarton: Is that because it coulb be different from the one used in the other [minBound..]?
12:38:52 <yitz> nicknull: yeah. \bot isn't allowed to know about those IO kind of things.
12:38:55 <soundy> yitz: in {- do your checks -} I get the result of M.lookup key v?
12:39:00 <rwbarton> mightybyte: The most straightforward solution is to turn on -XScopedTypeVariables, add forall a. after the :: in the type signature, and annotate away
12:39:09 <rwbarton> mightybyte: Right, there's no reason it has to be the same
12:39:36 <yitz> soundy: you get it in let table = ... then you refer to "table" in the checks.
12:39:53 <soundy> yitz: ok
12:40:52 <rwbarton> > let i = id in (i 3, i 'd')
12:40:53 <lambdabot>   (3,'d')
12:40:57 <rwbarton> > let (i) = id in (i 3, i 'd')
12:40:58 <lambdabot>       No instance for (Num Char)
12:40:59 <lambdabot>        arising from the literal `3' at <inte...
12:41:07 <nicknull> i tried to install url-1.0.1, i get missing utf8-string -any
12:41:12 <mightybyte> rwbarton: Hmmm, that doesn't seem to be doing it...maybe my syntax is wrong
12:41:12 <nicknull> ok how d get that?
12:41:16 <rwbarton> mightybyte: you can also write  let (mb) = minBound in ...  but it seems not to be the best way
12:41:19 <vixey> :t let i = id in i
12:41:20 <lambdabot> forall a. a -> a
12:41:23 <vixey> :t let (i) = id in i
12:41:24 <lambdabot> forall a. a -> a
12:41:30 <vixey> :t let (i) = id in (i,i)
12:41:32 <lambdabot> forall a. (a -> a, a -> a)
12:41:34 <vixey> :t let i = id in (i,i)
12:41:35 <lambdabot> forall a a1. (a -> a, a1 -> a1)
12:41:36 <nicknull> its really annoying that you can never just download a library and use it for haskelll...
12:41:45 <mauke> nicknull: what
12:41:48 <vixey> whyyyy
12:41:59 <yitz> soundy: you may then have something like: when checksOK $ modify $ M.insert newKey newValue -- that only inserts the new item if the checks were OK.
12:42:09 <rwbarton> mightybyte: like this? http://hpaste.org/11208#a2
12:42:19 <vixey> pattern bindings have ridiculous wrong type rules or something
12:42:21 <vixey> ?
12:42:21 <vixey> aoe
12:43:04 <rwbarton> pattern bindings are monomorphic, function bindings can be polymorphic
12:43:13 <mightybyte> rwbarton: Ahh, I didn't have ScopedTypeVariables in the right place
12:43:17 <soundy> yitz: ah ok so combining the checks ok
12:43:19 <vixey> that sucks
12:43:26 <vixey> except I suppose it's the only way
12:43:28 <rwbarton> vixey: but yeah the exact syntax rules are kind of weird
12:43:39 <mightybyte> rwbarton: ...and I didn't have minBound::a
12:43:43 <quicksilver> rwbarton: it is rather odd that (i) is different from i
12:43:53 <nicknull> should downloaded libs be in /lib along with the stanbdard libraries?
12:44:06 <yitz> soundy: right, but that's just an example.
12:44:10 <rwbarton> mightybyte: I'm guessing only the second minBound::a matters
12:44:24 <mauke> nicknull: what kind of libs?
12:44:42 <nicknull> mauke: something you downloaded from hackage, lib/package
12:44:54 <nicknull> like :http://hackage.haskell.org/cgi-bin/hackage-scripts/package/conjure
12:44:56 <lambdabot> Title: HackageDB: conjure-0.1, http://tinyurl.com/462sev
12:44:57 <mauke> just install it somewhere
12:45:01 <rwbarton> quicksilver: yeah, it's kind of surprising.  I think there are a couple other places where adding ()s has surprising behavior
12:45:17 <nicknull> well i prefer to have the m collected
12:45:26 <nicknull> so it doesnt matter is what you say...
12:46:17 <nicknull> how do i import Template haskell?
12:46:23 <rwbarton> mightybyte: ScopedTypeVariables lets you write forall a. before a type declaration and then use a within the body of the function to refer to that same type a
12:46:58 <rwbarton> mightybyte: There are usually Haskell 98 workarounds for the problems it solves, but they're less transparent
12:48:17 <yitz> soundy: i've got to go. if you have other questions, there are plenty of people here to help. good luck!
12:48:33 <soundy> yitz: ok thank you :)
12:49:05 <mightybyte> rwbarton: Ok, interesting.  I've never really understood when forall is needed.
12:50:05 <anonymouz666> how do I concat two lists? [Int] -> [Int] -> [Int]
12:50:09 <anonymouz666> I am doing something wrong
12:50:23 <nicknull> how do i import Template haskell?
12:50:47 <mauke> anonymouz666: with ++
12:51:28 <anonymouz666> I am trying to use concat
12:52:10 <rwbarton> > (\i -> (i 3, i 'd')) id
12:52:11 <lambdabot>       No instance for (Num Char)
12:52:12 <lambdabot>        arising from the literal `3' at <inte...
12:52:16 <Philippa_> anonymouz666: concat is for lists of lists
12:52:27 <Philippa_> > concat ["this","works"]
12:52:28 <lambdabot>   "thisworks"
12:52:59 <anonymouz666> I should enter [1,2,3] and [4,5] and the output should be [1,2,3,4,5]
12:53:13 <vixey> anonymouz666: And what you have tried?
12:53:42 <anonymouz666> I am lost because should be a given lists
12:54:03 <anonymouz666> and I don't know to represent this
12:54:21 <rwbarton> mightybyte: I believe the 'forall' keyword is actually used in lots of different ways, which all have more or less similar meanings
12:56:06 <nicknull> anon: [1,2,3]++[4,5]
12:56:23 <nicknull> dont use that when u should use : though
12:56:25 <vixey> anonymouz666>: You could actually (since being a programmer) _IMplement_ this your self
12:56:29 <nicknull> which you shoudnt there but,,,
12:56:37 <vixey> anonymouz666: And do you understand recursion?
12:57:52 <anonymouz666> yes
12:58:13 <mightybyte> Is zero always the Int corresponding to the lowest element in an Enum?
12:58:25 <anonymouz666> nicknull: ok thanks for that. But I want to represent these two given lists
12:58:28 <anonymouz666> like
12:58:29 <rwbarton> > fromEnum (-3) :: Int
12:58:30 <lambdabot>   -3
12:58:46 <Philippa_> rwbarton: the only 'different' way is in traditional datatype declarations, AFAICT
12:58:55 <anonymouz666> $c = concat ($a, $b)
12:59:05 <anonymouz666> (it's just an example)
12:59:11 <vixey> anonymouz666: bad example, syntax error
12:59:11 <rwbarton> Philippa_: "traditional"?
12:59:12 <anonymouz666> not what I am trying to do
12:59:18 <mightybyte> rwbarton: Well...in the enum created by a type like "data Foo = A | B | C"
12:59:20 <vixey> anonymouz666: You can't have $ there like that don't
12:59:22 <Philippa_> rwbarton: as opposed to the "where" syntax that came with GADTs
12:59:30 <rwbarton> mightybyte: For derived instances, I think so
12:59:39 <mauke> anonymouz666: huh?
12:59:45 <rwbarton> Philippa_: like  data Foo = forall a. Foo a
12:59:48 <anonymouz666> vixey: I know I am just trying to explain what I need to do in haskell
13:00:03 <vixey> anonymouz666: Don't explain it with syntax errors though. .......
13:00:05 <mightybyte> rwbarton: Yeah, that's mainly what I'm looking for.
13:00:10 <anonymouz666> given two lists I need to concat them
13:00:18 <mauke> anonymouz666: what's the problem?
13:00:20 <Philippa_> rwbarton: right. If you write it using where instead, it's just another type annotation
13:00:32 <mightybyte> rwbarton: Trying to decide whether I should axe the Bounded requirement in that function
13:00:34 <vixey> anonymouz666: Are you trying to write the function or trying to not write this function?
13:00:44 <anonymouz666> trying to write the function
13:00:46 <rwbarton> mightybyte: I see
13:01:06 <vixey> so 1) know that [1,2,3,4] = 1 : (2 : (3 : (4 : [])))
13:01:26 <mightybyte> rwbarton: I wonder why the Enum class doesn't define a function that gets the whole list of possibilities.
13:01:27 <rwbarton> Philippa_: Hmm.  Technically, forall is also used in RULES, where it's not even scoping over a type variable
13:01:33 <vixey> and now you must define tow cases concat ([], ys) = ....; concat (x:xs, ys) = ...
13:01:36 <anonymouz666> together :: [Int] -> [Int] -> [Int together list = [n | n <- concat(n)] I am trying to do something like that
13:01:53 <vixey> anonymouz666: No that is another syntax error
13:02:34 <rwbarton> Philippa_: "Lots" was an overstatement.
13:02:34 <anonymouz666> I just need an example
13:02:34 <mauke> anonymouz666: wait, can you use predefined functions like concat?
13:02:41 <Philippa_> rwbarton: fair call, I guess. Though I don't really see RULES as part of "Haskell" as opposed to "stuff GHC does"
13:02:49 <anonymouz666> mauke: sure, why not?
13:02:54 <vixey> anonymouz666:  <vixey> and now you must define tow cases concat ([], ys) = ....; concat (x:xs, ys) = ...
13:02:56 <mauke> anonymouz666: then just use ++
13:02:56 <rwbarton> Philippa_: "At least two" :)
13:02:57 <mauke> what the hell
13:03:02 <vixey> anonymouz666: Do you see this?
13:03:07 <anonymouz666> I saw
13:03:11 <vixey> anonymouz666: ..and you have tried doing this now?
13:03:43 <Philippa_> rwbarton: yeah, the datatype case can at least be put down to legacy weirdness though
13:03:59 <nicknull> i dont get it, is it an exercise?
13:05:11 <anonymouz666> vixey: 'cause I don't know where to start with your example
13:05:30 <vixey> anonymouz666: you start by filling in either of the  two blanks
13:06:06 <nicknull> Prelude> concat [[1,2,3],[4,5]] -> [1,2,3,4,5]
13:06:32 <anonymouz666> lists :: [Int] -> [Int] -> [Int] : question how do I see the two given lists?
13:06:50 <anonymouz666> lists [1,2,3] [4,5]
13:06:51 <vixey> anonymouz666: You should think about this thing I said before moving on
13:07:34 <rwbarton> anonymouz666: lists x y = ...
13:08:18 <anonymouz666> lists :: [Int] -> [Int] -> [Int] lists x y = concat stuff ?
13:08:27 <mauke> lists x y = x ++ y
13:08:34 <mauke> or just lists = (++)
13:08:41 <rwbarton> or just use ++ instead of lists
13:09:26 <anonymouz666> working
13:09:28 <anonymouz666> damn
13:09:37 <anonymouz666> I need to stop being so smart...
13:09:39 <nicknull> i dont get it, u want [1,2,3] + [4,5] to be [1,2,3,4,5]. ++ does exactkly that. so why not usre it?
13:09:46 <nicknull> ok
13:10:02 <vixey> I don't know what you mean
13:10:08 <anonymouz666> cause I just learned how to "see" the two given lists
13:10:14 <mauke> what do you mean by "see"?
13:10:22 <anonymouz666> x ++ y
13:10:27 <anonymouz666> lists x y
13:10:28 <mauke> what
13:10:37 <anonymouz666> x y represents the two given lists
13:10:54 <badsheepy> incredible! i must write this down
13:11:17 <anonymouz666> that's functional programming
13:11:22 <anonymouz666> heh...
13:11:25 <vixey> anonymouz66: What are you talking about
13:11:31 <mauke> no, it's called function parameters
13:11:35 <mauke> or variables in general
13:11:38 <vininim_> @hoogle m a -> m (m a)
13:11:39 <lambdabot> Data.List inits :: [a] -> [[a]]
13:11:39 <lambdabot> Data.List tails :: [a] -> [[a]]
13:11:39 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
13:11:57 <vixey> :t return :: Monad m => m a -> m (m a)
13:11:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m (m a)
13:12:18 <rwbarton> , src ''Comonad
13:12:23 <lunabot>  class (Copointed w) => Comonad w where
13:12:23 <lunabot>          duplicate :: forall a . w a -> w (w a)
13:12:23 <lunabot>          extend :: forall b a . (w a -> b) -> w a -> w b
13:15:56 <vininim_> , src concatMap
13:15:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
13:16:15 <mauke> , src 'concatMap
13:16:16 <vixey> ,src ''(\x -> x)
13:16:20 <lunabot>  concatMap :: forall a b . (a -> [b]) -> ([a]) -> [b]
13:16:21 <lunabot>  luna: parse error on input `\'
13:16:29 <vixey> âª src ''(\x -> x)
13:16:31 <lunabot>  luna: parse error on input `\'
13:16:44 <anonymouz666> I don't know if the teacher will allow the use of pre-defined functions in the test
13:16:47 <anonymouz666> =)
13:16:52 <sbahra> musical note?
13:16:56 <sbahra> âª
13:16:56 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
13:17:04 <[Batman]> hey, is there anyway to cast a Maybe Type to just a Type
13:17:08 <sbahra> âª
13:17:08 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
13:17:09 <vixey> [Batman]: No
13:17:14 <sbahra> Oh, that is in response.
13:17:18 <[Batman]> daing
13:17:19 <vixey> [Batman]: You can not every cast anything in haskell
13:17:29 <vixey> [Batman]: If you know it's a Just foo then you can go::
13:17:34 <vixey> getFoo (Just foo) = foo
13:17:51 <rwbarton> @src fromJust
13:17:51 <lambdabot> fromJust Nothing  = undefined
13:17:51 <lambdabot> fromJust (Just x) = x
13:18:03 <mauke> unsafePerformMaybe
13:18:12 <vininim_> o_o
13:18:17 <BMeph> ... use 'maybe' :)
13:18:20 <vixey> haskell is so dangerous!
13:18:21 <nicknull> seriously does anyone know of a haskell library that lets you open URLs and read the page in?
13:18:39 <vixey> [Batman]: There is also this stuff:
13:18:48 <rwbarton> heh, unsafePerformList should fork your program
13:18:48 <BMeph> nicknull: Have you tried...the HTTP library? :)
13:18:54 <vixey> @let something = Just 7
13:18:55 <lambdabot>  Defined.
13:19:01 <vixey> > do x <- something ; return (x+1)
13:19:01 <nicknull> was anonymouz666 just pulling our legs?
13:19:02 <lambdabot>       Ambiguous occurrence `something'
13:19:02 <lambdabot>      It could refer to either `L.somet...
13:19:04 <bastard4> http://www.slave.lt/konkursas/?key=29671c <- double click and close, thanks for your help
13:19:11 <lambdabot> Title: Konkursas! LaimÄk Haruki Murakami knygÄ | slave.lt
13:19:14 <vixey> I don't think it was ambiguous
13:19:29 <rwbarton> @hoogle something
13:19:29 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
13:19:32 <[Batman]> thank you
13:19:46 <vixey> > let something = Just 7 in          do x <- something ; return (x+1)
13:19:48 <lambdabot>   Just 8
13:19:50 <vixey> k...
13:19:53 <vixey> lambdabot--
13:20:26 <vixey> bastard4: No that is completely unacceptable anywhere on freenode..
13:21:16 --- mode: ChanServ set +o Heffalump
13:21:59 --- mode: Heffalump set +b *!n=kma@78-61-233-147.static.zebra.lt
13:22:03 <BMeph> vixey: You do know 'someting' is already defined, right? :)
13:22:06 --- kick: bastard4 was kicked by Heffalump (spamming)
13:22:19 <vixey> BMeph :(
13:22:24 <vixey> all the good names are used up
13:22:24 <idnar> @undef
13:22:34 <idnar> @type something
13:22:35 <lambdabot> forall u a. (Data a) => GenericQ (Maybe u) -> a -> Maybe u
13:22:54 <BMeph> vixey: If by 'good', you mean 'easily thought-of'...then yeah. :)
13:22:54 <idnar> what is that?
13:24:14 * BMeph wants one of those fabled Haskell T-shirts to have "@hoogle something" and its type sig
13:24:34 <nicknull> cabal makes me feel like -> unsafePerformSuicide
13:24:34 <Elly> there are fabled haskell T-shirts?
13:24:44 <Elly> nicknull: suicide monad!
13:24:55 <BMeph> Elly: "Have you played with your monads today?" ;)
13:24:55 <idnar> cut along, not across
13:25:05 <RayNbow> SuicideT?
13:25:11 <Elly> BMeph: I like it :P
13:25:48 <mauke> nicknull: do you know about http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install ?
13:25:50 <lambdabot> Title: HackageDB: cabal-install-0.6.0, http://tinyurl.com/2sj7lw
13:26:32 <jeffz> I think nicknull mentioned that he's on windows and some packages require configure
13:26:33 <nicknull> BMeph: hpow do i import Http?  install actually worked!
13:27:05 <jeffz> I've found that mildly annoying
13:27:51 <Deewiant> I've found that very annoying, since the average configure takes 20 minutes to run and does something wrong the first time :-P
13:28:11 <Elly> Deewiant: configure can do any of an arbitrary number of things wrong, and each time you fix one, you get the next one
13:28:21 <Elly> Deewiant: the trick is reducing it to an acceptable level of wrongness before you run make :P
13:28:57 <Deewiant> Elly: yep, and the fact that after each change you have to wait 20 minutes makes it really aggravating
13:29:34 <Elly> ahh
13:29:39 <Elly> configure takes more like a minute for me
13:29:43 <Elly> but my laptop is pretty new
13:29:46 <Deewiant> I take it you're not on Windows
13:29:52 <Elly> of course not :P
13:29:56 <Deewiant> yeah
13:30:00 <Elly> on windows it'd take FOREVER because of all the processes it makes
13:30:02 <Deewiant> that makes a difference
13:30:03 <Deewiant> exactly
13:30:07 <Deewiant> hence, 20 minutes
13:30:15 <Elly> that's unfortunate, but not unexpected
13:30:23 <Elly> configure works alright if you have a unix process model :P
13:30:34 * Deewiant digs up some timings from a Reddit comment
13:30:34 <Elly> it's arguably less wrong than autoconf
13:30:40 <rwbarton> , something Data.Typeable.cast ("hello", [5, 7], 23.9) :: Maybe Integer
13:30:40 <Deewiant> configure --help, Windows: real    0m22.703s
13:30:42 <lunabot>  Just 5
13:30:45 <rwbarton> , something Data.Typeable.cast ("hello", [5, 7], 23.9) :: Maybe Double
13:30:45 <Deewiant> configure, Windows: real    17m37.373s
13:30:47 <lunabot>  Just 23.9
13:30:50 <Deewiant> configure, Linux: real    0m12.301s
13:30:52 <rwbarton> , something Data.Typeable.cast ("hello", [5, 7], 23.9) :: Maybe ()
13:30:54 <lunabot>  Nothing
13:30:57 <nicknull> ould not find module `Network.HTTP':
13:30:57 <nicknull> but the install of http worked...
13:30:57 <nicknull> so it installs on top of Network? since network alread y is astdlib module
13:31:10 <Deewiant> Elly: so... yeah. configure --help on Windows takes twice as long as plain configure on Linux
13:31:45 <Elly> Deewiant: oh, wow :P
13:31:48 <nicknull> runghc Setup configure or runhaskell Setup.lhs configure is the same right?
13:31:53 <Elly> Deewiant: switch to a real OS? :P
13:32:08 <Deewiant> Elly: as soon as it supports games
13:32:26 <Elly> Deewiant: wine :)
13:32:38 <Deewiant> I said "games", not "0.01% of games" :-P
13:32:45 <Elly> Deewiant: name one :)
13:32:46 <jeffz> wine only works if you have an nvidia video card, ati's drivers are no good.
13:32:53 <nicknull> maybe i should just write my own
13:32:53 * Elly does have an nvidia video card
13:33:02 <Deewiant> Elly: space empires v
13:33:12 <Elly> Deewiant: I don't own SE5, but SE4 works flawlessly for me
13:33:18 <Deewiant> yes, I know
13:33:22 <Deewiant> SE4 does, 5 doesn't. :-P
13:33:26 <mauke> silly kids, just use an SNES emulator
13:33:31 <nicknull> haskell will be like lisp. everyoen writs their own stuff and noone ever gets anywhere
13:33:33 <Deewiant> actually, sounds didn't work in SE4.
13:33:36 * Elly currently has warcraft 3, Dawn of War, and Doom 3 installed
13:33:38 <schme> Just play nethack like ordinary people.
13:33:46 <Elly> schme: crawl! :)
13:33:51 <Deewiant> Omega!
13:34:17 <schme> crawl is nice indeed!
13:34:31 <rwbarton> crawl is hard though
13:34:37 <Deewiant> and Nethack is easy? :-P
13:34:46 <schme> nethack is not so hard.
13:35:00 <nicknull> import Network.HTTP is an example but doesnt work for me
13:35:02 <Deewiant> Elly: alright, how about: any DirectX-10-only game
13:35:07 <cads> gives <3 to nethack
13:35:14 <schme> Deewiant: What I think the best solution for that space empires game of yours is if you write an implementation of it yerself. In haskell maybe ;)
13:35:15 <Deewiant> Elly: granted, doesn't work on my XP either :-P
13:35:16 <Elly> Deewiant: those don't run on my card, so I haven't tried them
13:35:20 <Elly> Deewiant: but I bet they don't work on -
13:35:22 <Elly> e:f;b
13:35:37 <mauke> herm use loo ecstamin
13:35:37 * cads currently has nethack and glChess installed
13:35:39 * Elly tends to play Warcraft 3, Dawn of War, and UT/UT2004
13:35:49 <Elly> UT and UT2004 have native ports and the other two run fine under Wine
13:35:55 <Deewiant> schme: yeah, it's the 'best' solution in that I'm guaranteed to get what I want but it's also the worst in several other ways :-P
13:36:02 <schme> :(
13:36:13 <schme> Think of the good!
13:36:22 <Deewiant> why don't you do it?
13:36:26 <nicknull> runghc Setup configure or runhaskell Setup.lhs configure is the same right?
13:37:07 <Deewiant> Elly: I appear to have 162 games in my games directory... I guarantee you that many of those will not run under Wine :-P
13:37:12 <Deewiant> nicknull: yep
13:37:29 <cads> hey, I've got a folder with 50+ papers from citeseerx and arxiv, and they're all random math/programming papers with random number filenames and no bookmarks internally.. this is madness
13:37:38 <vixey> crazy
13:37:48 <cads> do you guys have any favorite tools for organizing such insanity?
13:38:02 <vixey> yeah delete it once you read it
13:38:03 <Elly> cads: a file system is traditional
13:38:03 <Botje_> give sensible names
13:38:10 <jeffz> cads, precognition
13:38:12 <vininim_> citeseerx and arxiv should give sensible names
13:38:23 <nicknull> i now have ghc/lib/http-3000/
13:38:27 <schme> Deewiant: I have a very good reason for not doing it. I play computer games like an hour every other year.
13:38:56 <Deewiant> schme: and so would I, if I were to use your solution ;-)
13:39:23 <schme> Deewiant: Well it's more an issue of computer games not being very entertaining for me.
13:39:25 <nicknull> and ghc/lib/http-3000/network/http
13:39:25 <nicknull> so network.http is there but ghc cant find it
13:39:25 <nicknull> so it does matte rwhere i out the libs
13:39:25 <nicknull> wait
13:39:47 <vininim_> schme: you don't need to play them ;)
13:39:54 <schme> vininim_: I don't.
13:40:13 <sm> nicknull: you really should not be figuring out where to put things by hand
13:40:20 <vininim_> you'll have plenty of testers if you write one
13:40:43 <nicknull> wtf i hadnt restarted emacs...
13:41:02 <nicknull> how do i make emacs reload without closing and reopening?
13:41:18 <schme> reload what?
13:41:18 <jeffz> nicknull: reload what?
13:41:35 <sm> cabal install (possibly helped with --user or --global) or runhaskell Setup.hs install should know where to put things. See also ghc-pkg list and expose commands
13:41:43 <Heffalump> meta-x refresh-buffer
13:41:57 <Heffalump> no, sorry
13:42:08 <Heffalump> revert-buffer
13:42:11 <dcoutts> :-)
13:42:50 <dcoutts> sm: ghc-pkg expose is usually a red herring
13:43:17 <sm> ok.. I've had to fiddle with it in the past, but probably because of legacy stuff
13:43:51 <sm> dcoutts: did my first cabal upload yesterday, it worked beautifully. thanks!
13:46:18 <dcoutts> great
13:47:02 <dcoutts> sm: oh was that hledger?
13:47:09 <sm> yes
13:47:38 <roconnor> @type mapM_
13:47:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:48:10 <roconnor> I think it would be marginally better for mapM_ to take a function of type (a -> m ())
13:48:11 <dcoutts> sm: cool. we may evaluate that and possibly use it.
13:48:29 <roconnor> well
13:48:29 <sm> great, what for ?
13:48:32 <vixey> I can't see why roconnor
13:48:32 <roconnor> maybe it's fine it is.
13:48:54 <roconnor> vixey: It might prevent errors where people are accidentally throwing away results
13:49:03 <dcoutts> sm: keeping track of simple accounts
13:49:13 <roconnor> but with do notation, it is pretty easy to throw away results I guess
13:49:45 <sm> I guess that was obvious. :) Just the "we may evaluate" sounded unconventional
13:50:25 <dcoutts> sm: well, I mean look at it, see if it'd be suitable
13:50:35 <sm> yup
13:51:46 <roconnor> using doubles instead of rationals really speeds up my program
13:51:52 <roconnor> but it makes me feel dirty
13:52:03 <vixey> I don't like doubles :/
13:52:24 <roconnor> I don't have my floating point license
13:52:42 <rwbarton> I'm getting lots of these errors building gtk2hs: $* is no longer supported at /usr/lib/ghc-6.8.2/ghc-split line 39.  Can I ignore them?
13:52:48 <sm> is there a fast Decimal type ?
13:53:26 <pizza_> define fast
13:54:17 <dcoutts> rwbarton: your perl is too new it looks like. This is fixed in 6.10, you may be able to back-port it, or it might be fixed in 6.8.3, I'm not sure.
13:55:05 <mauke> rwbarton: no
13:55:15 <rwbarton> dcoutts: Right, I ran into this before with the evil mangler, but that got resolved somehow
13:56:27 <sm> pizza_: not subject to the same kind of slowdown as rationals mentioned above
13:59:12 * THE_MITT_ROMNEY throws up
14:00:23 <viktator> hey, could anyone help me understand the '.' operator for combining functions?
14:00:40 <viktator> i been told f.g x = f(g(x))
14:00:40 <dcoutts> @src (.)
14:00:40 <lambdabot> (f . g) x = f (g x)
14:00:45 <vixey> it's not quite that
14:00:52 <vixey> f.g x actually parses as f . (g x)
14:00:54 <vixey> which is wrong
14:01:01 <viktator> ok?
14:01:14 <viktator> okey
14:01:29 <viktator> a so bracketing would do the job?
14:03:01 <dcoutts> viktator: right, either (f . g . h) x or f . g . h $ x
14:03:28 <Phyx-> Hi, i was wondering if someone can point me to a good State monad tutorial? i've run into a bit of a problem, i have a function that returns a State Foo but i need the value of Foo, but i can't find like i usually do , eg. do val <- func, it complains about the type not being IO
14:03:30 <viktator> okey
14:03:36 <viktator> ill check!
14:03:59 <viktator> yey, it works! thank you
14:04:49 <vixey> since  f . (g . h) = (f . g) . h  (it's easy to check this if you apply an x to each side) so you can just write (f . g . h) anywhere
14:10:48 <rwbarton> Well, gtk2hs and then yi compiled and installed, but yi -fgtk is pretty broken for me, so maybe I need to hunt down this bug fix
14:11:56 <vixey> (f . g)^-1 = g^-1 . f^-1
14:12:48 <vixey> actually,
14:12:55 <vixey> (f . g)Âº = gÂº . fÂº
14:14:32 <mauke> ÂºvÂº
14:14:53 <Cale> Phyx-: It's important to keep *which* monad you're using straight. In any do-block, all the actions have to be in the same monad.
14:14:56 <psnively> Hi guys.
14:15:00 <vixey> hello
14:15:02 <Cale> Hello
14:15:36 <Cale> Phyx-: Eventually, once you've built up your whole computation, you'll use runState/evalState/execState to run it.
14:16:14 <Cale> "This work is licensed under a Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported License because I couldn't find a license with an even longer name." hehe
14:16:33 <psnively> *sigh*
14:17:26 <Phyx-> Cale: yeah, i figured that out a few secs ago
14:17:33 <Phyx-> already writing the code to do it
14:17:38 <vixey> I may port ilearnTAP
14:17:46 <vixey> ileanTAP*
14:18:11 <Phyx-> Cale: and thanks for the first comment, that explains why i'm getting these type errors
14:21:16 <Phyx-> Cale: is it possible to use two different monads in one function? i need to get a IO value and state value
14:21:46 <vixey> ?go stacking Monad Transformers
14:21:48 <lambdabot> http://www.haskell.org/all_about_monads/html/stacking.html
14:21:48 <lambdabot> Title: Managing the transformer stack
14:21:54 <vixey> not that
14:21:58 <Cale> Phyx-: Well, how to tackle that depends on the extent to which you're using values from both IO and State
14:22:17 <Phyx-> not to very much
14:22:19 <Cale> Phyx-: Most likely, you just want to write an IO action that calls runState.
14:22:21 <Phyx-> both are just 1 calls each
14:22:33 <Phyx-> well, i use an io action to read a file
14:22:33 <Cale> (to run your state computation)
14:22:50 <Phyx-> that string gets used to calculate the expression, and from that i call evalState
14:23:08 <Phyx-> and the type of that function is IO
14:23:16 <Phyx-> but i can't call get then to get the state
14:23:30 <Cale> Ah, use runState
14:23:51 <Cale> To get both the result of the State computation and the final state.
14:24:14 <Phyx-> *tries*
14:25:05 <Cale> You are probably going to want to parametrise your State computation by that String containing the file's contents:  String -> State MyStateType Foo
14:25:27 <Phyx-> Ahhhh
14:25:34 <Phyx-> i get what you mean now
14:25:36 <Phyx-> makes sense
14:26:21 <Cale> and then in IO, write  do xs <- readFile "something.dat"; let (result, finalState) = runState (myComputation xs); print result; ... etc.
14:26:48 <Phyx-> hm, runState takes only 1 argument?
14:26:57 <vixey> :t runState
14:26:58 <lambdabot> forall s a. State s a -> s -> (a, s)
14:27:25 <Cale> er, sorry
14:27:39 <Cale> runState (myComputation xs) initialState  :)
14:28:23 <Phyx-> where i'm guessing initialState isn't a function but a value :P
14:29:01 <Cale> Well, it *could* be a function.
14:29:08 <Phyx-> heheeh
14:29:13 <Cale> But is more likely to be some other type of value.
14:29:16 <vixey> uh
14:29:23 <vixey> functions are values!
14:30:30 <ddarius> > execState (replicateM 10 (modify (1+)) 0
14:30:31 <lambdabot>   <no location info>: parse error on input `;'
14:30:46 <idnar> values are functions!
14:30:47 <vixey> stop using so many ';'s ...
14:31:01 <ddarius> > execState (replicateM 10 (modify (1+))) 0
14:31:02 <lambdabot>   10
14:31:12 <ddarius> Doh
14:31:39 <ddarius> > execState (replicateM 10 (modify ((1+). ))) id 0
14:31:40 <lambdabot>   10
14:32:13 <Phyx-> well, i'm still kinda stuck on something, http://phyx.pastebin.com/d62331e13
14:32:17 <rog> > execState (replicateM 100000000 (modify ((1+). ))) 0
14:32:19 <lambdabot>       No instance for (Num (a -> t))
14:32:19 <lambdabot>        arising from the literal `0' at <...
14:32:23 <Phyx-> that's the function i'm trying to make
14:32:47 <rog> > execState (replicateM 10 (modify (1+))) 100000000
14:32:47 <mauke> Phyx-: what state are you trying to get?
14:32:48 <lambdabot>   100000010
14:33:22 <Phyx-> mauke: well, the current, i'm guessing i should use that to call evalState? i don't know the state monad verywell
14:33:32 <rog> what are the space characteristics of that line?
14:33:50 <Phyx-> space characteristics?
14:33:50 <mauke> Phyx-: what current state? you're not in a state monad there, you're in IO
14:34:17 <Phyx-> mauke: and that's my problem, if i'm in a State monad, i can't use io right? so then i can't read the file
14:34:32 <Phyx-> or am i misunderstanding something?
14:34:34 <rog> as in: do all the n replicateM instances get instantiated into one list before getting passed to execState?
14:34:42 <mauke> parseFile :: String -> StateT MyState IO ()
14:34:58 <mauke> content <- liftIO (readFile filepath)
14:35:00 <rog> @type replicateM
14:35:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:35:11 <Phyx-> ah
14:35:15 <Phyx-> cool, lemme try that
14:37:28 <Phyx-> hey it compiles
14:37:48 <rog> 'cos i can't see how they wouldn't. although it doesn't seem to be running out of space. hmm.
14:38:01 <Phyx-> ehh..?
14:38:18 <twxfn> who wants to hear the best song i've written in my life
14:38:44 <Phyx-> mauke: is there anyway for me to run that from ghci now? to see the results?
14:39:06 * twxfn throws up
14:39:19 <rog> i'm looking at ddarius's line of code, and trying to work out how the result of replicateM can be generated lazily.
14:39:21 <mauke> :t runStateT
14:39:22 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:39:55 <Phyx-> ok
14:39:56 <Phyx-> thanks
14:41:47 <rog> ah there's some serious optimisation going on there
14:41:49 <rog> > execState (replicateM 10 (modify (1+))) 100000000000000000000000000000000
14:41:50 <lambdabot>   100000000000000000000000000000010
14:42:05 * twxfn frowns
14:42:08 <rog> it's not actually doing all those additions, is it?
14:42:19 * twxfn looks at rog all funny-like
14:42:19 <kaizoku> Oh cool
14:42:21 <kaizoku> > :t 'c'
14:42:22 <lambdabot>   <no location info>: parse error on input `:'
14:42:25 <kaizoku> Aww :(
14:42:35 <dv_> > execState (replicateM 10000000000000000000 (modify (1+))) 1
14:42:36 <kaizoku> > show 5
14:42:37 <lambdabot>   1
14:42:37 <rwbarton> all 10?
14:42:38 <lambdabot>   "5"
14:43:06 * rog is *so* stupid
14:43:23 <twxfn> > foldl (+) 1 (map (\x->x^2) [1..1000])
14:43:24 <lambdabot>   333833501
14:43:33 * twxfn throws up
14:43:54 <rog> > execState (replicateM 1000000 (modify (1+))) 0
14:43:56 <twxfn> hold on...
14:43:57 <lambdabot>   * Exception: stack overflow
14:43:59 <twxfn> > foldl (+) 1 (map (\x->x^2) [1..1000000])
14:44:01 <lambdabot>   * Exception: stack overflow
14:44:03 <rog> that's more like it
14:44:05 <twxfn> > foldl (+) 1 (map (\x->x^2) [1..10000])
14:44:06 <lambdabot>   333383335001
14:44:11 <twxfn> that's really cool :D
14:44:18 <twxfn> i love when numbers do that
14:44:20 <vixey> > error "stack overflow"
14:44:21 <lambdabot>   * Exception: stack overflow
14:44:24 <vixey> !
14:44:33 <rwbarton> > fix error
14:44:33 <mauke> > fix error
14:44:38 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:44:40 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:44:46 <vixey> @let stackOverflow = error "stack overflow"
14:44:47 <lambdabot>  Defined.
14:44:49 <ddarius> > foldl' (+) 1 $ map (^2) [1..1000000]
14:44:51 <lambdabot>   333333833333500001
14:44:59 <mauke> monadic stack pointer overflow
14:45:07 <vixey> > error "monadic stack pointer overflow"
14:45:08 <lambdabot>   * Exception: monadic stack pointer overflow
14:45:34 <twxfn> > error "hello vixey"
14:45:35 <lambdabot>   * Exception: hello vixey
14:45:49 <ddarius> > error "\nfoo"
14:45:50 <lambdabot>   * Exception:
14:45:51 <lambdabot>  foo
14:46:00 <vixey> bar
14:46:01 <twxfn> > error "Exception: Exception: Exception: Exception: stack overflow"
14:46:02 <lambdabot>   * Exception: Exception: Exception: Exception: Exception: stack overflow
14:46:03 <tromp_> :t or
14:46:04 <lambdabot> [Bool] -> Bool
14:46:17 <lament> > error $ cycle "Exception\n"
14:46:18 <lambdabot>   * Exception: Exception
14:46:19 <lambdabot>  Exception
14:46:19 <lambdabot>  Exception
14:46:19 <lambdabot>  Exception
14:46:19 <lambdabot>  Exception
14:46:21 <lambdabot>  Excepti...
14:46:33 <vixey> @farbar
14:46:34 <lambdabot> He's casting a red herring on the face of the water.
14:46:37 <vixey> @noxin
14:46:38 <lambdabot> Maybe you meant: join nixon
14:46:41 <vixey> @nixin
14:46:41 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
14:46:41 <lambdabot> seen it. I know. I believe that.
14:46:54 <vixey> @keal
14:46:54 <lambdabot> i think it because mathematics damage you cpu
14:47:12 <vixey> @noxon
14:47:12 <lambdabot> The press is the enemy.
14:47:18 <twxfn> :D
14:47:23 <twxfn> <3 lambdabot
14:47:31 <lament> error $ cycle "\n * Exception:" -- even better
14:47:48 <twxfn> hmm
14:47:52 <twxfn> > error $ cycle "\n"
14:47:54 <lambdabot>   * Exception:
14:47:59 <twxfn> > error $ cycle " \n"
14:48:00 <lambdabot>   * Exception:
14:48:00 <lambdabot>  
14:48:00 <lambdabot> ...
14:48:11 <twxfn> > error $ cycle "?!?!?!?!?!\n"
14:48:12 <lambdabot>   * Exception: ?!?!?!?!?!
14:48:12 <lambdabot>  ?!?!?!?!?!
14:48:12 <lambdabot>  ?!?!?!?!?!
14:48:12 <lambdabot>  ?!?!?!?!?!
14:48:12 <lambdabot>  ?!?!?!?!?!
14:48:14 <lambdabot>  ?!...
14:48:18 <twxfn> :)
14:48:28 <lament> ...
14:49:21 <twxfn> ./\.
14:49:29 <twxfn> it's a volcano
14:49:46 <dons> mm.
14:49:49 * twxfn runs away
14:49:56 <vixey> @quote
14:49:56 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
14:49:57 <dons> we're allowing lambdabot to do multiline output now?
14:50:08 <twxfn> don't shoot the messenger!
14:50:08 <dons> runplugs forever!
14:53:08 <Saizan> dons: how did it reported exceptions?
14:55:19 <dons> Exception: foo
14:55:37 <dons> seriously, we did all this, and it worked well. and it was secure. sigh.
14:56:08 <lispy> Surely there was a good reason for the switch?
14:56:33 * lispy glares at at Cale, "right?"
14:56:49 <dons> someone couldn't install plugins 1.2 ?
14:57:00 <dons> i don't know.
14:57:03 <Saizan> dons: right, and if the exceptions contained a newline?
14:57:19 <dons> they were removed. only one line of input was ever returned.
14:57:39 <dons> there's a whole bunch of nice error handling in the Eval.hs module that was not ported to mueval
14:58:09 <Saizan> oh, well, when we had to decide we settled to just indent the other lines instead of altering the output
14:58:31 <lispy> mueval gives worse output, and it seems to be stricter than runplugs
14:58:40 <dons> a pretty good rule: print only one line of output, ever.
14:59:17 <Saizan> lispy: stricter?
14:59:33 <dons> less things work, he means.
14:59:34 <lispy> (it also leaves zombies and doe something where my server keeps running out of memory and the oom-killer gets invoked)
14:59:45 <lispy> Er, opposite of laziness
14:59:56 <lispy> There are things I could evaluate on runplugs that result in "thread killed" now
15:00:17 <dons> yup.
15:00:20 <Saizan> the zombie problem was the one they tried to solve removing runplugs :)
15:00:26 <dolio> It was doing that before mueval.
15:00:32 <dons> totally unrelated though.
15:00:44 <dons> waitForProcess + -threaded
15:00:46 <lispy> okay, we could use the double-fork ala xmonad then
15:00:51 <dons> zactly
15:01:17 <dons> just rewrite random things in the security layer until some other thing works.
15:02:15 <Saizan> so, it shouldn't be hard to rollback and fix the fork problem for one who knows how it worked?
15:02:46 <dons> yes.
15:02:47 <lispy> Saizan: i assume you're right.  The trick is finding the motivated party that will make time for this.
15:02:53 * ddarius improves security and fixes the zombie problem by making @run more strict on input.  handle _ = return "thread killed"
15:03:25 <vixey> why not add lambdabot features into luna
15:04:53 <Saizan> vixey: because we'd have to reimplement all the plugins system into luna, and then we can basically lambdabot back
15:04:59 <Saizan> *get
15:05:10 <lispy> vixey: what is luna?
15:05:18 <Saizan> , "this is luna"
15:05:18 <lispy> "Why luna?" <-- another way to ask
15:05:20 <lunabot>  "this is luna"
15:05:37 <lispy> obviously luna is a bot here, but I want to know what is special :)
15:06:10 <Saizan> it has TH and nice things in scope
15:06:26 <rwbarton> , let x = x in x
15:06:29 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:07:05 <Saizan> so, really not valid reasons to switch an ircbot, imo, maybe valid reasons to make use of its the eval backend
15:07:20 <Saizan> s/the//
15:09:48 <nicknull> could someone give or point to a very good example of monte carlo methods (except for wikipedia) ?
15:13:14 <roconnor> @hoogle color
15:13:14 <lambdabot> Text.XHtml.Transitional color :: String -> HtmlAttr
15:13:14 <lambdabot> Text.XHtml.Transitional bgcolor :: String -> HtmlAttr
15:13:14 <lambdabot> Text.XHtml.Frameset bordercolor :: String -> HtmlAttr
15:14:35 <tromp_> how do you make map refer to Data.List.map instead of Data.Map.map again?
15:15:26 <dolio> import Data.Map hiding (map)
15:15:48 <tromp_> thx, dolio
15:16:22 <mapreduce> dons: For http://www.galois.com/blog/2008/10/09/type-correct-changes-a-safe-approach-to-version-control-implementation/ - it'd just be nicer if you omitted the line 'comments are closed'.  I don't know why, but that line says "fuck you, readers" to me.
15:16:28 <lambdabot> Title: Galois âº Blog âº Blog Â» Type Correct Changes: A Safe Approach to Version Con ..., http://tinyurl.com/4decec
15:16:36 <roconnor> I feel like making a Colour package for hackage.
15:17:01 <roconnor> does hoogle index all of hackage?
15:18:24 <dolio> hayoo does.
15:19:07 <roconnor> @where hayoo
15:19:07 <lambdabot> I know nothing about hayoo.
15:19:35 <rwbarton> This elastic tabstops thing is pretty cool.
15:19:45 <rwbarton> It just needs some Haskell-specific knowledge to be usable
15:22:09 <nicknull> could someone give or point to a very good example of monte carlo methods (except for wikipedia) ?
15:24:26 <lispy> mapreduce: it's on reddit if you want to comment
15:24:39 <ronwe> does anyone know of a secondary jEdit mode for haskell, other than the one packaged with it?
15:24:40 <mapreduce> That's where I noticed it from.
15:25:24 <roconnor> @hayoo color
15:25:25 <lambdabot> Unknown command, try @list
15:25:40 <dolio> hayoo's linked from the hackage front page.
15:26:40 <lispy> I think it's funny that the top comment on the reddit page is one about the fonts used :)
15:27:49 <vininim_> > randoms (mkStdGen 2) :: [Double]
15:27:51 <lambdabot>   [0.23123395599686403,0.6602530742902898,0.7992004084631801,0.94699959164648...
15:28:36 <Cale> Well, I can think of at least one reason that mueval is more convenient than runplugs. hs-plugins requires packages to be installed globally or else it behaves as if they don't exist.
15:30:11 <Cale> Which means that in order to get lambdabot working from my user account I'd have to compile ghc myself, which was annoying.
15:31:01 <lispy> Cale: ah, I wonder how hard it is to get tha working?
15:31:03 <Cale> (or at least install a ghc binary into my user account... I forget if that worked)
15:32:15 <Cale> But really if you want to know about why we have mueval, ask gwern. He's the one who submitted those patches.
15:37:29 <Saizan> but shouldn't hs-plugins be subsumed by the ghc-api eventually?
15:38:09 <lispy> Saizan: I'm not sure.  My understanding is that currently the have a lot of overlap, but are pretty different
15:38:23 <dons> no one's using ghc-api for object loading, afaik.
15:38:32 <dons> though that was the original idea.
15:40:37 <Phyx-> how do you actually make a new Map?
15:40:49 <sm> Data.Map.fromList I think
15:41:11 <Phyx-> i thought bout that, thought there was another way, but ok, i'll do that
15:41:11 <chrisdone> âemptyâ also works
15:41:16 <lispy> ?hoogle a -> Data.Map
15:41:17 <Phyx-> ah ok
15:41:17 <lambdabot> Parse error:
15:41:17 <lambdabot>   --count=20 "a -> Data.Map"
15:41:17 <lambdabot>                       ^
15:41:22 <sm> oh nice
15:41:36 <lispy> ?hoogle a -> Map
15:41:37 <lambdabot> Did you mean: a -> Map a a /count=20
15:41:37 <lambdabot> Prelude id :: a -> a
15:41:37 <lambdabot> Data.Function id :: a -> a
15:41:45 <Phyx-> read over that one
15:41:47 <Phyx-> heeheh
15:41:50 <lispy> I see that hoogle is borked :(
15:41:55 <chrisdone> :t Data.Map.empty
15:41:56 <lambdabot> forall k a. M.Map k a
15:42:05 <rwbarton> @hoogle k -> a -> Map k a
15:42:06 <lambdabot> Data.Map singleton :: k -> a -> Map k a
15:42:06 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
15:42:06 <lambdabot> Data.Map insertWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> Map k a
15:42:13 <rwbarton> @hoogle Map k a
15:42:14 <lambdabot> Did you mean: :: Map k a /count=20
15:42:14 <lambdabot> Data.IntMap mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
15:42:14 <lambdabot> Data.Map mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
15:42:21 <rwbarton> Weird
15:42:41 <Phyx-> *crosses fingers and prays to the haskell gods that it'll compile*
15:42:43 <chrisdone> sounds like a hoogle update
15:42:57 <chrisdone> Phyx-: Dijkstra would not have liked this
15:43:20 <mauke> dijkstra cat is not amused
15:43:29 <Phyx-> chrisdone: hey, what ever gets the job done
15:43:30 <twxfn> http://i37.tinypic.com/29m23k5.jpg
15:43:31 <Phyx-> :P
15:43:43 <Phyx-> hmmm it actually compiled
15:43:45 <Phyx-> go figure
15:43:48 <twxfn> dijkstra cat is never amused
15:43:50 <lispy> Cheeze burger considered harmful?
15:43:51 <twxfn> only efficient!!!
15:43:53 <Phyx-> now will it run....
15:44:31 * twxfn throws up, leaves
15:44:34 <chrisdone> I think I just stepped into Î»chan
15:44:59 <mauke> /Î»/
15:45:02 <Phyx-> *cries in a corner*
15:45:32 <Phyx-> *** Exception: Prelude.(!!): index too large <-- oddly anti-climactic
15:46:25 <vixey> Haskell can't do numbers bigger than 2^32
15:46:26 <chrisdone> that's what she said
15:46:41 <mauke> http://dis.4chan.org/read/prog/1223866277/
15:46:42 <lambdabot> Title: 4chan BBS - What is wrong with our country
15:46:44 <dolio> > maxBound :: Int
15:46:45 <lambdabot>   9223372036854775807
15:46:46 <lispy> vixey: that's not 100% true
15:46:59 <vixey> 9223372036854775807 = 2^32
15:47:00 <vixey> :)
15:47:10 <dolio> > 2^32
15:47:12 <lambdabot>   4294967296
15:47:12 <mauke> @check 9223372036854775807 == 2^32
15:47:13 <lambdabot>   "Falsifiable, after 0 tests:\n"
15:47:17 <vixey> roughly
15:47:26 <lispy> It's just that (!!) takes an Int insetad aof an Integer
15:47:34 <chrisdone> lispy: are you drunk?
15:48:00 <dolio> For Integer use, you have the much more convenient name of genericIndex.
15:48:02 <lispy> chrisdone: no, but thanks for checking :)
15:48:20 <chrisdone> mauke: Xarn is the only competent programmer on that board
15:48:30 <lispy> chrisdone: but why do you ask?
15:48:36 <vixey> genericHaskell
15:48:44 <mauke> chrisdone: what about The Sussman?
15:48:45 <chrisdone> lispy: noa raeson
15:48:53 <zloog> What IDE do most people use for haskell (emacs?)
15:49:01 <mauke> linux
15:49:02 <lispy> chrisdone: ah, yeah high latenccy connection means my typos go up
15:49:13 <Valodim> linux as an ide?
15:49:14 <Valodim> haha
15:49:18 <lispy> zloog: emacs and vim seem to the the 2
15:49:19 <chrisdone> mauke: well, besides Sussman, who Has Always Been There
15:49:44 <zloog> lispy: I figured that, but I'd really like some nice way to browse for definitions in emacs.
15:49:48 <lispy> zloog: but eclips hase a nice plugin, eclise-fp
15:49:57 <lispy> zloog: for that there is hasktags
15:50:07 <Pseudonym> Where is eclipse-fp, as a matter of curiosity?
15:50:09 <chrisdone> @check lispy == orbitz
15:50:10 <lambdabot>   Not in scope: `lispy'Not in scope: `orbitz'
15:50:16 <lispy> zloog: also, you can run hoogle on your code
15:50:25 <zloog> lispy: ty, &ty ill start googling those three
15:50:37 <Phyx-> i wish ghci exceptions came with a callstack...
15:50:39 <mauke> @google hoogle
15:50:40 <lispy> Pseudonym: google knows, I want to say sf.net
15:50:41 <lambdabot> http://www.haskell.org/hoogle/
15:50:41 <lambdabot> Title: Hoogle
15:50:53 <Phyx-> do they?
15:52:01 <vixey> Phyx-: Do you really think that would be easier than just writing working programs from the start?
15:52:09 <lispy> ?check \lispy orbitz -> lispy == orbitz
15:52:10 <chrisdone> mauke: use @go, optimised
15:52:10 <lambdabot>   "OK, passed 500 tests."
15:52:32 <mauke> ?check ?check
15:52:33 <lambdabot>       Unbound implicit parameter (?check::a)
15:52:33 <lambdabot>        arising from a use of `e_...
15:52:34 <chrisdone> lispy: I'm still not convinced
15:52:50 <Phyx-> vixey: well.. nobody's perfect :P we all make mistakes once in a while... and then a call stack is handy.. so i know where the exception is being thrown in :P
15:53:02 <lispy> Phyx-: there are solutions to your current dilema...this problem of head and (!!) are documented on the haskell wiki
15:53:30 <Phyx-> mkay, *goes to look*
15:54:40 <lispy> Phyx-: this is good in general: http://www.haskell.org/haskellwiki/Things_to_avoid
15:54:44 <lambdabot> Title: Haskell programming tips - HaskellWiki
15:57:47 <Phyx-> lispy: long list
15:57:48 <Phyx-> lol
15:58:08 <vixey> lol
15:58:12 <vixey> do what I do
15:58:19 <vixey> -XNoImplicitPrelude
15:58:22 <vixey> length = ....
15:58:24 <vixey> ...
15:58:34 <vixey> rewrite everything.. everytime you start a new program :/
15:58:54 <vininim_> let rnd = randoms (mkStdGen 5) :: [Double]; pairGen = \ (x1:x2:xs) -> Just ((x1,x2), xs); pairRnd = unfoldr pairGen rnd; tupleSum (a,b) (c,d) = (a+c,b+d);  mc a b = if ((fst a)^2 + (snd a)^2) <= 1.0 then (1 + fst b, 1 + snd b)  else (fst b, 1 + snd b);  result = foldr mc (0,0) (take 100000 pairRnd) in (fst result)/(snd result)*4
15:59:01 <vininim_> > let rnd = randoms (mkStdGen 5) :: [Double]; pairGen = \ (x1:x2:xs) -> Just ((x1,x2), xs); pairRnd = unfoldr pairGen rnd; tupleSum (a,b) (c,d) = (a+c,b+d);  mc a b = if ((fst a)^2 + (snd a)^2) <= 1.0 then (1 + fst b, 1 + snd b)  else (fst b, 1 + snd b);  result = foldr mc (0,0) (take 100000 pairRnd) in (fst result)/(snd result)*4
15:59:05 <pumpkin_> :o
15:59:06 <lambdabot>   3.14084
15:59:13 <vixey> > pi
15:59:14 <lambdabot>   3.141592653589793
15:59:16 <vininim_> =P
15:59:33 <Pseudonym> > iterate (\x -> x + sin x) 2.0 !! 10
15:59:34 <lambdabot>   3.141592653589793
15:59:45 <Pseudonym> So there.
15:59:46 <nicknull> http://www.datastructures.info/the-las-vegas-algorithmmethod/
15:59:48 <vininim_> notice how tupleSum is defined but not used
15:59:49 <Phyx-> hmm think i know where my program dies a cruel death
15:59:52 <lambdabot> Title: 20 The Las Vegas algorithm/method 1 4 at 1 e DataStructures 46
15:59:56 <pumpkin_> @src iterate
15:59:57 <lambdabot> iterate f x =  x : iterate f (f x)
16:00:00 <pumpkin_> ooh
16:00:07 <nicknull> anyone know that? there must be something wrong because that doesnt cover evry case in witness
16:00:45 <Pseudonym> @pl \x -> x + sin x
16:00:45 <lambdabot> ap (+) sin
16:00:45 <bos> dons: we need to do the haskell version of this. http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1/
16:00:53 <lambdabot> Title: A Million-user Comet Application with Mochiweb, Part 1 | Richard Jones, Esq., http://tinyurl.com/44akgv
16:01:03 <Pseudonym> > iterate (ap (+) sin) 2.0 !! 10
16:01:04 <lambdabot>   3.141592653589793
16:01:10 <pumpkin_> @src ap
16:01:10 <lambdabot> ap = liftM2 id
16:01:13 <pumpkin_> :o
16:01:39 <dons> bos, i thought we need to do a haskell version of this http://nitrogen-erlang.tumblr.com/
16:01:39 <lambdabot> Title: Nitrogen Web Framework
16:02:02 <roconnor> maxBound :: Word8
16:02:08 <dons> the mochiweb one looks like something the happs guys should do
16:02:15 <roconnor> > maxBound :: Word8
16:02:17 <lambdabot>   255
16:02:18 <lispy> Phyx-: bummer, IC and find the article I'm thinking of
16:02:29 <Pseudonym> The twitter clone written in Scala would be fun to try to replicate, too.
16:02:31 <Pseudonym> But to be honest...
16:02:33 <lispy> ?go haskellwiki debugging head exception location
16:02:37 <lambdabot> http://www.haskell.org/haskellwiki/GHC:FAQ
16:02:37 <lambdabot> Title: GHC/FAQ - HaskellWiki
16:02:46 <Pseudonym> We don't need a Haskell version of X.  We need something better than X.
16:02:57 <sm> I need to do scrape some web content for work, and I'd like to do it in haskell. Are there any html parsers out there, anything like http://www.crummy.com/software/BeautifulSoup/ ?
16:03:02 <lambdabot> Title: Beautiful Soup: We called him Tortoise because he taught us.
16:03:03 <dons> tagsoup
16:03:11 <bos> Pseudonym: true. but we can't hit 0.1% of X right now.
16:03:19 <vixey> > let lim f = f 0.0001 in   2 * lim (\dx -> sum (map (\x -> dx * sqrt (1 - x*x)) [-1,dx-1..1]))
16:03:20 <lispy> Phyx-: oh this: http://www.haskell.org/haskellwiki/GHC:FAQ#My_program_is_failing_with_head_.5B.5D.2C_or_an_array_bounds_error.2C_or_some_other_random_error.2C_and_I_have_no_idea_how_to_find_the_bug._Can_you_help.3F
16:03:21 <lambdabot>   3.1415914777444
16:03:24 <lambdabot> Title: GHC/FAQ - HaskellWiki, http://tinyurl.com/ywxcqq
16:03:24 <dons> sm, i use download-curl for scraping. does client side downloading and parsing
16:03:43 <vininim_> does ghci do tail-recursion optimization?
16:03:43 <lispy> Phyx-: Alternatively, compile your program with -prof -auto-all (make sure you have the profiling libraries installed), and run it with +RTS -xc -RTS to get a Â´stack traceÂ¡ at the point at which the exception was raised.
16:03:44 <sm> woah, I'll check that out, thanks dons
16:03:55 <Phyx-> lispy: cool, thanks :D
16:04:02 <dons> sm, if in doubt, always look on hackage.haskell.org first.
16:04:10 <vixey> vininim_: You can always make tail recursive functions operate in O(1) stack
16:04:25 <sm> true
16:04:41 <skorpan> :t only
16:04:42 <lambdabot> Not in scope: `only'
16:04:46 <skorpan> @src only
16:04:47 <lambdabot> Source not found. It can only be attributed to human error.
16:04:48 <sm> dons, any chance the package list could be made the default page ?
16:04:58 <dons> yes.
16:05:01 <vininim_> I believe my up to the point question would be why is it getting stack overflow with folding and take
16:05:02 <dons> actually, a search box
16:05:05 <dons> since the package list is too big
16:05:28 <nicknull> anyone know that? there must be something wrong because that doesnt cover evry case in witness
16:05:33 <bos> vininim_: probably because you're using a left fold?
16:05:34 <sm> that's unfortunate
16:05:35 <Tobsan> skorpan: lol
16:05:43 <sm> why too big ? too much bandwidth serving it ?
16:05:46 <nicknull> wait
16:05:51 <Pseudonym> @let zenoSequence f h = f h : zenoZequence f (h * 0.5)
16:05:52 <lambdabot>  <local>:2:25: Not in scope: `zenoZequence'
16:06:08 <vininim_> bos: it's my previous code snippet, foldr
16:06:13 <nicknull> http://www.datastructures.info/the-las-vegas-algorithmmethod/
16:06:14 <lambdabot> Title: 20 The Las Vegas algorithm/method 1 4 at 1 e DataStructures 46
16:06:18 <nicknull> anyone know that? there must be something wrong because that doesnt cover evry case in witness
16:06:20 <dons> sm, it just isn't useful to have an 800 element list thrown at you
16:06:21 <bos> vininim_: ah, didn't see it.
16:06:51 <sm> I think it's useful to see the page you want when you jump to hackage.haskell.org
16:07:03 <sm> every time I do, I have to click that link
16:07:12 <Pseudonym> @let accelerateZenoZequence seq p = let { p2 = 2^p; p21 = p2-1 } in zipWith (\rh rh2 -> ((p2 * rh2) - rh) / p21) seq (tail seq)
16:07:13 <lambdabot>  Defined.
16:07:16 <sm> that's all..
16:07:33 <dons> yeah, we're on it.
16:07:45 <sm> thanks
16:08:14 <Pseudonym> @let makeZenoTableau seq p q = let seqs seq order = seq : seqs (accelerateZenoSequence seq order) (order + q) in sequences seq p
16:08:16 <lambdabot>  <local>:3:59: Not in scope: `accelerateZenoSequence'
16:08:16 <lambdabot>  
16:08:16 <lambdabot>  <local>:3:108: Not i...
16:08:42 <vininim_> ZenoZequence
16:08:55 <Pseudonym> @let makeZenoTableau seq p q = let seqs seq order = seq : seqs (accelerateZenoZequence seq order) (order + q) in sequences seq p
16:08:56 <lambdabot>  <local>:3:108: Not in scope: `sequences'
16:09:07 <Pseudonym> @let makeZenoTableau seq p q = let seqs seq order = seq : seqs (accelerateZenoZequence seq order) (order + q) in seqs seq p
16:09:08 <lambdabot>  Defined.
16:09:25 <vixey> :t makeZenoTableau
16:09:27 <lambdabot> forall a b. (Fractional a, Integral b) => [a] -> b -> b -> [[a]]
16:09:27 * sm finds download-curl.. oh it's haskell, I see
16:09:33 <Pseudonym> @let richardsonSequence seq p q = map head $ makeZenoTableau seq p q
16:09:34 <lambdabot>  Defined.
16:09:36 <sm> lovely
16:09:37 <Pseudonym> Right.
16:09:41 <vixey> > makeZenoTableau [0,1,0,1,0,1] 3 7
16:09:42 <lambdabot>   [[0.0,1.0,0.0,1.0,0.0,1.0],[1.1428571428571428,-0.14285714285714285,1.14285...
16:10:28 <vininim_> > richardsonSequence [1,2,3] 4 5
16:10:29 <lambdabot>   [1.0,2.066666666666667,3.0686236138290934,* Exception: Prelude.head: empty ...
16:10:34 <nicknull> wow anyone look at true blood? just saw a short excerpt, looks very coll(tv-series)
16:10:38 <nicknull> cool
16:10:45 <vixey> what is this
16:10:57 <Japsu> sparta?
16:10:58 <vixey> > richardsonSequence [pi,pi,pi,pi] 1 1
16:10:59 <lambdabot>   [3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,* ...
16:11:15 <Mike> Hi, is there such a function to change Integer -> Int ?
16:11:23 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ]
16:11:23 <lambdabot>   <no location info>: parse error on input `;'
16:11:26 <vixey> :t fromIntegral :: Integer -> Int
16:11:27 <lambdabot> Integer -> Int
16:11:30 <vixey> yes
16:11:33 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ] in arctanSequence 0.01
16:11:33 <Peaker> @hoogle Integer -> Int
16:11:34 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
16:11:34 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
16:11:34 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
16:11:34 <lambdabot>   133.32999999999987
16:11:47 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ] * h in arctanSequence 0.01
16:11:48 <lambdabot>   1.3332999999999988
16:11:54 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ] * h in arctanSequence 0.001
16:11:55 <lambdabot>   1.3333329999999983
16:12:05 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ] * 2 * h in arctanSequence 0.001
16:12:07 <lambdabot>   2.6666659999999967
16:12:17 <Pseudonym> > let arctanSequence h = sum [ 1-x*x | x <- [-1,-1+h..1] ] * 2 * h in arctanSequence 0.00001
16:12:19 <lambdabot>   2.6666666666121324
16:12:23 <pumpkin_> :o
16:12:25 <Pseudonym> Hmm.
16:13:00 <Pseudonym> Aha.
16:13:15 <Pseudonym> > let arctanSequence h = sum [ sqrt (1-x*x) | x <- [-1,-1+h..1] ] * 2 * h in arctanSequence 0.00001
16:13:18 <lambdabot>   3.1415926165015526
16:13:21 <Pseudonym> Right.
16:14:02 <Pseudonym> @let arctanIntegral h = sum [ sqrt (1 - x*x) | x <- [0,h..1] * 4 * h
16:14:02 <lambdabot>   Parse error
16:14:15 <Pseudonym> @let arctanIntegral h = sum [ sqrt (1 - x*x) | x <- [0,h..1] ] * 4 * h
16:14:16 <lambdabot>  Defined.
16:14:24 <zloog> lispy: So you are saying that it is possible to run hoogle on my own code and be able to browse it via firefox?
16:14:26 <Pseudonym> > zenoSequence arctanIntegral 0.1
16:14:27 <lambdabot>   Not in scope: `zenoSequence'
16:15:32 <lispy> zloog: yes, that is possible, but I've never tried it.  I bet you could eliminate the FF requirement.  Doesn't it have a command line version?
16:15:32 <vixey> > zenoZequence arctanIntegral 0.1
16:15:33 <lambdabot>   Not in scope: `zenoZequence'
16:15:48 <Pseudonym> > zenoSequence arctanIntegral 0.1
16:15:49 <lambdabot>   Not in scope: `zenoSequence'
16:15:59 <Pseudonym> What happened to my zenoSequence?
16:16:20 <Pseudonym> @let zenoSequence f h = f h : zenoZequence f (h * 0.5)
16:16:21 <lambdabot>  <local>:6:25: Not in scope: `zenoZequence'
16:16:30 <Pseudonym> oH, DUH.
16:16:32 <vininim_> slow down guys, I was just failing at monte carlo one-liner example
16:16:46 <vininim_> pi is irrelevant
16:17:00 <zloog> lispy: FF would be easier on my eyes.
16:17:02 <Pseudonym> @let zenoSequence f h = f h : zenoSequence f (h * 0.5)
16:17:03 <lambdabot>  Defined.
16:17:08 <Pseudonym> > zenoSequence arctanIntegral 0.1
16:17:11 <lambdabot>   [3.304518332208783,NaN,NaN,3.1649498007548984,3.1535117069860483,NaN,NaN,3....
16:17:37 <Phyx-> hmm i was afraid of this
16:17:46 <Pseudonym> > zenoSequence arctanIntegral 0.5
16:17:49 <lambdabot>   [3.732050807568877,3.4957090681024408,3.339819144357173,3.2482530378277414,...
16:17:53 <Pseudonym> OK
16:17:57 <Pseudonym> > zenoSequence arctanIntegral 0.125
16:18:00 <lambdabot>   [3.339819144357173,3.2482530378277414,3.197602422877131,3.170546912779686,3...
16:18:31 <Phyx-> the ghci debugger is actually quite handy :)
16:18:45 <Pseudonym> > richardsonSequence (zenoSequence arctanIntegral 0.125) 2 2
16:18:49 <lambdabot>   [3.339819144357173,3.217731002317931,3.1782514100430825,3.159963292568572,3...
16:19:25 <Pseudonym> > zenoSequence arctanIntegral (1/256)
16:19:27 <lambdabot>   [3.14911808295723,3.1453974027196545,3.14350989153902,3.1425565279114425,3....
16:19:37 <Pseudonym> > richardsonSequence (zenoSequence arctanIntegral (1/256)) 2 2
16:19:39 <lambdabot>   [3.14911808295723,3.144157175973796,3.1427956241569204,3.1421864225193366,3...
16:20:06 <vininim_> > richardsonSequence (zenoSequence arctanIntegral 0.125) 2 1.8
16:20:07 <lambdabot>   Add a type signature
16:20:08 <Pseudonym> I guess it's not much faster for this example.
16:20:24 <Pseudonym> > richardsonSequence (zenoSequence arctanIntegral (1/256))4 4
16:20:27 <lambdabot>   [3.14911808295723,3.145149357370483,3.1433771347155655,3.1424892591104556,3...
16:22:06 <adityam> how to I generate an infinite list of random numbers between 0 and 1?
16:22:55 <Botje_> @hoogle randomrs
16:22:56 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
16:24:43 <Botje_> or just call randoms :)
16:24:59 <Botje_> > take 10 $ randoms (mkStdGen 42) :: [Float]
16:25:00 <lambdabot>   [0.110407025,0.8453985,0.3077821,0.78138804,0.5242582,0.5196911,0.20084688,...
16:26:29 <dancor> Array's are good for like deleting some column entirely right?
16:26:35 <adityam> Ah, thanks. I could not understand what should be g for randoms.
16:26:51 <adityam> is mkStdGen 42 equal to setting seed = 42 in C?
16:28:12 <Phyx-> wow.. what a stupid bug
16:28:14 <Saizan> similar
16:28:29 <Phyx-> can't beleive i missed that
16:28:50 <nicknull> anyone good with Network.HTTP ? isnt there a simple way to just do print $ openAndRead(url)
16:28:52 <nicknull> ?
16:29:11 <Pseudonym> https://eprints.kfupm.edu.sa/22313/1/22313.pdf <- This is a great paper, BTW.
16:29:18 <lambdabot> Title: Abstraction in Numerical Methods
16:29:26 <Pseudonym> Old, but great.
16:29:35 <Pseudonym> But they programs make more sense in Haskell.
16:29:55 <adityam> If I want an infinite list of pairs of random numbers, what do I do?
16:30:28 <adityam> > take 10 $ randoms (mkStdGen 42) :: [(Float, Float)]
16:30:29 <lambdabot>       No instance for (Random (Float, Float))
16:30:29 <lambdabot>        arising from a use of `r...
16:30:38 <dancor> maybe ixmap can be used to delete parts of the array
16:30:42 <Pseudonym> @let gatherPairs (x:y:xs) = (x,y) : gatherPairs xys
16:30:43 <lambdabot>  <local>:7:43: Not in scope: `xys'
16:30:49 <Pseudonym> @let gatherPairs (x:y:xs) = (x,y) : gatherPairs xs
16:30:50 <lambdabot>  Defined.
16:31:04 <Peaker> why is there no: instance (Random a, Random b) => Random (a, b) where ... ?
16:31:08 <Pseudonym> > gatherPairs [1..]
16:31:09 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
16:31:16 <EvilTerran> @hackage HTTP-Simple
16:31:16 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-Simple
16:31:24 <Pseudonym> Peaker: Submit a patch.
16:31:26 <EvilTerran> nicknull, grab that as well
16:32:20 <adityam> Pseudonym: Thanks
16:33:21 <dancor> hm maybe i'll just stick with a list of lists for now..
16:35:03 <Pseudonym> @let haltonSequence p x = let { p1 = 1.0 / fromIntegral p; h 0 = 0; h d x = let (q,r) = x `divMod` p in fromIntegral r * d + h q (d * p1) } in h x p1
16:35:04 <lambdabot>   arity mismatch for 'h'
16:35:14 <Pseudonym> @let haltonSequence p x = let { p1 = 1.0 / fromIntegral p; h 0 _ = 0; h d x = let (q,r) = x `divMod` p in fromIntegral r * d + h q (d * p1) } in h x p1
16:35:15 <lambdabot>  Defined.
16:35:33 <Pseudonym> > [ haltonSequence 2 i | i <- [20..] ]
16:35:34 <lambdabot>   Add a type signature
16:35:41 <dfrey|work> I have noticed that Data.Text.HaXml.SAX will parse a malformed XML document.  Is this expected?
16:35:42 <Pseudonym> > [ haltonSequence 2 i | i <- [20..] ] :: [Double]
16:35:43 <lambdabot>       No instance for (Integral Double)
16:35:43 <lambdabot>        arising from a use of `haltonS...
16:35:47 <dfrey|work> Details at http://hpaste.org/11210
16:35:51 <Pseudonym> @type haltonSequence
16:35:52 <lambdabot> forall b. (Fractional b, Integral b) => b -> b -> b
16:35:57 <Pseudonym> Aha.
16:36:00 * Pseudonym will fix later
16:37:34 <pumpkin_> @yhjulwwiefzojcbxybbruweejw
16:37:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:37:36 <pumpkin_> :o
16:37:51 <dfrey|work> The SAX parser in Python barfs because of the mismatched start and end tags, but the HaXml version doesn't complain.
16:37:55 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
16:37:56 <lambdabot> "\"#$%&'()*+,\""
16:37:56 <pumpkin_> @protontorpedo
16:37:56 <lambdabot> why haskell over say smalltalk
16:38:10 * pumpkin_ is confused
16:39:12 <EvilTerran> @vixen say hi to pumpkin_
16:39:13 <lambdabot> how're you?
16:40:31 <Pseudonym> @let revDigits p x = unfoldr (\x -> if x == 0 then Nothing else let (q,r) = x `divMod` p in Just (r,q)) x
16:40:31 <lambdabot>  Defined.
16:40:42 <Pseudonym> @let halton p x = let { p1 = 1.0 / fromIntegral p } in sum $ zipWith (*) (iterate (*p1) p1) (map fromIntegral (revDigits p x))
16:40:44 <lambdabot>  Defined.
16:42:42 <Phyx-> hey thanks lispy mauke and Cale , it works now :) and i learned a few new things in the process
16:42:45 <Phyx-> :)
16:46:05 <Pseudonym> > map (\ns -> 4.0 * fromIntegral (sum ns) / genericLength ns) .  tail . inits . map (\(x,y) -> if x*x + y*y > 1.0 then 0 else 1) . map (halton 2 &&& halton 3) $ [20..]
16:46:06 <lambdabot>   [4.0,4.0,4.0,3.0,3.2,3.3333333333333335,2.857142857142857,3.0,3.11111111111...
16:46:35 <Pseudonym> > map (\ns -> 4.0 * fromIntegral (sum ns) / genericLength ns) . drop 50 . inits . map (\(x,y) -> if x*x + y*y > 1.0 then 0 else 1) . map (halton 2 &&& halton 3) $ [20..]
16:46:36 <lambdabot>   [3.2,3.215686274509804,3.1538461538461537,3.169811320754717,3.1851851851851...
16:46:59 <Pseudonym> > richardsonSequence (map (\ns -> 4.0 * fromIntegral (sum ns) / genericLength ns) . drop 50 . inits . map (\(x,y) -> if x*x + y*y > 1.0 then 0 else 1) . map (halton 2 &&& halton 3) $ [20..]) 2 2
16:47:00 <lambdabot>   [3.2,3.220915032679739,3.127387296799061,3.1787286017992646,3.1915844311602...
16:47:09 <Pseudonym> Not much better, really.
16:47:38 <Pseudonym> OTOH, low-discrepancy sequences would make a good something-or-other for hackage, wouldn't they.
16:50:20 <Pseudonym> > map (halton 2 &&& halton 3) [20..]
16:50:22 <lambdabot>   [(0.15625,0.7407407407407407),(0.65625,0.18518518518518517),(0.40625,0.5185...
16:50:38 <Pseudonym> That's considered a pretty good cover of [0,1] x [0,1]
16:51:02 <Pseudonym> In general, you can replace 2 and 3 with any two primes.
16:52:24 <lispy> Phyx-: cool
16:53:34 <dons> oh wow, http://www.vimeo.com/1983774 haskelldb videos
16:53:34 <lambdabot> Title: HaskellDB Talk Trailer on Vimeo
16:53:35 <dons> freakin' awesome.
16:56:31 <Pseudonym> dons: By "freakin' awesome", I assume you mean "cheesy and funny".
16:56:47 <ddarius> Would have been better if they figured out something to put at the end
16:56:56 <dons> i like this idea of trailers for talks.
16:57:00 <dons> we need that at ICFP
16:57:42 <Peaker> Hey, I just realized the important difference between Functor and Applicative Functor is that Functors can only serially manipulate a contained value, but not combine multiple contained values into any single computation.. Applicative Functors just let you combine inputs from multiple containers into one computation.. Is this accurate?
16:58:22 <Peaker> I am asking because I can't see this explanation in the Wiki page about Applicative Functors... Only that they are "More than Functors, Less than Monads"
16:58:23 <ddarius> Peaker: Reasonably.
16:58:55 <ddarius> Applicative functors add an applicative layer over functors which themselves merely preserve categorical structure, i.e. compositions of functions.
16:59:42 <Peaker> ddarius: Yeah, but I think it could be informative to write something like: "When you'd use a Functor" and "When you'd use Applicative"
17:00:08 <EvilTerran> "applicative layer" meaning "layer giving you the apply the result of one action to the result of another, as an action"
17:00:28 <EvilTerran> which pretty much agrees with what you said
17:00:29 <s0832894> does anyone have time to help me with a small problem in my 1st year Uni homework?
17:00:34 <jsnx> EvilTerran: an action that you can run later?
17:00:50 <jsnx> s0832894: we certainly have time...
17:00:50 <EvilTerran> jsnx, well, no actions happen 'til you run them
17:01:06 <Pseudonym> s0832894: And the usual disclaimers about homework help apply.
17:01:10 <jsnx> EvilTerran: i'm not sure i understand your utterance then
17:01:17 <Pseudonym> But you already knew that, right?
17:01:27 <s0832894> errr
17:01:36 <jsnx> s0832894: we don't know the answer, in other words
17:01:37 <ddarius> "Applicative layer" as in an "applicative structure" but yes, that means about what you said.
17:01:43 <EvilTerran> jsnx, er, "the ability to apply"
17:01:57 <EvilTerran> ?type (<*>)
17:01:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:02:13 <jsnx> oh, interesting
17:02:22 <ddarius> "applicative structure" in the sense that the combinatory algebra is an applicative structure
17:02:32 <EvilTerran> applying the result of the action of type "f (a -> b)" to the result of the action of type "f a", as an action of type "f b"
17:02:35 <Pseudonym> s0832894: That means "go ahead and ask".
17:02:44 <s0832894> oh right cool
17:03:03 <Pseudonym> The disclaimers are that nobody will do your homework for you, but people are usually happy to help.
17:03:27 <Peaker> EvilTerran: I think they key thing in ap vs fmap is that two of its inputs are wrapped in "f" and not just one
17:03:32 <s0832894> ah yeah fair enough I'm just confused about how to construct something
17:03:46 <Pseudonym> Not a problem.  Ask away, and use hpaste if you need to.
17:03:47 <Pseudonym> !hpaste
17:04:06 <Pseudonym> Erm... hpaste.org
17:05:14 <s0832894> right well I have to basically write a function that will take a string such as "hAsKEll" and convert it to "Haskell" so the first letter is capitalized and the rest are lower case
17:05:22 <Peaker> @hoogle capitalize
17:05:23 <lambdabot> No results found
17:05:33 <Peaker> @hoogle String->String
17:05:33 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
17:05:33 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
17:05:33 <lambdabot> Distribution.Simple.Utils lowercase :: String -> String
17:05:38 <s0832894> ive been messing around with trying to seperate the head and the tail but i can't seem to get it
17:06:14 <Pseudonym> s0832894: RIght.  What have you got so far?
17:06:29 <Peaker> s0832894: capitalize [] = [] ; capitalize (x:xs) = toUpper x : lowercase xs
17:06:52 <Pseudonym> Peaker: What did I just say about not doing homework for someone?
17:07:07 <Peaker> Pseudonym: Its homework?
17:07:10 <Pseudonym> Quite apart from the fact that Distribution.Simple.Utils is likely to be off-limits.
17:07:12 <Pseudonym> Yes.
17:07:18 <Peaker> oh sorry
17:07:49 <s0832894> I've only managed to get the entire string to lower case adn the capitalize function i have already tried bu doesn't seem to be defined within Data.Char
17:08:10 <ddarius> What are educators' feelings about #haskell and Haskell-Cafe?
17:08:19 <Pseudonym> s0832894: Show us the code.
17:09:05 <Pseudonym> ddarius: Pretty much everyone who has been consulted agreed with http://www.haskell.org/haskellwiki/Homework_help
17:09:06 <lambdabot> Title: Homework help - HaskellWiki
17:09:17 <Pseudonym> Which should probably be updated to reflect the new beginners list.
17:09:46 <s0832894> don't worry it's not course credit just a practice excercise
17:10:09 <ddarius> Pseudonym: That's true.
17:10:13 <s0832894> I have to use list comprehension for this function as well
17:10:23 <Pseudonym> Oh, nice.
17:10:29 <Pseudonym> So show us your code so far.
17:10:44 <Pseudonym> If it's only 3 lines or so, you can paste it here.  Otherwise use hpaste.org
17:11:20 <s0832894> capitalized :: String -> String	
17:11:22 <s0832894> capitalized xs = [ toLower x | x <- xs ]
17:11:29 <jeffwheeler> Is it possible to install Happy on 6.8.3 without having it previously installed somehow?
17:11:42 <jeffwheeler> It always complains about the program Happy not already existing, but that's exactly what I'm trying to install.
17:11:55 <jeffwheeler> "The program happy is required but it could not be found"
17:12:25 <s0832894> i started with that and then every time i tried to experiment with apply different functions to the head and the tail for instance i would get errors on loading the .hs
17:13:19 <Pseudonym> So give an example of something you tried which gave an error, and show us what the error was.
17:13:36 <jeffwheeler> > let cap xs = map toLower xs in "aBc"
17:13:38 <lambdabot>   "aBc"
17:13:42 <Pseudonym> I'm not being obtuse about that, BTW.  Learning to read GHC's error messages is something you have to learn, and something you can help with.
17:13:42 <jeffwheeler> err . . .
17:13:47 <Pseudonym> Sorry, something we can help with.
17:13:48 <jeffwheeler> > let cap xs = map toLower xs in caps "aBc"
17:13:49 <lambdabot>   Not in scope: `caps'
17:13:54 <jeffwheeler> Gah.
17:13:57 <jeffwheeler> > let cap xs = map toLower xs in cap "aBc"
17:13:59 <lambdabot>   "abc"
17:14:11 <jeffwheeler> I didn't see the beginning of the question, though, so I could be missing something entirely.
17:14:21 <s0832894> right give me a sec and I'll get one
17:14:27 <Pseudonym> jeffwheeler: First off, it's homework.
17:16:36 * jeffwheeler wishes his homework was in Haskell. :P
17:16:55 <s0832894> ok heres one i tried. probably nonsense but I've just started on haskell
17:17:00 <s0832894> capitalized :: String -> String	
17:17:01 <s0832894> capitalized xs = head([ toUpper x | x <- xs ]) ++ tail ([ toLower | x <- xs])
17:17:16 <Pseudonym> Right.
17:17:18 <Pseudonym> OK.
17:17:23 <Pseudonym> Thing you need to know.
17:17:30 <Pseudonym> This is the type of head:
17:17:31 <Pseudonym> :t head
17:17:33 <lambdabot> forall a. [a] -> a
17:17:34 <Pseudonym> And tail:
17:17:36 <Pseudonym> :t tail
17:17:37 <lambdabot> forall a. [a] -> [a]
17:17:45 <jeffwheeler> s0832894: You probably come from a C-like language. Parentheses don't follow methods to include all arguments.
17:18:01 <Pseudonym> head doesn't return a list, it returns a single element.
17:18:03 <Pseudonym> tail returns a list
17:18:07 <Pseudonym> Makes sense?
17:18:09 <jeffwheeler> > head [1, 2, 3]
17:18:10 <lambdabot>   1
17:18:19 <mmorrow> > drop 1 [1,2,3]
17:18:20 <lambdabot>   [2,3]
17:18:25 <s0832894> right yeah i can see that
17:18:26 <jeffwheeler> > head ([1, 2, 3]) -- that's not necessary
17:18:27 <mmorrow> > take 1 [1,2,3]
17:18:28 <lambdabot>   1
17:18:28 <lambdabot>   [1]
17:19:02 <s0832894> should i be working with head and tail at all for this problem or am I way off course?
17:19:23 <EvilTerran> you don't need them
17:19:25 <Pseudonym> s0832894: You could.  It's not how a seasoned Haskell programmer would do it, but if it helps to think that way...
17:19:26 <jeffwheeler> s0832894: it overcomplicates it significantly, actually
17:20:06 <Pseudonym> The type error in that version is because ++ works on lists.
17:20:17 <Pseudonym> And head doesn't return a list, it returns an element.
17:20:23 <jeffwheeler> s0832894: What exactly is the function supposed to do, anyways? "aBCd" => "ABCD"?
17:20:44 <Pseudonym> You can attach an element to the front of a list using the : operator.
17:20:44 <s0832894> no aBCd => Abcd
17:20:49 <Pseudonym> > 'A' : "bcd"
17:20:50 <lambdabot>   "Abcd"
17:20:51 <dolio> Not having to use head/tail/null is a key selling point of Haskell.
17:20:53 <Pseudonym> Right?
17:21:05 <Pseudonym> dolio: I'm planning to proceed by refactoring.
17:21:11 <Pseudonym> FWIW
17:21:27 <dolio> At least, if you're Jon Harrop talking to Lispers.
17:21:36 <s0832894> right ok Ill just try something and get back to you lot in a minute
17:21:40 <Pseudonym> OK
17:21:45 <s0832894> thanks very much for the help btw
17:23:28 <dolio> Pseudonym: On an entirely unrelated note, did you at some point in the past post a comment to a blog about Ruby occupying a type-system sweet spot not hit by Common Lisp, and Java hitting a sweet spot for network-distributed software on 1995 hardware?
17:23:42 <Pseudonym> Yes.
17:23:47 <Pseudonym> A couple of days ago, IIRC.
17:23:59 <dolio> Huh. People here thought it didn't sound like you.
17:24:04 <Pseudonym> Really?
17:24:07 <sm> yow, showing the full text of download-curl's contents all the time in ghci is killing me (/emacs)
17:24:10 <Pseudonym> What didn't sound like me?
17:24:18 <sm> how to get ghci to not show, I wonder
17:24:25 <dolio> I don't know. You'll have to ask ddarius and quicksilver.
17:24:26 <Pseudonym> I thought the oblique slagging off at Java was very "me".
17:24:35 <shukhov> hmm I'm getting errors when I try to build zlib, anyone else have this problem?
17:25:04 <plutonas> i want to define a type T to be a list of some other type, like [OtherType]. I have given a line stating newtype T = Something (). How do i do this definition? i try data Something = MakeSomething [Othertype] but it doesn't seem to work, and i have the suspicion that i didn't understand the concept very good
17:25:05 <dons> sm, :set -fno-print-bind-result
17:25:06 <dons> i think
17:25:12 <sm> thanks!
17:26:10 <s0832894> Right been trying something of this sort of form:
17:26:12 <s0832894> capitalized :: String -> String	
17:26:14 <s0832894> capitalized xs = toUpper x : [ toLower | x <- xs ]
17:26:15 <s0832894> As i kinda expected though I am getting errors saying that x is out of scope (im guessing from the muddled way ive constructed the list comprehension in the tail)
17:26:17 <s0832894> Any pointers?
17:26:38 <Pseudonym> Thing 1: x isn't defined at the point where you use it.
17:26:46 <Pseudonym> Thing 2: toLower is missing its argument.
17:27:17 <s0832894> only missing the arguement where ive typed it there
17:27:18 <Pseudonym> Now.  Have you seen pattern matching?
17:27:48 <plutonas> hm, perhaps my question wasn't very clear?
17:28:12 <s0832894> could you give me an example of pattern matching?
17:28:28 <Pseudonym> @src tail
17:28:28 <lambdabot> tail (_:xs) = xs
17:28:28 <lambdabot> tail []     = undefined
17:28:32 <Pseudonym> There's an example.
17:28:34 <s0832894> yeah
17:28:39 <Pseudonym> Maybe not a good one because of the underscore.
17:28:56 <Pseudonym> So you know what this would mean:
17:29:01 <Pseudonym> capitalize (x:xs) = ...
17:29:25 <Adamant> 1741 messages. not bad.
17:29:38 <s0832894> can i use the (x:xs) in comprehension?
17:29:55 <Pseudonym> Yes, but it doesn't mean what you think it means.
17:30:03 <roconnor> you can use patterns in comprehensions
17:30:07 <Pseudonym> So "no".
17:30:09 <roconnor> @src mapMaybe
17:30:09 <lambdabot> Source not found. Where did you learn to type?
17:30:37 <chrisdone> why do cats like sleeping in boxes? http://chrisdone.com/blog/db/static/cizra-mlatu.png
17:30:50 <Pseudonym> > [ x*y | (x,y) <- [(1,2),(4,3)] ]
17:30:51 <lambdabot>   [2,12]
17:30:58 <Pseudonym> That's pattern matching in a comprehension.
17:31:13 <Pseudonym> chrisdone: To give Schroedinger a bigger sample size, obviously.
17:31:16 <s0832894> well guys thanks for the help but its like half one in the morning and  I just gonna call it a night and get help from my tutor tomorrow
17:31:30 <chrisdone> Pseudonym: wehey!
17:31:34 <Pseudonym> OK.  You're definitely on the right track, though.
17:31:59 <Pseudonym> http://icanhascheezburger.com/2008/04/09/schrodinger-improves-accuracy/
17:32:05 <lambdabot> Title: Schrodinger improves accuracy Â« Lolcats ânâ Funny Pictures of Cats - I Can  ..., http://tinyurl.com/5fv7fn
17:32:20 <sm> no joy with -fno-print-bind-result or -fno-print-bind-contents , bummer
17:32:23 <chrisdone> :3
17:32:25 <s0832894> so you recommend  going down the road of pattern matching in a comprehension?
17:32:42 <Pseudonym> s0832894: No.  But pattern matching in the left-hand side is a good plan.
17:32:43 <chrisdone> I thought it was just my cat!
17:32:51 <Pseudonym> No, all cats do that.
17:33:02 <Pseudonym> Mine does, too.
17:33:08 <Pseudonym> http://en.wikipedia.org/wiki/My_Cat_Likes_to_Hide_in_Boxes
17:33:09 <s0832894> right ok thanks
17:33:13 <s0832894> good night
17:33:25 <chrisdone> that cracks me up
17:33:38 <Pseudonym> Night.
17:35:13 <chrisdone> Pseudonym: well, you've been exceedingly helpful!
17:35:19 <chrisdone> #haskell: cats and a bit of programming
17:36:13 <sm> but do tags <- openAsTags url; return () works alright
17:36:37 <chrisdone> tag soup?
17:36:51 <Pseudonym> You know, I think there are a bigger proportion of "cat people" amongst Haskellers than "dog people".
17:36:56 <sm> this is download-curl, but I'm about to use tagsoup on it I think
17:37:03 <Pseudonym> This is something that deserves study, though.
17:37:04 * Dianora is a cat person
17:37:11 <shukhov> Can somebody help me build zlib, I'm getting these errors -> http://hpaste.org/11214 although I'm sure I have all the dependencies.
17:38:30 <chrisdone> Pseudonym: agreed. perhaps a poll ought to be posted to #haskell and haskell-cafe.
17:39:14 <nicknull> ima dogperson, cates are to clever
17:39:20 <chrisdone> is that haskell survey still around?
17:39:24 * chrisdone looks for haskell surveys
17:39:35 <nicknull> pets should be stupid and do what they are told.
17:39:39 <Dianora> I need to learn haskell yet. ;-)
17:39:46 <chrisdone> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
17:39:46 <nicknull> and guard the house
17:39:50 <lambdabot> Title: Haskell Users Survey
17:39:51 <chrisdone> ^ this one's a bit buggered
17:40:03 <Cthulhon> @pl (\ xs f i -> foldr f i xs )
17:40:03 <lambdabot> flip (flip . foldr)
17:40:17 <Pseudonym> Cats are like strong static type systems.  They'll be very happy to tell you when they don't accept what you want to do.
17:40:33 <wjt> Pseudonym: question is, what's the overlap between cat people and unicyclists?
17:41:02 <Pseudonym> wjt: Unicycling is just a computer science thing.
17:41:06 <chrisdone> unicyclers are safer than bicycles, like static typing
17:41:22 <chrisdone> s/r//
17:41:35 <Pseudonym> Every good computer scientist does one of three things: 1) Unicycle and/or juggle, 2) play Bridge, Chess and/or Go, or 3) is a vegetarian.
17:41:47 <dons> that is true.
17:42:00 <Pseudonym> Perhaps that's just true of Australia, mind.
17:42:01 * wjt must be a bad computer scientist
17:42:03 <dons> and if all else fails, 4) grows a beard.
17:42:09 <Peaker> come on, almost everyone can juggle (3), and many many play Chess.. that's too easy
17:42:30 <lament> i know very few people who can juggle
17:42:37 <Pseudonym> Me too.
17:42:37 <Dianora> Pseudonym: I preferred the yo-yo
17:42:39 * EvilTerran plays bridge and go
17:42:40 <lament> and not many who can play chess
17:42:41 <wjt> Peaker: there's a difference between playing chess and being a chess player
17:42:45 * Pseudonym plays bridge
17:42:51 <dons> Pseudonym: that's pretty much the breakdown at galois too, fwiw. jugglers, go-heads, bridge-heads, vegetarians, beardies.
17:42:51 * lament plays go
17:42:52 <Dianora> I used to play chess. not in a long time now.
17:42:55 <Pseudonym> Not chess, though.  Well, not in a long time.
17:42:57 <Dianora> I got bored with go
17:43:01 <dons> and most overlap
17:43:06 <Dianora> but I got bored with chess too
17:43:06 * EvilTerran isn't really a bridge player, though. i'm kinda still a go player, imo.
17:43:13 <Pseudonym> Famously, Ron Graham juggles.
17:43:14 * chrisdone writes programs to play games
17:43:14 <Dianora> so I got interested in "fairy chess"
17:43:22 <Dianora> if you know what that is
17:43:23 <Pseudonym> Oh, what's fairy chess?
17:43:24 <dons> we have militant cyclists though, rather than unicyclists.
17:43:31 <Dianora> Pseudonym: chess variants
17:43:40 <Pseudonym> The militant cyclists, though, often play bridge.
17:43:43 <Dianora> such as Chancellor chess, cylindrical chess
17:43:46 <Pseudonym> In my experience.
17:43:46 * cjb == go-playing vegetarian cyclist.
17:43:46 <chrisdone> peyton `simon` jones :: Cyclist
17:43:55 <Dianora> Casablanca suggested adding a new piece
17:44:06 <Dianora> combinating knight and rook I think it was
17:44:10 <Dianora> called the chancellor
17:44:11 <dons> cjb, you need to learn to juggle
17:44:14 <Pseudonym> Interesting.
17:44:17 <cjb> hm, cunning
17:44:19 <Dianora> it's a cool variant
17:44:26 <cjb> are any of the Go players here dan-level?
17:44:28 <Dianora> cylindrical chess you can play on a normal chessboard
17:44:41 <Dianora> basically, you wrap the right and left edges together
17:44:42 <cjb> (curious whether being a Haskell programmer conveys an advantage ;-)
17:44:45 <Dianora> and imagine it is a cylinder
17:45:09 * cjb has played toroidal go.
17:45:31 <Pseudonym> Famously, darcs was created to manage Dave's Bridge-playing code.
17:45:33 <Dianora> go is very complex, but I like my quarks pre-assembled.
17:45:37 <Dianora> If you get my drift.
17:46:02 * EvilTerran doesn't
17:46:23 <Dianora> quarks make up larger particles
17:46:29 <Dianora> like electrons etc.
17:46:39 <Dianora> I like the electrons and protons more than I like the quarks
17:46:57 <EvilTerran> ... ok.
17:47:24 <Plouj> hi
17:47:27 <Pseudonym> I think that one of the appeals of Go is that it's highly symmetric.
17:47:32 <Pseudonym> Unlike Chess.
17:47:32 <Plouj> in CPS, a continuation is a function, right?
17:47:48 <Pseudonym> The appeal of Bridge is that it's a complex communication protocol built on top of a simple channel.
17:48:08 <Pseudonym> Playing Bridge is an exercise in information theory.
17:48:33 <wchogg> Quarks don't make up electrons
17:48:39 <Plouj> I mean, is the continuation argument always supposed to be a function?
17:49:28 <Pseudonym> Plouj: IIRC, it's always an unevaluated thunk, but it needn't have any arguments.
17:49:32 <Pseudonym> A CAF is also acceptable.
17:49:44 <Pseudonym> In the limiting case.
17:49:55 <Plouj> Pseudonym: I don't know what a CAF is
17:50:02 <Pseudonym> Constant Applicative Form.
17:50:03 <nicknull> Peaker: can you give me an example of a control flow you created?
17:50:12 <Plouj> Pseudonym: and what the heck is that?
17:50:29 <Peaker> nicknull: I haven't created, the stdlib has: ContT implements continuations
17:50:32 <Plouj> Pseudonym: can you answer me in simple terms?
17:50:45 <Pseudonym> Well, think about "break" or "continue" in C-like languages.
17:51:01 <Pseudonym> These are control-flow operations, but they don't pass any data, like "return" does.
17:51:17 <Pseudonym> You could, in principle, model them with a continuation with no arguments.
17:51:32 <Peaker> nicknull: Actually I have implemented a few trivial ones... takeWhileM (runs an action in a loop until it fails to satisfy a condition) and the usual forever x = x >> forever x
17:51:56 <Plouj> Pseudonym: that's not really answering my question
17:51:57 <Pseudonym> In Scheme, you might use (lambda () (stuff))
17:52:09 <Pseudonym> I'm answering your first question first, if that's okay. :-)
17:52:30 <Pseudonym> shapr: Cat person and unicyclist.
17:52:40 <Pseudonym> Oh, and juggler.
17:52:44 <Plouj> I'm asking if I the 'continuation argument' in CPS programing always has to be a function or if it can also be just a simple variable
17:53:15 <shapr> I'm baack!
17:53:41 <Pseudonym> plouj: Right, and I'm trying to answer that. :-)
17:53:43 <zloog> Setup: array.hoo: copyFile: does not exist (No such file or directory) <-- Anyone know what might cause that (trying to install hoogle.)
17:53:59 <zloog> in response to "sudo runhaskell Setup install"
17:54:22 <shapr> Pseudonym: Anyway, why the sudden CV of me?
17:54:22 <Pseudonym> Basically, the answer is "yes".  There's a degenerate case where you don't need to pass any data.
17:54:39 <Pseudonym> shapr: We're trying to work out if there are more cat people in Haskell-land than dog people.
17:54:42 <Pseudonym> You're a data point.
17:54:46 <shapr> Yeah
17:54:55 * ddarius is a dog person.
17:55:02 <shapr> Has anyone done any Bentley-McIlroy compression in Haskell?
17:55:29 * twxfn likes  dogs too
17:55:44 <Pseudonym> shapr: Doug McIlroy is on haskell-cafe/
17:55:44 <twxfn> does anybody else think 9/11 was created by the bush administration
17:55:54 <shapr> twxfn: Dude, take it to #haskell-blah
17:56:04 <Plouj> Pseudonym: it looks like you're telling me that the continuation arg. can be a function that takes no arguments. I don't care how many arguments it takes. I care about the destinction between a function and a variable.
17:56:07 <Pseudonym> For the record, I think 9/11 was created by the Julian calendar.
17:56:09 <Plouj> Pseudonym: I don't care about passing no data!
17:56:16 <shapr> Pseudonym: ooh
17:56:21 * twxfn cringes
17:56:31 <shapr> @users
17:56:31 <lambdabot> Maximum users seen in #haskell: 518, currently: 470 (90.7%), active: 30 (6.4%)
17:56:35 <shapr> hmm
17:56:35 <ddarius> Freakin' Caesar
17:56:45 <Pseudonym> Plouj: In Haskell, a function with no arguments is a value.
17:56:49 <Plouj> Pseudonym: I'm wondering if the 'continuation argument' can be a variable, as in non-executable data
17:56:52 <Pseudonym> Thanks to lazy evaluation.
17:57:08 <Plouj> yeah, lets ignore Haskells confusion
17:57:33 <vininim_> then it would be kind of off-topic
17:57:34 <Plouj> ok
17:57:37 <Plouj> in other words
17:57:41 <Pseudonym> My point is that there are situations where you only care about the control flow.
17:57:47 <Plouj> can I say that every value/variable/data is a function?
17:57:54 <Pseudonym> If you think about the Maybe monad, for example.
17:58:14 <plutonas> i'm not sure how exactly to define the type here to not get an error, the function should be ok i think: http://pastebin.ca/1228928
17:58:28 <ushdf> today i learned that "monad" means "protuberance"
17:58:37 <dons> no.
17:59:09 <plutonas> ushdf: in greek at least monada means unit
17:59:19 <Pseudonym> The Maybe monad can be implemented with two continuations, one for the "Just" case and one for the "Nothing" case.
17:59:25 <Pseudonym> The "Nothing" case takes no arguments.
17:59:29 <ushdf> that's what my lit teacher said
17:59:34 <ushdf> i had never heard it outside of the context of haskell
18:00:47 <Pseudonym> But to answer your question, shapr, nobody's implemented vcdiff in Haskell yet AFAIK.
18:00:49 <plutonas> anybody looks at my paste? (i'm starting to wonder perhaps no one sees my messages here)
18:00:57 <shapr> Pseudonym: too bad..
18:00:57 <plutonas> though i'm registered
18:01:09 <dons> plutonas: hi
18:01:14 <plutonas> phew
18:01:21 <plutonas> at least my messages arrive :D
18:01:30 <Plouj> basically, I'm just gonna edit the YAHT book to say "This takes three arguments: a"
18:01:36 <Plouj> list of tokens and two ''continuation'' functions
18:01:42 <Plouj> oops
18:01:45 * shapr hugs plutonas 
18:02:13 <shapr> plutonas: talar du svenska ocksa?
18:02:15 <dons> yaya shapr!!
18:02:19 * shapr boings!
18:02:29 <plutonas> shapr: ja, but only en liten
18:02:36 <shapr> ah, okej :-)
18:02:45 <plutonas> min svenska ar inte bra, although i live here a year already
18:02:53 <plutonas> en ar
18:03:00 <shapr> Well, I live in Boston...
18:03:06 <plutonas> oh
18:03:16 <ushdf> eg heiti islenska
18:03:17 <plutonas> but i guess you're swedish?
18:03:18 <ushdf> :D
18:03:23 <shapr> plutonas: Nah, I'm from Alabama.
18:03:28 <dons> close!
18:03:38 <shapr> plutonas: I'm from the Swedish speaking part of Alabama.
18:03:41 <dons> :D
18:03:50 <plutonas> swedish speaking part of alabama? that must be a joke
18:03:54 <shapr> Yeah, it is :-)
18:03:56 * shapr laughs
18:03:59 <plutonas> i am very surprised that you learned swedish though
18:04:05 <shapr> I lived there for awhile..
18:04:05 <Pseudonym> shapr _is_ the Swedish-speaking part of Alabama.
18:04:09 * shapr laughs!
18:04:09 <plutonas> oh i see
18:04:12 <dons> shapr: there is no cabal, http://www.spreadshirt.com/us/US/There-is-no-Cabal/Products-64/Marketplace/Products/detail/article/3612542#
18:04:34 <shapr> ooh, nice!
18:04:50 <dons> the must have fall fashion item
18:04:52 <plutonas> did anyone look at my paste?
18:05:00 <shapr> plutonas: Anyway, did you get interested in Haskell because it's the language of Sweden?
18:05:18 <plutonas> shapr: i live in the haskell-speaking part of sweden
18:05:19 <plutonas> :P
18:05:29 <dons> :)
18:05:41 <plutonas> i was interested in lisp for 4 years, and because of that i selected the functional programming course now at uni
18:05:52 <plutonas> which is related to haskell
18:06:00 <EvilTerran> ah, and they steered you onto the path of light. good, good.
18:06:03 <shapr> plutonas: You live at Chalmers?
18:06:07 <plutonas> Lund
18:06:25 <shapr> Oh, I don't know about the Haskell goodness at Lund.
18:06:33 <plutonas> EvilTerran: i still prefer lisp, although i have a very good idea about haskell
18:06:46 <plutonas> the one i don't like is that types restrict me too much
18:07:01 <EvilTerran> they stop doing that after a while
18:07:05 <plutonas> it's very good for error checking, but sometimes (like now) it drives me crazy
18:07:15 <dolio> It's an illusion.
18:07:18 <plutonas> i want to return different types from the same function, on different occasions
18:07:22 <plutonas> this is no side-effect
18:07:24 <plutonas> anyway...
18:07:24 <shukhov> shapr: you wen't to chalmers?
18:07:37 <EvilTerran> it's like they claim that the parentheses stop making your eyes cross and head hurt after a while getting used to them
18:07:40 <shapr> shukhov: Nej, jag bodde i Boden och Stockholm.
18:07:46 <EvilTerran> in lisp
18:07:47 <EvilTerran> :P
18:07:54 <jsn> plutonas: you can think of it as wanting to return a union type
18:08:00 <shapr> plutonas: What about making a sum type? MyType = ReturnType1 | ReturnType2
18:08:04 <Plouj> can someone familiar with CPS edit the second paragraph after the second code block in this section  to clarify what each of the "it" refers to here http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Continuation_Passing_Style ?
18:08:07 <lambdabot> Title: Haskell/YAHT/Type basics - Wikibooks, collection of open-content textbooks, http://tinyurl.com/y8w64d
18:08:09 <shukhov> shapr: ah, Chalmers seems keen on haskell though
18:08:10 <shapr> er, union type...
18:08:19 <plutonas> jsn: is it about my paste or the discussion?
18:08:30 <shapr> shukhov: Yeah, lotsa Haskell goodness at Chalmers. I visited Chalmers for EuroHaskell!
18:08:32 <jsn> shapr: they are the same thing
18:08:33 <EvilTerran> shapr, are sum types and union types different?
18:08:44 <EvilTerran> ah. jsn++
18:08:46 <jsn> plutonas: did not see your paste
18:08:48 <plutonas> shapr: could be a solution, but it still restricts you
18:08:50 <shapr> Well, with one you add.. and with the other you...
18:08:51 <plutonas> jsn: ok
18:08:58 <shapr> plutonas: Restricts you how?
18:09:07 * shapr boings randomly
18:09:08 <jsn> plutonas: does it restrict you, or just require you to state your intentions?
18:09:22 <plutonas> you need to know beforehands what exactly is going to be returned
18:09:38 <shapr> umm.. yeah?
18:09:40 <plutonas> anyway, i'm not planning to start a language war :P i need your help anyway
18:09:43 <ddarius> There is a thing called a union type that is different from a sum type.  A -disjoint- union type is a sum type.
18:09:53 <jsn> ddarius: thank you
18:10:05 <jsn> and in truth, that is what you can make in haskell
18:10:08 <jsn> is a sum type
18:10:11 <EvilTerran> plutonas, you need to know little more beforehand in haskell than you do in a dynamically typed language
18:10:11 <rwbarton> Union types are icky.
18:10:23 <EvilTerran> plutonas, it's just haskell makes sure you really do know :)
18:10:32 <plutonas> EvilTerran: thats true
18:10:41 <jsn> plutonas: your question/problem?
18:10:50 <plutonas> but when you get errors and don't understand why.... it nerves you
18:11:03 <plutonas> i'm not sure how exactly to define the type here to not get an error, the function should be ok i think: http://pastebin.ca/1228928
18:11:04 <EvilTerran> plutonas, better at compile-time than run-time, i say
18:11:06 <plutonas> jsn: ^^^
18:11:13 <plutonas> EvilTerran: i agree on that also
18:11:30 <ddarius> Plouj: Every instance of 'it' in that paragraph refers to 'parseFunction' as the leading sentence indicates.
18:12:05 * shapr boings!
18:12:09 * EvilTerran is reminded by ddarius of how he had the implicit variable described to him when he was learning perl
18:12:15 <EvilTerran> "spelt $_, pronounced 'it'"
18:12:29 <Plouj> ddarius: even the "it" here: "The first continuation (which is what parseIdentifier should do if it succeeds"?
18:12:32 <plutonas> my problem is that T should be defined as a list of another type, but have no idea how to do it
18:12:36 <plutonas> am stuck there since yesterday
18:12:50 <plutonas> and i'm not sure i understand what should be done
18:13:04 <EvilTerran> what is iter?
18:13:22 * twxfn throws up
18:13:24 <plutonas> iter :: Parser a -> String -> Maybe ([a], String)
18:13:31 * shapr throws down...
18:13:34 <shapr> the gauntlet!
18:13:36 <plutonas> iter iterates a function over some input as long as it succeds
18:13:43 <shapr> plutonas: yeah?
18:13:47 * Pseudonym throws an exception
18:13:50 <plutonas> shapr: ?
18:13:55 <ddarius> Plouj: Okay, in that case 'it' refers to 'parseIdentifier'
18:14:09 <Plouj> ddarius: and from then on I'm totally confused :p
18:14:36 <ddarius> There are no more uses of 'it' after that.
18:14:48 * ddarius picks up the guantlet.
18:15:20 <plutonas> shapr: what do you mean by yeah?
18:15:20 <Plouj> humm, ok
18:15:47 <Plouj> then who can explain to me how "The first continuation (which is what parseIdentifier should do if it succeeds) is" makes sense?
18:16:20 <Plouj> is it saying that the type of the first continuation should match the type of parseIdentifier?
18:16:21 <EvilTerran> "The first continuation is ..."
18:16:37 <EvilTerran> <insert whatever follows your quote here>
18:16:54 <Plouj> I thought the first continuation _is_ parseIdentifier, not what parseIdentifier should do
18:17:02 <EvilTerran> "parseIdentifier should follow the first continuation if it succeeds."
18:17:21 <EvilTerran> that's how i read that, anyway. i only have the bit you quoted to go by, though.
18:17:28 <Plouj> http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Continuation_Passing_Style
18:17:31 <lambdabot> http://tinyurl.com/y8w64d
18:18:18 <jsn> okay, i don't actually have the modules i need to make this compile
18:18:29 <jsn> plutonas: but, try making removing T
18:18:37 <jsn> plutonas: you'll see that it works
18:18:44 <EvilTerran> Plouj, my interpretation of it seems sensible to me in context
18:19:09 <shapr> plutonas: Oh, I got distracted.
18:19:13 <jsn> plutonas: so you want a type synonym, i think -- `type T = [something]`
18:20:09 <plutonas> you mean removing the line starting with newtype?
18:20:10 <jsn> if you want to actually make T a wrapper, then `data T = Program [something]`
18:20:21 <jsn> yes, just get rid of T to get a working program
18:20:41 <jsn> plutonas: but i don't think it will express your intent
18:20:45 <plutonas> if i get rid it's not working: Program.hs:8:15: Not in scope: type constructor or class `T'
18:20:46 <plutonas> Failed, modules loaded: Parser, Dictionary, Statement, Expr, CoreParser.
18:21:08 <jsn> oh, yeah
18:21:36 <nicknull> what is the compile for optimization? ghc -O2 filename.hs ?
18:21:52 <jsn> what does Statement.parse do?
18:22:01 <jsn> plutonas: what is its type?
18:22:03 <plutonas> jsn: and substituting this line with data T = Program [Statement.T] which is what i want, gives the same error
18:22:13 <jsn> ah, i see
18:22:19 <plutonas> jsn: parse :: (Parse a) => String -> Maybe (a, String)
18:22:32 <jsn> but Statement.parse ?
18:22:45 <plutonas> jsn: yes that's Statement.parse
18:22:49 <jsn> returns `Statement.T`s right?
18:22:53 <jsn> oh, it doesn't
18:23:05 <plutonas> no, Statement.T is type Statement
18:23:20 <plutonas> it's a bit complicated perhaps thats why i'm confused
18:24:22 <jsn> let me try to describe your parse instance in words to you
18:24:38 <plutonas> jsn: that would be helpful :)
18:24:57 <jsn> plutonas: the Parse instance for T uses the Statement.parse parse to parse out a list of statements, which makes the program
18:25:50 <plutonas> jsn: exactly that's what i want to do
18:26:06 <plutonas> get a String, and use Statement.parse on it as long as it succeds
18:26:14 <plutonas> to construct a list of Statements
18:27:54 <jsn> plutonas: i need to get on a train
18:27:55 <jsn> http://hpaste.org/11215
18:28:01 <jsn> that's what i have so far
18:28:08 <jsn> oh wait, oops
18:28:20 <shapr> @users
18:28:20 <lambdabot> Maximum users seen in #haskell: 518, currently: 473 (91.3%), active: 20 (4.2%)
18:28:40 <plutonas> jsn: thanks a lot
18:29:03 <plutonas> i'm not sure what the problem is, but will get it
18:29:10 <jsn> http://hpaste.org/11215#a1
18:29:14 <jsn> here
18:29:37 <jsn> i am still unclear on how `iter` knows to stop -- but if it does, this should be it...
18:29:48 <Peaker> @type iter
18:29:49 <lambdabot> Not in scope: `iter'
18:29:51 <plutonas> it knows, when parse returns Nothing it stops
18:29:57 <shapr> hi Peaker
18:30:02 <Peaker> hi shapr
18:30:04 <plutonas> thanks jsn
18:31:07 <roconnor> @where hayoo
18:31:07 <lambdabot> I know nothing about hayoo.
18:31:15 <roconnor> @where+ hayoo http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:31:15 <lambdabot> I will remember.
18:31:18 <roconnor> @where hayoo
18:31:19 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:31:26 <Plouj> what type is (g t) in cfold f z l = cfold' (\x t g -> f x (g t)) z l
18:31:46 <Plouj> or, what does g get "instantiated" to in that code?
18:32:16 <Plouj> it looks like g is a function, but I don't see anywhere that specifies what it does
18:32:22 <Plouj> again, this is about http://en.wikibooks.org/wiki/Haskell/YAHT/Type_basics#Continuation_Passing_Style
18:32:24 <lambdabot> http://tinyurl.com/y8w64d
18:32:47 <rwbarton> :t   cfold' (\x t g -> ?f x (g t)) ?z ?l
18:32:48 <lambdabot> Not in scope: `cfold''
18:33:17 <Plouj> get the cfold' from link too
18:33:21 <rwbarton> Oh oops
18:34:04 <rwbarton> import Prelude hiding (return, fail)  <-- scary
18:35:32 <Plouj> aah, the second line of cfold' implicitly specifies the type of g and what it does...
18:35:46 <Plouj> that's so circular and confusing....
18:37:19 <EvilTerran> rwbarton, that could work interestingly with -XNoImplicitPrelude
18:37:38 <rwbarton> EvilTerran: yeah, but wouldn't you also want to hide >>=?
18:38:52 <EvilTerran> not necessarily; just hiding fail and "class Monad m => MonadFail m where fail :: String -> m a" would suffice to get a MonadFail constraint on do-blocks with refutable patterns to the left of <-s
18:40:03 <EvilTerran> the current ghc de-sugaring is completely Report compliant, iirc, and happens before typechecking
18:40:12 <rwbarton> ah
18:40:17 <EvilTerran> so you can do a fair bit of clever stuff like that
18:40:40 <EvilTerran> you can even make do-blocks with no <-s at all have an Applicative constraint instead of Monad
18:41:06 <EvilTerran> by hiding (>>) and (>>) = (Control.Applicative.*>)
18:43:01 <EvilTerran> ?type ((>>), (*>))
18:43:03 <lambdabot> forall (m :: * -> *) a b (f :: * -> *) a1 b1. (Applicative f, Monad m) => (m a -> m b -> m b, f a1 -> f b1 -> f b1)
18:43:21 <sm> http://searchpath.org is awesome
18:43:22 <lambdabot> Title: SearchPath â Automatic import chasing across the Internet for Haskell modules
18:43:29 <sm> for auto-building
18:43:52 <EvilTerran> can we get rid of those foralls in lambdabot's ?type ?
18:44:28 <EvilTerran> move them to a ?rankntpe or sometihng
18:44:36 <EvilTerran> er, ?rankntype
18:45:19 <EvilTerran> that one would've almost seemed legible without the visual assault that is kind annotations before it
18:46:12 <EvilTerran> , 1
18:46:14 <lunabot>  1
18:46:47 <EvilTerran> ... i forget if/how you get the types of things out of lunabot
18:47:04 <EvilTerran> , typeOf 1
18:47:06 <lunabot>  Integer
18:47:44 <EvilTerran> , typeOf id {- ah, but does it work for polymorphic values? #-}
18:47:46 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
18:47:57 <EvilTerran> oh well
18:48:01 * EvilTerran goes to bed
18:58:48 <shemale_fun> well i have started learning haskell
19:02:03 <shemale_fun> and happs is on the horizon with itnernet riches as the goal
19:02:06 <shemale_fun> YEAH
19:09:27 <shemale_fun> wow kinda quiet in here
19:09:35 <shemale_fun> is everyone building a haskell dns server?
19:09:49 <nicknull> no, solving the P vs NP problem
19:09:52 * dancor is waiting for next release of reactive
19:09:56 <shemale_fun> has world of warcraft released a linux client?
19:10:02 <nicknull> no, solving the P vs NP problem
19:10:10 <shemale_fun> wzat?
19:10:13 <nicknull> no, solving the P vs NP problem
19:10:28 <lament> ?
19:10:35 <shemale_fun> what is that?
19:10:39 <shemale_fun> p vs np
19:10:49 <lament> player vs non-player
19:10:53 <dancor> shemale_fun: http://en.wikipedia.org/wiki/P_vs_NP
19:11:54 <schme> mornin' ladies
19:12:23 <Pseudonym> It's afternoon, you insensitive clod.
19:12:32 <schme> Sorry :(
19:12:37 <Pseudonym> But greetings nonetheless.
19:12:48 <schme> Or aloha, as one says :)
19:13:53 <plutonas> how do i go from Just value to value?
19:14:01 <schme> Hey plutonas !
19:14:07 <Pseudonym> unsafePerformMaybe
19:14:11 <Pseudonym> Just kidding.
19:14:17 <plutonas> schme: not sleeping? :P
19:14:18 <Pseudonym> @hoogle Maybe a -> a
19:14:19 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
19:14:19 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
19:14:19 <lambdabot> Data.Monoid First :: Maybe a -> First a
19:14:19 <plutonas> how are you?
19:14:23 <schme> plutonas: What, I just got up!
19:14:36 <plutonas> oh
19:14:46 <schme> plutonas: I am great. Last couple of days.. less than great.  How's stuff up north?
19:17:22 <plutonas> good good
19:17:28 <schme> Horray :)
19:17:39 <plutonas> anyway schme, am going to bed, have to wake up at 9
19:17:49 <plutonas> am doing haskell assignments the whole night :P
19:17:50 <schme> Heh :)
19:17:58 <plutonas> so goodnight!
19:18:00 <schme> Sleep tight.
19:18:18 <schme> That's less than 5 hrs! Don't get all wired up about the lack of sleep you will be getting.
19:18:50 <plutonas> well tomorrow midnight is the deadline, i'll sleep then
19:18:56 <schme> haha.
19:19:06 <schme> Solid plan.
19:20:11 <sm> darnit. how do I convert a Map to a list of lists of like-keyed values ?
19:20:26 <sm> or even extract all values with a certain key ?
19:20:59 <sm> the api doc is making me dizzy
19:20:59 <rwbarton> There's at most one value with a given key... so M.lookup
19:21:13 <rwbarton> or M.toList
19:21:13 <sm> er
19:21:21 <sm> hmm. right.
19:21:34 <sm> abort!
19:21:48 <sm> I'll start over, thank you rwbarton
19:22:52 <nicknull> Just . either . maybe $ afternoon
19:23:18 <nicknull> @eval Just . either . maybe $ afternoon
19:23:28 <nicknull> @seen lambdabot
19:23:29 <lambdabot> Yes, I'm here. I'm in ##freebsd, ##hrg, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.
19:23:29 <lambdabot> it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #
19:23:29 <lambdabot> gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
19:23:36 <nicknull> whoops sorry
19:24:00 <Dianora> heh that's ok
19:25:54 <Adamant> no #haskell-haskell, I see
19:26:08 <vininim_> hac07?
19:26:08 <Dianora> That would be recursive.
19:26:24 <shemale_fun> uh
19:26:36 <shemale_fun> I guess if i get to a bti in the tutorial I dont get I skip it eh
19:26:49 <shemale_fun> http://haskell.org/haskellwiki/Learn_Haskell_in_10_minutes part 7 here?
19:27:28 <vininim_> I wonder why lambdabot is alone in a channel
19:28:00 <mmorrow> @tell EvilTerran , src ''id  {- :) -}
19:28:00 <lambdabot> Consider it noted.
19:28:16 <mmorrow> , src ''id
19:28:17 <lunabot>  luna: Not in scope: type variable `id'
19:28:18 <mmorrow> oops
19:28:24 <mmorrow> @tell EvilTerran , src 'id  {- ;) -}
19:28:25 <lambdabot> Consider it noted.
19:28:29 <mmorrow> , src 'id
19:28:39 <lunabot>  id :: forall a . a -> a
19:29:08 <rwbarton> , src 'gfoldl
19:29:15 <lunabot>  Killed.
19:29:29 <mmorrow> class ops i haven't got around to formatting nicely yet :(
19:29:35 <mmorrow> , src 'gfoldl
19:29:41 <lunabot>  Class op from Data: gfoldl :: forall a . Data a => forall c . (forall d b...
19:29:41 <lunabot>                                                                           ...
19:29:41 <lunabot>                                                                           ...
19:29:46 <mmorrow> ug
19:30:15 <mmorrow> , src ''Data
19:30:21 <lunabot>  class (Typeable a) => Data a where
19:30:21 <lunabot>          gfoldl ::
19:30:21 <lunabot>                 forall c .
19:30:41 <mmorrow> haha
19:37:13 <sbahra> Hi Dianora
19:37:19 <sbahra> Dianora, so you decided to check out haskell? :-P
19:37:21 <Dianora> hi sbahra
19:37:39 <Dianora> someone convinced me even if I don't know the language yet, I should sit here.
19:37:57 <Dianora> haskell has been on my to do list for a while now
19:38:14 <sbahra> nod
19:38:18 <sbahra> It's nice.
19:41:18 * twxfn coughs
19:45:18 <roconnor> :type showHex
19:45:29 <roconnor> @type showHex
19:45:30 <lambdabot> forall a. (Integral a) => a -> String -> String
19:47:47 <mm_freak> say i have a list and i want to index it, while giving status messages as to the progress of the indexing, what's the way to go?  should i use foldM or should i use some monad transformer?
19:48:24 <mm_freak> Dianora: haskell is a bit more difficult to learn than other languages, but it certainly pays off
19:54:12 <roconnor> > 0xFF
19:54:14 <lambdabot>   255
19:55:42 <newsham> > 0x1badd00d
19:55:43 <lambdabot>   464375821
19:56:02 <Cthulhon> > 0xdeadbeef
19:56:04 <lambdabot>   3735928559
19:56:11 <Adamant> > 0xCAFEBABE
19:56:12 <lambdabot>   3405691582
19:57:31 <mm_freak> > 0xdeadaffedeadaffe
19:57:32 <lambdabot>   16045674556583423998
19:57:38 <newsham> > 0xdeadfedd
19:57:39 <lambdabot>   3735944925
19:57:46 <mm_freak> > 0xdeadbabe
19:57:47 <lambdabot>   3735927486
19:57:50 <heatsink> > 0xface
19:57:52 <lambdabot>   64206
19:57:54 <Cthulhon> > 0xdeadc0de
19:57:55 <lambdabot>   3735929054
19:58:00 <newsham> > 0xfade2black
19:58:01 <lambdabot>   Not in scope: `lack'
19:58:52 <mm_freak> > pi
19:58:53 <lambdabot>   3.141592653589793
19:59:08 <mm_freak> > (+) 0xfacepi
19:59:09 <lambdabot>   64209.14159265359
19:59:32 <mm_freak> > let sucker = undefined in const 0xdeadsucker
19:59:33 <lambdabot>   57005
20:02:17 <roconnor> > showHex 0x0f []
20:02:18 <lambdabot>   /tmp/998671215435636747:68:40: Not in scope: `showHex'
20:02:38 <roconnor> > Numeric.showHex 0x0f []
20:02:39 <lambdabot>   /tmp/4342211451360648719:68:40: Not in scope: `Numeric.showHex'
20:05:25 <mm_freak> > printf "%x" 0x0F
20:05:26 <lambdabot>   Add a type signature
20:05:30 <mm_freak> > printf "%x" 0x0F :: String
20:05:32 <lambdabot>   "f"
20:05:41 <mm_freak> > printf "0x%x" 0xdead :: String
20:05:43 <lambdabot>   "0xdead"
20:12:04 <roconnor> @type reads
20:12:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:12:08 <roconnor> @type read
20:12:09 <lambdabot> forall a. (Read a) => String -> a
20:32:10 <waynemokane> @type lift
20:32:11 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
20:34:23 <lispy> :t printf
20:34:24 <lambdabot> forall r. (PrintfType r) => String -> r
20:34:39 * lispy wonders if ByteString is an instance of PrintfType
20:37:32 <adu> lispy: ByteString is an instance of IsString, and GHC does some strange things with String/IsString...
20:38:10 <thoughtpolice> providing you have 6.8 :P
20:38:19 <adu> lispy: like it inserts 'fromString' in certain places....
20:39:21 <adu> lispy: so I'm sure you could do (printf "format" a b c) :: ByteString with no problem
20:39:46 <lispy> > printf "Blah!" :: ByteString
20:39:47 <lambdabot>       Not in scope: type constructor or class `ByteString'
20:39:56 <adu> well, if it was in scope :)
20:39:57 <lispy> Oh, I thought BS was in scope :(
20:40:10 <adu> > printf "Blah!" :: BS.ByteString
20:40:11 <lambdabot>       No instance for (PrintfType BSC.ByteString)
20:40:11 <lambdabot>        arising from a use o...
20:40:16 <adu> hmm
20:46:00 <pumpkin_> what is new@ ?
20:46:07 <pumpkin_> it's hard to search fro
20:46:11 <pumpkin_> for
20:46:38 <dons> mm?
20:46:41 <rwbarton> Sounds like LaTeX source code... @ isn't a letter in haskell
20:46:51 <pumpkin_> hmm
20:46:53 <dons> pumpkin_: '@' is a way of binding variables in patterns
20:46:58 <dons> as in ls@(x : xs)
20:47:01 <pumpkin_> ah maybe that's it
20:47:04 <pumpkin_> what
20:47:05 <dons> ls is the whole thing, x and xs are the components
20:47:11 <pumpkin_> aha!
20:47:13 <pumpkin_> thanks!
20:47:19 <pumpkin_> so it's just to save myself from having to reassemble it?
20:47:24 <dons> > let f a@(x:xs) = (a, x, xs) in f "foo"
20:47:25 <lambdabot>   ("foo",'f',"oo")
20:47:36 <dons> right
20:48:08 <dons> data structures are first class, so there's lots of support for taking 'em apart, joining them together, and generally getting funky
20:48:40 <adu> pumpkin_: its kinda like (f a = let (x:xs) = a in ...)
20:48:57 <rwbarton> Except the match can fail
20:49:14 <rwbarton> and is not lazy
20:49:16 <adu> so (f (x:xs) = let a = (x:xs) in ...)
20:49:57 <pumpkin_> I see
20:49:58 <adu> so (f !(x:xs) = let a = (x:xs) in ...)
20:49:59 <pumpkin_> thanks
20:50:35 <rwbarton> I think a ! there is irrelevant.
20:50:43 <rwbarton> I endorse your previous description :)
20:51:27 <adu> :)
20:53:43 <roconnor> @hoogle asType
20:53:43 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:53:52 <roconnor> @src asTypeOf
20:53:52 <lambdabot> asTypeOf = const
20:58:45 <lispy> > read "1" `asTypeOf` 10
20:58:46 <lambdabot>   1
20:59:19 <mm_freak> http://hpaste.org/11218 â could anyone help me with this?  it works fine, except that it eats a few hundred MiBs of memory when run
20:59:29 <McGyver> Do you enjoy Haskell just for fun or for Unveristy classes?
21:00:09 <dons> "you"?
21:00:10 <dons> ?users
21:00:11 <lambdabot> Maximum users seen in #haskell: 518, currently: 468 (90.3%), active: 12 (2.6%)
21:00:29 <dons> do we only get to choose between fun and university?
21:00:54 <adu> McGyver: for fun
21:01:12 <adu> McGyver: but also because it is the most powerful programming language on the planet
21:01:45 <heatsink> Its power level is over 9000!
21:01:46 <McGyver> You in this channel
21:02:11 <adu> McGyver: there are many reasons to enjoy Haskell
21:02:11 <lispy> Super Sayian Haskell!
21:02:14 <mm_freak> McGyver: i enjoy it for almost everything, where programming is involved
21:02:27 <adu> Haskell++
21:02:27 <dons> some of us have to do it for work.
21:02:30 <dons> life's tough
21:02:34 <mm_freak> but currently i have a big problem with it i can't resolve =/
21:02:50 <adu> mm_freak: i can help
21:02:58 <mm_freak> adu: then see above
21:02:59 <davidL> > let (~) = complement in ~0xff :: Word32
21:03:01 <lambdabot>   <no location info>: parse error on input `)'
21:03:05 <lispy> ?Can Haskell solve mm_freak's problem?
21:03:05 <lambdabot> Maybe you meant: faq map run wn
21:03:10 <lispy> ?faq Can Haskell solve mm_freak's problem?
21:03:10 <lambdabot> The answer is: Yes! Haskell can do that.
21:03:31 <davidL> > let (~) = complement in ~255 :: Word32
21:03:32 <lambdabot>   <no location info>: parse error on input `)'
21:03:38 <dons> ~255 eh?
21:03:44 <dons> that's a lazy pattern binding
21:03:51 <mm_freak> lispy: it does solve my problem, in factâ¦  but not the way i'd like it to =)
21:03:51 <dons> trying using unicode 'not'
21:03:58 <davidL> :(
21:04:43 <mm_freak> > let (\!) = complement in \! 255
21:04:44 <lambdabot>   <no location info>: parse error on input `\!'
21:05:02 <dons> ?let (Â¬) = not
21:05:04 <lambdabot>  Defined.
21:05:22 <dons> > (Â¬ True)
21:05:23 <lambdabot>   Couldn't match expected type `Bool -> t'
21:05:23 <mm_freak> > Â¬ True
21:05:24 <davidL> > Â¬True
21:05:25 <lambdabot>   <no location info>: parse error on input `Â¬'
21:05:25 <lambdabot>   <no location info>: parse error on input `Â¬'
21:05:37 <dons> heh
21:05:46 <heatsink> mm_freak: So, the first accumulator to f is a counter. What's the second for?
21:05:48 <davidL> :t (~)
21:05:49 <lambdabot> parse error on input `)'
21:05:52 <dons> http://hackage.haskell.org/packages/archive/unicode-prelude/0.1.1/doc/html/Prelude-Unicode.html#2
21:05:54 <lambdabot> Title: Prelude.Unicode, http://tinyurl.com/69ka35
21:06:05 <mm_freak> heatsink: it's the old value from the list, which is ignored to be replaced by the new one
21:06:35 <McGyver> dons: In what branch of business people work with Haskell? BTW: I worked with Haskell 10 years ago, in a university course.
21:06:50 <waynemokane> is StateT not an instance of MonadState ?
21:06:52 <lispy> McGyver: CS
21:07:09 <dons> a variety of things, http://haskell.org/haskellwiki/Haskell_in_industry
21:07:11 <lambdabot> Title: Haskell in industry - HaskellWiki
21:07:14 <lispy> ?instances MonadState
21:07:15 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
21:07:22 <lispy> waynemokane: ^^
21:07:22 <waynemokane> ack, nevermind  :)
21:07:45 <heatsink> mm_freak: The entire modSquares list sits in memory until computation is complete, I think that's your problem.
21:07:51 <davidL> dons: is Prelude.Unicode in lambdabot?
21:07:53 <Adamant> lispy: math and EE too
21:07:55 <adu> McGyver: haskell.org has a list of ppl using haskell in the industry, i suggest you take a look
21:08:05 <dons> davidL: don't think so.
21:08:13 <lispy> Adamant: my reply was meant to be snarky, that it's programmers who use it :)  But yes.
21:08:16 <Adamant> Galois and Bluespec
21:08:32 <Adamant> lispy: sorry, my snark-o-meter is busted
21:08:54 <dons> btw, looks like these guys are hiring, http://www.peerium.com/jobs.html
21:08:55 <lambdabot> Title: Peerium | Jobs
21:08:57 <heatsink> mm_freak: Wait, I misread it.  Let me check again.
21:09:06 <lispy> Adamant: I'll use a different encoding next time that supports snarky characters
21:09:08 <Adamant> lispy: and I keep almost typing my whole comments in ALL CAPS and then I catch myself and rewrite them
21:09:21 <Adamant> lispy: do they have a snarky bit to go with the evil bit?
21:09:49 <mm_freak> heatsink: consider the following:  if i remove the 'tell', then it works well
21:09:56 <lispy> dons: interesting
21:10:00 <mm_freak> i'm sure it's related to Writer
21:10:18 <lispy> mm_freak: link again please?
21:10:44 <mm_freak> lispy: http://hpaste.org/11218
21:10:56 <rwbarton> @src foldM
21:10:56 <lambdabot> foldM _ a []     = return a
21:10:56 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
21:11:11 <rwbarton> @src Writer >>=
21:11:11 <lambdabot> Source not found.
21:11:37 <mm_freak> i think it's related to the way the Writer's monoid is used in IO
21:12:16 <lispy> mm_freak: well, for one thing, could you use fast modular exponentiation?
21:12:20 <heatsink> @src [] (++)
21:12:20 <lambdabot> Source not found. Just try something else.
21:12:21 <mm_freak> seems like it's built completely before being evaluated
21:12:50 <mm_freak> lispy: i could, but that's not the pointâ¦  i'm trying to implement status messages
21:13:01 <lispy> mm_freak: Oh
21:13:33 <lispy> mm_freak: so every X operations you want to 'tell' and then display it?
21:14:00 <mm_freak> goal:  indexing a list while printing the indexing progressâ¦  i used to use foldM in IO, but i thought i could be more general than that, so i went to Writer
21:14:22 <mm_freak> i could run 'tell' less often, but that doesn't solve the problem
21:14:33 * lispy nods
21:15:10 <mm_freak> hold on, i just solved it =)
21:15:16 <rwbarton> mm_freak: try Writer.Lazy?
21:15:20 <rwbarton> mm_freak: ah too late :P
21:15:23 <heatsink> Writer is Writer.Lazy.
21:15:32 <mm_freak> just demand 'st' in statusMessages
21:15:39 <mm_freak> statusMessages (st:sts) = do
21:15:46 <mm_freak> statusMessages ((!st):sts) = do
21:16:21 <lispy> mm_freak: hmm..why does that solve it?
21:16:35 <mm_freak> wait, no, it didn't =/
21:16:35 <mm_freak> sorry
21:17:21 <lispy> mm_freak: what is it currently doing?  I'm lazy to download it
21:17:43 <mm_freak> rwbarton: btw, this is lazy Writer
21:18:04 <mm_freak> lispy: it just indexes the modSquares list and prints status messages regarding the indexing progress
21:18:32 <mm_freak> i.e. it does the same as (!!)
21:18:58 <lispy> mm_freak: I'm confused
21:19:10 <lispy> mm_freak: so I'm running it, and it gives me progress.  But you expected??
21:19:47 <lispy> Done.
21:19:50 <lispy> Value: 2
21:19:59 <mm_freak> look how it consumes memory
21:20:01 <adu> mm_freak: I think I've got it
21:20:19 <mm_freak> at least for me it takes hundreds of MiBs
21:20:48 <lispy> mm_freak: ah, but you think it should run in a small O(1) overhead.  Gotcha.
21:21:02 <mm_freak> yeah, in O(1) space and O(n) time
21:21:20 <heatsink> mm_freak: I can't figure out why it's doing that, but my solution would be to rewrite it as a loop with tail-call.
21:21:37 <mm_freak> heatsink: that's the foldM
21:22:08 <mm_freak> it's not related to statusMessages, so it's not related to IOâ¦  even if i don't do anything with the monoid, it takes a lot of memory
21:22:24 <mm_freak> if i don't use 'tell', then it runs in O(1) as expected
21:22:55 <mm_freak> maybe that's related to the nature of a Writer?
21:22:56 <heatsink> foldM f (x:xs) expands to f x >>= foldM f xs, and (>>=) forces evaluation of both its arguments before returning a result.
21:23:57 <mm_freak> heatsink: that doesn't make sense
21:23:59 <mm_freak> at least to me
21:24:09 <mm_freak> the second argument to (>>=) is a function
21:24:50 <mm_freak> and i know that the problem is not related to the foldM, because just skipping the 'tell' already solves the problem
21:25:42 <mm_freak> i thought that statusMessages is called concurrently with calculating the result, which seems to be the case, but the monoid is built entirely, and that's the problem
21:26:09 <lispy> mm_freak: oh, mappend is called right?
21:26:16 <heatsink> That's not conclusive.  It might be that skipping 'tell' removes a dependence between 'x' and 'msgs'.
21:26:17 <mm_freak> yeah
21:26:24 <lispy> mm_freak: and that's (++) which is strict in the first param?
21:26:35 <mm_freak> (++) is strict?
21:26:42 <lispy> ?src (++)
21:26:42 <lambdabot> []     ++ ys = ys
21:26:42 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:26:42 <lambdabot> -- OR
21:26:42 <lambdabot> xs ++ ys = foldr (:) ys xs
21:27:00 <lispy> mm_freak: see, it has to traverse the first param
21:27:19 <lispy> > [1..] ++ [-1]
21:27:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:27:21 <mm_freak> yeah, but it retains the WHNF behaviour, i thought
21:27:27 <lispy> wait, maybe I'm stupid
21:27:31 <dobblego> yes it does
21:27:40 <lispy> > [-1] ++ [1..]
21:27:42 <lambdabot>   [-1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
21:27:47 <dobblego> > head ([1, 2, undefined] ++ [4, 5, 6])
21:27:57 <lambdabot>   1
21:28:26 <dobblego> > [1, 2, undefined] ++ [4, 5, 6]
21:28:27 <lambdabot>   [1,2,* Exception: Prelude.undefined
21:28:29 <rwbarton> mm_freak: does the memory size grow throughout the process?
21:28:32 <lispy> Well, according to the profiler
21:28:32 <lispy> COST CENTRE                    MODULE               %time %alloc
21:28:32 <lispy> CAF                            Main                 100.0  100.0
21:28:35 <mm_freak> rwbarton: yes
21:29:36 <mm_freak> @src tell
21:29:36 <lambdabot> Source not found. My brain just exploded
21:29:41 <rwbarton> mm_freak: does it change if you remove the print x line?
21:29:53 * ddarius suspects that if you do a retainer profile (with some manually added SCCs) the problem will be obvious.
21:29:59 <heatsink> tell w = Writer ((), w)
21:29:59 <mm_freak> rwbarton: it doesn't even change, when i remove the call to statusMessages entirely
21:30:29 <lispy> to me it seems like this is a mappend problem
21:30:30 <rwbarton> did you try removing the print x though?
21:30:59 <lispy> rwbarton: i did, and it still grows
21:31:07 <rwbarton> Hmm.
21:31:14 <rwbarton> I bet it doesn't grow if you remove both of them :P
21:31:26 <mm_freak> rwbarton: i just tried, and (as expected) it didn't help ;)
21:32:13 <mm_freak> it even grows when i remove the call to statusMessages completely in the main function, so that the monoid doesn't get used at all
21:32:41 <lispy> mm_freak: are you sure it's not using the monoid?
21:33:07 <lispy> ?hoogle execWriter
21:33:07 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
21:33:07 <lambdabot> Control.Monad.Writer.Strict execWriter :: Writer w a -> w
21:33:07 <lambdabot> Control.Monad.Writer.Lazy execWriterT :: Monad m => WriterT w m a -> m w
21:33:16 <lispy> ?hoogle runWriter
21:33:17 <lambdabot> Control.Monad.Writer.Lazy runWriter :: Writer w a -> (a, w)
21:33:17 <lambdabot> Control.Monad.Writer.Strict runWriter :: Writer w a -> (a, w)
21:33:17 <lambdabot> Control.Monad.Writer.Lazy runWriterT :: WriterT w m a -> m (a, w)
21:33:25 <lispy> :t evalWriter
21:33:26 <lambdabot> Not in scope: `evalWriter'
21:33:32 <lispy> What is the one to return just the a?
21:33:43 <lispy> ?hoogle Writer w a -> a
21:33:44 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
21:33:44 <lambdabot> Control.Monad.Writer.Strict execWriter :: Writer w a -> w
21:33:44 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
21:33:45 <heatsink> mm_freak: If you don't use the monoid, it will still construct a big lazy `mappend` thunk.
21:35:40 <mm_freak> is this a peculiarity of Writer or is it my fault?
21:35:40 <lispy> ?index unsafePerformIO
21:35:41 <lambdabot> System.IO.Unsafe, Foreign
21:35:53 <heatsink> mm_freak: Lazy writer will always do that.
21:36:39 <mm_freak> well, instead of a thunk, it seems to be an actual list, that gets constructed
21:36:41 <lispy> ?hoogle StrictWriter
21:36:41 <lambdabot> No results found
21:36:56 <mm_freak> lispy: Control.Monad.Writer.Strict.Writer
21:36:58 <heatsink> Hmm.  Actually, strict writer would probably also do that.
21:37:27 <mm_freak> strict Writer doesn't work at allâ¦  it constructs the monoid before returning it
21:37:50 <lispy> mm_freak: I think you have 2 choices given the way writer works.  1) a huge thunk that will construct a list when evaluated 2) a huge list
21:38:47 <mm_freak> hmm
21:39:02 <mm_freak> ok, i guess i'll stop to try to generalize it
21:39:32 <heatsink> I think I see what's happening.  While evaluating statusMessages, you're also creating a big thunk f (fst (runWriter (f (fst (runWriter (...))))))
21:39:32 <lispy> mm_freak: you just need a different monad I think
21:40:01 <adu> mm_freak: I got a 6% speed increase by switching Integer to Word
21:40:05 <mm_freak> heatsink: the problem is unrelated to statusMessagesâ¦  it appears even if i don't call it
21:40:06 <roconnor> > 0xff :: Double
21:40:08 <lambdabot>   255.0
21:40:25 <mm_freak> adu: ok, but that's not the point
21:40:32 <adu> mm_freak: what's the point?
21:40:45 <mm_freak> lispy: i could use cheap concurrency here
21:40:50 <lispy> adu: the memory usage should be low and O(1) here
21:41:03 <lispy> mm_freak: that's how darcs implements progress messages
21:41:12 <mm_freak> adu: see aboveâ¦  the point is not calculating the actual value, but printing status messages while calculating it
21:41:27 <adu> mm_freak: actually, a 1% speed increase from s/Integer/Word/
21:41:47 <adu> mm_freak: but a 6% increase from switching printf to shows
21:41:53 <adu> ShowS rather...
21:41:57 <mm_freak> lispy: but cheap concurrency is slow in this case, and i'd need to wrap indexing in IO
21:42:12 <lispy> mm_freak: I think, the problem inherint in your approach is that any way to "log" the updates, even lazily, either requires constructing all the thunks to log it, or the log itself, all in memory while you're doing stuff purely.
21:42:43 <rwbarton> mm_freak: are you compiling with optimizations?
21:42:43 <mm_freak> yeah, but that's a Writer issueâ¦  maybe State would help
21:42:50 <mm_freak> rwbarton: yes
21:42:58 <lispy> mm_freak: you could probably get some speed up by being strict in the list element creation?
21:43:01 <rwbarton> mm_freak: If you remove the statusMessages line, and compile without optimizations, do you get a stack overflow?
21:43:15 <lispy> mm_freak: how would state help?
21:43:17 <heatsink> mm_freak: You could write a function that creates a list-like data type, Status a = NotFinished Message | Finished a
21:43:22 <mm_freak> lispy: that is strict by the way the foldM evaluates the list
21:43:28 <adu> mm_freak: but ya, you should definitely use shows instead :)
21:43:51 <heatsink> um.  Status a = NotFinished Message (Status a) | Finished a
21:44:01 <lispy> mm_freak: you could use an iteratee, I think
21:44:15 <mm_freak> rwbarton: nope
21:44:30 <mm_freak> i'll try another approach, hold on
21:45:18 <adu> mm_freak: http://hpaste.org/11218#a2
21:45:26 <rwbarton> oh, that's probably because of the strictness annotation !k
21:45:33 <lispy> mm_freak: you could also use some sort of continuation based approach?  Every 100 status, you jump out, returning the message and then go back to processing
21:47:34 <lispy> making i strict in indexProgress gives a big improvement, but still not O(1) memory
21:50:22 <rwbarton> Wait no, I don't see how foldM in the Writer monad could ever not cause a stack overflow when compiled without optimizations.
21:51:40 <mm_freak> http://hpaste.org/11218#a3
21:51:46 <mm_freak> that works and achieves the same generalization
21:53:28 <mm_freak> although the Writer approach seemed more natural to me
21:53:32 <adu> mm_freak: but what about ShowS?
21:53:41 <mm_freak> adu: you're missing the problem
21:54:12 <adu> O(n)-ness?
21:54:47 <mm_freak> O(1)-ness in space, which i got nowâ¦  now i can start optimizing the linear factors =)
21:54:52 <adu> i'm well aware of O(n)-ness, but I can't think of any solutions to it, so I'm addressing the more general problem of speed
21:56:15 <mm_freak> your abandoning of printf only gives a linear speed increase, but doesn't help with the O(n) memory consumptionâ¦  since it should have O(1), this appears to be a much more important issue to me, so i resolved it first
21:56:53 <mm_freak> still, i'm not happy, because the Writer-based solution appeared natural to me
21:57:03 <mm_freak> maybe i just missed something simple
21:57:06 <lispy> mm_freak: are you sure it's O(1) memory? I'm up to 230Megs
21:57:12 <adu> i have no idea what Writer does
21:57:58 <mm_freak> lispy: it works well for me
21:58:16 <lispy> mm_freak: maybe I need to compile with -O something
21:58:44 <lispy> mm_freak: yes, that made it really fast
21:58:53 <mm_freak> lispy: make sure you're using the solution at the bottom of the page, since others have posted improvements earlier
21:59:01 <mm_freak> ah, ok =)
22:01:41 <lispy> :t showMsg
22:01:45 <lambdabot> Not in scope: `showMsg'
22:04:01 <lispy> oh
22:05:56 <mm_freak> adu: interestingly, printf is faster than ShowS for me
22:06:58 <rwbarton> Can someone explain to me why the code   foldM (\x y -> return x) 0 [1..10000000]  causes a stack overflow in the Identity monad but not the Writer Foo monad?
22:07:11 <mm_freak> what greatly speeded it up:  replacing (rem i 1000) by (i .&. 1023)
22:07:19 <rwbarton> (in ghci)
22:07:38 <mm_freak> rwbarton: try to be strict in the first argument of the fold function
22:07:53 <rwbarton> My question is about the code I wrote. :)
22:08:02 <mm_freak> (\x y -> x `seq` return x)
22:08:07 <mm_freak> and so is my answer =)
22:08:12 <rwbarton> No, it's not. :)
22:08:27 <rwbarton> I'm specifically interested in why it doesn't cause a stack overflow in Writer Foo.
22:08:47 <mm_freak> if my suggestion works then you know why
22:08:54 <rwbarton> huh?
22:08:59 <rwbarton> It "works" already in Writer Foo.
22:09:12 <mm_freak> Identity x >>= f = x `seq` f x
22:09:27 <lispy> rwbarton: writer is not as lazy then I'm guesing
22:10:04 <rwbarton> mm_freak: that's not what the source I'm looking at says.
22:10:20 <mm_freak> yeah, but it answers your question
22:10:30 <rwbarton> > return undefined >>= (\x -> return 2) :: Identity Integer
22:10:32 <lambdabot>       No instance for (Show (Identity Integer))
22:10:33 <lambdabot>        arising from a use of ...
22:10:37 <mm_freak> (hopefully at least)
22:10:37 <rwbarton> > runIdentity (return undefined >>= (\x -> return 2) :: Identity Integer)
22:10:39 <lambdabot>   2
22:10:56 <rwbarton> > runWriter (return undefined >>= (\x -> return 2) :: Writer String Integer)
22:10:57 <lambdabot>   (2,"")
22:11:14 <lispy> hmm
22:11:32 <mm_freak> retry it in GHC, because lambdabot's base library is a bit different
22:11:59 <rwbarton> good idea, but same result
22:13:15 <mm_freak> > runIdentity $ return undefined >>= const (return undefined) >>= const (return 2)
22:13:16 <lambdabot>   2
22:13:41 <mm_freak> maybe GHC is specially optimized for the base Writer monad
22:13:42 <lispy> mm_freak: I don't see how you'll make any progress without a solution that periodically dumps the accumulated status messages.
22:14:25 <lispy> mm_freak: you could use continuations and iteratees to make this elegant, but otherwise, I think it's a lost cause
22:14:58 <mm_freak> rwbarton: consider that pragmas are scattered all around GHC's base libraries
22:15:28 <sjanssen> what is the program we're trying to make faster? :)
22:15:49 <lispy> sjanssen: more memory efficient actually: http://hpaste.org/11218
22:15:52 <mm_freak> lispy: oh well, before dealing with continuations, i'd rather just use my monadic approach =)
22:16:22 <lispy> sjanssen: the idea is to give status messages during pure code, and then print them out in O(1) memory
22:17:09 <lispy> at least with writer, you're either building the thunks or the list of messages and that is going to take O(n) memory
22:17:22 <sjanssen> the original code is pretty silly
22:17:32 <rwbarton> If I take the Writer source code, and get rid of all the pairs replacing them with just the value, then the stack overflow appears
22:17:51 <lispy> sjanssen: I think it's suppose to illustrate a point, and the status messaging will be used in some real code
22:18:36 <rwbarton> And then it goes away if I replace "newtype" with "data".
22:19:30 <lispy> mm_freak: suppose you can make your own monad to solve this
22:19:35 <lispy> mm_freak: or you can use State
22:19:55 <lispy> mm_freak: how do you propose to avoid accumulating the status messages while you do the computation?
22:20:54 <rwbarton> Oh, this is kind of like the sum xs / length xs thing, isn't it
22:21:13 <rwbarton> Except not really, because not demanding half of the pair doesn't solve the problem...
22:21:33 <sjanssen> rwbarton: yes, it is similar
22:22:56 <mm_freak> lispy: i thought that i would build a list of status messages lazily so that the statusMessages function is the one to evaluate it
22:23:27 <lispy> mm_freak: unless I'm way off base, that still requires accumlating the thunks
22:23:37 <mm_freak> State doesn't seem to help here, btwâ¦  i had a little error in reasoning
22:23:40 <heatsink> This gets O(1) space, as well as running much faster.  http://hpaste.org/11218#a4
22:23:49 <heatsink> Agh
22:24:19 <heatsink> My window wasn't scrolling for the last few minutes.
22:25:16 <mm_freak> heatsink: hehe, and i don't see how yours is different from mine
22:25:25 <mm_freak> sjanssen: btw, why is the original code stupid?
22:25:32 <rwbarton> ... didn't you just change printf to putStr?
22:25:48 <rwbarton> Oh, and also Word to Integer
22:25:51 <rwbarton> er, vice versa
22:26:00 <lispy> This new one is not O(1) memory
22:26:42 <heatsink> Oh.  Emacs copy buffer /= KDE copy buffer.
22:26:46 <lispy> I even tried with -O2
22:27:06 <rwbarton> yeah, that can't have been what you meant to paste, it's the same as #2 :)
22:28:20 <heatsink> Okay, I pasted what I intended to now.
22:28:30 <lispy> mm_freak: if you have an evaluation order dependency between the result and the status messages, then doesn't the RTS have to build either the list of status OR the intermediate thunks to generate it?
22:28:56 * sjanssen likes heatsink's version
22:29:25 <mm_freak> lispy: yeah, and that was my original ideaâ¦  it just builds the monoid itself entirely
22:29:45 <sjanssen> could perhaps be made simpler (but less type safe) with [Either Double a]
22:30:33 <mm_freak> heatsink: i don't see a difference (besides having changed some linear speed factors)
22:30:44 <mm_freak> and it doesn't solve the O(n) memory problem
22:30:57 <lispy> mm_freak: it's the relationship between the intermidate states that he changed, I think
22:31:07 <lispy> mm_freak: it solved it here
22:31:10 <rwbarton> mm_freak: make sure you're looking at #a5
22:31:22 <mm_freak> oh, indeed, sorry
22:31:23 <heatsink> mm_freak: It's O(1) for me.
22:32:38 <pumpkin_> O(0) for me
22:32:58 <mm_freak> heatsink: yeah, i just looked at the wrong code
22:33:59 <snails> hi
22:34:10 <snails> im not sure if i want to learn prolog or haskel.
22:34:24 <snails> can haskel "crunch" predicate calculus?
22:34:28 <snails> or even set theory?
22:34:31 <ivanm> if you tell it how to :p
22:34:43 <snails> ok
22:34:47 <pumpkin_> how can I import Data.Map into ghci?
22:34:49 <lispy> In Haskell we do prolog in the type system ;)
22:34:56 <heatsink> pumpkin_, :m +Data.Map
22:34:57 <lispy> pumpkin_: :m + Data.Map
22:34:58 <ivanm> pumpkin_: :m +Data.Map
22:35:02 <pumpkin_> lol
22:35:02 <mm_freak> snails: you'll find that prolog code usually looks quite similar to haskell code, besides that you express the idea of "result" differently in prolog
22:35:07 <ivanm> lispy: you're outnumbered!
22:35:11 <lispy> ?quote fugue
22:35:12 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
22:35:23 <ivanm> fugues now, is it?
22:35:25 <adu> snails: if you want to learn somerhing really different, learn prolog, then when you want to combine it with more normal programming, then you can learn haskell, because haskell's type system is very similar to prolog in many ways...
22:35:25 <ivanm> not stereo?
22:36:16 <mm_freak> snails: generally you'll be happier learning haskell
22:37:21 <mm_freak> prolog is an interesting language, but not too useful in practice (i might get flamed for this statement though)
22:38:30 <adu> mm_freak: correction: not too useful in isolation, hence why combining it is so nice when combined with the rest of haskell :)
22:38:36 <sjanssen> http://hpaste.org/11218#a6 folds make everything better :)
22:39:49 <Cthulhon> What's a good online tutorial for Haskell that I can give to a non-coder friend of mine who has a good grasp on general logic?  Most of the tutorials seem to be focused on helping refugees from C/Java/etc.
22:40:00 <adu> snails: not that Haskell is in any way normal...
22:40:08 <heatsink> nice.  Symmetry demands an unfoldStatus too.
22:40:22 <mm_freak> well, i liked #a3 best
22:40:31 <mm_freak> http://hpaste.org/11218#a3
22:40:34 <sjanssen> Cthulhon: I've never personally used it, but Programming in Haskell might be okay
22:41:01 <sjanssen> #a3 involves an unnecessary Monad
22:41:51 <mm_freak> sjanssen: #a6, too, it just moved it elsewhere =)
22:41:54 <sjanssen> heatsink: yeah.  It's also hard to decide whether [Either s a] would be more convenient here
22:42:13 <ivanm> Cthulhon: not online, but maybe Haskell Road?
22:42:21 <sjanssen> mm_freak: I disagree.  You want to do IO, a Monad is required
22:42:58 <lispy> I tihnk the heatsink version is very nice too.
22:43:02 <Cthulhon> Hm.  It would really be better online, but a book might have to do.
22:43:04 <sjanssen> mm_freak: what is annoying is requiring indexProgress to be written in a monadic style when it really shouldn't be
22:43:30 <lament> Cthulhon: your nick sounds like you're planning to show up at LHC
22:43:45 <lispy> and sjanssen is right, you can use [Either s a] instead of Status s a
22:43:47 <mm_freak> sjanssen: either in monadic style or in some other combinator styleâ¦  in fact, it "should" be written just like (!!)
22:44:11 <Cthulhon> Large Hadron Collider?  I suppose if it tears a hole through dimensions...
22:44:15 <lament> "Cthulhons discovered, scientists devoured"
22:44:50 <heatsink> You scared him.
22:45:01 <lament> he will die last.
22:45:17 <lispy> although, I think I would have use data Status s a = NotFinish s | Finished a; and then passed around [Status s a]
22:45:40 <lispy> that way you decouple the list aspect from the Status
22:45:50 <lispy> But, this has a drawback
22:45:58 <lispy> Currently you can only have one Finished
22:46:01 <lispy> My way allows multiple
22:46:16 <sjanssen> @src Either
22:46:16 <lambdabot> Source not found.
22:46:16 <mm_freak> what do you need multiple Finished for?
22:46:21 <sjanssen> lispy: forgetting Either?
22:46:39 <lispy> mm_freak: exactly, hence the drawback
22:47:28 <lispy> sjanssen: [Either s a] works, I said you were right.  I just thought having a custom either makes it a bit more self documenting
22:47:49 <rwbarton> Status s is a monad too, right?
22:48:18 <lispy> rwbarton: I tihnk Status s is isomorphic to [a]
22:48:26 <mm_freak> rwbarton: you could turn it into an identity-like monad
22:48:32 <sjanssen> lispy: not really
22:48:35 <dobblego> eh?
22:48:41 <heatsink> I think Status s is isomorphic to [s]
22:48:46 <sjanssen> rwbarton: yeah, I think it is a Monad -- but kind of a weird one
22:48:57 <sjanssen> Status s () is isomorphic to [s]
22:49:00 <lispy> but Status s, stores a list of a effectively
22:49:06 <lispy> oh right
22:49:07 <mm_freak> return x = Finished x
22:49:09 <lispy> I mixed 'em up
22:49:29 <rwbarton> I guess it's just another representation for Writer [s] really
22:49:40 <rwbarton> depending on how you define >>=
22:49:49 <lispy> rwbarton: I was trying to figure out how to make it a writer
22:50:12 <sjanssen> well, the definition for join is pretty obvious
22:50:56 <quicksilver> there is an alternative MonadPlus definition for Error/Either which collects all the errors.
22:50:57 <lispy> :t join
22:50:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:51:01 <rwbarton> does it correspond to strict or lazy evaluation?
22:51:04 <quicksilver> (is that remotely related to what you are talking about?)
22:51:44 <rwbarton> @src-in-terms-of-join >>=
22:51:45 <lambdabot> Unknown command, try @list
22:52:26 <dmwit> :t (join .) . fmap
22:52:28 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
22:52:33 <lispy> sjanssen: it's not obvious to me :)
22:52:38 <rwbarton> @unpl (join .) . fmap
22:52:39 <lambdabot> (\ d i -> (fmap d i) >>= \ e -> e)
22:52:44 <rwbarton> doh
22:52:46 <rwbarton> :)
22:52:50 <lispy> ?src join
22:52:50 <lambdabot> join x =  x >>= id
22:52:51 <dmwit> (>>=) = flip ((join .) . fmap)
22:52:57 <rwbarton> @unpl (join' .) . fmap
22:52:58 <lambdabot> (\ d g -> join' (fmap d g))
22:53:00 <rwbarton> ok
22:53:15 <dmwit> \m f -> join (fmap f m)
22:53:21 <rwbarton> Right
22:53:30 <dmwit> Oh, ?pl already said that. =P
22:53:38 <sjanssen> lispy: join (NotFinished x xs) = NotFinished x (join xs); join (Finished y) = y
22:53:41 <sbahra> Monads are nice.
22:54:17 <sjanssen> or, foldProgress NotFinished id
22:54:22 <rwbarton> OK, so the NotFinisheds from m will be on the outside, right?
22:54:37 <sjanssen> rwbarton: yeah
22:54:49 <rwbarton> kind of like strict evaluation
22:54:52 <sjanssen> well, there are two m's in the signature
22:55:00 <rwbarton> I meant the m in  \m f -> join (fmap f m)
22:57:04 <lispy> fmap f (NotFinished x xs) = NotFinished (f x) (fmap f xs); fmap f (Finished x) = Finished (f x), right?
22:57:29 <rwbarton> The first case shouldn't have (f x), just x
22:57:44 <sjanssen> fmap f = foldProgress NotFinished (Finished . f) -- use the fold, people!
22:57:49 <lispy> rwbarton: so f just applies to the value in finished?
22:57:49 <rwbarton> There's only one a in a Status s a
22:58:06 <lispy> I didn't know we had a fold...
22:58:16 <lispy> rwbarton: yeah, I forgot about that
22:58:49 <lispy> so then, if you define a monad interms of join/fmap do you even need to define the others?
22:59:18 <rwbarton> You still need return, or a value of type m ()
22:59:36 <lispy> ah, well return = Finished
23:00:13 <lispy> :t WriterT
23:00:14 <lambdabot> forall (m :: * -> *) a w. m (a, w) -> WriterT w m a
23:01:42 <lispy> and we're done when we get to: WriterT (Status s) m a
23:01:45 <lispy> right?
23:02:20 <sjanssen> @pl \x xs -> x `seq` (x:xs)
23:02:20 <lambdabot> liftM2 (.) seq (:)
23:02:38 <lispy> it doesn't look right to me...been a while since I tried to use a monad trans
23:03:30 <mmorrow> lispy: this code does it fast: http://hpaste.org/11218#a7
23:03:40 <sjanssen> lispy: I think the point of Status is that we avoid WriterT entirely
23:03:45 <mmorrow> under a second on my laptop
23:03:58 <mmorrow> (and in O(1) mem)
23:04:23 <rwbarton> seems to me that Status s is a version of Writer [s] which has better laziness properties for this use case
23:04:26 <b7j0c> hi, having some issues with mplus and Either. given an expression (t1 `mplus` t2 `mplus` t3)...what i want is for the final result to be (Left e) is *any* of t1,t2,t3 match (Left e)
23:04:47 <b7j0c> doesn't seem to be the way mplus is defined for Either...
23:05:06 <rwbarton> b7j0c: It isn't?
23:05:11 <b7j0c> no
23:05:21 <rwbarton> > (Right 3 `mplus` Left "foo" `mplus` Right 7) :: Either String Integer
23:05:23 <lambdabot>   Right 3
23:05:29 <rwbarton> Oh, I see
23:05:33 <mrd> it wouldn't be
23:05:39 <dons> yo b7j0c.
23:05:40 <lispy> sjanssen:  I think I'm all goofed up with the WriterT, but I just wanted a Writer instance using Status
23:05:41 <mrd> i think you're looking for >>
23:05:53 <b7j0c> hi dons
23:05:59 <b7j0c> mrd,
23:05:59 <rwbarton> What do you want it to be if none of t1,t2,t3 are Left e?
23:06:04 <lispy> mmorrow: cool, alouthgh, this was mm_freak's code and I think he was trying to avoid doing things in IO
23:06:11 <mrd> > (Right 3 >> Left "foo") :: Either String Integer
23:06:12 <lambdabot>   Left "foo"
23:06:19 <b7j0c> Right
23:06:24 <rwbarton> > (Right 3 >> Left "foo" >> Right 7) :: Either String Integer
23:06:24 <mrd> Left :P
23:06:25 <lambdabot>   Left "foo"
23:06:34 <b7j0c> mrd!
23:06:36 <rwbarton> > (Right 3 >> Right 8 >> Right 7) :: Either String Integer
23:06:38 <lambdabot>   Right 7
23:07:01 <mrd> "mplus" is more like "or"
23:07:07 <b7j0c> by the way, does the leading ">" send the expression to lambabot for eval?
23:07:10 <lispy> rwbarton: odd, I thought 3 rights make a left :(
23:07:10 <mmorrow> lispy: ah, oops :)
23:07:14 <mrd> b7j0c: yea
23:07:31 <b7j0c> well thanks for the info mrd
23:07:33 <mmorrow> mm_freak: this seems to be pretty fast: http://hpaste.org/11218#a7
23:07:59 <b7j0c> is there a way i can "privately" send things to lambdabot for eval so other people don't see what a moron i am?
23:08:04 <mrd> /msg
23:08:12 <mrd> @hoogle mappend
23:08:13 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
23:08:15 <b7j0c> cool!
23:08:25 <mmorrow> it inverts control and iterates instead of folds
23:08:54 <b7j0c> just reading RWH online (don't worry dons, i preordered and paid already)...vastly exceeding my expectations!
23:09:00 * mmorrow just read a rather strongly worded pdf/slideshow by tibbe :)
23:09:06 <mm_freak> mmorrow: yeah, but that's solving a different problem =)
23:09:19 <mm_freak> (or the same problem in a different paradigm)
23:10:10 <mmorrow> hmm, so what about it is incompatible? moving `iterate' from inside modSquares to outside of it?
23:10:55 <mmorrow> ooh, i just refreshed that paste page..
23:11:36 <mmorrow> hmm, it looks like the same thing to me :)
23:11:58 <lispy> mmorrow: anything worth sharing? (the pdf I mean)
23:12:15 <mmorrow> heh, i'll get the link
23:12:26 <lispy> mmorrow: what is it about?
23:12:48 <mmorrow> i was chuckling
23:13:07 <lispy> ?go tibbe
23:13:09 <lambdabot> No Result Found.
23:13:18 <waynemokane> is there a quickie for finding whether an element is in a list?    ??? :: (Eq a) => a -> [a] -> Bool
23:13:28 <mmorrow> it's just his slideshow pdf that he gave at galois
23:13:39 <dobblego> @type contains
23:13:39 <sjanssen> @hoogle elem
23:13:40 <jsn> :t elem
23:13:40 <lambdabot> Not in scope: `contains'
23:13:40 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
23:13:40 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
23:13:40 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
23:13:41 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:13:42 <dobblego> oops
23:13:49 <dobblego> wrong language :)
23:13:50 <sjanssen> @hoogle a -> [a] -> Bool
23:13:51 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
23:13:51 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
23:13:51 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
23:13:51 <mmorrow> the whole oleg theme etc
23:14:16 <waynemokane> elem it is!  thx
23:14:24 <mmorrow> lispy: http://www.galois.com/blog/2008/09/12/left-fold-enumerators-a-safe-expressive-and-efficient-io-interface-for-haskell/
23:14:30 <lambdabot> Title: Galois âº Blog âº Blog Â» Left-fold enumerators: a safe, expressive and effici ..., http://tinyurl.com/3f3er3
23:16:23 <b7j0c> well thanks for all the great info folks, shout-outs to mrd
23:16:29 <b7j0c> for solving my problems!
23:16:35 <b7j0c> take care, good night
23:18:43 <lispy> mmorrow: cool, I've been meaning to read on this subject, that paper is an excellent intro
23:18:56 <mm_freak> mmorrow: not incompatible, but an unrelated problem =)
23:20:05 <mmorrow> mm_freak: ah, i see now. so you want to collect them..
23:20:44 <mm_freak> mmorrow: i just wanted to build a list and then index an element with status messages
23:20:46 * mmorrow is only half sure if he know what the problem statement even is
23:21:01 <mmorrow> lispy: yeah, totally
23:22:28 <mmorrow> mm_freak: hmm, i think i see now
23:27:14 <rwbarton> I made Status w a MonadWriter [w] instance and used it with the original code, and I get O(1) memory provided I only demand one of x and msgs
23:33:29 <rwbarton> mm_freak: You can use this data structure with the original indexProgress:  http://hpaste.org/11218#a8
23:40:50 <mm_freak> the code is getting bigger and bigger
23:41:00 <mm_freak> i'll use my original monadic version
23:41:25 <mm_freak> it's simple, easy to understand and works well
23:42:08 <mm_freak> we're killing bees with nuclear bombs here =)
23:44:08 <rwbarton> Aw... you don't want to use category-extras and the fact that Status w is the free monad on (,) w? :)
23:50:50 <mm_freak> hehe
23:50:56 <mm_freak> no, i don't ;)
23:51:19 <zeno> IM UNLOVED :( [andrew@newcomp ~]$ cabal install yi;cabal: alex version >=2.0.1 && <3 is required but it could not be found.
23:51:34 <dcoutts> zeno: cabal install alex
23:52:39 <zeno> dcoutts: i was talking about <3 is required but it could not be found :)
23:53:25 <zeno> install alex errors with
23:53:25 <zeno> /tmp/TMPalex-2.2/alex-2.2/Setup.lhs:30:43:
23:53:25 <zeno>     Not in scope: `buildVerbose'
23:54:21 <mm_freak> then don't be so unloving
23:54:25 <mm_freak> a heart is required =)
23:54:29 <dcoutts> zeno: cabal update; cabal install alex
23:54:47 <dcoutts> zeno: you need the later version of alex that works with ghc-6.10 / Cabal-1.6
23:55:17 <mm_freak> (sorry, i'm just showing clear signs that i need sleep, so thanks for your help and bye)
23:56:54 <zeno> dcoutts thanks
23:58:31 <zeno> dcoutts: what about <3? where can i find that?
23:59:13 <dcoutts> zeno: alex version 2.3 is less than version 3
23:59:40 <dcoutts> >= 2.0.1 && < 3 means a version in that range, not two different versions
23:59:50 <mmorrow> mm_freak: here's my prev paste with Status added fwiw: http://hpaste.org/11218#a9
