00:00:16 <humasect> it does not seem widely known let alone understood, that game creation depends just as much on the target system as it does on the creators; for what the game actually becomes. ie. developing for Nintendo DS, that is the "API" and its very limitations is what causes the creativity in the games available
00:00:36 <humasect> there is up to 100-tuple, but i think any past 64 is commented out
00:01:07 <humasect> i could see how come really nutty TH or the like could make use of it
00:01:21 <dmwit_> Yup, GHC can't handle 64-tuples or up.
00:01:30 <dmwit_> It just prints a message saying to use nested tuples. =)
00:01:36 <ivanm> well, doesn't that suck ;-)
00:01:51 <humasect> hehe
00:02:22 <dmwit_> I agree with Baughn.  These things should be generated automatically at compile time, not hand-written at code-writing time.
00:02:53 <dmwit_> ...not that I've ever needed more than a triple.
00:02:54 <humasect> ah, yes. i think they might be.
00:03:10 <ac> humasect: limitations in the APIs available could certainly inspire creative programming, but I don't see how it would inspire content. Also, for the most part, more powerful APIs and CPUs seems to just end up making game authors throw in more eye candy
00:03:25 <dmwit_> humasect: err, where "compile-time" means the time you compile your application, not the time that GHC gets compiled =P
00:04:20 <humasect> ac: yep, that is right. so an artist spends 3 days to develop a photorealistic rock that no one sees. there is a level of abstraction which is not provided by most/all tools which would have identical effect if not greater impact on presentation.
00:05:20 <humasect> hm, data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n = (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
00:06:07 <ac> humasect: and I totally agree that the really big game projects are not being efficient, and don't actually require that much work. That's probably true for all big software projects
00:06:41 <humasect> yes. i think haskell is a great start to fixing any of this
00:07:41 <humasect> so anything designed purely within that world, as honorably and reflective of its intention as can be done, will ripple outward to those things which it is then applied to
00:07:42 <Baughn> I did try some haskell game-making, but through feature creep it's now become an universe-simulator. That's a point, too - it's entirely too easy to throw in more cool stuff, until you entirely lose sight of the original idea.
00:07:52 <humasect> hehehe
00:07:59 <humasect> yes indeed
00:08:15 <Baughn> And, of course, it's so hoorrifyingly complex that it's stalled.
00:08:21 <humasect> meditating helps. ^_^ it can be far too easy to let the ambition create a monster only to devour its creator..
00:08:29 <Baughn> Why do I have to learn lorentzian geometry to write a game? ;_;
00:08:37 <humasect> hehe =)
00:08:50 <ac> Baughn: lol
00:09:57 <ac> Baughn: I thought it would be cool to write a game like portal that actually warped space in to 4 dimensions, but it would be rather computationally impossible I believe
00:10:21 <BMeph> Haskell: We don't design games; we make the games you design...Better! ;)
00:10:29 <Baughn> ac: Oh sure, it's impossible if you try for exactness
00:10:33 <Baughn> Approximations are something else
00:10:45 <humasect> these tools also, simplicity was #1. except the editor is very logically-bound and difficult to reproduce without the same amount of efforts that were found by actually making it while using it.
00:11:09 <humasect> BMeph: hehe, why do i feel at a different rhythm in here than everyone else? =)
00:11:38 <dmwit_> ac: Just deciding how gravity should behave near a Portal is already a hard problem.
00:11:50 <BMeph> humasect: <Shrug> Er, lack of laziness? ;)
00:11:58 <humasect> when i first compiled numeric-prelude, i realised just how far skellers can go, to reproduce anything at any detail. what use is it?
00:12:10 <ac> dmwit_: but think of all the fun you could have with spaces with convoluted topology...
00:12:24 <Baughn> ac: "Fun". ;_;
00:12:33 * dmwit would have fun
00:12:33 <Baughn> In practice, you'll mightily confuse people
00:13:19 <ac> Baughn: naturally. The whole point is to make a mind expanding game
00:15:39 <ac> dmwit: I presume gravity would act in the direction of the shortest path towards the attracting mass, but with convoluted spaces, finding the shortest path would probably be difficult
00:16:25 <humasect> haskell is enough of a game for most people, it seems.
00:16:57 <dmwit> ac: That may be technically a good solution, but I don't think pragmatically it's a good solution for a game.
00:17:16 <humasect> because of haskell profundity, it is easy to go overboard.
00:17:36 <humasect> eg. data (,,,,,,,,,,,,) a b c d e f g h i j k l m = (,,,,,,,,,,,,) a b c d e f g h i j k l m
00:17:42 <humasect> =)
00:18:02 <dmwit> ac: If you use a shortest-path approach, there are contours where gravity suddenly switches directions -- probably a very unsettling game mechanic.
00:18:23 <ac> dmwit: indeed, and precise points where it would cancel itself out entirely
00:18:25 <humasect> dmwit: have you played mario galaxy? no problem =)
00:18:52 <dmwit> humasect: Have you seen their gravity model?
00:18:56 <dmwit> humasect: It's not what you think it is.
00:19:03 <pstickne> isn't the standard approach just to sum the forces?
00:19:07 <humasect> its what the player experiences, dmwit
00:19:22 <Baughn> ac: If you really want to know, read papers on wormholes. It's not at all what you'd think
00:19:23 <dmwit> humasect: My point exactly.  ac's model is not a good player experience
00:19:31 <humasect> dmwit: oh, ok =)
00:19:52 <ac> Baughn: I probably wouldn't be able to understand any papers on wormholes
00:20:19 <dmwit> humasect: In particular, in Mario Galaxy, they worked really hard to make sure that the force Mario experiences is a continuous function of your position, whereas ac's is discontinuous.
00:20:41 <humasect> i am a good coder, even with plenty of math, but on the artistic side. i could never fully read a paper like you guys seem to enjoy ^_^
00:20:55 <Baughn> ac: Hm. Executive summary: If you think of gravity as having field lines then, when you move through a wormhole, your field lines get "caught" on it so the wormhole acquires your charge, mass, etc. - or at least appears to. The one you come out of acquires their /negative/.
00:21:13 <humasect> dmwit: ah, i see. i had a game just like mario galaxy's, in the 90s
00:21:57 <Baughn> ac: But for two object on different sides on the wormhole, what they feel depends on the internal geometry (if any) and surface area of the wormhole itself
00:22:49 <ac> Baughn: another words it's completely nuts to go through a wormhole
00:23:08 <Baughn> ac: A sufficiently large wormhole is indistuingishable from normal space
00:23:46 <ac> Baughn: that makes sense
00:25:38 <chrisdone> yay, my blog is now one which was written in haskell http://chrisdone.com/
00:30:53 <ivanm> chrisdone: using what?
00:31:13 <ivanm> oh, wait, now it's loaded and says what :s
00:31:19 <mmorrow> chrisdone: rad, using Panda i see. i think i may follow suit.
00:31:32 <chrisdone> ^_^!
00:31:50 <ivanm> yeah, IIRC panda stole code from pandoc
00:33:46 <mmorrow> @remember humasect meditating helps. ^_^ it can be far too easy to let the ambition create a monster only to devour its creator..
00:33:47 <lambdabot> Nice!
00:33:52 <humasect> chrisdone =)
00:34:14 <humasect> novapilot page too, is all text.html =)
00:34:43 <chrisdone> what's novapilot?
00:35:11 <humasect> http://96.51.4.55/~humasect/ <- this old thing
00:35:11 <lambdabot> Title: Hoovy Studios
00:36:12 <chrisdone> Novapilot is the enlightened technology designed and developed for advanced real time, hardware accelerated, modern and high level flexibility, power and wisdom for simplistically profound and virtuously productive game development, which is demonstrated through the games created with it.
00:36:14 * chrisdone blinks
00:36:37 <Baughn> Enlightened, no less?
00:36:39 <chrisdone> take 500 $ Data.MarkovChain.run markettingBullshitFile
00:37:00 <Baughn> No, that's too much. It has to be meant ironically.
00:37:25 <chrisdone> of course
00:37:32 <chrisdone> I just like mentioning the markov chains module
00:37:44 <Baughn> Wait, there is a markov chains module?
00:37:58 <Baughn> Oh. I see.
00:38:04 <chrisdone> missing out!
00:38:13 <qebab> wait, really?
00:38:15 <chrisdone> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/markov-chain
00:38:17 <lambdabot> Title: HackageDB: markov-chain-0.0.2, http://tinyurl.com/4fsuft
00:38:33 <humasect> hehe its just text filler.
00:38:42 <chrisdone> %jbobau
00:38:44 <lojbot> ue coi xal do'u mi cu ba zi na jundi vau
00:39:02 <Baughn> It appears to lack a method to save (and later extend) the sequences
00:39:03 <chrisdone> ^ that's grammatical lojban, generated from irc logs and Data.MarkovChain  ;D
00:39:24 <chrisdone> yeah, I kind of wanted that once
00:39:39 <qebab> hrm. chrisdone: what sort of order does that use?
00:40:16 <qebab> after experimentation I have found that order 3 gives the most plausible strange new words :)
00:40:46 <chrisdone> mine uses order 3, but for whole words, not letters
00:41:58 <qebab> yeah, that gives good results but tends to reproduce a lot of the input verbatim
00:42:12 <chrisdone> indeedy
00:42:14 <mmorrow> humasect: those screenshots look great
00:42:20 <qebab> anything beyond order 3 basically just echoes back what you say to it
00:42:50 * Baughn wonders what order -1 would be
00:43:05 <humasect> hehe mmorrow , sometimes i wonder how it even works with so little code.
00:43:18 <qebab> Baughn: prefixes of length -1? that could be interesting :p
00:43:47 <qebab> Baughn: that said, M-x dissociated-press will accept -1 as an argument
00:44:30 <donthaveaname> hello. in read . concatMap show $ (a:b:c:d:e:[]) :: Integer i don't understand the meaning of the dot(.) and $. any hints?
00:44:53 <humasect> @src (.)
00:44:54 <lambdabot> (f . g) x = f (g x)
00:44:55 <mmorrow> f x === f $ x
00:44:56 <humasect> @src ($)
00:44:56 <lambdabot> f $ x = f x
00:44:57 <BMeph> ?type (.)
00:44:58 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:45:11 <BMeph> ?type ($)
00:45:12 <lambdabot> forall a b. (a -> b) -> a -> b
00:45:18 <mmorrow> (g . f) x === g (f x)
00:45:22 <donthaveaname> GET A RL
00:45:25 <BMeph> donthaveaname: hint, hint
00:45:51 <dmwit> a:b:c:d:e:[] -- =/
00:45:56 <dmwit> [a, b, c, d, e] -- =D
00:47:10 <rahuljosephgeorg> hi
00:47:31 <chrisdone> hai
00:47:49 <rahuljosephgeorg> i need help
00:48:00 <rahuljosephgeorg> it's about programming
00:48:12 <BMeph> we have help here. ;)
00:48:30 <rahuljosephgeorg> im trying to make an mmo game
00:48:42 <dmwit> What's your budget?
00:48:47 <rahuljosephgeorg> usuing no no
00:48:49 <rahuljosephgeorg> it's free
00:48:56 <chrisdone> > "I detect a " ++ cycle "troll "
00:48:57 <lambdabot>   "I detect a troll troll troll troll troll troll troll troll troll troll tro...
00:49:06 <rahuljosephgeorg> ?
00:49:11 <Baughn> I assure you, making games isn't free
00:49:15 <ivanm> s/detect/smell/
00:49:24 <rahuljosephgeorg> usuing eclipse
00:49:24 <ivanm> Baughn: so why are there so many free games available?
00:49:29 <chrisdone> ivanm:  fe fi fo fum?
00:49:32 <ivanm> heh
00:49:35 <qebab> Baughn: well, it is if you have a bunch of people with free time :) a lot of free time
00:49:36 <dmwit> rahuljosephgeorg: Check ##java or something.
00:49:37 <humasect> how much does it cost to tell someone what they can or can't, should or shouldn't do?
00:49:39 <dmwit> We use Haskell here.
00:49:41 <ivanm> rahuljosephgeorg: ummmm.... how is that relevant here then?
00:49:49 <Baughn> ivanm: Some people have odd priorities
00:49:52 <ivanm> unless by eclipse you mean the functional plugin for eclipse...
00:49:53 <rahuljosephgeorg> exlipse
00:49:57 <rahuljosephgeorg> eclipse
00:50:03 <rahuljosephgeorg> no
00:50:07 <ivanm> Baughn: yes.... so?
00:50:13 <rahuljosephgeorg> it's a program that helps u to make mmorpg game
00:50:14 <Baughn> Well, I suppose you could make an MMO in haskell faster than most languages.. so long as you don't spend half a year writing a 3d engine. :P
00:50:34 <rahuljosephgeorg> im new here
00:50:34 <rahuljosephgeorg> ok
00:50:40 <BeelsebobWork_> who said an MMO even needed a 3D engine
00:50:40 <rahuljosephgeorg> and what is haskell
00:50:41 <ac> lol
00:50:46 <rahuljosephgeorg> and what is haskell?
00:50:50 <BeelsebobWork_> rahuljosephgeorg: you're the one in #haskell
00:50:54 <humasect> haskell is for making your mmo
00:50:55 <BeelsebobWork_> you tell us
00:50:56 <BeelsebobWork_> ;)
00:51:03 <rahuljosephgeorg> wait
00:51:04 * Baughn twitches randomly
00:51:08 <mapreduce> rahuljosephgeorg: This is a channel about the Haskell programming language.  Did you join the wrong channel by accident?
00:51:10 <rahuljosephgeorg> haskell is a language?
00:51:14 <jeffz> who want to see a baby Haskell elephant?
00:51:20 <BeelsebobWork_> rahuljosephgeorg: yes, Haskell is a language
00:51:21 <Baughn> rahuljosephgeorg: What did you /think/ it was?
00:51:28 <jeffz> http://img242.imageshack.us/img242/1108/elephantaq4.png
00:51:32 <mapreduce> A spreadsheet.
00:51:36 <rahuljosephgeorg> ok
00:51:42 <rahuljosephgeorg> how do i learn it
00:51:48 <rahuljosephgeorg> and what is it used for?
00:51:50 <ivanm> rahuljosephgeorg: www.haskell.org
00:51:59 <BeelsebobWork_> rahuljosephgeorg: all you need to do to write your MMO is type this command > unsafePerformIO launchMissiles
00:52:00 <ivanm> it's turing complete, so it can technically be used for anything
00:52:03 <Wild_Cat> rahuljosephgeorg: pretty much anything you want to use it for.
00:52:05 <ivanm> BeelsebobWork_: LOL!
00:52:08 <humasect> haskell is used for making mmos and people twitch randomly
00:52:11 <rahuljosephgeorg> even games?
00:52:14 <rahuljosephgeorg> mmo games?
00:52:16 <ivanm> @remember BeelsebobWork_  all you need to do to write your MMO is type this command > unsafePerformIO launchMissiles
00:52:16 <lambdabot> Done.
00:52:30 <BeelsebobWork_> rahuljosephgeorg: sure, why not?
00:52:35 <qebab> rahuljosephgeorg: are you know enough programming to make an mmo?
00:52:38 <Baughn> ivanm: This may be a low blow, but so is COBOL
00:52:50 <ivanm> yes
00:52:52 <Wild_Cat> rahuljosephgeorg: There was a presentation a while ago about how Epic Games was considering switching to it or another FP language for their game engine.
00:52:53 <ivanm> and?
00:52:53 <mapreduce> BlowBol
00:52:53 <rahuljosephgeorg> i dont know a language
00:52:56 <qebab> er, sure*
00:52:57 <rahuljosephgeorg> besides im 12
00:53:11 <BeelsebobWork_> rahuljosephgeorg: well, I suggest lowering your expectations a little
00:53:11 <qebab> rahuljosephgeorg: then start by doing other things.
00:53:14 <rahuljosephgeorg> and im really interested in computers
00:53:14 <ivanm> rahuljosephgeorg: well, creating an MMO might be a bit ambitious as a first project
00:53:19 <rahuljosephgeorg> and im really interested in computers
00:53:25 <BeelsebobWork_> writing an MMO takes *many* man-years for experienced programmers
00:53:25 <humasect> haskell is a fun place to start, rahuljosephgeorg
00:53:25 <qebab> rahuljosephgeorg: making an mmo is an awful lot of work
00:53:26 * ivanm is amazed that a 12yo knows what IRC _is_, let alone uses it
00:53:35 <rahuljosephgeorg> i wana make a game who cares if i cant make mmo's
00:53:42 <rahuljosephgeorg> how about just normal computer games
00:53:49 <ivanm> @go haskell frag
00:53:52 <BeelsebobWork_> rahuljosephgeorg: what I suggest you do, is learn a language -- haskell is a great start -- and then start thinking about games
00:53:54 <ac> ivanm: I'm not amazed at that, I'm just amazed he stumbled in to #haskell
00:54:01 <lambdabot> http://www.haskell.org/haskellwiki/Frag
00:54:01 <lambdabot> Title: Frag - HaskellWiki
00:54:02 <humasect> rahuljosephgeorg: you can do whatever you like! one can only fail when they give up, right?
00:54:03 <ivanm> ac: I was getting to that ;-)
00:54:10 <mapreduce> rahuljosephgeorg: Python is a programming language that has some libraries specifically for making games with.
00:54:15 <ivanm> rahuljosephgeorg: see that link from lambdabot above... it's a FPS written in Haskell
00:54:17 <mapreduce> pygame
00:54:18 <rahuljosephgeorg> right
00:54:22 <qebab> rahuljosephgeorg: all I am saying is that for a first project, you should not try to make something so complex. save it for when you know programming properly :)
00:54:24 <chrisdone> #1) you can't even use IRC well; #2) you can't tab-complete; #3) you can't google - this implies yer too busy jerking off and sucking soda or video-gaming. Die well, kid
00:54:35 <ivanm> @slap chrisdone
00:54:35 * lambdabot will count to five...
00:54:36 <chrisdone> (quote from PoppaVic)
00:54:37 <rahuljosephgeorg> ok
00:54:43 <rahuljosephgeorg> is anyone here on yahoo?
00:54:45 <ivanm> we're known as the _friendly_ language channel!
00:54:49 <rahuljosephgeorg> i really need
00:54:50 <rahuljosephgeorg> help
00:54:52 <qebab> chrisdone: was that necessary?
00:54:54 <mapreduce> rahuljosephgeorg: Yahoo's for grannies. :)
00:54:55 <Baughn> chrisdone: Poppavic is not for quoting. ;_;
00:54:56 <rahuljosephgeorg> and i use yahoo for chat
00:54:57 <rahuljosephgeorg> so
00:55:08 <chrisdone> Baughn: haha, his quotes make me laugh so much
00:55:12 <BeelsebobWork_> rahuljosephgeorg: I'd suggest you look at http://www.haskell.org/ -- down the left hand side there's a "Learning" section
00:55:13 <lambdabot> Title: Haskell - HaskellWiki
00:55:17 <ivanm> rahuljosephgeorg: 1) learn how to program, 2) _then_ consider writing a game
00:55:20 <BeelsebobWork_> there's tons of good tutorials
00:55:24 <mapreduce> ivanm: Huh?
00:55:30 <BeelsebobWork_> they should get you started on ivanm's stage 1)
00:55:34 <mapreduce> I learned to program by writing games, admittedly pretty crap ones.
00:55:34 <rahuljosephgeorg> ok
00:55:41 <humasect> mapreduce: right =)
00:55:51 <ivanm> mapreduce: s/a game/a decent game/
00:55:51 <humasect> learning == doing
00:55:52 <ivanm> happy now?
00:55:53 <rahuljosephgeorg> wait it says download haskell?
00:55:55 <rahuljosephgeorg> wait it says download haskell?
00:55:58 <BeelsebobWork_> mapreduce: yeh, just probably they were games like "guess the number" not WoW
00:56:00 <jeffz> rahuljosephgeorg: stop repeating
00:56:07 <rahuljosephgeorg> sorry
00:56:09 <ivanm> well, it's a bit hard to learn haskell without using it
00:56:12 <mapreduce> rahuljosephgeorg: Yes, generally to use a program you need to download it.
00:56:12 <ivanm> admittedly, it's possible
00:56:14 <BeelsebobWork_> rahuljosephgeorg: yes, for any language you learn you'll need to download either an interpretter or a compiler
00:56:22 <rahuljosephgeorg> yeah
00:56:24 <BeelsebobWork_> they translate your code into something the computer can run
00:56:26 <humasect> ivanm: it is also hard to do something without learning too. they are 1:1
00:56:31 <rahuljosephgeorg> i know
00:56:33 <rahuljosephgeorg> i know
00:56:47 <qebab> right, that was very unpleasant
00:56:48 <ivanm> humasect: true
00:56:50 <BeelsebobWork_> rahuljosephgeorg: so, the tutorials there will tell you how to download a Haskell interpretter & compiler :)
00:56:52 <chrisdone> mapreduce: not fer long! /me checks his google spreadsheet
00:56:55 <qebab> someone hard-reset my server
00:57:00 * qebab is angry
00:57:04 <rahuljosephgeorg> so
00:57:06 <mapreduce> rahuljosephgeorg: Dude: http://www.pygame.org/news.html
00:57:10 <rahuljosephgeorg> will u guys
00:57:13 <rahuljosephgeorg> be on this
00:57:17 <lambdabot> Title: pygame - python game development
00:57:18 <rahuljosephgeorg> chatting
00:57:22 <rahuljosephgeorg> everyday?
00:57:30 <Baughn> rahuljosephgeorg: Pretty much. Only about haskell, though.
00:57:32 <ivanm> well, _someone_ usually is
00:57:34 <mapreduce> rahuljosephgeorg: Check the screenshots.
00:57:44 <BeelsebobWork_> mapreduce: dudo, no offence, but telling someone who's come into #haskell uncontaminated by imperative languages to go and learn python is *really* cruel
00:58:00 <Axman6> agreed
00:58:02 <humasect> BeelsebobWork_: agreement
00:58:02 <rahuljosephgeorg> which should i learn first?
00:58:06 <ac> yeah, I was just going to make some sort of comment about the Python nudging
00:58:08 <Axman6> haskell
00:58:08 <dmwit> Haskell.
00:58:08 <rahuljosephgeorg> phyton or haskell
00:58:17 <BeelsebobWork_> rahuljosephgeorg: I'd highly recommend Haskell as a first language
00:58:17 <ac> Haskell
00:58:23 <dmwit> ?quote "even the lisp"
00:58:23 <Axman6> preemptive multianswering ftw!
00:58:23 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
00:58:24 <BeelsebobWork_> it teaches you a really lovely way to think
00:58:26 <Baughn> rahuljosephgeorg: Haskell would be best. It's hard to learn haskell /after/ python, but the other way would be fine
00:58:29 <dmwit> ?quote lisp
00:58:30 <lambdabot> twb says: I liked _On Lisp_, but it should have been called _Dirty Things I Did With Macros_
00:58:36 <Baughn> rahuljosephgeorg: Not that most haskellers feel like they need python. :P
00:58:36 <rahuljosephgeorg> ok
00:58:40 <mapreduce> BeelsebobWork_: He wants to write games.  He's 12.  Find me a similar page to the pygame one that fits both criteria.
00:58:47 <sjanssen> if making games is the point, is Haskell the best place to start?
00:58:51 <ac> rahuljosephgeorg: though once you really learn Haskell, your brain might expand to dangerous sizes
00:59:07 <rahuljosephgeorg> what do u mean ac?
00:59:12 <mapreduce> And learning doesn't damage.
00:59:26 <mapreduce> ghc wouldn't be as good as it is if SPJ didn't learn imperative programming.
00:59:33 <BeelsebobWork_> mapreduce: all the evidence I've seen says that learning an imperative language does damage your ability to think
00:59:34 <dmwit> ?quote dcnstrct
00:59:34 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
00:59:44 <rahuljosephgeorg> hey
00:59:46 <mapreduce> BeelsebobWork_: Ah, clearly you can see that with SPJ.  Dumb as a dog.
00:59:47 <ivanm> is there a version of concatMap for monads? (i.e. so I can use it in IO)
00:59:48 <rahuljosephgeorg> if i learn haskell
00:59:50 <Baughn> rahuljosephgeorg: Haskell programmers tend to be smarter than other programmers. We're not sure whether haskell makes us smarter, or other languages damage your brain, but either way..
00:59:57 <rahuljosephgeorg> can i make games for commercial use?
01:00:02 <mapreduce> rahuljosephgeorg: Sure.
01:00:04 <BeelsebobWork_> mapreduce: I'm sure that SPJ had to do a decent amount of unlearning when he first came across functional languages too
01:00:08 <Baughn> rahuljosephgeorg: In a decade. :P
01:00:13 <ivanm> Baughn: or else dumb people give up quickly :p
01:00:16 <solrize> @hoogle zipWith0
01:00:16 <lambdabot> No results found
01:00:17 <rahuljosephgeorg> ok
01:00:17 <dmwit> ivanm: uh, (>>=)?
01:00:20 <ac> Baughn: or smart people choose to use Haskell
01:00:25 <rahuljosephgeorg> so haskell people are smatter?
01:00:26 <Wild_Cat> Baughn: IMO, it's more like "to understand Haskell, you need to be smart."
01:00:28 <BeelsebobWork_> rahuljosephgeorg: it takes a long time to learn all the stuff you need to do it... but you can in the end
01:00:28 <chrisdone> the whole imperative-languages-make-programmers-stupid idea is just a troll started by Dijkstra
01:00:29 <ivanm> @ty (>>=)
01:00:30 <dmwit> ivanm: (What do you mean?)
01:00:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:00:44 <ivanm> dmwit: (a -> m [b]) -> [a] -> m [b]
01:00:49 <ivanm> @type mapM
01:00:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:00:56 <Baughn> Wild_Cat, ac, ivanm: Maybe. *Maybe*, but no non-programmers I've tried to teach have had any more trouble with haskell than other languages.
01:00:58 <ivanm> ^^ a concatenated version of that
01:01:00 <Baughn> Usually less
01:01:06 <dmwit> :t \f -> liftM concat . mapM f
01:01:07 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
01:01:09 <BeelsebobWork_> chrisdone: I've seen really good evidence for it -- my wife is picking up Haskell *way* easier than any of my students when I was teaching at Kent
01:01:14 <dmwit> ivanm: ^^
01:01:16 <Wild_Cat> Baughn: even with monads?
01:01:19 <BeelsebobWork_> (because she's never seen another language)
01:01:21 <mapreduce> Baughn: If you hadn't been teaching them would they have had trouble doing it themselves?
01:01:21 <humasect> Baughn: beginner's mind, zen midn
01:01:23 <ivanm> thanks dmwit
01:01:27 <Baughn> Wild_Cat: Monads aren't really that special
01:01:30 <chrisdone> BeelsebobWork_: maybe your wife is just smarter?
01:01:41 <Baughn> Wild_Cat: It's a way to overload syntax. That's about it..
01:02:00 <BeelsebobWork_> chrisdone: maybe, but much as I love my wife, I doubt that she's magically smarter than *every* computer science student to go through UKC
01:02:09 <rahuljosephgeorg> hey in the haskell homepage it says find a library.......what's that mean?
01:02:30 <Baughn> mapreduce: Probably, but it's very rare for someone to learn to program entirely on their own
01:02:30 <Wild_Cat> Baughn: yeah. I kinda get them now, but they're what stopped me dead in my tracks the first 2 or 3 times I tried to learn Haskell. Eveything was crystal-clear except for them. Which I blame on the tutorials more than on the concept itself, though.
01:02:39 <BeelsebobWork_> rahuljosephgeorg: you'll learn that when you get into it a bit -- essentially it means find a group of pre-programmed stuff that you can pick up and use
01:02:40 <dmwit> rahuljosephgeorg: In the CS world, a library is a package of useful software bundled for use by a programmer.
01:02:41 <ivanm> BeelsebobWork_: UKC?
01:02:51 <mapreduce> rahuljosephgeorg: Programming languages tend to come with a small 'standard library' when you download the compiler.  There are extra libraries for the language, usually made by various people.  You can find those from that link.
01:02:51 <BeelsebobWork_> ivanm: Uni of Kent at Canterbunnies
01:02:56 <ivanm> ahhh
01:03:02 <ivanm> "Canterbunnies"? :p
01:03:03 <mapreduce> Canterbury.
01:03:06 <BeelsebobWork_> :P
01:03:08 <ivanm> yeah, I got that
01:03:08 <Wild_Cat> now the one stumbling block is that purity prevents me from adding print statements everywhere to debug my programs. That sucks.
01:03:09 <chrisdone> >:3
01:03:16 <rahuljosephgeorg> can anyone tell me how to download the haskell compiler?
01:03:17 <chrisdone> ... ;_;
01:03:18 <Baughn> Wild_Cat: Debug.Trace.trace
01:03:18 <ivanm> Wild_Cat: trace?
01:03:19 <humasect> Wild_Cat: hehe
01:03:26 <int-e> Wild_Cat: have a look at Debug.Trace
01:03:30 <Baughn> rahuljosephgeorg: What OS are you on?
01:03:31 <ivanm> rahuljosephgeorg: go to haskell.org, click download, go from there?
01:03:31 <BeelsebobWork_> rahuljosephgeorg: haskell.org/ghc <-- click the download button
01:03:35 <Axman6> @where GHC
01:03:35 <rahuljosephgeorg> windows xp
01:03:35 <lambdabot> http://haskell.org/ghc
01:03:37 <Wild_Cat> nice group shot :D . How do I use that?
01:03:40 <Axman6> rahuljosephgeorg: ^^
01:03:54 <ivanm> @hoogle trace
01:03:54 <rahuljosephgeorg> im on windows xp
01:03:55 <lambdabot> Debug.Trace trace :: String -> a -> a
01:03:55 <lambdabot> module Debug.Trace
01:03:55 <lambdabot> package traced
01:03:57 <dmwit> Wild_Cat: Look at its type and guess.
01:04:05 <rahuljosephgeorg> hello?
01:04:10 <int-e> > trace
01:04:12 <lambdabot>   Not in scope: `trace'
01:04:14 <rahuljosephgeorg> can i download it?
01:04:14 <ivanm> Wild_Cat: import Debug.Trace; 2 == trace "hiya" (1+2)
01:04:19 <thoughtpolice> Wild_Cat: it's basically 'trace s = unsafePerformIO $ print s'
01:04:23 <ivanm> rahuljosephgeorg: yes
01:04:29 <Baughn> rahuljosephgeorg: There's just the one windows package, then.. um, you should probably learn linux (or grab a mac) at some point, but that's not important for haskell
01:04:35 <ivanm> isn't there a GUI ndm was working on for windows?
01:04:46 <rahuljosephgeorg> ok can i get a link
01:04:49 <thoughtpolice> ivanm: ndm worked on winhugs
01:04:55 <ivanm> yeah, that's what I mean
01:04:57 <Baughn> rahuljosephgeorg: http://haskell.org/ghc/download_ghc_683.html#windows
01:04:59 <lambdabot> Title: GHC: Download version 6.8.3
01:05:00 <ivanm> @go winhugs
01:05:01 <dmwit> trace s v = unsafePerformIO (putStr s >> return v) -- thoughtpolice, Wild_Cat
01:05:02 <lambdabot> http://www.haskell.org/haskellwiki/WinHugs
01:05:02 <lambdabot> Title: WinHugs - HaskellWiki
01:05:04 <rahuljosephgeorg> thx
01:05:05 <Wild_Cat> right, so it's just something I add before any operation and poof, it prints its result, right?
01:05:11 <ivanm> rahuljosephgeorg: ^^ you might want winhugs to start with
01:05:16 <ivanm> Wild_Cat: and the string you want
01:05:19 <sjanssen> rahuljosephgeorg: if you don't mind me asking, what made you decide to join #haskell?
01:05:20 <rahuljosephgeorg> winhugs?
01:05:23 <Wild_Cat> all right, I see. Brilliant.
01:05:29 <ivanm> I often find this function handy: tracer a = trace (show a) a
01:05:29 <thoughtpolice> Wild_Cat: yes, but it's lazily evaluated
01:05:32 <Wild_Cat> ...and it cheats with purity, as well ^^
01:05:39 <Baughn> rahuljosephgeorg: Oh, and you'll want a better text editor than notepad, if you don't have one. Textpad is simple to use, and good enough for now.
01:05:44 <thoughtpolice> so you might not see the print statements you want ever, or they may just appear at random times
01:05:46 <ivanm> rahuljosephgeorg: Hugs is a Haskell interpreter, and WinHugs is a WIndows GUI
01:05:52 <dmwit> Wild_Cat: But don't let me catch you using it ever.
01:05:53 <dmwit> ;-)
01:05:53 <thoughtpolice> ('seemingly random times' that is)
01:06:12 <ivanm> thoughtpolice: we're talking about a computer, which is mainly deterministic here...
01:06:17 <ivanm> so it's probably only pseudo-random
01:06:21 <ivanm> ;-)
01:06:21 <rahuljosephgeorg> i needed help with programming so i thought i search for programming help and i thought this was the best place
01:06:45 <mapreduce> rahuljosephgeorg: Sure, but most of the documentation on Haskell isn't aimed at 12 year-olds who want to write games.
01:06:49 <thoughtpolice> ivanm: laziness + io == problems generally,
01:06:51 <mapreduce> rahuljosephgeorg: Which is a shame.
01:06:53 <Axman6> rahuljosephgeorg: tutorials are usually a better place to start, but we'll give you any help you need
01:06:57 <ivanm> thoughtpolice: yeah
01:06:57 <thoughtpolice> but i think you get what I was trying to say :]
01:07:06 <rahuljosephgeorg> then what is it aimed for?
01:07:09 <Axman6> mapreduce: ha
01:07:24 <Axman6> rahuljosephgeorg: a lot of comp sci stuff done with it
01:07:29 <Baughn> rahuljosephgeorg: Thirty-year-old computer science PhDs, I'm afraid. ^^;
01:07:34 <humasect> rahuljosephgeorg: you came to the right place =)
01:07:36 <ivanm> rahuljosephgeorg: not many languages are purposefully designed for 12yo's to make games
01:07:46 <thoughtpolice> ivanm: there's something in the ghc trac about building a UI for ghc along the line of winhugs but according to ndm winhugs is tied to hugs internals in really nasty ways, and with ghc being a much more moving target, something like that outside of the standard distribution may become pretty hard to maintain...
01:07:47 <Baughn> rahuljosephgeorg: A lot of the articles seem to assume you already know what they're trying to explain
01:07:48 <Axman6> exept VM
01:07:50 <humasect> ivanm: each person is their own very special demographic !
01:07:50 <Axman6> VB*
01:08:06 <dmwit> Well, there's Squeak, or whatever.
01:08:10 <rahuljosephgeorg> VM = Virtual Machine?
01:08:11 <ivanm> thoughtpolice: hmmmmm....... oh well, I use emacs anyway ;-)
01:08:17 <ivanm> rahuljosephgeorg: yup
01:08:20 <Axman6> i meant VB not VM
01:08:22 <humasect> thoughtpolice: hm, interesting.
01:08:22 <Baughn> dmwit: Squeak is definitely /not/ designed for that. ;_;
01:08:25 <thoughtpolice> ivanm: C-c C-l ftw!
01:08:28 <rahuljosephgeorg> VB = Visual Basic?
01:08:31 <humasect> hehe squeak ..
01:08:32 <Axman6> yah
01:08:32 <Baughn> There's Logo, though
01:08:32 <dmwit> Baughn: Then what am I thinking of?
01:08:33 <ivanm> thoughtpolice: damn straight!
01:08:36 <Baughn> dmwit: Logo?
01:08:40 <dmwit> Baughn: Something with an s.
01:08:43 <Axman6> lego mindstorms!
01:08:44 <ivanm> and now I've worked out how to get darcsum working, it's even nicer!
01:08:50 <ivanm> Axman6: lol
01:08:59 <Baughn> dmwit: Squeak is the only thing I can think of. I just disagree with your assessment.
01:09:03 <rahuljosephgeorg> Wat's Swueak?
01:09:04 <ivanm> Axman6: the default language sucks, you need to use NQC or something to make it bearable
01:09:15 <Baughn> dmwit: It's too complicated and baroque to be helpful to newbies
01:09:43 <ivanm> click-and-play? *ducks*
01:09:46 <rahuljosephgeorg> ok so haskell is the best programming language for me?
01:09:56 <dmwit> Baughn: Ah, I meant Scratch, which is built on Squeak.
01:09:57 <ivanm> ... maybe...
01:09:59 <Baughn> rahuljosephgeorg: You're in #haskell. Of course we think it's the best one.
01:10:04 <Axman6> rahuljosephgeorg: tbh, probably not
01:10:04 <Baughn> rahuljosephgeorg: We might even be right
01:10:06 <ivanm> we're not biased at all!
01:10:12 <humasect> actually, squeak may be a better start after all.
01:10:21 <rahuljosephgeorg> squeak?
01:10:32 <ac> @go squeak language
01:10:35 <Axman6> rahuljosephgeorg: but learn haskell, and learn some useful stuff. making games might be hard, but you'll end up a better programmer
01:10:37 <humasect> it is very easy to use and get to know the whole deal about development
01:10:44 <humasect> and smalltalk is basically pure functional
01:10:45 <lambdabot> http://www.squeak.org/
01:10:45 <lambdabot> Title: Squeak Smalltalk
01:10:50 <rahuljosephgeorg> ok fine i go with haskell
01:11:03 <thoughtpolice> i still remember seeing videos of kids put in front of xerox machines back in the 80s to play with smalltalk, most found it fairly intuitive.
01:11:06 <dmwit> humasect: ...if by pure functional you mean object-oriented
01:11:07 <rahuljosephgeorg> so im downloading hugs right now
01:11:13 <humasect> dmwit: nope.
01:11:16 <rahuljosephgeorg> wat is winhugs?
01:11:19 <thoughtpolice> funny thing is the interface in the videos was amazingly similar to what squeak is today
01:11:26 <Baughn> rahuljosephgeorg: Hugs-for-windows
01:11:28 <mapreduce> rahuljosephgeorg: A build of hugs for Windows.
01:11:41 <rahuljosephgeorg> wat is hugs a compiler ?
01:11:44 <thoughtpolice> but I guess that just means 20 years of interface-refining...
01:11:46 <mapreduce> An interpreter.
01:11:46 <humasect> rahuljosephgeorg: two implementations of haskell mostly; hugs and ghc
01:11:56 <rahuljosephgeorg> oh
01:11:57 <ivanm> is this OneTuple library a joke?
01:12:05 <humasect> ghc is used most, rahuljosephgeorg
01:12:13 <rahuljosephgeorg> so wat do i need to learn the program wat software?
01:12:21 <thoughtpolice> from a purely practical point of view I would say if you go haskell, you need to go with GHC
01:12:29 <humasect> ivanm: could be a test for 6.10 base-4 package deps and such
01:12:32 <thoughtpolice> although nhc98 and hugs are great for getting haskell places it would be, um...
01:12:38 <thoughtpolice> 'difficult' to get GHC ;]
01:12:41 <humasect> @go haskellwiki
01:12:44 <lambdabot> http://www.haskell.org/haskellwiki/Haskell
01:12:44 <lambdabot> Title: Haskell - HaskellWiki
01:12:57 <humasect> there is a neat place for seeing code and stuff, rahuljosephgeorg
01:13:10 <rahuljosephgeorg> im downloading win hugs
01:13:12 <thoughtpolice> (actually I do believe nhc98 runs more programs from benchmarks like nofib than any other compiler excluding ghc)
01:13:14 <rahuljosephgeorg> is that all i ned
01:13:15 <ivanm> humasect: ummmm..... so the library is a _serious_ one?
01:13:18 <ivanm> rahuljosephgeorg: probably
01:13:25 <rahuljosephgeorg> ok
01:13:28 <rahuljosephgeorg> cool
01:13:29 <ivanm> at least to learn in initially
01:13:31 <humasect> ivanm: well, seriously for testing, perhaps.
01:13:36 * humasect looks
01:13:37 <ivanm> humasect: *nod*
01:13:42 <rahuljosephgeorg> winhugs?
01:13:47 <rahuljosephgeorg> it's about 14 mb
01:13:51 <rahuljosephgeorg> is that right
01:13:52 <rahuljosephgeorg> ?
01:14:08 <mapreduce> Probably.
01:14:12 <sjanssen> humasect: what makes you think onetuple is related to 6.10?
01:14:37 <Axman6> rahuljosephgeorg: while that's downloading, you might want to start having a look at http://www.haskell.org/tutorial/intro.html
01:14:38 <lambdabot> Title: A Gentle Introduction to Haskell: Introduction
01:14:45 <luqui> humasect, "smalltalk is basically pure functional"  -- strongly disagree
01:14:59 <ivanm> Axman6: IIRC, that isn't that "gentle"... wouldn't say YAHT be better?
01:15:00 <mapreduce> Smalltalk is *about* mutable data.
01:15:04 <ivanm> it's got nuclear waste!
01:15:10 <rahuljosephgeorg> k
01:15:16 <humasect> luqui: functions aren't first class, of course. but it is not imperative anyway.
01:15:18 <Axman6> ivanm: no idea, i never used any tutorials
01:15:36 <sjanssen> ivanm: there might be some use for this package, but I can't imagine what
01:15:36 <ivanm> heh
01:15:37 <luqui> humasect, "pure functional" means no side-effects.  smalltalk objects have all sorts of state
01:15:39 <humasect> sjanssen: ah, it's not =) i just thought it would be related to the issue of the newer base library breaking some programs, and hackagedb, and cabal, and stuff.
01:15:40 <mapreduce> humasect: How does it work then, when you call a method on an object?
01:15:45 <ivanm> you just absorbed haskell by osmosis, did you Axman6?
01:15:46 <rahuljosephgeorg> which is rhe nest place to learn haskell?
01:15:47 <luqui> that's why it was impossible for me to program in squeak...
01:15:49 <rahuljosephgeorg> which is rhe nest place to learn haskell?
01:15:50 <humasect> hehe
01:15:51 <EvilRanter> "A variable is assigned a value via the ':=' syntax."
01:15:52 <Axman6> ivanm: uni
01:15:54 <EvilRanter> ^ it's imperative
01:16:02 <humasect> rahuljosephgeorg: right here
01:16:07 <ivanm> sjanssen: yeah, I can't either... I havent' actually looked at it though
01:16:09 <rahuljosephgeorg> i mean best place to learn haskell
01:16:21 <humasect> yes, right here.
01:16:24 <ivanm> @where wikibook
01:16:24 <lambdabot> http://en.wikibooks.org/wiki/Haskell
01:16:26 <rahuljosephgeorg> right here?
01:16:33 <luqui> rahuljosephgeorg, in IRC
01:16:34 <mapreduce> I found the wikibook good.
01:16:39 <humasect> yep. you are here, already starting to learn it
01:16:40 <luqui> we are a great resource once you get going
01:16:41 <sjanssen> ivanm: "data OneTuple a = OneTuple a", plus one function and a bunch of instances
01:16:42 <mapreduce> And realworldhaskell.
01:16:50 <Axman6> rahuljosephgeorg: this might be good: http://lisperati.com/haskell/
01:16:57 <dmwit> sjanssen: any different than Id?
01:17:00 <EvilTerran> sjanssen, isn't that usually called Id?
01:17:03 <Baughn> rahuljosephgeorg: Of course we can't explain everything, but if you get stuck on something..
01:17:13 <glguy> Alan Hawkins writes: I made an hpaste search: http://gsarchives.net/pikadude/search.html
01:17:19 <sjanssen> dmwit, EvilTerran: isn't Id usually a newtype?  So that is one difference
01:17:23 <ivanm> sjanssen: about what I figured
01:17:24 <rahuljosephgeorg> ok what command to display text?
01:17:26 <rahuljosephgeorg> ok what command to display text?
01:17:29 <EvilTerran> calm down
01:17:38 <humasect> hehe
01:17:38 <luqui> I actually owe OneTuple a great debt, since it just taught me that [fmap f = OneTuple . f . only] is *not* a correct instance.
01:17:41 <jeffz> rahuljosephgeorg: stop repeating
01:17:42 <EvilTerran> we need more context
01:17:44 <dmwit> rahuljosephgeorg: Please figure out how to stop repeating yourself.
01:17:45 <humasect> > putStrLn "hello rahul"
01:17:46 <lambdabot>   * Exception: "<IO ()>"
01:17:52 <ivanm> heh
01:17:53 <humasect> awesome
01:17:54 <rahuljosephgeorg> aorry
01:18:07 <EvilTerran> sjanssen, iirc, monadLib's Id is a data
01:18:16 <rahuljosephgeorg> ok
01:18:24 <Baughn> rahuljosephgeorg: Have you got winhugs running?
01:18:28 <sjanssen> EvilTerran: nope, newtype
01:18:32 <rahuljosephgeorg> not yet
01:18:36 <glguy> There is Lift and Id
01:18:43 <Axman6> rahuljosephgeorg: forget about displaying text for now. it's actually kinda hard in haskell (for various reasons you'll find out about in the furure)
01:18:44 * EvilTerran gets back from checking
01:18:47 <Axman6> future*
01:18:48 <EvilTerran> ah, yeah, my bad
01:18:57 <Baughn> Axman6: Eh, I wouldn't call it "hard"
01:18:59 <sjanssen> okay, so OneTuple == Lift
01:19:13 <ac> Axman6: what's so hard about: main = putStrLn "hello" -- ? :-P
01:19:13 <Axman6> Baughn: i would. stfu :'(
01:19:17 <glguy> Lift is the strict one
01:19:17 <EvilTerran> ski, i got confused because the docs said Lift is strict (and implied Id isn't)
01:19:19 <luqui> aka Box by some
01:19:20 <Baughn> rahuljosephgeorg: And winhugs will echo back whatever you throw at it, so to have it print "foo", just write in "foo"
01:19:25 <EvilTerran> er, s/ski/sjanssen/
01:19:26 <glguy> Id is the lazy one
01:19:29 <dolio> Hey, OneTuple has an Applicative instance.
01:19:44 <Baughn> rahuljosephgeorg: ..well, of course it only gets interesting when you do something more than just echo the text
01:19:47 <dolio> That makes it better than Identity from mtl. :)
01:19:53 <ac> > OneTuple 1
01:19:55 <lambdabot>   Not in scope: data constructor `OneTuple'
01:20:04 <sjanssen> "data Lift a               = L a" "newtype Id a              = I a"
01:20:12 <thoughtpolice> there can only be OneTuple to rule them all.
01:20:14 <luqui> > (["hello"], id) <*> (["world"], 42)
01:20:15 <lambdabot>   (["hello","world"],42)
01:20:16 <rahuljosephgeorg> ok then wat's easy in haskell?
01:20:27 <rahuljosephgeorg> if text is hard?
01:20:31 <luqui> rahuljosephgeorg, NOTHING, mwahahahaha
01:20:33 <humasect> > (4,4) <*> (4,5)
01:20:34 <lambdabot>       No instance for (Num (a -> b))
01:20:34 <lambdabot>        arising from the literal `4' at <...
01:20:34 <EvilTerran> sjanssen, yeah, i see that. i guess the strict/non-strict thing's done in the monad instance, not the type
01:20:43 <EvilTerran> rahuljosephgeorg, text is easy, it's IO that's a little harder
01:20:47 <Axman6> :t (<*>)
01:20:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:20:50 <humasect> :t (<*>)
01:20:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:20:55 <humasect> ah right.
01:21:06 <EvilTerran> > unwords . map reverse . words $ "Text is really quite easy, honest."
01:21:07 <lambdabot>   "txeT si yllaer etiuq ,ysae .tsenoh"
01:21:15 <Baughn> rahuljosephgeorg: The larger your program gets, the simpler it gets, relative to other languages. Simple things can be hard (until you get the hang of them); hard things will be simple.
01:21:16 <humasect> rahuljosephgeorg: squeak is more graphics , haskell is more text
01:21:23 <Axman6> text is fine, IO is not so fine
01:21:24 <luqui> In fact, text with interact is a great way to get started
01:21:26 <rahuljosephgeorg> c u guys later thx for the help
01:21:30 <Baughn> rahuljosephgeorg: Overall, you'll do more hard things than simple things.
01:21:32 <humasect> rahuljosephgeorg: be well
01:21:33 <EvilTerran> rahuljosephgeorg, Project Euler is easy!
01:21:34 <EvilTerran> do
01:21:35 <EvilTerran> h
01:21:40 <glguy> e
01:21:58 <dmwit> I still can't shake the feeling he was putting us on.
01:22:01 <Baughn> ..I really wish people would stop claiming IO is hard. It isn't. It's the absolutely simplest monad. ;_;
01:22:06 <sjanssen> EvilTerran: right, they're written that way because pattern matching on a newtype is a no-op, making it lazy
01:22:35 <sjanssen> dmwit: yeah, I wonder
01:22:42 <humasect> Baughn: it might be the mixing between monadic and non, that one needs to find the delicate balance of , at first
01:22:48 <luqui> Baughn, that was a joke right?
01:22:55 <Axman6> Baughn: i haven't found that so. it may be for you, it's not for many others
01:23:08 <dmwit> I also think IO is not so hard.
01:23:09 <sjanssen> we probably shouldn't have recommended Haskell to him -- Haskell is not the language where you'll have a game in one night of learning
01:23:11 <luqui> IO is hard because it's quite unlike IO in other languages
01:23:26 <EvilTerran> sjanssen, it seems to me that they could both be newtypes, and the strict/non-strict-ness could be dealt with in the definition of >>=
01:23:37 <humasect> sjanssen: squeak is meant for that very kind of person/intent =)
01:23:40 <Baughn> luqui: But he doesn't /know/ any other languages
01:23:44 <EvilTerran> seeing as it's not "data Lift a = L !a
01:23:45 <EvilTerran> "
01:23:48 <jeffz> sjanssen: but writing games isn't about producing something quickly though, it's about understanding the problem domain and writing a program that solves it nicely
01:23:53 <EvilTerran> er, extraneous newlines <.<  >.>
01:23:56 <luqui> oh... Oh.... yikes.  Or maybe awesome.  I don't know.
01:24:12 <Baughn> luqui: Usually a good thing. :P
01:24:17 <luqui> I have always wondered if Haskell would be a good beginning language; everyone I know was already an advanced programmer when they started learning it.
01:24:26 <thoughtpolice> jeffz: which is not something someone who's just starting is likely to understand
01:24:32 <luqui> and that's when it's hard, because it is not very close to existing languages
01:24:36 <ac> sjanssen: like everyone said, starting with Haskell will make one a better programmer. Worst case is he gives up and goes and learns a different language
01:24:39 <thoughtpolice> i admit,
01:24:43 <ac> sjanssen: then maybe coming back to it later
01:24:48 <sjanssen> ac: he didn't say he wanted to be a programmer
01:24:53 <EvilTerran> luqui, i think, if haskell was someone's first language, they'd become a good haskell programmer a lot quicker, but find learning otherlanguages more painful
01:24:59 <thoughtpolice> 90% of my haskell experience intially involved a lot of *un*learning
01:25:16 <Baughn> luqui: I mentioned earlier, I've taught haskell to some people as a first language. It seems to be easier than most others - definitely easier than C and such things.
01:25:22 <humasect> EvilTerran: hm, yeah
01:25:23 <luqui> jeffz, I'd say writing games for the beginner is getting your hands dirty and hacking all sorts of crap together so you can see what happens when you change something.
01:25:37 <EvilTerran> "learning C, learning C... hey, FreeNode#c, how do i do anonymous functions?"
01:25:39 <dolio> There's no language where you can bang out an MMO game overnight with no previous programming experience.
01:25:51 <luqui> EvilTerran, most certainly, because I was a good programmer until I learned haskell, now I find other languages more painful :-)
01:25:59 <sjanssen> dolio: hmm, given sufficient library support ...
01:26:04 <thoughtpolice> :t makeAwesomeMMO
01:26:05 <lambdabot> Not in scope: `makeAwesomeMMO'
01:26:09 <dolio> Heh.
01:26:12 <thoughtpolice> :'[
01:26:18 <EvilTerran> :t makeAMillionDollars
01:26:20 <lambdabot> Not in scope: `makeAMillionDollars'
01:26:22 <dolio> Well, if you're going to give that, then any language can do it. :)
01:26:39 <Japsu> makeAwesomeMMO :: IO () -- serious social and economical side-effects
01:26:39 <dolio> We should have recommended Arc.
01:26:44 <luqui> dolio, sure.  just using an existing mmo with a mod community...
01:26:44 <thoughtpolice> :t makeEvaMendez
01:26:45 <lambdabot> Not in scope: `makeEvaMendez'
01:26:48 <EvilTerran> ... i take it lambdabot doesn't import US.FederalReserve, then
01:27:19 <luqui> Japsu, that function's name does not match its type.  Shouldn't it be makeAwesomeMMO :: IO MMO
01:27:28 <thoughtpolice> :t hackTheGibson -- US.Pentagon imported?
01:27:29 <lambdabot> Not in scope: `hackTheGibson'
01:27:40 <Japsu> luqui: yeah, why not
01:27:44 <EvilTerran> thoughtpolice, that one's unsafeHackTheGibson
01:28:06 <Axman6> the gibson?
01:28:19 <thoughtpolice> i propose a function named unsafeBlowShitUp because it would be totally awesome
01:28:26 <EvilTerran> Axman6, it's a Hackers reference
01:28:43 <luqui> thoughtpolice, what are its semantics?
01:28:45 <dolio> You need to watch Hackers immediately.
01:28:54 <dmwit> thoughtpolice: You should totally make a library addition petition, I'll support you.
01:29:04 <Axman6> i do...
01:29:14 <EvilTerran> luqui, you call it, and shit blows up. obviously.
01:29:22 <luqui> EvilTerran, what do you mean "call"?
01:29:32 <luqui> =P
01:29:32 <EvilTerran> ok, run it as an IO action
01:29:35 <thoughtpolice> just think of it as all the bad things out of the bible
01:29:39 <thoughtpolice> all at once
01:29:47 <luqui> oh, unsafeBlowShitUp :: IO ().  I thought it would be a pure function...
01:29:49 <dolio> Hackers 2 is an amusing pass time, too, although it's totally different.
01:30:12 <dmwit> luqui: It's unsafe for reasons totally unrelated to referential transparency.
01:30:26 <Liempt> :t (flip map .) . enumFromTo
01:30:27 <lambdabot> forall a b. (Enum a) => a -> a -> (a -> b) -> [b]
01:30:36 <Liempt> Thanks, lambdabot
01:30:42 <EvilTerran> god's done an unsafePerformIO blowShitUp, that's why everyone's really confused about when the end of the world's due
01:30:43 <dmwit> ?botsnack
01:30:43 <lambdabot> :)
01:30:56 <luqui> on a more serious note, I often prefix names with unsafe if they break the semantic abstraction I'm making.
01:31:01 <Axman6> luqui: pure as in purify the earth?
01:31:16 <luqui> Axman6, heehee
01:31:48 <luqui> unsafeHolocaust :: IO (Jew -> False)
01:31:56 <thoughtpolice> another addition I propose - makeAwesome :: IO (), similar to unsafeBlowShitUp, but with ninjas and xmen fighting santa claus while evil kinevel is jumping around with rambo hanging off tires killing everything
01:31:57 <EvilTerran> then there's safeBlowShitUp
01:32:00 <luqui> okay, woah, abort.
01:32:03 <thoughtpolice> bruce willis might be able to fit in there, too
01:32:19 <EvilTerran> mythBusters = safeBlowShitUp >> mythBusters
01:32:29 <thoughtpolice> oh and cyclops dinosaurs
01:32:36 <thoughtpolice> with laser vision
01:32:37 <Axman6> luqui: ^C^C^C^C!
01:32:40 <Xenoblitz> hi guys... quick question... is there something like !! or fst/snd for tuples?
01:32:42 <luqui> or more readably:  mythBusters = forever safeBlowShitUp
01:32:46 <thoughtpolice> the ultimate function
01:32:55 <EvilTerran> Xenoblitz, not for tuples in general, no
01:33:04 <EvilTerran> use pattern-matching
01:33:12 <Axman6> Xenoblitz: fst and snd?
01:33:15 <Xenoblitz> i mean sorry something more generic than fst/snd
01:33:24 <EvilTerran> Xenoblitz, it'd be possible to hack it with Data.Generics or Template Haskell
01:33:41 <Xenoblitz> hmmm nah ok I will work around it i guess
01:33:47 <Xenoblitz> thanks all the same EvilTerran
01:33:50 <quicksilver> Xenoblitz: the funny thing is, YAGNI.
01:33:51 <quicksilver> ;)
01:33:59 <humasect> just stuff like tup n = case n of { 0 -> (a,_,_) .. w/e
01:34:07 <Xenoblitz> Axman6: fst takes the first item in a tuple and snd the second
01:34:12 <EvilTerran> nth l n = lam1E (tupP [if i == n then varP (mkName "a") else wildP | i <- [0..l-1]]) $ varE (mkName "a")
01:34:16 <luqui> or rather, like subtyping, YSLNTNI
01:34:21 <EvilTerran> Xenoblitz, there's a Template Haskell function
01:34:27 <Axman6> Xenoblitz: i know what they do
01:34:59 <luqui> maybe spelled YOTLNTNI, sounds like a yodel
01:35:02 <EvilTerran> Xenoblitz, it'd work as: $(nth 4 2) (a,b,c,d) = c
01:35:08 <EvilTerran> (0-based indexes)
01:35:20 <Xenoblitz> cool thanks
01:35:23 <Xenoblitz> I'll look it up
01:35:24 <Xenoblitz> :)
01:35:42 <EvilTerran> Xenoblitz, look it up? er, look up the screen :P
01:35:48 <luqui> Xenoblitz, for what it's worth, 4 and 2 above cannot be runtime values, they have to be constants at compile time.
01:35:49 <EvilTerran> it's something i wrote myself
01:35:56 <humasect> Xenoblitz: <EvilTerran> nth l n = lam1E (tupP [if i == n then varP (mkName "a") else wildP | i <- [0..l-1]]) $ varE (mkName "a")  <- that's the function=)
01:36:43 <EvilTerran> yes
01:36:51 <EvilTerran> horrible, isn't it? :P
01:37:00 * humasect doesn't know TH well
01:37:12 <EvilTerran> , listify
01:37:13 <lunabot>  luna: No instance for (GHC.Show.Show ((r -> GHC.Bool.Bool) -> a -> [r]))
01:37:13 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-57
01:37:13 <lunabot>  Possible fix:
01:37:16 <EvilTerran> aha
01:37:26 <EvilTerran> , listify (const True) (1,2,3,4)
01:37:29 <lunabot>  []
01:37:31 <EvilTerran> hm
01:37:40 <Xenoblitz> yeah it is kind of scary hehe
01:37:52 <EvilTerran> TH isn't always that bad
01:38:03 <EvilTerran> it's just hard to manipulate tuples in haskell, and that carries over to TH too
01:38:18 <EvilTerran> a curried version would be a lot easier on the eye
01:38:21 <ac> luqui: YSLNTNI?
01:38:23 <Saizan_> , listify (const True) (1,2,3,4) :: [Integer]
01:38:25 <lunabot>  [1,2,3,4]
01:38:41 <luqui> ac, I was wondering if someone would ask.  "you should learn not to need it" :-)
01:38:55 <ac> luqui: ah I should've guessed that from the context
01:39:19 <luqui> :t listify
01:39:20 <lambdabot> forall r a. (Typeable r, Data a) => (r -> Bool) -> a -> [r]
01:40:16 <Xenoblitz> its just that i a function (b,c) and it calls a function which returns (a,b,c)
01:40:16 <Xenoblitz> *that i have
01:40:22 <luqui> , listify (const True) [1,2,3]    --
01:40:23 <lunabot>  luna: parse error (possibly incorrect indentation)
01:40:23 <Xenoblitz> i need to remove one of the results and return it
01:40:28 <luqui> , listify (const True) [1,2,3]
01:40:30 <lunabot>  []
01:40:31 <EvilTerran> Xenoblitz, could your function return (a,(b,c)) instead?
01:40:42 <Liempt> :t flip flip id . (ap .) . join . (flip .) . flip flip "> %s %s\n" . (flip .) . flip flip printf . (flip .) . flip (do hPrintf) "%s %s\r\n"
01:40:43 <lambdabot>     No instance for (PrintfArg (String -> r))
01:40:43 <lambdabot>       arising from a use of `hPrintf' at <interactive>:1:116-122
01:40:43 <lambdabot>     Possible fix:
01:40:45 <EvilTerran> , listify (const True) [1 :: Int,2,3] :: [Int]
01:40:47 <lunabot>  [1,2,3]
01:41:00 <EvilTerran> , listify (const True) [1 :: Int,2,3] :: [()] -- this is what the defaulting is making it
01:41:01 <Xenoblitz> not a bad idea
01:41:01 <Xenoblitz> i'll give it shot
01:41:02 <lunabot>  luna: parse error (possibly incorrect indentation)
01:41:04 * luqui is perplexed
01:41:05 <EvilTerran> doh
01:41:24 <Xenoblitz> yeah i get lost into such simple haskell stuff which are not found in other languages
01:41:26 <Xenoblitz> bear with me plz ^^
01:41:29 <luqui> lunabot, learn what a comment is!
01:41:30 <EvilTerran> Xenoblitz, in a perfect world, all haskell tuples would be built up from pairs, IMO
01:41:40 <EvilTerran> well, snd-strict pairs and ()
01:41:46 <Xenoblitz> i can't cause of the fold
01:41:48 <Xenoblitz> i am using
01:41:53 <Xenoblitz> i need tuples
01:41:54 <mapreduce> Oh, rahuljosephgeorg left.  It was just getting fun.
01:42:01 * luqui again mentions his desire for unlifted tuples.
01:42:30 * luqui wonders if IRC is too overwhelming for some people
01:43:15 * EvilTerran would like (x1, x2, ..., xN) to be syntactic sugar for (x1 :*: x2 :*: ... :*: xN :*: ()), where data x :*: xs = x :*: !xs
01:43:19 * BMeph prefers last to snd
01:43:27 <EvilTerran> it'd allow all sorts of clever things with typeclasses
01:43:55 <EvilTerran> (i might need an infixr :*: in there)
01:45:15 <quicksilver> there are lots of cool things which you might imagine doing with tuples and a slightly better type formulation
01:45:22 <quicksilver> but in my experience you really don't need it.
01:45:25 <quicksilver> ;)
01:46:58 <Deewiant> argh, System.Process revamp is now "beyond 6.10"
01:47:14 <quicksilver> the first version of the revamp is in 6.10.
01:47:23 <quicksilver> JaffaCake's first pass is already committed and present.
01:47:27 <Deewiant> oh, it is? yaaay
01:47:34 <luqui> what is in said revamp?
01:47:44 <Deewiant> well, Pipe depends on it :-P
01:47:49 <quicksilver> more control about launching subprocesses with existing fds, etc.
01:48:20 <Deewiant> so I guess I could solve unmarshal's problem by telling him to get 6.10, as well
01:48:35 <luqui> quicksilver, do you remember that quote about darcs, something like "we didn't realize how much we needed branching until we had it"
01:48:40 <Deewiant> quicksilver: do you know the version number used there?
01:49:22 <Deewiant> ah, darcs.haskell.org has ghc, never mind, I can look it up
01:49:35 <luqui> quicksilver, after using coq which can do everything I feel like it should be able to (as long as I help the compiler when it needs help), I kind of don't buy "you don't really need it" anymore
01:50:20 <luqui> because a missing capability is a missing abstraction, which is a missing library which could be built on that abstraction
01:51:35 <quicksilver> haskell doesn't have EnterpriseFactoryFactoryFactories either
01:51:38 <quicksilver> that's a missing abstraction
01:51:41 <quicksilver> but I don't miss it.
01:51:48 <luqui> not to say that haskell should be coq.
01:52:04 <luqui> or that it should be able to do everything I feel like it should be able to do
01:52:15 <luqui> just that "you don't really need it" is not a good reason to dismiss a feature.
01:52:34 <luqui> because how do you know if you need it if you don't have it?
01:52:44 <osfameron> then again, if you added a feature every time you thought you might need it, you'd end up with perl 6
01:52:51 <osfameron> or not, as the case may be
01:52:52 <quicksilver> because I am perceptive enough to know when I'm programming that I've hit an abstraction barrier
01:52:57 <quicksilver> or missing feature
01:53:27 <luqui> quicksilver, well, you might be.  but what might oleg do with such a feature?
01:53:33 <quicksilver> a classic abstraction barrier than I hit in haskell is the inability to abstract over record names.
01:53:52 <quicksilver> luqui: we're not talking about new language features, just a new library.
01:53:58 <quicksilver> the language already supports generalised tuple abstractions
01:54:01 <quicksilver> (see HList)
01:54:05 <quicksilver> (which is what oleg already did)
01:54:32 <luqui> ah, right, we were talking about tuples
01:54:39 <luqui> I guess it's not hard to get those right in a library
01:54:50 <quicksilver> but, nonetheless, you probably don't need it.
01:54:53 <luqui> it's just the syntax support which is missing, which is a minor annoyance, but ...
01:54:56 <quicksilver> which was my message to Xenoblitz.
01:55:26 <luqui> so you're saying that instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (a,b,c,d,e,f,g) is fine?
01:55:27 <Saizan_> i keep getting in situations where i miss proper support for extensible records
01:55:32 <quicksilver> I could express it more concisely as "whichever problem you thought you were solving with generalised tuples, I bet I can solve neatly enough without"
01:55:33 <luqui> which appears in the standard library?
01:56:04 <quicksilver> luqui: I can't say it bothers me much. 'deriving Eq' is the compiler's business. I don't care how it does it.
01:56:30 <quicksilver> the report's state rule for how to derive Eq applies fine to tuples.
01:56:54 <luqui> but isn't Haskell 98 missing instances for tuples above some finite number?
01:57:21 <luqui> I seem to recall that Eq instances on arbitrary length tuples is a ghc thin
01:57:22 <luqui> g
01:57:26 <quicksilver> it doesn't guarantee them above some finite number.
01:57:39 <luqui> I'm not saying that I ever use such large tuples.
01:57:40 <quicksilver> but that's OK, because you never[*] need to use tuples bigger than 3 or 4.
01:57:49 * luqui never uses tuples bigger than 2.
01:57:50 <quicksilver> which is my real point to xenoblitz.
01:57:53 <luqui> ah okay
01:57:54 <quicksilver> * well almost never.
01:58:25 <quicksilver> I use 3 or 4 tuples for custom syntax sometimes
01:58:30 <quicksilver> like event dispatch tables
01:58:44 <quicksilver> [(CommandName,CommandAction,CommandHelpText)]
01:58:52 <quicksilver> say.
01:59:27 <luqui> ah.   for syntax I'd probably end up using (CommandName, (CommandAction, CommandHelpText)) so it would be easy to make up some local infix operators for readability
02:00:00 <luqui> For verbatim lists, I hate those parens around tuples, I usually do something like "where (-->) = (,)"
02:00:18 <jeffz> not (CommandName, [(CommandAction, CommandHelpText)])?
02:00:40 <luqui> multiple actions and helptexts?
02:01:05 <quicksilver> luqui: can't say the parens bother me in that context. But point taken.
02:01:23 <jeffz> i guess it's irrelevant
02:01:35 <quicksilver> luqui: the point really is that cleverer language support for generalised / larger tuples is not a big problem
02:01:40 <quicksilver> the cost/benefit ration is poor.
02:01:51 <luqui> uh.  the cost is very low.
02:01:57 <luqui> so you're right :-)
02:02:14 <luqui> (the cost is high in haskell, but low in a new language)
02:03:20 <Saizan_> > let (<--) = (,,); (-->) = ($) in a <-- b --> c
02:03:21 <lambdabot>   (a,b,c)
02:03:57 <luqui> Saizan_, yeah that works.  a bit too subtle for me :-)
02:04:22 <luqui> but point taken.
02:04:24 <osfameron> is every one of (,) (,,) (,,,) etc. a separate funtction?
02:04:31 <Saizan_> yes
02:05:00 <quicksilver> osfameron: that's kind of the point we're discussing
02:05:08 <papermachine> > :t (,,)
02:05:09 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
02:05:09 <lambdabot>  ...
02:05:16 <quicksilver> osfameron: that tuples aren't "uniform" in any way apparent to the language itself.
02:05:19 <Saizan_> :t (,,)
02:05:20 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
02:05:32 <quicksilver> osfameron: but, my personal view is that although that is an abstraction hole, it's not one that matters.
02:06:09 <osfameron> ok
02:06:22 * luqui agrees, mostly because the only thing missing is syntax support.  if it were impossible to express generalized tuples whatsoever, then I would consider it a larger problem
02:06:40 <luqui> see eg. C.  :-)
02:08:44 <Saizan_> OT, how do you force an application inside screen to adapt to the changed terminal size?
02:08:54 <luqui> infixr 9 :, ; data Tuple a b = a :, !b ;  (1 :, "jerkey" :, id :, ())
02:09:19 <luqui> oh, :, isn't a valid operator :-(
02:09:20 <Baughn> Saizan_: C-l?
02:09:44 <Saizan_> Baughn: no luck
02:11:53 <quicksilver> Saizan_: if the application doesn't respect SIGWINCH
02:11:58 <quicksilver> Saizan_: then, you're out of luck.
02:15:17 <Saizan_> quicksilver: it happens with emacs and irssi.. but i've just installed a fresh system, so i guess it's a problem with the terminal
02:21:59 <quicksilver> Saizan_: emacs and irssi both respect WINCH
02:22:09 <quicksilver> Saizan_: so it's a problem with your terminal, I image.
02:22:18 <quicksilver> detaching and re-attching screen is a workaround worth trying.
02:23:43 <Baughn> Saizan_: What terminal are you using, anyway?
02:24:43 <Saizan_> urxvt
02:26:22 <Baughn> Saizan_: What version? There used to be a bug like that, but unless you're using debian it shouldn't be an issue
02:27:16 <Saizan_> rxvt-unicode (urxvt) v9.05 - released: 2008-06-15, i'm on archlinux
02:27:26 <EvilTerran> luqui, i know, annoying, isn't it?
02:27:34 * sjanssen was trying to upgrade Ubuntu, from the logs: AttributeError: 'DistUpgradeQuirks' object has no attribute 'cache'.  Dynamic typing fail
02:28:30 <Baughn> Saizan_: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=392870 <-- This bug/behaviour might be relevant, arch or not
02:28:33 <lambdabot> Title: #392870 - aptitude: SIGWINCH block is inherited by installed package processes - ...
02:29:14 <EvilTerran> luqui, seeing as the only ambiguities would be in (,) and the like (avoided by requiring at least one non-, character in an operator) and with the comma in infix declerations (avoided by taking those commas out, they look really weird anyway)
02:29:20 <sjanssen> Saizan_: you're probably seeing a Linux kernel bug (very FAQ in #xmonad)
02:30:25 <sjanssen> Saizan_: I think 2.6.27 is the broken version, the pty code sends SIGWNCH before updating the dimensions of the pty
02:30:46 <quicksilver> EvilTerran: what do you mean about the comma in infix declarations?
02:31:08 <Saizan_> sjanssen: uname -r == 2.6.26-ARCH, so it might be that
02:31:20 <sjanssen> Saizan_: maybe thats the version, I don't remember
02:31:29 <EvilTerran> quicksilver, i mean, if you allowed commas in operators, the comma in infix declerations would cause trouble
02:31:51 <sjanssen> Saizan_: yep, http://kerneltrap.org/mailarchive/linux-kernel/2008/8/10/2884104/thread
02:31:58 <quicksilver> which comma in infix declarations are you talking about?
02:32:03 <lambdabot> Title: TIOCGWINSZ retuns old pty size after receiving SIGWINCH | KernelTrap, http://tinyurl.com/52tasf
02:32:06 <EvilTerran> "infix *, +"
02:32:07 <EvilTerran> kinda thing
02:32:09 <quicksilver> ah.
02:32:11 <quicksilver> there is also
02:32:14 <quicksilver> f,g::Int
02:32:18 <EvilTerran> that comma looks really weird to me, so i'd want rid of it anyway
02:32:31 <EvilTerran> spaces would work fine
02:32:40 <luqui> quicksilver, again fixed by having at least one non-comma character in an operator
02:32:53 <luqui> s/having/requiring/
02:33:10 <zi> hello
02:33:11 <luqui> it's not that annoying.  After all, I have unicode :-)
02:33:40 <EvilTerran> quicksilver, anyway, that's a decleration, and "f `op` g :: Type" is an expression, so that'd be unambiguous anyway
02:33:44 <EvilTerran> (i think)
02:34:23 <quicksilver> I think it's OK because you need () around infix ops, in type declarations.
02:34:28 <EvilTerran> operators in :: declerations have to be wrapped in parentheses, so any ,s in those wouldn't get confused in the... yeah.
02:34:33 <quicksilver> but it's another use o comma which might be confusing ;)
02:34:50 <EvilTerran> i just want to have data x :, xs = x :, !xs :P
02:35:51 * quicksilver nods
02:36:04 <sjanssen> > map ($ []) [x :, id]
02:36:04 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
02:36:05 <lambdabot>  ...
02:36:15 <luqui> I actually dislike the type punning of tuples at the type level
02:36:27 <luqui> i.e. the type of (1,2) being (Int,Int).
02:36:39 <luqui> to me (Int,Int) is itself a tuple of types
02:36:40 <Saizan_> sjanssen: so they usually solve this by installing a 2.6.27 release candidate?
02:36:43 <quicksilver> I think [a] is worse.
02:36:49 <luqui> definitely
02:36:55 <quicksilver> it's not even the same arity ;)
02:37:17 <sjanssen> Saizan_: I've never asked.  I suppose you can either upgrade or downgrade
02:38:32 <luqui> sjanssen, I think that is a ghc misfeature
02:39:01 <EvilTerran> luqui, i think it's a better solution than ML's weird behaviour of * at the type level
02:39:11 <EvilTerran> a * b * c /= a * (b * c)
02:39:25 <EvilTerran> they're isomorphic, yes, but they're still different
02:39:53 <luqui> oh, it's a "listfix" operator (as they said in the perl world)
02:40:04 <EvilTerran> yeah
02:40:37 <EvilTerran> listfix means adding or removing parentheses changes the meaning, that makes me wince
02:40:41 <luqui> the purist in me wants not to be able to write operators without parens unless it's truly associative
02:40:52 <luqui> but then I would miss out on a -> b -> c
02:41:12 <EvilTerran> while haskell's tuple constructors are ok, because removing the parentheses causes an error instead of different behaviour
02:41:37 <EvilTerran> imo
02:41:44 * EvilTerran wanders off
02:41:59 <mapreduce> luqui: How would the compiler verify associativity?
02:42:35 <quicksilver> luqui, sjanssen : a misfeature which has been fixed in 6.10, no less.
02:42:56 <luqui> mapreduce, well, practically it wouldn't.  it would just be a personal convention
02:43:26 <luqui> mapreduce, ideally, you could prove it :-)   but despite how much I talk about it, I actually don't want haskell to have dependent types
02:44:04 <mapreduce> Ah.
02:44:57 <mapreduce> So, the compiler wouldn't treat a function labelled associative any differently/
02:44:58 <mapreduce> ?
02:45:19 <cjs> What was the trick one uses to find out where head or undefined or whatever is blowing up in your program?
02:45:48 <luqui> mapreduce, in which case?    In the conventional case, I wouldn't define an operator to be infixl or infixr unless it were associative (instead preferring the nonassoc infix)
02:46:21 <mapreduce> Nevermind, I'm not qualified to discuss this.
02:46:22 <luqui> and in cases where it is associative, there might be a reason to prefer one over the other (take (++) for example)...
02:46:33 <quicksilver> cjs: (a) don't use head (b) don't use undefined :P
02:47:03 <cjs> I wasn't I thought. And as it turned out, I throught right on that score. Where I went wrong was in believing that I'd recompiled the changed file. :-)
02:47:18 <luqui> mapreduce, I wouldn't call it terribly technical (or important).  I'm just using standard haskell jargon, can rephrase if you like.
02:54:17 <zi> i like cookies
02:54:48 <opqdonut> what's your favourite sort?
02:54:56 <zi> vanilla cookies
02:55:10 <zi> with chocolate
02:55:16 <zi> chip
02:55:21 <mapreduce> luqui: I would just generally be wary of providing nice syntax for a non-proven property, as that encourages people to declare that property everywhere.
02:55:32 <sjanssen> cjs: you can try the ghci debugger
02:55:42 <zi> along with a carrot
02:56:01 <mapreduce> luqui: But I don't know enough about this case to even tell whether that's what you're thinking about.
02:57:41 <luqui> oh.  I was just saying that I would prefer not to be able to write  foo ++ bar ++ baz if (foo ++ bar) ++ baz /= foo ++ (bar ++ baz)
02:58:45 <luqui> but proving that is a little over the top for day-to-day programming
02:59:06 <BONUS> well you can write 5 / 3 / 3
02:59:19 <BONUS> and / is only left associative
02:59:37 <luqui> BONUS, indeed, and you can also write xs !! 1 !! 2
02:59:52 <ivanm> now _that_ looks weird...
02:59:56 <luqui> and you can also write f $ g $ x
02:59:58 <ivanm> I take it x :: [[a]] ?
03:00:04 <luqui> those are the things I prefer not to do
03:00:10 <luqui> (including the (/) example)
03:00:20 <luqui> ivanm, yes
03:00:35 <ivanm> I have no problem with f $ g $ x ... though I usually write f $ g x
03:01:01 <BONUS> yeah, i only do stuff like that when it's really well known which way the associativity points
03:01:01 <luqui> this associativity thing is actually what caused me to start writing f . g $ h x instead of f $ g $ h x
03:01:10 <BeelsebobWork> ivanm: I think I'd write f . g $ x
03:01:17 <osfameron> for me it was the sheer noisiness of $
03:01:17 <BONUS> i usually do f . g $ x or f $ g x if i only have 2 functions
03:01:30 <quicksilver> fully associative operators have more subexpressions.
03:01:34 <luqui> right of course, it was just an example...
03:01:36 <quicksilver> which helps refactoring, which is nice.
03:01:47 <Cale> yay! :)
03:01:48 <Cale> hehe
03:01:52 <ivanm> BeelsebobWork: typically, if I have multiple functions .'d together, I normally let the last one apply directly to the function
03:02:06 <ivanm> if only because it kinda looks like the last one does nothing
03:02:19 <BeelsebobWork> ivanm: any particular reason -- that to me breaks the reason why the (.) between stuff notation is so nice
03:02:32 <luqui> I'm actually starting to ponder whether there are serious advantages of doing most things the "categorical" way, expressing everything in terms of composition
03:02:34 <BeelsebobWork> the reason for me to put (.) between the functions instead of ($) is that it builds a function
03:02:35 <BeelsebobWork> then applies it
03:02:55 <ivanm> BeelsebobWork: I just find that a . b . c . d $ e x looks nicer usually than a . b . c . d . e $ x
03:03:20 <ivanm> mainly because the "$ x" looks useless on the end
03:03:24 <BeelsebobWork> ivanm: tbh, I think in that case I'd do let f = a . b . c . d . e in f x
03:03:31 <Cale> hehe :)
03:03:35 <BONUS> depends on the function
03:03:43 <BeelsebobWork> (if I can think of a name for f)
03:03:44 <ivanm> only time I don't is if I have some kind of duality: e.g.: f a . f b $ x
03:03:47 <BONUS> i wouldn't write zip xs . tail $ xs
03:03:48 <ivanm> heh
03:03:52 <ivanm> normally I can't
03:03:58 <Deewiant> zip`ap`tail $ xs
03:03:59 <ivanm> BONUS: yeah, exactly
03:04:01 <BONUS> (i'd do ap zip tail ahahaha)
03:04:06 <BONUS> kidding aside
03:04:11 <Deewiant> @quote aztec
03:04:12 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
03:04:13 <BONUS> yeah
03:04:17 <BONUS> haha
03:04:26 * luqui writes zip xs (tail xs)
03:04:33 <luqui> or xs `zip` tail xs
03:04:35 <ivanm> I try and avoid ap, etc. normally... mainly because when I look at it it's harder for me to tell what it does :s
03:04:43 * BeelsebobWork says zip <$> tail fwiw
03:04:44 <BONUS> yeah me to
03:04:53 <BONUS> but i just have ap zip tail memorized
03:04:54 <luqui> ivanm, what about <*> ?
03:04:54 <ivanm> @src <$>
03:04:54 <lambdabot> f <$> a = fmap f a
03:04:57 <BONUS> cause i use it a lot
03:04:59 <Cale> not zip <*> tail ?
03:05:01 <ivanm> luqui: no idea what it does ;-)
03:05:05 <BeelsebobWork> Cale: yeh that one
03:05:12 <BeelsebobWork> I always write them the wrong way round for some reason
03:05:15 <ivanm> @src <*>
03:05:15 <lambdabot> Source not found. My mind is going. I can feel it.
03:05:18 <luqui> ivanm, ah, it's awesome.  check out Control.Applicative, cool stuff.
03:05:36 <ivanm> I _really_ like first and second from Control.Arrow though
03:05:40 <ivanm> and ***
03:05:51 <luqui> &&& is less useful for whatever reason :-)
03:05:57 <ivanm> @type &&&
03:05:58 <lambdabot> parse error on input `&&&'
03:06:03 <ivanm> @type (&&&)
03:06:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:06:14 <Deewiant> (id &&&) is what I mostly use
03:06:20 <ivanm> yeah, by type alone arrow stuff doesn't make sense to me :p
03:06:54 <Deewiant> ?ty (&&&) :: (a->b) -> (a->c) -> a -> (b,c)
03:06:55 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
03:07:18 <Cale> I would like to be more convinced that there are categories enriched over Hask which are useful enough to warrant that particular generalisation of (.). I like (.) = fmap, since fmap/liftM/liftA is such a common operation to need that we seem to be inventing more and more names for it.
03:07:26 <Deewiant> ?ty (***) :: (a->b) -> (c->d) -> (a,c) -> (b,d)
03:07:28 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:07:33 <Cale> (I would go with just  map  and  (.)  myself.
03:07:35 <Cale> )
03:08:35 <luqui> Cale, you're talking about (.) from Control.Category?
03:08:36 <ivanm> Deewiant: ahhh..... a splitter function
03:09:09 <Cale> luqui: yeah
03:09:29 <luqui> ivanm, for arrow stuff, it can sometimes help to replace "a" with infix ~>.  then you'd get  (&&&) :: (b ~> c) -> (b ~> c') -> (b ~> (c,c'))
03:09:47 <Cale> luqui: If we had some really fundamental examples besides (->) from Control.Category which seemed like they could be used in almost any code all the time...
03:10:00 <Deewiant> and to replace the "c'" with something else
03:10:09 <ivanm> luqui: and what's ~> ?
03:10:18 <luqui> ivanm, it's an infix type variable ;-)
03:10:32 <luqui> (Arrow (~>)) => ...
03:10:42 <ivanm> ahhh
03:10:51 * ivanm has no idea what an Arrow is :s
03:10:58 <ivanm> except that (a,b) is an instance of Arrow ;-)
03:11:10 <luqui> ivanm, it's a generalization of a function
03:11:37 <luqui> you can cast ordinary functions into it:   arr :: (Arrow (~>)) => (a -> b) -> (a ~> b)
03:11:56 <luqui> you can compose :  (>>>) :: (Arrow (~>)) :: (a ~> b) -> (b ~> c) -> (a ~> c)
03:12:36 <Deewiant> ?instances-importing Control.Arrow Arrow
03:12:38 <lambdabot> (->), Kleisli m
03:12:57 <luqui> those two are the point, imo.  there's also first :: (Arrow (~>)) => (a ~> b) -> ((a,c) ~> (b,c)), which lets you do some other stuff...
03:13:25 <matthew-_> ivanm: were you looking for me?
03:14:01 <ivanm> matthew-_: oh, yeah... I worked out what I wanted
03:14:18 <ivanm> though once I've got my library/program done, I might be sending you more patches for graphviz :p
03:15:05 <matthew-_> cool. I look forward to them!
03:15:24 <luqui> (a,b) isn't an instance of Arrow.  Arrow needs to be "contravariant" in its first argument; i.e. you need to have a mapping function:  (b -> a) -> (a ~> c) -> (b ~> c);  (a,b) only has the opposite:  (a -> b) -> (a ~> c) -> (b ~> c)
03:16:35 <_Dae_> @source sum
03:16:35 <lambdabot> sum not available
03:16:40 <_Dae_> .....
03:16:44 <Deewiant> sum = foldl (+) 0
03:16:56 <ivanm> matthew-_: basically, I've defined a fair few wrapper functions for calling the graphviz app, etc.
03:17:01 <_Dae_> thanks )
03:17:03 <_Dae_> * :)
03:17:19 <_Dae_> for reasons unknown i always confuse foldr and foldl
03:17:39 <ivanm> matthew-_: they're in here, if interested: http://code.haskell.org/Graphalyze/Data/Graph/Analysis/Visualisation.hs
03:17:41 <lambdabot> http://tinyurl.com/4lkpzy
03:17:48 <luqui> they're the same for associative operators like (+)  (modulo infinite lists)
03:18:11 <quicksilver> luqui: I think you can make (a,b) an arrow in a restricted category.
03:18:21 <quicksilver> luqui: it may not be a very interesting arrow.
03:18:59 <quicksilver> luqui: Monoid a, por possibly just Pointed a.
03:18:59 <matthew-_> ivanm: so I see. That's a fair amount of extension
03:19:08 <ivanm> yeah
03:19:11 <matthew-_> ivanm: definitely worth getting them all into the same package
03:19:14 <ivanm> yup
03:19:26 <matthew-_> further fragmentation on hackage will only make things worse ;)
03:19:30 <ivanm> heh, yeah
03:19:52 <ivanm> except I kinda need to get this code done, as I'm meant to give a talk on it on Monday (and I've still got to make the slides!)
03:20:20 <matthew-_> oh sure, np
03:20:27 <matthew-_> I'm pretty busy too atm
03:21:28 <luqui> quicksilver, an *arrow*, with a and b as the two arguments?
03:21:37 <luqui> quicksilver, what would be the implementation of arr ?
03:25:52 <lilac> Deewiant: not foldl' (+) 0 ?
03:26:10 <maltem> lilac: nope
03:26:15 <luqui> lilac, nope, that's the strictness analyzer's job.  it would be incorrect for eg. lazy naturals
03:26:37 <lilac> hmm, fair enough
03:27:00 <quicksilver> luqui: arr f = (mempty, f mempty)
03:27:11 <Axman6> gahh, i hate it when i make stupid little mistakes in programs :(
03:27:18 <quicksilver> luqui: (a,b) >>> (b,c) = (a,c)
03:27:22 <maltem> luqui: even though for lazy naturals Num would be rather useless
03:27:50 <Axman6> i was using div when i needed mod and it meant my fromgram never terminated, instead of taking less than a second
03:28:12 <lilac> quicksilver: you're right, that's not a very interesting arrow ;-)
03:28:51 <lilac> (Enum a, Bounded a) => [(a, b)] would be more interesting
03:29:24 <quicksilver> Enum + Bounded does not imply enumerable, I'm afraid.
03:29:57 <lilac> sure, but enumFromTo minBound maxBound will still be a good selection of elements ;-)
03:30:19 <lilac> is there a selection of standard typeclasses which does imply enumerable?
03:30:58 <quicksilver> well it really should be Enum.
03:31:07 <luqui> quicksilver, oh I see what you mean by restricted category now.
03:31:09 <quicksilver> they just broken it by allowing Enum to be used for ..
03:31:14 <quicksilver> that should be something else.
03:31:38 * lilac is not in favour of the Enum Double instance
03:31:46 <quicksilver> .. should be a typeclass called 'FORTOSTEP', in honour of BASIC
03:31:57 <lilac> hehe
03:32:01 <luqui> the caps are a nice touch
03:33:42 <luqui> in fact if I could choose one thing in haskell to change, it would be the prelude.   or records.   hmm, I can't decide...
03:35:47 <smtms> for to step, wasn't that in some Algol version? or maybe Ada?
03:46:44 <cjs> Hm. What's an easy way to browse the source for lists as an instance of Monad?
03:47:23 <Twey> @instances Monad
03:47:24 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:47:45 <Twey> @src [] (>>=)
03:47:45 <lambdabot> xs >>= f     = concatMap f xs
03:47:51 <lilac> @src [] return
03:47:51 <lambdabot> return x    = [x]
03:47:51 <Twey> @src [] return
03:47:51 <lambdabot> return x    = [x]
03:47:59 <Twey> Heh
03:48:21 <lilac> @quote glorious
03:48:21 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
03:48:25 <Twey> Does anyone else here like to write 'return' in [] as (:[]) when it can't be any other Monad?
03:48:36 <lilac> yep
03:48:36 <Twey> Hahaha
03:48:56 <Twey> It's shorter and clearer?
03:49:13 <b_jonas> Twey: I did write (:[]) once but only when it's in code where the environment uses list functions too not monad fucntions at all
03:49:17 <Axman6> i wouldn't necessarilly say clearer
03:49:24 <b_jonas> like map and stuff
03:49:30 <Twey> Axman6: Makes it obvious you're dealing with a list
03:49:34 <b_jonas> it's a smilie
03:49:50 <Axman6> Twey: [x] doesn't?
03:50:30 <b_jonas> that's not pointless enough
03:50:37 <Twey> Aye
03:50:42 <Twey> Axman6: E.G. Gtk2Hs code: set outputLabel . (:[]) . (labelText :=) . ("Hello " ++)
03:50:52 <Twey> There's an intermediate list
03:50:57 <b_jonas> what's := in that?
03:51:14 <Twey> b_jonas: It's Gtk2Hs' special 'set property' operator
03:51:38 <Twey> You use set like: set someWidget [property1 := value, property2 := value]
03:51:46 <b_jonas> I see
03:52:00 <Twey> It takes a property and a value and returns an object representing setting that property to that value
03:52:06 <Twey> s/object/value/ *blushes*
03:52:54 <lilac> essentially (:=) == (,) ?
03:53:50 <Twey> I don't know how it's implemented exactly
03:53:54 <Twey> Maybe
03:53:57 * Twey checks.
03:54:14 <b_jonas> well, it must be a constructor because of syntax
03:54:19 <lilac> well, it's got to be a data constructor because it starts with a :
03:54:24 <b_jonas> so it's a different type
03:54:47 <Twey> Not quite -- there's type magic
03:54:49 <Twey> (:=) :: ReadWriteAttr o a b -> b -> AttrOp o
04:30:37 <Axman6> @src mod
04:30:37 <lambdabot> Source not found. I am sorry.
04:30:42 <Axman6> @src cgd
04:30:43 <lambdabot> Source not found. stty: unknown mode: doofus
04:30:46 <Axman6> @src gcd
04:30:47 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
04:30:47 <lambdabot> gcd x y = gcd' (abs x) (abs y)
04:30:47 <lambdabot>    where gcd' a 0  =  a
04:30:47 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
04:32:54 <Axman6> :t mod
04:32:55 <lambdabot> forall a. (Integral a) => a -> a -> a
04:33:01 <Axman6> hmm, righto
04:35:26 <b_jonas> let me ask some questions. in ghc concurrency, is thread switching really fast or just moderately fast?
04:36:17 <luqui> i've heard really fast
04:36:50 <luqui> way faster than os threads, of course
04:37:23 <sjanssen> b_jonas: I've seen scenarios where context switches become the bottleneck
04:37:24 <b_jonas> oh, faster than those of course
04:37:27 <b_jonas> but still
04:37:41 <b_jonas> anyway, other question is
04:37:50 <b_jonas> is there a good http client library I can use from haskell?
04:38:31 <sjanssen> @hackage HTTP
04:38:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
04:38:49 <b_jonas> oh, I'll look at that
04:38:59 <b_jonas> to see if it has features I need
04:39:36 <besiria> any emacs haskell-mode help? i'm trying to C-c C-t on a Map.lookup function, but i get ambiguous type and it returns the Prelude.lookup. how can i overcome this
04:40:08 <b_jonas> I'd like the persistent tcp connections feature, timeouts, and that it works well with haskell concurrency if possible
04:40:37 <shapr> I can't even get haskell-inferior-type loaded :-(
04:41:36 <besiria> shapr: shy
04:41:45 <shapr> shae actually
04:42:00 <shapr> Though some people do say shy instead, and I don't know why.
04:42:09 <besiria> shapr: what is shae
04:42:17 <shapr> shae is me, who are you?
04:42:26 <besiria> i'm confused
04:42:26 * shapr multicasts confusion...
04:42:30 <besiria> :D
04:42:32 <shapr> see! it worked!
04:42:38 <besiria> wow it works
04:43:07 <ivanm> besiria: probably can't
04:43:17 <ivanm> shapr: why can't you?
04:43:25 <rahuljosephgeorg> hi
04:43:26 <shapr> ivanm: I don't know!
04:43:29 <rahuljosephgeorg> i need some help
04:43:30 <ivanm> heh
04:43:35 <toyvo> hello, anyone used the SCGI module lately? i can't get it to work with Apache mod_scgi.
04:43:43 <ivanm> shapr: you're using the latest version I take it?
04:43:49 <byorgey> hi rahuljosephgeorg, help with what?
04:44:08 <rahuljosephgeorg> the best programming language for begenniers like me
04:44:11 <shapr> besiria: I think haskell-inferior-type looks up in a list, so you could just dump out a list of the types in your module.
04:44:35 <shapr> besiria: But if you're trying to figure out what the type of one chunk of code would be if you already know the types of the rest of the code, there are easier ways.
04:44:43 <rahuljosephgeorg> the best programming language for begenniers like me
04:44:49 <rahuljosephgeorg> hello
04:44:52 <ivanm> besiria: it does it through ghci, I think... so you need to C-c C-l your file first
04:45:08 --- mode: ChanServ set +o shapr
04:45:31 <rahuljosephgeorg> hello!??
04:45:36 <shapr> rahuljosephgeorg: Hi
04:45:40 <rahuljosephgeorg> i need help
04:45:50 <rahuljosephgeorg>  
04:45:57 <rahuljosephgeorg> ....................................................................................................................................
04:45:58 <shapr> rahuljosephgeorg: Haskell is a good beginning programming language, and there are other options such as Python.
04:46:05 <shapr> rahuljosephgeorg: But it looks to me like you're spamming the channel.
04:46:10 <rahuljosephgeorg> ?
04:46:11 <rahuljosephgeorg> wat?
04:46:14 <rahuljosephgeorg> me spamming?
04:46:20 <rahuljosephgeorg> idont even know wat that means?
04:46:22 <rahuljosephgeorg> but
04:46:23 <rahuljosephgeorg> i think
04:46:25 <rahuljosephgeorg> that's
04:46:28 <rahuljosephgeorg> something wrong
04:46:31 <rahuljosephgeorg> understand?
04:46:40 <shapr> Yeah, I'd suggest you check out the Haskell wiki and look at the introductory pages.
04:46:41 <ivanm> shapr: spamming with vikings? :p
04:46:43 <besiria> ivanm: hmm, when i C-c C-t i put in the minibuffer Map.lookup instead the default lookup and it works. It would be nice if it could see that i want the type of Map.lookup
04:46:57 <SamB_XP> where see vikings?
04:47:05 <rahuljosephgeorg> haskell? i need something other that haskell or python
04:47:09 <ivanm> SamB_XP: Monty Python's spam sketch
04:47:22 <shapr> rahuljosephgeorg: Oh, then you're in the wrong place. Would you like some suggestions for other places?
04:47:23 <ivanm> besiria: my guess is that it's parsing of the function name fails at the .
04:47:27 <mapreduce> > repeat "spam "
04:47:28 <lambdabot>   ["spam ","spam ","spam ","spam ","spam ","spam ","spam ","spam ","spam ","s...
04:47:34 <rahuljosephgeorg> ok
04:47:40 <ivanm> or else it only uses what's loaded into ghci
04:47:49 <shapr> rahuljosephgeorg: You may want to try PHP or C
04:47:49 <ivanm> > unwords $ repeat "spam"
04:47:50 <besiria> ivanm: you're right
04:47:51 <lambdabot>   "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam...
04:47:56 <b_jonas> > cycle "flood " {- actually -}
04:47:58 <lambdabot>   "flood flood flood flood flood flood flood flood flood flood flood flood fl...
04:47:59 <shapr> or maybe C# or Java if you're looking to be immediately profitable.
04:48:00 <_Dae_> rahuljosephgeorg: you -never- need something other than haskell....
04:48:13 <rahuljosephgeorg> yeah......
04:48:26 <b_jonas> _Dae_: I want to find out if that's true right now
04:48:27 <ivanm> _Dae_: sure you do... lambdashell isn't good enough yet!
04:48:28 <ivanm> ;-)
04:48:45 <shapr> rahuljosephgeorg: Ok, I'd suggest learning C# or Java. In those cases, try the #java channel or talk to microsoft.
04:48:50 <b_jonas> _Dae_: that's why I'm asking about http modules and stuff
04:48:58 <rahuljosephgeorg> im 12!!!
04:49:04 <ivanm> shapr: heh
04:49:10 <ivanm> there's always mono...
04:49:17 <_Dae_> you -may- use the foreign interface of haskell if you're really desperate, but you then have to ask forgiveness of one of the saints of haskell. Quicksilver or Dons preferably
04:49:19 <rahuljosephgeorg> mono?
04:49:23 <rahuljosephgeorg> wat's that
04:49:35 <ivanm> _Dae_: I though SPJ, Wadler, etc. were the saints of haskell
04:49:38 <b_jonas> is this a bot?
04:49:39 <_Dae_> b_jonas:
04:49:40 <ivanm> or are they the archangels?
04:49:47 <shapr> rahuljosephgeorg: In any case, the topic of this irc channel is the Haskell programming language, so you may not feel comfortable here.
04:49:47 <smtms> ivanm, they are the gods
04:49:49 <ivanm> b_jonas: is what a bot?
04:49:54 <ivanm> smtms: ahhh
04:49:55 <osfameron> maybe saints of #haskell
04:49:55 <rahuljosephgeorg> hey
04:50:01 <rahuljosephgeorg> everybody
04:50:02 <b_jonas> ivanm: rahuljosephgeorg
04:50:07 <rahuljosephgeorg> i have a problem
04:50:10 <Axman6> wb rahuljosephgeorg
04:50:10 <ivanm> rahuljosephgeorg: an open source version of .Net
04:50:15 <_Dae_> osfameron: ohh, yes... that's what i ment
04:50:17 <shapr> Axman6: He's been here before?
04:50:18 <rahuljosephgeorg> hold ctrl + w see wat happens
04:50:20 <b_jonas> ivanm: just look at eir sentences
04:50:35 <_Dae_> ivanm: what osfameron said :p
04:50:39 <ivanm> rahuljosephgeorg: depends on what app you're in
04:50:42 <shapr> rahuljosephgeorg: Hey, this channel is for discussion of Haskell.
04:50:50 <ivanm> in emacs, it sends stuff to the kill ring ;-)
04:50:51 <rahuljosephgeorg> ok ok im sorry
04:51:01 <rahuljosephgeorg> im leaving .........hope ur happy
04:51:10 <ivanm> *phew*
04:51:19 <ivanm> I don't think we wanted to go through all that again
04:51:24 <shapr> He's been here before?
04:51:27 * ivanm isn't being mean or anything
04:51:29 <ivanm> shapr: yup
04:51:37 <shapr> So... why not ask him to leave?
04:51:39 <ivanm> came in here asking for help in writing an MMO
04:51:52 <sjanssen> shapr: he was a bit more on topic before
04:51:57 <shapr> oh
04:52:07 <shapr> He didn't want to know about Haskell this time :-)
04:52:08 <_Dae_> b_jonas: I thought there were hackage stuff that dealt with http these days?
04:52:09 --- mode: shapr set -o shapr
04:52:12 <ivanm> he came in here originally because he thought it was a general programming channel
04:52:21 <b_jonas> _Dae_: yes, likely
04:52:30 <sjanssen> I don't think he's actually a troll, just an over excited 12 year old
04:52:32 <b_jonas> _Dae_: I'll read the description of the HTTP package and find out
04:52:33 <ivanm> shapr: didn't even notice you becoming an op and mentioning spamming ;-)
04:52:37 <shapr> ivanm: Only because Haskell and our powerful programming language theory discussions subsume ALL OTHERS!
04:52:40 <shapr> but besides that...
04:52:42 <ivanm> lol
04:52:59 <shapr> sjanssen: Yeah, I totally agree.
04:53:02 <_Dae_> ivanm: an mmo, written in haskell? that would be interresting.... Monad XP.....
04:53:07 <quicksilver> my computer starts to play 'Dies Irae' when shapr gets ops, automatically.
04:53:09 <ivanm> heh
04:53:16 * shapr grins
04:53:19 <byorgey> haha
04:53:22 <ivanm> _Dae_: he didn't even know what Haskell was when he brought that up ;-)
04:53:26 <shapr> quicksilver: Whyever is that? Because of my boots of kicking?
04:53:26 <ivanm> quicksilver: :o
04:53:31 <ivanm> how'd you do that? :p
04:53:33 <qebab> this discussion still going on? :o
04:53:43 <ivanm> qebab: which one?
04:53:47 <qebab> the MMO one
04:53:56 <rog_> as usual, i'm agonising about style. i've written some code (http://hpaste.org/10841#a0) that does the job, and is quite pleasantly type-safe, but i end up writing code that does lots of argument shuffling and isn't very pleasant to look at. i wonder if i'm missing out on some appropriate idiom?
04:54:00 <ivanm> oh, it was re-brought up when rha* came back
04:54:01 <b_jonas> "Network.HTTP ... An easy HTTP interface enjoy." -- I don't want an easy one :(
04:54:03 <qebab> I can't autocomplete the rahulj nick anymore, so I'm going to guess that he left at some point?
04:54:09 <b_jonas> easy interfaces suck
04:54:10 <ivanm> yup
04:54:12 <ivanm> again
04:54:15 <ivanm> b_jonas: heh
04:54:35 <quicksilver> I do in fact think haskell would be a good language for an MMO in most respects.
04:54:42 <_Dae_> b_jonas: well...only if you sacrifice power on the altar of easiness, or?
04:54:42 <quicksilver> But I"m not sure if the realtime nature might bite.
04:54:46 <toyvo1> Would Data.ByteString.Lazy.Char8.hGetContents work on a server socket handle if the other side does not close it, or would it wait hang the server waiting on input?
04:55:22 <_Dae_> quicksilver: I think memory might become an actual concern.....
04:55:39 <b_jonas> can I supply timeouts or interrupt a request or something like that with this?
04:56:00 <quicksilver> toyvo1: it will yield you a chunk at a time (64k, I think?)
04:56:01 <Saizan_> toyvo1: it would work since it's lazy IO
04:56:14 <quicksilver> toyvo1: but if the server stops sending data without actually closing
04:56:21 <quicksilver> toyvo1: then you'll never get that 'last bit'
04:56:40 <quicksilver> I don't really recommend interleaved IO for careful systems programming.
04:56:41 <toyvo1> quicksilver: right! So that might be the reason why SCGI module is not working for me
04:57:06 <quicksilver> it's fine for quick hacks, and it's probably more fine on files than it is on sockets.
04:57:12 <byorgey> rog_: which parts in particular aren't pleasant to look at?
04:57:22 <quicksilver> (because files can be expected to yield there data in a fairly timely way and reach a well defined end)
04:57:38 <byorgey> rog_: in general it looks ok, although those 'rot*' functions are ugly =)
04:57:46 <byorgey> but you only seem to ever use rotl2
04:57:47 <toyvo1> So lazy bytestrings are _interleaved_ IO? What does that mean?
04:57:54 <rog_> byorgey: i'm thinking of the definition of the rosenlimits function in particular
04:58:02 <Cthulhon> FWIW, I wrote a bot in Haskell that automates MMO gameplay, and that worked out well.  I don't think it would be hard to invert it into an MMO server with monster AI.
04:58:06 <rog_> and those rot functions are part of the problem
04:58:16 <_Dae_> b_jonas: not quite sure.... I must admit my http is a bit rusty....
04:58:21 <Cthulhon> Graphics might be harder.
04:58:23 <SamB_XP> Cthulhon: isn't that illegal?
04:58:31 <rog_> here's a line from a more complete example: 		R.evalRandIO . minmaxrange 20 . ag . ag . ag0 . imprecise blr . U.rotl3 . imprecise lr . U.rotl3 . imprecise rr $ (U.rotr6 . U.rotr6 . U.rotr6 $ valuehistory) 0.3 30 alpha
04:58:43 <Cthulhon> It's against a EULA...
04:59:05 <rog_> ... and it'll only get worse as the number of variables goes up
04:59:11 <Cthulhon> It's not like I was selling it, though.
04:59:19 <b_jonas> basically I want to rewrite some part of an ugly program to perl
04:59:29 <_Dae_> Cthulhon: why? there's an openGL lib on hackage.
04:59:30 <byorgey> rog_: hmmm
04:59:30 <b_jonas> and I'm considering haskell
04:59:39 <quicksilver> toyvo1: it's a term I use for 'lazy IO' because I consider that a poor use of lazy.
04:59:45 <b_jonas> and I want to find out if it would work for this instead of perl
04:59:56 <toyvo1> quicksilver: ok, got you
05:00:17 <byorgey> rog_: why do you have functions that take so many arguments?
05:00:26 <byorgey> rog_: like, what is valuehistory?
05:00:31 <Cthulhon> _Dae_: I'm aware of it, but I'm not sure how easy it is to use.
05:00:38 <rog_> basically, i guess i'm preprocessing the arguments to a function. and that seems difficult to do generically unless you're doing it on the first argument.
05:00:54 <b_jonas> hmm, no, I don't want this HTTP package
05:00:59 <_Dae_> Cthulhon: as easy as the c version I presume?
05:01:00 <byorgey> rog_: true
05:01:03 <b_jonas> it doesn't handle persistent tcp connection strangely
05:01:12 <rog_> byorgey: the functions are modelling physical systems, and the arguments are parameters to the model
05:01:17 <b_jonas> that is, it leaves me to handle connections myself
05:01:19 <b_jonas> no good
05:01:26 <byorgey> rog_: I see
05:01:29 <b_jonas> any other http modules before I decide it has to be perl?
05:01:52 <Saizan_> ..there's a curl binding
05:01:53 <byorgey> rog_: and the parameters switching around has some sort of physical interpretation?
05:02:21 <b_jonas> Saizan_: sorry, no
05:02:29 <b_jonas> Saizan_: I won't mess with that
05:02:36 <Cthulhon> I would think certain collision detection and interaction aspects might be harder to manage, though.  At least, unless you develop the right semantics.
05:02:38 <_Dae_> b_jonas: there's the simple version, which will do it for you?
05:02:39 <SamB_XP> wise ;-)
05:02:48 <luqui> rog_, I can't say about your actual question.  However, I can help you with that stack overflow in average.
05:02:51 <byorgey> rog_: I'm not 100% sure, but I think what I would do is make a new data type to hold model parameters, so you can package them up
05:03:09 <rog_> byorgey: no. i need to switch the parameters around so that i can provide a generic function which provides imprecision on a single variable
05:03:10 <b_jonas> _Dae_: I want more of the http client implemented yet more control over it too
05:03:28 <Cthulhon> I could be very wrong, I haven't given it much thought.
05:03:30 <b_jonas> _Dae_: I want to have persistent connections handled transparently, so I just issue requests and the module handles connections for me
05:03:40 <luqui> rog_, the trouble is that the accumulator "tot" builds up a big thunk.  force "tot" at some point each time through the "loop"
05:03:43 <b_jonas> yet I want to be able to specify timeouts and stuff
05:03:46 <byorgey> rog_: oh, now I see!  ok, there's got to be a better way to do that, let me think...
05:04:01 <rog_> byorgey: but of course i might wish to provide different imprecision on different variables, so there's no natural argument ordering.
05:04:11 <byorgey> right.
05:04:27 <luqui> rog_, oh,also, n has the same problem.   I'm surprised the strictness analyzer isn't catching that though.  Are you compiling with optimizations?
05:04:38 <luqui> or do you not care about that stack overflow? :-)
05:04:50 <b_jonas> pity
05:04:59 <rog_> luqui: in this case, i was just using ghci
05:05:13 <byorgey> rog_: do the parameters all have the same type?
05:05:58 <luqui> rog_, ah okay.  so if you compile with optimization the problem might just go away.  you can fix it for ghci by adding explicit seqs (or bangs).
05:06:24 <rog_> byorgey: not necessarily
05:06:36 <byorgey> hmm
05:06:42 <b_jonas> how about if you used a single parameter that's a tuple?
05:06:42 <Cthulhon> SamB_XP: Speaking of illegal uses of Haskell, though, I did use it to circumvent cheat detection software as well, which the DMCA might frown upon.  Haskell was just so useful for it, though. :)
05:06:45 <_Dae_> b_jonas: right.... not sure I can help you there. I guess it would be a FI job...
05:07:08 <SamB_XP> ???
05:07:12 <SamB_XP> how?
05:07:27 <toyvo1> as SCGI still doesn't work for me I wrote my own version http://hpaste.org/10842 - if anyone would care to check? Basically I want to forkIO on each incoming request, and also timeout those created threads. But I'm not sure if I'm doing it in a bit naive way in terms of how exceptions are handled.
05:07:30 <byorgey> b_jonas: that just shifts the ugliness somewhere else (lots of functions for pulling out particular elements of a tuple of various sizes, etc)
05:07:34 <b_jonas> _Dae_: there's still one chance: I'll still have to evaluate the two http modules for perl (only those which are non-blocking wrt Coro)
05:07:43 <rog_> byorgey: but all the parameters to be analysed simultaneously will be of the same type (eventually) - either Distrib or Range
05:07:51 <b_jonas> _Dae_: and if they turn out to be wrong, I still have to think on what to do
05:08:06 <b_jonas> _Dae_: but even in that case I won't likely use this HTTP module unless it gets developped further
05:08:13 <quicksilver> toyvo1: what seems to be wrong? or does nothing seem to be wrong and you're just looking for comments?
05:08:16 <byorgey> rog_: well, I was going to suggest putting the parameters in a list, and adding an index parameter to your imprecision function, to tell it which parameter to act on
05:08:17 * luqui thinks haskell is a great language for almost anything, MMOs included.  If you think haskell is not good for something, you need to think harder about the something...
05:08:25 <SamB_XP> b_jonas: develop further ...
05:08:41 <byorgey> dunno if that would work
05:08:43 <shapr> quicksilver: After reading the lyrics to Dies Irae, that was far more amusing.
05:08:47 <_Dae_> b_jonas: it probably willl but...
05:09:01 <b_jonas> SamB_XP: I'm a reinvent the wheel kind of guy, but I'm selective in what I want to write myself and what I don't
05:09:05 <rog_> byorgey: the point being that you give it a random double between 0 and 1 and it produces an appropriately typed parameter to the original function somewhere in the appropriate range.
05:09:08 <b_jonas> SamB_XP: and I don't want to write a http client
05:09:23 <Cthulhon> I wrote a library to do static analysis of binary blobs of code sent down by the server in order to isolate portions which detected my other code or otherwise had side effects.
05:09:27 <luqui> afraid you'll learn something, b_jonas ? :-)
05:09:41 <b_jonas> luqui: no, I just want to decide what I want to learn
05:09:43 <SamB_XP> b_jonas: if you can't find one that manages connections, won't you kind of HAVE to ?
05:09:43 <quicksilver> luqui: well, my misgivings relate to soft real-time and insufficient control of the RTS.
05:10:02 <b_jonas> SamB_XP: no, there's a good one for perl only it's not non-blocking
05:10:13 <b_jonas> SamB_XP: but you can work non-blockingness around by forking and stuff
05:10:17 <toyvo1> quicksilver: yes mostly looking for comments. For me, forkT seems to be wrong, I'm concerned if the socket handles are closed when there is a timeout
05:10:18 <rog_> byorgey: so putting the params in a list isn't possible. at least, i do put the params in a list - that's what the ag0 and ag functions are about. but they can only do that when the variables have been coerced to the same type.
05:10:18 <Saizan_> interesting, haddock is using all my physical memory while building ghc 6.10
05:10:20 <quicksilver> luqui: arguably that's a deficiency of a particular RTS or compiler but you also have to note that the haskell language spec doesn't help.
05:10:22 <b_jonas> SamB_XP: and I'd rather do that then write a http client
05:10:23 <luqui> quicksilver, you mean GC parameters?  Threading stuff?
05:10:33 <byorgey> rog_: ok, I see
05:10:42 <quicksilver> luqui: controlling what you do when things start to run too slowly.
05:10:49 <SamB_XP> b_jonas: so selfish!
05:10:49 <b_jonas> SamB_XP: but you see, the non-blocking module is written by Mark Lehmann so I assume it's a good one
05:10:54 <quicksilver> luqui: it's hard to set up cases for when events start to backlog
05:11:14 <quicksilver> luqui: (consider a large reactive system which is receiving events faster than it can process: how do you program an elegant fallback for that case?)
05:11:29 <rog_> byorgey: i'm quite pleased with the way it works in principle. but in practice, it looks somewhat ugly...
05:11:47 <quicksilver> toyvo1: well, a priori they wouldn't be, but your uses of finally appear to have that covered.
05:11:53 <quicksilver> toyvo1: that's what finally is for, after all :)
05:11:57 <luqui> quicksilver, conal and I are trying to solve that...   I think that falls firmly in the category of "you need to think harder about the something"
05:12:24 <byorgey> rog_: yeah, I know what you mean.  I think there's probably a cleaner way to do it, but not an obvious one
05:12:44 <luqui> the trouble is that often the amount you have to think is quite hard.  but it's so satisfying when you get it :-)
05:12:53 <quicksilver> luqui: I think you will discover you need to add extra RTS features (like unamb is an extra RTS feature).
05:13:05 <quicksilver> luqui: the GHC RTS simply doesn't have an time-related or liveness guarantees.
05:13:17 <quicksilver> luqui: and expression evaluation is not observable.
05:13:27 <rog_> byorgey: that's what i thought. hence the original question...
05:13:38 <quicksilver> luqui: now, in a sense, this isn't a deficiency of the haskell language, so much as the GHC RTS.
05:13:45 <toyvo1> quicksilver: ok, thanks! i'll go try use this see
05:13:50 <luqui> quicksilver, well in particular I think that race (and by extension unamb) is the wrong way to solve future merging
05:13:59 <byorgey> rog_: right =)
05:14:07 <b_jonas> this rewriting stuff was called vaporware even before I mentioned haskell
05:14:08 <luqui> precisely because thread schedulers (in general) are not predictable enough
05:14:11 <rog_> byorgey: the code would be smaller in lisp, but i wouldn't get the type checking :-)
05:14:14 <ttt--> is it possible to get the type from an Exp (like the type checker would give you)?
05:14:20 <byorgey> rog_: indeed =)
05:14:21 <toyvo1> another question that came up for me today. Can a sequence of digits be read efficiently from a Handle into an Integer?
05:14:22 <b_jonas> I won't start developping a haskell http library for then it's really goint to become vaporware
05:14:38 <quicksilver> luqui: yes, I agree.
05:15:22 * _Dae_ bangs his head against the wall, as yet another program flatly refuses to run in parallell
05:15:47 <luqui> quicksilver, (fwiw my current plan is simulating a subset of STM to accomplish the same thing.  simulating because unsafePerformIO is still necessary)
05:15:56 <Axman6> _Dae_: how did you compile it?
05:16:15 <_Dae_> Axman6: using -threaded. Running with +RTS -N3
05:16:28 <quicksilver> luqui: so, more RTS extensions :)
05:16:32 <Axman6> and --make?
05:16:36 <quicksilver> luqui: not a criticism, just an observation.
05:16:56 <luqui> quicksilver, oh, because unsafePerformIO is an RTS extension
05:17:04 <luqui> or rather an RTS extension generator
05:17:06 <luqui> I see what you mean
05:17:42 <_Dae_> Axman6: yes
05:17:47 <quicksilver> luqui: yes. Once you're using that you're not using haskell. In a sense.
05:17:53 <quicksilver> luqui: you are, rather, extending haskell.
05:17:54 <quicksilver> hopefuly.
05:17:59 <quicksilver> extending it or breaking it :)
05:18:00 <Axman6> _Dae_: cleaned the .o and .hi files and rebuilt?
05:18:19 <luqui> quicksilver, fair enough.
05:18:44 <luqui> quicksilver, damn you!  now you have me thinking what an pure extensible RTS would look like...
05:19:12 <b_jonas> someone write a good http library please
05:19:17 <b_jonas> I don't want to
05:19:28 <luqui> b_jonas, HTTP is bad?
05:19:35 <b_jonas> yet I want to try to use haskell for such kinds of things
05:19:43 <b_jonas> luqui: yes, like I said above
05:19:48 <rog_> luqui: average now works.... thanks.
05:20:03 <b_jonas> luqui: it is missing important parts of the client side of http
05:20:17 <luqui> b_jonas, can you patch it?
05:20:23 <luqui> *gasp*
05:20:25 <b_jonas> luqui: dunno, maybe
05:20:32 <b_jonas> maybe
05:20:40 <b_jonas> I'll have to look at its source
05:20:40 <_Dae_> Axman6: also.... It's probably a weak head normal thing.... not that it matters, I reduced the speed of the program 300 times so I could use strategies, hardly worth it
05:20:47 <quicksilver> luqui: I asked jaffacake once if he knew what kind of lower-level language would be need to implement (say) ByteString
05:21:07 <quicksilver> luqui: without just giving up entirely and offering up unsafePerformIO.
05:21:14 <quicksilver> luqui: he didn't have a quick answer :)
05:21:41 <luqui> I would be quite surprised and impressed (if it were good) if he did
05:21:45 <sjanssen_> b_jonas: what is the actual problem with HTTP?
05:21:54 <sjanssen_> b_jonas: also, have you looked at the curl library?
05:22:06 <luqui> hmm, that also reminds me how much par bugs me.
05:22:56 * luqui wants a semantics of parallelism, not just some annotation hacks.
05:22:57 <_Dae_> luqui: I hear ya
05:24:57 <ski> Saizan_ : did you try `^AF' ?
05:25:18 <quicksilver> sjanssen_: he wants something which manages connection pools transparently
05:25:23 <b_jonas> sjanssen_: no, whcih one is the curl?
05:25:26 <quicksilver> sjanssen_: HTTP keep-alive.
05:25:39 <sjanssen_> b_jonas: it is called "curl"
05:25:52 <b_jonas> looking
05:26:47 <rog_> of the first argument to seq, how much of it will be evaluated? just the top level of the type? or the whole lot?
05:26:58 <Saizan_> ski: yup, not helping.. i'm going to compile my own kernel and see
05:27:03 <ski> just thwe top constructor
05:27:16 <ttt--> Is the type checker available from normal haskell code? I'd like to build up Exp's and let ghc tell me what the type is..
05:27:20 <jaak> hi
05:27:25 <rog_> > (\f -> seq f f) (error "one", error "two")
05:27:26 <lambdabot>   (* Exception: one
05:27:36 <rog_> so why does that give an exception?
05:27:37 <jaak> what could be reason for getting: "<interactive>: <socket: 9>: hClose: illegal operation (handle is finalized)"
05:27:37 <luqui> rog_, seq f f = f
05:27:46 <rog_> good point!
05:27:47 <b_jonas> ttt--: sounds scary
05:28:00 <ttt--> how so?
05:28:09 * rog_ kicks self.
05:28:12 <ski> (Saizan_ : if you have multiple attaches, the default is to not resize windows which are displayed in other attachings (`^AF' aka `^A:fit' overrules this) .. but possibly your problem was another ..)
05:29:04 <b_jonas> ttt--: especially the part where you call that "normal"
05:29:10 <luqui> ttt-- in the ghc api.   I think there's a nice wrapper for it on hackage
05:29:16 <ski> > let (_,_) = (\f -> seq f f) (error "one", error "two") in "ok"
05:29:17 <lambdabot>   "ok"
05:29:44 <ski> rog_ : the printing of the final result triggered the `error ...', not the `seq' by itself
05:29:48 <Saizan_> (ski: yeah, but i've only one attached terminal)
05:29:49 <SamB_XP> b_jonas: perhaps he simply meant "not part of the compiler"?
05:29:51 <rog_> then presumably if i do (seq (x, y) (x, y)) it'll have no effect at all?
05:30:04 <ski> rog_ : *nod*
05:30:12 <luqui> rog, yes, (x,y) is in WHNF no matter what x and y are
05:30:20 <b_jonas> SamB_XP: if you embed the compiler it's scary enough
05:30:23 <rog_> i.e. i need a variable to make it do something useful
05:30:27 <ski> rog_ : however `seq (x,y) (..(x,y)..)' is quite another thing
05:30:44 <luqui> ski, ?
05:30:49 <rog_> ski: ?
05:30:51 <SamB_XP> b_jonas: well, considering it normal for code not to be part of the compiler is not exactly scary, though, is it?
05:30:55 <ttt--> luqui, this one? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/metaplug
05:31:18 <luqui> ttt--, I believe so
05:31:22 <b_jonas> SamB_XP: maybe my problem is not the "normal" but messing with compiler internals actually. sorry.
05:31:27 <ski> rog_ : in `seq <foo> <bar>', this will only be executed if the whole is demanded .. and then `<bar>' is demanded (after `<foo>'), that's why `seq x x = x'
05:31:32 <ttt--> thanks
05:31:48 <luqui> ttt--, actually I think I was thinking of 'hint'
05:32:04 <ski> (Saizan_ : ic .. can't help, then)
05:32:08 <b_jonas> SamB_XP: If I want to code in haskell, it's because I want clean semantics, not messing with compiler internals and building code on demand
05:32:18 <SamB_XP> uh huh
05:32:21 <luqui> ski, yeah, but still seq (x,y) = id
05:32:22 <rog_> ski: but (seq (x, y) anything) is still a no-op, no?
05:32:40 <rog_> luqui put it better...
05:32:54 <luqui> equational reasoning ftw!
05:33:07 <rog_> ftw?
05:33:08 <ski> rog_ : yes, since to force `(<foo>,<bar>)' only the toplevel pair constructor is forced (the arguments to it are lazy)
05:33:14 <luqui> "for the win"  it's just a silly meme.
05:33:16 <ski> "ftw" = "for the win"
05:33:31 <luqui> ski, way to use equational reasoning to explain :-)
05:34:45 <ski> rog_ : however, consider `seq (3 :+ (0/0))' ..
05:34:46 <luqui> is there a strict pair in some library somewhere?    i.e. data Pair a b = Pair !a !b
05:35:11 <rog_> ski: :+?
05:35:19 <ski> (luqui : oh .. didn't notice i used eq. reasoning ..)
05:35:24 <luqui> seq (3 :+ (0/0)) = const _|_   (which should = _|_)
05:35:25 <ski> @type (:+)
05:35:26 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
05:35:32 <ski> @src Complex
05:35:32 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
05:35:45 <b_jonas> luqui: isn't that only if you mean for integers?
05:35:49 <b_jonas> 0/0 isn't always bottom
05:35:53 <ski> > sqrt (-1) :: Complex Double
05:35:54 <lambdabot>   (-0.0) :+ 1.0
05:36:11 <luqui> I guess I shouldn't say that since we are explicitly discussing seq, which is the thing that makes _|_ /= const _|_
05:36:17 <luqui> b_jonas, yeah, good catch
05:36:22 <qebab> Hey, I'm writing a program to do calculations regarding a game, and I'd like to solve p = 2 sqrt(t) ln(t) for t, but I'm getting stuck. Can anyone see a solution, or should I just use newtons method to get a good approximation? (Sorry for being offtopic, but I figured that people in here are a lot more clever than me)
05:36:27 <ski> luqui,b_jonas : oops, yes s/0\/0/error "foo!"/
05:36:52 <luqui> b_jonas, 0/0 = _|_ also for computable reals :-)
05:37:01 <ski> > seq (3 :+ error "foo!") "hi there"
05:37:03 <lambdabot>   "* Exception: foo!
05:37:08 <b_jonas> though it would default to Integer I guess
05:37:35 <b_jonas> because the type of (seq (3 :+ (0/0))) doesn't depend on the numeric type inside
05:37:37 <luqui> > seq (1 + error "foo") "X"
05:37:39 <lambdabot>   "* Exception: foo
05:37:44 <luqui> > const "x" (1 + error "foo")
05:37:45 <lambdabot>   "x"
05:37:46 <b_jonas> so that numeric default rule steps in
05:38:10 <b_jonas> so you're probably right if you write it just that way
05:38:16 <b_jonas> > 0/0
05:38:17 <lambdabot>   NaN
05:38:19 <rog_> ski: but would  (3 :+ (0/0)) ever actually be useful, other than forcing an early error?
05:38:28 <b_jonas> hmm no
05:38:30 <luqui> b_jonas, (/) isn't defined on Integer
05:38:37 <b_jonas> yeah,
05:38:41 <rog_> s/would  (/would (seq /
05:39:05 <luqui> rog_, seq C  for any constant expression C is pretty much useless
05:39:40 <rog_> luqui: as far as i can see, seq C for any C that is not an identifier is pretty much useless
05:39:51 <Axman6> @src nubBy
05:39:51 <lambdabot> nubBy eq []             =  []
05:39:51 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:40:07 <ski> qebab : i'm not sure .. you could also try in #math
05:40:10 <luqui> rog_, hmm, I guess that's true.
05:40:17 <Axman6> BeelsebobWork: ^^
05:40:28 <b_jonas> I disagree
05:40:45 <b_jonas> seq C can be useful for when C is a function call
05:40:46 <BeelsebobWork> Axman6: heh, I stand corrected
05:40:50 <ski> rog_ : no, it was just an example of `seq (Constructor arguments ...)' not being the same as `id'
05:40:54 <Axman6> damn right you do :P
05:40:56 <luqui> b_jonas, do demonstrate
05:41:27 <Saizan_> luqui: rnf big_list `seq`
05:41:53 <Axman6> BeelsebobWork: wayta reinvent the wheel there :P
05:41:54 <luqui> Saizan_, ahhh yes of course!
05:41:57 <b_jonas> luqui: I'm thinking of something like (seq (longlist !! 100))
05:41:58 <BeelsebobWork> hehe
05:42:00 <ski> rog_ : consider `seq (length xs)' ..
05:42:14 <luqui> b_jonas, which of course only forces the spine.
05:42:19 <b_jonas> luqui: yep
05:42:22 <qebab> ski: thanks, but I just settled on the approximation. a friend of mine ran it through maple, and appearently it's t = p ^ 2 / 16LambertW(-p/4)^2 which tells me nothing. :p
05:42:24 <b_jonas> luqui: sometimes that's enough
05:42:37 <b_jonas> luqui: depends on what you want
05:42:48 <ski> (qebab : ok)
05:42:56 <rog_> ski: so if you've got seq (length xs) (length xs), will the length be evaluated only once?
05:43:20 <maltem> qebab: I suspect that LambertW is just a dirty trick to be able to write t as an analytical expression :)
05:43:20 <b_jonas> rog_: no
05:43:23 <luqui> qebab, LamberW is one of my favorite special functions :-)
05:43:23 <EvilTerran> rog_, no
05:43:30 <ski> rog_ : depends on whether the implementation does CSE there, i think
05:43:30 <luqui> *LambertW
05:43:39 <EvilTerran> rog_, if you have "let l = length xs in l `seq l", it'll only be evaluated once
05:44:06 <b_jonas> luqui: it's certainly the one that comes up the most often when people ask questions about solving some equatoins analytically
05:44:19 <luqui> ski, right.  most implementations do *not* do CSE because it can introduce space leaks.
05:44:29 <rog_> EvilTerran: the first arg to seq being an identifier...
05:44:30 <b_jonas> a bit ot, but can it also solve (sin x == a*x + b) for x?
05:44:41 <rog_> CSE?
05:44:51 <ski> Common Sub-expression Elimination
05:44:58 <rog_> of course
05:45:02 <luqui> b_jonas, good question.  rewrite sin in exponential form, I suspect it can.
05:45:04 <maltem> qebab: ah indeed, aunt Google says it's just the inverse of f(x) = x  e^x
05:45:49 <ddarius> W
05:46:34 <ski> @let graph = (id &&&)
05:46:35 <lambdabot>  Defined.
05:46:36 <ski> @let cograph = (||| id)
05:46:36 <lambdabot>   Parse error
05:46:36 <luqui> b_jonas, hmmm, actually I think the + b messes it up.  I can't see how to do it offhand with that there.
05:46:54 <b_jonas> luqui: that equation comes up when you try to solve where a planet is at a given time assumin ghte kepler's laws
05:47:16 <ski> @let cograph = ( ||| id )
05:47:17 <lambdabot>  Defined.
05:47:29 <b_jonas> luqui: on the other hand people _really_ ask lots of equations with exp on some forums that are solved by LambertW
05:48:03 <luqui> so there are probably tricks that make it more versatile than I can see immediately
05:48:10 <luqui> (heh, probably, riight...)
05:48:42 <luqui> :t cograph
05:48:43 <lambdabot> forall b a. (b -> a) -> Either b a -> a
05:48:44 <wjt> ski: why did you need the space?
05:49:03 <ski> wjt : i'm not sure .. maybe it clashed with some TH syntax or something ..
05:49:22 <luqui> ah yeah, banana brackets!   I think it's arrow notation
05:49:22 <lilac> istr it's an @let bug
05:49:29 <ski> ("it" being `(|')
05:49:42 <wjt> aha
05:50:06 <luqui> I actually don't know what they're used for.
05:50:16 <ski> (Deewiant mentioned using `(id &&&)' before .. so i just named it)
05:50:23 <rog_> still on strictness, to take an example from my previous code, is it possible in general to rewrite (foldl val_minmax (x, x) xs), to work when xs is an arbitrary length, without rewriting val_minmax to be strict?
05:51:27 <Deewiant> ski: on occasion, (&&& id). ;-)
05:51:30 * ski wonders how often `cograph' would be useful ..
05:51:53 <b_jonas> @faq
05:51:53 <lambdabot> The answer is: Yes! Haskell can do that.
05:52:45 <Deewiant> hmm, (|||) = either, generalized for any ArrowChoice?
05:52:53 <ski> @type (|||)
05:52:55 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
05:52:59 <ski> @type either
05:53:00 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:53:04 <Deewiant> seems like it to me :-P
05:53:07 <ski> *nod*
05:53:20 <rog_> i suppose what i'm really asking is: when is it appropriate to write functions that are strict?
05:53:24 <luqui> rog_, hmmm, I don't think so.  Shouldn't val_minmax be strict?
05:53:34 <luqui> rog_, when the function is strict.
05:53:38 <ski> rog_ : Cale had some mantra for that ..
05:53:58 <rog_> luqui: isn't "when the function is strict" circular?
05:54:03 <luqui> rog_, oh, do you know the definition of strict?
05:54:08 <ivanm> apart from the cabal-based method that xmonad uses, can anyone think of a way of keeping the defined version numbers in haskell source and the .cabal file in sync?
05:54:13 <rog_> luqui: perhaps not
05:54:18 <luqui> rog_, it's very useful.   f is strict if f _|_ = _|_
05:54:28 * ski supposes `cograph' could possibly be used when one has either an input value or a cached output value, and want the output value ..
05:54:36 <luqui> that's all you need to know to make all this talk about strictness very precise.
05:55:15 <rog_> ok. that is useful. so (+) is strict, for example, then?
05:55:16 <luqui> and to answer my own question, of couse val_minmax should not be strict
05:55:25 <luqui> rog_, on most types, yes.
05:55:41 <besiria> can you give me the definition of pure in pure functional? finding hard to translate it in my lang. is it pure as in clean? or pure as in theoretical?
05:55:57 <ivanm> besiria: pure as in maths
05:56:04 <Cale> rog_: It's appropriate to use strictness when you're collapsing a large structure into a small one. But in order for this to make total sense, I have to carefully define 'large' and 'small'.
05:56:09 <b_jonas> pure as in no side effects
05:56:26 <b_jonas> and not depending on previous side effects either
05:56:26 <luqui> besiria, pure as in "referential transparency" ; i.e. no side effects ; i.e. you can replace a function with its definition anywhere and everywhere without changing the meaning of your program
05:56:30 <ivanm> every time you call a function with the same arguments, the exact same stuff happens
05:56:34 <Cale> rog_: A large structure is one with many parts that can be separately evaluated or not, and a small one is one with few such parts.
05:56:37 <b_jonas> only what counts as side effects is not alwasy easy to define
05:56:50 <besiria> can you give me a synonym?
05:56:52 <ski> rog_ : iirc, functions from "large" to "small" datastructures would typically be strict, and functions from "small" to "large" would typically be lazy .. here "large" means that it possibly consists of many parts which doesn't all have to be evaluated at the same time (or at all), while "small" means that is has few such parts (more or less : if you want any of it, all will be computed)
05:56:55 <ivanm> b_jonas: an increase in entropy? :p
05:57:05 <ivanm> besiria: referential transparency, as luqui said
05:57:05 <ddarius> luqui: Referential transparency is not purity.  Neither implies the other.
05:57:07 <luqui> b_jonas, "no side effects"      "not depending on previous side effects either"    how do you have previous side effects if you don't have side effects?   :-)
05:57:14 <ski> (Cale : i see my invokation succeeded :)
05:57:15 <ivanm> ddarius: :o I thought it did...
05:57:28 <luqui> ddarius, ah then I'm mixed up.  Can you give some distinguishing examples?
05:57:40 <ddarius> @google Amr Sabry What is a purely functional language
05:57:43 <Cale> And they might not actually be in memory all at once or represented by a single piece of data by your program. you might write a recursive loop to add a bunch of numbers, and this would be collapsing lots of individual numbers into a small structure (a single number).
05:57:54 <b_jonas> luqui: with IO or with impure functions
05:57:55 <rog_> ski: so minmax is kinda in the middle...
05:57:55 <lambdabot> Plugin `search' failed with: thread killed
05:58:11 <luqui> b_jonas, but haskell doesn't have any of those.
05:58:17 <ddarius> http://citeseer.ist.psu.edu/sabry98what.html
05:58:22 <luqui> b_jonas, (well it has IO of course, I meant impure functions)
05:59:03 <b_jonas> luqui: as in, you can't make readIORef a pure function because it depends on side effects, even though it doesn't _cause_ a side effect
05:59:17 <ski> (maybe s/invokation/evocation/ ..)
05:59:17 <luqui> b_jonas, ah gotcha.
05:59:40 <b_jonas> sure, haskell doesn't have any impure functions
05:59:47 <Philonous> Too bad Haskell doesn't have an eval function :>
05:59:52 <b_jonas> but "pure functions" can make sense in an impure langauge too
06:00:02 <b_jonas> where only some functions are pure, not all
06:00:04 <luqui> Philonous, there are modules that add it.
06:00:17 <besiria> so pure is sth that doesnt introduce side-effects?
06:00:28 <Philonous> luqui: Really? Do you know which?
06:00:35 * luqui looks
06:01:04 <luqui> Philonous, hint is the one I have used.
06:01:13 <luqui> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
06:01:13 <Philonous> Ok, thanks a bunch
06:01:13 <lambdabot> Title: HackageDB: hint-0.2.4.1
06:01:16 <ski> besiria : more or less, yes (see ddarius reference for details)
06:03:28 <besiria> so , maybe clarity is a synonym?
06:03:36 <rog_> since foldl is strict in its last argument, why isn't the prelude version written that way?
06:04:03 <Baughn> fodld', you mean?
06:04:12 <Baughn> It is a mystery.
06:04:27 <maltem> Haddock question: Is there a rationale for having this | and ^ syntax? I mean, would it not be possible to associate comments to declarations without this syntax?
06:04:44 <rog_> i guess i mean "why is foldl' necessary?"
06:04:49 <Baughn> maltem: It's so you can have comments that don't relate to the interface, and shouldn't be haddocked
06:05:25 <b_jonas> don't you mean foldl1?
06:05:28 <rog_> (he says, having finally got his minmaxl function working ok on long lists....)
06:05:36 <b_jonas> no wait you don't
06:05:37 <b_jonas> sorry
06:05:53 <maltem> Baughn: Wouldn't newlines be enough for that? (internal comment, empty line, interface comment, declaration)
06:05:57 <luqui> rog_, almost nobody uses foldl
06:05:57 <Saizan_> rog_: how'd you teach beginners about stack overflows otherwise?;)
06:06:17 <Saizan_> ?src reverse
06:06:17 <lambdabot> reverse = foldl (flip (:)) []
06:06:19 <luqui> rog_, or when they do, they are relying on the strictness analyzer to turn it into foldl'
06:06:20 <Baughn> maltem: Probably
06:06:50 <Saizan_> (one of the rare cases where it's right to use foldl)
06:06:55 <rog_> this is something i'm finding the hardest about haskell. you might think that a program works, but unless you understand its space behaviour (which is non-obvious) then it might fail when n becomes larger.
06:06:56 <lilac> @src sum
06:06:56 <lambdabot> sum = foldl (+) 0
06:06:58 <maltem> hm...
06:07:13 <luqui> Saizan_, but is that not strict?
06:07:17 <lilac> rog_: yeah, i find that hard too :)
06:07:20 <luqui> i.e. wouldn't it be the same as foldl'
06:07:32 <Baughn> rog_: You really do need to model the graph reduction in your head, yes ;)
06:07:39 <Saizan_> luqui: no need to check that the cons-cell is there
06:07:39 <Deewiant> > sum [a,b,c]
06:07:41 <lambdabot>   0 + a + b + c
06:07:54 <luqui> Saizan_, I don't follow
06:07:55 <Deewiant> ((0 + a) + b) + c... hmm
06:08:04 <rog_> i keep wanting some worst-case analysis tools
06:08:09 <Cale> rog_: Well, yeah, it's a little bit awkward at first especially. Eventually you get a bit of sense for it.
06:08:19 <encoder> i want to HTTP POST png image that I read from file:  image <- Data.ByteString.readFile "image.png"
06:08:20 <Cale> rog_: There are excellent profiling tools at least.
06:08:33 <Saizan_> luqui: well in the end you get the same result, but foldl' would add the overhead of seq without any benefit
06:08:36 <Cale> rog_: But if you want to put strict bounds on things, it can take some work.
06:08:50 <encoder> what should I use to enocde it to String fot this purpose?
06:08:53 <luqui> Saizan_, okay
06:09:29 <Axman6> @src foldl'
06:09:30 <lambdabot> foldl' f a []     = a
06:09:30 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:09:31 <Cale> encoder: I believe the function is unpack
06:09:40 <encoder> thanx!
06:09:42 <Cale> unpack :: ByteString -> [Char]
06:16:10 <rog_> anyone know of haskell functions for calculating quantile distributions? or other stats-type functions, for that matter?
06:17:19 <rog_> "just use matlab" :-)
06:18:03 <b_jonas> rog_: do you mean from examined data or from a nice distrib of you which you supply the parameters?
06:18:59 <rog_> b_jonas: either. e.g. something that takes [Double] and returns stats about it.
06:20:12 <rog_> i've written a little histogram function, but there are all kinds of clever algorithms around for doing things better, and they're tedious to replicate, if it's unnecessary.
06:20:43 <b_jonas> rog_: GSL has some functions for this kinds of hting
06:20:57 <rog_> GSL?
06:20:58 <b_jonas> rog_: they're not in haskell but it's probably easy to wrap most
06:21:16 <rog_> let me guess "gnu statistics library"
06:21:21 <b_jonas> no
06:21:27 <b_jonas> gnu scientific library
06:21:34 <b_jonas> http://www.gnu.org/software/gsl/
06:21:39 <b_jonas> or just install from pakcage
06:21:45 <lambdabot> Title: GSL - GNU Scientific Library - GNU Project - Free Software Foundation (FSF)
06:21:51 <b_jonas> there are already haskell wrappings around some of its functions on hackage
06:22:08 <b_jonas> but it's a _large_ library with lots of functions so there's no complete wrapping
06:22:18 <b_jonas> but as it's numeric, it's easy to wrap in general
06:22:22 <rog_> ah, that'll mean getting into the joys of FFI. fantastic!
06:22:32 <b_jonas> rog_: only if there's no wrapping yet
06:22:47 <b_jonas> check hackage
06:22:57 <ddarius> There is already one
06:23:03 <b_jonas> ddarius: for some of the functions, yes
06:23:23 <b_jonas> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
06:23:25 <lambdabot> Title: HackageDB: hmatrix-0.4.0.0, http://tinyurl.com/58d3eb
06:24:31 <rog_> thanks. that gives me food for thought.
06:29:18 * EvilTerran considers proposing unviewr and unviewl in Data.Sequence
06:29:38 <EvilTerran> (unviewr (xs :> x) = xs |> x; unviewl (x :< xs) = x <| xs)
06:30:18 <EvilTerran> i'm (slightly cheekily) using a ViewR for a compile-time-enforced non-empty sequence :)
06:32:11 <TheAeRoxPlaiia_> Wer kann mir 20ac leihen ich brauch bis zu 400020ac ich zahl auch wenne s sein muss das doppelte zurck!
06:33:16 <EvilTerran> ops?
06:34:09 <EvilTerran> the 419ers appear to have learnt IRC (and german)...
06:34:43 <smtms> EvilTerran, you know German?
06:35:08 <EvilTerran> bits and pieces
06:36:33 <rog_> EvilTerran: (first time i've encountered sequences, but...) what's to stop you having an EmptyR value?
06:36:36 <EvilTerran> he said something about lending him 20ac (whatever that means), him needing 400020ac, and him doubling it. or something to that effect.
06:37:06 <EvilTerran> rog_, ah, good point. =/
06:37:12 <EvilTerran> this is the first time i've used sequences as well. not really paying attentio.
06:37:24 <EvilTerran> i'll use a (a, Seq a) pair instead, i guess
06:37:43 <Philonous> EvilTerran: I guess that's  in ISO-8859-1
06:37:46 <ddarius> Then you can write uncurry (<|)
06:37:52 <EvilTerran> indeed
06:38:15 <rog_> that's nice
06:38:33 <EvilTerran> or i might just live dangerously and leave the requirement off :P
06:38:51 <ddarius> No one has ever been bit by a partial function.
06:39:05 <EvilTerran> honest"
06:39:10 <EvilTerran> er, !
06:39:28 <EvilTerran> i don't suppose Catch does Seq's?
06:39:38 <EvilTerran> ?where catch
06:39:38 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
06:39:58 <ddarius> @where throw
06:39:58 <lambdabot> I know nothing about throw.
06:48:34 <rog_> it's funny the way so much haskell stuff is at cs.york.ac.uk. i had my first brush with functional programming there, before haskell existed... there are even some folks still there that i recognise.
07:11:33 <toyvo> hello, was trying to build hsql-mysql on Fedora and GHC 8.3; It doesn't build with cabal install. I finally got it working after hacking the .cabal file. But the file now has these lines: include-dirs: /usr/include/mysql and extra-lib-dirs: /usr/lib/mysql which are of course specific to my platform. How to write the cabal system platform-agnostic?
07:13:44 <toyvo> Any FFI Cabal experts here?
07:15:35 <ivanm> I presume writeFile will throw an exception if it can't actually write to that file?
07:16:16 <Botje> *** Exception: /etc/passwd: openFile: permission denied (Permission denied)
07:16:20 <Botje> yup :)
07:16:34 <ivanm> OK, because System.IO doesn't say it does
07:17:15 <ivanm> though I presume using openFile and hPutStr would be better?
07:17:43 <ivanm> heh, that's what writeFile does anyway :p
07:20:35 <ivanm> hmmm.... my IO code is getting rather wide :s
07:21:42 <matthew-_> ivanm: I code to the width of the monitor
07:21:52 <matthew-_> though it does make things very painful when I have to use my laptop
07:22:02 <ivanm> heh
07:22:10 <ivanm> I try and stick to around 80 chars
07:22:38 <ivanm> but with all the if-statements and case-statements I'm using to check for errors, etc.... :s
07:22:45 <matthew-_> yeah quite
07:22:57 <matthew-_> if statements are particularly ugly
07:23:14 <ivanm> especially since you need to re-start your do-block
07:23:14 <matthew-_> you could just use guards
07:23:26 <matthew-_> guards aren't very wide
07:23:57 <ivanm> oh?
07:24:11 <ivanm> how does one suddenly start a guard mid-do-block?
07:24:17 <matthew-_> oh
07:24:21 <ivanm> heh
07:24:26 <matthew-_> well, you can't
07:24:32 <matthew-_> but you could put it in a let!
07:24:37 <matthew-_> and then join!
07:24:47 <matthew-_> mmm. that wouldn't help really...
07:24:52 <ivanm> can you put IO stuff in a let?
07:24:54 <ivanm> ;-)
07:24:59 <matthew-_> yup
07:25:05 <matthew-_> but then you have to run it
07:27:48 <ivanm> oohhhh..... didn't know that...
07:28:20 <score> wow, haxml.. wow
07:29:35 <score> what xml library do people actually use?
07:29:36 <malcolmw> rog_: I think we even shared a house for a year...
07:30:53 <malcolmw> rog_: or was that a different Rog at cs.york?
07:31:05 <rog_> malcomw:  hey, good to see you. indeed we did...
07:31:34 <rog_> malcolmw: should've known you'd be lurking around here!
07:31:59 <rog_> malcolmw: ... after seeing your name on some of the papers.
07:32:47 <b_jonas> score: me, I use the perl xml library XML::Twig
07:33:37 <rog_> malcolmw: BTW, i finally moved away from york a couple of years ago. not easy!
07:33:38 <ivanm> b_jonas: does this look like #perl to you? :p
07:33:52 <b_jonas> ivanm: score specifically asked "people actually"
07:33:58 <b_jonas> ivanm: plus, #perl isn't about perl
07:34:09 <malcolmw> rog_: I've been here for 21 years now
07:34:12 <ivanm> it isn't? :o
07:34:28 <ivanm> then what is it about?
07:35:07 <rog_> malcolmw: well, i'd have been the same if i hadn't moved. (except 2 years in leeds). i thoroughly recommend moving, BTW! sweeps out the cobwebs...
07:35:44 <b_jonas> ivanm: join it and you'll see it has all kinds of random discussion but nothing relevant to perl and it definitely doesn't give support for perl newbies
07:35:51 <b_jonas> ivanm: there's no fix theme I guess
07:36:13 <score> malcolmw: would you accept janitorial patches ridding the warnings when compiling haxml?
07:36:20 <b_jonas> (ivanm: if you wanted to ask perl questions, the right channel is #cbstream )
07:36:22 <ivanm> b_jonas: so it's like #haskell gone bad?
07:36:42 <ivanm> wow, that makes _so_ much sense!
07:36:48 <malcolmw> score: sure, as long as the patches are clean
07:37:23 <rog_> malcolmw: well, since you're here... what are the chances of me getting Hat to work with ghc under macos?
07:37:38 <maltem> Argh, did they refactor Control.Exception for ghc-6.10 without being backwards compatible?
07:37:41 <malcolmw> score: someone once sent me warning-removal patches that destroyed a lot of the code structure, so I'm sometimes wary
07:38:14 <rog_> malcolmw: i couldn't even get hmake working, sadly
07:38:22 <b_jonas> this curl library looks nice
07:38:23 <malcolmw> rog_: My nightly builds of Hat (darcs repository) on MacOS go through cleanly, but I haven't actually used it in a while
07:38:35 <b_jonas> I'm still reading its docs to see if it would work for what I want
07:38:36 <malcolmw> rog_: ah, hmake is kind of essential.
07:39:52 <rog_> malcolmw: i registered a bug with macports, but no useful response. they're usually good, too. i guess i should really try it directly myself.
07:40:09 <Axman6> rog_: what's the bug?
07:40:35 <malcolmw> rog_: you could try a tarball of hmake, or even the darcs repo of nhc98 (which contains hmake)
07:42:36 <rog_> Axman6: http://trac.macports.org/ticket/16592 (i tried to reopen it, but it seems to have forgotten about that).
07:42:42 <lambdabot> Title: #16592 (hmake build failure)  MacPorts  Trac
07:44:43 <rog_> malcolmw: i'll try the tarball. it died somewhere in configure, as usual.
07:45:21 <Axman6> rog_: i assume you have the dev tools installed?
07:45:55 <rog_> Axman6: yeah. i've installed ghc, and much else just fine.
07:46:58 <rog_> Axman6: i started following the shell-scripts through, but it's all a maze of twisty passages; fixing one thing just gets something else to fail.
07:47:10 <Axman6> :\
07:47:58 <rog_> Axman6: indeed
07:49:27 <malcolmw> rog_: those would be my shell-scripts no doubt. :-)  sending bug reports direct to me might be faster than fixing it yourself.
07:51:31 <rog_> i don't doubt it! you still malcolmw at cs.york?
07:52:02 <malcolmw> rog_: drop the w, just malcolm
07:52:27 <rog_> i'll send you a transcript...
07:53:57 <b_jonas> I have to try this libcurl binding
07:58:43 <b_jonas> strange
07:58:57 <b_jonas> my ghc executable is a shell script with no execute permission on it
07:59:53 <b_jonas> I could just chmod them but this might be a symptom of some more serious install trouble
07:59:58 <b_jonas> I wonder how I ended up with this
08:00:17 <rog_> malcolmw: i remember now. the first problem is that at configure:58, it uses $CCC before it's been set, so the emulated echo doesn't get built, so everything subsequent fails...
08:02:05 <b_jonas> so what was that magic command to list all the installed hackage packages?
08:02:38 <rog_> malcolmw: ... and it still doesn't work when i move the CCC= line before that echo. i think that's when i gave up, in a pathetic sort of way.
08:02:40 <quicksilver> ghc-pkg list
08:03:40 <malcolmw> rog_: hmm, yes, can't imagine how that ever worked - I think some patch must have switched the lines around at some stage
08:03:58 <b_jonas> thanks
08:04:07 <rog_> malcolmw: i'd guess maybe you always had an echo that did -n.
08:05:11 <malcolmw> rog_: However, assuming you are not still using Jaguar or earlier, it is safe to remove the lines setting CCC, and replace all uses of CCC with ${CC-gcc}
08:05:14 <rog_> malcolmw: i do too (i still use rc), but i guess that /bin/sh is bash in sysv emulation mode by default.
08:06:43 <rog_> malcolmw: what about confhc? that's where it goes wrong second time
08:08:17 <malcolmw> rog_: hmm, so CCC={CC-gcc} script/confhc should work (i.e. define CCC as gcc before the invocation of confhc)
08:08:41 * rog_ is trying it.
08:10:43 <b_jonas> this curl library looks quite nice
08:10:49 <b_jonas> well-written that is
08:10:53 <rog_> malcolmw: ok, that works. all built and lovely. ta.
08:10:55 <b_jonas> I'll have to try it
08:10:59 <b_jonas> thanks for those two people recommending it
08:12:11 * malcolmw really must work out how to create a nice easy Cabal package of hmake
08:13:04 <quicksilver> lispy: your post to g-h-u makes no sense.
08:13:53 <quicksilver> lispy: ah no, false alarm. It's me being stupid.
08:20:33 <b_jonas> wait,
08:20:56 <b_jonas> if I have ghc installed to my home dir, why does cabal try to install packages to /usr?
08:21:09 <b_jonas> (to /usr/local of course I mea)
08:21:31 <quicksilver> that is the default for cabal-install
08:21:38 <quicksilver> use --global for the other behaviour.
08:22:04 <b_jonas> I'm not running cabal-install
08:22:09 <mapreduce> @src join
08:22:09 <lambdabot> join x =  x >>= id
08:22:27 <mapreduce> Where's join, should I wish to use it?
08:22:30 <mapreduce> @hoogle join
08:22:30 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
08:22:31 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
08:22:31 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
08:22:33 <b_jonas> I'm running runhaskell Setup configure && runhaskell Setup build && runhaskell Setup install
08:22:47 <rog_> malcolmw: are you responsible for hat too?
08:22:50 <b_jonas> maybe I have some really big problem with my local haskell installation
08:22:57 <b_jonas> and it's actually finding the other haskell install
08:22:59 <b_jonas> the global one that is
08:23:09 <b_jonas> I think I should try to reinstall haskell
08:23:15 <mapreduce> > let square = join (*) in square 5
08:23:16 <lambdabot>   25
08:23:17 <b_jonas> reinstall ghc that is
08:23:22 <mapreduce> I can't get that working in ghci.
08:23:25 <b_jonas> only it takes quite a lots of time to rebuild
08:23:29 <malcolmw> rog_: yep
08:24:39 <Axman6> mapreduce: i can;t get thay working in my head...
08:25:03 <mapreduce> Put your head between these two books..
08:25:03 <Axman6> @src join
08:25:04 <lambdabot> join x =  x >>= id
08:25:06 <rog_> malcolmw: 'cos i've fixed one bug (the ghcsym function produces an invalid ghcsym file, because it greps for '^#' not '{-#') but even then i get a dependency error. i'll hpaste the transcript.
08:25:15 <quicksilver> b_jonas: pass --global to the configure step
08:25:38 <seliopou> > let dup = join (***) in dup 1
08:25:39 <lambdabot>       No instance for (Show (a (b, b) (c, c)))
08:25:39 <lambdabot>        arising from a use of `...
08:25:45 <mapreduce> Axman6: join x f = f x x
08:25:49 <mapreduce> Does that help?
08:25:54 <b_jonas> quicksilver: I'll try, a moment
08:25:55 <Axman6> a little
08:26:06 <Axman6> i don't see how it is, but i shall accept it :)
08:26:11 <mapreduce> Wrong way around.
08:26:16 <mapreduce> join f x = f x x
08:26:17 <rog_> malcolmw: http://hpaste.org/10847#a0
08:26:19 <b_jonas> quicksilver: what's the equivalent of make clean?
08:26:30 <mapreduce> So join (*) 5 = (*) 5 5
08:26:33 <quicksilver> b_jonas: runhaskell Setup clean
08:26:36 <mapreduce> (*) 5 5 = 5 * 5
08:27:07 <b_jonas> same result with --global
08:27:08 <b_jonas> however,
08:27:15 <b_jonas> I get a warning which I ignored
08:27:18 <b_jonas> Warning: The field "hs-source-dir" is deprecated, please use "hs-source-dirs"
08:27:19 <b_jonas> Configuring polyparse-1.1...
08:27:25 <b_jonas> that warning might be relevant
08:27:34 <b_jonas> I get it from runhaskell Setup configure --global
08:27:39 <b_jonas> (and without the global too
08:27:39 <quicksilver> malcolmw is your man, I guess.
08:27:40 <b_jonas> )
08:28:00 <b_jonas> I wonder if I should try to reinstall my ghc
08:28:29 <malcolmw> rog_: looks like your hat tarball is quite old.  both problems have been fixed in the darcs repo for a while
08:28:45 <b_jonas> malcolmw: which tarball?
08:29:04 <b_jonas> malcolmw: the tarball of the package?
08:29:22 <rog_> malcolmw: oh. i downloaded the latest hat tarball from the hat page. i never use darcs, so thought i'd save myself going the manpages working out how to do it...
08:29:35 <b_jonas> hat tarball... what's a hat?
08:29:48 <malcolmw> rog_: I should probably package up a tarball then
08:30:00 <malcolmw> b_jonas: errm, different conversation
08:30:02 <rog_> malcolmw: that'd be sweet
08:30:04 <b_jonas> oh, sorry
08:30:25 <malcolmw> b_jonas: re polyparse, the warning is totally harmless
08:30:37 <b_jonas> malcolmw: ok
08:32:09 <b_jonas> is it possible that this is trying to use the system ghc (from debian package) instead of my ghc
08:32:16 <b_jonas> which is why it wants to use this prefix?
08:33:20 <[R]ayne> If I leave GHCi open for more than 20 minutes it takes 255mb memory O_O
08:33:37 <quicksilver> the "20 minutes" part should be irrelevant
08:33:42 <b_jonas> well, I guess I'll try building and installing a new ghc
08:33:44 <quicksilver> it should just depend what you're doing with it.
08:34:08 <[R]ayne> If I just open it and leave it idle.
08:34:13 <quicksilver> I have a ghci that's been running for a few hours and it's only using 20M
08:34:20 <quicksilver> that's very odd then ;)
08:34:22 <[R]ayne> I've never cared enough to rebuild it.
08:34:35 <[R]ayne> My computer is shitty.
08:34:39 <[R]ayne> That could be part of it.
08:34:43 <[R]ayne> :p
08:35:33 <quicksilver> shitty computers still shouldn't make ghci take up 255M doing nothing.
08:35:44 <quicksilver> are you sure it's not printing the output of [1..] ? ;)
08:35:53 <[R]ayne> No.
08:35:54 <Baughn> What OS is it running?
08:36:04 <[R]ayne> Vista, windows.
08:36:21 <[R]ayne> It's not exactly important, I rarely use it anyways.
08:36:22 <dmwit> At this point, it is *very* tempting to blame Windows.
08:36:34 <quicksilver> I give in to the temptation.
08:36:38 <quicksilver> [R]ayne: that's windows' fault.
08:36:39 <Baughn> I blame Vista. Windows is fine.
08:36:42 <[R]ayne> I love blaming windows for things.
08:36:47 <[R]ayne> ^_^
08:36:53 <b_jonas> I blame windows too
08:37:03 <quicksilver> Baughn: Unless you retract the statement 'Windows is fine' I revoke your lambdas!
08:37:07 <quicksilver> ;P
08:37:10 <[R]ayne> I should switch to unbuntu.
08:37:13 <[R]ayne> ._.
08:37:17 <Baughn> quicksilver: No! Anything but my lambdas!
08:37:33 <Baughn> I admit it: I, too, believe Windows is a failed attempt at a bio-weapon.
08:37:51 <quicksilver> I'm not sure it has entirely failed.
08:37:56 <quicksilver> time will tell.
08:40:15 <ivanm> I've got pandoc installed as a library... but cabal isn't finding it! ;o
08:40:20 <ivanm> any idea why?
08:40:34 <quicksilver> cabal --look-behind-fridge
08:40:39 <ivanm> ghc-pkg list has it
08:40:40 <quicksilver> (sorry, that's not helpful)
08:40:42 <ivanm> quicksilver: *groan*
08:40:45 <quicksilver> is it in () ?
08:40:45 <ivanm> no, really? :p
08:40:56 <BeelsebobWork> ivanm: it's in your _|_
08:41:00 <BeelsebobWork> >.>
08:41:15 <quicksilver> ivanm: in ghc-pkg list, is it in (.....) ?
08:41:16 <b_jonas> lol
08:41:41 <quicksilver> ivanm: is it in the builddeps of the package you're trying to compile?
08:41:48 <ivanm> nope
08:41:52 <Baughn> quicksilver: Hm. It might be helpful to add a --look-behind-fridge option that, instead, looks through your homedir for packages
08:41:54 <ivanm> and yes, it is
08:42:18 <quicksilver> ivanm: then I think that's odd. Can you hpaste the output?
08:42:26 <quicksilver> of ghc-pkg list as well
08:42:30 <quicksilver> and the failed cabal command
08:42:47 <malcolmw> rog_: current tarball of Hat now available from the webpages (haskell.org/hat)  you may need to refresh the page to see it
08:43:20 <ivanm> http://rafb.net/p/gyOyg245.html
08:43:21 <lambdabot> Title: Nopaste - $ cabal install -v --dry-run;
08:43:26 <ivanm> http://rafb.net/p/ULnJBq30.html
08:43:26 <lambdabot> Title: Nopaste - $ ghc-pkg list;
08:43:32 <ivanm> what's the old-school way of doing it?
08:43:43 <b_jonas> ok, starting build
08:43:50 <b_jonas> this will take some time
08:44:39 <ivanm> OK,  using "runghc Setup.lhs build" doesn't complain about it >_>
08:44:39 <rog_> malcolmw: i just installed darcs, got the latest version, chmodded 755 the scripts (shouldn't darcs do that?), and still got the same error: http://hpaste.org/10848#a0
08:44:48 <pozic> malcolmw: does it already work with any program that can be compiled with GHC?
08:45:08 <rog_> malcolmw: i'll try with your tarball anyway.
08:45:09 <b_jonas> this one I'll install globally
08:45:24 <quicksilver> ivanm: still, that's very odd.
08:45:30 <quicksilver> ivanm: I think you shoulud tell dcoutts_ when he's around.
08:45:38 <dcoutts> @arr!
08:45:38 <lambdabot> Shiver me timbers!
08:45:45 <quicksilver> my word, speak of the devil
08:45:56 <quicksilver> dcoutts: have a look at ivanm's two rafb pastes.
08:46:13 <malcolmw> rog_: after getting the repo with darcs, you need a "sh start" to set permissions on scripts etc
08:46:42 <malcolmw> pozic: if you mean Hat, then no, it is haskell'98 programs only
08:46:50 <ivanm> quicksilver: you have the magic power of summoning our cabally lords and masters! :o
08:47:13 <JaffaCake> dcoutts: welcome back :)
08:47:22 <rog_> malcolmw: i obviously didn't read far enough!
08:47:56 <dcoutts> @localtime JaffaCake
08:48:27 <rwbarton> ivanm: as a random guess, maybe you've upgraded some dependency of pandoc and cabal has decided it'd better rebuild pandoc to avoid version conflict problems?
08:48:31 <JaffaCake> dcoutts: I don't know what that's supposed to do, but some window just popped up from lambdabot
08:48:32 <rog_> malcolmw: h98 only... that's a pity. that rules out almost every haskell program around!
08:48:38 * dcoutts tries to work out what time he'd need to get up to make it to the weekly ghc meeting
08:48:52 <JaffaCake> 8am
08:49:00 <dcoutts> JaffaCake: oh, perhaps your client does not support time requests
08:49:19 <EvilTerran> JaffaCake, it causes lambdabot to send a CTCP TIME request to your client and then print the response in the channel
08:49:22 <EvilTerran> @localtime dcoutts
08:49:23 <lambdabot> Local time for dcoutts is Thu Oct  2 08:49:23
08:49:25 <malcolmw> rog_: most of my programs are pure H'98 :-)
08:49:43 <Baughn> Is there an overview somewhere of how well the various haskell implementations implement ghc? ^_^
08:49:44 <rog_> malcolmw: BTW, after sh start, still same problem (can't find PackedString)
08:49:59 <ivanm> rwbarton: tried that, ghc-pkg check shows hnothing, cabal upgrade doesn't want to rebuild anything :s
08:50:00 <malcolmw> rog_: which version of ghc do you have?
08:50:12 * ivanm tries rebuilding it again though, just to make sure
08:50:20 <rog_> malcolmw: quite difficult to do without things like scoped type variables, i've found.
08:50:22 <ivanm> even  though the only thing I've updated recently is cabal :s
08:50:39 <dcoutts> JaffaCake: so it's 10 to 50
08:50:41 <dcoutts> erm
08:50:51 <dcoutts> JaffaCake: so it's 10 to 5pm for you now then?
08:50:52 <ivanm> with haddoc, how does one link to functions like <.> in FilePath?
08:50:55 <rog_> malcolmw: 6.8.2
08:50:58 <JaffaCake> right
08:51:08 <dcoutts> ok, will have to get up early next weds
08:51:09 <b_jonas> by the way, why doesn't the curl docs and webpage ("http://curl.haxx.se/libcurl/bindings.html") list haskell among the langauges for which there's a binding?
08:51:12 <JaffaCake> you are UTC-8
08:51:17 <dcoutts> right
08:51:38 <malcolmw> dcoutts: are you in Portland?
08:51:43 <dcoutts> malcolmw: aye
08:52:13 <malcolmw> dcoutts: here's hoping it is wet and cold for you - just the way you like it :-)
08:52:36 <dcoutts> malcolmw: actually yes it is :-)
08:53:40 <dcoutts> ivanm: so your issue with cabal-install graphalyze, I expect it wants to install pandoc against different versions of its deps than those that are currently installed
08:53:49 <ivanm> yeah
08:53:52 <dcoutts> really I should make it say that when it proposes to reinstall things
08:54:00 <dcoutts> as working it out yourself is not trivial
08:54:04 <ivanm> I'm rebuilding pandoc again to make sure, since I've installed it via ebuild
08:54:22 <dcoutts> you can see, just ghc-pkg field pandoc depends
08:54:38 <dcoutts> and compare those deps to the ones you can see selected in the --dry-run -v output
08:55:48 <malcolmw> rog_: odd - does the reported invocation of ghc include the flag "-package packedstring"?
08:57:04 <ivanm> nope, I've just rebuilt it, and it still complains :s
08:57:27 <ivanm> can't see anything in ghc-pkg field depends that isn't listed by cabal install --dry-run -v :s
08:57:58 <rog_> malcolmw: i don't think i have a reported invocation of ghc. the error seems to be reported by MkProg.
08:59:12 <dcoutts> ivanm: I don't believe it, look harder! ;-)
08:59:28 <ivanm> heh
09:00:11 <ivanm> dcoutts: could it be that I built it with different flags than what cabal-install knows about?
09:00:17 * BMeph_ and his wife wish it were wet and cold in San Diego, but they're probably the only ones...
09:00:36 <rog_> malcolmw: the error is exactly as in http://hpaste.org/10848 (after the make command)
09:01:33 <DukeDav1> Hey guys, I have a rather fun multithreaded problem I'd like to solve with Haskell
09:01:42 <rog_> h
09:01:58 <rog_> malcolmw: i tell a lie. here's an exact copy: http://hpaste.org/10848#a1
09:02:46 <b_jonas> what?
09:03:02 <b_jonas> I thought DukeDav1 would ask a question
09:03:55 <malcolmw> rog_: the mixture of "hmake not installed" and actual errors from hmake is somewhat confusing :-)
09:04:01 <quicksilver> he decided he'd rather solve it himself and make $$$!
09:05:15 <ivanm> dcoutts: double-checked, they're all the same :s
09:05:43 <ivanm> dcoutts: only thing I can think of is that I built pandoc with different config flags with the ebuild than what cabal-install expects :s
09:05:46 <rog_> malcolmw: your software! :-) thanks for trying anyway. i have to go now. the working day is over and it's a beautiful sunny evening (not been many of those this year!). good to chat. all best, see ya.
09:06:21 <malcolmw> rog_: and the second (non-working) invocation of hmake correctly has the -package packedstring flag... curiouser and curiouser
09:07:56 <Baughn> Right, then. Is it possible to install gtk2hs in ~/.ghc?
09:07:59 <malcolmw> rog_: ah, the top-level Makefile invokes hmake just to get the list of source files!
09:08:21 <BMeph_> quicksilver: ???
09:08:55 <BMeph_> quicksilver: Profit? --Aren't there a few steps missing there... ;p
09:09:12 <malcolmw> rog_: ... and on my machine, hmake defaults to using nhc98 for that step, rather than ghc.  argh!
09:09:31 <Baughn> BMeph_: ??? is a perfectly valid step. If it fails for you, you need an interpreter that allows longer backtracks.
09:14:28 <lilac> b_jonas: DukeDav1 was actually just bragging. i wish i had a rather fun multithreaded problem to solve with haskell
09:15:07 <ivanm> dcoutts: for some reason, if I try and use cabal to install pandoc, it says it doesn't need to :o
09:16:49 <b_jonas> I can tell a multithreaded problem to solve with haskell, but it's not fun
09:24:23 * lilac wonders how hard it'd be to create a database with STM
09:24:26 <ivanm> dcoutts: OK, looks like the problem is that cabal-install only reads flags for the package specified
09:24:56 <ddarius> lilac: Databases are as hard as you want to make them.
09:25:04 <ivanm> In case anyone cares, I uploaded v 0.2 of Graphalyze
09:26:10 <lilac> ddarius: i'm thinking of a full-featured database like mysql or psotgres :D
09:26:24 <Deewiant> anybody know why copyFile would give a "permission denied" error on a temp file of its own?
09:26:40 <ddarius> lilac: It's not the feature set that adds complexity.
09:27:35 <lament> boo, RWH delayed to mid-december!
09:28:05 <Axman6> :(
09:28:22 <Axman6> that means like mid june for us ivanm :(
09:28:50 <lament> (i mean, my amazon pre-order is delayed to mid-december)
09:28:58 <ivanm> Axman6: ummmm.... why mid-june?
09:29:08 <ivanm> mid-jan, maybe...
09:29:15 <Axman6> because this is australia, and you know how behind we are
09:29:23 <mmorrow> this cgi prog takes "?incl=<comm-sep-pkg-names>&excl=<comm-sep-pkg-names>" and gives back a png of a graph of every pkg which the pkgs in the "incl" list dep on as well as pkgs which dep on them. an example for a single included pkg: http://moonpatio.com:8080/cgi-bin/hackgraphs.cgi?incl=Cabal
09:29:42 <mmorrow> a more complex query: http://moonpatio.com:8080/cgi-bin/hackgraphs.cgi?incl=monadLib,HaXml&excl=panda,Barracuda,HAppS-Server,HAppS-State,HAppS-Data
09:29:44 <lambdabot> http://tinyurl.com/3fybl6
09:29:50 <ivanm> Axman6: it'll be shipped from the states though
09:29:56 <ddarius> They have to wait for winter in Australia
09:29:58 <ivanm> well, possibly via NZ
09:29:58 <Axman6> yeah
09:30:02 <mmorrow> it's addicting :)
09:31:01 <mmorrow> (hackage packages that is)
09:36:45 <quicksilver> dcoutts: "By everything I mean everyone's
09:36:46 <quicksilver> private projects and all the packages on hackage"
09:36:53 <quicksilver> dcoutts: hmm yeah. That sure sounds like everything :)
09:49:47 * EvilTerran runs into a situation where he'd feel a lot safer if there were an added class constraint on do-blocks with failable patterns
09:49:51 <EvilTerran> grr :/
09:50:03 <EvilTerran> MonadFail++
09:51:40 <EvilTerran> ... can this be done with -XNoImplicitPrelude?
09:52:19 <dolio> Have they changed the way GHC types do blocks?
09:52:29 <dolio> @type do 3
09:52:30 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
09:53:18 <dolio> I don't think it desugars before it type checks.
09:53:21 <EvilTerran> aww
09:53:33 <dolio> I may be wrong, though.
09:53:39 <Deewiant> EvilTerran: I think it can, since you get to supply your own Monad
09:53:57 <EvilTerran> i vaguely recall a trick to use Set as a monad in do-blocks
09:53:58 <Deewiant> or, more to the point, your own fail
09:54:13 <maltem> EvilTerran: Still you'd need a totality checker on patterns tied into the type checker
09:54:26 <EvilTerran> indeed =/
09:55:08 <EvilTerran> @undo do x <- [Just 1, Nothing]; return x
09:55:08 <lambdabot> [Just 1, Nothing] >>= \ x -> return x
09:55:13 <EvilTerran> @undo do Just x <- [Just 1, Nothing]; return x
09:55:13 <lambdabot> [Just 1, Nothing] >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
09:55:29 <dolio> Well, you wouldn't, actually, if it just calls whatever is named 'fail'.
09:55:34 <EvilTerran> hm... if the desugaring already does totality checking like that, it'd work
09:55:46 <dolio> Except that 'do (a,b,c) <- m ; ...' would have a MonadFail constraint.
09:55:52 <dolio> Despite being unfailable.
09:55:58 <EvilTerran> if the desugaring always includes the case and fail, it won't work
09:56:03 <Deewiant> @undo do (a,b,c) <- m; return a
09:56:04 <lambdabot> m >>= \ (a, b, c) -> return a
09:56:08 <maltem> ah, that makes sense, dolio
09:56:10 <Deewiant> I don't see a case there
09:56:12 <EvilTerran> dolio, well, then you'd use do ~(a,b,c) <- m; ...
09:56:17 <ddarius> EvilTerran: Use a little TH
09:56:30 <EvilTerran> what, desugar the do-blocks myself?
09:56:48 <ddarius> EvilTerran: Yes
09:56:58 <EvilTerran> hardly "a little" TH, but i guess it'd work
09:57:06 <ddarius> The desugaring is pretty simple
09:57:14 <EvilTerran> yes, but TH isn't :P
09:57:20 <ddarius> You should be able to do it in less than a page of code.
09:57:33 <EvilTerran> i think i'm getting into yak shaving here
09:58:29 <hackage> Uploaded to hackage: Graphalyze 0.2
09:59:53 <dolio> Well, apparently the report doesn't even define a special case for 'do var <- m ; ...'.
10:00:24 <dolio> I suppose it's possible that GHC recognizes some unfailable patterns and optimizes for them, but it's not required to.
10:00:37 <EvilTerran> ah well
10:00:48 <EvilTerran> if i'm using NoImplicitPrelude, i'm tied to ghc anyway
10:02:05 <dolio> And I don't know where @undo got its algorithm from, so I don't know if it accurately represents what GHC does or nto.
10:02:55 <chessguy_work> err, if i want a haskell program to return a string to the shell for something, how would i go about that?
10:03:16 <chessguy_work> i.e., i want a haskell program whose results i can pipe into another program
10:04:10 <tromp_> try writing to stdout, e.g. putStr
10:05:03 <EvilTerran> ghci> :t \m -> do x <- m; return x
10:05:04 <EvilTerran> \m -> do x <- m; return x :: (Monad t) => t t1 -> t t1
10:05:04 <EvilTerran> ghci> :t \m -> do Just x <- m; return x
10:05:04 <EvilTerran> \m -> do Just x <- m; return x :: (MonadFail t) => t (Maybe t1) -> t t1
10:05:07 <EvilTerran> ^ it seems to work
10:05:37 <EvilTerran> altho i thought it didn't initially, as i needed to :set -XNoImplicitPrelude to get away from the Prelude.Monad constraint
10:06:06 <dolio> Cool. I do seem to recall it being brought up and people talking about making it work, but I didn't know it'd been done.
10:06:15 <maltem> good to see it works - warm fuzzy feelings come up :)
10:06:15 <EvilTerran> i'm tempted to do that now
10:06:19 <dolio> How about (a,b,c)?
10:06:27 <EvilTerran> although i'm not sure how appropriate it'd be in a serious project
10:07:06 <EvilTerran> \m -> do (x,y) <- m; return (y,x) :: (Monad t) => t (t1, t2) -> t (t2, t1)
10:07:23 <dolio> Huh, well I'll be.
10:07:29 <EvilTerran> i'm surprised too <.< >.>
10:07:31 <dolio> We can resurrect haskell 1.4.
10:08:06 <maltem> yay for monads that won't fail!
10:08:08 <EvilTerran> it works for single-constructor datas and newtypes too
10:08:25 <dolio> newtypes aren't a surprise, since they're irrefutable.
10:08:49 <EvilTerran> datas are as surprising as tuples, although doing one but not the other would feel inconsistent
10:09:34 <dolio> Yeah.
10:09:36 <EvilTerran> i'm tempted to get completely sidetracked now and flesh this out :P
10:10:31 <dolio> If there's one thing Haskell needs to catch on, it's a fork of the standard libraries.
10:11:31 <EvilTerran> i'm now noticing that it'd be nice if ghci took notice of the LANGUAGE pragma in directly-loaded modules
10:12:04 <EvilTerran> although that could get confusing, i guess
10:12:13 <dolio> It does some of them, no? But it seems inconsisten to me which ones it picks up.
10:13:04 <EvilTerran> it doesn't pick up TemplateHaskell or NoImplicitPrelude, at least
10:13:19 <dolio> I think the main one that's bugged me is TypeOperators.
10:13:29 <dolio> I load modules using that and then get bitten.
10:14:11 <dolio> Whereas it seems to me that Rank2Types gets picked up when you load a module with it.
10:14:15 <dolio> But maybe I'm imagining things.
10:16:24 <dolio> I guess I'm wrong. It doesn't work.
10:18:03 <EvilTerran> so... yeah. it doesn't pick any up, and it should pick them all up, imo :)
10:18:19 <dolio> It'd save me a fair amount of hassle.
10:19:57 <hugo__> hmm
10:37:29 <EvilTerran> dolio, i guess it'd only work for interpreted modules, though
10:43:52 <mmorrow> , [|\m -> do x <- m ; return x|]
10:43:55 <lunabot>  LamE [VarP m_0] (DoE [BindS (VarP x_1) (VarE m_0),NoBindS (AppE (VarE ret...
10:44:22 <mmorrow> , (\(LamE _ e)->e) [|\m -> do x <- m ; return x|]
10:44:23 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
10:44:23 <lunabot>         against inferred type `Language.Haskell.TH.Syntax.Q
10:44:23 <lunabot>                                  Language.Haskell.TH.Syntax.Exp'
10:44:31 <mmorrow> , (\(LamE _ e)->e) `fmap` [|\m -> do x <- m ; return x|]
10:44:32 <lunabot>  DoE [BindS (VarP x_1) (VarE m_0),NoBindS (AppE (VarE return) (VarE x_1))]
10:45:12 <sbahra> wow
11:02:48 <sbahra> haskell wasn't even on the wikipedia programming language list
11:02:57 <Beelsebob> o.O
11:03:00 <Beelsebob> I take it it is now?
11:03:15 <sbahra> yes
11:04:13 <hugo_> today im in a strange anti-stress mood
11:04:22 <hugo_> and started wondering about little things in life...
11:04:41 <hugo_> ...do you guys think haskell will have a role on the programming languages we will have 30 years from now ?
11:05:08 <hugo_> :/
11:05:22 <BONUS_> role? dunno. influence? yeah.
11:05:39 <BONUS_> although 30 years from now is a very, very long time
11:05:42 <hugo_> yes role/influence/grain of salt
11:05:49 <hugo_> yes, precisely
11:06:11 <hugo_> we will all have a chip, and no privacy :P
11:07:29 <hugo_> i want to do a function that searches a list for a given pattern, but this list is generated the first time the search function is called, then it is used throughout... how do i do it ?
11:08:03 <hugo_> i was thinking in doing it a certain way, but seems to me that it is not functional :/
11:08:05 <sbahra> functional programming
11:09:15 <rwbarton> hugo_: Perhaps you can write it in the form   search = let pattern = ... in \list -> search' pattern list
11:11:13 * sbahra is attending a lecture by Hoare later today
11:11:18 <sbahra> ;D
11:11:22 <qebab> cool
11:11:44 <dolio> Wow.
11:12:27 <qebab> I wonder why these guys never show up here in north coldland
11:12:40 <hugo_> who is hoare ?
11:12:52 <dolio> The quicksort guy.
11:12:53 <abbe> C.A.R. Hoare, the inventor of QuickSort, hmm...?
11:12:58 <hugo_> oh
11:13:09 <hugo_> total respect then :)
11:13:36 <dolio> And Hoare logic, and CSP...
11:14:39 <sbahra> CSP is so ugly
11:14:45 <mmorrow> i think i got do desugaring with th: http://hpaste.org/10849
11:14:48 <b_jonas> I reinstalled ghc (6.8.3 this time) from source
11:14:49 <sbahra> But I definitely want to learn it.
11:15:03 <b_jonas> but cabal packages will still try to get installed to the wrong place
11:15:06 <sbahra> I tried to formalize the notion of fairness (in a much more descriptive sense) with TLA+, and failed.
11:15:07 <sbahra> TLA
11:15:10 <dolio> You more of a pi calculus person?
11:15:14 <b_jonas> so I have some stupid questions
11:15:29 <sbahra> TLA isn't so expressive compared to CSP, but I haven't seen *any* notions of fairness in CSP.
11:15:45 <b_jonas> if I install a cabal package, can multiple ghc installations use it or just one?
11:15:54 <b_jonas> if multiple can, does that work for different minor versions too?
11:16:02 <sbahra> Oh
11:16:09 <sbahra> That CSP :-)
11:16:20 <b_jonas> that is, does ghc have a compatible interface towards installed modules?
11:16:26 <sbahra> I was talking about Concurrent Separation Logic (built on Hoare logic).
11:17:07 <dolio> Oh. No.
11:18:09 <FunctorSalad> @dict-all TLA
11:18:10 <lambdabot> Unknown command, try @list
11:18:28 <dolio> Too many CSPs.
11:18:30 <Randroid> How do I find the current working directory? I looked in System.IO (and even System.FilePath) couldn't find anything.
11:18:31 <FunctorSalad> that should be an alias for all-dicts :)
11:18:40 <Zao> Randroid: System.Directory
11:18:48 <Randroid> Zao: Ah! Duh. Thanks!
11:18:52 <FunctorSalad> import HSH; run "pwd"
11:18:53 <FunctorSalad> :)
11:19:16 <dolio> @vera CSP
11:19:18 <lambdabot> *** "csp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:19:18 <lambdabot> CSP
11:19:18 <lambdabot>      Cross System Product (IBM)
11:19:18 <lambdabot>  
11:19:18 <lambdabot> *** "csp" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:19:19 <lambdabot> [11 @more lines]
11:21:04 <Axman6> bleh, how do i get an intagral value from a floating value?
11:21:20 <Axman6> i swear i have to do this every second day, and i always forget how to do it
11:21:20 <Deewiant> @hoogle (Integral a, Floating b) => a -> b
11:21:21 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:21:22 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:21:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:21:24 <dolio> @type (floor, ceiling, round, truncate)
11:21:25 <Deewiant> darn
11:21:25 <lambdabot> forall a b a1 b1 a2 b2 a3 b3. (Integral b3, RealFrac a3, Integral b2, RealFrac a2, Integral b1, RealFrac a1, Integral b, RealFrac a) => (a -> b, a1 -> b1, a2 -> b2, a3 -> b3)
11:21:38 <Deewiant> @hoogle (Integral a, Fractional b) => a -> b
11:21:40 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
11:21:40 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
11:21:40 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
11:21:42 <Deewiant> hmm
11:21:53 <Deewiant> right
11:21:56 <Deewiant> the other way around
11:22:06 <Deewiant> I was wondering why it didn't find anything useful :-P
11:22:14 <rwbarton> RealFrac is the magic word
11:22:25 <Axman6> it is
11:22:34 <Axman6> :t sqrt
11:22:35 <lambdabot> forall a. (Floating a) => a -> a
11:22:49 <rwbarton> @src RealFrac
11:22:50 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
11:22:50 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
11:22:50 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
11:22:51 <Axman6> :t fromIntegral
11:22:52 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:23:15 <Deewiant> RealFrac not needed
11:23:17 <rwbarton> > sqrt (3 :+ 4)
11:23:18 <Deewiant> @hoogle (Integral b, Floating a) => a -> b
11:23:19 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
11:23:19 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
11:23:19 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
11:23:19 <lambdabot>   2.0 :+ 1.0
11:23:28 <Deewiant> works fine if you get it the right way around :-P
11:23:44 <Axman6> Deewiant: the thing is it doesn't work fine
11:23:54 <Axman6> round doesn't work
11:24:05 <Deewiant> how not
11:24:10 <Deewiant> > round 2.5
11:24:12 <lambdabot>   2
11:24:13 <Deewiant> looks good to me :-P
11:24:19 <rwbarton> Works in the sense that hoogle will figure out what you mean
11:24:39 <Axman6> ok... maybe i dies when i quit using . and start using $
11:24:55 <Axman6> i have never successfully used (.) and that annoys me a lot
11:25:44 <Axman6> anyway, sleep time. night all
11:27:06 <BONUS_> hmmm
11:27:21 <BONUS_> is there like a designated charity for the haskell community
11:27:28 <BONUS_> like the vim community usually donates to uganda children
11:29:29 <Lord_Illidan> When using the not command, for instance takeWhile (not.(==5)) [3,3,3,34], the composition operator is necessary as the elements from the list are compared to the ==5 and then the result passed to not, right?
11:29:52 <BONUS_> yes
11:29:55 <BONUS_> or you could do
11:30:05 <Deewiant> ?src (/=)
11:30:06 <lambdabot> x /= y = not (x == y)
11:30:08 <BONUS_> \x -> not ((==5) x)
11:30:14 <BONUS_> or /= yes
11:30:15 <BONUS_> lol
11:31:28 <Lord_Illidan> bah
11:31:30 <Lord_Illidan> ok
11:31:32 <Lord_Illidan> 10
11:31:33 <Lord_Illidan> 10x
11:34:22 <kaol> @src (>=>)
11:34:22 <lambdabot> Source not found. Maybe you made a typo?
11:35:31 <ski> > sqrt (0 :+ (-2))
11:35:32 <lambdabot>   1.0 :+ (-1.0)
11:51:01 <zachk> how do i write 6.67*10^(-11) as a double in haskell
11:51:15 <Deewiant> > 6.67e-11
11:51:16 <b_jonas> > 6.67e-11 :: Double
11:51:17 <lambdabot>   6.67e-11
11:51:18 <lambdabot>   6.67e-11
11:51:24 <zachk> thank you
11:51:27 <Deewiant> > 6.67*10^(-11)
11:51:29 <lambdabot>   * Exception: Negative exponent
11:51:33 <Deewiant> > 6.67*10^^(-11)
11:51:35 <lambdabot>   6.67e-11
11:52:39 <b_jonas> if I learnt haskell ffi and had questions about it, would this be the right channel for them?
11:53:30 <BONUS_> but of course
12:03:11 <Zao> Is HDirect a sane route to go if I want to do COM, or is it ancient and deprecated?
12:03:18 <Zao> The latest release seems to be in 2004.
12:05:08 <monochrom> There has not been another, new route anyway.
12:05:52 <monochrom> Certain HDirect code may need change to match the current GHC and libraries.
12:06:08 <Zao> -cafe@
12:06:19 <Zao> meantions hscom, but it seems a bit too slim.
12:06:28 * Zao curses C-M
12:10:15 <dolio> Lots of new lambda cats lately.
12:11:32 <dmead> ?src scanr
12:11:33 <lambdabot> scanr _ q0 []     =  [q0]
12:11:33 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
12:11:33 <lambdabot>     where qs@(q:_) = scanr f q0 xs
12:12:05 <dmead> > scanr (+) [1..10]
12:12:07 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
12:12:07 <lambdabot>        arising from a u...
12:12:44 <dolio> > scanr (*) 1 [1..10]
12:12:45 <lambdabot>   [3628800,3628800,1814400,604800,151200,30240,5040,720,90,10,1]
12:13:10 <dmead> >scanr (-) 1 [1..30]
12:13:15 <dmead> > scanr (-) 1 [1..30]
12:13:16 <lambdabot>   [-14,15,-13,16,-12,17,-11,18,-10,19,-9,20,-8,21,-7,22,-6,23,-5,24,-4,25,-3,...
12:19:47 <Zao> package lang, GlaExts and IOExts, heh.
12:20:15 <Zao> I have a feeling that this code predates hierarchial modules.
12:20:59 <leimy> > :t fmap
12:20:59 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
12:20:59 <lambdabot>  ...
12:21:08 <leimy> :t fmap
12:21:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:21:12 <leimy> :t map
12:21:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:21:34 <b_jonas> dolio: wow, I just checked it a few days ago and then there were only two new ones
12:21:39 <leimy> I'm not sure I understand Functor :-)
12:21:41 <b_jonas> dolio: thanks for the notice
12:21:58 <dolio> Dude, you need to subscribe to the RSS feed!
12:21:59 <b_jonas> and now tehre are three
12:22:21 <b_jonas> that is, one more
12:25:04 <visof> > let factors x = [ a | a <- [2..((round.sqrt) x)], mod x a == 0 ] in 10
12:25:06 <lambdabot>   10
12:25:16 <visof> > let factors x = [ a | a <- [2..((round.sqrt) x)], mod x a == 0 ] in factors 10
12:25:17 <lambdabot>   Add a type signature
12:25:53 <visof> > let factors x = [ a | a <- [2..((round.sqrt) x)]], mod x a == 0 ] in factors 10
12:25:53 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 57}
12:25:53 <lambdabot> ...
12:26:13 <visof> > let factors x = [ a | a <- [2..((round.sqrt) x)], mod x a == 0 ] in factors 10
12:26:14 <lambdabot>   Add a type signature
12:26:22 <visof> > let factors x = [ a | a <- [2..x)], mod x a == 0 ] in factors 10
12:26:22 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 40}
12:26:23 <lambdabot> ...
12:26:32 <visof> > let factors x = [ a | a <- [2..x], mod x a == 0 ] in factors 10
12:26:33 <lambdabot>   [2,5,10]
12:26:52 <visof> what is the problem about (round.sqrt) x ?
12:27:02 <visof> > (round.sqrt) 30
12:27:04 <lambdabot>   5
12:27:13 <visof> > (round.sqrt) 100
12:27:14 <lambdabot>   10
12:27:29 <vixey> :t (floor . sqrt . fromIntegral)
12:27:30 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
12:27:36 <EvilTerran> don't do that
12:27:39 <vixey> :t (round . sqrt)
12:27:40 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
12:28:17 <dolio> @type mod
12:28:18 <lambdabot> forall a. (Integral a) => a -> a -> a
12:28:22 <EvilTerran> there really should be a O(log n) integer sqrt in the stdlib, imo
12:28:36 <EvilTerran> people seem to need it frequently
12:28:40 <dolio> You're asking for x to be both Integral and Floating and RealFrac.
12:29:03 <EvilTerran> and it looks bad to say "don't convert to floating point and back, use this O(sqrt n) search instead!"
12:29:04 <dolio> And there's no default for that.
12:29:12 <dolio> (No type, really.)
12:29:59 <idnar> so why does it work?
12:30:21 <Deewiant> ?ty (round.sqrt) 30
12:30:23 <lambdabot> forall b. (Integral b) => b
12:30:23 <vixey> it doesn't work in theory, and that's all that matters
12:30:34 <idnar> oh nevermind
12:30:43 <EvilTerran> it works if the return type and parameter type aren't required to be the same
12:30:46 <idnar> I misunderstood what was being discussed
12:33:06 <EvilTerran> > let factors n = [i | i <- takeWhile ((<=n).(^2)) [1..], n `mod` i == 0] in map factors [1..]
12:33:08 <lambdabot>   [[1],[1],[1],[1,2],[1],[1,2],[1],[1,2],[1,3],[1,2],[1],[1,2,3],[1],[1,2],[1...
12:34:17 <EvilTerran> > let isPrime n = null [i | i <- takeWhile ((<=n).(^2)) [2..], n `mod` i == 0] in filter isPrime [2..]
12:34:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:34:54 <Deewiant> > Set.empty
12:34:55 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:34:56 <Deewiant> :-/
12:35:48 <b_jonas> > S.empty
12:35:48 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:35:57 <b_jonas> > S.fromList []
12:35:58 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:36:07 <Deewiant> > S.foo
12:36:08 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:36:15 <Deewiant> > Foo.foo
12:36:16 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:36:32 <rwbarton> > empty
12:36:34 <lambdabot>       Ambiguous occurrence `empty'
12:36:34 <lambdabot>      It could refer to either `Text.Pretty...
12:37:35 <b_jonas> > 1 + 5
12:37:37 <lambdabot>   6
12:37:48 <b_jonas> > map (2+) [3,5]
12:37:50 <lambdabot>   [5,7]
12:43:17 <dblazakis> @src (^)
12:43:17 <lambdabot> x ^ 0            =  1
12:43:18 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:43:18 <lambdabot>   where f _ 0 y = y
12:43:18 <lambdabot>         f x n y = g x n
12:43:18 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:43:19 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:43:21 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:44:01 <sbahra> ew
12:44:16 <sbahra> isn't there some "native" one?
12:45:20 <RayNbow> :t (**)
12:45:22 <lambdabot> forall a. (Floating a) => a -> a -> a
12:45:28 <RayNbow> :t (^)
12:45:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:46:22 <dblazakis> @src (^^)
12:46:22 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
12:46:36 <dblazakis> @src (**)
12:46:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:48:05 <rwbarton> I wish it would say something like  class (...) => Floating a where ...; (**) :: a -> a -> a; ...
12:49:23 <dblazakis> @info
12:49:23 <lambdabot> ()
12:49:28 <dblazakis> @info #haskell
12:49:29 <lambdabot> (# haskell)
12:50:17 <dblazakis> @users
12:50:17 <lambdabot> Maximum users seen in #haskell: 516, currently: 513 (99.4%), active: 15 (2.9%)
12:50:39 <rwbarton> also there needs to be a "what are you spell-correcting this command to" command :)
12:51:13 <dolio> @info do a <- m ; b <- n ; return (a,b)
12:51:13 <lambdabot> m >>= \ a -> n >>= \ b -> return (a, b)
12:51:24 <rwbarton> dolio wins
12:51:43 <dolio> @yow!
12:51:43 <lambdabot> BARRY ... That was the most HEART-WARMING rendition of "I DID IT MY
12:51:43 <lambdabot> WAY" I've ever heard!!
12:51:59 <olsner> +1, abuse of spell-correction
12:52:12 <olsner> dolio++ :)
12:52:13 <rwbarton> :info (**)
12:52:27 <seliopou> :info (***)
12:52:37 <seliopou> @info (***)
12:52:38 <olsner> :foo bar (**)
12:52:38 <lambdabot> (***)
12:53:03 <b_jonas> @help ungoogle
12:53:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:53:07 <b_jonas> @help cogoogle
12:53:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:53:28 <b_jonas> is there a way to know the real name of the command if you know the misspelt but spelling-connected one?
12:54:09 <dolio> Not that I'm aware of.
12:54:19 <rwbarton> b_jonas: I don't think so, that's what I proposing.  Probably @help ought to do it.
12:54:23 <rwbarton> *I was
12:54:41 <chrisdone> the bot would rather keep you in ignorance in preperation for the rapture
12:54:48 <dolio> I've just been around here too long.
12:55:11 <dolio> @botcrack
12:55:11 <lambdabot> :)
12:55:24 <chrisdone> @botsmack
12:55:25 <lambdabot> :)
12:55:31 <olsner> @vixen you on drugs!?
12:55:31 <lambdabot> why, you selling something?
12:55:57 <olsner> oh, how depraved, our sweet sweet lambdabot
12:56:49 <rwbarton> @unpf ap
12:56:49 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
12:56:58 <rwbarton> Shouldn't it go the other way?
12:57:23 <dolio> Wow.
12:57:46 <dolio> That's pretty extreme.
12:58:35 <olsner> @do (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
12:58:35 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a)) not available
12:59:08 <rwbarton> I was trying to suggest that the name @unpf was wrong
12:59:26 <dolio> @unpl ap
12:59:26 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
12:59:31 <rwbarton> @help unpx
12:59:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:59:33 <rwbarton> @help unpf
12:59:34 <lambdabot> pointful <expr>. Make code pointier.
12:59:41 <dblazakis> @help info
12:59:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:59:52 <dblazakis> damn, thought that might work
13:00:32 <dolio> @. unpl pl \f g x -> f x (g x)
13:00:32 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:00:33 <olsner> @undo ap
13:00:33 <lambdabot> ap
13:01:30 <dblazakis> how does lambdabot spell correct? edit distance?
13:02:00 <dolio> Yes. It gets to change/add/subtract 2 characters.
13:02:01 <olsner> I like how pl makes the type more general so that unpl can't fold it back into its original form (although... doesn't ap have the more general type from the start?)
13:02:35 <dolio> Yeah, the unpl for ap is valid, althoug it's kind of gratuitous.
13:02:50 <dolio> @. unpl pl \mf ma -> ap mf ma
13:02:50 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:02:56 <rwbarton> @. redo unpl ap
13:02:57 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
13:03:57 <olsner> hmm, liftM2 id?
13:04:12 <dolio> @src ap
13:04:12 <lambdabot> ap = liftM2 id
13:04:18 <olsner> d'oh :)
13:21:46 <b_jonas> maybe when you misspell a command, it should just tell you about the correct spelling like it does when it's ambiguous instead of running the corrected command
13:21:50 <b_jonas> @sl
13:21:51 <lambdabot> I don't perform such side effects on command!
13:21:56 <b_jonas> @tp
13:21:56 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc thx type v wn
13:22:44 <rwbarton> @sl ap
13:22:45 * lambdabot submits ap's email address to a dozen spam lists
13:23:06 <b_jonas> @?
13:25:45 <dblazakis> @help ?
13:25:46 <lambdabot> ? [args].
13:25:46 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
13:25:46 <lambdabot>  The commands are right associative.
13:25:46 <lambdabot>  For example:    ? ?pl ?undo code
13:25:46 <lambdabot>  is the same as: ? (?pl (?undo code))
13:40:01 <Jarvellis> are there any small compiler/interpreters for haskell?
13:40:09 <thoughtpolice> there is hugs
13:40:11 <thoughtpolice> and nhc98
13:40:31 <Jarvellis> does nhc98 compile?
13:40:55 <Jarvellis> actually nvm, the REPL will do for now
13:44:11 <thoughtpolice> Jarvellis: it does, to a bytecode iirc
13:44:47 <Jarvellis> thoughtpolice, thanks, i'm just playing with the hugs REPL for now, to see if i like the feel of the language
13:45:07 <thoughtpolice> Jarvellis: nhc98 is also apparently the 2nd most featureful haskell compiler next to ghc, and runs more of the nofib benchmarks than any other compiler excluding ghc
13:45:17 <thoughtpolice> s/nofib/nobench/
13:45:35 <thoughtpolice> (including yhc, jhc, and hugs)
13:46:00 <Jarvellis> is ghc really 250MB or is arch being daft?
13:46:40 <thoughtpolice> Jarvellis: with all of the extralibs it's possible
13:46:42 <Igloo> Sounds possible for ghc+extralibs on a 64bit arch
13:50:33 <MedeaMelana> Hiya
13:50:42 <dcoutts> the ghc lib dir on a 6.10 build is 210Mb for me, on 32bit
13:51:01 <Ferdirand> hello
13:51:06 <BMeph> Where is the unpl code? :)
13:51:15 <Jarvellis> that's bigger than emacs
13:51:16 <BMeph> And shouldn't it be "copl? ;p
13:51:30 * Jarvellis didn't think anything was bigger than emaca
13:52:39 <b_jonas> BMeph: yeah, and codo too
13:53:24 <byorgey> hi MedeaMelana
13:59:56 <dblazakis> can you do extensible unions in Haskell? like in the modular interpreters paper...
14:05:29 <matthew-_> dblazakis: err, I don't understand those terms. What do you mean by an "extensible union" as a language construct?
14:08:35 <dblazakis> matthew-_: hrm, so, being able to have a union type which consists of a union of many distinct types, and being able to inject to and project from that union type based on the type you are injecting or projecting to
14:09:06 <matthew-_> ahh
14:09:20 <matthew-_> maybe type classes with functional dependencies are what you're after
14:09:29 <matthew-_> fundeps or associated data types
14:09:44 <matthew-_> or in fact just type families maybe more useful
14:11:15 <matthew-_> but, last time I remember looking at union types was wrt -calculus, and I can't remember enough details
14:12:48 <rwbarton> I think there was a Functional Pearl about extensible unions
14:13:09 <djsiegel> Does anyone know of a Haskell solution for using libnotify?
14:13:09 <dblazakis> ah, i'll take a look for it
14:13:24 <mauke> IIRC there's something on hackage
14:13:24 <matthew-_> djsiegel: yes, there's a hackage package
14:13:30 <matthew-_> by adam langley
14:13:34 <mauke> I also have a self-written binding
14:14:10 <matthew-_> I know for a fact that adam's not supporting those packages any more, so if it doesn't do what you need, probably best to bug mauke  ;)
14:14:10 <djsiegel> mauke, that's inotify.
14:14:15 <rwbarton> "Data Types a la Carte"
14:14:21 <mauke> oh, oops
14:14:23 <djsiegel> I want libnotify, the displaying notifications in GNOME.
14:14:26 <dblazakis> here's what i had, http://hpaste.org/10851
14:14:41 <mauke> then no :/
14:14:53 <djsiegel> Shoot.
14:15:05 <EvilTerran> dblazakis, have you looked at Oleg's HList paper?
14:15:08 <EvilTerran> ?where hlist
14:15:08 <lambdabot> http://homepages.cwi.nl/~ralf/HList
14:15:08 <rwbarton> dblazakis: Yes, something like that, though maybe you need some functional dependencies, I don't recall.
14:15:34 <EvilTerran> dblazakis, i believe that has something similar
14:15:44 <matthew-_> yeah, even with overlapping instances turned on, that'd blow up
14:15:48 <EvilTerran> dblazakis, for a different approach, have a look at
14:15:53 <EvilTerran> @go data types a la carte
14:15:57 <lambdabot> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=1899160
14:15:57 <lambdabot> Title: CJO - Abstract - Data types  la carte
14:16:29 <EvilTerran> er, http://wadler.blogspot.com/2008/02/data-types-la-carte.html
14:16:30 <lambdabot> Title: Wadler's Blog: Data Types a la Carte
14:16:35 <dblazakis> ah thanks, perfect, "type based access"
14:24:19 <hugo__> is there any haskell wrapper for yaml ?
14:25:16 <hugo__> oh, i just found it :)
14:25:27 <hugo__> i really should learn to use hackage more often
14:26:16 <quicksilver> hugo__: I have http://hackage.haskell.org/packages/archive/pkg-list.html open permanently in a tab :)
14:26:17 <lambdabot> Title: HackageDB: packages by category
14:26:27 <quicksilver> then it's just a browser search command away.
14:26:37 <quicksilver> And http://www.haskell.org/ghc/docs/latest/html/libraries/ in another one.
14:26:37 <hugo__> :D
14:26:38 <lambdabot> Title: Haskell Hierarchical Libraries
14:26:50 <hugo__> i just added a firefox keyword for hackage its the 'h' key :)
14:27:08 <hugo__> ohh
14:27:13 <hugo__> nice hints quicksilver :D
14:31:17 <matthew-_> hmmm. is there not a cabal search command?
14:31:25 <thoughtpolice> cabal list
14:31:40 <dcoutts> matthew-_: perhaps cabal list will do, it only looks through names, not all metadata
14:31:58 <dcoutts> but it does do substring search on all package names
14:32:03 <matthew-_> hmm, not with the > 1 sec start up time it won't. Even ff is faster that that ;)
14:33:07 <matthew-_> what is the file format optimised for?
14:33:17 <dcoutts> the file format is tar
14:33:34 <dcoutts> but the slow one is the installed packages
14:33:47 <dcoutts> which is several 100k of Read/Show text
14:33:57 <matthew-_> ewwww
14:34:05 <dcoutts> if we only searched available, rather than installed packages it'd be instant
14:34:19 <dcoutts> ghc-pkg is too slow, that's the issue
14:34:23 <b_jonas> ok, good night now
14:34:25 <matthew-_> I can give you damn fast linear hash table implementation so that you can build indexes
14:34:41 <matthew-_> but really seeing as you'll be doing range queries you want a b-tree disk index
14:34:48 <dcoutts> matthew-_: that doesn't help us unfortunately because we do not control the ghc-pkg db format
14:35:00 <matthew-_> dcoutts: mmm. you need to control more ;)
14:35:19 <dcoutts> matthew-_: but if you'd like to fix ghc's package db format that'd be great, there are some open tickets on it
14:35:28 <thoughtpolice> eventual cabal plan: world domination
14:35:35 <thoughtpolice> of course that is the plan of #haskell all the time.
14:35:39 * matthew-_ checks his calendar for a month of free time.
14:35:42 <dcoutts> yup
14:35:43 <SamB_XP> who had the bright idea of letting ghc-hq control ghc-pkg ?
14:35:50 <dcoutts> heh heh
14:35:51 * matthew-_ finds something around May 2015
14:36:05 <dcoutts> matthew-_: right, like the rest of us
14:36:21 <matthew-_> wow, that'll be an awesome month
14:36:29 <matthew-_> we'll all fix *everything*
14:36:49 <matthew-_> May 2015: the month of the Haskell revolution
14:37:08 <SamB_XP> huh, my calander doesn't even include today properly
14:37:21 <matthew-_> mmm, actually, the ICFP deadline is likely to be around then
14:37:56 <younder> Funny tought that was when Knuth finished "The art of computer programming"...
14:38:05 <matthew-_> although, if I'm still trying to write papers in 7 years' time, can someone please shoot me?
14:38:21 <thoughtpolice> where?
14:38:32 <SamB_XP> when is knuth scheduled to die then?
14:38:40 <younder> lol
14:38:48 <thoughtpolice> never, it seems.
14:38:51 <Botje> when he finishes TaoCP
14:38:58 <SamB_XP> I guess he doesn't have time to die ?
14:39:01 <Botje> why'd you think he's stretching it so long?
14:39:05 <Zao> SamB_XP: You can't know if he will halt or not.
14:39:27 <younder> Look it up on his webcite
14:39:36 <SamB_XP> lol
14:39:38 <SamB_XP> webcite
14:40:19 <sbahra> amamamama
14:40:22 <sbahra> mamamia
14:40:27 <thoughtpolice> there is no knuth,
14:40:29 <thoughtpolice> only ZUUL!
14:43:37 <SamB_XP> did you know that Mozilla's ".xul" format appears to be named after zuul ?
14:44:13 <thoughtpolice> brownie points for that.
14:44:15 <mauke> http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
14:45:08 <dblazakis> i think somone needs to start making a haskell-ish podcast -- my 45 minute ride home would be a lot more interesting
14:45:48 <SamB_XP> the namespace URL, at least, is, clearly
14:46:10 <matthew-_> we just need a bot that can read the source code
14:46:18 <matthew-_> and speak it
14:46:22 <dblazakis> like software engineering radio, but not...
14:46:22 <matthew-_> and broadcast that
14:46:25 <EvilTerran> funnel the Monad.Reader through a text-to-speech thing?
14:47:10 <dblazakis> i would officially donate some money if someone starting doing a interview podcast
14:47:12 <SamB_XP> we could run animations of SPJ through IFFT sight-for-blind software ;-)
14:47:31 <mauke> EM GREATER THAN GREATER THAN EQUALS EFF
14:47:43 <matthew-_> oh how we'd laugh
14:47:51 <dblazakis> worst ride home ever
14:47:53 <matthew-_> the enlightenment, the revelations, the jokes
14:48:05 <matthew-_> the witty comments
14:48:08 <matthew-_> the parse errors
14:48:23 <SamB_XP> how about just a HWN podcast?
14:48:41 <matthew-_> It should be done like the shipping forecast
14:50:55 <kowey> any hpc people around?
14:51:05 <kowey> if so, you might be interested in this  : http://lists.osuosl.org/pipermail/darcs-users/2008-October/014227.html
14:51:08 <lambdabot> Title: [darcs-users] darcs patch: fix tests to sort of work with hpc., http://tinyurl.com/4aalyb
14:52:06 <kowey> darcs has had hpc for some time, thanks to christopher l. hinson ; this updates our regression tests to see how much of darcs they are actually exercising
14:53:01 <thoughtpolice> hpc is dandy stuff
14:58:30 <hackage> Uploaded to hackage: hgalib 0.2
15:00:41 <kowey> hpc is dandy indeed... as are hoogle, hscolour, haddock and various steps we are making towards making full use of the haskell community's offerings :-)
15:01:12 <kowey> i suppose we should automate our hpc use, generate these stats automatically and stick them on the web for devs to scrutinise
15:19:21 <tristes_tigres> Hi
15:21:04 <dons> ?users
15:21:05 <lambdabot> Maximum users seen in #haskell: 516, currently: 484 (93.8%), active: 4 (0.8%)
15:21:58 <tristes_tigres> 500 users and only 4 talking ? what's up with that
15:22:29 <Peaker> people join #haskell to listen
15:22:35 <Peaker> to the pearls of wisdom
15:22:44 <mauke> preflex: quote
15:22:44 <preflex>  <dcoutts> kolmodin and I considered implementing lolcode in the small step semantics style, including how to simulate lolcode io purely
15:23:32 <tristes_tigres> lol-code ? Is that what freshment turn in at their programming assignemnts ?
15:23:44 * dcoutts notes that it'd be a good fun exercise for someone trying to understand operational semantics
15:24:19 <Twey> tristes_tigres: http://en.wikipedia.org/wiki/LOLCODE
15:24:20 <lambdabot> Title: LOLCODE - Wikipedia, the free encyclopedia
15:24:41 <dcoutts> tristes_tigres: HAI CAN HAVE sdtio? KTHKBAI
15:25:25 <dcoutts> it's a very simple pascal style language with lol syntax
15:25:27 <SamB_XP> tristes_tigres: no ... it's what lolcats turn in
15:25:40 * tristes_tigres wrote his fair share of lol-code, but it was in conventional languages
15:26:18 <Peaker> tristes_tigres: that's called wtfcode
15:27:01 <tristes_tigres> peaker: Isn't wtfcode something that only wizards can understand ?
15:28:01 <Peaker> internet wizards?
15:28:03 <mauke> may I direct you to thedailywtf.com?
15:29:06 <tristes_tigres> mauke: tnks for the reminder, I seen it once but then lost the ref
15:30:11 <keseldude> how do I use backreferences with Text.Regex.Posix?
15:30:36 <dons> you don't.
15:30:39 <dons> use Text.Regex.PCRE
15:30:41 <dons> or pcre-light
15:30:47 <keseldude> ah
15:30:49 <keseldude> thanks
15:30:50 <dons> (or try using \1 \2 \3 ...)
15:30:52 <SamB_XP> yeah, the correct question is "can I has backreferences?"
15:31:00 <dons> but using PCRE is just more sensible
15:31:05 <SamB_XP> er.
15:31:16 <SamB_XP> I can has backreferensez?
15:31:21 <keseldude> \1 doesn't work for some reason
15:31:28 <keseldude> with Text.Regex.Posix
15:31:29 <mauke> 
15:31:44 <SamB_XP> mauke: why the funky letters ?
15:31:59 <mauke> because I can!
15:32:03 <lispy> parsec: it's what's for parsing.
15:32:05 <Cale> mauke: I think I might have asked this before, but do you have Japanese or Chinese support installed?
15:32:21 <SamB_XP> > ""
15:32:22 <RayNbow> 
15:32:23 <lambdabot>   "\65360\65345\65362\65363\65349\65347"
15:32:25 <mauke> Cale: what does that mean?
15:32:34 <SamB_XP> > ""
15:32:35 <lambdabot>   "\65316\65353\65348\12288\65363\65359\65357\65349\65359\65358\65349\12288\6...
15:32:39 <Cale> mauke: Well, usually it lets you type fullwidth characters like that :)
15:32:52 <dejones> dons: Cool blog entry about the Mersenne prime.  :)
15:33:12 <RayNbow> > ""
15:33:14 <lambdabot>   "\65321\65325\65317\12288\65309\12288\65331\65317\65330\65321\65327\65333\6...
15:33:14 <dons> hehe. well, simple one. but it was a bit nice.
15:33:21 <mauke> Cale: I don't have a special IME
15:33:55 <SamB> ?
15:34:16 <SamB> can has decent font?
15:34:29 <SamB> .
15:34:51 <SamB> ?
15:35:19 <mauke> cany irssi users?c
15:35:47 * Twey reports for duty.
15:35:50 <Twey> 
15:36:16 <mauke> 40e><x>5c52e<5l9=l69e<:n2;t
15:36:21 <RayNbow> Twey: imaasu?
15:36:23 <Botje> MY EYES
15:36:28 <Twey> Argh!
15:36:31 <SamB> apparantly courier works fine
15:36:35 <Twey> But but but
15:36:38 <Twey> We're +c :(
15:36:47 <SamB> Twey: +c?
15:36:50 <Twey> +c!
15:36:51 * lispy stabs mauke for the nasty colors
15:36:57 <SamB> oh
15:36:59 <Twey> SamB: The channel is set to strip colours
15:37:11 <lispy> mauke: I'm an irssi user
15:37:16 <chrisdone> something in one of mmorrow's unicode messages made a purple square appear on my gnome-terminal t'other day
15:37:18 <mauke> I noticed :-)
15:37:19 <sbahra> Epic.Twey
15:37:24 <tristes_tigres>     ?
15:37:28 * Twey waves to sbahra.
15:37:39 <Twey> tristes_tigres: No, I can't see that, wrong encoding
15:37:53 <mauke> Eae ian+,o iiaaaoaee eeoeeeeou ?
15:38:23 <sbahra> mauke, what is p3m?
15:38:31 <Twey> 3pm :)
15:38:35 <stepcut> 
15:38:35 <stepcut>          
15:38:35 <stepcut>            
15:38:35 <stepcut> 
15:38:37 * SamB_irssi want see nasty color
15:38:39 <stepcut>  
15:38:44 * Twey wins the maze!
15:38:56 <mauke> SamB_irssi: 6<a:8s84 >2y89o:2u<8 ?1w=8i1:s81h
15:39:08 <SamB_irssi> nasty!
15:39:14 <tristes_tigres> maybe a client problem ? I use the latest version of miranda for XP
15:39:34 <stepcut> erc does not seem to do anything with the colors
15:39:37 <chrisdone> I like how your maze has no entry
15:39:44 <chrisdone> it makes it so much more challenging
15:39:52 <SamB> nor x-chat
15:39:59 <mauke> sbahra: http://pound-perl.pm.org/about-us/
15:40:00 <lambdabot> Title: pound-perl.pm -- About Us
15:40:00 <stepcut> chrisdone: more fun! You can start and end wherever you want!
15:40:06 <SamB> that's why I wanted to see it in irssi
15:40:08 <stepcut> chrisdone: better replay value
15:40:11 <Twey> tristes_tigres: Likely  try to set the encoding to UTF-8
15:40:19 <Twey> If you can't, get a better client :-P
15:41:03 * SamB sets his input method back to english
15:41:26 <tristes_tigres> Twey - doesn't seem to be any way of doing that
15:42:06 <Twey> Oh ah
15:42:18 <tristes_tigres> oh here is something
15:42:27 <SamB_irssi> I still haveb't decided whether those color codes are worse interpreted or uninterpreted
15:42:34 <Apocalisp> @. uglycolors yarr
15:42:35 <lambdabot> Plugin `compose' failed with: Unknown command: "uglycolors"
15:42:45 <lispy> ?yarr
15:42:46 <lambdabot> I'd like to drop me anchor in her lagoon
15:42:59 <lispy> ?vixen you have an anchor?
15:43:00 <lambdabot> good question
15:43:03 <tristes_tigres> ,     -
15:43:05 <Apocalisp> That plugin is screaming to be written.
15:43:23 <SamB> and we are here screaming at you not to write it ;-P
15:43:24 <lispy> ?version
15:43:25 <lambdabot> lambdabot 4.2.1
15:43:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:43:32 <lispy> Apocalisp: hack away ^^
15:43:47 <tristes_tigres>    ?
15:43:52 <Apocalisp> I'm busy writing HList in Java.
15:44:07 <lispy> Apocalisp: how do you write HList with out type classes?
15:44:16 <r3m0t> AA A A-A AAA AAA?
15:44:17 <Apocalisp> With a lot of pointy brackets.
15:44:38 <lispy> Apocalisp: what java concept do you use inplace of type classes I mean.
15:44:57 <lispy> Apocalisp: I would be surprised if you said generic interfaces
15:45:22 <sjanssen> Java lists are already heterogenous
15:45:32 <leimy> anyone know when GHC 6.10 is slated to be out or is that a "when it's done" situation?
15:45:42 <tristes_tigres> ,   - ?
15:45:49 <Apocalisp> sjanssen: Yes, but we want them to be type-safe.
15:45:50 <SamB_XP> I thought it was a "just before it's done" type situation ?
15:45:50 <lispy> leimy: soon, There is a release date set, I think
15:46:04 <tristes_tigres> lispy: which is ?
15:46:08 <Apocalisp> actually, we just want to see if we can. :)
15:46:13 <tristes_tigres> lispy: Sept 19 ?
15:46:20 <leimy> heh
15:46:31 <SamB_XP> tristes_tigres: heh
15:47:17 <lispy> I don't know, I just recall hearing it would be around the time of ICFP which just happened
15:47:24 <lispy> And tehre have been release candidates, rights?
15:47:34 <Apocalisp> lispy: I'm translating type classes to final generic classes. The typeclass becomes a generic class and instances of the typeclass become methods that return values of the instance type.
15:48:19 <tristes_tigres> lispy: http://www.haskell.org/ghc/dist/stable/dist/
15:48:20 <lambdabot> Title: Index of /ghc/dist/stable/dist
15:48:31 <lispy> Apocalisp: ah, yeah, quite a bit different than my naive idea of it
15:49:00 <lispy> tristes_tigres: ?
15:49:25 <tristes_tigres> lispy: you asked for release candidates for ghc 6.10
15:50:19 <lispy> tristes_tigres: I don't want them.  I was just thinking that they have come out, but I wasn't sure.
15:51:21 <lispy> the reasoning being, that once we start to see release candidates the full release is not far behind :)
15:52:59 <keseldude> dons: so how do the backreferences work now?
15:53:01 <keseldude> Prelude Text.Regex.PCRE> if "http://google.com/hello" =~ "http:\\/\\/(google\\.com.*)" :: Bool then "\1" else "nop"
15:53:24 <mauke> that's not a backreference, that's a capture
15:53:55 <keseldude> well I want to refer to what I captured
15:55:51 <lispy> keseldude: in my experience, regexp capture groups are usually either $n or \n
15:55:57 <lispy> keseldude: so you could try "$1"
15:56:32 * lispy has never tried the Haskell regular expressions
15:56:36 <rwbarton> No, you need a different instance of =~
15:57:09 <rwbarton> case "http://google.com/hello" =~~ "http:\\/\\/(google\\.com.*)" of Just x -> x; _ -> "nop"
15:57:16 <mauke> $1 isn't a valid variable in Haskell
15:57:24 <keseldude> ah
15:57:27 <keseldude> thanks, rwbarton
15:57:30 <rwbarton> (use fromMaybe as desired)
15:57:57 <lispy> :t fromMaybe
15:57:59 <lambdabot> forall a. a -> Maybe a -> a
15:58:08 <lispy> > fromMaybe 1 (Just 2)
15:58:10 <lambdabot>   2
15:58:13 <lispy> > fromMaybe 1 Nothing
15:58:14 <lambdabot>   1
15:59:03 <rwbarton> Uh, that case isn't quite what you want.  I bet it's   Just [x, y] -> y
16:00:19 <keseldude> what if it's already in a case
16:01:13 <keseldude> | url =~~ "http:\\/\\/(google\\.com.*)" -> do return $ "yay"?
16:01:27 <keseldude> er, without the $
16:01:38 <lispy> wow, hpc is not fast :)
16:01:42 <stepcut> heh
16:02:21 <lispy> > "\1"
16:02:23 <lambdabot>   "\SOH"
16:02:38 <lispy> I wonder if that was the problem with recoving your capture group
16:02:42 <lispy> > "\\1"
16:02:44 <lambdabot>   "\\1"
16:02:51 <lispy> > length "\\1"
16:02:53 <lambdabot>   2
16:03:55 <lispy> and, why is '/' escaped?  Is that realy needed?
16:04:08 <keseldude> I think so
16:04:23 <rwbarton> I don't.  Looks like a holdover from perl
16:04:34 <mauke> not really
16:04:36 <rwbarton> (or some other m/.../ language)
16:04:45 <mauke> in perl you'd just use m{http://google\.com/}
16:04:47 <keseldude> well it still comes out as True
16:04:55 * lispy notes that in perl you don't have to surround regexp with /, you can use anything pretty much
16:04:56 <rwbarton> mauke: If you know what you're doing, yeah :)
16:05:05 <mauke> same for vim
16:05:36 <leimy> same for sed
16:05:37 <ziman> and sed, too :)
16:05:42 <leimy> jinx
16:05:53 <EvilTerran> contrapuntal fugue!
16:06:02 <mapreduce> What's the lambdabot command to find the polynomial matching a sequence?
16:06:09 <rwbarton> case "http://google.com/hello" =~~ "http://(google\\.com.*)" of Just (AllTextSubmatches [x, y]) -> y ; Nothing -> "nop"
16:06:11 <jeffz> ziman: some seds only accept /
16:06:24 <lispy> keseldude: so, it's possible 1) your regexp didn't match 2) your caputure group was incorrectly specified.  So let's see your current version?
16:06:27 <EvilTerran> @oeis 1 4 9 16
16:06:28 <lambdabot>  The squares: a(n) = n^2.
16:06:28 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
16:06:48 <mapreduce> EvilTerran: Close, but not the one.
16:07:04 <rwbarton> > ([1,4,9,16]...)
16:07:05 <lambdabot>   Not in scope: `...'
16:07:08 <rwbarton> It's gone
16:07:29 <Philonous> @oeis 3 1 4 1 5 9
16:07:30 <lambdabot>  Decimal expansion of Pi.
16:07:30 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
16:07:34 <Philonous> Wow!
16:07:36 <mapreduce> @oeis 110 107 112 97 114 116
16:07:37 <lambdabot>  Sequence not found.
16:08:09 <Philonous> Ok, actually it's pretty common, I guess
16:08:13 <mapreduce> The command I refer to generates \x -> 3x^16 + 2x^15-...
16:08:22 <mapreduce> @oeis 1 1 1 1
16:08:23 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
16:08:23 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
16:08:25 <EvilTerran> i think that was someone's @let'd function
16:08:26 <ddarius> It was just a function
16:08:31 <mapreduce> ah.
16:08:33 <rwbarton> Oh, I think that was Olathe
16:08:42 <ddarius> It's just a zipWith pretty much
16:08:45 <ziman> @oeis 1 1 1 2 1 1 2 1 1 1 1 1 2 2 1
16:08:46 <lambdabot>  Number of distinct prime factors of n-th odd number.
16:08:46 <lambdabot>  [0,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,2,1,2,1,1,2,1,1,2,1,2,2,1,1,2,2,1,2,1,1,2...
16:09:04 <lispy> "just a zipWith" <-- I bet it was a polynomial then as some here conjectured
16:09:10 <EvilTerran> @oeis 1 11 21 1211 1112221
16:09:11 <lambdabot>  Sequence not found.
16:09:12 <rwbarton> > ([1,4,9,16]...) -- I put it back
16:09:20 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
16:09:25 <EvilTerran> @oeis 1 11 21 1211 111221
16:09:27 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
16:09:29 <EvilTerran> there we go :)
16:09:29 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
16:09:34 <lispy> rwbarton: what's with the onetuple?
16:09:42 <ziman> i decomposed it too much :)
16:09:48 <rwbarton> lispy: :)  I'm using it to solve a new class of problem :)
16:09:50 <EvilTerran> lispy, it's a left-section of (...)
16:09:57 * lispy grins
16:10:20 <EvilTerran> ghc lets you have left-sections of unary functions, even tho the report doesn't
16:10:22 <rwbarton> ghc syntax extension abuse
16:10:27 <EvilTerran> > (1 `Just`)
16:10:28 <lambdabot>   Just 1
16:10:29 <mapreduce> > ([110,107,112,97,114,116]...)
16:10:30 <lambdabot>   [110,107,112,97,114,116,-222,-1682,-5682,-14455,-31228,-60401,-107726,-1804...
16:10:48 <lispy> Oh, hey guys, if you're writing text about types and you have a type like, a x y, how do you refer to x and y other than 'x' and 'y'.  do they have names?  Like the first and second type parameters?
16:10:54 <mauke> > ([]...)
16:10:55 <lambdabot>   * Exception: <local>:10:0-79: Non-exhaustive patterns in function ...
16:10:58 <ziman> > let (!) n = product [1..n] in (6!)
16:10:59 <mapreduce> That's not the same.. it doesn't give a polynomial.
16:11:00 <lambdabot>   720
16:11:04 <mauke> > ([0]...)
16:11:05 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:11:13 <EvilTerran> @oeis 0
16:11:14 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
16:11:15 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:11:17 <EvilTerran> heh
16:11:21 <rwbarton> shortest fib yet :)
16:11:46 <Saizan_> lispy: that sounds right
16:12:16 <Apocalisp> http://rafb.net/p/4YrSh018.html
16:12:18 <lambdabot> Title: Nopaste - Folding an HList
16:12:28 <ddarius> lispy: You can call them whatever you want.
16:12:29 <Apocalisp> worse than the ansi colors :)
16:12:52 <keseldude> http://hpaste.org/10852 this is where I need the regex match
16:12:57 <keseldude> and I'm confused about what to do
16:13:23 <rwbarton> keseldude: you can use a view pattern
16:13:30 <rwbarton> I mean a pattern guard
16:13:42 * lispy finds David Menedez's posts on Haskell-Cafe to be really nice and informative
16:13:58 <ddarius> lispy: Why are you telling us?
16:13:58 <lispy> ddarius: I was hoping there was an established convention
16:14:13 <lispy> ddarius: for his good karma, sack
16:14:15 <lispy> er sake
16:14:35 <ddarius> lispy: Didn't you watch that TED talk I linked to the other day?
16:14:44 <rwbarton> | (Just [AllTextSubmatches [_, y]] <- url =~~ "http:\\/\\/google\\.com(.*)") -> {- do something with y -}
16:15:08 <keseldude> thanks :)
16:16:16 <lispy> ddarius: Probably not, re-link?
16:17:47 <rwbarton> Or in this case you can just write   | (Just y <- stripPrefix "http://google.com" url) -> {- do something with y -}
16:17:48 <lambdabot> Title: Google
16:18:15 <keseldude> heh
16:18:37 <keseldude> that would probably be a lot better
16:18:39 * keseldude facepalms
16:18:48 <keseldude> @hoogle stripPrefix
16:18:49 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
16:20:13 <rwbarton> I think it's new in ghc 6.8
16:28:33 <mmorrow> innnteresting.. http://www.obviously.com/tech_tips/slow_load_technique
16:28:38 <lambdabot> Title: The Slow Load Technique/Reverse AJAX - Simulating Content Push in a Standard Web ...
16:31:19 <lispy> > stripPrefix "blah" "blahfoo"
16:31:20 <lambdabot>   Just "foo"
16:31:29 <lispy> > stripPrefix "blah" "blaafoo"
16:31:31 <lambdabot>   Nothing
16:31:46 <lispy> Why bother with a Maybe?
16:32:24 <mapreduce> What else should it do for the case where it currently returns Nothing?
16:33:17 <Philonous> > stripPrefix "foo" "foo"
16:33:18 <lambdabot>   Just ""
16:35:41 <lispy> I would argue that when stripPrefix x s | not (x `isPrefixOf` s) = s
16:35:53 <lispy> I would so that's correct :)
16:36:28 * lispy fails english
16:36:34 <lispy> I would "say" that's correct
16:38:38 <Philonous> You'd have to test that stripPrefix ps "= s seperately and than you'd have to check that p != "", isn't that even more complicated than dealing with a Maybe?
16:38:55 <Philonous> "= should be !=
16:39:40 <Philonous> stripPrefix p s != s *
16:40:22 <lispy> I'm thinking about it interms of behavior.  stripPrefix is doing 2 things.  It's telling me when p `isPrefixOf` s, and it's giving me a string that is gauranteed to not start with p.  That seems like a bad api.  They should probably be separate.
16:42:09 <lispy> (I'm assuming it works on strings, but obviously it's more general than that)
16:42:47 <mmorrow> otoh, one could possibly think of it as a zip which instead of taking the initial parts of the two lists until one ends, it take the opposite of this from the list designated as "not the prefix one"
16:43:23 <Saizan_> lispy: it's precisely introduced to avoid two traversals to get the suffix
16:43:23 <mmorrow> you could make a symmetric version
16:43:35 <BMeph> lispy: No, it's giving you a string guaranteed to be an `s`-worth shorter.
16:43:42 <BMeph> mmorrow: I did. :)
16:44:16 <BMeph> When I kludged together my version of an ud-code solver. :)
16:44:21 <lispy> BMeph: oh right, stripPrefix "foo" "foofoo" is still starting with "foo"
16:44:47 <lispy> > stripPrefix "foo" "foofoo"
16:44:49 <lambdabot>   Just "foo"
16:44:59 <BMeph> lispy: Imagine stripPrefix "badger " ... ;)
16:45:39 <mmorrow> , let snagged [] ys = ys ; snagged xs [] = xs ; snagged (_:xs) (_:ys) = snagged xs ys in snagged "kthxbai" [0..]
16:45:45 <mmorrow> heh
16:45:48 <mmorrow> > let snagged [] ys = ys ; snagged xs [] = xs ; snagged (_:xs) (_:ys) = snagged xs ys in snagged "kthxbai" [0..]
16:45:49 <lambdabot>       No instance for (Num Char)
16:45:49 <lambdabot>        arising from the literal `0' at <inte...
16:45:56 <mmorrow> ah
16:46:01 <BMeph> > stripPrefix "badger badger badger badger badger badger badger Mushroom!"
16:46:02 <lambdabot>       Overlapping instances for Show ([Char] -> Maybe [Char])
16:46:02 <lambdabot>        arising ...
16:46:08 <mmorrow> > let snagged [] ys = Right ys ; snagged xs [] = Left xs ; snagged (_:xs) (_:ys) = snagged xs ys in snagged "kthxbai" [0..]
16:46:09 <lambdabot>   Right [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30...
16:46:20 <BMeph> > stripPrefix "badger " "badger badger badger badger badger badger Mushroom!"
16:46:22 <lambdabot>   Just "badger badger badger badger badger Mushroom!"
16:46:47 <mmorrow> > let snagged [] ys = Right ys ; snagged xs [] = Left xs ; snagged (_:xs) (_:ys) = snagged xs ys in snagged "kthxbai" "bandger dadger danger wildabeast"
16:46:49 <lambdabot>   Right " dadger danger wildabeast"
16:47:08 <lispy> ?hoogle stripInfix
16:47:09 <lambdabot> No results found
16:47:38 <lispy> ?hoogle stripSuffix
16:47:39 <lambdabot> No results found
16:47:47 <mmorrow> hmm. what would be a suitable type for a function named `danger'
16:47:54 <lispy> a -> b
16:47:56 <wjt> :: Mouse
16:48:07 <BMeph> > stripPrefix "spam " "spam spam spam spam spam spam spam spam and eggs."
16:48:08 <lambdabot>   Just "spam spam spam spam spam spam spam and eggs."
16:48:47 <lispy> > fix $ \s -> stripPrefix "spam " s
16:48:49 <lambdabot>   Couldn't match expected type `[Char]'
16:48:57 <lispy> I think I meant iterate
16:49:16 <lispy> > iterate $ \s -> stripPrefix "spam " s $ "spam spam spam spam spam spam spam spam and eggs."
16:49:17 <lambdabot>   Couldn't match expected type `a -> b'
16:49:20 <lispy> doh!
16:49:26 <wjt> @ty fromMaybe
16:49:28 <lambdabot> forall a. a -> Maybe a -> a
16:49:37 <wjt> @ty maybe
16:49:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:49:56 <lispy> > let lispyStripPrefix p s = fromMaybe s (stripPrefix p s)
16:49:57 <BMeph> lispy: fromJust . stripPrefix "..."
16:49:57 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
16:49:57 <lambdabot>  ...
16:50:13 <lispy> > let lispyStripPrefix p s = fromMaybe s (stripPrefix p s) in lispyStripPrefix "foo" "blah"
16:50:14 <lambdabot>   "blah"
16:50:14 <mmorrow> let danger :: (forall f. f) -> (forall a. a) -> (forall sirensLoudNoises. sirensLoudNoises) ; danger f a = unsafeCoerce ((unsafeCoerce f) (unsafeCoerce a))
16:50:15 <wjt> > iterate Nothing (stripPrefix "spam ") (Just "spam spam spam spam spam spam spam spam and eggs."
16:50:16 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
16:50:16 <lambdabot>  ...
16:50:19 <wjt> > iterate Nothing (stripPrefix "spam ") (Just "spam spam spam spam spam spam spam spam and eggs.")
16:50:20 <lambdabot>   Couldn't match expected type `a -> a'
16:50:28 <wjt> > iterate (maybe Nothing (stripPrefix "spam ")) (Just "spam spam spam spam spam spam spam spam and eggs.")
16:50:29 <ac> lispy: you've got a Maybe to deal with
16:50:30 <lambdabot>   [Just "spam spam spam spam spam spam spam spam and eggs.",Just "spam spam s...
16:50:41 <wjt> > catMaybes $ iterate (maybe Nothing (stripPrefix "spam ")) (Just "spam spam spam spam spam spam spam spam and eggs.")
16:50:54 <BMeph> > iterate (fromJust . stripPrefix "spam ")  "spam spam spam spam spam spam spam spam and eggs."
16:50:57 <lambdabot>   ["spam spam spam spam spam spam spam spam and eggs.","spam spam spam spam s...
16:50:57 <lambdabot>   thread killed
16:51:07 <wjt> BMeph: errors at the end :(
16:51:10 <lispy> ?src iterate
16:51:11 <lambdabot> iterate f x =  x : iterate f (f x)
16:51:12 * BMeph pumps his fist in victory!
16:51:27 <lispy> iterate operates on codata via guarded recursion!
16:51:55 <lispy> I want to say I learned this on sigfpe's blog
16:52:37 <ac> where's stripPrefix defined anyway?
16:52:45 * BMeph wants an "Everything I know about computing I learned from sigfpe" T-shirt
16:52:59 <lispy> ?index stringPrefix
16:52:59 <lambdabot> bzzt
16:53:05 <lispy> ?hoogle stringPrefix
16:53:06 <lambdabot> No results found
16:53:07 <BMeph> ac: Data.List
16:53:22 <lispy> lambdabot: you import more than you know about.  Knock it off.
16:54:09 <BMeph> lispy: Lambdabot imports more than Wal-Mart. ;p
16:54:49 <lispy> does Haskell have implementations of RDF or Owl?  I'm mostly asking on behalf of a friend.
16:55:36 <Saizan_> @remember BMeph * wants an "Everything I know about computing I learned from sigfpe" T-shirt
16:55:36 <lambdabot> I will remember.
16:55:51 <lispy> http://www.ninebynine.org/RDFNotes/Swish/Intro.html
16:55:52 <lambdabot> Title: Swish: Semantic Web Inference Scripting in Haskell
16:55:56 <lispy> seems we have
17:03:40 <ac> is there a monadic version of iterate... like (>>=), but returns a list? Does that question make sense?
17:06:01 <lispy> ?hoogle iterateM
17:06:02 <lambdabot> No results found
17:06:14 <Saizan_> ?type \f x -> iterate (f =<<) (return x) -- i tend to need this
17:06:15 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
17:07:06 <ac> I think that's what I was asking for, except I'd compose it with sequence
17:07:28 <ac> kind of like an iterateM
17:07:41 <lally> hey, anyone mind helping me with a dead-simple 3-liner?  I don't know what's wrong, nor how to interpret the error message.
17:08:00 <Saizan_> ac: the problem with sequence is that iterate is returining an infinite list
17:08:24 <Saizan_> @paste
17:08:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:08:39 <lally> myParse :: Either b a -> a
17:08:39 <lally> myParse (Left _) = []
17:08:42 <lally> myParse (Right a) = a
17:09:00 <Saizan_> ?type []
17:09:01 <lambdabot> forall a. [a]
17:09:56 <Saizan_> lally: [] is the empty list, but your type requires you tu return something of type 'a'
17:11:09 <lally> Oh, ok thanks.  That did it.  Thanks :-)
17:11:40 <ac> Saizan_: why can't I define that in GHCi? I get: Ambiguous type variable 'm' in the constraint ...
17:11:58 <dobblego> where is the function :: String -> Maybe Integer for parsing an integer?
17:12:09 <ac> @let iterateM = \f x -> iterate (f =<<) (return x)
17:12:10 <lambdabot>  <local>:11:27:
17:12:10 <lambdabot>      Ambiguous type variable `m' in the constraint:
17:12:10 <lambdabot>        `M...
17:12:25 <Saizan_> ac: Monomorphism Restriction
17:12:55 <Saizan_> @let iterateM f x = iterate (f =<<) (return x)
17:12:57 <lambdabot>  Defined.
17:13:04 <Saizan_> @type iterateM
17:13:06 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> b -> [m b]
17:13:18 <ac> what the heck? You just did the same thing I did, and it worked
17:13:38 <dobblego> bit different
17:13:46 <Saizan_> the difference is that mine had formal parameters
17:13:52 <Saizan_> while yours didn't
17:14:08 <ac> which should be equivalent
17:14:31 <ac> guess I'm going to have to go read about this so called monomorphism restriction
17:14:36 <dobblego> they are if you ignore MR
17:14:48 <Saizan_> yeah, aside from this monomorphism restriction, that says a definition with no formal parameters without a type signature can't be typeclass polymorphic
17:17:21 <dobblego> is there a function :: a -> Maybe a that catches error to None?
17:17:27 <dobblego> er Nothing
17:17:50 <Saizan_> dobblego: you need unsafePerformIO for that
17:17:57 <ac> anywy, all I wanted was to be able to do this...
17:18:09 <dobblego> any other way to write read' :: String -> Maybe Int then?
17:18:09 <ac> > sequence $ takeWhile (not . (==Nothing)) $ iterateM (stripPrefix "spam ") "spam spam spam and eggs"
17:18:11 <lambdabot>   Just ["spam spam spam and eggs","spam spam and eggs","spam and eggs","and e...
17:18:25 <Saizan_> dobblego: write it in terms of reads
17:18:30 <dobblego> @type reads
17:18:31 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:18:58 <Olathe> > iterate ("spam "++) "and spam"
17:19:00 <lambdabot>   ["and spam","spam and spam","spam spam and spam","spam spam spam and spam",...
17:19:14 <ac> that's the problem with Haskell. You want to do some simple string manipulation and you end up learning about a monomorphism restriction
17:19:47 <dobblego> or don't learn and just write the function with formal parameters
17:19:49 <ac> though admittedly I specifically wanted to do said string manipulation in the most elegant forseeable way
17:20:09 <dobblego> you could also type annotate like you do in other languages
17:20:17 <ac> dobblego: for Maybe?
17:20:30 <dobblego> for your function
17:20:39 <Saizan_> ac: maybe add :set -XNoMonomorphismRestriction  to your .ghci :) a lot of people hates it, btw
17:21:16 <ac> Saizan_: it must do something good...
17:21:37 <ac> something like make type checking decideable I'm guessing
17:21:47 <Saizan_> ac: no, nothing like that
17:22:59 <Saizan_> ac: a definition with no formal parameters is called a CAF, and we usually expect the evaluation of CAFs to be shared among all the uses, but if their type involves a typeclass it's hard for the compiler to guarantee that
17:23:36 <Saizan_> ac: so if you want a CAF with a typeclass context you're forced to add a type signature and consider that you're losing sharing by doing so
17:24:00 <ac> Ok, that makes a sort of vague intuitive sense
17:49:55 <Guest15444> anyone know if Debug.Trace.Location can find the location of an "undefined" assertion
17:58:41 <sebaseba> @quote
17:58:41 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
17:58:41 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
17:58:42 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
17:59:45 <shapr> got cut off there...
18:03:04 <mmorrow> > flip runCont id (callCC $ \k -> sequence (iterateM (\n -> if n > 900 then k (return n) else return (n*2)) 1))
18:03:05 <lambdabot>   [1024]
18:03:25 <lally> Whean learning haskell, does one spend a lot of time trying to figure out what the compiler's trying to infer with types?
18:04:44 <lament> one spends a lot of time trying to parse compiler's error messages :)
18:04:48 <Saizan> lally: yeah, annotating toplevel definitions with the type you expect helps in getting better error messages
18:05:59 <mmorrow> yeah. i found my wow/ohhhh moment to be when i realized that you're programming as much with the type sigs as you are with the expressions, and changes a type sig alone can completely change what a program does just as much as changing some code can (well, it actually /is/ changing some code, just not visibly at the src-level).
18:06:21 <lally> mmorrow: eeesh
18:07:22 <mmorrow> > join (replicateM 10 [0])
18:07:23 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
18:07:41 <mmorrow> err, bad one
18:07:53 <mmorrow> > return 0 :: [Int]
18:07:55 <lambdabot>   [0]
18:07:58 <mmorrow> > return 0 :: Maybe Int
18:07:59 <lambdabot>   Just 0
18:08:03 <mmorrow> > return 0 :: IO Int
18:08:04 <lambdabot>   * Exception: "<IO Int>"
18:08:23 <lament> > [0] + [1]
18:08:23 <lambdabot>       No instance for (Num [t])
18:08:23 <lambdabot>        arising from a use of `+' at <interact...
18:09:56 <mmorrow> > return 0 :: ContT IO r (Complex Double)
18:09:58 <lambdabot>       `IO' is not applied to enough type arguments
18:09:58 <lambdabot>      Expected kind `*', bu...
18:10:09 <mmorrow> > return 0 :: ContT r IO (Complex Double)
18:10:10 <lambdabot>       No instance for (Show (ContT r IO (Complex Double)))
18:10:10 <lambdabot>        arising fro...
18:12:35 <lally> Ok, so a function that does a little IO and returns a [[Float]], the type should be readCSV :: IO () -> [[Float]]
18:12:37 <lally> correct?
18:12:57 <dmwit> Not quite.
18:13:01 <dobblego> it will be an action of type IO [[Float]]
18:13:07 <dmwit> You have to signal the IO in the return type, not the argument type.
18:13:18 <lally> So what'd be the expression to return somethign?
18:13:22 <lally> IO []
18:13:28 <lally> ?
18:13:31 <lally> or would I return []
18:13:33 <lally> }
18:13:34 <lally> ?
18:14:00 <dmwit> IO [[Float]]
18:14:18 <dmwit> Wait, do you mean return at the type level or at the term level?
18:14:39 <lally> I declared a function called readCSV
18:14:49 <lally> originally readCSV:: IO () -> [[Float]]
18:14:57 <lally> new version is just readCSV :: IO [[Float]]
18:15:01 <lally> correct?
18:15:06 <dmwit> Right! =)
18:15:10 * BMeph applauds
18:15:28 <lally> Ok, so it's not a function, it's an action, which takes no params (not even the IO context thingy)
18:16:20 <lally> Next, question, when I call it: do
18:16:24 <lally> csv <- readCSV
18:16:27 <lally> print csv
18:16:34 <lally> is there a way to avoid the temp var?
18:16:44 <dmwit> Sure!
18:16:46 <dmwit> :t (>>=)
18:16:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:17:01 <lally> dmwit: I think your modem is broken
18:17:05 <dmwit> readCSV >>= print -- is equivalent to yours
18:17:09 <lally> ah
18:17:09 <dmwit> lally: =P
18:17:30 <dmwit> (>>=) is like the composition operator, but for monads.
18:17:41 <lally> Ok, >>= is some sort of IO pipe
18:17:42 <Philonous> Actually it's not a temp var but only a sugared way to do what dmwit suggested as an alternative
18:18:00 <dmwit> Yeah, "temp var" is a misleading way to call it.
18:18:39 <humasect> is there a bigger picture of these two? -> http://www.haskell.org/haskellwiki/Haskell_Platform
18:18:40 <lally> oh I'm too n00b to go into terminology just yet.
18:18:40 <lambdabot> Title: Haskell Platform - HaskellWiki
18:18:53 <dmwit> lally: Have you had a look at this?
18:18:59 <dmwit> ?go io monad for people who just don't care
18:19:02 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
18:19:02 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
18:19:35 <lally> oh nice!
18:20:05 <lally> I'd prefer to get moderately productive first, before learning the deep details.  Otherwise I lose motivation and jump languages.
18:22:45 <Philonous> Btw. is there some material on identifying monads, comonads, functors, applicatives and such? I have a hard time translating my ideas into those concepts
18:23:42 <dmwit> Hmmm, translating your ideas into those concepts?
18:23:47 <dmwit> That doesn't really sound like a good idea.
18:24:18 <humasect> dmwit: i think it means, if his ideas that already made, can fit into one of those 'already defined' types and 'fancy theory'
18:24:21 <dmwit> Shoehorning some new workflow into a monad just because "that's how Haskell does things" sounds problematic.
18:24:43 <Philonous> Well, that's exactly what I want to avoid
18:25:03 * dmwit notes that he has never written an instance of any of those
18:25:06 <Philonous> I meant I have an idea and I want to know if it already is a monad, a comonad and so on
18:25:09 <dmwit> So just learn a whole bunch of instances.
18:25:15 <dmwit> Then you'll know if they apply.
18:25:48 <Philonous> Hmm, ok
18:25:53 <dmwit> Philonous: Well, your idea is a monad if it has return and (>>=) and satisfies the monad laws.
18:26:05 <dmwit> Analogously for comonads and functors.
18:26:14 <dmwit> Do you just want a reference for the laws?
18:27:09 <Philonous> No
18:27:18 <Philonous> I surely could just check for the laws
18:28:31 <Philonous> I just meant I know a right-angled triangle when I see one. But I couldn't tell if something behaves like a monad without checking the properties
18:29:38 <dmwit> You know a right-angle triangle because you've seen a lot of them.
18:29:43 <dmwit> So, see (and use) a lot of monads.
18:29:46 <dmwit> ;-)
18:30:01 <dmwit> ...in other words, no, I don't know of any guidelines for detecting when something is a monad. =P
18:30:18 * BMeph wishes there were a comonad and bifunctor reference as clear and readable as http://www.haskell.org/all_about_monads/html/index.html
18:30:19 <lambdabot> Title: All About Monads
18:31:10 <Philonous> Yup, that whas the idea. I just wondered whether there is some material for this or a rule of thumb whether something even comes into consideration
18:37:24 <lally> Syntax question, how do I avoid looking too lispy?  E.g. (head (take n vals))
18:37:38 <lally> I tried the ., but it is too advanced I fear
18:38:55 <mmorrow> head . take n
18:39:04 <mmorrow>  @pl is t3h best
18:39:18 <mmorrow> @pl \n vals -> (head (take n vals))
18:39:18 <lambdabot> (head .) . take
18:39:49 <mmorrow> @pl \x y -> g (f x y)
18:39:49 <lambdabot> (g .) . f
18:39:56 <mmorrow> @pl \x y z -> g (f x y z)
18:39:56 <lambdabot> ((g .) .) . f
18:40:04 <mmorrow> @pl \x y z a-> g (f x y z a)
18:40:04 <lambdabot> (((g .) .) .) . f
18:40:27 <mmorrow> @pl \x y -> g (f x) y
18:40:27 <lambdabot> g . f
18:40:29 <lally> \msg lambdabot help
18:40:31 <dobblego> lally, (.) is not very advanced; I recommend you take the time understand what it does (it's just a function after all)
18:40:51 <Cthulhon> Of course, (head . take) is the same as just head...
18:41:22 <lally> I'm implementing a quick nth, which so that nth 3 [1 2 3 4] returns 3
18:41:39 <Philonous> > take 0 abc
18:41:40 <lambdabot>   Not in scope: `abc'
18:41:43 <Philonous> > take 0 "abc"
18:41:44 <lambdabot>   ""
18:41:55 <lispy> lally: since when is looking lispy bad?
18:42:05 <FunctorSalad> :)
18:42:09 <lally> haha :-)
18:42:16 <lally> should I say lisp-esqe?
18:42:17 <mmorrow> > (\n -> (!!n)) 5 [0..]
18:42:18 <lambdabot>   5
18:42:20 <mmorrow> > (\n -> (!!n-1)) 5 [0..]
18:42:21 <lispy> I'm just saying :)
18:42:21 <lambdabot>       The operator `!!' [infixl 9] of a section
18:42:22 <lambdabot>          must have lower prec...
18:42:28 <mmorrow> > (\n -> (!!(n-1))) 5 [0..]
18:42:29 <lambdabot>   4
18:43:25 <dmwit> lally: Well, you can implement it, or you can use (!!), the built-in list indexing operator.
18:43:35 <dmwit> lally: Note that "take" does the wrong thing for what you want, though.
18:43:41 <Philonous> @pl \x y -> f $ g x y
18:43:41 <lambdabot> (f .) . g
18:43:42 <dmwit> It "keeps" the beginning of the list.
18:43:53 <dmwit> You want to "throw away" the beginning of the list, which is what drop is for.
18:43:57 <dmwit> > drop 10 [0..]
18:43:58 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
18:45:34 <mmorrow> lally: this might make it clearer
18:47:07 <mmorrow> main = putStr . unlines . map (unwords . take 4 . words) . lines =<< getContents
18:47:41 <mmorrow> ==take the first four words of each line in a file
18:48:12 <dmwit> heh
18:48:23 <dmwit> crystal clear
18:48:30 <mmorrow> the (.) compose the functions into a pipeline, which is just another function
18:49:02 <lally> essentially the last parameter of the function is left off, and fed in from somewhere on the right of the pipeline?
18:49:09 <mmorrow> exactly
18:49:36 <lally> So how does one pipeline params into a function when it's not the last one?
18:49:41 <mmorrow> you forget about the parameters as such, and start to think of the functions as parameters to the (.) functions
18:50:08 <mmorrow> so, these are equivalent:
18:50:15 <lally> e.g. a two-arg function, when I want to pipe in arg 1 instead of 2
18:50:21 <mmorrow> \x y -> f x y
18:50:24 <Philonous> It's much like Unix-pipes, just in reverse order.
18:50:24 <mmorrow> \x -> f x
18:50:28 <mmorrow> f
18:50:41 <mmorrow> yeah, exactly like unix pipes
18:51:32 <mmorrow> $ cat | ... | ... | something `cat | ... | ...` | wc -l
18:51:38 <mmorrow> will just sit there and wait
18:51:46 <dmwit> Unix pipes are a monad!
18:52:07 <mmorrow> heh, i like that paper.
18:52:13 <Philonous> How so?
18:52:16 <dmwit> lally: Well, there's the "flip" function.
18:52:23 <dmwit> Philonous: return = cat, (>>=) = |
18:52:39 <dmwit> Philonous: Or maybe return = echo, depending on how you formalize it.
18:52:57 <Philonous> Owww, that's kinda trivial, isn't it?
18:53:02 <dmwit> yep =)
18:53:12 <dmwit> (But the point is that it's not pure.)
18:53:33 <mmorrow> the only thing that's different is that unix pipes arent lazy
18:53:39 <pjdelport> Philonous: http://okmij.org/ftp/Computation/monadic-shell.html
18:53:40 <lambdabot> Title: UNIX pipes as IO monads
18:53:44 <mmorrow> A=`cat`; echo $A
18:53:48 <mmorrow> will hang
18:53:49 <mmorrow> but
18:54:02 <mmorrow> do a <- getContents; putStr a
18:54:05 <mmorrow> won't
18:54:39 <mmorrow> err, i meant "won't produce any output til cat sees eof"
18:54:59 <dmwit> On the other hand,
18:55:04 <dmwit> cat | cat # will not hang
18:55:08 <Saizan> your example is not a pipe though
18:55:11 <dmwit> right
18:55:22 <mmorrow> he also considers (;) and tmp files
18:55:25 <pjdelport> also, getContents is cheating
18:55:38 <mmorrow> and cat | cat is just getContents >>= return
18:55:41 <dmwit> Pipes are lazy enough that you can't do something like
18:55:47 <mmorrow> not getContents >>= putStr
18:55:51 <dmwit> sed 's/  / /' <in >in
18:56:24 <dmwit> mmorrow: cat | sed p # also does not hang
18:56:26 <mmorrow> yeah, they are lazy in the way that makes them pipes :)
18:56:41 <mmorrow> cat /dev/urandom | od | head -10
18:56:48 <Philonous> Well, typed unix pipes would be interesting
18:57:10 <lally> I'm gonna guess String -> String
18:57:22 <Philonous> That's how it's now, yes
18:57:31 <dmwit> String -> IO String
18:57:51 <dmwit> Philonous: There is a typed shell out there.
18:57:57 <dmwit> I can't remember what it's called.
18:58:02 <mmorrow> newtype IO a = IO (WorldState -> a)
18:58:13 <pjdelport> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
18:58:15 <lambdabot> Title: [Haskell-cafe] Takusen and strictness, and perils of getContents, http://tinyurl.com/yp35rl
18:58:16 <dmwit> IO (WorldState -> (WorldState, a))
18:58:26 <mmorrow> so a val of type IO is actually a function
18:58:38 <pjdelport> s/getContents/unsafeGetContents/
18:58:41 <dmwit> mmorrow: It's got to output a new WorldState. ;-)
19:00:04 * mmorrow loves how the type RealWord is imaginary
19:01:17 <retrohscoder> ok, I cannot for the life of me figure out how to compile my .hs file. It uses the SDL bindings.
19:01:21 <retrohscoder> I'm using ghc
19:01:46 <humasect> -package SDL ?
19:02:27 <retrohscoder> thanks
19:02:33 <dmwit> ghc --make
19:03:30 <humasect> i'm looking for a nice way to pass 1 argument to two functions
19:03:42 <dmwit> humasect: Take a look at the (->) monad.
19:03:46 <humasect> k
19:03:50 <Philonous_> (f &&& g )
19:04:02 <dmwit> The (->) arrow is also nice. =)
19:05:57 <humasect> allParts ed = parts ed ++ selParts ed   -- must be simplified =)
19:06:34 <dmwit> liftM2 (++) parts selParts
19:06:42 <dmwit> ?pl allParts ed = parts ed ++ selParts ed
19:06:42 <lambdabot> allParts = liftM2 (++) parts selParts
19:06:45 * humasect   ponders
19:06:57 <dmwit> But really... why bother?
19:06:59 <humasect> ha .. and all my use of liftM i didn't see it.
19:07:11 <dmwit> What you wrote is perfectly clear and efficient.
19:07:11 <humasect> because repetition is bad for health
19:07:16 <humasect> +unecessary repetition
19:07:29 <dmwit> This is about the smallest example of repetition you will ever find.
19:07:36 <humasect> yep.
19:08:52 <humasect> er, how come parts/selParts becomes 'm a' for liftM(2) ?
19:09:05 <dmwit> The monad is the (e -> a) monad.
19:09:16 <humasect> ...oh!!
19:09:28 <humasect> wow. ok, that is very cool.
19:09:55 <dmwit> In other words, "ed" is an environment that parts and selParts are operating in.
19:10:49 <humasect> hmm
19:11:03 <dmwit> Mind-blowing, hey?
19:11:23 <humasect> i'm about half way to that experience yes =)
19:11:36 <humasect> (e -> a) is what some call CPS ?
19:11:51 <mmorrow> > (id=<<(*)) 4
19:11:52 <lambdabot>   16
19:12:04 <mmorrow> humasect: that's (a -> r) -> r
19:12:08 <mmorrow> (cps)
19:12:19 <humasect> hehehe..
19:12:25 <mmorrow> @src Cont
19:12:25 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
19:12:37 <dmwit> humasect: Nope, it's called the environment monad.
19:12:57 <humasect> dmwit: ie (.) forms a monad?
19:13:06 <dmwit> hm
19:13:07 <dmwit> no?
19:13:17 <dmwit> Oh, yes.
19:13:18 <humasect> mmorrow: that is too much for me just yet hehe. (i'm sure it will haunt me very soon.)
19:13:30 <dmwit> ?src Monad (->)
19:13:30 <lambdabot> Source not found. I feel much better now.
19:13:32 <mmorrow> @src (>>=) ((->)e)
19:13:32 <lambdabot> Source not found. Do you think like you type?
19:13:36 <dmwit> ?src (>>=) (->)
19:13:37 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:13:44 <mmorrow> @src ((->)e) (>>=)
19:13:44 <lambdabot> Source not found. Just try something else.
19:13:49 <dmwit> ?src (->) (>>=)
19:13:49 <lambdabot> f >>= k = \ r -> k (f r) r
19:13:52 <dmwit> There we go.
19:13:54 <mmorrow> heh
19:13:58 <dmwit> ?src (->) return
19:13:58 <lambdabot> return = const
19:14:09 <dmwit> humasect: (.) is fmap, not (>>=)
19:14:15 <dmwit> ?src (->) fmap
19:14:15 <lambdabot> fmap = (.)
19:14:18 <TehZorroness> I'm a refugee from C++ trying to learn a bit about FRP, but most documents I've found use a bunch of special notation that I don't understand.  Can someone recommend a from-scratch explanation?
19:14:26 <humasect> ahh
19:14:33 <mmorrow> @pl \ r -> k (f r) r
19:14:33 <lambdabot> k =<< f
19:14:37 <mmorrow> haha
19:14:44 <humasect> hm thats what i was just thinking, mmorrow =)
19:15:04 <humasect> :t (->)
19:15:06 <lambdabot> parse error on input `->'
19:15:09 <mmorrow> > join (*) 20
19:15:10 <lambdabot>   400
19:15:16 <humasect> :t join
19:15:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:15:25 <mmorrow> > join [[0],[1]]
19:15:25 <humasect> @src join -- oops
19:15:26 <lambdabot> Source not found.
19:15:27 <lambdabot>   [0,1]
19:15:31 <dmwit> TehZorroness: Take a look at the Arrow papers first.
19:15:33 <mmorrow> > (id=<<) [[0],[1]]
19:15:34 <lambdabot>   [0,1]
19:15:43 <mmorrow> > (id=<<) (*) 20
19:15:44 <lambdabot>   400
19:15:57 <mmorrow> > (id=<<) (Just (Just 2000))
19:15:58 <lambdabot>   Just 2000
19:16:10 <mmorrow> @src join
19:16:10 <lambdabot> join x =  x >>= id
19:16:12 <humasect> ah join == (id =<<) ?
19:16:13 <humasect> oh
19:16:48 <bd_> :t (join, (id =<<))
19:16:49 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) b. (Monad m1, Monad m) => (m (m a) -> m a, m1 (m1 b) -> m1 b)
19:17:19 <retrohscoder> how would you implement this C code in haskell? v1 = x % y; v2 = x / y;
19:17:21 <dobblego> (=<<) id
19:17:28 <dobblego> = join
19:17:37 <humasect> thx dobblego
19:17:47 <humasect> hehe bd_
19:17:48 <bd_> retrohscoder: is this homework? :)
19:18:08 <retrohscoder> bd_ nope. I've not had homework in 17 years
19:18:10 <retrohscoder> :D
19:18:17 <bd_> :t divMod
19:18:18 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
19:18:21 <retrohscoder> this is me just trying to learn this haskell thing
19:18:41 <bd_> let (v2, v1) = x `divMod` y in .......
19:19:00 <bd_> there's div and mod if you're only interested in one
19:19:27 <retrohscoder> what is the ....... part?
19:19:54 <retrohscoder> and is "in" a command in haskell?
19:20:03 <humasect> :t runCont
19:20:04 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
19:20:14 <humasect> retrohscoder: its part of the let
19:20:20 <dobblego> retrohscoder, look up a let/in expression
19:21:37 <mmorrow> > Cont (\k -> k 42) `runCont` id
19:21:38 <lambdabot>   42
19:21:42 <mmorrow> > Cont (\k -> k 42) `runCont` (*2)
19:21:44 <lambdabot>   84
19:21:58 <humasect> ah yes..
19:22:35 <mmorrow> > (Cont (\k -> k 42) `runCont` (\n -> (\k -> k n))) (*2)
19:22:36 <lambdabot>   84
19:22:40 <humasect> mmorrow i will come to you when i need all the cool stuff like this that i came to haskell for in the first place. ^_^
19:22:47 <humasect> ah .. brain..
19:22:53 <mmorrow> > (Cont (\k -> k 42) `runCont` (\n -> Cont (\k -> k n))) `runCont` (*2)
19:22:54 <lambdabot>   84
19:23:06 <mmorrow> humasect: :)
19:23:27 <TehZorroness> dmwit: you mean "Generalizing Monads to Arrows?"
19:23:58 <dmwit> TehZorroness: That's a good start, yes.
19:24:06 <TehZorroness> ok, thanks :)
19:24:09 <humasect> i am still on 'environment monad' which is something i really wished to have been faced with much earlier
19:24:12 <dmwit> TehZorroness: It will introduce the main notation used in FRP stuff.
19:24:21 <mmorrow> > flip runCont id (callCC (\escape -> forever (escape "hai")))
19:24:22 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `()'
19:24:23 <dmwit> humasect: Have you seen Meet the Monads?
19:24:27 <dmwit> ?go meet the monads
19:24:30 <lambdabot> http://www.haskell.org/all_about_monads/html/meet.html
19:24:30 <lambdabot> Title: Meet the Monads
19:24:32 * humasect looks
19:24:41 <mmorrow> > flip runCont id (callCC (\escape -> forever (escape "hai" >> return ())))
19:24:42 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `()'
19:24:47 <humasect> hm, yes i have
19:25:08 <dmwit> humasect: It's this one: http://www.haskell.org/all_about_monads/html/readermonad.html
19:25:08 <lambdabot> Title: The Reader monad
19:25:24 <humasect> oh!
19:25:31 <mmorrow> > flip runCont id (callCC (\escape -> forever (escape "hai"))) :: String
19:25:35 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `()'
19:25:40 <mmorrow> grr
19:26:08 <mmorrow> > flip runCont id (callCC (\escape -> forever ( ?f )))
19:26:09 <lambdabot>       Unbound implicit parameter (?f::Cont () a)
19:26:09 <lambdabot>        arising from a use of...
19:26:13 <humasect> hehe
19:26:32 <humasect> :t liftM2 (++)
19:26:33 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
19:26:57 <humasect> oops. well i have to use all of this stuff otherwise it goes nowhere
19:28:01 <mmorrow> > let forev m a = m a >>= forev m in flip runCont id (callCC (\escape -> forev (\n -> if n>10 esc n else return (3*n)) 7))
19:28:01 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 106}...
19:28:50 <mmorrow> > let forev m a = m a >>= forev m in flip runCont id (callCC $ \esc -> forev (\n -> if n >10 then esc n else return (3*n)) 7)
19:28:51 <lambdabot>   21
19:28:53 <lally> I'm allowed to do let...ins inside do exprs, correct?
19:29:09 <dmwit> Yes.
19:29:14 <dmwit> You don't even need the "in" clause.
19:29:34 <dmwit> > do { x <- [3,4,5]; let y = x + 1; [y, 5 * y] }
19:29:34 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 53}
19:29:34 <lambdabot> ...
19:29:38 <lally> I'm getting a "The last statement in a 'do' construct must be an expression"
19:29:42 <dmwit> oh
19:29:45 <lally> when the 'in' clause is just a pair of prints
19:29:47 <dmwit> > do { x <- [3,4,5]; let {y = x + 1}; [y, 5 * y] }
19:29:48 <lambdabot>   [4,20,5,25,6,30]
19:29:57 <mmorrow> lally: (let <decls> in <exp>) is an <exp>
19:30:07 <dmwit> lally: Let's see what you've got.
19:30:12 <lally> main = do
19:30:12 <lally>          let
19:30:12 <lally>              csv = readCSV "/research/phd/data/densitymaps/apr1_study_density.csv"
19:30:12 <lally>              densityMap = normMatrix csv (sumMatrix csv)
19:30:12 <lally>          in
19:30:13 <lally>            print (sumMatrix densityMap)
19:30:15 <lally>            print (sumColumn 19 densityMap)
19:30:25 <humasect> :t print
19:30:28 <lambdabot> forall a. (Show a) => a -> IO ()
19:30:32 <lally> if I take out the densityMap and make the prints operate on csv directly, it seems to work fine
19:30:36 <lally> e.g.
19:30:46 <dmwit> lally: You have to use (<-) to bind results from IO actions, not =.
19:31:11 <lally> yeah, I tried to put the csv <-... before the let
19:31:27 <dmwit> Also!
19:31:33 <dmwit> After the "in" you need another "do".
19:31:48 <humasect> or, don't use 'in' while using let's in a do.
19:31:56 <mmorrow> and the two prints at the bottom are getting considered as being part of the let, when you want them as part of the enclosing do
19:31:57 <dmwit> For the same reason you need a "do" in if/then/else clauses.
19:32:14 <dmwit> mmorrow: I don't think that's right.  Though it might be a parse error.
19:32:17 <mmorrow> (or a sub do, either way)
19:32:30 <mmorrow> you'd have to drop the "in"
19:32:39 <dmwit> lally: Also, in the future, please use a paste site like hpaste.org rather than pasting in-channel.
19:32:41 <lally> Ah, so the let.. format will change dep. on whether I'm in a do or not.
19:32:50 <dmwit> A little bit, yes.
19:32:51 <mmorrow> and line up the prints with the let
19:32:52 <lally> I'll look at hpaste.org
19:35:16 <mmorrow> do let x = ...
19:35:23 <mmorrow>     print ...
19:35:39 <mmorrow> oops, add one '\b'
19:35:49 <mmorrow> or
19:35:56 <mmorrow> let x = ...
19:36:02 <mmorrow> in do ...
19:37:08 <mmorrow> but not    do + (let + in) + <stuff-that-needs-to-be-in-the-do-but-is-getting-grabbed-by-the-in>
19:38:14 <humasect> =)
19:42:14 <monochrom> do { let x=1; return x }   {- note no "in" -}
19:42:54 <dmwit> needs more braces ;-)
19:43:02 <dmwit> do { let {x = 1}; return x }
19:43:06 <monochrom> Oh oops.
19:43:07 <dmwit> But that's a special case, and you know it.
19:43:21 <dmwit> We're trying to *help* the new guy, not confuse him. =)
19:43:48 <roconnor> > mdo {}
19:43:48 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 13}
19:43:48 <lambdabot> ...
19:44:21 <dmwit> > mdo { [] }
19:44:22 <lambdabot>   []
19:44:24 <dmwit> huh
19:44:27 <dmwit> What's mdo?
19:44:37 <humasect> hm, is there 'braceless' version of record construction ?
19:44:37 <monochrom> sugar for mfix
19:44:52 <dmwit> humasect: Yup.
19:44:58 <dmwit> humasect: Just use regular constructor syntax.
19:45:07 <dmwit> > Node 3
19:45:07 <humasect> without record names? =)
19:45:08 <lambdabot>       Overlapping instances for Show (Forest t -> Tree t)
19:45:08 <lambdabot>        arising from...
19:45:16 <dmwit> > Node 3 []
19:45:18 <lambdabot>   Node {rootLabel = 3, subForest = []}
19:45:25 <humasect> yeah, that, hm.
19:45:35 <humasect> it is the only place i find braces in my code
19:46:41 <roconnor> > runState (mdo {a<-get; put y; z<-get; put 5; y<-get; put a; return z} 0
19:46:41 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 78}
19:46:42 <lambdabot> ...
19:46:50 <roconnor> > runState (mdo {a<-get; put y; z<-get; put 5; y<-get; put a; return z}) 0
19:46:52 <lambdabot>   (5,0)
19:59:39 <mmorrow> this page has some interesting reading: http://www.softpanorama.org/Lang/coroutines.shtml
19:59:50 <lambdabot> Title: Coroutines
20:03:15 <micahcowan> mmorrow, does it cover coroutines in relation to FP, or just coroutines?
20:05:26 <mmorrow> micahcowan: i haven't read much, but so far i've gotten through 2 msgs from 2003 that seem to be discussions between python lang devs about stack frames and python implem partics.
20:06:42 <mmorrow> heh, reading those made the more happy than i already am about programming in a lang with optimized tail calls :)
20:06:51 <mmorrow> s/the/me/
20:07:51 <lament> scheme?
20:08:01 <mmorrow> um
20:08:47 <lament> i always heard haskell doesn't have optimized tail calls
20:09:30 <mmorrow> t3h evil mangler begs to differ ;)
20:10:03 <mmorrow> being more precise, i mean tail calling a function doesn't push a stack frame if it doesn't need to
20:10:38 <geezusfreeek> i think the only reason people say that is because they fail to understand laziness and say it must not be optimizing tail calls when they get stack overflows
20:10:55 <bos> @seen dcoutts_
20:10:55 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
20:10:56 <mmorrow> (and that tail call could possibly be indirectly via a second, third, ... function)
20:11:23 <bos> @seen dons
20:11:24 <lambdabot> dons is in #arch-haskell, #ghc, #darcs, #xmonad and #haskell. I last heard dons speak 4h 38m 9s ago.
20:11:43 <mmorrow> let f (x:xs) = x : f xs  -- the call to f gets tail-called by (:)
20:12:33 <ddarius> (:) doesn't call anything
20:12:36 <mmorrow> i've heard this refered to as "guarded recursion", but i'm not sure the exact connotation of that
20:12:52 <mmorrow> ddarius: yeah, you know what i mean
20:13:31 <ddarius> mmorrow: Not really.  There are no tail calls there (except to (:))
20:14:10 <dmwit> :t mfix
20:14:11 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
20:14:19 <mmorrow> by "tail call" i really mean "the recursive call to f doesn't push a stack frame"
20:14:37 <dmwit> I wish I had known about mfix sooner.
20:14:48 <humasect> :t MonadFix
20:14:49 <lambdabot> Not in scope: data constructor `MonadFix'
20:14:56 <humasect> :i MonadFix
20:14:59 <dmwit> ?instances MonadFix
20:15:00 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:15:04 <humasect> ah, thx=)
20:15:04 <lally> So is there anything cool to do with the compiler's type deductive logic?  Outside of saving type decls, of course.
20:15:15 <dmwit> lally: You bet!
20:15:30 <dmwit> lally: The type-level is Turing complete!  (With a few extensions.)
20:15:41 <mmorrow> i suppose this is handled by "tail-call optimization" by the compiler in general, so i think i'm not quite refering to the what i want to be when i say "f is tail called"
20:15:49 <dmwit> lally: More practically, the type system can be used to express behavioral constraints.
20:15:50 <lally> I've heard this before in C++ land, and I was hurt badly.
20:15:55 <ddarius> mmorrow: Again, it doesn't get called at all in that expression.  It does get called when someone tries to look at the tail.  Whether it is a tail call or not then depends on the context.
20:15:56 <lally> now we're talking.
20:16:21 <dmwit> lally: My favorite example of this is in xmonad.  They use newtypes to make sure that Windows and Screens (both represented as CInt internally) are never used where the other was meant.
20:16:24 <Adamant> dmwit: what's the actual point in the type system being Turing-complete?
20:16:48 <dmwit> Adamant: It's theoretically interesting.
20:16:48 <geezusfreeek> Adamant: not much unless you are trying to pull an oleg ;)
20:16:51 <mmorrow> ddarius: ok. but whether it's stack gets saved or not is context-independent (i believe).
20:16:53 <Adamant> I mean, what advantages can it give?
20:16:54 <Adamant> ah
20:16:57 <lament> Adamant: it's so that you can never be sure whether your program ever finishes to compile.
20:16:57 <dmwit> Adamant: It also means you can put the compiler in an infinite loop.
20:17:01 <mmorrow> *its
20:17:16 <Adamant> so it's not necessarily useful yet
20:17:18 <Adamant> but it might be
20:17:20 <dmwit> Adamant: On the practical side, there's not much.
20:17:31 <Adamant> if you're willing to deal with non-termination
20:17:35 <lally> Ok, I saw this in C++ land too, you can make simple wrappers around normal data to make sure they don't get used incorrectly.  E.g. Feet as struct{float value}, same as Meters, but messing the two up will cause compiler errors.
20:17:38 <mmorrow> s/saved/reused by the recursive instance of it/
20:17:42 <dmwit> Adamant: But you *could* theoretically do any computation in the compiler, and the most optimized calculation is the one that never takes place at all.
20:18:04 <dmwit> lally: Right, that's the idea.
20:18:19 <dmwit> lally: You can, of course, encode more complicated constraints, but I thought I'd start slow. =)
20:18:23 <ddarius> mmorrow: The stack frame of the outer instance has already come and gone, maybe replaced by others or rewound further or both by the time the recursive call gets invoked (if ever)
20:19:12 <mmorrow> ddarius: yes. this is what i'm refering to by "tail-call optimization"
20:19:40 <ddarius> mmorrow: That example doesn't build stack not because f doesn't ever push a stack frame, but because it has already pushed and popped by the time you ever get to the recursive instance.
20:19:41 <mmorrow> whether that is the correct term, i'm not sure
20:19:54 <Cthulhon> The IOCCC had an entry that embedded a prime number calculator in the preprocessor (by constructing a 4-bit ALU via recursive preprocessing).  I'd imagine you could do something similar with Haskell's type system.
20:20:05 <ddarius> It is not tail call optimization as usually viewed and the internal use of f isn't a tail call so it is -really- not a tail call optimization.
20:20:22 <ddarius> That example relies on laziness but not TCO.
20:21:44 <ddarius> @users
20:21:44 <lambdabot> Maximum users seen in #haskell: 516, currently: 468 (90.7%), active: 15 (3.2%)
20:22:28 <mmorrow> ddarius: so you're saying that because haskell is lazy, the cosiderations are different wrt stack frames. i believe they are, but not so radically that by virtue of laziness a naive implem would succeed in being as efficient as one which does some sort of optimization here.
20:22:46 <mmorrow> (that first sentence was a question)
20:22:50 <ddarius> mmorrow: Haskell still benefits from TCO, that particular example just has nothing to do with TCO.
20:23:03 <Saizan> foldl (+) 0 instead produces the lazy accumulator in constant stack thanks to TCO, which then blows the stack since it's not made of tail calls (with a strict (+))
20:23:19 <ddarius> Also, Haskell is lazy -by-default-, not completely lazy.
20:23:27 <mmorrow> hmm
20:24:14 <mmorrow> ddarius: you are taking into account that a function may be "tail-called" indirectly by another function, correct?
20:24:29 <ddarius> mmorrow: That has nothing to do with that example.
20:24:54 <mmorrow> ok, i wanted to be sure you were sure.
20:25:10 <ddarius> That example will run in constant stack regardless of whether the implementation supports TCO or not.
20:25:39 <mmorrow> hmm
20:25:41 <ddarius> Of course, the function traversing the list may not if the language doesn't support TCO.
20:26:26 <mmorrow> ok, so you are now refering to the "f" in that example?
20:26:44 <ddarius> No, I'm referring to, say, last.
20:26:53 <ddarius> last will not run in constant stack space without TCO.
20:28:09 <mmorrow> so then you are saying that "f" will regardless of tco because it simply traverses the list forever or pattern-match-fails at the end (==> never returns a value)?
20:28:36 <mmorrow> err, it does return the list...
20:28:47 <ddarius> f immediately returns.  It doesn't call itself recursively.
20:28:58 <mmorrow> let f (x:xs) = x : f xs
20:29:20 <mmorrow> (i'm assuming the recursive call to f is demanded)
20:29:25 <lally> If I want to run f on all combinations of values from two lists (e.g. (foo f [a,b,c] [d,e,f]) -> ((f a d) (f b e) (f c f))), is there already a function available?  my version's getting a little circular.
20:29:37 <mmorrow> (to infinity and beyond)
20:29:50 <sjanssen> lally: liftM2 f [a, b, c] [d, e, f]
20:30:35 <sjanssen> lally: oh, is that what you really want?  To you want every pair, or just pairs in the same positions?
20:30:47 <sjanssen> > zipWith (+) [1, 2, 3] [4, 5, 6]
20:30:49 <lambdabot>   [5,7,9]
20:30:50 <lally> sjanssen: every pair, sorry, misleading example
20:30:51 <ddarius> mmorrow: And every time f is called it immediately returns.  A stack frame is pushed and then popped immediately (or in many cases never pushed)
20:30:58 <dobblego> zipWith f
20:31:03 <sjanssen> > liftM2 (+) [1, 2, 3] [4, 5, 6]
20:31:05 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:31:11 <lally> (f a d) (f a e) (f a f) (f b d) ...
20:31:14 <Pseudonym> > return (*) `ap` [1,2,3] `ap` [4,5,6]
20:31:15 <lambdabot>   [4,5,6,8,10,12,12,15,18]
20:31:21 <sjanssen> lally: right, you want liftM2
20:31:23 <Pseudonym> > return (+) `ap` [1,2,3] `ap` [4,5,6]
20:31:25 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:31:27 <lally> even if I'm not in a monad?
20:31:30 <Pseudonym> Hmm.
20:31:31 <dobblego> f <$> [a,b,c] <*> [d,e,f']
20:31:34 <dmwit> lally: Lists are a monad.
20:31:36 <sjanssen> lally: lists are a Monad :)
20:31:44 <mmorrow> ddarius: is it /ever/ actually pushed though? my understanding is that the recursive call reuses the stack frame of its caller
20:31:46 <dmwit> lally: (Surprise! =)
20:31:52 <Pseudonym> :t (<$>)
20:31:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:31:59 <lally> if you guys start telling me to bend spoons with my mind, I'm gonna go crazy
20:32:15 <Pseudonym> > (+) <$> [1,2,3] <*> [4,5,6]
20:32:16 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:32:21 <dmwit> No no no, you have to bend your *mind*, not the spoon!
20:32:28 <dmwit> There is no spoon.
20:32:28 <sjanssen> lally: you might find [f x y | x <- xs, y <- ys] to be more straightforward at this point
20:32:32 <ddarius> mmorrow: First off, in the worst case, no TCO, it will be pushed and immediately popped, it won't build up.  Even with TCO this can happen e.g. tail (f xs) + 3
20:33:08 <lally> sjanssen: that does sound more straightforward.  Will it do (length xs) iterations of f, or (length xs * length ys) ? The latter's what I want.
20:33:24 <sjanssen> lally: the latter
20:33:28 <lally> sweet
20:33:29 <lally> thanks
20:33:36 <dobblego> > (+) <$> [1,2,3] <*> [4,5,6] -- 3 * 3
20:33:37 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:33:40 <Pseudonym> Aha.
20:33:46 <mmorrow> ddarius: yeah, that's true that it wouldn't be hard pressed without tco.
20:33:55 <Pseudonym> > repeat (+) <*> [1,2,3] <*> [4,5,6]
20:33:56 <lambdabot>   [5,6,7,6,7,8,7,8,9,5,6,7,6,7,8,7,8,9,5,6,7,6,7,8,7,8,9,5,6,7,6,7,8,7,8,9,5,...
20:34:00 <Pseudonym> Hmm.
20:34:02 <sjanssen> lally: later on you can learn that list comprehensions are a monadic interface and advance to liftM2 :)
20:34:15 <Pseudonym> > repeat (+) <$> [1,2,3] <$> [4,5,6]
20:34:16 <lambdabot>   Couldn't match expected type `a -> b'
20:34:34 <lally> sjanssen: we'll worry about that bridge when we get there :-)
20:34:36 <dobblego> > (+) <$> [1,2,3] <*> [4,5,6] -- 3 * 3 (so long as you use <$> and not <*> for f)
20:34:37 <lambdabot>   [5,6,7,6,7,8,7,8,9]
20:34:54 <mmorrow> , 123
20:35:43 <ddarius> mmorrow: To see it, think of laziness in Scheme.  (define (f xs) (cons (car xs) (lambda () (f (cdr xs)))))
20:38:57 <mmorrow> ddarius: interestingly, (to stray slighlty from the topic), i'm playing with that exact same construction there with this javascript quasiquoter. it's amusing manipulating these massive js expressions and printing them in ghci/repeat as if they we a tree of Ints or something
20:39:30 <mmorrow> i should add that to lunabot's imports
20:39:40 <mmorrow> , [$rx|.+|]
20:39:43 <lunabot>  luna: No instance for (GHC.Show.Show
20:39:43 <lunabot>                     (GHC.Base.String -> Data.Maybe.Maybe [GHC.Base.String]))
20:39:43 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-59
20:40:10 <mmorrow> , [$rx|(.{4})|] ['a'..]
20:40:12 <lunabot>  Just ["abcd","abcd"]
20:40:35 <b\6> i'm just in time for the weird stuff.
20:40:37 <mmorrow> , [$rx|.(.((.{4}).))|] ['a'..]
20:40:38 <lunabot>  Just ["abcdefg","bcdefg","cdefg","cdef"]
20:40:53 <mmorrow> b\6: heh
20:41:16 <ddarius> mmorrow: If you know what trampoline-style is, then you can think of it like that.
20:42:03 <mmorrow> ddarius: yes. i also know that is vastly inferior to proper tco wrt efficiency in the general case.
20:44:28 <mmorrow> ok, so i think i have the overhead perspective now on our discussion, (correct me if i'm wrong). so, the case with "f" does /not/ require tco to run in constant space, because it will at most ever accum 1 pushed stack frame, and this is independent of laziness.
20:45:06 <mmorrow> or is it preciself /because/ of laziness?
20:45:49 <mmorrow> (i'm assuming rnf or equiv has been called on the list which f produces)
20:47:05 <mmorrow> i'm, gonna look in to whether f reuses its stack frame also (not that this is particularly relevant from an efficiency standpoint in this case ..).
20:47:54 <ddarius> mmorrow: It's because of laziness, if it weren't for laziness it'd a) loop forever and b) accumulate stack regardless of TCO.
20:48:35 <lally> If I get an exception on output (e.g.  *** Exception: Prelude.(!!): index too large), can I get a backtrace?
20:48:48 <lally> (ghci 6.8.3)
20:49:02 <mmorrow> i'm not so sure about b). i'm satified for the moment though (and have to run). catch you later.
21:03:58 <mml`> :t 2/3
21:04:00 <lambdabot> forall t. (Fractional t) => t
21:04:05 <sbahra> :t div 2 3
21:04:05 <mml`> :t 0/0
21:04:06 <lambdabot> forall t. (Integral t) => t
21:04:06 <lambdabot> forall t. (Fractional t) => t
21:04:15 <sbahra> :t div 1 0
21:04:16 <lambdabot> forall t. (Integral t) => t
21:04:22 <mml`> :t 3/3
21:04:23 <lambdabot> forall t. (Fractional t) => t
21:04:36 <mml`> why des it think 0/0 is INtegral, but 3/3 is not?
21:04:37 <sbahra> :t (/)
21:04:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:04:42 <sbahra> It doesn't.
21:04:45 <sbahra> :t div
21:04:46 <lambdabot> forall a. (Integral a) => a -> a -> a
21:04:48 <sbahra> :t (/)
21:04:49 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:04:55 <mml`> :t 0/0
21:04:57 <lambdabot> forall t. (Fractional t) => t
21:05:00 <sbahra> :t 2 `div` 3
21:05:01 <lambdabot> forall t. (Integral t) => t
21:05:03 <sbahra> :t 2 / 3
21:05:04 <mml`> ah, oh.  just reading out of order.
21:05:04 <lambdabot> forall t. (Fractional t) => t
21:05:24 <mml`> PEBKAC
21:12:05 <dons> bos?
21:12:21 <bos> dons: was just hoping you might prod duncan for me :-)
21:12:29 <bigtalk> would there be any interest in machine learning libraries for haskell?
21:12:29 <dcoutts> @arr!
21:12:29 <lambdabot> I'll crush ye barnacles!
21:12:35 <dons> bos, sure. he's right here.
21:12:44 <dons> want me to wack him over the head with something?
21:12:46 <dons> he's not looking.
21:12:50 <bos> :)
21:12:55 <bigtalk> i normally use python and i dont want to spend a lot of time writing something that wont be used
21:13:58 <dons> bigtalk: you could just put it on hackage.haskell.org
21:13:59 <bos> bigtalk: i think we had some summer of code people doing a bit of that last year? or maybe they applied and were rejected?
21:14:09 <bos> bigtalk: are you talking about HMMs and the like?
21:14:10 <dons> people will use it if it's useful.
21:15:38 <bos> machine learning is a narrowish field. so just bear in mind that haskell is relatively small, machine learning is small, and the intersection of the two isn't going to be huge.
21:18:03 <dons> it might be fun though :) and you may be able to publish a paper on the result
21:18:49 <dmwit> bigtalk: I've been writing a multi-dimensional array library that you might find useful as a starting point, if you do decide to write some machine learning code.
21:36:24 <mmorrow> pretty cool: http://www.chiark.greenend.org.uk/~sgtatham/coroutine.h
21:36:32 <mmorrow> from http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
21:36:34 <lambdabot> Title: Coroutines in C
21:38:23 <Axman6> "Bravo, Axman6! Now that you have solved 25 problems you have achieved what 78.61% of members have failed to do and have advanced to level 1. Good luck as you continue." \o/
21:39:46 <ivanm> O...K... then...
21:40:09 <Axman6> project euler
21:41:09 <yakov2> Axman6 \o/
21:41:09 <dmwit> Level 1?
21:41:16 <dmwit> WTF happened to Project Euler?
21:41:25 <Axman6> dmwit: ?
21:41:29 <PHO_> http://projecteuler.net/ heh... it looks interesting
21:41:35 <lambdabot> Title: Project Euler
21:41:35 <dmwit> Axman6: Since when were there levels?
21:41:38 <Axman6> it's very interesting :)
21:41:40 <yakov2> "Problems Solved: 	30 out of 210"
21:41:42 <Axman6> dmwit: no idea
21:42:16 <dmwit> "26 more until next level" weird
21:43:03 <dmwit> There are PDFs for problems now?
21:43:11 <dmwit> more and more weird
21:43:29 <Axman6> eh?
21:59:16 <adu> hi
21:59:16 <adu> how do you represent (void *) in Haskell? Ptr a?
21:59:31 <sjanssen> or Ptr (), perhaps
21:59:46 <sjanssen> that will at least require an explicit cast to peek or poke
21:59:51 <adu> sjanssen: ah, that makes more sense
22:02:10 <dons> Ptr () , yes.
22:04:33 <bigtalk> dmwit: link?
22:04:58 <thetallguy> So, what do y'all think about OneTuple?
22:05:19 <Pseudonym> I'm concerned about the duplication of effort.
22:05:45 <Pseudonym> OneTuple, Control.Monad.Id, An from the idioms paper.
22:06:11 <Pseudonym> We should put our combined resources into the One True Version.
22:06:15 <sjanssen> Pseudonym: one difference is that OneTuple is lifted where the usual Id type is unlifted
22:06:23 <thetallguy> Okay, well, that answers my question.
22:06:28 <glguy> MonadLib.Lift?
22:06:30 <Pseudonym> Oh, good point.
22:06:37 <Pseudonym> So we really need two of them.
22:06:42 <thetallguy> For some reason, I read the headline and the first line and assumed the whole thing was a joke.
22:06:55 <Pseudonym> The default should be lifted so it's a Functor.
22:06:59 <thetallguy> Then the thread got longer and the tail messages looked serious
22:07:07 <thetallguy> So I guess I'll have to read the whole thing
22:07:17 <sjanssen> Pseudonym: the unlifted version isn't a Functor?
22:07:31 <Pseudonym> I don't think so, no.
22:07:38 <Pseudonym> Let's see...
22:07:46 <Pseudonym> newtype OneTuple a = OneTuple a
22:07:58 <Pseudonym> fmap f (OneTuple x) = OneTuple (f x)
22:07:59 <Pseudonym> Right?
22:08:05 <sjanssen> Pseudonym: you should use another name to avoid confusion
22:08:11 <sjanssen> data OneTuple a = OneTuple a
22:08:15 <Pseudonym> Good point.
22:08:39 <Pseudonym> newtype UnliftedId a = UnliftedId a
22:08:42 <Pseudonym> So.
22:08:52 <bigtalk> @dmwit
22:08:52 <lambdabot> Unknown command, try @list
22:08:56 <Pseudonym> fmap (const ()) (OneTuple bottom) = ?
22:09:00 <bigtalk> @seen dmwit
22:09:00 <lambdabot> dmwit is in #haskell, #xmonad and #haskell-blah. I last heard dmwit speak 25m 49s ago.
22:09:02 <Pseudonym> Is it OneTuple () or bottom?
22:09:18 <sjanssen> ()
22:09:35 <Pseudonym> And fmap (const ()) bottom = ?
22:09:43 <sjanssen> bottom
22:09:51 <dmwit> bigtalk: One sec.
22:09:54 <bigtalk> does anyone have a classification problem or clustering problem you ant solved?
22:09:59 <Pseudonym> Really?
22:10:00 <sjanssen> but () with the unlifted version
22:10:12 <bigtalk> what kind of code do you people write for a living?
22:10:15 <Pseudonym> Yes, I'm talking about the unlifted version.
22:10:35 <sjanssen> is this one of the Functor laws?
22:10:46 <Pseudonym> I think it might be a consequence of one of them.
22:10:50 <Pseudonym> Just a moment, let me check.
22:11:21 <sjanssen> fmap id == id and fmap f . fmap g == fmap (f . g) -- are those the only laws?
22:11:38 <dmwit> bigtalk: dmwit.com/MultiArray.hs
22:12:02 <dmwit> bigtalk: No documentation on it, though, and it isn't really all that featureful... just some things that happened to be handy on a recent ML homework assignment. =P
22:12:10 <dmwit> err
22:12:17 <dmwit> that probably imports Dmwit.hs, heh
22:12:20 <dmwit> Let's fix that.
22:12:30 <adu> bigtalk: php
22:12:41 <Pseudonym> Hmm, you may be riht.
22:12:59 <Pseudonym> I do seem to recall some situation where strictness caused a container to fail to obey the Functor laws.
22:13:10 <Axman6> wow, haskell scares me sometimes. just wrote something that i thought would take forever, took a third of a second
22:13:20 <Pseudonym> bigtalk: Nanotech firmware, mostly.
22:13:30 <Axman6> well, GHC scares me at least
22:13:38 <sjanssen> of course unlifted data differs very slightly from strictness in Haskell
22:13:52 <Pseudonym> Though my probably next job will be working out how to use a 50,000 CPU supercomputer to do bioinformatics.
22:14:05 <adu> bigtalk: EigenTrust solves everything :)
22:14:19 <PHO_> bigtalk: perl/CGI
22:14:52 <PHO_> Pseudonym: your job sounds very interesting
22:15:15 <dmwit> bigtalk: Okay, it should compile now.
22:15:16 <Pseudonym> PHO: Well, the next job will be at a different place.
22:15:34 <Pseudonym> But I'll let you in on a secret.  Everything is work.
22:15:50 <adu> Axman6: lol
22:15:55 <PHO_> haha
22:16:16 <adu> in that case, I "work" for haskell.org
22:16:19 <Axman6> Pseudonym: did you see that article on using bloom filters in haskell for bioinformatics?
22:16:34 <Pseudonym> I did, but the stuff I'll be doing is a bit different.
22:17:06 <Pseudonym> Searching databases is one thing.  Creating the databases in the first place is a bit trickier.
22:17:42 <adu> right, you have to deal with, you know, reality
22:18:10 <mmorrow> bigtalk: i'd use code for that for sure.
22:18:12 <Pseudonym> A more typical scenario is that someone comes to you with gene fragments from 50 people with some disorder and you have to work out what genes they have in common that deviate from "normal".
22:19:43 <Adamant> Pseudonym: how is working in the health care/drug company/etc. area of IT?
22:19:55 <Pseudonym> I don't.
22:19:59 <Adamant> ah.
22:20:02 <Pseudonym> So I don't know.
22:20:04 <Adamant> but you work with genetics?
22:20:07 <Pseudonym> Not yet.
22:20:11 <Adamant> ah
22:20:20 <Adamant> a premature question.
22:20:22 * mmorrow enjoys looking at R bio/gene-related graphics
22:20:27 <Pseudonym> That's next job.  It's not 100% certain, but one of my referees on my job application a) asked me to work there, and b) will be my boss.
22:20:29 <adu> Pseudonym: so you make micromachines ?
22:20:35 <Pseudonym> Nope.
22:20:51 <adu> Pseudonym: then what did you mean by "Nanotech firmware"?
22:20:58 <Pseudonym> Ah, well.
22:21:25 <adu> is it like nanomachine OS writing?
22:21:28 <Pseudonym> It is a nano-device.
22:21:34 <Pseudonym> But it's more like a transducer.  A sensor.
22:21:48 <Pseudonym> The electronics is macro-scale.
22:22:36 <Pseudonym> We don't do micro-machines and we don't do nanotubes.  Hence, nobody on slashdot cares about this area of nanotech.
22:23:32 <adu> Pseudonym: are you designing a worm hole?
22:24:11 <adu> sounds like time travel to me, I think /. would care about that!
22:24:42 <PHO_> They definitely do.
22:25:25 <adu> although I think time travel isn't supposed to be invented for another 25 years... ;)
22:25:58 <adu> at least thats what the guy from 2045 told me :P
22:26:06 <Pseudonym> No, no time travel, sadly.  And surely it's CERN that's making the singularities.
22:26:11 <jeffz> some conspiracy theorists would have you believe it's already been invented
22:26:33 <Pseudonym> Not true.  Time travel won't have been invented until 20 years ago.
22:26:49 <PHO_> lol
22:27:36 <adu> Pseudonym: scary, he said the same thing too! that CERN invent(ed) it
22:28:00 <sandbox> how can I perform compile-time Char or Char# -> Word8 with ghc?
22:29:05 <dons> just use a Char and ghc will constant fold
22:29:21 <sandbox> thanks
22:29:51 <mmorrow> http://www.lysator.liu.se/c/duffs-device.html
22:29:57 <lambdabot> Title: Tom Duff on Duff's Device
22:30:24 <adu> sandbox: or w2c and c2w
22:30:28 <roconnor> dons will it really?
22:30:31 <mmorrow> @nixon
22:30:31 <lambdabot> This is a great day for France!
22:30:36 <mmorrow> @nixon
22:30:37 <lambdabot> I can take it. The tougher it gets, the cooler I get.
22:30:50 <PHO_> How do you feel about death from inflating black hole? For me it's not too unacceptable.
22:30:57 <roconnor> sandbox: at the very least the conversion will be memoized :)
22:32:06 <Cale> PHO_: Where is the inflating black hole going to come from?
22:32:13 <PHO_> CERN
22:32:57 <Cale> Oh?
22:34:09 <Cale> They're not doing anything more than what the Earth has already experienced many times over, only they're observing it.
22:34:09 <PHO_> http://jp.youtube.com/watch?v=BXzugu39pKM
22:34:14 <lambdabot> Title: YouTube - The CERN black hole
22:34:23 <PHO_> I know :)
22:34:26 <dons> well, it depends on what you're doing roconnor
22:34:33 <dons> ghc-core knows the answer
22:35:18 <Axman6> is there any easy way to implement a doubly linked list in haskell?
22:35:40 <dons> mm :) a challenge for the unwary.
22:36:07 <Axman6> i don't need to use one, just curious :)
22:36:11 <dons> what operations do you need? previous and next? but not circular?
22:36:12 <dmwit> ?go tying the knot haskell
22:36:25 <Pseudonym> ?ho haskell zipper
22:36:25 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
22:36:26 <lambdabot> http://www.haskell.org/haskellwiki/Tying_the_Knot
22:36:26 <lambdabot> Title: Tying the Knot - HaskellWiki
22:36:28 <Axman6> could always used what i did for the turing machine stuff i was playing with (T [a] a [a])
22:36:32 <Pseudonym> ?go haskell zipper
22:36:40 <lucca> > 4 * sum [(-1)**n / (2*n + 1)  | n <- [0..100000]]
22:36:44 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Zippers
22:36:46 <lambdabot>   3.1416026534897203
22:36:51 <dmwit> Axman6: Yeah, a ([a], [a]) is one easy solution.
22:36:55 <dons> Z { prev :: [a], this :: a , next :: [a] }
22:37:08 <Pseudonym> You can't represent empty lists with that, dons.
22:37:15 <dons> Maybe Z
22:37:16 <quicksilver> Axman6: you can do a 'real' doubly linked list. But, it's not very useful.
22:37:20 <dmwit> Z { prev :: Z a, this :: a, next :: Z a }
22:37:44 <Axman6> quicksilver: how would you do it?
22:37:54 <dons> btw, xmonad, stack :: Maybe (Stack a)
22:37:54 <mjrosenb> why do you need an empty list for a turing machine?
22:37:57 <quicksilver> like dmwit said just there.
22:38:03 <Axman6> dmwit: yeah ([a], [a]) would probably be best
22:38:12 <quicksilver> although you mean need a |Nil case.
22:38:13 <dons> data Stack a = Stack { focus  :: !a        -- focused thing in this set , up     :: [a]       -- clowns to the left , down   :: [a] }
22:38:21 <Axman6> mjrosenb: i'm not making a turing machine. already did that
22:38:47 <quicksilver> if the objective is O(1) traversal in each direction you want a zipper, though.
22:39:03 <mjrosenb> oic
22:39:12 <Axman6> just curious about the idea of a doubley linked list in haskell
22:39:25 <adu> lucca, try acos (-1)
22:39:42 <lucca> hm, that might be faster yeah
22:39:45 <Axman6> disclaimer: i'm not actually writing any code
22:39:52 <ivanm> has anyone managed to build the documentation for haskell-src-exts?
22:39:58 <adu> > acos (-1)
22:40:00 <lambdabot>   3.141592653589793
22:40:11 <adu> > pi
22:40:13 <lambdabot>   3.141592653589793
22:40:23 <Axman6> @src acos
22:40:23 <lambdabot> Source not found. Where did you learn to type?
22:40:25 <lucca> well yeah, I'm just screwing around with the list syntax :p
22:40:35 <Axman6> stupid SPU lookup tables
22:40:37 <Axman6> CPU*
22:40:40 <lucca> > sum [1 / (product [1..n]) | n <- [0..100]]
22:40:42 <lambdabot>   2.7182818284590455
22:40:57 <ivanm> I keep getting an error for some reason a line that just contains "-- |" :s
22:41:13 <Axman6> ivanm: not --|?
22:41:14 <adu> ivanm: are you using lhs?
22:41:30 <Axman6> because i've had errors with --* before. really annoying
22:41:54 <ivanm> it's got "-- |"
22:42:24 <Axman6> adu: if you were wondering, that thing that i was surprised about being so fast was this: http://hpaste.org/10856
22:42:42 <ivanm> adu: nope, it's .hs
22:42:54 <ivanm> and it's not me that's using anything ;-)
22:43:06 <adu> Axman6: ahh, numerology?
22:43:18 <Axman6> projecy euler
22:43:19 <Axman6> t8
22:43:23 <Axman6> urgh
22:43:24 <dmwit> sumDigits = sum . map digitToInt . show
22:44:01 <dons> sumDigits = sum . unsafeCoerce# . show
22:44:14 <adu> dmwit: sumDigits = flip mod 9
22:44:18 <Axman6> dons: i was trying to do that for a long time, and kept getting it wrong. i like mine
22:44:29 <dmwit> adu: Only if you want the answer mod 9.
22:44:37 <Axman6> uh, dmwit i meant
22:44:42 <ivanm> hackage has the same problem as me: http://hackage.haskell.org/packages/archive/haskell-src-exts/0.3.7/logs/failure/ghc-6.8
22:44:48 <lambdabot> http://tinyurl.com/3mmphx
22:44:54 <ivanm> thing is, it looks fine :s
22:44:54 <Axman6> dons: how unsafe is it anyway?
22:45:03 <adu> dmwit: o, I guess thats (fix sumDigits)
22:45:05 <dons> not too bad, as far as type unsafetygoes
22:45:07 <dons> Prelude GHC.Base> sum . unsafeCoerce# . show $ "1234567890"
22:45:07 <dons> 593
22:45:14 <dmwit> dons: Surely then you'd need a (map (subtract (unsafeCoerce# '0'))) in there.
22:45:38 <dons> well, if you're trying to do something sensible
22:45:48 <dmwit> oh
22:46:18 <dmwit> Axman6: 'course, mine dies on negative inputs.
22:46:28 <Axman6> heh
22:47:35 <adu> @let sumDigits = sum . map digitToInt . show
22:47:36 <lambdabot>  <local>:12:35:
22:47:36 <lambdabot>      Ambiguous type variable `a' in the constraint:
22:47:36 <lambdabot>        `S...
22:47:47 <dons> Prelude GHC.Base> sum . unsafeCoerce# . show $ replicate 1000 (Just ())
22:47:47 <dons> 579140
22:48:20 <dons> Prelude GHC.Base> sum . unsafeCoerce# . show $ replicate 1000 Data.Map.empty
22:48:20 <dons> 1108140
22:48:22 <dons> endless fun.
22:48:27 <Axman6> :|
22:48:45 <ivanm> http://hpaste.org/10857
22:48:48 <dons> Prelude GHC.Base> sum . unsafeCoerce# $ replicate 1000 unsafeCoerce#
22:48:48 <dons> <interactive>: internal error: PAP object entered!
22:48:51 <dons> not quite endless.
22:49:13 * Axman6 refrains from making a breast joke...
22:49:25 <dons> Prelude GHC.Base> sum . unsafeCoerce# $ unsafeCoerce#
22:49:26 <dons> 0
22:49:49 <dons> Prelude GHC.Base> unsafeCoerce# . unsafeCoerce# $ unsafeCoerce#
22:49:49 <dons> zsh: segmentation fault  ghci
22:49:56 <dons> the challenge with C is writing correct programs
22:51:09 <adu> @let sumDigits = sum . map digitToInt . show :: Int -> Int
22:51:10 <lambdabot>  Defined.
22:51:29 <adu> @let fixDigits = flip mod 9 :: Int -> Int
22:51:31 <lambdabot>  Defined.
22:53:15 <adu> @pl \x -> fix sumDigits x == fixDigits x
22:53:15 <lambdabot> ap ((==) . fix sumDigits) fixDigits
22:53:28 <adu> @check ap ((==) . fix sumDigits) fixDigits
22:53:29 <lambdabot>   Not in scope: `sumDigits'Not in scope: `fixDigits'
22:53:46 <adu> ?
22:57:30 <glguy> This problem lends itself to a really simple / efficient / short list-based solution, if anyone was looking for something to do :) http://projecteuler.net/index.php?section=problems&id=205
22:57:31 <lambdabot> Title: Problem 205 - Project Euler
22:58:22 <elliottt> @check ap ((==) . fix (sum . map digitToInt . show)) (flip mod 9)
22:58:22 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Int'
22:58:32 <elliottt> ooh, fail.
22:59:22 <PHO_> > let fac 0 = 1; fac x = x * fac (x-1) in 1 / ((2 * sqrt 2) / (99**2) * sum [(fac (4*n) * (1103+26390*n)) / ((4**n * 99**n * fac n)**4) | n <- [0..2]])
22:59:23 <lambdabot>   3.141592653589793
22:59:58 <dmwit> > let f m n = m^2 * n^2 - 3 * m^2 * n - 3 * m * n^2 + 9 * m * n in f 1 1
22:59:59 <lambdabot>   4
23:00:02 <dmwit> > let f m n = m^2 * n^2 - 3 * m^2 * n - 3 * m * n^2 + 9 * m * n in f 1 2
23:00:03 <lambdabot>   4
23:00:07 <dmwit> uh-oh
23:00:09 <Pseudonym> > iterate (\x -> x + sin x) 3.0
23:00:10 <lambdabot>   [3.0,3.1411200080598674,3.1415926535721956,3.141592653589793,3.141592653589...
23:00:31 <dmwit> > let f m n = m^2 * n^2 - 3 * m^2 * n - 3 * m * n^2 + 9 * m * n in f 2 3
23:00:33 <lambdabot>   0
23:01:05 <PHO_> How can I use an arbitrary-precision Double to calculate pi more further with Ramanujan's formula?
23:01:35 <dmwit> > pi :: CReal
23:01:36 <lambdabot>   3.1415926535897932384626433832795028841972
23:01:40 <Axman6> heh
23:01:57 <dmwit> PHO_: Double is by definition not arbitrary-precision.
23:02:01 <dmwit> You need a different data type.
23:02:06 <PHO_> yes, I know
23:02:08 <rwbarton> @src (\\)
23:02:09 <lambdabot> (\\) = foldl (flip delete)
23:02:13 <rwbarton> Is this a good definition?
23:02:17 <dmwit> PHO_: CReal is such a type. =)
23:02:21 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9])10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
23:02:22 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 179}...
23:02:23 <PHO_> heh. thanks
23:02:56 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9])10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 10
23:02:56 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 179}...
23:03:01 <Pseudonym> Hrm.
23:03:52 <PHO_> > let fac 0 = 1 :: CReal; fac x = x * fac (x-1) in 1 / ((2 * sqrt 2) / (99**2) * sum [(fac (4*n) * (1103+26390*n)) / ((4**n * 99**n * fac n)**4) | n <- [0..2]])
23:03:54 <lambdabot>   3.1415926535897932384626490657027588981567
23:04:23 <PHO_> 3.14159265358979323846264 |<- right, wrong ->| 90657027588981567
23:04:31 <PHO_> > let fac 0 = 1 :: CReal; fac x = x * fac (x-1) in 1 / ((2 * sqrt 2) / (99**2) * sum [(fac (4*n) * (1103+26390*n)) / ((4**n * 99**n * fac n)**4) | n <- [0..10]])
23:04:44 <lambdabot>   3.1415926535897932384626433832795028841972
23:05:04 <PHO_> > let fac 0 = 1 :: CReal; fac x = x * fac (x-1) in 1 / ((2 * sqrt 2) / (99**2) * sum [(fac (4*n) * (1103+26390*n)) / ((4**n * 99**n * fac n)**4) | n <- [0..20]])
23:05:09 <quicksilver> dmwit: does CReal have an arbitrary limit on its Show instance?
23:05:19 <lambdabot>   thread killed
23:05:26 <dmwit> quicksilver: Yes, but it also has a function to select the number of digits you want.
23:05:27 <PHO_> oh my
23:05:29 * quicksilver nods
23:06:12 <Pseudonym> > let p d = take d(fix(\i y h->let(z,x)=fix(\f xs->case xs of{((n,d,c):y)->let{(z,k)=f y;(q,r)=(c*10+k)`divMod`d}in((n,d,r):z,n*q);_->([],0)})y in case x of{9->i z(h++[9]);10->i z(map(\x->(x+1)`mod`10)h++[0]);_->h++i z[x]})((1,10,2):[(i,2*i+1,2)|i<-[1..(10*d)`div`3]])[])in p 100
23:06:14 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
23:06:21 <Pseudonym> There we go.
23:06:29 <Pseudonym> Change the 100 at the end to whatever you like.
23:07:32 <PHO_> Pseudonym: what is the name of your algorithm?
23:07:50 <Pseudonym> I call it Frank.
23:08:00 <Pseudonym> But actually, it's computing the continued fraction incrementally.
23:08:07 <PHO_> hm
23:09:42 <dmwit> > let f m n = m * n * (m + 1) * (n + 1) in f 1 1
23:09:43 <lambdabot>   4
23:09:44 <dmwit> > let f m n = m * n * (m + 1) * (n + 1) in f 1 2
23:09:45 <lambdabot>   12
23:09:47 <dmwit> better
23:09:50 <dmwit> > let f m n = m * n * (m + 1) * (n + 1) in f 2 3
23:09:52 <lambdabot>   72
23:10:02 <dmwit> > 18 * 4
23:10:03 <lambdabot>   72
23:10:25 <humasect> how come in record syntax, semicolons are not used instead of ',', like other curly brace syntax usage ?
23:11:06 * ski has wondered about that, too
23:11:13 <adu> humasect: to be similar to x,y::Int
23:11:34 <adu> humasect: otherwise you would have   x; y :: Int which would look odd as well
23:11:42 <glguy> because ; is option and , isn't?
23:11:46 <glguy> optional
23:12:10 <ski> adu : but in record syntax you have `data Foo = F {x :: Int,y :: Int,b :: Bool}'
23:12:38 <humasect> Data {x=y; z=10}  like  do {x <- y; return$z 10}
23:12:49 <ski> it might have been better to use instead `data Foo = F {x,y :: Int; b :: Bool}'
23:13:02 <adu> I think its because you can do Rect {x,y,w,h :: Int} or Rect { x :: Int, y :: Int, w :: Int, h :: Int } the comma is the same, just makes sense
23:13:31 <humasect> for designing the types, sure adu, it is also like import lists and such to have commas.
23:13:45 <ski> the comma in ordinary type signatures is just for giving several patterns the *same* type .. not for separating different type signatures
23:14:23 <ski> (yes, it could also be nice if import,export lists used (or allowed) semi-colons ..)
23:14:35 <adu> ski: true, in my language ; is also used for heterogeneous separations
23:14:50 <ski> adu : your language ?
23:14:51 <humasect> hehe
23:15:04 <adu> ski: http://tetration.itgo.com/up/
23:15:07 <monochrom> English.
23:15:10 <lambdabot> Title: The Droscript Specification
23:15:11 <adu> ski: I'm still designing it
23:15:28 <adu> ski: I've implemented half a parser and half a typechecker
23:15:55 <ski> monochrom : Tack .. Svenska hr
23:16:23 <monochrom> I mean English uses ; for heterogenous separations.
23:16:50 <humasect> it looks kind of neat adu, but i don't know what the page is talking about hehe. i see an example at the bottom and it makes me see how haskell's syntax can be further simplified to basic constructs
23:16:55 <ivanm> has _anyone_ managed to build the haddock documentation for haskell-src-exts?
23:16:58 <humasect> (or is it? aside from the sugar)
23:18:44 <adu> humasect: ya, I definitely want it to be simplified :)
23:18:44 <adu> humasect: if I can figure out a way, I'm going to make (=) and (::) redefinable
23:18:56 <humasect> hm neat =)
23:19:03 <ski> monochrom : even if there's no sub-separation of items by ',' ?
23:19:29 <monochrom> Yes.
23:19:47 <humasect> hello; my name is huma.  i bought: an apple, two forks, and an egg; i wonder what i can make?
23:22:48 <quicksilver> @remember Pseudonym < PHO_> Pseudonym: what is the name of your algorithm? < Pseudonym> I call it Frank.
23:22:48 <lambdabot> It is stored.
23:22:49 <PHO_> humasect: an apple which tastes like eggs, and an egg which looks like apples.
23:22:58 <humasect> hehehe
23:23:07 <adu> humasect: an apple omelette?
23:23:14 <humasect> semicolon soup
23:23:55 <humasect> > let x ((+2) -> y) = y+y
23:23:55 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 20}
23:23:56 <lambdabot> ...
23:25:56 <ski> humasect : your Droscript declaration of `Maybe' looks quite strange .. care to elaborate ?
23:26:05 <humasect> @adu
23:26:05 <lambdabot> Maybe you meant: arr ask id
23:26:22 <monochrom> I wonder if you can make an ipod. You have an apple to start with...
23:26:31 <ski> s/humasect/adu/, yes
23:26:59 <humasect> monochrom: i would probably need more eggs
23:27:06 <adu> skioh, sure
23:27:24 <ski> .. try making a few tetrapods
23:27:29 <PHO_> 1. Slice the apple.  2. Colour each slices with 6 different pigments
23:27:59 <ski> (or was it tripods .. ?)
23:28:03 <adu> well, the symbol datatype should be somewhat similar to Mathematica
23:28:18 <humasect> hehe PHO_
23:28:39 <ski>   Maybe :: Type -> Type
23:28:40 <ski>   Maybe t (Just x) = t x
23:29:03 <ski> why is `Maybe' (apparently ?) applied to two arguments ?
23:29:07 <adu> ski: that was back when I did not distinguish between "Type" and "a -> Bool"
23:29:21 <adu> ski: I'm starting to think I need to distinguish the two
23:29:28 <ski> oh, so that's deprecated, then ?
23:29:35 <adu> ski: maybe
23:30:11 * ski doesn't know how symbols work in Mathematica ..
23:30:17 <adu> ski: now I think it would be more appropriate to have (?) :: Type -> a -> Bool
23:30:23 <adu> so Int? 3 == True
23:30:27 <ski> does Droscript symbols "contain" their name ?
23:31:01 <adu> ski: well, I think a Haskell implementation can be found in "numbers" hackage package
23:31:19 <ski> or is the name immaterial, so that you can rename at will, but still refer to the same thing
23:31:23 <ski> ?
23:31:29 <adu> ski: where (Sym a) is basically an enumeration type
23:31:46 <adu> ski: no, the name is concrete
23:31:52 <ivanm> anyone know what happened to ghc-src that lemmih started work on a few years ago?
23:31:55 <adu> F[x] != G[y]
23:32:01 <adu> but F[x] == F[x]
23:32:25 <ski> how about `F == G  =>  F[x] == G[x]' ?
23:33:10 <adu> ski: hmm, maybe if F := G, yes
23:33:30 <eck_> does someone happen to know what package/module contains the haskell version of the unix function inet_aton (or inet_addr)? I'm having difficulty finding it...
23:33:55 <ski> (`F' and `G' here doesn't have the same name, but are *assumed* to be the same symbol .. under such an assuption (if consistent), `F[x]' should be equal to `G[x]', methinks)
23:34:04 <adu> ski: http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-Symbolic.html
23:34:06 <lambdabot> Title: Data.Number.Symbolic, http://tinyurl.com/67aufo
23:34:55 <adu> ski: well, Mathematica is silly, and says that both F and G are of type Function, so its ok :P
23:35:25 <quicksilver> eck: it's in Network.Socket
23:35:32 <quicksilver> eck: note that you don't normally need it.
23:35:45 <quicksilver> eck: the high level interface in 'Network' is normally enough.
23:35:52 <dancor> is this the best way to do this?  fromIntegral kills me
23:35:55 <dancor> http://hpaste.org/10858
23:35:57 <eck> quicksilver, thanks
23:36:04 * ski wonders how to do capture-avoiding substitution with `Data.Number.Symbolic' ..
23:36:41 <ski> adu : "so it's ok" .. what is ok ?
23:36:48 <adu> but what I think it most useful about symbols is the ability to do so much manupulation, summation, division, etc, then say let x = 4 in expr where "expr" is something you may have calculated before hand, and cannot be replaced in the traditional way
23:37:19 <monochrom> I think it's quite nice, dancor.
23:37:33 <ski> (where `x' is dynamically free in `expr' ?)
23:38:00 <adu> ski: I'm not sure I understand dynamic
23:38:15 <adu> ski: o yes
23:38:53 <adu> maybe not like that, but maybe more like subs (Sym "x", 4) expr, but something like that
23:39:54 <ski> adu : sorry .. i'm assuming that you *don't* mean that `expr' is a meta-variable standing for a haskell expression which has free occurances of the haskell variable `x' .. but rather that the haskell expression is a haskell variable `expr' which dynamically, at run-time (?), will be bound to a symbolic expression tree which may contain "free" occurances of the *symbol* `x'
23:41:11 <ski> (adu : reasking : *what* was ok about `F' and `G' above ?)
23:41:19 <adu> ski: yes that is correct, although the method by which the "freeness" is encoded, and the method for substituting it remain to be worked out...
23:41:34 <ski> ok
23:44:25 <adu> ski: I basically want to find a way to combine the flexibility of symbols with the strength of types
23:44:38 <adu> ski: the sad part is that symbols totally break the monomorphism restriction
23:45:53 <dmwit> ?pl \f g pairs -> any (uncurry f) pairs && any (uncurry g) pairs
23:45:53 <lambdabot> (. (any . uncurry)) . ap . ((&&) .) . any . uncurry
23:46:57 <adu> ski: because for "symbol" to be well defined, it would have to be of type (String -> a) so you can say (symbol "Pi") :: Double and (symbol "Age") :: Int
23:48:16 <glguy> adu: that function already exists
23:48:16 <glguy> :t error
23:48:18 <lambdabot> forall a. [Char] -> a
23:48:34 <ski> adu : how does this break the DRM^H^HMR ?
23:49:32 <adu> ski: well, I thought that you can't use polymorphic values in Haskell
23:49:50 <adu> ski: like 3 :: Int is ok, but 3 is bad because its of type "a"
23:50:03 <adu> well, Num a => a
23:50:06 <glguy> adu: the MR says you need a type signature if you want that
23:50:31 <ski> adu : but that's because of the constraint in the type
23:52:57 <ski> adu : e.g. `empty = []' infers `empty :: [a]', not restricting `a' ..
23:53:05 <adu> actually, I think Data.Number.Symbolic is perfect
23:53:43 <adu> ski: hmm, then maybe I just don't understand MR
23:54:16 <quicksilver> in any case, the MR is optional, it's not deep.
23:54:27 <adu> heh ok
23:54:32 <quicksilver> it's just there because of some assumptions about sharing and CAFs
23:54:59 <quicksilver> you can write "n :: Num a => a; n = 3"
23:55:05 <quicksilver> if you want a polymorphic 'constant'
23:55:19 <quicksilver> (Explicit type signature over-rides MR)
23:57:01 <ski> the typical problem prompting DMR is that `foo = 3 + 4' would, without the restriction, infer `foo :: Num a => a', and in typical dictionary-passing implementations of constraints (assuming no compiling-away of it in this case), this would translate to something like `foo :: NumDict a -> a', so because this is a function, it would probably not cache the result of the expensive computation of `3 + 4', but reevaluate it each ti
23:58:19 <ski> (cut-off .. ".. but reevaluate it each time `foo' is used (possibly at different types)")
23:58:50 <adu> ski: ahh that makes sense
23:58:51 * ski fetches tea
