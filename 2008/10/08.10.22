00:21:01 <now> Hi!  What would be the best representation of 2700 entries of a C struct consisting of two byte fields and one integer field in Haskell?  My trivial solution was a list of tuples, but that doesn't seem to be very effective when compiled (it takes a lot of space).  Is there any way of making this simple solution more effective, or is there a better alternative?
00:22:18 <Axman6> now: maybe a bytestring? i hav no idea if that'd work though...
00:22:33 <Axman6> not sure if they're just for Strings
00:23:17 <vegai> Data.Word, perhaps?
00:23:27 <Axman6> sounds good to me too
00:23:55 <vegai> or Data.Int
00:24:04 <sjanssen> now: you could also use the FFI to store it just as you would in C
00:24:33 <jsn> now: if you have not tried a 'data' declaration with strictness annotations, you might...
00:25:02 <vegai> hmm, this is a bit silly: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Version.html
00:25:04 <lambdabot> Title: Data.Version, http://tinyurl.com/5k9vxc
00:25:48 <pumpkin_> lol
00:25:53 <now> jsn: How would I go about that?
00:26:44 <jsn> data Record = Record !Word8 !Word8 !Word32
00:27:39 <mc__> Does anyone know any paper about a functional approach to a 3d engine?
00:28:50 <earthy> mc__: there's a couple of raytracers written in Haskell
00:29:10 <now> jsn: is that better than (Word8, Word8, Word32)?
00:29:24 <jsn> now: the ! makes it strict
00:29:45 <jsn> strict means, no thunk, which is "better" for your purpose
00:29:50 <earthy> see e.g. http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics
00:29:52 <lambdabot> Title: Applications and libraries/Graphics - HaskellWiki, http://tinyurl.com/4hjxmb
00:30:23 <sjanssen> now: you should also compile with -funbox-strict-fields
00:31:42 <sjanssen> now: (Word8, Word8, Word32) will be three pointers to boxes containing words
00:32:17 <sjanssen> the strict, unpacked data version will have no pointers and no boxes
00:49:00 <HerrSchnapps> hi, so I get the following error: *** Expression: courseStudents x : collegeList xs *** Term: courseStudents x *** Type: [([Char],Char)] *** Does not match: ([Char],Char)
00:49:28 <HerrSchnapps> with the following recursive function: collegeList :: DB -> Students collegeList [] = [] collegeList (x:xs) = courseStudents x : collegeList xs
00:50:00 <Deewiant> looks like you maybe want ++ instead of : ?
00:50:24 <now> OK, thanks for the pointers, but I seem to be doing something very wrong.  It's gotten even bigger.  I have data Record = Record !Word8 !Word8 !Word32  and then 2700 Record 1 2 3 in a list.  Running ghc -funbox-strict-fields -C gives shows that they're still boxed.  Where am I going wrong now?
00:50:37 <HerrSchnapps> ahh, thankyou!
00:50:53 <HerrSchnapps> d'oh!
00:52:22 <jsn> now: maybe you need bang patterns?
00:53:06 <sjanssen> now: does -O help?
01:03:12 <rog> i'm trying to compile OOHaskell, and it imports HList modules directly (e.g. "import Record" rather than "import Data.HList.Record"). is there a way to make this work without going through changing all the imports? (Data.HList is a package module).
01:03:46 <rog> (i don't *think* that i can make ":set -i" do what i want)
01:07:11 <HerrSchnapps> so if I have a list like such: [("recipe"), [("cheese",5),("eggs",12)], 10], how would I be able to extract ("cheese",5),("eggs",12) out?
01:08:18 <rog> HerrSchnapps: you can't have such a list - all the elements aren't of the same type.
01:09:47 <pumpkin_> maybe he meant it to be a tuple?
01:09:56 <Saizan> rog: i'd rollback the HList repository to the point where it matches OOHaskell
01:10:29 <jeffz> HerrSchnapps: maybe you mean something like: [("omlette",[("cheese",5),("eggs",12)])]
01:10:37 <HerrSchnapps> oops, that should be [("recipe", [("cheese",5),("eggs",12)], 10)]
01:11:17 <jsn> HerrSchnapps: you could pattern match
01:11:28 <rog> HerrSchnapps: there are no predefined operations on tuples with > 2 members. you'll have to define them yourself, if you want them.
01:11:40 <badri> HerrSchnapps: may be you want (("recipe"), [("cheese",5),("eggs",12)],10) instead?
01:11:54 <dolio> , fst3 (1,2,3)
01:12:00 <lunabot>  luna: Not in scope: `fst3'
01:12:01 <badri> oh yeah
01:12:16 <jsn> badri: i think you meant to put the parens on the other side
01:12:43 <rog> i defined t1of3, t2of3, etc. but i haven't found myself using them much.
01:12:55 <badri> jsn: I wanted to suggest that HerrSchnapps use a tuple instead of a list. But I see that he did that already
01:13:07 <jsn> [("recipe", ([("cheese",5),("eggs",12)], 10))]
01:13:21 <badri> HerrSchnapps: Extract the first element of the list, which is the tuple using head
01:13:22 <jsn> two tuples in two tuples is pretty good, i think
01:13:29 * jauaor just realized himerge is in the top 10 of Haskell applications in freshmeat!
01:13:58 <badri> HerrSchnapps:  then define a fn to extract mid element
01:14:14 <badri> mid (_,x,_) = x
01:14:32 <dolio> @seen mmorrow
01:14:32 <lambdabot> I saw mmorrow leaving #ghc, #darcs and #haskell 1d 17h 10m 55s ago, and .
01:14:46 <HerrSchnapps> well its actually a list of indefinate size, so it could be [ ("omlette", [("cheese",5),("eggs",12)], 10), ("cake", [("flour",2),("eggs",3)],1) ... n]
01:15:00 <rog> Saizan: hmm. i don't know how to do that. (i just got the tgz and used cabal install). it'll probably be quicker to do a cross-file edit...
01:15:23 <badri> ok extract a tuple you want use !! and then use mid
01:15:30 <HerrSchnapps> okay, awesome
01:15:36 <jsn> HerrSchnapps: once you have two tuples in two tuples, then you just do this: 'snd . fst $ ("recipe", ([("cheese",5),("eggs",12)], 10))'
01:17:06 <rog> Saizan: (it's not obvious to me that there's even a repository to roll back...)
01:18:02 <rog> Saizan: (the hackage HList page doesn't mention it. or is everything on hackage in a version control system?)
01:20:00 <Saizan> @where hlist
01:20:01 <lambdabot> http://homepages.cwi.nl/~ralf/HList
01:20:56 <Saizan> rog: at the end of the page there's a darcs repository
01:21:36 <rog> ah, thanks
01:23:55 <rog> Saizan: PS. you're right - even when i did the edits, it won't allow me to import individual modules from the package. (it says they're hidden). (that seems odd, but there y'go)
01:30:13 <FrozenTomato> hi is there a way to "convert" [[1,2,3,4]] to [1,2,3,4]... i know convert isnt right word
01:30:24 <Deewiant> concat
01:30:40 <FrozenTomato> thanks!
01:30:43 <FrozenTomato> ive been looking forever
01:30:44 <Deewiant> no problem
01:30:45 <Deewiant> :-)
01:30:47 <FrozenTomato> jeez.. :)
01:30:50 <Deewiant> ?hoogle [[a]] -> [a]
01:30:50 <lambdabot> Prelude concat :: [[a]] -> [a]
01:30:50 <lambdabot> Data.List concat :: [[a]] -> [a]
01:30:50 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:31:24 <Deewiant> knowing the type of what you've got and what you've want, put it into hoogle and see what comes out
01:31:32 <Deewiant> s/you've want/you want/
01:31:45 <FrozenTomato> kk thanks
01:32:02 <FrozenTomato> ?hoogle [[a], [b]] -> [a]
01:32:02 <lambdabot> Parse error:
01:32:02 <lambdabot>   --count=20 "[[a], [b]] -> [a]"
01:32:02 <lambdabot>                  ^
01:32:11 <FrozenTomato> too much for hoogle? ;)
01:32:15 <Deewiant> not a valid type
01:32:21 <Deewiant> maybe you meant [([a],[b])]
01:32:37 <FrozenTomato> no i didnt unfortnately
01:32:51 <FrozenTomato> but concat is fine.. itll work :)
01:32:56 <Deewiant> well what did you mean, [[a], [b]] isn't a Haskell type :-P
01:33:19 <Deewiant> if you have a list of pairs it's [(a,b)], if you have a pair of lists it's ([a],[b])
01:33:33 <FrozenTomato> for example [[1,2,3], [4,5,6], [7,8,9]]
01:33:43 <Deewiant> :t [[1,2,3], [4,5,6], [7,8,9]]
01:33:44 <lambdabot> forall t. (Num t) => [[t]]
01:33:57 <Deewiant> [[Int]] for instance
01:34:17 <Deewiant> a list, containing lists, containing integers
01:34:24 <FrozenTomato> right
01:34:53 <FrozenTomato> so hoogle [[Int]] -> [a]?
01:34:59 <FrozenTomato> ?hoogle [[Int]] -> [a]
01:34:59 <lambdabot> Prelude concat :: [[a]] -> [a]
01:34:59 <lambdabot> Data.List concat :: [[a]] -> [a]
01:34:59 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:35:03 <Deewiant> yeah, for instance
01:35:08 <Deewiant> or [Int] in this case for the result type
01:35:16 <FrozenTomato> so hoogle [[Int]] -> [Int]?
01:35:19 <FrozenTomato> err
01:35:24 <FrozenTomato> ?hoogle [[Int]] -> [Int]
01:35:24 <lambdabot> Prelude concat :: [[a]] -> [a]
01:35:24 <lambdabot> Data.List concat :: [[a]] -> [a]
01:35:24 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:35:34 <Deewiant> it's clever enough ;-)
01:35:42 <badri> :)
01:35:54 <FrozenTomato> ok what if i have a list like above [[1,2,3], [4,5,6], [7,8,9]] and i want to 2nd element. how do i ask hoogle that ;)
01:36:07 <Deewiant> well, you have as one input [[Int]]
01:36:12 <Deewiant> and as a second input Int (the 2)
01:36:16 <Deewiant> and your output is [Int]
01:36:27 <Deewiant> ?hoogle [[Int]] -> Int -> [Int]
01:36:27 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
01:36:27 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
01:36:27 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
01:36:30 <Deewiant> darn
01:36:42 <Deewiant> not in the top three, at least :-P
01:36:51 <opqdonut> ?hoogle [a] -> Int -> a
01:36:52 <lambdabot> Prelude (!!) :: [a] -> Int -> a
01:36:52 <lambdabot> Data.List (!!) :: [a] -> Int -> a
01:36:52 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
01:36:54 <opqdonut> :)
01:36:59 <opqdonut> (yeah yeah I know)
01:37:07 <FrozenTomato> hm
01:37:16 <jsn> now: any luck?
01:37:34 <Deewiant> FrozenTomato: generalizing the type, if you think it can be generalized, can help, as witnessed above. :-)
01:51:19 <now> jsn: no
01:51:31 <now> Here's my code: http://hpaste.org/11383
01:52:01 <now> Um, damn, it was cut
01:53:47 <now> Here's a truncated version: http://hpaste.org/11384
01:54:12 <now> It still compiles them boxed
01:54:57 <now> Even with ghc -funbox-strict-fields -O digraph.hs
01:55:59 <quicksilver> what is your evidence that they are boxed, now?
01:56:56 <jsn> now: you inspect the resulting C, is that right?
01:58:55 <now> jsn: yes, it's more or less all StgWord Main_a2_closure[] = {... };
01:59:28 <quicksilver> now: inspecting the C does not sound sane to me.
01:59:34 <quicksilver> the C backend is deprecated.
01:59:44 <quicksilver> you should be inspecting the core
01:59:50 <quicksilver> or, if you're really hardcore, the assembly.
02:00:01 <now> How do I do that?
02:00:32 <now> (And the fact resulting a.out is 970 kb while the a.out for the equivalent C program is 26 kb is quite telling)
02:01:13 <now> (I'm running ghc 6.8.2, by the way)
02:01:22 <jsn> ghc -fext-core -fglasgow-exts -funbox-strict-fields -O
02:01:40 <jsn> now: the binary has the runtime system in it
02:02:13 <quicksilver> -ddump-simpl, probably
02:02:16 <quicksilver> list of fields at
02:02:17 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-debugging.html
02:02:18 <lambdabot> Title: 5.16.�Debugging the compiler, http://tinyurl.com/t96uq
02:02:31 <quicksilver> there is also the package 'ghc-core' on hackage
02:02:42 <quicksilver> which is supposed to help make it easier to read.
02:03:06 <jsn> now: i don't know how how small that can get, but certainly not as small as an array and a handful of operations in C
02:03:08 <Deewiant> now: the C program doesn't come with an RTS containing a GC and a thread pool and various other things.
02:03:35 <Saizan> putStrLn "hello world" takes ~500k here
02:03:43 <Deewiant> stripped?
02:03:47 * jsn YA RLY
02:04:18 <Saizan> ~300k stripped
02:05:02 <quicksilver> most people don't think it's very interesting to waste time trying to make haskell executables small.
02:05:08 <quicksilver> it is possible, if you are interested.
02:05:21 <quicksilver> you need to tweak various flags to get one-object-file-per-function
02:05:24 <quicksilver> do smart linking and stripping.
02:05:29 <Deewiant> split-objs
02:05:42 * quicksilver nods
02:05:55 <Deewiant> the main reason why building gtk2hs takes around 8 hours here :-P
02:06:34 <Feuerbach> What corresponds to (void *) in FFI?
02:06:44 <Deewiant> Ptr (), I think
02:11:48 <HerrSchnapps> how would I find the average value of each list, within a list? eg: [ [2,2,2], [1,5,9,2], [13,2,4] ] = [ 2, 4.25, 16.333]
02:12:13 <now> jsn: Yeah, but that's only 500 kb, right?
02:12:21 <now> (ah, Saizan already mentioned that)
02:13:20 <Feuerbach> HerrSchnapps: write function for average, then use map
02:13:32 <Saizan> HerrSchnapps: you've two problems there 1) find the average value of a list 2) apply a function to each element of a list
02:14:36 <HerrSchnapps> so I'll tackle 1 first, so can I do something like easy like "sum list, divide by length of list"?
02:14:48 <Saizan> yup
02:14:56 <Saizan> ?type sum
02:14:57 <lambdabot> forall a. (Num a) => [a] -> a
02:15:04 <Saizan> ?type div
02:15:05 <lambdabot> forall a. (Integral a) => a -> a -> a
02:16:16 <jsn> now: i'm not really sure what to try next
02:16:52 <jsn> now: i had this problem with a big chinese dictionary, a few months, ago, and i just went ahead and made a C array and imported it
02:17:26 <jsn> now: which was, granted, a little more to do than use a few compiler options
02:18:21 <hugo__> good morning everyone
02:22:59 <jsn> > map (\ list -> (sum list) / (fromIntegral length list) ) [ [2,2,2], [1,5,9,2], [13,2,4] ]
02:23:00 <lambdabot>       No instances for (Num ([a] -> a), Integral ([a1] -> Int))
02:23:00 <lambdabot>        arisin...
02:23:23 <jsn> map (\ list -> (sum list) / (fromIntegral $ length list) ) [ [2,2,2], [1,5,9,2], [13,2,4] ]
02:23:39 <jsn> > map (\ list -> (sum list) / (fromIntegral $ length list) ) [ [2,2,2], [1,5,9,2], [13,2,4] ]
02:23:41 <lambdabot>   [2.0,4.25,6.333333333333333]
02:28:05 <HerrSchnapps> why won't it accept a list from another function?
02:28:18 <HerrSchnapps> map (\ list -> (sum list) / (fromIntegral $ length list) ) studGrades
02:29:03 <HerrSchnapps> instead it says it cannot infer infer instance
02:29:13 <now> jsn (and everyone else): OK, thanks for your help.
02:33:08 <Axman6> holzplatten: what form is the list in?
02:33:11 <Axman6> urgh
02:33:20 <Axman6> sorry holzplatten, HerrSchnapps left
02:37:23 <quicksilver> news at 11 : student joins channel via mibbit hoping for homework answers on a plate, doesn't get them, leaves.
02:37:27 <quicksilver> :P
02:43:00 <jsn> quicksilver: maybe i need to be more wary of that
02:47:26 <rog> still fooling around with HList. why does this code give an error: http://hpaste.org/11385#a0
02:48:05 <rog> (the OOHaskell sources, which i still haven't got to work (but it's a distraction) make it seem like this *should* work)
02:50:57 <rog> it's all a bit frustrating. does anyone know of some other, preferably not too complex, code that uses HList and labelled records (and which works with the current version of HList)?
02:53:47 <quicksilver> rog: Nobody uses HList ;)
02:53:58 <quicksilver> that's not really true, but it is true of my personal experience.
02:54:05 <quicksilver> it's seldom discussed here, for example.
02:54:23 <quicksilver> rog: A well-crafted email to the -cafe with HList in the title is likely to attract a response from oleg.
02:54:53 <matthew-_> negation is associative right? ¬(A^B) == ¬A ^ ¬B yes?
02:55:12 <ToRA|MSR> u mean distributive?
02:55:21 <matthew-_> that too ;)
02:55:28 <matthew-_> and I think I'm wrong too
02:55:37 <ToRA|MSR> what's ^? xor or and or or or ..?
02:55:44 <Saizan> rog: you've to import Label4 and TypeEqGeneric1 for that to work
02:55:51 <matthew-_> ToRA|MSR: normally, it's and
02:55:59 <matthew-_> it's never or, but it's sometimes xor
02:56:02 <matthew-_> or power ;)
02:56:08 <ToRA|MSR> ;)
02:56:11 <rog> Saizan: ... but i can't do that because they're hidden inside the HList package...
02:56:12 <Saizan> ¬(A^B) == ¬A V ¬B
02:56:19 <matthew-_> duh, of course, De Morgans
02:56:20 <matthew-_> sorry
02:56:27 <matthew-_> brain failure. It's still morning here
02:57:16 <Saizan> rog: i'm quite skeptic about that cabalization of HList
02:58:37 <augustss_> Saizan: indeed.  HList is not really in a user friendly state
02:58:47 <rog> Saizan: i'm not surprised. it seems to make the whole thing fairly unusable.
02:59:31 <matthew-_> It seems to me to be more a technique than a library
02:59:32 <rog> Saizan: i think i should probably just copy the directory rather than use the cabal version. maybe that'll work.
02:59:51 <matthew-_> as in most cases one's individual use cases will normally demand bits of it get rewritten
03:00:22 <rog> matthew-_: i actually haven't found that. and the operators it defines would be tedious to redefine.
03:00:42 <Saizan> matthew-_: it looks quite flexible as it is, if the right modules are exposed
03:00:46 <rog> matthew-_: i just wish there was a relatively small, documented API.
03:01:17 <rog> matthew-_: 'cos currently it exports hundreds of names. (and still not the ones which are necessary, it seems)
03:05:36 <rog> Saizan: i've just tried it with Label4 and TypeEqGeneric1 imported (and not loading from the package) and i still get an error: No instance for (TypeCast HFalse HFalse)
03:19:34 <Saizan> rog: see TypeCastGeneric1/2, i thought that was already imported somewhere
03:20:59 <dancor> @hoogle (Monad m, Monad n) => (a -> b -> m (n a)) -> a -> [b] -> m (n a)
03:20:59 <lambdabot> No results found
03:23:38 <rog> Saizan: well... that compiled. but the moment i try to use it (e.g. rec1 .!. foo) i get "Overlapping instances for TypeEq Foo Foo HTrue".
03:24:09 <rog> and it was all going so well!
03:24:18 <rog> (yesterday)
03:31:27 <quicksilver> rog: I think OverlappingInstances is asboutely required for HList
03:31:44 <solrize> so is haskell really statically typed?  are existentially typed values really resolved at compile time?  i tried the mixed list example and got a compile error, but may have not done it right
03:32:07 <quicksilver> (1) Yes, haskell is really statically typed
03:32:12 <quicksilver> (2) Depends what you mean by 'resolved'
03:32:30 <quicksilver> an existential box really is a box which doesn't know what type it is.
03:32:40 <Saizan> rog: right, i've tried it now and you need OverlappingInstances in the TypeEqGeneric1 module
03:32:42 <quicksilver> (but then no types exist at run time anyway)
03:32:50 <solrize> resolved means that in principle the compiler can specialize every function to operate completely on ground types.  i.e. no boxes.  in practice implementations use boxes to avoid exponential code bloat but not for any other reason
03:33:06 <quicksilver> solrize: in that case the answer is no.
03:33:14 <quicksilver> GHC does separate compilation.
03:33:20 <solrize> hmm
03:33:24 <quicksilver> it makes no attempt to resolve existential types as far as I know.
03:33:31 <quicksilver> they are boxed and type-erased.
03:33:39 <mokus> nor can it without breaking separate copilation
03:34:21 <quicksilver> solrize: consider that "tail :: [a] -> [a]", being truly polymorphic, effectively takes an existential input.
03:34:22 <solrize> well, one could imagine a linking phase that did more specialization and type erasure
03:34:39 <quicksilver> universals occurring in negative positions are existential
03:34:42 <quicksilver> (in some sense, at least)
03:34:58 <solrize> yes, but in everyday usage, all calls to tail can be specialized
03:35:00 <quicksilver> and GHC doesn't specialise the code for tail.
03:35:02 <quicksilver> no they won't.
03:35:06 <quicksilver> there is no reason to do so.
03:35:11 <quicksilver> GHC's list representation is uniform
03:35:15 <quicksilver> so specialisation has no benefit.
03:35:22 <solrize> well by CAN be specialized i don't mean they ARE specialized ;)
03:35:50 <solrize> i just mean that the user code has enough info to specialize each call if it were for some reason desirable
03:35:52 <lilac> doesn't nhc do full speicalization etc?
03:36:11 <quicksilver> in the absense of higher rank types or existentials, that's true.
03:36:25 <quicksilver> and of course GHC is capable of doing specialisation across module boundaries
03:36:32 <quicksilver> but that requires it to fill the ".hi" files with crap
03:36:42 <quicksilver> and separate compilation starts to be somethign of an illusion at that point :)
03:36:47 <quicksilver> or, at least, a continuum.
03:37:15 <solrize> what about jhc?
03:37:37 <quicksilver> jhc doesn't have separate compilation at all, IIRC
03:37:46 <quicksilver> so it has the flexibility to specialise everything
03:37:49 <quicksilver> I don't know if it does.
03:38:39 <solrize> http://hpaste.org/11386
03:39:05 <solrize> see if i actually try mixing types in that list it won't compile
03:41:04 <solrize> data E = forall a. (Show a) => E a
03:41:13 <solrize> or when i write the data statement that way, i get no output, hmm
03:42:08 <quicksilver> your "get" won't typecheck.
03:42:52 <solrize> http://hpaste.org/11386#a1   in this version i don't get a compile error but there's no output
03:44:00 <solrize> hm i get an error from "ghc" but not from "runhaskell"
03:44:06 <quicksilver> it shouldn't compile
03:44:13 <quicksilver> it's broken code.
03:44:20 <mokus> right
03:44:25 <mokus> the existential type escapes
03:44:29 <quicksilver> as I said, "get" won't type check.
03:44:55 <quicksilver> mapM_ (putStrLn . showE) xs where showE (E x) = show x
03:44:59 <quicksilver> ^^ that's what you want.
03:45:20 <quicksilver> (you can, indeed, say instance Show E where show=ShowE, which is quite a common idiom)
03:45:46 <solrize> interesting
03:46:39 <jsn> mokus: how does the existential "escape" in solrize's example?
03:47:02 <mokus> what's the type of get?
03:47:13 <quicksilver> get appears to have type "E -> a"
03:47:13 <solrize> get :: E -> a
03:47:19 <quicksilver> where 'a' was the type 'stuck inside'
03:47:22 <quicksilver> but htat's not possible
03:47:27 <quicksilver> it doesn't mean anything :)
03:47:38 <solrize> right
03:47:40 <quicksilver> after all, no fixed type was stuck inside.
03:47:45 <mokus> get :: exists a. Show a => E -> a
03:48:26 <mokus> so, although the existential does'nt actually escap e the program, it escapes get, which isn't allowed
03:48:50 <quicksilver> one way to say this is "everything must have a valid type"
03:48:50 <solrize> E -> a certainly seems like an invalid type
03:49:04 <quicksilver> and, of course, exists isn't a valid type :)
03:49:04 <mokus> it isn't in itself
03:49:14 <jsn> aha!
03:49:19 <quicksilver> "E -> a" is technically shorthand for "forall a . E -> a"
03:49:24 <quicksilver> which is not what we have here
03:49:34 <quicksilver> so "E -> a" is technically valid, but not what we get.
03:49:42 <mokus> constundefined can be :: E -> a ;-)
03:50:56 * mokus for one wishes exists a. ... were a valid type
03:51:05 <mokus> at least with some set of extensions on
03:51:33 <mokus> even if I had to annotate it every time
03:51:58 <solrize> is "exists a." valid syntax in haskell?  how can it know?
03:52:11 <mokus> no, it isn't
03:54:23 <mokus> it sure would be nice sometimes though
03:54:31 <quicksilver> you need the explicit constructor
03:54:44 <quicksilver> there needs be a syntactical "point" in the code where the wrapping/unwrapping happens
03:55:10 <mokus> I disagree
03:56:32 <mokus> or rather, I don't agree with the assertion that that precludes the possibility that you can manipulate types for which that has already happened outside your scope
03:56:56 <Baughn> Fascinating. I have a function getList :: Binary a => Integer -> Get [a]; if I curry the with something like "let gl = getList len", then the specific type of a is fixed at that point?
03:57:17 <mokus> no, it's still a forall type
03:57:19 <Baughn> I'm sure I did that in the past without something like that happening..
03:57:43 <mokus> the a will still be resolved to whatever type it unifies with
03:58:01 <Baughn> But it can't unify with more than one, apparently.
03:58:06 <mokus> right
03:58:14 <mokus> but you get the choice of what to unify with
03:58:19 <lilac> "get :: E -> (exists a. Show a => a)" seems plausible (though obviously not legal)
03:58:23 <mokus> if it were existential you woundn't
03:58:41 <mokus> it would be providing some 'Binary a => a' of its own choice
03:59:00 <mokus> and you would have to be prepared for any of them
04:00:27 <Baughn> Further down, I've got DNSServers <$> gl, which fixes it to Get [Word8]
04:00:51 <Baughn> *Get [Word32], rather
04:00:53 <mokus> given (x :: exists a. Foo a => a) and (f x :: b), you have (f :: (forall a. Foo a => a) -> b)
04:00:59 <Baughn> Then I try for ParameterRequestList <$> gl, which wants a Get [Word8]
04:01:32 <mokus> or (f :: forall a. Foo a => a -> b)
04:01:34 <Baughn> That fails rather hard, unfortunately. Shouldn't I be able to define local functions with parametric polymorphism?
04:01:57 <dancor> what is the right way to do foldMM :: (Monad m, Monad n) => (a -> b -> m (n a)) -> a -> [b] -> m (n a)
04:01:59 <mokus> are you runnning into the monomorphism restriction in your local bindings?
04:02:07 <mokus> does it apply there?  I forget
04:02:11 <Baughn> Not to my knowledge
04:02:19 <Baughn> GHCi is supposed to tell me, I think..
04:02:38 <Baughn> ...
04:02:41 <dancor> m = IO, n = Either String for me here
04:02:42 <Baughn> Actually. Yes. Yes, I was.
04:02:54 <Baughn> mokus: Heh. Thanks for the hint.
04:03:21 <mokus> no problem, glad it helped
04:03:30 <Baughn> That's the second time it's annoyed me
04:03:36 <mokus> just sounded vaguely familiar ;-)
04:03:50 <Baughn> But I was *sure* ghci used to /tell/ me when that happened..
04:04:00 <mokus> it may have changed the way it tells you
04:04:10 <Baughn> You mean, to not telling me?
04:04:12 <dancor> :t lift foldM
04:04:13 <lambdabot> forall a b (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => t ((->) (a -> b -> m a)) (a -> [b] -> m a)
04:04:14 <mokus> also, it can't always tell you if typeclasses are involed
04:04:23 <mokus> it can lead to impossible contexts
04:04:36 <Baughn> So what was the downside of turning the restriction off, again?
04:04:38 <mokus> that don't become a problem till you try to actually use something
04:04:57 <mokus> I think it makes you type more type annotations in some cases
04:05:24 <mokus> and leads to the impossible contexts I was just spouting on about
04:05:31 <Baughn> A sharing thing in this case, too
04:05:39 <mokus> ah, yea
04:05:49 <Baughn> It'll have to evaluate getList len twice.. but that's just currying anyway
04:05:56 * dancor had thought the monomorphism restriction was just a warning about things not being memoized the way you might expect
04:06:05 <Baughn> (Well. Maybe. I *assume* Get is a function under the covers.)
04:06:16 <Baughn> dancor: No, not /just/ that, but it's a part
04:06:28 <idnar> what does memoization have to do with the monomorphism restriction?
04:06:32 <Baughn> Well, I can't say I care much about performance for a dhcp relay
04:06:38 <quicksilver> sharing is the 'official' reason.
04:06:57 <mokus> I'm just glad I can turn it off
04:07:01 <quicksilver> although "just turning it off" will have strange effects if you rely heavily on defaulting.
04:07:16 <quicksilver> because things which defaulted before will suddenly become properly polymorphic.
04:07:36 <quicksilver> only really an issue with code with lots of numeric literals.
04:07:42 <mokus> it's nice when I'm not sure what heinously large type I need to annotate it to be able to go to ghci and infer all my types for parameterless bindings
04:07:43 <jsn> wow, i'm having deja vu
04:07:55 <Baughn> Just so long as I don't need to type "glToWord8"...
04:08:06 <jsn> triggered by "what does memoization have to do with the monomorphism restriction?"
04:08:09 <Baughn> I don't care if the compiler does so under the covers. That's what it's for.
04:08:23 <quicksilver> idnar: to the extent that sharing is a kind of simple case of memoization
04:08:29 <quicksilver> idnar: the answer is "everything"
04:08:48 <idnar> quicksilver: oh, right, I see
04:09:46 <mokus> of course, if a polymorphic binding is used 2x at the same type, those usages can be factored by the compiler into a new monomorphic subexpression
04:09:51 <mokus> and regain sharing
04:10:07 <quicksilver> "could be"
04:10:11 <mokus> yep
04:10:16 <quicksilver> I doubt they are. GHC does very little CSE.
04:10:28 <quicksilver> although this special case seems like a good candidate.
04:10:32 <mokus> but "could be" is more or less what the debate is about, I think
04:11:00 <quicksilver> we like to pretend we're only interested in the semantics of our program, which is why the haskell spec doesn't define much operational.
04:11:09 <mokus> heh
04:11:18 <quicksilver> but then we're forced to concede that controlling sharing is (sometimes) incredibly important.
04:11:35 <quicksilver> getting it wrong - too little or too much - can shift you into a different space O() class
04:11:42 <quicksilver> which is 'catastrophic'
04:12:14 <dancor> i guess i want to use MonadIO (Either String) somehow
04:15:30 <Saizan> MonadIO (ErrorT String IO) might be more realistic
04:20:25 <tegguN> hey guys I need some pretty basic help
04:20:38 <pjdelport> tegguN: just ask
04:21:21 <tegguN> okay so this works fine for removing/filtering text discardPunct :: String -> String
04:21:22 <tegguN> discardPunct thaString = [toLower d | d <- thaString, isAlpha d]
04:21:49 <tegguN> however I want to leave hyphens in
04:22:08 <tegguN> so I tried this
04:22:09 <tegguN> discardPunct :: String -> String
04:22:09 <tegguN> discardPunct theString = [toLower d | d <- theString, removePunct d]
04:22:09 <tegguN> removePunct :: String -> Bool
04:22:09 <tegguN> removePunct e = e == "-" || isAlpha e
04:22:32 <quicksilver> tegguN: "d" is a single Char rather than a String
04:22:53 <quicksilver> tegguN: so you want removePunct :: Char -> Bool
04:23:03 <quicksilver> and you want to use '-' instead of "-"
04:23:14 <quicksilver> "-" is a one character string, while '-' is a Char
04:23:45 <tegguN> ahh that makes sense, I couldn't work out why the first one worked but the second one didn't
04:23:49 <tegguN> thanks so much! :D
04:23:53 <dancor> removePunct should be called like shouldKeepChar
04:24:16 <tegguN> ah yes, I haven't thought the names through yet
04:24:22 <jsn> keepThaChar
04:24:37 <dancor> charIsSweet
04:24:41 <tegguN> any other tips on neatness etc.? And is this the correct way to do this sort of operation
04:24:43 <osfameron> dontKeepThatcher
04:25:08 <pjdelport> tegguN: filter?
04:25:31 <jsn> charIsTheSchnizel
04:25:33 <tegguN> yes
04:25:58 <jsn> kharIstDasSchnitzel
04:26:29 <quicksilver> tegguN: it's fine, but you want to understand how to do it with maps and filters too
04:26:40 <quicksilver> tegguN: because for some cases that's easier to work out.
04:26:52 <dancor> > let lowerNoPunct = map toLower . filter (\ x -> isAlpha x || x == '-') in lowerNoPunct "d0l-AEIb."
04:26:53 <lambdabot>   "dl-aeib"
04:27:00 <pjdelport> K, is for KeepChar
04:27:08 <quicksilver> [f d | d <- l, p d] is the same as map f . filter p $ l
04:27:24 <quicksilver> I do like list comprehension syntax myself.
04:27:45 <tegguN> ah thanks, I'm only 3 weeks into my course so I haven't studied those yet, I'll bare that in mind though
04:28:05 * quicksilver nods
04:28:07 <TomMD> Where is your course?
04:28:22 <tegguN> *bear
04:28:31 <tegguN> City University
04:28:48 <tegguN> (London)
04:28:53 <quicksilver> nice.
04:28:58 <quicksilver> I didn't know city were doing haskell.
04:29:19 <tegguN> 2nd year Functional Programming Module
04:30:44 <hugo__> :)
04:31:10 <hugo__> in portugal there are two universities teaching haskell in begining and advanced programming classes
04:31:57 <jsn> i wonder if there are any american universities using haskell?
04:32:10 <jsn> in undergraduate courses, i mean?
04:32:10 <earthy> there are
04:36:08 <tegguN> what do you guys think of City?
04:37:43 <Axman6> City?
04:37:59 <tegguN> University
04:38:13 <Axman6> jsn: i know ANU does... it's where i learnt about haskell, and fell in love :)
04:38:18 <quicksilver> I'm afraid I don't really have an opinion on it.
04:38:23 <Axman6> but, its not american
04:38:32 <quicksilver> never had much contact with it.
04:38:37 <quicksilver> but I've pleased to hear it does haskell :)
04:39:09 <BeelsebobWork> I thought america land was also known as land of the schemers :P
04:39:25 <SamB_XP> what be this "america land"?
04:39:30 <jsn> ANU is ... ?
04:39:37 <BeelsebobWork> australian
04:39:58 <jsn> BeelsebobWork: america is full of schemers...
04:40:29 <SamB_XP> unfortunately most of them are corporate
04:40:39 <mokus> schemers and brainf*ckers
04:40:45 <Associat0r> http://www.perfectduluthday.com/2008/01/fonzie_scheme.html
04:40:46 <lambdabot> Title: Perfect Duluth Day: Fonzie Scheme.
04:40:47 <mokus> I know cause I live there ;-)
04:40:56 <jsn> SamB_XP: why is that unfortunate?
04:41:04 <SamB_XP> jsn: it's a pun
04:41:52 <jsn> SamB_XP: ah
04:42:11 <jsn> i've got a great startup idea
04:42:35 <jsn> once the economy gets a little better, it'll be time to create a new financial crisis!
04:42:50 <jsn> i'm not sure how to do it yet, but...
04:42:53 <earthy> http://www.cs.caltech.edu/courses/cs11/overview.html
04:42:54 <lambdabot> Title: Computer Language Shop (CS11)
04:44:04 <jsn> earthy: that is not quite the same thing as "we will be using the purely functional language Haskell -- mu hu ha ha ha ha -- for this course..."
04:44:28 <earthy> no, true.
04:44:50 <SamB_XP> mwahahaha?
04:45:21 <jsn> SamB_XP: that's the higher, faster version
04:45:31 <vixey> μ-haha
04:45:44 <SamB_XP> isn't that the evil laugh?
04:46:05 <earthy> http://web.engr.oregonstate.edu/~erwig/cs381/
04:46:08 <lambdabot> Title: CS 381: Programming Languages
04:46:15 <jsn> SamB_XP: there's more than one, i thought
04:46:36 <SamB_XP> well, I mean, aren't BOTH of those evil ones ?
04:47:14 <jsn> earthy: i wonder how many universities -- anywhere -- teach courses like "datastructures" or "distributed programming" with haskell?
04:47:15 <earthy> http://www.willamette.edu/~fruehr/254/
04:47:19 <lambdabot> Title: Introduction to Functional Programming
04:47:23 <earthy> jsn: a couple
04:47:40 <earthy> at the very least
04:50:04 <tegguN> we're doing Data Structures & Algorithms with Java at the same time as this Functional Programming (Haskell) module, so they kind of cross over in that way
04:50:37 <Axman6> i don't want to have to do any more java :(
04:51:47 <al-maisan> http://linux-foundation.org/weblogs/press/2008/10/21/linux-foundation-publishes-study-estimating-the-value-of-linux/
04:51:59 <lambdabot> Title: Linux Foundation Press Releases » Blog Archive » Linux Foundation Publishes St ..., http://tinyurl.com/6l6nxl
04:52:44 <dancor> is Control.Monad.Maybe in hackage anywhere
04:53:13 <EvilTerran> al-maisan, i find it suspect that they keep talking about lines of code
04:53:27 <al-maisan> yeah
04:53:34 <EvilTerran> also that it's their own report
04:54:23 <dancor> so meta
04:54:35 <EvilTerran> dancor, i think it is
04:55:26 <al-maisan> I guess it's not easy to estimate something like this
04:55:36 <al-maisan> I am amazed they are even trying
04:55:55 <jsn> to be fair, they are providing just as sound an analysis as any other vendor would provide
04:56:48 <SamB_XP> how about ... one meelion dollars?
04:56:58 <jsn> mwahahahaha
04:57:33 * jsn estimates the value of his sharks with laser beams
04:57:33 <SamB_XP> I haven't even seen any of those movies...
04:58:54 <rog_> Saizan: i found your reply in the logs. OverlappingInstances seems to have done the trick, thanks.
04:58:57 <Baughn> Are you using laser beams to measure the sharks? Or are the sharks with lasers?
05:00:12 <SamB_XP> Baughn: oh, I thought he was in fact slicing them to bits instead of estimating their value ;-)
05:01:27 <Baughn> SamB_XP: Actually, I think they're probably SHARKS with LASERS. Taped to their foreheads, that is.
05:02:27 <gal_bolle> is it possible to link to an instance declaration in hoogle?
05:02:36 <gal_bolle> haddock, not hoogle
05:02:37 <gal_bolle> sorry
05:03:28 <jsn> they are "sharks with frickin' laser beams attached to their heads!"
05:03:50 <SamB_XP> jsn: how is that different from what Baughn said ?
05:04:35 <jsn> SamB_XP: it provides the appropriate search term to recover the culture reference from the internets
05:08:54 <EvilTerran> jsn, i thought they were sea bass
05:09:22 <jsn> EvilTerran: my henchmen deliver
05:10:01 <EvilTerran> that must be handy. mine are collection-only.
05:11:13 <SamB_XP> I don't even have henchmen :-(
05:14:08 <Axman6> hmm, i wonder how long this ghc compile is going to take on this 500MHz celeron
05:14:49 <SamB_XP> Axman6: what pentium is it the celeron of ?
05:15:10 <Axman6> eh?
05:15:19 <vixey> man..... people on wikibooks suck
05:15:33 <Axman6> weren't celerons cpus? maybe i have mislead myself...
05:15:36 <vixey> reverting a bunch of changes instead of improving the bits you don't like is not really progress
05:15:42 <SamB_XP> you know all celerons are stripped down versions of pentiums, don't you?
05:16:11 <Axman6> SamB_XP: i didn't, and i don't really care either :P
05:16:35 <quicksilver> a celeron is a pentium with an old womand strapped to the top shouting at it "slow down! slow down! there's no need to drive so fast!"
05:16:37 <Axman6> PPC was always more interesting to me, until Apple went to intel ;)
05:16:39 <SamB_XP> well, at least now you should be able to understand my question
05:17:30 <Cozminsky> samb_xp: I like that analogy ;)
05:17:57 <SamB_XP> Cozminsky: I didn't give an analogy -- perhaps you meant to say that to quicksilver ?
05:18:26 <Cozminsky> samb_xp: ah, you're right, maybe I should increase the font size ;)
05:35:44 <pgavin> @seen igloo
05:35:44 <lambdabot> igloo is in #darcs, #ghc and #haskell. I last heard igloo speak 3h 22m 9s ago.
05:36:26 <EvilTerran> ... how do you do haskell in codepad?
05:37:21 <vixey> choose haskell in the Language section
05:37:25 <RayNbow> twanvl: under what license can people use your generic merge function?
05:38:18 <twanvl> RayNbow: never thought of that, you can consider it SimplePermisive or BSD licensed
05:38:42 <EvilTerran> vixey, i got that, but it took a few tries to work out that it was expecting a module, not an expression
05:38:45 <RayNbow> ok :)
05:39:28 <RayNbow> I'm just going to use your function to solve a simple puzzle, but I'll include a link to your blog post in the source :)
05:40:17 <twanvl> cool
05:43:32 <RayNbow> as \\ bs = mergeByR compare (const (const id)) (:) (const id) [] as bs   -- for sorted as and bs :)
05:44:15 <EvilTerran> ?unpl  const (const id)
05:44:16 <lambdabot> (\ _ _ c -> c)
05:44:30 <EvilTerran> is probably clearer :P
05:44:56 <EvilTerran> ?pl (\ _ _ c -> c)
05:44:56 <lambdabot> const (const id)
05:45:05 <quicksilver> I'm quite a big fan of lambda notation.
05:45:15 <vixey> :t const (const id)
05:45:15 <quicksilver> I think it's a nice concise way to specify simple functions :)
05:45:16 <lambdabot> forall a b b1. b1 -> b -> a -> a
05:45:46 <EvilTerran> ?type const . flip const -- being silly
05:45:46 <RayNbow> EvilTerran: I started with (\a b c -> c) and made it pointfree (manually) :p
05:45:47 <lambdabot> forall b a a1. a1 -> b -> a -> a
05:45:47 <TomMD> What?  lambdabot doesn't know the alphabet beyond 'b'?
05:46:00 <EvilTerran> TomMD, it uses the type variable names given in the source
05:46:07 <EvilTerran> appending numbers when they collide
05:46:12 <TomMD> Ahh.
05:46:18 <quicksilver> and const is delcared as "a -> b"
05:46:44 <TomMD> I'll submit a patch making the type "alphragalistic - > beerbelly"
05:47:14 <EvilTerran> i personally feel it'd make nicer sigs if it worked its way up the alphabet in case of collisions, but oh well
05:47:54 <EvilTerran> as in, instead of "a1 -> b -> a -> a", it'd go to "b1 -> b2 -> a -> a", and then increment either b1 or b2
05:48:18 <EvilTerran> probably b2; minimise the sum-of-squares for the moves :P
05:49:38 <RayNbow> lambdabot should use α, etc. :p
05:49:46 <EvilTerran> that too
05:49:59 <RayNbow> hmm, that alpha looks odd in my font
05:50:41 <dmwit_> I find Greek a bit unreadable.
05:54:12 <vixey> 4 alphabets is hardly enough
05:55:25 * ilyak have written a haskell program with greek variable names
05:55:30 <ilyak> it's pretty cool actually
05:55:53 * vixey also
05:56:01 <vixey> and wiggly arrows
05:56:11 <oklopol> haskell allows that?
05:56:26 <vixey> it's annoying you can't actually define which symbols are lower and uppercase though
05:56:27 <ilyak> oklopol: sure
05:56:39 <ilyak> vixey: well, it works fine for greek
05:56:39 <oklopol> awesome
05:56:50 <ilyak> and there are a lot of symbols in unicode
05:57:02 <ilyak> like, pacific sign, make an operator from it
05:57:05 <vixey> it doesn't
05:57:05 <oklopol> and unicode prolly defines what are symbols or not, and what are upper- and what lowercase?
05:57:15 <ilyak> vixey: Well, it did when I tried
05:57:19 <janimo> hi, what how to input end of file from stdin? Ctrl-D does not work it seem (Ubuntu)
05:57:23 <ilyak> oklopol: Well, it does
05:57:23 <vixey> sometimes I want to use <some symbol> as a constructor name but I can't
05:57:32 <vixey> for example, Gamma can't be a variable name
05:57:33 <oklopol> does haskell know these definitions?
05:57:44 <ilyak> vixey: small gamma can
05:57:51 <ilyak> vixey: big gamma can't
05:58:01 <Axman6> π = 3.141592... handeh
05:58:04 <dmwit_> janimo: WFM.
05:58:08 <vixey> ilyak: not sure you are getting my point
05:58:08 <quicksilver> oklopol: unicode has some standard classes
05:58:10 <dmwit_> janimo: What's your buffering look like?
05:58:30 <ilyak> vixey: I think I do, you want to define that
05:58:34 <quicksilver> oklopol: GHC uses those for some approximation of what 'upper case' means.
05:58:39 <quicksilver> (etc)
05:58:39 <ilyak> But I kinda like haskells' restrictions on names
05:58:52 <Asztal> I want to define different types of white space as operators
05:59:00 <janimo> dmwit_: just plain getContents and piping into it on the cmdline
05:59:05 <ilyak> Asztal: That would be hell
05:59:12 <ilyak> But I doubt it's possible, try it
05:59:49 <dmwit_> janimo: I've seen it behave strangely in ghci.  Try compiling it and running it to see if it behaves more like you expect.
05:59:52 <Axman6> Asztal: make the language " ", which is entirely whitespace based
06:00:06 <Asztal> there's already one :(
06:00:08 <dmwit_> janimo: If that fixes it, it is likely due to the buffering that ghci sets.
06:00:11 <Axman6> naww
06:00:27 <lilac> > (isUpper '\x0393', isUpper '\x03b3')
06:00:29 <lambdabot>   (True,False)
06:01:34 <janimo> dmwit_: no, building with ghc and no extra option results in the same
06:01:43 <janimo> dmwit_: only ctrl-c fixes it
06:01:50 <janimo> closes it I mean
06:02:39 <quicksilver> janimo: does cat file | prog behave as expected?
06:02:52 <quicksilver> handling of ^D is really something your shell does.
06:03:45 <rog_> is there a convention about the name an infix operator that looks like function application should look like? an arrow seems wrong, and a dot signifies composition, not application. the only example i can think of is <*> (which i can't use). maybe something else with a *?
06:04:05 <janimo> quicksilver:, dmwit_ got it
06:04:13 <janimo> works in xterm but not in gnoome-terminal
06:04:19 * quicksilver nods
06:04:19 <janimo> ghci -e "do getContents>>=print"
06:04:27 <quicksilver> shell/terminal issue then.
06:04:28 <lilac> rog_: <$> is used by Applicative
06:04:34 <janimo> maybe I messed up some of the settings
06:04:39 <lilac> rog_: and then of course there's $ and $!
06:05:51 <janimo> quicksilver, dmwit_ but indeed only if I build it. ghci does not take ctrl-D even in xterm
06:06:30 <quicksilver> ghci is probably taking full control of the terminal
06:06:39 <quicksilver> that's expected for an interactive program.
06:07:08 <Saizan> btw, anyone tried ghci 6.10 in haskell-mode?
06:07:11 <janimo> ok, actually it works when built but not in ghci regardless of terminal
06:07:32 <janimo> but once I exit unless I run reset (for the terminal) not even cat handles Ctrl-D
06:07:34 * dmwit_ feels vindicated
06:08:21 <dmwit_> janimo: ghci sets NoBuffering on stdin, which does strange things.  Try :m + System.IO and then hSetBuffering stdin LineBuffering.
06:08:55 <janimo> ok, since python works even if it too is a REPL and reads stdin
06:08:55 <rog_> lilac: i want it left associative, like normal application, so i don't think $ is appropriate. but then applicative does it left associative, so maybe it is ok. hmm.
06:08:57 <janimo> >>> import sys
06:08:58 <janimo> >>> print(sys.stdin.readlines())
06:09:23 <Asztal> F# defines <| and |> which act like $
06:09:27 <rog_> i'm using ~* currently.
06:10:02 <rog_> the joys of non-alphabetic function names!
06:10:17 <dmwit_> janimo: In a world with laziness, many things change.
06:10:41 <Saizan> dmwit_: why should laziness matter here?
06:10:44 <dmwit_> (With lazy IO, you usually *want* NoBuffering.)
06:11:08 <dmwit_> Saizan: It's more obvious exactly when things get calculated if you turn buffering off.
06:11:09 <janimo> dmwit_: even if setting buffering to Line it does not work
06:11:29 <janimo> I wonder why should ctrl-d depend on buffering at all
06:11:51 <janimo> it's as if the ctrl-d combination is not interpreted correctly
06:13:25 <janimo> oh it is actually closed as invalid http://hackage.haskell.org/trac/ghc/ticket/1268
06:13:32 <lambdabot> Title: #1268 (GHCi reads from stdin do not handle ^D) - GHC - Trac
06:15:21 <janimo> so it is a known issue and even if annoying it may not be fixed not to break backwards compat AIUI
06:15:52 <janimo> "Perhaps you're complaining about the fact that NoBuffering implies ICANON on Unix ttys, and hence disables the ^D processing.  GHC has always had this behaviour, as far as I recall. "
06:18:01 <hugo__> most of my friends keep on forcing me to move to ruby :(
06:19:47 <dmwit_> hugo__: Your life could be *so* much worse.
06:19:54 <hugo__> :D
06:19:57 <hugo__> indeed
06:20:04 <hugo__> i could be programming C++
06:20:05 <jsn> hugo__: it is the ghetto
06:20:13 <jsn> hugo__: c++ is so much cooler
06:20:26 <Boney> hugo__: you need new friends.
06:21:17 <hugo__> jsn: nahh... all c++ coders i know have aquired this strange nervous twitches
06:22:10 <Boney> oh hey,  I just relised I havn't had my twich for a couple of years now.
06:22:13 <dmwit_> Man, why all the hate?
06:22:18 <dmwit_> Coding can be fun!
06:22:42 <jsn> dmwit_: yeah, marginal languages shouldn't fight amongst themselves!
06:22:45 <rog_> i see the same ^D issue, and it doesn't appear to be anything to do with tty settings (they're unchanged between starting ghci and running getContents)
06:23:03 <Boney> seriously, this was about the time the guy that wares black in the corner of the office was suggesting I should look into FP.
06:23:35 <hugo__> see, i have a point :D
06:24:04 <Boney> hugo__: this is true, except that I was coding in Java,  but we can leave that detail out.
06:24:05 <Saizan> rog_: the point was that ghci changes them, not getContents
06:24:28 <rog_> Saizan: but in my case, ghci has not changed them (i checked)
06:24:43 <rog_> Saizan: (by doing two stty -a's and diffing them)
06:24:46 <hugo__> yes, i define what i call "the nervous twitch pack of languages" which include java, c++, c#
06:25:10 <Boney> it also had a bit to do with the workplace.
06:25:14 <rog_> the times i've seen the "ignore ^D" issue in the past it's been because the reader passes over a zero-length read, and just carries on to read again.
06:25:38 <Boney> anyhoo.
06:25:44 <hugo__> yes :/ most of the places where you code java/C++/C#/... have no windows
06:26:23 <vegai> no Windows?
06:26:27 <hugo__> not the OS
06:26:33 <hugo__> windows as in house windows
06:27:06 <Boney> oh we had windows, so the thread of definistration was strong.
06:27:22 <hugo__> heheh
06:27:44 <Boney> I realised it was bad when managment removed the steal cutlery and replaced it with plastic cutlery.
06:27:52 <Boney> you can't hurt anyone (even yourself) with that stuff.
06:28:57 <hugo__> i dont get it, these guys that usually start companies, have a tendency to pick a building and then: "look, here is a room without windows, what should we do here?" answer: "put the programmer monkeys... they like it"
06:29:38 <hugo__> and then there are the slave working corporations, aka consulting companies
06:30:39 <hugo__> i dont know how these guys plan on changing the world with their big mercedes and a horde of slave programmers to support them...
06:31:16 <Boney> mm,  so the problem is the 'programmer monkeys', managment tend to have the view that we're not indervidual, and don't have regular human neads.
06:31:47 <Boney> of course there are some places that seem to be the exception to this tread.
06:31:54 <Boney> they are worth finding.
06:32:12 <Boney> also, all companies (and people) change.
06:33:43 <hugo__> yes, i am aware of that
06:34:35 <saml> .faq can haskell do real-time audio programming?
06:35:52 <C-Keen> saml:there is hascore...
06:36:04 * byorgey cooks some locally nameless lambdacakes
06:36:07 <C-Keen> saml: and there are bindings for supercollider
06:38:02 <dmwit_> ?remember byorgey byorgey cooks some locally nameless lambdacakes
06:38:02 <lambdabot> Done.
06:38:10 <saml> real-time as in so fast. don't they only render wav?  i want users to press a key and hear sound with less than 10ms delay
06:38:46 <dmwit_> You'll likely have to write a small wrapper that binds to some existing C library.
06:38:52 <dmwit_> (Actually, I'm surprised there isn't one.)
06:39:20 <dmwit_> Oh, look, bindings to the SDL stuff.
06:39:26 <rog_> Saizan: yeah, i've just verified, the ^D problem occurs even when ghci has no access to a tty at all.
06:39:28 <dmwit_> ?hackage SDL-mixer
06:39:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-mixer
06:39:53 <dmwit_> rog_: Changing the buffering only requires a file handle, not a tty.
06:41:06 <dmwit_> saml: Is that what you meant?
06:41:34 <dmwit_> There's also a whole "Sound" category on Hackage.
06:42:26 <rog_> dmwit_: i wasn't aware it was possible to change the buffering on a pipe
06:42:42 <C-Keen> saml: supercollider is used by the livecodig folks a lot
06:44:01 <rog_> dmwit_: in fact, i'm fairly sure it isn't. of course, at the stdio level it's a different matter, but that's internal to ghci.
06:44:04 <saml> dmwit_: i will look into it. i tried yampasynth but it was way too slow. i'll try sdl
06:44:18 <saml> C-Keen: i use windows vista because it's better than mac and linux combined
06:44:50 <C-Keen> saml: good
06:45:16 <hugo__> saml: but worse than mac or linux by themselves :)
06:46:06 <saml> hugo__: exactly. i hate emergence when things are combined
06:46:13 <C-Keen> saml: http://sonenvir.at/downloads/sc3/sc3-win/ maybe that will suit you better then
06:46:23 <saml> no bug in this function. no bug in that function. when they are composed, it has bugs!
06:46:25 <lambdabot> Title: SuperCollider 3 for Windows — The SonEnvir project portal
06:46:46 <C-Keen> saml: the nice thing about this is that your haskell code just outputs a certain protocol (possibly over a network) to the supercollider server
06:48:21 <saml> C-Keen: thanks!
06:48:51 <C-Keen> saml: welcome
06:49:22 <C-Keen> saml: maybe you will find this interesting: http://toplap.org/index.php/Main_Page
06:52:38 <rog_> C-Keen: that's cool. e.g. i remember well watching someone manipulating kernel data structures on a multiuser machine live, with adb. no safety net...
06:53:12 <C-Keen> rog_: another view of live coding yes :)
06:53:22 <rog_> (i'm not sure they were changing the code though)
07:05:47 <mdmkolbe> I hear that GHC is moving away from darcs soon.  How soon will that be?  Week, Month, Months?
07:06:11 <LarstiQ> mdmkolbe: afaik git usage is already operational
07:06:35 <Axman6> hmm, ghc has been compiling for over 4 hours now...
07:07:07 <C-Keen> Axman6: what kind of machine are you using? on my little board it took nearly a whole day
07:07:21 <Axman6> Hostname: freebsd.axman6.homeip.net - OS: FreeBSD 7.0-RELEASE/i386 - CPU: Pentium II/Pentium II Xeon/Celeron (501.14-MHz 686-class CPU) - Processes: 118 - Uptime: 98d 3h 34m - Load Average: 1.08 - Memory Usage: 50.18MB/178.40MB (28.13%) - Disk Usage: 7.39GB/233.63GB (3.16%) - External Traffic (rl0): 2711.14MB In/2333.53MB Out
07:07:37 <C-Keen> Axman6: yep similar to mine
07:07:43 <Deewiant> 500 mhz and 180 MB memory? that might take a while :-P
07:08:02 <Axman6> well, it'll just keep me awake tonight :P
07:08:05 <BeelsebobWork> Axman6: that'll take about 48 hours IIRC
07:08:18 * Axman6 just wants darcs -_-
07:08:22 <BeelsebobWork> lol
07:08:30 <C-Keen> Axman6: there are darcs binaries
07:08:33 <mdmkolbe> LarstiQ: How long till darcs support is dropped?
07:08:41 <dmwit_> Axman6: Use a binary distribution of GHC?  and of darcs?
07:09:05 <Axman6> meh, ports is easy enough
07:09:28 <C-Keen> Axman6: your port system can also use prebuild packages
07:09:53 <Axman6> it probably can... but it's really not an issue :P
07:10:17 <dancor> is it impossible to have a foldM analogue foldMM :: (Monad m, Monad n) => (a -> b -> m (n a)) -> a -> [b] -> m (n a)
07:10:45 <idnar> @type foldM
07:10:48 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
07:12:01 <LarstiQ> mdmkolbe: that I'm not aware of, but I believe the intention is to keep a darcs mirror up for the forseeable future
07:12:26 <LarstiQ> mdmkolbe: but for authoritative answers, go to the source :)
07:27:21 <rog_> stupid question of the day: what's wrong with: data (~*) x y = (~*) x y
07:27:35 <rog_> i get "Malformed head of type or class declaration"
07:28:25 <Deewiant> rog_: has to start with :, no?
07:28:49 <rog_> Deewiant: what has to start with : ?
07:29:08 <rog_> oh, do all infix constructors have to start with : ?
07:29:16 <Deewiant> rog_: yes, constructors and the type name as well.
07:29:34 <Deewiant> rog_: and likewise, normal operators can't start with :.
07:29:39 <C-Keen> rog_: Konstruktors have to be uppercase but since ~ is no character you need :~ to mark it 'uppercase'
07:29:53 <C-Keen> rog_: it is an enforced lexical convention
07:30:08 <rog_> one i hadn't come across before
07:30:31 <rog_> i just thought those constructors starting with : were being nicely mnemonic!
07:30:31 <C-Keen> rog_: look at other definitions and you will notice
07:31:22 <C-Keen> rog_: the ':' just yells "I am an infix constructor!" at you silently :)
07:32:10 <rog_> thanks.
07:32:15 <quicksilver> rog_: Ah. I see your email succeeded in summoning oleg.
07:32:29 <rog_> quicksilver: oh good, i'll have a look
07:32:49 <rog_> quicksilver: nope, haven't got it yet.
07:33:35 <quicksilver> well it's copied to you personally and also on the -cafe
07:33:43 <quicksilver> and I got it 2.5 hours ago
07:34:05 <quicksilver> nabble has it
07:34:06 <quicksilver> http://www.nabble.com/labels-in-HList-td20107794.html
07:34:13 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - labels in HList
07:35:37 <tromp_> any suggestions for improvement of my Go program? http://www.cwi.nl/~tromp/go/Go.hs
07:36:41 <quicksilver> tromp_: can it beat a professional dan?
07:37:16 <dancor> have you tested it on snapback
07:37:20 <rog_> quicksilver: yeah, i found it in the archives. can't think why it hasn't yet arrived (personally or via mailing list). some other cafe posts have.
07:37:32 <tromp_> it doesn't play, just executes given moves
07:38:13 <rog_> quicksilver: he still doesn't address the point that you can't do those imports with the cabal install as it stands (unless i've misread him). but maybe you're not supposed to do that.
07:38:14 <tromp_> it's mostly an expression of the rules of go in haskell
07:38:44 <dancor> tromp_: i would use Array (Int,Int) instead of hardcoding n=3
07:38:49 <dancor> or something
07:38:56 <tromp_> no, i dont want ints
07:39:18 <tromp_> the domain of Position should be exactly all possible points
07:39:21 <dancor> one day you will want to play on a bigger board :)
07:39:39 <tromp_> then you expand definition of XCoord / YCoord
07:39:39 <mihir> hi guys...i was wondering if you could help me with haskell
07:39:57 <tromp_> now, there's no need to check for Int's outside board range
07:40:08 <dancor> i
07:40:15 <ToRA|MSR> mihir: don't ask to ask, just ask :)
07:40:18 <tromp_> the board dimensions are enforced by typers
07:40:25 <dancor> think it would be cooler if it was more general
07:40:28 <tromp_> types
07:40:32 <dancor> but i respect your decision :)
07:40:52 <hukolele> ive just compiled Yi the editor on windows, but idk how to run it, anyone did run it on win can tell me how?
07:40:58 <quicksilver> yes, but Int makes it more general at the cost of giving everything up.
07:41:17 <quicksilver> more general without giving everythign up would be making the coord type a parameter.
07:41:18 <dancor> everything?
07:41:18 <tromp_> changing Xcoord definition is not much harder than changing a width=3 definition
07:41:53 <hugo__> is control.arrow part of the prelude ?
07:42:03 <int-e> hugo__: no
07:42:05 <Deewiant> Prelude is the prelude, anything else is not
07:42:06 <dancor> hugo__: no you have to do import Control.Arrow
07:42:11 <mihir> ok..cheers dude...i am creating a text proceesor in haskell....but i am shaving difficulties adding extra spaces to the left so that the right hand ends of the words line up
07:42:15 <hugo__> oh
07:42:16 <hugo__> ok
07:42:55 <hukolele> in the yi install dir btw there is not a .exe or something like, only .a and .hi...
07:43:41 <dancor> it seems to me that a real go program would accept the board size as a parameter
07:43:46 <dancor> command line parameter
07:44:10 <tromp_> most real programs have it as a #define
07:44:11 <dancor> like gnugo does
07:44:16 <mihir> so is there anyways...either of you guys could help me
07:44:38 <quicksilver> tromp_: that's just not true.
07:44:49 <quicksilver> tromp_: every go game I've ever see enables you to choose board side at runtime.
07:44:52 <h0m3r> hi
07:44:59 <h0m3r> haskell newbie here
07:45:00 <int-e> tromp_: wouldn't  cycle [Black, White] be just as clear, if not clearer, than  iterate other Black?
07:45:08 <jeffz> mihir: it's usually best if you ask a question
07:45:11 <h0m3r> does anybody know how to get the division module in haskell?
07:45:19 <int-e> tromp_: and I sorta expected Position to be a newtype with an Eq instance.
07:45:21 <quicksilver> h0m3r: division module?
07:45:21 <mihir> ok..
07:45:21 <tromp_> yes, int-e, that's a good suggestion
07:45:31 <h0m3r> the module
07:45:35 <h0m3r> the remain of a division
07:45:43 <quicksilver> > 12 `mod` 5
07:45:44 <mihir> how do i add spaces to the left so that the right hand ends of the words line up???
07:45:46 <lambdabot>   2
07:45:49 <quicksilver> h0m3r: like that?
07:45:49 <dancor> modulus
07:46:09 <tromp_> making Position a newtype requires extra (un)wrapping at every use
07:46:17 <earthy> > 12 `quotRem` 5
07:46:18 <lambdabot>   (2,2)
07:46:25 <tromp_> i cldnt just apply a positions to a point
07:46:27 <h0m3r> yes
07:46:30 <h0m3r> thx quicksilver
07:46:31 <earthy> > 12 `divMod` 5
07:46:32 <lambdabot>   (2,2)
07:46:33 <Deewiant> > 12 `divMod` 5
07:46:34 <lambdabot>   (2,2)
07:46:50 <h0m3r> `mod` worked (i'm using curry)
07:47:29 <badsheepy> whats the difference between quoterem and divmod?
07:47:35 <dancor> negatives
07:47:45 <dancor> > (-12) `divMod` 5
07:47:46 <lambdabot>   (-3,3)
07:47:51 <dancor> > (-12) `quotRem` 5
07:47:52 <lambdabot>   (-2,-2)
07:47:53 <badsheepy> oh :)
07:47:57 <saml> @type? divMod
07:47:58 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
07:48:08 <saml> > divMod 1 0
07:48:10 <lambdabot>   * Exception: divide by zero
07:48:10 <tromp_> quicksilver: ok, i exaggerate. but the programs that optimize for speed often use #define to get some more optimizations
07:48:34 <jeffz> mihir: you could subtract the width of the text you've placed already from the total available space
07:48:58 <quicksilver> tromp_: frankly I don't think is an optimisation issue.
07:49:02 <quicksilver> it's a type safety issue.
07:49:06 <mihir> see i am novice in this...so i need some1...who could look at my code and tell me what to do
07:49:11 <quicksilver> it's not about making the program faster or slower
07:50:07 <jeffersonheard> can I declare A an instance of a typeclass, where A is defined by "type A = Ptr B"?
07:50:07 <int-e> newtype XCoord range = XCoord range deriving (Eq, Ord, Bounded, Enum)
07:50:16 <tromp_> i'll try making coordinates a parameter
07:50:38 <int-e> data Point xrange yrange = Point (XRange xrange) (YRange yrange)? etc?
07:50:40 <tromp_> no, you can't jefferson
07:50:51 <jeffersonheard> gah.  Just jeff
07:51:00 <jrh> But thanks
07:51:09 <Deewiant> jrh: you can if you newtype it.
07:51:12 <tromp_> must be off to gym, back in 1.15 hour...
07:51:18 <tromp_> thx for suggestions so far
07:51:25 <int-e> tromp_: mv x y  instead of  mv (x,y)  seems more natural.
07:51:57 <dancor> > preSpace ["lol", "whooop"] where preSpace lines = map (\ x -> replicate (maxlen - length x) ' ' ++ x) lines where maxlen = maximum $ map length lines
07:51:58 <lambdabot>   ["   lol","whooop"]
07:52:03 <jrh> Deewiant, meaning?  newtype A = A (Ptr B)?
07:52:19 <pjdelport> jrh: type is only a synonym for human consumption; "A" and "Ptr B" are still completely interchangeable in the type system
07:52:21 <Deewiant> jrh: yeah.
07:52:32 <pjdelport> jrh: so declaring an instance for one would declare it for the other
07:52:47 <jrh> I suspected that was the case, pjdelport
07:52:56 <pjdelport> newtype actually declares a distinct type, as far as the type system is concerned
07:53:07 <pjdelport> hence you can declare different instances for it
07:53:26 <jrh> So I could say "instance Eq (Ptr B) where" ?
07:53:50 <pjdelport> yep, probably
07:53:58 <Deewiant> I think that requires FlexibleInstances
07:54:02 <Deewiant> since you've specified the B
07:54:11 <jrh> Deewiant, thanks
07:54:37 <jrh> Once again, FFI code, where the comparison function for two handles is written in C
07:54:40 <Deewiant> what you can do more generally is instance Eq (Ptr a), or probably instance Eq a => Eq (Ptr a)
07:55:11 <Deewiant> but yeah, I'm not sure what's a smart idea in such a case.
07:55:29 <Deewiant> probably the newtype so you can forget that it's really a Ptr underneath.
07:55:41 <jrh> k
07:56:09 <Cale> newtype A = A (Ptr A)
07:56:16 <Cale> Is a rather fun trick :)
07:56:30 <Deewiant> O_o
07:56:37 <jrh> Cale: so I can pattern match on just A?
07:56:40 <jrh> that's evil
07:56:40 <geezusfreeek> ow my brain
07:56:41 <lilac> Cale: reinventing the natural numbers again?
07:56:41 <Deewiant> Is that useful for anything? :-P
07:56:43 <Cale> (good for representing abstract resources accessible from FFI)
07:56:51 <Cale> Yes, it actually is quite useful.
07:57:33 <jrh> so I could do... oh...  foreign import ccall "foo" c_foo :: A -> IO ()
07:57:42 <jrh> cute
07:57:44 <scook0> doesn't that make things a little hairy when you're using nested pointers?
07:57:45 <Cale> yeah, and the FFI can see through newtypes
07:57:54 <scook0> (not that nested pointers aren't hairy anyway)
07:57:56 <jrh> I'm using type at the moment, but I like that better
07:58:23 <mihir> any solutions tromp
07:58:38 <jrh> Cale:  meaning that if I call alloca and need a type Ptr A, the newtype trick doesn't garble it?
07:58:52 <jrh> (as in, that would be a Ptr (Ptr a)
07:59:03 <Cale> jrh: I mean, when you do the foreign import, it wraps the thing correctly.
08:00:04 <jrh> right.  I do have several instances where I have to preallocate space for a pointer to a new object A that I pass in as a parameter.  The type trick I already know works.  I'm assuming the Newtype trick will as well...
08:00:06 <Cale> But alloca will do the right thing regardless.
08:00:13 <jrh> k.  excellent
08:00:31 <Cale> Oh, yeah, you still need to allocate space explicitly.
08:00:51 <Cale> (if the thing you're calling expects you to manage the memory)
08:01:24 <jrh> Yeah, in those cases it does.  I've nitpicked this library to death
08:01:53 <jrh> By the end of the day, Haskell will have an interface to the Geospatial Data Abstraction Library
08:02:08 <jrh> and thus be a viable language to write GIS applications in
08:02:21 <h0m3r> does anybody know what's wrong with this curry code? http://pastebin.com/pastebin.php?dl=m55990abb
08:02:40 <jrh> right now, I'm doing a fairly straightforward translation, but I will write a higher level interface once the FFI code is done
08:02:42 <pjdelport> lambdabot: hpaste
08:02:52 <pjdelport> @hpaste
08:02:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:02:57 <pjdelport> h0m3r: -^
08:03:20 <quicksilver> h0m3r: data types have to have capital letters
08:03:25 <quicksilver> h0m3r: so it has to be BinTree
08:03:48 <pjdelport> constructors too
08:03:52 <h0m3r> okok, i'll try that, thx
08:03:57 <pjdelport> so, Empty and Node
08:04:18 <quicksilver> ahyes, that too.
08:04:39 <Cale> h0m3r: It's how the system syntactically distinguishes constructors from variables when pattern matching.
08:05:26 <h0m3r> if still giving the same error
08:05:59 <h0m3r> the code: http://hpaste.org/11389 the error: http://hpaste.org/11390
08:06:47 <quicksilver> h0m3r: I doubt that is the same error?
08:06:54 <quicksilver> in any case, it is something entirely different.
08:07:00 <quicksilver> it points out that your code is broken ;)
08:07:43 <Cale> h0m3r: What is the type of f x ?
08:07:44 <h0m3r> yes, i know my code is broken :-P, but don't know why
08:07:55 <pjdelport> h0m3r: the function you've implemented is not filter
08:07:57 <Cale> h0m3r: f :: a -> Bool, and x :: a, right?
08:08:04 <Cale> h0m3r: So f x :: Bool
08:08:18 <Cale> and so the Node you're constructing is a Tree Bool
08:08:22 <pjdelport> h0m3r: remove the type signature, and look at the type that gets inferred
08:08:25 <Cale> Is that really what you want?
08:09:00 <h0m3r> yes, cale
08:09:33 <Cale> h0m3r: But your type signature disagrees.
08:09:53 <h0m3r> does it?
08:09:54 <Cale> h0m3r: It claims that filterBinTree should produce a BinTree a
08:10:02 <Cale> not a  BinTree Bool
08:10:18 <pjdelport> h0m3r: the type signature is for filter
08:10:25 <pjdelport> h0m3r: but the implementation is for map
08:10:41 <pjdelport> you'll have to choose one or the other :)
08:10:42 <h0m3r> well, then the implementation is what is wrong, it must produce a BinTree a
08:11:42 <h0m3r> i choose filter xD
08:13:20 <pjdelport> @src map
08:13:20 <lambdabot> map _ []     = []
08:13:20 <lambdabot> map f (x:xs) = f x : map f xs
08:13:22 <pjdelport> @src filter
08:13:23 <lambdabot> filter _ []     = []
08:13:23 <lambdabot> filter p (x:xs)
08:13:23 <lambdabot>     | p x       = x : filter p xs
08:13:25 <lambdabot>     | otherwise = filter p xs
08:13:43 <pjdelport> compare and contrast
08:16:08 <h0m3r> ok, thx everybody
08:16:19 <h0m3r> i'll keep on thinking about it ;-)
08:20:04 <hugo__> what do the /> and the <\ operators do ?
08:20:15 <BeelsebobWork> depends what module you imported
08:20:39 <hugo__> oh
08:20:42 <hugo__> hxt :/
08:23:34 <jrh> grar.  Now I've got something that's going to return a pointer to a union.  I can find the type of the union from another function, so that's no problem, but I'm trying to figure out how to encode the result
08:23:52 <jrh> My best guess right now is
08:24:14 <jrh> data Fld ; newtype Fld = Field (Ptr Fld) ; data Field = Field FieldType Fld
08:25:54 <quicksilver> jrh: depends if you're trying to preserve representation or unwrap into a sensible haskell type.
08:26:14 <quicksilver> jrh: if you're trying to preserve representation then it has to be (Ptr SomethingAbstract)
08:26:16 <vegai> ls
08:26:23 <quicksilver> because no haskell type has the same representation as a C union
08:26:36 <jrh> quicksilver: preserve representation, so yeah
08:26:40 <quicksilver> alternatively, you unwrap it into a nice clean sum type data Foo = Bar | Baz
08:26:51 <rog_> oleg's reply got classified as spam by google. first time that's happened to me for anything significant.
08:27:24 <hugo__> do you know where i can find a good tut on hxt without being the ones on haskell.org wiki ?
08:28:39 <BMeph> Blasphemy!
08:28:43 <jrh> quicksilver: I'm thinking preserve the representation and then write getters/setters for each of the fields of the union, in a typesafe way
08:28:56 <quicksilver> jrh: yes, exactly.
08:29:09 <quicksilver> jrh: remember they'll be in IO though, if you're actualy mutating the Ptr.
08:29:25 <quicksilver> jrh: it might be more convenient, sometimes, to pull the value out into pure immutable haskell land.
08:29:26 <jrh> makes the most sense to the people who are used to the library already
08:29:29 * quicksilver shrugs
08:29:39 <quicksilver> depends of course precisely what ou're trying to do
08:30:01 <jrh> and yeah, that's the point -- mutating the Ptr.  Might write a convenience function to unwrap everything
08:30:53 <BMeph> hugo_: I'm not sure how good it is now, but Janis' stuff is always a good read for me. :)
08:32:50 <saml> > [1 ..............................................]
08:32:51 <lambdabot>   <no location info>: parse error on input `]'
08:33:22 <saml> > 1.34235347987598375984759827630925823094823095834095809346093485290345.3245234634524234645234643253454235
08:33:24 <lambdabot>       Overlapping instances for Show (a -> c)
08:33:24 <lambdabot>        arising from a use of `s...
08:33:45 <vixey> :t 1.2.3.4
08:33:46 <lambdabot> forall b c a. (Fractional (a -> b), Fractional (b -> c)) => a -> c
08:34:23 <quicksilver> haha :)
08:35:27 <saml> :t 1.1.1
08:35:28 <lambdabot> forall b c a. (Num (a -> b), Fractional (b -> c)) => a -> c
08:35:50 * saml head explodes
08:36:01 <saml> :t 1.(1.1)
08:36:02 <lambdabot> forall b c a. (Fractional (a -> b), Num (b -> c)) => a -> c
08:36:13 * BeelsebobWork wonders why 1.1 doesn't get given the type (Num (a -> b), Num (b -> c) => a -> c
08:36:16 <Deewiant> ?ty (1.1).1
08:36:17 <lambdabot> forall b c a. (Num (a -> b), Fractional (b -> c)) => a -> c
08:36:24 <BeelsebobWork> :t 1.1
08:36:25 <lambdabot> forall t. (Fractional t) => t
08:36:26 <Deewiant> BeelsebobWork: because 1.1 is fractional.
08:36:44 <BeelsebobWork> sure... but what I'm trying to establish is why the parser splits things up like it does
08:36:55 <BeelsebobWork> why is 1 . 1.1 . 1 less valid than 1.1 . 1.1
08:36:56 <Deewiant> maximal munch?
08:37:06 <dancor> :t 1 . 1.1 . 1
08:37:07 <lambdabot>     No instance for (Fractional (b -> c))
08:37:08 <lambdabot>       arising from the literal `1.1' at <interactive>:1:4-6
08:37:08 <lambdabot>     Possible fix: add an instance declaration for (Fractional (b -> c))
08:37:08 <Deewiant> I'm sure there's some specified rule for these cases
08:37:08 <BeelsebobWork> I guess
08:37:15 <dancor> :t 1.1 . 1.1
08:37:16 <lambdabot> forall b c a. (Fractional (a -> b), Fractional (b -> c)) => a -> c
08:37:30 <Deewiant> you'll probably find it in the report
08:37:34 <Deewiant> if you care to look
08:37:36 <dancor> :t 1.1 . 1.1 . 1.1
08:37:37 <lambdabot>     No instance for (Fractional (b -> c))
08:37:37 <lambdabot>       arising from the literal `1.1' at <interactive>:1:6-8
08:37:37 <lambdabot>     Possible fix: add an instance declaration for (Fractional (b -> c))
08:37:47 <dancor> :t 4. 5
08:37:48 <lambdabot> forall b c a. (Num (a -> b), Num (b -> c)) => a -> c
08:38:44 <dancor> 1 . 1.1 . 1 "errors \"more\"" than 1.1 . 1.1 most bc it has 3 terms
08:39:58 <dancor> everything is pretty reasonable except you could ask for 1.1.1 to be an error instead of greedily being 1.1 . 1
08:40:03 <lilac> the report often says things like "this thingy extends as far as possible to the right"
08:40:14 <lilac> > (1).1
08:40:15 <lambdabot>       Overlapping instances for Show (a -> c)
08:40:15 <lambdabot>        arising from a use of `s...
08:40:30 <lilac> @type (1).1
08:40:32 <lambdabot> forall b c a. (Num (a -> b), Num (b -> c)) => a -> c
08:41:27 * plutonas wrote everything very nicely in his exam, except the monad question where he screwed up... and it was a simple one
08:43:02 <Deewiant> I'm writing a trie library---essentially Sets and Maps with list keys. I want to have Patricia tries separate, so that's 4 data structures (basic Set/Map, Patricia Set/Map). I can have different internal structure for when the list type has an Eq/Ord/Enum instance, so that's 12 types. Is this smart? Is there a smart way of dealing with this without ending up with lots of almost-identical code?
08:48:27 <Deewiant> So I'd be looking at something like Data.Trie.Set.Enum, Data.Trie.Set.Eq, Data.Trie.Set.Ord, repeat for s/Set/Map/ and s/Trie/Trie.Patricia/
08:51:27 <Deewiant> This just smells bad somehow but I can't think of anything better.
08:53:45 <wjt> Deewiant: just require the list type to have those instances
08:54:10 <Deewiant> wjt: the trie is different depending on the instance.
08:54:57 <Deewiant> The three cases are Eq => [(key,Trie)], Ord => Map key Trie, Enum => IntMap Trie
08:55:01 <wjt> ah
08:55:07 <wjt> youch
08:55:45 <niklaus>  how do we find the minimal number of flips for a string of brackets to be balanced (even length )
08:55:47 <Deewiant> The latter two I can handle in my code with something like a MapTrieBase.hs which is #included into the "real" modules
08:56:08 <Deewiant> But I still have a lot of duplicated code overall. Between Set and Map as well, of course.
08:56:24 <vixey> niklaus: So like (((( is 2 flips?
08:56:50 <Deewiant> niklaus: http://en.wikipedia.org/wiki/Levenshtein_distance
08:56:51 <lambdabot> Title: Levenshtein distance - Wikipedia, the free encyclopedia
08:56:53 <niklaus> vixey, yes and at any point the number of close ")" should be <= "("
08:57:33 <vixey> :t count
08:57:34 <lambdabot> Not in scope: `count'
08:57:44 <vixey> @let count p = length . filter p
08:57:45 <lambdabot>  Defined.
08:57:45 <niklaus> Deewiant, we are not allowed to insert or delete
08:58:02 <niklaus> and that is for 2 strings
08:58:09 <Deewiant> niklaus: you can simplify those cases away from the algorithm
08:58:17 <vixey> > let l = "((((" in 1 * count (=='(') l + (-1) * count (=='(') l
08:58:18 <lambdabot>   0
08:58:21 <niklaus> what is the targe string
08:58:26 <vixey> > let l = "((((" in 1 * count (=='(') l + (-1) * count (==')') l
08:58:27 <lambdabot>   4
08:58:48 <niklaus> Deewiant, what is target string
08:58:49 <Deewiant> niklaus: flip any half of unbalanced brackets
08:58:51 <vixey> > let l = "(((()(" in (1 * count (=='(') l + (-1) * count (==')') l)`div`2
08:58:52 <lambdabot>   2
08:59:02 <Hegel> o/ athos
08:59:28 <Deewiant> niklaus: I think, anyway. Shouldn't be too hard to figure out; remove balanced pairs since those don't have to be changed and then do something with what's left.
09:01:43 <vixey> :t scanl
09:01:44 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:02:22 <vixey> > scanl (\b c -> if b == '(' then c+1 else c-1) 0 "((()))()((((()))())()(((()"
09:02:24 <lambdabot>       No instance for (Num Char)
09:02:24 <lambdabot>        arising from the literal `1' at <inte...
09:02:32 <vixey> > scanl (\c b -> if b == '(' then c+1 else c-1) 0 "((()))()((((()))())()(((()"
09:02:33 <lambdabot>   [0,1,2,3,2,1,0,1,0,1,2,3,4,5,4,3,2,3,2,1,2,1,2,3,4,5,4]
09:02:46 <hugo__> sigur rós is really depressive
09:03:02 <Hegel> well
09:03:03 <Hegel> no
09:03:06 <Hegel> not really
09:03:09 <vixey> > (last $ scanl (\c b -> if b == '(' then c+1 else c-1) 0 "((((")`div`2
09:03:10 <lambdabot>   2
09:05:08 <saml> ok bored? write a one liner that unfolds secrets of prime number distribution
09:05:30 <vixey> :t unfoldr
09:05:32 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:05:34 <niklaus> vixey, how much did you get for ((()))()((((()))())()(((()
09:05:50 <vixey> niklaus,
09:07:17 <vixey> ø ((()))()((((()))())()(((() = ø (((( = 2
09:08:02 <niklaus> vixey, :) cool
09:10:47 <ystael> hugo__: sigur ros is wonderful and makes happy.  i admit that i don't like the later work as much as 'Agaetis byrjun' though.
09:13:38 <hugo__> ystael: i find it very sadening, im almost cuting my wrists
09:14:27 <rog_> is there some way of turning an expression into a type? e.g. foo ::  a -> typeof (4 +)
09:14:51 <quicksilver> rog_: and what would the type of the type be?
09:15:06 <rog_> quicksilver: does it need a name?
09:15:07 <vixey> rog_: you want a function called typeof in the type system?
09:15:07 <quicksilver> rog_: (types don't exist as values in haskell)
09:15:27 <quicksilver> oh, I see.
09:15:33 <quicksilver> no, not exactly
09:15:43 <quicksilver> but can do thing like that with asTypeOf
09:16:02 <quicksilver> x `asTypeOf` (\_ -> (4+))
09:16:26 <ziman> :t asTypeOf
09:16:28 <lambdabot> forall a. a -> a -> a
09:16:50 <quicksilver> rog_: does that appear to solve your problrm?
09:17:33 <rog_> hmm. it's all the messing around with types in HList that's getting to me. it's really hard to write out types explicitly. sometimes the type of something is best defined by the result-type of a function with the relevant argument type...
09:18:22 * quicksilver nods.
09:18:41 <ystael> quicksilver: does that sort of trick the type inference algorithm into constraining the type of x to be what you want?
09:19:07 <vixey> it is just unification
09:19:10 <rog_> when i've got a complex type that's derived from a particular expression, i'd like not to have to explicitly type that expression (as that makes the code less maintainable)
09:19:13 <Deewiant> > 1 `asTypeOf` 1.0
09:19:14 <lambdabot>   1.0
09:19:16 <Deewiant> > 1
09:19:17 <lambdabot>   1
09:19:51 <vixey> rog_: haskell can't infer the right types?
09:20:03 <rog_> ... but i do like providing explicit signatures for most functions...
09:20:05 <ystael> vixey: that's exactly what i meant.  like writing a stupid definition in Coq: Definition typeof (A: Type) (x: A): Type := A.
09:20:34 <ystael> it doesn't actually extract the type from a term, but if you write Eval simpl in typeof _ 3, the type inference reconstructs and returns nat.
09:20:35 <rog_> vixey: it can.
09:20:47 <quicksilver> ystael: Yes. I wouldn't really call it a trick. But yes, that's what it does :)
09:21:09 <rog_> vixey: but i find it very easy to get lost in a sea of unsurety if i let the haskell do all my inference.
09:21:24 <rog_> vixey: (in particular, the error messages become harder to interpret)
09:21:37 <rog_> vixey: (and they're not easy at the best of times!)
09:24:11 <rog_> in fact, i kind of wish it was possible to specify some components of a type, and let the type system figure out the rest. maybe i should do more explicit expression-level typing.
09:24:38 <vixey> rog_: yes, It's nice being able to leave holes in types
09:24:58 <vixey> it would be a good addition to haskell actually
09:25:10 <vixey> why don't you add it to GHC?
09:25:44 <rog_> vixey: the problem is, i don't see that it's possible in general, as if you're not giving a type signature for a function, you've got no type variables to define your partial types in terms of.
09:25:47 <quicksilver> rog_: yes, partial type annotaitons would be very nice.
09:26:03 <ziman> > 1 `asTypeOf` 5%4
09:26:05 <lambdabot>   1%4
09:26:05 <vixey> rog_: It's possible in general
09:26:22 <niklaus> vixey, i store +1 for "(" and -1 for ")" ,  at any point where cum sum <0 , flip because that is the minimal reqd for to be balanced, and for  { indexes > len/2,  cusum(1,len)>0 }, flip, this is because no matter what we do with future brackets the sum is always going to be +ve
09:26:25 <rog_> vixey: i've only been using haskell for a month or so now. adding things to GHC is.... beyond my current grasp. :-_
09:26:35 <ystael> :t 5%4
09:26:36 <lambdabot> forall t. (Integral t) => Ratio t
09:26:46 <ziman> > 1 `asTypeOf` (5%4)
09:26:47 <lambdabot>   1%1
09:26:50 <vixey> niklaus: ah that sounds good
09:27:00 <ystael> ziman: ah, i was confused for a moment. :)
09:27:09 <ziman> me too :)
09:27:27 <niklaus> vixey, but it is wrong for the example you gave, (note i'm not removing balanced parenthesis)
09:27:35 <vixey> rog_: I'm sure you could do it if you tried
09:27:49 <rog_> vixey: it is possible in general... in current haskell?
09:28:57 <rog_> vixey: i'm spending more time than i should messing about with this stuff anyway. my colleagues want me to just hack out a specific solution. i'm balking. and i've a list of "i'd like to do that" projects that filled the cupboard decades ago!
09:30:00 <rog_> (well ok that's a slight exaggeration)
09:34:10 <lilac> vixey: something like this? a :: Maybe _ -> Either _ String; a Nothing = Left (); a (Just x) = Right x
09:34:24 <vixey> yes
09:34:30 <lilac> that'd be very neat
09:37:32 <rog_> lilac: that's what i'd imagined. it's always seemed a little odd to me that you couldn't use _ as a type variable.
09:39:39 <vixey> rog_: AFAICT it's because nobody implemented it :p
09:40:04 <hukolele> anyone did compile Yi on windows?
09:44:35 <hugo__> i like the fact that hxt works with xpath expressions
09:44:38 <hugo__> really sweet
09:46:00 <quicksilver> domain specific text based languages
09:46:04 <quicksilver> love them or hate them?
09:47:10 <lilac> hmm. do wildcards in types make unification harder? i guess probably not since they must arise all the time anyway...
09:47:32 <vixey> there is nothing new algorithmically you need to do to implement this
09:47:33 <quicksilver> no, they don't.
09:47:42 <quicksilver> they're just the same as free type variables
09:48:08 <quicksilver> (as distinct from what GHC terms "rigid" type variables)
09:48:29 <lilac> i thought not. my example above is exactly like adding: f :: Maybe a -> Maybe a; g = a . f; h :: Either a String -> Either a String; i = h . a
09:48:37 <lilac> (i think)
09:48:46 <vixey> lilac,
09:48:48 <vixey> foo :: a
09:48:49 <vixey> foo = \x -> x
09:48:59 <vixey> is an example where you'd have to use _ instead of a
09:49:32 <lilac> vixey: right. you want foo :: (forsome a. a) rather than foo :: (forall a. a)
09:50:43 * lilac notes that this is not the same as foo :: (exists a. a)
09:53:17 <vixey> what's exits?
09:53:18 <vixey> exists
09:53:48 <lilac> exists is dual to forall
09:53:53 <opqdonut> how is forsome different than exists?
09:54:11 <vixey> what do you mean ual
09:54:14 <opqdonut> :D
09:54:16 <vixey> dual?
09:54:46 <lilac> it means the arrows go the other way around, which i guess is not helpful :)
09:54:59 <vixey> yeah I have no idea what that means
09:55:42 <opqdonut> vixey: for example (exists a. (x->a,a->y))
09:55:57 <opqdonut> tells you that there is some concrete type but you're not allowed to know which
09:56:18 <opqdonut> so the onlything you can do with a tuple (f,g) of that type is do g.f
09:56:28 <opqdonut> delete the other do
09:58:14 <vixey> can you show me some examples of values with exists in the type?
09:58:51 <lilac> opqdonut: forsome != exists, because in "foo :: exists a. a; foo = True", foo cannot be used in a context where a Bool is required
09:59:47 <opqdonut> lilac: ah okay
10:00:28 <opqdonut> vixey: such values don't naturally arise, they are "casted"
10:01:17 <opqdonut> but an encapsulation like "data Foo = exists a. Foo a (a->String) (a->Bool)" is how exists is usually used
10:01:51 <lilac> vixey: data Generator x = forall a. Gen (a, a -> (a, x))    is equivalent to    data Generator x = Gen (exists a. (a, a -> (a, x)))
10:01:55 <opqdonut> they're important in expressing object-oriented stuff
10:03:29 <opqdonut> lilac: err, Gen ((), \_ -> ((),1)) isn't a valid value of the former but is of the latter
10:03:38 <opqdonut> or am i missing something
10:03:43 <lilac> vixey: [exists a. Show a => a] would be a list of showable things
10:04:52 <lilac> opqdonut: it is a valid value of the former, as I understand it, but possibly i've got it backwards. Gen :: forall a. (a, a -> (a,x)) -> Generator x
10:06:22 <lilac> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
10:06:24 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
10:10:18 <opqdonut> lilac: no, it was me misremembering existential types :)
10:15:42 <johnnowak> @pl \f z x y -> (f x z, f y z)
10:15:46 <lambdabot> ap (ap . ((flip . (((.) . (,)) .)) .) . flip) flip
10:16:06 <thoughtpolice> fear the @pl
10:16:29 <johnnowak> ow
10:16:44 <Beelsebob> @pl \x y -> (f x &&& f y)
10:16:44 <lambdabot> (. f) . (&&&) . f
10:16:48 <Beelsebob> that's nicer
10:16:59 <Beelsebob> @type (. f) . (&&&) . f
10:17:00 <lambdabot> forall a (a1 :: * -> * -> *) b c c' a2. (SimpleReflect.FromExpr (a1 b c), Show a2, Arrow a1, SimpleReflect.FromExpr (a1 b c'), Show a) => a2 -> a -> a1 b (c, c')
10:17:12 <Beelsebob> oh, it'snot right though
10:17:12 <Beelsebob> fail
10:17:27 <Beelsebob> oh, yes it is
10:17:37 <johnnowak> it's just 'papply bi' in Cat
10:17:39 <Deewiant> @pl \f z x y -> (f x &&& f y) z
10:17:39 <lambdabot> flip . (flip .) . (flip =<< (((.) . (&&&)) .))
10:17:44 <johnnowak> er, 'papply bi@'
10:18:00 <Beelsebob> @pl \f x y z -> (f x &&& f y) z
10:18:00 <lambdabot> flip =<< (((.) . (&&&)) .)
10:18:09 <Beelsebob> rather better
10:18:10 * johnnowak runs in fear
10:18:18 <Beelsebob> if you're prepared to have your arguments in the wrong order
10:36:53 <tromp_> do class conditions make sense in data declarations?
10:36:58 <tromp_> like:  data (Coord x, Coord y) => Point2D x y = Point2D x y deriving (Eq)
10:37:03 <vixey> not really
10:37:17 <tromp_> why does ghc allow them then?
10:38:11 <ddarius> Because the standard says to.
10:40:04 <Deewiant> And why does the standard say so? :-)
10:40:06 <tromp_> does the standard see any use for that?
10:43:54 <tromp_> do the standard libraries have any conditional data declarations?
10:44:10 <vixey> what's that
10:44:37 <tromp_> data (SomeClass a) => ...
10:46:06 <tromp_> i was expecting that with my Point2D  definition, whenever i use a  Point2D x y , the compiler knows that x and y are in class Coord
10:47:04 <linolium> how can I compare a number returned by Data.Map.lookup to a number computer by subtracting one Int from another?  I think I'm having problems because one isn't of type "Ord"
10:47:38 <rwbarton>  @type Data.Map.lookup
10:47:45 <rwbarton> lookup doesn't return a number
10:47:50 <rwbarton> @type Data.Map.lookup
10:47:51 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
10:48:04 <gbacon> I want to print the Haskell NDP paper, but it's sized for A4, which we ugly Americans don't have. I tried scaling it with mogrify, but that looks terrible. Any helpful hints?
10:48:52 <rwbarton> linolium: what do you want to do if the key you look up isn't present in the map?
10:49:20 <ravi_n> gbacon: You have the paper as PDF?
10:49:25 <gbacon> ravi_n: yes
10:49:59 <linolium> rwbarton: I already added a check to make sure it is
10:50:09 <rwbarton> Then you can use...
10:50:11 <gbacon> google searches have been fruitless
10:50:12 <rwbarton> @type Data.Map.!
10:50:13 <lambdabot> parse error on input `Data.Map.!'
10:50:17 <linolium> ?
10:50:18 <rwbarton> @type (Data.Map.!)
10:50:20 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
10:50:50 <linolium> how do I use !
10:50:53 <ravi_n> gbacon: I think you do pdf2ps and then use ps2pdf, ps2pdf has switches that let you change the paper size (vaguely recalled from when I was trying to format my ICFP paper)
10:51:06 <gbacon> ravi_n: thanks
10:52:45 <linolium> wait, what's the difference between lookup and ! ?
10:53:19 <pjdelport> > fromList [(1,'a')] `lookup` 1
10:53:20 <lambdabot>   Not in scope: `fromList'
10:53:25 <pjdelport> > M.fromList [(1,'a')] `lookup` 1
10:53:26 <lambdabot>       No instance for (Num [(M.Map t Char, b)])
10:53:26 <lambdabot>        arising from the liter...
10:54:01 <pjdelport> > lookup 1 $ M.fromList [(1,'a')]
10:54:03 <lambdabot>   Couldn't match expected type `[(t, b)]'
10:54:05 <linolium> is lookup only for using in monads?
10:54:20 <pjdelport> > M.lookup 1 $ M.fromList [(1,'a')]
10:54:21 <lambdabot>       No instance for (Show (m Char))
10:54:21 <lambdabot>        arising from a use of `show' at ...
10:54:35 <pjdelport> > M.lookup 1 $ M.fromList [(1,'a')] :: Maybe Char
10:54:37 <lambdabot>   /tmp/8205091487886864872:68:40: Not in scope: `M.lookup'/tmp/82050914878868...
10:55:51 <pjdelport> ?
10:56:20 <niklaus> vixey, do you have some more longer inputs
10:56:21 <pjdelport> > M.fromList [(1,'a')] ! 1
10:56:22 <lambdabot>   Couldn't match expected type `Array i e'
10:56:22 <niklaus> for ()
10:56:23 <rwbarton> this happens all the time sadly... modules are in scope for typechecking but not for evaluating
10:56:28 <pjdelport> > M.fromList [(1,'a')] (M.!) 1
10:56:29 <lambdabot>   Couldn't match expected type `(M.Map k a -> k -> a) -> t1 -> t'
10:56:48 <pjdelport> > M.fromList [(1,'a')] M.! 1
10:56:49 <lambdabot>   /tmp/7498292909350121921:68:40: Not in scope: `M.fromList'/tmp/749829290935...
10:56:58 * pjdelport gives up
10:57:22 <Saizan> there's no Data.Map in any way in scope
10:57:34 <Saizan> , M.fromList []
10:57:36 <lunabot>  luna: Not in scope: `M.fromList'
10:57:45 <Saizan> neither there :)
10:58:13 <linolium> , Data.Map.fromList
10:58:15 <lunabot>  luna: Not in scope: `Data.Map.fromList'
10:58:27 <Beelsebob> > Data.Map.(!) (Data.Map.fromList [(1,'a')]) 1
10:58:28 <lambdabot>       Failed to load interface for `Data':
10:58:28 <lambdabot>        Use -v to see a list of the...
10:59:10 <pjdelport> linolium: anyway, yeah; (!) just blows up if it doesn't find the key
10:59:11 <linolium> > (M.fromList [('a', 5)]) M.! 'a'
10:59:12 <lambdabot>   /tmp/3170376458148246051:68:37: Not in scope: `M.fromList'/tmp/317037645814...
10:59:27 <linolium> pjdelport: I see
10:59:31 <pjdelport> linolium: lookup calls fail in the monad
11:00:13 <linolium> why does lookup do that and none of the others do
11:00:16 <linolium> that seems inconsistent
11:00:21 <pjdelport> none of the others?
11:00:33 <linolium> the other methods in Data.Map
11:01:19 <pjdelport> lookupIndex, minView/maxView do
11:01:33 <pjdelport> but it's a bad thing to do, really
11:01:35 <pjdelport> fail is evil
11:01:51 <vixey> why
11:01:52 <pjdelport> those methods should just return Maybe
11:02:04 <pjdelport> or MonadPlus, at least
11:02:05 <linolium> c,nfps.d
11:02:26 <pjdelport> vixey: fail is not part of the definition of a monad
11:02:27 <linolium> oh dear, getting keyboard layouts confused
11:02:39 <vixey> yeah it is
11:02:57 <pjdelport> vixey: it happens to be in Haskell's Monad type class
11:03:19 <pjdelport> which doesn't make it any more relevant to monads
11:03:32 <pjdelport> it's largely an artifact of do syntax
11:03:43 <pjdelport> to have something to call when pattern matches fail
11:03:51 <pjdelport> (as far as i understand)
11:04:42 <pjdelport> Data.Map uses fail as if it were mzero
11:05:05 <pjdelport> which isn't the case for many monads
11:05:14 <vixey> they should make do and do+
11:05:15 <pjdelport> which can implement fail pretty arbitrarily
11:05:28 <linolium> what's wrong with this: Data.Map.findWithDefault (\_ -> 0) next realHash
11:05:45 <linolium> where realHash = fromList [('a',5)] and next = 'a'
11:06:57 <vixey> @let realHash = fromList [('a',5)]
11:06:58 <lambdabot>  <local>:12:11: Not in scope: `fromList'
11:07:03 <pjdelport> linolium: shouldn't that be 0 instead of (\_ -> 0)
11:07:20 <vixey> @let realHash = M.fromList [('a',5)]
11:07:21 <lambdabot>  Defined.
11:07:27 <vixey> @let next = 'a'
11:07:28 <lambdabot>  Defined.
11:07:33 <linolium> pjdelport: I thought findWithDefault requires a function
11:07:34 <vixey> :t M.findWithDefault (\_ -> 0) next realHash
11:07:35 <lambdabot>     Ambiguous occurrence `next'
11:07:36 <lambdabot>     It could refer to either `L.next', defined at <local>:13:0
11:07:36 <lambdabot>                           or `System.Random.next', imported from System.Random
11:07:42 <linolium> pjdelport: oh, maybe I'm being stupid again
11:07:50 <pjdelport> :t M.findWithDefault
11:07:51 <lambdabot> forall a k. (Ord k) => a -> k -> M.Map k a -> a
11:08:21 <linolium> ah I see
11:10:03 <lilac> M.lookup is to lookup as ! is to !!
11:10:36 <lilac> (approximately)
11:10:49 <vixey> this requires a commutative diagram
11:12:27 <tromp_> i rewrote my Go program to parametrize on board dimensions, but i cant get it to compile:(
11:12:27 <Samy> ! is to !!?
11:12:53 <tromp_> can anyone see the problem? http://hpaste.org/11391
11:13:15 <tromp_> compiler says Ambiguous type variable `p' in the constraint:
11:14:48 <luite> does anyone here have a working example of a parsec IndentParser? I'm not sure how to use the indentParser and block functions to add indent-based parsing to an existing parsec parser
11:17:58 <rwbarton> tromp_: paste the error message
11:18:17 <Samy> @info What is the purpose of this?
11:18:17 <lambdabot>  Parse error at "of" (column 21)
11:18:24 <tromp_> Go.hs:107:13:
11:18:24 <tromp_>     Ambiguous type variable `p' in the constraint:
11:18:24 <tromp_>       `Point p' arising from a use of `showpos' at Go.hs:107:13-47
11:18:24 <tromp_>     Probable fix: add a type signature that fixes these type variable(s)
11:18:44 <Samy> ah, ok
11:18:45 <tromp_> line number may be off by 1
11:19:26 <tromp_> the relevant code fragment is
11:19:28 <tromp_> showgame :: (Point p) => Game p -> IO ()
11:19:29 <tromp_> showgame game = do
11:19:29 <tromp_>   putStrLn $ showpos emptypos
11:19:44 <rwbarton> tromp_: Right, how can it possibly know which Point instance you want?
11:19:58 <tromp_> cause i declare:     emptypos = const Empty :: Position p
11:20:10 <rwbarton> tromp_: ah
11:20:14 <rwbarton> tromp_: That doesn't do what you think it does
11:20:19 <tromp_> so emptypos uses same board as argument game
11:20:29 <rwbarton> tromp_: Turn on ScopedTypeVariables and add forall p. before the type signature of showgame
11:20:53 <tromp_> uhm, i'd like my code to work under default options
11:20:59 <tromp_> can i rewrite it?
11:21:02 <rwbarton> maybe
11:21:09 <vixey> tromp_: why?
11:21:15 <rwbarton> If you can get a Position p out of a Game p, then yes
11:21:27 <rwbarton> Or rather, if you can get the type Position p out of the type Game p
11:21:39 <vixey> foo :: Game p -> Position p
11:21:40 <vixey> foo = foo
11:21:48 <tromp_> i see
11:22:01 <rwbarton> Yeah, that looks like it will work
11:22:16 <rwbarton> emptypos = const Empty `asTypeOf` foo game
11:22:38 <tromp_> hmm, feels a bit like black magic:(
11:22:46 <rwbarton> The option exists for a reason :P
11:24:22 <jsn> luite: i'm working on one
11:24:34 <jsn> but i'm not doene :)
11:25:09 <jsn> i want to have a combinators to treat indent and outdent like parentheses
11:25:52 <luite> jsn: are you working on a new package, or is it based on the current IndentParser (0.2.1) package on hackage?
11:25:59 <jsn> new package
11:26:09 <jsn> i don't think that one has the right perspective
11:27:01 <jsn> i'm trying to make indent and outdent appear to be tokens, even though they are not
11:27:15 <luite> I don't really 'get' the current one, and it does not exactly have a lot of documentation
11:27:54 <luite> yes, that sounds reasonable
11:28:05 <jsn> http://github.com/jsnx/dent/
11:28:25 <jsn> i will try to finish it up soon
11:28:27 <roconnor> ooh, I should make AlphaColour a Monoid.
11:28:40 <roconnor> @hoogle Monoid
11:28:41 <lambdabot> module Data.Monoid
11:28:41 <lambdabot> Data.Monoid class Monoid a
11:29:11 <luite> jsn: ah, thanks
11:29:20 <saml> wanna chat?
11:29:30 <saml> brb i need to work
11:29:44 <saml> haha i'm so funny that i just asked "wanna chat?" then i said "brb"
11:29:46 <jsn> it's somewhat complicated because you need to push some indent onto a state parameter so you can take it off later
11:30:12 <jsn> but what's really cool is "far indentation"
11:30:24 <jsn> which i sorta made up
11:30:57 <jsn> > print "      a\n   b\n c"
11:30:58 <lambdabot>   * Exception: "<IO ()>"
11:31:03 <jsn> oh bah
11:31:17 <jsn> so, there should be two indent levels for the first line there
11:31:27 <jsn> but you have to lookahead to find them
11:31:32 <vixey> why would you want identation sensitive syntax?
11:32:14 <Samy> jsn, can you show us an example on hpaste?
11:32:21 <jsn> sure
11:32:26 <luite> jsn: hm, I'm not really sure I understand what you mean
11:32:36 <luite> an example would be good indeed :)
11:32:38 <Samy> http://github.com/jsnx/dent/tree/master/README
11:32:40 <lambdabot> Title: README at master from jsnx's dent — GitHub
11:34:07 <FrozenTomato> ?hoogle
11:34:07 <lambdabot> No query entered
11:34:07 <lambdabot> Try --help for command line options
11:34:14 <FrozenTomato> --help
11:34:17 <vixey> ?farmer
11:34:17 <lambdabot> Sounds like it's time to sever the apron string.
11:34:29 <FrozenTomato> ?hoogle --help
11:34:29 <lambdabot> Go to the website for full help, http://haskell.org/hoogle/
11:34:29 <lambdabot>  
11:34:29 <lambdabot> Flag reference:
11:34:35 <tromp_> i have one more error in http://hpaste.org/11393
11:34:54 <FrozenTomato> ?hoogle [Int] -> Int
11:34:54 <lambdabot> Prelude maximum :: Ord a => [a] -> a
11:34:54 <lambdabot> Prelude minimum :: Ord a => [a] -> a
11:34:54 <lambdabot> Data.List maximum :: Ord a => [a] -> a
11:34:59 <tromp_>     Could not deduce (Coord xc1) from the context ()
11:34:59 <tromp_>       arising from a use of `allcoords' at Go.hs:119:14-22
11:35:35 <tromp_> it doesn't complain about the use of allcoords in allpoints though
11:35:37 <vixey> ?farmer
11:35:37 <lambdabot> He's running around like a chicken with his ass cut off.
11:36:08 <jsn> Samy: http://hpaste.org/11395
11:36:38 * rog_ wishes that "import Module as M" either gave an error, or did an "import qualified" anyway.
11:37:02 <jsn> oh, here, i wrote this
11:37:02 <jsn> http://github.com/jsnx/dent/tree/master/doc/far-example
11:37:05 <lambdabot> Title: doc/far-example at master from jsnx's dent — GitHub
11:38:33 <luite> jsn: does it need to process the whole stream to know how 'deep' each indent is?
11:39:37 <jsn> it needs to go up to the starting indentation level
11:39:49 <jsn> so if you try "far" indentation on the whole document, then yes
11:39:56 <jsn> well, even then, no
11:40:15 <jsn> because if you reach a zero indent, then obviously, there is not further to go
11:40:36 <luite> ah
11:40:54 <jsn> however, that's why i have two algorithms
11:40:59 <jsn> near and far
11:41:19 <jsn> i see far indentation actually being helpful for nifty patterns, like: http://hpaste.org/11396
11:41:23 <proq> heh... *not* parallels' fault
11:42:23 <jsn> so the pattern there is "indent-indent a outdent b outdent" is a quote "a" with attribution "b"
11:43:05 <sheijk> far indent looks like a great way to make code obscure
11:43:21 <proq> oops, wrong channel
11:43:39 <jsn> sheijk: it allows you to define unlimitedly crazy indentation patterns, yeah
11:43:42 <sheijk> like "looks, there is an additional indent level on the next page, surprise!"
11:44:02 <vixey> it sounds awful to program in
11:44:14 <jsn> sheijk: well, any parser combinator allows you to do stupid stuff
11:44:58 <jsn> i set it up to be limited by the current indentation level so you can prevent it from leaking out to the whole document
11:45:10 <geezusfreeek> dang i didn't realize C++ templates don't type check at all unless you instantiate them :(
11:45:55 <geezusfreeek> haskell has given me a bad habit of relying on the compiler
11:46:03 <jsn> however, i think it allows for some really nice little patterns that you can't have otherwise
11:46:09 <mc___> Let say I  have the type "data Triple a b c = Triple a b c" is it possible to get "Triple 1 2 3" produce for instance "Triple 2 3 6"
11:46:12 <jsn> so i've worked out an algorithm for it
11:46:17 <sheijk> jsn: could you show us an example?
11:46:27 <vixey> mc___: what instance..?
11:46:33 <jsn> sure
11:46:42 <jsn> just a few minutes ago in this channel
11:46:44 <jsn> http://hpaste.org/11396
11:47:12 <mc___> vixey: ehm no instance, I meant for example
11:47:20 <jsn> <jsn @ 2008-10-22 11:42:22 -0700> so the pattern there is "indent-indent a outdent b outdent" is a quote "a" with attribution "b"
11:47:34 <sheijk> jsn: i saw that one but i'm not sure what it does / why it helps
11:48:53 <rwbarton> mc___: no, identifiers beginning with capital letters are data constructors, they just hold data.
11:48:58 <jsn> sheijk: i came across it in devising a document format like markdown
11:49:17 <mc___> rwbarton: alright, thank you
11:49:42 <jsn> sheijk: i want that pattern to be valid as indentation, because the slightly outdented attribution is nice
11:50:00 <tromp_> rwbarton, can you see a way to fix http://hpaste.org/11393#a1 ?
11:50:41 <jsn> sheijk: and that is the major use for it
11:52:11 <jsn> i think at that point, i realized, slight outdent is meaningful but i don't know a good way to parse it
11:53:19 <rwbarton> tromp_: I really suggest ScopedTypeVariables
11:53:41 <tromp_> how to set those from ghci?
11:54:01 <vixey> :set -XScoopyTypeVariables
11:54:24 <rwbarton> Well, what you really want to do is turn it on for your source file
11:54:33 <rwbarton> by adding {-# LANGUAGE ScopedTypeVariables #-} as the top line
11:54:36 <jsn> sheijk: sorry if i'm not able to clarify it for you -- the examples i've made are mostly for my own benefit, to explain the method, not the motivation
11:54:46 <byorgey> scoopy type variables?
11:54:56 <rwbarton> *Scooby?
11:54:58 <rog_> i'm enjoying using HList, in principle, but the error messages can get quite... interesting. here's an example of a single message: http://hpaste.org/11397#a0 :-)
11:54:58 <vixey> actuall you just put it all in .ghci
11:54:59 <byorgey> is this a new feature in ghc 6.10?
11:55:02 <sheijk> jsn: i'm just having a look at markdown. wait a moment :)
11:55:04 <tromp_> just after module Go where ?
11:55:09 <tromp_> or even before?
11:55:18 <rwbarton> top line
11:55:33 <vixey> the suggested fix is amusing
11:55:35 <byorgey> or *Snoopy, perhaps
11:56:13 <rwbarton> vixey: yeah I was just thinking that :)
11:58:05 <rog_> actually, that's a relatively simple one.
12:00:58 <sheijk> jsn: hm, k. for markup it might work out. however i still think it is a bit problematic to require humans to look ahead to see the meaning of the indent
12:03:36 <jsn> then you should ensure you only look ahead one paragraph, for example
12:04:09 <jsn> there is a definite danger in overuse
12:04:40 <jsn> however, i have a nice collection of cases where i want to use it
12:04:58 <jsn> and i'm not the only person who needs an indentation library, so...
12:06:58 <seydar> is there any list of keystrokes for yi? how can i see a keymap?
12:08:02 <jsn> sheijk: okay, i have a practical example
12:08:10 <jsn> sheijk: haskell
12:09:10 <jsn> http://hpaste.org/11399
12:09:30 <jsn> it is common to write where with partial outdent
12:10:15 <maltem> seydar: the keymap is user-defined, you don't have any keys (...) in a non-customized yi
12:10:18 <tromp_> thanks for the help, rwbarton et al.
12:10:40 <rockastop> hi, I just started learning haskell and I'm attempting to map characters in a file to coordinates.  I have a solution but I'm looking for input and (constructive) criticism on it.  I have a better description of the problem and my solution at http://hpaste.org/11398  Any help would be greatly appreciated
12:10:49 <jsn> sheijk: so it's not *so* crazy
12:10:52 <tromp_> my new Go code is at http://www.cwi.nl/~tromp/go/Go.hs
12:11:08 <maltem> seydar: the vim-like and emacs-like keymaps, one of which you're likely to use, are at least in the source tree
12:11:30 <sheijk> jsn: hm, where is actually a useful case, k
12:13:12 <maltem> btw homework in basic logic and set theory is stupid... depending on your mood your deduction fills a line or a page
12:16:42 <Botje> rockastop: people would put the parseLines' in a where block
12:16:48 <Botje> parseLines = parseLines' 0 where ...
12:16:58 <rockastop> ah ok
12:17:01 <Botje> so others can't call parseLines' by accident
12:17:08 <rockastop> makes sense
12:17:41 <Botje> i'd use pattern matching instead of fst and second
12:18:06 <Botje> so: [ ((w,y), z) | (w,z) <- zip [0..] line ]
12:18:42 <rockastop> oh right I forgot you could do that.. durr
12:18:45 <rockastop> anything else?
12:19:12 <Botje> i'd try to write it as a concatmap
12:19:17 <Botje> but i'm not sure if it'd come out better
12:19:29 <rockastop> ok
12:19:32 <rockastop> I'll look into that
12:19:35 <rockastop> thanks
12:20:06 <Botje> [ (w,y) , z) | (y,line) <- zip [0..] rest, (w,z) <- zip [0..] line ]
12:20:17 <Botje> maybe
12:20:36 <rwbarton> [ ((row, col), char) | (row, line) <- zip [0..] doc, (col, char) <- zip [0..] line ]
12:23:14 <rockastop> that's better looking
12:23:20 <rockastop> I'll play around with those
12:23:22 <rockastop> thanks for the input
12:27:39 <FrozenTomato> say  i have a list [1,2,3] and a list [3,4] .. how can i remove the second list from the first one
12:28:01 <FrozenTomato> [1,2,3] operation [3,4]  would be 1,2
12:28:23 <sjanssen> Data.List.//
12:28:33 <FrozenTomato> ?
12:28:45 <FrozenTomato> oh
12:28:48 <FrozenTomato> ah!!
12:28:48 <FrozenTomato> thanks
12:29:09 <FrozenTomato> exactly what i was looking for
12:31:30 <maltem> even though it's (\\)
12:31:54 <maltem> :)
12:33:09 <SamB_XP> hehehehe
12:33:40 <sjanssen> oh, // is array update
12:34:06 <sjanssen> that really ought to be a function rather than an operator, in my opinion
12:34:35 <SamB_XP> how so ?
12:40:50 <sjanssen> SamB_XP: I'd be able to remember Data.List.difference, but clearly I can't remember an operator name
12:41:16 <SamB_XP> it would probably have been \ if that wasn
12:41:19 <SamB_XP> 't used for lambda
12:50:01 <aeolist> my friends! the lurker king has a question about ghc: does it identify pure functions and apply specific optimisations on them?
12:51:24 <SamB_XP> aeolist: no ... it just does the optimizations
12:52:07 <aeolist> ok, so are all the functions you declare in haskell side-effects free? everything is pure and the rest is monads right?
12:52:33 <SamB_XP> well ... if you forget about unsafe*, yes ;-P
12:53:06 <aeolist> unsafe in what sense?
12:53:24 <roconnor> @hoogle unsafe
12:53:25 <lambdabot> module Data.ByteString.Unsafe
12:53:25 <lambdabot> module System.IO.Unsafe
12:53:25 <lambdabot> Language.Haskell.TH Unsafe :: Safety
12:53:30 <SamB_XP> there are functions whose names begin with unsafe
12:53:36 <roconnor> @hoogle unsafePerformIO
12:53:36 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:53:36 <SamB_XP> such as unsafePerformIO
12:53:36 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:53:46 <roconnor> @hoogle unsafeCast
12:53:46 <lambdabot> No results found
12:53:57 <aeolist> aha
12:54:43 <rwbarton> One factor contributing to their unsafeness is exactly that the compiler will tend to apply optimizations to them as though they were pure, as you said
12:55:04 <u_quark> aeolist: haskell is not *realy* side-effect free ... it's just that side-effects are not in the language e.g. you cannot express an assignment
12:55:30 <u_quark> but you can call arbitrary C functions that do whatever they want...
12:55:32 <Philippa_> u_quark: you want to be careful about words like "really", that gets a little philosophical :-)
12:55:49 <u_quark> Philippa_: LOL yes!
12:56:05 <Philippa_> *nod* - but in doing whatever they want, they often break the entire semantics of the language
12:56:15 <Philippa_> when Haskell says "unsafe", it doesn't just mean nasal demons
12:56:24 <aeolist> u_quark: you werent this articulate in our private chat, you noob
12:56:25 <Philippa_> it means the entire universe will no longer make sense...
12:56:49 <qwr> (it never did)
12:57:09 <Philippa_> well, Haskell's idea of "universe" :-)
12:57:13 <atenea> hi all , i have this datatype data Sec a = Unit a | Nounit (Sec a) a  and i need to make a concat function , anyone can help me please ?
12:57:45 <mattam> Is non-termination an effect? Now we're getting philosophical.
12:57:51 <SamB_XP> Philippa_: I thought we hadn't a semantics anymore anyway?
12:58:26 <mopped> get n l         = last (take n l) <-- How can I make that work using the 'currying' method (the one with the .)!
12:58:31 <Philippa_> SamB: we don't have a formal one. There's an informal equational one you can kludge together from what's in the report
12:59:17 <yitz> atenea: that looks a lot like a non-null list. is that what you mean?
12:59:33 <atenea> yitz, yes
12:59:34 <mattam> Isn't some DCPO denotational semantics applicable to Haskell 98
12:59:41 <PsVSpieler_> Sucht jemand eine bande?
12:59:56 <mattam> ? (or is it just purposedly not said in the standard?)
12:59:58 <HerrSchnapps> hi, why is it that I have a function that gives me a list like so: [ [1,2,3],[10,2,4] ], cannot be used for the following: map (\ list -> (sum list) / (fromIntegral $ length list) ) value?
13:00:08 <atenea> yitz, a kind of list with no empty list
13:00:33 <yitz> @src concat
13:00:33 <lambdabot> concat = foldr (++) []
13:00:40 <rwbarton> > map (\ list -> (sum list)  / (fromIntegral $ length list) ) [ [1,2,3],[10,2,4] ]
13:00:41 <lambdabot>   [2.0,5.333333333333333]
13:00:46 <yitz> atenea: so all you need is ++
13:01:03 <yitz> (you'll call it something else of course)
13:01:05 <HerrSchnapps> except it won't accept map (\ list -> (sum list) / (fromIntegral $ length list) ) value
13:01:21 <HerrSchnapps> where value is [ [1,2,3],[4,5,6] ]
13:01:26 <atenea> yitz, but it's a secuence not a list
13:01:31 <rwbarton> HerrSchnapps: perhaps it is a list of Integers, or some other non-Fractional instance?
13:01:50 <atenea> ++ is a operator for concat lists
13:02:03 <yitz> atenea: a rose by any other name smells as sweet (or however it goes)
13:02:09 <Cale> HerrSchnapps: remember to do the numeric conversion in the numerator as well.
13:02:10 <HerrSchnapps> the function that creates the list outputs Ints...
13:02:42 <yitz> @src (++)
13:02:43 <lambdabot> []     ++ ys = ys
13:02:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:02:43 <lambdabot> -- OR
13:02:43 <lambdabot> xs ++ ys = foldr (:) ys xs
13:02:53 <Cale> HerrSchnapps: you're converting the length to a fractional type using fromIntegral, but you can't forget to convert the sum as well, before dividing.
13:03:04 <HerrSchnapps> ahh
13:03:21 <SamB_XP> Cale: can't or shouldn't ?
13:03:21 <yitz> atenea: try adapting one of those two definitions
13:03:49 <atenea> yitz, ok thanks , i'll try :)
13:03:55 <yitz> atenea: the second one doesn't mention the empty list :)
13:04:25 <atenea> ok ;)
13:04:39 <Cale> SamB_XP: that depends, but in this case, can't.
13:04:56 <Cale> SamB_XP: Because he wants to pass a list of Int values to it.
13:05:03 <FrozenTomato> is there a simple way to sort a list descending?
13:05:14 <Cale> FrozenTomato: sortBy (flip compare)
13:05:38 <yitz> atenea: for your lists, (:) is called Nounit (and its arguments are reversed).
13:05:39 <FrozenTomato> interesting..thank you
13:05:56 <Philippa_> mattam: there isn't one given, and I don't know if the report is sufficiently well-specified to give one that covers all valid implementations
13:05:58 <SamB_XP> @type compare
13:05:59 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:06:08 <SamB_XP> is Ordering a Monoid yet ?
13:06:26 <dobblego> > LT `mappend` GT
13:06:27 <lambdabot>   LT
13:06:35 <SamB_XP> cool
13:06:41 <mopped> Can anyone explain with flip does?
13:06:49 <SamB_XP> @src flip
13:06:49 <lambdabot> flip f x y = f y x
13:07:06 <Deewiant> > subtract 3 5
13:07:07 <lambdabot>   2
13:07:08 <Deewiant> > flip subtract 3 5
13:07:10 <lambdabot>   -2
13:07:12 <atenea> yitz, sorry i'm beggining
13:07:23 <yitz> > flip (:) [3..5] 7
13:07:24 <lambdabot>   [7,3,4,5]
13:07:49 <SamB_XP> hehehe topic fusion
13:07:55 <mopped> ok, and where is it useful? rearranging arguments doesnt seem that great :P
13:08:19 <yitz> @src reverse
13:08:20 <lambdabot> reverse = foldl (flip (:)) []
13:08:21 <dobblego> > let reverse' = foldl (flip (:)) [] in reverse' [1..5]
13:08:22 <lambdabot>   [5,4,3,2,1]
13:08:24 <Deewiant> it's useful when you can say "flip f" instead of "\a b -> f b a"
13:08:26 <SamB_XP> mopped: well, if you reverse the arguments to a comparison function it compares backwards ;-)
13:08:32 <SamB_XP> so you can use it to sort a list backwards
13:09:54 <SamB_XP> :t (compare `on` fst) `mplus` (flip compare `on` snd)
13:09:55 <lambdabot> forall a b. (MonadPlus ((->) (a, b)), Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
13:10:02 <SamB_XP> :t (compare `on` fst) `mconcat` (flip compare `on` snd)
13:10:03 <lambdabot>     Couldn't match expected type `[a]'
13:10:03 <lambdabot>            against inferred type `(a1, b) -> (a1, b) -> Ordering'
13:10:03 <lambdabot>     In the first argument of `mconcat', namely `(compare `on` fst)'
13:10:22 <SamB_XP> :t (compare `on` fst) `mappend` (flip compare `on` snd)
13:10:23 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
13:10:26 <mopped> that type statement may aswell be gobblety-gook to me :P
13:10:39 <SamB_XP> mopped: I was just musing to myself mostly
13:10:43 <agcorona> just a question:
13:11:06 <SamB_XP> wondering if I could use Monoid to build up comparison functions from pieces
13:11:37 <mathijs> Hi all, I'm just learning Haskell and I'm trying to understand the type system and type classes. I noticed :t (/) gives (Fractional a) => a -> a -> a, say I want to create my_div and mandate the input is Int/Integer and the output is Fractional? what would be the type declaration?
13:12:08 <agcorona> It is possble to read keys pressed without waiting for the enter key?
13:12:55 <rwbarton> mathijs: perhaps my_div :: (Integral a, Fractional b) => a -> a -> b
13:12:57 <yitz> > let a f g = Just $ g f 52 10; back = subtract in do a back flip
13:12:58 <lambdabot>   Just 42
13:14:21 <Deewiant> :-P
13:15:54 <fophillips> Is there a more sensible way to find the largest difference consecutive numbers in a list other than iterating through the whole list.
13:16:11 <Heffalump> fophillips: how could you possibly do it without iterating?
13:16:26 <fophillips> That is what I thought.
13:16:38 <Heffalump> well, just because you need to inspect the whole list to know the answer
13:16:51 <Heffalump> \xs -> max $ zipWith (-) xs (tail xs)
13:16:55 <yitz> fophillips: of course, there are a lot of ways to iterate through a list.
13:17:00 <Heffalump> perhaps with an abs in there
13:18:59 <yitz> > max . map abs . (zipWith subtract `ap` tail) $ [1,2,4,7,11]
13:19:00 <lambdabot>       Overlapping instances for Show ([a] -> [a])
13:19:00 <lambdabot>        arising from a use o...
13:19:06 <yitz> awww
13:20:24 <mathijs> rwbarton: I tried that, just reverted to my_div x = x at the moment, I get an error about not being able to match type b against type a
13:20:37 <mopped> Can anyone explain $ to me? if f $ x = f x, what's the point? :P
13:20:48 <Heffalump> mopped: different precedence and associativity
13:21:00 <agcorona> It is possble to read keys pressed in from the console without waiting for the enter key?
13:21:21 <mopped> can you elaborate a bit Heffalump?
13:21:24 <yitz> mopped: it allows you to omit parens sometimes
13:21:39 <sebaseba> agcorona: getChar?
13:21:50 <byorgey> agcorona: yes, I think you can just turn off input buffering
13:21:52 <Heffalump> mopped: f $ g $ h x = f (g (h x ))
13:21:53 <agcorona> no
13:21:57 <byorgey> hSetBuffering stdin NoBuffering
13:22:04 <rwbarton> mathijs: If you give a definition that doesn't match the type you specify in a type signature, then it won't compile :)
13:22:09 <agcorona> input buffering does not work too
13:22:12 <byorgey> oh
13:22:26 <byorgey> well, there is definitely a way to do it
13:22:32 <rwbarton> mathijs: if you want a placeholder, a good one is  my_div = undefined
13:22:33 <byorgey> darcs does it, for example =)
13:22:45 <byorgey> (but I don't recommend looking at the darcs source to figure out how...)
13:22:46 <yitz> mopped: it's also useful for applying a list of functions
13:23:03 <byorgey> agcorona: did you try searching on the wiki?
13:23:12 <yitz> > map ($ pi/3) [sin, cos, tan]
13:23:13 <lambdabot>   [0.8660254037844386,0.5000000000000001,1.7320508075688767]
13:23:15 <agcorona> yes , I did
13:23:30 <mopped> hmm
13:23:31 <mopped> ok
13:23:40 <agcorona> I tough that whas a matter of buffering but this does not work
13:23:45 <mathijs> rwbarton: well, I don't really want a placeholder, I just want to make sure the arguments are Int, why? just for learning, it's no use :)
13:23:56 <mopped> How about the '.' operator? whenever I try to use it instead of parens I just get a type error, is there special circumstances
13:24:09 <yitz> @type (.)
13:24:10 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:24:14 <vixey> mopped: . isn't parens
13:24:31 <mathijs> rwbarton: so I want my_div x y = x / y , only by mandating x and y to be integers and the result to be fractional
13:24:54 <rherrmann> agcorona: this is more of an OS question, not a language question ... are you on *NIX ?
13:25:13 <mopped> is it used soley in currying then vixey?
13:25:18 <geezusfreeek> mopped, (.) allows you to compose functions directly, without explicitly threading in arguments. \x -> f (g x) vs. f . g
13:25:19 <vixey> no
13:25:35 <agcorona> rherrmann:  I use Ubuntu
13:25:50 <geezusfreeek> *without explicitly passing in arguments
13:25:53 <rwbarton> mathijs: you'll need to use fromIntegral
13:25:55 <rwbarton> :t fromIntegral
13:25:56 <yitz> > let FtoC = (* 5) . (/ 9) . subtract 32 in FtoC 68
13:25:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:25:57 <lambdabot>   Not in scope: data constructor `FtoC'Not in scope: data constructor `FtoC'
13:26:17 <mopped> > head (init [1..5])
13:26:18 <yitz> > let fToC = (* 5) . (/ 9) . subtract 32 in fToC 68
13:26:19 <rherrmann> agcorona: You could use the bindings to the curses library
13:26:19 <lambdabot>   1
13:26:20 <lambdabot>   20.0
13:26:31 <mopped> > last (init [1..5])
13:26:33 <lambdabot>   4
13:26:37 <mopped> >last . init [1..5]
13:26:39 <mathijs> rwbarton: ah, cool, to... and from... didn't know those, this helps a lot
13:26:43 <mopped> > last . init [1..5]
13:26:44 <geezusfreeek> > (head . init) [1..5]
13:26:45 <lambdabot>   Couldn't match expected type `a -> [a1]'
13:26:46 <lambdabot>   1
13:26:52 <mopped> hmm
13:27:00 <geezusfreeek> > head . init $ [1..5]
13:27:00 <vixey> > (head . init . const [1..5]) ()
13:27:02 <lambdabot>   1
13:27:02 <lambdabot>   1
13:27:16 <agcorona> rherrmann:  this could be a solution
13:27:35 <mopped> > let x = tail . init in x [1..5]
13:27:35 <rherrmann> agcorona: I believe it's cbreak
13:27:37 <lambdabot>   [2,3,4]
13:27:56 <agcorona> rherrmann:  what is that?
13:28:12 <rherrmann> agcorona: take a look at this: http://c-faq.com/osdep/cbreak.html
13:28:17 <agcorona> i used curses almost 20 years ago
13:28:17 <lambdabot> Title: Question 19.1
13:29:06 <rwbarton> mathijs: fromIntegral is part of the definition of the fromIntegral class
13:29:09 <rwbarton> @src Integral
13:29:09 <lambdabot> class  (Real a, Enum a) => Integral a  where
13:29:09 <lambdabot>     quot, rem, div, mod :: a -> a -> a
13:29:09 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
13:29:09 <lambdabot>     toInteger           :: a -> Integer
13:29:23 <rwbarton> Well, that's not exactly true
13:29:26 <rwbarton> @src fromIntegral
13:29:26 <lambdabot> fromIntegral = fromInteger . toInteger
13:29:37 <agcorona> rherrmann:  thaks ;)
13:30:00 <rherrmann> agcorona: let us know if you find a better way
13:31:20 <mathijs> rwbarton: I didn't know about those from and to's I didn't need them because of haskell's default implicit types, but I'm trying to give all my functions the right type declarations and I got errors when I made them to strict. Those typecasters help.
13:31:59 <rwbarton> mathijs: Right.  A literal '3' is secretly 'fromInteger 3'
13:32:18 <agcorona> rherrmann:  curses maybe the easiest option.
13:32:39 <rwbarton> mathijs: (and we don't call them "typecasters" but rather "conversions")
13:33:41 <mathijs> rwbarton: I noticed lambdabot responded to @src, any way I can get this behavior on ghci? I know about :info and :t which are helpful, but viewing the source is nice also.
13:35:32 <rwbarton> mathijs: lambdabot has a basically hand-made database for @src
13:35:55 <rwbarton> mathijs: but you can also look up identifiers in hoogle, follow the links to the documentation and usually there will be links to the source code
13:35:58 <rwbarton> @where hoogle
13:35:59 <lambdabot> http://haskell.org/hoogle
13:36:12 <Baughn> mathijs: For looking up indentifiers, I'd suggest using haskell-mode in emacs
13:36:37 <Baughn>  @src only knows about what's in a manually created database
13:36:49 <mathijs> Baughn: I am using emacs and haskell mode, didn't look into all functionality yet
13:37:27 <Baughn> mathijs: Look into decl-scan-mode
13:38:08 <seydar> uhoh
13:40:37 <Baughn> Hm. For some reason my decl-scan menu has gone missing, though.
13:41:17 <mathijs> Baughn: I found doc-mode
13:41:27 <mathijs> decl-scan isn't here either
13:41:50 <mdmkolbe> What is the "correct" way to change argc/argv in GHC?  (This is needed because I'm wrapping a C library who's initialization function expects to munge argc/argv to remove library specific arguments.)
13:42:49 <mopped> How can I 'cons' two lists such that [1,2] cons [3,4] is [[1,2], [3,4]]
13:43:08 <Cale> mdmkolbe: withArgs
13:43:19 <vixey> mopped, 'cons' x y = [x,y]
13:43:25 <mdmkolbe> @index withArgs
13:43:25 <lambdabot> System.Environment
13:43:30 <yitz> @index withArgs
13:43:31 <lambdabot> System.Environment
13:44:19 <int-e> mopped: [1,2] : [3,4] : [] would work, too
13:44:27 <vixey> > [1,2] : [3,4] : []
13:44:28 <lambdabot>   [[1,2],[3,4]]
13:44:48 <Cale> > (\x y -> [x,y]) [1,2] [3,4]
13:44:49 <lambdabot>   [[1,2],[3,4]]
13:45:09 <vixey> chunks 2 [1..4]
13:45:09 <mdmkolbe> Cale: thanks, not the nicest (since it's reader monad style instead of state monad style that the C library would be most natural with), but I might be able to shoe horn that in to work.
13:45:22 <mopped> hmm
13:45:40 <int-e> > 1 : 2 : []
13:45:42 <lambdabot>   [1,2]
13:46:01 <rwbarton> (Also, 'cons' usually refers to (:))
13:46:25 * mdmkolbe turns of smilies b/c of rwbarton
13:47:09 * rwbarton has done his good deed for the day
13:48:14 <yitz> > takeWhile (not . null) . evalState (sequence . repeat . State . splitAt $ 2) $ [1..4]
13:48:15 <lambdabot>   [[1,2],[3,4]]
13:48:26 <Baughn> mathijs: You need to, in .emacs, add two lines to make it work
13:48:50 <mathijs> Baughn: which 2 lines?
13:48:52 <Baughn> (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
13:48:52 <Baughn> (add-hook 'haskell-mode-hook 'imenu-add-menubar-index)
13:49:38 <Baughn> mathijs: ..actually, that last one didn't work. It's what needs to get called (M-x imenu-...), but.. hmm, let me try again
13:49:43 <mathijs> Baughn: if I type M-x turn-on-haskell-decl-scan it can't find it
13:49:58 <Baughn> mathijs: You don't need to do that
13:50:13 <mathijs> Baughn: it should work just for trying though?
13:50:19 <lilac> is GHC 6.10.1 officially out?
13:50:26 <vixey> 6.11 is out
13:50:41 <Baughn> mathijs: Somewhat. I'm not really sure what's going on here.
13:51:00 <mopped> What's the name of the function that's like break, but breaks when it's false? :P
13:51:07 <Baughn> not break
13:51:11 <vixey> :t breka
13:51:12 <lambdabot> Not in scope: `breka'
13:51:19 <lilac> \f -> break (not . f)
13:51:23 <int-e> > span odd [1,3,5,6,7]
13:51:25 <lambdabot>   ([1,3,5],[6,7])
13:51:31 <int-e> mopped: this?
13:51:37 <mopped> yes, thanks
13:51:47 <lilac> @src break
13:51:47 <lambdabot> break p =  span (not . p)
13:52:07 <vixey> span p = break (not . p)
13:52:24 <mathijs> Baughn: I put those lines in my .emacs, restarted, no errors, so I guess something should be different now?
13:52:32 <atenea> hi all , i have this datatype data Sec a = Unit a | Nounit (Sec a) a  and i need to make a concat function , anyone can help me please ?
13:52:47 <vixey> atenea: You can use recursion,
13:52:49 <Baughn> mathijs: Sorry, as I said, it didn't work
13:52:56 <vixey> atenea: with that there are two cases to do
13:53:01 <vixey> concat (Unit a) xs = ...
13:53:05 <seydar> @src span
13:53:05 <lambdabot> Source not found. I feel much better now.
13:53:08 <vixey> concat (Nounit ys y) xs = ...
13:53:09 <seydar> @src span
13:53:10 <lambdabot> Source not found. You type like i drive.
13:53:12 <Baughn> mathijs: Calling imenu-add-menubar-index manually does, and there are no errors. I don't get it.
13:53:14 <seydar> @src span
13:53:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:53:18 <seydar> @src span
13:53:18 <lambdabot> Source not found. I am sorry.
13:53:22 <atenea> vixey, ok thanks
13:53:26 <mathijs> Baughn: I'll try that first
13:53:28 <seydar> sorry everyone, it says some witty things
13:53:58 <vixey> atenea: actually you may want to split xs into Unit/Nounit cases too
13:54:03 <vixey> to give 4 cases
13:54:05 <vixey> dependens
13:54:20 <int-e> vixey: I suspect you should do the pattern match on the second argument only.
13:54:31 <atenea> mmmmm
13:55:29 <mathijs> Baughn: sorry for being a total noob again :)  I disabled my menu/toolbars in emacs, so how do I get to the Imenu? or in other words: how do I use the haskell-decl-scan feature?
13:55:54 <Baughn> mathijs: Er, you'll need to turn on the menu. :P
13:56:09 <int-e> But it really depends on what 'Sec' means - what is concat Seq (Nounit (Unit 1) 2) (Nounit (Unit 3) 4)?
13:56:09 <Baughn> mathijs: Alternately you could say M-x imenu, but that's not nearly as nice
13:56:14 <rwbarton> mathijs: control-right click maybe
13:56:20 <mopped> > a, b = span odd [2, 4..10]
13:56:21 <lambdabot>   <no location info>: parse error on input `,'
13:56:26 <rwbarton> mathijs: hmm, it doesn't seem to be there
13:56:42 <mathijs> found it
13:56:43 <mopped> > let (a, b) = span odd [2, 4..10] in print a
13:56:44 <lambdabot>   * Exception: "<IO ()>"
13:56:46 <Cale> > let (a,b) = span odd [2,4..10] in a
13:56:48 <lambdabot>   []
13:56:49 <mathijs> ctrl-right-click works
13:56:50 <Cale> > let (a,b) = span odd [2,4..10] in b
13:56:51 <lambdabot>   [2,4,6,8,10]
13:56:59 <mopped> thanks
13:57:03 <atenea> vixey, how can i do the recursive case please ?
13:57:22 <vixey> atenea: did you do the non recursive case already? what is it?
13:57:53 <atenea> i think concat (Unit a) xs = a concat xs
13:58:07 <vixey> you better write:  a `concat` xs
13:58:09 <mathijs> hey, this feature is nice, doc-mode is nice too, for me it works automatically after emacs restart
13:58:19 <vixey> so consider, Unit a `concat` xs = a `concat` xs
13:58:23 <vixey> now what is the type of concat?
13:59:12 <atenea> concat :: Secuence a -> Secuence b -> Secuence c
13:59:32 <vixey> so one problem with the definition is, the right hand side doesn't match with that type
13:59:44 <mopped> http://hpaste.org/11402 Can anyone give me a nudge in the right direction? i'm trying to group all duplicates
13:59:55 <atenea> mmmm
14:00:11 <vixey> mopped: why are you writing  (\g h -> [g, h]) a (pack b)
14:00:41 <mopped> ah, a and b are already lists?
14:00:47 <mathijs> rwbarton: I created this my_div function and the type declaration, works fine, I keep 1 warning though (-Wall):    Warning: Defaulting the following constraint(s) to type `Double'
14:00:50 <mathijs>              `Fractional b' arising from a use of `my_div' at mydiv.hs:10:20-51
14:00:52 <mathijs>     In the first argument of `show', namely
14:00:55 <mathijs>         `(my_div (3 :: Integer) (5 :: Integer))'
14:01:17 <mopped> my bad, thanks vixey :p
14:01:45 <atenea> vixey, then how can i make this ? i got lost at all
14:01:45 <rwbarton> mopped: hmm?
14:01:56 <rwbarton> mopped: there's little point in writing
14:02:07 <mathijs> rwbarton: I know Double is a Fractional type so I understand why it is chosen, (well, Float would be fine too?), but how do I get rid of the warning?
14:02:16 <rwbarton> mopped: (\x y -> <some expression containing x and y each exactly once>) x0 y0
14:02:47 <rwbarton> mathijs: You can write  (my_div (3 :: Integer) (5 :: Integer) :: Double)
14:02:57 <rwbarton> mopped: because you can always just substitute in x0 and y0
14:03:14 <mopped> hmm, true :P
14:03:25 <roconnor> What source code for the showsPrec function is generated by deriving Show?
14:03:28 <mopped> I guess grab could just be span (==c) l aswell?
14:03:36 <roconnor> is it in the Haskell 98 report?
14:03:48 <rwbarton> roconnor: should be
14:04:27 <mathijs> rwbarton: yeah, but I don't want to force double, float is fine too, (remember this is just for testing the type system), so Fractional is right. Does this mean I will always get warnings when using -Wall and not be strict about types?
14:04:54 <roconnor> ah chapter 10
14:05:16 <vixey> mathijs: don't use -Wall
14:05:28 <roconnor> app_prec
14:05:34 <rwbarton> mathijs: when -Wall is on, you'll get a warning whenever the compiler chose a type for you based on some class constraints
14:05:34 <vixey> mathijs: it's silly, type errors are much better than -Wall
14:05:35 <roconnor> > app_prec
14:05:36 <lambdabot>   Not in scope: `app_prec'
14:05:49 <roconnor> app_prec = 10
14:05:56 <rwbarton> mathijs: there are only a limited number of situations in which it can do this anyway
14:06:00 <vixey> atenea: You should have same idea what concat does
14:06:08 <roconnor> > showParen
14:06:09 <lambdabot>       Overlapping instances for Show (Bool -> ShowS -> String -> String)
14:06:09 <lambdabot>     ...
14:06:14 <adekoba> Hullo. I've run `cabal upgrade`, and it reports that a HUnit "requires base ==4.*". I'm gussing base-4 comes with ghc-6.10, so how would I go about upgrading my packages without having to install ghc-6.10
14:06:21 <roconnor> @type showParen
14:06:22 <lambdabot> Bool -> ShowS -> String -> String
14:06:49 <atenea> vixey, concat :: Secuence a -> Unit b -> Secuence c ?
14:06:49 <mathijs> rwbarton: ok, so I should either not use -Wall or be very strict about what types I expect. nice for trying stuff out though.
14:07:16 <vixey> atenea: no that's illegal
14:07:21 <roconnor> @src showString
14:07:21 <lambdabot> Source not found. I feel much better now.
14:07:32 <roconnor> @type showString
14:07:33 <lambdabot> String -> String -> String
14:08:29 <Baughn> mathijs: Problem solved
14:08:55 <mathijs> Baughn: what was it?
14:09:12 <Baughn> mathijs: You must *not* have a call to turn-on-haskell-decl-scan
14:09:13 <int-e> adekoba: hum. install 1.2.0.1 or wait for the 1.2.0.3 release which - looking at the darcs version - will fix that
14:09:22 <mathijs> Baughn: that's all ?
14:09:28 <Baughn> mathijs: Well, almost. Let me paste
14:09:40 <Baughn> mathijs: http://rafb.net/p/wBpLOD83.html
14:09:45 <lambdabot> Title: Nopaste - No description
14:09:58 <Baughn> That's my exact code. Adapt as appropriate.
14:10:18 <Baughn> mathijs: ..of course, you still need to have menus on.
14:10:29 <adekoba> int-e: right. In the meantime, however, I'm unable to upgrade other packages because cabal will fail when it realizes HUnit won't install. Is there a way to fix this?
14:11:08 <mathijs> Baughn: damn, osX as well, well it's great to see mac users use emacs too, in the ruby-community everyone is on textmate so I'm lonely on emacs :)
14:11:14 <Baughn> mathijs: Also, decl-scan does not grok hierarchical imports. It must be *old*.. well, I wasn't going to use that anyway, btu...
14:11:21 <mathijs> Baughn: menu's are no problem, ctrl-right-click works
14:11:25 <int-e> adekoba: pass -constraint "HUnit == 1.2.0.1" to cabal? (I hope I got the syntax correct)
14:11:54 <adekoba> int-e: unrecognized option `-constraint'
14:12:17 <int-e> adekoba: cabal install --constraint "..." hmm. I wonder how recent that feature is
14:12:39 <dcoutts> int-e: sadly does not work yet
14:12:45 <dcoutts> but it will do soon
14:12:48 <int-e> dcoutts: oh.
14:12:57 <dcoutts> int-e: the constraint is currently only used by configure
14:13:03 <dcoutts> but I'm going to unify the two
14:13:18 <int-e> ah, it should ... ok, you probably have a hackage report for that already.
14:13:34 <adekoba> oh well, I can wait. No problem. Thanks, regardless.
14:13:35 <dcoutts> int-e: but you can get mostly the equivalent by just saying "HUnit == 1.2.0.1" as a arg to cabal install
14:13:50 <int-e> dcoutts: it's adekoba's problem :)
14:14:04 <dcoutts> int-e: the only difference is that it makes hunit an install target too, where as --constraint does not make it a target to install
14:14:55 <dcoutts> adekoba: cabal install 'HUnit < 1.2.0.1'
14:15:39 <adekoba> dcoutts: yeah, that works, but I also need to pass --reinstall
14:22:46 <dons> http://www.reddit.com/r/programming/comments/78r6f/xmonad_for_life/ :) yay
14:22:49 <lambdabot> Title: Xmonad for Life! : programming, http://tinyurl.com/6mzl46
14:22:49 <dons> i love happy users
14:23:29 <mathijs> another question: how can I curry the second argument to a function but keep the first one variable?
14:23:43 <dons> flip foo
14:23:45 <dons> :t flip
14:23:46 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
14:24:02 <dons> > (flip map) [1..10] (+1)
14:24:04 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:24:12 <dons> ?src flip
14:24:13 <lambdabot> flip f x y = f y x
14:24:18 <dons> yes, that easy.
14:24:19 <dons> :)
14:24:21 <mathijs> dons: that seems to do the trick
14:24:36 <dons> i challenge people to find something as elegant in another language :)
14:25:07 <rwbarton> also  (`f` y) = \x -> f x y
14:25:15 <mathijs> but on inflix functions there's an easier way, (10/) for example,
14:25:20 <vixey> mathijs, s/curry/partially apply/
14:25:25 <mathijs> rwbarton: yeah, that's inflix-like
14:25:47 <rwbarton> mathijs: right, you can convert an identifier to infix form by wrapping it in ``
14:26:12 <mathijs> vixey: isn't that the same? I thought curry'ing was applying some default arguments?
14:26:27 <vixey> mathijs, different concepts
14:26:44 <vixey> mathijs, currying is turning AxB -> C into A -> (B -> C)
14:27:10 <vixey> it's currying that makes partial application really easy
14:27:15 <mathijs> hrm... then the ruby-community is using it wrongly, also prototype(js) uses another definition.
14:27:30 <camio> I'm having trouble understanding why a simple program is behaving so weird, would anyone care to elighten me? http://hpaste.org/11403
14:27:44 <dons> dcoutts: martin sulzmann's using hackage, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/actor-0.1.1
14:27:45 <lambdabot> Title: HackageDB: actor-0.1.1, http://tinyurl.com/6ld3r7
14:27:50 <dons> dcoutts: win!
14:27:52 <mathijs> vixey: I do remember reading about what you just typed... so many different concepts to wrap my brain around :)
14:28:00 <dcoutts> dons: yay
14:28:23 <dcoutts> dons: are you back now btw? or you're back tomorrow? I expect to get to portland ~4pm Friday
14:28:40 <rwbarton> mathijs: Partial application in those languages is the uncurried form of currying.
14:28:46 <rwbarton> mathijs: It's an understandable confusion :)
14:28:51 <rwbarton> @type uncurry curry
14:28:53 <lambdabot> forall a b c. ((a, b) -> c, a) -> b -> c
14:28:57 <Nafai> dcoutts: I got my switcher utility working with a little FFI magic! :)
14:29:14 <dcoutts> Nafai: sorry, remind me, switcher?
14:29:36 <vixey> :t curry (uncurry curry)
14:29:37 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:29:53 <Nafai> dcoutts: I was writing a replacement for dmenu in gtk2hs, but I couldn't get it to work within xmonad.  I had to call out to gdk_window_setoverride_redirect and a few other things
14:30:04 <dcoutts> Nafai: ahh, right, great
14:30:22 <dcoutts> Nafai: so you've submitted a patch to gtk2hs to bind this function I presume ;-)
14:30:25 <mopped> Is there a repeat function or something? like repeat 5 1 = [1,1,1,1,1]
14:30:45 <Nafai> dcoutts: Heh, not yet :(
14:31:05 <wjt> > replicate 5 1
14:31:07 <lambdabot>   [1,1,1,1,1]
14:31:10 <mopped> thanks
14:31:14 <wjt> . repeat 1
14:31:16 <wjt> > repeat 1
14:31:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:31:21 <mopped> @src replicate
14:31:21 <lambdabot> replicate n x = take n (repeat x)
14:31:26 <mathijs> vixey: thanks, I looked it up in yaht again.
14:31:37 <dcoutts> Nafai: but hopefully you will :-)
14:32:25 <Nafai> I should figure out how to do so
14:32:37 <Nafai> I had to wrap 4 functions
14:33:15 <dblazakis> camio: i don't know, but i'm be curious now too
14:33:30 <camio> dblazakis: Yeah, it's a real weird one.
14:34:47 <camio> dblazakis: The thing that confuses me is (h b). How is that possible?
14:36:43 <camio> http://hpaste.org/11403#a2 <- here's another version simplifying the problem to one of laziness. Arrows on (->) is more lazy than Functor on (() t).
14:37:15 <mopped> http://hpaste.org/11404 Can anyone explain the error messagen why is it occuring? :P
14:37:39 <vixey> :t replicate
14:37:40 <lambdabot> forall a. Int -> a -> [a]
14:37:51 <vixey>                         helper (Single x)       = x
14:37:51 <vixey>                         helper (Multiple n x)   = replicate n x
14:37:57 <vixey> see what is happening here?
14:38:00 <mopped> [x] perhaps?
14:38:12 <vixey> x :: n
14:38:16 <vixey> replicate n x :: [n]
14:38:23 <mopped> yeah
14:38:25 <vixey> sorry
14:38:27 <vixey> x :: t
14:38:29 <vixey> replicate n x :: [t]
14:38:31 <mopped> need to get used to lists only containing one type :P
14:38:49 <vixey> and since thes are both the same definition it must unify t = [t]
14:39:05 <dblazakis> camio: what does the tilde do?
14:39:31 <dblazakis> camio: notice "const 6" doesn't cause the evaluation
14:39:41 <camio> dblazakis: Makes a function non-strict with pattern matching.
14:40:08 <dblazakis> camio: ahhh i see
14:40:34 <camio> Oh, I think I understand now.
14:40:51 <camio> So z returns a (lazy a, lazy b)
14:40:59 <camio> So h can match on that.
14:41:06 <bbs> 4
14:41:08 <bbs> sry sry
14:41:09 <bbs> :/
14:41:28 <camio> And since h doesn't use a or b, it returns no error.
14:41:54 <camio> So fmap is strict and second is not.
14:43:36 <dblazakis> where is fmap on tuples defined, i can't seem to find it
14:43:56 <camio> Control.Monad.Instances maybe?
14:44:32 <camio> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/src/Control-Monad-Instances.html
14:44:37 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5eh86r
14:45:00 <camio> So indeed Functor on tuples is strict.
14:45:02 <dblazakis> yep
14:45:06 <camio> Same with Either.
14:46:15 <camio> I wonder why that choice was made.
14:46:28 <dblazakis> camio: and second on Arrow (->) is nonstrict http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Arrow.html -- as you said
14:46:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/62bzdg
14:46:59 * camio runs to dinner
15:02:48 <kamaji> is there a nicer way to do this: take (div (length s) 2) s -- where s is a set
15:03:07 <vixey> halve s
15:03:18 <kamaji> (I just started playing with haskell again for fun after being forced to do it last year)
15:03:27 <kamaji> vixey: thanks :)
15:03:32 <vixey> halve s = take (length s `div` 2) s
15:03:40 <tromp_> in a list comprehension, is there a better way to filter patterns than [...|... (Just i) <- [somemaybe]... ] ?
15:03:53 <vixey> :t isJust
15:03:55 <lambdabot> forall a. Maybe a -> Bool
15:04:00 <vixey> ..., isJust somemaybe, ...
15:04:00 <int-e> :t catMaybes
15:04:02 <lambdabot> forall a. [Maybe a] -> [a]
15:04:16 <tromp_> well, i dont actually have Maybes
15:04:25 <vixey> isNotAMaybe
15:04:33 <tromp_> I have data Color = Empty | Stone Player
15:04:39 <int-e> tromp_: no, probably not, unless you want to define your own predicate for the purpose
15:04:54 <tromp_> and I want to filter out the (Stone p)
15:05:08 <tromp_> ok, thx
15:07:57 <mathijs> is there a function for "foldr (+) 0 xs" ? and if so, how can I find out these things myself (using hoogle or something?)
15:08:02 <vixey> sum
15:08:06 <mathijs> ah
15:08:11 <mathijs> sounds logical :)
15:08:14 <rwbarton> @hoogle (Num a) => [a] -> a
15:08:14 <lambdabot> Prelude product :: Num a => [a] -> a
15:08:14 <lambdabot> Prelude sum :: Num a => [a] -> a
15:08:14 <lambdabot> Data.List product :: Num a => [a] -> a
15:08:25 <kamaji> mathijs: http://www.zvon.org/other/haskell/Outputglobal/index.html
15:08:25 <lambdabot> Title: Haskell
15:08:32 <kamaji> mathijs: that's what I use, I don't know if you've seen it
15:08:45 <yitz> atenea: still around?
15:08:59 <atenea> yitz, yes with soooo headache :_(
15:09:07 <mathijs> kamaji: it's nice, bookmarked
15:09:22 <yitz> sorry. I was away from the kbd for awhile.
15:09:43 <atenea> no problem yitz , thank you for help me
15:10:14 <yitz> hope your headache will be better soon :)
15:10:36 <yitz> atenea: did you finish your problems?
15:10:52 <atenea> nope
15:11:04 <yitz> rrr
15:11:24 <atenea> yitz, it's my first year in declarative programming using curry
15:11:35 <atenea> mi first month
15:11:52 <atenea> there is no doc in my language
15:12:10 <vixey> yes there is
15:12:11 <atenea> then i'm reading haskell papers to learn
15:12:32 <atenea> vixey, there is no curry report in spanisj
15:12:36 <atenea> *spanish
15:12:50 <vixey> it's in english
15:13:46 <yitz> atenea: have you tried #haskell.es ?
15:36:02 <mathijs> can't find another one... average (as in sum / length), I'm sure there has to be a function for this somewhere
15:36:14 <vixey> :t liftA2 (/) sum length
15:36:15 <lambdabot>     No instance for (Fractional Int)
15:36:15 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
15:36:15 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
15:36:29 <vixey> @let haskellSucksLength = foldr (const (+1)) 0
15:36:30 <lambdabot>  Defined.
15:36:33 <vixey> :t liftA2 (/) sum haskellSucksLength
15:36:34 <lambdabot> forall a. (Fractional a) => [a] -> a
15:36:53 <Samy> :t liftA2
15:36:55 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:36:58 <mathijs> interresting :)
15:37:58 <mathijs> tnx
15:38:19 <sjanssen> vixey: genericLength
15:39:09 <idnar> @type genericLength
15:39:10 <lambdabot> forall b i. (Num i) => [b] -> i
15:39:14 <idnar> @type length
15:39:15 <lambdabot> forall a. [a] -> Int
15:39:19 <idnar> ah yes
15:42:58 <Peaker> :t liftA2 (/) sum (fromInteger . length)
15:42:59 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Int'
15:42:59 <lambdabot>       Expected type: [a] -> Integer
15:42:59 <lambdabot>       Inferred type: [a] -> Int
15:43:04 <Peaker> :t liftA2 (/) sum (fromIntegral . length)
15:43:06 <lambdabot> forall b. (Fractional b) => [b] -> b
15:43:11 <vixey> basically haskell type system sucks
15:43:23 <vixey> you can't do a proper number hiererchy
15:43:56 <ddarius> Maybe it's the number hierarchy that sucks.
15:44:32 <vixey> the problem is it's not fixable
15:44:36 <ptolomy2> Converting http://crazybob.org/BeustSequence.java.html to haskell is harder than I initially thought it would be. I forget how confusing 'return' really is.
15:44:37 <lambdabot> Title: BeustSequence.java
15:45:14 <vixey> ptolomy2: make a Java monad out of Cont and so on
15:50:21 <ptolomy2> vixey: Well, the algorithm doesn't necessitate any sort of weird control flow, and I'm aiming to see what sort of performance I can squeeze out using bang patterns and bitwise operations, so I'm hoping to avoid fancy monads.
15:50:46 <nicknull> is a webserver a fairly simple program? i mean of c a simple webserver could be simple but something like apache, is it hard to program? it is a lot of code? i saw a 5-module 100-line webserver written in erlang that was supposedly faster than YAWS but perhaps it was special purpose
15:51:04 <nicknull> is there a websever written in haskell that i can see the code of?
15:51:33 <ptolomy2> nicknull: A webserver is trivial to write, I've done dozens. A good production-quality useful webserver is much harder.
15:52:12 <ptolomy2> There's an old paper on writing a webserver in haskell ("Tacking the Awkward Squad", I believe), but I'm not sure if it is considered out-dated.
15:54:06 <linolium_> does anyone have an idea of what's wrong with this code? Couldn't match expected type `t -> t1 -> Bool' against inferred type `Bool'
15:54:17 <mauke> missing parens?
15:54:24 <qebab> seems likely
15:54:28 <linolium_> in this code: ((Data.Map.findWithDefault 0 next hash) > 0) or (curKeys < keys)
15:54:38 <mauke> linolium_: 'or'
15:54:43 <qebab> :t or
15:54:44 <lambdabot> [Bool] -> Bool
15:54:47 <linolium_> ??
15:54:54 <linolium_> or takes a list?
15:54:56 <mauke> yes
15:54:59 <linolium> oh my
15:55:01 <qebab> linolium: that's what it says
15:55:06 <qebab> linolium: try ||
15:55:11 <linolium> oh, ok
15:55:15 <linolium> I find it hard to read these errors
15:55:18 <linolium> I'm gonna have to work on that
15:55:18 <mauke> Data.Map.findWithDefault 0 next hash > 0 || curKeys < keys
15:55:39 <qebab> linolium: everyone does, in the start. you'll learn to recognize most after a while
15:55:48 <linolium> mauke: thanks
15:55:54 <linolium> qebab: hopefully
15:56:04 <mauke> @src or
15:56:04 <lambdabot> or    =  foldr (||) False
15:56:18 <linolium> ah, neat
15:59:18 <Botje> @pl \(i,e) -> e >>= \f -> (i,f)
15:59:18 <lambdabot> uncurry ((=<<) . (,))
15:59:23 <Botje> cute
16:07:08 <EvilTerran> ?type \(i,e) -> e >>= \f -> (i,f)
16:07:10 <lambdabot> forall t a. (Monad ((,) t)) => (t, (t, a)) -> (t, a)
16:07:23 <EvilTerran> o.ó
16:07:58 <EvilTerran> ?type \x@(_,_) -> join x
16:07:59 <lambdabot> forall t a. (Monad ((,) t)) => (t, (t, a)) -> (t, a)
16:08:09 <linolium> what does this mean: Couldn't match expected type `Int -> Int -> Int -> Map Char Int -> Int' against inferred type `Int'
16:08:16 <EvilTerran> Botje, what about that?
16:08:45 <mauke> linolium: you've used something of type 'Int' in a context that demands an 'Int -> Int -> Int -> Map Char Int -> Int'
16:08:51 <mauke> I'd blame the context
16:08:56 <EvilTerran> it may have different behaviour, actually...
16:09:05 <linolium> mauke: I'm just calling a recursive function with a crap load of parameters
16:09:15 <linolium> mauke: it returns one Int number in the end
16:09:43 <EvilTerran> , join ("123",("abc",()))
16:09:46 <lunabot>  luna: No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
16:09:50 <EvilTerran> er?
16:10:11 <EvilTerran> i thought that was anonymous writer
16:10:26 <EvilTerran> or implicit writer or whatever people call it. the (w,) monad.
16:20:09 <Peaker> EvilTerran: doesn't it need to a Monoid for it to be (w,) ?
16:20:17 <Peaker> oh wait, a string is a monoid
16:20:28 <Peaker> > "hello" `mappend` "goodbye"
16:20:29 <lambdabot>   "hellogoodbye"
16:21:15 <EvilTerran> yeah
16:21:22 <EvilTerran> the instance seems to've quietly disappeared
16:21:31 <EvilTerran> ?instances-importing Control.Monad.Instances Monad
16:21:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:21:37 <EvilTerran> hmm
16:22:59 <Peaker> Well, (->) r and Reader r are two separate monads, so I guess (,) w and Writer w are also two separate monads
16:23:19 <EvilTerran> indeed
16:23:33 <EvilTerran> but there's ((->) r) and Reader r, but only Writer w
16:23:38 <EvilTerran> ?src Writer
16:23:38 <lambdabot> Source not found. There are some things that I just don't know.
16:24:34 <dobblego> @src Reader
16:24:34 <lambdabot> Source not found. Maybe you made a typo?
16:26:41 <mathijs> tnx 2 all for helping, I learned quite a bit today
16:30:44 <rwbarton> , src ''Writer
16:30:56 <lunabot>  newtype Writer w a = Writer {runWriter :: ((a, w))}
16:31:54 * clanehin contemplates a monoid instance for (Monad m) => a -> m a
16:32:00 <dolio> Maybe (,) w disappeared accidentally in the move to Control.Monad.Instances?
16:41:07 <lilac> "Maybe ((,) w)" ? :)
16:41:33 <dolio> :P
16:42:35 <ddarius> That's not kind correct.  Maybe ((,) w disappeared)
16:48:49 <RayNbow> :t mergeByR
16:48:50 <lambdabot> forall a1 a b. (a1 -> a -> Ordering) -> (a1 -> a -> b -> b) -> (a1 -> b -> b) -> (a -> b -> b) -> b -> [a1] -> [a] -> b
16:51:10 <cpfr> dons, i need your PR magick
16:52:16 <RayNbow> > let merge = mergeByR compare (const (:)) (:) (:) []; merge3 as bs cs = merge as (merge bs cs); hammings = 1 : merge3 (map (2*) hammings) (map (3*) hammings) (map (5*) hammings)    in   hammings  -- twanvl, putting your mergeByR to work :)
16:52:17 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
17:13:21 <roconnor> @type lex
17:13:22 <lambdabot> String -> [(String, String)]
17:13:34 <roconnor> lex "Hello World"
17:13:42 <luqui> @free (a,(b,c)) -> ((a,b),c)
17:13:42 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
17:13:42 <roconnor> >lex "Hello World"
17:13:47 <roconnor> > lex "Hello World"
17:13:49 <lambdabot>   [("Hello"," World")]
17:13:55 <luqui> @free f :: (a,(b,c)) -> ((a,b),c)
17:13:56 <lambdabot> $map_Pair ($map_Pair g h) k . f = f . $map_Pair g ($map_Pair h k)
17:13:58 <roconnor> > lex "   Hello World"
17:13:59 <lambdabot>   [("Hello"," World")]
17:14:33 <roconnor> @type readParen
17:14:34 <lambdabot> forall a. Bool -> ReadS a -> String -> [(a, String)]
17:15:36 <roconnor> @src readParen
17:15:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:16:22 <rwbarton> @free f :: (a -> a) -> a -> a
17:16:22 <lambdabot> g . h = k . g => g . f h = f k . g
17:17:57 <roconnor> @free undefined
17:18:02 <lambdabot> f undefined = undefined
17:18:36 <Botje> well spotted, that.
17:23:32 <roconnor> what's the precidence of `foo` by default?
17:23:42 <ddarius> That example makes the assumption that @free makes clear.
17:26:07 <Cale> Offtopic, but hilarious: http://www.youtube.com/watch?v=QnE-YJ---GI
17:26:10 <gwern> 'lo all
17:26:12 <gwern> any news?
17:26:13 <lambdabot> Title: YouTube - McCain Accidentally Agrees with Murtha About Voters in PA
17:27:00 * dolio saw that video. Quite awkward.
17:27:10 <gwern> Cale: 'I couldn't fail to agree with you less!'
17:37:54 <lispy> hey gwern
17:38:05 <lispy> gwern: we may get cabal for darcs
17:38:18 <gwern> so I vaguely heard
17:38:23 <gwern> along with enfranchisement
17:38:29 <roconnor> > lex "`foo`"
17:38:30 <lambdabot>   [("`","foo`")]
17:38:31 * gwern feebly woots
17:38:35 <lispy> er, *en*franchisement?
17:38:41 <lispy> you're missing a dis
17:38:44 <roconnor> grmble
17:38:51 <dcoutts> hah
17:39:00 <gwern> lispy: roundy has backpeadaled on building darcs via franchise?
17:39:23 <lispy> gwern: no, i just think it's stupid to call franchise support enfranchisement
17:39:29 * dcoutts worries that while in principle what darcs is planning with cabal+franchise is possible, nobody has ever tested that it works
17:39:31 * gwern incidentally hopes this latest trend of choosing project names which can be verbed abates - 'enfranchised' would be hell to google for
17:39:38 <lispy> I should write a compatibility layer between franchise and cabal and call it infringe
17:39:44 <dcoutts> heh heh
17:40:08 <gwern> lispy: well, what else would one call it? to give someone a franchise is to... enfranchise them!
17:40:35 <gwern> I may like cabal better, but it's a cute name in some respects
17:40:36 <lispy> gwern: yes, but requiring franchise has the opposite effect on them than enfranchising them
17:40:53 * lispy won't install franchise anytime soon
17:41:06 <lispy> so, if we switch to requiring franchise, I lose the ability to build darcs
17:41:13 <gwern> I have no idea how to install, or use franchise much less where to get it
17:41:23 * lispy nods
17:41:43 <lispy> gwern: if you do get the source, just run the test suite, it has the feature of installing itself...very viral
17:41:44 <luqui> franchise = ?
17:41:59 <lispy> dcoutts: BTW, is there is a way to blacklist packages in cabal-install?
17:42:18 <gwern> anyways I set up a procmail rule to filter darcs emails into their own mailbox, but apparently I don't know how to set up another mailbox in mutt, so I basically haven't read any darcs-related emails in like a month
17:42:25 <gwern> I should probably abandon that rule and catch up
17:42:34 <dcoutts> lispy: not yet, file a feature request
17:42:38 <gwern> luqui: droundy's cabal competitor
17:42:41 <lispy> luqui: franchise is a competetior to cabal that uses an autotools style configuration step.  It's made by droundy for darcs since he's pretty anti-cabal
17:42:42 <Dianora> mutt -f ~/Mail/darcs
17:42:52 <Dianora> or wherever you stored it.
17:42:55 <luqui> ah
17:42:59 <Dianora> yw
17:43:12 <gwern> Dianora: confusingly, that doesn't work
17:43:18 <dcoutts> gwern: you can actually install franchise using cabal-install :-)
17:43:19 <lispy> gwern: haha
17:43:31 <Dianora> gwern: it does. where did it store the mail folder then?
17:43:38 <Dianora> gwern: mutt -f ~/darcs ?
17:43:39 <lispy> dcoutts: okay.  I think it would be a useful feature in general.  Say if you want to avoid upgrading or something.
17:44:01 <gwern> which is one of the things that makes me think maybe I should just abandon my getgmail/ssmtp/promail/mutt setup and just go back to gmail. (it can't be *that* hard to get pgp signing with gmail, no?)
17:44:17 <gwern> Dianora: nah, I used the right location, just mutt sez 'it's not a mailbox'
17:44:30 <lispy> dcoutts: did you see my bug about happy?
17:44:35 <rdmltrs9> hi does anyone know of good source code to look at when trying to learn about threading in Haskell?
17:44:59 <gwern> rdmltrs9: what style of threading? for mvars, look at dons' http linkchecker
17:45:01 <rdmltrs9> i'm trying to find something that uses forkIO in practice rather than just stare at its type signature
17:45:39 <gwern> well, I use forkIO here: https://secure.wikimedia.org/wikipedia/en/wiki/User:Gwern/Archive-bot.hs
17:45:46 <gwern> (first thing that comes to mind)
17:45:46 <lambdabot> http://tinyurl.com/6ll2q9
17:46:09 <gwern> is forkIO that hard to understand?
17:46:21 <gwern> it's bsically the shell '&'
17:46:43 <dcoutts> lispy: I'm not sure I did see your bug about happy, could you remind me? is it filed?
17:46:54 <lispy> dcoutts: it is filed
17:47:06 <dcoutts> lispy: you're right that having persistent constraints on package versions would be useful
17:47:44 <gwern> the only thing I ever found odd about forkIO was that any forkIO'd threads die when the main thread dies
17:47:51 <gwern> that was odd, I sort of thought
17:47:56 <rdmltrs9> i'm trying to learn threads concurrent with learning how threads work in haskell so it's been hard for me to wrap my head around what they mean and how they are used
17:48:02 <dcoutts> lispy: ah yes, I did see it, did you see my comment?
17:48:26 <lispy> dcoutts: I don't know how to find that bug :(
17:48:50 <lispy> I'm not trac sauvy
17:49:26 <dcoutts> lispy: http://hackage.haskell.org/trac/hackage/ticket/375#comment:2
17:49:32 <gwern> rdmltrs9: well try describing what you think it does and how one could use it and maybe someone here will correct you?
17:49:37 <lambdabot> Title: #375 (target bindir should added to the build tool search path) - Hackage - Trac
17:49:39 * Nafai checks out the gtk2hs source code so as to make patches
17:50:28 <lispy> dcoutts: oh, so change my path?
17:50:45 * gwern muses. how would one write a WSYIWG HTML editor in haskell?
17:51:00 <dcoutts> lispy: yep or tell cabal to symlink binaries into ~/bin or somewhere that is on your path
17:51:09 <lispy> dcoutts: hmm...I don't see happy in either ~/bin or ~/lib
17:51:36 <dcoutts> lispy: the default is ~/.cabal/bin because we cannot all easily agree on a better place
17:51:47 <lispy> oh, weird, okay
17:51:58 <lispy> no happy
17:51:59 <EvilTerran> gwern, with gtk2hs?
17:52:02 <lispy> just cabal and haddock
17:52:05 <dcoutts> lispy: some people will scream if I change it to always install to ~/bin/
17:52:17 <gwern> EvilTerran: I dunno, does gtk2hs provide html rendering?
17:52:29 <EvilTerran> ... it *might*...
17:52:39 <dcoutts> lispy: my plan is to have it display what configuration it will use on the first run and tell people how to change it
17:53:07 <lispy> dcoutts: I still can't find happy, not even under ~/.caba/
17:53:09 <gwern> EvilTerran: how would a gui widget toolkit provide html rendering/editing capabilities? seems a bit far afield
17:53:10 <lispy> cabal*
17:53:21 <EvilTerran> an HTML->Glade translator might be relatively straightforward
17:53:36 <EvilTerran> for enough bits and pieces for a WYSIWIG editor, anyway
17:53:51 <lispy> ./.cabal/packages/hackage.haskell.org/happy
17:53:56 <lispy> that's the only happy I have so far
17:54:05 <EvilTerran> i wasn't particularly suggesting it because i expected it to do the HTML rendering for you
17:54:22 <EvilTerran> i don't think there's anything that does anything even similar to html rendering in haskell
17:54:39 <gwern> a pity
17:54:59 <EvilTerran> i meant you'd have to start with something like gtk2hs and do the rendering yourself
17:55:00 <lispy> dcoutts: I really think I don't have happy installed
17:55:29 <gwern> I keep thinking 'there must be some way' but all I can think of is one-way - dump out the edited text to pandoc, pandoc turns it to html, and then you have FF open up the html
17:55:35 <gwern> but that's obviously not really an editor
17:55:55 <lispy> dcoutts: and remember, that error is happening during the install of happy
17:56:54 <dcoutts> lispy: ah, then install happy
17:57:17 <lispy> dcoutts: but, look at the bug ticket.  It's the install of happy that complains happy is not installed
17:57:18 <dcoutts> lispy: that's another ticket, that cabal-install does not track build-tools as dependencies yet
17:57:24 <dcoutts> huh?
17:57:38 <dcoutts> lispy: ah, then someone messed up making that package
17:58:05 <dcoutts> lispy: they forgot to include the pre-processed parser in the package
17:58:34 <lispy> dcoutts: hmm
18:00:58 <lispy> dcoutts: what is your advice?
18:01:20 <dcoutts> lispy: install an older version the 1.17
18:01:56 <lispy> what is the syntax, cabal install happy-1.17
18:02:05 <dcoutts> lispy: that will work
18:02:15 <dcoutts> lispy: --dry-run is your friend in this context
18:02:22 <lispy> too late :)
18:02:41 <dcoutts> lispy: it also works to use dependencies like 'happy < 1.18'
18:02:48 <lispy> awesome
18:02:58 <lispy> yay, I now have happy 1.18
18:03:13 <lispy> and my system is up to date
18:03:19 <lispy> dcoutts: thanks
18:05:21 <lispy> darn, I can't update the ticket
18:06:47 <lispy> dcoutts: there, I added what worked for me and resolved as invalid (not really your bug)
18:18:37 <twb> Does haskell-mode still use CVS?
18:18:49 <twb> My notes say cvs -d :pserver:anoncvs@cvs.haskell.org:/cvs login && cvs -z9 -d:pserver:anoncvs@cvs.haskell.org:/cvs co -d haskell-mode fptools/CONTRIB/haskell-modes/emacs
18:19:28 <Nafai> dcoutts: Is the current gtk2hs darcs buildable?
18:19:54 <twb> Apparently so.  What a pain.
18:28:32 <adu> theres only one thing I think of when I think of CVS
18:28:44 <adu> alias ls='ls --ignore=CVS'
18:37:14 <luqui> adu, wow, that's pretty impressive.  how much therapy did you need before that's the only thing you think of?
18:37:46 <luqui> I think of years of pain and agony...
18:37:58 <luqui> of contacting the administrator to add a directory
18:38:07 <SamB_XP> when I think of CVS I think of how I kept having to restart it in mid-operation because it got stuck ...
18:38:18 <SamB_XP> something to do with low bandwidth, I think ...
18:38:39 <luqui> I think of the painstaking process to find the state of the project at some early date
18:38:42 <adu> luqui: hehe
18:38:50 <SamB_XP> ah, that as well
18:39:07 <adu> luqui: oh, ya I use viewcvs.cgi for that
18:39:11 <luqui> (alas, darcs is not terribly better in that last respect, unfortunately)
18:39:19 <SamB_XP> or at least, the process of getting a working tree state from a patch ...
18:40:07 <adu> I personally thing all these data manipulation cr-apps are an indication that OSs are not doing their jobs
18:40:31 <adu> all OSs should have 4GLs builtin, and DBMSs integrated with the filesystem...
18:41:12 <luqui> adu, folks are idly throwing around ideas that would comprise a purely functional operating system
18:41:35 <adu> luqui: is that what I'm talking about? maybe...
18:41:38 <SamB_XP> they should do it lazily instead
18:41:44 <SamB_XP> idly sounds too imperative to me
18:41:46 <luqui> adu, well, if not, then you should go there.
18:41:58 <luqui> DBMS traditionally are stateful beasts...
18:42:00 <adu> I already like House
18:42:04 <luqui> how do you make them pure and meaningful?
18:42:38 <adu> well, make all tables of type a -> IO b?
18:42:42 <luqui> it might be so easy as:  filesystem :: Time -> Relation
18:42:47 <SamB_XP> that's not very pure
18:42:53 <luqui> adu, IO is not pure and meaningful
18:42:55 <luqui> just pure.
18:42:59 <djsiegel1> gmail.com
18:43:10 <djsiegel1> Haha, oops.
18:43:24 <adu> luqui: thats nice :)
18:43:43 <adu> luqui: which folks are throwing around ideas?
18:44:05 <luqui> mostly conal and everyone who comes in contact with him
18:44:11 <roconnor> IO a = ((a -> IOTree) -> IOTree)
18:44:12 <adu> I want to catch some of those ideas...
18:44:27 <adu> I want to meet this conal you speak of...
18:44:41 * adu gets his idea catcher out of the closet
18:44:45 <luqui> :-)
18:45:02 <luqui> I could start a cafe thread to get some of the ideas out in the open
18:45:04 <roconnor> oh wait, the OS is on the otherside of IO.
18:45:11 <luqui> roconnor, :-)
18:45:14 <Nafai> Any gtk2hs hackers around?  I can't get darcs gtk2hs to compile
18:45:29 <jsn> maybe  (Time, Node) -> Relations
18:45:49 <dcoutts> Nafai: I've not tried it in recent days
18:46:02 <jsn> however, i have to wonder at the trouble you'll have with the time :)
18:46:06 <luqui> roconnor, in fact, that's a great observation.  it can tell us both things the OS should be, and things IOTree should not :-)
18:46:42 <Nafai> dcoutts: I can't get GIO stuff to compile (I might not have new enough libs on my system).  Plus I'm getting errors in the soegtk directory
18:46:43 <luqui> jsn, what do you mean?
18:47:13 <dcoutts> Nafai: I suggest you email the gtk2hs-devel users list
18:47:20 <jsn> i mean, if you're clock is reset, you are in trouble
18:47:29 <jsn> s/you're/your/
18:47:40 <luqui> jsn, not SysClock.  Time.  Real time.  as in, the time in an inertial reference frame :-)
18:47:40 <Nafai> dcoutts: Okay, I'll do that
18:47:52 <Nafai> dcoutts: I'm wanting to do these patches :)
18:47:54 <jsn> luqui: that's not implementable
18:48:01 <dcoutts> Nafai: ah yes
18:48:09 <luqui> jsn, not directly.
18:48:28 <jsn> luqui: you can have vector clock, i guess
18:48:36 <luqui> jsn, but we can still use it as our semantics and implement around it using clever tricks.
18:48:37 <dcoutts> Nafai: if you can't get it to work, then send a patch against the last release and let the devs fix it up
18:48:44 <Nafai> dcoutts: Sounds good.
18:48:45 <luqui> (jsn, see, eg., every FRP implementation ever)
18:49:11 <dcoutts> Nafai: or just unrecord and revert the recent gio changes
18:49:32 <SamB_XP> luqui: what if the OS isn't in such a frame ?
18:49:43 <luqui> SamB_XP, lol
18:49:48 <jsn> luqui: i misunderstood the layer at which the interface would be referentially transparent, then
18:50:09 <luqui> SamB_XP, probably we would make a semantic compromise and use newtonian time...
18:50:13 <jsn> if two OS move toward one another at half the speed of light...
18:50:31 <luqui> I Just threw inertial reference frame in there to drive home that I'm talking about physics, not bits on a computer
18:50:55 <SamB_XP> luqui: or dealing with concerns like DST
18:51:06 <SamB_XP> what if the computer was confused about the time recently ?
18:51:20 <jsn> SamB_XP: DST is not a big deal
18:51:31 <jsn> but clock drift and correction is, yeah
18:51:48 <SamB_XP> I was thinking more like jumps than drift
18:51:55 <roconnor> I'm not really paying attention, but an OS is largely unrelated to time.
18:52:00 <jsn> by correction, i meant jumps
18:52:04 <SamB_XP> oh
18:52:06 <luqui> roconnor, do tell
18:52:16 <luqui> roconnor, current OSes have everything to do with time.
18:52:19 <SamB_XP> I thought most OSes used gradual shifts for correction
18:52:24 <jsn> yes
18:52:28 <roconnor> luqui: it's just a sequence of events.
18:52:31 <jsn> but they are definitely noticeable
18:52:40 <luqui> roconnor, why do you forbid it from being continuous?
18:52:41 <SamB_XP> luqui: the time isn't really the main thing an OS handles ;-)
18:52:49 <roconnor> maybe even not quite a sequence if you add paralism
18:52:54 <SamB_XP> luqui: 'tis impossible
18:53:03 <luqui> SamB_XP, computably continuous then.
18:53:15 <roconnor> luqui: digital computers are abstracted to be discrete things.
18:53:33 <roconnor> luqui: one of these events is possibly a clock timer
18:53:42 <roconnor> but you could have multiple clock timers
18:53:43 <luqui> roconnor, yes, but is it optimal for the user (/ client program) of an OS to think about it as discrete?
18:53:48 <jsn> SamB_XP: i guess, as long as you never apply a non-monotonic correction -- and NTP tries not to -- things will be okay
18:53:49 <luqui> why can we not reabstract it back to continuous?
18:53:49 <roconnor> that aren't even in sync
18:53:52 <roconnor> or consistent
18:54:31 <roconnor> luqui: that would be abstaracting away from digital, which is an essential property of what we call computers.
18:54:58 <luqui> I think that is essntial to the implementation of a computer, but not the idea of a computer.
18:55:12 <conal> roconnor: maybe luqui is suggesting that we program with computers, not about them.
18:55:19 <roconnor> I guess we'll have to disagree there
18:55:27 <jsn> i think it makes no difference, as long as clients expect finitely many monotonic measurements in some interval
18:55:29 <SamB_XP> luqui: well, the OS is supposed to run on the implementation of a computer
18:55:36 <SamB_XP> in case you forgot
18:55:48 <conal> roconnor: is functional programming possible?  doesn't it contradict the nature of computers?
18:56:07 <luqui> SamB_XP, well, yeah, but so does a music player.  does that mean music is fundamentally discrete?
18:56:18 <twb> Where's the magic to turn a cabal package into a debian package?
18:56:27 <jsn> luqui: seems to work fine that way
18:56:28 <SamB_XP> luqui: well, no, but we've been using analog music for years
18:56:37 <twb> Oh, update-debian-haskell-files
18:56:58 <luqui> SamB_XP, our representations of music on computers are discrete, but it still abstracts over the continuous idea of sound
18:57:09 <SamB_XP> (and I'm not saying music isn't actually discrete as well ... I honestly don't know ;-)
18:57:11 <roconnor> conal: we all program with respect to abstractions.  Even though our computer aren't a perfect implementation of this abstraction.
18:57:39 <conal> similarly, math is notationally discrete and yet handles continuous time & space just fine.
18:57:53 <luqui> roconnor, true!  and isn't an OS an abstraction?
18:58:08 <conal> ditto for finite and infinite
18:58:36 <luqui> conal, "just fine" modulo lots of wonderful theory about when it can't do so well :-)
18:58:38 <roconnor> yes.  You can make a continuous "OS", but it wouldn't be an OS as we understand it.  Perhaps that is a good thing.
18:58:40 <SamB_XP> yes but a continuous stream of events isn't plausible ;-)
18:59:10 <luqui> that was the idea.  kill OS as we understand it, start thinking about OS as we want it.
18:59:22 <jsn> what does it even mean, a continuous OS?
18:59:23 <roconnor> but more likely it is a mistake :)
18:59:24 <SamB_XP> I don't see as I want an OS like that
18:59:25 <luqui> SamB_XP, it doesn't even mean anything!
18:59:27 <roconnor> but what do I know.
18:59:32 <SamB_XP> I can't understand how it would do anything useful
18:59:51 <SamB_XP> it sounds like it would only be useful for signal processing
19:00:00 <jsn> it couldn't even do that
19:00:06 <shrughes> luqui: frequency-wise, music is discrete
19:00:09 <luqui> SamB_XP, what?!  well, the state of a mouse button is a function from continuous time to booleans.
19:00:11 <jsn> it could not, in fact, take a step :)
19:00:25 <SamB_XP> luqui: that's not events
19:00:31 <roconnor> an OS is supposed to abstract hardware, and all our hardware is digitial.  Making a continuous abstraction of digital hardware just seems bizarre.
19:00:32 <luqui> SamB_XP, Exactly!
19:00:45 <luqui> SamB_XP, what do events have to do with operating?
19:00:59 <SamB_XP> luqui: a lot ...
19:01:00 <jsn> actually, the whole thing is treated in terms of events
19:01:02 <roconnor> luqui: interupts
19:01:08 <jsn> you get a mouse down and a mouse up
19:01:11 <jsn> or you sample
19:01:12 <luqui> roconnor, well you can still embed discrete things in continuous time.
19:01:24 <SamB_XP> how does you gets continuous internets ?
19:01:32 <jsn> luqui: and that what computation is, basically
19:01:45 <luqui> jsn, no, I mean purely.  You start with continuous, and work your way to discrete.
19:01:46 <jsn> s/that what/that is what/
19:01:53 <shrughes> i would hope computers are not continuous because that would make security really hard
19:01:56 <jsn> you mean, event driven
19:02:21 <luqui> my favorite way to do this so far is that a series of discrete events is a step function Time -> Time, which identifies the last (or next) occurrence.
19:02:29 <roconnor> luqui: well, that is a sort of fallicy due to classical mathematics.  Classical mathematics reasons about all sorts of non-computational things.
19:02:52 <luqui> roconnor, all of classical mathematics is computable, because doing math is doing computation
19:03:00 <rwbarton> Computers can reason about all sorts of non-computational things too.
19:03:06 <luqui> mathematicians are computers, they just make rather wiser decisions most of the time
19:03:41 <luqui> rwbarton, good observation...
19:04:03 <adu> rwbarton: I love it when they do that
19:04:06 <roconnor> luqui: okay, write a program to solve the halting problem.
19:04:12 * adu <3 alicebot.org
19:04:24 <luqui> roconnor, ask a mathematician to solve the halting problem
19:04:31 <adu> I'm a mathematician
19:04:33 <jsn> roconnor: not fair
19:04:47 <roconnor> luqui: a mathematics claims the halting problem is solvable: every program halts or doesn't.
19:05:05 <luqui> roconnor, yep.  and a computer can certainly represent that statement.
19:05:15 <jsn> roconnor: well it is trivial to write that program
19:05:17 <luqui> mathematics does not claim that you can find out which it is
19:05:25 <rwbarton> Even if there are no physical continuous devices on which to run a "continuous OS", we can still use ordinary computers to reason about how such a device would behave
19:05:27 <roconnor> luqui: they can represent the statement, but the cannot compute the solution.
19:05:28 <maxote> is it new?
19:05:50 <roconnor> luqui: My point is that classical mathematics gives you bad inutitions when it comes to computation.
19:06:01 <roconnor> they claim all sorts of things exist that are not computable.
19:06:03 <maxote> classical mathematics or quantum mathematics?
19:06:06 * luqui keeps getting rwbarton and roconnor mixed up, first letter + length must be my hash function
19:06:16 <roconnor> :)
19:06:20 <maxote> x = can be either 0 or 1
19:06:22 <maxote> or both
19:06:29 <adu> luqui: lolol
19:06:53 <adu> so I am a??
19:06:59 <adu> and you are l????
19:07:01 <luqui> roconnor, okay, then don't use classical mathematics.  build our OS abstraction on intuitionistic mathematics
19:07:08 <luqui> there's still a notion of continuity in that one
19:07:14 <luqui> and actually that's the one I think about when I say continuous :-)
19:07:33 <adu> luqui:
19:07:36 <roconnor> luqui: yes, but it is difficult / impossible to embed discrete events into a continuous space in constructive mathematics.
19:07:42 <adu> I could write a book about OS abstractions
19:07:47 <luqui> roconnor, what about my earlier model?
19:08:00 <roconnor> luqui: what model was that?
19:08:10 <luqui> roconnor, continuous step function Time -> Time.
19:08:14 <adu> luqui: I personally think tunes.org has the best of the best in terms of OS abstraction
19:08:17 <luqui> (continuous step function is undefined at the steps)
19:08:30 <luqui> adu, I know not about it
19:08:43 <adu> luqui: then go forth and learn, then you will know
19:08:59 <luqui> oh nice, looks cool
19:09:14 <roconnor> luqui: such a function cannot support evaluation constructively, because it is undecidable which side of a step that an arbitrary Time falls into.
19:09:32 <luqui> roconnor, but *most* times are decidable
19:09:42 <luqui> and splitting an interval on the step is decidable
19:09:55 <luqui> and lots of other very useful things about such step functions are perfelctly doable
19:10:03 <roconnor> yes
19:10:22 <roconnor> but this will make you model quite complicated.
19:10:25 <luqui> just because there is a halting problem doesn't mean we shouldn't try to compute things
19:10:33 <roconnor> I agree
19:10:38 <luqui> roconnor, well, insofar as domain theory is complicated.
19:10:43 <adu> luqui: I think my favorite concept is "Orthogonal Persistence"
19:11:02 <luqui> and it is to some degree, but it also has a beautiful simplicity about it
19:11:15 <dmwit_> http://tunes.org/wiki/Orthogonal%20Persistence
19:11:19 <dmwit_> 404'd
19:11:24 <roconnor> I have never seen domain theory used with discontinuous step functions.
19:11:42 <ddarius> Blech orthogonal persistence
19:12:02 <luqui> roconnor, there is no such thing as discontinuous in domain theory.
19:12:13 <luqui> domain theory is a topological thing where all functions are continuous
19:12:30 <adu> http://web.archive.org/web/20070924235446/http://tunes.org/wiki/Orthogonal+Persistence
19:12:43 <luqui> a function from reals to bools *has* to have at least one _|_ in between the trues and the falses
19:13:12 <luqui> but you can still call that a step function (esp. if you augment it with information about where the _|_ is located)
19:13:14 <jsn> so is there a total ordering of events in this continuous filesystem?
19:13:51 <adu> luqui: I think whatever abstraction can handle both filesystems and databases should also be abstractable using both uniqueness typing and monads
19:13:57 <luqui> jsn, probably quasitotal if we're going to use continuous maths
19:14:22 <roconnor> luqui: I'm torn between advising you to go for this because diverse aproaches are a good thing, and advising you against this because I don't want you wasting time on what I beleive is a bad approach.
19:14:53 <luqui> roconnor, well, I think it's way too far off to start implementing or anything
19:14:56 <jsn> luqui: what is quasitotal?
19:14:59 <luqui> it's a thought bubble
19:15:12 <roconnor> :)
19:15:24 <luqui> jsn, ~(~(a <= b) /\ ~(b <= a))
19:15:30 * SamB_XP comes along with a needle
19:15:45 <luqui> jsn, i.e. it is contradictory for two events not to be related, but you can't necessarily compute which one was first
19:16:55 <luqui> NO NO NO let me be in my idealistic little world!!  put the needle of pragmatism away at once!
19:17:13 <SamB_XP> needle of pragmatism?
19:17:25 <SamB_XP> this is my needle-of-annoying-brotherhood
19:17:26 <luqui> SamB_XP, that's what I assumed your needle was made of
19:17:37 <adu> in my idealistic world, browsers would be more like terminals
19:17:44 <jsn> luqui: it is not clear how you can have a consistent world state, given that
19:17:58 <luqui> jsn, can you elaborate?
19:18:14 <jsn> without a total ordering of events, you can not determine the state of the system
19:18:44 <luqui> jsn, what if we only require events which need to be related to be computably related
19:19:02 <luqui> I don't care if this mouse click came before this network packet...
19:19:04 <SamB_XP> actually I think that's about how it is now
19:19:12 <jsn> luqui: yes you do
19:19:24 <jsn> luqui: if they both write to a file
19:19:36 <luqui> jsn, mouse clicks and network packets do not write to files...
19:19:45 <jsn> yes they do
19:19:58 <luqui> jsn, ....?
19:20:02 <adu> packets do, but clicks don't
19:20:05 <jsn> or some buffer or whatever
19:20:06 <SamB_XP> hmm, what if the network packet was an X protocol request ?
19:20:20 <dmwit_> adu: They might, if there's a button underneath the click.
19:20:32 <jsn> the point is, one can take the space the other might
19:21:05 <roconnor> luqui: perhaps we are fighting about wave mechanics vs matrix mechanics.  Perhaps in the end what we both want is equivalent.
19:21:40 <jsn> luqui: my point is only, there is no consistent state in a system like that
19:21:59 <jsn> luqui: you can hope you cover all your bases and keep the causally unrelated things in separate worlds
19:22:55 <jsn> luqui: but that requires a pretty high level of abstraction
19:23:30 <jsn> and to be honest, it's pretty limiting
19:24:08 <jsn> yikes
19:26:39 <jsn> luqui: so, chandra, lynch & lamport are good authors on this stuff -- what you can do without total synchrony, and what you have to do to get it if you don't have it
19:36:39 <jsn> luqui: did you get my last message?
19:53:47 <AWizzArd> Is there a way to test for equality of functions? If I have a function foo which adds 10 to its argument and a function bar that adds 10 to its argument, is there an equality test that would yield true?
19:54:14 <bd_> AWizzArd: No. Such a test is provably impossible to make.
19:54:30 <shrughes> AWizzArd: only if the function has a finite input space
19:54:31 <ddarius> _ == _ = True
19:54:40 <bd_> shrughes: and is not a partial function
19:54:46 <rwbarton> s/finite/compact
19:54:48 <bd_> which implies the function is not turing-complete
19:55:07 <bd_> or well, not written in a turing-complete language
19:55:12 <ddarius> bd_: Better
19:55:23 <bd_> better?
19:55:37 <ddarius> Your earlier sentence was meaningless.
19:55:51 <bd_> right :)
19:55:56 <AWizzArd> I understand that it technically is difficult, but isn't it possible to compare (internally, hidden from the user) the machine code? A chunk of bytes compared with another one?
19:56:12 <shrughes> AWizzArd: different machine codes can do the same thing
19:56:12 <bd_> AWizzArd: however different machine code may have identical effect
19:56:42 <shrughes> bd_, whatever you're talking about, you can still compare Bool -> a's just fine
19:57:04 <bd_> shrughes: even if the function is f _ = undefined ?
19:57:11 <bd_> if one of the functions are, rather
19:57:28 <AWizzArd> right, there would still be enough things that couldn't be tested correctly, but at least a huge number of functions could be compared this way
19:57:38 <bd_> AWizzArd: not really
19:57:42 <shrughes> bd_: no of course not, you can't compare [undefined] with things either
19:57:46 <bd_> first off, in haskell, functions aren't just the function code
19:57:53 <bd_> they also have a pad of lexical bindings
19:58:11 <bd_> and in theory, let a = \x -> ... in (a, a) might return two different pointers
19:58:39 <jeffz> AWizzArd: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/33850/focus=33914 "Printing and Referential transparency excuse"
19:58:40 <bd_> moreover, if those lexical bindings have a program embedded in them, now you must compare this arbitrarily complicated data structure
19:58:47 <bd_> which may contain fun things like pointers into C data
19:58:51 <lambdabot> Title: Gmane Loom, http://tinyurl.com/5zyneg
19:58:51 <dmwit_> bd_: Actually, I think "let" is specifically for sharing.
19:59:00 <dmwit_> (But your point stands.)
19:59:11 <bd_> dmwit_: at the Core level, maybe, but surely optimization and rewrite rules are allowed to play with that if they like :)
19:59:52 <dmwit_> No, at the Core level, let is for introducing a thunk.
19:59:53 <bd_> shrughes: how can you compare Bool -> a if you don't have an Eq a?
20:00:09 * jeffz compares some types of functions for equality by pairing them with another value that can be compared for equality.
20:00:24 <ddarius> dmwit_: The Report doesn't even require Haskell 98 to be call-by-need.
20:00:32 <bd_> dmwit_: oh, hm. Still, I'm not convinced that I can trust the optimization rules to always ensure sharing in all cases :)
20:00:37 <shrughes> bd_ sure, with Eq a
20:00:58 <shrughes> bd_: or you could consider two functions equivalent if they both terminate :)
20:01:08 <bd_> shrughes: well, okay, but in general functions which are complete (and thus not in a turing-complete language) and with a finite domain are trivially comparable
20:01:20 <dmwit_> Your claim that you can only compare functions with finite domain is a bit questionable, too.  I seem to recall a sigfpe blog post about comparing functions in a strange way...
20:01:24 * dmwit_ goes digging
20:01:37 <bd_> dmwit_: I'm not saying /only/ those functions can compared. Just that those functions are /trivially/ compared
20:01:45 <bd_> and with partial functions all bets are off
20:01:46 <ddarius> If you assume they're total, you're fine.
20:01:55 <rwbarton> I mentioned the case of comparing functions with compact domain
20:01:59 <ddarius> You can't even compare () -> () functions.
20:02:10 <bd_> ddarius: let f n = the value of the binary digit n of some uncomputable number
20:02:14 <bd_> f is total, but not comparable
20:02:22 <shrughes> bd_: I don't think that language makes any sense -- you could say that lists, arrays, and values aren't comparable either
20:02:23 <bd_> actually irrational number is probably good enough
20:02:58 <bd_> shrughes: well, I should say that, (I think) you can't write a function that can compare f to some other function g and give a correct result in all cases
20:03:03 <bd_> unless it fails to terminate in some cases
20:03:23 <rwbarton> bd_: Surely if you give me two functions f and g and ask me to test whether they are equal, you will at least let me evaluate the functions on some input!
20:03:29 <bd_> rwbarton: oh, certainly
20:03:29 <SamB_XP> how can f be total if the number is uncomputable ?
20:03:37 <bd_> SamB_XP: okay, irrational then
20:03:40 <rwbarton> bd_: OK, so this function f is not a concern
20:03:42 <shrughes> bd_: you mean to say, unless it terminates in all cases?
20:03:55 <shrughes> bd_: can you compare lists for equality?
20:04:03 <ddarius> If I have two total functions with finite domain, I can compare them on all inputs and if they are equal then they are equal functions up to observational equivalence.
20:04:08 <bd_> shrughes: no, in general :)
20:04:15 <shrughes> bd_: you are saying nothing then :P
20:04:17 <bd_> XD
20:04:20 <bd_> true
20:04:36 <shrughes> i think you can compare Int# for equality
20:05:10 <bd_> So perhaps it would be more accurate to say that for some types there is not an equality function that implies identity?
20:05:19 <bd_> not a computable equality function rather
20:05:30 <shrughes> you betcha!
20:06:00 <bd_> ... I think we scared AWizzArd off
20:14:03 <LynxAba> hello everybody!!
20:14:17 <LynxAba> is there a function to pass a Int to String?
20:14:35 <Cale> show?
20:14:37 <Cale> > show 654343
20:14:39 <lambdabot>   "654343"
20:14:55 <LynxAba> interesting detail
20:14:57 <ddarius> > "3" $ 5
20:14:58 <LynxAba> ^^'
20:14:58 <lambdabot>   Couldn't match expected type `a -> b'
20:15:46 <LynxAba> i'm actually defining the show funct for a newtype i have, i totally forgot that thing
20:15:51 <LynxAba> thanks Cale
20:17:26 <dmwit_> Did you know you can have GHC write your Show instance for you?
20:17:30 <dmwit_> It's highly recommended.
20:18:01 <LynxAba> yes, but in this case i need to define it by myself
20:18:03 <rwbarton> Perhaps the reason for the newtype is to create a new Show instance :)
20:18:13 <LynxAba> exactly
20:18:26 <rwbarton> Although, that's not 100% recommended I suppose
20:18:30 <dmwit> right
20:18:41 <dmwit> It's pretty common practice to separate your Show instance from your pretty printer.
20:18:45 <LynxAba> eventhough you can use the "deriving (Show)" instead
20:18:56 <dmwit> Show/Read are really supposed to be for things you could drop straight into Haskell source.
20:19:26 <SamB_XP> also Show doesn't support any kind of indentation
20:21:10 <nicknull> wow JAVA is retarded
20:21:28 <SamB_XP> like duh
20:21:36 <nicknull> but Bush is president so the world i obv upside down, therefore JAVA rules and Haskell doesnt
20:21:46 <Cale> nicknull: heh, what's the problem with it this time?
20:21:51 <dmwit> Opposite day starts in 5...
20:21:53 <dmwit> 4...
20:21:54 <dmwit> 3...
20:21:56 <dmwit> 2...
20:21:56 <nicknull> it?
20:21:56 <dmwit> 1...
20:21:59 <nicknull> JAVA?
20:22:02 <Cale> With Java, yeah.
20:22:11 <dmwit> I would just like to point out that it is NOT opposite day.
20:22:17 <nicknull> verbositylevel=max
20:22:33 <nicknull> everything HAS to be in a *"!# class
20:23:01 <SamB_XP> yeah, it can't even be in a just peachy class
20:23:05 <Cale> Well, technically you could put everything in the same class.
20:23:06 <SamB_XP> it has to be in an accursed class
20:26:34 <nicknull> yes but then it cant be public
20:31:44 <Cale> nicknull: There's always Scala ;)
20:33:54 <shrughes> dmwit++
20:33:56 <nicknull> i know, i have tried it, it has some nice features and it is pretty much nicer in every way it feels like but i wish it had better type inference
20:34:34 <nicknull> and was faster... i have python for scripting rapid prototyping, i want sdomething static for big projects where performance and correcness matters
20:34:52 <dmwit> shrughes: Why are you lowering my karma? =(
20:35:01 <shrughes> @karma dmwit
20:35:02 <lambdabot> dmwit has a karma of 2
20:35:04 <shrughes> what
20:35:36 <dmwit> Opposite day has *totally* ended. ;-)
20:35:41 <shrughes> i'm lowering your karma
20:35:51 <shrughes> lambdabot is not lowering your karma
20:36:04 <shrughes> dmwit--
20:36:06 <shrughes> there I raised it
20:36:10 <dmwit> glee!
20:37:38 <shrughes> dmwit I agree that opposite day is over
20:38:14 <dmwit> It's over, okay, you guys?  I just want to state for the record that it is NO LONGER OPPOSITE DAY.
20:38:16 <dmwit> No thank you.
20:38:37 <Cale> But wait, doesn't that mean that opposite day has just begun?
20:38:55 <dmwit> I think you didn't mean to ask, doesn't that mean that opposite day has not just begun?
20:39:10 <dhotson> Hi all, I'm a haskell newbie.. I've been reading through http://learnyouahaskell.com/ recently. It seems like a pretty good intro.
20:39:11 <lambdabot> Title: Learn You a Haskell for Great Good!
20:39:24 <Nafai> dhotson: I thought it was pretty approachable
20:39:30 <Cale> dhotson: cool :) Let us know if you have any questions or trouble :)
20:39:40 <dhotson> I've got a question about how 'variables' work actually :)
20:39:43 <Cale> okay
20:39:49 <dmwit> They don't!
20:39:52 <dmwit> vary, that is
20:40:00 <dhotson> yeah hence the quotes hehe ;)
20:40:01 <Nafai> I'm trying to hack on xmonad but I've run into an issue and perhaps I could get some help, it's more of understanding my error message and how to solve something than an xmonad thing
20:40:03 <dmwit> "work" is something they do just fine ;-)
20:40:15 <Nafai> This is what I've tried: http://hpaste.org/11407 and the error message I get
20:40:26 <Cale> As long as a variable is in scope, it has the same value, but it can take on different values at different times in the program.
20:40:45 <dhotson> when I do something like x = 42 ... is that the same as making a function called x that just returns 42 ?
20:40:57 <dhotson> .. is it actually a function?
20:41:02 <Cale> It's not a function.
20:41:04 <thoughtpolice> no, 42 is just a constant.
20:41:06 <Cale> It's a constant.
20:41:23 <dmwit> It's okay to think of it as a function that takes no arguments, actually.
20:41:24 <thoughtpolice> like 'int x = 1;' in C or something
20:41:25 <Cale> If we have  f x = x^2 + x + 1, then x can have different values at different points in the program.
20:41:36 <Cale> (Because you can call f with different parameters)
20:41:36 <dmwit> You don't *have* to think of it that way, but it kind of works in a wonky sort of way.
20:41:39 <dhotson> Ahh ok... yeah I had kinda imagined it could be a function with zero arguments
20:41:44 <dhotson> which would be equivalent to a constant
20:41:45 <rwbarton> 42 is a function of no arguments to the same extent as (+) is a function of two arguments.
20:42:01 <Cale> rwbarton: Not quite the same extent.
20:42:23 <dhotson> so it's not the same as a function with no arguments?
20:42:24 <SamB_XP> 42 could be a function of one argument
20:42:27 <dhotson> little bit different?
20:42:31 <Cale> Because you might say that the only things which are functions are the things which have (->) as the top-level type constructor in their type.
20:42:55 <SamB_XP> Cale: in that case "of two arguments" isn't sensible
20:43:03 <rwbarton> Cale: I didn't say anything at all about anything being a function :)
20:43:13 <rwbarton> Cale: Just "function of n arguments" for a particular n.
20:43:25 <Cale> dhotson: I think to appreciate the points zipping by here, it's important to realise that in reality, every function in Haskell has exactly one argument.
20:43:27 <dmwit> Nafai: Check out these two lines of the error:
20:43:40 <dmwit> Nafai: Expected type Map String Window -> X (Maybe a)
20:43:49 <dmwit> Nafai: Inferred type Map String a -> X (Maybe a)
20:43:56 <Cale> dhotson: Functions which appear to have more arguments are really functions which take the first and produce other functions to take the rest.
20:44:02 <dmwit> Nafai: At first, this seems fine -- we could just instantiate 'a' at Window, right?
20:44:24 <Cale> dhotson: This seems a little strange at first, but after a while, you'll wonder how you ever lived without it :)
20:44:27 <dhotson> Cale: Ahh right... so _all_ functions take one argument? .. a function with no arguments is just a constant?
20:44:35 <Cale> dhotson: yeah
20:44:40 <dmwit> Nafai: But actually the two types are different, because the inferred type requires that 'a' be the same in both the input and the output.
20:44:59 <Nafai> dmwit: Okay, that makes sense
20:45:03 <dmwit> Nafai: But the expected type doesn't return a X (Maybe Window) -- it has to be able to return *anything*!
20:45:06 <rwbarton> dhotson: What I was saying obliquely is that technically there's neither such a thing as a function with zero arguments, nor a function with two arguments.
20:45:23 <nicknull> @karma nicknull
20:45:24 <lambdabot> You have a karma of 0
20:45:28 <dmwit> (Well, an X (Maybe *anything*). ;-)
20:45:31 <nicknull> nicknull ++
20:45:36 <nicknull> @karma nicknull
20:45:36 <lambdabot> You have a karma of 0
20:45:36 <Cale> dhotson: Of course, even if you're allowed functions with no parameters, they must always give the same result because you always call them with the same args.
20:45:44 <dhotson> rwbarton: sorry, can you please clarify?
20:45:45 <roconnor> roconnor++
20:45:47 <Cale> dhotson: So, might as well be a constant :)
20:45:51 <Nafai> dmwit: *nods* I understand that much
20:45:57 <roconnor> @karma+ roconnor
20:45:58 <lambdabot> You can't change your own karma, silly.
20:45:58 <dmwit> nicknull: Two problems: the ++ wasn't attached to your nick, and \bot is smart enough to ignore own-karma-boosts. =)
20:46:15 <dmwit_other> dmwit++
20:46:18 <dmwit_other> ?karma dmwit
20:46:18 <lambdabot> dmwit has a karma of 2
20:46:22 <dmwit_other> That works, though.
20:46:26 <adu> omg I am so confused
20:46:32 <roconnor> dmwit--
20:46:38 <roconnor> :)
20:46:39 <dhotson> well the other reason I was wondering.. is because I was wondering if that's where haskell get's it's lazy property from... ie you don't actually get the value of a constant until you call it
20:46:42 <dmwit> ;-)
20:46:52 <dhotson> is that where the laziness comes from?
20:46:58 <dmwit> My karma has just been on a roller coaster tonight.
20:47:04 <Nafai> dmwit: So why wasn't copying the type signature from dmenuMap and enclosing it in parens enough?
20:47:08 <Cale> dhotson: Lazy evaluation is just a particular order of evaluating expressions (along with one subtle kind of optimisation which I'll get to)
20:47:15 <roconnor> @sparkline karma dmwit
20:47:16 <lambdabot> Unknown command, try @list
20:47:16 <dolio> @karma+ dolio
20:47:16 <lambdabot> You can't change your own karma, silly.
20:47:22 <dmwit> Nafai: I don't know very much about this code, sorry.
20:47:29 <jsn> roconnor: i wonder, is the "quasi-total" ordering luqui described enough to make a system asynchronous?
20:47:37 <shrughes> dmwit++   -- for not calling a personal jynx on me
20:47:37 <Cale> dhotson: Under strict evaluation, you evaluate expressions by reducing the innermost things first.
20:47:40 <dhotson> yep, I understand the concept of laziness.. I'm just curious how it actually works :)
20:47:45 <rwbarton> dhotson: All functions in Haskell have a single argument.  If the type of the function is a -> b, then the type of the argument is a.
20:47:52 <roconnor> jsn: quasi? not even partial?
20:47:57 <Cale> dhotson: Lazy evaluation, by contrast, evaluates outermost-first.
20:48:00 <Nafai> dmwit: That's okay
20:48:03 <jsn> roconnor: right
20:48:05 <rwbarton> dhotson: But, it's very useful to think of (+) :: Num a => a -> a -> a as having two arguments.
20:48:09 <Cale> Let's have a look at a simple example I like to give:
20:48:15 <Cale> double x = x + x
20:48:16 <dhotson> so you mean: main = xxx ?
20:48:27 <Cale> Let's evaluate  double (double 5)
20:48:27 <adu> help: http://hpaste.org/11408
20:48:32 <roconnor> jsn: cyclic ordering of events seems like a bad idea. ... are you using quasi-order in a technical sense?
20:48:36 <adu> it crashes the stack for some reason
20:48:48 <Cale> Under strict evaluation (which is what you get in most programming languages), it goes:
20:48:51 <Cale> double (double 5)
20:48:55 <Cale> -> double (5 + 5)
20:48:58 <Cale> -> double 10
20:49:02 <Cale> -> 10 + 10
20:49:03 <Cale> -> 20
20:49:04 <rwbarton> adu: there's a typo in the area of s3
20:49:18 <Cale> Let's try outermost-first evaluation now:
20:49:23 <Cale> double (double 5)
20:49:29 <Cale> -> (double 5) + (double 5)
20:49:36 <Cale> -> (5 + 5) + (double 5)
20:49:40 <jsn> roconnor: i am not familiar with the term -- luqui used it, and described it as:  ~( ~(a <= b) /\ ~(a => b) )
20:49:41 <Cale> -> 10 + (double 5)
20:49:44 <Cale> -> 10 + (5 + 5)
20:49:47 <Cale> -> 10 + 10
20:49:49 <Cale> -> 20
20:49:51 <adu> rwbarton: where?
20:49:57 <dhotson> sorry brb.. wont be long... (I'm at work atm :P)
20:50:00 <rwbarton> adu: s3' = 100 * (s3' - fromInteger s3)
20:50:06 <rwbarton> should have s2 on the right hand side
20:50:06 <Cale> okay
20:50:13 <shrughes> now do lazy evaluation!
20:50:13 <adu> rwbarton: oh, hehehe
20:50:17 <roconnor> jsn: oh, okay.  That makes more sense.
20:50:21 <[-> dhotson, remember, these are functions in the mathematical sense
20:50:35 <adu> rwbarton: thanks
20:50:37 <Cale> shrughes: I'll get to it when he gets back :)
20:50:59 <roconnor> jsn: I'm not sure what that will give you over a partial order.
20:51:12 <roconnor> hmm
20:51:52 <Cale> The important difference between lazy evaluation and outermost-first evaluation is that lazy evaluation avoids the duplicated work of evaluating (double 5) which was caused by the parameter x occurring twice in the body of double.
20:52:20 <roconnor> I have vague recollections of it giving you something like f(a \/ b) = f(a) \/ f(b) for monotone functions.
20:52:47 <dolio> roconnor: "i.e. it is contradictory for two events not to be related, but you can't necessarily compute which one was first"
20:53:15 <jsn> why is that?
20:53:30 <roconnor> dolio: I understand what it means.  I'm just trying to think about useful things it entails.
20:54:56 <jsn> dolio: i'm having trouble understanding why it isn't "it is *not* contradictory for two events not to be related, but you can't necessarily compute which one was first"
20:55:04 <roconnor> for partial orders I think you only get an inequality between f(a \/ b) and f(a) \/ f(b) for monotone f
20:55:23 <roconnor> but with this addition structure, I think you get equality.
20:56:35 <dolio> jsn: If a and b are unrelated, then I guess both a <= b and b <= a are false, so the conjunction of their negation is true, and the overall expression is false.
20:57:10 <jsn> dolio: i see, thank you
20:57:16 <jsn> dolio: that last part i missed
20:59:37 <jsn> so luqui is saying, there *must* be an ordering
20:59:52 <jsn> ?
21:00:20 <jsn> but i guess i don't see why
21:00:41 <dhotson> Cale: I'm back now sorry about that :)
21:00:59 <Cale> dhotson: No problem
21:01:33 <Cale> dhotson: So, if you followed that bit above, you'll notice that in the case of outermost evaluation, we duplicated some work: double 5 got evaluated twice
21:02:31 <Cale> dhotson: Lazy evaluation refines this a bit by saying that if a parameter to a function occurs multiple times in the function body, any results of evaluating it are shared between the copies.
21:02:55 <dhotson> ahh yep.. so the double function.. the argument it accepts is a function?
21:03:05 <Cale> no, just a number
21:03:11 <dhotson> and it just calls it twice and adds the result.. kind of?
21:03:13 <Cale> double 5 = 5 + 5 = 10
21:03:38 <Cale> It takes a number, and adds it to itself.
21:04:08 <dhotson> hmm ok... If you look at it from the point of view that 5 is a function that returns 5 .. does that kinf of make sense?
21:04:18 <rwbarton> I think I understand dhotson's question
21:04:22 <Cale> uh, sort of...
21:04:24 <rwbarton> In ML you can write  let five () = 5
21:04:26 <Cale> (double 5) is a number of course
21:04:34 <rwbarton> let double x () = x () + x ()
21:04:39 <dhotson> I'm just trying to figure out how it manages to delay the evaluation
21:04:42 <Cale> We just don't know which number it is yet.
21:04:44 <rwbarton> to simulate lazy evaluation
21:05:05 <Cale> dhotson: It's perfectly acceptable to view it as simply manipulating expressions in memory.
21:05:12 <Cale> When you have an expression like f (g x)
21:05:32 <Cale> What it does is look at the definition of f, and plug (g x) in for the first parameter of f in the body.
21:06:20 <Cale> Think of highschool algebra, where you might have had f(x) = x^2 + x + 1, and so f(g(x)) = (g(x))^2 + g(x) + 1
21:06:22 <dhotson> hmm ok.. so what is it that triggers it to actually evaluate it?
21:06:34 <dhotson> I mean it can't delay forever :)
21:06:47 <Cale> Aha, good question. At some level, all evaluation is forced by pattern matching.
21:07:01 <Cale> (but you could also consider things like printing to the screen)
21:07:19 <shrughes> dhotson, do you know C# by any chance?
21:07:22 <Cale> and when evaluation starts happening, it reduces the outermost thing first.
21:07:35 <dhotson> ahh ok... so in a real program, the io stuff pretty much triggers the evaluation?
21:07:39 <Cale> yeah
21:07:46 <adu> the time is 0x000007D80A1704081024553E :)
21:08:02 <dhotson> nah.. but I know other languages like java, ruby, python .. *ahem*php etc
21:08:04 <Cale> dhotson: Okay, so let's look at  double (double 5)  under real lazy evalation now.
21:08:12 <Cale> evaluation*
21:08:20 <Cale> double (double 5)
21:08:26 <Cale> -> let x = double 5 in x + x
21:08:33 <Cale> -> let x = 5 + 5 in x + x
21:08:37 <Cale> -> let x = 10 in x + x
21:08:41 <dhotson> sorry... brb again.. :)
21:08:42 <Cale> -> 20
21:09:29 <aluink> i need to write a function that prints out some data structure and then returns it
21:09:42 <shrughes> dhotson: after listening to Cale, if you want a somewhat shoddily written, overwrought example of manually implementing lazy evaluation (and the other two kinds mentioned here) see http://samuelhughes.com/misc/variables_and_thunks.html
21:09:43 <lambdabot> Title: Variables And Thunks
21:09:44 <aluink> i'm having trouble coming up with something...and direction?
21:09:53 <adu> aluink: then it will have to be of type (something -> IO Struct)
21:10:02 <Cale> aluink: Okay, so it's really going to produce an I/O action.
21:10:31 <badtruffle> so if I do :t (,), it says a -> b -> (a, b)
21:10:33 <aluink> adu, Cale: yes, i tried IO Struct, but the function calling it complained that it was IO Struct and not Struct
21:10:40 <badtruffle> how does (1, 2, 3) work?
21:10:41 <Cale> aluink: right.
21:10:44 <shrughes> :t (,,)
21:10:45 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
21:10:54 <Cale> aluink: Only IO actions are allowed to execute other IO actions.
21:10:56 <shrughes> > (,,) 1 2 3
21:10:58 <lambdabot>   (1,2,3)
21:11:00 <badtruffle> shrughes: is that some language special case?
21:11:06 <badtruffle> or can patterns like that be generalized?
21:11:08 <shrughes> badtruffle: yes, tuples are a special case
21:11:14 <badtruffle> cool, thanks
21:11:20 <shrughes> what do you mean by "patterns like that"?
21:11:25 <adu> aluink: is the function calling it something you wrote?
21:11:35 <badtruffle> I meant, can I write :t (+++++)
21:11:42 <badtruffle> and define special behavior
21:11:46 <dmwit> badtruffle: Sure.
21:11:56 <badtruffle> so for interleaved patterns that'll work?
21:11:57 <Cale> badtruffle: You can define (+++++) for yourself, as an ordinary function
21:11:57 <dmwit> > let a +++++ b = "foo" in 3 +++++ 4
21:11:58 <lambdabot>   "foo"
21:12:00 <shrughes> > let x +++++ y = x * y in 4 +++++ 6
21:12:02 <lambdabot>   24
21:12:03 <aluink> http://pastebin.com/m3bab3ad8
21:12:07 <shrughes> you people type so fast
21:12:08 <badtruffle> oh, but I mean interleaving like with the comma
21:12:18 <aluink> ...i'm printing a chessboard
21:12:19 <badtruffle> make 1 + 2 + 3 + 4 + 5 behave differently
21:12:25 <Cale> badtruffle: Oh, (,) and (,,) etc. are all just the names of constructors.
21:12:31 <aluink> type Board = [Int]
21:12:41 <Cale> badtruffle: they're separate and not really related apart from the fact that they all make tuples.
21:13:28 <Cale> aluink: okay, so foo must produce an IO action, as must doCommand
21:13:52 <Cale> foo b = do printBoard b; return b
21:14:06 <Cale> aluink: But,  (do printBoard b; return b) :: IO Board
21:14:06 <aluink> hmmm, ok, i'll play with that, thanks
21:14:11 <badtruffle> Cale: I mean, if I do :t (,,) it'll give me a tuple constructor, and the arguments to that are allowed to be interleaved. If I do :t (,,,,,,,) it'll do the same, with n + 1 interleaved arguments. I was wondering if I was allowed to define (in the same way) a function ++++ that took 5 interleaved arguments and did something different from regular +
21:14:12 <aluink> yeah
21:14:54 <Cale> badtruffle: oh, no, (a,b,c) is special syntax
21:14:54 <shrughes> badtruffle: you can't have it affect the + operator's behavior
21:15:02 <badtruffle> aha, I see
21:15:11 <badtruffle> okay, I just wanted to see if the tuples had special treatment from the language
21:15:19 <badtruffle> thanks :)
21:15:22 <aluink> is there anyway i can convert a IO Board value into a Board value, so i don't forever have to keep passing IO Board values around?
21:15:27 <Cale> badtruffle: that's the only special treatment they get
21:15:37 <badtruffle> yup
21:15:48 <badtruffle> after the syntactic sugar for making them, they behave like anything else
21:15:52 <badtruffle> I think
21:15:57 <shrughes> aluink: ioBoardValue >>= \board -> ....
21:16:00 <Cale> badtruffle: We could have defined  data Tuple2 a b = T2 a b, data Tuple3 a b c = T3 a b c, etc.
21:16:02 <dmwit> aluink: Sorry, no.
21:16:12 <dmwit> aluink: However, you can lift your pure functions into the IO monad with no trouble.
21:16:25 <Cale> aluink: an (IO Board) is not itself a board.
21:16:40 <Cale> aluink: It's a program, which if it were executed, would produce a board.
21:17:03 <Cale> aluink: From inside an IO action, you can cause that program to execute, by writing  b <- myIOBoard
21:17:08 * aluink is still wet behind the ears with Haskell ;)
21:17:26 <Cale> aluink: that's okay, everyone gets stuck on this to some extent or another :)
21:17:44 <Cale> aluink: So, once you've done that,  b :: Board
21:17:52 <aluink> i come from C if that helps you out in your explanation any
21:18:30 <dhotson> Cale: sorry.. thanks for your patience :) .. so evaluation is triggered by IO?
21:18:33 <aluink> so what is b <- myIOBoard about?
21:18:49 <Cale> dhotson: Yeah, effectively.
21:19:10 <Cale> aluink: inside a do-block, the line  v <- x  means "run the action x and call its result v"
21:19:13 <dhotson> Ahh right... so is there a way to force something to evaluate? Or is that just a bad habit from java? :P
21:19:22 <Cale> aluink: Of course, do-blocks just define other actions.
21:19:28 <aluink> hmmm
21:19:41 <Cale> aluink: So in the end, one of these actions actually needs to get run, and in a compiled program, that's main.
21:19:52 <aluink> hmmm
21:19:55 <Cale> Normal Haskell evaluation doesn't cause IO actions to execute.
21:20:23 <Cale> You might think of a value of type  IO t  as being like the source code for a C program that computes a value of type t.
21:20:24 <dmwit> dhotson: When you are ready, the incantation for forcing an evaluation will be revealed to you.
21:20:35 <Cale> Evaluating what that source code is won't cause it to run
21:20:42 <rwbarton> dhotson: Why would you want to force something to evaluate?
21:20:54 <dmwit> But first you must drink deep of the forces of lazy evaluation and lay your heart at the altar of the Church of the Lambda.
21:20:59 <Cale> heh
21:21:25 <dhotson> well, if you need to ensure something happens in order for example... or at a particular time
21:21:30 <Cale> You can force any expression to evaluate simply by typing it at the GHCi prompt, although if it's of type IO t, it will be executed.
21:21:31 <dhotson> ie cron
21:21:45 <dmwit> dhotson: IO makes a little bit of a guarantee about evaluation order.
21:21:47 <dhotson> could you write something cron in haskell?
21:21:49 <dhotson> like*
21:21:52 <dmwit> dhotson: Certainly.
21:21:54 <Cale> dhotson: absolutely
21:21:57 <telexicon> of course
21:22:01 <shrughes> dhotson: positively
21:22:05 <Cale> dhotson: But getting the current time is an IO action.
21:22:09 <dmwit> definitely
21:22:12 <gnut> hi
21:22:13 <Cale> heh
21:22:15 <telexicon> dhotson, undeniably
21:22:16 <dhotson> so how can you guarantee your code will be run at the time you want it to?
21:22:18 <dmwit> gnut: Hi!
21:22:30 <Cale> dhotson: Well, you might poll the clock time.
21:22:46 <gnut> when is ghc 6.10 expected to be released?
21:22:53 <Cale> and use something like threadDelay to wait in between.
21:23:12 <Cale> gnut: well, it's in release candidate mode
21:23:22 <telexicon> isnt there a facility somewhere where you can schedule callbacks and hook into the machines HPET handled by the kernel or something
21:23:24 <gnut> oh really? or beta?
21:23:34 <dhotson> ahh right... so you can have something like an event loop? and trigger events etc ?
21:23:36 <Cale> I think it's at RC1
21:23:42 <gnut> i run solaris x86, i can't seem to build it
21:23:45 <dmwit> dhotson: Yup.
21:23:46 <Cale> dhotson: yep, from IO
21:23:51 <gnut> that's why i'm waiting for the binaries
21:23:51 <dhotson> does haskell even have the concept of a loop??
21:23:58 <gnut> dhotson: recursion
21:23:59 <dmwit> dhotson: Pretty much everything you're used to from other languages can be done in Haskell.
21:24:14 <Cale> dhotson: yeah, typically we write them ourselves, but the libraries also provide lots of useful loops
21:24:15 <ddarius> dmwit: What can't be done?
21:24:17 <dhotson> riight.. so you use recursion to kind of fake a loop?
21:24:20 <dmwit> dhotson: You might just get a little bit of a surprise about exactly the syntax looks.
21:24:30 <Cale> loop = do print "Hello"; loop
21:24:44 <ddarius> fix (print "Hello" >>)
21:24:49 <aluink> Cale: argh..what you said did help, but i'm still lost as to what i need to do to solve my problem
21:24:50 <dhotson> is that infinite recursion? wouldnt you run out of stack space?
21:25:02 <Cale> aluink: You should read my short tutorial on IO
21:25:09 <dmwit> dhotson: Tail recursion for the win!
21:25:10 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
21:25:12 <lambdabot> Title: Introduction to IO - HaskellWiki
21:25:22 <shrughes> > evalState (replicateM_ 10 (modify (^ 2))) 2
21:25:23 <lambdabot>   ()
21:25:27 <dhotson> oh awesome.. thanks for the link :)
21:25:32 <Cale> dhotson: The stack in Haskell is used for something entirely different from what it's used for in strict languages.
21:25:36 <shrughes> > evalState (do { replicateM_ 10 (modify (^ 2)) ; get }) 2
21:25:37 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
21:25:38 <gnut> does haskell have an equivalent of python's scipy? a well-supported mathematical package?
21:26:02 <dmwit> ?where hackage
21:26:02 <lambdabot> http://hackage.haskell.org/
21:26:03 <Cale> dhotson: It's basically used when searching through an expression tree for the outermost reducible subexpression.
21:26:05 <dhotson> ok, I think I kinda get the idea. Also another slightly more open ended question. :)
21:26:14 <Cale> (or expression graph, more correctly)
21:26:55 <dhotson> .. I'm used to designing things in an OO way. Is there something kind of equivalent in haskell... how would I model a 'Dog' object for example?
21:27:05 <dmwit> gnut: Well, there's a Math section on Hackage, maybe you should start there.
21:27:06 <shrughes> dhotson: what's a Dog?
21:27:13 <gnut> dmwit: i did... :(
21:27:25 <gnut> i was just hoping something was ouut there and the page was outdated :)
21:27:25 <dhotson> can I have something like a class... with instance variables etc?
21:27:28 <shrughes> dhotson: pretty much the same way you'd do in OOP, for examples like that
21:27:31 <dhotson> and methods?
21:27:53 <shrughes> data Dog = Dog { furColor :: Color, age :: Double }
21:27:54 <Cale> dhotson: Well, Haskell is not an OO language
21:27:54 <gnut> i fear using small packages because i'm afraid (like some of the previous opengl stuff on haskell) that the guy will graduate
21:27:59 <gnut> and things will get stale
21:28:06 <dhotson> eg. dog.bark()
21:28:08 <shrughes> bark :: Dog -> IO ()
21:28:16 <Cale> dhotson: But you can define datatypes, and those datatypes may have functions as fields.
21:28:18 <gnut> i've been writing my own functions, but a scipy that's maintained would be really nice :)
21:28:29 <shrughes> bark _ = putStrLn "Hey hey hey!\n"
21:28:40 <dhotson> Cale: ahh right.. that's what I was wondering... so you can attach behavior to Types?
21:28:53 <jsn> dhotson: there's more than one way to do that, though
21:28:57 <Cale> dhotson: You do so mostly by writing functions which consume and produce them.
21:29:15 <Cale> dhotson: But datatypes can also carry functions around internally, because functions are not special.
21:29:21 <dhotson> ahh ok kinda like function bark(Dog) returns Dog ?
21:29:34 <jsn> dhotson: or returns a bark?
21:29:41 <shrughes> it doesn't return Dog, it returns an action that would bark
21:29:47 <shrughes> (in my implementation)
21:29:58 <path[l]> hello
21:30:03 <gnut> hi
21:30:11 <Cale> data Dog = Dog { furColor :: Color, age :: Double, bark :: IO () }
21:30:18 <jsn> path[l]: welcome. the only limit is yourself
21:30:40 <Cale> poochy = Dog { furColor = white, age = 5, bark = putStrLn "Arf!" }
21:30:40 <shrughes> dhotson: you can attach behavior to types -- but you generally don't attach it to objects of a given type
21:30:48 <dhotson> ohh ok.. that looks pretty close to a class in curly brace languages :)
21:30:58 <path[l]> lol is that an auto message?
21:31:03 <shrughes> dhotson: except when you manually make it a field, like in Cale's example
21:31:09 <jsn> dhotson: however, you might want to look at type classes
21:31:40 <jsn> because that is how you can define an interface (sort of) that many types are compatible with
21:31:53 <dhotson> so what would the haskell code to call bark look like? poochy.bark ?
21:32:06 <shrughes> bark poochy
21:32:11 <Cale> rover = Dog { furColor = red, age = 7, bark = (do putStrLn "Woof."; eraseHardDrive) }
21:32:11 <jsn> hehe
21:32:25 <dhotson> hmm.. so the function comes first?
21:32:30 <Cale> dhotson: right
21:32:46 <jsn> <something>.<something else> is composition
21:32:46 <Cale> dhotson: Field names automatically define functions for extracting those fields.
21:32:59 <rherrmann> Side-effectful dogs may launch missiles ;-)
21:33:01 <dhotson> heh.. eraseHardDrive.. nice one :P
21:33:15 <gnut> rherrmann: heheh... i just read that interview
21:33:19 <dhotson> ahh, so that's kind of a convinience thing?
21:33:26 <Cale> (and since they're functions, you apply them like any other)
21:33:32 <shrughes> in soviet haskell, you bark the dog (and launch missiles) :/
21:33:36 <Cale> Yeah, just convenience, you could also pattern match.
21:33:47 <rherrmann> gnut: read SPJ's chapter of Beautiful Code
21:33:50 <gnut> in soviet haskell, dog barks you
21:33:58 <dhotson> ok cool
21:34:00 <gnut> rherrmann: okay. must find that book
21:34:03 <rherrmann> gnut: lol, great analogy
21:34:35 <Cale> dhotson: Note that IO actions, being values, can be put into datastructures, just like we've shown here.
21:34:47 <Cale> dhotson: They can also be manipulated by functions.
21:34:54 <Cale> For example...
21:34:55 <rherrmann> gnut: it's avalilable online (legally)
21:35:10 <gnut> looking for it
21:35:12 <dhotson> Anyway.. I've gtg. Thanks for all your help guys, you've been truly fantastic. I'm still a little confused about some stuff... but at least I've got the gist of it. Thanks for being patient with me. :D
21:35:17 <Cale> oh, okay :)
21:35:25 <dhotson> I'll have some more questions next time for sure :D
21:35:33 <Cale> dhotson: no problem, hope we'll see you again soon :)
21:35:42 <shrughes> more like "grasped" than manipulated
21:35:48 <dhotson> .. may I ask.. what kind of cool stuff are you guys working on anyway? :)
21:36:07 <Cale> shrughes: Well, there are lots of nice operations, like >> and replicateM and such :)
21:36:17 <dhotson> any interesting projects going on?
21:36:34 <rherrmann> dhotson: once you get past monads and monad transformers everything will be fine, it's like a rite of passage
21:36:47 <shrughes> Cale: right, i feel like "manipulate" sort of means you can break into them and look inside
21:37:24 <shrughes> for example, you don't manipulate a tennis ball -- you just whack it
21:37:28 <Cale> shrughes: depending on your point of view, >>= gives you just a touch of that.
21:37:38 <Cale> But right, you can't properly see inside.
21:37:56 <shrughes> if you whack it hard enough i guess you could achieve manipulation :o
21:38:43 <Cale> and depending on whether you're willing to import  System.Unsafe.Necronomicon
21:40:41 <aluink> Cale: thanks for that tutorial...was enlightening...but i'm still at a lost for a solution...sorry ;)
21:41:22 <shrughes> hrm... so here's an OT rambling... say you have a language without returning -- you have to use continuation passing style
21:41:25 <aluink> >>= felt like it would help, but i can't get it to fix things
21:41:40 <shrughes> echoLine cc = getLine (\line -> putStrLn line cc)
21:42:10 <dmwit> aluink: (>>=) lifts functions into a monad.
21:42:16 <shrughes> and procedures have arities from 0 to n -- so getLine has arity 1, putStrLn has arity 2
21:42:41 <dmwit> aluink: So, if you have a function that takes a pure value, and turns it into an IO action, then you can use (>>=) to turn it into a function that takes an IO value and turns it into an IO action:
21:43:05 <dmwit> :t \(f :: a -> IO ()) (x :: IO a) -> x >>= f
21:43:06 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
21:43:06 <lambdabot>       unless the pattern has a rigid type context
21:43:06 <lambdabot>     In the pattern: f :: a -> IO ()
21:43:10 <Cale> dmwit: While correct, that is a strange way to think about it. :)
21:43:16 <dmwit> It is how I think about it.
21:43:28 <shrughes> if you allow syntax for partial evaluation, i.e. (f x) is equivalent to (\y -> f x y) if f has arity 2, you can pretty much get nice syntax, albeit with call-by-name performance
21:43:28 <dmwit> :t \f -> (>>= f) -- my worldview
21:43:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
21:43:40 <dmwit> (a -> m b) -> (m a -> m b)
21:43:56 <dmwit> It's like map, but for Monads.  and more different
21:44:05 <Cale> aluink: Okay, let's have a look at your specific problem.
21:44:23 <shrughes> if you go *poof; use lazy evaluation* (and add datatypes, newtype, etc, sure) you have haskell
21:45:07 <Cale> aluink: where was that paste again?
21:45:14 <aluink> http://pastebin.com/m3d3a3f2c
21:45:14 <Cale> aluink: Or do you have more recent code?
21:45:25 <aluink> yes...that's more recent
21:45:37 <aluink> though not closer to any solution
21:45:56 <aluink> my problem is how to deal with the "print" line in doCommand:88
21:46:43 <aluink> try not to look at how printBoard works...i know it's ugle and surely not the best way of doing what i'm doing
21:48:05 <aluink> startingBoard :: Int -> Int
21:48:27 <Cale> http://pastebin.com/m4e9e796c
21:48:29 <aluink> startingBoard returns the piecevalue at a given index for the starting position of a chess game
21:49:27 <Cale> aluink: have a look there...
21:50:07 <aluink> yeah, i think i tried going something like that...but i guess i didn't the finess to see it through
21:50:25 <telexicon> weapon finesse
21:51:12 <aluink> i think what i tried was to turn EVERY Board into an IO Board...but that was causing problems when i tried to actually evaluate that Board...cause, like you said IO Board !(::) Board
21:51:47 <Cale> aluink: of course, you might want to refactor that now :P
21:52:03 <aluink> i'll make it work first ;)
21:52:14 <Cale> aluink: I sort of did almost the minimal thing to make things at least conceptually right :)
21:52:36 <aluink> i have class in 7hrs with a test in 8.5...i need to make this work so i can sleep ;)
21:52:59 <Cale> b == []  is okay, but should usually be avoided in favour of the function null, or pattern matching
21:52:59 <rwbarton> aluink: a good rule of thumb is that if you have a function of type X -> Y -> Z but you want to make it able to do IO, change the type to X -> Y -> IO Z
21:54:03 <Cale> But you should generally design your program so that most of the interesting bits where real computation is happening are pure, and the stuff which is in IO is the parts related to input and output.
21:54:10 <aluink> and do the little trick Cale did in my processCommands with <-
21:54:26 <aluink> yeah, i'm trying to do that
21:55:31 <Cale> Inside a do-block, you can have a line like   let foo = bar   (without the 'in' part) which defines foo to be the same as bar. It's handy for doing pure stuff.
21:55:35 <dmwit> I would recommend "You Could Have Invented Monads (and Maybe You Already Have)" if you have a bit of time, or "The IO Monad for People Who Simply Don't Care" if you're in a rush.
21:55:55 <rwbarton> aluink: right, that type change will have effects elsewhere, but it tells you what direction to go in
21:56:11 <johnnowak> So easy, even a ruby programmer could do it!
21:56:13 <dmwit> The first uses the (a -> m b) -> (m a -> m b) view of the world; the second uses the "just get it to compile" view of the world. =)
21:56:51 <aluink> SWEET, it works, thank you so much...now i need to go explore this more...tomorrow ;)
21:56:55 <Cale> I actually kind of find myself a little upset with most monad tutorials, in that most of them never actually mention the purpose of the monadic abstraction.
21:57:09 <johnnowak> all the ones i've seen are quite poor
21:57:15 <Cale> If you're just interested in I/O, there's no need to know that it's a monad, or what a monad is.
21:57:31 <johnnowak> it's just something you have to deal with rather than a very powerful concept you can use for all sorts of things
21:57:40 <Cale> (and that's not a "just get it to compile" view of the world, it's just a view which is restricted to IO)
21:57:42 <dibblego> Cale, I absolutely agree. So when are you writing yours? :)
21:57:49 <Cale> dibblego: I've written 3 already.
21:58:16 <Cale> My monad tutorial for monad tutorial writers is here: http://www.haskell.org/haskellwiki/Monads_as_Computation
21:58:18 <lambdabot> Title: Monads as computation - HaskellWiki
21:58:39 <Cale> (but it tries to be comprehensible to beginners with a grasp of the basics as well :)
21:59:23 <Cale> In short, the point of defining anything as a monad is so that we can reuse code. (Just like any good abstraction.)
21:59:40 <Cale> Specifically, all that stuff which is sitting in Control.Monad, for a start.
21:59:45 <aluink> i'm so glad this is being logged ;) i'll need this as a starting point tomorrow
21:59:52 <aluink> g'night all
21:59:56 <Cale> g'night :)
21:59:56 <dibblego> by implementing Ord, you pick up sort. By implementing Monad you pick up mapM et. al. someone needs to say that
22:00:01 <Cale> yeah
22:01:22 <Cale> It's also important to point out, I think, that the fact that IO happens to be a monad in Haskell is inessential. We could use any sort of combinator library which represented actions as values.
22:01:52 <Cale> The value of recognising it as a monad is exactly the fact that we get all the good stuff from Control.Monad for free.
22:02:32 <dibblego> good luck explaining that :)
22:02:44 <Cale> I just did, didn't I? :)
22:02:59 <Cale> Well, with a beginner, I would usually do examples.
22:03:10 <Cale> I find sequence is particularly enlightening.
22:03:21 <dibblego> yes I have found that with beginners too
22:03:23 <Cale> (followed by something like forM)
22:03:35 <telexicon> interesting
22:03:46 <telexicon> the haskell process is an abstract entity
22:04:07 <telexicon> and there are IO points, but it is otherwise totally independent from our world
22:04:21 <Cale> yep :)
22:04:46 <telexicon> lame
22:04:50 <b7j0c> <b7j0c> let us say i have a function f that evaluates its single input and
22:04:50 <b7j0c>         returns and "Either" retval, (Left e) being the error case, (Right a)
22:04:50 <b7j0c>         being the nonerror case. now lets say i want to sequence calls to f on
22:04:50 <b7j0c>         various inputs. using "mplus" to sequence these calls will pick a
22:04:53 <b7j0c>         (Right a) result from any of the calls. using ">>" will do what you
22:04:56 <Cale> Heh, it's even funnier when you think of a Haskell program as simply being a point in the space of IO values.
22:04:56 <b7j0c>         expect...but what i want is a "short circuit". if the first call to f
22:04:58 <telexicon> huh
22:05:00 <b7j0c>         in a sequence of calls  [22:04]
22:05:03 <b7j0c> <b7j0c> should return (Left e'), i want that to be the result of the sequence
22:05:06 <b7j0c>         of calls, with no other calls to f in the sequence executed. how do i
22:05:09 <b7j0c>         do this? thanks!!
22:05:19 <Cale> b7j0c: ...
22:05:21 <telexicon> you suck at life
22:05:33 <Cale> telexicon: huh?
22:05:49 <telexicon> huh?
22:06:03 <dmwit> b7j0c: That's exactly what (>>) does.
22:06:15 <dmwit> > Left "wrong! you cheating scum" >> Right 3
22:06:16 <lambdabot>   Left "wrong! you cheating scum"
22:07:06 <b7j0c> hi dmwit...i have a sequence of calls that all return errors of different types...at the end of the sequence i spit out the error...its the error from the last vcall in the sequence, which should have never been called
22:07:33 <dmwit> Sounds like you have a bug.
22:07:45 <b7j0c> indeed
22:07:48 <dmwit> I suggest making sure that the earlier calls really don't return an error.
22:08:05 <dmwit> Also, this "errors of different types" thing sounds highly suspect.
22:08:06 <rwbarton> you can't have a sequence of things joined with >> that "return errors of different types"
22:08:08 <Cale> or really *do*?
22:08:23 <dmwit> Cale: That's what I meant, thanks.
22:09:10 <b7j0c> sorry, a bad explanation...i meant "data E = E1 | E2 | E3"
22:09:24 <Eridius_> b7j0c: so they're all errors of type E
22:09:29 <dmwit> Ah, errors with different *values* is a totally different story. =)
22:09:40 <b7j0c> yes exactly Eridius, my poor explanation
22:09:40 <rwbarton> > Left "foo" >> Left "bar" >> Right 3 >> Left "baz"
22:09:41 <lambdabot>   Left "foo"
22:10:03 <b7j0c> hmmm...well i can't argue with lambdabot!
22:10:17 <dmwit> ?vixen nuh-uh!
22:10:18 <lambdabot> you're turning me on :)
22:10:19 <Eridius_> b7j0c: maybe you're doing this in the wrong monad?
22:10:20 <b7j0c> okay as dmwit says i have a bug. thanks for the help!
22:10:52 <b7j0c> Eridius: i am using Either....i presume that is appropriate
22:11:45 <Eridius_> b7j0c: just a thought, seeing as how you haven't actually provided code
22:11:50 <dan_> @hoogle <-
22:11:51 <lambdabot> keyword <-
22:11:57 <dan_> keyword <-
22:11:59 <dan_> no?
22:12:00 <dan_> :s
22:12:21 <b7j0c> i would Eridius, but its longish and i figured a contrived distillation would get me to an answer faster.
22:12:26 <dmwit> dan_: Yes, <- is a keyword.
22:12:39 <dmwit> i.e. syntax
22:12:42 <dan_> whats the name of that operator
22:12:44 <b7j0c> well thanks all! have a good one
22:12:56 <dan_> other than reverse arrow
22:12:59 <dmwit> dan_: I'm not sure; maybe "binds" would be a good way to pronounce it.
22:13:14 <dan_> :t <-
22:13:15 <dmwit> or "bound to", more like
22:13:15 <lambdabot> parse error on input `<-'
22:13:20 <dan_> right
22:13:31 <dmwit> dan_: ...it's not a function.  It's a keyword. ;-)
22:13:32 <dan_> but it's calle monadic binding or something
22:13:34 <dan_> i'm trying to remember
22:13:42 * dmwit nods
22:13:53 <dmwit> Anybody here would know what you were talking about if you called it monadic binding.
22:14:25 <dmwit> Names are not so important, except for communication.
22:14:38 <rwbarton> Here we usually just call it <- :)
22:15:21 <dan_> ;)
22:18:40 <b7j0c> oin #haskell
22:19:04 <dmwit> Welcome back. =)
22:19:17 <b7j0c> okay! i have a concrete malexample:
22:19:21 <b7j0c> f t s = if t then return (Right s) else return (Left s)
22:19:32 <b7j0c> main = ((f False "a") >> (f True "b") >> (f False "c")) >>= (\r -> print r)
22:19:35 * dmwit chuckles
22:19:40 <rwbarton> too much return
22:19:43 <dmwit> You *are* operating in a different monad.
22:20:06 <Eridius_> b7j0c: check the type of f
22:20:08 <dmwit> f t s = if t then Right s else Left s
22:20:11 <rwbarton> wait how does that even compile?
22:20:21 <rwbarton> :t \f r  -> ((f False "a") >> (f True "b") >> (f False "c")) >>= (\r -> print r)
22:20:22 <Eridius_> rwbarton: it's operating in the IO monad
22:20:22 <lambdabot> forall t a. (Show a) => (Bool -> [Char] -> IO a) -> t -> IO ()
22:20:28 <rwbarton> oh duh
22:20:51 <rwbarton> (I converted >>= to flip ($) in my head)
22:21:05 <dmwit> print (f False "a" >> f True "b" >> f False "c")
22:21:11 <rwbarton> where by converted I mean unsafeCoerce#d
22:21:35 <b7j0c> okay so i see i have Either inside another monad M, namely IO (???)
22:21:38 <dmwit> rwbarton: Yeah, you were automatically fixing bugs, and then being confused because the fixed version didn't have the problem b7j0c was complaining about. =)
22:21:52 <b7j0c> \print (f False "a" >> f True "b" >> f False "c")
22:21:52 <dmwit> b7j0c: yup, that's the "return"s fault.
22:22:00 <rwbarton> Right, it didn't compile because there was an ambiguous type variable 'm' :)
22:22:01 <dmwit> b7j0c: return is a *function* that puts a value into any monad.
22:22:24 <b7j0c> oooooh. i see
22:22:29 <dmwit> b7j0c: (It's not necessary to call return just to return a value from a function as it is in other languages.)
22:22:36 <Eridius_> rwbarton: I thought it did compile, m being resolved to IO because of main
22:22:43 <path[l]> Im still learning through haskell. Going through a really neat textbook here -> http://book.realworldhaskell.org/.
22:22:44 <path[l]> Have people seen it?
22:22:46 <rwbarton> I mean this "didn't" compile:
22:22:48 <Eridius_> rwbarton: his problem was it didn't obey the normal semantics of the Either monad
22:22:55 <dmwit> path[l]: Yes, RWH is very nice.
22:22:58 <lambdabot> Title: Real World Haskell
22:22:58 <rwbarton> :t print ((f False "a") >> (f True "b") >> (f False "c"))
22:22:59 <lambdabot>     No instance for (Show (m b))
22:23:00 <lambdabot>       arising from a use of `print' at <interactive>:1:0-53
22:23:00 <lambdabot>     Possible fix: add an instance declaration for (Show (m b))
22:23:08 <b7j0c> but i thought i needed to call "return" when i return a value from a monadic functoin
22:23:20 <path[l]> but I just finished chapter 3 and I was surprised by the sudden jump in complexity
22:23:24 <dmwit> b7j0c: Not if you're putting it in the monad yourself.
22:23:24 <path[l]> with the problems
22:23:32 <path[l]> The first 11 were trivial
22:23:35 <path[l]> and then boom!
22:23:43 <rwbarton> b7j0c: this is a common confusion if you've only played with the IO monad
22:23:52 <b7j0c> oh, so if i might ask for a little spoonfeeding, how might i write f properly? just omit return??
22:23:57 <Eridius> b7j0c: yeah
22:24:00 <rwbarton> b7j0c: the constructor for the IO monad is hidden, you can only create interesting actions by calling print and so on
22:24:08 <b7j0c> ah
22:24:14 <dmwit> b7j0c: You could also write "f t s = if t then Left s else return s", for example.  See if you can see how this corresponds...
22:24:20 <rwbarton> b7j0c: but in general that needn't be the case.  for the Either s monad the constructors are Left and Right and you can use them however you like
22:24:28 <b7j0c> thanks Eridius, dmwit, rwbarton!
22:24:46 <dmwit> path[l]: Lightbulb moments are the BEST! =D
22:24:47 <Eridius> f :: Either String a; f t s = if t then fail s else return s
22:25:05 <dmwit> Eridius: couldn't match expected type
22:25:27 <Eridius> dmwit: yeah I cheated and didn't put a real type expression there :P
22:25:33 <b7j0c> yes i have lightbulb moments in this channel often
22:25:58 <dmwit> path[l]: Oh, wait, you're complaining about the exact opposite phenomenon.
22:26:09 <dmwit> path[l]: Well... is there a particular thing you're finding tricky?
22:26:24 <b7j0c> well thanks again folks! have a good one
22:26:28 <dmwit> path[l]: There's a pretty helpful crowd in here, and the three authors of that book have been known to show their faces from time to time...
22:26:54 <path[l]> no not at the moment. I got through it. But the problem before it was actually a bit umm
22:26:58 <path[l]> whats the word
22:26:58 <Cale> path[l]: That was written by bos, dons, and CosmicRay, if I have my nick <-> name mapping right :)
22:27:04 <path[l]> puts you on the wrong path
22:27:09 <path[l]> ah cool
22:27:25 <dmwit> "misleading"
22:27:45 <path[l]> yeah sorry I dont know what happened suddenly. Couldnt get the word I wanted
22:27:52 <dmwit> The non-beta version might also have a rewording of some stuff.  They collected a lot of comments about the book.
22:28:22 <path[l]> I added a comment to that problem actually, and given how the number of comments suddenly drop I wonder if a lot of people skipped that problem
22:28:39 <path[l]> but looking at my solution my BIGGEST problem was I didnt know how to name things :/
22:29:29 <Cale> path[l]: Which question did you find misleading?
22:29:33 <juhp> what are the default values for cabal's htmldir and interfacedir (haddockdir)?
22:30:15 <path[l]> Cale:  question 11 on chapter 3 suggests people make a function that given a list of points to return a list of directions.
22:30:57 <juhp> I guess haddockdir = htmldir
22:30:57 <path[l]> So question 12 then asks people to solve graham's scan problem. Given how the last 3 questions had been working to that I assumed Id have to use this function. But it turns out that you can't make use of that approach
22:31:00 <juhp> which is enough for me
22:32:33 <Cale> path[l]: hmm, well, it's certainly not completely unrelated...
22:33:08 <rwbarton> path[l]: You can certainly use your answers to 9 and 10.  You may well be right about 11 though.
22:33:27 <path[l]> no infact thats the problem. If it was Id have recognised it instantly. But I first ended up trying to solve it using the previous function. And after I was done I realised the solution I had was wrong
22:33:31 <path[l]> rwbarton: yeah thats true
22:33:36 <Cale> Hmm, it seems to me that the answer to 11 should be usable.
22:33:45 <Cale> er, 10
22:33:52 <path[l]> 9 and 10 are usable
22:33:52 <Cale> no, 11 :)
22:34:39 <Cale> Because as the Wikipedia article explains, you construct a list of points sorted in a particular way, and then remove the ones at which the turn is in the wrong direction.
22:34:41 <path[l]> Ive pasted my solution to 12 on the book comments and when I look at it now the worst part for me is the ugly names lol
22:35:45 <path[l]> Cale:  yeah I tried to solve it by converting a list of points to a list of tuples of points and directions, dropping the ones not turning left and unzipping it to get points
22:35:50 <path[l]> But it turns out thats wrong
22:35:57 <Cale> So you could imagine doing this by first constructing the appropriate list of points, and then zipping it with the list of turns, and then filtering that by picking the ones which have the right direction.
22:36:07 <Cale> Why doesn't that work?
22:36:36 <rwbarton> Cale: ABC is a left turn in the example, and B is on the convex hull.
22:36:46 <Cale> Oh, so you have to drop one.
22:36:53 <rwbarton> Cale: But imagine moving D up a lot, then ABC would still be a left turn, but B is no longer on the convex hull.
22:37:05 <path[l]> because if I add a point "a" because it turns left to point "b". And point b is then dropped because it turns right to point "c", I might have to drop "a" because it now turns right to point "c"
22:37:33 <Cale> rwbarton: Ah, so you have to do it iteratively?
22:37:39 <path[l]> yeah
22:37:56 <rwbarton> Cale: yeah, I think that would work.  It's unclear whether that would deserve to be called Graham's algorithm though :)
22:38:27 <rwbarton> In particular it might not perform the scan in O(n) time
22:38:50 <path[l]> actually if anyone here has got a few minutes could you take a look at what Ive done and tell me if there's some big trick Ive missed?
22:39:23 <Cale> It is extremely unfortunate that the RWH comments appear to discard indentation.
22:39:30 <path[l]> yeah
22:40:42 <Cale> I would have written  ydiff (x,y) (x',y') = y' - y
22:40:59 <Cale> It's clearer what's going on when you pattern match :)
22:42:02 <path[l]> ah
22:42:31 <path[l]> yeah
22:43:39 <Cale> It mostly seems quite reasonable though, at least style-wise, though the names are sort of subtle -- I almost didn't see the one-letter change between grSort and gsSort
22:43:58 <Cale> oh, and you have both gScan and gscan...
22:44:12 <Cale> That's a bit strange :)
22:45:28 <path[l]> yeah with recursive functions I keep wanting to provide a wrapper that does not need the accumulator
22:46:16 <rwbarton> how about,  gscan xs = gscan' [] (bottom : sortBy gCompares rest) where (bottom : rest) = sort xs; gscan' xs [y] = y : xs; ...
22:46:55 <Cale> In those cases, we usually name the version with the accumulator with a name ending in ' and usually end up sticking that into a where-clause (unless it's more generally useful)
22:47:04 <path[l]> ah
22:47:51 * lispy is found of _aux
22:47:53 <rwbarton> (gCompares should have been (gCompares bottom))
22:48:02 <lispy> I grew unfond of ' on accumulators
22:48:11 <lispy> but mostly because CPP doesn't like ' in identifiers
22:48:15 <path[l]> what does bottom : rest mean?
22:48:19 <Plareplane> how about _ then?
22:48:44 <rwbarton> bottom : rest = sort xs is a pattern match
22:49:10 <path[l]> oh head + rest?
22:49:13 <path[l]> ok
22:49:22 <path[l]> ah I see how that makes it smaller
22:49:22 <rwbarton> right. just like the argument to grSort
22:49:27 <Cale> I tend not to use _ in my variable names (excepting that convention where it means you're throwing away the result of a computation)
22:49:45 <rwbarton> use #, then people probably won't call the wrong function
22:50:04 <Cale> Can you normally use # ?
22:50:05 <Plareplane> oh i missed that lispy already said he was fond of _. i didn't quite understand "found of _aux"
22:50:14 <rwbarton> Only with -XMagicHash :)
22:50:20 <Cale> Right.
22:51:13 <path[l]> I found myself ending up using some ideas that are explained in the next chapter
22:51:22 <path[l]> mostly because I kinda expected them to exist
22:51:56 <lispy> I wonder what haskell would be like if we had agda style operators where _ can appear in the name as an argument place holder...so that you can define if_then_else_ :: Bool -> a -> a -> a
22:52:03 <path[l]> but I was wondering if I have function a b c d, can I curry it on any specific argument and get a function of a b d? Or is it only on the first argument?
22:52:18 <lispy> then use it as, if b then a1 else a2
22:52:25 <dibblego> @pl \a b c d -> a b d c
22:52:25 <lambdabot> (flip .)
22:52:58 <Cale> path[l]: you can write a lambda, basically
22:53:08 <Cale> path[l]: But it's not quite the same as currying.
22:53:17 <rwbarton> data Then; then :: Then; then = undefined; data Else; else :: Else; else = undefined; if :: Bool -> Then -> a -> Else -> a; if = ...
22:53:22 <path[l]> ah so its like a wrapper?
22:53:24 <Cale> (there's a very subtle possible difference)
22:53:28 <Cale> yeah
22:53:37 <path[l]> aww ok
22:53:58 <Cale> It's possible that the function a can do some work after it gets its first parameter
22:54:24 <path[l]> Ive seen you can do it on the first n arguments or on the second argument of a binary function. I was hoping there was a neat way to do it for any set of arguments
22:54:48 <Cale> and even if it's also possible that it could have been written to take the second parameter first and do work after getting that one, just swapping them around with a lambda won't likely do that for you.
22:55:25 <Cale> Parameter order really matters in Haskell. You want to put the parameters in increasing order of rate of change.
22:58:13 <Cale> Compare the performance of:
22:58:17 <Cale> let f x y = product [1..x] + y in map (f 10000) [1..10]
22:58:24 <Cale> let g x = let u = product [1..x] in \y -> u + y in map (g 10000) [1..10]
22:58:55 <Cale> (the optimiser might actually make that change itself, if you're compiling with optimisations.)
23:00:41 <Cale> It does affect memory usage in general though, so I'm not 100% sure about it.
23:01:56 <Cale> Unless you have too fast a machine, you can see that g 10000 gets evaluated first, and product [1..10000] gets shared between subsequent calls of that function.
23:02:14 <Cale> But in the first case, it will evaluate product [1..10000] every time.
23:02:53 <Cale> (that is, 10 times over)
23:03:39 <Cale> In any event, functions which have their parameters in the right order are amenable to this kind of optimisation.
23:06:00 <Cale> As a more practical example, you can imagine a regular expression library where the matching function took the regular expression as the first parameter, and compiled it into a function which used a DFA to match strings. That translation might be a lot of work, and so you'd want to be able to save the partial application.
23:08:46 <Cale> path[l]: Does that make sense?
23:09:24 <Cale> oh, you got disconnected?
23:09:25 <Cale> heh
23:09:39 <Cale> I was starting to feel like I was talking to myself :)
23:09:47 <path[l]_> hmm I see thanks. Sorry got disconnected
23:09:49 <path[l]_> last thing I saw was the bit about the regex library
23:10:01 <Cale> oh, you caught it all then :)
23:10:11 <Cale> I just asked if it was making sense :)
23:10:44 <path[l]_> Im wondering why in the first case the haskell compiler cant use the product[1...1000] after doing it once
23:10:56 <rwbarton> RWH uses the word "cromulent"
23:11:07 <Cale> Because in order to save memory, once that goes out of scope, it drops it on the floor.
23:11:54 <olsner> the compiler can do it (i.e. by haskell's semantics it's safe to do that moving), the problem is knowing if it's beneficial
23:11:57 <path[l]_> but isnt there enough information for the compiler itself to see that this is repeated. I thought that was the whole point of functional programming where the compiler has all the information it needs
23:12:03 <path[l]_> olsner:  ah
23:12:13 <Cale> The compiler (without optimisations at least) is not smart enough to realise that product [1..x] is constant in the second parameter, and lift it up so that after the first parameter is applied, you get a function where that constant is wired in.
23:14:05 <rwbarton> (BTW, if this is the whole program "main = let f ...", then ghc -O2 will only compute the product once)
23:14:32 <Cale> Yeah, I suspected as much.
23:14:58 <Cale> How about if the parameters are in the wrong order?
23:15:33 <Cale> It might even be smart enough to get that, but I would be more surprised :)
23:15:45 <rwbarton> Hmm, that broke it
23:16:07 <rwbarton> oops
23:16:28 <rwbarton> forgot to switch the order at the call site too :)
23:16:58 <rwbarton> main = print $ let f y x = product [1..x] + y in map (`f` 10000) [1..10]   -- only evaluates product [1..10000] once
23:17:19 <Cale> okay, it is smart enough then :)
23:18:16 <Cale> In the past, these things mattered more ;)
23:20:00 <rwbarton> I looked at the core without optimizations turned on--yuck
23:20:24 <rwbarton> It's all dictionary unpacking :P
23:20:33 <Cale> I wonder if it's smart enough to specialise on both parameters.
23:20:42 <mm_freak> is there a good place to have tutorials reviewed?
23:21:41 <rwbarton> Of course it is, the definition is inlined and product [1..10000] is a CAF and everything. :)
23:21:44 <rwbarton> (with -O2)
23:21:56 <Cale> ah, right.
23:22:18 <Cale> Actually, even when 10000 is not a constant, it's good enough.
23:22:48 <Cale> er...
23:24:04 <rwbarton> It's really hard to say how GHC will compile a function, because things might get inlined into it, or it might get inlined elsewhere, or specialized...
23:24:19 <rwbarton> by the time you look at the core, the function you thought you wrote has practically disappeared :)
23:25:52 <Cale> heh, interesting, GHC uses Text.ParserCombinators.ReadP to read Integers.
23:25:59 <Cale> (apparently)
23:26:58 <rwbarton> Yeah, you can discover all kind of weird stuff looking at ghc core
23:27:18 <Cale> I'm not sure that it did that with 6.8.2
23:27:52 <Cale> er, 6.8.1 rather?
23:28:37 <rwbarton> > (fromIntegral (-2^63) :: Int) `mod` (-1)
23:28:38 <lambdabot>   * Exception: arithmetic overflow
23:29:20 <Cale> uh, that's a curious result
23:30:14 <Cale> oh, hmm
23:31:22 <rwbarton> it makes "sense"
23:31:30 <Cale> I think I'd have to consider it a bug still.
23:32:03 <rwbarton> have you looked at the Integral Int instance source?
23:32:17 <Cale> Not yet.
23:35:15 <dhotson> Hey Cale, I've had a go at emulating some haskell stuff with javascript. (Lazy evaluation and all). The syntax isn't as nice though.. :-/
23:36:09 <dhotson> for example:
23:36:09 <dhotson> int = function(n) { return function() { return n } }
23:36:09 <dhotson> plus = function(a, b) { return function() { return a() + b() } }
23:36:55 <Cale> :)
23:36:56 <dhotson> .. so then I can do plus( int(2), int(6) )()
23:37:03 <johnnowak> ow
23:37:05 <dhotson> the final () is to force evaluation :D
23:37:08 <Cale> You could even curry the plus ;)
23:37:15 <dhotson> yeah but it looks awful :P
23:37:18 <Cale> hehe
23:37:28 <dhotson> so is that kinda whats going on in haskell?
23:37:40 <Cale> rwbarton: Oh, that's interesting, it's explicitly checking for that case and throwing an error.
23:37:50 <dhotson> your double example works too:
23:37:50 <dhotson> double = function(x) { return plus(x, x) }
23:37:51 <Cale> dhotson: Kind of. The effect is the same.
23:38:28 <dhotson> hehe cool... it's pretty fun to play around with :D
23:38:31 <Cale> mm... similar.
23:39:03 <Cale> You'd need to add static variables to every one of those functions which, once the result was computed once, would return the value that was computed immediately.
23:39:27 <dhotson> you mean like memoizing ?
23:39:38 <Cale> dhotson: Only of constants.
23:39:54 <Cale> Because if you say, have x = 3 + 5 in Haskell, and you write x + x, then 3 + 5 -> 8 is only computed once.
23:40:08 <dhotson> couldnt you do that for all functions though?
23:40:20 <dhotson> or is it better just to do it for constants?
23:40:28 <Cale> You could, sort of, but it would eat memory like crazy
23:40:38 <dhotson> ahh yep.. gotcha :)
23:40:40 <Cale> and you could basically never garbage collect anything
23:41:02 <dhotson> so it's kind of a space/time tradeoff?
23:41:05 <Cale> yeah
23:41:24 <dhotson> ah awesome.. I think I've kinda got the hang of this functional stuff
23:41:28 <dhotson> kinda tricky though
23:41:40 <Cale> Well, this is implementation details ;)
23:41:42 <hhiroavalon> Hi, can I get some hints on a problem on Haskell?
23:41:53 <Cale> Lazy evaluation says that the result of evaluating parameters to a function are shared between the copies of that parameter in the function body.
23:42:04 <Cale> hhiroavalon: sure!
23:42:05 <dhotson> yeah the end result ends up being quite elegant... but figuring out what is actually going on is hard to understand
23:42:29 <hhiroavalon> I want to convert an n-ary tree into a binary tree... something like this http://en.wikipedia.org/wiki/Image:N-ary_to_binary.svg
23:42:36 <dhotson> from my (newbie) perspective.. it's a little hard to see under the covers
23:42:45 <Cale> dhotson: I think the best mental model for the most part is the one in which you just manipulate expressions as text.
23:42:56 <dhotson> there's still a bit of magic going on
23:43:08 <Cale> Carrying out evaluation like I did with that double (double 5) example
23:43:20 <Cale> because that really isn't so far from how it actually looks in memory
23:43:27 <Cale> (of course, the strings aren't there)
23:44:36 <Cale> But you can imagine that there's a sort of directed graph representing the expression you're evaluating, and a process for replacing parts of that graph with other parts as things get evaluated.
23:45:07 <Cale> It's a little tricky to "see" that graph in the modern implementations, but it's still there.
23:45:20 <dhotson> hmm, actually... can you do stuff similar to lisp where they can manipulate code at runtime?
23:45:20 <Cale> hhiroavalon: okay
23:45:27 <hhiroavalon> I have "data Nary x = nNode x [Nary x]" and "data Btree x= Node x (Btree x) (Btree x) | MT"
23:45:31 <Cale> dhotson: you mean at compile time?
23:45:39 <Cale> (macros?)
23:45:59 <dhotson> Well from what I understand.. in lisp all the code is just made of lists... so you can build functions out of lists pretty much
23:46:00 <Cale> hhiroavalon: Data constructors must start with an uppercase letter.
23:46:24 <dhotson> or you achieve the same kind of thing with functions in haskell?
23:46:27 <Cale> dhotson: right. But they tend not to manipulate code explicitly at runtime, unless they're writing an interpreter.
23:46:29 <johnnowak> dhotson: in some lisps, there's no different between lists and functions at all. see pico lisp.
23:47:16 <hhiroavalon> Cale: yes, that seems to be a start...
23:47:16 <johnnowak> there's no lambda for the same reason
23:49:06 <Cale> hhiroavalon: okay, so you're effectively replacing each cons in the list of subtrees with a rightward branch
23:49:56 <Cale> (and the left subtree is obtained by converting the subtrees of that item)
23:52:07 <dhotson> Hey, thanks again Cale. See you next time! :D
23:52:11 <hhiroavalon> Cale: thanks for the hint, I'll try to pencil and paper some code for a while :)
23:52:27 <Cale> dhotson: no problem :)
23:52:35 <Cale> dhotson: See you around
23:57:01 <glguy> Is there a pragma I can add to a .hs file that will tell GHCi what libraries to link against when loading it?
23:59:50 <hhiroavalon> hmm... I don't know what to do with the root, I guess this is what is confusing me...
