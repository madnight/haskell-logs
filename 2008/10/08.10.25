00:05:19 <ivanm> with the listings code here, anyone know what the \csname stuff is for?
00:11:20 <quicksilver> ivanm: yes.
00:11:35 <ivanm> well, what is it for?
00:11:37 <ivanm> *sigh*
00:11:50 <quicksilver> csname is the tex way of constructing "symbol names" at runtime
00:12:04 <ivanm> whoops, forgot to paste the link... I meant the literate page on the wiki
00:12:20 <quicksilver> it's a long time since I was a texnician and I forget the correct terminology you're supposed to use
00:12:20 <ivanm> http://www.haskell.org/haskellwiki/Literate_programming#Listings_package <-- that's what I meant
00:12:22 <lambdabot> Title: Literate programming - HaskellWiki, http://tinyurl.com/y5klfa
00:12:45 <ivanm> I'm just wondering why that code snippet there sets and saves the label
00:12:59 <quicksilver> \csname lst@SaveFirstLabel\endcsname
00:13:02 <quicksilver> is the same as
00:13:13 <quicksilver> \lst@SaveFirstLabel
00:13:25 <quicksilver> except that '@' is probably not a legal character in a macro name
00:13:29 <ivanm> *nod*
00:13:31 <quicksilver> (at least, not at that point it isn't)
00:13:33 <ivanm> any idea what that's for there?
00:14:00 <quicksilver> well LaTeX convention is to use '@' for internal names
00:14:09 <quicksilver> crude kind of namespacing
00:14:17 <ivanm> *nod*
00:14:29 <ivanm> but why set and save the label?
00:15:36 <quicksilver> I'd need to check the source for listings ;(
00:15:44 <quicksilver> google search just finds that cargo culted all over the internet
00:15:58 <ivanm> yeah
00:16:47 <quicksilver> I'll see if I've got the listings doc installed locally
00:17:12 <ivanm> my guess is that it's to make it play nicely when trying to then run it through ghc, etc. ... but that's just a guess
00:18:21 <quicksilver> nice. my copy of xdvi bus errors.
00:18:33 <quicksilver> I probably haven't used tex since I switched from G4 to intel.
00:19:06 <ivanm> heh
00:21:45 <quicksilver> ivanm: something to do with automatic numbering and lettering of labels
00:21:55 <quicksilver> and not making it restart between sublistings?
00:22:00 <quicksilver> (or, possibly making it restart)
00:22:11 <quicksilver> it's not even in my copy of lstmisc.sty
00:22:18 <ivanm> ahhh, could be
00:22:19 <quicksilver> must be a relatively recent feature
00:22:23 <ivanm> thanks quicksilver
00:23:38 <ivanm> why, how old is your copy of tex?
00:23:53 <ivanm> (and it isn't mentioned in the docs of my recent copy of listings either...)
01:04:10 <RayNbow> @users
01:04:10 <lambdabot> Maximum users seen in #haskell: 547, currently: 475 (86.8%), active: 4 (0.8%)
01:04:24 <RayNbow> when will we hit the 600 mark?
01:04:35 <mm_freak> is there something like a mutable Map?
01:04:42 <mauke> preflex: calc '8 475
01:04:42 <preflex>  733
01:05:31 <ivanm> RayNbow: invite 53 friends to #haskell, and we will! :p
01:06:22 <Cthulhon> Them current/max counts are anagrams.
01:06:23 <RayNbow> ivanm: the problem is that I don't have 53 friends that are able or willing to join a certain IRC channel :p
01:06:30 <Cthulhon> *The
01:06:31 <ivanm> heh
01:06:41 <RayNbow> Cthulhon: nice observation :)
01:06:49 <ivanm> Cthulhon: they're also cyclic rotations :p
01:07:11 <ivanm> (then again, with 3-elements, anagrams are either cyclic or inverse-cyclic rotations anyway...)
01:08:45 * ubernostrum reads and actually understands why he done busted his stack with something that didn't look like it was recursive.
01:10:46 <Peaker> has anyone done some work on reconciling Haskell/pure-fp with capabilities?  Capabilities seems to be quite tied to the OO model..
01:11:07 <RayNbow> capabilities?
01:11:27 <ubernostrum> Peaker: I assume you mean capability-based security models?
01:11:37 <Peaker> ubernostrum: yeah
01:12:28 <ubernostrum> RayNbow: http://en.wikipedia.org/wiki/Capability-based_security <-- he means this, then ;)
01:12:29 <lambdabot> Title: Capability-based security - Wikipedia, the free encyclopedia
01:12:46 * ubernostrum can't say whether anyone's done such stuff with Haskell, but I do know a bit about the model itself.
01:12:50 <Peaker> yeah, I am not sure "capabilities" refers to anything else of interest :)
01:13:08 * RayNbow adds to reading queue
01:13:52 <RayNbow> (although my mental reading queue is not really a queue... more like an unsorted mess :p)
01:13:57 <ubernostrum> Peaker: I would guess that you could do a naive functional capability system based on having the capabilities be some actual data type, and passing around instances of them.
01:14:34 <ubernostrum> But I stress the word "naive" there ;)
01:15:03 <Peaker> RayNbow: capabilities are really simple, and make security much simpler and at the same time finer grained.  They let you truly implement POLA (Principle of Least Authority), which would mean that running random code (even arbitrary solitary actions) is only as dangerous as the authority you give it
01:15:59 <Peaker> I believe capabilities open up a new set of very interesting things you become able to do, such as automatic migration of objects between hosts for performance reasons
01:16:19 <ubernostrum> Peaker: I would wonder, though, whether you'd have to be quite careful doing it in Haskell, since you'd need to be strict about the capability itself (passing around a thunk just wouldn't be the same, ya know?).
01:16:21 <Peaker> ubernostrum: capabilities are about authority though, a data type conveys no authority
01:17:09 <Peaker> @src FileHandle
01:17:10 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:17:27 <ubernostrum> Peaker: well, take the simplest example, and model a capability as a type representing some object and some rights to access that object.
01:17:36 <Peaker> Lets say FileHandle is a data type that does not let you conjure into existence values, nor does it point to invalid files anymore after you close/re-open files
01:17:39 <jsn> Peaker: well, they might be a value, then
01:17:46 <ubernostrum> An algebraic type system is actually a little better suited to that sort of thing than a typical nominal OO system.
01:18:20 <Peaker> ubernostrum: who can make new values (new authority) of that type?
01:18:25 <jsn> yeah, if you used values than the type system could do nothing for you
01:18:35 <ubernostrum> Peaker: that's the tricky bit, isn't it? ;)
01:18:36 <jsn> s/than/then/
01:19:20 <jsn> ubernostrum: using types implies that introducing "new" authority tokens involves a hard reboot of the system
01:19:21 <Peaker> ubernostrum, jsn: If we consider "FileHandle" to be a capability, that means we want to not have any "open" function that creates a FileHandle (or any function that creates authority) be important in the global module namespace
01:19:33 <mm_freak> is Data.Map.Map intelligent enough for use as a mutable database?
01:19:48 <ubernostrum> jsn: depending on how you view your system's security, that might actually be a good thing.
01:19:49 <Peaker> s/important/importable heh
01:19:58 <ubernostrum> jsn: and, again, I stress "naive" here :)
01:19:59 <jsn> mm_freak: could you clarify a little? intelligent enough?
01:20:18 <mm_freak> jsn: so changing an element doesn't create a copy
01:20:20 <Peaker> An IORef/MVar/TVar seem like they're also capabilities
01:20:29 <jsn> ubernostrum: well, capabilities are pretty fine-grained -- the capability to open such-and-such file
01:20:43 <Peaker> mm_freak: An IOVar that points to one is a mutable database
01:20:43 <RayNbow> hmm, interesting stuff those capabilities
01:20:59 <mm_freak> Peaker: intuitively or technically?
01:21:04 <ubernostrum> jsn: yeah, but I'm simply coming at it from the perspective of "how would I design the simplest thing that'd work", to get a starting point.
01:21:13 <Peaker> mm_freak: both? :)
01:21:34 <jsn> mm_freak: i honestly don't know the right answer
01:21:46 <jsn> mm_freak: but i suspect updates do indeed make a copy
01:21:53 <Peaker> ubernostrum, jsn: I think capabilities are only interesting in the IO monad (and possibly ST because of ST vars)
01:21:59 <jsn> mm_freak: and putting it in an IOVar obviously will not change that
01:22:14 <mauke> they copy the path from the root to the element you're changing, not the whole map
01:22:21 <Peaker> updates of Data.Map/etc make a copy in theory, but in practice they share most of the tree
01:23:01 <mm_freak> so (modifyIORef db (\m -> update (Just . (+1)) someKey)) will definitely not create a copy?
01:23:05 <jsn> Peaker: well, the notion of permission to load a module might be meaningful -- but permission to evaluate a pure function, probably not
01:23:13 <mauke> mm_freak: depends on your definition of "copy"
01:23:27 <mm_freak> a copy of the entire structure in memory
01:23:34 <jsn> ubernostrum: one other thing to consider is that we need to invalidate capabilities rapidly, in the event of a breach
01:23:47 <mauke> no, it won't copy the entire Map
01:23:52 <mm_freak> theoretically it would create a copy and then garbage-collect the old one
01:23:53 <jsn> ubernostrum: so it is essential that capabilities be deletable online
01:23:54 <mm_freak> ok
01:24:14 <mauke> mm_freak: no
01:24:14 <Peaker> jsn: I don't think you want to have permission to load a module. I think you want modules to only contain authority-less code, and pass authority as arguments to actions
01:24:21 <mauke> it would create a copy of parts of the spine, then garbage collect
01:24:30 <mm_freak> is that only true for IORef?  or can i do the same by using recursion?
01:24:39 <Peaker> jsn: pass proxies to capabilities, and disable those proxies
01:24:40 <ubernostrum> Peaker: http://www.cis.upenn.edu/~lipeng/homepage/slides/lz06csfwtalk.ppt <-- this looks moderately interesting/relevant.
01:24:41 <mauke> this has nothing to do with IORef
01:24:45 <mm_freak> ah, ok
01:24:49 <mm_freak> thanks
01:25:06 <ubernostrum> (http://74.125.95.104/search?q=cache:vl17rYQzJ6AJ:www.cis.upenn.edu/~lipeng/homepage/slides/lz06csfwtalk.ppt as HTML)
01:25:08 <lambdabot> Title: Encoding Information Flow in Haskell, http://tinyurl.com/6j9fk8
01:25:17 <mm_freak> is it fast enough for a user database in a server?
01:25:45 <jsn> mm_freak: i think you are getting awful close to the part where we tell you to use SQLite :)
01:25:53 <mm_freak> (expecting thousands to hundreds of thousands of users, that is)
01:26:11 <jsn> mm_freak: uhm, no don't do that -- use a real database for that
01:26:25 <ubernostrum> Yeah, that's what real databases are for.
01:26:27 <jsn> learn to snapshot it, replicate it, &c.
01:26:32 <ubernostrum> They're quite good at it :)
01:26:51 <mm_freak> jsn: i don't mean a stored database, but an internal online information database
01:26:58 <ubernostrum> (or move up to something like PostgreSQL, and learn to do backups of it)
01:27:20 <jsn> mm_freak: you mean a cache?
01:27:35 <mm_freak> say, i'm writing an IRC server, so i need to keep track of the users
01:27:44 <mm_freak> sort of a cache, but i'd rather call it database
01:28:10 <mauke> should be doable
01:28:27 <jsn> mm_freak: okay, i understand better what you are doing
01:28:28 <mauke> preflex used to store all its information in a Map of Bytestrings
01:28:50 <jsn> mm_freak: my earlier remark was guided by concern for the data's durability as much as anything
01:28:56 <mm_freak> is there a better alternative than Data.Map?  (the keys will be nicknames or socket handles, i'm not sure yet)
01:29:39 <Peaker> ubernostrum: that's about information flow limitations, not capabilities, though
01:30:14 <ubernostrum> Peaker: that's part of the infrastructure for a capability system, though, unless I've really gone off the rails here.
01:30:47 <jsn> one thing that's irritating about capabilities is that identity is essentially meaningless in them
01:31:04 <jsn> if you have they keys, you have they keys -- doesn't matter who you are or how you got them
01:31:05 <Peaker> ubernostrum: I think its limiting information flow according to low/high classifications, which is very different from the capability approach
01:31:47 <jsn> whereas a system like ACLs can ban people or grant rights based on who they are, that's it -- and there's no way to transfer those rights
01:32:09 <Peaker> jsn: I guess if you remove all authority from all modules (so you are forced to pass authority by argument) you are pretty close to a capability system in Haskell already
01:32:38 <jsn> haskell is, i think, free of authority, at present
01:32:47 <Peaker> @hoogle FileHandle
01:32:48 <lambdabot> No results found
01:33:26 <mm_freak> when i write "listenOn … >>= \socket -> socket `seq` …", the socket is opened, right?  so i can check for errors at that point instead of at the point where i 'accept' connections
01:33:29 <Peaker> the action openFile contains ambient authority
01:33:39 <Peaker> ambient authority is the opposite of capabilities
01:33:54 <mauke> why socket `seq` ...?
01:34:07 <mm_freak> in other words, `seq` demands normal form, not just some weaker form of it
01:34:23 <mauke> what
01:34:24 <mm_freak> mauke: because nothing seems to happen, as long as i don't use 'socket'
01:34:38 <jsn> Peaker: uhm, what?
01:34:59 <mauke> I find that unlikely
01:35:05 <Peaker> jsn: The ability to use openFile is authority
01:35:06 <jsn> openFile delegates to the operating system for authority
01:35:21 <Peaker> mm_freak: IO actions are normally not lazy
01:35:38 <Peaker> jsn: And the operating system uses ambient authority as a security model
01:35:59 <Peaker> jsn: I'm thinking about building a capability system enforced by the language, on top of the horrible security provided by the OS :)
01:36:43 <jsn> Peaker: so your saying, because openFile does not accept a "rights" token with which to exercise the operation, it is relying on ambient authority
01:37:09 <Peaker> jsn: if you had a "rights" token (capability) to use a file, you wouldn't need open, you'd use that token itself for the operations
01:37:25 <jsn> Peaker: in an OO languages
01:37:26 <mm_freak> mauke: you were right
01:37:45 <jsn> Peaker: but it Haskell you'd perform an operation on the rights token
01:37:46 <Peaker> jsn: in other words, openFile converts a designator to a designator+authority. If you started with the latter, you don't need openFile
01:38:05 <jsn> Peaker: oh, i get it
01:38:13 <jsn> Peaker: but you'd use read, &c.
01:38:21 <Peaker> yeah
01:38:38 <Peaker> readFile does not convey any new authority, but lets you excercise authority that you have
01:38:49 <Peaker> but openFile conveys ambient authority from the OS
01:39:07 <jsn> and of course to manage the capabilities you'd have have 'getFileAuthority :: String -> IO (Maybe Authority)' to see if you have the right token
01:39:40 <Peaker> jsn: that goes against the spirit of capabilities - you'd never ever have a function converting a string to authority...
01:40:02 <jsn> Peaker: well how would you find the authority that goes with the file you are looking for?
01:40:17 <Peaker> you would receive it as an argument from someone who already had it
01:40:33 <jsn> but you have thousands of them
01:40:44 <jsn> how do you pick out the one for this particular file?
01:41:15 <Peaker> Well, consider a value that conveys authority to a directory in the file system, and a single operation on it:  listDirectory :: DirectoryAuthority -> [(String, FileAuthority)]
01:41:30 <Peaker> this operation does not return new authority, but authority that is already conveyed by the directory authority
01:41:41 <jsn> sure
01:41:51 <jsn> so then you have a lookup operation, like my 'getFileAuthority'
01:42:11 <Peaker> getFileAuthority would have to take all the authority in existence as an argument, and prune that which you do not want
01:42:19 <Peaker> that is different from creating new file authority
01:42:23 <jsn> right
01:42:26 <Peaker> (which openFile does)
01:42:49 <Peaker> btw: you could use Data.List.lookup directly
01:42:53 <Peaker> @hoogle lookup
01:42:54 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
01:42:54 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
01:42:54 <lambdabot> Data.IntMap lookup :: Monad m => Key -> IntMap a -> m a
01:43:03 <jsn> okay, so we see that getFileAuthority, as a lookup, is compatibile with capabilities
01:43:21 <Peaker> yeah, I think its redundant to Data.List.lookup though
01:43:31 <Peaker> or Data.Map.lookup (if the directory returns that instead)
01:44:12 <jsn> so it turns out that openFile is precisely this lookup -- it checks the OS context for the necessary rights, and grants you the (latent) capability to manipulate the file
01:44:50 <Peaker> jsn: no, because openFile uses a global namespace and "looks it up" from the entire set of capabilities the "user" has, its "ambient authority"
01:45:17 <Peaker> jsn: openFile cannot possibly be POLA, while always passing authority as argument can be POLA
01:45:20 <jsn> Peaker: well, it looks it up from the capabilities that the operating system has granted to that process
01:45:40 <Peaker> jsn: s/process/user -- which is much worse granularity than a per-fucntion-basis
01:45:52 <Peaker> jsn: not to mention that you cannot pass capabilities around with that model
01:45:53 <jsn> if the operating system used capabilities, then you'd still have 'openFile'
01:46:24 <jsn> you just make the capabilities part of a process environment
01:46:27 <Peaker> jsn: nope, "open" is completely the opposite of the capability model
01:46:44 <Peaker> jsn: capabilities mean that you pass around the result of open instead of those silly strings
01:46:52 <Peaker> jsn: (i.e a file handle)
01:46:54 <jsn> and when a process creates new processes, it puts the appropriate capabilities in their environment
01:47:14 <jsn> Peaker: you still need the silly strings to find the files you were after, later on
01:47:40 <jsn> Peaker: the difference is not in the lookup, but in how authority is allocated
01:47:57 <Peaker> jsn: only a GUI shell or such needs to perform such a lookup, and it performs it on a database that already conatins the authority
01:48:15 <jsn> but then the database needs to do the lookup in its index, &c...
01:48:28 <Peaker> jsn: generally code in obj-caps does not get to access any file the "process" or "user" has access to (indeed there is no need for "users")
01:48:39 <Peaker> the database has its index as authority already
01:49:19 <Peaker> jsn: the whole point of capabilities is to approach POLA (Principle of least authority). If your granularity is process or user level, rather than function-level authority, you lose most of the advantages already
01:49:45 <jsn> function level authority is, to put it mildly, ridiculous
01:50:18 <Peaker> jsn: capabilities also let you modify the authority of entities (pass around capabilities) in a manner that can be proven not to result in privelege escalation/etc.  If any code of a "user" can pass around capabilities to any other code of any other "user" you cannot prove anything about the authority of entities in the system
01:50:22 <Peaker> jsn: why?
01:50:45 <Peaker> jsn: function-level authority is practical and easy if you consider the designation that you already to also convey authority, instead of just designation.
01:50:57 <jsn> Peaker: because the capabilities are all available in a shared memory space
01:51:13 <Peaker> jsn: Can you access an IORef of someone else in this "shared memory"?
01:51:33 <Peaker> jsn: You don't need OS-level security if you have language-level security (Haskell may need to lose a few unsafe* functions though :-)
01:51:53 <jsn> Peaker: Haskell can run C in it :)
01:52:09 <Peaker> only if you have authority (i.e FFI) in modules
01:52:10 <jsn> Peaker: you can not lose the unsafe functions
01:52:38 <Peaker> I think you only need to remove the unsafe functions that can result in core dumps, not unsafePerformIO or interleaveIO for example
01:52:51 <Peaker> Out-of-bounds array access, unsafeCoerce, etc
01:53:03 <flux> jsn, how about java? doesn't it run everything in essentially shared memory, yet objects can have separate priviledges
01:53:11 <jsn> unsafePerformIO is enough to perform coercion, actually
01:53:13 <flux> of course, you can run C from java too - but in general you don't
01:53:23 <Peaker> flux: Java is almost completely suitable for a capability system
01:53:36 <Peaker> jsn: Maybe I am wrong about what I think unsafeCoerce does then
01:53:49 <Peaker> jsn: if it can be implemented with unsafePerformIO then it can't core dump right?
01:53:50 <flux> so is the backdoor for all "language x is secure" -claims "no it isn't, it can interface with C, and must do so to be useful"?
01:54:03 <Peaker> flux: how can Java code run arbitrary C code?
01:54:20 <Peaker> flux: or Haskell code run C code for that matter, assuming FFI and other authority-modules are not importable?
01:54:20 <ulfdoz> Peaker: Java Native Interface.
01:54:27 <jsn> flux: i think that is why we have process level memory protection
01:54:33 <flux> peaker, see, you had that "assuming" right there
01:54:35 <Peaker> ulfdoz: Just don't allow imports of authority
01:54:53 <flux> of course, given sufficient restrictions, those possibilities can be taken away
01:54:56 <Peaker> flux: yeah, for capabilities with language-level security, you have to remove authority from modules
01:55:07 <flux> and unsafePerformIO isn't standard haskell anyway, is it?
01:55:09 <flux> (but FFI is?)
01:55:14 <ulfdoz> Peaker: Making the assumption, that your SecurityManager is secure.
01:55:14 <Peaker> flux: the idea is that with languages like Java/Haskell, all authority comes from modules you import
01:55:29 <dolio> unsafePerformIO is part of the FFI.
01:55:38 <flux> jsn, btw, do you know Singularity?
01:55:46 <Peaker> ulfdoz: A capability system has no SecurityManager, what do you mean?
01:55:57 <flux> dolio, right.. so is FFI standard then?
01:56:24 <dolio> It's not part of the 98 report, but it's some kind of standard addendum.
01:56:33 <dolio> I think that's the situation, that is.
01:56:36 <jsn> i would much rather locate security in the operating system, and leave the languages alone
01:56:52 <Peaker> jsn: Why? I rather like POLA
01:56:55 <jsn> that way, i can use more of them
01:57:00 <flux> jsn, Singularity (a development OS from Microsoft) does away with memory protections, yet (in principle) provides secure environment
01:57:08 <jsn> and it's easier for people to make new ones
01:57:19 <Peaker> jsn: All "safe" languages (where you can't conjure pointers into existence) are usable for capability systems
01:57:23 <ulfdoz> Peaker: ah, sorry, I should read more backlogs.
01:57:33 <jsn> Peaker: what languages are those?
01:57:39 <Peaker> flux: I thought singularity restored memory protections, which totally disappointed me
01:57:56 <flux> peaker, really? for reasons othen than interacting with C libraries?-o
01:58:02 <Peaker> jsn: Haskell (without the core-dumping stuff), Python, Java, E, etc
01:58:24 <Peaker> flux: yeah, they still have "processes" that are memory separate from one another, I think its an "extra precaution", which I find self-defeating
01:58:27 <jsn> Haskell is not one of those languages today, though
01:58:46 <Peaker> jsn: how hard do you think it is to remove these core dumping stuff from Haskell? I don't think there are plenty
01:58:51 <flux> peaker, wouldn't that lose a lot of the visioned performance benefits.
01:59:10 <Peaker> flux: Yes :( I think either I am lacking more of their rationale, or they are dumb.
01:59:14 <flux> peaker, case in point: lambdabot :)
01:59:31 <Peaker> flux: lambdabot removes a bit too much, perhaps ;)
01:59:41 <jsn> Peaker: it would make it hard to do a lot of stuff
02:00:55 <Peaker> jsn: what stuff?
02:01:02 <jsn> Peaker: it would also make Haskell completely unsuitable for kernel development, &c.
02:01:03 <flux> jsn, wouldn't tons of java software be written without interfacing with C, however?
02:01:13 <Peaker> jsn: With language-level security, you don't need a kernel ;-)
02:01:43 <jsn> Peaker: something must hold the device drivers together, and allow the numerous languages on your system to talk to one another
02:01:49 <flux> if you were to write a kernel the kernel would have higher authority, but the processes it runs would no longer need to access things such as memory directly.
02:01:58 <flux> how does Hops work?
02:02:07 <Peaker> You don't need to give up C interaction completely, you just need to limit which functions/actions have authority to do this interaction. You can get C interaction to implement certain features and then you pass around values of that C-interacting library
02:02:19 <flux> I've only taken a brief look to witness that "yes, you can write device drivers in haskell and they're quite pretty"
02:02:33 <Peaker> jsn: with language-level security, device drivers are libraries to access hardware
02:02:55 <jsn> Peaker: so you are not talking about actually removing C stuff from the language, i gather
02:03:11 <flux> you can have parts that can access C and other parts that can't
02:03:12 <Peaker> jsn: the runtime system of the languages (e.g JVM) itself could implement threads/scheduling, and communication queues are already implemented
02:03:24 <jsn> Peaker: as far as the drivers go, it's not clear how you're going to schedule access to a device across more than one language without a kernel
02:03:27 <flux> you need to have C to interface with the operating system
02:03:29 <Peaker> jsn: No, but instead of FFI being importable, it should be a capability you pass as an argument to a select few
02:04:10 <Peaker> jsn: you have just one driver, and that driver can be accessed by those that have authority to it, that driver does the multiplexing, but the driver is basically a library
02:04:39 <jsn> so how do you schedule access to the CPU without a kernel?
02:04:48 <jsn> and really, that driver is basically a service
02:05:37 <Peaker> jsn: You create a JVM that runs no top of the hardware. Its not really a kernel, but a language runtime
02:05:51 <Peaker> (There are no "rings" or use of hardware protection, for example)
02:06:08 <jsn> but how do two different languages get access to the hardware?
02:06:15 <Peaker> they both run on top of the same JVM
02:06:31 <jsn> well, that is your "kernel" i guess
02:06:47 <Peaker> except kernels traditionally use hardware protection, ring0 vs ring3, etc
02:07:14 <jsn> this has the same kind of elegance of a planned economy
02:07:24 <jsn> if fear it must meet the same fate
02:07:29 <Peaker> jsn: that is demagogic :)
02:08:30 <jsn> Peaker: please try not to make things personal
02:09:28 <Peaker> jsn: I'm not, just saying that comparing a language runtime based system vs kernel   to   free market vs planned market  does not teach us about the merits of the system :)
02:09:38 <flux> so are the points in this discussion that jsn says the POLA doesn't work in function-level while peaker says it does?
02:09:45 <jsn> Peaker: you hardly said it like that
02:10:06 <Peaker> jsn: demagogic just means you're appealing to emotion
02:10:29 <jsn> Peaker: it is substantially more harsh than that
02:10:31 <Peaker> flux: The last discussion was about language-level vs hardware-level security
02:10:56 <Peaker> jsn: sorry then, I meant you were appealing to emotion rather than reason
02:10:56 <jsn> i am inclined to delegate security to the operating system and its APIs
02:11:16 <Peaker> jsn: OS's have a really really bad security record, btw
02:11:25 <Peaker> jsn: do you know "the confused deputy" problem?
02:11:25 <flux> can we instead say "byte code level" (that is, essentially typed assembler) and hardware level?
02:11:32 <Peaker> flux: yeah
02:11:40 <jsn> flux: well, that is not my argument, though
02:11:49 <jsn> i'm not talking about hardware level anything
02:12:04 <jsn> i'm talking about OS level vs. language level
02:12:13 <Peaker> OS level = hardware level, though?
02:12:17 <jsn> no
02:12:23 <Peaker> You could call my JVM-based system an "OS"
02:12:27 <jsn> right
02:12:42 <jsn> but then it is "JVM level"
02:13:01 <Peaker> "security" is handled by the fact you can't conjure into existence pointers - and the fact people only pass around the authority that is required to perform the task
02:13:10 <Peaker> s/people/functions
02:13:15 <Baughn> "JVM level" sounds like a subtype of "byte code level", anyhow
02:13:33 <Peaker> Baughn: I mean JVM in the general sense, I lack a word for that.. Language runtime, perhaps?
02:13:37 <jsn> Baughn: it is not my term of choice
02:14:09 <Baughn> Peaker: Half-fabricate executables. :P
02:14:46 <flux> jsn, are you familiar with the concept Proof Carrying Code?
02:14:58 <Peaker> jsn: why did you say function-level granularity of authority is ridiculous?
02:15:29 <Baughn> Why would it be function-level instead of value-level?
02:16:04 <Peaker> Baughn: more accurately action-level, probably
02:16:14 <Peaker> Baughn: because actions do things, they are entities, and values just "sit there": )
02:16:47 <Baughn> Peaker: I suppose it doesn't matter. The main thing is that the system is capability-based
02:16:57 <Peaker> Baughn: yeah
02:17:18 <Peaker> basically all expressions in the language get their authority from their arguments and lexical scope, and not from modules they import
02:17:57 <jsn> Peaker: many languages offer (if surreptitiously) access to the whole of a process' memory space -- so i do not think it is meaningful to introduce divisions of capability within it
02:18:15 <Baughn> jsn: This language wouldn't, obviously
02:18:22 <Peaker> Baughn: In a message-based OO language, its easy to make sure a function only returns authority that it has (within that object).  In Haskell, you'd have to somehow make sure each a->b  function returns in b only authority that was sitting in a
02:18:52 <Peaker> jsn: I think its reasonable to run C/C++ in an emulator so that we can have proper POLA
02:19:05 <Baughn> Peaker: Which, for non-IO functions, the compiler ensures just fine
02:19:11 * Baughn pointedly ignores the FFI
02:19:14 <Peaker> jsn: where emulator is something like cyclop (or what that safe C implementation was called)
02:19:55 <dolio> Presumably the FFI would only be interacting with well behaved languages on this theoretical system.
02:20:06 <jsn> ah, okay
02:20:07 <Peaker> Baughn: yeah, I guess that is only a problem with the adapter layer that talks to the OS -- if the whole system was Haskell based, we'd have values instead of silly filenames, and we wouldn't have the problem at all
02:20:11 <Baughn> There would only /be/ well-behaved languages, yes
02:20:28 <Baughn> ..well, you could probably run C code and such inside a hardware-enforced firewall. No direct memory access for those.
02:21:04 <Baughn> Peaker: No, we'd stil use strings for handles. People like names.
02:21:04 <Peaker> Baughn: or a safe-C implementation that does not let you make pointers up or access out-of-bounds array, which means C might actually be a cap language too
02:21:19 <Peaker> Baughn: Capabilities mean you must unite designation with aurhotiy
02:21:21 <Peaker> with authority
02:21:33 <jsn> Peaker: multiplex the names?
02:21:38 <Peaker> Baughn: Just make it an instance of Show :)
02:21:41 <Baughn> Peaker: You could and should write a C variant that works well on the system, but you _also_ have to run legacy POSIX code
02:21:58 <Baughn> Peaker: And Read. Typing in the name and all..
02:22:02 <jsn> Baughn: well, he doesn't _have_ to...
02:22:17 <Baughn> jsn: Yes. Yes, he does.
02:22:19 <Peaker> Baughn: I think legacy compatibility is overrated, at least for the common desktop machine ;)
02:22:22 <Baughn> Otherwise it'd be an utter flop
02:22:34 <jsn> Baughn: the read instance would be weird, mapping the name to some context-defined authority token
02:22:37 <Baughn> Peaker: Right. You get to rewrite Firefox on your own, then.
02:22:44 <Peaker> Baughn: you can't make it an instance of Read, because that would mean you can conjure authority into existence from strings
02:23:04 <jsn> Peaker: how do you get from a string to a file, then?
02:23:12 <Peaker> Baughn: note that almost all code on a modern desktop is less than 10 years old.  In just 10 years time, you get to lose all legacy software :)
02:23:13 <Baughn> Peaker: Not really. You'd presumably start with the authority to read some directory structure, and go from there
02:23:16 <jsn> you have yet to clearly answer that
02:23:41 <Peaker> jsn: you don't.  You might get from (String, FileDatabase) to file, however only a GUI/non-gui shell would probably hold access to "FileDatabase", as it is so sensitive authority
02:23:53 <Baughn> jsn: Well, it'd basically be openFile, but with an extra database/capability parameter
02:24:10 <Peaker> Baughn: yeah, but note that Read does not let you take directory,String as an argument, it takes String->FileHandle directly, and that's a problem
02:24:47 <Peaker> Baughn: openFile is probably just Data.Map.lookup on the database of stuff you have
02:25:08 <Baughn> Peaker: Oh, sure
02:25:38 <Baughn> Peaker: I don't think we actually disagree about anything here. ;)
02:25:45 <Baughn> Peaker: Have you written any significant code yet?
02:26:02 <Peaker> Baughn: Caps are far away in my plan :)
02:26:22 <Peaker> Baughn: I want to write an FRP code editor first, but FRP libraries are not mature, I spend the little time I have reading about FRP and only recently I fully "got" it
02:26:59 <Peaker> Baughn: well fully enough to actually do something with it, but I want to use Reactive, but its currently in flux, Conal says it will be usable in just a few days
02:28:58 <Peaker> Baughn: plan: A) write non-textual Haskell editor with FRP (ala Subtext) with revision control instead of undo/redo support [this makes it quite hard :-].  B) the code runs as you edit it [like conal's EROS] so I think I can make it usable as sort of a desktop shell  C) network transparency should make it a viable platform for a web replcement in the future :)
02:47:41 <ivanm> is there a standard way of referencing hackage?
02:49:01 <Leaves> Hello, I'm making an old haskell exam, and there is a question which asks me to argue why "foldr sum" doesn't type check. However it _does_ have a type as far as I know, but I'm not sure if Num (b -> b) => .. is possible, could someone shed some light on this?
02:49:13 <ivanm> @type foldr sum
02:49:14 <lambdabot> forall b. (Num (b -> b)) => b -> [[b -> b]] -> b
02:49:29 <ivanm> because there's no function b -> b that is a number
02:49:44 <ivanm> @src Num
02:49:45 <lambdabot> class  (Eq a, Show a) => Num a  where
02:49:45 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:49:45 <lambdabot>     negate, abs, signum     :: a -> a
02:49:45 <lambdabot>     fromInteger             :: Integer -> a
02:49:56 <ivanm> ^^ can any function b -> b implement all these functions?
02:50:06 <Leaves> no, I don't think so
02:50:12 <ivanm> then that answers your questioni
02:50:17 <ivanm> @type foldr
02:50:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:50:55 <Leaves> but I though maybe foldr sum (since it has a type) does typecheck, just that it goes wrong later
02:51:00 <ivanm> Leaves: sum takes in a list of values
02:51:19 <ivanm> foldr requires a function that takes in _two_ values and returns a third value
02:51:24 <ivanm> @type sum
02:51:25 <lambdabot> forall a. (Num a) => [a] -> a
02:51:34 <ivanm> ^^ doesn't match the type required for foldr
02:52:26 <Leaves> but wouldn't it be correct to say that foldr sum does have a type, just that there can be no correct input for the foldr sum function?
02:52:41 <ivanm> Leaves: an impossible type
02:52:44 <Peaker> Leaves: its a Void type that has no values
02:54:13 <Leaves> ok, that is clear to me now, thanks for your help
02:57:21 <Saizan> that's quite untrue..
02:58:34 <quicksilver> Leaves: it has a perfectly good type
02:58:42 <quicksilver> Leaves: (so your exam question is poorly worded)
02:59:06 <quicksilver> Leaves: it's just not *likely* to be a useful type since we don't expect any instances Num (b -> b)
02:59:32 <quicksilver> Leaves: probably the person who set the question was thinking of sum :: [Int] -> Int
02:59:43 <quicksilver> ...in which case foldr sum really doesn't have a type.
02:59:47 <quicksilver> I'd answer it in those terms.
02:59:50 <ttt--> how come ([a]->a) is allowed to match (a->b->b) ?
03:00:24 <quicksilver> ttt--: [a]->a matches (b -> (c -> c))
03:00:31 <quicksilver> ttt--: by setting a = b = c -> c
03:00:35 <quicksilver> which is a valid unification.
03:00:43 <quicksilver> erm. not quite
03:00:51 <quicksilver> b = [a] ; a = c -> c
03:00:54 <quicksilver> (sorry!)
03:01:10 <vixey> :t (undefined :: ([a]->a)) :: (a->b->b)
03:01:12 <lambdabot>     Couldn't match expected type `a' against inferred type `[b -> b]'
03:01:12 <lambdabot>       `a' is a rigid type variable bound by
03:01:12 <lambdabot>           the polymorphic type `forall a b. a -> b -> b' at <interactive>:1:0
03:01:20 <quicksilver> so b = [c -> c]
03:01:23 <vixey> :t (undefined :: ([a]->a)) :: (x->y->y)
03:01:24 <lambdabot>     Couldn't match expected type `x' against inferred type `[y -> y]'
03:01:25 <lambdabot>       `x' is a rigid type variable bound by
03:01:25 <lambdabot>           the polymorphic type `forall x y. x -> y -> y' at <interactive>:1:0
03:02:01 <vixey> bah, this trick doesn't work here
03:02:04 <quicksilver> vixey: explicitly specificed types are fully polymorphic.
03:02:05 <quicksilver> right.
03:02:11 <kosmikus> vixey: doesn't work. type variables in type signatures are interpreted as quantified, not free.
03:02:39 <Saizan> :t (undefined :: (forall a. [a]->a)) :: (x->y->y)
03:02:40 <lambdabot>     Couldn't match expected type `x' against inferred type `[y -> y]'
03:02:40 <lambdabot>       `x' is a rigid type variable bound by
03:02:40 <lambdabot>           the polymorphic type `forall x y. x -> y -> y' at <interactive>:1:0
03:02:47 <quicksilver> it's a little more fiddly to force lambdabot to  do gen
03:03:06 <quicksilver> ..al unification.
03:04:56 <Saizan> ?ty (undefined :: [a] -> a) `asTypeOf` (undefined :: (x -> y -> y))
03:04:57 <kosmikus> @type if True then (undefined :: [a] -> a) else (undefined :: b -> c -> c)
03:04:57 <lambdabot> forall y. [y -> y] -> y -> y
03:04:58 <lambdabot> forall c. [c -> c] -> c -> c
03:05:05 <kosmikus> :)
03:05:09 <Saizan> heh :)
03:05:20 <Leaves> quicksilver: ok, but the not likely, is it possible to prove that it is not only not likely but also impossible?
03:05:34 <kosmikus> Saizan: your version is nicer
03:06:22 <vixey> :t (undefined :: [a] -> a) + (undefined :: (x -> y -> y))
03:06:24 <lambdabot> forall y. (Num ([y -> y] -> y -> y)) => [y -> y] -> y -> y
03:06:56 <kosmikus> Leaves: no, type classes are open. nobody prevents you from defining such a Num instance.
03:08:22 <Leaves> kosmikus: ok, thanks
03:11:19 <ivanm> what do you call it when a function binds to either the left or the right?
03:11:53 <Baughn> Associativity, as in left- or right-
03:11:56 <ivanm> that's the one
03:12:48 <Saizan> Num b => (a -> b) would be a function space, btw, right?
03:13:00 <SingInTime> hello world
03:13:12 <ivanm> which ones which? i.e. if I have a function f :: a -> b -> b, if I need to do: a1 `f` (a2 `f` b) ?
03:13:24 <Baughn> SingInTime: Type mismatch: Expected type: IRC [a], inferred type: IO ()
03:13:26 <ivanm> SingInTime: well, I'm not the world but I'm saying hello back anyway ;-)
03:13:32 <ivanm> Baughn: lol
03:13:47 <ivanm> @remember Baughn SingInTime> hello world <Baughn> SingInTime: Type mismatch: Expected type: IRC [a], inferred type: IO ()
03:13:48 <lambdabot> It is stored.
03:14:21 <ski> ivanm : right-associative, if you want  a1 `f` a2 `f` b  to be shorthand for what you gave
03:14:22 <Saizan> ivanm: if f is right associative then  a1 `f` a2 `f` b == a1 `f` (a2 `f` b)
03:14:44 <ivanm> nah, I _have_ to have that, so this function must be left-associative
03:14:50 <Baughn> ivanm: With right-associativity, there are more paranteheses to the right. And vice versa.
03:15:09 <Baughn> (When fully disambiguated)
03:15:26 <ivanm> Baughn: ummm..... doesn't that contradict what ski and Saizan just said?
03:15:42 <ivanm> oh, do you mean fully disambiguited by adding parentheses?
03:15:42 <Baughn> ivanm: No
03:15:44 <Baughn> Yes
03:15:45 <ski> no
03:15:47 <ivanm> heh
03:15:55 <ivanm> OK, I misunderstood what you meant at first
03:16:09 <ivanm> so if I _have_ to have the brackets there for it to typecheck, it's left-associative?
03:16:15 <vixey> actually `f` is a bad name, why don't you use an operator
03:16:21 <vixey> like + or *..
03:16:30 <ivanm> vixey: well, it's the & operator from FGL
03:16:35 <Saizan> btw f :: a -> b -> b can't assciate to the left unless a = b, right?
03:16:36 <ivanm> which I'm actually talking about
03:17:38 <ivanm> ([],2,2,[((),1)]) & ([],1,1,[]) & empty doens't type check
03:17:39 <ski> Saizan : aye  (unless maybe if we're talking about some more complicated kind of associativity, with more structure to `a' and `b')
03:17:50 <ivanm> @type (&)
03:17:51 <lambdabot> Not in scope: `&'
03:17:57 <ivanm> @hoogle &
03:17:57 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
03:17:57 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
03:17:57 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
03:18:05 <SingInTime> ...does anybody know if people @ #xmonad are dead?
03:18:05 <ivanm> I guess lambdabot doesn't know about FGL then
03:18:19 <SingInTime> needed some info about the WM...
03:18:33 <ivanm> SingInTime: in general, with IRC you don't ask to ask ;-)
03:20:16 <ski> (but may you ask to ask to ask .. ?)
03:21:41 <ivanm> @slap ski
03:21:41 * lambdabot orders her trained monkeys to punch ski
03:23:14 * ski figured it maybe was a polarity kind of thing .. so two nested askings would sortof cancel into covariance
03:23:57 <ski> (of course in such case i still asked about it, so added another level)
03:27:10 <SingInTime> @ski: that's what happens when a language speaks about itself :P
03:27:10 <lambdabot> Unknown command, try @list
03:34:55 <enolan> @seen lemmih
03:34:55 <lambdabot> I saw lemmih leaving #haskell 4d 15h 7m 35s ago, and .
03:57:22 <luntain_> anyone else getting "could not read cabal file Glob" after cabal update; cabal list?
04:03:32 <mm_freak> what's a clean way for one thread to ask another thread something and get a response?
04:03:37 <mm_freak> Chan and MVar?
04:04:02 <mm_freak> writeChan (Question mvarForAnswer)
04:04:21 <mm_freak> writeChan chan (Question mvarForAnswer)
04:05:32 <Saizan> writeChan chan (Question (putMVar mvar))
04:05:53 <Saizan> so the answering thread doesn't have to know that it's using an mvar
04:06:02 <Taejo> :t foldl
04:06:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:06:26 <Saizan> anche you could later swap that MVar to a Chan, for example
04:06:27 <mm_freak> you can pass closures around threads?
04:06:33 <Saizan> sure
04:06:42 <mm_freak> i love haskell =)
04:06:43 <Saizan> s/anche/and/
04:07:16 <Saizan> heh :)
04:10:51 <Taejo> @hoogle [a] -> [b] -> [(a,b)]
04:10:52 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
04:10:52 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
04:10:52 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
04:14:49 <pjdelport> mm_freak: i can't think of a language where you *can't* pass closures around threads
04:16:10 <mm_freak> true, actually
04:16:35 <mm_freak> i just have never used that…  in imperative languages i'd pass a pointer for the answer
04:16:51 <mm_freak> although a closure makes much more sense
04:21:00 <ttt--> how are the closures passed internally?
04:21:44 <pjdelport> in Haskell, "closure" and "pointer for the answer" probably comes down to exactly the same thing
04:22:57 <ttt--> do all threads share memory?
04:26:11 <Saizan> ttt--: they all share the same heap, yes
04:26:11 <mm_freak> ttt--: compilers are free to implement this the way they like…  it's not strictly necessary to share memory or have real threads at all
04:26:40 <pjdelport> referential transparency means that sharing is basically an optional implementation optimization
04:28:52 <ivanm> any idea how I can reference GHC (in particular its extensions)?
04:29:14 <ivanm> (I'm explaining why I'm using haskell-src-exts rather than haskell-src)
04:32:51 <Taejo> @list
04:32:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:33:27 <quicksilver> ttt--: shared memory is made 100 times easier by immutability.
04:33:34 <Taejo> @undo do {x <- xs; y <- ys; return (x, y)}
04:33:34 <lambdabot> xs >>= \ x -> ys >>= \ y -> return (x, y)
04:33:48 <quicksilver> if all values are readonly, then the problems of sharing memory between threads vanish.
04:33:49 <Taejo> @pl xs >>= \ x -> ys >>= \ y -> return (x, y)
04:33:50 <lambdabot> (`fmap` ys) . (,) =<< xs
04:33:58 <insane> hello i have to create a program which animates a movement of an object graphically but i want to use haskell for this purpose
04:34:04 <insane> is it possible
04:34:04 <insane> ?
04:34:07 <quicksilver> of course that's a bit of a simplification, becaue evaluating a thunk is a write operation.
04:34:19 <insane> i mean does the libraries such as gtk2hs or wxhaskell support animation
04:34:21 <quicksilver> but at least if it's accidentally done twice the answer remains the same ;)
04:34:28 <quicksilver> insane: yes.
04:34:46 <quicksilver> insane: to precisely the same extent as they support it when called from C ;)
04:34:50 <quicksilver> haskell is just another language.
04:34:59 <ttt--> im trying to remember how erlang does it, but not with shared memory, i think
04:35:03 <quicksilver> I've written animations in haskell but I've used opengl, as it happens.
04:35:26 <insane> quicksilver: so it would be better to use wxhaskell or gtk2hs
04:35:32 <insane> quicksilver: ?
04:35:40 <quicksilver> insane: have a look at the apis and see which you prefer.
04:35:59 <EmielRegis> @src connectTo
04:36:00 <lambdabot> Source not found.
04:36:01 <quicksilver> wx's drawable contexts vs gtk's cairo, I guess.
04:36:03 <EmielRegis> :(
04:36:09 <quicksilver> cairo is a bit more modern and funky.
04:36:12 <EmielRegis> @src Network.connectTo
04:36:12 <lambdabot> Source not found. Do you think like you type?
04:36:26 <quicksilver> EmielRegis: all the src is avaialble online
04:36:34 <EmielRegis> whereabouts?
04:36:56 <quicksilver> EmielRegis: http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
04:37:02 <EmielRegis> danke
04:37:08 <lambdabot> Title: Network, http://tinyurl.com/2znny8
04:37:20 <quicksilver> EmielRegis: (click the 'Source' link, top right of page)
04:37:25 <EmielRegis> ok
04:37:26 <EmielRegis> i wonder
04:37:26 <dobblego> which module has instance Monad ((->) t) ?
04:37:34 <EmielRegis> is this
04:37:35 <quicksilver> Contorl.Monad.Instances
04:37:37 <quicksilver> module typos
04:37:40 <EmielRegis> t <- getClockTime
04:37:42 <dobblego> cheers mate
04:37:43 <EmielRegis> equivalen to
04:37:46 <EmielRegis> t = getClockTime
04:37:47 <EmielRegis> ?
04:38:47 <pjdelport> ttt--: Erlang has limited thread-local state, IIRC
04:39:03 <insane> quicksilver: thanks i'll take a look at both of them then
04:39:09 <pjdelport> and is otherwise referentially transparent
04:39:34 <quicksilver> EmielRegis: no. <- is for monads.
04:39:39 <EmielRegis> ah
04:39:55 <pjdelport> ttt--: implementations do optional sharing within OS processes, i think
04:42:33 <daf> EmielRegis: a <- b is syntactic sugar for b >>= \a -> ...
04:43:06 <EmielRegis> O_o
04:43:08 <EmielRegis> tell m e more lol
04:43:12 <EmielRegis> i dont know much about monads yet
04:44:17 <daf> there are many introductions to monads
04:44:42 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation
04:44:43 <lambdabot> Title: Monads as computation - HaskellWiki
04:44:56 <Saizan> that is nice if you need them for IO
04:45:12 <daf> http://www.haskell.org/haskellwiki/Tutorials#Using_monads has a list of tutorials
04:45:14 <lambdabot> Title: Tutorials - HaskellWiki
04:45:51 <mm_freak> @hoogle Monad m => (a -> m a) -> a -> m ()
04:45:52 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
04:45:52 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
04:45:52 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:46:04 <mm_freak> @hoogle Monad m => a -> (a -> m a) -> m ()
04:46:05 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
04:46:07 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
04:46:09 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
04:46:17 <EmielRegis> Saizan, yes im examining IRC bot rolling atm
04:46:19 <EmielRegis> and it uses monads
04:50:45 <mm_freak> i'd like to have something like a foreverAccum :: a -> (a -> m a) -> m (), so i can get away without an IORef
04:50:54 <mm_freak> how can i do that with StateT?
04:51:29 <mm_freak> (without recursion, that is, otherwise i don't need implicit state)
04:53:09 <mm_freak> don't bother, that was a dumb question
04:53:38 <daf> mm_freak: what was the answer?
04:53:56 <Saizan> maybe WriterT is more appropriate?
04:54:19 <mm_freak> just using 'forever' in StateT…  my thinking was flawed
04:54:41 <mm_freak> Saizan: nope, i need mutable state in a forever-repeating piece of code
04:55:07 <mm_freak> it forever-repeats in the IO monad
04:55:55 <ttt--> is it possible to do a "deriving ..." from another module?
04:56:09 <Saizan> ?google standalone deriving ghc
04:56:11 <lambdabot> No Result Found.
04:56:26 <daf> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
04:56:28 <lambdabot> Title: GHC/Stand-alone deriving declarations - HaskellWiki
04:56:33 <ttt--> thanks
04:57:16 <daf> cool, I didn't know you could do that
05:04:02 <pastorn> there is no e in haskell
05:04:09 <pastorn> (as there is pi)
05:04:20 <pastorn> or does it go by some other name?
05:04:40 <pastorn> (in the ghci 6.8.2 Prelude, i mean)
05:04:45 <dolio> > exp 1
05:04:46 <lambdabot>   2.718281828459045
05:05:45 <pastorn> oh, cool
05:05:49 <pastorn> thankl :)
05:05:59 <pastorn> *thanks*
05:06:54 <vixey> > sum (map ((1/) . product . enumFromTo 1) [0..10])
05:06:55 <lambdabot>   2.7182818011463845
05:07:22 <pastorn> vixey: heh, cool
05:07:31 <pastorn> > sum (map ((1/) . product . enumFromTo 1) [0..100])
05:07:33 <lambdabot>   2.7182818284590455
05:07:52 <pastorn> > exp 1 - sum (map ((1/) . product . enumFromTo 1) [0..100])
05:07:53 <lambdabot>   -4.440892098500626e-16
05:07:58 <pastorn> > exp 1 - sum (map ((1/) . product . enumFromTo 1) [0..1000])
05:07:59 <lambdabot>   -4.440892098500626e-16
05:08:12 <pastorn> > exp 1 - sum (map ((1/) . product . enumFromTo 1) [0..10])
05:08:13 <lambdabot>   2.7312660577649694e-8
05:08:14 <Saizan> > exp 1 - sum (map ((1/) . product . enumFromTo 1) [0..1000]) :: CReal
05:08:29 <lambdabot>   thread killed
05:12:35 <mm_freak> is it safe to use a System.Posix.Signals signal handler to set an MVar?
05:13:11 <mm_freak> (i'd like to quit a program in a controlled manner, if it receives SIGTERM or SIGINT
05:13:39 <mm_freak> although a Chan would be more appropriate in my case
05:43:02 <path[l]> hi I read somewhere that foldl can be expressed using foldr. Does anyone know how this can be done?
05:43:03 <Taejo> @djinn (a -> a) -> a
05:43:03 <lambdabot> -- f cannot be realized.
05:44:31 <dobblego> path[l], it would be two calls to foldr and have different comlplexity properties
05:44:44 <Deewiant> > foldl f z [a,b,c,d,e]
05:44:46 <lambdabot>   f (f (f (f (f z a) b) c) d) e
05:44:48 <Deewiant> > foldr (flip f) z (reverse [a,b,c,d,e])
05:44:50 <lambdabot>   f (f (f (f (f z a) b) c) d) e
05:45:02 <Deewiant> and reverse is a foldr
05:45:05 <Deewiant> ?src reverse
05:45:06 <lambdabot> reverse = foldl (flip (:)) []
05:45:12 <Deewiant> darn
05:45:18 <Deewiant> well, it can be expressed as one ;-)
05:45:30 <path[l]> hehe I had just read its a foldl but ok I think Im seeing it.
05:45:37 <path[l]> What does flip f do again?
05:45:50 <Deewiant> > flip f x y :: Expr
05:45:52 <BONUS> returns a function that takes the arguments of f, only flipped
05:45:52 <lambdabot>   f y x
05:46:02 <BONUS> > flip (/) 2 8
05:46:04 <path[l]> ah I see
05:46:04 <lambdabot>   4.0
05:46:07 <path[l]> neat
05:46:33 <path[l]> so it takes any function that takes 2 arguments and flips it
05:46:58 <BONUS> it can also take a function that takes more than 2, but yeah, usually it's done with binary functions
05:47:14 <path[l]> oh it can?
05:47:40 <path[l]> hmm somehow I thought with a statically typed language you wouldnt be able to do something like that
05:47:50 <nybyn> it's called partial application
05:48:09 <vixey> :t let f x y z w = y in flip f
05:48:11 <lambdabot> forall a b t t1. b -> a -> t -> t1 -> b
05:48:12 <BONUS> well, basically, every function in haskell only takes *one* argument
05:48:17 <vixey> ?djinn b -> a -> t -> t1 -> b
05:48:17 <lambdabot> f a _ _ _ = a
05:48:29 <path[l]> oh ok right I see.
05:48:43 <path[l]> Ive seen partial application a few times
05:48:43 <BONUS> if you have a function a -> b -> c, it actually takes an a and returns a function that takes b and returns c
05:48:45 <vixey> flip (let f x y z w = y in f) ~~> let f y x z w = y in f
05:49:34 <dobblego> @hoogle (a -> Bool) -> [a] -> [a]
05:49:34 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
05:49:34 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
05:49:34 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
05:50:00 <Saizan> > let foldl f z xs = foldr (\x rec acc -> rec (f acc x)) id xs z in foldl (flip (:)) [] [1..10]
05:50:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
05:52:20 <Deewiant> foldl = flip . flip foldr id . (flip (.) .) . flip
05:52:26 <Deewiant> I like that :-P
05:52:42 <zachk> thats crazy, crazy good
05:52:57 <skorpan> FLIPMODE, FLIPMODE IS THE GREATEST
05:53:47 <path[l]> I read about point free style recently, but Im still new to it, so it makes my head hurt to parse things like that
05:54:07 <BONUS> i dont think anyone can just look at that and mentally parse it
05:54:07 <BONUS> haha
05:54:09 <vixey> like what?
05:54:13 <skorpan> pointfree is not always useful
05:55:22 <Philonous> It's called pointless style for a reason
05:55:25 <Deewiant> map flip (map (flip foldr id) (map (map (flip map)) flip))
05:55:33 <path[l]> I was reading about how its supposed to be better to learn to read it since it gets you thinking in a higher order rather than thinking of a function as modifying values
05:55:46 <idnar> @unpl foldl = flip . flip foldr id . (flip (.) .) . flip
05:55:47 <lambdabot> foldl t b c = foldr (\ ac j m -> j (t m ac)) (\ g -> g) c b
05:55:55 <BONUS> depends, sometimes its easier to read and more elegant, sometimes its just a mess
05:56:00 <BONUS> depends on the case really
05:57:31 <path[l]> hmm
05:57:56 <Saizan> ?type \f -> foldr (flip (.) . f) id -- nicer type imo
05:57:57 <lambdabot> forall a a1. (a1 -> a -> a) -> [a1] -> a -> a
05:59:26 <EvilTerran> ?type (`foldr` id) . (flip (.) .)
05:59:27 <lambdabot> forall a a1. (a1 -> a -> a) -> [a1] -> a -> a
06:07:17 <lilac> why does GHC accept 1 (one) as a data type?
06:07:31 <Deewiant> ?ty foo :: 2
06:07:32 <lambdabot> Not in scope: `foo'
06:07:32 <lambdabot> Only unit numeric type pattern is valid
06:07:40 <Deewiant> ?kind 1
06:07:41 <lambdabot> *
06:08:18 <lilac> it appears to be asynonym for GHC.Generics.Unit
06:08:20 <Deewiant> evidently it's GHC.Generics.Unit
06:18:15 <vixey> can anyone think of an example to demonstrate unification which isn't type inference?
06:20:09 <Philippa> vixey: pick a prolog program
06:21:07 <Philonous> Is (=<<) ~= flip (>>=) ?
06:21:14 <Deewiant> yep
06:21:31 <Deewiant> ?ty (=<<)
06:21:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:21:35 <Deewiant> ?ty flip (>>=)
06:21:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
06:21:39 <Philonous> Types match
06:22:00 <daf> @source (=<<)
06:22:00 <lambdabot> (=<<) not available
06:22:12 <Deewiant> @src (=<<)
06:22:12 <lambdabot> f =<< x = x >>= f
06:22:43 <daf> @check (=<<) == (flip (>>=))
06:22:44 <lambdabot>       No instance for (Eq ((a -> m b) -> m a -> m b))
06:22:44 <lambdabot>        arising from a u...
06:22:46 <Philonous> Oh, beautiful
06:23:26 <Philonous> Even a palindromic definition
06:26:12 <daf> @check \a b -> (a =<< b) == (b >>= a)
06:26:13 <lambdabot>       Overlapping instances for Show (a -> m b)
06:26:13 <lambdabot>        arising from a use of ...
06:28:08 <daf> :/
06:29:19 <Deewiant> can't check anything taking a function parameter with @check
06:30:00 <daf> oh, right
06:30:48 <vixey> @check \f g h -> (f . g) . h == f . (g . h)
06:30:49 <lambdabot>       Overlapping instances for Show (a -> b1)
06:30:49 <lambdabot>        arising from a use of `...
06:31:01 <vixey> @check \f g h x -> ((f . g) . h) x == (f . (g . h)) x
06:31:02 <lambdabot>       Overlapping instances for Show (a -> b1)
06:31:03 <lambdabot>        arising from a use of `...
06:31:16 <Deewiant> @check \a -> (Just =<< a) == (a >>= Just)
06:31:17 <lambdabot>   "OK, passed 500 tests."
06:41:55 <path[l]> oh the book explains foldl defined from foldr
06:42:04 <path[l]> myFoldl f z xs = foldr step id xs z
06:42:04 <path[l]>     where step x g a = g (f a x)
06:44:25 <ski>   Yet another senior Haskell programmer
06:44:26 <ski>     (leaned so far right he came back left again!)
06:53:47 <mopped> Can anyone explain what intercalate does? :P
06:54:20 <mm_freak>   cidGen <- newEmptyMVar
06:54:20 <mm_freak>   forkIO $ forM_ [1..] (putMVar cidGen)
06:54:29 <mm_freak> is this a good approach to a thread-safe ID generator?
06:55:02 <mm_freak> or is there a better method?
06:56:07 <mm_freak> the IDs are used as keys to Data.IntMap, so likely there is a much better method to generate them
07:01:10 <Saizan> > intercalate " | " ["foo","bar","baz"]
07:01:11 <lambdabot>   "foo | bar | baz"
07:02:03 <Saizan> mopped: it's like join in other languages, it inserts the given delimiter between the elements
07:02:38 <mopped> alright, thanks
07:03:37 <mm_freak> it's almost like 'join' in haskell =)
07:04:31 <mopped> join " | " ['a'..'z']
07:04:35 <mopped> > join " | " ['a'..'z']
07:04:36 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
07:04:37 <mm_freak> nope
07:04:48 <mopped> whats the difference?
07:05:09 <path[l]> > foldr f z [a,b,c]
07:05:10 <lambdabot>   f a (f b (f c z))
07:05:13 <mm_freak> join is a bit less flexible (or much more flexible, depending on whether you restrict yourself to lists)
07:05:27 <mm_freak> > join ["foo","bar","baz"]
07:05:28 <lambdabot>   "foobarbaz"
07:05:48 <mm_freak> > join $ intersperse " | " ["foo","bar","baz"]
07:05:49 <lambdabot>   "foo | bar | baz"
07:07:32 <mopped> aha
07:07:47 <Saizan> join = concat in this case
07:08:15 <mopped> and what does show do? turn anything into a string?
07:08:43 <dobblego> turns a [String] into a String
07:08:43 <mm_freak> yeah, turn anything into a string, from which it knows how to do so
07:08:55 <mm_freak> > show 3
07:08:56 <lambdabot>   "3"
07:09:05 <mm_freak> > show id
07:09:06 <lambdabot>       Overlapping instances for Show (a -> a)
07:09:07 <lambdabot>        arising from a use of `s...
07:09:25 <mopped> say I have a custom type such as XString String, in what case would I want to do 'let f (XString s) = show s', when I want to retain the "" surrounding s?
07:09:30 <mopped> > show "test"
07:09:31 <lambdabot>   "\"test\""
07:10:20 <mm_freak> "XString String" is not a type, but the type is likely just XString
07:10:30 <pjdelport> :t show
07:10:31 <lambdabot> forall a. (Show a) => a -> String
07:10:40 <mm_freak> instance Show XString where show (XString s) = show s
07:11:09 <Saizan> it's useful having an instance of Show that returns a valid haskell expression, so that you can paste it back at the evaluator prompt
07:11:17 <mopped> sorry XString is a type that only accepts Strings?
07:11:27 <mm_freak> data XString = XString String
07:11:35 <pjdelport> mopped: in other words, show turns any instance of the Show type class into a String
07:11:36 <mm_freak> data XString = AnotherConstructorName String
07:11:46 <mm_freak> instance Show XString where show (AnotherConstructorName s) = show s
07:11:50 <Saizan> if you need to prettyprint a value for UI purpouses there are specialized modules
07:12:04 <mopped> A type class is the word after data right? on the LHS of =?
07:12:21 <mm_freak> nope, that's the type's name with any type parameters
07:12:30 <pjdelport> mopped: type classes are on the left side of the =>
07:12:46 <mm_freak> data TypeName typeParam1 typeParam2 = Constructor1 typeParam1 | Constructor2 typeParam2
07:13:06 <mm_freak> then Constructor "blah" is of type TypeName String a
07:13:10 <mm_freak> uhm
07:13:13 <mm_freak> then Constructor1 "blah" is of type TypeName String a
07:14:03 <pjdelport> mopped: so "(Show a) => a" in a type signature means "any type a that is an instance of the Show class"
07:14:10 <pjdelport> @src Show
07:14:10 <lambdabot> class  Show a  where
07:14:10 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:14:10 <lambdabot>     show      :: a   -> String
07:14:10 <lambdabot>     showList  :: [a] -> ShowS
07:14:30 <pjdelport> a Show instance provides those functions
07:14:55 <pjdelport> mopped: type classes are used for many things; compare:
07:14:58 <pjdelport> :t (+)
07:14:59 <mm_freak> mopped: http://haskell.org/haskellwiki/Algebraic_data_type
07:14:59 <lambdabot> forall a. (Num a) => a -> a -> a
07:15:00 <lambdabot> Title: Algebraic data type - HaskellWiki
07:15:21 <pjdelport> in other words, (+) adds any instances of the Num type class
07:15:46 <Philonous> Btw. how do existential types work?
07:18:09 <mopped> hmm, ok thanks
07:20:07 <mm_freak> mopped: you should read some tutorial about haskell's type system…  it's great — if you understand it
07:20:48 <pjdelport> Philonous: have you looked at http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types ?
07:20:58 <lambdabot> http://tinyurl.com/f9umb
07:21:16 <Philonous> pjdelport: thanks
07:21:57 <pjdelport> Philonous: what do you want to know about them, specifically?
07:22:07 <pjdelport> how they're implemented, or how they're used?
07:23:07 <Philonous> I'm reading a paper about bytesstrings where existential types are used and I just wanted to know what their meaning is
07:24:01 <Philonous> Turns out I just mistyped my search querry in google, now I find plenty of sites
07:24:02 <pjdelport> mopped: you might want to look at http://en.wikibooks.org/wiki/Haskell/Class_declarations
07:24:12 <pjdelport> Philonous: ah
07:25:03 <mopped> will do
07:25:04 <pjdelport> Philonous: the basic idea is to partially hide type information
07:25:40 <pjdelport> Philonous: the canonical example is having a list of Showables
07:26:13 <Philonous> Like forall a. (Show a) => [a] ?
07:26:39 <pjdelport> not exactly
07:27:26 <Philonous> Oh wait
07:27:26 <pjdelport> the above restricts the list to still only have one homogeneous type
07:27:29 <Philonous> I see the problem
07:27:35 <Philonous> Yes
07:27:48 <pjdelport> so you can have a list of any Show instance
07:28:17 <pjdelport> but you can't have multiple instances in the list
07:30:27 <Deewiant> but can one have a [forall a. Show a => a] directly?
07:31:05 <Deewiant> ah, I see why not
07:31:56 <cnwdup> Is there documentation about i18n besides the module's source code?
07:33:09 <path[l]> whoops
07:33:13 <path[l]> disconnected
07:33:31 <path[l]> I was wondering. I can write foldr using foldl, cant I do the reverse?
07:37:14 <mm_freak> data Element = forall s. Show s => Element s
07:37:39 <mm_freak> map (\Element x -> show x) [Element "blah", Element 3]
07:37:54 <Philonous> Ah, so existential types are ad-hoc polymorphism at the type level and existentiality refers to the common "interface" of all types?
07:38:05 <pjdelport> right
07:38:42 <Baughn> Philonous: "Whatever the real type of this a is, it follows the interface Show", or whatever..
07:38:55 <Saizan> ad-hoc polymorphism at the type level?
07:39:20 <Baughn> Well, that's one way. I prefer to look at the implementation and just note that existentials bundle the vtable with the data, instead of passing it in lexically like typeclasses normally do
07:39:42 <Baughn> (Which has a major performance cost. Passing it in lexically can usually be optimized down to a direct call to the implementation.)
07:39:47 <mm_freak> simply, it's for cases where knowing that a type is a particular class instance, is enough for you
07:40:04 <mm_freak> like above, it suffices that 's' is a Show instance, and you don't need to know more about it
07:40:39 <pjdelport> each element of s, specifically
07:41:20 <Saizan> being an instance is a property of the type, not of the value
07:41:48 <pjdelport> with existential types, it's more or less the other way around
07:42:19 <pjdelport> each value is an instance; the type doesn't correspond to any particular instance
07:42:22 <Saizan> a value of type Element is a proof that there exists a type s that is an instance of Show
07:42:47 <Saizan> and as usual that proof must carry a value of that type
07:43:10 * Baughn wonders how this connects to general abstract nonsense
07:44:04 <Saizan> Baughn: it's just second order propositional logic :)
07:44:32 <Baughn> Saizan: I haven't gotten far in learning, but what I've figured out so far is that *everything* connects to general abstract nonsense. P
07:44:41 <Baughn> (Which should be incredibly useful, eventually)
07:46:02 <vixey> well you can use it as a foundation
07:46:20 <vixey> in that respect everything is actually made of nonsense
07:47:06 * Baughn loves that nickname
07:54:20 <Philonous> Wouldn't it be easier to allow something like ["abc" , 3, True] :: [Show] than introducing existential types?
07:54:45 <vixey> no
07:57:03 <amz> hm, is EclipseFP the best Haskell IDE?
07:57:10 <RayNbow> Philonous: easier for who? :p
07:57:12 <amz> because it doesn't do much
07:57:28 <RayNbow> amz: it's probably the best Haskell IDE for Eclipse :p
07:57:44 <amz> what about the best Haskell IDE, for Eclipse or not? ;)
07:58:24 * RayNbow doesn't have experience with other Haskell IDEs
07:58:34 <RayNbow> http://leksah.org/ <-- an Haskell IDE
07:59:38 <RayNbow> http://www.haskell.org/haskellwiki/Yi <-- Haskell editor
07:59:49 <lambdabot> Title: Yi - HaskellWiki
08:01:00 <amz> sigh, no debugging support...
08:01:08 <amz> I wonder if EclipseFP has that
08:03:49 <path[l]> oh finally
08:07:04 <mm_freak> path[l]: evaluating foldl needs to evaluate the whole list
08:07:29 <mm_freak> i think, you can write a (very inefficient) version of foldr using foldl, which only works on finite lists
08:07:56 <path[l]> ah yeah I see, but if I ignore efficiency and such, purely from a mathematical point of view it should be possible right?
08:08:15 <path[l]> yeah cause this book talks about how foldr is more basic because foldl can be written using foldr
08:08:18 <pjdelport> path[l]: for finite lists only
08:08:21 <path[l]> so I tried the reverse and it worked
08:08:28 <path[l]> yeah I get that :)
08:08:48 <mm_freak> foldl is a special case of foldr, but the opposite doesn't hold
08:09:13 <path[l]> hmm
08:09:59 <mm_freak> mathematically reimplementing foldr through foldl is impossible (if i don't miss something)…  a strict foldr for finite lists is another special case of foldr, and hence a different function
08:10:11 <mm_freak> so you can't say that you can describe foldr in terms of foldl
08:10:19 <vixey> > foldl (\x y -> x) 0 [1..]
08:10:19 <pjdelport> path[l]: consider the following
08:10:23 <vixey> > foldl (\x y -> y) 0 [1..]
08:10:29 <lambdabot>   mueval: Prelude.read: no parse
08:10:39 <lambdabot>   mueval: Prelude.read: no parse
08:10:54 <pjdelport> (a+(b+(c+(...)))) -- right associative
08:10:54 <pjdelport> ((((z+a)+b)+c)+...) -- left associative
08:11:33 <path[l]> mm_freak: ok I accept that argument. So foldl can only implement a foldr meant for finite lists. I just wanted to make sure it wasnt something else I was missing
08:11:57 <pjdelport> path[l]: for arbitrary lists, the first one can immediately begin evaluating the outer (a+...)
08:12:03 <mm_freak> foldl can implement strictFoldr
08:12:11 <mm_freak> which is not the same as foldr
08:12:11 <pjdelport> and proceed inwards, only consuming as much of the list as required
08:12:49 <pjdelport> path[l]: the second one's outer + instead starts from the *end* of the rist
08:12:50 <path[l]> yeah this morning cale was explaining to me what I missed about the finiteness. But whats strictFoldr ?
08:12:51 <mm_freak> the lazy foldr can exploit the WH-ness of lists, which strict foldr cannot
08:13:02 <path[l]> ah
08:13:06 <mm_freak> so even for finite lists, strictFoldr behaves differently
08:13:53 <path[l]> oh so you mean even for finite lists, an error condition which foldr would ignore would break the foldr implemented using foldl
08:14:41 <pjdelport> Philonous: you could have that
08:15:02 <pjdelport> Philonous: it would still be an existential type
08:15:14 <Philonous> Yeah
08:15:23 <Philonous> I figured it could desugar to existential types
08:15:43 <pjdelport> i think you could in theory have anonymous existential types like [exists a. Show a => a]
08:15:43 <Philonous> But it would get kind of messy
08:16:21 <pjdelport> but in practice Haskell doesn't have them, i guess for much the same reason it doesn't have other kinds of anonymous types
08:16:51 <mm_freak> > let x `mult` 0 = 0; x `mult` y = x*y in foldr (\a p -> a `mult` p) 1 [undefined,0,1,2,3]
08:16:51 <pjdelport> like anonymous unions
08:16:54 <mm_freak> 0
08:16:55 <lambdabot>   0
08:17:09 <mm_freak> path[l]: a strict foldr couldn't preserve that property
08:17:22 <SamB_XP> pjdelport: I thought it was because it was too hard to figure out how to represent the values ;-)
08:17:49 <path[l]> oh right. I get it
08:17:56 <pjdelport> SamB_XP: how so?
08:18:23 <pjdelport> i don't really know the implementation issues, but you'd just compile it into some box, wouldn't you?
08:18:29 <Saizan> mm_freak: a foldr written with foldl can still be lazy in the elements
08:18:35 <SamB_XP> or perhaps because it's too hard to tell when they are being "opened"
08:18:43 <pjdelport> i.e. do the same thing under the hood that the named existential type does
08:18:57 <Saizan> mm_freak: the differences arise with lists like (1:undefined)
08:18:59 <Philonous> Haskell typeclasses appear to be even more different to C++ classes than I expected. Upcasts are bread-and-butter operations in C++
08:19:18 <pjdelport> Philonous: they're pretty different concepts, i think
08:19:33 <daf> mm
08:19:33 <SamB_XP> quite so
08:19:47 <daf> they're much more like interfaces
08:20:03 <SamB_XP> the use of the term "member" strikes me as a pun
08:20:13 <SamB_XP> or "method"
08:20:31 <Saizan> upcast is easy with interfaces/oo-classes because they are _types_ while typeclasses aren't
08:21:00 <mm_freak> Saizan: how could a foldr in terms of foldl be lazy, if foldl demands the entire list to give a result?
08:21:26 <pjdelport> mm_freak: just lazy in the elements, not the list itself
08:21:56 <pjdelport> i.e. it would evaluate the entire list, but not necessarily all its elements
08:22:30 <Saizan> > let x `mult` 0 = 0; x `mult` y = x*y in foldl (flip (\a p -> a `mult` p)) 1 $ reverse [undefined,0,1,2,3]
08:22:31 <lambdabot>   0
08:23:17 <mm_freak> hmm, ok, so it just builds the thunks?
08:23:39 <Saizan> it just applies the function to the elements
08:24:14 <mm_freak> wait, you're using reverse…  can you consider that a "foldr in terms of foldl"?
08:24:34 <Saizan> that was a shorthand :)
08:27:29 <mm_freak> > let x *** 0 = 0; x *** y = x*y in foldl (***) 1 [-3 .. 100000000]
08:27:40 <lambdabot>   mueval: Prelude.read: no parse
08:28:07 <mm_freak> > let x *** 0 = 0; x *** y = x*y in foldl (***) 1 [-3 .. 100]
08:28:11 <lambdabot>   0
08:28:21 <mm_freak> > let x *** 0 = 0; x *** y = x*y in foldl' (***) 1 [-3 .. 100000000]
08:28:36 <lambdabot>   thread killed
08:28:59 <mm_freak> why doesn't that work?
08:29:21 <pjdelport> mm_freak: that's really all "foldr in terms of foldl" comes down to
08:31:05 <Saizan> > let x `mult` 0 = 0; x `mult` y = x*y in foldl (\rec a -> rec . (a `mult`) ) id [undefined,0,1,2,3] 1
08:31:07 <lambdabot>   0
08:31:39 <Saizan> > let x *** 0 = 0; x *** y = x*y in foldl' (***) 1 [-3 .. 100000]
08:31:40 <lambdabot>   0
08:37:15 <mm_freak> instance Modulus n => Eq (Mod n) where Mod x == Mod y = rem (x-y) (modulus (undefined::n)) == 0
08:37:26 <mm_freak> what's wrong here?  i'm getting an ambiguous type error
08:38:45 <Raynes> O_O
08:42:38 <Saizan> mm_freak: you need ScopedTypeVariables i think
08:42:51 <rwbarton> mm_freak: I don't think type variables in instance heads are in scope in the bodies of instance methods without ScopedTypeVariables
08:43:54 <Saizan> or define a toN :: Mod n -> n; toN = undefined, and use that to fix the type
08:52:23 <Fiyuri> http://www.clanplanet.de/_sites/index.asp?rn=&clanid=10972
08:52:27 <Fiyuri> http://www.clanplanet.de/_sites/index.asp?rn=&clanid=10972
08:52:29 <lambdabot> Title: Gildenseite der Gilde 'Mann mach hinne' | Clanseiten, Gildenseiten, Allianzseite ...
08:52:29 <lambdabot> Title: Gildenseite der Gilde 'Mann mach hinne' | Clanseiten, Gildenseiten, Allianzseite ...
08:55:07 <mm_freak> thanks
08:56:45 <mopped> data Foo = Foo {x :: Integer, str :: String}
08:56:52 <mopped> Does that define two constructors, or what?
08:57:18 <Saizan> mopped: one constructor with two fields
08:57:21 <vixey> :t let foreach f [] = (); foreach f (x:xs) = flip const (f x) (foreach f xs) in foreach
08:57:22 <lambdabot> forall t b. (t -> b) -> [t] -> ()
08:57:28 <zenhacker_rouan> vixey: hey
08:57:43 <mopped> Is that the same as data Foo = Foo Integer String or what?
08:58:00 <cnwdup> Can I mix existential type declaration with a simple class declaration? I tried type PL a = (forall s . PluginClass s, SomeClass m) => StateT s m a but it won't be accepted.
08:58:00 <Saizan> it's similar to data Foo = Foo Integer String; x (Foo a _) = a; str (Foo _ b) = b;
08:58:15 <Saizan> plus syntactic sugar for pattern-matching/updates
08:59:17 <mopped> I think i'm going to have to re-look at types from scratch, I don't recognize that form :P
08:59:23 <Saizan> cnwdup: you probably want "data" rather than "type", and the syntax is forall s. (PluginClass s, SomeClass m) => ...
08:59:38 <cnwdup> saizan: Thanks (-:
08:59:47 <Saizan> mopped: which form?
09:00:03 <mopped> The original and the explanation
09:00:06 <rwbarton> cnwdup: I think writing that type is legal given enough extensions, but it's not an "existential" without data
09:00:17 <mopped> unless x (Foo a _) = a, is just a normal functiom
09:00:19 <mopped> and not types
09:00:29 <Saizan> mopped: yeah that's just a normal function
09:02:19 <mopped> Ok, so the {} syntax is ordered? as in the first entry refers to the first parameter and so on?
09:02:37 <dons> ?yow
09:02:38 <lambdabot> A dwarf is passing out somewhere in Detroit!
09:03:30 <Saizan> mopped: right, but if you always use the names to refer to the fields you don't have to worry about order
09:03:45 <dons> audreyt: around? what's the background for the sqlite upload?
09:03:50 <dons> is it just the one patched with your stuff?
09:04:06 <dons> audreyt: btw, we've got hosting now, so i'll set up the repo here, http://code.galois.com/cgi-bin/gitweb
09:04:07 <lambdabot> Title: code.galois.com Git
09:04:20 <Saizan> mopped: like in incrementX f@Foo{x=v} = f{x = v + 1}
09:05:00 <mopped> Say I have something of type Foo "bar" "Baz", x (Foo "bar" "Baz") would return "bar" and str (..) would return "Baz"?
09:05:31 <Saizan> mopped: it looks like you're mixing types and values to me
09:05:32 <mopped> Is that a type Saizan, seems quite like gibberish to me!
09:06:29 <Saizan> data Foo = Foo {x :: Integer, str :: String}, Foo 1 "bar" :: Foo
09:07:02 <Saizan> so, x (Foo 1 "bar") == 1, str (Foo 1 "bar") == "bar"
09:07:19 <Saizan> x :: Foo -> Integer
09:07:27 <Saizan> str :: Foo -> String
09:07:33 <Saizan> they are just accessor functions
09:08:16 <Saizan> they don't have much to do with the type level
09:08:26 <mopped> ok
09:08:38 <Saizan> but it's convenient to define the field names while defining the datatype
09:09:20 <Igloo> Does anyone know how I can get GHC to find libcurl here: http://hpaste.org/11447
09:09:26 <Igloo> (cygwin)
09:11:08 <mopped> What about your incermentX example, could you explain that?
09:13:17 <Saizan> there are two other uses of field names, which are purely syntactic sugar, one is in pattern, so if you define a function like "baz Foo{x=v) = ..." it desugars to "baz (Foo v _) = ..."
09:14:26 <Saizan> the other is update syntax: if f :: Foo, f {x = v} == (\(Foo _ b) -> Foo v b) f
09:15:45 <Saizan> you can use multiple fields at a time by separating them with a comma, like f {x=1, str = "foo"}
09:17:17 <mopped> right, thanks
09:36:27 <swiert> coq
09:47:23 <swiert> @users
09:47:23 <lambdabot> Maximum users seen in #haskell: 547, currently: 514 (94.0%), active: 7 (1.4%)
09:48:15 <Peaker> active in what time frame?
09:53:48 * Baughn is the spare change in the vending machine of science.
10:00:03 <user317> does anyone know where i can find more documentaiton on using ghc as library?
10:00:32 <swiert> user317: http://www.haskell.org/haskellwiki/GHC/As_a_library
10:00:34 <lambdabot> Title: GHC/As a library - HaskellWiki
10:00:50 <user317> thats really light on details
10:01:09 <Baughn> user317: What details are you missing?
10:01:31 <Baughn> user317: You can also look at the source code of mueval for a use case. Or perhaps you could just use mueval?
10:01:33 <swiert> You could ask nominolo, he's working with it quite a bit atm.
10:01:48 <user317> hmm, whats mueval
10:02:06 <Baughn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
10:02:07 <user317> oh cool
10:02:07 <lambdabot> Title: HackageDB: mueval-0.6.4
10:03:39 <user317> is there a haddock for GHC as a library api's?
10:04:53 <Baughn> user317: Ah.. nope.
10:07:30 <gour> hi, anyone has some success with Hare/Emacs?
10:08:06 <user317> cool, i found http://www.haskell.org/ghc/dist/current/docs/libraries/ghc/GHC.html
10:08:08 <lambdabot> Title: GHC, http://tinyurl.com/6aozwj
10:11:12 <ski> Peaker : assuming `IO a = RealWorld -> (a,RealWorld)', would `RealWorld' be a capability, e.g. wrt to `openFile :: FilePath -> IOMode -> IO Handle' ?
10:12:13 <Baughn> ski: Yes. Or a table of capabilities, more likely
10:12:57 <ski> (but a quite course-grained one ..)
10:13:27 <Baughn> It doesn't *have* to be coarse-grained
10:15:25 <ski> (depends on what "it" refers to :)
10:17:38 <Baughn> ski: The table of capabilities in IO. You'd use the monad to store them for later use, of course; there's no inherent need for that table to be /coarse-grained/ though
10:18:01 <Baughn> ski: Though of course if you're emulating posix it would be, but why do that? System.IO needs replacement anyway. ;)
10:22:20 <ski> what would be coarse-grained would be to pass the whole `RealWorld' capability in and out of every function using capabilities at all (as the `IO' monad could be construed to do)
10:22:56 <Baughn> Sometimes it's useful to pass all capabilities along. Sometimes it isn't.
10:23:10 <ski> aye
10:23:24 <Baughn> Practically speaking, you'd have IO pass all of them along, but then have special functions to filter out a few when you want to reduce it
10:23:25 <vixey> http://strictlypositive.org/a-case/
10:23:26 <lambdabot> Title: A Case for Dependent Families
10:23:36 <vixey> this is ofunny
10:25:39 <audreyt> dons: yes, it's just the one patched with the patches I sent to you... meant to send you a ping later today
10:26:23 <audreyt> dons: I have a coming patch that upgrades the bundled sqlite to the latest version but that's not critical for $job
10:26:37 <clogged> Cale: was it you that said Python is not a language, just glue? If so, do you think LISP is? do you think JAVA is?
10:27:45 <audreyt> ...maybe it's because Python doesn't have a navy...
10:38:03 <mattam> vixey: ;)
10:40:43 <dons> audreyt: ok. sounds good. send the patch. i'll have the git repo online next week
10:43:03 <jpcooper> @hoogle [a] -> a -> [a]
10:43:03 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:43:03 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:43:03 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:43:36 <ziman> which *morphism is (ana . cata)?
10:44:03 <audreyt> dons: cool! any reason why not use github as a mirror?
10:46:21 <vixey> ziman: I think that's hylo
10:47:06 <ziman> well, hylo is the other way around (cata . ana)
10:47:06 <ddarius> cata . ana is hylo
10:48:04 <Baughn> With a library (eg. hFuse) telling me it /has/ to be compiled with -threaded, will it work with GHCi?
10:48:11 <ziman> i'm just wondering how to classify heapsort :)
10:48:27 <Baughn> I'd try, but I'm suspecting race conditions might result
10:49:13 <Baughn> ziman: Also, given that ana and cata are more reasonably called fold and unfold (but which is which? I have no idea), what is hylo?
10:49:13 <user317> i am trying to run this example http://www.haskell.org/haskellwiki/GHC/As_a_library but when i compile it i get an error: "    Could not find module `DynFlags':rn      it is a member of package ghc-6.10.0.20081007, which is hidden
10:49:15 <lambdabot> Title: GHC/As a library - HaskellWiki
10:49:32 <dons> audreyt: not sure. we like github.
10:49:33 <Baughn> user317: Are you compiling with --make?
10:49:36 <user317> yea
10:49:43 <Baughn> user317: Hm. Try -package ghc, then
10:49:54 <dons> audreyt: http://code.galois.com/cgi-bin/gitweb
10:49:55 <lambdabot> Title: code.galois.com Git
10:50:05 <Baughn> user317: Alternately, sudo ghc-pkg unhide ghc, but I'm thinking there's a /reason/ it's hidden
10:50:09 <dons> audreyt: so looks like a few more things need to move in. but we'll have accounts and so forth.
10:50:25 <user317> oh, duh, thanks, i forgot about the package flag
10:51:34 <Baughn> user317: --make *is* supposed to use it automatically, but obviously not with hidden packages
10:51:54 <Baughn> user317: Alternately there's the always convenient cabal. mkcabal gets you started on that.
10:53:16 <ziman> > let hylo f g x = foldr f x . unfoldr g; fac = hylo (*) (\n -> if n == 0 then Nothing else Just(n,n-1)) 1 in fac 6
10:53:17 <lambdabot>   720
10:57:54 <ziman> phoenixmorphism :)
10:58:03 <ddarius> ziman: metamorphism is one name
10:58:41 <ziman> ddarius, thanks
10:58:57 <ddarius> It would be clearer to just say unfold . fold
10:59:50 <ziman> sure it is, i just wanted to know whether there's a name for this scheme, too :)
11:13:09 <mopped> I'm getting used to vim co-inciding with learning haskell, I was wondering if anyone could reccomend a vmirc or other tweeks or whatever? :P
11:14:35 * Baughn pouts at another potential Emacser lost to the darkness
11:15:03 <Deewiant> mopped: http://www.vim.org/scripts/script.php?script_id=2062 if you don't have it already
11:15:04 <lambdabot> Title: haskell.vim - Syntax file for Haskell : vim online
11:17:25 <mopped> thanks
11:17:40 <xcthulhu> Baughn: At least he wasn't lost to python?
11:18:29 <Baughn> xcthulhu: True. Say, does http://brage.info/~svein/chaos.png look as disturbing to you as it does to me?
11:18:36 <mopped> Hey, I've yet to open vimtutor Baughn, vim was reccomended because it was runnable "anywhere"!
11:18:45 <mopped> (although I don't code anywhere..)
11:18:51 <Baughn> mopped: Including on things ghc aren't, yep. :P
11:19:09 <mopped> What's the difference?
11:19:15 <Baughn> mopped: If it matters, emacs' system requirements are considered very low by modern standards. They're considerably lower than ghc's.
11:19:28 <byorgey> Baughn: that is bizzare
11:19:38 <Baughn> byorgey: That's the power of the chaos star
11:20:14 <byorgey> I was like, woah, this is a strange animation
11:20:27 <byorgey> and then I realized... it's not an animation!
11:20:29 <mopped> What's the difference? between vim and emacs Baughn (I've already heard the biased side of vim!)
11:20:35 <Deewiant> Baughn: it's not "the chaos star", there's not even a star in the middle in the original :-P
11:20:59 <Baughn> Deewiant: True. But I wonder if the warhammer players I'm going to freak out with it will realize that?
11:21:17 <Baughn> mopped: Hm. If you want my viewpoint..
11:21:28 <Baughn> mopped: Vim is a good editor, with a steep learning curve
11:21:33 <BMeph_> Needs more red, IMO. :)
11:21:52 <Baughn> BMeph: Good idea
11:22:12 * BMeph polishes his horns...
11:22:12 <Baughn> mopped: Emacs is a mediocre editor, with a shallow learning curve, but an excellent editor construction kit, with a middling learning curve
11:22:42 <mopped> What's the difference between mediocre and good - i've been using gedit/nano and notepad++ till now!
11:22:45 <Baughn> mopped: Also, Emacs has good support for Haskell. Probably quite a lot better than vim, but I don't actually know that.
11:23:12 <Baughn> mopped: Hm. Basically.. You'll get good at vim in a few months, and then it'll stay just as good for decades
11:23:27 <Deewiant> I beg to differ
11:23:36 <Baughn> mopped: You'll get good at emacs in a few months, and then you'll start to write your own editor that never stops getting better
11:23:38 <Deewiant> I'm still learning after a year :-P
11:23:51 <Raynes> Emacs haskell mode is very exceptional.
11:23:51 <Baughn> Still, with vim there's a plateau. :P
11:23:58 <xcthulhu> Baughn: They both have fine support for haskell
11:24:03 <Baughn> Eventually you know everything there is to do with it
11:24:12 <Baughn> xcthulhu: Vim has an equivalent of haskell-indentation.el?
11:24:25 <mopped> Well, what's so excellent - Is there a feature list of the haskell mode?
11:24:27 <Deewiant> Yes, with emacs that's impossible because it's so huge :-P
11:24:35 <xcthulhu> Baughn: Hmm... I'm not entirely sure
11:24:53 <xcthulhu> Baughn: To be honest, I do all my coding in literate latex.
11:25:04 <xcthulhu> emacs has much better support for latex
11:25:16 <Baughn> mopped: Not recently, I'm afraid
11:25:26 <ddarius> Baughn: vim users spend their time writing code not tweaking their configuration
11:25:36 <Baughn> ddarius: Their loss
11:26:11 <Deewiant> I suppose not all emacs users hack their editor either
11:26:21 <Baughn> If they don't, they're doing it wrong
11:26:30 <mopped> What's the main emacs client then? Putting emacs in terminal gives me a large number :P
11:26:39 <Baughn> mopped: Usually just called "emacs". :P
11:27:06 <xcthulhu> mopped: The popular ones are emacs and xemacs
11:27:08 <Baughn> mopped: It works both in terminals and as an X11 program, of course
11:27:12 <xcthulhu> emacs is pure command line.
11:27:29 <Baughn> xcthulhu: That hasn't been the case for a large part of a decade
11:27:48 <Baughn> Actually, is xemacs even still being developed? I got the impression it'd been abandoned
11:27:58 <Deewiant> Baughn, byorgey: in case you're interested in that illusion here's the author's page + two PDFs about it: http://www.ritsumei.ac.jp/~akitaoka/index-e.html
11:28:05 <rwbarton> Over a decade, I'm almost certain.
11:28:09 <lambdabot> Title: Akiyoshi's illusion pages
11:28:34 <Deewiant> xemacs is still developed AFAIK
11:28:47 <xcthulhu> Baughn: People still develop xemacs, I think.  It's the prefered front-end for lots of theorem proving systems.
11:28:48 <Baughn> Last release was over a year ago
11:28:51 <rwbarton> I think most of the new features xemacs brought us have been incorporated into regular emacs, so xemacs doesn't have the momentum it once did
11:29:04 <xcthulhu> Baughn: And latex hacking
11:29:13 <Deewiant> Baughn: looks like just under a year: november 10
11:29:22 <xcthulhu> ...which isn't really hacking...
11:30:03 <xcthulhu> Baughn: Hmm... okay, maybe development is stifled.
11:30:13 <xcthulhu> I don't always pay attention to that stuff I guess
11:30:23 * Baughn just uses Aquamacs anyhow
11:31:11 <xcthulhu> Baughn: To be honest ...I switched to texshop... for all of my haskell editing.
11:34:15 <mopped> Baughn: quick question, where can I type (require 'inf-haskell) and fnd (custom-set-variables) :P
11:34:27 <Baughn> mopped: ~/.emacs
11:34:39 <Baughn> mopped: Or rather, emacs runs ~/.emacs every time it starts
11:34:43 <BMeph> I've always wondered something: In the whole strict/eager vs. non-strict/lazy eval debate, strict language users are billed as claming they can add lazy annotation later. I wonder, though - how do they know where to put the annotations, and except for early termination, why would they?
11:34:54 <Baughn> mopped: That's not really how you should run it, though. Let me see..
11:35:26 <Deewiant> BMeph: well, you look for cases where a possibly-expensive computation may often be discarded
11:35:41 <ddarius> BMeph: The question is which is the default.  non-strict languages can just as easily have strictness annotations just as Haskell does.
11:35:57 <Baughn> mopped: http://hpaste.org/11448 <-- Have a look at this. You'll have to change the path, and the haskell-mode-map only works on OS X.. but you'll find it an useful template for defining your own shortcuts
11:36:04 <Baughn> mopped: So stick that in ~/.emacs
11:36:10 <ddarius> I'm of the opinion that the default is not particularly important.
11:36:39 <Baughn> mopped: And of course you'Ll need the latest version of haskell-mode
11:36:54 <mopped> yeah, i've got haskell mode
11:37:07 <Baughn> mopped: Right, but which one? CVS version?
11:37:09 <mopped> I just tried to C-c C-b and it chucked me an error which I googled :P
11:37:09 <Deewiant> Baughn: out of curiosity: wc -l ~/.emacs
11:37:10 <mopped> yes
11:37:15 <mopped> or rather
11:37:16 <flux> ddarius, although it is nice that lazy and strict values "look alike": there is no separate "lazy type" in the language
11:37:24 <mopped> repo version ;\
11:37:30 <Baughn> Deewiant: 234, but most of my code is in ~/.emacsd. ;)
11:37:43 <Deewiant> Baughn: and how long is that :-P
11:37:54 <Deewiant> Baughn: my vimrc is 269 :-P
11:37:57 <flux> but it is understandable that many languages want to put lazy values into their own league - performance
11:37:58 <Baughn> Deewiant: 8379
11:38:05 <Deewiant> ouch
11:38:08 <Baughn> Deewiant: I've been working on it for a while.
11:38:35 <Deewiant> I can tell :-P
11:38:42 <Baughn> flux: That need can be avoided simply by having a sufficiently smart compiler. ;)
11:39:40 <ddarius> The need to write your program at all can be avoided by having a sufficiently smart compiler.
11:40:12 <BMeph> ddarius: Or by engaging in "laziness optimization"... ;)
11:40:32 <Deewiant> main = print undefined :: IO WhatIWant#
11:40:33 <rwbarton> Or a sufficiently helpful IRC channel :)
11:40:38 <mopped> what is haskell-site-file Baughn, is it what you pasted?
11:41:00 <Baughn> mopped: Not likely, seeing as what I pasted /calls/ it.
11:41:08 <Baughn> mopped: It's part of haskell-mode
11:41:09 <mopped> yeah, i though the same!
11:41:46 <Baughn> mopped: In Emacs parlance, a site file typically loads the rest of a package, sets up paths and autoloaders, etc.
11:41:56 <Baughn> mopped: So when you get a new package, you'll want to load its site file
11:42:16 <flux> baughn, ah, yes, the "sufficiently smart compiler".. ;)
11:42:25 <Baughn> flux: GHC, that is. ^_^
11:43:05 <Baughn> mopped: You'Ll find the keybinding in my paste very useful, if you bind it to C-r or something - it loads your current buffer into the currently attached ghci session
11:43:15 <Baughn> mopped: Thus type-checking and so on
11:44:08 <mopped> buffer being the file im currently working on?
11:44:35 <Baughn> Yep
11:45:01 <mopped> thats handy
11:45:37 <Baughn> And that's why I think emacs is superior to vim. They may start out about the same, but with emacs you can do /this/..
11:45:53 <Deewiant> bad example, you can do that in vim as well :-P
11:46:23 <Baughn> Can you split the window in vim?
11:46:33 <Deewiant> no, that's what the window manager is for :-P
11:46:33 <Baughn> And have a ghci session running in half of it?
11:46:42 <Deewiant> I already have an OS, thanks :-P
11:46:51 <Baughn> Well, will vim talk to a ghci session and tell it to reload the file?
11:46:56 <ddarius> You can split the vim window
11:47:12 <ddarius> Baughn: It can, yes.
11:47:27 <Deewiant> Really?
11:47:48 <ddarius> Anyway, I have to go.
11:50:47 <xcthulhu> Emacs vs. VIM is just a religious debate
11:50:49 <xcthulhu> Honestly
11:51:32 <badsheepy> a debate where its blasphemous to even consider the notion that an editor should not take months to learn
11:52:05 <Gabby> Nano ftw.
11:52:08 * Gabby hides
11:52:37 <xcthulhu> badsheepy: Well, you can't say that in a chat-room devoted to a language where you need category theory to explain how IO works.
11:52:38 <olsner> fftw makes me want to have needs for fft transforms
11:52:50 <badsheepy> well thats a good point :)
11:53:16 <Baughn> xcthulhu: Erk. You mean I don"t understand IO? ;_;
11:53:30 <badsheepy> although, i dont actually understand it whatsoever, so i attempt not to consider it a language flaw just yet :)
11:54:17 <hasnew> M-x understand-category-theory :)
11:54:18 <xcthulhu> Baughn: I think I'm pretty good with it now.  I'm taking a haskell course where the teacher really emphasizes the theoretical stuff.
11:54:40 <xcthulhu> Baughn: Oh, you weren't asking if I understood it, sorry.
11:55:32 <Baughn> xcthulhu: I don't think IO in haskell is that hard. I understand you were making a joke, but you really don't need to understand nonsense just to understand haskell..
11:56:10 <xcthulhu> Baughn: I know.  Actually... the course is *too* theoretical for my tastes.  We sit around solving math problems instead of coding...
11:56:41 <vixey> math problems? How boring! I'd rather write a GUI in visual basic
11:56:54 <badsheepy> see i find it hard to do anything in haskell which isnt a math problem, just cause the monad business scares me :(
11:56:57 <osfameron> vixey: heh
11:57:29 <xcthulhu> badsheepy: I can recommend some category theory books if you want.
11:57:43 <xcthulhu> I found one for computer scientists the other day.
11:58:03 <Deewiant> badsheepy: how many monad tutorials have you read?
11:58:13 <xcthulhu> 3 I think?
11:58:18 <badsheepy> far more than i have understood in detail :p
11:58:28 <xcthulhu> Oh, not targeted at me..
11:58:32 <Botje> the secret is to forget about the tutorials
11:58:35 <Botje> and just start using them
11:58:36 <Deewiant> read a few more and then read them all again, and then play around
11:58:57 <xcthulhu> And learn Control.Monad :)
11:59:10 <badsheepy> yeah, that was my plan, jump in and take tissues for the tears
11:59:58 <xcthulhu> badsheepy: My favorite one is the "you could have invented monads" one
12:01:44 <hasnew> mine too
12:02:05 <mopped> I'm trying to launch the intepreter Baughn, and i'm getting 'Symbol's function definition is void: switch-to-haskell', and the '*Messages*' window is in-expandable - any ideas (or a point to where I can learn?)
12:02:59 <Baughn> mopped: There's always #emacs
12:03:03 <ttt--> "you could have written this monad tutorial"
12:03:49 <Baughn> mopped: There shouldn't be any issues if you load haskell-site-file first, though
12:04:45 <Apocalisp> It's best to understand Functor first. Maybe Applicative next, then Monad.
12:05:17 <Apocalisp> I found that grokking functors made it all click
12:05:17 <Deewiant> I'm fine with Functors and Monads but I don't get Applicatives :-P
12:05:32 <Deewiant> but I admit I haven't really tried to get Applicatives
12:05:41 <Deewiant> and FWIW, I learned Functors after Monads
12:05:48 <Apocalisp> Applicative functors are like monads, only less so. ;)
12:05:57 <Deewiant> although I do agree that starting with Functors is probably a good idea.
12:06:00 <Saizan> Deewiant: ever used "ap"?
12:06:37 <Deewiant> Saizan: only in the (r ->) monad, only for @pl'ing stuff. :-)
12:07:37 <Apocalisp> @type ap
12:07:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:07:51 <Apocalisp> @type (Control.Applicative.<*>)
12:07:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:08:08 <Deewiant> I know that <*> = ap for Monads
12:08:53 <Deewiant> and pure = return, and Alternative is MonadPlus.
12:09:11 <Deewiant> (where 'is' does not mean 'is'.)
12:09:51 <Apocalisp> is isomorphic to
12:09:53 <Apocalisp> ?
12:12:13 <Apocalisp> @type zipWith ($)
12:12:14 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
12:12:58 <Apocalisp> There's an applicative for lists that is not ap.
12:13:32 <Deewiant> ?ty ap :: [a -> b] -> [a] -> [b]
12:13:33 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
12:14:00 <Saizan> > [(+1)] `ap` [1..4]
12:14:01 <lambdabot>   [2,3,4,5]
12:14:20 <Deewiant> d'oh
12:14:27 <Saizan> > getZipList $ ZipList [(+1)] <*> ZipList [1..4]
12:14:28 <lambdabot>   [2]
12:15:00 <Apocalisp> > zipWith ($) [(+1)] [1..4]
12:15:01 <lambdabot>   [2]
12:16:34 <Apocalisp> > zipWith ($) [(+1),(+2),(+3),(+4))] [1..4]
12:16:36 <lambdabot>   <no location info>: parse error on input `)'
12:16:41 <Apocalisp> > zipWith ($) [(+1),(+2),(+3),(+4)] [1..4]
12:16:42 <lambdabot>   [2,4,6,8]
12:16:48 <Apocalisp> > ap [(+1),(+2),(+3),(+4)] [1..4]
12:16:49 <lambdabot>   [2,3,4,5,3,4,5,6,4,5,6,7,5,6,7,8]
12:22:01 <Apocalisp> @let fizzBuzz xs ns = let f n = maskInt n =<< xs; maskInt n x = if' (n `mod` (fst x) == 0) (snd x) "" in map (if' . null . f <*> show <*> f) ns
12:22:02 <lambdabot>  <local>:9:59: Not in scope: `if''
12:22:02 <lambdabot>  
12:22:02 <lambdabot>  <local>:9:105: Not in scope: `if''
12:22:13 <Apocalisp> @type if'
12:22:14 <lambdabot> Not in scope: `if''
12:22:38 <int-e> if' p x y = if p then x else y
12:23:01 <rwbarton> @let if' p x y = if p then x else y
12:23:07 <lambdabot>  Defined.
12:23:29 <Apocalisp> @let fizzBuzz xs ns = let f n = maskInt n =<< xs; maskInt n x = if' (n `mod` (fst x) == 0) (snd x) "" in map (if' . null . f <*> show <*> f) ns
12:23:29 <Deewiant> > take 10 $ map(\n->snd.head.snd$span((>0).mod n.fst)[(15,"FizzBuzz"),(5,"Buzz"),(3,"Fizz"),(n,show n)])[1..100]
12:23:31 <lambdabot>  Defined.
12:23:31 <lambdabot>   mueval: Prelude.read: no parse
12:23:31 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
12:23:44 <Deewiant> > take 10 $ map(\n->snd.head.snd$span((>0).mod n.fst)[(15,"FizzBuzz"),(5,"Buzz"),(3,"Fizz"),(n,show n)])[1..100]
12:23:46 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz"]
12:23:48 <Deewiant> hmm
12:23:51 <Deewiant> that was interesting
12:23:55 <Apocalisp> > fizzBuzz [1..10]
12:23:56 <lambdabot>       Overlapping instances for Show ([a] -> [String])
12:23:56 <lambdabot>        arising from a ...
12:24:08 <Apocalisp> oops
12:24:11 <Deewiant> > fizzBuzz [(3,"Fizz")] [1..10]
12:24:12 <lambdabot>   ["1","2","Fizz","4","5","Fizz","7","8","Fizz","10"]
12:24:24 <Apocalisp> > fizzBuzz [(3,"Fizz"), (5, "Buzz")] [1..10]
12:24:25 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz"]
12:24:47 <Deewiant> > fizzBuzz [(3,"Fizz"),(2,"Buzz"),(4,"FizzBuzz")] [1..10]
12:24:48 <lambdabot>   ["1","Buzz","Fizz","BuzzFizzBuzz","5","FizzBuzz","7","BuzzFizzBuzz","Fizz",...
12:24:57 <Deewiant> right
12:27:03 <idnar> fizzbuzz again, eh
12:27:16 <Apocalisp> this time with applicatives!
12:31:38 <letitbit> Make money on the internet: http://letitbit.net/page/marsclub/partners.php
12:31:44 <lambdabot> Title: letitbit net - this is totally free file hosting. The speed and size of files is ...
12:38:34 <kowey> if I pass --enable-executable-profiling to cabal(-install), do I also get the non-profiling version of my executable?
12:41:12 <dcoutts> kowey: no
12:41:43 <kowey> thanks! :-)
12:51:14 <rook123456> is there a function to get all the substrings from a string? i.e: otto -> [otto, ott, tto, ot, tt, to, o, t, t, o]?
12:51:56 <pumpkin> shouldn't hard to write one, but I don't think there's an easily available one
12:52:19 <Apocalisp> > tails "otto"
12:52:20 <lambdabot>   ["otto","tto","to","o",""]
12:53:11 <Apocalisp> not quite
12:53:22 <C-Keen> > tails $ tails "otto"
12:53:23 <lambdabot>   [["otto","tto","to","o",""],["tto","to","o",""],["to","o",""],["o",""],[""]...
12:53:38 <skorpan> rook123456: ironically, that exact question was on a haskell exam last year at my school
12:54:00 <rook123456> and what was the solution? :)
12:54:10 <pumpkin> rook123456: it isn't that hard to write recursively
12:55:14 <Apocalisp> [inits, tails] `ap` "otto"
12:55:19 <Apocalisp> > [inits, tails] `ap` "otto"
12:55:20 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
12:55:58 <Deewiant> > let f x = nub . filter (`isInfixOf` x) . concatMap (flip replicateM x) $ [1..length x] in f "otto"
12:55:59 <lambdabot>   ["o","t","ot","to","tt","ott","tto","otto"]
12:56:13 <pumpkin> > map inits (tails "abc")
12:56:15 <lambdabot>   [["","a","ab","abc"],["","b","bc"],["","c"],[""]]
12:56:24 <rook123456> thanks a lot Deewiant
12:56:31 <Apocalisp> > join $ ap [inits, tails] ["otto"]
12:56:32 <lambdabot>   ["","o","ot","ott","otto","otto","tto","to","o",""]
12:56:35 <Deewiant> rook123456: that's a pretty bad solution, I don't suggest you use it :-P
12:56:51 <Twey> > map inits (tails "abcd")
12:56:51 <pumpkin> Apocalisp: missing tt
12:56:52 <lambdabot>   [["","a","ab","abc","abcd"],["","b","bc","bcd"],["","c","cd"],["","d"],[""]]
12:57:21 <pumpkin> > concatMap inits (tails "otto")
12:57:23 <lambdabot>   ["","o","ot","ott","otto","","t","tt","tto","","t","to","","o",""]
12:57:27 <pumpkin> :P
12:57:44 <Twey> > filter (/= "") . concat $ tails "otto"
12:57:45 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
12:57:51 <Twey> :(
12:58:02 <Deewiant> > concat $ tails "otto"
12:58:03 <Twey> :(Oh
12:58:04 <lambdabot>   "ottottotoo"
12:58:16 <Twey> > filter (/= "") . concat . map inits $ tails "otto"
12:58:17 <lambdabot>   ["o","ot","ott","otto","t","tt","tto","t","to","o"]
12:58:23 <Twey> There we go.
12:58:30 <pumpkin> Twey: now we just need a uniq on it :P
12:58:35 <Twey> Yeah :)
12:58:40 <Twey> > nub . filter (/= "") . concat . map inits $ tails "otto"
12:58:41 <lambdabot>   ["o","ot","ott","otto","t","tt","tto","to"]
12:58:53 <pumpkin> nub :o
12:59:02 <pumpkin> :t nub
12:59:03 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:59:08 <pumpkin> @src nub
12:59:08 <lambdabot> nub = nubBy (==)
12:59:10 <Twey> Oh
12:59:12 <Twey> The original didn't have the nub though
12:59:12 <Twey> 205105 < rook123456> is there a function to get all the substrings from a string? i.e: otto -> [otto, ott, tto, ot, tt, to, o,  t, t, o]?
12:59:20 <Twey> Oh well, nub or no nub, rook123456, do as you like
12:59:34 <ttt--> does nub stand for a word?
12:59:40 <Deewiant> no, it is a word
12:59:41 <pumpkin> nüb
12:59:46 <pumpkin> for n00bs
12:59:54 <Deewiant> no, not that :-P
12:59:58 <pumpkin> oh
13:00:05 <rook123456> thanks a lot guys
13:00:07 <pumpkin> I thought it just did the magic n00bs needed to solve their problem
13:00:13 <pumpkin> nub (P == NP)
13:00:17 <Deewiant> @wn nub
13:00:18 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
13:00:20 <lambdabot> nub
13:00:22 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
13:00:24 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
13:00:28 <lambdabot>      3: the choicest or most essential or most vital part of some
13:00:30 <lambdabot> [5 @more lines]
13:00:35 <pumpkin> fail
13:00:39 <Deewiant> no, success
13:00:46 <pumpkin> surely you mean win
13:00:50 <Deewiant> no, success
13:00:52 <pumpkin> otherwise you can't be a true lolcat
13:00:57 * pumpkin hands out lolcat licenses
13:00:58 <Deewiant> how unfortunate
13:01:03 * Deewiant refuses to accept one
13:01:07 <pumpkin> :(
13:01:07 <Twey> What better motive?
13:01:12 * Twey too.
13:01:14 <pumpkin> well I wouldn't have offered you one cause you used success
13:01:19 <Apocalisp> > nub . filter (/= "") $ inits =<< tails "otto"
13:01:20 <pumpkin> :(
13:01:21 <lambdabot>   ["o","ot","ott","otto","t","tt","tto","to"]
13:01:29 <ttt--> @src nub
13:01:29 <lambdabot> nub = nubBy (==)
13:01:33 <pumpkin> Apocalisp: now that's crazytalk
13:01:34 <ttt--> @src nubBy
13:01:35 <lambdabot> nubBy eq []             =  []
13:01:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:03:15 <BMeph> > map (tail.inits).tails$"otto"
13:03:16 <lambdabot>   [["o","ot","ott","otto"],["t","tt","tto"],["t","to"],["o"],[]]
13:03:29 <BMeph> > concatMap (tail.inits).tails$"otto"
13:03:30 <lambdabot>   ["o","ot","ott","otto","t","tt","tto","t","to","o"]
13:03:39 <Deewiant> > concatMap (init.tails).inits$"otto"
13:03:40 <lambdabot>   ["o","ot","t","ott","tt","t","otto","tto","to","o"]
13:03:56 <C-Keen> : hPutStr
13:04:01 <C-Keen> :t hPutStr
13:04:02 <lambdabot> Not in scope: `hPutStr'
13:04:16 <C-Keen> @hoogle hPutStr
13:04:16 <lambdabot> Data.ByteString hPutStr :: Handle -> ByteString -> IO ()
13:04:16 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
13:04:16 <lambdabot> Data.ByteString.Char8 hPutStr :: Handle -> ByteString -> IO ()
13:04:48 <Apocalisp> @let lolcatMap x = \y -> repeat "cheezburger"
13:04:49 <lambdabot>  Defined.
13:05:57 <C-Keen> @hoogle stderr
13:05:58 <lambdabot> System.IO stderr :: Handle
13:07:01 <Apocalisp> @let lolcatMap = (map (("I can haz " ++) . show)) . map
13:07:01 <lambdabot>  <local>:11:0:
13:07:01 <lambdabot>      Equations for `lolcatMap' have different numbers of argum...
13:07:10 <C-Keen> heh
13:07:12 <Apocalisp> @undef lolcatMap
13:08:12 <Apocalisp> @let lolcatMap = (map (("I can haz " ++) . show)) . map
13:08:12 <lambdabot>  <local>:1:0:
13:08:12 <lambdabot>      Equations for `lolcatMap' have different numbers of argume...
13:08:54 <Apocalisp> @let lolcatmap = (map (("I can haz " ++) . show)) . map
13:08:55 <lambdabot>  Couldn't match expected type `[a]'
13:09:30 <vixey> did anyone here use agda 2?
13:09:43 <vixey> I wonder if someone has already tried to code up the SPF stuff in it?
13:10:33 <BMeph> vixey: Which SPF stuff? :)
13:10:55 <vixey> anything from Peter Morris work
13:11:01 <Apocalisp> @lolcatmap ["cheezburger","cookie","lambda"]
13:11:01 <lambdabot> Unknown command, try @list
13:11:06 <Apocalisp> > lolcatmap ["cheezburger","cookie","lambda"]
13:11:07 <lambdabot>   Couldn't match expected type `a1 -> a'
13:11:18 <Apocalisp> > lolcatmap id ["cheezburger","cookie","lambda"]
13:11:20 <lambdabot>   ["I can haz \"cheezburger\"","I can haz \"cookie\"","I can haz \"lambda\""]
13:11:23 <vixey> http://www.cs.nott.ac.uk/~pwm/
13:11:24 <lambdabot> Title: Peter Morris's Homepage
13:13:53 <Apocalisp> > lolcatmap (+1) $ repeat 1
13:13:55 <lambdabot>   ["I can haz 2","I can haz 2","I can haz 2","I can haz 2","I can haz 2","I c...
13:13:59 <rook123456> http://hpaste.org/11452 <-- the performance of this solution of getting all the maximum-length palindroms of a string is not very good, is there a way of increasing it?
13:14:06 <Apocalisp> > lolcatmap (+1) $ [1..10]
13:14:07 <lambdabot>   ["I can haz 2","I can haz 3","I can haz 4","I can haz 5","I can haz 6","I c...
13:14:29 <Deewiant> rook123456: nub is slow, use 'map head . group . sort' instead
13:15:09 <mofmog> > let a = do { print "hi"; a}
13:15:10 <lambdabot>   <no location info>: parse error on input `;'
13:15:15 <mofmog> woops
13:16:52 <rook123456> thanks Deewiant
13:19:54 <Peaker> ski: I don't think IO/RealWorld maps to anything in cap terminology, and its ambient. If you did limit access to the IO monad and RealWorld, maybe you could consider them caps, but they encompass a whole class of things you can do, rather than limit access to any specific object, so I'm not sure they're very useful as a security scheme
13:20:33 <Peaker> ski: (they can't be very fine grained, as their granularity is type-based, and not value-based)
13:24:31 <vixey> BMeph, it's quite hard
13:24:46 <conal> has anyone here tried GLUT on with ghc >= 6.10 in Windows?  i'm getting crashes for the simplest glut program i can construct.
13:24:56 <vixey> agda doesn't like it much
13:25:38 <BMeph> vixey: Hard to read? Hard to implement? Hard to understand? ...hard to get a "cheezburger"? ;p
13:25:45 <vixey> to implement
13:29:57 <BMeph> vixey: Hmm, I'll start "slow" and check the McBride paper first...
13:30:10 * _omy_ omy
13:32:24 <Twey> Hmm
13:32:34 <Twey> If I want to produce HTML 4.01 Strict, which library should I use?
13:32:58 <Twey> Text.Html seems to only support HTML 3.2, and Text.Xhtml seems to only support... well, XHTML
13:34:16 <Deewiant> conal: I'm compiling HOpenGL at the moment, I'll tell you if it works
13:36:56 <Peaker> conal: cabal install glut on ghc 6.10 seems to work cleanly here
13:37:27 <Twey> I'd like something validating.
13:39:16 <conal> Peaker: which OS?
13:40:11 <Peaker> conal: Ubuntu hardy
13:40:28 <Peaker> but all the Haskell stuff is built from scratch (for ghc 6.10)
13:42:29 <conal> so far, the crashing problem seems to be specific to Win32.
13:42:39 <conal> Deewiant: which OS?
13:42:48 <Deewiant> conal: Windows XP
13:43:33 <conal> Deewiant: great, thx.  seems to work on OSX and linux and crash on Windows.  it'd be great to get a second data point on Windows before reporting the problem.
13:44:06 <Peaker> conal: did you resolve the strictness issues of the memoization technique you demonstrated on your blog?
13:44:17 <Deewiant> conal: seems to work fine here: a short app using FTGL+GLUT+OpenGL
13:44:19 <conal> Peaker: no
13:45:33 <Peaker> conal: oh sorry, I thought the build itself crashed. is there any simple program using GLUT installable from cabal?
13:46:18 <conal> Deewiant: would you please try out http://hpaste.org/11453 ?
13:46:56 <Twey> I'd also be happy if there were something that could convert an XHTML 1.0 Strict tree to an HTML 4.01 Strict tree...
13:47:19 <conal> Peaker: would you also try the paste on ubuntu hardy?
13:47:29 <Peaker> conal: yeah, it worked
13:47:34 <conal> thx
13:48:07 <Deewiant> conal: builds and runs fine.
13:48:43 <conal> okay, so the problem is on my end somehow.  i wonder what it could be.
13:48:48 <Deewiant> conal: GHC 6.10.0.20081007 for what it's worth.
13:49:34 <conal> Deewiant: thx.  that's one of the versions that crashes for me.  strangely my 6.9 doesn't crash.
13:49:52 <Peaker> conal: what about -fvia-c?
13:54:14 <Peaker> conal: why do you use an associated type instead of a fundep?
13:54:25 <conal> Peaker: where?
13:55:31 <Peaker> conal: VectorSpace (blog post)
13:56:19 <conal> Peaker: i use a couple there.  do you mean for VectorSpace or for Basis or something else?
13:57:39 <Peaker> conal: http://conal.net/blog/posts/vector-space-bases-via-type-families/
13:57:44 <lambdabot> Title: Conal Elliott » Vector space bases via type families
13:57:47 <Peaker> class AdditiveGroup v => VectorSpace v where
13:57:48 <Peaker>   type Scalar v :: *
13:59:19 <conal> Scalar could be a fundep instead.  i think the current version still is, due to bugs in 6.9.  the extra type param though shows up in subclasses, even where it's not useful.
14:00:09 <Peaker> ah, ok
14:05:29 <conal> Deewiant: do you now where you got your glut and opengl libs?
14:06:14 <conal> Deewiant: also, how did you compile & run that simple glut program?
14:06:34 <conal> whois Deewiant
14:09:01 * vixey has given up 
14:09:08 <Peaker> vixey: on what?
14:11:49 <BMeph> conal: 'fess up, you just wanted to get "space base" into your maths papers, didn't you? ;p
14:12:24 <conal> :)
14:13:41 <ddarius> @google "hand grenade" "set theory"
14:13:44 <lambdabot> http://wwwmath.uni-muenster.de/logik/Personen/rds/
14:13:44 <lambdabot> Title: Ralf Schindler's home page
14:17:25 <cnwdup> Can I run a state computation from within a state computation? I'm trying to construct a type like StateT s (StateT s IO) a, but I can't get it working. Is it possible?
14:17:51 <ddarius> Sure
14:18:00 <cnwdup> ddarius: So what's wrong with the type?
14:18:07 <vixey> :k StateT s (StateT s IO) a
14:18:08 <lambdabot> Not in scope: type variable `s'
14:18:08 <lambdabot> Not in scope: type variable `s'
14:18:08 <lambdabot> Not in scope: type variable `a'
14:18:37 <vixey> :t undefined :: StateT s (StateT s IO) a
14:18:38 <lambdabot> forall s a. StateT s (StateT s IO) a
14:18:45 <vixey> that type is fine
14:18:46 <ddarius> cnwdup: Nothing.  What error are you getting?
14:19:51 <cnwdup> Mh, StateT Int (StateT String IO) a is fine, but type Inner a = StateT Int Outer a with type Outer a = StateT String IO a is not.
14:20:20 <ddarius> You can't partially apply type synonyms.
14:20:32 <ddarius> You can write Outer as: type Outer = StateT String IO
14:20:53 <ddarius> In general, I'd recommend eta reducing type synonyms as much as possible.
14:21:18 <ddarius> So I'd also recommend rewriting Inner's type synonym in a similar way.
14:21:26 <insane> hi did anyone try to make animations using haskell?
14:21:32 <cnwdup> Thanks you two. With that my example is working.
14:21:38 <ddarius> @google Fran Haskell
14:21:40 <lambdabot> http://conal.net/fran/
14:21:40 <lambdabot> Title: Functional Reactive Animation (Fran)
14:21:43 <insane> or tried to use libraries such as wxhaskell or gtk2hs for this purpose?
14:22:39 <idnar> @src foldl
14:22:39 <lambdabot> foldl f z []     = z
14:22:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:49:38 <b0fh_ua> hello! can somebody please advice some articles and resources about web development in Haskell?
15:14:07 <LynxAba> hello everybody! i don't understand why this function doesn't work, ghci says "not instance for (Show ([t]->[t]))"
15:14:36 <Cale> LynxAba: apparently you're trying to show a function
15:14:38 <LynxAba> deleteRepeated [] _ = []
15:14:38 <LynxAba> deleteRepeated (x:xs) y | elem x y = deleteRepeated xs y
15:14:38 <LynxAba>                            | otherwise = x : deleteRepeated xs y
15:14:50 <Cale> Perhaps you didn't apply it to enough parameters?
15:14:53 <LynxAba> tha's the function, hello Cale
15:14:59 <Cale> hi :)
15:15:20 <Cale> How did you call it?
15:15:20 <LynxAba> but i don't understand, i'm almost sure i'm right
15:15:39 <LynxAba> deleteRepeated
15:15:50 <LynxAba> here it goes again
15:15:55 <LynxAba> deleteRepeated [] _ = []
15:15:57 <LynxAba> deleteRepeated (x:xs) y | elem x y = deleteRepeated xs y
15:16:00 <LynxAba>                            | otherwise = x : deleteRepeated xs y
15:16:07 <Cale> yes, I saw that
15:16:07 <zerber> argh, stop pasting :(
15:16:12 <Cale> How are you calling that function?
15:16:17 <LynxAba> hehe sorry
15:16:33 <Japsu> deleteRepeated = head . group?
15:16:40 <Japsu> @let deleteRepeated = head . group
15:16:41 <lambdabot>  <local>:2:24:
15:16:41 <lambdabot>      Ambiguous type variable `a' in the constraint:
15:16:41 <lambdabot>        `Eq...
15:16:48 <LynxAba> you mean the signature?
15:16:48 <Japsu> ffs
15:17:05 <Japsu> > let deleteRepeated = head . group in deleteRepeated [1,2,2,2,3,4,5]
15:17:06 <lambdabot>   [1]
15:17:09 <Japsu> oops.
15:17:13 <Japsu> > let deleteRepeated = map head . group in deleteRepeated [1,2,2,2,3,4,5]
15:17:15 <lambdabot>   [1,2,3,4,5]
15:17:18 <Japsu> ^____^
15:17:49 <Cale> LynxAba: Does it give you that error when you just load the function into ghci?
15:18:25 <LynxAba> well, thanks! but what does group do?
15:18:35 <LynxAba> no, when i use it
15:18:41 <Cale> LynxAba: right.
15:18:50 <Cale> LynxAba: So how are you trying to use it?
15:19:20 <Japsu> LynxAba: see,
15:19:21 <Cale> LynxAba: Are you giving it all the parameters that it needs?
15:19:24 <Japsu> > group [1,2,2,2,3,4,5]
15:19:26 <lambdabot>   [[1],[2,2,2],[3],[4],[5]]
15:19:38 <Peaker> > nub [1,2,2,1,3,5]
15:19:39 <lambdabot>   [1,2,3,5]
15:19:52 <LynxAba> no, i'm so dumb!
15:19:54 <LynxAba> sorry
15:20:02 <Japsu> Peaker: nub is different
15:20:13 <LynxAba> by the way, i forgot the nub function! XD
15:20:17 <Cale> Japsu: That does what the name 'deleteRepeated' might suggest, but doesn't do the same thing as his function.
15:20:24 <LynxAba> is it different?
15:20:24 <Japsu> from map head . group, that is
15:20:41 <Japsu> well my intuition would say map head . group is what deleteRepeated means
15:21:00 <Japsu> deleteRepeated, not deleteDuplicates
15:21:06 <Peaker> Japsu: yeah
15:21:17 <Peaker> Japsu: I think he wrote nub though
15:21:18 <Cale> His function removes all the elements of its second parameter from its first (regardless of how many times they occur)
15:21:24 <Japsu> Peaker: might be
15:21:26 <Japsu> ok
15:21:28 <Cale> Did anyone even look at his code?
15:21:29 <Cale> :)
15:21:39 <zerber> exciseAdjacentDuplicates
15:21:48 <Peaker> his "y" is not being built properly, just passed around
15:21:54 <Cale> built?
15:22:00 <Twey> Is there a bag module in Hackage?
15:22:18 <Twey> Or GHC?
15:22:19 <byorgey> seem like y is supposed to accumulate elements already seen
15:22:23 <Cale> He wrote the equivalent of  deleteRepeated xs ys = filter (`notElem` ys) xs
15:22:33 <byorgey> *seems
15:22:36 <LynxAba> i'm actually wrong
15:22:52 <Cale> Which I assume is what he actually meant to write, but perhaps he actually meant something entirely different.
15:23:17 <qwr> uh. stupid non-haskell question... is there any specific name for upward-only-continuations (and i'm not looking for the name "exception" ;))?
15:23:29 <Cale> qwr: "upward"?
15:23:32 <Peaker> Cale: My guess is that he meant for "y" to accumulate seen elements
15:23:49 <zerber> longjmp
15:23:53 <LynxAba> originally deleteRepeated used to use as y the xs, but in my redefinition i forgot that that will not work (the use of a complete list to find an element)
15:24:12 <qwr> Cale: basically like call/cc, but you can't re-enter old code state using it
15:24:17 <LynxAba> ***originally deleteRepeated used to use y as xs
15:24:22 <qwr> Cale: only escape
15:24:34 <vixey> qwr, exceptions..?
15:25:32 <LynxAba> Cale: well yes, the function returns something totally different from the name, i'm wrong
15:25:41 <qwr> vixey: yeah :) ok. i actually search for a good function name. now escape seems quite good :)
15:26:10 <qwr> vixey: that is good function name for that kind of call/cc wannabe function
15:26:45 <Twey> Oh, here it is, haskell-multiset
15:26:49 <Cale> qwr: maybe like getCC?
15:27:34 <Cale> hmm
15:27:50 <Cale> Or perhaps that's the opposite of what you want :)
15:29:51 <LynxAba> btw, another question, wich one would be more efficient, nub or map (head . group)   ???
15:30:21 <qwr> Cale: i don't know. getCC doesn't sound like that. its basically exactly like schemes call/cc, but the "continuation" don't work after returning from the given lambda and it is meant for mostly non-exceptional use :)
15:31:17 <LynxAba> Japsu: btw, another question, wich one would be more efficient, nub or map (head . group)   ???
15:31:51 <Peaker> isn't it map head . group ?
15:32:34 <Peaker> I think that "map head . group" can run in linear time, and that nub requires n*log(n) at best
15:32:50 <user317> is anyone familiar with using ghc as a library
15:33:50 <Twey> Peaker: Why do you think that?
15:33:53 <user317> i am loading a module and i can examine the symbols that it exports via modInfoExports, but how do do anything with those symbols?  Is there a way to extract symbols of a specific type, or test the type?
15:33:54 <Twey> Surely the time requirement is the same?
15:33:55 <byorgey> note, nub and map head . group are not actually the same.
15:34:07 <Twey> Aye
15:34:12 <Twey> Oh, yes.
15:34:16 <Peaker> Twey: because nub needs to prune from an ever growing list
15:34:17 <byorgey> map head . group only removes *consecutively* repeated elements, whereas nub removes *all* duplicates
15:34:19 <Twey> I see why.
15:34:20 * Twey nods.
15:34:50 <byorgey> but  map head . group . sort  does the same thing as   sort . nub, and is more efficient.
15:35:02 <LynxAba> hmmm then i will use nub
15:35:43 <Twey> What data structure is appropriate for an ordered data structure O(1) access at either end?
15:36:09 <Twey> Er, access = read, append/prepend
15:36:21 <zerber> Sequence
15:37:08 <Twey> Aha, thank you :)
15:42:59 <robthebob> hi, i'm trying to use quickcheck, but have run into a typing problem
15:43:22 <robthebob> when using ==>, i get "couldn't match expected type Bool against inferred type Property"
15:43:35 <robthebob> is there an obvious mistake i'm making here?
15:43:49 <Botje> can you put your code on hpaste?
15:45:13 <robthebob> ok, its up there
15:45:23 <robthebob> its a simple matrix multiplication algorithm
15:45:52 <robthebob> feel free to comment unfavourably on the style if necessary :)
15:46:17 <robthebob> the problem i'm having is with the prop_Multiply function at the bottom,
15:46:30 <robthebob> asserting the size of the resultant matrix is correct
15:48:17 <Saizan> oh, you just have to change the type signature
15:48:25 <Saizan> ?type (==>)
15:48:26 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
15:48:27 <Botje> ==> has type Bool -> a -> Property
15:49:11 <robthebob> ... embarrassing
15:49:18 <robthebob> thanks guys!
15:49:22 <Twey> zerber: So how do I access the right end of a Sequence?
15:49:33 * Twey feels like ve needs sleep :-P
15:49:46 <Saizan> Twey: viewr
15:50:16 <Twey> Oh, I see
15:50:45 <Twey> So I have to call viewr then pattern-match the first element off?
15:51:00 <Saizan> right
15:59:37 <Twey> Oh
15:59:46 <Twey> Saizan: Can I pattern-match with |>?
16:00:25 <Twey> last (_ |> x) = x
16:00:39 <ddarius> No.
16:01:04 <Twey> Oh :(  Hmn
16:01:04 <ddarius> You could, if you want, use the recent extensios view patterns
16:01:28 <rwbarton> Twey: Just like you can't pattern match with, say, *
16:01:45 <Twey> Aye, mm
16:02:03 <Twey> Just makes it a little clumsy-seeming
16:03:25 <BMeph> Twey: since you're applying the view(r|l) function to get it to a matchable form, you'd use view patterns. It's a natural fit. :)
16:03:54 <Twey> Mmm
16:04:00 <Twey> I'm not familiar with them, I'll look them up :)
16:04:09 <rwbarton> last (viewr -> (_ :> x)) = x
16:04:49 <Twey> Oh right :)  That's quite simple.
16:06:15 <BMeph> Twey: But yes, it is clumsy. Almost as bad as when you use a type to change some other type's behavior ('ZipList', First/Last monoids, 'Down' for descending-comparing order, et al.)
16:06:30 <Twey> Aye
16:06:37 <Peaker> what's a ZipList?
16:06:53 <BMeph> Twey: Hmm, never mind that "Almost" part, it's exactly as clumsy. :)
16:07:30 <BMeph> Peaker: ZipList is the name for the "other" Applicative form for lists.
16:08:27 <Peaker> BMeph: zipping instead of combinatoric?
16:09:24 <Cale> Do view patterns exist yet?
16:09:32 <BMeph> Peaker: Zipping instead of cross-product..."ing", however you'd describe that. :)
16:09:34 <Cale> 6.10 hasn't been released...
16:09:40 <rwbarton> , let f (id -> x : y) = x in f [3,4]
16:09:42 <lunabot>  3
16:10:18 <adamvo> hi, I'm having trouble building gtk2hs: http://hpaste.org/11458
16:10:18 <BMeph> Cale: IIRC, they've been an extension since 6.8.3, if not 6.8.2.
16:10:33 <LynxAba> i've found an alternative solution for nub,it is:
16:10:33 <LynxAba> nub' = (Data.Set.toList . Data.Set.fromList) ... is this better ? some people say yes, but there are some others that don't
16:11:09 <dcoutts> adamvo: the cairo C lib changed it's api slightly in the last release
16:11:12 <Cale> BMeph: Pattern guards have been around a while...
16:11:22 <Cale> BMeph: But ViewPatterns aren't in 6.8.2 at least.
16:11:25 <dcoutts> adamvo: either use the darcs version of gtk2hs or use an older version of the cairo C lib
16:11:56 <Cale> Btw, Ubuntu Intrepid doesn't seem to even have 6.8.3
16:12:40 <Twey> Oh dear
16:12:56 <ddarius> Cale: That's typical for Ubuntu.  The release cycles are out of phase.
16:13:06 <Cale> ddarius: Intrepid's not even released yet.
16:13:19 <Cale> ddarius: But it's past the freeze.
16:13:36 <ddarius> It has 6.8.2, but not 6.8.3?
16:15:15 <rwbarton> Debian unstable doesn't have 6.8.3 yet
16:16:41 <adamvo> dcoutts: Thanks, I'm trying to build the darcs version now
16:17:19 <hcube> hi! what's the easyest way to compile HOpenGL with jhc ? how can i setup the haskell compiler in Setup.hs ?
16:18:21 <vixey> hummm
16:18:38 <Twey> Ah, no view patterns then eh :(
16:18:58 <BMeph> Cale: Hmm, maybe I just read up on view patterns, while using a pattern guard. Anyway, it looks like VPs are in 6.10, though.
16:19:25 <vixey> should pattern matching be a primitive or should it be defined in terms of smaller primitives ? (eg. eliminators)
16:19:34 <BMeph> Cale,Twey: The entry is different on the GHC wiki, anyway.
16:19:58 * Twey nods.
16:20:09 <Cale> rwbarton: It seems we need someone who actually cares about Haskell in the Ubuntu and Debian teams.
16:20:17 <BMeph> It starts "This page has been revised to reflect what we've implemented."
16:20:36 <Twey> It's not my problem, and I've no idea what version the user has, so I'd best stay clear.
16:21:19 <Dreadshoot> is there any haskell standard document, like in c/c++?
16:21:20 <vixey> this really bugs me I can't figure out the right answer
16:21:20 <BMeph> Cale: I think Debian devs work in their own special bubble. I don't have first-hand experience with them, just a lot of the second-hand bitches from dealing with them. :)
16:22:05 <Cale> Dreadshoot: yes
16:22:15 <Cale> Dreadshoot: The Report, you'll find it linked from haskell.org
16:22:36 <Cale> http://www.haskell.org/haskellwiki/Language_and_library_specification
16:22:39 <lambdabot> Title: Language and library specification - HaskellWiki, http://tinyurl.com/2to3n6
16:22:56 <Cale> Dreadshoot: It is perpetually behind though.
16:23:05 <Cale> Dreadshoot: (that's just the way things are done)
16:23:41 <Cale> Implementation of new features always comes first, and the popular ones get standardised.
16:23:49 <BMeph> Haskell: Where the specs describe what's already been done, not what the language should do "someday". ;)
16:24:04 <Twey> Heheh
16:24:39 <Twey> Interesting, ViewPatterns were proposed before '98, yet they've only just been implemented?
16:25:04 <BMeph> Or, Haskell: Bringing you the future specs today...not next decade? ;)
16:25:30 <vixey> :(
16:25:38 <Twey> Haha
16:25:40 <Dreadshoot> Cale: mm yes i see, they seem to be pretty slow with updating the standard
16:26:26 <rwbarton> Twey: The idea of having view patterns in some form may predate Haskell.
16:26:40 <vixey> views is a cool idea
16:27:04 <SamB_XP> vixey: you mean full-blown views ?
16:27:06 <vixey> the way the are in haskell is really annoying though
16:27:09 <vixey> if I write
16:27:14 <vixey> foo (f -> A) = ...
16:27:15 <vixey> foo (f -> B) = ...
16:27:32 <vixey> I have no idea if f is calculated once or twice when the second equation is the one that matches
16:27:55 <SamB_XP> what's worse
16:27:59 <vixey> syntactically, it seems to say that that f of <parameter> will be calculated twice
16:28:01 <Twey> Standard match order, no?
16:28:02 <SamB_XP> if f is a bit longer ...
16:28:07 <Twey> Calculate from the top down
16:28:13 <vixey> operationally, that would be really stupid
16:28:22 <vixey> so I am clueless
16:28:32 <Twey> Why would it be stupid?
16:28:43 <Twey> Oh
16:28:44 <Twey> I see
16:28:46 <ddarius> rwbarton: Transformational patterns were discussed in the same paper as pattern guards and are essentially view patterns.
16:28:48 <Twey> Memoisation to the rescue?
16:29:14 <SamB_XP> Twey: ITYM cse
16:29:39 <Twey> Oh, pardon me :)
16:29:56 <ddarius> vixey: And if it was f (Polar r 0) = ...; f (Polar r theta) = ... it would be clear?
16:30:15 <adamvo> Dreadshoot: haskell 98 report: http://www.haskell.org/onlinereport/index.html
16:30:15 <lambdabot> Title: The Haskell 98 Language Report
16:30:58 <Dreadshoot> adamvo: yes i've found it
16:31:05 <vixey> ddarius: not really no
16:31:06 <adamvo> I should really check my scroll back buffer
16:31:24 <rwbarton> ddarius: "Views: A way for pattern matching to cohabit with data abstraction"? (1987)
16:31:42 <ddarius> rwbarton: That's views not view patterns or pattern guards.
16:32:04 <SamB_XP> ddarius: what ???
16:32:23 <SamB_XP> about the f polar thing
16:32:34 <ddarius> SamB_XP: If Polar was a view.
16:32:43 <SamB_XP> OH
16:32:44 <Cale> Dreadshoot: for other extensions, the GHC User's Guide is pretty effective
16:32:46 <rwbarton> ddarius: Oh, well, it has the same purpose.
16:32:56 <Cale> Dreadshoot: there are also papers written about most of them
16:32:58 <ddarius> rwbarton: Not quite.
16:33:33 <Dreadshoot> ah yes, i'm still only at the basics of haskell though. havent had time to spend learning it
16:33:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
16:33:36 <lambdabot> Title: Chapter�8.�GHC Language Features, http://tinyurl.com/kf2g3
16:33:39 <SamB_XP> view patterns are a lot less pie-in-the-sky
16:33:56 <ddarius> SamB_XP: Views have been implemented in some MLs for a long time.
16:34:00 <clogged> which is the best IRC-client for linux(free as in beer and freedom)?
16:34:08 <Twey> irssi, clogged
16:34:09 <clogged> i just switched to ubuntu
16:34:12 <Cale> clogged: I like X-Chat.
16:34:18 <Twey> Not really the right channel, though :-P
16:34:32 <skorpan> clogged: ERC
16:34:34 <ddarius> Unless the answer is hircules
16:34:38 <user317> i use naim/nirc
16:34:39 <Cale> hehe
16:34:44 <skorpan> i think rms himself used/uses rcirc though
16:34:49 <SamB_XP> well, okay, it's a lot clearer how far to take view patterns ...
16:35:55 <Dreadshoot> http://learnyouahaskell.com/ heh whats this, looks almost like binky for c/c++ ;)
16:35:56 <lambdabot> Title: Learn You a Haskell for Great Good!
16:36:18 <Twey> Haha, yeah, it's pretty cool
16:36:58 * BMeph thinks laguage guides took a nose-dive in quality, after "why"
16:37:06 <skorpan> i think BONUS wrote learn you a haskell
16:37:08 <BMeph> *language
16:38:44 <BMeph> I like how the value input feature tidies up unfoldr's definition, though. It looks semi-self-referential there. :)
16:41:34 <Dreadshoot> hmm the developement of real world haskell book seems to have progressed also
16:42:05 <ddarius> Dreadshoot: It's completed.
16:47:57 <wy> When did Haskell start to use layout?
16:48:39 <dolio> Layout was part of Miranda, no?
16:48:46 <dolio> Possibly even earlier languages?
16:48:46 <Cale> wy: From the very beginning.
16:49:04 <wy> dolio: Miranda doesn't have that
16:49:10 <Cale> huh?
16:49:13 <dolio> Really?
16:49:15 <Cale> Miranda used layout.
16:49:18 <wy> Cale: So earlier than Python?
16:49:26 <Cale> Yes.
16:49:35 <wy> Cale: Simon's old book used Miranda, there is semicolons etc
16:49:59 <Cale> The original language to use layout was, I believe, Occam. ABC inherited it from there, and was an inspirational factor for Python, from what I understand.
16:50:08 <Peaker> I wonder how Haskell's use of layout is much less of a knee-jerk causer than Python's use of layout :)
16:50:14 <dolio> Wikipedia says ISWIM used it originally.
16:50:23 <Twey> Peaker: Probably because it's optional
16:50:25 <Peaker> Cale: Yeah, I think Python is a direct successor of ABC, both designed by GvR
16:51:30 <dolio> And Occam, Miranda, and Haskell inherited it from there.
16:51:54 <Cale> mm, yeah.
16:52:25 <Cale> I wasn't sure about whether ISWIM had it. I knew that ISWIM is where we got 'where' clauses from.
16:53:26 <wy> Is ISWIM a realistic language?
16:53:31 <idnar> uSWIM
16:53:37 <Cale> I'm fairly sure that it's always been layout-optional though.
16:53:48 <Cale> http://www.cs.kent.ac.uk/people/staff/dat/miranda/manual/12.html
16:53:49 <lambdabot> Title: 12
16:54:02 <Cale> That's the description of the use of layout in Miranda.
16:54:11 <idnar> Twey: people hardly ever use explicit {;} in Haskell code, though
16:54:20 <ddarius> > map succ "ABC"
16:54:21 <lambdabot>   "BCD"
16:54:29 <dolio> SPJ is just crazy like that sometimes.
16:54:57 <Cale> wy: I don't think anyone's ever actually implemented ISWIM, but it's the template for Miranda, Haskell, and other functional programming languages.
16:55:16 <ddarius> It looks almost identical to early pure functional languages.
16:56:05 <unenough> who made learnyouahaskell?
16:56:09 <Cale> It's understandable why a book about implementing functional languages would include the semicolons and braces. Layout is desugared as one of the very first steps in compilation.
16:56:13 <vixey> there is a file ISWIM.agda on my HD :)
16:56:15 <Cale> unenough: BONUS did.
16:56:45 <unenough> BONUS: looks nice :)
16:56:49 <unenough> i may finally learn haskell now
17:03:16 <adamvo> dcoutts: building the current darcs gtk2hs fails on these errors: http://hpaste.org/11460
17:04:59 <dcoutts> adamvo: hmm, not sure what's going there, ask on the gtk2hs-users list
17:06:06 <adamvo> dcoutts: thanks for helping, I'll go ask there
17:09:07 <wy> I found it hard to indent code if I need to restructure it
17:09:44 <vixey> yeah I just make everyting one liners
17:09:52 <vixey> that way there is no fussing around with indentation
17:10:11 * vixey exaggerating but this is roughly true
17:10:27 <wy> haha
17:10:29 <Cale> wy: Well, ideally your editor would do it for you. I don't know if such an editor is widely available though :)
17:10:38 <Peaker> I wish haskell-mode in emacs stepped through the indentation levels in reversed order than it currently does
17:11:30 <wy> Cale: but it's not possible, since the editor can never read your mind
17:11:38 <Cale> It would be good to have an editor where any edit which moved one of the indentation keywords, would force its block to be carried along
17:11:51 <Plareplane> just indent after do/let/of/where but nowhere else
17:11:54 <Cale> that would essentially solve the problem
17:12:00 <Plareplane> it's troublesome to actually align stuff
17:12:10 <Cale> It's not so troublesome to align things.
17:12:11 <Peaker> textual editors :-(((
17:12:19 <vixey> there are some really great things possible with a typed language like haskell and a new editor
17:12:20 <mrd> rectangular commands, align-regexp
17:12:24 <Cale> It's only troublesome to adjust alignment.
17:12:38 <vixey> it's just that you'd have write a lot of code to have it working :/aoe
17:12:39 <rwbarton> Cale: have you seen http://nickgravgaard.com/elastictabstops/ ?
17:12:43 <Cale> rwbarton: yes
17:12:45 <lambdabot> Title: Elastic tabstops - a better way to indent and align code
17:13:03 <Cale> Elastic tabstops are not *exactly* what we want, but they're close.
17:13:05 <rwbarton> I think it wouldn't be hard to make a haskell-aware version
17:13:32 <rwbarton> You'd have to adjust to hitting tab a lot, and be able to handle import and export to files formatted with spaces
17:14:31 <Cale> I'd prefer an editor where I'd never have to hit tab.
17:15:05 <Cale> (except to indent by more than could be expected)
17:15:47 <Peaker> Cale: I think it makes more sense to have newline remain at the same most-nested level as continuing in the same line, so tab should actually go backwards towards outer levels
17:15:52 <Cale> If I start by writing:
17:15:59 <Cale> main = do x <- getLine
17:16:09 <Cale> It should know where to indent the next line :)
17:16:20 <rwbarton> I guess that would just require a lot more haskell-specific knowledge.
17:16:27 <Peaker> Maybe in do blocks newline often corresponds to the >> so you'd want to go all the way back to the "do" level
17:16:38 <Peaker> rwbarton: haskell-mode for example already has a lot of that I thnk
17:17:03 <Cale> Peaker: I hate it when tab does anything other than increasing the level of indentation.
17:17:13 <dolio> vim manages to indent the next line of 'main = do x <- getLine' correctly.
17:17:14 <Cale> Let backspace go outward :)
17:17:24 <rwbarton> Peaker: Right, but it doesn't automatically keep your code aligned when you change the length of 'main'.
17:17:25 <Cale> dolio: With extensions?
17:17:27 <Peaker> Cale: for some reason backspace is usually mapped to delete-one-space, which is not very useful
17:17:57 <dolio> Cale: I can't recall what all I was using at the time. But it got it right when last I used it.
17:18:07 <Cale> dolio: huh, mine doesn't.
17:18:10 <dolio> I've been using Emacs lately.
17:18:24 <Cale> I don't really mind indenting one line of every block.
17:18:31 <dolio> Because using Agda without Emacs is kind of a pain, and I'd rather not switch between two editors.
17:18:44 <Cale> But it would be nice :)
17:19:26 <Cale> Also, if I start out with something like that, and add a parameter to the function, say, so the 'do' gets pushed over, it should push over the subsequent lines of the block by the same amount.
17:19:31 <rwbarton> The emacs haskell indentation mode by kuribas knows where to indent the next line in that example.
17:20:08 <rwbarton> Right, that's something that I've only seen the electric tabstops do.
17:20:14 <wy> But automatic indentation is not possible, because without indentation, the language is ambiguous
17:20:36 <wy> unless we start to use braces
17:20:59 <Cale> and if I press enter with the cursor just before the 'do', it should drop down to the next line, indented by 2-spaces (or whatever my default indent is), and the subsequent lines should move accordingly.
17:21:11 <Peaker> if backspace/tab jumped between indentation levels, emacs haskell-mode would already be much more usable. Pushing whole blocks forwards/backwards when their delimiter is moving would improve it even more
17:22:22 <wy> It's troublesome if we need to cut and paste an inner function to toplevel
17:22:23 <dolio> The kuribas indentation mode uses backspace/tab.
17:23:00 <Cale> Ideally, the layout-keyword could also act as a drag-and-drop element.
17:23:27 <dolio> Cale: I just reinstalled vim, and it jumps right under the 'x' for that example.
17:23:38 <wy> You mean rectangle D&D operation
17:23:38 <Cale> Say, clicking the layout-keyword (of,where,let,do) would select the block for cutting/pasting (with preserved alignment) and dragging it would move it elsewhere.
17:23:52 <Cale> dolio: Perhaps my vim is stupid.
17:24:08 <dolio> I seem to have a special haskell indentation file. I wonder where I got it...
17:24:22 <Cale> I appear to have an old vim...
17:25:02 <wy> Who is using Emacs with haskell here?
17:25:06 * vixey  
17:25:32 <Cale> Also, guards should automatically align, though that's actually a little trickier.
17:25:56 <Cale> (because things are a little more ambiguous as to what it is that you want to do)
17:26:26 <dolio> Cale: It doesn't do very well on backspace, though.
17:26:28 <wy> So layout doesn't really save us typing...
17:26:37 <Cale> wy: It's not meant to.
17:26:43 <Cale> wy: It's meant to be easier to read.
17:27:23 <wy> Cale: but you can change the color of braces to a dim one :p
17:27:25 <Cale> Haskell doesn't take a lot of typing as it is :)
17:27:50 <Cale> (If it does, it's quite possible you're doing it wrong ;)
17:28:19 <Cale> So spending a little time making it look nice is not usually a burden.
17:28:20 <wy> But it's impossible to get it right for the first run
17:28:26 <clogged> how doi quit ghci in the ubuntu terminal?
17:28:27 <Cale> Oh?
17:28:35 <Cale> clogged: ctrl-C?
17:28:44 <Cale> er, ctrl-D
17:28:51 <dolio> Cale: This appears to be the indentation file I have: http://www.vim.org/scripts/script.php?script_id=1968
17:28:52 <lambdabot> Title: indent/haskell.vim - Haskell indent file : vim online
17:28:56 <wy> so lots of changes are needed. for example putting some functions into where clauses, and back, ... adding more lets..
17:28:57 <Cale> clogged: Or :q
17:29:31 <wy> vixey: It seems only we two are using Emacs :~P
17:29:37 <Cale> dolio: thanks
17:29:42 <vixey> wy, well it really sucks..
17:29:46 <vixey> wy, I don't know anything better though
17:30:01 <wy> vixey: why do you think emacs sucks?
17:30:14 <Peaker> I use emacs, but I do very little actual Haskell development :(
17:30:23 <vixey> for haskell it's really bad
17:30:36 <vixey> or should I say, could be much better? :)
17:30:39 <Cale> Oh, another cool thing would be if I could grab a function name and drag it out of a 'let' with my mouse, say, to the top-level, and it would move the whole definition out, and remove the let if it was the last definition there.
17:30:46 <wy> vixey: I think this is because of Haskell, and not because of Emacs
17:31:23 <Cale> (or move things in, and have a 'let' automatically added ;)
17:31:59 <Cale> (or 'where', depending on the location of the cursor)
17:32:08 <vixey> wy, I think it's my fault. I'm too lazy to write a decent emacs mode
17:32:12 <clogged> how is not emacs best for everything?
17:32:13 <adu> i feel much better now
17:32:16 <clogged> what do you use, VIM?
17:32:36 <wy> vixey: It's quite clear to me no good haskell-mode can exist...
17:32:58 <clogged> im new to ubuntu and the #ubuntu channel is unhelpfukl
17:33:12 <vixey> oh
17:33:15 <wy> vixey: because of layout...
17:33:19 <clogged> how do i install a chatclient? i downlaoded and untared bitchx but nothing happens whne i click
17:33:30 <wy> vixey: Let's use S-expressions! yeah!
17:33:54 <bbs> clogged: vim has a great haskell mode
17:33:56 <bbs> i use it often
17:33:57 <rwbarton> Many arguments of the form "It's clear that no X can exist, because of Y" turn out to be completely wrong.
17:34:00 <bbs> for my hw :D
17:34:09 <Cale> clogged: bitchx is a console IRC client.
17:34:14 <wy> vixey: make Liskell the standard :)
17:34:20 <Cale> clogged: If you're looking for something nice with a GUI, I recommend X-Chat.
17:34:22 <vixey> wy, I always found s-exps for typed languages really really awkward though
17:34:35 <Peaker> We shouldn't be editing Haskell as a character string in a text file..
17:34:37 <bbs> clogged: you should use irssi
17:34:45 <wy> vixey: what about OCaml syntax?
17:34:47 <vixey> wy, but you could probably do something with s-exps internally.. and present them like real haskell code, but keep the easy editing features
17:35:01 <vixey> wy, (and this is what I meant about me being too lazy to write a good emacs mode )
17:35:01 <Cale> irssi has the same problem though, of needing to be run from a terminal :)
17:35:19 <Cale> It might be nice if you're someone who likes to use screen a whole lot.
17:35:30 * bbs is addicted to console
17:35:32 <Cale> (But X-Chat has a terminal mode as well)
17:35:37 <adu> bbs: me too
17:35:37 <bbs> this is also true
17:35:55 <rwbarton> It may be sufficient to use semicolons-and-braces internally, but display as layout.
17:36:00 <bbs> clogged: if you don't know *exactly* what you like start with x-chat
17:36:10 <bbs> and then you can try an alternative if you prefer
17:36:19 <rwbarton> Of course supporting editing on a displayed form is always tricky
17:36:35 <bbs> and if you are logged in for long amounts of time -- many people (myself included) use a program called screen to leave it in the background
17:36:46 <Peaker> screen++
17:37:04 <Cale> I just wish that screen integrated better with X programs.
17:37:17 <rwbarton> Hopefully yi will get to the point where haskell programmers can easily experiment with this kind of thing.
17:37:18 <vixey> wy, but really I am waiting for all these hundreds of people who have great ideas about structural editions aware of abstract syntax to get together and write something really good instead :)
17:37:23 <Cale> I should be able to take an X client and move it transparently between X servers.
17:37:24 <Peaker> there's some sort of X proxy but it doesn't work very well
17:37:57 <adu> bbs: I find I can do about 99% of all things in a terminal and a browser
17:38:17 <Cale> Last time I looked at yi's source code, it was a bit hairy. Has it become any more comprehensible?
17:38:19 <wy> vixey: I think we could change the internal syntax to something like XML, then use a graphical editor on that. Like TeXmacs
17:38:31 <Cale> wy: Oh, god, XML? Why?
17:38:38 <vixey> wy, well I'd rather use s-exps than XML, but yes exactly
17:38:52 <wy> Cale: only for internal use. You wouldn't see it on the screen
17:38:55 <Nafai> Cale: I use Emacs' multitty mode, run it in screen and then create new frames
17:38:57 <vixey> wy, it's a shame this is not how TeX-maxima works actually
17:39:02 <bbs> Cale: that would be fscking awesome for x progs
17:39:12 <bbs> adu: *nod*
17:39:12 <adu> bbs: and it dawned on me that these 2 mediums are both ways of piping programs across networks, i.e. terminals standardize the transmission of character-based apps and browsers standardize the transmission of 2D/GUI based apps
17:39:13 <Cale> XML is an abomination. Everything which touches it turns into a horrible mess.
17:39:29 <rwbarton> bbs: there's a program that tries to do this
17:40:09 <rwbarton> bbs: but I forget the name...
17:40:11 <wy> Cale: it seems to work well with TeXmacs...
17:40:23 <bbs> rwbarton: lulz kde tries to
17:40:29 <bbs> with multiple desktops
17:40:32 <bbs> not good enough for me though
17:40:36 <bbs> i really am in term enough
17:40:38 <Cale> wy: Sort of :)
17:40:41 <clogged> xchat says for fedora 7, i have ubuntu 8, it works anyway?
17:40:41 <bbs> as a programmer i don't really need to much other stuff
17:41:04 <Plareplane> clogged, if you are on ubuntu, just type "sudo apttitude install xchat"
17:41:10 <Plareplane> aptitude
17:41:12 <Plareplane> not apttitude
17:41:13 <wy> Cale: any ways... we need braces, brackets, semicolons, S-exps in the editor :P
17:41:14 <Cale> wy: TeXmacs does seem to have massive performance issues for some reason though. (With documents longer than a few pages.)
17:41:46 <wy> Cale: You tried that?
17:41:55 <Cale> (Not to mention that the LaTeX code that it generates isn't exactly beautiful :P)
17:41:59 <wy> Cale: Maybe because of Guile...
17:42:12 <Cale> It seems to have lots of O(n) editing operations.
17:42:31 <wy> Cale: It's meant not to generate LaTeX code. It generates PDF
17:43:03 <vixey> wy, the problem is this basically - there are lots of people with great ideas regarding this sort of stuff but it's bloody impossible to get them to work together
17:43:06 <wy> Cale: any ways... You can always improve on that
17:43:12 <Cale> Right. I noticed some issues with the way it breaks formulas as well, relative to LaTeX.
17:43:40 <Cale> It's great for homework assignments, but I would never write anything serious in it.
17:43:50 <Cale> (at least in its current state)
17:44:28 <Cale> I would love to have a visual editor like TeXmacs whose editing operations corresponded *directly* to LaTeX commands.
17:44:38 <wy> yes. I hope it can get better. I heard they are replacing the gui toolkit
17:45:04 <Plareplane> i wish more editors were like wordperfect where you could split screen between "presentation view" and "code view"
17:45:07 <wy> Cale: but how can a Haskeller like TeX...?
17:45:19 <Cale> wy: I'm a mathie first :)
17:45:25 <wy> TeX is nothing comparable to Haskell :p
17:45:31 <Cale> wy: In fact, I used plain TeX for years.
17:45:37 <Plareplane> and whatever you do in one view will appear correspondingly in the other vie
17:45:56 <clogged> but how do i install something on linux?
17:45:56 <wy> Cale: I read the TeXbook twice and immediately forgot all of it...
17:46:12 <Cale> clogged: You're using Ubuntu, right?
17:46:20 <clogged> cant i just sudo apt-get some irc client and get going?
17:46:25 <Cale> clogged: Applictions -> Add/Remove...
17:46:26 <clogged> yes ubuntu
17:46:27 <Plareplane> yes you can
17:46:45 <wy> Plareplane: It seems to me that TeXmacs can do it now.
17:46:48 <Cale> Or  sudo apt-get install xchat
17:46:53 <Plareplane> you can do "sudo apt-get install xchat" or "sudo aptitude install xchat" or applications -> add remove like cale said
17:47:12 <cads> do you guys know about work done to take concepts from analysis and create computer programs that work with those same theorems and objects that mathematicians do when they do analysis?
17:47:19 <cads> I know that's extremely vague
17:47:25 <Cale> Or, System -> Administration -> Synaptic Package Manager, for a more advanced GUI tool for packages.
17:47:31 <Cale> They're all interfaces to the same thing.
17:47:49 <Cale> cads: hmm.
17:48:06 <rhz> cads: try looking up "theorem provers" maybe
17:48:14 <Cale> cads: There are theorem provers which have had libraries written to work with concepts from analysis.
17:48:24 <Cale> cads: Nothing all that usable for mathematicians though.
17:48:56 <cads> I've gathered that, but I'm not knowlegeable enough about theorem provers or the math
17:49:04 <adu> Cale: my favorite joke: http://www.charlespetzold.com/etc/CSAML.html
17:49:05 <lambdabot> Title: C# Application Markup Language (CSAML): A Preview
17:49:06 <Cale> cads: What are you trying to do?
17:49:07 <cads> why exactly are they not useful to mathematicians?
17:49:10 <vixey> cads, you can check formalized proofs about analysis in Coq there's a whole theory for it
17:49:29 <Cale> cads: Because formalisation is a pain in the ass.
17:49:32 <cads> cale, I'd like to learn analysis by implementing what I learn in code
17:49:32 <vixey> formalizing proofs in excruciating detail like that isn't really _maths_
17:49:44 <wy> vixey: I remember you also use scheme?
17:49:48 <vixey> wy, yes
17:49:58 <wy> vixey: Do you use syntax-case?
17:50:02 <Cale> Mathematicians don't work at the same level as their formalisations.
17:50:05 <vixey> wy, yeah, it's the best bit!
17:50:21 <Cale> They insist that everything is formalisable, but only rarely carry out the whole process explicitly.
17:50:42 <cads> I mostly work at an extremely abstract intuitive level
17:50:45 <wy> vixey: I'm trying to understand its hygiene algorithm. Do you have ideas on that?
17:50:46 <Cale> Because it consists of many details which are "mechanical" for a human, but just hard enough that a computer can't do them.
17:50:52 <cads> and extract theorems from hunches
17:50:54 <Plareplane> wy: does it? from the screenshots it looks more like lyx-style where you can do latex style input, but you only see the formatted output and not the code
17:50:57 <Cale> cads: right.
17:51:07 <adu> Cale: like equivalent properties?
17:51:28 <Cale> adu: yeah, I suppose a lot of it has to do with applying equivalences as appropriate.
17:51:33 <vixey> wy, yeek I am not sure, it's not something I know a lot about it - hygiene seems very complex to me
17:51:56 <cads> so our formalisms haven't come to be able to express that intuitionism except through excruciating detail
17:52:04 <Cale> Mathematicians communicate mathematics by communicating the important details, and become extremely bored when forced to communicate things which ought to be obvious.
17:52:07 <wy> Plareplane: you can split frames. At least I tried to edit a style file in one window and having the document changing in another window
17:52:27 <Plareplane> oh nice
17:52:28 <Cale> The problem is that the set of things which are obvious to a mathematician is much larger than the set of things which are obvious to a computer.
17:53:09 <Cale> cads: And yeah, our formalisms tend to look very different from our intuitions.
17:53:34 <wy> Plareplane: And an even nicer thing is that the style file can be partially evaluated. You can see part of the final format intuitively
17:53:35 <Peaker> Feynman claimed in his book that mathematicians wave away lots of things as obvious (trivial, I think he said), even when they're wrong ;)
17:53:56 <cads> handwaving is pretty great :D
17:54:18 <Cale> Peaker: The fact is, though, that except for things which are very new, the chances of something being wrong decrease quite a lot over time.
17:54:19 <cads> but I think someone's got to have the obsessive level of detail
17:54:32 <adu> Cale: I know exactly what you're talking about, but can you give an example?
17:54:48 <vixey> cads: I think it's just the difference between formal and formalized
17:54:49 <rwbarton> Also, each area of math has its own standard tricks which humans are good at adapting to new problems
17:54:59 <Cale> Peaker: Most mathematicians internally at least in part turn the things which are communicated into something somewhat more formal.
17:55:12 <vixey> cads: but look at the Coq standard library and other stuff, there is lots of math in there
17:55:30 <vixey> cads: people have proof fundamental theorems of algebra and calculus I think
17:55:37 <Cale> vixey: My algebraic topology prof called it the difference between "rigourous" and "rigourisable"
17:55:58 <Peaker> Cale: if they're wrong, though, their proof does not crash.. if its not trivial, errors may be missed
17:56:13 <Cale> Peaker: But not forever.
17:56:15 <cads> anyways, cale, back to what I wantd to do with it, it's a little of learning higher maths, and more to work towards proof carrying code and programs that are proven to be correct and safe
17:56:39 <Cale> Peaker: By the time that more than a handful of people have looked over something, the possibility that there's an error is very low.
17:56:42 <cads> I'll take coq for a spin
17:56:51 <cads> ... which doesn't sound homo at all
17:56:56 <Cale> cads: ah, okay
17:57:02 <adu> cads: lolol
17:57:17 <Cale> cads: In that case, coq, agda, and other dependently typed languages are things to look at.
17:57:55 * SamB_XP can has homomorphism ?
17:58:04 <Peaker> Cale: I hope so. I'm not a mathematician though. I wonder how many people read Andrew Wiles 200-page proof of Fermet's last theorem
17:58:21 <adu> i am
17:58:37 <cads> Peaker, I forgot the details, but it was a machine assisted proof?
17:58:47 <Cale> cads: iirc, it wasn't.
17:59:06 <Cale> cads: You're thinking of the original proof of the four colour theorem perhaps.
17:59:11 <cads> yes
17:59:22 <rwbarton> Is there a non-computer assisted proof of that now?
17:59:41 <rwbarton> I think I heard there was a second, much simplified one, but still computer assisted
18:00:01 <rwbarton> (I don't know why I'm asking here and not looking on wikipedia :)
18:00:03 <Peaker> that proof just enumerated the colorings of all the interesting cases, iirc
18:01:11 <Cale> rwbarton: I think they've simplified it somewhat. It's still not really satisfying.
18:01:20 <cads> wiki doesn't seem to elaborate too much
18:01:54 <cads> but anyways, do you guys think there's any way that fermat had an actual correct proof?
18:03:53 <adu> I think the Riemann hypothesis is "obvious"
18:04:13 <vixey> cads: I think it's compeletly insane to try and predict anything about something that clever
18:04:25 <vixey> someone*
18:04:43 * wy is crashing his google chrome
18:05:07 <cads> wy, try the firefox 3.1 beta
18:05:12 <cads> it crashes too
18:05:52 <wy> cads: firefox 3 seems to have something wrong than 2
18:05:56 <Cale> cads: It's astoundingly unlikely that Fermat had a correct proof.
18:06:21 <Cale> cads: It's much more likely that he had the same incorrect "proof" which quite a few others managed to come up with at that time.
18:06:27 <wy> cads: It uses much more mem now and some of my add-ons can't be used any more
18:06:38 <Cale> (which basically relied on the assumption that every ring was a unique factorisation domain)
18:06:54 <Cale> (iirc)
18:07:06 <vixey> is it the quaternions that aren't a UFD?
18:07:13 <cads> cale, I see
18:07:42 <Cale> All nonzero quaternions have inverses.
18:08:19 <zeno> delete x l doesnt make l strict right?
18:08:25 <clogged> is sudo apt-get some database of linux-packages or how does ubuntu know where to fetch it=
18:08:26 <adu> Cale: so are not all rings unique factorization domains?
18:08:35 <Cale> adu: Right.
18:08:37 <vixey> what is a ring that isn't?
18:08:48 <vixey> I'm sure I read about this recently but I can't remember it..
18:08:52 <Cale> Z[sqrt(-5)]
18:08:56 <Cale> iirc.
18:09:07 <rwbarton> Right, 2*3 = (1+sqrt(-5))(1-sqrt(-5))
18:09:13 <Cale> Or, for example, most matrix rings :P
18:09:32 <Cale> (but they're not even integral domains)
18:09:35 <rwbarton> I don't think people tend to consider non-commutative rings in this context
18:09:43 <Cale> Well, yeah.
18:10:04 <Cale> I think the important thing is that there are subrings of C which are not UFDs.
18:10:17 <opqdonut> wow
18:10:24 <opqdonut> i read that as "substrings in C"
18:10:32 <Cale> heh
18:10:37 <rwbarton> A more "geometric" example is Z[x^2, x^3] (i.e. Z[y, z]/(y^3-z^2))
18:10:50 <rwbarton> Well, replace Z by a field if you like
18:11:20 <vixey> what is that?
18:12:08 <Cale> vixey: Polynomials in x^2 and x^3 with integer coefficients.
18:12:12 <rwbarton> Actually, I'm not really confident about this example
18:12:14 <Cale> hmm
18:12:19 <rwbarton> So, polynomials without a linear term
18:12:50 <rhz> The ring of holomorphic functions in a single variable is not a UFD according to wikipedia
18:14:09 <FunctorSalad> Cale: you are confirming my theory that Z[sqrt(-5)] is the *only* example ;) ;)
18:14:15 <Cale> FunctorSalad: what?
18:14:31 <Cale> Z[sqrt(-k)] for larger k are also nonexamples.
18:14:39 <Cale> er, examples of non-UFDs
18:15:01 <vixey> oh
18:15:06 <FunctorSalad> Cale: just kidding (since that ring is always the example given)
18:15:14 <Cale> FunctorSalad: ah, right.
18:15:18 <vixey> there's one like Z[x^2 + 1] I think?
18:15:20 <Cale> It's a good example though :)
18:15:23 <user317> hehe, http://en.wikipedia.org/wiki/Haskell_class_attack_transport
18:15:24 <lambdabot> Title: Haskell class attack transport - Wikipedia, the free encyclopedia
18:15:27 <vixey> which is equivalent to complex numbers ?
18:15:49 <vixey> ro maybe it's Z[1 - x^2]
18:16:03 <Cale> vixey: You're thinking of Z[x]/<x^2+1>
18:16:03 <opqdonut> no not with Z
18:16:12 <vixey> oh I see
18:16:17 <Cale> The Gaussian integers.
18:16:20 <opqdonut> yes
18:16:30 <Cale> Which is the same as Z[sqrt(-1)]
18:16:30 <vixey> this notation is quite difficult..
18:17:02 * vixey blaming the tools..
18:17:07 <sbahra> Cale, what does "UFD" stand for?
18:17:16 <Cale> Z[x]/<x^2+1> basically means take Z, add a new element x to it, and then make a wish that x^2 + 1 = 0
18:17:26 <Cale> sbahra: Unique factorisation domain
18:17:44 <Cale> http://en.wikipedia.org/wiki/Unique_factorisation_domain
18:17:45 <lambdabot> Title: Unique factorization domain - Wikipedia, the free encyclopedia
18:17:49 <sbahra> nod, thanks
18:18:24 <vixey> does / have a meaning for any two sets ?
18:18:41 <FunctorSalad> rwbarton: you mention 'geometric'... is there a geometric way to see that it's not an UFD?
18:18:53 <FunctorSalad> vixey: not for sets, but for various algebraic structures
18:18:56 <vixey> I read it like, divide into equvalence classes
18:19:00 <FunctorSalad> namely, 'quotient'
18:19:48 <FunctorSalad> vixey: yes, in addition to that structures like rings have the property that a congruence relation can be specified by the subset congruent to zero
18:20:05 <FunctorSalad> (congruence relation = eqv. relation that respects the operations)
18:20:08 <Cale> If S is a set, and ~ is an equivalence relation on S, then we write S/~ for the set of equivalence classes. That would be the generalisation to sets.
18:20:14 <cads> I love you guys, by the way.. you guys have to be one of the most intelligent groups of SOBs I've met on irc
18:20:27 <vixey> ohh
18:20:41 <Cale> But <x^2 + 1> here is an ideal, which is a subset of the ring, and the equivalence relation we're talking about is congruence modulo that ideal.
18:20:48 <vixey> ok I was mixing up sets and structures :)
18:20:57 <Cale> That is u ~ v if and only if u - v is in the ideal.
18:21:41 <sbahra> old: 0m0.120s, new: 0m0.052s, old: 0m5.382s, new: 0m0.443s
18:21:45 <sbahra> memoization to the rescue. :D
18:22:57 <rwbarton> FunctorSalad: I don't know offhand, but if there is one it must have to do with the non-smooth point at the origin
18:23:29 <vixey> I only started reading algebra a couple weeks ago .. so I am really into it atm :p
18:23:53 <FunctorSalad> rwbarton: hmm are you sure Z can be replaced by a field? I thought the K[x1,...xn] for K were all UFDs
18:23:56 <vixey> so excuse me for derailing everything ..
18:24:22 <FunctorSalad> :)
18:24:37 <FunctorSalad> *for K a field
18:24:44 <rwbarton> FunctorSalad: Those rings are--but by k[x^2, x^3] I meant the subring of k[x] generated by x^2, x^3
18:25:15 <FunctorSalad> ah, assumed it was inherited to subrings
18:26:01 <SubStack> @pl (\xs -> inits xs ++ tails xs) [1,2,3,4]
18:26:02 <lambdabot> liftM2 (++) inits tails [1, 2, 3, 4]
18:26:04 <rwbarton> x^2 and x^3 are irreducible in this ring, and x^6 = x^2 * x^2 * x^2 = x^3 * x^3
18:26:18 <SubStack> except that doesn't work >:|
18:26:24 <FunctorSalad> oh. that's easier than I thought :)
18:27:43 <vixey> > liftM2 (++) inits tails [1, 2, 3, 4]
18:27:44 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4],[2,3,4],[3,4],[4],[]]
18:27:52 <SubStack> o_O
18:27:55 <pumpkin> wow :P
18:28:12 <pumpkin> but no 2, 3?
18:28:44 <FunctorSalad> that's neither a initial nor a tail :)
18:28:52 <pumpkin> oh I thought it was all sublists
18:29:16 <SubStack> naw
18:29:39 <pumpkin> > liftM2 (++) inits tails "SubStack"
18:29:40 <lambdabot>   ["","S","Su","Sub","SubS","SubSt","SubSta","SubStac","SubStack","SubStack",...
18:29:48 <pumpkin> :o
18:30:09 * SubStack likes all these point-free monadic crazy tools
18:32:59 <Peaker> a lifted (in applicative or monad) function applied to functions applies to their results.  I don't know why I only realized it in this form recently, but since I have, its so much easier to understand its use :)
18:36:21 <cads> > let powerset = filterM (const [True, False]) in powerset [1..5]
18:36:22 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
18:36:40 <SubStack> saw that one on reddit, pretty awesome
18:37:17 <cads> I really need to learn the definitions to these higher order thingamajigs
18:37:30 <EvilTerran> hehe
18:37:32 <EvilTerran> from the logs:
18:37:34 <EvilTerran> 0159<rwbarton> I think I heard there was a second, much simplified one, but still computer assisted
18:37:34 <EvilTerran> 0100<rwbarton> (I don't know why I'm asking here and not looking on wikipedia :)
18:37:41 <EvilTerran> (hours of sleep)++
18:37:47 <dolio> > let powerset = filterM (const [True, False]) in powerset [5,5,5,5]
18:37:48 <lambdabot>   [[5,5,5,5],[5,5,5],[5,5,5],[5,5],[5,5,5],[5,5],[5,5],[5],[5,5,5],[5,5],[5,5...
18:37:56 <SubStack> except:
18:38:15 <roconnor> > (const 3 undefined)
18:38:16 <lambdabot>   3
18:38:16 <Cale> I prefer the term "combinations"
18:38:27 <SubStack> http://hpaste.org/11461
18:38:29 <rwbarton> EvilTerran: nice :)  We have to wait another week or so
18:38:34 <cads> cale, right, that's not really dealing with a set
18:38:48 <Cale> SubStack: import Control.Monad.Instances
18:38:52 <SubStack> oic
18:38:58 <FunctorSalad> I like higher-order functions as much as everyone but isn't sublists really a job for recursion ;)
18:39:07 <SubStack> Cale++ # there it goes
18:39:11 <Cale> FunctorSalad: Nothing is *really* a job for recursion
18:39:16 <EvilTerran> cads, it can be considered to be manipulating the set of indices in the list
18:39:20 <dolio> @karma sleep)
18:39:20 <lambdabot> sleep) has a karma of 1
18:39:33 <EvilTerran> preflex: karma hours of sleep
18:39:33 <preflex>  karma for hours of sleep: 1
18:39:40 <Cale> Higher order functions FTW!
18:39:46 <EvilTerran> preflex++ he can DWIM
18:46:22 <cads> FTW = for the women?
18:46:39 <EvilTerran> the win, shurely?
18:48:23 <pumpkin> yup
18:51:21 <cads> I like "Higher order functions, for the women!" better :)
18:52:20 <cads> is there an offline version of hoogle to be had?
18:52:21 <EvilTerran> @vixen Higher order functions, for the women!
18:52:22 <lambdabot> i love fun
18:52:29 <EvilTerran> o.ó
18:53:02 <electronx> hi whats a good text editor for haskell?
18:53:12 <EvilTerran> i use vim with the haskell syntax file
18:53:17 <EvilTerran> or scite, on windows
18:53:25 <EvilTerran> there's a haskell-mode for emacs
18:53:27 <SubStack> yi (which I've yet to try)
18:53:47 <EvilTerran> and there's yi, which is written in haskell, and, as is the way with such things, is kinda experimental
18:53:49 <electronx> which is best ya think?
18:53:59 <wy> Is GHCi really an interpreter for Haskell?
18:54:04 <EvilTerran> electronx, it really doesn't matter that much
18:54:08 * araujo should continue working on his text editor
18:54:17 <EvilTerran> you don't have to do much typing in haskell compared to other languages
18:54:21 <SubStack> indeed
18:54:29 <cads> electronx, emacs has got a flymake mode for haskell which tests your syntax dynamically
18:54:33 <EvilTerran> the language can usually support its own weight, it doesn't need propped up through many tedious bits with an IDE
18:54:55 <electronx> okay
18:55:03 <wy> I'm still wondering why Template Haskell requires that you put the generator in another module
18:55:09 * SubStack writes out haskell on paper sometimes
18:55:29 <rwbarton> cads: you can cabal install hoogle, and then use it from the command line
18:55:39 <EvilTerran> wy, it's to prevent weird paradoxes where a generator invokes itself in its own definition or something
18:55:56 <EvilTerran> wy, seeing as that would be impossible to compile without a *great* deal of cleverness
18:56:20 <wy> EvilTerran: But can I still write recursive generators in the module?
18:56:42 <EvilTerran> it's not a matter of recursion
18:56:47 <FunctorSalad> EvilTerran: I'm wondering why there isn't a simple non-cyclicity check though (but admittedly I haven't thought it through)
18:56:51 <EvilTerran> it's a matter of recursing through different compiler steps
18:57:03 <EvilTerran> foo = ... $(foo ...) ...
18:57:12 <wy> power n x = if n==0 then [| $(g (-2)) |] else [| $x * $(power (n-1) x) |]
18:57:18 <cads> is libghc6-cabal-dev broken in ubuntu/debian?
18:57:43 <dcoutts> cads: not afaik, but it's very old
18:57:58 <EvilTerran> wy, that's a very odd way of writing that, seeing as it'll be expanded (but not necessarily evaluated) at compile-time
18:58:21 <wy> Why can this power function work?
18:58:25 <EvilTerran> , [|1|]
18:58:28 <lunabot>  LitE (IntegerL 1)
18:58:37 <EvilTerran> wy, ah, i see what you're getting at
18:59:01 <EvilTerran> the recursive call is in the same TH pass, as the $(...) it's inside is cancelled out by the [|...|] it's inside
18:59:36 <EvilTerran> the $(...) moves it a step earlier, but the [|...|] moves it a step later
19:00:03 <wy> EvilTerran: You meant the problem is about foo = $(foo) ?
19:00:14 <EvilTerran> yeah, that sort of thing
19:00:17 <wy> It seems that this can be detected
19:00:21 <EvilTerran> , let foo = $foo in foo
19:00:23 <lunabot>  luna: GHC stage restriction: `foo'
19:00:46 <EvilTerran> wy, consider that this could happen without the $foo being lexically in the definition of foo
19:01:04 <EvilTerran> and it could get very complicated with higher-order functions in TH splices, say
19:01:35 <EvilTerran> ... to work out exactly if there's a circularity; i suspect it's undecidable
19:01:37 <wy> EvilTerran: Is the problem that it will cause infinite loops when compiling?
19:02:11 <EvilTerran> the problem is that its behaviour cannot be well characterised
19:02:35 <EvilTerran> so it's better to forbid it than to have horrifically complicated semantics to work around this weird corner case
19:02:44 <FunctorSalad> EvilTerran: do you mean that the definition may not contain foo literally, but somehow generate it?
19:03:21 <EvilTerran> i mean you can't splice in a function that is declared in the TH pass you are currently in
19:03:27 <EvilTerran> or in a later pass, obviously
19:03:54 <EvilTerran> and i believe modules are considered separate stages
19:03:57 <FunctorSalad> yeah, I mean the reason why circularity is hard or undecidable
19:04:30 <EvilTerran> it's because the types and behaviour would be at best unintuitive and at worst undecidable to work out
19:06:03 <FunctorSalad> to be more concrete, I meant why we can't have convenience definitions like 'a = ...', 'b = ... $(a) ...' with no other relations between a and b
19:06:11 <FunctorSalad> (in the same module)
19:06:28 <FunctorSalad> OTOH you could just define a inside a 'let' in the def of b I think
19:06:31 <scook0> it's annoying when restrictions like that prevent you from doing perfectly reasonable-seeming stuff
19:07:16 <wy> I still can't see why it's hard to do so
19:07:26 <scook0> because they're designed to prevent situations that you would almost never be in willingly
19:07:51 <wy> maybe a topological sort will do?
19:08:52 <FunctorSalad> (b is a TH definition too in my example, otherwise it'd be valid code of course)
19:10:33 <FunctorSalad> sorry if I'm horribly confused here
19:10:50 <EvilTerran> , let a = [|1|]; b = $a in b
19:10:52 <lunabot>  luna: GHC stage restriction: `a'
19:11:21 <EvilTerran> the problem is that, even if it's not immediately apparent that there's one of these problems, i think it's undecidable to prove that there isn't
19:11:49 <EvilTerran> although i guess you could just bail at "run-time" for that stage if such a thing happened
19:12:08 <FunctorSalad> because b could be referred to via a name string in a?
19:12:32 <EvilTerran> because of various complexities created by even higher-order functions
19:13:48 <wy> How about this... $(...) will decrease "level" by one, and [|...|] increase level by 1. You can only have $(foo) if the inner foo is at level >=0.
19:14:03 * FunctorSalad should learn more about TH before making such comments ;)
19:14:05 <wy> doh. I got it reversed
19:14:42 <wy> hmm... I take the doh back. that's want I meant.
19:15:52 <wy> So in that case: foo = $(foo). the inner foo is at level -1. So that's not allowed
19:16:31 <rwbarton> , let a = [|1|]; b = [| $a |] in b
19:16:34 <lunabot>  LitE (IntegerL 1)
19:17:05 <wy> rwbarton: what does the comma mean here?
19:17:38 <rwbarton> asks lunabot to evaluate it; lunabot has template haskell enabled
19:17:43 <cads> trying to install cabal-install, doing ./boostrapSetup gets me : At least the following dependencies are missing: HTTP >=3000 && <3002, network >=1 && <3.    Is one of the dependencies love ( <3 )?
19:18:03 <wy> lambdabot: who is lunabot?
19:18:24 <dcoutts> cads: so installing http and network failed
19:18:49 <dcoutts> cads: >= 1 && < 3 means version later than 1 but less than 3
19:18:58 <cads> dcoutts, hehe, it was an attempt at internet humor :D
19:19:17 <dcoutts> cads: ok, though apparently it does genuinely confuse some people :-)
19:19:21 <cads> I'm determining where it went wrong
19:19:39 <dcoutts> cads: it's a stupid bash script so it doesn't stop when it fails
19:19:46 <dcoutts> cads: patches welcome
19:20:02 <wy> , let power n x = if n==0 then 1 else [| $x * $(power (n-1) x) |] in power 5 2
19:20:05 <lunabot>  luna: No instance for (GHC.Num.Num Language.Haskell.TH.Lib.ExpQ)
19:20:59 <wy> , let power n x = if n==0 then 1 else [| $x * $(power (n-1) x) |] in let power2 = $( [| \a -> $( power 3 [| a |] ) |] ) in power2 3
19:21:01 <lunabot>  luna: GHC stage restriction: `power'
19:21:14 <Cale> , let power n x = if n==0 then [| 1 |] else [| $x * $(power (n-1) x) |] in power 5 2
19:21:16 <lunabot>  luna: No instance for (GHC.Num.Num Language.Haskell.TH.Lib.ExpQ)
19:21:39 <wy> , let power n x = if n==0 then [|1|] else [| $x * $(power (n-1) x) |] in let power2 = $( [| \a -> $( power 3 [| a |] ) |] ) in power2 3
19:21:41 <lunabot>  luna: GHC stage restriction: `power'
19:21:54 <EvilTerran> wy, what you suggested is how it works, i think
19:21:55 <rwbarton> Yeah, I didn't believe that code
19:22:11 <electronx> lambdabot is not very good haskell code
19:22:23 <electronx> just looked at it
19:22:47 <Cale> electronx: It's basically a pile of patches by a lot of authors.
19:23:01 <electronx> hehe ya looks like it
19:23:06 <electronx> i was going to extend it
19:23:24 <electronx> now maybe i'll write my own from scratch
19:23:41 <Cale> There are other bots as well.
19:23:49 <electronx> any nice ones
19:23:56 <thetrav> f(x) = x^3 + 8x^2 + 0.5x + 4;
19:23:56 <thetrav> f(y) = f(x) + f(x)
19:23:56 <thetrav> f(z) = f(y) - 2f(x) + 100
19:23:56 <thetrav> f(z) = 100
19:23:56 <thetrav> Would haskell work all that out without evaluating all the exponential operators on x?
19:23:57 <thetrav> Sorry if the syntax is a bit cruddy, I don't really know haskell, just trying to get my head around functional langauges
19:24:36 <Cale> thetrav: I'm not certain what you're asking...
19:24:49 <Cale> thetrav: that looks like four definitions of the function f
19:24:52 <thetrav> well, if it doesn't have to evaluate the first function, f(x)
19:24:56 <thetrav> until it's really needed
19:25:04 <wy> EvilTerran: but this power thing should work...
19:25:10 <thetrav> can it be clever enough to recognise that f(y) is 2f(x)
19:25:21 <thetrav> and that 2f(x) - 2f(x) = 0
19:25:26 <electronx> pobably
19:25:27 <Cale> thetrav: I think you're mistaking what patterns are.
19:25:32 <electronx> ghc compiler is good
19:25:47 <electronx> but f(y) whould be called a diff function
19:25:55 <electronx> like f2(y)
19:25:56 <Cale> thetrav: the first definition says that for any value x, f x = x^3 + 8*x^2 + 0.5*x + 4
19:26:02 <rwbarton> , let y = 1 in let power n x = if n == 0 then [|1|] else [| $x * $(power (n-1) x) |] in power 5 [|y|]
19:26:05 <lunabot>  InfixE (Just (LitE (IntegerL 1))) (VarE *) (Just (InfixE (Just (LitE (Int...
19:26:12 <Cale> thetrav: (and you need to write the multiplication operators)
19:26:31 <rwbarton> (The definition of y isn't necessary there, I was just too lazy to construct a VarE from scratch)
19:26:33 <Cale> thetrav: Not that for some specific value x, f x is that polynomial.
19:27:02 <thetrav> yeah, I'm not so much asking how to express it in haskell, I'm more curious as to the capability of functional languages in general to optimise such a scenario
19:27:15 <thetrav> as I'm fairly certain an imperative language could not
19:27:52 <Cale> The second line has more problems. It looks like another definition of f
19:28:01 <wy> rwbarton: How is the generated code shown from TH?
19:28:04 <Cale> But x is not in scope.
19:28:13 <thetrav> Sorry, f(x) f(y) and f(z) are all intended to be different fuctions
19:28:20 <Cale> oh, that's... bad
19:28:29 <Cale> f is the function
19:28:43 <Cale> f(x) is the value of f evaluated at the point x
19:28:43 <rwbarton> wy: huh?
19:28:56 <Cale> (even in mathematics)
19:28:58 <thetrav> nah, f(x) is a symbol I've chosen to represent an anonymous function that operates on the input x
19:28:59 <rwbarton> wy: it's just a big AST
19:29:13 <Cale> So, you should name the functions differently :)
19:29:18 <thetrav> I probably made some maths booboos then
19:29:19 <rwbarton> wy: it hasn't been spliced in anywhere yet
19:29:25 <wy> rwbarton: How do you show ASTs without lunabot?
19:29:40 <wy> rwbarton: It's not an instance of Show
19:30:07 <Cale> thetrav: In general, it will perform all the arithmetic operations, because various kinds of numbers are less than ideal when it comes to satisfying mathematical laws.
19:30:28 <wy> , let power n x = if n==0 then [|1|] else [| $x * $(power (n-1) x) |] in let power2 = [| \a -> $( power 3 [| a |] ) |] in power2 3
19:30:30 <lunabot>  luna: Couldn't match expected type `t -> a'
19:30:37 <rwbarton> wy: Exp is
19:30:46 <rwbarton> wy: I usually write something like...
19:30:56 <Cale> thetrav: For, say, Rationals, the laws are satisfied, and you could add rewrite rules to GHC to get it to remove the computations. It might be tricky in general to get those rules to fire though.
19:30:56 <wy> rwbarton: How do you get Exp? I got only ExpQ
19:31:17 <wy> , [|1|]
19:31:19 <Cale> thetrav: But at least you can do it as a library ;)
19:31:20 <lunabot>  LitE (IntegerL 1)
19:31:25 <wy> , [|x|]
19:31:27 <lunabot>  luna: Not in scope: `x'
19:31:45 <rwbarton> wy: ExpQ = Q Exp, and Q is a monad
19:31:55 <rwbarton> wy: in ghci you can enter $( lift . show =<< [|3|] )
19:32:10 <Cale> thetrav: For floating point numbers, not many of the usual axioms for numbers are satisfied, and so simplifying expressions can change the meaning of a program.
19:45:58 <thetrav> Cale, thanks for the explanation.  I thought I had stumbled upon something that makes functional languages more compiler friendly.  I saw a presentation yesterday on them but it didn't really go into any detail, so now I'm trying to work out that detail
19:46:51 <Cale> thetrav: It will, however, do inlining, and can do lots of transformations to code which languages with unrestricted side-effects can't do.
19:48:03 <thetrav> Cale, heh, yeah that's the sort of explanation that was given at the presentation :P I sort of see the outline of what it's describing but I'd really love to figure out some simple examples so I can understand it enough to explain to other people
19:49:08 <electronx> Cale: do you know if there is a maximum number of connections that can be open on a operating system?
19:49:16 <electronx> opened*
19:49:36 <thetrav> hey what if instead of a polynomial at the bottom it was some sort of list sort operation?
19:49:37 <electronx> Cale: can i have say open 2000 connections in haskell
19:49:44 <thetrav> then would it be optimised out of existance?
19:49:49 <electronx> or maybe 10000
19:49:52 <Cale> electronx: There are OS-dependent restrictions.
19:50:12 <Cale> thetrav: Well, in Haskell, if you never end up using a value, it's never computed.
19:50:24 <Cale> thetrav: For instance, let's say you have a function...
19:50:47 <Cale> f 0 y = 0
19:50:58 <Cale> f x y = product [1..y]
19:51:02 <Cale> (for instance)
19:51:13 <thetrav> ok yeah, I see where you're going
19:51:15 <Cale> and we call  f 0 (product [1..10000])
19:51:20 <thetrav> lists's are "defined" rather than built
19:51:44 <Cale> Then the product of 1 up to 10000 is never computed
19:51:56 <Cale> because the first definition matches, and the result is 0
19:52:11 <Cale> (the value of y is irrelevant, and so not computed)
19:52:31 <Cale> But that's just lazy evaluation.
19:52:32 <thetrav> ohh
19:53:01 <Cale> Of course, lazy evaluation + unrestricted side-effects gives you something which is all but impossible to understand.
19:53:22 <Cale> So it's something which we can get away with because of how restricted side-effects are.
19:53:40 <Cale> Also, it's really easy to work with very large things, like infinite lists or trees.
19:54:03 <Cale> If you're writing, say, an AI for a game, you might define the whole game tree.
19:54:14 <Cale> and then prune that afterward
19:54:33 <Cale> Parts of the tree which you never pattern match against will never be computed.
19:55:01 <Cale> It's much more natural than having to mix in all your various heuristics for pruning the tree into the code which is generating it.
19:55:22 <Cale> and results in code which is much more reusable
19:58:18 <Cale> thetrav: You might have a look at the paper "Why Functional Programming Matters"
19:59:30 <Cale> thetrav: It's just a little unfortunate that to fully appreciate what that paper is saying, you kind of have to understand it already, so it unintentionally ends up preaching to the choir to some extent.
20:00:24 <Cale> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.pdf
20:00:26 <lambdabot> Title: Why Functional Programming Matters
20:00:56 <Cale> It uses a language which is an ancestor to Haskell, so the syntax is a little different.
20:01:07 <Cale> But it should be understandable anyway.
20:01:08 <thetrav> Cale: I've found that's a common dilemma among functional programming papers/presentations/etc
20:01:29 <dobblego> indeed it is very common
20:01:31 <thetrav> I've been very slowly increasing my knowledge over the last 4 years and I still don't get a lot of it
20:01:59 <thetrav> thanks for the link though
20:02:02 <Cale> thetrav: The best thing to do is just to dive in and properly learn, say, Haskell :)
20:02:09 <Cale> @where lyah
20:02:09 <lambdabot> www.learnyouahaskell.com
20:02:16 <thetrav> heheh yeah I know
20:02:19 <Cale> This tutorial is new, and should be fun :)
20:02:30 <Cale> There's also...
20:02:33 <Cale> @where yaht
20:02:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:02:37 <Cale> @where wikibook
20:02:38 <lambdabot> http://en.wikibooks.org/wiki/Haskell
20:02:45 <Cale> @where realworldhaskell
20:02:46 <lambdabot> http://www.realworldhaskell.org/
20:02:50 <electronx> don't forget rwh
20:02:54 <Cale> I didn't ;)
20:02:58 <electronx> hehe
20:03:57 <thetrav> yeah I went through yaht a while back
20:04:31 <rwbarton> Are there any _The Little Schemer_-style Haskell tutorials?
20:04:47 <cads> the trav, there's a paper, "a tutorial on the expressiveness of fold" or something, by hudak or so, which to me was kind of an eye opening and yet accesible example of what thinking in a functional way lets you do
20:06:25 <BMeph> We need to get new students to go into imperative lang channels and ask FP-biased questions, like "How come you eep stopping in the middle of your list maps and restarting them?" :)
20:06:35 <BMeph> *keep
20:07:06 <rwbarton> "wtf why cant i use a simple state monad" :) :)
20:07:18 <electronx> whats the best way to read in a large data type?
20:07:33 <BMeph> Or "Why do you make a variable, set it to what ever index of a list you're interested in, then later change it?"
20:07:41 <electronx> i have to implement read type but it has about 18 attributes
20:07:44 <dobblego> try it and you'll be banned; I've tried it, the imperative guys hate thinking
20:08:01 <Cale> BMeph: This code isn't making the tree that I expect: t = Branch(0,t,t)
20:08:38 <Cale> hehe
20:08:50 <Cale> electronx: deriving Read ?
20:09:46 <Cale> BMeph: Wait, i is equal to 0, how can it also be equal to 1?
20:09:48 <BMeph> Cale: But it'd be fun while it lasted. I especially like the "How come when you've just about calculater a part of your answer, you overwrite it with something else?" :)
20:09:54 <electronx> Cale two attributes have to be parsed manually
20:10:02 <cads> how should I answer when an imperative friend of mine says that it is his understanding that to do 'anything useful' in haskell you have to imitate imperative programing anyways, but with the added brain-cost of the extra abstraction of monads?
20:10:12 <Cale> electronx: Are you sure you can't write Read instances for those as well?
20:10:23 <dobblego> cads, try this, "mate you are full of shit and have no idea what you are talking about"
20:10:49 <Cale> cads: You don't have to know anything about monads to do I/O.
20:11:19 <Cale> It *happens* that IO is a monad, but this is inessential.
20:11:21 <dobblego> you might also ask what extra brain power he expends when using monads himself (e.g. each time he types the semicolon)
20:11:49 <rwbarton> There are two general approaches--(1) replace language X with Haskell and vice versa (2) replace language X with assembly language and Haskell with X
20:12:07 <electronx> Cale: http://hpaste.org/11462
20:12:21 <Cale> cads: Actually, a good response might be: "To do anything useful in object oriented languages, you have to imitate imperative programming anyways, but with the added brain cost of the extra abstraction of objects."
20:12:24 <BMeph> "Okay, I see the print, and the list. So how does this 'for' function translate in terms of bind and return?" :)
20:12:47 <Cale> electronx: Oh, you want a specific parser.
20:12:48 <dobblego> Cale, except that it legitimises his initial remark
20:13:14 <rwbarton> That's only if the original language isn't objected oriented, otherwise this is a great example of (2) :)
20:13:15 <electronx> Cale: yeah
20:13:28 <electronx> Cale: any nice may of doing it?
20:13:44 <Cale> dobblego: Let's take it a little further.  To program in procedural programming, you have to imitate assembly programming anyway, but with the added brain-cost of the extra abstraction of procedures.
20:13:46 <cads> Cale, dobblego, he was citing something that he had read that mentioned that high performance haskell code has to degenerate to imitation imperative code
20:13:48 <BMeph> "What do you mean there aren't tuples built in? I just used them with that function two lines ago!"
20:14:01 <Cale> cads: Yeah, that's not really true.
20:14:04 <dobblego> cads, what he had read is trivial to debunk as nonsense
20:14:17 <Cale> cads: You can write Haskell code which is low-level.
20:14:26 <Cale> cads: (in order to get additional performance)
20:14:36 <Cale> But in order to get reasonable performance, you don't have to.
20:14:45 <dobblego> cads, computer programming is a fashion industry, there are lots of mths
20:14:47 <dobblego> *myths
20:14:54 <Cale> GHC's code generator is really good these days.
20:15:08 <Cale> and it's improving rapidly
20:15:27 <Cale> It used to be the case that (even compiled) Haskell was quite slow.
20:15:32 <cads> what is really funny is that he is a ruby programmer
20:15:35 <Cale> But that's not really true anymore.
20:15:37 <Cale> heh
20:15:51 <dobblego> cads, there is a Ruby guy that pops into my office every now and then and makes a fool of himself
20:16:04 <electronx> lol
20:16:05 <cads> it's okay, he is brother and so is forgiven
20:16:06 <Cale> Yeah, naively written Haskell code will basically always slaughter Ruby.
20:16:27 <electronx> Ruby slowest language ever
20:16:38 <electronx> at least its changing with 1.9
20:16:39 <Cale> (simply because it's compiled to native code and optimised)
20:16:49 <Cale> electronx: I would write a parsec parser.
20:16:51 <dobblego> I'm not sure he is aware of how big a fool he looks with some of his comments
20:17:01 <electronx> Cale: okay thanks
20:17:31 <Cale> electronx: Haskell and large product types like that don't mix too well though.
20:17:48 <cads> hehe, it stinks, I use a little ruby too, and I find myself desperately wanting list comprehensions and guilt free recursion.. and pattern matching... and goddamn functions that don't have unknown side effects
20:17:48 <Cale> electronx: But it can be hard to avoid it.
20:18:55 <cads> anyways, I think I will implement an exotic public key encryption algorithm and beat him over the head with it
20:19:28 <Cale> hehe
20:20:13 <Cale> cads: I always find it funny when people consider abstractions to be extra cognitive workload.
20:20:14 <electronx> Cale: i've never used parsec before can it be avoided?
20:20:32 <Cale> electronx: Well, you could use another parsing library, but it's probably the easiest way to go.
20:20:33 <electronx> maybe time to learn?'
20:20:49 <Cale> electronx: Perhaps, yeah :)
20:20:51 <electronx> okay i'll have to learn it
20:20:54 <electronx> thanks
20:21:19 <Cale> electronx: I didn't really understand the value of the monad abstraction until I learned parsec :)
20:21:21 <dobblego> electronx, I once tried to avoid Parsec and reinvented it in doing so
20:21:52 <Cale> It's a beautiful library.
20:22:02 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
20:22:05 <Cale> is a good tutorial
20:22:13 <lambdabot> Title: Parsec, a fast combinator parser
20:22:20 <Cale> (there are some slight differences to modern parsec though)
20:22:29 <cads> cale, for those used to one abstraction another can be ugly and scary, and cause irrational reactions :)
20:23:11 <Cale> Of course, admitting that it's an abstraction in the first place seems to indicate that you're aware that it abstracts something.
20:23:29 <Cale> Which means that you're already admitting that it reduces cognitive overload ;)
20:23:56 <electronx> looking at examples it kind looks magical
20:24:02 <electronx> kinda*
20:24:14 <electronx> not typical haskell
20:24:35 <Cale> There's no real magic though :)
20:24:43 <Cale> It just represents parsers as data.
20:24:50 <dobblego> electronx, Graham Hutton's book has a good introduction to parsers
20:24:53 <Cale> and defines operations on them
20:25:08 <Cale> (which is very functional)
20:25:30 <Cale> In particular, it defines the monad operations, so you get all the neat stuff from Control.Monad for free. :)
20:26:04 <Cale> sequence [p,q,r] will concatenate the parsers p,q,r into a parser which parses all three and returns a list of their results, for example.
20:26:32 <electronx> nice
20:26:33 <rwbarton> electronx: RWH has a chapter on Parsec too
20:26:45 <electronx> rwbarton: thats what i'm reading :)
20:28:14 <clogged> code as data, is that true for all languages that lets you pass functions to other functions? or dos it mean having access to the abstract syntax tree?
20:28:27 <clogged> or is it data as code?
20:29:53 <pjdelport> clogged: probably depends largely on your definitions
20:30:20 <pjdelport> clogged: some people use the term to mean homoiconicity
20:31:59 <pjdelport> clogged: first-class functions are also a possible interpretation
20:33:19 <pjdelport> yet another sense is data as control flow, and control flow as data
20:34:34 <pjdelport> which is evident in Haskell in the form of algebraic data types and pattern-match-driven evaluation
20:35:03 <pjdelport> for example, how lists are loops and vice versa
20:42:12 <ddarius> http://www.cs.cmu.edu/~noam/abstracts/Gallium-04mar08 Sounds interesting
20:50:59 <ddarius> rwbarton: Your quoted comment on HWN has given me ideas.
20:53:26 <rwbarton> ddarius: Which one?
20:53:48 <electronx> anything nice as parsec but faster?
20:56:36 <ddarius> rwbarton: The relational calculus one.
20:57:10 <ddarius> There are a variety of libraries with Parsec-like or even Parsec-compatible interfaces.  Which, if any of those, you want to use depends on what you want to do.
20:57:28 <rwbarton> ddarius: Cool.  I'd be interested in hearing about them
20:59:14 <ddarius> "ideas" may have been to strong a word, more the thought of applying things like behavioural differentiation to things like relational tables.
20:59:44 <rwbarton> differentiation in the sense of derivative of a functor?
21:00:10 <ddarius> Not quite.
21:00:17 <ddarius> @google J. J. M. M. Rutten
21:00:23 <lambdabot> http://homepages.cwi.nl/~janr/
21:00:23 <lambdabot> Title: Jan Rutten's homepage at CWI
21:03:56 <oneal> Admin !!! You banned me ?
21:04:26 <oneal> why me all Banned
21:04:30 <oneal> :Z
21:04:36 <oneal> SUKA
21:04:40 <bd_> given that you're in here, you're obviously not banned
21:05:07 <ddarius> which seems like an omission to me
21:05:17 <oneal> no , no . on other channel
21:05:26 <bd_> why are you asking us then?
21:05:32 <bd_> we have nothing to do with other channels
21:05:36 <oneal> This Good Chanel :D
21:07:21 <oneal> what here rules ?
21:07:37 <oneal> to me not Banned
21:08:22 * ibid reminds all finns on this channel to vote in the municipal elections today (if you haven't cast your advance ballot)
21:10:53 <bd_> oneal: #haskell has nothing to do with whatever channel you were banned in. You'll need to find an op of that unspecified other channel.
21:11:27 <oneal> Ok
21:11:29 <oneal> SPS
21:29:37 <Riastradh> Earlier tonight some strange entity possessed me to look into making GHC run on NetBSD/macppc.  Why is the GHC build system so insanely complex, and incapable of cross-compiling itself as of 6.8?  Does nobody care about doing that sort of thing?
21:33:03 <Korollary> #ghc is a better place to ask that question.
21:33:18 <Riastradh> I see: I was not aware of #ghc.
21:38:06 <Cale> Or perhaps one of the mailing lists...
21:38:53 <Cale> http://www.haskell.org/mailman/listinfo/glasgow-haskell-users perhaps
21:38:54 <lambdabot> Title: Glasgow-haskell-users Info Page
21:39:09 <rwbarton> I heard a rumor that the situation might improve in 6.10 or 6.12...
21:39:28 <electronx> Riastradh: i had the same thought when i tried to get it working on solaris 9
21:39:44 <electronx> i gave up in the long term
21:40:46 <Nafai> Riastradh: Still doing Scheme hacking?
21:46:13 <electronx> #defocus
21:48:51 <httpdss1> im looking on how to convert from integer to string, where string is a hexadecimal representation of the integer and has de following format "0000"
21:49:11 <Riastradh> f "0000" = 0     -- Like that function?
21:49:41 <httpdss1> if integer is 16 then answer has to be "0010" ... if integer is 15 then answer has to be "000a"
21:50:07 <cads> is leksah worth using?
21:50:09 <Riastradh> Oops, other way around, I suppose:  f 0 = "0000"; f 16 = "0010"; f 15 = "000a"
21:50:11 <httpdss1> the opposite
21:50:29 <roconnor> > showHex 15 ""
21:50:32 <lambdabot>   /tmp/218577197086305917:68:40: Not in scope: `showHex'
21:50:42 <roconnor> > Numeric.showHex 15 ""
21:50:43 <lambdabot>   /tmp/1358037108783949833:68:40: Not in scope: `Numeric.showHex'
21:50:49 <roconnor> > Numeric.showsHex 15 ""
21:50:50 <lambdabot>   Not in scope: `Numeric.showsHex'
21:50:51 <httpdss1> Riastradh, that last one, but not patternmatching :)
21:50:54 <Korollary> > head "a"
21:50:56 <lambdabot>   'a'
21:50:57 <roconnor> @hoogle Hex
21:50:57 <cads> I seem to remember seeing cool screenshots with nice syntax highlighting and cool greek charachter lambda, and arrows instead of ->
21:50:57 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
21:50:58 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
21:50:58 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
21:51:02 <roconnor> @hoogle showHex
21:51:02 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
21:51:25 <BMeph> Numeric> showHex 40
21:51:34 <roconnor> @tell lambdabot import Numeric
21:51:34 <lambdabot> Nice try ;)
21:51:49 <roconnor> damn
21:53:28 <httpdss1> wow thx! i got it using showHex 15 ""
21:53:36 <rwbarton> > printf "%04x" 15
21:53:37 <lambdabot>   Add a type signature
21:53:40 <rwbarton> > printf "%04x" 15 :: String
21:53:41 <lambdabot>   "000f"
21:53:46 <BMeph> > Numeric.showHex 33 ""
21:53:48 <lambdabot>   /tmp/5485699769509851971:68:40: Not in scope: `Numeric.showHex'
21:56:24 <encryptio> :t printf
21:56:26 <lambdabot> forall r. (PrintfType r) => String -> r
21:58:50 <httpdss1> rwbarton, really neat solution ;) thx
22:01:23 <user_> ahaha
22:01:32 <user_> yes it worked finally
22:01:41 <user_> can somon see me_
22:01:45 <Korollary> Yes
22:01:54 <user_> i love ubuntu already
22:02:06 <user_> now i wanna set up coq with ubuntu, can i apt/get it_
22:02:30 <Korollary> Yes
22:02:55 <sbahra> http://hpaste.org/11463 - I take that's a good use scenario of StateT :-P
22:03:14 <sbahra> s/:-P/?/
22:06:21 <rwbarton> What is L?
22:06:36 <sbahra> Data.List
22:07:17 <sbahra> and n :: [B.ByteString]
22:07:42 <rwbarton> splitAt is in the Prelude too :)
22:07:52 <rwbarton> unless you've hidden it, I suppose.
22:08:20 <sbahra> :)
22:08:24 <rwbarton> do you actually need to keep around the second halves of all these pairs?
22:08:37 <rwbarton> you can't write [name, path, prefix, ...] = n?
22:08:41 <sbahra> rwbarton, they're the actual tokens.
22:08:42 <sbahra> rwbarton, well
22:09:02 <sbahra> rwbarton, = Port (Name name) (Foo foo) ...
22:09:05 <user_> if i want to try coq, is sudo apt-get all i need to do
22:09:10 <sbahra> rwbarton, where ...
22:09:47 <rwbarton> ... [name, path, prefix, ...] = n?  (I'm lost--why wouldn't that work?)
22:10:29 <rwbarton> or  map (:[]) n  to match the current behavior better
22:10:50 <sbahra> rwbarton, http://kerneled.org/dump/Porte/Ports.hs
22:11:37 <rwbarton> oh.... this is inside a record constructor
22:11:38 <sbahra> rwbarton, to better illustrate why I can't. :)
22:11:47 <rwbarton> no...
22:12:36 <rwbarton> I still don't get it
22:12:40 <sbahra> I need to rewrite this whole PoS
22:12:42 <sbahra> rwbarton, haha
22:12:47 <rwbarton> > let x = a where [a, b] = [3, 4] in x
22:12:48 <lambdabot>   3
22:13:35 <sbahra> rwbarton, well, splitAt is O(n)
22:13:59 <sbahra> rwbarton, so I assume by using second field I avoid prior n
22:14:07 <rwbarton> why can't you get rid of all the 'first's and replace all the lines starting with "name = ..." with "[name, path, prefix, ...] = n"
22:14:31 <rwbarton> or (name : path : prefix : ... : _) = n if you need to handle extra lines at the end
22:15:08 <rwbarton> (or need the laziness somehow)
22:15:21 <sbahra> nod
22:15:22 <sbahra> stupid me
22:15:31 <rwbarton> er s/n/p/g
22:17:14 <sbahra> rwbarton, thanks
22:17:32 <sbahra> I wasn't thinking about this correctly :-/
22:22:00 <mmorrow> how does one reply to a message on a mailman list (e.g. haskell-cafe) so that the reply gets inserted into the correct place in the msg tree (in particular if you're replying to a msg addressed only to the list)?
22:22:34 <mmorrow> i must be missing something obvious
22:22:50 <roconnor> I think you need to get the References: header right
22:23:01 <BMeph> mmorrow: Reading messages by thread, perhaps? :)
22:23:02 <mmorrow> ah, excellent. thx
22:23:06 <roconnor> or maybe In-Reply-To:
22:23:27 <mmorrow> BMeph: err, how do you mean?
22:24:27 <mmorrow> roconnor: and speak of the devil. i was just reading the annoucement of colour and the haddocks, and have a suggestion for adding to class Composite f
22:24:43 <roconnor> shoot
22:24:51 <BMeph> mmorrow: Well, I read the list with Gmane, and just look at the messages grouped by thread.
22:25:27 <mmorrow> this paper is (was?) /the/ standard reference for compositing colo(u)rs (i'm not sure the official link, but here's one) http://code.haskell.org/~morrow/papers/p253-porter.pdf
22:25:29 <lambdabot> Title: cache:http://code.haskell.org/~morrow/papers/p253-porter.pdf - Google Search
22:27:02 <roconnor> mmorrow: ok
22:27:03 <mmorrow> BMeph: ohh, i gotcha. i'm way not at that level of sophistication. i'm just reading the list from the archives, then trying to reply to particular msgs by email by hand. :) :|
22:27:37 <mmorrow> roconnor: i've wanted to implement that little compositing algebra there in haskell for a while now :)
22:28:49 <roconnor> hmm
22:29:22 <rwbarton> mmorrow: if you download the .txt file maybe your email client can open it and send a proper response?
22:29:57 <mmorrow> rwbarton: hmm, that sounds like a nice way to go. i'll try that.
22:31:15 <mmorrow> rwbarton: been working on your {un,old}type or anything related at all?
22:31:43 <rwbarton> mmorrow: Not recently
22:31:56 <rwbarton> mmorrow: I noted the recent "rewriting" module on hackage
22:32:06 <mmorrow> heh, me too. just saw it..
22:32:14 <rwbarton> mmorrow: but I doubt it handles recursion (there are no haddock links, so I didn't investigate much)
22:32:18 <mmorrow> sadly it can't ..
22:32:19 <mmorrow> yeah
22:32:39 <mmorrow> no recursion
22:32:42 <mmorrow> (apparently)
22:33:13 <mmorrow> "This library cannot be used with mutually recursive datatypes or with nested datatypes."
22:33:51 <mmorrow> HERA has a pretty crazy rewriting system going on.. i haven't quite figured out how to use it though
22:34:07 <rwbarton> Well, the datatype is just Type which is a regular recursive datatype
22:34:37 <mmorrow> hmm
22:34:41 * mmorrow gets the code
22:34:47 <rwbarton> you'd have to provide replacement rules dynamically based on the results of reify, I don't know whether it can handle that
22:35:19 <rwbarton> but they'd all look like AppT (AppT (ConT Foo) (VarT x)) (VarT y) --> (something involving x and y)
22:35:45 <rwbarton> what I meant was, does it detect when your rewrite rules cause a loop?
22:37:21 <mmorrow> i've thought about writing a little tool that'll scan .hs src files and extract and somehow store all the info that reify provides (i bet hoogle does 90% of this) so that it can be used without GHC support, but haven't really thought about it extensively
22:38:07 <mmorrow> (so then you'd run this tool over all the base libs and whatever else to get the info)
22:38:10 <rwbarton> isn't that sort of what haddock does?
22:38:23 <rwbarton> does haddock use ghc somehow though?
22:39:18 <mmorrow> i believe haddock gets the ModIface (or something) from GHC somehow, but i'm not sure exactly where that info is coming from (.hs? .hi? ..)
22:40:16 <mmorrow> but yeah, it seems like between haddock and hoogle probably 90% of the code/technique is done, but to slightly different ends.
22:41:06 <mmorrow> i recently read the paper on haddock, and it's really good
22:41:51 <mmorrow> http://www.haskell.org/~simonmar/bib/bib.html
22:41:52 <lambdabot> Title: Simon Marlow's Publiciations
22:42:27 <mmorrow> there're a bunch of interesting looking papers there that i haven't yet looked at
22:42:55 <mmorrow> http://www.haskell.org/~simonmar/papers/haddock.pdf
22:42:56 <lambdabot> Title: cache:http://www.haskell.org/~simonmar/papers/haddock.pdf - Google Search
22:44:12 <mmorrow> i found the part about how it links the docs especially interesting
22:45:39 <mmorrow> oh, and HERA's repo is at (in case anyone os interested) http://code.haskell.org/HERA/
22:45:39 <lambdabot> Title: Index of /HERA
22:47:13 <mmorrow> here're two screenshots from HERA (running on my laptop):
22:47:15 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_0.png
22:47:19 <mmorrow> http://code.haskell.org/~morrow/code/images/hera_1.png
22:47:52 <mmorrow> and info http://haskell.org/haskellwiki/Hera
22:47:54 <lambdabot> Title: Haskell Equational Reasoning Assistant - HaskellWiki
22:48:03 <mmorrow> cool stuff
22:53:45 <DrSyzygy> Wooooots!
22:53:53 <DrSyzygy> I have a working ghc 6.8.3 on my work laptop!!
22:54:18 <mmorrow> @yow
22:54:19 <lambdabot> Now I'm being INVOLUNTARILY shuffled closer to the CLAM DIP with the
22:54:19 <lambdabot> BROKEN PLASTIC FORKS in it!!
22:54:43 <mmorrow> at least they're not SPORKS!!
22:59:55 <roconnor> mmorrow: in and out are just matte operaties. ie of type AlphaColour -> Alpha -> AlphaColour.  They can be implemented using fade
23:00:14 <roconnor> mmorrow: atop is more intresting
23:00:26 <roconnor> xor is dumb, but unique. :)
23:00:46 <mmorrow> heh
23:01:03 <mmorrow> also, note that that paper coined the term "alpha channel" :)
23:01:35 <mmorrow> one thing i find interesting about those also is that they're noncommutative
23:01:43 <mmorrow> (well, some)
23:02:00 <roconnor> mmorrow: I've turned AlpahColour into a Monoid in my development version
23:02:15 <mmorrow> nice
23:02:16 <roconnor> transparent, over
23:04:38 <roconnor> mmorrow: it's nice to see that I manged to get the name "over" correct. :)
23:04:46 <roconnor> I guess it is a natural name
23:06:10 <mmorrow> heh
23:08:20 <dcoutts> @yarr!
23:08:20 <kaizoku> YARRRR
23:08:20 <lambdabot> Keelhaul the swabs!
23:09:07 <LynxAba> hello, is there a function to compare the type of a function? something like this: "whichNum a | a==Int = 1 | a==Fractional = 2"  ?
23:09:39 <LynxAba> i mean, s there a way to know the type of a function?
23:10:16 <LynxAba> by the way i'm not talking about ":type"
23:10:57 <mmorrow> ghc has to know the type of every function at compile time, but that can be something like  :: (Num a) => a -> String
23:12:10 <mmorrow> you could maybe do something like what you want with Data.Typeable and/or Data.Dynamic, but that may be introducing more overhead/pita than you're interested in dealing with
23:12:11 <roconnor> mmorrow: oh maybe I should rename fade to disolve
23:12:29 <pumpkin> you can do whichNum (Int a) = 1 I think
23:13:07 <LynxAba> yes but i need a function that given a Num, return only if is an integer or a fractional, no more
23:13:12 <mmorrow> roconnor: dissolve is definitely a cooler word ;)
23:13:23 <rwbarton> LynxAba: You can't do that in general.
23:13:29 <roconnor> it is
23:13:35 <roconnor> I'm sold
23:13:38 <mmorrow> heh
23:13:43 <roconnor> and I get to use darcs rename again
23:13:47 <cads> I am looking for sourcecode to an implementation of the mceliece cryptosystem.. so far I've found an implementation in java called flexiprovider, but that doesn't have the source. aside from that I've found tons of papers on the cryptosystem, but they seem not to mention the implementation details or make their code available... where would you guys suggest that I continue my search?
23:14:21 <LynxAba> that's bad :( ... anyway, thanks everybody for your help :)
23:14:24 <rwbarton> LynxAba: why do you want to do this anyways?  There are usually better approaches
23:14:41 <roconnor> er darcs replace
23:14:51 <dons> ?users
23:14:51 <lambdabot> Maximum users seen in #haskell: 547, currently: 469 (85.7%), active: 15 (3.2%)
23:15:37 <pumpkin> cads: http://en.wikipedia.org/wiki/McEliece_cryptosystem doesn't help?
23:15:38 <lambdabot> Title: McEliece cryptosystem - Wikipedia, the free encyclopedia
23:16:13 <mmorrow> cads: (i'm sure you've already seen this, but) it looks like there's a description + pseudocode for it in "Handbook of Applied Cryptography", which i was linked to by http://en.wikipedia.org/wiki/McEliece_cryptosystem
23:16:14 <lambdabot> Title: McEliece cryptosystem - Wikipedia, the free encyclopedia
23:17:02 <LynxAba> rwbarton: look, i want to develop like an overcharged function, the function simply drops the x firsts elements from a list, so if the input number is an integer just do the drop directly, but if the number is fractional, first truncate, then drop
23:17:03 <mmorrow> i guess just implement it yourself?
23:17:11 <mmorrow> (@cads)
23:17:43 <cads> step three in the pseudocode is "Choose a k × n generator matrix G for a binary (n, k)-linear code which can correct t errors, and for which an efficient decoding algorithm is known."   : )
23:17:43 <Cale> LynxAba: 'truncate, then drop'?
23:17:43 <rwbarton> LynxAba: It's not like in general you can truncate a (Num a => a) value
23:17:54 <cads> mmorrow, I think I shall do that
23:18:03 <Cale> Oh, truncate the number
23:18:04 <mmorrow> cads: nice!
23:18:20 <rwbarton> how about    dropFrac n x | n <= 0 = x; dropFrac n (x:xs) = dropFrac (n-1) xs
23:18:24 <cads> there is a paper on breaking the system which gives considerably more detail on how steps like the above are achieved
23:18:55 <rwbarton> dropFrac n [] = []
23:18:57 <LynxAba> exactly, that's why i first need to know if is an integer, if is an integer i can't truncate, even i don't need it
23:19:59 <mmorrow> cads: if you're going for a pure haskell implem, maybe look at the pure-md5 package on hackage (and the crypto pkg as well, but i think that's in for an overhaul) for some efficiency techniques or somesuchstuff
23:21:59 <rwbarton> LynxAba: it doesn't seem so bad to just write drop . floor where you want to call it with a RealFrac argument;
23:22:18 <rwbarton> LynxAba: or try the dropFrac I wrote above
23:22:43 <LynxAba> >:t floor
23:22:49 <rwbarton> :t floor
23:22:49 <mmorrow> :t floor
23:22:50 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:22:50 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:22:53 <sclv> ?ty floor
23:22:54 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
23:23:02 <sclv> ?quote fuge
23:23:02 <lambdabot> No quotes match. Wrong!  You cheating scum!
23:23:05 <sclv> ?quote fugue
23:23:06 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:23:21 <mmorrow> sclv: reading "Monadic Floating Point" now :)
23:23:33 <LynxAba> ok, i will use floor, would work :):)  thanks
23:24:15 <cads> mmorrow, I think I am out of my league... but if I find a good library for linear codes and finite fields (which I think haskell should have an abundance), I may be able to jive
23:24:20 <LynxAba> actually doesn't work
23:24:40 <sclv> it doesn't work on things of type Integer, because Integers are not RealFracs
23:24:43 <LynxAba> i'm just going to implement that function, but that was my last option
23:25:03 <LynxAba> sclv: yup, i see that now, thanks
23:25:08 <sclv> mmorrow: it wasn't much in the way of a message -- just a little announcement to garner some feedback.
23:25:13 <mmorrow> cads: hmm. at one point i searched for some pkg to do finite field stuff with to no avail :(
23:25:22 <cads> mmorrow:  come to think of it I haven't searched hackage for an implementation
23:25:26 <sclv> LynxAba: I don't think there's a way to do quite what you want. rwbarton's suggestion is the best.
23:25:30 <mmorrow> but there may be something out there...
23:25:45 <LynxAba> right, i will do that
23:29:33 <mmorrow> sclv: i came across this paper during the whole "top-level <-" discussion, which i thought was interesting in general (which ?ieeeMutex reminded me of) http://code.haskell.org/~morrow/papers/Globals.ps
23:29:49 <mmorrow> (i don't remember where i got it from though)
23:31:04 <sclv> you're a fount of interesting paper links tonight :-)
23:31:13 <sclv> it must be a plot to ruin my weekend.
23:31:21 <mmorrow> sclv: hehe, EXACTLY!!
23:31:39 <sclv> re finite fields, http://www.polyomino.f2s.com/david/haskell/commalg.html ?
23:31:40 <lambdabot> Title: Haskell for Commutative Algebra
23:31:46 <mmorrow> ohh, awesome
23:33:01 <Cale> I should do more with the module I wrote for monoid rings
23:33:28 <mmorrow> Cale: do eet!
23:33:36 <Cale> It's the nicest way to get a lot of useful rings quickly.
23:33:57 <Cale> Multivariate polynomials being one of them :)
23:34:28 <rwbarton> monoid rings + type-indexed Z/nZ = lots of fun
23:34:29 <mmorrow> maybe i can incorporate some modified fft in pure-fft for fast polynomial division/etc too
23:34:58 <rwbarton> + type-indexed vectors!
23:35:15 <mmorrow> zOMG
23:42:35 <sclv> that hughes paper is quite nice.
23:43:18 <mmorrow> it really is
23:44:08 <sclv> it motivates why the unsafePerformIO method is a bad idea fairly well.
23:45:49 <mmorrow> and it's great how he actually benchmarks the different strategies and shows actual numbers
23:47:01 <sclv> it makes sense that implicit parameters would be cheaper actually. although who knows what they'd look like these days.
23:47:24 <mmorrow> that'd be interesting to find out..
23:48:02 <mmorrow> i think this paper's from 2001 (?)
23:48:14 <sclv> he said he benchmarked with ghc 5
23:48:21 <mmorrow> hehe
23:49:10 <sclv> you can just stick an implicit parameter in some context, i suppose, whereas iorefs require an indirection.
23:49:40 <sclv> and because they're io actions, are impossible to optimize.
23:50:11 <sclv> the monadic version could be much faster these days, i suspect, however.
23:54:50 <electronx> how do i say any text in parsec?
23:55:15 <electronx> or any word
23:55:32 <electronx> i just need something like anything seperated by spaces
23:55:43 <Cale> many (noneOf " ")
23:55:59 <Cale> anyChar is any character, iirc.
23:56:43 <electronx> ah thanks Cale
23:58:44 <pumpkin> oh wow, the grammar is written in haskell?
23:58:47 <pumpkin> I have to check this out
23:59:06 <Cale> pumpkin: yes, parsec is awesome. It gives you parsers as first class values.
23:59:33 <pumpkin> sounds neat, I've heard people talk about it a lot, but didn't realize you could write the grammar in haskell
