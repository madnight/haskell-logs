00:00:05 <mmorrow> let daysInMonth y m = if isLeapYear y && m==2 then 29 else monthDays!!((m-1)%12) in daysInMonth 2008 2
00:00:07 <mmorrow> > let daysInMonth y m = if isLeapYear y && m==2 then 29 else monthDays!!((m-1)%12) in daysInMonth 2008 2
00:00:08 <lambdabot>   Couldn't match expected type `Int' against inferred type `Ratio a'
00:00:19 <mmorrow> > let daysInMonth y m = if isLeapYear y && m==2 then 29 else monthDays!!((m-1)`mod`12) in daysInMonth 2008 2
00:00:20 <lambdabot>   29
00:00:24 <mmorrow> @let daysInMonth y m = if isLeapYear y && m==2 then 29 else monthDays!!((m-1)`mod`12) in daysInMonth 2008 2
00:00:25 <lambdabot>   Parse error
00:00:31 <mmorrow> @let daysInMonth y m = if isLeapYear y && m==2 then 29 else monthDays!!((m-1)`mod`12)
00:00:32 <lambdabot>  Defined.
00:00:33 <mmorrow> epic
00:00:45 <Pseudonym> > daysInMonth 1752 9
00:00:47 <lambdabot>   30
00:00:51 <Pseudonym> Wrong!
00:01:05 <mmorrow> um
00:01:07 <olsner> > daysInMonth 2007 2
00:01:08 <lambdabot>   28
00:01:18 <mmorrow> why is that wrong?
00:01:28 <olsner> oh, monthDays... nevermind
00:01:28 <mmorrow> did i screw up the number of days in that month?
00:01:39 <mmorrow> > monthDays
00:01:40 <lambdabot>   [31,28,31,30,31,30,31,31,30,31,30,31]
00:01:47 <olsner> different calendar back then
00:01:50 <mmorrow> ah
00:01:54 <olsner> (in 1752, that is)
00:02:02 <mmorrow> good ole 1752
00:02:07 <Pseudonym> Try "cal 9 1752" on your favourite Unix system.
00:02:12 <Pseudonym> And weep.
00:02:16 <mmorrow> haha
00:02:20 <gio123> does somebody has access to download: http://portal.acm.org/citation.cfm?id=256195&dl=
00:02:45 <olsner> Pseudonym: wow!
00:02:47 <mmorrow> Pseudonym: um, what am i weeping about?
00:02:53 <dolio> 1 2 14 15 16
00:02:58 <mmorrow> whoa
00:03:01 <mmorrow> just noticed that
00:03:11 <Pseudonym> Yeah.
00:03:20 <Pseudonym> That was when the Julian calendar cut over to the Gregorian calendar.
00:03:26 <Pseudonym> And they had to remove 11 days to do it.
00:03:32 <medfly> o.O
00:03:40 <medfly> LOL.
00:03:52 <Pseudonym> > daysInMonth 1700 2
00:03:53 <lambdabot>   28
00:04:00 <Pseudonym> That's also wrong.
00:04:17 <mmorrow> ah. shit. now i'll have to hack that into my javascript to handle all those checks written in 1752.
00:04:21 <Pseudonym> For the same reason.
00:04:27 <mmorrow> (or earlier)
00:04:32 <mmorrow> :)
00:04:58 <Cale> albino: No problem!
00:05:35 <medfly> just define it to work with the julian calender or something. you know when they stopped using it, no?
00:05:57 <medfly> oh , its just one year?
00:06:22 <Pseudonym> Pre-1752, years which are divisible by 100 are leap years, too.
00:06:44 <mmorrow> function isLeapYear(x){return(x%4==0&&(x%100!=0||x%400==0))}
00:06:45 <Pseudonym> That's why 11 days were removed from 1752.
00:06:49 <gio123> Cale: hi, do u have only 1 minute to pm?
00:07:07 <mmorrow> does that function get the seal of approval?
00:07:16 <Pseudonym> No, it's wrong for 1600.
00:07:23 <Pseudonym> Sorry, 1700.
00:07:27 <Pseudonym> Which was a leap year.
00:07:46 <olsner> funny that cal chose to do that on 1752... various countries used julian dates well into the 1920's
00:07:49 <Pseudonym> It's correct for any year after 1752.
00:08:01 <mmorrow> Pseudonym: ok nice. i'm golden then.
00:08:02 <olsner> and other countries switched in the 1500's
00:08:07 <Pseudonym> Yeah, well.  The US inherited the British calendar.
00:08:11 <Pseudonym> I think that's why.
00:08:19 <Pseudonym> Really, cal should be sensitive to the locale.
00:08:48 <medfly> well, its not like people use cal for stuff around the 1700s every day.
00:08:51 <medfly> they should know if they do.
00:08:55 <Pseudonym> It should, for example, display the Hebrew calendar in Israel, the Lunar calendar in Saudi Arabia, and the Discordian calendar in San Francisco.
00:09:05 <olsner> or maybe it should just say "no calendar data", or just keep counting gregorian
00:09:42 <Pseudonym> Today is Pungenday, the 34th day of Bureaucracy in the YOLD 3174
00:11:07 <olsner> "... from the 12th century until 1751 the legal year in England began on 25 March (Lady Day).", and does cal also take that into consideration?
00:11:35 <Pseudonym> Well, that's the legal year.
00:12:04 <Pseudonym> So probably not.
00:12:45 <codacola> theres a lady day?
00:15:29 <codacola> heh, windos calander doesnt allow you to choose a year before 1900
00:17:21 <olsner> "For example William III of England arrived at Brixham in England on 5 November (Julian calendar), after setting sail from the Netherlands on 11 November (Gregorian calendar)."
00:17:28 <Pseudonym> 1900 is the Win32 epoch, IIRC.
00:17:46 <olsner> but file time stamps are counted from 1600
00:17:48 <gio123> does somebody has access to download: http://portal.acm.org/citation.cfm?id=256195&dl=
00:17:50 <lambdabot> Title: Kleene algebra with tests
00:18:03 <olsner> (in hectonanoseconds, iirc)
00:19:40 <abbe> olsner: 1 hectonanosecond = 10^-7 seconds right ?
00:19:53 <olsner> yeah
00:20:37 <therp> portal.acm.org is really slow today..
00:35:09 <_zenon_> gio123, I think so
00:35:25 <cjs> You have to be a subscriber to TOPLAS.
00:35:27 <_zenon_> gio123, ohh. you mean access as in account?
00:35:49 <_zenon_> yeah, that sucks, citeseer is way better
00:35:52 <cjs> Makes me wonder what I'm getting for my SIGPLAN membership.
00:36:05 <_zenon_> http://citeseer.ist.psu.edu/
00:36:06 <lambdabot> Title: Computer and Information Science Papers CiteSeer Publications ResearchIndex
00:36:51 <mapreduce> I find it ridiculous that publically-funded papers are not visible to the public.
00:37:01 <cjs> I've always found that annoying.
00:37:08 <ac> oops, I put my package in the wrong category. How do I move it?
00:37:31 <_zenon_> cjay, I subscribed to IEEE once in a time, but cut off, costs way too much.
00:38:02 <cjs> Yeah, me too. Ages ago. But their historical computing journal was fascinating.
00:38:02 <_zenon_> mapreduce, yeah, kind of makes you wonder whether they not really WANT you to now know?
00:38:11 <mmorrow> ac: upload a new version
00:38:21 <ac> so just edit the cabal file and reupload?
00:38:27 <mmorrow> yes indeedy
00:38:30 <_zenon_> what has it come to when you have to torrent a scientific paper? :P
00:38:48 <mapreduce> heh
00:38:54 <ac> mmorrow: It's not really a game, but I'll put it in game anyway. Close enough
00:38:58 <mmorrow> ac: you'll have to bump the version num of course
00:39:05 <mmorrow> ac: cool
00:39:38 <therp> gio123: dcc?
00:40:35 <therp> mapreduce: full ack. any university should require their employees to submit only to papers that adhere to the open access standards
00:41:15 <Myoma> how can we make this change happen?
00:41:29 <therp> s/papers/magazines/
00:41:35 <therp> (need more black tea)
00:41:56 <therp> sometimes I wish I had a type checker for irc.
00:42:09 <mapreduce> I have paren-matching.
00:42:23 <_zenon_> mapreduce, for IRC? hehe
00:42:23 <_zenon_> nice
00:42:41 <mapreduce> My IRC client is ERC, part of emacs.
00:43:01 <ac> oops, uploaded a duplicate version. Anyway, w00t, first Haskell package
00:45:23 <cads> is ocaml really more terse than haskell?
00:45:46 <Wild_Cat> gratz.
00:45:48 <Myoma> cads, no
00:46:43 <cads> phew
00:47:40 <cads> I'm glad I'm gullible
00:48:10 <codacola> cads: dont be, demand reasons!
00:48:14 <yitz> cads is it good to be more terse?
00:48:34 <yitz> cads: APL is terse. Perl is terse.
00:48:51 <Wild_Cat> Terse is concise gone bad.
00:49:21 <cads> well I suppose there are different definitions
00:49:29 <yitz> Hurray for COBOL!
00:50:57 <cads> I don't think terseness is bad
00:51:22 <cads> I'd consider stuff like mathematical set builder notation to be terse, and that is a goodness
00:51:27 <mapreduce> A language should not add noise above the problem being solved.  It should instead help to remove noise.
00:51:52 <Twey> Terseness and readability are not directly related
00:52:05 <Twey> The aim is to improve both at the same time
00:52:23 <Twey> Lots of languages succeed at the former, but fail at the latter :)
00:52:44 <yitz> Twey: and vice versa.
00:53:00 <mapreduce> > fix ("new Runnable() { public void run() { "++)
00:53:01 <lambdabot>   "new Runnable() { public void run() { new Runnable() { public void run() { ...
00:53:23 <cads> With apl it seems like implement complex mathematical concepts would be a joy
00:53:56 <mapreduce> Readability and terseness are indirectly related, but ultimately a terse language can be just as unreadable as a verbose language depending on the language and the user.
00:53:59 <yitz> mapreduce: yeah, lambdabot has indeed been having problems with memory leaks lately.
00:54:30 <mmorrow> heh, look at all these zombies http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=34
00:55:10 <Twey> mapreduce: I think you meant to swap 'terse' and 'verbose' in that sentence :-P
00:55:11 <mapreduce> 10,000 lines of repetitive code written by an idiot are more unreadable than one line of Haskell written by Oleg.  And Oleg's probably does more. :)
00:55:21 <mapreduce> Twey: Nope.
00:55:30 <Twey> Heh
00:55:31 <cads> mapreduce: I may have misidentified tersness for the ease with which one can express abstract concepts
00:55:41 <mapreduce> Verbose languages have unreadable code written in them, more often than not.
00:56:18 <Wild_Cat> if verbose meant readable, COBOL would be the way of the future.
00:56:59 <Wild_Cat> after all, ADD A TO B GIVING C is natural language-ish, right?
00:57:37 <mapreduce> what are those funny letters.. did you use shift to get them?
00:57:50 <Twey> Hahaha
00:57:51 <awesame_> have you heard about the object oriented language based on cobol?
00:58:00 <Twey> ADD 1 TO COBOL GIVING COBOL?
00:58:09 <Wild_Cat> hahahaha :D
00:58:20 <cads> : )
00:58:29 <mapreduce> awesame_: What's the punchline?
00:58:33 <awesame_> Twey got it
00:58:40 <cjs> ASK 1 TO ADD 2 GIVING N.
00:59:11 <mapreduce> ADD ONE TO ONE GIVING UP.
00:59:15 <Twey> Hahaha
00:59:18 <mapreduce> DERIVING EQ.
00:59:22 * Twey winces.
01:00:56 <mapreduce> So LHC fired and we're still here.  Damn.
01:01:11 <Twey> Well, not really
01:01:12 * mapreduce writes some unit tests in Java.
01:01:20 <Twey> No particle collisions yet
01:01:27 <yitz> mapreduce: only one beam so far, and low power. no black holes yet.
01:01:28 <Twey> They just fired a single beam around its length
01:01:56 <Twey> The real stuff starts on 2008-10-21
01:01:56 <mapreduce> Ah.  I thought the radio coverage finished because the experiment did.  Now I realise; they are dealing with low attention spans.
01:02:17 <mapreduce> I thought BBC Radio 4 was better than that.
01:02:21 <Twey> Haha
01:02:31 <mapreduce> Oh, the coverage is back.
01:02:52 <cjs> http://thedailywtf.com/Articles/A-Bit-of-Closure.aspx
01:03:01 <lambdabot> Title: A Bit of Closure - The Daily WTF
01:03:04 <cjs> Now let's see Haskell do that!
01:03:15 <mapreduce> Is the point of this to see what happens when you get particles moving faster than the light around them, relatively?
01:03:32 <olsner> mapreduce: no point in having a longer attention span than your audience anyway
01:04:10 <yitz> SET FACTORIAL TO 1. PERFORM MULTIPLY-FACTORIAL VARYING MULTIPLIER FROM 1 BY 1 UNTIL MULTIPLIER >= NUMBER. MULTIPLY-FACTORIAL SECTION. MULTIPLY ANSWER BY MULTIPLIER GIVING ANSWER.
01:04:42 <yitz> or something like that
01:04:43 <mapreduce> > fix ("eventManager.addDelegate(LOAD_COMPLETE, new FunctionDelegate(function() { "++)
01:04:45 <lambdabot>   "eventManager.addDelegate(LOAD_COMPLETE, new FunctionDelegate(function() { ...
01:04:52 <Twey> Heh
01:05:13 <Wild_Cat> cjs: now that's true Enterprise-grade code.
01:05:53 <mmorrow> HAI; CAN HAS STDIO?; IM IN YR LOOP UPPIN YR VAR TIL BOTHSAEM VAR AN 10; VISIBLE SUM OF VAR AN 1; IM OUTTA YR LOOP; KTHXBYE
01:06:02 <mapreduce> COBOL and FORTRAN, the only languages that Java has better lambda support than.
01:06:19 <mmorrow> http://en.wikipedia.org/wiki/Lolcode
01:06:23 <mmorrow> t3h future
01:06:29 <mapreduce> lolcobol
01:06:57 <Twey> addDelegate (LoadComplete, (addDelegate (LoadComplete, addDelegate (LoadComplete, addDelegate (LoadComplete, addDelegate ... ) eventManager)) eventManager)) eventManager
01:07:34 <Wild_Cat> something tells me that kind of stuff would be better expressed as a fold.
01:07:38 <olsner> addDelegate LoadComplete $ do { addDelegate LoadComplete $ do {} ; loadData }
01:07:47 <Twey> No really?  :-P
01:07:59 <Twey> > cycle "addDelegate (LoadComplete, ("
01:08:01 <lambdabot>   "addDelegate (LoadComplete, (addDelegate (LoadComplete, (addDelegate (LoadC...
01:08:29 <Wild_Cat> of course, that I *thought* of a fold for adding callbacks kind of worries me.
01:08:29 <olsner> > cycle "addDelegate (LoadComplete, (" ++ repeat ')'
01:08:31 <lambdabot>   "addDelegate (LoadComplete, (addDelegate (LoadComplete, (addDelegate (LoadC...
01:08:43 <Twey> Heh
01:08:49 <Twey> Infinite Enterpriseness!
01:08:52 <olsner> have to close those parens!
01:08:59 <Twey> Indeed, indeed
01:09:13 <mmorrow> "we'll do that after lunch."
01:09:34 <olsner> > cycle "addDelegate (LoadComplete, (" ++ cycle "))" -- oops, have to keep them balanced!
01:09:35 <lambdabot>   "addDelegate (LoadComplete, (addDelegate (LoadComplete, (addDelegate (LoadC...
01:09:47 * Twey laughs.
01:09:58 <Wild_Cat> "He who fights with WTFs should see to it that he himself doesn't become a WTF. When you gaze into the Enterprise Beans, the Enterprise Beans also gaze into you."
01:10:02 <yitz> > cycle "}))"
01:10:03 <lambdabot>   "}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))}))})...
01:10:06 <Twey> ∞ * 2 = balance!
01:10:25 <Twey> Hahahaha, Wild_Cat
01:10:30 <cads> cjs, that link was traumatising
01:10:39 <mmorrow> > foldr (.) id (repeat read) $ fix show
01:10:42 <lambdabot>   mueval: Prelude.read: no parse
01:10:42 <lambdabot>  mueval: "*** Exception: stack overflow
01:10:49 <cjs> cads: There's more where that came from. :-)
01:10:50 <mmorrow> > foldl (.) id (repeat read) $ fix show
01:10:53 <Twey> Hehe, aye
01:10:57 <cjs> The whole site is traumatising.
01:10:58 <lambdabot>   mueval: Prelude.read: no parse
01:11:05 <mmorrow> > foldl' (.) id (repeat read) $ fix show
01:11:10 <olsner> > fix printf "addDelegate (LoadComplete, (%s))"
01:11:10 <cads> is is totally necessary to code that way in that language?
01:11:12 <lambdabot>   Couldn't match expected type `[Char] -> t'
01:11:15 <Twey> cads: No
01:11:16 <lambdabot>   mueval: Prelude.read: no parse
01:11:41 <Twey> cads: That's indicative of incredible poor design and forethought :)
01:11:48 <Twey> incredibly**
01:11:57 <olsner> wait, no, I fail at fix
01:12:10 <osfameron> try break instead
01:12:53 * cads now has a fear of one day feeling a problem needs a solution as redundant as that
01:13:25 <Twey> Hahahaha
01:14:12 <olsner> > fix (printf "addDelegate (LoadComplete, (%s))" :: String -> String) -- there! stack overflow!
01:14:13 <lambdabot>   mueval: Prelude.read: no parse
01:14:13 <lambdabot>  mueval: "addDelegate (LoadComplete, (*** Ex...
01:14:53 <olsner> printf has insufficient laziness?
01:15:57 <cads> it could happen in haskell, probably with more advanced concepts... there'd be a theorem or reduction principle I wouldn't know  and so I'd be forced to code something in a ridiculously circuitous way : (
01:15:59 <Twey> Where's fix defined?
01:16:12 <olsner> Data.Function
01:16:15 <Twey> Ah, ta
01:16:26 <Twey> Ah
01:16:36 <Twey> It does overflow nicely, olsner
01:16:40 <Twey> But kind of fast :-\
01:16:42 <Twey> "addDelegate (LoadComplete, (*** Exception: stack overflow
01:16:50 <olsner> heh, using lambdabot makes you think everything from fix to arrows are in the Prelude
01:17:14 <Twey> Haha, aye
01:17:35 <luqui> are there any typical structures "between" applicative functor and monad
01:17:38 <luqui> ?
01:17:43 <dobblego> applicative
01:17:45 <BeelsebobWork> how is fix defined in a library?
01:17:46 <dobblego> oops
01:17:54 <olsner> @src fix
01:17:54 <lambdabot> fix f = let x = f x in x
01:17:55 <BeelsebobWork> it's not typable in Haskell's type system is it?
01:18:00 <olsner> sure it is
01:18:03 <olsner> @ty fix
01:18:05 <lambdabot> forall a. (a -> a) -> a
01:18:16 <BeelsebobWork> yeh -- I was under the impression it had to be built in, and it's type defined
01:18:19 <luqui> Beelsebob, but not without it already being there
01:18:24 <BeelsebobWork> luqui: exactly
01:18:28 <BeelsebobWork> that's what I'm saying
01:18:39 <luqui> BeelsebobWork, if there were no recursive lets, then I think haskell would be strongly normalizing
01:18:43 <luqui> I'm not sure about that though
01:18:54 <BeelsebobWork> plausable
01:21:30 <olsner> > printf "addDelegate (LoadComplete, (%s))" (cycle "  ")
01:21:31 <lambdabot>   Add a type signature
01:21:34 <olsner> > printf "addDelegate (LoadComplete, (%s))" (cycle "  ") :: String
01:21:40 <lambdabot>   mueval: Prelude.read: no parse
01:22:21 <olsner> huh, gotta investigate this tonight
01:24:12 <hackage> Uploaded to hackage: gameclock 1.0.2
01:24:12 <hackage> Uploaded to hackage: gameclock 1.0.1
01:24:12 <hackage> Uploaded to hackage: gameclock 1.0
01:26:41 <rwbarton> > fix mueval
01:26:42 <lambdabot>   mueval: Prelude.read: no parse
01:26:52 <luqui> > :t mueva
01:26:53 <lambdabot>   mueval: Prelude.read: no parse
01:26:53 <luqui> > :t mueval
01:26:54 <lambdabot>   mueval: Prelude.read: no parse
01:27:03 <rwbarton> > mueval (mueval: Prelude.read: no parse)
01:27:04 <luqui> oh i see now :-)
01:27:04 <lambdabot>   mueval: Prelude.read: no parse
01:27:08 <rwbarton> :)
01:47:51 <ziman> i have a State BotState Action computation and i need to convert it into a StateT BotState IO Action. Is there a more elegant way than using get, put, and runState manually?
01:48:57 <sjanssen> StateT . fmap return . runState -- should work
01:49:07 <ketil> Whee!  My parsers parse 3-400MB/sec.  Bytestrings FTW!
01:49:16 <ziman> sjanssen, thanks
01:49:41 <sjanssen> ziman: but probably the best thing would be to avoid using State or StateT directly and use the MonadState class
01:50:08 <ziman> hmm
01:50:36 <ziman> any recommended reading/tutorial?
01:51:40 <ejt> ketil: what parse lib are you using ?!
02:04:03 <ketil> ejt: only bytestring :-).  It's a simple format.
02:04:41 <quicksilver> ziman: it's a simple change, it may be your code is fine and you just need to change the type sif.
02:06:45 <ejt> ketil: ah, /me still dreams of parsec that works on bytestrings
02:11:16 <Myoma> hm
02:11:21 <Myoma> @quite
02:11:22 <lambdabot> Maybe you meant: quit quote
02:32:31 <gavin_happy> hello all
02:32:33 <gavin_happy> wow
02:32:39 <gavin_happy> haskell seems really cool
02:33:18 <smtms> gavin_happy, are you happy because of it?
02:34:45 <gavin_happy> well I havent learned lisp
02:34:50 <gavin_happy> which is nice too
02:35:04 <gavin_happy> but concurrency seems important and wow haskell has tons of that
02:35:39 <gavin_happy> smtms: wat do you use haskel for?
02:35:48 <smtms> gavin_happy, currently nothing
02:35:56 <gavin_happy> heh
02:36:18 <smtms> gavin_happy, but I intend to use it for some tree transformations - part of a compiler backend
02:36:38 <gavin_happy> what program will result?
02:36:58 <mapreduce> gavin_happy: A compiler.
02:37:03 <smtms> just a more capable compiler
02:37:14 <gavin_happy> ...
02:37:33 <gavin_happy> good night!
02:38:05 <ejt> that had to be a bot
02:41:02 <smtms> ejt, you sound like a bot
02:41:58 <ejt> smtms: tell me why  I  sound like a bot ?
02:42:11 <mapreduce> Does it bother you that ejt, I sound like a bot?
02:42:28 <ejt> mapreduce: better :)
02:42:59 <cjs> Can you elaborate on that?
02:43:01 <ketil> But will a bot be able to determine if somebody passes the Turing test or not?
02:43:51 <smtms> the Turing test is about human distiguishing a human from a computer, so a bot is by definition not able to do the test
02:44:14 <ejt> even if it passed the test itself ?
02:44:28 <mapreduce> The bot might supervise the test, that's what he asked about.
02:44:56 <quicksilver> conal: changesR :: (Eq a) => Reactive a -> Event a
02:45:00 <quicksilver> conal: this seems useful.
02:45:31 <conal> quicksilver: yeah, it does.
02:46:16 <conal> quicksilver: the Eq is there to make sure the value *really* changes, right?  not just an occurrence in the event part of the reactive's rep?
02:47:04 <conal> i.e., a semantic change
02:47:29 <quicksilver> conal: yes, exactly.
02:47:42 <quicksilver> conal: it's convenient to construct Reactives which have some changes which aren't really changes
02:48:05 <quicksilver> conal: you get them with accumR when your Event is sometimes 'id', and so on.
02:48:20 <luqui> only makes sense if Reactive is a progressive step function
02:48:32 <quicksilver> luqui: eh?
02:48:34 <conal> quicksilver: ah!  which also would lead to unnecessary recomputation.
02:49:03 <quicksilver> conal: Yes. Well in my case I wanted to only display "Mode Changed!" when the mode of my program really changed.
02:49:23 <quicksilver> conal: but because of the way I constructed my "Reactive ProgramMode" it contains changes whch weren't really changes.
02:50:58 <conal> quicksilver: i wonder if there are similar tools that are useful and semantic without Eq
02:51:22 <quicksilver> to some extent this is laziness on my part
02:51:30 <quicksilver> since I could construct the correct event-stream upfront
02:51:41 <quicksilver> but it actually feels easier to construct an accumR which contains some ids
02:51:47 <conal> sure
02:51:48 <quicksilver> and then filter them out as a separate step.
02:52:06 <quicksilver> but you need Eq to filter it out, this way.
02:52:19 <quicksilver> if you had a non-Eq type you'd have to make your functions observable instead
02:52:31 <quicksilver> (data Fun a b = Id | Fun (a -> b))
02:52:45 <quicksilver> well, or just Maybe (a -> b)
02:52:54 <quicksilver> and filter before applying accumR in the first place
02:52:56 <conal> quicksilver: yeah.
02:53:06 <conal> quicksilver: aside: monoidR might be fun as well, using Endo
02:54:01 <conal> quicksilver: though i haven't enjoyed the required adding & stripping of Endo ctor.
02:55:01 <quicksilver> conal: yeah, that's what I don't like about :.
02:55:13 <conal> quicksilver: me too :(
02:55:13 <quicksilver> conal: I find the O constructor quite unintuitive to use in practice :)
02:55:42 <conal> quicksilver: one symptom is that :. is not associative, for a trivial reason.
02:55:46 * luqui thinks typeclasses are not perfect...
02:56:17 <quicksilver> luqui: for which purpose?
02:56:23 * conal wonders about using higher-order unification and backtracking (higher-order logic programming) in instance selection.
02:56:44 <Myoma> I was going to prototype something in lambda prolog
02:56:47 <Myoma> but I couldn't decide what
02:56:53 <luqui> For the purposes they are used for in Haskell.  eg. necessity of Endo wrappers
02:57:08 <quicksilver> conal: I would like to know if there is a good reason for haskell's current instance selection algorithm
02:57:16 <quicksilver> conal: I have a feeling there might be, but I'm not sure.
02:57:29 <quicksilver> conal: I think monotonicity of instance selection when adding new modules is part of it.
02:57:34 <luqui> I don't know how to make them better, but I think some kind of explicit dictionary passing with (restricted) term inference might fit this kind of usage better
02:57:57 <quicksilver> luqui: I use "explicit dictionary passing" very heavily in my own programs
02:58:03 <quicksilver> luqui: much much more often than typeclasses.
02:58:25 * luqui too, maybe not more often than type classes... about the same.
02:58:36 <luqui> it's a delicate balance.
02:58:45 <quicksilver> I agree with what sjanssen neatly summed up yesterday: typeclasses are for when there is obviously only one morally correct instance for each type.
02:58:47 <mmorrow> this is pretty cool: http://hpaste.org/10238
02:59:01 <luqui> eg. functor most of the time
02:59:07 <mmorrow> apparently it's easy to inspect closures in ghci
02:59:16 <mmorrow> and get their itable entry code
02:59:20 <quicksilver> mmorrow: awesome!
02:59:31 <mmorrow> totally!
02:59:57 <__bgi> mmorrow: wow!
02:59:59 <mmorrow> i want to figure out how to construct datatypes and load them into ghci
03:00:03 <mmorrow> err, i mean
03:00:12 <mmorrow> data A = A | B deriving (Show)
03:00:13 <mmorrow> a
03:00:15 <mmorrow> A
03:00:20 <mmorrow> and then it prints A
03:00:30 <mmorrow> like how hbi does it
03:00:33 <quicksilver> luqui: Endo is a slightly deeper issue, though. It's not just more-than-one-instance. It's that (->) has the wrong kind.
03:00:52 <conal> Myoma: lambda-prolog is fun stuff!
03:01:00 <luqui> quicksilver, oh right, good point.
03:01:27 <conal> quicksilver: i have the same hunch/impression about monotonicity & selection
03:01:30 <luqui> quicksilver, wait, no, not really.   Monoid works on kind *.
03:01:56 <dons> http://www.reddit.com/r/programming/comments/70n09/gat_a_git_clone_in_haskell/
03:01:58 <lambdabot> Title: gat, a git clone in haskell : programming, http://tinyurl.com/5hnyxj
03:02:01 <luqui> whati s monotonicity in this context?
03:03:47 <Wild_Cat> git "clone"? Does that mean "git reimplementation that's compatible with the original", or merely "DVCS that somewhat looks like git"?
03:04:19 <Corun> git clone is a command
03:04:32 <Corun> Roughly equivalent to svn co
03:04:36 <luqui> lol
03:04:50 <luqui> communication fail!
03:04:55 <Corun> :-D
03:07:05 <quicksilver> luqui: importing a new module may bring new 'instance selection rules' into scope which, with a more relaxed algorithm, could change the instances of existing types.
03:07:31 <quicksilver> luqui: the current rules have the property that bringing new rules into scope can add instances but never change existing instances.
03:08:25 <luqui> ah, ok.  good to have a name for that.
03:08:26 <quicksilver> conal: equally I wonder if there is another deep reason. I keep meaning to bring it up on -cafe.
03:08:56 <mmorrow> sometimes i wish you /could/ override instances sometimes. or at least have a way to selectively import them.
03:08:56 <quicksilver> conal: "why doesn't instance Foo a => Bar a" do what I want is the number one typeclass FAQ.
03:09:12 <quicksilver> mmorrow: that way lies very serious problems.
03:09:13 <mmorrow> i'm not sure what (if any) problems that would cause though.
03:09:21 <quicksilver> mmorrow: typeclasses are used to guarantee invariants.
03:09:30 <quicksilver> mmorrow: more than one instance available in the context of a program breaks them.
03:09:32 <Myoma> I would like to replace typeclasses with a real relational language
03:09:59 <quicksilver> it's fairly clear to me that a more powerful logical setup for instance search would permit some horrendous abuse.
03:10:03 <Myoma> not something that implementing factional seems like magic in
03:10:09 <quicksilver> it's less clear to me currently what useful things it would permit.
03:10:24 <quicksilver> (well, I suppose in general it permits more type-level programming, which might be useful)
03:10:40 <luqui> type level programming is great.  type level programming with typeclasses is not so great.
03:11:02 <mmorrow> quicksilver: hmm. but what if, say, i have a module and in it i hide some instance for a type A, and make and use my own instance in that module (and this instance isn't visible outside of this module)?
03:11:03 <luqui> it's like template metaprgramming.  yeah, you _can_ do it, but what you mean is almost always obscured in the process of encoding it.
03:11:11 <Myoma> what type level programming?
03:11:33 <luqui> Myoma, kind of a loose term.  doing "tricky stuff" at compile time, roughly.  ;-)
03:11:39 <mmorrow> quicksilver: so you could both selectively import /and/ selectively export instances.
03:11:55 <quicksilver> mmorrow: it becomes visible in ways you don't expect.
03:12:08 <quicksilver> mmorrow: suppose that class is 'Ord' and you use the instance to construct a Data.Map
03:12:31 <quicksilver> mmorrow: you pass the Data.Map outside of your module and, although you are not allowing the Ord instance out, accessing that Map with a different Ord instance will make everything break.
03:13:05 <mmorrow> quicksilver: ah yeah, true. hmm.
03:13:22 <luqui> hmm, I think I would probably like a typeclass system where explicit *instantiation* is required, but propagation is just like in Haskell
03:14:12 <mmorrow> quicksilver: err, but why would it break? if i don't export my instance of Ord there, it'll be (from the module thich imports my module) as if no instance of Ord for that type exists.
03:14:13 <luqui> so: foo f = fmap f  (fine), foo' f = fmap f [1,2,3]  (need instance for Functor [Int])
03:14:19 <quicksilver> mmorrow: that would be fine.
03:14:24 <quicksilver> mmorrow: (that's already permitted and possible)
03:14:36 <quicksilver> mmorrow: the problem is if there is a different Ord instance somewhere.
03:15:45 * luqui wonders if that is possible, or if there is a tricky issue hiding in there...
03:16:00 <Myoma> chamelion uses CHR
03:16:03 <Myoma> I think
03:16:15 <mmorrow> quicksilver: hmm. i have to think it through and try to come up with an instance where something breaks. i don't have as clear a picture as i'd like in my head.
03:16:34 <quicksilver> luqui: any system which countenances there being more than once instance for a type (anywhere in a program, not necessarily in the same scope) has the basic problem.
03:16:53 <quicksilver> luqui: if you permit that, you have to stop using typeclasses to guarantee invariants.
03:17:07 <quicksilver> force dictionaries to be bundled with the objects.
03:17:08 <luqui> quicksilver, what sort of invariant are you referring to?
03:17:19 <quicksilver> well, Ord + Data.Map is the most natural example
03:17:29 <quicksilver> if you insert into a Data.Map with one Ord instance, and select with another
03:17:31 <quicksilver> it will bork.
03:17:47 <luqui> oh I see what you mean now.
03:18:10 <luqui> yeah, to do that right you'd need to go all the way to dependent types
03:18:37 <luqui> or I guess you could use regions :-)
03:18:38 <Myoma> why would you want dependent types, you could just pass a (<) function?
03:19:06 <luqui> not for map in specific, but for typeclass invariants in general
03:20:00 <mmorrow> Myoma: i personally dislike the relational flavor most of the type-level stuff, and would much prefer it to be functional.
03:20:01 <quicksilver> yes, you can always bundle the dictionary with the value
03:20:09 <quicksilver> that's a solution
03:20:13 <quicksilver> but it's not a simple solution
03:20:22 <quicksilver> Where do you bundle the Binary dictionary into your ByteString?
03:20:34 <quicksilver> (how do you pass that Binary dictionary over the wire with the ByteString?)
03:21:23 <quicksilver> how expensive is it to bundle Monoid dictionarys with every Int value in your program, just to give you the freedom to choose between Sum and Product monoids?
03:21:38 <luqui> quicksilver, I don't follow that exmaple.  Bytestring has no parameter, so no enforcement is done.
03:21:41 <quicksilver> I think some of these questions have good answers, but I don't think they're simple small steps.
03:21:57 <quicksilver> luqui: if you 'encode' into a ByteString with one instance, and 'decode' with another, it will break.
03:22:05 <luqui> quicksilver, better yet, how do you bundle a Num dictionary with an Int?
03:22:31 <quicksilver> luqui: if you want a more painful example, switching Storable instances on a Ptr can cause segfaults :)
03:22:43 <luqui> quicksilver, yeah, but if you encode into a ByteString with Binary Int, and decode with Binary Float, it will break.
03:23:07 <quicksilver> true. So it's always the application's responsible to keep the type information around.
03:23:15 <quicksilver> But supposing it *has* kept the type information around.
03:23:21 <quicksilver> it also needs the corresponding instances.
03:23:44 <luqui> yeah, but how is that different from "it's the application's responsibility to keep the codec function around"
03:23:48 <quicksilver> I might know that a ByteString contains a MyData; and I might have a nice derived Binary instance for MyData which I always use. This is safe.
03:24:04 <mmorrow> i don't recall the particulars, but jhc has an interesting implem of typeclasses
03:24:04 <quicksilver> however, deep down inside, the Binary instance for MyData depends on the Binary instance for Double
03:24:26 <quicksilver> if some smart alex introduces an IEEE-based binary instance for Double instead of the one I had
03:24:37 <quicksilver> suddenly reading my Bytestring as 'MyData' fails
03:24:40 <luqui> anyway, I think the ByteString one is a bad example.  Though most of your other examples were good :-P
03:24:54 <quicksilver> mmorrow: it's not semantically any different though.
03:25:11 <quicksilver> mmorrow: it's based on passing types instead of classes, which has some cute operational benefits.
03:25:18 <quicksilver> (types instead of dictionaries)
03:26:52 <luqui> hmm, typeclasses in the dependent type world correspond to open functions...
03:27:03 * luqui wonders if any DT languages permit open functions
03:27:58 <Myoma> mmorrow: I thought about taking the whole program, running hindly milner on it, then you have some relational constraints which can instantiate variables, fail, or maybe calculate some programs
03:27:58 <Saizan> in The Power of Pi they use universes
03:28:07 <mmorrow> found the description: http://repetae.net/dw/darcsweb.cgi?r=jhc;a=annotate_shade;f=/docs/type-classes.txt
03:28:09 <lambdabot> Title: darcs - jhc, http://tinyurl.com/5f3r5l
03:28:53 <Myoma> mmorrow: it seems to me like after type inference you have partial information on both sides of any equation you might describe as a function, so I wonder about good ways to exploit it
03:29:18 <mmorrow> Myoma: that sounds interesting. it would be great if there was a lightweight way to type{check,infer} haskell code.
03:29:40 <mmorrow> Myoma: hmm.
03:30:56 <mmorrow> Myoma: that's going on my "to think about" list
03:31:26 <Myoma> it's on mine too, as soon as I have something that seems workable I'd like to prototype it
03:36:16 <kowey> ejt: ping
03:37:06 <mmorrow> Myoma: sweet. i'd be down to hack on that for sure.
03:37:33 <kowey> @tell ejt by the way, you're welcome to come hack on Haskell-hg implementation at the darcs hacking sprint (25-26 Oct)
03:37:33 <lambdabot> Consider it noted.
03:37:34 <ejt> kowey: hi
03:37:34 <lambdabot> ejt: You have 1 new message. '/msg lambdabot @messages' to read it.
03:37:42 <kowey> whoops :-)
03:38:22 <ejt> kowey: I didn't know about that, will definitely join in
03:38:25 <quicksilver> conal: BTW my basic modal application does now work. It's not very interesting but I was exploring combinators.
03:38:37 <ejt> kowey: where are the details ?
03:38:56 <kowey> ejt: http://wiki.darcs.net/index.html/Sprints
03:38:57 <lambdabot> Title: Sprints - DarcsWiki
03:39:00 <quicksilver> conal: I think I'm going to replace my uses of accumE with foldE, though. accumE feels clumsy
03:39:07 <quicksilver> conal: I end up using too many fmaps everywhere
03:40:26 <ejt> kowey: I still think strict IO is the place to start
03:40:46 <kowey> for optimisation of darcs?
03:41:28 <ejt> yep
03:42:02 <kowey> hmm... would love to see you there so we can talk about it
03:42:16 * dcoutts loves the lazy io
03:42:39 <dcoutts> kowey: I might be at the Portland event, I'm staying for a bit after ICFP
03:42:52 <dcoutts> otherwise I'd come to the Brighton venue
03:43:00 <ejt> I have a week off next week, so hopefully I can make some good progress on the Hg project
03:43:58 <kowey> dcoutts: oh, please do drop by either way!
03:44:29 <kowey> ejt: I was always kinda hoping that somebody would work on a Haskell implementation of git (for the same reasons as you)
03:44:41 <kowey> I have no preferences between hg/git (just have heard of the latter)
03:44:51 <gio123> does somebody have a book: E.L. Leiss, Language Equations, Springer, New York, 1999.
03:45:21 <gio123> ?
03:50:14 * luqui prefers git because of in-place branches.  but they're both great systems.
03:51:41 <kowey> my dream for Future Darcs is still seamless integration
03:52:03 <kowey> so one of the hopes with hhg/hgit is to one day use them as a darcs library :-)
03:52:32 <kowey> also along the way, maybe getting some shared code between the systems, or just us learning some lessons from you
03:53:13 <ejt> kowey: I do wonder if there's smaller, sharper set of patch tools hiding in darcs, that would be of use to all distributed source control software
03:53:38 <ejt> seperating patch manipulation from repo storage
03:53:47 <kowey> ah!  I hope so!
03:54:09 <kowey> ejt: my dream for Future Future darcs is that darcs patch manipulation becomes a generic undo lib, used by yi, the gimp, etc
03:54:11 <conal> quicksilver: congrats about your app.
03:54:45 <Axman6> conal: what's the app?
03:54:46 <kowey> ejt: in the meantime, we're working on DarcsLibraries http://wiki.darcs.net/index.html/DarcsLibraries
03:54:47 <lambdabot> Title: DarcsLibraries - DarcsWiki
03:55:01 <kowey> ejt: and also getting a nice clean safe API for repository manipulation
03:55:16 <conal> quicksilver: i'd like to see your accumE uses and what you replace them with.  to get a sense of the style issue.
03:55:31 <kowey> so we're starting from the outside and working our way in; i.e. trying to spinn off as much stuff as we can, but it's slow going
03:55:37 <conal> Axman6: quicksilver is doing an FRP-based app, using a variant to the "reactive" library
03:55:57 <Axman6> FRP? :\
03:56:28 <yitz> Functional Reactive Programming
03:56:43 <Myoma> Is it online ? I would like to read it
03:57:44 <quicksilver> Myoma: it's not an exciting app. it's just the combination of two simple toys: a character-based addition program and a line-based string reverser
03:57:54 <yitz> Axman6: event-based programming in a functional language.
03:57:59 <quicksilver> Myoma: it is an experiment into whether reactive programming lets you do truly "composable" programming.
03:58:02 <ejt> kowey: ok, that all look sensible - I think there are more pressing issues though - like the way you can't do a recursive add on a large project without eating all the memory in the world
03:58:03 <Myoma> could you hpaste it please ?
03:58:05 <Axman6> ah, righto. sounds good
03:58:08 <Myoma> if it's short enough
03:58:17 <quicksilver> i.e. develop two applications as if they were independent, and then combine them without their knowledge.
03:58:21 <Myoma> I wonder what reactive looks like
03:58:35 <quicksilver> I will hpaste a chunk. at least
03:58:39 <quicksilver> 5k is the hpaste limit, right?
03:58:51 <yitz> quicksilver: or use a different paste bin
03:59:05 <quicksilver> hmm true.
04:01:09 <mmorrow> i'm gonna remove the limit on that hpaste2 i have up. already did that on my local copy...
04:02:46 <yitz> mmorrow: does hpaste2 know how to announce on irc?
04:03:00 <yitz> that was the nicest feature of hpaste.
04:03:08 <mmorrow> there's an ircbot that comes with it, but i haven't set it up
04:03:08 <quicksilver> Myoma: http://hpaste.org/10239
04:03:26 <mmorrow> i should though. the web interface even lets you tell it what channel to announce inm
04:03:28 <quicksilver> conal: see the uses of accumE in http://hpaste.org/10239
04:04:41 <Myoma> ?where+ moonpaste http://moonpatio.com:8080
04:04:42 <lambdabot> Done.
04:06:39 <yitz> quicksilver: is order significant in mconcat?
04:07:20 <quicksilver> yitz: only very slightly.
04:07:21 <yitz> quicksilver: what kind of stream are the keypresses in? (off-topic, but interesting anyway)
04:07:39 <quicksilver> yitz: in the case of simultanous events, you get the left-most one first.
04:08:03 <quicksilver> yitz: getKeypresses = keepCalling getChar
04:08:15 <quicksilver> yitz: keepCalling turns an IO action into an Event by calling it over and over again.
04:08:24 <conal> quicksilver: ok, thanks.
04:08:35 <yitz> quicksilver: what is "simultaneous"? below the resolution of some timer?
04:08:56 <yitz> keepCalling sounds like a nice way to represent a stream, actually.
04:08:59 <quicksilver> yitz: Well, some things are perfectly simultaneous, whatever timer you have.
04:09:07 <quicksilver> yitz: for example, two copies of the same event ;)
04:09:09 * Myoma does not understand this code :(
04:09:19 <quicksilver> yitz: consider keypresses `mappend` keypresses
04:09:26 <yitz> quicksilver: I was going to suggest spin switches in electron pairs
04:09:44 <quicksilver> yitz: this is not as stupid an example as it seems, since quite often you have events derived from other events, and thus "precisely" simultaneous with them.
04:10:19 <quicksilver> Myoma: feel free to ask questions. You may be interested in Conal's paper on it.
04:10:19 <yitz> quicksilver: gotcha.
04:10:45 <quicksilver> yitz: otherwise, yes, simultaneous up to the resolution of 'getCurrentTime', in my implementation, would count as simultaneous.
04:10:55 <quicksilver> but that is actually quite unlikely to happen naturally.
04:11:10 <conal> quicksilver: looks pretty nice to me, but yeah i can see you'd like to abstract out the accum/fmap pattern.
04:11:40 <quicksilver> conal: foldE :: b -> (a -> b -> b) -> Event a -> Event b
04:11:49 <quicksilver> conal: actually taht's a really bad name. I mean 'scanE'
04:11:51 <FunctorSalad> since this is also #logic ;-) would anyone know about this? is it possible to do a variant of FOL without quantifiers by replacing existentials by skolem functions and making all variables universally quantified?
04:11:55 <quicksilver> conal: would abstract one common pattern.
04:12:10 <Myoma> is accumE & fmap something like bind ?
04:12:13 <Myoma> except in reactive
04:12:46 <quicksilver> conal: and trivially scanE init f ev = accumE init (fmap (f$) ev)
04:12:52 <quicksilver> Myoma: that's not a bad intuition.
04:13:00 <Myoma> I see
04:13:03 <quicksilver> Myoma: an 'Event a' is a stream of "a" values, arriving over time
04:13:05 <yitz> quicksilver: what are the principle instances of Event and Reactive (besides Functor)?
04:13:21 <quicksilver> (presumably cause by some external event like a key being pressed)
04:13:28 <quicksilver> Myoma: fmap is fairly natural.
04:13:40 <quicksilver> Myoma: accumE is a way of progressively building up a value.
04:14:22 <Saizan> FunctorSalad: that looks like what the skolemization theorem says
04:14:24 <quicksilver> Myoma: http://www.haskell.org/haskellwiki/Reactive
04:14:25 <conal> quicksilver: i have the same definition in Reactive.hs (scanlE)
04:14:25 <lambdabot> Title: Reactive - HaskellWiki
04:14:34 <quicksilver> conal: ah, right ;)
04:15:06 <conal> quicksilver: with the first two arguments reversed
04:15:29 * quicksilver nods
04:15:52 <conal> @type scanl
04:15:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:15:54 <FunctorSalad> Saizan: yeah, I'm just a little worried that apparently you have to "dynamically" add new skolem functions whenever a new formula comes up, but that still seems easier to handle on a computer than quantifiers
04:16:30 <quicksilver> conal: anyhow the main point is the "compositionality" aspect is a success.
04:16:38 <quicksilver> two minor surprising consequences
04:16:46 <quicksilver> the key you press to 'change mode' is also passed to the submode
04:17:00 <FunctorSalad> Saizan: and my language only has functor symbols rather than function symbols, but that should be okay
04:17:02 <quicksilver> and when you switch modes, the old mode remembers its state for when you return
04:17:06 <yitz> quicksilver: accumE is a scanl over an event stream in the sense that it returns the intermediate values as a new event stream?
04:17:07 <quicksilver> not bad things, necessarily, but interesting.
04:17:13 <quicksilver> yitz: yes.
04:17:34 <quicksilver> yitz: it effectively enables you to remember the last event
04:17:38 <quicksilver> (or more than that, if you like)
04:17:46 <quicksilver> which is rather important for lots of things.
04:18:00 <quicksilver> accumE [] (:) remembers all previous events.
04:18:12 <quicksilver> I called that 'history' although I haven't actually found it useful. Just cute.
04:18:26 <Saizan> FunctorSalad: uhm, refresh me on terminology, what's the difference between them?
04:18:26 <conal> quicksilver: yeah.  that's a nice idiom i hadn't thought of
04:19:34 <quicksilver> conal: my next concern is how I adapt this to run inside a callback-driven mainloop like GLUT
04:19:36 <Axman6> ah, it's so nice to have 4GB ram. came today, and now my haskell programs kill my computer in twice the time!
04:19:41 <quicksilver> conal: then I can do something 'real' with it.
04:20:11 <Myoma> you will have a stream of events as the mouse and keyboard ?
04:20:21 <Myoma> and then combine them to output some graphics?
04:20:33 <quicksilver> yes.
04:20:37 <quicksilver> that's the idea, Myoma
04:20:52 <quicksilver> my example program has type "Event (IO ())"
04:20:57 <quicksilver> i.e. a stream of IO actions
04:20:57 <Myoma> even if you just do something trivial it will be very interesting to see
04:20:59 <FunctorSalad> Saizan: "function symbols" are part of usual FOL, "functor symbols" I just made up ;-) now that I think about it, I think my "functor symbols" are just constant symbols of sort "functor"
04:21:03 <quicksilver> which the main harness executes.
04:21:17 <quicksilver> a more interesting graphical program would be of type "Behaviour SceneGraph"
04:21:21 <Mr_Awesome> quicksilver: make asteroids! :)
04:21:32 <quicksilver> and the rendering routine "SceneGraph -> IO ()" would be called perioidcally by the harness.
04:21:33 <FunctorSalad> Saizan: and my function symbols (for FOL-category theory) are things like dom, cod, id, compose
04:21:44 <quicksilver> Mr_Awesome: I have some already-written code I want to port
04:21:50 <quicksilver> Mr_Awesome: as a test case
04:22:02 <yitz> quicksilver: so by composible you mean you can run them independently in parallel? it looks like the keypress stream is split before it goes into the composition, and after that there is no communication between the components at all.
04:22:03 <Mr_Awesome> i see
04:22:04 <FunctorSalad> Saizan: so I think there's an extra layer of indirection here compared to skolem functions...
04:22:38 <Axman6> i'm writing asteroids in java at the moment, it's kind of fun, but not all that stimulating
04:23:04 <Mr_Awesome> i wrote asteroids in haskell using yampa a while back
04:23:16 <quicksilver> I've not played with yampa
04:23:26 <quicksilver> for some reason, Reactive was the first FRP setup that really caught my interest.
04:23:46 <quicksilver> I'm actually using my own implementation not conal's, but I don't claim mine is better.
04:23:46 <Mr_Awesome> quicksilver: yampa's worth a look, at least
04:23:48 <yitz> Is Reactive an Arrow?
04:24:06 <quicksilver> no, it has the wrong kind.
04:24:09 <quicksilver> Reactive a
04:24:20 <yitz> ah right. a monad?
04:24:31 <quicksilver> yes
04:24:40 <quicksilver> and therefore a -> Reactive b is an arrow
04:24:51 <quicksilver> but, I'm not currently *using* the Monad instance of Reactive.
04:24:52 <yitz> ok. Event is just foldable or something?
04:24:56 <quicksilver> in fact, I haven't even written it.
04:25:04 <quicksilver> Event is Monoid and Functor.
04:25:07 <mmorrow> the bot's giving me trouble at the moment, but i upped the char limit from 5000 to 30000 here: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
04:25:14 <quicksilver> Reactive is Applicative
04:25:15 <yitz> ah, ok.
04:25:21 <mmorrow> you can also get there by just doing http://moonpatio.com:8080
04:25:33 <yitz> quicksilver: I guess so, if it's a monad.
04:25:36 <Myoma> mmorrow cool!
04:25:59 <quicksilver> The applicative instance is more 'obviously' useful
04:26:06 <quicksilver> "Apply a changing function to a changing value"
04:26:08 <mmorrow> Myoma: it's nice. i have my local hpaste2 at maxBound chars ;)
04:26:16 <quicksilver> (producing a changing value"
04:26:38 <Myoma> mmorrom, yay supports unicode
04:26:43 <mmorrow> oh yesh
04:27:48 <fnord123> is reactive standard?
04:28:05 <Myoma> @undef
04:28:07 <Myoma> ...
04:28:09 <Myoma> @undefine
04:28:14 <Myoma> what is going on
04:28:20 <Botje> @bot
04:28:20 <lambdabot> :)
04:28:23 <yitz> > 2
04:28:24 <quicksilver> fnord123: no.
04:28:24 <lambdabot>   2
04:28:26 <Botje> she's still alive, at least
04:28:39 <quicksilver> fnord123: it may not even be complete.
04:28:48 <quicksilver> fnord123: although I think it's pretty close.
04:29:17 <conal> quicksilver: we're hooking up reactive to glut here.  what i call the "legacy adapter".  maybe our methods will be useful to you also.
04:29:33 <yitz> quicksilver: when you compose Reactives, can they send messages to each other?
04:29:52 <quicksilver> yitz: reactives are a bit more passive than that.
04:29:55 <fnord123> i was thinking of doing something like reactive to use with glut
04:30:02 <quicksilver> that's like asking if functions can send messages to each other.
04:30:12 <quicksilver> you can pass functions as parameters to functions
04:30:16 <quicksilver> and they can use each other
04:30:17 <conal> quicksilver: also hooking up reactive & FieldTrip
04:30:22 <quicksilver> -- and this is true of reactives too.
04:31:02 <quicksilver> conal: FieldTrip?
04:31:18 <quicksilver> fnord123: I have a bunch of GLUT hacks I plan to convert to reactive
04:31:26 <quicksilver> fnord123: if I can get it working sufficiently well.
04:31:33 <quicksilver> first up is my particles system fire hack.
04:31:40 <fnord123> neat
04:31:56 <conal> quicksilver: a functional 3d library that i started with andy gill last spring and we're using here at anygma
04:32:01 <fnord123> i was hacking shu thing to make it do my bidding and thought i would want something like reactive to handle events
04:32:39 <quicksilver> conal: does that mean, something like a scene graph?
04:32:45 <conal> btw, i'm setting up a mailing list and trac for reactive.
04:32:48 <quicksilver> conal: or more like a physics engine?
04:33:32 <conal> quicksilver: not a physics engine.  and not like "scene graph" APIs i've seen, which are very stateful.
04:33:47 <conal> quicksilver: 3D geometry (and related types) as first-class values
04:34:41 <quicksilver> conal: well, a scene graph doesn't have to be stateful ;) Just cos they all are.
04:35:19 <conal> quicksilver: scene graph apis also usually have a "graph" feel.  i.e., representational rather than denotational.
04:35:27 <conal> i.e., there are navigation operations.
04:35:45 * quicksilver nods
04:35:53 <conal> those two aspects are why i don't use the term "scene graph".
04:35:57 <conal> and use "functional geometry" instead
04:36:02 <fnord123> isn't that an ideal place to use something like a zipper?
04:36:07 <quicksilver> yes
04:36:10 <yitz> conal: sounds like a C++ class library we hacked together when I was doing 3D ultrasound rendering.
04:36:14 <quicksilver> (if navigation is a goal)
04:36:17 <mm_freak_> in "I have a X interest in…", what sounds best for X?  "big", "great" or "large"?
04:36:34 <Twey> mm_freak_: 'no'
04:36:37 <yitz> mm_freak_: strong
04:36:40 <quicksilver> mm_freak_: 'profound' 'deep' 'intense' 'abiding'
04:36:42 <quicksilver> ;)
04:36:45 <fnord123> mm_freak_: deep
04:36:52 * Twey wonders why he missed that article
04:37:00 <Twey> 'healthy'
04:37:02 <conal> i think scene graph libs exponse editing and navigation because they're impoverished functional languages, which are then edited at run-time.
04:37:04 <mm_freak_> ok hehe, thanks
04:37:07 <FunctorSalad> mm_freak_: "enormous-ass"
04:37:10 <FunctorSalad> :-)
04:37:20 <mm_freak_> ;)
04:37:28 <FunctorSalad> but seriously, depends on the application
04:37:30 <quicksilver> conal: zipper based navigation and "editing" could be useful in some settings, though.
04:37:31 <conal> simpler & more powerful is to embed a functional data type in a functional language.
04:37:41 <quicksilver> conal: but other settings don't need "editing" in that sense at all.
04:37:57 <quicksilver> some settings generate a fresh graph each iteration anyway
04:38:10 <quicksilver> (although the underlying implementation may be able to take advantage of sharing)
04:38:18 <conal> quicksilver: one could layer a sort of syntactic interface over a semantic geometry data type, as with any data type.
04:38:24 * quicksilver nods
04:38:29 <conal> so i like to keep them orthogonal
04:38:31 <yitz> conal: but you said you also have navigational elements
04:38:46 <mm_freak_> i'm not a native speaker, and i'm trying to say something like:  "…  and as i have X interest in increasing haskell's deployment…"
04:38:46 <conal> yitz: i did?
04:39:40 <yitz> ah, you were talking about "scene graphs" - the other guys.
04:39:53 <yitz> conal: so yours is representationaL?
04:39:59 <conal> no.  semantic.
04:40:31 <conal> and therefore has non-trivial properties, allows optimization, etc.
04:41:09 <yitz> conal: yeah, in C++ we would build up from our base objects. at run time, but only once at the beginning.
04:41:41 <yitz> conal: based on incoming data though, so it couldn't be a static hard-coded declaration.
04:42:18 <conal> yitz: i also did a C++-based functional geometry a while back: http://conal.net/tbag/
04:42:19 <lambdabot> Title: TBAG Home Page
04:42:50 <conal> it used constraints to automatically synthesize functions from time to geometry, i.e., 3d animations.
04:42:54 <mmorrow> also, there's a javascript shell here: http://moonpatio.com:8080/jsh.html  i find it handy/amusing
04:43:08 <mmorrow> well, not a shell, but a js interpreter
04:43:50 <mmorrow> (w/ command history!!)
04:43:54 <Myoma> that's a nice trick
04:44:00 <mmorrow> heh
04:44:02 <mmorrow> do:
04:44:06 <mmorrow> document.body.innerHTML
04:44:08 <yitz> conal: hmm. so your elements are fixed in advance, but they transform dynamically. same for FieldTrip?
04:44:38 <conal> yitz: what do you mean by "elements"?
04:45:36 <yitz> conal: well in your case it sounds like you are animating a scene. isn't it composed of fixed objects that move or transform in some way?
04:46:19 <conal> yitz: got it. no, nothing has to be static.  arbitrary functions from time to geometry.  not just animated spatial transformations.
04:48:05 <Axman6> yitz: you know problem 188?
04:48:16 <conal> yitz: e.g., one can write functions of arbitrary parameters to geometry (or image or ...) and use liftAn to lift them to functions from dynamic parameters to dynamic results.
04:48:51 <conal> yitz: where "dynamic" can be time function or function of UI parameters or general reactive behaviors.
04:49:09 <Axman6> found something quite depressing with it, the mathematica answer is "Nest[PowerMod[1777, #, 10^8] &, 1777, 1855 - 1]" which runs the whole tetration, not just a little bit of it... and it finishes in about a second -_-
04:49:49 <yitz> conal: our app was given a large set of 2d sections and their coordinates, construct a 3D rep. of it. Then provide a nice UI to investigate it - rotate it, change transparency, slice cross-sections, 2D and 3D measuring tools, etc.
04:50:09 <conal> yitz: neat
04:51:28 <yitz> conal: the main subjects we rendered were fetuses :)
04:52:12 <yitz> conal: would that kind of thing fit in to your approach?
04:52:52 <quicksilver> conal: I would imagine decomposing it into a reactive part "Behaviour SceneGraph" and an (openGL) interpreter SceneGraph -> IO ()
04:53:09 <quicksilver> conal: the 'internals' of scenegraph would then not need to be at all explicitly reactive
04:53:17 <quicksilver> just a plain old data type you layer reactive outside of
04:53:21 <conal> yitz: i'm just talking about functional programming & graphics.
04:53:27 <quicksilver> am I along the right lines or are you doing something different?
04:54:01 <conal> quicksilver: exactly.  the geometry type is static, just like Bool, list etc.  orthogonality.
04:54:55 <conal> quicksilver: usually people try to build behavior or animatability into the geometry representation, which means it's not as simple & general.
04:55:30 <conal> one of my principles is to make such data types as non-special as possible.
04:55:34 <quicksilver> conal: OK. That's what I meant by a scene graph.
04:55:39 <quicksilver> the scene graph is the data type
04:55:53 <quicksilver> the library is a set of combinators for building "Behaviour SceneGraph"
04:55:59 <quicksilver> i.e. reactive scene graphs
04:56:11 <quicksilver> my terminology may be non-standard
04:56:18 <quicksilver> it arose in a discussion with BeelsebobWork_ over there
04:56:22 <quicksilver> you know how unreliable he is ;)
04:56:23 <conal> quicksilver: sure.  it's a different meaning from any scene graph api i've seen.
04:56:28 <conal> :)
04:56:40 <Beelsebob> quicksilver: :P
04:57:01 <yitz> Axman6: could be that mathematica's built-in PowerMod is smart enough to look for the 2 tricks needed, which are inherent to modular arithmetic.
04:58:03 <quicksilver> conal: my particles program is a simple example of this.
04:58:08 <Axman6> yeah, could be, nest might look to see if the value is changing, and if not, return it
04:58:16 <quicksilver> conal: I plan to pull out my particles as a 'Behaviour [Particle]'
04:58:19 <conal> quicksilver: e.g., there's even a scenegraph library on hackage (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/scenegraph)
04:58:21 <lambdabot> Title: HackageDB: scenegraph-0.1, http://tinyurl.com/5qx9wp
04:58:22 <quicksilver> conal: will be a good test case
04:58:37 <yitz> Axman6: glad to hear you got it though.
04:59:15 <conal> quicksilver: yep.  you could then fmap a renderer of type [Particle] -> Geometry
04:59:25 <Axman6> yeah, though with a little help form Beelsebob. i would've got it if i'd had the time though
04:59:32 <quicksilver> conal: how would you constrast the notation in that scenegraph package with your own?
04:59:37 <quicksilver> cube 0.5 `colour` Green `scale` v1x 40 `translate` vy 2 <+> camera `translate` vy (-10) <+> light `translate` vz 10
04:59:42 <quicksilver> conal: ^^ example from his wiki page
05:02:12 <conal> quicksilver: that part looks like it _might_ be semantically compatible.  looking at SceneData and use of FGL, i infer something more like a traditional scene graph, i.e., state-based traversal.
05:02:50 <quicksilver> conal: OK. the combinators look OK, but it depends what they do.
05:03:05 <quicksilver> conal: if the data-structure they produce is too low-level it is not amenable to high-level techniques.
05:03:13 <quicksilver> if the data-structure is something like the free data structure
05:03:20 <quicksilver> then high-level passes are possible.
05:03:53 <conal> quicksilver: mainly i wonder what the semantics are.  do they require something semantically intractable like IO in order to explain them?
05:04:00 * quicksilver nods
05:04:06 <quicksilver> I understand.
05:04:14 <quicksilver> I don't always know what you mean when you say semantics.
05:04:28 <quicksilver> computer scientists (myself included) overload that word badly ;)
05:04:30 <dobblego> there is a clever combinator that gets: ["ab", "bc", "cd"] (or something like it?) from "abcd", anyone know what I am talking about?
05:04:34 <quicksilver> but I think I'm following you now.
05:04:44 <quicksilver> dobblego: map (take 2) . tails
05:05:03 <conal> quicksilver: thx for that feedback.  i have a strong bias toward simple denotational semantics.  which is why i don't like IO.
05:05:04 <Twey> :t tails
05:05:05 <lambdabot> forall a. [a] -> [[a]]
05:05:09 <Twey> @src tails
05:05:09 <lambdabot> tails []         = [[]]
05:05:09 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
05:05:11 <purestorm> Hi, I have a parsec question: In this http://hpaste.org/10241, the > parse... line makes ghci block. Why is this so?
05:05:36 <conal> quicksilver: i'm also very suspicious of the use of FGL.  as if geometry has some kind of inherent structural nature, unlike other data types.
05:06:16 * Twey frowns.
05:06:26 <Twey> > tails [1, 2, 3, 4, 5]
05:06:27 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
05:06:35 <Twey> .ua
05:06:41 <Twey> Peculiar function
05:06:43 <conal> quicksilver: and i'm especially suspicious of nodes like MatrixTransform and Light, which remind me of Inventor and similar APIs, which have very order-dependent semantics.
05:06:48 <Beelsebob> Twey: why for?
05:06:50 <Axman6> Twey: why?
05:06:59 <Axman6> damn it Beelsebob, quit that
05:07:05 <Beelsebob> Axman6: :P
05:07:09 <Twey> Haha
05:07:10 <Twey> Just never something I thought of as being useful
05:07:13 <quicksilver> conal: Yup. Mind you, order-dependent semantics aren't an absolute evil.
05:07:22 <conal> quicksilver: though i did get an email from the author of that library, saying that FieldTrip is what he really wanted to do.
05:07:33 <quicksilver> conal: it's merely a question of "finding the semantics which has the largest number of symmetries it can"
05:07:51 <quicksilver> and discarding semantic systems which exhibit too few symmetries
05:08:05 <conal> quicksilver: yes.  simple denotational model and nice math properties.
05:08:50 <conal> while traditional retained mode (scene graph) APIs are derived from operational models.
05:09:00 <conal> particularly, stateful traversal.
05:09:41 <conal> that's why i have a visceral ICK response to even the from "scene graph", after my years at Sun and then Microsoft.
05:10:41 * Zao cues http://home.comcast.net/~tom_forsyth/blog.wiki.html#%5B%5BScene%20Graphs%20-%20just%20say%20no%5D%5D
05:10:43 <lambdabot> Title: TomF's Tech Blog - It's only pretending to be a wiki., http://tinyurl.com/2pz7fd
05:11:12 * Axman6 takes note not to take the FFT of a 4000x4000 matrix in mathematica again
05:11:38 <quicksilver> conal: OK, I understand where you're coming from now.
05:11:55 <quicksilver> conal: some kinds of effect are quite hard to find the right semantic model for without introducing some notion of order
05:11:57 <conal> quicksilver: statefulness aside, the term "graph" in "scene graph" could be taken to describe the semantics (free) or interface (traversal), or as describing an implementation.  if the former, yuck.  if the latter, then irrelvant to users.
05:12:46 <conal> quicksilver: yep.  semantic modeling is challenging.  once there's a nice & adequate model, i'm confident that i am working on solid ground.
05:13:08 <quicksilver> conal: various special effects I do in OpenGL (and I'm a part-time opengl hacker only) rely on drawing order
05:13:25 <conal> quicksilver: sure.  the implementation does.
05:13:32 <quicksilver> conal: drawing particles using blend effects, have to be drawn after the things behind them etc.
05:13:49 <quicksilver> conal: well it's non-trivial to get an efficient implementation without pushing some of that forward to the front-end
05:14:07 <conal> quicksilver: i wonder if you could describe rather than implement the effects.
05:15:02 <conal> quicksilver: btw, i don't yet know of a simple & adequate semantic model for 3d.  i'd really like to.
05:15:35 <conal> quicksilver: one that has simple semantics and can be implemented on current hardware.
05:16:02 <quicksilver> conal: OK, I think that's the only point I was making.
05:16:19 <quicksilver> conal: in the interests of simplicity it's an easier path to expose some of the peculiarities of the back end.
05:16:47 <conal> quicksilver: i meant *semantic* simplicity.
05:16:59 <quicksilver> conal: the use case is "draw a large number of particles using a semi-transparent blend mode"
05:17:09 <quicksilver> And I meant implementation simplicity ;)
05:17:41 <quicksilver> the problem is that drawing order is critical. It has to be drawn after the stuff behind, and before any stuff in front.
05:17:43 <conal> quicksilver: yeah.  they're in opposition, since graphics hw and APIs are mountains of implementation hacks.
05:17:51 <quicksilver> completely depth-sorting the scene is a solution.
05:18:01 <quicksilver> but it's an expensive solution, and not entirely pleasant to implement.
05:18:13 <conal> quicksilver: yeah.  we have to deal with the same problem.
05:18:16 <quicksilver> deciding when you need to dept-sort and when you don't is a good answer, but that presents a challenge.
05:18:23 <Zao> quicksilver: Which is quite unfeasible when you start throwing vertex shaders into the mix.
05:18:32 <Zao> Let alone geometry shaders.
05:18:47 <conal> quicksilver: do you think you can specify the meaning of what you want?
05:18:48 <quicksilver> well they're my shaders. I know what invariants they violate and wht they don't.
05:19:03 <quicksilver> I have to "depth-sort taking into account the peculiarities of my shaders"
05:19:10 <quicksilver> which, I agree makes the problem even harder Zao
05:19:46 <quicksilver> conal: Yes. I think so. This example is really quite simple. There is a clear semantic description of the scene.
05:19:53 <quicksilver> the quirk is just depth-sorting before drawing
05:19:57 <quicksilver> (manually or automatically)
05:20:03 <quicksilver> currently I just draw the particles last
05:20:22 <quicksilver> i.e. manual, partial, depth-sort
05:20:30 <conal> quicksilver: see if you can describe the "quirk" purely in semantic terms.
05:20:41 <conal> and then maybe see why the operational quirk is necessary for correctness.
05:20:48 <conal> where correctness is defined by semantics.
05:21:54 <Svrog> quicksilver: there are some hacks that give you order independent transparency though there is a limit to how many transparent layers you can get away with
05:21:59 <quicksilver> Svrog: *nod*
05:22:09 <quicksilver> Svrog: and most of the hacks have other parameters which limit which one you choose when.
05:22:16 <Svrog> yeah
05:22:18 <conal> if you have a (simple denotational) semantic model for your geometry (including particles) and for rendering, then it may come clear exactly (in math terms) why ordering is needed.  from there i bet you'd be in a much better position to see implementation possibilities.  you'd have a foundation for correctness & optimization.
05:22:28 <quicksilver> Svrog: which makes a truly 'universal' scene description hard
05:22:37 <quicksilver> Svrog: because in a 'universal' context it's hard to choose the right hack.
05:22:38 <mmorrow> ?hoogle runWith
05:22:38 <lambdabot> No results found
05:22:57 <quicksilver> Svrog: for a particular closed example - a particular application - you can choose the right hack easily enough.
05:23:04 <mmorrow> ?hoogle Handle -> Handle -> IO a -> IO a
05:23:05 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
05:23:05 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
05:23:05 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
05:23:21 <quicksilver> conal: I expect you're right. I will ponder it.
05:23:22 <conal> quicksilver: and by "rendering" i mean a function from geometry to images, rather than some kind of IO thing.
05:23:32 <quicksilver> conal: I'll even upload my code so you can ponder :P
05:23:35 <quicksilver> if you're interested.
05:24:16 <conal> quicksilver: yes, i'd like to take a look. especially if you're moving in semantic direction.  i'm really puzzled about how to do 3D graphics in a semantically simple & sound way.
05:24:32 <conal> rich & fast 3D graphics
05:25:38 <conal> quicksilver: btw, svrog is also working on this project and is working on GPU-based execution.
05:25:56 <Svrog> yup
05:26:28 <Axman6> how would GPU programming be done in haskell anyway? would it be done via something like CUDA or OpenCL?
05:27:03 <Svrog> yeah, or opengl or directx
05:27:28 <Svrog> cuda is limited only to nvidia 8x00+ series of cards however
05:27:37 <Axman6> i as more thinking about gpu computations, rather than graphics
05:27:37 <Svrog> and opencl isn't gonna be out for at least another year
05:27:51 <Axman6> less than a year i'd say
05:27:59 <Axman6> macworld most likely
05:28:03 <Svrog> that leaves opengl 2 pretty much as the the only wide-spread and cross platform base
05:28:20 <conal> Axman6: btw, see http://conal.net/papers/Vertigo/, which targeted old (now) GPUs
05:28:20 <lambdabot> Title: Programming Graphics Processors Functionally
05:28:25 <Svrog> opengl and directx can be used for gpgpu
05:28:45 <Svrog> yeah what i trying to do currently is a lot like vertigo
05:28:54 <Svrog> im*
05:29:20 <quicksilver> I have a perlin noise implementation I'd like to move to the GPU
05:29:20 <Axman6> conal: very nice
05:29:26 <quicksilver> but that's not high on my priority list :)
05:29:26 <conal> :)
05:29:42 <quicksilver> I'm mainly interested in being able to writer better hacks, quicker
05:29:51 <quicksilver> and if reactive can make me more productive, I'm all for it.
05:30:10 <quicksilver> a couple of my openGL programs stalled because the degree of modality got painful to manage
05:30:26 <quicksilver> I'm hoping reactive can help, which is why I was working towards a modality example.
05:30:45 <Svrog> i'd like to hide as many of those hacks as possible without killing performance
05:31:02 <Svrog> though there will likely be some performance impact
05:31:22 * quicksilver nods
05:31:40 <quicksilver> (I note that the sense of the word 'hack' in my last use was a different once)
05:31:53 <Svrog> having said that most popular 3d engines out there don't perform all that great either
05:32:23 <Svrog> so i don't think it will be hard to match their performance
05:32:46 <conal> for me, simple clear meanings is the essense of functional programming, which is why i distinguish between haskell programming (with IO) and functional programming.
05:32:55 <Svrog> yup
05:33:49 <conal> i'm a lot more interested in functional programming.  and it takes quite some thought to see through layers of imperative just to the functional essence, so progress can be slow.
05:33:49 <quicksilver> I agree with the spirit of that observation.
05:34:06 <quicksilver> I think you risk using different terminology to other people, though ;)
05:34:24 <conal> i'm distressed every time i see haskell described as a "purely functional language"
05:34:38 <quicksilver> ah. I'm not.
05:34:41 <conal> since i think it's only literally true, but then so is C programming.
05:34:44 <quicksilver> a -> IO b is a pure function.
05:34:52 <quicksilver> that's the point isn't it?
05:34:53 <conal> yes it is.
05:35:03 <conal> and yet it's not semantically useful
05:35:08 <conal> and the same is true of every C program.
05:35:09 <quicksilver> whereas ML has impure a -> b
05:35:29 <conal> so Haskell is more honest about its imperativeness.
05:35:30 <quicksilver> C is impure in the same sense as ML : its types lie.
05:35:36 <quicksilver> haskell is pure to its type system.
05:35:50 <conal> quicksilver: i'm making a different connection between Haskell and C
05:35:52 <flux> conal, however, in C there is no way to see from a function signature whether it have effects or not
05:35:53 * quicksilver nods
05:36:06 <conal> namely Haskell is to IO as the CPP language is to C
05:36:06 <flux> "can have"
05:36:16 <quicksilver> conal: it's only a historical accident that IO is inscrutable.
05:36:21 <quicksilver> conal: well actually it's more than that.
05:36:22 <conal> C programmers program in the CPP language, which is purely functional.
05:36:26 <quicksilver> but the point is IO *could* be scrutable.
05:36:30 <quicksilver> it just happens not to be.
05:36:33 <conal> quicksilver: semantically?
05:36:33 <quicksilver> Or parts of it could be.
05:36:34 <Svrog> that realization along some of the other stuff conal mentioned gave me a new perspective on programming, and functional programming in general :)
05:36:48 <quicksilver> conal: sure. data IO a where GetChar :: IO a .....
05:37:03 <quicksilver> conal: you could expose parts of it and define absolutely precise semantics for those parts.
05:37:08 <quicksilver> it just happens that we haven't done that.
05:37:16 <quicksilver> and we've bundled *everything* into one big sin bin.
05:37:36 <flux> in haskell only the top-most function is able to perform real-world operations by returning a script that drives them. in C any function anywhere can do anything.
05:37:52 <conal> flux: i'm talking about CPP
05:38:13 <flux> conal, c pre processor, c plus plus, c something else?
05:38:21 <conal> preprocessor
05:38:32 <conal> which is a functional language, just like haskell is.
05:38:47 <conal> and generates "programs" in an imperative language, just like haskell does.
05:39:20 <conal> and useful understanding of a CPP/C program requires a model of the imperative language, just as does Haskell/IO programs.
05:39:55 <conal> that's why i don't see Haskell+IO as purely functional any more than CPP+C.
05:40:18 <conal> both statements are accurate in a literal sense, but not true in a useful sense.
05:40:25 <conal> hi andyjgill
05:40:38 <flux> I'm not sure how the existence of CPP changes anything. Let's say we strip CPP away and replace it with a preprocessor that simply works as "cat". Has this change anything, are we still programming a preprocessor that happens to construct an imperative program?
05:41:05 <conal> flux: yes.  as in haskell+IO
05:41:22 <conal> flux: you've simply weakened the functional part even more.
05:41:25 <lilac> a haskell program is a program which runs at compile-time and produces an imperative program
05:41:40 <quicksilver> conal: haskell + IO is much more usefully functional than CPP+C
05:41:52 <conal> quicksilver: yes!
05:42:02 <conal> quicksilver: *more* functional, not *purely* functional.
05:42:14 <conal> so change the slogan to "Haskell: a relatively functional language"
05:42:14 <lilac> quicksilver: what about C++ templates plus C++?
05:42:34 * quicksilver still disagrees.
05:42:39 <conal> or "Haskell: a more usefully functional language than CPP+C"
05:42:45 <quicksilver> The point about the difference between a -> IO b and a -> b is the key to purity.
05:43:06 <Axman6> "Haskell: as pure as it gets"
05:43:07 <lilac> conal: "Haskell: a referentially-transparent language"
05:43:09 <quicksilver> SPJ gives lectures about how laziness was the stick which beat him into keeping purity throughout.
05:43:17 <flux> conal, if IO was stripped from haskell, would it then in your opinion be pure?
05:43:19 <BeelsebobWork_> quicksilver: so is your assertion that IO is not part of Haskell then?
05:43:27 <conal> quicksilver: i don't think you really disagree, assuming you understand what i'm saying.  i think you just prefer a different perspective.
05:43:35 <luqui> lilac, that's the most accurate I can think of :-)
05:44:29 <Svrog> when you use io, you are effectively programming imperatively - referential transparency isn't broken, but you have an imperative language emulator right there
05:44:37 <Svrog> or IO rather
05:44:39 <luqui> not much of a slogan though, because wtf does "referentially transparent" mean?  might as well just go all out and say Haskell: Monads and Anamorphisms!
05:44:40 <desp> Has anyone tried modifying the Parsec tokenizer to handle whitespace as explicit tokens?
05:45:04 <lilac> "Haskell: a referentially-transparent language with no side-effects except for the magic incantation 'main ='"
05:45:23 <quicksilver> BeelsebobWork_: not at all. My assertion is that "a -> IO b" is a pure function; given any particular value of type 'a' it will always return the same action of type 'IO b'
05:45:26 <luqui> desp, that's pretty easy isn't it?
05:45:26 <conal> another angle: haskell+IO is programming in two different languages.  one with simple semantics and one without.
05:45:29 <lilac>  --> "Haskell: a purely functional language except for 'main = '"
05:45:40 <quicksilver> BeelsebobWork_: and *that* is the essential of purity.
05:45:41 <luqui> desp, whitespace is in the language def, which is replacable
05:46:03 <quicksilver> BeelsebobWork_: (in particular contrast to ML, where a function 'a -> b' need not always give the same b for a given a)
05:46:07 <conal> quicksilver: i completely agree with your assertion.  what's missing for me is semantic tractability.
05:46:14 <flux> my view on the matter is that the haskell as a language is pure. however, the haskell runtime environment obviously isn't, and is capable of running such haskell pure programs.
05:46:24 <BeelsebobWork_> quicksilver: yes, but Haskell doesn't just create IO actions, it also runs them
05:46:30 <flux> the haskell runtime can read the list of instructions the pure haskell programs generate and work accordingly
05:46:41 <conal> and i like that haskell is more honest about this semantically intractable stuff than ml is.
05:46:41 <Wild_Cat> it'd be pretty useless if it didn't run IO actions.
05:46:43 <quicksilver> haskell is a pure programming language with a good semantics. Unfortunately the output of a haskell program is an IO action, and this has a less-good semantics.
05:46:45 <luqui> conal, quicksilver, perhaps, "given the same a, it will always return the same action of type IO b, whatever the hell an IO b is"
05:46:59 <conal> luqui: exactly
05:47:02 <lilac> conal: any turing-complete pure functional language has an embedding of the IO monad into it
05:47:12 <quicksilver> BeelsebobWork_: with apologies for being pedantic, there is a useful sense in which haskell does not run IO actions. The compiler/RTS runs the IO actions.
05:47:13 <conal> and since i care about semantics, i want to know what an IO b is.
05:47:43 <quicksilver> BeelsebobWork_: haskell is entirely usable/useful without this conventional RTS action.
05:47:53 <lilac> conal: "IO b" is an opaque data structure with a number of predefined operations, and semantics definable in terms of side-effects
05:47:57 <quicksilver> mueval as exposed in lambdabot.
05:48:12 <conal> lilac: i want a simple denotational semantics.
05:48:19 <conal> even a tractable one
05:48:27 <quicksilver> conal: Yes, I think we do agree. Although I would moderate your comments a bit further. "IO a" may be a bit semantically intractable, but it's better than what most other languages give you.
05:48:36 <quicksilver> conal: at least it obeys the monad laws ;)
05:48:38 <conal> sorry.  i'm so biased toward *denotational* semantics that i forget to say "denotational"
05:48:43 <luqui> SPJ wrote down some very complicated semantics for a subset of IO.
05:48:48 <luqui> not all of it.
05:48:48 <conal> quicksilver: which says almost nothing
05:48:51 <BeelsebobWork_> so quicksilver I think conal is right then -- you're just chosing the perspective that "it's in the runtime, so it's not part of Haskell"
05:49:05 <BeelsebobWork_> in much the same way as conal's unamb function would be part of the runtime, not part of Haskell
05:49:13 <conal> BeelsebobWork_: which is exactly what i say about CPP & C.
05:49:17 <BeelsebobWork_> indeed
05:49:17 <quicksilver> conal: in particular, say, the MVar fragment is much more tractable than most other implementations of concurrency.
05:49:28 <pjdelport> BeelsebobWork_: in the sense that you mean, only unsafePerformIO runs IO actions
05:49:31 <conal> and since people really program in CPP, not in C, they can say their programs are purely functional also.
05:49:40 <quicksilver> conal: I"m pretty sure I could formalise MVars with a denotational semantics, given a little time.
05:49:43 <luqui> though unamb does have a well defined semantics (provided you fulfill its proof obligation)
05:49:48 <conal> quicksilver: i'd like that
05:49:49 <pjdelport> and it's not part of referentially transparent Haskell
05:49:49 <lilac> conal: "IO b" is a side-effecting program which produces a "b". each primitive operation of IO type defines the semantics for the program it produces. what's the problem?
05:50:01 <quicksilver> lilac: the fact that they don't ;)
05:50:13 <quicksilver> lilac: there is no definition for the semantics of those primitives.
05:50:29 <quicksilver> in principle they could define their semantics, but they don't.
05:50:33 <conal> lilac: do you know about denotational semantics?
05:50:37 <lilac> isn't that a documentation bug?
05:50:41 <quicksilver> quite a lot of them just call libc, and there's no semantics for that.
05:50:47 <quicksilver> lilac: yes. But it's a big bug and hard to fix.
05:51:01 <quicksilver> as in, many-year research project with many extremely good people required to fix it.
05:51:06 <luqui> conal, (it might help, when you say denotational, you also mean compositional.  I've heard the two separated before)
05:51:12 <lilac> conal: yes. but expecting denotation smenatics for things which interface with the outside world seems to require us to define denotatonal semantics for the outside world itself...
05:51:32 <quicksilver> there are known ways of doing that lilac
05:51:33 <lilac> perhaps that's not quite what i mean
05:51:35 <conal> lilac: i don't think so.
05:51:35 <quicksilver> a variety of them.
05:51:39 <quicksilver> streams of input events
05:51:49 <BeelsebobWork_> luqui: is it really possible to write a denotational semantics that isn't compositional?
05:51:49 <quicksilver> giving a semantics to a filesystem is not unfeasible
05:51:58 <conal> quicksilver: not necessary.
05:52:13 <quicksilver> conal: well you have to give semantics to 'readFile' and 'getSymbolicLinkStatus'
05:52:14 <lilac> sure. but the outside world is largely nondeterministic and terrifying.
05:52:34 <quicksilver> the fact that it's nondeterministic doesn't matter, it's external.
05:52:40 <Svrog> quicksilver: not necessarily
05:52:45 <lilac> it matters if you want semantics for it, i think
05:52:45 <luqui> BeelsebobWork_, to answer that question you have to define "denotational".  and then it's trivial.  but I"m formulating a better response.
05:53:04 <quicksilver> "the outside world will generate events (we don't know how) but we do know how to calculate the result of our program, given those events"
05:53:05 <Svrog> if you get rid of the concept of files for example
05:53:07 <conal> quicksilver: maybe, maybe not.  maybe just define the semantics of how a program interacts with such things, say as Event -> Event functions.
05:53:26 <conal> quicksilver: exactly
05:53:27 <Svrog> and have everything as code and data - haskell as an operating system :)
05:54:32 <ariep> > let ns = 0 : map succ ns in length . show $ ns !! 10^1000
05:54:33 <conal> Svrog: exactly.  we're in an odd situation now where we think that interacting with file systems is part of a problem to be solved or question to be answered.  i think of it not as a question but as an old answer.
05:54:33 <lambdabot>   1001
05:54:38 <luqui> BeelsebobWork_, denotational semantics, the way I learned it, was just that you define the meaning of a program by its denotation (in some other domain)
05:54:51 <conal> Svrog: i'd rather try to remember the question and give a different answer.
05:55:01 <luqui> BeelsebobWork_, whereas conal requires the meaning function to be a homomorphism
05:55:36 <luqui> but really denotational semantics the way I learned it is more of a presentation than a property.
05:55:42 <conal> luqui: yes i do assume compositionality.  but the model itself is the really important part to me
05:56:48 <quicksilver> I agree with luqui; denotations can be entirely trival.
05:56:53 <conal> i read IO meaning StuffWeDontUnderstand
05:56:57 <quicksilver> You can denote a program by its source code, for example.
05:57:01 <conal> quicksilver: yes
05:57:03 <quicksilver> But normally we speak of 'interesting' denotation.
05:57:11 <quicksilver> typically ones which make identical, equivalent programs
05:57:13 <conal> with useful & nontrivial properties
05:57:15 <quicksilver> (or at least some of them)
05:57:35 <quicksilver> ideally we take a denotation into some other well-known domain
05:57:41 <quicksilver> a domain about which we already know theorems
05:57:46 <conal> yeah :)
05:57:51 <quicksilver> and we hope to reflect those theorems back, along the denotation
05:57:54 <quicksilver> and learn about our program.
05:58:10 <lilac> conal: how about this: there are two classes of IO actions. (1) those which aren't really IO, and don't communicate with the RealWorld, such as IORef. we can give these semantics (mostly in terms of ST). (2) those which do perform genuine RealWorld stuff. these just build a data structure (so putStr x = PutStr x). our program exists to produce, and is specified in terms of, this data structure.
05:58:11 <conal> quicksilver: yes!  i like your description.
05:58:12 <quicksilver> this requires the denotation to have enoguh symmetries to reflect the theorem back.
05:58:20 <luqui> which we cannot do about IO, because there are no theorems about, um, complicated crap nobody has fully written down yet.
05:58:41 <_zenon_> Is there a neat way to list everything that instances Monoid ?
05:58:50 <quicksilver> luqui: well actually there are loads of theorems about complicated crap :)
05:58:53 <luqui> _zenon_, ;info in ghci
05:59:00 <quicksilver> luqui: there isn't a Grand Unified Theory of Complicated Crap though
05:59:05 <conal> lilac: i'd still want to know the meanings of those data structures, in order to design and understand my program.
05:59:07 <quicksilver> luqui: just fragments here and there in the literature.
05:59:21 <luqui> quicksilver, fair enough :-)
05:59:28 <_zenon_> luqui, hm. k. thank
05:59:28 <quicksilver> _zenon_: the web documentation page for Monoid
05:59:40 <quicksilver> _zenon_: lists all the instances that were visible to haddock when it built that page
05:59:54 <lilac> conal: they have no semantics, just like 'Just x' has no inherent semantics
06:00:07 <quicksilver> _zenon_: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#t%3AMonoid
06:00:08 <Myoma> Just x has semantics..
06:00:09 <lambdabot> Title: Data.Monoid, http://tinyurl.com/szdxl
06:00:16 <lightstep> lilac, what about forkIO if none of the threads touch the real world?
06:00:21 <conal> lilac: if they have no semantics, then you wouldn't mind arbitrarily replacing them.
06:00:32 <_zenon_> quicksilver, yeah, thanks.
06:00:34 <conal> lilac: with other equally meaningless data structures
06:00:35 <lilac> lightstep: i'd call that category (1), so i'd want semantics for it
06:00:53 <quicksilver> lilac: for example you want to know if (putStr "foo" >> putStr "bar") is truly equivalent to (putStr "foobar")
06:01:04 <conal> quicksilver: exactly
06:01:06 <quicksilver> lilac: this is precisely the kind of reasoning you hope a denotational domain allows you to do.
06:01:14 <lilac> conal: they have no *inherent* semantics. but if the purpose of your program is to be 'PutStr "foo"' then replacing it with something else is not acceptable...
06:01:24 <quicksilver> conal: incidentally this is reasoning that haskell's Monad laws allow it to do ;)
06:01:26 <Myoma> reasoning with the awkward squad is a paper about proving that sort of thing
06:01:30 <quicksilver> conal: so score one point to me.
06:01:39 <conal> lilac: why not acceptable, since they have the same (nonexistent) smcs
06:01:44 <conal> semantics
06:01:54 <quicksilver> conal: (because putStr is defined to be mapM putChar, and we have free theorems about mapM)
06:02:00 <luqui> lilac, but Bind (PutStr "foo") (const (PutStr "bar")) cannot be reduced to (PutStr "foobar") if all it is is a data structure
06:02:04 <conal> quicksilver: yes, one tiny point for you!
06:02:08 <lilac> quicksilver: i am not convinced that (putStr "foo" >> putStr "bar") *is* truly equivalent to (putStr "foobar")
06:02:14 <quicksilver> lilac: It may not be.
06:02:18 <quicksilver> lilac: that is exactly the question!
06:02:19 <lilac> quicksilver: at least, not in the presence of unsafeInterleaveIO
06:02:24 <quicksilver> I agree it's not obvious.
06:02:30 <quicksilver> and that's why IO is intractable.
06:02:35 <quicksilver> because we can't tell.
06:02:39 <conal> quicksilver: right!  and even without unsafeInterleaveIO
06:02:39 <quicksilver> but we'd like to be able to tell.
06:02:49 <conal> because of concurrency
06:03:04 <lilac> but if we can agree that there are no inherent semantics, then our work is done
06:03:11 <quicksilver> but we don't want to agree that.
06:03:15 <quicksilver> we want to be able to reason, please.
06:03:31 <quicksilver> agreeing there are no semantics is saying "I want to go home, I can't do anything with this"
06:03:45 <Myoma> lilac: What equivalence relation are you using?
06:03:48 <luqui> lilac, in the same way that a mathematician who decides to go into liberal arts's work is done
06:03:50 <quicksilver> whereas I want to say "I can guarantee your aeroplane is safe, now pay me the million dollars you promise med"
06:04:10 <quicksilver> and to do that, I need to be able to reason about the programs.
06:04:11 <lilac> quicksilver: but we *can* say that
06:04:29 <lilac> we can say, this program produces the following IO datastructure, therefore is correct, since that was the required structure
06:04:37 <quicksilver> conal: I didn't intend to be petty, I hope it didn't come across that way. My point is there is some limited reasoning we can do. IO is not a completely barren domain.
06:04:42 <luqui> lilac, how do you specify the required structure?
06:04:46 <quicksilver> conal: but it could be much better. and we hope it would be.
06:04:54 <lilac> luqui: in terms of the primitives of it, such as PutStr
06:05:11 <luqui> lilac, so you're saying "this haskell program is correct because it is equivalent to a transliteration of itself"
06:05:18 <lilac> yes
06:05:33 <luqui> great, all my programs are correct!
06:05:35 <lilac> "this haskell program is correct because it is equivalent to the specification"
06:05:53 <luqui> lilac, what if you want your specification to be something simpler than the program?
06:05:59 <moshisushi> hello i need a little help writing a proper base case for this functino
06:06:04 <moshisushi> function*
06:06:07 <lilac> luqui: then you're kidding yorself
06:06:08 <Myoma> "this haskell program is correct because it type checks"
06:06:10 <lilac> that's not possible
06:06:16 <moshisushi> transpose xs = map (head) xs : transpose (map (tail) xs)
06:06:28 <luqui> lilac, that is certainly not true.
06:06:31 <lilac> luqui: if the specification is complete, you can write a compiler for it
06:06:39 <Myoma> moshisushi: You could cheat.. lambdabot knows the answer
06:06:46 <Myoma> moshisushi: *I* don't..
06:06:47 <flux> lilac, actually a specification can say that the return value of this function must this assertion
06:06:48 <pastorn> @src transpose
06:06:48 <lambdabot> transpose []             = []
06:06:49 <lambdabot> transpose ([]   : xss)   = transpose xss
06:06:49 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:06:49 <lilac> luqui: otherwise, the specification is ambiguous
06:06:56 <luqui> lilac, what you just said is equivalent to all statements being decidable
06:06:57 <flux> lilac, while actually implementing the function can be more compilcated
06:07:17 <luqui> lilac, here is a simple specification: "find the least number x for which there are no twin primes above x".
06:07:29 <luqui> lilac, or Nothing if there is no such number
06:07:30 <lilac> luqui: no, it's equivalent to all computable fucntions being computable
06:07:37 <moshisushi> hmm so you can't transpose using map like that?
06:07:45 <lilac> luqui: a non-computable specification is obviously broken, for instance.
06:07:56 <luqui> lilac, but what about that specification that I jsut gave?
06:08:10 <luqui> lilac, we don't know if it's computable :-)
06:08:10 <conal> quicksilver: and i didn't mean "tiny point" in a harsh way.
06:08:34 * Myoma wonders what would happen if you coded up a IO monad in OTT
06:08:38 <conal> quicksilver: i wanted to say that yes we get a tiny bit of non-trivial reasoning, compared with all we don't get
06:08:42 * quicksilver nods
06:08:45 <luqui> lilac, but if it is computable, we would sure like to know that our program that computes it conforms to it
06:08:45 <lilac> luqui: sure, exhastively enumerate all possible programs, run each of them in turn, and if the function is computable, eventually one will produce a proof of the answer
06:09:05 <Myoma> lilac: run them all _concurrently_*
06:09:06 <lilac> luqui: if none of them do, your program doesn't terminate but your spec was not computable
06:09:24 <Myoma> lilac: If you run them all in turn and program 3547 was let x = x in x
06:09:29 <lightstep> moshisushi, the complexity of that implementation is bcause the definition throws out empty lists, instead of returning an empty product
06:09:33 <lilac> Myoma: no. you run program 1 for 1 step. then you run programs 1 and 2 for 2 steps each, and so on
06:09:40 <lilac> this is a well-known technique
06:09:41 <Myoma> lilac: Ok, so.. concurrently
06:09:54 <luqui> lilac, but how is it going to produce a proof of the answer if there are no theorems about IO?
06:09:59 <luqui> lilac, s/theorems/laws/
06:10:17 <lilac> luqui: you don't need theorems if your spec is in terms of the algegraic type of IO
06:10:20 <Myoma> lilac: (You are aware this is as practical as brute forcing SHA-1? :) )
06:10:23 <luqui> lilac, my spec wasn't.
06:10:36 <Myoma> infact probably less so
06:10:38 <lilac> Myoma: i didn't say practical. we're talking semantics here :)
06:10:46 <luqui> Myoma, probably!?
06:11:03 <Myoma> I don't know, lots of smart people seem to be, brute forcing math
06:12:08 <luqui> lilac, right.  so what does a proof of main = ... outputs the string representing the least number x for which there are no twin primes above x look like?
06:12:11 <lilac> luqui: your spec was in a language for which you have provided me with no semantics
06:12:30 <moshisushi> lightstep: yeah that's what i struggled with :)
06:12:43 <moshisushi> lightstep: but lambdabots solution was exactly what i needed
06:12:46 <moshisushi> thanks guys!
06:12:57 <luqui> lilac, we use the semantics of first order logic + arithmetic
06:13:08 <lilac> luqui: in "find the least number x for which there are no twin primes above x">
06:13:10 <lilac> ?
06:13:11 <luqui> and somehow map the output of the haskell program into that
06:13:16 <luqui> but we have no semantics for IO, so we cannot.
06:13:28 <Myoma> give semantics to IO by modelling a computer/teletype, it's very simple
06:13:40 <lilac> this seems to work fine using the semantics i described. i don't see the problem.
06:14:09 <luqui> lilac, it does?  okay, then take my semantics and convert them into something that makes sense for IO.
06:14:28 <luqui> I don't know how, but you claim you do.
06:14:40 <ariep> how is this possible:
06:14:41 <ariep> > let ns = 0 : map succ ns in length . show $ ns !! 10^1000
06:14:42 <lambdabot>   1001
06:14:52 <ariep> given that (!!) takes an Int argument
06:15:11 <ariep> and that I wouldn't a computer to be able to do so many applications of succ and finish in time
06:15:28 <lightstep> > ((10^1000)::Integer) `mod` ((2^32)::Integer)
06:15:29 <lambdabot>   0
06:15:32 <luqui> (lilac, or rather, you claim you have an algorithm which can semidecidably.  write the algorithm)
06:15:40 <luqui> lilac, or convince me you can.
06:16:29 <lilac> luqui: sure. the program has value PutStr x, where x = show (y :: Integer) and there are no twin primes above y.
06:16:41 <lilac> the second part of that lives within the standard denotational semantics for Haskell
06:17:28 <luqui> lilac, and what if I wrote a program which was not PutStr x, but instead did lots and lots of fancy IO stuff, but still produced the same answer.
06:17:35 <lilac> the program proceeds as i described above, with an ADT for proofs, enumerating all possible peano proofs
06:17:56 <lilac> luqui: that would not match my interpretation of your spec.
06:18:09 <Myoma> luqui: If you would like to prove the programs equivalent, what equivalence relation would you use?
06:18:09 <luqui> lilac, then the spec is incorrect.
06:18:18 <lilac> since you have me no semantics for your English spec, it's as correct as I could make it
06:18:27 <ariep> I find it quite miraculous
06:18:28 <Myoma> luqui: I would think bisimulation of the modeled state machine
06:18:35 <Myoma> s
06:18:36 <lilac> *gave
06:18:37 <luqui> Myoma, yep.
06:18:42 <ariep> does ghc see that 'ns !! x == x' ?
06:18:57 <luqui> Myoma, that makes sense to me.  except lilac claims no state machine, instead says a data structure suffices.
06:19:06 <quicksilver> lilac: you fundamentally misunderstand specification.
06:19:22 <lilac> quicksilver: possibly. if so, i'd like to be reeducated :)
06:19:23 <quicksilver> lilac: luqui's example satisfies the spec. It produces the right answer.
06:19:37 <quicksilver> howevr it produces a completely different IO trace
06:19:38 <Myoma> lilac: We can write specifications that boil down to a sound logic
06:19:43 <lilac> quicksilver: a program which produces the right answer but also creates a file /tmp/foo does not satisfy the spec IMO
06:19:47 <quicksilver> this indicates that IO traces are a poor demantics.
06:20:01 <quicksilver> lilac: that's true. But creating IORefs would be fine.
06:20:02 <Myoma> lilac: it is all symbol manipulation, there's need be no ambiguity
06:20:06 <lilac> unless the spec also says "you may create temporary files", which would translate into ... something ... in the ADT domain
06:20:19 <lilac> quicksilver: my semantics for IO exclude IORefs from this ADT model
06:20:21 <quicksilver> ah well now you're getting close.
06:20:26 <quicksilver> ... something ...
06:20:27 <quicksilver> that's *it*
06:20:35 <quicksilver> that's your framework for reasoning about the ADT>
06:20:46 <Myoma> lilac: to say 'you may create temporary files' one could just erase temp files from the equivalence relation
06:20:56 <quicksilver> and once you have that framework, you are moving towards a useful semantics.
06:20:57 <lilac> quicksilver: i'd say the "...something..." is understanding of the English spec
06:21:27 <lilac> it could translate into "you may include OpenFile x elements in your value, if x is of the form "/tmp/" ++ y"
06:22:01 <luqui> lilac, now you have to define "may" "OpenFile" "form".
06:22:05 * Myoma talks to a wall
06:22:07 <luqui> no OpenFile
06:22:09 <luqui> t
06:22:40 <Myoma> hm, rather than inventing a new specification language, why not learn an existing one?
06:22:44 <lilac> luqui: 'may' is trivially definable in terms of recursion down the ADT. 'of the form' is trivially definable in terms of Haskell's semantics
06:22:52 <lilac> and OpenFile is a primitive of IO.
06:23:29 <lilac> what i'm saying is incredibly mundane, i think
06:23:35 <lilac> essentially...
06:23:37 <luqui> lilac, yeah I missed the point with that remark.  What I meant was is that if the answer is 42, these two are both 'correct":
06:23:41 <Myoma> lilac: I think what you are saying is slightly odd
06:23:52 <luqui> Bind (PutStr "4") (const (PutStr "2")) and Bind (PutStr "42")
06:23:52 <lilac> Myoma: possibly.
06:24:01 <luqui> and most of the time, there are infinitely many correct programs.
06:24:05 <luqui> how do you catch them all in a specification?
06:24:23 <Myoma> luqui: they are not structurally equivalent
06:24:24 <lilac> luqui: well, i'd say those are different, actually.
06:24:44 <lightstep> putStr is actually mapM_ putChar
06:24:46 <Myoma> structural equivalence is your equivalence relation?
06:24:47 <lilac> luqui: but i think PutStr is probably not a good primitive. if the primitive is instead PutChar...
06:24:53 <lilac> ... then you have no problem
06:25:02 <lightstep> you can define a normal form for the IO datatype, and have no two programs with the same result
06:25:18 <luqui> lilac, d you claim that there is no problem in all of IO once you do that?
06:25:22 <lilac> luqui: there is still an issue of defining all the IO operations in terms of such primitives, though
06:25:23 <Myoma> lightstep: Is that definitely possible?
06:25:48 <lilac> luqui: i have no proof of that. and not all of IO; I've already excluded the non-RealWorld-interaction bits, remember.
06:25:52 <luqui> lilac, and _also_ giving rules for when the primitives convert to each other
06:25:55 <lilac> luqui: but yes, that's what i'm saying.
06:26:37 <lilac> basically, all i'm saying is that you can assume nothing at all about the behaviour of the outside world
06:27:04 <lilac> Haskell can do nothing to stop me from running your program in a sandbox which does bizarre things
06:27:06 * luqui can assume things
06:27:07 <lightstep> Myoma, i don't see why not. concurrency would be slightly hard, and you can choose stupid semantics for the scheduler that can make this work
06:27:25 <lilac> luqui: i think you can assume things because you're not actually modeling a haskell program
06:27:31 <lilac> you're modelling the composition of multiple programs
06:27:42 <lilac> and that i think is a much simpler question to think about.
06:28:05 <Myoma> lightstep: Yeah, that's true.  I have no idea how to model concurrency
06:28:16 <luqui> lilac, so you're saying that a haskell compiler would be correct if it produced a program that said "Fuck You" for input main = putStrLn "Hello, World"
06:28:39 <lilac> luqui: please to be defining what you mean by "said \"Fuck You\""
06:29:09 <luqui> lilac, alright.  that is imprecise.
06:29:11 <lilac> for that program it must produce something trivially equivalent to PutStr "Hello, World"
06:29:19 <lilac> but it's not producing a program
06:29:26 <lilac> it's producing an IO action
06:29:30 * Myoma would be very upset if a haskell compiler did that!
06:29:31 <luqui> lilac, trivially are you sure?
06:29:53 <lilac> the act of translating that into a binary is outside the semantics in my opinion
06:30:07 <luqui> lilac, a haskell compiler would *not* be correct if it performed some very clever optimizations that gave the same result?
06:30:18 <luqui> (external, real world result, not data structure)
06:30:26 * lilac retracts the word 'trivially'
06:30:36 <luqui> lilac, so what do I mean by same then?
06:30:40 <lilac> it must be equivalent in terms of the denotational semantics of pure haskell values
06:30:53 <luqui> how do we know that the optimizations were correct?
06:31:05 <lilac> the denotational semantics of pure haskell values
06:31:12 <Myoma> lilac & luqui: It seems to me you both just need to define an equivalence relation and everything drops out of that
06:31:26 <lilac> Myoma: i think i agree.
06:31:26 <luqui> Myoma, alright.
06:31:50 <Myoma> (perhaps not a _single_ equvalence, maybe a class of them,..)
06:31:54 <luqui> I guess the disagreement is that lilac is fine with a trivial equivalence relation
06:32:13 <lilac> the point of the ADT is to excape from the world of side-effects into the world of pure values, for which we already have a semantics.
06:32:16 <quicksilver> personally I think the point is defining this equivalence realtion.
06:32:18 <quicksilver> it's *HARD*
06:32:19 <luqui> two programs that produce identical observable results needn't be equivalent.
06:32:35 <luqui> whereas for my semantics they need to be.
06:32:36 <quicksilver> and definition this equivalence relation is what conal and I mean by 'giving semantics to IO'
06:33:02 <lilac> luqui: the point is that the primitives of the IO ADT are exactly the observable results
06:33:03 <Myoma> lightstep suggested it could be a structural equality on a simple data type
06:33:14 <desp> @src makeTokenParser
06:33:14 <lambdabot> Source not found.
06:33:15 <luqui> lilac, not to me
06:33:15 <lilac> Myoma: that's what i've been suggesting all along
06:33:20 <luqui> lilac, my semantic domain is not an ADT
06:33:26 <Myoma> It may be possible, I'm not sure? but that would be a very nice way to do it
06:34:03 <lilac> luqui: are you saying that you can't express the set of observable actions as an ADT?
06:34:05 <Myoma> you may want to loosen it up a bit sometimes though
06:34:22 <luqui> lilac, I could with some laws.
06:34:30 <luqui> lilac, some very, very compilcated laws.
06:34:44 <conal> more complicated that that, even
06:34:51 <lilac> luqui: i think that's the fundamental point of disagreement between us then
06:34:53 <Myoma> lilac: Do you have a precise enough idea about it to put down some code?
06:35:05 <lilac> Myoma: quite possibly.
06:35:15 <Myoma> lilac: It maybe worthwhile to repeat some of the proofs in the paper I mentioned with it
06:35:35 <luqui> lilac, like I said, I think the difference is that you do not consider the programs putStr "foo" >> putStr "bar"  and putStr "foobar" equivalent (given the PutStr interpretation)
06:35:36 <Myoma> in the best case, they would be extremely easy -- that may be an indication of success :)
06:35:39 <luqui> whereas I do
06:35:39 <lilac> Myoma: i think i'd want to pull it back a level, to the point of saying the observable behaviour is defined in terms of some structure of FFI function calls
06:35:50 <luqui> so my semantic domain must capture that, and yours doesn't need to
06:36:25 <lilac> luqui: if putStr x translates into a C function call to write(x, strlen(x)) then I'd say they are obserably different.
06:36:28 <Myoma> lilac: with which you could implement IO (and maybe other things too)?
06:36:31 <lightstep> this can be simpler i think. it you take a filesystem monad, and have a monad transformer for each imported ffi function, and wrap it in a state monad transformer and exceptions transformer, you have a much more basic set of actions to analyse
06:36:36 <lilac> Myoma: yes.
06:36:43 <_zenon_> Hm... I'm trying to combine Writer with Reader, and figured it might be nice with WriterT, however I get kind error
06:36:46 <luqui> lilac, I wouldn't.
06:36:52 <BeelsebobWork_> lilac: really? why?
06:36:53 <_zenon_> WriterT [String] (Reader [Propos]  Bool)
06:36:54 <_zenon_>  ?
06:37:01 <Myoma> I see, that sounds good
06:37:02 <Deewiant> ?kind WriterT
06:37:03 <lambdabot> * -> (* -> *) -> * -> *
06:37:04 <lilac> luqui: if i run your program with an LD_PRELOAD which replaces write(), i can see the difference.
06:37:05 <luqui> because thinking of programs in terms of FFI calls doesn't allow me to reason about them.,
06:37:36 <Deewiant> _zenon_: WriterT [String] (Reader [Propos]) Bool, I think
06:37:39 <lilac> luqui: that's the point, i think. i don't think you can reason about them in isolation
06:37:40 <Deewiant> _zenon_: but why not just use State?
06:37:52 <lilac> luqui: but you *can* reason about the composition of your program, libc and a kernel
06:37:54 <_zenon_> Deewiant, because I'm into Writer right now
06:37:58 <luqui> lilac, so therefore you are being *very* specific about what you want your compiler to do
06:38:03 <dmwit_> Deewiant: State is not lazy enough.
06:38:05 <Myoma> lightstep: Would you really need lots of transformers, as opposed to just putting the set of available FFI calls in the type of the filesystem monad perhaps?
06:38:08 <luqui> lilac, you do not allow a compiler to replace the two calls with a single one.
06:38:12 <_zenon_> Deewiant, yeah, that's it, thanks
06:38:17 <Deewiant> dmwit_: it's not?
06:38:20 <lilac> luqui: that's right. i'm giving precise semantics.
06:38:38 <dmwit_> Deewiant: Right.  You can't read any part of the [] state until the entire computation is done.
06:38:38 <Myoma> luqui: What the compiler does is its buisness, the semanicts may be different
06:38:50 <quicksilver> Deewiant: Writer + Reader is a lot different from state.
06:38:51 <luqui> lilac, well ghc does things like that, so you probably shouldn't use it
06:38:52 <BeelsebobWork_> lilac: I believe the point is that luqui wants a semantics in which the compiler is allowed to d othat
06:39:04 <Myoma> i.e reading a file might do it in a few 1024 slurps, but the semantics are still ReadChar >> ReadChar ...
06:39:11 <Deewiant> dmwit: oh, didn't know that.
06:39:13 <lilac> luqui: i suspect that putStr is not implemented as a single call to write.
06:39:24 <lightstep> Myoma, i think so, it you want to talk about equivalence of programs that use a different set of ffi functinos
06:39:26 <lilac> Myoma: that's actually covered by the semantics for pure Haskell
06:39:39 <BeelsebobWork_> lilac: the thing is you're essentially giving the semantics "the result is whatever the implementation makes the result be"
06:39:46 <dmwit> Deewiant: Also: what quicksilver said. =)  (You can't read what you wrote in a WriterT Reader.)
06:39:50 <BeelsebobWork_> which isn't a very useful semantics to compare your implementation with
06:39:54 <quicksilver> Deewiant: Writer + REader allows you to specify 'this bit is read-only and this bit is append-only'
06:39:55 <lilac> BeelsebobWork_: no, i'm trying to define what the implemnetaion should make the result be.
06:40:11 <quicksilver> Deewiant: where as State says 'all of this is random access read/write'
06:40:12 <Myoma> I am just saying there are various correct operational meanings to some semantics, and thinking about _those_ makes life hell
06:40:14 <Deewiant> dmwit, quicksilver: heh, good point, should have realized that.
06:40:19 <quicksilver> Deewiant: so, it's a tighter specification.
06:40:32 <Myoma> it doesn't matter if the x or y in (x,y) gets evaluated first
06:40:41 <quicksilver> Deewiant: Reader and Writer can both be implemented by State, but they are more limited types.
06:40:46 <BeelsebobWork_> lilac: in that case your semantics are very inflexible -- because they don't for example allow a compiler to replace putStr "foo" >> putStr "bar" with putStr "foobar" even though in most peoples semanticies it's entirely valid
06:40:52 <quicksilver> and of course limited is useful for theorem proving.
06:40:56 <lilac> anyway, this discussion has been fun. if i get time, i'll try to put some code together to demonstrate what i mean. but i need to get back to work now :)
06:41:08 <lilac> BeelsebobWork_: it depends on how putStr is specified
06:41:15 <quicksilver> BeelsebobWork_: which in fairness, is still a valid choice. But it's a surprising one.
06:41:17 <_zenon_> quicksilver, That's why I'm using Writer + Reader
06:41:22 <luqui> lilac, we're wondering how that is.
06:41:23 <lilac> if it is specified as appending to a buffer, then it allows that
06:41:27 <Myoma> lilac: cool, I hope to see it eventually :)
06:41:30 <quicksilver> A typical goal of a semantics is to maximise the number of equivalences.
06:41:31 <BeelsebobWork_> quicksilver: absolutely, I was pointing out why luqui wanted a different semantics
06:41:36 <luqui> lilac, *now* you are starting, finally, to give a semantics
06:41:40 <lilac> Myoma: no promises, though. i have a list of projects as long as my arm
06:41:55 <luqui> lilac, assuming a buffer is a mathematical object of some sort
06:41:57 <Myoma> that's not very long :p
06:42:00 <lilac> luqui: no, i'm changing my semantics to be more flexible
06:42:00 <luqui> which has associativity
06:42:19 <lilac> because my original semantics was not sufficiently flexible to allow optimizations you wanted
06:43:15 <luqui> lilac, alright.  the problem is doing that for all of IO, for all the optimizations, say, ghc does
06:43:29 <luqui> (plus maybe some more that ghc hasn't thought of yet)
06:43:33 <lilac> luqui: who says that GHC is doing only permitted optimizations?
06:43:33 <luqui> so that we can prove ghc is correct
06:43:51 <luqui> yes I see your formality
06:43:51 <Myoma> don't bother proving ghc correct :|
06:43:59 <luqui> Myoma, :-P
06:43:59 <Myoma> that will take longer than a week
06:44:15 <luqui> lilac, and I understand that being pedantic is fun :-)
06:44:31 <lilac> luqui: yes, sorry if i've been annoying or overly stubborn
06:44:53 <luqui> lilac, anyway, you do see our beef with IO anyway don't you?
06:45:17 <lilac> you want to imbue it with all sorts of properties which allow various optimizations
06:45:38 <lilac> i don't think it has those properties
06:45:44 <luqui> lilac, well, no.  we want to replace it with something that has a simple, easy-to-reason about semantics
06:45:58 <luqui> so that we can do all sorts of optimizations and prove they are correct
06:45:59 <lilac> i suggested something, which you disagreed with because it didn't allow optimizations
06:46:29 <lilac> i don't think you're arguing that my suggestion is not a valid approach for forming a semantics.
06:46:45 <BeelsebobWork_> lilac: I think he's arguing that it's not a useful one
06:46:47 <lilac> merely that it's not the sementics you want.
06:47:15 <luqui> lilac, yep.  not simple, fails to capture any fundamental (a subjective term) correspondences in the target domain
06:47:16 <lilac> BeelsebobWork_: sure. nonetheless, i think it is maximally useful without being too vague
06:47:28 <luqui> lilac, maximally?
06:47:50 <lilac> luqui: the revised semantics in terms of external function calls, yes.
06:47:55 <BeelsebobWork_> lilac: which reinforces my suspicion that there is *no* useful semantics for IO
06:47:58 <BeelsebobWork_> because that one isn't useful
06:48:02 <BeelsebobWork_> and you can't get more useful
06:48:12 <lilac> but i'll write this down somewhere and try to come up with an intuitive proof
06:48:23 <luqui> lilac, but BeelsebobWork_ is getting at the issue
06:48:41 <luqui> it's not that your semantics for IO aren't good for IO, it's that IO probably doesn't have *any* good semantics
06:48:42 <lilac> i completely agree with what e just said
06:48:44 <luqui> for our definition of good
06:49:17 <lilac> but the problem isn't "make good semantics", it's "make correct semantics which are as good as possible"
06:49:19 <quicksilver> BeelsebobWork_: I am convinced that there are useful semantics for all kinds of sub-monads of IO
06:49:29 <quicksilver> BeelsebobWork_: and that partitioning IO in this way would be worthwhile effort.
06:49:31 * mmorrow just figured out how to hijack haskell stdout with createPipe + modifyMVar_
06:49:33 <BeelsebobWork_> quicksilver: possibly of sub-monads
06:49:44 <luqui> lilac, well, no, that wasn't my problem.  my problem was "come up with an alternative to IO that has good semantics"
06:49:52 <luqui> (or show that IO has good semantics)
06:49:59 <lilac> luqui: ah, ok then. that's a different problem :)
06:50:01 <quicksilver> BeelsebobWork_: giving semantics to arbitrary FFI calls requires understand the semantics of that library.
06:50:05 <Twey> mmorrow: How?  *curious*
06:50:08 <quicksilver> BeelsebobWork_: which is not something you can do 'abstractly'
06:50:09 <_zenon_> quicksilver, geesh, I feel I need to read more on Monadtransformers, got a good link?
06:50:19 <quicksilver> BeelsebobWork_: it's a job you have to do afresh for each new lib.
06:50:25 * lilac -> work
06:50:29 <luqui> lilac, in fact, your semantics for IO would make a fine semantics for the FFI monad
06:50:30 <quicksilver> BeelsebobWork_: so embedding all arbitrary FFI in IO is a problem ;)
06:50:31 <BeelsebobWork_> quicksilver: sure it is -- if the library actually does have abstract semantics
06:50:31 <_zenon_> quicksilver, I feel the "All about monads" monadtransformer examples get too complex when they involve continuation etc.
06:50:35 <luqui> lilac, okay I will stop distracting you
06:50:37 <BeelsebobWork_> quicksilver: for example, (+) is an FFI call
06:50:48 <quicksilver> BeelsebobWork_: hmm. by 'abtractly' I mean 'without reference to the library in quesiton'
06:50:49 <Twey> @src (+)
06:50:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:50:52 <Twey> Heh
06:50:55 <quicksilver> BeelsebobWork_: perhaps a poor choice of words.
06:51:03 <BeelsebobWork_> it still has nice semantics (modulo overflow etc)
06:51:12 <Axman6> awww, i just got all this RAM, and then found out that by making my program non-strict, it gets a lot faster (this originaly wasn't the case), and uses very little RAM. used to use heaps
06:51:17 <quicksilver> BeelsebobWork_: I mean you can't give useful semantics to "foreign import 'quicksilver'"
06:51:24 <quicksilver> BeelsebobWork_: until I tell you waht quicksilver() does.
06:51:28 <BeelsebobWork_> quicksilver: oh, sure, yes
06:51:31 <Twey> Axman6: *blink* By making it lazy?
06:51:40 <Axman6> yeah
06:51:52 <Twey> Huh
06:51:55 <quicksilver> BeelsebobWork_: so, we can't have a "once and forall" semantics for IO, on account of it being extendable by FFI.
06:52:00 <Twey> It was all strict before?
06:52:05 <BeelsebobWork_> quicksilver: but that's saying essentially "[[foreign import x]] == [[x]]"
06:52:06 <Axman6> and doing stuff in parallel actually works when it's lazy
06:52:13 <luqui> BeelsebobWork_, it has nice semantics, overflow modulo 2^32 :-)
06:52:17 <BeelsebobWork_> but that usually we don't know what [[x]] is
06:52:17 <quicksilver> BeelsebobWork_: but it would be very interesting work to give semantics to the MVar-fragment, or the OpenGL fragment, etc etc.
06:52:17 <Twey> Heh, aye
06:52:40 <quicksilver> BeelsebobWork_: and many practical programs will use just a few small fragments.
06:52:46 <BeelsebobWork_> quicksilver: plausable, yes
06:52:55 <Axman6> originally it was lazy, and bloated massivly, so i made it strict to reduce bloat, and it ran faster too, now it runs in 4MB when it's lazy, and very fast comparitively
06:52:56 <BeelsebobWork_> although I don't think OpenGL has any nice semantics
06:53:04 <BeelsebobWork_> not in it's current state at least
06:53:21 <_zenon_> Anyone?
06:53:33 <_zenon_> A good link on using monadstransformers (and not the all about monads)
06:53:40 <quicksilver> BeelsebobWork_: sometimes I will settle for tractable. If nice isn't available. ;)
06:53:53 <BeelsebobWork_> quicksilver: maybe, I'm not so sure I'm so willing to settel
06:53:53 <luqui> _zenon_, hmm.
06:53:55 <BeelsebobWork_> settle*
06:54:04 <BeelsebobWork_> I'd rather often just look for something that does have a nice semantics instead
06:54:29 <quicksilver> ;)
06:54:30 <luqui> _zenon_, I learned from experience with pugs.  do you have a question about them?
06:54:35 <quicksilver> that's a reasonable decision, BeelsebobWork_
06:54:41 <quicksilver> but I want to write programs which work, today.
06:54:43 <quicksilver> and openGL works, today.
06:54:55 <_zenon_> luqui, mostly the syntax
06:55:01 <BeelsebobWork_> quicksilver: true, which is why I put up with using OpenGL -- but try to push it as far to the outside as possible
06:55:02 * luqui too!  stupid reactive with it's stupid insanely subtle implementation
06:55:12 <quicksilver> and I'd like to take small steps towards improving my programs by imposing bits of compositionality and tructure where I can.
06:55:16 <swiert> _zenon_ have you seen: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.pdf
06:55:17 <luqui> _zenon_, what syntax?  they're just types.
06:55:23 <lambdabot> Title: Monad Transformers Step by Step
06:55:38 <_zenon_> luqui, how do I write the code? I've never used them. Need to see some examples really.
06:55:56 <luqui> _zenon_, ah okay.
06:56:15 <swiert> _zenon_ or maybe the Paul Hudak paper on Modular Interpreters.
06:56:21 <_zenon_> luqui, I'm trying to use     WriterT (Reader [Propos]) Bool
06:56:35 <_zenon_> but don't get the syntax right I belive.
06:56:38 <BeelsebobWork_> luqui: you're getting less keen on reactive?
06:56:54 <luqui> _zenon_, WriterT needs another argument
06:57:03 <quicksilver> luqui: would you be interested to see my implementation, as a comparison?
06:57:12 <luqui> quicksilver, yes!
06:57:24 <_zenon_> luqui, WriterT [String] (Reader [Propos]) Bool
06:57:36 <luqui> _zenon_, okay.  mostly what you need to know is in the "lift" function
06:57:42 <_zenon_> luqui, just missed it when typing, however, now I want to use it properly.
06:57:50 <BeelsebobWork_> quicksilver: I haven't seen your implementation in the post yet
06:57:53 <BeelsebobWork_> can I see too?
06:57:55 <luqui> _zenon_, lift :: Reader [Propos] a -> WriterT [String] (Reader [Propos]) a
06:58:11 <quicksilver> BeelsebobWork_: I did copy you on the email...
06:58:13 <luqui> (it's much more general than that, of course)
06:58:19 <quicksilver> BeelsebobWork_: but, it's changed since then.
06:58:26 <BeelsebobWork_> quicksilver: hmm, arse, I wonder if my spam filter has jumped it
06:58:30 <quicksilver> now, where is that big hpaste without the line limit
06:58:43 <BeelsebobWork_> quicksilver: what's your email?
06:58:45 <_zenon_> luqui, okay, thanks. I'll see where I get with this.
06:59:01 <quicksilver> foudn it
06:59:39 <BeelsebobWork_> cool, found it quicksilver
06:59:41 <luqui> _zenon_, also tell and ask both Just Work in this monad, because of the MTL's typeclass magic
06:59:54 <luqui> so you might not even need lift
07:00:07 <_zenon_> luqui, hm,, okay, but I want to, want to make it properly :)
07:00:07 <luqui> (and local)
07:00:13 <_zenon_> "properly" <--- ""
07:00:20 <quicksilver> luqui: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=36#a36
07:00:31 <luqui> _zenon_, what do you mean?
07:00:46 <quicksilver> luqui: the reactive impl starts about 2/3 of the way down.
07:00:48 <quicksilver> erm 1/2
07:00:50 <quicksilver> 1/3!
07:00:52 <quicksilver> damn fingers.
07:01:21 <_zenon_> luqui, I want to use the lift etc as "expected" if you have monadtransformers,
07:01:49 <luqui> quicksilver, it looks like you just replaced Future
07:01:53 <quicksilver> luqui: right.
07:01:56 <luqui> good, that was the source of the most pain :-)
07:02:07 <quicksilver> luqui: well there are some subtle details in my choice of implementation on the others.
07:02:09 <BeelsebobWork_> quicksilver: I think my first observation is that because of the limited field of your input events it really doesn't show off what Reactive has over interact :P
07:02:28 <quicksilver> luqui: not because I made a concious decision to discard conal's implementation.
07:02:37 <quicksilver> luqui: I implemented this independently as an exercise
07:02:45 <quicksilver> (and I gave up and copied some of the high-level stuff ;)
07:02:47 <_zenon_> luqui, you get what I mean?
07:02:54 <luqui> quicksilver, sure.  I implement about one reactive library a week...
07:02:59 <_zenon_> luqui, train hard , fight easy
07:03:04 <quicksilver> BeelsebobWork_: yes. They are very simple examples
07:03:08 <quicksilver> BeelsebobWork_: jsut interactive tests.
07:03:19 <quicksilver> BeelsebobWork_: I have it sufficiently well working I'm about to try something more interesting with it :)
07:03:26 <luqui> _zenon_, what's expected is just to use ask and local and tell as they have been overloaded
07:03:31 <BeelsebobWork_> quicksilver: shiny :)
07:03:44 <quicksilver> BeelsebobWork_: rewriting my existing particles fire simulation.
07:03:50 <luqui> _zenon_, their usage is very simple, really.  it's like you have a monad with capabilities of both Reader and Writer
07:03:53 <quicksilver> BeelsebobWork_: Behaviour [Particle] is much prettier than my existing hack.
07:03:58 <BeelsebobWork_> :)
07:04:03 <quicksilver> BeelsebobWork_: (which couples simulation speed to frame rate, apart from anything else)
07:04:08 <BeelsebobWork_> oh, lame
07:04:08 <_zenon_> luqui, hm, okay, but It's not a type error lifting
07:04:42 <luqui> quicksilver, what are the two actions in IOFuture?
07:04:58 <quicksilver> luqui: a blocking and non-blocking read
07:05:11 <quicksilver> luqui: either get the value by waiting for it, or just get if its available.
07:05:24 <quicksilver> luqui: I prefer this (currently) to conal's approach of hiding blocking values in pure code.
07:05:38 <quicksilver> luqui: I may come round to his approach when I understand the design space better.
07:05:54 <luqui> quicksilver, yes.  I mostly don't like that because it's using a nonexistent corner of haskell's semantics
07:06:07 <luqui> namely the semantics of blocking thunks... which require a different domain model
07:06:09 <quicksilver> luqui: I argue it's using a corner of GHC semantics
07:06:16 * RayNbow blinks @ http://www.reddit.com/r/haskell/comments/70mz9/gat_a_git_clone_in_haskell/ ...
07:06:21 <lambdabot> Title: gat, a git clone in haskell : haskell, http://tinyurl.com/62utp5
07:06:21 <quicksilver> luqui: admittedly, a fairly natural implementation choice
07:06:25 <quicksilver> luqui: but not obviously the only one.
07:07:35 <quicksilver> luqui: also my implementation does appear to work :) although I don't have proper tests like conal does.
07:07:46 <luqui> quicksilver, yay work!
07:08:00 <quicksilver> luqui: but those example programs test simultaneity and things like that. I know they do, because I found bugs in simultaneity when writing them...
07:08:15 <quicksilver> luqui: I like the explicit 'Always Never' too.
07:08:31 <quicksilver> luqui: this enables never-occurring events to be garbage collected
07:08:38 <luqui> quicksilver, those are in conal's also
07:08:45 <luqui> as MaxBound and MinBound
07:08:45 <quicksilver> luqui: instead of hanging around like a bad smell at the edge of the 'mappend'.
07:08:55 <quicksilver> luqui: yes, he implemented them in the Time instead of in the Future.
07:09:03 <quicksilver> my way seemed more obvious to me.
07:09:41 <luqui> quicksilver, quite.  improving, unamb, etc.  all very pretty, but very subtle...
07:10:31 <luqui> quicksilver, is your Event a monad?
07:10:43 <quicksilver> luqui: I didn't make it one.
07:10:49 <quicksilver> but alwaysE and joinE are there.
07:10:58 <quicksilver> I was taking a minimal approach.
07:11:00 <luqui> quicksilver, do they satisfy the monad laws?  conal's don't.
07:11:13 <quicksilver> I only added instances when I could see the justification for the classes existance.
07:11:18 <luqui> (it's a semantic bug we're trying to work out :-)
07:11:34 <quicksilver> event doesn't 'feel like' a monad to me
07:11:41 <quicksilver> although joinE is definitely useful.
07:11:49 <quicksilver> (necessary to implement filterE)
07:11:56 <quicksilver> also I hate these stupid suffixes :P
07:12:00 <quicksilver> although I've adopted them for now.
07:12:12 * luqui too :-)
07:12:21 <mmorrow> just got a haskell interpreter working similar to ghci (uses the GHC-API), which keeps state across expression evals. http://code.haskell.org/~morrow/eva/
07:12:21 <lambdabot> Title: Index of /~morrow/eva
07:12:32 <mmorrow> Twey: how to do so is in there ^^^
07:12:41 <quicksilver> luqui: my test for monadness: do { a <- ev1; b <- ev2 a; return (a,b) }
07:12:50 <_zenon_> Why is the Reader monad page on hoogle so unstructured?
07:12:50 <mmorrow> and is easily customizable
07:12:56 <quicksilver> luqui: if this expression doesn't make useful sense, it probably isn't a monad.
07:13:01 <_zenon_> A lot of examples instead of functions defined?
07:13:06 <luqui> quicksilver, liftA2 (,) ?
07:13:08 <Myoma> mmorrow :(
07:13:09 <Myoma>     Could not find module `PackageConfig':
07:13:09 <Myoma>       it is a member of package ghc-6.9.20080615, which is hidden
07:13:13 <Myoma> what do I do?
07:13:16 <quicksilver> luqui: no, "a" is passed as a parameter to ev2
07:13:17 <Twey> mmorrow: Ack, can't use the Web at the moment
07:13:18 <luqui> oh, no there's an extra a in there
07:13:31 * Twey tries to remember to check it later
07:13:37 <quicksilver> luqui: but also, I agree: since Applicative doesn't seem useful for Events, Monad is unlikely too.
07:13:41 <Myoma> I will wait for 6.10
07:13:45 <Myoma> then hopefully everything will work
07:13:52 <quicksilver> luqui: of course Applicative makes excellent sense for Reactive
07:13:55 <quicksilver> and this is interesting.
07:13:56 <mmorrow> Twey: crappy. hold on a sec.
07:14:11 <quicksilver> Two such tightly coupled types, and yet Applicative makes sense for one and not the other.
07:14:12 <luqui> quicksilver, I've always programmed in FRP with Event (different semantics) doing most of the heavy lifting
07:14:30 <Twey> mmorrow: It's OK, I can read it in half an hour or so
07:14:40 <quicksilver> luqui: I have a very practical approach. I need to (try to) write real programs
07:14:47 <quicksilver> to inform my opinion about things.
07:14:56 <quicksilver> hence my goal to port some existing code to Reactive.
07:15:39 <luqui> quicksilver, well, I like you implementation for working.  although I am still not sure about the *semantics* of Event...
07:15:49 <luqui> want to kill it.
07:15:54 <luqui> but not sure how to regain its expressivity.
07:16:29 <luqui> anyway, yeah, I'm supposed to be building a UI library on top of reactive, so I'll use yours (because it works)
07:17:02 <quicksilver> luqui: you can consider all the code freely licensed under any terms.
07:17:07 <quicksilver> I should have put that on it, really.
07:17:14 <luqui> oh boy public domain!
07:17:27 <quicksilver> I think I have signed something which freely licenses anything I post on the wiki, the -cafe, or hpaste :)
07:17:40 <ariep> does anyone have an idea about my question?
07:17:45 <quicksilver> so if it's useful, take it, butcher it, as you will.
07:17:59 <quicksilver> ariep: I didn't see your question.
07:18:14 <quicksilver> ah well.
07:22:28 <luqui> quicksilver, have you tested the canonical memory leak example: let b = integral b in b
07:23:30 <luqui> oops gtg
07:23:38 <ziman> :t integral
07:23:39 <lambdabot> Not in scope: `integral'
07:24:32 <profmakx> ziman  Integral is a type class
07:24:39 <ariep> quicksilver: sorry, my connection dropped
07:25:00 <ariep> i'm wondering why this finishes so quickly:
07:25:24 <ariep> > let ns = 0 : map succ ns in length . show $ ns !! 10^1000
07:25:25 <lambdabot>   1001
07:25:42 <mmorrow> Myoma: oh, uhoh. hmm.
07:25:52 <Myoma> > let ns = 0 : map succ ns in length . show $ ns !! (10^1000)
07:26:00 <lambdabot>   1
07:26:05 <mmorrow> Myoma: what cabal version do you have?
07:26:12 <Myoma> > let ns = 0 : map succ ns in length . show $ (ns !! 10)^1000
07:26:13 <lambdabot>   1001
07:26:29 <idnar> > 10 ^ 1000
07:26:31 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
07:26:47 <ariep> ah, silly me
07:27:33 <quicksilver> profmakx: luqui's integral was not a type-class ;)
07:28:42 <Twey> :t fromIntegral
07:28:43 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:29:06 <quicksilver> mmorrow: sometimes I get weird answers from moonpatio
07:29:13 <mmorrow> Myoma: weird, that must have changed in the month between my ghc version and your ghc version
07:29:22 <Myoma> mmorrow: oh well
07:29:33 <mmorrow> quicksilver: uhoh. what kind of weird answers?
07:29:38 <Myoma> mmorrow: for some reason I think that GHC 6.10 will fix everything
07:29:52 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
07:30:02 <quicksilver> "readUTF8Char: illegal UTF-8 character 248"
07:30:24 <mmorrow> Myoma: all you need to do is find where   PackageIdentifier, Version, and mkPackageId  are
07:31:08 <mmorrow> quicksilver: odd. that happens when you just go the the front-page?
07:31:25 <mmorrow> quicksilver: oh crap. ok
07:31:51 <quicksilver> mmorrow: it first happened when I tried to paste somesthing
07:31:54 <mmorrow> quicksilver: i think that happens to hpaste2 when it gets a weird char in a title/author. i'll zap it.
07:31:58 <quicksilver> mmorrow: now it happens on the front page
07:32:03 <quicksilver> I'm sorry if I broke it ;)
07:32:04 <mmorrow> i've done that before on my local one.
07:32:12 <mmorrow> quicksilver: heh, no worries. bug!
07:40:43 <mmorrow> quicksilver: ok, works now. i'm not sure how it's happening, but sometimes hpaste2'll put garbage into the author/title fields, which makes it barf
07:41:25 <mmorrow> that's probably exploitable somehow (uhoh), but oh well
07:41:38 <quicksilver> odd
07:41:42 <Twey> Not really
07:41:56 <mmorrow> it uses an sqlite3 db as its store
07:42:07 <Twey> What're they going to do, use XSS to steal cookies?  Ooh, vital info stored there :-P
07:42:14 <mmorrow> heh
07:42:15 <inimino> I upgraded ByteString, and now my project won't compile
07:42:28 <BeelsebobWork_> inimino: with what error?
07:42:35 <mmorrow> Twey: ok god, i feel better now
07:42:39 <mmorrow> s/god/good/
07:42:58 <inimino> "no package matching bytestring-0.9.0.1 was found"
07:43:03 <quicksilver> inimino: you ahve to upgrade all other libs you have which depend on bytestring
07:43:15 <quicksilver> where 'upgrade' may just mean 'recompile'
07:43:17 <dcoutts_> inimino: sounds like you unregistered a package that others still depended on
07:43:21 <quicksilver> you don't necessarily need different versions.
07:43:30 <quicksilver> dcoutts_: he upgraded bytestring.
07:43:31 <dcoutts_> inimino: ghc-pkg check will tell you about broken packages
07:43:38 <quicksilver> dcoutts_: I'm betting he has other packages which depend on the old bytestring
07:43:38 <dcoutts_> quicksilver: but removed the old one
07:43:42 <inimino> dcoutts: ok, I'll try that
07:43:54 <quicksilver> dcoutts_: cant you get this message just because the old one is hidden
07:43:55 <quicksilver> ?
07:44:06 <dcoutts_> quicksilver: no, different message
07:44:29 <inimino> before I uninstalled the old bytestring I got a different error message
07:44:34 <inimino> much more bizarre
07:44:37 <dcoutts_> inimino: type error matching ByteString against ByteString ?
07:45:34 <inimino> dcoutts: yes
07:45:52 <dcoutts_> inimino: see the thing is, you had (until you removed the old one) two instances of the bytestring package. That's fine, but within a single program you only want one, because 0.9.0.1:ByteString is not the same type as 0.9.0.4:ByteString
07:46:12 <dcoutts_> inimino: so basically, half your packages were using the old and half the new
07:46:19 <inimino> so ghc-pkg check shows lots of missing dependencies on the old one
07:46:21 <dcoutts_> and so they're different types and will not work together
07:46:33 <dcoutts_> inimino: the solution is to rebuild packages using one version or the other
07:46:41 <inimino> dcoutts: was there an easier way to do that?
07:46:42 <dcoutts_> inimino: which is exactly what cabal install can do for you
07:47:29 <dcoutts_> inimino: if you run "cabal install --dry-run" in your project dir, it'll tell you what packages it needs to re-install to get a consistent set of dependencies
07:47:50 <inimino> ok
07:48:12 <dcoutts_> basically it'll say it'd rebuild a bunch of packages using the more recent bytestring (unless it turns out a consistent solution is impossible)
07:48:24 <inimino> there's no cabal file in there so it doesn't say much ;-)
07:48:30 <mmorrow> dcoutts_: how would one go about constructing a PackageId in the current ghc-HEAD
07:48:30 <dcoutts_> inimino: ah
07:48:31 <mmorrow> ?
07:49:03 <dcoutts_> mmorrow: either by parsing or direct construction using PackageIdentifier (PackageName "Foo") (Version [1,0] [])
07:49:18 <mmorrow> perfect, thanks
07:49:18 <inimino> apparently ghc depended on the old bytestring, so I guess I'll have to recompile that or re-install the old bytestring?
07:49:34 <dcoutts_> mmorrow: parsing using simpleParse "foo-1.0" :: Maybe PackageIdentifier
07:50:28 <dcoutts_> inimino: it's generally unwise to unregister packages that ghc came with since you cannot guarantee to rebuild it and get the same ABI that existing packages depend on, and in particular you cannot rebuild the ghc api package
07:50:48 <inimino> dcoutts: I see
07:51:10 <dcoutts_> inimino: so if possible, re-register the old bytestring, if you're using gentoo or debian that's easy, otherwise it's more problematic
07:51:31 <inimino> I'm on debian, so I'll just re-install it
07:51:31 <dcoutts_> inimino: or live with a borken ghc package
07:51:41 <inimino> dcoutts: never ;-)
07:51:54 <mmorrow> dcoutts: err, i'm slightly confused. so in a 6.9 from june, i did  :m + PackageConfig , then
07:51:55 <dcoutts_> inimino: right, you can re-install ghc or you can just re-register the bytestring package
07:52:00 <mmorrow> mkPackageId (PackageIdentifier "base" (Version [] []))
07:52:13 <mmorrow> and there doesn't seem to be a mkPAckageId equivalent
07:52:19 <dcoutts_> inimino: because debian keep a saved copy of the original package.conf as package.conf.shipped
07:52:24 <inimino> oh, unregistering didn't delety any files?
07:52:30 <dcoutts_> inimino: exactly
07:52:34 <inimino> s/delety/delete
07:52:35 <inimino> ok
07:53:08 <mmorrow> dcoutts_: ah, ok. i'm looking to make a Module.PackageId
07:53:21 <mmorrow> and the constructor is hidden
07:53:25 <dcoutts_> inimino: so you should be able to do something like: ghc-pkg -f package.conf.shipped describe bytestring-0.9.0.1 | ghc-pkg register -
07:53:55 <mmorrow> err, actually Module isn't there anymore at all
07:54:06 <dcoutts_> mmorrow: I'm not really sure what you're saying
07:54:31 <dcoutts_> mmorrow: there is no mkPackageId
07:55:19 <mmorrow> dcoutts_: so in the function (newS :: Maybe DynFlags -> IO Session), i need to do what i'm doing with (mkPackageId base) there in a current 6.9: http://code.haskell.org/~morrow/eva/eva.hs.html
07:55:20 <lambdabot> Title: Haskell code
07:57:11 <mmorrow> dcoutts_: so i need to get from a PackageIdentifier to a the first arg of   mkModule :: PackageId -> ModuleName -> Module
07:57:21 <inimino> there's a new version of GHC in debian anyway, so I'll see if that fixes it
07:57:28 <dcoutts_> mmorrow: you must be talking about the GHC api, not Cabal
07:57:39 <mmorrow> dcoutts_: yes, exactly.
07:57:46 <dcoutts_> mmorrow: ok, sorry, I was confused
07:57:50 <mmorrow> dcoutts_: :)
07:58:05 <dcoutts_> mmorrow: I know nothing about the ghc api, though it's got some confusingly similar names and types :-)
07:58:18 <mmorrow> dcoutts_: ah, ok cool. thanks.
08:01:36 <inimino> dcoutts: thanks, GHC is unhorked
08:01:52 <inimino> now i just have to get rid of the type error...
08:02:05 <mmorrow> Myoma: ok, all you have to do is $ sudo ghc-pkg expose ghc
08:02:13 <dcoutts_> inimino: you'll be glad to know that in the next ghc version, ghc-pkg will complain loudly if you try to unregister things that other packages still need
08:02:28 <dcoutts_> mmorrow: that does not sound like good advice
08:02:30 <inimino> dcoutts: that's a good feature :-)
08:02:32 <profmakx> > [9..1]
08:02:33 <lambdabot>   []
08:02:36 <profmakx> gnarf
08:02:40 <mmorrow> dcoutts_: oh, in that case...
08:02:41 <profmakx> *selfslap*
08:02:52 <dcoutts_> mmorrow: it's hidden for a reason, because it exposes module names like "Util"
08:02:58 <mmorrow> Myoma: ok, all you have to do is add "-package ghc" which compiling that
08:03:15 <dcoutts_> mmorrow: that's much better :-)
08:03:18 <mmorrow> dcoutts_: ah, that sounds logical :)
08:03:21 <mmorrow> hehe
08:04:42 <inimino> so "No instance for (Data.String.IsString bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString)"
08:05:33 <dcoutts_> inimino: so this is where you want to make sure all your deps are built with the same bytestring
08:05:36 <inimino> is there a way to make GHC not use 0.9.0.1 when compiling this?
08:06:00 <inimino> dcoutts: ah, I see
08:06:05 <dcoutts_> inimino: if the package you've got doesn't have a .cabal file you can still sort things out, use cabal install --dry-run dep1 dep2 dep3 etc
08:06:15 <inimino> so I can just recompile all dependencies
08:06:16 <inimino> ok
08:06:56 <dcoutts_> inimino: ask it to do them simultaneously though, that way it makes sure it's a consistent set
08:07:45 <dino-> @paste
08:07:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:08:56 <inimino> what's the easiest way to lookup package names from module names?
08:09:03 <mmorrow> quicksilver: in case you didn't see, i zapped your most recent paste in the process of trying to fix it :( (sry)
08:10:45 * BMeph_ was reminded of xkcd when he saw mmorrow's advice for using the ghc package...
08:11:21 <quicksilver> mmorrow: ah ;)
08:11:29 <quicksilver> mmorrow: well I can repaste if anyone wants it.
08:11:36 <dino-> Yay, I deliberately used liftM2 for the first time. And get what's going on. http://hpaste.org/10243
08:11:57 <mmorrow> quicksilver: i wouldn't mind taking a peak ;)
08:12:33 <mmorrow> gah. my ability to spell has gone to zero.
08:12:38 <mmorrow> *peek
08:12:53 <quicksilver> mmorrow: have a summit while you're at it! http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=36#a36
08:12:58 <mmorrow> ha
08:16:11 <Myoma> dino-: >>! = mplus I think
08:16:27 <Myoma> > Nothing `mplus` Just 1
08:16:28 <lambdabot>   Just 1
08:16:30 <Myoma> > Just 33 `mplus` Just 1
08:16:31 <lambdabot>   Just 33
08:17:40 <mmorrow> beforeTheDawnOfTime
08:18:18 <mmorrow> Myoma: did adding -package ghc work for you?
08:18:20 <quicksilver> dino-: I call liftM2 (>>!) 'orElse'
08:18:27 <quicksilver> dino-: it's definitely useful.
08:19:16 <Myoma> mmorrow: I didn't try it
08:19:31 <Myoma> :t liftM2 mplus
08:19:32 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
08:19:56 <Baughn> @instances MonadPlus
08:19:57 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
08:19:59 <Myoma> > liftM2 mplus [Nothing,Just 1,Nothing, Just 2] [Just 3, Just 4, Nothing, Nothing]
08:20:00 <lambdabot>   [Just 3,Just 4,Nothing,Nothing,Just 1,Just 1,Just 1,Just 1,Just 3,Just 4,No...
08:20:10 <Baughn> @src Maybe mplus
08:20:10 <lambdabot> Nothing `mplus` ys = ys
08:20:10 <lambdabot> xs      `mplus` ys = xs
08:20:18 <Myoma> > catMaybes (liftM2 mplus [Nothing,Just 1,Nothing, Just 2] [Just 3, Just 4, Nothing, Nothing])
08:20:19 <lambdabot>   [3,4,1,1,1,1,3,4,2,2,2,2]
08:23:38 <Botje> Myoma++ # two monads in one statement!
08:24:10 <Myoma> yay ao
08:25:45 <moshisushi> plutonas: What the :D
08:26:07 <moshisushi> plutonas: still in Lund?
08:28:42 <dino-> Myoma, quicksilver: Oh, you guys are awesome.
08:28:51 <dino-> This is getting even cooler
08:30:44 <desp> @src the-handling-of-infix-expressions-in-GHC's-pretty-printer
08:30:44 <lambdabot> Source not found. You untyped fool!
08:31:04 <EvilTerran> @source ghc
08:31:04 <lambdabot> ghc not available
08:31:09 <quicksilver> desp: showsPrec ?
08:31:14 <quicksilver> desp: I think that's the key element.
08:31:27 <desp> quicksilver: thanks.
08:31:30 <inimino> whee! my project compiles again! thanks dcoutts
08:31:41 <quicksilver> basically you pass showsPrec the precedence of the enclosing context
08:31:48 <quicksilver> and it either parenthesises itself, or not.
08:32:00 <quicksilver> :t showsPrec
08:32:01 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
08:37:28 <dino-> Curious that mplus has 'xs `mplus` ys = xs' and not 'xs `mplus` _ = xs'
08:37:46 <purestorm> Hi, how can I try a list of ports and use the first one that is free? Network.listenOn seems not to work since it uses reuseAddr...
08:38:03 <quicksilver> dino-: just a quesiton of style, I guess.
08:38:23 <lightstep> quicksilver, why does your future implementation use 2 actions?
08:38:38 <quicksilver> lightstep: because I needed a non-blocking version to support correct mappend.
08:41:08 <lightstep> what was wrong with the original "race" implementation?
08:42:15 <lightstep> in your mappend, very small timing differences can still lead to incorrect results
08:42:34 <lightstep> so is the improvement just that the constant had changed?
08:43:10 <lightstep> (the problem is that nonblockingReadFuture f and nonblockingReadFuture g are not atomic)
08:43:41 <quicksilver> lightstep: how can very small timing differences ever lead to incorrect results in my new version?
08:44:48 <lightstep> nonblockingReadFuture f returns Nothing, then f signals, then g signals, and then nonblockingReadFuture g is called and returned Just *
08:46:54 <lightstep> f was done earlier, but the g result is still chosen. this will only give the wrong result the first time the method is called, afterwards the correct result will be returned
08:46:58 <quicksilver> lightstep: Ah. but my blockingReadFuture is safe, isn't it?
08:47:08 <lightstep> yes
08:47:09 <quicksilver> lightstep: it's only the nonblocking one which is unsafe.
08:47:22 <dino-> Ah! Data.Generics.Aliases.orElse
08:47:36 <quicksilver> lightstep: well, that's an improvement ;)
08:47:56 <quicksilver> lightstep: since it is ultimately the blocking one which gets called to implement Event
08:48:13 <quicksilver> lightstep: so I've managed to produce an implementation which is safe for Events, which was the goal.
08:48:19 <quicksilver> lightstep: but you make an interesting point.
08:48:32 <quicksilver> lightstep: can you see how to fix it?
08:48:58 <dino-> Which I guess looks more like mplus
08:49:52 <dino-> quicksilver: When you said you call liftM2 mplus 'orElse', YM your own name for it?
08:49:57 <lightstep> i think you can only change the case when g is preferred, to check again if f is done
08:50:21 <quicksilver> dino-: yes that's my name.
08:50:31 <quicksilver> dino-: although I proabbly saw it somewhere.
08:50:57 <quicksilver> lightstep: this doesn't feel very elegant :(
08:51:02 <quicksilver> lightstep: there must be a clever way.
08:51:05 <quicksilver> lightstep: STM perhaps?
08:51:25 <dino-> ya, I thought of STM immediately too. Surprised to see that Data.Generics
08:52:09 <lightstep> that would work if it's possible
08:52:33 <lightstep> or you can create a channel, and ask each thread to store the result there, and then read the channel
08:52:58 <quicksilver> how does that help?
08:54:46 <lightstep> if the channel will have exactly noe result, it must be from the thread that finished earlier
08:54:52 <lightstep> s/noe/one/
08:55:13 <quicksilver> but the thread the writes to the channel first is not necessarily the thread that finishes earlier
08:55:22 <quicksilver> that's exactly why my first impl was broken
08:55:38 <quicksilver> and I had to try to patch it with this explicit nonblocking read.
08:57:52 <CosmicRay> dons: you available for a Text.JSON question?
08:57:52 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:01 <lightstep> if you add a new operation to a Future, of type (Chan a -> IO ()), which will push the value if already computed and remember to put the value if it's not computed yet
08:59:39 <lightstep> the only situation that the channel can contain one value (not zero or two) is if one thread signals it but the other didn't yet
09:00:12 <quicksilver> lightstep: right. But the thread which has not signalled may have calculated the result, and had an unlucky context switch just before the putMVar
09:00:30 <quicksilver> lightstep: and furthermore it may actually have done that slightly earlier than the one which has signalled
09:01:01 <lightstep> yes, you're right. maybe you really must have the a guarantee like that of "atomically"
09:01:53 <quicksilver> lightstep: this race is what caused me to change implementation in the first place
09:01:59 <quicksilver> I believed I'd fixed it and in a way I did
09:02:02 <quicksilver> but not properly
09:02:11 <quicksilver> it was surprisingly easy to observe the problem actually :)
09:02:24 <lightstep> how?
09:02:42 <quicksilver> I had genuinely co-incident events
09:02:50 <quicksilver> since they were fmap'ed copies of the same event
09:02:58 <quicksilver> sometimes they arrived in the wrong order
09:04:25 <purestorm> Hm, I have a function that tries to allocate a networks socket and Maybe returns one or Nothing if it could not do this. Somehow, get type mismatches though... could it be the combination of IO and Maybe? http://hpaste.org/10244
09:04:29 <lightstep> if the implementation of Future a was Never | Always a | Fut (Time, a), where the constructor used unsafePerformIO
09:04:34 <quicksilver> lightstep: maybe it is sufficient, but inelegant to check f and g both twice.
09:04:43 <lightstep> you could use the caching of the underlying lazyness system
09:04:57 <quicksilver> lightstep: you'd have the same issue, althought it might be harder to replicate
09:05:08 <quicksilver> lightstep: GHC does not guarantee unique thunk reduction in its threaded rts
09:05:22 <quicksilver> thunks can (occasionally) get reduced twice
09:06:08 <lightstep> anyway, you only need to evaluate f twice (since g would already be evaluated in the problematic case)
09:06:11 <quicksilver> :t catch
09:06:12 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
09:06:38 <lightstep> and the code as it is written will still work, since the blocking wait only calls the unblocking one after at least one thread is done
09:07:04 <quicksilver> purestorm: looks like bindSocket returns () whilst hander returns Maybe Socket
09:07:14 <quicksilver> purestorm: so you're violating the type of 'catch'
09:07:20 <quicksilver> lightstep: hmm, good catch.
09:07:24 <quicksilver> lightstep: thanks for your comments.
09:07:34 <quicksilver> lightstep: I don't lke committing a change like that without being able to test it though.
09:07:51 <quicksilver> lightstep: I need an abstract model of forkIO I can deliberate induce pathological evaluation order in.
09:07:56 <quicksilver> lightstep: to exhibit the bug ;)
09:09:06 <lightstep> if you can get a non-preemptive scheduler, where you control which thread to run next, it's easy
09:09:50 <quicksilver> lightstep: yes, I would want a controllable scheduler
09:10:01 <quicksilver> lightstep: which I can feed the desired thread-trace to and exhibit the problem.
09:10:31 <purestorm> quicksilver: Thanks.
09:10:34 <quicksilver> lightstep: for a similar problem where the issue was seeking into large files, I was able to build an abstract model of file seeking using StateT (Int,ByteString) and put my tests there.
09:10:35 <lightstep> or you can put a ten-second sleep in mappend
09:10:47 <quicksilver> lightstep: that's harder to build into a test case ;)
09:10:48 <lightstep> since it shouldn't matter
09:10:50 <quicksilver> but yeah.
09:11:19 <dblazakis> i installed lambdabot with cabal install and it doesn't seem to like ">" -- i also installed mueval
09:11:36 <mm_freak> my conclusion:  if you don't need paged output and can live without beautiful math typesetting, don't use LaTeX
09:12:03 <Saizan> dblazakis: are you using it over an irc channel or just in your terminal?
09:12:14 <dblazakis> Saizan: irc channel
09:12:34 <bos> @seen augustss
09:12:34 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
09:12:40 <dblazakis> Saizan: i get stuff like "setResourceLimit: invalid argument (Invalid argument)"
09:14:31 <Saizan> dblazakis: oh, that's because rlimits seems to be broken on a lot of platforms
09:15:53 <ziman> Has anybody tried to write something from the bananas-lenses-barbwire paper? I tried to create a class Bifunctor bf where (||) :: (a -> b) -> (c -> d) -> bf a c -> bf b d; and then the instance Bifunctor (->); but I seem to be unable to write a definition for the (||) operation in this case. Does (->) require a different (||), e.g. ... -> bf b c -> bf a d?
09:15:59 <Saizan> dblazakis: however the lambdabot on hackage still uses the plugins package, not mueval, if you use the darcs version you shouldn't get that error
09:16:07 <Saizan> dblazakis: since rlimits is disabled by default
09:16:26 <dblazakis> Saizan: ah, i'll give the darcs version a try, thanks
09:17:10 <Myoma> ?djinn (a -> b) -> (c -> d) -> (a -> c) -> (b -> d)
09:17:11 <lambdabot> -- f cannot be realized.
09:17:19 <Myoma> ziman: You're not the only one that can't write it
09:17:23 <ziman> ;)
09:17:35 <ziman> yeah, there's no path in the dag from b to d
09:17:50 <quicksilver> ziman: (a -> b) is not a bifunctor.
09:17:55 <quicksilver> ziman: it's contravariant in 'a'
09:18:06 <Myoma> http://hackage.haskell.org/packages/archive/category-extras/0.44.4/doc/html/Control-Bifunctor.html
09:18:09 <lambdabot> Title: Control.Bifunctor, http://tinyurl.com/5j9gc4
09:18:12 <quicksilver> it's split co-contravariant bifunctor
09:18:18 <quicksilver> I forget the correct terminology.
09:18:27 <Myoma> maybe you could write one for <->
09:18:42 <Myoma> ?djinn (a -> b) -> (c -> d) -> (a -> c, c -> a) -> (b -> d, d -> b)
09:18:42 <lambdabot> -- f cannot be realized.
09:18:44 <Myoma> or not....
09:18:44 <ziman> <-> would work
09:19:17 <Myoma> ?djinn (a -> b) -> (c -> d) -> (a,c) -> (b,b)
09:19:17 <lambdabot> f a _ (b, _) = (a b, a b)
09:19:20 <Myoma> ?djinn (a -> b) -> (c -> d) -> (a,c) -> (b,d)
09:19:20 <lambdabot> f a b (c, d) = (a c, b d)
09:19:40 <Myoma> ?djinn (a -> b) -> (c -> d) -> (Either a c -> x) -> (Either b d -> x)
09:19:40 <lambdabot> -- f cannot be realized.
09:19:47 <quicksilver> ?djinn (b -> a) -> (c -> d) -> (a -> c) -> (b -> d)
09:19:47 <lambdabot> f a b c d = b (c (a d))
09:20:00 <Myoma> ?djinn (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)
09:20:00 <lambdabot> f a b c =
09:20:00 <lambdabot>     case c of
09:20:00 <lambdabot>     Left d -> Left (a d)
09:20:00 <lambdabot>     Right e -> Right (b e)
09:20:01 <quicksilver> ^^ you need to switch a and b 'cos it's contravariant there
09:22:39 <ziman> okay, thanks :)
09:23:36 <quicksilver> ziman: you can go crazy with all the permutations of co/contra once you get up to tri-functors ;)
09:23:39 <ziman> just wondering why arrows were in the middle of the Functors chapter (with the operation defined: (f --> g) h = g ∘ h ∘ f)
09:23:40 <Myoma> f . bf is a bifunctor too
09:24:20 <ddarius> quicksilver: There isn't, to my knowledge, any particular terminology for mixed variant functors.
09:24:37 <ziman> i need to study something about co/contravariant functors first ;)
09:24:55 <quicksilver> ddarius: fair enough :)
09:24:56 <ddarius> Don't forget the free variant and invariant ones
09:25:18 <ziman> any recommended paper?
09:26:09 <ddarius> ziman: There isn't really much to say.  A covariant functor transforms (a -> b) into Fa -> Fb, a contravariant functor transforms (a -> b) into Fb -> Fa
09:26:33 <vegai> are there any concrete examples of using Reactive?
09:26:51 <ddarius> vegai: I wrote a very simple IRC bot that's on hpaste somewhere.
09:26:54 <quicksilver> vegai: my recent paste contains some simple example.
09:27:05 <quicksilver> very simple, the only event type is keypresses
09:27:09 <ziman> thanks, i'll google for more information :)
09:27:16 <quicksilver> and not elegant because I'm still exploring the design space
09:27:32 <plutonas> moshisushi: hello, yes
09:27:33 <ddarius> @google ReactiveIRC site:hpaste.org
09:27:35 <lambdabot> No Result Found.
09:27:41 <purestorm> How can I do pattern matching to get (Just x) from a (IO (Maybe String))?
09:27:52 <ddarius> purestorm: You don't.
09:28:17 <ddarius> purestorm: If instead of IO you had Set, would you ask that question?
09:28:19 <purestorm> So having a function that returns an IO (Maybe String) is a bad idea?
09:28:21 <quicksilver> x <- action; case x of Just m ->
09:28:27 <quicksilver> (in a do block)
09:28:33 <vegai> quicksilver: ok, found yours
09:28:35 <dcoutts_> foo >>= \x -> case x of Just m ...
09:28:46 <pjdelport> ziman: are you familiar with the (r ->) functor?
09:28:48 <vegai> ddarius: how old paste, can you guess?
09:29:13 <ziman> pjdelport, quite, i think
09:29:13 <ddarius> http://hpaste.org/8723
09:29:24 <vegai> my god, hpaste is fast
09:29:25 <quicksilver> vegai: http://hpaste.org/8723
09:29:38 <quicksilver> (google for 'ddarius IRC site:hpaste.org')
09:29:47 <quicksilver> oh, ddarius beat me ;)
09:29:58 <ddarius> quicksilver: The string I gave to @google works, just not via lambdabot for some reason.
09:30:07 <lightstep> vegai, try http://www.mail-archive.com/haskell-cafe@haskell.org/msg36457.html
09:30:12 <lambdabot> Title: Re: [Haskell-cafe] First go at reactive programming, http://tinyurl.com/64v6ku
09:30:17 <pjdelport> ziman: that's covariant;  the contravariant version is (-> r)
09:30:25 <purestorm> quicksilver: thx
09:30:28 <vegai> thanks
09:30:39 <vegai> to all
09:33:28 <Myoma> hehe
09:33:33 <Myoma> "Since that compiler text is not very accessible even for readers knowing Dutch and X1 assembly language, a more or less equivalent version of it in (standard) Pascal has been added"
09:33:52 <pjdelport> ziman: where (r ->)'s fmap composes a function to the result end, (-> r)'s cofmap composes it to the input end
09:35:54 <ziman> pjdelport, i see
09:35:55 <pjdelport> ziman: so for functions, fmap :: (a -> b) -> (r -> a) -> (r -> b)
09:36:05 <pjdelport> and cofmap :: (a -> b) -> (b -> r) -> (a -> r)
09:36:23 <roderyk> if you're just making a version .0.0.1 and just want to mockup some code, can you save/load datastructures to disk? Basically, is there an idiom similar to python's shelve?
09:37:08 <quicksilver> roderyk: Read/Show
09:37:30 <quicksilver> roderyk: is the simplest idiom requiring, in most cases, no more work than adding 'deriving (Read,Show)'
09:38:23 <roderyk> quicksilver: ah, didn't think of that. thanks :)
09:41:09 <ziman> pjdelport, yes, thanks
09:41:33 <dcoutts_> http://www.hasthelhcdestroyedtheearth.com/
09:41:34 <lambdabot> Title: Has the Large Hadron Collider destroyed the earth yet?
09:42:50 <gwern> 'lo all. any news?
09:43:33 <medfly> the earth hasnt been destroyed yet.
09:43:56 * gwern is sick of the LHC news/jokes, as sick as I am of Reiser jokes
09:44:18 <medfly> how come i don't hear any reiser jokes?
09:44:26 <Myoma> Reiser FS ???
09:44:41 <medfly> Myoma, yes, the filesystem that kills your wife!
09:44:43 <gwern> medfly: you're just not looking in the right places
09:45:01 <ddarius> gwern: Obviously, then, you are in the wrong places.
09:45:56 <gwern> ddarius: I am doing my part to turn reddit into the right places by viciously downvoting all reiser and lhc jokes
09:46:06 <gwern> ddarius: I am part of the solution; are you part of the problem? :)
09:46:53 <Myoma> improving reddit is a worthewhile thing to do ....
09:48:02 <selmanj> reddit is a giant echo chamber
09:48:04 <gwern> not really, but I do it anyway
09:49:03 <ddarius> gwern: I don't read reddit.  Your problem is personal and can be solved by (also) not reading reddit.
09:49:51 <gwern> ddarius: I am trying, but addictions are difficult to eliminate.
09:50:05 <Myoma> this is really cute though http://www.reddit.com/r/types/
09:50:06 <lambdabot> Title: Types, typed programming, and static program analysis
09:50:25 <Myoma> at the top left
09:50:25 * gwern accepts that that I have a problem, and that there is a higher power - dons - but it is actively working against my efforts by posting interesting links to proggit :(
09:51:01 <gwern> dammit Myoma!
09:51:16 * Myoma considers opening ALGOL.reddit.com
09:52:38 <larsko> hey
09:52:48 <larsko> can I ask a quick question about lambdabot?
09:52:55 <Myoma> yes of course
09:53:21 <larsko> I'm using the darcs version -- how do I tell it to give op to some people joining channels?
09:53:30 <gwern> larsko: edit the rc
09:53:36 <larsko> how?
09:53:39 <gwern> wait, give IRC chanops?
09:53:43 <gwern> not lambdabot privileges?
09:53:44 <larsko> yes
09:53:47 <larsko> ahhhh
09:53:53 <larsko> those lines are lambdabot privs
09:53:54 <larsko> ok
09:54:04 <larsko> no, I'm talking about irc op privs
09:54:08 <gwern> I don't think lambdabot gives chanops; the rc is just about lambdabot commands like @flush
09:54:11 <gwern> @flush
09:54:21 <Myoma> larsko: that's against freenode policy, you s ouldn't do that
09:54:25 <ddarius> lambdabot doesn't have op
09:54:27 <gwern> eg; since I am in the rc, lb will not give me an error
09:54:36 <larsko> ok, I see
09:54:37 <Myoma> larsko: If you need op then you can get it at any time from chanserv, but don't stay opped
09:54:44 <gwern> if you tried it, I think lb would error like 'larsko does not have sufficient privileges'
09:55:01 <larsko> right
09:55:27 <larsko> well, it doesn't really matter, I just assumed that the "admin" lines in the rc did that and was wondering why it didn't work
09:55:27 <Myoma> larsko: umm, assuming you were actually talking about freenode
09:55:31 <larsko> yes
09:55:36 <gwern> larsko: so to summarize: lambdabot doesn't do that, and you shouldn't want it to :)
09:55:44 <larsko> right
09:57:38 <larsko> ok thanks, at least I know that my rc is correct and does what it's supposed to do now
10:01:01 <MyCatVerbs> @check (\f -> (f == f) == (not (isNaN f))) :: Float -- IEE754 -is- sane, right?
10:01:02 <lambdabot>   Couldn't match expected type `Float' against inferred type `String'
10:01:34 <MyCatVerbs> @check (\f -> (f == f) == (not (isNaN f))) :: Float -> Bool
10:01:34 <Myoma> @check (\f -> (f :: Float == f) == (not (isNaN f)))
10:01:34 <lambdabot>   Parse error at "==" (column 20)
10:01:35 <lambdabot>   Couldn't match expected type `Float -> Bool'
10:01:46 <Myoma> @check (\f -> ((f :: Float) == f) == (not (isNaN f)))
10:01:47 <lambdabot>   "OK, passed 500 tests."
10:02:11 <dblazakis> my lambda bot will work with @type, but :t fails with the hClose error
10:02:20 <MyCatVerbs> Myoma: danke.
10:03:10 <xpika> > 1
10:03:11 <lambdabot>   1
10:03:36 <xpika> >  parse (replicateM 5 (anyChar)) [] "abnnnc"
10:03:37 <lambdabot>   mueval: Prelude.read: no parse
10:03:41 <inimino> is anybody using attoparsec?
10:03:59 <xpika> inimino: i gave it a whirl
10:04:05 <gwern> dblazakis: interesting. I would've thought they went through the same codepath
10:04:39 <xpika> > parse (replicateM 5 (anyChar)) "" "abnnnc"
10:04:40 <lambdabot>   mueval: Prelude.read: no parse
10:05:09 <ddarius> @check (\f -> (f::Float)==f)
10:05:10 <lambdabot>   "OK, passed 500 tests."
10:05:15 <dblazakis> gwern: me too -- and it appears to work fine in an irc envirnoment
10:05:21 <inimino> there seems to be a bug in it
10:05:29 <dblazakis> gwern: locally it didn't work
10:05:32 <xpika> is there a parsec function to skip 1 char
10:05:41 <ddarius> anyChar
10:05:43 <dblazakis> xpika: anyChar?
10:05:50 <gwern> dblazakis: hm. are you running them in different directories?
10:06:00 <gwern> the ~/ code hasn't been 100% debugged imo
10:06:54 <xpika> ddarius: dblazakis: i want it like skip so it doesnt return
10:07:11 <deeflex> if I have a datatype like "data M = A String String | B String String" . How can I extract the members? I've only reached this far "getA :: M -> String getA (M a _) = a " .
10:07:51 <Myoma> deeflex: that's it !
10:08:05 <Myoma> deeflex: the type annotation is superfluous by the way
10:08:14 <Myoma> i.e. you can write simply: getA (M a _) = a
10:08:34 <Saizan> not M
10:08:38 <gwern> (I've always found it difficult to understand when and when not to use pattern matching)
10:08:38 <quicksilver> lightstep: the more I think about this, the more I think STM is the answer.
10:08:38 <Saizan> but A
10:08:40 <Saizan> or B
10:09:03 <ddarius> gwern: Use it except where you don't think you should.
10:09:45 <deeflex> Myoma: Ok, well then the problem is how I call it from hugs. I get an error when calling the function as "getA 'a' 'blbla'"
10:09:55 <Myoma> deeflex: "an error"?
10:10:05 <deeflex> ERROR - Type error in application
10:10:15 <EvilTerran> getA (A "a" "blbla")
10:10:17 <Myoma> and it doesn't go into more detail than that?
10:10:32 <EvilTerran> you need to construct an M before you can get a value out of it :P
10:10:37 <dblazakis> xpika: what do you mean return? you can ignore the result
10:11:54 <gwern> ddarius: as ever you are a font of useful advice
10:12:02 <ddarius> gwern: I try.
10:12:13 <deeflex> EvilTerran, that's true. Myoma: yes it does..hold on gonna try something different
10:12:15 <gwern> and you try very well
10:12:17 <deeflex> brb
10:14:56 <lightstep> quicksilver, the way i see it, STM will always check both f and g twice, and the ugly way will check g once and f once, or twice is necessary, but optimization is probably not important
10:15:54 <xpika> dblazakis: i want to skip the n's
10:16:05 <xpika> dblazakis: parse (replicateM 5 (anyChar)) [] "abnnnc"
10:16:30 <xpika> dblazakis: parse (replicateM 5 (satisfy (/='n') <|> (anyChar) )) [] "abnnnc"
10:17:02 <EvilTerran> ?hoogle noneOf
10:17:03 <lambdabot> Text.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:17:03 <lambdabot> Text.ParserCombinators.Parsec.Char noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
10:17:17 <EvilTerran> huh. must be parsec3
10:17:24 <deeflex> EvilTerran & Myoma: Ye doh, forgot to construct something, but not M. "getA (A 'a' 'bla')" is correct.
10:17:44 <Myoma> deeflex: Why are you using single quotes ?
10:18:26 <deeflex> im not..just when typing here in the chat to separate the code
10:18:54 <Myoma> deeflex: That is utterly confusing :)
10:19:00 <EvilTerran> i normally do that by not changing the code and wrapping it in (...) if it's not clear where it starts and ends
10:19:13 <Myoma> When you do that it's no longer valid haskell
10:19:28 <deeflex> oh..thought it would be more clear for u
10:19:29 <deeflex> hah
10:21:36 <deeflex> anyway...how can I construct a (one) function for getting the first member (from both A&B)? Instead of defining two functions like getA (A first _) = first, getB (B first _) = first.
10:21:59 <EvilTerran> getFirst (A first _) = first; getFirst (B first _) = first
10:22:20 <EvilTerran> if the first pattern doesn't match, it goes onto the second pattern
10:22:26 <EvilTerran> and so on, if there's more than two patterns
10:23:24 <deeflex> aha
10:23:28 <deeflex> ok tnx
10:23:37 <quicksilver> lightstep: Yes. But STM has a faster way of checking.
10:23:50 <quicksilver> lightstep: STM's "has this TVar been modified" is a super-fast primitive.
10:24:03 <yav> dcoutts: are you there?
10:24:05 <quicksilver> lightstep: presumably much faster than 'tryTakeMVar'
10:24:15 <dcoutts_> yav: hia
10:24:16 <hackage> Uploaded to hackage: bloomfilter 1.2.5
10:24:23 <quicksilver> lightstep: and the code will look prettier :)
10:24:53 <yav> hi, what's the right way to run tests with cabal these days?  Are we supposed to install a user handle, or is there a better way?
10:25:31 <dcoutts_> yav: there's not really any useful way. There's a hook for "cabal test" but nothing runs that automatically or collects results.
10:25:40 <deeflex> EvilTerran, isn't that code duplication? IF both A and B are of type M. (data M = A String String | B String String). Why can't I write  getFirst (M first _ ) = first ? Thanks
10:26:03 <dcoutts_> yav: so yeah, you can implement the test hook in UserHooks in your Setup.hs, but there's no massive advantage to doing so.
10:26:17 <lightstep> quicksilver, coll, so plusgood :)
10:26:19 <lightstep> *cool
10:26:32 <yav> dcoutts_: ok.  that's what we've used (you get a watning so we were wondering if there is a better way).  Thanks!
10:26:39 <dcoutts_> yav: I've got some ideas for doing testing in Cabal packages properly so that we can actually collect useful results.
10:26:46 <sw17ch> does any one know if there's a way to emulate Parsec3's Stream behavior with Happy?
10:26:54 <dcoutts_> yav: what warning?
10:26:58 <lilac> deeflex: if you want that, you can write data M = A { first :: String, second :: String } | B { first :: String, second :: String }
10:27:25 <dcoutts_> sw17ch: you can get happy to use a monadic lexer if that helps
10:27:25 <lilac> deeflex: then you get a first :: M -> String for free
10:27:53 <deeflex> aha so I don't need to define any functions? cool
10:28:01 <sw17ch> dcoutts_: i've put together (with some help) a method for getting exact (offset,length) tuples into the types produced by Parsec
10:28:13 <yav> scoutts_: oh nothing special---just a warning that i've used a hook
10:28:30 <sw17ch> so "\"Hello World\"" would produce a data type that has the string value, the offset into the overall stream, and the length of the token
10:28:32 <yav> dcoutts_: ^
10:28:39 <sw17ch> so you could look back and see what that piece of the syntax tree was parsed from
10:28:49 <dcoutts_> yav: I'm a bit confused. There's nothing wrong with using hooks.
10:29:20 <dcoutts_> sw17ch: you mean tokens with position information
10:29:46 <sw17ch> dcoutts_: yes, but i wanted the exact offset (in bytes) into the stream rather than the line/column format every one is used to
10:29:53 <dcoutts_> sw17ch: you can certainly do that with happy, if you use an appropriate lexer
10:30:13 <dcoutts_> sw17ch: and alex makes it not too hard to define such a lexer
10:30:17 <sw17ch> dcoutts_: you helped Benedikt with Langauage.C, right? (Or am i thinking of some one else)
10:30:25 <dcoutts_> sw17ch: I did, yes.
10:31:07 <sw17ch> dcoutts_: I've been talking to him about replacing the preprocessing stage with a different preprocessor which attaches that kind of information. Then the final expansion/AST can point to the exact source it was derived from.
10:31:32 <dcoutts_> sw17ch: so byte offsets are even easier, you just don't calculate columns
10:31:38 <sw17ch> I'm trying to determine how coupled the parser will need to be with the CPP used to do such a thing
10:31:40 <yav> dcoutts: cabal 1.4 says: Warning: defaultUserHooks in Setup script is deprecated.
10:31:59 <dcoutts_> yav: ahh, you can use simpleUserHooks iirc
10:32:08 <sw17ch> dcoutts_: yes, it's really not that hard, i'm just not used to happy.. so i wanted to be sure ther wasn't some serious road block. thanks :)
10:32:32 <dcoutts_> yav: I deprecated defaultUserHooks because it was not the default and thus very very confusing :-)
10:33:13 <dcoutts_> sw17ch: take a look at the existing language.c / c2hs lexer
10:33:16 <yav> dcoutts: cool.  that seems to have removed the warning and the tests still run
10:33:41 <sw17ch> dcoutts_: i've been looking at it, but not too in depth yet. i was planning on that after fact-checking. :)
10:34:51 <dcoutts_> sw17ch: so see data Position, I guess you want something similar, but with just filename and offset (and maybe length) rather than row and column
10:34:54 <deeflex> lilac, say I want to return the length of the second parameter. How can I do that without typing length (second (M "lal" "lala")). Is it possible to like override second :: M -> String ?
10:35:11 <dcoutts_> sw17ch: and you'd adjust alexMove :: Position -> Char -> Position  appropriately
10:35:50 <sw17ch> dcoutts_: yes, the primary concern I have is switching out how the c2hs parser/lexer accepts input
10:36:16 <dcoutts_> sw17ch: so what are you trying to do in the end exactly?
10:36:36 <sw17ch> dcoutts_: find the positional information based on the original, unpreprocessed, c file
10:36:55 <dcoutts_> sw17ch: it does that already
10:37:10 <dcoutts_> sw17ch: because the C pre-processors inserts #line pragmas
10:37:23 <sw17ch> if all of main is defined in a macro, #define MAIN main {return 0;}, i want the positional information to represent only the space taken up by the characters MAIN rather than the entire block
10:37:29 <dcoutts_> sw17ch: well, ok the column number might be wrong for macros I guess, but the row will be right
10:38:03 <sw17ch> so, for that example, instead of having a length of 16, you'd have a length of 4
10:38:21 <sw17ch> wow, my C was bad in that example...
10:38:28 <dcoutts_> sw17ch: so you're going to implement a C pre-processor :: [Token] -> [Token] ?
10:38:51 <sw17ch> that's the idea, but the produced tokens contain information to override the positional information normally produced
10:39:07 <dcoutts_> right, still sounds like a lot of work
10:39:13 <sw17ch> dcoutts_: it is
10:39:22 <visq_> sw17ch: hi
10:39:28 <sw17ch> the preprocessor is a scary beast
10:39:33 <sw17ch> visq_: hi
10:39:34 <dcoutts_> sw17ch: especially if it has to be accurate compared to gcc's cpp
10:39:43 <deeflex> lilac, any suggestion?
10:39:49 <dcoutts_> sw17ch: which it needs to be if you're processing GNU C
10:40:06 <sw17ch> dcoutts_: i'm fully aware of the difficulty, i don't plan on doing this overnight :)
10:40:16 <visq_> I think the integration with language.c won't be the most difficult part
10:40:56 <sw17ch> visq_: replacing the c preprocessor will be
10:41:02 <dcoutts_> sw17ch: ok :-) have fun
10:41:16 <sw17ch> dcoutts_: i'm sure i will... :P
10:41:43 <yav> sw17ch:  (missed beginning of discussion). Language.C has a hook to run a custom pre-processor, or did you already know about that?
10:42:15 <sw17ch> yav: i'm aware... i really need to integrate a CPP into the parsing/lexing that Language.C does. i have to have the CPP annotate the stuff it produces with more information
10:42:16 <lilac> deeflex: i don't think i understand the problem. (length . second) :: M -> Int
10:42:53 <visq_> sw17ch: I think it is enough if we replace the lexer
10:43:18 <dcoutts_> visq_: btw, does it still lex from String, or from Lazy.ByteString now?
10:43:41 <visq_> dcoutts_: currently bytestring is default, it is a cabal flag
10:43:49 * lilac has a parsec implementation of a c preprocessor around here somewhere
10:43:51 <dcoutts_> visq_: nice
10:43:56 <dcoutts_> visq_: btw, I'm not going to have time to look at c2hs / language.c 'til after ICFP
10:44:12 * sw17ch would like to know when lilac finds it :)
10:44:21 <dcoutts_> visq_: so don't feel that my ignoring the patches means they'll always be ignored! :-)
10:44:33 <deeflex> lilac, aha ok. What I want is a function like getLengthSecondMember (A/B "bla" "test") which returns 4 (length of "test")
10:44:38 <visq_> dcoutts_: that's fine. I hope some of the patches make it into c2hs eventually, though.
10:44:42 <sw17ch> visq_: hello, i had no idea who you were at first :)
10:44:58 * sw17ch applogizes for being confused
10:45:07 <lilac> sw17ch: i'll upload it somewhere. feel free to laugh at it :)
10:45:29 <sw17ch> visq_: how do you think replacing the lexer would fix the problem?
10:45:36 <dcoutts_> visq_: me too, I'm sure we'll get there, it's just a matter of long TODO lists of the patch reviewers
10:45:37 <lilac> deeflex: "getLengthSecondMember = length . second" should do the trick
10:45:49 <visq_> sw17ch: there's also cpphs, did you have a look at it ?
10:46:15 <EvilTerran> aka "getLengthSecondMember m = length (second m)@
10:46:20 <EvilTerran> er, ", not @
10:46:38 <sw17ch> visq_: yes, i took a look at it. I haven't had tons of time to play aroudn with it yet. I wanted to bang out a simple CPP in Parsec which tracked positional information before trying anything too complex.
10:47:31 <visq_> sw17ch: what do you think about the approach I've outlined in the wiki ?
10:48:03 <dblazakis> @pl \x -> if x then True
10:48:03 <lambdabot> (line 1, column 21):
10:48:03 <lambdabot> unexpected end of input
10:48:03 <lambdabot> expecting letter or digit, variable, "(", operator or "else"
10:48:05 <sw17ch> has it changed since you e-mailed it to me a while back?
10:48:16 <visq_> sw17ch: no
10:48:43 <EvilTerran> dblazakis, in haskell, "if"s must have an "else"
10:49:05 <deeflex> lilac, Thanks! EvilTerran: Ok lilac's code worked too.
10:49:09 <EvilTerran> dblazakis, otherwise, what would the if's value be when the predicate is flase?
10:49:15 <visq_> sw17ch: preprocess, keep a map original source tokens <-> preprocessed tokens (including macro expansions), and references the preprocessed tokens somehow within the AST
10:49:45 <sw17ch> visq_: that was the approach i was considering also
10:49:54 <sw17ch> (i had to go back and refresh what you'd written)
10:50:12 <sw17ch> My thought was taht you'd end up wtih a list of [CppBlock]
10:50:31 <sw17ch> the CppBlock's would be CppExpansions, Comments, Strings, NormalText
10:50:47 <sw17ch> the CppBlock would have a start/length corresponding to the original offset and length of the preprocessor macro
10:50:57 <sw17ch> so yes, what you're saying
10:51:21 <visq_> sw17ch: so instead of Position maybe an AST node could reference the ID of the first and last token it was build from
10:51:51 <sw17ch> visq_, that would work if each token mantains it's own positional information
10:51:55 <dblazakis> EvilTerran: thanks, i actually just hit the numpad enter while eating my chili (with a half typed expression...)
10:52:08 <visq_> sw17ch: right
10:52:27 <dblazakis> @pl \a b c -> if c then a else b
10:52:28 <lambdabot> flip . flip if'
10:52:30 <dblazakis> ah
10:52:36 <dblazakis> that is what i was looking for :-)
10:52:44 <sw17ch> visq_: yes, this is exactly how i'd like to implement it. i feel like the hardest part will be that this approach requires replacing the preprocessor we use with our own (i think)
10:53:43 <EvilTerran> dblazakis, if' isn't available anywhere except to @pl, unless you define it yourself
10:53:52 <visq_> sw17ch: changing the parser to remember the last token as well is also a lot of work, but relatively straightforward.
10:53:57 <EvilTerran> dblazakis, and you might as well define one in the right order if you're gonna do that
10:54:07 <dcoutts_> visq_: the ghc parser maintains spans, which indeed is the position of the first token and the pos+len of the last token that makes up that ast node
10:54:15 <EvilTerran> "bool false true False = false; bool false true True = true"
10:54:37 <visq_> dcoutts_: yes, that sounds like a good idea
10:54:38 <dcoutts_> visq_: there's obviously a simple + operation for spans
10:54:42 <sw17ch> dcoutts_: does the GHC parser accept preprocessor statements?
10:54:59 <dcoutts_> sw17ch: no, it expects a separate cpp pass
10:55:16 <dcoutts_> sw17ch: it underatands cpp #line pragmas though, so the line numbers are accurate
10:55:40 <visq_> sw17ch: did you have a short look at the papers of the approaches which modified gcc ?
10:55:42 <dcoutts_> sw17ch: but not positions within the line if there was macro expansion on that line
10:56:00 <dcoutts_> sw17ch: but is that really important? what's the application?
10:56:22 <visq_> dcoutts_: source code annotation
10:56:29 <dcoutts_> ah, hmm
10:56:43 <sw17ch> visq_: i, unfortunately, don't have ACM access :\
10:56:43 <dcoutts_> fair enough
10:57:15 <visq_> sw17ch: ah ok. Well, one can build a database mapping preprocessed positions -> original source positions while preprocessing.
10:57:44 <visq_> sw17ch: or tokens after preprocessing -> original source tokens
10:57:49 <sw17ch> visq_: yes, i've produced taht behavior (somewhat) in my parsec preprocessor
10:58:48 <CoryDambach> does anyone in here have a functioning haskell cluster using ghc?
10:58:56 <visq_> sw17ch: I'll think a bit more about integration into the lexer/parser. please modify the wiki page if you have any additional ideas.
10:59:13 <sw17ch> i will. tahnks visq_. i need to step out for a while here.
10:59:31 <sw17ch> thanks visq_/dcoutts_
11:05:57 <laz0r> is there a neat type system trick that would make it possible to use State s () Funtions inside of StateT s IO () as if they had the StateT type?
11:06:17 <EvilTerran> trickery with runState
11:06:25 <EvilTerran> ?type runState
11:06:26 <lambdabot> forall s a. State s a -> s -> (a, s)
11:06:37 <EvilTerran> ?type runStateT
11:06:38 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
11:06:57 <laz0r> ok
11:07:22 <laz0r> that'll do, but i actually was thinking about something more fancy
11:07:38 <laz0r> i wanted to use the State functions as if they hasd the StateT type
11:07:42 <EvilTerran> ?type let liftState m = do s <- get; let { (x,s') = runState m s }; put s'; return x in liftState
11:07:43 <lambdabot> forall t t1 (t2 :: * -> *). (MonadState t t2) => State t t1 -> t2 t1
11:08:09 <EvilTerran> ?src StateT
11:08:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:26:41 <dblazakis> @pl flip (:) [][
11:26:41 <lambdabot> (line 1, column 12):
11:26:41 <lambdabot> unexpected "["
11:26:41 <lambdabot> expecting variable, "(", operator or end of input
11:26:50 <dblazakis>  @pl flip (:) []
11:27:23 <dblazakis> @pl flip (:) []
11:27:23 <lambdabot> return
11:32:50 <sw17ch> was any one else, when learning haskell, surprised to find that (,) is an operator?
11:33:06 <sw17ch> i was just remembering how big of a surprise that was to me about a year ago
11:33:18 <Corun> ?type (,)
11:33:19 <lambdabot> forall a b. a -> b -> (a, b)
11:33:48 <sw17ch> ?type (,,)
11:33:49 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
11:33:50 <sw17ch> ?type (,,,)
11:33:51 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
11:33:57 <sw17ch> ?type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
11:33:58 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n
11:33:59 <lambdabot> -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> (a, b, c,
11:33:59 <lambdabot> d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45)
11:34:11 <Corun> Heh
11:40:17 <mmorrow> > (\doc xs -> parens . punctuate comma . fmap doc) int [0..19]
11:40:18 <lambdabot>   Couldn't match expected type `Doc' against inferred type `[Doc]'
11:40:25 <mmorrow> > (\doc xs -> parens . hcat . punctuate comma . fmap doc) int [0..19]
11:40:26 <lambdabot>       Overlapping instances for Show ([Int] -> Doc)
11:40:26 <lambdabot>        arising from a use...
11:40:39 <mmorrow> > (\doc -> parens . hcat . punctuate comma . fmap doc) int [0..19]
11:40:40 <lambdabot>   (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19)
11:40:46 <mmorrow> > (\doc -> parens . vcat . punctuate comma . fmap doc) int [0..19]
11:40:47 <lambdabot>   (0,
11:40:47 <lambdabot>   1,
11:40:47 <lambdabot>   2,
11:40:47 <lambdabot>   3,
11:40:47 <lambdabot>   4,
11:40:49 <lambdabot> [10 @more lines]
11:41:23 <EvilTerran> O.o
11:41:29 <EvilTerran> ?type parens
11:41:30 <lambdabot> Doc -> Doc
11:41:34 <EvilTerran> ?type vcat
11:41:36 <lambdabot> [Doc] -> Doc
11:41:40 <EvilTerran> ?index Doc
11:41:41 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
11:41:56 <EvilTerran> ah
11:41:57 <mmorrow> > (\doc -> parens . vcat . punctuate comma . fmap ((space<>).doc)) int [0..19]
11:41:58 <lambdabot>   ( 0,
11:41:58 <lambdabot>    1,
11:41:58 <lambdabot>    2,
11:41:58 <lambdabot>    3,
11:41:58 <lambdabot>    4,
11:42:00 <lambdabot> [8 @more lines]
11:42:22 <mmorrow> > (\doc (x:xs)-> parens . vcat . punctuate comma . (doc x:) . fmap ((space<>).doc) $ xs) int [0..19]
11:42:23 <lambdabot>   (0,
11:42:23 <lambdabot>    1,
11:42:23 <lambdabot>    2,
11:42:23 <lambdabot>    3,
11:42:23 <lambdabot>    4,
11:42:25 <lambdabot> [8 @more lines]
11:42:36 <EvilTerran> this is a bit floody
11:42:53 <EvilTerran> ?type doc
11:42:54 <lambdabot> Not in scope: `doc'
11:43:04 <EvilTerran> orite
11:43:10 <EvilTerran> ?type int
11:43:11 <lambdabot> Int -> Doc
11:43:31 <mmorrow> > double pi
11:43:33 <lambdabot>   3.141592653589793
11:43:42 <mmorrow> > integer 10 ^100
11:43:42 <lambdabot>       No instance for (Num Doc)
11:43:43 <lambdabot>        arising from a use of `^' at <interact...
11:43:57 <mmorrow> > integer (10 ^100)
11:43:58 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
11:44:03 <Twey> Doc?
11:44:07 <Twey> What's a Doc?  O.O
11:44:09 <mmorrow> > text "asdfg"
11:44:10 <lambdabot>   asdfg
11:44:17 <Twey> Oh, pretty-printing
11:44:20 <mmorrow> > Text.PrettyPrint.HughesPJ
11:44:21 <lambdabot>       Not in scope: data constructor `Text.PrettyPrint.HughesPJ'
11:44:26 <mmorrow> > empty :: Text.PrettyPrint.HughesPJ.Doc
11:44:26 <lambdabot>       Ambiguous occurrence `empty'
11:44:27 <lambdabot>      It could refer to either `Control.App...
11:44:40 <EvilTerran> > Text.PrettyPrint.HughesPJ.empty
11:44:41 <lambdabot>   mueval: Prelude.read: no parse
11:44:49 <Twey> > Text.PrettyPrint.HughesPJ.empty :: Text.PrettyPrint.HughesPJ.Doc
11:44:50 <lambdabot>   mueval: Prelude.read: no parse
11:44:53 <mmorrow> > (text[])
11:44:54 <lambdabot>   mueval: Prelude.read: no parse
11:45:07 <mmorrow> > text [] <> text []
11:45:08 <lambdabot>   mueval: Prelude.read: no parse
11:45:09 <EvilTerran> > text "a"
11:45:10 <lambdabot>   a
11:45:16 <mmorrow> > text ""
11:45:17 <EvilTerran> hm
11:45:18 <lambdabot>   mueval: Prelude.read: no parse
11:45:22 <mmorrow> hmm
11:45:54 <mmorrow> @let emptyDoc = Text.PrettyPrint.HughesPJ.empty
11:45:55 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
11:46:07 <mmorrow> @let emptyDoc = Text.PrettyPrint.empty
11:46:08 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
11:48:17 <mmorrow> > foldr (.) id (replicate 10 (parens . brackets . braces)) $ double pi
11:48:19 <lambdabot>   ([{([{([{([{([{([{([{([{([{([{3.141592653589793}])}])}])}])}])}])}])}])}])}])
11:48:56 <Feuerbach> :t double
11:48:57 <lambdabot> Double -> Doc
11:49:06 <mmorrow> > foldr (.) id (replicate 10 (parens . nest 2 . brackets . braces)) $ double pi
11:49:08 <lambdabot>   ([{([{([{([{([{([{([{([{([{([{3.141592653589793}])}])}])}])}])}])}])}])}])}])
11:49:31 <Feuerbach> @index double
11:49:32 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
11:49:42 <lilac> @tell sw17ch my hacky C++ preprocessor is available at http://metafoo.co.uk/darcs/hc++
11:49:51 <lambdabot> Consider it noted.
11:50:14 <mmorrow> Feuerbach: those are all the same one, just aliased or duplicated
11:51:01 <mmorrow> @type render
11:51:02 <lambdabot> Doc -> String
11:51:54 * sw17ch thanks lilac! 
11:51:54 <lambdabot> sw17ch: You have 1 new message. '/msg lambdabot @messages' to read it.
11:53:20 <mmorrow> > let ppCsv = vcat . fmap (hcat . punctuate comma . fmap (doubleQuotes . text . show)) in ppCsv (replicate 3 [0..7])
11:53:21 <lambdabot>   "0","1","2","3","4","5","6","7"
11:53:21 <lambdabot>  "0","1","2","3","4","5","6","7"
11:53:21 <lambdabot>  "0","1","...
11:56:09 <OceanSpray> where can I get the documentation for the haskell llvm bindings?
11:56:21 <OceanSpray> My google-fu seems to be weak today.
12:05:18 <sw17ch> haskell has llvm bindings?
12:05:19 <sw17ch> neato!
12:05:36 <OceanSpray> aye.
12:06:06 <sw17ch> OceanSpray: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm ?
12:06:08 <lambdabot> Title: HackageDB: llvm-0.0.2
12:06:19 <sw17ch> ah, the docs aren't there...
12:06:19 <OceanSpray> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/llvm
12:06:19 <lambdabot> Title: HackageDB: llvm-0.0.2
12:08:26 <OceanSpray> And that is a problem.
12:12:11 <sw17ch> you could try checking out the darcs repo, and then running `runhaskell Setup haddock` and see what's produced
12:30:07 <pcc1> I'm declaring a function of type [Token] -> XYZType a.  when commpiling I get the error message "Inferred type is less polymorphic than expected"
12:30:50 <pcc1> ..."Quantified type variable `a' is mentioned in the environment:"  then it lists a bunch of happy internal functions (this is a file preprocessed using happy)
12:31:15 <pcc1> what do I need to do to make the type system happy?
12:35:13 <rwbarton> Can you paste the function and the full error message?  http://hpaste.org/new
12:37:13 <jpcooper> hello
12:37:35 <jpcooper> @hoogle A -> B -> A
12:37:36 <lambdabot> Warning: Unknown type A
12:37:36 <lambdabot> Prelude const :: a -> b -> a
12:37:36 <lambdabot> Data.Function const :: a -> b -> a
12:37:48 <pcc1> rwbarton: http://hpaste.org/10246
12:38:00 <jpcooper> excellent
12:39:33 <pcc1> rwbarton: more: http://hpaste.org/10247
12:41:33 <rwbarton> ... wow
12:41:56 <rwbarton> parseType has type [Token] -> XYZType a?  and it compiles?  does it have a type annotation?
12:42:07 <mopped> Would haskell be classed as static typed?
12:42:47 <Feuerbach> mopped: yes
12:43:10 <pcc1> no, it's a happy geenrated function
12:43:11 <Philippa|IFL> no, the type system changes too often :-)
12:44:07 <Feuerbach> 2:1
12:44:55 <pcc1> yes it compiles
12:46:39 <rwbarton> "no" was it doesn't have a type annotation?  Can you :t parseType in ghci?
12:47:09 <pcc1> correct, let me check
12:50:15 <pcc1> it only compiles when I change a to () in toXYZType signature, then I get:  parseType :: [XYZType.Token] -> XYZType ()
12:52:20 <pcc1> or I can use -fno-monomorphism-restriction and get: parseType :: (Ord rt, Show rt, XYZRec rt) => [Token] -> XYZType rt
12:54:02 <jpcooper> @hoogle random
12:54:02 <lambdabot> package random
12:54:02 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
12:54:02 <lambdabot> module System.Random
12:54:07 <pcc1> ah, using -fno-monomorphism-restriction solves my problem, thanks
12:58:44 <Philippa|IFL> 'lo swiert
13:02:17 <swiert> Hiya Philippa.
13:02:34 <Heffalump> IFL?
13:03:18 <swiert> Implementing Functional Languages (or something like that)
13:03:35 <swiert> http://events.sac-home.org/ifl2008/
13:03:37 <lambdabot> Title: IFL 2008 » 20th International Symposium on the Implementation and Application o ...
13:05:41 <Heffalump> I thought that was next week, though
13:06:36 <Heffalump> ah, apparently not.
13:09:08 <EvilTerran> pcc1, if you're going to use that flag, the current non-deprecated name for it is -XNoMonomorphismRestriction
13:09:31 <EvilTerran> pcc1, alternatively, you can switch one of those on temporarily, ask ghci for the type of it, and put that in as an annotation in the source file
13:10:06 <pcc1> EvilTerran: thanks
13:10:11 <EvilTerran> pcc1, as you can circumvent the monomorphism restriction for individual definitions by giving an explicit polymorphic type signature
13:11:04 <EvilTerran> if you want to disable the MR for a whole file, you can put {-# LANGUAGE NoMonomorphismRestriction #-} at the top of the file
13:11:17 <EvilTerran> LANGUAGE pragmas and -X flags use the same names
13:13:26 <pcc1> hmm, seems it won't work reliably in this case as all the functions are auto-generated by happy, think I'll go with the whole file disable
13:26:18 <olsner> augustss: I think I've found a bug in printf: it's always evaluating the length of the string fed into %s to figure out how much padding it should have - even when it hasn't been asked to pad anything
13:26:31 <olsner> it broke my fixpoint fun this morning :P
13:29:58 <CosmicRay> dons: happen to see my JSON question?
13:30:14 <CosmicRay> olsner: that does sound like a bug
13:31:03 <bd_> > fix (printf "x%s")
13:31:04 <lambdabot>   Add a type signature
13:31:08 <bd_> > fix (printf "x%s" :: String -> String)
13:31:09 <lambdabot>   mueval: Prelude.read: no parse
13:31:10 <lambdabot>  mueval: "x*** Exception: stack overflow
13:31:23 <olsner> the fix is simple, change 'if lstr+lpre < width ...' into 'if width > 0 && lstr+lpre < width ...' in the fmt function in Text.Printf
13:31:41 <olsner> then it properly handles fixpoint fun :)
13:41:16 <olsner> @seen augustss
13:41:16 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
13:41:50 <olsner> hmm, soo.. is there a bugtracker for the 'base' package anywhere? am I looking for the ghc bugtracker?
13:42:04 <Botje> olsner: pretty much.
13:42:05 <sjanssen> olsner: yes, yes
13:45:24 <olsner> meh, feels silly to report a bug for this... can't someone with write access just add the extra check to the source? :P
13:55:19 <smoothride5> can someone help regarding motor gearing please
13:56:03 <Nafai> smoothride5: This channel is about the Haskell programming language
13:56:14 <smoothride5> bye
13:57:03 <Nafai> That was...random.
13:57:25 <Nafai> Is Haskell the name of some auto company or something? :)
13:57:50 <olsner> iirc there's a brand of motorcycles
13:58:10 <Nafai> Ah
13:58:15 <Nafai> That would explain it then
13:58:45 <olsner> hmm, can find no proof of it though... it might just be something I made up
14:02:58 <DRMacIver> Random thought. Does hpaste have an API you can use remotely?
14:04:24 <Heffalump> DRMacIver: HTTP? :-)
14:05:46 <DRMacIver> Heffalump: Well, I'm assuming it would be an API over http. e.g. something restful or whatever. But something to let you talk to it that doesn't require parsing the HTML it outputs, etc. :)
14:06:19 <DRMacIver> (The reason I ask is that I've just discovered the pastebinit command line tool, which I find ridiculously useful, and I was idly wondering if there were an equivalent for hpaste)
14:08:16 <Heffalump> fair enough :-)
14:09:36 <DRMacIver> Anyway, given that I haven't written Haskell outside of my xmonad.hs in an embarrassingly long time (I will soon, honest) I don't really care. Just curious. :)
14:13:04 <sjanssen> DRMacIver: there's a vim plugin that works with hpaste
14:14:50 <olsner> do you really need an interface though? shouldn't it suffice to just POST the data to the cgi script and be done?
14:16:43 <olsner> wget --post-data="`awk '...' f.hs`" for some value of ...
14:16:51 <DRMacIver> True
14:17:46 <lament> i just open hpaste in the browser...
14:19:15 <olsner> printf bug reported! http://hackage.haskell.org/trac/ghc/ticket/2583
14:19:20 <lambdabot> Title: #2583 (printf %s is not lazy enough) - GHC - Trac
14:20:09 <DRMacIver> olsner: Although I was actually thinking in terms of exposing a little more than just the pastebinit functionality. Oh well, never mind. It's not really important. :)
14:20:29 <DRMacIver> lament: Having a command line interface is actually really useful. It simplifies dumping files, results of stdout, etc. a lot
14:20:32 <sjanssen> DRMacIver: the vim plugin also allows you to browse pastes and download them
14:21:02 <DRMacIver> sjanssen: Cool
14:22:11 <roderyk> can someone shed a little light for me on JSON? (showJSON ["foo", "bar"]) seems to do the same thing as showJSONs (even though one is a the other [a]), and I have yet to figure out how to properly use the JSObject constructor to make some {"name": "string value", "name2": int} object.
14:22:27 <lightstep> > printf "%s" :: String
14:22:28 <lambdabot>   mueval: Prelude.read: no parse
14:22:28 <lambdabot>  mueval: "*** Exception: Printf.printf: argu...
14:23:06 <twanvl> > printf "%1s" (repeat 'x') :: String
14:23:31 <lambdabot>   mueval: Prelude.read: no parse
14:37:05 <Cale> roderyk: do they really both typecheck? Perhaps there's an instance of the JSON class for lists?
14:40:20 <Cale> roderyk: JSObject (toJSObject [("name", JSString "string value"), ("name2", JSRational 5)])
14:42:21 <roderyk> Cale: can't match 'JSString' against '[Char]'
14:43:03 <roderyk> if I use toJSString instead, it's a type mismatch between JSValue and JSString
14:43:11 <roderyk> does this work for you?
14:51:44 <Cale> roderyk: oh, right
14:52:08 <Cale> JSObject (toJSObject [("name", JSString (toJSString "string value")), ("name2", JSRational 5)])
14:53:44 <Cale> that works
14:54:57 <Cale> Prelude Text.JSON> putStrLn . encode $ JSObject (toJSObject [("name", JSString (toJSString "string value")), ("name2", JSRational 5)])
14:54:57 <Cale> {"name":"string value","name2":5}
14:56:10 <Cale> The JSON library is a little inconvenient with regard to JSString, given that it's really just a newtype of String.
14:56:26 <twanvl> Why do you have to say everything twice? JSObject (toJSObject ..), JSString (toJSString ..)
14:56:27 <Cale> (why not just use String?)
14:56:35 <Cale> That too.
14:57:08 <Cale> toJSObject would be more convenient if it produced a JSValue.
14:57:42 <Cale> The JSString type is mostly just pointless.
14:59:31 <roderyk> Cale: ah ok. thanks a lot!
15:00:20 <roderyk> the JSString and the fact all the constructors are "doubled" really threw me off.
15:03:13 <roderyk> Cale: one more question, if you would be so kind. :) decode "{\"name\":\"string value\",\"name2\":5}" :: what kind of signature do you need this to return?
15:03:39 <guenni> mmorrow: ping
15:04:06 <BONUS_> is there a standard library function for combining predicates with and or or?
15:04:38 <BONUS_> \x -> isSpace x || isPunctuation x || isControl x
15:05:06 <rwbarton> @pl \x -> f x || g x || h x
15:05:06 <lambdabot> liftM2 (||) f (liftM2 (||) g h)
15:05:52 <ddarius> and . sequene
15:06:03 <BONUS_> > let p1 (||) p2 = \x -> p1 x || p2 x in (isSpace || isPunctuation || isControl) ' '
15:06:04 <lambdabot>   Couldn't match expected type `Bool'
15:06:15 <BONUS_> > let (||) p1 p2 = \x -> p1 x || p2 x in (isSpace || isPunctuation || isControl) ' '
15:06:16 <lambdabot>       Occurs check: cannot construct the infinite type: t = t1 -> t
15:06:16 <lambdabot>      Prob...
15:06:19 <BONUS_> hm
15:06:23 <rwbarton> BONUS_: you're shadowing the || on the right
15:06:35 <BONUS_> oh
15:06:45 <BONUS_> > let (|||) p1 p2 = \x -> p1 x || p2 x in (isSpace ||| isPunctuation ||| isControl) ' '
15:06:46 <lambdabot>   True
15:06:55 <EvilTerran> ?type and . sequence [isSpace, isPunctuation, isControl]
15:06:56 <BONUS_> kewl combinator imho
15:06:57 <lambdabot> Char -> Bool
15:07:05 <BONUS_> oh
15:07:06 <BONUS_> nice
15:07:33 <EvilTerran> > map (or . sequence [isSpace, isPunctuation, isControl]) "!3g ?.A\n\t"
15:07:34 <lambdabot>   [True,False,False,True,True,True,False,True,True]
15:08:49 <EvilTerran> ?let infixr 5 <||>; (<||>) = liftA2 (||)
15:08:49 <lambdabot>   Parse error
15:16:36 * dcoutts announces that code.haskell.org has switched to darcs 2
15:16:43 <dcoutts> $ darcs --version
15:16:43 <dcoutts> 2.0.2 (release)
15:16:54 <dolio> Nice.
15:17:17 <dcoutts> http://haskell.org/pipermail/haskell/2008-September/020618.html
15:17:18 <lambdabot> Title: [Haskell] Heads Up: code.haskell.org is upgrading to darcs 2
15:17:23 <dcoutts> details ^^
15:17:53 <tomh_-_> why darcs
15:18:36 <tomh_-_> oh its written in haskell :>
15:18:51 <dolio> Why not darcs?
15:19:12 <tomh_-_> well git, svn, mercurial are more widespread actually
15:19:18 <tomh_-_> but i dunno, im just a noob
15:21:03 <haskellian> have any of you tried Scala+ what do you think about it? ive started to play around with it.
15:21:16 <tomh_-_> oh my school is gonna force me to use darcs too
15:21:28 <dolio> Is Scala+ different than Scala?
15:21:52 <dolio> Darcs is pretty easy to use.
15:21:53 <dcoutts> tomh_-_: your school is clearly very enlightened :-)
15:22:15 <dolio> At least, for anything I've ever needed to do, which probabl isn't much.
15:22:16 <tomh_-_> hehe
15:22:47 <tomh_-_> its all about haskell here
15:23:57 <roderyk> I'm awful confused about the simple things. Any suggestions on what Text.JSON expects here: decode "{\"name\":\"string value\",\"name2\":5}" :: ???
15:24:42 <roderyk> do I need to give it a full schema of what I expect? (if so, how would that look like?)
15:24:53 <lightstep> ?t Text.JSON.decode
15:24:54 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:25:05 <lightstep> ?type Text.JSON.decode
15:25:06 <lambdabot> Couldn't find qualified module.
15:25:20 <roderyk> > :t Text.JSON.decode
15:25:21 <roderyk> Text.JSON.decode :: (JSON a) => String -> Result a
15:25:21 <lambdabot>   mueval: Prelude.read: no parse
15:25:31 <ddarius> roderyk: It's an object, say JObject (or whatever it is)
15:25:46 <roderyk> decode "{\"name\":\"string value\",\"name2\":5}" :: JSObject
15:25:47 <roderyk> <interactive>:1:52: `JSObject' is not applied to enough type arguments Expected kind `?', but `JSObject' has kind `* -> *'
15:27:43 <rwbarton> :: Result JSValue   I think
15:28:12 <rwbarton> or :: Result (JSObject JSValue)
15:28:19 <roderyk> rwbarton: brilliant! it always seems simple and yet I'm always left scratching my head. thanks!
15:29:00 <ddarius> roderyk: All you have to do is match the types up.
15:29:22 <ddarius> Just doing that by itself can often go a long way in Haskell.
15:30:51 <roderyk> ddarius: sometimes that's easier said than done :) I've been staring at the API for the JSON constructors for an hour and I'm not sure if I would have figured out I need (JSX (toJSX ..)) for every single element when constructing it ;-)
15:34:48 <augustss> olsner: that's not a "bug" I really care about :)
15:40:00 <Stinger_> > encode 5
15:40:01 <lambdabot>   mueval: Prelude.read: no parse
15:40:23 <Stinger_> @ty encode
15:40:25 <lambdabot> Not in scope: `encode'
15:40:47 <Stinger_> @ty Text.JSON.encode
15:40:48 <lambdabot> Couldn't find qualified module.
15:45:16 <DRMacIver> Hm. What on earth is up with the font on hackage?
15:45:34 <dcoutts> DRMacIver: which one, where exactly?
15:46:00 <DRMacIver> dcoutts: The font for the packages listing seems to have changed recently. Either that or my browser is doing something weird
15:46:20 <DRMacIver> Sorry, my browser is doing something weird
15:46:28 <Cale> Yeah... it looks fine here
15:46:40 <dozer> mm, I'm getting a compile-time error: "malformed class assertion"
15:46:47 <DRMacIver> (I closed it and reopened it in a different window to check, but apparently that was insufficient)
15:46:57 <dcoutts> DRMacIver: it's using hackage.css which specifies font-family: sans-serif;
15:47:09 <dozer> instance (Fractional f) => Probability [(c => Proposition c, f)] f where
15:47:10 <dcoutts> DRMacIver: oh ok, good. :-)
15:47:19 <dozer> It seems to be complaining about the c=> clause
15:47:29 <dozer> have I done something very dense?
15:47:35 <dcoutts> dozer: did you mean -> ? rather than =>
15:47:48 <DRMacIver> Hm. Looks like firefox is convinced it should be done at a weird size
15:47:48 <dozer> hum, I meant to forall qualify over c
15:48:13 <dcoutts> dozer: as in [(forall c. Proposition c, f)] ?
15:48:54 <Saizan> just "Proposition c" doesn't do what you want?
15:49:44 <dozer> dcoutts_: that looks better - I will continue to tinker
15:49:51 <dcoutts> dozer: right, it'll be implicitly forall'ed over at the top level, which is probably what you want rather than a local forall
15:50:07 <dcoutts> dozer: ie. try Saizan's suggestion
15:50:18 <dozer> dcoutts_: I mean to make an assoc list where each element could be over a different c
15:50:37 <dcoutts> dozer: ohh, then you need existential quantification
15:51:40 <Saizan> then you need something like data AnyProp = forall c. AnyProp (Proposition c), ..Probability [(AnyProp,f)] f where ..
15:52:14 <dcoutts> or [(forall c. Proposition c -> d, f)]
15:52:31 <dcoutts> (I think)
15:53:10 <Saizan> forall c. (Preposition c -> d) -> d
15:53:27 <dcoutts> oh, yes course
15:53:54 <dcoutts> I should know that, I've been writing about inductive and co-inductive encodings all day
15:54:08 <Saizan> uhm
15:54:16 <dozer> sorry, you lost me somewhere in the ascii art - I've been away from haskell for a few months :)
15:54:17 <Saizan> i'm wrong btw
15:54:47 <Saizan> forall d. (forall c. Preposition c -> d) -> d, right? so the c can be chosen internally
15:55:00 * dcoutts is now totally confused
15:55:09 <Saizan> heh :D
15:55:20 <dcoutts> Saizan: I read this the other day but I don't recall now :-)
15:55:24 <Saizan> dozer: do you know anything about existential types?
15:55:32 <dcoutts> it's the encoding of exists in system f
15:55:39 <Saizan> yeah
15:55:39 <dozer> yes, but I'm very out of practice at actually using them
15:55:56 <Saizan> i'm pretty sure on my latter definition
15:56:54 <Saizan> dozer: the easiest way is to use a datatype like my AnyProp, so you can use the AnyProp constructor to "hide" the exitentially quantified variable
15:57:38 <dcoutts> Saizan: that does sound right, that the forall is inner not top level there
15:59:13 <Saizan> dcoutts: yeah, sicne if i have x :: forall d. (forall c. Preposition c -> d) -> d, then i must pass a function that works for any 'c' to it, granting x the right to choose the type it wants
16:00:33 <bos> @seen dons
16:00:33 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 12h 58m 37s ago.
16:00:48 <bos> is there an easy way to find the current number of packages on hackage
16:00:50 <bos> er, ?
16:01:00 <bos> short of summing the numbers by hand, that is.
16:01:09 <metasyntax> am I alone in being unable to compile Haddock >= 2.0 for GHC 6.8.3 ?
16:01:58 <metasyntax> Haddock 2.0 and 2.1 don't compile, 2.2 and higher requires ghc-paths but that doesn't compile
16:02:16 <metasyntax> :(
16:02:25 <Saizan> metasyntax: what error do you get?
16:02:42 <rwbarton> bos: $ cabal list | grep '^ \*' | wc -l
16:02:42 <rwbarton> 746
16:02:51 <ddarius> ∃ = ¬ ∀ ¬
16:03:14 <metasyntax> For ghc-paths, same as listed as the build failure on Hackage.
16:03:27 <metasyntax> Let me get you the exact error for 2.0, 2.1, just a sec.
16:03:37 <Cale> ddarius: heh, that looks a bit like a crazy Japanese emoticon :)
16:03:43 <bos> i got 830 from schlurping up the heading on hackage.haskell.org
16:04:20 <dcoutts> bos: cabal list --simple-output and then you might need to sed if you want distinct names
16:04:43 <metasyntax> rwanderley: "Constructor `HsModule' should have 7 arguments, but has been given 8"
16:04:54 <metasyntax> oops, sorry, meant rwbarton
16:05:43 <bos> dcoutts: i think the 830 figure will do for a preso slide
16:06:08 <metasyntax> rwbarton: same error for Haddock 2.0 and 2.1
16:06:47 <dcoutts> bos: I get $ cabal list --simple | cut -d' ' -f1 | uniq | wc -l
16:06:47 <dcoutts> 748
16:06:49 <Saizan> metasyntax: the error in the ghc-paths build log is only about the documenation, you can install the package without it
16:07:48 <Saizan> metasyntax: i.e. just doing cabal install ghc-paths should work
16:10:09 <BMeph_> Saizan, metasyntax: Now /that/'s metasyntax! ;)
16:11:50 <metasyntax> Saizan, rwbarton: sorry about the mis-addressing; multitasking = not good for humans
16:11:54 <rwbarton> bos: some packages, like category-extras, are in multiple categories and get counted more than once in the 830 number
16:12:03 <bos> ah, yes.
16:12:05 <metasyntax> Saizan: the error message building from source is "Could not find module `Distribution.Simple.PackageIndex'"
16:12:10 <bos> well, double-counting is no fun.
16:12:49 <dcoutts> bos: I think my method is accurate, I think
16:13:01 <bos> dcoutts: i've used your number, thanks.
16:13:06 <Saizan> metasyntax: on ghc-paths?
16:13:20 <metasyntax> Saizan: yes
16:14:25 <Saizan> metasyntax: which version of Cabal do you have?
16:15:44 <metasyntax> 1.2.4.0 - the one packaged with the GHC 6.8.3 source distribution
16:16:42 <Saizan> metasyntax: you need 1.4 or higher
16:17:46 <dozer> apologies - my client crashed
16:18:03 <Saizan> which is also needed for the recent versions of cabal-install
16:18:27 <Saizan> metasyntax: you can find it on hackage, it installs as any other Cabal package
16:18:37 <dozer> so, nearly there
16:18:46 <dozer> just need an Eq instance for AnyProp
16:19:19 <Saizan> i hope you don't need to know 'c' for it
16:19:36 <dozer> funny you should mention that...
16:19:47 <dozer> Couldn't match expected type `c' against inferred type `c1'
16:19:54 <Saizan> heh :)
16:20:48 <dozer> is there a workaround?
16:20:51 <metasyntax> Saizan: cool, I'm giving it a shot now
16:21:20 <Saizan> mmh, maybe something with Typeable, how is Proposition defined?
16:21:43 <dozer> data Proposition ctxt where ...
16:22:08 <nominolo> @seen swiert
16:22:08 <lambdabot> I saw swiert leaving #haskell 2h 7m 11s ago, and .
16:22:11 <dozer> data AnyProposition where AnyProposition :: Proposition c -> AnyProposition
16:22:13 <Saizan> and the constructors?
16:22:43 <dozer> things like: Unconditioned :: Sentence -> Proposition ctxt
16:23:59 <Saizan> so i guess two Propositions with different ctxt are not equal regardless of the constructors?
16:24:05 <dozer> right
16:24:27 <dozer> if ctxt1 != ctxt2 then the propsitions are not equivalent
16:25:06 <metasyntax> Saizan: OK, I see that in the .cabal file now - using the right version made it work.  Thanks very much!
16:25:35 <Saizan> you could use data AnyProp where Typeable c => Proposition c -> AnyProposition
16:26:02 <Saizan> and then use typeOf and compare the TypeRep
16:26:09 <Saizan> ?type typeOf
16:26:10 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:26:44 <Saizan> the first parameter of typeOf is phantom, btw
16:27:07 <dozer> or perhaps define a class Eq2, with an instance for (Proposition c) (Proposition c) and a fall-through instance for (Proposition c1) (Proposition c2)?
16:27:22 <ddarius> Saizan likes confusingly reusing terminology.
16:27:45 <Saizan> ddarius: about phantom?
16:27:51 <ddarius> Yes.
16:28:30 <Saizan> dozer: the problem is that when you pattern match on two AnyProp there's no way for the typechecker to tell that they have the same 'c' inside
16:28:48 <dozer> oh? it gets elided that early?
16:29:09 <ddarius> dozer: No, that's just the definition of existential quantification.
16:29:26 <ddarius> (or maybe "yes" would've been more appropriate)
16:29:41 <Saizan> you forget about 'c' as soon as you existentially quantify it by applying the AnyProp constructor
16:31:36 <dozer> well, it seems to compile using the instances approach
16:32:39 <Saizan> dozer: can you paste the code?
16:33:06 <dozer> @paste
16:33:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:33:38 <dozer> http://hpaste.org/10250
16:34:46 <lispy> ?seen Cale
16:34:47 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 31m 9s ago.
16:35:00 <Cale> I'm here
16:35:06 <lispy> Cale: I was just wondering if you ever setup a cronjob or similar to restart lambdabot
16:35:27 <lispy> better yet, fix the resource leaks and crashing
16:35:47 <Cale> lispy: I set up a script to kill off copies of mueval which ran amok
16:35:57 <lispy> hehe, okay, that's a start
16:36:04 <lispy> But, what about the memory leakage?
16:36:35 <Cale> Oh, it does look like it's getting rather large, isn't it?
16:36:55 <Cale> I initially thought that removing the log module had mostly fixed the problem.
16:36:57 <Cale> @flush
16:37:46 <lispy> Yeah, my (uneducated) guess at a sure fire way to bound it is to forcibly save everything and re-start lambdabot every 24 (or so) hours.  Is there any reason why this is a bad idea?
16:38:31 <Cale> Doesn't seem like too bad a plan.
16:38:42 <dancor> then you can like vcs state too
16:38:59 <lispy> That's a good idea, daily snapshots
16:39:15 <Cale> I wonder if there are any problems with just sending it a signal to die.
16:39:21 <lispy> (also a good time to rsync that state to c.h.o)
16:39:28 <Cale> (without an explicit flush)
16:39:38 <lispy> Cale: That's my uneducated part.  I'm not sure :)
16:39:45 <Saizan> dozer: right, but that always picks the second Eq2 instance here, i.e. AnyProposition x == AnyProposition x === False
16:40:02 <lispy> Cale: how about telling lambdabot to respond to a particular signal by saving all and exiting?
16:40:15 <Cale> Yeah, that would be cool
16:40:16 <lispy> it could be one of the user defined signals
16:40:19 <dozer> Saizan: oh, does it? that is unfortunate
16:40:38 <ddarius> We should infect half the internet with a botnet that just stores lambdabot's state
16:40:49 <dancor> for safekeeping
16:40:57 <lispy> ddarius: we could use Tahoe
16:41:05 <lispy> ddarius: the distributed file system thing
16:41:13 <Saizan> or happs
16:42:01 <lispy> Cale: that was my next question, BTW.  Did you configure the periodic backups?  I'd had to lose a drive and lose lambdabot too
16:42:20 <Cale> I just push things by hand.
16:42:41 <Cale> Lambdabot's source is stored on c.h.o anyway
16:42:57 <Cale> The state, well, it's not such a big deal to lose some of that.
16:43:04 <lispy> okay, as long as my system going down is not a big deal to being able to restore lambdabot then I'm happy
16:44:49 <lispy> Cale: I may in a few months time switch to a virtual machine with less ram.  At that time lambdabot would be cool to move, but we'd need to figure out how much ram she needs
16:45:21 <Cale> It apparently got up to a bit over 200MB after I left it for a long while.
16:45:23 <lispy> (and if we can augment the physical ram with swap)
16:45:34 <shukhov> can anyone recommend a good prolog implementation?
16:45:43 <lispy> That's not so bad, but the lowest rung machine I'm looking at is something like 360MB
16:46:12 <Cale> shukhov: I haven't really used any prolog extensively, but swipl seems decent.
16:46:12 <lispy> Again, there is no plan to switch yet and I won't until maybe January anyway
16:46:42 <lispy> I used a gnu prolog (forgot the exact name) for a class once, and it was okay
16:47:07 <shukhov> Thanks, just wanted some input so I wouldn't be stuck with a bad one
16:47:08 <Cale> http://www.swi-prolog.org/
16:47:11 <lambdabot> Title: SWI-Prolog's Home
16:47:28 <lispy> oh yeah, I remember hearing good stuff about swi prolog
16:49:30 <Saizan> dozer: yeah, this is how i'd do it however http://hpaste.org/10250#a1
16:50:28 <esteth> Is there a more generic words function? similar to break, but removing the matched element and allowing a custom predicate?
16:51:09 <esteth> I mixed up things there. I meant removing the matched element and doing it for every instance of the match, not just the first
16:51:37 <lispy> ?hoogle breakBy
16:51:37 <lambdabot> Data.ByteString breakByte :: Word8 -> ByteString -> (ByteString, ByteString)
16:51:46 <dozer> Saizan: Ah, thanks for that
16:52:02 <lispy> ?hoogle [a] -> (a -> Bool) -> [[a]]
16:52:03 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
16:52:03 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:52:03 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
16:52:33 <lispy> ?src words
16:52:33 <lambdabot> words s = case dropWhile isSpace s of
16:52:34 <lambdabot>     "" -> []
16:52:34 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:52:35 <esteth> ah. breaks looks to be exactly what I want. I shall have to learn to use hoogle more often :)
16:53:09 <lispy> I'm not sure if breaks is what you want though.  Isn't that something that is part of cabal?  I mean, I thought Distribution.Simple was a cabal thing
16:53:50 <lispy> esteth: If I were implementing it, I would take that definition above of words and generalize it to use a predicate of your choosing
16:53:58 <lispy> or mke the predicate a parameter
16:54:07 <esteth> ah, true. Didn't realise that it wasn't in the prelude. Looks like I'll just implement it myself :)
16:54:28 <dcoutts> lispy: I've no idea what breaks is doing there
16:54:32 <esteth> lispy: I'll go for the latter. I'll need different predicates all over the place
16:55:05 <lispy> the lack of this 'breaks' function is an oversight of the prelude.  Surely we have something in Data.List that does what you want thouh?
16:55:23 <lispy> It just seems like we should, but hoogle didn't find it
16:55:30 <dcoutts> problem is there are so many combinations you might want
16:55:37 <FunctorSalad> haha, chunk time again?
16:55:38 <dcoutts> you can make most using unfoldr and break
16:56:41 <lispy> ?hoogle chunk
16:56:41 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
16:56:41 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
16:56:41 <lambdabot> Data.ByteString.Lazy.Internal chunkOverhead :: Int
16:59:40 <lispy> dcoutts: ah
16:59:52 <lispy> dcoutts: and they would be so similar that it's hard to name them?
17:00:21 <FunctorSalad> hmm, chunk :: (Eq a) => a -> [a] -> [[a]] stands out as highly standard to me
17:00:26 <dcoutts> lispy: yeah a bit. Someone needs to look at it and see if there is any that are obviously more common and useful or general.
17:00:33 <FunctorSalad> usually called "split" or sth
17:01:22 <Cale> I think it should be (a -> Bool) -> [a] -> [[a]]
17:02:15 <dozer> Saizan: that's got me closer - I'm having to push Typeable through the code
17:02:16 <Saizan> then (a -> Bool) -> [a] -> [Either a [a]] so you don't lose the separators :)
17:02:23 <Cale> hmm, or I suppose if you want to split on a multicharacter thing...
17:02:47 <dolio> What do you need the separators for?
17:02:49 <Cale> Well, I suppose at a certain point, the answer is really just to write a parser :)
17:03:34 <dcoutts> Cale: right, but it seems there has to be a useful intermediate point
17:03:57 <dcoutts> most languages have some sort of split, it'd be interesting to look at which meaning(s) they pick
17:04:11 <Cale> Maybe ([a] -> Bool) -> [a] -> [[a]], where the predicate should give True for any list starting with the separator?
17:04:21 <Cale> er, heh
17:04:33 <Cale> That Maybe was the start of my sentence, not a type constructor :)
17:05:41 <Cale> hmm...
17:06:07 <dolio> ([a] -> Bool) [a] -> [[a]] looks expensive.
17:06:15 <Cale> It has the problem that you don't know how many chars to eat though.
17:06:26 <Saizan> most languages just have the inverse of intersperse
17:06:34 <Cale> So it would need to be ([a] -> Integer) -> [a] -> [[a]]
17:06:59 <Cale> (0 => no separator here)
17:07:35 <lispy> ([a] -> ([a], [a])) -> [a] -> [[a]]
17:07:45 <lispy> the first param works like break
17:07:45 <Cale> That'd work :)
17:07:48 <Cale> yeah
17:08:08 <Cale> actually, I like that
17:08:12 <FunctorSalad> the Eq seems simplest and I agree that for more complex things you'd probably want your own parser
17:08:16 <ddarius> split should be the inverse to intercalate
17:08:17 <Cale> Sort of a comultiplication.
17:08:28 <ddarius> or some other such function
17:12:38 <lispy> :t break
17:12:39 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:12:52 <lispy> > break isSpace "This is a sentence"
17:12:53 <lambdabot>   ("This"," is a sentence")
17:13:35 <Cale> :t (second (drop 1) .) . break
17:13:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:13:49 <Saizan> ([a] -> ([a], [a])) -> [a] -> [[a]] also gives fixed-size chunking with splitAt
17:13:51 <dolio> ([a] -> ([a], [a])) -> [a] -> [[a]] is almost unfoldr.
17:14:12 <Cale> I like it :)
17:14:26 <ddarius> Zipper comonad?
17:14:27 <Saizan> yeah, unfoldr + termitation on null
17:15:01 <humasect> haddock: internal Haddock or GHC error: src/Haddock/Interface/Rename.hs:(370,16)-(373,46): Non-exhaustive patterns in case  hm =(
17:15:27 <dolio> At that point you should just work on making it easier to use b -> (a,b) functions with separate stopping predicates.
17:15:51 <TomMD> humasect: Are you using the latest haddock?
17:15:59 <humasect> yep TomMD , 2.2.0
17:16:48 <humasect>  i just finished getting it to like all of my 30+modules , too
17:16:51 <lispy> if chuckBy :: ([a] -> ([a],[a])) -> [a] -> [[a]], when what is the implementation?
17:16:57 <lispy> chunkBy*
17:17:25 <FunctorSalad> let chunk p = ghcCalculateInverse (intersperse p)
17:17:29 <FunctorSalad> =)
17:17:42 <Cale> If the list is empty, give an empty list, if the list is nonempty, apply f to get the first chunk and recurse on the tail.
17:17:49 <lispy> chunkBy b s = case break b s of (c, rest) -> c : chunkBy b rest
17:17:52 <dolio> \f -> unfoldr (\s -> if null s then Nothing else Just (f s))
17:18:00 <Saizan> :t \f -> unfoldr (\xs -> guard (not . null $ xs) >> return (f xs))
17:18:01 <lambdabot> forall a a1. ([a] -> (a1, [a])) -> [a] -> [a1]
17:18:01 <Cale> Er, recurse on the second part, that is :)
17:18:26 <BONUS_> just installed ghc 6.8.2 on a fresh ubuntu install ... when i do :m + Control.Monad.State it says it cant find the module
17:18:27 <BONUS_> wtf
17:18:48 <Saizan> BONUS_: install libghc6-mtl-dev
17:18:50 <lispy> BONUS_: ubuntu probably needs an additional package to get that module
17:18:52 <ddarius> Control.Monad.State is in the mtl library
17:18:55 <Saizan> BONUS_: and other such packages
17:19:14 <BONUS_> ah hmm
17:19:19 <BONUS_> i just did apt-get install ghc6
17:19:21 <Saizan> (assuming you installed ghc via apt-get)
17:19:25 <BONUS_> what else would i need
17:19:25 <BONUS_> yeah
17:19:35 <Cale> Right, it doesn't require all the library packages.
17:19:41 <BONUS_> ah
17:19:44 <dolio> I'd argue you'd instead define: 'stopAt p f x = guard (not $ p x) >> return (f x)' and then use '\f -> unfoldr (stopAt null $ f)'
17:19:58 <lispy> ?let chunkBy = \f -> unfoldr (\xs -> guard (not . null $ xs) >> return (f xs))
17:19:59 <lambdabot>  Defined.
17:20:01 <Saizan> BONUS_: apt-cache search libghc6
17:20:10 <lispy> > chunkBy isSpace "This is a sentence."
17:20:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
17:20:15 <BONUS_> w00t, thanks
17:21:16 <Saizan> > chunkBy (break isSpace) "This is a sentence."
17:21:17 <lambdabot>   ["This","","","","","","","","","","","","","","","","","","","","","","","...
17:21:38 <Saizan> > chunkBy (span isSpace) "This is a sentence."
17:21:39 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
17:21:39 <dozer> sweet - I think I have type-safe bayes stats :)
17:21:46 <Saizan> bah
17:22:09 <BONUS_> wait so hmm
17:22:14 <BONUS_> how do i get the full library then
17:22:24 <Saizan> > chunkBy (second (drop 1) . break isSpace) "This is a sentence."
17:22:25 <lambdabot>   mueval: Prelude.read: no parse
17:22:28 <humasect> haddock 2.2.2 does not build with 6.8.3, i will give up this third time to apply haddock to this project
17:22:35 <Saizan> > chunkBy (fmap (drop 1) . break isSpace) "This is a sentence."
17:22:36 <lambdabot>   ["This","is","a","sentence."]
17:22:40 <humasect> be well all ~ thanks again
17:22:59 <lispy> ?let chunkBy' _ [] = []; chunkBy' b s = case b s of (c, rest) -> c : chunkBy' b rest
17:23:00 <lambdabot>  Defined.
17:23:05 <lispy> :t chunkBy'
17:23:06 <lambdabot> forall t a. ([t] -> (a, [t])) -> [t] -> [a]
17:23:20 <lispy> > chunkBy' (break isSpace) "this is a sentence"
17:23:21 <lambdabot>   ["this","","","","","","","","","","","","","","","","","","","","","","","...
17:23:42 <Saizan> lispy: break doesn't discard the separator
17:23:48 <lispy> oh
17:23:55 <Saizan> break isSpace "this is a sentence"
17:23:56 <dolio> Yeah, that's kind of a pain.
17:23:58 <Saizan> > break isSpace "this is a sentence"
17:23:59 <lambdabot>   ("this"," is a sentence")
17:24:14 <ddarius> (F a -> Zipper[F] a) -> (F a -> F^2 a) ?
17:24:18 <FunctorSalad> > partition isSpace "can has sentence"
17:24:19 <lispy> oh hence why words does the dropWhile
17:24:19 <lambdabot>   ("  ","canhassentence")
17:24:36 <FunctorSalad> oops
17:24:54 <lispy> :t split
17:24:55 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
17:25:22 <FunctorSalad> bogoChunk :: (RandomGen g) => ... ;-)
17:26:31 <Saizan> > (&&&)
17:26:32 <lambdabot>       Overlapping instances for Show (a b c -> a b c' -> a b (c, c'))
17:26:32 <lambdabot>        ...
17:26:42 <lispy> I don't have any good ideas how to work round this.  break seems okay and chuckBy's type seems riht
17:27:00 <lispy> But, you somehow how need break to consume somuthing
17:27:11 <dozer> thanks for the help guys - see you about
17:27:49 <lispy> I guess if your break returns ([], rest) where rest /= [], then you consume one element and try again?
17:27:57 <Saizan> lispy: yeah hence my fmap (drop 1)
17:28:11 <lispy> I missed that
17:28:22 <Saizan> > chunkBy (fmap (drop 1) . break isSpace) "This is a sentence."
17:28:23 <lambdabot>   ["This","is","a","sentence."]
17:28:45 <lispy> But it would be nice for fmap (drop 1) to be part of chunkBy
17:29:09 <FunctorSalad> > sepBy1
17:29:10 <lambdabot>   mueval: Prelude.read: no parse
17:29:15 <FunctorSalad> @type sepBy1
17:29:16 <lambdabot> Not in scope: `sepBy1'
17:29:33 <lispy> ?let chunkBy' _ [] = []; chunkBy' b s = case b s of ([], r:est) -> chunkBy' b est; (c, rest) -> chunkBy' b rest
17:29:34 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
17:29:51 <xpika> the try function doesn't seem to be working
17:29:55 <lispy> ?let chunkBy'' _ [] = []; chunkBy'' b s = case b s of ([], r:est) -> chunkBy'' b est; (c, rest) -> chunkBy'' b rest
17:29:56 <lambdabot>  Defined.
17:30:04 <xpika> parse (count 5 (try $ noneOf "n")) [] "abcnne"
17:30:08 <xpika> > parse (count 5 (try $ noneOf "n")) [] "abcnne"
17:30:09 <lambdabot>   mueval: Prelude.read: no parse
17:30:14 <lispy> > chunkBy'' (break isSpace) "This is a sentence"
17:30:15 <lambdabot>   []
17:30:41 <dolio> Heh, r:est. Nice.
17:30:49 <xpika> the error is unexpected "n"
17:31:39 <Saizan> xpika: try is still supposed to give you an error, it just doesn't consume the input when that happens
17:31:40 <lispy> oh I see the bug
17:31:59 <rwbarton> xpika: try is for when you want parsec to be able to backtrack, so it can try a second alternative.  But you didn't give parsec any alternative.
17:31:59 <lispy> ?let chunkBy''' _ [] = []; chunkBy''' b s = case b s of ([], r:est) -> chunkBy''' b est; (c, rest) -> c : chunkBy''' b rest
17:32:00 <lambdabot>  Defined.
17:32:05 <lispy> > chunkBy''' (break isSpace) "This is a sentence"
17:32:07 <lambdabot>   ["This","is","a","sentence"]
17:32:10 <xpika> Saizan: can i supress the error?
17:32:20 <lispy> :t chunkBy'''
17:32:21 <lambdabot> forall t1 t. ([t1] -> ([t], [t1])) -> [t1] -> [[t]]
17:34:01 <dblazakis> xpika, how about something like many (anyChar >>= return .  filter (/= "n") . return) >>= return . concat
17:34:33 <Saizan> xpika: you can write (try (noneOf "n") <|> return somethingOfTheRightType) but then count 5 will count 'n' as one of the chars
17:35:25 <dblazakis> :t Text.ParserCombinators.Parsec.Char.anyChar
17:35:26 <lambdabot> forall st. Text.ParserCombinators.Parsec.Char.CharParser st Char
17:35:42 <dblazakis> :t Text.ParserCombinators.Parsec.parse
17:35:43 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
17:35:48 <lispy> interestingly, chunkBy is basically a parser
17:35:52 <ddarius> count 5 (many (satisfy (=='n')) >> satisfy (/='n')))
17:35:53 <lispy> I mean when you look at the type
17:37:37 <rwbarton> xpika: I think we all have different ideas of what you're trying to do
17:38:21 <dblazakis> > Text.ParserCombinators.Parsec.parse Text.ParserCombinators.Parsec.Char.anyChar [] "abcnnnd"
17:38:22 <lambdabot>       Not in scope: `Text.ParserCombinators.Parsec.parse'
17:38:22 <lambdabot>      Not in scope: ...
17:39:08 <FunctorSalad> lispy: "parseTest (sepBy (many1 alphaNum) (try spaces))" seems to do it
17:40:47 <FunctorSalad> or "parseTest (sepBy (many alphaNum) (try space))" which seems kinda the same
17:42:49 <lispy> :t parseTest
17:42:50 <lambdabot> Not in scope: `parseTest'
17:43:20 <FunctorSalad> it takes a parser and a string and runs the parser on it
17:44:43 <FunctorSalad> by the way, why does "notFollowedBy" have this weird signature? seems to be the only function where the "t" of "Stream" appears on the right, which gives me errors
17:45:00 <FunctorSalad> notFollowedBy :: (Show t, Stream s m t) => ParsecT s u m t -> ParsecT s u m ()
17:45:30 <FunctorSalad> which for the case of parsing strings means that t must be Char :-(
17:45:41 <FunctorSalad> so I can only check for not being followed by a single char
17:46:24 <xpika> is it common to parse inside a parse when using parsec?
17:49:08 <rwbarton> FunctorSalad: how about  do { x <- try (string "bar" >> return True) <|> return False ; when x mzero }
17:49:21 <lispy> :t isAlpha
17:49:22 <lambdabot> Char -> Bool
17:50:59 <rwbarton> FunctorSalad: or  notFollowedBy (string "bar" >> return 'x')
17:52:37 <FunctorSalad> rwbarton: heh, didn't think of that last one, but seems odd
17:53:26 <FunctorSalad> maybe it's a bug, maybe the t is there for a reason
17:53:45 <rwbarton> It gets shown in the error message
17:53:51 <rwbarton> (seems like not a very good reason)
17:54:23 <FunctorSalad> hmm but other commands show arbitrary error messages for arbitrary types too, don't they?
17:54:38 <FunctorSalad> cancel the first "arbitrary"
17:55:05 <FunctorSalad> I don't understand how your first suggestion works though
17:55:53 <FunctorSalad> shouldn't it be do { try (string "bar" >> fail) <-> return () }  ?
17:56:05 <rwbarton> I tried that at first, but the try eats the fail
17:56:26 <FunctorSalad> (I mean <|>, not <->)
17:57:12 <FunctorSalad> the notFollowedBy calls "unexpected" there rather than "fail"
18:01:28 <jsnx> does string concatenation result in copies?
18:02:01 <FunctorSalad> no idea but I guess the answer will be "use bytestring" ;-)
18:02:11 <ddarius> jsnx: No
18:02:18 <ddarius> Well yes.
18:02:19 <FunctorSalad> (if you're concerned about performance)
18:02:41 <ddarius> By no I meant yes, except for the last one or the latter one if you meant (++)
18:02:46 <jsnx> i just want to avert performance disaster :)
18:03:17 <jsnx> so concat [string0, string1,...] results in one copy?
18:03:29 <Saizan> you create new cons cells with (++) for the first string, but depending on your use the cons cells might get optimized away anyhow
18:03:31 <FunctorSalad> without optimization it would seem to be at least O(length(first string)), since it needs to iterate through the list first
18:03:35 <lispy> :index nubBy
18:03:37 <ddarius> jsnx: It will copy all but the last one.
18:03:42 <jsnx> !!
18:03:44 <jsnx> yikes
18:03:48 <lispy> :hoogle nubBy
18:03:55 <lispy> oh
18:03:56 <ddarius> jsnx: It's not really a big deal.
18:04:00 <lispy> ?index nubBy
18:04:00 <lambdabot> Data.List
18:04:13 <ddarius> concat is a reasonably "fast" operation
18:04:33 <FunctorSalad> maybe I'm forgetting about lazyness
18:04:53 <Olathe> @info nubBy (==) [1, 1..]
18:04:59 <Olathe> @help info
18:05:00 <jsnx> ddarius: well, when my strings are huge it is a big deal, right?
18:05:01 <lambdabot> nubBy (==) [1, 1 ..]
18:05:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:05:10 <Olathe> What does info do ?
18:05:10 <ddarius> jsnx: Not really.
18:05:35 <Saizan> Olathe: nothing, it's just spell corrected to undo or something like that
18:05:37 <rwbarton> jsnx: Depends on what you are doing with the result of the concat
18:05:37 <FunctorSalad> maybe due to lazyness the first string never gets built?
18:05:38 <mm_freak_> is there a way to write an integer square root function consistently with type (Monad m => Integer -> m Integer)?
18:05:39 <ddarius> concat is lazy, so as long as you don't keep hold of each of the substrings, they will be garbage collected as soon as the copy is finished being made.
18:05:43 <Olathe> Oh.
18:05:56 <jsnx> rwbarton: printing it
18:06:07 <rwbarton> jsnx: Then you're fine, concat will run in constant space
18:06:30 <Olathe> mm_freak_: Can't you just do return.f ?
18:06:38 <jsnx> rwbarton: well, one more question
18:06:48 <ddarius> If you wrote, readFile "/dev/hda" >>= writeFile "foo" . concat . map (:[]) it would run in constant space.
18:06:48 <mm_freak_> Olathe: i'd like it to act differently for different monads
18:06:53 <jsnx> rwbarton: say i define a function that does the concatenation
18:06:59 <mm_freak_> for Maybe it should return the positive root or Nothing
18:07:03 <jsnx> rwbarton: then i use it in a context where the result is printed
18:07:07 <mm_freak_> for the list monad, it should return all roots
18:07:13 <jsnx> rwbarton: does this still run in constant space?
18:07:21 <dancor> jsnx: if it's just f = concat, there is not difference
18:07:27 <rwbarton> jsnx: Most likely.
18:07:44 <mm_freak_> for identity-like monads (like IO, ST and the identity monad itself), i'd like it to return the positive root or bottom
18:07:44 <rwbarton> jsnx: What you need to worry about is if there is another pointer to the result of concat, that will still be alive after the call to print.
18:07:46 <Saizan> mm_freak_: use mplus
18:07:54 <jsnx> rwbarton: aha
18:07:57 <Saizan> mm_freak_: and mzero
18:07:57 <mm_freak_> Saizan: good point, thanks
18:08:35 <ddarius> jsnx: Basically, you are not going to end up with two copies in memory unless your code (is written in such a way that it) needs to.
18:11:56 <rwbarton> (Maybe it's worth mentioning that this is a property of lazy evaluation, not some compiler optimization)
18:12:58 <ddarius> rwbarton: Technically speaking, lazy evaluation -is- a compiler optimization for Haskell.
18:13:12 <ddarius> But that's being pedantic in a confusing way.
18:13:50 <rwbarton> Right, it's specified by what everyone knows the report means in practice. :)
18:14:00 <dancor> or a "language optimization" since it's not compilerific
18:14:52 <ddarius> dancor: My point is that it is compiler specific.  You have have non-lazy Haskell implementations.
18:14:59 <mm_freak_> Saizan: ST s is not a MonadPlus instance…  anything i could do about it?
18:15:03 <dancor> ddarius: serious?
18:15:39 <dancor> i thought the whole point of haskell was to be lazy and pure-functional.  and if you aren't lazy you might as well be doing ml or something
18:15:43 <rwbarton> s/have have/could theoretically have/?
18:15:50 <ddarius> dancor: The Report only specifies that Haskell is "non-strict."  Call-by-name is a perfectly valid implementation mechanism (as well as some others)
18:15:56 <dolio> You could implement haskell as call by name.
18:16:07 <dolio> Or optimistic evaluation has been tried, for instance.
18:16:08 <ddarius> rwbarton: Yes.
18:16:25 <dolio> Where you start evaluating thunks right away, but stop after a while.
18:16:31 <newsham> informally people often use "lazy" to mean "non-strict"
18:16:54 <Olathe> I use lazy to mean
18:17:00 <ddarius> newsham: Yes, but for the example it makes a difference.
18:17:25 <newsham> ahh, thats what i get for entering in the middle of a conversation.
18:18:15 <Saizan> mm_freak_: fro your purposes you could write one with mzero = fail ""; mplus = const
18:18:18 <dancor> Olathe: i just got it
18:18:55 <mm_freak_> Saizan: that appears inconsitent to me, at least for a library, since other libraries could make ST s a MonadPlus instance
18:19:01 <mm_freak_> probably in a different way
18:19:20 <dolio> Isn't the whole point that ST shouldn't be a MonadPlus?
18:19:50 <Saizan> ah, sure, if it's in a library then you shouldn't do it
18:20:16 <ddarius> Actually, for this particular example it may not make a difference, but I'm sure I could construct a related example where it would.
18:20:33 <Saizan> why not just go with the simplest type then and use a list? it has all the information you need to convert it to other monads
18:21:02 <Saizan> s/convert it/convert the result/
18:21:20 <mm_freak_> dolio: why?  any problem with mzero being bottom?
18:21:31 <dolio> It's nasty.
18:21:34 <mm_freak_> Saizan: i'm just playing around
18:21:40 <dolio> Just like fail being in Monad.
18:22:09 <mm_freak_> dolio: sure, but is there anything formally wrong with that?
18:22:34 <dolio> As far as MonadPlus deals with failure, mplus is supposed to recover from such failures.
18:22:45 <dolio> Provided the alternative doesn't also fail.
18:23:05 <Saizan> mm_freak_: mzero should be an identity for mplus, but if mzero is bottom you can't satisfy that
18:23:14 <mm_freak_> true
18:25:57 <dolio> There's no point in having a separate type class if you're going to put everything in there, sticking bottom in for things that logically shouldn't be in the class.
18:26:54 <mm_freak_> dolio: it makes sense now, as mzero must not be bottom
18:27:18 <mm_freak_> and i wouldn't know how to interpret ST as a MonadPlus in another way
18:30:07 <mm_freak_> unless we start to distinguish different types of bottom, that is…  if we had distinct "not calculatable" and "not calculated" bottoms, ST could be a MonadPlus
18:31:18 <lispy> Guys, I found that an, anan, er and tang are all dictionary 'words' that are both regular palindroms and palindroms under rot13
18:31:23 <lispy> I thought I should share that
18:32:11 <dolio> None of those are palindromes, are they?
18:34:08 <andyjgill> Evening all.
18:34:48 <dolio> > let rot13 = chr . (+97) . (`mod` 26) . (+13) . subtract 97 . ord in map rot13 "an"
18:34:49 <lambdabot>   "na"
18:34:55 <dolio> > let rot13 = chr . (+97) . (`mod` 26) . (+13) . subtract 97 . ord in map rot13 "tang"
18:34:55 <dino-> My understanding of palindrome is like: radar
18:34:56 <lambdabot>   "gnat"
18:35:04 <dino-> i.e. spelled backwards is identical to forwards.
18:35:09 <dolio> Yeah.
18:35:09 <Olathe> > let rot13 = chr . (+97) . (`mod` 26) . (+13) . subtract 97 . ord in map rot13 "..."
18:35:10 <lambdabot>   "ooo"
18:35:23 <dino-> But yeah, I see that my good man lispy seems to be saying that they are still words when spelled backwards.
18:35:47 <dolio> That would make sense. Although I wasn't aware than na and re were words.
18:35:53 <dino-> Surely that must have a name, that reversed-is-still-a-word
18:36:02 <dolio> Of course, I've never seen anan, either.
18:36:05 <rwbarton> re is as in do re mi
18:36:13 <Olathe> I think any two-letter thing is probably a word.
18:36:13 <FunctorSalad> "re" is used to indicate that you're back from being afk
18:36:17 <dolio> Ah.
18:36:22 <Olathe> Oh.
18:36:22 <FunctorSalad> (in german at least)
18:36:29 <FunctorSalad> (although it's not a german word either)
18:36:32 <dino-> Olathe: qx
18:36:45 <Olathe> Qx to you too !
18:36:51 <rwbarton> FunctorSalad: Wouldn't saying anything at all indicate that? :)
18:37:19 <mm_freak_> interestingly, the german "re" is actually short for the english "returned"
18:37:25 <FunctorSalad> rwbarton: hmm, it's also a greeting... maybe it's short for "re-hi"
18:37:30 <Saizan> gnat?
18:37:37 <FunctorSalad> a re-greeting, I mean
18:37:39 <Olathe> Gnats are annoying.
18:37:42 <dino-> Saizan: small flying bug
18:37:49 <dino-> Small enough to get thorugh window screens
18:37:56 <Olathe> Gnus are annoying, too.
18:38:10 <dolio> They're less common than gnats, though.
18:38:21 <Olathe> They can fit through window screens, though.
18:38:24 <FunctorSalad> "re" is also pronounced exactly like "reh", which denotes a small deer
18:38:31 <Olathe> The screens don't do too well after that, though.
18:38:37 <mm_freak_> why is all GNU stuff named after some annoying animal/insect?
18:38:53 <mm_freak_> GNU, gnus, gnats, …
18:38:53 <Olathe> Because GNU is an animal screamed in all-caps.
18:38:55 <FunctorSalad> (or maybe the females, not the young)
18:38:57 <dolio> Gnus aren't insects, actually.
18:39:03 <dolio> They're large mammals.
18:39:08 <Olathe> Of course.
18:39:08 <dino-> gnatu
18:39:19 <Olathe> That's why they don't leave the screens they go through in good shape.
18:39:26 <dolio> Heh.
18:40:14 <dolio> Gimp?
18:40:22 <FunctorSalad> gawk
18:40:34 <dolio> Yeah, that's a verb.
18:40:40 <Olathe> Agnoying.
18:40:41 <FunctorSalad> it's also GNU awk
18:40:45 <FunctorSalad> ;-)
18:42:00 <dolio> Man, the GNU gnu is ripped: http://www.gnu.org/graphics/gnu-and-penguin-color-300x276.jpg
18:42:26 <pastorn> @type fail
18:42:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
18:42:36 <Olathe> @hoogle modpower
18:42:36 <lambdabot> No results found
18:42:41 <Olathe> @hoogle powermod
18:42:41 <lambdabot> No results found
18:42:51 <dolio> Doesn't exist.
18:42:58 <Olathe> Ahh :(
18:43:04 <Olathe> Shouldn't be too hard to write, I guess.
18:43:21 <dolio> I bet it's in GMP, though. Someone should make a library pulling in some more of its functions.
18:43:28 <ddarius> Olathe: Just write a mod newtype and use ^
18:43:31 <FunctorSalad> dolio, why is fail in Monad evil?
18:43:38 <FunctorSalad> (IIRC you said that)
18:43:46 <dolio> Because not all monads have an appropriate implementation of it.
18:44:05 <dino-> heh, ripped
18:44:07 <dolio> So it just defaults to bottom in many cases, and causes bugs in programs.
18:44:19 <FunctorSalad> hmm, I see
18:45:39 <dolio> It occasionally causes library issues, too.
18:45:50 <dolio> For instance, Either e isn't declared a monad, despite being one.
18:46:36 <dolio> Because to implement a nice fail, you need to place constraints on e so that you have a function :: String -> e.
18:47:04 <dolio> So instead you have to import Control.Monad.Error from mtl, and it's only declared a monad for Error e => ....
18:48:06 <dolio> But Either e fits the mathematical definition of a monad regardless of what e is.
18:49:07 <FunctorSalad> *nod* -- I wasn't aware that fail produced a monadic value, I thought it was like "error"
18:49:32 <FunctorSalad> of course that changes the mathematical meaning
18:49:41 <FunctorSalad> (the former)
18:50:50 <dolio> The reason for introducing fail was to keep pattern matching in monads convenient.
18:51:19 <dolio> Pre-98, you could do "(a,b,c) <- m" in do notation, and it would be recognized that that couldn't fail except for bottom...
18:51:36 <dolio> So there was no reason to require failure-in-the-monad.
18:52:25 <dolio> With 98, they wanted to get rid of such a notion of "unfailable patterns", but wanted to still be able to match like that with just a Monad constraint (instead of MonadPlus), so they added fail.
18:53:09 <dolio> But it hasn't been a particularly popular decision.
18:53:58 <FunctorSalad> what is m there?
18:54:07 <dolio> Some monadic computation.
18:54:34 <dolio> m :: Monad m => m (a,b,c)
18:55:46 <dolio> For instance, pre-98 (1.4 at least), "Just a <- m" would require a MonadZero constraint.
18:55:57 <dolio> Because that pattern can be refuted by something other than bottom.
18:56:21 <FunctorSalad> I thought incomplete patterns just threw runtime errors, with or without involvement of a Monad?
18:56:55 <dolio> When you match in do-notation like that, they fail in the monad.
18:57:15 <dolio> > do Just a <- [Nothing] ; return a
18:57:16 <lambdabot>   []
18:57:18 <FunctorSalad> good to know, I wouldn't expect that
18:57:30 <Toxaris> FunctorSalad: it's a feature of do notation, not of monads
18:57:45 <Toxaris> FunctorSalad: (and of list comprehensions)
18:57:52 <dblazakis> Are there kind variables in haskell? http://hpaste.org/10251
18:58:05 <dolio> No, no kind variables.
18:59:27 <waynemokane> hi friends. Mr.  "Trying to Build GHC in His Funky Work Environment" here
18:59:33 <Toxaris> @undo do Just a <- [Nothing] ; return a
18:59:34 <lambdabot> [Nothing] >>= \ b -> case b of { Just a -> return a; _ -> fail ""}
18:59:51 <dolio> Although I don't see any kinds in that paste, off hand.
19:00:05 <FunctorSalad> Toxaris: ahh
19:00:22 <waynemokane> anyone have a clue about a gcc-style error thrown by ghc - "directives may not be used inside a macro argument"?
19:00:28 <waynemokane> full paste:    http://hpaste.org/10252
19:00:59 <FunctorSalad> > (\(Just a) -> return a) `liftM` [Nothing]
19:01:00 <lambdabot>       No instance for (Show (m t))
19:01:00 <lambdabot>        arising from a use of `show' at <in...
19:01:39 <dblazakis> dolio: well, yeah... i'm trying to instantiate a type like... (a, (a2, (a3, Int))) and bind that to a type variable for a function signature using the type system
19:01:41 <FunctorSalad> > (\(Just a) -> return a) `liftM` [Just 1, Just 2]
19:01:42 <lambdabot>       No instance for (Show (m t))
19:01:42 <lambdabot>        arising from a use of `show' at <in...
19:01:53 <FunctorSalad> > (\(Just a) -> a) `liftM` [Just 1, Just 2]
19:01:55 <lambdabot>   [1,2]
19:01:56 <dblazakis> dolio: a -> a will assume a is of kind * right?
19:02:03 <FunctorSalad> > (\(Just a) -> a) `liftM` [Nothing]
19:02:05 <lambdabot>   mueval: Prelude.read: no parse
19:02:05 <lambdabot>  mueval: [*** Exception: /tmp/90974632935848...
19:02:07 <dolio> I believe so.
19:02:09 <FunctorSalad> ouch
19:02:54 <dblazakis> so that's where i'm running to a problem... not really kind variables, but type variables of higher orders? (does that even make sense?)
19:04:11 <Olathe> > let modPower n power modulus = foldr1 (\a b -> mod (a*b) modulus) $ zipWith (^) repeatedSquaring binPower where binPower = (map (flip mod 2).takeWhile (>0).iterate (flip div 2)) power; repeatedSquaring = iterate (\x -> mod (x*x) modulus) n in modPower 2 (2^100) 10
19:04:13 <lambdabot>   6
19:04:56 <Olathe> > let modPower n power modulus = foldr (\a b -> mod (a*b) modulus) 1 $ zipWith (^) repeatedSquaring binPower where binPower = (map (flip mod 2).takeWhile (>0).iterate (flip div 2)) power; repeatedSquaring = iterate (\x -> mod (x*x) modulus) n in modPower 2 0 10
19:04:57 <lambdabot>   1
19:08:25 <inimino> hackage is down?
19:15:34 <jeffz> inimino: either that or really really slow...
19:18:57 <roconnor> any libs for making https connections?
19:19:29 <jeffz> hm, it would be nice if cabal-install also built docs and stashed them in .cabal somewhere so I had something to browse when hackage is down
19:19:30 <inimino> there's a curl binding
19:20:05 <inimino> jeffz: or if there was a mirror up somewhere
19:20:15 <roconnor> I suppose ideally there would be a HTTP-3000 socket interface for SSL
19:21:03 <roconnor> I wonder if there is enough in crypto to build such an interface
19:21:11 <inimino> roconnor: I think libcurl is a lot more robust, unless you want to handle things like redirects manually
19:21:33 <roconnor> I suppose you are right ...
19:22:10 <roconnor> hmm, I don't see SSL anything in crypto anyways
19:23:17 <ddarius> jeffz: cabal haddock
19:23:56 <jeffz> ddarius: I'm aware of cabal haddock, it's not the same as cabal install generating the docs for all of those packages I installed a few weeks ago.
19:24:49 <xpika> success ! (many1 (try $ noneOf "n") <|> many anyChar)
19:26:29 <brweber2> are there any haskell conferences?  any recommendations?
19:26:30 <roconnor> I'm reading an old haskell-cafe thread on the slowness of sha1 in crypto
19:26:42 <ddarius> xpika: That doesn't read exactly five non-"n" characters.
19:27:05 <xpika> ddarius: i just realized
19:27:21 <roconnor> I want to scream out: "No, It's the Data.Bits code is the problem; it is really slow to check 8<32 for every bit operation!"
19:27:30 <roconnor> alas, I can't scream back in time
19:27:43 <xpika> neither does parse (many1 (try $ noneOf "n") <|> count 5 anyChar) [] "abcdef"
19:28:07 <roconnor> I think dons said that this was fixed in a recent GHC
19:28:25 <roconnor> I wonder if sha1 is faster now
19:29:06 <roconnor> so important to profile
19:29:08 <ddarius> xpika: You haven't been clear on the exact specification you want, but I gave you a function that will parse exactly five characters separated by any amount of 'n's
19:29:23 <roconnor> Slowness is almost never where I think it is
19:29:59 <brweber2> does the thread claim that the sha1 implementation is abnormally slow?  b/c the algorithm isn't designed to be fast by my understanding...
19:31:09 <Olathe> I think it would mean much slower than a C one.
19:31:14 <Olathe> But I don't know.
19:34:50 <xpika> parse (count 5 (many (satisfy (=='n')) >> satisfy (/='n'))) [] "abcdn" gives unexpected line end
19:35:09 <inimino> how can I get ghci to put the whole module (not just the exports) in scope once I've already compiled?
19:35:26 <ddarius> Add >> eof to the end of the parser.
19:35:35 <ddarius> Actually, that should give that error.
19:36:05 <ddarius> It expects five characters that aren't 'n'.  There are only four there.
19:36:55 <Olathe> It might eliminate those.
19:37:29 <xpika> ddarius: im parsing binary and the fields have fixed widths but the data inside in variable
19:37:43 <xpika> is* variable
19:39:33 <lispy> maybe it's not realy fair to call tang a palindrom so much as it can be reversed by applying rot13
19:39:47 <lispy> I just thought palindrom was the closest concept
19:41:27 <dolio> You're still talking about that? That was like an hour ago. :)
19:42:47 <marcot> Good evening.  I'm having a problem with Cabal.  I'm trying to build a package which depends on HSH.  I've added it to build-depends, but I'm still getting:
19:42:58 <marcot>     Could not find module `HSH':
19:42:58 <marcot>       it is a member of package HSH-1.2.6, which is hidden
19:43:24 <lispy> marcot: did you re-run configure?
19:43:44 <lispy> marcot: to be extra paranoid you could clean, configure and build
19:44:10 <marcot> lispy: yes, I've run it all.
19:44:46 <marcot> Ok, I got it.
19:44:50 <lispy> oh?
19:44:59 <marcot> I added it to the library section.
19:45:08 <marcot> I thought it could be before it.
19:45:40 <marcot> lispy: thanks anyway.
19:46:37 <lispy> Are witness types really different than phantom types?
19:47:54 <lispy> I guess witness types are an application of phantom types?
19:52:41 <newsham> ?let rot m xs = let f n = chr.(+n).(`mod` 26).(+m).(subtract n).ord; r ch | isUpper ch = f 65 ch | isLower ch = f 97 ch | otherwise = ch in map r xs
19:52:42 <lambdabot>  Defined.
19:52:55 <newsham> > reverse . rot 13 $ "tang"
19:52:56 <lambdabot>   "tang"
19:53:20 <Olathe> Eww.
19:54:04 <lispy> > reverse . rot 13 $ "gnat"
19:54:05 <lambdabot>   "gnat"
19:54:18 <newsham> > rot 13 "tang"
19:54:19 <lambdabot>   "gnat"
19:54:20 <Olathe> @let omg = reverse.rot 13
19:54:21 <lambdabot>  Defined.
19:54:25 <Olathe> > omg "gnat"
19:54:26 <lambdabot>   "gnat"
19:55:27 <Olathe> @check \x -> omg x /= x
19:55:28 <lambdabot>  Terminated
19:55:33 <Olathe> Terminated ?
19:55:34 <Olathe> @check \x -> omg x /= x
19:55:35 <lambdabot>  Terminated
19:55:38 <Olathe> Bah.
19:55:56 <Olathe> @pl \x -> omg x /= x
19:55:57 <lambdabot> (/=) =<< omg
19:56:29 <dmwit> ap (/=) omg
19:56:37 <dmwit> ?pl \x -> x /= omg x
19:56:37 <lambdabot> ap (/=) omg
19:56:42 <waynemokane> can you derive Eq for free in algebraic types?
19:56:49 <dmwit> yes
19:57:17 <dmwit> waynemokane: Wait, you mean in GADTs?  Or just in the usual data declarations?
19:57:42 <waynemokane> like this: it doesn't "just work"... I'm sure to be missing something obvious
19:57:43 <waynemokane> data Portfolio = Portfolio TeamName Double Double [Position]   deriving (Show, Eq)
19:58:00 <waynemokane> wait I'm stupid, nm
19:58:07 <lispy> waynemokane: TeamName and Position need to derive Eq
19:58:20 <waynemokane> lispy: bingo  :)
19:58:21 <lispy> er instance it really
19:59:17 <adu> YEY
19:59:17 <adu> the Haskell talk went very well :)
19:59:27 <newsham> http://www.thenewsh.com/~newsham/x/machine/palin13.hs
19:59:31 <dmwit> adu: Great!
19:59:35 <Cale> adu: Was it recorded at all?
19:59:42 <Cale> adu: What did you talk about?
19:59:45 <newsham> > reverse $ rot 13 "ravine"
19:59:46 <lambdabot>   "ravine"
19:59:59 <dmwit> That's a pretty good one.
20:00:09 <newsham> also averin, grivet, rebore
20:00:19 <adu> Cale: no, not recorded, half was intro, half was about (darcs, parsec, xmonad, yi)
20:00:26 <Cale> ah, okay :)
20:00:27 <dmwit> Rebore is good, but the others are less impressive, I think.
20:00:39 <adu> Cale: but at the end 3 people asked questions about type-classes
20:00:40 <newsham> i like ravine best
20:01:05 <adu> Cale: calug.org
20:07:40 <adu> :t rot
20:07:42 <lambdabot> Int -> [Char] -> [Char]
20:08:31 <Olathe> How do you get that @check to work ?
20:08:38 <Olathe> Or, rather, why is it failing ?
20:08:45 <adu> @check (\_ -> True)
20:08:47 <lambdabot>   "OK, passed 500 tests."
20:09:02 <Olathe> @check \x -> omg x /= x
20:09:03 <lambdabot>  Terminated
20:09:11 <Cale> @check \x -> L.omg x /= x
20:09:11 <lambdabot>       Failed to load interface for `L':
20:09:11 <lambdabot>        Use -v to see a list of the fi...
20:09:12 <Olathe> > omg "gnat"
20:09:13 <lambdabot>   "gnat"
20:09:14 <Cale> hmm
20:09:19 <Cale> I think it's simply not in scope.
20:09:21 <Olathe> @check -v
20:09:21 <lambdabot>       No instance for (Testable Expr)
20:09:21 <lambdabot>        arising from a use of `myquickch...
20:09:34 <Olathe> Bah.
20:09:37 <lispy> Hmm..
20:09:40 <Olathe> @check the scope
20:09:40 <lambdabot>  Terminated
20:09:49 <lispy> I'm looking for a citation for type witnesses, somewhere they've been discussed in the literature
20:10:02 <lispy> I see the Haskellwiki mentions them but with no citation
20:10:11 <adu> lispy what's a type witness?
20:10:48 <Olathe> > let rot m xs = let f n = chr.(+n).(`mod` 26).(+m).(subtract n).ord; r ch | isUpper ch = f 65 ch | isLower ch = f 97 ch | otherwise = ch in map r xs; omg = reverse.rot 13 in omg "gnat"
20:10:50 <lambdabot>   "gnat"
20:10:53 <lispy> adu: Yeah, that's part of why I'm looking.  I want an official definition of what people mean... I have some intuition.
20:10:56 <adu> lispy: hmm I don't think this is a good reference: http://www.freeminds.org/psych/hitchhikers.htm
20:10:57 <lambdabot> Title: Hitchhikers Guide to Jehovah's Witness Types
20:11:00 <Olathe> @check let rot m xs = let f n = chr.(+n).(`mod` 26).(+m).(subtract n).ord; r ch | isUpper ch = f 65 ch | isLower ch = f 97 ch | otherwise = ch in map r xs; omg = reverse.rot 13 in \x -> x /= omg x
20:11:01 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\323335\"\n"
20:11:20 <Olathe> > omg "323335"
20:11:21 <lambdabot>   "533323"
20:11:27 <Olathe> > omg "\\323335"
20:11:28 <lambdabot>   "533323\\"
20:11:35 <lispy> adu: http://www.haskell.org/haskellwiki/Type_witness
20:11:36 <lambdabot> Title: Type witness - HaskellWiki
20:11:40 <lispy> adu: hehe
20:12:12 <Olathe> > let x = "\\323335" in x /= omg x
20:12:13 <lambdabot>   True
20:12:23 <Olathe> OK then
20:12:38 <ddarius> lispy: A simpler (earlier) form of GADTs was called "first-class phantom types."
20:12:47 <ddarius> @google first class phantom types
20:12:50 <lambdabot> http://ecommons.library.cornell.edu/handle/1813/5614
20:12:50 <lambdabot> Title: eCommons@Cornell: First-Class Phantom Types
20:13:09 <Olathe> > let x = "\323335" in x /= omg x
20:13:10 <lambdabot>   False
20:13:16 <lispy> hmm...I think I read that paper
20:13:16 <Olathe> > let x = "\323335" in omg x
20:13:17 <lambdabot>   "\323335"
20:13:22 <lispy> I'll check again :)
20:14:43 <lispy> ddarius: but that paper doesn't even use the word witness
20:14:48 <Olathe> > map (\f -> f '\323') [isUpper, isLower]
20:14:50 <lambdabot>   [True,False]
20:14:55 <ddarius> Yes.  That paper is way pre-GADTs.
20:15:02 <Olathe> '\323' is an uppercase character ?
20:15:18 <lispy> Well, okay but I want a paper that introduces, or at least dicusses, the meaning of type witness
20:15:39 <lispy> For example, people use the term on the wiki and mailing list but where did it start appearing?
20:16:00 <dolio> Are you sure the darcs people didn't invent the term?
20:16:23 <lispy> dolio: pretty sure
20:16:47 <Olathe> > filter (isUpper.chr) [0..255]
20:16:48 <lambdabot>   [65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89...
20:16:59 <Olathe> > reverse $ filter (isUpper.chr) [0..255]
20:17:01 <lambdabot>   [222,221,220,219,218,217,216,214,213,212,211,210,209,208,207,206,205,204,20...
20:17:41 <adu> lispy: wow
20:18:16 <dolio> I mean, I guess I've seen the term 'witness' in dependent typing.
20:18:58 <dolio> Where a "witness" is a value with the type of some proposition, which "witnesses" that the proposition is provable.
20:19:00 <lispy> adu: wow what?
20:19:14 <dolio> Which is probably how it gets into GADTs and such.
20:19:26 <adu> lispy: type witnesses, it reminds me of "Typeable" and "HList" at the same time
20:19:50 <adu> lispy: i'm gonna have to read that page a few times...
20:21:11 <dolio> Like, in Sigma a P, the second component is a witness that the value of type a satisfies the predicate P.
20:22:00 <lispy> Yeah, okay I get that it witnesses some proposition
20:22:31 <lispy> A citation would still be nice though as it seems to be established terminology and I want to mention it in a paper
20:22:47 <lispy> adu: yeah it does seem related to HList but I can't comment on Typeable
20:23:18 <dblazakis> lispy: i thought i saw the term used in either the Coq or Isabelle manual
20:23:27 <dblazakis> might want to just try a quick search
20:24:30 <Olathe> > let extents = concat.intersperse ", ".map g.f.map (join (,)) where g (a,b) = if a == b then show a else show a ++ "-" ++ show b; f ((a,b):(c,d):xs) = if b + 1 == c then f ((a,d):xs) else (a,b):f ((c,d):xs); f a = a in extents $ filter (isUpper.chr) [1..]
20:24:31 <lambdabot>   "65-90, 192-214, 216-222, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,...
20:25:04 <lispy> dblazakis: okay
20:29:31 <xpika> is there a (!!) that returns a Maybe?
20:30:01 <dolio> @type index
20:30:02 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
20:30:07 <dolio> Hmm...
20:31:10 <lispy> so maybe saying that a witness type is a type that represents some propositon is true is plenty
20:31:15 <lispy> That's how the coq people seem to use it
20:32:08 <luqui> are there any known tricks to encode linear types into haskell?
20:32:31 <luqui> say, using a term algebra, or anything really
20:33:13 <dolio> There's a paper on translating a set of data and functions on linear types into a monad that enforces the linearity.
20:33:27 <dolio> Other than that, I don't think you can encode linear types in haskell's type system.
20:33:30 <luqui> dolio, that'd be great, can you point me to it?
20:33:50 <dolio> (Or even dependent type systems, really.)
20:34:26 <luqui> woah, something dependent types can't do.  *gasp*
20:35:06 <dolio> I'm not certain it can't be done by dependent type systems, but I suspect there's no great way to encode it.
20:35:21 <lispy> adu: one thing that bugs me on the haskellwiki definition is that they say a type witness is a value, but it must be a value at the type level in that context
20:35:47 <adu> lispy: hmm that is confusing
20:35:55 <lispy> adu: I mean, if you have a phantom type that holds your witness there is no value needed
20:36:01 <dolio> luqui: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.1593
20:36:03 <lambdabot> Title: Rolling your own mutable ADT: A connection between linear types and monads - Cit ...
20:36:27 <rwbarton> > let xs !!! n = listToMaybe (drop n xs) in ("abcde" !!! 3, "abcde" !!! 7)
20:36:29 <lambdabot>   (Just 'd',Nothing)
20:36:42 <luqui> dolio, thanks!
20:36:48 <dolio> No problem.
20:36:55 <adu> lispy: these distinctions between values and types would all disappear if we all used adga :)
20:37:20 <dolio> luqui: Of course, doing that gets you no advantage in haskell, because the compiler won't recognize that you're enforcing linearity, and do mutable update.
20:37:43 <dolio> So instead you have to implement your data structure in the ST or IO monad, more or less.
20:37:54 <luqui> dolio, but I can do crazy unsafePerformIO hacks that take advantage of the known linearity
20:38:09 <dolio> Sure. :)
20:38:10 <lispy> adu: interesting, I don't know anything about agda though
20:38:12 <luqui> it's research for another language frontend anyway.
20:38:52 <luqui> agda is pretty.  I prefer coq nowadays (it's easier to use IMO).  they're both great though, I love dep type programming!
20:39:04 <adu> lispy: its apparently the leading implementation for a Haskell-ish language with dependent types
20:39:21 <lispy> ah
20:39:48 <lispy> adu: I notice that the wikipage is exploiting phantom types.  do witness types make sense without phantoms?  I'm not sure
20:40:06 <adu> lispy: of course, I've been trying to design my own Haskell-ish language with dependent types, so to me, adga is competition :)
20:44:03 <lispy> adu: another annoying thing about that page is that the dynamicCast doesn't actually cast things so the example seems silly to people
20:44:21 <Olathe> > let extents xs=("concat [["++).(++"]]").concat.intersperse"],[".map(\ys->f(snd$head ys,fst$head ys,fst$last ys)).groupBy(\a b->snd a==snd b)$(zip xs(zipWith subtract xs(tail xs))) where f(1,start,end)=show start++".."++show end;f(dist,start,end)=if start==end then show start else show start++","++show(start+dist)++".."++show end in extents $ filter (isUpper.chr) [1..]
20:44:22 <lambdabot>   "concat [[65..89],[90],[192..213],[214],[216..221],[222],[256,258..308],[31...
20:44:32 <adu> lispy: hmm, well i didn't notice that
20:45:08 <lispy> adu: by inspecting the definition you see that the only time dynamicCast :: Witness a -> Witness b -> p a -> Maybe (p b), returns Just, is if a = b
20:45:13 <adu> lispy: but now that you mention it, it is kind of a silly name
20:45:28 <lispy> and if you know a = b, then why bother with the dynamic cast
20:46:41 <luqui> adu,  I wish you luck.  dependent type compilers have lots of tricky stuff; nowhere near the simplicity of type checking on normal lambda calculus.  I would love to see a simple framework.
20:46:54 <tyler_> How do I restrict a polymorphic data type with a type class. E.g. I can make Foo t, but only if t is in Ord
20:47:03 <adu> luqui: me too
20:47:30 <adu> luqui: so far my typechecker is stuck on "forall"
20:48:00 <luqui> well sure, that's almost all you need :-)
20:48:19 <adu> lol
20:48:51 <adu> luqui: I was actually thinking of doing types with type classes
20:48:52 <TSC> tyler_: Try http://www.haskell.org/haskellwiki/Existential_type -- look at the "Short example"
20:48:53 <lambdabot> Title: Existential type - HaskellWiki
20:49:02 <lispy> adu: because I'm creative I could imagine a non-trivial dynamicClast
20:49:20 <lispy> adu: one that converts chars to ints for example by their ord
20:50:04 <luqui> tyler_, do you mean data Ord t => Foo t = ... ?
20:50:10 <adu> lispy: but you have a good point, if you know thats how its going to work, then its kinda useless
20:50:14 <luqui> don't do that though, tyler_
20:50:36 <luqui> tyler_, use data Foo t where MkFoo :: Ord t => t -> Foo t
20:51:03 <dibblego> is hackage broke again?
20:51:09 <lispy> dibblego: I think so
20:53:08 <dibblego> @hoogle Gen a -> (a -> Bool) -> Gen a
20:53:08 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:53:08 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
20:53:08 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:54:59 <tyler_> ahh, ok, thanks
20:55:13 <tyler_> writing a little btree module to give me something to hack on
20:56:12 <xpika> how do i skip the trailing whitespace in parsec for "a b c  "
20:58:32 <lispy> adu: also, it seems that GADTs make phantoms and witnesses easy to use
20:58:54 <luqui> xpika, doesn't parsec automatically skip trailing whitespace?
20:59:05 <adu> lispy: well, it seems they make them easier to define, I still don't understand what they're used for...
20:59:09 <lispy> luqui: no but it has combinators for that
20:59:30 <luqui> oh right, token etc...
20:59:38 <lispy> adu: well, phantoms have a lot of uses it seems.  Mostly to 'tag' a value with more information
21:00:18 <lispy> adu: witnesses seem to be a tag that tells the type system that some specific property is true
21:00:21 <tyler_> neat, I have a datatype and an 'add' function in 5 lines of actual code (not counting the type sigs)
21:00:39 <tyler_> which is even more elegant than the ML version I wrote a while back
21:00:56 <adu> tyler_: cool
21:04:25 <adu> you know what would really nice to have in TH?
21:05:21 <adu> a macro like $(nat 3) = Succ (Succ (Succ (Zero)))
21:06:31 <luqui> adu, can you not do this?
21:06:39 <adu> i dunno
21:06:44 <adu> never tried
21:06:57 <luqui> I think it's doable and pretty easy
21:07:06 <adu> maybe its been done before...
21:07:15 <adu> and I just don't know its name
21:07:29 <luqui> adu, if you're interested in learning TH, it would make a fine first exercise, actually :-)
21:07:38 <adu> hmm
21:08:04 <adu> It seems not as interesting as my previous TH exercise...
21:08:48 <Olathe> The interestingness differs interestingly.
21:09:56 <adu> which turned [("label", Dynamic)] => a data declaration with record labels and a defaultValue = TyCon (....) with the default values
21:09:58 <dblazakis> xpika: many space, i thought
21:10:47 <adu> I was able to implement the data-decl and default macro in like 10 loc :)
21:14:54 <adu> wanna see?
21:15:39 <dancor> i can only find old-locale
21:15:44 <dancor> where is new
21:19:47 <andyjgill_> hackage down?
21:19:52 <adu> http://hpaste.org/10253
21:20:04 <dolio> Yes.
21:20:14 <dolio> Someone should change the topic, so people can fail to read it.
21:21:08 <lispy> why does hackage go down so much again?
21:21:10 <dancor> Data.Time.Format (new time) refs TimeLocale
21:21:19 <dancor> which i can only find in old-locale
21:21:22 <dancor> which seems odd
21:21:46 <adu> is there a new-locale?
21:21:52 <sereven> dancor: I think it is part of ghc now System.Locale? But I am very very new to haskell.
21:37:46 <xpika> is using setinput in parsec cheating?
21:38:34 <lispy> in infix data constructors require a GHC specific extension or is that plain H98?
21:39:51 <Cale> I think infix data constructors is H98, but infix type constructors are not...
21:39:59 <xpika> lispy:  -fglasgow-exts
21:40:03 <lispy> ah, that would make a lot of sense
21:42:20 <lispy> "Unlike data constructors, infix type constructors are not allowed (other than (->))."
21:42:27 <lispy> that's from: http://www.haskell.org/onlinereport/decls.html
21:42:28 <lambdabot> Title: The Haskell 98 Report: Declarations
21:43:14 <adu> Cale: you still here?
21:44:03 <dancor> how do i do DiffTime -> Int
21:44:26 <Cale> yep
21:45:08 <roconnor> dancor: what type of int?
21:45:12 <adu> Cale: if you're interested I could email you my slides...
21:45:13 <roconnor> what do you want to measure?
21:45:46 <dancor> roconnor: seconds
21:47:22 <roconnor> dancor: toRational
21:47:54 <Cale> Sure, it would be interesting to have a look :)
21:48:21 <Cale> My gmail account is cgibbard
21:48:24 <roconnor> dancor: be certain that this is really what you want to do.
21:51:32 * lispy signs Cale up for spam
21:53:21 <Cale> Apparently I've received 1531 spams in the last month. I never look at my spam though.
21:54:03 <adu> me 2
21:54:29 <dancor> roconnor: ya i'm storing unix time in db.  floor . toRational $ utctDayTime getCurrentTime
21:54:41 <adu> I make a point to grep my spam every 3 months, just to see if my friends used the word "lucrative" accidentally and got filtered...
21:54:56 <lispy> adu: heh
21:55:04 <roconnor> @type floor
21:55:05 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
21:55:33 <roconnor> @type getCurrentTime
21:55:34 <lambdabot> Not in scope: `getCurrentTime'
21:55:45 <roconnor> @hoogle getCurrentTime
21:55:45 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
21:55:45 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
21:56:09 <roconnor> dancor: you just want the time of day?
21:56:42 <dancor> roconnor: oh
21:57:12 <dancor> i want to get seconds since unix epoch with new time library
21:57:35 <dancor> unpossible?
21:58:05 <roconnor> dancor: toRational (diffUTCTime currentTime epoch)
21:59:35 <roconnor> dancor: there is also utcTimeToPOSIXSeconds
22:00:10 <dancor> ah
22:00:29 <roconnor> and then toRational again (or realToFrac)
22:00:38 <humasect> can hoogle search instances?
22:00:58 <roconnor> dancor: but if you are doing that you might as well use getPOSIXTime
22:02:05 <humasect> what is the default infix for `fun` ?
22:03:40 <rwbarton> > let f = (,) in 1 `f` 2 `f` 3
22:03:42 <lambdabot>   ((1,2),3)
22:03:42 <humasect> is it 10, like functions? if one does "infix 8 `fun`" does that apply just to infix-style use of "fun" ?
22:04:18 <dibblego> @type \x t -> length (filter (== x) t) -- is this in the standard libraries anywhere?
22:04:19 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
22:04:34 <roconnor> @hoogle a -> [a] -> Int
22:04:35 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
22:04:35 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
22:04:35 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
22:04:37 <humasect> huh, rwbarton you've just solved a bunch of problems for me, showing me that (,) is a fun =)
22:05:09 <humasect> (among those you just have =)
22:05:10 <dibblego> @type \x t -> length $ elemIndicies x t
22:05:11 <lambdabot> Not in scope: `elemIndicies'
22:05:47 <roconnor> type \x t -> length $ elemIndices x
22:05:51 <roconnor> type \x t -> length $ elemIndices x t
22:05:54 <roconnor> @type \x t -> length $ elemIndices x t
22:05:55 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
22:06:00 <humasect> that is a fantastic answer, thank you so much rwbarton .
22:06:10 <rwbarton> humasect: :) no problem
22:06:14 <humasect> =)
22:06:54 <rwbarton> there's also
22:06:56 <rwbarton> @type (,,)
22:06:57 <rwbarton> etc.
22:06:57 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
22:07:04 <humasect> !
22:07:30 <humasect> i was starting to look into fmap as someone else suggested, but .. excellent=) and cool.
22:07:45 <humasect> also i am also seeing things like : instance (Eq a, Eq b) => Eq (a, b) -- Defined in Data.Tuple
22:08:44 <humasect> i have some functions which are also used in higher dimensions, and they are tuples. i think it can be done magically after all ^_^ cool cool.
22:09:37 <humasect> let f = (,) in 1 `f` (f 2)
22:09:44 <humasect> > let f = (,) in 1 `f` (f 2)
22:09:45 <lambdabot>       Overlapping instances for Show (b -> (t, b))
22:09:45 <lambdabot>        arising from a use ...
22:21:49 <humasect> @unpl f $ g . f
22:21:50 <lambdabot> (f (\ e -> g (f e)))
22:24:45 <Myoma> :t (f (\ e -> g (f e)))
22:24:46 <lambdabot> forall t t1 t2 t3. (SimpleReflect.FromExpr ((t -> t2) -> t3), SimpleReflect.FromExpr (t1 -> t2), SimpleReflect.FromExpr (t -> t1)) => t3
22:25:02 <Myoma> :t \g f -> (f (\ e -> g (f e)))
22:25:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
22:25:03 <lambdabot>       Expected type: (t -> t1) -> t2
22:25:03 <lambdabot>       Inferred type: t -> t3
22:25:19 <luqui> wow, amazing that it was given a type with simplereflect...
22:25:48 <Myoma> I think all the one letter variables are defined at the toplevel
22:25:58 <Myoma> > iterate f x
22:25:59 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
22:26:02 <luqui> yes they are
22:26:22 <luqui> I'm amazed that something that doesn't type in haskell does when given those overloads.
22:26:30 <Myoma> :t let g = undefined ; f = undefined in (f (\ e -> g (f e)))
22:26:31 <lambdabot> forall t. t
22:26:51 <luqui> let polymorphism?
22:27:01 <Myoma> That's all I could think of, to try and explain it
22:27:21 <Myoma> I mean it's the only type rule _left_ :p
22:29:17 <dibblego> @hoogle (Integral a) => a -> a -> a
22:29:17 <lambdabot> Prelude div :: Integral a => a -> a -> a
22:29:17 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
22:29:17 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
22:29:33 <Myoma> oo
22:29:40 <Myoma> I didn't know it did typeclasses
22:29:42 <dibblego> where is exponentiation?
22:29:45 <Myoma> @help hoogle
22:29:45 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
22:29:49 <Myoma> :t exp
22:29:50 <lambdabot> forall a. (Floating a) => a -> a
22:29:57 <dibblego> sorry, I mean power
22:29:58 <Myoma> is this the new verlsion
22:30:10 <dibblego> it's done type-classes for as long as I recall
22:30:16 <Myoma> :t ((^),(**))
22:30:17 <lambdabot> forall a b a1. (Floating a1, Integral b, Num a) => (a -> b -> a, a1 -> a1 -> a1)
22:30:24 <dibblego> ah thanks
22:30:30 <Myoma> @src (^)
22:30:30 <lambdabot> x ^ 0            =  1
22:30:31 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:30:31 <lambdabot>   where f _ 0 y = y
22:30:31 <lambdabot>         f x n y = g x n
22:30:31 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:30:32 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:30:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:30:36 <Myoma> yeah it uses the better algorithm
22:31:50 <dancor> maybe the new locale library doesn't exist yet?
22:32:18 <humasect> @hoogle Functor
22:32:19 <lambdabot> Prelude class Functor f
22:32:19 <lambdabot> Control.Monad class Functor f
22:32:19 <lambdabot> Control.Monad.Instances class Functor f
22:33:01 <dolio> Is that the fixed exponentiation?
22:34:32 <humasect> i am allergic to parens
22:36:10 <dolio> Apparently not.
22:37:46 <dancor> i can't seem to find any way to print a UTCTime in local time (like `date`)
22:42:30 <quicksilver> lightstep: Bother it. Even with our discussed fixes it's still not perfectly deterministic.
22:43:10 <quicksilver> lightstep: I'm starting to suspect I need to thread *all* events through one central single-threaded Chan to serialise them formally.
22:43:26 <quicksilver> lightstep: which doesn't sound particularly compositional or efficient.
22:50:20 <dmwit> ?type formatTime -- dancor
22:50:21 <lambdabot> Not in scope: `formatTime'
22:50:30 <dmwit> ?type Data.Time.formatTime
22:50:31 <lambdabot> forall t. (Data.Time.Format.FormatTime t) => System.Locale.TimeLocale -> String -> t -> String
22:53:30 <dancor> dmwit: but how do you make a TimeLocale for the system locale
22:53:36 <dancor> defaultTimeLocale is just UTC
22:54:55 <dmwit> I don't think the locale tells the time zone, it's more for localization stuff, right?
22:55:05 <dmwit> If you want to convert to your timezone, use the LocalTime functions.
22:56:15 <dmwit> (i.e. the TimeLocale would be used to expand "%c" to something culture-specific.)
22:56:35 <dmwit> There's getCurrentTimeZone and utcToLocalTime, if I remember correctly.
22:57:44 <dmwit> yeah
22:57:56 <dancor> ah, ok tx
23:43:25 <luqui> > fix (error . ('X':))
23:43:40 <lambdabot>   thread killed
23:44:08 <luqui> oh, this works just as well
23:44:10 <luqui> > fix error
23:44:25 <lambdabot>   thread killed
23:46:11 * luqui has a new favorite noob response.
23:47:57 <Cale> Thanks for creating runaway processes which will eventually turn into zombies!
23:48:20 <luqui> oh lambdabot can't handle that?
23:48:21 <Myoma> by the way
23:48:21 <Myoma> > head []
23:48:23 <Cale> It's a bug in mueval that this isn't caught.
23:48:24 <lambdabot>   mueval: Prelude.read: no parse
23:48:24 <lambdabot>  mueval: *** Exception: Prelude.head: empty ...
23:48:25 <Myoma> is a bug
23:48:26 <Myoma> I have decided
23:48:36 <Myoma> it should not say "no parse"
23:48:38 <luqui> sry
23:48:44 <Cale> Myoma: It is a bug.
23:49:06 <quicksilver> Cale: zombies don't actually do any harm except clutter up 'ps' output.
23:49:06 <Cale> luqui: It's okay, I have a script which cleans up the runaway processes every hour.
23:49:09 <Cale> right
23:49:22 <Cale> quicksilver: I wonder what happens when you run out of pids though...
23:49:25 <quicksilver> process table space is not a particularly expensive resource.
23:49:37 <quicksilver> Cale: that generates a strangelet which consumes the universe.
23:50:01 <mmorrow> i was totally about to say that same thing but s/strangelet/blackhole/
23:50:14 <quicksilver> predictable-geek-humour++
23:50:18 <mmorrow> haha
23:50:29 <Myoma> @src Mu
23:50:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
23:50:38 <mmorrow> i think also the current google image is partly to blame
23:50:39 <Myoma> > In ()
23:50:40 <lambdabot>   Couldn't match expected type `f (Mu f)' against inferred type `()'
23:50:41 <Cale> Heh, I find it funny how so many people find the LHC experiment scary.
23:50:47 <Myoma> > In (Just ())
23:50:49 <lambdabot>   Couldn't match expected type `Mu Maybe' against inferred type `()'
23:50:55 <Myoma> > In Just
23:50:56 <lambdabot>   Couldn't match expected type `Mu ((->) a)'
23:51:10 <Myoma> > fix (In . Just)
23:51:12 <lambdabot>       No instance for (Show (Mu Maybe))
23:51:12 <lambdabot>        arising from a use of `show' a...
23:51:58 <luqui> I figure if LHC "goes wrong", that will be the absolute coolest way for humanity to go extinct. I would be proud.
23:52:10 <_zenon_> luqui, :P
23:52:17 <Myoma> Leeds Haskell Compiler ??
23:52:20 <mmorrow> i can't wait til that thing gets going and hopefully discovers mind-blowing stuff
23:52:21 <_zenon_> Nah, I vote for the terminators
23:52:25 <_zenon_> THAT would be cool
23:52:39 <_zenon_> at least there is someone to take over the general extermination of other species etc.
23:52:47 <luqui> fair enough
23:52:47 <_zenon_> and more effectively
23:52:49 <Beelsebob> luqui: it would be the cause of aliens making pictures of the earth disapearing into a black hole with the words "EPIC FAIL" printed across the top
23:53:04 <quicksilver> Beelsebob: which would be most fitting.
23:53:09 <luqui> haha lolspeices
23:53:12 <quicksilver> in oh so many ways.
23:53:17 <Beelsebob> yep
23:53:24 <_zenon_> terminators
23:53:38 <Myoma> we need a show instance for Mu :(
23:53:56 <_zenon_> Was I the only one who cried when Arnold "died" with a iron bar through his torso in T2 ?
23:54:05 <luqui> Myoma, and how do you suppose to define it?
23:54:57 <Myoma>    deriving Show
23:55:01 <luqui> haha
23:55:01 <Beelsebob> lol
23:55:02 <mmorrow> > fix show
23:55:03 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
23:55:22 <_zenon_> I guess so.
23:55:41 <luqui> _zenon_, I probably did, but I'm so macho I intentionally forgot about it.
23:55:55 <Cale> _zenon_: Have you been following the new TV series? :)
23:56:02 <Myoma> its not that easy!
23:56:49 <luqui> Myoma, I believe there is no valid general Show instance for Mu
23:56:54 <mmorrow> yeah
23:56:59 * Myoma tries
23:57:05 <quicksilver> I don't think there is any reason not to have an instance Show (f a) => Show (Mu f a)
23:57:14 <quicksilver> any theoretical reason, that is.
23:57:16 <_zenon_> Cale, yeah :) Saw the episode 1 season 2 yesterday,
23:57:30 <Cale> :)
23:57:35 <luqui> quicksilver, it would need to be Show (forall a. f a) => Show (Mu f)
23:57:35 <_zenon_> luqui, hehe, I think it's more macho to cry when a machine dies.
23:57:37 <mmorrow> i guess the decision is in how to display it
23:57:54 <mmorrow> oh
23:57:56 <_zenon_> Cale, you? Following it?
23:57:59 <Cale> yeah
23:58:09 <Myoma> stop giving away the answser :P
23:58:18 <luqui> =P
23:58:44 <quicksilver> luqui: no, something weaker than that.
23:58:47 <quicksilver> you just need
23:58:48 * _zenon_ loves terminators and all the like. I would be proud to be killed by my own creation if it was so awesome
23:58:59 <quicksilver> (forall a. Show a => Show f a) => Show (Mu f)
23:59:06 <luqui> okay yeah
23:59:11 <quicksilver> which is quite a bit weaker than what you said.
23:59:19 <medfly> i didnt realize theres pride in winning a darwin award
23:59:29 <Cale> Dexter S3E1 was leaked a short while ago as well :)
23:59:43 <luqui> medfly, I think it's a codarwin award
