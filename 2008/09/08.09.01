00:00:15 <mmorrow> thoughtpolice: yes. in fact i just saw your paste re language-c, and am about to auto-generate instances of Language.Haskell.TH.Syntax.List for the AST, after which a QuasiQuoter (w/out splcing capability as that'll be parsing work) will essentially come for free :)
00:01:20 <mmorrow> thoughtpolice: and answering your question, yes i do have an example, i'm organizing things right now and'll put something up in an hour or so. i'll let you know.
00:02:19 <thoughtpolice> mmorrow: well damn, that's the exact reason I wanted the example; so I could steal the lift instance :]
00:02:27 <thoughtpolice> i was writing one myself since I got language-c to build for HEAD
00:03:32 <mmorrow> thoughtpolice: nice. i'm building language-c from darcs right now, then the setup + generation should take maybe 20 minutes. :)
00:04:13 <thoughtpolice> mmorrow: are you using drift to derive instances or data.derive or somesuch?
00:04:18 <mmorrow> thoughtpolice: ohhh, are you looking for List instances for the TH AST? i also am putting together a th-utils package that has those
00:04:43 <mmorrow> thoughtpolice: i'm using th-lift + Lift instances for the TH AST + other misc support code
00:05:02 <mmorrow> i'm trying to stick everything needed to do this into th-utils
00:05:32 <thoughtpolice> mmorrow: ah cool, that could be useful indeed.
00:05:39 <mmorrow> thoughtpolice: the bootstrapping stage in that process is a bitch. then it's easy as pie. :)
00:06:44 <mmorrow> (th-utils'll get rid of the bootstrap)
00:10:45 <sioraiocht> @src words
00:10:45 <lambdabot> words s = case dropWhile isSpace s of
00:10:45 <lambdabot>     "" -> []
00:10:45 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:10:57 <ketil> @seen lambdabot
00:10:57 <lambdabot> Yes, I'm here. I'm in #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
00:10:57 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-uy,
00:10:57 <lambdabot> #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
00:11:18 <sioraiocht> @bsrc break
00:11:18 <lambdabot> break p =  span (not . p)
00:25:32 <dons> ketil: hey, do you happen to have a fast bytestring trie type handy?
00:25:55 <dons> i'm looking to write a canonical string-specialised map type.
00:30:25 <dons> this is a nice paper, http://www.reddit.com/r/programming/comments/6z0dz/generalizing_generalized_tries_trie_search_with/
00:30:27 <lambdabot> Title: Generalizing Generalized Tries: trie search with arbitrary first-order polymorph ..., http://tinyurl.com/5p8klf
01:01:29 <Myoma> @hoogle UTF8
01:01:29 <lambdabot> package utf8-light
01:01:30 <lambdabot> package utf8-string
01:01:30 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
01:03:20 <Myoma>     FATAL:Symbol _utf8zmstringzm0zi3zi1zi1_CodecziBinaryziUTF8ziGeneric_zdf3_closure already defined.
01:03:21 <Myoma> :(((
01:03:33 <Myoma> preflex: zdec _utf8zmstringzm0zi3zi1zi1_CodecziBinaryziUTF8ziGeneric_zdf3_closure
01:03:33 <preflex>  _utf8-string-0.3.1.1_Codec.Binary.UTF8.Generic_$f3_closure
01:04:06 <Myoma> Can I actually use System.IO.UTF8 with ghc 6.9 ?
01:04:39 <humasect> type classes cannot be used for records ? i can't seem to work the syntax tonight.
01:05:12 <humasect> data Data = Data { record :: Class c => [c] }
01:06:49 <TSC> Maybe you need a wrapper existential type
01:06:54 <TSC> http://www.haskell.org/haskellwiki/Existential_type
01:06:56 <lambdabot> Title: Existential type - HaskellWiki
01:08:03 <dons> Myoma: should be able to, yes.
01:08:16 <ketil> dons: hi (sorry, coffee break)
01:08:47 <humasect> ahh =) (Read is not derivable without the wrapper)
01:08:55 <ketil> I don't think I have.
01:08:57 <Myoma> I get that error trying to cabal install it though
01:09:01 <Myoma> do you know what I should do?
01:09:22 <ketil> A trie, that is.  The challenge is to avoid all the pointers, I guess.
01:09:59 <dons> to make it fast, yeah.
01:10:17 <dons> though it seems fairly naive implementations can beat FiniteMap
01:10:41 <ketil> well, using O(n) comparisons will suck, obviously.
01:11:23 <mmorrow> thoughtpolice: ping
01:11:38 <ketil> Using bytestrings should allow compact tries (ie. merging nodes with in and out-degrees of 1)
01:11:43 <ketil> as in suffix trees.
01:12:38 <mmorrow> @tell thoughtpolice see the EXAMPLE file for how to derive Lift  file:///usr/local/apache2/htdocs/haddock/th-utils/index.html   http://code.haskell.org/~morrow/code/haskell/th-utils/
01:12:38 <lambdabot> Consider it noted.
01:13:00 <dons> yeah, that was the plan (for path compression).
01:13:21 <humasect> thanks TSC
01:13:23 <dons> though there's an awful lot of variants around for these kind of structures, with no obvious winner, from what i can see. i'll keep looking.
01:14:00 <BeelsebobWork> is haddock currently meant to be broken with ghc683, or is macports' version broken?
01:14:14 <ketil> dons: you might want to compress things further by storing the input strings at the "top level" and use indices in the search tree.  Since a BS has considerable overhead, I mean (ptr offset length).
01:14:27 <dons> that's not a bad idea.
01:14:56 <ketil> an index into a set of strings should be a single ptr, and you're risking having a lot of them.
01:15:45 <ketil> for compression, you may need to have segment lengths as well?  Not sure about that.
01:16:09 <ketil> I guess you'll just have to implement every option, and benchmark it out. :-)
01:17:33 <ketil> If you only store offset at each node, you can determine lenght of the internal strings by subtracting current offset from the next one, so I think it might work.
01:17:45 <ketil> (Is this making any sense?)
01:18:08 <Myoma> am I using cabal wrong?
01:18:27 <humasect> why is it that non-haskell98-constructors can't derive from Show or Read ?
01:19:36 <ketil> Are there any important performance optimizations between ghc 6.8.1 and ghc 6.8.3?
01:20:43 <dons> yeah, in 6.8.2. spec constr was enabled.
01:20:50 <dons> 6.8.3 has some backpeddling though.
01:21:02 <opqdonut> spec constr?
01:21:19 <dons> constructor specialisation (-fspec-constr)
01:21:36 <dons> turns data into code. nice optimisation.
01:21:49 <opqdonut> ah, nice indeed
01:22:08 <opqdonut> so it's kind of like constructor inlining?
01:22:20 <ketil> Probably should upgrade, then.
01:22:27 <dons> ketil: i'd go to 6.8.2
01:22:32 <dons> it's my favourite ghc so far.
01:23:37 <ketil> :-)
01:24:59 <dons> yeah, the main issue with the string lookup/insert data structures is that there are so many options
01:25:09 <dons> and with purely functional ones, in particular, not many have been benchmarked
01:25:20 <mmorrow> @tell thoughtpolice currently churning away deriving
01:25:20 <lambdabot> Consider it noted.
01:25:21 * dons smells research result just implementating these...
01:25:34 <mmorrow> @tell thoughtpolice lift forall c types
01:25:35 <lambdabot> Consider it noted.
01:28:42 <mmorrow> Myoma: what's the error?
01:28:55 <Myoma> /tmp/ghc1560_0/ghc1560_0.s:15341:0:
01:28:56 <Myoma>     FATAL:Symbol _utf8zmstringzm0zi3zi1zi1_CodecziBinaryziUTF8ziGeneric_zdf3_closure already defined.
01:28:56 <Myoma> cabal: Error: some packages failed to install:
01:28:56 <Myoma> utf8-string-0.3.1.1 failed during the building phase. The exception was:
01:28:56 <Myoma> exit: ExitFailure 1
01:30:32 <mmorrow> ugh. hmm, maybe either comment out Codec.Binary.UTF8.Generic in the .cabal , or mess with it more, or install utf8-light :)
01:31:32 <mmorrow> Myoma: you should be able to just comment that module out though in the .cabal file as a temporary fix (assuming you don't need that one /in particular/)
01:35:47 <Myoma> I can't do that :/
01:36:46 <Myoma> oh well I can get around it another way
01:50:51 <Axman6> so, today, my friend and I came up with an interesting idea. Kind of related to a quine
01:51:29 <Axman6> it is a computer that can model its own atoms in real time
01:51:50 <BeelsebobWork> heh
01:51:57 <Axman6> and i figured, if anyone could figure out how to do it, they were likely to be in here ;)
01:52:00 <BeelsebobWork> something tells me that's unlikely
01:52:02 * Axman6 looks at dons 
01:52:28 <humasect> doesn't any computer already do that, by being said computer?
01:52:51 <sjanssen> doesn't every object model its own atoms in real time?
01:52:55 <humasect> right=)
01:53:10 <Axman6> i mean have a computational model
01:53:23 <humasect> a model that computes? the computer itself, still?
01:53:24 <Axman6> i'm trying to avoid the php quine approach
01:54:47 <mmorrow> Myoma: does it work yet?
01:55:46 <Axman6> BeelsebobWork: comes from some idiot in one of our lectures last semester asking why we don't just use our super computer to model all the atoms in the world
01:55:59 <BeelsebobWork> heh
01:57:47 <Twey> Hahaha, Axman6
01:58:23 <Axman6> i mean, we have the largest super somputer in the country, but it's not quite that large
01:59:15 <Myoma> mmorrow: Your webserver works :D
01:59:22 <PeakerWork> in theory, if the entropy is low in a big system, a smaller system with higher entropy could model it
01:59:31 <Myoma> mmorrow: I can not use System.IO.UTF8 and everything is ok though
02:01:59 <mmorrow> Myoma: cool and not cool! try utf8-light. here's a screenshot: http://code.haskell.org/~morrow/code/images/utf8-light.png
02:03:14 <mmorrow> Myoma: cool and not cool! try utf8-light. here's a screenshot: http://code.haskell.org/~morrow/code/images/utf8-light.png
02:03:29 <mmorrow> (dunno if you saw that or not)
02:03:30 <Myoma> utf8-light wouldn't install either
02:03:42 <mmorrow> huh? another linker error?
02:03:50 <rdtst> wow russian letters %)
02:03:52 <Myoma> yes
02:04:02 <Myoma> maybe once 6.10 is out I will have less problems
02:04:06 <mmorrow> Myoma: did you recently upgrade Binary or ByteString?
02:04:24 <Myoma> I'm not sure
02:04:28 <mmorrow> what does $ ghc-pkg list binary    say?
02:04:37 <mmorrow> and  $ ghc-pkg list bytestring
02:05:10 <Myoma> {binary-0.4.2} and bytestring-0.9
02:05:43 <mmorrow> ooh. ok, those braces mean that a package it depends on is now gone. try to reinstall binary.
02:06:17 <Myoma> how do you know all this :)
02:06:52 <mmorrow> Myoma: heh, cuz i've had all this happen to me and be scrambling to unbreak things ;)
02:07:22 <mauke> necessity is a cruel teacher
02:07:33 <mmorrow> mauke: very much so
02:07:48 <mmorrow> mauke: a rapid one though
02:08:21 <Myoma> binary reinstalled but utf8-string still doesn't
02:08:54 <mmorrow> what is the linker error?
02:09:14 <Myoma> It's
02:09:14 <Myoma> [2 of 6] Compiling Codec.Binary.UTF8.Generic ( Codec/Binary/UTF8/Generic.hs, dist/build/Codec/Binary/UTF8/Generic.o )
02:09:14 <Myoma> /tmp/ghc294_0/ghc294_0.s:15341:0:
02:09:14 <Myoma>     FATAL:Symbol _utf8zmstringzm0zi3zi1zi1_CodecziBinaryziUTF8ziGeneric_zdf3_closure already defined.
02:09:51 <mmorrow> i had this exact problem happen to me actually. i got around it by commenting out some modules in the .cabal file.
02:10:36 <mmorrow> preflex: zdec CodecziBinaryziUTF8ziGeneric
02:10:36 <preflex>  Codec.Binary.UTF8.Generic
02:11:22 <mmorrow> so just comment that out in utf8-string.cabal and it should at least work until you find a fix
02:11:48 <mmorrow> in the build-depends:  field
02:16:17 <Twey> preflex: zdec zz
02:16:18 <preflex>  z
02:16:21 <Twey> preflex: zdec zo
02:16:21 <preflex>  zo
02:16:28 * Twey shakes his head.
02:16:35 <Twey> Using 'z' as an escape character...
02:16:48 <mauke> what would you prefer?
02:16:58 <mmorrow> Myoma: i think it actually might be because you have 6.9 and you're trying to install the hackage version. try the darcs version http://code.haskell.org/utf8-string/
02:16:59 <lambdabot> Title: Index of /utf8-string
02:17:00 <Twey> _ perhaps
02:17:12 <mmorrow> preflex: zenc _
02:17:12 <preflex>  zu
02:25:24 <ketil> Heh. Interesting thread on the list about Haskell as a research language vs practical programming.
02:26:11 <ketil> Success seems inevitable, but what do we do about it?
02:26:26 <PeakerWork> fork the language!
02:27:37 <ketil> fork dons!
02:27:42 <quicksilver> ketil: I was boggled by JCC's suggestion that he didn't want haskell to be a day-to-day language.
02:28:17 <ketil> But what else is there?  Ocaml doesn't look nearly as much fun.
02:28:33 <ketil> I guess we could try out agda or cayenne...
02:28:35 <quicksilver> ocaml is no less a research playground than haskell.
02:28:47 <quicksilver> oh hang on, what's your objective here? :)
02:29:28 <ketil> I'm just looking for what to use, now that Haskell is being restricted to research-only.
02:29:30 <Wild_Cat> I find it bizarre that someone would be willing to invest lots of time in learning a language they neither expect nor *want* to ever be used in the real world.
02:29:49 <BeelsebobWork> tbh, I wouldn't mind forking the language -- if I thought anyone would pay attention to the fork
02:30:03 <quicksilver> ketil: well agda and cayenne are definitely much more research-only than haskell :)
02:30:09 <BeelsebobWork> but in reality, I don't think anyone uses anything other than the cutting edge version of Haskell
02:30:14 <quicksilver> ketil: I wasn't sure which direction you were trying to go.
02:30:21 <quicksilver> BeelsebobWork: I'm stil using 6.6 ;)
02:30:31 <ketil> quicksilver, yes.  I was trying to be humorous.  Didn't work, I know.
02:30:40 <ketil> It usually doesn't, but one can't stop trying.
02:30:44 <quicksilver> BeelsebobWork: and I don't use any extensions except existential types, as far as I can remember.
02:30:46 <ketil> Just like avoiding success, really.
02:30:49 <mmorrow> @tell thoughtpolice here's most of language-c http://code.haskell.org/~morrow/code/haskell/misc/CLift.hs
02:30:49 <lambdabot> Consider it noted.
02:30:54 <quicksilver> ketil: ah, sorry ;)
02:31:04 <quicksilver> ketil: consider your comments suitably re-interpreted in that light.
02:31:14 * quicksilver laughs politely.
02:31:34 <PeakerWork> is alt.comp.lang.haskell associated with the list in any way, or used at all?
02:31:42 <ketil> Thank you, thank you.
02:31:43 <quicksilver> I wouldn't be against a fork, per se.
02:31:51 <quicksilver> but I'd need there to be a reason for the fork.
02:31:52 <ketil> Remind me to do it again some time :-)
02:32:12 <quicksilver> at the moment, I find the status quo (research and real work going in roughly the same arena) is working fine.
02:32:14 <Axman6> erlang style message passing!
02:32:46 <quicksilver> Axman6: I find "Chan t" where t is some user defined type gives me all that I want from erlang.
02:32:55 <quicksilver> (I haven't actually programmed erlang though, just read about it)
02:32:56 <ketil> Each iteration, ghc grows some new features.  Some work out, and some go off to collect dust.  Fine with me :-)
02:33:07 <Axman6> what's Chan t do...
02:33:16 <quicksilver> it's a channel over which you can pass values of type 't'
02:33:18 <quicksilver> message passing!
02:33:39 <Axman6> does it work over CPU cores and the internet?
02:34:01 <quicksilver> the former, not the latter.
02:34:27 <quicksilver> but message passing over the internet isn't especially hard, you do need a serialisation layer.
02:34:32 <quicksilver> I've used Read/Show for that purpose
02:34:40 <quicksilver> (in a non-performance critical setting)
02:34:50 <slarba> how about erlang-style process links?
02:34:54 <slarba> ;)
02:34:58 <quicksilver> Of course that implies you can't serialise thunks.
02:35:03 <quicksilver> but that doesn't bother me much.
02:35:08 <quicksilver> slarba: I don't know what that means.
02:35:08 <Axman6> i just like the way that erlang doesn't care where a process is. it's the same syntax to send the message to anywhere
02:35:15 <quicksilver> Axman6: yes, that's nice.
02:35:33 <quicksilver> Axman6: woudln't be too hard to do that in haskell too, subject to the proviso above.
02:35:44 <slarba> quicksilver: you can form a link between processes such that if the remote end dies for some reason, you'll get notified
02:35:47 <quicksilver> You could have a Chan which happens to attached to a 'stub listener' which forwards over the wire.
02:36:12 <quicksilver> slarba: yes. I'd bundle that under "distributed process managament" or some such banner. Haskell doesn't have any of that.
02:36:19 <quicksilver> Definitely funky stuff.
02:36:27 <quicksilver> not something I've ever actually needed myself :)
02:36:32 <Axman6> but that's not really in the language, but creating it from the language.
02:36:42 <quicksilver> Axman6: I don't think that matters.
02:36:55 <quicksilver> modern languages often tend towards a smaller core and a tightly-coupled standard lib.
02:36:59 <quicksilver> I don't see that as a bad thing.
02:37:05 <Axman6> yeah
02:37:22 <quicksilver> Is the tuple type "(a,b)" part of the haskell compiler, or just a type from the standard lib?
02:37:30 <quicksilver> How would you (the programmer) be able to tell which it was?
02:37:34 <quicksilver> (and does it, therefore, matter?)
02:37:52 <Axman6> i guess
02:38:02 <quicksilver> Of course, tuples have a bit of custom syntax, so they clearly exist in the compiler front-end at least.
02:38:08 <quicksilver> so maybe that's a bad example.
02:38:16 <quicksilver> 'Either a b' has no custom syntax
02:38:19 <BeelsebobWork> quicksilver: interesting
02:38:25 <quicksilver> and could easily be completely in the library.
02:38:31 <slarba> hmm. I think that process linking needs some support from the runtime
02:38:36 <BeelsebobWork> I think you would prabably have been one of the people lower on my list of "people expected to use something close to H98"
02:38:54 <quicksilver> BeelsebobWork: not for ideological reasons. Simply because I've never needed to.
02:38:56 <Axman6> but it does allow for the mechanisms to be optimised more i'd say, and to hide the process from the user
02:39:08 <BeelsebobWork> quicksilver: yep, roughly the same reasons as I do
02:39:17 <Axman6> but yes. i'd like to see it happen in haskell, not just hear that it could be done ;)
02:39:19 <BeelsebobWork> although I do always like H98 code, because I can actually use the tools then
02:39:26 <quicksilver> BeelsebobWork: I've experimented with MPTCs but as far as I can recall I don't use them in anything like a real program.
02:39:35 <quicksilver> I'm quite anti-type-class actually.
02:39:43 <quicksilver> rather rarely do I define my own.
02:39:53 <BeelsebobWork> ditto
02:40:12 <BeelsebobWork> my code always seems to be either more general, or more specific than that
02:40:28 <Myoma> chamelion has some nice features
02:40:37 <quicksilver> Axman6, slarba : yes, I think it is an interesting area. I'm just not currently seeing it as part of the toolbox I need for day-to-day programming.
02:40:54 <Myoma> this thing http://www.cs.mu.oz.au/~sulzmann/chameleon/
02:40:55 <lambdabot> Title: Chameleon
02:41:10 <Axman6> quicksilver: would make data parallel haskell quite interesting imo
02:41:33 <quicksilver> @where+ chameleon http://taichi.ddns.comp.nus.edu.sg/taichiwiki/ChameleonHomePage
02:41:33 <lambdabot> Done.
02:41:41 <quicksilver> Myoma: Interesting. I'd never heard of that one.
02:41:54 <quicksilver> it looks like it bitrotted.
02:41:58 <quicksilver> like most phd projects :)
02:42:15 <quicksilver> Axman6: absolutely.
02:42:39 <quicksilver> Axman6: but the synchronisation heuristics required to do an efficient distributed DPH are quite hard.
02:42:58 <quicksilver> Axman6: too much over-the-net data copying nullifies your speed advantage.
02:43:12 <quicksilver> Axman6: there is a distributed haskell project which is, I think, not *entirely* dead.
02:43:28 <Axman6> just need efficient data distribution
02:43:35 <Axman6> heh
02:46:18 <Axman6> something like push bittorrent, send out the data in chunks and get the nodes to share it, if it's large enough to need it
02:47:20 <Axman6> if it's something like matrix vector multiplication, then there's never going to be too much data anyway
02:50:51 <mauke> preflex: wb
02:51:14 <chrisdone> you say wb to your bot
02:51:26 <chrisdone> ``WTF''
02:51:35 <mauke> ‚ÄúWTF‚Äù
02:52:08 <mauke> `·∫Åhat the fuc·∏±¬¥
02:52:15 <chrisdone> your quotes need to be more '`jaunty''
02:52:31 <mauke> „Äågood„Äç enough?
02:52:46 <chrisdone> expert unicode user
02:53:07 * Botje sticks a gold 0x2606 on mauke 
02:53:29 <Myoma> > say . return . chr $ 0x2606
02:53:30 <lambdabot>   ‚òÜ
02:53:32 <mauke> EXPERT COMPOSE KEY USER
02:53:54 <mauke> > say "\x2606"
02:53:55 <lambdabot>   ‚òÜ
02:54:00 <mauke> optimized
02:54:12 <Myoma> :set -funroll-loops
02:54:21 <chrisdone> `-. ‚òÜ ^_^!‚ÄΩ‚òÜ .-`
02:54:34 <chrisdone> haha
02:54:39 <BeelsebobWork> > say "\x3020"
02:54:41 <lambdabot>   „Ä
02:56:52 <chrisdone> > say "yarr! \141"
02:56:53 <lambdabot>   yarr!
02:57:06 <chrisdone> > say $ reverse "yarr! \141"
02:57:07 <lambdabot>    !rray
02:57:15 <chrisdone> OH WH-
02:58:09 <chrisdone> > say @yow -- ??
02:58:10 <lambdabot>   mueval: Prelude.read: no parse
02:58:15 <chrisdone> @@ say @yow -- ??
02:58:16 <lambdabot>  say Thank god!! ... It's HENNY YOUNGMAN!!
02:58:30 <Axman6> ...
02:58:33 * chrisdone chuckles
02:58:47 <BeelsebobWork> @elite "\x2606"
02:58:47 <lambdabot> "\X2606"
02:59:08 <chrisdone> hah?
02:59:20 <BeelsebobWork> @. elite eval say "\x2606"
02:59:20 <lambdabot> Say again?
03:04:43 <ivanm> @help say
03:04:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:04:54 <ivanm> so what is say meant to do?
03:05:02 <BeelsebobWork> it isn't
03:05:11 <BeelsebobWork> it's not a lambdabot command
03:05:15 <BeelsebobWork> @hoogle say
03:05:15 <lambdabot> No results found
03:05:25 <BeelsebobWork> god knows what the Haskell function does though
03:05:28 <mauke> :t say
03:05:29 <lambdabot> [Char] -> Expr
03:05:53 <ivanm> ahhh
03:05:59 <EvilTerran> say = var, i believe
03:06:00 <ivanm> > say "stuff"
03:06:02 <lambdabot>   stuff
03:06:06 <EvilTerran> > var "bleem fleem"
03:06:07 <lambdabot>       Ambiguous occurrence `var'
03:06:07 <lambdabot>      It could refer to either `Data.Number.S...
03:06:10 <EvilTerran> gr
03:06:11 <ivanm> lol
03:06:15 <ivanm> and var is?
03:06:20 <BeelsebobWork> > say "> say \"> say \\\"Jam\\\"\""
03:06:22 <lambdabot>   > say "> say \"Jam\""
03:06:29 <BeelsebobWork> bah
03:08:06 <EvilTerran> ivanm, it's part of SimpleReflect
03:08:09 <EvilTerran> ?where simplereflect
03:08:09 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
03:08:14 <chrisdone> ?jt coi ro do
03:08:14 <lojbot> (^coi /greetings/ ro /every/ /(of)/ do /you/^)
03:08:15 <lambdabot>  fd:6: hClose: resource vanished (Broken pipe)
03:08:22 <EvilTerran> > foldr f e [x,y,z] -- wot makes this work
03:08:24 <lambdabot>   f x (f y (f z e))
03:08:40 <EvilTerran> ?help jt
03:08:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:08:41 <lojbot> commands: help (h), word (w), definition (def, d), gismu (g), cmavo (c), grammar, colors (cl, colours, skari), jbofihe (jbofi'e, jt), cmafihe (ct), coi, vlatai (i, v), jvocuhadju (lujvo), selma'o (s), more
03:08:52 <EvilTerran> ...
03:09:07 <EvilTerran> there should not be two bots in here both replying to ?
03:09:18 <chrisdone> hehe
03:09:28 <BeelsebobWork> is lambdabot meant to reply to @
03:09:31 <jsnx> what is the deal with lojban?
03:09:45 <EvilTerran> BeelsebobWork, yeah, she replies to both @ and ? identicall
03:09:46 <EvilTerran> y
03:09:56 <jsnx> it's like, all popular all of a sudden
03:10:00 <ivanm> jsnx: the "deal" depends on how many illegal substances you've consumed :p
03:10:02 <BeelsebobWork> oh, why not reconfigure her to only respond to @ then
03:10:22 <chrisdone> ivanm: ~_~
03:10:24 <EvilTerran> why not configure new bots to respond to something different, instead of changing the old bot?
03:10:38 <jsnx> indeed
03:10:44 <EvilTerran> for some people, @ is not as conveniently placed as ?
03:10:53 <BeelsebobWork> oh?
03:10:55 <jsnx> lojbot should only respond if the message begins with lokbot:
03:11:04 <EvilTerran> they're both by my right shift key, so it wouldn't particularly bother *me*
03:11:26 <EvilTerran> but US keyboards, say, put @ over the 2, which is a bit more out of the way
03:11:35 <BeelsebobWork> EvilTerran: my keyboard puts it there
03:11:36 <jsnx> yeah, for english speakers with american keyboards, @ is far and ? is not
03:11:38 <BeelsebobWork> it's not out the way at all
03:11:54 <BeelsebobWork> I'd even count it as an easier to reach key than ?
03:11:56 <EvilTerran> anyway, regardless of why, lambdabot pays attention to both @ and ? commands - why change it?
03:12:10 <BeelsebobWork> well, because it's using up a large chunk of namespace for no gain
03:12:16 <EvilTerran> "a large chunk"
03:12:24 <BeelsebobWork> precicely, doubled
03:12:32 <jsnx> lojban is like the new lolcats or something
03:12:40 <EvilTerran> other bots can only use !$%^&*:;~#
03:12:52 <jsnx> well, i thnk it is time for us to make and RFC for this namespace
03:12:56 <EvilTerran> that's greatly restricted as compared to ?!$%^&*:;~#
03:12:59 <EvilTerran> :P
03:13:07 <jsnx> first, we need to get the IANA to adopt our protocol
03:13:10 <yitz> BeelsebobWork: that may be, but both of those chars are pretty established for \bot, you'd start a war if you try to force the community to pick only one.
03:13:17 <BeelsebobWork> that's true
03:13:24 <jsnx> then we can register the various prefixes
03:13:29 <quicksilver> war! war! war!
03:13:34 * quicksilver rolls out the lambdacannons.
03:13:39 <BeelsebobWork> note, I wasn't really suggesting this -- merely pointing out that lambdabot is rather hogging the name space
03:13:46 <BeelsebobWork> she in fact, sits on 3 characters
03:13:51 <BeelsebobWork> (@, ? and >)
03:13:56 <jsnx> probably, lambdabot will get a prefix like 12.34.22
03:13:57 * yitz prepares a flag with the @ emblem
03:14:07 <jsnx> and lojbot will get 09.81.77.21
03:14:09 <BeelsebobWork> yitz: I'll follow that flag :P
03:14:22 <jsnx> adn thus they will be well separated
03:14:24 <EvilTerran> BeelsebobWork, i mean, it's not a matter of how much more space lambdabot takes up as a proportion of how much she'd take up only using one character, more how much she takes up as a proportion of all available space. which is still really not that much.
03:14:29 <EvilTerran> BeelsebobWork, she also uses :
03:14:30 <jsnx> though admittedly not as easy to type
03:14:34 <EvilTerran> :k StateT
03:14:35 <lambdabot> * -> (* -> *) -> * -> *
03:14:39 <BeelsebobWork> so she does
03:15:11 <BeelsebobWork> anyway, personally, I think we should all address the bots with "@" followed by a UUID -- @E26FCB6F-9BE0-4CD1-BBE6-09C8EB4381D2 is much more user friendly
03:15:18 <BeelsebobWork> and deminishes the risk of clashes
03:15:21 <jsnx> yeah, i agree
03:15:28 <jsnx> that way we always know which bot
03:15:28 <EvilTerran> ... or just use their /nick
03:15:35 <EvilTerran> that has to be unique on the network anyway
03:15:43 <jsnx> as long as we register the UUIDs with the IANA
03:15:53 <BeelsebobWork> jsnx: oh of course
03:16:01 <yitz> lambdabot is our beloved local chanbot. all others are visitors and will have to be polite.
03:16:02 <BeelsebobWork> surely you wouldn't be able to run a bot without registering it's UUID
03:16:04 <mauke> preflex: are you a bot?
03:16:04 <preflex>  yes.
03:16:14 <jsnx> BeelsebobWork: indeed
03:16:23 <yitz> preflex: what is your UUID?
03:16:25 <jsnx> we've gotten away with it for too long...
03:16:28 <lilac> EvilTerran: clearly addressing a message to a specific person within a channel is impossible, though! :)
03:16:36 <yitz> @vixen what is your UUID?
03:16:36 <lambdabot> i don't know, what?
03:16:47 <BeelsebobWork> @botsnack
03:16:47 <lambdabot> :)
03:16:55 * EvilTerran dibs number 6
03:17:02 <chrisdone> mine has a bot hostmask :(
03:17:11 <chrisdone> see ^
03:17:11 <jsnx> i even gave myself a UUID
03:17:20 <yitz> > md5 "lambdabot"
03:17:21 <lambdabot>   mueval: Prelude.read: no parse
03:17:21 <jsnx> 81EADEB7-CCC5-4BF3-BD66-40CD32824A6E
03:17:41 <jsnx> and then i registered it with the IANA
03:17:41 <yitz> bf7e231484d0562c25e67791e21e4122
03:18:06 <mauke> md5(lambdabot) = 121bf662d50326f59022c7096d636d58
03:18:41 <jsnx> bah, humbug
03:18:42 <yitz> mauke: I got mine by echo lambdabot | md5
03:19:14 <BeelsebobWork> my md5 computation agrees with yitz
03:19:20 <Saizan> still playing with the bots? :)
03:19:33 <BeelsebobWork> Saizan: that's the E26FCB6F-9BE0-4CD1-BBE6-09C8EB4381D2s thank you very much
03:20:01 <Myoma> I guess it depends on newline termination
03:20:27 <BeelsebobWork> Myoma: ah yeh, fair point
03:20:28 <yitz> The command feeds in other stuff. yeah maybe newline, or '-' as the filename.
03:20:53 <yitz> Nope, just a newline, that's right.
03:21:10 <yitz> >>> md5.md5("lambdabot\n").hexdigest()
03:21:10 <yitz> 'bf7e231484d0562c25e67791e21e4122'
03:37:33 <chrisdone> lojbot: help
03:37:34 <lojbot> commands: help (h), word (w), definition (def, d), gismu (g), cmavo (c), grammar, colors (cl, colours, skari), jbofihe (jbofi'e, jt), cmafihe (ct), coi, vlatai (i, v), jvocuhadju (lujvo), selma'o (s), more, see http://chrisdone.com/lojbot.txt for detail
03:37:36 <chrisdone> there we go
03:39:35 <EvilTerran> ?bot
03:39:35 <lambdabot> :)
03:39:53 <chrisdone> lojbot: coi
03:39:53 <lojbot> coi
03:45:15 <chrisdone> yeah lojbot is lambdabot's intended equivalent for #lojban
03:48:38 <yitz> thanks chrisdone
03:48:54 <yitz> lojbot: skari red
03:48:54 <lojbot> red
03:49:13 <chrisdone> ?jt so'i me la lojban. tavla prenu cu je'u nelci la .xaskil. pe'i
03:49:14 <lambdabot>  fd:5: hClose: resource vanished (Broken pipe)
03:49:17 <chrisdone> whoops
03:49:22 <chrisdone> lojbot: jt so'i me la lojban. tavla prenu cu je'u nelci la .xaskil. pe'i
03:49:22 <lojbot> [([nelci1 (like-r(s)):] so'i /many/ ^^me /amongst those that are/ la / / lojban. /[NAME]/ /[type-of]/ tavla /talk-ing/^ /[type-of]/ prenu /person(s)/^) cu /is/does/ je'u /{truth..}/ <<nelci /lik-ing/>> ([nelci2 (liked thing(s)):] la / / xaskil. /[NAME]/ pe'i /{I opine..}/)]
03:50:37 <xci> hi guys, is there a function that returns the first element from a list that satisfies a certain condition?
03:50:41 <chrisdone> BeelsebobWork: very amusing indeed
03:50:51 <ivanm> xci: head . filter ?
03:51:00 <BeelsebobWork> chrisdone: hmm? my comment about the website?
03:51:06 <BeelsebobWork> I was being 100% serious
03:51:15 <ivanm> actually, you might want the Maybe equivalent in case nothing matches
03:51:17 <chrisdone> xci: perhaps find
03:51:21 <ivanm> @hoogle [a] -> Maybe a
03:51:21 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
03:51:21 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:51:21 <lambdabot> Prelude head :: [a] -> a
03:51:22 <BeelsebobWork> it took me god knows how long clicking about on the website to get me to a page saying "lojban is a language"
03:51:30 <xci> ivanm: ah, of course, thanks :)
03:51:40 <ivanm> @type listToMaybe . filter
03:51:41 <lambdabot>     Couldn't match expected type `[a]'
03:51:41 <lambdabot>            against inferred type `[a1] -> [a1]'
03:51:41 <lambdabot>     Probable cause: `filter' is applied to too few arguments
03:51:47 <ivanm> @type \p -> listToMaybe . filter p
03:51:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
03:52:10 <ivanm> looks like that's what find does (which chrisdone mentioned)
03:52:11 <chrisdone> BeelsebobWork: I know; everyone in the community is aware of it. we've been working on new designs
03:52:23 <BeelsebobWork> chrisdone: ah, cool
03:52:44 <Myoma> :t foldr (\x e -> if ?p x then x else e) undefined
03:52:45 <lambdabot> forall a. (?p::a -> Bool) => [a] -> a
03:53:03 <chrisdone> BeelsebobWork: actually here is one: http://lojban.jim.dabell.name/ -- what is your impression?
03:53:05 <Myoma> @let bool true false True = true ; bool true false False = false
03:53:06 <lambdabot> Title: Lojban: A Logical Language
03:53:07 <lambdabot>  Defined.
03:53:48 <Myoma> :t foldr (liftM2 flip bool p) undefined
03:53:48 <EvilTerran> xci, i think Data.List.find does that
03:53:49 <lambdabot>     Couldn't match expected type `c -> Bool'
03:53:49 <lambdabot>            against inferred type `Expr'
03:53:49 <lambdabot>     In the third argument of `liftM2', namely `p'
03:53:52 <EvilTerran> ?type find
03:53:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
03:54:01 <ivanm> @src find
03:54:01 <lambdabot> find p          = listToMaybe . filter p
03:54:06 <EvilTerran> heh
03:54:07 <Myoma> > foldr (liftM2 flip bool even) undefined [3,5,4,7,8,6,4]
03:54:08 <lambdabot>   4
03:54:08 <ivanm> yeah, that's what I thought
03:54:37 <EvilTerran> (head . filter p) is more straightforward if you're willing to rely on there being a matching element
03:55:13 <yitz> chrisdone: hmm what's up with all the usage of cu nowadays? what was wrong with le gerku bajra?
03:55:47 <papermachine> yitz: that's not a sentence.
03:56:22 <chrisdone> yitz: that means dogish type-of run, {gerku} and {bajra} form a tanru
03:56:50 <papermachine> dogish type-of runner, since x1 of bajra is the thing that runs.
03:57:08 <chrisdone> that's right
03:58:18 <yitz> in fact, I could just say "bajra" if we're all looking at that picture on the page and know we're talking about the dog.
04:01:12 <chrisdone> lojbot: grammar le gerku bajra .i le gerku cu bajra
04:01:12 <lojbot> (0[{<le (1gerku bajra)1 KU> VAU} i {<le gerku KU> cu <bajra VAU>}])0
04:02:33 <chrisdone> :hoogle bool
04:02:36 <chrisdone> @hoogle bool
04:02:36 <lambdabot> module Data.Bool
04:02:36 <lambdabot> Prelude data Bool
04:02:36 <lambdabot> Data.Bool data Bool
04:02:53 <EvilTerran> lambdabot evaluates haskell expressions... can lojbot evaluate lojban expressions? :
04:02:56 <EvilTerran> * :P
04:03:56 <chrisdone> to what? :P
04:04:17 <EvilTerran> well, i imagine you could pick out a subset involving arithmetic, string manipulation, etc
04:04:28 <EvilTerran> that could be meaningfully run
04:04:47 <EvilTerran> give it objects and call it whatever the lojban phrase for "increment lojban" is :P
04:05:00 <yitz> "cu" acts as a separator after at least one preceding sumti to clearly
04:05:00 <yitz>    mark the selbri.  As the diagram indicates, it may often be omitted. http://www.lojban.org/publications/brochures/lojex.txt
04:05:01 <chrisdone> ha, yes, I suppose
04:05:10 <chrisdone> I prefer the emulating prolog approach, personally
04:05:47 <chrisdone> http://www.lojban.org/tiki/tiki-index.php?page=Prolog+for+Lojbanists&bl
04:05:53 <lambdabot> Title: Lojban : Prolog for Lojbanists, http://tinyurl.com/63w8ol
04:05:59 <EvilTerran> i guess it could be used to express facts and queries
04:06:15 <EvilTerran> proloj?
04:06:27 <chrisdone> heh
04:06:34 <papermachine> Somebody wrote a small fact deducer that used lojban.
04:06:46 <chrisdone> indeed, I'm looking into writing a lojban parser for haskell so that I can do something like a logic language
04:06:48 <papermachine> I forget who. Lojban names aren't usually memorable.
04:07:22 <chrisdone> right
04:07:56 <lambdapants> greetings
04:08:05 <EvilTerran> salutations
04:08:27 <lambdapants> functional comrades, I have a problem.
04:08:42 <lambdapants> anyone used hscurses much?
04:08:49 <EvilTerran> we all have problems. that's the human condition for ya. :)
04:08:59 <lambdapants> heh!
04:09:10 * EvilTerran hasn't, i'm afraid
04:09:27 <lambdapants> ÔªøI've written half a shoot-em up, but I can't get multiple windows to work and such a game needs a hud.
04:10:09 <chrisdone> a shoot-em up in curses
04:10:23 <lambdapants> yes.  with a network server.  it's quite fun.
04:10:28 <papermachine> Wow.
04:10:30 * chrisdone screams
04:10:44 <papermachine> I should try hacking together something. Hm.
04:10:48 <chrisdone> screenshots?
04:11:20 <lambdapants> um, I'll go see if I can make some.  I could upload what I have so far, to my server
04:11:24 <lambdapants> give me a few minutes
04:12:16 <lambdapants> the network server dumps everything in the game world to all the clients 10 times a second, where it should really send about 3 bytes describing just what changed... so it's not really ready for internet play.  still you can kill eachother already...
04:16:33 <chrisdone> EvilTerran: yeah, like it says on that page. <foo> .ijanai <bar> is <foo> is implied by bar, and so it's equivalent to a rule in a logic language. then you can use subscripts to make pattern variables. {daxipa prami daxire .ijanai daxipa speni daxire} = "existing thing 1 loves existing thing 2 is implied by existing thing 1 being married to existing thing 2‚Äù, or simply ‚Äúloves(X,Y) :- married(X,Y).‚Äù so that's a rule. then you have facts, lik
04:18:53 <chrisdone> EvilTerran: I do love you, by the way ‚ô•
04:20:33 <xci> hmm, restructuring my question - is there a function that returns the index of the first element from a list satisfying the condition
04:20:50 <Axman6> indexOf sound familiar
04:21:32 <Axman6> findIndex
04:21:39 <quicksilver> :t findIndex
04:21:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
04:21:43 <quicksilver> yes, that's the one.
04:22:58 <Axman6> maybe indexOf was a java thing...
04:23:03 <Myoma> ?docs Data.List
04:23:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
04:27:44 <Myoma> :(
04:27:52 <Myoma> I get this same problem with cabal again and again
04:28:15 <Myoma> user package database then this is probably due to ghc bug #2201. The
04:28:16 <Myoma> workaround is to register at least one package in the user package db.
04:28:26 <Myoma> and someone told me it's been fixed
04:28:58 <chrisdone> I had that problem.. couldn't fix it
04:29:04 <lambdapants> curses based haskell death: http://www.killersmurf.com/static/textdeath.png
04:29:33 <chrisdone> lambdapants: that cracks me up. great
04:29:38 <lambdapants> one dude is on a lift.  the purple thing is a quake 3 style jump platform.
04:30:38 <quicksilver> hmm. that PNG failed to load here.
04:31:08 <quicksilver> wget fine. *shrug* safari must be odd.
04:31:12 <quicksilver> lambdapants: looks very cool :)
04:31:24 <lambdapants> thankyou.
04:32:05 <chrisdone> lambdapants: I get the feeling you liked to draw stick men fighting eachother at school
04:32:20 <lambdapants> yes, haha.
04:32:35 <chrisdone> lambdapants: ‚Äúand this man .. is falling ... into.. a .. pit.. of... bears...‚Äù
04:33:27 <lambdapants> hehe.
04:33:33 <lambdapants> ÔªøÔªøStill, I can't get a working heads up display.  I looked at hmp3 because it uses curses, but grepping the source there is no "newWin" call...
04:33:55 <osfameron> this place is crawling with bots
04:34:08 <osfameron> oh wait, lambdapants /= bot
04:34:09 <osfameron> sorry
04:35:05 <lambdapants> it's alright.  just a bit of cyber-punk identity problem, mistaking me for a robot.
04:36:18 <Axman6> is it possible to write compile directives so that things like f [1..n] can be matched, when they're special cases for something?
04:36:42 <Axman6> like sum [1..n] = n*(n+1)/2
04:36:57 <Myoma> Axman6: yes, RULES
04:37:10 <Axman6> so you can actually match that sort of thing?
04:38:44 <Myoma> where is the user package database for cabal stored?
04:40:13 <quicksilver> Axman6: it's not really matching, it's cheating using RULES.
04:40:24 <quicksilver> I'm not sure RULES apply to pattern-position.
04:41:15 <lambdapants> goodbye people, things to do.
04:44:16 <EvilTerran> chrisdone, <3
04:49:02 <dcoutts> Myoma: ghc-pkg manages the ghc package db. see eg ghc-pkg list
04:49:03 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
04:49:03 <Saizan> Myoma: it's ghc that stores it, under ~/.ghc
04:49:48 <dcoutts> dmwit: yeah, I noticed that too on a solaris box. I've fixed it already.
04:50:19 <Myoma> so how do I fix this? :)
04:51:56 <dcoutts> Myoma: oh you're using ghc-6.9 are you ?
04:52:02 <Myoma> eys
04:52:04 <Myoma> es
04:52:04 <Myoma> yes
04:52:16 <dcoutts> Myoma: in that case, update, it's been fixed.
04:52:36 <dcoutts> Myoma: or if you do not want to update use the suggested workaround
04:53:03 <Myoma> by update do you mean install this http://www.haskell.org/cabal/release/latest/Cabal-1.4.0.2.tar.gz ?
04:53:23 <dcoutts> Myoma: ghc-6.9 comes with a version of Cabal
04:53:46 <Myoma> I just built and installed ghc 6.9 .. now I get this error
04:54:03 <dcoutts> Myoma: so I mean the latest version of Cabal that gets built with ghc-6.9
04:54:20 <Myoma> I don't know what to do.. :S
04:55:20 <dcoutts> Myoma: if you're getting that message about the workaround and the empty package db then you cannot be using the latest version because the latest version does not contain that error message anymore! :-)
04:55:33 <Myoma> lastest version of what
04:55:39 <dcoutts> Myoma: ghc and Cabal
04:55:58 <Myoma> http://www.haskell.org/ghc/dist/current/dist/
04:55:58 <lambdabot> Title: Index of /ghc/dist/current/dist
04:56:19 <Myoma> I took the one before 20080822
04:56:33 <Myoma> because that extralibs being 14 bytes is suspicious
04:56:50 <dcoutts> Myoma: that's too old I'm afraid
04:57:11 <dcoutts> Myoma: so if you don't want to use the darcs version then you'll have to use the workaround instead
04:57:43 <Myoma> I will use any version
05:00:49 <Myoma> If that is too old, is there a newer one which works?
05:11:36 <Leaves> Hello, do you know of a nicer way then this to see if a number is an integer?   (fromIntegral $ floor r) == r
05:11:55 <Myoma> > divMod 7.3 1
05:11:56 <lambdabot>   Add a type signature
05:12:17 <quicksilver> > truncate 7.3
05:12:18 <lambdabot>   7
05:12:20 <skorpan> > (fromIntegral $ floor 7.5) == 7.5
05:12:21 <lambdabot>   False
05:12:28 <skorpan> > (fromIntegral $ floor 7.0) == 7.0
05:12:29 <lambdabot>  Terminated
05:12:31 <Myoma> > mod' 7.0 1 == 0
05:12:32 <lambdabot>   True
05:12:33 <Myoma> > mod' 7.3 1 == 0
05:12:34 <lambdabot>   False
05:12:40 <Myoma> I have no idea if that actually works
05:12:47 <quicksilver> Leaves: be aware that what you're asking to do is dangerous, with the imprecision of FP numbers.
05:12:49 <Myoma> mod' 7.3 1 < 0.0001 may be safer
05:13:01 <quicksilver> well, 0.0000000001 or something.
05:13:39 <Leaves> quicksilver: good point, I didn't think of that
05:14:44 <Leaves> (in the program I want to know if for Integers a and b if sqrt  (a^2 + b^2) is an Integer), maybe I should not use sqrt but do this in a smarter way?
05:14:45 <Axman6> or just f :: Integer -> integer ; f i = i
05:14:56 <Myoma> Leaves: Certainly!
05:14:57 <Axman6> since it'll whinge if it doesn't get an int ;)
05:15:14 <Myoma> isSquare :: Integer -> Bool can be defined very simply
05:15:15 <quicksilver> Leaves: It's better to use an integer square root, yes.
05:15:23 <int-e> > map ((0 ==) . snd . properFraction) [-1.1,-1,0,0.1,1.7,42]
05:15:25 <lambdabot>   [False,True,True,False,False,True]
05:15:37 <quicksilver> Leaves: but, you can use sqrt safely.
05:15:40 <Myoma> isSquare x = x == square (isqrt x)
05:16:09 <quicksilver> Leaves: let a = round . sqrt . fromIntegral $ x in a * a = x
05:16:15 <quicksilver> sorry, a * a == x
05:16:20 <Axman6> [(a,b) | a <- [1..100], b <- [1..100], c <- [1..100], a*a + b*b = c*c
05:16:23 <Axman6> ]
05:16:23 <quicksilver> Leaves: point is to use (==) in the integer domain.
05:16:28 <quicksilver> not in the Double one.
05:16:36 <Axman6> probably not quite what you want though...
05:16:54 <drigz> @pl \x -> x == f x
05:16:54 <lambdabot> ap (==) f
05:16:56 <quicksilver> also "round" is guaranteed to round in the correct direction for all integers which are within the precision of double anyway.
05:17:02 <Axman6> @src ap
05:17:03 <lambdabot> ap = liftM2 id
05:17:11 <Axman6> hmm
05:17:28 <int-e> Leaves: http://mathworld.wolfram.com/PythagoreanTriple.html -- look for "The early Greeks gave"
05:17:33 <lambdabot> Title: Pythagorean Triple -- from Wolfram MathWorld
05:18:07 <Myoma> Leaves: To get there, consider   isEven x = x == double (halve x)
05:19:42 <luite> > double 2
05:19:43 <lambdabot>   2.0
05:20:41 <Myoma> @index double
05:20:41 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
05:20:51 <Myoma> :t double
05:20:52 <lambdabot> Double -> Doc
05:20:59 <Myoma> hah
05:21:08 <Myoma> I meant double as in multiply by two
05:21:46 <Myoma>                                                              
05:24:05 <Leaves> Myoma: where is isqrt defined?
05:24:15 <Myoma> Leaves: wikipedia
05:24:40 <Leaves> quicksilver: I understand what you mean in general but I will study the code some more
05:24:58 <Leaves> int-e: I will read that poage, looks interesting, but it will take some time :)
05:25:02 <Leaves> Myoma: ok
05:25:23 <quicksilver> the "right" thing is an efficient integer square root algorithm.
05:25:29 <quicksilver> binary chop is not bad.
05:25:35 <quicksilver> newton will be faster.
05:25:45 <quicksilver> GMP has one built in but GHC's binding does not expose it :(
05:25:46 <Myoma> oh
05:26:07 <Myoma> can it be stole back via ffi?
05:26:19 <quicksilver> no, because you can't re-ffi to libraries the RTS binds
05:26:25 <quicksilver> a rather annoying implementation detail.
05:32:51 <yitz> quicksilver: have you tried newton vs binsearch for isqrt? are you sure it's faster?
05:33:01 <quicksilver> no.
05:33:13 <guenni2> are there any samples how to work with 2D Arrays?
05:33:13 <quicksilver> but it should be, sqrt is a nice smooth curve with good tangents.
05:33:29 <quicksilver> guenni2: just the same as 1D arrays except your index is a tuple?
05:34:05 <guenni2> quicksilver: lol, so are there any Examples how to work with 1D Arrays?
05:34:30 <guenni2> quicksilver: I'm really thick as you may have noticed :)
05:34:41 <quicksilver> I don't know of any examples.
05:34:51 <quicksilver> as far as I know the type signatures say it all.
05:35:02 <quicksilver> look at IArray for immutable and MArray for mutable
05:35:05 <quicksilver> and ask here if you have questions.
05:35:55 <guenni2> thx
05:37:03 <Axman6> guenni2: the answer really depends on what you want to do
05:37:55 <guenni2> well I need a data structure to hold values, like a table, rows and cols
05:38:06 <yitz> > let newton x = iterate (\y -> y - (y*y-x) `div` (2*y)) x in newton 12345
05:38:07 <lambdabot>   [12345,6173,3088,1546,777,397,215,137,114,112,112,112,112,112,112,112,112,1...
05:38:10 <Axman6> and what do you want to do with it?
05:38:18 <Myoma> yitz, cool!
05:38:43 <Myoma> @let iterateProgress f x = let fx = f x in if fx == x then x else iterateProgress f fx
05:38:44 <lambdabot>  Defined.
05:38:53 <Myoma> @let isqrt = iterateProgress (\y -> y - (y*y-x) `div` (2*y))
05:38:54 <lambdabot>   Parse error
05:38:59 <guenni2> Axman6: just read them
05:39:06 <Myoma> :?
05:39:29 <guenni2> Axman6: no fancy transformations or anything
05:39:46 <Axman6> well use lists if lists then
05:40:04 <Axman6> i don't know much about haskell arrays as such, only lists
05:40:26 <guenni2> Axman6: I guess I'll do just that, it does seem the easiest way
05:40:34 <yitz> > let binSearch x = iterate (\(a,b) -> let c=(a+b)`div`2 in if c*c > x then(a,c)else(c,b)) (0,x) in binSearch 12345
05:40:38 <lambdabot>   [(0,12345),(0,6172),(0,3086),(0,1543),(0,771),(0,385),(0,192),(96,192),(96,...
05:40:38 <Saizan> Myoma: i guess it's complaining about x
05:40:39 <Myoma> @let isqrt x = iterateProgress (\y -> y - (y*y-x) `div` (2*y)) x
05:40:39 <lambdabot>   Parse error
05:41:03 <yitz> > let binSearch x = map fst $ iterate (\(a,b) -> let c=(a+b)`div`2 in if c*c > x then(a,c)else(c,b)) (0,x) in binSearch 12345
05:41:08 <lambdabot>   [0,0,0,0,0,0,0,96,96,96,108,108,111,111,111,111,111,111,111,111,111,111,111...
05:41:28 <yitz> > let binSearch x = map snd $ iterate (\(a,b) -> let c=(a+b)`div`2 in if c*c > x then(a,c)else(c,b)) (0,x) in binSearch 12345
05:41:32 <lambdabot>   [12345,6172,3086,1543,771,385,192,192,144,120,120,114,114,112,112,112,112,1...
05:42:13 <yitz> about the same. Newton wins 12 to 14 here.
05:42:46 * quicksilver nods
05:42:58 <quicksilver> newton generally wins.
05:43:02 <Myoma> :t forever
05:43:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
05:43:42 <yitz> quicksilver: I think there are functions for which Newton doesn't even converge. Whereas binSearch is guaranteed.
05:43:55 <guenni> is "Purely functional data structures" a good read when you do Haskell?
05:44:32 <Axman6> yitz: there are
05:45:12 <quicksilver> yitz: there are functions for which binsearch fails.
05:45:31 <quicksilver> yitz: and ones for which is doesn't converge.
05:45:45 <yitz> monotonic
05:45:45 <quicksilver> just the classes are different.
05:46:49 <yitz> you wouldn't want to use either for non-monotonic, and binsearch is guaranteed O(log n) on all monotonic.
05:47:10 <int-e> newton will profit a lot from using a better initial value.
05:47:11 <Axman6> speaking of such things, i found out the other day that it's quite easy to represent a square wave using the sum of sinusoids. it's fairly strange to play with
05:47:21 <yitz> Newton is only slightly fast when it works, but there are monotonic functions where it is much slower, or even diverges.
05:47:52 <Myoma> hm
05:47:56 <Myoma> @where mmorrow
05:47:59 <lambdabot> I know nothing about mmorrow.
05:48:02 <Myoma> :(
05:48:25 <Myoma> I can't figure a good way to shoehorn state into this httpd
05:48:34 <Myoma> I'll just do it in the most obvious way
05:49:35 <lilac> > let x = 12345 in iterate (\y -> (y + (x `div` y)) `div` 2) x
05:49:39 <lambdabot>   [12345,6173,3087,1545,776,395,213,135,113,111,111,111,111,111,111,111,111,1...
05:50:30 <lilac> ^^ should iterate faster than N-R but converge about as fast
05:51:15 <quicksilver> how do you interate faster?
05:51:22 <Myoma> @src forever
05:51:22 <lambdabot> Source not found.
05:51:24 <quicksilver> oh, I see what you mean.
05:51:39 <Axman6> > forever [1]
05:51:45 <r3m0t> @src repeat
05:51:46 <lambdabot> repeat x = xs where xs = x : xs
05:51:47 <lambdabot>   mueval: Prelude.read: no parse
05:51:47 <lambdabot>  mueval: *** Exception: stack overflow
05:52:12 <Axman6> > forever (Just 1)
05:52:21 <Myoma> forever a   = a >> forever a
05:52:28 <lambdabot>   thread killed
05:52:39 <r3m0t> @src repeatM
05:52:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
05:53:09 <r3m0t> @hoogle (a -> m a) -> m [a]
05:53:09 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:53:09 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:53:09 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
05:53:19 <r3m0t> @hoogle (a -> m a) -> a -> m [a]
05:53:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:53:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
05:53:20 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
05:53:27 <r3m0t> ...
05:54:47 <FunctorSalad> > ((replicateM 5) .)
05:54:51 <lambdabot>       Overlapping instances for Show ((a -> m a1) -> a -> m [a1])
05:54:51 <lambdabot>        aris...
05:54:59 <FunctorSalad> @type ((replicateM 5) .)
05:55:01 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> a1 -> m [a]
05:55:06 <r3m0t> @hoogle Monad m => m a -> m ()
05:55:07 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
05:55:07 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
05:55:07 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
05:58:40 <int-e> > let newton x = let w 1 = 0; w n = let t = length $ takeWhile (<= n) (iterate (^2) 4) in 2^t + w (n `div` 2^(2^t)) in iterate (\y -> (y + (x `div` y)) `div` 2) (2^(w x `div` 2)) in newton 938402198649171
05:58:45 <lambdabot>   [16777216,36355172,31083620,30636612,30633351,30633351,30633351,30633351,30...
05:59:59 <r3m0t> > sqrt  938402198649171
06:00:05 <lambdabot>   3.063335108422144e7
06:01:11 <yitz> [sum . map . sin . (2*pi*x*) $ [1..100] | x <- [0,0.01..1]]
06:01:22 <int-e> hmm, bad newton iteration
06:01:27 <quicksilver> yitz: I must admit I never found this stuff particularly interesting so it doesn't stick in my mind, but binsearch is guaranteed for continuous monotonic and isn't newton guaranteed for continuous monotonic derivative?
06:01:37 <yitz> > [sum . map . sin . (2*pi*x*) $ [1..100] | x <- [0,0.01..1]]
06:01:41 <lambdabot>   Couldn't match expected type `[a]'
06:01:42 <int-e> > let x = 20 in iterate (\y -> (y + (x `div` y)) `div` 2) 4
06:01:43 <quicksilver> sufficient although not necessary.
06:01:47 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
06:01:56 <int-e> > let x = 24 in iterate (\y -> (y + (x `div` y)) `div` 2) 4
06:02:01 <lambdabot>   [4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,...
06:02:49 <yitz> > [sum . flip map [1..100] $ sin . (2*pi*x*) | x <- [0,0.01..1]]
06:02:55 <lambdabot>   [0.0,7.346220571045038e-15,-3.233252659651677e-16,-9.640984032894686e-17,2....
06:05:34 <yitz> quicksilver: no because newton depends on the shape of the curve, it can send the tangent line flying off every which way.
06:06:25 <quicksilver> yitz: but if the derivative is continuous and monotonic it doesn't go every which way.
06:06:57 <Myoma> ?docs Network.Socket
06:06:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
06:11:54 <mm_freak> http://hpaste.org/10062 ‚áê this is a solution to projecteuler.net's problem 15‚Ä¶  any way to optimize it even more?  (just for the sake of understanding)
06:12:40 <mm_freak> (not that it's slow‚Ä¶  it takes less than 2 ms on my machine)
06:13:05 <Botje> what's euler15 again ..
06:13:12 <mm_freak> http://projecteuler.net/index.php?section=problems&id=15
06:13:14 <lambdabot> Title: Problem 15 - Project Euler
06:13:16 <Botje> oh.
06:13:22 <Botje> yeah, i did something similar
06:13:50 <Botje> is there a reason you're going from (0,0) to (m-1,n-1) instead of (1,1) -> (m,n) ?
06:14:07 <mm_freak> not really‚Ä¶  it just appears more natural to me
06:14:15 <Botje> why?
06:14:29 <Botje> waysTable (m,n) ! (m-1,n-1) -- is very confusing
06:14:30 <mm_freak> because i thought of lines from some point in space to the origin
06:14:37 <mm_freak> ok, gimme a second
06:14:52 <yitz> > let newton x = iterate (\y->y-1+12345`div`(round . exp . fromIntegral $ y)) x in newton 5 :: [Integer]
06:14:57 <lambdabot>   [5,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,...
06:15:13 <BeelsebobWork> mm_freak: think about the maths of it -- it can be computed *very* fast
06:15:14 <yitz> quicksilver: so no, that's not good enough either.
06:15:17 <Saizan> mm_freak: maybe you can avoid the array, you seem to traverse it in a fairly ordered way
06:15:40 <BeelsebobWork> and you don't need to do any traversals of anything
06:15:41 <yitz> (computing exp 12345 using Newton - very, very slow)
06:15:44 <mm_freak> http://hpaste.org/10062#a1
06:15:56 <BeelsebobWork> the problem is designed so that it's not possible to solve sensibly by making all the traversals
06:16:01 <Botje> see? much nicer ;)
06:16:22 <mm_freak> BeelsebobWork: my solution takes less than 2 ms =)
06:16:31 <mm_freak> it doesn't calculate all paths
06:16:41 <BeelsebobWork> exactly
06:16:47 <BeelsebobWork> but you don't even need to calculate 1 path
06:17:01 <mm_freak> BeelsebobWork: you mean, there is an algebraic solution?
06:17:04 <BeelsebobWork> yes
06:17:04 <Botje> that list comprehension is just map numWays $ range (...)
06:17:19 <mm_freak> Botje: true
06:17:24 <lilac> mm_freak: yes, there is a quicker way.
06:17:25 <Botje> yeah, you can solve it with combinatorics
06:17:44 <lilac> > product [21..40] / product [1..20]
06:17:45 <BeelsebobWork> mm_freak: given that you must construct sentences of 1s and 0s, 40 characters long, and each sentence must contain 20 1s and 20 0s, how many can you construct?
06:17:49 <lambdabot>   1.3784652882e11
06:18:46 <r3m0t> > product [21..40] `div` product [1..20]
06:18:51 <lambdabot>   137846528820
06:19:16 <mm_freak> BeelsebobWork: uhm‚Ä¶  i've never been good at combinatorics‚Ä¶  maybe i should learn all that stuff first
06:19:30 <mm_freak> but what comes to my mind is permutations
06:20:23 <lilac> mm_freak: one way to solve it is as follows: consider paths to the middle diagonal. these are sequences of Left and Right moves, all independent. each path from corner to corner is a path to a diagonal followed by another one.
06:20:54 <lilac> the number of Ls tells you which point along the diagonal you hit.
06:20:56 <mm_freak> now i got how those two problems are similar
06:21:00 <mm_freak> in fact, they're the same
06:21:08 <BeelsebobWork> mm_freak: :)
06:21:14 <mm_freak> one way up is 1, one way right is 0
06:21:19 <BeelsebobWork> exactly
06:21:33 <BeelsebobWork> all ways across involve 20 ups and 20 rights, just in different orders
06:22:05 <mm_freak> is there a formula or does it still involve an algorithm?
06:22:29 <BeelsebobWork> there is a formula
06:23:59 <mm_freak> ok, now that i know the problem pattern, i could just go and open wikipedia for the formula‚Ä¶  but then it wouldn't be my solution anymore =)
06:24:05 <Myoma> @seen chessguy
06:24:06 <lambdabot> I haven't seen chessguy.
06:24:21 <mm_freak> so i'll try it on my own first‚Ä¶  thanks for that hint
06:24:34 <quicksilver> preflex: seen chessguy
06:24:34 <preflex>  chessguy was last seen on ##c++ 3 days, 10 hours, 28 minutes and 23 seconds ago, saying: on my channel list
06:24:46 <BeelsebobWork> mm_freak: np, have fun
06:24:54 <Myoma> :t ap
06:24:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:24:57 <Myoma> :t ap fst snd
06:24:59 <lambdabot> forall b b1. (b -> b1, b) -> b1
06:25:06 <Myoma> :t uncurry ($)
06:25:09 <lambdabot> forall a b. (a -> b, a) -> b
06:25:56 <quicksilver> MarcWeber: doesn't HaXML already have a validating mode?
06:26:00 <quicksilver> MarcWeber: how is your vxml better?
06:26:17 <MarcWeber> quicksilver: It does validate at compile time
06:26:35 <malcolmw> I think the idea is that vxml builds valid XML by construction, whilst HaXml just checks afterwards
06:27:11 <quicksilver> malcolmw: but isn't that what HaXml's (admittedly troublesome) DtDToHaskell code does?
06:27:24 <Myoma> does anyone know where chessguys code is?
06:27:35 <malcolmw> quicksilver: kinds sorta
06:27:38 <quicksilver> ;)
06:28:46 <quicksilver> sporadically I'm quite interested in the mapping being semistructured (XML, YAML, etc) to strongly typed.
06:29:00 <quicksilver> it's fiddly enough that it doesn't hold my interest for long enough for me to actually solve anything.
06:29:08 <quicksilver> quicksilver-- # flightly
06:30:12 * earthy hugs parsec
06:31:00 <dmhouse> Has anyone read `I am a Strange Loop'?
06:32:19 <earthy> hadn't even heard about the book, but the association with GEB was correct. ;)
06:32:54 <dmhouse> It's the successor to GEB, been out a couple of years I think. I've just got it out of the library, wondering if anyone had any opinions.
06:33:02 <mm_freak> the sum of the digits of 2^1000:  sum $ map (`rem` 10) $ takeWhile (/= 0) $ iterate (`div` 10) $ 2^1000
06:33:11 <mm_freak> is there a more elegant way to do it?
06:34:09 <Deewiant> > sum . map ord . show $ 2^1000
06:34:13 <earthy> dmhouse: 2007. :)
06:34:15 <lambdabot>   15862
06:34:21 <mm_freak> Deewiant: that's wrong
06:34:27 <mm_freak> ord '0' == 48
06:34:33 <int-e> > sum . map digitToInt . show $ 2^1000
06:34:35 <Deewiant> oh, right, oops
06:34:38 <lambdabot>   1366
06:34:56 <mm_freak> well, that solution is technically the same
06:35:13 <Deewiant> > sum . map ((-48).ord) . show $ 2^1000
06:35:15 <Myoma> "technically" it's different
06:35:17 <lambdabot>       No instance for (Num (Int -> c))
06:35:17 <lambdabot>        arising from a use of `negate' ...
06:35:18 <Deewiant> arg
06:35:25 <mm_freak> Myoma: mathematically
06:35:26 <Deewiant> > sum . map (subtract 48.ord) . show $ 2^1000
06:35:31 <lambdabot>   1366
06:35:32 <mm_freak> i'm asking because there may be a shortcut which i missed
06:35:40 <dmhouse> Deewiant: you should use spaces around .
06:35:51 <dmhouse> > (Just.negate) False
06:35:52 <Deewiant> I "should"?
06:35:55 <lambdabot>       Failed to load interface for `Just':
06:35:55 <lambdabot>        Use -v to see a list of the...
06:36:00 <dmhouse> ^^ otherwise confusion like that arises.
06:36:02 <mm_freak> one that doesn't require me to calculate 2^1000 in the first place
06:36:12 <xci> how does one usually implement dynamic programming with haskell, as global mutable arrays seem to be quite non-existant?
06:36:14 <Deewiant> the compiler knows when the confusion arises and can tell me :-P
06:36:25 <quicksilver> xci: by using a local mutable structure
06:36:26 <Deewiant> especially in short expressions like map (f.g) I tend to leave it out
06:36:27 <MarcWeber> quicksilver: http://hpaste.org/10063
06:36:29 <yitz> > foldl' (+) 0 . map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) $ 2^1000
06:36:34 <lambdabot>   1366
06:36:35 <quicksilver> xci: or a local structure with efficient pure update.
06:36:47 <quicksilver> xci: nothign about dynamic programming needs globality.
06:37:14 <quicksilver> MarcWeber: good answer to my question.
06:37:17 <quicksilver> MarcWeber: looks nice.
06:37:31 <earthy> wtf? haskell.org not responding?
06:37:39 <mm_freak> yitz: yeah, that's almost my solution, though i used 'sum' and 'rem' instead
06:38:04 <mm_freak> (rem is faster than mod)
06:38:18 <earthy> oh, just slow.
06:38:30 <MarcWeber> quicksilver: But I'm still not sure how to write some sugar
06:38:33 <Saizan> quicksilver: or a local lazy immutable structure :)
06:38:52 <yitz> mm_freak: sum is still broken (last I heard). sometimes works, sometimes blows the stack.
06:38:58 <quicksilver> Saizan: yes, although that sometime requires a little more thought.
06:39:07 <MarcWeber> Does hackage support publishing repo urls if your library is too unstable yet to make a real distribution package?
06:39:13 <quicksilver> Saizan: not all dynamic prog. algorithsm are all obviously immediately expressible in that form.
06:39:20 <xci> quicksilver: yeah, but if I am calling a function recursively, how can the same local mutable array be seen in these recursively called functions?
06:39:28 <quicksilver> xci: by passing it as a parameter.
06:39:29 <int-e> > sum . map digitToInt . show $ 2^1000000
06:39:31 <mm_freak> yitz: true
06:39:32 <Myoma> xci, if it's in scope
06:39:38 <lambdabot>   mueval: Prelude.read: no parse
06:39:38 <lambdabot>  mueval: *** Exception: stack overflow
06:39:40 <mm_freak> but it works well in GHC 6.8's base
06:39:54 <Saizan> xci: seen this? http://hpaste.org/10062
06:39:57 <Myoma> > let x = 3 in let f e = x : e : f (e+x) in f 2
06:40:02 <lambdabot>   [3,2,3,5,3,8,3,11,3,14,3,17,3,20,3,23,3,26,3,29,3,32,3,35,3,38,3,41,3,44,3,...
06:40:26 <int-e> > foldl' (+) 0 . map digitToInt . show $ 2^1000000
06:40:27 <xci> Saizan: lol, actually I was just doing the same exercise :P
06:40:33 <lambdabot>   1351546
06:41:04 <matthew-_> > let f = (foldr (.) id) (replicate 48 pred) in sum . map (f . ord) . show $ 2^1000
06:41:09 <lambdabot>   1366
06:41:12 <xci> Saizan: thank :)
06:41:16 <xci> thanks*
06:41:38 <Saizan> xci: np, the code is from mm_freak :)
06:42:35 <mm_freak> Saizan: though as BeelsebobWork pointed out, there is a more elegant, combinatorial solution, which doesn't involve any algorithm
06:42:39 <BeelsebobWork> xci: scroll up for interesting discussion about much faster way of doing it
06:42:50 <BeelsebobWork> but yeh, mm_freak's solution is nice
06:42:58 <BeelsebobWork> and I have to admit, I solved it that way first too
06:43:20 <mm_freak> Jedai gave me that idea yesterday for problem 14
06:43:30 <mm_freak> problem 15 appeared to have the same pattern to me
06:43:33 <xci> yeah certainly a formula can be constructed
06:43:47 <xci> but I am not trying to study maths, but haskell instead ;)
06:44:13 <mm_freak> xci: then the solution is a good example‚Ä¶  it shows haskell in its deepest essence =)
06:44:15 <Myoma> xci: Don't bother with project euler then
06:44:36 <BeelsebobWork> xci: bear in mind that 90% of the problems of project euler are about a bit of mathematical thinking followed by only a little programming
06:44:54 <Myoma> @let n z s 0 = z ; n z s x = s (x-1)
06:44:59 <lambdabot>  Defined.
06:45:06 <Myoma> @let digits = unfoldr (n Nothing (Just . swap . flip divMod 10 . (+1)))
06:45:07 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
06:45:19 <mm_freak> Myoma, BeelsebobWork, xci: but expressing the solutions in haskell is a good exercise
06:45:20 <xci> BeelsebobWork: yeah, but I am not doing Project Euler for the sake of solving problems, but for the sake of learning a new language, as it seems to be tremendous for that purpose
06:45:28 <Myoma> @let swap (x,y) = (y,x)
06:45:29 <Myoma> @let digits = unfoldr (n Nothing (Just . swap . flip divMod 10 . (+1)))
06:45:30 <lambdabot>  Defined.
06:45:31 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
06:45:32 <mm_freak> it was of great help to me to drop my imperative thinking
06:45:38 <Myoma> weird ...
06:46:10 <quicksilver> xci: I think it teaches you a slightly unnatural fragment of the language.
06:46:16 <quicksilver> xci: but its' certainly a useful tool.
06:48:24 <BeelsebobWork> xci: yeh, it's excellent for that
06:50:06 <mm_freak> quicksilver: i don't think it's too unnatural, because the most difficult part for a haskell beginner isn't finding a solution, but expressing it in the language
06:50:38 <quicksilver> mm_freak: well it teaches you a lot about lists, memoization, and haskell numerics.
06:50:38 <mm_freak> at least for most of the problems
06:50:43 <FunctorSalad> math tends to be unusually well-behaved though ;)
06:50:50 <quicksilver> mm_freak: but it doesn't teach you about custom data types or using monads.
06:51:08 <quicksilver> to my mind using custom data types is one of the big milestones of moving from another language to haskell.
06:51:24 * FunctorSalad comes to this discussion straight from trying to process malformed html ;)
06:51:41 <BeelsebobWork> quicksilver: yeh, one of the biggest hurdles with Haskell is using something that isn't a list
06:51:42 <mm_freak> yeah, but perhaps custom data types and monads can be learned better using a tutorial and some dedicated exercises
06:51:49 * quicksilver <blink/>s at FunctorSalad 
06:52:32 <FunctorSalad> Tagsoup is nice for the task but I still have to dig through it...
06:52:38 <Wild_Cat> <kick target="quicksilver" reason="using the B-tag" />
06:52:39 <Myoma> is there other ways to do multiline strings than
06:52:42 <Myoma>  unlines [
06:52:43 <Myoma>  "foo",
06:52:47 <Myoma>  "bar", ..
06:52:47 <mm_freak> i think, once you've grasped monads and the type system, it's all a matter of expression solutions
06:52:48 <quicksilver> Myoma: Yes, there are.
06:52:53 <mm_freak> s/expression/expressing/
06:52:54 <quicksilver> although personally I find that is the best one.
06:52:57 <Deewiant> Myoma: "foo\nbar" ;-)
06:53:05 <mm_freak> being declarative instead of imperative
06:53:49 * FunctorSalad used StateT in the wild for the first time... I guess you have to be careful not to be lazy and abuse it ;)
06:54:27 <FunctorSalad> but for passing around the state in a event/draw loop it's ok I guess
06:54:38 * shapr grumbles
06:54:45 <Myoma> hey shapr
06:54:46 <quicksilver> FunctorSalad: the draw loop keeps it honest, typically.
06:54:50 * BeelsebobWork pokes shapr in the unicycle
06:55:00 <quicksilver> FunctorSalad: although you have to be a little bit careful about accumulating thunks in never-used fields.
06:55:03 <Myoma> what's going on?
06:55:12 <BeelsebobWork> FunctorSalad: don't use an event/draw loop, or pass around state -- use FRP
06:55:21 <FunctorSalad> FRP?
06:55:28 <BeelsebobWork> Functional Reactive Programming
06:55:38 <quicksilver> I think that's a great idea but I don't think it's quite ready yet.
06:55:57 <quicksilver> I spent quite some time pondering how to fit it to a couple of my projections.
06:55:59 <quicksilver> projects.
06:56:01 <quicksilver> damn fingers.
06:56:24 <BeelsebobWork> I think it's ready -- I think it's at that stage where no one thinks its ready, because no one else has used it yet
06:56:30 <quicksilver> autocomplete built in to the phalanges.
06:56:35 <BONUS> i think the whole idea of making typeclasses for more abstract behavior (like stuff that can be appended, mapped over, sequenced) in Haskell is genius
06:56:36 <BeelsebobWork> (but then, I'm in the middle of using it)
06:56:49 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in (evalStateT . replicateM 4 $ StateT select) [1,2,3,4]
06:56:50 <quicksilver> BeelsebobWork: then make a blog post showing how to use it for a typical app. or a mailing list post. or something.
06:56:55 <lambdabot>   [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1...
06:56:55 <quicksilver> BeelsebobWork: and point me at it :)
06:57:05 <BeelsebobWork> quicksilver: I think David Sankel's in the middle of doing that
06:57:22 <quicksilver> also I think the 'draw part' of the traditional loop is fine.
06:57:26 <quicksilver> nothing wrong with
06:57:34 <quicksilver> renderFrame :: AppState -> IO ()
06:57:47 <FunctorSalad> quicksilver: hehe that's my exact sig
06:57:58 <FunctorSalad> (except I wrote StateT AppState IO ())
07:00:21 <BeelsebobWork> quicksilver: not sure -- I'd rather go for AppState -> SceneGraph
07:00:35 <BeelsebobWork> and use something else to hide the fact that IO has to go on somewhere
07:00:41 <quicksilver> BeelsebobWork: Yes. That would indeed be nicer.
07:00:42 <Myoma> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] ; insert (e,[]) = [[e]] ; insert (e,x:xs) = (e:x:xs) : map (x:) (insert (e,xs)) in insert =<< select [1,2,3]
07:00:48 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1],[2,1,3],[1,2,3],[1,3,2],[3,1,2],[1,3,2],[1,2,3]]
07:00:49 <quicksilver> but inventing SceneGraph is not a zero-cost addition.
07:00:56 <quicksilver> it's not even a low-cost addition actually.
07:01:00 <BeelsebobWork> quicksilver: I'm not convinced of that
07:01:07 <quicksilver> I do agree it's nicer.
07:01:14 <quicksilver> FunctorSalad: ah, you got that wrong then :)
07:01:24 <Myoma> :/
07:01:25 <BeelsebobWork> in fact, given a few months time, I may be in a position to convince you it's a negative-cost operation
07:01:28 <quicksilver> FunctorSalad: StateT AppState IO () is much worse.
07:01:38 <BeelsebobWork> in at least the majority of cases
07:01:46 <quicksilver> FunctorSalad: because that gives the renderFrame the ability to alter the state
07:01:56 <quicksilver> FunctorSalad: which (I hope) you don't intend to exercise.
07:02:20 <quicksilver> BeelsebobWork: I'm not sure how you'll convince me of that.
07:02:26 <quicksilver> you don't know what my applications do.
07:02:29 <dmhouse> ReaderT AppState IO (), then.
07:02:40 <BeelsebobWork> quicksilver: yep, you may not fit into my "majority of cases"
07:02:47 <dmhouse> (Which is of course isomorphic to AppState -> IO ().)
07:02:48 <quicksilver> adding an extra level of abstraction between my 'state' and my 'IO rendering actions' is obviously a cost.
07:02:57 <quicksilver> I'm not saying it isn't a cost with an associated benefit :)
07:03:03 <BeelsebobWork> quicksilver: what we seem to be discovering at the moment is that as we get more abstract, we can do more on the GPU, that the programmer didn't realise they could
07:03:10 <FunctorSalad> quicksilver: right, I didn't use it. but my thing is not very fast-paced, it just renders a diagram that changes upon user input
07:03:12 <quicksilver> yes, that's true enough.
07:03:37 <quicksilver> FunctorSalad: it's not really about that. It''s about specifying your types nicely. It's nice to enforce that the rendering loop can't change the state.
07:04:05 <quicksilver> FunctorSalad: given a further Eq AppState you can even automatically not bother to call it if the state hasn't changed :)
07:04:36 <quicksilver> BeelsebobWork: Yes, but the penalty is forcing the programming into a predefined scene graph model.
07:04:42 <FunctorSalad> quicksilver: I have a "do_refresh" boolean in my AppState for that
07:04:42 <quicksilver> BeelsebobWork: which may not fit with what they had planned.
07:04:56 <quicksilver> a fully general scene graph model is quite hard to write.
07:04:58 <BeelsebobWork> quicksilver: yep, hopefully we'll be doing something general enough that that isn't an issue
07:05:05 <quicksilver> in many cases you find trade-offs
07:05:05 <BeelsebobWork>  /agree
07:05:15 <quicksilver> (reflection algorithms, shadow algorithms, for example)
07:05:18 <BeelsebobWork> there's a reason why we got conal to work on this
07:05:19 <FunctorSalad> quicksilver: but I agree that giving it write access was pure carelessness ;)
07:05:19 <BeelsebobWork> :P
07:13:11 <quicksilver> FunctorSalad: I find this quite interesting.
07:13:25 <quicksilver> FunctorSalad: the interaction between functions of type MonadState s, MonadReader s
07:13:35 <quicksilver> also MonadState t where t is a 'subobject' of s.
07:13:49 <quicksilver> it's not yet well explored enough to be seemless.
07:14:56 <seydar> whoever wrote parsec
07:14:58 <seydar> thank you
07:15:17 <Myoma> I am starting the Parsec fan club
07:16:19 <matthew-_> Myoma: imho, polyparse is better than parsec. Mainly because it'll do real lazy parsing
07:17:11 <mornfall> matthew-_: How about performance?
07:17:13 <Myoma> any parsers and pretty printers which get derived together?
07:17:25 <Cale> seydar: Daan Leijen originally, but there's been some more recent work put in, if I'm remembering things straight, by Paolo Martini.
07:17:36 <matthew-_> mornfall: I've never used either parser in a performance critical path
07:17:44 <Cale> (and Philippa Cowderoy?)
07:18:09 <araujo> morning
07:18:40 <seydar> matthew-_: polyparse?
07:18:54 <matthew-_> seydar: cabal install polyparse
07:19:00 <seydar> parsec was written by a dutcch lad!
07:19:09 <mornfall> And API-compatibility to parsec? When I have a parsec parser, how much work to get it over to polyparse?
07:20:20 <matthew-_> mornfall: well it's basically the same. It's missing some of the higher level stuff but, eg, if you look at my graphviz package on hackage, there's a combinators module in there that gets you a lot closer which you could just use if you wanted. It's certainly not as rich as parsec is by default
07:20:39 <Cale> I find it curious that polyparse has a bunch of modules which have "NoLeak" in the module path. Does that mean we should expect the others to leak memory? :)
07:20:54 <matthew-_> undetermined ;)
07:21:22 <mornfall> matthew-_: Okey, thanks. I'll keep that in mind. :)
07:21:23 <malcolmw> Cale: yes, you can expect some of the not-NoLeak versions to leak
07:21:36 <seydar> damn, haskell is soooo nice
07:22:55 <matthew-_> I really like doing hGetContents on a handle and then just pushing the result through polyparse, to get a lazy stream of parsed output. You can't do this with parsec. However, it does make error handling harder.
07:24:04 <mornfall> matthew-_: It presumably also tends to leak FDs. (Hm. About lazy IO and leaking descriptors, is there a systematic solution to that, somewhere?)
07:24:08 <Saizan> matthew-_: yeah, how do you handle them? C.E.catch?
07:24:20 <matthew-_> Saizan: nah, just pretend they never happen ;)
07:24:42 <Saizan> that's how Plugin.Seen got broken :\
07:24:43 <FunctorSalad> error "Catastrophic failure"
07:25:06 <mornfall> ... : - )
07:25:11 <matthew-_> oh shuush. It's fine. Sort of :)
07:25:43 <mornfall> (Actually, the laziness versus errors is an interesting problem in itself...)
07:25:44 <seydar> how long have you all been using haskell?
07:25:49 <FunctorSalad> wasn't directed at you matthew-_ ;)
07:25:53 <dmwit_> 40 years!
07:26:00 <mornfall> Bwaha. :)
07:26:30 <Saizan> mornfall: there's work on incremental parsers that can get the data in chunks  as well as return intermediate results
07:26:45 <FunctorSalad> matthew-_: I actually used your graphviz package today :)
07:27:05 <matthew-_> FunctorSalad: YAY! did it work? I don't seem to have received any bug reports!
07:27:27 <FunctorSalad> matthew-_: yes, it worked (but I only did a basic example yet)
07:28:04 <Cale> seydar: Close to 5 years for me now.
07:29:08 <Cale> I wonder what Lennart's up to :)
07:29:28 <thatsright> ive installed cabal-install but "cabal get" does not work
07:29:51 <dcoutts_> thatsright: did you mean "cabal install" ?
07:30:01 <dcoutts_> thatsright: see cabal --help
07:30:03 <seydar> can i use: return case sdf of ..... ?
07:30:13 <matthew-_> FunctorSalad: I should probably get that graphviz package to replace the rubbish thing in the base libraries: data.graph.inductive.graphviz or something. It's truly awful.
07:30:15 <Myoma> libraries/Cabal/Distribution/Compat/Exception.hs:21:14:
07:30:15 <Myoma>     Not in scope: `Exception.onException'
07:30:18 <dmwit_> seydar: try "return $ case sdf of"
07:30:20 <Myoma> is a weird error ..
07:30:37 <seydar> dmwit_: k, just checking if that construct was possible
07:30:51 <dmwit> seydar: When in doubt, try it. =)
07:30:51 <Cale> Alternately, wrap the case expression in parens.
07:31:01 <dcoutts_> Myoma: when Cabal is built using ghc-6.9 it expects to work with the latest versions of the base libs.
07:31:04 <FunctorSalad> matthew-_: just a minor bug, apparently graphToGraph had a problem with special characters in "label" attributes (square brackets I guess)
07:31:16 <FunctorSalad> (didn't reparse)
07:31:29 <dcoutts_> Myoma: you could try making it think it's working with ghc-6.8 but I dunno if that'd work.
07:31:31 <matthew-_> FunctorSalad: ahh, yes, that doesn't surprise me. Patches are welcome!
07:31:37 <FunctorSalad> or wait, I think the square brackets worked. must have been something else
07:31:57 <Saizan> FunctorSalad: quotes?
07:32:06 <dcoutts_> Myoma: basically you've got version skew between your ghc and cabal, you've got dev versions of each but not versions that work together.
07:32:09 <FunctorSalad> Saizan: yeah could well be
07:32:23 <FunctorSalad> maybe I accidentally showed a String
07:32:39 <Myoma> dcouotts_: It seemed to build when I took out #define NEW_EXCEPTION but after that the same cabal build thing happens
07:32:45 <Myoma> I just got the darcs of GHC
07:33:04 <Myoma> maybe that's not the right thing then
07:33:19 <thatsright> Intended usage:
07:33:19 <thatsright>   cabal install xmonad
07:33:36 * FunctorSalad keeps typing cabal-install...
07:33:45 <thatsright> ok
07:33:49 <matthew-_> FunctorSalad: the arbitrary string parser understands '\'-escaped char pairs fine
07:33:55 <dcoutts_> FunctorSalad: you need the cabal-install bash completion! :-)
07:34:16 <BONUS> hmm, if i have class Foo f where foo :: f a, the kind of f has to be * -> * right?
07:34:17 <dcoutts_> Myoma: if you're using latest darcs ghc-6.9 then there's no need to hack the Cabal sources.
07:34:21 <BONUS> or can it be * -> * -> *
07:34:28 <Myoma> what should I do then?
07:34:30 <BONUS> since it isnt stated anywhere how a is used
07:34:45 <FunctorSalad> matthew-_: but what about the writer, does it escape quotes?
07:34:52 <Myoma> Bonus: foo  (which should be Foo)is a value
07:34:57 <dcoutts_> Myoma: build latest darcs ghc-6.9, but use ghc-6.8.x as your starting compiler.
07:34:58 <Myoma> Bonus: so it must have kind *
07:35:01 <matthew-_> FunctorSalad: it just calls show
07:35:06 <dmwit> BONUS: It could be (* -> *) -> *, if a is (* -> *)...
07:35:07 <Myoma> dcoutts_: ok I'll try that ty
07:35:10 <matthew-_> well, depending on the attribute
07:35:12 <BONUS> ah
07:35:14 <matthew-_> is this Label?
07:35:20 <FunctorSalad> matthew-_: yes
07:35:20 <thatsright> oh cabal-install is nice!
07:35:25 <dmwit> BONUS: Basically, (f a) has to be :: *.
07:35:31 <matthew-_>     show (Label string) = "label=" ++ (show string)
07:35:43 <BONUS> aha, yeah, thats what i thought
07:35:44 <BONUS> thanks
07:35:44 <dcoutts_> Myoma: in general, dev versions of ghc cannot be built with arbitrary dev versions of ghc. It is only guaranteed to work using the last few major release versions.
07:36:21 <thatsright> was annoying that i had to download and compile haskell zlib
07:36:36 <dmwit> thatsright: Did you try bootstrap.sh?
07:36:54 <thatsright> dmwit: i was tempted
07:36:55 <dmwit> bootstrap.sh = cabal install cabal-install =)
07:37:19 <dcoutts_> dmwit: btw, you might like to check the bootstrap.sh in the darcs version, check that it looks ok to you. It doesn't use pushd any more.
07:37:23 <matthew-_> FunctorSalad: hmm. which is /could/ be right. It depends on whether dot magically interprets certain chars. Certainly quotes should be escaped correctly
07:37:33 <dmwit> dcoutts_: ?where darcs
07:38:28 <dmwit> http://darcs.haskell.org/cabal-install/ ?
07:38:29 <lambdabot> Title: Index of /cabal-install
07:38:38 <thatsright> putting that in the readme or an INSTALL file would of been helpful
07:38:46 <FunctorSalad> matthew-_: the dot doc says "any double-quoted string ("...") possibly containing escaped quotes (\");"
07:39:04 <dmwit> thatsright: It's in the first few lines of the script.
07:39:17 <matthew-_> FunctorSalad: in which case that should be fine. Let me know if you can repeat the bug and figure it out
07:39:18 <dmwit> thatsright: Although in principle I agree that it should be in the README. =)
07:39:53 <dcoutts_> dmwit: right, http://darcs.haskell.org/cabal-install/bootstrap.sh
07:40:01 <FunctorSalad> matthew-_: ok
07:40:18 <dmwit> dcoutts_: Okay, that one looks (at a glance) like it ought to work.  Thanks! dcoutts++
07:40:24 <dcoutts_> dmwit: and yeah, I should add a README
07:40:30 <dcoutts_> er INSTALL
07:41:00 <FunctorSalad> "cabal install cabal-install" actually does something :o
07:41:14 <dcoutts_> FunctorSalad: of course! :-) it's self-hosting
07:41:15 <FunctorSalad> what exactly is it?
07:41:43 <dcoutts_> FunctorSalad: "cabal install cabal-install" upgrades you to the latest version
07:41:49 <thatsright> even better i should add a debian package of zlib
07:42:13 <dcoutts_> thatsright: a debian package for zlib, HTTP and cabal-install would indeed be excellent.
07:42:14 <FunctorSalad> dcoutts_: I thought "cabal install cabal" did that already (or maybe "upgrade cabal")
07:42:38 <dcoutts_> FunctorSalad: the package "Cabal" is the library, the package "cabal-install" is the command line tool.
07:42:47 <FunctorSalad> I see
07:43:00 <Myoma> public LambdaBuilder FinishScope (Expression body) {
07:44:24 <quicksilver> BeelsebobWork: having been for a walk to buy some coffee I'd like to further clarify my comments.
07:44:49 <quicksilver> BeelsebobWork: SceneGraph - as in, a delcarative specification of what to render - is deifnitely a win.
07:44:55 <BeelsebobWork> yep
07:45:02 <quicksilver> BeelsebobWork: however, given the existance of existing render code
07:45:07 <quicksilver> BeelsebobWork: porting it over is not zero-cost
07:45:09 <BeelsebobWork> but not necessarily in the form of a big pile of constructors
07:45:13 <BeelsebobWork> oh, yeh, okay
07:45:19 <quicksilver> (that's all my zero-cost comment was intended to signify)
07:45:32 <quicksilver> also, in some cases, SceneGraph may be trivially embedded in AppState
07:45:35 <quicksilver> or even *be* AppState.
07:45:50 <quicksilver> generally not though.
07:46:04 <quicksilver> this is like what MVC people call model-view separation.
07:46:37 <BeelsebobWork> it does a lot actually
07:46:54 <quicksilver> BeelsebobWork: furthermore - and this is a totally orthogonal point - a generic SceneGraph which can be provided by a third party is hard to get right, because of conflicting implementation tradeoffs.
07:47:11 <quicksilver> so it may sometimes be more appropriate to have a bespoke SceneGraph for a particular program.
07:47:33 <BeelsebobWork> quicksilver: yeh, the "scene graph" I'm refering to is not necessarily what you think of as a traditional scene graph
07:47:49 <BeelsebobWork> I'm not talking about a big tree, with transformations, and objects and stuff  of this kind
07:47:59 <BeelsebobWork> but instead a nice compositional, functional description of the scene
07:48:10 <quicksilver> Yes, I understood it in the sense you intended.
07:48:25 <BeelsebobWork> k
07:48:29 <FunctorSalad> matthew-_: ok, here's the dot output that breaks the reparsing http://hpaste.org/10064
07:48:46 <FunctorSalad> matthew-_: it's no real problem for me though, didn't want these labels anyway :)
07:49:50 <matthew-_> FunctorSalad: interesting. I'll try debugging it later. Thanks for the report :)
07:50:04 <FunctorSalad> matthew-_: fwiw I replaced dot by fdp (possible option for the lib)
07:50:17 <matthew-_> definitely
07:50:19 <FunctorSalad> (it's one of the other graphviz tools)
07:50:29 <quicksilver> BeelsebobWork: Cairo contains such a beast, I believe.
07:50:36 <quicksilver> (implicitly if not explicitly, I don't recall)
07:50:47 <BeelsebobWork> possibly so
07:50:58 <dcoutts_> cairo has no scene graph
07:51:07 <dcoutts_> it's an immediate mode graphic lib
07:51:23 <dcoutts_> but one can lift the cairo operations into a scene graph
07:51:34 <dcoutts_> and the interpretation of that graph is a linear sequence of cairo calls
07:51:42 <dcoutts_> with a more or less 1:1 correspondence
07:51:44 <quicksilver> that's what I meant by implicit, I guess.
07:52:51 <dcoutts_> and whether that scene graph is introspectable or not depends on whether you use a deep or shallow encoding
07:53:40 <dcoutts_> the shallow encoding would be just newtype Picture = Picture (Render ())  or something like that
07:54:04 <ekidd> Here's a quick-and-dirty Hoogle command for the new "Ubiquity" plugin from Mozilla: http://www.randomhacks.net/articles/2008/09/01/ubiquitous-hoogle
07:54:08 <lambdabot> Title: Ubiquitous Hoogle
07:54:41 <dmwit> ekidd: Instant karma points on proggit. ;-)
07:55:11 <dmwit> You better submit it quick, or I will. =)
07:58:27 <ekidd> dmwit: I never self-submit to reddit. If you think it's interesting, feel free!
07:59:02 <dmwit> very clever
07:59:09 <seydar> what does it mean to have ![a]?
07:59:21 <dmwit> ! is a strictness annotation.
07:59:22 <matthew-_> FunctorSalad: it's the "\N" it doesn't like.
07:59:27 <mauke> it means to have [] or (:) _ _
07:59:48 <matthew-_> FunctorSalad: it wants "\\N" or just "N"
07:59:52 <seydar> dmwit: what's that mean?
07:59:56 <dmwit> seydar: If it's in a data declaration, it means that, as soon as that value's constructor is demanded, the list's constructor will also be demanded.
08:00:01 <dmwit> So, for example:
08:00:02 <matthew-_> it doesn't understand why N should be '\'-escaped
08:00:16 <dmwit> data Foo = Foo ![Char] | Bar Char
08:00:32 <quicksilver> ![a] is seldom helpful.
08:00:34 <dmwit> Now, if you pattern match on a value foo :: Foo,
08:00:42 <Myoma> what about [!Char] is that a syntax error
08:01:03 <dmwit> those that have the Foo constructor will also check whether the list is empty or not before matching.
08:01:17 <dmwit> (Which, as quicksilver says, isn't really that helpful most of the time.)
08:01:37 <seydar> dmwit: is it equivalent to just leave off the !?
08:01:41 <dmwit> no
08:01:49 <dmwit> If you leave off the !,
08:02:04 <dmwit> matching on a Foo constructor will not check the containing list for emptiness or not.
08:02:18 <dmwit> seydar: Are you familiar with WHNF?
08:02:23 <dmwit> weak-head normal form
08:02:29 <seydar> not at all
08:02:32 <dmwit> OK!
08:02:42 <FunctorSalad> matthew-_: hmm I didn't consciously add that "N"... I'll have to look :)
08:02:57 <dmwit> seydar: A value is in WHNF if it is a function or if you know what the outermost constructor is.
08:03:22 <seydar> is that as simple as it seems?
08:03:28 <dmwit> seydar: So, for example, (thunk) is not WHNF, but (\a -> thunk) is, as is (thunk : thunk).
08:03:35 <dmwit> seydar: That is as simple as it seems.
08:03:44 <dmwit> Now.
08:03:54 <matthew-_> FunctorSalad: actually, ignore that. I suck - I can't even read my own code
08:03:57 <dmwit> The (!) changes the meaning of WHNF slightly.
08:04:03 <matthew-_> I'll sort it and push a new version out tonight
08:04:18 <FliPPeh> Learning haskell after years of imperative programming is challenging :(
08:04:26 <dmwit> It says that to be in WHNF, it is not enough to know the outermost constructor.
08:04:38 <dmwit> You must also have the WHNF of all the ! members.
08:05:02 <dmwit> So, let's use "data Foo = Foo ![Char] Int".
08:05:10 <Myoma> bah .. Distribution/Compat/Exception.hs:31:35:
08:05:11 <Myoma>     Not in scope: data constructor `Exception.IOException'
08:05:27 <dmwit> (thunk) is not WHNF; and because of the !, neither is (Foo thunk thunk).
08:05:36 <Myoma> I don't understand how I can keept getting errors
08:05:40 <dmwit> But (Foo [] thunk) is OK, as is (Foo (thunk : thunk) thunk).
08:05:45 <dmwit> seydar: Are you with me?
08:05:53 <seydar> dmwit: yea
08:05:58 <seydar> yea!
08:06:15 <quicksilver> Myoma: you keep getting errors because you keep using bleeding edge versions of software as far as I can gather :)
08:06:42 <quicksilver> seydar: as a fairly minor point, a compiler may be able to find a more efficient representation in the ! case, perhaps ommitted a pointer.
08:06:48 <Myoma> somebody is writing this software -- why is works for them and not me
08:06:58 <quicksilver> Myoma: I think they're using different versions? :)
08:07:20 * Myoma doesn't really know about any of this but just wanted the cabal errors to go away
08:07:40 <FliPPeh> main = do
08:07:40 <FliPPeh>         let number = 5
08:07:40 <FliPPeh>         putStr "Square of " ++ (show number) ++ ":"
08:07:47 <FliPPeh> Gives me an error in the "let number" line
08:07:49 <FliPPeh> ;(
08:07:57 <FliPPeh> Couldn't match expected type `[a]' against inferred type `IO ()'
08:08:00 <mauke> FliPPeh: the error should be on the putStr line
08:08:02 <mauke> ... and it is!
08:08:12 <FliPPeh> Sorry, it is
08:08:14 <Myoma> You don't need brackets around (show number)
08:08:20 <mauke> you've written (puStr "Square of ") ++ (show number) ++ ":"
08:08:20 <FliPPeh> Ugh
08:08:31 <Myoma> you do need brackets around "Square of " ++ show number ++ ":"
08:08:35 <mauke> you want putStr ("Square of " ++ show number ++ ":")
08:08:54 <FliPPeh> Common beginner mistake, right?
08:08:55 <dmwit> or putStr $ "s" ++ show number ++ ":"
08:08:55 <seydar> dmwit: will an error be raised if its not in WHNF
08:09:07 <FliPPeh> I'm coming from a whole lot of imperative background
08:09:09 <dmwit> seydar: No, it will just be evaluated to WHNF.
08:09:10 <Myoma> seydar: It is evaluated into WHNF
08:09:19 <mauke> FliPPeh: yeah, many people need to relearn how to read expressions
08:09:41 <Myoma> there is no relearning, this is totally new
08:09:49 <mauke> FliPPeh: you need to realize that functions parse as unary operators, i.e. bind tighter than infix ops
08:10:13 <seydar> dmwit: ok, i lied. I dont get why the ! makes a difference
08:10:22 <FliPPeh> mhh okay
08:10:28 <Myoma> > let !x = 3 in x
08:10:33 <lambdabot>   3
08:10:36 <mauke> f x + g y parses as ((f x) + (g y))
08:10:37 <dmwit> seydar: Okay, here's the cool concept I gleaned from the STG paper:
08:10:43 <Myoma> > let (!x,y) = (3,undefined) in x
08:10:47 <lambdabot>   mueval: Prelude.read: no parse
08:10:49 <dmwit> seydar: There are two possible actions in Haskell: building a value, and tearing it down.
08:10:56 <mauke> putStr "x" ++ "y" parses as ((putStr "y") ++ "y")
08:11:05 <dmwit> To a first approximation, "let" builds a value, and "case" tears it down.
08:11:28 <dmwit> (It's complicated a bit by an implicit top-level let and where clauses, but ignore them for now.)
08:11:55 <dmwit> seydar: ! makes no difference in building a value, only in tearing it down.
08:12:22 <seydar> ah! and how does it make a difference there?
08:12:26 <lilac> > let !x = undefined in 3
08:12:27 <dmwit> And no evaluation ever happens when building a value.
08:12:30 <lambdabot>   mueval: Prelude.read: no parse
08:12:30 <lambdabot>  mueval: *** Exception: Prelude.undefined
08:12:31 <dmwit> Only when tearing it down.
08:12:50 <dmwit> So, when you're tearing it down, you first evaluate it to WHNF.
08:13:03 <dmwit> So ! can force more evaluation to happen during a tearing-down procedure.
08:13:07 <quicksilver> lilac: that's an extension though.
08:13:18 <quicksilver> lilac: and, unfortuantely, it blurs the helpful distinction that dmwit is making :)
08:13:33 <lilac> quicksilver: :) yes, i find it a confusing extension tbh
08:13:34 <seydar> dmwit: ooooooooooh! so it fights laziness?
08:13:39 <dmwit> right!
08:13:54 <mauke> let ¬°x! = undefined
08:13:59 <seydar> that should be called the personal trainer operator
08:15:17 <FliPPeh> I just noticed that Haskell supports unicode input files
08:15:22 <FliPPeh> Does it also support unicode output?
08:15:23 <BeelsebobWork> let ¬°‚Ä¢‚Äì! = undefined
08:15:37 <shapr> hiya Myoma
08:15:39 <shapr> hey BeelsebobWork
08:15:40 <mauke> FliPPeh: not directly, sort of, uh ...
08:15:48 <BeelsebobWork> FliPPeh: yes, if you use System.IO.UTF8
08:15:54 <ekidd> FliPPeh: http://hackage.haskell.org/packages/archive/utf8-string/0.3.1.1/doc/html/Data-String-UTF8.html
08:15:56 <lambdabot> Title: Data.String.UTF8, http://tinyurl.com/5me489
08:16:06 <mauke> FliPPeh: the current implementation of putStr and friends isn't unicode-friendly; you need another library
08:16:06 <Myoma> shapr: I got a venus fly trap :)
08:16:11 <BeelsebobWork> hey shapr, how goes it
08:16:15 <BeelsebobWork> Myoma: gief
08:16:15 <Myoma> (today)
08:16:20 <FunctorSalad> but the Chars themselves are utf-8, aren't they?
08:16:21 <BeelsebobWork> we need to get rid of a load of flies
08:16:42 <mauke> FunctorSalad: no, Chars are unicode
08:16:53 <shapr> Myoma: Cool! Have you fed it yet?
08:16:57 <shapr> BeelsebobWork: Code is good!
08:17:05 <BeelsebobWork> :)
08:17:06 <Myoma> I am just leaving it to fend for itsself
08:17:15 <Saizan> FunctorSalad: they are supposed to be unicode codepoints, but they can end up containing utf8 octects if you just use readFile on a utf8 file
08:17:23 <Saizan> s/can//
08:17:39 <mauke> yeah, because readFile effectively assumes latin-1
08:21:21 <Saizan> ok, noob question, what are the years in a Copyright (c) $year1-$year2 $name, supposed to be?
08:21:30 <quicksilver> 1977 and 2001.
08:21:50 <quicksilver> (the first year that part made significant, copyrightable, contributions, and the last)
08:22:01 <Igloo> Is there a portable way of saying "Does $filepath exist"?
08:22:16 <Igloo> I don't care if it's a file, directory, symlink, broken symlink, named pipe, etc
08:22:29 <Igloo> I just need to know whether or not it exists
08:22:30 <Deewiant> Igloo: in Haskell? doesFileExist || doesDirectoryExist is what I used
08:22:38 <Deewiant> it's slow, though
08:22:49 <BeelsebobWork> yeh, that's what I do too
08:22:56 <Igloo> I don't care about speed, but that thinks broken symlinks don't exist
08:23:03 <Deewiant> so I replaced it with an #ifdef'd version for win32 and linux
08:23:16 <mauke> find an lstat binding
08:23:22 <lilac> Igloo: why do you wnat to find out? (yes, it affects the answer ;-))
08:23:25 <Deewiant> Igloo: System.Posix.Files.fileExist?
08:23:31 <Deewiant> for windows:
08:23:31 <Deewiant> doesPathExist = flip withTString (fmap (/= 0xffffffff).c_GetFileAttributes)
08:23:48 <mauke> getSymbolicLinkStatus
08:24:13 <Igloo> lilac: I'm going to create an empty file there if it doesn't
08:24:17 <Igloo> and complain if it does
08:24:33 <Igloo> mauke: Not portable  :-(
08:24:34 <mauke> then checking first is pointless
08:24:43 <Deewiant> Igloo: what does fileExist report
08:24:45 <lilac> Igloo: checking first is asking for a race condition
08:24:49 <mauke> create file, complain if fail
08:24:59 <quicksilver> @remember AndrewCoppin Oleg cat sez: "see, yr type problum not so hard".
08:24:59 <lambdabot> I will remember.
08:25:00 <mauke> Igloo: well, symbolic links themselves are nonportable
08:25:02 <Igloo> I don't really care about race conditions
08:25:24 <Igloo> So how do I portably create the file in such a way that I'll get an exception if it exists?
08:25:35 <Igloo> openBinaryFile doesn't do it, certainly
08:25:45 <mauke> you can't
08:26:21 <quicksilver> check with doesFileExist
08:26:25 <quicksilver> and then openBinaryFile?
08:26:28 <quicksilver> (race condition though)
08:26:45 <Igloo> Deewiant: fileExist isn't portable
08:26:54 <Igloo> quicksilver: doesFileExist thinks broken symlinks don't exist
08:27:05 <Igloo> Maybe I should just stop caring about symlinks
08:27:20 <Deewiant> Igloo: I posted the Win32 alternative so you can #ifdef it
08:27:33 <mauke> openFd filename WriteOnly (Just 0o644) defaultFileFlags{ exclusive = True }
08:27:36 <Deewiant> Igloo: mostly I was just interested in whether fileExist would give the correct result in any case :-)
08:27:37 <Igloo> Deewiant: I really don't want to do that
08:27:37 <quicksilver> Igloo: yes, doesFileExist thinkgs broken symlnks don't exit
08:27:45 <quicksilver> Igloo: but then shouldn't it die on openBinaryFile?
08:28:02 <Igloo> (phone)
08:30:15 <lilac> Igloo: you can open the file and chec whether you're at EOF. that'll replace empty files silently (and write to non-existing/empty symlink targets i guess), but should otherwise work.
08:33:15 <quicksilver> Igloo: you should post a message to libraries@haskell demonstrating this ridiculous hole in the API, too :)
08:33:49 <dmhouse> Wasn't there a post a few days ago about how to detect broken symlinks?
08:34:00 <quicksilver> it was proably posix-only though?
08:34:13 <quicksilver> Igloo is specifically asking for a platform independent solution.
08:34:16 <quicksilver> not unresonable.
08:35:14 <dmhouse> Aren't symlinks basically POSIX-only anyway?
08:35:30 <quicksilver> yes, but other OSes may have similar things.
08:35:34 <quicksilver> or different things :)
08:35:40 <quicksilver> but things which get in the way of regular files.
08:35:46 <dmwit> Windows has .lnk files, which are basically a brain-dead version of symlinks.
08:35:56 <quicksilver> OSX has both symlinks and shortcuts.
08:35:59 <quicksilver> 'aliases'
08:36:05 <Cale> Don't NT and its children have some proper notion of links?
08:36:13 <Cale> Maybe that was hard links only.
08:36:17 * dmwit nods
08:36:32 <quicksilver> I maintain that Igloo's core need is a very rational need.
08:36:44 <quicksilver> A kind of 'NoClobber' option to openBinaryFile should cover it?
08:36:44 <dmwit> Cygwin helps, but outside of Cygwin, .lnk files are still totally unusable.
08:36:57 <mauke> I maintain that windows should just go away and die :-(
08:37:14 <quicksilver> NoClobber : always create a new file, give an exception in the case of existing file or a problem creating.
08:40:20 <Deewiant> quicksilver: still, a "doesPathExist" function should exist as well
08:40:31 <quicksilver> Deewiant: Yes.
08:46:52 * shapr boings
08:48:45 <Taejo> why can't GHC parse "{-# LANGUAGE: TypeSynonymInstances #-}"
08:48:52 <Myoma> :
08:49:15 <dmhouse> Taejo: get rid of the colon, is what Myoma means.
08:49:15 <Taejo> Myoma: wow I'm dumb :)
08:49:24 <Taejo> thanks Myoma, dmhouse
08:51:05 <FliPPeh> Bah
08:51:20 <FliPPeh> SciTE doesn't understand Hexadecimal literals
08:51:24 <FliPPeh> Doesn't highlight them properly
08:51:52 <Myoma> why should the editor understand it
08:52:14 <FliPPeh> To highlight it
08:52:14 <mauke> syntax coloring
08:52:21 <FliPPeh> It looks rather strange now =d
08:52:33 * dmhouse quietly suggests Emacs
08:52:42 <FliPPeh> 0x45 - 0 gets highlighted, rest doesn't
08:52:47 <FliPPeh> Oh nah
08:52:53 <FliPPeh> I just got such a nice syntax coloring
08:54:50 <dcoutts_> least fixed points ftw!
08:55:14 <mauke> what if I want a most fixed point?
08:55:18 * dcoutts_ goes back to writing his thesis with a slightly manic look on his face
08:55:26 <dcoutts_> mauke: oh you can have one, they're even more cool
08:55:37 <dcoutts_> and less known
08:55:53 <dmhouse> How would a greatest-fixed-point operator look in Haskell?
08:55:56 <dcoutts_> streams are just an encoding of the greatest fixed point
08:56:04 <dcoutts_> for types I mean
08:57:22 <Taejo> which of div and rem behaves like C's division?
08:57:26 <quicksilver> GFPs, co-induction, and BQOs for the win.
08:57:30 <dcoutts_> type List a = fix x. ListF a x  where data ListF a x = Empty | Cons a x
08:57:31 <Taejo> I mean, div and quot
08:57:53 <Myoma> none
08:58:16 <Taejo> Myoma: are you answering my question?
08:58:21 <dmhouse> dcoutts_: hmm, what does definedness look like on types? Is it essentially the subset relation with types viewed as sets?
08:58:46 <dcoutts_> dmhouse: I think the usual interpretation is with domains not sets.
08:59:07 <Igloo> quicksilver: Sadly not. openBinaryFile on a broken symlink creates the file that the symlink points to
08:59:20 <dmhouse> dcoutts_: "essentially" :)
08:59:23 <thatsright> when you 'cabal install' where do the source files go?
08:59:52 <dcoutts_> thatsright: the .tar.gz packages get downloaded to ~/.cabal/packages/$server/
08:59:58 <Cale> dmhouse: On types, I think least and greatest fixed point are usually interpreted (more or less) in terms of containment.
09:00:03 <dcoutts_> thatsright: no source files are 'installed'
09:00:59 <dcoutts_> Cale: and containment via injective functions right?
09:01:04 <Cale> yeah
09:01:33 * dcoutts_ is currently trying to explain and prove stream fusion
09:01:43 <thatsright> dcoutts: fair enough
09:01:52 <Cale> Well, monic -- not 100% sure that's the same thing as injective for domains, but I suspect it is :)
09:03:36 <FunctorSalad> isn't existence of a monic function way weaker than what I think of when I think "subtype"? it would include lots of coercions
09:03:59 <FunctorSalad> and all bijections that happen to exist between types
09:04:26 <quicksilver> Igloo: not nice.
09:04:35 <quicksilver> Igloo: what do you think of a NoClobber flag for openBinaryFile
09:04:40 <quicksilver> Igloo: to cover this sort of case?
09:05:03 * dmwit notes that this is exactly the behavior he would have expected... and wanted
09:05:34 <Cale> FunctorSalad: Well, yes, it's weaker than the usual sense of that term, I'll agree.
09:06:33 <FunctorSalad> Cale: to be honest I don't know the rigorous senses :)
09:12:02 <Cale> I suppose that it depends on the exact context that we're applying everything, but perhaps I can try to formalise this (and hope that my definitions agree with everyone else's :)
09:13:34 <Cale> We'll call a type T a fixed point of some functor F if there is a (specified) isomorphism T -> FT.
09:14:38 <dcoutts_> quicksilver: this behaviour with dangling symlinks is exactly the standard OS semantics, what is the problem?
09:15:02 <dcoutts_> quicksilver: don't you think it's reasonable that if you want to do something non-standard that you basically code it yourself
09:15:11 <quicksilver> dcoutts_: perhaps this particular example is not a problem.
09:15:18 <quicksilver> it is a security hole.
09:15:33 <quicksilver> sometimes you want to see "create a file HERE damnit, because that's what I want. If you can't do it, just tell me"
09:15:35 <dcoutts_> quicksilver: then it's not our fault! :-)
09:15:40 <Cale> Then we can form a category of fixed points of F and monic maps between them which respect the isomorphisms in the sense that the square involving the two isomorphisms, the map itself, and its functorial lift commutes.
09:16:01 <Cale> An initial object in that category would be a least fixed point, and a terminal object would be a greatest fixed point.
09:16:45 <dcoutts_> quicksilver: is that the postfix symlink bug?
09:17:04 <quicksilver> dcoutts_: it is in that general family. It is a well known kind of race condition.
09:17:17 <dcoutts_> quicksilver: http://lwn.net/Articles/294667/
09:17:20 <lambdabot> Title: Standards, the kernel, and Postfix [LWN.net]
09:17:27 <quicksilver> dcoutts_: it is the reason that secure programs create fresh subdirectories for their temporary files.
09:17:30 <quicksilver> like ssh.
09:17:34 <dcoutts_> aye
09:17:44 <quicksilver> OK, no, it's not that one.
09:17:50 <quicksilver> no hard links in involved here.
09:18:01 <quicksilver> however, it's a cousin. It's a bit more obvious/less obscure.
09:18:05 <dcoutts_> oh yes
09:18:49 <Cale> That is, a least fixed point of a functor F is a type T together with an isomorphism i :: T -> F T such that for any other type U and isomorphism j :: U -> F U, there is a unique monic map f :: T -> U such that j . f = fmap f . i
09:19:05 <Igloo> quicksilver: I think the API could be improved, certainly
09:20:02 <Cale> Does that seem sensible?
09:20:07 <dcoutts_> quicksilver: what I think is missing from the posix file api is the ability to create files with no name, and to make additional dir entries for open files given their fd.
09:20:28 <Cale> We could prove (quite easily) under those conditions that least fixed points are unique up to isomorphism.
09:20:40 <dcoutts_> quicksilver: eg, why do I need to make a file name for my temp file? I make a unique name and then delete the file while holding it open. That's silly.
09:21:50 <dcoutts_> quicksilver: similarly, when I want to replace an existing file I should be able to make a new file in the same dir and if/when I'm satisfied I should be able to linkfd() my open file over the target file name, and that'd be the first time that my file has any dir entry at all.
09:21:58 <Igloo> dcoutts_: You need to say where it should be created
09:22:02 <Saizan_> Cale: is that different/more general than saying that the least fixed point is the initial algebra?
09:22:03 <dcoutts_> Igloo: yes
09:22:18 <dcoutts_> Igloo: using an open fd for the directory
09:22:47 <Igloo> dcoutts_: For temporary files, I mean
09:22:59 <dcoutts_> Igloo: yes.
09:23:55 <dcoutts_> Igloo: like the new openat() function, which takes the fd of a dir
09:24:14 <Cale> Saizan_: hmm... it should be the same in the end, though I've actually imposed some extra conditions now that I look at it.
09:24:27 <quicksilver> dcoutts_: I agree 100%. I've thought exactly that before.
09:24:33 <dcoutts_> in fact if I could use openat() with a NULL file name and if there were a linkfd then that'd be enough
09:25:03 <Cale> Saizan_: I want an isomorphism T -> F T, whereas an F-algebra is just any morphism F T -> T
09:25:05 <quicksilver> dcoutts_: this is of course orthogonal to adding features to System.Directory (which is intended to be platform neutral) which behave sanely.
09:25:15 <dcoutts_> quicksilver: indeed
09:25:22 <quicksilver> doesFilePathExist :: FilePath -> IO Bool
09:25:44 <quicksilver> and a new 'onlyIfFilePathDoesNotExist' flag to the {open,read}*File functions.
09:25:50 <quicksilver> which I was calling NoClobber for short.
09:26:19 <dcoutts_> quicksilver: it's usually called exclusive isn't it?
09:26:37 <Cale> Saizan_: so I have something which is both an F-algebra and an F-coalgebra at the same time, and the two maps are inverses.
09:27:01 <Cale> Perhaps that's too much to ask for? I'm not sure.
09:27:27 <Cale> It seems to model what we do in Haskell reasonably well, I think.
09:28:27 <Saizan_> Cale: ah, i see, you're requiring both the constructor and the destructor, roughly speaking
09:28:27 <Cale> ah, okay, so usually people look at the initial F-algebra as the least fixed point, and the terminal F-coalgebra as the greatest one.
09:28:30 <Cale> yeah
09:29:08 <rwbarton> Cale: My logician friends tell me that under reasonable hypthoses, the F-algebra structure map of the terminal F-coalgebra is always an isomorphism.
09:30:05 * gwern uses rapidshare to download a FP paper. o.0
09:30:08 <dcoutts_> quicksilver: do you want O_NOFOLLOW for open() ?
09:30:10 <Cale> rwbarton: It seems very reasonable, at least for the sorts of things we usually do with types. :)
09:30:47 <Armored_Azrael> Hey, does anyone know how hard it would be to make, in template-haskell, a function
09:30:47 <Armored_Azrael> convert :: (a -> b) -> SomeRecordType a -> SomeRecordType b
09:30:47 <Armored_Azrael> where convert just recurses through everything in the structure, and converts everything which has the parameterized type to the other parameterized type?
09:31:27 <quicksilver> dcoutts_: To fix the security issue, yes.
09:31:27 <xsdnyd> hi
09:31:30 <Myoma> why would you do it in template haskell
09:31:31 <Armored_Azrael> (I assume template haskell is necessary as I don't think we have type variables for outer types there...)
09:31:39 <quicksilver> dcoutts_: I'm not sure exactly what igloo needed.
09:31:47 <Armored_Azrael> The idea is that I want it to work with arbitrary record types with arbitrary levels of recursion
09:31:52 <xsdnyd> how do i determine the current working directory? i mean where my haskell application was started... :)
09:32:05 <dcoutts_> @hoogle getCurrentDirectory
09:32:06 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
09:32:09 <Myoma> Have you seen typeclasses?
09:32:11 <Myoma> such as Eq
09:32:25 <Myoma> [Just (Left ())]
09:32:27 <Armored_Azrael> Myoma: Yes, I don't see how that would help
09:32:30 <gwern> Cale: what's with the TH imports you added to lb?
09:32:37 <Cale> Armored_Azrael: So you want something to write a Functor instance for you, you mean?
09:32:37 <quicksilver> dcoutts_: O_CREAT & O_EXCL might be enough in some cases.
09:32:39 <xsdnyd> dcoutts: thank you very much. exactly what i needed! :)
09:32:48 <rwbarton> Armored_Azrael: Sounds like you might want the Data.Derive.Functor module from derive (which uses TH)
09:32:48 <Myoma> can have an Eq instances, just because a=>[a] a=>Maybe a, a b => Either a b and () do
09:33:01 <dcoutts_> xsdnyd: you know about the hoogle website right ? haskell.org/hoogle
09:33:08 <Armored_Azrael> Cale: This may be what I mean, I'm not sure though as I haven't learned what a functor is yet. I suppose I should go look at it.
09:33:22 <quicksilver> dcoutts_: "If O_EXCL is set and the last component of the pathname is a symbolic link, open() will fail even if the symbolic link points to a non-existent name"
09:33:22 <Myoma> Functor is a typeclasse :)
09:33:24 <xsdnyd> dcoutts_: not until now. cool site
09:33:24 <dcoutts_> quicksilver: right, that's what is used for the openTempFile
09:33:30 <quicksilver> dcoutts_: I think O_EXCL might be enough.
09:33:36 <Cale> Armored_Azrael: class Functor f where fmap :: (a -> b) -> f a -> f b
09:34:06 <Cale> Armored_Azrael: You want this to satisfy the laws:  fmap id = id, and fmap (f . g) = fmap f . fmap g
09:34:06 <Armored_Azrael> Yeah, that's exactly what I'm looking for.
09:34:27 <dcoutts_> quicksilver: O_EXCL can only be used in addition to O_CREAT, it means nothing on its own
09:34:40 <dcoutts_> quicksilver: for opening an existing file you need O_NOFOLLOW
09:35:19 <quicksilver> dcoutts_: I specifically don't want an existing file though.
09:35:21 <quicksilver> in this case.
09:35:34 <dcoutts_> quicksilver: ah 'k, then just O_CREAT & O_EXCL as you say.
09:35:35 <Igloo> dcoutts_: I can do it with Posix, it's doing it portably that was the problem
09:35:37 <quicksilver> O_NOFOLLOW isn't in OSX so I assume it isn't POSIX.
09:35:58 <dcoutts_> quicksilver: right, it's in FreeBSD and Linux
09:36:12 <dcoutts_> Igloo: right. What is it you're trying to do?
09:36:38 <Igloo> dcoutts_: If this filepath exists, scream and shout. Otherwise, create an empty file there
09:37:21 <Igloo> I've just gone with doesFileExist || doesDirectoryExist in the end
09:37:35 <dcoutts_> Igloo: yes it is annoying actually. Eg I want to use something other than openBinaryTempFile for writeFileAtomic, because I want to use the ordinary file mask not the restricted one that openBinaryTempFile uses. But we cannot implement openBinaryTempFile using System.IO
09:37:36 <Igloo> i.e. ignoring race conditions and broken symlinks. And probably things like named pipes too
09:38:09 <dcoutts_> Igloo: make a proposal for extending the portable System.IO to allow exclusive create. All OSs can do it.
09:38:16 <SamB_XP> not really too smart to ignore all those things
09:38:33 <quicksilver> SamB_XP: yes, I think he recognises it's not smart.
09:38:41 <quicksilver> we don't have a portable solution though.
09:38:53 <SamB_XP> quite so
09:39:06 * Igloo isn't going to make a proposal right now, but I might at some point in the future if no-one else does
09:39:20 <SamB_XP> which makes this problem especially important ;-)
09:39:53 <Igloo> Looks like I can't check a file size without opening the file, either
09:40:18 <Cale> See... here is something which seems like it would be reasonably easy in Generic Haskell, but appears to be difficult using the library based approaches to generics... (at least, as far as I can see)
09:40:22 <dcoutts_> Igloo: perhaps we can roll in a few things. Like there's almost certainly a portable subset of stat. Something that tells us if a filepath is a file, a dir, something else, and if it's a file what its size and mod times are etc. Windows has this too.
09:40:36 <dcoutts_> Igloo: right, what you said. :-)
09:40:45 <SamB_XP> dcoutts: but race conditions
09:40:46 <Cale> Maybe it's actually still hard.
09:40:54 <Igloo> Right, it needs some thought, which is why I'm not going to do it right now  :-)
09:40:56 <dcoutts_> SamB_XP: what race conditions ?
09:41:03 <dcoutts_> Igloo: aye
09:41:07 <SamB_XP> between check and use?
09:41:09 <matthew-_> Igloo: I know this is the wrong way round, but if you use the mmap package then you can get the filesize out of that without having to open it - but I guess you are opening it under the bonnet
09:41:41 <Igloo> matthew-_: Opening it is rather less of an ordeal than using the mmap package to mmap it  :-)
09:41:53 <matthew-_> Igloo: oh quite.
09:41:59 <Saizan_> Cale: yeah, there's a thread in the generics mailing list about implementing fmap, and they found a lot of problems
09:42:12 <dcoutts_> SamB_XP: sure, I'm not sure what point you're making. All stat function have that problem if you use them before another operation on the file and assume it cannot have changed in the mean time.
09:42:45 <Cale> Saizan_: The first hard thing is not incurring any additional type constraints.
09:42:49 <matthew-_> dcoutts_: yeah but on posix, is there a single atomic "stat" function which would have to be emulated by several functions on windows?
09:43:19 <dcoutts_> matthew-_: that's my point, I think there is a windows function that gives a similar set of info
09:43:27 <matthew-_> ahh, I see.
09:43:46 <desp> Arg.
09:43:48 <quicksilver> It's not really the standard library's job to make stupid things impossible.
09:43:57 <quicksilver> although I agree it's nice to try to make the correct path the easy one.
09:44:01 <matthew-_> Igloo: in generaly, I'm slightly surprised that mmap isn't more widely used. I'm not convinced it shouldn't be in the base libraries.
09:44:20 <desp> It looks like adding support for single-quoted-strings to Parsec requires a lot of code duplication.
09:44:46 <desp> @src stringLiteral
09:44:46 <lambdabot> Source not found. Take a stress pill and think things over.
09:45:40 <matthew-_> esp given people's love of trying to make Haskell go faster - it's pretty low hanging fruit for file IO
09:45:41 <desp> http://haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Token.html#line-161
09:45:43 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/69xz5o
09:46:17 <desp> Because stringChar isn't exported.
09:46:53 <dcoutts_> matthew-_: one does have to be a bi careful with mmap, eg on 32bit systems there's the danger of running out of address space. Then you can also get bus errors if someone else truncates the file etc.
09:47:02 <dcoutts_> matthew-_: and for small files it's not faster.
09:47:33 <Igloo> dcoutts_: You would run out of address space if you read the file normally though, no?
09:47:48 <matthew-_> dcoutts_: well, if you want to talk about int sizes in system.io, look at the complete *expletive* mess of Int/Integer
09:47:49 <dcoutts_> Igloo: not if you did it incrementally
09:48:21 <Igloo> OK, yes
09:48:43 <Tobsan> is there a smart way to generate all numbers up to the square root of a number
09:49:11 <lilac> > let x = 42 in takeWhile (< x*x) [1..]
09:49:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:49:31 <Tobsan> yeah, i realized that myself :P
09:49:38 <lilac> > let x = 42 in takeWhile (\y -> x < y*y) [1..]
09:49:39 <Tobsan> thanks though
09:49:43 <lambdabot>   []
09:49:45 <Myoma> > [1..floor $ sqrt 10]
09:49:50 <lambdabot>   [1,2,3]
09:49:58 <dcoutts_> matthew-_: I don't think I see the problems. The uses of Int/Integer look fine to me.
09:49:59 <FliPPeh> > let testvar = 0x123
09:50:03 <lambdabot>   mueval: Prelude.read: no parse
09:50:04 <lilac> Tobsan: when you say "smart", what're you looking for?
09:50:09 <Myoma> @let
09:50:09 <matthew-_> dcoutts_: um, big file support?
09:50:12 <lambdabot>  Defined.
09:50:13 <Myoma> @let
09:50:16 <lambdabot>  Defined.
09:50:16 <Myoma> @let
09:50:19 <lambdabot>  Defined.
09:50:23 <Tobsan> lilac: something where i won't have to convert integrals to integers etc
09:50:25 <dcoutts_> matthew-_: Yes. It uses Integer for file sizes and Int for buffer sizes.
09:50:40 <matthew-_> dcoutts_: so internally, in a lot of code, I just tend to use Word64 for all of that stuff
09:50:55 <matthew-_> a buffer can be bigger than maxBound::Int though
09:50:56 <lilac> Tobsan: what type do you want your list in, and what type is your limit?
09:51:06 <Tobsan> lilac: Integer
09:51:19 <dcoutts_> matthew-_: It has to fit in memory.
09:51:26 <Tobsan> and well I work with Integer type so no real limit there
09:51:41 <matthew-_> dcoutts_: indeed
09:51:43 <dcoutts_> matthew-_: or do you mean that you want a >2GB buffer on a system with a 32bit address space?
09:51:46 <Tobsan> Myoma's solution looks good to me
09:51:47 <lilac> Tobsan: we were discussing computation of Integer square roots earlier today; you might want to check out the logs
09:51:54 <Tobsan> oh
09:51:54 <Tobsan> thanks
09:52:04 <dcoutts_> matthew-_: are you saying it should be Word rather than Int ?
09:52:18 <lilac> or you can do it the takeWhile way, but that's lots of multiplications...
09:52:19 <matthew-_> dcoutts_: my understanding was that Int was the same regardless of platform.
09:52:19 <Myoma> Tobsan: If I bothered to implement it, I would write [1..isqrt 10] instead
09:52:28 <dcoutts_> matthew-_: no, it follows the bit size.
09:52:31 <Tobsan> oh
09:52:39 <matthew-_> dcoutts_: is that in h98?
09:52:46 <dcoutts_> matthew-_: none if this is H98
09:53:09 <matthew-_> dcoutts_: Int is defined in h98
09:54:14 <dcoutts_> matthew-_: right I guess it's going by common implementation than H98 spec, there is a point to be argued there.
09:54:39 <matthew-_> I was completely unaware that Int changed depending on platform
09:54:49 <matthew-_> I always assumed 2^28-1 or whatever it is
09:54:49 <quicksilver> matthew-_: you never want a buffer bigger than 2GB.
09:54:53 <dcoutts_> matthew-_: but if we go by that impl then the code is fine.
09:55:04 <quicksilver> I hesitate to make a "640KB is enough for anyone" statement.
09:55:27 <quicksilver> but the point of buffers is to hold a reasonable amount of data to avoid bottlenecking, preferably combined with some flavour of asynchronous IO.
09:55:32 <matthew-_> I would prefer them to all be unsigned (apart from the relative seek) but that's a lesser point
09:55:46 <quicksilver> as such, the buffer only has to be 'big enough' for that case.
09:55:46 <dcoutts_> quicksilver: you might want a buffer bigger than 2GB, but then you'd also not be using a machine with just 4GB of address space
09:56:05 <dcoutts_> matthew-_: yes, really they should be Word not Int
09:56:09 <matthew-_> we have machines here with about 20GB of addressable storage
09:56:22 <quicksilver> matthew-_: no doubt. that doesn't mean you want more than 2G buffers though.
09:56:32 <quicksilver> that's just not what 'buffers' are for.
09:57:01 <quicksilver> the word/int thing is a classic strict typing/usability tradeoff.
09:57:20 <quicksilver> If we gave corret Word/Int signatures to everything you'd need a lot more explicit conversions around.
09:57:31 <dcoutts_> and in practise it's ok
09:57:40 <matthew-_> quicksilver: I've definitely had reason to load huge files into memory in the past
09:57:48 <matthew-_> sure, not in a contiguous malloc
09:57:55 <dcoutts_> nobody does want memory objects that large on machines with only 3GB usable address space
09:57:57 <matthew-_> but I don't see what's wrong with trying it
09:58:05 <quicksilver> that's no longer a buffer, is all I'm trying to say.
09:58:10 <matthew-_> ok
09:58:11 <quicksilver> that's a large in-memory object.
09:58:19 <quicksilver> buffers are for, well, buffering :)
09:58:37 <matthew-_> right, so I'm not understanding why the system.io api is only for buffering
09:58:38 <quicksilver> pedantry perhaps but I was trying to make a point with it.
09:59:10 <dcoutts_> matthew-_: the Int params there are for the hGet/Put functions mostly, which are offsets, lengths of file io buffers
09:59:59 <matthew-_> dcoutts_: ok, so the Int on hGet/Put thus seems at odds with the Integer on hFileSize
10:00:15 <matthew-_> and hSetFileSize
10:00:17 <dcoutts_> matthew-_: except that they're for different things
10:00:29 <dcoutts_> the Int size is for an in-memory object
10:00:35 <dcoutts_> and thus can fit in an Int
10:00:48 <dcoutts_> where as the Integer is the large on disk file
10:01:32 <dmwit> ?check ap (==) (read . show)
10:01:35 <lambdabot>   mueval: Time limit exceeded
10:03:16 <dcoutts_> matthew-_: the only potentially difficulty is wanting an in-memory object between 2-3GB on a 32bit machine. The usual max address space a process is allowed on most OSs on 32ibt is 3GB (though some restrict it to 2GB)
10:03:46 <matthew-_> dcoutts_: yep, ok, on second thoughts, I do agree
10:04:17 <quicksilver> dcoutts_: well actually there is a theoretical problem a bit smaller than that, since Ints are only guaranteed to be 28 bits.
10:04:26 <ToRA> dmwit: (ap (==) (read . show)) (0/0 :: Double)
10:04:28 <quicksilver> dcoutts_: perhaps that's no longer interesting though.
10:04:44 <Myoma> hey mmorrow
10:04:49 <mmorrow> Myoma: hey
10:04:55 <seydar> I have an issue with parsec. I need to achieve this: many1 instruction :: [Op Int]
10:05:05 <mmorrow> Myoma: any luck with the utf8?
10:05:09 <seydar> but it doesn't want to cast
10:05:21 <Myoma> mmorrow: I have a fix
10:05:28 <mmorrow> Myoma: awesome!
10:05:44 <kpreid> seydar: many1 x is an action, you need to run it as part of your parser
10:05:53 <quicksilver> seydar: because the type of 'many1 instruction' is Parser [Op Int]
10:05:57 <quicksilver> or something along those lines.
10:06:08 <Igloo> You know something's gone wrong with your standard library when you find yourself writing    case mySplitAt skip $ myLines content of
10:06:13 <quicksilver> seydar: you shouldn't need the annotation though, the type should be inferrable.
10:06:21 <quicksilver> :t many1
10:06:23 <lambdabot> Not in scope: `many1'
10:06:29 <Myoma> mmorrow: Neutron is very slick :)
10:06:52 <mmorrow> Myoma: thx
10:06:55 <seydar> quicksilver: thanks, this is what i had before: return ((many1 instruction) <|> [End])
10:06:55 <Myoma> mmorrow: I break the concurrency bit to thread some state through it
10:07:10 <kpreid> seydar: you want many1 instruction <|> return [End]
10:07:21 <Myoma> I don't have any pieces moving but I get a hit counter
10:07:23 <kpreid> return is for putting something in the monad, many1 already is
10:07:32 <seydar> quicksilver: can i do (\_ -> [End])?
10:07:39 <seydar> kpreid: thats what I have, but what do you mean?
10:07:41 <mmorrow> Myoma: heh. so you're writing the chess server/_?
10:07:44 <quicksilver> listen to kpreid ;)
10:07:45 <seydar> kpreid: gotcha
10:07:55 <Myoma> yes
10:08:03 <mmorrow> Myoma: cool.
10:09:04 <Myoma> http://hpaste.org/10065/1/plain
10:09:09 <Myoma> :)
10:09:20 <seydar> kpreid: yay! genius
10:09:27 <seydar> quicksilver: kpreid: thanks!!!
10:09:30 <Myoma> this is generated by unlines . concatMap type stuff
10:09:43 <mmorrow> Myoma: whoohoo, lookin good
10:11:07 <Myoma> I may use chessguys chess library
10:11:16 <Myoma> to get valid moves etc
10:11:29 * Myoma &
10:11:42 <mmorrow> nice, i didn't know he had a chess lib.
10:17:40 <shapr> @yow !
10:17:41 <lambdabot> Hmmm ... A hash-singer and a cross-eyed guy were SLEEPING on a deserted
10:17:41 <lambdabot> island, when ...
10:17:49 * shapr boings
10:23:41 <shapr> SHAZAM!
10:23:55 <shapr> Sure is quiet...
10:24:01 * Myoma reappears
10:24:03 <shapr> TADAH!
10:24:08 <Lycurgus> us holiday
10:24:24 <shapr> cjb: Hey, have you heard of the Willoughby & Baltic hackerspace?
10:27:11 <cjb> shapr: nope
10:36:34 <quicksilver> Beelsebob: so, when you suggest that FRP is ready for real use are you recommending the `Stepper` stuff?
10:36:53 <quicksilver> because I am not yet convinced about that. Maybe I don't understand it yet.
10:37:08 <Beelsebob> quicksilver: hmm? what do you mean by `Stepper` other than the implementation in reactive?
10:37:42 <quicksilver> nothing other than that.
10:38:04 <Beelsebob> so is the question you're asking "do you recommend the version of reactive that uses Steppers"?
10:38:08 <quicksilver> yes.
10:38:12 <quicksilver> that is exactly the question :)
10:38:21 <ekidd> @seen ndm
10:38:21 <lambdabot> I haven't seen ndm.
10:38:22 <Beelsebob> then yes
10:38:28 * quicksilver nods.
10:38:28 <Beelsebob> it's pretty hard to get into
10:38:36 <quicksilver> Then it behoves me to try again to understand it, I guess.
10:38:46 <Beelsebob> I don't think I fully understood what I was meant to do with it, until I'd read the source and wanted to reimplement it
10:38:47 <quicksilver> I really don't like interleaved IO lists
10:38:56 <quicksilver> but I shall try to cast aside my prejudice.
10:39:09 <Beelsebob> hehe, it'll be interesting what you think then
10:39:11 <Beelsebob> I love them
10:39:25 <quicksilver> I have a version of 'reactive.pdf' dated 2008/6/11.
10:39:29 <quicksilver> Is that the right one?
10:39:39 <Beelsebob> it sounds likely
10:41:56 <Beelsebob> I'd suggest that the paper is pretty hard to penetrate
10:42:06 <Beelsebob> I think it's probably about 3 papers in one
10:42:20 <quicksilver> Beelsebob: I find it remarkable that given your personal opinions on purity
10:42:22 <Beelsebob> I found I got it much more by skimming the paper, then reading chunks of source
10:42:34 <quicksilver> you're keen on an implementation which conceals IO inside apparently pure thunks
10:42:40 <quicksilver> which to me is the epitome if impurity :)
10:42:55 <Beelsebob> quicksilver: maybe I misinterpretted what you meant by "interleaved IO lists"
10:43:15 <quicksilver> things like that which is returned by hGetContents
10:43:50 <Beelsebob> yeh, that is what I thought
10:43:57 <Beelsebob> see, I see hGetContents as a very pure thing
10:44:18 <Beelsebob> it's only because of the implementation of the OS that hGetContents is impure
10:44:41 <Beelsebob> it is conceptually a completely pure function
10:44:58 <quicksilver> yes, that's true.
10:45:23 <quicksilver> however Event a is a much more delicate beast.
10:45:24 <roconnor> :i sequence
10:45:35 <roconnor> @src sequence
10:45:36 <lambdabot> sequence []     = return []
10:45:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:45:36 <lambdabot> --OR
10:45:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:45:37 <quicksilver> it obviously can't really exist in a pure sense because it contains information about the future.
10:45:57 <Beelsebob> quicksilver: sure it can -- that's like saying [1..] can't exist because it contains information about infinity
10:45:59 <roconnor> > sequence [[1,2],[3,4],[5,6]]
10:46:05 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:46:14 <quicksilver> Beelsebob: you don't know what key I'm going to press next.
10:46:29 <quicksilver> Beelsebob: so you don't know what the list "Event KeyCode" looks like.
10:46:32 <quicksilver> it's not computable
10:46:37 <quicksilver> (unlike [1..] which is)
10:46:42 <Beelsebob> quicksilver: sure it is -- it just may not terminate
10:47:01 <lilac> quicksilver: the key you're going to press next is clearly _|_
10:47:22 <Beelsebob> lilac: no, it's just a computation that takes exactly as long as it takes you to press a key
10:48:14 <lilac> Beelsebob: my hypothesis is true iff quicksilver never responds
10:48:15 <quicksilver> well it's only computable by 'waiting until the next key is pressed'
10:48:19 <lilac> darnit
10:48:27 <quicksilver> which is not the normal notation of computation.
10:48:28 <Beelsebob> lilac: yep
10:48:29 * shapr boing
10:48:40 <quicksilver> it's somethign that blocks until some real-world occurance occurs.
10:48:46 <quicksilver> this is not what 'pure' normally means.
10:48:48 <benny99> hm, I wonder what's the 'best implementation of skipWhite' -- skipWhite string -- eats a String and returns a string with all 'prefix-white-space' skipped -- example: skipWhite "   hi" - result: "hi"
10:48:54 <Beelsebob> quicksilver: no, but I think it's an entirely valid notion of computation, and I don't think there's anything impure about it
10:49:28 <mmorrow> > dropWhile isSpace "         hi"
10:49:28 <Myoma> benny99: I think it's:  dropWhile isWhite
10:49:33 <lambdabot>   "hi"
10:50:03 <benny99> works fine :)
10:50:18 <mmorrow> yeah, dropWhile (is<whatever-you-want> :: Char -> Bool) :: String -> String
10:50:21 <Myoma> > unwords . words $ "      hi"
10:50:26 <lambdabot>   "hi"
10:50:29 <mmorrow> heh
10:50:40 <quicksilver> Beelsebob: yes, it's a valid notion of cpmtuation, but it is what Moggi calls an effectful one.
10:50:42 <benny99> huh?
10:50:50 <newsham> "But Haskell's community is also growing and becoming more
10:50:50 <newsham> results-oriented.  If you want to blame someone for this, Don Stewart
10:50:51 <newsham> is probably your guy :)"
10:50:55 <newsham> :)
10:50:58 <newsham> ?karma+ dons
10:50:59 <lambdabot> dons's karma raised to 3.
10:51:17 <mmorrow> > unlines . filter (not . null) . lines $ "1\n2\n\n4"
10:51:22 <lambdabot>   "1\n2\n4\n"
10:51:31 <quicksilver> Beelsebob: and treating it as pure has horrendous consequences.
10:51:41 <Beelsebob> quicksilver: what like?
10:52:52 <mauke> dons++
10:53:09 <shapr> dons++
10:53:15 <shapr> For great authorship!
10:53:27 <mauke> preflex: karma dons
10:53:28 <preflex>  karma for dons: 18
10:53:37 <shapr> preflex: karma shapr
10:53:38 <preflex>  karma for shapr: 3
10:53:40 <newsham> take off every zig
10:53:43 <shapr> Well, better than nothing.
10:53:57 <mauke> shapr++  # we love you too
10:53:58 <Beelsebob> what dons do that was clever today?
10:53:59 <benny99> preflex: karma benny99
10:53:59 <preflex>  benny99 has no karma
10:54:00 * shapr grins
10:54:01 <lilac> > say "move zig"
10:54:02 <benny99> :/
10:54:02 <shapr> mauke: Thanks!
10:54:06 <lambdabot>   move zig
10:54:18 <Corun> *every sig
10:54:19 <Corun> *zig
10:54:58 <Cale> Hey! Haskell has always been results-oriented. It's just that the sort of results used to be more weighted toward the kind you would put in a paper. ;)
10:55:00 <eu-prleu-peupeu1> hello
10:55:11 <quicksilver> Beelsebob: suppose keypreesses :: Event KeyCode and mouseClicks :: Event (Int,Int)
10:55:12 <eu-prleu-peupeu1> where can i read about reactive functional programming ?
10:55:28 <shapr> Try Conal's site.
10:55:31 <Beelsebob> quicksilver: okay, sounds reasonable
10:55:33 <shapr> @where conal
10:55:33 <lambdabot> http://conal.net
10:55:45 <newsham> also conal.net/blog
10:55:46 <quicksilver> Beelsebob: the consider the value (keycodeToInt (head keypresses) + fst (head mouseClicks))
10:55:52 <shapr> eu-prleu-peupeu1: Conal does most of the recent FRP research I've heard about.
10:56:00 <eu-prleu-peupeu1> thanks shapr :D
10:56:28 <Beelsebob> quicksilver: I'm not following you now -- there's a well defined interface for getting at Events
10:56:30 <quicksilver> Beelsebob: isn't this vulnerable to deadlock depending which order the events arrive in?
10:56:35 <Beelsebob> and it doesn't let you just grab the first thing off them
10:56:42 <Beelsebob> and also, no it isn't
10:56:55 <Beelsebob> because of the unambiguous choice function
10:56:55 <lilac> > fst . flip breakSubstring (pack "\n-- \n")  -- take off every sig!
10:56:59 <lambdabot>   mueval: Prelude.read: no parse
10:57:58 <Beelsebob> > say "\x21"
10:58:04 <lambdabot>   !
10:58:18 <Beelsebob> > say "\x08> 5+6"
10:58:23 <lambdabot>   > 5+6
10:58:27 <Beelsebob> bah
10:58:29 <shapr> hej bringert!
10:58:40 <Cale> Beelsebob: foiled!
10:58:44 <Beelsebob> Cale: :D
10:58:44 * shapr hugs bringert 
10:58:45 <bringert> hej shapr
10:58:51 <shapr> How's married coding life?
10:59:08 <Cale> Beelsebob: Control characters are filtered out, and spaces are added to the beginning of every output line now.
10:59:25 <Beelsebob> Cale: yeh, I didn't know about the former
10:59:49 * Nafai just listened to SPJ on Software Engineering Radio
10:59:50 <Beelsebob> so I can't make lambdabot fire off everyone's terminal bell lots :(
10:59:53 <Nafai> Eloquent, as usual
11:00:08 <shapr> heh
11:00:51 <quicksilver> Beelsebob: Ah, OK. That was cheating. Evants are abstract.
11:00:57 <Beelsebob> quicksilver: yep
11:01:08 <bringert> shapr: not much coding in it
11:01:21 <Beelsebob> quicksilver: bear in mind that there's a couple of little gotchas about events that need to get ironed out -- but they're minor
11:01:26 <quicksilver> Beelsebob: I think my uneasiness derives from the fact that the Reactive code is not haskell.
11:01:35 <Beelsebob> e.g. associativity doesn't work in the Event monad when lots of events happen at the same time
11:01:36 <quicksilver> Beelsebob: it's GHC-RTS code (at least some of it is)
11:01:46 <Beelsebob> it is?
11:01:46 <quicksilver> but it attempts to give a pure haskell interface.
11:01:56 <Beelsebob> why is it GHC-RTS code?
11:01:56 <quicksilver> Beelsebob: yes, things like unamb require RTS primitives.
11:01:59 <Beelsebob> no
11:02:09 <quicksilver> unsafeInterleave, unsafePerformIO and so on.
11:02:12 <newsham> > say "\n> 1\n> 2"
11:02:17 <lambdabot>   > 1
11:02:17 <lambdabot>  > 2
11:02:28 <Beelsebob> oh, okay -- well, I think what conal would say is that unamb is a new language primative quicksilver
11:02:37 <lilac> @type unamb
11:02:39 <lambdabot> Not in scope: `unamb'
11:02:42 <Beelsebob> and calling it does no more IO than calling +
11:02:55 <Beelsebob> lilac: a -> a -> a
11:03:10 <Beelsebob> lilac: it takes two equal values, and returns a result as soon as one of them terminates
11:03:17 <mauke> :t let wide = map w where w c | inRange ('\x21' , '\x7e') c = chr (0xfee0 + ord c) | otherwise = c in wide
11:03:19 <lambdabot> [Char] -> [Char]
11:03:27 <mauke> @let wide = map w where w c | inRange ('\x21' , '\x7e') c = chr (0xfee0 + ord c) | otherwise = c
11:03:30 <lambdabot>  Defined.
11:03:44 <mauke> > say (wide "hello")
11:03:49 <lambdabot>   ÔΩàÔΩÖÔΩåÔΩåÔΩè
11:04:14 <lilac> Beelsebob: like a combination of some forkIOs, a takeMVar and an unsafePerformIO?
11:04:25 <Beelsebob> lilac: that's how it's implemented, yes
11:04:40 <ziman> > say . wide $ "!@#$%^"
11:04:45 <Beelsebob> although I think conal would like to make it just a language primative
11:04:45 <lambdabot>   ÔºÅÔº†ÔºÉÔºÑÔºÖÔºæ
11:04:51 <lilac> sounds useful, but not what i'd call referentially transparent
11:05:02 <Beelsebob> lilac: yeh, it should be called unsafeUnamb
11:05:08 <Myoma> > upsidown . wide $ "foooo"
11:05:08 <Beelsebob> luckily, reactive only calls it in safe places
11:05:12 <lambdabot>   mueval: Prelude.read: no parse
11:05:24 <mauke> > say . $ wide "oh god, I am so fat :-("
11:05:25 <ddarius> quicksilver: There are pure implementations as well.
11:05:28 <lambdabot>   mueval: Prelude.read: no parse
11:05:33 <mauke> what
11:05:38 <mauke> > say . wide $ "oh god, I am so fat :-("
11:05:44 <lambdabot>   ÔΩèÔΩà ÔΩáÔΩèÔΩÑÔºå Ôº© ÔΩÅÔΩç ÔΩìÔΩè ÔΩÜÔΩÅÔΩî ÔºöÔºçÔºà
11:05:48 <Myoma> preflex: wide
11:05:52 <Myoma> preflex: 8ball wide
11:05:53 <preflex>  outlook not so good
11:06:04 <dmhouse> What are all these functions?
11:06:10 <dmhouse> say, wide etc.
11:06:12 <dmhouse> ?index say
11:06:13 <lambdabot> bzzt
11:06:15 <dmhouse> ?src say
11:06:15 <lambdabot> Source not found. My mind is going. I can feel it.
11:06:44 <Myoma> @@ @run say . wide . map toLower @show @yow
11:06:48 <Myoma> @@ @run say . wide . map toLower $ @show @yow
11:06:49 <lambdabot>   Couldn't match expected type `a -> [Char]'
11:06:53 <lambdabot>   ÔΩâ ÔΩàÔΩÅÔΩñÔΩÖ ÔΩîÔΩàÔΩÖ ÔΩêÔΩèÔΩóÔΩÖÔΩí ÔΩîÔΩè ÔΩàÔΩÅÔΩåÔΩî ÔΩêÔΩíÔΩèÔΩÑ...
11:07:08 <Myoma> @@ @run say . wide . map toLower $ @show @nixon
11:07:14 <lambdabot>   ÔΩÑÔΩè ÔΩôÔΩèÔΩï ÔΩãÔΩéÔΩèÔΩó ÔΩóÔΩàÔΩÅÔΩî ÔΩàÔΩÅÔΩêÔΩêÔΩÖÔΩéÔΩÖÔΩÑ ÔΩîÔΩè ...
11:07:20 <Myoma> >:|
11:07:49 <newsham> ?help wide
11:07:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:07:55 <Myoma> @wide
11:07:55 <lambdabot> Maybe you meant: bid dice id time wiki
11:08:02 <newsham> > wide "test"
11:08:07 <lambdabot>   "\65364\65349\65363\65364"
11:08:16 <newsham> ahh
11:08:18 <Myoma> @@ @run say . wide . map toLower $ @show @yow
11:08:21 <shapr> [Head|Rest]: haha
11:08:24 <mauke> why toLower?
11:08:25 <lambdabot>   ÔΩâÔºáÔΩç ÔΩÅ ÔΩéÔΩïÔΩÉÔΩåÔΩÖÔΩÅÔΩí ÔΩìÔΩïÔΩÇÔΩçÔΩÅÔΩíÔΩâÔΩéÔΩÖ ÔΩïÔΩéÔΩÑÔΩ...
11:08:38 <newsham> maybe the def of wide assumes lower letters?
11:08:40 <[Head|Rest]> =^_^=
11:08:52 <mauke> > say . wide $ "WHAT!"
11:08:58 <dmhouse> What is this nonsense?
11:08:58 <lambdabot>   Ôº∑Ôº®Ôº°Ôº¥ÔºÅ
11:09:01 <Myoma> [Head|Rest]: Why aren't you in prolog ? :p
11:09:04 <newsham> wide = lambda x : unichr(ord(x) -0x20 + 0xff00)
11:09:10 <shapr> He's relaxing... being a headrest.
11:09:23 <Myoma> o
11:09:27 * shapr hugs Myoma
11:09:31 <[Head|Rest]> i dont know :(
11:09:32 * shapr codes furiously
11:09:35 * Myoma is going to try sleeping again
11:09:49 <Myoma> it seems to be possible every few days. ...
11:10:33 <shapr> Myoma: I've found that one hour of exercise before 6pm means I can sleep every night.
11:12:19 <jinjing> @type wide
11:12:21 <lambdabot> [Char] -> [Char]
11:12:55 <jinjing> > say $ wide
11:12:59 <lambdabot>   Couldn't match expected type `[Char]'
11:13:20 <jinjing> > say $ wide "ÂÆΩ"
11:13:25 <lambdabot>   ÂÆΩ
11:13:45 <jinjing> > say "ÂÆΩ"
11:13:50 <lambdabot>   ÂÆΩ
11:13:56 <dmhouse> > say "/part"
11:14:02 <lambdabot>   /part
11:14:28 <shapr> maybe ^H/part ?
11:14:34 <dmhouse> It won't work anyway.
11:14:43 <dmhouse> IRC clients interpret "/part", not the servers.
11:14:46 <shapr> ah
11:14:50 <dmhouse> (I think.)
11:15:17 <shapr> Hey does anyone else have problems with Takusen 0.8.3 when trying to do "cabal list|grep foo" ?
11:15:27 <Nafai> What's Takusen?
11:15:35 <[Head|Rest]> > say "^H/part"
11:15:40 <lambdabot>   ^H/part
11:15:58 <dmhouse> > say "/part"
11:16:03 <lambdabot>       lexical error in string/character literal at character '\b'
11:16:15 <trofi> > say "\n"
11:16:19 <lambdabot>  Terminated
11:16:32 <shapr> Nafai: Do you have cabal installed? If so, does 'cabal update && cabal list|grep agick' give you an error?
11:16:37 <[Head|Rest]> > say "halt()"
11:16:42 <lambdabot>   halt()
11:17:42 <shapr> Perhaps I should flush my cabal package list
11:17:54 <Nafai> shapr: I don't have it installed just yet on this new machine
11:18:05 <shapr> Ok, anyone else have cabal installed and can try that?
11:19:07 <shapr> I get this error: cabal: Couldn't read cabal file "./Takusen/0.8.3/Takusen.cabal"
11:19:15 <dmhouse> shapr: do I need Takusen installed as well?
11:19:19 <shapr> no
11:19:30 <dmhouse>  * foo
11:19:30 <dmhouse>       Homepage: http://sourceforge.net/projects/fooengine/?abmode=1
11:19:42 <dmhouse> (On cabal list | grep foo)
11:19:45 <shapr> I tried deleting the reference from the tar and tar.gz index files, but it didn't work for me.
11:19:53 <shapr> dmhouse: No takusen error?
11:20:36 <mmorrow> > say "‡∑¥"
11:20:41 <lambdabot>   ‡∑¥
11:20:42 <mauke> :t let flip'=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235" in flip'
11:20:44 <lambdabot> [Char] -> [Char]
11:20:51 <mmorrow> the craziest unicode char i'v seen yet
11:20:56 * shapr couldn't see it
11:20:57 <mmorrow> mauke: awesome.
11:20:59 <mauke> @let flip'=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235"
11:21:02 <lambdabot>  Defined.
11:21:14 <mmorrow> > flip' "hello????????"
11:21:19 <lambdabot>   "))))))))ollp\387"
11:21:26 <mauke> crap
11:21:32 <mmorrow> heh
11:21:35 <mauke> > say . flip' $ "I fail!"
11:21:38 <dmhouse> shapr: is that command fetching from hackage?
11:21:40 <lambdabot>   }l…•9«ù …•
11:21:44 <mmorrow> > say (flip' "hello????????")
11:21:45 <mauke> off by one somewhere
11:21:49 <lambdabot>   ))))))))ollp∆É
11:22:02 <mmorrow> mauke: love those fencepost errors
11:22:16 <shapr> dmhouse: Nah, 'cabal update' gets the latest list, and list just reads all the cabal files.
11:22:19 <dmhouse>  ?src should work with ?let'd commands.
11:22:29 <dcoutts_> shapr: works for me. What does cabal --version tell you about the version of Cabal and cabal-install ?
11:22:36 <mauke> is there a way to selectively @unlet definitions? :-/
11:22:49 <shapr> dcoutts_: unrecognized option! yow!
11:22:50 <mmorrow> what's the difference (if anything) between ?let and @let?
11:22:59 <mauke> mmorrow: none, both ? and @ are command triggers
11:23:07 <mmorrow> ah, cool
11:23:11 <dcoutts_> shapr: that means it's very very old and it's time you got the latest version.
11:23:38 <dcoutts_> shapr: the latest version has absolutely enormous improvements compared to the version you're running.
11:23:54 <mauke> :t let flip'=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="6abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235" in say $ flip' "abcxyz what"
11:23:55 <dcoutts_> so big I wouldn't know where to start explaining
11:23:56 <lambdabot> Expr
11:24:02 <mauke> > let flip'=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="6abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235" in say $ flip' "abcxyz what"
11:24:08 <lambdabot>    á…ê…• ç z éx…îq…ê
11:24:54 <mauke> @let flap=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="6abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235"
11:24:57 <lambdabot>  Defined.
11:25:16 <Zao> @let spam="the above"
11:25:21 <lambdabot>  Defined.
11:26:00 <mmorrow> mauke: sweet.
11:26:19 <mmorrow> shapr: that char was "\3572"
11:26:28 <mmorrow> > utf8s "\3572"
11:26:34 <lambdabot>   "\224\183\180"
11:26:35 <mauke> U+0DF4 (e0 b7 b4): SINHALA PUNCTUATION KUNDDALIYA [‡∑¥]
11:26:59 <mauke> > say $ flap "now we can talk upside down."
11:27:05 <lambdabot>   .u çop «ùpƒ±sdn  ûl…ê á u…ê…î «ù ç  çou
11:27:26 <mauke> ... or not
11:27:40 <mmorrow> > say . flap $ "..... or snot"
11:27:45 <lambdabot>    áous …πo .....
11:27:50 <mauke> the dots are wrong :-(
11:27:59 <quicksilver> Beelsebob: thank you this has been a very helpful conversation.
11:28:10 <dmhouse> Unicode is massively funky.
11:28:12 <quicksilver> Beelsebob: my worst mistake was not thinking of Events as abstract.
11:28:23 <sclv> @remember mauke let flap=map(ap fromMaybe(`lookup`t).toLower).reverse where t=zip k v++zip v k;k="6abcdefghijkmnrtvwy[({?!'<_;\x203f\x2045\x2234";v="9\x250q\x254p\x1dd\x25f\x183\x265\x131\x27e\x29e\x26fu\x279\x287\x28c\x28d\x28e\x2d9])}\xbf\xa1,>\x203e\x61b\x2040\x2046\x2235"
11:28:23 <lambdabot> Done.
11:28:27 <quicksilver> Beelsebob: I think I understand quite a bit better now.
11:28:38 <mauke> I should have tested the thing first :/
11:28:40 <quicksilver> Beelsebob: shame it's such a pain to implement ;)
11:28:43 <Beelsebob> quicksilver: no probs -- come poke me if you need more -- although conal knows a *lot* more than me about it
11:28:55 <ddarius> Beelsebob: Hopefully...
11:29:16 <quicksilver> Beelsebob: I've had conversations with conal before, but not many since the latest iteration.
11:29:40 <quicksilver> ddarius: pure implementation of unamb?
11:29:50 <quicksilver> ddarius: not qithout an extra RTS construct, surely?
11:30:04 <ddarius> Pure implementation of Reactive
11:30:10 <sclv> > say . flap $ "This is an exclamation or a question!"
11:30:15 <lambdabot>   ¬øuoƒ± ás«ùnb …ê …πo uoƒ± á…ê…Ø…êl…îx«ù u…ê sƒ± sƒ±…• á
11:30:25 <Beelsebob> ddarius: reactive *is* pure
11:30:27 <mmorrow> haha
11:30:39 <mmorrow> ! -> ? on the flipside
11:30:42 <Beelsebob> or at least, the latest version
11:30:46 <quicksilver> unamb adds non-determinism so it can't be part of a "traditional" pur language semantics.
11:30:50 <Beelsebob> where unamb is seperated into it's own package
11:30:59 <Beelsebob> quicksilver: unamb is no longer part of reactive
11:31:04 <Beelsebob> because it's useful for far more things
11:31:07 <chrisdone> mmorrow: is flap your magnificent creation?
11:31:18 <Beelsebob> e.g. implementing (&&) with correct lazy semantics
11:31:21 <quicksilver> I was talking to ddarius. I had thought he was claiming a pure implementation of unamb.
11:31:23 <ddarius> Beelsebob: And the Future based version of Reactive uses it no?
11:31:32 <mmorrow> chrisdone: :)
11:31:37 <mmorrow> @let upsidown = let flipTab = zip "abcdefghijklmnopqrstuvwxyz.[]{}<>?!'_;" "\592p\596q\477\607\387\613\305\638\670l\623uobd\633s\647n\652\653x\654z\729][}{><\191\161,\8254\1563" in say . reverse . map (\c -> maybe c id (lookup c flipTab))
11:31:39 <lambdabot>  Defined.
11:31:41 <quicksilver> Beelsebob: correct, in some sense, but adding non-determinism.
11:31:43 <quicksilver> which is a pretty big semantic leap.
11:31:47 <Beelsebob> ddarius: not very future at all
11:31:58 <mauke> mmorrow: fromMaybe
11:32:02 <mmorrow> > upsidown "qwertyuiop!!!!????"
11:32:03 <Beelsebob> quicksilver: there's no exposed non-determanism though
11:32:07 <lambdabot>   ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩbo
11:32:14 <mmorrow> uh, crap
11:32:22 <ddarius> Beelsebob: I'm saying there is an implementation that doesn't use unamb or unsafePerformIO at all.
11:32:24 <quicksilver> Beelsebob: yes there is? given (1 `unamb` 2) you don't know what the result will be.
11:32:31 <mmorrow> > upsidown "q"
11:32:36 <lambdabot>   d
11:32:39 <mmorrow> > upsidown "q?????//"
11:32:44 <lambdabot>   //ÔøΩÔøΩÔøΩÔøΩÔøΩd
11:32:46 <mmorrow> > upsidown "q??"
11:32:47 <Beelsebob> ddarius: yep, but as far as we can see, there's no way to do it efficiently
11:32:50 <chrisdone> > (length "fromMaybe", length "flip maybe id")
11:32:50 <hansfbaier> anyone knows why runhaskell Setup.lhs configure doesnt find locally installed packages, whereas cabal configure does?
11:32:52 <lambdabot>   ÔøΩÔøΩd
11:32:54 <lambdabot>   (9,13)
11:32:58 <Beelsebob> quicksilver: oh, sorry, I thought you meant that (&&) was non-determanistic
11:32:59 <ddarius> Beelsebob: I didn't say anything about efficiency.
11:33:04 <Beelsebob> ddarius: sure
11:33:14 <Beelsebob> then there deffinately are implementations that don't use unamb
11:33:21 <dcoutts_> hansfbaier: the old default was --global, while for cabal-install we made the default --user
11:33:24 <mmorrow> hmm, that's odd, i'm not sure what's happenning
11:33:37 <quicksilver> Beelsebob: no. Just that adding unamb to the language radically changes it mathematically.
11:33:40 <dcoutts_> hansfbaier: so if you're using runghc Setup configure then add --user explicitly.
11:33:57 <quicksilver> FSOV radical.
11:34:02 <benny99> > let testbla x = if x == "" then [] else x
11:34:04 <Beelsebob> quicksilver: let me get back to you on that, but I'm inclined to agree atm
11:34:05 <lambdabot>  Terminated
11:34:09 <benny99> > testbla ""
11:34:10 <mauke> mmorrow: I think I broke 'say'
11:34:12 <lambdabot>   mueval: Prelude.read: no parse
11:34:15 <mauke> sorry
11:34:25 <quicksilver> Beelsebob: I'm re-reading hte paper but I don't see how Events are created, except for trivial ones.
11:34:28 <benny99> what happened to labmdabot :( ?
11:34:29 <mmorrow> make: hehe
11:34:37 <hansfbaier> dcoutts: Thanks!
11:34:43 <quicksilver> Beelsebob: suppose I am the GUI library author. How do I build my 'keypresses :: Event KeyCode' ?
11:34:50 <mmorrow> > fix ((0:) . scanl (+) 1)
11:34:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:34:58 <Saizan_> benny99: you've to use @let to define things, as always
11:35:08 <Beelsebob> quicksilver: yeh, this is one of the slighly incomplete things -- luke palmer is making some "legacy adapters" -- i.e. things to hook reactive up to the legacy way of interacting with the world
11:35:11 <benny99> > @let testbla x = if x == "" then [] else x
11:35:14 <lambdabot>   mueval: Prelude.read: no parse
11:35:19 <benny99> > testbla ""
11:35:22 <lambdabot>   mueval: Prelude.read: no parse
11:35:27 <mmorrow> ... in testbla
11:35:27 <Saizan_> benny99: without >
11:35:35 <mmorrow> err, ignore what i said
11:35:38 <Saizan_> however use let .. in
11:35:39 <mmorrow> wrong
11:35:40 <benny99> lambdabot:  @let testbla x = if x == "" then [] else x
11:35:41 <quicksilver> Beelsebob: ah, so in an ideal world all events would already be Events
11:35:42 <lambdabot>  Defined.
11:35:45 <mauke> > flap "abc.[x]"
11:35:47 <quicksilver> Beelsebob: I see, yes., that's consistent.
11:35:48 <Beelsebob> quicksilver: exactly
11:35:49 <lambdabot>   "[x]\729\596q\592"
11:35:52 <quicksilver> Beelsebob: then you'd just combine them.
11:35:56 <benny99> > testbla ""
11:35:58 <mmorrow> Saizan_: (i meant i was wrong earlier, not you were wrong...)
11:36:00 <Beelsebob> yep, exactly
11:36:00 <lambdabot>   ""
11:36:04 <benny99> why :'( ?
11:36:21 <RayNbow> > showHex 255 ""
11:36:24 <lambdabot>   mueval: Prelude.read: no parse
11:36:30 <mmorrow> > utf8s (flap "abc.[x]")
11:36:33 <lambdabot>   mueval: Prelude.read: no parse
11:36:35 <benny99> > if "" == "" then 1 else 2
11:36:39 <lambdabot>   1
11:36:45 <trofi> > show "–ø—Ä–∏–≤–µ—Ç!"
11:36:49 <Saizan_> > "" == []
11:36:51 <lambdabot>   "\"\\1087\\1088\\1080\\1074\\1077\\1090!\""
11:36:54 <lambdabot>  Terminated
11:37:04 <mauke> mmorrow: utf8 and utf8s are gone
11:37:20 <mmorrow> oh, i gotcha
11:37:29 <benny99> guess my code is not that good anyway, but why does 'x == ""' not evaluate to True in testbla ?
11:37:44 <rwbarton_> benny99: it does.  But also [] is the same as ""
11:37:54 <Saizan_> > "" == []
11:38:00 <lambdabot>   True
11:38:01 <rwbarton_> > [] :: String
11:38:05 <lambdabot>   ""
11:38:31 <trofi> :t show
11:38:32 <lambdabot> forall a. (Show a) => a -> String
11:38:40 <trofi> :t say
11:38:42 <lambdabot> String -> Expr
11:38:53 <trofi> > say "—É—Ö"
11:38:56 <mauke> why do I not have @let utf8 in my scrollback?
11:38:58 <lambdabot>   mueval: Prelude.read: no parse
11:38:58 <lambdabot>  mueval: Enum.toEnum{Word8}: tag (1091) is o...
11:39:02 * shapr builds cabal 1.5.4
11:39:11 <benny99> > 'a' : ' ' : []
11:39:16 <lambdabot>   "a "
11:39:20 <benny99> ok
11:39:22 <dcoutts_> shapr: I'd suggest using the released versions
11:39:27 <shapr> oh?
11:39:32 <shapr> Which version?
11:39:39 <dcoutts_> shapr: get the latest cabal-install from hackage and use the bootstrap.sh
11:39:47 <shapr> ok
11:39:54 <benny99> thanks :)
11:40:09 <trofi> > say $ map toUpper "hi"
11:40:14 <lambdabot>  Terminated
11:40:16 <dcoutts_> shapr: unless you want to help test the darcs version in which case feel free to use the darcs version of both and report new bugs to me
11:42:01 <mmorrow> mauke: ok redefined
11:42:12 <mauke> > say "a‚Ç¨"
11:42:17 <lambdabot>   a
11:42:31 <mauke> > utf8s "a‚Ç¨"
11:42:35 <lambdabot>   "a\226\130\172"
11:42:46 <mauke> the problem is, to fix 'say' we have to remove all definitions again :-/
11:43:21 <mauke>  lambdabot: @bot
11:44:24 <Xenoblitz> hi to all
11:44:24 <Xenoblitz> newbie here :)
11:44:24 <Xenoblitz> anyone?
11:44:30 <shapr> I'm a newbie too!
11:44:41 <Nafai> Me too!
11:44:42 <mauke> > say . utf8s . flap $ "I'm a newbie too!"
11:44:46 <shapr> dcoutts_: I'll try the darcs version
11:44:47 <lambdabot>   ¬°oo á «ùƒ±q ç«ùu …ê …Ø,ƒ±
11:44:49 <shapr> seems to work so far
11:45:11 <trofi> :t utf8s
11:45:11 <dcoutts_> shapr: great
11:45:13 <lambdabot> [Char] -> [Char]
11:45:22 <trofi> > utf8s "!
11:45:25 <trofi> > utf8s "!"
11:45:26 <lambdabot>       lexical error in string/character literal at character '\n'
11:45:28 <lambdabot>  Terminated
11:45:32 <jsnx> how did lambdabot get a that upside down d?
11:45:39 <dmhouse> jsnx: mauke magic
11:45:47 <mauke> huhu
11:45:51 <Xenoblitz> is there anyone who may help me with some monad stuff?
11:45:52 <Saizan_> maybe we should have a #play-with-lb-and-unicode channel..
11:45:57 <mauke> dmhouse: it's called 'p'
11:45:59 <shapr> hm, error parsing config file..
11:46:03 <jsnx> Xenoblitz: we don't know about that stuff
11:46:16 <jsnx> Xenoblitz: we just all use python for that
11:46:17 <dmhouse> mauke: it's "magic".
11:46:24 <Saizan_> Xenoblitz: sure, feel free to ask any haskell related question here
11:46:36 <Xenoblitz> thanks :)
11:46:41 <dmhouse> mauke: grr, bash.org is down, and there's a perfect quote for this situaiton
11:47:11 <Saizan_> @paste
11:47:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:47:18 <Saizan_> if you need to show code ^^^
11:47:36 <Xenoblitz> Saizan_ thanks man give me a sec to show you :)
11:47:57 <chrisdone> lojbot: coi -- if you need to express your question more concisely
11:47:58 <lojbot> coi
11:48:13 <shapr> Hm, can anyone else install hsmagick?
11:49:16 <Xenoblitz> Saizan_: ok so i just do @paste and paste my code afterwards? sorry guys i am not used to mirc much
11:49:26 <mmorrow> mauke: if say messed up?
11:49:29 <mmorrow> s/if/is/
11:49:45 <mauke> it's currently defined as fun x :: Expr
11:49:45 <Saizan_> Xenoblitz: you go to  http://hpaste.org/new and submit it there
11:49:55 <benny99> may I paste some code and you tell me, what's bad about it :-[ ?
11:49:56 <Saizan_> Xenoblitz: then you paste the url of the page you get here
11:50:06 <Xenoblitz> Saizan_ thanks :)
11:50:06 <dmhouse> benny99: sure!
11:50:40 <mauke> heh, "mirc"
11:51:16 <benny99> dmhouse: great, thanks :)
11:52:32 <benny99> http://hpaste.org/10067 -- what's bad?
11:52:33 <quicksilver> Beelsebob: Yes. I think conal started me on the wrong foot with type Event a = [(T,a)]
11:52:55 <quicksilver> Beelsebob: I appreciate that's intended to be a semantics, but I took it too literally as a haskell implementation.
11:53:01 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&calc=calculate&xfullcpu=1&xmem=0&xloc=0&binarytrees=1&chameneosredux=1&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&meteor=0&nbody=1&pidigits=1&regexdna=1&revcomp=1&spectralnorm=1&threadring=1 nice
11:53:02 <Beelsebob> quicksilver: yeh, it makes you think you can get at it like a list
11:53:03 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel¬Æ Q6600¬Æ quad-core Computer Langua ..., http://tinyurl.com/6xt5rr
11:53:05 <Beelsebob> which you really can't
11:53:08 <quicksilver> Beelsebob: really 'Event a' is something 'as opaque as' IO a.
11:53:12 <benny99> I don't like the 'skipped == ""' and stripPrefix stuff :(
11:53:14 <Beelsebob> dons: genious!
11:53:22 <Beelsebob> dons++
11:53:23 <quicksilver> Beelsebob: it's a similar qualitative idea as IO a, it's just a better model.
11:53:35 <Beelsebob> quicksilver: exactly, yeh
11:53:39 <bringert> dons: wow!
11:53:40 <benny99> wow @ benchmarks :)
11:55:04 <quicksilver> Beelsebob: so the 'adapter question' a.k.a. how shall I create Event a's for all the stuff in my existing libraries
11:55:04 <Beelsebob> dons: so that was the gain from improving just one benchmark, yes?
11:55:09 <quicksilver> is not discussed in the paper.
11:55:25 <Beelsebob> quicksilver: no, that's much more recent - like, in the past 3 weeks
11:55:30 <Xenoblitz> Saizan_: http://hpaste.org/10068
11:55:33 <Beelsebob> you're best asking luqui about that quicksilver
11:55:35 <quicksilver> Beelsebob: is a good download of reactive available?
11:55:41 <rwbarton_> wait, the quad-core benchmark measures CPU time?
11:55:49 <Beelsebob> quicksilver: the darcs on code.haskell.org is up to date
11:56:12 <rwbarton_> or is it really wall-clock time?
11:56:37 <dons> Beelsebob: just adding the chameneos benchmark to the mix.
11:56:53 <Beelsebob> dons: ah, okay -- I thought you'd parallelised something that hadn't been before
11:56:58 <dons> Beelsebob: see here, http://www.eigenclass.org/hiki/shootout-elo-ratings , particular benchmarks with very wide divergence between languages have a big effect.
11:57:06 <lambdabot> Title: eigenclass - Elo ratings for the Benchmarks Game (aka Great Computer Language Sh ...
11:57:12 <dons> and the thread benchmarks ghc is killing everyone on, on x86_64
11:57:28 <dons> Beelsebob: so no, we haven't added any parallel benchmarks yet, amazingly.
11:57:39 <Xenoblitz> Saizan_: I didn't post all the code... but it should be enough to get an idea of what is wrong...
11:57:41 <Saizan_> Xenoblitz: you've some misunderstanding on the State monad, something of type State Well () doesn't return the new Well, but a () (which is a token for when you don't care about the result, basically)
11:57:51 <Beelsebob> dons: so it's likely to actually get much faster still?
11:58:00 <benny99> Saizan_: talking to me :-[ ?
11:58:05 <dons> yeah, certainly. we're not using the cores.
11:58:10 <Beelsebob> awesome :)
11:58:12 <Beelsebob> go go dons
11:58:12 <benny99> Saizan_: nope, sorry
11:58:25 <Xenoblitz> Saizan_: i know ... i don't want it to return anything... but change the state to a new well... that's why i did the ()
11:58:44 <rwbarton_> oh, it's only the one-language page that doesn't show elapsed time
11:58:47 <Xenoblitz> i know i should add return () at the end... but that's extra right?
11:59:07 <Saizan_> Xenoblitz: ok, so why are you doing put newW? newW is of type () there
11:59:16 <benny99> dmhouse: I pasted my 'code' at http://hpaste.org/10067 btw.
11:59:53 <mmorrow> Beelsebob: this shocked me yesterday: http://hpaste.org/10060
12:00:20 <Xenoblitz> Saizan_: yeah i might not have understood the state monad well...
12:00:38 <Xenoblitz> Saizan_: i am trying to put the new Well as the new State
12:00:38 <mmorrow> 13s -> 2s with a small `par` annotation
12:00:47 <Xenoblitz> Saizan_: is there anyway to do that?
12:00:57 <Saizan_> simply using setBlockAtXY x y newB...
12:01:05 <Saizan_> will do that
12:01:24 <Xenoblitz> that's a bit weird for me coming from OOP :S
12:01:36 <benny99> Xenoblitz: you are not alone :p
12:01:45 <Xenoblitz> when must put be used?
12:01:49 <Xenoblitz> benny99: hehe :)
12:01:52 <rwbarton_> benny99: yeah, the stripPrefix is kind of weird.  You could use span rather than takeWhile...
12:02:03 <rwbarton_> benny99: ... but for this particular purpose you can just use the Prelude function 'words'
12:02:22 <rwbarton_> benny99: (Well, 'words' doesn't do exactly the same thing)
12:02:25 <Beelsebob> dons: it's a little bit of a shame that we're still so much worse for memory usage, but then ghc doesnt optimise for RAM at all
12:02:43 <Xenoblitz> Saizan_: i know that put puts ((),newState) but... when is it right to use it?
12:03:01 <benny99> rwbarton_: thanks :)
12:03:26 <Saizan_> Xenoblitz: put must be used when you want to put something in the state, but the inner call of setBlockAtXY share the same call as toggleBlockAtXY, so the put is already performed
12:04:07 <Xenoblitz> Saizan_: ouch... Haskell is cooler than i thought :P
12:04:25 <Xenoblitz> Saizan_: thanks a million! I hope that they become clearer with time!
12:04:27 <benny99> rwbarton_: guess using words is smarter :/
12:04:38 <mmorrow> > let fib1 = (get >>= \(m,n) -> put (n,m+n) >> return m) in runState (replicateM 10 fib1) (0,1)
12:04:43 <lambdabot>   ([0,1,1,2,3,5,8,13,21,34],(55,89))
12:04:47 <Saizan_> Xenoblitz: it's the same as if you copy/pasted the definition of setBlockAtXY inside toggleBlockAtXY, modulo lexical scope of variables
12:05:24 <Saizan_> Xenoblitz: did you look at the definition of the State monad? it's instructive
12:05:31 <mmorrow> > let fib1 = (get >>= \(m,n) -> put (n,m+n) >> return m) in runState fib1 (0,1)
12:05:32 <dons> it's weird, why did so many programs (in other languages...) break when moving to the 64 bt quad core,
12:05:35 <dons>  http://shootout.alioth.debian.org/u64q/benchmark.php?test=chameneosredux&lang=all
12:05:36 <lambdabot>   (0,(1,1))
12:05:37 <lambdabot> Title: chameneos-redux benchmark | x64 Ubuntu : Intel¬Æ Q6600¬Æ quad-core Computer Lang ..., http://tinyurl.com/6zcher
12:05:55 <Xenoblitz> Saizan_: so technically speaking... if i just copy the code its the same effect... yes I did Saizan_ but getting used to types and what not is a new concept for me
12:06:31 <Cale> mmorrow: How do the programs compare with -N1? Are they about the same then, or is there something funny going on with the par/pseq helping GHC to produce better code?
12:06:35 <Xenoblitz> Saizan_: its more the fact that you have to unlearn what you are used to... i mean for me what you showed me is a bit strange
12:07:49 <Xenoblitz> Saizan_: so it works this way... because setBlockAtXY x y newB has the same return as toggleBlockAtXY
12:07:51 <dons> Cale, we're not using `par` yet.
12:07:59 <Saizan_> yeah, the effects are composed like that, you build bigger State computations from simpler ones, but there's a unique "location" that gets modified by all of them
12:08:00 <mmorrow> Cale: i'll check. it has to be different code probably
12:08:21 <Cale> It seems kind of ridiculous to get more than 2x speedup :)
12:08:31 <Cale> So there's got to be something funny going on :)
12:08:37 <quicksilver> Beelsebob: Reactive is a special case of Behaviour, just for implemenation reasons?
12:08:48 <rwbarton_> mmorrow, Cale: the two threads traverse the list in parallel, so at least the peak memory usage is better
12:08:56 <Cale> (I don't have GHC 6.9, but on 6.8, there's little difference between them on a uniprocessor)
12:08:59 <rwbarton_> I don't know whether that accounts for the speedup though
12:09:01 <Xenoblitz> Saizan_: I can never thank you enough!
12:09:20 <dons> oh, on the 64 bit quad core they increased the values for N a lot as well.
12:10:05 <Xenoblitz> Saizan_: one last question... so in essence you have to have one put for such a composition to make sense ... composition might not be the correct word here...
12:10:24 <Cale> Xenoblitz: I might be a bit late on this, but you understand that  u <- return x  in the middle of a do-block is always the same as  let u = x  ?
12:10:55 <Cale> (apart from obscure issues about let allowing for more polymorphism)
12:11:21 <Xenoblitz> Saizan_: one last question... so in essence you have to have one put for such a composition to make sense... composition might not be the correct word here...
12:11:32 <Xenoblitz> Cale: yeah i saw that in examples... and i was wondering if there is a difference
12:11:44 <Xenoblitz> Cale: why and how it works like that is still a bit of mystery to me
12:12:01 <Xenoblitz> Cale: at this point i am hoping experience teaches me why and how... unless someone enlightens me :P
12:13:02 <Cale> okay, well... it's basically one of the monad laws (things that are supposed to be true in order to have a proper monad), that 'return' is a function which takes a value, and gives you an action that 'does nothing' but return that value.
12:13:42 <Cale> In what sense do we mean 'does nothing'? Well,  do v <- return x; f v  is always supposed to be the same as  f x
12:14:03 <Xenoblitz> Cale: oh wait... if i am not mistaken i read it... sort of... encapsulates it to make it monadic
12:14:10 <Cale> and  do v <- m; return v  is supposed to be the same as m
12:14:22 <dmhouse> Xenoblitz: right. return x defines a trivial monadic action which does no side effects, and yields x.
12:15:32 <newsham> anyone familiar with HaXml?  is there any function for taking a Document and getting at its Element?
12:15:45 <newsham> the example in RWH uses pattern matching to do it.
12:15:53 <BONUS> does it make sense for all functors to be applicative functors as well?
12:15:55 <jsnx> it is too bad that exhuastive pattern guards are not exhaustive from the compiler's point of view
12:16:00 <Cale> Yeah... for example in the IO monad, you can think of values of type  (IO t)  as simply descriptions of some stuff to do in order to produce a value of type t. In that case,  return v  is the description which says "don't do anything, just produce the value v every time"
12:16:17 <Cale> BONUS: They shouldn't be.
12:16:29 <Cale> BONUS: There ought to be some functors which are not applicative...
12:16:33 <dmhouse> BONUS: no, since you need extra structure for Applicative.
12:16:35 <BONUS> whats an example of a functor that makes sense as a normal functor but not an applicative one
12:16:44 <BONUS> yeah but i dont mean like a subclass
12:16:47 <BONUS> just generally
12:16:49 <dmwit> ?src Applicative
12:16:49 <lambdabot> class Functor f => Applicative f where
12:16:49 <lambdabot>     pure  :: a -> f a
12:16:49 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:16:57 <rwbarton_> BONUS: Also, there are some functors that have several reasonable Applicative structures
12:16:57 <dmwit> BONUS: Array
12:17:08 <BONUS> hmm, array
12:17:12 <dmhouse> dmwit: why?
12:17:12 <BONUS> interesitng
12:17:20 <dmwit> dmhouse: There's no pure.
12:17:25 <dmhouse> dmwit: why not?
12:17:33 <dmhouse> Static bounds thing?
12:17:48 <dmwit> dmhouse: Yep, you need two values that are Ix instances to make an Array.
12:17:57 <BONUS> ah...
12:18:01 <Xenoblitz> Saizan_, Cale, dmhouse: guys thanks alot... I will save this chat for future reference and hopefully to undersand it better later on :)
12:18:03 <BONUS> man i love #haskell
12:18:11 <dmhouse> Right, so because you don't know the size of the array in advance, you can't create a singleton array.
12:18:44 <Cale> hmm...
12:18:59 <dmwit> There's problems with (<*>), too, I think.
12:19:00 <rwbarton_> another example is (,) a for some random type a
12:19:34 <Cale> There are problems with fmap for Arrays even. (If you're talking about instances of Ix being a problem:)
12:19:36 <rwbarton_> Applicative ((,) a) <==> Monoid a, I believe
12:19:36 <dmwit> rwbarton_: Huh.  What's wrong with that?
12:19:54 <Cale> But I think Array is mostly okay.
12:19:57 <ddarius> dmwit: Pure doesn't work (unless you stick in undefined.)
12:20:05 <dmwit> Cale: fmap should be fine
12:20:07 <Cale> rwbarton's example is more fundamental
12:20:19 <Cale> dmwit: It's not, because you need to ensure that i is an instance of Ix.
12:20:32 <dmwit> :t fmap
12:20:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:20:40 <Cale> dmwit: Though I guess you could write instances for fixed index types.
12:20:46 <dmwit> Cale: fmap :: (a -> b) -> Array i a -> Array i b -- not a problem?
12:20:54 <dmwit> :t Array.map
12:20:56 <lambdabot> Not in scope: `Array.map'
12:21:03 <dmhouse> :t Data.Array.map
12:21:04 <Cale> :t Array.amap
12:21:05 <lambdabot> Not in scope: `Data.Array.map'
12:21:06 <lambdabot> Not in scope: `Array.amap'
12:21:09 <Cale> :t Data.Array.amap
12:21:09 <dmhouse> :t Data.Array.amap
12:21:10 <rwbarton_> > fmap toUpper (listArray ('a', 'c') ['x', 'y', 'z'])
12:21:10 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:21:11 <lambdabot> Not in scope: `Data.Array.amap'
12:21:11 <lambdabot> Not in scope: `Data.Array.amap'
12:21:16 <Cale> :t Data.IArray.amap
12:21:18 <lambdabot> Couldn't find qualified module.
12:21:25 <Cale> :t Data.Array.IArray.amap
12:21:27 <lambdabot> forall e' e (a :: * -> * -> *) i. (Ix i, Data.Array.Base.IArray a e, Data.Array.Base.IArray a e') => (e' -> e) -> a i e' -> a i e
12:21:27 <sjanssen> Cale: the array length is cached as an Int, so fmap can be written
12:21:39 <mmorrow> Cale: ok, here's a dir with a README giving new timings, plus the asm of each, and a diff of the two asm files http://code.haskell.org/~morrow/mean/
12:21:39 <lambdabot> Title: Index of /~morrow/mean
12:21:44 <sjanssen> (you have to break into Data.Array.Unsafe to write it, though)
12:21:53 <rwbarton_> > listArray
12:21:53 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:21:57 <sjanssen> data Array i e = GHC.Arr.Array !i !i !Int (GHC.Prim.Array# e)
12:22:12 <rwbarton_> listArray is really unsafe?
12:22:24 <sjanssen> > "Array"
12:22:25 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:22:34 <sjanssen> gwern: booo!
12:22:42 <Cale> wtf?
12:22:47 <dmhouse> sjanssen: I suspect "STArray" is, though.
12:22:49 <sjanssen> this unsafe crap is really stupid
12:23:03 <Cale> The fact that you can't do any IO is really safe enough :)
12:23:04 <sjanssen> dmhouse: STArray is prefectly safe
12:23:07 <mauke> > "unsafe"
12:23:07 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:23:17 <dmhouse> ?ask gwern why listArray is considered unsafe
12:23:18 <lambdabot> Consider it noted.
12:23:20 <dmwit> > "blargle"
12:23:25 <lambdabot>   "blargle"
12:23:47 <sjanssen> @. eval eval "uns" ++ "afe"
12:23:54 <Cale> Heh, too bad that won't rearrange your sentence when it asks him :)
12:24:05 <mauke> @. run run "uns" ++ "afe"
12:24:09 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:24:40 <rwbarton_> > fmap toUpper (array ('a', 'c') $ zip "abc" "xyz")
12:24:45 <lambdabot>   array ('a','c') [('a','X'),('b','Y'),('c','Z')]
12:25:40 <mmorrow> Cale: i'm amazed it's that much faster
12:25:58 <Beelsebob> quicksilver: reactive is the general case of a behavior
12:26:10 <Beelsebob> Behavior = Reactive :. Improving Fun
12:26:14 <Beelsebob> IIRC
12:26:51 <dmhouse> Hehe, that reads great!
12:26:57 <dmhouse> "Reactive: Improving Fun"
12:27:03 <Beelsebob> hehe
12:27:08 <dmhouse> (Shame about the period.)
12:27:13 <Beelsebob> that's an awesome tag line actually
12:28:04 <Cale> mmorrow: I am too.
12:28:10 <Beelsebob> oh, no, I'm wrong
12:28:12 <Beelsebob> type Behavior = R.Reactive :. Fun TimeT
12:28:16 <Beelsebob> lame
12:28:25 <Beelsebob> TimeT is the bit that does the improving
12:28:50 <dmwit> reactive fun-time!
12:28:54 <Beelsebob> hehe
12:29:37 <Cale> mmorrow: What I really wanted to see is how mean.hs performs on a single processor.
12:29:47 <Cale> mmorrow: (i.e. with the parallel annotations left in)
12:29:55 <Beelsebob> Cale: got a mac?
12:30:00 <Cale> Beelsebob: no
12:30:03 <Beelsebob> ah, lame
12:30:08 <mmorrow> Cale: ahhh, ok. i'll do that.
12:30:12 <Beelsebob> chud can disable (n-1) CPUs
12:30:18 <dons> Beelsebob: do you havee a dual core?
12:30:22 <Beelsebob> dons: yes
12:30:23 <Cale> Beelsebob: There would be no need for that.
12:30:34 <Beelsebob> and a quad core at work
12:30:37 <dons> i'd like people with more time than I to have a go at parallel strategising binary-trees
12:30:45 <Cale> Beelsebob: You have to run the program with +RTS -N2 to get two processors in use anyway.
12:30:49 <dons> i think its a good candidate (quad core traversals)
12:31:19 <Beelsebob> dons: I'd be willing to have a go -- I tried earlier and managed something like a 1% speedup
12:31:28 <Beelsebob> but I hadn't read anything about the strategies module at that point
12:31:33 <Beelsebob> that was just by sticking `par` in
12:31:41 <dons> ah
12:31:48 <dons> yeah, you need to be careful with strictness
12:31:52 <dons> and the depth of `par`
12:31:54 <Beelsebob> yep
12:32:06 <Beelsebob> I think I managed to get it to go "yep, it's a tree" in paralel
12:32:06 <dons> we're doing worse on the quad core than we normally do
12:32:07 <Beelsebob> and no more
12:32:07 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=all
12:32:09 <lambdabot> Title: binary-trees benchmark | x64 Ubuntu : Intel¬Æ Q6600¬Æ quad-core Computer Languag ..., http://tinyurl.com/69l8ag
12:32:25 <dons> so anyone else want to have a go? sjanssen ?
12:32:41 <mmorrow> Cale: heh. slightly worse than mean0. http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=29#a31
12:33:23 <Cale> mmorrow: interesting
12:33:51 <Cale> That is very unintuitive.
12:34:13 <Cale> dons: Can you think of a reason why there would be superlinear speedup going from 1 to 2 cores?
12:35:13 <mmorrow> yeah, it's most definitely superlinear
12:35:30 <mmorrow> (in this particular program's case)
12:36:20 <dons> Cale, superlinear? only if say, search terminates early or something.
12:36:34 <mmorrow> wrt time
12:36:35 <Cale> dons: It's computing the mean of a list.
12:36:37 <dons> or maybe the GC can be more effective
12:36:46 <mmorrow> ah, maybe that
12:36:52 <mmorrow> but it's a foldl
12:36:54 <mmorrow> '
12:37:07 <Cale> dons: On one core (with -threaded) it takes around 8-9 seconds, whereas on two it's taking 1-2 seconds.
12:37:08 <mmorrow> well i guess the list.. (?)
12:37:21 <dons> hmm
12:37:33 <mmorrow> and in a prog w/out par annotations and not compiled with threaded it's about 7s
12:37:39 <dons> that's really good
12:37:45 <mmorrow> dons: http://code.haskell.org/~morrow/mean/
12:37:46 <lambdabot> Title: Index of /~morrow/mean
12:38:01 <mmorrow> there's a diff of the asm of each in there
12:38:13 <mmorrow> (and HsColourized asm :)))
12:38:15 <dons> oh, but isn't that just the sum and the length?
12:38:22 <dons> i.e. (sum xs / length xs)?
12:38:27 <dons> which is a retainer with one thread
12:38:34 <dons> but with two threads, becomes a constant space function
12:38:44 <EvilTerran> that's nifty
12:39:04 <EvilTerran> and a lot tidier than making it a single traversal in one thread
12:39:20 <dons> it's really the classic example of how extra threads can change things dramatically. the strategy here squashes a retainer, and makes the idiomatic version efficient
12:39:33 <EvilTerran> (unless you use an attribute grammar, but then there's another step in the compilation process involved to do so)
12:39:39 <dons> mmorrow: you could just use 'sum' for foldl' (+) 0 xs
12:39:43 <mmorrow> dons: ah, i see. so it's not so much that the gc is more efficient in the -threaded cases, but that it doesn't have to do much, whereas in the single threaded case it has to churn away?
12:40:01 <dons> well, it doesn't have to retain the entire list in the -N2 case
12:40:04 <mmorrow> dons: it would do the optimization for me (w/ -O2)?
12:40:09 <Cale> It's too bad that the single threaded compilation version can't take advantage of the parallelism annotation.
12:40:22 <dons> you've got two threads chasing along xs
12:40:25 <EvilTerran> mmorrow, in the sum/length case, the GC can't do *anything* until the first traversal has happened, that's the problem
12:40:34 <dons> simultaneously dropping the heads, so the GC chases behind, cleaing up
12:40:41 <mmorrow> EvilTerran: ahhh. i see,
12:40:52 <dons> on its own that a very interesting blog post :)
12:41:04 <dons> just talking about how strategies can change the space complexity
12:41:07 <EvilTerran> mmorrow, while, if evaluation keeps switching between traversing xs for sum, and traversing it for length, the GC can pick up the prefix of the list that both threads are done with already
12:41:09 <dons> in a lazy language, anyway.
12:41:19 <dons> threads + laziness == less space leaks :)
12:41:32 <mmorrow> hmm
12:41:40 <quicksilver> well, except there is no way for the RTS to exert the pressure needed to keep that balanced
12:41:43 <quicksilver> (is there?)
12:41:51 <quicksilver> you've just got to hope both threads move along at the same speed.
12:41:59 <Cale> I wonder if there's a sensible way to use the fact that the program's been annotated for parallelism to get better code even on one processor.
12:42:45 <bjrn> Can I tell the ghc profiler to ignore certain modules when using -auto-all? I get the following error: http://hpaste.org/10069 but since I'm not really interested in profiling that part of the program I'd like to exclude that module
12:43:00 <mmorrow> Cale: it seems like that'd reduce to having to transform  sum x / length x into a single-pass version (which i think is hard?)
12:43:36 <EvilTerran> Cale, well, i guess you could theoretically have a system which switched threads repeatedly even on a single processor
12:45:02 <mmorrow> that'd be one way to xform it into a single pass version i suppose
12:45:03 <Cale> EvilTerran: yeah...
12:45:24 <EvilTerran> it's a rather roundabout solution to the space leak, mind
12:45:35 <EvilTerran> deliciously arcane
12:45:49 <Cale> Currently, it seems that running it with -N2 on a uniprocessor just makes it take much longer :)
12:47:08 <sjanssen> quicksilver: I think the threads will naturally keep pace with each other
12:47:26 <sjanssen> quicksilver: notice that the thread that is ahead has to allocate each cell of the list
12:49:23 <benny99> hm... what's is "StdGen" ? (http://www.haskell.org/all_about_monads/html/statemonad.html)
12:49:29 <lambdabot> Title: The State monad
12:49:41 <mauke> a random number generator
12:50:34 <mmorrow> @type randoms
12:50:36 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
12:51:01 <mmorrow> > randoms (mkStdGen 424242) :: [Int]
12:51:06 <lambdabot>   [3486148939327370149,4328819905853371541,4701723600260585502,88860605917747...
12:51:17 <mauke> @index CReal
12:51:17 <lambdabot> bzzt
12:51:21 <mauke> @where CReal
12:51:21 <lambdabot> I know nothing about creal.
12:51:34 <mmorrow> > randomRs ('a','m') (mkStdGen 424242) :: [Char]
12:51:39 <lambdabot>   "lmihkkiiigcjkcakamggakehbfihmbkaldechdfabjmhbfdjeidlfegldhaefjdifgacicfemc...
12:51:41 <trofi> Numeric
12:51:42 <benny99> ah, ok, thanks :)
12:51:43 <Cale> mauke: It's in the numbers package on Hackage.
12:51:52 <mmorrow> > randoms (mkStdGen 424242) :: [Bool]
12:51:57 <lambdabot>   [False,True,False,False,False,True,False,False,False,False,False,False,Fals...
12:52:00 <Beelsebob> dons: got about a 30% speedup, but I'm struggling to get more than that
12:52:01 <trofi> @hoogle CReal
12:52:01 <lambdabot> No results found
12:52:03 <Cale> > exp 1 :: CReal
12:52:07 <Beelsebob> on the plus side, the alteration is tiny
12:52:07 <mmorrow> > randomRs (0,1) (mkStdGen 424242) :: [Int]
12:52:08 <lambdabot>   2.7182818284590452353602874713526624977572
12:52:10 <lambdabot>  Terminated
12:52:15 <mmorrow> > randomRs (0,1) (mkStdGen 424242) :: [Int]
12:52:19 <lambdabot>   [0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,...
12:52:22 <Cale> > showCReal 100 (exp 1)
12:52:27 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
12:52:29 <Beelsebob> dons: http://hpaste.org/10070
12:52:32 <mmorrow> heh
12:52:40 <Cale> > showCReal 100 pi
12:52:45 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
12:52:58 <mauke> @where+ CReal http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-CReal.html
12:52:58 <lambdabot> I will remember.
12:53:03 <dons> Beelsebob: on 2 cores?
12:53:07 <Beelsebob> 2 cores, yes
12:53:12 <dons> and just that one function?
12:53:16 <Beelsebob> not tested on my Xeon -- need to go to work for that
12:53:20 <Beelsebob> yes, just that one function
12:53:20 <dons> ok. i've got a quad core, will try .
12:53:25 <Beelsebob> if you modify it lower down it slows down
12:53:27 <dons> looks like a good start
12:54:05 <Beelsebob> it has a little bit of a strange behavior
12:54:11 <Beelsebob> it prints pairs of lines very quickly together
12:54:26 <Beelsebob> and then pauses
12:54:37 <Beelsebob> it may do 4 quickly at once on a quad core
12:55:08 <mmorrow> not this if this is even related, but i recall a note in the docs about when to use `seq` and when to use `pseq`
12:55:14 <Igloo> GADT question: Can I make this work without adding a Show constraint on the Cons constructor? http://hpaste.org/10071
12:55:16 <mmorrow> *not sure if ...
12:58:23 <benny99> hm... to understand to use monads the right way appears difficult to me -- I'll take a nap...
12:58:43 <roconnor> How do I use git push to make a new branch in my public repository?
12:58:56 <Cale> Igloo: I guess the problem is that there's no way to say that p has instances of Show for every choice of types x and y.
13:00:17 <Cale> Igloo: Combined with the trouble that the 'mid' type isn't mentioned in the type signature...
13:01:21 <mmorrow> Igloo: i didn't get it to work, but this error msg is /HUGE/! :)   http://hpaste.org/10071#a1
13:01:30 <Cale> If you have:
13:01:32 <Cale> class Show2 f where
13:01:32 <Cale>     show2 :: f a b -> String
13:01:38 <Cale> then
13:01:38 <mmorrow> yeah
13:01:39 <Cale> toString :: Show2 p => Seq p from to -> String
13:01:39 <Cale> toString Nil = ""
13:01:39 <Cale> toString (Cons p ps) = show2 p
13:01:42 <mmorrow> {-# LANGUAGE UndecidableInstances #-}
13:01:50 <Igloo> Cale: Yeah, I was trying to avoid a differently names show function
13:02:00 <roconnor> oh nevermind
13:02:19 <Cale> And there's no way to specify a general instance of Show2, I don't think... you immediately run into the same issue.
13:03:10 <EvilTerran> Igloo, the short answer to your original question is "no", because you have an existentially qualified type
13:03:19 <EvilTerran> (albeit implicitly, owing to the GADT syntax)
13:03:36 <dons> mmorrow: so a small speedup, 109% cpu 44.600 total
13:03:50 <EvilTerran> as the type of a constructor parameter doesn't appear in the return type, you can't put constraints on it except when defining the type
13:04:41 <Igloo> EvilTerran: Right, so I want a way to universally quantify variables in the constraints
13:05:17 <EvilTerran> er?
13:05:51 <Igloo> EvilTerran: for any types x and y, Show p x y exists
13:06:00 <Igloo> Therefore Show p from mid exists
13:06:06 <bjrn> profiling <3
13:06:07 <EvilTerran> i see
13:06:18 <bjrn> A single function: 66% of the time
13:06:30 <EvilTerran> i think you may need to do arcane things with witnesses or something similarly olegian
13:07:03 <mmorrow> dons: @Beelsebob?
13:07:52 <dons> sorry, yes.
13:08:12 <Beelsebob> dons: 44.6 total?
13:08:13 <Beelsebob> seconds?
13:08:15 * araujo greets dons 
13:08:22 <Beelsebob> is this a slow quad core?
13:08:32 <mmorrow> haha
13:08:48 <Beelsebob> what happens if you use -N2?
13:09:35 <Beelsebob> because I'm getting 31s on a 2Ghz C2D
13:09:55 <dafra> > random (mkStdGen 0) :: (Bool, StdGen)
13:10:00 <lambdabot>   (True,40014 40692)
13:10:18 <mmorrow> @type next
13:10:20 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
13:11:00 <mmorrow> @type next :: (RandomGen g, Random a) => g -> (a, g)
13:11:02 <lambdabot>     Couldn't match expected type `a' against inferred type `Int'
13:11:02 <lambdabot>       `a' is a rigid type variable bound by
13:11:02 <lambdabot>           the polymorphic type
13:11:13 <quicksilver> sjanssen: yes. the question is is that allocation enough to slow it down.
13:11:29 <dons> Beelsebob: slow dual core.
13:11:34 <quicksilver> sjanssen: I mean, it perhaps seems very likely in this precise case, ut in a more general case
13:11:38 <dons> Beelsebob: but seeing 109% cpu,
13:11:43 <dons> so there's work to do.
13:11:53 <dafra> > [fst (random (mkStdGen i)) | i <- [0..9] :: [Bool]
13:11:57 <lambdabot>   mueval: Prelude.read: no parse
13:12:09 <Beelsebob> dons: odd, I'm seeing 166%
13:12:15 <dons> cool
13:12:21 <dons> maybe post the flags you're using , and the complete program
13:12:27 <dafra> > [fst (random (mkStdGen i)) | i <- [0..9]] :: [Bool]
13:12:31 <lambdabot>   [True,True,True,True,True,True,True,True,True,True]
13:12:35 <mmorrow> Beelsebob: what ghc are you running?
13:12:47 <dafra> that's weird : always True
13:12:48 <Beelsebob> 6.8.2 and ghc --make -O2 -fglasgow-exts -fexcess-precision -fasm -threaded binarytrees.hs -o binarytrees.ghc_run
13:13:10 <dafra> the fist timr, random is always True
13:13:43 <jeffwheeler> @pl \s -> not (s `elem` f)
13:13:43 <lambdabot> not . (`elem` f)
13:13:50 <jeffwheeler> Doh. Always obvious.
13:13:56 <mauke> jeffwheeler: (`notElem` f)
13:14:09 <dafra> are there better random generators than the default one ?
13:14:10 <jeffwheeler> Ha. Thanks.
13:14:26 <EvilTerran> > map (fst.random.mkStdGen) [0..] :: [Bool]
13:14:29 <mmorrow> it'd be great if you could do
13:14:30 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
13:14:40 <mmorrow> a `this that` b
13:14:44 <EvilTerran> > findIndex not $ map (fst.random.mkStdGen) [0..]
13:14:49 <lambdabot>   Just 53668
13:14:53 <EvilTerran> oh dear
13:15:07 * benny99 doesn't understand anything
13:15:26 <EvilTerran> mmorrow, define operators "infixl 1 <|, |>; x <| f = f x; f |> x = f x"
13:15:28 <Saizan_> you're not uspposed to keep creating different seeds, but rather use the returned one..
13:15:29 <benny99> http://hpaste.org/10072 <- ok, how I might get it to output "TestData 20 "Bye" ?
13:15:38 <EvilTerran> mmorrow, then you can write "xs <|zipWith (+)|> ys" and whatnot
13:15:43 <mmorrow> EvilTerran: ah, clever.
13:16:29 <waynemokane> how can I tell where my local haddock docs are?
13:16:33 <EvilTerran> mmorrow, if you fancy using unicode, you can use more compact things for those - i find "xs ¬´zipWith (+)¬ª ys" to be fairly aesthetically pleasing
13:16:34 <dafra> the generator is very poor : i shuffled a deck of cards, sorted by ranks, and it ended sorted by colors !
13:16:37 <mauke> benny99: you need a runState somewhere
13:16:57 <mmorrow> > ord '¬ª'
13:17:02 <lambdabot>   187
13:17:18 <EvilTerran> ok, extended ascii. whatever. :P
13:17:22 <ddarius> @hackage mersenne-random
13:17:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random
13:17:26 <mauke> benny99: let (x, y) = runState doStateStuff test
13:17:33 <mmorrow> > ord '\63734'
13:17:37 <lambdabot>   63734
13:17:39 <mauke> (extended ascii)--
13:17:50 <mmorrow> heh
13:18:00 <mmorrow> i view 'a' as being unicode
13:18:17 <dmwit> ?karma ascii)
13:18:17 <lambdabot> ascii) has a karma of -1
13:18:19 <dafra> does mersenne support splitting ?
13:18:26 <mmorrow> > utf8s 'a'
13:18:29 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
13:18:33 <mmorrow> > utf8 'a'
13:18:37 <lambdabot>   "a"
13:18:41 <dafra> split is in the class after all
13:18:42 <benny99> mauke: may you paste that hat hpaste.org? Sorry, I really don't understand how it's supposed to be used :(
13:19:29 <rwbarton_> dafra: you know map mkStdGen [0..] isn't how you're supposed to use mkStdGen, right?
13:19:43 <dafra> rwbarton_: yes :)
13:19:49 <rwbarton_> dafra: OK, good :)
13:20:24 <dmwit> dafra: Did you know that the usual "riffle shuffle" that people do is also not a good way to randomize a deck?
13:20:29 <mauke> benny99: http://hpaste.org/10072#a1
13:20:30 <dmwit> =)
13:20:57 <mmorrow> > let g = mkStdGen0 ; ((x0::Int),g0) = random g ; (x1,g1)  = random g0 ; (x2,g2) = random g1 in ([x0,x1,x2],g2)
13:21:00 <lambdabot>   mueval: Prelude.read: no parse
13:21:02 <mmorrow> > let g = mkStdGen 0 ; ((x0::Int),g0) = random g ; (x1,g1)  = random g0 ; (x2,g2) = random g1 in ([x0,x1,x2],g2)
13:21:07 <lambdabot>   ([-117157315039303149,-8854136653200549331,-2598893763451025729],1860990862...
13:21:37 <mmorrow> > let g = mkStdGen 0 ; ((x0::Int),g0) = random g ; (x1,g1)  = random g0 ; (x2,g2) = random g1 in (g,g0,g1,g2)
13:21:41 <lambdabot>   Add a type signature
13:21:59 <dafra> dmwit: what's riffle shuffle ? I split the deck in odd and even position cards, and append both left ++ right or right ++ left, randomly
13:22:00 <mmorrow> > let g = mkStdGen 0 ; ((x0::Int),g0) = random g ; (x1,g1)  = random g0 ; (x2,g2) = random g1 in (g,g0,g1,g2::StdGen)
13:22:03 <lambdabot>   Add a type signature
13:22:09 <dmwit> > randoms (mkStdGen 0) :: [Int]
13:22:13 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
13:22:23 <benny99> mauke: thanks :)
13:22:39 <mmorrow> > let g = mkStdGen 0 ; ((x0::Int),g0) = random g ; (x1,g1)  = random g0 ; (x2,g2) = random g1 in (x0::Int) `seq` (g,g0,g1,g2)
13:22:41 <dmwit> dafra: That's very close to the riffle shuffle.
13:22:43 <lambdabot>   Add a type signature
13:22:49 <dmwit> dafra: May I suggest a permutation shuffle instead?
13:23:04 <Beelsebob> @hoogle [a] -> [a] -> [a]
13:23:04 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
13:23:04 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
13:23:04 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:23:06 <dmwit> ?go oleg perfect shuffle provably
13:23:11 <Beelsebob> @hoogle interleave
13:23:13 <dafra> dmwit: sure, didnt findany good code on the web, still searching
13:23:18 <lambdabot> http://okmij.org/ftp/Haskell/
13:23:19 <lambdabot> Title: Haskell Programming: Miscellanea
13:23:19 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
13:23:19 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
13:23:20 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
13:23:22 <Beelsebob> @hoogle intersperse
13:23:22 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
13:23:24 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:23:26 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
13:23:36 <dmwit> dafra: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
13:25:22 <quicksilver> Beelsebob: in fact, if I think as an *implementor*, all I need to think about is the sinks.
13:25:36 <Beelsebob> quicksilver: sounds about right, yes
13:25:37 <benny99> mauke: going to take take a nap now... that in fact helped me a lot :), bye
13:25:37 <quicksilver> Beelsebob: Event, Behaviour and Reactive are properly viewed as abstract.
13:25:43 <dafra> dmwit: i had seen this one. its ugly, but if perfect...
13:25:45 <Beelsebob> yes
13:25:55 <quicksilver> Beelsebob: I can implement them however I want as long as the sinks drive it all correctly.
13:26:02 <quicksilver> Beelsebob: I think I finally have it :)
13:26:14 <Beelsebob> :)
13:26:30 <quicksilver> for example, all the E,B,R combinators could be fully abstract,
13:26:36 <quicksilver> I could do all the hard work at sink-time.
13:26:37 <dmwit> dafra: It's only as perfect as your generator, of course.
13:26:45 <quicksilver> that probably loses far too much sharing though.
13:27:03 <quicksilver> Beelsebob: thank you again, you've been most helpful :)
13:27:08 <Beelsebob> no probs
13:27:09 <dmwit> dafra: There is certainly a more easily written/readable version of permutation shuffle, but why bother?  It's already written. =)
13:28:38 <ddarius> dmwit: Just implement the imperative algorithm.
13:29:18 <FliPPeh> @source
13:29:18 <lambdabot>  not available
13:29:22 <FliPPeh> Hugh!
13:36:37 <Beelsebob> dons: how are you measuring CPU use?
13:37:04 <SamB> Beelsebob: weighing the CPU before and after use, of course
13:37:11 <Beelsebob> lol
13:37:35 <dmhouse> ?remember <Beelsebob> dons: how are you measuring CPU use? <SamB> Beelsebob: weighing the CPU before and after use, of course
13:37:35 <lambdabot> Good to know.
13:37:48 <SamB> dmhouse: would you stop doing that
13:37:59 <dmhouse> SamB: stop being funny, then.
13:38:03 <SamB> ?remember SamB <Beelsebob> dons: how are you measuring CPU use? <SamB> Beelsebob: weighing the CPU before and after use, of course
13:38:03 <lambdabot> It is forever etched in my memory.
13:38:08 <dmhouse> Oh.
13:38:19 <SamB> ?forget <Beelsebob> dons: how are you measuring CPU use? <SamB> Beelsebob: weighing the CPU before and after use, of course
13:38:19 <lambdabot> Done.
13:38:53 <SamB> dmhouse: note that by "you", I mean "those denizens of haskell who keep using ?remember wrong"
13:38:53 <Igloo> Hmm, I've solved the problem for Show, but now I'm stuck on Read
13:39:10 <Leaves> hi, I really don't understand what is happening here: http://hpaste.org/10073, this must be a really stupid mistake from me or it is a bug in ghc..
13:39:14 <dmhouse> Igloo: what's the problem?
13:39:18 <dons> Beelsebob: time and +RTS -sstderr
13:39:25 <dons> Beelsebob: on a dual and quad core.
13:39:32 <dons> there's a lot of memory traffic here.
13:39:39 <mmorrow> Igloo: interesting, could you paste?
13:39:42 <dons> but we may get some benefit by locking down thread affinities
13:39:43 <Igloo> Cale: http://hpaste.org/10074 works for Show, BTW
13:40:00 <Beelsebob> okay, I was just using activity monitor to watch it -- I've got up to pegging both CPUs, and another 10% speed up
13:40:02 <dmhouse> Leaves: what were you expecting?
13:40:11 <Beelsebob> just seeing what -sstderr says
13:40:47 <Leaves> dmhouse: the last two elements also of length 5
13:40:51 <mmorrow> Igloo: interesting...
13:41:06 <dmhouse> Leaves: why?
13:41:10 <dons> Beelsebob: awesome.
13:41:18 <dons> we need to document these tricks
13:41:49 <Beelsebob> dons:     let vs = (parMap rnf) (depth' maxN) [minN,minN+2..maxN] and depth appropriately adapted to only do one level
13:42:01 <FliPPeh> How does the "Data" stuff work? It looks like a structure from imperative langauges to me
13:42:07 <Beelsebob> the CPU usage drains off as we get to bigger trees
13:42:11 <Beelsebob> I suspect more GC is happening
13:42:14 <Beelsebob> and blocking both threads
13:42:35 <Leaves> dmhouse: owh no, it is too late to be coding still, I see the error in my thinking (or not thinking) now... thanks for your help
13:42:42 <dons> Beelsebob: hmm. yes.
13:42:46 <Beelsebob> it's saying 55% of time spent in GC atm
13:42:48 <Igloo> http://hpaste.org/10075 is the Read problem. Maybe I just fundamentally need an unsafeCoerce there
13:42:53 <dons> once it gets out of the cache, bandwidth becomes an issue, and GC
13:43:14 <Beelsebob> hmm, so my Xeon workstation with quad channel ram is probably not the best machine to test on then
13:45:47 <mmorrow> Igloo: hmm. i think you may, related to how data A = A (forall a.a)  needs a coerce on the way in, and data B = forall a. B a needs a coerce on the way out
13:46:14 <mmorrow> err, maybe i switched that
13:46:30 <mmorrow> no i didn't
13:47:24 <dons> Beelsebob: i notice we've never tried adjusting the GC hints at runtime in this benchmark...
13:47:29 <dons> since it stresses the GC, that's kind of odd.
13:47:39 <Beelsebob> oh, I didn't know that one could do that
13:47:40 <dons> initial GC sizes, maximum residencies, generation tweaks
13:47:46 <dons> oh, huh.
13:47:51 <dons> i think i just doubled the performance...
13:47:55 <Beelsebob> awesome
13:47:57 <dons> testing...
13:48:19 <ddarius> We forgot to pass the -fdouble-performance flag
13:48:21 <dons> kind of stupid i didn't think of this before.
13:48:26 <Beelsebob> ddarius: rofl
13:48:27 <dons> Beelsebob: +RTS -A350M
13:48:36 <Taejo> I'm doing an assignment with a bunch of tree transformations... I chose to do Haskell because I thought, "pattern matching will whip this"... but I wrote just as much code as everyone else because the input and output is more difficult in haskell
13:48:51 <dons> Taejo: i'd hope IO was shorter!
13:49:01 <dons> x <- decodeFile "foo" :: IO Tree
13:49:03 <dons> process x
13:49:10 <dons> encodeFile "foo2" x'
13:49:10 <Beelsebob> dons: that causes my kernel to go crazy allocating RAM
13:49:20 <dons> yeah, it takes it from 50s to 23s here
13:49:29 <dons> ah, but that was single core..
13:49:39 <dons> so that'll help the normal benchmark...
13:49:45 <Beelsebob> dons: that halved user time for me
13:49:48 <Beelsebob> but doubled system time
13:49:51 <dons> heh
13:49:56 <Beelsebob> but as I discovered earlier, OS X is *shit* at malloc
13:49:57 <dons> so wall clock time?
13:50:02 <dons> i've heard that.
13:50:02 <Beelsebob> and the tests are done on linux
13:50:16 <Taejo> dons: decodeFile is like 10 lines of perl, but I have the whole thing properly typed so each node has the right number of arguments and so on, and so I have to have separate code for each node type
13:50:24 <Taejo> and I wasn't that amped to learn TH
13:50:27 <Beelsebob> wall-clock got doubled too -- but I'd be interested in it running on Linux
13:50:36 <dons> Taejo: i guess we'd need to see the code to work out what the issue is.
13:50:46 <dons> oh, you were actually using Data.Binary ?
13:51:01 <dons> so the problem was instance code ?
13:51:07 <Beelsebob> dons: this is my current best code if you'd like to try on Linux
13:51:10 <Beelsebob> http://hpaste.org/10070#a1
13:51:23 <ddarius> Sounds like a case for phantom types
13:51:40 <dons> yeah, Beelsebob 46s to 18s here with -N2 -A300M
13:51:47 <Beelsebob> awesome
13:51:50 <dons> so that's going to improve normal binary-trees too.
13:51:58 <Beelsebob> shiny :)
13:52:09 <Beelsebob> that should get us into first place for binary-trees in parallel actually
13:52:10 <Beelsebob> just
13:52:16 <dons> ah, you switched to parMap ?
13:52:16 <mmorrow> holy craps,
13:52:27 <Beelsebob> yep
13:52:33 <Beelsebob> it's margional, but a little faster
13:52:37 <dons> i'd imagine we could provide -ANNM flags for all benchmarks for the win.
13:52:43 <mmorrow> hehehe
13:52:50 <dons> we used to do that, back in 04-05
13:52:55 <dons> but somehow it fell out of use.
13:52:56 <Beelsebob> hehe
13:53:15 <Beelsebob> I take it that says "by the way, you should allocate 350MB before you start -- you're gonna need it"
13:53:24 <dons> yeah
13:53:36 <dons> Set the allocation area size used by the garbage collector. The allocation area (actually generation 0 step 0) is fixed and is never resized (unless you use -H, below).
13:53:46 <dons> there's a bunch of other runtime flags we can play with.
13:53:49 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#id345729
13:53:50 <lambdabot> Title: 5.14.ÔøΩRunning a compiled program, http://tinyurl.com/d7dj4
13:54:07 <Taejo> the worst of all is finally finishing and running it on the test input, and discovering that the input doesn't satisfy the same type constraints as the spec says
13:54:12 <ddarius> @users
13:54:12 <lambdabot> Maximum users seen in #haskell: 491, currently: 486 (99.0%), active: 18 (3.7%)
13:54:24 <dons> Taejo: i guess we'll need to see the code, if you'd like feedback.
13:54:37 <dons> tree processing, i'd hope for shorter, dramatically faster code, than anyone around.
13:54:45 <Beelsebob> yeh
13:54:50 <Beelsebob> we have the shorter part
13:54:54 <Beelsebob> but only just faster now
13:54:59 <Taejo> and that was indeed the case
13:55:18 <Taejo> my tree-processing is about 1/20 times the C++ people's
13:55:31 <Taejo> 1/20th of the code, I mean
13:55:49 <dons> still, we should be able to beat perl :)
13:56:03 <Beelsebob> I don't understand the gzipped bytes benchmark actually
13:56:05 <dons> Beelsebob: down to 10s on the quad core.
13:56:08 <Beelsebob> it seems completely counter intuative
13:56:11 <dons> so that also halved the running time there.
13:56:12 <Taejo> well, input processing *is* Perl's strong point
13:56:18 <Beelsebob> dons: nice one :)
13:56:19 <Taejo> s/input/text/
13:56:24 <dons> 8s, 170% productive
13:56:32 <Toxaris> Taejo: but Perl is not strong with data structures
13:56:33 <dons> just tweaking -A values
13:56:38 <Beelsebob> excellent
13:56:54 <Toxaris> Taejo: that is, except hash maps and strings :)
13:57:31 <Beelsebob> dons: for me -H350M instead of -A350M got me down by half again
13:57:36 <Taejo> Toxaris: that's what I'm saying... Haskell owned the data structures, but the assignment is so small that processing the input is actually a significant portion of the work
13:57:38 <dons> Beelsebob: %GC time       5.4%  (9.3% elapsed)
13:57:42 <dons> so that's good.
13:57:46 <dons> Beelsebob: ok.
13:57:50 <Beelsebob> yeh, I'm at 5% now
13:58:16 <Beelsebob> I'm at 12 seconds on a dual core now
13:58:30 <Toxaris> Taejo: "processing the input" == parsing?
13:58:37 <Taejo> yeah
13:59:00 <mauke> preflex zenc 4/.g
13:59:00 <preflex>  z4U4zsziz4Ug
13:59:18 <Toxaris> hehe yes, Haskell encourages you to write real parsers, while in Perl, you just hack together some regexp's
13:59:27 <Taejo> that's it
13:59:28 <mauke> pfft, "just"
13:59:37 <dons> Beelsebob: good, seeing good results on dual core now too.
13:59:54 <matthew-_> mauke: quite - what's wrong with a few dozen regexs strung together?!
13:59:58 <Beelsebob> dons: :) -H250M seems to be optimal for me
14:00:05 <dons> ok. testing.
14:00:07 <Beelsebob> gets me down to 11.5 seconds
14:00:45 <dons> we need a program to search for  the best runtime GC flags...
14:00:57 <Beelsebob> hehe, genetic algorithm for flag generation?
14:01:05 <dons> yep
14:01:08 <dons> or just full search
14:01:13 <Beelsebob> actually, conal suggested a genetic algorithm for finding the best place for inserting `par`
14:01:26 <dons> with your parMap, the best time i've got so far on dual core is with time ./Parallel2 20 +RTS -sstderr -N2 -A250M
14:01:32 <ddarius> We could probably just hack a script to test 4-5 options for each flag and that will be more than good enough.
14:01:50 <Beelsebob> dons: interesting, you're still finding -A to be faster than -H?
14:01:55 <Beelsebob> must be an OS X specific thing
14:01:56 <dons> yeah, just a little
14:03:58 <Cale> Igloo: Oh, yes, that direction works, but the other doesn't.
14:04:27 <Cale> (There's no way to get a Show2 instance from an appropriately universal Show instance)
14:04:38 <dons> Beelsebob: system 235% cpu 6.881 total
14:04:40 <Taejo> @tell taejo write your functions with their arguments in the order that encourages currying :)
14:04:40 <lambdabot> You can tell yourself!
14:04:40 <dons> :)
14:04:45 <Beelsebob> dons: fucking hell!
14:04:50 <Beelsebob> how'd you gain that much?
14:04:52 <dons> Beelsebob: we're getting there. that's quad core, with the parMap version
14:04:57 <dons> which seems to be the best one
14:05:02 <dons> time ./Parallel2 20 +RTS -N4 -A150M -sstderr
14:05:18 <Beelsebob> I'm surprised that a lower -A is better on quad core
14:05:30 <Beelsebob> surely it needs to allocate more RAM for doing 4 things at once
14:05:41 <SamB_XP> does each core get it's own pool ?
14:06:01 <dons> 245% cpu 6.477 total
14:06:10 <dons> GC down to 3%
14:06:14 <ddarius> mapM_ system $ liftM2 (printf "ghc %s %s %s" progName) ["-A200M", "-A250M", "-A300M"] ["-H200M", "-H250M", "-H300M"]
14:06:37 <Beelsebob> ddarius: giggle
14:06:50 <SamB_XP> :t mapM_ system $ liftM2 (printf "ghc %s %s %s" progName) ["-A200M", "-A250M", "-A300M"] ["-H200M", "-H250M", "-H300M"]
14:06:52 <lambdabot> Not in scope: `system'
14:06:52 <lambdabot> Not in scope: `progName'
14:06:56 <SamB_XP> aww
14:07:16 <Beelsebob> :t mapM_ System.system $ liftM2 (printf "ghc %s %s %s" "jam") ["-A200M", "-A250M", "-A300M"] ["-H200M", "-H250M", "-H300M"]
14:07:18 <lambdabot> IO ()
14:07:19 <dons> 2.8% GC, system 260% cpu 6.337 total
14:07:25 <dons> so approaching a limit
14:07:26 <SamB_XP> :t mapM_ putStrLn $ liftM2 (printf "ghc %s %s %s" "foo") ["-A200M", "-A250M", "-A300M"] ["-H200M", "-H250M", "-H300M"]
14:07:28 <lambdabot> IO ()
14:07:47 <Beelsebob> dons: yeh, that's getting pretty good -- what's that? 42s -> 6s?
14:08:06 <SamB_XP> hmm, what about the +RTS ?
14:08:13 <dons> nah, let's see...
14:08:24 <dons> 269% cpu. :)
14:08:38 <dons> so that's not too bad
14:09:31 <dons> so the current program, on quad core linux, N=20, 26s
14:09:40 <dons> with parallelisation, and heap tweaks, 6.2s
14:09:50 <dons> > 20 / 6
14:09:55 <lambdabot>   3.3333333333333335
14:09:59 <dons> pretty good.
14:10:03 <Beelsebob> excellent -- that should get us ahead of Java :)
14:10:09 <Beelsebob> and that's all that matters to me :P
14:10:32 <dons> > 44 / 3.33
14:10:37 <lambdabot>   13.213213213213212
14:10:39 <dons> so we'd look at something like 13s
14:10:47 <dons> on the shootout quad core
14:10:54 <dons> which would give us 1st place by a good margin.
14:11:02 <dons> 17.74s for java currently
14:11:12 <Beelsebob> aw bugger
14:11:19 <Beelsebob> C's just knocked us off top spot
14:11:29 <dons> only cause chameneos isn't counted :)
14:11:29 <Beelsebob> we're 1.1 times slower than C now :(
14:11:33 <Beelsebob> oh, okay
14:11:37 <dons> but fix binary-trees and we'll be back in #1.
14:12:03 <im_alone> C Everywhere
14:12:08 <dons> note the original program single core, goes from 26s to 13s by tweaking -A350M
14:12:10 <Cale> Why isn't chameneos counted?
14:12:20 <Beelsebob> so what's the submission process for that?  You emailing the guy who runs the benchmarks?
14:12:35 <dons> nah, there's a web submission
14:12:41 <dons> Cale, too many other langs broke
14:12:52 * dons plays with other flags.
14:12:55 <Beelsebob> hehe
14:13:06 <Beelsebob> I'll have a look in the morning -- I expect us to be no 1 by then :P
14:13:24 <dons> yep, i'll submit it.
14:13:29 <jaggederest> anyone have their linear algebra hat on today?
14:13:29 <dons> and talk to igouy about it too
14:13:36 <Cale> Maybe we should submit working chameneos programs for the other languages :)
14:13:52 <Beelsebob> so is the chameneos redux problem just that no one can quite print the result character perfect?
14:15:15 <dons> it seems like a lot of chameneos programs in other languages broke when moved to the new machine.
14:15:19 <dons> i'm not sure why. smp issues?
14:15:24 <Beelsebob> oh, interesting
14:15:25 <dons> they had incorrect programs, i suppose
14:15:33 <dons> that didn't do the synchronising properly
14:15:40 <dons> there's a story right there.
14:15:49 <Beelsebob> heh, interesting that Ada broke then
14:16:04 <SamB> we have issues
14:16:21 <newsham> haxml is making me sad
14:16:23 <SamB> try googling "Language.C" (with the quotes)
14:16:50 <Beelsebob> SamB: C (programming language) - wikipedia?
14:17:44 <SamB> okay, how do I tell cabal to include SCCs in a library?
14:18:01 <SamB> Beelsebob: not "i'm feeling lucky"!
14:18:02 <dcoutts_> SamB: you mean -auto-all ?
14:18:12 <Beelsebob> SamB: I don't see anything interesting there at all
14:18:15 <SamB> dcoutts: fine
14:18:28 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-c-0.3.1 is what I wanted
14:18:30 <lambdabot> Title: HackageDB: language-c-0.3.1, http://tinyurl.com/5qqlwg
14:18:44 <Beelsebob> SamB: why did you expect it to be on the first page?
14:18:50 <dcoutts_> SamB: configure with --enable-library-profiling --ghc-options=-auto-all
14:19:11 <SamB> Beelsebob: I just wish google would pay a LITTLE bit more attention to punctuation
14:19:28 <Beelsebob> oh, no, google advertises that it pays *no* attention to symbols
14:19:50 <SamB> Beelsebob: but I used quotes
14:19:55 <dcoutts_> SamB: and perhaps add you comments to http://hackage.haskell.org/trac/hackage/ticket/200
14:19:57 <lambdabot> Title: #200 (Allow more convenient use of ghc profiling options -auto and -auto-all) -  ...
14:19:57 <Twey> Makes it quite difficult to do some programming queries
14:20:00 <Beelsebob> SamB: even then
14:20:09 <SamB> I think it should at least reorder the results based on them
14:20:10 <Beelsebob> quotes just means "all these words, in this order"
14:20:13 <Twey> It should pay heed to them with quotes.
14:20:21 <Twey> It makes a special exception for C++, though.
14:20:26 <SamB> I'm a programmer, I require these things
14:20:28 <SamB> Twey: also C#
14:20:32 <Twey> Aye
14:20:33 <SamB> and F#
14:20:52 <ddarius> @google C#
14:20:56 <lambdabot> http://msdn.microsoft.com/en-us/vcsharp/default.aspx
14:20:56 <lambdabot> Title: Visual C# Developer Center
14:21:00 <SamB> @google C
14:21:02 <lambdabot> http://en.wikipedia.org/wiki/C_(programming_language)
14:21:02 <lambdabot> Title: C (programming language) - Wikipedia, the free encyclopedia
14:21:10 <rwbarton_> It seems like it's more an exception for + and #.
14:21:13 <SamB> hmm, I wonder if they made any exceptions for C?
14:21:21 <SamB> @google B#
14:21:23 <lambdabot> http://blogs.bartdesmet.net/bart/
14:21:24 <lambdabot> Title: B# .NET Blog
14:21:30 <SamB> @google Z--
14:21:32 <ddarius> @google F#
14:21:32 <lambdabot> http://en.wikipedia.org/wiki/Z
14:21:32 <lambdabot> Title: Z - Wikipedia, the free encyclopedia
14:21:33 <lambdabot> http://research.microsoft.com/fsharp/
14:21:34 <lambdabot> Title: Microsoft F#
14:21:35 <SamB> @google Z++
14:21:37 <lambdabot> http://www.zhmicro.com/
14:21:37 <lambdabot> Title: ZHMICRO Software, Home of Scientifically Oriented Sofware Engineering
14:21:46 <EvilTerran> @google C -programming
14:21:48 <lambdabot> http://en.wikipedia.org/wiki/Celsius
14:21:48 <lambdabot> Title: Celsius - Wikipedia, the free encyclopedia
14:21:55 <EvilTerran> it pays attention to '-', too
14:22:04 <SamB> @google C--
14:22:07 <lambdabot> http://en.wikipedia.org/wiki/C_(programming_language)
14:22:07 <lambdabot> Title: C (programming language) - Wikipedia, the free encyclopedia
14:22:10 <EvilTerran> not at that end
14:22:22 * rwbarton_ googled for X# -- with disturbing results
14:22:26 <SamB> EvilTerran: that doesn't count, that's explicit exclusion syntax!
14:22:35 <SamB> @gogle X#
14:22:37 <lambdabot> http://www.microsoft-watch.com/content/operating_systems/microsoft_x_on_tap.html
14:22:37 <lambdabot> Title: Microsoft Watch - Operating Systems - Microsoft 'X#' On Tap?
14:22:44 <EvilTerran> different meaning of "pay attention", i guess
14:25:11 <jaggederest> http://refactormycode.com/codes/473-raytracer-in-haskell-lisp-seems-to-be-the-closest-answer-eh
14:25:12 <lambdabot> Title: Raytracer in haskell (lisp seems to be the closest answer, eh?) - RefactorMyCode ..., http://tinyurl.com/5wmabe
14:25:30 * SamB fills out the dissatisfaction form
14:25:41 <ziman> i'm trying to create a module called ~/Utils.hs and have it automatically loaded on ghci start (via ~/.ghci). Instead, i'm getting this error (?): module main:Utils is not loaded
14:25:44 * SamB is happy that google has such a form to fill out
14:25:57 <jaggederest> would have put it in hPaste but it's a few lines too long
14:26:20 <ziman> does anybody know right away what could be wrong?
14:26:21 <jaggederest> (which is, of course, what I need help with heh)
14:26:58 <ddarius> jaggederest: They are called data types.
14:27:16 <Ilmuri> http://www.kuvalauta.fi/b/src/122000748327.jpg this is also finnish BB
14:27:21 <jaggederest> yes, that's correct. I ought to be using better ones
14:27:25 <Ilmuri> -
14:27:30 <ddarius> SamB: It's just a ploy to soothe the masses.  The input goes straight to /dev/null
14:27:31 <Ilmuri> sigh, wrong window
14:27:36 <EvilTerran> ...
14:27:37 <Ilmuri> but it's still good enough ;<
14:27:53 <SamB> ddarius: google doesn't waste data like that
14:28:08 <EvilTerran> Ilmuri, this is a family-friendly channel (-.-)
14:28:21 <SamB> surely they keep it for at least a month before funneling it to /dev/null
14:29:05 <SamB> I mean, it's an excellent way to create statistics regarding the characteristics of queries that people are displeased with the results of ...
14:29:37 <Beelsebob> dons: wow, chameneos-redux really doesn't like OS threads, does it?
14:29:48 <Ilmuri> EvilTerran: yeah, seeing horrible breasts is going to scar everyone's minds forever
14:29:57 <Ilmuri> emphasis on horrible (because it's true)
14:29:58 <dons> Beelsebob: i get better with -N5 ...
14:30:00 <dons> 290% cpu 5.889 total
14:30:06 <Beelsebob> oh, cool
14:30:10 * SamB fills one out for the results of a search for "C--" as well
14:30:13 <dons> so much IO i guess.
14:30:27 <Ilmuri> anyhow, I'll play closer attention to my open window when pasting in the future
14:30:38 <dons> 295% ..
14:30:38 <Beelsebob> I got to 1:30 and killed it using -N2 -- it's 5 seconds with -N1
14:30:42 <Beelsebob> dons: shiny
14:30:47 <dons> ok, -N8 is a bit too much :)
14:30:52 <Beelsebob> lol
14:31:16 <dons> the N+1 rule is pretty good.
14:31:29 <dons> so we should really do a sweep over the shootout looking for programs spending more than 5% of their time doing GC
14:31:29 <Beelsebob> hmm, tis odd
14:31:34 <dons> woot, 300% cpu 5.777 total
14:31:40 <Beelsebob> in other languages I've usually found 2N is best
14:31:40 <dons> time ./Parallel2 20 +RTS -N5 -A350M -sstderr
14:31:40 <SamB> Beelsebob: how come?
14:31:51 <Beelsebob> SamB: to which statement?
14:31:58 <SamB> how come it's odd
14:32:13 <SamB> and what other languages have a setting like this?
14:32:18 <dons> i'll set up a Parallel subset on the shootout wiki
14:32:31 <Beelsebob> SamB: not many -- usually I have to hard-code t
14:32:32 <Beelsebob> it*
14:32:44 <SamB> Beelsebob: could be apples/oranges then
14:33:07 <dons> so that was ultimately very easy , eh?
14:33:08 <SamB> I'd think that N+1 would result in the threads getting shuffled about a lot
14:33:20 <dons> parMap for map, -N(capabilities+1)
14:33:25 <dons> and -AHeapSiz
14:33:33 <Beelsebob> dons: yeh -- except that we weren't mapping before
14:33:35 <SamB> hmm, but if they get different Haskell threads scheduled on them anyway that isn't really a big deal is it?
14:33:45 <dons> yeah.
14:33:46 <Beelsebob> I assume some optimisation couldn't fire with a map for some reason
14:34:48 <SamB> dcoutts: so, how DOES one find packages that depend on a particular library ?
14:35:36 <dcoutts_> SamB: you mean by hand or in code ?
14:35:50 <SamB> as a human
14:35:54 <dmwit> Hackage reports: "ghc-options: -Wall -Werror" makes the package very easy to break with future GHC versions.
14:35:58 <dmwit> Is there a way to get around that?
14:36:11 <dcoutts_> dmwit: no, it's giving you very good advice :-)
14:36:14 <SamB> dmwit: not use -Wall and -Werror
14:36:21 <dmwit> But... why not?
14:36:32 <SamB> dmwit: are you insane?
14:36:37 <dmwit> I like bondage, it's one of the reasons I choose Haskell.
14:36:37 <dcoutts_> dmwit: every new ghc version adds a new warning
14:36:37 <mauke> because future GHC versions make it break
14:37:01 <SamB> dmwit: haven't you seen some of the stupid warnings GHC gives sometimesÔºü
14:37:10 <SamB> whoops
14:37:33 <ddarius> SamB: The results of those forms are analyzed for a future product GoogleEmo
14:37:34 <dmwit> Fine.
14:37:38 <dmwit> But I'm keeping -Wall.
14:37:39 <dcoutts_> SamB: we do not yet provide any easy tools to do reverse lookups if that's what you're asking.
14:37:51 <dcoutts_> dmwit: that's the sensible thing to do
14:38:00 <SamB> I somehow went into the japanese IM ...
14:38:24 <dcoutts_> dmwit: perhaps the message should suggest that, to use -Wall only
14:39:23 <SamB> why can't cabal remove things yet?
14:39:37 <dcoutts_> SamB: because it does not track what files are in a package
14:39:45 <rwbarton_> SamB: Because you have not written that feature yet
14:39:53 <quicksilver> SamB: because it's sponsored by a cabal of hard disk manufacturers.
14:39:59 <SamB> dcoutts: okay, where do I start on that feature?
14:40:01 <dcoutts_> rwbarton_: right :-)
14:40:09 <dcoutts_> SamB: lemme find you the ticket...
14:40:24 <dcoutts_> SamB: http://hackage.haskell.org/trac/hackage/ticket/234
14:40:25 <lambdabot> Title: #234 (track installed files to allow uninstall) - Hackage - Trac
14:41:05 <dmwit> Whoops.
14:41:10 <dmwit> How do I get a Hackage account?
14:41:34 <mauke> http://hackage.haskell.org/packages/accounts.html
14:41:35 <lambdabot> Title: HackageDB: User accounts
14:41:36 <dcoutts_> dmwit: see the instructions on the accounts page
14:41:42 <dmwit> thanks
14:46:20 <sclv> gah. ghc is too smart for its own good.
14:46:54 <sclv> i was playing with ieee stuff and added error flags to -utils, then tried to cook up a higher-level interface.
14:47:23 <mauke> ghc is the closest thing we have to a sufficiently smart compiler
14:47:29 <SamB> oops, apparantly I set myself as the owner of that bug
14:47:32 <SamB> oh well
14:47:36 <sclv> and all was well until I though "oh, hey! We can write something called perturb that runs a pure function multiple times with different rounding modes and then we can get numeric stability testing for free!"
14:47:49 <sclv> And then oops...
14:48:16 <sclv> Even in ghci it only evaluates the thunk once.
14:48:28 <sclv> and I can't seem to figure out any way to trick it to evaluating it multiple times.
14:48:44 <sclv> Possibly something gnarly with polymorphism to prevent CAFing might work...
14:48:58 <bd_> sclv: try (something_depending_on_test_parameters `seq` f) arg
14:49:01 <ddarius> Why not just add a parameter?
14:49:13 <bd_> assuming you need a parameter for it
14:49:16 <sclv> ddarius: even with a parameter it doesn't seem to wrork...
14:49:18 <sclv> erm, work
14:49:21 <bd_> if it's bound to a top-level constant it'll only be evaluated once
14:49:28 <SamB> ddarius: well, how would he keep the parameter from being elided ?
14:49:35 <bd_> but the seq trick ought to ensure it can't completely be elided... I hope :)
14:49:59 <sclv> perturb (\x -> x / 0.00005) 0.5 doesn't work, for example.
14:50:13 <bd_> sclv: how dows perturb call it?
14:50:21 <SamB> really, it isn't fair to blame the problem on GHC
14:50:27 <dcoutts_> bd_: no, that's not enough
14:50:42 <sclv> even though perturb is theoretically applying (f x) four times -- once after setting the rounding mode each way.
14:50:57 <mauke> does it bind the result?
14:50:58 <SamB> a related problem exists in nearly every programming language
14:51:00 <sclv> SamB: yeah, I know -- the problem is that we have a pure expression that, because of rounding mode, really isn't pure.
14:51:03 <mauke> as in 'let y = f x'?
14:51:13 <bd_> dcoutts_: why not?
14:51:17 <dcoutts_> sclv: the problem is your function to set the flags is not pure
14:51:27 <SamB> dcoutts: that's not REALLY the problem
14:51:37 <ddarius> sclv: It's possible that they are all being executed outside of perturb or outside a block of rounding mode settings resulting in them all being executed with the same rounding mode.
14:51:39 <SamB> the problem is older and deeper
14:51:46 <SamB> the problem is that rounding modes exist
14:51:48 <dcoutts_> well, ok the problem is the function isn't pure but he's pretending it is
14:52:11 <sclv> mauke -- I didn't tell it to bind the result. I could possibly figure out some way to tell it explicitly *not* to.
14:52:13 <dcoutts_> bd_: strictness and dependencies within evaluation are not quite the same.
14:52:23 <SamB> dcoutts: he's not the one to blame for the fantasy
14:52:23 <sclv> I'm not  "pretending" that perturb is pure.
14:52:30 <sclv> It's in IO.
14:52:42 <bd_> sclv: however it alters the evaluation of a pure function
14:52:44 <sclv> The problem is that the numeric expressions can't *help* being pure.
14:52:47 <rwbarton_> Haskell is "pretending" that (/) is pure
14:52:48 <dcoutts_> bd_: using seq doesn't mean it must be evaluated multiple times, just that it must be evaluated
14:52:50 <ddarius> What is the code to perturb?
14:52:54 <SamB> and GHC is the one fantasizing here, anyway
14:53:02 <bd_> dcoutts_: mm :/
14:53:12 <dcoutts_> SamB: well not really. The subset it uses is pure.
14:53:20 <SamB> but then so does the Haskell report ...
14:53:28 <bd_> sclv: You could define a new numeric type that implies the rounding mode
14:53:31 <dcoutts_> SamB: it's just extending it to the full ieee fp feature set is a pita
14:53:49 <SamB> dcoutts: well, okay.
14:53:53 <sclv> http://hpaste.org/10078
14:54:09 <SamB> well, C has the same fantasy
14:54:23 <SamB> it's one of the few fantasies in C
14:54:31 <SamB> (perhaps the only one?)
14:54:40 <sclv> bd: hmm... and then only accept values into "perturb" of type "IEEE a" ? I don't think that would work.
14:55:11 <sclv> dcoutts: the subset that (/) uses isn't pure. as in, I can call setRound and change the results of (/)
14:55:26 <sclv> the subset that (/) uses is pure to the extent that nobody touches the fpu rounding mode.
14:55:27 <ddarius> It's probably getting executed to soon.
14:55:34 <dcoutts_> sclv: yes, but setRound isn't part of the api that ghc provides.
14:55:41 <dcoutts_> sclv: right
14:55:47 <bd_> sclv: Or cast from float to IEEE a
14:56:07 <sclv> IEEE is actually a newtype of IO with restricted operations...
14:56:11 <dcoutts_> sclv: could you annotate that paste with the defintions of runIEEE and withRoundMode
14:57:01 <sclv> dcoutts: done.
14:57:42 <sclv> as it is, it's useful and the right approach as far as it goes, I think...
14:58:00 <sclv> It would just be really nice to have something like perturb (and probably a cute selling point for haskell too)
14:59:11 <sclv> using calculate (which is really just liftIO evaluate) we can at least force strictness -- so that exception flags get set when we want them to.
14:59:18 <sclv> we just don't seem to be able to delay...
14:59:32 <ddarius> sclv: Okay, so what is the definition of (/) that lets you pass in (\x -> x / 0.00005) ?
14:59:56 <sclv> ddarius: huh?
15:00:37 <ddarius> perturb :: ... -> (b -> IEEE a) ...
15:00:43 <sclv> right.
15:00:56 <dcoutts_> sclv: yeah, that's the bit I don't get yet too
15:01:06 <dcoutts_> what is the type of / there
15:01:13 <sclv> oh, sorry... it's (\x -> return $ x / 0.000005)
15:01:21 <dcoutts_> sclv: ah ok, so that's why it breaks
15:01:41 <dcoutts_> x / 0.000005 does not depend on the monad parameter so it can be floated out
15:01:45 <dcoutts_> outside and shared
15:01:58 <sclv> any way to prevent that?
15:02:03 <dcoutts_> you need / itself to be in the monad
15:02:08 <dcoutts_> since it depends on the rounding mode
15:02:22 <sclv> oh, I need to define, e.g., ./, .* and soforth?
15:02:26 <dcoutts_> yes
15:03:07 <dcoutts_> and you need to do it in such a way that it cannot be floated out, which is tricky if you're using the ordinary / * etc
15:03:08 <rwbarton_> But how to make them depend on the mode?  I mean, there's not a dependency that Haskell can see so it might be able to do some more complicated optimization
15:03:09 <dons> our first SMP-parallel benchmark entry submitted to the quad core shootout,
15:03:10 <dons>  http://alioth.debian.org/tracker/index.php?func=detail&aid=311036&group_id=30402&atid=411646
15:03:12 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311036 Haskell GHC: paral ..., http://tinyurl.com/5pguhy
15:03:27 <dons> runtime goes from 26s to 5.6s, using 4 cores. 305% productivity. With *one* line change :)
15:04:01 <dons> this gives me some confidence that we may come to dominate the shootout.
15:04:05 <ddarius> sclv: If you pass withRoundMode a function and an argument and do the application within it, you should be fine (with some care to force things properly)
15:04:11 <dons> there's not a lot of cheap, smp-ready, native code compiled languages there...
15:04:12 <rwbarton_> I bet the compiler doesn't know that, say, do a <- newIORef b; readIORef a is the same as return b
15:04:28 <dcoutts_> ddarius: I'm not sure, even then. Not if one lets things be inlined.
15:05:06 <sclv> so, e.g, (./) :: Floating a => a -> a -> IEEE a; x ./ y -> return $ x / y ?
15:05:17 <sclv> is that sufficient, or will that just inline back out into the same problem?
15:05:26 <dcoutts_> sclv: exactly
15:05:39 <dcoutts_> it'll just get inlined back into the same problem
15:05:39 <sclv> exactly sufficient, or exactly the same problem?
15:05:48 <dcoutts_> you can prevent inlining but you'll get terrible performance
15:05:49 <Saizan_> so you've to use a RealWorld-like token?
15:06:05 <sclv> you mean by giving ./ a noinline pragma?
15:06:05 <dcoutts_> Saizan_: right, but you need the very primitives to use that
15:06:21 <dcoutts_> sclv: right, but expect awful perf, a function call for every fp op
15:06:37 <EvilTerran> you need divIEEE :: Floating a => a -> a -> IO a
15:06:39 <EvilTerran> or similar
15:06:52 <EvilTerran> you could do that with a foreign import and a C wrapper
15:07:03 <dcoutts_> and again, awful performance
15:07:07 <EvilTerran> yes
15:07:14 <dcoutts_> the 'right' thing would be primitives
15:07:18 <RayNbow> yay... I just created a monster in Haskell...
15:07:25 <sclv> hmm.. could I just write it using RealWorld# explicitly?
15:07:26 <SamB> RayNbow: yes, yay!
15:07:27 <EvilTerran> dcoutts_, which would come to the same thing in the end?
15:07:33 <dcoutts_> inline cmm and a state parameter
15:07:38 <SamB> EvilTerran: not really
15:07:39 <dcoutts_> EvilTerran: faster
15:07:49 * EvilTerran wasn't sure if you could do it reliably without dropping down to C
15:07:53 <dmwit> RayNbow: What kind of monster?
15:08:03 <sclv> I could probably use the primop that haskell already has...
15:08:04 <RayNbow> @faq does Haskell have an complexity upperbound?
15:08:04 <lambdabot> The answer is: Yes! Haskell can do that.
15:08:10 <sclv> just give the function that calls it a different type...
15:08:22 <EvilTerran> RayNbow, instance Monad Grue ?
15:08:25 <dcoutts_> EvilTerran: eg touch# turns into no code, but the optimiser cannot see through it, so it's used only for the dependency stuff
15:08:28 <SamB> sclv: but it doesn't demand a RealWorld# ...
15:08:28 <sclv> but now this is getting painful.
15:08:35 <RayNbow> dmwit: foldr1 (liftT2 min *** liftT2 max >>> uncurry (***))
15:08:36 <rwbarton_> how about  data Downward ; data Upward ; ... ; newtype RoundingMode a = RoundingMode Double ; instance Num (RoundingMode a) ; eval :: RoundingMode a -> Double -- magic?
15:08:40 <sclv> SamB: but that doesn't mean I can't use one...
15:08:43 <dcoutts_> sclv: actually touch# might help. Hmm
15:08:43 <rwbarton_> is that possible?
15:08:51 <EvilTerran> dcoutts_, ok, so i take it from what you're saying that it's possible without using the FFI?
15:09:05 <SamB> rwbarton_: I don't think that will fix the issue somehow
15:09:09 <dcoutts_> EvilTerran: yes, but by adding new primitives :-) which is a good deal harder
15:09:27 <RayNbow> > liftT2 min (1,2) (0,4)
15:09:29 <EvilTerran> i see
15:09:31 <SamB> dcoutts: but on the plus side doesn't need -fvia-C to get reasonable performance
15:09:32 <lambdabot>   (0,2)
15:09:35 <EvilTerran> ?type liftT2
15:09:37 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => (b -> a b' c') -> (b, b) -> a (b', b') (c', c')
15:09:37 <RayNbow> > liftT2 (+) (1,2) (0,4)
15:09:40 <dcoutts_> SamB: right
15:09:42 <lambdabot>   (1,6)
15:10:04 <dmwit> RayNbow: Neat, what does it do?
15:10:11 <EvilTerran> ?index liftT2
15:10:11 <lambdabot> bzzt
15:10:33 <EvilTerran> ?hoogle liftT2
15:10:33 <lambdabot> No results found
15:10:35 <EvilTerran> ?
15:10:38 <dmwit> It's a ?let.
15:10:46 <EvilTerran> i see
15:10:52 <EvilTerran> what does the "T" stand for? tuple?
15:10:58 <dmwit> I think so.
15:11:06 <RayNbow> yup
15:11:06 <dmwit> liftT2 = join (***) -- or so
15:11:16 <RayNbow> http://hpaste.org/9986 <-- liftT
15:12:24 <dmwit> :t liftT2 min *** liftT2 max >>> uncurry (***)
15:12:26 <lambdabot> forall b b1. (Ord b1, Ord b) => ((b, b), (b1, b1)) -> ((b, b), (b1, b1)) -> ((b, b), (b1, b1))
15:12:29 <mmorrow> sclv: ooh, cool.
15:12:50 <dmwit> RayNbow: cute
15:13:17 * EvilTerran vaguely detects a connection to `on`
15:13:23 <mmorrow> sweet, and implicit MVar! i never thought about mutable implicit params...
15:13:37 <dmwit> I'd connect it to \((a, b), (c, d)) -> [a,b,c,d] and transpose.
15:14:01 <dmwit> Though that restricts the type slightly, I suppose.
15:14:04 <RayNbow> I find the use of my defined liftT functions limited though... every now and then I still have to use some uncurry magic :p
15:14:36 <EvilTerran> mmorrow, yeah, i've heard that used as a semantically cleaner alternative to mutable globals
15:15:08 <SamB> dcoutts: so what should the new type of Distribution.Simple.Install.install be?
15:15:10 <sclv> mmorrow: it was a suggestion from Heffalump originally.
15:15:30 <SamB> IO [(FilePath, FilePath, SHA1)] ?
15:15:35 <mmorrow> EvilTerran, sclv: hmm, interesting.
15:15:36 <sclv> I'll probably hack away at it more in the next week, and see if I can't get perturb working.
15:16:23 <mmorrow> sclv: ah, just saw your mail, i'll add it asap. later tonight probably. :)
15:16:48 <sclv> cool -- not sure when I'll actually need all this stuff, but its fun to play with :-)
15:16:59 <dcoutts_> SamB: the top level should probably be the same, but internally split into a function that generates a big list of files to install and a second that does it.
15:17:36 <dcoutts_> SamB: the list of files to install should be [(FilePath, FilePath)], the source and relative target
15:18:04 <dcoutts_> SamB: then the function that actually does it can prepend the destdir from CopyFlags if necessary
15:18:33 <dons> ok, sent to -cafe@ a summary of the first parallel shootout entry.
15:18:56 <dcoutts_> SamB: the hardest part is converting GHC.install etc
15:19:16 <dcoutts_> SamB: also, then the install can do sanity checks like that no files overwrite each other. It'd be pretty useful.
15:19:19 <mmorrow> sclv: for sure. who knows, someone may be combing hackage all stressed out because they need this in particular for something asap, and they'll find it :)
15:19:42 <dcoutts_> SamB: and then cabal-install could call this and generate hashes or whatever as it copies things over
15:20:16 <dcoutts_> SamB: unfortunately the Cabal lib itself cannot generate the hashes
15:20:45 <dcoutts_> but if it provides the file list and lets the caller do the copy and hash then that's ok
15:20:51 <dcoutts_> SamB: sound ok?
15:21:30 <SamB> dcoutts_: the bit about Cabal not being able to generate hashes sounds dumb to me
15:21:48 <dcoutts_> SamB: we cannot depend on non-core libs
15:22:08 <SamB> I think Cabal can stand to copy the source of one module
15:22:19 <SamB> (but not, of course, the name)
15:22:22 <bd_> Or perhaps some hashes should be put into core.
15:22:33 <SamB> yes, or that
15:22:35 <dcoutts_> SamB: and it's not worth it to copy in a whole crypto module I think
15:22:44 <SamB> ONE module, I said
15:22:46 <dcoutts_> SamB: the caller in other libs can easily do it
15:23:08 <SamB> uh, I'm not going to stand for this being an "optional" part of installing
15:23:13 <dcoutts_> SamB: runghc Setup install is not going to be doing anything with hashes, it's only package managers
15:23:23 <SamB> oh.
15:23:41 <SamB> so cabal install foo won't do anything with the hash?
15:23:46 <SamB> that's okay then
15:23:58 <dcoutts_> SamB: yes it will, but runghc Setup install will not
15:24:04 <SamB> wait what?
15:24:11 <SamB> that just sounds wrong
15:24:20 <dcoutts_> SamB: that's the split between Cabal the lib and cabal-install the (simple immature) package manager
15:24:43 <Saizan_> that looks problematic if you've a custom Setup.hs
15:24:58 * SamB thinks this whole Setup.hs idea needs rethinking then
15:25:15 <dcoutts_> Saizan_: yes, for custom setup we'd have to just ./setup copy --destdir=image and then do the file list ourselves
15:25:44 <SamB> it shouldn't be possible to manually install one cabaly way and get the hashes, and another cabaly way and not
15:25:50 <SamB> that just sounds like a recipe for disaster
15:26:23 <dcoutts_> SamB: indeed, we would want it both ways, and it's quite possible with a bit more inefficiency and indirection.
15:26:44 <SamB> uh, no.
15:26:52 <dcoutts_> yes ./setup copy --destdir=image
15:27:34 <SamB> well, I mean, it shouldn't be based on something so arbitrary as whether the user used cabal install or not
15:27:53 <SamB> both ways should have the same default behaviour in this respect
15:28:04 <dcoutts_> SamB: look, runghc Setup install does not and never will track installed files. that's not its job
15:28:10 <dcoutts_> SamB: just like make install does not
15:28:24 <SamB> well, we shouldn't be calling it Setup then
15:28:25 <dcoutts_> it's the job of the package manager to manage installed files, not the build tool
15:28:32 <SamB> it's just too damn confusing to do that
15:28:54 <dcoutts_> whu?
15:29:15 <SamB> if it's called Setup, people are going to expect it to set the package up
15:29:15 <dcoutts_> it's what everyone calls these things, python setup.py isn't it?
15:29:39 <dcoutts_> SamB: yes, and how many of those kind of things do you know that generate package file lists ?
15:29:54 <dons> parallel wiki http://haskell.org/haskellwiki/Shootout/Parallel
15:29:56 <lambdabot> Title: Shootout/Parallel - HaskellWiki
15:30:06 <SamB> the typical setup.exe does
15:30:40 <dcoutts_> SamB: that's because a setup.exe is it's own primitive (single package) package manager
15:30:49 <SamB> I'm telling you, if you make this the default for cabal install but not for Setup.hs, this will be at *best* useless
15:31:01 <dcoutts_> SamB: not true
15:31:11 <SamB> how so?
15:31:18 <dcoutts_> SamB: all the package managers manage installed files
15:31:33 <dcoutts_> ebuild, rpm, deb etc, and hopefully (but not yet) cabal-install
15:31:46 <SamB> well, unless of course you can keep users from ever running Setup.hs themselves
15:31:49 <dcoutts_> but ./configure && make install and runghc Setup install do not
15:32:15 <dcoutts_> because they're not package managers and do not support uninstalling, it's another set of tools that do that
15:32:27 <dcoutts_> and it's a sensible place to split the functionality
15:32:40 <dcoutts_> all the install code needs to support is --destdir, which we do
15:32:46 <dons> links like this make me think things might get busy in the coming months, (i hope),
15:32:49 <dons>  http://www.reddit.com/r/programming/comments/6z3q2/real_world_haskell_book_from_oreilly_freely/
15:32:51 <lambdabot> Title: Real World Haskell book from O'Reilly freely available online : programming, http://tinyurl.com/679ktn
15:32:56 <SamB> how do you prevent users from having some package installed by Setup.hs and some by cabal install?
15:33:07 <dons> we need some "learn haskell over the winter" stories :)
15:33:26 <dcoutts_> SamB: how do you prevent users from having some package installed by rpm and some by ./configure && make install?
15:33:27 <SamB> you either need to make it not matter, or keep it from happening
15:33:42 * mmorrow installs all his packages with Setup.lhs
15:33:58 <SamB> dcoutts: well, the fact that rpm doesn't know about packages installed the other way, for starters...
15:34:13 <Guest20642> took me about 2 weeks to be comfortable programming in haskell
15:34:15 <Guest20642> with no FP experience
15:34:26 <SamB> take for instance the user who has just built cabal-install
15:34:33 <mmorrow> Guest20642: awesome!
15:35:03 <dons> that's cool.
15:35:09 <mauke> oh yeah? I wrote an ANSI C compiler when I was 6
15:35:19 <dons> of course you did.
15:35:20 <SamB> he has installed cabal-install and oll of it's dependencies without using cabal-install, but probably will begin to install many new packages using it
15:35:54 <Guest20642> and for what its worth - no college education and just average IQ too (115)
15:36:05 <binrapt> lol IQ
15:36:11 <mauke> average IQ is 100, not 115
15:36:19 <Guest20642> yea but 115 is nothing to brag about
15:36:23 <SamB> so basically you'd need to have cabal-install pay no attention to the output of ghc-pkg list ...
15:36:36 <Guest20642> some countries have like 110 average too afaik
15:36:37 <binrapt> The IQ cult is silly
15:36:42 <binrapt> lol
15:36:43 <Guest20642> yea IQ isnt everything but whatever
15:36:51 <mauke> no, 100 is defined as the average
15:36:59 <Guest20642> its normalized to 100 yea
15:37:02 <dcoutts_> SamB: no, we must be able to use all packages registered with ghc-pkg irrespective of whether we think we manage them or not
15:37:04 <Adamant_> 115 is a standard deviation above average. it's not bad.
15:37:09 <Guest20642> but some populations average out at 100+
15:37:18 <Guest20642> either way im on the way out haha
15:37:20 <Guest20642> bbl
15:37:20 <SamB> dcoutts: well, how are you going to educate users about the difference. think on that.
15:37:25 <dcoutts_> SamB: but obviously it can only uninstall packages it does manage
15:37:42 <dcoutts_> SamB: when users ask to uninstall another then we tell them we do not manage it
15:37:44 <SamB> I for one would not be expecting any such distinction
15:37:59 <SamB> I mean, it's like a distinction between packages managed by apt and by dpkg ...
15:37:59 <dcoutts_> SamB: eg packages installed by the distro package manager
15:38:18 <dcoutts_> SamB: no, it's like a distinction between packages managed by apt and gnu stow
15:38:27 <dcoutts_> or apt and manual in /usr/local
15:38:44 <dcoutts_> or any primary / secondary package manager setup
15:39:06 <SamB> dcoutts: but apt doesn't allow non-dpkg packages to fulfill depencencies
15:39:23 <SamB> so your analogy doesn't work
15:39:34 <dcoutts_> SamB: true it is in a privileged position to take a closed world point of view
15:39:54 <SamB> I think the apt/dpkg view is more apt
15:40:02 <dcoutts_> no, because apt uses dpkg
15:40:11 <SamB> yes, and cabal install uses cabal!
15:40:31 <dcoutts_> they're different layers
15:40:43 <SamB> no more than apt and dpkg
15:40:45 <ddarius> dpkg uses make
15:41:02 <dcoutts_> SamB: yes, apt -> dpkg -> autoconf+make
15:41:22 <dcoutts_> SamB: vs, (cabal-install) -> cabal
15:41:29 <SamB> apt is a layer on top of dpkg that can install packages automatically from an online repository, automatically satisfying dependencies from same
15:41:33 <dcoutts_> cabal-install covers both apt and dpkg
15:41:36 <SamB> cabal install is a layer on top of cabal that can install packages automatically from an online repository, automatically satisfying dependencies from same
15:42:02 <ddarius> SamB: apt == cabal-install doesn't imply dpkg == cabal
15:42:23 <SamB> hmm.
15:42:35 <dcoutts_> SamB: the very fact that .cabal packages can be installed by dpkg or ebuild or rpm or whatever show you want layer Cabal belongs to
15:42:52 <dcoutts_> show you want/shows you what
15:42:53 <SamB> but still, apt doesn't really do anything you couldn't do by just downloading debs and running dpkg
15:43:12 <SamB> dcoutts: uh, no.
15:43:21 <SamB> my dpkg has no clue about .cabal
15:43:24 <daedra> hey im getting the error "Could not find module `XMonad.Layout.ResizableTile':" (and for any other imported module) when I run `xmonad --recompile`
15:43:45 <dcoutts_> SamB: it knows about lots of debs that have build scripts that call runghc Setup install
15:44:18 <dcoutts_> well, actually that's the source debs, but you know what I mean
15:44:21 <SamB> dcoutts: yes but what does that have to do with the issue of having some packages with manifests and some without?
15:44:21 <Saizan_> daedra: maybe you've to install xmonad-contrib ? (if that's the right name)
15:44:48 <dcoutts_> SamB: runghc Setup install is not a package in the sense of a package manager
15:45:17 <SamB> dcoutts_: and ???
15:45:37 <dcoutts_> SamB: runghc Setup install --destdir=image =~ make install DESTDIR=image  is the right equivalence
15:45:42 <daedra> Saizan_: nope wasn't the problem, although I didn't have the package
15:46:28 <SamB> dcoutts: I still think this is going to be too confusing
15:46:44 <Saizan_> daedra: there's also #xmonad, which might answer better
15:46:45 <dcoutts_> SamB: and it's important we have that layer since it's what all the native distro packages build scripts use
15:48:01 <dcoutts_> SamB: it might be useful for informational purposes for ghc-pkg to record which agent registered the package
15:50:57 <SamB> dcoutts: damnit, how am I supposed to do this without using Control.Monad.Writer?
15:51:14 <dcoutts_> SamB: :-) use lists I guess
15:51:39 <dcoutts_> SamB: not being able to use mtl is a pain sometimes
15:52:07 <Saizan_> define it?:)
15:52:14 <ddarius> For some reason, I never use the Writer monad
15:52:24 <dcoutts_> SamB: but actually most of that code should be pure, most of the IO in there is due to copying files
15:53:05 <dcoutts_> when the only IO is searching then it should be possible to do that up front and then gather the file lists together purely
16:11:15 <dons> Beelsebob: nbody has well known parallel implementations.
16:11:21 <dons> though that'll need a rewrite.
16:25:29 <dons> Beelsebob: halve running time in k-nucleotide by giving GC hints too.
16:25:41 <dons> general rule: look for programs doing more than 5% GC, give heap hints.
16:26:39 <gwern> I have a question - why can'
16:26:39 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
16:26:54 <gwern> t I replace fmap :: (Functor f) => (a -> b) -> f a -> f b with (parMap rnf) :: (NFData b) => (a -> b) -> [a] -> [b] ?
16:27:20 <gwern> the type sigs look the same to me
16:27:32 <Saizan_> the same?
16:27:38 <Saizan_> NFData b
16:28:12 <Saizan_> assuming f == [] holds
16:28:55 <olsner> similar /= same :)
16:29:27 <chrisdone> hmm. it seems laziness is causing oddness with runInteractiveCommand. admittedly I am using it about 1000 times repeatedly, but what is happening is the stdout from the launched process is being displayed inside ghci
16:29:55 <sjanssen> @hoogle runInteractiveCommand
16:29:55 <lambdabot> System.Process runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
16:30:01 <chrisdone> http://hpaste.org/10080
16:30:06 <sjanssen> chrisdone: are you closing your handles?
16:30:54 <sjanssen> chrisdone: you're probably hitting your operating system's limit on open file descriptors
16:31:05 <dcoutts_> chrisdone: that code is not right, but for other reasons
16:31:07 <chrisdone> I guess I'm not closing hOut which I guessed would be garbage collected and closed automagically
16:31:13 <chrisdone> dcoutts_: why is it not right?
16:31:31 <dcoutts_> chrisdone: you'd better be pretty sure that you're only ever going to send the process 4k or less
16:31:34 <FunctorSalad> by the way, are totally naive idea: recently there was a discussion here about the perils of nondeterministic IO. couldn't you just make the ordering constraints explicit?
16:31:35 <dcoutts_> chrisdone: or it'll block.
16:31:49 <FunctorSalad> (or maybe that exists already)
16:32:01 <dcoutts_> chrisdone: in fact 4k might not even be a posix minimum guarantee.
16:32:17 <chrisdone> well, it's more like 512 bytes tops
16:32:21 <dcoutts_> chrisdone: you need to interleave pushing the input to the process with pulling on the output.
16:32:44 <chrisdone> how do I do that?
16:32:47 <dcoutts_> chrisdone: and the easiest way to do that is to forkIO $ putStr hIn text
16:32:57 <dcoutts_> erm
16:33:07 <dcoutts_> chrisdone: forkIO $ putStr hIn text >> hClose hIn
16:33:21 <chrisdone> dcoutts_: why is interleaving it necessary?
16:33:34 <dcoutts_> chrisdone: you've also got to be similarly careful with the output and error
16:33:34 <dmwit> It depends on the application.
16:34:24 <dmwit> dcoutts_: Even with lazy hGetContents?
16:34:38 <dcoutts_> dmwit: hmm, maybe that's ok.
16:34:49 <chrisdone> why is interleaving it necessary?
16:34:56 <dcoutts_> chrisdone: it depends on when the program produces output relative to consuming input.
16:35:12 <dcoutts_> chrisdone: and there's only a small pipe buffer
16:35:40 <dmwit> chrisdone: You're only allowed a certain backlog on each of in, out, and err.
16:35:44 <dcoutts_> chrisdone: consider what would happen if there was a pipe buffer of only 1 character.
16:35:59 <dcoutts_> apart from performance being horrible
16:36:52 <dcoutts_> it means you cannot expect to push two characters in sequence to the process without checking if the process wants to produce output before it'll accept new input
16:37:20 * gwern frowns. replacing fmap with parMap has proven unexpectly challenging
16:37:35 <dcoutts_> chrisdone: the problem still exists as you use a bigger pipe buffer, just happens less frequently
16:38:07 <dcoutts_> dmwit: I think you're right hGetContents on both the err and out is ok.
16:38:39 <dcoutts_> dmwit: hmm, actually no. it's not ok.
16:38:58 <dcoutts_> dmwit: you'd have to demand both in parallel
16:38:59 <dmwit> Yeah, you have to be careful about the order you force the resulting strings.
16:39:01 <chrisdone> dcoutts_: oh I see
16:39:33 <dcoutts_> dmwit: I don't think there's any static order you could use
16:39:45 <dmwit> right
16:39:56 <dmwit> (Unless you know more about the particular program in question, of course.)
16:40:00 <dcoutts_> right
16:40:09 <dcoutts_> so again, you need forkIO $ hGetContents
16:40:16 <dmwit> That won't work.
16:40:19 <dmwit> :t forkIO
16:40:21 <lambdabot> Not in scope: `forkIO'
16:40:29 <dmwit> forkIO :: IO a -> IO () -- isn't it?
16:40:34 <chrisdone> mvars etc :\
16:40:38 * dmwit nods
16:40:45 <dcoutts_> dmwit: you'd need:
16:40:46 <chrisdone> then again
16:40:52 <chrisdone> forkIO hPutStr
16:41:46 <dcoutts_> dmwit: out <- hGetContents hout; err <- hGetContents hout; forkIO (evaluate $ length err); evaluate (length out)
16:42:23 <gwern> http://hpaste.org/10082#a1 <-- ideas about how to do parallelism here?
16:42:55 <dcoutts_> chrisdone: for reference, see rawSystemStdout in Cabal's Distribution/Simple/Utils.hs
16:43:21 <dcoutts_> chrisdone: and use runInteractiveProcess not Command
16:43:25 <dmwit_> Yeah, the evaluate thing could work.
16:43:44 <dmwit_> Assuming forkIO does the Right Thing with regards to blocking.
16:43:51 <dcoutts_> dmwit_: it's what rawSystemStdout in Cabal uses and it seems to work and JaffaCake 'ack'ed it
16:44:42 <dmwit> 'ack'ed?
16:44:54 <dcoutts_> dmwit: checked it and said it was ok
16:45:01 <dmwit> ah
16:45:04 <dmwit> Cool! =)
16:45:14 <mmorrow> haha, a C QuasiQuoter: http://code.haskell.org/~morrow/code/haskell/c-qq/
16:45:15 <lambdabot> Title: Index of /~morrow/code/haskell/c-qq
16:45:25 <mmorrow> which needs this package: http://code.haskell.org/~morrow/code/haskell/th-utils/
16:45:26 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
16:45:29 <mmorrow> lol
16:45:33 * gwern dunno what to do about that type error. it looks right - a parallel map of a lifted pure function
16:45:49 <gwern> how does one reconcile [m Bytestring] with IO Bytestring?
16:45:57 <dmwit> sequence
16:46:02 <mmorrow> (it doesn't allow splicing of haskell vars into the C yet..)
16:46:38 <gwern> @hoogle sequence
16:46:38 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
16:46:38 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
16:46:38 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
16:47:41 <chrisdone> heh, Utils.hs reads like a reverse usenet display
16:48:38 * chrisdone tries it
16:49:02 <guenni> are there alternatives to the bytestring package?
16:49:15 <dcoutts_> guenni: what kind of alternatives are you thinking of?
16:49:41 <Toxaris> @type "there are ordinary strings"
16:49:43 <guenni> for serialization
16:49:43 <lambdabot> [Char]
16:49:57 <gwern> Data.Binary?
16:50:37 <guenni> gwern: well that use Bytestring under the hood and is actually my problem
16:50:54 <dmwit> gwern: ...but if your [m ByteString] came from a map, then mapM is the preferred spelling.
16:50:54 <dcoutts_> guenni: what is the problem?
16:51:10 <dons> for serialisation, there's slower Read/Show
16:51:14 <dons> there's also xml if you're keen ...
16:51:23 <Twey> Heheh
16:51:25 <guenni> well what I do want to serialize is a really large list
16:51:34 <dons> ah, so you're hitting the strict list instance
16:51:41 <dons> you'll need a lazy serializer.
16:51:57 <dons> I wonder if we should just add Lazy [a] as a newtype , dcoutts_
16:52:02 <dons> since this is the number one user complaint
16:52:05 <gwern> @do uncurry proc =<< clines `fmap` S.getContents
16:52:05 <lambdabot> uncurry proc =<< clines `fmap` S.getContents not available
16:52:09 <dons> "oi! my big list done gone stack overflowed"
16:52:10 <guenni> yep, I did manage to write a work around but I'm still not happy with it
16:52:25 <gwern> hm. what is the undo of undo? :)
16:52:28 <dons> well, the normal way is to serialise using a chunked encoding.
16:52:30 <dcoutts_> dons: I think the answer is to do a lazy chunked encoding by default
16:52:35 <ddarius> gwern: redo
16:52:37 <guenni> cause the probblem also occurs where you want to serialize a very large String
16:52:43 <dmwit> gwern: redo
16:52:43 <gwern> @redo uncurry proc =<< clines `fmap` S.getContents
16:52:43 <lambdabot> uncurry proc =<< clines `fmap` S.getContents
16:52:45 <dcoutts_> dons: with adaptive chunk size, depending on the size of the output
16:52:45 <chrisdone> @hoogle Verbosity
16:52:45 <lambdabot> module Distribution.Verbosity
16:52:45 <lambdabot> Distribution.Verbosity data Verbosity
16:52:45 <lambdabot> Distribution.Simple.Setup buildVerbosity :: BuildFlags -> Flag Verbosity
16:52:49 <gwern> ....
16:52:49 <SamB_XP> dcoutts: not soon
16:52:53 <gwern> gee thanks lb
16:53:06 <dmwit> err...
16:53:11 <SamB_XP> dcoutts: first comes the deprecation, then the breaking, THEN the different semantics
16:53:18 <dmwit> ?redo clines `fmap` S.getContents >>= uncurry proc
16:53:19 <lambdabot> do { a <- clines `fmap` S.getContents; uncurry proc a}
16:53:19 <dcoutts_> SamB_XP: ah :-)
16:53:23 <dons> dcoutts_: how do we work out the size lazily? fibonacci chunking?
16:53:35 <dmwit> gwern: It apparently doesn't know =<<. =P
16:53:39 <dons> strictly take N, then double , then ...
16:53:41 <gwern> @redo uncurry proc =<< (fmap) clines S.getContents
16:53:41 <lambdabot> uncurry proc =<< (fmap) clines S.getContents
16:53:56 * olsner thinks something clever about data structures and undo behaviours but is too lazy to put it into witticism
16:54:17 <guenni> so, any alternatives to those 2 packages?
16:54:37 <dcoutts_> dons: we write one element, if there's still space in the current buffer we write another etc. When we're about to flush the buffer we write the number. A chunk with 0 elements terminates.
16:54:47 <dons> guenni: well, what are you trying to do? a lazy Data.Binary instance will be the best choice, basically.
16:55:31 <guenni> dons: as I said whenever I'm dealing with a list (which for instance a string is) it blows up
16:55:48 <dons> right, because you're not using a lazy instance for Binary [a]
16:56:00 <dons> the alternative is to switch to a lazy instance.
16:56:06 <ChilliX_> Hi dons, hi dcouts
16:56:07 <dons> i'll write one for you :)
16:56:11 <dcoutts_> hia ChilliX_
16:56:13 <dons> yo ChilliX_
16:56:24 * ChilliX_ wonders, why the _ at the end of the nickl
16:56:30 <ChilliX_> nick*
16:56:32 <guenni> dons: serious?
16:57:25 <dons> sure.
16:57:37 <SamB_XP> ChilliX_: connectivity
16:57:37 <chrisdone> dcoutts_: any idea how one constructs a value of type Verbosity?
16:57:58 <dons> guenni: how big is your list?
16:58:05 <dcoutts_> chrisdone: import qualified Distribution.Verbosity as Verbosity; Verbosity.normal
16:58:16 <dons> guenni: and are you compiling the code (e.g. ghc -O2 Foo.hs --make)
16:58:27 <dcoutts_> chrisdone: or get it as input from another source
16:58:42 <dcoutts_> chrisdone: or convert it from a verbosity number given as user input
16:58:43 <ChilliX_> SamB_XP: It seems to have connected me as ChilliX first, then dropped out and connected again, finding the original name taken.  But why drop out....
16:58:51 <chrisdone> dcoutts_: ahh, functions. thanks
16:59:12 <SamB_XP> ChilliX_: what, right away?
16:59:20 <ChilliX_> SamB_XP: seems so
17:00:11 <dons> guenni: i'd need to see what kind of encoding your doing, since naively, serialising a list just allocates a big list, and shouldn't overflow any stacks
17:00:34 <Plareplane> is there a reason the index on rwh lists appendices b, c, and d instead of a, b, and c?
17:00:41 <Plareplane> by index i mean table of contents
17:00:51 <dons> Plareplane: hm
17:00:57 <dons> well spotted, Plareplane
17:01:08 <dons> if you can determine the encoding, you win a lolly.
17:01:55 <dcoutts_> dons: hmm, is it binary coded decimal?
17:01:59 <dons> heh
17:02:07 <mauke> is it WTF-8?
17:02:13 <dcoutts_> hah hah
17:02:15 <mmorrow> haha
17:02:36 <guenni> dons: the list has about 80K of records which I construct from parsing an XML file lazily
17:02:46 <guenni> guenni: using HaXml
17:02:58 <dons> oh, pretty small.
17:03:04 <dons> do you compile it then?
17:03:10 <guenni> 80K as in 80.000 records
17:03:14 <ddarius> Is it bos, CosmicRay, dons?
17:03:50 <dons> guenni: i'd not expect a stack overflow, anyway.
17:04:06 <dons> the list instance simply takes the length of the list, which will cause memory exhaustion in the heap
17:04:17 <guenni> well the swap file got bigger and bigger
17:04:33 <dons> guenni: oh, so it didn't stack overflow, but did allocate a lot?
17:04:42 <dons> ok. i'll give you a lazy serialiser.
17:04:43 <guenni> dons: correct
17:04:59 <guenni> dons: love and kisses
17:06:55 <guenni> dons: I mean I did find that code for the list and wrote some sort of wrapper instead serializing chunk wise of 100 items with the help of new type and it did actually work
17:07:19 <guenni> dons: but as soon as Strings came along ....
17:07:46 <dons> http://hpaste.org/10083
17:07:59 <dons> so yeah. you might want to do Lazy String too
17:08:15 <dons> dcoutts_: so maybe benchmark that, and rely in compression to clean up the encoding?
17:08:40 <dcoutts_> dons: the encoding should still be pretty tight
17:08:54 <dcoutts_> dons: but it's rather more subtle code
17:09:09 <ddarius> dcoutts: ?
17:09:14 <dons> yeah, we've not tried chunked encodings.
17:09:19 <dons> only the naive tagging one, and the strict one.
17:09:30 <dcoutts_> ddarius: hmm?
17:09:44 <ddarius> dcoutts: What is rather more subtle code?
17:09:47 <dons> so you want to serialise exactly as eagerly as lazy bytestring chunks?
17:09:56 <dons> fill buffers from the list, suspend?
17:10:08 <guenni> dons: thx, a lot, no "get" needed?
17:10:17 <dons> guenni: well, if you want  to read it back in , yes :)
17:10:19 <dcoutts_> dons: the chunking would be determined by the free space in the output buffer
17:10:23 <dons> yep
17:10:33 <dons> and you'd suspend on the first buffer full?
17:10:43 <guenni> dons: uhm, I might?
17:10:55 <dcoutts_> dons: right, something like that. I've not got all the details worked out.
17:10:57 <ddarius> How do you get access to the size of the free space in the output buffer?
17:11:01 <dons> dcoutts_: so a length-prefixed, eager encoding.
17:12:10 <dcoutts_> dons: yes, of chunks that roughly correspond to buffer size.
17:12:28 <dcoutts_> ddarius: inside the impl one can do anything :-)
17:12:51 <dons> dcoutts_: btw, i was thinking bytestring's should have a compile time chunk size flag. we could even script the test, to specialise per-machine.
17:13:46 <dcoutts_> dons: hmm, I'd be surprised if there was much variance between machines, but it's worth checking
17:14:04 <dons> well, cache sizes vary a lot
17:14:09 <dons> and that was originally an issue.
17:14:25 <dcoutts_> dons: but most operations do not actually need the full chunk in cache at once
17:14:26 <dons> my core2 has what, a 4M cache?
17:14:35 <ddarius> class ChunkSize c where chunkSize :: c -> Int; data KB64; instance ChunkSize KB64 where chunkSize _ = 65536; ... ByteString KB64
17:14:36 <dons> while the original laptop i used had 256k
17:15:01 <dcoutts_> dons: we're mostly doing linear traversals, not random reads, so the cache size is not that important I think
17:15:15 <dcoutts_> we do not need the current chunk to all be in cache at once
17:19:40 <guenni> dons: this is what I had come up with: http://hpaste.org/10084
17:20:03 <guenni> dons: ie. my work around
17:21:30 <guenni> it did work but would fail awfully if there were lists of lists
17:22:22 <guenni> dons: what was the reason to make an instance of Binary / List non-lazy?
17:22:38 <guenni> dons: just curious
17:22:51 <dcoutts_> guenni: it significantly increases then encoded size
17:22:56 <dcoutts_> then/the
17:23:11 <dcoutts_> using the lazy encoding I mean, vs the simple length prefix
17:23:45 <guenni> because you'd have to write gos and stoppers
17:23:59 <dcoutts_> guenni: right
17:24:06 <guenni> dcoutts_: I mean markers
17:24:17 <guenni> dcoutts: Ic
17:26:06 <guenni> dcoutts_: the whole problem started when ghc would blow while compiling a huge data structure in literal haskell
17:26:49 <guenni> I hadn't expected that and then quicksilver pointed me to: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014385.html
17:26:51 <lambdabot> Title: static constants -- ideas?, http://tinyurl.com/6mshve
17:27:09 <guenni> which did help
17:27:34 <guenni> until it also got screwy ... :)
17:30:40 <guenni> dons, dcoutts_ so is the books still on schedule?
17:31:14 <dons> this one http://book.realworldhaskell.org/ ?
17:31:22 <guenni> yep
17:31:28 <dons> or the secret book duncan and I are writing about "ByteString internals revealed!"
17:31:29 <lambdabot> Title: Real World Haskell
17:31:33 <dcoutts_> guenni: you're confusing me for one of the authors, it's dons, bos and CosmicRay
17:31:50 <dons> 'Fusion rules for dummies!'
17:32:05 <dons> 'Practical array fusion for C++'
17:32:11 <guenni> sry then dcoutts_
17:32:45 <mauke> dons: ARGH
17:32:56 <guenni> dons: I'd like to get a copy of that one too then
17:33:21 <dons> heh
17:33:25 <Botje> 'pragmatic C++ template metaprogramming'
17:33:32 <Botje> i can see this catching on.
17:33:32 <guenni> dons: so is it on schedule?
17:33:34 <Igloo> Arg, GHC is determined to make me use unsafeCoerce
17:34:13 <tp|away> *cue ominous music*
17:34:16 <dons> guenni: sure. its out of our hands now.
17:34:22 <dons> in production.
17:34:29 <dons> land in the stores in november.
17:34:42 <guenni> excellent
17:34:46 <dmwit> http://www.youtube.com/watch?v=gMEhescEBaE -- tp|away  done and done
17:34:47 <lambdabot> Title: YouTube - Flobots - Handlebars
17:34:57 <Botje> they're silently rewriting all examples in visual basic and releasing it as "advanced visual basic"
17:35:03 <guenni> it just might safe me from going back to wood work :)
17:35:05 <Botje> BUT DON'T TELL THE AUTHORS
17:36:03 <Botje> sorry, i'm tired.
17:36:06 <Botje> i'll go to bed now :)
17:36:39 <mauke> http://www.getacoder.com/projects/programming_c_87390.html
17:36:45 <lambdabot> Title: Programming In C C++ (C++ / C, Programming, Visual Basic)
17:37:32 <guenni> Botje: slaap lekker
17:37:55 <tp|away> dons: why does increasing the default heap size make the program in your post on -cafe run faster? does allocation and (appropriately) garbage collection only happen if the memory needed goes beyond the default heap size?
17:38:34 <tp|away> i.e. if all allocations can fit on the heap, GC is not an issue?
17:43:08 <dons> yeah
17:43:15 <dons> makes it seems like there's less heap pressure. so less GC
17:44:22 <elliottt> dons: what's the name of the darcs to git converter that was used on the ghc tree?
17:45:33 <dons> elliottt: its on github, dont' recall the name
17:45:52 <elliottt> dons: thanks :)
17:45:56 <tp|away> there's darcs2git
17:46:13 <tp|away> but iirc, there was a version like that which was piss-ass slow
17:46:18 <tp|away> and then a version actually built on top of darcs
17:46:51 <tp|away> i think nominolo would know where the 'fast' one is
17:48:40 <tp|away> elliottt: i think this is what you're looking for
17:48:41 <tp|away> http://int-e.home.tlink.de/haskell/git-darcs-import-0.1.tar.bz2
17:49:37 <Armored_Azrael> Does anyone have an example of a use case for the "Other-Modules" field in an executable build section of a cabal file?
17:49:47 <Armored_Azrael> I'm mostly just curious what that would be needed for.
17:49:50 <tp|away> elliottt: http://git.sanityinc.com/?p=darcs-to-git.git;a=tree <-- that's written in ruby, and http://repo.or.cz/w/darcs2git.git?a=shortlog <-- that's written in python apparently
17:49:56 <lambdabot> Title: sanity, inc. gitweb - darcs-to-git.git/tree
17:49:58 <tp|away> so yeah, both are probably going to be pretty slow past a certain repo size
17:50:01 <dons> no, he wants the haskell one.
17:50:10 <tp|away> yeah, which is 'git-darcs-import-0.1'
17:50:27 <tp|away> which apparently has no other ann or link anywhere, than somewhere on the mailing lists in june
17:50:58 <tp|away> ah wait - repo.or.cz/w/git-darcs-import.git
17:51:00 <tp|away> that's the one :]
17:52:31 <dcoutts> Armored_Azrael: it's needed for sdist and it's needed if you use any pre-processors.
17:52:57 <Armored_Azrael> Ah. Thanks.
17:54:48 <dons> hehe, there's this 'python multiprocessing package' story on reddit, just a link to the python queues + threads library. so here's a link to the haskell multiprocessing package
17:54:51 <dons>  http://www.reddit.com/r/programming/comments/6z4o1/haskells_high_level_mulltiprocessing_package/
17:54:53 <lambdabot> Title: Haskell's high level mulltiprocessing package : programming, http://tinyurl.com/6l8vo4
17:55:34 <tp|away> silly global locks!
17:56:02 <Olathe> Global locks are excellent for keeping the air from being sucked out of your planet.
17:57:01 <Moosefish> is there an easy way to look at the graph structure of the thunks of a running haskell program? Meaning, I'd like to snapshot the heap and pass it through some moral equivalent of graphviz
17:57:28 <Myoma> Moosefish: that would be so cool if it was animated :)
17:57:32 <ddarius> Moosefish: No.  You could try Hat or GHood but...
17:58:02 <ddarius> dons: That's only a tiny part of Haskell's "multiprocessing package"
18:01:32 <dons> ddarius: yeah, indeed, we need a comprehensive guide to exploiting multicores.
18:01:51 <dons> "Concurrent and Parallel Haskell: the book"
18:04:37 <mauke> "ocretadPrle akl:teboCunnalHe  kn ashrlo l"
18:05:02 <dmwit> heh
18:05:30 <dmwit> > sort "Concurrent and Parallel Haskell: the book" == sort "ocretadPrle akl:teboCunnalHe  kn ashrlo l"
18:05:35 <lambdabot>   True
18:05:39 <jeffwheeler> @pl \n -> n ^ n
18:05:40 <lambdabot> join (^)
18:05:45 <mauke> mapM_ (forkIO . putChar)
18:09:31 <mmorrow> > downsidup "Concurrent and Parallel Haskell: the book"
18:09:36 <lambdabot>    ûooq «ù…• á :ll«ù ûs…êH l«ùll…ê…π…êP pu…ê  áu«ù…π…πn…îuoC
18:09:44 <seydar> holy crap
18:09:56 <seydar> whooooooa
18:10:04 <mmorrow> > downsidup "holy crap whooooooooa"
18:10:09 <lambdabot>   …êoooooooo…• ç b…ê…π…î  élo…•
18:10:11 <mmorrow> heh
18:10:20 <seydar> bind, >>=, will that "unwrap" a monad and pass the sandwich value to the second function?
18:10:22 <mmorrow> damn, p's are messed up
18:10:26 <seydar> ie, getChar >>= putChar
18:10:30 <Twey> Haha, downsidup
18:10:34 <Twey> Yes, seydar
18:10:49 <mmorrow> upsidown is already defined with a messed up internal func, so ...
18:10:49 <Myoma> "sandwich value"? :D
18:10:50 <seydar> Twey: coolio, kaj dankon!
18:10:57 <seydar> Myoma: yea, sandwich value
18:11:06 <seydar> Twey: how do we get that quote that was remembered?
18:11:13 <Twey> Cxu vi estas esperantisto?
18:11:23 <Twey> Which quote?
18:11:25 <seydar> Twey: esperantisteto, jes
18:11:31 <seydar> "monads are just like saran wrap"
18:11:34 <Twey> Oh, haha
18:11:37 <Twey> @quote saran
18:11:37 <lambdabot> No quotes match. Do you think like you type?
18:11:39 <Twey> :(
18:11:47 <seydar> @quote seydar
18:11:47 <lambdabot> No quotes match. Are you on drugs?
18:11:51 <Twey> I don't know \b's wizardry
18:12:01 <SamB_XP> seydar: apparantly lambdabot is a lier
18:12:01 <mmorrow> main = putStr . unlines . zipWith (++) (map show [0..]) . lines =<< getContents  -- number lines in a file
18:12:02 <mauke> > flap "Concurrent and Parallel Haskell: the book"
18:12:07 <lambdabot>   "\670ooq \477\613\647 :ll\477\670s\592\613 l\477ll\592\633\592d pu\592 \647...
18:12:13 <SamB_XP> @quote saran wrap
18:12:13 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
18:12:14 <mmorrow> say is jacked
18:12:17 <mauke> > say . utf8s . flap $ "Concurrent and Parallel Haskell: the book"
18:12:19 <Myoma> @hoogle lines
18:12:19 <lambdabot> Prelude lines :: String -> [String]
18:12:19 <lambdabot> Data.List lines :: String -> [String]
18:12:19 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
18:12:21 <lambdabot>    ûooq «ù…• á :ll«ù ûs…ê…• l«ùll…ê…π…êd pu…ê  áu«ù…π…πn…îuo…î
18:12:28 <mmorrow> > sayy "\8704" -- but sayy isn't ;)
18:12:33 <lambdabot>   ‚àÄ
18:12:45 <seydar> > sayy "hello"
18:12:49 <seydar> poopy
18:12:50 <lambdabot>   hello
18:12:56 <seydar> oh, hello
18:13:12 <seydar> > downsidup "Twey"
18:13:17 <lambdabot>    é«ù çT
18:13:25 <seydar> T-s are messed up too
18:13:27 <SamB_XP> ???
18:13:29 * Twey nods.
18:13:40 <mmorrow> the 'p's are messed up in downsidup
18:13:47 <seydar> Twey, how long have you been haskellizing?
18:13:55 <Twey> A few months, seydar
18:14:31 <Twey> I came across it ages ago, but balked at monads for a long time :)
18:14:39 * Twey vanishes for a bit.
18:15:09 <seydar> there is hope!
18:15:09 <dmwit> mmorrow: main = spawn "nl" -- better way to number lines in a file
18:15:20 <mmorrow> heh
18:15:39 <mmorrow> main = spawn "halt"  -- a better way to shutdown
18:15:59 <dmwit> seydar: It's more like (>>=) puts its second (function) argument *into* the monad.
18:16:09 <dmwit> i.e. there is no escaping a monad... only shoving more things in.
18:16:39 <seydar> thats the beauty of it though! GHC is like your mom
18:16:42 <Pseudonym> Twey, cxu ni deve kreas #haskell-eo?
18:16:49 <seydar> and unwraps your sandwiches for you
18:17:49 <seydar> Pseudonym: jes, certe
18:18:34 <Pseudonym> Universala programara lingvo bezonas universalan lingvon.
18:22:47 <Olathe> Eww.
18:23:02 <seydar> Olathe, if you bust out lojban on us...
18:23:41 <Olathe> Oh, no, that was Eww as in Eww, Esperanto.
18:23:48 <Olathe> Lojban, too.
18:24:55 <|Steve|> Universal programmer language good universal language?
18:25:24 <seydar> a universal programming language needs a universal language
18:25:43 <|Steve|> Ah.
18:25:47 <Pseudonym> Esperanto admittedly makes more sense if you translate it back into the original Polish.
18:26:32 <seydar> do you speak polish?
18:26:37 <Pseudonym> Nope.
18:28:24 <seydar> when did you get your esperanto book?
18:28:47 <Pseudonym> Uhm... about 1986.
18:29:04 <seydar> wait, didn't you say you hadn't studied esperanto ever?
18:29:06 <Pseudonym> It's been a while.
18:29:18 <|Steve|> That's like never.
18:29:27 <Pseudonym> Not really.I just picked stuff up form the book and occasonally hanging around on #esperanto.
18:29:35 <seydar> good point.
18:29:51 <seydar> hanging around there works my brain a lot
18:30:00 <seydar> i tihnk i'll stop coding for the nighit and chill there
18:30:23 <Pseudonym> One thing I didn't pick up in the 80s was the slang.
18:30:29 <Pseudonym> Like "krokodili".
18:30:31 <Myoma> learning a programming language and a spoken language are two completely different things aren't they?
18:30:50 <|Steve|> Yes. One is easy, the other is hard.
18:30:56 <Pseudonym> Larry Wall would be proud.
18:31:07 <|Steve|> Well, if you're over 15, one is easy, the other is hard. If you're under 15, they swap.
18:31:27 <Pseudonym> Myoma: Programming languages and spoken languages are more similar than they are different.  The main difference is the size of the vocabulary.
18:31:32 <|Steve|> (Actually, I don't know what the cut off is for little kids learning languages.
18:31:54 <|Steve|> )
18:31:56 <Pseudonym> We still talk about syntax, semantics, pragmatics, context etc.
18:35:51 <Twey> Pseudonym: Ni devas sed mi estas lojxbanisto kaj ne esperantisto :)
18:36:18 <Adamant_> Interlingua FTW!
18:36:34 <Pseudonym> Klingon FTL!
18:36:49 <dmwit> English FTConfusing!
18:37:06 <Adamant_> EnglishFTInternationalWordThief
18:37:21 <Pseudonym> That's one of its strengths.
18:37:24 <Adamant_> it is
18:37:31 <Pseudonym> No Academie to prevent adding words as needed.
18:37:33 <ddarius> Adamant_: Along with every other major language, though English is probably the worst offender.
18:37:50 <Adamant_> ddarius: most of those languages are borrowing the words from English. ;)
18:38:22 <Adamant_> but the downside is that spelling and grammar are insane
18:38:23 <Pseudonym> Only English could make a distinction between "pig" and "pork".
18:38:43 <Twey> Well, Spanish does the same for 'fish' and... er... 'fish'.
18:38:53 <ddarius> Adamant_: So?  Now what is funny (is because it is very likely the case) is that there are loanwords in a non-English language that are based off loanwords from the borrowing language.
18:38:59 <seydar> Pseudonym: but its interesting how that is
18:39:07 <seydar> anglo-saxon or french?
18:39:08 <Pseudonym> :-)
18:39:16 <seydar> the french is once its prepared
18:39:17 <Pseudonym> That's right, it's Saxon and Norman French.
18:39:23 <seydar> saxon is for the animal
18:39:27 <Twey> Pez vs. pescado
18:39:30 <Pseudonym> The Normans didn't deal with the animals.
18:39:47 <Adamant_> ddarius: English steals the words, then other languages steal them again!
18:39:58 <Twey> ... and the languages they
18:40:09 <Twey> came from stole them in the first place, &c., &c.
18:40:10 <Adamant_> it's a great cycle of mutually beneficit thievery
18:40:14 <Twey> To the beginning of time!
18:40:31 <Pseudonym> Proto-World FTW!
18:40:40 <Adamant_> actually I do have a question on English
18:41:09 <Adamant_> do other languages have "sublanguages" for technology and science like English uses Latin and Greek?
18:41:21 <ddarius> Adamant_: Yes
18:41:30 <Olathe> I think most languages use the fake Latin for biology.
18:41:32 <Twey> Most Latinate languages use Latin for the same purposes as English
18:41:36 <Olathe> Japanese borrows a lot of words.
18:41:41 <Pseudonym> All languages which have science, engineering or anything that requires precision use technical jargon.
18:41:49 <Twey> Other languages tend to use English borrowings for technology.
18:41:51 <Olathe> It has an alphabet specifically for borrowed words.
18:41:57 <Twey> Well
18:42:04 <Twey> That's not quite true
18:42:04 <SamB> Olathe: and sfx
18:42:07 <Adamant_> yeah, I know obviously Romance languages have no problem with Latin
18:42:10 <Olathe> Yes :)
18:42:20 <Twey> That's what it's used for today
18:42:23 <Twey> It's older than that, though
18:42:43 <Twey> During WWII, all official documents were written in katakana
18:42:54 <Olathe> Why ?
18:42:54 <Adamant_> also, what's so cool about Hangul?
18:43:28 <Twey> Olathe: Because
18:43:40 <Twey> Never ask why a language does something :-P  There's rarely a good reason
18:43:52 <SamB> Olathe: I guess the military was illiterate!
18:43:52 <Twey> Adamant_: Uhm
18:43:59 <Twey> Lots, if you like Koreans?  :-P
18:44:16 <Adamant_> I just hear stories of Chinese engineers lapsing into English to do technical stuff then going back to Chinese for the rest of the conversation, and I wonder why the Chinese never had a technical sublanguage
18:44:44 <Pseudonym> It probably does, but it's easier to work with engineering stuff written in English.
18:44:44 <SamB> Adamant_: well, they used to use chinese for it
18:44:59 <SamB> but then they took all this technology from us english speakers
18:45:05 <dmwit> English is a Chinese sublanguage.
18:45:08 <Pseudonym> China used to have a big NIH thing going on.
18:45:14 <SamB> and swallowed the vocabulary whole
18:45:20 <Pseudonym> I think they're mostly over that now.
18:45:25 <Adamant_> Twey: Koreans are OK, but I meant more the language and writing
18:45:26 <Olathe> English is the work of SATAN !
18:45:37 <Adamant_> English is present from Santa
18:46:05 <Olathe> Ahh, so Satan is one of Santa's elves.
18:46:12 <SamB> I guess they don't learn the entire language, they probably couldn't enjoy many old novels
18:46:13 <Adamant_> no
18:46:17 <SamB> or historical ones
18:46:39 <Adamant_> SamB: I think some Taiwanese people think that is deliberate
18:46:49 <SamB> Adamant_: hmm?
18:47:10 <SamB> deliberate on who's part?
18:47:19 <Adamant_> modern more simplified Chinese being a hard bridge to older forms of Chinese
18:47:29 <Adamant_> the Communist government
18:47:41 <SamB> oh, I was speaking of the English language actually
18:47:43 <Adamant_> ah
18:47:56 <Plareplane> i'm under the impressioned that educated people can read both traditional and simplified script with only a little bit of trouble and headscratching
18:47:57 <SamB> and I don't think anyone is deliberately restricting access to any of that
18:48:23 <Adamant_> well you can puzzle English out back until Middle English
18:48:28 <SamB> it's just that there's so damn much *of* it
18:48:49 <Twey> If you know a bit of German you can go back to Old English
18:48:54 <SamB> and the only way I know to learn as much as I have is to read a massive amount of novels ;-)
18:49:19 <Adamant_> though Old English is incomphrensible, but makes a nice furniture polish and refreshing alchoholic beverage to curl up on the sidewalk with
18:49:46 <SamB> what's middle english like?
18:49:48 <Pseudonym> Germans don't use blackletter any more.
18:49:59 <Lycurgus> i understand yueh/cantonese is closer to the language of the classics
18:50:10 <Lycurgus> you mean Fraktur?
18:50:19 <SamB> fraktur is one blackletter font
18:50:21 <Adamant_> 1 million English words, 500,000 currently used, 500,000 not used but might be revived at any time
18:50:28 <Pseudonym> Like SamB said.
18:51:01 <SamB> Adamant_: how did you count them?
18:51:07 * FunctorSalad likes that english hardly uses genders
18:51:08 <Adamant_> SamB: I didn't
18:51:14 <Adamant_> experts did
18:51:17 <SamB> Adamant_: so ... you just made it up?
18:51:21 <Adamant_> using their expert methods
18:51:21 <FunctorSalad> thousands of arbitrary choices to learn :(
18:51:22 <Lycurgus> i've always heard that 1 million figure
18:51:29 <Adamant_> nah it's a real published statistic
18:51:37 <SamB> oh, so experts made it up
18:51:42 <Pseudonym> Which means it must be true!
18:51:43 <Lycurgus> never seen a source for it or heard that half were archaic
18:51:43 <Adamant_> yeah I guess
18:51:50 <Pseudonym> 87.6% of statistics are made up.
18:51:56 <Lycurgus> would make sense that chinese had more
18:52:02 <Olathe> > length $ nub $ words $ allEnglishText
18:52:06 <lambdabot>   mueval: Prelude.read: no parse
18:52:16 <SamB> I don't pretend to know how many English words there are, but there are an awful lot that get very little current use
18:52:19 <Lycurgus> since with archaics there are 30-50K characters
18:52:39 <Lycurgus> and words can be 1,2,3 or rarely 4 characters
18:52:59 <Lycurgus> but have always heard english has most words
18:53:25 <Myoma> @w80 tintinabulation
18:53:31 <FunctorSalad> it seems to have a high friendlytude to making up words
18:53:36 <SamB> indeed
18:53:40 <Myoma> :#
18:53:40 <lambdabot> Error: thread killed
18:53:44 <SamB> you just made that one up, for instance ;-P
18:53:58 <FunctorSalad> ;)
18:54:01 <Myoma> @w80 frop
18:54:05 <Lycurgus> was that Phillpa?
18:54:16 <lambdabot> Error: thread killed
18:54:25 <Olathe> @w80 thread killed
18:54:25 <SamB> you mean Philippa ?
18:54:25 <Lycurgus> guess not
18:54:31 <Twey> Nope
18:54:42 <Lycurgus> y i did
18:54:45 <FunctorSalad> was waht Philippa?
18:54:47 <FunctorSalad> *what
18:54:47 <Twey> Philippa's a fellow Englishwoman
18:54:51 <Twey> 025349 -!- FliPPeh [i=flippeh@p578F7661.dip.t-dialin.net] has quit [Read error: 110 (Connection timed out)]
18:54:53 <SamB> how do you misspell the nick of someone who is present?
18:54:59 <Lycurgus> FliPPeh
18:55:09 <SamB> (other than getting the wrong tab completion, of course ;-)
18:55:10 <Twey> Perhaps he/she was trying to avoid highlighting
18:55:22 <Lycurgus> i didn't use tab complete or look at who was online
18:55:42 <FunctorSalad> it's the fastest way to see who's online ;)
18:55:51 <Lycurgus> in fact I didn't even know about tab complete till today
18:56:25 <Adamant_> Lycurgus: it's harder to make up new words in Chinese than English
18:56:52 * Lycurgus wonders why
18:56:58 <SamB> Lycurgus: why what?
18:57:07 <Lycurgus> han neologisms harder
18:57:13 <Lycurgus> my 1st is ...
18:57:22 <SamB> oh, because nobody knows how to pronounce them or what they mean
18:57:35 <Lycurgus> ‰ªÅ Êñá
18:58:01 <SamB> why the space?
18:58:04 <FunctorSalad> Monad Transformer?
18:58:08 <Adamant_> also English has been borrowing words from other languages since England's inception as a current country, China has been significantly less lingusitically adoptive until recently for the general case
18:58:12 <FunctorSalad> j/k
18:58:31 <FunctorSalad> heh... you could have a tiny commutative diagram for "monad"
18:58:32 <SamB> Adamant_: only that long?
18:58:48 <Lycurgus> yeah but when you say "china" you should compare it with "europe"
18:58:52 <glguy> ?seen shapr
18:58:54 <Adamant_> SamB: 1000 years vs. 150
18:58:54 <Lycurgus> not a specific nation state
18:59:16 <Adamant_> true Chinese has a bunch of dialects united by the characters
18:59:39 <Lycurgus> mutually unintelligble for the most part
18:59:40 <Adamant_> but English has stolen large amount of words from pretty much every European language
18:59:49 <Lycurgus> like italian, french, english, etc.
18:59:57 * lispy wonders how this is related to the topic :)
19:00:03 <Adamant_> ah, I'll stop
19:00:13 <lispy> well, #haskell-blah is a good place for it
19:00:17 <lispy> so you don't have to stop
19:00:40 <Adamant_> nah, I need to. thanks though.
19:00:41 <Pseudonym> #haskell-linguistics
19:00:42 <Lycurgus> well the nice way to go back on topic is to actually do so
19:00:52 <Lycurgus> this is chat after all
19:00:56 <ddarius> Pseudonym: It comes up often enough.
19:01:13 <Pseudonym> True indeed.
19:01:13 <FunctorSalad> in #math the preferred procedure is to insult then ban the offender
19:01:17 <FunctorSalad> ;)
19:01:31 <Lycurgus> though I suppose the mention of monad transformer might have been so construed
19:01:32 <Adamant_> no comment
19:01:41 <Pseudonym> Haskell has a wider variety of language-speakers than many other languages of similar age and population.
19:01:47 <dmwit> FunctorSalad: You suck.  Your age is higher than your IQ.
19:01:50 <dmwit> /ban FunctorSalad
19:02:01 <FunctorSalad> :-(
19:02:07 * lispy notes that FunctorSalad is actually 300 years old
19:02:21 <FunctorSalad> thanks lispy
19:02:23 <Pseudonym> So he might remember COBOL, then.
19:02:26 <lispy> Have you guys read the encyclopedia dramatica article on Haskell?
19:02:27 <dmwit> FunctorSalad: Don't feel too bad, I measure age in seconds. ;-)
19:02:28 <Lycurgus> #math here or efnet?
19:02:40 <FunctorSalad> here
19:02:40 <ddarius> lispy: They have an article on Haskell?
19:02:42 <Pseudonym> Lycurgus: Here, if you must.
19:02:48 <lispy> ddarius: yeah, it was in HWN
19:02:51 <FunctorSalad> Lycurgus: slightly exaggerating
19:03:05 <lispy> They had this example that generates powers of 2
19:03:07 <ddarius> lispy: uncyclopedia you mean?
19:03:12 <lispy> ddarius: oh yeas, sorry
19:03:35 <adu> hi
19:03:50 <Myoma> @keal
19:03:54 <Myoma> hey adu, how's it going
19:04:11 <lispy> how goes the haskell hacking?
19:04:13 <adu> Myoma: good, I think I found a way to implement "forall" :)
19:04:31 <chrisdone> dang it!
19:04:50 <Olathe> Hmm, I can't find the article now.
19:05:19 <chrisdone> I can't make a Parsec function which takes two parsers, and returns a parser which succeeds when the first parser succeeds and the second one fails. it never ever works when I use ‚Äúeof‚Äù for the second parser argument
19:05:48 <lispy> Olathe: http://uncyclopedia.org/wiki/Haskell
19:05:49 <lambdabot> Title: Haskell - Uncyclopedia, the content-free encyclopedia
19:06:08 <lispy> chrisdone: is this a case whre you need to "try"
19:07:11 <lispy> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
19:07:17 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
19:07:57 <Myoma> hi chessguy
19:08:00 <FunctorSalad> pretty-indenting it would be a start
19:08:10 <adu> Myoma: what about you?
19:08:17 <chessguy> 'evening
19:08:19 <chessguy> @bot
19:08:24 <Twey> Hey chessguy
19:08:34 <chessguy> Twey:  :)
19:08:42 <Myoma> chessguy, You've written a chess library?
19:09:04 <chessguy> more ore less
19:09:05 <Myoma> adu I am just hacking my compiler it is going pretty smoothly
19:09:17 <lispy> ?bot
19:09:26 <Myoma> chessguy, I thought so! I couldn't find it anywhere though, is it online?
19:09:29 <adu> wow compiler... sounds tough, I'm just trying for an interpreter...
19:09:31 <lispy> well shoot
19:09:31 <Myoma> I'd like to use it for something
19:09:46 <chessguy> it's not release-worthy yet
19:10:00 <lispy> ?tell Cale mueval keeps using up all the cpu and just running for ever.  I just did a kill all purge and now lambdabot is not responding.
19:10:05 <chessguy> may never be
19:10:07 <lispy> oops that was silly
19:10:36 <chessguy> Myoma:  what are you looking to use it for?
19:10:44 <Myoma> chessguy, oh, if it can list valid moves for a board config. it would be useful -- I was going to make a little chess thing in a browser you can play against the computer (LogicT) with
19:10:56 <Twey> Hahahaha, lispy
19:11:04 <FunctorSalad> Myoma: read that as "play against the compiler"
19:11:11 <FunctorSalad> *grins*
19:11:21 * Twey would put that on bash.org, if they accepted anything other than masturbation jokes these days
19:11:25 <FunctorSalad> chess in the type system!
19:11:34 <Twey> Haha, FunctorSalad
19:11:36 <chessguy> Myoma:  it can't, not in any legible form anyway
19:11:56 <Myoma> chessguy, awww thanks anyway
19:12:49 <chessguy> Myoma:  what is LogicT?
19:13:14 <chrisdone> Twey: tonnes of Factor quotes
19:13:16 <dmwit> chess is complicated
19:13:18 <Myoma> chessguy, it's like a list monad basically, there's a noughts and crosses AI in the examples I was planning on extending
19:13:21 <dmwit> ...let's go shopping
19:13:24 <FunctorSalad> @src LogicT
19:13:46 <Olathe> "Complicated" is hard
19:13:47 <dmwit> LogicT is pretty cool, there's a good paper on it.
19:13:56 <chrisdone> diamonds are hard, let's go shopping, for diamonds
19:14:12 <FunctorSalad> I'd guess it is the "free boolean algebra over a type" functor :)
19:14:14 <dmwit> Chess actually isn't that hard... just complicated.
19:14:16 <chessguy> ?where LogicT
19:14:31 <dmwit> It's so not-hard that even a computer can do it.
19:14:31 <Lycurgus> @version
19:15:09 <chessguy> uh
19:15:21 <chessguy> there are a lot of things wrong with that statement :)
19:15:34 <Pseudonym> LogicT is pretty useful.
19:15:45 <Pseudonym> It's strongly-moded logic programming in Haskell.
19:15:45 <Myoma> have you used LogicT?
19:15:52 <chessguy> dmwit:  there are a lot of things wrong with that statement :)
19:15:53 <SamB> dmwit: chess is not so easy
19:16:07 <dmwit> I know.
19:16:08 <Pseudonym> Myoma: The examples in the paper are from me.
19:16:10 <Pseudonym> So yeah.
19:16:27 <Myoma> :o
19:16:54 <SamB> easier than Go, sure, but...
19:17:03 <FunctorSalad> nvm, LogicT is not what I thought
19:17:15 <chessguy> anyway, this belongs in haskell-blah, but i'm currently prototyping a system for genetically breeding "noughts and crosses" (tic tac toe) players, with the hopes of using the same techniques for chess one day
19:17:17 <ddarius> Pseudonym: What all happened with your non-determinism monad?
19:17:29 <Pseudonym> Still got it somewhere.
19:17:35 <Pseudonym> I think it's on sourceforge.
19:17:43 <Pseudonym> But I should hackage it up.
19:18:03 <Pseudonym> Actually, that and LogicT would be a useful hackage, wouldn't it.
19:18:13 <Myoma> I think LogicT is on hackage thanks to dolio
19:18:21 <Pseudonym> Right.
19:18:29 <chessguy> my tic-tac-toe protoype is almost working (though not very smart yet) -- feel free to ask on -blah if anyone's interested
19:18:30 <FunctorSalad> it's in hoogle too
19:18:43 <Pseudonym> Oh, here it is./
19:18:47 <Pseudonym> http://www.haskell.org/haskellwiki/Sudoku
19:18:48 <lambdabot> Title: Sudoku - HaskellWiki
19:18:52 <Pseudonym> More or less.
19:19:03 <dmwit> chessguy: If it's written in Haskell, I think it's sufficiently on-topic here in #haskell, too.
19:19:16 <chessguy> it's not
19:19:27 <dmwit> ah
19:20:03 <chessguy> it's actually written in *cough* java, because i found a library i like
19:20:22 <Twey> Hahaha
19:20:26 <Twey> Java?!
19:20:40 <chessguy> (though i've been repeatedly tempted to port it to C#)
19:20:42 <Myoma> > say . downsidup $ "Java"
19:20:44 <lambdabot>   Couldn't match expected type `String' against inferred type `Expr'
19:20:48 <Myoma> :/
19:20:57 <Twey> > downsidup "Java"
19:20:57 <ddarius> chessguy: C# has the same library or did you mean the library?
19:20:59 <lambdabot>   …ê å…êJ
19:21:03 <Twey> Does it automatically
19:21:07 <chessguy> port the library
19:21:12 * Twey balks at the thought of a Haskellian actually choosing to use Java
19:21:14 <dmwit> Capital letters seem problematic.
19:21:19 <Twey> Aye
19:21:23 <dmwit> > downsidup "JAVA"
19:21:24 <lambdabot>   AVAJ
19:21:32 <Twey> > downsidup ['A'..'Z']
19:21:33 <lambdabot>   ZYXWVUTSRQPONMLKJIHGFEDCBA
19:21:34 <Myoma> Twey, Java is a useful tool ..
19:21:41 <Twey> Doesn't seem to do any of them
19:21:49 <chessguy> haskell just isn't always practial
19:22:04 <dmwit> > downsidup ['a'..'z']
19:22:04 <Twey> Myoma: For what, exactly?
19:22:05 <lambdabot>   z éx ç ån ás…πdbou…Øl û…æƒ±…•∆É…ü«ùp…îq…ê
19:22:07 <chessguy> not for me anyway
19:22:13 <Twey> In those cases I would generally go for Python
19:22:27 <Twey> Or a Lisp
19:22:34 <dmwit> l seems right-side-up, too.
19:22:37 <dmwit> oddly
19:22:40 <Twey> Mm
19:22:43 <Twey> Somehow
19:22:44 <Pseudonym> It's a sad truth that sometimes, the ability to reuse the work of script kiddies is a virtue.
19:23:12 <ddarius> Pseudonym: An example of such time?
19:23:20 <Myoma> Twey, for example I am using it as one backend to get reasonably efficient execution of my language, not have to implement a GC, able to write GUI programs that work on my OS and others as well as distribute compiled programs for people
19:23:33 <adu> how does it do that upsidedownthing?
19:23:36 <dmwit> Are they all just characters that happen to look like the letters upside down?  I guess it must be.
19:23:48 <dmwit> Like 'y' is lambda...
19:23:58 <Pseudonym> ddarius: Java libraries.
19:24:08 <ddarius> dmwit: It's a backwards lambda...
19:24:17 <adu> b is q
19:24:18 <dmwit> heh, p and q are backwards...
19:24:19 <Myoma> abdimal
19:24:20 <ddarius> Pseudonym: Java libraries written by script kiddies?
19:24:25 <chessguy> anyway, you can't disagree that haskell's object model sucks
19:24:25 <FunctorSalad> flip Œª, actually
19:24:31 <adu> dmwit: lol
19:24:33 <Myoma> chessguy, object model ??
19:24:45 <Myoma> chessguy, AFAIK it doesn't exist enough to suck
19:24:55 <chessguy> haskell's way of modelling objects
19:24:56 <TomMD> I just had an odd thought - tell me if I should stop thinking and sleep.  Simon Marlow says the main thread is handled slightly differently and, as such, communication between it and other haskell threads is slower.  Does the Control.Parallel library take this into account?  Does it avoid using the main thread, instead forking off children threads and leaving the main one to sleep?
19:24:58 <chessguy> i.e., records
19:25:12 <Twey> chessguy: Hrm
19:25:15 <Twey> WFM
19:25:26 <Pseudonym> ddarius: In this context, "script kiddie" refers to anyone who writes or uses code without thinking about it very hard.
19:25:37 <dmwit> records could be a lot better, but let's not talk about it yet again.
19:25:38 <Pseudonym> And without the ability to think about it very hard.
19:25:44 <chessguy> ?vera wfm
19:25:51 <dmwit> "works for me"
19:25:53 <ddarius> Pseudonym: And my question is when do you want to use a library written by such a person?
19:26:03 <chessguy> bah
19:26:19 * Lycurgus is away: I'm busy
19:26:20 <Twey> With record syntax, I don't see the point of changing it really
19:26:29 <dmwit> ddarius: When it's so easy to write that even a script kiddie can do it right without thinking?
19:26:31 <adu> Pseudonym: described most ppl
19:26:33 <Pseudonym> When it performs a task that you don't have the time to rewrite yourself.
19:26:39 <dons> i started a page to document everything we know about haskell on multicore, http://haskell.org/haskellwiki/Haskell_for_multicores
19:26:40 <lambdabot> Title: Haskell for multicores - HaskellWiki
19:26:44 <Pseudonym> And it does it well enough.
19:26:48 <TomMD> Reading it now.
19:27:07 * Lycurgus is back (gone 00:00:50)
19:28:30 <dons> TomMD: examples of each area are obviously missing. then we link to related libraries, blogs, wikipages and papers.
19:28:40 <dons> in the end you've got a 10 chapter book :)
19:29:16 <chessguy> RWMH - Real World Multicore Haskell
19:32:07 <mornfall> ?hoogle [Maybe a] -> [a]
19:32:17 <Myoma> catMaybes!
19:32:24 <mornfall> Right!
19:32:26 <chrisdone> best function evar
19:32:33 <mornfall> Been looking for concatMaybes :|
19:33:46 <TomMD> dons: I'll try to add examples this week.  I'm tempted to add benchmarks for various examples, but something is telling me not to.
19:34:01 <TomMD> perhaps on another page.
19:34:05 <mornfall> chrisdone: How come?
19:34:31 <chrisdone> mornfall: so useful
19:34:35 <mornfall> : - )
19:34:36 <Myoma> :t foldr (maybe const (:))
19:34:37 <lambdabot>     Couldn't match expected type `b -> [a]' against inferred type `[a]'
19:34:37 <lambdabot>     Probable cause: `:' is applied to too many arguments
19:34:37 <lambdabot>     In the second argument of `maybe', namely `(:)'
19:34:45 <Myoma> :t foldr (maybe id (:))
19:34:46 <lambdabot> forall a. [a] -> [Maybe a] -> [a]
19:34:51 <dons> TomMD: maybe the wikibook makes sense..
19:34:54 <Myoma> catMaybes = foldr (maybe id (:)) []
19:34:56 <dons> encourages better style.
19:35:01 <dons> TomMD: and we do need benchmarks.
19:35:47 <TomMD> dons: Why do you say that, about the wikibook?  The organization of the whole thing?
19:36:25 <TomMD> I'd like for haskell.org to be a good home, but it just doesn't have the organization the wikibook does.  Can't recall which two people were doing much of that work, but it is good work.
19:37:02 <Myoma> pointfree is made of combinators, constructors, destructors and eliminators only?
19:37:22 <dons> TomMD: right.
19:37:25 <dons> organisation.
19:39:35 <ddarius> Myoma: No lambdas is a sufficient rule.
19:47:52 <mmorrow> and no lets
19:48:02 <mmorrow> (or wheres)
19:48:25 <mmorrow> (and obviously only expressions)
19:50:02 <mib_91nbufyr> o_o
19:50:07 <mib_91nbufyr> yay im in haskell
19:50:13 <mib_91nbufyr> morrow sounds like a game to me, morrowind
19:50:24 <mmorrow> it is a game.
19:50:25 <mib_91nbufyr> anyone tried that game before? its fun
19:50:37 <mib_91nbufyr> are you good at it?
19:50:47 <mmorrow> if this was tomorrow i'd be
19:50:57 <mib_91nbufyr> i get headache playing this game, moves around
19:51:05 <mmorrow> if you're asking yesterday, then i agree
19:51:26 <newbieyu> if i ask tod ay? then you disagree?
19:51:34 <mmorrow> is it tomorrow yet?
19:51:40 <mmorrow> hehe
19:51:51 <newbieyu> it is today, anways, i want to ask about syntatic sugar
19:51:53 <newbieyu> anyone heard about it
19:51:59 <mmorrow> it's sweet
19:52:07 <newbieyu> how does it work
19:52:09 <newbieyu> in haskel
19:52:11 <mmorrow> how do you mean?
19:52:13 <newbieyu> haskell*
19:52:25 <newbieyu> i got a tutorial haskell book, it says about syntatic sugar
19:52:27 <Myoma> haskell sees [1..5] but it thinks enumFromTo 1 5
19:52:40 <mmorrow> > [0..]
19:52:40 <Myoma> that is everything there is to syntax sugar
19:52:41 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
19:52:46 <mmorrow> > [0..9]
19:52:47 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
19:52:59 <newbieyu> huh? could myoma explain in more detail?
19:53:00 <newbieyu> please
19:53:06 <Myoma> You say one thing but you mean another
19:53:22 <newbieyu> example of the "mean another" vs "one thing"
19:53:39 <Myoma> enumFromTo 1 5  vs  [1..5]
19:53:53 <Myoma> > enumFromTo 1 5  ==  [1..5]
19:53:54 <lambdabot>   True
19:54:02 <mmorrow> > return . (+1) =<< [0..9]
19:54:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:54:26 <mmorrow> > do { x <- [0..9] ; return (x+1) }
19:54:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:54:40 <Myoma> > id { 3 }
19:54:41 <mmorrow> > [ x + 1 | x <- [0..9] ]
19:54:41 <lambdabot>   mueval: Prelude.read: no parse
19:54:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:54:43 <waynemokane> what is the correct way to turn a Fractional into a Rational
19:54:44 <Myoma> Aww
19:54:52 <mmorrow> heh
19:54:56 <Myoma> :t realToFrac :: Fractional -> Rational
19:54:57 <lambdabot>     Class `Fractional' used as a type
19:54:57 <lambdabot>     In the type `Fractional'
19:54:57 <lambdabot>     In the type `Fractional -> Rational'
19:55:00 <Myoma> not that ...
19:55:08 <newbieyu> huh
19:55:18 <mmorrow> > toRational pi
19:55:19 <lambdabot>   884279719003555%281474976710656
19:55:30 <Myoma> > 22%7
19:55:32 <lambdabot>   22%7
19:55:58 <newbieyu> mmorrow do { x <- [0..9] ; return (x+1) }, this is "one thing" or "another thing"
19:56:16 <newbieyu> you guys just post stuff , but I do not know which 1 you are referring to
19:56:47 <Myoma> newbieyu: Did I say something which you have not understood?
19:56:48 <mmorrow> newbieyu: so the following 3 that i'm gonna do are equivalent:
19:56:50 <lispy> ?check (+1) `fmap` [0..9] == do { x <- [0..9]; return (x+1) }
19:56:54 <mmorrow> > do { x <- [0..9] ; return (x+1) }
19:56:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:56:57 <mmorrow> > [ x + 1 | x <- [0..9] ]
19:56:57 <Olathe> newbieyu: You could ask :)
19:56:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:57:00 <mmorrow> > return . (+1) =<< [0..9]
19:57:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:57:34 <TSC> @src toRational
19:57:51 <Olathe> > [1..10]
19:57:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:57:55 <Olathe> I win !
19:58:01 <newbieyu> umm... still im confuse
19:58:13 <mmorrow> newbieyu: but exactly /why/ isn't tricky or hard to understand, but i'm not sure how to say it clearly in a few sentences
19:58:44 <newbieyu> hmm the book says somethign like this
19:58:51 <mmorrow> newbieyu: messing around in ghci is an excellent way to get a feel for things
19:58:55 <TomMD> Does RULES pragma work in literate haskell files?
19:59:17 <newbieyu> In fact, the [5,1,2,3,4] syntax is ‚Äúsyntactic sugar‚Äù for the expression using the explicit cons operators and empty list. If we write something using the [5,1,2,3,4] notation, the compiler simply translates it to the expression using (:) and [].
19:59:23 <mmorrow> TomMD: i believe so
19:59:35 <mmorrow> newbieyu: ahhh, ok.
19:59:36 <waynemokane> TSC: thanks
19:59:43 <Myoma> newbieyu: I say [1,2,3], but I mean 1 : (2 : (3 : []))
19:59:45 <mmorrow> > 0:1:2:3:[]
19:59:45 <newbieyu> so i dont know how to relate that sentence to your codes
19:59:46 <lambdabot>   [0,1,2,3]
20:00:01 <lispy> and [a] is syntatic sugar for [] a
20:00:08 <lispy> > [] :: [] Int
20:00:08 <mmorrow> > (:) 1 ((:) 2 ((:) 3 []))
20:00:10 <lambdabot>   []
20:00:10 <lambdabot>  Terminated
20:00:16 <mmorrow> > (:) 1 ((:) 2 ((:) 3 []))
20:00:17 <lambdabot>   [1,2,3]
20:00:31 <newbieyu> how do i disable smileys in mibbit
20:00:32 <waynemokane> dons: are you online?
20:00:34 <newbieyu> i could not see the codes clearly
20:00:40 <mmorrow> > foldr f a [x,y,z]
20:00:41 <lambdabot>   f x (f y (f z a))
20:00:46 <mmorrow> > foldl f a [x,y,z]
20:00:47 <lambdabot>   f (f (f a x) y) z
20:00:57 <Myoma> > foldr (flip f) a [x,y,z]
20:00:59 <lambdabot>   f (f (f a z) y) x
20:01:00 <mmorrow> > foldl f a (repeat x)
20:01:03 <Olathe> @pl \a b c d -> a:b:c:d:[]
20:01:04 <Myoma> > foldl f a (reverse [x,y,z])
20:01:11 <lambdabot>   mueval: Prelude.read: no parse
20:01:14 <lambdabot>   f (f (f a z) y) x
20:01:29 <mmorrow> > (:[]) 42
20:01:30 <lambdabot>   [42]
20:01:34 <mmorrow> > [42]
20:01:35 <newbieyu> myoma  I say [1,2,3], but I mean 1 : (2 : (3 : [])) what does this mean? whats the difference
20:01:36 <lambdabot>   [42]
20:01:37 <Olathe> @pl \a b c d -> a:b:c:d:[]
20:01:53 <Olathe> Faster !
20:02:06 <lispy> Hmm
20:02:15 <Myoma> newbieyu: they are equals thing but written in different ways, '1 : (2 : (3 : []))' is closer to the truth
20:02:32 <geezusfreeek> Olathe: (. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)
20:02:35 <newbieyu> closer to Truth (boolean) ?
20:02:39 <Myoma> the truth being that lists are made of conses
20:02:48 <Myoma> as opposed to square brackets and commas
20:02:51 <geezusfreeek> dunno what lb is doing
20:02:52 <Myoma> (:) is a cons
20:03:13 <Olathe> > ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:)) 1 2 3 4
20:03:14 <lambdabot>   [1,2,3,4]
20:03:17 <Olathe> There.
20:03:19 <newbieyu> ok i see that (: ) is a cons
20:03:21 <lispy> wow, lambdabot has 14 defunct processes right now
20:03:34 <Olathe> Eww.
20:03:43 <lispy> gwern: is it possible lambdabot is not strict enough in waiting for children?
20:03:51 <Olathe> Thank you, geezusfreeek.
20:03:55 <geezusfreeek> np
20:04:00 <newbieyu> oh thanks for the explanation myoma, , but how does the cons relates to "syntatic sugar"
20:04:22 <geezusfreeek> newbieyu: [a,b,c,d] => a:b:c:d:[]
20:04:34 <mmorrow>   x:y:[]  <====>  [x,y]
20:04:43 <newbieyu> geezus , mind explaining that code?
20:04:54 <mmorrow> > x:y:[]
20:04:56 <lambdabot>   [x,y]
20:05:04 <geezusfreeek> the bracket notation on the left desugars to the explicit cons notation on the right
20:05:04 <Twey> newbieyu: He means that [a, b, c, d] is sugar for a : b : c : d : []
20:05:20 <mmorrow> > map (x:) [a,b,c,d,e,f,g]
20:05:22 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
20:05:34 <mmorrow> > map (x:) (map (:[]) [a,b,c,d,e,f,g])
20:05:35 <lambdabot>   [[x,a],[x,b],[x,c],[x,d],[x,e],[x,f],[x,g]]
20:06:03 <Twey> > map (:[]) [a, b, c, d]
20:06:05 <lambdabot>   [[a],[b],[c],[d]]
20:06:09 <Olathe> > map :: Expr
20:06:10 <lambdabot>   Couldn't match expected type `Expr'
20:06:22 <mmorrow> > (map . map) ((x:) . (:[])) [a,b,c,d,e,f,g]
20:06:23 <Twey> > map ((x:) . (:[])) [a, b, c, d]
20:06:23 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Expr'
20:06:25 <lambdabot>   [[x,a],[x,b],[x,c],[x,d]]
20:06:29 <newbieyu> so sugar means replacing cons with comma and have a bracket around them?
20:06:40 <mmorrow> newbieyu: "sugar
20:06:46 <Olathe> Sugar means a nicer-looking way of doing something.
20:06:58 <newbieyu> nicer loooking?
20:07:00 <Olathe> 1:2:3:4:[] is sort of ugly and difficult to type.
20:07:01 <Myoma> newbieyu: That is just one syntax sugar, there may be others
20:07:06 <Twey> newbieyu: It means it doesn't actually do anything that couldn't be done without it
20:07:07 <Olathe> [1,2,3,4] is quite a bit nicer.
20:07:16 <Twey> It's just an easier way of writing it
20:07:24 <newbieyu> thanks twey for the explanation :D
20:07:29 <geezusfreeek> [a,b,c,d] is what you type (when you think it is more appropriate), but a:b:c:d:[] is what it _actually_ is internally
20:07:41 <newbieyu> i finally understand about syntatic sguar, you rocks
20:07:41 <mmorrow> newbieyu: "sugar" is taking the way to formally construct something syntactically, and creating a new way to say the /same/ thing with /different/ that's more manageable/easy to use
20:07:47 <newbieyu> man that was hard
20:07:57 <Twey> Haha
20:07:58 <Myoma> now you say internally, but internal to what?
20:08:02 <mmorrow> *thing with /different/ ... that's more
20:08:05 <mmorrow> gah
20:08:10 <Twey> Haha
20:08:13 <mmorrow> *thing with /different/ syntax that's more ...
20:08:20 <geezusfreeek> okay, "internally" was not the perfect choice to describe it
20:08:44 <Myoma> I know exactly what you mean and I agree but it's tricky to phrase it
20:08:55 <geezusfreeek> yeah
20:09:02 <Twey> In the same manner that 'do a; b <- c; d b' becomes a >> c >>= \b -> d b
20:09:34 <Olathe> 1 + 2 -> (+) 1 2
20:09:47 <newbieyu> so this is the other sugar syntatic? In the same manner that 'do a; b <- c; d b' becomes a >> c >>= \b -> d b
20:09:49 * Twey nods.
20:09:58 <mmorrow> yes
20:10:01 <newbieyu> wow, what command you use for nod
20:10:06 <newbieyu> cool
20:10:07 <Twey> newbieyu: Yes, that's also syntactic sugar (don't worry about what it means for now)
20:10:17 * mmorrow says /me says to demonstrate
20:10:37 <Olathe> /me
20:10:39 * newbieyu says to demonstrate?
20:10:45 * Twey tries to think of some others.
20:10:48 * newbieyu nods
20:10:54 <newbieyu> lol thanks mmorrow :D
20:10:57 <mmorrow> heh
20:11:04 <Twey> Oh, multiple definitions to patterns
20:11:10 <Myoma> \x y z w -> M
20:11:17 <Myoma> \x -> \y -> \z -> m -> M
20:11:28 <Myoma> um.
20:11:31 <Twey> Oh, yes, arguments too
20:11:33 <Myoma> \x -> \y -> \z -> \w -> M
20:11:41 <Myoma> you might say
20:11:45 <Myoma> f Nothing = 3
20:11:51 <Myoma> f (Just x) = x
20:11:56 <Myoma> is sugar for f = maybe 3 id
20:12:05 <chrisdone> or vise-versa..
20:12:36 <Twey> Well, no, it isn't
20:12:51 <Twey> It's sugar for f v = case v of Nothing -> 3; Just x -> x
20:13:31 <chrisdone> true
20:13:38 <michaelgg> Someone here (I think) gave me a link to the "Real World Haskell" book. *THANK YOU*
20:14:00 <chrisdone> ‚ô• RWH ‚ô•
20:14:10 <Myoma> so who chooses what is sugar and what isn't?
20:14:40 <Twey> Myoma: Uh, the language designers?
20:14:41 <chrisdone> who chose if to be syntactical :(
20:15:04 <Myoma> i.e.   is  6 sugar for  fromIntegral 6 ?
20:15:16 <Twey> Well, no
20:15:21 <Twey> Because that's a recursive definition
20:15:25 <dons> michaelgg: what did you think of it?
20:15:29 <Twey> You can't do it without the sugar
20:15:31 <Myoma> but the do notation sugar is recursive
20:15:33 <Twey> 'sugar'
20:15:36 <Twey> No, it isn't
20:15:44 <Twey> You can implement do without using do
20:15:46 <Olathe> Sugar is just a nice descriptor, not something to formally define ;)
20:15:54 <michaelgg> I've been reading it and i love it
20:16:02 <michaelgg> And having the comments online is totally awesome
20:16:09 * Twey nods.
20:16:13 <michaelgg> because they tend to ask and answer so many common questions that might pop up
20:16:21 <dons> yeah, that's true.
20:16:23 <Twey> Give back by commenting if you find anything that needs clarification :)
20:16:24 <chrisdone> michaelgg: yeah,  I like that
20:16:25 <michaelgg> I'm ordering a copy now, and I think ill make it required reading
20:16:37 <dons> michaelgg: oh, you teach some where?
20:16:37 <Twey> You're a teacher?
20:16:41 <michaelgg> no, company
20:16:45 <Twey> Ah-huh
20:16:46 <dons> cool
20:16:51 <Twey> Nice *nod*
20:17:01 <michaelgg> Even though I dont plan on using Haskell commercially, I found that that book was the thing that finally got me to get some of a grasp on monads
20:17:04 <Twey> Your company uses Haskell?
20:17:05 <Twey> Ah
20:17:06 <michaelgg> which in turn helped me understand F#
20:17:09 <dons> heh
20:17:14 <Twey> Hehe
20:17:18 <michaelgg> no, we cant give up the .NET platform (and Mono)
20:17:23 <dons> ah i see.
20:17:29 <dons> platform lock in :(
20:17:31 <michaelgg> As someone put it, "learning haskell will fuck your brain, and youll like it"
20:17:32 * Twey nods.
20:17:34 <dons> now, a .NET bridge.
20:17:42 <michaelgg> well, the fact that we get SOOOO much for free on .NET / Mono
20:17:43 <mmorrow> michaelgg: start your own company that uses haskell. :)
20:17:43 <Twey> Isn't there one?
20:17:50 <michaelgg> it is my own company
20:17:53 <mmorrow> heh
20:17:57 <Twey> Haha
20:18:02 <mmorrow> michaelgg: so then use haskell!!
20:18:03 <newbieyu> thanks mmorrow for the lengthy explanation, but it helps alot
20:18:04 <chrisdone> tiem parandox
20:18:06 <michaelgg> But we need to connect to SQL Server Database and OLAP
20:18:14 <mmorrow> newbieyu: no prob :)
20:18:24 <michaelgg> as well as use existing libraries which arent in Haskell
20:18:31 <chrisdone> michaelgg: write a logic-language database >___>
20:18:40 <michaelgg> although, i am afradi that the more i use it, the more i will consider it :P
20:18:41 <bjrn> Using the -hd switch to the ghc heap profiler I get an entry, "D#". What's that?
20:18:42 <dons> michaelgg: oh, which things are missing (you looked on hackage?)
20:18:51 <dons> bjrn: the Double constructor
20:18:55 <mmorrow> michaelgg: perhaps a slow but steady transition?
20:18:57 <dons> data Double = D# Double#
20:18:59 <michaelgg> Well, WCF for one :P
20:19:03 <ddarius> @src Double
20:19:03 <bjrn> dons: Ah cheers.
20:19:23 <michaelgg> We want a SOAP platform plus support for distributed transactions....
20:19:33 <chrisdone> michaelgg: SPJ, ‚ÄúI've slipped Haskell into your company without you even realising it!‚Äù
20:19:37 <michaelgg> specifially, the WCF one :P
20:19:58 <chrisdone> read: ‚ÄúI've slipped Haskell into your $x without you even realising it!‚Äù
20:20:06 <Twey> Myoma: http://www.cin.ufpe.br/~haskell/haskelldotnet/ -- keep an eye out!
20:20:08 * mmorrow had to google WCF
20:20:13 <Twey> Er
20:20:16 <Twey> michaelgg: ^
20:20:17 <lambdabot> Title: The Haskell.NET Project
20:20:28 <michaelgg> If there was a "supported" Haskell .NET project, it'd get considerably more appealing
20:20:37 * Twey nods.
20:20:43 <chrisdone> latest news: 2003-12-13
20:20:44 <Twey> Apparently the GC is difficult
20:20:48 <chrisdone> it's worse than the lojban web site
20:20:51 <newbieyu> hey guys, how do i make the element in the list displayed in new lines?
20:20:51 <Twey> chrisdone: You never know
20:20:52 <dons> the UNSW guys have a .NET bridge too
20:20:54 <michaelgg> But we still have about 100K lines of code in this project alone in C#
20:20:59 <michaelgg> apart from F#
20:21:05 <dons> oh, you're using F#?
20:21:08 <newbieyu> for example [1..10] prints all the result in 1 line, but i want it to be in 10 lines
20:21:08 <michaelgg> yewa
20:21:12 <Twey> newbieyu: What do you mean?  'Displayed'?  When printing?
20:21:15 <chrisdone> newbieyu: use unwords
20:21:18 <newbieyu> ya print
20:21:23 <chrisdone> > unwords ["hey","guise"]
20:21:23 <michaelgg> and F# has monad support ("computation expressions")
20:21:24 <lambdabot>   "hey guise"
20:21:29 <chrisdone> > unlines ["hey","guise"]
20:21:30 <lambdabot>   "hey\nguise\n"
20:21:31 <dons> michaelgg: as glue for the underlying .NET libraries?
20:21:36 <michaelgg> which I *finally* got after reading your book
20:21:42 <dons> cool
20:21:42 <Twey> unlines looks like it
20:21:46 <michaelgg> dons well we're only starting to push it into full production
20:21:57 <michaelgg> We've been hesitant since it was "research"
20:22:11 <bjrn> mapM_ Printf probably works too.
20:22:12 <michaelgg> and i'd be responsible to investors and everyone if there was some problem
20:22:12 <dons> F#, well, it's new.
20:22:27 <michaelgg> butn ow that MS actually released a commercial preview, I can trust em
20:22:33 <dons> so that'd be the main risk, i imagine, not knowing what happens if you hit a bug.
20:22:38 <newbieyu> unlines?
20:22:48 <chrisdone> yes, unlines, from Data.List
20:22:55 <newbieyu> i place into my winhugs, and it displayed everythign in 1 ilnle
20:22:57 <newbieyu> line*
20:23:12 <michaelgg> SPJ and the F# people are both at MSRC arent they
20:23:13 <newbieyu> do i need to import something?
20:23:17 <chrisdone> > unlines $ lines "blah\nblah\blah"
20:23:18 <dons> michaelgg: yeah.
20:23:18 <lambdabot>   "blah\nblah\blah\n"
20:23:19 <chrisdone> yes, Data.List
20:23:27 <michaelgg> so im hoping we'll get good things filtering in
20:23:44 <Twey> newbieyu: import Data.List; main = putStrLn . unlines . (map show) $ [1..10]
20:23:48 <chrisdone> newbieyu: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Aunlines
20:24:00 <lambdabot> Title: Data.List, http://tinyurl.com/yhrw65
20:24:13 <dons> michaelgg: cool. you could think about coming to CUFP.
20:24:25 <dons> at least, the next one, 20:16  michaelgg> because they tend to ask and answer so many common questions that might pop up
20:24:28 <dons> grr.
20:24:33 <dons> at least, the next one, http://cufp.galois.com/
20:24:38 <lambdabot> Title: Commercial Users of Functional Programming
20:24:54 <michaelgg> Maybe :). the one thing I've noticed is that the FP community is so intelligent compared to the "imperative/industry" communities
20:25:06 <dons> michaelgg: if you see the program, Don Syme's there, and pretty much all the other big players in commercial FP.
20:25:08 <michaelgg> I'm horribly ignorant and unqualified :P
20:25:30 <dons> http://cufp.galois.com/2008/schedule.html
20:25:31 <lambdabot> Title: Commercial Users of Functional Programming 2008 Program
20:25:32 <michaelgg> I got a book on category theory and im moving through it at a glacial pace. I think i need to go to school :P
20:25:53 <chrisdone> michaelgg: what book?
20:26:10 <michaelgg> Pierce
20:26:13 <bjrn> Hehe I think Haskell is punishing me. I have two functions I wrote a few days ago annoted with lots of "TODO" and "rewrite" and a bunch of profanities for good measure. I profiled the code today, and of course these are the two that leak memory like theres no tomorrow.
20:26:38 <dmwit> Time for a rewrite and a bit of a TODO, I'd say. =)
20:26:49 <michaelgg> I think the problem is i dropped out of high school to become a programmer. As far as work in "industry" as a consultant, it's working stellar :P
20:27:08 <michaelgg> so i prolly need to sort out a full course load to get myself up to speed
20:27:38 <michaelgg> I got so sick once I started studying FP and found out some of these ideas have been around since the 70s, yet few "working programmers" have any clue they exist :P
20:27:40 <lispy> custom monads++
20:27:40 <bjrn> There's this saying you get half a masters degree by learning haskell :)
20:28:20 <chrisdone> michaelgg: I am in the same position
20:29:05 <michaelgg> Like "functions that return functions" -- holy crap people balk at that, but shouldnt anyone with a college degree understand it??
20:29:13 <michaelgg> Wait, are the authors of the realworld haskell book here?
20:29:17 <lispy> a Haskell course is still no substitute for jumping in while reading some good papers.  In particular, tackling the awkward squad, some of the monad transformer papers, and just about anything by Oleg
20:29:41 <lispy> michaelgg: quite often they are, bos, dons and dcoutts I think
20:29:46 <Twey> michaelgg: Uhm, I don't have anything like a college degree, but I got it pretty quickly after I encountered it in Javascript :)
20:29:51 <ddarius> michaelgg: dons is one of them.
20:29:54 <newbieyu> thanks chrisdone for the website link, pretty useufl ^_^ "
20:29:56 <michaelgg> Oh.... dons :P Hi and thanks! :)
20:29:58 <newbieyu> useful*
20:30:06 <michaelgg> Putting it on the web is so awesome
20:30:13 <ddarius> lispy: s/dcoutts/CosmicRay
20:30:15 <michaelgg> intelligent publisher that lets ya do that
20:30:20 <newbieyu> i realised why the code did not work, I did not have the putStrLn <<<<
20:30:30 <Twey> It is a rather awesome idea
20:30:43 <chrisdone> Twey: encountered what?
20:31:21 <michaelgg> The other problem with .NET integration is A: They *love* their overloading (I guess named/optional parameters didnt cross their mind)
20:32:01 <newbieyu> i typed this unlines ["hey","guise"] instead of this putStrLn $ unlines ["hey","guise"]
20:32:03 <bd_> nothing suitable typeclass hackery can't fix
20:32:27 <michaelgg> and B: they like all their functions in tupled form
20:32:53 <michaelgg> (and C, they consider a high allocation rate to be a bug, rather than an area that needs optimization)
20:33:59 <bos> really? that must make F# behave like a dog.
20:34:11 <waynemokane> is there a way, in gchi, to find out all classes which some type is an instance of?
20:34:20 <newbieyu> thanks twey
20:34:23 <newbieyu> for the code
20:34:25 <bos> waynemokane: @info MyType
20:34:45 <waynemokane> @info Double
20:34:56 <bos> waynemokane: that will only tell you about typeclasses that are in scope, though
20:35:16 <michaelgg> bos, yea, it means you have to be a bit more careful in F#
20:35:24 <michaelgg> but F# keeps up with C# overall
20:35:41 <michaelgg> (in part cause the compiler isn't a "Source code to MSIL version of source code" translator" :P)
20:35:44 <shapr> glguy: What?
20:36:57 <glguy> nevermind, the person that was causing me to seek you out has since left
20:37:15 <dons> sometimes i'm surprised there are people who are learning haskell, who haven't heard about RWH yet. I wonder how we more effectively push new "practical" people towards it.
20:37:44 <bjrn> Slashdot review.
20:37:44 <lispy> dons: pimp it at open source conferences
20:37:57 <hml> dons: what's rwh?
20:38:00 <dons> mm.
20:38:11 <lament> slashdot review certainly!
20:38:19 <dons> hml: you're not kidding? didn't we talk about this last week. :)
20:38:27 <dons> slashdot eh?
20:38:32 <dons> last bastion of scoundrals.
20:38:35 <michaelgg> Well I'm gonna post to the F# Dev Center homepage
20:38:40 <michaelgg> on msdn
20:38:50 <dons> michaelgg: hehe. yeah. i like that: RWH made me a better F# programmer.
20:38:52 <michaelgg> since i think RWH can give people a deeper understanding of F#
20:38:57 * dons smacks jdh up
20:39:06 <michaelgg> jdh?
20:39:13 <dons> oh, never mind :)
20:39:25 <michaelgg> What I cannot understand is why more people aren't using FP
20:39:25 <dmwit> hml: In case you weren't kidding: Real World Haskell, a new book.
20:39:34 <glguy> who's new book?
20:39:35 <michaelgg> Any estimates on the ship date?
20:39:48 <dons> November!
20:39:48 <Twey> I'm a new book!
20:39:50 <Olathe> Well, if you buy it, your new book.
20:39:58 <michaelgg> Nov? so long .....
20:40:18 <dons> copyediting sigh. apparently they actually want to read every word before printing.
20:40:21 <dons> i know, crazy.
20:40:39 <lament> that's kind of important
20:40:46 <michaelgg> Yea, I had started a book project and know how much work it is.
20:40:52 <michaelgg> people dont appreciate it until they do it themselves
20:41:08 <dons> glguy: i know, we can go up to the top of the bancorp tower in portland, and throw copies of RWH down to the people below.
20:41:15 <lament> reading badly proofread books is unpleasant
20:41:16 <bjrn> Isn't Anathem released soon? Something to read til November. :)
20:41:24 <Twey> And get done for murder?  :-P
20:41:25 <michaelgg> Although, I ended up stopping because I realised "Pratical Functional C#" is the same difficulty as "Cultivating meaningful relationships on Craiglist for under $10/hr"
20:41:36 <Twey> Hahahahaha, michaelgg
20:41:37 <michaelgg> technically possible, but quite painful and mostly futile.
20:41:40 <dons> :)
20:42:00 <michaelgg> They have psuedo monad support in their query comprehensions
20:42:08 <michaelgg> but you end up with some really f'd up code
20:42:14 <lament> michaelgg: where can i buy that book?
20:42:41 <michaelgg> Practical Functional C#? nowhere. I got about 4 chapters into it and realised i cant fill a full book because C# sucks too much :P
20:42:48 <lament> no, the other one
20:42:54 <michaelgg> RWH? At Amazon
20:43:00 <dons> i guess we kick out the online reviews in the next few weeks.
20:43:06 <lament> no, dammit, the one about meaningful relationships
20:43:08 <dons> start getting preprints to reviewers
20:43:09 <michaelgg> http://www.realworldhaskell.org/
20:43:11 <lambdabot> Title: Real World Haskell
20:43:11 <michaelgg> oh hahhaha :D
20:43:11 <waynemokane> dons: can you please take a look at my paste and let me know if I'm using the Text.JSON API in a sensible way?
20:43:17 <dons> waynemokane: sure.
20:43:23 <waynemokane> dons: http://hpaste.org/10087#a1
20:43:27 <michaelgg> That's another book project I abandoned.
20:43:27 <lament> RWH i have preordered :)
20:43:29 <waynemokane> dons: it's the bottom box that is formatted correctly
20:43:38 <lament> michaelgg: really?
20:43:51 <waynemokane> dons: basically I have some Position data type which is algebraic with a String and Double, and trying to declare it "JSON-able"
20:44:07 <dons> waynemokane: that bottom "> Error "Resulting JSValue was not a JSObject"
20:44:10 <dons> " looks wrong.
20:44:20 <michaelgg> Apparently the "pretty, single 20 yr old girl, studying quantum physics and looking to have a non-commital relationship with a .NET developer" turned out to be a scam.
20:44:51 <cjb> yeah, 20 year old physicists are all about Fortran
20:44:57 <michaelgg> fortunately i had left my wallet at home so i didnt get burned to badly.
20:45:28 <michaelgg> Fortran .NET?
20:45:47 * lispy chuckles about Fortran .NET
20:45:49 <lament> i know such a girl, except for the relationship part
20:45:54 <cjb> (it exists, you know)
20:46:04 <michaelgg> We actually used COBOL .NET in production
20:46:07 * cjb nearly worked for a company who did Fortran.NET stuff.
20:46:11 <lament> i certainly wouldn't want to be in a relationship with her... she's such a dork!
20:46:15 <bjrn> Fortran Net sounds like a medieval torturing device.
20:46:20 <waynemokane> dons: OK,can you elaborate a bit more?
20:47:12 <cjb> shapr: I'm liking django.  My site's done, and is 68 lines of code.  (40 for view, 28 for model.)
20:47:17 <waynemokane> dons: basically I'm trying to make sure that what they're trying to read is a JSObject, as opposed to say a JSArray
20:48:34 <bjrn> Hm is (++) constant time?
20:49:11 <bos> bjrn: that depends.
20:49:19 <bjrn> Say you're mapping over a++b
20:49:43 <bos> its cost is at most linear in the first term.
20:49:47 <Pseudonym> In Haskell, every function is constant time until it's evaluated.
20:50:11 <ajdhs> @help pf
20:50:21 <chrisdone> @help pl
20:50:31 <ajdhs> @help pl
20:50:32 <chrisdone> @pl \d -> d * d
20:50:35 <Pseudonym> ?bot
20:50:40 <chrisdone> D:
20:50:52 <chrisdone> ajdhs: sounds like you need GHCi on ACID!
20:51:08 <ajdhs> how do you get that?
20:51:15 <Pseudonym> It'd be nice to have a W combinator.
20:51:17 <Pseudonym> W (*)
20:51:42 <waynemokane> dons: for an example of what I'm trying to do:   http://hpaste.org/10089#a0
20:53:06 <ddarius> Pseudonym: Every function in every language is constant time until it is evaluated.
20:53:11 <waynemokane> dons: sorry, was missing a key line in that paste, let's try again:     http://hpaste.org/10090#a0
20:53:14 <ddarius> join (*)
20:53:32 <Pseudonym> I guess.
20:54:11 <shapr> cjb: wow, impressive
20:54:56 <hml> http://book.realworldhaskell.org/read/ <-- is this the beta or final?
20:55:01 <lambdabot> Title: Real World Haskell
21:01:26 <michaelgg> dons I hope your links to amazon are referall links so you get an extra kickback :)
21:01:46 <andyjgill> Hey dons, you might want to update your bio on the back of the book.
21:03:19 <jsnx> i have an idea that i think might be handled already, but i'm not sure
21:03:30 <dons> andyjgill: yeah, that's been done. takes a while to bubble through to amazon et al.
21:03:37 <dons> andyjgill: note the page count is also off.
21:03:52 <jsnx> i'd like to do something like `True . [1,2,3] = [ 1,2,3 ]` but `False . [1,2,3] = []`
21:04:05 <jsnx> i think there must be something involving mzero to do this
21:04:16 <andyjgill> Dons: sure.
21:04:20 <jsnx> and probably a different operator then `.`
21:04:28 <dmwit> jsnx: guard
21:04:31 <ddarius> guard bool >> [1,2,3]
21:04:32 <Myoma> jsnx: bool id (const [])
21:04:42 <dmwit> :t guard
21:04:44 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:04:49 <Myoma> @let bool true false True = true ; bool true false False = false
21:05:00 <ddarius> > guard True >> [1,2,3]
21:05:01 <lambdabot>   [1,2,3]
21:05:07 <ddarius> > guard False >> [1,2,3]
21:05:08 <lambdabot>   []
21:05:09 <Myoma> > let (.) = bool id (const []) in ( True . [1,2,3] , False . [1,2,3] )
21:05:10 <lambdabot>   mueval: Prelude.read: no parse
21:05:13 <jsnx> cool!
21:05:42 <Myoma> gwern: possible bug in mueval?
21:05:46 <jsnx> Myoma: closer to my syntax, but ddarius has captured my intent
21:05:57 <Myoma> syntax doesn't matter
21:06:38 <jsnx> Myoma: where is bool?
21:06:45 <dmwit> Data.Bool
21:06:46 <Myoma>  <Myoma> @let bool true false True = true ; bool true false False = false
21:06:58 <dmwit> oh
21:07:01 <dmwit> It's not there.
21:07:06 <hml> http://book.realworldhaskell.org/read/ <-- is this the beta or final?
21:07:07 <lambdabot> Title: Real World Haskell
21:07:15 <dmwit> Anyway, Myoma defined it backwards. =)
21:07:37 <dmwit> bool f t b = if b then t else f -- my preferred definition
21:07:42 <jsnx> guard has the effect of grabbing mzero when the value is false
21:07:49 <dmwit> jsnx: yes
21:07:52 <dmwit> ?src guard
21:07:59 <jsnx> no need to define the false value
21:08:11 <dmwit> guard False = mzero; guard True = return ()
21:08:27 <dons> hml, that's post-beta.
21:08:37 <Myoma> guard = bool mzero (return ())
21:09:07 <dmwit> jsnx: Actually, I have defined "ensure", which I use a lot more than guard.
21:09:08 <sjanssen> @src Maybe
21:09:18 <dmwit> ensure p x = guard (p x) >> return x
21:09:39 <dmwit> > let ensure p x = guard (p x) >> return x in ensure ((> 3) . length) [1,2,3,4]
21:09:40 <lambdabot>       No instance for (Show (m [a]))
21:09:40 <lambdabot>        arising from a use of `show' at <...
21:09:59 <dmwit> whoops
21:10:05 <sjanssen> hmm, should the False argument be first?
21:10:18 <sjanssen> this is more consistent with maybe/either
21:10:19 <dmwit> > let ensure p x = guard (p x) >> return x in ensure (> 3) 5 :: [Int]
21:10:20 <lambdabot>   [5]
21:10:25 <dmwit> sjanssen: I agree.
21:10:45 <sjanssen> though foldr breaks the convention, so who knows?
21:18:17 <waynemokane> dons: sorry to bug you but I really wanted an answer from before.. here's one paste with everything together:  http://hpaste.org/10091
21:21:17 <jsnx> dmwit: i am trying to abuse guard as a kind of ternary operator
21:21:33 <jsnx> boolVal ? list : []
21:22:09 <jsnx> and i started thinking about `maybe` and then i thought, there must be some way to get mzero in here to do it for me
21:22:34 <dmwit> yep
21:24:28 <Myoma> jsnx: I use bool instead of terniary operator
21:25:04 <Myoma> you could have like p ? x ::: y for some constructor :::
21:26:43 <BMeph`> It may just be my opinion, but Haskell seems to have trouble with defining operators. :|
21:26:55 <Myoma> what trouble?
21:26:56 <jsnx> dmwit: trouble
21:26:58 <jsnx> ?
21:27:12 <dmwit> BMeph`: It's better than just about any other language I've used.
21:27:18 <sjanssen> BMeph`: huh?  Not many other languages can define additional operators
21:27:20 <jsnx> > condition ? monadicValue = guard condition >> monadicValue
21:27:21 <lambdabot>   mueval: Prelude.read: no parse
21:27:27 <ddarius> dmwit: Use more languages.
21:27:33 * dmwit nods
21:27:34 <jsnx> @let condition ? monadicValue = guard condition >> monadicValue
21:28:10 <sjanssen> BMeph`: what do you think Haskell could do better?
21:28:30 <Olathe> It could use all of C's operators.
21:28:46 <BMeph`> E.g., issues defining unary operators (>cough< minus >cough<), differences between a parenthesized operator and a regular function with respect to back-quotes, defining operators that are "more" than binary.
21:29:10 <Myoma> obviously we need a Prolog frontend for haskell :)
21:29:23 <sjanssen> yeah, unary operators are a big problem
21:29:32 <Pseudonym> Myoma: LogicT!
21:29:55 <BMeph`> sjanssen: I suspect it's much easier once quasiquoting gets into the mix. It looks a little awkward (QQ) to my eye, although I appreciate the facility.
21:29:59 * ddarius thinks Haskell makes a reasonable compromise between implementability, extensibility, and understandibility.
21:30:38 <Pseudonym> I agree with ddarius in the sense that it's _almost_ on a sweet spot, and wouldn't take very much to hit said sweet spot.
21:30:38 <ddarius> You could definitely improve the flexibility of Haskell's operator syntax, but, in my opinion, for not much gain.
21:31:05 <Pseudonym> The only thing I'd overhaul is the module system.
21:31:16 <Pseudonym> Apart from that, it'd be a tweak here and a tweak there.
21:31:42 <dons> modules, yeah. there's some engineering things that would be good.
21:31:46 <Pseudonym> Yeah.
21:31:47 <dons> make 'error' harder to call
21:32:04 <Pseudonym> Yes, I'd design in exceptions from the start and encourage people to use them.
21:32:19 <Pseudonym> Having said that, there's something that'd be interesting to try.
21:32:23 <BMeph`> Maybe that's it - so much of Haskell is right on the sweet spot, that the few places where it isn't stand out. :)
21:32:30 <Pseudonym> Haskell is converging on System F.
21:32:38 <Pseudonym> Only without the explicit type-lambdas.
21:32:40 <mmorrow> i tried to add prefix operators to haskell-src-exts and every way i could think of to try it would go from 5 shift/reduce errors (the current expected count) to around 30+ reduce/reduce and 90+ shift/reduce errors (bearing in mind i didn't try for very long nor do i know exactly what i'm doing)
21:32:53 <Pseudonym> So it's kind of gone from Hindley-Milner to System F.
21:32:59 <Pseudonym> It'd be interesting to go the other way.
21:33:15 <BMeph`> dons: I like 'error'. I don't use it much, but I like it. I'd like it more if it were explicitly connected to the Exception module, but... :)
21:33:18 <Myoma> start with COC and make it more and more like haskell?
21:33:33 <mmorrow> the room for new syntax being able to be "just added" to existing parser is very small
21:33:35 <Pseudonym> Rather than what can you _add_ to HM while retaining HM's nice properties, answer the question of how much can you liberalise System F to make it as easy to use as HM.
21:33:45 <BMeph`> dons: As for 'fail,'... yeech! :(
21:34:09 <Pseudonym> That'd be a very interesting experiment, IMO.
21:34:22 <Myoma> Pseudonym: I think this is excatly what is happening with coq
21:34:37 <Myoma> typeclasses and such are added it is really interesting to see it happening
21:34:40 <Pseudonym> Coq isn't as easy to use as HM.
21:35:04 <Pseudonym> But Coq doesn't have the same goals as Haskell.
21:35:20 <Pseudonym> Haskell was designed to be a practical programming language for software engineering or something like that.
21:35:28 <Pseudonym> or at least to work towards that
21:35:37 <Pseudonym> It'd be interesting to do that starting with System F and working backwards.
21:36:00 <Pseudonym> Incidentally, by "System F", I of course refer to whatever your favourite variant is.
21:36:38 <jsnx> well, i just got finished convincing my boss that haskell was worth his time to learn
21:36:51 <Pseudonym> That much is definitely true.
21:36:52 <jsnx> last week we went over functors
21:36:57 <dons> jsnx: woot.
21:37:16 <jsnx> he pointed out some things to me about `>>=` which i had neglected, even
21:37:24 <ddarius> System FC_omega_sub_mu_nu
21:37:48 <jsnx> but now i'm going to have to talk him into learning coq, after i learn it...
21:37:48 <Pseudonym> Yeah, exactly.
21:38:00 <Pseudonym> How many people in the world know the difference between all those variants?
21:38:12 <Pseudonym> Probably a dozen at the most.
21:38:20 <jsnx> log(variants)
21:38:30 <Myoma> jsnx: Do you plan to write any programs in Coq?
21:38:44 <jsnx> well, it's just what seems to be cool these days
21:39:06 <jsnx> next year i'm going to come in this channel and everybody's going to be gone
21:41:32 <michaelgg> The RWH people should have a PayPal link so you can "buy" the book without having to get a shipped copy
21:42:15 <dons> i think o'reilly can do .pdfs
21:42:19 <michaelgg> Cause I personally know three people who are gonna read it online and not buy the book (international, shipping/customs/etc.)
21:42:21 <dons> so we'll see something on that soon.
21:42:25 <michaelgg> Oh cool
21:42:28 <ddarius> jsnx: They haven't left yet and I've been here since 2002.
21:42:38 <dons> michaelgg: can't amazon just ship anywhere?
21:42:46 <michaelgg> usually not
21:42:56 <michaelgg> but amazon shipping is only one side of it
21:43:02 <michaelgg> for instance, in El Salvador, there are no addressses
21:43:06 <michaelgg> so it makes it hard to *receive* :)
21:43:11 <dons> well, that's true enough. :)
21:43:27 <michaelgg> not to mention it can cost a bit of time and money to deal with "importing" stuff
21:43:56 <dons> you're in El Salavador?
21:44:02 <michaelgg> no
21:44:05 <dons> ah :)
21:44:07 <michaelgg> but i have people in Guatemala
21:44:12 <dons> ok.
21:44:13 <michaelgg> (i am shipping a copy or two down there anywyas)
21:44:17 <dons> cool
21:46:37 <Myoma> jsnx: I think it would be extremely cool to see some real programs
21:46:53 <Myoma> or libraries
21:47:03 <ddarius> Myoma: Write some.
21:52:12 * mmorrow heard Myoma was in #chess earlier asking this grandmaster if he dared face her chess program (which is alpha alpha btw)
21:52:55 * mmorrow adds that he did not
21:53:19 <jsnx> Myoma: i think we really need network services
21:53:38 <jsnx> write a Paxos service in Haskell, write a DNS server, &c.
21:53:56 <Myoma> lol
21:53:56 <jsnx> try this nice reliable program, without having to see or think about the code
21:54:00 * mmorrow notes third personally that Myoma's chess prog is over http
21:55:00 <jsnx> hmm, or what about a new sed, with an indentation token recognizer?
21:55:09 <jsnx> i am working on that today, actually
22:17:36 <jsnx> wow, the internet is broken
22:17:40 <MaxNanasy> How so?
22:18:08 <dons> no 'undo'
22:20:09 <SamB_XP> hmm. something is not right here.
22:20:32 <MaxNanasy> How so?
22:20:36 <SamB_XP> when I try to click on a google result, I get redirected to some junk website!
22:20:53 <mmorrow>  whatever it tells you to buy, do it.
22:21:06 <MaxNanasy> Does the "XP" in your nick refer to Windows?
22:21:10 <SamB_XP> I think I have some kind of really screwy spyware screwing up my domain-name resolution
22:21:53 <SamB_XP> (it happens in both IE and Firefox)
22:22:14 <mmorrow> weird
22:22:19 <MaxNanasy> If you stop using Windows, then your problem may go away.
22:22:40 * mmorrow agrees with MaxNanasy
22:22:41 <jsnx> MaxNanasy: we all wanted to say that, but none of us did :)
22:22:58 <michaelgg> unless you use debian ;)
22:22:59 <SamB_XP> this is true
22:23:05 <Myoma> what about debian?
22:23:08 <MaxNanasy> What's wrong with Debian?
22:23:11 <SamB_XP> michaelgg: what? debian can run win32 spyware?
22:23:27 <michaelgg> was making a offahnd comment about their ssl thing. maybe its no logner funny
22:23:35 <jsnx> so funny
22:23:35 <MaxNanasy> Anything can run Win32 spyware with WINE.
22:23:39 <Myoma> ahh that
22:23:44 <Myoma> I just didn't pick up
22:23:53 <SamB_XP> MaxNanasy: doubt that's sufficient to get it to work "properly"
22:24:11 <michaelgg> or if youre like plenty of users ive seen who will blindly apply a patch to their systems based off an unauthenticated patch to a mailing list :)
22:24:26 <jsnx> hahaha
22:24:46 <michaelgg> (Actually, i dont see how people running XPSP2/Vista get spyware if they have any idea what they're doing (i.e., NOT running arbitrary EXEs))
22:25:01 <SamB_XP> I don't see how I got it either
22:25:07 <michaelgg> 0day flash/quicktime stuff excepted
22:25:23 <SamB_XP> I think it must have been some kind of firefox exploit
22:25:27 <jsnx> the nice thing about running VMS is i don't have to deal with any of that stuff
22:25:31 <mmorrow> SamB_XP: did you get a welcome-to-the-botnet email?
22:25:32 <michaelgg>  I guess since flash just crashes on linux anyways the sploits dont work ;)
22:25:36 <SamB_XP> mmorrow: no
22:25:40 <mmorrow> haha
22:25:49 <SamB_XP> but how would they know my email address?
22:25:56 <SamB_XP> at least, I didn't NOTICE it if I got it
22:26:04 <mmorrow> the know how many hairs are in you left nostril now
22:26:12 <mmorrow> *they
22:26:12 <jsnx> lolz
22:26:48 <SamB> I don't see one
22:27:44 <mmorrow> hmm, curious. maybe you'll prob get one after the currently running spam batch is done sending?
22:28:18 <dmead_home> @hoogle trim
22:28:41 <dmead_home> > "hello"
22:28:42 <lambdabot>   "hello"
22:28:49 <dmead_home> @google trim
22:28:52 <dmead_home> @hoogle trim
22:29:07 <dmead_home> :t trim
22:29:08 <lambdabot> Not in scope: `trim'
22:30:00 <dmead_home> yuck yuck
22:30:00 <dmead_home> http://en.wikipedia.org/wiki/Trim_(programming)
22:30:09 <mmorrow> > let triml = dropWhile isSpace ; trimr = reverse . triml . reverse ; trim = trimr . triml in trim "   asdfghjkl     "
22:30:10 <lambdabot>   "asdfghjkl"
22:30:32 <mmorrow> i've seen it done (and have done it) like that before
22:31:09 <mmorrow> (if that's even what you're refering to ;))
22:37:44 <Myoma> dmead_home: what about it ?
22:38:03 <dmead_home> what?
22:38:27 * Myoma wondering why you linked to wikipedia article about trim
22:43:55 <quicksilver> the mere fact that a ridiculously simple and boring standard library function in a particular language gets a wikipedia page perhaps? :)
22:44:18 <Myoma> hah I didn't think of that
23:01:05 <noohgodno> TELL ME WHAT PROGRESS WE'RE MAKING WITH DEVELOPING HASKELL-BASED AI
23:01:14 <dons> we're making progress.
23:01:24 <noohgodno> LIKE WHAT
23:01:26 <Myoma> noohgodno: I'm writing an AI in haskell later
23:01:31 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:AI
23:01:36 <lambdabot> Title: HackageDB: packages by category
23:01:41 <dons> stop using capitals, thank you.
23:01:41 <noohgodno> <3
23:01:48 <Myoma> and by AI I mean completely mechaninical simple program that doesn't think
23:02:11 <vegai> why would you want that? The planet's full of those
23:02:18 <noohgodno> I'M TALKING ABOUT ARTIFICIAL NEURAL NETWORKS THAT PROVIDE THE BASIS FOR LEARNING BY ABSTRACTLY PERFORMING INDUCTION UPON ANY GIVEN DATA SETS
23:02:33 <thetallguy> Well we can dig it.
23:02:46 --- mode: ChanServ set +o dons
23:03:24 * noohgodno (a tumbleweed rolls by)
23:03:36 * noohgodno stares intently at dons, his fingers arching outward towards his holster
23:03:56 <Myoma> haha
23:04:00 * noohgodno (a violin plays)
23:04:14 <Myoma> "you yellow belly jellyfish ... draw"
23:04:38 * noohgodno shoots dons in the face
23:04:57 <noohgodno> dammit! i gotta beat the rap on this one
23:05:02 * noohgodno rides off on his horse
23:05:10 <noohgodno> i showed that guy, back there
23:06:50 <noohgodno> anyway, my theory is, the selective induction of input by learnt functions (not the piecewise kind) will result in the ability to make abstractions about the data
23:06:58 <noohgodno> that's not my theory, but
23:07:38 <Myoma> noohgodno: I heard that every problem NNs have ever been applied so far to can be solved much better with specific algorithms (which have already been invented)
23:07:46 <noohgodno> technically if you can do that in a modelling environment that's sufficiently complex
23:07:58 <noohgodno> maybe in 3d cartesian space, and grant it the ability to input data
23:08:07 <noohgodno> it could recreate modern science in its entirety, within a few days
23:08:31 <noohgodno> i think the trick is just turtle-stacking layers of abstraction
23:09:33 <noohgodno> the idea is that you can implement the AI universally
23:12:49 --- mode: dons set +b *!*@syru152-180.syr.edu
23:20:36 <Myoma> uh ?
23:20:53 <Myoma> random bannings
23:21:17 <dons> this guy has a nice history of bans, sadly.
23:21:49 <dons> one of those ranty, i-don't-care-this-is-the-internet kind of guys.
23:22:07 --- mode: ChanServ set -o dons
23:22:16 <Myoma> let's slag off jon harrop for a while instead then
23:22:22 <thoughtpolice> i will say i liked the wild-wild-west reference
23:22:25 <thoughtpolice> that's about it, though.
23:22:32 <dons> so we do temp domain bans, and try again later.
23:22:58 <dons> so far seems to be fairly effective at scaling up the quality of the channel, along side the growth in size
23:23:09 <dons> and we're getting quite a body of lore regarding when and how to control things.
23:23:29 <dons> for example, tor seems to be used primarily for spammers now, so we redirect them into a channel of their own.
23:23:36 <dons> they seem not to know they're in the real #haskell :)
23:24:35 * Beelsebob yawns
23:24:43 <thoughtpolice> even for spamming/trolling tor can be pretty unbearable.
23:25:01 <thoughtpolice> takes lots of dedication i guess
23:25:15 <dons> it seems there's few valid users
23:26:15 <dons> or, if people's connections are bouncing, we can redirect them.
23:26:19 <dons> not sure if that's been tried yet.
23:26:55 <dons> unlike some places, we seem to stay fairly on topic , interestingly.
23:27:03 <dons> so no voicing tricks have been attempted
23:27:13 <Beelsebob> that's somewhat risky (the tor users) -- surely you can end up sending a legit user into a room full of spammers, and make them think the Haskell community are a bunch of cocks
23:27:29 <dons> well, the ops are in the same channel.
23:27:39 <dons> and we just ban the spammers.
23:27:46 <thoughtpolice> i was considering using tor since my uni network doesn't like irc or something apparently - which wouldn't be a damn problem if freenode supported SSL - but instead opt'd for mibbit because it's still basically a bounce and doesn't totally suck
23:27:46 <dons> so far though, we've not see a real tor user yet.
23:28:00 <Beelsebob> ah, cool
23:28:05 <dons> i imagine real people using tor identify themselves
23:28:09 <Beelsebob> so it just acts as a spam mailbox
23:28:23 <dons> yeah, you'll see less crazy spam in here, since its all in the spam channel.
23:28:44 <Beelsebob> thoughtpolice: that's the moment to ssh out and use irssi ;)
23:28:57 <thoughtpolice> beelsebob: yeah see, I considered that
23:29:03 <thoughtpolice> then it occurred to me,
23:29:07 <newbieyu> test
23:29:11 <newbieyu> hi guys
23:29:14 <thoughtpolice> I don't have a box anywhere I can ssh into and use irssi
23:29:18 <thoughtpolice> since most people place restrictions on it
23:29:26 <thoughtpolice> personally I wish freenode would just support SSL damnit
23:29:28 <newbieyu> i have a question from yaht
23:29:54 <newbieyu> Write a datatype Quadruple which holds four elements. However, the first two elements must be the same type and the last two elements must be the same type. Write a function firstTwo which returns a list containing the first two elements and a function lastTwo which returns a list containing the last two elements. Write type signatures for these functions
23:30:02 <SamB> thoughtpolice: place restrictions on what?
23:30:05 <newbieyu> what does it mean by "type signatures"
23:30:31 <dons> f :: Int -> Int
23:30:34 <dons> is a type signature
23:30:38 <dons> f x = x * 2
23:30:40 <dons> is a function
23:30:40 <thoughtpolice> SamB: lots of the places I've ever had a free shell don't like long running processes, e.g. irssi or irssi + screen so I can connect from wherever
23:30:51 <newbieyu> i couldn't figure out how to do the part where it says the first 2 element is the same type, and the last 2 is the same type
23:30:57 <thoughtpolice> so they simply don't install them normally
23:31:36 <SamB> tried Lemmih ?
23:31:46 <thoughtpolice> i mean mibbit works right now, but I would prefer to not use it and that will happen when A) I get a reliable bounce that does not suck (tor) and I can trust reasonably, or B) freenode supports SSL
23:31:53 <thoughtpolice> Lemmih gives out shells?!
23:31:58 <Beelsebob> newbieyu: well, what type does "something with any type" have?
23:32:17 <Beelsebob> i.e. if I write f x = x -- then what type does x have?
23:32:42 <cjs> a
23:32:57 <newbieyu> i tried putting Int Int String String but does not work
23:33:07 <newbieyu> i'' post my code up
23:33:09 <SamB> Beelsebob: supercalafragilisticexpialadocious
23:33:14 <Beelsebob> well, the point is that we don't want to restrict ourselves to Ints and Strings newbieyu
23:33:34 <Beelsebob> we want to be able to call your function with Chars in the first part, and Monkeys in the second part
23:33:42 <Beelsebob> or any other wierd and wonderful types we can think of
23:33:56 <SamB> Kitteh and Munkie
23:34:13 <Beelsebob> so in Haskell we have a way of specifying "anything you want" -- you just use a lowercase letter, instead of an uppercase one
23:34:14 <SamB> @google inferred type kitteh
23:34:19 <newbieyu> monkey?
23:34:24 <newbieyu> http://www.mibbit.com/pb/0AvtIO
23:34:30 <lambdabot> Title: Mibbit: PasteBin
23:34:42 <Beelsebob> newbieyu: dunno -- I just made it up -- the point is, I *could* define a type called Monkey, and want to call your function with it
23:34:46 <mauke> newbieyu: almost right
23:34:56 <newbieyu> my quad is something wrong
23:35:08 <newbieyu> i dont know how to make them both same types
23:35:14 <mauke> newbieyu: yes, Quad should have only two type parameters
23:35:19 <SamB> wadler's been caml trading?
23:35:27 <Beelsebob> mauke: no, it should have 4, named differently
23:35:33 <Beelsebob> and the function should restrict the types
23:35:33 <mauke> data Quad a b = Quad a a b b
23:35:41 <Beelsebob> data Quad a b c d = Quad a b c d
23:35:46 <mauke> Beelsebob: that's not how I remember the exercise
23:35:51 <Beelsebob> oh, okay
23:35:57 <Beelsebob> this is something specific from the book?
23:36:04 <mauke> yes
23:36:06 <newbieyu> exercise? mauke done that before?
23:36:08 <SamB> Beelsebob: that's not how newbieyu presented it either
23:36:13 <newbieyu> its from yaht - yet another haskell
23:36:24 <mauke> newbieyu: no, I've just seen people with the exact same problem coming here :-)
23:36:25 <Beelsebob> SamB: yeh, but if mauke knows it -- he can help more easily
23:36:31 <SamB> both newbieyu and mauke say it's the type that gives this constraint
23:36:42 <SamB> not the function
23:37:10 <newbieyu> i get this error  ERROR file:.\haskellirc.hs:17 - Repeated variable "a" in pattern
23:37:36 <newbieyu> one way to get rid that error, is all letters must be different, or no repeats
23:37:42 <mauke> yeah, they're still four different values and you need to use different variable names for them
23:37:54 <newbieyu> variable names? how o_o
23:38:34 <mauke> data Quad a b = Q a a b b  -- renaming the data constructor so we can talk about it more easily
23:38:43 <mauke> firstTwo (Q a b c d) = ...
23:39:02 <mauke> or firstTwo (Q foo bar baz qux) = ...
23:39:45 <SamB> isn't it spelled quux ?
23:40:05 <mauke> yes, but that's too long
23:40:09 <ikegami--> tibbe: hello, I'm interested in your web server in Haskell
23:40:11 <mauke> qux is OPTIMIZED
23:40:16 <ikegami--> I heard from dons about that
23:40:18 <SamB> oh, wait, apparantly quux is next ???
23:40:42 <mauke> qu{2,}x
23:40:43 <SamB> oh, no, quux is the real thing
23:41:30 <SamB> as in quux.org
23:41:39 <newbieyu> hey guys i tested it out, but stil no luck
23:41:39 <SamB> gopher://quux.org
23:41:45 <SamB> lambdabot: what's your problem!
23:41:55 <SamB> you're supposed to proclaim the title of the page
23:41:57 <mauke> newbieyu: what's the error?
23:42:30 <SamB> hmm, apparantly gopher pages don't have titles?
23:42:55 <Beelsebob> blimeh, what's with jonathan cast?
23:43:17 <SamB> http://www.catb.org/jargon/html/Q/qux.html
23:43:17 <lambdabot> Title: qux
23:43:28 <SamB> http://www.catb.org/jargon/html/M/metasyntactic-variable.html
23:43:29 <lambdabot> Title: metasyntactic variable
23:43:36 <newbieyu> ERROR file:.\haskellirc.hs:17 - Undefined variable "x".
23:43:50 <mauke> newbieyu: and what's line 17?
23:44:29 <SamB> hmm, shouldn't it go fred, wilma, barney, [whatever-barney's-wife's-name-is] ?
23:44:39 <mauke> betty
23:44:45 <newbieyu> wait i'll post up a new code
23:44:55 <SamB> rather than fred, jim, sheila, barney ?
23:45:58 <dons> Beelsebob: yeah, i know. sometimes people feel down about things
23:46:05 <SamB> hmm, for some reason I think the "spam, eggs" should be "spam, spam, spam, eggs"
23:46:14 <newbieyu> http://www.mibbit.com/pb/ULmoVt
23:46:15 <lambdabot> Title: Mibbit: PasteBin
23:46:18 <SamB> (can you imagine why that might be?)
23:46:39 <Beelsebob> dons: seems odd to want Haskell to remain a language that only researchers want to use, because you're a researcher and you like it
23:46:45 <mauke> newbieyu: that doesn't contain 'x'
23:46:46 <newbieyu> *** Expression     : foo bar *** Term           : bar *** Type           : a -> b *** Does not match : a *** Because        : unification would give infinite type
23:46:54 <mauke> ah, now we're getting somewhere
23:47:06 <newbieyu> i clear out the other stuff, the previous tutorials i done, so it would not clutter/confuse
23:47:10 <newbieyu> :)
23:47:12 <Beelsebob> the worst that could happen is that he as a researcher forks it, and goes on having fun with the new fork
23:47:17 <SamB> Beelsebob: well, all these users sometimes get a bit annoying
23:47:21 <mauke> newbieyu: the expression 'foo bar' means 'call the function foo with an argument of bar'
23:47:38 <Beelsebob> SamB: this is true
23:47:39 <newbieyu> mauke o_o
23:47:44 <mauke> what
23:47:45 <dons> Beelsebob: oh interesting. and i found it odd to suggest that there'd be a 'pragmatic' fork over ACIO.
23:47:53 <newbieyu> mauke: so do i need to change the name of the variables or something
23:48:00 <SamB> Beelsebob: always wanting backwards compatability and such nonsense
23:48:00 <mauke> newbieyu: no, that makes no difference
23:48:00 <dons> researchers do forks all the time
23:48:11 <Beelsebob> SamB: agreed
23:48:27 <Beelsebob> dons: exactly -- that's what I'm getting at -- that it's no real penalty for him to fork it
23:48:30 <Beelsebob> so what's he moaning about
23:48:40 <newbieyu> mauke: so how do i fix it ?
23:48:42 <SamB> I want it too, actually ... I want compatability with pred Haskell98
23:48:49 <dons> so i don't know. that GHC was going to be forked to add ACIO, and all the practical people would leave? :)
23:48:49 <SamB> ;-P
23:49:00 <dons> seems like maybe he misread the direction?
23:49:26 <mauke> newbieyu: to return two values, you need to bundle them up into a single value
23:49:48 <mauke> newbieyu: e.g. by saying firstTwo (Q foo bar baz qux) = Pair foo bar
23:50:06 <mauke> (this assumes there's a definition of 'Pair' around)
23:50:31 <newbieyu> oh ok
23:50:38 <newbieyu> i just deleted my Pair function T_T
23:50:51 <hackage> Uploaded to hackage: ieee-utils 0.3
23:50:51 <hackage> Uploaded to hackage: unicode-names 3.2.0.0
23:50:51 <hackage> Uploaded to hackage: unicode-properties 3.2.0.0
23:50:52 <hackage> Uploaded to hackage: CouchDB 0.8.0.1
23:50:54 <hackage> Uploaded to hackage: ansi-wl-pprint 0.2
23:50:58 <mauke> eek
23:51:07 <dons> oops. there it is.
23:51:30 <SamB> dons: I guess nobody told him that it's not pragmatic to fork a compiler to keep out a feature unless it becomes a cross-cutting concern?
23:52:21 <dons> i note my lambdabot at galois has now reached 23:52  lambdabot> uptime: 1m 25d 13h 51m 51s
23:52:25 <newbieyu> i added Pair ,but does not work
23:52:28 <dons> fairly light use.
23:52:39 <newbieyu> do i need to add comma or something
23:53:00 <dons> Cale, my stable bot seems to be Sun Feb 17 18:42:50 PST 2008
23:53:01 <newbieyu> hi mmorrow
23:53:16 <mmorrow> hey newbieyu
23:53:26 <mmorrow> howsit coming?
23:53:42 <SamB> @yow
23:53:46 --- mode: ChanServ set +o dons
23:53:51 --- mode: dons set -b *!*@syru152-180.syr.edu
23:54:08 * SamB pokes lambdabot with a pointy stick
23:54:13 --- mode: dons set -b *!*@bzq-219-46-202.isdn.bezeqint.net
23:54:16 <newbieyu> hi mmorrow, i have some problems with my yaht tutorial
23:54:23 --- mode: dons set -b *!*@https.ftp.sh
23:54:30 --- mode: dons set -b *!*n=WP-Gast@*.dclient.hispeed.ch
23:54:31 * SamB glances at Cale 
23:54:48 --- mode: ChanServ set -o dons
23:54:50 <mmorrow> which part?
23:54:57 * SamB raises his eyebrows at Cale, too
23:55:33 <mmorrow> @botsmack
23:55:45 <newbieyu> http://www.mibbit.com/pb/EXBbcH
23:55:46 <lambdabot> Title: Mibbit: PasteBin
23:56:21 <newbieyu> mmorrow: i am able to load it perfectly, but when i try to use it, it post errors
23:56:33 <mauke> what's the error?
23:56:41 <newbieyu> like: firstTwo 1 2 'a' 'b'
23:56:42 <newbieyu> firstTwo 1 2 'a' 'b' ERROR - Type error in application *** Expression     : firstTwo 1 2 'a' 'b' *** Term           : firstTwo *** Type           : Quad f g -> Pair f f *** Does not match : a -> b -> c -> d -> e
23:56:58 <mauke> yeah, you need to give it a Quad, not four separate values
23:57:06 <mauke> firstTwo (Q 1 2 'a' 'b')
23:57:22 <mauke> (and THAT will probably complain about a missing Show instance)
23:58:12 <mmorrow> a -> b -> c -> d -> e
23:58:14 <mmorrow> 1    2    3    4
23:58:43 <mmorrow> a -> b -> c -> (d -> e) -> f
23:58:49 <mmorrow> 1    2    3       4
23:59:28 <mmorrow> Quad f g -> Pair f f
23:59:31 <mmorrow>    1
