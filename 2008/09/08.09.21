00:00:02 <Axman6> die everywhere
00:00:03 <sjanssen> Axman6-- lispy++
00:00:18 <sjanssen> Axman6: you get your karma back if you can justify that statement :)
00:00:45 <Axman6> is the pain of X11 really worth the ssh -X?
00:01:02 <Axman6> i'd much prefer something (anything) that just works
00:01:02 <sjanssen> Axman6: what pain?
00:01:25 <Axman6> i've never had an auto config for X11 work the way it should
00:01:28 <sjanssen> Axman6: also, note you initially complained about the protocol, not the implementation
00:01:32 <sjanssen> so please stay on topic :)
00:01:44 <sjanssen> Axman6: XFree86/X.org issue, not an X11 issue
00:01:50 <Axman6> ok, well the implementation sucks then ;)
00:02:05 <sjanssen> do you recant your words about X11?
00:02:58 <Axman6> i don't know enough about to go into any depth. all i do know if the alternatives work well, Xorg (and Xfree86) do not
00:03:09 <Twey> sjanssen, the brave knight of shining armour of X11!
00:03:16 <Twey> Alternatives?
00:03:33 <sjanssen> Axman6++
00:03:35 <Axman6> whatever windows uses and Quartz
00:03:45 <Axman6> especially Quartz ;)
00:03:53 <sjanssen> Axman6: also, I don't think that X.org is so bad, but I can accept differing opinions on that point
00:03:54 <Twey> Ah-huh
00:03:57 <sjanssen> Axman6: Quartz isn't free
00:04:01 <sjanssen> and free matters
00:04:03 <Axman6> so?
00:04:17 <Axman6> i'm more than willing to pay for something that works
00:04:25 <Twey> Not that kind of free
00:04:39 <sjanssen> Free as in speech, as they say
00:04:42 <Axman6> i know
00:04:49 <Twey> But Axman6 was comparing them purely in a technical scope, rather than considering licensing
00:05:10 <Twey> Axman6: It seems to me your issues are mainly with the autoconfig apps
00:05:32 <Olathe> Yes, those applications suck.
00:05:36 <ozy`> Axman6: it doesn't matter if it's 4-bit, character-based, written in assembly for MIPS, and displays every 11th window backwards... so long as it's Free as in speech
00:05:37 <sjanssen> Axman6: btw, when was the last time you've tried X.org?  Their new configless stuff is supposedly better
00:05:37 <Axman6> anything running in X11 always feels hackish to me
00:05:59 <Olathe> There's configless stuff out now ?
00:06:02 <Olathe> That sounds nice.
00:06:03 <ozy`> Axman6: switch to Linux and run a nicer window manager
00:06:05 <Axman6> sjanssen: about a week ago? in Arch linux
00:06:08 <Twey> New one on me, too
00:06:10 <Axman6> urgh
00:06:13 <Axman6> anything but linux
00:06:26 <Axman6> FreeeBSD, OpenBSD, OS X, that;s fine
00:06:30 <Axman6> '*
00:06:38 <ozy`> so go FreeBSD and run a nicer wm
00:06:42 <lispy> I have to be honest, linux ain't so nice with most laptop hardware
00:06:43 <Axman6> i'm just sick of the whole linux world
00:06:44 <Twey> To quote someone I saw recently
00:06:48 <sjanssen> Axman6: do you know if they're using configless X.org, or is it something else?  All config dialogs suck, I certainly agree with that
00:06:56 <Twey> 'BSD?  You must be joking, BSD is still using OSS'
00:06:57 <Axman6> ozy`: does it get nicer than Xmonad? :)
00:07:15 <Twey> lispy: On one now
00:07:17 <ozy`> Axman6: disclaimer: I have no idea what I'm talking about
00:07:22 <Twey> Out-of-the-box, pretty much :)
00:07:27 <Axman6> sjanssen: could have a lot to do with the fact it was in VMware (which Arch does not play nicely with. 64 bit at leats)
00:07:30 <Axman6> least*
00:07:37 <lispy> Well, we are very far off topic now
00:07:41 <Axman6> ozy`: yeah i had a feeling :P
00:07:54 <Nafai> Here's a chance for a little Haskell/FP evangelism: http://stackoverflow.com/questions/109193/what-language-feature-can-you-just-not-live-without
00:07:56 <lambdabot> Title: What Language Feature Can You Just Not Live Without? - Stack Overflow, http://tinyurl.com/3j9g5t
00:08:28 <sjanssen> dibblego++ awesome reddit comment re: brain surgery
00:09:39 <Nafai> dibblego++ indeed
00:17:10 <TommyOnMac> morning
00:20:30 <Olathe> A cute little game: http://www.gameroo.nl/games/light-bot
00:20:40 <lambdabot> Title: Light Bot - Gameroo
00:21:28 <mc__> Olathe: have you been able to solve  lvl 10?
00:22:04 <Olathe> Oh, I went to 4 until my browser crashed.
00:26:32 <ac> cool. Finished moppy, sausage, and banana2. The way I implemented they each depended on the next
00:26:54 <ac> I'm sure @src will show me a much more elegant set of solutions
00:26:56 <IsoPallo> Ahem... I think I'm in the need of a Haskell psychiatrist.
00:27:29 <TommyOnMac> M-x psychiastrist is the closest you can get right now I think
00:27:33 <ac> Axman6: here's my banana2: banana2 f a b = apple b $ furry' f a
00:27:40 <IsoPallo> Is it normal to feel a need to parametrize all your datatypes and classes over all the things you can think of?
00:27:51 <ac> Axman6: and here's my sausage: sausage l = foldl (banana2 (++)) (unicorn []) (map (furry' (:[])) l)
00:28:04 <ac> @src liftM2
00:28:04 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
00:28:28 <ac> @src sequenceM
00:28:28 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:28:40 <ac> @src sequence
00:28:40 <lambdabot> sequence []     = return []
00:28:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:28:40 <lambdabot> --OR
00:28:40 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:29:01 <IsoPallo> I'm lately started to feel incapable of even using String for identifiers and labels, because there *might* be a some otherway in the future...
00:29:31 <IsoPallo> So I parametrize the thought away...
00:31:57 <bogomipz> ?
00:52:49 <ivanm> dons: do you want to reply to Andrew Coppin about packaging for distros?
00:53:06 <dons> i attempted to, and have given up.
00:53:16 <dons> http://hackage.haskell.org/trac/hackage/wiki
00:53:25 <lambdabot> Title: Hackage - Trac
00:53:32 <dons> basic points i wanted to make: end users, binaries, dependency tracking, batteries included
00:54:11 <dons> but he needs too much background i think
00:54:36 <Axman6> Olathe: wow, level 10 of that game sucks :|
00:55:34 <Axman6> dons: i heard back from Ben. he said he might be interested in starting up a canberra FP group, or joining the sydney or something :)
00:57:37 <mc__> Axman6: were you able to solve it?
00:57:43 <Axman6> not yet
00:57:55 <hackage> Uploaded to hackage: vector 0.2
00:58:59 <Olathe> mc__: Just solved it :)
00:59:55 <ivanm> since I'm not sure whether my last two messages came through, I'll say them again
00:59:57 <ivanm> dons: biggest reason: non-haskell dependencies (or, in the case of packages using gtk2hs, non-caballable dependencies)
01:00:00 <ivanm> e.g. I used hackport to create the ebuild for graphviz... then realised today that I forgot to add a dependency for the _real_ Graphviz app ;-)
01:03:04 <dons> ivanm: there's a gazillion other reasons: all to do with users.
01:03:22 <Stinger> damn users
01:03:24 <dons> i'm not sure andrew's written anything that depends on non-core libraries though, that's true.
01:04:00 <dons> he has a gift for inciting responses.
01:04:54 <vegai> what a civilized way to call someone a troll :)
01:05:59 <thoughtpolice> dons: I pointed a few things out to him
01:06:34 <thoughtpolice> mainly having distro-packages for haskell libraries/tools makes it easier to install apps for users who might not write haskell, but want a haskell application like pandoc or darcs
01:06:54 <thoughtpolice> (OT: pandoc is awesome)
01:08:03 <dons> vegai: he's not really trolling though, just not willing to do research.
01:08:24 <dons> thanks thoughtpolice
01:11:47 <zeno> what the... fibs = fix $ (0:) . (1:) . ap (zipWith (+)) tail
01:11:59 <zeno> @src fix
01:12:00 <lambdabot> fix f = let x = f x in x
01:12:31 <zeno> oh haha crafty
01:12:45 <thoughtpolice> y combinator, to the rescue!
01:12:57 <arjanb> is haskell.org down?
01:13:06 <thoughtpolice> seems so
01:14:56 <thoughtpolice> also does anybody know who I can talk to about getting my SSH key reset on community.haskell.org? it was registered to my old public key on my old system and then I got this macbook and generated a new key...
01:15:05 <thoughtpolice> very inconvenient not being able to update ssh keys, that.
01:30:57 <electronx> question was the fastest way of counting the frequency of words in a list?
01:31:02 <electronx> is*
01:31:36 <electronx> say i got a million words in a list a i want to count occurances of each word is a Tree the fastest way?
01:31:37 <thetallguy> Here's a bleary eyed question:
01:32:05 <electronx> also each word is [Char]
01:32:27 <thetallguy> if   (f fst xs, f snd xs) compiles, should (f fst &&& f snd) xs compile?
01:34:22 <Olathe> @type (f fst xs, f snd xs)
01:34:24 <lambdabot> Not in scope: `xs'
01:34:24 <lambdabot> Not in scope: `xs'
01:34:31 <Olathe> @type \f, xs -(f fst xs, f snd xs)
01:34:32 <lambdabot> parse error on input `,'
01:34:34 <Olathe> @type \f, xs -> (f fst xs, f snd xs)
01:34:35 <lambdabot> parse error on input `,'
01:34:42 <Olathe> OK
01:34:42 <Deewiant> @type \f xs -> (f fst xs, f snd xs)
01:34:43 <lambdabot> forall t a t1. (((a, a) -> a) -> t -> t1) -> t -> (t1, t1)
01:35:00 <Olathe> @type \f xs -> (f fst && f snd) xs
01:35:01 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `Bool'
01:35:01 <lambdabot>     In the expression: (f fst && f snd) xs
01:35:04 <Olathe> @type \f xs -> (f fst &&& f snd) xs
01:35:05 <lambdabot> forall a b c. (((a, a) -> a) -> b -> c) -> b -> (c, c)
01:35:05 <electronx> also how do i pack [Char] into ByteString?
01:35:08 <Olathe> Yay, typing.
01:35:18 <ddarius> electronx: pack
01:35:20 <Olathe> You have to type correctly to get correct types.
01:35:35 <electronx> pack takes [Word8]
01:35:39 <ddarius> Particularly, Data.ByteString.Char8
01:35:41 <Deewiant> electronx: w2c
01:35:51 <ddarius> @hoogle [Char] -> ByteString
01:35:52 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:35:52 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:35:52 <lambdabot> Prelude read :: Read a => String -> a
01:35:52 <Deewiant> available in Data.ByteString.Internal
01:36:00 <Deewiant> @hoogle Char -> Word8
01:36:00 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
01:36:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:36:00 <lambdabot> Prelude read :: Read a => String -> a
01:36:19 <electronx> ah good old hoogle
01:36:51 <electronx> what about my above question?
01:36:59 <electronx> the other one
01:37:01 <electronx> :)
01:38:56 <electronx> word frequencies
01:42:38 <electronx> anyone?
01:42:59 <ddarius> electronx: Asymptotically, no.
01:43:06 <thoughtpolice> couldn't you just use a fold over a file?
01:43:11 <thoughtpolice> enumerators!
01:43:37 <electronx> i didn't mention that i need to then get a list of top n occurences
01:44:18 <electronx> doesn't each word need to cross refrence each other word then?
01:44:30 <ddarius> Why?
01:44:32 <electronx> Tree seems easy just keep inserting
01:44:59 <electronx> if word already in list just icrement its count
01:45:11 <ddarius> You didn't ask for easiest.  You asked for fastest.  I'd personally recommend that you do something reasonably straight forward and then see if you have performance problems.
01:45:29 <electronx> so what would be that fastest?
01:45:32 <thoughtpolice> just fold over the file and pass around a structure that represents all the words you have found so far and their associated counts
01:45:34 <electronx> the*
01:46:11 <ddarius> electronx: Asymptotically, you should be able to figure this out.  The analysis is no different in Haskell than any other language.
01:46:15 <electronx> thoughtpolice: thats one way of doing it but i need to preprocess file
01:46:21 <thoughtpolice> why?
01:46:29 <electronx> html
01:46:53 <thoughtpolice> why should it make a difference? you're going to pre-process in a separate phase from the actual counting of words
01:47:24 <ddarius> What's most performant in practice would require benchmarking.
01:47:40 <thoughtpolice> (which is the definition of pre-processing, really)
01:47:54 <thoughtpolice> strip all the tags, take everything that isn't a tag, and pass it to a fold that simply enumerates and counts the words
01:48:39 <electronx> thoughtpolice what would be fastest to store the words? hash map or tree of sorted list or array of some sort is the question
01:48:58 <electronx> or after tree*
01:49:18 <thoughtpolice> like ddarius said what's going to be the fastest is going to require benchmarking in practice
01:49:27 <electronx> ok
01:49:33 <ddarius> electronx: This is a question you should be able to derive a decent answer yourself.
01:49:57 <electronx> ddarius: i just don't have time to experiment thats all
01:49:58 <Vq^> my bet is a radix-tree
01:50:32 <ddarius> electronx: You don't need to experiment to come up with a reasonable choice of data structure.
01:50:34 <electronx> ah radix_tree i'll google it
01:50:54 <electronx> ddarius: see i didn't know about radix trees :)
01:51:02 <electronx> thats why i ask
01:51:02 <Vq^> electronx: http://upload.wikimedia.org/wikipedia/commons/a/ae/Patricia_trie.svg
01:51:05 <lambdabot> http://tinyurl.com/3mgkz2
01:51:37 <electronx> Vq^: looks perfect :)
01:51:40 <electronx> thanks
01:53:23 <Axman6> Cale: you around?
01:53:42 <electronx> @seen Cale
01:53:43 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 2h 6m 23s ago.
01:53:56 <maltem> electronx: Actually I'd just start out with Data.Map and just replace it with a different implementation when it turns out not to be fast enough
01:55:00 <maltem> electronx: Which has the side effect of making your potential radix tree impl. easy to reuse, because the API would be similar to Data.Map
01:56:03 <inimino> electronx: I'm working on something very similar, how big is your dataset?
01:56:35 <electronx> about 18 million words
01:57:29 <inimino> depending on how much memory you want to use, you might want to write out intermediate files and then merge them
01:57:36 <inimino> that's what I'm doing
01:58:41 <electronx> ok
01:58:51 <electronx> thanks for help everyone
01:58:54 <inimino> then you can get your final result without ever having to keep a data structure with all the words you're interested in in memory at once
01:58:57 <thoughtpolice> you can just read the file lazily off disk and it should run in constant-time for the most part
01:59:05 <ddarius> For the use he described, there's no need to have large amounts of text in memory at a time.  Also, with a trie structure, it's really not going to be all that much memory.
01:59:20 <ddarius> (even if he did have it all in memory at once)
01:59:32 <thoughtpolice> for example, reading the file into a lazy bytestring would be a good method for performance, but you can't just use Data.Map for example as bytestring's can't be key's for a map
01:59:58 <inimino> I tried it with Data.Map and ByteStrings first
01:59:58 <thoughtpolice> of course lazy io has its issues so you can also use oleg-style enumerators to still get constant-memory with more predictable resource management and termination
02:00:16 <inimino> (you just write a hash function)
02:00:40 <inimino> but the memory usage wasn't acceptable in my situation, his may be different of course
02:00:49 <thoughtpolice> with lazy bytestrings?
02:01:15 <ddarius> If I were writing this, I'd just use a hash function and an array, followed by a linear pass at the end.
02:01:16 <inimino> the problem was the map, not the input
02:01:23 <thoughtpolice> ah
02:01:57 <Axman6> @hoogle State
02:01:57 <lambdabot> module Control.Monad.State
02:01:57 <lambdabot> Test.HUnit.Base data State
02:01:57 <lambdabot> Test.HUnit.Base State :: Path -> Counts -> State
02:02:52 <maltem> thoughtpolice: Why can't ByteStrings be keys for a map?
02:02:55 <inimino> now I'm going with more of a map-reduce style solution which runs in constant space at the cost of a little disk IO
02:03:35 <thoughtpolice> maltem: many of the functions have an Ord constraint, e.g. insertWith
02:03:43 <Axman6> inimino: but... but... thar be dragons in IO :O
02:03:56 <maltem> thoughtpolice: ByteStrings are ordered, so what?
02:04:01 <Axman6> it even looks like an evil emoticon robot!
02:04:36 <inimino> oops, Data.Map is the one that uses trees, it was Data.HashTable I tried first
02:04:49 <thoughtpolice> maltem: gah, sorry. yeah you're right, I get real used to just looking at the instances in the Data.Map module
02:05:10 <maltem> heh ok
02:05:15 <ddarius> inimino: From what I hear, Data.HashTable is a pretty crummy implementation
02:05:50 <inimino> Axman6: yeah, I'm trying to get the IO stuff all it one place, with some sort of enumerator-like interface
02:06:01 <inimino> ddarius: that would be consistent with my experience
02:07:41 <ddarius> I should implement burst tries.  I don't have any use for them, and I don't see too many other people having use for them, but it would be fun.
02:08:18 <inimino> what's a burst trie?
02:08:53 <ddarius> @google "burst trie"
02:08:56 <lambdabot> http://www.cs.mu.oz.au/~jz/fulltext/acmtois02.pdf
02:08:57 <lambdabot> Title: Burst Tries: A Fast, Efficient Data Structure for String Keys
02:10:15 <Axman6> oh, gtfo :O
02:10:23 <Axman6> ac: you there?
02:11:49 <ddarius> Basically, the only thing it has over a hashtable for large amounts of data (in memory) is that it keeps the strings in (mostly) sorted order.
02:14:21 <inimino> ah
02:19:21 <inimino> huh, burst tries look interesting
02:19:51 <thoughtpolice> why do you fail me cabal??! why?!?!
02:20:06 <Phyx-> because you've been a bad boy
02:21:27 <thoughtpolice> ah how annoying.
02:21:30 <thoughtpolice> fixed :]
02:21:36 <thoughtpolice> (just don't use --user when dealing with HEAD)
02:22:03 <ddarius> We'll just say it was a --user error.
02:22:46 <Axman6> hmm, how is snd $ s x different to snd (s x)?
02:22:52 <thoughtpolice> 'ghc-pkg describe *' chooses to fail with e.g. --user if your user package conf is empty. why, i do not know.
02:22:57 <ddarius> Axman6: It isn't.
02:22:59 <thoughtpolice> oh well
02:23:04 <Axman6> apparently it is :\
02:23:19 <thoughtpolice> @src ($)
02:23:20 <lambdabot> f $ x = f x
02:23:35 <inimino1> it could be different in context
02:23:37 <Axman6> ah, it was becaus ei was using f . snd
02:25:04 <Axman6> well anyway, i figured out (a kinda ugly) fmap for State :D
02:25:08 * Axman6 is proud
02:25:26 <Axman6> @hoogle (a -> m b) -> m a -> m b
02:25:27 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:25:27 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:25:27 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:25:30 <FunctorSalad> the online-realworldhaskell scrolls horizontally for me :-(
02:25:57 <ddarius> fmap f = State . fmap (first f) . runState
02:26:19 <ddarius> Or fmap = liftM
02:26:48 <papermachine> FunctorSalad, get a bigger monitor ;)
02:27:29 * papermachine doesn't grok State
02:27:44 <Axman6> me either really
02:27:49 <FunctorSalad> papermachine: I use a ff extension for forcing wrapping, but it doesn't work with rwh
02:27:59 <FunctorSalad> guess I'll just disable the css
02:28:11 <papermachine> FunctorSalad, I was just being silly :)
02:29:55 <FunctorSalad> "use border box model" from the web developer extension fixes it, whatever that means ;-)
02:30:08 <inimino1> this paper seems to use "skew" everywhere "skewed" would be correct
02:30:32 <inimino1> as in "a highly skew distribution"
02:33:52 <ddarius> I believe in many of the "skew distribution" cases, it's being used as a term.  I only noticed two (other?) cases where it seemed to be used incorrectly.
02:34:04 <ddarius> (or at least read poorly)
02:34:23 <Beelsebob> ouch
02:34:31 <Beelsebob> now I see why everyone's been complaining about lvl 10
02:34:51 <Cale> Level 10?
02:34:55 <mc__> of light bot
02:35:00 <Beelsebob> http://www.gameshot.org/?id=2907
02:35:11 <lambdabot> Title: ffb LightBot - flash game @ Gameshot.org - browser based games
02:35:27 <Cale> Ah, my solution went for the left light first, dropped back down and went for the right one after.
02:35:40 <Beelsebob> interesting
02:36:16 <Cale> I struggled for quite a while to do it the other way around.
02:36:30 <Beelsebob> oh I see
02:36:39 <Beelsebob> you can write "get up to the top" in one function
02:36:59 <Axman6> ah, nice
02:38:13 <Cale> Axman6: oh, hehe, I'm here now... tried to sleep for a few hours there, but for some reason, wasn't really able to properly yet.
02:38:26 <Axman6> ah, not good :\
02:38:57 <Cale> It's all right, just means my hours will be strange, but what else is new? :)
02:39:08 <Axman6> well, you might be proud of me, i got exercise 19 all on my own :)
02:39:18 <Cale> cool, which one was that?
02:39:32 <dibblego> instance Functor (State s)
02:39:34 <Axman6> fmap for State
02:39:39 <Cale> ah, cool
02:39:50 <Axman6> it's a slightly ugly answer, but meh
02:41:28 <Phyx-> :r
02:41:30 <Phyx-> oops
02:42:01 <stulli> Is there something useful besides HAppS for making web applications?
02:42:31 <dibblego> Axman6, I have the answers when you are ready
02:42:42 <Axman6> dibblego: to what?
02:42:49 <dibblego> Axman6, the exercises
02:42:59 <Axman6> oh, right. well i've only got one thing left to do :)
02:43:03 <dibblego> righto
02:43:09 <subconscious> on tonys blog?
02:43:14 <dibblego> yes
02:43:33 <dibblego> http://projects.tmorris.net/public/misc/Fluffy.hs
02:45:47 <sjanssen> dibblego: hmm, you should also require the functor instances for (,) a
02:45:58 <dibblego> sjanssen, good idea
02:46:05 <sjanssen> then give bonus points for the proper fmap for State
02:46:24 <dibblego> I figure a second revision will have Applicative
02:47:00 <Axman6> that one little thing of code has done more to help me understand the use of monads than anything else i've seen
02:48:06 <dibblego> Axman6, I occasionally run courses here in Brisbane and that has worked mostly for my teaching, which is why I posted it
02:48:26 <Axman6> gahh, just need banana for State -_-
02:50:14 <Axman6> ok... after Dr. Who, i will come back to it i think
02:50:27 <Axman6> dibblego: where do you run these courses?
02:53:53 <papermachine> Ack, #10 is hard :(
02:54:14 <Axman6> yeah, that one was pretty annoying
02:55:42 <BONUS> you guys talkin about those tony's exercises?
02:55:53 <Axman6> yeah
02:56:13 <BONUS> hehe, i solved them yesterday, pretty fun
02:56:50 <Blub\0> when I have: f :: [String] -> String -> [String]      why can't I do: f xs y = xs : y          but f xs y = y : xs    seems to work fine?
02:57:35 <BONUS> because you can do 3:[2,3,4]
02:57:41 <BONUS> but you cant do [2,3,4]:3
02:57:54 <BONUS> the : operator takes an element on its left side and a list of elements on its right side
02:58:24 <Blub\0> oh okay, I thought it did both
02:58:29 <Blub\0> need to read up on that :)
02:58:50 <BONUS> hehe
02:58:55 <BONUS> if you want to add to the end of a list
02:58:58 <BONUS> you gotta do like
02:59:03 <BONUS> xs ++ [y]
02:59:47 <Blub\0> okay thanks, now I'm curious why it is that way :P
03:00:02 <wolverian> @type (:)
03:00:03 <lambdabot> forall a. a -> [a] -> [a]
03:00:13 <subconscious> Blub\0: y : xs = [y] ++ xs
03:00:28 <Beelsebob> Blub\0: if you're doing something that requires sticking things on the end of a list, you probably have a minor design problem
03:00:30 <Stinger> a list is either an empty list or an element cons'd with a list
03:00:36 <Beelsebob> you may want to consider reversing the order of your list
03:00:49 <BONUS> Blub\0: you can consider it as a kind of linked list
03:00:52 <BONUS> if you know what that is
03:01:00 <Blub\0> Beelsebob: no I'm just learning, not working on anything specific
03:01:13 <BONUS> you got a first element and then it points to the next one
03:01:22 <Blub\0> yep I know what a linked list is :)
03:01:26 <Beelsebob> Blub\0: okay, well, in general in Haskell you want to attach elements to the front of a list -- not the end
03:01:31 <Beelsebob> it's only singly linked
03:01:35 <BONUS> yeah
03:01:42 <BONUS> attaching at the beginning of a list is O(1)
03:01:47 <BONUS> and at the end it's O(n)
03:01:48 <Blub\0> so I can consider [a] ++ b  being slower than b : [a]?
03:02:01 <Blub\0> okay :)
03:02:06 <Blub\0> thanks
03:02:09 <BONUS> yeah, ++ has a cost that's equal to the length of its left argument
03:02:10 <BONUS> hehe np
03:02:18 <Beelsebob> try writing (++) and I think you'll see why it's less desirable
03:02:21 <subconscious> Blub\0: both of those can't exist in the same universe
03:02:36 <subconscious> :t \a b -> [a] ++ b
03:02:37 <lambdabot> forall a. a -> [a] -> [a]
03:02:41 <subconscious> :t \a b -> b : [a]
03:02:42 <lambdabot> forall a. a -> a -> [a]
03:02:44 <Axman6> @src (:)
03:02:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
03:02:50 <subconscious> :t \a b -> ([a] ++ b, b : [a])
03:02:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
03:02:51 <lambdabot>       Expected type: [a]
03:02:51 <lambdabot>       Inferred type: a
03:02:58 <BONUS> that doesnt seem like much but when you're recursively and repeatedly adding stuff to the end of a list, you can get in trouble
03:03:07 <Blub\0> what a mean bot :D
03:03:13 <subconscious> Blub\0: Does looking at the types there make it clear why?
03:03:23 <Beelsebob> Axman6: (:) is a constructor
03:03:27 <Beelsebob> so it has no source
03:03:32 <Axman6> yeah
03:03:37 <subconscious> :t (:)
03:03:38 <lambdabot> forall a. a -> [a] -> [a]
03:03:40 <BONUS> ++ takes two lists, : takes an element and a list
03:03:48 <Beelsebob> data [a] = a:[a] | [] -- if only that was valid syntax
03:04:42 <Beelsebob> it would be nice to be able to use 'outfix' notation for various things
03:05:00 <Beelsebob> like it'd be lovely to be able to defined [[ x ]] as being a semantic function on x
03:05:24 <Blub\0> subconscious: I think yes
03:05:40 <Cale> Beelsebob: hmm, how would you know that it's not just a list containing a list containing x? :)
03:06:07 <Beelsebob> Cale: yeh, I know that there are specific problems with that one -- but I'm talking in general
03:06:22 <Beelsebob> I just couldn't be arsed digging up the unicode symbol for semantic brackets
03:06:32 <Cale> There's something called quasiquotation which is coming soon that you might like.
03:06:53 <Beelsebob> oh? got a linky?
03:07:11 <Cale> http://www.haskell.org/haskellwiki/Quasiquotation
03:07:12 <lambdabot> Title: Quasiquotation - HaskellWiki
03:08:05 <dibblego> Axman6, at my work office, in Milton, near Brisbane city
03:08:14 <Axman6> ah, righto
03:08:31 <Axman6> we've hot a house up there, on the gold coast
03:08:51 <dibblego> I live on the GC for 14 years
03:08:51 <Axman6> investment property... so never stayed in it -_-
03:09:24 <Axman6> it's in meadow peak, if you know where tht is
03:09:27 <Axman6> that*
03:09:41 <mattam> I've never seen a TeX message that helpful: There are two subscripts in a row in a mathematical
03:09:44 <Beelsebob> Cale: so the idea is to hide the parser so that one can define the rules in the syntax of the source language?
03:09:44 <mattam> formula---something like x_{2}_{3}, which makes no sense.
03:09:45 <Beelsebob> sounds neat
03:10:17 <Axman6> mattam: x_{2_{3}}?
03:10:29 <Axman6> x_{23}?
03:10:47 <Axman6> > 3^3^3
03:10:48 <lambdabot>   7625597484987
03:10:54 <Axman6> > (3^3)^3
03:10:55 <lambdabot>   19683
03:11:23 <mattam> Well, it's not clear how I'll fix it, I want to have Π_1_τ where the 1 indicates the first projection and τ is a type label.
03:11:56 <Axman6> mattam: what's wrong with x_{y_z}?
03:12:10 <Cale> mattam: Is the tau a subscript of the 1 or of the whole thing, use braces to disambiguate
03:12:36 <Cale> Either you want  {\Pi_1}_\tau or \Pi_{1_\tau}
03:12:53 <mattam> The first works?
03:13:00 <Cale> why not?
03:14:11 <mattam> Ah great, thanks.
03:15:16 <Axman6> hmm, they don't look that different at all used used
03:15:19 <Axman6> when used *
03:16:21 * Cale tries to think of a minimal-steps strategy for level 11. ;)
03:17:16 <Cale> My original solution had a couple moves which did nothing, iirc.
03:17:40 * subconscious tries to write a minimal proof that f p < f m \/ f p = f m /\ g q < g n is well founded :S
03:18:34 <Cale> subconscious: What do you mean by well-founded in this context?
03:19:09 <Cale> Are you defining < there somehow?
03:19:22 <subconscious> < is the usual on natural numbers
03:19:37 <Cale> hmm, okay. I don't have enough context :)
03:19:50 <subconscious> well founded as in there is no infinite chain of this relation
03:19:53 <gal_bolle> you're defining an order on the domain of f and g with that formula
03:20:12 <gal_bolle> and proving it's well-founded, isn't it?
03:20:23 <subconscious> gal_bolle: yes
03:20:38 <gal_bolle> which formalism are you working in?
03:20:40 <Cale> ah, okay
03:21:01 <subconscious> gal_bolle: type theory
03:21:02 <gal_bolle> (that might influence what you'll call minimal)
03:21:18 <subconscious> well I have a really long version which I hate ..
03:21:22 <mattam> Seems like the lexicographic order on 'f on <', 'g on <'.
03:21:57 <Cale> yeah
03:22:08 <mattam> Where does that [q] come from?
03:22:43 <the_unmaker> wow haskell is not mesing around
03:22:47 <gal_bolle> to say it otherwise, <f,g> is an increasing map from your order to N^2, which is well-founded
03:22:53 <the_unmaker> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
03:22:54 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki
03:22:54 <subconscious> instead of having a relation (p,q) R (m,n) I have curried it into  p -> q -> m -> n -> Prop
03:23:02 <mattam> Actually, [q] and [n]...
03:23:06 <subconscious> so that my extracted code doesn't have lots of tuples in it
03:23:12 <Blub\0> hah, got my infix calculator working now xD
03:23:32 <subconscious> Blub\0: hey cool -- how did you parse the infix expressions?
03:23:58 <mattam> What's wrong with tuples? OCaml does a bit of curryfication I think.
03:23:59 <thoughtpolice> Beelsebob: quasiquoting is a lot of fun
03:24:30 <mattam> Don't know about Haskell though.
03:25:16 <electronx> wtf?
03:25:17 <electronx> Prelude Data.List Data.ByteString Text.Regex> subRegex (mkRegex "<") "a" "<html>
03:25:17 <electronx> hadf</html>"
03:25:17 <electronx> "a"
03:25:24 <electronx> why is it doing that?
03:25:25 <Blub\0> subconscious: http://blubpc.homelinux.org/~blub/tmp.hs.txt
03:25:28 * Blub\0 hides :P
03:26:04 <Blub\0> I just started learning yesterday and found the postfix one in a tutorial
03:26:08 <electronx> Text.Regex is broken
03:26:13 <Blub\0> and thought as an exercise I'd try an infix calc :>
03:26:43 <the_unmaker> Nepal -- Nested Data-Parallelism in Haskell wow http://www.cse.unsw.edu.au/~chak/papers/CKLP01.html look at that!
03:26:44 <lambdabot> Title: Research Papers of Manuel Chakravarty
03:27:02 <thoughtpolice> the_unmaker: yes it's very nice work being done
03:27:22 <electronx> someone please help me with Text.Regexp
03:27:28 <electronx> it doesn't work
03:27:47 <electronx> > subRegex (mkRegex "<") "a" "<html>asdfasdf<ht>"
03:27:48 <lambdabot>   mueval: Prelude.read: no parse
03:28:12 <subconscious> tuples probably make very little difference but it's interesting to see how to erase them
03:29:23 <the_unmaker> are you gents working on 'tuple space' kind fo apps?
03:29:48 <electronx> sigh
03:30:09 <thoughtpolice> the_unmaker: a form of nested data parallelism is going into ghc 6.10
03:30:18 <thoughtpolice> since i think the vectorise pass is somewhat working now
03:30:29 <the_unmaker> electronix: not good at regex am I
03:30:34 <thoughtpolice> (or maybe not, i'm not sure)
03:30:49 <the_unmaker> thoughtpolice: sounds awesome
03:31:11 <the_unmaker> I read randomly last week somewhere about something faster than map-reduce being done in haskell
03:32:53 <the_unmaker> http://www.seas.upenn.edu/~lipeng/homepage/unify.html holy crap
03:32:54 <lambdabot> Title: Unifying events and threads
03:32:56 <mapreduce> Faster for algorithms that benefit from it.
03:32:59 <the_unmaker> 1E7!
03:33:18 <the_unmaker> 10million threads!
03:33:34 <mapreduce> 10 million "threads".
03:33:40 <thoughtpolice> the_unmaker: it uses libaio and epoll to get there, but it's pretty impressive
03:34:31 <Baughn> Hold it, isn't the minimal stack 1kB per thread?
03:34:47 <Baughn> ..well, I suppose it's not impossible
03:35:29 <the_unmaker> I know some of the new webservers use and event model, something tcl people have been enjoying for quite a while, but using combined thread+event wow, I think aolserver is the only webserver to do that until i saw apaches event worker MPM do it but aolserver has had it since 1995, but 10million, well thas beyond anything Ive even vaguely heard of,, unless the mozart ssytem and oz or erlang do something like that
03:36:18 <the_unmaker> why is minimal stack 1k?
03:36:30 <the_unmaker> [never took a architecture calss]
03:36:35 <the_unmaker> class
03:36:43 <Baughn> Come to think of it, it isn't. That's just the default minimum stack size.
03:36:49 <thoughtpolice> hm apparently the vectorise pass is in
03:37:02 <thoughtpolice> unfortunately i cannot find a way still to install the dph packages with HEAD :[
03:37:49 <Fuse> Hey guys!
03:38:02 <Cale> hello
03:38:15 <Fuse> wow, massive channel
03:38:27 <Fuse> I was expecting some small and esoteric channel for Haskell
03:38:30 <Axman6> one of the beggest
03:38:33 <Cale> hehe
03:38:34 <Axman6> i*
03:38:43 <Cale> We have a pretty good community going :)
03:38:50 <Baughn> Fuse: Nah, haskell just made the bestseller list for the third year running
03:38:52 * Axman6 hugs you all
03:39:22 <Fuse> excellent, I guess the size compared to Haskell's userbase means that all the intelligence is super-concentrated here? ;)
03:41:58 <Axman6> Fuse: very much so
03:44:17 <Dr_Zooix> Hi all
03:44:21 <Cale> hello
03:44:24 <Axman6> o/
03:44:26 <Dr_Zooix> I've got a little problem with that: http://rafb.net/p/woOqlc74.html
03:44:31 <lambdabot> Title: Nopaste - No description
03:44:35 <Dr_Zooix> Can you help me please
03:44:37 <Cale> Dr_Zooix: --make
03:44:44 <Cale> Dr_Zooix: (on the commandline to ghc)
03:44:55 <Cale> Or -package mtl
03:44:56 <Dr_Zooix> Ok thanks
03:45:00 <Dr_Zooix> I'll try
03:45:06 <Cale> But --make will take care of the package flags for you
03:46:18 <Dr_Zooix> Ok thanks it works
03:50:52 <Axman6> oh no!
03:50:59 <Cale> what?
03:51:08 <Axman6> i quit my browser and i lost my lightbot stuff :'(
03:57:21 <Blub\0> when I have data aaa = Int Int Int Int...   is there some short form? like Int{4} or something?
03:57:31 <subconscious> no
03:57:41 <Axman6> could that even work?
03:58:56 <Cale> Blub\0: If you have enough of them, you could just use an array... though admittedly, arrays aren't statically bounds checked.
03:58:59 <Fuse> Axman: use Firefox? ;)
03:59:20 <Axman6> Fuse: flash game, lost the level i was on
03:59:40 <Axman6> and firefox fails on OS X compared to. well pretty much all the other browsers
04:01:00 <Axman6> s/./,
04:01:36 <thoughtpolice> i actually use ff on this macbook but it was while I used vimperator
04:01:42 <thoughtpolice> was thinking of trying out camino or something
04:04:49 <Axman6> thoughtpolice: Safari can't be beat (especially Safari 4)
04:05:17 <thoughtpolice> they're on 4 already?
04:05:20 <thoughtpolice> i'm behind the times
04:05:37 <the_unmaker> when is the haskell web browser coming out?
04:05:46 <the_unmaker> kick butt over google chrome!
04:06:04 <ivanm> the_unmaker: whenever you make it
04:06:05 <ivanm> ;-)
04:06:27 <the_unmaker> ;)
04:06:53 <the_unmaker> chrome crashed today on me on xp
04:07:04 <thoughtpolice> Axman6: what's amazing about safari 4?
04:07:04 <ivanm> :o
04:07:08 <thoughtpolice> wondering :]
04:07:13 <ivanm> thoughtpolice: the animals you see ;-)
04:07:43 <Axman6> thoughtpolice: faster, more stable (well, the first beta was...), and should be out with a fatser JS engine than Chrome when released
04:07:56 <thoughtpolice> yeah squirrelfish extreme or whatever
04:08:00 <Axman6> yeah
04:08:03 <thoughtpolice> Axman6: link?
04:08:11 <Axman6> got an ADC account?
04:08:18 <thoughtpolice> yeah
04:08:23 <Axman6> technically i'm talking about stuff that's under NDA...
04:08:37 <Axman6> but meh, it's all in WebKit anyway ;)
04:08:40 <thoughtpolice> 'faster JS engine, more stable' - $10,000,000
04:08:48 <thoughtpolice> the world is a scary place sometimes
04:10:32 <Axman6> haha, i love how they've gone onto squirrelfish extreme... before SF was even released in anything
04:11:12 <thoughtpolice> next: squirrelfish insane. prepare to play doom 3 in your browser
04:12:44 <thoughtpolice> speaking of that that llvm talk about converting C to run on the tamarin vm was awesome interesting and sweet
04:13:08 <thoughtpolice> best part: porting an NES emulator in C to tamarin and running the original zelda
04:13:29 <thoughtpolice> the quake 1 demo was pretty impressive too, 30fps for a 3d game written in C running on flash
04:16:40 <Axman6> thoughtpolice: link?
04:17:02 <Cale> Nevermind Doom 3 in your browser, why not Duke Nukem Forever?... I'm sure they'd be up for another engine change.
04:19:12 <Axman6> heh
04:22:12 <thoughtpolice> Axman6: http://llvm.org/devmtg/2008-08/ is it iirc
04:22:18 <thoughtpolice> you want the 'flacc' video
04:22:22 <thoughtpolice> it's a real impressive talk honestly
04:22:47 <Axman6> i remember reading about the c -> flash thing they were working on
04:23:05 <thoughtpolice> yeah but this describes the architecture of it fairly well and also has lots of good examples :]
04:23:16 <thoughtpolice> they also port python and lua (with little effort from what I understand) to flash
04:23:23 <thoughtpolice> so you can use python/lua to program your flash games/animations
04:23:28 <thoughtpolice> lots of really cool stuff
04:24:39 <ac> so I hear about all these tools to compile to Flash bytecode, but how do you actually write useful programs that include graphics?
04:25:18 <thoughtpolice> you mean like haxe and stuff?
04:25:40 <ac> thoughtpolice: yeah. Seems like you still need Macromedia in order to actually write a Flash program
04:26:04 <thoughtpolice> haxe in particular can import other swf files full of e.g. clips as external libs basically, and it automatically makes those clips/symbols classes you can create instances of and whatnot
04:26:06 <subconscious> ac: It's possible to do graphics without a gui
04:26:46 <ac> subconscious: you mean by just writing drawing functions manually?
04:26:52 <subconscious> yes
04:27:00 <subconscious> to square :side
04:27:02 <thoughtpolice> and haxe has full bindings to the flash9 api and the unstable version has support for flash10 as well, so you can program shaders and whatnot in haxe
04:27:11 <subconscious>  repeat 4 [ fd side rt 90 ]
04:27:13 <subconscious> type stuff
04:27:31 <ac> subconscious: ah ok. I thought there might be different primitives for shapes in the bytecode. I suppose you could actually write a Flash editor in Flash bytecode
04:27:31 <jadrian> there's this thing about polymorphism I still don't get...
04:27:32 <subconscious> I think flash has bezier path tools and such now
04:27:41 <thoughtpolice> brb
04:28:15 <jadrian> when we talk about Rank - 1 (Prenex) polymorphism does that mean we can only substitute type vars by monomorphic types?
04:28:22 <ac> all you'd need is some sort of compiler that you could call from Flash
04:29:00 <Heffalump> jadrian: yes
04:29:15 <ac> so when does Haskell get a Flash back end? :)
04:29:51 <EvilTerran> ac, as soon as you implement it for YHC. well volunteered!
04:30:07 <ac> EvilTerran: what's YHC?
04:30:15 <EvilTerran> ?where yhc
04:30:15 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
04:30:25 <EvilTerran> compiler notable for having pluggable backends
04:30:48 <jadrian> Heffalump: so does that mean I cannot instantiate   forall alpha . alpha -> alpha    to  forall  beta gamma . ( beta -> gamma) -> (betta -> gamma)    in Rank 1 ?
04:30:57 <Fuse>  I think first things first: perfect gnash
04:31:10 <ac> EvilTerran: is it written in Haskell?
04:31:54 <subconscious> jadrian: rank 1 doesn't let you do   (forall beta gamma, beta -> gamma) -> (forall beta gamma, beta -> gamma)
04:32:10 <jadrian> subconscious: exactly that's what I thought...
04:32:40 <jadrian> subconscious: but at the same time, what I read says rank 1 only allows instantiation of type vars with mono types
04:32:47 <Heffalump> jadrian: no, it does allow that. What I should have said was that you can't ultimately instantiate to polymorphic types.
04:33:10 <Heffalump> you can (temporarily) instantiate with other type variables
04:33:32 <Heffalump> and then later instantiate those variables too
04:33:52 <jadrian> ok got it
04:34:01 <Axman6> rawr. can anyone else load llvm.org?
04:34:22 <ac> Axman6: no
04:34:27 <jadrian> Heffalump: thanks that's what I thought, just got confused with the description I read
04:34:44 <Axman6> what a pita :\
04:37:55 <aempirei> whats the easiest wat to convert Int to Double
04:38:05 <MedeaMelana> fromIntegral?
04:38:12 <MedeaMelana> :t fromIntegral
04:38:13 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:38:52 <aempirei> oh
04:38:53 <aempirei> ok
04:39:03 <aempirei> perfect thanks
04:39:30 <ivanm> so if I want greek letters showing up in a gtk-based app, do I need to import utf8-string?
04:40:06 <ivanm> (well, technically in a graph drawn by the Chart library, but it uses gtk2hs)
04:40:29 <ivanm> or is it just that ghci can't show unicode characters?
04:41:12 <MedeaMelana> q
04:41:44 <Axman6> thoughtpolice: i can't get llvm.org to load :(
04:41:56 <thoughtpolice> Axman6: yeah seems to be down right now
04:45:49 <creaux> is the comprehension list syntax a big advantage, compared to other programming languages? Like SML where the same semantics can be expressed with map and a list?
04:46:35 <creaux> filter is also needed
04:46:51 <subconscious> creaux: I don't use it
04:47:42 <Cale> creaux: don't forget concat to go along with each map
04:47:43 <creaux> I guess it is easier if one i used to mathematical set construction
04:48:15 <Cale> It's effectively equivalent to the list monad.
04:48:35 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
04:48:36 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
04:48:56 <Cale> > do x <- [1..20]; y <- [x..20]; z <- [y..20]; guard (x^2 + y^2 == z^2); return (x,y,z)
04:48:57 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
04:50:16 <Cale> In fact, they used to be monad comprehensions, and worked for any instance of MonadZero
04:51:09 <sjanssen> creaux: list comprehensions have a high power to cost ratio
04:51:47 <sjanssen> the cost is small syntactically, and the semantics are just like Monads as Cale points out
04:51:49 <creaux> I am about trying to understand the monad concept. Reading an article by Erik Meijer (M$)
04:52:52 <Cale> creaux: here's my take on it, which includes a touch of philosophy that I think most monad tutorials lack: http://www.haskell.org/haskellwiki/Monads_as_Computation
04:52:55 <lambdabot> Title: Monads as computation - HaskellWiki
04:53:37 <sjanssen> Cale: is Monads as Computation your new preferred description?
04:53:44 <creaux> With a little background in SML I try to compare, haskell with sml
04:53:49 <sjanssen> you wrote Monads as Containters too, right?
04:54:08 <Cale> sjanssen: Well, it has some stuff in it which I possibly should reiterate somehow in Monads as Containers.
04:55:33 <creaux> thx for the link
04:59:26 <jethr0> good -insert time of day here- haskell
05:00:23 <Cale> こんにちは、jethr0さん
05:00:45 <jethr0> looks like katagana
05:00:55 <Vq^> jethr0: goodday to you too
05:01:04 <jethr0> Cale: do you speak japanese?
05:01:19 <Cale> jethr0: No, but I'm learning :)
05:01:33 <Cale> I can read it, with help from a dictionary :)
05:01:55 <jethr0> i started once, but then got kinda frustrated. now i've switched to chinese ;)
05:02:18 <Cale> That was hiragana, by the way.
05:03:15 <ivanm> Cale: hmmm... xchat can't display those characters, but when I cat the logs to term they come up properly :s
05:03:17 <jethr0> damn
05:03:21 * ivanm suspects a font problem
05:03:30 <Fuse> Huh, it comes up as Japanese on my end. It would come up as big black squares in Windows
05:03:36 <Cale> ivanm: Given that I'm also using xchat, yeah...
05:04:05 <ivanm> which font are you using?
05:04:36 <Cale> Andale Mono, but it doesn't specifically have Japanese characters
05:04:55 <Cale> Those are overlaid from... I think one of the MS Japanese fonts.
05:05:03 <ivanm> *nod*
05:05:11 <Cale> If you have Japanese fonts installed, Freetype2 should know...
05:05:13 <Beelsebob> ivanm: your OS doesn't use a closely related font when the one you've selected doesn't have the relevant characters?
05:05:30 <inimino1> Chunk !!ByteString ByteString
05:05:39 <ivanm> Beelsebob: I think I've got Georgia set as my default font, which is what xchat is using
05:05:48 <inimino1> what does !! mean?
05:05:49 <Cale> Is xchat set to use UTF-8?
05:06:10 <Cale> inimino1: that's strange, is that in a data declaration?
05:06:11 <ivanm> yeah, because I've got dejavu as the font in my edit box, and copy-pasting those japanese characters showed up right there
05:06:39 <inimino1> Cale: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.2/doc/html/Data-ByteString-Lazy-Internal.html
05:06:40 <lambdabot> Title: Data.ByteString.Lazy.Internal, http://tinyurl.com/4dmjwn
05:06:41 <ivanm> to use unicode, what do I have to do? just import Data.String.UTF8 ?
05:07:10 <Beelsebob> ivanm: and then use the print/putStr etc in there
05:07:25 <Cale> inimino1: Looks like a bug in Haddock, or an intentional but confusing feature
05:07:25 <Beelsebob> I thought it was System.IO.UTF8 though
05:07:26 <inimino1> Cale: I see it's not in the source, just in the documentation
05:07:33 <ivanm> Beelsebob: *nod*
05:07:36 <inimino1> right
05:08:14 <ivanm> it didn't work :(
05:08:18 <jethr0> have any of you done any significant programming with dependent types yet?
05:08:22 <Cale> inimino1: That's an unpacked strict field, which means that the structure for the strict bytestring will be stored directly in with the Chunk constructor, and not on the other end of a pointer.
05:08:35 <ivanm> (I'm trying to draw a graph using the Chart library...)
05:08:37 <jethr0> i'm really fascinated by the idea, but what I saw so far looked a bit clunky
05:09:15 <inimino1> Cale: oh, I see
05:09:50 <inimino1> so the !! is a feature, indicating that it is not only strict but also unpacked
05:09:59 <Cale> possibly :)
05:10:14 <inimino1> yes ;-)
05:10:47 <ivanm> looks like I can't use "σ" for standard deviation in my graph legends :(
05:22:07 <maltem> Is identity an equivalence relation?
05:22:28 <subconscious> maltem: yes
05:22:42 <maltem> subconscious: On what set is it defined then?
05:22:59 <subconscious> identity is defined on every set
05:23:19 <Beelsebob> no it isn't
05:23:24 <Beelsebob> sets don't have operations
05:23:30 <Beelsebob> it's defined on some groups though
05:24:24 <ivanm> Beelsebob: though it can be _used_ on any set, right?
05:24:33 <ivanm> and which groups don't have identity?
05:24:42 <maltem> ah, so we just have seperate identities. I was wondering how to define identity on the set of everything :)
05:24:46 <jethr0> "In mathematics, an equivalence relation is a binary relation between two elements of a set which groups them together as being "equivalent" in some way."
05:24:51 <subconscious> maybe we should talk about types rather than sets
05:24:53 <subconscious> :)
05:25:03 <ivanm> the set of types?
05:25:06 <maltem> subconscious: To be on-topic? :)
05:25:08 <ivanm> the type of sets?
05:25:08 <ivanm> :p
05:25:12 <ivanm> @quote topic
05:25:12 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
05:25:16 <ivanm> grr..
05:25:17 <ivanm> @quote topic
05:25:17 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
05:25:26 <Beelsebob> ivanm: how about the group ({a,b}, <+>) where a <+> a = a, a <+> b = b, b <+> a = a and b <+> b = b
05:25:45 <subconscious> maltem: I know types better than sets
05:25:47 <Beelsebob> no identity in there
05:26:23 <jethr0> Beelsebob: from how i understand it, equivalence relations are indeed defined over sets...
05:26:58 <PeakerWork> @quote Haskell
05:26:58 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
05:26:58 <lambdabot> for your entire program.")
05:27:15 <ivanm> Beelsebob: ummm, yeah, I suppose
05:27:18 <maltem> Beelsebob: if {a,b} is a set, then it should surely be decideable whether it has one or two elements?
05:27:33 <Beelsebob> maltem: ?
05:27:47 * ivanm doesn't know much about groups
05:27:53 <subconscious> maltem: In Prolog we defined = like this:     X = X.
05:27:59 <Beelsebob> ivanm: I can't claim to know much either
05:28:03 <maltem> Beelsebob: I mean, what is it that forbids identity in your structure? (I don't know much about groups either)
05:28:07 <subconscious> maltem: and this is the identity, in a fashion, see what I mean?
05:28:07 <ivanm> heh
05:28:26 <Beelsebob> maltem: well, it's finite, so it's easy to verify that there's no identity
05:28:46 <Beelsebob> a isn't an identity because b <+> a = a, and b isn't an identity because a <+> b = b
05:29:02 <jethr0> Beelsebob: are you sure your example is a group? does it have identity and an inverse?
05:29:11 <Axman6> ㍂ᄢ귿
05:29:35 <Beelsebob> jethr0: I didn't think that that was required for being a group
05:29:48 <Axman6> whoops
05:29:54 <Beelsebob> I may be wrong though
05:29:55 <maltem> Beelsebob: I guess I would follow you if I were less ignorant of group theory
05:30:09 <Beelsebob> maltem: it may be that I'm ignorant of group theory
05:30:18 <jethr0> Beelsebob: from what i remeber a group needs (closure, associativity, identity and an inverse)
05:30:29 <subconscious> wait, are we talking about identity as in  a -> a or identity as monoids zero?
05:30:36 <maltem> subconscious: looks about right :) I had once seen something similar in Agda code and wondered how it worked...
05:30:46 <subconscious> maltem: yeah in <made up language that is almost haskell> you can define  data a = a where refl :: (x :: a) -> x = x
05:30:51 <Beelsebob> jethr0: hmm, from reading wikipedia a bit, we're both wrong -- your properties, but not closure
05:31:09 <subconscious> maltem: It works very similar to Prolog
05:31:12 <subconscious> maltem: It works very similar to Prolog
05:31:14 <subconscious> oops
05:31:15 <subconscious> sorry
05:31:38 <jethr0> huh?
05:31:46 <maltem> subconscious: I suppose unification is the keyword here?
05:32:08 <subconscious> In the Prolog definition of = we reflect the host languages unification into a relation we can use,  in <made up language that is almost haskell> we reflect the convertablitiy relation of the type theory into a relation we can use
05:32:27 <jethr0> Beelsebob: i don't know where you browsed, but groups are definitely closed under the group-operation
05:32:48 <maltem> Beelsebob: hm ok
05:34:05 <subconscious> you could probably come up with more examples too
05:34:30 <Baughn> @hoogle on
05:34:31 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:34:31 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
05:34:31 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
05:36:37 <subconscious> maltem: so identity always comes out as an equivalence relation, but it can still have very interesting properties
05:36:52 <subconscious> (and different ones for which setting you extract it from)
05:38:17 <ivanm> anyone know how I can generate random complex numbers?
05:38:30 <subconscious> @instances Random
05:38:31 <lambdabot> Couldn't find class `Random'. Try @instances-importing
05:38:35 <subconscious> umm,,,
05:38:50 <ivanm> just generate two random doubles?
05:38:52 <Axman6> ivanm: could always use the :+ operator
05:38:55 <subconscious> I would start by writing an instance for complex
05:39:02 <ivanm> Axman6: yes, I know that...
05:39:02 <subconscious> instance Random Complex where
05:39:06 <Axman6> on yeah, two floats
05:39:12 <ivanm> subconscious: yes, but what would be the right way of doing it ;_
05:39:15 <subconscious> :k Complex
05:39:16 <lambdabot> * -> *
05:39:18 <subconscious> ivanm: the way I said
05:39:37 <subconscious> instance Random foo => Random (Complex foo) where
05:39:54 <ivanm> subconscious: *sigh* but how would I implement it?
05:40:13 <ivanm> the biggest problem is how to do the bounded one...
05:40:17 <subconscious> ivanm: Have you ever written an instance before
05:40:21 <ivanm> subconscious: yes...
05:40:40 <ivanm> but my question relates to how do I define a random :: g -> (Complex Double, g)
05:40:49 <ivanm> not the implementation... the theory
05:40:55 <subconscious> ok.... if you're going to sigh and overuse ellipsis I'll leave you to it
05:40:57 <ivanm> do I do a rectangular bound or circular bound ofr randomR?
05:41:08 <ivanm> subconscious: I didn't sigh...
05:41:20 <subconscious> hypercube rejection method
05:41:24 <ivanm> but you didn't state at all how one specifies a random complex?
05:43:21 <maltem> ivanm: a pair of a random real, and a random imaginary part?
05:43:46 <ivanm> subconscious: well, that was part of my question... does using a circle make any more sense than using a rectangle?
05:44:01 <subconscious> ivanm: You are the one that is using these numbers right?
05:44:07 <ivanm> yes
05:44:12 <ivanm> but in general
05:44:24 <subconscious> so why do you want random complex numbers?
05:44:27 * ivanm needs to create random gaussians
05:44:33 <ivanm> *random complex gaussians
05:44:43 <subconscious> so do tha
05:45:14 <Axman6> @hoogle (a -> m b) -> m a -> m b
05:45:14 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:45:15 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:45:15 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:45:49 <nornagon> ivanm: there's likely a reason for the lack of standard instance of Random (Complex Double) :)
05:46:06 <ivanm> nornagon: yeah ;-)
05:46:11 <ivanm> hence my questions :p
05:46:27 <ivanm> though subconscious's suggestions of "just do it" don't really help :s
05:46:28 <nornagon> it's precisely because your questions can't be answered in the general case ;)
05:46:36 <ivanm> *nod*...
05:46:45 <maltem> d'oh, I missed the "bounded" part :)
05:47:01 <nornagon> i'd put them in a unit circle, myself.
05:47:07 <ivanm> getting random double gaussians is easy... but I can't think of how to get complex numbers to be gaussian :s
05:47:11 <ivanm> nornagon: *nod*
05:47:39 <nornagon> ivanm: gaussian filters are seperable, iirc
05:47:49 <ivanm> actually... if I'm basically doing a random walk in the complex space, I might as well use rectangular bounds...
05:47:52 <ivanm> nornagon: oh?
05:47:53 <nornagon> so gaussian in re + gaussian in im = gaussian in C
05:48:12 <ivanm> *nod*
05:48:18 <nornagon> not 100% on that though
05:48:37 <nornagon> i just remember it from writing blurring pixel shaders :p
05:48:47 <ivanm> hmmmm.... maybe I should just change my 1D complex problem into a 2D real problem, since that's what I had to do for the first part anyway...
05:48:50 <ivanm> nornagon: lol
05:48:51 <MedeaMelana> I'm pretty sure that's correct
05:49:26 <ivanm> looks like it is, according to wikipedia: http://en.wikipedia.org/wiki/Normal_distribution#Complex_Gaussian_process
05:49:29 <lambdabot> Title: Normal distribution - Wikipedia, the free encyclopedia, http://tinyurl.com/m2gx6
05:49:42 <ivanm> I can see how that would split up into a multiple of two gaussians...
05:49:57 <Baughn> For those of you who are native english speakers: Do you normally switch frequency to mark word separation? Or pause? Or both?
05:50:15 <ivanm> Baughn: when speaking?
05:50:18 <Axman6> Cale: still awake? :P
05:50:38 <Baughn> ivanm: Presumably.
05:50:53 <Axman6> Baughn: generally neither
05:51:13 <ivanm> well, you'd normally have a _slight_ gap between words... same as in any language I presume
05:51:14 <nornagon> ivanm: http://nornagon.net/pics/bloom2.png <-- see for yourself :)
05:51:28 <ivanm> i.e. the difference between "hello, how are you" and "hellohowareyou" ;-)
05:51:32 <Axman6> words are spoken almost as a single word, with punctuation indicating pauses and frequency changes
05:51:47 <nornagon> i'd agree with Axman6
05:51:49 <Axman6> ivanm: the difference is the punctuation though
05:51:51 <ivanm> nornagon: what is that meant to be?
05:51:54 <nornagon> i speak quickly, though
05:51:58 <Baughn> Axman6: Hmm. I'm stuck on switching frequency between every single word, which has some native speakers telling me that I sound chinese. (huh?)
05:51:59 <nornagon> ivanm: a bloom filter
05:52:02 <ivanm> Axman6: longer gaps and intonation there...
05:52:06 <Baughn> It seems easy to understand, though
05:52:18 <ivanm> nornagon: oh, is that the probablistic set thingy?
05:52:33 <ivanm> Baughn: why, what's your native tongue?
05:52:52 <nornagon> ivanm: i guess so... it's implemented as a gaussian in x and a gaussian in y iirc
05:52:56 <Baughn> ivanm: Norwegian
05:53:13 <ivanm> hmmm....
05:53:41 <Axman6> Baughn: listen to a lot of podcasts ;)
05:53:50 <Axman6> (preferably not american ones)
05:53:57 <Axman6> british would be good
05:54:07 <Baughn> Axman6: Japanese podcasts? ^_^
05:54:34 <Axman6> english preferably :P
05:54:38 <maltem> A Norwegian accent in German suggests that the speaker is singing :)
05:55:10 <Baughn> I would. I'm not sure it would help, though - for some reason conversation in my .edu always devolves to english, even with no actual foreigners present
05:55:14 <maltem> (at least that's the case for my Norwegian cousin-or-something)
05:55:17 <Japsu> or that he is Swedish and very, very drunk
05:55:37 <maltem> Japsu: :)
05:57:39 <maltem> Japsu: My Swedsh cousin, on the other hand, when talking English, has a _very_ strong American accent
05:58:03 <Japsu> I think Received Pronounciation is cool. I should learn that.
05:59:47 <maltem> I always thought you have to be born a Windsor to get your tongue around RP
05:59:50 <Axman6> far out. fmap for State is a bitch to figure out how to write -_- (no one tell me how)
06:00:06 <subconscious> Axman6: What is 'State'?
06:00:21 <Axman6> the State monad
06:00:30 <Axman6> newtype State s a = State { state :: (s -> (s, a)) }
06:00:33 <MyCatVerbs> Axman6: fmap f = (>>= (return . f))
06:00:41 <Axman6> MyCatVerbs: what did i just say?
06:00:54 <subconscious> :t State
06:00:55 <lambdabot> forall s a. (s -> (a, s)) -> State s a
06:00:57 <MyCatVerbs> Axman6: for any Monad. :)
06:01:17 <subconscious> :t fmap
06:01:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:01:31 <subconscious> Axman6: And what is the type signature of what you're trying to write?
06:01:41 <Baughn> > execState (State (\a -> (a,a))) 3
06:01:42 <lambdabot>   3
06:01:43 <Axman6> (a -> State s b) -> State s a -> State s b
06:01:51 <Axman6> and i don't want answers >_<
06:01:56 <MyCatVerbs> Axman6: fmap f (State k) = State $ \s -> let (s,a) = k s in (s,f a)
06:01:58 <Axman6> i've supposed to be figuring it out myself
06:02:02 <MyCatVerbs> Oops.
06:02:04 <Beelsebob> Axman6: that's not fmap's type
06:02:12 <Axman6> MyCatVerbs: "(no one tell me how)
06:02:19 <Beelsebob> (a -> b) -> State s a -> State s b
06:02:27 <MyCatVerbs> Axman6: yeah, but the type you're asking about is the type for bind, (>>=), not fmap.
06:02:37 <Axman6> ah right, not fmap :P
06:02:43 <Axman6> i got fmap already
06:02:51 <MyCatVerbs> Axman6: fmap is (Functor f) => (a -> b) -> f a -> f b
06:03:15 <subconscious> So you are just writing the state monad
06:03:18 <Axman6> fmap f (State s) = State (\x -> let (y, z) = s x in (y, f z))
06:03:41 <MyCatVerbs> Axman6: and yeah, I'm not surprised. >>= in the State monad is clever and difficult to wrap your head around unless you're very used to continuation passing.
06:03:46 <Axman6> i'm going through this: http://blog.tmorris.net/20-intermediate-haskell-exercises/
06:03:57 <lambdabot> Title: λ Tony’s blog λ » Blog Archive » 20 Intermediate Haskell Exercises
06:04:46 <Axman6> got everything except for bind for State (furry)
06:05:49 <Baughn> @instances Fractional
06:05:50 <lambdabot> Double, Float
06:05:59 <Baughn> @instances-importing Data.Ratio Fractional
06:06:00 <lambdabot> Double, Float, Ratio a
06:06:13 <Baughn> @hoogle fromFractional
06:06:13 <lambdabot> No results found
06:06:20 * Baughn pouts
06:06:48 <Saizan> ?ty realToFrac
06:06:49 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
06:07:06 <Baughn> @ty fromIntegral
06:07:07 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:07:20 <Baughn> See, I'd like a function that does that..
06:07:28 <Baughn> @ty fromRational . toRational
06:07:29 <lambdabot> forall a a1. (Real a1, Fractional a) => a1 -> a
06:07:41 <Saizan> you can't
06:07:44 <Baughn> Oh well.
06:07:50 <Saizan> ?ty fromIntegral . round
06:07:51 <lambdabot> forall b a. (RealFrac a, Num b) => a -> b
06:07:58 <Baughn> realToFrac is closest, but the naming is inconsistent there
06:32:12 <Axman6> ac: yt?
06:37:46 <FunctorSalad> \@remember CaptainObvious the number tower is confusing
06:37:51 <FunctorSalad> ;-)
06:38:41 <FunctorSalad> @instances RealFrac
06:38:42 <lambdabot> Double, Float
06:38:48 <FunctorSalad> @instances Fractional
06:38:49 <lambdabot> Double, Float
06:38:53 <FunctorSalad> @instances Real
06:38:54 <lambdabot> Double, Float, Int, Integer
06:39:23 <FunctorSalad> @src RealFrac
06:39:23 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
06:39:23 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
06:39:23 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
06:40:45 <Axman6> > properFraction 12
06:40:46 <lambdabot>   (12,0.0)
06:40:54 <Axman6> > properFraction 2
06:40:55 <lambdabot>   (2,0.0)
06:41:14 <FunctorSalad> @src Real
06:41:15 <lambdabot> class  (Num a, Ord a) => Real a  where
06:41:15 <lambdabot>     toRational      ::  a -> Rational
06:41:18 <Axman6> what's the point of that?
06:41:53 <Beelsebob> > properFraction 93.287624876234
06:41:54 <lambdabot>   (93,0.28762487623400546)
06:41:58 <Beelsebob> that is
06:42:04 <Axman6> src properFraction
06:42:10 <FunctorSalad> does it work on other numbers too?
06:42:12 <Axman6> oh, right
06:42:13 <FunctorSalad> ;-)
06:42:26 <Axman6> i thought it was b -> (b,a)
06:43:48 <subconscious> @src realToFrac
06:43:48 <lambdabot> realToFrac = fromRational . toRational
06:43:53 <daguerre> hej - I've got problem with Haskell data types. I get the error Message:
06:43:53 <daguerre> Couldn't match expected type "x" against inferred type"y"
06:44:02 <subconscious> Axman6: It's a bad design but that ^ is the reason why
06:44:12 <daguerre> but, some lines above, I've got:
06:44:12 <daguerre> data x = y - so what's wrong?
06:44:13 <FunctorSalad> @src Rational
06:44:13 <lambdabot> type Rational = Ratio Integer
06:44:20 <Axman6> @src properFraction
06:44:20 <lambdabot> Source not found. Where did you learn to type?
06:44:34 <FunctorSalad> meh. "Fractional" makes me think of what is called "Rational" here
06:44:35 <subconscious> daguerre: that line should give an error
06:44:39 <Axman6> @src properFraction :: RealFrac
06:44:39 <lambdabot> Source not found. Are you on drugs?
06:44:42 <igel> daguerre: try data X = Y
06:44:57 <FunctorSalad> what makes it even weirder is that every Double represents a rational number
06:45:07 <igel> type names and constructors have to start with a capital letter afaik
06:45:53 <FunctorSalad> maybe it would be less confusing if the mathematical hierarchy and the implementation properties were seperated
06:45:54 <daguerre> O - x,y are sample names. The true are in polish, but let's name them:
06:45:54 <daguerre> data Instruction= String
06:45:54 <daguerre> and the message is:
06:45:54 <daguerre>     Couldn't match expected type `Identifier'
06:45:54 <daguerre>            against inferred type `String'
06:46:14 <FunctorSalad> you need to name the constructor
06:46:20 <subconscious> daguerre: oh you should use type instead of data
06:46:22 <FunctorSalad> data Instruction = MakeInstruction String
06:46:43 <FunctorSalad> or data Instruction = Instruction String. this makes "Instruction" both the name of your type and of your constructor
06:47:15 <daguerre> subconscious: worked:) maybe in a minute I'll have more quests. Thx.
06:47:17 <FunctorSalad> which is a bit confusing at first but has the advantage that you need to keep track of fewer names mentally
06:47:27 <Jedai> Or type Instruction = String (that creates a synonym for String)
06:48:49 <FunctorSalad> so.... equality of objects is usually decidable in real-world ;-) category theory, right?
06:49:01 <subconscious> FunctorSalad: no not at all
06:49:14 <FunctorSalad> subconscious: I mean in what one actually does with CT
06:49:35 <FunctorSalad> subconscious: the only purpose of equality of objects seems to be to define composeability of morphisms
06:50:16 <FunctorSalad> subconscious: I mean strict *equality*, not isomorphy
06:50:31 <daguerre> The other problem is here : http://hpaste.org/10584
06:50:45 <daguerre> same, with the typing
06:51:45 <olsner> error: identifier unpronouncible :D
06:52:42 <daguerre> olsner: it's Polish
06:54:02 <FunctorSalad> subconscious: whether to assume decidability is an important design decision in this thing I'm writing, so I'd be curious about your opinion
06:57:46 <FunctorSalad> of course, morphism equality would not be assumed to be decidable.
06:57:59 <daguerre> anyone can help ? http://hpaste.org/10584
06:59:13 <ac> Axman6: what?
06:59:20 <FunctorSalad> you could argue that object equality may depend on morphism equality, like equality of two pullbacks being dependent on equality of the functions being pulled back
06:59:27 <Axman6> wondering how you're going with those problems
06:59:46 <FunctorSalad> but in such situation isomorphisms of the objects is enough
06:59:52 <ac> Actually working on 19. Can't figure out why State is called State
06:59:58 <FunctorSalad> hmm, I'll take this to logic
07:00:02 <FunctorSalad> err, #logic
07:00:14 <BONUS> ac: it represents a state transition
07:00:22 <BONUS> a function of s -> (s,a)
07:00:24 <BONUS> it takes some state
07:00:26 <ac> but it doesn't contain state
07:00:31 <BONUS> and returns a new state and a result
07:00:35 <BONUS> no it doesnt per se
07:00:39 <BONUS> its a stateful function
07:00:58 <ac> and why is it a record?
07:01:18 <BONUS> so we can make it part of a typeclass
07:01:34 <BONUS> think about it like this
07:01:40 <Axman6> ac: yeah i manages to grok 19. banana for State is a bitch though
07:01:46 <BONUS> if you wanna make it part of Fluffy, you have to return a new stateful function
07:02:09 <kaspyanand> hi i want to understand this piece of code
07:02:13 <kaspyanand> fib = 0 : 1 : zipWith (+) fib (tail fib)
07:02:17 <ac> right... I haven't actually used State before
07:02:22 <kaspyanand> generates fibonaaci numbers
07:02:54 <Axman6> kaspyanand: i've usually seen it written as 1:1:...
07:02:58 <Axman6> but anyway
07:03:14 <Axman6> kaspyanand: do you know how zipWith works?
07:03:17 <BONUS> the first two fibonnaci numbers are 1, 1
07:03:18 <BONUS> :)
07:03:19 <ac> kaspyanand: just look at the type signature of zipWith and think about what tail does, and it makes sense
07:03:55 <ac> :t zipWith
07:03:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:04:05 <ac> > tail [1, 2, 3]
07:04:06 <lambdabot>   [2,3]
07:04:08 <kaspyanand> well first execution will be this zipWith (+) [0,1] [1],returns [1]
07:04:21 <BONUS> > zipWith (+) [1..3] [5..7]
07:04:23 <lambdabot>   [6,8,10]
07:04:27 <kaspyanand> rite
07:04:46 <ac> kaspyanand: don't bother trying to understand _how_ it works. That's the compiler's job
07:05:00 <BONUS> yeah hehe, its good to understand the why
07:05:03 <Axman6> kaspyanand: why do you say that?
07:05:10 <Axman6> uh, ac. sorry kaspyanand
07:05:43 <kaspyanand> so am i rite that first zipWith (+) [0,1] [1] is evaluated
07:06:20 <Axman6> kaspyanand: basicallt it's adding the n-1th and nth elements of itself
07:06:39 <Axman6> > zipWith (+) [0,1] [1]
07:06:40 <lambdabot>   [1]
07:06:59 <olsner> hmm, you should rather think about it as starting with evaluating zipWith (+) (0:1:...) (1:...), where "..." is stuff that hasn't yet been evaluated
07:07:11 <Axman6> > zipWith (+) [0,1,1] [1,1]
07:07:12 <lambdabot>   [1,2]
07:07:21 <Axman6> > zipWith (+) [0,1,1,2] [1,1,2]
07:07:22 <lambdabot>   [1,2,3]
07:07:28 <Axman6> > zipWith (+) [0,1,1,2,3] [1,1,2,3]
07:07:29 <lambdabot>   [1,2,3,5]
07:07:36 <Axman6> etc
07:07:44 <kaspyanand> axman6:rite
07:08:06 <olsner> I think there's a nice graph representation of that fib definition somewhere
07:08:14 <ac> Axman6: why do I say what?
07:08:55 <Axman6> that he doesn't need to understand how it works. it's very useful in understanding recursion
07:09:37 <subconscious> olsner: graph ?
07:10:07 <ac> Axman6: oh, I just meant that as long as the code makes perfect sense, I don't see the point in digging any deeper. It's the spirit of declarative programming
07:10:10 <subconscious> fib = 0 : 1 : zipWith (+) fib (tail fib)
07:10:20 <subconscious>     = 0 : 1 : zipWith (+) (0 : 1 : zipWith (+) fib (tail fib)) (tail (0 : 1 : zipWith (+) fib (tail fib)))
07:10:49 <subconscious> if you just substitute in and collapse it down you see what happens
07:10:51 <Axman6> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs !! 100
07:10:52 <lambdabot>   573147844013817084101
07:11:06 <subconscious> in reality textual substitution isn't exactly what happens though
07:11:07 <olsner> http://www.lcc.uma.es/~blas/pfHaskell/gentle/fig1.gif hmm, this is the image I'm thinking of, but it doesn't actually make much sense
07:11:22 <subconscious> yeah that doesn't make sense
07:11:59 <subconscious> that's a shame
07:12:05 <Axman6> yeah :\
07:12:47 <Axman6> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in sum $ take 100 fibs
07:12:48 <lambdabot>   927372692193078999175
07:13:21 <Axman6> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in map (\n -> sum $ take n fibs) [1..]
07:13:22 <lambdabot>   [1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17710...
07:13:30 <Japsu> @oeis 1 2 4 7
07:13:35 <lambdabot>  Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3).
07:13:35 <lambdabot>  [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,...
07:13:40 <Beelsebob> Axman6: scanl?
07:13:43 <ac> Axman6: really it was a unhelpful thing to say.
07:13:50 <Japsu> @oeis 1 2 4 7 12 20
07:13:50 <lambdabot>  Fibonacci numbers - 1.
07:13:50 <lambdabot>  [0,0,1,2,4,7,12,20,33,54,88,143,232,376,609,986,1596,2583,4180,6764,10945,17...
07:14:28 <_ar> how do i pass command line arguments to a program when invoking main in ghci?
07:14:32 <Axman6> Beelsebob: sure
07:14:40 <Axman6> what's scanl do?
07:14:48 <ac> For some reason I implemented banana2 and 3 with apple and furry' without noticing the "bonus" and that there's a much easier way to do it using just banana
07:14:48 <Axman6> @src scanl
07:14:49 <lambdabot> scanl f q ls = q : case ls of
07:14:49 <lambdabot>     []   -> []
07:14:49 <lambdabot>     x:xs -> scanl f (f q x) xs
07:15:35 <Axman6> > scanl (+) 1 [1..]
07:15:36 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
07:15:47 <Axman6> > scanl (+) 0 [1..]
07:15:49 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
07:16:11 <Axman6> oh, triangular numbers
07:16:20 <Axman6> > scanl (*) 0 [1..]
07:16:25 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
07:16:26 <Axman6> > scanl (*) 1 [1..]
07:16:34 <ac> BONUS: what do you mean "so you can make it part of a type class". A record isn't necessary for that is it?
07:16:39 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
07:18:20 <BONUS> no, but like
07:18:39 <Axman6> > scanl (*) (-1) [1..]
07:18:40 <lambdabot>   [-1,-1,-2,-6,-24,-120,-720,-5040,-40320,-362880,-3628800,-39916800,-4790016...
07:19:05 <BONUS> if you want to make a function a part of a typeclass
07:19:07 <Axman6> > scanl (*) (-1) [(-1)..]
07:19:09 <lambdabot>   [-1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:19:11 <BONUS> you often have to wrap it in a newtype
07:19:56 <BONUS> that's why it's a record, it's just wrapped. it doesn't have to be, it could also just be newtype State = State (s -> (s,a))
07:24:09 <Blub\0> oh my... why have I never heard of literate programming? :O
07:24:09 <ac> BONUS: ah ok. But then you'd need to define state too. Is newtype actually equivalent to a single element record?
07:24:22 <_ar> what does it mean if ghc is giving me linker errors (undefined references)
07:24:32 <ac> _ar: use --make
07:25:41 <_ar> ac: much better output. it seems like libhscurses can't link to curses functions
07:25:55 <_ar> can i tell it where my curses lib is?
07:26:52 <ac> _ar: I'm sure you can. I've never actually run accross a link error when using --make
07:27:31 <ac> is this correct: furry f a = State $ (\(s, c) -> (s, f c)) . (state a) -- ?
07:28:30 <_ar> hehe it just needed -lncurses... i'm just a beginner
07:29:39 <Axman6> ac: what's state there?
07:29:53 <Axman6> you're not supposed to use predefined stuff, that's just cheating ;)
07:30:20 <ac> the accessor for State. I'm not using anything predefined
07:30:57 <Saizan> ac: if furry :: (a -> b) -> f a -> f b then yes
07:31:13 <Axman6> oh right, furry
07:31:28 <Axman6> mine was furry f (State s) = State (\x -> let (y, z) = s x in (y, f z))
07:31:31 <ac> What's a use case of fmap for State?
07:32:24 <Saizan> ac: e.g. when your state is a record and you want to access a field:  field `fmap` get
07:32:42 <ac> Axman6: ah, using a pattern match is more clear
07:32:44 <Axman6> i still don't get State
07:32:50 <Saizan> ac: in fact there's a specialized function for that case, gets
07:33:02 <Axman6> ac: what do you mean?
07:33:10 <ac> Saizan: you mean in the FRef library?
07:33:35 <Saizan> ac: i'm just talking about plain haskell records and Control.Monad.State
07:34:06 <ac> Axman6: I mean I should have written: furry f (State a) = State $ (\(s, c) -> (s, f c)) . a
07:34:32 <Saizan> however fmap is often useful with every monad, it's common to have to process the result of an action with a pure function
07:34:33 <Axman6> i like mine better... i can't see what yours is doing :P
07:34:41 <Axman6> all comes back to my naming of things ;)
07:36:15 <Axman6> ac: had a go with banana yet?
07:36:44 <Saizan> Axman6, ac: btw, your implementations of "furry" are subtly different
07:37:22 <Saizan> ac's one is stricter
07:37:27 <Axman6> Saizan: how so? (i don't fully understand ac's)
07:38:19 <Saizan> Axman6: where you use "let (y,z) =", ac uses "(\(s,c) -> "
07:38:43 <Saizan> and the lambda actually checks that the tuple is not bottom
07:38:49 <Saizan> while the let doesn't
07:38:56 <Saizan> > let (x,y) = undefined in ()
07:38:57 <lambdabot>   ()
07:39:02 <Saizan> > (\(x,y) -> ()) undefined
07:39:03 <lambdabot>   mueval: Prelude.read: no parse
07:39:03 <lambdabot>  mueval: *** Exception: Prelude.undefined
07:39:04 <Aviator> which one to use: hxt or hxml?
07:39:14 <ac> Saizan: very interesting
07:39:17 <Axman6> hmm, fair enough
07:39:39 <Saizan> > (\ ~(x,y) -> ()) undefined  -- this is equivalent to the let version
07:39:41 <lambdabot>   ()
07:39:52 <Saizan> because ~ makes a pattern irrefutable
07:40:06 <ac> I've never seen ~ used
07:41:01 <Axman6> is that the same sort of thing as ! being used to ensure strictness?
07:41:06 <Saizan> ~ essentially delays the pattern match until you actually use the parts it binds to variables
07:41:34 <Saizan> they are sort of dual :) but ~ is haskell98
07:41:53 <Axman6> so like the opposite of ! then
07:41:57 <Saizan> > case Nothing of ~(Just x) -> 1
07:41:58 <lambdabot>   1
07:42:02 <Saizan> > case Nothing of ~(Just x) -> x
07:42:04 <lambdabot>   mueval: Prelude.read: no parse
07:42:04 <lambdabot>  mueval: *** Exception: /tmp/171275864769060...
07:42:09 <Axman6> explicit laziness?
07:43:26 <Saizan> yeah
07:45:49 <Saizan> State (\x -> let (y, z) = s x in (y, f z)) == State (\x -> (\ ~(y,z) -> (y,f z)) (s x)) == State ((\ ~(y,z) -> (y,f z)) . s)
07:46:04 <Saizan> Axman6: helps? ^^^
07:46:32 <Axman6> sure
07:46:34 <Axman6> >_>
07:47:00 <Axman6> i think i follow. i'd need to spend a bit more time on it, but yeah
07:49:14 <DRMacIver> Interesting. David Pollack is on the review board for SIPs
07:49:25 <Heffalump> who, what?
07:52:25 <DRMacIver> oops
07:52:31 <DRMacIver> Sorry, wrong channel
07:53:03 <DRMacIver> (Scala related comment)
07:57:00 <ac> Axman6: you're right, 'banana' for 'Misty (State s)' is a pain
07:57:16 <Axman6> i have something that typechecks...
07:57:38 <Axman6> but i have no idea how to test it ---
07:57:40 <ac> Axman6: I understand what I should do... just can't get the types to match up. It would be easy to throw away the state and still have something that type checks
07:58:11 <Axman6> banana f (State s) = f y where ~y = snd $ s undefined, ha
07:58:21 * ac looks away
07:58:30 <Axman6> pretty sure that's wrong
07:58:36 <Axman6> if it's not... State's fucked
07:58:56 <Saizan> using undefined is almost always wrong :)
08:00:16 <Axman6> yah
08:00:24 <Saizan> mmh, maybe it would be easier to write it without caring about the newtype wrapper
08:01:21 <Saizan> i.e. write a function of type (a -> (s -> (s,b)) -> (s -> (s,a)) -> (s -> (s,b))
08:01:36 <Saizan> and don't cheat using ?djinn :)
08:03:21 <ac> Saizan: yeah the wrapper complicates it
08:04:08 <ivanm> what is meant by an "orphan instance"?
08:04:44 <Saizan> ivanm: an instance that's not declared in the same module as the class or the type
08:04:53 <ivanm> ahhhh
08:04:57 <ivanm> so it can be ignored?
08:05:08 <Beelsebob> all it does is slows down ghc slightly
08:05:20 <ivanm> (especially if I'm providing a custom instance to a datatype and class in the std libs?)
08:05:27 <ivanm> Beelsebob: run time or compile time?
08:05:31 <Beelsebob> compile
08:05:38 <ivanm> pffft, not a problem then
08:06:16 <Saizan> the only risk is that another library could define another matching instance and an user of both will get in trouble
08:07:01 <ivanm> well, I'm not ;-)
08:12:43 <ac> Axman6: ok, I'm pretty sure this is right: banana f (State a) = State $ (\(s, x) -> state (f x) $ s) . a
08:18:47 <Axman6> ac: again, where's this state function come from?
08:20:39 <Saizan> Axman6: it looks like "state (State x) = x"
08:20:57 <Axman6> hmmm
08:21:04 <Axman6> that does make sense then
08:22:24 <Saizan> i confirm that's right, modulo strictness as before
08:23:09 <ac> Saizan: can you give me a test case for this? I'm struggling to come up with one
08:23:28 <Axman6> yeah, i have no idea how to test this stuff
08:25:27 <Saizan> do you also have get/put defined?
08:25:37 <Axman6> no
08:25:51 <Axman6> it's just return, fmap, and (>>=)
08:27:12 <Axman6> @src get
08:27:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:27:19 <Saizan> not much to test then..
08:27:28 <Axman6> @src Control.Monad.State.get
08:27:28 <Saizan> @src State get
08:27:28 <lambdabot> Source not found. My pet ferret can type better than you!
08:27:28 <lambdabot> Source not found.
08:27:44 <Axman6> why do i get all the insults? :(
08:27:48 <Saizan> well get :: State s s, not hard to write :)
08:28:00 <Axman6> @src Control.Monad.State get
08:28:00 <lambdabot> Source not found. Just try something else.
08:28:11 <Saizan> Axman6: it's not in the database
08:28:24 <Axman6> was it something like (\s -> (s,s))?
08:28:43 <Saizan> exactly
08:28:57 <Axman6> :t get
08:28:58 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
08:29:08 <Axman6> -_-
08:29:22 <Saizan> don't care about MonadState for now
08:29:35 <Axman6> :t State get
08:29:36 <lambdabot> forall s a. (MonadState (a, s) ((->) s)) => State s a
08:29:48 <Saizan> heh
08:29:57 <Saizan> :t get :: State s s
08:29:58 <lambdabot> forall s. State s s
08:30:43 <Axman6> so, how is state used anyway?
08:31:05 <ac> my question exactly
08:32:13 <Axman6> i've asked it a few times, and it just doesn't click. it makes no sense
08:32:43 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html#3 <-- maybe this?
08:32:45 <lambdabot> Title: Control.Monad.State.Lazy, http://tinyurl.com/2sjf3c
08:33:40 <_zenon_> Axman6, have you seen the All about monads tutorial?
08:33:54 <Axman6> possibly...
08:34:01 <_zenon_> http://www.haskell.org/all_about_monads/html/statemonad.html
08:34:02 <lambdabot> Title: The State monad
08:34:11 <_zenon_> one of the best monad tutorials around imho
08:35:11 <ac> ah, random numbers... a perfect example
08:35:44 <ac> one of my first Haskell programs involved random numbers, and I remember someone suggesting to use the State Monad, but that was way over my head
08:37:00 <Saizan> yeah, threading the generator around is a perfect match for the State monad
08:38:13 <ac> then you could use '(>>=)' to go from one type of random number generator to another type (though I have no idea why you'd want to do this)
08:38:16 <Jedai> State basically allows you to have state in your monad... You can look at it with get, change it with put (or modify)
08:38:38 <ac> while using the current seed to seed the next one
08:39:08 <ndmitchell> anyone at ICFP who wants to go find some breakfast?
08:39:10 <ac> no, I'm mixing up the parameters
08:39:58 <Jedai> ac: The point is you need to have a random number generator around to generate a random number  in Haskell, you can't just pull one out of a hat like in other languages (since it would invalidate purity)
08:40:13 <olsner> hmm, how would you implement something like forkST?
08:40:18 <ac> Jedai: right, I'm just trying to figure out when you'd use (>>=) for State
08:40:39 <Jedai> ac: So when you want to generate several random numbers, you need to thread the generator, something like :
08:41:42 <Jedai> let (rn, g') = random g; (rn2, g'') = random g'; (rn3, g''') = random g'' in rn + rn2 + rn3
08:42:00 <Jedai> Which quickly become inconvenient !
08:42:07 <olsner> dons: parallelised version of the STUArray (converted to use IOUArray due to using forkIO) spectral-norm complete :D
08:42:33 <Jedai> With State and with a State action like randomS = State random
08:42:41 <bos> people are at ICFP already? wow.
08:42:58 <ndmitchell> yep, got here last night
08:43:24 <Jedai> You can do that with : do { rn <- randomS; rn2 <- randomS; rn3 <- randomS; return $ rn + rn2 + rn3 }
08:43:29 <ac> ah I see. So you could use (>>=) to get several random numbers... actually you'd want replicateM, right?
08:43:58 <ac> :t replicateM
08:43:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:44:08 <Jedai> Which is much neater, you can even use the common monad function to make that even better
08:44:17 <Axman6> rawr, i don't get how get and put work
08:44:19 <Igloo> bos: There are workshops before ICFP itself
08:44:42 <Jedai> do { rns <- replicateM 3 randomS; return $ sum rns }
08:44:46 <Axman6> are you only allowed to have one state monad in your program?
08:44:55 <Axman6> there does put put things?
08:45:09 <ndmitchell> ML workshop and poster session are today
08:45:15 <Jedai> Axman6: Why would you be ? State is just a type and a monad like any other
08:45:17 <dons> olsner: woot.
08:45:21 <dons> bos, when do you arrive?
08:45:37 <ac> where is this ICFP anyway?
08:45:52 <Axman6> Jedai: but when you do put x, you get nothing back from that, so how do you get that x back?
08:46:05 <Jedai> Axman6: You use get
08:46:15 <Axman6> but how does get get that x?
08:46:18 <ac> Axman6: it goes in to the State, right?
08:46:19 <Jedai> Axman6: The point is the monad carry the state for you
08:46:36 <Axman6> ...
08:46:48 <ndmitchell> Canada, Victoria, British Columbia
08:47:04 <dons> ndmitchell: you coming to icfp?
08:47:08 <ac> whaaat? That's just a ferry ride from here
08:47:12 <Jedai> Axman6: Just try to follow a simple State computation, you'll see the state pass from one action to the next by the >> or >>=
08:47:17 <ac> I should be there
08:47:20 * dons points at #haskell-icfp for those who want to catch up while there.
08:47:34 <bos> dons: wednesday
08:47:34 <olsner> dons: oh, don't know if you caught that comment yesterday, but the parallel versions on the wiki seem wildly incorrect, missing the required barrier between iterations (instead running each iteration in parallel on the same memory area :S)
08:47:52 <dons> olsner: right :)
08:48:01 <dons> they can fight for who gets to write.
08:48:42 <dons> olsner: the definition of "required barriers" is unclear, as the spec says nothing about parallel strategies.
08:48:53 <Axman6> Jedai: ok, say i have a program, and i just run do x <- get, without having done anything else, like setting the state. what happens?
08:49:09 <Axman6> i don't give get anything to work on, but it gives me something back
08:49:40 <dons> olsner: once you're done, we need to revisit binary-trees
08:49:42 <Jedai> Axman6: You can't... To run a State computation you have to use "runState" (or evalState)
08:49:48 <dons> seee if there's a way to control GC, without -A300M
08:50:04 <Jedai> Axman6: What you're asking for don't make sense and can't be done
08:50:10 <olsner> well, the algorithm does require the barriers since each iteration depends on the data produced by the previous one :) see e.g. the OpenMP barrier pragmas in http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=gpp&id=3
08:50:11 <lambdabot> Title: spectral-norm C++ GNU g++ #3 program | x64 Ubuntu : Intel® Q6600® quad-core Co ..., http://tinyurl.com/4lhedc
08:50:28 <ac> :t runState
08:50:29 <lambdabot> forall s a. State s a -> s -> (a, s)
08:50:31 <Jedai> Axman6: Anyway "get" is not an IO action so you can't put it in main
08:50:37 <dons> olsner: oh, are the numbers I was getting widly wrong? did i not spot that.
08:51:07 <Axman6> Jedai: well i wasn't necessarilly saying in main (though from waht i said it implied it was i guess)
08:51:17 <ac> ok, I totally get the State Monad. (It helps to implement it :-P)
08:51:19 <olsner> they weren't so far off, oddly enough, only calculated incorrectly
08:51:25 <_zenon_> Axman6, let k = execState $ do { x <- get ; put (x+1); return ()}
08:51:30 <_zenon_> k :: Int -> Int
08:51:40 <dons> right. so we need a proper soln either way
08:51:52 <Jedai> Axman6: The point is : You write a computation in the State monad, and when you need it's result, you run it with "runState" giving it an initial state
08:51:55 <dons> olsner: but worth checking what the other langs do
08:52:17 <Axman6> hmm, i think i may be starting to get it...
08:52:36 <ac> arhg, does anybody else find that GMail crashes Firefox a LOT?
08:52:42 <dons> olsner: and by "not far off" you mean, "the same" ? 1.274224153 == 1.274224153
08:52:43 <Jedai> > runState (do { x <- get ; put (x+1); return (x-1) }) 5
08:52:44 <lambdabot>   (4,6)
08:52:45 <Axman6> so, you set up the computations to get a result, and then in the end, you put in a value, and get a result?
08:52:46 <dons> olsner: old and new.
08:52:57 <dons> olsner: so that might just be the threads are forked in the right order ...
08:52:57 <_zenon_> ac, hm. no, but I do get logged out a lot
08:53:30 <Jedai> Axman6: As you see, 5 was the initial state, 4 is the returned value and 6 is the final state
08:53:40 * ac looks in to taking the Victoria clipper to ICFP
08:53:59 <olsner> dons: try running with something like -N1000 and see if you get something less the same (I got something like a one millionth difference though)
08:54:13 <Axman6> ac: if you see any posters explaining the state monad clearly, take pic eh? :P
08:54:51 <olsner> it seems the benchmark doesn't check for incorrect implementations very well (or that each iteration doesn't give much extra precision)
08:57:13 <Jedai> Axman6: Yeah, that's it
08:57:27 <Axman6> ?
08:57:35 <Jedai> <Axman6> so, you set up the computations to get a result, and then in the end, you put in a value, and get a result?
08:57:44 <Axman6> ah ha!
08:57:48 <Axman6> good!
08:58:14 <Axman6> so it's like building up a function, and then when you're ready, you give it a value?
08:58:24 <Jedai> Axman6: In fact you can also get the final state or just the final state, that's why there are runState, execState and evalState
08:58:26 <ac> Axman6: exactly
08:58:30 <Jedai> Axman6: Yes
08:58:57 <Axman6> ok, i need a good example now...
08:59:01 <Jedai> Axman6: In fact the State monad is just a function if you look at it from the right angle
08:59:16 <Axman6> yeah, i kinda noticed thqat
08:59:18 <Axman6> -q
08:59:18 <ac> Axman6: all the monad functions are for stringing together stateful functions to get a more and more complicated stateful function
08:59:23 <Jedai> Axman6: An useful example or a simple example ?
08:59:44 <Axman6> start with simple, then useful :P
08:59:56 <ac> Axman6: I mean all the monad functions for State
09:00:11 <Jedai> > execState (do { x <- get ; put (x+1); return (x-1) }) 5
09:00:12 <lambdabot>   6
09:00:25 <Jedai> > evalState (do { x <- get ; put (x+1); return (x-1) }) 5
09:00:26 <lambdabot>   4
09:00:35 <Jedai> > runState (do { x <- get ; put (x+1); return (x-1) }) 5
09:00:36 <lambdabot>   (4,6)
09:00:37 <Axman6> so execState executes the fu8nctions you've set up?
09:00:55 <FunctorSalad_> ndmitchell: small idea for derive: maybe make it recognize unexpected stuff in the {! ...Classes... !} inside the deriving clause, rather than generating a tempfile that contains a non-existing function :)
09:01:10 <Jedai> Axman6: execState executes the function we've set up and returns us the final state
09:01:19 <FunctorSalad_> oh, too late
09:01:25 <Axman6> and evalState?
09:01:25 <ac> execState is essentiall snd . runState, right?
09:01:32 <Jedai> Axman6: evalState does the same but returns the final result
09:01:47 <FunctorSalad_> only runState is elementary AFAIK
09:01:49 <Jedai> ac: Right (that's probably its exact definition)
09:01:59 <FunctorSalad_> @src StateT
09:02:00 <lambdabot> Source not found. There are some things that I just don't know.
09:02:02 <Axman6> so how are they different, you said they both return the final state?
09:02:19 <Jedai> Axman6: and runState does the same but returns a pair of (final result, final state)
09:02:34 <Axman6> hmm, i'm not sure i understand that
09:02:43 <Axman6> what's the final state then?
09:02:59 <ac> what's returned
09:03:00 <Jedai> Axman6: 6 because we used "put (x+1)
09:03:13 <Axman6> the result is the result of putting the value into the functions you've set up. but the state?
09:03:23 <FunctorSalad_> Axman6: runState is just the name of the constructor argument of State :) ("data State s a = State { runState :: s -> (a,s) }")
09:03:24 <Jedai> Axman6: The final result is 4 because the last operation is "return (x-1)
09:03:44 <Axman6> ah. hmm
09:03:54 <Axman6> ok, let me give it a go...
09:04:20 <FunctorSalad_> it almost seems too simple to do anything useful, but the convenient stuff happens with the MonadState instance
09:04:24 <FunctorSalad_> that one gives you put and get
09:04:52 <Axman6> > runState ( do { x <- get; put (+2); put (-5)}) 4
09:04:53 <lambdabot>       No instance for (Num (a -> a))
09:04:53 <lambdabot>        arising from a use of `negate' at...
09:05:15 <Axman6> > runState ( do { x <- get; put (+2); put (-5), return x}) 4
09:05:16 <lambdabot>   mueval: Prelude.read: no parse
09:05:26 <Axman6> > runState ( do { x <- get; put (+2); put (-5); return x}) 4
09:05:27 <lambdabot>       No instance for (Num (a -> a))
09:05:27 <lambdabot>        arising from a use of `negate' at...
09:05:33 <Axman6> :|
09:05:56 <FunctorSalad_> you are putting the function (+2) there
09:06:04 <Jedai> Axman6: You're trying to put function in the state, I'm quite sure that's not what you want
09:06:06 <daguerre> anyone can help ? http://hpaste.org/10584 - I've problem with typing
09:06:06 <anders^^> should be x+2
09:06:07 <Axman6> > runState ( do { x <- get; put (x+2); put (x-5); return x}) 4
09:06:09 <lambdabot>   (4,-1)
09:06:17 <olsner> ah, parallelisation is really cool :D
09:06:49 <FunctorSalad_> famous last words ;-)
09:06:51 <FunctorSalad_> j/k
09:07:09 <olsner> or maybe it's hot?
09:07:19 <Axman6> > runState ( do { x <- get; put (x+2); y <- get; put (y-5); return x}) 4
09:07:20 <lambdabot>   (4,1)
09:07:25 <FunctorSalad_> olsner: I never really tried it, was just going with the cliche that it's hard
09:07:35 <Axman6> that's what i was looking for
09:07:55 <Jedai> Axman6: You can use "modify" instead of put
09:07:58 <Saizan> daguerre: the errors come with line numbers, you should also paste that code
09:08:09 <_zenon_> daguerre, simplifying your code would not hurt you know... like A, B, C instead of SomeReallyLongName
09:08:16 <Axman6> :t modify
09:08:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
09:08:21 <Jedai> > runState ( do { x <- get; modify (+2); modify (\y -> y - 5); return x}) 4
09:08:22 <lambdabot>   (4,1)
09:08:44 <_zenon_> daguerre, but as Saizan says, the line # would be nice
09:08:47 <olsner> not been too bad actually, but I've only gotten to the trivially parallelisable problems, where you basically just have to split a range between a set number of threads, fork then synchronize
09:08:47 <Axman6> > runState ( do { x <- get; put (x+2); y <- get; modify (y-5); return x}) 4
09:08:48 <lambdabot>       Occurs check: cannot construct the infinite type: s = s -> s
09:08:48 <lambdabot>        Exp...
09:09:02 <Axman6> > runState ( do { x <- get; put (x+2); y <- get; modify (-5); return x}) 4
09:09:03 <lambdabot>       No instance for (Num (s -> s))
09:09:03 <lambdabot>        arising from a use of `negate' at...
09:09:24 <Deewiant> Axman6: (-5) is of type Num a => a
09:09:28 <Jedai> Axman6: (-5) is a negative number, not a section (special case)
09:09:31 <Deewiant> you want (subtract 5)
09:09:35 <FunctorSalad_> olsner: I haven't worked with parallelisation directly, but this ArrowList thing in the haskell xml toolkit feels very parallel
09:09:43 <Axman6> ah, right
09:09:54 <Jedai> > runState ( do { x <- get; modify (+2); modify (substract 5); return x}) 4
09:09:55 <lambdabot>   mueval: Prelude.read: no parse
09:10:05 <Jedai> > runState ( do { x <- get; modify (+2); modify (substract 5); return x}) 4
09:10:06 <lambdabot>   mueval: Prelude.read: no parse
09:10:11 <Jedai> > runState ( do { x <- get; modify (+2); modify (subtract 5); return x}) 4
09:10:12 <lambdabot>   (4,1)
09:10:13 <FunctorSalad_> olsner: ArrowList a b = ArrowList a -> [b], and the composition is concatMap
09:10:25 <olsner> basically, the list monad but an arrow?
09:10:32 <FunctorSalad_> yeah
09:10:48 <FunctorSalad_> surely there is an arrow that is specifically meant for parallel computing?
09:11:08 <olsner> hmm, maybe ArrowArray or something :D
09:11:50 <FunctorSalad_> the arrows seem to be easier to compose pointlessly than monads
09:11:51 <Axman6> hmm, i'm still not comfortable with State
09:11:58 <olsner> there's supposed to be some kind of parallel array comprehension syntax under development
09:12:03 <FunctorSalad_> (not sure why exactly)
09:13:35 <FunctorSalad_> maybe just because the &&& and friends are encouraged
09:13:42 <Axman6> olsner: the NDP stuff?
09:13:59 <olsner> wow, removing a single inline pragma made the benchmark run more than 100 times slower :D
09:14:10 <olsner> Axman6: yeah
09:14:11 <Saizan> FunctorSalad_: well, how do you compose something that's not an arrow?:)
09:14:16 <ac> grrr, it confuses me that the convention is (result, state) and not (state, result)
09:14:25 <Axman6> like [x+y | x<- [1..10]|y<-{2..11]]
09:15:57 <Jedai> ac: why ? it's a convention
09:16:10 <Axman6> ac: the opposite of the way it was in those exercises?
09:16:41 <Jedai> Axman6: That's parallel list comprehension (a GHC extension), it has nothing to do with NDP
09:16:56 <Jedai> Axman6: The NDP stuff is between [: :]
09:16:57 <Axman6> ah, right
09:17:00 <Axman6> yeah
09:17:17 <Jedai> @type State get
09:17:18 <lambdabot> forall s a. (MonadState (a, s) ((->) s)) => State s a
09:17:23 <Axman6> i love the way that concat was O(1) for that :)
09:17:30 <ac> Axman6: yeah, the exercises also swapped the arguments for (>>=) which certainly didn't help me
09:17:35 <BONUS> hey ac and axman, did you finish those exercises :)
09:17:41 <ac> BONUS: yeah
09:17:46 <BONUS> kewl
09:17:52 <ac> BONUS: you're not the one who wrote them are you?
09:17:55 <TomMD> ?djinn a -> b -> c
09:17:55 <lambdabot> -- f cannot be realized.
09:17:56 <BONUS> no no
09:18:14 <BONUS> a cool thing to do though
09:18:21 <BONUS> is to implement banana as banana = flip bnd
09:18:24 <BONUS> and then make a function bnd
09:18:27 <BONUS> that's just flip banana
09:18:42 <BONUS> and then instead of implementing banana, implement bnd
09:19:14 <Axman6> hmm, compiling erlang while on battery. maybe not such a good idea...
09:19:16 <BONUS> because m a -> (a -> m b) -> m b is easier to use than (a -> m b) -> m a -> m b
09:19:46 <ac> That would make sense. Hmm, could you swap the params to State too? How would the syntax work for that?
09:19:54 <Axman6> ok, sleep time/ goodnight all, and thanks for the State help :)
09:20:02 <BONUS> you mean that it's s -> (a, s) instead of s -> (s ,a)
09:20:32 <_zenon_> Axman6, sure, np
09:20:45 <BONUS> you could, but you wouldnt benefit much
09:21:02 <Saizan> s -> (s,a) actually makes more sense, i don't know why it's the other way in mtl
09:21:15 <BONUS> why does it make more sense
09:21:41 <Saizan> because (,) s is a Functor :)
09:21:52 <BONUS> yeah, that it is
09:24:26 <BONUS> i was thinking
09:24:28 <ac> I'm not sure if this question makes sense, but what if I wanted 'instance Misty (State _ s) where ...' How do you paramaterize over the second paramater?
09:24:34 <Jedai> @src State
09:24:34 <lambdabot> Source not found. Maybe you made a typo?
09:24:35 <BONUS> you cant
09:24:39 <BONUS> i was just about to say that
09:24:54 <BONUS> if you could make explicit parametrisation
09:24:57 <ac> there isn't a flip for type constructors?
09:25:05 <BONUS> nope
09:25:11 <ac> damn
09:25:16 <Jedai> ac: You have to do a newtype with the type arguments flipped (sorry)
09:25:26 <BONUS> so that you could make (a,s) a functor by doing instance Functor (,) ? s
09:25:52 <Jedai> I wonder how hard it would be...
09:29:07 <_ar> if i wanted to print all of the numbers from 1 to 100 what's the best way to do that? is there a way to get an expansion that's like >> print 1 >> print 2 >> ...
09:30:12 <Saizan> _ar: yes, mapM print [1..100]
09:30:29 <Saizan> or mapM_
09:31:08 <_ar> thank you Saizan
09:31:10 <ac> in this case you want mapM_, as it doesn't save the non-existant result
09:36:39 <ac> looks like the 25th is the day to go
09:39:16 <b\6> f0 :: Foo -> IO (Maybe Bar). f1 :: Bar -> IO (Maybe Baz). that is, f1 needs f0's output. what's the cool way to get Maybe Baz without lots of boilerplate pattern matching?
09:41:41 <olsner> oh, this is interesting... this seems faster than the C++ version by something like 6x :D
09:44:01 <IsoPallo> You are writing bad C++...
09:45:03 <Axman6> olsner: what's 'this'?
09:45:14 <olsner> Axman6: spectral-norm benchmark
09:45:15 <Olathe> IsoPallo: Where is the code ?
09:45:43 <olsner> but it gives a different result by 2e-9 ... don't know if that means it's "wrong"
09:46:16 <b\6> are you calculating numbers of donuts? if so, seems close enough.
09:57:04 <dino-> b\6: Your types of f0 and f1 look a lot like types involved in (>>=)
09:57:30 <dino-> :t (>>=)
09:57:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:58:07 <Axman6> dino-: (>>=) and join maybe?
09:58:15 <newsham> what's causing this compiler error?  http://hpaste.org/10586
09:58:17 <b\6> but join needs the monads to be the same.
09:58:24 <Axman6> oh yeah
09:59:00 <Axman6> ok, batteries' dead. night all
09:59:11 <b\6> if i >>=, the right side needs to be something that wants Maybe.
09:59:36 <_zenon_> Axman6, not going to bed?
09:59:41 <dmwit> newsham: Maybe upgrade your regex library?
10:00:04 <Axman6> _zenon_: yeah i'm sleeping now. i have to be up in 4 hours :'(
10:00:07 <newsham> the one that comes with 6.8.2 is too old?
10:00:22 <_zenon_> Axman6, geesh. hehe, sleep well then,
10:00:22 <Saizan> b\6: you could use MaybeT IO as the monad
10:00:37 <_zenon_> Axman6, sounds like a case for o'l coffeé tomorrow
10:00:39 <Saizan> b\6: so f0 :: Foo -> MaybeT IO Bar
10:00:57 <dino-> mm, Maybe transformer
10:01:04 <olsner> meh, insanely large mistakes in the code give insanely small differences to the output
10:01:05 <dmwit> newsham: I don't know.  It sure seems unlikely, but I can't think of any other explanation.
10:01:34 <Saizan> MaybeT is missing from mtl but there's a package for it on hackage and/or a page on the haskell wiki
10:01:39 <b\6> Saizan: interesting, but i don't get to change types in other peoples' libraries.
10:01:51 <b\6> i'll look at it for my stuff, though.
10:01:56 <newsham> it obviously runs on the shootout site.  i wish there was more info about the requirements i guess
10:02:41 <dino-> Saizan: Ah, I thought you had to grab it from here: http://haskell.org/haskellwiki/New_monads/MaybeT
10:02:42 <lambdabot> Title: New monads/MaybeT - HaskellWiki
10:02:45 <dino-> Hackage, you say.
10:02:55 <b\6> newsham: does -optc do anything if you don't say via c?
10:03:15 <Saizan> b\6: well, it's just newtype MaybeT m a = MaybeT (m (Maybe a)), so you can wrap preexisting functions, e.g. \x -> MaybeT (f0 x) :: Foo -> MaybeT IO Bar
10:03:17 <newsham> dont know
10:03:50 <b\6> maybe try -fvia-c too.
10:04:01 <dino-> Eric Kidd!
10:04:10 <dmwit> b\6: Surely -fvia-c doesn't change the type-checking.
10:04:36 <b\6> dmwit: ? was talking about newsham's use of -optc without -fvia-c.
10:05:21 <dmwit_> b\6: Yes, but the error he's getting is a type-checking one.
10:05:26 <Saizan> the other option is to write a function :: Maybe (m a) -> m (Maybe a) and use it as you would use sequence for lists
10:06:08 <Saizan> dino-: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MaybeT
10:06:13 <lambdabot> Title: HackageDB: MaybeT-0.1.1
10:06:50 <user317> is there a way for quickcheck to check functions that return an IO
10:06:59 <dino-> ty
10:07:20 <dmwit> user317: There is an IO mockup somewhere.
10:09:16 <SidLogan> Hi everyone. Can you help me out? I'm working on a uni project and I must come up with a solution for the Baguenaudier game. I must create a function that given "n" rings, I must return a list of movements where 1 means I must hook a ring and 0 means I must *unhook* it.
10:10:13 <SidLogan> Any ideas ?
10:18:11 <user317> dmwit, any idea where i can find it?
10:20:29 <tsar> if i get "Just 6" as a result, how do i get the 6?
10:21:01 <dmwit> user317: I'm not sure, no.
10:21:02 <newsham> > fromJust (Just 6)
10:21:03 <lambdabot>   6
10:21:05 <newsham> > fromJust Nothing
10:21:06 <lambdabot>   mueval: Prelude.read: no parse
10:21:07 <lambdabot>  mueval: *** Exception: Maybe.fromJust: Noth...
10:21:14 <newsham> > maybe 100 id (Just 6)
10:21:15 <lambdabot>   6
10:21:17 <dmwit> tsar: Use pattern matching, or the "maybe"/"fromMaybe" functions.
10:21:18 <newsham> > maybe 100 id Nothing
10:21:19 <lambdabot>   100
10:21:31 <dmwit> > fromMaybe 100 (Just 6)
10:21:32 <lambdabot>   6
10:21:35 <dmwit> > fromMaybe 100 Nothing
10:21:37 <lambdabot>   100
10:21:41 <swiert> tsar: use the fromJust function or pattern match.
10:21:50 <dmwit> > maybe "no result" show (Just 6)
10:21:51 <lambdabot>   "6"
10:21:52 <tsar> and where is fromJust?
10:21:55 <dmwit> > maybe "no result" show Nothing
10:21:56 <lambdabot>   "no result"
10:21:57 <Deewiant> ?index fromJust
10:21:58 <lambdabot> Data.Maybe
10:21:59 <subconscious> > let getJustSix = Just 6 in do x <- getJustSix ; return (x+1)
10:22:00 <lambdabot>   Just 7
10:22:05 <subconscious> > let getJustSix = Nothing in do x <- getJustSix ; return (x+1)
10:22:07 <lambdabot>   Nothing
10:22:10 <dmwit> tsar: Be warned!  If you use fromJust, your program can crash.
10:22:26 <newsham> "crash" is a strong term.
10:22:31 <tsar> dmwit how do i pmatch against Just 6
10:22:37 <dmwit> newsham: How would you describe it?
10:22:41 <newsham> terminate with error
10:22:54 <shepheb> I'm using a function -> StateT s IO ()   for parsing client commands. is there an elegant way to short-circuit when parsing fails (and I've already sent the error message)
10:23:03 <dmwit> newsham: Practically speaking, how is that different?
10:23:05 <Deewiant> > let f (Just x) = x + 5; f Nothing = 10 in f (Just 6)
10:23:06 <lambdabot>   11
10:23:21 <newsham> dmwit: lack of a core file? *shrug*
10:23:27 <newsham> sometimes you want a termination with error
10:23:31 <newsham> rarely do you want a crash
10:23:55 <dmwit> A crash is just a termination with a really long error.
10:25:05 <Spark> crashing usually means not cleaning up
10:25:06 <newsham> dmwit: in practice there is a difference between theory and practice.
10:25:27 <dmwit> Spark: I dare you to clean up after a failed fromJust.
10:25:49 <roconnor> dmwit: doesn't bracket do that?
10:26:05 <newsham> ro: i dare yu to bracket! :)
10:26:11 <dmwit> heh
10:26:15 <newsham> this is a silly argument.
10:26:17 <dmwit> Okay, yes, it's possible.
10:26:58 <geezusfreeek> but it's fugly
10:27:11 <olsner> dons: alternate parallel solution added here http://www.haskell.org/haskellwiki/Shootout/Parallel/SpectralNorm
10:27:12 <lambdabot> Title: Shootout/Parallel/SpectralNorm - HaskellWiki
10:27:13 <roconnor> In haskell, infinite loops are a catchable exception :P
10:27:23 <roconnor> > fix id
10:27:24 <lambdabot>   mueval: Prelude.read: no parse
10:27:25 <lambdabot>  mueval: *** Exception: stack overflow
10:27:31 <roconnor> er
10:27:36 <roconnor> not quite what I had in mind
10:27:37 <Olathe> > fix (+1)
10:27:46 <olsner> seems to be about twice as fast as the C++ version, plus being just as parallel :D
10:27:48 <geezusfreeek> :t bracket
10:27:49 <lambdabot> Not in scope: `bracket'
10:27:52 <lambdabot>   thread killed
10:27:55 <roconnor> Olathe: :P
10:28:23 <dmwit> olsner: ...does this one return the right answer? =P
10:29:07 <olsner> dmwit: yep... the one that gave a slightly wrong answer but 4x faster did so because I forgot to process 3/4 of the data
10:29:19 <Deewiant> heh
10:29:20 <subconscious> I want to implement dependent pattern matching
10:29:45 <dmwit> olsner: Wow!  1/4 of the data, and only a 2e-9 error?  ...was the answer in the 1e-9 range? =D
10:30:11 <subconscious> that bit in the epigram paper about getting the unification problem out of it is very elegant
10:30:13 <olsner> (which was funny since it was hardly noticable in the output - I thought it was just a matter of rounding error, floating point fudge, ordering of operations or something like that)
10:30:55 <subconscious> hi shapr!
10:31:02 <olsner> dmwit: correct answer is 1.274224153, working on 1/4 of the data it gave 1.274224151
10:31:23 <shapr> hiya subconscious!
10:33:29 <shepheb> I'm using a function -> StateT s IO ()   for parsing client commands. is there an elegant way to short-circuit when parsing fails (and I've already sent the error message)
10:34:26 <Olathe> You can use Maybe or something.
10:34:45 <shepheb> MaybeT might be a pretty good way to go
10:35:07 <shepheb> or ErrorT
10:36:45 <roconnor> @unmtl ErrorT e (StateT s IO) ()
10:36:45 <lambdabot> s -> IO (Either e (), s)
10:36:54 <dmwit> EarlGreyT
10:37:03 <Olathe> Heheh
10:37:03 <roconnor> @unmtl StateT s (ErrorT e IO) ()
10:37:03 <lambdabot> s -> IO (Either e ((), s))
10:38:12 <roconnor> @src throw (ErrorT e)
10:38:12 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:44:13 <shapr> Hey cool, we (#haskell) got mentioned in the A-Z of Programming Languages article for Haskell!
10:44:18 * shapr boings cheerfully
10:44:39 <b\6> finally, recognition.
10:45:00 <b\6> all these years, i knew it would pay off.
10:45:06 <shapr> Yay!
10:45:50 <ddarius> shapr: He didn't quite characterize the community correctly.  While the Haskell community is "unusually" helpful, a more accurate characterization is that it is aggressively helpful.
10:46:13 <ddarius> s/helpful/friendly/g  as well
10:46:45 <shapr> hah, true
10:47:06 <b\6> i guess there's no better time than now to announce that earlier today i proposed to dons, and he accepted. the estate of haskell b. curry has agreed for his remains to be our best man.
10:47:41 <shapr> whoa, crazy.
10:47:49 <shapr> That's it, I'm going hom.
10:47:54 <shapr> er, home*
10:47:59 <shapr> That didn't sound right, did it?
10:48:05 <shapr> aanyway
10:51:17 <Riastradh> Going homomorphic?
10:51:30 <Riastradh> Do you linearly transform?
10:51:53 <shapr> something like that
10:52:02 <shapr> Mr Cambpell, how's life?
10:52:28 <Riastradh> Life is happening.  A roving rhinovirus has interrupted mine, to my chagrin, but it will pass.
10:53:17 <olsner> ddarius: heh, yeah, asking a question in #haskell gets you spammed with answers rather than flames
10:53:36 <Riastradh> I shall remain in Boston for another couple of hours.
10:54:04 <shapr> Riastradh: What? You're in Boston? Where?
10:54:28 <shapr> Riastradh: Dude, I want to meet you!
10:55:39 <shapr> Somewhere in East Boston?
10:55:47 <Riastradh> Sorry, right now you probably don't want to come near me (*cough*hack*hurk*), and I'm about to vanish to the hinterlands of the north for some time.
10:56:00 <shapr> aww
10:57:31 <shapr> Riastradh: How long?
10:58:27 <dmwit> :t (((,) <$>) .) . (<*>)
10:58:28 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => f (a -> b1) -> f a -> f (b -> (b1, b))
10:58:37 <Riastradh> About a year, possibly with some brief interludes.
10:58:42 <shapr> oh
10:58:50 <shapr> I don't even know if I'll still be in Boston in a year.
10:59:01 <ziman> @unpl (((,) <$>) .) . (<*>)
10:59:01 <lambdabot> (\ e h -> ((,)) <$> (e <*> h))
10:59:37 <qwerty> Hi everyone. Looking for pointers on undefined references to things like "containerszm0zi1zi0zi1_DataziMap_empty_closure"
10:59:49 <dmwit> qwerty: Use ghc --make.
11:01:43 <FunctorSalad_> this deriving-instances-for-tuple thing could be better...
11:02:03 <FunctorSalad> I know TH can handle it, but that would be too distracting right now :)
11:02:21 <qwerty> dwmit - hmmm ... thanks!. It links now. A short explanation for the newbie ?
11:02:41 <pfo> does ``yi'' - the haskell editor - install cleanly via cabal install with you guys?
11:02:52 * shapr tries
11:03:01 <Botje> qwerty: --make makes ghc figure out the dependencies and proper linking flags
11:03:48 <pfo> i'm getting errors about missing ``alex''  >=2.0.1 && <3 - but i have the newest alex installed via cabal install.
11:04:34 <qwerty> Botje: Any reason why this is not done by default ? Is this a ghc bug ?
11:04:36 <pfo> (which in my install is  alex 2.2)
11:04:54 <b\6> pfo: does ghc-pkg list show alex?
11:05:01 <dmwit> qwerty: Not a bug.  Why do you have to specify -lm to gcc?
11:05:46 <TomMD> pfo: I'm trying, but cabal install still isn't multi-threaded so it is taking some time :-(
11:05:51 <_ar> dmwit: because it doesn't have a --make?
11:06:01 <dmwit> _ar: =)
11:06:50 <qwerty> dmwit: Yes, of course, but this code linked fine before. I did add the State monad. But the linker seems to complain about Map.
11:07:34 <pfo> b\6: it doesn't show up indeed.
11:08:04 <pfo> b\6: i have the alex bin installed by cabal in $HOME/.bin/ tough
11:08:18 <b\6> pfo: dunno. but that's the problem. maybe remove and reinstall.
11:08:19 <TomMD> alex isn't supposed to show up as it isn't a library.
11:08:25 <b\6> no?
11:08:34 <TomMD> Not afaik.
11:08:47 <b\6> how can stuff tell whether the dependency is met?
11:08:54 <Botje> qwerty: yes, it should be a default, as (i think) dcoutts mentioned some days ago
11:09:04 <pfo> TomMD: no traces of alex in $HOME/.cabal/lib
11:09:24 <TomMD> b\6: Thats one limitation of cabal - it can't check for non-haskell libraries (so C libs and executables are not checked at config time)
11:09:55 <TomMD> pfo: $HOME/.cabal/bin is in your $PATH, right?
11:10:03 <pfo> damnit!
11:10:05 <pfo> that was it.
11:10:09 <pfo> TomMD: thx.
11:10:25 <pfo> forgot to source my haskell.sh stuff.
11:10:28 <TomMD> No problem.
11:11:03 <pfo> but that's a clear limitation of cabal not beeing able to check such stupid things like a bin in some path and report ``a no such file ...'' error.
11:11:47 <TomMD> pfo: Yes, that limitation is known and I bet there is a ticket for it.  Also, yi just finished installed - it wasn't clean (plenty of warnings) but it worked.
11:11:56 <TomMD> And I can run it!
11:12:05 <pfo> TomMD: thx for the effort
11:12:07 <shapr> built for me as well
11:12:20 <shapr> Really ghc --make should be --dwim
11:12:27 <pfo> :P
11:12:39 <Zao> --dwimc ?
11:13:00 <dmwit> What's the 'c' for?
11:13:05 <Zao> "correctly"
11:13:13 <shapr> Maybe there should be an implicit --dwim after every ghc call, and the only way to turn it off is with --no-dwim
11:13:13 <dmwit> heh
11:13:21 <Botje> isn't that implicit in the "im" part?
11:13:34 <dmwit> Yeah, it would be convenient if --make were the default.
11:13:35 <shapr> Maybe -f-no-implicit-dwim is better?
11:13:38 <Zao> dmwit: http://www.catb.org/jargon/html/D/DWIM.html
11:13:39 <lambdabot> Title: DWIM
11:13:48 <subconscious> ?jargon DWIM
11:13:49 <lambdabot> *** "DWIM" jargon "Jargon File (4.3.1, 29 Jun 2001)"
11:13:49 <lambdabot> DWIM /dwim/ [acronym, `Do What I Mean'] 1. adj. Able to guess,
11:13:49 <lambdabot>    sometimes even correctly, the result intended when bogus input was
11:13:49 <lambdabot>    provided. 2. n. obs. The BBNLISP/INTERLISP function that attempted to
11:13:49 <lambdabot>    accomplish this feat by correcting many of the more common errors. See
11:13:51 <lambdabot> [34 @more lines]
11:20:16 <dmwit> The Jargon File is oooold.
11:21:11 <dmwit> It talks about Motif as if it were currently a hot new thing...
11:24:35 <_zenon_> HEHE
11:24:39 <_zenon_> oops. caps
11:24:44 <Olathe> It'll win over all the Windows 3.1 users.
11:27:05 <roconnor> > 360 / 60
11:27:06 <lambdabot>   6.0
11:45:11 <Taejo> byorgey: can Diagrams be persuaded to output SVGs or some other vector format?
11:46:13 <dmwit> Well, it's just Cairo under the hood, so almost certainly yes.
11:49:02 <dmwit> renderAs :: OutputType -> (longish signature)
11:49:09 <dmwit> data OutputType = PNG | PS | PDF | SVG
11:49:12 <dmwit> So... there you go?
11:49:40 <Taejo> dmwit: I guess I'm using an older version
11:49:57 <dmwit> ah
11:50:19 <dmwit> Yeah, that might not be on Hackage yet; I just darcs got the dev version.
11:50:31 <Taejo> I guess I'm a fool for relying on hackage :)
11:52:48 <dmwit> Taejo: You should ?tell byorgey to package up Diagrams and put a new version on hackage. =)
11:53:01 <dmwit> It'll make him happy to know he has users.
11:53:58 <Taejo> ?tell byorgey Could you put diagrams-0.2 on hackage, please
11:53:58 <lambdabot> Consider it noted.
12:15:38 <Deviant`> Hi
12:16:12 <subconscious> hello
12:16:32 <Deviant`> ah okay, atleast I can talk, thats a start ! :)
12:17:10 <subconscious> welcome :)
12:19:16 <Deviant`> so my knowledge of haskell is pretty low, I was wondering does it have sockets / some ofor of network protocol ?
12:19:30 <subconscious> yes it does
12:19:55 <DroneZilla> > map (succ ) [1..10Ø
12:19:56 <lambdabot>   mueval: Prelude.read: no parse
12:19:59 <Deviant`> ah okay, is there a library listing somewhere ?
12:20:04 <DroneZilla> >map succ [1..10]
12:20:14 <subconscious> ?docs Network
12:20:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
12:20:18 <Deviant`> thanks
12:20:21 <Deviant`> useful bot
12:20:28 <subconscious> yeah here,   http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:20:29 <lambdabot> Title: Haskell Hierarchical Libraries
12:20:40 <subconscious> assuming you use GHC
12:20:45 <Deviant`> yeah
12:21:03 <Deviant`> wow, it has a much bigger library than I expected
12:21:18 <Deviant`> and on friday I was tring to implement bitwise expressions heh
12:21:25 <subconscious> if you think that is big :p
12:21:32 <subconscious> there is even more stuff on hackage
12:21:47 <ddarius> @hackage
12:21:47 <lambdabot> http://hackage.haskell.org
12:22:14 <Deviant`> opengl packages, the thought of doing anything with 3d in haskell is somewhat mind boggling
12:22:44 <subconscious> just doing basic stuff is mind boggling at first :)
12:22:53 <Deviant`> indeed
12:32:48 <b\6> some functions return IO (Maybe Blah). can i use ErrorT to return Either String Stuff?
12:40:40 <DroneZilla> hi
12:41:16 <roconnor> b\6: I'm not sure I understand your question
12:41:57 <b\6> roconnor: yeah, sorry. i'm pretty confused.
12:42:18 <roconnor> wanna try again? :)
12:43:36 <iago_> hi
12:44:05 <b\6> i have a lot of boilerplate to get stuff from two functions returning IO (Maybe Foo). if they both return Just Whatever, i can return the thing i actually want. if either returns Nothing, i want some explanation. i was thinking maybe i could use ErrorT but i don't know what the underlying monad parameter should be, etc.
12:44:54 <roconnor> b\6: If your function returned Monad m => IO (m Foo), then you could return (fail "error message")
12:45:15 <roconnor> > fail "I like bees" :: Just Integer
12:45:16 <lambdabot>   mueval: Prelude.read: no parse
12:45:38 * roconnor sighs
12:45:42 <roconnor> oops
12:45:47 <roconnor> > fail "I like bees" :: Maybe Integer
12:45:48 <lambdabot>   Nothing
12:45:57 <roconnor> > fail "I like bees" :: Either String Integer
12:45:59 <lambdabot>   Left "I like bees"
12:46:07 <roconnor> > fail "I like bees" :: [Integer]
12:46:08 <lambdabot>   []
12:46:14 <idnar> heh
12:46:28 <idnar> :t fail
12:46:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
12:46:35 <idnar> ah
12:46:43 * idnar confused fail with error
12:46:53 <sclv> ?ty throwError
12:46:54 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
12:46:55 <b\6> roconnor: ok, thanks. i'll study.
12:47:33 <sclv> > throwError "or this way" :: Either String Int
12:47:34 <lambdabot>   mueval: Unsafe functions to use mentioned.
12:47:45 <sclv> grrr
12:48:19 <b\6> yeah, read a bit about throwError.
12:49:02 <shapr> Hey, what's sun.haskell.org really called?
12:49:07 <sclv> throw error is the right way to throw things in an error monad.
12:49:16 <sclv> but why mueval doesn't like it is beyond me.
12:49:33 <shapr> I tried {sun,parallel,ndp}.haskell.org, but none of those are the real thing.
12:49:57 <b\6> sclv: confused about what's going on when i return IO (Either String Stuff).
12:50:59 <sclv> alternately, if you're not working monadically, you can just return Left and Right directly...
12:51:04 <_ar> i want to construct a sample population. my imperative intuition would be to loop a fixed number of times allocating sample instances, randomly populating their fields, and adding them to a list. how should such a process be translated into haskell?
12:52:06 <sclv> ?unmtl ErrorT String IO a
12:52:06 <lambdabot> IO (Either String a)
12:52:23 <sclv> ?ty runError
12:52:24 <lambdabot> Not in scope: `runError'
12:52:28 <sclv> ?ty runErrorT
12:52:30 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
12:52:32 <b\6> _ar: like maybe start by 'replicate'ing as many structures as you want. then map some function over the list that randomly screws with the fields or whatever.
12:52:37 <roconnor> b\6: IO (Either String a) contains two nested monad: IO and (Either String).  It can be confusing to know which level you are on.
12:53:30 <sclv> b\6: you can just take your plain code in the IO monad and every time you have an IO action stick liftIO in front of it.
12:53:40 <_ar> b\6. thanks. replicate was what i was looking for
12:54:15 <_ar> ?src replicate
12:54:15 <lambdabot> replicate n x = take n (repeat x)
12:54:20 <b\6> thanks for suggestions. trying stuff and studying.
12:54:20 <sclv> ?ty randoms
12:54:21 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
12:54:25 <shapr> ?ty shapr
12:54:26 <lambdabot> Not in scope: `shapr'
12:54:28 <shapr> aww
12:54:33 <shapr> @ty lambdabot
12:54:34 <lambdabot> Not in scope: `lambdabot'
12:54:38 <_ar> ?repeat
12:54:39 <lambdabot> Unknown command, try @list
12:54:42 <_ar> ?src repeat
12:54:42 <lambdabot> repeat x = xs where xs = x : xs
12:54:45 <shapr> @yw lambdabot!
12:54:45 <lambdabot> Yow!  Are we laid back yet?
12:54:48 <shapr> haha
12:54:49 <sclv> you can call randoms to get a list of randoms and turn each random into a seed for a different structure by mapping too...
12:55:21 <sclv> or get a list and chunk it into slices of 5 or however many for the number of random elements you need for each structure.
12:56:03 <sclv> keeps the whole thing lazy too so you have an infinite list... and you can chop it off whenever you really need to instead of in advance.
12:56:29 <_ar> sclv, thank you. that helps
12:58:41 <Botje> @src randoms
12:58:42 <lambdabot> Source not found. That's something I cannot allow to happen.
13:02:39 <_ar> sclv is chunk defined anywere or is that something i should implement?
13:03:19 <sclv> chunk is probably the most reimplemented not-in-stdlibs function out there.
13:04:05 <_ar> ahaa okay
13:08:47 <humasect> http://darcs.haskell.org/ghc-6.10/ == ?
13:08:52 <lambdabot> Title: Index of /ghc-6.10
13:09:12 <sclv> ?remember chunk \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
13:09:12 <lambdabot> It is forever etched in my memory.
13:09:22 <sclv> ?quote chunk
13:09:22 <lambdabot> chunk says: \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
13:09:34 <sclv> whee
13:09:42 <subconscious> @let chunk = \n -> unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)
13:09:43 <lambdabot>  Defined.
13:09:51 <subconscious> > chunk 3 ['a'..'z']
13:09:53 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
13:10:16 <BONUS> thats a pretty kewl implementation with the unfold
13:10:38 <Olathe> > chunk 3 []
13:10:39 <lambdabot>   []
13:10:47 <tsar> http://hpaste.org/10587 , im trying to generate a list of random numbers but i dont get how to call it. it compiles though
13:10:49 <Olathe> > chunk 3 [1, 2]
13:10:50 <lambdabot>   [[1,2]]
13:10:54 <Olathe> > chunk 3 [1, 2, 3, 4]
13:10:55 <lambdabot>   [[1,2,3],[4]]
13:11:35 <Botje> tsar: newGen is IO StdGen
13:12:01 <Botje> uh
13:12:04 <Botje> neeevermind :)
13:12:09 <Botje> missed a line
13:12:27 <Botje> tsar: what's x ?
13:12:40 <sclv> you need to be in IO to get a new gen
13:12:49 <Botje> did you do x <- getStdGen or let x = getStdGen ?
13:14:26 <tsar> ah cool
13:18:46 <BMeph> BONUS: It's even nicer with aguard-like function:
13:19:57 <BMeph> @let mGuard p f x = guard (p x) >> f x
13:19:58 <lambdabot>  Defined.
13:20:07 <tsar> how are Maps implemented? hashtables? redblacktrees?
13:20:16 <BONUS> balanced binary trees
13:20:18 <Botje> some kind of tree, yes
13:21:05 <BMeph> @let chunk2 n = unfold (mGuard null (Just (splitAt n))
13:21:05 <lambdabot>   Parse error
13:21:11 <shrughes>  tsar there's probably a link about it in the documentation
13:21:18 <BMeph> @let chunk2 n = unfold (mGuard null (Just (splitAt n)))
13:21:18 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
13:21:20 <BONUS> hmm pretty nice
13:21:56 <humasect> @src guard
13:21:57 <lambdabot> guard True  =  return ()
13:21:57 <lambdabot> guard False =  mzero
13:22:17 <Olathe> > guard (1 == 1) :: [Int]
13:22:18 <lambdabot>   Couldn't match expected type `Int' against inferred type `()'
13:22:24 <humasect> > mzero
13:22:25 <lambdabot>       No instance for (Show (m a))
13:22:26 <lambdabot>        arising from a use of `show' at <in...
13:22:30 <Olathe> > guard (1 == 1) :: [()]
13:22:31 <lambdabot>   [()]
13:22:34 <Olathe> > guard (1 == 0) :: [()]
13:22:34 <Twey> Hmn
13:22:35 <lambdabot>   []
13:22:44 <Twey> guard only works for MonadPlus?
13:22:47 <BMeph> > guard (1 == 1) :: [a]
13:22:48 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
13:22:49 <humasect> yep twanvl
13:22:53 <humasect> Twey*
13:22:55 <Twey> I thought it was a Monad thing
13:22:56 <BMeph> ...
13:22:59 * BMeph sighs
13:23:16 <Olathe> > let omgCBoolLol b = length $ guard b in omgCBoolLol (1==1)
13:23:17 <lambdabot>   1
13:23:26 <Olathe> > let omgCBoolLol b = length $ guard b in omgCBoolLol (1==0)
13:23:27 <lambdabot>   0
13:23:31 <Twey> Couldn't match expected type `a' against inferred type `()' -- eh what?
13:23:46 <sclv> > let ch2 n = unfold (\x -> guard (not . null) x >> take n xs) in ch2 2 [1..10]
13:23:47 <lambdabot>   mueval: Prelude.read: no parse
13:23:53 <Twey> It couldn't match a against something?
13:24:01 <BMeph> Twey: It uses mzero and () explicitly, thus it needs (MonadPlus m) => m ()
13:24:06 <humasect> it doesn't know what 'a' is.
13:24:12 <sclv> > let ch2 n = unfoldr (\x -> guard (not . null) x >> take n xs) in ch2 2 [1..10]
13:24:14 <lambdabot>   mueval: Prelude.read: no parse
13:24:15 <Twey> humasect: Exactly :-\
13:24:21 <Twey> So it should match anything
13:24:23 <BMeph> > guard (1 == 1) :: [?a]
13:24:24 <lambdabot>   mueval: Prelude.read: no parse
13:24:39 <sclv> > let ch2 n = unfoldr (\x -> guard (not . null $ x) >> take n xs) in ch2 2 [1..10]
13:24:39 <humasect> an infinite match is similar to matching nothing at all.
13:24:40 <lambdabot>   mueval: Prelude.read: no parse
13:24:48 <Olathe> > let f::[a]; f = guard (1 == 1) in f
13:24:49 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
13:24:56 <Olathe> O...K.
13:25:01 <sclv> > let ch2 n = unfoldr (\x -> guard (not . null $ x) >> take n x) in ch2 2 [1..10]
13:25:02 <lambdabot>   Couldn't match expected type `Maybe (a, [a1])'
13:25:07 <sclv> forget it.
13:25:30 <BMeph> sclv: You'll need a Maybe (b,a)
13:25:33 <Olathe> Bad Haskell !
13:25:35 <Olathe> Bad !
13:25:38 <Twey> Haha
13:26:03 <sclv> > let ch2 n = unfoldr (\x -> guard (not . null $ x) >> splitAt n x) in ch2 2 [1..10]
13:26:04 <lambdabot>   Couldn't match expected type `Maybe (a, [a1])'
13:26:41 <humasect> > guard (1 == 1) :: Maybe Int
13:26:42 <lambdabot>   Couldn't match expected type `Int' against inferred type `()'
13:27:11 <Saizan> Olathe: why do you expect that to work?
13:27:40 <BMeph> > let chunk23 n = unfold (\x->guard (null x) >> (Just (splitAt n x))) in chunk23 4 [0..17]
13:27:41 <lambdabot>   mueval: Prelude.read: no parse
13:27:52 <Olathe> > return () :: [a]
13:27:53 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
13:27:55 <BMeph> > let chunk23 n = unfoldr (\x->guard (null x) >> (Just (splitAt n x))) in chunk23 4 [0..17]
13:27:59 <lambdabot>   []
13:28:00 <esap> I wonder why STM is not in MonadPlus?
13:28:05 <humasect> > mzero :: Maybe a
13:28:06 <lambdabot>   Nothing
13:28:13 <Olathe> Saizan: Because [a] seems like a would include ()
13:28:37 <Olathe> > let f::a; f=() in f
13:28:38 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
13:28:38 <Saizan> Olathe: the 'a' is implicitly forall-ed
13:28:42 <sclv> > let ch2 n = unfoldr (\x -> guard (not . null $ x) >> Just (splitAt n x)) in ch2 2 [1..10]
13:28:44 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
13:28:49 <Olathe> What does it mean to be foralled ?
13:28:54 <sclv> but the other version was prettier.
13:29:03 <Saizan> and () can't have type forall a. a
13:29:05 <sclv> I'd really like a few more standard monadic logic constructs.
13:29:30 <Olathe> Saizan: Why not ?
13:29:31 <humasect> > [1..10] `zip` (transpose [1..10])
13:29:33 <lambdabot>       No instance for (Enum [a])
13:29:33 <lambdabot>        arising from the arithmetic sequence ...
13:29:42 <ddarius> :t transpose
13:29:43 <lambdabot> forall a. [[a]] -> [[a]]
13:29:43 <Saizan> Olathe: when you write foo :: a, you are stating that foo can be instantiated to any type
13:29:51 <BMeph> sclv: I've noticed that the ones that are really useful, but are easy to make, aren't included - case in point, swap.
13:30:04 <Saizan> Olathe: and () can only have type ()
13:30:06 <Olathe> Saizan: Ahh.
13:30:08 <sclv> as in swap (a,b) = (b,a) ?
13:30:14 <Olathe> > let f::a; f = 5 in f
13:30:15 <lambdabot>       Could not deduce (Num a) from the context ()
13:30:15 <lambdabot>        arising from the li...
13:30:19 <sclv> hmm... never needed that.
13:30:49 <humasect> what..
13:30:58 <subconscious> grr
13:31:12 <subconscious> say you have a program
13:31:27 <humasect> oh, this is a different transpose.
13:31:29 <subconscious> match :: Regex -> String -> [(String,String)]
13:31:36 <sclv> I'd really like an ifM though of the form ifM p x y = p >>= \b -> if  b then x else y
13:31:59 <BMeph> humasect: What transpose were you thinking you had? ;)
13:31:59 <humasect> > let xs = [1..10] in xs `zip` (tail $ xs ++ [head xs])
13:32:00 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
13:32:26 <humasect> BMeph: the one i was accustomed to written for this project i am working on ^_^
13:32:30 <Olathe> @type 5
13:32:31 <lambdabot> forall t. (Num t) => t
13:32:37 <sclv> ?ty let if' b x y = if b then x else y in liftM3 if'
13:32:38 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
13:32:41 <Olathe> @type ()
13:32:41 <subconscious> so it's like match regex string ~~> [list of (match, left over)]
13:32:42 <lambdabot> ()
13:32:45 <BMeph> humasect: ...(is it a secret?) ;)
13:32:45 <Olathe> Heh
13:32:46 <humasect> sclv: i wrote one too.
13:33:02 <humasect> whenM p s = p >>= \b-> if b then s else return ()
13:33:05 <subconscious> how do you state the regex thing actually works?
13:33:09 <Saizan> slarba: ifM and liftM3 if' are quite different
13:33:17 <humasect> @type if'
13:33:18 <lambdabot> Not in scope: `if''
13:33:22 <opqdonut> quite
13:33:23 <Deviant`> where and let do the same job dont they? its just a matter of preference as to which you use ?
13:33:32 <subconscious> every possible match is in there can't work, because of htings like ((a*)*) has infinite matches
13:33:34 <sclv> oh right... the liftM3 one will eval them all..
13:33:40 <humasect> Deviant`: and some scoping rules
13:33:48 <sclv> ?ty let if' b x y = if b then x else y in liftM if'
13:33:49 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
13:33:51 <humasect> BMeph: (most of it is secret=)
13:34:03 <Deviant`> let is for the whole function while where is just for the where clause ?
13:34:47 <humasect> where's cannot find let's, but let's can find wheres; when in the same scope. and where's can find where's..
13:34:56 <ddarius> humasect: tail xs ++ [head xs] would be slightly faster.
13:35:16 <humasect> ddarius: without the $ is faster? o_o?
13:35:41 <ddarius> tail (xs ++ [head xs]) is a not (tail xs) ++ [head xs]
13:35:48 <humasect> hm maybe that is what was meant originally, i haven't seen this code in a while: (tail xs) ++ ..
13:35:53 <subconscious> hehe nobody is interesting in formal languages.. I don't blame them
13:35:53 <humasect> yeah
13:35:59 <humasect> cool thanks for spotting this, ddarius =)
13:36:20 <ddarius> It's unlikely to make an even remotely noticeable difference.
13:36:20 <humasect> > let xs = [1..10] in xs `zip` (tail xs ++ [head xs])
13:36:22 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,1)]
13:36:44 <ddarius> It's only the difference between copying the first element of xs and then dropping it or not.
13:36:45 <humasect> the fun is used often enough , better not to have seeds laying around all over eating up precious juice
13:36:46 <BMeph> Saizan: How are they different? :)
13:37:33 <ddarius> humasect: If you are doing that a lot, another data structure would probably be more appropriate.
13:37:38 <BMeph> Saizan: NM, I caught the type you did. :|
13:38:37 <humasect> ddarius: i dont think i am good enough to be able to apply that as skillfully as required. the datatype is plain list, often less than 10 elems
13:38:55 <humasect> it has a 'circular' or 'winding' kind of nature
13:39:10 <BMeph> ddarius: Why not just tail xs ++ xs? :)
13:39:27 <Saizan> BMeph: yeah, it was meant for sclv
13:39:37 <subconscious> I prefer to have
13:39:40 <humasect> (xs `zip` (tail xs ++ [head xs])) == spiral2 == asEdges
13:39:46 <ddarius> BMeph: Because that is a totally different function  (?)
13:39:47 <subconscious> foldr (:) [head xs]
13:40:07 <subconscious> > let xs = "foobar" in foldr (:) [head xs] xs
13:40:09 <lambdabot>   "foobarf"
13:40:11 <ddarius> In that particular context, it doesn't make a difference.
13:40:31 <b\6> http://hpaste.org/10588  <- please scrap my boilerplate
13:40:37 <subconscious> @let cycle' xs = foldr (:) [head xs] (tail xs)
13:40:37 <humasect> subconscious: ah, but skipping head
13:40:37 <lambdabot>  Defined.
13:40:44 <subconscious> > iterate cycle' "foobar"
13:40:45 <lambdabot>   ["foobar","oobarf","obarfo","barfoo","arfoob","rfooba","foobar","oobarf","o...
13:40:50 <BMeph> ddarius: Well, yes, but for the purposes of the zip, won't that be faster still, than the tail xs ++ [head xs]?
13:40:51 <humasect> ok
13:41:13 <subconscious> humasect: what?
13:41:31 <subconscious> > let xs = "foobar" in let this = foldr (:) this xs in this
13:41:32 <lambdabot>   "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfo...
13:41:35 <humasect> BMeph: length xs == length (transpose xs)
13:41:36 <subconscious> you mean like that?
13:42:08 <ddarius> map (take $ length "foobar") $ tails "foobar"
13:42:11 <humasect> subconscious: you had it in cycle' =) (not foobarf, but oobarf. =)
13:42:22 <ddarius> > map (take $ length "foobar") $ tails "foobar"
13:42:23 <lambdabot>   ["foobar","oobar","obar","bar","ar","r",""]
13:42:32 <ddarius> > map (take $ length "foobar") $ tails $ cycle "foobar"
13:42:33 <lambdabot>   ["foobar","oobarf","obarfo","barfoo","arfoob","rfooba","foobar","oobarf","o...
13:42:38 <BMeph> humasect: Uh, if xs is a "square" list, sure. :)
13:42:41 <b\6> "foobarf", nice.
13:42:42 <ddarius> BMeph: Possibly.
13:42:58 <humasect> BMeph: sorry, not Data.List.transpose.
13:43:04 <b\6> sometimes after too much haskell i want to foobarf. :(
13:43:11 <subconscious> @yarber
13:43:11 <lambdabot> It's time to pour on the midnight oil.
13:43:14 <subconscious> @yarber
13:43:14 <lambdabot> There's more than one way to lick a cat.
13:43:18 <subconscious> @yarber
13:43:18 <lambdabot> You gotta strike while the shoe is hot or the iron may be on the other foot.
13:43:38 <b\6> legal operator? :O~~ ?
13:43:46 <ddarius> No
13:44:12 <BMeph> subconscious: Awesome! :)
13:44:27 <humasect> @src cycle
13:44:27 <lambdabot> cycle [] = undefined
13:44:27 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:44:37 <ddarius> cycle = fix . (++)
13:44:44 <humasect> @src fix
13:44:45 <lambdabot> fix f = let x = f x in x
13:44:46 <SamB_XP> @brain
13:44:46 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
13:44:52 <humasect> ehe]
13:45:03 <SamB_XP> @brain
13:45:03 <lambdabot> I think so, Brain, but I didn't know 90210 was a real zip code! Will Tori be there?
13:45:17 <SamB_XP> @brain
13:45:17 <lambdabot> I think so, Brain, but pants with horizontal stripes make me look chubby.
13:45:38 <subconscious> @yarbor
13:45:38 <lambdabot> Maybe you meant: farber yarr
13:45:42 <subconscious> @yarber
13:45:42 <lambdabot> They were made up to the gills.
13:46:16 <SamB_XP> @harber
13:46:16 <lambdabot> We've got a cash cow that's turning into a dog that needs milking.
13:46:37 <humasect> > cycle' "foobar"
13:46:38 <lambdabot>   "oobarf"
13:46:45 <BMeph> humasect: Is your transpose == map (:[]) ? :)
13:46:55 <SamB_XP> I see lambadbot doesn't like OO ;-P
13:47:00 <humasect> i wonder ~
13:47:19 <subconscious> I like the foldr because it traverses the list once
13:47:24 <humasect> transpose ns = tail ns ++ [head ns]     <- is still what it is yet.
13:47:28 <humasect> yeah
13:47:35 <subconscious> > tail "foo"
13:47:36 <lambdabot>   "oo"
13:47:42 <subconscious> oh so does the ++ way
13:47:57 <subconscious> no significant gain then
13:48:00 <humasect> it is all i could do at the time of writing it
13:49:06 <humasect> > 5 `seq` 6
13:49:07 <lambdabot>   6
13:49:22 <subconscious> > 6`const`5
13:49:23 <lambdabot>   6
13:49:41 <humasect> > cycle []
13:49:42 <lambdabot>   mueval: Prelude.read: no parse
13:49:42 <lambdabot>  mueval: *** Exception: Prelude.cycle: empty...
13:49:50 <subconscious> > repeat []
13:49:51 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
13:49:54 <subconscious> > concat (repeat [])
13:50:09 <lambdabot>   thread killed
13:51:00 <BMeph> humasect: Ah, okay. I'd call it rotatel, but that's just me... ;)
13:51:22 <b\6> might call it rotel in honor of the canned tomatoes people use for salsa and quesadillas.
13:52:28 <BMeph> b\6: O really? Or is it so that the inverse function would be called 'roter'? ;)
13:52:47 <b\6> it'd be called greenBellPepper.
13:52:49 <b\6> shrug.
13:53:13 * BMeph thinks he'll call the inverse "delMonte"... ;p
13:53:22 <b\6> http://hpaste.org/10588  <- officer down, all units please respond
13:53:43 <b\6> maybe jollyGreenGiantAsparagus.
13:54:17 <BMeph> b\6: s/Asparagus/snowpeas/ ;p
13:54:43 <BMeph> err, /Snowpeas/, rather. :)\
13:54:44 <b\6> maybe jifExtraChunkyPeanutButter.
13:55:19 <dibblego> b\6, I think it is time to look at the Maybe monad
13:55:20 <b\6> this is a good idea because we could start putting nutrition information on every package in hackage.
13:55:47 <dibblego> b\6, have you seen Scala's Option.flatMap method?
13:55:53 <Botje> "this package contains 45% of your daily recommended IO"
13:56:10 <b\6> dibblego: think i remember it.
13:56:42 <dibblego> b\6, your code is not exactly of this form (since it is lifted into IO), but it basically takes the form of: case Nothing => Nothing; case Some(x) => f(x) // for some f
13:56:59 <dibblego> b\6, What Scala calls flatMap, Haskell calls >>=
13:57:17 <dibblego> s/Nothing/None ^^
13:57:59 <roconnor> what else does Scala have that Haskell calls >>= ?
13:58:16 <dibblego> they are all flatMap on different classes
13:58:16 <Botje> b\6: you could do Just dev <- OpenAL.openDevice Nothing
13:58:16 <Olathe> concat.map
13:58:19 <sclv> b6 maybe this: http://hpaste.org/10588#a1
13:58:22 <Botje> and `catch` pattern match errors
13:58:40 <Olathe> @src List >>=
13:58:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:58:43 <SamB_XP> roconnor: perhaps ;?
13:58:45 <Olathe> @src [] >>=
13:58:45 <lambdabot> Source not found. I feel much better now.
13:58:53 <dibblego> @src [] (>>=)
13:58:53 <lambdabot> xs >>= f     = concatMap f xs
13:58:54 <sclv> you'd actually want a MaybeT but that's not in the mtl for no good reason, and errorT is nicer anyway.
13:59:18 <Twey> @src List (>>=)
13:59:19 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:59:30 <Twey> I don't like that [] is Special
13:59:32 <Olathe> @src (>>=) List
13:59:32 <lambdabot> Source not found. You type like i drive.
13:59:45 <Twey> I think it should be sugar over a normal List monad
13:59:54 <subconscious> it is
14:00:04 <sclv> you could improve it a bit with maybeToError s = maybe (throwError s) return . liftIO
14:00:09 <Twey> It isn't, is it?
14:00:20 <Twey> > return 3 :: List Int
14:00:21 <lambdabot>   mueval: Prelude.read: no parse
14:00:27 <dibblego> [] is only special syntactically
14:00:29 <Twey> No, it isn't
14:00:31 <Twey> Yes
14:00:39 <Twey> That's special enough :)
14:01:19 <roconnor> > return 0 :: [] Int
14:01:21 <lambdabot>   [0]
14:01:27 <sclv> oh and then you could turn it into a one-liner with liftM2 SoundResource!
14:01:28 <Twey> Ooh
14:01:34 <Twey> I didn't know that was possible
14:01:39 <Twey> That's a little better
14:01:47 <roconnor> I don't know if that is haskell 98
14:01:57 <roconnor> I hope it is
14:02:01 <Twey> Aye
14:02:09 <humasect> BMeph: i may call it that now. =)
14:02:13 <b\6> sclv: dunno, thinking maybe it's worse than you think because dev is needed by the second function.
14:02:21 * humasect didn't know of Data.List.transpose then
14:02:29 <sclv> b\6 right but this takes care of that.
14:02:39 <sclv> the maybe and error monads "short circuit"
14:03:13 <sclv> i.e. if you call throwError than nothing following is evaluated, you just return Left "errorstr" immediately.
14:03:15 <b\6> yeah, i remember their >>= definitions pretty much. i just don't see how it helps.
14:03:16 <humasect> > mzero :: [] Int
14:03:17 <lambdabot>   []
14:03:42 <b\6> sclv: thanks for annotation. trying.
14:04:16 <Twey> What's the GHC switch to force '98?
14:04:48 <sclv> -fbe-painful-and-useless
14:04:51 <Twey> Hahaha
14:05:10 <humasect> b\6: i have openal streamer in dirty io haskell if you would like to use it
14:05:29 <humasect> (ported from c examples, works very well)
14:05:47 <roconnor> sclv: oleg would disagree
14:05:52 <b\6> humasect: yeah, i'd like to see it.
14:06:05 <roconnor> sclv: and then kick you in the monads
14:06:14 <sclv> just because you can do printf/scanf in it doesn't mean that its enjoyable :-)
14:06:35 <roconnor> (I just made that last bit up)
14:06:45 <roconnor> :)
14:06:57 <humasect> ok, b\6 - http://hpaste.org/10589
14:06:59 <subconscious> lol
14:07:03 <b\6> humasect: thank you.
14:07:07 <humasect> you're welcome
14:07:28 <humasect> how to use it: newStream and keep calling processStream in whichever manner.
14:07:56 <b\6> ok. studying.
14:08:17 <humasect> _render is where it is filling the buffer; do whatever you like here. ogg stream, sine waves, etc
14:10:52 <subconscious> Does anyone know where I could find info about that sort of thing?
14:11:01 <subconscious> I am really stuck with it
14:11:15 <humasect> 'that' ?
14:11:22 <visof> hi
14:11:27 <humasect> hello
14:11:48 <visof> is there anyone learning Haskell from Graham Hutton book?
14:11:56 <b\6> visof: i read it.
14:12:01 <visof> i can't understand cracking the casear cipher
14:12:10 <b\6> what's weird?
14:12:32 <ndmitchell> @seen malcolmw
14:12:32 <lambdabot> I saw malcolmw leaving #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 23d 4h 29m 28s ago, and .
14:12:34 <Olathe> Cracking a Caesar cipher is weird. Who uses that anymore ?
14:12:45 <b\6> cryptoquote in newspapers.
14:12:51 <b\6> it's just a learning example.
14:12:57 <visof> yeah
14:13:02 <Olathe> Ahh.
14:13:08 <Olathe> I was just kidding ;)
14:13:25 <visof> i want to understand chi-square do?
14:13:41 <visof> what chi-square*
14:13:45 <b\6> oh, dunno. hit wikipedia.
14:14:23 <pfo> may i use a utf-8 ``lambda'' sign isntead of \ with ghc(i) ?
14:14:55 <humasect> pfo: there is support in some editors to change the display of it to lambda, like emacs
14:15:28 <b\6> i was wondering about ghc utf8 stuff too. for coding backward E and whatnot.
14:15:40 <b\6> just in case this stuff ever seems not obscure enough already.
14:15:50 <ddarius> Olathe: We should have cracking RSA be an exercise.
14:16:02 <Beelsebob> pfo: unfortunately no
14:16:14 <Beelsebob> the powers that be decided that the lambda sign was more use as a letter like any other
14:16:23 <Beelsebob> I have no idea what possessed them to decide that
14:16:26 <humasect> the best solution still seems to be changing for display with emacs customization, ghc i do not think yet supports utf-8 source symbols. but this is kind of a good thing. because we don't have to find out how to input the characters, it is smart replace.
14:16:38 <Beelsebob> humasect: yes, it does
14:16:58 <Beelsebob> but the lambda character is just a letter
14:17:00 <Beelsebob> nothing more
14:17:03 <humasect> for lambda etc ? ah.
14:17:29 <visof> > sum[(n+1)^2 | n <- [0..100]]
14:17:30 <Beelsebob> it will accept things like the :: and -> characters as replacements for their various symbols though
14:17:30 <lambdabot>   348551
14:17:31 <subconscious> humasect: You can use UTF-8 in haskell source code for GHC
14:17:49 <humasect> hmm
14:18:10 <pfo> subconscious: for variable names and such?
14:18:17 <Beelsebob> pfo: for anything
14:18:23 <pfo> nice
14:18:28 <visof> is this correct for " calculates the sum1^2 + 2^2 + . . . 100^2 of the first one hundred integer squares."
14:18:30 <visof> ?
14:18:43 <humasect> pfo: http://img502.imageshack.us/my.php?image=picture2kh1.png  is just using lambda and fun compose
14:18:46 <subconscious> visof: No
14:19:15 <visof> ohh
14:19:20 <visof> > sum[(n+1)^2 | n <- [0..99]]
14:19:22 <lambdabot>   338350
14:19:27 <subconscious>   sum[(n+1)^2 | n <- [0..99]]
14:19:28 <visof> now ?
14:19:30 <Beelsebob> but it doesn't accept λx → x as being what you think it should :(
14:19:38 <subconscious> = sum[n^2 | n <- [0+1..99+1]]
14:20:19 <humasect> Beelsebob: how odd ~ still only java lets me use japanese for symbol names.
14:21:14 <pfo> humasect: was that a emacs screenie?
14:21:21 <pfo> *an
14:21:24 <humasect> yep pfo
14:22:00 <pfo> does haskell-mode produce such stuff?
14:22:12 <humasect> yep it does
14:22:16 <humasect> with a little help
14:22:23 <pfo> any pointers?
14:22:29 <humasect> yep, getting them now
14:22:38 <pfo> thanks
14:23:12 <humasect> here is what i started with : http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Unicodifying_symbols_.28Pretty_Lambda_for_Haskell-mode.29
14:23:14 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
14:23:36 <visof> >let replicate 0 x = []; replicate n x = [x] ++ replicate (n-1) x in replicate 3 True
14:23:41 <humasect> though most of them are not actually as productive/cool as the original ascii so most of them got disabled
14:23:41 <Olathe> > (3, 5)
14:23:42 <lambdabot>   (3,5)
14:23:47 <Olathe> Wrong, lambdabot, it's 1 !
14:23:51 <visof> > let replicate 0 x = []; replicate n x = [x] ++ replicate (n-1) x in replicate 3 True
14:23:52 <lambdabot>   [True,True,True]
14:23:57 <humasect> ehe..
14:25:32 <visof> > let replicate 0 x = []; replicate n x = [x] ++ replicate (n-1) x in replicate 3 True
14:25:33 <lambdabot>   [True,True,True]
14:26:48 <roconnor> subconscious: have you read "the view from the left" ?
14:26:56 <subconscious> roconnor: yes
14:27:06 <subconscious> I got sunburn when I read it
14:27:10 <roconnor> good.
14:27:12 <roconnor> :)
14:27:50 <roconnor> I was going to tell you to read it otherwise.
14:27:58 <roconnor> I forget which version was the better one.
14:28:04 <subconscious> it is really wonderful
14:28:22 <subconscious> today I was (re)reading some of the papers about strictly positive families
14:28:27 <roconnor> I think it was the unpublished one that was better for programming ideas
14:28:29 <subconscious> they are kind of mind blowing
14:28:38 <roconnor> and the published one that was better for implemenation ideas
14:28:52 <subconscious> mm I don't know which I read
14:28:53 <roconnor> subconscious: which papers?
14:29:26 <subconscious> lots of awesome stuff from http://www.cs.nott.ac.uk/%7Etxa/publ/ -- but specifically the ones by Peter Morris wrt representing Epigram syntax in Epigram
14:29:27 <roconnor> both versions are good.  I think one was about how/why to program in epigram, and the other how to implement epigram.
14:29:30 <lambdabot> Title: Thorsten Altenkirch's drafts and publications
14:30:50 <roconnor> subconscious: thanks
14:31:11 <visof> > let pyths n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], (x^2 + y^2) == z^2] in pyths 10
14:31:12 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:31:20 <visof> is there another way to this ?
14:31:24 <subconscious> the thing that I found really elegant is the bit from .. something mattam linked recently, on dependent pattern matching
14:31:30 <ushdf> really
14:31:37 <humasect> > [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:31:38 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
14:31:48 <subconscious> they choice of eliminator which gets the unification problem to just drop out
14:31:50 <ushdf> > foldl (+) 1 [1..10000]
14:31:51 <lambdabot>   50005001
14:31:57 <ushdf> > foldl (+) 0 [1..10000]
14:31:58 <lambdabot>   50005000
14:32:00 <subconscious> so I want to try implementing it :)
14:32:09 <humasect> > foldr (+) 0 [1..10000]
14:32:10 <lambdabot>   50005000
14:32:10 <roconnor> I'd like to combine epigram with darcs, and have the nodes operations be patches.
14:32:34 <ushdf> :t foldr
14:32:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:32:38 <ushdf> :t foldl
14:32:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:32:56 <subconscious> :t foldM
14:32:57 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:33:03 <ushdf> oh god
14:33:19 <roconnor> @src forM
14:33:19 <lambdabot> forM = flip mapM
14:33:25 <ushdf> > foldl (*) 0 [1..10000]
14:33:26 <lambdabot>   0
14:33:33 <ushdf> uh
14:33:34 <subconscious> I want Epigram 2 :|
14:33:39 <ushdf> > foldl (*) 1 [1..10000]
14:33:41 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
14:33:43 <ushdf> there you go
14:33:46 <subconscious> because I can't make head nor tail of OTT
14:33:56 <roconnor> > product [1.10000]
14:33:57 <lambdabot>   1.1
14:34:03 <roconnor> *L*
14:34:05 <humasect> > foldM mappend [] [1,2,3,4]
14:34:06 <ushdf> > product [1..10000]
14:34:06 <lambdabot>       Occurs check: cannot construct the infinite type: a = m a
14:34:06 <lambdabot>        Expect...
14:34:07 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
14:34:16 <humasect> oops
14:34:18 <ushdf> somebody show me a simple example of foldM?
14:34:31 <humasect> i have one here somewhere ..
14:34:34 <roconnor> subconscious: I only understand OTT because of the talks I've gone to.
14:34:36 <ushdf> monads scare me
14:34:46 <ushdf> like locusts...
14:34:53 <subconscious> (p:>ps ≡ q:>qs) σ = do "Cyclic" `should` (p /= q) ; foldM unify σ (zip (σ↗ ps) (σ↗ qs))
14:34:53 <BONUS> monads hiding under the bed
14:34:54 <subconscious> (Var x ≡ t) σ = do "Occurs check" `should` (x `occur` (σ⤴ t)) ; return $ (x --> t) σ
14:34:56 <subconscious> ushdf: ^
14:35:09 <ushdf> that's simple>
14:35:25 * ushdf has no idea what that expression does
14:35:29 <Olathe> > foldb
14:35:30 <lambdabot>   mueval: Prelude.read: no parse
14:35:33 <humasect> > foldM return [] (map return [1,2,3,4])
14:35:34 <Olathe> No parse ?!
14:35:34 <lambdabot>   Add a type signature
14:35:35 <humasect> oops
14:35:37 <subconscious> ushdf: first order unification
14:35:50 <humasect> it is simpler when you can think: i can use foldM where there is IO Int instead of fold when there is Int ..
14:36:07 <humasect> > $B&R(B?
14:36:09 <lambdabot>   mueval: Prelude.read: no parse
14:36:18 <Olathe> > foldb
14:36:19 <lambdabot>       Overlapping instances for Show ((a -> a -> a) -> a -> [a] -> a)
14:36:19 <lambdabot>        ...
14:36:53 <ushdf> i took top level math through high school and into early college, and i still find myself looking this stuff up - thus, public education fails miserably
14:36:55 <Olathe> > foldb (*) [a, b, c, d, e, f, g, h, i, j]
14:36:57 <lambdabot>       Overlapping instances for Show ([[Expr]] -> [Expr])
14:36:57 <lambdabot>        arising from...
14:37:00 <Olathe> > foldb (*) 0 [a, b, c, d, e, f, g, h, i, j]
14:37:01 <lambdabot>   0 * (a * b * (c * d) * (e * f * (g * h)) * (i * j))
14:37:05 <sclv> > let replicate 0 _ = [] ; replicate (n + 1) x = x : replicate n x in replicate 5 True
14:37:07 <lambdabot>   [True,True,True,True,True]
14:37:21 <subconscious> Olathe: that's interesting, what's the purpose?
14:37:31 <Olathe> Some things are faster when done that way.
14:37:36 <Olathe> Especially numeric stuff.
14:37:40 <subconscious> cool
14:37:48 <dmwit> This isn't really a Haskell question, but I'm looking to learn about the Barendregt lambda cube; anybody know off the top of their head what the paper is called?
14:37:50 <ushdf> normally looking at the code of an algorithm helps me get it in a minute
14:37:54 <ushdf> but i don't know the language or the algorithm here ;)
14:37:55 <Olathe> It's usually faster to work with two numbers of the same size, so foldr and foldl go slowly.
14:38:01 <humasect> >@type foldb
14:38:05 <humasect> tsk~_~
14:38:08 <Olathe> @type foldb
14:38:10 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
14:38:11 <Olathe> @type foldr
14:38:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:38:17 <Olathe> @type foldl
14:38:17 <subconscious> dmwit: what do you want to know about it?
14:38:18 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:38:22 <humasect> ah
14:38:29 <dmwit> subconscious: What it is, I guess?  I don't know.
14:38:31 <ushdf> do b, l, r and m actually stand for something
14:38:39 <subconscious> dmwit: they touch it breifly in TAPL and cover it thoroughly in Lectures on the Curry Howard Isomorphism
14:38:40 <ushdf> m is obviously monad, l r left right?
14:38:42 <Olathe> left, right, and binary, I guess.
14:38:45 <ushdf> loophole righteousness
14:39:08 <Olathe> foldb does each pair in the list to produce a new list half the original size.
14:39:14 <Olathe> Then it repeats until it's done.
14:39:30 <ushdf> > foldb [0,1...]
14:39:31 <lambdabot>   mueval: Prelude.read: no parse
14:39:41 <ushdf> > foldb [1,4,9...]
14:39:42 <lambdabot>   mueval: Prelude.read: no parse
14:39:43 <Olathe> > foldb (*) 1 [1..1000000]
14:39:52 <lambdabot>   826393168833124006237664610317266629113534797896387304516777588556337961103...
14:39:52 <ushdf> > foldb (*) 1 [1,4,9...]
14:39:54 <lambdabot>   mueval: Prelude.read: no parse
14:39:57 <humasect> > foldr (*) 1 [1..1000000]
14:39:58 <lambdabot>   mueval: Prelude.read: no parse
14:39:59 <lambdabot>  mueval: *** Exception: stack overflow
14:40:03 <ushdf> > foldb (*) 1 [1,4,9]...
14:40:04 <lambdabot>   mueval: Prelude.read: no parse
14:40:07 <ushdf> sigh
14:40:21 <humasect> > [1,4..9]
14:40:21 <ushdf> > foldb (*) 1 [1..100]
14:40:24 <Olathe> > scanl1 (*) ([1,4]...)
14:40:24 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
14:40:24 <lambdabot>  Terminated
14:40:25 <lambdabot>   [1,4,28,280,3640,58240,1106560,24344320,608608000,17041024000,528271744000,...
14:40:34 <Olathe> > scanl1 (*) ([1,4,9]...)
14:40:35 <lambdabot>   [1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,15...
14:40:48 <ushdf> aha
14:40:56 <Olathe> > sumPow 2
14:40:58 <lambdabot>   \x -> (2*x^3 + 3*x^2 + x) `div` 6
14:40:58 <dmwit> subconscious: Thanks, I'll look for the lecture notes.
14:41:09 <ushdf> > scanl1 (*) ([1,2,3]...)
14:41:11 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
14:41:21 <ushdf> i like that list
14:41:33 <Olathe> Yes, it's a nice list.
14:41:46 <ushdf> :D
14:41:50 <ushdf> ;O
14:42:25 <ushdf> > scanl1 (*) (map (* 2) 1 [1..100])
14:42:26 <lambdabot>   Couldn't match expected type `[t] -> [a]'
14:42:32 <ushdf> > scanl1 (*) (map (^ 2) 1 [1..100])
14:42:33 <lambdabot>   Couldn't match expected type `[t] -> [a]'
14:42:58 <Olathe> > map (^2) 1 [1..100]
14:42:59 <ushdf> > scanl1 (*) (map (** 2) 1 [1..100])
14:43:00 <lambdabot>   Couldn't match expected type `[t1] -> t'
14:43:00 <lambdabot>   Couldn't match expected type `[t] -> [a]'
14:43:02 <Olathe> > map (^2) [1..100]
14:43:03 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
14:43:08 <visof> > let factors num = [ x | x <- [1..num-1) , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 500
14:43:08 <ushdf> > scanl1 (*) (map (^2) 1 [1..100])
14:43:10 <lambdabot>   mueval: Prelude.read: no parse
14:43:10 <lambdabot>   Couldn't match expected type `[t] -> [a]'
14:43:11 <Olathe> map doesn't use a starting value.
14:43:16 <ushdf> > scanl1 (*) (map (^2) [1..100])
14:43:17 <lambdabot>   [1,4,36,576,14400,518400,25401600,1625702400,131681894400,13168189440000,15...
14:43:47 <olsner> openmp is pretty impressive when it comes to ease of parallelisation actually
14:43:57 <Olathe> What's openmp ?
14:44:08 <ushdf> > scanl1 (*) (foldl (**) 1 [1..100])
14:44:10 <lambdabot>       No instance for (Floating [a])
14:44:10 <lambdabot>        arising from a use of `**' at <in...
14:44:13 <Olathe> Ahh.
14:44:15 <ushdf> > scanl1 (*) (foldl (^) 1 [1..100])
14:44:16 <lambdabot>       No instance for (Num [a])
14:44:16 <lambdabot>        arising from a use of `^' at <interact...
14:44:23 <Olathe> @type foldl
14:44:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:44:30 <Olathe> Produces a value from a list.
14:44:39 <Olathe> But scanl1 needs a list, rather than a value.
14:44:42 <ushdf> > scanl1 (*) (map (^5) [1..100])
14:44:43 <lambdabot>   [1,32,7776,7962624,24883200000,193491763200000,3252016064102400000,10656206...
14:44:44 <Olathe> @type scanl1
14:44:45 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
14:44:54 <dmwit> subconscious: Oh man, the LotCHI are even longer than the Lambda Calculi with Types book by Barendregt himself that I found at first. =P
14:44:56 <dmwit> 273 pages!
14:45:08 <ushdf> this language is nuts
14:45:15 <olsner> Olathe: an extension of C that allows, for example, any for-loop (probably restricted to known patterns, but most for-loops look the same anyway) to be auto-parallelized by adding a #pragma omp parallel on the line above it
14:45:19 <Olathe> ushdf: Yes, it's quite nice :)
14:45:20 <ushdf> but i want to be a knight of the lambda calculus
14:45:23 <ushdf> so i can get all the bitches
14:45:26 <Olathe> Heheh
14:45:37 <Olathe> olsner: Ahh, that's excellent.
14:45:40 <olsner> so, for simple problems you just include a header, add a compiler option, add two or three pragmas, and it's parallel
14:46:23 * dmwit notes that parMap does something equivalent for Haskell
14:46:24 * cads would love to meet even one 'bitch' that knows what the lamba calculus is
14:46:44 <b\6> there are tons of girls who could school you to death in math.
14:46:53 <b\6> but yeah, they're hard to find.
14:46:53 <ushdf> i've met em
14:47:01 <ushdf> even one or two attractive ones
14:47:02 <ushdf> ;)
14:47:23 <visof_> > let factors num = [ x | x <- [1..num-1) , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 500
14:47:24 <lambdabot>   mueval: Prelude.read: no parse
14:47:32 <Olathe> Yeah, it's probably much more likely in the ho population.
14:47:34 <ushdf> tell me, what is your philosophy of government
14:47:36 <ushdf> what DO you believe in
14:47:37 <olsner> dmwit: yes, but only if the individual list items are good units of parallelisation
14:48:26 <olsner> threads seem to be very cheap in haskell otoh, so that's probably true in haskell more often than in C
14:48:52 <ushdf> threads or parallel tasks
14:48:55 <ushdf> DEBATE!!!
14:49:16 <b\6> i edit my threads in vim and anyone who edits them in emacs is an idiot.
14:49:57 <Olathe> When I was growing up, we had to edit our threads in gdb.
14:49:59 <visof_> > let factors num = [ x | x <- [1..num-1] , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 500
14:50:00 <lambdabot>   [6,28,496]
14:50:01 <Olathe> And we liked it !
14:50:11 <visof_> > let factors num = [ x | x <- [1..num-1] , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 100000
14:50:26 <lambdabot>   thread killed
14:50:38 <visof_> this solution is very slow in case of larger number, is there any idea?
14:50:42 <visof_> > let factors num = [ x | x <- [1..num-1] , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 10000
14:50:45 <DroneZilla>  @let ints = 2 : map succ ints
14:50:54 <DroneZilla> > take 10 ints
14:50:56 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
14:50:58 <lambdabot>   thread killed
14:51:22 <dmwit> visof_: if cond then True else False === cond
14:51:25 <ushdf> what???
14:51:30 <subconscious> :t cond
14:51:32 <lambdabot> Not in scope: `cond'
14:51:39 <olsner> and if the original map was just a range (e.g. map doLine [1..height]), afaik a parMap will have to actually evaluate a list for the iteration, while openmp with its smarts about iterations will split the range into n subranges instead and let each thread iterate
14:51:41 <subconscious> oh I see
14:51:45 <DroneZilla> @let prime_ (p : ps) = p : (prime_ (filter (\n -> n `mod` p /= 0) ps))
14:51:47 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
14:51:59 <DroneZilla> @type prime_
14:52:00 <lambdabot> forall a. (Integral a) => [a] -> [a]
14:52:06 <subconscious> @undef
14:52:08 <Olathe> > let factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor _ 1 = []; factor' p n = if (mod n p==0) then p:factor p (div n p) else factor (p + 2) n in factor [10000]
14:52:10 <lambdabot>   Couldn't match expected type `[t]'
14:52:11 <Olathe> > let factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor _ 1 = []; factor' p n = if (mod n p==0) then p:factor p (div n p) else factor (p + 2) n in factor 10000
14:52:13 <DroneZilla> @let primes = prime_ ints
14:52:13 <lambdabot>   Couldn't match expected type `[t]'
14:52:14 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
14:52:23 <DroneZilla> @type primes
14:52:24 <lambdabot> Not in scope: `primes'
14:52:24 <sclv> olsner: isn't being more like openmp part of what the dph stuff is about?
14:52:30 <Olathe> > let factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor' _ 1 = []; factor' p n = if (mod n p==0) then p:factor p (div n p) else factor (p + 2) n in factor 10000
14:52:30 <DroneZilla> @type ints
14:52:31 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> [a]'
14:52:32 <lambdabot> Not in scope: `ints'
14:52:33 <Olathe> > let factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor' _ 1 = []; factor' p n = if (mod n p==0) then p:factor p (div n p) else factor' (p + 2) n in factor 10000
14:52:34 <lambdabot>   Couldn't match expected type `[t]' against inferred type `a -> [a]'
14:52:40 <Olathe> Damn you, Haskell !
14:52:43 <DroneZilla> @let ints = 2 : map succ ints
14:52:44 <lambdabot>  Defined.
14:52:45 <Olathe> > let factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor' _ 1 = []; factor' p n = if (mod n p==0) then p:factor' p (div n p) else factor' (p + 2) n in factor 10000
14:52:47 <lambdabot>   [2,2,2,2,5,5,5,5]
14:52:49 <Olathe> Yay !
14:52:55 <DroneZilla> @type (ints * primes)
14:52:55 <Olathe> There's a faster factorer.
14:52:56 <lambdabot> Not in scope: `primes'
14:52:57 <olsner> sclv: yeah, probably
14:53:14 <DroneZilla> @let primes = prime_ ints
14:53:15 <subconscious> no lunabot :(
14:53:15 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
14:53:20 <DroneZilla> @type primes
14:53:22 <lambdabot> Not in scope: `primes'
14:53:33 <DroneZilla> @type ints
14:53:34 <lambdabot> forall a. (Num a, Enum a) => [a]
14:53:40 <DroneZilla> @type (prime_ )
14:53:41 <lambdabot> Not in scope: `prime_'
14:53:45 <Olathe> > let perfect x = if (sum $ factor x) == x then True else False; perfects range = [x | x <- [1..range], perfect x]; factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor' _ 1 = []; factor' p n = if (mod n p==0) then p:factor' p (div n p) else factor' (p + 2) n in perfects 500
14:53:46 <lambdabot>   [2,3,4,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
14:53:53 <Olathe> > let perfect x = if (sum $ factor x) == x then True else False; perfects range = [x | x <- [1..range], perfect x]; factor n = if n.&.1==0 then 2:factor (shiftR n 1) else factor' 3 n where factor' _ 1 = []; factor' p n = if (mod n p==0) then p:factor' p (div n p) else factor' (p + 2) n in perfects 10000
14:53:55 <lambdabot>   [2,3,4,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,1...
14:54:17 <DroneZilla> @let prime_ (p : ps) = p : (prime_ (filter (\n -> n `mod` p /= 0) ps))
14:54:18 <lambdabot>  Defined.
14:54:25 <DroneZilla> @type (int, prime_)
14:54:26 <lambdabot> forall a. (Integral a) => (Int -> Doc, [a] -> [a])
14:54:28 <intoverflow> Olathe: does this method have a name?
14:54:37 <DroneZilla> @let primes = prime_ ints
14:54:38 <lambdabot>  Defined.
14:54:45 <DroneZilla> @type primes
14:54:46 <lambdabot> forall a. (Integral a) => [a]
14:54:56 <Olathe> intoverflow: Trial division.
14:55:03 <DroneZilla> take 10 (primes :: [Integer])
14:55:20 <DroneZilla> > take 10 (primes :: [Integer])
14:55:21 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
14:55:31 <Olathe> Hmm, I think by factors, you meant divisors.
14:55:40 <Olathe> Let's see.
14:56:01 <DroneZilla> @src primes
14:56:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:56:50 <Olathe> > let factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in factors 10000
14:56:51 <lambdabot>   [2,2,2,2,5,5,5,5]
14:56:54 <Olathe> So far, so good.
14:58:15 <Olathe> > let factorization = map(\x->(length x,head x)).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in factorization 10000
14:58:16 <lambdabot>   [(4,2),(4,5)]
14:58:20 <DroneZilla> let fact = let fact_ n (p : ps) = if n = 1 then [] else if n `mod` p == 0 then p : fact_ (n `quot` p) (p : ps) else fact_ n ps in (\n -> fact n primes)
14:58:31 <DroneZilla> @let fact = let fact_ n (p : ps) = if n = 1 then [] else if n `mod` p == 0 then p : fact_ (n `quot` p) (p : ps) else fact_ n ps in (\n -> fact n primes)
14:58:31 <lambdabot>   Parse error
14:58:37 <Olathe> @pl \x->(head x,length x)
14:58:38 <lambdabot> liftM2 (,) head length
14:58:48 <DroneZilla> @let fact = let fact_ n (p : ps) = if n == 1 then [] else if n `mod` p == 0 then p : fact_ (n `quot` p) (p : ps) else fact_ n ps in (\n -> fact n primes)
14:58:49 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
14:58:53 <Olathe> > let factorization = map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in factorization 10000
14:58:54 <lambdabot>   [(2,4),(5,4)]
14:59:15 <encryptio> @src liftM2
14:59:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:59:26 <DroneZilla> @let fact = let fact_ n (p : ps) = if n == 1 then [] else if n `mod` p == 0 then p : fact_ (n `quot` p) (p : ps) else fact_ n ps in (\n -> fact_ n primes)
14:59:27 <lambdabot>  Defined.
14:59:32 <DroneZilla> fatc 10000
14:59:36 <DroneZilla> > fact 10000
14:59:37 <lambdabot>   [2,2,2,2,5,5,5,5]
14:59:42 <DroneZilla> > fact 12345
14:59:43 <lambdabot>   [3,5,823]
15:00:26 <DroneZilla> sorry I was trying lambdabot, I'll never spam again
15:00:34 <dmwit> 'sok
15:00:38 <dmwit> We like it. =)
15:01:00 <dmwit> If you ever feel like you're imposing on the channel, though, you can also play with \bot in a /msg.
15:01:09 <subconscious> DroneZilla: more code!
15:01:19 <DroneZilla> i'm not used with IRC
15:01:24 <Olathe> > let divisors=d'.factorization; d'[]=[1]; d'(n,pow):xs=map (n^) [0..pow]; factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in factorization 10000
15:01:25 <lambdabot>   mueval: Prelude.read: no parse
15:02:13 <DroneZilla> subconscious: what kind of code do you wanna see ?
15:03:31 <Olathe> > let divisors=d'.factorization; d' []=[1]; d'((n,pow):xs)=liftM2(*)(map(n^)[0..pow])(d' xs); factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in divisors 10000
15:03:33 <lambdabot>   [1,5,25,125,625,2,10,50,250,1250,4,20,100,500,2500,8,40,200,1000,5000,16,80...
15:03:35 <Olathe> There we are.
15:03:57 <Olathe> > let perfect n = (sum.divisors) n == n divisors=d'.factorization; d' []=[1]; d'((n,pow):xs)=liftM2(*)(map(n^)[0..pow])(d' xs); factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in perfect 28
15:03:58 <lambdabot>   mueval: Prelude.read: no parse
15:04:03 <Olathe> > let perfect n = (sum.divisors) n == n; divisors=d'.factorization; d' []=[1]; d'((n,pow):xs)=liftM2(*)(map(n^)[0..pow])(d' xs); factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in perfect 28
15:04:04 <lambdabot>   False
15:04:37 <Olathe> > let perfect n = (sum.divisors) n == n+n; divisors=d'.factorization; d' []=[1]; d'((n,pow):xs)=liftM2(*)(map(n^)[0..pow])(d' xs); factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in perfect 28
15:04:39 <lambdabot>   True
15:04:40 <Olathe> There.
15:04:51 <visof_> @let product (x,y) = x*y
15:04:52 <lambdabot>  Defined.
15:04:54 <Olathe> > let perfect n = (sum.divisors) n == n+n; divisors=d'.factorization; d' []=[1]; d'((n,pow):xs)=liftM2(*)(map(n^)[0..pow])(d' xs); factorization=map(liftM2(,)head length).group.factors; factors n=if n.&.1==0 then 2:factors(shiftR n 1)else f' 3 n where f' _ 1=[];f' p n=if (mod n p==0) then p:f' p(div n p) else f'(p+2)n in filter perfect [1..10000]
15:05:04 <lambdabot>   [6,28,496,8128]
15:05:18 <Olathe> Quick enough for lambdabot.
15:05:52 <visof_> > let scalar xs ys = sum [product (x,y) | (x,y) <- zip xs ys] in scalar [1,2,3] [4,5,6]
15:05:53 <lambdabot>       Ambiguous occurrence `product'
15:05:53 <lambdabot>      It could refer to either `L.product...
15:06:03 <Olathe> You killed product !
15:06:05 <Olathe> ;)
15:06:17 <Olathe> visof: zipWith (*)
15:06:33 <Olathe> > zipWith (*) [1, 2, 3] [4, 5, 6]
15:06:34 <lambdabot>   [4,10,18]
15:06:42 <Olathe> > zipWith (*) [a, b, c] [d, e, f]
15:06:43 <lambdabot>   [a * d,b * e,c * f]
15:06:52 <visof_> ok
15:07:41 <Olathe> > let dotP = sum.zipWith(*) in dotP [1, 2, 3] [4, 5, 6]
15:07:42 <lambdabot>   Couldn't match expected type `[a]'
15:07:47 <Olathe> :(
15:08:01 <Olathe> @type let dotP = sum.zipWith(*) in dotP
15:08:02 <lambdabot>     Couldn't match expected type `[a]'
15:08:02 <lambdabot>            against inferred type `[a1] -> [a1]'
15:08:02 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
15:08:17 <cads> penis
15:08:24 <Olathe> cads: You said it !
15:08:30 <Olathe> @type let dotP = zipWith (*) in dotP
15:08:31 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
15:08:37 <cads> err, sorry guys
15:08:37 <Olathe> @type let dotP = sum . zipWith (*) in dotP
15:08:38 <lambdabot>     Couldn't match expected type `[a]'
15:08:39 <lambdabot>            against inferred type `[a1] -> [a1]'
15:08:39 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
15:08:43 <Olathe> @type sum
15:08:45 <lambdabot> forall a. (Num a) => [a] -> a
15:08:57 <Saizan> ?type (sum .) . zipWith (*)
15:08:58 <lambdabot> forall a. (Num a) => [a] -> [a] -> a
15:09:11 <Olathe> Why does it need that ?
15:09:17 <humasect> @type sum.zipWith (*)
15:09:18 <lambdabot>     Couldn't match expected type `[a]'
15:09:18 <lambdabot>            against inferred type `[a1] -> [a1]'
15:09:18 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
15:09:29 <Saizan> Olathe: because zipWith (*) takes 2 arguments
15:09:46 <Olathe> @pl (\xs ys -> sum (zipWith (*) xs ys))
15:09:47 <lambdabot> (sum .) . zipWith (*)
15:09:49 <Olathe> Ahh :(
15:10:10 <Olathe> @type let dotP xs ys = sum $ zipWith (*) xs ys in dotP [1, 2, 3] [4, 5, 6]
15:10:12 <lambdabot> forall t. (Num t) => t
15:10:16 <Olathe> > let dotP xs ys = sum $ zipWith (*) xs ys in dotP [1, 2, 3] [4, 5, 6]
15:10:17 <lambdabot>   32
15:10:20 <Olathe> Yay !
15:10:40 <humasect> @src product
15:10:41 <lambdabot> product = foldl (*) 1
15:11:56 <DroneZilla> @let possibleProduct [] = [1]
15:11:58 <lambdabot>  Defined.
15:12:20 <DroneZilla> @let possibleProduct (p : ps) = do n <- possibleProduct ps; [n, p * n]
15:12:21 <lambdabot>  Defined.
15:12:25 <Olathe> > possibleProduct ([]::[()])
15:12:26 <lambdabot>       No instance for (Num ())
15:12:26 <lambdabot>        arising from a use of `possibleProduct'...
15:12:37 <Olathe> Wait.
15:12:43 <Olathe> You can do multi-line things like that ?
15:12:47 <DroneZilla> @let getDivisors n = possibleProduct (fact n)
15:12:48 <lambdabot>  Defined.
15:12:54 <Olathe> @let omg [] = 1
15:12:55 <DroneZilla> > getDivisors 10
15:12:56 <lambdabot>  Defined.
15:12:56 <lambdabot>   [1,2,5,10]
15:13:07 <DroneZilla> > getDivisors 60
15:13:08 <lambdabot>   [1,2,2,4,3,6,6,12,5,10,10,20,15,30,30,60]
15:13:13 <Olathe> @let omg (x:xs) = x*(omg xs)
15:13:14 <lambdabot>  Defined.
15:13:18 <Olathe> > omg [1..3]
15:13:20 <lambdabot>   6
15:13:22 <Olathe> omg !
15:13:31 <DroneZilla> f**k
15:13:44 <Olathe> @let omgbbq [] = 1
15:13:44 <Saizan> ahuahuahu
15:13:45 <lambdabot>  Defined.
15:13:53 <Olathe> @let omgbbqscrewerupper = 5
15:13:54 <lambdabot>  Defined.
15:13:57 <Saizan> yeah, it just append lines to a file.
15:14:03 <Saizan> *appends
15:14:07 <Olathe> @let omgbbq (x:xs) = x+(omg xs)
15:14:08 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:14:10 <Olathe> Ahh.
15:14:21 <Olathe> So, you have to be quick before the rest of the channel screws you up.
15:14:42 <Saizan> the rest of the channel*s*
15:14:48 <Olathe> Oh, yes :)
15:16:38 <DroneZilla> Olathe: what's your goal ?
15:17:11 <Olathe> In what ?
15:17:24 <Olathe> In doing multiline things ?
15:17:29 <DroneZilla> you're searching divisors of a number, what for ?
15:17:46 <Olathe> Oh, someone had a really slow filter perfect [1..n] thing.
15:17:49 <sclv> to crack pgp, duh.
15:17:51 <Olathe> I made a quicker one.
15:17:57 <Olathe> If they wanted it.
15:18:28 <Olathe> (16:50.42) (visof_) > let factors num = [ x | x <- [1..num-1] , num `mod` x == 0]; perfect x = if (sum $ factors x) == x then True else False; perfects range = [x | x <- [1..range], perfect x] in perfects 10000
15:18:30 <DroneZilla> hum...
15:18:32 <Olathe> That was the original one.
15:18:43 <DroneZilla> okay
15:19:56 <lelf> ?undef product
15:20:06 <Olathe> I think that undefs everything.
15:20:09 <Olathe> > foldb
15:20:10 <lambdabot>   mueval: Prelude.read: no parse
15:20:17 <Olathe> Yeah.
15:21:13 <lelf> > product []
15:21:15 <lambdabot>   1
15:21:24 <Olathe> > omg
15:21:25 <lambdabot>   mueval: Prelude.read: no parse
15:21:31 <Olathe> > foldb
15:21:32 <lambdabot>       Overlapping instances for Show ((a -> a -> a) -> a -> [a] -> a)
15:21:32 <lambdabot>        ...
15:24:30 <nolraiWest> Any one know the name of that replacement for the mtl?
15:24:39 <TSC> monadlib?
15:24:40 <_ar> is there a way to make a list of heterogenous element types all implementing the same class? it's the class interface i care about
15:24:40 <subconscious> there is monad lib
15:24:53 <subconscious> _ar, yes you can do that
15:25:40 <subconscious> _ar, but you may be able to avoid it, by using lambda in some cases
15:26:08 <_ar> subconscious: i declare class Entity e has position :: e -> Position, but when i try to declare [Entity] it tells me that it expected kind * but got kind k->*
15:26:25 <subconscious> _ar, why don't you use [Position] though?
15:26:45 <_ar> subconscious: there are other maps i want under that class too
15:26:47 <subconscious> _ar, You can map position over the elements, but it's not computed unless needed since haskell is lazy
15:26:59 <humasect> is it ever lazy.
15:27:06 <subconscious> _ar, You could encode is as a GADT, like Message ty -> ty
15:27:14 <subconscious> so GetPosition :: Message Position, etc
15:27:30 <subconscious> if not, you must use some forall thing
15:28:21 <_ar> so maybe i need to rethink this from square one
15:28:21 <bos> _ar: all the elements of a list must have the same type, so you cannot create a heterogeneous list without a trick.
15:28:47 <subconscious> _ar, it's possible to do this, there is even an example on the wiki under existential types
15:28:48 <bos> in particular, everything implementing the same typeclass does not mean that they are the same type.
15:28:59 <subconscious> _ar, I just don't really like this method.. so I suggest those alternatives :)
15:29:00 <Saizan> _ar: data AnyEntity = forall e. Entity e => AnyEntity e, then you can have a [AnyEntity] and get the positions out of it
15:29:33 <Saizan> _ar: this is with existential types
15:29:46 <_ar> bos: yes i'm in the special case where i'm only interested in the results of the evaluation of the class supplied functions on the elements and not the elements themselves
15:29:58 <sclv> well you need also instance Entity e => AnyEntity e where foo (AnyEntity x) = foo x, etc.
15:30:13 <subconscious> _ar, You can definitely encode this using the GADT like I suggested
15:30:22 <Saizan> ?google haskell wikibook existential types
15:30:28 <bos> using a GADT would be best.
15:30:31 <sclv> but if you only have say two functions in the class, then just have a list of the results of both functions.
15:30:35 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
15:30:45 <nolraiWest> The one im looking for had a ChoiceT.
15:30:59 <nolraiWest> Any one know what it was called?
15:31:04 <_ar> subconscious: i will certainly be looking into that... i'm trying to parse the overwhelming number of wonderful responses i'm getting
15:31:08 <subconscious> nolraiWest: never heard of ChoiceT, what does it do?
15:31:10 <sclv> nolraiWest: if that's not monadlib, then maybe that's logic?
15:31:11 <halberd> I was thinking--how about a user interface based around 2-d physics?  we have graphical metaphors for "dragging" objects but what if it was more physically realistic, with gravity, collisions, drag, etc?
15:31:15 <Saizan> sclv: instance Entity AnyEntity where ..., btw
15:31:44 <nolraiWest> subconscious: its a better version of ListT, ListT breaks the monad rules.
15:31:49 <sclv> Saizan: yeah, I was pretty sloppy there.
15:31:54 <subconscious> yes it does sound like LogicT
15:31:54 <halberd> you could have literally a "bin" that you could physically drop things into, representing a directory
15:31:55 <humasect> halberd: sure, there are enough flash-ui web sites to have an idea of what it would 'feel' like
15:32:18 <halberd> humasect do you know of a flash website with this theme?
15:32:31 <nolraiWest> where is LogicT?
15:32:39 <subconscious> You can use google to find it
15:32:45 <humasect> not offhand but i have come across several, even ones with simulated physics (ie. animated to death)
15:32:47 <sclv> there was a hack for oldschool Mac (circa system 7) that gave your desktop realistic physics.
15:33:00 <subconscious> search for "LogicT"
15:33:07 <nolraiWest> thanks!
15:33:11 <halberd> physics simulation isn't animation in the drawing sense
15:33:12 <subconscious> It is also on Hackage
15:33:25 <subconscious> so I think you can cabal install it, but I haven't tried that
15:33:26 <halberd> interesting sclv
15:33:33 <sclv> it was pretty cute.
15:33:43 <humasect> right. that was cleared up earlier by regarding how it would feel to use.
15:34:13 <humasect> but then again, there is no physics without animation of some kind of temporal application
15:37:50 <banbh> in http://www.haskell.org/pipermail/haskell-cafe/2008-September/047738.html oleg mentions "a `pure' function with observable side effects".  which function is he talking about?  what are its side effects?
15:38:02 <lambdabot> Title: [Haskell-cafe] Lazy vs correct IO [Was: A round of golf], http://tinyurl.com/3gyv9l
15:38:14 <humasect> @type Left
15:38:15 <lambdabot> forall a b. a -> Either a b
15:39:34 <Olathe> Watch this.
15:39:35 <Olathe> @let y a b = a*(2*a-b)
15:39:36 <lambdabot>   Parse error
15:39:38 <Olathe> @let y a b = a*(2*a - b)
15:39:41 <lambdabot>  Defined.
15:39:43 <Saizan> banbh: "file"
15:39:44 <Olathe> Yay, parse errors !
15:39:52 <Olathe> @help bug
15:39:52 <lambdabot> bug. Submit a bug to GHC's trac
15:40:03 <humasect> @let y a b = a -b
15:40:04 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:40:18 <Olathe> It has to be after *
15:40:21 <Olathe> I think.
15:40:25 <humasect> ah, hmm
15:40:28 <Olathe> @let omg a b = 2*a-b
15:40:28 <lambdabot>   Parse error in expression: HsPostOp (HsLit (HsInt 2)) (HsQVarOp (UnQual (Hs...
15:40:34 <Olathe> @let omg a b = 2*a - b
15:40:36 <lambdabot>  Defined.
15:40:43 <Olathe> @let omg1 a b = 2*a- b
15:40:46 <lambdabot>  Defined.
15:40:51 <Olathe> @let omg2 a b = 2*a -b
15:40:53 <lambdabot>  Defined.
15:41:01 <humasect> ah, interesting ..
15:41:04 <Olathe> How do you report a lambdabot bug ?
15:41:06 <ziman> banbh, i guess it's reading from a file
15:41:27 <BMeph> nolraiWest: http://www.haskell.org/haskellwiki/MonadLib
15:41:28 <lambdabot> Title: MonadLib - HaskellWiki
15:41:47 <banbh> Saizan: file is a lazy String, right? so the observable side effect is whether you have finished reading (in which case it becomes semi closed).
15:42:01 <Olathe> @bug @let y a b = c*a-b -- minus without spacing after times screws up.
15:42:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:42:27 <humasect> @let y a b = c * a-b
15:42:27 <lambdabot>   Parse error in expression: HsPostOp (HsVar (UnQual (HsIdent "c"))) (HsQVarO...
15:43:52 <tsar> why are not Data.Map, Data.List and Data.Maybe in the langugae, why do i ahve to import them? i use them in basically every program so why do i have to litter it with import-statements?
15:44:24 <banbh> in other words, reading from a file is fine.  the problem is creating String with dangling connections to the real world.  is that his point?
15:44:29 <newsham> "in the language"?  you mean in the Prelude?
15:44:32 <tsar> because of overlapping function-names?
15:44:44 <newsham> you can write a library that loads them all up and import that library if you dont like importing them all the time
15:44:51 <tsar> newsham: yes or you mean ghci?
15:45:25 <newsham> import AllMyToys
15:46:51 <newsham> banbh: there's a different behavior if you're running a program which reads all of the data at the start, does some work, and then processes the data, and another that lazily rads the file, does some work, and then processes the data, if the file changes while th eprogram is running
15:47:20 <newsham> that difference in behavior affects pure code.  so the code isnt really as "pure" as it seems.
15:47:27 <Saizan> also, you lose track of resources (like a file descriptor here), and it can cause problems
15:47:41 <newsham> also you can get an IO exception in the middle of pure code.
15:47:45 <elad`> I check for even-ness before dividing by two, but the interpretter can't know that, and cries that the function I wrote violates type safety by doing what might be fractional division. What should I do? How do I cast, or whatever, to fix this?
15:47:47 <newsham> since the IO exception is deferred
15:48:27 <newsham> or if you want to think about it more theoretically.  you're not just getting a single snapshot of RealWorld when you do the IO.
15:48:36 <idnar> elad`: use div instead of (/)
15:48:42 <idnar> @type div
15:48:43 <newsham> since your IO is lazy, the outcome of the IO changes as the RealWorld changes
15:48:43 <lambdabot> forall a. (Integral a) => a -> a -> a
15:48:45 <idnar> @type (/)
15:48:46 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:49:02 <ddarius> > 10 `shiftR` 1
15:49:03 <lambdabot>   Add a type signature
15:49:07 <ddarius> > 10 `shiftR` 1 :: Integer
15:49:08 <lambdabot>   5
15:49:11 <Olathe> @type (%)
15:49:13 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:49:19 <elad`> Thanks
15:49:27 <newsham> elad: the compiler doesnt care that its even or odd.  it cares that (/) matches a different type
15:49:38 <elad`> suppow :: Integer -> Integer -> Integer
15:49:38 <elad`> suppow _ 0 = 1
15:49:38 <elad`> suppow a b = if odd b then 2 * (suppow a (b-1)) else square (suppow a (b div 2))
15:49:45 <elad`> I still get a complaint.
15:49:50 <newsham> b `div` 2    or   div b 2
15:50:06 <elad`> oh, right
15:50:07 <elad`> Thanks.
15:50:30 * ushdf yawns loudly
15:50:35 <elad`> oops, silly me - a*
15:50:45 <ushdf> somebody explain these :t things to me
15:50:54 <banbh> thanks. that helps (a lot)
15:51:31 <ushdf> they scare me
15:51:36 <ushdf> :t sum
15:51:38 <lambdabot> forall a. (Num a) => [a] -> a
15:52:10 <newsham> sum takes a list of things that are Num's and returns the same kind of thing that is a Num
15:52:15 <dfrey> Is there a prelude function that takes a value and returns a list containing only that value?    eg.   f 126 -> [126]
15:52:19 <newsham> for example  [Int] -> Int
15:52:21 <newsham> (Int is a Num)
15:52:37 <humasect> > return 4 :: [Int]
15:52:38 <lambdabot>   [4]
15:52:51 <newsham> > (:[]) 126  -- or cons monster
15:52:53 <lambdabot>   [126]
15:53:00 <humasect> hehe
15:53:16 <ushdf> i still don't understand what forall a. (Num a( => [a] -> a means
15:53:19 <humasect> :t (:[])
15:53:20 <lambdabot> forall a. a -> [a]
15:53:27 <ushdf> switch one of those parentheses
15:53:41 <dfrey> thanks
15:53:50 <newsham> ushd: for any kind of "a" such that "a" is a "Num", [a] -> a
15:53:57 <newsham> ie. since Int is a Num,   [Int] -> Int
15:54:11 <ushdf> ah
15:54:13 <newsham> since Float is also a Num, [Float] -> Float
15:54:15 <ushdf> :t pred
15:54:16 <humasect> > sum ["13","34","324"]
15:54:16 <lambdabot> forall a. (Enum a) => a -> a
15:54:17 <lambdabot>       No instance for (Num [Char])
15:54:17 <lambdabot>        arising from a use of `sum' at <int...
15:54:37 <ushdf> > foldl (+) 1 [13,34,324]
15:54:38 <lambdabot>   372
15:54:57 <humasect> :t foldl (+) 1
15:54:58 <lambdabot> forall a. (Num a) => [a] -> a
15:54:59 <newsham> note, not   [Int] -> Float    even though Int and Float are Num's
15:55:06 <newsham> [a] -> a   says it has to be the same Num.
15:55:09 <ushdf> i realize that
15:55:21 <ushdf> i get the low-level stuff, the haskell parts are what throw me off ;)
15:55:41 <newsham> isnt it all haskell stuff?
15:55:44 <newsham> since we're talking about ahskell?
15:56:10 <ushdf> yes
15:56:13 <ushdf> parts of it are more...unique
15:56:30 <newsham> uniqueness is more a Clean thing ;-)
15:56:37 <humasect> it gets easier the more your brain is filled with it.
15:56:42 <humasect> so just (:[]) eat
15:56:45 <ushdf> like pirate shanties
15:57:06 <ushdf> > sum [1,4,9...]
15:57:08 <lambdabot>   mueval: Prelude.read: no parse
15:57:12 <ushdf> > sum [1,4,9]...
15:57:13 <lambdabot>   mueval: Prelude.read: no parse
15:57:16 <ushdf> > sum ([1,4,9]...)
15:57:24 <humasect> :t (...)
15:57:34 <humasect> > sum [1,3..100]
15:57:37 <ushdf> i think i broke it
15:57:50 <ushdf> > sum [1..2]
15:57:52 <lambdabot>   mueval: Prelude.read: no parse
15:57:52 <lambdabot> thread killed
15:57:56 <ushdf> > sum [1..2]
15:58:01 <lambdabot>   2500
15:58:01 <lambdabot>  Terminated
15:58:01 <lambdabot>   3
15:58:05 * ushdf pushes lambdabot
15:58:41 <humasect> :t (zip.unzip.zip.unzip)
15:58:42 <lambdabot>     Couldn't match expected type `[a]'
15:58:42 <lambdabot>            against inferred type `([a1], [b])'
15:58:42 <lambdabot>       Expected type: [(a1, b)] -> [a]
15:58:45 <newsham> > product [1..50000] :: Integer
15:58:57 <lambdabot>   334732050959714483691547609407148647791277322381045480773010032199016802214...
15:59:35 <humasect> > readFile "/dev/null"
15:59:37 <lambdabot>   mueval: Prelude.read: no parse
15:59:37 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
16:00:13 <humasect> i have never seen ([1,2,4]...) syntax before
16:01:18 <guenni>  /msg mmorrow welcome back
16:01:20 <newsham> its not builtin haskell syntax.  its defined, ie: http://codepad.org/WDXeV59b
16:01:36 <humasect> hm that is what i thought
16:01:40 <humasect> :t (...)
16:01:42 <lambdabot> forall a. (Num a) => [a] -> [a]
16:01:46 <humasect> ah now it works ^_^
16:02:06 <humasect> > (...) [1,2,3]
16:02:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:02:24 <humasect> ok
16:02:29 <newsham> > ([1,2,3,4,5.01] ...)
16:02:30 <lambdabot>   [1.0,2.0,3.0,4.0,5.01,6.049999999999999,7.149999999999997,8.349999999999993...
16:02:52 <ushdf> > ([1,3,7,9] ...)
16:02:53 <humasect> silly..
16:02:53 <lambdabot>   [1,3,7,9,5,-9,-37,-83,-151,-245,-369,-527,-723,-961,-1245,-1579,-1967,-2413...
16:02:58 <ushdf> ...
16:03:10 <ushdf> oh wow
16:03:19 <ushdf> > ([1,3,5,9] ...)
16:03:20 <lambdabot>   [1,3,5,9,17,31,53,85,129,187,261,353,465,599,757,941,1153,1395,1669,1977,23...
16:03:29 <newsham> > unwords $ map (\x -> printf "%.1f" x) ([1,2,3,4,5.01] ...)
16:03:31 <lambdabot>   "1.0 2.0 3.0 4.0 5.0 6.0 7.1 8.3 9.7 11.3 13.1 15.3 17.9 21.1 25.0 29.6 35....
16:03:36 <ushdf> that is precisely what makes haskell such a great candidate for writing AI
16:03:48 <humasect> it is ?
16:03:55 <ushdf> in my opinion, yes
16:04:36 * roconnor thinks haskell is a poor candidate for writing AI.
16:04:49 <newsham> haskell can do difference engine, therefore great for AI
16:04:55 <humasect> > unwords $ map toRational ([1,2,3,4,5.01] ...)
16:04:56 <lambdabot>   Couldn't match expected type `String'
16:05:04 <humasect> > map toRational ([1,2,3,4,5.01] ...)
16:05:04 <humasect> duh
16:05:05 <lambdabot>   [1%1,2%1,3%1,4%1,2820379266640773%562949953421312,3405847218198937%56294995...
16:05:05 <ushdf> why do you think that
16:05:26 <humasect> difference engine sounds good for ai.
16:05:36 * humasect has wrote and is writing ai
16:05:38 <roconnor> type systems are about proving properties.  Intellegence is about making mistakes
16:05:45 <ushdf> no
16:05:52 <ushdf> intelligence is about making abstractions out of all available data
16:06:01 <ushdf> and using those abstractions to formulate good ideas for future actions
16:06:02 <roconnor> I sould say intellegence involves making mistakes
16:06:10 <ushdf> it necessitates mistakes
16:06:10 <roconnor> or requies making mistakes
16:06:11 <vininim> you can't generalize on AI
16:06:11 <humasect> yep roconnor , but maybe that just means more randoms.
16:06:14 <ushdf> it doesn't require them
16:06:18 <dobblego> like intellegence
16:06:29 <humasect> intelligence without mistakes is like a computer without a user.
16:06:32 <ushdf> it causes them, that is, but it's not the intelligence's fault, only the lack of availability of data
16:06:49 <roconnor> I don't study AI, so my opinions is worth close to 0. :)
16:07:02 <ushdf> i do study AI, so my opinion is also worth close to 0
16:07:06 <Olathe> > showFunc [1,3,7,9]
16:07:07 <lambdabot>   mueval: Prelude.read: no parse
16:07:12 <Olathe> No parse ?!
16:07:28 <ushdf> > showFunc [1..100]
16:07:29 <lambdabot>   mueval: Prelude.read: no parse
16:07:33 <Olathe> > sayFunc [1,3,7,9]
16:07:34 <lambdabot>   map (\x -> ((-2)*x^3 + 9*x^2 + (-1)*x + 3) `div` 3) [0..3]
16:07:39 <ushdf> that is beautiful
16:07:43 <ushdf> > sayFunc [1..100]
16:07:51 <lambdabot>   mueval: Prelude.read: no parse
16:07:51 <lambdabot>  mueval: map (\x -> *** Exception: Ratio.%: ...
16:07:52 <Olathe> > sayFunc [1..100]
16:07:59 <Olathe> It uses Ints, I think.
16:07:59 <lambdabot>   mueval: Prelude.read: no parse
16:07:59 <lambdabot>  mueval: map (\x -> *** Exception: Ratio.%: ...
16:08:02 <Olathe> I'll have to fix that.
16:08:04 <Olathe> > sayFunc [1..10]
16:08:05 <lambdabot>   map (\x -> x + 1) [0..9]
16:08:21 <ushdf> ok wait so if i have a set of vectors
16:08:29 <ushdf> what's the best way to induce a function? the best fit function
16:08:37 <Olathe> Oh, I'm not sure.
16:08:39 <ushdf> slash deduce
16:08:44 <humasect> :t sayFunc
16:08:45 <lambdabot> [Int] -> Expr
16:08:51 <Olathe> I've just learned a bit of polynomial stuff, like Lagrange interpolation.
16:08:58 <DroneZilla_> > sayFunc [2, 3]
16:08:59 <lambdabot>   map (\x -> x + 2) [0..1]
16:09:14 <ushdf> > map (\x -> x+2) [0..1]
16:09:16 <lambdabot>   [2,3]
16:09:17 <DroneZilla_> sayFunc [3, 1, 4]
16:09:18 <humasect> > sayFunc [1,3,-5,-100,2,0.00001]
16:09:19 <lambdabot>       No instance for (Fractional Int)
16:09:19 <lambdabot>        arising from the literal `1.0e-...
16:09:27 <Olathe> > sayFunc [2,4]
16:09:29 <lambdabot>   map (\x -> 2*x + 2) [0..1]
16:09:31 <humasect> > sayFunc [1,3,-5,-100,2,0,-103]
16:09:32 <lambdabot>   map (\x -> (1835*x^6 + (-33201)*x^5 + 223565*x^4 + (-685755)*x^3 + 929840*x...
16:09:38 <ushdf> <3
16:09:40 <humasect> =o
16:09:46 <newsham> ushd: look it up online :)
16:09:58 <newsham> ?oeis 1,3,5,7
16:09:59 <lambdabot>  The odd numbers: a(n) = 2n+1.
16:09:59 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
16:10:01 <ushdf> am i right to call that deduction?
16:10:22 <dmwit> > sayFunc [104, 101, 108, 108, 111]
16:10:24 <lambdabot>   map (\x -> (27*x^4 + (-230)*x^3 + 621*x^2 + (-490)*x + 2496) `div` 24) [0..4]
16:10:28 <roconnor> > oesis [1,3,5]
16:10:29 <lambdabot>   mueval: Prelude.read: no parse
16:10:32 <Olathe> Heh.
16:10:33 <humasect> hot.
16:10:35 <Olathe> No strings.
16:10:46 <Olathe> > sayFunc $ map ord "Hello"
16:10:47 <lambdabot>   map (\x -> ((-5)*x^4 + 90*x^3 + (-499)*x^2 + 1110*x + 1728) `div` 24) [0..4]
16:11:00 <Olathe> > map chr $ map (\x -> ((-5)*x^4 + 90*x^3 + (-499)*x^2 + 1110*x + 1728) `div` 24) [0..4]
16:11:02 <lambdabot>   "Hello"
16:11:04 <dmwit> > map (chr . \x -> (27*x^4 + (-230)*x^3 + 621*x^2 + (-490)*x + 2496) `div` 24) [0..4]
16:11:06 <lambdabot>   "hello"
16:11:08 <humasect> ehh=)
16:11:48 <humasect> > show $ 27*x^4 + (-230)*x^3 + 621*x^2 + (-490)*x + 2496) `div` 24
16:11:49 <lambdabot>   mueval: Prelude.read: no parse
16:12:04 <dmwit> needs more parens
16:12:12 <dmwit> > show $ (27*x^4 + (-230)*x^3 + 621*x^2 + (-490)*x + 2496) `div` 24
16:12:13 <lambdabot>   "(27 * (x * x * (x * x)) + negate 230 * (x * x * x) + 621 * (x * x) + negat...
16:12:27 <humasect> =O. it actually..
16:12:30 <dmwit> You could even just drop the show.
16:12:35 <dmwit> > (27*x^4 + (-230)*x^3 + 621*x^2 + (-490)*x + 2496) `div` 24
16:12:36 <lambdabot>   (27 * (x * x * (x * x)) + negate 230 * (x * x * x) + 621 * (x * x) + negate...
16:12:58 <Olathe> > gcd x y
16:13:01 <ushdf> rewire the lambdabot dominatrix machine!!!!!!
16:13:02 <humasect> but if it can be show/read, it can be put in files etc.
16:13:04 <dmwit> Terminated!
16:13:04 <ushdf> all hands on deck!!
16:13:10 <elad`> suppow :: Integer -> Integer -> Integer
16:13:10 <elad`> suppow _ 0 = 1
16:13:10 <elad`> suppow a b = if odd b then a * (suppow a (b-1)) else square (suppow a (b `div` 2))
16:13:11 <ushdf> > lambdabot dominatrix machine
16:13:13 <lambdabot>   mueval: Prelude.read: no parse
16:13:13 <lambdabot>   thread killed
16:13:15 <ushdf> yeah, just deny everything!!!
16:13:17 <dmwit> humasect: It's a very limited instance of show.
16:13:29 <elad`> Given that, how long is suppow :: Integer -> Integer -> Integer
16:13:29 <elad`> suppow _ 0 = 1
16:13:29 <elad`> suppow a b = if odd b then a * (suppow a (b-1)) else square (suppow a (b `div` 2))
16:13:31 <elad`> sorry
16:13:32 <elad`> oops
16:13:35 <humasect> what instance is it dmwit ?
16:13:44 <dmwit> humasect: It's an instance for Expr.
16:13:46 <dmwit> See here:
16:13:47 <humasect> i didn't know of 'negate' appearing in shows
16:13:48 <humasect> ahhh!
16:13:49 <dmwit> ?where simple-reflect
16:13:49 <lambdabot> I know nothing about simple-reflect.
16:13:52 <elad`> Given the above suppow, how long is suppow 2 7830457 likely to take?
16:13:57 <dmwit> ?where twanvl
16:13:57 <lambdabot> I know nothing about twanvl.
16:14:00 <dmwit> bah
16:14:02 <dmwit> ?where expr
16:14:02 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
16:14:05 <dmwit> There!
16:14:23 <humasect> very interesting.i may have a use for this.
16:14:55 <humasect> i mean in this project. does it mean lambdabot is finding Expr on its leasure?
16:14:56 <dmwit> elad`: Looks like a reimplementation of (^).
16:15:01 <dmwit> elad`: Why not just use (^)?
16:15:06 <dmwit> > 2^7830457
16:15:11 <lambdabot>   273373863906283135573072488577320330081685564297380787917616071605499449545...
16:15:18 <dmwit> elad`: And to answer your question: not very long! =)
16:15:23 <Olathe> > shiftR 1 7830457
16:15:25 <lambdabot>   Add a type signature
16:15:30 <Olathe> No, YOU add one !
16:15:44 <dmwit> humasect: f, g, x, y, z are just constants.
16:15:47 <dmwit> :t x
16:15:49 <lambdabot> Expr
16:15:51 <elad`> dmwit: I've been waiting for more than 15 minutes now.
16:15:53 <humasect> :t fadg
16:15:55 <lambdabot> Not in scope: `fadg'
16:15:55 <Olathe> > shiftR 1 7830457 :: Integer
16:15:58 <lambdabot>   0
16:16:05 <Olathe> > shiftL 1 7830457 :: Integer
16:16:05 <dmwit> > fun "asdf" :: Expr
16:16:06 <elad`> As for ^ - does it use the same trick for getting faster results?
16:16:08 <lambdabot>   asdf
16:16:08 <lambdabot>  Terminated
16:16:13 <dmwit> elad`: of course
16:16:13 <Olathe> > shiftL 1 7830457 :: Integer
16:16:19 <lambdabot>   273373863906283135573072488577320330081685564297380787917616071605499449545...
16:16:33 <humasect> elad`: i think 15 minutes means it may not stop
16:16:49 <dmwit> elad`: Probably your "square" implementation is wrong, or you pasted wrong, or...
16:16:55 <elad`> humasect: Isn't that very odd?
16:16:55 <Olathe> > ffib 1000000
16:16:57 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
16:17:14 <ushdf> > 20502059^95020502
16:17:22 <dmwit> elad`: ...or you supplied a negative exponent. =P
16:17:28 <ushdf> > 2050205^5020502
16:17:29 <lambdabot>   thread killed
16:17:33 <elad`> I'm using ^ now, and though I haven't waited as long yet (naturally - it's just been suggested to me), it seems to take quite long too. And that one doesn't use my square, of course.
16:17:33 <ushdf> > 205020^020502
16:17:36 <Olathe> ushdf: Try in ghci.
16:17:36 <lambdabot>   279441367344566516861309230614293560448384704047587276850348887552898161905...
16:17:44 <lambdabot>   thread killed
16:17:44 <Olathe> ushdf: It should be able to give you it.
16:17:47 <DroneZilla> > sayFunc [1; 2; 3; 4]
16:17:49 <lambdabot>   mueval: Prelude.read: no parse
16:17:51 <ushdf> it's more amusing my way
16:18:03 <DroneZilla> sayFunc [1, 2,3, 4Ø
16:18:08 <Olathe> > sayFunc [1, 2, 3, 4]
16:18:08 <humasect> eh
16:18:15 <DroneZilla> thx
16:18:17 <lambdabot>   map (\x -> x + 1) [0..3]
16:18:27 <DroneZilla> > sayFunc [1, 2, 1]
16:18:29 <lambdabot>   map (\x -> (-1)*x^2 + 2*x + 1) [0..2]
16:18:35 <Olathe> @@ @run @run sayFunc [1, 2, 3, 4]
16:18:36 <nolraiWest> how do i change "data M target a = Return a | Done a | List [a] | forall x => Bind (M target x) (x -> M target a)" so it parses?
16:18:39 <lambdabot>   [1,2,3,4]
16:18:48 <dmwit> elad`: If I just paste your function into a file and run it, it executes basically instantly.
16:18:50 <DroneZilla> interpolateur de Lagrange, very nice
16:19:00 <nolraiWest> what's sayFunc?
16:19:10 <Olathe> It does Lagrange interpolation.
16:19:10 <dmwit> elad`: Unless you count printing as part of your runtime, in which case, well... it takes as long as it takes to print.
16:19:16 <dmwit> The computation is done. =)
16:19:58 <dmwit> > 7830457 * logBase 10 2
16:20:00 <lambdabot>   2357202.436756991
16:20:10 <dmwit> Two million digits...
16:20:34 <Olathe> > length.show $ 2^7830457
16:20:43 <lambdabot>   2357203
16:21:01 <dmwit> Olathe: Pretty close, hey? =)
16:21:05 <Olathe> > ceil $ 7830457 * logBase 10 2
16:21:07 <lambdabot>   mueval: Prelude.read: no parse
16:21:11 <Olathe> > ceiling $ 7830457 * logBase 10 2
16:21:13 <lambdabot>   2357203
16:21:16 <Olathe> dmwit: Yes :)
16:22:07 <ddarius> nolraiWest: "forall x."
16:22:11 <DroneZilla> can we have the source of sayFunc ?
16:22:21 <Olathe> Sure.
16:22:29 <DroneZilla> how ?
16:22:44 <ddarius> > let f xs = (xs...) in f [1,2,3,4] x
16:22:46 <lambdabot>   Couldn't match expected type `Expr -> t'
16:23:44 <nolraiWest> thanks!
16:23:49 <Olathe> DroneZilla: http://hpaste.org/10591
16:24:04 <Olathe> That's a better one than lambdabot is using at the moment.
16:24:39 <DroneZilla> Olathe: thx
16:24:47 <Olathe> You're welcome.
16:25:13 <elad`> sumOfDigits :: Integer -> Integer
16:25:13 <elad`> sumOfDigits 0 = 0
16:25:13 <elad`> sumOfDigits x = (x `mod` 10) + (sumOfDigits (x/10))
16:25:16 <elad`> What's wrong here?
16:25:18 <elad`> oh
16:25:18 <elad`> div?
16:25:28 <elad`> n/m
16:25:28 <Botje> yes
16:25:34 <DroneZilla> how hpaste works exactly ?
16:25:48 <humasect> click 'new'
16:26:02 <Botje> another way of writing it is sum . map digitToInt $ show x
16:26:03 <dmwit> > let sumOfDigits = sum . map digitToInt . show in sumOfDigits 12345
16:26:05 <lambdabot>   15
16:26:06 <ushdf> i want to know that too
16:26:11 <ushdf> haskell cgi scares the hell out of me
16:26:25 <dmwit> Botje: beatcha to it =)
16:26:38 <dmwit> DroneZilla, ushdf: I think hpaste is built on HaPPs.
16:26:51 <dmwit> Though hpaste2 is supposedly written in Python instead, the traitor. =P
16:26:58 <ushdf> =-o
16:27:02 <ushdf> happs
16:27:14 <DroneZilla> I swa many sources in hpaste, how we create it.
16:27:18 <ushdf> <3 functional php
16:27:23 <ushdf> "functional"
16:27:32 <dmwit> DroneZilla: As humasect said, just click "New".
16:27:45 <dmwit> ushdf: ...functional php?
16:28:00 <ushdf> functionally structured
16:28:03 <DroneZilla> oh ok, it's just a stupid wiki
16:28:03 <shrughes> I restrict myself to a purely functional subset of php :)
16:28:30 <dmwit> DroneZilla: Pretty much, yep, except you can never go back and edit old pastes.  It's an append-only wiki. =)
16:28:31 <ushdf> if you know what i mean
16:28:48 <dmwit> (It also used to have a companion bot that would announce new pastes in here, but that has since disappeared for some reason.)
16:29:05 <DroneZilla> why hpaste :: (a -> b) -> f a -> f b ?
16:29:09 <dmwit> for fun
16:29:26 <dmwit> :t fmap
16:29:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:30:32 <ushdf> i was doing functional programming before i knew what it was
16:30:40 <ushdf> do you guys think i'm cool yet
16:31:11 * ushdf coughs up a gallon of blood
16:32:23 <olsner> ... we're so used to people's brains exploding, no-one even notices a gallon of blood coughed up
16:32:52 <mmorrow> ushdf: runCGI (output . renderHtml $ thehtml << [header << thetitle (toHtml "42"), body << toHtml "42"])
16:32:58 <Olathe> Haskell is very bloody.
16:33:13 <ushdf> it still does
16:33:20 <Olathe> @src Expr
16:33:20 <lambdabot> Source not found. Do you think like you type?
16:33:27 <Olathe> @indexc Expr
16:33:27 <lambdabot> bzzt
16:33:29 <Olathe> @index Expr
16:33:30 <lambdabot> bzzt
16:33:34 <Olathe> Don't bzzt me !
16:33:35 <ushdf> oO
16:33:45 <Olathe> @hoogle Expr
16:33:45 <lambdabot> module Text.Parsec.Expr
16:33:45 <lambdabot> module Text.ParserCombinators.Parsec.Expr
16:33:45 <lambdabot> Distribution.Simple.Program alexProgram :: Program
16:33:49 <Olathe> @hoogle AExpr
16:33:49 <lambdabot> No results found
16:34:08 <nolraiWest> How would one use a case-expression to unpack a existentially-quantified constructor?
16:34:31 <ushdf> read it "thus spake zarathustra"
16:34:34 <ToRA> case x of (C y) -> f y
16:35:11 <ToRA> where f :: (forall a . (..) => a) -> b
16:36:16 <Olathe> > var
16:36:18 <lambdabot>       Ambiguous occurrence `var'
16:36:18 <lambdabot>      It could refer to either `Data.Number.S...
16:36:24 <Olathe> @hoogle var
16:36:24 <lambdabot> Distribution.PackageDescription Var :: c -> Condition c
16:36:24 <lambdabot> Language.Haskell.TH VarE :: Name -> Exp
16:36:24 <lambdabot> Language.Haskell.TH.Syntax VarE :: Name -> Exp
16:43:44 <olsner> newsham: have you tried using regexp-tdfa for the regex-dna benchmark?
16:44:07 <BMeph> So, is this right?
16:44:34 <BMeph> forall a (M:: * -> *). MonadPlus m => Monoid (m a)
16:44:43 <BMeph> s/M/m/
16:46:05 <olsner> hmm, no, PCRE was a little bit faster actually
16:47:00 <olsner> but both depend on being able to use hackage packages for the regexping I guess
16:47:04 <dmwit> BMeph: I don't think so; Monoid isn't a type constructor.
16:47:09 <dmwit> (...it's a class)
16:50:24 <Olathe> @index multiply
16:50:24 <lambdabot> bzzt
16:50:28 <Olathe> @index add
16:50:29 <lambdabot> bzzt
16:50:33 <BMeph> dmwit: Isn't MonadPlus also a class?
16:50:45 <dmwit> BMeph: ...yes?
16:50:55 <olsner> (but tdfa gets plus points for being pure haskell)
16:51:00 <dmwit> But Monoid is on the right-hand side of your (=>), which isn't really allowed.
16:51:35 <dmwit> Unless this is in an instance header?
16:51:46 <nolraiWest> how do you fit more than one class restriction in to a forall clause?
16:51:54 <BMeph> dmwit: Oh, duh - it'd have to be an instance statement. Got it.
16:53:22 <ToRA> forall x y z . (C x, C' y, C'' z) => x -> y -> z
16:54:37 <nolraiWest> ToRA: thanks
16:54:39 <newsham> olsner: no.  not familiar with it
16:57:07 <olsner> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-tdfa
16:57:13 <lambdabot> Title: HackageDB: regex-tdfa-0.94, http://tinyurl.com/3h9muw
17:02:59 <Olathe> @index intersperse
17:03:00 <lambdabot> Data.List
17:03:09 <jhdjkd> Hi
17:04:15 <ushdf> > blue lights and sunshine
17:04:16 <lambdabot>   mueval: Prelude.read: no parse
17:07:14 <humasect> > 't' :: Int
17:07:15 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
17:08:44 <Twey> > ord 't'
17:08:46 <lambdabot>   116
17:09:14 <humasect> ah ~
17:09:16 <humasect> > ord Bool
17:09:17 <lambdabot>   mueval: Prelude.read: no parse
17:09:18 <humasect> oops
17:09:19 <humasect> >ord TRue
17:09:21 <humasect> ..
17:09:25 <Twey> Nnno
17:09:26 <humasect> i'll stop there
17:09:37 <Twey> ord :: (Integral a) => Char -> a
17:09:40 <Twey> I think
17:09:42 <Twey> :t ord
17:09:43 <lambdabot> Char -> Int
17:09:45 <humasect> ohh, not Ord
17:09:48 <Twey> Oh, bit more limited than that.
17:09:50 <humasect> > fromEnum True
17:09:51 <lambdabot>   1
17:09:54 <Twey> No, ord and Ord are unrelated
17:09:58 <humasect> right, k
17:10:35 <humasect> > chr 116
17:10:37 <lambdabot>   't'
17:11:49 <humasect> > (flip.flip.flip.flip.map) [1,2,3,4] show
17:11:50 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[b1]'
17:14:29 <nolraiWest> @hoogle (a -> bool) -> [a] -> ([a], [a])
17:14:30 <lambdabot> Did you mean: a -> Bool -> [a] -> ([a], [a]) /count=20
17:14:30 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:14:30 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:14:44 <dmwit> > (flip.flip.flip.flip.flip$map) [1,2,3,4] show
17:14:45 <lambdabot>   ["1","2","3","4"]
17:14:53 <humasect> aha, thanks
17:14:54 <dmwit> :t partition
17:14:55 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:15:04 <ushdf> :t zip
17:15:05 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
17:15:09 <dmwit> nolraiWest: ^^
17:15:12 <nolraiWest> dmwit: thanks
17:15:27 <Twey> flip ^ n * 2 === flip
17:15:34 <dmwit> Bugger on Hoogle, though.
17:16:10 <humasect> ^_^
17:16:31 <Twey> (shush, I just invented a mini-language, I can make up operator precedence as I like)
17:16:50 <humasect> =) funcomp is more like an intuition.
17:17:10 * humasect allergic to variable names and parens
17:17:37 <Twey> Heh
17:22:07 <Olathe> Is there a way to do this ? instance ToAExpr (Integral a) where
17:22:33 <sjanssen> instance Integral a => ToAExpr a where
17:22:45 <sjanssen> note this requires overlapping instances, and is potentially a bad idea
17:23:35 <Olathe> Ahh :(
17:24:45 <Olathe> > let f::(Integral a)=>a; f = 5 in f::Int32
17:24:46 <lambdabot>   5
17:24:48 <vlm> > Data.Graph.Inductive.Graph.mkGraph [(1, "abc")] [(0, 1, "def")]
17:24:49 <lambdabot>       No instance for (Show (gr [Char] [Char]))
17:24:49 <lambdabot>        arising from a use of ...
17:24:52 <Olathe> @instances Integral
17:24:53 <lambdabot> Int, Integer
17:24:57 <Olathe> Where's Int32 ?
17:25:19 <olsner> Data.Int iirc
17:25:29 <olsner> ?index Int32
17:25:29 <lambdabot> Data.Int, Foreign
17:25:38 <Olathe> Is there a listing of what types are in each class ?
17:25:47 <olsner> @instances-importing Integral
17:25:48 <lambdabot> Int, Integer
17:26:23 <olsner> hmm, that's missing a bunch of them... so I guess the answer is no
17:26:32 <Olathe> Alright.
17:27:19 <olsner> (but such an index can only include packages and modules it knows about so it would never be complete anyway...)
17:28:28 <visof> how can i convert (x,y) to [x,y] ?
17:28:45 <sjanssen> @pl \(x, y) -> [x, y]
17:28:46 <visof> foo xs = [[x,ys] | (x,ys) <- xs]
17:28:46 <lambdabot> uncurry ((. return) . (:))
17:29:03 <visof> this isn't working for lists ?
17:29:04 <sjanssen> visof: type error
17:29:22 <Saizan> visof: what's the type of (x,y)?
17:29:32 <visof> tuple
17:29:36 <sjanssen> visof: your function has type [(a, a)] -> [[a]]
17:29:43 <visof> (Int,[Int)
17:29:47 <visof> (Int,[Int])
17:29:51 <sjanssen> visof: the function you're asking for has type (a, a) -> [a]
17:29:56 <Olathe> Well, you can't have a list of Int and [Int]
17:30:06 <Saizan> then you want (x,y) to (x:y)
17:30:25 <Olathe> @pl (x, y) -> x:y
17:30:26 <lambdabot> (line 1, column 8):
17:30:26 <lambdabot> unexpected ">" or "-"
17:30:26 <lambdabot> expecting variable, "(", operator or end of input
17:30:29 <Olathe> @pl \(x, y) -> x:y
17:30:29 <lambdabot> uncurry (:)
17:30:39 <Olathe> @src uncurry
17:30:39 <lambdabot> uncurry f p = f (fst p) (snd p)
17:30:44 <Olathe> @src curry
17:30:45 <lambdabot> curry f x y = f (x, y)
17:34:22 <ushdf> > mc
17:34:23 <lambdabot>   mueval: Prelude.read: no parse
17:35:13 <ushdf> ÿ.ÿ
17:36:51 <ushdf> > 9^2
17:36:52 <lambdabot>   81
17:36:53 <ushdf> > 99^2
17:36:55 <lambdabot>   9801
17:36:55 <ushdf> > 999^2
17:36:56 <lambdabot>   998001
17:36:57 <ushdf> > 9999^2
17:36:58 <lambdabot>   99980001
17:37:17 <ushdf> ([81,9801,998001,99980001] ...)
17:37:20 <BMeph> dmwit: Would it have to be: instance (Monad m, Monoid (m a)) => MonadPlus m -- is this legal?
17:37:23 <ushdf> > ([81,9801,998001,99980001] ...)
17:37:25 <lambdabot>   [81,9801,998001,99980001,393971121,979986681,1955042001,3416152401,54603332...
17:37:53 <BMeph> dmwit: Would it have to be: instance (Monad m, Monoid (m a)) => MonadPlus m -- is this legal?
17:38:17 <dmwit> Probably not, since the 'a' is orphaned.
17:40:03 <BMeph> dmwit: So, my original works as an instance stmt, though, right?
17:40:24 <BMeph> instance MonadPlus m => Monoid (m a)
17:40:30 <dmwit> BMeph: Try it. =)
17:40:46 <dmwit> (I think it should, though you might get overlapping instances.)
17:40:50 <BMeph> dmwit: ...I'm afraid. ;)
17:40:53 <sjanssen> BMeph: that isn't a very nice instance
17:41:04 <sjanssen> BMeph: see the Monoid instance for Maybe, for example
17:44:12 * BMeph pulls up Data.Monoid... and starts the hair-pull tango...
17:45:42 <visof> if i have something like this [(1,[2,3,4]), (2,[4,5,6])], how can i get lengths of inner lists that are [2,3,4], [4,5,6] ?
17:46:12 <sjanssen> map (length . snd)
17:46:15 <BMeph> visof: You mean map (length.snd) ? ;)
17:47:03 <BMeph> > map (length.snd)  [(1,[2,3,4]), (2,[4,5,6])]
17:47:05 <lambdabot>   [3,3]
17:47:35 <visof> thanks
17:56:56 <Olathe> (<) (Var _) _ = True
17:57:06 <Olathe> (<) (Product _) _ = True
17:57:25 <Olathe> If those lines are in that order, why is Product [] < Var "x"
17:58:32 <Saizan> (<) (Var _) _ = True matches only when the _first_ argument is Var
17:59:35 <Olathe> Oh.
17:59:38 <Olathe> :(
18:00:17 <Olathe> Is there an easier way to define such an ordering ?
18:00:36 <sjanssen> also, Var x < Var x, which isn't very nice
18:01:15 <Olathe> Oh, I handle that earlier.
18:01:20 <Olathe> I left out a bunch.
18:01:34 <dobblego> see if you can write it without overlapping patterns
18:01:37 <Olathe> Is there a way to make it order by the code's order of constructors ?
18:01:50 <dobblego> deriving Ord on the data type
18:02:15 <Olathe> Does that, if they are the same constructor, perform ord operations on the data ?
18:02:21 <sjanssen> Olathe: yes
18:02:26 <Olathe> Alright, thanks :)
18:03:17 <nolraiWest> How would one do breadth-first searchs in haskell?
18:03:28 <Olathe> Ahh, that works quite nicely, thanks :)
18:03:56 <BMeph> nolraiWest: What Olathe said. ;)
18:04:24 <nolraiWest> BMeph: ??????????????
18:04:34 <Olathe> *Main> x + x*x*abs(abs(y + 5)) + abs(5)*x + x*x
18:04:34 <Olathe> x + 5*x + x*x + x*x*abs(5 + y)
18:05:37 <BMeph> nolraiWest: Looking at http://www.google.com/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fciteseer.ist.psu.edu%2F356396.html&ei=Hu_WSPehMIiy9ATTj_iICg&usg=AFQjCNGFERyTGs_iM2Ap_BY9F1WalGAuqg&sig2=u6edsJALi1V6km4szu1Ycg should be a good springboard. :)
18:05:40 <lambdabot> Title: Programming General Terms - CiteSeerX, http://tinyurl.com/4qotq4
18:06:12 <BMeph> nolraiWest: Er, rather, try http://www.cs.columbia.edu/~cdo/icfp00.ps
18:06:31 <nolraiWest> thanks!
18:07:21 <BMeph> nolraiWest: Er, don't thank me yet, that one doesn't go, either. Try http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.342 instead.
18:07:22 <lambdabot> Title: Programming General Terms - CiteSeerX
18:09:30 <Olathe> Hmm.
18:09:41 <Olathe> deriving Ord screws up on negative numbers.
18:09:55 <Olathe> *Main> sort [5, x]
18:09:55 <Olathe> [5,x]
18:10:05 <Olathe> *Main> sort [-5, x]
18:10:05 <Olathe> *** Exception: stack overflow
18:10:25 <Olathe> @src sort
18:10:25 <lambdabot> sort = sortBy compare
18:10:30 <Olathe> @src compare
18:10:30 <lambdabot> compare x y | x == y    = EQ
18:10:30 <lambdabot>             | x <= y    = LT
18:10:30 <lambdabot>             | otherwise = GT
18:11:11 <roconnor> > compare (-5) x
18:11:13 <lambdabot>   LT
18:11:21 <roconnor> > compare x (-5)
18:11:22 <lambdabot>   GT
18:11:46 <roconnor> > compare (5) x
18:11:47 <lambdabot>   LT
18:11:51 <Olathe> http://hpaste.org/10593
18:11:52 <roconnor> > compare x (5)
18:11:53 <lambdabot>   GT
18:12:01 <Olathe> Can someone tell me why sort[-5, x] fails with that code ?
18:12:07 <roconnor> > compare (5:Expr) (-5)
18:12:08 <lambdabot>   mueval: Prelude.read: no parse
18:12:14 <roconnor> > compare (5::Expr) (-5)
18:12:16 <lambdabot>   GT
18:12:27 <roconnor> > compare (-5) (5::Expr)
18:12:28 <lambdabot>   LT
18:13:04 <roconnor> ... I kinda think sortBy outgh to never stack overflow on a 2 element list
18:13:10 <Olathe> Heheh
18:13:17 <Olathe> @src sortBy
18:13:18 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:13:26 <Olathe> @src insertBy
18:13:26 <lambdabot> insertBy _   x [] = [x]
18:13:26 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
18:13:26 <lambdabot>                                  GT -> y : insertBy cmp x ys'
18:13:26 <lambdabot>                                  _  -> x : ys
18:14:22 <Olathe> An insertion sort ?
18:14:50 <Olathe> Anyway, let me trace this loverly thing.
18:15:24 <Olathe> *Main> compare (-5) x
18:15:24 <Olathe> *** Exception: stack overflow
18:15:26 <Olathe> Oh dear.
18:15:45 <Olathe> I'm not sure how in the world that happens.
18:15:48 <mmorrow> nolraiWest: :) bfs = takeWhile (not . null) . uncurry (:) . fmap (bfs . concat) . unzip . fmap (\(Node x xs)->(x,xs))
18:16:01 <mmorrow> which is pretty much "levels" from Data.Tree
18:16:10 <Olathe> *Main> (-5) == x
18:16:10 <Olathe> *** Exception: stack overflow
18:16:13 <mmorrow> (but takes a Forest instead of a Tree)
18:16:14 <Olathe> That's always fun.
18:16:37 <Olathe> Why does deriving (Eq) do that ?
18:16:51 <mmorrow> what is x?
18:17:04 <Olathe> It's Var "x" in the hpast.
18:17:07 <mmorrow> ah
18:17:13 <Olathe> http://hpaste.org/10593
18:17:18 <Olathe> -5 is IntConst (-5)
18:17:59 <mmorrow> weird.
18:18:04 <Olathe> I think I'm gonna have to define Ord and Eq myself.
18:18:10 <sjanssen> @src negate
18:18:10 <lambdabot> negate x = 0 - x
18:18:44 <sjanssen> @src (-)
18:18:45 <lambdabot> x - y = x + negate y
18:19:01 <sjanssen> Olathe: you have to define at least one of (-) or negate in your Num instance
18:20:03 <sjanssen> Olathe: -5 = negate (fromInteger 5) = 0 - (negate (fromInteger 5)) = 0 + negate (negate (fromInteger 5))
18:20:06 <sjanssen> etc.
18:20:22 <vlm> > [5,5..5]
18:20:23 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
18:20:29 <Olathe> It is ?
18:20:30 <Olathe> Bah.
18:20:33 <mmorrow> yeah, this just loops til stack explosion
18:20:34 <mmorrow> (-5) :: AExpr
18:20:51 <Olathe> So, if I implement negate, it'll work ?
18:21:03 <mmorrow> depends on how you implement it ;)
18:21:09 <sjanssen> Olathe: yes, you have to implement negate or (-)
18:21:09 <Olathe> OK :)
18:21:13 <mmorrow> negate _ = error "omG"
18:21:17 <Olathe> @index negate
18:21:18 <lambdabot> Prelude
18:21:24 <Olathe> Is that a certain class ?
18:21:25 <Olathe> Num ?
18:21:31 <mmorrow> @src negate
18:21:32 <lambdabot> negate x = 0 - x
18:21:32 <sjanssen> Num, yes
18:21:36 <Olathe> Alright, thanks :)
18:21:55 <Olathe> @src (-)
18:21:55 <lambdabot> x - y = x + negate y
18:21:59 <Olathe> Oh dear.
18:22:04 <Olathe> It's recursive forever.
18:22:19 <sjanssen> Olathe: those are just the default definitions
18:23:39 <Olathe> Ahh.
18:23:47 <Olathe> Well, negate works nicely :)
18:23:48 <Olathe> Thanks.
18:23:55 <mmorrow> , pp $(lift =<< reify 'negate)
18:23:59 <lunabot>  Class op from Num: negate :: forall a_0 . Num a_0 => a_0 -> a_0
18:25:22 <mmorrow> , (text . show . cleanNames') $(lift =<< reify 'negate)
18:25:23 <lunabot>  ClassOpI negate (ForallT [a] [AppT (ConT Num) (VarT a)] (AppT (AppT ArrowT (...
18:25:40 <Olathe> How do I make a function private to the file it's written in ?
18:25:51 <mmorrow> don't export it
18:25:59 <Olathe> Ahh.
18:26:01 <mmorrow> (you need to have an export list)
18:26:03 <Olathe> I'll look up exporting.
18:26:08 <Olathe> Ahh, OK.
18:26:37 <mmorrow> module Foo (foo, Bar(Bar), Nine, module Asdf) where ...
18:26:44 <mmorrow> ;)
18:27:37 <Olathe> Ahh, thanks :)
18:27:44 <mmorrow> :)
18:42:35 <ddarius> > [5..5]
18:42:37 <lambdabot>   [5]
18:42:39 <ddarius> > [5..6]
18:42:41 <lambdabot>   [5,6]
18:43:56 <Olathe> > let f [] = omg 5; f (x:xs) = omg 6 where omg x = x + 1 in f []
18:43:57 <lambdabot>   mueval: Prelude.read: no parse
18:44:05 <Olathe> How do I get the where to apply to both ?
18:44:28 <ddarius> Olathe: You don't.  You could use guards or a case.
18:44:55 <ddarius> Alternatively, you could use a let on the outside.
19:24:35 <nolraiWest> is fmap not defined for Sequences?
19:30:55 <nolraiWest> Hello anybody here?
19:31:26 <nolraiWest> never mind
19:31:30 <lunabot>  hello, dave
19:31:37 <mmorrow> ;)
19:31:48 <mmorrow> nolraiWest: what's up
19:34:40 <nolraiWest> couln't find the functor instance for Seq, but then i found it.
19:34:56 <nolraiWest> Im almost done I think.
19:35:12 <mmorrow> nice
19:35:18 <mmorrow> @src Seq
19:35:19 <lambdabot> Source not found. You type like i drive.
19:37:05 <nolraiWest> @src Seq Functor
19:37:06 <lambdabot> Source not found. I feel much better now.
19:37:13 <nolraiWest> @src Functor Seq
19:37:13 <lambdabot> Source not found.
19:37:19 <nolraiWest> ehh
19:38:02 <nolraiWest> Oh whats the pragma for alowing scopeable type variables?
19:40:09 <mmorrow> hmm, not sure
19:40:24 <mmorrow> look in Language.Haskell.Extensions
19:40:28 <mmorrow> or something like that
19:40:33 <mmorrow> in the stdlib docs
19:40:34 <nolraiWest> Its ScopedTypeVariables should have just tried that.
19:40:37 <mmorrow> heh
19:51:11 <clanehin> Where the test suite is for the base library?
19:57:28 <dons> in the testsuite repo
20:02:21 <clanehin> ah, I get it, you need a special thingie to sync-all.  Thanks.
20:25:38 <Cale> http://www.boasas.com/?c=1010 -- hehe
20:25:43 <lambdabot> Title: Boy on a Stick and Slither
20:38:53 <dmwit> Whoa!
20:39:02 <dmwit> http://boasas.com/?c=759 http://boasas.com/?c=828
20:39:03 <lambdabot> Title: Boy on a Stick and Slither
20:39:36 <dmwit> Two consecutive clicks of the "Random Comic" button.
20:40:23 <Cale> heh
20:40:38 <Cale> From before and after the syndication line.
20:41:02 <dmwit> Ah, did he do a few repeats for the new syndication?
20:41:13 <Cale> yeah, I think so
20:41:26 <Cale> and the format changed...
20:41:45 <Cale> I liked the bigger format better, but I suppose it hasn't hurt too much.
20:42:51 <BMeph> I like http://www.boasas.com/?c=1005 you can almost taste the irony... ;)
20:42:54 <lambdabot> Title: Boy on a Stick and Slither
20:43:15 <dmwit> http://boasas.com/?c=565 # my favorite so far
20:43:16 <lambdabot> Title: Boy on a Stick and Slither
20:43:36 <mmorrow> is it true that irony tastes like copper?
20:43:45 <dmwit> No, it tastes coppery.
20:43:46 * BMeph chuckles
20:43:47 <aempirei> is there a standard way 2 define list comprehensions where each element in the sequence is recursively defined
20:44:02 <aempirei> like should i just use map (f) [1..]
20:44:12 <dmwit> what?
20:44:21 <dmwit> What do you mean by "recursively defined"?
20:44:28 <aempirei> ehre f is the recusrive unction definition
20:44:29 <BMeph> aempirei: Yes; use "loeb". ;)
20:44:31 <sjanssen> aempirei: inferred type Num a => a, expected type Word
20:44:59 <dmwit> heh
20:45:37 <aempirei> f 1 = 0 ; f 2 = 1 ; f n = f (n-1) + f (n-2)
20:45:41 <sjanssen> aempirei: anyway, it is generally preferred to use 'map' when you're only mapping a function
20:45:56 <sjanssen> aempirei: reserving list comprehensions for the more complicated cases
20:46:12 <dmwit> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 5 fibs -- you mean like this kind of thing?
20:46:13 <lambdabot>   [1,1,2,3,5]
20:47:11 <dmwit> > let fibs = 1:1:[x+y | (x,y) <- zip fibs (tail fibs)] in take 6 fibs -- it can certainly be massaged into comprehension form, but it seems a bit unnecessary
20:47:13 <lambdabot>   [1,1,2,3,5,8]
20:47:29 <aempirei> maybe ill try to restate
20:47:52 <aempirei> i have a recurance relation f
20:48:11 <aempirei> one way to make that an infinirte series is map (f) S1..]
20:48:20 <aempirei> err [1..]
20:48:36 <aempirei> is there some other eay to define recurancerelations as a list
20:48:45 <dmwit> Yes.
20:48:51 <aempirei> that is normal
20:49:00 <dmwit> Take a look at my first definition of fibs above; it will give you a hint about how to do it.
20:49:01 <aempirei> ok and u mentioned loeb
20:49:10 <mmorrow> , let loeb a = fmap ($ loeb a) a in loeb [\x -> 3 + (x!!1), const 10]
20:49:16 <mmorrow> > let loeb a = fmap ($ loeb a) a in loeb [\x -> 3 + (x!!1), const 10]
20:49:17 <lambdabot>   [13,10]
20:49:30 <mmorrow> , let loeb a = fmap ($ loeb a) a in loeb [(x!!1), const 10]
20:49:31 <lunabot>   Not in scope: `x'
20:49:35 <mmorrow> , let loeb a = fmap ($ loeb a) a in loeb [(!!1), const 10]
20:49:35 <lunabot>  [10,10]
20:50:16 <dmwit> Hum... loeb doesn't seem so useful for the construction of infinite lazy lists that are based on (recent, previous) entries, though.
20:50:32 <mmorrow> , let cofix f a = f ($ cofix f a) a in cofix fmap [(!!1), const 10]
20:50:33 <lunabot>  [10,10]
20:50:36 <dmwit> For example, the obvious implementation of fibs using loeb would be inefficient indeed...
20:50:56 <aempirei> i see map as looking clean and working fine is the issue with it a time complexity issue calculating up to the nth list element
20:51:04 <aempirei> or u just dont like it
20:51:49 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
20:51:50 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:52:04 <dmwit> > let loeb a = fmap ($ loeb a) a in loeb ([const 1, const 1] ++ [\x -> x !! n + x !! (n-1) | n <- [0..]])
20:52:05 <lambdabot>   mueval: Prelude.read: no parse
20:52:05 <lambdabot>  mueval: [1,1,*** Exception: Prelude.(!!): n...
20:52:09 <dmwit> oops
20:52:37 <dmwit> hmmm, what's wrong with that?
20:52:48 <mmorrow> i think the double (!!)s
20:53:03 <dmwit> > let loeb a = fmap ($ loeb a) a in loeb ([const 1, const 1] ++ [\x -> (x !! n) + (x !! (n-1)) | n <- [0..]])
20:53:04 <lambdabot>   mueval: Prelude.read: no parse
20:53:05 <lambdabot>  mueval: [1,1,*** Exception: Prelude.(!!): n...
20:53:18 <mmorrow> oh, you're going out of bounds...
20:53:25 <dmwit> oh, yeah =P
20:53:29 <dmwit> > let loeb a = fmap ($ loeb a) a in loeb ([const 1, const 1] ++ [\x -> (x !! n) + (x !! (n+1)) | n <- [0..]])
20:53:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:53:33 <mmorrow> yay
20:53:40 <dmwit> Still, that seems... so inefficient.
20:53:48 <mmorrow> > let loeb a = fmap ($ loeb a) a in loeb ([const 1, const 1] ++ [\x -> (x !! n) + (x !! (n+1)) | n <- [0..]]) !! 10000
20:54:07 <lambdabot>   mueval: Prelude.read: no parse
20:54:14 <mmorrow> > let loeb a = fmap ($ loeb a) a in (loeb ([const 1, const 1] ++ [\x -> (x !! n) + (x !! (n+1)) | n <- [0..]])) !! 10000
20:54:29 <lambdabot>   mueval: Prelude.read: no parse
20:54:33 <dmwit> eh?
20:54:40 <mmorrow> , let loeb a = fmap ($ loeb a) a in (loeb ([const 1, const 1] ++ [\x -> (x !! n) + (x !! (n+1)) | n <- [0..]])) !! 10000
20:54:41 <lunabot>  luna: out of memory (requested 1048576 bytes)
20:54:45 <dmwit> ah
20:54:46 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1 !! 10000
20:54:47 <lunabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
20:55:12 <sjanssen> mmorrow: that is O(n^2), where the better solution is O(n)
20:55:15 <mmorrow> yeah, i guess it's probably equiv to fib n = fib (n-1) + fib (n-2)
20:55:27 <sjanssen> (pretending for now that addition is O(1))
20:55:34 <mmorrow> sjanssen: which are you refering to?
20:55:38 <aempirei> expressions of high diction seem a bit masturbatory
20:55:41 <dmwit> > let fibs = 0:1:ap (zipWith (+)) tail fibs in fibs !! 10000
20:55:42 <Olathe> > ffib 10000
20:55:42 <sjanssen> mmorrow: the loeb version
20:55:48 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
20:55:48 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
20:55:49 <sjanssen> mmorrow: or am I missing something?
20:55:59 <Olathe> > ffib 1000000
20:56:01 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
20:56:03 <mmorrow> no, i think the loeb one is probably at least O(n^2)
20:56:45 <Olathe> > length $ show $ ffib 1000000
20:56:47 <lambdabot>   208988
20:58:52 <humasect> what do we do when a program becomes bigger than the code? diagrams? milestones? bug reports? =)
20:59:19 <SamB_XP> bigger than the code???
20:59:29 <mmorrow> if someone wrote a mini spreadsheet expression parser, we could have a mini spreadsheet one-liner ...
20:59:33 <dmwit> You mean, when you release it?
20:59:38 <SamB_XP> how can the program be larger than the code?
20:59:57 <roconnor> template haskell!
21:00:10 <SamB_XP> but the program IS the code
21:00:12 <mmorrow> , [|"oh snaP"|]
21:00:13 <lunabot>  LitE (StringL "oh snaP")
21:00:23 <dmwit> Pans ho!
21:01:59 <roconnor> mmorrow: a fine example of how the program is bigger than the code ... I think
21:02:12 <humasect> i am curious how large projects in haskell are maintained effectively as they become something of their own 'personality'; both to fulfilling the requirements, as well as new features. milestones? bug reports? dreams?
21:02:17 <mmorrow> heh
21:03:02 <sjanssen> humasect: that seems more like a qquestion about the humans behind a project, rather than the programming language
21:03:17 <humasect> indeed, hence you guys! =)
21:03:50 <roconnor> haskell projects are never large. We have so much abstraction that our programs are always tiny. :P
21:04:06 <humasect> hm , i like that=)
21:04:26 * roconnor is just hiding the fact that he has never worked on a large Haskell project.
21:04:47 <dmwit> humasect: Web page, FAQ, docs, IRC channel, mailing list, bug tracker -- these things seem common to all the successful Haskell projects
21:04:49 <SamB_XP> humasect: or so we wish
21:04:51 <osfameron> main =justDoWhatIMeanDammit
21:04:52 <dmwit> But that's not very Haskell specific.
21:05:04 <dmwit> Basically, every successful project in any language has those.
21:05:10 <roconnor> is Xmonad a large haskell project?  How many lines is it? :P
21:05:11 <SamB_XP> at least some of them
21:05:16 <ddarius> SamB_XP: Decompress the executable at runtime.
21:05:19 <dmwit> roconnor: 1000ish
21:05:20 <humasect> dmwit: hm, i see. haddock seems to help a little, and mmorrow 's graphiviz thing would be handy also.
21:05:30 <SamB_XP> ZSNES doesn't have a mailing list or a bug tracker ...
21:05:43 <humasect> for haskell maybe 'successful' is a better word than 'large' =)
21:05:50 <mmorrow> humasect: gah, i have to clean that up and put it somewhere ...
21:06:01 <humasect> hehe
21:06:06 <mmorrow> ;)
21:06:43 <SamB_XP> does Xmonad have a bug tracker?
21:06:47 <dmwit> yes
21:06:54 <SamB_XP> ... you mean ...
21:06:57 <SamB_XP> it has bugs?
21:07:21 <dmwit> Mostly in the contrib modules.
21:07:22 <dmwit> But yes.
21:07:24 <humasect> i'm sure it is just me , but, this project i am working on is just about 5000 lines. most of it is ultra-clean and factored as well as i could. but i find to be in a place where it will topple and devour me and my loved ones, without some precise steps to care for this situation
21:07:56 <SamB_XP> humasect: well-placed support columns
21:08:28 <humasect> haddock is a little bit more distracting since it is not meant as an API, but helps to see the structure
21:09:32 <humasect> SamB_XP: hm cool, yes i can see this. i think they are in place for the most part (i know exactly where everything is and what would crumble if i change what etc. it is clean enough to be able to predict most ghc errors)
21:10:11 * SamB_XP wonders why humasect took the answer seriously
21:10:18 * SamB_XP shrugs and goes to bed
21:10:28 <humasect> ..thanks for your help SamB_XP.
21:11:08 <humasect> i will start with a web page , docs, and FAQ. thanks dmwit
21:11:13 * mmorrow reads about linkers
21:15:56 <Olathe> @type f x = f
21:15:58 <Olathe> @type f x = f in f
21:15:58 <lambdabot> parse error on input `='
21:15:59 <lambdabot> parse error on input `='
21:16:04 <Olathe> @type let f x = f in f
21:16:06 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
21:16:06 <lambdabot>     Probable cause: `f' is applied to too few arguments
21:16:06 <lambdabot>     In the expression: f
21:17:55 <mmorrow> @type let f = flip const f in f
21:17:56 <lambdabot> forall a. a -> a
21:18:02 <mmorrow> err
21:18:31 <mmorrow> @type let f = flip const f in f 0 1 2 3 4 5
21:18:32 <lambdabot>     Ambiguous type variable `t' in the constraint:
21:18:33 <lambdabot>       `Num t' arising from the literal `1' at <interactive>:1:28
21:18:33 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
21:18:40 <mmorrow> @type let f = flip const f in f 0
21:18:41 <lambdabot> forall t. (Num t) => t
21:18:55 <mmorrow> @type let f = flip const (f
21:18:56 <lambdabot> parse error (possibly incorrect indentation)
21:19:08 <mmorrow> @type let f = flip const (f $) in f
21:19:09 <lambdabot> forall a. a -> a
21:19:23 <dmwit> ?pl let f x = f in f
21:19:23 <lambdabot> fix const
21:19:28 <mmorrow> ahhh
21:19:35 <dmwit> ;-)
21:19:39 <mmorrow> hehe
21:20:39 <dmwit> What was that clever puzzle with fix/fmap/return that boiled down to const or id or something like that?
21:21:30 <osfameron> ?pl let f x = f
21:21:31 <lambdabot> (line 1, column 12):
21:21:31 <lambdabot> unexpected end of input
21:21:31 <lambdabot> expecting letter or digit, variable, "(", operator, ";" or "in"
21:21:41 <dmwit> ?pl f x = f
21:21:41 <lambdabot> f = fix const
21:21:59 <osfameron> why the fix?
21:22:12 <dmwit> It's recursive.
21:22:36 <dmwit> f is the "hungry" function that eats as many arguments as you can give it and still wants more.
21:22:52 <osfameron> what's the definition of const itself?
21:22:58 <thoughtpolice> @src const
21:22:58 <lambdabot> const x _ = x
21:22:59 <dmwit> ?src const
21:22:59 <lambdabot> const x _ = x
21:23:03 <Olathe> @type fix const
21:23:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
21:23:04 <lambdabot>     Probable cause: `const' is applied to too few arguments
21:23:04 <lambdabot>     In the first argument of `fix', namely `const'
21:23:11 <Olathe> > fix const $ 5
21:23:12 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
21:23:13 <lambdabot>      Proba...
21:24:04 <twb> So Haskell strings are unicode.  What are Haskell characters?  Codepoints?
21:24:09 <Olathe> Man...that was the whole reason I learned functional programming. Now Haskell is saying I can't do that ?!
21:24:20 <humasect> @src Char
21:24:20 <lambdabot> data Char = C# Char#
21:24:36 <thoughtpolice> Olathe: you can wrap in a newtype to allow infinite types
21:24:38 <Olathe> > ord $ maxBound :: Char
21:24:39 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
21:24:46 <dmwit> twb: Right.
21:24:47 <Olathe> > ord (maxBound :: Char)
21:24:48 <lambdabot>   1114111
21:24:59 <Olathe> What's a newtype ?
21:25:07 <Olathe> The things I have to learn in this place...
21:25:09 <dmwit> newtype is in between "type" and "data"
21:25:09 <Olathe> ;)
21:25:15 <bd_> Olathe: fix const doesn't make sense. You'd have fix const :: T, where T = forall a. (a -> T)
21:25:19 <dmwit> Oh, you weren't asking for real. =P
21:25:27 <bd_> so you can keep passing in values, but you don't get anything useful out
21:25:36 <Olathe> bd_: That's the point ;)
21:25:47 * dmwit notes that you could easily do this with an extra data type
21:25:49 <Olathe> You get that function out.
21:26:06 <osfameron> what can you do w4ith fix const thenp?
21:26:16 <dmwit> i.e. Haskell is iso-recursive, not equi-recursive.
21:26:17 <Olathe> You can get fix const.
21:26:24 <shrughes> > fix (const 5)
21:26:25 <lambdabot>   5
21:26:38 <thoughtpolice> but the type is obviously infinite, fix :: (a -> a) -> a, const :: a -> b -> a, by trying to solve the equation so to speak, you get that (a -> a) -> a = a -> (b -> a), so a = (b -> a)
21:26:42 <shrughes> > filterM (const [True, False]) [1..3] -- another classic case of const
21:26:43 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
21:27:09 <shrughes> but never mind I misread :(
21:27:14 <dmwit> > filterM (return [False..]) [1..3] -- obfuscated
21:27:15 <lambdabot>   mueval: Prelude.read: no parse
21:27:21 <dmwit> > filterM (return [False ..]) [1..3] -- obfuscated
21:27:22 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
21:27:28 <shrughes> heh nice
21:27:28 <thoughtpolice> makes no sense, pl doesn't take that into account i guess
21:27:45 <Olathe> > [False..]
21:27:46 <lambdabot>   mueval: Prelude.read: no parse
21:27:51 <Olathe> > [False ..]
21:27:52 <lambdabot>   [False,True]
21:27:57 <Olathe> O-o
21:28:00 <Olathe> > [False..]
21:28:02 <lambdabot>   mueval: Prelude.read: no parse
21:28:02 <dmwit> Olathe: That parses as trying to use the (.) function from the False module.
21:28:08 <Olathe> Oh.
21:28:10 <shrughes> @src enumFrom
21:28:10 <lambdabot> Source not found. My pet ferret can type better than you!
21:28:13 <dmwit> Thank you very much, maximal munch rule.
21:28:21 <Olathe> I had a bug like that before.
21:28:26 <Olathe> > [True ..]
21:28:28 <lambdabot>   [True]
21:28:32 <Olathe> > [True, False ..]
21:28:33 <lambdabot>   [True,False]
21:28:45 <Olathe> > True > False
21:28:47 <lambdabot>   True
21:28:57 <dmwit> Bool is in Ord?
21:28:58 * osfameron is confused and scared of fix..
21:28:59 <dmwit> YES
21:29:00 <Olathe> Hmm...
21:29:08 <Olathe> You could probably make implication operators with >
21:29:09 <dmwit> Now I can make a Map Bool String!
21:29:11 <shrughes> > [0x7ffffffa ..] :: [Int]
21:29:13 <lambdabot>   [2147483642,2147483643,2147483644,2147483645,2147483646,2147483647,21474836...
21:29:21 <Twey> osfameron: Why is fix scary?
21:29:27 <dmwit> Olathe: (<), surely
21:29:27 <shrughes> > [0x7ffffffc ..] :: [Int]
21:29:28 <lambdabot>   [2147483644,2147483645,2147483646,2147483647,2147483648,2147483649,21474836...
21:29:33 <shrughes> oh :/
21:29:35 <osfameron> and of that powerset in const filterM example
21:29:37 <Olathe> > liftM2 (>=) [True, False] [True, False]
21:29:39 <lambdabot>   [True,True,False,True]
21:29:43 <shrughes> > [0x7ffffffffffffffc ..] :: [Int]
21:29:44 <lambdabot>   [9223372036854775804,9223372036854775805,9223372036854775806,92233720368547...
21:29:51 <Olathe> Looks like >= is implication.
21:30:09 <Olathe> > False >= True
21:30:13 <thoughtpolice> osfameron: it's just the y combinator :]
21:30:14 <lambdabot>   False
21:30:21 <shrughes> > [0x7ffffffffffffffe ..] :: [Int]
21:30:22 <lambdabot>   [9223372036854775806,9223372036854775807]
21:30:38 <osfameron> Twey: huh? cos it's hard. and probly i haven't spent enough time looking at it
21:30:47 <Twey> @src fix
21:30:47 <lambdabot> fix f = let x = f x in x
21:30:54 <Twey> Not hard :)
21:31:01 <dmwit> > maxBound + 1 :: Int
21:31:02 <lambdabot>   -9223372036854775808
21:31:58 <humasect> ah..
21:32:01 <dmwit> osfameron: Given a definition "let foo = ...", where foo is on the RHS, you can implement foo as "let foo = fix (\foo -> ...)".
21:32:09 <dmwit> osfameron: It's a really mechanical transformation.
21:32:19 <osfameron> Twey: apart from it looks like a programming error if you're not used to laziness, and gives no clue as to why and how you'd use it for what..
21:32:44 <Olathe> > let addOne = fix (\addOne -> (+1)) in addOne 5
21:32:45 <lambdabot>   6
21:32:59 <dmwit> For sanity, most people alpha-reduce the inside, so they do "let foo = fix (\bar -> ...)", but in this case you have to change all occurrences of "foo" in "..." to "bar", of course.
21:33:03 <osfameron> dmwit:  yeah, i "know". ish. just not very comfortable with it
21:33:12 * dmwit nods
21:33:14 <dmwit> it's weird
21:33:42 <Olathe> > fix (\addOne -> (+1)) 5
21:33:44 <lambdabot>   6
21:34:13 <shrughes> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 7
21:34:14 <lambdabot>   5040
21:34:19 <BMeph> dmwit, osfameron: Yeah, but not as weird as loeb. Now that puppy's downright freaky! ;)
21:34:27 <dmwit> > fix (\fib n -> if n < 2 then 1 else fib n + fib (n-1)) 10
21:34:28 <humasect> @src loeb
21:34:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:34:29 <lambdabot>   mueval: Prelude.read: no parse
21:34:29 <lambdabot>  mueval: *** Exception: stack overflow
21:34:42 <thoughtpolice> > let fac = fix (\f n -> if n == 0 then 1 else n*f (n-1)) in fac 10
21:34:43 <lambdabot>   3628800
21:34:46 <osfameron> loeb?
21:34:48 <dmwit> > fix (\fib n -> if n < 2 then 1 else fib n + fib (n-1)) 5
21:34:50 <lambdabot>   mueval: Prelude.read: no parse
21:34:51 <lambdabot>  mueval: *** Exception: stack overflow
21:34:56 <dmwit> oh
21:35:01 <Twey> > if_
21:35:02 <lambdabot>   mueval: Prelude.read: no parse
21:35:03 <dmwit> > fix (\fib n -> if n < 2 then 1 else fib (n-1) + fib (n-2)) 10
21:35:05 <lambdabot>   89
21:35:11 <Twey> > if_ True 1 2
21:35:12 <lambdabot>   mueval: Prelude.read: no parse
21:35:27 <dmwit> ?let if_ p x y = if p then x else y
21:35:28 <thoughtpolice> osfameron: personally I never really got the alligator/hungry thing, I kinda figured it out through SPJs book
21:35:30 <lambdabot>  Defined.
21:35:34 <dmwit> > if_ True 1 2
21:35:35 <Twey> Wasn't there a function-form if in \b?
21:35:36 <lambdabot>   1
21:35:37 <thoughtpolice> using beta reduction
21:35:37 <Twey> Huh, OK
21:35:38 <shrughes> @type if'
21:35:39 <lambdabot> Not in scope: `if''
21:35:44 <shrughes> @type if_
21:35:45 <dmwit> Twey: Nope, but ?pl uses it.
21:35:45 <lambdabot> forall t. Bool -> t -> t -> t
21:35:52 <osfameron> thoughtpolice: alligator?
21:36:03 <qqmrw> win new
21:36:06 <thoughtpolice> yeah i can't remember where I saw it
21:36:32 * osfameron goes back to bed. it is too early in the morning for haskell..
21:36:37 <Twey> Haha
21:36:39 <dmwit> There's an alligator/egg presentation of the lambda calculus.
21:36:45 <dmwit> It's really silly, and not very helpful.
21:36:46 <Olathe> Oh yeah. Sleep.
21:36:51 <Olathe> Time to go sleep.
21:37:18 <dmwit> http://worrydream.com/AlligatorEggs/
21:37:25 <lambdabot> Title: Alligator Eggs!
21:38:20 <ddarius> > let loeb = fix ((fmap .) . flip ($)) in loeb (const 1:const 1:[\x -> x !! n + x !! (n+1) | n <- [0..]])
21:38:22 <lambdabot>       Occurs check: cannot construct the infinite type:
21:38:22 <lambdabot>        a = (a -> a1 -...
21:38:35 <ddarius> @google sigfpe loeb
21:38:37 <lambdabot> No Result Found.
21:38:45 <dmwit> It uses an odd "evaluate inside lambdas" evaluation order, though.
21:38:56 <ddarius> http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
21:38:57 <lambdabot> Title: A Neighborhood of Infinity: From Löb's Theorem to Spreadsheet Evaluation, http://tinyurl.com/22eoxu
21:40:00 <humasect> hehe, alligator eggs
21:42:19 <shrughes> > let if' = (. (. (:[])) . (:)) . flip (!!) . fromEnum in if' True 3 4
21:42:20 <lambdabot>   Couldn't match expected type `a -> [a]'
21:42:30 <dmwit> ew
21:43:01 <dmwit> ?pl \p x y -> [y, x] !! fromEnum p
21:43:02 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
21:43:28 <dmwit> > let if' = flip (flip . ((!!) .) . flip (:) . return) . fromEnum in if' True 3 4
21:43:29 <lambdabot>   3
21:43:44 <Olathe> @hoogle Bool -> Maybe
21:43:45 <lambdabot> Did you mean: Bool -> Maybe a /count=20
21:43:45 <lambdabot> Control.Exception assert :: Bool -> a -> a
21:43:45 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
21:43:53 <Olathe> No, I didn't mean that.
21:43:54 <osfameron> obfuscated perl has nothing on haskell..
21:43:57 <Olathe> @hoogle Bool -> Maybe a
21:43:58 <lambdabot> Prelude Just :: a -> Maybe a
21:43:58 <lambdabot> Data.Maybe Just :: a -> Maybe a
21:43:58 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:44:38 <dmwit> :t guard
21:44:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
21:44:59 <shrughes> sure
21:45:10 <Olathe> > assert True "Yay !"
21:45:11 <lambdabot>   mueval: Prelude.read: no parse
21:45:17 <Olathe> No parse ?!
21:45:24 <dmwit> :t \p x y -> maybe y (const x) (guard p)
21:45:25 <lambdabot> forall a. Bool -> a -> a -> a
21:45:26 <Twey> :t assert
21:45:27 <shrughes> mueval..
21:45:28 <lambdabot> Not in scope: `assert'
21:45:38 <Twey> No assert
21:45:41 <Olathe> Wait a minute.
21:45:42 <dmwit> ?pl \p x y -> maybe y (const x) (guard p)
21:45:42 <lambdabot> flip (flip . flip maybe . const) . guard
21:45:45 <Olathe> > ord True
21:45:46 <lambdabot>   Couldn't match expected type `Char' against inferred type `Bool'
21:45:54 <dmwit> > fromEnum True
21:45:56 <lambdabot>   1
21:45:59 <Olathe> There was some function that took True to 1 earlier.
21:46:02 <Olathe> Ahh.
21:46:05 <Twey> fromEnum
21:46:18 <Olathe> It was some >>= weird thing, but that'll work.
21:46:21 <Olathe> > fromEnum False
21:46:23 <lambdabot>   0
21:46:59 <Olathe> > let if' c a b = [a, b] !! (fromEnum c) in if' False "yes" "no"
21:47:01 <lambdabot>   "yes"
21:47:09 <Olathe> > let if' c a b = [b, a] !! (fromEnum c) in if' False "yes" "no"
21:47:11 <lambdabot>   "no"
21:47:16 <Olathe> @pl let if' c a b = [b, a] !! (fromEnum c) in if'
21:47:16 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
21:47:21 <Olathe> Yee haw !
21:47:23 <Olathe> Or something.
21:47:30 <dmwit> We already did that one.
21:47:33 <Olathe> Oh.
21:47:43 <Olathe> @pl if p then t else f
21:47:43 <lambdabot> if' p t f
21:47:50 <Olathe> We need to replace if' there with that.
21:48:11 <dmwit> I like "flip (flip . flip maybe . const) . guard" better.
21:48:19 <humasect> @type <<
21:48:20 <lambdabot> parse error on input `<<'
21:48:27 <dmwit> :t (<<)
21:48:28 <lambdabot> Not in scope: `<<'
21:48:29 <Olathe> > flip (flip . flip maybe . const) . guard $ True "yes" "no"
21:48:30 <lambdabot>   Couldn't match expected type `[Char] -> [Char] -> Bool'
21:48:44 <humasect> :t Text.Html.(<<)
21:48:45 <lambdabot> Couldn't find qualified module.
21:48:47 <sjanssen> @src guard
21:48:47 <lambdabot> guard True  =  return ()
21:48:47 <lambdabot> guard False =  mzero
21:48:50 <dmwit> > (flip (flip . flip maybe . const) . guard) True "yes" "no"
21:48:51 <lambdabot>   "yes"
21:49:08 <Olathe> > guard True
21:49:09 <lambdabot>       No instance for (Show (m ()))
21:49:10 <lambdabot>        arising from a use of `show' at <i...
21:49:14 <Olathe> > length $ guard True
21:49:16 <lambdabot>   1
21:49:17 <dmwit> > guard True :: Maybe ()
21:49:18 <lambdabot>   Just ()
21:49:21 <humasect> > fix guard
21:49:23 <lambdabot>   Couldn't match expected type `Bool' against inferred type `m ()'
21:49:56 <Olathe> @pl \p a b -> [b, a] !! length (guard p)
21:49:56 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . length . guard
21:50:15 <Olathe> @pl \p b a -> [b, a] !! length (guard p)
21:50:16 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . length . guard
21:50:24 <Olathe> @pl \b a p -> [b, a] !! length (guard p)
21:50:25 <lambdabot> flip flip (length . guard) . (((.) . (!!)) .) . (. return) . (:)
21:50:29 <dmwit> fromEnum is superior to length . guard. =)
21:50:31 <Olathe> @pl \a b p -> [b, a] !! length (guard p)
21:50:32 <lambdabot> flip flip (length . guard) . (((.) . (!!)) .) . flip (:) . return
21:50:39 <dmwit> How about:
21:51:11 <dmwit> ?pl \p t f -> head ((guard p >> return t) ++ [f])
21:51:12 <lambdabot> ((head .) .) . flip flip return . (((.) . (++)) .) . (. return) . (>>) . guard
21:54:13 <Olathe> @unpl (flip (flip . flip maybe . const) . guard)
21:54:13 <lambdabot> (\ m c f -> maybe f (\ _ -> c) (guard m))
21:56:09 <Olathe> > ((.guard).flip.(.const).maybe) "No" True "Yes"
21:56:11 <lambdabot>   "Yes"
21:58:18 <dons> nice, we climbed to 3rd on the shootout ... http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
21:58:20 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
21:58:27 <Olathe> > (flip(flip.(.const).maybe).guard) True "No" "Yes"
21:58:29 <lambdabot>   "Yes"
21:58:33 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=all :)
21:58:35 <lambdabot> Title: spectral-norm benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/5zcma3
21:58:49 * cjb has never heard of ATS.
21:58:57 <dmwit> Yeah!
21:59:06 <dons> also good http://shootout.alioth.debian.org/u64q/benchmark.php?test=mandelbrot&lang=all
21:59:08 <lambdabot> Title: mandelbrot benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language  ..., http://tinyurl.com/4v5dcg
21:59:12 <dmwit> And that's not even using 100% on all the processors!
21:59:14 <dmwit> Take that!
21:59:27 <bos> dons: 6.8.3 or HEAD?
21:59:31 <dons> 6.8.2
21:59:41 <bos> nice.
21:59:46 <dons> spectral-norm kicking butt :)
21:59:55 <dmwit> Memory usage is pretty good there, too.
22:00:01 <bos> must benchmark the new laptop tonight.
22:00:25 <dmwit> Haskell: faster than C.
22:00:37 <dons> this is why multicore matters.
22:00:53 <dons> 1 or 2 more benchmarks and we'll be on top of this thing.
22:01:00 <dons> so hunt for things to parallelise :)
22:01:06 <bos> is the haskell spectral-norm code shorter than the C version?
22:01:25 <dons> nope.
22:01:33 <dons> its the fastest single core and overall though.
22:01:43 <bos> heh, i see some manually unboxed loops in there.
22:01:55 <dons> yeah, not sure that's needed since 6.8.x
22:02:05 <dons> it was with 6.6, but we tackled the unchecked shifts after that
22:02:13 <stmartin> I have a reasonably simple stream processing problem that will read input from two processes (System.Process I think), process them through various stages, and output results. I was looking at dons paper about stream fusion and was wondering if Haskell would be a suitable tool for this job. In particular, how would I deal with the fact that the two processes must be read from simultaenously? In C I would use select(2) or even threads
22:02:20 <bos> and the ever-present primitive shift to strength-reduce (`div` 2)
22:02:37 <bos> stmartin: just use two threads.
22:03:00 <cjb> bos: what new laptop d'you get?
22:03:01 <bos> dons: it's needed, shifts are still checked at least in the code i've looked at core for.
22:03:07 <bos> cjb: lenovo x200
22:03:08 <dons> hmm.
22:03:14 <cjb> bos: oh, x300?
22:03:28 <bos> no, x200
22:03:28 <cjb> oh, no, there is an x200
22:03:29 <cjb> huh
22:03:35 <cjb> how is it different to the x300?
22:04:19 <cjb> Interesting, I'd missed the announcement for this.  Looks like a tablet?
22:09:57 <dons> stmartin: yeah, just use two threads.
22:10:14 <stmartin> And will stream fusion work with that okay?
22:10:41 <dons> sure. you can have multiple threads running fused loops
22:18:08 <dons> hmm. we need to rewrite fannkuck
22:18:14 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=all
22:18:17 <lambdabot> Title: fannkuch benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language Be ..., http://tinyurl.com/48zwqp
22:18:27 <dons> even naive lisp is doing pretty well. and parallelise it.
22:29:26 <quicksilver> dons: dae spent some time attempting to parallelise fannkuch
22:29:38 <quicksilver> dons: and never made it actually use the extra core
22:31:30 <dons> quicksilver: code around somewhere?
22:31:39 <dons> i had a quick go too, but the folds need careful attention.
22:31:45 <dons> porting the lisp program might make sense
22:32:00 <dons> go back to basics, implement it naively ,parallelise that.
22:33:36 <TSC> Would it work to simply split the set of permutations in 2, and give half to each thread?
22:34:30 <dons> yes. some task-specific strategy.
22:34:33 <dons> got a dual core? :)
22:34:42 <quicksilver> dons: yes, on some hpaste. Just a minute I'll find it.
22:34:47 <dons> cheers
22:34:55 <dons> all those folds make things a bit harder.
22:36:58 <quicksilver> dons: can't find it. Here is the version in my working dir.
22:36:59 <quicksilver> http://hpaste.org/10594
22:37:07 <dons> ok. thanks
22:37:13 <quicksilver> dons: not precisely dae's attempt, but certainly a non-working attempt :)
22:37:22 <ushdf> > map (sin) [(pi)..(100*pi)]
22:37:24 <lambdabot>   [1.2246467991473532e-16,-0.8414709848078964,-0.9092974268256817,-0.14112000...
22:37:26 <ushdf> why^
22:37:34 <ushdf> why the inaccuracy
22:37:35 <quicksilver> I was playing with parListChnk and stuff
22:38:03 <ushdf> > pi
22:38:04 <quicksilver> > map sin [pi,pi*2..pi*100]
22:38:05 <lambdabot>   3.141592653589793
22:38:06 <lambdabot>  Terminated
22:38:07 <quicksilver> > map sin [pi,pi*2..pi*100]
22:38:09 <lambdabot>   [1.2246467991473532e-16,-2.4492935982947064e-16,3.6739403974420594e-16,-4.8...
22:38:17 <quicksilver> ^^ rhat's wwhat you meant.
22:38:24 <quicksilver> a little inaccuracy but much less.
22:39:16 <TSC> What does the fannkuch rule "Write the first 30 permutations and the number of flips." mean?
22:40:20 <ushdf> map (\x -> x+1) [1..100]
22:40:21 <TSC> What are the "first 30 permutations"?
22:40:26 <ushdf> > map (\x -> x+1) [1..100]
22:40:28 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
22:40:34 <ushdf> > map (\x -> sin(x)) [1..100]
22:40:36 <lambdabot>   [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.75680249530792...
22:40:38 <dons> TSC: you're doing lots of permutations. you have to print the first 30
22:40:47 <ushdf> > map (\x -> sin(x)) [0..100]
22:40:48 <lambdabot>   [0.0,0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.7568024953...
22:40:57 <ushdf> makes sense!
22:41:05 <TSC> But the problem doesn't define the order in which you should look at them, does it?
22:41:10 <TSC> So everyone might have a different "first 30"
22:41:47 <ushdf> @set adddddition = \x y -> x+y
22:41:49 <lambdabot>  Defined.
22:42:04 <ushdf> > adddddition 1 2
22:42:06 <lambdabot>   3
22:45:01 <dons> TSC: there's a specific order you have to match.
22:46:53 <ushdf> is fixity just the order of operations?
22:47:46 <ski> @let adddddition = \x y -> x + y + 4*d
22:47:47 <lambdabot>  Defined.
22:47:52 <ski> > adddddition 1 2
22:47:53 <ushdf> :(
22:47:54 <lambdabot>   1 + 2 + 4 * d
22:48:43 <ushdf> @let d = 5
22:48:44 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
22:48:48 <ushdf> @set d = 5
22:48:49 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
22:48:53 <ushdf> :(
22:48:59 <rwbarton> :t d
22:49:00 <lambdabot> Expr
22:49:03 <ski> ushdf : fixity is which way an operator will allow attaching on an expression with the same operator (or another of the same precedence)
22:49:10 <ski> @undefine
22:49:18 <ski> @let d = 5
22:49:19 <lambdabot>  Defined.
22:49:20 <ushdf> attaching?
22:49:47 <ski> ushdf : take e.g. `a - b*c - d'
22:50:06 <ushdf> yes
22:50:16 <ski> should that be parsed as `(a - (b*c)) - d' or as `a - ((b*c) - d)' ?
22:50:26 <ushdf> so yes, it's the order of operations for operators...
22:50:32 <ski> fixity answers that question
22:50:38 <ushdf> meh
22:50:40 <ushdf> semantics
22:50:53 <ushdf> > 1-2*3-4
22:50:54 <lambdabot>   -9
22:51:06 <ski> it also answers for `a - b*c + d' and `a + b*c - d'  (since `+' and `-' have the same precedence)
22:51:08 <quicksilver> well actually fixity is often considered to be part of syntax :P
22:51:11 <ushdf> suddenly there's a woman strangling you!
22:51:16 <ushdf> she's wearing too much lipstick!!!
22:51:33 <ski> @vixen is that you ?
22:51:33 <lambdabot> sure is
22:51:44 <ushdf> ?
22:52:03 <ski> lambdabot confessed to be the strangling party
22:52:18 <ushdf> let's call off the search for the missing children then
22:53:20 <ushdf> you came in at a bad time
22:55:07 <ushdf> you came in at a bad time
22:55:21 <ushdf> where did the girl with the red sundress go
22:55:45 <ushdf> > parsing ability
22:55:46 <lambdabot>   mueval: Prelude.read: no parse
22:56:07 <ushdf> he's not self-aware yet
22:56:11 <ushdf> quick, get the holy water!!!
22:56:15 <ski> s/he/she/
22:56:24 <ushdf> gross
22:56:53 <ushdf> s/ski/a herd of scantily clad women/g
22:57:00 <ushdf> oh babe
22:57:12 <ushdf> look atthem
22:57:36 <ushdf> > sin(sin(sin(sin(sin(sin(0)))))
22:57:37 <lambdabot>   mueval: Prelude.read: no parse
22:57:45 <ushdf> > sin(sin(sin(sin(sin(sin(0))))))
22:57:46 <lambdabot>   0.0
22:58:02 <Axman6> > iterate sin 1
22:58:03 <lambdabot>   [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.62757183204...
22:58:17 <ushdf> mine made him make a smiley
22:58:39 <ushdf> i'm a respected neurologist
22:58:41 <ushdf> do as i say
23:00:49 <dons> ushdf: off topic, sorry.
23:00:54 <dons> you can't help yourself eh?
23:01:37 <ushdf> i can help anybody
23:01:40 <ushdf> magic hands
23:02:50 * ski quietly whispers s/bckw/a well spirit named BGWJJILLIGKKKK!/
23:03:12 <dons> ok. no one else around.
23:03:13 --- mode: ChanServ set +o dons
23:03:15 --- mode: dons set +b *!*n=ushdf@*.syr.edu
23:03:15 --- kick: ushdf was kicked by dons (dons)
23:03:19 --- mode: ChanServ set -o dons
23:04:00 <dons> well spirits rock.
23:17:55 <cpfr> hey i want to create a [(Int,Int)] of random Int
23:18:18 <cpfr> but since random is through the IO Monad i cant keep my collection stable
23:18:34 <cpfr> everytime i access them they are regenerated
23:18:45 <TSC> Then don't do that (:
23:18:48 <cpfr> i am considering using unsafeIO
23:19:01 <TSC> Create them once, then reuse the list
23:19:03 <cpfr> TSC, but i want to do computations with this sample
23:19:17 <dons> cpfr: you can do randoms outside IO though
23:19:21 <Deewiant> > let gen = mkStdGen 2 in join zip (randoms gen) :: [(Int,Int)]
23:19:22 <lambdabot>   [(-2493721835987381530,-2493721835987381530),(6819820395428238746,681982039...
23:20:20 <cpfr> > gen
23:20:22 <lambdabot>   mueval: Prelude.read: no parse
23:21:24 <cpfr> dons, listening (:
23:23:17 <glguy> :t randomR
23:23:18 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
23:23:50 <glguy> cpfr: once you pick an initial seed (done in IO usually) you can feed the generator though purely
23:25:19 <cpfr> glguy, i see
23:26:21 <thoughtpolice> playing with dph = fun
23:26:29 <thoughtpolice> although there are still vectorisation errs
23:27:16 <cpfr> glguy, is there anyway to hide the threading of the seed in a monad?
23:27:28 <cpfr> ... that has already been done
23:27:31 <glguy> there is
23:27:44 <glguy> It has been done, many times, and one such instance is known as MonadRandom
23:27:55 <glguy> which is laying around somewhere on the wiki, I believe
23:28:05 <glguy> it is a case of a state monad
23:32:50 <ozy`> so how's that yi editor doing? is it actually going anywhere promising?
23:33:22 <dons> new release last week.
23:33:30 <dons> and talk this week at the haskell workshop.
23:39:46 <Axman6> what are the pros (and cons) of yi?
23:39:49 <Cale> cpfr: You can use newStdGen from the IO monad, and then use the randoms function on the resulting generator to get a (pure) infinite list of random Ints...
23:40:20 <Axman6> apart from being written in haskell...
23:40:31 <cpfr> thanks Cale
23:41:08 <Cale> cpfr: you could do something like  let (g1,g2) = split g in zip (randoms g1) (randoms g2)  -- to get a list of random pairs
23:41:25 <Cale> cpfr: It's strange and unforunate that there isn't a Random instance for pairs.
23:41:39 * glguy needs to write a library to pull an infinite list of randoms out of /dev/srandom
23:41:39 <Cale> cpfr: I suppose the better solution would be to write one first ;)
23:41:51 <glguy> actualRandoms
23:42:01 <Cale> glguy: yeah
23:42:02 <Axman6> glguy: actualPsudoRandoms?
23:42:19 <Cale> In fact, I think it's totally stupid that newStdGen uses the system clock.
23:42:48 <Axman6> Cale: why?
23:42:50 <Cale> You could use /dev/random to get a seed for newStdGen (I think it's okay to eat one word of entropy)
23:42:59 <Cale> Or even /dev/urandom
23:43:06 <Cale> if you're that afraid of blocking
23:43:22 <Axman6> you're almost guaranteed a unique seed right?
23:43:37 <mm_freak_> @pl \(a,b) -> a `seq` p b
23:43:37 <lambdabot> uncurry ((. p) . seq)
23:43:42 * glguy just got one of those Via chips with the RNG source
23:43:53 <Baughn> The OpenAL bundled with ghc doesn't seem to work. Compiling from source, it does. How odd.
23:43:56 <Cale> glguy: That would be cool too.
23:43:57 <glguy> among other neat features
23:43:58 <Axman6> though, i guess if you were writing something that needed security, that's pretty susceptible to a brute force attack
23:44:13 <glguy> Cale: it feeds directly into the kernel entropy pool
23:44:23 <glguy> Cale: all existing apps that use /dev/random benefit
23:44:24 <Cale> glguy: I was just about to ask.
23:44:24 <glguy> :)
23:44:29 <Axman6> glguy: nice. i hear OpenBSD takes good advantage of them
23:44:48 <glguy> and it accelerates AES, SHA1/2, MD5
23:44:55 <glguy> and anything that uses openssl benefits
23:45:38 <glguy> Axman6: That's what OS I'm using
23:45:44 <Adamant> I kinda wish you could get those as coprocessors.
23:45:47 <Axman6> good work :)
23:46:28 <Axman6> i use it for my router. only thing that worked really well at 133MHz, with 32MB RAM
23:46:37 <glguy> I have a hifn 7811 pci card too (not using it)
23:46:39 <glguy> but you can get them
23:46:41 <Axman6> and ≈1GB hdd
23:46:42 <glguy> you don't need it in your processor
23:48:25 <Baughn> "checking value of AL_FALSE... -1" <-- This is wrong, right?
23:49:21 <Baughn> ..yeah. The test actually fails, but for some reason this configure script doesn't detect that. Great.
23:51:34 <Axman6> oh, nice, haskell at #1 on the spectral norm benchmark
23:55:38 <Twey> Axman6: http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
23:55:40 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchma ..., http://tinyurl.com/bruf8
23:55:41 <Twey> #1?
23:55:54 <humasect> hm what system Baughn ?
23:56:05 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=all
23:56:06 <humasect> the prebuilt seems to work here on mac
23:56:07 <lambdabot> Title: spectral-norm benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/5zcma3
23:56:17 <humasect> (and why it is not prebuilt makes it /very/ hard for windows users!)
23:56:21 <Axman6> bah, pentium 4
