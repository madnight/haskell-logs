00:00:44 <Baughn> nha_: The actual FFI overhead for calling C functions from Haskell /exists/, but it's tiny in comparison to the cost of calling opengl functions. Also, as you've noticed (callLists, etc.), opengl was /designed/ for the purpose of being used over high-latency, low-bandwidth connections (at least, it pretends to be), so it can minimize the number of calls
00:00:49 <Baughn> Just like X, at that
00:01:04 <Baughn> (Now if only people would use it that way..)
00:01:13 <Cale> okay, and that gets stashed in the options, in the loadFile field.
00:01:17 <nha_> yea i was profiling it and the haskell overhead was like nothing
00:01:47 <Baughn> It's probably on the order of a hundred cycles. Hardly "nothing", but when the opengl call takes millions..
00:04:20 <Baughn> (Should that range be from 10^1.5 to 10^2.5, or 10^1 to 10^3?)
00:05:21 <Cale> Okay, this makes basically no sense :)
00:05:28 <Cale> hmm
00:06:14 <Cale> Maybe this 'takeFileName' isn't required/helpful.
00:07:38 <Cale> > sort [1,3,2]
00:07:39 <lambdabot>   /tmp/6187477358637478411:5:46: Not in scope: `sort'
00:07:41 <Cale> nope.
00:07:55 <Baughn> > 1
00:07:56 <lambdabot>   1
00:08:25 <int-e> > "") ++ (""
00:08:25 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 10}
00:08:25 <lambdabot> ...
00:08:25 <Baughn> So is L.hi/L.o missing or empty?
00:08:41 <Cale> Deleted, apparently. So it can't be using it.
00:08:51 <Cale> It must be using L.hs
00:09:03 <int-e> > )
00:09:03 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
00:09:03 <lambdabot>  ...
00:09:11 <Cale> But if that's the case, I don't understand why the things L.hs imports are not visible.
00:09:18 <int-e> ah. ugly, but better than "Prelude: no parse"
00:09:30 <int-e> Prelude.read even.
00:10:05 <mauke>  Prelude.read: what
00:11:01 <int-e> > read "" :: Int
00:11:02 <lambdabot>   * Exception: Prelude.read: no parse
00:11:32 <int-e> > read ('"':repeat ' ') :: Int
00:11:44 <lambdabot>   mueval: Prelude.read: no parse
00:12:02 <Cale> > read ('"':repeat ' ') :: String
00:12:17 <lambdabot>   thread killed
00:12:19 <Cale> Well, that's interesting.
00:12:49 <int-e> Haskell98 specifies read in terms of a tokenizer, and the tokenizer has to distinguish "\"..." from "\"...\""
00:12:55 <int-e> so it never returns the first token
00:12:57 <adu> are there any array classes that do interpolation?
00:13:19 <mauke> heh, you mean that kind of interpolation
00:14:17 <adu> like arr ::  InterpArray (Float, Float) Float
00:15:28 <adu> such that (arr ! (0.5, 0.5)) is actually the average of arr!(0,0), arr!(0,1), arr!(1,0), arr!(1,1)
00:16:25 <Cale> Hey, that's interesting...
00:16:59 <Cale> If I modify the hint example.hs to do a "sort [3,2,1]" and modify SomeModule.hs to import Data.List
00:17:02 <Cale> then it works
00:17:19 <lispy> Is there a way, at either the type or value level, to project a phantom type to be by itself?  like, data P a = P, project :: P a -> a
00:17:21 <Cale> But that looks essentially the same as what mueval is doing now... I would think.
00:17:43 <adu> > sort [2,3,1]
00:17:46 <lambdabot>   /tmp/764788644340943984:5:46: Not in scope: `sort'
00:17:59 <Cale> and yet, that does not work.
00:18:09 <int-e> lispy: project :: P a -> a; project _ = undefined
00:18:10 <Cale> @let foo = 43
00:18:11 <lambdabot>  Defined.
00:18:13 <Cale> > foo
00:18:15 <lambdabot>   43
00:18:21 <Cale> This however, magically does.
00:18:43 <adu> lispy: that looks like a kind error
00:18:50 <audax_> good morning
00:19:07 <lispy> int-e: so, then you could do,  mumble `asTypeOf` (project P) ?
00:19:16 <audax_> how do i generate the haddock html index files?
00:19:18 <int-e> lispy: you can even replace P by a type variable there.
00:19:20 <int-e> lispy: yep
00:19:42 <lispy> I'll play with this a bit more, thanks
00:20:28 <adu> audax_: morn
00:22:02 <Axman6> far out. i wish happs stuff would just work. it's been nothing but pain so far, and i've learnt nothing
00:22:18 <Saizan> Cale: mueval uses setInstalledModsAreInScopeQualified False
00:22:26 <lispy> int-e: hmm...is not working.  I have data P a b = P; foo :: (IsC a, IsC b) => P a b; foo = P; project1 :: p a b -> a; project1 = const undefined; but project1 foo, is a type error
00:22:42 <Saizan> Cale: see Hint.Configuration, the documentation explains the problem
00:23:01 <Cale> aha, hmm
00:23:09 <audax_> btw: the real-world-haskell book is really great!
00:23:12 <Cale> So what's the issue if we set that to True?
00:23:13 <lispy> int-e: It says I have an ambiguous type variale 'a' in the constraint
00:23:19 <Cale> Everything is in scope then?
00:23:22 <Saizan> yeah
00:23:26 <Saizan> just like in ghci
00:23:32 <int-e> lispy: yes, but that's because you nowhere fix the 'b' variable.
00:23:47 <Cale> So the problem is really a GHC-API problem?
00:24:00 <Saizan> it seems so
00:24:11 <int-e> lispy: try projecting out both components, project_ :: p a b -> (a, b); project_ = undefined
00:24:23 <lispy> int-e: okay...
00:24:52 <int-e> lispy: project_ P should then have type (IsC a, IsC b) => (a, b)
00:25:20 <lispy> int-e: yeah, that works but jsut like before, as soon as I jettison one (say calling fst) it get the type error again
00:26:13 <int-e> lispy: it's called imrpedicativity - the context must determine the class instances (even those that you're not using)
00:26:19 <Cale> Well, okay, but with the new hint, I suppose I could at least copy all the properly qualified imports into mueval itself.
00:26:29 <Cale> I guess that's almost a fix.
00:26:35 <lispy> int-e: ah
00:26:51 <lispy> int-e: this impredicativity comes up a lot in the stuff I do :)
00:26:55 <lispy> int-e: I need to study it better
00:27:14 <audax_> adu: was that an insult? Oo
00:28:17 <Axman6> anyone have any ideas about this? http://hpaste.org/10759 just used darcs to get the lastest happs-tutorial, and it won't run
00:28:18 <lispy> What, I'm trying to do is given, coerce :: (IsC a, IsC b) => a -> b, can I write a function to coerce' :: P a b -> P x y, using coerce
00:28:50 <lispy> er, coerce' :: (IsC a, IsC b, IsC x, IsC y) => P a b -> P x y, actually
00:30:26 <adu> audax_: no I was welcoming you to this room, and I accidently pressed enter before I was finished typing "morning"
00:30:43 <audax_> adu: ah...k :D
00:31:16 <lispy> adu: lazy irc protocol?
00:31:19 <lispy> ;)
00:31:37 <int-e> lispy: hmm, no, except for the obvious  coerce' P = P which doesn't need all those type classes
00:31:50 <Baughn> lispy: Given the apparent cost of dethunking, the strictness analyzer should be a bit more aggressive
00:32:32 <lispy> int-e: right, that definition is easy, but it won't work in general.  I magine replacing the type P with things that have non-exported constructors.
00:33:06 <lispy> int-e: So, I see that we can project the types out, now I was wondering how I'll inject that into another type sig
00:33:15 <lispy> int-e: asTypeOf gets me part of the way there
00:33:31 <Axman6> guess that's a no...
00:33:55 <lispy> int-e: oh, but I see.  Without access to the data constructors I can't inject those types.  so this is safe.
00:34:01 <audax_> noone here who could help me generating docs with haddock? :o
00:34:17 <int-e> lispy: You can't express the fact that a and b in P a b are phantom types on the type level. (and if they aren't, the coerce clearly doesn't help you building coerce' much - imagine  P a b = P (a -> b))
00:34:46 <int-e> lispy: err. hmm. you have a bijection, but still ...
00:35:07 <lispy> int-e: Well, I can kinda model their phantomness using a type class
00:35:38 <int-e> lispy: well, you'll end up providing functions of the kind  coerce :: P a b -> P c d
00:35:42 <int-e> lispy: I think
00:35:55 <lispy> int-e: I have, class IsC a where; and then I put that constraint into my GADT declarations, like, data (a :> b) x z where (:>) (IsC x, IsC y, IsC z) => a x y -> b y z -> (a :> b) x z
00:36:25 <lispy> int-e: and I don't create any instances of that type class
00:36:39 <lispy> int-e: so only phantomy phantoms can get in to those slots
00:37:11 <lispy> and yes, I have unsafeCoerceP :: (IsC a, IsC b, IsC x, IsC y) => p a b -> p x y
00:37:54 <lispy> AFAICT, this prevents unsafeCoereP from being used to implement unsafeCoerce :: a -> b, and also prevents it from being used to make segfaults.
00:38:40 <Cale> odd...
00:38:54 <Cale> So the new hint provides qualified imports, but still no import lists.
00:39:09 <Cale> Oh well, I guess we avoid ST for now.
00:39:11 <lispy> int-e: does that make sense?
00:40:38 <Saizan> lispy: you've to create the instances for your phantoms though
00:41:15 <lispy> Saizan: supposing we have, data P a b = P; this is valid: foo (IsC a, IsC b) => P a b; foo = P
00:41:23 <lispy> Saizan: so, voila, I have my phantoms
00:41:32 <int-e> lispy: yes, and you'll never be able to use foo
00:41:45 <int-e> not without an IsC instance /somewhere/
00:42:24 <lispy> what, if I add, data Nil; instances IsC nil
00:42:34 <int-e> then you can
00:42:34 <lispy> s/nil/Nil
00:43:06 <int-e> but at the same time you open up the possibility to use undefined :: Nil  as a witness for the IsC class.
00:43:46 <lispy> but, undefined can be used in place of any type
00:43:54 <lispy> So it is really such a bad thing?
00:44:12 <int-e> maybe not.
00:44:55 <int-e> I guess I'm not seeing what the IsC buys you in the end.
00:45:42 <lispy> well, when I had just unsafeCoerceP :: p a b -> p x y, you can easily reimplement unsafeCoerce :: a -> b, with it
00:45:46 <Saizan> i'd put the constraint on p, rather than the parameters
00:46:25 <Saizan> is p uses the arguments only as phantoms then you can't cause segfaults, i think
00:46:31 <lispy> Saizan: I tried that too, but that just constrains the types that can be fed to unsafeCoerce, not the types that can be coerced
00:47:26 <int-e> I mean the point of having a phantom type a in a type (T a) isn't so much that a doesn't have any values; the point is that no value of P actually contains an a.
00:48:37 <lispy> The problem for us arises with an equality class we have.  It has a function like (=\/=) :: p a b -> p a c -> EqCheck b c
00:48:46 <lispy> We implement (=\/=) via unsafeCoerce#
00:49:00 <int-e> so restricting a with an IsC constraint is rather pointless; the property is expressed by having a noop  coerce :: P a -> P b
00:49:09 <lispy> So that when the parameters to (=\/=) are the same we coerce b and c to be the same
00:51:34 <lispy> We want to have a dynamicCast on phantoms I guess
00:52:13 <lispy> But, the techniques I've seen for that require that you know your types ahead of time.  With the exception of () all the types we use in the phantoms are existentialy bound
00:53:36 <int-e> oh and you want to do equality checks on those?
00:53:42 <lispy> Yeah
00:53:51 <lispy> hence (=\/=)
00:54:08 * Twey chuckles at (=\/=)
00:54:13 <lispy> data EqCheck a b where IsEq :: EqCheck a a; NotEq :: EqCheck a b
00:54:54 <lispy> But, if you have a function like (=\/=) :: p a b -> p a c -> EqCheck b c; how do you return IsEq?  Well, we use unsafeCoerce#.
00:56:28 <int-e> so you can write a function  EqCheck a c -> EqCheck b d -> p a b -> Maybe (p c d)
00:57:45 <lispy> f IsEq IsEq p = Just p; f _ _ = Nothing
00:58:06 <lispy> But, how do you do the equality check?
00:58:13 <lispy> p a b -> p a c -> ??
00:58:16 <hackage> Uploaded to hackage: haskore-supercollider 0.0.2
00:58:16 <hackage> Uploaded to hackage: haskore-realtime 0.0.2
00:58:20 <int-e> you create type witnesses and pass them around
00:58:38 <dolio> How are you testing for equality between b and c?
00:58:46 <lispy> dolio: correct
00:58:48 <int-e> alternatively you implement a dynamic version of Data.Typeable ... not sure whether it can be done nicely.
00:58:50 <lispy> But, you do it via p
00:58:52 <dolio> Are you creating unique values or something?
00:59:12 <lispy> dolio: basically yes.  we use existentially bound variables, so they are distinct
00:59:46 <dolio> What are distinct?
00:59:58 <lispy> The types in the phantoms
01:00:00 <dolio> What's a 'p a b'?
01:00:12 <dolio> How does looking at one tell you what b is?
01:00:59 <lispy> so, p is usually a patch type, and something we know about patches is that two patches start in a context a, and have the same contents then b is the same for both patches
01:01:06 <int-e> lispy: You need runtime /values/ to check, unless how the types are propagates is obvious to the compiler (in which case you wouldn't have this problem in the first place).
01:01:19 <lispy> That's what (=\/=) :: p a b -> p a c -> EqCheck b c, is intended to express
01:01:30 <int-e> lispy: the compiler doesn't magically conjure up unique runtime ids for existential types - you have to do the magic yourself
01:01:49 <lispy> int-e: it does magically conjure up compile time ids for existentials though
01:02:20 <int-e> not really, it does "all types are different unless proven equal"
01:02:29 <lispy> int-e: so for the run-time types that we check, we use the equality of the 'p' part of the type
01:02:35 * lispy nods
01:02:44 <lispy> That's what I mean by magicaly conjures up ids :)
01:03:17 <Cale> > sort [3,2,1]
01:03:18 <lambdabot>   [1,2,3]
01:03:22 <Saizan> so 'p' contains enough information to tell if b == c or not, the only problem is telling this to the type checker, summarizing?
01:03:24 <Cale> > runST
01:03:25 <lambdabot>       Overlapping instances for Show ((forall s. ST s a) -> a)
01:03:25 <lambdabot>        arising...
01:03:27 <lispy> There isn't really a way for us to avoid unsafeCoerce#, near as I can tell.  But, I like to try out the alternatives so I can defend why they don't work so well.
01:03:32 <Cale> > unsafeSTToIO
01:03:33 <lambdabot>   Not in scope: `unsafeSTToIO'
01:03:37 <Cale> hmm!
01:03:38 <lispy> Saizan: right, good summary
01:03:41 <Cale> How the...
01:03:59 <Cale> > pure
01:04:00 <lambdabot>       Ambiguous occurrence `pure'
01:04:00 <lambdabot>      It could refer to either `Control.Appl...
01:04:04 <Cale> hmm, okay
01:05:03 <Cale> Well, nothing I can do about that, no import lists.
01:05:12 <Cale> But otherwise, things ought to work.
01:05:23 <Cale> I have no idea why runST is in scope though. That's scary.
01:05:26 <lispy> So, then I think at the end of the day, the IsC approach is as close as I can come to having a dynamic cast and restricting it to the existential types.
01:05:36 <Saizan> > (+1) *** (+2) $ (1,2)
01:05:38 <lambdabot>   (2,4)
01:06:03 <Cale> OH!
01:06:28 <Cale> If functions are explicitly imported by an import declaration, then are they implicitly exported?
01:06:43 <lispy> int-e: for example, I think the problem with what you suggested, EqCheck a c -> EqCheck b d -> p a b -> p c d, is that I still don't have a way to construct the first two params given the way that I get my types (existentially bound)
01:06:46 <dolio> Well, if you have ordinary run-time values that need to inform the type system, I don't see how you can get around calling unsafeCoerce, unless you write your own Typeable GADT + class.
01:07:18 <dolio> And I'm still not sure you can make the connection between the b and whatever the p a b holds known to the type system.
01:07:24 <int-e> lispy: well, you won't escape the unsafeCoerce, but the right place for it is the =\/= operator, I think.
01:07:26 <lispy> dolio: and I guess that's sort of what we have is our own typale
01:07:39 <int-e> lispy: where, as you said, you already have it
01:08:19 <Cale> Well, close enough anyway.
01:08:24 <lispy> int-e: but, having it in =\/= means that any value or function that can return phantoms that are unrelated to input types can be combined with =\/= to reimplement unsafeCoerce :)
01:08:31 <Cale> I could fix the pure thing, but I've had enough :)
01:08:56 <Saizan> Cale++
01:09:02 <lispy> Thanks Cale
01:09:13 <Cale> Let me know if you guys find anything suspicious.
01:09:13 <lispy> Cale: olive appreciates it :)
01:09:17 <Cale> hehe
01:09:31 <Cale> Lambdabot still seems to grow slowly.
01:09:38 * lispy names all his computers after fruit...he's working from apricot at the moment
01:09:43 <Cale> But restarting it occasionally fixes that.
01:09:48 <lispy> cool
01:10:02 <Cale> (I just do it by hand, it grows so slowly that's not really much of an issue :)
01:10:19 <lispy> int-e: thinking further, probably it doesn't matter if =\/= uses unsafeCoerce
01:10:38 <Cale> Over a couple of weeks, it got up around 400MB
01:10:40 <lispy> int-e: it's more the fact of its type signature
01:10:54 <int-e> lispy: uhm. right. sorry. So what you can really have is a function  p a b -> p c d -> Maybe (p a b) which checks that the two patches agree on a, c and b, d, and returns the coerced second patch (or not)
01:11:05 <lispy> Cale: having manual would make me happy, but I trust your judgement.
01:11:32 <Cale> manual?
01:11:42 <lispy> Cale: doing it manually I meant
01:11:46 <lispy> er wait
01:11:48 <lispy> hehe
01:11:54 <dolio> Manuel?
01:11:57 <lispy> Cale: Sorry, I mean, having it automated would make me happy :)
01:12:13 <lispy> I was reading what int-e wrote :)
01:12:23 <Cale> Yeah, it would make me happy too, except that already if I forget to @flush before killing lambdabot, everything messes up.
01:12:47 <int-e> lispy: (I understand that p belongs to a type class which allows the check to be done)
01:13:11 <lispy> int-e: hmm...my experience has been that I often times just need a witness that two phantoms are equal.  so I'm not sure how p a b -> p c d -> Maybe (p a b), helps.
01:13:17 <lispy> int-e: right
01:13:57 <lispy> int-e: when this comes up, it's the type checker I'm trying to satisfy
01:14:34 <dolio> p a b -> p c d -> Maybe (p a b) is the low-tech way of doing that.
01:14:49 <dolio> You coerce one value to the type of the other instead of proving that they're the same type.
01:15:35 <int-e> lispy: it should help with the problem that you can suddenly prove all types equal.
01:15:49 <lispy> Ah hmm...yes I see now.
01:17:16 <lispy> Not 100% satisfying as we'd have to remove some code that uses IsEq for filtering, and restructure some other things.  But I can think about it more.
01:18:11 <Saizan> > M.fromList []
01:18:12 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
01:18:23 <lispy> thanks guys
01:20:34 <int-e> lispy: p a b -> p c d -> IsEq (p a b) (p c d)  is equivalent, I think
01:23:10 <dolio> What kind of stuff is put in the phantom types in practice?
01:23:14 <int-e> err. EqCheck. but ... hmm, that also gives you p a b -> p c d -> EqCheck a b and p a b -> p c d -> EqCheck c d
01:23:34 <lispy> dolio: in my case?
01:23:50 <int-e> woops. EqCheck a c and EqCheck b d  of course.
01:23:52 <dolio> Does it vary widely?
01:24:00 <lispy> dolio: either (), or it gets wrapped up in a data type that uses an existentially quantified type variable
01:24:22 <dolio> Oh.
01:25:21 <lispy> We could replace () with something like, data Nil
01:25:40 <lispy> just that () exists already and we didn't yet see a reason to add a type
01:26:31 <dolio> That doesn't really matter. What you describe sounds like it destroys all hope of actually having values inform types within the stuff GHC implements.
01:27:09 <dolio> You can't even throw a type-rep in the patch.
01:27:18 <lispy> type-rep?
01:27:26 <int-e> @index TypeRep
01:27:27 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
01:27:39 <lispy> I think associated types might help here, but those didn't exist when we started
01:27:48 <dolio> data TypeRep a where TInt :: TypeRep Int ; ...
01:27:57 <int-e> dolio: yes, it all builds on the patches describing themselves sufficiently
01:28:05 <lispy> Oh, also I think typereps allow unsafeCoerce in the same way, see Oleg's example
01:28:27 <dolio> But you don't actually have a few types in mind that could be described that way.
01:28:47 <lispy> Now that we've sufficiently studied the prolem, I think we can avoid the trouble cases pretty easily with code audits, but it would be nice to remove it completely ya know.
01:29:09 <lispy> dolio: right, we have N types that only exist during compilation
01:29:32 <lispy> But, you can add class constraints to the GADT definitions we use.  That's how IsC was bored.
01:29:35 <lispy> er born
01:30:19 <dolio> Well, you don't actually have types at all.
01:30:44 <dolio> You have a place where a type would go, which GHC is forced to treat as all distinct.
01:31:05 <lispy> right
01:31:08 <dolio> And based on runtime data, you tell GHC to ignore the type mismatch.
01:31:09 <Saizan> don't you have to pick a type before wrapping it in a existential?
01:31:24 <dolio> Apparently not.
01:32:00 <quicksilver> .win 27
01:32:03 <quicksilver> ;-[
01:32:13 <lispy> Saizan: When you do, just pick something like ()
01:32:26 <lispy> Saizan: when you unwrappit, no one remembers anymore :)
01:32:45 <dolio> Well then, it's trivial. All your bs and cs are (). :)
01:32:50 <dolio> unsafeCoerce away!
01:33:22 <Saizan> Exist (undefined :: forall a. a) compiles, so you don't have to :)
01:34:58 <dolio> You would need to pick a type if you were storing a type-rep.
01:35:08 <Saizan> yeah, or a typeclass dictionary
01:35:16 <dolio> But that would defeat lispy's purpose, because he doesn't want to know what the type really is.
01:35:39 <lispy> dolio: well, the trouble spots are that you can reimplement unsafeCoerce from prooly defined functions assuming (=\/=) is available.  Which sucks because we wanted (=\/=) to be safe, and it's not.
01:36:11 <int-e> right, because anybody can construct new patches ... right?
01:36:20 <lispy> int-e: actually no
01:37:24 <lispy> provided you give me a definition of f, this funtion can do it:
01:37:25 <lispy> zipWithFL :: (forall r s u v x y. a r s -> b u v -> c x y)
01:37:25 <lispy>           -> FL a q z -> FL b j k -> Maybe (FL c m n)
01:37:25 <lispy> zipWithFL f (a :>: as) (b :>: bs) =
01:37:25 <lispy>   case zipWithFL f as bs of
01:37:27 <lispy>   Nothing -> Just (f a b :>: NilFL)
01:37:30 <lispy>   Just cs -> Just (f a b :>: cs)
01:37:32 <lispy> zipWithFL _ _ _ = Nothing
01:37:35 <lispy> (sorry!)
01:37:40 <dolio> Whoa.
01:38:00 <lispy> like the type sig?
01:38:47 <lispy> int-e: and I've accidentally defined a couple other variations that work
01:38:50 <dolio> It's something.
01:39:12 <quicksilver> f a b :>: (fromMaybe NilFL cs)
01:39:16 <quicksilver> would save you a couple of lines.
01:39:22 <dolio> I've always thought that [q,j,m] and [z,k,n] were logical groupings of letters.
01:40:08 <int-e> f _ _ = undefined. mmm
01:40:13 <lispy> quicksilver: oh, yeah, that's a good idea
01:40:36 <lispy> int-e: so, in my thesis, I cheat and use data P a b = P, f _ _ = P :)
01:40:50 <lispy> int-e: because I got too lazy to come up with a nice pedagocial f
01:41:32 <lispy> :t fromMaybe
01:41:33 <lambdabot> forall a. a -> Maybe a -> a
01:41:48 <int-e> ah. I totally missed that a b and c aren't quantified.
01:42:15 <lispy> Yeah, that type signature really sucks.
01:43:35 <lispy> But, the point is, it doesn't matter how f is defined as long as it does something besides return undefined
01:43:55 <lispy> actually, that doesn't even matter
01:44:07 <lispy> zipWithFL undefined NilFL NilFL
01:44:11 <lispy> That's what I use it as
01:45:02 <lispy> Hmm
01:45:09 <lispy> On second thought, that's not true.
01:45:10 <Saizan> doesn't that just gives you Nothing?
01:45:20 <dolio> And what does this have to do with (=\/=)?
01:45:52 <lispy> dolio: you call zipWithFL twice on the same input, but you can make the phantoms on the return type be whatever you want
01:46:01 <lispy> So then the result is equal right?
01:46:10 <lispy> So you use that to make the phantoms you returned equal
01:46:11 <int-e> dolio: =\/= is unsafe if you can construct a patch with arbitrary phantom markers
01:46:29 <lispy> But, as Saizan pointed out, I forget that in my example, I need to return more than Nothing
01:47:19 <lispy> zipWithFL f (P:>:NilFL) (P:>:NilFL) -- this should work
01:47:21 <int-e> dolio: (rather than patches where the phantom markers are actually () but the compiler doesn't know about that.)
01:48:09 <dolio> Right. So you can write malicious instances of whatever type class p is constrained by? That's the issue?
01:48:18 <dolio> Like you can write malicious Typeable instances.
01:48:46 <lispy> dolio: let me use hpaste this time and show you what unsafeCoerce looks like
01:49:04 <lispy> dolio: http://hpaste.org/10760
01:49:52 <dolio> Oh, I see.
01:50:38 <Saizan> the problem is IsEq
01:50:44 <lispy> exactly
01:51:26 <Saizan> how are you using IsEq when not trying to write coerce?
01:51:40 <Saizan> +unsafe
01:51:54 <lispy> Saizan: Heh, i've kinda forgotten...let's see
01:52:14 <lispy> Saizan: you might use it to check if a sequence of patches really is an identity transformation
01:52:28 <lispy> Saizan: that's pretty useful
01:52:56 <Saizan> so you still use it for things inside FL ?
01:54:27 <lispy> Saizan: what do you mean?
01:54:46 <int-e> ./Darcs/Patch/Permutations.lhs:instance (MyEq p, Commute p) => MyEq (FL p) where
01:54:48 <lispy> Saizan: we can filter elements out of an FL safely using an identity check, if that's what you mean
01:54:54 <int-e> (MyEq defines =\/=)
01:55:56 <lispy> It really isn't used much
01:56:24 <Saizan> i just wonder if you can get away with something like cast, rather than an equality witness
01:58:08 <int-e> lispy: so you had a MyEq instance of P?
01:58:15 * int-e wonders
01:58:17 <hackage> Uploaded to hackage: synthesizer 0.0.3
01:58:47 <lispy> int-e: well, in my thesis, I don't bother defining =\/= interms of a type class, just to keep thing simple
01:59:02 <lispy> int-e: I just defined =\/= with P in the signature
01:59:36 <lispy> oh but I used a type variale
01:59:38 <lispy> variable*
01:59:51 <dolio> It's not really IsEq that's the problem.
02:00:09 <int-e> it's constructing new patches
02:00:11 <lispy> oh, but heh, this example wouldn't compile as is...
02:00:34 <lispy> It's anything with constrained phantoms + =\/=
02:00:34 <dolio> It's that the phantom type is supposed to be a type-level analogue of the data, but you can associate arbitrary data with arbitrary phantom types.
02:00:50 <lispy> er unconstrained phantmos
02:02:26 <lispy> You need both things, the subtly hidden unsafeCoerce in (=\/=) and the phantoms that can unify with whatever.  Once you have that combo you're unsound.
02:02:35 <dolio> (And the place where you unsafe coerce assumes that the phantom is a genuine analogue of the data, not just a made-up association.)
02:03:32 <lispy> ?localtime lispy
02:03:36 <lambdabot> Local time for lispy is Mon Sep 29 02:02:12 2008
02:03:53 <lispy> Thanks guys, It's been a good and productive chat but I must sleep
02:04:16 <dolio> lispy: Rewrite darcs in coq. :)
02:04:26 <dolio> Problem solved.
02:04:34 <lispy> I've found 2-3 bugs in my code samples, and you've helped me exhaust the alternatives
02:04:42 <lispy> dolio: I've suggested this :)
02:04:52 <lispy> but fewer people know coq than haskell :)
02:09:43 <Lord_Illidan> Hi, can anyone help with this. I want to convert strings to ints
02:09:55 <Lord_Illidan> I know I can do it with the read::Int function
02:10:06 <Lord_Illidan> But can I use it with map?
02:10:37 <dolio> Do you have a sample string and what you want out of it?
02:10:39 <Lord_Illidan> Say I have a list ["95","14","32"], how do I convert them to a list of ints?
02:10:39 <BeelsebobWork> > map (read :: String -> Int) ["5", "10", "20", "249857"]
02:10:41 <lambdabot>   [5,10,20,249857]
02:10:48 <Lord_Illidan> ah, I forgot how to use that command
02:11:15 <Cale> > map read ["95","14","32"] :: [Int]
02:11:16 <lambdabot>   [95,14,32]
02:11:20 <BeelsebobWork> > (map read ["5","10","20"]
02:11:21 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
02:11:21 <lambdabot>  ...
02:11:22 <BeelsebobWork> fail
02:11:36 <BeelsebobWork> that was meant to be the delete key, because cale said it already
02:11:44 <quicksilver> it was the fail key!
02:12:17 <Lord_Illidan> aye, it works for me
02:12:52 <Lord_Illidan> How does this work, though, is it a form of overloading?
02:13:11 <Lord_Illidan> Why does map (read::Int) ... doesn't work?
02:13:22 <EvilTerran> ?type read
02:13:22 <lambdabot> forall a. (Read a) => String -> a
02:13:25 <quicksilver> read doesn't have the type Int.
02:13:30 <quicksilver> it can have the type String -> Int
02:13:37 <EvilTerran> > map (read :: String -> Int) ["123","456","789"]
02:13:38 <lambdabot>   [123,456,789]
02:13:40 <quicksilver> read is a function, it is not an integer.
02:13:47 <Lord_Illidan> of course
02:13:50 <EvilTerran> > map read ["123","456","789"] :: [Int]
02:13:51 <Lord_Illidan> so when you have this : read "12"::Int
02:13:51 <lambdabot>   [123,456,789]
02:14:04 <EvilTerran> > map (\x -> read x :: Int) ["123","456","789"]
02:14:04 <quicksilver> the ::Int is applying to the whole expression
02:14:05 <lambdabot>   [123,456,789]
02:14:10 <quicksilver> (read "12") :: Int
02:14:14 <quicksilver> because 12 is an integer.
02:14:30 <EvilTerran> :: is ultra-low precedence
02:14:34 <Lord_Illidan> What I was thinking is that map would plug every string in the list into read::Int
02:14:59 <BeelsebobWork> yes, that is what you wrote
02:15:00 <quicksilver> well yes what you say is roughly right
02:15:03 <BeelsebobWork> but read doesn't have that type
02:15:07 <quicksilver> except that 'read::Int' is rubbish
02:15:10 <BeelsebobWork> so instead, it says "that's a type error"
02:15:35 <EvilTerran> everything on the left of a :: gets grabbed by it, up to any control structure (if/then/else, case/of, or \ ... ->)
02:15:47 <BeelsebobWork> read has type String -> <insert type here> for any type which has a Read instance
02:16:57 <Lord_Illidan> I see
02:17:15 <Lord_Illidan> thanks, of course read::Int on it's own doesn't mean anything
02:17:22 <BeelsebobWork> well it does mean something
02:17:32 <BeelsebobWork> it means "program that produces a type error when compiled"
02:18:17 <EvilTerran> even if Int was a valid type to read, you wouldn't be able to use (read::Int) as the first parameter to map
02:18:18 <EvilTerran> ?type map
02:18:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:18:30 <EvilTerran> because the first parameter has to be a function
02:18:52 <EvilTerran> and functions have a -> in the type
02:19:09 <Lord_Illidan> I see
02:20:23 <BeelsebobWork> > (map read :: [String] -> [Int]) ["12", "8976", "373"] -- just for completeness sake
02:20:24 <lambdabot>   [12,8976,373]
02:20:39 <xsdnyd> i always wondered what the forall keyword in haskell means
02:22:04 <Lord_Illidan> Another stupid question, say you have this : [["75"],["95","64"],["17","47","82"]], does this count as a [String] or as a [[String]]?
02:22:23 <BeelsebobWork> that's a list of lists of strings
02:22:26 <BeelsebobWork> so [[String]]
02:22:44 <Zao> As lists are homogeneous, you only need to look at the first element to determine the type.
02:23:21 <quicksilver> Zao: unless the first element is [] ;) ... or other expression which can take multiple types.
02:23:24 <Lord_Illidan> right, but haskell is identifying it as [string]
02:23:35 <quicksilver> :t [["75"],["95","64"],["17","47","82"]]
02:23:36 <lambdabot> [[[Char]]]
02:23:47 <quicksilver> Lord_Illidan: my haskell certainly doesn't identify that as [String]
02:23:54 <quicksilver> Lord_Illidan: I don't believe yours does, either.
02:24:08 <Lord_Illidan> let me start from scratch
02:24:41 <Lord_Illidan> I have a function that's supposed to read a String of numbers and split them up
02:25:12 <Lord_Illidan> split "290 201 301 210" = ["290","201","301","210"]
02:25:30 <Lord_Illidan> ah forget it
02:25:36 <ivanm> split == words?
02:25:47 <Lord_Illidan> ivanm, ?
02:26:02 <ivanm> > words "290 201 310 210"
02:26:03 <lambdabot>   ["290","201","310","210"]
02:26:04 <Lord_Illidan> I was working on this last night, woke up to it this morning, and forgot I was applying map
02:26:22 * ivanm just started reading
02:26:23 <Lord_Illidan> damn, I never thought about using words
02:26:32 <ivanm> but that matches what you said you wanted... ;-)
02:26:35 <BeelsebobWork> > unwords  ["290","201","310","210"]
02:26:35 <Lord_Illidan> *smacks head*
02:26:36 <lambdabot>   "290 201 310 210"
02:26:43 <Lord_Illidan> I want to cry now
02:26:50 * ivanm passes Lord_Illidan a tissue
02:27:07 <Lord_Illidan> @src words
02:27:07 <lambdabot> words s = case dropWhile isSpace s of
02:27:07 <lambdabot>     "" -> []
02:27:07 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
02:28:12 <Zao> quicksilver: Oh well, first non-pathological element then :)
02:28:41 <EvilTerran> Lord_Illidan, don't worry, pain is weakness leaving the body. you are now (a) stronger (haskell programmer) :)
02:29:18 * Twey grins.
02:29:53 <FlamingCows> @pl (\ a b c -> map c b a )
02:29:53 <lambdabot> flip (flip . flip map)
02:31:12 <Lord_Illidan> Ok, it's working now
02:31:17 * Lord_Illidan kisses everybody
02:31:32 * BeelsebobWork organises a 25 man raid
02:32:16 <Lord_Illidan> You are not prepared!
02:32:17 <Twey> http://hpaste.org/10761 -- is there any way I can get around the monomorphism restriction here, preferably without having to manually specify types that include 'System.Glib.Types.GObject'?
02:32:21 <Cthulhon> :t flip (flip . flip map)
02:32:21 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[b1]'
02:32:22 <lambdabot>     Probable cause: `flip' is applied to too many arguments
02:32:22 <lambdabot>     In the second argument of `(.)', namely `flip map'
02:33:13 <BeelsebobWork> Twey: {-# LANGUAGE NoMonomorphismRestriction #-} ?
02:33:30 <Twey> BeelsebobWork: Yeah, I'm doing that right now... I was thinking any *other* way :-P
02:33:41 <EvilTerran> Twey, what type is xmlGetWidget?
02:33:58 <Twey> EvilTerran: xmlGetWidget :: (Graphics.UI.Gtk.Types.WidgetClass widget) => GladeXML -> (System.Glib.Types.GObject -> widget) -> String -> IO widget
02:34:17 <EvilTerran> let getter f = xmlGetWidget xml f
02:34:22 <Twey> If I include that into my code, I lose all the lovely clarity :-\
02:34:23 <Twey> Oooh
02:34:28 <Twey> Wonderful!
02:34:33 <EvilTerran> :D
02:34:41 <quicksilver> Twey: just turn off the monomorphism restriction? :)
02:34:55 <EvilTerran> hooray for the DMR breaking eta reduction! =/
02:35:13 <Twey> EvilTerran: <3
02:35:14 <retybok> can someone explain what this line in the xmonad source means? I can't even parse it..        XState { windowset = sset } <- get
02:35:18 <EvilTerran> :3
02:35:28 <EvilTerran> retybok, have you met record syntax before?
02:35:39 <retybok> EvilTerran: not really
02:35:54 <BeelsebobWork> retybok: it's a pattern match -- it binds XState to the result of get
02:36:01 <BeelsebobWork> or rather *an* XState
02:36:10 <BeelsebobWork> and pulls the windowset out of it in the variable sset
02:36:30 <retybok> I find the "=" notation very weird
02:36:45 <retybok> i doesn't look like the usual pattern matching
02:37:00 <BeelsebobWork> indeed, record notation needs to be stabbed repeatedly until it bleeds to death
02:37:10 <retybok> mmm
02:37:17 <retybok> would you have a link explaining it?
02:37:44 <osfameron> I thought that notation was for updating a record?
02:37:49 <BeelsebobWork> http://research.microsoft.com/~simonpj/Haskell/records.html
02:37:54 <retybok> thanks
02:37:56 <BeelsebobWork> it is, it's also for pattern matching on them though
02:38:04 <osfameron> ah, that's handy ;-)
02:39:05 <retybok> why isn't it written XState { sset = windowset } ? That would make more sense to me
02:39:15 <BeelsebobWork> retybok: yep, it would make more sense to me too
02:39:21 <quicksilver> well it's declarative
02:39:24 <quicksilver> not imperative :P
02:39:51 <BeelsebobWork> yes, and in this declarative language we bind variables by doing <variable> = <term>
02:39:53 <quicksilver> it's just that way for consistency with other uses of it.
02:39:54 <xsdnyd> can anybody give me a link which explains the "@" syntax of haskell?
02:40:01 <BeelsebobWork> so it would still make sense to put sset = something
02:40:06 <retybok> quicksilver: by that logic you would write "x*x = square x"
02:40:06 <Twey> No
02:40:10 <Twey> Because it's the term we want
02:40:12 <xsdnyd> its hard to google such small character ;)
02:40:17 <quicksilver> retybok: no, I'm not applying that logic.
02:40:24 <quicksilver> xsdnyd: it's in the report
02:40:34 <BeelsebobWork> xsdnyd: not sure about the link, but it allows you to bind a variable to a structure you want to pull appart
02:40:35 <quicksilver> retybok: I'm just rejecting the other logic.
02:40:55 <xsdnyd> quicksilver: you mean this: http://www.haskell.org/onlinereport/
02:40:58 <xsdnyd> ?
02:41:01 <lambdabot> Title: The Haskell 98 Language Report
02:41:03 <BeelsebobWork> > let x@(Just y) = Just 5 in print x >> print y
02:41:04 <lambdabot>   * Exception: "<IO ()>"
02:41:07 <BeelsebobWork> oops
02:41:07 <Twey> retybok: It's similar to: [foo] = [5] to bind 'foo' to 5
02:41:17 <BeelsebobWork> > let x@(Just y) = Just 5 in show x ++ " " ++ show y
02:41:19 <lambdabot>   "Just 5 5"
02:41:23 <retybok> xsdnyd: it's refered to as the as-notation (I think)
02:41:26 <Twey> retybok: The variable name just goes in the place of the value you want
02:41:30 <EvilTerran> xsdnyd, http://haskell.org/onlinereport/exps.html describes them as "as-patterns"
02:41:31 <lambdabot> Title: The Haskell 98 Report: Expressions
02:41:35 <xsdnyd> ok thanks :)!!
02:42:33 <EvilTerran> > let x@y@(Just z) = Just 5 in (x,y,z)
02:42:34 <lambdabot>   (Just 5,Just 5,5)
02:42:52 <xsdnyd> ah as-patterns make much sense :)
02:43:27 <EvilTerran> it's purely a convenience thing
02:43:37 <BeelsebobWork> it is?
02:43:38 <Twey> Well...
02:43:47 <BeelsebobWork> it allows for more sharing doesn't it?
02:43:47 <Twey> There may be some work saved there
02:43:51 * Twey nods.
02:44:00 <dolio> It can conceivably make a tiny performance difference.
02:44:10 <EvilTerran> "foo x@(<pat>) = <exp>" would be the same as "foo x = let { <pat> = x } in <exp>"
02:44:18 <dolio> Although -O catches stuff like that in simple cases, at least.
02:44:26 <EvilTerran> including sharing, i think
02:44:30 <BeelsebobWork> EvilTerran: ah, yeh
02:44:32 <BeelsebobWork> fair doos
02:44:42 <retybok> what does the pattern matching expression above become if you have two cases of patterns to match?
02:44:44 <EvilTerran> that may even be the desugaring discussed in the report, i forget
02:44:52 <Twey> `f s@[x, y] = x : y : s` could theoretically be faster than `f [x, y] = x : y : x : [y]` because it doesn't involve reconstructing the list
02:45:03 <BeelsebobWork> retybok: not sure what you mean by that -- can you give an example?
02:45:11 <retybok>        XState { windowset = sset } <- get
02:45:15 <dolio> foo x@(<pat>) = <exp> is not the same as foo x = let { <pat> = x} in <exp>
02:45:29 <EvilTerran> dolio, ah, yes, fallthrough
02:45:35 <retybok> suppose the type corresponding to XState has two constuctors
02:45:40 <dolio> Right.
02:45:53 <EvilTerran> it'd be the same as "foo x | <pat> <- x = <exp>" :P
02:45:58 <BeelsebobWork> retybok: XState { windowset = sset, jamset = monkies} <- get
02:46:02 <dolio> Heh.
02:46:14 <retybok> I don't know, usually pattern matching is used to distiguish between different cases
02:46:22 <dolio> Well, it's more like 'foo x = case x of pat -> <exp> ...' where you fill in the other function cases.
02:46:53 <BeelsebobWork> retybok: I don't think that's true -- it gets used to distinguish between cases in a sum type, and to pull apart a product type
02:47:11 <dolio> > let f x@(Just y) = x in f Nothing
02:47:12 <lambdabot>   * Exception: /tmp/3743748898159330916:68:36-51: Non-exhaustive patterns in ...
02:47:20 <BeelsebobWork> this is a product type, so it's being used to pull it appart
02:47:21 <xsdnyd> is it really bad style if i use let x = ... without an "in" in a do-expression?
02:47:21 <retybok> ok
02:47:26 <dolio> > let f x = let Just y = x in x in f Nothing
02:47:27 <lambdabot>   Nothing
02:47:46 <BeelsebobWork> xsdnyd: I'd regard it as really bad style if you use a do expression :P
02:47:46 <retybok> you mean product in the sense of cartesian product and sum in the sense of "or", right?
02:47:47 <sjanssen> xsdnyd: nope, that style is used rather frequently
02:47:53 <EvilTerran> retybok, given "data Foo = Bar { bar :: Int } | Baz { baz, eek :: Int }", you could have "f (Bar { bar = x }) = ...; f (Baz {baz = x, eek = y}) = ..."
02:47:55 <BeelsebobWork> retybok: yes
02:48:03 <xsdnyd> sjanssen: ok, that good ;)
02:48:10 <retybok> EvilTerran: thank you
02:48:20 <xsdnyd> BeelsebobWork: I sadly have to use a do-expression :(
02:48:32 <BeelsebobWork> xsdnyd: you do? are you sure?
02:48:49 <EvilTerran> xsdnyd, it's considered better style to write "do ...; let ...; ..." than "do ...; let ... in do ..."
02:48:56 <retybok> EvilTerran: but in your example, I couldn't use the <- syntax with the pattern matching, right?
02:49:03 <EvilTerran> that's why the syntactic sugar is there
02:49:14 <Twey> That's because it involves huge chunks of needlessly indented code.
02:49:39 <EvilTerran> retybok, indeed not, <- doesn't do case analysis. that's a separate issue to whether or not you're using records
02:49:41 <electronx> just wandering do people find haskell really hard to learn?
02:49:45 <xsdnyd> EvilTerran: i do it the first way you mentioned :)
02:49:47 <Twey> electronx: Nah
02:49:53 <BeelsebobWork> electronx: no -- but I did find other languages hard to unlearn
02:49:58 <xsdnyd> BeelsebobWork: yep, i have to. doing some IO stuff
02:50:02 <Twey> Not *really* hard to learn.  There were a couple of bumps.
02:50:10 <retybok> EvilTerran: so in that case, you'd do temp <- get and pass temp to a function doing the case analysis, right?
02:50:12 <BeelsebobWork> xsdnyd: yeh, are you sure you need to do IO stuff?
02:50:20 <electronx> i've done alot of programming and i find there is just soooo much to learn and get your head around
02:50:35 <xsdnyd> BeelsebobWork: yes. writing files etc.
02:50:50 <BeelsebobWork> electronx: Haskell is the martial arts of programming -- you need to unlearn everything else before you can fully learn and appreciate its beauty
02:50:52 <electronx> constantly reading phd papers to find new techniques for haskell
02:51:03 <retybok> electronx: yes it's hard. I took me a long time to start understanding, but once you get it, it's quite cool. So keep trying :)
02:51:04 <EvilTerran> retybok, indeed. if you consider, for instance, the function "ifM :: Monad m => m Bool -> a -> a -> a"
02:51:23 <retybok> EvilTerran: thanks again
02:51:28 <EvilTerran> retybok, you could define that as "ifM p t f = do p' <- p; if p then t else f"
02:51:39 <EvilTerran> because you can't case-analyse in the <-, you have to do it afterwards
02:51:48 <electronx> retybok: the basic haskell is easy to learn but the more advanced stuff like monad transformers etc is much much harder
02:52:20 <BeelsebobWork> electronx: otoh, in a good long time of writing Haskell, I've never had need to use a monad transformer
02:52:29 <retybok> electronx: I don't think you have to learn it all at once, though
02:52:36 <electronx> lol
02:52:41 <electronx> thats how i learn langs
02:52:46 <retybok> I think you can learn this stuff as you program
02:52:49 <electronx> learn the whole thing then programme
02:52:56 <EvilTerran> yeah, pick bits up as you need them. it's easier.
02:53:07 <retybok> I try to read code written by experimented coders
02:53:31 <EvilTerran> electronx, well, some bits and pieces of "haskell as she is written" are kinda experimental and bordering on the highly arcane
02:54:06 <electronx> EvilTerran: i'm learning the stuff in real world hasekell book
02:54:18 <EvilTerran> electronx, and even in the non-experimental stuff, some of the more complicated things will only really make sense if you're familiar with the simple stuff
02:55:02 <xsdnyd> what do you guys think about this: i have a lot of case expressions with Maybe's. I am thinking about using "shortCase :: Maybe a -> b -> (a -> b) -> b" which takes the Maybe value, a value for the Nothing case and a function for the Just case. This way i could rewrite the case expression as one-liners. Does it make sense to use this function? Or is it bad style or something like that?
02:55:04 <electronx> haskell is a big hill to climb
02:55:22 <EvilTerran> it helps to understand typeclasses before you try to understand monads, for instance
02:55:32 <electronx> monads are easy
02:55:38 <sjanssen> xsdnyd: congratulations, you've just re-invented Prelude.maybe!
02:55:41 <EvilTerran> well, that's a first
02:55:47 <sjanssen> @type maybe
02:55:48 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:55:49 <EvilTerran> no-one thinks monads are easy <.<  >.>
02:55:52 <electronx> its the more advanced stuff that i don't like
02:56:01 <EvilTerran> such as?
02:56:09 <xsdnyd> sjanssen: omg
02:56:11 <xsdnyd> :D
02:56:20 <electronx> monad transformers and array fusion
02:56:29 <Eridius> xsdnyd: whenever you think "gee, a simple function like this would be extremely useful", it's probably already in the libraries
02:56:29 <EvilTerran> you don't need to know those to be a useful haskell programmer
02:56:54 <xsdnyd> Eridius: ok, good to know ;)
02:56:56 <EvilTerran> array fusion in particular. i don't even know what that is, and i've been programming almost exclusively in haskell for the best part of 2yr.
02:56:57 <electronx> EvilTerran: peformance is critical for me
02:57:15 <sjanssen> fusion is overrated
02:57:18 <Eridius> EvilTerran: almost exclusively? lucky bastard
02:57:19 <electronx> EvilTerran: i'm thinking there is something that i don
02:57:22 <BeelsebobWork> Eridius: I have found one instance where I don't think the function I wanted was in the library -- satisfiesM p x = x >>= liftA3 if' p return (const (satisfiesM p x))
02:57:28 * Eridius would love a job that lets him use neat languages like Haskell
02:57:38 <electronx> i don't know that may help my code
02:57:38 <Twey> Eridius: Start a company
02:57:39 <EvilTerran> Eridius, i'm a student, it's not like i'm being paid for it :P
02:57:48 <Eridius> BeelsebobWork: it might help if I understand Control.Applicative
02:57:49 <Eridius> EvilTerran: oh
02:57:55 <Twey> Or hire yourself out
02:57:57 <sjanssen> BeelsebobWork: if' is another function missing from the libraries
02:58:01 <electronx> EvilTerran: what do you use haskell for?
02:58:03 <Twey> Often they don't care what language you use so long as it gets done :)
02:58:03 <BeelsebobWork> Eridius: liftA3 == liftM3 == fmap
02:58:09 <BeelsebobWork> sjanssen: oh yeh, I forgot that it's missing
02:58:11 <Eridius> o_O
02:58:12 <BeelsebobWork> I use it so much
02:58:14 <EvilTerran> BeelsebobWork, shurely not fmap?
02:58:17 <hackage> Uploaded to hackage: haskore-synthesizer 0.0.2
02:58:18 <Eridius> what's if'
02:58:18 <BeelsebobWork> well no, not quite
02:58:19 <BeelsebobWork> sorry
02:58:26 <EvilTerran> liftA = liftM = fmap = (<$>)
02:58:31 <BeelsebobWork> Eridius: if' x y z = if x then y else z
02:59:02 <EvilTerran> electronx, well, my uni taught us it in the first term of first year, and i've been using it as my general hacking language ever since
02:59:31 <electronx> EvilTerran: perhaps for simple hacking not the bare haskell maybe enough
02:59:32 <EvilTerran> i've thrown together programs for scraping sites for links, that kinda thing
02:59:38 <BeelsebobWork> Eridius: unfolded, liftA3 if' == \c t e p -> if c p then t p else e p
03:00:17 <Eridius> BeelsebobWork: ah
03:00:20 <EvilTerran> electronx, to be quite honest, i don't think it's possible for someone to know everything there is to know about haskell
03:00:21 <electronx> EvilTerran: my project in haskell already has 5-6k lines of haskell
03:00:43 <EvilTerran> "haskell-related clever stuff" is an ever-expanding field
03:00:45 <BeelsebobWork> Eridius: satisfiesM keeps doing a monadic action until its output looks like you want it to
03:01:07 <electronx> EvilTerran: perhaps your right no mere mortal can know all of haskell :)
03:01:18 <EvilTerran> so i find the only way of retaining my sanity is to learn things as i need them
03:01:30 <Eridius> oh durr, I was trying to figure out what the purpose of (const (satisfies p x)) was, because it looked like it would just repeat indefinitely. I forgot it could do side effects if it's in the IO monad ;)
03:01:50 <electronx> EvilTerran: thats one thing i don't like its sometimes too damn complex
03:01:51 <EvilTerran> or learn things as they strike me as being within my grasp and looking interesting
03:01:54 <BeelsebobWork> I think what a lot of people forget when learning Haskell, is just how long it took before they knew all of C, let alone before they knew all of C++
03:02:02 <EvilTerran> ignore the complex stuff 'til you need it
03:02:09 <EvilTerran> when you get there, it might not look that complex any more
03:02:11 <Eridius> BeelsebobWork: naw, they just remember that it didn't hurt their brain to learn other languages
03:02:30 <electronx> Eridius: :) probably
03:02:31 <BeelsebobWork> Eridius: it didn't?  I've not met anyone who didn't go through a lot of brain hurting with their first language
03:02:45 <EvilTerran> Eridius, yeah, it just hurt their brain to use them once they'd learnt them :P
03:02:52 <Eridius> hah
03:03:07 <Eridius> BeelsebobWork: most imperative languages work the way people work. Not much brain-hurting there
03:03:16 <BeelsebobWork> Eridius: I don't think that's true at all
03:03:20 <EvilTerran> imperative languages work the way computers work
03:03:29 <EvilTerran> haskell works the way mathematicians work
03:03:41 <EvilTerran> only natural language works the way people work :P
03:03:45 <electronx> EvilTerran: i'm not that good at math
03:03:47 <BeelsebobWork> my wife is currently learning Haskell having never had experience of an imperative language, she's not finding that it works differently to her
03:04:01 <EvilTerran> then you're DOOOOOOOOOOOOOOMED *thunderclap* *evil laugh*
03:04:04 <EvilTerran> ;)
03:04:08 <BeelsebobWork> I think the only people that it works in a different way to is people who have been *trained* to think imperatively
03:04:24 <Cale> I think that people naturally think with something which is close to higher order functions in nature :)
03:04:29 <smtms> BeelsebobWork, what uses of Haskell does your wife have?
03:04:52 <EvilTerran> comlab.ox.ac.uk agree with BeelsebobWork - they teach haskell first, and actively discourage you from learning any programming before you arrive
03:04:53 <BeelsebobWork> smtms: she wondered what I did at work all day, and wanted to learn something new and shiny
03:04:54 <electronx> EvilTerran: seriously?
03:05:05 <EvilTerran> electronx, the "doomed" thing was a joke :P
03:05:12 <electronx> hehe
03:05:29 <EvilTerran> well, except insofar as we're all doomed. but that has nothing to do with our maths competence. =/
03:06:19 <electronx> question is sorting an array in haskell just as slow as sorting a list?
03:06:31 <BeelsebobWork> electronx: depends how you sort it :P
03:06:32 <EvilTerran> that depends on how you do it
03:06:40 <EvilTerran> both are O(n.log n)
03:06:42 <electronx> or can it be sped up using monads?
03:06:43 <Cale> electronx: Sorting a list can be done in O(n log n) time.
03:06:47 <EvilTerran> monads don't come into it
03:06:50 <BeelsebobWork> electronx: monads don't speed things up
03:06:58 <BeelsebobWork> they just sequentialise things
03:07:01 <EvilTerran> BeelsebobWork, well, apart from programmers who grok them :P
03:07:04 <electronx> well how will swap work?
03:07:09 <BeelsebobWork> EvilTerran: possibly true, yes
03:07:16 <EvilTerran> electronx, you seem to be thinking very imperatively
03:07:17 <Cale> swap on immutable arrays would be pretty slow :)
03:07:18 <electronx> no side affects in haskell
03:07:45 <electronx> so it will be no where near as fast a a c qsort
03:07:48 <Cale> So if you want to base your sorting algorithm on explicitly swapping pairs of elements over and over, then your array sort will be very slow.
03:08:08 <Cale> (Assuming you're using immutable, rather than mutable arrays)
03:08:13 <Cale> (Haskell has both)
03:08:19 <electronx> Cale: ya immutable prob
03:08:25 <EvilTerran> if you base it on shoving everything into a Data.Map and pulling it out again in the right order, it'll be comparable speed to doing the same to a list
03:08:27 <electronx> since mutable will be IO?
03:08:44 <Cale> mutable would be in IO or ST
03:08:55 <electronx> ok
03:08:59 <EvilTerran> ?type (A.!)
03:09:00 <lambdabot> Couldn't find qualified module.
03:09:04 <electronx> thanks
03:09:06 <electronx> i gtg
03:09:07 <EvilTerran> ?type (Data.Array.!)
03:09:08 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
03:09:10 <EvilTerran> aha
03:10:39 <xsdnyd> mhh
03:10:43 <xsdnyd> i have a problem with maybe
03:10:45 <xsdnyd> x = Just "cool"; maybe "not cool" () x
03:10:59 <xsdnyd> if x is Just s i want it to just return s
03:11:08 <xsdnyd> this is why i use "()"
03:11:16 <EvilTerran> ?type ()
03:11:17 <lambdabot> ()
03:11:21 <EvilTerran> xsdnyd, why () ?
03:11:24 <EvilTerran> ?type maybe
03:11:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:11:41 <xsdnyd> mhh
03:11:46 <EvilTerran> xsdnyd, (x :: Maybe String), so a = String in that type
03:11:59 <EvilTerran> the first parameter is a String too, so b = String too
03:12:02 <xsdnyd> should i use: (\x -> x)?
03:12:12 <EvilTerran> so you're using maybe :: String -> (String -> String) -> Maybe String -> String
03:12:21 <EvilTerran> ?pl \x -> x
03:12:22 <lambdabot> id
03:12:25 <EvilTerran> ?src id
03:12:25 <lambdabot> id x = x
03:12:39 <xsdnyd> ok cool
03:12:42 <xsdnyd> with id it works :)
03:12:53 <xsdnyd> thx
03:13:38 <EvilTerran> ?src fromMaybe
03:13:38 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
03:13:45 <EvilTerran> ?index fromMaybe
03:13:45 <lambdabot> Data.Maybe
03:14:06 <xsdnyd> thats even cooler
03:14:22 <EvilTerran> fromMaybe e x = maybe e id x
03:14:52 <xsdnyd> EvilTerran: hx
03:14:54 <xsdnyd> thc
03:14:55 <xsdnyd> thx
03:15:01 <EvilTerran> thc? <.<  >.>
03:15:26 <EvilTerran> np :)
03:44:19 <rog_> hi, is there any way i can use type-dynamic or existential types to partially match against a dynamic type (e.g. given toDynamic [1,2,3], that some other code could match this against the type [a])?
03:45:04 <rog_> or is this kind of operation fundamentally problematic in haskell?
03:45:41 <earthy> well, yes and no
03:46:24 <earthy> [a] is fundamentally unscrutable, as you have *no* information and therefore no operations on a
03:46:31 <earthy> (the values of type a)
03:46:56 <rog_> but i can manipulate it as a list, which is all i need for quite a few operations
03:47:09 <earthy> however, Typeable a => [a]  does give you your type matching operations.
03:48:14 <rog_> or (and the example i started with) if i've got (toDynamic x) where x is an instance of Show, can i call (show x) without knowing the original type of x?
03:48:54 * earthy doesn't understand that question
03:49:20 <earthy> x is a value of a type X that has an instance of Show, so yes, ofcourse, you can call show x
03:49:37 <earthy> however, this does not hold for  show (toDyn x)
03:50:07 <earthy> then again, it does hold for   show (fromDynamic . toDyn $ x)
03:50:27 <rog_> ok. that's what i'd like to do!
03:50:44 <earthy> since from a Dynamic you can recover the original type.
03:50:52 <earthy> if you know that original type!
03:51:30 <rog_> but unfortunately i don't know the specifics of the original type, just that it was an instance of Show...
03:51:40 <earthy> rog_: that's not a problem
03:52:13 <earthy> as long as you can force the result type of the fromDynamic to be Maybe X if the original type was X
03:52:43 <earthy> i.e. as long as you can force the result type of fromDynamic to be the same as the original type, the exact type does not matter
03:52:44 <rog_> so i tried: 		let Just v = (fromDynamic d) :: Maybe (forall a. Show a => a)
03:53:35 <rog_> ... but if you don't know the exact type, how can you force the result type to be the original type?
03:54:02 <rog_> ... and i got "Cannot match a monotype with `forall a. (Show a) => a'"
03:54:07 * earthy nods
03:54:45 <rog_> i'm not entirely sure of the definition of a monotype.
03:54:46 <earthy> suppose I have two elements of a list, what type do they have?
03:55:05 <rog_> the same as each other
03:55:19 <earthy> exactly. and that is how you can force two things to have identical type
03:56:08 <rog_> but say i've got a list of Dynamic?
03:56:30 <earthy> you've managed to create that list somehow, right?
03:57:06 <rog_> yes (in several different places, each element with a potentially different original type)
03:57:34 <rog_> (although i've ensured that each of the original types is an instance of Show)
03:57:40 <earthy> ahhhh... I think I see what you want to do
03:58:02 <earthy> why do you use Dynamic and not HList?
03:58:04 <rog_> in fact i haven't got a list, i've got an expression tree, and i'm building a little interpreter
03:58:22 <rog_> i'll have to google for HList.
03:58:27 <earthy> http://homepages.cwi.nl/~ralf/HList/
03:58:30 <lambdabot> Title: Strongly typed heterogeneous collections
03:58:58 <earthy> going to Dynamic is trying to circumvent the type system. that is usually the wrong path in Haskell
03:59:10 <earthy> try letting the type system help you
04:00:18 <rog_> the thing is that the types in my case really are only known at runtime, because they're generated in response to the interpretation of a language.
04:01:17 <rog_> the easiest way to go would be to have a data declaration that contains all the possible forms of value that i can have. i was just hoping i could be a little more modular than that.
04:02:03 <earthy> uhm, what is not modular about that?
04:02:15 <earthy> you *need* that information, and you have a nice place where to gather it
04:02:29 <earthy> and the compiler informs you when you haven't taken the possibilities into account
04:03:14 <earthy> (but yeah, I think I can see where you're headed, and your answer is 'Attribute Grammar', http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem)
04:03:46 <Philippa_> earthy: I would've thought an existential was most appropriate here?
04:04:26 <earthy> philippa: he's writing an interpreter for a tree... and wants to extend both the tree's definition and the functions performed on it
04:04:35 <earthy> sounds like attribute grammar to me.
04:04:46 <rog_> i think i was hoping to leverage the haskell type system directly, so that, for instance, a value in the interpreted language that had functional type was actually represented by a haskell function of isomorphic (?) type.
04:05:09 <earthy> good idea
04:05:36 <earthy> however, you then lose inspection...
04:05:42 <earthy> which you'll have to work hard to recover
04:06:28 <earthy> explicitly specifying the structure as a datatype and then writing the interpretation as a seperate catamorphism is much easier
04:06:29 <rog_> i was planning on keeping a separate data structure detailing the type of the expression, which has a simple algebra, and enables inspection.
04:06:51 <rog_> catamorphism?
04:06:55 <earthy> 'fold'
04:07:59 * rog_ is reading about attribute grammars...
04:11:12 <Cale> @remember Twey The problem with Java is the rigid language design that requires you to write out all your types explicitly and implement FooFactoryFactoryFactoryFactories in order to get around type requirements
04:11:13 <lambdabot> Good to know.
04:11:23 <plutonas> is there some function like repeat 5 'a' -> "aaaaa" ?
04:11:26 <plutonas> or should i define it?
04:11:29 <Cale> plutonas: replicate
04:11:33 <plutonas> thanks
04:11:34 <Twey> Hahaha
04:12:03 * rog_ realises that he has a vague recollection of attribute grammars from the dragon book. dim memories.
04:15:00 <Eridius> @pl do x <- arbitrary; y <- arbitrary; return (Concat x y)
04:15:01 <lambdabot> (line 1, column 18):
04:15:01 <lambdabot> unexpected ";"
04:15:01 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
04:15:06 <Eridius> damn
04:15:12 <Cale> @undo do x <- arbitrary; y <- arbitrary; return (Concat x y)
04:15:12 <lambdabot> arbitrary >>= \ x -> arbitrary >>= \ y -> return (Concat x y)
04:15:17 <Eridius> o_O
04:15:19 <Cale> @pl arbitrary >>= \ x -> arbitrary >>= \ y -> return (Concat x y)
04:15:19 <lambdabot> (`fmap` arbitrary) . Concat =<< arbitrary
04:15:22 <Cale> heh
04:15:31 <Cale> Not very good :)
04:15:42 * Eridius was about to do the undo transformation by hand >_<
04:15:45 <Cale> liftM2 Concat arbitrary arbitrary
04:16:52 <Eridius> Cale: thanks
04:17:22 <plutonas> how do i turn some value into type Int?
04:17:34 <quicksilver> plutonas: fromIntegral, perhaps
04:17:38 <quicksilver> depends what the value was!
04:17:41 <Eridius> fromEnum perhaps
04:17:57 <plutonas> it's ratio
04:18:13 <plutonas> but it's integer
04:18:24 <plutonas> i confuse you, so lets go from the start
04:18:36 <plutonas> it's a ratio, that has 8 as denominator
04:18:51 <plutonas> i divide it by 1/8 which turns it into an integer
04:18:56 <plutonas> but the type remains ratio
04:20:27 <Eridius> plutonas: truncate?
04:20:37 <Eridius> or maybe round, depending on how you want to handle non-integral ratios
04:22:07 <plutonas> they all will be integral, thanks, truncate was what i wanted
04:22:11 <cajun-rat> are there any known issues with ghc on windows, the threaded RTS, and foreign calls?
04:23:37 <mjrosenb> Eridius: interesting seeing you in here
04:23:41 <Eridius> hey mjrosenb
04:23:50 <cajun-rat> i've got a (gtk2hs) gui application that is calling my threaded rts haskell back-end
04:24:08 <Eridius> mjrosenb: figured I should stop playing with OCaml and start playing with Haskell, and I'm having fun :)
04:24:27 <cajun-rat> and threads in the backend seem to not get run
04:24:59 <rog_> earthy: food for thought. off back to the drawing board. thanks.
04:30:11 <plutonas> next question: is there a ready function to skip elements of a list, for example take the first and then every fourth, for example, function [0..20] -> [0,4,8,12,16,20]
04:30:36 <plutonas> hm, of course i mean for lists of every type of element, not just numbers
04:32:35 <qebab> anyone here know anything about this Liskell language?
04:32:36 <plutonas> i guess it would not be so hard to define, although i didn't try yet, but if it exists it would be much better :)
04:33:26 <Cale> http://www.youtube.com/watch?v=vYktRTtulek
04:33:27 <lambdabot> Title: YouTube - Coequalisers 1
04:33:41 <SamB_XP> plutonas: well, you could use the mythical chunk function ;-P
04:34:26 <rog_> here's another question: what do people tend to use in haskell for lightweight sets of enums, the sort of thing for which you might use 32-bit ints and bit operations in C? Data.Set strikes me as potentially somewhat heavyweight. but maybe it optimises?
04:34:30 <plutonas> why mythical?
04:34:58 <SamB_XP> plutonas: well, it isn't in Data.List for some odd reason :-(
04:35:18 <Cale> I love the way that YouTube completely fails to find videos that are in any way related to TheCatsters videos :)
04:35:28 <plutonas> SamB_XP: where is it?
04:35:51 <SamB_XP> Cale: what does it do instead?
04:36:08 <SamB_XP> plutonas: I don't know!
04:36:13 <SamB_XP> @where chunk
04:36:13 <lambdabot> I know nothing about chunk.
04:36:18 <Cale> SamB_XP: Well, see for yourself what the "Related Videos" are ;)
04:36:19 <plutonas> SamB_XP: does it exist?
04:36:56 <mm_freak> hmm  every second package fails to build haddock documentation here; i have haddock 0.9 installed
04:37:27 <mm_freak> it is marked 'testing' (~x86) on gentoo  should i downgrade to haddock 0.8.0.8?
04:38:20 <mm_freak> rog_: data MyEnumType = Value1 | Value2 | Value3 | Value4 | 
04:38:57 <daf> rog_: perhaps Data.Bits is what you want?
04:39:12 <daf> rog_: probably the right thing to do is to start off with Data.Set and replace it if it's too slow later
04:39:30 <mm_freak> oh, bit operations  well
04:41:15 <rog_> daf: i suppose so. i guess i was wondering if there was something which leveraged Enum and Bounded to come up with something similar to bitsets.
04:41:20 <mm_freak> unless i have to do fancy stuff like shifting, i'd just use something like this: data Color = Color { red :: Bool, green :: Bool, blue :: Bool }
04:41:36 <mm_freak> or even something like UArray Int Bool
04:42:07 <rog_> mm_freak: but then i'd have to explicitly write all the union, intersect, etc operators each time. not great.
04:42:10 <SamB_XP> couldn't you use UArray My
04:42:15 <SamB_XP> EnumType Bool
04:42:35 <rog_> what's UArray?
04:43:23 <mm_freak> an unboxed array  this is going to be a bitfield, if Bool is your element type
04:45:10 <rog_> mm_freak: i think i'd be better off using some instance of Bits. that way at at least i don't have to rewrite all the bit operations. inefficiently.
04:46:42 <mm_freak> rog_: you don't need to do that anyway  the array operations become your bit operations
04:47:20 <mm_freak> but indeed you'd need to rewrite set operations
04:47:57 <mm_freak> (binary and, binary or, etc.)
04:48:08 <mm_freak> it's easy though
04:49:00 <rog_> mm_freak: easy but really not very quick, as i'd have to do all the iteration myself, rather than have the natural parallelism of the ALU do it for me. which i'd prefer, all other things being equal.
04:49:22 <mm_freak> true
04:50:23 <ivanm> with the recent discussion on -cafe regarding licenses, I've read a couple of times that the unofficial Haskell policy is BSD-like for libs, and if you want GPL for apps
04:50:31 <ivanm> which variant of the BSD license is preferred?
04:51:01 <rog_> i could create an instance of Data.Bits for any data type that was an instance of Enum and Bounded. and i guess with overlapping instances, i wouldn't even need to write any boilerplate.
04:52:10 <SamB_XP> ivanm: BSD2!
04:52:20 <mm_freak> rog_: well, you could use Integer and power-of-two constants
04:52:22 <mm_freak> but that's ugly
04:52:28 <ivanm> SamB_XP: well, I see a lot of libs with BSD-3, which is why I asked
04:52:33 <rog_> anyway, this is academic. i'll be using Data.Set for the time being. sometimes getting over my natural tendency to premature optimisation is like pulling teeth!
04:52:53 <ivanm> since AFAICT, the only difference is that with BSD-3, you can't use the author's name to justify your usage (or something like that)
04:52:58 <SamB_XP> actually I only said that because it's the most permissive
04:53:05 <ivanm> *nod*
04:53:16 <rog_> mm_freak: it's not ugly if it's hidden. that's precisely what i was thinking of.
04:53:25 <ivanm> well, I've tentatively chosen it over BSD-3 myself, only because I think the extra clause isi rather pointless
04:53:47 <SamB_XP> I doubt we care much, for your software ;-)
04:54:17 <mm_freak> rog_: well, go ahead and write a wrapper type =)
04:54:52 <mm_freak> data BitSet a = BitSet a
04:55:02 <mm_freak> instance Bits a => BitSet a where 
04:55:45 <ivanm> SamB_XP: heh
04:56:43 <rog_> mm_freak: i was thinking of: data (Enum a, Bounded a) => Bitset a = Bitset Integer
04:57:13 <rog_> mm_freak: or something along those lines.
04:58:10 <mm_freak> rog_: i don't like contexts right in data definitions
04:58:17 <hackage> Uploaded to hackage: yi 0.4.6.2
04:58:29 <mm_freak> btw, if you don't use the 'a', you can just as well leave it away
04:58:38 <mm_freak> data BitSet = BitSet Integer
04:59:11 <rog_> mm_freak: but how else are the functions on BitSet going to find out what the values of the enums are?
04:59:59 <rog_> mm_freak: i mean the integer values, of course.
05:00:04 <vegai> should all Haskell programs be compiled with -O for distribution packaging?
05:00:29 <mm_freak> rog_: Integer is an instance of Bits
05:00:29 <SamB_XP> probably at least
05:00:37 <mm_freak> you don't need a context for that
05:00:40 <rog_> mm_freak: but Enum is not
05:00:54 <SamB_XP> Enum can't be
05:01:06 <SamB_XP> Enum isn't a type ;-P
05:01:11 <mm_freak> rog_: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#6
05:01:13 <lambdabot> Title: Prelude, http://tinyurl.com/ovjef
05:01:14 <rog_> mm_freak: good point...
05:01:22 <rog_> ^^^ SamB_XP
05:01:35 <SamB_XP> you has ... three eyes ?
05:01:37 <mm_freak> Integer is an instance of Bits and Enum, but (naturally) not of Bounded
05:01:38 <vegai> SamB_XP: does a typical Cabal setup do this already? Seems that it doesn't
05:01:56 <SamB_XP> vegai: speak to dcoutts and Igloo, perhaps ?
05:02:04 <mm_freak> if you need a bounded Integer type, create one
05:02:08 <vegai> dcoutts_, Igloo?
05:02:44 <SamB_XP> @localtime dcoutts
05:02:44 <vegai> ah
05:02:44 <lambdabot> Local time for dcoutts is Mon Sep 29 05:02:45
05:03:02 * vegai noticed finally the --enable-optimization switch to Setup.hs configure
05:03:10 <SamB_XP> well, I guess this is probably not the best time to speak with dcoutts ?
05:03:30 <vegai> yeah, he's probably too busy coding
05:03:37 <vegai> at this hour
05:03:43 <SamB_XP> he codes at 5:00 AM ?
05:03:53 <vegai> insert Laughter
05:03:54 <rog_> mm_freak: but data types can automatically derive Bounded and Enum, which means they could plug straight in to a bitwise representation of a set.
05:04:06 <vegai> joke :: Maybe Laughter
05:05:06 <mm_freak> vegai: i'd regard laughter a value
05:05:13 <mm_freak> laughingAtJoke :: Joke -> Bool
05:05:47 <mm_freak> rog_: i don't know how Bounded and Enum are useful here
05:05:48 <BeelsebobWork> surely Joke -> Person -> Bool
05:06:04 <mm_freak> meLaughingAtJoke :: Joke -> Bool
05:06:05 <mm_freak> =P
05:06:07 <vegai> Joke -> [Person] -> Bool
05:06:19 <vegai> IO Bool?
05:06:30 <rog_> mm_freak: hold on, i'll post some code. i'm intrigued now.
05:06:39 <rog_> mm_freak: gimme 5 minutes.
05:06:40 <vegai> perhaps TVar Bool
05:06:47 <BeelsebobWork> determineFuniness j = (length $ filter (laughingAtJoke j) allPeople) / length allPeople
05:06:51 <vegai> since if the joke fails, you of course have to retry
05:06:57 <mm_freak> (Laughable j, Monad m, Creature p) => j -> m p -> IO Bool
05:07:22 <BeelsebobWork> why on earth would we want such a pure concept to be wrapped in a monad?
05:07:35 <mm_freak> BeelsebobWork: to generalize the list
05:07:49 <mm_freak> Maybe Person, [Person], Id Person, 
05:07:50 <BeelsebobWork> no, I meant the IO Bool
05:08:12 <vegai> joke, a pure concept?
05:08:16 <mm_freak> oh  because you don't always laugh at a joke  it depends on your mood, which again depends on the state of the universe
05:08:25 <BeelsebobWork> I guess so, yeh
05:08:35 <vegai> Wenn ist das Nunstck git und Slotermeyer? Ja! ... Beiherhund das Oder die Flipperwaldt gersput.
05:08:41 * vegai dies
05:08:50 * BeelsebobWork dies too
05:08:52 <BeelsebobWork> damn you
05:08:56 <vegai> oh wait a minute, I don't know pseudo-German.
05:08:57 <mm_freak> vegai: ich verstehe dich nicht
05:08:58 * vegai lives!
05:10:54 <mm_freak> being purely functional in the real world \o/
05:11:19 <SamB_XP> hmm
05:11:26 <SamB_XP> I think IO isn't the right monad
05:11:51 <SamB_XP> well, or, is monad even the right abstraction ?
05:11:53 <BeelsebobWork> findsFunny :: Person -> Joke -> Behavior Bool
05:12:14 <BeelsebobWork> funnieness :: Joke -> Behavior Rational
05:12:14 <mm_freak> SamB_XP: PersonState
05:12:20 <SamB_XP> persons are not able to be carried around as immutable objects
05:12:29 <BeelsebobWork> why not?
05:12:39 <mm_freak> but you'll find that the state of a person is bound to the state of the universe, for which IO is the right abstraction
05:12:41 <BeelsebobWork> if a person is a description of what that person is, was and ever will be
05:12:52 <SamB_XP> they change as they interact with their environments
05:13:16 <BeelsebobWork> right, so type Person = Behavior ExternalPersonBits
05:13:34 <mm_freak> type Person = IORef PersonState
05:13:39 <BeelsebobWork> ewwwww
05:14:24 <BeelsebobWork> specifically, findsFunny p j = fmap (funnyNow j) p
05:15:21 <rog_> mm_freak: http://hpaste.org/10762
05:15:45 <mm_freak> findsFunny :: Person -> FunnyEntity -> IO Bool
05:16:17 <mm_freak> (in fact, any state monad encapsulating the state of the world will do, but we've got only IO)
05:16:34 * BeelsebobWork doesn't want this horrible IO hanging about
05:16:41 <BeelsebobWork> there's no reason for it
05:17:01 <mm_freak> rog_: your code doesn't make sense
05:17:09 <mm_freak> try:  data BitSet = BitSet Integer
05:17:52 <rog_> mm_freak: it compiles...
05:17:59 <BeelsebobWork> doesn't mean it makes sense
05:18:07 <BeelsebobWork> it's a phantom type
05:18:21 <mm_freak> sure it does, but it contains many superfluous things
05:18:29 <BeelsebobWork> you probably wanted newtype ... Bitset a = Bitset a
05:18:38 <rog_> mm_freak: i think it makes sense - the operations on it only allow one to place the same enum type in there.
05:18:38 <mm_freak> BeelsebobWork: needlessly, unless i'm missing something
05:18:57 <mm_freak> ah
05:19:03 <BeelsebobWork> mm_freak: it is a bit odd -- but he may want to make instances from it at a later date
05:19:09 <ivanm> gah, I just realised that I'd re-invented Data.Map.fromList :s
05:19:21 <mm_freak> rog_: ok, now i get what you're trying to do
05:19:25 * BeelsebobWork hugs ivanm 
05:19:41 <mm_freak> indeed, it makes sense
05:19:47 <ivanm> thanks BeelsebobWork
05:21:56 <mm_freak> rog_: in fact, that's a great idea
05:22:14 <rog_> mm_freak: good!
05:23:31 <ivanm> BeelsebobWork: oh, wait, it wasn't _quite_ a re-implementation of fromList... I was flipping the pairs whilst I was at it
05:23:52 <BeelsebobWork> ivanm: well that's margionally better isn't it? :D
05:24:01 <ivanm> heh
05:24:17 <ivanm> except that since I've replaced it with fromList, it no longer typechecks :s
05:24:34 <rog_> mm_freak: as it happens, i don't use the Bounded constraint, but i could use it a) when creating a new instance, to check that the range of the enum type was within the range of the integer type i'm using and b) when showing a Bitset, to show only the relevant range.
05:24:59 <ivanm> oh, wait, my new flipping function wasn't right...
05:25:18 <Stinger> @ty uncurry
05:25:19 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:27:14 <mm_freak> rog_: btw, you could generalize it to other Bits types
05:27:25 <mm_freak> since a future BitSet type may be more efficient than Integer
05:28:53 <rog_> mm_freak: indeed.
05:29:15 <mm_freak> data BitSet r e = BitSet r
05:29:34 <mm_freak> instance (Bits r, Enum e) => BitSet r e where 
05:29:42 <rog_> mm_freak: ... or just use Int, which is what i was planning anyway. most such sets aren't bigger than 32.
05:29:54 <mm_freak> rog_: then Int will be used internally anyway
05:29:57 <mm_freak> don't bother
05:30:13 <mm_freak> @src Integer
05:30:14 <lambdabot> data Integer = S# Int#
05:30:14 <lambdabot>              | J# Int# ByteArray#
05:31:10 <rog_> mm_freak: i'm slightly doubting that the compiler could statically determine the range needed for the bitset underlying type. but maybe it is that smart.
05:31:27 <ivanm> wow, what an improvement:
05:31:28 <ivanm> @unpl map ((,) =<< f)
05:31:29 <lambdabot> map (f >>= ((,)))
05:31:44 <mm_freak> rog_: it isn't, but as long as your bitfield doesn't overflow, it will stick with Int
05:31:57 <mm_freak> it's theoretically slightly slower than Int
05:32:05 <mm_freak> but in practice, it's even faster for some reason
05:32:27 <rog_> oh i see, it uses an unboxed type until it can't. like lisp?
05:32:49 <mm_freak> that has nothing to do with boxing  it's just that Integer has two constructors internally
05:33:02 <mm_freak> one for a machine word and one for larger integers
05:33:11 <mm_freak> it doesn't use the latter unless necessary
05:34:14 <rog_> i guess that's what i meant. the actual runtime type depends on which constructor is used, presumably.
05:35:28 <mm_freak> yes
05:36:21 <rog_> in which case, there's probably no need to parameterise the integer type used by bitset. what will ever be faster than Integer?
05:36:28 <romildo> Hi.
05:38:19 <romildo> Why when using a tree view widget in gtk2hs one has to "import Graphics.UI.Gtk" and also "import Graphics.UI.Gtk.ModelView as New"? Is the "as New" part really necessary?
05:38:34 <mm_freak> rog_: a BitField type
05:38:55 <mm_freak> which is not an integral type, but an optimized bitfield in memory
05:39:15 <rog_> mm_freak: how is that different from a 2s complement integer?
05:39:40 <mm_freak> romildo: you're just giving a short namespace name to Graphics.UI.Gtk.ModelView
05:40:23 <romildo> mm_freak: yes, but if I ommit the short namespace name would it work?
05:40:29 <mm_freak> romildo: for example, if you import Data.List as L, then you can refer to the 'groupBy' function as L.groupBy in addition to Data.List.groupBy
05:40:35 <mm_freak> if you never use that New name, you can omit it
05:41:12 <mm_freak> btw, usually Graphics.UI.Gtk exports all Gtk-related stuff, so i don't think it's necessary to import Graphics.UI.Gtk.ModelView
05:41:34 <mm_freak> rog_: Integer uses GMP's bit manipulation functions, which are slow
05:41:51 <rog_> mm_freak: GMP?
05:42:03 <mm_freak> a dedicated bitfield type may use a simple word array internally without going through GMP
05:42:03 <romildo> I am looking at some demos from the distribution, and they have been written in this style.
05:42:17 <mm_freak> GMP = GNU Multi-Precision library
05:42:31 <mm_freak> the bigint library GHC and some others use
05:43:04 <mm_freak> romildo: the name "New" is a bit pointless though
05:43:10 <mm_freak> i'd rather name it MV or something
05:44:07 <rog_> mm_freak: so all integer ops go through GMP? i thought you said that small ints used a more efficient representation.
05:44:33 <rog_> mm_freak: does that include bitwise ops on Ints?
05:45:07 <mm_freak> rog_: as long as small ints are used, yes
05:45:08 <Stinger> Integer type != Int type
05:45:38 <mm_freak> rog_: i'm talking specifically about bigints, when the machine word version is _not_ used
05:46:18 <mm_freak> Stinger: Integer has two constructors, one for a machine word and one for a real bigint
05:46:21 <mm_freak> @src Integer
05:46:22 <lambdabot> data Integer = S# Int#
05:46:22 <lambdabot>              | J# Int# ByteArray#
05:47:26 <rog_> mm_freak: ... ok. but i suppose i'm still wondering why GMP's bit manipulation functions should be slower than some dedicated bitfield operators. there's not much overhead in storing an MP int. unless they're being silly.
05:48:02 <rog_> mm_freak: i've written MP bit operators, and i've written bitfield operators, and they're pretty much identical, no?
05:48:06 <mm_freak> rog_: because of memory management and even because of function call overhead
05:48:26 <koweywork> is there a common function along the lines of "histogram :: [a] -> Map a Int" somewhere?
05:48:37 <rog_> mm_freak: but how would a bitfield implementation get around those problems?
05:48:45 * koweywork doesn't particularly mind reinventing tiny wheels
05:49:25 <mm_freak> koweywork: what do you want?  count identical elements?
05:49:40 <Ferdirand> is this for all bit operators ? rotate and shift, f.i, sound more difficult than logical operators
05:50:06 <mm_freak> rog_: in that it doesn't have to obey some of GMP's rules  it can use a simple word array
05:50:07 <koweywork> mm_freak: yeah... I suppose come to think of it I could also do something with sort, group and length
05:50:09 <romildo> mm_freak: If only "import Graphics.UI.Gtk" is used, then some names are not resolved and I get messages like: ListDemo.hs:24:73: Not in scope: `cellToggleActive'
05:50:34 <mm_freak> rog_: and it then wouldn't need two separate internal representations anymore, because that's only useful for numerical computations
05:51:07 <mm_freak> romildo: ok, then you'll have to import ModelView
05:51:28 <romildo> mm_freak: so it seems that Graphics.UI.Gtk does not exports all Gtk-related stuff.
05:51:58 <mm_freak> koweywork: Data.Map.fromList may be what you're looking for
05:52:46 <koweywork> thanks! probably fromListWith (+) is more like it
05:52:57 <scriptdevil> is there a haskell tcp/ip implementation?
05:53:18 <rog_> mm_freak: presumably all the other integer ops are using GMP, so it can't be that slow...
05:53:27 <mm_freak> scriptdevil: a "TCP/IP" implementation?  one that gets around the OS's one?
05:53:48 <romildo> and importing Graphics.UI.Gtk.ModelView withoung renaming gives clashes:
05:53:49 <romildo> ListDemo.hs:14:11:
05:53:49 <romildo>     Ambiguous occurrence `listStoreNew'
05:53:49 <romildo>     It could refer to either `Graphics.UI.Gtk.listStoreNew', imported from Graphics.UI.Gtk at ListDemo.hs:3:0-21
05:53:49 <romildo>                           or `Graphics.UI.Gtk.ModelView.listStoreNew', imported from Graphics.UI.Gtk.ModelView at ListDemo.hs:4:0-31
05:53:55 <ivanm> SamB_XP: so if you use BSD-2, how do you put that in as a license for cabal? :s
05:53:59 <mm_freak> rog_: GMP is extremely fast for integer stuff, but quite slow for bit manipulation
05:54:07 <scriptdevil> mm_freak: yeah... the network stack
05:54:20 <scriptdevil> mm_freak: ipv6 is better
05:54:47 <BeelsebobWork> scriptdevil: why would someone do that?  also, what OS doesn't implement IPv6?
05:55:05 <ivanm> BeelsebobWork: old ones?
05:55:12 <ivanm> linux where someone didn't enable the kernel options?
05:55:12 <BeelsebobWork> very old ones
05:55:13 <romildo> mm_freak: would it be a problem in the design of those Gtk modules bad?
05:55:15 <mm_freak> scriptdevil: there is an operating system written in haskell, which may contain what you want
05:55:18 <scriptdevil> BeelsebobWork: I mean.. Does house or some other OS have an implementations?
05:55:18 <mm_freak> http://programatica.cs.pdx.edu/House/
05:55:21 <lambdabot> Title: House
05:55:38 <BeelsebobWork> scriptdevil: no idea if house implements TCP/IP or not
05:55:42 <BeelsebobWork> it may well do
05:55:53 <rog_> mm_freak: hmm. seems a bit odd to me, but i'll take it from you. i think that rather than burdening the user of the bitset module with the task of determining the fastest appropriate implementation type, i'd be happier just using it (and hiding which it is from the user)
05:55:55 <mm_freak> romildo: no
05:56:01 <BeelsebobWork> in fact, the front page says it does
05:56:06 <mm_freak> romildo: it's a design choice
05:56:09 <BeelsebobWork> but it doesn't support IPv6
05:56:28 <scriptdevil> BeelsebobWork: Well.. ipv4 is good enough then .. Thanks
05:56:33 <mm_freak> rog_: write a wrapper type
05:56:53 <mm_freak> data BitSetWith r e = BitSetWith r
05:57:01 <plutonas> i want to alter the tail of a list, in the following way, each element changes according to it's previous, what is the best way to do this?
05:57:14 <mm_freak> type BitSet = BitSetWith Integer
05:57:16 <BeelsebobWork> plutonas: foldl
05:57:19 <BeelsebobWork> @type foldl
05:57:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:57:51 <plutonas> BeelsebobWork: thought of it, but foldl would return one element
05:57:55 <plutonas> it kind of folds the list
05:58:06 <mm_freak> why foldl?  rather sounds like a job for mapAccumL or mapAccumR
05:58:25 <mm_freak> or maybe foldr
05:58:34 <mm_freak> depends on what you mean by "manipulate"
05:58:40 <BeelsebobWork> foldr actually would be better, yes
05:58:44 <plutonas> i want for example to have [7,9,7,8] and for example add the previous one to the current to have [7, 16, 23, 31]
05:58:47 <koweywork> hooray for haskell NLP! (display the most frequent n-grams in < 30 lines of naive code)
05:58:50 <plutonas> (just an example)
05:59:03 <BeelsebobWork> plutonas: ah, okay, scanl then
05:59:13 <BeelsebobWork> > scanl (+) 0 [7,9,7,8]
05:59:15 <lambdabot>   [0,7,16,23,31]
05:59:31 <BeelsebobWork> > scanl1 (+) [7,9,7,8]
05:59:33 <lambdabot>   [7,16,23,31]
06:00:08 <plutonas> thanks. It's good that i ask for every function i could possibly need, seems that haskell has most of them
06:00:18 <BeelsebobWork> hoogle is your friend
06:00:29 <BeelsebobWork> @hoogle (a -> a -> a) -> [a] -> [a]
06:00:30 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
06:00:30 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
06:00:30 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
06:00:32 <mm_freak> yeah, but learning haskell involves a lot of reinventing
06:00:38 <BeelsebobWork> indeed
06:00:44 <mm_freak> so it's not bad, if you do that often =)
06:02:14 <rog_> mm_freak: hmm. thought i'd take a look at the GMP source. usual unspeakable gnu crud. 3680 line header file. oh dear, i guess i won't be finding out why their bit functions are slow then.
06:03:46 <mm_freak> rog_: GMP is quite ugly code, particularly because it's VERY low-level
06:04:03 <mm_freak> it uses hand-optimized code, where possible
06:04:08 <rog_> mm_freak: it *is* possible to write pretty low level code.
06:04:24 <mm_freak> the bit manipulation functions are slow because of function call overhead and memory management (unless you use mpn_*)
06:04:31 <mightybyte> @pl (\x -> (x`elem`y)&&(x`elem`z))
06:04:31 <lambdabot> liftM2 (&&) (`elem` y) (`elem` z)
06:04:37 <mm_freak> but GMP unfortunately uses the mpz_* class of functions
06:04:40 <mm_freak> uhm
06:04:43 <mm_freak> but GHC unfortunately uses the mpz_* class of functions
06:05:12 <BeelsebobWork> @type (&&) <$> (`elem` y) <*> (`elem` z)
06:05:14 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
06:05:14 <lambdabot>     In the second argument of `elem', namely `y'
06:05:14 <lambdabot>     In the second argument of `(<$>)', namely `(`elem` y)'
06:06:51 <ivanm> @seen dons
06:06:51 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I don't know when dons last spoke.
06:07:42 <ivanm> anyone know why don's mkcabal app doesn't let you choose OtherLicense or UnknownLicense?
06:09:56 <mm_freak> because dons doesn't want you to use other licenses =P
06:10:08 <ivanm> heh
06:10:23 <ivanm> bad enough that Cabal restricts the licenses... >_>
06:10:26 <rog_> mm_freak: having just looked at the code a bit harder, i see how a bitfield type (as long as it was bounded) could be quicker. and i'm not surprised that ghc uses the mpz_ functions!
06:11:30 <mm_freak> well  what's sad ist that although GHC uses mpz_*, many virtues of GMP are inaccessible to haskell programmers
06:11:55 <mm_freak> like mpz_probab_prime_p or mpz_sqrt
06:13:02 <rog_> mm_freak: presumably they'd by straightforward to provide an interface to with FFI?
06:13:22 <rog_> s/by/be/
06:13:55 <mm_freak> you'd expect that, wouldn't you  but unfortunately that's not the case
06:14:09 <mm_freak> because GHC redirects the memory management functions
06:15:39 <rog_> mm_freak: i see. FFI code can't call back into the haskell memory management, then?
06:15:53 <mm_freak> i don't know
06:16:42 <mm_freak> my proposal is to statically link GMP into binaries and then FFI-interface GMP independently
06:17:10 <mm_freak> but firstly that would become a major licensing problem, and secondly it would only work for compiled programs
06:17:43 <mm_freak> current licensing is a mess already
06:19:03 <rog_> mm_freak: surely the licences must be compatible for ghc to use gmp anyway?
06:21:42 <rog_> an aside: one thing i was a bit surprised at was the fact that i had to put the Enum constraint explicitly into (for instance) the add function, where the compiler should have been able to infer it from its presence on the Bitset type. why is that?
06:21:59 <ivanm> this is weird... haddock's cabal file says it's under the BSD license, but looking at its website it lists a BSD-2 license :s
06:22:12 <rog_> is there a compiler flag that i can set to enable it to do that automatically?
06:25:52 <Deewiant> rog_: -XNoMonomorphismRestriction, perhaps?
06:26:11 <quicksilver> rog_: types do not imply instances.
06:26:40 <mm_freak> rog_: the problem is that BSD allows redistribution in binary, whereas the LGPL does not  that's no problem as long as you don't link GMP into the binary
06:26:47 <mm_freak> but GHC does exactly that
06:27:21 <Leaves> Hello, do you know how to convert a Word8 to an Int?
06:27:35 <Taejo> @hoogle Word8 -> Int
06:27:35 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
06:27:35 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
06:27:35 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
06:27:44 <quicksilver> Leaves: fromIntegral
06:27:48 <BeelsebobWork> > fromIntegral (5 :: Word8) :: Int
06:27:49 <lambdabot>   5
06:28:03 <Leaves> aah, ok, I though that was for the other direction, thanks
06:28:15 <Taejo> @ty fromIntegral
06:28:16 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:28:31 <BeelsebobWork> it's for *all* directions that start in some integral type
06:29:04 <quicksilver> Leaves: in this particular case it would indeed work in both directions.
06:30:48 <rog_> i'm not sure that -XNoMonomorphismRestriction is the one. but i'll try it.
06:31:08 <quicksilver> rog_: it is not relevant, if I understood your problem.
06:31:14 <quicksilver> rog_: types do not imply classes.
06:31:20 <quicksilver> so BitSet will never 'imply' Enum.
06:31:26 <rog_> quicksilver: ok.
06:31:58 <quicksilver> "BitSet a -> BitSet b"   <--- this type is fully polymorphic over a and b
06:32:23 <quicksilver> it would be a strange thing (in the context of haskell's type system) if some internal detail of BitSet could reduce what looked like fully polymorphism.
06:32:29 <quicksilver> so you always have to have the constraint there.
06:34:00 <rog_> quicksilver: but in that example, isn't both the type of a and the type of b known from their context. and they'll always be instances of whatever constraints are placed on them in the data declaration?
06:34:14 <quicksilver> that's not what I meant.
06:34:30 <quicksilver> I meant, you are entitled to look at that type signature without knowing anything about bitset
06:34:38 <rog_> ok. i see.
06:34:42 <quicksilver> and it is obviously fully polymorphic.
06:34:52 <quicksilver> the compiler is also entitled to do this, in a sense.
06:35:04 <quicksilver> the compiler can assume that polymorphic functions are polymorphic
06:35:16 <quicksilver> and that's the basis of some compilation techniques/optimisations.
06:35:27 <quicksilver> rog_: as and asidt, constraints in data declarations don't work, so don't use them.
06:35:32 <rog_> ... even though it's not actually fully polymorphic because you could never actually create a Bitset instance without the type satisfying Bitset's constraints....
06:36:07 <rog_> oh
06:36:09 <ddarius> rog_: It is fully polymorphic.
06:36:42 <mm_freak> rog_: as said, write constraints in instance declarations
06:37:25 <quicksilver> constraints on constructors work, only if you're using GHC, and only if you turn on GADTs.
06:37:33 <quicksilver> constraints on data types don't do anythign useful.
06:37:50 <rog_> why does the syntax allow them, then?
06:37:58 <quicksilver> (and even in the constructor case, the compiler does not attempt to infer that "constraint on each constructor => constraint on whole type".
06:38:03 <quicksilver> rog_: IMO it was a mistake.
06:38:27 <quicksilver> all it does it apply the constraint to each constructor.
06:38:31 <besiria> > fromEnum '#'
06:38:32 <lambdabot>   35
06:38:36 <quicksilver> but it doesn't give you the constraint back when you pattern match.
06:38:39 <quicksilver> so that's pretty useless.
06:39:25 <ivanm> how does one set author, email address, etc. in a darcs repo?
06:39:26 <Deewiant> don't type families allow for something like that, or do I misremember something?
06:40:14 <rog_> i see. so in my little bitset example, there's no point in putting the constraint on the data type, as long as i've got the right constraints on whatever data constructors i make available?
06:40:51 <quicksilver> yes.
06:44:27 <Leaves> I've another question: If I have an array (generated with a = listArray (0, 255) [...]) does it make sence to say a :: Array Word8 Word8, ie does haskell use this info?
06:44:48 <quicksilver> sure.
06:45:06 <plutonas> what am i doing wrong here:
06:45:09 <plutonas>  foldr1 (\x y -> min (length x) (length y)) [[1..5], [1..10], [50..100]]
06:45:44 <Leaves> quicksilver: but I though that an array is always from Int to something else, why can I also specify the key type?
06:46:47 <quicksilver> Leaves: you were wrong.
06:46:58 <quicksilver> haskell arrays can be indexed by anythign which implements 'Ix'
06:47:23 <quicksilver> notably most of the integral types, also tuples like (Int,Int), user-defined types which have a finite number of members
06:47:30 <quicksilver> (data X = A | B | C)
06:48:11 <Leaves> quicksilver: ok, thanks, that's pretty cool
06:48:18 <quicksilver> it is, yes ;)
06:48:27 <trzkril> plutonas: foldr1 :: (a -> a -> a) -> [a] -> a
06:48:31 <maltem> plutonas: the lambda abstraction works on lists, but returns numbers
06:48:34 <quicksilver> I have arrays indexed by (Int,Int,Direction) and (Int,Int,Side) in cube analysis code
06:48:42 <mml> it's quite practical.  making the index (Int,Int) gives you 2D arrays, which are nothing exotic.
06:48:44 <trzkril> plutonas: but your function is [a] -> [b] -> Int
06:48:50 <quicksilver> arrays of faces or edges or ...
06:49:49 <Leaves> mml, that's cool to, I would have made an array of arrays :)
06:50:00 <maltem> plutonas: That is, you have to decide whether you want the minimal length, or the shortest list
06:50:19 <plutonas> maltem: shortest list
06:50:47 <maltem> plutonas: Then your function of x and y should return the shorter list
06:51:14 <plutonas> maltem: how would i do this?
06:51:39 <maltem> plutonas: I'd suggest an if-then-else clause  :)
06:51:39 <plutonas> i mean using minimum i can find the minimum length, but i don't think it would be optimal to use this to find the shortest list
06:51:50 <plutonas> hm, ok
06:52:19 <quicksilver> then convert them all to lengths ford
06:52:20 <quicksilver> first
06:52:25 <quicksilver> foldr1 minimum . map length
06:52:40 <quicksilver> foldr1 min . map length I mean
06:52:44 <quicksilver> or simply
06:52:47 <quicksilver> minimum . map length
06:52:55 <maltem> quicksilver: He's going for the shortest list
06:53:53 <plutonas> also there might be that two lists have the shortest length, so i'd like to have them both
06:53:55 <maltem> plutonas: actually, there's the problem with the obvious solution (if length x < length y then x else y) in that it computes every length two times
06:55:22 <maltem> er, not every length
06:55:30 <maltem> but some lengths multiple times
06:55:35 <plutonas> maltem: what do you propose? I use this call quite a lot in my code
06:55:43 <plutonas> (which is not exactly about lengths
06:55:50 <plutonas> but it's the simplest example i could think of)
06:56:02 <maltem> plutonas: I'd suggest you first map (\xs -> (xs,length xs))
06:56:18 <maltem> Then you're sure not to compute any length more than once
06:57:14 <maltem> Then fold over that list, pattern-matching on the length (or using snd to get the length)
06:57:52 <plutonas> hm, i see, thanks
06:57:56 <plutonas> gets complicated
06:58:29 <quicksilver> :t minimumBy
06:58:30 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:58:45 <quicksilver> you can get the shortest list using minimumBy
06:58:54 <quicksilver> minimumBy (min `on` length)
06:58:58 <quicksilver> that does recompute lengths
06:59:02 <quicksilver> but you may not care.
06:59:11 <quicksilver> otherwise it's schwartzian transform ftw.
06:59:27 <maltem> quicksilver: minimumBy (comparing length), you mean?
06:59:35 <Vq^> maltem: same thing
06:59:38 <plutonas> quicksilver: thanks
06:59:44 <quicksilver> I meant compare `on` length
06:59:47 <quicksilver> good catch :)
06:59:52 <quicksilver> but comparing length is the same.
07:00:09 <quicksilver> schwartzian transform is good to learn, though.
07:00:11 <Vq^> ah, i didn't see the error :)
07:00:18 <plutonas> not in scope on? where is that function?
07:00:32 <quicksilver> Data.Function, I think.
07:00:38 <quicksilver> @index on
07:00:38 <lambdabot> bzzt
07:00:43 * quicksilver slaps lambdabot 
07:00:43 <Vq^> it is
07:01:03 <quicksilver> @src on
07:01:03 <lambdabot> (*) `on` f = \x y -> f x * f y
07:01:06 <plutonas> thanks a lot
07:01:09 <quicksilver> it's the coolest combinator eva!
07:01:13 <plutonas> this is quite simple
07:01:24 <Vq^> it's surprisingly useful
07:01:36 <maltem> ah right
07:01:36 <maltem> so, just to finish off the obvious, we have minimumBy (comparing snd) . map (id &&& length)
07:02:00 <plutonas> it has a disadvantage though
07:02:06 <quicksilver> maltem: map fst .
07:02:14 <quicksilver> no, not map.
07:02:16 <quicksilver> just "fst" ;)
07:02:19 <plutonas> what if there are two lists with the minimum length?
07:02:27 <maltem> quicksilver: gotcha
07:02:45 <quicksilver> well minimumBy will be left biased, I imagine.
07:02:47 <ivanm> how can I determine which libraries I need for build-depends in my .cabal file?
07:02:55 <plutonas> left biased?
07:02:55 <ivanm> (is there an automated way?)
07:03:08 <maltem> plutonas: then you'd need to write something like minimumsBy
07:03:10 <quicksilver> > minimumBy (compare `on` length) ["foo","bar"]
07:03:11 <lambdabot>   "foo"
07:03:15 <quicksilver> yup, left biased.
07:03:20 <maltem> plutonas: or minimaBy, rather
07:04:08 <maltem> ivanm: Hm... leave the field empty and check the error messages?
07:04:24 <maltem> ivanm: Or won't that list all dependencies?
07:04:35 <plutonas> :t minimaBy
07:04:36 <lambdabot> Not in scope: `minimaBy'
07:04:47 <plutonas> maltem: shoud i define it?
07:04:49 <plutonas> should*
07:04:52 <maltem> right
07:04:56 <plutonas> :P
07:05:06 <plutonas> and i was searching for the right library
07:05:07 <plutonas> :)
07:05:11 <maltem> heh
07:05:19 <ivanm> maltem: no idea, hence why I'm asking :p
07:05:29 <ivanm> especially with split-base stuff :s
07:05:51 <maltem> ah, didn't think of that
07:08:43 <xsdnyd> is there a function which combines 'filter' and 'map'?
07:08:55 <Stinger> a list comprehension?
07:09:06 <Baughn> That's not a function
07:09:27 <xsdnyd> Stinger: yeah that could work
07:09:35 <Stinger> erm a lambda containing a list comprehension? :)
07:09:52 <Vq^> (>>=) could be used for that :)
07:09:54 <xsdnyd> is a list comprehension slower than filter + map?
07:09:57 <opqdonut_> xsdnyd: people usually just say "map f . filter p"
07:10:07 <opqdonut_> or "filter p . map f"
07:10:35 <opqdonut_> a lisp comprehension should be as fast as filter.map
07:10:36 <quicksilver> xsdnyd: a list comprehension will produce the same code as filter + map
07:10:39 <quicksilver> in GHC at least.
07:10:57 <xsdnyd> ok thanks all
07:12:10 <mm_freak> how can i translate list comprehension predicates to monadic list operations?  is that even possible?
07:12:24 <mm_freak> i reckon it's not
07:12:35 <quicksilver> sure it is.
07:12:52 <quicksilver> list comprehensions are just a minor variation on do notation
07:13:24 <quicksilver> [ x | x <- l, p x] ---> do x <- l; guard (p x); return x
07:13:32 <rog_> ok, so i've tried putting constraints in the interface declaration, and i can't make it work. here's a simple example that i thought ought to have worked: http://hpaste.org/10764#a0
07:13:39 <mm_freak> @src guard
07:13:39 <lambdabot> guard True  =  return ()
07:13:39 <lambdabot> guard False =  mzero
07:13:42 <BeelsebobWork> quicksilver: heh, that's rather nice
07:13:46 <mm_freak> oh
07:13:56 <rog_> i get "Could not deduce (Bounded a1) from the context ()"
07:14:36 <mm_freak> > [1,2,3] >>= \x -> (return 1 >> return x)
07:14:38 <lambdabot>   [1,2,3]
07:14:53 <mm_freak> > [1,2,3] >>= \x -> (mzero >> return x)
07:14:54 <lambdabot>   []
07:15:10 <xsdnyd> mhh i think i have a wrong unde
07:15:32 <xsdnyd> wrong knowledge of monads. when i use the do notation i am in the world of monads, right?
07:15:44 <mm_freak> xsdnyd: yes
07:15:54 <xsdnyd> and everywhere it says i can't get back to "normal"
07:16:05 <rog_> is it possible to do this?
07:16:05 <mm_freak> but do notation is just syntactic sugar for monad functions
07:16:32 <xsdnyd> so if a list comprehension uses a do notation how can the result the non-monad?
07:16:35 <mm_freak> xsdnyd: nope  it is way possible to "escape" from monads, but there are monads, for which it is not, particularly the IO monad
07:16:36 <Ferdirand> not all monads forbid you to "get back to normal"
07:16:51 <Eridius> xsdnyd: when you read that you can't "get back to normal", it's talking about the IO monad
07:16:59 <Eridius> since the IO datatype is an abstract data type, you can't unwrap it
07:17:07 <mm_freak> what you've seen above was the list monad, from which you can well escape  you do that all the time
07:17:10 <xsdnyd> ah ok. and what it the normal way to get back from a monad that allows it?
07:17:10 <Eridius> but the List monad just gives you... a List
07:17:18 <Eridius> s/L/l/
07:17:27 <Eridius> xsdnyd: to do whatever you normally do with that datatype
07:17:40 <quicksilver> you don't even want to escape from the list monad
07:17:42 <quicksilver> (normally)
07:17:44 <mm_freak> xsdnyd: either you know the type's constructors, or you have support functions
07:17:44 <Eridius> [a] is a monad, whether or not you actually use the monadic operators. Once you're done using the monadic operators, you're still left with [a]
07:17:49 <quicksilver> the result is a list and that's what you wanted.
07:18:01 <mm_freak> xsdnyd: in case of the Maybe monad, you know its two constructors, so you can pattern-match against them
07:18:07 <mm_freak> or you can use fromJust or fromMaybe
07:18:14 <Eridius> quicksilver: ah, but if you then fold over the list, you've "escaped" the list monad because you're left with a non-list (well, unless your fold produces a new list)
07:18:59 <mm_freak> Eridius: in fact [] is the monad, not [a]
07:19:08 <xsdnyd> that is really interesting. thanks for your explanations. now i understand haskell a bit more
07:19:20 <Eridius> mm_freak: true, but not relevant to my point :P
07:20:04 <quicksilver> Eridius: true true; I just meant you don't always need to.
07:20:06 <mm_freak> xsdnyd: personally my favorite interpretation of monads is:  they are wrappers around a type, which allow to change the idea of "value" for that type, and the idea of "passing a value between computations"
07:20:28 <quicksilver> xsdnyd: there is something of a general form "runFoo :: stuff -> m a -> (a , stuff)"
07:20:38 <Eridius> my favorite interpretation of monads is: they are the concept of a pattern of computation done with a particular datatype
07:20:43 <mm_freak> the Maybe monad changes the idea of value to "at most one value", and the idea of passing becomes: "passing a value, if there is one"
07:20:49 <quicksilver> xsdnyd: which says, roughly, that to run a monad you need to provide some stuff, and then you get some kind of answer, maybe with more stuff.
07:20:54 <Eridius> so a monadic type is actually a stored computation, and then when you unwrap that type you perform the computation
07:20:57 <quicksilver> it's only a general pattern, not a rule.
07:21:01 <Eridius> in the case of the IO monad, it gets unwrapped when the main function is called
07:21:26 <xsdnyd> ah :) nice
07:21:33 <xsdnyd> that helps
07:22:10 <mm_freak> Eridius: monads as computation appears more special than my interpretation  it's particularly useful for identity-like monads like IO or State
07:22:27 <Eridius> mm_freak: sure, but the monadic type in the case of the State monad is literally a saved monad
07:22:30 <Eridius> err, saved computation
07:22:39 <mm_freak> a saved function
07:22:40 <Eridius> nothing actually gets *computed* until you "run" it, with an initial state
07:22:56 <Eridius> mm_freak: well, it's a chain of lambdas
07:22:59 <mm_freak> it's a computation which results in a function
07:23:20 <mightybyte> @pl (\(a,b) -> a+b)
07:23:20 <lambdabot> uncurry (+)
07:24:08 <mightybyte> :r
07:24:25 <rog_> sorry for belabouring this, but looking at http://hpaste.org/10764 why does the first example compile and the second not?
07:25:41 <quicksilver> rog_: would be helpful if you'd paste the error message for the one which doesn't compiler
07:26:13 <Cale> rog_: The first doesn't work because 'a' in that context doesn't mean what you want it to.
07:26:48 <Cale> rog_: in   (minBound :: a), the type variable a is not in scope (!) and so that means  minBound :: forall a. a
07:26:55 <Cale> (which is a type error)
07:27:22 <rog_> quicksilver: done
07:27:24 <Cale> An easy way to fix it is to stick   forall a.  just after the  instance
07:27:29 <Cale> (keyword)
07:27:56 <Cale> rog_: okay, that error message agrees with me :)
07:28:11 <Cale> btw, there are tabs in your file
07:28:14 <quicksilver> and add -XScopedTypeVariables
07:28:16 <Cale> that's generally a bad idea
07:28:19 <quicksilver> or whatever it's called.
07:28:27 <rog_> Cale: why?
07:28:47 <Cale> rog_: Because they mess with alignment
07:29:05 <Cale> rog_: It's not indentation which is important in Haskell, but how things line up vertically.
07:29:36 <Cale> rog_: Since different editors interpret tabs differently, if you leave them in your source file, you're asking for trouble :)
07:29:39 <rog_> Cale: if i only ever use tabs, that should be ok, no? it's certainly worked ok for me so far
07:29:55 <rog_> Cale: i can always untab them if distributing the code.
07:30:03 <Cale> It may, but you should ensure that your editor is treating them as aligning to 8-space boundaries
07:30:09 <Cale> Since that's what the compiler is doing.
07:30:25 <rog_> Cale: why's that? my editor uses proportionally spaced chars.
07:30:26 <encryptio_> @pl (\x -> all $ take 50 (iterate (foo x)))
07:30:26 <Cale> There will be things which you'll be forced to write awkwardly too.
07:30:26 <lambdabot> all . take 50 . iterate . foo
07:30:36 <Cale> rog_: oh, that won't do at all
07:30:49 <encryptio_> @pl (\x -> all $ take 50 (repeat (foo x)))
07:30:49 <lambdabot> all . take 50 . repeat . foo
07:30:58 <Cale> rog_: I'll give an example...
07:30:59 <rog_> Cale: i like it 'cos it looks nice and i fit loads more text for available horizontal space.
07:31:34 <Cale> http://hpaste.org/10765
07:31:38 <quicksilver> you can use proportionally space chars if you always start a newline after every layout construct.
07:31:40 <Cale> Consider that program.
07:32:07 <quicksilver> "do", "of", definitions, instances
07:32:48 <Cale> The second line must be indented exactly the number of spaces that it is. No more and no less.
07:33:12 <rog_> Cale: i'd format it like: http://hpaste.org/10765#a1
07:33:15 <Cale> This is because the 'putStrLn' must line up with the 'x <-' in order to be part of that do-block
07:34:00 <rog_> Cale: that means that i can change the length of "main" without changing any indentation.
07:34:20 <Cale> You already can.
07:35:03 <rog_> Cale: but if you change "main" to "foobarbletharoony", then presumably you'd have to re-indent the following lines?
07:36:10 <Cale> Ah, okay, so in that sense.
07:36:19 <plutonas> having a list of three elements, each element can have one or two states, i would like to generate all possible lists, i'll give an example, if for example the states were positive and negative, an i had [1,0,2]i'd like to produce [[1,0,-2],[1,0,2],[-1,0,-2],[-1,0,2]]. Is there a function doing this kind of stuff?
07:36:58 <Cale> You could also write it like: http://hpaste.org/10765#a2
07:37:09 <Cale> (assuming that 'main' was actually something much longer)
07:37:41 <plutonas> of course i could have two 0's in my list which would produce two different lists, or no 0, which would produce 8
07:37:43 <Cale> > mapM (\x -> [x,-x]) [1,0,2]
07:37:46 <lambdabot>   [[1,0,2],[1,0,-2],[1,0,2],[1,0,-2],[-1,0,2],[-1,0,-2],[-1,0,2],[-1,0,-2]]
07:38:15 <rog_> Cale: sure. but on balance i think i prefer my way, as it puts the two monad statements on an equal footing - i can swap them or insert a line before the first one equally easily.
07:38:24 <Deewiant> > nub . mapM (\x -> [x,-x]) $ [1,0,2]
07:38:27 <lambdabot>   [[1,0,2],[1,0,-2],[-1,0,2],[-1,0,-2]]
07:38:41 <Cale> rog_: Sure, but you still should not have any tabs in your source files.
07:38:48 <plutonas> :t nub
07:38:50 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:38:51 <Cale> rog_: Have your editor convert them to spaces.
07:39:03 <Deewiant> Cale: why not? As long as you use them responsibly, it's fine.
07:39:15 <ziman> > map (\x -> [x,-x]) [1,0,2]
07:39:19 <lambdabot>   [[1,-1],[0,0],[2,-2]]
07:39:21 <Eridius> why the hell anyone would want to use hard tabs is beyond me
07:39:25 <Cale> Deewiant: Because Haskell is, in general, alignment sensitive.
07:39:26 <Eridius> it only serves to cause problems
07:39:39 <Cale> Deewiant: and tabs screw with alignment, in general.
07:39:56 <Deewiant> Cale: and if you use them responsibly, you won't have problems. :-)
07:40:00 <Cale> You have to be very careful to produce files where the choice of tab indentation won't matter.
07:40:07 <Cale> Which is silly.
07:40:08 <Cale> Just use spaces.
07:40:10 <ivanm> in haddock, how can I just have an un-attached chunk of documentation (i.e. a documentation for the next segment)?
07:40:17 <ivanm> use the $doc notation?
07:40:17 <rog_> Eridius: one reason is that it's only a single key to add or delete a tab.
07:40:19 <Deewiant> I do it pretty much automatically these days even though I use spaces for Haskell
07:40:22 <Cale> and configure your editor to do something sane when you press the tab key
07:40:24 <ziman> Eridius, because tabs mean just indentation. Spaces are used for different purposes.
07:40:28 <Eridius> rog_: so use an editor which supports the concept of soft tabs
07:40:43 <Cale> rog_: what editor are you using?
07:40:51 <rog_> Cale: acme
07:40:58 <Cale> Okay, I have no idea about acme.
07:41:16 <Cale> In vim,  :set expandtab   and possibly  :set smarttab
07:41:43 <rog_> Cale: it's a rob pike editor - powerful but minimalist. having used quite a few editors in the past, i'd be unwilling to give it up...
07:42:00 <Cale> Every reasonable text editor will have an option to auto-expand tabs, and treat multiple spaces as a tab when backspacing.
07:42:54 <Eridius> Cale: I don't know how to make emacs pretend it's using soft tabs when backspacing
07:42:59 <Eridius> but at least I figured out how to make it stop inserting hard tabs
07:43:02 <rog_> Cale: acme's not reasonable... but i have an unreasonable love for it.
07:43:07 <Ferdirand> some might add that using any value /= 8 for tab width is heresy :)
07:43:10 <Lord_Illidan> >enumFromThenTo 'A' 'A' 'A'
07:43:13 <quicksilver> Eridius: use kuribas' indentation mode.
07:43:18 <rog_> Cale: structural regexps, for example, are fantastic.
07:43:20 <Eridius> quicksilver: what's that?
07:43:30 <quicksilver> Eridius: then backspace moves you back to the previous point which is significant to haskell
07:43:40 <quicksilver> and tab moves you forward to the next significant point.
07:43:50 <Eridius> tab already works nicely for me with the haskell mode
07:43:58 <Eridius> although it has a few minor failings
07:44:06 <dmwit> > enumFromThenTo 'A' 'A' 'A' -- Lord_Illidan
07:44:07 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
07:44:21 <rog_> Ferdirand: if you're using a proportionally spaced font, then a "space" doesn't mean anything in particular when it comes to horizontal spacing.
07:44:22 <Deewiant> > ['A','A'..'A']
07:44:24 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
07:44:36 <Lord_Illidan> cool function, but I can't see why it's allowed to return an infinite list :|
07:44:49 <Cale> rog_: The Haskell compiler is still going to treat it as such though
07:44:51 <Deewiant> > [0,1..-1]
07:44:53 <lambdabot>   Not in scope: `..-'
07:44:56 <Deewiant> > [0,1.. -1]
07:44:58 <lambdabot>   []
07:44:58 <Lord_Illidan> and it also works in reverse, cool
07:45:04 <dmwit> Deewiant: That's a more convenient form for some things, but it's a lot harder to partially apply a list comprehension... =P
07:45:18 <Cale> rog_: So in order for Haskell source files to be readable, you must pick a monospace font, or have an editor smart enough to parse Haskell syntax.
07:45:24 <Deewiant> dmwit: I rarely have the need to, though
07:45:31 <dmwit> Right.
07:45:43 <Deewiant> Cale: or use only tabs.
07:45:43 <quicksilver> Eridius: well this solves your backspace problem
07:45:45 <xsdnyd> > [0,1..(-1)]
07:45:46 <lambdabot>   []
07:45:51 <Cale> Deewiant: No, that doesn't help
07:45:59 <Eridius> Cale: why would anybody ever code in a proportional font
07:45:59 <quicksilver> Eridius: and, indeed, also improves tab behaviour in the opinion of everyone I've asked :)
07:46:01 <Cale> Deewiant: If you're reading source files written by others.
07:46:03 <Deewiant> Cale: yes, it does, as long as you don't use them for alignment.
07:46:05 <Eridius> quicksilver: where can I find this?
07:46:06 <Cale> Eridius: I have no idea.
07:46:10 <mm_freak> > [1, 2 .. 0]
07:46:10 <dmwit> Eridius: It's a lot easier to read.
07:46:11 <lambdabot>   []
07:46:11 <Deewiant> Cale: okay, for that case not, yes.
07:46:12 <quicksilver> @where kuribas-indentation
07:46:12 <lambdabot> I know nothing about kuribas-indentation.
07:46:20 * quicksilver SCREAMs
07:46:21 <Cale> Otherwise, there will be conditions under which the meaning of code is ambiguous.
07:46:27 <Eridius> dmwit: we're talking about code here. Code belongs in monospace
07:46:31 <Eridius> it's not prose, it's *code*
07:46:31 <quicksilver> Cale: is LB totally incapable of remembering @where+ ?
07:46:32 <rog_> Cale: ... i've not encountered any examples so far that have needed actually within-line text alignment. and my code, i hope, has been reasonably readable.
07:46:35 <mm_freak> > iterate (+1) 0
07:46:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
07:46:41 <Deewiant> @seen kuribas
07:46:41 <lambdabot> I haven't seen kuribas.
07:46:42 <dmwit> Eridius: Code only belongs in monospace because you want a particular layout.
07:46:45 <Deewiant> preflex: seen kuribas
07:46:45 <preflex>  kuribas was last seen on #haskell 145 days, 4 hours, 56 minutes and 48 seconds ago, saying: dolio: I'll the other one this evening.
07:46:46 <mm_freak> oh
07:46:54 <Cale> Eridius: I would be happy to code in a non-monospace font if my editor was sufficiently smart about layout :)
07:46:55 <mm_freak> > [ 3, 2 .. 4 ]
07:46:57 <lambdabot>   []
07:46:58 <dmwit> Eridius: But suppose you could have that layout in a proportional font?
07:47:05 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
07:47:05 <lambdabot> I will remember.
07:47:05 <Cale> Eridius: but no editor exists which is smart enough :)
07:47:08 <quicksilver> Eridius: there.
07:47:10 <Lord_Illidan> What's a nice editor for haskell in Linux?
07:47:13 <Taejo> @ty on
07:47:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:47:19 <Taejo> Lord_Illidan: vim :)
07:47:19 <Cale> Lord_Illidan: vim or emacs
07:47:22 <dmwit> Lord_Illidan: vim, emacs ar ethe popular ones
07:47:24 <Lord_Illidan> Not those two
07:47:25 <mm_freak> i like emacs
07:47:25 <Apocalisp> yi
07:47:29 <Eridius> dmwit: you can't have layout in a proportional font because there's no guarantees from one proportional font to the next about the layout
07:47:37 <dmwit> Lord_Illidan: There's also leskah
07:47:40 <rog_> Cale: the only main thing i can't do is multiple clauses in a let statement. but i just use several let...in statements instead. it's not so bad.
07:47:47 <dmwit> Eridius: False.
07:47:53 <Eridius> dmwit: FileNotFound
07:47:55 <mm_freak> Eridius: you can, because space is always the same
07:48:07 <dmwit> Eridius: You can have layout in a proportional font if your editor makes your guarantees for you.
07:48:11 <Lord_Illidan> I'm using geany atm, not bad
07:48:11 <Cale> rog_: If you ever work on a project with another Haskell programmer, don't say I didn't warn you :)
07:48:12 <Eridius> mm_freak: layout consisting entirely of spaces is useless
07:48:24 <Deewiant> rog_: can't you do let \n\t x = foo \n\t y = bar, or what did you mean
07:48:25 <Lord_Illidan> dmwit, leskah?
07:48:29 <plutonas> why can't i write if a then b else if c then d else g, having the last else match the first if?
07:48:34 <Lord_Illidan> dmwit, Google doesn't know about it :|
07:48:36 <Eridius> dmwit: what's the point of using a proportional font if your editor isn't going to follow the font's layout rules?
07:48:46 <plutonas> does it have to do with types?
07:48:49 <mm_freak> Eridius: not if your editor supports laying out properly
07:48:51 <plutonas> should i use guards instead?
07:48:55 <Lord_Illidan> leksah, I think
07:49:06 <Deewiant> plutonas: because the last else doesn't match the first if, how could it?
07:49:08 <dmwit> ?hackage leksah
07:49:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/leksah
07:49:19 <Lord_Illidan> Yeah, you told me leskah :P
07:49:21 <Deewiant> plutonas: each if has one else, and you already gave one for the first one
07:49:22 <Cale> if a then b else if c then d else g = if a then b else (if c then d else g)
07:49:25 <dmwit> Lord_Illidan: sorry
07:49:29 <Cale> Is there any other way to parse that?
07:49:37 <Lord_Illidan> Not in AUR, damn
07:50:08 <quicksilver> > if False then 1 else if True then 2 else 3
07:50:09 <lambdabot>   2
07:50:10 <dmwit> Eridius: Have you heard of elastic tabstops?
07:50:11 <rog_> Deewiant: see http://hpaste.org/10765#a3
07:50:13 <plutonas> Cale: i would like parse something like (if a then b) (else if c then d) (else g)
07:50:14 <quicksilver> plutonas: sure, it works fine :)
07:50:21 <Eridius> plutonas: parsing an if expression is only ambiguous if the else clause is optional, which it isn't in haskell
07:50:22 <Eridius> dmwit: no
07:50:34 <dmwit> Eridius: Perhaps it's time you did.
07:50:34 <Cale> plutonas: Every 'if' has both a 'then' and an 'else' which are part of it.
07:50:38 <dmwit> ?go elastic tabstops
07:50:40 <Deewiant> rog_: can't you put a line break after the 'let'
07:50:41 <lambdabot> http://nickgravgaard.com/elastictabstops/
07:50:41 <lambdabot> Title: Elastic tabstops - a better way to indent and align code
07:50:41 <plutonas> Eridius: so i should put some default value?
07:50:45 <Deewiant> rog_: then indent a tab deeper
07:50:48 <plutonas> on the else clause i don't care about?
07:50:55 <rog_> if you only ever rely on indentation at the start of a line, then there's no problem with using tabs.
07:50:56 <plutonas> or is there something like lisps cond?
07:51:03 <rog_> as long as you don't mix tabs & spaces.
07:51:10 <Cale> plutonas: (else if c then d) is not an expression.
07:51:17 <quicksilver> plutonas: what you asked for works.
07:51:20 <quicksilver> plutonas: I just demonstrated it.
07:51:28 <quicksilver> plutonas: so I no longer understand what your question is.
07:51:29 <dmwit> rog_: My usual rule of thumb is that all lines should match "\t*[^\t]*".
07:51:32 <quicksilver> nesting if/then/else is fine.
07:51:43 <dmwit> rog_: (i.e. tabs are used for indentation, not alignment.)
07:51:52 <rog_> dmwit: yup. easy to check, too.
07:51:53 <plutonas> oh i see
07:52:02 <Cale> rog_: you could awkwardly put the 'let' on its own line, like with do :)
07:52:16 <rog_> dmwit: actually, i use tabs before comments too, where they don't matter.
07:52:19 <Cale> rog_: also, the 'in' generally goes at the start of a line
07:52:20 <Lord_Illidan> Seeing that it's an alpha version, any other recommendations?
07:52:47 <dmwit> rog_: That seems okay, but sometimes people line up comments on two consecutive lines that way... and then it's not ok. =)
07:53:13 <rog_> Cale: that's another example - if i did that, i'd have to do non-start-of-line alignment. and just like the do statement, i prefer independent lines.
07:53:23 <dmwit> Lord_Illidan: If none of the offerings satisfy you, I suggest you write your own with all the features you want. ;-)
07:53:41 <rog_> dmwit: agreed.
07:54:09 <Cale> Lord_Illidan: What's wrong with vim or emacs?
07:54:13 <dmwit> Well, that was a fun ten minutes.
07:54:14 * dmwit &
07:54:30 <Lord_Illidan> I want something a tad more IDE-ish, and not CLI based
07:54:40 <Lord_Illidan> I can use Vim in a pinch, but my keyboard isn't too good
07:55:04 <Cale> I usually just run vim in a window alongside ghci
07:55:14 <rog_> both vim and emacs are ancient and crufty.
07:55:16 <Cale> ghci provides all the IDEish features I'd ever use.
07:55:16 * rog_ ducks.
07:55:50 * Deewiant throws spiky lambdas at rog_
07:56:03 * Lord_Illidan shakes hands with rog_
07:56:32 <Deewiant> Lord_Illidan: you'd say that they're crufty and yet want an IDE? :-P
07:56:49 * rog_ defends with (\ _ -> ())
07:56:50 <Lord_Illidan> I want a GUI :D
07:57:04 <xsdnyd> In the statement "do ...; x <- getLine; ...; return x" the "<-" keyword is used to transform the IO String into a String, right? So i can work with the string and the last statement returns the String. The return result is an IO String. But how does haskell know, that the result has to be IO ... because i called 1 IO function?
07:57:05 <Cale> Lord_Illidan: there are GUI versions of both
07:57:19 <Cale> xsdnyd: yes
07:57:41 <Cale> xsdnyd: because the do block as a whole has to be a value in the same monad as each action in it
07:57:56 <xsdnyd> Cale: ah ok. again i learned something :)
07:57:59 <Cale> xsdnyd:  x <- getLine  means  "run the action getLine to produce x"
07:58:27 <Cale> The do-block as a whole is an expression which glues together all the actions in it into one large one.
07:58:51 <xsdnyd> ok :)
08:00:11 <Cale> Evaluating that expression doesn't do a whole lot which is visible, but *executing* it does. In the end, the only action in a compiled program which is actually executed is main, but it's usually built up from many smaller ones.
08:01:06 <leimy> xsdnyd: <- is not a keyword, just syntax :-)
08:01:16 <mauke> same thing
08:01:35 <mauke> next you'll be telling me + isn't a function :-)
08:01:35 <xsdnyd> leimy: http://www.haskell.org/haskellwiki/Keywords#.3C-
08:01:36 <lambdabot> Title: Keywords - HaskellWiki
08:01:46 <xsdnyd> :)
08:01:48 <leimy> mauke: that depends on whom you ask, and the context but in many cases you're correct
08:01:54 <leimy> mauke: + is not a function
08:02:03 <leimy> mauke: + is a function generator :-)
08:02:14 <quicksilver> bah
08:02:18 <quicksilver> I call humbug!
08:02:25 <quicksilver> + is a function and <- is a keyword.
08:02:38 <mauke> I call grouphug!
08:02:47 <leimy> xsdnyd: I call wiki's are unreliable.   :-)
08:03:26 <Cale> "This page lists all Haskell keywords, feel free to edit."
08:03:31 <leimy> :-)
08:04:33 <rog_> Cale: editor wars aside, back to http://hpaste.org/10764, you said: "An easy way to fix it is to stick  forall a.  just after the  instance". i'm not entirely sure what you mean here, and haven't managed to get past the syntax checker yet...
08:04:48 <quicksilver> rog_: -XScopedTypeVariables
08:04:53 <quicksilver> is needed to make it work.
08:04:55 <Cale> rog_: ah, that is an extension, yes
08:05:06 <quicksilver> or {-# LANGUAGE ScopedTypeVariables #-}
08:05:21 <quicksilver> the haskell98 workaround is liberal use of asTypeOf
08:05:37 <rog_> quicksilver: could you paste a quick example?
08:06:34 <Cale> http://hpaste.org/10764#a3
08:07:03 <mauke> show (Bitset x) = show (minBound `asTypeOf` x)
08:07:07 <mauke> wait, no
08:07:15 <Cale> The trouble in this case is that you can't possibly use asTypeOf, because you don't have a value of type a
08:07:22 <mauke> right, x is an Integer
08:07:43 <Cale> So there's just no way to do it without extensions.
08:07:56 <Cale> (but it is a little bit silly)
08:08:28 <Jedai> leimy: So (+) is a "function generator" because of the type class ?
08:08:36 <leimy> no... :-)
08:08:41 <leimy> it's a function
08:08:43 <Cale> Why would the 'show' for Bitsets show the minimum element of the phantom type?
08:08:58 <leimy> I was calling it a function generator because of Haskell's auto-Currying
08:09:13 <leimy> like  (+) 1 is a function
08:09:22 <mauke> then id is also a function generator
08:09:30 <leimy> sure
08:09:36 <mauke> :t flip id
08:09:37 <lambdabot> forall b c. b -> (b -> c) -> c
08:09:37 <Cale> leimy: But also, it's parametrised over the type of its parameters -- it also secretly takes a dictionary for the Num typeclass :)
08:09:50 <leimy> Cale: interesting :-)
08:09:52 <Jedai> leimy: Oh I see (well it's a higher-order function then)
08:09:55 <leimy> yes
08:09:56 <quicksilver> Cale: although technically that's an implementaiton detail.
08:09:58 <Cale> :t (+)
08:09:59 <lambdabot> forall a. (Num a) => a -> a -> a
08:10:03 <Cale> quicksilver: well, yes
08:10:09 <leimy> :t (+) 1
08:10:10 <lambdabot> forall t. (Num t) => t -> t
08:10:18 <leimy> :t (+) 1 2
08:10:19 <lambdabot> forall t. (Num t) => t
08:10:39 <leimy> so you could say (+) 1 2 is a function that always returns 3
08:10:47 <leimy> but it's a bit silly
08:10:50 <leimy> just call it a value
08:10:51 <leimy> :-)
08:10:56 <BeelsebobWork> leimy: you couldn't
08:10:57 <Cale> But in whatever type it is that you ask for :)
08:10:59 <leimy> functions are values in Haskell.
08:11:02 <BeelsebobWork> it's not a function that returns 3
08:11:08 <BeelsebobWork> it's a constant, with value 3
08:11:11 <leimy> BeelsebobWork:  if you can call <- a keyword I can call that a value :-)
08:11:21 <rog_> Cale: it wouldn't. but it would enumerate all values of the phantom type to determine membership in the actual set.
08:11:28 <leimy> In functional programming you only deal with values
08:11:29 <Cale> BeelsebobWork: It's a function which takes a typeclass dictionary for Num and produces 3 for the type that it corresponds to :)
08:11:33 <leimy> it just happens that functions are values
08:11:38 <BeelsebobWork> Cale: yeh, true
08:11:40 <idnar> a constant is just a nullary function :P
08:11:46 <leimy> yes
08:11:48 <BeelsebobWork> but thanks to the monomorphism restriction it behaves like a CAF
08:11:54 <leimy> Almost indistinguishable from a constant value
08:12:07 <Jedai> idnar: Except this one isn't really nullary thanks to the typeclass
08:12:16 <BeelsebobWork> a nullary function is non existant -- a function is something with type a -> b
08:12:23 <BeelsebobWork> there *only* are unary functions in Haskell
08:12:26 <Cale> But yeah, I tend not to call things functions unless they have -> as the top level type constructor in their types
08:12:36 <BeelsebobWork> and CAFs
08:12:36 <mauke> (nullary function)--
08:13:25 <parodyoflanguage> > 700000000000 / 300000000
08:13:27 <lambdabot>   2333.3333333333335
08:14:06 <Cale> I actually really like that insight, the insight that if your functions are going to be first-class values, then there's no point in having anything other than functions of one parameter.
08:14:38 <tac-tics> Is there a math term for a pair of functions such that f . g = id, but g . f != id?
08:15:14 <Cale> yes...
08:15:28 <rog_> Cale: .... unless you want named, optional parameters, i guess.
08:15:32 <Cale> g is a section of f and f is a retraction of g
08:15:47 <Cale> er
08:15:52 <leimy> I would call <- a lexeme, not a keyword, but I guess keywords themselves are lexemes too.
08:15:53 <tac-tics> Thanks Cale
08:16:00 <Cale> Well, that's if g . f is not necessarily id
08:16:12 <quicksilver> tac-tics: half-inverse is also used.
08:16:15 <Cale> I don't know about imposing the restriction that it's not the identity.
08:16:23 <Cale> Yeah, f is also called a left inverse for g
08:16:32 <Cale> and g a right inverse for f
08:16:44 <Cale> (maybe easier to remember)
08:16:49 <tac-tics> yeah
08:16:54 <tac-tics> I'm running into these things lately
08:17:00 <quicksilver> and you might call them adjoints
08:17:08 <Cale> One way to remember which one is the retraction is that it's the one which is "undoing" things.
08:17:21 <Cale> Like retracting a statement that you made :)
08:17:55 <leimy> I'm wondering what the real advantage of a Monad is over just programming with continuations.
08:17:55 <Cale> Of course, that takes a kind of strict-evaluation viewpoint ;)
08:18:04 <leimy> but that's because I'm pretty new to both of them :-)
08:18:13 <tac-tics> I was thinking about these the other week in terms of derivatives and anti-derivatives, and I just came across them again today with unicode encoding/decoding functions
08:18:17 <leimy> I don't know if, in general, you can compose continuations like you can monads.
08:18:26 <Cale> leimy: Continuations form a monad.
08:18:34 <leimy> hmm
08:18:36 <Cale> leimy: Typically, monads don't compose.
08:18:58 <Cale> (but monadic computations in the same monad compose with each other)
08:19:07 <leimy> yeah, I guess that's what I really meant :-)
08:19:18 <ivanm> is it just me, or is community.haskell.org down?
08:19:18 <leimy> you can sometimes lift some stuff over another monad
08:19:24 <leimy> is that the right term? lift over"?
08:19:36 <leimy> or lift up into?
08:19:55 <Cale> Are you referring to what's done with monad transformers?
08:19:55 <leimy> I guess that's not the same as composition though.
08:20:00 <leimy> Kind of
08:20:07 <Cale> Monad transformers compose nicely.
08:20:10 <leimy> I mean, if I am coding in the Reader monad
08:20:16 <leimy> and I want to do IO I can liftIO
08:20:24 <Cale> Actually, you can't. :)
08:20:25 <leimy> as a way to get the type system happy :-)
08:20:30 <leimy> I can't?
08:20:36 <Cale> You can only do that if you're in the  ReaderT r IO  monad.
08:20:46 <leimy> Ah weird!
08:20:51 <leimy> I wondered why that worked at one point
08:21:13 <Cale> Which is like Reader, in that it supports the same primitives (via a typeclass)
08:21:18 <Cale> but it also handles IO
08:21:46 <leimy> It makes sense
08:22:46 <leimy> so continuations form a monad, and monads can be expressed by arrows, as can regular functions?
08:22:54 <Cale> yes
08:22:55 <leimy> so we're really always dealing with arrows?
08:23:06 <tac-tics> isomorphically, yes
08:23:09 <Cale> Well, yeah, you can always generalise things a bit more :)
08:23:09 <leimy> neat
08:23:24 <leimy> The nice thing about continuations, in other languages, are then only syntax
08:23:35 <tac-tics> but in the same way that children doing addition in 1st grade are really manipulating sets in set theory ;-)
08:23:36 <Cale> Arrows are significantly weaker in terms of what you can say about them than monads.
08:24:00 <leimy> Cale: but that's where they're able to capture more behaviors as well right?
08:24:15 <leimy> less restriction means they're even more "dangerous" code.
08:24:18 <Cale> The more general a basis of combinators you pick, the fewer useful library functions you can write which will work in all instances.
08:24:31 <Cale> But the more instances you get :)
08:24:35 <leimy> I see
08:25:12 <quicksilver> waht does "monads can be expressed by arrows" mean?
08:25:35 <quicksilver> I would say monads and arrows are related but incomparable
08:25:46 <Cale> Well, every monad gives rise to a particular arrow.
08:25:55 <Cale> Its Kleisli arrow of functions  a -> M b
08:25:58 <quicksilver> yes, but not all arrows arise in such a way.
08:26:02 <Cale> right
08:26:23 <quicksilver> and the kleisli arrow is not the monad
08:26:39 <quicksilver> in the important sense that combining the kleisli arrow with the arrow combinators is strictly less expressive
08:26:40 <Cale> Well...
08:26:43 <quicksilver> than using the original monad.
08:27:05 <quicksilver> you need ArrowApply to regain a full translation, IIRC.
08:27:35 <Cale> Well, any ArrowApply certainly is a Monad.
08:28:04 <leimy> I guess I was speaking more generally, in terms of capturing the expression of different computational forms.
08:28:07 <leimy> if that makes any sense :-)
08:28:11 * leimy needs coffee
08:28:46 <leimy> It seems Arrows allow for the expression of more kinds of computation than do Monads, but can cover all that Monads already covers.
08:28:56 <quicksilver> not unless you include ArrowApply, no
08:29:07 <quicksilver> and ArrowApply is pretty much out of the 'spirit' of arrows, IMO.
08:29:10 <leimy> I'm not saying they're the same.
08:29:16 <Lord_Illidan> forget leksah, isn't building on my setup
08:29:24 <Lord_Illidan> so vim+geany it is, then
08:29:39 <quicksilver> I would say Arrow allows for the expression of more kinds of computation than Monad - but there are things Monad can do that Arrow can't.
08:29:43 <quicksilver> i.e. they are incomparable.
08:29:45 <leimy> quicksilver: honestly I need to review my very elementary understanding of Arrow
08:30:02 <leimy> quicksilver: Monad can do what that Arrow can not?
08:30:04 <humasect> Could not find module `Data.Generics': it is a member of package base-3.0.3.0, which is hidden  <-- how do i add this into cabal?
08:30:09 <Cale> quicksilver: If you have an Arrow instance for your Kleisli arrow, and you have the function  A b c -> b -> M c, then you can write the Monad instance in terms of it.
08:30:21 <Cale> I think...
08:30:34 <Cale> hmm...
08:30:49 <quicksilver> leimy: Monad can make later computations depend on the result of earlier ones
08:30:49 <leimy> I thought Monads captured a subset of what Arrows were capable of.
08:31:02 <quicksilver> leimy: Monad permits more complex computation -> data dependencies
08:31:12 <quicksilver> leimy: arrow forces you to linearise the computation -> data dependencies
08:31:20 <quicksilver> (and applicative permits none at all)
08:31:58 <leimy> that would be why you say you can't compare them :-)
08:32:03 <leimy> makes sense
08:32:11 <Cale> leimy: Basically, there are more useful functions you can write which work in all Monads than those you can write which work in all Arrows
08:32:26 <humasect> (ok i've fixed it=)
08:32:33 <quicksilver> there are some in both camps.
08:32:44 <leimy> Cale: So really, it sounds like in a practical sense, one should stick to Monads, until they can't do what you want.... then in some cases use Arrows if they solve the problem.
08:32:48 <quicksilver> There are things you can write over all arrows which you can't write over all monads, and vice versa.
08:32:51 <Cale> leimy: right
08:32:55 <leimy> Parsing seemed to be the motivating example in favor of Arrows.
08:33:01 <Cale> quicksilver: really?
08:33:11 <quicksilver> yes.
08:33:11 <mikr^Jolem> Hi! anyone that can help me? im doing a suduko program and i dont know how to fix the block so it becomes 3x3
08:33:17 <leimy> quicksilver: you've achieved some meta-understanding I'm not at yet :-)
08:33:40 <Cale> quicksilver: It would seem to me that if you can write something which works on a general arrow, you could specialise it to Kleisli arrows.
08:33:48 <mauke> data Mushroom badger = Mushroom badger badger badger badger badger badger badger badger badger
08:33:59 <ivanm> lol
08:33:59 <leimy> where's the snake
08:34:05 <mauke> deriving Snake
08:34:09 <leimy> ah
08:34:21 <leimy> sadly I don't think you can use derviing that way :-)
08:34:25 <leimy> er deriving.
08:34:46 <ivanm> @remember mauke <mauke> data Mushroom badger = Mushroom badger badger badger badger badger badger badger badger badger <leimy> where's the snake <mauke> deriving Snake
08:34:46 <lambdabot> Done.
08:34:59 <Cale> data All your base = Are | Belong | To | Us
08:35:10 <ivanm> this is HaskellMeme time, is it?
08:35:37 <Cale>   deriving Zig
08:35:48 <Cale>    -- for great justice
08:36:20 <quicksilver> Cale: yes, you're right, I muddled that up.
08:36:40 <quicksilver> Cale: of course what I mean is "there are concrete data structures which implement arrow but can never implement monad"
08:36:51 <quicksilver> duality--
08:36:52 <Cale> oh, yes
08:37:14 <Cale> There's a kind of contravariance there. :)
08:37:27 <Cale> It happens throughout mathematics.
08:38:12 <Cale> The more axioms you specify, the more theorems you can prove, but fewer structures will satisfy under those axioms.
08:38:14 <Cale> er
08:38:18 <Cale> s/under//
08:39:41 <quicksilver> so: it is true that any monad gives rise to an arrow, but not all arrows are of that form.
08:40:01 <quicksilver> so some arrows are not the kleisli arrow of any monad.
08:40:12 <Cale> and every arrow-combinator gives rise to a monadic-combinator
08:40:19 <quicksilver> what I *don't* know is whether every ArrowApply arises as the kleisli monad of an arrow.
08:40:29 <Cale> It apparently does.
08:40:36 <Heffalump> Cale: unless the combinator is higher-order, I'd have thought
08:41:06 <quicksilver> The other thing I don't know is whether anyone can think of any interesting arrows (about from the S-D parser) which are not in fact the kleisli arrow of a monad.
08:41:18 <quicksilver> because the S-D parser is the only one I've seen.
08:41:18 <Heffalump> quicksilver: Yampa
08:41:26 <Cale> Heffalump: well, higher-order in what sense? If something works for any arrow type, it certainly works for all the Kleisli arrows, and you can then specialise.
08:41:44 <Heffalump> Cale: oh, yeah, ok.
08:41:55 <Heffalump> though not if it changes the underlying arrow type
08:41:55 <Lord_Illidan> can someone refresh my memory on what the $ sign does in haskell?
08:42:02 <Cale> Lord_Illidan: f $ x = f x
08:42:05 <Heffalump> e.g. an arrow transformer that doesn't preserve kleisli-ness
08:42:09 <Lord_Illidan> ah ok, thanks
08:42:17 <Cale> Lord_Illidan: but $ binds very weakly to its parameters
08:42:36 <Cale> Lord_Illidan: So you can write things like  f . g . h $ 6 + 7
08:42:47 <Lord_Illidan> Also, is there a way to step through a function?
08:42:50 <Cale> Without fear of needing parens around f . g . h or 6 + 7
08:42:50 <Lord_Illidan> in ghci
08:42:58 <Heffalump> yes, the ghci debugger lets you do that
08:42:59 <Cale> Lord_Illidan: you can use :trace
08:43:06 <Cale> and the other ghci debugger commands
08:43:13 <Cale> There's a tutorial somewhere...
08:43:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
08:43:41 <lambdabot> Title: 3.5.The GHCi Debugger, http://tinyurl.com/2orwlb
08:44:06 <Cale> It really needs more editor integration. :)
08:44:15 <quicksilver> Heffalump: interesting; can you characterise the yampa arrow?
08:44:49 <Lord_Illidan> thanks
08:44:53 <Heffalump> quicksilver: well, I don't know it very well. But AIUI they moved from a monad to stop people writing some invalid programs that "leaked time", i.e. kept around a value from an earlier event that they should not have had access to any more.
08:45:04 * quicksilver nods
08:45:14 <Heffalump> so it seems plausible that it really isn't an arrow
08:45:22 <quicksilver> I had heard something like that, yes. But not been able to make it precise.
08:45:28 <quicksilver> I know TVs aren't really arrows.
08:46:30 <quicksilver> newtype SF a b = SF { runSF :: DTime -> a -> (b, SF a b) }
08:46:45 <Lord_Illidan> Hmm, I am setting breakpoints
08:46:52 <Lord_Illidan> but the program is still not stopping
08:47:28 <Cale> Are you certain that the program is reaching your breakpoints?
08:47:51 <Cale> One thing you can do is  :set -fbreak-on-exception
08:47:55 <Cale> and then :trace foo
08:48:08 <Cale> and then if you hit Ctrl-C, the program will pause
08:48:17 <Cale> and let you look around wherever you are
08:48:24 <Lord_Illidan> yes, I am using :step function
08:48:40 <Lord_Illidan> and then when I run function, it still runs without pausing
08:49:48 <Cale> Is the function anything simple enough for us to look at?
08:49:55 <mauke> haha, "I can't seem to type Monday anymore; it always comes out Monad"
08:50:20 <Lord_Illidan> restarted ghci it's working
08:50:31 <Cale> hmm, okay :)
08:50:40 <Lord_Illidan> sure, it's on the haskellwiki
08:50:47 <Lord_Illidan> http://www.haskell.org/haskellwiki/Euler_problems/11_to_20#Problem_18
08:50:50 <lambdabot> Title: Euler problems/11 to 20 - HaskellWiki, http://tinyurl.com/4uvtya
08:50:59 <Lord_Illidan> I'm trying to understand the haskell code being used
08:52:00 <Cale> okay
08:52:04 <leimy> quicksilver: so all bugs are insects but not all insects are bugs :-)
08:52:14 <leimy> :-)
08:52:24 <Cale> f x y z adds x to the maximum of y and z
08:52:45 <leimy> So it is true that one can implement any Monad as an arrow instead?
08:53:00 * leimy had to go away for a moment
08:53:17 <Cale> leimy: You can, but fewer useful functions will be available for writing your computations.
08:54:22 <Cale> Lord_Illidan: So then what is g xs ys doing? It's taking each element of xs, and adding it to the max of the corresponding and the following element of ys
08:55:38 <leimy> Cale: right :-)
08:55:43 <leimy> due to the lack of restrictions on the Arrow
08:55:52 <Cale> leimy: right.
08:55:54 <leimy> vs the stuff you can already know due to the monad's type.
08:56:06 <Cale> Lord_Illidan: So now imagine what the foldr1 does
08:56:09 <leimy> neato
08:56:35 * leimy needs to write his permute function for ByteString sometime....
08:56:46 <Lord_Illidan> wait if you have g xs ys
08:56:53 <Lord_Illidan> does that mean that g is taking 2 arguments?
08:56:57 <Cale> yes
08:57:15 <Cale> (It had better, since it's the function parameter to foldr1)
08:57:33 <maltem> Lord_Illidan: It may be due to problem_18's being a CAF that breakpoints don't work
08:57:33 <Lord_Illidan> So how does that work in the foldr1?
08:57:40 <Lord_Illidan> CAF?
08:58:01 <maltem> Lord_Illidan: if you define it as problem_18 () = ..., then calling problem_18 () will stop at the specified breakpoints
08:58:17 <hackage> Uploaded to hackage: Graphalyze 0.1
08:58:19 <Lord_Illidan> ok, but what's a CAF?
08:58:26 <Cale> You can think of this as adding each element in xs with the maximum of the two maximal sums over the paths that go further down the triangle
08:58:48 <maltem> Lord_Illidan: I forgot what the abbreb. stands for
08:58:54 <maltem> abbrev.
08:59:04 <Heffalump> Constant/Common Applicative Form
08:59:05 <Cale> Lord_Illidan: CAF stands for constant applicative form. Basically anything which is a constant.
08:59:19 <Lord_Illidan> hell, I forgot that the function to foldr1 should always have 2 arguments
08:59:20 <Heffalump> most importantly used in the context of top-level constants
08:59:32 <Lord_Illidan> That was getting me
08:59:44 <Heffalump> the type system should tell you that
08:59:47 <Heffalump> didn't it?
08:59:50 <Lord_Illidan> I have to go, people.. but thank you very much for your help, yes Heffalump
08:59:53 <Lord_Illidan> :t foldr1
08:59:54 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
08:59:55 <Lord_Illidan> :D
09:00:06 <maltem> Cale: is this correct debugger behaviour, though?
09:00:09 <Heffalump> ok, so that wasn't what you needed to debug
09:00:17 <Lord_Illidan> I wanted to see the internals
09:00:22 <Cale> Lord_Illidan: So it produces something like  g [75] (g [95,64] (.... (g [63,66,04,68,...] [04,62,98,27...]) .... ))
09:00:35 <Lord_Illidan> you know, step through it step by step so I could see the internal workings
09:00:48 <Lord_Illidan> I'm not too interested in the final result, I just want to learn haskell
09:01:11 <Cale> even though that will start evaluating at the outermost position
09:01:16 <Lord_Illidan> I'll be back later, but thank you very much everyone.
09:01:21 <Cale> let's look at what the innermost g is going...
09:01:23 <Cale> oh, okay :)
09:04:03 <dcoutts> SamB_XP, vegai: you called?
09:04:03 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:04:14 <mauke> oh hi, dcoutts
09:04:19 <mauke> I just had a problem with cabal-install
09:04:59 <dcoutts> cajun-rat: did you figure out the gtk2hs threads issue? find the gtk2hs FAQ?
09:05:12 <mauke> xhtml-3000.2.0.1 failed during the final install step. The exception was:  /usr/local/share/doc/xhtml-3000.2.0.1: createDirectory: permission denied (Permission denied)
09:05:28 <mauke> but a manual build/install worked fine
09:05:42 <dcoutts> mauke: were you doing a --global install?
09:05:47 <mauke> yes
09:05:54 <mauke> where "worked fine" = doesn't touch anything in /usr because it's supposed to go in ~/usr/local
09:06:18 <mauke> I have a ghc installation in my home and PREFIX is set accordingly
09:06:30 <dcoutts> mauke: I bet you did: cabal configure --prefix=blah; cabal build; cabal install
09:06:47 <dcoutts> mauke: but cabal install really means configure + build + install
09:06:53 <mauke> er, I actually did 'cabal upgrade'
09:07:05 <dcoutts> oh, ok
09:07:13 <dcoutts> mauke: and didn't set the prefix?
09:07:32 <mauke> and my ~/.cabal/config sets user-prefix and global-prefix to "/home/mauke/usr/local"
09:07:34 <dcoutts> mauke: or is this prefix set already in the ~/.cabal/config?
09:07:36 <mauke> apparently not
09:08:01 <dcoutts> mauke: ah, hmm. so you think the config is getting ignored
09:08:24 <mauke> it worked for 'cabal upgrade cabal-install', which I ran immediately before that
09:09:08 <dcoutts> mauke: can you file a ticket with as much  detail as possible so we can reproduce it
09:09:20 <dcoutts> esp, version numbers etc, what config was used
09:10:46 <mauke> ok, trying to reproduce ...
09:11:06 <Igloo> Hmm, now www.haskell.org has stopped talking to me. They're dropping like flies!
09:11:21 <Igloo> Ah, working again now
09:11:53 <plutonas> having a list of sublists, how do i map a function on every sublist?
09:12:37 <plutonas> i mean [[a, c], [b, d]] i want to produce [(map fn [a, c]), (map fn [b, d])]
09:12:53 <BMeph> map.map
09:14:25 <plutonas> thank you BMeph
09:14:40 <BMeph> plutonas: Happy to help. :)
09:17:43 <mauke> dcoutts: I can reproduce it after unregistering the new xhtml and running upgrade again. I'm including cabal/Cabal/ghc versions and the cabal config. what other information would be useful?
09:25:10 <mauke> oh shi
09:26:03 <mauke> I misdiagnosed the problem
09:26:20 <mauke> EVERYTHING fails with the new cabal-install and/or Cabal
09:26:39 <plutonas> probably my last question, in case you got tired of me :) : having two lists [elt1, elt2, elt3] and [pos1, pos2, pos3], how can i produce the permutation of the second list, that minimizes abs(pos1 - elt1) + abs(pos2 - elt2) + abs(pos3 -elt3) ?
09:26:56 <mauke> "Using install prefix: /usr/local"
09:29:30 <plutonas> i mean the first list has fixed order, i want to find the order of the second list that optimizes something
09:30:12 <Deewiant> is there a "recursively delete directory contents" function which does /not/ follow symlinks, somewhere?
09:30:22 <byorgey> plutonas: just produce all permutations of the list, map the evaluation function over it, and find the minimum
09:30:58 <byorgey> there's probably some example code on the wiki somewhere for finding all permutations of a list
09:31:09 <mmorrow> Deewiant: isn't there a isSymLink? (write your own?)
09:31:16 <plutonas> oh there's no function?
09:31:19 <plutonas> ready function i mean
09:31:27 <Deewiant> mmorrow: not that I can find
09:31:35 <mmorrow> Deewiant: oh. hmm
09:31:44 <Baughn> Is there an explanation of the ghc evaluation model somewhere?
09:31:52 <mmorrow> Deewiant: what module are you using?
09:31:55 * mmorrow looks
09:32:06 <quicksilver> Baughn: yes, the spineless tagless book/paper
09:32:18 <Zao> mmorrow: If there were one, I'd be surprised if it grokked Vista symlinks.
09:32:24 <Deewiant> mmorrow: I'm just looking at System.Directory, it doesn't either have such a rm -r function nor a isSymlink
09:32:36 <mauke> getSymbolicLinkStatus
09:32:38 <mmorrow> Zao: /me becomes scared
09:32:39 <mauke> it's in posix
09:32:43 <Baughn> quicksilver: Righto. Is that what I should look at to write an interpreter too?
09:33:00 <mmorrow> yeah, it's in a Posix module
09:33:04 <Zao> mmorrow: http://en.wikipedia.org/wiki/Symbolic_link#Windows_Vista_symbolic_link
09:33:11 <lambdabot> Title: Symbolic link - Wikipedia, the free encyclopedia, http://tinyurl.com/mf3oj
09:33:30 <quicksilver> Baughn: it should be required reading for anyone involved in the implementation of functional languages :)
09:33:47 <quicksilver> Baughn: not saying you have to do it that way, but you should at least understand those choices before making your own.
09:34:21 <mmorrow> Zao: urrghh.
09:34:24 <Deewiant> I'd really rather not have to write both the posix and the win32 code
09:34:32 <Deewiant> I just want to remove a directory safely :-/
09:35:37 <mmorrow> Deewiant: system "insert hackery here" ? (ugly yes, easy yes)
09:35:46 <Deewiant> mmorrow: no, I want this to be robust.
09:36:01 <mmorrow> fair enough
09:36:26 <mmorrow> i really don't know what to do on windows
09:40:03 <rog_> for what it's worth, here's what i ended up with: http://hpaste.org/10762#a1
09:42:26 <rog_> BTW, what *is* a nice canonical way of concatenating a string list joined by strings (e.g. join "," ["foo", "bar"] -> "foo, bar"; join ", " [] -> "") ?
09:42:56 <wjt> > intercalate "," ["foo","bar"]
09:42:56 <quicksilver> intercalate
09:42:57 <lambdabot>   "foo,bar"
09:43:10 <Deewiant> (obvious name, isn't it?)
09:43:29 <plutonas> how do i go from [[a, b], [c, d]] to [a,b,c,d]+
09:43:30 <plutonas> ?*
09:43:31 <lambdabot> Maybe you meant: . ? @ v
09:43:34 <rog_> not in the standard prelude though
09:43:35 <Deewiant> > concat [[a,b],[c,d]]
09:43:37 <lambdabot>   [a,b,c,d]
09:43:41 <Deewiant> rog_: no, but in Data.List
09:43:43 <plutonas> thanks again!
09:43:49 <dcoutts> mauke: which version?
09:43:52 <mmorrow> Baughn: don't know what level you're looking to write an interp at, but this is really cool: http://www.cs.york.ac.uk/fp/darcs/hhi
09:43:58 <rog_> cool. thanks.
09:44:05 <mauke> dcoutts: filed as #365
09:45:12 <dcoutts> mauke: thanks
09:45:22 <mmorrow> Baughn: (unfortunately you need yhc to generate the yhc-core :()
09:46:31 <Deewiant> speaking of yhc, anybody managed to compile Catch recently? I think my version of yhc-core (the only one on hackage) is too new
09:47:41 <mmorrow> Deewiant: i have the code, don't recall if i ever got it built... i may try in a bit though now that you mention it
09:49:58 <thoughtpolice> Deewiant: i tried a while back and got failure :[
09:50:27 <Deewiant> preflex: seen ndmitchell
09:50:27 <preflex>  ndmitchell was last seen on #haskell 33 days, 7 hours, 50 minutes and 46 seconds ago, saying: i think i just broke hackage: http://hackage.haskell.org/packages/archive/pkg-list.html
09:50:30 <Deewiant> preflex: seen ndm
09:50:31 <preflex>  ndm was last seen on #xmonad 32 days, 16 minutes and 17 seconds ago, saying: cool :)
09:50:32 <lambdabot> Title: HackageDB: packages by category
09:50:35 <Deewiant> hmph
09:50:38 <mmorrow> yeah, looking in the directory, it doesn't look like i got it built either
09:59:15 <mmorrow> nice, preflex is back
09:59:28 <mmorrow> preflex: seen lunabot
09:59:29 <preflex>  Sorry, I haven't seen lunabot
09:59:34 <mmorrow> preflex: seen mmorrow
09:59:35 <preflex>  mmorrow was last seen on #haskell 6 seconds ago, saying: preflex: seen lunabot
09:59:49 <mmorrow> , 42
09:59:50 <Deewiant> hmm
09:59:52 <Deewiant> @seen ndm
09:59:53 <lambdabot> I haven't seen ndm.
09:59:54 <lunabot>  42
09:59:55 <Deewiant> @seen ndmitchell
09:59:55 <lambdabot> I haven't seen ndmitchell.
09:59:59 <Deewiant> ah well
10:00:30 <mmorrow> i definitely saw him here w/in the last week
10:08:21 * mmorrow builds 6.10
10:09:17 <mml_> is there a standard fn akin to takeWhile, I might call it takeThrough, that works the same but also includes the first element for which the predicate is false?
10:10:35 <mmorrow> not that i know of
10:10:37 <EvilTerran> unfortunately, no
10:10:44 <therp> @ho split
10:10:44 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
10:10:48 <mmorrow> @src takeWhile
10:10:48 <lambdabot> takeWhile _ []                 =  []
10:10:48 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:10:48 <lambdabot>                    | otherwise =  []
10:10:55 <mmorrow> roll your own?
10:11:13 <mmorrow> | otherwise =  [x]
10:11:26 <mml_> mmorrow: happy to roll my own, but i almost always find when i come up with such things, they are hiding somewhere else. :)
10:11:38 <mmorrow> heh, i hear you :)
10:12:02 * mmorrow loves @src
10:12:04 <therp> @hoogle [a] -> (a -> Bool) -> ([a],[a])
10:12:04 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
10:12:05 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
10:12:05 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
10:13:16 <mmorrow> , let takeWhile' p = uncurry (++) . fmap (take 1) . span p in takeWhile (<4) [0..9]
10:13:17 <lunabot>      Ambiguous occurrence `uncurry'
10:13:21 <mmorrow> fug
10:13:22 <therp> mml_: just use break
10:14:07 <mml_> therp: or span :)
10:14:16 <mmorrow> does anyone know what category-extras module ucurry is in off the top of their head?
10:14:34 <therp> mml_: ah yes, span seems more natural as you the predicate isn't inverted
10:14:36 <EvilTerran> takeThrough p xs = case span p xs of (ts, []) -> trues; (ts, f:fs) -> ts ++ [f]
10:14:37 <therp> -you
10:14:47 <EvilTerran> er, s/trues/ts/
10:15:07 <EvilTerran> slightly unfortunate need for (++) in that approach, but ah well
10:15:44 * EvilTerran would just write it with explicit recursion, styled after takeWhile, TBH
10:15:44 <mmorrow> found it
10:16:03 <EvilTerran> working with prelude functions isn't always neater
10:16:56 <mmorrow> , let takeWhile' p = uncurry (++) . fmap (take 1) . span p in takeWhile (<4) [0..9]
10:17:01 <lunabot>  [0,1,2,3]
10:17:03 <mmorrow> crap
10:17:06 <mmorrow> , let takeWhile' p = uncurry (++) . fmap (take 1) . span p in takeWhile' (<4) [0..9]
10:17:09 <lunabot>  [0,1,2,3,4]
10:18:15 <mmorrow> yeah, the (++) there makes me think the directly recursive version would be better
10:21:42 * EvilTerran can envisage a version involving MaybeT Writer
10:22:00 <EvilTerran> gratuitous use of monads (and indeed transformers), tho
10:29:02 * BMeph waits for the ref to flag EvilTerran's play...
10:30:34 <pfo> is there a way to have homogenous lists in haskell?
10:30:48 <Heffalump> umm, []...
10:30:52 <Heffalump> do you mean heterogenous?
10:31:13 <lament> pfo: if you mean heterogenous, the short answer is "no"
10:31:14 <pfo> oh
10:31:15 <pfo> yeah
10:31:38 <ddarius> What would you do with such a list?
10:31:56 <dibblego> gaze in wonder at at all the different types of elements!
10:32:00 <pfo> a lisper from the office bitched about haskell's homogenous only lists
10:32:01 <pfo> :)
10:32:28 <pfo> i'd do probably something like ike dibblego said
10:32:28 <arjanb> you could use Hlist: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HList
10:32:29 <lambdabot> Title: HackageDB: HList-0.1
10:32:35 <lament> the short answer is "no"
10:32:41 <lament> the longer answer is "see Data.Typeable"
10:32:54 <lament> an even longer answer is "Haskell isn't Lisp - for a reason"
10:33:49 <Philippa_> and the best one is "your 'heterogenous' lists almost certainly have something in common - work out what and tell the type system about it"
10:33:56 <lament> arjanb: by Oleg, why am I not surprised :)
10:33:56 <mmorrow> , [toDyn "asdf", toDyn (42::Int), toDyn [[[('\10000',())]]], toDyn print]
10:33:58 <lilac> data HList = HCons (forall x. x) HList | HNil
10:34:04 <lunabot>  [<<[Char]>>,<<Int>>,<<[[[(Char,())]]]>>,<<() -> IO ()>>]
10:34:28 <mmorrow> , fmap fromDynamic [toDyn "asdf", toDyn (42::Int), toDyn [[[('\10000',())]]], toDyn print] :: [Maybe Int]
10:34:30 <lunabot>  [Nothing,Just 42,Nothing,Nothing]
10:34:41 <mmorrow> , fmap fromDynamic [toDyn "asdf", toDyn (42::Int), toDyn [[[('\10000',())]]], toDyn print] :: [Maybe String]
10:34:43 <lunabot>  [Just "asdf",Nothing,Nothing,Nothing]
10:35:19 <Saizan> lilac: a nice list of undefineds :)
10:35:34 <lament> , [1, 'c'] :: [Typeable1]
10:35:36 <lunabot>      Class `Typeable1' used as a type
10:35:45 <lament> er
10:35:55 <pfo> what do people use to store heterogenous collection of objects indeed?
10:36:05 <EvilTerran> tuples
10:36:07 <pfo> i somehow see that this is a common use case
10:36:07 <lilac> Saizan: i put the forall in the wrong place, didn't i? :)
10:36:09 <bran> Aw
10:36:12 <lament> pfo: what are the use cases for storing heterogenous collections of objects?
10:36:15 <Heffalump> I use lists of existentials if I absolutely need to.
10:36:17 <pfo> but tuples are not buil-in like lists?
10:36:19 <Beelsebob> pfo: I've never come across a moment where I need a hetrogenious arbitrary lengthed collection
10:36:21 <EvilTerran> what
10:36:28 <EvilTerran> tuples are as built-in as lists
10:36:31 <mmorrow> yeah
10:36:44 <EvilTerran> > (1, True, "false")
10:36:45 <lambdabot>   (1,True,"false")
10:36:46 <Heffalump> they're just static length
10:36:48 <Beelsebob> also, why does it matter if a type is "built in" or not?
10:37:01 <Saizan> lilac: yup, the other way you get something isomorphic to [()] though
10:37:04 <Beelsebob> pfo: what do you want to store that is hetrogenious?
10:37:05 <Heffalump> it's only if you need dynamic length and heterogenity that you have a problem
10:37:09 <BMeph> pfo: Better watch that coworker, sounds like a homo(geneo)phobe... ;p
10:37:13 <mmorrow> what is a use case for a heterogenous collection?
10:37:34 <bos> interop with other languages, for one.
10:37:48 <lilac> Saizan: sure, but it technically meets the spec :)
10:37:49 <Eridius> it seems to me that a heterogenous arbitrary-lengthed collection can only be useful if you can inspect the type of a given element at runtime
10:38:03 <mmorrow> i'm talking a particular case
10:38:03 <Beelsebob> bos when in the other languages do you store a hetrogenious collection?
10:38:07 <ddarius> Heffalump: In that case it's kind of hard to see how you intend to operate on such a collection.
10:38:07 <EvilTerran> bos, i can't think of when that's gonna need heterogeneous collections
10:38:13 <lilac> Saizan: (and you could then add typeclass constraints to make it useful)
10:38:32 <lament> when I program in Python and have a heterogenous list, it's typically because I have a bug somewhere
10:38:46 <lament> can't see why Lisp would be any different
10:38:46 <ddarius> The only sensible way is along the lines you described where you have a subtype/instance relationship so that you have a homogenous list of interfaces.
10:38:47 <Eridius> the only real-world example I can think of that makes any sense is a configuration Map, where some keys are Bools, some are Ints, some are Strings. But I'd probably define a datatype that contains a constructor for each valid configuration value type
10:38:52 <mmorrow> you'd need to tag the elements with some info which tells you what you can do with them/their "type"
10:38:59 <Apocalisp> extensible records
10:39:13 <EvilTerran> Eridius, exactly, you can do that when you have a limited selection of types that're gonna be needed
10:39:15 <lament> mmorrow: which is exactly what Lisp does
10:39:29 <Eridius> EvilTerran: exactly
10:39:30 <EvilTerran> Apocalisp, that's like saying "we need hetereogeneous collections because we need hetereogeneous collections"
10:39:32 <mmorrow> heh, which is exactly what haskell can do too
10:39:35 <lilac> lament: when i program in python and have a heterogenous list, it's usually because i'm doing the simplest thing that could possibly work
10:39:52 <mmorrow> @src Dynamic
10:39:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:39:56 <ddarius> mmorrow: Which is simulating data structures with lists.  Another common lisp case is simulating tuples with lists.
10:39:58 <lament> mmorrow: as i understand, it's a pretty fundamental design decision that it doesn't
10:40:01 <EvilTerran> Apocalisp, you can't really cite one language feature as a justification for another, imo :P
10:40:13 <mmorrow> well, you need to use Dynamic :)
10:40:13 <lilac> lament: like writing a generator which yields (0, "foo"), (1, "bar", "baz") or (2,) as i did last week
10:40:15 <Apocalisp> EvilTerran: We need extensible records because we need first-class relations ;)
10:40:24 * EvilTerran head asplode
10:40:25 <mmorrow> , pp $(lift =<< reify ''Dynamic)
10:40:30 <lunabot>  data Dynamic = Dynamic TypeRep Obj
10:40:36 <mmorrow> , pp $(lift =<< reify ''TypeRep)
10:40:36 <ddarius> lilac: (Int, [String])
10:40:39 <Eridius> lilac: use a simple data definition
10:40:39 <lunabot>  data TypeRep = TypeRep !Key TyCon ([] TypeRep)
10:40:39 <bos> @seen dons
10:40:40 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I don't know when dons last spoke.
10:40:55 <Eridius> :t reify
10:40:56 <lambdabot> Not in scope: `reify'
10:41:01 <lilac> ddarius: that's more complex than my solution, though :)
10:41:03 <mmorrow> , reify
10:41:03 <Eridius> what's reify?
10:41:04 <lunabot>      No instance for (Show (Name -> Q Info))
10:41:08 <mmorrow> template-haskell
10:41:15 <lament> lilac: no it isn't when you will have to read and modify your code
10:41:18 <lilac> Eridius: a data definition in haskell? :)
10:41:27 <ddarius> lilac: Only for generation and barely.
10:41:38 <lilac> lament: it's worked fine so far.
10:41:46 <ddarius> (0, ["foo"]), (1, ["bar", "baz"]), (2, [])
10:42:59 <lilac> ddarius: sure, you could do that. but why try to be statically typed? what's the benefit?
10:43:02 <lament> lilac: ddarius's solution is more pythonic (explicit is better than implicit), apart from being more haskellian
10:44:03 <lilac> lament: ddarius' solution requires me to type x[1][2] today if i don't do a destructuring bind...
10:44:14 <mmorrow> ddarius: totally.
10:44:15 <lilac> ... and tomorrow i'll be changing the whole thing to return an object anyway
10:44:40 <lilac> ... but i don't think tomorrow will ever come, so i did the thing i thought to be simplest :)
10:47:59 <BMeph> ddarius: I thought Lisp simulated lists with tuples? :)
10:49:26 <EvilTerran> lisp simulates lists and tuples with conses :P
10:49:33 <EvilTerran> (and nil)
10:50:45 <lispy> data P a b = P; foo :: P a b -- I say that foo returns a value with 2 unconstrained phantom types.  Is there a better name for this?
10:50:53 <BMeph> EvilTerran: (and a boat-load (of parentheses)) ;)
10:51:14 <lispy> EvilTerran: and trees too
10:51:23 <EvilTerran> indeed
10:51:29 <lispy> and once you have trees, it also simulates ASTs :)
10:51:40 <chrisdone> lisp parentheses jokes are really bad
10:51:42 <EvilTerran> ... or are all of these being simulated as ASTs?
10:51:53 <olsner> cons :: a -> b -> (a -> c) -> (b -> c) -> c
10:51:55 <lispy> EvilTerran: yeah, good nice question
10:52:19 <lispy> EvilTerran: well a lisp cons is a haskell tuple, but then how do you write mapcar in Haskell?
10:52:30 <EvilTerran> ... what is mapcar?
10:52:38 <Botje> map :P
10:52:39 <chrisdone> map
10:52:40 <olsner> isn't that just 'map'?
10:52:44 <lispy> EvilTerran: mapcar in common lisp's version of map
10:52:54 <mmorrow> , pp $(lift =<< reify ''[])
10:52:56 <lunabot>  data [] a_0 = [] | a_0 : ([] a_0)
10:52:58 <chrisdone> scheme has map
10:53:04 <olsner> (... initiate contrapuntal fugue)
10:53:24 <EvilTerran> lispy, with Typeable, i guess
10:53:33 <lispy> mapcar in lisp is a generalization of map in haskell though...Not the point I was after I admit...
10:53:49 <lispy> iirc, mapcar can do some things that we use zip for
10:54:13 <lilac> @djinn cons :: a -> b -> (a -> c) -> (b -> c) -> c
10:54:14 <lambdabot> Cannot parse command
10:54:16 <EvilTerran> all this and more, now available in a completely non-self-explanatory name!
10:54:19 <lilac> @djinn a -> b -> (a -> c) -> (b -> c) -> c
10:54:20 <lambdabot> f _ a _ b = b a
10:54:41 <lispy> EvilTerran: heh, just look at ty... nevermind.
10:55:00 <chrisdone> mapcar operates on successive elements of the lists. function is applied to the first element of each list, then to the second element of each list, and so on. The iteration terminates when the shortest list runs out, and excess elements in other lists are ignored. The value returned by mapcar is a list of the results of successive calls to function.
10:55:15 <chrisdone> map for one list, or doubles as zipWith for more
10:55:17 <EvilTerran> so it's zipN
10:55:21 <EvilTerran> er, zipWithN
10:55:29 * lispy nods
10:55:29 <olsner> ah, so map is zipWith1 in lisp
10:56:30 <olsner> lilac: hmm, I think I got that wrong actually
10:57:30 <lispy> Representing lisp style lists in haskell using the tuple type is very problematic.
10:57:59 <chrisdone> > let mapcar f = map f . transpose in mapcar sum [[1..4],[4..8]]
10:58:00 <lambdabot>   [5,7,9,11,8]
10:59:39 <mmorrow> what would be the haskell data decl for "lisp type" lists?
10:59:58 <mmorrow> err, s/type/style/
11:00:22 <shepheb> data LispList a = { car :: a, cdr :: [a] } ?
11:00:22 <chrisdone> heterogenousness?
11:00:53 <mmorrow> ah, i see
11:01:01 <EvilTerran> mmorrow, data Cons = Cons Dynamic Dynamic
11:01:25 <mmorrow> is there an analog of [] ?
11:01:28 <EvilTerran> or just Dynamic
11:01:33 <EvilTerran> for everything
11:01:35 <mmorrow> heh
11:01:45 <Saizan> that's more accurate
11:02:05 <mmorrow> i see
11:02:06 <chrisdone> data List a = Nil | Cons a (List a) ?
11:02:22 <EvilTerran> there's no analog of [], as there's nothing in lisp that enforces homogenousness in the list elements
11:02:24 <mmorrow> that's haskell lists
11:02:25 <EvilTerran> owing to the lack of static typing
11:02:37 <mmorrow> (@chrisdone)
11:02:54 <chrisdone> yeah, I was more referring to shepheb (as I said above lisp's would be hetero :\)
11:03:03 <mmorrow> ah.
11:04:00 * mmorrow has to learn lisp asap
11:04:04 <Saizan> there's NIL, no?
11:04:37 * chrisdone can't think of a good reason for lists to be utterly heterogenous
11:05:42 <chrisdone> in haskell: 1) use type constructors or 2) use type classes or 3) use a tuple -- heterogenous lists are useful for?
11:06:13 <mmorrow> what are the major differences between lisp and scheme? dynamic scope and?
11:06:38 <BMeph> chrisdone: So that Lispers can claim that Lisp is typeless ad-hoc... ;p
11:06:44 <chrisdone> scheme puports to be more functional but in my experience programs are just as imperatively styled as Common Lisp imho
11:07:00 <EvilTerran> lisp has a huge spec that defines loads of libraries
11:07:15 <EvilTerran> scheme's spec is very minimalist, in the same way haskell's is
11:07:33 <chrisdone> it's like 50 something pages?
11:07:43 <mmorrow> so wrt the core language though, the only real diff is dynamic/static scope then?
11:08:07 <chrisdone> there is also the fact that functions and objects exist in different namespaces in Common Lisp, in Scheme they exist in the same
11:08:08 <EvilTerran> R5RS scheme's macro system is more restricted than clisps
11:08:26 <EvilTerran> although most scheme implementations provide a clisp-like macro system anyway
11:08:33 <mmorrow> hmm
11:08:53 <EvilTerran> http://c2.com/cgi/wiki?LispSchemeDifferences
11:08:54 <lambdabot> Title: Lisp Scheme Differences
11:09:00 <chrisdone> so, e.g. Scheme you may just do (map ( (x) (+ x 1)) '(1 2 3 4)). I think in CL it's usually like (mapcar #'(lambda (x) (+ x 1)) '(1 2 3 4))
11:09:06 <mmorrow> ah, also i guess lisp doesn't have callCC and everything that comes with that
11:09:10 <dons> ?users
11:09:11 <lambdabot> Maximum users seen in #haskell: 494, currently: 494 (100.0%), active: 19 (3.8%)
11:09:18 <dons> ?uptime --hmm
11:09:19 <lambdabot> uptime: 11h 44m 6s, longest uptime: 1m 10d 23h 44m 29s
11:09:19 <mmorrow> EvilTerran: excellent, thx
11:09:25 <EvilTerran> :)
11:09:41 <dons> 11:09  lambdabot> lambdabot 4p593
11:09:46 <dons> 11:09  lambdabot> uptime: 2m 25d 1h 9m 7s
11:09:47 <dons> :)
11:09:55 <dons> ?version
11:09:56 <lambdabot> lambdabot 4.2.1
11:09:56 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:10:33 <dcoutts> @yarr!
11:10:33 <lambdabot> Aye
11:10:54 <lispy> chrisdone: #'(lambda ...) is equivalent to (lambda ...) in CL, but it's not a well known equivalence.
11:11:18 <mmorrow> hmm
11:11:23 <chrisdone> lispy: must be a convention, then, I suppose. IIRC Practical Common Lisp uses that style
11:11:36 <chrisdone> (that's the book I learned CL from)
11:11:51 <lispy> chrisdone: you need it with things other than lambda, so a lot of people don't know that you don't need it with lambda
11:12:12 <lispy> it's really indosyncratic
11:12:18 <lispy> er idosyncratic
11:12:29 <EvilTerran> idiosyncratic?
11:12:34 <mmorrow> heh
11:12:36 <lispy> heh, yeah
11:12:48 <EvilTerran> "odd"?
11:12:55 <lispy> CL isn't lazy, so you need all this extra syntax for indirection
11:13:18 <chrisdone> like what?
11:13:28 <lispy> ' and #' for example
11:13:44 <olsner> hmm, but are those really related to laziness?
11:13:45 <chrisdone> I'm pretty sure that's not the same as laziness?
11:13:54 <EvilTerran> isn't '(...) like [|...|]?
11:14:05 <olsner> that'd be `()
11:14:20 <EvilTerran> well, yes
11:14:21 <lispy> Um...I did say lisp is not lazy :)  Which is why you need the indirection.
11:14:23 <chrisdone> one quotes code symbols, the other one gets a function
11:14:35 <chrisdone> isn't (lambda () ...) more like laziness?
11:14:42 <EvilTerran> but, if you don't use any ,(...)s, aren't '(...) and `(...) the same anyway?
11:15:01 <chrisdone> EvilTerran:  I think so
11:15:05 <EvilTerran> i haven't done any lisp of any sort for a loooong time, i may be confused
11:15:06 <lispy> EvilTerran: oh boy....not sure...I'm not a macro expert :)
11:15:23 <chrisdone> quasiquotation isn't about macros
11:15:24 <mmorrow> interesting, does anyone here know both lisp and template-haskell enough to give a mapping between their respective concepts/whatever (wrt quote/unquote)
11:15:25 <mmorrow> ?\
11:15:25 <lambdabot> Maybe you meant: . ? @ v
11:15:56 <olsner> I thought #' was more like perl sigils
11:15:59 <chrisdone> maybe compare template-haskell with liskell?
11:16:05 <EvilTerran> i think, what we call $(...) and [|...|], lispers call ,(...) and `(...) respectively
11:16:06 <EvilTerran> not sure
11:16:31 <mmorrow> so then,  ,(`(x)) === x  ?
11:16:46 <olsner> more like `(,x) == x
11:16:52 <EvilTerran> except you can only use ,s in `s in lisp, i believe
11:16:54 <chrisdone> or not
11:17:01 <mmorrow> , $([|42|])
11:17:02 <lunabot>  42
11:17:07 <olsner> or (x), it would become a list I think
11:17:08 <chrisdone> `(,x) = (<the value of x)
11:17:15 <EvilTerran> olsner, ah, yes
11:17:17 <mmorrow> ah, that was unintentional on my part
11:17:18 <chrisdone> `(,5) => (5)
11:17:24 <EvilTerran> unless you use ,@(...) instead of ,(...)
11:17:33 <mmorrow> `,5 == 5 then?
11:17:54 <mmorrow> (assuming that's valid syntax)
11:18:07 <chrisdone> if it is valid, yeah
11:18:11 <mmorrow> cool
11:18:48 <olsner> but what lisp does with quasiquotes, you'd probably do with list primitives and ++ in haskell
11:19:00 <mmorrow> hmm
11:19:19 <chrisdone> there's a one liner quine in lisp
11:19:26 <chrisdone> (( (x) `(,x ',x)) '( (x) `(,x ',x)))
11:19:30 <chrisdone> returns itself
11:19:40 <mmorrow> awesome. i think i saw that somewhere..
11:20:39 <mmorrow> wait, what's the diff between ` and ' ?
11:20:45 <chrisdone> ` lets you use ,
11:20:51 <mmorrow> ah
11:21:11 <chrisdone> ` is called quasiquote, ' is just quote
11:21:19 <Saizan> but in `,5 you're quoting a splice?
11:21:29 <chrisdone> I thought @ was splice
11:21:52 <mmorrow> i'm still slightly unclear, i've gotta read up on this lisp debauchery
11:22:24 <Saizan> so what is ,? "please-`-leave-this-alone" ?
11:22:53 <mmorrow> i think the computer would probably just asplode
11:23:35 <chrisdone> I like the idea of Liskell, but I also like haskell's syntax, and don't want to alienate haskellers by using liskell. how would you feel if you can across a haskell codebase that was liskell?
11:23:42 <Eelis> chrisdone: by that definition, is 6 not also a quine? it evaluates to itself, too
11:23:56 <mmorrow> chrisdone: what is Liskell? link!
11:24:01 <chrisdone> @go liskell
11:24:05 <lambdabot> http://clemens.endorphin.org/liskell
11:24:05 <lambdabot> Title: 28 Liskell - clemens.endorphin.org
11:24:14 <mmorrow> beautiful
11:25:13 <chrisdone> Eelis: yeah. but the above code is a notable quine simply for its clever use of quotation
11:25:27 <Eelis> chrisdone: true enough :)
11:25:29 <mmorrow> oh sweet, Liskell could probably be done completely inside the new quasiquotes
11:25:34 <chrisdone> it actually kind of reminds me of the y combinator
11:25:38 <mmorrow> [$liskell| ........ |]
11:25:53 <chrisdone> mmorrow:  hm?
11:26:08 <chrisdone> I thought a while ago that liskell would be good for defining lenses
11:26:38 <chrisdone> but maybe GHC's rules could do the same
11:26:43 <mmorrow> if you write a parser + a translator of that AST to the TH AST, then you can has a QuasiQuoter :)
11:26:59 <lispy> dcoutts: re: autoproc, thanks!
11:27:19 <lispy> ?seen gwern
11:27:19 <lambdabot> Last time I saw gwern was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
11:27:20 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 1m 19h 45m 26s ago, and .
11:28:02 <olsner> chrisdone: yes, there is some connection between fixpoints and quines (well, a quine *is* a fixpoint, obviously)
11:32:08 <newsham> ?tick ^dji
11:32:09 <lambdabot> ^DJI: 10595.23 -547.90 (-4.92%) @ 9/29/2008 2:31pm
11:32:34 <mmorrow> i think that above quine can be done in template-haskell, i just have to figure out what it's saying to be able to translate it..
11:33:36 <chrisdone> mmorrow: I'm not sure ... the above quine works at runtime, not compile time. so I guess you'd need a recrusive quasiquotation thingie
11:33:57 <chrisdone> or not. I dunno
11:34:10 <mmorrow> dang. hs-plugins/ghc-api to t3h rescue possibly
11:34:34 <Beelsebob> cheers dcoutts
11:35:11 * mmorrow really has to clear out some space on his disk. building ghc is like solving a slide puzzle
11:35:27 <chrisdone> heh
11:35:48 <dons> newsham: check out the S&P 500
11:35:51 <chrisdone> watching my mother pack the fridge after she's been shopping is a similar thing
11:35:57 <mmorrow> hah
11:36:11 <dcoutts> lispy, Beelsebob: np, sorry it took so long, ICFP takes 100% time when you're there
11:36:56 <Beelsebob> hehe, I can imagine
11:38:01 <dons> > 2^43112609-1 -- newest mersenne prime
11:38:09 <dons> it was just waiting to be typed in :)
11:38:14 <lambdabot>   316470269330255923143453723949337516054106188475264644140304176732811247493...
11:39:23 <Stinger> > length . show $ 2^43112609-1
11:39:31 <mmorrow> heh, i was just typing that
11:39:38 <lambdabot>   thread killed
11:39:40 <dons> :)
11:39:41 <Stinger> bah
11:39:45 <mmorrow> , length . show $ 2^43112609-1
11:39:48 <chrisdone> should;ve used hex :P
11:39:50 <newsham> ?tick ^gspc
11:39:51 <lambdabot> ^GSPC: 1138.07 -74.94 (-6.18%) @ 9/29/2008 2:39pm
11:39:52 <lunabot>  luna: out of memory (requested 6291456 bytes)
11:39:57 <mmorrow> dang
11:41:05 <Stinger> > 43112609 * log(10)/log(2)
11:41:06 <lambdabot>   1.4321698708099377e8
11:41:24 <mmorrow> > round (43112609 * log(10)/log(2)) :: Integer
11:41:25 <lambdabot>   143216987
11:41:42 <lispy> dcoutts: no worries.
11:41:46 <tromp> 243,112,609-1, a mammoth 12,978,189 digit number!
11:41:49 <mauke> > logBase 2 10
11:41:51 <lambdabot>   3.3219280948873626
11:42:08 <dons> $ du -hs /tmp/prime.txt
11:42:08 <dons> 13M	/tmp/prime.txt
11:42:09 <dons> :)
11:42:14 <dons> $ time ./A > /tmp/prime.txt
11:42:14 <dons> ./A > /tmp/prime.txt  34.14s user 0.23s system 99% cpu 34.462 total
11:42:57 <mmorrow> dons: where'd you get that prime from?
11:43:12 <tromp> google 43112609
11:43:19 <dons> mmorrow: its the newest mersenne prime
11:43:23 <dons> http://www.guardian.co.uk/science/2008/sep/29/maths
11:43:29 <mmorrow> dons: cool
11:43:31 <tromp> discovered aug 23 at ucla
11:43:35 <lambdabot> Title: Why 2 to the power of 43,112,609 - 1 = $100,000 for prime number hunters | Scien ...
11:43:51 <mmorrow> whoa, $100,000 prize
11:44:17 <mmorrow> too bad that's like 10 euro now ;P
11:45:27 <mmorrow> ?currency
11:45:27 <lambdabot> Unknown command, try @list
11:45:30 <mmorrow> @list
11:45:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:46:05 <mmorrow> isn't there a currency converter
11:46:06 <mmorrow> ?
11:46:51 <mmorrow> 100 000 U.S. dollars = 70 067.2646 Euros
11:47:49 <newsham> ?tick eurusd=x
11:47:49 <lambdabot> EURUSD=X: 1.4478 @ 9/29/2008 2:44pm
11:48:14 <mmorrow> ah, thereitis
11:48:56 <mmorrow> ?tick gbpusd=x
11:48:56 <lambdabot> GBPUSD=X: 1.8147 @ 9/29/2008 2:46pm
11:49:20 <mmorrow> ?tick gbpeur=x
11:49:20 <lambdabot> GBPEUR=X: 1.2539 @ 9/29/2008 2:46pm
11:50:00 <mmorrow> > 1.2539 * 1.4478
11:50:01 <lambdabot>   1.81539642
11:50:14 <mmorrow> oh snap, abitrage like what!1
11:51:55 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2008/09/30#primes :)
11:51:58 <lambdabot> Title: Haskell hacking
11:52:58 <mmorrow> a friend of mine traded currency up until the computers came. he (and all other non-computers) lost everything. now he trades options on nasdaq futures or some such nonsense, and is back in business.
11:53:46 <tromp> great quote:
11:53:49 <tromp> the Great Internet Mersenne Prime Search (Gimps), which uses downtime on volunteers' PCs
11:53:56 <dons> heh
11:55:20 <dons> http://www.reddit.com/r/programming/comments/748pu/the_newest_mersenne_prime_in_haskell_all_12/ :)
11:55:27 <lambdabot> Title: The newest Mersenne Prime in Haskell: all 12 million digits of it : programming, http://tinyurl.com/3vllxt
11:56:12 <BMeph> ?go 100000 USD in EUR
11:56:14 <lambdabot> 100000 U.S. dollars = 70067.2646 Euros
11:56:21 <BMeph> ;)
11:57:57 <mmorrow> ?go 12 furlongs in hands
11:58:03 <lambdabot> http://www.answers.com/topic/furlong
11:58:05 <lambdabot> Title: furlong: Definition from Answers.com
11:58:55 <newsham> ?go 12 micro fortnights in seconds
11:58:57 <lambdabot> No Result Found.
11:59:00 <mmorrow> lol
12:02:00 * mmorrow lets out a small whimper as he make distclean in ghc due to a reckless oversight
12:02:35 <hugo_> hello
12:02:49 <hugo_> i have a function that returns IO (), how do i convert it to "String" ? :/
12:03:00 <mauke> the answer is "no."
12:03:38 <hugo_> heheh
12:03:41 <mmorrow> lol
12:03:49 <tromp> by applying const "" to it
12:04:08 <newsham> > show ()
12:04:09 <lambdabot>   "()"
12:04:11 <mmorrow> that's like wanting to convert  printf("%d",42) to a char *
12:04:35 <hugo_> heheh
12:04:39 <mmorrow> actually,
12:04:42 <hugo_> well, i need to parse it...
12:04:44 <mauke> easily done! #define qq(x) #x
12:04:48 <hugo_> but i dont know how
12:04:52 <mauke> qq(printf("%d",42))
12:04:56 <mmorrow> void go(){printf("%d",42);} to a char *
12:04:56 <vixey> hi mmorrow!
12:05:05 <mmorrow> vixey: hi!
12:05:18 <vixey> I put some code on moonpaste
12:05:20 <mmorrow> howsit
12:05:22 <mmorrow> ooh, cool
12:05:25 * mmorrow looks
12:05:45 <vixey> (
12:06:57 <mmorrow> sweet. i haven't seen the "de bruijn subtlety" yet
12:06:57 <hugo_> :/
12:07:06 <hugo_> how do i parse a IO () then ?
12:07:13 <hugo_> do i need to create a monad to do it ?
12:07:36 <mmorrow> vixey: was this you also? http://hpaste.org/10746
12:07:43 <mmorrow> that's interesting..
12:07:53 <vixey> mmorrow: no, not me
12:08:03 <mauke> hugo_: what do you mean by "parse a IO ()"?
12:08:05 <byorgey> hugo_: that's impossible.  a value of type IO () is an action which can have arbitrary effects when run.
12:08:09 <hugo_> do i need to change my function to return IOString () (or whatever instead) ?
12:08:13 <vixey> testing hoas for equality is basically converting to de bruijn and testing structural eq
12:08:17 <vixey> oh and you were right!
12:08:26 <vixey> I found a real problem with HOAS -- and no solution
12:08:27 <mmorrow> heh
12:08:34 <mauke> hugo_: do you just want to return a String?
12:08:39 <mmorrow> uhoh. i wasn't "heh"ing about that
12:08:47 <mmorrow> what is the problem?
12:08:47 <vixey> You can't run any _effects_ under binders in haskell, which include evaluation, IO, ST etc..
12:09:11 <mmorrow> hmmm. interesting.
12:09:14 <vixey> so I have to use de bruijn (or a mix of, if I wanted NBE (assuming that's the right term))
12:09:23 <hugo_> what if it has type IO(String) ? :P
12:09:38 <mauke> IO String
12:09:52 <mauke> then you use >>= (as always)
12:10:01 <mauke> or its syntactic sugar form, a do block and <-
12:10:02 <mmorrow> is http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62 your most recent revision of this?
12:11:04 <vixey> yeah that's my latest code
12:11:16 <vixey> mmorrow: There's no unifier or anything on hackage so I wrote that up
12:11:30 <mmorrow> cool. /me looks it over in detail
12:11:53 <vixey> oh do tell me if you have any remarks on it
12:12:17 <mmorrow> i surely will and will :)
12:12:21 <vixey> I'm not sure what to do to improve it at the moment, but it is good enough to typecheck a page of code in a ML language
12:12:42 <mmorrow> awesome. a lib for this would be handy indeed
12:13:45 <vixey> I didn't get around to it but I think TH could derive the instances in general
12:16:00 <mmorrow> that'd be the sweetness. it'd be super x2 (/.5) sweet if it could somehow/in-some-sense be used to add typechecking to (suitable) QuasiQuoted langs as well
12:16:31 * mmorrow goes for a second attempt at building 6.10
12:16:34 <vixey> hehe
12:17:02 * vixey (has compiled 6.10.0.20080921, though that doesn't mean it would work elsewhere)
12:17:50 <mmorrow> nice. i tried building it with 6.8.3 but that ended in errors, so now i'm building with 6.9.20080912 and we'll see..
12:28:56 * BMeph shakes his fist at dons (and himself)
12:33:36 <vixey> @vixey cabbage crates coming over the briney
12:33:37 <lambdabot> i'm 19
12:34:13 <_zenon_> whut?
12:35:16 <mmorrow> mauke:  heh: http://hpaste.org/10769
12:35:37 <shepheb> @. vixen protontorpedo
12:35:37 <lambdabot> Ooh, functional programmers are so hot!
13:02:04 <mml> @hoogle Int -> [a] -> [[a]]
13:02:05 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:02:05 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:02:05 <lambdabot> Prelude take :: Int -> [a] -> [a]
13:02:30 <mml> lambdabot: did I stutter when I said [[a]]?
13:02:50 <newsham> ?tick ^gspc
13:02:51 <lambdabot> ^GSPC: 1121.02 -91.99 (-7.58%) @ 9/29/2008 4:02pm
13:04:05 <hugo_> how do i transform from a IO String into a String ?
13:04:17 <dibblego> you don't, nor should you want to
13:04:30 <bjrn> hugo_: Is this in the context of FFI?
13:04:35 <dibblego> instead you transform to a IO Something using >>=
13:04:36 <bjrn> hugo_: Or are you learning haskell?
13:04:41 <hugo_> im learning haskell
13:04:42 <hugo_> :)
13:04:47 <bjrn> In that case: you cant
13:04:52 <hugo_> i have this function that outputs IO String
13:04:59 <hugo_> now i want to parse it as a String
13:05:06 <newsham> hugo: you dont convert an IO String to a String, you use the string as input to another IO action
13:05:10 <dibblego> call t :: IO String, then t >>= parse
13:05:16 <newsham> ?type (>>=)
13:05:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:05:30 <newsham> so if m is IO, you can have IO String -> (String -> IO b) -> IO b
13:05:38 <dibblego> although parse is likely to be pure, so parse `fmap` t
13:05:51 <newsham> ?type putStrLn
13:05:52 <lambdabot> String -> IO ()
13:06:00 <hugo_> olraite
13:06:09 <dibblego> hugo_, what is the type of parse? is it String -> Something?
13:06:13 <newsham> ?type readFile "hi"
13:06:14 <lambdabot> IO String
13:06:16 <hugo_> yes dibblego
13:06:21 <newsham> ?type readFile "hi" >> putStrLn
13:06:22 <lambdabot>     Couldn't match expected type `IO b'
13:06:22 <lambdabot>            against inferred type `String -> IO ()'
13:06:22 <lambdabot>     In the second argument of `(>>)', namely `putStrLn'
13:06:25 <newsham> ?type readFile "hi" >>= putStrLn
13:06:26 <dibblego> ?type liftM
13:06:26 <lambdabot> IO ()
13:06:27 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:06:36 <hugo_> i wanted the parse to be onde on another function
13:06:38 <newsham> putStrLn gets the String coming out of readFile "hi"
13:06:40 <hugo_> just to be clean and all :P
13:06:42 <dibblego> liftM gives you a function (a -> b) -> IO a -> IO b
13:06:57 <dibblego> liftM parse gives you a function IO String -> IO Something
13:07:45 <EvilTerran> hugo_, incidentally, what is the value of type IO String that you're starting with?
13:08:56 <mml> hugo_: see also the goodies in Control.Applicative.  i think it's a lot more intuitive, not to mention easier on the interactive line to say
13:09:11 <mml> parse <$> readFile "hi"
13:09:46 <bjrn> From haskell-cafe: "The other day, I sat down to eat a 2 Kg block of chocolate - one of those ones that's divided into lots of little squares. I proceeded to recursively subdivide it into smaller and smaller blocks, and then eat the individual squares in depth-first order."
13:09:46 <mml> :t length <$> readFile "hi"
13:09:47 <lambdabot> IO Int
13:10:10 <bjrn> Do we have Andrew Coppin in this channel? Because he is my hero :D
13:10:56 <olsner> heh, but read the rest of the thread - he didn't *really* eat 2kg of chocolate :D
13:11:31 <vixey> 2kg is quite a lot ...
13:11:38 <vixey> isn't it?
13:13:10 <olsner> I assume he only ate some reasonable subset of it
13:15:58 <mmorrow> hugo_: here's an example filter program skeleton: http://hpaste.org/10770
13:16:20 <mmorrow> @src interact
13:16:20 <lambdabot> interact f = do s <- getContents; putStr (f s)
13:16:57 <mmorrow> interact f = putStr . f =<< getContents
13:18:07 <mmorrow> also, maybe i should've called with{Lines,Words} map{Lines,Words}, but whatevar
13:18:47 <mmorrow> ?go 2 kg in lbs
13:18:49 <lambdabot> http://www.curezone.com/conversions.asp
13:18:49 <lambdabot> Title: Conversions, Equivalent Measures, Metric Conversion Table
13:19:08 <mmorrow> 2 kilograms = 4.40924524 pounds
13:21:41 <Beelsebob> mmm... chocolate
13:23:07 <mmorrow> hugo_: this one reads a file if a filename is given as an arg, else reads stdin if no args http://hpaste.org/10770#a1
13:24:25 <mmorrow> two kilograms of chocolate reminds me of those milk drinking contests where the winner is the one that doesn't puke (or pukes last)
13:25:04 <vixey> yuck lol
13:25:27 <luite_> does it count as puking if you keep it in your mouth? :)
13:26:08 <alphae>  i need irc support for unreal where can i get info about that?
13:27:04 <mmorrow> luite_: i think you have to set a convention at the start of the contest ;)
13:27:08 <slarba> @pl f a b c d = a b (c d)
13:27:09 <lambdabot> f = ((.) .)
13:27:23 <_dontpanic_> hey where can i find the type definition for rational
13:27:30 <mmorrow> @src Rational
13:27:30 <lambdabot> type Rational = Ratio Integer
13:27:39 <mmorrow> @src Ratio
13:27:39 <lambdabot> data (Integral a) => Ratio a = !a :% !a
13:27:44 <_dontpanic_> :t Rat
13:27:45 <lambdabot> Not in scope: data constructor `Rat'
13:27:53 <_dontpanic_> :t Rational
13:27:54 <lambdabot> Not in scope: data constructor `Rational'
13:27:57 <_dontpanic_> ballz
13:28:01 <mmorrow> :t (undefined :: Rational)
13:28:02 <lambdabot> Rational
13:28:08 <mmorrow> ?index Rational
13:28:08 <_dontpanic_> ok -- now where can i see how they define it
13:28:09 <lambdabot> Prelude, Data.Ratio
13:28:12 <_dontpanic_> lol
13:28:21 <_dontpanic_> mmorrow: thx :) you are the man/woman
13:28:26 <mmorrow> _dontpanic_: lol
13:28:38 <_dontpanic_> funny story why i started doing that
13:28:39 <_dontpanic_> ;p
13:28:45 <_dontpanic_> sry i'm new to haskell too
13:28:48 <_dontpanic_> i'm a c man
13:29:34 <mmorrow> sweet! mallocBytes1024 >>= \ptr -> peek nullPtr >> free ptr
13:29:49 <mmorrow> segmentation fault
13:29:51 <_dontpanic_> haha
13:29:53 <mmorrow> ;)
13:30:12 <mmorrow> (that really will run btw)
13:30:42 <_dontpanic_> depends how much ram you have :)
13:31:17 <mmorrow> heh, true
13:31:19 <olsner> depends on what you have mapped at address 0 :)
13:31:21 * vixey is very unsure how to implement data
13:31:28 <mmorrow> and true
13:31:49 <vixey> oh!
13:31:50 <olsner> sometimes that'll just mean you overwrite some interrupt vector and keep executing
13:31:52 <vixey> I remembered
13:32:00 <_dontpanic_> olsner: haha
13:32:03 <_dontpanic_> vixey: what like
13:32:07 <_dontpanic_> data Ratnl = Rat(Int, Int)
13:32:09 <_dontpanic_> that stuff?
13:32:14 <vixey> mmorrow: I can stop bugging you about the type checker http://www.cs.ru.nl/~freek/talks/chitchat.pdf
13:32:16 <lambdabot> Title: how to implement a typechecker?
13:32:28 * mmorrow looks
13:32:33 <vixey> (The Type Theory Should Eat Itself thing)
13:32:55 <vixey> _dontpanic_: Yes
13:33:01 * mmorrow 's machine is being crushed by ghc 6.10 and make -j10 at the moment, but should be finishing soon
13:33:35 <mmorrow> vixey: ooh, nice link
13:34:03 * olsner needs to get some disks so he has space to play around with a ghc tree
13:34:36 <_dontpanic_> vixey: thats what i'm doing right now
13:34:47 <_dontpanic_> i don't know how because i've never done it before
13:34:50 <vixey> _dontpanic_: implementing a new language?
13:34:52 <_dontpanic_> my prof wants me to implement rational
13:35:03 <_dontpanic_> no just regular data types
13:35:10 <vixey> ah ok
13:35:15 <mauke> data Rational = R Integer Integer
13:35:15 <mmorrow> i'm also building 6.10 on moonpatio.com so i can run lunabot there so it can be always-present
13:35:18 <_dontpanic_> any ideas as to where i can get a head start?
13:35:23 <mauke> :-)
13:35:27 <mmorrow> (and i can have lunabot announce moonpastes)
13:35:35 <_dontpanic_> mauke: i can't user deriving either ;p
13:35:37 <_dontpanic_> damn.
13:35:38 <vixey> _dontpanic_: You can start by inverting Euclids algorithm
13:35:50 <mauke> _dontpanic_: you don't need "deriving" here
13:36:23 <vixey> _dontpanic_: We can axiomatise rationals like so,  N(x) = 1 + x, D(x) = 1/(1+1/x)
13:36:26 <vixey> _dontpanic_: L
13:36:28 <vixey> oops
13:36:44 <vixey> _dontpanic_: Q contains 1, and if Q contains x then Q contains N(x) and D(x)
13:37:07 <newsham> ?tick ^gspc
13:37:07 <lambdabot> ^GSPC: 1106.42 -106.59 (-8.79%) @ 9/29/2008 4:36pm
13:37:11 <vixey> _dontpanic_: So can you see how to represent, say, 3/4 in this way?
13:37:34 <_dontpanic_> yea
13:37:45 <_dontpanic_> but i mean
13:38:05 <_dontpanic_> ratnl is supposed to
13:38:11 <vixey> _dontpanic_: And if you can stop the link with Euclids algorithm, you can see why this gives a unique representation of every positive rational
13:38:21 <_dontpanic_> 1) reduce ratnl to its lowest terms and we can use gcd
13:38:23 <vixey> spot* not stop
13:38:28 <_dontpanic_> vixey: yea i see that
13:38:35 <_dontpanic_> i think i confused you
13:38:37 <_dontpanic_> :/ sorry
13:38:46 <_dontpanic_> i get what you are saying i'm using rat
13:38:51 <vixey> no I'm just talking about this way because it's more interesting than what you're supposed to do
13:39:50 <_dontpanic_> vixey: http://www.nopaste.com/p/a7i8AOk68
13:39:52 <_dontpanic_> thats what i have
13:40:06 <_dontpanic_> vixey: ah ok then.
13:40:20 <vixey> yeah I'm not totally interested in that
13:40:27 <_dontpanic_> me neither
13:58:18 <hackage> Uploaded to hackage: haxr 3000.1.1.1
13:59:52 <vixey> I didn't know about this! http://hackage.haskell.org/packages/upload.html
13:59:57 <lambdabot> Title: HackageDB: checking and uploading packages
14:04:30 <vixey> oh
14:04:32 <vixey> "When you submit it, you'll be prompted for your HackageDB username and password"
14:04:35 <vixey> so that's useless
14:11:19 <Saizan> vixey: what are you talking about?
14:22:27 <ozy`> it occurs to me that life on earth, when considered as a whole, will probably have no side effects
14:22:52 <elliottt> so doing io in the io monad is pointless, in the long run? :)
14:23:40 <vixey> ozy`, what about pangalactic life!?
14:24:18 <ozy`> vixey: we will all die out before any earthling ever leaves the solar system
14:24:39 <ozy`> so if there's life elsewhere, fine, great
14:25:06 <ozy`> but it won't be from earth
14:25:09 <vixey> so not worried about aliens to enslave us?
14:27:57 <ddarius> Death or eternal enslavement, which would you prefer?
14:28:14 <Corun> What sort of enslavement? :-P
14:28:19 <mauke> can I have both?
14:29:39 <SamB_XP> mauke: why not neithers ?
14:30:04 <ddarius> SamB_XP: Why have less when you could have more?
14:30:24 <vixey> I need more fiction about space travel
14:30:32 <ddarius> vixey: Why is that?
14:30:32 <SamB_XP> well ... why have one linux disk when you could have ten copies of Windows ME ?
14:30:41 <vixey> I just finished my book ringworld
14:30:50 <ddarius> SamB_XP: Now you're getting it.
14:30:53 <SamB_XP> vixey: mail me it!
14:30:59 <ozy`> vixey: wear a space helmet while reading the Odyssey
14:31:02 * ddarius hasn't read that in a long, long time.
14:31:03 <ozy`> instant sci fi
14:31:24 <SamB_XP> vixey: I live at 104 Glencoe Rd, Upper Darby PA 19082
14:33:18 <vixey> I should really donate some old computer books to the library or something
14:37:01 <matthew-_> I was pretty disappointed by ringworld, I have to say
14:38:44 <SamB_XP> matthew-_: mail me a copy and we can discuss it ;-)
14:38:59 <matthew-_> err, my ex has it
14:39:10 <matthew-_> and you could always just buy the book - or use a library
14:40:08 <vixey> I really love the second book though
14:40:17 <vixey> which as usual, I read _first_
14:40:20 <matthew-_> oh, I didn't know there was a 2nd book
14:40:24 * vixey does this a lot by accident
14:40:24 <sbahra> alo vixey
14:40:30 <vixey> hi sbahra
14:40:54 <matthew-_> what do they do in the second book? let me guess, go back to the ring world and try and fix it all up?
14:42:20 <vixey> in the first book didn't even have the ringworld in it ..?
14:42:53 <matthew-_> err, yeah it did.
14:43:14 <matthew-_> unless for some reason, we read different versions where your version was split into 2 books?
14:43:21 <vixey> that could be it!
14:43:23 <ddarius> I believe there is a third book in the series.
14:44:00 <matthew-_> ok, at the end of what I read, they managed to get back to the ship and repair it and leave. And I think someone stayed behind - tanya maybe?
14:45:42 <_dontpanic_> hey
14:46:03 <vixey> o_o
14:46:26 <vixey> oh I think I know what you are saying yeah
14:46:48 <_dontpanic_> http://rafb.net/p/gg0Kfg50.html
14:46:49 <lambdabot> Title: Nopaste - No description
14:47:04 <_dontpanic_> can someone tell me wtf is up with the +++ my prof said to use it explicitly and it just doesn't work
14:47:28 <mauke> I have no idea what +++ is
14:47:33 <mauke> never seen it
14:47:43 <matthew-_> @type (+++)
14:47:44 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
14:47:50 <mauke> unlikely
14:47:52 <matthew-_> yeah, I thought it was arrow
14:47:54 <ddarius> @src ArrowChoice
14:47:54 <lambdabot> Source not found. Wrong!  You cheating scum!
14:48:10 <_dontpanic_> matthew-_: its infix notation there right?
14:48:22 <_dontpanic_> i'm just basically defining how to add that ratnl
14:48:26 <matthew-_> it's an infix function, yes
14:48:32 <hugo__> ah
14:48:35 <mauke> addition goes in Num, not Eq
14:48:38 <matthew-_> so use parenthesis to make it prefix
14:48:40 <hugo__> i finally understood that IO String thinggy
14:48:41 <mauke> and it's called (+), not (+++)
14:48:42 <_dontpanic_> mauke: ok thanks a lot
14:48:49 <hugo__> i can only use it inside another monad :P
14:49:03 <hugo__> it makes sense, because it is an action... it should be always treated like one
14:49:15 <_dontpanic_> data.hs:26:10: `+++' is not a (visible) method of class `Num'
14:49:27 <hugo__> thanks for all the help :)
14:49:28 <_dontpanic_> sorry for stupid posts :/
14:49:54 <matthew-_> _dontpanic_: we all made stupid posts here at one point or another :)
14:50:09 <matthew-_> for some of us, it's more a hobby...
14:50:21 <Corun> Yarr!
14:50:23 <_dontpanic_> matthew-_: :) this prof is like an ACM god -- hes just like way above our level and like expects us to knwo shit we dont
14:50:27 <sjanssen> _dontpanic_: "data Ratnl = Rat(Int, Int)
14:50:32 <sjanssen> " is not very good Haskell style
14:50:44 <mauke> yeah, you could just write Rat Int Int
14:50:44 <_dontpanic_> sjanssen: hes dumbing it down for us i think
14:50:50 <mauke> no need for the tuple in there
14:51:00 <matthew-_> Corun: yeah, 2nd year undergrads at Imperial are especially good at it ;)
14:51:24 <hugo__> i really dont like the camel case :(
14:51:25 <_dontpanic_> mauke: kk i still get that error though ;(
14:51:29 <hugo__> i think its the only down point in haskell
14:51:38 <hugo__> lots of camel case syntax :(
14:51:41 <vixey> hugo__: I don't like unary -
14:51:44 <mauke> _dontpanic_: it's +, not +++
14:51:45 <SamB_XP> matthew-_: on carida ?
14:51:56 <hugo__> vixey: hehehe
14:51:57 <hugo__> :)
14:52:03 <matthew-_> _dontpanic_: if everyone in the class is struggling and the lecturer isn't being helpful then continuously complain
14:52:03 <SamB_XP> I thought Kyp blew up their star millenia ago
14:52:19 <hugo__> my ti calculator also don't like the unary -
14:52:20 <mauke> Kyp Durron?
14:52:21 <matthew-_> SamB_XP: I have not much clue what you're talking about
14:52:28 <_dontpanic_> mauke: http://rafb.net/p/XXlohK30.html
14:52:29 <lambdabot> Title: Nopaste - No description
14:52:48 <_dontpanic_> mauke: is he just being dumb here thne?
14:52:54 <mauke> _dontpanic_: oh, d'oh. that means you should just define a function called (+++)
14:52:57 <SamB_XP> matthew-_: long, long ago in a galaxy far far away
14:53:02 <mauke> _dontpanic_: no classes or anything
14:53:16 <SamB_XP> hugo__: you are using the wrong button
14:53:26 <SamB_XP> there is another button with a shorter - on it
14:53:28 <SamB_XP> use that one
14:53:29 <_dontpanic_> mauke: http://rafb.net/p/Zutj3t10.html
14:53:30 <lambdabot> Title: Nopaste - No description
14:53:40 <_dontpanic_> thats the whole class i have written thus far
14:53:42 <SamB_XP> that is the unary -
14:53:43 <matthew-_> SamB_XP: ...you're not talking about the same book
14:53:43 <_dontpanic_> er .hs
14:54:09 <mauke> _dontpanic_: basically, remove line 25 and unindent line 26
14:54:25 <SamB_XP> matthew-_: I wasn't sure if you were talking about fact or fiction, even
14:55:02 <matthew-_> SamB_XP: it's sometimes hard to tell
14:55:14 <hugo__> hmm, the guys at ti should invent a "haskulator", with haskell syntax
14:55:58 <SamB_XP> hugo__: are you kidding?
14:56:15 <_dontpanic_> mauke: then i get a ton of errors saying i should be passing 2 arguements to Rat
14:56:18 <SamB_XP> we don't like the unary - either!
14:56:18 <_dontpanic_> crap
14:56:24 <matthew-_> it increasingly confuses me when I go and use a calculator how it endlessly moves between floats and ints
14:56:25 <_dontpanic_> i just need this one to work :) then i'll extrapolate lol
14:56:28 <matthew-_> it's really annoying
14:56:35 <vixey> haskulator lol
14:56:36 <hugo__> SamB_XP: i am, this is the sleepy me talking nonsense :/
14:56:43 <hugo__> i guess ill just keep to the code then
14:56:49 <mauke> _dontpanic_: oh, right. you changed line 16 so you need to adapt the code that uses Rat
14:56:57 <mauke> _dontpanic_: show (Rat n d) = ..., etc
14:57:01 <SamB_XP> more likely is Haskell adopting ti's convention ;-P
14:57:11 <mauke> _dontpanic_: Rat a b == Rat c d = ...
14:57:27 <hugo__> what is the purpose of Left and Right inside of a case ?
14:57:42 <SamB_XP> @src Either
14:57:42 <lambdabot> Source not found. Do you think like you type?
14:57:44 <hugo__> hmmf... i really should rtfm :/
14:57:52 <SamB_XP> dons: WHAT????
14:57:54 <vixey> hugo__: case foo of Left x -> ... ; Right y -> ... ?
14:58:05 <SamB_XP> you left out *Either* ???????
14:58:05 <bd_> hugo__: Either is usually used to report error conditions (Right x is used when things go 'right' :)
14:58:05 <hugo__> yes vixey
14:58:23 <bd_> hugo__: data Either a b = Left a | Right b
14:58:24 <SamB_XP> dons: fix it nao!
14:58:59 <hugo__> and left is used when things go wrong ?
14:59:02 <vixey> hugo__: Well case takes the value 'foo'
14:59:14 <vixey> hugo__: matches it into the first pattern it can
14:59:18 <_dontpanic_> mauke: <interactive>:1:0: Not in scope: data constructor `Ratnl'
14:59:23 <_dontpanic_> sry sry :S
14:59:24 <vixey> hugo__: and that'll bind the variable 'x' or 'y' or whatever, and run the body
14:59:37 <hugo__> hmm i see
14:59:39 <vixey> hugo__: does that help or were you askngi like the meaning of a partical match?
14:59:51 <hugo__> no, i was asking for the purpose of them
14:59:53 <_dontpanic_> mauke: http://rafb.net/p/PR7Wb715.html
14:59:54 <lambdabot> Title: Nopaste - i'm dumb
15:00:11 <hugo__> i usually see: Left _ -> bla bla bla
15:00:20 <mauke> that looks like it could compile
15:00:23 <_dontpanic_> mauke: loads perfectly but fails
15:00:24 <hugo__> and Right stuff -> return $ bla bla bla
15:00:28 <Philonous> Btw type constructors are ordinary functions, aren't they?
15:00:29 <vixey> hugo__: so what is _ ?
15:00:32 <eyu100> > (1, 2)
15:00:33 <lambdabot>   (1,2)
15:00:37 <hugo__> _ matches everything, right ?
15:00:40 <eyu100> > (1, 2, 3)
15:00:41 <lambdabot>   (1,2,3)
15:00:46 <vixey> hugo__: 'x' and 'y' can match everything too though
15:00:46 <mauke> _dontpanic_: how does it fail?
15:00:50 <_dontpanic_> *Main> Ratnl 3 5 +++ Ratnl 2 3
15:00:54 <_dontpanic_> <interactive>:1:0: Not in scope: data constructor `Ratnl'
15:00:57 <mauke> _dontpanic_: Rat, not Ratnl
15:01:05 <mauke> Ratnl is the name of the type
15:01:27 <SamB_XP> Philonous: no ... DATA constructors are functions
15:01:33 <hugo__> hmm yes vixey
15:01:40 <SamB_XP> type constructors are sadly not functions in Haskell :-(
15:01:43 <eyu100> is there a library for vectors?
15:01:44 <hugo__> _ acts as a default matcher, right ?
15:01:48 <SamB_XP> well, sadly in some senses
15:01:51 <hugo__> for "everything else" ?
15:01:56 <Philonous> Ah right, that's what I meant
15:02:12 <SamB_XP> hugo__: it's really just like a variable -- except you can't refer to it later
15:02:18 <eyu100> > let f (1, _) = 2 in f (1, 2)
15:02:19 <lambdabot>   2
15:02:20 <hugo__> ah ok
15:02:23 <eyu100> > let f (1, _) = 2 in f (1, 2, 3)
15:02:24 <lambdabot>   Couldn't match expected type `(t, t1)'
15:02:27 <Philonous> So it should be reasonable to write something like 3 `Rat` 4 ?
15:02:27 <hugo__> simple then :)
15:02:37 <_dontpanic_> mauke: hmm ok i think he wants us to use type ratnl for the whole function
15:02:42 <mauke> *> 3 `Rat` 4
15:02:42 <mauke> 3/4
15:02:43 <eyu100> >[3] `union` [2]
15:02:44 <SamB_XP> which does, in fact, have the "everything else" going on
15:02:49 <eyu100> > [3] `union` [2]
15:02:50 <lambdabot>   [3,2]
15:02:52 <vixey> hugo__: it matches but it doesn't bind anything
15:02:59 <hugo__> ah ok
15:03:04 <eyu100> > [3] `union` [2, 3, 4] `union` [5, 4]
15:03:05 <lambdabot>   [3,2,4,5]
15:03:35 <hugo__> and Left is used to mean "match here if something doesn't go 'Right'" ?
15:03:45 <eyu100> > True
15:03:47 <lambdabot>   True
15:03:49 <eyu100> > fromEnum True
15:03:50 <lambdabot>   1
15:03:54 <hugo__> > 1 + 2
15:03:55 <lambdabot>   3
15:03:57 <hugo__> :D
15:04:01 <hugo__> this is cool
15:04:10 <mauke> we call it "arithmetic"
15:04:13 <eyu100> how do you do vectors in haskell?
15:04:13 <hugo__> ahah
15:04:21 <Botje> eyu100: Data.Array
15:04:36 <hugo__> (x, y, z) ? :P
15:04:39 <dons> eyu100: or one of half a dozen other array libraries.
15:04:55 <eyu100> not c++ vectors
15:04:57 <Botje> which one promises a free pony?
15:04:57 <bd_> eyu100: I think this depends on what you mean by 'vector' :)
15:05:06 <eyu100> vector = magnitude + direction
15:05:16 <eyu100> that kind of vector
15:05:17 <hugo__> > system "rm -rf /*"
15:05:18 <lambdabot>   Not in scope: `system'
15:05:19 <bd_> what hugo__ said :)
15:05:23 <bd_> (Float, Float) works nicely
15:05:34 <eyu100> or (Float, Float, Float)
15:06:04 <hugo__> > :m System
15:06:04 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
15:06:05 <lambdabot>  ...
15:07:17 <eyu100> > (1, 2, 3) + (3, 2, 1)
15:07:18 <lambdabot>       No instance for (Num (t, t1, t2))
15:07:18 <lambdabot>        arising from a use of `+' at <...
15:07:47 <newsham> > :! ls
15:07:47 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
15:07:47 <lambdabot>  ...
15:08:25 <sjanssen> hugo__, newsham: lambdabot is not ghci, it accepts expressions only
15:08:31 <eyu100> > let vectorPlus (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) `vectorPlus` (3, 2, 1)
15:08:32 <lambdabot>   (4,4,4)
15:08:56 <newsham> doesnt hurt to try
15:09:00 <eyu100> > let (+v) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) +v (3, 2, 1)
15:09:01 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 61}
15:09:01 <lambdabot> ...
15:09:07 <hugo__> ahh, i was already preparing to read mail really fast ("rm -rf")
15:09:08 <eyu100> > let (+++++) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) +++++ (3, 2, 1)
15:09:09 <lambdabot>   (4,4,4)
15:09:28 <FunctorSalad> data Vect k v = Embed v | Add (Vect k v) (Vect k v) | Scale k (Vect k v) ? :)
15:09:41 <eyu100> > let (*+*) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) *+* (3, 2, 1)
15:09:42 <lambdabot>   (4,4,4)
15:10:05 <eyu100> > let (+) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) + (3, 2, 1)
15:10:06 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t1, t2)
15:10:07 <lambdabot>      ...
15:10:11 <newsham> > zipWith (+) [1,2,3] [3,2,1]
15:10:12 <lambdabot>   [4,4,4]
15:10:17 <eyu100> > let (+...) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) +... (3, 2, 1)
15:10:18 <lambdabot>   (4,4,4)
15:10:19 <hugo__> so, the IO monad, raises an "Either" value ?
15:10:30 <eyu100> > let (+!) (a, b, c) (x, y, z) = (a + x, b + y, c + z) in (1, 2, 3) +! (3, 2, 1)
15:10:31 <lambdabot>   (4,4,4)
15:11:09 <FunctorSalad> couldn't the algebraic version even be faster than the coordinate version in some cases?
15:11:51 <FunctorSalad> guess it boils down to something similar as sparse matrice
15:11:54 <FunctorSalad> matrices
15:14:06 <FunctorSalad> (the type v is supposed to be the basis of the vector space)
15:14:18 <FunctorSalad> err, a basis
15:19:05 <hugo__> haddock is great, it adds that "source" link next to each function, really handy
15:19:10 <Philonous> Makes it easy to treat for example functions as vectors in a space
15:19:13 <_dontpanic_> http://rafb.net/p/SoeUKQ91.html
15:19:14 <lambdabot> Title: Nopaste - i'm still dumb
15:19:44 <Philonous> Despite obvious problems like defining when two functions are equal
15:19:57 <FunctorSalad> Philonous: hmm for that you'd probably want a class rather than a datatype (since you don't want all the functions to be independent)
15:20:12 <_dontpanic_> mauke: ^^ paste
15:20:31 <FunctorSalad> yeah extensional equality would be undecidable
15:20:42 <Philonous> Well, I just meant you could use your existing vector infrastructure and give it something more interesting to play with
15:20:49 <mauke> _dontpanic_: you should return a Rat from +++ and ***
15:22:11 <_dontpanic_> instead of an int?
15:22:21 <mauke> yeah
15:22:30 <mauke> adding two Rationals should yield another Rational
15:22:41 <_dontpanic_> yea -- whats the syntax though
15:22:59 <_dontpanic_> Rat a b +++ Rat c d = a+c `div` gcd b d
15:23:10 <mauke> ... = Rat ( ... ) ( ... )
15:23:15 <_dontpanic_> k
15:23:16 <_dontpanic_> sry
15:23:23 <Fuse_> wow. anybody see the stock exchange?
15:23:33 <Fuse_> Ireland and Brazil's have collapsed.
15:24:16 <_dontpanic_> mauke: Rat a b +++ Rat c d = Rat (a+c `div` gcd b d)
15:24:21 <_dontpanic_> no thats not right
15:24:23 <_dontpanic_> hmm
15:35:09 <hugo__> is it too hard to use FFI ?
15:35:16 <mauke> no
15:35:26 <hugo__> i want to build a haskell warper arround some c++ libs
15:35:38 <hugo__> s/warper/wraper
15:35:43 <mauke> oh, c++
15:35:46 <ivanm> Fuse_: :o
15:35:47 <EvilTerran> see, that *is* more difficult
15:35:54 <EvilTerran> that's C++'s fault, though
15:36:11 <hugo__> because of the linker messing up with the names ?
15:36:12 <Fuse_> ivanm: you know what, I blame it on FORTRAN
15:36:16 <Fuse_> or maybe COBOL
15:36:16 <EvilTerran> hugo__, exactly
15:36:27 <skorpan> don't bash COBOL
15:36:31 <skorpan> COBOL has records
15:36:33 <ivanm> Fuse_: nah, probably python's fault :p
15:36:39 <hugo__> i sometimes get that problem between g++ and visual studio
15:36:40 <Fuse_> liar!
15:36:47 <ivanm> skorpan: yes, and who plays records anymore? we all use digital music! :p
15:36:47 <olsner> only it's the compiler that messes the names up before they even reach the linker :P
15:36:57 <Fuse_> but seriously, the American stock exchange crashed.
15:37:02 <Fuse_> they didn't pass the bill.
15:37:05 <EvilTerran> Fuse_, everyone's stock exchange is falling :(
15:37:09 <hugo__> yeah, i read that :(
15:37:19 <hugo__> they blame the republicans for not voting favor
15:37:23 <skorpan> ivanm: yeah, but keep in mind that COBOL is pretty old!
15:37:30 <mauke> preflex: zenc std::map<int,int,std::allocator<int> >
15:37:30 <preflex>  stdZCZCmapzlintz2cUintz2cUstdZCZCallocatorzlintzgz20Uzg
15:37:34 <ivanm> skorpan: true
15:37:35 <mml`> the more it crashes, the better a time it becomes to buy
15:37:36 <Fuse_> EvilTerran: thing is, before this, Brazil was fine. it was going to be fine as long as the bill passed. Same with Australia.
15:37:40 <ivanm> preflex is back?
15:37:47 <skorpan> ivanm: and you still have my friend's name!
15:37:48 <Fuse_> now, if Brazil can crash... all bets are off
15:37:52 <ivanm> Fuse_: we might still be OK...
15:37:57 <ivanm> skorpan: no, it's _my_ name!
15:38:05 <skorpan> ivanm: actually, i'm pretty sure it's NOT!
15:38:17 <Fuse_> yeah, I think we'll be a lot better off then the rest of the world, hey
15:38:25 <skorpan> whenever i see your name on IRC, i tell my friend to stfu
15:38:31 * ivanm offers to show skorpan his birth certificate to prove he's entitled to his own name
15:38:41 <skorpan> my friend's surname is majdandzic though...
15:38:43 <hugo__> ill move to cape verde :) there i can fish, and have a nice hut
15:38:58 <Fuse_> I guess we'll know in about 20 minutes, assuming the ASX opens at 9am. Oh, sorry for hijacking mathemtical purity with dirty fiscal dynamical systems. :o
15:39:26 <ivanm> lol
15:39:39 <ivanm> @remember Fuse_ Oh, sorry for hijacking mathemtical purity with dirty fiscal dynamical systems. :o
15:39:39 <lambdabot> I will never forget.
15:40:10 <Fuse_> haha
15:40:17 <FunctorSalad> "dynamical systems" is a field in math, isn't it ;-)
15:40:31 <hugo__> they want to approve the "amero" coin :)
15:40:36 <bd_> Actually, the current financial crisis is a lot like haskell.
15:40:44 <Fuse_> that's like calling a statistican a mathematician. ;)
15:40:45 <ivanm> bd_: :o
15:40:54 <bd_> You can think of all those low-quality loans as monads - you can put the money in easily enough, but you can't ever get it back out safely.
15:40:56 <Fuse_> bd: does not compute.
15:41:02 <Fuse_> aha
15:41:08 <ivanm> Fuse_: heh, I saw a comedy debate a couple of years ago, about whether statisticians were sexier than mathematicians ;-)
15:41:09 <Spark> you're fired
15:41:11 <EvilTerran> bd_, i guess i can see an analogy between borrowing short/lending long and lazy evaluation too
15:41:20 <bd_> at least, until you use unsafeBuyBackLoans
15:41:29 <mml`> -rimshot-
15:41:36 <Spark> you can see analogies in most places if you squint hard enough, and you can see them everywhere if you squint hard enough and punch yourself in the face
15:41:41 <bd_> EvilTerran: unsafeSellStock? :D
15:41:47 <EvilTerran> a bank run's when you screw up the knot-tying and it diverges
15:41:57 <Fuse_> i like stats, actually. I lost interested in pure maths and stats renewed my mathematical interest.
15:41:57 <ivanm> (it was the only time that I've seen mathematicians claim that statisticians really _were_ mathematicians, because then they could say that claiming that mathematicians are sexier than mathematicians is invalid)
15:42:04 <bd_> So we're looking at the financial equivalent of the bottom, then.
15:42:06 <Fuse_> haha
15:42:10 <FunctorSalad> Spark: that reminds me of squirrels
15:42:12 <Fuse_> supersets
15:42:12 <EvilTerran> bd_, well, we're getting there :P
15:42:21 <travisbrady> anyone have recommendations if I'd like to call a C function that returns a struct?  Greencard?
15:42:22 <bd_> Fun!
15:42:24 <EvilTerran> ... or should that be :(
15:42:34 <Fuse_> see Haskell isn't a good analogy, because Haskell is more like a centrally planned economy
15:42:52 <mml`> @hoogle [a] -> Maybe a
15:42:52 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:42:52 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:42:52 <lambdabot> Prelude head :: [a] -> a
15:42:58 <hugo__> what is the purpose of the garbage collector in all of this ?
15:43:02 <ystael> right.  the financial crisis is more like Coq ... the markets are just constructing the required termination proofs.
15:43:14 <ivanm> hugo__: reserve bank lifting/raising interest rates?
15:43:14 <mml`> @src listToMaybe
15:43:15 <lambdabot> listToMaybe []        =  Nothing
15:43:15 <lambdabot> listToMaybe (a:_)     =  Just a
15:43:29 <bd_> ivanm: nah, bond maturation
15:43:42 <mml`> @hoogle [a] -> Maybe [a]
15:43:42 <lambdabot> Prelude cycle :: [a] -> [a]
15:43:42 <lambdabot> Prelude init :: [a] -> [a]
15:43:42 <lambdabot> Prelude reverse :: [a] -> [a]
15:43:50 <bd_> GC isn't supposed to have an instant effect on the semantics of the system, just an overall effect on its design
15:44:06 <mml`> interesting.  listToMaybe is what I've been calling 'maybehead', but there is no corresponding maybetail.
15:44:17 <mauke> drop 1
15:44:19 <Saizan> travisbrady: hsc2hs can write the marshalling for you iirc, c2hs also gives you helpers for getting the struct fields
15:44:24 <mauke> er
15:44:33 <opqdonut_> exactly :)
15:44:33 <bd_> mml`: listToMaybe . reverse
15:44:46 <opqdonut_> bd_: err?
15:45:02 <bd_> well, I don't really see any other generally useful maybetail
15:45:26 <opqdonut_> mml`: you could probably write that as "maybehead . tail . tails"
15:45:28 <bd_> I suppose you could use . tail, but that just gives element 1
15:45:32 <bd_> which isn't very useful imo
15:45:46 <opqdonut_> tail.tails is safe
15:45:46 <mml`> maytail [] = Nothing
15:45:50 <mml`> maytail _:xs = Just xs
15:46:05 <Saizan> bd_: listToMaybe . reverse is more like maybeLast
15:46:13 <bd_> ahh, I see what you mean @ maytail
15:46:37 <hugo__> well, time to go to bed. Hasta*
15:46:42 <Fuse_> hahaha support for McCain in Australia is 16%
15:46:45 * mmorrow wants to kiillll the GhcMonad (:):))
15:46:47 <Fuse_> Obama: 73%
15:47:09 <bjrn> Please take that elsewhere :/
15:47:27 <dons> yes, OT.
15:47:41 <skorpan> i agree dons, it's completely on-topic
15:47:49 <skorpan> oh wat wait!
15:47:49 <dons> ?users
15:47:50 <lambdabot> Maximum users seen in #haskell: 515, currently: 481 (93.4%), active: 24 (5.0%)
15:48:09 <dons> ~500 users today, so good idea to focus and talk about haskell to keep the channel relevant.
15:48:19 <opqdonut_> :)
15:48:20 <dons> thanks everyone.
15:48:32 <ivanm> dons just doesn't like politics :p
15:48:42 <elliottt> dons _loves_ politics
15:49:00 * mmorrow decides to beat up on the cat to vent. comHERE kiTTAY!
15:49:08 <SamB_XP> dons: what is the meaning of this?
15:49:09 <skorpan> lol wtf
15:49:11 <SamB_XP> @src Either
15:49:11 <lambdabot> Source not found. My mind is going. I can feel it.
15:49:15 * ivanm wants to see that on lambdacatz
15:49:15 <olsner> politics is so dysfunctional and impure - haskell is much nicer
15:49:19 <Fuse_> i'm merely observing statistics! not politics.
15:49:22 <SamB_XP> WHAT IS THE MEANING OF THIS, DONS???
15:49:26 <Fuse_> or somesuch.
15:49:35 <_dontpanic_> http://rafb.net/p/ECUAjU52.html
15:49:39 <opqdonut_> so, can anyone golf maybetail = maybehead . tail . tails ?
15:49:41 <lambdabot> Title: Nopaste - No description
15:49:46 <_dontpanic_> i can't believe i'm still struggling with this :/
15:49:52 <ivanm> opqdonut_: "golf"?
15:49:54 <_dontpanic_> i feel stupid
15:50:09 <FunctorSalad> there's also #haskell-blah for the off-topic :)
15:50:18 <ivanm> I'd just have maybeTail [] = Nothing; maybeTail xs = Just (tail xs)
15:50:25 <opqdonut_> _dontpanic_: Rat (a) (gcd b d) + Rat (b) (gcd b d)
15:50:27 <Fuse_> when you say it like that (i feel stupid) it empowers me to actually check the code. haha.
15:50:40 <opqdonut_> ivanm: yeah, but that's longer :P
15:50:45 <opqdonut_> _dontpanic_: that's your problem
15:50:54 <ivanm> _dontpanic_: you need to define addition on Ratnl
15:50:54 <opqdonut_> _dontpanic_: can you see why?
15:51:10 <_dontpanic_> ivanm: via what?
15:51:13 <ivanm> opqdonut_: well, it looks neater than maybeList . tail . tails
15:51:13 <_dontpanic_> instance Num?
15:51:16 <ivanm> yeah
15:51:26 <sjanssen> maybetail(_:x)=x;maybetail _=fail""
15:51:36 <_dontpanic_> ivanm: i wish my prof didn't expect us to know this stuff and have the book w/o examples
15:51:43 <_dontpanic_> cales wiki is barely keeping me alive in this class
15:51:46 <ivanm> sjanssen: ummmm..... that will return a list...
15:51:46 <opqdonut_> _dontpanic_: you are defining +++
15:51:49 <Fuse_> what text do you use?
15:51:53 <sjanssen> ivanm: oops
15:51:56 <opqdonut_> _dontpanic_: you can't define it via + on Rats
15:52:07 <opqdonut_> _dontpanic_: you need to write out the normal definition for rational addition
15:52:08 <ivanm> Cale has a wiki?
15:52:21 <sjanssen> ooh, here's a better one: maybetail xs = do (_:x) <- xs; return x
15:52:31 <mmorrow> _dontpanic_: it could be worse...it could be JAVA!
15:52:33 * mmorrow gasps
15:52:44 <opqdonut_> sjanssen: heh
15:52:45 <_dontpanic_> mmorrow: i would cry -- i already dealt with that POS lang
15:52:49 <Fuse_> anything but java. even ASM
15:52:56 <_dontpanic_> Fuse_: ++
15:52:57 <_dontpanic_> :)
15:53:11 <_dontpanic_> ivanm: see i just don't know the silly syntax here
15:53:19 <Fuse_> after learning Python, I could never go back to Java. It's like Python Beta with ugly syntax.
15:53:23 <ivanm> Fuse_: even COBOL? :p
15:53:27 <Fuse_> ahah
15:53:28 <opqdonut_> sjanssen: except you're missing someting
15:53:31 <ivanm> _dontpanic_: it's not silly at all!
15:53:39 <_dontpanic_> you know what i meant
15:53:49 <_dontpanic_> ivanm: i'm not sayign its silly -- i'm silly because i can't do it lol
15:53:50 <sjanssen> opqdonut_: actually, I think you're building on the wrong primitive.  Create a "maybeuncons :: [a] -> Maybe (a, [a])", then maybetail = fmap snd . maybeuncons
15:53:57 <ivanm> _dontpanic_: heh
15:54:04 <opqdonut_> sjanssen: yeah, that would be the better way
15:54:15 <Fuse_> anybody here used Ada?
15:54:15 <opqdonut_> but mine was something that could be hacked together with perlude
15:54:24 <ivanm> and eventually, we'll create a whole new Maybe-based datatype!
15:54:32 <sjanssen> opqdonut_: maybehead isn't in the Prelude
15:54:47 <opqdonut_> sjanssen: well maybehead = ToList
15:54:50 <_dontpanic_> ivanm: instance Num Ratnl where
15:54:51 <opqdonut_> *listToMaybe
15:55:14 <_dontpanic_> ivanm: i think thats how i start but i have _no_ idea how to finish that thought
15:55:56 <adekoba> Hi. I'm making multiple levels of data abstraction, and there are naming conflicts. I don't want to have to keep naming things like Object/Object1 etc. Is there a strategy to avoid this? Or any experience with this sort of thing?
15:56:01 <olsner> any first-class pattern-matching proposals out there we could use? something like... maybetail = \?(_:xs) -> return xs perhaps? (just making up syntax...)
15:56:09 <ivanm> data MaybeList a = Null | Cons a (MaybeList a)
15:56:17 <ivanm> hmmmm.... that looks familiar... ;-)
15:56:33 <ivanm> _dontpanic_: how do you add rational numbers?
15:56:45 <sjanssen> newtype MaybeList a = ML { unML :: Maybe (a, MaybeList a) }
15:56:52 <ivanm> adekoba: can you give us an idea of what you're wanting?
15:57:09 <opqdonut_> sjanssen: we just need an automatic way of getting the []->\mu X. Maybe (a, X) isomorphism
15:57:12 <ivanm> sjanssen: heh.... though since you've got a record, shouldn't that be data and not newtype?
15:57:12 <opqdonut_> oh, you beat me to that
15:57:13 <adekoba> ivanm: h/o, i'll pastebin
15:57:54 <sjanssen> ivanm: newtypes can have a record filed
15:57:59 <sjanssen> s/filed/field
15:58:01 <_dontpanic_> ivanm: rationalnum(num1 gcd den1 den2) + rationalnum(num2 gcd den1 den2)
15:58:15 <ivanm> oh? I thought they couldn't, so have been using data all along... >_>
15:58:30 <ivanm> _dontpanic_: = ?
15:58:52 <ivanm> ignore the data structure... I have two rational numbers, a/b and c/d
15:58:55 <ivanm> how do I add them?
15:59:12 <Fuse_> are you guys college professors or Ph.D's or...?
15:59:13 <_dontpanic_> a+b / gcd b d
15:59:17 <adekoba> ivanm: http://hpaste.org/10773
15:59:23 <ivanm> Fuse_: I'm an undergraduate mathematician :p
15:59:24 <_dontpanic_> Fuse_: student atm
15:59:37 <adekoba> there are some Ph.D's here :D
15:59:38 <Fuse_> good, good. I didn't want to feel left out
15:59:56 <ystael> Fuse_: and some of us lurkers are just "some guy".  :)
15:59:58 <adekoba> a lot of by-night hackers, too
16:00:00 <Fuse_> I'm a maths undergrad switching to comp sci and chemistry.
16:00:15 <ivanm> adekoba: so I'd just have Tags = ID3v1 Int | ID3v23 Int Int | ID3v24 Int Char
16:00:18 <_ar_> physics grad =)
16:00:23 <_ar_> while we're all reporting in
16:00:28 <ivanm> unless you have operations that are only applicable to ID3v1 or ID3v2
16:00:29 <Fuse_> haskell is just so beautiful. you see that a lot in maths, but it's rarer in programming, even though they're conceptual very similar
16:00:36 <_ar_> grad student i mean
16:00:41 <ivanm> Fuse_: and _chemistry_ :o
16:01:03 <adekoba> ivanm: Yeah, I have binary instances for each... it would be a lot easier to separate them.
16:01:17 <ivanm> _ar_: so are you going to invent your own pseudo-mathematical theory of version control as well? :p
16:01:23 <ivanm> adekoba: *nod*
16:01:25 <Fuse_> chemistry is beautiful, too, because... well... did I mention you get to blow stuff up and make drugs?
16:01:31 <ivanm> you could just make a Tag class instead...
16:01:41 <Fuse_> but seriously, chem can be pretty mathematical - equillibria and complex systems
16:01:41 <adekoba> ivanm: yes, true.
16:01:47 <adekoba> ivanm: alright, well thanks
16:01:53 <_dontpanic_> ivanm: ?
16:02:05 <_ar_> ivanm: huh?
16:02:20 <ivanm> Fuse_: heh, my brother's studying chem here and apparently they keep dumbing down the maths in it (nowhere near as bad as how they're dumbing down the maths in biol though)
16:02:22 * edwardk waves hello.
16:02:27 <_dontpanic_> hi
16:02:29 <bjrn> adekoba: What's that code from?
16:02:39 <Fuse_> so for those of you who work on Haskell as research projects, theses, etc, what is your focus? abstract stuff? real-world use? scientific visualisation (lol)?
16:02:40 <ivanm> _ar_: droundy is a physics prof, and developed the theory of patches which turned into darcs
16:02:45 <adekoba> bjrn: working on an ID3 parsing library...
16:02:55 <bjrn> adekoba: Ah cool. I'm working on a decoder :)
16:03:06 <bjrn> It doesn't understand ID3
16:03:08 <_dontpanic_> ivanm: is there a good place that has this documented?
16:03:11 <adekoba> bjrn: Really? For what?
16:03:12 <ivanm> Fuse_: for what I do with Haskell, see my ANNOUNCE to the mailing lists from 2AM this morning :p
16:03:14 <_ar_> ivanm: ahh a little context makes sense
16:03:16 <bjrn> adekoba: MP3
16:03:16 <Fuse_> ivanm: that sucks. Biology is actually so very mathematical. Evolution is basically just one big optimisation theory. It really needs a solid maths basis.
16:03:17 <_dontpanic_> mmorrow: are you still around i'm floudering in haskell
16:03:20 <Fuse_> genetic algorithms anybody?
16:03:21 <adekoba> bjrn: neat!
16:03:28 <ivanm> _dontpanic_: addition of rationals? ummm... your math textbook?
16:03:36 <adekoba> bjrn: what are you using to parse?
16:03:47 <bjrn> binary-strict is alright
16:03:49 <_dontpanic_> ivanm: i know how to add rationals
16:03:55 <Saizan> _dontpanic_: http://en.wikipedia.org/wiki/Rational_number#Arithmetic
16:03:57 <lambdabot> Title: Rational number - Wikipedia, the free encyclopedia
16:04:08 <_dontpanic_> ivanm: i just am unsure of how i must define the Num isntance
16:04:10 <Fuse_> well, put more accurately, evolution is giant cellular automata
16:04:33 <ivanm> well, extract the components of your data structure, add the rationals, and then put the result back into the format of your data structure
16:04:35 <bjrn> "Can a sufficiently large cellular automata think?" :)
16:04:40 <mmorrow> _dontpanic_: what's it like to have both eyes on one side of your head?
16:04:46 <_ar_> Fuse_: i know a ton of people that would tell you it's statistical mechanics
16:04:48 <edwardk> fuse: parallelism
16:04:54 <_dontpanic_> mmorrow: ?
16:04:55 <mmorrow> _dontpanic_: um, :) what's up?
16:05:05 <mmorrow> (flounders have both eyes. .. (i think))
16:05:10 <mmorrow> anyways, bad joke
16:05:16 <edwardk> fuse: re focus.
16:05:23 <ivanm> @src Num
16:05:23 <lambdabot> class  (Eq a, Show a) => Num a  where
16:05:24 <lambdabot>     (+), (-), (*)           :: a -> a -> a
16:05:24 <lambdabot>     negate, abs, signum     :: a -> a
16:05:24 <lambdabot>     fromInteger             :: Integer -> a
16:05:27 <ivanm> _dontpanic_: ^^
16:05:31 <edwardk> fuse: er and i guess comonads
16:05:31 <Fuse_> _ar_: however you put it, it's a natural metahueristic search algorithm
16:05:46 <ivanm> from memory, you need to define (+), negate, abs and fromInteger
16:05:58 <ivanm> something like that
16:06:03 <Fuse_> but hey, probabalistic computation doesn't preclude metahueristic search
16:06:38 <_ar_> Fuse_: your way makes it sound all "intentional"
16:06:41 <Fuse_> edwardk: ah, cool. I hope Haskell goes somewhere with parallelism.
16:06:43 <edwardk> fuse: gp/ga tends to be a great answer to the multi-armed bandit problem with mutation playing the part of the supply of the payout counters for the low reward arms. on the other hand, the problem is the multi-armed bandit problem is very rarely what you are actually modeling ;)
16:06:50 <ivanm> _dontpanic_: I take it back... you have to define all except one of negate and (-)
16:06:58 <Fuse_> _ar_ no more than a Creationist confuses evolution with some guiding hand
16:07:17 <Fuse_> _ar_ how intential is the output of a cellular automaton? do gliders in the game of life come about by intent?
16:07:30 <mmorrow> _dontpanic_: ah, just scrolled back. yeah, looks like you need to make Ratnl an instance of Num
16:07:34 <Fuse_> does human thought come about by intent or statistical coherence?
16:07:36 <_ar_> Fuse_: missing the point.
16:07:44 <Fuse_> (biological neural net = cellular automaton)
16:07:54 <Fuse_> probably. :(
16:08:05 <_dontpanic_> i'll try
16:08:20 <ivanm> @doc Prelude
16:08:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
16:08:42 <ivanm> _dontpanic_: ^^ look for the Num class (search for "class (Eq a, Show a) => Num a where")
16:08:47 <ivanm> it will tell you what you need to define
16:08:50 <_ar_> Fuse_: i was just noting that calling it an algorithm made it sound intentional, as opposed to statistical side-effect
16:08:55 <bjrn> Is there a Prelude' for Haskell'?
16:08:56 <_ar_> not that it was, or that you were saying it was
16:09:06 <_ar_> algorithms are constructs of the mind
16:09:15 <ivanm> bjrn: there's the numeric prelude...
16:09:54 <Fuse_> _ar_ I disagree. it's a recursive mathematical phenomenon - we call those algorithms, no? *shrug*
16:09:55 <_ar_> calling something a search shows intent, that's all i was trying to say
16:10:04 <edwardk> _ar_: well in some sense it is still guided, you do choose the fitness function
16:10:11 <bjrn> ivanm: Nice, have to try it out :)
16:10:14 <Fuse_> I guess. But nobody would deny that evolution IS a search problem.
16:10:25 <ivanm> bjrn: any particular reason the standard prelude isn't good enough for you?
16:10:39 <_ar_> edwardk: you model a fitness function that approximates something deep that's happening statistically
16:11:02 <Fuse_> fitness functions don't need to approximate a statistical phenonemon at all.
16:11:03 <bjrn> ivanm: Nah it's alright, but I guess there's plenty of discussion about it.
16:11:14 <_ar_> Fuse_: i think he meant biological fitness
16:11:21 <Fuse_> ah
16:11:21 <_ar_> that's all i'm referring to
16:11:22 * edwardk shrugs. I gave up on GP/GA approaches to pretty much anything as there is almost always a better way to burn CPU cycles.
16:11:38 <Fuse_> biological fitness is very complex, but I wouldn't argue it's statistical
16:11:39 <edwardk> ar: i meant in terms of GP/GA. the fitness function which you use to select the next generation
16:12:02 <edwardk> ar: honest to goodness biological fitness is pretty messed up ;)
16:12:08 <Fuse_> aside from non-deterministic irregularities at the quantum level, macroscopic life is fairly causal, if chaotic.
16:12:34 <lament> as opposed to microscopic life?
16:12:37 <Fuse_> real-life fitness function is amazing. it's what, 4 dimensional, with n-dimensional graph vertices?
16:12:47 <_ar_> edwardk: that's a model that seeks to have the kinds of emergent behavior as experienced in biology
16:13:01 <_ar_> edwardk: agreed on messed up. and also impossibly complicated
16:13:08 <Fuse_> lament: macrosopic is used to differentiate between nano and micro in physics
16:13:33 <Fuse_> _ar_ that's why I think we still have a lot to learn from evolution about genetic algorithms
16:13:50 <_ar_> Fuse_: i'd say it's the other way
16:13:53 <lament> in biology, it's used to differentiate between visible and invisible :)
16:14:04 <Fuse_> I mean evolution just popped out a nowhere an enhanced search technique - mating/crossover.
16:14:26 <Fuse_> _ar_ other way...?
16:14:34 <edwardk> ar: well the fitness function can be anything. its the population size, mutation rate, and contour of the problem space that typically define the issue, but we seem to mostly be talking past each other and I don't care enough to dogmatically hold a position on this. ;)
16:14:42 <Fuse_> nanoscopic = quantum effects, van der waals, etc, ya?
16:15:04 <Fuse_> sorry guys. I don't mean to be dogmatic. I just find the topic fascinating.
16:15:21 <_ar_> study of evolution helps gp/ga, not gp/ga provides enhanced understanding of evolution
16:15:25 <ivanm> "nanoscopic"? that's a new term for quantum physics I haven't heard of before :p
16:16:00 <Fuse_> _ar_ I disagree. the study of gp/ga helps us understand evolution mathematically. it's a direct contradiction to Creationism's claims, too.
16:16:08 <_ar_> i'm referring to "i think we still have a lot to learn about evoltion from ga"
16:16:18 <edwardk> ar: completely agreed since it looks like given retroviral snippets in the genome that evolution is a heck of a lot more complicated than flip a few bits here and there and cross strands.
16:16:19 <Fuse_> ivanm: it exists, I believe. I'll check.
16:16:49 <_ar_> edwardk: and i agree on the not dogmatic bit
16:16:56 <Fuse_> http://en.wikipedia.org/wiki/Nanoscale
16:16:57 <lambdabot> Title: Nanoscopic scale - Wikipedia, the free encyclopedia
16:16:57 <ivanm> according to wikipedia (via google), it means "Having a scale expressed in nanometres"
16:17:17 <ivanm> and quantum < nanometres :p
16:17:35 <edwardk> @google picoscopic
16:17:37 <edwardk> =)
16:17:37 <_ar_> Fuse_: gp/ga helps us understand evolution so much as our model is "correct"
16:17:41 <Fuse_> quantum effects are most prominent on the nanoscopic scale.
16:17:42 <lambdabot> http://plib.sourceforge.net/pui/
16:17:42 <lambdabot> Title: The Picoscopic User Interface: Programmers Guide.
16:17:57 <ivanm> edwardk: nah, you'd want angstrom-scopic :p
16:17:58 <Fuse_> _ar_ yes, fair enough
16:18:04 <bjrn> My favorite book store apperantly lists Real World Haskell under the categories "Programming", "Software Engineering", and "Humor".
16:18:21 <Fuse_> genetic algorithms are to evolution what artifical neural nets are to the human brain
16:18:27 <ivanm> bjrn: "humour"? :o
16:18:32 <ivanm> what kind of crazy bookstore is this?
16:18:44 <bjrn> ivanm: Hehe weird isn't it? Sweden's largest online book store.
16:18:44 <ivanm> or are rhinoceros beetles amusing nowadays?
16:19:07 <ivanm> bjrn: maybe it has that really dodgy "amusing" description >_>
16:19:20 <bos> it's a laugh-a-minute sort of book.
16:19:35 <Fuse_> oh, guys, you'll love this. it's absolutely epic. (assuming you know about cellular automata): http://upload.wikimedia.org/wikipedia/commons/7/7d/Textile_cone.JPG
16:19:37 <lambdabot> http://tinyurl.com/5xf24f
16:19:53 <edwardk> angstrom = 10^-10 meters, picometer = 10^-12, so if you need to go 'down a scale' i think you don't have a better SI unit. =P
16:20:00 <ivanm> Fuse_: I'm not finding it that funny...
16:20:06 <bjrn> Fuse_: I have one of those.
16:20:11 <Fuse_> http://upload.wikimedia.org/wikipedia/commons/f/fa/CA_rule110s.png
16:20:12 <lambdabot> http://tinyurl.com/4p95ge
16:20:16 <Fuse_> compare with that
16:20:16 <ivanm> edwardk: well, an angstrom is meant to be the size of an atom, isn't it?
16:20:30 <reified> Fuse_: is it *actually* the result of a CA process though?
16:20:51 <ivanm> edwardk: but yes, it's not SI
16:20:54 <Fuse_> you don't find it ironic that a cone covered its shell in a turing complete cellular automato?
16:21:02 <ivanm> ironic? no
16:21:07 <reified> automato?
16:21:09 <ivanm> interesting maybe, but not ironic
16:21:15 <ivanm> reified: an automatic tomato
16:21:21 <ivanm> ;-)
16:21:26 <Fuse_> :D
16:21:27 <_ar_> reified: i say tomato, you say automato
16:21:51 <Fuse_> reified: yes, it is. it's an imperfect one since there's a slight influence from the outside world, but yes, it is
16:21:55 <mml`> my wife couldn't decide what kind of pizza to get.  i told her to order nondeterministic automato
16:22:27 <Fuse_> "The pigment cells reside in a narrow band along the shell's lip. Each cell secretes pigments according to the activating and inhibiting activity of its neighbour pigment cells, obeying a natural version of a mathematical rule."
16:22:40 <reified> cool!
16:22:48 <_ar_> mml`: i hear those taste the same as deterministic automato
16:22:56 <ivanm> mml`: and did she?
16:23:06 <_ar_> aside from differences in presentation
16:23:40 <bjrn> Fuse_: Whenever I see these photos, I can only think of one thing: undergraduate level math book covers.
16:23:50 <edwardk> yeah
16:23:51 <Fuse_> plant leaves also uses cellular automata to optimise air and vapour flow in the stoma. computations that are NP-hard for normal computers and require long time on a supercomputer are constantly being solved in seconds by plant leaves
16:24:21 <Fuse_> bjrn: my maths text book had a violin on the cover. :(
16:24:22 <opqdonut_> itym solved _approximatively_
16:24:26 <bjrn> On the other hand, beats the graduate level math book covers. "This one is completely yellow"
16:24:32 <edwardk> i have to admit i used to be a lot more impressed by the ANKOS stuff than I am these days
16:24:36 <Fuse_> opqdonut_: yes, I should have added that.
16:24:43 <opqdonut_> that's an important point
16:25:00 <opqdonut_> since most NP-hard problems aren't NP-hard to approximate
16:25:07 <Fuse_> still, it's interesting the plants evolved a CA in their leaves with an algorithm for optimising flow
16:25:19 <opqdonut_> yes, CAs are cool
16:25:30 <reified> Fuse_: So if plants also use cellular automata, there really could be a Turing-complete tomato, or automato?
16:25:36 <ivanm> I still don't think that they're a new kind of science though
16:25:43 <reified> But could it simulate the Universe?
16:25:44 <edwardk> reified: ouch
16:26:02 <Fuse_> reified: hah. yes. but turing complete doesn't mean much, I remind myself, if you can't change the inputs
16:26:03 <ivanm> hmmmm.... the tomatoverse!
16:26:09 <Fuse_> see that's the thing.
16:27:27 <Fuse_> we could create a computer that could simulate the universe. I mean, theoretically.
16:27:37 <edwardk> you say tomato i say tomataumata
16:27:54 <Fuse_> assuming it's a CA and not the product of some twisted meta-consistent logic.
16:27:56 <lament> tomautomata?
16:28:12 <reified> Fuse_: If digital physics is correct, the Universe *is* something like a computer
16:28:25 <_ar_> Fuse_: maybe there are a couple of common chaotic systems that pop up?
16:28:36 <edwardk> lament: er exactly
16:28:37 <tomautomata> reified: yeah but if that's the case, then it must be either inconsistent or incomplete
16:28:47 <Cale> opqdonut_: By "not NP-Hard to approximate" do you mean that for any e > 0 an algorithm which finds the correct answer with probability 1-e is not NP-Hard? Or something weaker?
16:29:06 <cellular_tomauto> tomautomata: Heh-heh. ;)
16:29:12 <tomautomata> hah
16:29:14 <reified> hehe
16:29:38 <lament> medieval astronomers thought the universe was like a giant armillary sphere. modern programmers think it's like a giant computer. Some things never change...
16:29:55 <tomautomata> it's got some good weight behind the idea though
16:30:06 <tomautomata> causality is basically equal to a CA
16:30:07 <edwardk> lament: you use the vocabulary and models that you have
16:30:18 <_ar_> tomautomata: isn't saying that shell is a CA a bit like saying a plant with 9 leaves is a calculator since it has 4+5 leaves?
16:30:20 <tomautomata> thing is, the universe may be non-deterministic.
16:30:20 <reified> http://en.wikipedia.org/wiki/Digital_physics
16:30:22 <lambdabot> Title: Digital physics - Wikipedia, the free encyclopedia
16:30:32 <tomautomata> _ar_ probably.
16:30:37 <tomautomata> but the leave case is different
16:30:44 <tomautomata> it DOEs actively compute air flow on the go
16:30:53 <lament> edwardk: as long as people realize that that's all they're doing, sure
16:30:59 <tomautomata> the cone shell just paints it once based on a CA
16:31:23 <lament> the universe is a giant computer in the same sense that it's a giant pipe organ or a giant napkin or a giant watermelon: you can draw some parallels.
16:32:36 <SamB_XP> lament: I think the "giant computer" idea makes more sense ...
16:32:39 <lament> (why is a universe like a writing desk?)
16:32:46 <reified> "Digital physics holds the basic premise that the entire history of our universe is computable"
16:32:57 <SamB_XP> do pipe organs support physical simulations ?
16:33:05 <bjrn> lament: I'll bite: why?
16:33:17 <ivanm> lament: because people keep trying to leave their mark on it, despite it not belonging to them?
16:33:18 <reified> Pipe organs are the wrong level of abstraction
16:33:21 <mauke> why is an array like a pointer?
16:33:39 <SamB_XP> ivanm: you may be confused with a student's desk
16:33:44 <tomautomata> The universe as a computer isn't far-fetched. Once (if) we get working quantum computers it'll be more meaningful. No guarentees it'll change complexity classes dramatically or anything, though.
16:33:45 <ivanm> true
16:34:11 <tomautomata> in the sense that causality is conceptually equivalent to a CA in a closed system
16:34:21 <lament> reified: that's just because you don't understand music very well
16:34:32 <SamB_XP> lament: explain!
16:34:39 <SamB_XP> also explain the watermelon one
16:34:51 <lament> what is the universe if not a giant multi-part fugue?
16:34:56 <reified> lament: no, its because there is something more fundamental that underlies pipe organs and computers
16:34:56 <SamB_XP> and tell me where you buy your organs and melons ?
16:35:07 <mauke> they have registers?
16:35:13 <jikim> Hey guys, does anyone know how I can get Java commands in Haskell?
16:35:16 <ivanm> reified: you talking about the cryptonomicon, where the guy built a computer from pipe organ pipes?
16:35:17 <tomautomata> Bach's Stocatta in Fugue on the organ is bloody brilliant
16:35:18 <SamB_XP> mauke: lol
16:35:34 <ivanm> jikim: I think everyone here would try to avoid that scenario! :p
16:35:41 <lament> "toccata and fugue"
16:35:50 <bjrn> ivanm: Cryptonomicon or Godel Escher Bach?
16:35:51 <tomautomata> jikim: um. there's no one-to-one comparison. Haskell is lazy functional. Java is eager imperative.
16:35:58 <reified> ivanm: more like "It from bit"
16:35:59 <tomautomata> *no easy
16:36:03 <SamB_XP> bjrn: I don't remember a pipe-organ computer in GEB
16:36:07 <ivanm> bjrn: the Cryptonomicon... I've never read the latter ;-)
16:36:16 <mauke> tomata and fudge
16:36:18 <bjrn> ivanm: Then you should!
16:36:23 <jikim> I don't care if it's eager imperative or not; I just want Java functionality.
16:36:24 <AStorm> @hoogle gcd
16:36:24 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
16:36:25 <edwardk> jikim: as in invoke them from haskell?
16:36:36 <ivanm> jikim: Java "functionality"?
16:36:37 <AStorm> is there a variant that works on many args?
16:36:39 <tomautomata> oh. I thought you mean convert code.
16:36:46 <tomautomata> either way: good luck.
16:36:48 <ivanm> you might want Scala then...
16:37:02 <AStorm> or should I do something like maximum of permutations? (sloooow!)
16:37:08 <tomautomata> you'd have an easier time with JPython and Java.
16:37:10 <mauke> foldl1' gcd
16:37:18 <AStorm> just as I thought ;P
16:37:30 <SamB_XP> tomautomata: if you could find a time machine to go back to when Python 2.1 was current
16:37:53 <reified> www.qubit.org/people/david/Articles/ItFromQubit.pdf
16:37:56 <jikim> My problem is that I have a blazing-fast Java algorithm that I want to compile into my Haskell program.
16:38:10 <lament> the universe is like a watermelon because it's green on the outside, red on the inside, and contains small bits of dense matter suspended in a less solid substrate
16:38:32 <lament> (green and red due to Doppler shift)
16:38:33 <edwardk> jikim: i am unaware of a haskell implementation that runs over the JVM, so the only real way to hook into those functions would be to use the FFI interface to drive java's JNI interface, which is an exercise in frustration. a better thing to search for would be how to transliterate or re-express your java code/idea using haskell primitives
16:38:38 <SamB_XP> lament: but ... the universe might actually be implemented as a computer ...
16:38:47 <reified> lament: sounds like a description of me when I'm sea sick
16:38:53 <ivanm> jikim: ummmm.... "blazing fast"? if you wrote it yourself, why not just re-write it in haskell?
16:38:54 <jikim> I'm not really looking for a Java API.
16:39:12 <tomautomata> SamB_XP: you gotta admit, there's more cross-over, way more, between Jython and Java than Haskell and Java, while Python still preserves many of the features that make Haskell desirable
16:39:20 * ivanm is always suspicious when people say they have a "blazing fast", especially when it's only in language X
16:39:41 <AStorm> @hoogle foldl1
16:39:42 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
16:39:42 <lambdabot> Data.ByteString foldl1 :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
16:39:42 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
16:39:43 <ivanm> isn't Scala meant to have haskellish syntax?
16:39:44 <SamB_XP> ivanm: I always believe them when they show me the photos
16:39:45 <jikim> I need something similar enough to Java that I can use this in Haskell.
16:39:49 <tomautomata> my tomautomata is blazing fast
16:39:53 <ivanm> SamB_XP: photos of what?
16:39:57 <AStorm> hmm, why doesn't lambdabot answer to /msg?
16:40:05 <SamB_XP> ivanm: the flames coming out of the CPU ;-P
16:40:06 <tomautomata> jikim: what's your aim?
16:40:10 <AStorm> oh, it does
16:40:13 <AStorm> but I have to be here
16:40:16 <AStorm> weird ;P
16:40:17 <ivanm> AStorm: lol
16:40:24 <ivanm> SamB_XP: heh
16:40:40 <jikim> tomautomata: I need Java-style memory management, especially OO.
16:40:58 <reified> Java-style memory management?
16:41:04 <tomautomata> You don't control memory management in Java though...
16:41:14 <tomautomata> and Haskell has a pseudo-OO style.
16:41:26 <SamB_XP> jikim: I have difficulty believing that the algorithm requires OO
16:41:29 <edwardk> jikin: haskell is also garbage collected ala java, and oo patterns can be expressed as well. you need to turn your thinking sideways a bit, but its all doable.
16:41:51 <edwardk> @where oohaskell
16:41:52 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
16:41:59 <_ar_> jikim: if you need all of that, use java, not haskell
16:42:03 <tomautomata> the barriers between java and Haskell are minor compared to, say, C++ and Haskell
16:42:13 <bjrn> You could interface java from C, then use the FFI. That is, of course, a bit too much "the daily wtf" for most peoples taste :)
16:43:06 <_ar_> haskell is not java. if you want java, use java, it's java by definition.
16:43:24 <lament> SamB_XP: (re: the universe might be implemented...) I don't know that, and you don't know that, but see http://en.wikipedia.org/wiki/D%C3%A9formation_professionnelle
16:43:25 <lambdabot> Title: Dformation professionnelle - Wikipedia, the free encyclopedia
16:43:35 <jikim> _ar_: I'm trying to insert it/interface it with a Haskell program.
16:43:43 <SamB_XP> _ar_: no, by the reflexive property of equality
16:44:24 <reified> I was going to ask, did Oleg write anything about OO concepts implemented in Haskell, but I see the above paper is by Oleg :)
16:44:44 <ivanm> lol
16:44:49 <lament> (why is the universe like a writing desk? because there's B in both and N in neither)
16:44:57 <_ar_> SamB_XP: cute, but the first java stands for what he wants, the second use is the name and is different by context. forgive me for being ambiguous
16:45:20 <edwardk> jikim: my usual response would be to reimplement it in haskell and see what you learn about both the problem and your solution in the process, but I think you're staring too close at the solution you have in mind to the problem to put it in perspective
16:45:54 <jikim> No, this algorithm wouldn't work in the functional paradigm, particularly with lazy evaluation.
16:45:59 <edwardk> samb: gah, you've been spending too much time in agda ;)
16:46:14 <SamB_XP> edwardk: how do you know it wasn't Coq ?
16:46:15 <edwardk> jikim: you can work in the ST monad, you don't HAVE to be lazy
16:46:31 <edwardk> samb: because you're on the agda mailing list?
16:46:33 <jikim> jimki: That won't solve the functional problem.
16:46:41 <ivanm> jikim: how do you know it wouldn't?
16:46:48 <SamB_XP> edwardk: I thought I'd signed up for coq-club now too ?
16:46:58 <edwardk> samb: fair enough ;)
16:47:15 <edwardk> i try not to play with coq in public.
16:47:23 <SamB_XP> how about wii?
16:47:24 <newsham> teehee
16:47:39 <edwardk> my wii? i whip that out whenever someone comes over.
16:48:06 <SamB_XP> why's that?
16:48:17 <SamB_XP> it's okay when you say "wii", but not when you say "coq"?
16:48:21 <newsham> this would be much more topical on #-blah
16:48:37 <BMeph> edwardk: Now, don't be a Coq blocker, eh? ;p
16:48:54 <newsham> what people prove in their own homes is their own business
16:49:03 * ivanm finds it interesting that with all the where statements, etc. his haskell implementation of an algorithm looks almost identical to the original imperative version
16:49:11 <edwardk> jikim: um, you can reimplement anything you have that is OO based with appropriate type classes and enough micro-olegs of thought.
16:49:13 <ivanm> newsham: lol
16:49:15 <jikim> ivanm: This algorithm depends on a comparison-based architecture for its complexity constraints.
16:49:16 <sbahra> ivanm, what is the algorithm?
16:49:37 <j3parker> functional programming is like communism; it's a good idea but only in theory
16:49:39 * ivanm has no idea wtf a "comparison-based architecture" is meant to be...
16:49:49 <bjrn> Gah stop with the politics!
16:49:52 <ivanm> j3parker: nah, communism fails in theory as well
16:50:15 <newsham> ivanm: the most profitable countries in the world are socialist
16:50:21 <newsham> like the ussa
16:50:39 <jikim> The USA is profitable now?
16:50:40 <_ar_> jikim: seems like you've got a research problem then
16:50:45 <edwardk> jikim: ok, i'll bite. what the heck is a comparison-based architecture?
16:50:50 <newsham> jikim: in theory ;-)
16:50:53 <tomautomata> functional programming is a good idea in practice
16:50:56 <tomautomata> mission critical safety
16:51:02 <tomautomata> kind of like ADA
16:51:07 <_ar_> mission critical safety is for pussies
16:51:12 <ivanm> newsham: I'm not sure if I'd call the USA socialist
16:51:13 <tomautomata> i like pussies
16:51:23 <ivanm> also, whilst communism implies socialism, the reverse isn't true
16:51:32 <edwardk> ivanm: wait until they get done with the bailout ;)
16:51:33 <tomautomata> the USA calls everywhere else socialist, from where I last stood
16:51:38 <ivanm> edwardk: it failed
16:51:48 <SamB_XP> tomautomata: everywhere ?
16:51:51 <jikim> edwardk: It is a model of computation descended from Turing machines.
16:51:53 <newsham> ivanm: we nationalized wall st
16:51:54 <ivanm> tomautomata: I don't think australia has been classified as socialist
16:52:03 <SamB_XP> do we call those gunnary platforms off the shore of the uk socialist ?
16:52:03 <edwardk> ivanm: the first attempt to pass it did. they at last check were looking for a few sacrificial lambs on both side of the aisle to push it through anyways
16:52:04 <ivanm> newsham: I thought congress blocked the bill?
16:52:04 <jikim> As opposed to the Lambda or Nabla Calculi.
16:52:07 <_ar_> people in the USA call people in the USA socialist
16:52:10 <_ar_> don't take it personally
16:52:16 <newsham> ivanm: yah, we're not done yet.  but we already got a few
16:52:17 <tomautomata> ivan: i tried explaining Australia's politics to an American. He called us socialists.
16:52:24 <ivanm> tomautomata: :o
16:52:36 <tomautomata> apparently paid maternity leave and universal welfare are for sissies
16:52:36 <ivanm> just because they're so ridiculously capitalist?
16:52:41 <tomautomata> yup
16:52:52 <_ar_> oh now you guys are stereotyping just as bad
16:52:57 <SamB_XP> tomautomata: did you try explaining america's politics to him too?
16:53:01 <newsham> in soviet amerika insurance company doesnt protect tax payer, tax payer protects insurance company
16:53:09 <ivanm> newsham: heh
16:53:16 <ivanm> that happens everywhere though...
16:53:16 <tomautomata> not really. it's well known America's free market fundamentalism is pretty pervasive, _ar_
16:53:20 <tomautomata> reagonomics
16:53:23 <mauke> in russia, president kills financial crisis
16:53:28 <tomautomata> HAHAHAHA
16:53:28 <ivanm> major disaster... "oh no, it was an act of God, we don't cover them"
16:53:33 <_ar_> tomautomata you're stereotyping
16:53:40 <tomautomata> I am.
16:53:46 <ivanm> tomautomata: this is from "American Hoax"?
16:53:48 * SamB_XP wants God insurance then
16:53:55 <ivanm> (reagonomics, I mean)
16:54:00 <edwardk> samb: lol
16:54:07 * ivanm still wants to see "The Man who Sued God"
16:54:18 <edwardk> samb: can i use that if palin and company wind up in office?
16:54:18 <SamB_XP> all I have to do is make sure I get a theologically sound insurance company
16:54:18 <Pseudonym> That's a good movie.
16:54:19 <Saizan> edwardk: do you intend to resume the "field guide" on recursion schemes someday?
16:54:31 <_ar_> ivanm he probably won because god failed to show for his court appointment
16:54:36 <edwardk> saizan: yeah, i have just been kinda sidetracked
16:54:37 <tomautomata> ivanm: dunno. reagonomics is just this strange idea that all government intervention is bad. lots of libertarians and republicans espouse it.
16:55:06 <ivanm> _ar_: nah, he was taking the church as god's representative to court
16:55:26 <ivanm> tomautomata: have you read American Hoax by Charles Firth (from the Chaser)?
16:55:26 <Pseudonym> BTW, perhaps we could take this discussion to #haskell-blah.
16:55:37 <ivanm> Pseudonym: spoil-sport ;-)
16:55:45 <newsham> reductio ad lambdum
16:55:46 <tomautomata> <SamB_XP> tomautomata: did you try explaining america's politics to him too? <-- yeah. He called the democrats socialists. What can you do? :S
16:55:51 <Pseudonym> Yeah, I know.  But people still come in here wanting to talk functional programming.
16:56:00 <tomautomata> sorry. my bad
16:56:01 <bjrn> Thanks Pseudonym
16:56:02 <_ar_> it's reganomics and most people don't buy it
16:56:22 <Pseudonym> Speaking of which: http://www.se-radio.net/podcast/2008-08/episode-108-simon-peyton-jones-functional-programming-and-haskell
16:56:24 <lambdabot> Title: Episode 108: Simon Peyton Jones on Functional Programming and Haskell | Software ..., http://tinyurl.com/63s243
16:56:32 <Pseudonym> For those who haven't listened to that interview yet.
16:57:12 <Pseudonym> The interviews these guys have done with Erik Meijer and Martin Odersky are also interesting.
16:57:40 <Pseudonym> Oh, and Joe Armstrong.
16:58:20 <ddarius> Yeah, those aren't anywhere near as bad as the other one.
16:58:37 <ddarius> "Thunks, like from VB"
16:58:47 <BMeph> jikim: So, where were you schooled in "comparison-based architecture?" :)
16:58:51 <Pseudonym> Yeah.
16:59:29 <Pseudonym> One thing that I'm surprised wasn't mentioned was the phrase "two-phase commit".
16:59:40 <Pseudonym> Probably because the SER guys don't really understand Haskell's execution model.
16:59:47 <Pseudonym> And fair enough; not every one does.
17:00:29 <bjrn> What's the largest open source Haskell project, in lines of code?
17:00:40 <sbahra> ghc?
17:00:41 <dons> ghc
17:00:47 <sbahra> ghc.
17:00:47 <bjrn> Ah, except ghc :)
17:00:48 <dons> also the oldest.
17:01:00 <dons> hmm. one of the other compilers.
17:01:09 <dons> or theorem provers.
17:01:13 <dons> in the ~100k range.
17:01:24 <ddarius> dons: Do we have code metrics on GHC?
17:01:24 <dons> there's ~1.5M loc on hackage.haskell.org
17:01:31 <dons> spread over 800 projects, fwiw.
17:01:33 <ddarius> Like that silly ohloh thing?
17:01:34 <Pseudonym> The oldest Haskell program still in use.  THat's a tough one.
17:01:53 <Pseudonym> Probably one of the nofib programs.
17:02:01 <BMeph> dcoutts: ping
17:02:19 <dons> Pseudonym: yeah, there's some ~1990 era programs in ther.
17:02:24 <dons> one from wadler, and some others.
17:02:40 <Pseudonym> Yes.
17:02:50 <Pseudonym> For some definition of "used", anyway.
17:03:02 * dons can't wait for full metrics for hackge.
17:03:08 <dons> there's *so* much code there.
17:03:16 <dons> we got several hundred new modules today, thanks to henning.
17:03:25 <dons> if people didn't notice, haskore+supercollider+realtime music
17:04:07 <ivanm> dons: what kind of metrics are you after?
17:04:13 <dcoutts> BMeph: pong
17:04:23 <jikim> BMeph: Mostly I learnt from #algorithms.
17:04:35 <BMeph> dcoutts: I just noticed - the c-i bootstrap script works for me, but 'cabal update' still doesn't go through. Should I add that info to the Trac?
17:04:59 <dcoutts> BMeph: this is the issue with paths and config files right?
17:05:07 <BMeph> jikim: Ah. Okay, that sounds ... complex. Thanks. :)
17:06:06 <BMeph> dcoutts: Well, as far as I care, it's about figuring out why I can't get cabal-install to install anything anymore. :\
17:06:51 <BMeph> dcoutts: At work, that is; it's fine at home. Of course, I'm the network admin at home, heh-heh. ;)
17:07:16 <dcoutts> BMeph: so I suspect it's just the old style config files going wrong
17:07:46 <dcoutts> BMeph: as a workaround you could backup your ~/.cabal/config and then rm it, let it be re-created and edit the paths
17:08:41 <BMeph> dcoutts: ...sounds interesting. I'll give it a go. :)
17:08:44 <ivanm> dcoutts: that reminds me, I saw that cabal-install has a boostrap script... would that work as well if I download the sources locally (for when I install it at uni, where I have no CLI net access :@ )
17:09:00 <m3lawren> q
17:09:14 <dcoutts> ivanm: no, the bootstrap script needs wget or curl
17:09:25 <ivanm> *nod*
17:09:33 <ivanm> in that case I'd be better of doing it manually?
17:09:45 <SamB_XP> how do you have no cli net access?
17:10:19 <ivanm> because to get net access, I have to log in to the proxy via the web browser
17:10:37 <ivanm> and it uses some autoproxy thing that I've never managed to work out to get going at the command line
17:10:57 <SamB_XP> ivanm: I would recommend transferring
17:10:58 <ivanm> and when I asked tech support, they at first had no idea what I was talking about and then didn't see why I'd want it
17:11:39 <ivanm> SamB_XP: what, transferring unis?
17:11:44 <SamB_XP> YES
17:11:46 <ivanm> that's a bit... harsh, isn't it?
17:11:49 <SamB_XP> NO!
17:11:56 <ivanm> especially when I've only got a couple of months to go...
17:12:13 <ozy`> ivanm: clearly, the only reason to be there is to be working on haskell...
17:12:16 <SamB_XP> well, okay ...
17:12:21 <bjrn> Pseudonym: Thanks for linking to the SPJ interview, it's nice :)
17:12:28 <ivanm> ozy`: nope, I do haskell on my own..
17:12:39 <ivanm> (I _do_ have cli access in the labs controlled by the maths sysadmins, but not in those controlled centrally)
17:12:44 <SamB_XP> I guess if you're in your last semester, you can stick it out the rest of the time most easily ...
17:12:50 <SamB_XP> oh
17:12:59 <ozy`> ivanm: :p
17:13:01 <SamB_XP> why don't you just play in the maths labs then ???
17:13:09 <ozy`> can you take your computer into the labs?
17:13:21 * SamB_XP thought ivanm was saying that this was a university-network-wide thing
17:13:22 <ivanm> ozy`: yes, I normally use my laptop
17:13:51 <SamB_XP> if it's just in the mis-managed computer labs, yeah, don't transfer over that ;-)
17:13:51 <ivanm> but we'll be having a practical exam there, and I need to use the computers there rather than my own laptop
17:14:04 <ivanm> SamB_XP: just the generic computers used by us undergrads :p
17:14:07 <SamB_XP> instead, install an alternative OS
17:14:12 <SamB_XP> ;-P
17:14:19 <SamB_XP> or, er, I mean, boot one
17:14:25 <ivanm> SamB_XP: it already _is_ using linux in the labs I'm talking about :p
17:14:40 <ddarius> ivanm: Maybe he meant install Windows
17:14:58 <ivanm> pfffftttt.....
17:15:15 <ivanm> one of the only advantages of these labs is that it runs *nix
17:15:27 <ivanm> of course, it would help if they actually updated the software and made sure it all worked properly :@
17:15:31 <eyu100> @hoogle foldr
17:15:31 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
17:15:32 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
17:15:32 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
17:15:36 <eyu100> @hoogle foldl
17:15:36 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
17:15:36 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
17:15:36 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
17:16:05 <eyu100> foldl add 3 [5, 4]
17:16:10 <eyu100> > foldl add 3 [5, 4]
17:16:10 * ivanm got the lecturer to ask them to install ghc there... after they eventually installed it it complained about libreadline... so I just installed it in my home directory and it works \o/
17:16:11 <lambdabot>   Not in scope: `add'
17:16:16 <eyu100> > foldl (+) 3 [5, 4]
17:16:17 <lambdabot>   12
17:16:28 <eyu100> > foldl (+) 3 [5, 4, 3]
17:16:29 <lambdabot>   15
17:16:39 <eyu100> > foldr (+) 3 [5, 4, 3]
17:16:40 <lambdabot>   15
17:16:49 <eyu100> > foldr (-) 3 [5, 4, 3]
17:16:50 <lambdabot>   1
17:17:23 <Saizan> > foldr f z [a,b,c] :: Expr
17:17:24 <lambdabot>   f a (f b (f c z))
17:17:29 <Saizan> > foldl f z [a,b,c] :: Expr
17:17:31 <lambdabot>   f (f (f z a) b) c
17:18:10 <mauke> > foldr f z [a,b,c]
17:18:11 <lambdabot>   f a (f b (f c z))
17:18:51 <mauke> > foldl (+) 3 [5, 4, 3] :: Expr
17:18:53 <lambdabot>   3 + 5 + 4 + 3
17:19:36 <ushdf> > foldl (*) 1 [1..100]
17:19:37 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
17:19:41 <ushdf> > foldl (*) 1 [1..10]
17:19:42 <lambdabot>   3628800
17:19:49 <mauke> > foldl (*) 1 [1..10] :: Expr
17:19:50 <lambdabot>   1 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
17:20:14 <ushdf> what do you normally use  :: Expr to do
17:20:19 <ushdf> in real coding situations
17:20:19 <eyu100> > foldl1 (*) [1, 2, 3]
17:20:21 <lambdabot>   6
17:20:39 <shrughes> you don't
17:20:42 <mauke> > product [1 .. 100]
17:20:43 <ushdf> thank god
17:20:44 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
17:20:46 <ddarius> ushdf: It's a "hack" primarily for this purpose.
17:20:48 <eyu100> fold1 (-) [6, 5, 4]
17:20:54 <Saizan> ushdf: you don't, it's mostly an hack for teaching
17:20:57 <eyu100> > foldl1 (-) [6, 5, 4]
17:20:59 <lambdabot>   -3
17:21:07 <eyu100> > foldr1 (-) [6, 5, 4]
17:21:08 <lambdabot>   5
17:21:11 <ddarius> However, there are symbolic algebra libraries that work essentially the same way.
17:21:15 <mauke> e.g. if you want to know what that did
17:21:23 <ushdf> i get what it does
17:21:24 <mauke> > foldl1 (-) [6, 5, 4] :: Expr
17:21:25 <lambdabot>   6 - 5 - 4
17:21:30 <mauke> > foldr1 (-) [6, 5, 4] :: Expr
17:21:31 <lambdabot>   6 - (5 - 4)
17:21:33 <eyu100> > foldr1 (-) [6, 5, 4] :: Expr
17:21:34 <lambdabot>   6 - (5 - 4)
17:21:46 <mauke> you can see how it's grouped
17:21:46 <eyu100> > foldr1 (-) [1..100] :: Expr
17:21:48 <lambdabot>   1 - (2 - (3 - (4 - (5 - (6 - (7 - (8 - (9 - (10 - (11 - (12 - (13 - (14 - (...
17:21:51 <ushdf> that is useful
17:21:54 <eyu100> > foldr1 (-) [1..100]
17:21:55 <lambdabot>   -50
17:21:59 <eyu100> > foldr1 (-) [1..102]
17:22:01 <lambdabot>   -51
17:22:05 <eyu100> > foldr1 (-) [1..101]
17:22:07 <lambdabot>   51
17:22:09 <ushdf> folding is the strangest thing i've seen in this language
17:22:11 <eyu100> interesting
17:22:22 <mmorrow> @src reverse
17:22:23 <lambdabot> reverse = foldl (flip (:)) []
17:22:25 <shrughes> folding is a very normal thing
17:22:38 <ushdf> i know but i've never seen it
17:22:40 <shrughes> You do it all the time in other languages
17:22:41 <ushdf> expressed anything like that
17:22:42 <eyu100> @hoogle reverse
17:22:42 <lambdabot> Prelude reverse :: [a] -> [a]
17:22:42 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
17:22:42 <lambdabot> Data.List reverse :: [a] -> [a]
17:22:44 <mmorrow> @src concat
17:22:45 <lambdabot> concat = foldr (++) []
17:22:47 <ddarius> It just captures a simple recursion patterns.  Left folds, in particular, are absolutely rampant in imperative code.
17:22:53 <mml`> i am surprised flip is not a primitive in some other functional languages, e.g. scheme
17:22:59 <eyu100> > reverse "yobananaboy"
17:23:00 <lambdabot>   "yobananaboy"
17:23:04 <ivanm> ddarius: which symbolic algebra libraries?
17:23:12 <ddarius> It's not a primitive in Haskell.
17:23:14 <eyu100> > reverse "YO BANANA BOY"
17:23:15 <lambdabot>   "YOB ANANAB OY"
17:23:27 <eyu100> > reverse reverse "YO BANANA BOY"
17:23:28 <lambdabot>   Couldn't match expected type `[a]'
17:23:32 <ivanm> I ended up just installing and using maxima the last time I needed to do symbolic calculations...
17:23:33 <eyu100> > reverse (reverse "YO BANANA BOY")
17:23:34 <lambdabot>   "YO BANANA BOY"
17:23:38 <mml`> ddarius: granted, no.  i guess i should have said standard library.
17:24:03 <ushdf> > reverse "i met a guy and he spoke in the strangest language, he said to me 'em ot dias eh egaugnal tsegnarts eht ni ekops eh dna yug a tem i'"
17:24:04 <lambdabot>   "'i met a guy and he spoke in the strangest language he said to me' em ot d...
17:24:10 <ushdf> fuck you lambdabot
17:24:32 <BMeph> dcoutts: Meh, no dice. It just rewrites the same file, and bombs out some more. :|
17:24:59 <eyu100> > reverse "he said (lol) : (lol) dias eh"
17:25:00 <lambdabot>   "he said )lol( : )lol( dias eh"
17:25:04 <mauke> > reverse "IN GIRVM IMVS NOCTE ET CONSVMIMVR IGNI"
17:25:05 <lambdabot>   "INGI RVMIMVSNOC TE ETCON SVMI MVRIG NI"
17:25:18 <ushdf> >:O
17:25:19 <eyu100> > reverse "he said (lol) ' (lol) dias eh"
17:25:20 <lambdabot>   "he said )lol( ' )lol( dias eh"
17:25:27 <eyu100> > reverse "he said lol ' lol dias eh"
17:25:29 <lambdabot>   "he said lol ' lol dias eh"
17:25:34 <mauke> "opuld" s <
17:25:42 <Pseudonym> > reverse "SATOR AREPO TENET OPERA ROTAS"
17:25:43 <lambdabot>   "SATOR AREPO TENET OPERA ROTAS"
17:25:47 <ushdf> semper ubi, sub ubi
17:25:56 <mauke> always where under where
17:26:02 <ushdf> :D
17:26:30 <mauke> > transpose . words $ "SATOR AREPO TENET OPERA ROTAS"
17:26:31 <lambdabot>   ["SATOR","AREPO","TENET","OPERA","ROTAS"]
17:26:48 <ushdf> hmph
17:26:56 <ushdf> what's the equivalent to an explode function
17:27:04 <mauke> id
17:27:17 <eyu100> @hoogle id
17:27:18 <lambdabot> Prelude id :: a -> a
17:27:18 <lambdabot> Data.Function id :: a -> a
17:27:18 <lambdabot> Text.Read Ident :: String -> Lexeme
17:27:19 <eyu100> @src id
17:27:19 <lambdabot> id x = x
17:27:27 <BMeph> unsafePerformIO(sendLaunchCodes)? ;p
17:27:37 <stepcut> ?tick ^skf
17:27:38 <lambdabot> ^SKF: 0.00 @ N/A N/A
17:27:44 <eyu100> > id x
17:27:52 <lambdabot>   x
17:27:57 <eyu100> > id 5
17:27:58 <lambdabot>   5
17:28:01 <ddarius> ivanm: I'm not sure what, if any, symbolic attributes DoCon has, but there doesn't seem to be any handy library on hackage.  Googling turns up some things.
17:28:02 <ushdf> that seems profoundly useless
17:28:15 <mauke> :t flip id
17:28:16 <lambdabot> forall b c. b -> (b -> c) -> c
17:28:22 <eyu100> [(Float, Float, Float)]
17:28:25 <Pseudonym> ushdf: Its main use is for plugging in higher-order functions.
17:28:25 <eyu100> > [(Float, Float, Float)]
17:28:26 <lambdabot>   Not in scope: data constructor `Float'Not in scope: data constructor `Float...
17:28:32 <Pseudonym> Where you want "nothing" done.
17:28:36 <ushdf> an example?
17:28:44 <mauke> :t foldr id (.)
17:28:45 <lambdabot> forall b c a. [((b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> b) -> a -> c] -> (b -> c) -> (a -> b) -> a -> c
17:28:50 <ushdf> you mean monadic functions?
17:28:56 <Pseudonym> > foldr (.) id
17:28:57 <lambdabot>       Overlapping instances for Show ([a -> a] -> a -> a)
17:28:57 <lambdabot>        arising from...
17:28:59 <Pseudonym> That.
17:29:06 <BMeph> @src join
17:29:07 <mauke> :t foldr (.) id
17:29:07 <lambdabot> join x =  x >>= id
17:29:07 <lambdabot> forall a. [a -> a] -> a -> a
17:29:08 * ushdf can't read those yet
17:29:10 <Pseudonym> > foldr (.) id [(+1),(*2)] 5
17:29:11 <lambdabot>   11
17:29:22 <ivanm> ddarius: yeah, I saw DoCon, but couldn't work out how it was meant to be used :s
17:29:28 <ddarius> You can always tell a functional programmer from a non-functional programmer because non-functional programmers don't understand the point of the id function.
17:29:35 <Saizan> > zipWith id [(+1),(*2)] [5,3]
17:29:36 <lambdabot>   [6,6]
17:29:40 <BMeph> ushdf: ^^ Like that, ushd. ;)
17:29:41 * ushdf feels excluded
17:29:44 <Pseudonym> It's like asking what's the point of "void" in C-like languages.
17:29:50 <Pseudonym> Why would you want no value?
17:29:58 <ushdf> i know what the point of void is
17:30:02 <mauke> what's the point of having the number 0?
17:30:06 <mauke> it doesn't do anything
17:30:13 <Pseudonym> id is the identity for (.)
17:30:19 <ivanm> Pseudonym: well, why would you? :p
17:30:22 <mauke> id is the identity.
17:30:31 <ivanm> unless your name is Freud
17:30:33 <ivanm> ;-)
17:30:37 * ushdf groans
17:30:40 <Pseudonym> And in Haskell, where everything is algebraic, if you have an operator with an identity, you give the identity.
17:30:48 <Pseudonym> To make the algebra complete.
17:30:52 <Pseudonym> id . f = f . id = f
17:31:07 <ushdf> i'm used to "." as "concatenate"
17:31:09 <ushdf> what's it mean in haskell ;)
17:31:16 <Pseudonym> It's function composition.
17:31:19 <ushdf> also "end of sentence"
17:31:24 <Pseudonym> f . g = \x -> f (g x)
17:31:30 <eyu100> > product [2, 3]
17:31:32 <lambdabot>   6
17:31:34 <ushdf> ohh ok
17:31:35 <eyu100> > sum. product [2, 3]
17:31:36 <lambdabot>       Overlapping instances for Show (a1 -> a)
17:31:36 <lambdabot>        arising from a use of `...
17:31:39 <eyu100> > sum . product [2, 3]
17:31:40 <lambdabot>       Overlapping instances for Show (a1 -> a)
17:31:40 <lambdabot>        arising from a use of `...
17:31:43 <mauke> fg
17:31:48 <Pseudonym> RIght.
17:31:49 <ushdf> wait just to be clear you mean
17:31:54 <ushdf> f . g = \x -> f(g(x))
17:31:55 <ushdf> ?
17:31:58 <eyu100> > (sum . product) [2, 3]
17:31:59 <lambdabot>       No instance for (Num [a])
17:31:59 <lambdabot>        arising from a use of `product' at <in...
17:32:05 <mauke> (x) better written as x
17:32:08 <Pseudonym> Yes, but in Haskell, that's less clear.
17:32:09 <dibblego> yes, some of those parentheses are redundant
17:32:27 <Pseudonym> But that's more traditional mathematical notation, yes.
17:32:34 <ushdf> i like this language more every time i learn something about it
17:32:40 <ddarius> Yeah, void is probably another way to test it swapping sides.
17:32:47 <ushdf> how's it benchmark, usually?
17:32:53 <mauke> huhu
17:32:56 <eyu100> > (+).(*) 2 3
17:32:56 <lambdabot>       Overlapping instances for Show (a -> b -> b)
17:32:57 <lambdabot>        arising from a use ...
17:32:58 <mauke> threadring!
17:33:02 <eyu100> > (+) . (*) 2 3
17:33:03 <lambdabot>       Overlapping instances for Show (a -> b -> b)
17:33:03 <lambdabot>        arising from a use ...
17:33:26 <Pseudonym> eyu100: You multiply 2 by 3.  Then what does (+) do?
17:33:31 <mauke> http://shootout.alioth.debian.org/debian/benchmark.php?test=threadring&lang=all
17:33:33 <lambdabot> Title: thread-ring benchmark | Debian : AMD Sempron Computer Language Benchmarks  ..., http://tinyurl.com/5nmnqh
17:33:51 <Pseudonym> Note that your syntax is also a bit off, but please try to think logically about what you're trying to express.
17:33:57 <eyu100> > (+) . (*) 2 3 4
17:33:59 <lambdabot>       Overlapping instances for Show (a -> b -> b)
17:33:59 <lambdabot>        arising from a use ...
17:34:00 <Pseudonym> > (+1) . (*2) $ 3
17:34:01 <lambdabot>   7
17:34:10 <ivanm> Pseudonym: logic? what's that? :p
17:34:13 <Pseudonym> :-)
17:34:19 <Pseudonym> The ($) is low-precende function application.
17:34:22 <Pseudonym> You could also write this:
17:34:27 <Pseudonym> > ((+1) . (*2)) 3
17:34:29 <lambdabot>   7
17:34:32 <Pseudonym> Or:
17:34:37 <Pseudonym> > let f = (+1) . (*2) in f 3
17:34:38 <lambdabot>   7
17:34:44 <ushdf> > ((+1) . (*2)) 3 :: Expr
17:34:45 <lispy> hey, Pseudonym
17:34:47 <lambdabot>   3 * 2 + 1
17:34:55 <Pseudonym> Hey hey!
17:35:14 * ushdf is in love!!!!!!
17:35:20 <Pseudonym> Group hug!
17:35:21 <ushdf> :O
17:35:32 <lispy> ushdf: but Pseudonym is already married, so don't get your hopes up
17:35:33 <ushdf> > human intimacy
17:35:33 <lambdabot>   Not in scope: `human'Not in scope: `intimacy'
17:35:48 <ushdf> i knew you wouldn't understand
17:35:50 <ddarius> What are the polygamy laws like down under?
17:36:08 <Pseudonym> ddarius: Lacking.
17:36:18 <ushdf> that's the best kind of law
17:49:59 * ushdf throws up on lambdabot
17:50:54 <dolio> @vixen You want a hug?
17:50:54 <lambdabot> i think you know the answer to that one, silly
17:51:17 <dolio> @vixen Clean yourself off.
17:51:17 <lambdabot> ouch! I just spilt hot coffee on myself!
18:12:47 <lispy> ?vixen You doing anything later?
18:12:47 <lambdabot> i'll hafta plead the fifth on that one.
18:13:17 <lispy> ?vixen I have some codata I was hoping you could take a thunk at.
18:13:18 <lambdabot> you remind me of that actor, whatshisname
18:13:58 <dmwit> Ronald Reagan?
18:27:43 <robcrusemefrac> http://gpirate.com
18:27:44 <lambdabot> Title: Gpirate.com - The World's Biggest Torrent Search Engine
18:27:53 <robcrusemefrac> http://gpirate.com
18:27:54 <lambdabot> Title: Gpirate.com - The World's Biggest Torrent Search Engine
18:31:36 <ivanm> yay, spammers :s
18:34:19 <adekoba> does ghc have a --make-clean function, or something similar?
18:34:23 <adekoba> probably not
18:34:34 <ddarius> No
18:35:23 <Shimei2> Does anyone know if the funtional graph library has the searching algorithms described in the user manual somewhere in its current iteration? I'm looking for the depth-first/breadth-first searches in particular.
18:36:11 <Saizan> Shimei2: like in http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Query-DFS.html ?
18:36:14 <lambdabot> Title: Data.Graph.Inductive.Query.DFS, http://tinyurl.com/4larya
18:36:33 <Shimei2> Ah, thanks. I was looking for that.
18:36:48 <newsham> yay http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=all
18:36:50 <lambdabot> Title: regex-dna benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Language B ..., http://tinyurl.com/47qxv5
18:37:02 <newsham> 12.48sec 519bytes (gz)
18:37:17 <newsham> 56% 64% 84% 59%
18:41:37 <dmwit> You know what's crazy?
18:42:17 <lispy> dmwit: what?
18:42:18 <Pseudonym> Putting underwear on your head and saluting is normally seen as crazy.
18:42:21 <dmwit> The first few times are not so different -- 9s up to 12s -- but they look hugely different at a glance because 8s has only one digit, while 11-12s have two digits.
18:42:26 <ivanm> mrd: you around?
18:43:03 <dmwit> (Actually, going from 12s to 9s is quite an achievement... but not the order of magnitude achievement it looks like at a glance.)
18:46:36 <mml`> what are "interesting alternative programs"?
18:46:59 <ddarius> dmwit: I'll sell you a watch for $99.99
18:47:10 <mml`> the perl program seems to spank everything else.  how do i read that part of the chart?
18:47:14 <mrd> ivanm: what's up
18:47:37 <dmwit> mml`: What are you talking about?
18:48:11 <mml`> http://tinyurl.com/47qxv5
18:48:14 <lambdabot> Title: regex-dna benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Language B ...
18:48:47 <dmwit> Oh, I didn't see the alternative programs section, sorry.  Your comment makes total sense now.
18:49:19 <ivanm> mrd: is this something of yours? http://209.85.173.104/search?q=cache:http%3A%2F%2Fpeople.cse.iitd.ernet.in%2F~cs5050211%2Femacs%2Fcabal-mode.el
18:49:20 <lambdabot> http://tinyurl.com/4yep9k
18:49:38 <dmwit> I think the deal there is that each benchmark has certain rules about how you can solve the problem.  If you don't follow the rules, they stick you in a separate section.
18:49:40 <mrd> i wrote a simple and stupid cabal.el
18:50:09 <ivanm> simple and stupid? it at least generates the fields! :p
18:50:23 <ivanm> whereas the one with haskell-mode doesn't
18:50:40 <ivanm> I just can't seem to get it to work... or doesn't it actually have any font-locks or menu?
18:50:59 <mrd> as i was saying :) it just has some keybinds to insert fields
18:51:15 <mml`> dmwit: indeeed: http://shootout.alioth.debian.org/u64q/faq.php#alternative
18:51:15 <ivanm> ahhhh
18:51:16 <lambdabot> Title: Read the FAQ! | x64 Ubuntu : Intel Q6600 quad-core Computer Language Benchma ...
18:51:31 <ivanm> mrd: have you ever thought about sending that functionality upstream to haskell-mode?
18:51:35 <mrd> actually it should highlight field names
18:51:45 <mrd> i didn't even know haskell-mode had cabal support
18:52:00 <ivanm> 2.4 does at least, but it's just font stuff
18:52:05 <ivanm> yours doesn't seem to do that :s
18:52:12 <mrd> ("^[^:]*:" 1 'font-lock-keyword-face)
18:52:23 <mrd> oh
18:52:26 <mrd> buggy
18:52:35 <mrd> probably should have a \\( \\) group in there
18:54:07 <ivanm> *nod*
18:58:38 <lispy> oh how i love regular expressions....I was just debugging them earlier
19:10:31 <ddarius> lispy: Decided to replace your sexpr parser with a pile of regex?
19:11:20 <lispy> ddarius: no, but the lexer had a buggy regular expression
19:38:54 <hasenov_> hello, we need to write some code in java for a project and i was wondering if i could use a haskell interface
19:39:13 <bd_> If you're required to use Java, it's probably a bad idea to use haskell.
19:39:23 <hasenov_> sort of like jython, i looked at jaskell but i'm not sure if its stable enough
19:39:33 <bd_> That wouldn't be java then :)
19:39:39 <bd_> It would be Haskell... on the java interpreter.
19:39:51 <bd_> But if you're required to use Java, it's again probably a bad idea.
19:40:32 <hasenov_> well, we definetly need to implement one part in java, which is to make numbers arbitrarily large (haskell already provides that feature so we can't use it)
19:41:10 <hasenov_> so we thought we could import the java code in jaskell and use lazy evaluation and all that good stuff in there
19:41:33 <hasenov_> im not sure if here is the right place to ask, but does jaskell support infinite lists like haskell?
19:42:18 <hasenov_> and if there is some better interface, some ffi to java, that would also be good
19:43:00 * PHO_ thinks about FFI to JNI API
19:43:20 * PHO_ haven't tried that
19:46:00 <PHO_> http://java.sun.com/docs/books/jni/html/invoke.html#11202
19:46:12 <PHO_> ah, it doesn't look so easy
19:47:18 <adu> PHO_: hmmm
19:47:35 * adu thinks about FFI to Python API
19:48:22 <dolio> jaskell seemed pretty crazy, last I looked.
19:48:59 <adu> dolio: is there a pyskell?
19:49:13 <dolio> Haven't looked for that.
19:49:28 <dolio> Google says no.
19:49:30 <adu> 2way would be nice
19:49:32 <PHO_> hasenov_: why don't you implement the Java part and Haskell part separetely and make them communicate with some kind of RPC?
19:49:55 <PHO_> oops, separately. sorry
19:51:23 <hasenov_> PHO_: i remember reading somewhere where you can call python code from haskell using ffi
19:51:28 <adu> I think the most likely use case I can see for Python<->Haskell API would be to do OOP in Python, then implement the innermost algorithms in pure fast Haskell :)
19:52:12 <lispy> I'd rather do the OOP in Haskell though, personally.  It seems to have a richer object system :)
19:52:23 <hasenov_> PHO_: oops sorry, i guess we could do something like that but that introduces problems like blocking and threads
19:52:29 <lispy> See the OOHaskell paper if you have any doubts :)
19:52:41 <dcoutts> @yarr!
19:52:41 <lambdabot> Where d' all t' pirates come from?
19:52:41 <lambdabot> Great Yarrmouth!
19:52:51 <adu> lispy: right, but it takes popular ideas and cuts them in half, and takes other ideas and glues them together
19:53:13 <adu> lispy: it certainly makes it hard to switch between the two realms of design
19:53:19 <hasenov_> am i correct in assuming that that the Int type can be infinitely large?
19:53:30 <adu> hasenov_: no, thats Integer
19:53:31 <dolio> No. That's Integer.
19:53:46 <dolio> Int is machine-sized, more or less.
19:54:07 <PHO_> Int is at least (or at most) 30 bits long IIRC
19:54:14 <hasenov_> oh ok, so with Integer, it doesnt have an overflow limit like in java?
19:54:40 <adu> hasenov_: the limit is how big your memory is
19:54:51 <humasect> ac: hello
19:54:57 <dolio> I think the actual guarantee in the report is below 30 bits.
19:56:47 <dolio> Oh, I guess it is guaranteed to be 30.
19:57:05 <dolio> I stand corrected.
19:57:19 <dolio> > 2^30
19:57:20 <lambdabot>   1073741824
19:58:30 <dons> newsham: regex-dna roxors, http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=all
19:58:37 <lambdabot> Title: regex-dna benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Language B ..., http://tinyurl.com/47qxv5
19:59:37 <PHO_> Faster than g++!!
20:02:03 * ushdf dispute resolution
20:02:55 <dons> PHO_: :-) parallel regex search.
20:03:08 <dons> faster than perl, using the perl regex matcher.
20:03:13 <dolio> That ATS code is awful. :)
20:03:28 <dons> 3600 bytes versus 500 bytes for haskell.
20:03:33 <dons> so yes, ATS makes its flaws clear.
20:03:45 <lispy> Is ATS a new language?
20:03:49 <dons> haskell looks pretty good there in terms of conciseness/performance.
20:05:07 <PHO_> I don't know anything about ATS but the code looks implementing its own parallelism. Right?
20:05:25 <dolio> It's embedding C code that calls pthreads.
20:05:35 <dolio> If I'm reading correctly.
20:05:43 <dolio> I guess they have no threading/parallelism library.
20:06:57 <mmorrow> heh, a nice touch:
20:06:58 <mmorrow>   substCh etc = [etc]
20:07:09 <PHO_> http://www.ats-lang.org/ hmm
20:07:20 <dons> mmorrow: i liked that too.
20:07:20 <lambdabot> Title: Home Page for ATS
20:07:36 <dons> overall, we're doing well.
20:07:36 <dons>  http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=all
20:07:38 <lispy> dons: how long are the talks usually? (the ones at galois)
20:07:39 <lambdabot> Title: regex-dna benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Language B ..., http://tinyurl.com/47qxv5
20:07:41 <dons> but we need a few more parallel programs.
20:07:45 <dons> lispy, 45 minues.
20:07:50 <dons> lispy, so you're on next tuesday.
20:07:55 <dons> we have a talk on thursday.
20:08:56 <lispy> dons: oh wait, the 7th or the tuesday after that?
20:08:58 <dons> we need a better parallel binary trees.
20:09:09 <dons> checking...
20:09:13 <dons> i thought we decided on the 14th?
20:09:26 <lispy> dons: Yeah, I thought we moved to the 14th too
20:09:26 <dons> but i'm checking. its whatever we agreed on.
20:09:30 <lispy> oh okay
20:09:46 <dons> oh, you wanted 14th? yes. ok.
20:09:52 <dons> looks like i did not actually update that :)
20:09:59 <dons> that works well though.
20:10:00 <mmorrow> what's the difference between regex-pcre-builtin  and regex-pcre ?
20:10:03 <lispy> dons: I just checked the pdxfunc and i didn't see a schedule for the next talk yet.  But, you say, there is one on the 9th?
20:11:07 <mmorrow> i wanna add them/it to regexqq now that 6.10 is almost here and everyone'll have quasiquotes
20:11:17 <lispy> dons: should I expect to talk for the whole 45 min (or should I plan to talk for 30 and answer questions for 15?), can I bring my laptop with slides (keynote probably)?
20:11:22 <dons> lispy: so, 2nd, 7th and 14th.
20:11:46 <mmorrow> ah, n/m. they're the same thing it looks like.
20:11:56 <dons> i'm about to announce the 2nd, then dcoutts on tuesday. and lispy on the following tuesday.
20:12:06 <lispy> dons: are the talks usually at 10:30am?
20:12:25 <dons> yep.
20:12:30 <mmorrow> err, actually i don't think they are..
20:12:35 <dons> 10.30 - 11.20 or so, with questions
20:12:43 <lispy> okay cool
20:12:55 <lispy> dons: so many details :)
20:13:07 <dons> i'll be sending you details tomorrow i think.
20:13:13 <dons> when i do all the other announces.
20:13:23 <lispy> dons: I'll try to make it to at least one of those two talks then.  I'd like to meet people and see how it works, but it sounds pretty standard so far.
20:13:29 <dons> yep
20:13:50 <lispy> dons: oh and just to reconfirm, so bringing my own laptop with slides is the norm?
20:13:57 <dons> yes.
20:14:01 <lispy> dons: is there a white or chalk board?
20:14:05 <dons> whiteboard.
20:14:08 <lispy> awesome
20:14:20 <lispy> Doubt I'll use it, but it's nice to know just in case
20:14:22 <humasect> @lastspoke
20:14:22 <lambdabot> Unknown command, try @list
20:14:26 <dons> sjanssen: chameneos is parallelisable, http://shootout.alioth.debian.org/u64q/benchmark.php?test=chameneosredux&lang=all
20:14:28 <lambdabot> Title: chameneos-redux benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Lang ..., http://tinyurl.com/6zcher
20:14:30 <lispy> ?lastspoke lambdabot
20:14:30 <lambdabot> Unknown command, try @list
20:14:36 <ivanm> is community.haskell.org down?
20:14:50 <humasect> i think its right there where you wrote it
20:15:37 <sjanssen> hmm
20:15:46 <dons> looks like we can improve mandelbrot too, http://shootout.alioth.debian.org/u64q/benchmark.php?test=mandelbrot&lang=all
20:15:48 <lambdabot> Title: mandelbrot benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Language  ..., http://tinyurl.com/4v5dcg
20:15:52 <dons> port the C++ version
20:16:03 <humasect> code.haskell.org warning, also down
20:17:47 <kig> how do i print the uppercase version of each line in a file so that memory usage is O(maximum line size)? map putStrLn . lines . map Char.toUpper =<< readFile "my_file"  doesn't quite work
20:18:26 <dons> well, memory use should be O(1)
20:18:45 <lispy> yeah, where the constant is 4GB ;)
20:18:59 <dons> mapM_ putStrLn . map toUpper . lines =<< readFile "f"
20:19:10 <dons> but better to use Data.ByteString.Lazy
20:19:11 <dons> for speed
20:19:14 <bd_> that should be fine though
20:19:17 <dons> yeah
20:19:22 <bd_> I wonder if kig was confused by the GC?
20:19:26 <dolio> 4 gigabytes... of time!
20:19:34 <bd_> under a certain size it would appear to be O(n) on the file size
20:19:34 <humasect> @tell_me_O_of  map toUpper . lines ["asd","asd"]
20:19:34 <lambdabot> Unknown command, try @list
20:19:36 <kig> ooh, mapM_
20:19:44 <bd_> @does_this_halt fix id
20:19:44 <kig> thank you
20:19:45 <lambdabot> Unknown command, try @list
20:19:58 <lispy> ?faq Does this halt: fix id
20:19:59 <lambdabot> The answer is: Yes! Haskell can do that.
20:20:43 <kig> and yeah, O(1) indeed
20:20:47 <humasect> hehe
20:21:04 <bd_> the lines bit isn't really needed though
20:21:11 <dons> sjanssen: apparently you can also parallelise reverse-complement, http://shootout.alioth.debian.org/u64q/benchmark.php?test=revcomp&lang=all
20:21:13 <lambdabot> Title: reverse-complement benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer L ..., http://tinyurl.com/3qkop7
20:21:42 <Saizan> why not just putStr . map toUpper =<< readFile "file" ?
20:22:12 <dolio> That C++ mandelbrot is actually surprisingly nice.
20:23:16 <dons> can we port it plz :)
20:23:40 <ivanm> hmmm.... I can ssh into haskell, but the web interface is down :s
20:23:42 <kig> i'm writing examples on how to do line-wise IO, toUpper is a bit bad example. better change it to reverse
20:24:30 <sbahra> kig, why?
20:25:22 <kig> toUpper is block-size oblivious
20:26:14 <sjanssen> dons: looks like C++ manages parallel results with spinlocks
20:26:56 <sjanssen> dons: notice how C++ uses 16.57 CPU seconds while GHC only uses 6.16
20:27:33 <sbahra> Why is that bad?
20:27:49 <adu> sbahra: because 16 > 6
20:27:52 <sbahra> Lies.
20:28:38 <lispy> > let 16 = 2 in 16 > 6
20:28:39 <lambdabot>   True
20:29:16 <lispy> > let 16 > 6 = False in 16 > 6
20:29:17 <lambdabot>   False
20:29:23 <adu> lol
20:29:34 <sjanssen> dons: I think chameneos is just too serial for a parallel version -- every thread contends on a single lock
20:30:14 <dmort> > pl f s = (s `elem`) . words
20:30:14 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 15}
20:30:14 <lambdabot> ...
20:31:03 <lispy> does anyone know how to upload project source once you have a projet on the c.h.o?
20:32:04 <dmort> pl f s = (s `elem`) . words
20:32:07 <adu> lispy: i dunno, i was trying to do that about a month ago, and I couldn't figure out how
20:32:42 <sbahra> adu, http://shootout.alioth.debian.org/u64q/benchmark.php?test=chameneosredux&lang=all
20:32:44 <lambdabot> Title: chameneos-redux benchmark | x64 Ubuntu : Intel Q6600 quad-core Computer Lang ..., http://tinyurl.com/6zcher
20:32:53 <lispy> adu: if you have ssh keys setup, then I think it's just a matter of scp repo code.haskell.org:somepath/to/project
20:33:16 <lispy> adu: but, it's the somepath/to/project that I'm ignorant of
20:33:35 <lispy> I was thnking about emailing the admins, but if the info is already available that would be nice :)
20:34:04 <Saizan> lispy: /srv/code/$project
20:35:01 <lispy> Saizan: thank you very much sir
20:35:18 <Saizan> np
20:35:25 <adu> hey, I don't see Aenigma on the front page
20:36:49 <sjanssen> dons: actually, I think there is one tiny change we can make.  Can you test this on a multi core box?  http://hpaste.org/10777#a1
20:37:17 <sjanssen> http://hpaste.org/10777/diff?old=0&new=1 might make all the difference :)
20:44:20 <dons> trying sjanssen
20:44:35 <sjanssen> dons: the third annotation might be very slightly better
20:45:50 <dons> so i should just check on quad core.
20:46:22 <sjanssen> dons: also, "-qm -qw" seems spurious
20:46:43 <sjanssen> dons: yeah
20:46:52 <lispy> yay, now autoproc is on code.haskell.org
20:46:59 <lispy> and I think gwern is going to take over the project too
20:48:49 <ivanm> since community.haskell.org is down, is it still possible to apply for project hosting?
20:49:22 <sjanssen> dons: or maybe -qm -qw is best, I don't really know
20:53:27 <hasenov_> does anyone know any sites that show you how to find large prime numbers?
20:53:45 <Cale> hasenov_: How large?
20:53:47 <hasenov_> besides the haskellwiki entry
20:54:04 <Cale> hasenov_: Like, mersenne prime large, or usably large?
20:55:23 <b7j0c> looking for some simple advice. i have a file i am parsing, every few chars i read i check for some sort of match and signal an error if the data is bad. this will result in a very nested set of case statements...is there a more haskellish way to avoid deep nesting of case statements?
20:55:36 <Heffalump> b7j0c: yes, use an error or maybe monad
20:56:11 <b7j0c> thanks heffalump. is error a monad too? i know of maybe
20:56:13 <mauke> http://mauke.ath.cx/stuff/c/array-pointer.html
20:56:15 <lambdabot> Title: C Programming: What is the difference between an array and a pointer?
20:56:20 <mauke> excellent
20:56:28 <Heffalump> Either is a monad
20:56:54 <mauke> dns + apache is working again
20:56:57 <b7j0c> thanks i will do some digging
20:57:04 <b7j0c> thanks heffalump
20:58:03 <mml`> this is slightly OT, but does anybody have a favorite curses (or at least non-GUI) bittorrent client?
20:58:19 <hackage> Uploaded to hackage: graphmod 1.1.3
20:58:19 <hackage> Uploaded to hackage: haskell-lexer 1.0
20:59:15 <dons> sjanssen: ok.
21:00:55 <dons> arch linux has 602 haskell packages now.
21:06:38 <sjanssen> dons: the ones to try out are http://hpaste.org/10777#a2 and http://hpaste.org/10777#a3 (the latter might be considered cheating)
21:07:40 <dons> ok
21:07:56 <dons> and with what flagss? +RTS -N4 {-qw -qm}
21:07:57 <dons> ?
21:08:17 <sjanssen> +RTS -K100M -N5 -qm -qw -RTS 6000000
21:08:34 <dons> ok.
21:11:00 <adu_> isn't Either usually used for errors tho?
21:11:18 <bd_> tho...?
21:11:44 <dons> sjanssen: not getting any speedup. with a1 I can get more cpu utilisatoin, but longer running times, without -qw -qm. with -qw -qm i get the same as with no -N value.
21:12:17 <sjanssen> so -qw -qm are probably bad for chameneos
21:12:21 <dons>  134% cpu 47.255 total gets dramatically slower with -N4 and no -qw -qm
21:12:47 <dons> getting GC stats...
21:12:48 <sjanssen> did you have a chance to try a3?
21:12:54 <dons> yeah. a little slower overall
21:13:00 <sjanssen> weird
21:13:02 <dons> sorry, i tried a1, a2 and a3
21:13:12 <dons> no GC happening.
21:13:25 <dons> hmm. 9 tasks created.
21:13:42 <dons> how many threads are forked?
21:13:57 <sjanssen> 3 for the first run
21:14:09 <sjanssen> 10 for the second
21:17:04 <sjanssen> a3 should get a nearly perfect 2x speed up, I can't imagine what is going on there
21:24:18 <dons> hmm. ok. trying again.
21:26:53 <dons>  $ ghc -O2 -threaded -funbox-strict-fields --make C.hs -fbang-patterns
21:27:03 <dons> $ time ./C +RTS -N5 -RTS 6000000
21:27:04 <dons>  ?
21:27:13 <sjanssen> dons: yeah
21:27:42 <dons> much slower. weird.
21:27:47 <dons> maybe lots of context swapping
21:28:11 <sjanssen> must be
21:28:46 <sjanssen> dons: so failing a properly threaded version, the original should be a bit faster without -threaded
21:28:50 <dons> ./C +RTS -N5 -RTS 6000000  55.02s user 47.11s system 155% cpu 1:05.56 total
21:29:05 <dons> versus about 4.7s without -N
21:29:06 <sjanssen> wow
21:29:19 <dons> ./C 6000000  5.19s user 0.00s system 97% cpu 5.306 total
21:29:29 <cjb> so, question:  are there any standard unix utilities that could be made faster by rewriting with par?
21:29:38 <bd_> cjb: sort, maybe?
21:29:59 <cjb> 'cause it seems that they're all written in C, and that it's so ridiculously hard to do on-demand SMP in C that I bet some are missin
21:30:00 <cjb> g
21:30:43 <sjanssen> dons: yeah, I guess context switches are so expensive that they eat up any concurrency gains
21:37:26 <dons> ./C +RTS -N5 -qm -RTS 6000000  5.40s user 0.03s system 99% cpu 5.448 total
21:37:34 <dons> gets it back down to single core performance.
21:38:02 <sjanssen> -qm is the "don't migrate" flag?
21:38:06 <dons> yeah.
21:38:12 <dons> so keeps them on whatever they're on.
21:38:15 <dons> but notice no parallelism
21:38:20 <dons> ./C 6000000  5.18s user 0.02s system 99% cpu 5.208 total
21:39:07 <sjanssen> is it possible to start a thread on a specific capability?
21:39:47 <dons> yes, forkOnIO
21:39:56 <dons> so maybe that would work...
21:40:03 <dons> i do that in thread-ring
21:40:07 <dons> should have remembered that :-)
21:40:12 <dons> look at thread-ring #2
21:41:41 <sjanssen> so we want to start all the threads on the first "run" on CPU 1, and all the threads on the second run on CPU 2
21:42:14 <newsham> > sum [0.9**n | n <-[1..100]]
21:42:15 <lambdabot>   8.99976094741001
21:42:22 <newsham> >>> sum(0.9**n for n in xrange(100))
21:42:23 <newsham> 9.9997343860111219
21:42:30 <newsham> oops!
21:42:39 <newsham> forgot n==0
21:42:41 <sjanssen> dons: and then run with -qm
21:44:15 <mmorrow> newsham: i was about to tell you about derive, but upon just checking it looks like you already saw it :)
21:44:17 <sjanssen> dons: http://hpaste.org/10777#a4
21:44:28 <mmorrow> newsham: cool stuff http://www.thenewsh.com/~newsham/store/DeriveBinary.hs
21:45:17 <mmorrow> newsham: i have a darcs repo of some template-haskell utils i've been putting together (need to update it with some more stuff i've got...)
21:45:20 * mmorrow gets the link
21:45:44 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/
21:45:55 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
21:46:10 <mmorrow> it assumes ghc >= 6.9 though (i believe ...)
21:46:26 <mmorrow> (because of the template-haskell lib, not any extensions or anything)
21:47:26 <mmorrow> whoa, i haven't updated that for a while. got a bunch more stuff to put in.
21:47:56 <sbahra> cjb, grep
21:47:59 <mmorrow> the best part is instance of Lift for all of the TH ast:
21:48:00 <sbahra> cjb, diff
21:48:08 <mmorrow> , $(lift =<< reify ''Info)
21:48:11 <lunabot>  TyConI (DataD [] Language.Haskell.TH.Syntax.Info [] [NormalC Language.Has...
21:48:18 <sbahra> cjb, not sure if gnu tar has been parallelised (probably has, BSD tar has)
21:48:30 <sbahra> cjb, find
21:49:38 <dons> sjanssen: ./D 6000000 +RTS -N5 -qm  9.36s user 0.00s system 192% cpu 4.874 total
21:49:41 <dons> :)
21:49:53 <dons> we're in business.
21:50:05 <humasect> mmorrow: where is modules -> graphviz ? =)
21:50:12 <humasect> (just wondering =)
21:50:33 <mmorrow> heh. just added that to the short list. (really.) :)
21:50:40 <int-e> system 192%. heh. crazy.
21:50:50 <humasect> hehe ok ^_^
21:50:57 <newsham> mmorrow: thank you.  on the one hand its disheartening that someone else did it already and much better, but on the other hand, it was fun to learn, and I think I have some interesting strange cases I may want to support that arent supported by the derive lib
21:51:34 <sjanssen> dons: hmm, possibly faster than the C++ leader.  Do you know how your machine compares to the shootout machine?
21:51:38 <dons> sjanssen: so, ./D 6000000 +RTS -N5 -qm -sstderr  9.24s user 0.02s system 188% cpu 4.913 total
21:51:42 <dons> its hmm. a bit faster i think.
21:51:48 <dons> but its loadedup.
21:51:53 <dons>  14:51:49 up 148 days, 15:15, 69 users,  load average: 1.71, 1.56, 1.42
21:52:47 <sjanssen> hopefully they don't consider this cheating
21:53:03 <dons> i think we're pretty loose with parallelisation strategies
21:53:14 <int-e> well there isn't much to parallelize otherwise.
21:53:16 <dons> so does it give the same output?
21:53:29 <mmorrow> newsham: totally. i think it was most definitely worth doing despite that it's already been done in derive. some of the derive code is somewhat unreadable (on account of the way it's prettyprinted), and there're a ton of side-case/whatever that need to be added to it/written in general to get closer to awesome. (don't get me wrong, derive's is sweet and all).
21:53:30 <sjanssen> int-e: right
21:53:35 <dons> i'll upload it.
21:54:01 <newsham> i'll check out your util lib..  gotta run..
21:54:13 <mmorrow> newsham: i've been trying to make a list lately of things other than instances to derive...
21:54:17 <mmorrow> cool, have fun :)
21:54:43 <_dontpanic_> 'm going to bed
21:54:46 <_dontpanic_> thanks for the helps
21:55:00 <mmorrow> night
21:56:36 <dons> sjanssen: how would you describe the parallelisation strategy?
21:58:50 <sjanssen> dons: coarse grained parallelism by running the two separate trials simulataneously
21:59:18 <dons> ok.
21:59:26 <dons> we do gain over single core, 5.3s to 4.0s
21:59:58 <dons> on a loaded machine.
22:00:03 <dons> so expecting a bit better on the shootout.
22:00:40 <dons> submitted. http://alioth.debian.org/tracker/index.php?func=detail&aid=311147&group_id=30402&atid=411646
22:00:42 <int-e> dons: can you paste the sstderr output somewhere, please?
22:00:43 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311147 Haskell GHC: paral ..., http://tinyurl.com/42dpa3
22:01:01 <dons> yes.
22:01:34 <dons> http://www.cse.unsw.edu.au/~dons/chameneos-rts.txt
22:03:54 <int-e> Heh, it's almost boring actually. Virtually no GC time (ok, that shouldn't be surprising), and two fairly balanced worker threads, as desired.
22:03:58 <int-e> thanks
22:05:10 <dons> yes.
22:06:15 <Saizan> so running with -N2 (or 3?) would give the same results?
22:06:55 <sjanssen> Saizan: yes
22:07:04 <dons> yep
22:07:14 <dons> fomr -N1 to -N2 show speedup
22:07:37 <dons> how does the C++ program do its parallelisationnn?
22:08:10 <sjanssen> one run at a time, spinlocks instead of blocking mutexes
22:09:46 <sjanssen> so they waste a lot of CPU, but it turns out to be a net win
22:14:29 <int-e> a spinlock ... hmm. yes, because all that matters in this benchmark is making progress, and every time you take the lock - no matter which thread does it - you get progress.
22:16:09 <dons> so can we do something in that direction?
22:16:30 <sjanssen> they apparently don't count chameneos-redux in the default rankings, why?
22:16:39 <dons> oh, not enough programs submitted  to it yet/
22:16:57 <dons> actually, its looking pretty comprehensive
22:17:41 <dons> note how poorly erlang does due to all the switching, i suppose
22:17:56 <dons> languages good at threading need careful scheduling support too
22:24:07 <unmarshal> if i'm inside a monad and i need to do something like foldM but over a Data.Map must I do a toList on the Map or is there any other function that will allow me to do this
22:29:47 <Cale> unmarshal: I think there's a foldM in Data.Foldable
22:30:29 <Cale> unmarshal: That is, if you're just folding over the elements
22:30:50 <Cale> unmarshal: The usual thing is to use toList though.
22:32:29 <Saizan> :t Data.Map.fold
22:32:31 <lambdabot> forall a b k. (a -> b -> b) -> b -> M.Map k a -> b
22:33:30 <int-e> dons: so that C++ implementation of lock() (on x86-64) is essentially a loop consisting of a cmpxchg, and a sched_yield if the cmpxchg fails. (It's noteworthy that the implementation does not use pthread_spin_lock (which would probably perform horribly, because it doesn't suspend the thread voluntarily)
22:34:35 <unmarshal> Cale: thanks, i'll just use toList, seemed incorrect, but i used google code search and found a bunch of examples
22:34:38 <unmarshal> thanks
22:35:01 <unmarshal> this is my first foray into actually using monad transformers
22:35:10 <mmorrow> , eval "eval \"42\""
22:35:12 <unmarshal> so running into little things i haven't thought about before hehe
22:35:13 <lunabot>  <<Dynamic>>
22:35:19 <mmorrow> oh SnAP
22:35:32 <mmorrow> hackery FTW!
22:36:21 <mmorrow> , maybe Nothing fromDynamic (fromDynamic (eval "eval \"42\"") :: Maybe Dynamic) :: Maybe Integer
22:36:24 <lunabot>  Just 42
22:36:35 * mmorrow does a giddy dance
22:37:36 <Twey> :t fromDynamic
22:37:37 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
22:37:54 <Twey> Oh ah.  TH.
22:38:52 <lispy> I love how that reads
22:39:14 <lispy> maybe nothing from dynamic, from dynamic eval "eval 42"
22:39:38 <mmorrow> the eval function has itself in its environment, so you can nest them infinitely deep
22:39:45 <int-e> dons: Not sure we can match that without changing the RTS. We need a different locking primitive instead of MVars, the problem with MVars being that only one thread gets woken up when it's being filled, while the C++ version has several threads just waiting (busily) for an opportunity to jump in and do some work.
22:40:10 <Saizan> , fix error
22:40:15 <lunabot>  Killed.
22:40:15 <mmorrow> and the /best part/ is that that function itself is what's being used at the /top/ level in the evaluator
22:40:22 <mmorrow> , eval "fix error"
22:40:25 <lunabot>  <<[Char]>>
22:40:44 <mmorrow> , eval "fix (eval \"error\")"
22:40:47 <lunabot>  luna: Couldn't match expected type `a -> a'
22:40:47 <lunabot>         against inferred type `Data.Dynamic.Dynamic'
22:40:56 <sjanssen> int-e: perhaps STM could work?
22:41:19 <int-e> I don't know enough of the STM internals to speculate on that.
22:42:03 <dons> hmm
22:42:11 <dons> ok.
22:42:16 <dons> too hard to make much progress here.
22:42:17 <ivanm> http://hpaste.org/10778 <-- do people think this is an adequate summary of haskell for mathematicians?
22:42:21 <dons> we can move on to other things.
22:42:55 <crutcher> I've got a performance issue I don't understand. Its small, but measurable on large numbers of iterations.  http://hpaste.org/10779
22:43:03 <mmorrow> Twey: Data.Dynamic.fromDynamic
22:43:15 <int-e> I also think that this behaviour of MVars is generally very useful.
22:43:22 <crutcher> In this code snippet, z' and z'' are very similar, but z'' uses an accumulator.
22:43:37 <crutcher> I would think that z'' would be faster, but it isn't.
22:44:33 <Saizan> crutcher: that's a lazy accumulator
22:44:40 <crutcher> ?
22:44:43 <quicksilver> crutcher: well, the accumulator wastes a little bit of space and time.
22:44:56 <quicksilver> crutcher: meanwhile GHC manages to infer strictness automatically on the first one.
22:45:11 <quicksilver> (I'm guesing it does; that would be consistent with it being faster)
22:46:36 <crutcher> is it strictness, or does it notice (x + (y + z'' y)) and reduce this to ((x+y) + z'' y), and go ahead and compute (x+y)?
22:48:14 <quicksilver> no
22:48:21 <quicksilver> there are no associative laws in GHC
22:48:45 <Saizan> crutcher: try adding  '!' on the a parameter of f, like f !a 0 = ..; that should make z'' the fastest
22:49:02 <crutcher> what does that mean?
22:49:20 <Axman6> makes it strict
22:49:25 <Axman6> a strict*
22:50:14 <lispy> f !a 0 = ...; is the same as f a b | a `seq` False, or something like that.  I know I have it wrong actually.
22:50:17 <crutcher> I get a parse error when I do that.
22:50:31 <lispy> crutcher: maybe you need to compile with -fglasgow-exts ?
22:50:47 <lispy> if that works there is probably a more specific option for just bang patterns
22:51:26 <crutcher> nope, still doesn't work.
22:52:24 <Axman6> -Xbangpatterns i think
22:52:31 <Axman6> -XBangPatterns maybe
22:52:43 <crutcher> -fbang-patterns
22:52:58 <chrisdone> anyone used pappy?
22:53:02 <crutcher> that worked, but isn't faster.
22:53:32 <Axman6> try using $!
22:53:39 <Axman6> @src ($!)
22:53:39 <lambdabot> f $! x = x `seq` f x
22:54:01 <Saizan> crutcher: btw, are you compiling with -O2 ?
22:54:20 <crutcher> no, let me try that.
22:54:33 <quicksilver> ah then my previous comment about inferring strictness is way off :)
22:54:41 <quicksilver> no such thing happens without optimisation.
22:55:41 <crutcher> k, with -O2 z'' is in fact faster, without any games played with seq
22:56:18 <Saizan> yeah, it can infer the strictness for such a simple loop, especially since you've specified Int, i guess
22:57:18 <BMeph|asleep> Go for Int#, now! :)
22:59:29 <crutcher> is that the unboxed Int? how would I do that?
23:00:27 <mmorrow> pattern match on an Int and extract the unboxed part
23:01:11 <mmorrow> f (I# n) = W# (int2word# n)
23:01:13 <int-e> BMeph|asleep: ghc does that for you, if it can infer the required strictness
23:01:35 <mmorrow> yeah, saying nothing about if you actually /need/ to do that..
23:02:20 <BMeph> Kuhl. :)
23:04:59 <int-e> but here's a puzzle. why does z' get compiled to, paraphrasing the core,  z' n = case n of 0 -> 0; -2147483648 -> let n' = divInt (-2147483648) 5 in n' + z' n'; n -> let n' = divInt n 5 in n' + z' n' ?
23:06:19 <sjanssen> int-e: I'm not sure, but I've seen it before
23:06:23 <int-e> Ah. I see why. a `div` b | a == minBound && b == (-1) = overflowError
23:06:47 <dons> haskell.org down?
23:06:49 <int-e> (from the Integral instance for Int)
23:07:03 <int-e> dons: no?
23:07:08 <dons> hmm
23:07:54 <int-e> that should be written as  b == (-1) && a == minBound, perhaps.
23:09:34 <ozy`> okay, having just seen how one defines a list representing the entire Fibonacci sequence, I have to admit that lazy evaluation is really really cool... but I'm still curious as to why it's the default
23:10:02 <dons> int-e: can you try again, refreshing?
23:10:08 <dibblego> because it's the most often desired
23:10:34 <dons> hmm. i can get it from code.haskell.org
23:10:47 <int-e> dons: still works for me.
23:11:05 <dons> yep. ok.
23:11:08 <dons> something wrong on my end.
23:11:11 <unmarshal> hmm
23:11:14 <unmarshal> not loading for me
23:11:53 <int-e> http://downforeveryoneorjustme.com/haskell.org
23:11:54 <lambdabot> Title: It's just you.
23:12:10 <unmarshal> weird, must be me too then
23:12:12 <unmarshal> comcast dons?
23:12:14 <int-e> (see. no need to even visit the page. lambdabot tells us all we need to know :)
23:12:18 <dons> unmarshal: yeah. maybe.
23:12:20 <unmarshal> yeah
23:12:49 <dons> is it down for comcast, or just me? :)
23:12:55 <unmarshal> down for me as well
23:13:01 <unmarshal> The server at haskell.org is taking too long to respond.
23:13:10 <Axman6> OpenDNS says it's down
23:13:14 <dons> is it down for everyone, or just comcast? :)
23:13:28 <BMeph> ozy': Because it's easier to tell where you can use strictness for better effect than laziness. :)
23:13:36 <ozy`> OpenDNS sucks.... OrSoIHear
23:13:40 <aprocter> down for me as well (not on Comcast)
23:13:54 <unmarshal> PST?
23:13:59 <ozy`> BMeph: heh, that works for me
23:14:01 <unmarshal> im in california
23:14:06 <unmarshal> sf
23:14:09 <BMeph> Same here.
23:14:14 <aprocter> Missouri
23:14:43 <dons> hmm. down for the states?
23:14:50 <BMeph> Oh - by "the server," does the Wiki count, or do you mean c.h.o, and hackage? :)
23:14:51 <dons> yale got moved to europe?
23:14:58 <dons> BMeph: just the wiki.
23:15:10 <dons> c.h.o is elsewhere, hackage is another elsewhere.
23:15:14 <aprocter> It's back for me now
23:15:20 <ivanm> the wiki is up down under...
23:15:21 <dons> back now.
23:15:22 <dons> phew.
23:15:23 <BMeph> dons: Then, I think it's just Comcast; it's paging fine for me.
23:15:27 <dons> life returns to normal.
23:15:58 <BMeph> dons: Heh-heh, cable envy. ;)
23:16:12 <unmarshal> back for me as well
23:16:15 <Axman6> me too
23:16:36 <Axman6> all is well people, do about your business as usual
23:16:41 <Axman6> go*
23:17:04 <Adamant> it work for US SE on Comcrap
23:17:49 <Adamant> ugh. I really hate sounding like I don't know English because of a overly short response.
23:21:04 <BMeph> Adamant: At least you don't have an ovary short response... ;)
23:21:19 <Adamant> heh heh heh
23:21:50 <Adamant> I almost had "soundling" in the sentence before I corrected it.
23:22:05 <TSC> ivanm: Are you the Graphalyze ivanm?
23:22:20 <ivanm> TSC: yes
23:22:34 <ivanm> yay! someone saw my ANNOUNCE! :p
23:22:44 <TSC> Yeah, I did (:
23:22:50 <TSC> ivanm: It's a pity your talk is all the way north in Brisbane; it looks interesting
23:23:07 <ivanm> TSC: well, I'm not going down to you :p
23:23:23 <ivanm> I can show you my draft talk outline (I'll be doing the slides up this weekend) if you want...
23:23:32 <BMeph> dons: Oh, thanks for the Mersenne link; I tried to pull up the file with all digits in it, and crashed the browser. :)
23:23:47 <dons> hehe
23:23:47 <ivanm> same here :s
23:23:51 <TSC> ivanm: Will you put the slides up when you've done them?
23:23:54 <ivanm> yup
23:24:00 <TSC> Cool
23:24:08 <humasect> ac ~
23:25:37 <Axman6> @src (+++)
23:25:38 <lambdabot> Source not found. You untyped fool!
23:25:46 <Axman6> hmm
23:25:59 <Axman6> HAppS needs _some_ documentation -_-
23:26:26 <humasect> @src Text.Html.(+++)
23:26:27 <lambdabot> Source not found. Wrong!  You cheating scum!
23:26:40 <Saizan> (+++) is likely from Text.XHtml, yeah
23:26:51 <Saizan> @hoogle (+++)
23:26:51 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
23:26:51 <lambdabot> Text.ParserCombinators.ReadP (+++) :: ReadP a -> ReadP a -> ReadP a
23:26:51 <lambdabot> Text.ParserCombinators.ReadPrec (+++) :: ReadPrec a -> ReadPrec a -> ReadPrec a
23:27:07 <Axman6> yeah it appears it is
23:27:29 <humasect> i made lots of webpage stuff in the last few days with Text.Html ; pretty neat stuff. i am glad to use haskell for the task, it is much easier and simpler; also more fun
23:28:37 <pantsd_> How would I get the integer part of a divions (i.e. 5/2 -> 2 )
23:28:39 <pantsd_> ?
23:28:53 <ivanm> > 5 `div` 2
23:28:54 <lambdabot>   2
23:29:00 <ac> humasect: ~
23:29:02 <ivanm> > 5 `quot` 2
23:29:03 <lambdabot>   2
23:29:15 <humasect> ac =)
23:29:16 <ivanm> ^^ div for remainders, quot for moduli
23:29:18 <pantsd_> yays!
23:29:21 <pantsd_> thanks
23:29:25 <ivanm> no worries
23:29:37 <ivanm> > 5 `divrem` 2
23:29:38 <lambdabot>   Not in scope: `divrem'
23:29:39 <Cale> uh
23:29:42 <humasect> here ac: http://96.51.4.55/~humasect/
23:29:42 <lambdabot> Title: Hoovy Studios
23:29:51 <ivanm> or have I got them the wrong way round?
23:29:53 <humasect> under 'novapilot'
23:29:53 <ivanm> @hoogle quot
23:29:54 <lambdabot> Prelude quot :: Integral a => a -> a -> a
23:29:54 <lambdabot> Text.XHtml.Frameset quote :: Html -> Html
23:29:54 <lambdabot> Text.XHtml.Strict quote :: Html -> Html
23:29:59 <Cale> div is the quotient and mod is the corresponding remainder
23:30:04 <Cale> there's also quot and rem
23:30:14 <Axman6> rem cunfuses me
23:30:19 <Axman6> confuses too. far out
23:30:20 <Cale> They have slightly different behaviour with regard to negative values
23:30:35 <Cale> > rem (-1) 5
23:30:36 <lambdabot>   -1
23:30:37 <Axman6> > (-10) `rem` 3
23:30:38 <lambdabot>   -1
23:30:41 <Cale> > mod (-1) 5
23:30:42 <lambdabot>   4
23:30:46 <ozy`> Axman6: how about the foo fighters, then?
23:31:01 <Axman6> so so
23:31:08 <Axman6> :P
23:31:31 <Axman6> they were on one of the episodes of the west wing i was watching last night
23:31:57 <ac> humasect: cool. So it /is/ for games. Is there a darcs repository?
23:32:36 <humasect> ac: yes, but, i am not sure if i can have that online yet. i am working on seeing if i can get haddock up at least
23:50:03 <opqdonut_> Cale: no, I meant approximation in the sense "finds a solution x with utility at least \omega(x) \ge \omega^*/\alpha where \omega^* is the optimum utility"
23:50:31 <opqdonut_> Cale: and yes, I know this isn't a decision problem
23:51:01 <Cale> I'm sure it could be encoded into one
23:51:10 <opqdonut_> yes
23:51:40 <opqdonut_> tho I can't recall how the problems of type "is X > n?" behaved
23:54:40 <Cale> I wonder if there are, say, polynomial time algorithms for getting arbitrarily good approximations in the sense that I mentioned (where the probability that the answer is incorrect is less than e), what that implies about the complexity of the exact problem.
23:56:38 <dons> http://haskell.org/haskellwiki/Haskell_Platform
23:56:40 <lambdabot> Title: Haskell Platform - HaskellWiki
23:58:48 <Cale> It's sort of like saying that mostly the problem is not so hard, but I suppose it's possible there might be small islands of difficulty.
