00:01:21 <sjanssen> sure.  The reasons your C++ wins is probably because of the following restrictions: restricted to one type rather than polymorphic, bounded size, and restrictions on the behavior of readers and writers
00:03:42 <FunctorSalad> so what's an arrow in math terms? as far as I can see so far, it's a category C with the same objects as Hask and with a functor from Hask to C
00:04:02 <FunctorSalad> and something about the products
00:08:23 <rwbarton> FunctorSalad: It's not something particularly useful
00:09:40 <FunctorSalad> rwbarton: viewing arrows in ct terms? or arrows in general?
00:10:39 <rwbarton> FunctorSalad: the category-theoretic notion that corresponds to an arrow
00:11:45 <Myoma> does it matter that it is not useful? :)
00:12:15 <mornfall> sjanssen: Well, it's template C++, so not type-restricted, and unbounded.
00:12:27 <mornfall> sjanssen: So it's reader/writer behaviour.
00:13:18 <sjanssen> mornfall: but there is a difference in how C++ instantiates that polymorphism
00:15:02 <mornfall> sjanssen: Yes, that's likely.
00:15:05 <mornfall> sjanssen: http://rafb.net/p/DaXUDA39.html
00:15:11 <lambdabot> Title: Nopaste - No description
00:15:39 <FunctorSalad> rwbarton: not useful for ct or not useful for understanding arrows?
00:16:12 <FunctorSalad> if it doesn't map neatly to ct there must be some slightly different concept that does
00:16:37 <mornfall> sjanssen: (You instantiate WM with NoopMutex for the one-writer case. For low contention on writers, it seems to perform quite well even with the mutex (as opposed to using multiple queues instead).
00:16:42 <mornfall> )
00:17:19 <mornfall> I'm not sure how to translate that code to Haskell though.
00:19:55 <rwbarton> FunctorSalad: Sure, you can translate all the structure of arrows to category theory.  The resulting notion even has a name, "Freyd category".
00:20:14 <FunctorSalad> rwbarton: thanks
00:20:23 <FunctorSalad> something I can look up :)
00:20:28 <rwbarton> FunctorSalad: But it's not like the case of monads, which have a one-sentence definition and pop up in a bunch of places in mathematics.
00:29:34 <adekoba> is there a preferred way of dealing with state in Data.Binary? Specifically, I'm trying to read a binary format, and some parts of the reading depend on others.
00:32:23 <haskellian> http://hpaste.org/10178 , why isnt this growing and blowing the stack? seems to work for large inputs. and is there a way to make delete faster? it is O(n^2) right?
00:32:25 <rwbarton> adekoba: Get is a monad, so you can write stuff like  do { n <- get ; xs <- replicateM n get }
00:33:37 <adekoba> rwbarton: yes, but when 'get'ing different parts of the file, I can't pass any arguments. For example, if in the header, there was a flag that specified compression, how would I go about letting the other reading functions know about this?
00:34:09 <Axman6> haskellian: delete (x:xs) []     = (x:xs) is cleaner if you use delete xs []     = xs imo
00:34:32 <rwbarton> adekoba: I see.  I think you can't just make your pieces instances of Get then, you have to write getFoo functions that take extra arguments (the state).
00:34:39 <dibblego> Axman6, it's inequivalent
00:35:02 <adekoba> rwbarton: I see. Thanks.
00:35:03 <dibblego> delete xs@(_:_) [] = xs -- however
00:36:23 <Axman6> how is it not equivalent? it's saying once you get to the end of the secnd list, return the first, doesn't matter if it's empty or not
00:36:52 <Axman6> second*
00:37:01 <dibblego> Axman6, because it overlaps patterns
00:38:03 <Axman6> where?
00:42:36 <haskellian> but can I speed it up?
00:45:13 <Axman6> haskellian: might be able to use elem, to see if each element is an element of the delete list. but yu may not get the behaviour you want
00:45:31 <Axman6> since rmv removes the first occurance on the element in the list, not all
00:47:41 <Axman6> haskellian: what is the actual behaviour you wany btw?
00:48:55 <Axman6> want* urgh, too tired to type
00:52:01 <haskellian> http://hpaste.org/10179 , i have 2 versions, one that does this: remove [1,2,3,1] 1 -> [1,2,3] and another that does [1,2,3,1] 1 -> [2,3]
00:53:00 <Axman6> it returns [1,2,3]? not [2,3,1]?
00:53:33 <haskellian> well 2,3,1 yes
00:53:39 <haskellian> doesnt really matter
00:53:39 <Axman6> ok, good
00:53:52 <Axman6> does a little, quite diffeent behaviour
00:54:13 <dibblego> @src nub
00:54:13 <lambdabot> nub = nubBy (==)
00:54:16 <dibblego> @src nubBy
00:54:16 <haskellian> i mean 1,2,3 or 2,3,1 doesnt matter, either is fine, if you can spped it up by returning 1,2,3 then thatwins
00:54:17 <lambdabot> nubBy eq []             =  []
00:54:17 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
00:54:39 <Axman6> delete all will reverse the list btw
00:55:50 <haskellian> but the import tant one is remove [1,2,3,1] should return [2,3,1] or [1,2,3] but not [2,3]
00:56:01 <haskellian> remove list elem
00:56:06 <Axman6> > numBy (<) [3,2,4,6,1,]
00:56:07 <lambdabot>   mueval: Prelude.read: no parse
00:56:10 <Axman6> > nubBy (<) [3,2,4,6,1,]
00:56:12 <lambdabot>   mueval: Prelude.read: no parse
00:56:58 <Axman6> > nubBy (<) [3,2,4,6,1]
00:56:59 <lambdabot>   [3,2,1]
00:57:18 <Axman6> > nubBy (<) [1..10]
00:57:19 <lambdabot>   [1]
00:57:24 <haskellian> well that isnt really what i want
00:57:25 <Axman6> > nubBy (>) [1..10]
00:57:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:58:07 <Axman6> yeah it's not
00:58:38 <haskellian> ty anyway, im going to bed after wathcin g some dexter
01:06:58 <Axman6> dibblego: what's the point of nubBy?
01:07:33 <Axman6> i've seen a fast prime list func that used it, and it was a little confusing
01:09:32 <Axman6> > nubBy (<) ([1..10 ++ (reverse [1..10))
01:09:33 <lambdabot>   mueval: Prelude.read: no parse
01:09:38 <Axman6> > nubBy (<) ([1..10] ++ (reverse [1..10))
01:09:39 <lambdabot>   mueval: Prelude.read: no parse
01:09:45 <Axman6> > nubBy (<) ([1..10] ++ (reverse [1..10]))
01:09:47 <lambdabot>   [1,1]
01:10:17 <Axman6> > nubBy (>) ([1..10] ++ (reverse [1..10]))
01:10:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,10]
01:10:40 <dancor> Axman6: you would rather do   nub . map somethingThatCollapses  ?
01:10:49 <dancor> re if nubBy has a point
01:11:03 <Axman6> eh?
01:11:31 <Axman6> i just find it a little confusing, not sure what it's for
01:12:00 <dancor> i guess i'm saying that i think it's for that, but sometimes more convenient than writing a "collapsing" function?
01:12:52 <dancor> > nub . map toLower $ "adcCab"
01:12:53 <lambdabot>   "adcb"
01:13:13 <dancor> > nubBy (compare `on` toLower) "adcCab"
01:13:14 <lambdabot>   Couldn't match expected type `Bool'
01:13:56 <ziman> > nubBy ((==) `on` toLower) "adcCab"
01:13:58 <lambdabot>   "adcb"
01:14:48 <dancor> nub is cooler here, but you could imagine cases where you already have a collapsed-comparison but don't want to write a collapsing function
01:14:58 <dancor> that's my theory
01:15:41 <Axman6> nubBy (/=) [1..10]
01:15:46 <Axman6> > nubBy (/=) [1..10]
01:15:47 <lambdabot>   [1]
01:15:58 <Axman6> > nubBy (==) [1..10]
01:16:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:37:28 <dancor> Saizan_: on my one-file project, 'hbuild src/Main.hs' just says: search path, target modules, then build-depends is blank.  re-running it: hbuild: _hbuild/cache: openFile: resource busy (file is locked)
01:39:05 <dancor> Saizan_: so it doesn't find that 'base, containers' is needed for build-depends
01:50:12 <Myoma> > 999999999999**99999999999999 :: CReal
01:50:27 <lambdabot>   thread killed
01:50:32 <Myoma> > 999999999999**99999999999999 :: Int
01:50:34 <lambdabot>       No instance for (Floating Int)
01:50:34 <lambdabot>        arising from a use of `**' at <in...
01:52:25 <dancor> > 999999999999 ^ 99999999999999
01:52:34 <Myoma> > 999 ^ 999
01:52:36 <lambdabot>   368063488259223267894700840060521865838338232037353204655959621437025609300...
01:52:40 <lambdabot>   thread killed
01:52:42 <Myoma> > 999 ^ 9999
01:52:44 <lambdabot>   452185645415902363718328227712673544054723792469156654365365177828057046716...
01:52:45 <Myoma> > 9999 ^ 9999
01:52:47 <lambdabot>   367897836216551579269262598478356580455025438573477618640185661384561636087...
01:52:49 <Myoma> > 999999 ^ 999999
01:52:57 <lambdabot>   367879625111270205556003681274050933069823505448445562823388038163980214998...
01:53:10 <Myoma> do they all start with 367897
01:53:19 <tusho> > 9999999 ^ 9999999
01:53:31 <dancor> lamebdabot
01:53:34 <lambdabot>   thread killed
01:53:43 <tusho> dancor: *g*
01:54:32 <sei_> > product [1..200000]
01:54:45 <Myoma> > product [1..999^999*100000000000000000]
01:54:47 <lambdabot>   thread killed
01:55:00 <lambdabot>   thread killed
01:55:10 <Myoma> > (99999**9999)**(99999**9999)**(99999**9999)**(99999**9999)
01:55:17 <lambdabot>   Infinity
01:55:21 <Myoma> wtf
01:55:23 <sei_> jejeje
01:55:24 <ziman> wow :)
01:55:27 <Myoma> > (99999**9999)**(99999**9999)**(99999**9999)**(99999**9999)+1
01:55:30 <lambdabot>   Infinity
01:56:10 <Myoma> > [99999999999999999999999999999999999**99999999999999999999999999999999999]
01:56:13 <lambdabot>   [Infinity]
01:56:20 <yitz> > let f n = 10^n - (10^n-1) * 10^(n-1) in map f [1..]
01:56:22 <lambdabot>   [1,-890,-98900,-9989000,-999890000,-99998900000,-9999989000000,-99999989000...
01:56:51 <ziman> > length.show $ 999999 ^ 999999
01:57:07 <lambdabot>   thread killed
01:57:19 <[Head|Rest]> > map(product,[1..100,100..1000,1000..10000])
01:57:21 <lambdabot>  Terminated
01:57:39 <yitz> > let f n = 10^n - (10^n-1) * (10^(n-1)) in map f [1..]
01:57:41 <lambdabot>   [1,-890,-98900,-9989000,-999890000,-99998900000,-9999989000000,-99999989000...
01:58:13 <Myoma> > nine billion
01:58:15 <lambdabot>   9000000000
01:58:29 <[Head|Rest]> > one postman
01:58:31 <lambdabot>   mueval: Prelude.read: no parse
01:59:55 <[Head|Rest]> > one + nine
01:59:57 <lambdabot>   mueval: Prelude.read: no parse
02:00:03 <dan_> head rest
02:00:09 <dan_> in haskell it's head tail
02:00:13 <dan_> suz
02:00:33 <[Head|Rest]> O.o
02:07:33 <Saizan_> dancor: sorry, the syntax is like hbuild -i src Main
02:09:23 <dancor> Saizan_: ah, ok.  works great
02:10:26 <Saizan_> dancor: cool :)
02:11:17 <ian_> read "123" :: Integer is slow, what's faster?
02:16:34 <Myoma> :t unfoldr
02:16:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:17:19 <Myoma> > foldr (\d x -> x * 10 + (ord x - ord '0')) 0 $ "123"
02:17:21 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
02:17:27 <Myoma> > foldr (\d x -> x * 10 + (ord d - ord '0')) 0 $ "123"
02:17:29 <lambdabot>   321
02:20:56 <LeoD> is there some kind of convention whether to put spaces before and after operators like ':'?
02:21:05 <Myoma> LeoD: no
02:21:36 <Beelsebob> LeoD: it tends to vary from use to use
02:21:46 <LeoD> i see
02:22:06 <[Head|Rest]> > reverse "123"
02:22:07 <lambdabot>   "321"
02:22:14 <Beelsebob> like (x:xs) is usually written closed up, while (something complex) : (something complex) tends to get a space added
02:22:15 <[Head|Rest]> i won ^.^
02:22:27 <Myoma> [Head|Rest]: You got it backwards!
02:22:32 <LeoD> Beelsebob: ah ok, thanks
02:29:01 <Myoma> > foldl (\d x -> x * 10 + (ord d - ord '0')) 0 $ "123"
02:29:02 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
02:29:06 <Myoma> > foldl (\x d -> x * 10 + (ord d - ord '0')) 0 $ "123"
02:29:08 <lambdabot>   123
02:29:24 <paczesiowa> how do I import specific version of module (e.g. parsec-2*)?
02:32:05 <ivanm> paczesiowa: define it in the .cabal file?
02:32:41 <paczesiowa> I just want to parse some parens:)
02:33:17 <paczesiowa> :t (do char '('; char '(') <|> char ')'
02:33:18 <lambdabot>     Couldn't match expected type `f t' against inferred type `Doc'
02:33:18 <lambdabot>     In the expression: char '('
02:33:18 <lambdabot>     In a stmt of a 'do' expression: char '('
02:33:19 <FunctorSalad> while we're talking about conventions: foo1 (2huge_expr... where of 1 and 2 do you put newlines?
02:33:45 <FunctorSalad> also with [ instead of (
02:33:58 <paczesiowa> :t (do Text.ParserCombinators.Parsec.char '('; Text.ParserCombinators.Parsec.char '(') <|> Text.ParserCombinators.Parsec.char ')'
02:33:59 <lambdabot> forall st. (Alternative (Text.ParserCombinators.Parsec.Prim.GenParser Char st)) => Text.ParserCombinators.Parsec.Prim.GenParser Char st Char
02:34:14 <Myoma> 2
02:34:17 <paczesiowa> let x = (do Text.ParserCombinators.Parsec.char '('; Text.ParserCombinators.Parsec.char '(') <|> Text.ParserCombinators.Parsec.char ')' in undefined
02:34:46 <paczesiowa> > let x = (do Text.ParserCombinators.Parsec.char '('; Text.ParserCombinators.Parsec.char '(') <|> Text.ParserCombinators.Parsec.char ')' in undefined
02:34:47 <lambdabot>       No instance for (Alternative
02:34:48 <lambdabot>                         (Text.ParserCombin...
02:35:04 <paczesiowa> can someone explain that?
02:35:20 <Saizan_> paczesiowa: that's the dreaded monomorphism restriction
02:35:46 <paczesiowa> oh, wait wrong type of <|>
02:36:19 <paczesiowa> anyway, you're right Saizan_
02:36:22 <Saizan_> paczesiowa: i.e. that values with no formal parameters can't be typeclass polymorphic, you have to either add a type signature for x, or use {-# LANGUAGE NoMonomorphismRestriction #-}
02:36:58 <paczesiowa> Saizan_: but where is usual ghci suggestion to turn off MR?
02:36:58 <yitz> @let  {-# LANGUAGE NoMonomorphismRestriction #-}
02:37:01 <lambdabot>  Defined.
02:37:11 <yitz> hey - did that work??
02:37:42 <dibblego> Prelude> :set -fno-monomorphism-restriction
02:37:47 <Saizan_> yitz: not sure if it will work, but it's a comment so you can put it anywhere
02:37:50 <Myoma> > let in () -- yitz
02:37:52 <lambdabot>   ()
02:37:59 <yitz> let x = read in x "56" :: Int
02:38:13 <yitz> > let x = read in x "56" :: Int
02:38:13 <Saizan_> paczesiowa: mmh good point, you might file a request on the ghc trac
02:38:14 <lambdabot>   56
02:38:28 <yitz> > let x = read in x "56"
02:38:29 <lambdabot>   mueval: Prelude.read: no parse
02:38:29 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
02:38:36 <Myoma> @let {-
02:38:36 <lambdabot>   Unterminated nested comment
02:38:44 <Myoma> @let {-  -\}
02:38:44 <lambdabot>   Unterminated nested comment
02:38:44 <FunctorSalad> legend has that nobody ever really understood the dreaded monomorphism restriction
02:39:05 <paczesiowa> I hate it
02:39:36 <yitz> FunctorSalad: it's not that hard to understand. The hard part is why it's on by default at the ghci prompt. (and in mueval)
02:39:38 <Saizan_> really? i think it's not so complicated
02:39:57 <Saizan_> yitz: it's on by default everywhere
02:40:49 <yitz> Saizan_: yes. there's at least some logic to that in source code. There's no reason at all to have it on be default at an interactive prompt.
02:42:10 <FunctorSalad> I guess I stopped trying to understand it after getting confused by the unusual use of the word 'monomorphism'
02:42:45 <paczesiowa> yeah, sounds boring. how about comonomorphism?
02:46:26 <FunctorSalad> yitz: what's the logic of it in source?
02:49:15 <Saizan_> FunctorSalad: it's argued that one expects bindings with no formal parameters (called CAF) are shared
02:49:16 <yitz> FunctorSalad: The two reasons given are: 1. Catch subtle bugs where you really meant something to be a value, but a function type was accepted by the type checker because of polymorphism. 2. Allow for certain compiler optimizations. Both claims are controversial, and certainly not applicable at an interactive prompt.
02:50:08 <Saizan_> FunctorSalad: but if you have a typeclass context it really gets implemented as a function of a method disctionary, so it's no more shared
02:50:37 <Saizan_> FunctorSalad: so they require you to declare that you want that much polymorphism
02:54:19 <FunctorSalad> Saizan_: wait, I thought all choice of method was resolved at compile time, right?
02:54:45 <FunctorSalad> (how would polymorphism be a performance problem then)
02:55:17 <Saizan_> FunctorSalad: not all the dictionaries are removed at compile time though
02:55:18 <FunctorSalad> obviously I know nothing about the ghc internals
02:55:54 <FunctorSalad> Saizan_: so you can add more instances in another library without recompiling the first?
02:56:40 <Saizan_> FunctorSalad: yeah
02:57:07 <Saizan_> that's one of the mainr easons
02:58:15 <FunctorSalad> speaking of subtle typing bugs, missing a comma in a list of long-ish expressions can cause a very serious-sounding error too =)
02:58:21 <Saizan_> ghc has things like SPECIALIZE pragmas and it tries to inline method selection though, since it can be expensive to do that a runtime
02:58:48 <FunctorSalad> (or having an extra trailing `op` in something like a `op` b `op` c `op`)
03:03:51 <yitz> FunctorSalad: unfortunately, MR doesn't help with those. So let's get rid of MR! ;)
03:04:34 <FunctorSalad> hehe
03:05:27 <ivanm> should continual array updates be really slow? :s
03:05:55 <FunctorSalad> isn't that what the mutable array things are for?
03:06:01 <Saizan_> ivanm: array updates on an immutable array are O(n), so better to do them in batch
03:06:06 <ivanm> :(
03:06:12 <ivanm> I'm doing continual updates
03:06:16 <ivanm> no wonder my code is slow!
03:07:32 <ivanm> Saizan_: so if I don't want to use IO, should I use DiffArrays then?
03:07:48 * ivanm presumes DiffArrays are done using unsafeIO :s
03:09:16 <Saizan_> ivanm: DiffArrays are not so well optimized, but yes, or you could use ST
03:09:24 <Axman6> @src until
03:09:25 <lambdabot> until p f x | p x       = x
03:09:25 <lambdabot>             | otherwise = until p f (f x)
03:09:37 <Saizan_> ?wiki Array
03:09:38 <lambdabot> http://www.haskell.org/haskellwiki/Array
03:09:56 <ivanm> Saizan_: ST would require me to change all my code :s
03:10:29 <ivanm> but if I'm continually updating one element at a time, DiffArray > Array?
03:10:31 <Saizan_> http://www.haskell.org/haskellwiki/Arrays#DiffArray_.28module_Data.Array.Diff.29
03:10:34 <lambdabot> Title: Arrays - HaskellWiki, http://tinyurl.com/5emwps
03:11:19 <ivanm> *nod*
03:11:27 <ivanm> doesn't say anything there about not being optimized...
03:11:36 <Saizan_> ivanm: in theory, other options are Map, IntMap
03:11:50 <ivanm> nah, I want the whole 2D-structure
03:12:19 <Saizan_> ivanm: with DiffArrays i often found that Array was better anyhow, but i've also read about reports of the contrary, it really depends on the usage pattern
03:12:38 <ivanm> *nod*
03:12:43 <Axman6> @src find
03:12:44 <lambdabot> find p          = listToMaybe . filter p
03:12:44 <Saizan_> ivanm: Map (Int,Int) a is 2D :)
03:12:50 <ivanm> heh, true
03:13:35 <ivanm> if the elements of my arrays are just doubles, would it make sense to use a UArray version?
03:14:11 <ivanm> (actually, the contents would be all either -1 or 1, but leaving it as double avoids continual conversions)
03:14:18 <Saizan_> ivanm: definitely, unless you're relying on laziness
03:14:19 <Axman6> heh, it's such a relief to finally write something in haskell that doesn't use extraordinary amounts of RAM
03:14:43 <ivanm> Saizan_: nah, I'm forcing the array at each time anyway
03:21:24 <FunctorSalad> Axman6: is haskell that bad with ram normally?
03:21:39 <Axman6> FunctorSalad: depends on what you're writing
03:21:45 <Axman6> usually it's pretty good
03:21:52 <FunctorSalad> (haven't tried something computation-intensive yet)
03:23:18 <Axman6> check out project euler then ;)
03:23:47 <Axman6> if you're new, you'll think of all sorts of computationally intensive ways to do things. i know i do, but i'm learning
03:29:05 <chrisdone> any haskell videos I can watch on my other screen while coding today?
03:29:28 <Axman6> seen the nested data parallel haskell ones?
03:29:44 <Axman6> haskell.org has a page of video presentations
03:30:10 <moshisushi> how do i declare a type that is a list of a certain set of Chars?
03:30:52 <Axman6> have a type that's those certain chars, and then a type which is [YourType]
03:31:18 <moshisushi> Axman6: that's what i figured, i just don't know how to declare that first type
03:31:21 <moshisushi> the caracter set
03:31:23 <Axman6> data myChars = 'a'|'b'|'c'|...
03:31:35 <moshisushi> ah
03:31:37 <Saizan_> Axman6: if that worked :)
03:31:46 <Axman6> Saizan_: i thought it might not...
03:32:21 <Saizan_> at best you can do data MyChars = A | B | C | ..., and write a conversion function between that and Char, deriving Enum would help too
03:32:30 <mgsloan> well, you can newtype Char
03:32:45 <mgsloan> hide the constructor, and ensure that only characters of that set are created
03:34:49 <FunctorSalad> what are the exponents in the ghc doc syntax?
03:35:04 <FunctorSalad> priority I'd guess
03:36:06 <Axman6> Cale: you around?
03:39:07 <alexey_r> Hi!
03:39:28 <Axman6> o/
03:44:09 <ivanm> Saizan_: heh, turns out you were right... 9-10 seconds for [U]Array, 18 for DiffUArray :s
03:44:36 * ivanm wonders why the times for UArray and standard Array are the same :s
03:45:25 <ivanm> maybe because I'm forcing the computation of the array?
03:50:46 <Myoma> hey alexey_r
03:53:28 <alexey_r> The new Cabal and Cabal-install versions actually work on my machine!
03:53:46 <alexey_r> I've always got weird mistakes before.
03:59:34 <dibblego> is GHC smart enough to know that some functions are identity when used with map?
03:59:53 <dibblego> e.g. let x = 0 in map (+x)
04:00:53 <opqdonut> 'fraid not
04:01:46 <Olathe> That's an identity even when not used with map.
04:02:11 <dibblego> yes I mean that since map obeys the identity law, then the map is optimised
04:02:18 <ivanm> SPJ only writes the compiler, he doesn't embed part of himself in it! ;-)
04:02:19 <opqdonut> you could of course define a function "plus 0 = id; plus x = (+x)"
04:02:39 <Myoma> and expect the complier to go   if f == id then id else map f  ?
04:03:08 <Myoma> that seems very odd
04:03:14 <Myoma> I wonder if it is possible
04:04:52 <alexey_r> {- RULE "map/id" map id list = list -} ? If plus 0 gets inlined this rule should fire.
04:05:00 <alexey_r> I think.
04:05:27 <Myoma> I was supposing one writes:  foo ... x ... = ... map (plus x) ...
04:05:36 <Myoma> rather than literally, map (plus 0)
04:05:51 <alexey_r> {- RULE "map/id" forall list . map id list = list -}, that is.
04:08:11 <alexey_r> "plus x" compiles into "case x of {0 -> id; y -> (+ y)}", right?
04:08:37 <Myoma> ok
04:08:55 <Myoma> but if x is not known at compile time?
04:11:15 <Axman6> rawr, i can't get a good answer for http://projecteuler.net/index.php?section=problems&id=197 -_-
04:11:24 <lambdabot> Title: Problem 197 - Project Euler
04:11:32 <Axman6> the answer i get is wrong, i think i'm losing quite a lot of precision
04:12:10 <alexey_r> So after inlining "plus x" we get "foo ... x ... = ... map (plus x) list ..." => "foo ... x ... = ... map (case x of {0 -> id; y -> (+ y)}) list ...".
04:13:09 <opqdonut> and then the map might get floated inside the case
04:13:11 <opqdonut> i don't know for sure
04:13:54 <ivanm> I've imported Data.Map as qualified... but it doesn't like M.! as a function :s
04:14:16 <ivanm> it thinks the '!' is the array function :s
04:14:18 <alexey_r> If x is only mentioned in one place, this is the same as "foo ... x ... = case x of {0 -> ... map id list ...; y -> ... map (+ y) list ...}" and the rule fires.
04:14:24 <Axman6> m.(!) maybe?
04:14:26 <Axman6> M*
04:14:42 <yitz> > 2 ** 30.403243784
04:14:44 <lambdabot>   1.420000000279318e9
04:14:55 <ivanm> Axman6: now it thinks M is a data constructor :s
04:14:58 <opqdonut> M.! if used as infix, M.(!) if prefix
04:15:01 <alexey_r> Of course I don't know if GHC actually does that second to last step.
04:15:08 <ivanm> opqdonut: nope, doesn't like it :s
04:15:18 <ivanm> because I've got Data.Array imported as well :s
04:15:25 <Axman6> yitz: i've got func x = (fromIntegral $ floor $ 2**(30.403243784-x**2))/(10.0**9) for my function
04:15:26 <yitz> > 1.42 * 10^9
04:15:28 <lambdabot>   1.42e9
04:15:36 <ivanm> No instance for (IArray Map Spin) arising from a use of `!'
04:15:39 <yitz> > 142 * 10^7
04:15:40 <lambdabot>   1420000000
04:15:47 <yitz> > 2^31
04:15:48 <lambdabot>   2147483648
04:16:07 <Myoma> :t (1.42 * 10^9, 142 * 10^7)
04:16:08 <lambdabot> forall t t1. (Num t1, Fractional t) => (t, t1)
04:16:24 <ivanm> OK, if I no longer import Array, M.! works
04:16:27 <alexey_r> And it's needed for the rule to have a chance.
04:17:10 <yitz> > 2^30
04:17:12 <lambdabot>   1073741824
04:17:19 <Myoma> > 99999^99999
04:17:21 <lambdabot>   367881280579378064819168577503806084214763804352266842054869913618354605097...
04:19:05 <Axman6> how odd, take 10 $ drop (10^12 -1) $ iterate func (-1) gives the same answer as when no drop is used
04:19:50 <Axman6> doesn't look like iterate is doing what it's supposed to...
04:20:11 <dibblego> Axman6, that might make sense, depends on func
04:20:12 <alexey_r> Axman6: wat is func?
04:20:58 <Axman6> func x = (fromIntegral $ floor $ 2**(30.403243784-x**2))/(10.0**9) for my function
04:21:19 <Axman6> uh, should've deleted the end of that too, heh
04:22:11 <Axman6> oddly enough, when you use drop 10^11 it seems to work fine
04:22:17 <Axman6> but 10^12 breaks
04:22:28 <Axman6> ah, that's be the Int limit
04:22:35 <Axman6> well, above it
04:22:51 <Axman6> > 10^12 :: Int
04:22:53 <lambdabot>   1000000000000
04:22:59 <Axman6> hmm
04:23:07 <Axman6> :t drop
04:23:08 <lambdabot> forall a. Int -> [a] -> [a]
04:23:19 <Myoma> > 1000000000000 + 1
04:23:20 <lambdabot>   1000000000001
04:23:58 <yitz> Axman6: dropping 10^12 things from a list will take a long time
04:27:20 <Axman6> ah ha: 10^12 :: Int
04:27:20 <Axman6> -727379968
04:27:25 <Axman6> i was right
04:27:37 <Axman6> :t (!!)
04:27:37 <Heffalump> @type genericDrop
04:27:39 <lambdabot> forall a. [a] -> Int -> a
04:27:39 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
04:28:23 <dibblego> @check drop (10^12-1) == id
04:28:24 <lambdabot>       No instance for (Eq ([a] -> [a]))
04:28:24 <lambdabot>        arising from a use of `==' at ...
04:28:35 <dibblego> @check \x -> drop (10^12-1) x == x
04:28:36 <lambdabot>   "Falsifiable, after 0 tests:\n[()]\n"
04:28:47 <Myoma> @check \x -> drop (10^12-1) x == []
04:28:48 <lambdabot>   "OK, passed 500 tests."
04:28:57 <dibblego> yeah that
04:30:15 <Myoma> @heck \p q -> p*q /= 66
04:30:16 <lambdabot>   "Falsifiable, after 172 tests:\n22\n3\n"
04:31:30 <Myoma> @@ @run tail . unlines @check \x y -> x+y == 4
04:31:32 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
04:32:03 <yitz> @help @
04:32:04 <lambdabot>  @ [args].
04:32:04 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
04:32:04 <lambdabot>  The commands are right associative.
04:32:04 <lambdabot>  For example:    @ @pl @undo code
04:32:04 <lambdabot>  is the same as: @ (@pl (@undo code))
04:32:42 <ivanm> @help undo
04:32:43 <lambdabot> undo <expr>
04:32:43 <lambdabot> Translate do notation to Monad operators.
04:32:47 <ivanm> ahhh
04:32:53 <Myoma> @@ @run tail . lines $ @check \x y -> x+y == 4
04:32:54 <yitz> @help @@
04:32:55 <lambdabot>   ["1","2"]
04:32:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:32:57 <Myoma> @@ @run tail . lines $ @check \x y -> x+y == 4
04:33:00 <lambdabot>   ["0","1"]
04:34:18 <yitz> Myoma: what is @@
04:34:35 <Myoma> @@ foo bar baz
04:34:35 <lambdabot>  foo bar baz
04:34:49 <Myoma> @@ @run reverse @show @yow
04:34:50 <lambdabot>   "\n?RAW MANTEIV eht redisnocer dna YRC ot tnaw uoy sekam\nosla hcihw amard ...
04:35:05 <Myoma> @@ @run @run ()
04:35:08 <lambdabot>   ()
04:35:12 <Myoma> @@ @run @run say "1+1
04:35:13 <Myoma> @@ @run @run say "1+1"
04:35:14 <lambdabot>   mueval: Prelude.read: no parse
04:35:17 <lambdabot>   2
04:35:20 <yitz> @ foo bar baz
04:35:35 <Olathe> @@ explode
04:35:35 <lambdabot>  explode
04:35:46 <Saizan_> @show x
04:35:47 <lambdabot> "x"
04:35:57 <Myoma> @@ @show @yow
04:35:57 <lambdabot>  "Barbie says, Take quaaludes in gin and go to a disco right away!\nBut Ken says, WOO-WOO!!  No credit at \"Mr. Liquor\"!!\n"
04:35:58 <yitz> @seen mauke
04:35:58 <lambdabot> mauke is in #xmonad and #haskell. I don't know when mauke last spoke.
04:36:07 <yitz> @seen Cale
04:36:07 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 9h 2m 38s ago.
04:36:26 <yitz> preflex list
04:36:26 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
04:36:31 <Myoma> @@ @run say . unwords . reverse . words $ @show @seen mauke
04:36:33 <lambdabot>   spoke. last mauke when know don't I #haskell. and #xmonad in is mauke
04:36:33 <Olathe> @show 1
04:36:33 <lambdabot> "1"
04:36:41 <Olathe> @show 1 + 5
04:36:42 <lambdabot> "1 + 5"
04:36:42 <Myoma> @@ @run say . unwords . reverse . words $ @show @nixon
04:36:44 <lambdabot>   nuns. the laying were popes that right all It's popes? the to happened what...
04:37:23 <yitz> @@ foo @run "bar"
04:37:25 <lambdabot>  foo   "bar"
04:38:02 <pastorn> @src undefined
04:38:03 <lambdabot> undefined =  error "Prelude.undefined"
04:38:16 <Olathe> @say hello
04:38:17 <lambdabot> Maybe you meant: faq map slap src
04:38:28 <yitz> > say "hello"
04:38:30 <lambdabot>   hello
04:38:32 <ziman> @@ @run say . unwords . map (++"\n") . reverse . words $ @show @nixon
04:38:33 <lambdabot>   Socrates.
04:38:33 <lambdabot>   was
04:38:33 <lambdabot>   so
04:38:33 <lambdabot>   that,
04:38:33 <lambdabot>   know
04:38:35 <lambdabot> [6 @more lines]
04:39:02 <yitz> @@ @show @run say "hello"
04:39:03 <lambdabot>  "  hello\n"
04:39:05 <opqdonut> @nixon
04:39:05 <lambdabot> Don't try to take on a new personality; it doesn't work.
04:39:28 <yitz> @@ @show @@ foo
04:39:28 <lambdabot>  " foo"
04:39:41 <Olathe> @@ @run say . unwords . map (++"n't") . reverse . words $ @show @nixon
04:39:43 <lambdabot>   answer.n't then't notn't aren't Solutionsn't
04:39:46 <pastorn> @type (%)
04:39:48 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
04:39:50 <yitz> @@ @show @pl foo
04:39:50 <lambdabot>  "foo"
04:40:01 <pastorn> @hoogle (%)
04:40:01 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
04:40:46 <Myoma> @@ (@@ @run say $ unwords $ replicate 50 "@localtime pastorn ")
04:41:03 <lambdabot> Local time for pastorn is Sun Sep  7 13:40:59
04:41:07 <lambdabot> Plugin `compose' failed with: thread killed
04:41:08 <lambdabot> Local time for pastorn is Sun Sep  7 13:40:59
04:41:44 <pastorn> wat+
04:41:45 <pastorn> ?
04:42:04 <Olathe> @localtime Olathe
04:42:05 <lambdabot> Local time for Olathe is Sat Oct 26 01:24:00 1985
04:43:32 <Axman6> ok, thought up a much better way to do that project euler problem. avoiding the stupid use of iterate
04:43:48 <Axman6> wrote an iterator function that will iterate n times
04:45:03 <Axman6> and the whole thing's running in 1.36MB RAM
04:45:14 <Axman6> as opposed to over a gig in a few seconds...
04:45:34 <Feuerbach> I want to define class of constructors (* -> *) with restriction that it will give instance of Show when applied. Is it possible?
04:46:07 <Feuerbach> i.e. class (Show a b) => SuperShow a where ...
04:46:17 <Heffalump> when applied to something that supports Show, presumably?
04:46:42 <Feuerbach> Heffalump: yes
04:46:48 <Heffalump> class ShowC c where showC :: Show a => c a -> String
04:46:52 <yitz> preflex  list
04:46:52 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
04:46:57 <yitz> preflex      list
04:46:57 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
04:46:57 <Heffalump> (add extra methods for the other stuff Show does to suit)
04:48:53 <Heffalump> it's possible that something nicer could be done with associated datatypes, but I can't visualise it immediately
04:49:25 <Feuerbach> Heffalump: not exactly what I want. My class is for other things (not for showing), I just want to restrict what things can be made instance of that class
04:50:03 <Heffalump> there's no easy way to express the constraint (forall a . Show a => Show (c a)) in the type system.
04:50:07 <Heffalump> which is what you really want.
04:50:11 <Feuerbach> yeah
04:52:27 <Heffalump> another way of looking at it is that you need a function from Show a dictionaries to Show (c a) dictionaries.
04:52:45 <Heffalump> So you could reify the Show dictionaries in an existential datatype, then add such a function to your class.
04:53:06 <Heffalump> but it'd all add explicit overhead to doing anything.
04:53:21 <Saizan_> which is equivalent to defining ShowC and require that context, no?
04:53:24 <dancor> easiest way to do readFile but nonlazily?
04:53:31 <Feuerbach> I think I found solution. In my case I can embed that restriction into datatype
04:53:34 <Heffalump> Saizan_: yes, but less dependent on the internal structure of Show.
04:53:41 <Heffalump> Feuerbach: sounds better :-)
04:54:17 <Heffalump> you can also make instance (Show a, MyClass c) => Show (c a) with either of my suggestions, if you don't mind overlapping instances and all that they entail.
04:55:19 <Heffalump> hmm, no you can't, you'd get incoherent instances.
04:55:33 <Heffalump> or just general insanity, anyway.
04:56:32 <yitz> preflex zdec abcd
04:56:32 <preflex>  abcd
04:57:40 <Heffalump> dancor: do foo <- readFile bar ; (foo == foo) `seq` return foo
04:57:43 <yitz> preflex rot13 abcd
04:57:43 <preflex>  nopq
04:57:53 <Heffalump> a very quick and evil hack, that
04:58:05 <dancor> ah, i just had   foo `seq`   and it wasn't working
04:58:15 <Heffalump> that just forces the head
04:58:55 <yitz> Heffalump: any advantage over the traditional length foo?
04:59:08 <Heffalump> I didn't know length foo was traditional :-) No.
04:59:21 <Heffalump> length foo is probably better.
05:01:46 <yitz> > say "hello\ngoodbye"
05:01:48 <lambdabot>   hello
05:01:48 <lambdabot>  goodbye
05:02:01 <ziman> will length force the chars?
05:02:20 <Heffalump> no, but it doesn't need to
05:02:21 <dcoutts> ziman: no
05:02:22 <ziman> (or is it sufficient to firce the list spine?)
05:02:25 <ziman> *o
05:02:36 <Heffalump> that's sufficient
05:02:43 <dcoutts> :t flip (foldl' (flip const))
05:02:45 <lambdabot> forall b. [b] -> b -> b
05:02:52 <dcoutts> erm
05:02:55 <dcoutts> :t flip (foldl' (flip seq))
05:02:57 <lambdabot> forall b a. [b] -> a -> a
05:03:06 <Heffalump> eww :-)
05:03:24 <Heffalump> (I'm sure that'd work, but it's confusing. This is what DeepSeq/RNF is for!)
05:03:32 <dcoutts> right
05:04:07 <dcoutts> though that also deeply forces the list elements rather than whnf
05:04:40 <Heffalump> perhaps we need Data.Seq.Strategies
05:04:48 <yitz> @unpl flip (foldl' (flip seq))
05:04:48 <lambdabot> (\ b c -> foldl' (\ e f -> seq f e) c b)
05:05:43 <yitz> dcoutts: to whnf of the elements, as opposed to rnf.
05:05:55 <dcoutts> yitz: right
05:07:00 <yitz> preflex zdec helloz0dUz0aUgoodbye
05:07:00 <preflex>  hello
05:07:12 <yitz> preflex zdec helloz0aUgoodbye
05:07:12 <preflex>  hello
05:07:40 <moshisushi> why can't i use snd to get the second value from a 3-tuple?
05:07:58 <Heffalump> moshisushi: because the type system doesn't support that kind of thing
05:08:07 <yitz> moshisushi: 3-tuple is a different type. snd works on 2-tuples.
05:10:01 <dancor> Saizan_: do you think this import-guesser could be made to actually check like all installed packages (erroring on dupe functions i guess, or having package preferences): http://hpaste.org/10181
05:10:48 <dancor> i'm going to at least generate mods for some generally useful packages for personal use
05:11:04 <dancor> that and hbuild should save me some typing
05:12:00 <Saizan_> dancor: uhm, i'd use hoogle to lookup modules
05:12:08 <Saizan_> ?hoogle getContents
05:12:09 <lambdabot> Prelude getContents :: IO String
05:12:09 <lambdabot> Data.ByteString getContents :: IO ByteString
05:12:09 <lambdabot> System.IO getContents :: IO String
05:12:16 <dancor> ok
05:14:05 <Saizan_> dancor: but i'm not sure that parsing not in scope errors is the best way, even if the alternative is doing your own scope checking, which is a bit of work
05:14:10 <moshisushi> yitz: hmm, what's the best way to pick the n:th value from a k-tuple then?
05:14:15 <dancor> true
05:14:39 <_zenon_> @src mapM
05:14:39 <lambdabot> mapM f as = sequence (map f as)
05:14:43 <yitz> > let (_,x,_) = (3,6,9) in x
05:14:44 <lambdabot>   6
05:15:11 <yitz> > let snd3 (_,x,_) = x in snd3 (3,6,9)
05:15:13 <lambdabot>   6
05:15:54 <_zenon_> it would be infinitely nice with autogenerated methods for that... like sndN
05:16:49 <Jedai> moshisushi: There is no generic method, though you could write a typeclass and instances, it wouldn't work on "any" tuple, just on those you have instances for. Alternatively, you can use Template Haskell to autogenerate the right function
05:16:55 <yitz> moshisushi: you could define some fancy ways to do it more generally - but it's not worth the trouble, because if you need that, you probably should not be using tuples.
05:17:31 <Jedai> _zenon_: You can use TH for this (but yitz is right that Tuple probably aren't the right tool for you then)
05:27:03 <_zenon_> Any method for doing  (Writer (0,[])) >>= f (A1 0) >>= f (A2 2) >>= ... >>= f (An 1) like  somefun (Writer (0,[])) (\x -> cc' c) [A1 0,...,An 1] instead?
05:29:15 <Saizan_> _zenon_: see foldM
05:29:23 <_zenon_> Saizan_, okay
05:29:35 <_zenon_> @src foldM
05:29:36 <lambdabot> foldM _ a []     = return a
05:29:36 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
05:29:45 <_zenon_> mm
05:29:48 <_zenon_> looks interesting
05:30:30 <yitz> @index foldM
05:30:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:30:43 <Saizan_> _zenon_: it's like foldl but with monadic results
05:30:45 <Axman6> @src (^)
05:30:45 <lambdabot> x ^ 0            =  1
05:30:45 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:30:45 <lambdabot>   where f _ 0 y = y
05:30:45 <lambdabot>         f x n y = g x n
05:30:45 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:30:47 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:30:49 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:31:06 <_zenon_> Saizan_, Yeah, I saw that from the source
05:34:10 <Axman6> @src (**)
05:34:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:34:14 <Axman6> @src (^^)
05:34:15 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
05:35:40 <yitz> Axman6: solve 197 yet?
05:36:06 <Axman6> well, i have a program that'll do it (i hope) but no answer yet. i stopped it after an hour or so :\
05:36:13 <Axman6> working on 188
05:36:34 <Axman6> which is proving difficult (Integers are awesome, except when they get _really_ big
05:36:56 <yitz> Axman6: try computing some values of un by hand (for 197).
05:37:23 <trofi> :]
05:38:14 <Feuerbach> yitz: what are you talking about? project euler?
05:38:24 <yitz> Feuerbach: yes
05:38:35 <Axman6> 2^(30.403243784-x^2) by hand you say?
05:38:55 <trofi> with CReal :]
05:39:54 * trofi 've solved 197 on MPFR. didn't hear of Numbers that time
05:39:55 <yitz> Axman6: "by hand" means one at a time
05:41:31 <Axman6> hurrah. yeah it ends up repeating the numbers, which gives the answer pretty quickly
05:41:58 <trofi> yep
05:42:28 <Axman6> damn you project euler *shakes-fist*
05:42:38 <yitz> Axman6: and you thought your program was doing something interesting all that time
05:42:50 <Axman6> heh, yeah
05:43:08 <Axman6> i thought it may do something like that, but i didn't investigate it too deeply
05:43:20 <FliPPeh> Beginers question:
05:43:24 <FliPPeh> main :: IO ()
05:43:33 <FliPPeh> Means main only accept things that return an IO monad?
05:43:41 <Axman6> think i looked at the 100-200th numbers, needed more like 100
05:44:01 <FliPPeh> Currently I always do "main = putStr """ if I just want to test if something compiles
05:44:06 <Axman6> FliPPeh: no, it returns the IO monad
05:44:06 <FliPPeh> Isn't there something easier?
05:44:20 <dancor> FliPPeh: i usually use   main = print 4   heh
05:44:22 <Heffalump> if you just want to test compilation, don't bother linking
05:44:25 <Saizan_> FliPPeh: you can load a module in ghci without definig main
05:44:50 <Axman6> yitz: did you have a look at 188?
05:44:54 <FliPPeh> So I MUST use some kind of IO monad function in main?
05:45:07 <Axman6> FliPPeh: i believe so
05:45:08 <dancor> FliPPeh: yes.  return ()    might be the "simplest"
05:45:31 <Axman6> i usually print my results with it (main = print result
05:45:32 <yitz> Axman6: since you recommended it
05:45:48 <FliPPeh> Oh nice, I didn't think off return
05:45:59 <FliPPeh> I thought it meant something very different in haskell?
05:45:59 <dancor> i guess   putStr ""  amounts to the same
05:46:14 <trofi> :t putStr
05:46:16 <lambdabot> String -> IO ()
05:46:22 <FliPPeh> :t return
05:46:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:46:23 <Jedai> FliPPeh: return lift a value in a monad (here the IO monad)
05:46:29 <dancor> trofi: i mean in not doing anything
05:46:33 <Heffalump> it does mean something different to "early exit return" that it means in other languages
05:46:38 <FliPPeh> [14:46:18] <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:46:43 <FliPPeh> Now THAT looks complicated
05:47:07 <Heffalump> :t return :: a -> IO a
05:47:08 <lambdabot> forall a. a -> IO a
05:47:17 <dancor> FliPPeh: return "pulls something into" a monad; it wraps the thing in the monad wrapper
05:47:18 <Heffalump> there you go, all better :-)
05:47:29 <FliPPeh> Ah okay
05:47:47 <dancor> so () is nothing, so return () does nothing :)
05:47:58 <trofi> :]
05:48:02 <FliPPeh> Haskell's type system can save lives.. but it completly confuses me mostly :(
05:48:20 <trofi> it's temporary
05:48:22 <mapreduce> In he signature FliPPeh posted, can someone explain how a monad has a kind * -> * ?
05:48:22 <Axman6> FliPPeh: you'll get it (though monads are quite confusing to me as wel)
05:48:23 <dancor> yeah just put type signatures on your functions
05:48:24 <Axman6> l8
05:48:30 <dancor> or the errors get more cryptic
05:48:35 <yitz> > return 42 :: [Int]
05:48:37 <lambdabot>   [42]
05:48:42 <mapreduce> I'd have thought (->) would have that kind, I don't see what each * means for a monad.
05:48:43 <FliPPeh> I type my methods all the way ;D
05:48:48 <yitz> > return 42 :: Maybe Int
05:48:49 <FliPPeh> It's much easier for me that way
05:48:50 <lambdabot>   Just 42
05:48:51 <trofi> @instances Monad
05:48:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:49:00 <Heffalump> mapreduce: (->) has kind * -> * -> *
05:49:01 <Jedai> mapreduce: a Monad is a type constructor (it means it takes a type parameter and return a type)
05:49:13 <Heffalump> any concrete type (Int, Char, etc) has kind *
05:49:21 <Heffalump> concrete types = things that have values
05:49:21 <mapreduce> Ah, gotcha.
05:49:44 <Heffalump> actually, my use of "concrete type" is a bit confusing.
05:49:57 <ziman> > return 42 :: IO Int
05:49:59 <lambdabot>   mueval: Prelude.read: no parse
05:49:59 <lambdabot>  mueval: *** Exception: "<IO Int>"
05:50:21 <mapreduce> > return 42 :: Int
05:50:22 <lambdabot>   Couldn't match expected type `Int' against inferred type `m t'
05:50:24 <dancor> Heffalump: if there are only like four of them i guess easiest definition is the list of them?
05:50:24 <yitz> mapreduce: in Haskell a "type" can be like a type in other languages, or it can be function on types
05:50:42 <Heffalump> dancor: huh?
05:50:44 <dancor> nm
05:50:57 <mapreduce> yitz: Ok.
05:51:23 <trofi> > minBound :: Int
05:51:24 <lambdabot>   -9223372036854775808
05:51:28 <mapreduce> I think C# has something similar in that there's a type called List<>, and List<T> is an 'instantiation' of that.
05:51:30 <yitz> mapreduce: a "type of kind * -> *" is a function that maps a concrete type to another concrete type
05:51:40 <yitz> mapreduce: kind of like that, yeah
05:51:59 <Axman6> mapreduce: looks like java's generics
05:52:03 <yitz> mapreduce: in Python, types are themselves objects. so you can think of it that way too
05:52:17 <mapreduce> Axman6: C# has no raw types.
05:52:26 <Axman6> :\
05:52:39 <Axman6> what do you mean, no ints etc?
05:52:40 <ivanm> mapreduce: that's a bit of a raw deal... ;-)
05:52:42 <yitz> mapreduce: in C# everything is raw :)
05:52:51 <ivanm> Axman6: I think he means there are no primitives, everything is an object
05:52:53 <yitz> ivanm: :)
05:53:01 <mapreduce> Axman6: You can't use a generic type without a type parameter.
05:53:04 <FliPPeh> > maxBound :: Int
05:53:05 <lambdabot>   9223372036854775807
05:53:06 <ivanm> whereas in Java, Int, Double, etc. are primitive, everything else is an object
05:53:06 <Axman6> ok, well, what i said still stands
05:53:07 <FliPPeh> > maxBound :: Integer
05:53:08 <lambdabot>       No instance for (Bounded Integer)
05:53:08 <lambdabot>        arising from a use of `maxBoun...
05:53:12 <FliPPeh> :d
05:53:17 <trofi> > maxBoud :: Bool
05:53:19 <lambdabot>   mueval: Prelude.read: no parse
05:53:20 <trofi> > maxBound :: Bool
05:53:22 <lambdabot>   True
05:53:30 <Axman6> ivanm: int and double are, Integer and Double are objects ;)
05:53:46 <FliPPeh> I like how Integer is "infinite"
05:53:47 <ivanm> Axman6: true, but I was using Haskell types as analogies :p
05:54:16 <mapreduce> object/primitive is a silly distinction.
05:54:29 <Heffalump> mapreduce: not really, they have different semantics
05:54:37 <mapreduce> Heffalump: Only for mutable objects.
05:55:00 <Heffalump> well, yes, but...
05:55:19 <yitz> mapreduce: or for values that are computed lazily
05:55:34 <ivanm> FliPPeh: well, it uses gmp
05:55:47 <FliPPeh> gmp? =d
05:55:58 <mapreduce> yitz: In a language without explicit support for that you'd probably use a Promise<T> for that anyway.
05:56:21 <ivanm> FliPPeh: gmplib.org
05:56:22 <trofi> http://gmplib.org
05:56:25 <lambdabot> Title: The GNU MP Bignum Library
05:56:35 <ivanm> arbitrary precision integers
06:03:04 <Jedai> > maxBound :: INt
06:03:05 <lambdabot>   mueval: Prelude.read: no parse
06:03:06 <Jedai> > maxBound :: Int
06:03:08 <lambdabot>   9223372036854775807
06:03:40 <Jedai> Lambdabot is on a 64 bits computer now ? The Sparc server ?
06:07:07 <Axman6> yitz: any luck with 188 at all? i've got something that should eventually work... but with 3 |^|^ 5, it takes a very long time...
06:12:20 <Axman6> far out, those numbers get real big, real fast -_-
06:13:01 <yitz> Axman6: we'll have to find a trick. I have an idea, but I'll keep it to myself for now...
06:13:17 <Axman6> heh, fine then :P
06:30:53 <trofi> :t while
06:30:54 <lambdabot> Not in scope: `while'
06:31:00 <trofi> :t until
06:31:01 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
06:33:58 <Axman6> anyone know why iterator would use a lot of memory in this? http://hpaste.org/10183
06:34:12 <Axman6> seems like it should be tail recursive
06:34:12 <Axman6> \
06:34:39 <Deewiant> Axman6: probably building a bunch of (f (f (f ... (f ini))))
06:35:19 <Deewiant> f $! ini should fix that, I think
06:35:58 <bla123> class C a b where f :: a
06:36:09 <bla123> how can i tell ghc which instance to use for f?
06:38:50 <Axman6> Deewiant: i just used seq, seems to work fine
06:39:00 <Axman6> unless you have a better idea?
06:39:08 <Deewiant> they're equivalent
06:39:09 <Axman6> @src ($!)
06:39:09 <lambdabot> f $! x = x `seq` f x
06:39:14 <Axman6> heh, ok then
06:40:27 <Axman6> using 'iterator f ini n = res `seq` iterator f res (n-1) where res = f ini'
06:40:42 <Deewiant> seems to me that you've pretty much rewritten foldl' there
06:40:45 <Deewiant> ?src foldl'
06:40:45 <lambdabot> foldl' f a []     = a
06:40:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:40:58 <trofi> how eq [[prime^n `mod` k == 1]] is called? :]
06:41:08 <Axman6> how so? i'm not using lists...
06:41:40 <Deewiant> Axman6: well, your decreasing 'n' parameter is the same as iterating over [0..n]
06:41:57 <dancor> Saizan_: ok i'm pretty happy with it using hoogle now.  thanks for the help!  http://dzl.no-ip.org:81/gitweb/?p=himportant.git;a=blob;f=src/Main.hs
06:42:00 <lambdabot> http://tinyurl.com/5j3dmx
06:42:20 <lilac> bla123: you can't. that class is broken.
06:42:24 <Axman6> well when using foldr1, i was getting stack overflows. these numbers get very, very big
06:42:40 <Saizan_> dancor: nice :)
06:42:54 <Deewiant> Axman6: I think, types might not match but approximately: iterator f ini n = foldl' (\a _ -> f a) ini [0..n]
06:43:00 <Deewiant> foldr is of course different from foldl
06:43:03 <trofi> @hoogle foldr1'
06:43:04 <lambdabot> Data.ByteString foldr1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
06:43:04 <lambdabot> Data.ByteString.Char8 foldr1' :: (Char -> Char -> Char) -> ByteString -> Char
06:43:05 <Jedai> Axman6: foldr1 and foldl' aren't the same thing..
06:43:19 <lilac> bla123: you could split the class, as "class C' a where f :: a; class C' a => C a b where {- other bits of C -
06:43:23 <bla123> @lilac: thanks, now i know for sure :)
06:43:24 <lambdabot> Unknown command, try @list
06:43:24 <lilac> }"
06:43:28 <Jedai> Axman6: The haskell wiki has a page comparing foldr and foldl
06:43:39 <Jedai> @go foldr foldl'
06:43:42 <lambdabot> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
06:43:42 <lambdabot> Title: Fold (higher-order function) - Wikipedia, the free encyclopedia
06:43:45 <Deewiant> ?ty \f ini n -> foldl' (const . f) ini [0..n]
06:43:47 <lambdabot> forall b b1. (Enum b1, Num b1) => (b -> b) -> b -> b1 -> b
06:43:57 <Jedai> @go foldr foldl' HaskellWiki
06:44:01 <lambdabot> http://www.haskell.org/haskellwiki/Fold
06:44:01 <lambdabot> Title: Fold - HaskellWiki
06:44:06 <Axman6> well anyway, i don't think it makes a difference here
06:44:35 <Jedai> Axman6: It does, read http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
06:44:37 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
06:44:54 <bla123> @lilac: that doesn't seem to mean the same, because a type could only have one instance of C then
06:44:54 <lambdabot> Unknown command, try @list
06:45:12 <lilac> bla123: another option is to use functional dependencies. if b can be determined from a, you can write the class as "class C a b | a -> b where ..."
06:45:21 <yitz> Axman6: this is a math problem not a programming problem. after doing some math, try the steps one by one like in 197. :)
06:45:26 <lilac> bla123: but that has the same problem wrt a class having only one instance.
06:45:44 <yitz> Axman6: so no, foldr and foldl don't make a difference, don't use either :)
06:46:14 <yitz> Axman6: but good to learn about them though, for Haskell. ;)
06:46:22 <lilac> bla123: the fundamental problem is that you want "f :: C a b => a", and is guaranteed ambiguous (no way to determine b).
06:46:39 <bla123> @lilac: yes. i just wondered if it was possible for one type to have multiple instances for the same class, but didn't find a way to annotate the type for ghc
06:46:39 <lambdabot> Unknown command, try @list
06:46:41 <lilac> bla123: another way out is to use "f :: b -> a", and ignore the first argument
06:46:56 <Axman6> yitz: i would, if my tetrate function would actually terminate for anything that wasn't 2, 3
06:47:30 <yitz> Axman6: right, you have to do some math first
06:47:35 <bla123> @lilac: ok, that way i could help the compiler out with an annotation
06:47:35 <lambdabot> Unknown command, try @list
06:47:41 <Deewiant> > 4^4^4^4
06:47:43 <bla123> @lilac: thanks
06:47:43 <lambdabot> Unknown command, try @list
06:47:56 <lambdabot>   thread killed
06:49:10 <Axman6> heh, managed to give ghci a buss error
06:49:22 <Deewiant> > ((4^4)^4)^4
06:49:24 <lambdabot>   340282366920938463463374607431768211456
06:50:56 <Axman6> (^) really doesn't like to be cancalled with ^C
06:53:24 <Jedai> bla123: The standard technique when one want multiple instance for the same type is to use a newtype to differentiate between the instances behaviour. The newtype is only a hint to the compiler typechecker, it disappear after compilation, so it doesn't affect the performance at all
06:54:43 <yitz> Axman6: the gmp library in C doesn't hear the ^C.
06:54:59 <Axman6> :\
06:56:03 <bla123> @Jedai: do you mean, that the compiler optimizes away the construction/deconstruction of the "newtype type"?
06:56:03 <lambdabot> Unknown command, try @list
06:56:27 <Heffalump> bla123: yes
06:56:30 <Axman6> bla123: stop using the @'s, you're hurting lambdabot ;)
06:56:37 <Heffalump> I think that's guaranteed by the standard
06:56:50 <bla123> sry, i only noticed it a few seconds ago :|
06:57:17 <bla123> @list
06:57:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:57:54 <trofi> otherwise `data' would be pure superset of `newtype'
06:58:00 <bla123> hm, no lilac or Jedai command there ;)
06:58:15 <Heffalump> trofi: no, newtype has different semantics to data too.
06:58:29 <Heffalump> even data with a single strict argument to a single constructor
06:58:45 <bla123> what's the difference between them?
06:58:46 <trofi> ah yes. "strictness"
06:59:13 <Heffalump> bla123: newtype Foo = Foo Int is almost like Data Foo = Foo !Int
06:59:59 <bla123> is newtype more strict, because the compiler removes one level of construction?
07:00:00 <Heffalump> except that if you have an undefined value, you can match against Foo _ with the newtype version but not with the data version.
07:00:09 <lilac> bla123: the difference is that 'case undefined of X _ -> True' returns True with 'newtype X = X Int' but diverges with 'data X = X Int'
07:00:27 <Heffalump> data X = X !Int
07:00:36 <lilac> ^^ that too
07:01:02 <Heffalump> that's the important difference, because in the non strict case, X undefined is not the same as undefined
07:01:08 <Heffalump> whereas in the strict case it is
07:01:18 <bla123> that's interesting, i thought i read somewhere that the difference was only in performance
07:01:26 <Heffalump> the difference between what and what?
07:01:44 <Heffalump> data X = X !Int isn't guaranteed to be represented exactly like an Int, either.
07:01:44 <bla123> between newtype and data without "!"
07:01:58 <Heffalump> no, they have crucial strictness differences
07:12:01 <mc__> I Dont understandt that type error: http://haskell.pastebin.com/m34dfb442
07:12:12 <dcoutts> for newtype N x = N x; data D x = D !x; f (N x) = (); g (D x) = ();
07:12:19 <dcoutts> f _|_ = ()   but   g _|_ = _|_
07:12:33 <Deewiant> ?pl safe_analyse a b c = analyse (sort3 a b c)
07:12:34 <lambdabot> safe_analyse = ((analyse .) .) . sort3
07:12:36 <Deewiant> mc__: ^
07:13:10 <mc__> Deewiant: but why? that looks, really, really ugly
07:13:10 <Deewiant> ?pl safe_analyse a b c = (analyse (sort3 a)) b c
07:13:10 <lambdabot> safe_analyse = analyse . sort3
07:13:14 <Deewiant> mc__: because of that
07:13:19 <byorgey> mc__: analyse . sort3  means that only one parameter will be passed to sort3
07:13:24 <byorgey> but you want 3
07:13:26 <Deewiant> it's just how . works
07:13:38 <Deewiant> can't really do much about it except define a function that handles 3 parameters
07:14:01 <Nafai> byorgey!
07:14:05 <Nafai> How's school?
07:14:18 <byorgey> Nafai!
07:14:19 <Deewiant> mc__: or, as most would do, just not write it points-free
07:14:21 <byorgey> it's great!
07:14:43 <mc__> Deewiant: I just wanted to try that once :)
07:15:08 <Deewiant> ?pl sort3 a b c = ((max3 a b c), (middle a b c), (min3 a b c))
07:15:08 <lambdabot> sort3 = ap (ap . (ap .) . ap (ap . (liftM2 (,,) .) . max3) middle) min3
07:15:09 <byorgey> I get paid to read research papers! =D
07:15:15 <Deewiant> mc__: go ahead and use that, then, too ;-)
07:15:41 <mc__> lol
07:16:11 <byorgey> Nafai: how are things with you?
07:16:37 <Nafai> byorgey: Not super bad, I guess.  Just looking for a job and trying to figure out some health issues.
07:17:54 <mapreduce> Is Network only available since ghc 6.8 or thereabouts?
07:18:26 <mapreduce> My apt sources have 6.6 - is that generally going to be incompatible with online tutorials?
07:18:49 <byorgey> mapreduce: 6.6 should be ok, but you might notice a few differences.
07:19:12 <byorgey> Network is probably there, it just might be in a different package
07:19:21 <byorgey> try libghc6-network or something like that
07:20:57 <mapreduce> libghc6-network-dev
07:22:18 <_zenon_> Nafai, what's up with the health?
07:22:24 <byorgey> mapreduce: yup, that's it
07:22:49 <Nafai> _zenon_: I was recently diagnosed with kidney disease.  Going to be going to a transplant doctor soon
07:23:23 <_zenon_> Nafai, o, that's sounds serious.
07:23:48 <Nafai> A bit :/
07:24:21 <byorgey> Nafai: yikes!  I hope that works out.
07:24:22 <Twey> Sounds nasty, Nafai :-\  Hope it works out OK
07:24:32 <Nafai> Thanks for the support.
07:25:52 <mapreduce> byorgey: Great, that worked fine.
07:26:52 <byorgey> mapreduce: excellent.  yeah, 6.6 should be fine for following along with tutorials.  at some point in the future you might want to upgrade to 6.8.3 but I wouldn't worry about it for now.
07:42:32 <ben____> What is the minimal "import" line to make openFile "foo" ReadMode work as expected?
07:42:57 <dmwit_> ?index ReadMode
07:42:58 <lambdabot> System.IO
07:43:05 <dmwit_> ?index openFile
07:43:05 <lambdabot> System.IO
07:43:07 <chrisdone> reddit just died?
07:43:15 <ben____> import System.IO (openFile, ReadMode) does not seem to work
07:43:20 <dmwit_> chrisdone: It's been wavering in and out for me all morning.
07:43:33 <dmwit_> :t ReadMode
07:43:34 <chrisdone> dmwit_: must be updates or reaching critical mass
07:43:35 <lambdabot> Not in scope: data constructor `ReadMode'
07:43:45 <ben____> The type seems to be IOMode
07:43:57 <dmwit_> import System.IO (openFile, IOMode(ReadMode))
07:44:03 <ben____> Thanks
07:44:12 <dmwit_> But the *minimal* line is "import System.IO". =)
07:44:47 <ben____> I meant importing minimal amounts of names :)
07:57:21 <mapreduce> On a remote box to which I have only user access, I downloaded the binary distribution of ghc.  I ran ./configure --prefix=/home/ricky/ghc/, and the configure script told me my C compiler (gcc) cannot create executables.
07:57:56 <mapreduce> Does ghc rely on gcc for stuff while you are developing in Haskell?  I assumed that if I already had a binary I could just use it.
07:58:09 <dmwit> There's -fvia-c
07:58:58 <dcoutts> mapreduce: it needs gcc to link programs
07:59:15 <dcoutts> and it uses gcc as an assembler
07:59:23 <dcoutts> even if it's not using -via-C
07:59:23 <mapreduce> gcc 4.1.2 is installed.
07:59:27 <Jedai> mapreduce: Wait a second, why do you need to do a configure with a binary distribution ?
07:59:42 <mapreduce> Jedai: That's what the INSTALL thing says to do.
07:59:43 <dcoutts> Jedai: to say where to install to
07:59:51 <dcoutts> it's the right thing to do
07:59:56 <mapreduce> I cannot find the ghci executable, for example, within that distribution.
08:00:26 <dcoutts> mapreduce: ghci is actually a script that calls ghc --interactive
08:00:38 <dcoutts> the script is generated on install
08:00:53 <dcoutts> because it needs to know where the stuff is installed
08:00:56 <Jedai> Well I always either used the OS package or compiled GHC myself so I didn't know but that seems a little bit strange... ^^
08:01:08 <mapreduce> config.log says: gcc conftest.c >&5
08:01:24 <mapreduce> next line: /lib/libc.so.6: file not recognized: File format not recognized
08:01:41 <dcoutts> mapreduce: ok, there's your problem, gcc really cannot generate executables :-)
08:02:01 <dcoutts> mapreduce: looks like you've got an arch mismatch or something weird
08:02:25 <FunctorSalad> I must be doing it 'rong... "installHandler sigTERM (Catch handle_sigTERM) Nothing"
08:02:36 <mapreduce> libc.so.6 links to libc-2.5.so, which 'file' says is a 64-bit ELF so for Linux 2.6.0.
08:02:48 <FunctorSalad> handle_sigTERM = do putStr "omg, sigTERM received"
08:02:49 <dmwit> Jedai: Even the binary distribution is pretty large and intricate, so GHC packages a configure and Makefile to help out.
08:02:53 <mapreduce> I did download the 64-bit build of Haskell.
08:03:09 <FunctorSalad> it printed that exactly once out of a dozen attempts or so
08:03:15 <mapreduce> of .. ghc, I mean.
08:03:34 <mapreduce> dcoutts: Ok, I'll look into that, thanks.
08:03:50 * mapreduce isn't sure he fancies building gcc in ~
08:05:43 <FunctorSalad> my program goes into "nextEvent" after installing that handler, maybe that has something to do with it
08:05:56 <FunctorSalad> (nextEvent waits for the next x11 event)
08:06:52 <FunctorSalad> but it doesn't run the signal handle even when it gets out of waiting
08:07:47 <FunctorSalad> *handler
08:12:12 <mapreduce> dcoutts: I have another remote machine it should work on.  Thanks.
08:12:30 <dcoutts> mapreduce: did you work out what was wrong with gcc?
08:13:41 <TomMD> Yay, new equalities solver just hit head from Manuel.  Hello type familiy happyness.
08:14:10 <Heffalump> TomMD: oooh.
08:14:29 <thoughtpolice> TomMD: yeah I saw that patch - does it make everything nice and stable? :]
08:14:46 <thoughtpolice> (i haven't built head in a week or so)
08:14:59 <TomMD> thoughtpolice: I don't know yet, just started to compile head again.
08:15:02 <mapreduce> dcoutts: No, but I've alerted the guy with root access.
08:15:39 <Heffalump>   - The code is there, but it is not being used yet.
08:15:42 <Heffalump> so...no.
08:15:46 <TomMD> drat
08:17:06 <TomMD> I see, missed that last line.  I was going to say - how did you review the code so fast? ;-)
08:18:40 <Heffalump> :-)
08:18:55 <bos> @seen ketil
08:18:55 <lambdabot> I saw ketil leaving #haskell 46m 38s ago, and .
08:20:22 <stevan> it seem as if a datatype defined using the record syntax can't be read from strings using the short-hand syntax, is that so? or i'm missing something?
08:21:40 <dmwit> What's the short-hand syntax?
08:22:19 <dmwit> > Node 1 []
08:22:21 <lambdabot>   Node {rootLabel = 1, subForest = []}
08:22:35 <dmwit> > read "Node {rootLabel = 1, subForest = []}" :: Tree Int
08:22:36 <lambdabot>   Node {rootLabel = 1, subForest = []}
08:22:42 <dmwit> Seems to work fine.
08:23:30 <stevan> > read "Node 1 []" :: Tree Int
08:23:32 <lambdabot>   mueval: Prelude.read: no parse
08:23:32 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
08:23:44 <dmwit> stevan: Ah, yes, that's correct.
08:23:53 <dmwit> Read usually knows exactly one format.
08:24:16 <stevan> ok
08:24:23 <dmwit> (All derived Read instances are that way, and most of the built-in ones, too.)
08:24:51 <dmwit> > (read "123456789.0", read "1.234567890e9") :: (Double, Double) -- arguably, one of the only exceptions
08:24:53 <lambdabot>   (1.23456789e8,1.23456789e9)
08:25:56 <mapreduce> dcoutts: checking for path to top of build tree... utils/pwd/pwd: /lib/i686/libc.so.6: version `GLIBC_2.3' not found (required by utils/pwd/pwd on the other machine.
08:26:39 <dcoutts> mapreduce: try the bindist for ghc-6.8.2 which was built against an older glibc + kernel
08:28:16 <mapreduce> I'm going to go another direction for a moment.  I have a working ghc 6.6 on the asus eee that's on my lap.  My program works with ghci 3.hs then typing main and pressing return.
08:29:10 <mapreduce> So I guessed I should be able to do ghc 3.hs and find some a.out or similar.  I instead get undefined references to stuff in Network, e.g., Network_PortNumber_con_info
08:29:26 <mapreduce> I though I could then transfer that a.out to those remote machines (well, one of them).
08:30:31 <dmwit> mapreduce: Try ghc --make 3.hs
08:32:32 <mapreduce> Amusingly, that works, the binary runs but on the target machine it complains that libgmp is missing.
08:32:51 <Heffalump> try -optl-static
08:32:58 <Heffalump> that should get you a statically linked binary
08:35:26 <mapreduce> That appears to have made no difference.
08:37:27 <Heffalump> odd.
08:37:41 <Heffalump> perhaps there's a different way to make static binaries nowadays, I haven't used it for a while.
08:38:07 <dmwit> --make may override -optl-static
08:38:23 <Heffalump> that would seem an odd thing for it to do
08:38:29 <dmwit> I agree.
08:38:37 <Heffalump> you could probably use -v to find out what ld command is being run, and add -static to that.
08:38:37 <FliPPeh> @src last
08:38:38 <lambdabot> last [x]    = x
08:38:38 <lambdabot> last (_:xs) = last xs
08:38:38 <lambdabot> last []     = undefined
08:38:50 <FliPPeh> Neat
08:39:04 <dmwit> safeLast = take 1 . reverse
08:39:07 <Heffalump> the last line is particularly unhelpful
08:39:29 <Heffalump> either leaving it out, or providing a useful error message, would be better
08:39:42 <dmwit> > last [] -- they do better in most implementations, I guess
08:39:43 <lambdabot>   mueval: Prelude.read: no parse
08:39:43 <lambdabot>  mueval: *** Exception: Prelude.last: empty ...
08:39:58 <mapreduce> Heffalump: dmwit: The problem appears to be that I left the previous binary around.
08:40:14 <dmwit> mapreduce: Ah, yeah, I hate that.
08:40:28 <dmwit> It's a love/hate relationship, really.
08:40:36 <Heffalump> mapreduce: hehe
08:40:41 <dmwit> I like that GHC tries to do as little as is necessary, but hate that it's sometimes wrong. =)
08:41:01 <Heffalump> this is why the world should be run by nix.
08:41:25 <ben___> Desktops hardly run the world, so it probably is.
08:41:36 <Heffalump> nix, not *nix
08:41:38 <dmwit> ben___: nix is a particular distribution
08:41:46 <mapreduce> Great, success.
08:41:55 <dmwit> Do executables have a way of storing a comment?
08:41:57 <mapreduce> Now I need to make the program actually useful. :)
08:42:24 <ben___> Huh. Link?
08:42:34 <ben___> Somewhat hard to google for.
08:42:36 <mapreduce> What's the .hi file generated for?
08:42:37 <dmwit> It would be nice if GHC stored the command-line used to create an executable *in the executable*, so that it could correctly guess when the command-line has changed (and hence actually has to do some work).
08:42:42 <dmwit> ben___: Google for nixos.
08:46:13 <Jedai> safeLast = listToMaybe . reverse
08:46:37 <Heffalump> mapreduce: it's the interface needed for other modules that depend on this one
08:46:40 <Jedai> > let safeLast = listToMaybe . reverse in safeLast []
08:46:42 <lambdabot>   Nothing
08:46:58 <Heffalump> at the minimum it contains the API of the module
08:47:13 <Heffalump> it might also contain optimisation information (e.g. function bodies for cross-module inlining)
08:47:34 <Heffalump> If a .hi file your module depends on has changed, you need to recompile your module.
08:48:53 <mapreduce> ghc building a statically-linked executable seems to bring my machine to a crawl, is there a way of making it less CPU or memory intensive?  i don't mind slower builds.
08:49:17 <mapreduce> Heffalump: I see.
08:49:22 <cjb> mapreduce: nice(1)?
08:49:27 <Heffalump> I think ld will be the thing taking up the CPU/memory.
08:49:42 <mapreduce> nice won't help if it's memory rather than CPU.
08:49:48 <Heffalump> google made a new faster ld, didn't they? You could see if that helps - I dunno how painful it is to install, though.
08:49:56 <mapreduce> Heffalump: Ah.  Anything I can do about that?
08:50:10 <Heffalump> my best guess is "not really", though.
08:50:37 <ddarius> Don't use libraries built with -split-objs
08:50:43 <cjb> mapreduce: do you have swap?
08:50:58 <mapreduce> cjb: You might be barking up the wrong tree there.
08:51:08 <mapreduce> The local machine is an Asus EEE.
08:51:13 <cjb> I'm just curious why it's bringing your.. oh.
08:51:23 <mapreduce> (a great reason to get the remote machines fixed so I can compile on them)
08:51:27 <mc__> what is the haskell pendant for null/nil ?
08:51:39 <Botje> what do you mean?
08:51:40 <cjb> mc__: Nothing
08:51:58 <BONUS> hey what are some good uses for inits and tails
08:52:01 <mc__> ty cjb
08:52:03 <BONUS> i cant think of any off the top of my head
08:52:07 <BONUS> im trying to explain something to someone
08:52:28 <Heffalump> foldr/foldl <-> scanr/scanl equivalence?
08:52:43 <BONUS> hmm yeah
08:52:47 <Botje> > let l = [1..5] in zip (inits l) (tails l)
08:52:49 <lambdabot>   [([],[1,2,3,4,5]),([1],[2,3,4,5]),([1,2],[3,4,5]),([1,2,3],[4,5]),([1,2,3,4...
08:52:50 <Heffalump> sublist finding?
08:53:00 <ddarius> @src isInfixOf
08:53:00 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
08:53:02 <Botje> BONUS: also, isPrefixOf . tails
08:53:09 <Botje> to search for a substring
08:53:11 <BONUS> ahh yeah it was that yeah!
08:53:15 <BONUS> awesome
08:53:26 <BONUS> i remember doing something cool with doing inits or tails and then folding that but i cant remember what
08:54:08 <mapreduce> I'm gonna have to write this stuff up so I don't forget it.
08:56:22 <ddarius> @. pl src isInfixOf
08:56:22 <lambdabot> (line 1, column 1):
08:56:22 <lambdabot> unexpected end of input
08:56:22 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:56:56 <FliPPeh> @src .
08:56:56 <lambdabot> (f . g) x = f (g x)
08:57:16 <FliPPeh> :D
08:57:33 <ddarius> @pl isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
08:57:34 <lambdabot> isInfixOf = (. tails) . any . isPrefixOf
09:10:26 <ziman> @type (.)
09:10:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:10:36 <ziman> boring.
09:10:37 <ziman> :)
09:11:15 <trofi> :t mfix
09:11:16 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
09:12:41 <Botje> :t callCC
09:12:43 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:12:50 <Botje> slightly less interesting type.
09:12:54 <Botje> *more
09:12:55 <Botje> even :p
09:15:07 <mapreduce> dmwit: Heffalump: More for my benefit than anyone else's, but: http://rickyclarkson.blogspot.com/2008/09/irc-bot-in-haskell-20-code-80-grr.html
09:15:09 <lambdabot> Title: Ricky's technical blog: An IRC Bot in Haskell, 20% code, 80% GRR, http://tinyurl.com/6yba7r
09:16:41 <_zenon_> What's GRR?
09:16:52 <Heffalump> an expression of annoyance
09:16:53 <Zao> _zenon_: An angry noise.
09:17:10 <_zenon_> Ah... okay, it's onomatopoetic
09:17:13 <Heffalump> "(no, really)"? :-)
09:17:20 <mc__> nowadays people assume everything is an acronym ^^
09:17:26 <_zenon_> hehe, I thought it was
09:17:36 <dmwit> mapreduce: You don't like Heffalump's nick? =P
09:17:42 <_zenon_> Like .. Generic ... something
09:18:00 <dmwit> Generic Reduction Requirement
09:18:11 <mc__> yeah that sounds good
09:20:29 <thoughtpolice> mapreduce: that your blog? if so, would you say good things about the eee? i was thinking of buying one when money permits me to do so
09:21:03 * Botje will buy a netbook for giving presentations and using wireless
09:21:08 <Botje> anything else it's good for is a bonus :)
09:22:36 <FliPPeh> @src ++
09:22:36 <lambdabot> []     ++ ys = ys
09:22:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:22:36 <lambdabot> -- OR
09:22:36 <lambdabot> xs ++ ys = foldr (:) ys xs
09:22:40 <FliPPeh> Whoo spam
09:23:23 <Twey> I'm guessing the former is how it's implemented in the Report, and the latter is how most people would implement it given the choice?
09:23:52 <hackage> Uploaded to hackage: test-framework 0.1.2
09:23:52 <hackage> Uploaded to hackage: ansi-wl-pprint 0.4.0
09:23:52 <hackage> Uploaded to hackage: ansi-terminal 0.4.0
09:23:53 <hackage> Uploaded to hackage: ansi-wl-pprint 0.3.1
09:23:55 <hackage> Uploaded to hackage: ansi-terminal 0.3.1
09:24:17 <FliPPeh> And the title of "Spammer" goes to hackage!
09:26:29 <mapreduce> thoughtpolice: Yes, I really really like the eee.  But other people find them difficult to type on..
09:26:58 <mapreduce> My normal typing speed is around 100-110wpm, I think it's probably 90 on the eee, but I find it more relaxing to type on because there's less movement involved.
09:27:39 <mapreduce> dmwit: Heffalump: C'mon, they are amusing nicks. :)
09:28:08 <dmwit> =)
09:28:13 <Heffalump> I wasn't complaining, just commenting :-)
09:28:18 <thoughtpolice> mapreduce: cool. i'll look into getting one although I don't know if I'd like xandros - know if debian or something works?
09:28:30 <Heffalump> why are they hard to type on?
09:38:32 <Jedai> Heffalump: The keyboard is small
09:51:47 <mapreduce> thoughtpolice: You are able to screw it up with Debian packages so much that you need to reinstall.  I'm not sure how you would reinstall though.
09:52:30 <mapreduce> thoughtpolice: The Xandros repos are not perfectly safe either, but they are known good in most cases.  eeeusers.com has details on this, iirc.
10:14:57 <newsham> hmm..  Data.Binary.Get.bytesRead, but no Data.Binary.Put.bytesWritten.  :(
10:15:00 <newsham> i'm in trouble
10:40:54 <Heffalump> dcoutts: cabal install has been resolving dependencies for 4 minutes, and is using 400MB of memory and 100% CPU. Should I assume something is wrong?
10:41:22 <dcoutts> Heffalump: mm, that's exciting
10:41:35 <Heffalump> this is with my newly built HEAD ghc.
10:41:47 <dcoutts> Heffalump: ok, can you do two things
10:42:09 <dcoutts> one, save your global and local package.conf files so we can try reproducing this elsewhere
10:42:20 <dcoutts> two, ^C and run again with -v
10:42:38 <dcoutts> see if it's producing any resolver output at all
10:44:38 <Heffalump> this is running --global, so is there any point in saving the local file?
10:46:23 <dcoutts> Heffalump: in that case, no
10:46:34 <Heffalump> good, cos I can't find it ;-)
10:47:07 <Heffalump> preliminary indications are that there is no resolver output at all.
10:47:57 <Heffalump> it's now had a minute, so I think definitely not.
10:49:50 <dcoutts> Heffalump: and this is for a task that you'd normally expect to be small? I presume you do not have many packages registered?
10:50:09 <dcoutts> it only usually takes a while for things like trying to resolve a plan for all of hackage
10:50:14 <Heffalump> this is trying to install "plugins" into my fresh ghc build
10:50:32 <dcoutts> Heffalump: and do you get the same for anything you try?
10:51:08 <Heffalump> looks like it, as it happens with a very small and simple package (rmonad)
10:51:24 <dcoutts> Heffalump: so what cabal-install version?
10:51:36 <Heffalump> ganesh@defoe:~$ cabal --version
10:51:36 <Heffalump> cabal-install version 0.5.1
10:51:37 <Heffalump> using version 1.4.0.1 of the Cabal library
10:51:42 <Heffalump> I guess an upgrade is called for?
10:52:06 <dcoutts> Heffalump: there's nothing in the behaviour you're seeing that I'd expect an upgrade to fix
10:52:14 <Heffalump> ok. Shall I check anyway?
10:52:28 <dcoutts> Heffalump: ok, make sure the global conf is saved
10:52:35 <Heffalump> that's already done
10:53:22 <dcoutts> Heffalump: so, this is the same cabal-install that has worked ok before, but it's failing now when you're telling it to use ghc-6.9 ?
10:53:39 <dcoutts> Heffalump: or did you build this cabal-install using ghc-6.9?
10:54:04 <purestorm> Hi. How can I convert String to ByteString?
10:54:18 <dcoutts> purestorm: ask hoogle
10:54:24 <Heffalump> I can't remember what I built it with, but it's certainly been working before.
10:55:17 <purestorm> dcoutts: I tried that. What should I look for? " String ->" does not appear in the documentation of Data.ByteString.
10:55:21 <dcoutts> Heffalump: I wonder if the base-3/4 thing is upsetting it somehow
10:55:29 <dcoutts> @hoogle String -> ByteString
10:55:29 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
10:55:29 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
10:55:29 <lambdabot> Prelude read :: Read a => String -> a
10:55:48 <dcoutts> purestorm: ^^ that's what I mean by asking hoogle
10:55:52 <newsham> dons: around?
10:56:02 <purestorm> Oh, I consulted the web site. Thanks.
10:56:06 <Heffalump> dcoutts: plausible, it probably does complicate the solution space rather.
10:56:10 <dcoutts> purestorm: you want a function from String to ByteString, so hoogle for String -> ByteString
10:56:19 <purestorm> nice
10:56:27 <dons> newsham: rise and shine!
10:56:58 <dons> hoogle makes people think in types == good thing.
10:56:59 <dcoutts> Heffalump: I do expect it not to work at the moment with the base-3/4 thing, but not by hanging :-)
10:57:21 <Heffalump> :-)
10:57:39 <newsham> dons: I have a Data.Binary question or perhaps request.   Data.Binary.Put doesnt seem to have a "getBytesWritten" (like Data.Binary.Get.getBytesRead) and my protocol needs something like that.   Also I would like to make a StateT out on PutM, but there doesnt seem to be a runPutM or access to the internals to write one outside the library (ie. PairS)
10:57:52 <dcoutts> Heffalump: so if you could send me the global package.conf that'd might help me reproduce it
10:58:18 <newsham> if it was just evalStateT i can use runPut, but if I need to get the state out of it, I need PairS
10:58:29 <dons> newsham: hmm. you can certainly layer it. i'm not sure if we make it easy to do.
10:58:52 <dons> ah, so PairS isn't exported
10:59:06 <newsham> right.  although exporting that would prob be worse solution than making a runPairM
10:59:10 <dcoutts> but it probably shouldn't
10:59:12 <newsham> which would hide the abstraction
10:59:15 <dons> unPut is , but not PairS.
10:59:33 <newsham> urr..  runPutM
10:59:45 <dons> so you want to runState (runPut ) and get what back?
11:00:01 <Heffalump> dcoutts: will do, just waiting for the upgrade to check if it still happens. Is there a bug tracker, or shall I just mail it to you?
11:00:15 <dons> oh, you want to interleave them. i see. access the current PairS at each point?
11:00:17 <mapreduce> dons: Your IRC bot tutorial is great, thanks.
11:00:34 <dons> mapreduce: sure.
11:00:37 <dcoutts> Heffalump: there is, http://hackage.haskell.org/trac/hackage/
11:00:39 <lambdabot> Title: Hackage - Trac
11:00:49 <dons> it might be fun to write a "modern" version: STM + parallelism + new network libs
11:01:21 <mapreduce> dons: Heh, I was pondering how to make command responses run in parallel, not that I have any need for that right now.
11:01:31 <newsham> runStateT myprog s :: PutM (a,s)    then runPutM to get out the s
11:02:27 <dons> http://rickyclarkson.blogspot.com/2008/09/irc-bot-in-haskell-20-code-80-grr.html
11:02:29 <lambdabot> Title: Ricky's technical blog: An IRC Bot in Haskell, 20% code, 80% GRR, http://tinyurl.com/6yba7r
11:02:30 <dons> i see!
11:02:34 <mapreduce> dons: heh
11:02:46 <dons> yeah, forkIO the jobs as they arrive.
11:03:04 <dons> so you can do things asynchronously, and on spare cpus (for when the bot is under load .. :)
11:03:42 <dons> yes, so you needed a statically linked executable.
11:03:42 <newsham> dons: how hard would it be to add a "getBytesWritten :: PutM Int64" ?
11:03:56 <dons> newsham: you want to add a counter to the state?
11:04:18 <newsham> dons: my protocol requires knowing what the current offset is.
11:04:37 <newsham> there's already a    getBytesRead :: Get Int64
11:04:45 <newsham> but nothing for Put
11:05:23 <dons> no, i see that. so i think modifying things so you are able to use a StateT for extra counts
11:07:06 <mapreduce> Also, 6.8.2 failed in the same way, "checking for path to top of build tree... utils/pwd/pwd: /lib/i686/libc.so.6: version `GLIBC_2.3' not found (required by utils/pwd)"
11:07:19 <mapreduce> I think it was dcoutts or dmwit who suggested that.
11:07:55 <newsham> do you think this is something that Put should do, or is it something people should layer on afterwards?
11:08:04 <newsham> i'm not really familiar with Builder.
11:08:08 <newsham> i should probably look at that
11:08:23 <dons> newsham: i don't like the idea of adding 'write' counters to the state.
11:08:36 <dcoutts> newsham: builder has a very simple api, no support for counting the offset there
11:08:49 <dcoutts> but it's doable for put, I think we need most of that info anyway
11:09:14 <dons> just work out what you need changed to write it properly.
11:09:45 <dons> people always find good reasons to work around library abstraction, eh, dcoutts
11:10:44 <Heffalump> ugh? cabal install just failed to upgrade itself on a unix machine.
11:10:49 <Heffalump> cabal: /usr/local/bin/cabal: copyFile: resource busy (Text file busy)
11:11:18 <FliPPeh> @src !!
11:11:18 <lambdabot> xs     !! n | n < 0 = undefined
11:11:18 <lambdabot> []     !! _         = undefined
11:11:18 <lambdabot> (x:_)  !! 0         = x
11:11:18 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:11:40 <trofi> @src undefined
11:11:41 <lambdabot> undefined =  error "Prelude.undefined"
11:11:47 <newsham> > undefined
11:11:48 <lambdabot>   mueval: Prelude.read: no parse
11:11:48 <lambdabot>  mueval: *** Exception: Prelude.undefined
11:11:49 <FliPPeh> So that one does access an element based on it's number in the list?
11:11:56 <Heffalump> yes
11:12:02 <FliPPeh> Hm
11:12:02 <dcoutts> dons: they *think* they do ;-)
11:12:13 <FliPPeh> HMMM
11:12:16 <Heffalump> but you should try to avoid it, it's inefficient and sometimes an indicator that you are using lists like they are arrays
11:12:18 <newsham> i'd love to not have to work around a library abstraction :)
11:12:20 <trofi> > let und | False = und in und
11:12:21 <Heffalump> which they aren't
11:12:22 <lambdabot>   mueval: Prelude.read: no parse
11:12:22 <lambdabot>  mueval: *** Exception: /tmp/685734939506144...
11:12:29 <FliPPeh> I guess so :(
11:12:34 <newsham> unfortunately this protocol is dictated to me and i cant htink of a more clever way to handle it
11:12:35 <trofi> > let { und | False = und } in und
11:12:37 <lambdabot>   mueval: Prelude.read: no parse
11:12:37 <lambdabot>  mueval: *** Exception: /tmp/562458419993390...
11:12:37 <dcoutts> Heffalump: hmm, that is confusing
11:12:40 <FliPPeh> But I can't imagine doing anything more complicated right now
11:12:47 <FliPPeh> Like string processing
11:13:02 <FliPPeh> I already see how Haskell is great for mathemaics
11:13:06 <FliPPeh> mathematics*
11:13:15 <Heffalump> we have cool libraries for fast string processing
11:13:25 <Heffalump> and if you don't need massive speed, String is fine
11:13:48 <FliPPeh> You mean the basic string Alias?
11:13:52 <Heffalump> yes
11:13:54 <newsham> DNS packets have "compressed" domain names where any previously used domain name can be represented by a back reference to the offset of the earlier definition
11:13:59 <FliPPeh> HMhm
11:14:17 <purestorm> How to convert from Data.ByteString.Lazy.Internal.ByteString to Data.ByteString.ByteString? lambdabot does not know.
11:14:22 <ketil> FliPPeh, for performance: Data.ByteString(.Lazy, .Char8 etc)
11:14:24 <FunctorSalad> do I have to use unsafePerformIO to initialize an MVar as in the example?
11:14:31 <FliPPeh> In my old favourite language I could do "myString[2 .. $]" and get anything from start to end
11:14:31 <dons> i find the "good for mathematics" meme funny. we have far more networking/string/data libraries, than math libraries
11:14:38 <FliPPeh> I have no idea how to do it in haskell
11:14:42 <Heffalump> most mathematicians complain about the prelude.
11:14:44 <Botje> FliPPeh: drop 2 string
11:14:50 <Botje> > drop 2 "i like cookies"
11:14:51 <lambdabot>   "like cookies"
11:14:53 <dons> FliPPeh: i think you should look over the standard List module
11:14:55 <ketil> purestorm, fromChunks/toChunks?
11:14:56 <FunctorSalad> or can I just have a local MVar in my main thread and pass it to the other threads upon their creation
11:14:56 <dons> ?docs Data.List
11:14:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
11:14:59 <Heffalump> FunctorSalad: as in what example?
11:15:06 <FliPPeh> And everything from position 5 to end-6 ?
11:15:16 <Heffalump> passing an MVar from your main thread to the other threads is much better.
11:15:22 <dcoutts> Heffalump: I don't understand how that can happen, System.Directory.copyFile uses the rename trick so never opens the original target file for writing
11:15:38 <dons> FliPPeh: are you writing a parser?
11:15:39 <Heffalump> FliPPeh: drop 5 . take 7 or take 2 . drop 5
11:15:43 <ketil> > map (!![5..6]) "foo bar zot"
11:15:45 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
11:15:51 <FliPPeh> Hm
11:15:56 <ketil> sorry, that was too quick
11:15:58 <Heffalump> dcoutts: this is running as a user, with --global --root-cmd=sudo, if that helps.
11:15:59 <dons> cute idea, ketil
11:16:00 <FliPPeh> I should do my homework
11:16:06 <FliPPeh> :d
11:16:07 <purestorm> ketil: And then join them?
11:16:08 <dons> FliPPeh: study the list functions, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
11:16:09 <ketil> map ("foo bar zot"!!) [5..6]
11:16:11 <lambdabot> Title: Data.List, http://tinyurl.com/yhrw65
11:16:13 <Heffalump> ketil: ewww.
11:16:14 <dons> memorise them.
11:16:22 <ketil> > map ("foo bar zot"!!) [5..6]
11:16:22 <dons> > map ("foo bar zot"!!) [5..6]
11:16:24 <lambdabot>   "ar"
11:16:24 <lambdabot>  Terminated
11:16:26 <dons> heh
11:16:38 <ketil> but...which is which?
11:16:39 <purestorm> It's a bit weird that encode converts to something internal instead of ByteString :(
11:16:40 <FunctorSalad> Heffalump: in the ghc docs, ctrl-f for "unsafe" here http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
11:16:42 <lambdabot> Title: Control.Concurrent, http://tinyurl.com/33wpmr
11:16:55 <dons> purestorm: ? a lazy bytestring?
11:16:56 <Heffalump> FunctorSalad: ok, I happen to know that one because I was just looking at it.
11:17:04 <FunctorSalad> hehe
11:17:04 <dons> ?type Data.Binary.encode
11:17:04 <Heffalump> If you can arrange not to need the global, that'd be much better.
11:17:05 <lambdabot> forall a. (Data.Binary.Binary a) => a -> BSLC.ByteString
11:17:17 <FunctorSalad> Heffalump: that's what I thought too
11:17:28 <mapreduce> In ghci if I use return 5, with no type annotation, what's happening?
11:17:37 <mapreduce> Is there some identity monad that is defaulted to?
11:17:40 <FliPPeh> I think I'll browse the lambdabot source
11:17:42 <Heffalump> mapreduce: defaulting is picking Integer for the type, and IO for the monad.
11:17:45 <Heffalump> (I think)
11:17:56 <FliPPeh> I think it does a lot of stringies
11:17:58 <dons> FliPPeh: do you know about hackage.haskell.org ?
11:18:04 <FliPPeh> Nah
11:18:10 <FliPPeh> Hackage is that spammy bot :(
11:18:16 <trofi> :]
11:19:00 <mapreduce> Heffalump: I see, thanks.
11:19:02 <FunctorSalad> > (return 5 :: IO Integer)
11:19:03 <lambdabot>   mueval: Prelude.read: no parse
11:19:04 <lambdabot>  mueval: *** Exception: "<IO Integer>"
11:19:18 <FunctorSalad> > (return 5 :: Integer)
11:19:19 <lambdabot>   Couldn't match expected type `Integer' against inferred type `m t'
11:19:26 <FunctorSalad> > (return 5 :: Identity Integer)
11:19:27 <lambdabot>       No instance for (Show (Identity Integer))
11:19:27 <lambdabot>        arising from a use of ...
11:19:37 <FunctorSalad> :)
11:19:38 <Heffalump> dcoutts: I guess I can't get much useful info with strace due to the use of sudo. Are you particularly interested in debugging this (i.e. the failure to upgrade it) or shall I move on?
11:20:18 <dcoutts> Heffalump: I'm just trying to reproduce it
11:20:25 <dons> FliPPeh: no. hackage.haskell.org is the library site.
11:20:27 <Heffalump> ok, I'll hold on.
11:20:43 <dons> FliPPeh: it's like CPAN for Haskell.
11:21:55 <trofi> > [1,2,3] >>= [4,5,6]
11:21:57 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
11:22:01 <trofi> > [1,2,3] >> [4,5,6]
11:22:07 <lambdabot>   [4,5,6,4,5,6,4,5,6]
11:22:07 <dcoutts> Heffalump: hmm, works ok for me. You're not using nfs or some weird file system?
11:22:36 <Heffalump> nope. ext3 on Debian, running under vmware.
11:22:53 <dcoutts> Heffalump: file a ticket, perhaps someone else will get the same symptoms
11:22:56 <Heffalump> ext3 under lvm, to be precise.
11:23:20 <trofi> strace logs would help
11:23:30 <Heffalump> trofi: except that I can't strace it once it sudos
11:23:42 <trofi> sudo strace cmd ?
11:23:47 <Heffalump> at least, I don't know how to do that sanely. It seems to exit much earlier when I strace it.
11:23:47 <dcoutts> Heffalump: if you have the time, try installing it as user and see if you get the same
11:23:55 <Heffalump> trofi: then it would run as root, wouldn't it?
11:24:20 <trofi> or --sudo-command='sudo strace somehow'
11:24:28 <Heffalump> oh, that might work
11:24:57 <Heffalump> am just trying as a user.
11:27:35 <vininim> > [1,2,3] >>= return.(+1)
11:27:37 <lambdabot>   [2,3,4]
11:27:52 <Heffalump> ok, it did happen.
11:28:49 <mapreduce> :t (>>=)
11:28:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:29:20 <vininim> > [1,2,3] >>= \ x -> map (+x) [4,5,6]
11:29:21 <lambdabot>   [5,6,7,6,7,8,7,8,9]
11:31:37 <Heffalump> dcoutts: strace doesn't give any indication that it's trying to move and rename. I just see an open of the binary with O_WRONLY|O_CREAT (and some other flags) which fails with ETXTBSY
11:31:38 <vininim> @pl \ x -> map (+x) []
11:31:38 <lambdabot> const []
11:31:44 <vininim> @pl \ x -> map (+x) [1,2,3]
11:31:45 <lambdabot> flip map [1, 2, 3] . (+)
11:32:09 <BONUS_> hmmm
11:32:11 <Heffalump> I'm going to actually upgrade it now then see if it still happens.
11:32:17 <Heffalump> (I've got the old binary safe)
11:32:50 <dcoutts> Heffalump: that's pretty odd. The code for copyFile is clearly doing that, in 6.8 and latest ghc HEAD
11:33:25 <Heffalump> can I get the RTS to tell me which GHC built it?
11:33:29 <Heffalump> (or otherwise find out)
11:33:37 <dcoutts> Heffalump: +RTS --info
11:33:44 <dcoutts> Heffalump: and we install using copyFileVerbose which calls copyFile, and it's copyFile that seems to be generating the error message
11:33:54 <Heffalump> unknown RTS option: --info
11:34:04 <Heffalump> I wonder if that shows it's 6.6
11:34:10 <dcoutts> Heffalump: ah, lemme check copyFile for 6.6
11:34:20 <Heffalump> it won't be any earlier than 6.6
11:35:01 <dcoutts> Heffalump: yep 6.6 is using different copyFile code
11:35:11 <Heffalump> ok, mystery explained :-)
11:35:20 <dcoutts> Heffalump: and it changed in 6.6.1
11:35:25 <dcoutts> Heffalump: which is why I never got it
11:35:30 <Heffalump> I blame Debian ;-)
11:35:35 <dcoutts> me too :-)
11:43:09 <Heffalump> dcoutts: ticket 349 created
11:45:51 <FordCortina> Agda2 is a strict langage right? it has to be because it's a total language?
11:47:00 <newsham> if offset tracking is done externally from Put, then none of the instance Binary's will benefit from it.
11:48:33 <ddarius> FordCortina: If it is total (and otherwise effect-free), there's no way to observe a difference between it being strict and lazy.
11:51:39 <FordCortina> ddarius: ah that was not one answers i was expecting :)
11:51:44 <FordCortina> surely
11:52:18 <FordCortina> if for every symbol in a lazy language you allow it to be non-terminating
11:52:51 <FordCortina> that is a complete contrast to a language where every symbol must be show itself to be terminating
11:53:07 <ddarius> Being "total" means there are no non-terminating terms.
11:53:25 <ddarius> "strict" means f _|_ = _|_, "total" means there is no _|_
11:53:29 <mc__> no endless loops?
11:53:41 <FordCortina> aha
11:56:21 <FordCortina> mc__: in a total language there can be no endless loops, yes (i gather anyway)
11:57:01 <mc__> FordCortina: interesting, how is that possible?
11:57:32 <purestorm> How can I get a hexadecimal representation string of an integer?
11:57:35 <ddarius> mc__: What do you mean? As a brute force way, if you remove recursion from Haskell you can't write any non-terminating loops.
11:57:46 <TomMD> purestorm: See the Numeric library
11:57:52 <TomMD> @hoogle showHex
11:57:52 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
11:58:03 <FordCortina> mc__: there's a termination checker... you can only express a certain subset of programs, in a certain way.
11:58:28 <ddarius> There is a dual notion to "total", "productive", that allows the production of an endless supply of values.  "productive" means that it will produce the next output in finite time.
11:58:35 <TomMD> "purestorm" Is that a storm that has no side effects?  If so, what is the return value?
11:58:38 <mc__> I see
11:58:53 <purestorm> TomMD: ()
11:59:08 <dcoutts> Heffalump: thanks
11:59:36 <FordCortina> ddarius: so what is f _|_ equal to in a lazy language? just *crash* or what?
11:59:52 <TomMD> purestorm: You also might be interested in the Text.Printf.printf function - for some reason people miss it.
12:00:14 <ddarius> FordCortina: Functions are strict or lazy.  A language being strict means all functions are strict.
12:00:17 <purestorm> TomMD: For simplicity's sake, I guess.
12:00:23 <ddarius> So to answer your question you have to tell me what f is.
12:00:34 <mc__> ddarius:  really?
12:00:36 <ddarius> Anyway, "crash" = _|_
12:00:52 <ddarius> FordCortina: const 3 _|_ = 3
12:00:59 <ddarius> 3+_|_ = _|_
12:01:09 <ddarius> > const 3 undefined
12:01:10 <mc__> the author of the book I'm reading says there are strict and lazy functions in haskell
12:01:10 <lambdabot>   3
12:01:16 <FordCortina> ah i think i see what you mean
12:01:18 <ddarius> mc__: Indeed there are.
12:01:34 <mc__> so not all are automatically lazy if the language is lazy
12:01:49 <ddarius> mc__: Haskell being non-strict just means that f _|_ = _|_ does not necessarily hold.  That is all.
12:02:05 <mc__> ok
12:03:34 <FordCortina> thanks ddarius
12:04:29 <ddarius> By the way, oftentimes "total" is used to include both total and productive.
12:07:37 <mattam> mc__: you can be lazy in a strict language as well.
12:08:19 <ddarius> mattam: You can emulate it.
12:11:46 <mattam> ddarius: are you suggesting you can't be as lazy or just that you have to decorate terms?
12:14:05 <haskellian> http://hpaste.org/10186 , i translated it from erlang but it isnt working, cannot construct infinite type.
12:14:29 <ddarius> mattam: I'm saying if the language is actually strict, you can't have non-strict functions but you can emulate them.  If the language allows non-strict functions then it is not strict it is, at best, strict-by-default.
12:14:44 <byorgey> haskellian: try h:t instead of h:[t]
12:14:58 <byorgey> haskellian: (:) (i.e. cons) has type  a -> [a] -> [a]
12:15:09 <byorgey> so the first argument should be an element while the second is a list
12:15:36 <haskellian> thanks, compiles but returns [] for perms [1,2,3]
12:15:51 <byorgey> @type delete
12:15:52 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:15:53 <haskellian> but is it really allowed to use h in both places
12:16:09 <haskellian> or it is euqivalent to an inner for loop the second comprehension?
12:16:10 <byorgey> haskellian: I think you have the parameters to delete switched around, perhaps?
12:16:22 <byorgey> > delete 1 [3,2,1]
12:16:23 <haskellian> it is my own delete
12:16:24 <lambdabot>   [3,2]
12:16:27 <byorgey> oh, I see
12:17:11 <trofi> :t delete
12:17:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
12:17:26 <byorgey> haskellian: yes [ foo | x <- bla, y <- bla ] is like nested loops
12:18:10 <FliPPeh> @src negate
12:18:10 <lambdabot> negate x = 0 - x
12:18:23 <byorgey> haskellian: if it still doesn't work I would look at your delete function
12:18:28 <byorgey> make sure it is working as you expect
12:21:08 <haskellian> i siwtched to List.delete, but im sure mine works too
12:21:47 <haskellian> it is the exact same function now and it works in erlang, strange
12:25:00 <byorgey> haskellian: so what exactly does your second case, perms (x:xs) = ...  look like now?
12:25:01 <haskellian> wait  it wasnt lol, perms [] = [[]]
12:25:12 <byorgey> oh! right, duh =)
12:25:16 <haskellian> perms xs = [(h:t) | h <- xs, t <- perms $ L.delete h xs]
12:25:19 <haskellian> works now
12:25:23 <byorgey> great =)
12:25:27 <haskellian> ty
12:35:37 <Wild_Cat> 'evening.
12:35:44 <FunctorSalad> by the way, passing a MVar to my (unix-)signal handler function worked just fine. some sort of IO closure I guess?
12:36:51 <FunctorSalad> (the signal handler writes to the mvar when the signal is caught)
12:37:01 <Taejo> @pl return x = T (\t -> (x, t)
12:37:01 <lambdabot> (line 1, column 10):
12:37:01 <lambdabot> unexpected "="
12:37:01 <lambdabot> expecting variable, "(", operator or end of input
12:37:04 <Taejo> @pl return x = T (\t -> (x, t))
12:37:05 <lambdabot> return = T . (,)
12:37:19 <dons> FunctorSalad: yeah. everything's a closure.
12:37:35 <FunctorSalad> dons: the involvement of IO confuses me though
12:37:58 <dons> well, you still need to plug in a RealWorld# token to run it.
12:38:09 <dons> it's just a function, suspended with its environment from the calling site.
12:38:44 <FunctorSalad> how does the event handler get that token when the OS calls it?
12:39:09 <FunctorSalad> err, signal handler I mean
12:39:25 <dons> the signal handlers are set up in the IO monad
12:39:35 <dons> so they see the token from their binding site.
12:39:43 <dons> (there's no actual real world token at runtime)
12:40:10 <FunctorSalad> they're set up in IO, yes, but called inside their own thread from somewhere I don't understand :)
12:40:16 <dons> signal handlers are interesting, they're a bit like another 'main'
12:40:31 <dons> in that they look like a new entry point.
12:40:46 <FunctorSalad> yeah
12:41:21 <dons> mapreduce: so getting a feel for the libraries now?
12:51:12 <dblazakis> does hOp exist anywhere anymore (all googling leads me to pages which no longer exist)? and was the source ever released?
12:51:38 <dons> it exists as House (and various branches and forks) at PSU.
12:51:51 <dons> http://programatica.cs.pdx.edu/House/
12:51:51 <lambdabot> Title: House
12:52:43 <dons> hmm. i wonder if there's code to stick on hackage there.
12:53:51 <intoverflow> For a while I had the source to hOp, although I wasn't able to get it to build; it relied on a modified ghc runtime, iirc
12:54:45 <dblazakis> dons: thanks
12:56:36 <dons> intoverflow: definitely relies on a modified ghc runtime :)
12:56:45 <dons> the one that runs on bare metal. which has a certain flavor
12:56:51 <sadache> i want to foldr (+) on a list of Maybe Int
12:56:54 <intoverflow> dblazakis: I've got  hOp-2004-06-09.tar
12:56:58 <sadache> i cant recal how to do it
12:57:09 <dons> sadache: sum . catMaybes ?
12:57:37 <dblazakis> intoverflow: compiling was an issue?  i'm wondering if the documentation to the House stuff is any better
12:58:08 <dons> > sum . catMaybes $ [ x | n <- [1..100], let x = if odd n then Nothing else Just n ]
12:58:09 <lambdabot>   2550
12:58:28 <sadache> dons:  cant i do it with fmap?
12:58:30 <Feuerbach> Why catchCGI doesn't catch ordinary exceptions (like undefined)? See http://hackage.haskell.org/packages/archive/cgi/3001.1.6.0/doc/html/src/Network-CGI-Monad.html#catchCGI
12:58:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/597534
12:58:41 <dons> hmm, what would *fold* comprehensions look like?
12:59:01 <dons> Feuerbach: does it not use Control.Exception.catch ?
12:59:12 <dons> ?src fmap Maybe
12:59:12 <lambdabot> Source not found. You type like i drive.
12:59:13 <intoverflow> dblazakis: I never tried to build house, although it was an academic project, and thus might have better docs
12:59:16 <dons> ?src Maybe fmap
12:59:17 <lambdabot> fmap _ Nothing       = Nothing
12:59:17 <lambdabot> fmap f (Just a)      = Just (f a)
12:59:23 <waynemokane> is there a builtin quickie for going between strings and enumerated types?
12:59:28 <dons> sadache: so that only gives you 'map'
12:59:29 <dblazakis> intoverflow: i was interested in seeing the major issues they solved in porting a runtime like GHCs to bare metal
12:59:33 <dons> waynemokane: read ?
12:59:34 <Feuerbach> dons: it uses try from Control.Exception
12:59:43 <dons> Feuerbach: that should be ok then
12:59:48 <dblazakis> intoverflow: the House papers just sort of say "yeah, we just used hOps" or at least that was the impression i got
12:59:54 <dons> Feuerbach: 'undefined' is just a normal exception
13:00:27 <Feuerbach> dons: yes, that's why I ask :)
13:00:44 <sadache> dons: I remember i saw a way using foldr with fmap to fold (+) on Maybe Int, but maybe i am mistaken
13:00:45 <intoverflow> dblazakis: I worked on my own haskell-based os for a while; getting ghc onto bare metal isn't *too* hard.  I got it to run by compiling my binary with ghc, getting a list of missing symbols, and re-implementing what parts of posix I needed to get ghc to go
13:01:08 <intoverflow> dblazakis: you can fake a lot of it depending on how much of the runtime you actually need
13:01:33 <dblazakis> intoverflow: ah, thats an interesting path to take -- port the small slice of posix you need instead of the ghc runtime
13:01:51 <newsham> dons: emailed you re: PutM.
13:01:52 <dblazakis> "small slice" :-)
13:02:58 <intoverflow> dblazakis: it relies on a surprisingly-small amount of posix.  many of the posix and libc stuff don't even use system calls, so you can just grab the code right out of your /usr/lib without much hassle
13:03:03 <mc__>  haskell seems like a perfect language for writing an OS to me
13:03:09 <waynemokane> dons: hmm didn't know about the read class... just show.. I'll check it out; thanks
13:03:13 <intoverflow> mc__: I enjoyed it
13:03:43 <mc__> what features did your os have?
13:03:47 <intoverflow> very very few
13:04:06 <intoverflow> it's still something I tweak on from time to time, but grad school doesn't afford much chance for such things
13:04:35 <intoverflow> I got as far as writing an interrupt handler, a driver for the VMWare graphics adapter, mouse/kbd support, and started working on a real scheduler
13:04:50 <intoverflow> definitely a project in its infancy
13:05:19 <dblazakis> intoverflow: my dayjob is embedded systems for high security applications and i've been thinking of ways to move pieces to something less forgiving than C -- wanted to see how to limit/predict the memory usage
13:05:29 <intoverflow> hOp source: http://www.ninj4.net/hOp-2004-06-09.tar
13:05:56 <mc__> intoverflow: sounds amazing
13:06:07 <dblazakis> intoverflow: thanks
13:08:33 <dblazakis> i've seen the hughes paper, anyone know of other starting places for looking at functional languages on memory constrained systems?
13:09:22 <dons> dblazakis: the nhc papers
13:09:41 <dons> it was a 10 year project to run haskell on embedded systems, that was quite succesful
13:09:54 <dons> dblazakis: http://haskell.org/nhc98/papers.html
13:09:54 <lambdabot> Title: Papers about nhc98
13:10:07 <dons> there's other papers out of that work too.
13:10:19 <dblazakis> dons: wow, excellent, thanks!
13:10:44 <dons> we used it on a credit-card sized arm device a few years ago, for example.
13:12:38 <malcster> hi. i'm having some problem installing some packages I downloaded from hackage, I wonder if anyone can help?
13:12:53 <malcster> I get a segmentation fault trying the configure step for Cabal-1.4.0.2
13:13:51 <Botje> a 10-year project? O_o
13:14:43 <malcster> the segmentation fault only occurs if I do ghc --make Setup, as recommended in the README. doing "runghc Setup.hs configure" works without any errors, but then doing "runghc Setup.hs build" tells me to run the configure command
13:15:21 <Heffalump> malcster: what OS?
13:15:25 <malcster> ubuntu
13:16:04 <malcster> another example is filepath-1.1.0.0 - I run configure, then build, and build says I should run configure
13:16:34 <mattam> hehe, if you google "timezone" you get nicely formated code excerpts from the linux kernel.
13:16:47 <olsner> > or []
13:16:48 <lambdabot>   False
13:16:51 <olsner> > and []
13:16:52 <vininim> > unfoldr Just (1,1)
13:16:53 <lambdabot>   True
13:16:54 <lambdabot>   mueval: Prelude.read: no parse
13:17:01 <AStorm> I think I'll have to do AStar myself for Data.Graph
13:17:06 <AStorm> pity it's not in the fgl ;P
13:17:15 <AStorm> *Data.Graph.Inductive
13:17:21 <Heffalump> malcster: that sounds very odd, and I have no idea what might be going on.
13:17:41 <malcster> is it right that the configure step puts a bunch of files into dist/ ?
13:17:45 <AStorm> is there a distinction between a graph out of Nodes and one out of LNodes? (weighted)
13:17:59 <malcster> that folder is always generated but doesn't have anything in
13:18:12 <dons> AStorm: isn't there A* on hackage already?
13:18:30 <AStorm> dons: where? :>
13:18:30 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/astar
13:18:31 <lambdabot> Title: HackageDB: astar-0.1
13:18:36 <AStorm> argh
13:18:40 <AStorm> I suck at searching
13:18:41 <vininim> > unfoldr \ x -> (x,x+1) 1
13:18:42 <dons> hehe
13:18:43 <lambdabot>   mueval: Prelude.read: no parse
13:19:00 <Deewiant> > unfoldr (id &&& succ) 1
13:19:01 <lambdabot>   Couldn't match expected type `Maybe (a, b)'
13:19:06 <Botje> > unfoldr (\x -> Just (x,x+1)) 1
13:19:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:19:53 <Heffalump> how does mueval parse?
13:19:56 <vininim> Botje: yes! =)
13:20:17 <mmorrow> > unfoldr (\(m,n) -> Just (m,(n,m+n))) (0,1)
13:20:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:20:47 <dons> AStorm: if you use Arch Linux, yaourt --aur -S haskell-astar
13:20:55 <AStorm> uhm
13:21:08 <AStorm> this astar doesn't work on Data.Graph.Inductive
13:21:12 <Heffalump> whose bright idea was that tool name?
13:21:30 <AStorm> aStar :: (Ord a, Ord c, Num c) => a -> Set a -> a -> a -> c -> a -> c -> a -> Bool -> a -> Maybe [a]
13:21:34 <dons> Heffalump: yeah. it's the tool for non-binary bundles. for binaries, use 'pacman'
13:21:36 <AStorm> this is *yuck*
13:21:40 <dons> (e..g xmonad, ghc, et al)
13:21:41 <Deewiant> Heffalump: Yet AnOther User Repository Tool
13:21:47 <Heffalump> oh dear.
13:21:54 <mmorrow> haha
13:22:01 <mmorrow> yatnyas
13:22:04 <Heffalump> all you arch users have my sympathy
13:22:09 <dons> heh
13:22:11 <mmorrow> yet another thing named yet another something
13:22:18 <dons> sympathy, and 537 haskell packages.
13:22:30 <mmorrow> a winning combo
13:22:32 <AStorm> dons: so, do you have something nicer that works on DynGraph or a weighted variant? :>
13:22:39 <Heffalump> I have cabal-install (when it doesn't go into infinite loops) and I'm not afraid to use it
13:22:45 <dons> AStorm: the haskell-astar is 'data structure independenty' right?
13:22:52 <dons> so bug Cale about how you parameterise it with a graph
13:22:57 <AStorm> more or less
13:23:13 <AStorm> it needs a functional description of a graph
13:23:27 <AStorm> which sucks
13:24:18 <rwbarton> Why does it suck?  Seems optimal to me :)
13:24:21 <AStorm> so, I'd have to give it some browsing method
13:24:28 <AStorm> of D.G.I
13:25:06 <mmorrow> @type let g = (undefined::(Eq a)=>[(a,[a])]) ; g!a = maybe [] id (lookup a g) in (g!)
13:25:07 <lambdabot> forall a. (Eq a) => a -> [a]
13:25:17 <vininim> > unfoldr (\ (n, acc) -> Just (acc, (n+1, acc*n)) ) (1,1)
13:25:18 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
13:25:29 <vininim> fail =P
13:25:30 <Deewiant> > (id &&& id) 1
13:25:31 <AStorm> mmorrow: looks not too well, but... :>
13:25:31 <lambdabot>   mueval: Prelude.read: no parse
13:25:34 <Deewiant> :-/
13:25:40 <mmorrow> AStorm: :)
13:26:00 <_zenon_> I hoogled for something with this type but found none: [a] -> [(a->a)]  -> [a]
13:26:05 <vininim> > unfoldr (\ (n, acc) -> Just (acc*n, (n+1, acc)) ) (1,1)
13:26:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:26:17 <vininim> *blushes*
13:26:29 <AStorm> _zenon_: well, you mean application or functions, right? :)
13:26:40 <_zenon_> AStorm, yeah, from a list to a list
13:26:41 <Deewiant> > scanl1 (*) [1..]
13:26:41 <rwbarton> @type zipWith (flip ($))
13:26:43 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
13:26:43 <lambdabot> forall a b. [a] -> [a -> b] -> [b]
13:26:52 <FliPPeh> @src <-
13:26:52 <lambdabot> Source not found. Take a stress pill and think things over.
13:26:53 <_zenon_> ah, nice
13:26:56 <AStorm> exactly
13:26:58 <_zenon_> rwbarton, thanks
13:27:03 <AStorm> scanl is what you want
13:27:10 <vininim> > unfoldr (\ (n, acc) -> Just (acc, (n+1, acc*n)) ) (1,2)
13:27:11 <lambdabot>   [2,2,4,12,48,240,1440,10080,80640,725760,7257600,79833600,958003200,1245404...
13:27:20 <dons> AStorm: like fmap or so?
13:27:26 <AStorm> that too
13:27:44 <FliPPeh> If I use "<-" on something that returns "IO String", will it be converted to a pure string?
13:28:05 <dons> yep.
13:28:10 <FliPPeh> Sweet
13:28:12 <FliPPeh> Now I got it
13:28:15 <rwbarton> So why is Haddock getting the type of aStar wrong?
13:28:17 <AStorm> obviously, you're still in monad ;P
13:28:18 <vininim> > unfoldr (\ (n, acc) -> Just (acc, (n+1, acc*(n+1))) ) (1,1)
13:28:19 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
13:28:20 <dons> it runs the IO action.
13:28:24 <AStorm> yes
13:28:34 <AStorm> this is all sequential code
13:28:46 <mmorrow> rwbarton: i've noticed that haddock2 sometimes drops parens in (eg) a -> (a -> b) -> b
13:28:54 <mmorrow> to a -> a -> b -> b
13:28:56 <rwbarton> mmorrow: Yeah, that's exactly the case here
13:29:01 <mmorrow> grr
13:29:01 <AStorm> mmorrow: yes, horrible
13:29:04 <newsham> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
13:29:07 <lambdabot>  Defined.
13:29:10 <malcster> is it possible that these packages aren't installing because I need a newer version of GHC? I have 6.8.2 ...
13:29:11 <AStorm> someone should fix it
13:29:50 <newsham> > unfoldUntil True (\a b -> (a+1, b*(a+1))
13:29:51 <lambdabot>   mueval: Prelude.read: no parse
13:29:54 <_zenon_> @pf (zipWith (flip ($)))
13:29:54 <lambdabot> Maybe you meant: bf pl
13:29:58 <newsham> > unfoldUntil True (\a b -> (a+1, b*(a+1)))
13:29:59 <lambdabot>   Couldn't match expected type `b -> Bool'
13:30:00 <_zenon_> @pl (zipWith (flip ($)))
13:30:00 <lambdabot> zipWith (flip id)
13:30:28 <olsner> @pl \f -> f &&& f
13:30:28 <lambdabot> join (&&&)
13:38:53 <FliPPeh> main =
13:38:53 <FliPPeh>  do name <- readLn
13:38:53 <FliPPeh>     putStrLn name
13:38:59 <FliPPeh> user error (Prelude.readIO: no parse)
13:39:00 <FliPPeh> :(
13:39:08 <ddarius> AStorm: Pass in (Set.fromList . neighbors yourGraph).  That doesn't seem too hard.
13:39:12 <Kabelludo_> 11
13:39:35 <FliPPeh> Oh
13:39:40 <FliPPeh> It's getLine
13:39:42 <FliPPeh> @src readLn
13:39:42 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
13:39:48 <FliPPeh> @src getLine
13:39:48 <lambdabot> getLine = hGetLine stdin
13:39:59 <AStorm> ddarius: hmmmm :)
13:40:04 <_zenon_> FliPPeh, readLn assumed ""
13:40:08 <FliPPeh> :t readLn
13:40:10 <lambdabot> forall a. (Read a) => IO a
13:40:14 <FliPPeh> :/
13:40:48 <_zenon_> FliPPeh, do {readLn >>= putStrLn} and writing the input as "input" outputs input
13:40:52 <AStorm> ddarius: also, it uses function for the distance
13:41:23 <AStorm> this means I'll have to abuse DynGraph out of LNodes a bit :)
13:41:41 <AStorm> actually, LEdges
13:41:47 <AStorm> as I have weighted edges
13:43:06 <FliPPeh> Can I have multiple case options on one line?
13:43:17 <FliPPeh> 1, 2 -> doThis
13:43:25 <FliPPeh> 4,5,6 -> doThat
13:43:36 <Heffalump> nope
13:43:38 <_zenon_> ah.... hm I believe not.
13:43:42 <Heffalump> bit annoying occasionally
13:43:44 <FliPPeh> Yuck
13:44:06 <FliPPeh> Pretty repeative work
13:44:13 <Heffalump> if you really have numbers, you can use a guard instead
13:44:20 <FliPPeh> Strings :(
13:44:23 <_zenon_> yeah, that's advisable
13:44:32 <Heffalump> well, anything where equality comparisons work
13:44:34 <Heffalump> or ordering
13:44:41 <AStorm> ddarius: so, it will be getWeight :: Num a => LEdge a -> a
13:44:44 <Heffalump> case foo of _ | foo == "bar" || foo == "baz" -> ...
13:44:51 <_zenon_> FliPPeh, what do you case on ?
13:44:53 <FliPPeh> Currently doing one of the exercises from the haskell wikibook
13:45:01 <Heffalump> foo `elem` ["bar", "baz"] is shorter
13:45:36 <FliPPeh> "Write a program that asks the user for his or her name. If the name is one of Simon, John or Phil, tell the user that you think Haskell is a great programming language. If the name is Koen, tell them that you think debugging Haskell is fun (Koen Classen is one of the people who works on Haskell debugging); otherwise, tell the user that you don't know who he or she is."
13:45:36 <FliPPeh> :d
13:45:41 <bos> @seen ketil
13:45:42 <lambdabot> ketil is in #haskell. I last heard ketil speak 12m 22s ago.
13:45:56 <_zenon_> FliPPeh, yeah, you should go for the elem approach there
13:46:26 <_zenon_> or
13:46:36 <Heffalump> you can also use a where clause to abstract out the repeated right hand side.
13:47:17 <Heffalump> case foo of "Simon" -> great ; "John" -> great ; "Phil" -> great ; "Koen" -> debugging ; _ -> noidea where great = ... ; debugging = ... ; noidea = ....
13:47:20 <Cale> AStorm: Haddock has a bug which makes the type signature incorrect
13:47:24 <Heffalump> (with some more line breaks etc)
13:47:37 <AStorm> Cale: I noticed
13:47:38 <AStorm> :)
13:47:45 <Cale> AStorm: http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html -- you can see the correct documentation here :)
13:47:48 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
13:47:48 <AStorm> fortunately, the docs are ok
13:47:52 <AStorm> Cale: yes :)
13:48:12 <Cale> AStorm: So did you work out how to use it?
13:48:18 <AStorm> not yet
13:48:23 <AStorm> need a distance function
13:48:44 <Cale> It should be reasonably easy to use with any graph library. Ah, you can use the constant 1 function if you don't already have anything decent.
13:48:49 <rwbarton> Cale: Maybe the first two arguments should be replaced with a -> Set (a, c)
13:48:53 <FliPPeh> Wow
13:48:54 <FliPPeh> I did it
13:49:09 <Cale> rwbarton: That's true, they could be.
13:49:27 <rwbarton> Cale: e.g. if you have a list-of-edges representation, computing the distance function would be expensive
13:49:41 <AStorm> rwbarton: no no
13:49:48 <olsner> @pl \b m -> b >>= \b -> when b m
13:49:48 <lambdabot> (. flip when) . (>>=)
13:49:50 <FliPPeh> "case name `elem` ["Simon", "John", "Phil"] of" -> True: print, otherwise: case name == "Koen" -> True: print, otherwise: unknown
13:49:52 <AStorm> it's just the distance between two guaranteed direct neighbors
13:50:09 <FliPPeh> Although I should have done the last one using IF
13:50:18 <rwbarton> AStorm: Yes
13:50:51 <rwbarton> AStorm: You knew the distance when you passed in the first argument, but threw it away.  Now you have to find it again to compute the second argument
13:50:51 <_zenon_> FliPPeh, you could have solved it with a tuple also (not so nice) .. (elem n ["Phil","Simon","John"),n == "Koen")
13:50:52 <Cale> AStorm: I think he is assuming that... it's just that if you had a list of edges representation where the edges carry the weight, you have to go searching through that for the appropriate pair every time the distance is needed. However, aStar does internally memoise calls to the distance function anyway.
13:51:04 <Cale> (so it's not as bad as it might be)
13:51:21 <FliPPeh> That's a bit overkill :(
13:51:29 <_zenon_> FliPPeh, the tuple with thus take three values (F,F) (F,T) or (T,F)
13:51:48 <_zenon_> yeah, and I also forgot a ']' there :)
13:52:13 <AStorm> Cale: no no, I could grab the context from one node to another somehow
13:52:18 <_zenon_> FliPPeh, any way, nice for you! I hope you enjoy Haskell
13:52:24 <AStorm> out of the graph, then use out'
13:52:48 <FliPPeh> I do, it's just hard to change from imperative to functional
13:52:50 <Cale> AStorm: Oh, don't mess around with contexts directly for that...
13:53:18 <FliPPeh> I think the theft of my "return" functionality will hurt in some ways
13:53:21 <FliPPeh> :[
13:53:28 <LeoD> not.
13:53:35 <sadache> i am searching for a function []
13:53:35 <Cale> AStorm: The arc (a,b) might be in either the context for a or the context for b, so it's inconvenient to look at the graph that way.
13:53:35 <AStorm> Cale: trick is, either I do, or I lose a lot of speed
13:53:46 <sadache> String -> Maybe Int
13:54:02 <AStorm> well, my graph is directed
13:54:09 <_zenon_> sadache, for parsing?
13:54:13 <sadache> yes
13:54:22 <Cale> AStorm: Right, but any arc might be in one of two contexts in the structure.
13:54:23 <sadache> for parsing
13:54:27 <AStorm> yes
13:54:41 <AStorm> but there's a difference between outbound and inbound nodes
13:54:50 <AStorm> also, I could just use out on the graph
13:54:52 <_zenon_> sadache, I don't know any directly, but look here http://haskell.org/hoogle/?hoogle=String+-%3E+Maybe+Int
13:54:53 <lambdabot> Title: String -> Maybe Int - Hoogle
13:55:04 <_zenon_> sadache, you can search hoogle by type signatures
13:55:09 <ddarius> \here there -> calcDistance . fromJust . find (there==) $ out yourGraph here
13:55:10 <sadache> ok
13:55:11 <AStorm> sadache: you probably want read?
13:55:21 <AStorm> ddarius: something :>
13:55:25 <Cale> AStorm: Just use out, and find the minimal edge in the list returned.
13:55:41 <_zenon_> @src read
13:55:41 <lambdabot> read s = either error id (readEither s)
13:55:43 <AStorm> not minimal
13:55:48 <AStorm> the exact one, which ddarius did :)
13:56:18 <Cale> oh, I mean, the minimal one among those which go to the right place :)
13:56:39 <AStorm> well, right
13:56:47 <AStorm> so that goes
13:57:24 <AStorm> \here there -> calcDistance $ min $ fromJust . find (there==) $ out yourGraph here
13:57:27 <AStorm> or similar
13:57:38 <AStorm> no, that won't work
13:57:42 <AStorm> LEdges are not comparable
13:58:13 <Cale> They are actually
13:58:21 <Cale> They're just triples.
13:58:38 <AStorm> yes
13:58:48 <AStorm> but nodes are not comparable
13:58:59 <AStorm> (what would that mean anyway ;P)
13:59:03 <Cale> Data.Graph.Inductive is strangely designed.
13:59:13 <Cale> AStorm: What would what mean?
13:59:13 <AStorm> no, it's actually nice
13:59:16 <AStorm> dynamic graph
13:59:25 <AStorm> Cale: comparing nodes ;P
13:59:35 <ddarius> Nodes are just Int
13:59:41 <AStorm> no
13:59:48 <Cale> It's not usually as nice as just storing a graph as a  Map v (Set v)
14:00:00 <AStorm> I need LNodes because I want to read their data from a database
14:00:18 <AStorm> I can reimplement the Node and be all set
14:00:41 <AStorm> otherwise, I'd have to reimplement Map in a horrible way
14:00:45 <Cale> oh?
14:01:01 <ddarius> AStorm: You can just use lab to get the label from the unlabelled Node and compare Nodes.
14:01:09 <Cale> Isn't a node labelling just an additional function v -> c ?
14:01:40 <Cale> So, Map v (Set v, c), say?
14:01:54 <AStorm> no, Node is LNode ()
14:02:03 <AStorm> LNode is the basic type
14:02:16 <Cale> (I'm just saying, if one was using a Map implementation of graphs)
14:02:48 <AStorm> uh, wait
14:02:50 <ddarius> According to the documentation here: http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graph.html  type Node = Int; type LNode a = (Node, a)
14:02:53 <lambdabot> Title: Data.Graph.Inductive.Graph, http://tinyurl.com/5hzued
14:02:56 <AStorm> LNode is (Node. a)
14:03:00 <AStorm> where Node is an int
14:03:03 <int-e> this is cute: (installing binary on ghc head) Configuring binary-0.4.3... Setup.lhs: At least the following dependencies are missing: base >=2.0 && <2.2 && >=3.0 && >=2.0. What it means is that I need to install bytestring first *eg*.
14:03:08 <AStorm> I'd have to get node to something else
14:03:22 <AStorm> why the hell would Node be an Int and not a Num
14:03:30 <AStorm> or actually anything comparable
14:03:35 <AStorm> duh
14:03:36 <ddarius> lab :: Graph gr a b => gr a b -> Node -> Maybe a
14:03:53 <Cale> AStorm: Because Data.Graph.Inductive is strange.
14:04:05 <AStorm> nah, it would work w/o type Node = Int
14:04:26 <AStorm> instead, could make Node into a class
14:04:50 <olsner> it feels like you're not supposed to actually inspect the Node values in a graph, but rather use them as opaque id's
14:04:57 <ddarius> olsner: Indeed.
14:05:01 <AStorm> yes
14:05:09 <ddarius> I don't see any benefit to having Node be more general that Int
14:05:21 <AStorm> so currently, I'd have to rewrite the Graph itself
14:05:36 <AStorm> if it's not a class right now
14:05:51 <Cale> Well, it might mean that you need to thread a unique id supply through whatever it is that's building your graph.
14:05:57 <AStorm> yes. o,[;e,emt a Graph
14:06:02 <AStorm> *implement
14:06:06 <ddarius> AStorm: I really don't see why you think Data.Graph.Inductive can't be adapted to use AStar
14:06:19 <AStorm> no, well, it is
14:06:20 <ddarius> s/to use/to be used by
14:06:29 <AStorm> but it has to be fast too ;P
14:07:06 <Cale> I'm not sure that my AStar implementation is all *that* fast to begin with, but it's not totally unreasonable, afaict. I haven't tested it extensively.
14:07:10 <AStorm> real trick will be writing an implementation of the Graph to walk a relational db
14:07:31 <AStorm> so, I have to limit node walks to minimum
14:07:42 <AStorm> be as lazy as possible
14:07:45 <Cale> AStorm: If the DB is a pure value, you could simply not construct the graph at all.
14:07:59 <ddarius> Unless you graph has high out degree, so far the functions I've listed should be reasonably efficient.  I don't remember the asymptotic complexities of the Data.Graph.Inductive operations off hand.
14:08:00 <AStorm> Cale: no, I need to store the label of the node
14:08:15 <AStorm> ddarius: it has low out degree
14:08:16 <Cale> AStorm: what?
14:08:18 <AStorm> usually, 1 or 2
14:08:34 <AStorm> Cale: wait, you have a point
14:08:45 <AStorm> I just need the uuid on the node
14:08:47 <mmorrow> what about a Map Node MyLabelType
14:08:49 <mmorrow> yeah
14:08:52 <AStorm> what is stored in the DB is the edges
14:08:56 <mmorrow> in fact, IntMap MyLabel
14:08:59 <mmorrow> faster
14:09:06 <mmorrow> or even an array
14:09:14 <mmorrow> (if the graph is static)
14:09:15 <BMeph`> Aw, schucks, I got back on, just after conal left. Oh, well. :)
14:09:16 <AStorm> Cale: so, a->Set a might work really well here directly
14:09:19 <AStorm> no need for Graph
14:09:25 <Cale> AStorm: AStar takes functions which define your graph, you can use functions which effectively compute the graph locally from the database.
14:09:35 <mmorrow> ah, nice
14:09:40 <Cale> AStorm: So that you might not even end up building the whole graph.
14:09:44 <AStorm> mhm
14:09:54 <Cale> However, it's not (currently) monadic
14:09:57 <mmorrow> assuming you can get that info without IO
14:09:58 <mmorrow> yeah
14:10:02 <AStorm> Cale: uhoh
14:10:18 <AStorm> but I can run the monad in that function
14:10:32 <Cale> So if your database requires IO, then you're just slightly screwed. It would not be that hard to come up with a monadic generalisation of aStar though.
14:10:42 <Cale> You can't run the IO monad.
14:10:59 <AStorm> well... it was actually to use MySQL
14:11:01 <AStorm> ;P
14:11:16 <mmorrow> you could modify Cale's function though (i'm not sure how hard that'd be)
14:11:25 <AStorm> moderately
14:12:16 <Cale> It shouldn't be too hard. I could probably do it.
14:12:47 <ddarius> I'd imagine it would be mostly mechanical plus a few decisions to make
14:17:19 <bos> @seen dons
14:17:19 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 7m 42s ago.
14:18:17 <bos> @seen andyjgill
14:18:17 <lambdabot> Last time I saw andyjgill was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07,
14:18:17 <lambdabot>  #haskell-overflow and #haskell-soc 1d 17h 5m 53s ago, and .
14:18:43 <dons> bos.
14:20:31 <bos> dons: wondered if there's any chance you might know what time zones PADL thinks "september 8" might involve.
14:20:57 <bos> i sent email to andy and terrance, but sought the immediate gratification, too.
14:21:11 <dons> hmm. usually it is 'samoa'
14:21:19 <dons> i.e. last possible time. but yes, andy should say.
14:23:03 <bos> heh.
14:23:11 <bos> ok, thanks.
14:23:50 <mapreduce> dons: I've been superficially helping jonp (##csharp, committer on mono) with a port of Data.List to C#.  So I already have some library familiarity, just, well, not much.
14:24:16 <mapreduce> I just wish he wouldn't calling folds Aggregate.
14:24:21 <mapreduce> s/ing//
14:24:41 <Wild_Cat> "Aggregate"?
14:25:00 <mapreduce> Aggregate is what the linq designers decided on as a general term for folds and reduces.
14:25:02 <dons> urgh.
14:25:16 <Wild_Cat> yay. Like we needed yet another word for that concept.
14:25:18 <mapreduce> new[]{1,2,3}.Aggregate((x, y) => x+y)
14:25:32 <dons> hehe.
14:25:40 <opqdonut> citations for functional datastructures? okasaki, zipper paper, banana&lens paper?
14:25:56 <dons> so that's foldl1 ?
14:26:04 <mapreduce> Regardless of terminology, though, the linq stuff is pretty good in terms of being lazy.
14:26:05 <Wild_Cat> mapreduce: is that actual C# syntax? My, it's come a long way.
14:26:06 <dons> > foldl1 (+) [1,2,3]
14:26:07 <opqdonut> references must be the word i was looking for
14:26:07 <lambdabot>   6
14:26:11 <mapreduce> Wild_Cat: It is.
14:26:22 <mapreduce> dons: Yes.
14:26:28 <dons> functional programming is a meme :)
14:26:44 <skorpan> forced meme if anything
14:26:45 <opqdonut> what does that make python?
14:26:49 <dons> actually, its just because that's where all the fun research in languages happened over the last 20 years, so there was no where else to look for new features.
14:26:59 <opqdonut> mhmm
14:27:17 <dons> and people love new features. it drives the economy.
14:27:21 <mapreduce> Wild_Cat: I'm glad I didn't learn any C# until this year. :)
14:27:39 <Wild_Cat> actually, I wouldn't have used "=>". "->" looks less like a botched comparison operator.
14:27:58 <Wild_Cat> mapreduce: well, last time I had a look at it, it was Java with language support for properties.
14:28:01 <mapreduce> -> already has a meaning to C-deranged programmers.
14:28:09 <mmorrow> > ord (C# (chr# 0#))
14:28:10 <lambdabot>   mueval: Prelude.read: no parse
14:28:12 <Wild_Cat> oh, good point.
14:28:46 <qwr> mapreduce: C# supports C pointers?
14:28:48 * Cale uploads a new version of the astar package to hackage.
14:29:06 <mmorrow> Cale: nice
14:29:07 <TomMD> @hackage astar
14:29:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/astar
14:29:07 <mapreduce> I once couldn't remember in an interview whether -> was a C++ feature or a C one, so I wrote (*x).y instead of x->y.. and the interviewer didn't understand it.
14:29:13 <Cale> AStorm: I totally have not tested this at all. So you can be my guinea pig :)
14:29:25 <TomMD> Right, for my virtual mice!
14:29:32 <qwr> mapreduce: lol.
14:29:39 <mapreduce> qwr: It has 'unsafe' sections where you can do pointer arithmetic.  But -> itself is not there.
14:30:04 <Cale> oh, crap...
14:30:08 <Wild_Cat> so now C# also supports anonymous functions... Would that mean it has acquired... :gasp: first-class functions?
14:30:32 <opqdonut> we're in the age of first-class-everything
14:30:32 <mapreduce> Wild_Cat: Yes, though arguably those have been there ever since delegates have.
14:30:34 <opqdonut> IMO
14:30:38 <Cale> heh, don't get it yet :)
14:30:39 <mapreduce> Which I think was C# 1.0.
14:31:00 <Wild_Cat> opqdonut: I agree. Java and the Enterprise crew don't, however :p
14:31:09 <opqdonut> :)
14:31:12 <mapreduce> Wild_Cat: Func<int, int> f = x => x * 10;
14:31:16 <Cale> I went to all the trouble of writing a monadic generalisation, and then didn't add it to the export list.
14:31:31 <Cale> There we go...
14:31:31 <opqdonut> mapreduce: heh, that's almost exactly the scala syntax too
14:31:35 <mapreduce> Wild_Cat: Yes, Java people don't "see a need" for functions.
14:31:35 <AStorm> Cale: harhar
14:31:45 <AStorm> at worst I'll just rewrite it
14:31:58 * Cale uploads *another* one.
14:32:01 <Cale> This should be okay :)
14:32:05 <Cale> http://cale.yi.org/AStar/dist/doc/html/astar/Data-Graph-AStar.html
14:32:07 <lambdabot> Title: Data.Graph.AStar, http://tinyurl.com/69kxsb
14:32:26 <TomMD> @quote Java
14:32:26 <lambdabot> Korollary says: Can't you pretend that you've never heard of any of this and keep hacking happy java?
14:32:27 <mapreduce> opqdonut: val f: Int => Int = x => x * 10
14:32:29 <mmorrow> Cale: this isn't a darcs repo? http://cale.yi.org/AStar/
14:32:30 <lambdabot> Title: Index of /AStar
14:32:41 <Wild_Cat> mapreduce: Java *designers*, anyway, those same people whose C++-infected minds have been trying to persuade us for years that getters/setters, not properties, are the way to go. Back when I was a Java user, I cursed them every single minute.
14:32:41 <Cale> mmorrow: No it is not.
14:32:58 <opqdonut> mapreduce: yeah but the function objects (or something) have types like Function<Int, Int> right?
14:33:06 <dons> http://aur.archlinux.org/packages.php?ID=18574
14:33:07 <lambdabot> Title: AUR (en) - haskell-astar
14:33:11 <dons> :)
14:33:14 <mmorrow> Cale: so i should just get the hackage version, and not hold out for a darcs repo? ;)
14:33:23 <Cale> mmorrow: right. I don't have a darcs repo.
14:33:28 <mmorrow> Cale: cool
14:33:29 <dons> use the distro package :)
14:33:37 <Cale> dons: hehe
14:33:40 <mapreduce> opqdonut: They have any (delegate) type you give them.  Func is just a sensible one.
14:34:09 <Cale> dons: That's scary. My completely untested Haskell code is in a distro already!
14:34:10 <mapreduce> It's a shame Func isn't the default, then you could use var f = x => x * 10 or similar.
14:35:28 <mapreduce> Wild_Cat: There is a tendency among the better Java programmers towards immutable objects.  I think they're a few years away from generally accepting that their best code is functional though.
14:36:01 <mapreduce> Wild_Cat: I think lambdas in the language will change that, which is why I support the BGGA proposal for closures in Java.
14:36:13 <mapreduce> s/change/accelerate/
14:36:14 <Wild_Cat> mapreduce: the language has dreadful support for functional-style programming, though. It's really swimming against the current.
14:36:23 <mapreduce> Wild_Cat: Yes.
14:37:03 <Wild_Cat> and seeing that its evolution is slower than continental drift, I think it's not really worth bothering with it anymore.
14:37:21 <mapreduce> Sadly, Java jobs are the easiest for me to get right now.
14:37:52 <Wild_Cat> for anyone, really. You wouldn't believe how relieved I was last year when people came to me for the Python job I currently hold ^^
14:38:27 <mapreduce> At least my current job steers away from the enterprise stuff.
14:38:49 <waynemokane> dons: would you be so kind as to look at my paste and let me know what I'm doing wrong with Text.JSON?  http://hpaste.org/10188
14:38:54 <waynemokane> specific problem is line 10...       Couldn't match expected type `JSString'
14:38:54 <waynemokane>            against inferred type `JSValue'
14:38:54 <waynemokane>     In the pattern: JSString "BUY"
14:38:58 <pfo> what's the syntax to add tail someList to the head someList ?
14:39:04 <Wild_Cat> Java job without Enterprise crap? It's not that bad then :D
14:39:07 <mapreduce> Software for CCTV control and viewing.
14:39:32 <mmorrow> Cale: i'm not familiar with InkScape. Can these http://cale.yi.org/images/b/b3/Folds.svg be produced in an automated way, or is it essentially by hand?
14:43:24 <pfo> why can't i simply do tail [1..10] ++ head [1..10] ?
14:43:56 <mmorrow> @type head [1..10]
14:43:57 <lambdabot> forall t. (Enum t, Num t) => t
14:44:01 <mmorrow> @type tail [1..10]
14:44:03 <lambdabot> forall t. (Enum t, Num t) => [t]
14:44:05 <mmorrow> @type (++)
14:44:06 <lambdabot> forall a. [a] -> [a] -> [a]
14:44:21 <mmorrow> > tail [1..10] ++ [head [1..10]]
14:44:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,1]
14:44:58 <pfo> oh, nice. thx!
14:45:26 <mmorrow> > (\n -> take (length xs) . drop n . cycle) 1 [1..10]
14:45:27 <lambdabot>   mueval: Prelude.read: no parse
14:45:38 <mmorrow> > (\n xs -> take (length xs) . drop n . cycle $ xs) 1 [1..10]
14:45:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,1]
14:45:45 <mmorrow> > (\n xs -> take (length xs) . drop n . cycle $ xs) 7 [1..10]
14:45:46 <lambdabot>   [8,9,10,1,2,3,4,5,6,7]
14:47:29 <purestorm> What's the easiest way to convert an Integer into a char of bytes, the way it would look like if it was an "unsigned" in C, for example? I need this because I get the result of a SHA1-hashing as an Integer and need a hex representation.
14:48:10 <mmorrow> an /Integer/ or an Int(32,64)?
14:48:44 <mmorrow> because with Integer, you're slightly screwed
14:48:48 <purestorm> Integer http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/Data-Digest-SHA1.html#v:hash
14:48:53 <purestorm> Actually, it's a "Word160"
14:48:54 <lambdabot> Title: Data.Digest.SHA1, http://tinyurl.com/5svn9y
14:49:10 <purestorm> So with Integer I would be down to something with unfoldr?
14:49:22 <rwbarton> > printf "0x%x" (10^50) :: String -- is this what you mean?
14:49:24 <lambdabot>   "0x446c3b15f9926687d2c40534fdb564000000000000"
14:49:40 <mmorrow> purestorm: ah, ok. you'd want to pick apart the Word160, then convert each Word32 to [Word8]
14:50:06 <pfo> is there a good reason for supplying the type information on my own (ie in function definition) vs letting the compiler infer it?
14:50:07 <mmorrow> oh, rwbarton may have nailed it
14:50:18 <purestorm> ah, that looks awesome, thanks
14:50:18 <mmorrow> (if that's what you want)
14:50:40 <rwbarton> pfo: Yes, at least two good reasons:
14:50:54 <mmorrow> @type 42
14:50:55 <lambdabot> forall t. (Num t) => t
14:50:59 <mmorrow> ugh
14:51:14 <mmorrow> usually it default to Integer
14:51:18 <rwbarton> pfo: (1) You'll get better error messages when you have bugs elsewhere, because the compiler will know whether the usage or the definition of the function is wrong
14:51:29 <rwbarton> pfo: (2) They serve as documentation for humans reading the code
14:51:36 <mmorrow> (2) is huge
14:51:45 <pfo> rwbarton: the later makes to most sense to me.
14:51:48 <pfo> thx
14:51:57 <mmorrow> plus, without typesigs, the function won't show up in the haddock docs
14:52:03 <purestorm> hrm, on second though
14:52:06 <purestorm> t
14:52:16 <purestorm> ah, nvm
14:52:26 <ivanm> (1) is important as well, especially if you're writing down the type of your function before attempting to write it (as a type of check)
14:52:50 <rwbarton> pfo: ((3) Sometimes the compiler will infer a type that's more general than you intended, and mistakes using it elsewhere will give you a really confusing error message)
14:52:52 <mmorrow> purestorm: if you want [Word8], just do  Word160 -> [Word32] -> [Word8]
14:53:02 <purestorm> Yeah, that sounds good.
14:53:16 <dons> ?users
14:53:16 <lambdabot> Maximum users seen in #haskell: 497, currently: 460 (92.6%), active: 19 (4.1%)
14:53:21 <pfo> rwbarton: never tought of that, but i makes perfectly sense.
14:53:33 <rwbarton> (3) is more rare though.
14:53:35 <olsner> woo, getting close to 500
14:54:19 <dons> we've hit 500 a couple of times, actually.
14:54:21 <dons> lambdabot just forgot.
14:58:07 <mmorrow> pfo: yeah, what ivanm said. i usually always write the typesig before i write the function
14:58:12 <pfo> is there a list comprehension expression to reverse a given list?
14:58:25 <mmorrow> hmm
14:58:36 <mmorrow> > foldl (flip (:)) [] [0..9]
14:58:37 <lambdabot>   [9,8,7,6,5,4,3,2,1,0]
14:59:12 <pfo> without fold, flip, etc. :)
14:59:21 <mmorrow> heh, i'm trying to think
14:59:36 <mmorrow> i dunno
14:59:52 <drigz> pfo: are you allowed any other functions?
14:59:58 <dons> pfo, it's a fold, so not really.
15:00:17 <olsner> argh, parsec gets me wildly complicated grammars with loads of errors when I try to parse line-based file formats
15:00:31 <dons> list comprehensions are filters, maps and concatMaps
15:00:40 <pfo> i'm allowed to use anything, but it's just for myself. i'm trying to implement basic list functions on my own to learn haskell.
15:01:06 <mmorrow> @src reverse
15:01:06 <lambdabot> reverse = foldl (flip (:)) []
15:01:24 <pfo> too elegant :P
15:01:27 <mmorrow> haha
15:01:34 <AStorm> pfo: then think about it
15:01:47 <AStorm> it's not a list comprehension, but a recursive function
15:01:56 <AStorm> map is a list comprehension
15:02:35 <dons> Cale, we have haskell98 package, why not haskell1.3 ?
15:02:40 <dons> or haskell-b compat packages.
15:02:52 <dons> for those who want to work in ye olde style
15:03:09 <dons> haskell-gofer
15:03:26 <bos> i still have old gofer source files sitting around.
15:03:26 <dons> haskell-ccprelude
15:03:37 <mmorrow> > let map f = foldl (flip (:)) [] . foldl (\xs x -> f x : xs) [] in map (*2) [1..9]
15:03:38 <lambdabot>   [2,4,6,8,10,12,14,16,18]
15:03:53 <dons> http://www.cse.unsw.edu.au/~dons/data/cc.prelude
15:04:09 <drigz> > let pairs = [(y,x) | (x:y:_) <- tails [0..9]] ; follow x = x : follow (head [y | (x',y) <- pairs, x == x']) in follow 9
15:04:11 <lambdabot>   mueval: Prelude.read: no parse
15:04:11 <lambdabot>  mueval: [9,8,7,6,5,4,3,2,1,0,*** Exception:...
15:05:00 <drigz> part way there, but it's really just an obfuscation of writing it properly
15:05:15 <drigz> and it doesn't work for non-unique lists
15:05:26 <bos> it's a huge bummer how much slower GHC is on 64-bit hosts than on 32-bit.
15:05:48 <mmorrow> bos: wow, why is that?
15:05:50 <bos> i installed a 32-bit chroot so i could get decent performance.
15:05:52 <dons> slower in what way?
15:06:03 <dons> produces slower programs?
15:06:13 <bos> it's slower, and produces slower programs.
15:06:26 * dons had the opposite experience this week at work, battling to get decent 32 bit code generated
15:06:31 <dons> the gcc versions make a big difference.
15:06:56 <dons> some simulator code was 6x slower on 32 bit, because the inner loops were 30 instructions instead of 5
15:06:58 <bos> i find that most programs run just over half the speed.
15:07:19 <dons> i'm using gcc 4.3.1, fwiw, which seems to do a lot better on 64 bit than older ones.
15:07:39 <dons> but in general, isn't that what simonmar says, bos?
15:07:44 <dons> just due to extra memory traffic/
15:08:04 <bos> yes, due to the STG-machine overhead.
15:08:05 <sbahra> > head [ x | x <- [1 ..], log x >= 10]
15:08:07 <lambdabot>   22027.0
15:08:27 <dons> so while there are isolated big jumps, thanks to say, 64 bit ints, and better register use, if you don't need any hardware support that 32 bit can't provide, you'd see a slowdown.
15:08:51 <bos> right. and a lot of real programs that do lots of heap allocation are affected.
15:09:03 <dons> yeah.
15:09:13 <dons> i remember a thread about this from simon after he got his adm64.
15:09:15 <bos> haskell code that has allocation-free inner loops that dominate performance is a rare beastie
15:09:41 <dons> yup
15:10:00 <bos> and shaking the allocations out of code that you'd like to have a modular structure is really hard.
15:10:19 <newsham> bos: how come not  bo`s   as a nick?
15:10:38 <bos> newsham: unixes choke on it as a username.
15:13:21 <pfo> can someone tell me what's wrong with this http://hpaste.org/10190?lines=true? the error is ' cannot match expected type [a] against inferred type Maybe [a1]' ?
15:16:55 <TomMD> pfo: Your last "head [xs]" should just be "head xs"
15:16:59 <drigz> pfo: you can use not instead of == False
15:17:25 <mmorrow> pfo: (also, doing reverse that way is O(n^2) instead of O(n))
15:17:55 <mmorrow> since (\x xs -> xs ++ [x]) is O(n)
15:18:06 <drigz> pfo: sorry, wrong paste :s
15:18:06 <pfo> it's slow i know.
15:18:07 <rwbarton> pfo: specifically what that error message is telling you is you've written  (term of type Maybe [a]) ++ (term of type [a])  which is no good
15:18:48 <mmorrow> and Maybe a embeds in [a] by  Nothing -> [] , Just a -> [a]
15:18:49 <pfo> rwbarton: i thought that's the reason to use `Maybe'
15:19:04 <pfo> ok.
15:19:10 --- mode: ChanServ set +o dons
15:19:14 --- topic: set to '["Progress is beautiful", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
15:19:17 --- mode: ChanServ set -o dons
15:19:32 <TomMD> What progress do you refer to, dons?
15:19:44 <olsner> hmm, so, to use Data.Graph.Inductive, I need to assign unique Node id's myself? that's boring!
15:19:46 <TomMD> RWH?  hackage server?  DPH?  Open type functions? ;-)
15:19:58 <pfo> i just started today reading "real world haskell" and got addicted to haskell. so it's my first day and i barely scratched the surface of the basic stuff of haskell but already like it very much.
15:19:59 <dons> What have you got? :)
15:20:06 <dons> pfo, welcome!
15:20:10 <mmorrow> pfo: awesome!
15:20:45 <TomMD> pfo: Cafeful! If you end up liking it too much you are left with no choice but to get a PhD.
15:20:53 <pfo> :P
15:20:55 <olsner> hey, you have direct access to the authors of that book right here! isn't that cool? :P
15:21:00 <pfo> nothing against that.
15:21:08 <rwbarton> pfo: Maybe is usually used when you want to extend a type to include a value that represents some kind of failure.  But reversing a list is always a well-defined operation
15:21:18 <pfo> i can't imagine how one could say that haskell doesn't suite real world problems ...
15:21:35 <ivanm> TomMD: yes, but does it have to be a PhD in functional languages?
15:21:48 <TomMD> pfo: Well, it depends who you talk to.  The lack of control over allocation is the most serious comment I hear.
15:21:59 <TomMD> ivanm: Are you trying to tell me there are other fields?
15:22:08 <pfo> i'm doing EE
15:22:13 <dons> TomMD: so you counter that with examples of the precise, flexible control we get with all the evaluation strategy work.
15:22:31 <mmorrow> pfo: check out Lava
15:22:54 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chalmers-lava2000
15:22:56 <lambdabot> Title: HackageDB: chalmers-lava2000-1.0.1, http://tinyurl.com/65movm
15:23:01 <mmorrow> http://www.cs.chalmers.se/~koen/Lava/
15:23:07 <pfo> i've read about Lava on LtU
15:23:07 <lambdabot> Title: The Lava Homepage
15:23:12 <mmorrow> pfo: cool
15:23:12 <pfo> seems very nice to me.
15:23:28 <mmorrow> definitely
15:23:30 <TomMD> dons: I'm talking more on the line of, if you have a microkernel (ahemL4ahem) and it runs into an oom situation you have a better chance of recovery in 'C' than in Haskell.  Atleast, thats the argument.
15:23:33 <drigz> pfo: speaking as an electronic engineer, it doesn't suit real world problems because my co-workers won't let me write anything in haskell
15:23:36 <drigz> :p
15:23:45 <pfo> drigz: heh
15:23:45 <hackage> Uploaded to hackage: astar 0.2.1
15:23:45 <hackage> Uploaded to hackage: astar 0.2
15:23:56 <ivanm> TomMD: yes... in those other fields, you just _use_ haskell! ;-)
15:23:59 <TomMD> I recall asking Leslie about this and she poked fun at the idea any C kernel recovers well.
15:24:02 <AStorm> Haskell vs GC
15:24:20 <AStorm> we need that region memory managed compiler
15:24:27 <AStorm> what was it called? jhc? nhc?
15:24:30 <TomMD> hackage: Your are late, lazy bot!
15:25:01 <pfo> i just like looking at haskell code
15:25:06 <pfo> it is nice to my eyes
15:25:15 <mmorrow> so nice
15:25:19 <pfo> esp. when compared to java/cpp
15:25:31 <pfo> tight, terse, and expressive at the same time.
15:26:18 <mmorrow> best of both worlds
15:26:21 <dons> TomMD: yeah, recovery. that's an interesting question.
15:26:38 <TomMD> I've been considering devoting some research time looking at it.
15:27:04 <AStorm> pfo: Python ;P
15:27:11 <AStorm> it's because of layout mostly
15:27:21 <AStorm> though some aspects I find disturbing in Haskell
15:27:21 <TomMD> Writing my proposal now, so I've been racking my brain.  What are the hard problems. Which one do I want to kill.  How much of it do I expect I'd answer?  etc etc.
15:27:27 <dons> hmm, what's a good way to strip ansi sequences from a text file?
15:27:29 <AStorm> that is, reliance on operators
15:27:43 <AStorm> like a barb in an otherwise clean language
15:27:43 <dons> on *bsd, cat could do it.
15:27:49 <pfo> layout in haskell is pretty nice and i always like the idea of whitespace beeing semantic
15:27:54 <AStorm> ^^&&.^^
15:27:55 <AStorm> ;P
15:28:02 <b\6> i think less might strip colors.
15:28:02 <AStorm> nice operator, right? ;P
15:28:06 <drigz> dons: as in control codes?
15:28:09 <dons> yeah
15:28:12 <purestorm> How do I split a string at all "."'s?
15:28:14 <dons> ^[[m^O^[]0;rxvt-unicode^G^[[m^O
15:28:25 <TomMD> @hoogle break
15:28:25 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:28:25 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
15:28:25 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:28:26 <AStorm> also, & vs && vs &&&
15:28:27 <purestorm> Is there something simpler than combining iterate and break?
15:28:37 <AStorm> @hoogle (&)
15:28:37 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
15:28:37 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
15:28:37 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
15:28:48 <AStorm> which is yuck
15:29:07 <TomMD> @hoogle (a -> Bool) -> [a] -> [[a]]
15:29:07 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
15:29:08 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
15:29:08 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
15:29:20 <FunctorSalad> @hoogle partition
15:29:20 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
15:29:20 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
15:29:20 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
15:29:22 <AStorm> TomMD: you want partition
15:29:27 <AStorm> yes, that one
15:29:34 <FunctorSalad> seems to be binary too
15:29:36 <AStorm> works on lists too
15:30:38 <FunctorSalad> > breaks (==',') "foo!,fooooo!!"
15:30:39 <lambdabot>   mueval: Prelude.read: no parse
15:31:00 <FunctorSalad> hmm?
15:31:32 <FunctorSalad> > breaks (== ',') "foo,bar"
15:31:33 <lambdabot>   mueval: Prelude.read: no parse
15:31:42 <AStorm> can't do this
15:32:09 <AStorm> > breaks (\x -> x == ',') "foo,bar"
15:32:11 <lambdabot>   mueval: Prelude.read: no parse
15:32:20 <AStorm> hmmhmm
15:32:27 <AStorm> > break (\x -> x == ',') "foo,bar"
15:32:29 <lambdabot>   ("foo",",bar")
15:32:36 <AStorm> let us remember ;P
15:32:47 <purestorm> > Data.List.break (\x -> x == ',') "a,b,c,d"
15:32:48 <lambdabot>   ("a",",b,c,d")
15:32:51 <FunctorSalad> well, he wanted something n-ary
15:32:55 <AStorm> > partition (== ',') "foo,bar"
15:32:57 <lambdabot>   (",","foobar")
15:33:02 <AStorm> ;)
15:33:09 <purestorm> > partition (== '.') "a.b.c.d"
15:33:09 <TomMD> And many people write this as 'chunk' and have complained about it missing.
15:33:10 <lambdabot>   ("...","abcd")
15:33:16 <drigz> @src words
15:33:17 <lambdabot> words s = case dropWhile isSpace s of
15:33:17 <lambdabot>     "" -> []
15:33:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:33:19 <drigz> @src lines
15:33:20 <lambdabot> Source not found. You type like i drive.
15:33:28 <drigz> @hoogle lines
15:33:29 <lambdabot> Prelude lines :: String -> [String]
15:33:29 <lambdabot> Data.List lines :: String -> [String]
15:33:29 <lambdabot> Data.ByteString.Char8 lines :: ByteString -> [ByteString]
15:33:35 <drigz> @source Data.List
15:33:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
15:33:39 <AStorm> yup, something like this
15:33:45 <AStorm> @hoogle Data.List
15:33:46 <lambdabot> module Data.List
15:33:46 <lambdabot> package list-extras
15:33:46 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
15:33:56 <AStorm> lambdabot: no url? gah!
15:34:04 <FunctorSalad> @type words
15:34:05 <lambdabot> String -> [String]
15:34:20 <purestorm> This is so hard. Haskell definitely is not a language with a complete, practical string manipluation library :(
15:34:21 <AStorm> @type split
15:34:22 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:34:28 <AStorm> lol
15:34:55 <FunctorSalad> bogosplit? :D
15:34:55 <drigz> purestorm: the reason these functions don't exist is because there's a degree of uncertainty as to what they should do
15:35:00 <AStorm> so, you have to use break
15:35:08 <drigz> purestorm: see lines vs. words
15:35:13 <AStorm> drigz: [a] -> [[a]]
15:35:27 <AStorm> actually, a -> [a] -> [[a]]
15:35:46 <drigz> AStorm: (a -> Bool) -> [a] -> [[a]] is nicer
15:35:47 <AStorm> or [a] -> a -> [[a]]
15:35:48 <purestorm> Well, Ruby: "1.2.3.4".split('.') => ["1", "2", "3", "4"], similar in Python and Ruby.
15:35:49 <FunctorSalad> @help splitBy
15:35:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:35:52 <AStorm> drigz: indeed
15:35:53 <FunctorSalad> @type splitBy
15:35:55 <lambdabot> Not in scope: `splitBy'
15:36:06 <FunctorSalad> I thought parsec has something
15:36:15 <AStorm> FunctorSalad: no, parsec is entirely different
15:36:16 <FunctorSalad> @type endBy
15:36:17 <lambdabot> Not in scope: `endBy'
15:36:22 <drigz> purestorm: one question is "1..2" => "1","2" or "1","","2"
15:36:31 <AStorm> the latter
15:36:38 <FunctorSalad> AStorm: well you could abuse it for this too
15:37:20 <AStorm> so, it's a recursive variant of break
15:37:39 <AStorm> almost ;)
15:38:15 <FunctorSalad> @type unfold
15:38:17 <lambdabot> Not in scope: `unfold'
15:38:19 <AStorm> unfortunately, break leaves the predicate matching part in the snd of the tuple
15:38:22 <drigz> @type unfoldr
15:38:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:38:38 <purestorm> drigz: Provide two functions.
15:38:47 <AStorm> @unfoldl
15:38:47 <lambdabot> Unknown command, try @list
15:38:54 <AStorm> @type unfoldl
15:38:55 <lambdabot> Not in scope: `unfoldl'
15:38:58 <AStorm> ;P
15:39:02 <purestorm> Honestly, this is not rocket science but with unfoldr it quickly becomes hard :(
15:39:16 <rwbarton> > filter ((/= '.') . head) . groupBy ((==) `on` (== '.')) $ "1...2.3"  -- one of the functions
15:39:17 <lambdabot>   ["1","2","3"]
15:39:21 <FunctorSalad> > unfoldr (Just . (partition (==",")) "foo,bar,baz"
15:39:22 <lambdabot>   mueval: Prelude.read: no parse
15:39:48 <FunctorSalad> @type partition
15:39:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:40:27 <AStorm> doing that pointless will require some flipping
15:40:29 <FunctorSalad> > unfoldr (Just . (partition (==',')) "foo,bar,baz"
15:40:30 <lambdabot>   mueval: Prelude.read: no parse
15:40:34 <pfo> is there a quick method to check how something from the std library is implemented?
15:40:36 <AStorm> both unfoldr and partition want the argument
15:40:51 <AStorm> pfo: yes, haddock
15:40:53 <AStorm> :>
15:40:53 <rwbarton> > map (filter (/= '.')) . groupBy (\a b -> b /= '.') $ "1...2.3"  -- abusive, but another option
15:40:55 <lambdabot>   ["1","","","2","3"]
15:41:05 <AStorm> rwbarton: this sounds slow
15:41:40 <AStorm> two-pass
15:41:53 <AStorm> we need a variant of groupBy that eats the separator already
15:42:05 <FunctorSalad> why doesn't it parse mine?
15:42:06 <rwbarton> If you care enough to be counting passes, you should be using ByteStrings where there is a split already provided
15:42:18 <AStorm> FunctorSalad: because you didn't provide the argument to partition
15:42:26 <AStorm> rwbarton: :D
15:42:33 <AStorm> @hoogle split
15:42:33 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
15:42:33 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
15:42:33 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
15:42:40 <AStorm> har har
15:43:12 <AStorm> still, for other objects, one pass would still be better
15:43:21 <FunctorSalad> AStorm: that's intentional. the first arg to unfoldr is supposed to be a function
15:43:35 <Stinger> FunctorSalad, arent you missing a }
15:43:37 <AStorm> FunctorSalad: but not this kind of function
15:43:52 <AStorm> b->maybe(a, b)
15:43:52 <rwbarton> :t unfoldr (Just . (partition (==','))
15:43:54 <lambdabot> parse error (possibly incorrect indentation)
15:43:58 <Stinger> s/}/)/
15:43:59 <rwbarton> :t unfoldr (Just . (partition (==',')))
15:44:00 <lambdabot> [Char] -> [[Char]]
15:44:07 <AStorm> mhmmh
15:44:16 <Stinger> psst
15:44:21 <Stinger> you need another )
15:44:28 <Stinger> ah good
15:44:32 <FunctorSalad> :o
15:44:36 <AStorm> > unfoldr (Just . (partition (=='.'))) "foo.bar.baz..whatever"
15:44:38 <lambdabot>   ["....","","","","","","","","","","","","","","","","","","","","","","","...
15:44:41 <AStorm> ouch
15:44:42 <FunctorSalad> I also ommited the termination condition ;)
15:44:47 <Stinger> haha
15:44:54 <AStorm> > unfoldr (Just . (partition (\='.'))) "foo.bar.baz..whatever"
15:44:56 <lambdabot>   mueval: Prelude.read: no parse
15:45:03 <AStorm> > unfoldr (Just . (partition (/='.'))) "foo.bar.baz..whatever"
15:45:04 <lambdabot>   ["foobarbazwhatever","","","","","","","","","","","","","","","","","","",...
15:45:06 <AStorm> wrong slash
15:45:13 <AStorm> 100% not what you want
15:45:26 <rwbarton> I think you want span, not partition.  But even so, you have to get it past the delimiter as well
15:46:02 <AStorm> actually, I'd just use takewhile
15:46:06 <AStorm> for non-string
15:46:23 <rwbarton> > unfoldr (Just . second tail . (span (/= '.'))) "foo.bar.baz..whatever"
15:46:26 <lambdabot>   mueval: Prelude.read: no parse
15:46:54 <AStorm> one . too few?
15:46:54 <TomMD> Still working on the n-ary break?  Someone really should write the 'chunk' or 'breaks' or whatever else people call it and e-mail libraries@h.o
15:47:13 <AStorm> TomMD: it's been done in 2-pass
15:47:23 <AStorm> @src takewhile
15:47:24 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:47:27 <AStorm> ;)
15:47:35 <AStorm> @src takeWhile
15:47:36 <lambdabot> takeWhile _ []                 =  []
15:47:36 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
15:47:36 <lambdabot>                    | otherwise =  []
15:48:08 <AStorm> we need one level nested takewhile
15:48:44 <rwbarton> (BTW, I would not call "filter f . map g $ xs" is not a two-pass algorithm)
15:48:53 <rwbarton> s/is not//
15:49:10 <AStorm> it is
15:49:22 <AStorm> it does two passes over the list, unless ghc is very smart
15:49:25 <rwbarton> Then the notion of "pass" is not useful
15:49:45 <rwbarton> I mean, it applies g to the first argument, and returns it if it passes f.
15:50:01 <rwbarton> Then it applies g to the next argument, and returns it if it passes f, etc.  Just lazy evaluation
15:50:10 <AStorm> oh really?
15:50:13 <AStorm> this is smart compiler ;P
15:50:20 <AStorm> why won't it just first map, then filter?
15:50:24 <rwbarton> No, it's a smart language specification :)
15:50:32 <AStorm> yippie
15:50:33 <Stinger> lazyness
15:50:34 <BMeph`> AStorm: Er, fusing things like that is almost the whole point to GHC. :)
15:50:50 <AStorm> @src (.)
15:50:51 <lambdabot> (f . g) x = f (g x)
15:50:56 <AStorm> uh, fail?
15:51:08 <ddarius> Actually those will probably be fused in GHC...
15:51:19 <AStorm> == smart compiler
15:51:34 <AStorm> assuming we only have a dumb one
15:51:42 <AStorm> we'd like a recursive function
15:52:50 <AStorm> the variant that produces "" for each split is simple with takeWhile ;>
15:53:32 <AStorm> it will produce [] with other types
15:53:56 <rwbarton> > head . filter even . map (\x -> if x == 3 then error "3" else x) $ [1,2,3,4,5]  -- AStorm
15:53:57 <lambdabot>   2
15:54:30 <AStorm> that's ghc's doing
15:54:40 <rwbarton> That's specified by the Haskell report
15:54:45 <AStorm> or is (.) really that well defined?
15:54:50 <AStorm> excellent
15:54:58 <AStorm> so, src is the fail ;)
15:55:04 <rwbarton> No, @src is correct
15:55:31 <Stinger> AStorm, are you familiar with the concept of lazy evaluation?
15:55:35 <TomMD> grrr.  What is "-B" in GHC?  I can't seem to find it.
15:55:41 <AStorm> > head (filter even (map (\x -> if x == 3 then error "3" else x) [1,2,3,4,5]))
15:55:43 <lambdabot>   2
15:55:46 <AStorm> hmmmh
15:55:58 <AStorm> Stinger: I am ;P
15:56:08 <TomMD> "missing -B<dir> option" is never an error message anyone should write.
15:56:16 <Stinger> well its purely lazyness as far as I can see
15:56:33 <AStorm> take one, pass it through whole chain etc.
15:56:57 <AStorm> right, otherwise infinite structures wouldn't work
15:57:02 <Stinger> you are only taking the head element, so it only computes the head element
15:57:24 <AStorm> > head (filter even (map (\x -> if x == 3 then error "3" else x) (cycle [1,2,3,4,5])))
15:57:25 <lambdabot>   2
15:57:41 <TomMD> @let f = forkIO f
15:57:42 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:57:47 <AStorm> ;P
15:57:56 <FunctorSalad> :o
15:57:57 <rwbarton> @src map
15:57:58 <lambdabot> map _ []     = []
15:57:58 <lambdabot> map f (x:xs) = f x : map f xs
15:57:59 <AStorm> no IO for you in lambdabot
15:58:07 <rwbarton> The main point is (:) is non-strict
15:58:09 <AStorm> rwbarton: yes, that's it
15:58:19 <TomMD> I know, I am just getting irritated so I lashed out at the bot.
15:58:38 <FunctorSalad> @botsnack cookies
15:58:39 <lambdabot> :)
15:58:57 <AStorm> bots are people too! ;)
15:59:04 <TomMD> ... but not too bright.
15:59:06 <TomMD> @botsmack
15:59:06 <lambdabot> :)
15:59:07 <Stinger> @bitsnack brussel sprouts
15:59:07 <lambdabot> :)
15:59:26 <TomMD> @vixen are bots people too?
15:59:27 <lambdabot> let's don't talk about that
15:59:30 <TomMD> See
15:59:33 <FunctorSalad> is that like catnip?
16:00:09 <pfo> how do i concat Char + [Char] ?
16:00:13 <bos> TomMD: -B is a GCC option, telling it where to find piece of the compiler. perhaps it's GCC complaining, not GHC?
16:00:21 <TomMD> pfo (:)
16:00:26 <pfo> thx
16:00:36 <TomMD> > 'h' : "ello"
16:00:38 <lambdabot>   "hello"
16:00:39 <TomMD> bos: thanks
16:00:45 <AStorm> yes, it's a [Char]
16:00:56 <TomMD> bos: This is with a new bulid of 6.9 - my 6.8 works fine, but I know my 6.9 isn't installed right.
16:01:17 <bos> oh, then that could indeed be it.
16:01:21 <rwbarton> -B also seems to be an undocumented ghc option: $ ghc -B
16:01:22 <rwbarton> ghc-6.8.2: Can't find package.conf as driver/package.conf.inplace
16:01:45 <TomMD> Yes, I just am looking at how to fix the dern thing.
16:02:14 <rwbarton> You have my sympathies
16:05:35 <waynemokane> is it possible to declare several variables of the same type in one declaration?
16:06:19 <lilac> > let x,y,z :: Int; x = 1; y = 2; z = 3 in x+y+z
16:06:20 <lambdabot>   6
16:06:52 <lilac> yes and no: you can declare them to have the same types, but the values need to be given separately
16:07:06 <waynemokane> lilac: perfect, thanks
16:11:47 <dons> Lemmih: haskell-dbus is missing its .buildinfo.in file
16:15:15 <waynemokane> lilac: does that not work at the top level?
16:17:33 <lilac> waynemokane: yes, it works at the top level. same thing, without the 'let' and the 'in ...'.
16:17:34 <sjanssen> > let x, y, z :: Int; (x, y, z) = (1, 2, 3) in x + y + z -- you can also use pattern bindings
16:17:36 <lambdabot>   6
16:17:43 <waynemokane> lilac: nvm... forgot that names have to start w/lowercase
16:19:06 <waynemokane> ok another question... how to best implement constants?  it seems like just having c1,c2::String is problematic
16:19:19 <sjanssen> waynemokane: why?
16:19:27 <waynemokane> sjannsen: those cannot be used in patterns apparently
16:19:57 <waynemokane> or at least it gives a warning
16:21:52 <waynemokane> sjannsen: yeah it doesn't work in pattern matches using data constructors
16:22:35 <sjanssen> use ==
16:22:50 <lispy> :t (==)
16:22:51 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:22:55 <sjanssen> foo x | x == someConstant = blah
16:23:21 <lispy>       | otherewise = blah2
16:23:23 <waynemokane> sjannsen: are those guards?
16:24:07 <sjanssen> waynemokane: correct
16:24:11 <waynemokane> sjannsen: I read something about using guards being ill advised... have I been misinformed?
16:24:54 <sjanssen> waynemokane: you probably read one of the style guides on the wiki?  Some idiot added negative comments about guards, you can ignore it
16:25:42 <sjanssen> well, I suppose "idiot" isn't nice.  But it certainly isn't a mainstream opinion
16:25:45 <waynemokane> sjannsen: no it was something about not being universally supported
16:25:53 <waynemokane> sjannsen: like as in, ghc-only
16:25:59 <sjanssen> waynemokane: oh, you're thinking of pattern guards, which are different
16:26:04 <Lemmih> dons: Indeed.
16:26:28 <waynemokane> sjannsen: hmmm so these are not pattern guards but something else?
16:26:47 <sjanssen> waynemokane: this is just a plain old guard which all Haskell systems support
16:27:09 <sjanssen> pattern guards look like "| Just x <- foo = blah"
16:27:16 <sjanssen> (notice the binding <-)
16:29:17 <Lemmih> dons: 0.4 uploaded.
16:30:09 <waynemokane> sjanssen: oh interesting... so those are only within the context of a do block?
16:30:55 <adu> progress is beautiful!
16:31:04 <dons> Lemmih: thanks.
16:31:41 <sjanssen> waynemokane: nah, they're actually in any function binding.  It reuses the (<-) with a slightly different meaning
16:32:56 * ivanm idly wishes there was a way to see at what stage a running haskell program is up to...
16:33:20 <BONUS_> so is there a difference between f [] = ... ; f (x:xs) = ... and f a | [] <- a = ... | (x:xs) <- a = ..
16:34:12 <waynemokane> sjannsen: OK, is this an example of the normal guards you were originally suggesting?  http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html#Guards
16:34:15 <lambdabot> Title: Tour of the Haskell Syntax, http://tinyurl.com/kf5wj
16:36:27 <adu> ivanm: doesn't ghci have an interrupt prompt?
16:37:13 <sjanssen> waynemokane: right
16:37:28 <sjanssen> BONUS_: they're the same
16:37:32 <waynemokane> sjannsen: cool, thanks... this opens up a world of new possibilities
16:38:27 <waynemokane> it seems like the guards are a more generic utility than pattern matching in function parameters?
16:38:28 <adu> ivanm: woah no interrupt prompt... I thought there was... o well
16:38:40 <ivanm> adu: well, it's compiled anyway ;-)
16:39:20 * adu thinks there should be an interrupt prompt...
16:39:35 <sjanssen> waynemokane: well, guards are really a different thing from pattern matching
16:39:54 <adu> even if you have to press M-C-A-esc-2 to get to it...
16:39:58 <waynemokane> sjannsen: I guess pattern matching binds to variables
16:40:08 <sjanssen> waynemokane: notice that guards only work on boolean expressions, so they're more closely related to the if statement
16:40:19 <ddarius> Guards are sugar for if-then-else roughly and pattern matching is sugar for case
16:40:41 <waynemokane> hmm that seems reasonable
16:45:00 <haskellian> what is the recursion depth in haskell? does it optimize tailcalls? do i have to write a function ina certain way to do so?
16:46:15 <adu> haskellian: I think its 65536 or something
16:46:40 <sjanssen> haskellian: depends. yes. not really.
16:46:50 <dons> adu, huh?
16:46:59 <dons> it's -Kn where n is the stack limit.
16:47:05 <adu> dons: GHC max stack size
16:47:08 <haskellian> http://hpaste.org/10192 top one is tailrec, bottom isnt. still stack isnt blown when calling rrmv [1..1000000] 99999. why not?
16:47:33 <dons> laziness.
16:47:41 <dons> you're recursing under a constructor.
16:47:52 <dons>     | x /= y    = x : rrmv xs y
16:47:58 <dons> is:
16:48:05 <dons>    Cons (x) (rrmv xs y)
16:48:14 <dons> where that recursive call is suspended.
16:48:18 <haskellian> hmm often when doing machine learning, ai, datamining etc youd go deeper than 65K calls right? so isnt 65K kind of deceptive  since you might think your function works because it passed some toyexamples?
16:48:29 <dons> where'd this 65k number come from?
16:49:13 <dons> there's a default stack size of 8M.
16:49:22 <dons> so you can stick 8M of stuff in the stack by default.
16:49:28 <adu> dons: o, my bad
16:49:30 <dons> its not a fixed number of calls or anything like that.
16:49:33 <ivanm> awwwww, is that all? :(
16:49:34 <ivanm> ;-)
16:49:36 <sjanssen> IIRC, you can even shut off the limit entirely
16:49:36 <dons> now, you can change that as much as you want.
16:49:44 <dons> using -Kn, where n is some number
16:50:24 <adu> so -K8192 is default?
16:50:44 <dons> 8M. the type is 'bytes'
16:50:45 <haskellian> hmm what would be the practical limit then? for 1GB ram-memoery(is that were the stack is !?)
16:50:52 <dons> haskellian: physical memory.
16:51:04 <dons> how much have you got?
16:51:07 <adu> so -K8388608 is default?
16:51:08 <haskellian> ok so what 120GB?
16:51:11 <dons> sure.
16:51:18 <dons> $ ./A +RTS -K120G
16:51:18 <dons> "hey"
16:51:18 <haskellian> or RAM 1GB?
16:51:26 <sjanssen> haskellian: yes, stack is stored in RAM
16:51:27 <dons> sets the maximum stack size to 120G.
16:51:37 <haskellian> cool
16:51:51 <dons> no limits man!
16:52:15 <adu> i'm going to start calling ghc with -K1000000T
16:52:29 <dons> $ ./A +RTS -K1000000T
16:52:29 <dons> "hey"
16:52:41 <dons> safe strategy: more programs will run.
16:52:46 <b\6> the software excellence never ends.
16:52:51 <haskellian> but what do you mean recursing under a constructor?
16:52:58 <dons> using the stack significantly usually means you're doing it wrong though.
16:53:03 <ddarius> @wiki Stack overflow
16:53:03 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
16:53:04 <adu> haskellian: that wasn't a pure tail call
16:53:06 <ddarius> haskellian: Read that.
16:53:08 <dons> haskellian: so the recursive call is suspended under the cons constructor.
16:53:29 <Stinger> yeah your bad programs might take a tad longer to finish with 120G of stack
16:53:33 <dons> we get to use laziness to prevent stack use.
16:53:48 <haskellian> adu: which wasn't? rmv or rrmv?
16:53:54 <adu> haskellian: rrmv
16:54:01 <haskellian> stinger: my bad programs?
16:54:56 <haskellian> adu: i know ^^recur undr constructor, but the first one is proper tail right?
16:55:53 <adu> haskellian: ya i guess, I'm not sure what "tailcall" means in Haskell tho...
16:56:13 <adu> I only understand tail-calls in terms of (begin) and (progn)
16:57:04 <sjanssen> haskellian: the first version is not exactly tail recursive
16:57:16 <sjanssen> "| otherwise = reverse acc ++ xs
16:57:35 <sjanssen> erm, nevermind
16:57:44 <adu> haskellian: unless you take into account the if-then-else desugaring
17:01:31 <haskellian> sjanssen: well there is 2 "basecases" right?
17:03:06 <sjanssen> haskellian: yeah, I was incorrect
17:03:32 <sjanssen> haskellian: though I think it is weird that you only reverse the accumulator in the last case
17:04:54 <dons> Lemmih: is there a chance HAppS will use the newer HaXml soon?
17:05:05 <dons> the dep on old HaXml (==1.13.*) complicates things
17:07:34 <haskellian> len' [] acc = acc
17:07:34 <haskellian> len' (x:xs) acc = len' xs (1 + acc)
17:07:42 <haskellian> wy is that causing stack overflow?
17:07:52 <sjanssen> haskellian: Haskell is a lazy language
17:08:02 <dons> probably not compiling with optimisations on, so you're getting a naive translation of that function.
17:08:23 <dons> the (1 + acc) part will just build up a long chain of (+ 1 (+ 1 (+ 1 ... ) till the acc is used at the end
17:08:32 <dons> those "thunks" are on the stack.
17:08:49 <dons> to prevent this, use strictness:  len' (x:xs) acc = len' xs $! (1 + acc)
17:08:52 <haskellian> i should read more and ask less
17:08:58 <Christina> hi everyone.  I'm working on project for work, I'm new to asp.net and c# and I'm having trouble with a grid...is there anyone that could help me?
17:09:00 <haskellian> it says further down :) ty
17:09:01 <dons> which tells the compiler to evaluate it before the call
17:09:13 <dons> Christina: wrong channel.
17:09:24 <Christina> oh?
17:09:27 <Christina> where do I go?
17:09:31 <Christina> I'm new to mirc
17:09:35 <dons> this is #haskell. so I guess you want a C# channel.
17:09:42 <Christina> ok
17:09:43 <Christina> sorry
17:11:21 <qwr> Christina: /join #csharp
17:11:56 <haskellian> how come the builtin length is so fast? is not implemented like this:
17:12:00 <haskellian> ?src length
17:12:00 <lambdabot> Source not found. Just try something else.
17:12:08 <haskellian> len :: (Num t1) => [t] -> t1
17:12:08 <haskellian> len xs = len' xs 0
17:12:08 <haskellian> len' [] acc = acc
17:12:08 <haskellian> len' (x:xs) acc = len' xs $! (1 + acc)
17:12:09 <dons> haskellian: it's compiled with optimisations on.
17:12:14 <haskellian> ok
17:12:17 <dons> haskellian: yeah it's pretty much identical to that.
17:12:22 <dons> so if you compile with ghc -O2
17:12:29 <dons> you'll get the same kind of thing.
17:23:46 <hackage> Uploaded to hackage: DBus 0.4
17:28:10 <haskellian> :t foldl'
17:28:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:29:11 <haskellian> where is foldl' it is not in the prelude and not in List
17:29:19 <sjanssen> Data.List
17:30:45 <b\6> i noticed parsec2 code converting String to Integer via a fold instead of read. suppose that was done because it's faster? or why?
17:32:00 <humasect> haskellian: ":i" in ghci you may find useful too
17:33:39 <ddarius> b\6: It is faster.
17:33:56 <b\6> ddarius: thanks.
17:34:41 <haskellian> why aren't more basic functions in the prelude?
17:34:48 <haskellian> like foldl' and sort
17:35:08 <humasect> or less of them ? they are needed for bootstrap , could be one reason
17:37:29 <humasect> Prelude, List, Data.List
17:38:44 <b\6> how to make darcs show the original darcs get'ed url?
17:39:10 <mmorrow> cat _darcs/prefs/defaultrepo
17:39:40 <b\6> mmorrow: thanks.
17:57:59 <dominic-> hi
18:02:08 <TomMD> hello dominic-, welcome to Haskell on this fine evening.
18:02:17 <dominic-> thank you sir
18:03:31 <malouin> hi all -- so I'm on debian, and in trying to build cabal's dependencies from hackage, I get several errors of the form 'Could not find module X: it was found in multiple packages: <something I just built> <something installed on the system>'
18:03:47 <malouin> eg System.Locale found in old-locale-1.0.0.0 base
18:06:24 <malouin> I tried to remove all the system libraries that debian installed, but I can't remove 'base', and some things apparently conflict with it.
18:06:52 <sheyll> hi!
18:07:03 <mmorrow> hilo!
18:07:07 <malouin> I'm wondering if I will not have luck trying to build cabal with debian's ghc 6.6-3
18:07:52 <sheyll> is anyone of you using xmonad?
18:09:53 <BMeph`> dons: ping
18:10:04 <b\6> sheyll: i do.
18:10:47 <sheyll> b\6: does xmonad read your config file, and if so, where do you have it?
18:11:03 <sheyll> in .xmonad/xmonad.hs?
18:11:05 <b\6> sheyll: course. ~/.xmonad/xmonad.hs.
18:11:50 <sheyll> hmm.. do you know how I could find out whether, and if not why - xmonad reads this file?
18:12:28 <b\6> sheyll: what are you seeing? changes not taking effect?
18:12:47 <sheyll> b\6: exactly
18:13:00 <sheyll> I can put in there what ever I want - no effects
18:13:29 <b\6> sheyll: hmm. never had that problem. asked in #xmonad?
18:13:36 <b\6> operators are standing by there probably.
18:13:37 <sheyll> doh'
18:13:51 <sheyll> should have bothered the guys there not here...
18:14:03 <b\6> shrug, lots of overlap.
18:14:44 <b\6> now, if you start using a java window manager, don't ask in ##java.
18:14:50 <b\6> or expect avalanche of hatred.
18:15:41 <sheyll> yes, thinks are diffrent in the java world. Apart from the fact, that I have not seen a java window-manager.
18:15:49 <b\6> let's hope.
18:15:51 <ddarius> sheyll: Are you recompiling xmonad?  xmonad.hs is just a source file.
18:16:28 <sheyll> ddarius: no I just changed the file without recompiling it.
18:16:35 <b\6> yeah, that's how it should be.
18:17:11 <sheyll> But I will look at the  xmonad source...
18:17:41 <b\6> shouldn't be necessary. does .xmonad or xmonad.hs have weird perms or anything?
18:18:05 <sheyll> hmm good idea
18:18:08 <b\6> xmonad just spots the binary it makes is out of date and regenerates, seems as if.
18:18:10 <sheyll> I will check
18:18:37 <b\6> where'd you get it? did your distro have a package or what?
18:19:17 <sheyll> oooohhhh noo!
18:19:21 <ddarius> http://haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#How_do_I_configure_xmonad.3F
18:19:23 <lambdabot> Title: Xmonad/Frequently asked questions - HaskellWiki, http://tinyurl.com/3a2duf
18:19:56 <sheyll> guess what the path to my xmonad.hs file is: ~/.xmonad/.xmonad.hs
18:20:02 <sheyll> ok...
18:20:07 <dmwit> hehe
18:20:08 <b\6> oh, no good.
18:22:05 <dons> Beelsebob: parallel thread ring http://haskell.org/haskellwiki/Shootout/Parallel/ThreadRing
18:22:06 <lambdabot> Title: Shootout/Parallel/ThreadRing - HaskellWiki
18:22:13 <malouin> is it possible for cabal to think that a package has unmet dependencies when in fact the deps are satisfied by system libraries?
18:22:45 <malouin> ie libraries installed by the system package manager without cabal's knowledge
18:23:00 <b\6> but does ghc-pkg list show stuff in the system part?
18:24:24 <malouin> hmm, not in this case.
18:24:48 <dmwit> malouin: If your package manager installed it, but ghc-pkg list doesn't know about it, the package is broken, and you should complain.
18:25:02 <malouin> dmwit: ok.
18:28:35 <sheyll> yay it worked :)
18:30:28 <b\6> ok. if i get rich from coding haskell and get my dog an iced out <$> medallion, what about his sunglasses? i can do a lambda for the nose bridge, but what symbols for the eyepieces? @ seems natural, but i don't want people thinking he's some weird advert for yahoo.
18:30:52 <b\6> it's like step away from my dog. he's not ask jeeves.
18:32:19 <TomMD> Hummm, b\6 - if you get rich programming Haskell how about you open up b\6 Research Cambridge?
18:32:55 <b\6> yeah, it's just on the back burner until i get my dog's haskell bling figured out.
18:33:01 <b\6> first things first.
18:33:14 <sclv> <*>, obviously.
18:33:19 <TomMD> Hummm.  Don't over do the infix operators.
18:33:20 <b\6> aha.
18:33:40 <sclv> >>= ?
18:33:47 <Olathe> > (leftEye)-(rightEye)
18:33:48 <lambdabot>   mueval: Prelude.read: no parse
18:33:52 <Olathe> No parse ?!
18:34:34 <b\6> heh, i feel like submitting an "enough is enough" one line patch to print something better than "no parse".
18:34:42 <b\6> more like no speaka de english.
18:35:32 <b\6> <*>.\<*>  WOOF WOOF
18:36:57 <Saizan_> it's actually fixed in teh HEAD
18:37:36 <b\6> checking.
18:37:47 <Saizan_> mueval's head
18:37:55 <b\6> oh.
18:40:04 <Olathe> It's all theory in mueval's head rather than action.
18:43:52 <Cale> If only whatever was blocking the mueval release was done :)
18:44:13 <Cale> I think it was haskell-src-exts which needed a release
18:46:48 <Olathe> Error: Too many Cales.
18:47:24 <dancor> close cales
18:49:34 <malouin> is it possible to build a more recent 'base' for a user?
18:50:39 <malouin> or does this require rebuilding ghc?
18:50:50 <malouin> or re-installing
18:51:56 <dmwit> It's probably easier to just upgrade GHC.
18:53:13 <byorgey> malouin: why do you need a more recent 'base' package?
18:53:22 <byorgey> and which one do you have currently?
18:53:41 <malouin> I have 6.6-3
18:54:33 <sclv> you should just upgrade
18:54:40 <malouin> fair enough.
19:02:06 * byorgey bakes butterscotch-lambda chip cookies
19:09:07 * dancor thinks it should either be allowed to upgrade your base, or never needed to specify it in .cabal
19:10:15 <malouin> my only hangup is installing non-system-package-manager stuff outside my homedir.
19:10:27 * dolio sends a proposal to haskell-cafe to turn Haskell into an impure language with no type system.
19:10:38 <malouin> I'm just building the newest ghc source distribution to my homedir though, so it's fine.
19:12:43 <sclv> dolio: people use hacks to accomplish that anyway, in standard libraries even! so once we've admitted that, its better to codify it than to rely on hacks and unsafePerformIO to make it work. :-)
19:13:50 <dolio> sclv gets me. :)
19:21:23 <mmorrow> * dolio sends a proposal to haskell-cafe to turn Haskell into an impure language with no type system.
19:21:25 <mmorrow> lolol
19:22:22 <mmorrow> i think ghc should simply produce randomly generated asm instructions and call it good
19:22:53 <Olathe> It should produce random sequences until it finds one that does what the code says.
19:23:13 <mmorrow> pfftt. who cares about what the code says ;)
19:23:20 <Olathe> Compilers !
19:23:26 <Olathe> I don't.
19:23:33 <mmorrow> heh
19:24:48 <seafood_> Hey Haskellers. I'm going to ask for a few opinions.
19:24:49 <mmorrow> but the compiler i'm proposing simply (1) discards any input, and (2) randomly generates a (possibly empty) list of instructions which it then passes to the assembler
19:25:01 <Olathe> mmorrow: Ahh.
19:25:04 <mmorrow> Olathe: i mean come on.
19:25:07 <mmorrow> :)
19:25:14 <Olathe> You could call it a genetic compiler.
19:25:20 <Olathe> It's trendy.
19:25:21 <seafood_> Do you think that Haskell will one day have a web framework that is very popular? How do you think hApps is coming along?
19:25:32 <Olathe> seafood_: I doubt it, but who knows.
19:25:44 <seafood_> Olathe: Where does your doubt spring from?
19:25:49 <Olathe> Haskell's a bit too weird for the web developers out there.
19:26:07 <seafood_> I'm mainly a Haskell and OCaml programmer but I've also done some work in Ruby on Rails. And I have to say, it's not all it's cracked up to be.
19:26:17 <Olathe> It's not bad to be a Haskeller that also makes web apps.
19:26:31 <seafood_> It really matters to me that I find out about certain types of errors (that could be detected with a type checker) before I actually run the damn program.
19:26:45 <Olathe> Sure, that's not a bad desire.
19:27:24 <seafood_> But I've never used Haskell to make a webApp.
19:27:35 <Olathe> Oh.
19:27:49 <Olathe> You were wondering what's the best web framework available ?
19:27:49 <mmorrow> seafood_: it's pretty much fastcgi-dbpkg-buildyourownframework
19:27:54 <mmorrow> it works for me
19:28:00 <AlexSuraci> Kibro looked interesting.
19:28:06 <mmorrow> but there's also HAppS
19:28:14 <mmorrow> oh yeah, chrisdone's kibro too
19:28:16 <AlexSuraci> http://chrisdone.com/blog/2008/08/06/kibro-haskell-lighttpd-and-fastcgi/
19:28:23 <lambdabot> Title: 17 Chris Dones Blog 2d  Kibro: Haskell, lighttpd and fastcgi d, http://tinyurl.com/59vhhb
19:28:30 <seafood_> Exactly. Do you think HAppS is something we should all get behind?
19:28:46 <AlexSuraci> I don't really like to have html generated by anything, though. :x
19:28:59 <AlexSuraci> (I'm a web developer, learning Haskell on my free time.)
19:29:08 <seafood_> AlexSuraci: Really? So you like the idea of using Javascript to populate the hand written HTML?
19:29:19 <AlexSuraci> seafood_: I hate that even more.
19:29:24 <dmwit> WASH's HTML generation (which as a stand-alone library could be quite nice) has the interesting property that it guarantees the generation of valid XHTML-strict.
19:29:28 <seafood_> AlexSuraci: What's the alternative?
19:29:34 <AlexSuraci> Using JS/AJAX/etc. like that is blatant abuse of technology.
19:29:38 <mmorrow> seafood_: I personally don't prefer it (HAppS) over other possibilities (most of which don't yet exist :))
19:29:59 <seafood_> What are promising pathways then?
19:30:06 <AlexSuraci> seafood_: Unfortunately I can't name one. I just think a templating engine (similar to Erb, but not necessarily) is the best route.
19:30:20 <AlexSuraci> Well, not Erb. :P
19:30:42 <AlexSuraci> Probably more similar to Django's.
19:31:20 <AlexSuraci> That may just be a pipe dream, but I think that's really the best and least-surprising method of generating HTML.
19:33:02 <mmorrow> seafood_: what i personally (only speaking for myself) want is: (1) Sql parsing/generation/etc (2) javascript parsing/generation/simplification (i'm working on this and it's coming along) (3) css/html generation tools (i wish i had these) (4) i guess some sort of semi-coherent package that can tie some of this stuff together, but that /doesn't/ require things to be done a certain way
19:33:04 <seafood_> AlexSuraci: How does such a templating engine work, in principle?
19:33:40 <seafood_> mmorrow: You're going to generate javascript from Haskell?
19:33:51 <AlexSuraci> seafood_: You specify a context/scope that can be given to a template that can use those to output data.
19:33:54 <mmorrow> seafood_: hehe, i'm glad you asked. i'll paste a snippet
19:34:04 <mmorrow> actually, i'll find a previous paste
19:34:23 <AlexSuraci> The template is just good ol' HTML with simple "variables" like $site_name, etc.
19:34:53 <seafood_> AlexSuraci: Right, but don't heaps of frameworks use that approach?
19:35:11 <AlexSuraci> I don't see any reason for them not to.
19:35:13 * rwbarton is also curious about javascript from haskell
19:35:25 <mmorrow> seafood_: there's a practical code example at the very bottom (i'm already using this for some stuff), but the extension to GHC it uses won't be available until ghc6.10 (two weeks:))  http://hpaste.org/10114
19:35:26 <seafood_> seafood_: I mean, Ruby on Rails does, so did JSP.
19:35:52 <AlexSuraci> Doesn't Ruby on Rails automate the scope based on the controller?
19:36:19 <seafood_> AlexSuraci: I'm not sure what "automate the scope" means?
19:36:31 <seafood_> mmorrow: Interesting! What extension does it use?
19:36:33 <mmorrow> seafood_: that method allow splicing of haskell into the javascript + parsing of the js/sytactic correctness checks at /haskell/ compile-time
19:36:42 <AlexSuraci> Like, any variables that you create in the controller is put into the "scope" for the templates.
19:37:06 <mmorrow> seafood_: QuasiQuote
19:37:07 <seafood_> AlexSuraci: That's true.
19:37:08 <mmorrow> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
19:37:11 <lambdabot> Title: Why Its Nice to be Quoted: Quasiquoting for Haskell, http://tinyurl.com/yo9sa3
19:37:13 <mmorrow> ^^ really good
19:37:20 <mmorrow> a wiki page:
19:37:21 <mmorrow> http://haskell.org/haskellwiki/Quasiquotation
19:37:22 <lambdabot> Title: Quasiquotation - HaskellWiki
19:37:34 <seafood_> mmorrow: Let me get this straight, you're checking the syntactic correctness of the Javascript in Haskell using it's type system
19:38:43 <mmorrow> i'm doing that in the first two pastes yes, but that's a work in progress. but either way in order to have a QuasiQuoter, you need to parse the embedded lang, then translate that to template-haskell syntax
19:39:11 <mmorrow> so you get syntactic checking for free if you have a qq at all, since parsing is a prerequisite
19:39:16 <rwbarton> mmorrow: [$js|function(x){return(x+"")}|] <-- is the javascript being parsed, or is this basically just a data constructor?
19:39:24 <dons> anyone on ubuntu hardy?
19:39:35 * Nafai is
19:39:38 <seafood_> mmorrow: Personally, I can't stand Javascript's "gotchas". There are just too many of them. If you could restrict yourself to a safe subset it would be so much better.  Is that what you can do with your work?
19:39:40 <dons> what version of ghc does it ship wit, and are the extralibs, like, 'parallel' available?
19:39:42 <mmorrow> yeah, so  "function(x){return(x+"")}" is passed /as a String/ to your parsing function
19:39:44 <dons> or is the package system not working.
19:39:56 * Nafai looks
19:40:17 <mmorrow> and the [$js| ... |] can return /any/ haskell type it wants
19:40:27 <rwbarton> mmorrow: right, it looks FFI-ish in that way
19:40:35 <Nafai> dons: GHC version 6.8.2
19:40:44 <mmorrow> yeah, it crazyish
19:40:49 <dons> ok. and do you have 'parallel' . i.e. Control.Parallel ?
19:41:35 <dmwit> dons: I have Control.Parallel on an even older Ubuntu.
19:41:45 <dmwit> (From the package manager.)
19:41:50 <dons> dmwit: what's the package called?
19:42:08 <mmorrow> seafood_: here's (examples from) a regex qq which may make it clearer: http://code.haskell.org/~morrow/quasiquotes/regexqq/EXAMPLES
19:42:16 <dons> heya seafood_
19:42:31 <seafood_> dons: Like time no speak :)
19:42:32 <mmorrow> seafood_: the (rx :: QuasiQuoter) happens to return a function of type (String -> Maybe [String])
19:42:37 <dmwit> dons: Oh, hum, I'm not sure.  I just apt-get install libghc6-*-dev.
19:42:43 <Nafai> dons: Here's what apt-cache search libghc returns:
19:42:45 <dons> dmwit: oh ok.
19:42:45 <Nafai> http://hpaste.org/10194
19:42:52 <dmwit> dons: Let me look through the package list and make a guess, though.
19:42:54 <dons> dmwit: so libghc6-parallel-dev maybe?
19:43:36 <Nafai> dons: I'm not seeing a parallel package
19:43:55 <dons>   libghc6-parallel-dev ?
19:43:55 <dmwit> dons: I think it must be bundled with the ghc6 package.
19:44:06 <dons> well, i don't think so.
19:44:14 <dons> at least not now, since ghc on debian uses only the core lib.
19:44:15 <mmorrow> seafood_: oh just saw " I can't stand Javascript's "gotchas"...". totally. I'm using a parser that's on hackage (WebBits), but the answer is yes. you can arbotrarily manipulate/restrict/check/whatever the incoming code
19:44:16 <Nafai> dons: What do I have to import to see?
19:44:21 <dons> Control.Parallel
19:44:27 <seafood_> AlexSuraci: So what's the difference between Erb, Django and what we were talking about with Ruby on Rails.
19:44:29 <rwbarton> (fwiw, there is libghc6-parallel-dev on debian testing)
19:44:33 <dons> Prelude> :m + Control.Parallel
19:44:33 <dons> Prelude Control.Parallel>
19:45:01 <AlexSuraci> seafood: Erb (RoR's default engine) is a lot more lax, and it's basically using Ruby within HTML (like PHP does).
19:45:07 <AlexSuraci> Django/etc. is its own thing.
19:45:08 <Cale> mm... the latest Catsters video is interesting... I'd almost thought that I'd exhausted the ways with which to approach the concept of a limit of a diagram, and now there's an entirely new one that I haven't seen before :)
19:45:14 <Nafai> dons: Yeah, I'm not seeing it with just the basic stuff installed
19:45:30 <dons> and you're not seeing a parallel package of any flavour?
19:45:30 <mmorrow> Cale: i love when that happens
19:45:43 <dons> no haskell-parallel or libghc6-parallel-dev ?
19:45:54 <AlexSuraci> seafood_: By "its own thing" I mean they have their own syntax, their own systems, and generally I think they're a bit more structured.
19:45:57 <seafood_> AlexSuraci: More checks are done in Django?
19:46:03 * dons wonders what the hell is going on in ubuntu
19:46:16 <Adamant> dons: ?
19:46:21 <dons> is there a libghc6-parallel-dev package?
19:46:25 <dmwit> dons: Ubuntu breaks from Debian in a lot of places. =)
19:46:32 <dons> or are you saying there is *not* parallel package for haskell on ubuntu hardy?
19:46:38 <Nafai> dons: Not that I can find
19:46:48 <dons> bloody hell. wtf are they doing?
19:46:57 <Nafai> No clue
19:46:59 <AlexSuraci> seafood_: Well, for example you have to specify which variables are available to the template. With Erb you can use Ruby to do just about anything, even execute Ruby code from within the page, set variables, etc.
19:47:02 <dolio> I think I noticed that before, too.
19:47:08 <dmwit> dons: I have C.P available, without doing any explicit work, but search ghc | grep par yields no results.
19:47:09 <dolio> Didn't mention it.
19:47:11 <dons> does anyone know who the ubuntu packagers for ghc are?
19:47:22 <AlexSuraci> seafood_: Which I think is bad, since it bleeds the logic into the template.
19:47:23 <dmwit> (Other than two "par"ser packages.)
19:47:32 <dons> this is scary: that's the most popular distro, and core libs are missing.
19:48:27 <bos> dons: i think that ubuntu gets its bits from debian,
19:48:46 <dons> well, it'd be haskell-parallel or libghc6-parallel-dev then.
19:48:46 <byorgey> I seem to have Control.Parallel too.  not sure what package it's coming from.
19:48:48 <AlexSuraci> seafood_: Just found this templating engine, it's similar in concept to Django's. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/chunks (port of Perl's HTML::Chunks). The syntax is kind of ugly though. ;)
19:48:53 <lambdabot> Title: HackageDB: chunks-2007.4.18
19:49:00 <dons> i need to find the name, since it is missing on the shootout
19:49:09 <dons> so we can't write the kind of parallel programs we need to.
19:49:11 <sclv>  AlexSuraci
19:49:14 <byorgey> but there definitely isn't one named libghc6-parallel-dev
19:49:16 <dons> (the quad core shootout is running ubuntu)
19:49:17 <bos> it's a shame to see decent people use ubuntu.
19:49:25 <sclv> AlexSuraci: have you looked at HStringTemplate?
19:49:43 <dons> see http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ghc&id=2
19:49:43 <AlexSuraci> sclv: Not in-depth, I've got a tab for that open too. :P
19:49:43 <Nafai> dons: The maintainer of the ghc6 package is: Stefan Potyra <sistpoty@ubuntu.com>
19:49:45 <byorgey> bos: heh, why's that?
19:49:45 <lambdabot> Title: binary-trees Haskell GHC #2 program | x64 Ubuntu : Intel Q6600 quad-core Com ..., http://tinyurl.com/5ag9be
19:49:57 <dons> Nafai: ok.
19:50:09 <bos> byorgey: they're pretty cavalier about non-free components. it brings a pang to me.
19:50:11 <seafood_> AlexSuraci: There do seem to be some control flow structures in Django though. I just had a look.  There are for-loops for instance.
19:50:22 <byorgey> bos: ah, that's true.
19:50:23 <seafood_> AlexSuraci: I'm struggling to see the real difference at a cursory glance.
19:50:24 <Nafai> dons: The maintainers of almost all the lib packages is: Ubuntu MOTU Developers <ubuntu-motu@lists.ubuntu.com>
19:50:29 <dons> hmm
19:50:35 <AlexSuraci> seafood_: Yeah, but they aren't generating data. They're using it, but not doing anything new.
19:50:44 <Nafai> So I'm not sure if any specific person does that
19:50:46 <seafood_> AlexSuraci: Ahah. That *is* nice.
19:51:08 <sclv> stringtemplate is the way to go for preventing logic from making its way into templates -- no for loops even. instead, functional constructs.
19:51:24 <AlexSuraci> seafood_: I use a custom templating engine called Twig (by the same maker of Jinja) in a project of mine.
19:51:47 <bos> jeepers. human genes compress well. i downloaded 450MB of genome data, and it uncompressed to 3.2GB.
19:52:19 <AlexSuraci> sclv: I think for loops/if checks are fine in a template; they make it clear what's being outputted and how.
19:52:40 <sclv> well if checks are... but functional constructs are better than explicit looping.
19:52:41 <AlexSuraci> Granted, there should be limits to how much of it there is.
19:53:01 <AlexSuraci> sclv: What do the functional constructs do?
19:53:06 <mmorrow> wouldn't that make the templating lang turing complete then?
19:53:08 <sclv> loop :-)
19:54:11 <sclv> i.e. if I have a list in stringtemplate and want to write the same code for everything in it, I can write $myList:{" $it$ "}$
19:54:24 <sclv> the {} bit is an anonymous subtemplate.
19:54:36 <AlexSuraci> weird
19:54:40 <sclv> each item in myList gets passed into it, and the results are concated.
19:54:52 <sclv> its a concatMap.
19:54:55 <AlexSuraci> Isn't that more limiting though?
19:55:16 <sclv> right -- but more limiting in a good way. everything you need from a template engine you can get pretty much.
19:55:20 <AlexSuraci> For example, how would you output nav links (in the form of <li><a>$name</a></li>)?
19:55:24 <sclv> but nothing that you really don't want.
19:55:32 <sclv> you can do exactly that.
19:55:33 <dons> this ubuntu business is pretty awful. what kind of garbage packaging are they shipping? :(
19:56:25 <AlexSuraci> (A reference on the templating engine I'm most used to, used in my project, is here: http://github.com/vito/chyrp/wikis/twig-reference if you're interested)
19:56:35 <lambdabot> Title: Twig Reference  chyrp  GitHub
19:56:40 <sclv> $myList:{<li><a href=$it.url$>$it.name$</a></li>}$
19:56:51 <rwbarton> dons: it looks like there's no Parallel.hi in ubuntu right now.  It was in ghc6 in gutsy, and will be in libghc6-parallel-dev in intrepid
19:56:58 * mmorrow looks at twig
19:57:01 <bos> templating engines are a scourge.
19:57:04 <dons> rwbarton: how long aways is that?
19:57:21 <sclv> anyway as for sql libraries haskell has an abundance, and its trivial to knock out a good controller on top of the basic cgi monad too...
19:57:26 <Nafai> dons: Next month, I believe
19:57:32 * dons needs to keep a closer eye on what the various distros are packaging as 'haskell'
19:57:34 <bos> they're so easy to write that every web developer builds two before breakfast once a month, and uploads them to some code graveyard.
19:57:37 <dons> a public shame page.
19:57:48 <bos> dons: the platform should help to address that.
19:58:10 <sclv> which just leaves a more lightweight standard way to do sessions so everyone doesn't reinvent the wheel.
19:58:13 <dons> bos, yeah.
19:58:32 <sclv> (but in this case, its just a matter of packaging up -exts, even!)
19:58:33 <dons> package maintainers have peculiar ideas of what they need to support.
19:58:35 <dons> we have to tell them.
19:58:44 <sclv> seriously. extralibs.
19:59:03 <dons> yeah, well debian decided to break out extralibs into separate packages.
19:59:04 <mmorrow> i think quasiquotes will be so useful because they'll allow any external lang/whatever that can't be done in haskell to be brought into haskell so the type system can be used with it too
19:59:07 <dons> so when you install ghc, you're not done.
19:59:14 <dons> then ubuntu skipped at least one of the new packages.
19:59:30 <dons> so ubuntu users can't run parallel haskell program.s
19:59:31 <sclv> bos: I tend to like stringtemplate quite a bit. :-( you hurt me in my heart.
19:59:35 <seafood_> mmorrow: QuasiQuotes sound very exciting.
19:59:45 <mmorrow> seafood_: totally
20:00:08 <seafood_> bos: Why do you dislike templating engines?
20:00:23 <AlexSuraci> sclv: Here's a basic loop in Twig: http://paste.pocoo.org/show/9qRC2zT0fLR0HMbMWIwf/
20:00:28 <bos> seafood_: i don't. i dislike the fact that there are a million of them.
20:00:30 <sclv> I'll grant that ten thousand essentially similar ones are a pain though.
20:00:57 <seafood_> bos: Yeah, I suppose there is one for each language? Any preferences?
20:01:10 <sclv> there's like ten for each language.
20:01:27 <AlexSuraci> It just depends on which one you like the best.
20:01:37 <Cale> dons: In practice though, the smarter Ubuntu users don't even bother with ubuntu's packages. The generic linux package provided on the GHC site is reasonably decent, and the Ubuntu packages are pretty consistently far enough behind not to even bother with them.
20:01:41 <AlexSuraci> You're using it to essentially build your site, it's good for there to be so much variety. Unless they all suck.
20:01:57 <sclv> They're all too alike.
20:02:19 <dmwit> Yep, Ubuntu is guaranteed to be at least 6 months behind the state of the art.
20:02:26 <Cale> The GHC dev cycle and the Ubuntu dev cycle are almost optimally out of sync.
20:02:40 <seafood_> dons: You mention a while back (a year or two?) that some guys had use WASH plus custom hacks for a site. What was the site?
20:03:01 <Cale> It seems a new GHC comes out less than a month after the Ubuntu freeze every 6 months.
20:03:30 <sclv> There's only three real categories -- chunks-style dumb as a doorknob ones, ones that eventually bleed in pretty much everything (i.e. erb/jsp-like) and then I think stringtemplate stands pretty much alone as a functional-style carefully crippled one.
20:03:32 <stepcut> Cale: yeah, that is why we (seereason) have our own repo
20:04:08 <sclv> seafood_: http://lambda-the-ultimate.org/node/2315
20:04:13 <lambdabot> Title: Haskell web store | Lambda the Ultimate
20:06:02 <rwbarton> Speaking of Ubuntu, has anyone packaged a recent cabal install for Ubuntu?  Because otherwise I will need to for the Google Code Jam onsite
20:06:06 <AlexSuraci> On another note, the only way I'd use html generation is if it correctly indented it and prettified it and everything.
20:06:22 <AlexSuraci> That's why I prefer templates, automated things so often get things wrong.
20:06:38 <sclv> I'd like to see a haskell appserver actually though... with a good pluggable and configurable standard deployment story.
20:07:48 <dons> rwbarton: do we even have ubuntu packagers?
20:08:05 <AlexSuraci> I'd work on one if I knew Haskell well enough (still reading through the Real World Haskell book here).
20:08:35 <rwbarton> Beats me, I was just wondering if someone had produced a .deb for personal/company-wide/whatever use
20:09:11 <AlexSuraci> sclv: Are there any (non-Haddock) docs on HStringTemplate?
20:09:14 <dons> yeah. i'm sure that's the case. the debian guys are somewhat organised.
20:09:33 <rwbarton> Yes, I should take a look at debian experimental
20:09:49 <mmorrow> sweetness. i just darcs got this: http://braintreehemp.com.au/www.braintreehemp.com.au-WASH/
20:09:50 <lambdabot> Title: Index of /www.braintreehemp.com.au-WASH
20:10:01 <AlexSuraci> ah, I think I found it
20:10:02 <dons> or just use Arch, 552 haskell packages, ready to go :-)
20:10:03 <sclv> AlexSuraci: I put a bit on my blog -- but mainly the webpage for StringTemplate itself (stringtemplate.org) is the go-to reference from grammar, etc. the api itself is pretty simple.
20:10:14 <dons> and maintainers that actually want haskell to work on the distro for real world use.
20:10:42 <rwbarton> dons: Well, google is providing Ubuntu machines and 30 minutes to customize them, so that might be tricky :)
20:11:54 <bos> i think that the ubuntu packagers will pull their thumbs out if their users request it.
20:12:34 <Nafai> I should figure out who to complain too :)
20:13:25 * bos dons going a couple of rounds with tim s to tune the wording of his endorsement.
20:13:57 <bos> meh, where's "/msg" when you need it.
20:14:15 <mmorrow> haha
20:15:36 <dons> heh
20:17:59 <waynemokane> if I have a list of Maybe somethings, how can I build from that a list of all the elements that are Just
20:18:11 <waynemokane> so... basically     :: [Maybe t] -> [t]
20:18:34 <dmwit> :t catMaybes
20:18:35 <lambdabot> forall a. [Maybe a] -> [a]
20:18:44 <dmwit> ?hoogle [Maybe t] -> [t]
20:18:44 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:18:45 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:18:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:18:45 <ddarius> @hoogle [Maybe a] -> [a]
20:18:46 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:18:46 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:18:47 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:19:10 <bos> i think that the chapter on performance tuning in RWH is very good.
20:20:15 <Olathe> @hoogle Maybe a -> [a] -> [Maybe a]
20:20:15 <waynemokane> oh perfect... thanks everyone, also thanks for pointing out the hoogle command
20:20:15 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
20:20:15 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
20:20:15 <lambdabot> Data.Dynamic dynApply :: Dynamic -> Dynamic -> Maybe Dynamic
20:20:25 <Olathe> bzzt
20:21:05 <ddarius> Why can't other fields have as much freely available material as CS?
20:21:33 <bos> fewer stallmans.
20:21:58 <rwbarton> Other fields have been around longer, before it was easy to make things freely available?
20:22:05 <bos> the open access movement for other sciences isn't even a decade old.
20:22:37 <dmwit> Olathe: What would you want that to do?
20:22:52 <Olathe> Heheh, to give only functions with the type I gave.
20:23:01 <Olathe> It's not that important, though.
20:23:07 <Olathe> Since there probably are none.
20:23:20 <mgsloan> :t map Just
20:23:21 <lambdabot> forall a. [a] -> [Maybe a]
20:23:32 <mgsloan> err
20:23:33 <mgsloan> nevermind
20:23:36 <bos> and academic publishers who handle computer science are at least as lame and regressive as for other fields. look at ACM and IEEE's copyright assignment policies, which are just asinince and 13th-century.
20:23:44 <bos> er, asinine.
20:23:54 <dmwit> :t const (map Just) :: Maybe a -> [a] -> [Maybe a]
20:23:55 <lambdabot> forall a. Maybe a -> [a] -> [Maybe a]
20:24:07 <Olathe> @djinn Maybe a -> [a] -> [Maybe a]
20:24:07 <lambdabot> Error: Undefined type []
20:24:19 <dmwit> ?djinn-env
20:24:19 <lambdabot> data () = ()
20:24:19 <lambdabot> data Either a b = Left a | Right b
20:24:19 <lambdabot> data Maybe a = Nothing | Just a
20:24:19 <lambdabot> data Bool = False | True
20:24:19 <lambdabot> data Void
20:24:21 <lambdabot> type Not x = x -> Void
20:24:23 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:24:33 <dmwit> ?help djinn
20:24:33 <lambdabot> djinn <type>.
20:24:33 <lambdabot> Generates Haskell code from a type.
20:24:33 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:24:39 <Olathe> @pl \_ xs -> map Just xs
20:24:39 <lambdabot> const (map Just)
20:24:39 <dmwit> ?list
20:24:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:25:03 <dmwit> ?djinn-add data List a = Nothing | Cons a (List a)
20:25:03 <lambdabot> Error: Recursive types are not allowed: List
20:25:07 <dmwit> ah, too bad
20:25:11 <Olathe> For a list, do @ in private.
20:25:52 <dmwit> Sneaky, but not as helpful as ?list.
20:26:05 * Olathe sneaks away.
20:26:46 <dancor> it seems like djinn is a coq-subset; can coq do djinn-generations with lists?
20:27:58 <dancor> also doesn't the wheelreinvention there bother anyone
20:28:18 <Olathe> As long as it's not me reinventing the wheel, not really.
20:28:28 <dancor> hah yeah, it's just more choices
20:28:43 * dancor changes windowmanagers again
20:41:48 <mmorrow> @djinn  ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
20:41:48 <lambdabot> f a b = a (\ c _ -> b c) b
20:42:09 <mmorrow> @src callCC
20:42:09 <lambdabot> Source not found. That's something I cannot allow to happen.
20:42:47 <mmorrow> @djinn  ((a -> ((r->s)->s)) -> ((r->r)->r)) -> ((a->r)->r)
20:42:47 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
20:44:02 <Olathe> @type f a b = a (\ c d -> d (b c)) (\ e -> e)
20:44:02 <lambdabot> parse error on input `='
20:44:08 <Olathe> @type \a b - a (\ c d -> d (b c)) (\ e -> e)
20:44:08 <lambdabot> parse error on input `-'
20:44:11 <Olathe> @type \a b -> a (\ c d -> d (b c)) (\ e -> e)
20:44:12 <lambdabot> forall t t1 t2 t3 t4. ((t -> (t1 -> t2) -> t2) -> (t3 -> t3) -> t4) -> (t -> t1) -> t4
20:44:23 <mmorrow> @type cwcc
20:44:24 <lambdabot> Not in scope: `cwcc'
20:44:42 <ddarius> @src Cont callCC
20:44:43 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
20:46:45 <mmorrow> @let shift f = Cont $ \k -> runCont (f $ Cont . flip id . k) id
20:46:46 <lambdabot>  Defined.
20:47:04 <mmorrow> sup dolio
20:47:20 <dolio> Not much.
20:47:28 <mmorrow> nice
20:49:41 <mmorrow> > shift (\k -> k 1 >>= k) `runCont` (*2)
20:49:42 <lambdabot>       Ambiguous occurrence `shift'
20:49:42 <lambdabot>      It could refer to either `L.shift', d...
20:49:49 <mmorrow> > L.shift (\k -> k 1 >>= k) `runCont` (*2)
20:49:51 <lambdabot>   4
20:49:56 <dolio> @type shift
20:49:57 <lambdabot>     Ambiguous occurrence `shift'
20:49:57 <lambdabot>     It could refer to either `L.shift', defined at <local>:1:0
20:49:57 <lambdabot>                           or `Data.Bits.shift', imported from Data.Bits
20:50:02 <mmorrow> @let shiftCC f = Cont $ \k -> runCont (f $ Cont . flip id . k) id
20:50:03 <lambdabot>  Defined.
20:50:10 <mmorrow> > shiftCC (\k -> k 1 >>= k) `runCont` (*2)
20:50:11 <lambdabot>   4
20:50:39 <mmorrow> i can't remember reset of the top of my head
20:50:51 <dolio> Hmm...
20:50:54 * mmorrow digs it up
20:51:19 <dolio> \m -> return $ m `runCont` id ?
20:51:31 <dolio> @type \m -> return $ m `runCont` id
20:51:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Cont a a -> m a
20:51:34 <mmorrow> reset = Cont . flip id . runCont id
20:51:38 <Olathe> @src runCont
20:51:38 <lambdabot> Source not found. You untyped fool!
20:51:41 <mmorrow> err, flippef
20:51:44 <mmorrow> gah
20:51:46 <Olathe> I feel so untyped.
20:52:01 <mmorrow> @type Cont . flip id . flip runCont id
20:52:02 <lambdabot> forall c a. Cont a a -> Cont c a
20:52:26 <mmorrow> err
20:52:44 <mmorrow> i think that's it
20:52:48 <mmorrow> @type reset
20:52:49 <lambdabot> Not in scope: `reset'
20:52:58 <dolio> That looks like the right type.
20:53:00 <Olathe> > sin pi
20:53:01 <lambdabot>   1.2246467991473532e-16
20:53:02 <mmorrow> @let reset = Cont . flip id . flip runCont id
20:53:02 <Olathe> Eww
20:53:03 <lambdabot>  Defined.
20:53:08 <Olathe> > sin pi == 0
20:53:09 <lambdabot>   False
20:53:25 <dolio> Not an IEEE fan?
20:53:31 <Olathe> Heheh, no.
20:54:05 <mmorrow> @src Cont runCont
20:54:05 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:54:12 <mmorrow> @src (>>=) Maybe
20:54:13 <lambdabot> Source not found. Do you think like you type?
20:54:17 <mmorrow> @src Maybe (>>=)
20:54:18 <lambdabot> (Just x) >>= k      = k x
20:54:18 <lambdabot> Nothing  >>= _      = Nothing
20:54:24 <mmorrow> @src Cont (>>=)
20:54:24 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
20:54:53 <mmorrow> @src Cont
20:54:53 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
20:55:21 <mmorrow> @src Cont mfix
20:55:22 <lambdabot> Source not found. Where did you learn to type?
21:05:13 <Olathe> > 10^12 `div` 6000000000
21:05:14 <lambdabot>   166
21:45:45 <sandbox> having a bit of trouble building hmatrix, where does the function "trivial" come from?
21:46:00 <sandbox> used in nullspaceProp
21:48:06 <ac> how do I do incremental drawing using cairo/gtk2hs? AFAICT the whole drawing area's redrawn on every call to renderWithDrawable
21:49:12 <b\6> is there a Show for PortID hiding out somewhere? PortID/PortNumber seems pretty annoying.
21:50:31 <dmwit> On new GHC's you should be able to derive Show separately.
21:50:43 <dmwit> Also, it doesn't look like it would be a hard instance to write.
21:51:01 <dmwit> ac: You can keep your drawable around and use it as a surface.
21:51:27 <b\6> dmwit: yeah, easy to write, but ghc complains about it being incomplete.
21:51:34 <dmwit> incomplete?
21:51:42 <dmwit> There's three constructors, you know.
21:51:44 <ac> dmwit: and presumably that's a lot faster?
21:52:12 <dmwit> ac: Well, you can "paint" the whole thing and use it as a base for incremental drawing.
21:52:13 <ac> dmwit: well obviously if you don't have to redraw everything. What does that look like?
21:52:14 <b\6> dmwit: yeah. i guess i thought it was weird to have to write the other ones. :/
21:52:40 <dmwit> ac: Check out the source for the Cairo clock, I believe it uses such a technique to cache the clock face.
21:52:52 <ac> ah cool. Nothing better than an example program
21:53:07 <dmwit> b\6: It seems a little weird that they didn't just tack "deriving Show" on there for convenience, yeah.
21:53:26 <dmwit> b\6: I guess the idea is that the "Read" instance isn't so likely to get you a valid PortID, maybe?
21:54:50 <b\6> dmwit: dunno. i just made part of my configuration a PortID made from PortNumber. i just want to say "connecting to %s:%d" or whatever but the info's locked up in PortID.
21:58:21 <dmwit> sandbox: I'm not sure I can help, but I know how frustrating it can be to be ignored, so... what version are you trying to install?
21:58:39 <dmwit> Have you tried "cabal install"ing it?
22:05:59 <ac> here's the magick line I need it looks like: hild's play: the XO-2 next generation laptop
22:06:02 <ac> The XO-2 machine will be developed by the team behind the One Laptop per Child project. It will have two touch-sensitive screens and be about half the size of the original, iconic white-and-green XO device. Nicholas Negroponte, the founder of OLPC, also said the XO-2 will have a foldable book-like feel to it.
22:06:07 <ac> ah fuck
22:06:20 <ac> setSourceSurface background 0 0
22:08:17 <ac> (though I'm not clear what type "background" is)
22:08:37 <dmwit> ?tell dcoutts You might want to bug the Hoogle guy about letting Gtk2Hs' Hoogle work again.
22:08:37 <lambdabot> Consider it noted.
22:09:39 <dmwit> ac: http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
22:09:40 <ac> ah, Surface
22:09:51 <lambdabot> Title: Graphics.Rendering.Cairo, http://tinyurl.com/266njv
22:09:52 <dmwit> setSourceSurface :: Surface -> Double -> Double -> Render ()
22:09:57 <dmwit> So, yeah, Surface. =)
22:09:58 <ac> dmwit: yeah
22:12:12 <ac> ah that's cool. I can make this way faster. It works great on my normal computer, but it's too sluggish on my XO :-|
22:12:50 <dmwit> Great!
22:13:31 <ac> won't look as pretty as hsclock though
22:14:42 <dmwit> "trick is to avoid gradients and to cache things that don't change frequently, compositing is really fast."
22:14:57 <dmwit> ac: In case that helps prioritize your speed-hacking efforts.
22:15:34 <ac> dmwit: yeah, I only need to draw five to ten lines in a tight loop
22:16:40 <dmwit> ac: So, what are you hacking on?
22:16:42 <ac> going to need another IORef (or add another slot to my current state record)
22:16:47 <ac> it's a chess clock
22:17:05 <ac> with a couple crazy features
22:17:12 <dmwit> Ah, neat!
22:17:20 <ac> I'm sick of my retarded JavaScript one
22:17:43 <ac> When I'm done maybe I can get some help putting it in hackage?
22:17:56 <dmwit> You should definitely make it publically available, I'd love to have a game clock for games of go at school.
22:18:03 <dmwit> yeah!
22:18:17 <dmwit> It's really easy to put things on Hackage, I just did it for the first time last week.
22:18:28 <b\6> is it easy to accidentally put things on hackage?
22:18:31 <ac> ah cool. You play Go with a clock? I've never done that. Arimaa and Chess definitely, but Go tends to move pretty quickly
22:18:44 <dmwit> You might want to apply for an account now, it took me a day or two to get that straightened out.
22:18:46 <ac> b\6: lol
22:18:55 <dmwit> ac: You can play blitz games of *any* board game. ;-)
22:19:33 <dmwit> ac: Have you ever worked with Cabal before?
22:19:58 <ac> dmwit: Cabal? Just on the user's end
22:20:20 <dmwit> ah
22:20:33 <ac> I've got a per move time feature, so if you run: clock 5m+3s 5m+3s # you get an extra 3 seconds for every move, but unless you add "-c" it's not cumulative, so you never get more than 5 minutes and 3 seconds total
22:20:42 <dmwit> It's pretty easy from the development end, too; I think they even have a template on their site that you can just grab and fill in.
22:20:57 <dmwit> ac: Ah, Fischer time?
22:21:12 <ac> dmwit: that's what that's called?
22:21:19 * dmwit nods
22:21:39 <dmwit> Though usually it would just be capped at 5:00 if it was capped at all.
22:21:42 <ac> if it's cumulative it just adjusts the hands, otherwise it shows the extra move time with a second set of dotted hands
22:22:58 <ac> do you think it's worth adding code for a GUI for entering the times and setting options? I'd never use it...
22:23:04 <ac> and it'd be a pain
22:24:24 <ac> I'm thinking if one's nerdy enough to be using a game clock, they're nerdy enough to prefer command line options
22:25:12 <b\6> is there nicer string formatting stuff than printf?
22:25:38 <mmorrow> Text.PrettyPrint ?
22:25:59 <mmorrow> what're you trying to format?
22:26:22 <mmorrow> syntax/similar? or numbers?
22:26:45 <mmorrow> only 16 more and this can be 20 questions!
22:27:16 <b\6> like "did %d whatevers".
22:27:29 <dmwit> ac: CLI is fine, especially at the beginning.
22:28:20 <dmwit> b\6: I suggest you print a dictionary and a format string and pipe it to python's print statement. ;-)
22:28:26 <mmorrow> b\6: oh. personally i'd do (\d -> intercalate ["did",show d,"whatevers"])
22:28:34 <mmorrow> oops
22:28:41 <mmorrow> (\d -> intercalate " " ["did",show d,"whatevers"])
22:28:55 <dmwit> \d -> unwords ["did", show d, "whatevers"]
22:29:11 <mmorrow> (\d -> intercalate "," ["did",show d,"whatevers"])
22:29:21 <dmwit> eww
22:29:25 <mmorrow> heh
22:29:35 <dmwit> > intercalate "," ["did", show 3, "cycles"]
22:29:36 <lambdabot>   "did,3,cycles"
22:29:47 <dmwit> You might as well
22:29:55 <dmwit> > ("did", 3, "cycles") -- uuuugly
22:29:56 <lambdabot>   ("did",3,"cycles")
22:30:24 <mmorrow> > parens . vcat . punctuate comma . fmap text $ fmap (:[]) ['a'..'z']
22:30:25 <lambdabot>   (a,
22:30:25 <lambdabot>   b,
22:30:25 <lambdabot>   c,
22:30:25 <lambdabot>   d,
22:30:25 <lambdabot>   e,
22:30:27 <lambdabot> [11 @more lines]
22:30:50 <mmorrow> nice, it does newlines now apparently
22:31:24 <sjanssen> hmm, is that really a good thing?
22:31:46 <mmorrow> well not if it's a bad thing.
22:32:21 <sjanssen> > vcat $ repeat 'x'
22:32:22 <lambdabot>   Couldn't match expected type `Doc' against inferred type `Char'
22:32:39 <mmorrow> > vcat . fmap text $ repeat 'x'
22:32:39 <sjanssen> > vcat $ repeat (text "x")
22:32:40 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
22:32:41 <lambdabot>  Terminated
22:32:50 <mmorrow> > vcat . fmap text $ replicate 1000 'x'
22:32:51 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
22:32:57 <mmorrow> > vcat . fmap text $ replicate 1000 "x"
22:32:59 <lambdabot>   x
22:32:59 <lambdabot>  x
22:32:59 <lambdabot>  x
22:32:59 <lambdabot>  x
22:32:59 <lambdabot>  x
22:33:01 <lambdabot> [21 @more lines]
22:33:07 <mmorrow> > hcat . fmap text $ replicate 1000 "x"
22:33:08 <lambdabot>   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
22:33:22 <sjanssen> oh, I'm sure pretty is too strict for 'vcat . repeat'
22:33:33 <mmorrow> hmm, interesting
22:33:49 <mmorrow> > vcat . fmap text $ replicate 40 (replicate 78 'x')
22:33:50 <lambdabot>   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
22:33:58 <mmorrow> > vcat . fmap text $ replicate 40 (replicate 40 'x')
22:33:59 <lambdabot>   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
22:34:00 <lambdabot>  xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
22:34:29 <mmorrow> hmm, it seems like it'll only print 80 chars either way
22:34:40 <mmorrow> err, less maybe
22:35:11 <dmwit> probably count(x)+count(\n)=80 or whatever the constant is.
22:35:54 <mmorrow> oh, it's probably counting the spacing it insert at the beginning of each line
22:38:40 <mmorrow> > parens . vcat . punctuate comma . fmap (nest 2 . text) $ fmap (:[]) ['a'..'z']
22:38:41 <lambdabot>   (a,
22:38:41 <lambdabot>   b,
22:38:41 <lambdabot>   c,
22:38:41 <lambdabot>   d,
22:38:41 <lambdabot>   e,
22:38:43 <lambdabot> [11 @more lines]
22:39:16 <bos> @src concatMap
22:39:16 <lambdabot> concatMap f = foldr ((++) . f) []
22:39:49 <mmorrow> > nest 2 (text "a" $+$ nest 2 (text "b"))
22:39:50 <lambdabot>     a
22:39:51 <lambdabot>      b
22:41:19 <mmorrow> @type foldr (\b a -> b $+$ nest 2 (text a)) empty (map (:[]) ['a'..'z'])
22:41:20 <lambdabot>     Couldn't match expected type `String' against inferred type `Doc'
22:41:20 <lambdabot>       Expected type: String
22:41:20 <lambdabot>       Inferred type: Doc
22:41:38 <mmorrow> @type foldr (\b a -> b $+$ nest 2 (text a)) [] (map (:[]) ['a'..'z'])
22:41:39 <lambdabot>     Couldn't match expected type `String' against inferred type `Doc'
22:41:39 <lambdabot>       Expected type: String
22:41:39 <lambdabot>       Inferred type: Doc
22:43:00 <mmorrow> > foldr (\a b -> nest 2 b $+$ (text a)) empty (map (:[]) ['a'..'z'])
22:43:01 <lambdabot>       Ambiguous occurrence `empty'
22:43:01 <lambdabot>      It could refer to either `Control.App...
22:43:13 <mmorrow> > foldr (\a b -> nest 2 b $+$ (text a)) Text.PrettyPrint.empty (map (:[]) ['a'..'z'])
22:43:14 <lambdabot>       Not in scope: `Text.PrettyPrint.empty'
22:43:24 <mmorrow> grrrr
22:43:38 <mmorrow> > foldr (\a b -> nest 2 b $+$ (text a)) (text []) (map (:[]) ['a'..'z'])
22:43:39 <lambdabot>                       ...
22:44:08 * mmorrow beats up on the cat to let off some steam
22:44:57 <mmorrow> > foldr (\a b -> text a $+$ nest 2 b) (text []) (map (:[]) ['a'..'z'])
22:44:58 <lambdabot>   a
22:44:58 <lambdabot>    b
22:44:58 <lambdabot>      c
22:44:58 <lambdabot>        d
22:44:58 <lambdabot>          e
22:45:00 <lambdabot> [3 @more lines]
22:57:47 <ac> meow
23:02:40 <bos> @seen ketil
23:02:41 <lambdabot> I saw ketil leaving #haskell 57m 25s ago, and .
23:23:44 <mmorrow> timeout 2000 (threadDelay 1500 >> return 0)
23:31:40 <mmorrow> timeout 1000000 (takeMVar =<< newEmptyMVar)
23:36:12 <sandbox> @hoogle trivial
23:36:12 <lambdabot> Test.QuickCheck trivial :: Testable a => Bool -> a -> Property
23:37:06 <sandbox> @src trivial
23:37:06 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:37:25 <sandbox> anyone know what version trivial comes from?
23:37:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/QuickCheck/src/Test-QuickCheck.html#trivial
23:37:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5vqmlo
23:38:11 <sandbox> thanks
23:38:29 <Cale> The version on hackage ought to have it, I would think.
23:38:41 <Cale> At the very least, the version that comes with GHC does.
23:42:07 <tibbe_> @hackage benchpress
23:42:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/benchpress
23:46:29 <sandbox> @hoogle defaultConfig
23:46:29 <lambdabot> Test.QuickCheck defaultConfig :: Config
23:46:29 <lambdabot> Distribution.Simple.Setup defaultConfigFlags :: ProgramConfiguration -> ConfigFlags
23:47:03 <sandbox> will configure --user search user modules before system in build?
23:53:21 <mmorrow> i'm not sure the answer to that, but it's choice of one package over another may not depend on the order it finds each at all
23:53:47 <mmorrow> or it may, but i guess i'm saying that's another variable
