00:00:53 <mmorrow> you could almost have no idea what any functions do, but know there types, and still have a pretty good chance of doing something useful
00:01:02 <mmorrow> s/there/their/
00:01:19 <newbieyu> o_o
00:01:25 <newbieyu> so there is no way to fix it?
00:01:35 <mmorrow> because the types tell you how you can combine functions
00:01:55 <mmorrow> what's the definition of Quad?
00:02:23 <mauke> newbieyu: huh?
00:03:00 <mauke> if you're referring to the show thing, there are two solutions
00:03:02 <mmorrow> you have to make something of type (Quad f g), then pass that to firstTwo
00:03:30 <newbieyu> definition: ata Quad a b = Q a a b b ?
00:03:35 <newbieyu> definition: data Quad a b = Q a a b b ?
00:03:56 <mxc> dons, bos, et al - congrats, putting my order in tonight
00:04:06 <mmorrow> ok, so     (Q 1 4 pi pi) :: Quad Int Double
00:04:19 <mmorrow> let a = Q 1 4 pi pi in firstTwo a
00:05:35 <mmorrow> (Q "asdf" "qwerty" () ()) :: Quad String ()
00:06:30 <mmorrow> (Q (Q () () () ()) (Q () () () ()) () ()) :: Quad (Quad () ()) ()
00:09:57 <newbieyu> o_O
00:13:21 <newbieyu> mauke/mmorrow how is it?
00:13:37 <mauke> what
00:13:43 <newbieyu> the code above
00:13:53 <bringert> dons: you still awake?
00:15:18 <mxc> does anyone use GHC with preprocessing (say, by DRiFT) and VIM in quickfix mode?
00:17:18 <newbieyu> mauke/mmorrow: are you stil there
00:17:52 <mauke> yes
00:18:08 <newbieyu> http://www.mibbit.com/pb/cthLCd
00:18:09 <lambdabot> Title: Mibbit: PasteBin
00:18:26 <mauke> o_O
00:18:34 <newbieyu> so how is it
00:18:52 <mauke> weird
00:19:24 <mauke> you could make that compile by removing the parens around (Q1 a b) (Q2 c d)
00:19:44 <newbieyu> tried
00:19:48 <mauke> but why have Quad2 at all? it's the same as Quad1, which is just a pair
00:20:15 <newbieyu> to make it different o_o?
00:20:27 <mauke> it isn't different
00:20:47 <newbieyu> the coding is kinda diverting to something else
00:21:05 <newbieyu> i just wanna get the 2 thing be the same element,
00:21:21 <mauke> like data Quad a b = Q a a b b
00:21:23 <mauke> ?
00:21:25 <newbieyu> and display the first 2
00:21:28 <newbieyu> yeah
00:22:29 <newbieyu> i'll talk later gtg T_T
00:22:39 <mauke> you already had that in http://www.mibbit.com/pb/EXBbcH
00:22:40 <lambdabot> Title: Mibbit: PasteBin
00:42:44 <RayNbow> hmm... why is an instance declaration like "instance Bounded2D (Tree Shape) where" not allowed in H98?
00:45:11 <BeelsebobWork> because H98 is very strict about what kinds of instance declarations it allows
00:45:23 <BeelsebobWork> it's rather overly conservative to preserve type-checker termination
00:45:41 <RayNbow> ah
00:55:20 <quicksilver> RayNbow: however, FlexibleInstances is widely considered a pretty safe extension.
00:55:50 <quicksilver> RayNbow: on the other handed, having a polymorphic instance for (Tree a) *and* a monomorphic one for (Tree Shape) is more controversial.
00:56:39 <quicksilver> BeelsebobWork: took my hard copy of reactive.pdf on the train and re-read it again. I think one of the things which wasn't clear to me before was the divide between 'this part is a useful formalism' and 'this part is a concrete implementation'
00:56:59 <BeelsebobWork> quicksilver: yeh -- that's very unclear to me when I read the paper too
00:57:09 <BeelsebobWork> as I said, it's got about 3 papers in it
00:57:24 <BeelsebobWork> it could do with one paper on "here's this cool interface for FRP"
00:57:28 * quicksilver nods
00:57:35 <BeelsebobWork> another on "here's how you formalise said interface nicely"
00:57:44 <BeelsebobWork> and another on "here's how you implement said interface efficiently"
00:57:47 <quicksilver> Another thing which appears to be missing is 'this is how you would write a 'main' action'
00:58:33 <BeelsebobWork> quicksilver: yep, conal approaches it very much from a "wouldn't it be cool if the world were functional, and I didn't have to have main's type be IO ()"
00:58:39 <quicksilver> thinking it over it seems to me that a main action is likely to be a purely event driven part (:: Event (IO ())) and something like a display callback (Behaviour a, a -> IO ())
00:59:03 <quicksilver> and the 'harness' is responsible for calling the display callback either n times per second, or as often as possible.
00:59:07 <BeelsebobWork> I think the intention is actually to provide something like interact
00:59:42 <BeelsebobWork> you give it something pure that accepts events and spits out stuff, and it drives it for you
01:01:09 <quicksilver> how do we replace 'putStrLn' then?
01:01:26 <quicksilver> (to take a trivial example, but realy everything of type a -> IO () in the standard lib)
01:01:47 <BeelsebobWork> some way as you don't need to use putStrLn if you use interact
01:02:02 <quicksilver> yes, but interact is a very simple model.
01:02:14 <BeelsebobWork> only because it restricts you to String -> String
01:02:17 <quicksilver> consider a more complex program which prints stuff out, writes to files, opens network sockets
01:02:22 <quicksilver> how do you picture that?
01:02:44 <BeelsebobWork> so you end up with Behaviors describing the program output to each of them
01:02:51 <BeelsebobWork> or Reactives or Events if you so chose
01:02:56 <Cale> The trouble is how to have a model which can be extended by libraries to handle new kinds of I/O.
01:03:12 <BeelsebobWork> quicksilver: this is the stuff I'm most cloudy on
01:03:19 <BeelsebobWork> you're best off asking luqui about it tbh
01:03:29 <BeelsebobWork> (he's hooking reactive up to the legacy world)
01:04:34 <quicksilver> If FRP is to be interesting to me, there has to be a half-way solution that lets me use it now.
01:04:46 <Cale> I'm not thoroughly convinced that it is just the "legacy" world which is a problem...
01:04:58 <quicksilver> I don't want to wait for a whole new runtime :)
01:05:15 <quicksilver> Cale: I have a feeling this is the open ADT problem.
01:05:19 <quicksilver> Cale: or, that that is part of it.
01:05:39 <Cale> Well, perhaps...
01:06:29 <quicksilver> you want Events and what their dual is (Sinks?) to be abstract, global entities.
01:06:33 <quicksilver> like the constructors of an ADT.
01:06:34 <cjs> 最高！俺は
01:06:46 <quicksilver> but you want new libraries to be able to add new kinds of Event and Sink.
01:06:51 <cjs> 日本語も出来る。
01:07:13 <quicksilver> much like the famous model of IO where GetChar and PutChar are constructors of an ADT>
01:07:48 <RayNbow> cjs: I can't read kanji :p
01:08:22 <RayNbow> I do recognise 日 and 出 though :p
01:08:46 <Cale> cjs: こんばんは
01:09:55 <RayNbow> お早う、Ｃａｌｅさん
01:10:16 <cjs> Hey, I think that deserves an おめでとう, really. But anyway....I digress....
01:12:24 <quicksilver> BeelsebobWork: I agree with conal's reasoning up until the use of Future as a key implementation primitive.
01:12:35 <quicksilver> It will take more work to sell 'Future' to me.
01:12:40 <quicksilver> blocking pure values freak me out.
01:12:40 <BeelsebobWork> hmm?
01:12:45 <BeelsebobWork> oh, I see
01:13:07 <BeelsebobWork> well, they only block when you actually use the time axis
01:13:13 <BeelsebobWork> but yeh, I get what you're saying
01:13:17 <quicksilver> I'd be inclined to do something more like data Event a = { available :: IO Bool, getNextEvent :: IO a }
01:13:21 <Cale> 私も日本語を勉強する　頑張ります!
01:13:35 <RayNbow> hmm... ghci is slow after Windows has swapped most of its pages out of memory...
01:13:36 <quicksilver> then the blocking part is clearly inside IO where it belongs.
01:13:47 <BeelsebobWork> that sounds like an ugly hack to me
01:13:53 <BeelsebobWork> and a good way to spread the IO monad everywhere
01:13:53 <quicksilver> (actually getNextEvent :: IO (Time,a)
01:14:04 <quicksilver> not everywhere no, just part of the implementation.
01:14:13 <BeelsebobWork> everywhere you want to use Events
01:14:22 <quicksilver> no, it wouldn't propagate through the Event
01:14:26 <quicksilver> that's the point about Event being abstract
01:14:36 <BeelsebobWork> oh, I see
01:14:45 <quicksilver> it would only be visible in the 'harness'
01:14:53 <quicksilver> which is part of the implementation detail.
01:15:00 <BeelsebobWork> yeh
01:15:02 <quicksilver> Your interact-like pure toplevel would have no IO.
01:15:09 <BeelsebobWork> it still wouldn't be a beautiful implementation to me
01:15:21 <mapreduce> Cale: What's that, new notation for functors?
01:15:30 <quicksilver> well it's using the pure encapsulation we currently have (IO) to implement a better pure encapsulation (Reactive)
01:15:37 <quicksilver> there is a certain logic to that.
01:17:39 <quicksilver> @tell luqui wanted to talk to you about reactive + IO when you have some time.
01:17:52 <quicksilver> @bot
01:17:55 <quicksilver> @sigh
01:18:14 <BeelsebobWork> @poke-with-shapr-stick
01:18:27 <BeelsebobWork> oops, that was meant to be sharp, but shapr actually works
01:18:27 * Twey grooooooans.
01:18:31 <Twey> Hahaha
01:18:40 <ejt> quick straw poll: how many people line up '->'s ?
01:18:42 <Twey> That wasn't an intentionally terrible pun?
01:18:44 <Twey> You're forgiven
01:18:47 <Twey> ejt: *raise hand*
01:18:59 <quicksilver> preflex: tell luqui wanted to talk to you about reactive + IO when you have some time.
01:18:59 <preflex>  Consider it noted.
01:19:01 <BeelsebobWork> Twey: it was an especially god terrible pun though -- shame about the lack of intention
01:19:08 <Twey> Haha, indeed
01:19:09 <ejt> Twey: can haskell-mode in emacs help do that ?
01:19:13 <quicksilver> ejt: yes.
01:19:17 <quicksilver> ejt: M-x align-regexp
01:19:20 <Twey> ejt: I use vim :)
01:19:24 <quicksilver> (nothing to do with haskell-mode actually)
01:19:27 <quicksilver> just a core emacs feature.
01:19:28 <ejt> ah, thx quicksilver
01:19:39 <Cale> mapreduce: New notation?
01:20:01 <Cale> ejt: I line up ->'s :)
01:20:04 <flux> quicksilver, ah, thank you!
01:20:04 <BeelsebobWork> Cale: yes, we're gonna use famp, not fmap -- it gets ups in with the lamp croud
01:20:07 <BeelsebobWork> >.>
01:20:21 <quicksilver> flux: what for?
01:20:28 <flux> I've been thinking of writing that function for some time, but now I see that I don't need to
01:21:04 <mib_71rij547> boo
01:21:07 <mib_71rij547> :D
01:21:13 <quicksilver> ;)
01:21:47 <ayu08> hi quick, hi twey
01:21:48 <mapreduce> Cale: "<Cale> 私も日本語を勉強する　頑張ります!"
01:21:57 <Twey> Hi ayu08
01:22:12 <ayu08> how do i check someone if he or she is in this haskell channel?
01:22:13 <Cale> mapreduce: That was some of my attempts at Japanese :)
01:22:23 <Twey> Check your client's userlist?
01:22:38 <Cale> ayu08: You look in the list that your client usually displays at the side...
01:22:46 <afd8>  /whois user shows their channels
01:22:49 <cjs> @seen Cale
01:23:02 <cjs> Ack! Lambdabot is dead!
01:23:06 <Cale> oh!
01:23:10 <Cale> I'm on it then :)
01:23:14 <RayNbow> @bot
01:23:21 <ayu08> how do i revive the boat?
01:23:35 <chrisdone> I'm in here!
01:23:46 <ayu08> why there isnt any sheepdabot
01:23:47 <afd8> anyone know if hmatrix has row reduction / gaussian elim functions?
01:23:56 <Cale> Heh, we should have a lambdaboat
01:24:06 <ayu08> cowdabot :D
01:24:45 <quicksilver> all aboard the lambdaboat!
01:25:10 <chrisdone> @choo choo
01:25:14 <lambdabot> choo
01:25:21 <chrisdone> O_O!
01:25:22 <ayu08> aseen lambdabot
01:25:27 <ayu08> @seen lambdabot
01:25:33 <lambdabot> Yes, I'm here. I'm in #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #
01:25:35 <davidL> @help choo
01:25:39 <lambdabot> haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
01:25:41 <ayu08> @seen cowdabot
01:25:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:25:45 <ayu08> @seen mauke
01:25:45 <Cale> afd8: certainly
01:25:51 <lambdabot> I haven't seen cowdabot.
01:25:57 <lambdabot> mauke is in #haskell. I don't know when mauke last spoke.
01:26:07 <ayu08> @seen mmorrow
01:26:13 <lambdabot> mmorrow is in #haskell, #ghc and #darcs. I don't know when mmorrow last spoke.
01:26:32 <afd8> Cale: thanks, do you happen to know which module? ive been looking but im blind i guess haha
01:26:36 <ayu08> hmm ok, anyways, i'll post up my question that i am having dfficulty
01:30:30 <Cale> afd8: I think lu will give you what you want, basically, along with a bunch of other stuff...
01:30:36 <ayu08> http://www.mibbit.com/pb/du8GyR
01:30:37 <lambdabot> Title: Mibbit: PasteBin
01:30:43 <ayu08> can someone take a look in my code?
01:31:16 <afd8> Cale: thanks
01:31:21 <Cale> ayu08: Q takes 4 parameters
01:31:39 <ayu08> yeah
01:31:41 <Cale> ayu08: also, patterns that bind variables are required to bind distinct variables
01:32:08 <Cale> ayu08: Further, the right hand side of your equation for firstTwo does not construct a list :)
01:32:24 <ayu08> i dont really understand with this line: also, patterns that bind variables are required to bind distinct variables
01:32:34 <ayu08> could explain a little more detail
01:32:41 <Cale> Well, you have a pattern  (Q a a) there
01:32:46 <Twey> ayu08: You have a function firstTwo (Q a a)
01:32:48 <ayu08> yup
01:32:55 <Twey> That means that both those 'a's have to have the same value
01:32:59 <Twey> Or the pattern match will fail
01:33:06 <Cale> (But that isn't even allowed)
01:33:20 <Twey> Really, Cale?  :-\
01:33:21 <Cale> It would mean that, if it were allowed at all.
01:33:26 <Twey> Why?
01:33:42 <ayu08> actually i wanted to make them both same data type. like Int Int String String
01:33:56 <Cale> Because that would require an Eq instance, I suppose. There isn't a great reason, but it does add more complexity to how pattern matching is done.
01:34:11 <Cale> ayu08: Things don't need to be the same in order to have the same type :)
01:34:28 <Cale> ayu08: You might be confusing the data constructor Q with the type constructor Quad
01:34:36 <Twey> Cale: Ah, true.
01:34:44 <quicksilver> google's propaganda claims that precise garbage collection is faster.
01:34:48 * Twey didn't know that wasn't valid.
01:34:50 <quicksilver> that's interesting.
01:34:51 * Twey learns.
01:35:00 <Twey> Indeed, quicksilver
01:35:04 <quicksilver> They appear to have indirected all their pointers.
01:35:04 <Twey> Well
01:35:13 <quicksilver> I thought conventional wisdom was that made things slower...
01:35:15 <Twey> I think it was 'safer' rather than 'faster'
01:35:24 <Twey> If I remember correctly
01:35:24 <quicksilver> (Apple used to indirect all their pointers)
01:35:50 <quicksilver> Hmm. perhaps 'faster' in the sense of 'we can do partial collections in a sensible way'
01:35:56 <quicksilver> so 'faster' == 'more responsive'
01:36:12 <Cale> ayu08: Does that help?
01:36:18 <ayu08> no -_-
01:36:27 <ayu08> i couldnt understand what you are trying to say
01:36:35 <Cale> ayu08: People always get stuck on this exercise... I think it's a problem with that book :)
01:36:49 <ayu08> i found it from YAHT yet another haskell tutorial
01:36:51 <Cale> firstTwo (Q x y z w) = ...
01:36:53 <Cale> yes
01:37:01 <Cale> That's how the pattern is supposed to look
01:37:13 <ayu08> Cale: you done that question before
01:37:13 <Cale> In fact, you could also have something like:
01:37:15 <ayu08> ?
01:37:21 <Cale> firstTwo (Q x y _ _) = ...
01:37:30 <Cale> Yeah, and helped lots of other beginners through it :)
01:37:34 <quicksilver> ayu08: yes, most regulars in this channel have seen that question quite a few times :)
01:37:41 <quicksilver> it is, as Cale says, a common sticky one.
01:38:45 <Cale> I think YAHT kind of falls down with regard to explaining type constructors and data constructors at that point.
01:38:56 <ayu08> hmm still doesnt work
01:39:03 <ayu08> data Quad a b = Q a a b b  firstTwo (Q x y _ _) = x y
01:39:21 <Cale> ayu08: Your new problem is that you're now applying x as a function to the argument y
01:39:30 <Cale> ayu08: rather than making a list of two elements :)
01:40:02 <ayu08> so should i put brackets ? like data Quad a b = Q a a b b  firstTwo (Q [x y _ _]) = [x y]
01:40:12 <ayu08> or comma o_o
01:40:35 <Cale> You have the stuff before the = sign okay :)
01:40:41 <Cale> firstTwo (Q x y _ _) = ...
01:40:52 <Cale> Do you recall how lists are built up?
01:41:02 <Cale> > [1,2,3]
01:41:03 <lambdabot>   [1,2,3]
01:41:08 <ayu08> x:y:z:[] ?
01:41:09 <Cale> > 1 : 2 : 3 : []
01:41:11 <lambdabot>   [1,2,3]
01:41:31 <Cale> You can either write   x : y : []  or more simply [x,y]
01:41:48 <ayu08> firstTwo Q[x,y,_,_] = x y ?
01:41:51 <Cale> no
01:42:21 <ayu08> o_o "
01:42:23 <Cale> The problem is the x y on the right hand side
01:42:57 <Cale> What does x y mean in Haskell?
01:43:10 <Cale> It means apply the function x to the value y
01:43:37 <Cale> So you want:
01:43:44 <Cale> firstTwo (Q x y _ _) = [x,y]
01:44:11 <ayu08> ok
01:44:15 <Cale> Which means to take the values matched by x and y and make a 2-element list from them
01:45:09 <Cale> Now, here's an interesting exercise... what type would the following function have? (You can always ask ghci if you can't figure it out :)
01:45:28 <Cale> mystery (Q f g x y) = [f x, g y]
01:45:48 <ayu08> what do you mean by following function o_o
01:46:01 <Cale> I mean the function "mystery" which I just wrote :)
01:46:49 <ayu08> you mean data type
01:47:15 <Cale> Yeah, what data type does mystery belong to?
01:47:45 <ayu08> im not sure o_o
01:48:04 <Cale> Okay, so let's reason about it a bit :)
01:48:42 <Cale> Because it's pattern matching against something which looks like (Q f g x y), it must take an argument of some Quad type.
01:48:45 <jsnx> ayu08: can you guess what the type of f is?
01:49:16 <ayu08> no , i have no idea
01:49:42 <jsnx> ayu08: can you tell whether it is a function or not?
01:50:05 <ayu08> i do not know whether its int bool or string
01:50:12 <jsnx> oh
01:50:17 <ayu08> for the right side or left side
01:50:23 <Cale> ayu08: f is none of those 3 :)
01:50:23 <jsnx> well, it can be more general than that :)
01:50:25 <ayu08> right side looks like a list
01:50:33 <Cale> that's good :)
01:50:51 <Cale> So it's taking something which is some kind of Quad and producing something which is some kind of list
01:51:13 <Cale> So we already know that the type of mystery looks something like  Quad (...) (...) -> [...]
01:51:24 <Cale> Where each of the ...'s needs to be filled in yet :)
01:52:27 <Cale> ayu08: On the right side we also have that f is being applied to x, right?
01:52:39 <Cale> whoops
01:58:31 <mib_s5qkio7o> testing
01:58:38 <mib_s5qkio7o> o_O
01:59:01 <ayu08> weird
01:59:04 <ayu08> hey Cale
01:59:10 <ayu08> is there something wrong with this irc
01:59:28 <ayu08> because i waited 5 minutes and there wasn't any reply from anyone here, restarted my irc
01:59:37 <Cale> I noticed that you disappeared...
01:59:47 <Cale> What was the last message of mine that you saw?
01:59:52 <ayu08> sorry I did not receive your message
02:00:05 <ayu08> jsnx	well, it can be more general than that   16:50	ayu08	right side looks like a list  16:50	Cale	that's good
02:00:08 <Cale> <ayu08> right side looks like a list
02:00:08 <Cale> <Cale> that's good :)
02:00:08 <Cale> <Cale> So it's taking something which is some kind of Quad and producing something which is some kind of list
02:00:08 <Cale> <Cale> So we already know that the type of mystery looks something like  Quad (...) (...) -> [...]
02:00:22 <Cale> <Cale> Where each of the ...'s needs to be filled in yet :)
02:00:37 <ayu08> ok
02:00:49 <Cale> Does that much make sense? :)
02:00:59 <Cale> mystery (Q f g x y) = [f x, g y]
02:01:14 <ayu08> Shouldn't it be Quad (..)(..)(..)(..) -> []
02:01:29 <Cale> no, because the type constructor Quad takes two type parameters
02:01:38 <Cale> data Quad a b = Q a a b b
02:01:59 <BeelsebobWork> ayu08: that line that Cale just showed specifies *two* things
02:02:10 <BeelsebobWork> 1) a *type* constructor called Quad, that takes two type arguments
02:02:23 <BeelsebobWork> 2) a *data* constructor called Q, that takes 4 value arguments
02:02:35 <Cale> Right :)
02:03:32 <Cale> There's an alternate newer notation for defining data types which some people find more intuitive... in that notation, that would be written:
02:03:37 <Cale> data Quad a b where
02:03:45 <jpcooper> hello
02:03:45 <Cale>    Q :: a -> a -> b -> b -> Quad a b
02:04:10 <jpcooper> could anyone tell me how to download the CVS version of haskell-mode, please? I don't have much experience with CVS, and thus can't really do anything with the CVS info given on the page.
02:04:16 <Cale> Which makes it clear that Q is something which takes four arguments, and produces something of type Quad a b
02:06:30 <BeelsebobWork> jpcooper: #cvs might be a better place to try -- Haskellers all use darcs
02:06:34 <BeelsebobWork> or git occasionally
02:06:54 <Cale> jpcooper: export CVSROOT=:pserver:anoncvs@cvs.haskell.org:/cvs; cvs login; cvs checkout fptools/CONTRIB/haskell-modes/emacs
02:06:58 <jpcooper> right, I thought that someone may have downloaded haskell-mode from cvs
02:07:04 <jpcooper> thanks, Cale
02:07:14 <Cale> If I'm reading it correctly anyway :)
02:07:30 <Cale> I haven't tried those commands myself, and I don't really know anything about CVS either :)
02:07:39 <jpcooper> it seems that a password is needed
02:07:48 <Cale> cvs
02:08:00 <Cale> (is the password)
02:08:01 <jpcooper> thanks a lot
02:08:53 * quicksilver is a Haskeller who uses bzr not darcs :P
02:09:18 <Cale> quicksilver: not even git? :)
02:09:40 <Cale> It seems like most of the people who are not using darcs are using git.
02:10:04 <quicksilver> I don't think git existed when I switched to bzr.
02:10:25 <quicksilver> There doesn't seem to be a compelling reason to switch again.
02:24:09 <mib_lyt8lenq> testing 1 2 3
02:24:14 <mib_lyt8lenq> sorry cale
02:24:32 <ayu09> could someone recommend me a free irc program
02:24:41 <ayu09> im currently using a web irc, but it kept hanging
02:24:41 <Cale> ayu09: What platform?
02:24:46 <ayu09> iwindows
02:24:55 <ayu09> when it hang, i could not use lambdabot, or talk to you
02:24:59 <Cale> ayu09: Well, I use X-Chat on every platform :)
02:25:09 <Cale> http://www.silverex.org/download/
02:25:12 <lambdabot> Title: X-Chat 2 for Windows
02:26:03 <Cale> There might be other decent clients for windows, but I don't really use windows all that much, so I don't know about them.
02:28:37 <quicksilver> Beelsebob: I miss a combinator to access a Behaviour inside an Event...
02:30:21 <Ayu08> testing
02:30:29 <Ayu08> > 1+1
02:30:30 <quicksilver> looks promising to me
02:30:31 <lambdabot>   2
02:30:35 <quicksilver> welcome to IRC Ayu08 ;)
02:30:37 <Ayu08> yay it works, now im on xchat
02:31:05 <Ayu08> i had 3 hangs on mibbit.com in this haskell channel, suddenly this place is quiet,
02:31:32 <Ayu08> @seen quicksilver
02:31:33 <lambdabot> quicksilver is in #haskell-soc, #haskell and #ghc. I last heard quicksilver speak 57s ago.
02:31:41 <Ayu08> @seen Cale
02:31:42 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 5m 38s ago.
02:31:50 <Cale> I'm here :)
02:32:57 <|Steve|> @quote stereo
02:32:58 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
02:33:01 <|Steve|> Bah.
02:33:10 * Cale realises while installing hmatrix that it would be nice for cabal to integrate a bit with various package managers :)
02:33:10 <quicksilver> @quote stereo!
02:33:11 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
02:33:12 <|Steve|> That's usually the way to get his attention. =)
02:34:03 <Cale> You'll note that my name no longer occurs attached to that quote, after it was overused :)
02:35:05 <Ayu08>  hmm
02:35:10 <Cale> Ayu08: Okay, so where are you with this? :)
02:35:44 <Ayu08> err.. i close my mibbit.com website, and i lost track of the things you previously mentioned >.<
02:35:57 <Cale> Right... so we had:
02:36:08 <Cale> data Quad a b = Q a a b b
02:36:21 <Ayu08> yup
02:36:25 <Cale> mystery (Q f g x y) = [f x, g y]
02:36:38 <Ayu08> ok..
02:36:44 <Cale> and the goal is working out what mystery's type should look like
02:37:33 <Ayu08> mystery should look like this  >>> ? [f x, g y]
02:37:38 <Cale> We know so far that it takes some kind of Quad, and produces some kind of list, so its type looks like  mystery :: Quad ... ... -> [...]
02:37:56 <Cale> Where each of those ...'s is something we still have to fill in.
02:38:42 <Cale> Now, what else do we know?
02:39:03 <Cale> Well, let's use variables to represent the parts of the type that we're not sure about yet.
02:39:35 <Cale> Say  mystery :: Quad t1 t2 -> [t3]
02:40:36 <Cale> But that's not quite right yet, since clearly mystery can't just take any sort of Quad whatsoever and produce any sort of list whatsoever.
02:41:03 <Cale> But, whatever t1, t2, and t3 end up being, we know a few things:
02:41:08 <Cale> f :: t1
02:41:10 <Cale> g :: t1
02:41:14 <Cale> x :: t2
02:41:19 <Cale> y :: t2
02:41:24 <Cale> Do you agree?
02:42:40 <Cale> This is because when we have some (Q f g x y) :: Quad a b, we have that f and g are of type a, and x and y are of type b
02:43:16 <Cale> For instance, we might have
02:43:30 <Cale> (Q 5 6 "Hello" "There") :: Quad Integer String
02:44:26 <Cale> Ayu08: still around?
02:44:32 <Ayu08> oim here
02:44:35 <Cale> okay
02:44:45 <Cale> If you need time to think about it, that's fine :)
02:44:56 <Cale> But also feel free to ask about anything you're confused with :)
02:45:10 <Ayu08> im trying to digest what you have written here
02:45:25 <Cale> yeah, I get that it might be a bit much all at once :)
02:46:37 <Cale> The idea though will be that the fact that f x and g y are written on the right hand side of the equation will put some constraints on what the types can be.
02:51:44 <Ayu08> ok
02:51:53 <Ayu08> why is it a constraint?
02:52:23 <Cale> Well, whenever we write  f x  that means that f must be a function, and x must be a value to which that function can be applied.
02:52:58 <Ayu08> oh i see
02:53:02 <Ayu08> that clears up abit
02:53:07 <Cale> yeah :)
02:53:21 <quicksilver> Ayu08: haskell performs a gradual process of making better guesses
02:53:35 <quicksilver> Ayu08: based on those things it knows for sure.
02:53:45 <quicksilver> (at least, it's helpful to imagine it as gradual)
02:54:08 <quicksilver> Ayu08: so [] is definitely a list, but we don't know what type. ["hello","goodbye"] is definitely a list of strings.
02:54:26 <quicksilver> Ayu08: similarly "f x" tells us that f is definitely a function but what don't know what type of function yet.
02:54:28 <Cale> So now, we know that whatever type t1 is, since f :: t1, we must have that t1 = t4 -> t5, and also that x :: t4
02:54:43 <Cale> Of course, we already know that x :: t2, so t2 = t4
02:55:00 <Ayu08> thanks quicksilver, good explanation for me to understand ^_^
02:55:17 <Ayu08> i'll write that  in my diary
02:55:41 <Cale> Basically, f must be a function of an appropriate type that it can be applied to x.
02:55:50 <Cale> g must be a function of the same type
02:56:08 <Cale> And since we're forming a list of the results: [f x, g y]
02:56:16 <bringert> @seen dcoutts
02:56:17 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I don't know when dcoutts last spoke.
02:56:29 <Cale> The type of elements of that list must be the same as the *result* type of those functions.
02:57:04 <Cale> So, in the end, the complete type for mystery is... (should I give it away?)
02:59:35 <Ayu08> :D
03:00:40 <Cale> mystery :: Quad (a -> b) a -> [b]
03:01:35 <Ayu08> umm
03:01:47 <Ayu08> i do not understand this line
03:01:49 <Ayu08> So now, we know that whatever type t1 is, since f :: t1, we must have that t1 = t4 -> t5, and also that x :: t4
03:01:49 <Ayu08> <Cale> Of course, we already know that x :: t2, so t2 = t4
03:01:50 <Cale> okay
03:02:16 <Ayu08> f:: t1, g:: t1 , x :: t2, y:: t2 (i understand this part)
03:02:28 <Ayu08> but could not link the first with the 2nd one
03:02:48 <Cale> I introduced some new variables t4 and t5 to be able to represent the fact that f is some type of function, but we don't know yet what its parameter and result types are.
03:03:02 <jeffz> bringert: hi
03:03:15 <Cale> We know that f must be of a function type, because we see f x
03:03:17 <bringert> hi jeffz
03:03:38 <Cale> We also know that the parameter type of that function type (the type before the ->) must be the same as the type of x
03:03:42 <Ayu08> ok
03:04:02 <jeffz> bringert: I sent you an email a littlewhile ago about Network.HTTP, did you happen to receive it?
03:04:40 <bringert> jeffz: yes, I got it
03:04:41 <Cale> Further, the result type of that function type, has to be the same as the type of the elements of the list that we're returning
03:04:52 <Cale> Because f x is being used as an element of that list.
03:04:58 <jeffz> bringert: ah ok, good :)
03:05:12 <Cale> So if we recall that  mystery :: Quad t1 t2 -> [t3]
03:05:22 <Cale> this means that t3 must be the same type as t5
03:05:45 <Cale> So, making some substitutions, we get:
03:05:53 <bringert> jeffz: unfortunately I have a bunch of unanswered emails
03:06:04 <Cale> mystery :: Quad (t2 -> t3) t2 [t3]
03:06:45 <Cale> At this point, we run out of constraints given to us by the code for mystery.
03:06:52 <Cale> t2 and t3 could be any types at all
03:07:27 <Cale> So, we might want to write that explicitly:
03:07:55 <Cale> er... I just noticed that I have an arrow missing in the above
03:08:04 <Cale> It was supposed to be mystery :: Quad (t2 -> t3) t2 -> [t3]
03:08:36 <Cale> and then mystery :: forall t2 t3. Quad (t2 -> t3) t2 -> [t3] -- if you want to write explicitly that it should work for any types t2 and t3
03:09:31 <Cale> However, type variables in Haskell are automatically forall'd if you leave the forall off, so we don't have to write it.
03:10:09 <Cale> Ayu08: did that make any sense?
03:10:34 <Ayu08> still confused with that line
03:10:38 <Cale> hmm
03:11:02 <Ayu08> why  x :: t4  ? when x::t2
03:11:09 <Cale> Well, t2 = t4
03:11:44 <Cale> I introduced some new type variables for f's type, and then showed that they're actually the same as ones that we already have names for
03:12:32 <Cale> Because f :: t1, but we wanted to say that t1 was some function type, so I took some fresh variables t4 and t5 and wrote f :: t4 -> t5
03:12:56 <Cale> We can then start to worry about whether t4 and t5 are actually the same as other types we already know :)
03:13:09 <Cale> and we do...
03:13:44 <Cale> We immediately get that since f is applied to x :: t2, that t2 and t4 must be the the same type.
03:14:47 <Ayu08> what is t5?
03:15:03 <Ayu08> t2 = t4 = x
03:15:11 <Cale> x :: t2 = t4
03:15:20 <Cale> x is a value, the t's are types
03:15:35 <Ayu08> ?? :: t? = t5 ?
03:15:36 <lambdabot> Plugin `compose' failed with: Unknown command: ""
03:15:41 <Cale> Well...
03:15:47 <Cale> Let's have a look at that...
03:15:55 <Cale> We know that f x is being stuck into a list
03:16:01 <Ayu08> yup
03:16:06 <Cale> We already said that list has type [t3]
03:16:14 <Ayu08> ?
03:16:15 <Cale> That is, it's a list of values of type t3
03:16:28 <Ayu08> where t3 come from?
03:16:31 <Cale> Way back when I wrote:
03:16:39 <Cale> mystery :: Quad t1 t2 -> [t3]
03:16:55 <Ayu08> mystery :: Quad t1 -> t2 -> [t3] ?
03:16:59 <Cale> nope
03:17:12 <Ayu08> you mentioned that 1 arrow missing
03:17:33 <Cale> uh, that was missing in "mystery :: Quad (t2 -> t3) t2 [t3]"
03:17:50 <Cale> (it was supposed to be "mystery :: Quad (t2 -> t3) t2 -> [t3]"
03:17:52 <Cale> )
03:18:03 <Ayu08> why is it called mystery
03:18:17 <Cale> Hehe, because its type was supposed to be a mystery :)
03:18:47 <Cale> I suppose a better name for it would be  applyQuad  or something, if it was actually meant to be used :)
03:19:18 <Ayu08> applyQuad would sound better >.<
03:20:33 <Ayu08> mystery :: forall t2 t3. Quad (t2 -> t3) t2 -> [t3] (whats the dot there for)?
03:20:49 <Ayu08> is that related to the code? or just to separate them
03:21:49 <Ayu08> what is forall ?
03:22:45 <Cale> Oh, that's just to separate the forall'd variables from the rest
03:23:13 <Cale> forall is how you explicitly say that the type signature is meant to work for *all* types t2 and t3
03:23:22 <Cale> and not just some types which we're not sure about
03:23:53 <Cale> But in Haskell, if you write a type signature for your function and leave the forall out, all the type variables you used will be implicitly foralled anyway.
03:23:55 <Ayu08> what is a type signature?
03:24:07 <Cale> Something like  x :: Integer
03:24:31 <Cale> Or  mystery :: Q (a -> b) a -> [b]
03:24:56 <Ayu08> oh.
03:25:01 <Cale> It consists of the name of something, followed by ::, followed by that thing's type.
03:25:17 <guenni> about Data.Map is there an intro on how to use it?
03:25:35 <Cale> guenni: The documentation is mostly pretty good...
03:25:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
03:25:47 <lambdabot> Title: Data.Map, http://tinyurl.com/34gle9
03:25:58 <quicksilver> guenni: use 'empty' and 'insert' to make maps.
03:26:08 <quicksilver> guenni: use 'lookup' to get values out of maps
03:26:09 <quicksilver> guenni: profit.
03:26:16 <guenni> Cale: I
03:26:27 <guenni> sry, wrong key
03:26:28 <Cale> findWithDefault is more common for me :)
03:26:52 <quicksilver> sure, that was an intro. guenni asked for an intro.
03:27:00 <Cale> ehehe
03:27:18 <guenni> quicksilver: yep the doc is very good, but I haven't figured out to place data from a list into a map
03:27:31 <Cale> guenni: Okay, so you have a list of pairs?
03:27:34 <quicksilver> guenni: fromList?
03:27:39 <quicksilver> guenni: or a fold with insert.
03:27:58 <guenni> since map is I presume immutable then would I have to say loop over the list and pass the new map round and round?
03:28:56 <quicksilver> yes.
03:28:59 <quicksilver> that's what a fold does.
03:29:11 <quicksilver> a fold loops over a list and passes something round and round.
03:29:29 <guenni> ok
03:29:41 <quicksilver> :t foldr
03:29:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:29:47 <quicksilver> [a] is the list.
03:29:53 <quicksilver> "b" is the something which goes "round and round"
03:30:34 <guenni> right so b would initially be "empty"
03:31:07 <quicksilver> exacly!
03:31:12 <guenni> thx
03:33:09 <Ayu08> hmm
03:33:38 <Ayu08> where could i upload my code
03:34:42 <quicksilver> Ayu08: hpaste.org
03:34:43 <Deewiant> Ayu08: hpaste.org
03:34:48 <Ayu08> thanks quick
03:34:52 <Ayu08> thanks deew
03:35:49 <Ayu08> http://hpaste.org/10094
03:35:52 <Ayu08> weird
03:36:22 <Cale> oh, er, that's the type signature for mystery, and the code for firstTwo
03:36:44 <Ayu08> ERROR file:.\quadcore.hs:18 - Syntax error in input (unexpected `.')
03:37:04 <Cale> Ah, that would be that the original Haskell 98 didn't support making the forall explicit
03:37:30 <Cale> So you'd need -fglasgow-exts, or else a more explicit language pragma to say that you want that extension.
03:37:33 <Ayu08> do i need to import something
03:37:43 <Ayu08> im using lite winhugs
03:38:03 <Ayu08> pragma o_o
03:38:29 <Ayu08> import fglasgow exts in my notepad?
03:38:34 <Cale> ah, then just leave the forall off
03:38:42 <Ayu08> so i remove forall?
03:38:44 <Cale> mystery :: Quad (t2 -> t3) t2 -> [t3]
03:38:47 <Cale> means the same thing
03:38:59 <Cale> You'll also need to supply the code for mystery if you want to play with it
03:39:10 <Cale> mystery (Q f g x y) = [f x, g y]
03:39:52 <Cale> Note that you can also leave the type signature for mystery out, and hugs/ghci will infer it. If you leave it in, it checks that the signature you give is compatible with the one that it infers.
03:40:57 <Cale> If you want to see the type signature for any function or expression, you can use  :t <expression>  at the hugs or ghci prompt
03:41:32 <Cale> For instance, if you just wrote the code for mystery into a file and not the type signature, you could ask hugs what the inferred type is using  :t mystery
03:41:48 <Cale> (of course, you can do that even if you leave the signature in, but it's more fun the other way :)
03:41:53 <Ayu08> http://hpaste.org/10094#a1
03:42:19 <Cale> yeah, that should be working I would hope :)
03:42:45 <Ayu08> umm
03:42:51 <Ayu08> how do i make it "work" ?
03:43:05 <Cale> Write that in a file, say, Quad.hs
03:43:09 <Cale> and then load that file in hugs
03:43:22 <Cale> You can then try it with something like
03:43:39 <Cale> mystery (Q (*2) (+3) 4 5)
03:44:40 <Ayu08> cale, what does your code do o_o
03:44:56 <Ayu08> why does it need 2 functions infront
03:45:27 <Cale> Well, remember that in  mystery (Q f g x y)  we determined that f and g were supposed to be functions!
03:45:51 <Cale> So mystery gives us [f x, g y]
03:46:01 <Ayu08> err wait i post something up for you to see
03:46:08 <Cale> which in this case, we have that f = (*2), and g = (+3), and x = 4, y = 5
03:46:21 <Cale> So the result is [(*2) 4, (+3) 5]
03:46:26 <Cale> which is [8,8]
03:46:31 <Ayu08> http://hpaste.org/10094#a2
03:46:51 <Cale> Ayu08: Right, we did the firstTwo one right?
03:47:06 <Ayu08> the thing that confused me is , why is it functions?
03:47:31 <Cale> Why are firstTwo and lastTwo functions?
03:47:34 <Ayu08> i thought i would need to just call mystery ( value1  value2 value3 value4) and it pops up the firstTwo number
03:47:43 <Cale> Oh, mystery is unrelated
03:47:47 <Ayu08> >.<
03:47:50 <Cale> I gave it as another exercise.
03:47:58 <Ayu08> sigh
03:48:26 <Cale> We solved firstTwo, didn't we? -- Or else at least I gave it away :)
03:48:49 <Cale> I figured lastTwo would be similar enough that you wouldn't need any help with defining it :)
03:48:55 <Ayu08> the thing is I keep relating your code with the quesoitn
03:48:59 <Cale> So you want to try firstTwo again?
03:49:01 <Ayu08> but dont see the match
03:49:22 <Ayu08> so it makes it more difficult for me to understand the process
03:49:28 <Cale> The way we define a function on values of type Quad is to pattern match:
03:49:36 <Cale> firstTwo (Q x y z w) = ...
03:50:10 <Cale> We know here, because of the type of Q, that x and y must be values of the same type
03:50:17 <Cale> So it's okay to stick them both in a list
03:50:31 <Cale> So we do that:
03:50:38 <Cale> firstTwo (Q x y z w) = [x,y]
03:51:39 <Ayu08> wait cale, before you continue further, i need to clear up some doubts first, what is pattern matching
03:51:51 <Ayu08> my brain is filled with jargons now >.<
03:53:06 <Cale> Well... let's see, how should I explain this :)
03:53:20 <Cale> Ayu08: Do you know how to write the length function for lists?
03:53:21 <ejt> I think someone may have written a tutorial or two ...
03:53:26 <Ayu08> explain in layman terms
03:53:35 <Cale> Have you seen:
03:53:38 <Cale> length [] = 0
03:53:43 <Ayu08> yup
03:53:44 <Cale> length (x:xs) = 1 + length xs
03:53:46 <Ayu08> i seen that
03:54:01 <Ayu08> but not 2nd line
03:54:06 <Ayu08> length (x:xs) = 1 + length xs
03:54:24 <Cale> Okay, well, every list in Haskell is either the empty list []
03:54:28 <Ayu08> ok
03:54:43 <Cale> or it's a non-empty list having a first element x, and a remainder list xs
03:55:03 <Ayu08> where this s come from
03:55:10 <Cale> xs is just another variable
03:55:21 <Ayu08> so i could say z?
03:55:24 <Cale> sure
03:55:28 <Axman6> x is the first element in the list, xs is the rest
03:55:36 <Ayu08> length (x:z) = 1 + length z
03:55:40 <Cale> yeah
03:55:50 <Cale> We tend to use the convention that variables which stand for lists end in s though, as if they're plural :)
03:56:03 <Ayu08> oh plural, you should mentioned that early on >.<
03:56:09 <Axman6> an x, and the other xs
03:56:21 <quicksilver> it's only a convention, it's not meaningful to the language
03:56:25 <quicksilver> but that how you read it, yes.
03:56:31 <Axman6> (an 'ex', and the other 'exes')
03:56:33 <quicksilver> yes
03:56:34 <Ayu08> ok
03:56:38 <Ayu08> lol es
03:56:39 <Cale> So, when our length function is applied to a list like [1,2,3]
03:56:50 <Cale> Each pattern tries to match against it
03:56:55 <Cale> [] does not match [1,2,3]
03:57:15 <Cale> But (x:xs) does, since [1,2,3] is the same as 1 : [2,3]
03:57:51 <Cale> So x gets bound to 1
03:57:56 <Cale> and xs gets bound to [2,3]
03:58:09 <Cale> Does that make sense?
03:58:15 <Cale> So that's pattern matching for lists.
03:59:27 <Cale> Most datatypes can be pattern matched against. Any mishmash of data constructors and variables which is well-typed and where each variable occurs at most once is a valid pattern.
03:59:37 <Cale> For instance, we can write a function like this:
04:00:12 <Cale> f ((x,y):xs, Q a b c d) = y
04:01:01 <ziman> what does that comma do?
04:01:06 <Cale> Which matches a pair, whose first element is a list (whose first element is a pair (x,y), and whose tail is xs), and whose second element is a Quad (with elements a b c, and d)
04:01:11 <ziman> oh :)
04:02:16 <Cale> and if that matches the thing you give it, it gives you the second part of the pair which was the first element of the list which was in the first part of your pair. :)
04:02:55 <Cale> (It's almost easier to understand without the English description :)
04:03:09 <Ayu08> english description?
04:03:21 <Cale> That I tried to give :)
04:03:46 <Cale> As a simpler example...
04:03:54 <Cale> Have you bumped into the Maybe type yet?
04:04:12 <Cale> data Maybe a = Nothing | Just a
04:04:39 <Ayu08> no, i have not seen that example before
04:04:58 <Cale> It's available in the Prelude, because it's a fairly useful type to have around
04:05:09 <Ayu08> how do i activate that in win hugs
04:05:10 <Cale> Have you programmed in any other languages?
04:05:15 <Ayu08> c
04:05:15 <Cale> It should be available
04:05:28 <Ayu08> c seems to be much easier to handle than haskell >.<
04:05:42 <Cale> Okay, so in C, did you ever write a function which, say, returned a number, but it might also fail?
04:05:56 <Ayu08> yup , might also fail?
04:06:01 <Botje> C programs never fail. they operate as expected. :)
04:06:08 <Ayu08> lol nice one
04:06:14 <Cale> For example, the number might be entered by the user, but maybe the user doesn't enter a number
04:06:23 <Cale> So you have to return something else.
04:06:24 <Ayu08> enter alphabet?
04:06:49 <Cale> Or maybe the function looks up something in a database, but maybe the record it searches for isn't available.
04:06:51 <Ayu08> o_o i place exception handling inside to ask the user to input number instead of other stuff
04:07:08 <Cale> How about for this database example...
04:07:25 <Ayu08> just post a message " cant be found" ?
04:07:39 <Cale> Suppose you're writing a function which takes a parameter which is something to look up, looks it up in a database and, if it's found, returns the result of the query.
04:07:48 <Axman6> Cale: i'm a lazy programmer, i prefer to let the program segfault if the user breaks it :P
04:07:58 <Cale> But the question is, what does the function *return*
04:08:11 <Cale> The code which called your lookup function is expecting a value back.
04:08:25 <Ayu08> yup
04:08:35 <Cale> Most C programmers solve problems like this by, for instance, returning a null pointer.
04:08:55 <Axman6> oh noes!
04:09:09 <Cale> Or if it's not a pointer, they end up doing other hackish things, for instance, if it's a number which is normally positive, they might have the function give -1
04:09:24 <Ayu08> umm diverted kinda far
04:09:32 <Ayu08> from maybe to c haha
04:09:41 <Cale> Or maybe the function takes a pointer as a parameter as somewhere to write its result, and the function returns whether or not it succeeded...
04:09:57 <Cale> Anyway, there are lots of conventions, and none of them are particularly satisfactory.
04:10:23 <Cale> In Haskell, when we have a function that might fail to produce a value, one option is using the Maybe type.
04:10:38 <Cale> That is, we might have...
04:10:49 <Cale> lookup :: Name -> Maybe Person
04:11:02 <Cale> For looking up a Person in some database.
04:11:21 <Cale> The result of the lookup will be  Nothing  if no person with that name occurs
04:11:36 <Cale> otherwise it will be   Just x  where x :: Person
04:11:50 <Ayu08> cale , what language you are pro in?
04:12:01 <Cale> I mostly use Haskell these days.
04:12:13 <Ayu08> hasekll and c only?
04:12:44 <Cale> But I've also used Basic, Pascal, C, C++, Java, Python, Ruby, Common Lisp, Scheme and a bunch of otherss
04:13:04 <Axman6> Cale: no erlang?
04:13:09 <Cale> Axman6: Not really.
04:13:36 <Cale> Probably if I thought about it I could name 10 more :)
04:17:04 <Ayu08> brb still reading what cale wrote above about pattern matching
04:17:09 <Cale> okay :)
04:17:25 <Saizan_> the problem with haskell is that once you've tried it the motivation to try other languages is much lower :)
04:17:56 <Cale> Only because there aren't enough cool other languages around.
04:18:08 <chrisdone> toddlers are so quote
04:18:16 <chrisdone> mischan
04:18:27 <Axman6> i'd kinda like to end up at UNSW so i could meet all the godly haskellers there
04:18:39 <Cale> Most of the really interesting other languages are research languages. :)
04:18:40 <|Steve|> Ah fanboyism.
04:18:50 <Ayu08> what is "any mishmash of data constructors and variables"
04:18:52 <Botje> you need to lift yourself into the UNSW monad first.
04:19:03 <|Steve|> Is that like the NSFW monad?
04:19:05 <Axman6> i see...
04:19:09 <Cale> Ayu08: Well, I suppose I could be more formal about it
04:19:14 <Saizan_> yeah, and there's still a lot of research in haskell too
04:19:26 * Axman6 writes a function ANU Axman -> UNSW Axman
04:19:40 <Cale> Ayu08: A variable is a pattern, and then any data constructor applied to patterns is a pattern.
04:20:43 <Cale> So for instance, x is a pattern and y is a pattern, so (x,y) is a pattern (using the data constructor for pairs), and then so Just (x,y) is also a pattern (using the data constructor Just)
04:23:04 <|Steve|> Where is research done with haskell? All the PL stuff here is in ml.
04:28:50 <PeakerWork> ML is boring
04:29:14 <PeakerWork> side effects embedded into evaluation? strictness? come on... :)
04:29:39 <|Steve|> Hey, I'm not the one doing PL research.
04:29:53 <profmakx> i will be doing all my coding in haskell in my phd i hope
04:29:57 <Ayu08> o_o
04:30:13 <Ayu08> really confusing.
04:30:15 <quicksilver> that's not necessarily PL reasearch though.
04:30:21 <quicksilver> that's using haskell as a research tool.
04:30:24 <Ayu08> x is a pattern, so it means x is a variable
04:30:39 <Cale> Ayu08: well, the other way around, but okay :)
04:30:42 <Ayu08> x,y is a pattern, so (x,y) is a variable, right???
04:30:49 <Cale> no...
04:30:54 <Ayu08> no?
04:30:57 <Cale> x and y are variables, so they're also patterns
04:31:03 <Ayu08> you said a variable is a pattern
04:31:10 <Cale> right
04:31:11 <Ayu08> variable = pattern?
04:31:16 <Cale> but not every pattern is a variable
04:31:23 <Ayu08> o_O
04:31:37 <Ayu08> could you explain that part? not every pattern = variable
04:31:52 <quicksilver> (a,b) is a pattern.
04:31:55 <quicksilver> (a,b) is not a variable.
04:32:02 <quicksilver> a is a variable.
04:32:03 <quicksilver> a is a pattern.
04:32:12 <Cale> Just like all toothbrushes are brushes, but not all brushes are toothbrushes.
04:32:53 <Ayu08> lol thats a good layman example ^_^
04:33:04 <Ayu08> should use more of those often
04:34:04 <Cale> So a variable is one simple kind of pattern
04:34:45 <Cale> Patterns can also be built up from data constructors applied to other patterns.
04:35:06 <Cale> Like (,) the constructor for pairs
04:35:13 <Cale> or (:) the constructor for lists
04:35:37 <Cale> Or Just which is a constructor for Maybe
04:35:44 * Lycurgus gains a lil more insight into the Haskell philosophy of processing program text.
04:36:42 <Lycurgus> not just category theory but denotation semantics as well
04:37:08 <quicksilver> dons++ # hopeless optimist
04:37:20 <Cale> quicksilver: hm?
04:37:26 <quicksilver> "I've a conjecture that fast, smp capable, concise code, of the kind GHC produces, could dominate the shootout for a while to come"
04:37:39 <quicksilver> of course it won't. They will shift the rules and the weights until something else wins.
04:37:47 <earthy> why?
04:37:54 <quicksilver> and out-rule any strategies GHC uses which make it do too well.
04:38:01 <earthy> why?
04:38:02 <opqdonut> yeah :)
04:38:06 <quicksilver> earthy: because that's what they have done every time haskell has dominated that benchmark in any aspect.
04:38:18 <opqdonut> it's kinda like having a cyborg cheetah runnin in the olympics
04:38:24 <quicksilver> they have ruled out the haskell approach as the 'wrong algorithm' and changed the rules.
04:38:40 <Ayu08> cale: all variable is pattern, but not all pattern are variables?
04:38:57 <earthy> quicksilver: not on all benchmarks, right?
04:38:58 <Cale> Ayu08: right
04:39:03 <Ayu08> sweat
04:39:20 <earthy> I mean, the idea is to measure program's doing basically the same
04:39:46 <quicksilver> I'm spreading FUD, really, for which I apologise.
04:39:51 <earthy> 'generating' all prime numbers between 1 and 10000 could also be done from a table, and quite fast at that
04:40:06 <quicksilver> but there were occasions where they essentially said "If you don't do exactly what C does, you're disqualified"
04:40:07 <earthy> but that's obviously not the idea if you want to compare prime number generators
04:40:24 <earthy> ah, yeah, that sucks
04:40:48 <earthy> however, if you *can* do exactly what C does in fewer lines of code you still win
04:40:50 <Ayu08> Cale: what does it mean by data constructors applied to other patterns
04:41:05 <Ayu08> cale: whats a data constructor
04:41:11 <PeakerWork> quicksilver: denotationally or operationally?
04:41:16 <Botje> "Just" or "Nothing", for example
04:41:30 <Botje> Data Foo a = Bar | Baz a | Qux a a
04:41:32 <BeelsebobWork> quicksilver: hopefully dons and I should have pushed us up a bit more last night
04:41:39 <Botje> ^ Bar, Baz and Qux are data constructors
04:41:41 <PeakerWork> they should be going for semantic equivalence, of course different languages will encourage different operational approaches
04:41:43 <Botje> and Foo is a type constructor
04:41:45 <quicksilver> PeakerWork: operationally, in most cases.
04:41:46 <BeelsebobWork> but the new result hasn't gone up yet
04:41:56 <Cale> Ayu08: A data constructor is a special sort of function which values are built up using, and you're allowed to use in patterns to take the values apart again.
04:42:07 <quicksilver> PeakerWork: well, earthy outlined the objection against semantic equivalence. You can just write the answer down.
04:42:17 <opqdonut> a
04:42:18 <quicksilver> BeelsebobWork: nice.
04:42:19 <PeakerWork> quicksilver: not if its a function of some input
04:42:20 <opqdonut> woops
04:42:35 <BeelsebobWork> quicksilver: binarytrees went from 44 seconds to about 11
04:42:45 <quicksilver> BeelsebobWork: that's probably what the email I'm reading is about :)
04:42:56 <BeelsebobWork> oh?
04:43:00 <BeelsebobWork> where's this email from?
04:43:03 <Cale> Ayu08: Apart from a handful of special ones which are written with special syntax (specifically (,) and (:)) data constructors have names that start with an uppercase letter.
04:43:06 <quicksilver> [Haskell-cafe] Fast parallel binary-trees for the shootout:
04:43:36 <Cale> Ayu08: For example, the Q in your code is a data constructor.
04:43:46 <BeelsebobWork> ah, cool, yeh
04:44:15 <Ayu08> Cale: oh ok
04:44:28 <Ayu08> jotting them down
04:45:24 <kpreid> data constructors are the things defined on the right of 'data' or 'newtype'...
04:45:54 <kpreid> or: data constructors are those things which live in the capitalized value namespace
04:46:16 <kpreid> (that is, neither lowercase nor in the type namespace)
04:46:37 <kpreid> I bet that's more confusing than it helps :)
04:47:24 <Ayu08> Cale: the comma and cons (: ) are data constructor?
04:47:33 <Cale> yeah
04:47:41 <Ayu08> those are inbuilt ?
04:47:54 <BeelsebobWork> yes
04:47:56 <Cale> Yes, though only because we want them to have special syntax
04:48:00 <BeelsebobWork> although (,) is irritatingly special
04:48:04 <Cale> We could have
04:48:10 <BeelsebobWork> Cale: (:) isn't special syntax though
04:48:14 <BeelsebobWork> although I guess [] is
04:48:15 <Cale> data Pair x y = P x y
04:48:21 <Cale> BeelsebobWork: It is in Haskell 98
04:48:22 <PeakerWork> I think (,) should have been a binary constructor only (a,b,c) === (a,(b,c))
04:48:29 <thoughtpolice> quicksilver: i personally think the shootin is more interesting although it seems pretty dead (http://shootin.sf.net)
04:48:34 <lambdabot> Title: The shootin
04:48:36 <BeelsebobWork> Cale: you can define infix constructors with a : in H98
04:48:39 <thoughtpolice> it would be cool if it could be revived
04:48:42 <quicksilver> PeakerWork: wrong number of bottoms, though.
04:48:44 <Cale> BeelsebobWork: oh?
04:48:47 <BeelsebobWork> only thing you can't do infix in H98 is type constructors
04:48:55 <Cale> BeelsebobWork: ah, okay, right
04:49:01 <Ayu08> what is H98
04:49:06 <BeelsebobWork> Haskell 98
04:49:09 <BeelsebobWork> the standard
04:49:12 <Ayu08> how do i check my winhugs is haskell 98?
04:49:25 <BeelsebobWork> it is (or close enough)
04:49:31 <Cale> Ayu08: It will be. It might even implement some extensions to that.
04:49:32 <BeelsebobWork> as opposed to Haskell as defined by what glasgow haskell compiler compiles
04:49:36 <BeelsebobWork> which is a much bigger thing
04:50:49 <BeelsebobWork> quicksilver: tbh, the most unfair benchmark I think is actually the "source gzip" one
04:51:04 <BeelsebobWork> in that what I'm interested in is "how much do I have to repeat myself when programming in this language"
04:51:11 <BeelsebobWork> which is exactly the oposite of what gzip will do
04:51:25 <quicksilver> hrm? gzip should be in the right direction there.
04:51:33 <quicksilver> oh, I see.
04:51:33 <BeelsebobWork> gzip will take out duplicated code
04:51:38 <quicksilver> yeah.
04:51:44 <BeelsebobWork> which is what I want to know about
04:51:47 <BeelsebobWork> do I have to duplicate code
04:51:52 * quicksilver nods
04:54:00 <PeakerWork> I think that they just need to have a language-aware tokenizer count tokens
04:54:13 <PeakerWork> instead of lines or bytes.. bytes counts indentation spaces separately, for example
04:54:15 <BeelsebobWork> something like that
04:54:19 <BeelsebobWork> yep
04:54:30 <BeelsebobWork> and it'll also penalise people who use understandable variable names
04:54:33 <Ayu08> Cale: f ((x,y):xs, Q a b c d) = y
04:54:41 <Ayu08> Cale: Which matches a pair, whose first element is a list (whose first element is a pair (x,y), and whose tail is xs), and whose second element is a Quad (with elements a b c, and d)
04:54:52 <Ayu08> I dont understand that sentence you have written
04:55:12 <kalven> but who cares about the shootout anyway? why all the effort?
04:55:26 <quicksilver> kalven: it's a game.
04:55:30 <Cale> Well, I'm just re-expressing (or trying to) that pattern ((x,y):xs, Q a b c d)
04:55:30 <quicksilver> people like playing games.
04:55:32 <sclv> the shootout is a great way to think about performance issues as well
04:55:42 <PeakerWork> BeelsebobWork: to be fair, though, writing low-entropy code like repetative Java declarations is easier than writing condensed high-entropy code
04:55:48 <sclv> if you look at shootout code and think about why it works well, then you learn things from it.
04:55:58 <BeelsebobWork> PeakerWork: yes -- it's easier, but it's a waste of time
04:56:31 <BeelsebobWork> you wouldn't spend your entire day unrolling loops because it's easy to do
04:56:34 <PeakerWork> BeelsebobWork: yeah, but it somewhat correlates to the amount of effort required to write the code, whereas code size correlates to other things more strongly
04:56:38 <Cale> Ayu08: as an example of something which matches that pattern, we could have
04:56:40 <kalven> sclv: that'd be nice - if the code was idiomatic.
04:56:56 <sclv> kalven: sometimes you don't want idiomatic -- the question is when.
04:56:58 <BeelsebobWork> PeakerWork: thing is that I don't think it's an at all accurate mearuse of programming effort
04:56:59 <Cale> ([(1,2),(3,4)], Q "Hello" "World" 5 6)
04:57:01 <quicksilver> kalven: some of it is.
04:57:11 <PeakerWork> BeelsebobWork: If the entropy is twice as low, and its longer, but it took less time to write...
04:57:12 <BeelsebobWork> Haskell forces you to get it right straight away -- java spreads the effort over a long time
04:57:31 <Ayu08> brb guys, studying maya
04:57:34 <Cale> Ayu08: Then we'd have x = 1, y = 2, xs = [(3,4)], a = "Hello", b = "World", c = 5, d = 6
04:57:38 <kalven> quicksilver: and a lot of it isn't.. strictness annotations, unsafeperformio, malloc.
04:57:41 <sclv> Also, continuing to do well (especially moving towards idiomatic code while doing so) helps combat the myths about haskell being unsuitable for real programming.
04:57:59 <BeelsebobWork> PeakerWork: I've very rarely met languages that I felt I could write code in faster than Haskell code
04:58:04 <BeelsebobWork> I could write *more* code
04:58:09 <BeelsebobWork> but it wouldn't do anywhere near as much
04:58:22 <PeakerWork> BeelsebobWork: Yeah, I'm just trying to rationalize using entropy as a negative measure
04:58:34 * Botje found himself hunting for concatMap in vb.net last week
04:58:38 <BeelsebobWork> PeakerWork: yeh, I don't think you can succeed though
04:58:59 <PeakerWork> BeelsebobWork: I can churn out thousands of lines of working C per day.. there's a fun element to it :)
04:59:29 <BeelsebobWork> PeakerWork: sure -- and I can churn out hundreds of lines of Haskell a day that will usually do more than the thousands of lines of C I produced
04:59:37 <sclv> Its not a negative measure though -- it just gets closer to the overall complexity of the code
04:59:47 <quicksilver> kalven: I don't think strictness annotations are unidiomatic.
05:00:00 <PeakerWork> BeelsebobWork: I'm not as productive in Haskell yet
05:00:07 <quicksilver> just because we've chosen a language which is lazy-by-default doesn't mean we never need strictness.
05:00:10 <sclv> Really what you want to do is reward smaller code size, but not too much -- maybe a log scale.
05:00:10 <BeelsebobWork> PeakerWork: get better at haskell then ;)
05:00:21 <quicksilver> I agree malloc and unsaferPerform are not.
05:00:31 <quicksilver> but I don't think any of the shootout code needs them, really.
05:00:46 <sclv> poor n-bodies will still be better off with malloc on a quad core, and I don't think it'll parallelize well at all either?
05:00:49 <kalven> why is it there then? historic reasons?
05:01:01 <quicksilver> probably.
05:01:01 <BeelsebobWork> sclv: I'm not sure what your justification of a logarithmic scale is
05:01:34 <BeelsebobWork> is a 50 line piece of code only slightly better than a 100 line one, while a 4950 line one much better than a 5000 line one?
05:02:04 <BeelsebobWork> or are you meaning the other way round?
05:02:06 <sclv> well, n-bodies needs mutability as a problem, and haskell can give you mutability or it can give you c-like speed, but to get both you need to go low-level.
05:02:11 <sclv> Beelsebob: the other way around.
05:02:51 <BeelsebobWork> k, that seems fairly reasonable
05:04:58 <PeakerWork> BeelsebobWork: what about that Reactive tutorial you owe me? :-)
05:06:31 <BeelsebobWork> PeakerWork: ask David
05:06:50 <PeakerWork> davidL?
05:06:58 <quicksilver> BeelsebobWork: did you see my comment earlier about lacking a combinator to build a behaviour into an event?
05:07:11 <BeelsebobWork> oh?
05:07:20 <BeelsebobWork> what do you mean by "build a behaviour into an event"?
05:07:27 <quicksilver> if I have 'Event a' and 'Behaviour b' I want to be able to build 'Event c'
05:07:32 <quicksilver> using a function a -> b -> c
05:07:44 <BeelsebobWork> oh, yeh, that's an interesting one -- lemme check
05:07:48 <quicksilver> it 'occurs' at the same times as the first event, and it uses the value of the behaviour (at that time) to calculat its value.
05:08:02 <BeelsebobWork> quicksilver: you probably want snapshot
05:08:04 <BeelsebobWork> in Behavior
05:08:13 <BeelsebobWork> or snapshot_
05:08:19 <quicksilver> ah. That's not in the paper :)
05:08:22 * quicksilver browses the source.
05:08:33 <BeelsebobWork> it creates an Event from an Event and a Behavior
05:08:40 <BeelsebobWork> snapshotting the behavior every time the event occors
05:08:50 <quicksilver> yes. that's exactly what I want.
05:08:52 <quicksilver> :)
05:08:55 <BeelsebobWork> :)
05:09:49 <quicksilver> then I need uncurry and fmap, of course.
05:09:52 <quicksilver> but that's OK.
05:11:11 <BeelsebobWork> quicksilver: you're right that it taking a function to combine them is actually probably a nicer more general version
05:11:23 <Baughn> I should probably ask, is there a function that splits lists into n-element lists already?
05:11:32 <dmhouse> I don't think so.
05:11:41 <quicksilver> BeelsebobWork: well that's a general debate.
05:11:49 <dcoutts> http://blog.well-typed.com/2008/09/the-new-haskellorg-community-sparc-server-is-online/
05:11:52 <lambdabot> Title: blog.well-typed.com » Blog Archive » The new haskell.org community SPARC serve ..., http://tinyurl.com/56tt6j
05:11:53 <dcoutts> yay!!
05:11:56 <dcoutts> :-)
05:11:58 <quicksilver> .. -> (a,b) or .... -> (a -> b -> c) -> c
05:12:05 <quicksilver> resp. with a functor interposed.
05:12:11 <quicksilver> I don't know if there is a general answer.
05:12:44 <quicksilver> Baughn: No. I habitually write "groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
05:12:48 * BeelsebobWork adds snapshotWith to the code anyway
05:12:58 <quicksilver> BeelsebobWork: fair dos :)
05:13:07 <dmhouse> > map (map snd) . groupBy ((==) `on` ((`div` 4) . fst)) . zip [0..] $ [1..20]
05:13:08 <lambdabot>   [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]
05:13:51 <ziman> let chunkBy n = map (take n) . takeWhile (not.null) . iterate (drop n) in chunkBy 3 [1..10]
05:13:54 <ziman> > let chunkBy n = map (take n) . takeWhile (not.null) . iterate (drop n) in chunkBy 3 [1..10]
05:13:56 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
05:14:13 <dmhouse> But mine is FUN! :)
05:14:43 <thoughtpolice> dcoutts: yay :]
05:24:11 <Twey> @src null
05:24:12 <lambdabot> null []     = True
05:24:12 <lambdabot> null (_:_)  = False
05:24:31 <Twey> :-\
05:24:36 <Twey> Why is it defined so strangely?
05:24:49 <Twey> With (_:_) instead of _?
05:24:58 <quicksilver> for emphasis, I think.
05:25:01 <Twey> Did they just want to make a pattern that looked like a behind?
05:25:07 <quicksilver> possibly.
05:25:12 <Twey> Right-ho.
05:36:49 <trzkril> > let nul _ = False in nul undefined
05:36:50 <lambdabot>   False
05:36:56 <trzkril> > null undefined
05:36:58 <lambdabot>   mueval: Prelude.read: no parse
05:36:58 <lambdabot>  mueval: *** Exception: Prelude.undefined
05:37:52 <lilac> Twey: some people dislike overlapping patterns.
05:38:16 <Twey> Hmnhmn.
05:38:50 <Twey> I think they just wanted to make an arse.  :)
05:39:04 <quicksilver> personally I see no harm in overlaps as long you only ever overlap previous cases. But writing it this way does emphasise that it's complete.
05:39:29 <Twey> I don't see what can be more emphatically complete than a _ pattern on the end.
05:39:30 <dmhouse> Twey: it makes it stricter, as trzkril just demonstrated.
05:39:36 <Twey> Ah, true that.
05:39:49 <dmhouse> Not sure if this is a good thing.
05:39:58 <BeelsebobWork> quicksilver: how do you "only overlap previous cases"
05:39:58 <wjt> no it doesn't
05:39:59 <opqdonut> well, consistently stricter
05:40:00 <lilac> dmhouse: not really, since it needs to be WHNF for the first pattern anyway
05:40:07 <wjt> > let nul [] = True; nul _ = False in nul undefined
05:40:09 <lambdabot>   mueval: Prelude.read: no parse
05:40:09 <lambdabot>  mueval: *** Exception: Prelude.undefined
05:40:12 <dmhouse> Err, yeah :)
05:40:15 <BeelsebobWork> if you overlap previous cases, your previous cases by definition overlap future ones
05:40:15 <wjt> > let nul _ = False in nul []
05:40:17 <lambdabot>   False
05:40:18 <wjt> buh boh.
05:40:20 <opqdonut> if you're matching against different constructors of the same data type, you should be as strict for all of them
05:40:23 <dmhouse> Sorry kids, mind blank.
05:40:38 * dmhouse glares accusingly at trzkril
05:40:40 <lilac> quicksilver: no pattern overlaps means never having to say sorry for reordering
05:40:53 <quicksilver> BeelsebobWork: that's a very good point.
05:41:27 <quicksilver> BeelsebobWork: I meant overlappings should always be ordered so the later is a superset of the earlier.
05:41:48 <quicksilver> so the list as a whole is a consistent linearisation of the definedness partial order.
05:41:53 <BeelsebobWork> yeh, that sound somethilg like the intuative rule I use
05:42:06 <quicksilver> lilac: yes. true.
05:42:25 <lilac> quicksilver: so you're saying you can entirely overlap a previous case, but not partially?
05:42:35 <quicksilver> yes.
05:42:44 <lilac> right, that seems sensible, and sounds like what i do too
05:42:53 <quicksilver> more importantly you musn't entirely overlap a later case.
05:42:56 <BeelsebobWork> I think I do that -- but I think I'm a bit more strict
05:43:14 <BeelsebobWork> I overlap iff I'm adding a catch-all
05:43:18 <quicksilver> (because then the later case is dead)
05:43:19 <lilac> quicksilver: i'd hope that ghc would warn about entirely overlapping a later case?
05:43:27 <quicksilver> I'd hope that too.
05:43:34 <BeelsebobWork> i.e. I'll do a sequence of very specific pattern matches, and then an "anything else" match
05:44:02 <lilac> i think what we've learned is that none of us uses -Wall ;-)
05:44:19 <quicksilver> ISTR there is something I don't like about -Wall
05:44:25 <quicksilver> I'd need to turn it on again to remember what.
05:44:32 <quicksilver> something about getting confused with qualified imports, was it?
05:45:08 <lilac> there's (or was) a bug where it couldn't tell whether an import was unused in some cases
05:45:33 <quicksilver> I'll try turning -Wall back on on some code and let you know :)
05:49:23 <lilac> http://hackage.haskell.org/trac/ghc/ticket/1074 <<- that's the one i'm thinking of
05:49:25 <lambdabot> Title: #1074 (-fwarn-unused-imports complains about wrong import) - GHC - Trac
05:59:48 <mightybyte> his
06:04:53 <guenni> anybody know a piece of code for Maps of Maps?
06:05:25 <BeelsebobWork> to do what with them?
06:06:30 <guenni> for instance : http://hpaste.org/10096
06:07:01 <ddarius> guenni: You have a bad habit of making people play 20 questions just to try to help you.
06:07:15 <guenni> ddarius: sry
06:08:00 <quicksilver> guenni: Yes, don't use them.
06:08:04 <quicksilver> what would be my first advice :)
06:08:08 <guenni> I mean I have a structure, let's say a tuple of (Int, Int, String) and I want in inserted in a Map Int (Map Int String)
06:08:24 <quicksilver> what advantage does Map Int (Map Int String) have over Map (Int,Int) String ?
06:09:03 <guenni> quicksilver: maybe none, which you'd already know if you were clever?
06:09:07 <ddarius> quicksilver: There can be advantages in some cases
06:09:14 <quicksilver> there can indeed be advantages in some cases.
06:09:16 <BeelsebobWork> quicksilver: being able to lazily partially index
06:09:21 <quicksilver> I'm wondering if there is an advantage in guenni's case.
06:09:25 <quicksilver> ;)
06:09:38 <quicksilver> because in many respects the latter form is easier to deal with. All else being equal.
06:11:01 <guenni> quicksilver: wouldn't lookup be a bit faster with Nested ones, also keys would be grouped?
06:11:22 <BeelsebobWork> guenni: why would lookup be faster?
06:11:24 <quicksilver> don't think lookup would be faster. Fractionally slower if anything.
06:11:38 <quicksilver> grouping is mostly in your head.
06:11:52 <quicksilver> although what BeelsebobWork calls 'lazy partial indexing' is a kind of grouping
06:11:59 <guenni> Beelsebob: just guessing
06:12:00 <quicksilver> and if that is something you need, then yes, that's an advantage.
06:12:33 <guenni> so you guys wouldn't use nested maps?
06:12:50 <BeelsebobWork> depends on the scenario, but usually, no
06:13:13 <guenni> quicksilver: in your plist HaXml example you seem to deal with a similar problem, which solution did you use there?
06:13:15 <BeelsebobWork> so anyway, what did you want to do with them anyway?
06:14:14 <guenni> BeelsebobWork: store them and loop them up later, actually I need to store a large amount of static data and match dynamic data against it
06:14:40 <BeelsebobWork> guenni: okay, so what's the problem?
06:14:54 <quicksilver> in the plist I did use nested maps.
06:14:59 <quicksilver> because it's not always maps.
06:15:03 <quicksilver> (sometimes it's an array inside a map)
06:15:06 <guenni> I don't know how to insert something into nested maps
06:15:12 <quicksilver> or a map inside an array inside an array inside a map.
06:15:22 <guenni> I was looking for a nice code example
06:15:27 <BeelsebobWork> guenni: look at M.insertWith
06:15:40 <BeelsebobWork> that'll let you modify a value in a map, instead of just inserting into it
06:15:56 <guenni> BeelsebobWork: thx
06:16:14 <quicksilver> well, inserting into an inner map
06:16:21 <quicksilver> is 'updating' an outer map
06:16:25 <quicksilver> (if the outer key already exists)
06:16:36 <BeelsebobWork> quicksilver: yeh -- which is what insertWith does
06:16:45 <quicksilver> so if you new for sure the outer key already existed, you could use 'updateAt'
06:16:52 <quicksilver> BeelsebobWork: I know, I'm working toward that logically here ;)
06:16:57 <BeelsebobWork> oh, okay
06:16:59 <BeelsebobWork> fair enough
06:17:07 <quicksilver> what insertWith does is give you one function which copes with both cases
06:17:16 <quicksilver> (outer key already exists, and outer key doesn't exist)
06:17:36 <quicksilver> so you say "insert this as a new (outer key) if it wasn't already there; if it is already there, combine the values in this way"
06:17:54 <quicksilver> guenni: this is what I mean about nested maps being fiddly :) It's not actually hard once you get the idea though.
06:19:03 <guenni> quicksilver: that's why I asked, I'm dealing with Data.Map for the 1st time period and I just couldn't figure out how to from the haddocks
06:19:36 <quicksilver> I would suggest playing a little bit with maps on their own would be good practice.
06:19:41 <quicksilver> before generalising to nested ones.
06:21:59 <guenni> ddarius: and I'm sorry for not being able to express my problem more clearly at the 1st go, I know it's annoying but it's gonna take some more practise with haskell to be more precise
06:58:24 <zachk> how do i make IO non lazy, or how do I strictly evaluate something?
06:59:03 <lilac> zachk: it depends on the situation
06:59:33 <lilac> you might use bang-patterns, or ! in a 'data', or seq in order to strictly evaluate something
06:59:56 <quicksilver> zachk: you question is slightly ill-formed. laziness and IO are mostly orthogonal.
07:00:04 <lilac> but that's not really strict -- you're really saying "when that thing is forced, force this thing too"
07:02:50 <dmwit> zachk: What exactly do you want to strictify?
07:03:41 <dmwit> Somebody yesterday pointed me at the "strict" package on Hackage; it has a System.IO.Strict that might be relevant.
07:06:06 <zachk> dmwit: I am attemtping to write source and sink for shell pipelines: source reads in stdin till eof then switches to a network sock handle, problem is, it doesnt output till i shutdown telnet, but then the output is correct, which makes it impossible for me to loop with my sink command im writing, so i need the output line by line
07:07:02 <dmwit> aha
07:07:06 <Saizan_> that's more a problem of buffering, i think
07:07:09 * dmwit nods
07:07:27 <dmwit> hSetBuffering LineBuffering -- this should be done on the network handle
07:07:37 <dmwit> It should maybe be done on stdin, too.
07:10:39 <zachk> ok ill try that
07:13:36 <lilac> does haskell have a mod operation where a `mod'` b is always in the interval [0, b) ?
07:13:59 <lilac> neither mod nor rem seem to have this property
07:14:17 <Cale> lilac: well, `mod` does, doesn't it?
07:14:27 <lilac> > -1 `mod` 4
07:14:29 <lambdabot>   -1
07:14:31 <lilac> nope
07:14:34 <Cale> > (-1) `mod` 4
07:14:36 <lambdabot>   3
07:14:53 <lilac> grr unary minus
07:14:54 <Olathe> - strikes again !
07:14:58 <lilac> thanks! :)
07:15:02 <zachk> dmwit: thank you its almost completely working now :-D
07:15:03 <Cale> mod is multiplicative
07:15:16 <Deewiant> @check \a b -> mod a b >= 0
07:15:18 <lambdabot>   mueval: "*** Exception: divide by zero
07:15:25 <Cale> So you should expect it to bind tighter than negation, which is additive :)
07:15:29 <Deewiant> @check \a b -> b /= 0 ==> mod a b >= 0
07:15:30 <lambdabot>   "Falsifiable, after 3 tests:\n-2\n-3\n"
07:15:36 <Deewiant> @check \a b -> b /= 0 ==> rem a b >= 0
07:15:37 <Twey> > map (-1) [1..5]
07:15:38 <lambdabot>   "Falsifiable, after 8 tests:\n-1\n2\n"
07:15:39 <lambdabot>       No instance for (Num (a -> b))
07:15:39 <lambdabot>        arising from a use of `negate' at...
07:15:49 * Twey winces.
07:16:16 <_ar> how does @check work?
07:16:21 <lilac> Cale: it's a prefix multiplication of (-1), therefore multiplicative :)
07:17:01 <lilac> Cale: actually, i think in C. unary binds tighter than binary in my brain
07:17:03 <Cale> lilac: I tend to think of it as the (unique) inverse to addition, having nothing to do with multiplication :)
07:17:19 <Cale> @check \a b -> (a `mod` b) `elem` [min 0 b, max 0 b]
07:17:21 <lambdabot>   mueval: "*** Exception: divide by zero
07:17:29 <Cale> @check \a b -> b /= 0 ==> (a `mod` b) `elem` [min 0 b, max 0 b]
07:17:30 <lambdabot>   "Falsifiable, after 3 tests:\n-1\n2\n"
07:17:35 <Saizan_> _ar: it uses Test.QuickCheck
07:18:09 <Cale> @check \a b -> b /= 0 ==> (a `mod` b) `elem` [min 0 b .. max 0 b]
07:18:10 <lambdabot>   "OK, passed 500 tests."
07:18:14 <Cale> there we go :)
07:18:24 <lilac> :) thanks
07:18:44 <dmwit> _ar: It's QuickCheck.
07:18:48 <Cale> Note that when b is negative, the interval is as well :)
07:18:56 <dmwit> _ar: There's lots of docs (and even some papers!) on how QuickCheck works.
07:19:22 <_ar> awesome i'll look into it... it seems magic. does it only falseify or can it prove correctness?
07:19:34 <Olathe> It only falsifies.
07:21:29 <Twey> > replicate 4 x
07:21:31 <lambdabot>   [x,x,x,x]
07:21:36 <Twey> > replicate 4 xy
07:21:38 <lambdabot>   mueval: Prelude.read: no parse
07:21:47 <Twey> How do these Expr types work, then?
07:21:57 <lilac> @type x
07:21:59 <lambdabot> Expr
07:22:10 <Twey> Basically all single-letter values are defined as Expr types that Show to their letters?
07:22:10 <Olathe> @type "OMG HI !" :: Expr
07:22:11 <lambdabot>     Couldn't match expected type `Expr' against inferred type `[Char]'
07:22:17 <Olathe> :(
07:22:21 <lilac> Twey: pretty much. there's more to it than that tho
07:22:25 <quicksilver> @where expr
07:22:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:22:35 <quicksilver> Twey: see there if interested.
07:22:38 <Twey> Thanks :)
07:23:46 <Cale> > 2*x
07:23:48 <lambdabot>   2 * x
07:23:52 <Cale> > x^2
07:23:54 <lambdabot>   x * x
07:24:03 <Cale> > x^10
07:24:05 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x)
07:27:54 <_zenon_> I can't come up with a oneliner to conver [1..n] into (1,(2,(3....,n)))
07:28:09 <Cale> _zenon_: What type would that even have?
07:28:14 <Botje> that's okay, because it doesn't type in haskell :)
07:28:27 <_zenon_> Cale, exactly
07:28:38 <Cale> _zenon_: So you simply can't write it.
07:28:41 <_zenon_> I could not get the types straight for the basecase etc.
07:28:50 <Twey> It doesn't make sense in terms of Haskell's tuples
07:28:50 <ski> > x^x
07:28:51 <Botje> and even if you could come up with something like it, it'd be isomorphic to [a]
07:28:55 <Cale> The base case isn't so bad even...
07:29:05 <Twey> Tuples aren't meant to be iterable
07:29:10 <_zenon_> Yeah, maybe, or I just thought I wasn't good enough like the wizard himself
07:29:16 <lilac> I'm pretty sure I could write that conversion in TH
07:29:16 <Cale> But the recursive case...
07:29:19 <lambdabot>   thread killed
07:29:27 <_zenon_> with wizard i mean Oleg
07:29:33 <Cale> You have a different result type for each length of list.
07:29:45 <quicksilver> _zenon_: you can write something along those lines with suitable type classes, yes.
07:29:49 <quicksilver> it's not very pleasant.
07:29:53 <Cale> Given that the length of a list might not be known until runtime, that makes no sense :)
07:30:09 <quicksilver> and you end up without much type information.
07:30:19 <quicksilver> I.e. you end up with a nested tuple but you don't know how deep it is.
07:30:27 <quicksilver> there isn't much you could do with it.
07:30:34 <quicksilver> in fact, operationally, it's much like a list :)
07:30:35 <ski> Mu (Compose (Either () ((,) a)))
07:31:03 <opqdonut> :)
07:31:20 <lilac> ski: that type also includes infinite lists, doesn't it?
07:31:21 <ski> (.. move a few parenthesis in the obvious way)
07:31:28 <lilac> i suppose that's inevitable
07:31:39 <ski> lilac : not if you takes the least fixpoint (hinted by `Mu')
07:32:29 <ski> (but, yes, in haskell lists can be infinite)
07:32:42 <opqdonut> yay for iso-recursive types
07:33:03 <quicksilver> the other way is easier (tuples, nested or not, to lists)
07:33:07 <Saizan_> btw, what's the difference between iso- and equi- recursive?
07:33:09 <quicksilver> of course that discards type information.
07:33:42 <ski> Saizan_ : with `equi-' the two types are the same .. with `iso-' you have to use an explicit isomorphism
07:34:55 <ski> (also, i've seen a variant of `equi-' in which `mu rho. F rho' was equal to not `F (mu rho. F rho)' (that would be `equi-'), but equal to `mu rho. F (mu rho. F rho)')
07:36:16 <quicksilver> yay for overloading greek and latin prefixes which mean the same thign to mean slightly different things.
07:36:21 <quicksilver> mathematicians rock.
07:36:47 <matthew-_> in C++ you can overload [ and ]
07:36:49 <ski> (this variant used an explicit isomorphism for introducing and eliminating the top-level `mu rho. ')
07:37:25 <Twey> matthew-_: And Python!
07:37:26 <Saizan_> (ah, i was wondering which was that for)
07:37:33 <matthew-_> Twey: *headdesk
07:37:43 <Twey> And probably Ruby.  Knowing Ruby.
07:37:48 <matthew-_> well quite
07:37:50 <Twey> And Perl.
07:37:59 <Twey> And Lisp... kind of.
07:38:11 <matthew-_> hmm. If you can do it in Perl, I can't remember how
07:38:31 <matthew-_> is it via AUTOLOADER ?
07:38:32 <skorpan> i "know" all of those languages and have no idea about how to do that in any of them
07:38:38 <osfameron> overloading []?
07:38:40 <Twey> Hmn, really?  I was under the impression that you could hook the parser in Perl and do just about anything.
07:38:41 <skorpan> yeah
07:39:02 <matthew-_> oh, I've never messed with the parser I think
07:39:10 <Twey> skorpan: Python would be via supplying __getitem__
07:39:19 <osfameron> there's various things in 'use overload'
07:39:25 <Twey> Ruby and Perl were just guesses, since I don't know them personally
07:39:27 <osfameron> or tying an array to something
07:40:06 <Twey> Lisps... don't really have that kind of structure, but you can overload or shadow entirely the equivalent functions
07:40:11 <Twey> Hence the 'kind of'
07:42:08 <roderyk> hmm.. silly OT question. "echo $PAGER" => less; "PAGER=less git diff" works correctly; "git diff" uses some whacky pager. Any idea what other variable git/zsh is using?
07:43:26 <Olathe> How do I read RWH online without 25 million comment links ?
07:45:48 <quicksilver> roderyk: maybe you didn't export that environment variable.
07:45:51 <Olathe> I'm planning on buying it when it comes out, but...
07:46:04 <opqdonut> quicksilver: err?
07:46:05 <Twey> Olathe: Turn off Javascript?
07:46:10 <Twey> The comments can be valuable though.
07:46:21 <Olathe> Ahh, thanks.
07:46:26 <opqdonut> quicksilver: he's defining it for the git command
07:46:47 <quicksilver> matthew-_, Twey : Perl you would most simply use a tied array.
07:47:17 <quicksilver> opqdonut: I interpret roderyk as saying that he set PAGER and it didn't work, but 'PAGER=less git diff' does work.
07:47:34 <quicksilver> setting PAGER standalone only sets a shell variable unless its exported.
07:47:43 <quicksilver> 'PAGER=less foo' always sets an env. var.
07:47:47 <opqdonut> yes
07:48:07 <opqdonut> but one would think that PAGER is exported
07:48:11 <roderyk> quicksilver: you're right, thanks. It works after I export it. Although I'm not really sure why. *googles*
07:48:22 <opqdonut> oh, okay
07:48:28 <quicksilver> opqdonut: one might think that. one might be wrong though :)
07:48:32 <quicksilver> it was a possibility to check, at least.
07:48:39 <opqdonut> yes
07:48:42 <opqdonut> it seems :)
07:50:29 <chrisdone> my lojban bot has 25 lines of imports
07:50:34 <chrisdone> sorry, 35
07:50:36 <chrisdone> wooooooo
07:51:20 <chrisdone> http://hpaste.org/10097
07:51:25 <chrisdone> I was wrong, 34
07:51:56 <Saizan_> maybe you shouldn't write it all in one module :)
07:52:23 <chrisdone> ahh, I see duplicates!
07:52:31 <quicksilver> chrisdone: probably don't need Control.Applicative twice. 'double-applicatives' are rare and exotic structurs.
07:53:22 <chrisdone> quicksilver: I read it makes it more efficient
07:54:45 <thoughtpolice> only one way to find out: import it 30 more times and report back here.
07:55:05 <chrisdone> I don't have 30 cores
07:55:10 <chrisdone> the rule is one import per core
07:56:13 <lilac> > iterate (\n -> (n `mod` 2 == 1) <?> (3*n+1) <:> (n `div` 2)) 12345
07:56:15 <lambdabot>   [12345,37036,18518,9259,27778,13889,41668,20834,10417,31252,15626,7813,2344...
07:56:28 <dmhouse> ?type (<?>)
07:56:30 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => Bool -> b -> m b
07:57:07 <dmhouse> > iterate (\n -> odd n <?> (3*n+1) <:> (n `div` 2)) 12345
07:57:08 <lambdabot>   [12345,37036,18518,9259,27778,13889,41668,20834,10417,31252,15626,7813,2344...
07:57:10 <roderyk> on hackage, the last wx package seems to have been uploaded Mar 21 and there is a build failure log for ghc-6.8. Is wxHaskell currently not installable as-is?
07:58:10 <tromp> ?type (<:>)
07:58:12 <lambdabot> forall a. Maybe a -> a -> a
07:58:13 <thoughtpolice> roderyk: well, the hackage server doesn't exactly have a lot of external stuff installed so a lot of library bindings just won't build anyway
07:58:31 <thoughtpolice> also on hackage a failure in any step of the configure-build-install-haddock phase causes a 'failure'
07:58:46 <thoughtpolice> lots of packages actually do build if you read the log but, there's like a malformed haddock comment somewhere that botches it
07:58:51 <dmhouse> Is (<:>) = fromMaybe?
07:59:07 <dmhouse> ?src (<:>)
07:59:08 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:59:22 <roderyk> thoughtpolice: ah, ok. Was just worried it was left for bitrot or something :-)
07:59:29 <tromp> @src fromMaybe
07:59:30 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
08:00:03 <dmhouse> fromMaybe d = maybe d id
08:00:04 <tromp> it wld be flip fromMaybe
08:00:37 <dmhouse> ?type mayb
08:00:38 <dmhouse> ?type maybe
08:00:39 <lambdabot> Not in scope: `mayb'
08:00:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:00:55 <dmhouse> tromp: true.
08:01:32 <thoughtpolice> roderyk: so the general rule of thumb is that if you see a 'build failure on ghc-6.x' or whatever, check the actual log output - failures normally happen A) because of a bad haddock comment, B) it's a library wrapper and the library isn't there, or (rarely) C) there is crap that happens with multiple versions of the same package, etc.
08:02:08 <Olathe> What is the connection between Haskell and fish ?
08:02:21 <quicksilver> scalability?
08:02:34 <dmhouse> Olathe: one's a programming language, one's an aquatic animal
08:02:50 <BeelsebobWork> Olathe: one if it's legs is both the same
08:02:51 <dmhouse> I guess that's not much of a connection, actually.
08:02:58 <chrisdone> you can tune a haskell, and you can tuna fish!
08:03:09 <BeelsebobWork> chrisdone: that's *awful*
08:03:16 <dmhouse> ?slap chrisdone
08:03:16 * lambdabot activates her slap-o-matic...
08:03:23 <chrisdone> hahaha
08:04:12 <ejt> Olathe: Haskell98 or ghc haskell ?
08:04:25 <BeelsebobWork> heithev Cdn  be Cr  fated using Handnritiug recognition?
08:04:33 <pastorn> what's the name of the haskell editor?
08:04:38 <pastorn> *text editor*
08:04:40 <ejt> yi
08:04:43 <dmhouse> pastorn: Yi?
08:04:48 <pastorn> thanks :)
08:04:59 <dmhouse> There are many editors for editing Haskell, but that's one written in Haskell.
08:06:50 <chrisdone> anyone started using <$> instead of map?
08:07:04 <BeelsebobWork> why?
08:07:11 <BeelsebobWork> to obfuscate?
08:07:12 <chrisdone> it's more general
08:07:20 <chrisdone> actually no, consider this
08:07:38 <Olathe> @src (<$>)
08:07:38 <lambdabot> f <$> a = fmap f a
08:07:41 <BeelsebobWork> sure -- but more general doesn't matter when map is general enough for the situation you're looking at
08:07:52 <quicksilver> I'm so used to prefix notation for map
08:07:55 <BeelsebobWork> if I *were* to use it I'd write it fmap
08:07:56 <quicksilver> (and mapM and forM)
08:08:00 <Olathe> > (+1) <$> [1..]
08:08:01 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
08:08:02 <quicksilver> that I keep using it.
08:08:20 <quicksilver> I use <$> heavily for other monads though.
08:08:26 <quicksilver> not sure I can justify that clearly :)
08:08:35 <quicksilver> I guess when I use map I'm not thinking of list as a monad.
08:08:44 <BeelsebobWork> heh
08:08:47 <quicksilver> I'm thinking of it as a data structure which represents a loop.
08:08:47 <BeelsebobWork> that's strange
08:08:56 <chrisdone> I had two functions, one which returns Maybe Entry, and another which returns [Entry]. and in each of these functions, I want to apply a function Element -> Entry, to values [Element] and Maybe Element. <$> is the perfect choice here. Entry <$> elements and Entry <$> Just maybeElement
08:09:08 <quicksilver> chrisdone: yup.
08:09:19 <quicksilver> chrisdone: if you want to highlight the similarity between code using two different Functors
08:09:26 <quicksilver> then, definitely, <$> looks nice.
08:09:34 <BeelsebobWork> chrisdone: I disagree
08:09:46 <BeelsebobWork> in both of them I should be able to tell what's going on quickly
08:09:55 <BeelsebobWork> and hints like "map" tell me "you're working on lists"
08:10:15 <BeelsebobWork> fmap is only useful when the function that *you're* writing is more general than just working on lists
08:10:54 <chrisdone> should I have functions addIntegers, addInts, so forth instead of (+)?
08:11:48 * BeelsebobWork notes that in a lot of places we do actually distinguish
08:11:48 <quicksilver> it's a question of degree, in my opinion.
08:11:50 <chrisdone> and tryApplyFunctionToMaybeValue instead of fmap
08:11:58 <Saizan_> BeelsebobWork: often mental-type-inference is enough for that, i think there's some balance to take in consideration
08:12:02 <quicksilver> there is validity in both arguments
08:12:10 <quicksilver> it is a virtue to make types explicit
08:12:13 <BeelsebobWork> Saizan_: yeh, but using "map" makes mental type inference easier
08:12:14 <Olathe> > (+1) <$> (Maybe 3)
08:12:15 <lambdabot>   mueval: Prelude.read: no parse
08:12:18 <quicksilver> it's also a virtue to exhibit uniformity
08:12:23 <BeelsebobWork> it's another implicity type annotation
08:12:32 <Olathe> > (+1) <$> (Just 3)
08:12:34 <lambdabot>   Just 4
08:12:39 <Olathe> > (+1) <$> Nothing
08:12:41 <lambdabot>   Nothing
08:13:55 <chrisdone> admittedly I still use `map'
08:14:37 <BeelsebobWork> I can see the benefit in using <$>
08:15:00 <BeelsebobWork> but I think in any situation where I would actually use it, I'd (a) call it fmap, not <$> (b) move the general stuff out into another function
08:15:12 <trzkril> :t <$>
08:15:13 <lambdabot> parse error on input `<$>'
08:15:20 <trzkril> :t (<$>)
08:15:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:17:18 <quicksilver> BeelsebobWork: the benefits are most clear (to me) in parsers
08:17:29 <quicksilver> and more generally, in applicatives where you are constructing data.
08:17:44 <quicksilver> Foo <$> one <*> two
08:17:50 <quicksilver> is pleasingly-like 'Foo one two'
08:17:55 <BeelsebobWork> yep -- but these are both cases where you're dealing with very general things
08:18:11 <quicksilver> well it may well be a very concrete Applicative I'm working in
08:18:19 <quicksilver> I may know definitely it's Event, or Parser, or...
08:18:24 <quicksilver> but still choosen to use that syntax.
08:18:35 * BeelsebobWork shrugs
08:18:54 <BeelsebobWork> so far at least, I tend to rename functions when I know what type I'm working with
08:18:58 <Saizan_> what's the point of general combinators if you don't use them in specific cases?
08:19:20 <BeelsebobWork> Saizan_: using them in general places, and specialising them to use them in specific cases
08:19:31 <Saizan_> always renaming?
08:19:47 <BeelsebobWork> so far at least, yes
08:19:51 <dmhouse> BeelsebobWork: IMO type annotations serve the purpose you're talking about
08:20:25 <quicksilver> I think there is nothing wrong with naming a specialisation.
08:20:30 <Cale> Do you specialise the length function for each type of list at which you intend to apply it? :)
08:20:31 <Saizan_> that's quite weird, i like the fact that all my monads share the same "language"
08:20:32 <quicksilver> Like all kinds of naming, it serves a purpose.
08:21:11 <BeelsebobWork> Saizan_: I dislike not being able to form a quick *concrete* mental model
08:21:43 <Saizan_> i see
08:22:20 <quicksilver> I definitely think both arguments here are valid. I think where you choose to draw that line is a matter of taste / style.
08:23:20 * Saizan_ nods
08:23:42 <Cale> General monads are very concrete ;)
08:23:56 <BeelsebobWork>  /agree with quicksilver
08:24:02 <BeelsebobWork> Cale: really -- no :P
08:24:17 <SamB> but they are!
08:24:19 <Cale> BeelsebobWork: Actually, I've come to regard them as fairly concrete.
08:24:34 <Cale> BeelsebobWork: But I can understand how they might seem hopelessly general at first.
08:24:45 <BeelsebobWork> they're *anything* that has left and right identity and associativity
08:24:49 <BeelsebobWork> there's nothing concrete about that
08:24:50 <Cale> Right.
08:24:56 <Cale> No, that's quite concrete.
08:25:09 <chrisdone> interesting. the XML package has filterElement and filterElements, one returning [Element] and one returning Maybe Element. it could be Monad m => m Element and inferred depending on how the user uses it >_>. I guess BeelsebobWork, you would hate that? similar to how Data.Map.lookup is m a
08:25:37 <dmhouse> Although they really need to be MonadFail m => m a
08:25:48 <Saizan_> chrisdone: Data.Map.lookup always return just one element, though
08:25:59 <SamB> chrisdone: I don't know that that would make sense ...
08:26:14 <BeelsebobWork> Cale: I think we have different conceptual models of concrete
08:26:15 <Saizan_> chrisdone: you need MonadPlus to return multiple elements depending on the monad
08:26:30 <BeelsebobWork> Cale: I suspect that for something to be concrete to me it has to be constructive
08:26:37 <BeelsebobWork> wheras the definition of monad is destructive
08:26:51 <chrisdone> Saizan_: good point
08:27:00 <Cale> Well, once you understand how those axioms work, you can form a good mental model of things that should work in any monad.
08:27:33 <BeelsebobWork> Cale: sure -- but it's an abstract model, not a concrete one
08:28:59 <Saizan_> well, one of the uses of monads is to hide some of that concrete plumbing from you, e.g. so you don't have to think in terms of tuples when you use Writer
08:29:01 <Cale> I think it's reasonably concrete anyway...
08:29:27 <chrisdone> SamB: yeah, I don't either
08:29:31 <Cale> Have you seen the view of monads in terms of string diagrams?
08:31:09 <Cale> http://www.youtube.com/view_play_list?p=50ABC4792BD0A086
08:31:10 <lambdabot> Title: YouTube - Broadcast Yourself.
08:31:57 <Cale> It's a rather nice way to view the monad laws as simple topological moves on strings :)
08:36:05 <chrisdone> Cale: woah nice
08:36:15 <bjrn> Say s is a heavy lazy computation that evaluates to a number. If I do  func (seq s s)  is that the same thing as passing the result of s to func?
08:36:31 <Cale> bjrn: seq s s is the same thing as s
08:36:37 <Cale> So no.
08:36:49 <Cale> s `seq` func s  is more like it.
08:36:50 <bjrn> Can I mimic call by value somehow?
08:37:08 <bjrn> Ah nice, will try that
08:37:27 <Cale> Remember that (seq x y) is an expression which *when evaluated* will first evaluate x before resulting in y
08:37:42 <MaxNanasy> Is it possible to create an infinite list of STRefs?
08:37:46 <Cale> So seq x x is always the same thing as x (and possibly even a bit more wasteful)
08:38:04 <Cale> MaxNanasy: yes, though perhaps not distinct ones.
08:38:16 <MaxNanasy> Why not distinct ones?
08:38:25 <bjrn> What I'm doing is I'd like to evaluate an expression completely before passing it to a function, for profiling reasons
08:38:30 <Cale> Because distinct ones require taking a step in the ST monad to create.
08:38:50 <MaxNanasy> I've tried it, and even in the lazy ST monad, it doesn't work.
08:38:56 <quicksilver> right.
08:39:01 <Cale> So you'd have to do infinite amounts of ST computation to get a list like that.
08:39:04 <quicksilver> that's the nature of monadic actions.
08:39:11 <quicksilver> you can cheat with unsafeInterleave though.
08:39:17 <quicksilver> (lazy ST monad? is there one?)
08:39:31 <MaxNanasy> Control.Monad.ST.Lazy
08:39:46 <quicksilver> Interesting. I never knew that.
08:39:54 <MaxNanasy> How would I do it with unsafeInterleave?
08:43:31 <Cale> Uh, is there an unsafeInterleaveST?
08:43:46 <dmwit> bjrn: Check out RNF.
08:43:54 <Cale> ah, yes there is
08:43:56 <Cale> unsafeInterleaveST :: ST s a -> ST s a
08:44:06 <MaxNanasy> What does it do?
08:44:15 <dmwit> bjrn: In Control.Parallel.Strategies or something like that?
08:44:22 <MaxNanasy> I don't see docs for it in the GHC docs.
08:44:25 <thoughtpolice> unsafeInterLeaveST?! madness!
08:44:26 * quicksilver resists the temptation to giggle happily about the fact that unsafeInterleaveIO can now segfault or deadlock unpredictably.
08:44:32 <bjrn> dmwit: thanks, will check it out
08:44:39 <thoughtpolice> quicksilver: 'now'?
08:44:41 <quicksilver> "that'll teach em" ?
08:45:11 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2401
08:45:12 <lambdabot> Title: #2401 (unsafeIOToSTM discards exception handlers.) - GHC - Trac
08:46:10 <Cale> Oh, but the unsafeInterleaveST is for the strict variant of ST apparently.
08:46:32 <MaxNanasy> Yes, and the lazy variant just converts to strict to do it.
08:47:35 <dmhouse> Cale: those lectures are pretty fun, thanks.
08:48:19 <lilac> quicksilver: ooh nasty. i don't think that's something to be happy about.
08:48:28 <quicksilver> lilac: well, I resisted the temptation.
08:48:39 <lilac> i've written code which is externally pure but uses unsafePerformIO, for instance
08:48:42 <quicksilver> lilac: I'm a well known opponent of interleaved IO in all its forms.
08:49:15 <lilac> how do you feel about unamb?
08:49:43 <quicksilver> it is semantically absurd unless you apply its side condition.
08:49:58 <quicksilver> the side condition is a bit weird but if you respect it it's not a bad thing I guess :)
08:50:28 <lilac> even a Monad instance which doesn't follow the monad laws can cause nastiness...
08:50:44 <hackage> Uploaded to hackage: yahoo-web-search 0.2
08:50:56 <quicksilver> not segfaults, I don't think?
08:51:28 <dmhouse> Cale: do you know who the lecturer is?
08:51:44 <thoughtpolice> for the catsters videos on youtube? eugena cheng I think
08:51:53 <quicksilver> eugenia
08:51:53 <lilac> quicksilver: i don't think i can prove that :)
08:52:01 <Cale> Yeah, Simon Willerton
08:52:09 <Cale> and Eugenia Cheng in many of the others
08:52:42 <thoughtpolice> i've only heard very good things about TheCatsters' videos, I should probably watch them sometime :]
08:53:51 <Cale> If you wait long enough, they might even get all the introductory material on category theory in place.
08:54:10 <Cale> They've already worked their way back as far as defining initial and terminal objects. :)
08:54:13 <bjrn> Hehe I've browsed a category theory book. For the untrained eye most of the drawing looks like state machines. :)
08:54:16 <thoughtpolice> yeah see, that's the content I need :]
08:54:38 <thoughtpolice> although I do actually have a copy of pierce's book too
08:54:46 <Cale> http://cale.yi.org/autoshare/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
08:54:49 <lambdabot> Title: cache:http://cale.yi.org/autoshare/Category%20Theory%20-%20S.%20Awodey%20(Claren ..., http://tinyurl.com/62ypee
08:55:46 <dmhouse> Grr, I really wished fullscreen flash worked on Linux.
08:55:54 <Cale> It doesn't?
08:56:04 <therp> I really wished flash worked on Linux.
08:56:09 <Cale> It's worked for me for quite a long time.
08:56:20 <Cale> Probably ever since I installed Ubuntu. :)
08:56:29 <dmhouse> I've got Ubuntu, it's never worked for me.
08:56:30 <bjrn> You can watch youtube videos with mplayer or vlc
08:56:31 <Olathe> I really wish Linux worked.
08:56:33 <Olathe> Oh, wait.
08:56:39 <Cale> hmm
08:56:41 <dmhouse> I suppose I could scrape the video.
08:56:53 <Cale> dmhouse: Which flash player version are you running?
08:57:07 <Cale> (about:plugins should say)
08:57:08 <dmhouse> Cale: whatever default one comes with the latest Ubuntu
08:57:23 <Cale> Shockwave Flash 9.0 r124
08:57:26 <dmhouse> Shockwave Flash 9.0 r48
08:57:27 <Cale> is the version I have
08:57:35 <Cale> ah, maybe you should try upgrading.
08:57:42 <dmhouse> It's perhaps worth a shot.
08:57:46 <quicksilver> I've not had problems with flash on debian for years.
08:57:52 <therp> Cale: thanks. sounds interesting. I'm currently reading Pierce's C.T. for C.S.. I found it to be accessible (despite some negative amazon comments)
08:58:22 <Cale> Awodey's book seems like it would be excellent for CS people :)
08:58:23 <quicksilver> I haven't found any CT book which contains what I consider 'adequate motivation'
08:58:35 <quicksilver> leaving that to one side, I've read plenty of good ones.
08:58:45 <quicksilver> Pierce, MacLean, Popkorn
08:58:46 <Cale> It develops many of the examples reasonably well internally to the book.
08:58:54 <quicksilver> Johnstone
08:59:11 <dmhouse> quicksilver: which Johnstone, just out of interest?
08:59:39 <Cale> I've been reading through it ever since a bit from one of the later chapters provided a really nice intuition for what the Yoneda lemma is really good for.
09:00:09 <quicksilver> dmhouse: well, when I "read" it, it was still a lecture course. I *think* he was going to turn it into a book.
09:00:32 <dmhouse> quicksilver: I mean, what's Johnstone's full name?
09:00:42 <Cale> So I figured it's worth reading through to make sure I haven't missed anything. One nice thing about category theory is that it seems every time I read the early definitions, I get something new out of them. :)
09:01:02 <therp> cale: right ;)
09:01:03 <quicksilver> dmhouse: this one http://www.dpmms.cam.ac.uk/site2002/People/johnstone_pt.html
09:01:07 <lambdabot> Title: Prof. P.T. Johnstone
09:01:13 <dmhouse> Oh cool, he lectured me.
09:01:27 <quicksilver> as he did eugenia
09:01:28 <quicksilver> (and me)
09:01:36 <dmhouse> He was really boring. Pretty well-suited to CT, I guess.
09:01:51 <Cale> Heh.
09:01:53 <dmhouse> He also had really crappy small writing. :)
09:02:18 <Cale> I've actually been finding that category theory can be pretty colourful if looked at in the right ways :)
09:02:44 <bjrn> Can anyone see anything wrong with this? http://hpaste.org/10098 Because the past several hours I've been profiling a memory leak and this little function (which I've written in multiple ways) is the culprit.
09:03:14 <Cale> bjrn: Well, it's tail recursive without being strict...
09:03:21 <quicksilver> bjrn: well it builds up a large thunk in its third parameter
09:03:28 <quicksilver> which will leak space if you never force it.
09:03:38 <bjrn> Ah, #haskell to the rescue :)
09:03:46 <Cale> Also, it's missing two cases.
09:03:46 <quicksilver> but it looks like you just throw the third parameter away?
09:03:56 <quicksilver> matrixmone []     []     initial = res
09:04:04 <bjrn> Oh, initial = res
09:04:07 <quicksilver> ah.
09:04:11 <SamB> bjrn: maybe you should have asked sooner ;-)
09:04:18 <gcd> I have a question regarding the quick sort example in the docs : http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell while the implementation is indeed simplier than the one presented in C, is haskell implementation O(nlgn) too?
09:04:20 <lambdabot> Title: Introduction - HaskellWiki, http://tinyurl.com/eogyw
09:05:10 <quicksilver> Cale: I still don't really see it being a memory leak though.
09:05:19 <quicksilver> Cale: a potential stack overflow if it gets called on very long lists.
09:05:22 <Cale> http://hpaste.org/10098#a1
09:05:30 <Cale> quicksilver: Well, expressions take space :)
09:05:39 <bjrn> Cheers Cale, will try that
09:05:44 <quicksilver> Cale: but the expression isn't forced until its forced.
09:05:55 <quicksilver> Cale: so it's only one (small) thunk until you try to force it.
09:05:55 <bjrn> I combined sum and zipWith first but that was not so good..
09:06:04 <Cale> quicksilver: While it's tail recursing, the expression is getting bigger.
09:06:05 <quicksilver> Cale: then since it's fully strict it will ripple up and down.
09:06:07 <quicksilver> right.
09:06:16 <quicksilver> that's not what I'd call a "leak"
09:06:21 <quicksilver> it's high memory use at one point in time.
09:06:30 <quicksilver> if you get past that time, all that memory should GC.
09:06:39 <Cale> Oh, sure.
09:06:49 <quicksilver> of course maybe that's what bjrn meant.
09:07:15 <quicksilver> bjrn: the definition you had uses O(n) space, and probably is a bit slower than needed, but it doesn't "leak long term".
09:07:28 <Cale> Unless the lists are very long :)
09:07:31 <quicksilver> cale's definition uses O(1) space and should run fast though.
09:08:40 <Cale> bjrn: It's somewhat unfortunate, but  sum  isn't smart enough to be strict on strict numeric types... at least, without compiling with optimisations.
09:09:07 <bjrn> Ah yeah that's somewhat annoying
09:09:08 <Cale> bjrn: The foldl' (+) 0 will ensure that the accumulator gets evaluated on each step through the list.
09:09:12 <bjrn> How's sum written anyhow?
09:09:18 <dmhouse> foldl (+) 0
09:09:19 <Cale> foldl (+) 0
09:09:26 <bjrn> Ah
09:09:41 <Cale> Now, if the compiler consistently applied strictness analysis, it wouldn't be such a problem.
09:10:06 <Cale> (which was the original intent behind that definition)
09:10:39 <quicksilver> bjrn: were you, out of interesting, compiling with optimisations originally?
09:10:46 <bjrn> Ah yes, O2
09:10:50 * quicksilver nods
09:10:53 <Cale> Oh, that's interesting :)
09:10:58 <quicksilver> -O2 should discover strictness in foldl
09:11:11 <quicksilver> I'm somewhat surprised it couldn't discover it for your hand-coded recursion
09:11:15 <quicksilver> but I don't claim to be an expert.
09:11:22 <quicksilver> (on GHC's strictness analyzer)
09:12:03 <bjrn> In either case, Cale's foldl' worked alright, now to apply the same trick elsewhere. Cheers. :)(
09:12:03 <Cale> x = sum (zipWith (*) [1..1000000] [1..1000000])
09:12:03 <Cale> main = print x
09:12:12 <Cale> that program works when compiled with -O2 anyway...
09:12:27 <zachk> hooray, I finally got my pipeline working
09:12:51 <Olathe> > zipWith (*) [1..] [1..]
09:12:53 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
09:13:15 <bjrn> zipWith is really useful.
09:13:26 <Cale> (It still works if you make the limits 10 million rather than 1 million)
09:13:30 <quicksilver> bjrn: You have to learn better internet speak.
09:13:41 <bjrn> zipWith is awesome.
09:13:41 <quicksilver> bjrn: You should say "omfg! zipWith is made of win!"
09:13:52 <Cale> So I think maybe something funny happened when you compiled with -O2 before :)
09:14:07 <quicksilver> if you can illustrate it with a picture of a kitten programming haskell, all the better.
09:14:11 <Cale> Using foldl' is a bit safer anyway
09:14:43 <Cale> 333333383333335000000 is apparently the sum of the first 10 million squares.
09:15:08 <quicksilver> that's a valuable fact. I'm sure I will have occasion to use it soon.
09:15:27 <Olathe> Let us know.
09:15:31 <Beelsebob> > sum $ map (^2) [1..10000000]
09:15:43 <Beelsebob> lambdabot: you fail
09:15:43 <dmhouse> > foldl' (+) 0 $ map (^2) [1..10000000]
09:15:47 <lambdabot>   thread killed
09:16:13 <Olathe> > (`div` 6) . ap ((*) . ap (*) (1 +)) ((1 +) . join (+)) 10000000
09:16:19 <Olathe> lambdabot is slow.
09:16:30 <dmhouse> Probably still swapping from Beelsebob's statement
09:16:35 <Beelsebob> :D
09:16:47 <Olathe> I wonder how hard it is to disable swapping for an application.
09:16:53 <Cale> I'm not sure that mueval applies optimisations
09:17:01 <dmhouse> 33549115002053985083212424842649639068849412802474182611787640942603264920992503 34507359514398037350890352759626267047440593483160340739695483757546928530231102 690141024375907915406794215871479808000000000000000000000000000000000000 was the number of combinations of versions of packages on hackage 13 days ago
09:17:01 <lambdabot>   thread killed
09:17:07 <lambdabot>       No instance for (Num (a -> b))
09:17:08 <lambdabot>        arising from a use of `*' at <int...
09:17:54 <Olathe> > ((`div`6).ap((*).ap(*)(1 +))((1+).join(+))) 10000000
09:17:55 <lambdabot>   333333383333335000000
09:18:34 <lilac> > zomg zipWith is teh win
09:18:36 <lambdabot>   rofl
09:18:48 <bjrn> What's ap?
09:18:59 <Olathe> @src ap
09:18:59 <lambdabot> ap = liftM2 id
09:19:02 <lilac> bjrn: i think you mean "what's ap, doc?"
09:19:02 <Olathe> Eww.
09:19:10 <bjrn> lilac: hehe
09:19:11 <Olathe> @src liftM2
09:19:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:19:25 <ziman> liftM2 ($)
09:19:32 <Olathe> @undo do { x1 <- m1; x2 <- m2; return (id x1 x2) }
09:19:33 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (id x1 x2)
09:19:37 <Cale> :t ap
09:19:37 <roconnor> @src ($)
09:19:38 <lambdabot> f $ x = f x
09:19:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:19:54 <Cale> ap's type is possibly more informative than its code
09:20:10 <Olathe> @pl m1 >>= \ x1 -> m2 >>= \ x2 -> return (id x1 x2)
09:20:11 <lambdabot> (m2 >>=) . (return .) =<< m1
09:20:39 <Cale> > ap [id, (+2), (*2), (^2), (2^)] [5,6]
09:20:40 <lambdabot>   [5,6,7,8,10,12,25,36,32,64]
09:21:01 <Olathe> O-o
09:21:22 <Cale> "Apply these functions to these parameters in all possible ways"
09:21:50 <bjrn> Ah cool
09:22:05 <Cale> > ap (Just (*2)) 5
09:22:06 <quicksilver> a.k.a. "Solve those annoying maths problems you get on the games page before they invented sudoku"
09:22:07 <lambdabot>       No instance for (Num (Maybe a))
09:22:07 <lambdabot>        arising from the literal `5' at ...
09:22:10 <Cale> > ap (Just (*2)) (Just 5)
09:22:10 <dmwit> ap mf m = do { f <- mf; x <- m; return (f x) }
09:22:11 <lambdabot>   Just 10
09:22:16 <Cale> > ap Nothing (Just 5)
09:22:17 <lambdabot>   Nothing
09:22:21 <_zenon_> There should be some kind of "@expand <command>" which not only shows the definition, but also expands the definition.
09:22:21 <Cale> > ap (Just (*2)) Nothing
09:22:23 <lambdabot>   Nothing
09:23:35 <Olathe> @pl let f n = (n*(n+1)*(n+n+1))`div`6 in f
09:23:36 <lambdabot> (`div` 6) . ap ((*) . ap (*) (1 +)) ((1 +) . join (+))
09:23:42 <Olathe> @unpl (`div` 6) . ap ((*) . ap (*) (1 +)) ((1 +) . join (+))
09:23:43 <lambdabot> (\ f -> div (((\ o -> (*) (((*) >>= \ q -> (\ b -> 1 + b) >>= \ p -> return (q p)) o)) >>= \ h -> (\ x -> 1 + (((+) >>= \ y -> y) x)) >>= \ g -> return (h g)) f) 6)
09:23:46 <Olathe> Wow !
09:24:04 <Olathe> @. unpl pl let f n = (n*(n+1)*(n+n+1))`div`6 in f
09:24:05 <lambdabot> (\ f -> div (((\ o -> (*) (((*) >>= \ q -> (\ b -> 1 + b) >>= \ p -> return (q p)) o)) >>= \ h -> (\ x -> 1 + (((+) >>= \ y -> y) x)) >>= \ g -> return (h g)) f) 6)
09:24:46 <Cale> > liftM2 (+) (*10) (*1000) 5
09:24:47 <lambdabot>   5050
09:25:15 <Cale> > ap zip tail [1..10]
09:25:17 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
09:25:32 <ziman> > let fibs = 0:1:ap (zipWith (+)) tail fibs in fibs
09:25:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:25:38 <RayNbow> @src ap
09:25:39 <lambdabot> ap = liftM2 id
09:25:54 <Cale> :t ap
09:25:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:26:16 <Cale> So the monad in question in the  ap zip tail  example is the (->) e monad
09:26:24 <Cale> In that monad,
09:26:28 <ziman> > let fibs' = 1:2:ap (zipWith (*)) tail fibs' in fibs'
09:26:30 <lambdabot>   [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269...
09:26:39 <Cale> ap :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
09:26:51 <ziman> hmm, map (2^) fibs?
09:27:07 <Cale> This is exactly the type of the S combinator which you might know from elsewhere.
09:27:13 <RayNbow> writing down the types really helps in the (e->) monad :)
09:27:18 <Cale> ap x y z = x z (y z)
09:27:21 <RayNbow> it's how I figured out how join works :p
09:28:09 <Cale> I find it very beautiful that the Applicative instance for the (e->) functor is *exactly* the SK calculus.
09:28:25 <Cale> pure = K, <*> = S
09:28:43 <Cale> and the Functor instance is function composition
09:29:11 <dmead> hello #haskell
09:29:14 <Cale> hello :)
09:29:16 <dmead> are you feeling mighty today?
09:29:28 <Olathe> I'm feeling mighty today today.
09:29:37 <dmead> xD
09:29:43 <Olathe> Yesterday, I wasn't feeling mighty today, though :(
09:29:43 <dmead> @hoogle round
09:29:44 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
09:29:44 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
09:29:44 <lambdabot> package HipmunkPlayground
09:29:54 <dmead> @hoogle setprecision
09:29:55 <lambdabot> No results found
09:32:48 <xci> what was the name of the filter that stops immediately when the first element does not match the filter
09:33:01 <Olathe> takeWhile
09:33:08 <Olathe> Or dropWhile
09:33:21 <dmead> takewhile
09:33:26 <Olathe> > takeWhile (< 10) [1..]
09:33:28 <lambdabot>   [1,2,3,4,5,6,7,8,9]
09:33:43 <dmead> > dropWhille (<10 [1..40]
09:33:44 <lambdabot>   mueval: Prelude.read: no parse
09:33:47 <dmead> > dropWhille (<10( [1..40]
09:33:48 <lambdabot>   mueval: Prelude.read: no parse
09:33:50 <dmead> > dropWhille (<10) [1..40]
09:33:51 <lambdabot>   mueval: Prelude.read: no parse
09:33:51 <dmead> omfg.
09:33:58 <dmead> > dropWhile (<10) [1..40]
09:33:59 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34...
09:35:03 <Olathe> > takeWhile even [1..]
09:35:05 <lambdabot>   []
09:35:08 <ari> Wait, what
09:35:09 <dmead> how do you round floats?
09:35:14 <ari> > thisSymbolIsUndefined
09:35:15 <lambdabot>   mueval: Prelude.read: no parse
09:35:19 <dmead> > round 1.234353453
09:35:22 <lambdabot>   1
09:35:27 <Olathe> > round (1.5::Float)
09:35:29 <lambdabot>   2
09:35:33 <_zenon_> > even
09:35:35 <lambdabot>       Overlapping instances for Show (a -> Bool)
09:35:35 <lambdabot>        arising from a use of...
09:35:37 <_zenon_> > even 2
09:35:39 <lambdabot>   True
09:35:40 <dmead> what about truncating?
09:35:46 <dmead> aka setprecision
09:36:25 <Olathe> > floor (1.5::Float)
09:36:27 <lambdabot>   1
09:36:33 <ari> I take it lambdabot has some neat nonstandard feature that's considered worth the bug of producing the wrong error message when it sees an undefined symbol
09:37:15 <Olathe> I'd say it's more that the work to produce a correct message isn't worth it.
09:37:18 <Cale> Heh, subtraction is a functor from the real numbers considered as a category (with a unique arrow x -> y whenever x <= y in R) to the group of real numbers under addition considered as a one object category.
09:37:21 <Olathe> I don't know, though.
09:38:29 <dmead> ari, lambdabot is an expression evaluator, not an ghci session
09:39:06 <Cale> ari: No, it's just a bug.
09:39:23 * ari sees
09:39:53 <Cale> It might be fixed in the next mueval... I'm not sure.
09:40:03 <ari> dmead: I thought there was a distinction between "unparseable" and "containing undefined symbols"...
09:40:23 <Cale> gwern doesn't want to release that until the new haskell-src-exts gets released to hackage.
09:40:25 <dmead> indeed
09:40:43 <dmead> can you show an example of what you mean?
09:40:45 <dmead> ari
09:40:49 <Cale> So the mueval for now has some bugs which might already be fixed.
09:41:37 <ari> dmead: Unparseable expression: "(". Expression containing undefined symbols: "hello".
09:42:17 <dmead> a string of lower case characters is parseable... to a symbol
09:42:21 <dmead> a hanging paren isn't
09:42:28 <dmead> it's just that the symbol doesn't exist
09:42:53 <ari> dmead: Wait, I'm confused. Is there somewhere we're disagreeing?
09:42:59 <dmead> don't think so
09:43:05 <dmead> :P
09:43:08 * ari nods, relieved
09:43:58 <_zenon_> @unpl ap
09:43:58 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
09:44:46 <Olathe> @undo ap
09:44:46 <lambdabot> ap
09:44:52 <Olathe> @redo ap
09:44:52 <lambdabot> ap
09:45:45 <_zenon_> @unpl fix
09:45:45 <lambdabot> fix
09:45:56 <dmead> how would i round 1.1234 to 1.1?
09:45:58 <dmead> anybody?
09:46:20 <Olathe> Let me try to make a spiffy function for that.
09:46:28 <Saizan_> Cale: yes, it's fixed
09:46:28 <mmorrow> > (/10) . round . (*10) $ 1.1234
09:46:30 <lambdabot>   Add a type signature
09:46:48 <mmorrow> > ((/10) . round . (*10) $ (1.1234::Double))::Double
09:46:50 <lambdabot>       No instance for (Integral Double)
09:46:50 <lambdabot>        arising from a use of `round' ...
09:46:51 <nominolo> @seen lemmih
09:46:51 <lambdabot> lemmih is in #haskell-blah and #haskell. I don't know when lemmih last spoke.
09:46:57 <mmorrow> > ((/10) . fromIntegral . round . (*10) $ (1.1234::Double))::Double
09:46:59 <lambdabot>   1.1
09:47:09 <Olathe> > let roundTo n x = round ((10^n)*x)/(10^n) in roundTo 1 1.1234
09:47:11 <lambdabot>   Add a type signature
09:47:14 <Olathe> No, you add one !
09:47:22 <_zenon_> hehe
09:47:28 <ziman> @yarr
09:47:29 <lambdabot> Swab the deck!
09:47:38 <_zenon_> @unpl round
09:47:38 <lambdabot> round
09:47:45 <Cale> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo 1 1.1234
09:47:46 <Olathe> > let roundTo :: (Fractional a) => a -> a -> a; roundTo n x = round ((10^n)*x)/(10^n) in roundTo 1 1.1234
09:47:47 <lambdabot>   1.1
09:47:48 <lambdabot>       Could not deduce (RealFrac a) from the context (Fractional a)
09:47:49 <lambdabot>        ar...
09:48:07 <cjay> @vixen Swab the deck!
09:48:08 <lambdabot> who?
09:48:10 <Olathe> > let roundTo :: (Fractional a) => a -> a -> a; roundTo n x = round ((10^n)*x)/(10^n) in map (\n -> roundTo n 1.1234) [0..]
09:48:12 <lambdabot>       Could not deduce (RealFrac a) from the context (Fractional a)
09:48:12 <lambdabot>        ar...
09:48:22 <Cale> You're still missing a fromIntegral
09:48:25 <Olathe> Ahh, Cale has it.
09:48:27 <Cale> :t round
09:48:29 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:48:39 <Cale> There's nothing which is both Integral and RealFrac
09:48:54 <Olathe> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo 1 1.1234 in map (\n -> roundTo n 1.1234) [0..]
09:48:56 <lambdabot>   mueval: Prelude.read: no parse
09:49:00 <Olathe> No parse ?!
09:49:13 <Olathe> Bah.
09:49:14 <quicksilver> one let, two ins.
09:49:19 <Olathe> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n 1.1234) [0..]
09:49:19 <Cale> actually it really is no parse in this case :)
09:49:21 <lambdabot>   [1.0,1.1,1.12,1.123,1.1234,1.1234,1.1234,1.1234,1.1234,1.1234,1.1234,1.1234...
09:49:37 <Cale> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n pi) [0..] :: [CReal]
09:49:40 <lambdabot>   [3.0,3.1,3.14,3.142,3.1416,3.14159,3.141593,3.1415927,3.14159265,3.14159265...
09:50:03 <Olathe> Haskell has a Cereal type.
09:50:15 <Olathe> Now all it needs is some Milk.
09:50:38 <mmorrow> > fmap (uncurry subtract) . zip`ap`tail $ (let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n pi) [0..] :: [CReal])
09:50:40 <byorgey> I think you mean MIlk
09:50:40 <lambdabot>       precedence parsing error
09:50:40 <lambdabot>          cannot mix `(.)' [infixr 9] and `ap' ...
09:50:50 <mmorrow> > fmap (uncurry subtract) . (zip`ap`tail) $ (let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n pi) [0..] :: [CReal])
09:50:52 <lambdabot>   [0.1,0.04,0.002,-0.0004,-0.00001,0.000003,-0.0000003,-0.00000005,0.00000000...
09:50:52 <byorgey> that's the type of things that are sort of like monads, perhaps?
09:50:53 <Olathe> There's a MIlk ?
09:51:03 <mmorrow> > fmap (abs . uncurry subtract) . (zip`ap`tail) $ (let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n pi) [0..] :: [CReal])
09:51:05 <lambdabot>   [0.1,0.04,0.002,0.0004,0.00001,0.000003,0.0000003,0.00000005,0.000000004,0....
09:51:27 <dmead> let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo .1 1.12
09:51:32 <mmorrow> > sum . take 10 . fmap (abs . uncurry subtract) . (zip`ap`tail) $ (let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in map (\n -> roundTo n pi) [0..] :: [CReal])
09:51:34 <lambdabot>   0.1424133544
09:51:46 <dmead> let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo .1 1.12
09:51:54 <dmead> err..
09:51:56 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo .1 1.12
09:51:58 <lambdabot>       Overlapping instances for Show (a -> t -> b1)
09:51:58 <lambdabot>        arising from a use...
09:52:02 <dmead> wat
09:52:14 <Cale> You tried to print a function?
09:52:19 <dmead> apparently
09:52:22 <Cale> Oh, you wrote .1
09:52:29 <mmorrow> > .1
09:52:31 <lambdabot>   mueval: Prelude.read: no parse
09:52:32 <Deewiant> roundTo . 1
09:52:37 <Cale> That is treated as the composition operator applied to 1
09:52:39 <Deewiant> ?ty (.1)
09:52:40 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo (.1) (1.12)
09:52:40 <mmorrow> > 0.
09:52:41 <lambdabot> forall b c a. (Num (a -> b)) => (b -> c) -> a -> c
09:52:41 <Olathe> > let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n) in map (\n -> fTo floor n pi) [0..]
09:52:43 <lambdabot>   mueval: Prelude.read: no parse
09:52:43 <lambdabot>       No instance for (Integral ((b -> c) -> a -> c))
09:52:44 <lambdabot>        arising from a u...
09:52:44 <lambdabot>  Terminated
09:52:44 <dmead> ah
09:52:56 <Cale> roundTo .1 1.12 --> roundTo . (1 1.12)
09:53:00 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo (1.12) (.1)
09:53:02 <lambdabot>       No instance for (RealFrac ((b -> c) -> a -> c))
09:53:02 <lambdabot>        arising from a u...
09:53:16 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo (.1) (1.01)
09:53:18 <lambdabot>       No instance for (Integral ((b -> c) -> a -> c))
09:53:18 <lambdabot>        arising from a u...
09:53:20 <dmead> ?
09:53:24 <Cale> Which makes sense only if there's an instance of Num for functions :)
09:53:32 <Cale> .1 is not a number
09:53:35 <Cale> Write 0.1
09:53:35 <mmorrow> > 0.1 == .1
09:53:35 <Olathe> > let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n) in fTo floor 2 pi)
09:53:37 <lambdabot>   mueval: Prelude.read: no parse
09:53:37 <lambdabot>  Terminated
09:53:39 <Olathe> > let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n) in fTo floor 2 pi
09:53:41 <lambdabot>   3.14
09:53:44 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo (0.1) (1.01)
09:53:46 <lambdabot>   Add a type signature
09:53:54 <Olathe> > let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n) in map (\n -> fTo floor n pi) [1..]
09:53:57 <lambdabot>   [3.1,3.14,3.141,3.1415,3.14159,3.141592,3.1415926,3.14159265,3.141592653,3....
09:54:22 <Cale> Ah, now you have a type error because ^ only works with nonnegative integer exponents
09:54:35 <Deewiant> > 1 ^ (-1)
09:54:38 <lambdabot>   mueval: Prelude.read: no parse
09:54:38 <lambdabot>  mueval: *** Exception: Negative exponent
09:54:50 <Cale> > 1 ^^ (-1)
09:54:51 <dmead> > let roundTo n x = fromIntegral (round ((10^n)*x))/(10^n) in roundTo (3.12) (0.1)
09:54:53 <lambdabot>   1.0
09:54:53 <lambdabot>   Add a type signature
09:55:02 <dmead> what the crap
09:55:05 <dmead> what am i doing wrong?
09:55:15 <dmead> thats totally not returning a function
09:55:19 <Cale> You're rounding to a non-integer...
09:55:34 <dmead> > let roundTo n x = (round ((10^n)*x))/(10^n) in roundTo (3.12) (0.1)
09:55:36 <lambdabot>   Add a type signature
09:55:36 <mmorrow> > let roundN n d = let x = 10**n in (/x) . fromIntegral . round . (*x) $ d in roundN 2 pi
09:55:38 <lambdabot>   3.14
09:55:43 <Cale> ^n only makes sense when n is a (positive) integer
09:55:51 <mmorrow> > let roundN n d = let x = 10**n in (/x) . fromIntegral . round . (*x) $ d in roundN pi pi
09:55:52 <dmead> > let roundTo n x = (round ((10^n)*x))/(10^n) in roundTo (3.12) (1)
09:55:54 <lambdabot>   Add a type signature
09:55:54 <lambdabot>  Terminated
09:56:07 <Cale> > let roundTo n x = (round ((10**n)*x))/(10**n) in roundTo (3.12) 1
09:56:09 <lambdabot>   Add a type signature
09:56:17 <dmead> o0
09:56:19 <Cale> > let roundTo n x = fromIntegral (round ((10**n)*x))/(10**n) in roundTo (3.12) 1
09:56:21 <lambdabot>   0.9998052438884639
09:56:24 <Cale> there.
09:56:39 <mmorrow> heh
09:56:52 <Cale> If you need fractional exponents, then ^ is not the exponentiation operator for you :)
09:56:59 <Cale> Use ** instead
09:57:05 <dmead> > let roundTo n x = fromIntegral (round ((10**n)*x))/(10**n) in roundTo (1.01) 1
09:57:07 <lambdabot>   0.9772372209558107
09:57:15 <dmead> that doesn't make much sense
09:57:31 <dmead> > let roundTo n x = fromIntegral (round ((10**n)*x))/(10**n) in roundTo (1) 1
09:57:31 <Cale> Right, because rounding to a non-integer number of places doesn't make much sense :)
09:57:33 <lambdabot>   1.0
09:57:41 <dmead> oh
09:57:49 <dmead> > let roundTo n x = fromIntegral (round ((10**n)*x))/(10**n) in roundTo (1) 1.123
09:57:52 <lambdabot>   1.1
09:57:53 <dmead> ah
09:57:55 <dmead> i see
09:57:59 <ziman> :t (^)
09:58:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:58:03 <dmead> i got it backwards :P
09:58:11 <ziman> :t (**)
09:58:13 <lambdabot> forall a. (Floating a) => a -> a -> a
09:58:34 <Olathe> @let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n); roundTo = fTo round; floorTo = fTo floor
09:58:36 <lambdabot>  Defined.
09:58:42 <Olathe> @roundTo 5 pi
09:58:43 <lambdabot> Unknown command, try @list
09:58:47 <Olathe> > roundTo 5 pi
09:58:49 <lambdabot>   3.14159
09:58:59 <ziman> > roundTo 5 1
09:59:01 <lambdabot>   1.0
10:00:09 <Cale> > showCReal 100 (roundTo 50 pi)
10:00:11 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Double'
10:00:17 <Cale> ...
10:00:33 <Olathe> > showCReal 100 (roundTo 50 pi)::CReal
10:00:33 <Cale> Stupid numeric defaulting nonsense...
10:00:35 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Double'
10:00:43 <Olathe> > showCReal 100 ((roundTo 50 pi)::CReal)
10:00:45 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Double'
10:00:45 <Cale> :t roundTo
10:00:48 <lambdabot> forall b t b1. (RealFrac t, Fractional b1, Integral b) => b -> t -> b1
10:00:49 <Olathe> Stop inferring !
10:00:51 <Cale> hmm
10:01:05 <mmorrow> @type pi :: CReal
10:01:06 <Olathe> :t 1::CReal
10:01:07 <lambdabot> CReal
10:01:08 <lambdabot> CReal
10:01:16 <Olathe> :t CReal
10:01:18 <lambdabot> Not in scope: data constructor `CReal'
10:01:22 <Cale> > showCReal 100 (roundTo 50 (pi :: CReal) :: CReal)
10:01:24 <lambdabot>   Couldn't match expected type `Double' against inferred type `CReal'
10:01:28 <Cale> interesting.
10:01:31 <mmorrow> weird
10:01:47 <Cale> In fact, the outer constraint there should be unnecessary.
10:01:57 <Cale> (showCReal already imposes it)
10:02:07 <Cale> But, Double?
10:02:15 <mmorrow> yeah, wtf
10:02:19 <Cale> My guess is that mueval has the MR turned on.
10:02:24 <Cale> Whereas :type does not.
10:02:29 <mmorrow> ah
10:02:51 <Cale> @undefine
10:03:30 <Olathe> > let cfTo :: (CReal -> CReal) -> CReal -> Integral -> CReal; cfTo f n x = fromIntegral (f ((10^n)*x))/(10^n); croundTo = cfTo round; cfloorTo = cfTo floor in croundTo 5 pi
10:03:32 <lambdabot>       Class `Integral' used as a type
10:03:32 <lambdabot>      In the type `Integral'
10:03:32 <lambdabot>      In the...
10:03:45 <Olathe> > let cfTo :: (Integral a) => (CReal -> CReal) -> CReal -> a -> CReal; cfTo f n x = fromIntegral (f ((10^n)*x))/(10^n); croundTo = cfTo round; cfloorTo = cfTo floor in croundTo 5 pi
10:03:47 <lambdabot>   Couldn't match expected type `CReal' against inferred type `a'
10:03:49 <Cale> @let fTo :: (RealFrac t, Fractional b1, Integral b) => (t -> b) -> b -> t -> b1; fTo f n x = fromIntegral (f ((10^n)*x))/(10^n); roundTo = fTo round; floorTo = fTo floor
10:03:50 <lambdabot>  Defined.
10:03:59 <Cale> > showCReal 100 (roundTo 50 (pi :: CReal) :: CReal)
10:04:01 <lambdabot>   Couldn't match expected type `Double' against inferred type `CReal'
10:04:06 <Cale> oh!
10:04:10 <Cale> @undefine
10:04:24 <Olathe> Is pi Double ?
10:04:28 <Cale> @let fTo f n x = fromIntegral (f ((10^n)*x))/(10^n); roundTo x = fTo round x; floorTo x = fTo floor x
10:04:29 <lambdabot>  Defined.
10:04:30 <mmorrow> @type pi :: CReal
10:04:32 <lambdabot> CReal
10:04:34 <Cale> Obvious.
10:04:36 <Cale> > showCReal 100 (roundTo 50 (pi :: CReal) :: CReal)
10:04:38 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
10:04:56 <Olathe> Why did that fix it ?
10:05:09 <Cale> Because roundTo = fTo round is a pattern binding
10:05:15 <Cale> So the MR applies to it.
10:05:23 <Olathe> What is MR ?
10:05:31 <Cale> Monomorphism restriction...
10:05:48 <Cale> It says that pattern bindings without an explicit type signature must have non-polymorphic types.
10:06:11 <quicksilver> Heffalump++ # injecting santiy
10:06:12 <Cale> Which makes numeric defaulting kick in and the type was being defaulted to Double
10:06:38 <Cale> The MR is right up there with fail in terms of H98 fail.
10:07:12 <Cale> (it's a stupid rule which causes more problems than it fixes)
10:07:44 <quicksilver> I maintain switching it off will cause more problems than most people realise.
10:07:54 <quicksilver> however I have, thus far, been too lazy to prove it :)
10:08:04 <Cale> I maintain that turning it into a compiler warning will give the best of both worlds.
10:08:11 <Olathe> All you need is for someone to print out your proof to fix that.
10:08:49 <Cale> If you care at all about performance, you're probably being specific about your types anyway.
10:08:59 <ddarius> quicksilver: I can't see how turning it off could possibly cause more problems.
10:09:00 <matthew-_> NoMR is one of my default flags, I have to say
10:09:15 <Cale> matthew-_: same here
10:09:24 <quicksilver> ddarius: it increases the number of annotations you need in code which uses the MR to cascade types.
10:09:36 <ddarius> quicksilver: By one.
10:09:39 <quicksilver> ddarius: you can argue that this is a deficit in defaulting, or that such code is bad.
10:09:45 <quicksilver> ddarius: no, by much more than one, sometimes.
10:09:57 <quicksilver> MR can cascade types 1-to-n
10:09:59 <augustss> The defaulting is a hack
10:10:17 <Cale> I turned it off after blowing half an hour on trying to find out why my ST computations were producing type errors before realising that it was my definition of forM = flip mapM
10:10:18 <matthew-_> Cale: yeah, but so is overlapping instances, undecidable instances, flexible whatnots and functional dependencies ;)
10:10:25 <quicksilver> ddarius: rotate :: MatrixComponent c => c -> c -> c -> c -> IO ()
10:10:34 <quicksilver> ddarius: where c is a numeric type, in fact.
10:10:38 <FliPPehhh> Anyone using SciTE to write Haskell code?
10:10:52 <FliPPehhh> I just fixed mine to colorize 0x(...)
10:10:52 <quicksilver> the MR means that one concrete annotation 'ripples' in and out of all such invokations.
10:11:00 <quicksilver> typically you just need to annotate your top level.
10:11:00 <FliPPehhh> Maybe someone wants to know how to ;d
10:11:13 <quicksilver> remove the MR, and local definitions become fully polymorphic
10:11:18 <quicksilver> and you need to annotate them all.
10:11:50 <Cale> quicksilver: Or perhaps create a single specialised local definition for rotate.
10:12:16 <quicksilver> yes, true.
10:12:29 <quicksilver> maybe "I'm doing it wrong" is the correct answer
10:12:31 <quicksilver> I don't rule that out.
10:12:46 <quicksilver> But I'm fairly sure I have h98-compliant code which will require a lot more annotations if we remove the MR.
10:12:55 <quicksilver> (of course, I could turn it back on for that file, presumably)
10:13:10 <Cale> Have you tried compiling lots of your code with the MR turned off?
10:13:11 <Deewiant> {-# LANGUAGE MonomorphismRestriction #-}  :-)
10:13:29 <quicksilver> Cale: No. That's what I was referring to with "however I have, thus far, been too lazy to prove it"
10:13:40 <Cale> It would be interesting to know how much of your code needs the MR to compile
10:13:50 <Cale> I have a suspicion that it won't be so bad.
10:14:06 <quicksilver> haskell's laziness is seldom in excess. quicksilver's always is.
10:14:43 <ddarius> NHC doesn't even implement the monomorphism restriction
10:15:30 <Cale> That's because NHC is cooler than NHC.
10:15:52 <ddarius> "cooler than" meaning "cooler than or equal to" ?
10:16:45 <SamB> ddarius: certainly the relation in question doesn't have the irreflexive property
10:17:03 <Cale> Actually, no, it's HBC which is cooler than HBC. NHC is exactly as cool as NHC.
10:17:10 <BMeph> FliPPehhh: Sorry, I use Notepad++, but am slowly going back to using Emacs. :)
10:18:16 <Cale> Somewhat in the same sense as Lisp machines are cooler than Lisp machines. :)
10:18:50 <pgavin> @seen dcoutts_
10:18:50 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts_ speak 15m 7s ago.
10:18:56 <dcoutts_> hia pgavin
10:19:06 <pgavin> dcoutts_: hi :)
10:19:17 <Deewiant> hmm, HBC is somewhat old
10:19:26 <pgavin> dcoutts_: just wanted to make sure my opensparc app was received properly
10:19:38 <dcoutts_> pgavin: yes, we got it, don't worry.
10:19:39 <pgavin> dcoutts_: b/c I never got an email back or anything :)
10:19:46 <pgavin> dcoutts_: great, thanks :)
10:19:46 <ddarius> Deewiant: So?
10:19:52 <Cale> I wonder if HBC is still beating GHC at any benchmarks :)
10:19:57 <dcoutts_> pgavin: sorry, I probably should have sent a confirm or something
10:19:58 <ddarius> It is the oldest Haskell compiler.
10:20:10 <Deewiant> ddarius: Nothing, just made an observation :-)
10:20:22 <Deewiant> I don't think I was aware of its existence until now
10:20:47 <mmorrow> i recently got an hbc binary and it's pretty cool
10:20:53 <mmorrow> > data A = A | B deriving (Show);
10:20:53 <mmorrow> data A = A | B deriving (Show)
10:20:53 <mmorrow> > A;
10:20:53 <mmorrow> A
10:20:54 <lambdabot>   mueval: Prelude.read: no parse
10:20:55 <lambdabot>  Terminated
10:21:07 <mmorrow> ghci should have that ability!
10:21:30 <mmorrow> (that was in hbi)
10:21:43 <ddarius> hbc has some significant improvements on all other implementations
10:22:02 <Cale> Also note that HBC never implemented Haskell 98, which automatically makes it cool. :)
10:22:17 <ddarius> Cale: Actually it did.
10:22:25 <Cale> oh?
10:22:42 <ddarius> A few years ago they announced a new release of HBC that did support H98.
10:23:02 <Cale> Ah, then perhaps http://www.cs.chalmers.se/~augustss/hbc/hbc.html is not the true URL?
10:23:10 <lambdabot> Title: The HBC compiler
10:23:26 <Cale> Well, it claims Haskell 1.4 anyway :)
10:23:51 <Cale> Haskell 1.4 is much cooler than 98 in many ways :)
10:24:05 <thoughtpolice> how so? :]
10:24:14 <Cale> The Prelude mostly.
10:24:39 <augustss> There's a H98 version of hbc, but it's not been released properly.
10:25:19 <thoughtpolice> Cale: I'll have to check the reports; I'm long overdue to read bits of the h98 report...
10:25:24 <Cale> It had
10:25:50 <Cale> class Functor f where map :: (a -> b) -> f a -> f b
10:26:12 <Cale> Monad had no fail
10:26:15 <augustss> And Functor was a superclass of Monad
10:26:17 <Cale> There was MonadZero
10:26:20 <Cale> yeah
10:26:33 <Deewiant> :-O
10:26:39 <Deewiant> what happened?
10:26:39 <augustss> It was the Haskell version where most things were right
10:26:41 <Cale> and  (++) :: MonadPlus m => m a -> m a -> m a
10:26:54 <SamB> see, this is why I don't like Haskell'
10:27:00 <SamB> they started from the wrong version of Haskell
10:27:01 <Cale> The Haskell 98 committee had a bunch of people on it who were afraid of polymorphism
10:27:02 <Deewiant> what went wrong?
10:27:07 <Deewiant> :-/
10:27:37 <Cale> Also, the one thing which I think snowballed into most of the fail is that they removed monad comprehensions.
10:27:55 <augustss> H98 turned too pragmatic.
10:28:21 <lilac> Cale: how did monad comprehensions differ from do notation?
10:28:31 <Cale> lilac: List comprehensions worked in any monad.
10:28:42 <Cale> Well, any MonadZero
10:28:52 <Cale> (since you have guards)
10:29:18 <lilac> isn't that basically do notation but with the last expression written first?
10:29:32 <Cale> yes, except you can have guards
10:29:37 <dcoutts_> @type guard
10:29:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:29:42 <Cale> and it gives a different way of looking at things :)
10:29:45 <thoughtpolice> augustss: would you say it was a worthy tradeoff or haskell 1.4 was better at 'avoiding success at all costs' or something?
10:31:06 <augustss> I think the compromises made in H98 were not necessary.  We could have gotten the same improvements by better compiler error messages, because that's what the changes were mostly about.
10:31:47 <FliPPehhh> Can someone explain me / give me links to information about the "data" thing? Looks like a type combining a lot of other types, much like a struct in imperative languages - what is it in Haskell?
10:32:30 <Cale> FliPPehhh: It's like that, only you can have multiple cases.
10:32:54 <Cale> FliPPehhh: That is, more than one option for what kind of structure you have.
10:33:02 <Cale> FliPPehhh: Also, they can be recursive.
10:33:06 <dmhouse> FliPPehhh: you basically "tag" values with a data constructor
10:33:12 <FliPPehhh> Mhmm
10:33:38 <dmhouse> FliPPehhh: if you have data Foo = A | B, and you have a value foo :: Foo you can tell whether foo is A or B using pattern matching
10:33:39 <dcoutts_> augustss: it'd be an interesting experiment to compile all of hackage with map = fmap, ++ = mappend and see how many type ambiguities crop up
10:34:14 <augustss> dcoutts_: and no MR
10:34:21 <dcoutts_> augustss: ah yes, that too
10:34:49 <Cale> The syntax is roughly:  data <Type Name> <Type Parameters> = <Data Constructor> <Types of Parameters> | <Data Constructor> <Types of Parameters> | ...
10:34:58 <dcoutts_> it should be a fairly doable experiment actually, using cabal-install's build logging and reporting
10:35:22 <Cale> So, for example, you might have a fairly simple datatype:
10:35:39 <Cale> data Person = P String Integer
10:35:45 <FliPPehhh> Hmm okayy
10:35:54 <Cale> Here, Person is the name of the new type you've defined
10:36:17 <Cale> P is a data constructor, it takes two parameters, a String and an Integer, and produces a Person from them
10:36:31 <Cale> (P "Cale" 25) is then a Person value
10:36:50 <Cale> Making things a little more complicated...
10:37:16 <Olathe> You can't speed up babies by adding mothers, except with Haskell.
10:37:39 <Cale> data Employee = Boss String Integer | Underling String -- no need to pay the underlings :)
10:39:22 <Cale> So now we can have values of type Employee like  Boss "Mr. Bigshot" 2500000  and  Underling "Unlucky Joe"
10:39:57 <Cale> functions which act on values of type Employee will pattern match like this:
10:40:19 <Cale> raise n (Boss name salary) = Boss name (salary + n)
10:40:33 <Cale> raise n (Underling name) = Underling name
10:40:50 <Cale> Would have type  Employee -> Employee
10:41:02 <Cale> FliPPehhh: making sense?
10:42:21 <FliPPehhh> I guess so
10:42:34 <FliPPehhh> Only the declarating syntax seems a bit strange to me
10:42:41 <FliPPehhh> Type name is obvious
10:43:00 <FliPPehhh> Parameters? I thought they were for functions
10:43:28 <BONUS_> well constructors are functions, basically
10:43:56 <Deewiant> > let f = Just in (f 1, f 2)
10:43:58 <lambdabot>   (Just 1,Just 2)
10:44:08 <BONUS_> > map Just [1,2,3,4]
10:44:09 <BONUS_> etc
10:44:10 <lambdabot>   [Just 1,Just 2,Just 3,Just 4]
10:45:11 <thoughtpolice> i wonder when someone is going to make an oleg action figure
10:45:12 <FliPPehhh> I'm gonna experiment with it, thanks :)
10:45:15 <thoughtpolice> he deserves one by now
10:45:40 <FliPPehhh> Any tutorials for practical Haskell use? I currently only saw the Scheme and IRC one
10:45:49 <thoughtpolice> "have your own oleg - now with HM type-checking action!"
10:45:49 <Deewiant> realworldhaskell.org
10:46:02 <FliPPehhh> While I can perfectly write factorial methods now, I don't know how to read files or anything
10:46:19 <Deewiant> more precisely, http://book.realworldhaskell.org/read/
10:46:20 <byorgey> "(spj sold separately.  type system not included.)"
10:46:21 <lambdabot> Title: Real World Haskell
10:46:24 <thoughtpolice> FliPPehhh: the real world haskell book is really good, i suggest it
10:46:54 <FliPPehhh> Thanks for the tip :)
10:46:56 <thoughtpolice> byorgey: spj + wadler action pack!
10:47:03 <byorgey> ooooh!
10:47:14 <byorgey> collect all 3!
10:47:27 <byorgey> hm, I think shapr should have one too =)
10:47:32 <lilac> Warning: may contain uninhabited types
10:47:44 <byorgey> not suitable for C++ programmers
10:47:46 <Deewiant> get free plush lambdas if you get the whole set at once
10:47:52 <thoughtpolice> byorgey: we could have a #haskell mini-figure collection. collect all 400+ before they run out!
10:48:03 <byorgey> hehe, awesome =)
10:48:55 <SamB_XP> Cale: you can design 400+ minifigs in <=24 hours, right?
10:48:57 <thoughtpolice> on that note, something like a lambdabot plushie would be awesome and I would buy one - seriously.
10:49:13 <byorgey> heh, what would a lambdabot plushie look like?
10:49:19 <SamB_XP> like lambdabot
10:49:27 <byorgey> oh, of course, sorry.
10:49:38 <SamB_XP> you ain't never seen the picture?
10:49:44 <thoughtpolice> http://haskell.org/haskellwiki/Lambdabot
10:49:45 <lambdabot> Title: Lambdabot - HaskellWiki
10:49:47 <byorgey> oh, yes, I have =)
10:49:48 <thoughtpolice> ^^ i can dig that representation
10:49:49 <Cale> FliPPehhh: Ah, I hadn't got to that part yet... the types you define can have other types as parameters.
10:50:00 <Cale> SamB_XP: minifigs?
10:50:11 <byorgey> Cale: read the scrollback =)
10:50:31 <SamB_XP> based on IRC nicks alone, no less
10:50:56 <thoughtpolice> basically we need 2"-3" tall, immovable (to be simple) figurines representing all of #haskell
10:51:11 <thoughtpolice> i call the one that is entirely black and has a gigantic white '?' on the chest
10:51:14 <_zenon_> thoughtpolice, omg, that will be a lot of figures
10:51:39 <_zenon_> Hockeycards-ish are better idea then
10:51:45 <SamB_XP> well, SamB_XP can just look like SamB with a Windows logo
10:51:45 <_zenon_> Buy your #haskell booster packs!
10:52:17 <byorgey> hm, or #haskell, the card-based RPG!
10:52:31 <SamB_XP> gotta capture 'em all?
10:52:33 <_zenon_> lambdabot would have to be super-rare
10:52:35 <_zenon_> hehehe
10:52:35 <_zenon_> :)(
10:52:44 <thoughtpolice> I CHOOSE YOU, CONTROL.APPLICATIVE!
10:52:46 <SamB_XP> (as in name capture)
10:53:48 <SamB_XP> fmap allows me to apply a function of type a -> b to a functor over a, giving that same functor over b
10:54:05 <Deewiant> control.applicative used liftA!
10:54:10 <Deewiant> It's super effective!
10:55:36 <SamB_XP> (leave it to yu-gi-oh to explain such a simple function with which all present are already familiar in the middle of a battle!)
10:56:35 * thoughtpolice used quickcheck - bugs reduced by 40%
10:57:33 <thoughtpolice> no unsafeCoerce# though - then it's just "/me used unsafeCoerce# and segfaulted your entire deck!" and you lose :[
10:58:32 <SamB> wouldn't that destroy both participants?
11:00:12 <sw17ch> is any one else having problems with haskell.org responding slowly or with incomplete responses?
11:00:32 <thoughtpolice> hm, yes, likely.
11:01:13 <thoughtpolice> unsafePerformIO could be one too, but i'm not sure off hand how to use such a card :]
11:02:02 <thoughtpolice> sw17ch: seems to be loading fine for me
11:02:10 <sw17ch> alright
11:02:38 <thoughtpolice> but for serious, we should formalize the rules of this card game. we could play on IRC and call it haskellrpg :]
11:03:56 <lilac> thoughtpolice: perhaps all Haskell functions as cards, and you must play a well-typed card? you lose if you complete an expression
11:04:42 <trofi> :t arr
11:04:44 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:05:18 <Deewiant> lilac: probably too easy with (.) and ($)
11:11:21 <ziman> :t pure
11:11:23 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
11:11:41 <Jaak> @hoogle f a -> a
11:11:42 <lambdabot> Data.Monoid getDual :: Dual a -> a
11:11:42 <lambdabot> Foreign unsafePerformIO :: IO a -> a
11:11:42 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
11:12:22 <Jaak> @hoogle (w a -> b) -> (w a -> w b)
11:12:23 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
11:12:23 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t d -> q) -> d -> q
11:12:23 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
11:12:55 <Olathe> > $ (+) 1 2
11:12:57 <lambdabot>   mueval: Prelude.read: no parse
11:12:59 <Olathe> > ($) (+) 1 2
11:13:01 <lambdabot>   3
11:13:09 <Deewiant> > ($) ($) (+) 1 2
11:13:11 <lambdabot>   3
11:13:47 <Jaak> :t fix ($)
11:13:49 <lambdabot> forall a b. a -> b
11:14:13 <Olathe> > fix ($) (+) 1 2
11:14:28 <lambdabot>   thread killed
11:15:37 <Jaak> fix me a dollar
11:18:24 <saml> ghc-6.8.2: internal error: loadObj: can't map `/usr/lib/ghc-6.8.2/lib/base-3.0.1.0/HSbase-3.0.1.0.o'
11:18:33 <saml> (GHC version 6.8.2 for x86_64_unknown_linux)
11:19:21 <thoughtpolice> i will have to ponder on my card game idea later :]
11:19:35 <saml> that's when I get when I tried HCodecs from hackage
11:19:38 <newsham> o'saml
11:22:44 <saml> oh after i started ghci then runhaskell Setup.hs configure  worked
11:39:37 <desp> > '\''
11:39:40 <lambdabot>   '\''
11:39:49 <trofi> > say "\'"
11:39:51 <lambdabot>   mueval: Prelude.read: no parse
11:40:14 <desp> > say ('\'' : [])
11:40:14 <Olathe> > say "hi"
11:40:17 <lambdabot>   mueval: Prelude.read: no parse
11:40:17 <lambdabot>  Terminated
11:40:19 <Olathe> > say "hi"
11:40:22 <lambdabot>   mueval: Prelude.read: no parse
11:40:48 <Olathe> > say "hi"
11:40:51 <lambdabot>   hi
11:40:56 <Olathe> > say "\'"
11:40:59 <lambdabot>   '
11:42:33 <Olathe> @let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g
11:42:34 <lambdabot>   Parse error
11:42:41 <Olathe> > let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g in ffib 6
11:42:45 <lambdabot>   8
11:42:52 <Olathe> Why is there a parse error in the @let ?
11:46:38 <trofi> :t unfold
11:46:40 <lambdabot> Not in scope: `unfold'
11:47:44 <Saizan_> :t unfoldr
11:47:45 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:55:27 <koweywork> http://bugs.darcs.net/msg5883 <-- anybody up for getting GHC 6.8.3 into Ubuntu's Intrepid ?
11:55:28 <lambdabot> Title: Message 5883 - Darcs bug tracker
12:01:05 <tromp> > ()
12:01:07 <lambdabot>   ()
12:03:34 <Olathe> > (())
12:03:37 <lambdabot>   ()
12:03:40 <Olathe> Lies.
12:05:17 <Saizan_> 7/win 13
12:20:21 <udoprog> how would i define a function that only takes arguments that are instances of a specific class, like Ord?
12:20:55 <trofi> :t sort
12:20:57 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:21:27 <bjrn> You can ignore the "forall a." stuff tho, that's advanced haskell. :)
12:21:34 <bjrn> ignore for now that is
12:21:51 <udoprog> k, thanks
12:21:56 <Olathe> > let f :: (Ord a) => a -> a -> Bool; f a b = a < b in f 5 6
12:21:59 <lambdabot>   True
12:22:08 <Olathe> udoprog: Like that.
12:22:32 <trofi> :t (/)
12:22:32 <Olathe> It says that a can be whatever, as long as its Ord.
12:22:34 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:22:43 <Olathe> it's
12:27:56 <udoprog> So, how would i handle multiple arguments?
12:28:44 <tromp> :t (+)
12:28:45 <lambdabot> forall a. (Num a) => a -> a -> a
12:29:01 <FunctorSalad> Olathe's example already was multi-argument, or do you mean sth else?
12:29:21 <Vulpyne> forall a b. (Num a, Eq b) => a -> b -> a
12:29:26 <Vulpyne> Is that what you were wondering about?
12:29:50 <udoprog> i think so, just started with haskell today
12:30:05 <FunctorSalad> welcome :)
12:30:11 <bjrn> Then defenitely ignore the "forall ." stuff :)
12:30:37 <FunctorSalad> especially since it actually means "exists ." sometimes (j/k)
12:31:37 <udoprog> i have the equation 'merge a b' where a and b has to be lists containing elements which are instances of Ord, but i can't figure out the type defination
12:32:16 <Vulpyne> somefunc :: (Ord a, Ord b) => [a] -> [b] -> [a]
12:32:19 <stepcut> udoprog: do you mean like, merge :: (Ord a) => [a] -> [a] -> [a] ?
12:32:54 <stepcut> Vulpyne: you wouldn't be able to do much with the 'b' in that function
12:33:06 <FunctorSalad> I think you want stepcut's one since Ord only lets you compare elements of the same type
12:33:09 <Vulpyne> It was just an example. :)
12:33:28 <Vulpyne> For merging, yeah, you'd be right though.
12:33:34 <FunctorSalad> if you really want to compare elements of different types, you'd make a class "BiOrd" or something that has two type parameters
12:34:18 <stepcut> yeah, I think the function with that type would have to look mostly like, merge a b = (someFunction :: [a] -> [a]) a,
12:34:55 <stepcut> though, I guess you could do something like, merge a b = if  isNull b then f1 a else f2 a
12:35:40 <bjrn> Dear Diary. Today I learned about unsafePerformIO. I have now died a little bit inside.
12:35:57 <Olathe> It's unsafe to die inside.
12:36:03 <Olathe> You shouldn't do it, unless necessary.
12:36:09 <Vulpyne> unsafeDieInside
12:36:31 <stepcut> bjrn: but did you learn about, let (☣☠☣) = unsafePerformIO
12:36:46 <FunctorSalad> better use the temporary "withDeadInside"
12:37:14 <Olathe> let (ｕｎｓａｆｅＰｅｒｆｏｒｍＩＯ) = unsafePerformIO
12:37:14 <Botje> @remember FunctorSalad better use the temporary "withDeadInside"
12:37:15 <lambdabot> I will remember.
12:37:25 <FunctorSalad> :o
12:37:26 <udoprog> here: http://hpaste.org/10099
12:37:40 <stepcut> Olathe: hah
12:37:42 <udoprog> i get Occurs check: cannot construct the infinite type: a = [a]
12:38:04 <Botje> yes.
12:38:06 <udoprog> and i see two errors
12:38:17 <Botje> what's the type of (a:ar) ?
12:38:32 <udoprog> ah, solved it : P
12:39:58 <Olathe> Botje: A list.
12:40:18 <Botje> correct!
12:40:22 * Botje sticks a gold star on Olathe 
12:40:24 <Olathe> :t (:)
12:40:26 <Olathe> Yay !
12:40:26 <lambdabot> forall a. a -> [a] -> [a]
12:40:51 <udoprog> yeah, bu the a element has to be put in a list aswell '[a]' to be used with ++
12:47:19 <Xenoblitz> hi guys
12:47:35 <Xenoblitz> newbie here
12:47:46 <Xenoblitz> anyone?
12:47:53 <Botje> sure
12:47:54 <Olathe> Points to the "No newbies allowed" sign on the treehouse.
12:47:58 <Botje> what's the problem?
12:48:17 <Xenoblitz> Olathe: is there a newbies channel for haskell?
12:48:24 <Botje> yes, this is it. :)
12:48:28 <Olathe> Yes, this one ;)
12:48:28 <Saizan_> Xenoblitz: he's joking :)
12:48:38 <Xenoblitz> lol
12:48:45 <Xenoblitz> hi again Saizan_
12:48:46 <Botje> how can we answer your questions in Lambda Surround Sound today?
12:48:47 <ziman> is something like @src available in ghci? i can't see anything similar in :help
12:48:50 <Saizan_> hi
12:49:03 <Xenoblitz> well today my problem is related to... guess what... Monads!
12:49:04 <Xenoblitz> lol
12:49:17 <vininim_class> I found a ghc bug by being a noob. =P
12:49:25 <Saizan_> ziman: no, but there's GOA to integrate a local lambdabot in your ghci
12:49:28 <FunctorSalad> ziman:  :info is not the same but sometimes it suffices
12:49:28 <olsner> warm fuzzy things giving you trouble, eh?
12:49:37 <Xenoblitz> I wanted to ask...
12:49:40 <agcorona> chrome is available now!  http://www.google.com/chrome
12:49:41 <lambdabot> Title: Google Chrome - Download a new browser
12:49:46 <FunctorSalad> :bro can be good too
12:49:55 <Xenoblitz> say i have a function of type State Game ()
12:50:00 <EvilTerran> :bro don't taze me
12:50:13 <FunctorSalad> ziman: I think you can also run teh bot in ghci somehow
12:50:18 <Xenoblitz> and another one of type State Well ()
12:50:24 <Xenoblitz> Now Well is a part of Game
12:50:41 <Xenoblitz> is it possible to call the 2nd function from the 1st monadically?
12:50:54 <Botje> no.
12:50:58 <Botje> different monad, you see :)
12:51:02 <Xenoblitz> ic
12:51:03 <Saizan_> well
12:51:04 <Xenoblitz> hmmm
12:51:04 <Saizan_> yes
12:51:07 <FunctorSalad> @hoogle State a1 b -> State a2 b
12:51:08 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
12:51:08 <lambdabot> Control.Monad.State.Strict withState :: (s -> s) -> State s a -> State s a
12:51:08 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
12:51:12 <Botje> you'll need to do runState
12:51:13 <Saizan_> if you use a conversion function
12:51:16 <EvilTerran> you can write something State Well a -> State Game a
12:51:28 <ziman> Saizan_, FunctorSalad thank you
12:51:28 <EvilTerran> but you'd need a conversion function using runState, yeah
12:51:28 <FunctorSalad> usually there is some convenience function for mapping the state argument
12:51:45 <Saizan_> ?hoogle mapState ?
12:51:46 <lambdabot> Parse error:
12:51:46 <lambdabot>   --count=20 "mapState ?"
12:51:46 <lambdabot>                        ^
12:51:51 <Saizan_> ?hoogle mapState
12:51:51 <lambdabot> Control.Monad.State.Lazy mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
12:51:52 <lambdabot> Control.Monad.State.Strict mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
12:51:52 <lambdabot> Control.Monad.State.Lazy mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
12:52:12 <FunctorSalad> hmm not quite
12:52:31 <Saizan_> no
12:52:45 <Xenoblitz> hmmm
12:53:14 <Saizan_> Xenoblitz: you can write the conversion using runState and the State constructor
12:53:37 <Saizan_> ?type runState
12:53:38 <Xenoblitz> so literally... upgrade Well to Game for a limited time?
12:53:38 <FunctorSalad> is there some way to filter out these trivial hoogle results where my a1 and a2 are the same?
12:53:39 <lambdabot> forall s a. State s a -> s -> (a, s)
12:54:07 <Saizan_> Xenoblitz: more or less
12:54:10 <FunctorSalad> wait, wouldn't changing the state type require a converter both ways?
12:54:15 <EvilTerran> yeah
12:54:28 <Saizan_> FunctorSalad: yeah, you need a getter and a setter
12:54:30 <EvilTerran> something to extract a Well from a Game, and something to put the new Well back in
12:54:51 <EvilTerran> a functional reference :D
12:54:52 <Xenoblitz> EvilTerran: that's actually what i really need
12:55:00 <Xenoblitz> update Well
12:55:03 <Xenoblitz> then update Game
12:55:08 <Xenoblitz> with the same Well
12:55:32 <Saizan_> runState (foo :: State Well ()) :: Well -> ((),Well) <-- so if you can convert that to Game -> ((),Game) then you can apply the State constructor to get a State Game ()
12:57:10 <Saizan_> how to go from Well -> ((),Well) to Game -> ((),Game) depends only on the definition of Game, here
12:58:21 <Xenoblitz> hmmm i might be trying to do things which are too advanced for me
12:59:13 <Xenoblitz> for example I don't get the definition of runState you gave above... what i mean is... I don't understand it as yet
12:59:37 <Saizan_> ?src State
12:59:37 <lambdabot> Source not found. My mind is going. I can feel it.
12:59:57 <Xenoblitz> last time i saw :: was with Reader Monad I think... to convert input... :)
13:00:18 <Saizan_> x :: t, just means that the expression x has type t
13:00:42 <Saizan_> runState is defined in Control.Monad.State
13:00:59 <Saizan_> do you know about record syntax?
13:00:59 <Xenoblitz> so you are converting State Well () to Well -> ((),Well) or being equivalent of each other?
13:01:45 <dmhouse> ?djinn (a -> b) -> (Not b -> Not a)
13:01:46 <lambdabot> f a b c = b (a c)
13:01:55 <Saizan_> newtype State s a = State (s -> (a,s))
13:02:10 <dmhouse> ?djinn (Not b -> Not a) -> (a -> b)
13:02:11 <lambdabot> -- f cannot be realized.
13:02:13 <Xenoblitz> runState :: (s -> (a,s))
13:02:18 <Xenoblitz> just looked it up
13:02:27 <Saizan_> so the two are equivalent, because a value of type State, is just a wrapper around the function
13:02:28 <Botje> uh
13:02:33 <Botje> there's more to it than that :)
13:02:37 <Saizan_> runState (State f) = f
13:03:43 <Xenoblitz> ok it returns the function itself
13:03:50 <Xenoblitz> which is (s -> (a,s)
13:03:57 <Saizan_> in the source it's defined like newtype State s a = State {runState :: s -> (a,s)}, that's the record syntax equivalent of what i've defined
13:03:58 <Xenoblitz> * (s -> (a,s))
13:04:04 <Saizan_> yes
13:04:16 <Xenoblitz> so
13:04:19 <Xenoblitz> i need a function
13:04:38 <Xenoblitz> to convert ... State Well () to Well -> ((), Well)
13:04:54 <Xenoblitz> ...
13:04:57 <Xenoblitz> er am i on the right track
13:04:58 <Saizan_> that's runState
13:05:03 <Xenoblitz> ok good
13:06:19 <Saizan_> do you realize why a value of type State contains a function like that?
13:06:39 <Botje> Xenoblitz: well2game f = do { game <- get; let well = extractWell game; let newWell = runState f well; let newGame = updateWell game well; put newGame }
13:07:02 <Botje> assuming you have a function extractWell (of type Game -> Well) and updateWell (of type Game -> Well -> Game)
13:07:16 <Saizan_> Botje: forgot a tuple
13:07:38 <Xenoblitz> Saizan_: i know its cause of the before and after states + output thingy :)
13:07:38 <Botje> hmm?
13:08:00 <Saizan_> let (value,newWell) =..
13:08:09 <Botje> oh, right
13:08:10 <Botje> heh
13:08:18 <Botje> i always use execState or evalState :)
13:08:27 * Botje throws a candy lambda to Saizan_ 
13:08:34 <Saizan_> Xenoblitz: right :)
13:08:53 <Xenoblitz> its just weird working around with functions hehe
13:08:58 <Xenoblitz> i can't get used to it... yet
13:09:33 <Saizan_> ah, if you're not used to passing them around as values it can take a while
13:09:38 <Xenoblitz> Botje: thanks for the code... i'll write it line by line and try to understand it better
13:10:09 <Xenoblitz> its more how you have to think things on slightly a higher level than before
13:10:17 <Xenoblitz> i mean it makes sense in my mind
13:10:22 <Xenoblitz> but coding it is another story
13:11:23 <Botje> Xenoblitz: give it time :)
13:11:41 <Botje> you won't notice it
13:11:42 <Xenoblitz> hehe... this is an experiment prototype i am writing...
13:11:43 <Xenoblitz> :P
13:11:50 <elliottt> sclv: i've been playing around with the stringtemplate 0.4 release.  i like the changes you've made regarding the ToSElem class :)
13:11:54 <Botje> but sooner or later you'll say "damn, this is so much easier in haskell" when you're writing in an inferior language
13:12:08 <Xenoblitz> Trying ernestly to write a language to describe... guess which game...
13:12:09 <Xenoblitz> lol
13:12:30 <bjrn> Hehe, I will go for Tetris ;)
13:12:44 <Xenoblitz> yepp lol
13:12:45 <bjrn> Or Game of Life
13:12:50 <Xenoblitz> no its tetris
13:12:51 <Xenoblitz> lol
13:12:58 <bjrn> That's right - tetris.
13:14:06 <Xenoblitz> ok so guys... let me experiment a bit... i'll let you know soon enough if i managed hehe
13:14:09 <Xenoblitz> thanks all for the help
13:14:18 * BMeph is always reminded of the high number of colleges from SW Asia he works with, whenever he sees a blog post from "Paul Potts"...
13:17:19 * EvilTerran tried to write tetris once, but then discovered masses of stealth complexity involving rotation, particularly when other blocks and walls are nearby
13:18:16 <Xenoblitz> EvilTerran: oops... yeah i thought that would be the problem
13:18:34 <EvilTerran> @go tetris wiki
13:18:36 <lambdabot> http://en.wikipedia.org/wiki/Tetris
13:18:37 <lambdabot> Title: Tetris - Wikipedia, the free encyclopedia
13:18:39 <EvilTerran> bah
13:18:46 <Xenoblitz> i will go for left/right/down/up for now
13:18:56 <Xenoblitz> rotation is the next major step
13:19:05 <EvilTerran> http://www.tetrisconcept.com/wiki
13:19:05 <BMeph> Off for home - see you gouys later...
13:19:15 <lambdabot> Title: Main Page - wiki
13:19:23 <EvilTerran> ^ that describes the quirks of rotation in various tetris games
13:19:31 <EvilTerran> in excruciatingly obsessive detail
13:21:24 <Xenoblitz> EvilTerran: thanks for this page... good stuff i will surely need later on!
13:21:43 <EvilTerran> no worries :)
13:22:02 <EvilTerran> as i said, it kinda overwhelmed me with information to the point of abandoning the project for something with easier semantics :P
13:24:08 <Xenoblitz> i will probably just use my own system... this is just a prototype for something i won't be actually using ... just to show my tutor i am practising for the work ahead ;)
13:24:22 <Xenoblitz> thanks though... this might put things into focus
13:25:08 <EvilTerran> it'll give you an idea of the design space, at least :)
13:25:20 <bjrn> I'm time-profiling a program that calls a C function with FFI. The profiler tells me the function calling the c-code is taking plenty of time. Is this time for the whole function including the C-code, or just the haskell wrapper?
13:27:04 <tibbe> are there any new, interesting papers? I need something to read in the gym
13:27:24 <therp> tibbe: check ltu?
13:27:45 <dons> check the ICFP program
13:27:48 <dons> and the HW program
13:28:28 * EvilTerran recently enjoyed the "arrow calculus" paper from http://homepages.inf.ed.ac.uk/wadler/topics/links.html
13:28:34 <lambdabot> Title: Wadler: Links
13:28:34 <EvilTerran> but it's a short one
13:31:08 <udoprog> im using ghc, and when i try to use isAlpha from the Char module i get undefined reference from the linker, might i be doing something wrong?
13:32:05 <stepcut> udoprog: are you using ghc --make to build your program?
13:32:27 * EvilTerran gets beaten to the punch 'cos he had to look up whether it was -make or --make
13:32:35 <stepcut> EvilTerran: :p
13:33:04 <udoprog> no, i'm building the object files first, then running them through ghc, i thought it would add all necessary libraries
13:33:16 * stepcut notes that the correct answer is to do, runhaskell Setup configure && runhaskell Setup build ;)
13:33:19 <udoprog> objects build with ghc -c ...
13:33:20 <EvilTerran> #haskell - where your questions are answered in glorious stereo, except one of the headphone wires has been wiggled too much and is a bit dodgey
13:33:43 <udoprog> and then assembling, linking with ghc first.o ... -o binary
13:34:20 <Xenoblitz> i am not sure about this... but i think i had a similar problem to this once... cause the books said that isAlpha is in prelude... but its not anymore... I am not 100% sure... some one more expert?
13:34:21 <EvilTerran> udoprog, ghc does its own dependency chasing if you just ask it to compile the main module with --make
13:34:49 <SamB> Xenoblitz: it's in Data.Char
13:34:50 <stepcut> udoprog: most people just use, ghc --make Main.hs -o prog, unless they have a specific reason not to. It does everything automatically...
13:35:12 <Xenoblitz> so he can just import Data.Char right?
13:35:13 <stepcut> udoprog: to do it by hand you probably need a -package <whereever isAlpha lives>
13:35:15 <Xenoblitz> and it would be ok
13:35:27 <EvilTerran> Xenoblitz, that's a different problem
13:35:31 <Xenoblitz> oh ok then
13:35:32 <Saizan_> udoprog: you've to pass -package foo then, -package haskell98 in this case ,iirc
13:35:36 <Xenoblitz> nvm my lack of knowledge :P
13:35:40 <EvilTerran> Xenoblitz, it's not a "name not in scope", which is the problem you're thinking of
13:35:47 <EvilTerran> it's a "symbol not found", which is a linking error
13:35:55 <Xenoblitz> OH /slap Xenoblitz
13:35:58 <Xenoblitz> man i got loads to learn lol
13:36:04 <EvilTerran> names, symbols, errors, oh my!
13:36:56 <udoprog> k, ill be using --make then, but any ideas where the haskell libraries usually are?
13:37:43 <EvilTerran> dunno ... i've never had the need to think about it
13:38:02 <EvilTerran> the ghc manual might say
13:38:43 <Jedai> udoprog: in lib, under the prefix where ghc was installed
13:39:02 <Jedai> udoprog: so it depends on your distribution of course
13:39:23 <Jedai> udoprog: But just use --make, it does its job very well
13:39:59 <udoprog> Jedai: yep, under /usr/lib/ghc-6.8.2/hslibs-imports/
13:40:07 <udoprog> or depending on version
14:15:34 <grahamhutton> @users
14:15:34 <lambdabot> Maximum users seen in #haskell: 497, currently: 493 (99.2%), active: 12 (2.4%)
14:15:55 <grahamhutton> nearly 500!
14:20:09 <Saizan_> my client says 491, however still nearly 500 :)
14:20:23 <dmhouse> grahamhutton: we've had 500
14:20:32 <dmhouse> grahamhutton: lambdabot randomly forgets state
14:20:40 <Heffalump> more bodies needed!
14:20:59 <grahamhutton> dmhouse: oh dear!
14:21:27 <Heffalump> grahamhutton: btw, how are you expecting people to get hotels at ICFP '09?
14:21:59 <grahamhutton> the local organisers have block booked a range of hotels, so this shouldn't be a problem.
14:22:30 <grahamhutton> there will be a web page about ICFP 09 accommodation put up nearer the time.
14:22:30 <Heffalump> ah, cool
14:23:01 <FliPPehhh> I now read a whole article about the "data" type, but I still don't know how to access a single data field
14:23:09 <grahamhutton> hosting ICFP 09 during the last week of the Edinburgh Festival is supposed to be a bonus for participants!
14:23:13 <FliPPehhh> Like in C I'd do myStruct.x
14:23:58 <Heffalump> so you expect them to skip sessions to visit the Fringe? :-)
14:23:59 <EvilTerran> FliPPehhh, have you encountered the record syntax?
14:24:14 <FliPPehhh> I doubt
14:24:16 <grahamhutton> link: http://www.cs.nott.ac.uk/~gmh/icfp09.html
14:24:22 <lambdabot> Title: ICFP 2009: The 14th ACM SIGPLAN International Conference on Functional Programmi ...
14:24:45 <grahamhutton> surely the ICFP talks will be entertainment enough :-)
14:29:27 <quicksilver> udoprog: use ghc --make.
14:29:33 <Igloo> I wonder what effect ICFP being a month earlier will have on GHC's release cycle  :-)
14:29:33 <quicksilver> udoprog: damn, sorry.
14:29:35 <quicksilver> was scrolled up :)
14:30:28 <FliPPehhh> Hm
14:30:42 <udoprog> quicksilver: np, thanks for the attention
14:30:43 <FliPPehhh> I have to use pattern matching functions in order to get a specific field from a data?
14:30:57 <FliPPehhh> So for a data of 5 fields, I need 5 functions?
14:31:02 <TomMD> Igloo: Careful, that is a double edged sword.  GHC might be released a month early, but if it isn't ready it will have to wait another year!
14:31:10 <sjanssen> FliPPehhh: you can use records instead
14:31:19 <FliPPehhh> If only I knew what they are :)
14:31:30 <sjanssen> data Foo = Foo { blah :: Int } -- automatically defines a function 'blah' to extract that field
14:31:33 <mmorrow> data F a = F { x :: Int, f :: (Int -> a) }
14:32:08 <mmorrow> let a = F 42 show :: F String in (f a) (x a)
14:32:14 <mmorrow> "42"
14:32:27 <TomMD> Hummm.  We have a new Haskell interpreter.
14:32:31 <mmorrow> heh
14:33:14 <Heffalump> ah, but does mmorrow support <- ?
14:33:36 <mmorrow> hehe
14:34:08 <Heffalump> (think carefully before you answer; if you do, I'll be forced to shoot you)
14:34:19 <mmorrow> heh, i was just about to
14:36:09 <mmorrow> i don't if there isn't really anything that can't be done with other means (and <- is only a convenience). but john meacham's msgs are convincing in that they seem to say that it /does/ bring some capability that doesn't currently exist (or at least makes it safe?)
14:36:27 <Heffalump> the other means are an API change
14:36:50 <Heffalump> It's certainly the case that you can't have "global" state as defined in that thread any other way.
14:37:03 <Heffalump> or rather, with existing non-unsafe mechanisms
14:38:29 <mmorrow> hmm. yeah, i'm torn because it seems like such a large hammer to kill a fly, but that's better than not having anything (including a flyswatter) to kill said flies
14:38:50 <Heffalump> I don't like flies, but I question whether they should be killed at all.
14:39:16 <Heffalump> And certainly it shouldn't be claimed as a method for killing cockroaches too.
14:39:25 <udoprog> i need some debugging tips, is there any way to break/step/analyse in a gdb type of way with haskell?
14:39:38 <dmhouse> udoprog: GHCi has a debugger
14:39:43 <dmhouse> Not sure how mature it is.
14:39:47 * sjanssen has apparently stepped into #pest-control
14:40:03 <Saizan_> ?google ghc manual ghci debugger
14:40:06 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
14:40:06 <lambdabot> Title: 3.5.�The GHCi Debugger
14:41:42 <udoprog> looks mature enough, thanks
14:42:26 <mmorrow> Heffalump: that's true. summarizing my feelings...i'm all for extending the areas in which haskell is applicable, and am all for having a safe mechanism to do "unsafe" things, but i'd rather that not be with a huge thing such as a top-level <-. /but/, if there aren't any solutions by different means given/implemented and the choice is <- or nothing, then i'm for <-.
14:43:01 <Heffalump> if you don't want to change APIs, something is needed
14:43:07 <Heffalump> I claim people should change their APIs instead.
14:43:08 <mmorrow> also, i noticed the other day that jhc already has a top-level <-.
14:43:27 <mmorrow> Heffalump: by API, you mean the compiler-presented API?
14:43:37 <mmorrow> or how people go about implem their own libs?
14:43:40 <Heffalump> I mean the APIs of libraries where the need for <- is claimed.
14:44:18 <Heffalump> You can always replace the <- with an implicit parameter and a withFoo function, for example.
14:45:15 <mmorrow> yes! i just saw sclv using an implicit MVar, and he said you suggested it.
14:45:37 <mmorrow> i'd never thought of having a mutable var as an implicit param, and that seems very useful to me
14:45:40 <Heffalump> it's an obvious idea, I doubt I was the first, or even the tenth :-)
14:46:03 <Heffalump> a lot of people don't like implicit parameters, and personally I've never used them, though I keep meaning to.
14:46:15 <Heffalump> So I'm not sure that I support them. But they're way better than <-
14:46:26 <mmorrow> either way, it changes the way i see implicit params (i only really read about them since the <- and floatingpoint discussions happened)
14:46:53 <winter> hi
14:47:00 <mmorrow> Heffalump: " though I keep meaning to."    this is exactly my situation as well
14:47:08 <winter> Has anyone tried creating a Haskell to C++ translator?
14:47:26 <Heffalump> my best use case for them right now is actually work code, but I'm reluctant to use that as a guinea pig :-)
14:48:26 <mmorrow> Heffalump: heh, me too.
14:48:32 <TomMD> winter: GHC used to compile to c.
14:48:45 <TomMD> So if you have a C++ compiler... well...
14:48:52 <ddarius> GHC still can compile to C
14:49:09 <TomMD> Yes, but its not default any more.  Suppose I should have been more specific.
14:50:36 <winter> thanks, I was wondering about this after reading the "C++ templates/traits versus Haskell type classes" paper
14:51:22 <TomMD> winter: I see.  There is no program that will translate code at that high a level, afaik.
14:53:52 <winter> Thanks TomMD, do you think there'd be any benefit at all to such a translator?  Maybe the C++ code would be briefer and the compiler could better optimize the generated code?
14:54:27 <Olathe> There would probably be a benefit, but not enough to get someone to make one yet.
14:54:52 <Olathe> I've been thinking about making things like that, but I've had lack of motivation.
14:55:01 <Olathe> Not Haskell to C++ specifically.
14:55:35 <winter> I can empathize with you... so much to try out and learn, but so little time (and money)
14:55:51 <winter> Maybe Haskell to LLVM would be good enough
14:56:00 <TomMD> winter: Sounds like Olathe has given it more thought.  My take is that it wouldn't be worth the work by a long shot.  Any optimizations that are possible would probably be able to be expressed as a translation on the haskell source.
14:56:59 <TomMD> LLVM - now that would be a great accomplishment.  Especially if future LLVM targets, such as CellBE, are available.
14:57:50 <winter> TomMD: good point!  And GPGPUs, Intel's Larrabee, etc too
14:57:55 <tp|class> LLVM is mentioned so much, but non-strict semantics would make it a second class citizen, easily.
14:58:13 <tp|class> LLVM is certainly very very attractive though - very good API, well thought out, powerful and supported
14:58:34 <TomMD> tp|class: Who are you?  I saw you talking the other day and thought perhaps you are published?
14:59:01 <tp|class> i'm 'thoughtpolice' - 'thoughtpolice|class' exceeds max nick limit :p
14:59:07 <TomMD> Ahhh, ok!
14:59:33 <tp|class> one thing I actually want to do though is do some benchmarks, compile with -fvia-C but pass the results to, say, llvm-gcc
14:59:46 <tp|class> or clang; people tell me for C development it's viable these days
15:00:25 <TomMD> tp|class Good idea.  I recently switched from -fvia-c to the native codegen due to bugs but was happy to see zero performance impact (this if for pureMD5)
15:00:53 <tp|class> TomMD: are you using 6.6 or 6.8 and just always used -fvia-C?
15:01:11 <TomMD> winter: If you are interested in Larrabee and other processing you might like the look of Tilera or (separatly) the SunSPARC + Haskell effort.
15:01:17 <tp|class> (-fasm is default in 6.8)
15:01:55 <TomMD> tp|class: I used -fvia-C with 6.8.2 and then (due to OS X user complaints) dropped the -fvia-C with good results.
15:02:11 <tp|class> TomMD: in general I've found the -fvia-C and -fasm performance to not be too different, one way or the other. -fasm is default now just because the code gen got better in 6.8 and could really stack up
15:02:16 <winter> I hadn't heard of Tilera until now
15:02:24 <TomMD> tp|class So is class PSU?
15:02:30 <TomMD> winter: Its still small, but impressive.
15:02:31 <tp|class> with the new codegen packed full of goodness and awesome, things should be interesting in the performance department :]
15:02:48 <tp|class> although at this point I'm not even sure if the codegen patches will get merged
15:03:02 <tp|class> in time for the RC, at least
15:03:35 <tp|class> TomMD: I'm actually about to go to class but am currently diddling around on emails and somesuch
15:03:53 <TomMD> that would be ashame.  I've been looking forward to that.  Perhaps I should pull down head and run benchmarks on that?  Or is it not merged into head even?  (don't follow GHC quite close enough to know if they forked 6.10 separate from head yet)
15:04:09 <tp|class> TomMD: it's not merged into head yet
15:04:20 <tp|class> i can tell because the patch postings haven't hit cvs-ghc
15:04:28 <tp|class> and j. dias talked about it a week or so ago
15:04:35 <tp|class> he wanted to push them but he's stomping bugs right now I think
15:04:39 <TomMD> tp|class: I asked about PSU because I intend to go study under Tolmach.  Are you working on a PhD there?
15:04:55 <tp|class> TomMD: i just started my first undergrad year :]
15:05:10 <tp|class> been a uni. student for, uh, little over a week now?
15:05:19 <newsham> hi
15:05:25 <bjrn> when using ghc --make can i tell ghc to write all new files to a build directory?
15:05:37 <TomMD> tp|class: Ahhh.  Hummm.  I must have you confused with someone.  Still - I got the uni right?
15:05:40 <bjrn> and not the same dir as the source files
15:05:48 <tp|class> TomMD: i'm in texas :]
15:05:48 <newsham> bjrn: why not use a cabal file?
15:05:52 <TomMD> damn.
15:05:57 <newsham> (dont know the ansewr to your question)
15:06:03 <Heffalump> bjrn: -odir foo -hidir foo
15:06:03 <tp|class> TomMD: re: head perf., it's worth checking out for sure
15:06:14 <bjrn> Heffalump ah cheers.
15:06:20 <tp|class> the really annoying package.conf bugs have been fixed so like, ghc-pkg actually *works* in the head now
15:06:21 <TomMD> I'll look into it.
15:06:23 <tp|class> so you can register packages
15:06:28 <bjrn> newsham: That probably works too :)
15:06:54 <tp|class> TomMD: but for the new codegen patches, I guess it all comes down to the next week or so
15:07:52 <tp|class> anyway,
15:07:56 * tp|class *poofs*
15:10:53 <fnordb> http://haskell.pastebin.com/m1f6cdf12 <-- here I am trying to make a data type have a list of anytype that satisfies the ClassType interface.
15:11:26 <fnordb> However, I'm given a kind error saying http://haskell.pastebin.com/m1f6cdf12
15:13:01 <Saizan_> if you've a monadtransformer that needs to return some kind of intermediate result even if there's an error in the underlying monad, which interface would you require from that monad?
15:14:30 <fnordb> Is my text showing up?
15:14:39 <Corun> NO
15:14:41 <Saizan_> #
15:14:54 <fnordb> oh it appears now. anyway. http://haskell.pastebin.com/m1f6cdf12
15:15:04 <fnordb> apparently when I copy and paste, it doesn't appear
15:15:17 <Saizan_> fnordb: yes, it appears
15:15:35 <Saizan_> fnordb: however you can't use a typeclass as a type like that
15:15:58 <fnordb> oh it doesn't appear for me. stupid ajax, stupid work internet preventing me from using a proper irc client, stupid me for not having internet at home.
15:16:03 <Saizan_> fnordb: have you read anything on existential types?
15:16:14 <bjrn> Can Cabal build C-code? A small part of my library uses C
15:16:25 <dcoutts_> bjrn: yep: c-sources: foo.c
15:16:31 <bjrn> Ah, awesome :)
15:16:33 <fnordb> Saizan, my main book for learning haskell is Hudak. Aside from that, I code up examples like I have done here and try to figure out what's going on.
15:16:45 <dcoutts_> bjrn: and there's includes and include-dirs fields
15:16:53 <dcoutts_> bjrn: oh and cc-options
15:17:16 <bjrn> Nice, so Cabal solves both my problems. Should probably learn how to use it :)
15:17:34 <dcoutts_> bjrn: there is a user guide and there's lots of existing packages to look at
15:17:39 <earthy> Distribution.Simple is quite complex :)
15:17:56 <Stinger_> you dont have the internet at home? how do you survive? :P
15:18:02 <fnordb> Saizan, if I can dispatch on something like 'a', why can't I dispatch on 'a, where a implements a specific typeclass'? Or is my syntax just broken
15:18:04 <earthy> (oh, I always copy and paste from cabal files I've written)
15:18:08 <TomMD> fnordb: You should see the Haskell wikibook entry for existential types, its great.
15:18:12 <earthy> Stinger: by not being distracted
15:18:16 <fnordb> Stinger_: if I had internet at home I would never sleep. :)
15:18:25 <dcoutts_> earthy: as SyntaxNinja says, it's not the Simple build system because it's simple, it's because it does complex things to simple packages :-)
15:18:43 <SyntaxNinja> :)
15:18:44 <Saizan_> fnordb: ok, well, by  "list of anytype that satisfies the ClassType interface" you mean one where all the elements are of the same type or not?
15:18:56 <earthy> duncan: yeah :)
15:19:10 <earthy> and the packages needn't even be really simple
15:19:10 <dcoutts_> earthy: yes, one does see a lot of that which is why we added lots of QA warnings to tell people what not to do :-)
15:19:16 <earthy> just 'simple enough'
15:19:32 <TomMD> fnordb: data Box = forall a. TypeClass a => Bx [a]
15:19:35 <Olathe> > interact id
15:19:35 <fnordb> Saizan, well no. But if I had data Blah = BlahInt a | BlahDouble b | etc it would work
15:19:38 <lambdabot>   mueval: Prelude.read: no parse
15:19:38 <lambdabot>  mueval: *** Exception: "<IO ()>"
15:19:56 <Olathe> No parse...plus an exception
15:20:06 <TomMD> fnordb, scratch that last: data Box = forall a. TypeClass a => Bx a
15:20:06 <TomMD> list :: [Box]
15:20:07 <Saizan_> TomMD: that still requires all the elements to be of the same type
15:20:07 <earthy> yah, but warning that you haven't got a license file when you're still in the development stage...
15:20:20 <earthy> and haven't decided on a license at all
15:20:27 <TomMD> Saizan_: Typing race condition - fixed above.
15:20:31 <earthy> (or even when you're just idly hacking for your own purposes...)
15:20:35 <Saizan_> TomMD: right :)
15:20:44 <dcoutts_> earthy: ah yes, that's excessive, we should make sure that's only a distribution warning
15:20:47 <Olathe> @src interact
15:20:48 <lambdabot> interact f = do s <- getContents; putStr (f s)
15:21:01 <Olathe> @src getContents
15:21:02 <lambdabot> getContents = hGetContents stdin
15:21:08 <Saizan_> fnordb: if you're just learning the language i'd suggest you to stay away form exstentions like these :)
15:21:57 <earthy> (that's actually the only annoying one in the cabal on my system ;))
15:21:59 <fnordb> do I need an import or glasgow-exts to make that work?
15:22:11 <Saizan_> the latter
15:22:14 <dcoutts_> earthy: I think that might be fixed already, what cabal version are you using ?
15:22:32 <TomMD> fnordb: -XExistentialQuantification
15:22:42 <earthy> Cabal-1.2.4.0
15:22:47 <earthy> according to my ghc-pkg
15:23:21 <dcoutts_> earthy: yeah, I think we've improved that, judging by the current code. It looks like it'll only warn when you do cabal sdist or cabal check
15:23:26 <fnordb> So is there a common strategy for dealing with this type of thing? i.e. I would like a container of items that satisfy the interface. would I just make data X = X1 a :: Int | X2 b :: Double etc ?
15:23:41 <earthy> (I've been doing too much VB and MS SQL Server lately)
15:24:05 <dcoutts_> earthy: the principle is, we warn at configure time if it's something that's likely to break when you use it, and we warn at sdist time if it's likely to break when someone else uses it.
15:24:19 <Saizan_> fnordb: the syntax is data X = X1 Int | X2 Double
15:25:30 <earthy> sounds like a good set of heuristics
15:25:41 <fnordb> Saizan, yes. Sorry. But is that the general way of constructing this type? It makes sense in a statically typed language, since we obviously don't have dynamic dispatch.
15:26:14 <TomMD> fnordb: most the time a data declaration (such as Either) will do.  I suggest you use existential quantification infrequently.  There is evidently a Dependently typed like module, but I'm not clear on how it works - look it up if you want.
15:26:25 <TomMD> errr - dynamically typed.
15:28:20 <Saizan_> fnordb: yeah, that's the haskell98 way at least, note that with existentials there's no downcast-like feature
15:29:37 <fnordb> Saizan, TomMD, thanks.
15:29:41 <mmorrow> there is, but it's called unsafeCoerce :)
15:29:49 <mmorrow> (this is how Data.Dynamic does it)
15:30:10 <Saizan_> yeah, if you add a Typeable constraint
15:30:21 <ddarius> mmorrow: It doesn't need to do it that way, it's just simplest and most efficient that way.
15:30:25 <mmorrow> Saizan_: yeah, that does suck
15:31:22 <mmorrow> ddarius: hmm, i'm not sure the context right now because i just jumped in, but situations do exist there the only way to express something is with unsafeCoerce
15:31:35 <mmorrow> what that "something" is in this case, i'm not exactly sure
15:31:58 <Saizan_> i think he's referring to cast
15:32:33 <mmorrow> Saizan_: ddarius? casting from what to what?
15:32:54 <Saizan_> ?type cast
15:32:56 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
15:33:14 <mmorrow> oh, as in from Typeable, gotcha
15:33:27 <ddarius> mm_freak: I'm saying Data.Dynamic doesn't need to use unsafeCoerce
15:33:30 <ddarius> mmorrow:
15:33:49 <mmorrow> ddarius: i've heard various things to that extent. what's the alternate way?
15:33:49 <Heffalump> how else would it do it?
15:33:58 <mmorrow> yeah, i don't see how
15:34:00 <ddarius> @google Lightweight Generics and Dynamics
15:34:06 <lambdabot> http://citeseer.ist.psu.edu/692677.html
15:34:06 <lambdabot> Title: A lightweight implementation of generics and dynamics - CiteSeerX
15:34:33 <Saizan_> that uses a fixed universe?
15:35:00 <ddarius> Hell read/show is also another mechanism.
15:35:36 <dmhouse> ddarius: so you'd have class Cast a b where cast :: a -> b?
15:38:00 <kpreid> could anyone recommend a document on Haskell's type system for the smart-but-not-totally-mathy programmer, which talks about how if you have a value of type, e.g. [a] -> [a], you know it can't do anything with the 'a's but rearrange them?
15:38:07 <mmorrow> ddarius: that depends on the types' read/show instances though
15:38:44 <mmorrow> ddarius: so it's not "the general case", but a good point nonetheless
15:38:56 <Olathe> kpreid: You can transform them, too.
15:39:12 <Olathe> :t map (+1)
15:39:14 <lambdabot> forall a. (Num a) => [a] -> [a]
15:39:27 <earthy> Olathe: transform them how?
15:39:29 <kpreid> Olathe: Not without a Num class context; but yes, that's a refinement
15:39:30 <dmhouse> Olathe: that's not the type he gave
15:39:39 <dmhouse> Olathe: you can only apply functions of the type forall a. a -> a
15:39:45 <earthy> kpreid: the best description I've ever had was by Andres Löh
15:39:47 <Olathe> I see.
15:39:48 <dmhouse> ?type tail
15:39:50 <lambdabot> forall a. [a] -> [a]
15:39:55 <kpreid> earthy: URL?
15:40:00 <dmhouse> I wouldn't count that as "rearrangement".
15:40:08 <kpreid> dmhouse: I would :)
15:40:08 <Olathe> :t repeat . head
15:40:08 <earthy> it was in a talk that isn't archived online
15:40:10 <lambdabot> forall a. [a] -> [a]
15:40:14 <kpreid> or rather, it's what I meant
15:40:19 <Olathe> > (repeat . head) [1..]
15:40:19 <stepcut>    ls
15:40:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:40:24 <dmhouse> ?type const [] :: [a] -> [a]
15:40:26 <lambdabot> forall a. [a] -> [a]
15:40:46 <kpreid> I mentioned this property to someone who's interested in language-based security/safety and they want more info
15:41:24 <Olathe> @hoogle a -> a
15:41:25 <lambdabot> Prelude id :: a -> a
15:41:25 <lambdabot> Data.Function id :: a -> a
15:41:25 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
15:41:59 <dmhouse> The only functions forall a. a -> a are id, or undefined
15:42:52 <dmhouse> (Note that const undefined, and variants on that theme, is the same function as undefined, much as id id is the same function as id.)
15:43:42 <Olathe> :t cycle . tail
15:43:42 <ddarius> const undefined /= undefined
15:43:44 <lambdabot> forall a. [a] -> [a]
15:43:51 <Olathe> dmhouse: Ahh, OK.
15:43:53 <sjanssen> > const undefined `seq` ()
15:43:56 <lambdabot>   ()
15:43:59 <sjanssen> > undefined `seq` ()
15:44:02 <lambdabot>   mueval: Prelude.read: no parse
15:44:02 <lambdabot>  mueval: *** Exception: Prelude.undefined
15:44:09 <fnordb> Another question. At home I got a kind error. "expected kind '?' when given k -> *". I didn't know what kind '?' was. Maybe my xterm was playing tricks?
15:44:11 <kpreid> earthy: so, what was the second-best description? :)
15:44:32 <earthy> was just looking for it
15:44:44 <dmhouse> sjanssen: lalalalala I can't hear you and your seq-related blasphemy!
15:44:44 <sjanssen> fnordb: kind ? is either kind # or * (ie unboxed or regular)
15:45:11 <ddarius> kpreid: These behaviours are related to the free theorems, so you could look up those as well.
15:45:13 <fnordb> sjanssen: yes, but I always see it from ghc as * I never saw ? or #
15:45:18 <Saizan_> kpreid: the "theorems for free" of wadler are based on parametricity like that
15:45:37 <earthy> http://people.cs.uu.nl/andres/ST-05-2003.pdf are the slides of the talk I mentioned
15:45:41 <lambdabot> Title: Generic Programming in Haskell
15:46:30 <earthy> but the illustration was in terms of kinder chocolate surprise eggs
15:47:12 <earthy> if you have a parametrically polymorphic type, then that can be seen as a toy in an egg
15:47:21 <earthy> there's no way of playing with the toy...
15:47:43 <ddarius> Sounds more like an existential type
15:47:53 <earthy> ddarius: almost. :)
15:47:54 <FliPPehhh> Short question
15:47:57 <binrapt> Haskell must be awesome for webdev
15:48:00 <FliPPehhh> As Haskell does every looping using recursives
15:48:03 <sjanssen> fnordb: # is the kind of unboxed types (a GHC extension)
15:48:05 <earthy> they're closely related
15:48:15 <FliPPehhh> Isn't there a high probability of a stack overflow in normal programs?
15:48:19 <ddarius> FliPPehhh: No.
15:48:20 <earthy> nope
15:48:24 <afd8> tail recursion
15:48:26 <FliPPehhh> Nope?
15:48:29 <binrapt> FliPPehhh it's heavily optimised
15:48:32 <earthy> not just tail recursion
15:48:46 <FliPPehhh> I always had bad experiences with recursion in other languages :(
15:48:49 <ddarius> binrapt: It's not "heavily" optimized.  It's a rather small and simple "optimization."
15:48:54 <ddarius> FliPPehhh: Use better languages.
15:48:57 <FliPPehhh> Once a method crashed on me after 8 (!!) runs
15:49:17 <FliPPehhh> Well, using Haskell now
15:49:21 <earthy> much recursion is directly transformed away (which is an automatic process)
15:49:50 <earthy> plus, there's not really any concept of Stack in haskell code
15:49:55 <earthy> (or the runtime, IIRC)
15:50:11 <newsham> > foldl (+) 0 [1..100000]
15:50:14 <lambdabot>   5000050000
15:50:17 <newsham> > foldl (+) 0 [1..10000000]
15:50:25 <earthy> meaning that it's all heap-allocated and therefore can use mem until you run out of memory...
15:50:33 <lambdabot>   thread killed
15:50:41 <Olathe> Or your thread is killed.
15:50:45 <binrapt> lol
15:50:48 <FliPPehhh> Looks like there is
15:50:49 <FliPPehhh> "Stack space overflow: current size 8388608 bytes."
15:50:52 <earthy> plus, everything that is not used anymore can be garbage collected
15:51:06 <FliPPehhh> Got that after an infinite recurse
15:51:06 <earthy> flippehhh: yeah, true enough. but that's in the runtime
15:51:10 <newsham> > foldr (+) 0 [1..1000000]
15:51:12 <Saizan_> earthy: the graph-reduction still has a stack
15:51:15 <lambdabot>   mueval: Prelude.read: no parse
15:51:15 <lambdabot>  mueval: *** Exception: stack overflow
15:54:08 <newsham> ?src forever
15:54:09 <lambdabot> Source not found. Take a stress pill and think things over.
15:54:54 <Olathe> > ((`div`2).ap(*)(1+)) 1000000
15:54:57 <lambdabot>   500000500000
15:55:46 <chrisdone> forever a = a >> forever a
15:55:55 <Olathe> > @. pl say "\n -> n + 5"
15:55:57 <lambdabot>   mueval: Prelude.read: no parse
15:55:58 <Olathe> @. pl say "\n -> n + 5"
15:55:58 <ziman> FliPPehhh, when you run recursion in other languages, they just thoughtlessly put more and more stack frames onto the stack. In Haskell, recursion is just a way to describe things and those (recursively-defined) things will not get a recursive implementation (recursive as in C) from the compiler
15:55:58 <lambdabot> Plugin `compose' failed with: Unknown command: "say"
15:56:04 <Olathe> @. pl run say "\n -> n + 5"
15:56:07 <lambdabot> (line 1, column 4):
15:56:07 <lambdabot> unexpected "-"
15:56:07 <lambdabot> expecting space, "()", natural, identifier, lambda abstraction or expression
15:56:25 <Olathe> @run (+1) 5
15:56:29 <lambdabot>   6
15:56:33 <FliPPehhh> Hmm okay
15:56:35 <ziman> s/will not/may not/, i suppose
15:57:04 <kpreid> is it correct to call [a] -> [a] a parametric type?
15:57:06 <Olathe> @. pl run say "\\n -> n + 1"
15:57:09 <lambdabot> (1 +)
15:57:31 <kpreid> hm, I think no, it's a 'polymorphic type'
15:58:08 <FliPPehhh> So the "Stack Overflow" one can get in Haskell is more or less just something to prevent infinite loops?
15:58:13 <FliPPehhh> And nothing technical?
15:58:18 <Saizan_> kpreid: parametrically polypormhic
15:58:34 <Saizan_> kpreid: as opposed to ad-hoc, like typeclasses
15:59:18 <kpreid> hm, you mean Num a => a is not "parametrically polymorphic"?
15:59:39 <Saizan_> right
16:00:03 <ddarius> FliPPehhh: Ignore what many people here are saying.
16:00:17 <shapr> FliPPehhh: Are you related to Flippi?
16:00:24 <FliPPehhh> Nope
16:00:29 <shapr> oh, ok
16:01:07 <ddarius> FliPPehhh: Here's an old school paper on tail call optimization
16:01:08 <Saizan_> FliPPehhh: you can still have stack overflows in haskell, but they are not  common as you might think, however here's a good page on the argument: http://www.haskell.org/haskellwiki/Stack_overflow
16:01:10 <lambdabot> Title: Stack overflow - HaskellWiki
16:01:25 <ddarius> http://library.readscheme.org/servlets/cite.ss?pattern=Ste-77
16:02:58 <ddarius> Saizan_: Actually, if you are have little experience with strict functional languages stack overflows are less common than you might think, if you have a lot they are more common than you might think.
16:03:29 <ddarius> Of course, if you have a moderate amount of experience with non-strict functional languages then they are rare.
16:03:57 <monochrom> @src foldr
16:03:58 <lambdabot> foldr f z []     = z
16:03:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:04:07 <monochrom> @src map
16:04:08 <lambdabot> map _ []     = []
16:04:08 <lambdabot> map f (x:xs) = f x : map f xs
16:04:12 <FliPPehhh> Oh okay
16:04:21 <FliPPehhh> So stack overflows can easily be avoided
16:04:24 <monochrom> Note that map will not cause a stack overflow.
16:05:09 <Saizan_> ddarius: depending on how likely you're to use a lazy accumulator, essentially?
16:05:14 <monochrom> foldr will or will not get into a stack overflow depending on f.
16:05:30 <ddarius> Saizan_: More or less, yes.
16:06:51 <EvilTerran> monochrom, btw, is your name taken from the weird austrian art collective?
16:07:15 <EvilTerran> or did you think of dropping the "e" independently?
16:07:52 <shapr> He got the idea from me!
16:08:04 * shapr is sooo modest
16:08:15 <EvilTerran> all these folk dropping Es. you'd think this was a rave.
16:08:18 <EvilTerran> :P
16:08:21 <monochrom> e is dropped purely to fit the EFNet limit of 9 characters.
16:08:28 <shapr> Right on VilTerran!
16:08:39 <shapr> Or is that EvilTrran?
16:08:43 <shapr> hmmm
16:09:22 <EvilTerran> nah, it would be EvilTerrane if you spelt it normally :P
16:09:23 <shapr> hiya ekidd
16:09:33 <mrsolo> is realworldhaskell the best haskell intro book nowdays?
16:09:37 <ekidd> shapr: Hi!
16:09:44 <ekidd> mrsolo: Definitely one of them.
16:09:48 <r3m0t> absolutely undoubtedly certainly surely the best
16:09:50 <r3m0t> unless it isn't
16:09:54 <EvilTerran> mrsolo, "best" is subjective, but it ranks pretty high
16:09:58 <TomMD> mrsolo: It will be once printed.
16:10:44 <mrsolo> allright.. 3rd attempt at using/learning haskell
16:10:55 <TomMD> mrsolo: So are you the one who said that on proggit?
16:11:02 <mrsolo> nope
16:11:08 <stepcut> mrsolo: you should try to switch to dvorak at the same time
16:11:15 <TomMD> Humm.  We have a couple three timers trying with RWH.
16:11:15 <EvilTerran> and linux
16:11:27 <mrsolo> dvorak, much more difficult
16:11:31 <shapr> aoeu?
16:11:41 <EvilTerran> alphabetical order keyboard
16:11:43 <shapr> heck no
16:12:00 <EvilTerran> as advocated by dijkstra. although that may have had something to do with the "ijk" and "str" in his name. :P
16:12:06 <ddarius> mrsolo: It takes about a week or two to type Dvorak.
16:12:19 <mrsolo> ddarius: i tried and failed
16:12:19 <Olathe> People who use Dvorak are evil.
16:12:32 <mrsolo> switching to left-handed trackball is much easier for me
16:12:40 <shapr> I use that!
16:12:47 <shapr> Both left-handed trackball and dvorak.
16:12:50 <ekidd> ddarius: It's a little rougher for Emacs users, though! :-)
16:12:54 <Olathe> You're sinister and evil !
16:13:02 <shapr> I use dvorak on emacs!
16:13:03 * EvilTerran is a leftie but uses a mouse right-handed
16:13:06 <Olathe> Hahaha
16:13:07 <ddarius> ekidd: Rougher than for vim users?  I find that hard to believe.
16:13:20 <TomMD> Everyone thinks they have it hard.
16:13:22 <Olathe> I use Dvorak with ScITE.
16:13:22 <EvilTerran> actually, i generally use the trackpoint, 'cos then i don't have to move my hand off the keyboard
16:13:37 <EvilTerran> shapr, so you're sinister, evil, *and* a heretic!
16:13:45 <shapr> RIGHT ON!
16:13:45 <shapr> YOW!
16:13:50 <EvilTerran> @yow!
16:13:50 <lambdabot> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like RICARDO
16:13:51 <lambdabot> MONTALBAN'S HAIR!
16:13:59 <EvilTerran> ... i got that one last time =/
16:13:59 <Olathe> @. pl yow
16:14:00 <lambdabot> (line 3, column 1):
16:14:00 <lambdabot> unexpected end of input
16:14:00 <lambdabot> expecting space or simple term
16:14:18 <TomMD> "I had to learn geometry to become a carpenter"  ... "I had to get a B.S. to get a CS job" ... "I had to get a PhD to get a Galois job"
16:14:53 <EvilTerran> "I had to work for decades in academia to get headhunted by MSR"
16:15:46 <EvilTerran> "I had to get headhunted by MSR before SPJ even introduced me to the lowest ranks of the cabal fnord"
16:16:28 <shapr> Hail Eris!
16:17:10 <EvilTerran> -><-
16:17:51 <Cale> Hmm... it might be nice to have at least an option for GHC to never stack overflow. I sort of think of stack overflows as being similar to the ugly black slugs that TeX will sometimes drop into the margin of your document when you've given it a situation where the layout algorithm is either forced to put words too close together on a line, or else have them spread out in a too thinly. They're a sign of something which
16:17:51 <Cale>  is a performance issue, but which is then made more noticeable by the tool you're using.
16:19:19 <Cale> Sure, if you run into a situation where you need to evaluate an expression which is very very large, then chances are, it would have been a good idea to do a little more evaluation earlier on, but sometimes killing the entire program run over that is obnoxious.
16:21:41 <Cale> The machinery is already apparently there to automatically grow the stack, it's just artificially limited.
16:21:55 <monochrom> Enlarging the stack on-the-fly has always been on the wishlist.
16:21:56 <Olathe> @. pl run let term p = intersperse '*' $ take p $ repeat 'n'; sum p = foldr (++) "" $ intersperse "+" $ map term [1..p] in say $ "\\n -> " ++ (sum 10)
16:21:59 <lambdabot> (line 2, column 1):
16:21:59 <lambdabot> unexpected end of input
16:21:59 <lambdabot> expecting space or simple term
16:22:05 <Olathe> Lies.
16:22:12 <monochrom> Oh, it can already?  Cool.
16:23:08 <monochrom> Send this spam to the GHC people: "enlarge your stack now! 6" long, or 9" long, or 12" long!"
16:23:50 <ddarius>  @msg ghcpeople enlarge your stack now! 6
16:24:15 <monochrom> "new drug enlarges your stack to fit the target!"
16:24:21 <Olathe> Hahaha
16:26:37 <FliPPehhh> @src map
16:26:37 <lambdabot> map _ []     = []
16:26:37 <lambdabot> map f (x:xs) = f x : map f xs
16:29:28 <shapr> @src shapr
16:29:28 <lambdabot> Source not found. Where did you learn to type?
16:29:41 <Olathe> > let addOne [] = []; addOne (x:xs) = x + 1:addOne xs in addOne [1..10]
16:29:43 <shapr> @shapr shapr
16:29:43 * lambdabot orders her trained monkeys to punch shapr
16:29:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
16:30:17 <Olathe> @pl let addOne [] = []; addOne (x:xs) = x + 1:addOne xs in addOne [1..10]
16:30:17 <lambdabot> (line 1, column 12):
16:30:18 <lambdabot> unexpected "["
16:30:18 <lambdabot> expecting pattern or "="
16:30:28 <Olathe> Eww
16:32:04 <ivanm> @pl addOne [] = []; addOne (x:xs) = (x+1) : (addONe xs)
16:32:05 <lambdabot> (line 1, column 11):
16:32:05 <lambdabot> unexpected "="
16:32:05 <lambdabot> expecting variable, "(", operator or end of input
16:32:18 <Olathe> @pl let addOne [] = []; addOne (x:xs) = x + 1:addOne xs in addOne
16:32:19 <lambdabot> (line 1, column 12):
16:32:19 <lambdabot> unexpected "["
16:32:19 <lambdabot> expecting pattern or "="
16:32:23 <ivanm> don't think @pl likes multi-line functions
16:32:33 <ivanm> Olathe: addOne = map succ ;-)
16:32:38 <Olathe> I know :)
16:32:47 <ivanm> or map (1+) if you prefer
16:32:59 <lilac> or fmap (+1)
16:33:14 <Olathe> Or (<$>) (+1) according to earlier.
16:33:37 <Olathe> fmap is kind of neat.
16:39:43 <mmorrow> > (fmap . fmap . fmap . fmap . fmap) (+1) [Node [Node [0] []] []]
16:39:46 <lambdabot>   [Node {rootLabel = [Node {rootLabel = [1], subForest = []}], subForest = []}]
16:40:03 <EvilTerran> > everywhere (mkT (+1)) [Node [Node [0] []] []]
16:40:06 <lambdabot>   mueval: Prelude.read: no parse
16:40:07 <Olathe> O-o
16:40:10 <EvilTerran> bah
16:40:24 <mmorrow> EvilTerran: haha, i was just typing that
16:40:30 <EvilTerran> ?type everywhere (mkT (+1)) [Node [Node [0] []] []]
16:40:32 <lambdabot> forall t. (Data t, Num t) => [Tree [Tree [t]]]
16:40:34 <EvilTerran> :D
16:40:56 <Olathe> > sawDown $ (fmap . fmap . fmap . fmap . fmap) (+1) [Node [Node [0] []] []]
16:40:59 <lambdabot>   mueval: Prelude.read: no parse
16:40:59 <ddarius> > (fmap fmap fmap fmap fmap fmap fmap fmap fmap) (+1) [Node [Node [0] []] []]
16:41:00 <EvilTerran> ?src Tree
16:41:01 <lambdabot> Source not found. My pet ferret can type better than you!
16:41:01 <lambdabot>   Couldn't match expected type `a -> b'
16:41:31 <Olathe> @let sawDown = const Nothing
16:41:33 <lambdabot>  Defined.
16:41:36 <Olathe> > sawDown $ (fmap . fmap . fmap . fmap . fmap) (+1) [Node [Node [0] []] []]
16:41:39 <lambdabot>   Nothing
16:42:05 <EvilTerran> ddarius, i think you're gonna need more fmaps
16:42:30 <EvilTerran> that one may not converge, even
16:43:19 <Olathe> > let redo 0 _ = id; redo n f = f.(redo (n - 1) f) in (redo 5 fmap) (+1) [Node [Node [0] []] []]
16:43:21 <lambdabot>       Occurs check: cannot construct the infinite type: a = f a
16:43:21 <lambdabot>        Expect...
16:43:27 <Olathe> Bad lambdabot !
16:43:59 <ddarius> > (fmap fmap $ fmap $ fmap $ fmap $ fmap $ fmap $ fmap fmap) (+1) [Node [Node [0] []] []]
16:44:01 <lambdabot>       No instance for (Show (f1 (f a -> f b)))
16:44:01 <lambdabot>        arising from a use of `...
16:44:18 <ddarius> It's just a matter of getting the parentheses right.
16:44:50 <ddarius> > (fmap fmap $ fmap fmap $ fmap fmap $ fmap fmap $ fmap) (+1) [Node [Node [0] []] []]
16:44:53 <lambdabot>   [Node {rootLabel = [Node {rootLabel = [1], subForest = []}], subForest = []}]
16:44:57 <ddarius> There we go.
16:45:35 <mmorrow> > fmap flatten . (fmap . fmap . fmap) flatten $ [Node [Node [0] []] []]
16:45:39 <lambdabot>   [[[[[0]]]]]
16:46:14 <ddarius> > fmap (fmap flatten) (fmap fmap $ fmap fmap $ fmap) flatten $ [Node [Node [0] []] []]
16:46:16 <lambdabot>   Couldn't match expected type `Tree (f (f1 (Tree a)))'
16:46:29 <sjanssen> > fmap flatten . (fmap `fmap` fmap `fmap` fmap) flatten $ [Node [Node [0] []] []]
16:46:33 <lambdabot>   [[[[[0]]]]]
16:46:46 <mmorrow> @let nTimes n = foldr (.) id . replicate n
16:46:48 <lambdabot>  Defined.
16:47:00 <mmorrow> > nTimes 4 concat . fmap flatten . (fmap . fmap . fmap) flatten $ [Node [Node [0] []] []]
16:47:02 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
16:47:03 <lambdabot>        Expect...
16:47:08 * EvilTerran notes at best exponential growth in the number of fmaps he's gonna need
16:47:24 <ddarius> mmorrow: Yeah, that is one area HM falls down.
16:47:59 <mmorrow> dang
16:48:10 <ddarius> > let twice f = f . f in twice (:[])
16:48:12 <lambdabot>       Occurs check: cannot construct the infinite type: c = [c]
16:48:13 <lambdabot>        Expect...
16:48:23 <Olathe> > construct c = [c]
16:48:26 <lambdabot>   mueval: Prelude.read: no parse
16:48:30 <ddarius> > let twice f = f . f in (:[]) . (:[]) $ 1
16:48:33 <lambdabot>   [[1]]
16:49:52 <mmorrow> @type twice . twice
16:49:54 <lambdabot> Not in scope: `twice'
16:49:54 <lambdabot> Not in scope: `twice'
16:50:06 <mmorrow> @type let twice f = f . f in twice . twice
16:50:08 <lambdabot> forall c. (c -> c) -> c -> c
16:50:24 <mmorrow> @type let twice f = f . f in twice (twice . twice)
16:50:26 <lambdabot> forall c. (c -> c) -> c -> c
16:51:58 <Saizan_> .
16:53:18 <mmorrow> hah, look at this:
16:53:26 <mmorrow> :t (nTimes 5 (unsafeCoerce concat) $ fmap flatten . (fmap . fmap . fmap) flatten $ [Node [Node [0::Int] []] []])
16:53:28 <lambdabot> Not in scope: `unsafeCoerce'
16:53:34 <mmorrow> [[[[[Int]]]]]
16:53:53 <mmorrow> ghci> nTimes 5 (unsafeCoerce concat) $ fmap flatten . (fmap . fmap . fmap) flatten $ [Node [Node [0::Int] []] []]
16:53:54 <mmorrow> []
16:54:17 <lispy> what is your definition of unsafeCoerce?
16:54:27 <mmorrow> Unsafe.Coerce.unsafecoerce
16:54:52 <mmorrow> ghci> (unsafeCoerce pi)::Int
16:54:52 <mmorrow> 1413754136
16:55:04 <mmorrow> ghci> (unsafeCoerce "asdf")::Int
16:55:04 <mmorrow> 1744841559
16:55:06 <ddarius> unsafeCoerce is fun !
16:55:06 <lispy> oh I always thought it was unsafeCoerce#
16:55:19 <mmorrow> unsafeCoerce = unsafeCoerce#
16:55:29 <mmorrow> the one with the # is ghc's implem of it
16:55:35 <ddarius> lispy: Other implementations have unsafeCoerce
16:55:47 <ivanm> ummm.... how did it do that? by taking the codepoints?
16:56:13 <lispy> ddarius: so that one is portable?
16:56:17 <mmorrow> ivanm: just grabbing the whatever's in memory where the Int would have it's val
16:56:31 <ivanm> hmmm...
16:57:00 <ddarius> lispy: Yes.
16:57:04 <mmorrow> some type'll default
16:57:05 <Olathe> Apparently (unsafeCoerce 91281298391823)::String is too unsafe.
16:57:10 <mmorrow> ghci> (unsafeCoerce 0)::()
16:57:10 <mmorrow> ()
16:57:20 <mmorrow> ghci> (unsafeCoerce 0)::[a]
16:57:20 <mmorrow> []
16:57:21 <Olathe> ghci died.
16:57:23 <mmorrow> but...
16:57:29 <ivanm> Olathe: lol
16:57:32 <mmorrow> ghci> (unsafeCoerce 0)::(a,a)
16:57:32 <mmorrow> (Segmentation fault
16:57:54 <ddarius> mmorrow: You need to know things are represented.
16:58:10 <mmorrow> because it tries to go beyond the Integer's mem boundary and segfaults
16:58:25 <Olathe> Ahh.
16:58:33 <Olathe> I'll try the other way
16:58:47 <ddarius> mmorrow: No, it is trying to follow a pointer in the first component.
16:59:03 <Olathe> (unsafeCoerce "test")::Integer
16:59:05 <Olathe> That hangs :D
16:59:06 <mmorrow> yeah, undefined behavior essentially
16:59:43 <ddarius> > show (undefined :: ())
16:59:46 <lambdabot>   mueval: Prelude.read: no parse
16:59:47 <lambdabot>  mueval: "*** Exception: Prelude.undefined
17:00:07 <mmorrow> (that pointer takes it to wherever happens to be at whatever value happens to be in where the pointer would have been)
17:00:15 <mmorrow> hah
17:00:45 <mmorrow> err, s/wherever/whatever/ there
17:00:50 <EvilTerran> ?type fmap (fmap fmap fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap fmap (fmap fmap fmap)
17:00:57 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) a b (f4 :: * -> *). (Functor f4, Functor f3, Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 (f3 (f4 a))) -> f1 (f2 (
17:00:58 <lambdabot> f3 (f4 b))))
17:01:04 <EvilTerran> lambdabot's reached the point of struggling to typecheck it, i think i'll stop there :P
17:02:04 <EvilTerran> i suspect i have an algorithm that should reduce expressions of that structure to nothing but a sequence of unparenthesised fmap's, but i have no proof of termination
17:02:15 <EvilTerran> and they get very long very quickly
17:03:34 <EvilTerran> (that structure ::= "fmap . "* "fmap")
17:05:53 <nus-> erhm, anything close to GGNFS written in HS?
17:06:22 <EvilTerran> fmap . fmap = fmap fmap fmap; fmap . fmap . fmap = fmap fmap fmap . fmap = fmap (fmap fmap fmap) fmap = (fmap . fmap fmap) fmap fmap = fmap fmap (fmap fmap) fmap fmap = (fmap fmap . fmap) fmap fmap fmap = fmap (fmap fmap) fmap fmap fmap fmap = (fmap . fmap) fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap
17:06:25 <bjrn> Language too slow. No offence to anyone in here :)
17:06:40 <Olathe> nus-: I doubt it, but I don't know.
17:06:45 <EvilTerran> ?type (fmap . fmap . fmap)
17:06:46 <bjrn> Of course, it'd be a great language for learning the algorithm
17:06:47 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:06:48 <EvilTerran> ?type fmap fmap fmap fmap fmap fmap fmap fmap
17:06:50 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
17:07:04 <EvilTerran> bjrn, ehm, have you seen haskell's shootout scores?
17:07:24 <EvilTerran> we're quite capable of blowing away industry-standard interpreted languages, at least
17:07:24 <Olathe> > compare 2 3
17:07:27 <lambdabot>   LT
17:07:32 <bjrn> EvilTerran: Of course, I'd love to be wrong :)
17:07:33 <Olathe> :t compare 2 3
17:07:35 <lambdabot> Ordering
17:07:41 <Olathe> @src Ordering
17:07:41 <lambdabot> data Ordering = LT | EQ | GT
17:08:06 <bjrn> I do signal processing in Haskell and I got a substantial speed up porting some of the code to C. Then again I'm a haskell newbie, so it can probably be improved :)
17:08:19 <mmorrow> Evilterran: interpreted?? Haskell blows away most compiled langs wrt performance
17:08:22 <EvilTerran> i think we're pretty comparable to java, if you want to keep to fairly-idiomatic haskell only. i forget where exactly where we rank overall, it varies from benchmark to benchmark
17:08:37 <EvilTerran> mmorrow, i was trying to speak in things i know to be true, initially at least
17:08:48 <mmorrow> EvilTerran: :)
17:08:49 <EvilTerran> we're not consistently beating all compiled languages
17:08:58 <EvilTerran> so i thought i'd save the wishy-washy claim for after the bold one
17:09:00 <mmorrow> i din't say /all/. i said most
17:09:25 <mmorrow> and it isn't the case that there's a compiled lang that beats haskell in every category
17:09:49 <mmorrow> (now speaking in terms of the lang benchmarks thing)
17:09:50 <EvilTerran> i didn't say you did, merely that i didn't think a claim with a dubious word like "most" in it would be make a good start
17:09:58 <EvilTerran> s/make//
17:10:06 <mmorrow> oh, i know. i'm not arguing with you personally.
17:10:23 <EvilTerran> just being argumentative in general? :P
17:10:39 <mmorrow> yes, for haskell's sake
17:11:08 <bjrn> :) It'd be awesome with a language shootout using number crunching code.
17:11:21 <bjrn> "Compute the FFT"
17:11:27 <bjrn> Quadratic Sieve...
17:11:28 <bjrn> Etc
17:11:28 <EvilTerran> don't mind me, i should be sleeping right now (and probably am in some respects :P)
17:11:35 <mmorrow> EvilTerran: :)
17:12:42 <bjrn> Of course, having implemented the really tight routies (say FFT) in C, it's a joy to use from Haskell
17:12:50 <bjrn> Glue ftw.
17:13:21 <nus-> fsck c, compile native.
17:13:36 <EvilTerran> bjrn, when working in pure haskell, did you compile with ghc -O2?
17:13:40 <EvilTerran> did you profile?
17:14:31 <Olathe> Profiling is discrimination !
17:14:38 <EvilTerran> -O2 can make an astronomical difference
17:14:44 <bjrn> Ah, always -O2
17:15:05 <bjrn> I will try to improve the haskell code and see how it compares to C.
17:15:07 <dmhouse> How much slower are the compile times with -O2?
17:15:25 <dmhouse> Because I mean, seriously, can it not be the default? :)
17:15:28 <EvilTerran> profiling can provide great insight, even if it doesn't resolve the problem currently at hand
17:15:54 <EvilTerran> or it can uncover compiler bugs :P
17:16:13 <bjrn> Hmm anyone know of a haskell lib that generates random input, for benchmarking purposes?
17:16:24 <EvilTerran> not sure about benchmarking
17:16:30 <EvilTerran> but quickcheck does so for unit testing
17:16:59 <EvilTerran> @check (\xs -> reverse (reverse xs) == xs)
17:17:02 <lambdabot>   "OK, passed 500 tests."
17:17:08 <bjrn> Oh nice feature :)
17:17:11 <mmorrow> dmhouse: i always compile with -O2. even ghc itself.
17:17:38 <mmorrow> > (reverse . reverse) [0..]
17:17:40 <mmorrow> :)
17:17:48 <EvilTerran> that's a slightly cheeky example, actually - because of the type defaulting, those lists were of type [()] :P
17:17:52 <Olathe> @check (\xs -> xs == head xs:tail xs)
17:17:53 <lambdabot>   mueval: Prelude.read: no parse
17:17:56 <lambdabot>   mueval: Time limit exceeded
17:18:00 <EvilTerran> but i could give it an explicit type and it'd still work
17:18:15 <EvilTerran> mmorrow, yeah, it only does finite inputs, i know
17:18:16 <Olathe> @check (\xs -> xs == (head xs):(tail xs))
17:18:19 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
17:18:27 <Olathe> \n !
17:18:37 <EvilTerran> one that could deal with partial inputs and detect differences in strictness would be nice
17:18:41 <mmorrow> i was just illistrating for bjrn's sake :)
17:18:46 <mmorrow> s/i/u/
17:18:48 <EvilTerran> but a whole new kettle of fish to implement
17:19:08 <bjrn> cheers mmorrow :)
17:19:15 <mmorrow> :)
17:20:01 <mmorrow> but what dreams may come!
17:20:49 <Olathe> > let f :: Int -> (); f = const () in f 5.0
17:20:52 <lambdabot>       No instance for (Fractional Int)
17:20:52 <lambdabot>        arising from the literal `5.0' ...
17:25:25 <Olathe> How do I get lambdabotish stuff in ghci ?
17:25:45 <dmhouse> ?where goa
17:25:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
17:26:33 <Olathe> Thanks.
17:28:30 <bjrn> Is GHC the most optimizing Haskell compiler, or are there some experimental ones? For Scheme there's Stalin, but it only implements a subset of thelanguage (it optimize this subset like crazy tho) :)
17:29:39 <bjrn> Stalin is pretty interesting. Generated source, about 12-20 megabytes.
17:30:20 <bjrn> http://en.wikipedia.org/wiki/Stalin_(Scheme_implementation)
17:30:39 <lispy> oh, that stalin
17:30:44 <TomMD> bjrn: JHC aims at being the most optimising compiler, but isn't ready for production use (I've never tested it).  YHC has Neils work on Super-O, but for best results he uses GHC too.
17:30:46 <Cale> bjrn: Well, there's jhc, which does whole program compilation.
17:30:55 <newsham> isnt clean the fastest haskell compiler ;-)
17:30:57 <TomMD> @where supero
17:30:57 <lambdabot> I know nothing about supero.
17:31:05 <TomMD> @where super-o
17:31:06 <lambdabot> I know nothing about super-o.
17:31:12 <TomMD> @google haskell super-o
17:31:15 <lambdabot> http://neilmitchell.blogspot.com/2007/08/supero-faster-than-ghc.html
17:31:15 <lambdabot> Title: Neil Mitchell's Haskell Blog: Supero: Faster than GHC*
17:31:23 <bjrn> Interesting, thanks
17:31:38 <bjrn> Oh, that's quite substantial
17:31:42 <adu> is that superoptimization?
17:31:46 <TomMD> yes
17:32:01 <adu> I love that idea, if only I had my own personal cray
17:32:13 <TomMD> Great (and readable) paper - you should check it out!
17:32:58 <qwr> jhc was the one with interesting memory management?
17:33:22 <TomMD> What?  You don't call "dump it on the heap" interesting?
17:33:41 <qwr> :)
17:33:59 <qwr> i think jhc did some weird static analysis to avoid runtime gc
17:34:27 <thoughtpolice> it's a variant of region inference
17:34:43 <thoughtpolice> there is no pre-written runtime, parts of 'a runtime' are generated into the outputted C code as necessary
17:34:44 <adu> Woow
17:36:16 <ddarius> EvilTerran: There is already a strictcheck
17:36:50 <adu> I think of all the compilers that will never be written: is the dynamic haskell superoptimizer (DHS)
17:37:11 <bjrn> Hehe sounds like a CERN project.
17:38:28 <adu> bjrn: or a bad excuse to build yet another US defense agency...
17:40:10 <Olathe> @check \xs -> tail xs == drop 1 xs
17:40:12 <lambdabot>   mueval: "*** Exception: Prelude.tail: empty list
17:40:15 <Olathe> Heheh
17:40:33 <Olathe> @check \xs -> null xs || tail xs == drop 1 xs
17:40:36 <lambdabot>   "OK, passed 500 tests."
17:41:45 <ddarius> That is -not- superoptimization.  It is supercompilation.
17:48:12 <adu> anyone wanna help me with a typechecker?
17:48:25 <dmhouse> > return "Ask" :: Maybe String
17:48:28 <lambdabot>   Just "Ask"
17:49:51 <adu> well I've been having problems with my constructors
17:50:08 <adu> I think I have too many: http://hpaste.org/10100
17:50:59 <Olathe> I see you're making a chemistry application.
17:51:05 <adu> Olathe: lol
17:52:02 <adu> I'm wondering if the cons-like constructors should be bound identifiers, and use "Id" or if I should treat them differently in the expression datatype
17:53:50 <adu> I could still use that for pattern matching, like (inferType (Ap (Ap (Id ":") a) b) = ...) instead of (inferType (C2 a b) = ...)
17:54:08 <qwr> adu: weird stuff. what should it do?
17:54:25 <adu> qwr: I'm designing an adga-like interpreter
17:54:55 <adu> if you're familiar with HList, (.) is :*: and (:) is (.*.)
17:55:29 <Olathe> Are there any PNG libraries that allow you to mess with the compression dictionaries and so on ?
17:56:14 <adu> qwr: in short, I'm trying to write a type-checker for a dependant type system, that might have to be dynamically typed as well...
17:57:44 <qwr> sounds cool :)
18:02:53 <adu> qwr: the part I'm most unsure/passionate about is the polymorphism
18:03:33 <adu> qwr: I'm thinking the run-time polymorphism is going to require dynamic typing...
18:04:12 <adu> but then again, all instances of polymorphism I've decided upon so far could be implemented at compile-time...
18:04:25 <adu> qwr: do you wanna see a webpage I made about it?
18:09:17 <seydar> is it evidence that i am unenlightened, that i should ask when i will know if i understand monads?
18:10:18 <adu> seydar: you will know when you see someone using -> IO () on hpaste and say unto them... you don't need monads for that!
18:10:49 * seydar bows
18:11:38 <monochrom> You will understand monads after reading 10 tutorials.
18:12:11 <bjrn> Where by 10 you mean a 2-bit signed integer? :)
18:12:21 <bjrn> Just hack around
18:12:25 <adu> like there are 10 kinds of ppl in this world :) lol
18:12:27 <bjrn> Reading is good too
18:12:28 <monochrom> Probably a hexadecimal number.
18:13:59 <adu> I really don't know when Monads clicked for me, I think it was after writing an OpenGL app, a Parser, and a random number generator...
18:14:21 <seydar> ahah! i dont understand monads
18:14:54 <adu> seydar: start with a Parsec parser, its easier than you think
18:15:10 <seydar> i'm toying with parsec now. It makes a LOT of sense
18:15:13 <adu> I think the OpenGL app was the hardest
18:15:25 <seydar> but my issue is that i don't know how I would build parsec
18:15:34 <seydar> therefore i feel i don't know enough yet
18:15:49 <bjrn> Parsec is to Haskell what Yacc/BIson is to C?
18:15:56 <adu> seydar: fancy usage of unsafeInferleaveIO i think, i dunno
18:16:33 <seydar> actually, i feel pretty enlightened admitting my inferiority
18:16:57 <adu> bjrn: no, Parsec is to Haskell what the Borg are to C
18:17:39 <hansfbaier> bjrn: Happy/Alex are comparable to yacc/lex
18:17:47 * adu imagines a bison trampling him sayaing "resistance is futile"
18:18:04 <Olathe> The names of Haskell products are very strange.
18:18:08 <monochrom> http://www.cs.nott.ac.uk/~gmh/bib.html#monparsing  "monadic parser combinators" has the principle.  Parsec is not exactly it (optimization) but ok.
18:18:09 <lambdabot> Title: Graham Hutton: Publications
18:18:12 <bjrn> Oh nice, there's a Parsec chapter in RWH
18:18:45 <Olathe> Anyone know any coupon codes that work with RWH on Amazon ?
18:19:05 <mxc> olathe - its part of the 'avoid success at all costs' mantra of haskell
18:19:12 <adu> seydar: my favorite parser: lisp = myLiteral <|> parens $ many $ lexeme lisp
18:19:13 <hansfbaier> What kind of parser is Parsec, LL(k)?
18:19:23 <Olathe> Heheh. A decent mantra.
18:20:13 <adu> seydar: which is a descent approximation to lisp syntax...
18:20:24 <hansfbaier> oh, LL(1)
18:20:38 <adu> hansfbaier: LL(infinity)
18:21:25 <bjrn> > sum (cycle [1,-1])
18:21:30 <hansfbaier> adu: backtracking?
18:21:36 <adu> hansfbaier: yes
18:22:44 <hansfbaier> adu: I really like antrs LL(*) strategy
18:22:55 <adu> hansfbaier: whats that?
18:23:25 <mmorrow> > nub [0..]
18:23:31 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:23:33 <hansfbaier> adu: it uses a finite state automaton to look ahead.
18:23:47 <seydar> what does LL(k) mean?
18:23:50 <mmorrow> > nub . fmap (`mod`7) $ [0..]
18:23:54 <seydar> apart from a type of parser
18:24:05 <lambdabot>   thread killed
18:24:06 <hansfbaier> adu: and uses O(exp) backtracking only as a last resort.
18:24:35 <mxc> :t fmap
18:24:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:24:55 <mmorrow> > map (+1) [0..4] == fmap (+1) [0..4]
18:24:59 <lambdabot>   True
18:25:19 <mmorrow> @type Node 0 []
18:25:20 <lambdabot> forall t. (Num t) => Tree t
18:25:27 <mxc> > fmap (+ 5) $ Just 1
18:25:28 <mmorrow> @type fmap (+1) (Node 0 [])
18:25:31 <lambdabot> forall a. (Num a) => Tree a
18:25:31 <lambdabot>   Just 6
18:25:39 <mmorrow> > fmap (+1) (Node 0 [])
18:25:42 <lambdabot>   Node {rootLabel = 1, subForest = []}
18:26:11 <lispy> hmm...I have a module here with {-# OPTIONS_GHC -fno-warn-orphans #-} and it's still warning about orphans
18:26:49 <mmorrow> is -Wall set somewhere? maybe it's overiding it?
18:27:23 <lispy> -Wall is set on the commandline, but usually the per module comment overrides that
18:27:31 <mmorrow> hmm
18:27:38 <Igloo> Is the pragma high enough up the file?
18:28:05 <lispy> Igloo: i was wondering about that too, this is src/Darcs/Patch/Properties.lhs if you want to see for yourself
18:28:14 <Igloo> It's possible the pragma is being corrupted due to a known bug; I think only if the module proper doesn't start for >= 1k or something
18:28:39 <mxc> if someone wants a nice distraction:
18:28:40 <mxc> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
18:28:43 <lambdabot> Title: [FoRK] And then there's Haskell... (was: Bone / Greenspun, etc.), http://tinyurl.com/5c7uj5
18:29:08 <mmorrow> > fmap show (0,1)
18:29:12 <lambdabot>   (0,"1")
18:29:23 <bjrn> Hm?
18:29:40 <lispy> mmorrow: weird
18:29:49 <mmorrow> > instance Functor (,) a where fmap f (x,y) = (x, f y)
18:29:52 <lambdabot>   mueval: Prelude.read: no parse
18:29:56 <mmorrow> heh s/>//
18:30:51 <mmorrow> > let chunk n = takeWhile (not . null) . uncurry (:) . fmap (chunk n) . splitAt n in chunk 4 [0..]
18:30:54 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],...
18:31:29 <mmorrow> @ type \f -> uncurry (:) . fmap f
18:31:32 <mmorrow> @type \f -> uncurry (:) . fmap f
18:31:34 <lambdabot> forall a a1. (a1 -> [a]) -> (a, a1) -> [a]
18:32:16 <mmorrow> @type let go f x = uncurry (:) . fmap (go f) $ x
18:32:18 <lambdabot> <no location info>:
18:32:18 <lambdabot>     not an expression: `let go f x = uncurry (:) . fmap (go f) $ x'
18:32:35 <mmorrow> @type let go f = uncurry (:) . fmap (go f) in go
18:32:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a1, a)
18:32:37 <lambdabot>       Expected type: a -> [a1]
18:32:37 <lambdabot>       Inferred type: (a1, a) -> [a1]
18:33:06 <mmorrow> @type let go n = uncurry (:) . fmap (go n) . splitAt n in go
18:33:08 <lambdabot> forall a. Int -> [a] -> [[a]]
18:36:59 <mmorrow> @type list
18:37:01 <lambdabot> Not in scope: `list'
18:39:07 <Olathe> Is there a function that will do the equivalent of expanding (ax^2 + bx + c)(dx + e) when I have [a, b, c][d, e] ?
18:39:49 <Olathe> To give [a*d, a*e + b*d, b*e + c*d, c*e]
18:43:00 <dmwit> Here's a fun puzzle for the bored:
18:43:00 <dmwit> http://soe.stanford.edu/alumni/puzzle.html
18:43:02 <lambdabot> Title: Stanford School of Engineering - Stanford Engineering Puzzle
18:43:23 <adu> lol
18:44:43 <adu> "you know, one of *those* papers." hehe
18:45:08 <TomMD> If you are bored you could add examples to the new Multicore haskell wiki page.
18:45:19 <Olathe> > [2..0]
18:45:20 <TomMD> @where multicore
18:45:20 <lambdabot> I know nothing about multicore.
18:45:22 <lambdabot>   []
18:45:26 <TomMD> @where +multicore http://haskell.org/haskellwiki/Haskell_for_multicores
18:45:27 <lambdabot> I know nothing about +multicore.
18:45:34 <TomMD> @where+ multicore http://haskell.org/haskellwiki/Haskell_for_multicores
18:45:35 <lambdabot> I will remember.
18:46:03 <Stinger_> whats the syntax to get lambda bot to spit out the @src for a function beloning to a particular class instance?
18:46:18 <Stinger_> belonging
18:46:27 <adu> mxc: that was a wonderful distraction!
18:46:40 <Stinger_> say src of tell for Writer
18:46:43 <mxc> adu - glad you enjoyed
18:47:23 <mxc> adu - there's a great followup where someone describes ocaml as:  "Ocaml is mcuh easier, friendlier, but beware. she is a he.  for those of you who are into that, its great, but its not the real thing"
18:47:39 <adu> lol
18:47:45 <mmorrow> @let tupToMaybe (a,b) = if null b then Nothing else Just (a,b)
18:47:47 <lambdabot>  Defined.
18:48:28 <dmwit> ?let ensure p x = guard (p x) >> return x
18:48:31 <lambdabot>  Defined.
18:48:32 <mmorrow> > (unfoldr . (tupToMaybe .) . splitAt) 4 [0..]
18:48:35 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],...
18:48:43 <dmwit> :t ensure (not . null . snd)
18:48:45 <lambdabot> forall a a1 (m :: * -> *). (MonadPlus m) => (a1, [a]) -> m (a1, [a])
18:48:58 <dmwit> :t ensure (not . null . snd) :: (a, b) -> Maybe (a, b)
18:49:00 <lambdabot>     Couldn't match expected type `[a]' against inferred type `b'
18:49:00 <lambdabot>       `b' is a rigid type variable bound by
18:49:00 <lambdabot>           the polymorphic type `forall a1 b. (a1, b) -> Maybe (a1, b)'
18:49:08 <dmwit> :t ensure (not . null . snd) :: (a, [b]) -> Maybe (a, [b])
18:49:10 <lambdabot> forall a b. (a, [b]) -> Maybe (a, [b])
18:49:12 <mmorrow> > (\n -> takeWhile (not . null) . uncurry (:) . fmap (chunk n) . splitAt n) 4 [0..]
18:49:15 <lambdabot>   mueval: Prelude.read: no parse
18:49:26 <mmorrow> oh
18:49:29 <mmorrow> > let chunk n = takeWhile (not . null) . uncurry (:) . fmap (chunk n) . splitAt n in chunk 4 [0..]
18:49:33 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],...
18:50:39 <adu> dmwit: lol that doesn't even have a solution!
18:50:50 <dmwit> adu: That's the answer I get, too! =/
18:51:05 <mmorrow> heh
18:51:24 <dmwit> I guess there must be some non-English word in there.
18:51:29 <dmwit> A proper noun, maybe.
18:51:42 <Olathe> How do I get [(a, 1), (b, 1), (c, 2), (d, 3)] -> [[a, b], [c], [d]] ?
18:51:58 <adu> dmwit: no, I'm talking about how columns 10 and 22 don't have enough letters
18:52:27 <dmwit> adu: Yes they do, notice the ',' and '.'.
18:52:44 <adu> oh, n/m
18:58:40 <mmorrow> > (unfoldr . (tupToMaybe .)) (tail&&&tail) [0..4]
18:58:43 <lambdabot>   mueval: Prelude.read: no parse
18:59:00 <mmorrow> > let f &&& g = \x -> (f x,g x) in (unfoldr . (tupToMaybe .)) (tail&&&tail) [0..4]
18:59:03 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4]]
19:00:08 <Olathe> > let polyMult as bs = map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ liftM2 (\(aCoeff, aPow) (bCoeff, bPow) -> (aCoeff*bCoeff, aPow + bPow)) (zipPow as) (zipPow bs) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as in polyMult [a, b, c] [d, e]
19:00:12 <lambdabot>   [a * d,a * e + b * d,b * e + c * d,c * e]
19:00:19 <mmorrow> Olathe: nice.
19:00:23 <Olathe> Thanks :)
19:01:39 <TSC> That Stanford Knuth puzzle is not so hard (with the aid of a computer)
19:02:09 <dmwit> TSC: Does that mean you solved it already??
19:02:11 <dmwit> =/
19:02:13 <TSC> Yeah
19:02:23 <dmwit> I have a program to solve it, but it isn't working right.
19:02:28 <dmwit> I'm double checking my input now...
19:02:45 <dmwit> (It solves my mini test puzzle in the blink of an eye, though. =)
19:03:28 <dmwit> In any case, I know it's referring to some form of the "My general working style is to write everything first with pencil and paper, sitting beside a big wastebasket." quote.
19:03:38 <gwern> '7. Curse your curiosity for bringing your work to a halt.
19:03:40 <gwern> hee hee
19:03:55 * gwern marks CANT REPRODUCE; WONT FIX
19:04:11 <dmwit> TSC: Oh, wait, the end of the line doesn't mark the end of a word, does it.
19:04:15 <dmwit> =( =( =(
19:05:20 <TSC> Ha ha! (:
19:09:51 <TSC> dmwit: How does your program work?
19:10:27 <dmwit> Read dictionary into Trie, find words of each length that can be formed with the remaining letters, move on to next space.
19:10:54 <Olathe> Is there a comparing that gives the reverse order ?
19:10:55 <TSC> Backtrack if necessary?
19:11:05 <dmwit> TSC: It's all in the list monad, so yes.
19:11:18 <dmwit> Olathe: flip compare?
19:11:45 <Olathe> How do I use that in sortBy ?
19:11:53 <dmwit> sortBy (flip compare) xs
19:11:53 <Olathe> :t compare
19:11:55 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:12:09 <dmwit> > sortBy (flip compare) [1..10]
19:12:12 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
19:12:40 <Olathe> > sortBy (flip comparing snd) [(a, 1), (b, 3), (c, 2)]
19:12:43 <lambdabot>   Couldn't match expected type `(a, b) -> b'
19:12:50 <Olathe> :t comparing
19:12:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:12:58 <dmwit> TSC: The correct solution is to take a list of Donald Knuth quotes and see which fits into the spaces given. =)
19:13:11 <Olathe> @pl \f x y -> f y x
19:13:12 <lambdabot> flip
19:13:30 <Olathe> @pl \f g x y -> f g y x
19:13:31 <lambdabot> (flip .)
19:13:37 <TSC> > sortBy (flip (comparing snd)) [(a, 1), (b, 3), (c, 2)]
19:13:40 <Olathe> > sortBy ((flip .) comparing snd) [(a, 1), (b, 3), (c, 2)]
19:13:40 <lambdabot>   [(b,3),(c,2),(a,1)]
19:13:41 <dmwit> > sortBy (flip (comparing snd)) ...
19:13:44 <lambdabot>   [(b,3),(c,2),(a,1)]
19:13:44 <lambdabot>  Terminated
19:13:45 <dmwit> I got beat.
19:13:46 <Olathe> Ahh, thanks :)
19:14:01 <dmwit> Wait, terminated?
19:14:03 <dmwit> :t ...
19:14:05 <lambdabot> parse error on input `...'
19:14:20 <dmwit> :t (...)
19:14:22 <lambdabot> forall a. (Num a) => [a] -> [a]
19:14:22 <Olathe> > let polyAdd as bs = map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ sortBy (flip (comparing snd)) ((zipPow as) ++ (zipPow bs)) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as in polyAdd [a, b, c] [d, e]
19:14:26 <lambdabot>   [a,b + d,c + e]
19:14:37 <dmwit> > ([3,4]...)
19:14:40 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
19:14:48 <dmwit> wut
19:14:51 <dmwit> > ([3,5]...)
19:14:55 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
19:15:04 <Olathe> ... uses a nice polynomial interpolation.
19:15:04 <dmwit> > ([2,3,5,7,11]...)
19:15:09 <lambdabot>   [2,3,5,7,11,22,48,100,192,341,567,893,1345,1952,2746,3762,5038,6615,8537,10...
19:15:27 <Olathe> I'm trying to extend it to produce the polynomial, rather than just its results.
19:15:30 <TSC> > ([1,4,9,16]...)
19:15:33 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:15:36 <TSC> Cool
19:16:00 <TSC> Is it much harder to produce the coefficients of the polynomial?
19:16:06 <TSC> (than to extend the sequence)
19:16:45 <dmwit> > [1,4,9,16] ...
19:16:47 <lambdabot>   mueval: Prelude.read: no parse
19:16:57 <dmwit> But before it was Terminated? O_o
19:17:18 <FreenoseJew> stupid niggggger obama if elected nigggs will start killing whites in larger numbers just like after south africa elected their first nnnniiiiigggger!         Barack Hussein Obama Bin Laden won't last 2 months in office!
19:18:30 <dmwit> ?ops
19:18:30 <lambdabot> Maybe you meant: docs oeis pl
19:18:33 <dmwit> ?where ops
19:18:33 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:18:59 <Olathe> > let (#*#) as bs = map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ liftM2 (\(aCoeff, aPow) (bCoeff, bPow) -> (aCoeff*bCoeff, aPow + bPow)) (zipPow as) (zipPow bs) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as in [a, b, c] #*# [d, e]
19:19:02 <lambdabot>   [a * d,a * e + b * d,b * e + c * d,c * e]
19:19:05 <Olathe> That works.
19:19:09 <Olathe> @let (#*#) as bs = map (sum'.(map fst)) $ groupBy (\a b -> snd a == snd b) $ liftM2 (\(aCoeff, aPow) (bCoeff, bPow) -> (aCoeff*bCoeff, aPow + bPow)) (zipPow as) (zipPow bs) where zipPow xs = zip xs (reverse [0..length xs - 1]); sum' [a] = a; sum' (a:as) = a + sum' as
19:19:10 <lambdabot>   Parse error
19:19:12 <Olathe> That fails :(
19:19:20 <Olathe> Is there something horrid about it ?
19:19:24 <adu> dmwit: solved it
19:19:43 <dmwit> adu: Nice!
19:20:07 <adu> dmwit: thanks for the hint about the comma and period!
19:20:16 --- mode: ChanServ set +o allbery_b
19:20:47 --- mode: allbery_b set +b FreenoseJew!*@*
19:21:09 <allbery_b> oh, left already
19:21:24 * allbery_b is lagged both IRL and on network
19:21:38 --- mode: allbery_b set -o allbery_b
19:22:10 <BMeph> allbery_b: Nice try. That guy was silly, though.
19:23:33 <Olathe> @let (######) = 5
19:23:34 <lambdabot>   Parse error
19:23:45 <Olathe> It can't define operators.
19:24:11 <dmwit> ?let a ###### b = 5
19:24:13 <lambdabot>  Defined.
19:24:18 <Olathe> Ahh !
19:24:19 <Olathe> Thanks
19:25:08 <dmwit> That's a workaround for a bug, though; "(#####) a b" *should* work.
19:25:21 * BMeph finds it funny that Michelle Obama is "an African-American woman," and Charlize Theron is "an African woman"...
19:25:32 <Olathe> @let (#++#) a b = a + b
19:25:32 <lambdabot>   Parse error
19:25:51 <Olathe> There's one bug I can't figure out.
19:25:58 <Olathe> @let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k $!chr(124) k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p $!chr(124) p = (f*(f+2*g), ss) $!chr(124) otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g
19:25:58 <lambdabot>   Parse error
19:26:04 <Olathe> > let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k $!chr(124) k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p $!chr(124) p = (f*(f+2*g), ss) $!chr(124) otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g in ffib 6
19:26:07 <lambdabot>   mueval: Prelude.read: no parse
19:26:14 <Olathe> Bah.
19:26:26 <dmwit> You forgot a | in your list comprehension.
19:26:28 <Olathe> @let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g
19:26:29 <lambdabot>   Parse error
19:26:34 <Olathe> > let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g in ffib 6
19:26:38 <lambdabot>   8
19:26:46 <Olathe> Works great except in @let
19:27:10 <chessguy> > mapMaybe f [Just 2, Just 3]
19:27:12 <lambdabot>       No instance for (SimpleReflect.FromExpr (Maybe b))
19:27:13 <lambdabot>        arising from ...
19:27:19 <lispy> Olathe: it's possible ?let uses a buggy parser
19:27:33 <Olathe> Yeah :(
19:27:33 <chessguy> @type mapMaybe
19:27:35 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
19:27:49 <lispy> ?src mapMaybe
19:27:49 <lambdabot> Source not found. Do you think like you type?
19:28:06 <dmwit> mapMaybe f = map f . catMaybes
19:28:20 <dmwit> or
19:28:25 <lispy> reverse them right?
19:28:28 <dmwit> mapMaybe f xs = [f x | Just x <- xs]
19:28:40 <dmwit> lispy: oh
19:28:43 <dmwit> yeah, never mind
19:29:08 <lispy> :t catMaybes
19:29:10 <lambdabot> forall a. [Maybe a] -> [a]
19:29:15 <chessguy> > mapMaybe (Just . (+1)) [1,2,3,4]
19:29:18 <lambdabot>   [2,3,4,5]
19:29:37 <chessguy> > map Maybe (const Nothing) [1,2,3,4]
19:29:40 <lambdabot>   mueval: Prelude.read: no parse
19:29:41 <chessguy> oops
19:29:43 <dmwit> > mapMaybe (ensure (>3)) [1..5]
19:29:46 <lambdabot>   [4,5]
19:29:54 <chessguy> > mapMaybe (const Nothing) [1,2,3,4]
19:29:57 <lambdabot>   []
19:30:26 <dmwit> filter = mapMaybe . ensure -- ;-)
19:30:52 <lispy> :t ensure
19:30:54 <chessguy> @type ensure
19:30:54 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
19:30:56 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
19:31:00 <chessguy> jinx!
19:31:29 <lispy> ensure is kinda cool
19:31:39 <dmwit> I use it a lot.
19:32:00 <dmwit> It's probably one of the best ways of constructing Maybe values.
19:32:38 <chessguy> hm, i can't figure this out
19:33:03 <chessguy> i dug up some code from a few weeks ago, and i'm pretty sure i used it to construct a tic-tac-toe game tree, but now i can't figure out how
19:33:37 <chessguy> http://hpaste.org/10101
19:33:58 <lispy> > ensure (>3) [1..5]
19:34:02 <lambdabot>       No instance for (Show (m [t]))
19:34:02 <lambdabot>        arising from a use of `show' at <...
19:34:14 <dmwit> > [1..5] >>= ensure (> 3)
19:34:17 <lambdabot>   [4,5]
19:34:17 <lispy> > map (ensure (>3)) [1..5]
19:34:21 <lambdabot>       No instance for (Show (m a))
19:34:21 <lambdabot>        arising from a use of `show' at <in...
19:34:34 <dmwit> > map (ensure (>3)) [1..5] :: [[Int]]
19:34:37 <lambdabot>   [[],[],[],[4],[5]]
19:34:47 <chessguy> > inits [1,2,3,4]
19:34:50 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
19:34:59 <adu> what's "ensure"?
19:35:03 <lispy> > ensure (>3) [1..5] :: Maybe [Int]
19:35:06 <mmorrow> @let expand (.+) (.*) xs ys = fmap (\(x,i) -> fmap (\(y,j)->(x.*y,i.+j)) xs) ys
19:35:06 <lambdabot>       No instance for (Num [Int])
19:35:06 <lambdabot>        arising from the literal `3' at <int...
19:35:08 <lambdabot>  Defined.
19:35:13 <dmwit> adu: ensure p x = guard (p x) >> return x
19:35:21 <mmorrow> > expand (+) (*) [(1,0),(7,4)] [(1,2),(1,1)]
19:35:31 <lambdabot>  Terminated
19:35:34 <mmorrow> > expand (+) (*) [(1,0),(7,4)] [(1,2),(1,1)]
19:35:37 <lambdabot>   [[(1,2),(7,6)],[(1,1),(7,5)]]
19:35:38 <dmwit> adu: It just returns mzero if p fails, and x otherwise.
19:36:20 <dmwit> > ensure ((> 3) . length) [1..5] :: Maybe [Int] -- lispy
19:36:23 <lambdabot>  Terminated
19:36:27 <dmwit> err...
19:36:28 <dmwit> > ensure ((> 3) . length) [1..5] :: Maybe [Int] -- lispy
19:36:31 <lambdabot>   Just [1,2,3,4,5]
19:36:43 <mmorrow> @let ppp xs = let pp xs = intercalate " + " . fmap (\(n,i) -> case n of 0 -> [] ; 1 -> "x^" ++ show i ; _ -> show n ++ "x^" ++ show i) $ xs in intercalate " + " . fmap pp $ xs
19:36:45 <lambdabot>  Defined.
19:36:49 <mmorrow> > ppp $ expand (+) (*) [(1,0),(7,4)] [(1,2),(1,1)]
19:36:52 <lambdabot>   "x^2 + 7x^6 + x^1 + 7x^5"
19:36:55 <mmorrow> yay
19:37:24 <dmwit> mmorrow: Neat!
19:37:30 <mmorrow> heh
19:38:08 <mmorrow> (ppp == "ppPoly")
19:38:13 <lispy> > map (ensure (>3)) [1..5] :: Maybe [Int]
19:38:16 <lambdabot>   Couldn't match expected type `Maybe [Int]'
19:38:18 <mmorrow> err, i meant ppPolys
19:38:47 <dmwit> > map (ensure (>3)) [1..5] :: [Maybe Int]
19:38:50 <lambdabot>   [Nothing,Nothing,Nothing,Just 4,Just 5]
19:38:54 <lispy> oh right, thanks
19:39:06 <chessguy> @pl \x b -> b !! x
19:39:07 <lambdabot> flip (!!)
19:40:25 <jeeves__> Can anyone tell me where FFI-pragma'd directives such as #def{ and #let are documented?
19:40:40 <BMeph> What was that? Polyps, you say? ;p
19:41:07 <Olathe> Does anyone have any @let stuff they still need ?
19:41:45 <afd8> whats the best way to deal with floating point accuracy issues in haskell?
19:42:11 <dmwit> afd8: There's a CReal with (nearly) arbitrary precision.
19:42:12 <mmorrow> it take the mult and addition funcs, then two lists representing polynomials (eg  2x^2 + 3 --> [(2,2),(3,0)]), then expands their product into a sum of monomials
19:42:27 <dmwit> > 3 :: CReal -- do we still have it in mueval?
19:42:29 <lambdabot>   3.0
19:42:44 <afd8> hmm
19:42:52 <afd8> hows the performance of it?
19:43:00 <afd8> im trying to do collision testing in physics simulation
19:43:01 <dmwit> afd8: Other than that, just do the things you normally do in all languages to prevent floating point problems.
19:43:15 <dmwit> afd8: It's probably not good enough for high-speed physics engines.
19:43:18 <dmwit> afd8: 2D or 3D?
19:43:20 <mmorrow> afd8: hmatrix'll probably be where you want to look
19:43:22 <afd8> 2d
19:43:29 <dmwit> afd8: Why not use the Chipmunk binding?
19:43:31 <adu> lispy: did you get it?
19:43:42 <adu> > map fromJust $ filter isJust $ (map (ensure (>3)) [1..5] :: [Maybe Int])
19:43:44 <chessguy> @pl \x -> f x == y
19:43:44 <lambdabot> (y ==) . f
19:43:45 <lambdabot>   mueval: Prelude.read: no parse
19:43:48 <mmorrow> afd8: http://www.hmatrix.googlepages.com/
19:43:49 <lambdabot> Title: - hmatrix
19:43:55 <afd8> yea i considered chipmunk
19:43:59 <afd8> but wanted to learn some
19:43:59 <dmwit> ?let ensure p x = guard (p x) >> return x
19:44:01 <dmwit> adu: Try again.
19:44:02 <lambdabot>  Defined.
19:44:02 <mmorrow> afd8: check out the tut first: http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/hmatrix.pdf
19:44:04 <afd8> and rather have it pure haskell
19:44:07 <adu> > map fromJust $ filter isJust $ (map (ensure (>3)) [1..5] :: [Maybe Int])
19:44:07 <lambdabot> Title: A simple scientific library for Haskell
19:44:10 <lambdabot>   [4,5]
19:44:12 <afd8> mmorrow: thanks ill check it out
19:44:21 <mmorrow> afd8: good luck
19:44:26 <dmwit> adu: Also: map fromJust . filter isJust === catMaybes
19:44:36 <adu> dmwit: isee
19:44:54 <lispy> catMaybe is pretty handy
19:45:54 <mmorrow> concatMap (maybe [] id)
19:46:03 <mmorrow> err
19:46:09 <mmorrow> concatMap (maybe [] (:[]))
19:46:54 <dmwit> I like the catMaybes xs = [x | Just x <- xs] definition better.
19:47:06 <dmwit> ...even though it uses fail.
19:47:11 <mmorrow> list comprehensions are nice
19:49:23 <mmorrow> (maybe [] return =<<)
19:49:30 <mmorrow> > (maybe [] return =<<) [Just 4,Nothing,Just 8]
19:49:34 <lambdabot>  Terminated
19:49:36 <mmorrow> > (maybe [] return =<<) [Just 4,Nothing,Just 8]
19:49:41 <lambdabot>   [4,8]
19:49:46 <qwr> adu: webpage?
19:50:02 <adu> qwr: o i almost forgot: http://tetration.itgo.com/up/index.html
19:50:03 <lambdabot> Title: The Droscript Specification
19:50:16 <qwr> ok, thx :)
19:50:17 <mmorrow> > (maybe mzero return =<<) [Just 4,Nothing,Just 8]
19:50:20 <lambdabot>   [4,8]
19:52:58 <MarcWeber> #seen Saizan
19:53:07 <MarcWeber> @seen Saizan
19:53:08 <lambdabot> I saw Saizan leaving #haskell.it, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell and #darcs 1d 10h 37m 5s ago, and .
19:58:33 <mmorrow> > ppp $ expand (.|.) (.&.) [(1,1),(1,0)] [(1::Int,0::Int)]
19:58:36 <lambdabot>   mueval: Prelude.read: no parse
19:58:56 <mmorrow> > (1::Int) .|. 1
19:59:01 <lambdabot>   1
19:59:03 <mmorrow> > ppp $ expand (.|.) (.&.) [(1,1),(1,0)] [(1::Int,0::Int)]
19:59:07 <lambdabot>   mueval: Prelude.read: no parse
19:59:33 <chessguy> > take (0-1) [1..]
19:59:36 <lambdabot>   []
19:59:53 <chessguy> > take (negate 8) [1..]
19:59:56 <lambdabot>   []
20:00:55 <dons> http://www.reddit.com/r/programming/comments/6zc95/haskellorg_gets_an_opensparc_t2/
20:01:00 <lambdabot> Title: Haskell.org gets an OpenSPARC T2 : programming, http://tinyurl.com/5pakhh
20:01:37 <adu> qwr: and if you've read that page, and still understand it, then "() = ifType () (,) (;)" :)
20:02:52 <adu> qwr: that way you can emulate "() :: ()" in a weird sort of way...
20:04:26 <dons> another interesting one, http://www.reddit.com/r/programming/comments/6zc9n/a_stream_of_primes_is_a_comonad/
20:04:28 <lambdabot> Title: A stream of primes is a co-monad : programming, http://tinyurl.com/686x64
20:12:00 <chessguy> @src Eq
20:12:00 <lambdabot> class  Eq a  where
20:12:00 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:12:36 <TomMD> dons: I've added a couple examples to the multicore (forkIO and MVar).  Not sure how understandable they are for anyone else.  I'll likely get around to STM and Channels another day.
20:14:23 <adu> qwr: anyways, I would love any feedback...
20:14:43 <chessguy> @type any
20:14:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:16:50 <sw17ch> is there a "here's what's different in Parsec 3" article/paper out there somewhere?
20:16:59 <dons> TomMD: sweet.
20:17:06 <dons> sw17ch: talk to ddarius
20:17:11 <dons> generality.
20:17:36 <sw17ch> ?seen ddarius
20:17:37 <lambdabot> I saw ddarius leaving #haskell-blah, #haskell-overflow and #haskell 1h 24m 15s ago, and .
20:23:32 <Olathe> Yay, I think I have Lagrange interpolation :D
20:24:01 <mxc> dons - congrats on finishing
20:24:05 <mxc> rwh
20:24:29 <Olathe> > let poly ys = sum' $ map (section ys) [0..(length ys - 1)] where section ys n = map (% (foldr (*) 1 $ map (n-) (dropOne n [0..(length ys - 1)]))) $ ([ys !! n] #*#) $ prod' $ map (\x -> [1, -x]) (dropOne n [0..(length ys - 1)]); prod' [a] = a; prod' (a:as) = a #*# prod' as; sum' [a] = a; sum' (a:as) = a #+# sum' as; dropOne n xs = (take n xs) ++ (drop (n + 1) xs) in poly $ map (\x -> 5*x^3 + 3*x + 4) [0..10]
20:24:32 <lambdabot>   [0%1,0%1,0%1,0%1,0%1,0%1,0%1,5%1,0%1,3%1,4%1]
20:24:43 <sw17ch> dear god why
20:24:43 <dons> mxc, cheers.
20:25:54 * sw17ch is trying to convince his wife that the $50 price point isn't that bad
20:26:09 <Olathe> You finished the book ?
20:26:13 <Olathe> Congratulation :D
20:26:14 <roconnor> @go phoa principle
20:26:23 <lambdabot> http://www.monad.me.uk/ASD/foufct/phoa.html
20:26:23 <lambdabot> Title: Topology using the Phoa principle
20:27:04 <roconnor> anyone understand the Phoa principle?
20:48:51 <roconnor> oh neat, open sets are closed under infinite joins because the natural numbers are overt.
20:49:25 <roconnor> but open sets are not closed under infinite meets because the natural numbers are not compact.
20:51:43 <rwbarton_> overt?
20:52:51 <roconnor> good question
20:53:05 <roconnor> overt is some sort of dual to compactness that I don't really understand yet
20:53:21 <roconnor> currently I imagine it as a non-empty open set.
20:53:36 <rwbarton_> Well, the Pontryagin dual to "compact" is "discrete"
20:54:03 <roconnor> hmm
20:54:25 <roconnor> In this paper discrete and Hausdorff seem to be dual
20:55:16 <roconnor> overtness is a term from locale theory (or formal topology)
20:56:46 * roconnor is reading about Abstract Stone Duality
21:01:08 <rwbarton_> What is an algebra for the monad {0,1}^({0,1}^-) on Set?
21:14:28 <mmorrow> @let greek = let a = "αβγδεζηθικλμνξοπρςστυφχψω" in \i -> [a !! (i`mod`length a)]
21:14:32 <lambdabot>  Defined.
21:15:07 <mmorrow> > greek 9
21:15:12 <lambdabot>   "\954"
21:17:44 <dmwit> > [9,13,15] >>= greek
21:17:47 <lambdabot>   "\954\958\960"
21:17:50 <dmwit> :t say
21:17:52 <lambdabot> [Char] -> Expr
21:18:01 <dmwit> > say $ [9,13,15] >>= greek
21:18:06 <lambdabot>  Terminated
21:18:10 <dmwit> whee!
21:19:03 <mmorrow> oh sweet, say is still efined
21:19:19 <mmorrow> > say (greek 9)
21:19:22 <lambdabot>   κ
21:19:25 <mmorrow> > say (greek 10)
21:19:28 <lambdabot>   λ
21:19:47 <dmwit> > say ([14,9] >>= greek)
21:19:51 <lambdabot>  Terminated
21:19:56 <dmwit> wut
21:20:03 <dmwit> wut
21:20:06 <dmwit> > say ([14,9] >>= greek)
21:20:06 <mmorrow> hmm
21:20:09 <lambdabot>   οκ
21:20:12 <mmorrow> hah
21:20:14 <dmwit> \o/
21:21:12 <dmwit> > say ([13,15,9,4] >>= greek)
21:21:16 <lambdabot>   ξπκε
21:21:23 <dmwit> whoops
21:21:45 <dmwit> > say ([12,14,8,4] >>= greek)
21:21:49 <lambdabot>   νοιε
21:21:58 * dmwit sighs
21:22:10 <dmwit> I can't even express my "love" for #haskell properly.
21:25:26 <mmorrow> @let sup = \i -> ["\8304\185\178\179\8308\8309\8310\8311\8312\8313"!!i]
21:25:29 <lambdabot>  Defined.
21:25:32 <mmorrow> @let sub = \i -> ["\8320\8321\8322\8323\8324\8325\8326\8327\8328\8329"!!i]
21:25:35 <lambdabot>  Defined.
21:25:36 <mmorrow> > say (greek 11 ++ sup 7)
21:25:40 <lambdabot>   μ⁷
21:25:41 <mmorrow> !!
21:26:02 <mmorrow> > say (greek 11 ++ sup 7 ++ concatMap sub [2,4])
21:26:06 <lambdabot>   μ⁷₂₄
21:31:58 <Olathe> > sayFunc $ scanl (+) 0 $ map (^2) [1..10]
21:32:03 <lambdabot>   map (\x -> (2*x^3 + 3*x^2 + x)/6) [0..10]
21:32:21 <Olathe> > sayFunc $ scanl (+) 0 $ [1..10]
21:32:24 <lambdabot>   map (\x -> (x^2 + x)/2) [0..10]
21:33:11 <mmorrow> @type sayFunc
21:33:13 <lambdabot> [Int] -> Expr
21:33:30 <Olathe> It uses Lagrange polynomial interpolation.
21:34:14 <mmorrow> oh, hah, i was like "wheretf are the x's coming from"
21:34:21 <Olathe> Heheh
21:34:43 <mmorrow> > sayFunc [1]
21:34:46 <lambdabot>   mueval: Prelude.read: no parse
21:34:46 <lambdabot>  mueval: map (\x -> *** Exception: <local>:1...
21:35:12 <mmorrow> > sayFunc [0]
21:35:15 <lambdabot>   mueval: Prelude.read: no parse
21:35:16 <lambdabot>  mueval: map (\x -> *** Exception: <local>:1...
21:35:17 <mmorrow> > sayFunc [0,1]
21:35:20 <lambdabot>   map (\x -> x) [0..1]
21:35:31 <mmorrow> > sayFunc [0,1,2]
21:35:34 <Olathe> Hmm...
21:35:34 <lambdabot>   map (\x -> x) [0..2]
21:35:45 <mmorrow> > sayFunc [0,1,3]
21:35:49 <lambdabot>   map (\x -> (x^2 + x)/2) [0..2]
21:35:57 <mmorrow> > sayFunc [0,1,5]
21:36:01 <lambdabot>   map (\x -> (3*x^2 + (-1)*x)/2) [0..2]
21:36:12 <mmorrow> > sayFunc [0,1,9]
21:36:15 <lambdabot>   map (\x -> (7*x^2 + (-5)*x)/2) [0..2]
21:36:18 <mmorrow> :)
21:36:36 <mmorrow> that's cool
21:36:44 <Olathe> Thanks :)
21:36:56 <Olathe> Well, time for some needed sleep.
21:37:33 <mmorrow> night
21:37:42 <Olathe> Good night.
21:46:35 <lasts> @pl \x y z -> (x + y) * z
21:46:36 <lambdabot> ((*) .) . (+)
21:49:04 <mmorrow> @pl \x y z -> (x * y) + z
21:49:05 <lambdabot> ((+) .) . (*)
21:49:18 <mmorrow> @pl \x y z -> x * (y + z)
21:49:19 <lambdabot> (. (+)) . (.) . (*)
21:49:47 <mmorrow> @pl \x y z -> z * (x + y)
21:49:48 <lambdabot> ((*) .) . (+)
21:50:19 <mmorrow> @type (*) . (. (+))
21:50:21 <lambdabot> forall c a. (Num a, Num (a -> c)) => ((a -> a) -> c) -> (a -> c) -> a -> c
21:50:49 <hackage> Uploaded to hackage: zip-archive 0.1
21:53:25 <lasts> @pl \x y z a -> ((x + y) * z) - a
21:53:26 <lambdabot> ((((-) .) . (*)) .) . (+)
21:55:02 <aryapandiya> hello
21:57:47 <abbe> hola aryapandiya
21:57:59 <aryapandiya> sup abbe
21:58:29 <aryapandiya> i'm a newbie to haskell community, looking for some opensource projects
22:00:36 <abbe> aryapandiya, okay. do you know haskell ? if not, then check out YAHT, a supercool Haskell tutorial :)
22:00:57 <aryapandiya> i am learning the basics of haskell now
22:01:23 <aryapandiya> i have downloaded YAHT
22:02:03 <aryapandiya> just read few pages of it
22:02:09 <abbe> all the best with haskell :)
22:02:18 <aryapandiya> thanks
22:02:28 <Twey> aryapandiya: I suggest RWH
22:02:29 <abbe> while learning it, you might like to try out xmonad, the tiling wm written in haskell
22:02:37 <Twey> http://book.realworldhaskell.org/beta/
22:02:43 <lambdabot> Title: Real World Haskell
22:02:50 <aryapandiya> ok
22:02:58 <Twey> YAHT wasn't so helpful for me, but RWH is generally agreed to be amazing
22:03:47 <aryapandiya> RWH is good, and i'll start with that too
22:05:19 <Twey> aryapandiya: Notably, Pugs (one of the principle implementations of Perl6) is written in Haskell
22:05:36 <Twey> A few games
22:05:50 <Twey> GHC itself
22:06:00 * abbe wonders if their is any haskell implementation in perl6
22:06:01 <Twey> Oh, and Yi
22:06:04 <abbe> s/6$//
22:06:11 <Twey> aryapandiya: http://www.haskell.org/haskellwiki/Applications
22:06:13 <lambdabot> Title: Haskell in practice - HaskellWiki
22:06:48 <aryapandiya> is there any projects that i can get into
22:07:52 <aryapandiya> learrning books doesn't mean anything as long as i can't implement anything
22:08:10 <Twey> It's mostly open-source, once you've got a working knowledge of Haskell I'm sure you can get into any of them
22:08:21 <Twey> Yi is particularly active at the moment
22:08:30 <aryapandiya> ok
22:08:44 <eyeris> While learning FP, esp Haskell, how can I know if I am having trouble with a given task because I'm not well practiced with FP versus FP simply being poorly suited for the problem at hand?
22:08:58 <eyeris> Is there a list of questions I can ask myself about the problem, etc?
22:09:26 <Adamant> RWH is the new standard IMO
22:10:00 <Adamant> I'm not done reading it but it seems as good as PCL is for Common Lisp, which is pretty impressive
22:10:03 * Twey nods.
22:10:52 <Twey> eyeris: The answer is the former :)
22:11:46 <Twey> FP being 'poorly suited' for a particular problem means that the problem may involve slightly more code than in an imperative language, in the same manner that imperative programming requires more code for a lot of problems
22:12:03 <Twey> You shouldn't have actual difficulties so long as you have an adequate grasp of the techniques
22:13:55 <eyeris> I suppose that makes some sense.
22:16:14 <moosen> hello
22:16:22 * Twey waves hello to moosen.
22:25:04 <mxc> interesting that "customers who bought real world haskell also bought" includes Cocoa Programming for the Mac by Hillegass
22:25:18 <dons> eyeris: unless you're doing a particular algorithm for which no purely functional design is yet known, then its likely to be just you ;)
22:25:42 <dons> mxc, huh.
22:26:33 <mxc> apparently, amazon thinks there's a lot of customer overlap between RWH and cocoa (apple's api) coding
22:26:34 <dons> also 'Javascript: the good parts'
22:26:44 <mxc> which, doesn't really surprise me, but still interesting
22:27:06 <dons> wow, the 'customers also bought' links is pretty interesting.
22:27:12 <cjs> eyeris: The learning curve is steep, compared to, say, going from C++ to Java, though. I would expect that three months after you start you'll still be dealing with, "I'm programming this badly" moderately often.
22:27:18 <dons> "High Performance MySQL"
22:27:33 <joed> Oxymorons!
22:27:34 <mxc> eyeris - there is also hte posibility that the FP language you're using jsut doesn't have library support for something
22:29:48 <Stinger_> apparently people who buy real world haskell also buy some weird novel called anathem
22:30:20 <dons> heh.
22:30:28 <dons> that's been a recommended bundle for weeks now.
22:31:46 <Stinger_> So the version on the website, that gets updated via a script regularly?
22:32:03 <dons> btw, we hear the book will also be available via (a cheaper) .pdf
22:32:07 <dons> Stinger_: yeah
22:32:07 <Stinger_> for varying values of regularly?
22:32:09 <eyeris> mxc yeah, I have been flirting with Haskell for a while. I like the functional parts of C#
22:32:31 <Stinger_> well one of your things is broken in the database chapter
22:32:50 <mxc> eyeris - i think that was MS is doing is kind of interesting, but w/out FPness being a core of the language the syntax is just so ugly and crappy its kind of not worth it
22:32:58 <Stinger_> sqlite module seems to be missing
22:32:59 <mxc> itnerestingly, MSR sponsors a huge amount of haskell dev
22:33:00 <eyeris> but whenever I try to actually do something in Haskell, it ends up looking good and failing to work properly or it looks like crap but somehow works :)
22:34:00 <dons> eyeris: hmm.
22:34:01 <Stinger_> do you have a sense of impending doom? :)
22:34:12 <mxc> eyeris - my experience is that by the time something actually compiles, its much closer to being finished than with C/Java/C#
22:35:19 <eyeris> mxc yeah, by "not working" I mean not working for my purposes
22:35:33 <eyeris> e.g. I tried to mimic the ease of use of the PHP session API
22:35:46 <moosen> mxc, is it a matter of being able to reason mathematically about the program?
22:35:50 <eyeris> My sessions module works, but the API is no where near as nice
22:37:01 <eyeris> whereas I can design an API that's easier to use, but then I screw up the module and I start dropping useful information on the floor
22:39:21 <dons> eyeris: hmm. so practice i guess.
22:39:29 <dons> since you're still finding your way with the type structure
22:39:41 <dons> and how/when to exploit different aspects of the language
22:40:15 <eyeris> dons Yeah, what I need to do is drop C# and python for a few months and just use a functional language exclusively for a while
22:40:31 <eyeris> unfortunately that doesn't pay the bills in my current situation :)
22:42:58 <moosen> eyeris, how long have you been working with haskell?
22:43:08 <eyeris> On and off for about a year
22:43:11 <dons> you can't slip a few zippy haskell scripts in instead of python?
22:43:29 <eyeris> I've never written much more than 100 or 200 lines in a program though
22:43:48 <dons> maybe hack some open source stuff on the weekends ?
22:43:52 <eyeris> dons perhaps :)
22:44:34 <mxc> work on yi
22:44:49 <mxc> i'd love for that to approach feature parity w/ vim
22:44:50 <eyeris> I can't even get Yi to compile
22:44:55 <mxc> yeah, took me a while too
22:45:02 <mxc> use the cabal-install version
22:45:15 <eyeris> mostly because of package dependency problems on debian/unstable
22:45:28 <mxc> ah
22:45:32 <RayNbow> @bot
22:45:32 <lambdabot> :)
22:45:35 <cjs> So I've got a question about threads and lazy evaluation in Haskell.
22:45:39 <mxc> unfortunately the darwinports package is mucked up
22:45:50 <dons> eyeris: oh, gotta use cabal-install.
22:45:53 <dons> cjs: shoot.
22:45:57 <mxc> cjs - i'd like to tell you i have an answer, but thats quite unlikely
22:45:59 <mxc> will try though
22:46:08 <mxc> moosen - what do you mean?
22:46:46 <eyeris> Yeah, I plan to get setup a virtualized Slackware install and set that up as my haskell dev environment
22:46:52 <cjs> Actually, we may have been through this before, but I'd like to confirm my understanding of it. Say I've got three processes, and a channel. One process reads messages from the network or whatever, calls a parser on them that parses them into a standard format internal to my application, and then shoots them in the channel.
22:47:12 <cjs> If it doesn't actually use any of this parsed data, very little processing is done, and a thunk goes into the channel, right?
22:47:16 <mxc> moosen - i just mean that static typing, nonmutability, no partial functions, and exhaustive pattern matching elimiante a HUGE class of runtime errors
22:47:46 <eyeris> Thanks guys, good night!
22:47:56 <moosen> mxc, I recently read a paper about the fold function and a few related mathematical principles that allow you to reason about recursion without having to do inductive proofs
22:48:03 <quicksilver> cjs: correct.
22:48:11 <mxc> moosen - in a lot of cases thats true
22:48:18 <RayNbow> > (succ,pred) `apT` (1,2)
22:48:21 <lambdabot>   (2,1)
22:48:25 <quicksilver> cjs: you quite often want to force evalutation before putting stuff in MVars/Chans
22:48:36 <quicksilver> cjs: otherwise the work gets done in the wrong thread.
22:48:40 <mxc> moosen with fold you only need a well typed function and at least you're ensured that if your function is correct and terminating the fold will be too
22:48:44 <cjs> The other two processes each have a a dup of this other end of the channel. So when receiver 1 (we'll call him R1), starts digging into the header, to say, get the internal protocol message type, it's actually going to do the computational work to parse the header, then.
22:48:53 <dmwit> > (succ *** pred) (1, 2)
22:48:56 <lambdabot>   mueval: Prelude.read: no parse
22:49:11 <dmwit> > succ *** pred $ (1, 2)
22:49:15 <lambdabot>   mueval: Prelude.read: no parse
22:49:18 <dmwit> lambdabot--
22:49:32 <mxc> (***) succ pred $ (1,2)
22:49:34 <cjs> quicksilver: actually this is probably a good thing. So R1 decides to ignore the rest of the message, because it has no interest in it, so it just did the header parsing work and that's it.
22:49:36 <mxc> > (***) succ pred $ (1,2)
22:49:39 <lambdabot>   mueval: Prelude.read: no parse
22:49:44 <dmwit> :t (***)
22:49:44 <RayNbow> http://hpaste.org/9986#a2
22:49:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:49:57 <mxc> > succ (***) pred $ (1,2)
22:49:58 <dmwit> Okay, at least it's not a ?let that's screwing us up.
22:49:59 <lambdabot>   Couldn't match expected type `(->)' against inferred type `(,)'
22:50:07 <dmwit> > (***) succ pred (1, 2)
22:50:07 <cjs> Now, when the R2 thread later runs, and looks into the header, it uses the stuff parsed by R1, right? because that thunk's been evaluated?
22:50:09 <dmwit> > (1, 2)
22:50:09 <mxc> > (succ (***) pred) $ (1,2)
22:50:09 <sjanssen> dmwit: it's missing that import
22:50:12 <lambdabot>   mueval: Prelude.read: no parse
22:50:13 <lambdabot>  Terminated
22:50:13 <lambdabot>   Couldn't match expected type `(->)' against inferred type `(,)'
22:50:28 <sjanssen> cjs: the answer is "probably"
22:50:53 <cjs> sjanssen: under what circumstances would this not happen?
22:50:58 <sjanssen> cjs: if R1 and R2 attempt to evaluate the data simulatenously, there is a chance that the thunk could be computed twice
22:51:04 <cjs> Ah, I see.
22:51:20 <dmwit> I thought GHC had clever code to prevent that.
22:51:26 <cjs> But this of course could only happen if you've got threads running on multiple cores.
22:51:31 <dmwit> ...or aren't we talking about GHC...
22:51:37 <sjanssen> dmwit: in most cases, but it isn't a guarantee
22:51:44 <cjs> dmwit: I am talking about GHC.
22:51:47 <rwbarton_> It seems even cleverer to make it not be a problem
22:52:02 <cjs> I can live with "most cases," just so long as it's not happening on a regular basis on a multi-core system.
22:52:33 <cjs> Assume I've got a half dozen or so threads doing various things on a two-core system, many of which are always ready to run (i.e., this application is CPU-bound).
22:54:23 * RayNbow needs a sanity check
22:54:47 <RayNbow> (...I created a Haskell program that outputs XML manually... :p)
22:55:02 <cjs> Anyway, so when R2 looks at the header, and then decides it wants stuff from the body, and invokes the accessors for that, it will do the work of parsing the body, right?
22:55:17 <cjs> Well, obviously, if the thunk went through the channel and it's the first to evaluate it.
22:55:18 <joed> Awesome, as whe already hated XML.
22:55:44 <cjs> But if it looks at just the header, and also decides it's not interested in the body, now everybody's thrown the message away, and we never parsed the body at all, right?
22:55:54 <cjs> In other words, free CPU time! Yay!
22:57:24 <cjs> So, question: is GHC really clever enough to always avoid evaluating a thunk twice on a multi-core system? In other words, sjanssen, is your "no guarantee" referring to Haskell in general, or also to GHC (or some versions of it) in particular?
22:59:26 <sjanssen> cjs: to GHC specifically
22:59:59 <cjs> Hmm. Ok. Any thoughts on how one might find out how often this is happening?
23:00:00 <sjanssen> cjs: one of the GHC papers describes in more detail, I think it was "Haskell on a shared memory multi-processor"
23:00:41 <sjanssen> cjs: and Haskell in general has no guarantees about sharing
23:02:55 <mmorrow> > say (greek 10)
23:02:58 <lambdabot>   λ
23:03:36 <dons> noice.
23:03:39 <mmorrow> > say (greek 10 ++ sup 2)
23:03:41 <RayNbow> > say $ greek 1
23:03:45 <lambdabot>   λ²
23:03:45 <lambdabot>  Terminated
23:03:49 <dons> cjs, i'd imagine it is rare?
23:03:58 <dons> cjs, but you can use threading + profiling in the latest ghc's
23:04:02 <dons> so that wouuld be a start.
23:04:16 <mmorrow> > say (greek 1)
23:04:19 <lambdabot>   β
23:04:32 <mmorrow> > say (greek (negate 1))
23:04:36 <lambdabot>   ω
23:05:09 <Deewiant> > map greek [0..]
23:05:13 <lambdabot>   ["\945","\946","\947","\948","\949","\950","\951","\952","\953","\954","\95...
23:05:23 <dmwit> > say $ [0..] >>= greek
23:05:23 <TSC> > map (say . greek) [0..]
23:05:28 <lambdabot>   [α,β,γ,δ,ε,ζ,η,θ,ι,κ,λ,μ,ν,ξ,ο,π,ρ,ς,σ,τ,υ,φ,χ,ψ,ω...
23:05:29 <lambdabot>  Terminated
23:05:49 <Deewiant> > map (say.greek) [50..]
23:05:52 <lambdabot>   [α,β,γ,δ,ε,ζ,η,θ,ι,κ,λ,μ,ν,ξ,ο,π,ρ,ς,σ,τ,υ,φ,χ,ψ,ω...
23:06:00 <Deewiant> heh
23:06:09 <dmwit> It's the same, no matter where you start! ;-)
23:06:10 <Twey> greek = ('α' +) ?
23:06:16 <Twey> Ehhh
23:06:17 <mmorrow> > say (concatMap greek [0..])
23:06:18 <cjs> dons: profiling will help me figure it out?
23:06:18 <Deewiant> not quite
23:06:19 <dmwit> Twey: kind of
23:06:21 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψωαβγδεζηθικλμ...
23:06:29 <Deewiant> ew
23:06:37 <mmorrow> weird
23:06:41 <dmwit> > say . take 20 . concatMap greek $ [0..]
23:06:44 <lambdabot>   αβγδεζηθικλμνξοπρςστ
23:06:44 <dons> cjs, if two thunks update the same thing, probably not.
23:06:49 <dmwit> > say . take 40 . concatMap greek $ [0..]
23:06:53 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψωαβγδεζηθικλμ...
23:06:53 <cjs> dons: I would think it would just show me how much time I'm spending doing the parsing in total, more or less. Oh, wait, it gives me callers....
23:07:05 <mmorrow> ahh, a utf8 char must be getting chopped by lb ...
23:07:09 <dmwit> right
23:07:18 <Deewiant> doesn't explain why the whole thing breaks, though
23:07:24 <sjanssen> cjs: it isn't supposed to happen very often
23:07:37 <dmwit> Deewiant: Your client drops to another encoding for your convenience.
23:07:40 <cjs> sjanssen: Ok. So long as it doesn't, at least on CPU-bound systems, I'm fine with it.
23:08:01 <cjs> In my application, there's not much else running on the machine, so the only thing it would be starving would be itself.
23:08:08 <mmorrow> @let greekAlpha = "αβγδεζηθικλμνξοπρςστυφχψω"
23:08:09 <sjanssen> cjs: CPU bound doesn't really have anything to do with it
23:08:11 <Deewiant> dmwit: hmph, that sucks
23:08:11 <lambdabot>  Defined.
23:08:15 <cjs> Which you'd think would be more unlikely if you've got lots of stuff ready to run.
23:08:24 <mmorrow> > length greekAlpha
23:08:28 <lambdabot>   25
23:08:29 <sjanssen> the problem is if your two evaluators are running in lockstep
23:08:51 <cjs> Well, if you have only the two threads, it seems to me more likely that they'd both be running at the same time, and thus more likely both to evaluate the thunk at the same time, right?
23:09:09 <cjs> I mean, if they're both sitting there waiting on the channel....
23:09:10 <mmorrow> > say . take (length greekAlpha - 1) . concatMap greek $ [0..]
23:09:13 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψ
23:09:14 <mmorrow> gah
23:09:19 <mmorrow> > say . take (length greekAlpha) . concatMap greek $ [0..]
23:09:22 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψω
23:09:34 <Deewiant> > say greekAlpha
23:09:38 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψω
23:09:57 <cjs> Anyway, quicksilver, this is a good reason *not* to force evaluation early; I may have a reasonable number of cases where I don't actually need to parse everything in a message I receive.
23:10:25 <RayNbow> > pronounce greekAlpha
23:10:28 <lambdabot>   mueval: Prelude.read: no parse
23:13:18 <mmorrow> > say . concat . zipWith (:) greekAlpha . fmap sup $ [0..9]
23:13:22 <lambdabot>   α⁰β¹γ²δ³ε⁴ζ⁵η⁶θ⁷ι⁸κ⁹
23:13:42 <mmorrow> > say . concat . zipWith (:) (reverse greekAlpha) . fmap sub $ [0..9]
23:13:46 <lambdabot>   ω₀ψ₁χ₂φ₃υ₄τ₅σ₆ς₇ρ₈π₉
23:18:26 <quicksilver> cjs: absolutely.
23:20:11 <moosen> hmm, in ghci writing    let fib n = if n <= 2 then 1 else fib (n-1) + fib (n-2)    defines the fibonacci sequence using binary recursion. That algorithm has an exponential running time and doesn't seem to be able to finish on my computer for n ~ 50, but I understand that it's possible to memoize this algorithm and make it run in linear time (I'm not sure about the exactly though)
23:21:34 <mmorrow> moosen: you can do a non-recursive algo, which is faster
23:23:08 <mmorrow> > let fib m n = m : fib n (m+n) in fib 1 1
23:23:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:23:23 <mmorrow> > (let fib m n = m : fib n (m+n) in fib 1 1) !! 50
23:23:26 <lambdabot>   20365011074
23:23:33 <mmorrow> > (let fib m n = m : fib n (m+n) in fib 1 1) !! 1000
23:23:36 <lambdabot>   703303677114228158218352548771835497701812698363587327426049050871545371181...
23:24:04 <moosen> that is an infinite list?
23:24:09 <mmorrow> yes
23:24:36 <mmorrow> if you want zero at the front ...
23:24:41 <mmorrow> > let fib m n = m : fib n (m+n) in 0 : fib 1 1
23:24:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:25:03 <moosen> very nice
23:25:22 <mmorrow> haskell rulz!
23:25:32 <Deewiant> > fix $ (0:) . scanl (+) 1
23:25:36 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:25:43 <mmorrow> my favorite fib
23:27:00 <mmorrow> moosen: fix ((0:) . scanl (+1) 1) uses the same algo as the one above, just slightly less directly
23:27:12 <moosen> I know  fib n = fib2 1 1 n where fib2 a b c = if c <= 2 then a else fib2 b (a+b) (c-1)     or somesuch
23:27:39 <moosen> which is simple recursion like those algos, I believe
23:27:42 <mmorrow> ok, so that one is top-down. the above two are bottom-up
23:28:58 <mmorrow> they carry the last two values with them at all times, and at every step, dump one of those, shift the other to position two, calc the new position one's value, and jump to themselves with those new args
23:29:07 <moosen> hmm, s/ then a/ then b
23:29:41 <moosen> yeah, I like those
23:29:46 <mmorrow> me too :)
23:34:02 <winter> That fib example given earlier causes a HUGS seg fault on my machine for large numbers
23:34:02 <RayNbow> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs  in   fibs
23:34:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:34:26 <winter> > (let fib m n = m : fib n (m+n) in fib 1 1) !! 100000
23:34:38 <lambdabot>   420269270299515438631900510129391513177391570263223450330471608719833573145...
23:34:55 <winter> The result for me on that is "Segmentation fault"
23:35:03 <mmorrow> winter: hmm, maybe a HUGS infinite-precision-integer bug
23:35:14 <winter> for smaller vals its ok
23:35:17 <dons> hugs doesn't use libgmp.
23:35:26 <dons> so it has some funky differences with ghc
23:35:44 <mmorrow> but it does have an "equivalent" of Integer?
23:36:12 * RayNbow once computed the millionth Fibonacci number (where 0 was considered to be the first number)...
23:36:31 <RayNbow> most of the time was spent in converting it to a string and printing it :p
23:37:10 <mmorrow> > const () $ (let fib !m !n = m : fib n (m+n) in 0 : fib 1 1) !! 1000000
23:37:13 <lambdabot>   mueval: Prelude.read: no parse
23:37:24 <mmorrow> > const () ((let fib m n = m : fib n (m+n) in 0 : fib 1 1) !! 1000000)
23:37:27 <lambdabot>   ()
23:37:31 <mmorrow> leet
23:37:53 <mmorrow> > let a = ((let fib m n = m : fib n (m+n) in 0 : fib 1 1) !! 1000000) in a `seq` ()
23:38:00 <lambdabot>   mueval: Prelude.read: no parse
23:38:00 <lambdabot>  mueval: *** Exception: stack overflow
23:38:05 <mmorrow> crap
23:38:32 <RayNbow> you have to force evaluation of each element in the list
23:38:41 <mmorrow> > let a = ((let fib m n = let n' = m+n in m `seq` n' `seq` m : fib n n' in 0 : fib 1 1) !! 1000000) in a `seq` ()
23:38:44 <RayNbow> @src rnf
23:38:45 <lambdabot> Source not found. I am sorry.
23:38:57 <lambdabot>   thread killed
23:39:00 <RayNbow> @hoogle rnf
23:39:00 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
23:39:02 <mmorrow> > let a = ((let fib m n = let n' = m+n in m `seq` n' `seq` m : fib n n' in 0 : fib 1 1) !! 100000) in a `seq` ()
23:39:10 <lambdabot>   ()
23:39:24 <mmorrow> (that was 100,000 not 1million)
23:40:16 <RayNbow> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs; let fibs' = take 10000 fibs    in    seq (rnf fs) (last fs)
23:40:19 <lambdabot>   mueval: Prelude.read: no parse
23:40:29 <RayNbow> oh right
23:40:38 <RayNbow> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs; let fibs' = take 10000 fibs    in    seq (rnf fibs') (last fibs')
23:40:41 <lambdabot>   mueval: Prelude.read: no parse
23:42:17 <moosen> Let M be the matrix  [[1,1],[1,0]]. Then M^n = [[F n, F n-1],[F n-1, F n-2]], where F n is the nth fibonacci number.
23:42:42 <moosen> Which is neat because matrix exponentiation can be done in logarithmic time
23:42:51 <mmorrow> @let a +! b = a `seq` b `seq` a + b
23:42:55 <lambdabot>  Defined.
23:43:09 <mmorrow> @let a *! b = a `seq` b `seq` a * b
23:43:13 <lambdabot>  Defined.
23:45:08 <mmorrow> > ((let fib m n = m : fib n (m +! n) in 0 : fib 1 1) !! 100000) `seq` ()
23:45:23 <lambdabot>   thread killed
23:45:51 <RayNbow> you need to make indexing strict
23:45:56 <mmorrow> > ((let fib m n = let n' = m +! n in n' `seq` m : fib n n' in 0 : fib 1 1) !! 100000) `seq` ()
23:46:01 <RayNbow> or wait
23:46:09 <mmorrow> i think that might work
23:46:16 <lambdabot>   mueval: Prelude.read: no parse
23:46:21 <mmorrow> hmm
23:47:03 <mmorrow> > (0 + 2) +! 3
23:47:09 <RayNbow> http://raynbow.pastebin.com/f47aca4cb <-- this is some old code
23:47:10 <lambdabot>   5
23:47:15 * mmorrow looks
23:47:18 <RayNbow> where I tried different seq stuff
23:48:29 <mmorrow> @let seqList xs = case xs of [] -> [] ; x:xs -> x `seq` x : seqList xs
23:48:32 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
23:48:39 <mmorrow> @type seqList
23:48:41 <lambdabot> forall a. Strategy a -> [a] -> Done
23:48:44 <mmorrow> oh
23:48:53 <mmorrow> @type rnf
23:48:56 <lambdabot> forall a. (NFData a) => a -> Done
23:52:41 <mmorrow> @let xs !!! i = let go _ _ [] = error "qwertyuiop" ; go n i (x:xs) | i==n = x | otherwise = x `seq` go (n+1) i xs in go 0 i xs
23:52:45 <lambdabot>  Defined.
23:52:54 <mmorrow> > [0..9] !!! 7
23:52:58 <lambdabot>   7
23:53:15 <mmorrow> uh
23:53:18 <mmorrow> > [0..9] !!! 0
23:53:21 <lambdabot>   0
23:53:52 <mmorrow> > ((let fib m n = let n' = m +! n in n' `seq` m : fib n n' in 0 : fib 1 1) !!! 100000) `seq` ()
23:54:05 <lambdabot>   mueval: Prelude.read: no parse
23:54:27 <mmorrow> (this of course wouldn't be needed if we had more than 3 seconds)
23:56:03 <mmorrow> err, that's not the reason
23:56:25 * mmorrow ninja-vanishes
