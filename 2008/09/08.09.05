00:00:04 <dons> i wonder if they have things like that for books: recommend it to a java programmer, and get a discount
00:00:22 <dons> ivanm: yeah, quickCheck $ \x -> mytest x == yourtest x
00:00:29 <dons> or something like that.
00:01:09 <ivanm> failed after 1 test! :o
00:02:17 <ivanm> dons: hmmm.... does yours work for [] ?
00:03:15 <thoughtpolice> hm, i wonder what the new quickcheck that will be at defun will come with :]
00:04:09 <ivanm> is there any way to have quickcheck print what it used as its test?
00:04:20 <ivanm> *test data
00:09:15 <quicksilver> ivanm: Yes.
00:09:23 <ivanm> how?
00:09:26 <quicksilver> I don't remember exactly but it's in the haddock.
00:09:28 <quicksilver> verboseCheck is it?
00:09:53 <ivanm> quicksilver: for which version of quickcheck?
00:10:03 <quicksilver> the one which comes with GHC.
00:10:38 <ivanm> hmmm...
00:11:42 <ivanm> OK, how do I specify which version of quickcheck I want to load in ghci if I have 1.1.0.0 and 2.0?
00:13:21 <dons> use -package QuickCheck 1.1.0.0 at the command line
00:13:22 <thoughtpolice> by default it'll pull in 2.0 naturally, but you can do 'ghci --hide-package QuickCheck-2.0.0.0'
00:13:28 <thoughtpolice> or yeah, that too
00:13:39 <dons> yeah
00:13:43 <dons> --hide-package is better
00:13:43 <ivanm> well, I've already loaded ghci...
00:14:36 <ivanm> --hide-package is an unrecognised flag :s
00:15:12 <ivanm> heh... ghci says to use --help, but then complains that you can't you --interactive with --help ;-)
00:24:04 <ivanm> dons: the problem I'm having using quickcheck is that it fails if the two answers differ in the 15th place or something like that
00:24:12 <ivanm> if it's that close, I'd be tempted to say they're equal :s
00:24:22 <dons> ah , so don't use ==
00:24:28 <dons> used a custom =~
00:24:35 <ivanm> *nod*
00:24:49 <dons> e.g. epsilonify x == epsilonify y
00:25:23 <ivanm> actually, from looking at the code, the reason I think that the answers are slightly different is that it works slightly better for numbers that are very large or very different from each other
00:26:29 <ivanm> but in terms of efficiency, it should probably be updated to use something slightly closer to yours (rather than a fold)
00:35:23 <dons> i mean, they can have the same loop body
00:35:31 <dons> but using foldr and a lazy tuple will just be slower.
00:42:03 <dons> btw, for those who didn't see it earlier, this is a rather exciting debut into haskell blogging, http://www.reddit.com/r/programming/comments/6zrep/using_c_from_haskell_a_short_introduction/
00:42:06 <lambdabot> Title: Using C From Haskell: A Short Introduction : programming, http://tinyurl.com/58367y
00:42:15 <dons> clear, sharp intro to the ffi
00:42:26 <Myoma> is it possible to set a heap limit for ghci which will make it give up instead of swamping the computer if you try to compute something like that
00:42:51 <dons> Myoma: you should use the compiler if you care about that kind of stuff :)
00:43:09 <dons> but yes, hang on...
00:44:02 <dons> -Mfoo
00:44:08 <dons> where 'foo' is a maximum heap size
00:44:23 <Myoma> I don't know what value to use
00:44:28 <dons> "Msize
00:44:29 <dons> [Default: unlimited] Set the maximum heap size to size bytes. The heap normally grows and shrinks according to the memory requirements of the program. The only reason for having this option is to stop the heap growing without bound and filling up all the available swap space"
00:44:35 <dons> Myoma: oh, 500M ?
00:44:46 <dons> so, ghci +RTS -M500M -RTS
00:45:29 <dons> $ ghci +RTS -M10M -RTS
00:45:29 <dons> Prelude> 1+2
00:45:29 <dons> 3
00:45:29 <dons> Prelude> product [1..]
00:45:30 <dons> Heap exhausted;
00:45:37 <dons> :)
00:45:45 <Myoma> great!!
00:45:52 <Wild_Cat> something worth reading on reddit? Nonsense.
00:47:08 <dons> fwiw, and this might be moderately OT, i'm twittering all these little haskell tips and tricks http://twitter.com/donsbot
00:47:10 <lambdabot> Title: Twitter / donsbot
00:47:58 <Myoma> export GHCRTS=-M500M
00:48:09 <dons> hopefully i'll be doing live twittering of the ICFP conference too
00:57:14 <BeelsebobWork> dons: I have this... http://hpaste.org/10135 -- which is faster than the current mandelbrot, but only on 4 cores
00:57:17 <Adamant> Twitter seems to be breaking into the tech mainstream more and more, and outside of it
00:57:26 <BeelsebobWork> any extra ideas welcome
00:58:15 <Wild_Cat> Twitter's been popular in tech for quite a while now.
00:58:21 <Myoma> why don't you remove the fromIntegrals
00:58:33 <BeelsebobWork> ... because then it wouldn't type check
00:58:47 <Myoma> by that I don't mean s/fromIntegral//
00:58:56 <Wild_Cat> (I guess it's one of the areas where microblogging makes sense)
00:59:34 <Adamant> Wild_Cat: I tended to see it more on the Web 2.0 types
00:59:38 <sjanssen> Adamant: I've noticed that CNN is using twitter frequently in their broadcasts
00:59:53 <Adamant> that's another sign of mainstreaming
01:00:11 <BeelsebobWork> Myoma: actually, no, that's fine
01:00:15 <BeelsebobWork> I see what you mean
01:01:01 <BeelsebobWork> well, that's another 0.1 seconds gone
01:01:38 <Myoma> how do you view the file?
01:01:51 <BeelsebobWork> the output of the mand generator?  it's in portable bitmap format
01:02:06 <Myoma> it's so portable infact, that I don't have any programs to view it
01:02:07 <BeelsebobWork> so, find a viewer for your platform -- it's not easy
01:02:11 <BeelsebobWork> yeh
01:02:12 <BeelsebobWork> good init
01:02:27 <BeelsebobWork> tbh, it's a stupid format anyway
01:02:31 <BeelsebobWork> so no surprise
01:14:00 <BeelsebobWork> okay, a careful sprinkling of bang patterns, thanks to svorg and removal of fromInts has got it a bit faster
01:14:01 <BeelsebobWork> http://hpaste.org/10135#a2
01:14:28 <dons> BeelsebobWork: might be time to get ghc head, so you can use -thread + -prof
01:14:43 <dons> looks nice though
01:14:46 <BeelsebobWork> oh, does the latest head allow you to combine them?
01:14:47 <dons> i think we can work with that.
01:14:49 <dons> yeah
01:14:55 <BeelsebobWork> dons: warning -- I don't think it's quite right
01:15:00 <BeelsebobWork> but I think it's a floating point precission thing
01:15:13 <BeelsebobWork> it's only 2 bytes that are coming out different between it and the C version
01:15:15 <BeelsebobWork> :/
01:15:22 <BeelsebobWork> I can't figure out for the life of me what it thinks its doing
01:15:22 <dons> -fexcess-precision ?
01:15:26 <BeelsebobWork> same result
01:15:39 <dons> -optc-On messing things up?
01:15:43 <dons> different results with -fasm ?
01:16:28 <BeelsebobWork> no change again
01:16:32 <BeelsebobWork> other than slightly slower
01:20:21 <xci> is that Real World Haskell available in pdf-format already?
01:22:12 <Myoma> Aren't you allowed to exploit symmetry of the mandelbrot?
01:22:20 <BeelsebobWork> nope
01:22:27 <BeelsebobWork> gotta use the same algorithm as the C version
01:22:44 <BeelsebobWork> I wanted to write a sherman contour crawler :(
01:23:34 * BeelsebobWork ponders if the couple of bytes difference is that it's upside down
01:23:39 * BeelsebobWork checks what order the C generates the rows in
01:23:51 <ivanm> dumb question... how can I write a function that does \ n -> 10^(-n)?
01:24:02 <BeelsebobWork> exactly like that
01:24:04 <BeelsebobWork> ?
01:24:12 <quicksilver> (10^) . negate
01:24:17 <ivanm> nope, doesn't seem to work :s
01:24:21 <ivanm> negative exponent error :s
01:24:24 <quicksilver> ah
01:24:26 <quicksilver> you want ^^
01:24:32 <ivanm> ahhh
01:24:32 <quicksilver> ^ doesn't take negative exponents
01:24:40 <ivanm> *nod*
01:24:44 <ivanm> @ty (^^)
01:24:46 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
01:25:44 <xci> yeah, try ^^ or ** instead
01:25:56 <Wild_Cat> otherwise, \n -> 1 / (10^n) -- would work, I guess.
01:26:02 <sjanssen> y'know, if we moved (^) into the Num class, we could avoid this
01:26:11 <quicksilver> (^) is for positive exponent, any base, and preserves the type of its base. ^^ is for integer exponent, any base, and preserves the type of its base.
01:26:25 <quicksilver> ** is for fractional exponent but should really only be used with positive base
01:26:48 <quicksilver> sjanssen: I don't think I'd want (^)'s type to change. I like the separation between (^) (^^) and (**).
01:26:59 <quicksilver> sjanssen: there are other reasons to move it into Num, though.
01:27:05 <quicksilver> Interval arithmetic for one.
01:27:27 <rwbarton> move it into Num how?
01:27:29 <rwbarton> :t (^)
01:27:31 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:27:58 <quicksilver> make it a method, rwbarton
01:29:02 <rwbarton> how would that help interval arithmetic?
01:29:13 <quicksilver> the current (^) uses (*)
01:29:21 <quicksilver> in interval arithmetic that's suboptimal
01:29:27 <quicksilver> [0,1] ^ 2 is [0,1]
01:29:33 <quicksilver> erm, try again ;)
01:29:38 <quicksilver> [-1,1] ^ 2 is [0,1]
01:29:46 <quicksilver> but [-1,1] * [-1,1] is [-1,1]
01:30:05 <quicksilver> so, for interval arithmatic, x^2 is not x*x
01:30:16 <rwbarton> I think that's a failure of interval arithmetic, not the Num typeclass.
01:30:53 <purestorm> Hi. Is it somehow possible to install Haskell packages with one command like apt-get, easy_install or gem?
01:30:55 <rwbarton> i.e. [-1,1] is not a complete description of the number, there is also a notion of the number's "identity"
01:31:24 <Wild_Cat> purestorm: you're looking for cabal-install
01:31:42 <BeelsebobWork> shaved a bit more off by inlining fractal and f
01:33:01 <ivanm> is there a function that rounds a Double to a specified number of digits?
01:33:23 <ivanm> the obvious would be *10^x, round, /10^x, but that doesn't sound too efficient :s
01:33:29 <Myoma> ivanm: That is efficient
01:33:35 <ivanm> Myoma: oh?
01:33:40 <ivanm> not very pretty then :p
01:33:45 <Myoma> it is pretty
01:33:59 <ivanm> heh
01:34:02 <ivanm> fine then, I'll use it
01:34:32 <Myoma> > let places pi n = (% (10^n)) . toInteger . ((10^n) *) in places pi 3
01:34:35 <lambdabot>       Overlapping instances for Show (b -> Ratio Integer)
01:34:35 <lambdabot>        arising from...
01:35:30 <purestorm> Wild_Cat: Awesome, thanks.
01:35:36 <Myoma> > let places n = (% (10^n)) . floor . ((10^n) *) in places 3 pi
01:35:40 <lambdabot>   3141%1000
01:35:57 <quicksilver> rwbarton: eh? No, it's not.
01:36:14 <quicksilver> rwbarton: it's true that to reason about interval arithmetic you need to understand identity. But you don't to use it.
01:36:45 <quicksilver> rwbarton: [-1,1] ^ 2 = [0,1] is an instance of a simple rule.
01:37:05 <quicksilver> of course, you can argue 'Num' isn't designed for interval arithmetic
01:37:07 <quicksilver> and that's fair enough
01:37:20 <quicksilver> but the fact is, Num is actually very close to being perfect for interval arithmetic :)
01:37:28 <quicksilver> (^) is an annoying exception.
01:38:48 <dons> purestorm: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
01:38:50 <lambdabot> Title: CabalInstall - Hackage - Trac
01:39:11 <purestorm> dons: Thanks, but already google'd it and installed my first packgage.
01:39:28 <dons> great :)
01:39:39 <dons> now you can go nuts and install 750 packages from hackkage
01:39:43 <ivanm> lol
01:39:56 <dons> cabal install yeah, hell yeah, everything
01:40:23 <ivanm> dons: OK, after eventually finding an approximation function, I've managed to QC the two, and the results are comparable
01:40:32 <dons> great!
01:41:36 <ivanm> only difference is, yours fails if the list is empty
01:43:46 <dons> did i miss f [] = 0 or something ?
01:43:52 <ivanm> yup
01:44:05 <ivanm> well, you need to have it before going to the "go" inner function...
01:44:14 <ivanm> otherwise you get x / 0
01:44:21 <ivanm> (since the current length of the list is 0)
01:55:02 <ivanm> dons: http://hpaste.org/10136
01:55:24 <ivanm> just running it now, it failed for 13 and 15 digits but that's it
01:56:23 <ivanm> dons: want me to CC the email I'm sending to the author to you?
02:07:10 <ivanm> dons: not sure if this went before since my IRC connection seems to have cut, but do you want me to CC the email I'm sending to the author to you?
02:12:09 --- mode: irc.freenode.net set +o ChanServ
02:18:17 <rwbarton> quicksilver: if f(x) = x^2+x, what is f([-1,1])?
02:20:29 <quicksilver> rwbarton: Right; the rules will get that wrong.
02:20:39 <quicksilver> rwbarton: this is a limitation of IA, indeed.
02:20:55 <quicksilver> rwbarton: although they never produce an inconsistent answer, just a conservative one.
02:21:03 <quicksilver> You can always add new rules to the system, though.
02:21:18 <quicksilver> and you might as get ^ right instead of deferring to * which is too conservative.
02:21:45 <quicksilver> actually, that's [-1,2] and the rules get it right, isn't it?
02:22:04 <quicksilver> ah no, it's wrong indeed as you suggested.
02:30:35 <rwbarton> I guess the more fundamental issue is with the Eq instance :)
02:46:15 <quicksilver> conal: morning.
02:46:26 <quicksilver> conal: I have something of an abstraction gap, but maybe I'm thinking wrong.
02:46:27 <conal> quicksilver: hi there
02:46:50 <quicksilver> conal: we have combinators which let us defint Event (Behaviour a) -> Event a
02:47:03 <quicksilver> a 'discrete sample' of some behaviours
02:47:24 <quicksilver> but it seems hard to generalise that to 'Event (x,Behaviour a) -> Event (x,a)'
02:47:40 <quicksilver> [and other similar transformations]
02:47:59 <conal> quicksilver: what combinators let us define Event (Behaviour a) -> Event a ?
02:49:11 <quicksilver> well switcher :: Event (Behaviour a) -> Behaviour a
02:49:14 <quicksilver> and then snapshot?
02:49:44 <quicksilver> very likely I'm thinking about this all wrong.
02:51:22 <conal> okay, switcher :: Behavior a -> Event (Behavior a) -> Behavior a
02:51:33 <conal> what would you like to define?
02:52:32 <quicksilver> conal: well the point is I can 'evaluate' a behaviour at a given time.
02:52:49 <quicksilver> conal: but I can only do that in a context which has a notion of 'current time'
02:52:58 <quicksilver> conal: such as, inside an Event.
02:53:29 <conal> quicksilver: as in snapshot
02:53:32 <quicksilver> right.
02:53:40 <conal> ok
02:53:42 <quicksilver> but there doesn't seem to be a general way of doing this.
02:54:08 <quicksilver> let me give a concrete example.
02:54:19 <quicksilver> Event (x , x -> Behaviour y)
02:54:34 <quicksilver> I claim I should be able to get an 'Event y' out of that.
02:55:05 <quicksilver> and I think I can write it using the underlying implementation, btu I can't seem to write it using the general combinators.
02:55:49 <guenni> good morning
02:56:41 <conal> quicksilver: oh, okay.  and, fmap (flip ($)) to get Event (Behavior y) and ask the same question of the simpler result
02:58:13 <quicksilver> conal: Hmm. OK that's the wrong example then.
02:58:26 <quicksilver> conal: my real example has a worse problem. Let me think again.
02:59:38 <quicksilver> conal: Ah, I rememmber. Here it is:
02:59:55 <quicksilver> Event (Behaviour (x -> y), x)
03:00:22 <quicksilver> conal: I need to sample the behaviour at each time stamp, to pull the function out, then apply it to the value which is also hanging around.
03:01:08 <quicksilver> but that's OK too, isn't it? because behaviours are functors.
03:01:24 <EvilTerran> i see a great many sqlite bindings
03:01:29 <EvilTerran> how do i know which one i want?
03:01:36 <quicksilver> I can fmap (\(b,x) -> fmap ($x) b)
03:01:41 <Axman6> EvilTerran: you want them all
03:02:16 <quicksilver> conal: I'm actually trying to join piecewise behaviours together, which I suspect is a problem you have already solved.
03:02:23 <EvilTerran> haskelldb-hdbc-sqlite3 haskelldb-hsql-sqlite haskelldb-hsql-sqlite3 HDBC-sqlite3 hsql-sqlite3 hsSqlite3 sqlite
03:02:33 <quicksilver> conal: but I am finding it instructive trying to solve it myself.
03:02:43 <EvilTerran> ^ those are all the hackages with "sqlite" in the name
03:02:50 <conal> quicksilver: if you do that fmap, you won't have sampled the function behavior.  is that okay?
03:03:15 <conal> quicksilver: do you have a bunch of behaviors that you want to switch between?
03:03:22 <quicksilver> conal: well after the double fmap I have Event (Behaviour y)
03:03:34 <conal> quicksilver: yeah
03:03:35 <quicksilver> conal: which I can "pseudo-join" to get Event y.
03:03:53 <conal> quicksilver: can you?
03:04:00 <quicksilver> I claim I can.
03:04:15 <quicksilver> using switcher + snapshot at self.
03:04:21 <conal> quicksilver: yeah.
03:04:50 <Axman6> EvilTerran: i say you want them all so that you can test them out, and then blog about which one is the best in your oppinion. (easiest to use would probably make the greatest difference)
03:04:51 <quicksilver> conal: I have a bunch of behaviours I want to 'connect'.
03:05:04 <quicksilver> conal: the behaviours are parametric so you can specify their initial values.
03:05:18 <quicksilver> conal: I want to set the initial value, at each event, to be the final value of the *last* behaviour
03:05:26 <quicksilver> conal: thus producing something continuous.
03:05:34 <conal> quicksilver: oh ... now i get it.
03:05:49 <quicksilver> I wrote a combintor for an event which remembers previous occurrences
03:05:56 <quicksilver> so I have access to 'last behaviour'
03:06:04 <quicksilver> then I need to snapshot last behaviour at current time
03:06:07 <conal> as in withPrevE ?
03:06:12 <quicksilver> to get the right initial value to feed to new behaviour.
03:06:24 * quicksilver checks.
03:06:36 <conal> quicksilver: or just snapshot the behavior you're defining, rather than the last segment.
03:06:56 <conal> i.e., a self-referential definition.
03:07:19 <quicksilver> no, it's not self-referential
03:07:32 <quicksilver> or, at least, the self-reference is hidden inside withPrevE
03:07:36 <quicksilver> or something like it :)
03:07:37 <conal> i'm suggesting simplifying it by giving a self-referential definition.
03:07:55 <conal> instead of snapshotting the previous phase of the behavior, snapshot the behavior itself.
03:07:55 <quicksilver> That was one of the many things that crossed my mind ;)
03:08:17 <quicksilver> I have a random observation, too.
03:08:28 <quicksilver> Event/Reactive/Behaviour are used in two slightly different ways.
03:08:36 <quicksilver> Abstractly, they are defined 'for all time'
03:08:41 <conal> quicksilver: i don't know if you got the point about why you'd *want* self-referential in this case.
03:08:54 <quicksilver> concretely, we frequently reduce them to something with is only defined 'from this point forward'
03:09:02 <quicksilver> to enable old data to be discarded.
03:09:15 <conal> in the implementation, yes.  though one could use a zipper
03:09:21 <quicksilver> it's easy to get confused between teh value which represents 'the whole stream' and a value which represents 'half-stream'
03:09:24 * quicksilver nods
03:09:27 <quicksilver> half-streams make good sense.
03:09:32 <quicksilver> it's just possible to get confused :)
03:09:59 <conal> quicksilver: are you talking about the implementation?  or use of Reactive?
03:10:28 <ivanm> can strictness annotations be used with records?
03:10:45 <quicksilver> conal: I did miss the point about self-reference, yes.
03:10:56 <quicksilver> conal: would you like to elaborate.
03:11:35 <quicksilver> conal: I'm talking about the use, actually. A concrete haskell value of type 'Behaviour a' sometimes represents a half-stream.
03:11:39 <b\6> ivanm: yeah, i just saw someone do it.
03:11:55 <b\6> ivanm: http://techguyinmidtown.com/2008/07/16/lessons-learned-parsing-csv-in-haskell-and-python/  like tickerR?
03:11:57 <lambdabot> Title: Lessons Learned: Parsing CSV in Haskell and Python « tech guy in midtown, http://tinyurl.com/57bctu
03:12:00 <quicksilver> of course, you can 'sample' it at previous times. But you might get the wrong answer because you've lost information about reactions before the current time.
03:12:25 <conal> quicksilver: about self-reference, if i understood your description, you're taking care to remember a previous phase of a composite behavior b, so you can snapshot that phase in helping to define b.  i'm suggesting it'd be simpler to *not* remember the previous phases, and instead simply snapshot b as part of its own definition.
03:12:37 <EvilTerran> Axman6, but i don't want to try all of them and write a blog post =/
03:13:21 <ivanm> b\6: yeah
03:13:37 <quicksilver> conal: I'm sure that would be simpler. I couldn't quite get my head around it. I will try again.
03:14:14 <quicksilver> conal: I was suprised at how hard it was to write accumE and accumR. In the end I just used your definitions, but I spent quite a while trying to write them myself. I wasn't expecting to need mutual recursion.
03:14:17 <conal> quicksilver: if you try the self-referential version, i'd like to hear.  i carefully crafted the semantics to make it work, but i'm not sure the implementation is up to it.
03:14:40 <ivanm> is there a strict version of iterate?
03:14:42 <quicksilver> conal: I was convinced I could write accumE standalone, but I failed :)
03:14:43 <conal> quicksilver: you're getting deep in to this stuff!
03:15:25 <quicksilver> ivanm: you can just use iterate (f$!), I think. Depending what you meant by strict.
03:15:31 <quicksilver> ivanm: it's not normally necessary.
03:15:38 <ivanm> *nod*
03:15:46 <conal> quicksilver: keep trying.  i've been noodling about this stuff since 1992 or so.
03:16:03 <ivanm> just wondering if it delays computing f (f (f ( ... )))) until you actually ask for it...
03:16:11 <b\6> i thought dropping in bytestring might speed up parsec, but i'm seeing the opposite. i'm using readFile from Data.ByteString and Parser from Text.Parsec.ByteString; thought for sure that'd beat normal lazy reads and strings.
03:16:56 <conal> quicksilver: about half-streams, i'd hope that you can't tell that sampling before a certain time wouldn't give you the answer you'd expect.
03:17:16 <conal> quicksilver: can you tell?
03:18:11 <conal> quicksilver: and could you define accumE by itself simply by inlining accumR?
03:18:34 <conal> quicksilver: s/could/couldn't/
03:20:24 <quicksilver> conal: absolutely, but it wasn't obvious how to do so :)
03:20:42 <quicksilver> the function you fmap over the Future (you call it 'h') is a very non-obvious one.
03:20:59 <quicksilver> it applies a function to the first 'fixed' value of the reactive and does something totally different to the tail of the reactive.
03:21:17 <quicksilver> well maybe it's obvious in retrospect but I was unable to come up with until I gave up and cheated :)
03:21:29 <quicksilver> ivanm: it delays computing until you ask for it, yes.
03:21:44 <quicksilver> ivanm: but on the otherhand it remembers the n-1th value when calculating the nth value
03:21:51 <quicksilver> ivanm: you get a chain of thunks which reference each other.
03:21:57 <ivanm> it does? fair enough then
03:22:05 <ivanm> even if you lazily consume the list?
03:22:12 <quicksilver> especially if you lazily consume the list :)
03:22:43 <quicksilver> the nth thunk contains a reference to the n-1th thunk, so even if you 'consume' the n-1th it still can' tbe GCed yet.
03:23:13 <quicksilver> conal: I think that 'user code' shouldn't really play directly with the half-streams
03:23:17 <conal> quicksilver: which function has the 'h'?
03:23:34 <quicksilver> conal: accumE, in the paper version.
03:23:40 <ivanm> yay! strictness on my record data type prevented ghci from using up all the RAM!
03:23:51 <conal> quicksilver: looking ...
03:24:28 <quicksilver> the half-streams are there in the implenetation as you 'unwrap' the Reactives. Which is fine.
03:24:41 <quicksilver> but the user works with streams 'defined over my whole program'
03:24:47 <quicksilver> still I wonder if there is a pitfall.
03:25:20 <quicksilver> I also wonder if forgetThePast :: Event (Behaviour a) -> Event (Behaviour a) is useful.
03:26:22 <conal> quicksilver: i see.  i'd lost some appreciation for the subtlety of this style.
03:27:14 <quicksilver> conal: I am a very practical computer scientist. I need to try to write programs in order to give me intuition for the issues.
03:27:28 <quicksilver> conal: I have a couple more 'exercises' for myself yet to do :)
03:28:11 <conal> quicksilver: the library needs a good suite of commented examples.  it'll get there, especially with conributions from you & others.
03:28:41 <quicksilver> conal: I have another slight type-system mismatch.
03:28:48 <quicksilver> conal: I keep wanting to 'zipWith' two Events
03:28:55 <conal> quicksilver: do you see user code playing with half-streams and being able to distinguish them from full streams?
03:29:10 <quicksilver> conal: but the meaning of zipWith I have in mind only makes sense if the events are all simultaneous
03:29:41 <conal> quicksilver: sure.  you can do something similar, though.  fmap Left over one & Right over the other, and mappend them.
03:29:55 <conal> i have some nice examples somewhere in a blog post
03:30:58 <conal> quicksilver: have you played with pairE ?
03:31:47 * EvilTerran notes that HSQL and HDBC appear to be the same layer, so you only need one
03:32:15 <conal> quicksilver: http://conal.net/blog/posts/pairs-sums-and-reactivity/
03:32:20 <lambdabot> Title: Conal Elliott » Pairs, sums, and reactivity
03:32:33 <quicksilver> conal: well I came to the conclusion that I should be using Event (a,b) instead, if I knew they were simultaneous.
03:32:43 <quicksilver> conal: tell the type system that I know about simultaneity.
03:33:07 <quicksilver> conal: which goes against my haskell/list processing instincts to prefer 'zipWith' over explicit lists of tuples :)
03:34:50 <conal> quicksilver: sure.  in a synchronous setting.  still, it doesn't alway make "sense" to zipWith two lists.  i.e., without a reason to relate the nth element of one list to the nth element of another
03:35:56 <quicksilver> conal: true, true ;)
03:36:15 <conal> quicksilver: i'm enjoying these discussions.
03:36:35 <besiria> i was looking at shootout.alioth.debian.org earlier this day and i saw that there is a significant difference in perfomance between x86 and x86_64 Haskell benchmark results. is that normal?
03:37:16 <quicksilver> besiria: well their x86_64 machine has 4 cores and will have much larger caches.
03:37:21 <quicksilver> besiria: those things can make big differences.
03:37:58 <quicksilver> conal: I have a sneaking suspicions I am going to want something 'like' monad or notation or arrow notation soon.
03:38:03 <quicksilver> conal: but I haven't pinned it down.
03:38:29 <besiria> quicksilver: i understand. but i'm going to benchmark some parallel prog models and maybe i should use a x86 for comparison? 4cores and more
03:39:00 <quicksilver> conal: I have this strong intuition then when you're "inside" an Event, you are allowed to evaluate behaviours  and reactives as much as you like.
03:39:18 <quicksilver> conal: that is analogous to the idea that when you're "inside" IO you are allowed to execute as many IO actions as you like.
03:39:53 <quicksilver> conal: in do notation, this is acheived by <- which desugared into join. So really this is all "about" the existence of join :: IO (IO a) -> IO a
03:40:09 <quicksilver> conal: the 'pseudo-join' :: Event (Behaviour a) -> Event a gives rise to a similar feeling.
03:40:51 <conal> quicksilver: cool.  play around and let me know.  i've intentionally hidden the representations, and you might have to unhide them in order to add some more primitives.
03:41:08 <quicksilver> besiria: what are you trying to compare with what? If you're comparing different programming models then the most important thing is just that you use the same machine for all your tests; what other people use is not directly relevant.
03:41:15 <quicksilver> conal: well, I'm currently using my implementation not yours :)
03:41:21 <conal> quicksilver: what's important to me is that all of the primitives fit the semantic model.
03:41:23 <quicksilver> conal: just for instructive purposes.
03:41:41 <conal> quicksilver: oh yeah.  btw, we now have a bunch of QC tests you can use.
03:42:03 <quicksilver> I saw the clever class laws tests.
03:42:36 <conal> reactive is a jumbled mess now, with the tests in the code and the extension interface muddled with the functional interface.  i want to get it all neatly straightened out again.
03:42:58 <besiria> quicksilver: models and languages. haskell, erlang, java
03:43:28 <cads> in haskell, saying  x:xs is like saying cons x xs, and car x and cdr x are head x and tail x?
03:43:55 <quicksilver> cads: yes.
03:44:21 <conal> quicksilver: btw, watch out for recomputation, particularly of future values.  afaik, everyone who's tried to implement data-driven frp has run into the problem of recomputing future values, including me.  that's why i dropped using IO or STM in the representation.
03:45:10 <quicksilver> conal: I have a helper 'buildFuture' :: IO a -> Future a
03:45:21 <quicksilver> conal: it guarantees the action only gets called once :)
03:45:28 <quicksilver> actually IO(Future a)
03:45:57 <quicksilver> unfortunately, though, it's not general enough to use every time I need a future. My event's `mappend` has to cheat.
03:46:08 <guenni> parsec, one more time: has anyone done done a scan/parse, scan/parse, scan/parse ..... with Parsec?
03:46:48 <b\6> guenni: did you put a busted try at incremental parser on hpaste a while back?
03:47:15 <guenni> b\6: I think so
03:47:17 <quicksilver> conal: it definitely 'basically works' I have some examples working. I'll send you the code.
03:47:30 <b\6> guenni: yeah, welcome to the unhappy @ parsec Stream club.
03:48:06 <guenni> b\6: that doesn't sound good :(
03:48:21 <b\6> guenni: did you make an instance of Parsec Stream?
03:48:27 <conal> quicksilver: thx.  and give the qc tests a try.  for instance, determinacy of future&event mappend was tricky for me.  which is what led me to the functional unamb combinator.
03:48:58 <guenni> b\6: not sure what you mean
03:49:15 <quicksilver> conal: Yes. I'm pretty sure my event mappend is not guaranteed deterministic.
03:49:30 <quicksilver> conal: I think it's likely to be under the GHC RTS though :)
03:49:45 <eth01> possibly
03:49:47 <conal> quicksilver: testing will probably tell.
03:49:48 <b\6> guenni: think you'd know if you had. Parsec has a class called Stream with a function uncons. it acted kind of funny for me.
03:49:53 <conal> quicksilver: i suspect unamb has a lot of cool uses for functional programming.
03:50:24 <quicksilver> conal: I'm not trying to make a better implementation than yours, anyway. I'm trying to make a simple implementation to help me understand yours :) It's hard to understand design decisions without having explored the space a bit.
03:50:57 <guenni> b\6: it's kind of an unresolved issue then?
03:51:16 <conal> quicksilver: was sure hard for me too.  and i hope you or someone else does make a better implementation than mine.
03:52:27 <b\6> guenni: dunno. i couldn't figure out how to do what i wanted. i think it's kind of tricky because parsec needs certain things to be true about its streams and they aren't all specified.
03:53:16 <quicksilver> b\6, guenni: have you tried lazy polyparse?
03:53:23 <guenni> b\6: well I know how to work around the problem, it just means a hell of a lot of boilerplate code
03:54:03 <quicksilver> conal: I have a good target for a real but very small app to convert to reactive.
03:54:13 <quicksilver> conal: I have a simple particle system which does, e.g., fire effects.
03:54:25 <guenni> quicksilver: I had a glimpse at polyparse, but it is less documented than Parsec and I wondered of the relationship between those 2 libraries
03:54:33 <quicksilver> conal: would be very nice to use reactive to decouple the sampling from the frame-rate.
03:54:41 <quicksilver> less documented than parsec?
03:54:50 <quicksilver> surely that woudl only be possible if you had *NO* documentation at all.
03:54:59 <guenni> quicksilver: of what I could find, yes
03:55:39 <guenni> quicksilver: parsec had those 2 nice pdfs, polyparse only seemed to have haddocks
03:56:11 <conal> quicksilver: great.  i'd like to see know how it goes.  now i'm off to fool around in antwerp.
03:56:23 <EvilTerran> anyone used HaskellDB? is it worth using?
03:56:32 <guenni> quicksilver: but if you suggest to check it out I certainly will give it more effort
04:03:56 <Saizan_> b\6: parsec3 is highly unoptimized
04:04:10 <Saizan_> b\6: so it's not surprising that you're getting bad performance
04:04:45 <thoughtpolice> it apparently has better performance over e.g. bytestrings
04:04:55 <thoughtpolice> but for regular strings there are apparently big regressions from parsec2
04:04:56 <b\6> not in my tests.
04:05:10 <guenni> I had the impression, being totaly impressionable by anything as a newbie, that parsec was, well, state of the art?
04:05:42 <thoughtpolice> b\6: well that info came from someone who built pandoc against parsec3 and tested over strings v. bytestrings
04:05:47 <thoughtpolice> ymmv, for sure
04:06:08 <b\6> guess i'll try with parsec2.
04:06:27 <Saizan_> guenni: parsec2 has been the parsing library of choice for quite some time, and it's still one of the most used
04:06:37 <malcolmw> guenni: Here is a paper about polyparse:  http://www-users.cs.york.ac.uk/~malcolm/partialparse.html
04:06:39 <thoughtpolice> parsec2 is about ~6yrs old isn't it?
04:06:39 <lambdabot> Title: Partial parsing: combining choice with commitment
04:06:40 <maltem> guenni: It's widely used, but that's a different thing :) And it has a very nice interface
04:08:06 <guenni> malcolmw: thx for the paper
04:08:11 <quicksilver> I don't think parsec is anything like state of the art, tbh.
04:08:33 <malcolmw> parsec is from year 2000
04:08:33 <quicksilver> it's expressive and robust, and fast enough for most people.
04:08:45 <quicksilver> it's not cutting-edge parsing technology by any means.
04:08:59 <guenni> quicksilver: well I certainly have come to value your opinion very much
04:09:08 <malcolmw> the main reason parsec is widely used is because it has been distributed with ghc for many years
04:09:11 <quicksilver> of course, you don't necessarily need something state of the art to get a job done :)
04:09:19 <quicksilver> you need smoething which gets the job done.
04:09:32 <quicksilver> I personally prefer polyparse's decision to go for symmetric choice.
04:09:53 <maltem> Well when Parsec was written, [Char] was the overshadowing bottleneck anyway. ByteString has changed some perspectives, I guess
04:10:02 <quicksilver> and, it happens that polyparse has an experiment lazy parser
04:10:12 <mapreduce> Grr, "A Taste of Haskell" keeps pausing in a way that it doesn't seem to recover from.
04:10:13 <quicksilver> which I think was relevant to what people were talking about :)
04:11:36 <Saizan_> i still wonder if you can do the control inversion trick using delimited continuations with parsec3
04:16:37 <skorpan> OT: how do i hide my e-mail address from my google code profile?
04:18:18 <ivanm> use a dummy address? :p
04:18:47 <skorpan> :P
04:35:37 <ivanm> if I'm going to be doing computations where I have a list of n elements xs, and I'm gradually going to somehow combine xs and a shifted version of xs [0<=j<n], what would be better? for each j re-calcualte what the shifted list will be (uncurry (flip (++)) $ split j xs) or else keep passing around (cycle xs) and just do drop j on it?
04:41:41 <maltem> ivanm: My guess is that the latter is better. cycle is space-efficient, and gradually dropping is less steps than re-dropping
04:42:41 <maltem> ivanm: I'm not sure if that guess still applies if you need the shifted list to have exactly n elements
04:44:29 <ivanm> maltem: well, I'm doing a zip with the original list anyway
04:44:43 <ivanm> I figured cycle would be better, but wanted a 2nd opinion ;-)
04:45:16 <ivanm> besides, the cycled list would never contain more than 2n-1 elements (well, 2n-1 elements and 1 thunk)
04:46:11 <ivanm> usually less than that as I'm trying to find the first j that matches certain criteria, which is usually << n
04:46:44 <maltem> iirc ghc compiles  cycle xs  to a real cyclic list, where the last pointer is redirected to the first element
04:47:07 <maltem> so you wouldn't even get 2n-1 elements, in the ideal case
04:47:30 <ivanm> :o
04:47:34 <ivanm> \o/
04:47:51 <ivanm> it makes the type sig less "nice" of the subsidiary function, but shmeh
04:55:43 <cads> what editors do you guys use for haskell?
04:56:00 <quicksilver> emacs.
04:56:01 <Husio> vim
04:56:02 <Husio> :)
04:56:19 * ivanm uses the same as quicksilver 
04:56:25 * Twey uses the same as Husio
04:56:29 <guenni> still for hoping for a good one but using emacs for now
04:56:36 <Husio> it doesn't really matter, just user the force ;)
04:56:40 <ivanm> guenni: but emacs _is_ a good one!
04:56:41 <ivanm> ;-)
04:56:43 * Twey chuckles.
04:57:08 <guenni> ivanm: you put the bar pretty low then :)
04:57:22 <cads> oh no please no fite
04:57:22 <ivanm> @slap guenni
04:57:22 * lambdabot will count to five...
04:57:25 <ivanm> heretic!
04:57:31 <Husio> but it has build in tetris!
04:57:41 <ivanm> lambdabot is obviously being lazy about counting to five...
04:57:48 <cads> have you guys seen the leksah ide?
04:57:54 <ivanm> yeah, I"ve installed
04:58:01 <ivanm> haven't really played much with it
04:58:06 <guenni> cads: don't bother trying that one yet
04:58:14 <ivanm> there's also yi, which I had trouble installing :s
04:58:18 <guenni> it's a pain to install and then doesn't work
04:58:24 <ivanm> guenni: oh? how doesn't it work?
04:58:49 <Axman6> cads: what platform are you on?
04:58:56 <guenni>  ivanm: once you do manage to install it, it just crashes / freezes, that is on XP
04:59:19 <ivanm> guenni: _there's_ your problem!
04:59:22 <randomity> elp hilight
04:59:26 <cads> axman: ubuntu
04:59:37 <ivanm> cads: no, that's your distribution
04:59:41 <quicksilver> saying "Yi doesn't work" is just stupid.
04:59:49 <quicksilver> of course it works, the developers use it.
04:59:51 <ivanm> quicksilver: he meant leksah
04:59:53 <ivanm> your platform is gnu/linux
04:59:54 <quicksilver> oh
05:00:10 <quicksilver> yeah, it might be true that lekash doesn't work :)
05:00:12 <cads> ivan, gnu/linux is what I meant
05:00:18 <cads> oh
05:00:24 <cads> man I'm slow this morning
05:00:31 <Axman6> i	wouldn't that technically just be the kernel?
05:00:34 <maltem> yi has pretty specific cutting-edge always-changing dependencies, which is why so few people get it to compile
05:00:36 <ivanm> does anyone actually use kdevelop for haskell support?
05:00:46 <guenni> ivanm: can't do anything about that, need to develop for WinXP
05:00:54 <quicksilver> having just been a pedant, myself, I'm going to be hypocritical and criticise ivanm for being pedantic ;)
05:00:55 <ivanm> Axman6: linux is the kernel, gnu/linus is one of the ways of specifying the entire toolchain+kernel+system utils
05:01:03 <quicksilver> ubuntu is a perfectly sensible answer to 'platform'.
05:01:10 <ivanm> quicksilver: lol
05:01:10 <quicksilver> platform is a loosely defined concept at best.
05:01:16 <ivanm> though I beg to differ
05:01:21 <quicksilver> ubuntu tells you which package manager they use
05:01:27 <quicksilver> which is a very important part of a platform.
05:01:40 <ivanm> no it isn't
05:02:08 <ivanm> quicksilver: because windows doesn't have a pkg manager
05:02:29 <ivanm> http://en.wikipedia.org/wiki/Platform_(computing)
05:02:32 <quicksilver> yes. That's a very important part of the windows platform.
05:02:35 <quicksilver> That it has no package manager.
05:02:42 <quicksilver> one of the many things I don't like about it.
05:02:50 <ivanm> heh, true
05:02:51 <quicksilver> Although there is add/remove programs so it's not quite true.
05:03:10 <ivanm> quicksilver: no, it has an often malfunctioning central repository for removing packages
05:03:11 <Botje> well, most programs use MS installer nowadays
05:03:24 <ivanm> which is < 1/2 the job of a package manager
05:03:56 <ivanm> Botje: a variant of MS installer anyway
05:04:57 <cads> is there a way to use a gnu package manager in windows without say cygwin?
05:05:20 <cads> actually, nevermind that
05:05:45 <ivanm> cads: closest I can think of is gentoo-prefix
05:06:17 <cads> even when dealing with extremely weird bugs am I happy to no longer be on windows
05:10:37 <Saizan_> what do you use to search through the papers on your HD? i'm to lazy to rename the pdf to something sensible
05:10:43 <Saizan_> "too"
05:10:46 <ivanm> Saizan_: grep? :p
05:10:58 <Saizan_> for pdfs?
05:11:00 <ivanm> IIRC, adobe reader at one stage had a way of searching pdfs
05:11:13 <ivanm> maybe something like beagle can index pdfs?
05:12:54 <cads> could run pdf2txt on everything then grep that
05:13:07 <kig> pdftotext foo.pdf - | grep
05:13:29 <Saizan_> looks slow :)
05:14:12 <ivanm> filter (contains "foo") . map pdftotext $ find . -name "*.pdf" ;-)
05:16:14 <kig> -name glob filename = glob_match glob filename
05:16:54 <quicksilver> Saizan_: I use apple's spotlight. I think there are similar things for other platforms
05:16:59 <Axman6> wait, wtf? PDF's are perfectly searchable :S
05:18:05 * Axman6 is a little confused
05:18:22 <quicksilver> he wants to search his HD for a PDF
05:18:26 <quicksilver> not search a single PDF.
05:18:40 <Axman6> well, enter spotlight, as you said
05:18:40 <Saizan_> yeah
05:18:45 <ivanm> or beagle
05:18:55 <Saizan_> i'll try beagle, thanks
05:18:57 <ivanm> or whatever the new competitor for beagle is
05:19:03 <ivanm> Saizan_: I did say that before... ;-)
05:19:52 <Saizan_> i didn't say anything against it :)
05:20:47 <ivanm> http://www.wikinfo.org/index.php/Comparison_of_desktop_search_software
05:21:00 <lambdabot> Title: Comparison of desktop search software - Wikinfo, http://tinyurl.com/5ujaty
05:21:42 <cads> how would you guys do math on an irrational number where arbitrary precision would be needed?
05:21:56 <quicksilver> CReal
05:22:21 <cads> mm that reminds me to get some breakfast
05:22:37 <quicksilver> see also
05:22:37 <quicksilver> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Arbitrary_precision
05:22:40 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
05:22:46 <quicksilver> and the following section on 'Dynamic' precision
05:23:18 <mgsloan> has anyone here used the haskell protocol buffers library?
05:24:18 <cads> that looks good quicksilver
05:25:35 <mgsloan> dons - in the comments of http://stuartsierra.com/2008/07/10/thrift-vs-protocol-buffers you say there is another protocol buffers lib in dev?
05:25:37 <lambdabot> Title: Thrift vs. Protocol Buffers - Digital Digressions by Stuart Sierra
05:25:56 <matthew-_> sigh, that would have been the wrong irssi command...
05:27:16 <Axman6> heh
05:29:15 <opqdonut> wow http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
05:29:18 <lambdabot> Title: FP Lunch » Blog Archive » Modular Monad Transformers
05:38:02 <quicksilver> opqdonut: that looks very clever. Although I don't entirely grok it :)
05:38:20 <quicksilver> opqdonut: It looks like a big step in the direction of a better theory of monad transformers, though.
05:39:11 <opqdonut> yes
05:39:34 <opqdonut> i love this kind of haskell research. small, cute, obvious and powerful
05:40:15 <jinjing> obvious ?
05:40:36 <opqdonut> well, it's saying nothing fancy
05:40:54 <opqdonut> in terms of types and category theory
05:41:14 <jinjing> ok
05:41:15 <quicksilver> obvious in the "good ideas are obvious in retrospect" sense
05:41:22 <quicksilver> not in the "I could have thought of that" sense :)
05:41:32 <opqdonut> yes
05:41:40 <opqdonut> i wanted to do my (err, what should i call it) "bachelor's dissertation" on something like this but my mentor recommended functional data structures instead :(
05:41:57 <opqdonut> i'll try to sway him, of course
05:42:08 <quicksilver> restricting monad operations to only algebraic morphisms which automatically obey the laws is a really nice idea
05:42:20 <quicksilver> my gut instinct would be "I bet that means most interesting things are not valid"
05:42:24 <opqdonut> but he does computational medical biology or something like that, not very much into theoretical cs
05:42:25 <quicksilver> but hopefully I'm wrong.
05:42:43 <opqdonut> quicksilver: well the Reader' example is pretty good
05:43:54 <maltem> opqdonut: Hah, these "computational" things. I'm enrolled into Computational Engineering Science, but had to find out it doesn't cover CS at all
05:44:10 <maltem> little, anyway
05:44:37 <quicksilver> there is a lot of pressure for universities not to teach real CS
05:44:42 <opqdonut> yes
05:44:44 <quicksilver> that being, students don't like it and aren't good at it.
05:44:45 <opqdonut> it's a shame
05:45:01 <quicksilver> the pressure is towards teaching things that people will get good results in :)
05:45:16 <ivanm> quicksilver: CS? what's that? :p
05:45:16 <opqdonut> our uni is very much into machine learning
05:45:28 <quicksilver> in a good university you can hope this pressure reduces as you move towards Masters and later degrees.
05:45:28 <ivanm> my uni likes databases :s
05:45:35 <ivanm> oh, and web-based interfaces to those databases
05:45:39 <opqdonut> which is pretty nice compared to db or software engineering stuff
05:45:44 <opqdonut> ivanm: exactly :P
05:45:53 <ivanm> opqdonut: yeah :s
05:45:53 <Botje> mine does a bit of everything
05:46:00 <opqdonut> it's just that i've never felt any love for machine learning
05:46:11 <opqdonut> it's mostly linear algebra and statistics for chrissakes
05:46:13 <quicksilver> some bits of machine learning are very interesting.
05:46:17 <Botje> in soviet russia, machine learns to love YOU!
05:46:26 <opqdonut> quicksilver: of course
05:46:27 <quicksilver> They're not likely to be usefully teachable to undergrads though.
05:46:44 <ivanm> I was the only IT student who did the software specification subject... everyone else was SE (for which it was compulsory)
05:46:46 <quicksilver> undergrads can learn about expert systems which are useless except as 20-questions toys
05:46:52 <quicksilver> and about neural nets which don't actually work.
05:47:11 <quicksilver> makes for a really rewarding course, I find :)
05:47:58 <maltem> quicksilver: I do hope so, in re "move towards Master", also by including some courses from CS Bachelor
05:48:46 <quicksilver> try to establish links with people doing active research in the areas that interest you
05:48:52 <quicksilver> they will help you find good places.
05:49:02 <opqdonut> i've been doing that
05:49:03 <maltem> (I just felt fooled after they advertised this program being one third CS, and there isn't even discrete mathematics in it)
05:49:12 <quicksilver> almsot everyone responds positively to people who are interested in their research
05:49:17 <opqdonut> and we've racked up student pressure for functional programming and type theory courses
05:49:27 <opqdonut> a haskell workshop should be happening later this semester
05:49:34 <maltem> quicksilver: sounds like good advice
05:49:34 <quicksilver> that's pretty cool
05:49:44 <opqdonut> yes
05:49:45 <quicksilver> we dropped functional programming about 3-5 years before I started teaching
05:49:56 <quicksilver> I always hoped we could push it back, but the pressure was too great
05:49:59 <opqdonut> fp was dropped the same year I enrolled
05:50:00 <quicksilver> (and I was very junior)
05:50:17 <opqdonut> because the prof who had lectured all the courses left for another univ
05:50:18 <quicksilver> we did teach a bit of program logic to 2nd/3rd years, though, that was cool.
05:51:53 <maltem> whew, bad timing for both of you
05:52:13 <ivanm> quicksilver: which uni is this?
05:53:09 <quicksilver> that was Queen Mary.
05:53:16 <quicksilver> (London)
05:53:19 <ivanm> *nod*
05:53:29 <kig> opqdonut: the fp course used sml/nj and didn't really go very far with it iirc. had some lazy eval stuff at the end
05:53:38 <ivanm> yes, I noticed a dearth of FP there when I had a look through their pages :s
05:54:58 <opqdonut> oh, hi kig :)
05:57:40 <quicksilver> ivanm: there is plenty of FP in research at QM - in the theory group. It's just not represented in the undergrad syllabus
05:58:01 <ivanm> well, I was looking more at the postgrad end...
05:58:13 <quicksilver> no PL research, though.
05:58:17 <ivanm> maybe I missed it because I was looking more at usage of fp rather than fp fundamentals
05:58:26 <quicksilver> but plenty of related research which uses FPs as tools
05:58:33 <quicksilver> logic, type theory, program proof
05:58:54 * ivanm was aiming at more at computational combinatorics
05:58:58 <quicksilver> this bunch : http://www.dcs.qmul.ac.uk/researchgp/theory.php
05:59:10 <lambdabot> Title: Theory
06:00:19 <araujo> morning
06:03:22 <Arnar> hi all..
06:04:02 <Arnar> I'm looking for something that I feel should be in the library somewhere.. generating n-dimensional lattices over a list..
06:04:34 <Arnar> i.e. lattice 2 [0,1] == [[0,0],[0,1],[1,0],[1,1]]
06:05:20 <quicksilver> > replicateM 3 [0,1]
06:05:24 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
06:05:31 <Arnar> quicksilver: excellent.. thanks
06:05:36 <Arnar> @src replicateM
06:05:36 <lambdabot> replicateM n x = sequence (replicate n x)
06:05:48 <ivanm> @src sequence
06:05:49 <lambdabot> sequence []     = return []
06:05:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:05:49 <lambdabot> --OR
06:05:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:06:15 <quicksilver> it's do { a <- [0,1]; b <- [0,1]; c <- [0,1]; return [a,b,c] }
06:06:22 <quicksilver> if you find that easier to thing about.
06:06:25 <ivanm> yeah, that's what I figured
06:06:35 <Arnar> quicksilver: sure.. replicateM makes sense too
06:06:55 <Twey> > let lattice xs = replicateM (length xs) xs in lattice [0, 1]
06:06:59 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
06:07:04 <Twey> > let lattice xs = replicateM (length xs) xs in lattice [0, 2]
06:07:08 <lambdabot>   [[0,0],[0,2],[2,0],[2,2]]
06:07:13 <Twey> Hmph
06:07:18 <Twey> Not quite right
06:07:40 <Twey> Oh, I see.
06:07:42 <Arnar> Twey: no, the length of the list and the dimension are independent
06:07:46 <Twey> Silly me.
06:07:47 <Twey> Yes.
06:08:32 <quicksilver> of course it doesn't really generate the lattice.
06:08:38 <quicksilver> just the selections.
06:08:52 <quicksilver> it's a bit more work to generate the structure. but not too much.
06:08:57 <Arnar> quicksilver: what do you mean?
06:09:10 <Arnar> oh.. by "lattice" I mean just the vector elements
06:09:13 <maciek__> I have getMousePos :: IO (GLfloat,GLfloat) and I want to apply result of this function to renderRect :: (GLfloat,GLfloat) -> (GLfloat,GLfloat) -> IO (). How to do it?
06:09:16 <quicksilver> ah, OK ;)
06:09:47 <quicksilver> maltem: do (x,y) <- getMousePos; renderRect (x,y) (x+1,y+1)
06:09:51 <quicksilver> maciek__: that was for you.
06:09:54 <quicksilver> (sorry maltem )
06:10:01 <maciek__> thanks!
06:10:36 <ddarius> maciek__: You need to read up on how to use the IO monad, because if you can't answer that question yourself you aren't going to be able to do much else.
06:11:05 <maciek__> works, thanks.
06:11:47 <maciek__> yes, I know, but in tutorial I saw operator =<< to do this and I thought it's something different
06:12:18 <Arnar> maciek__: you mean =>> ?
06:12:27 <maciek__>   H.setPosition b =<< getMousePos
06:12:34 <Botje> a =<< b = do res <- b; a res
06:13:00 <quicksilver> maciek__: the <- I did is a convenient notation for >>=
06:13:06 <quicksilver> or, at least, some people find it convenient.
06:13:10 <quicksilver> I do! :)
06:13:40 <Botje> =<< is just too awesome for words :p
06:13:49 <maciek__> Botje: thanks, now I understand tutorial's example too
06:14:26 <Arnar> so (=<<) = flip (>>=) ?
06:14:32 <Arnar> @src (=<<)
06:14:32 <Botje> yup
06:14:36 <Arnar> cool
06:14:40 <lambdabot> f =<< x = x >>= f
06:14:44 <maciek__> where can I find what operator means? I cannot google for it..
06:15:00 <Botje> check the documentation?
06:15:01 <Arnar> maciek__: the word "operator" ?
06:15:21 <Arnar> maciek__: try Hoogle
06:15:26 <Arnar> you can search for operators there
06:15:38 <Arnar> @where hoogle
06:15:39 <lambdabot> http://haskell.org/hoogle
06:16:04 <maciek__> thanks, hoogle is what I was looking for
06:16:16 <Arnar> maciek__: you can use it through lambdabot too
06:16:20 <Botje> heh
06:16:24 <Arnar> @hoogle =<<
06:16:24 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
06:16:25 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
06:16:41 <maciek__> and how to do this inline? without (x,y) <- getPos and renderRect (x,y)
06:16:55 <maciek__> I mean in renderRect second argument
06:17:00 <Arnar> renderRect =<< getPos
06:17:14 <maciek__> render rect gets second argument,too
06:17:14 <Arnar> I guess (I don't know the GL stuff)
06:17:34 <Arnar> one trick is:
06:17:49 <Arnar> (`renderRect` secondarg) =<< getPos
06:18:04 <Arnar> or (flip renderRect) secondarg =<< getPos
06:18:23 <maciek__> not beautiful.
06:18:30 <Arnar> true
06:18:47 <Botje> getPos >>= \pos -> renderRect pos secondArg
06:18:48 <quicksilver> maciek__: and that's why we have do notaiton :)
06:18:55 * EvilTerran notes that an infix name for "flip" might be useful
06:19:05 <maciek__> can I do ((renderRect =<< getPos) size)?
06:19:14 <quicksilver> everyone_: useful for obfuscation, certainly :)
06:19:18 <Arnar> EvilTerran: example?
06:19:20 <quicksilver> damn tab complete
06:19:22 <quicksilver> that was for you EvilTerran
06:19:23 * Botje proposes (/|\) 
06:19:33 <Botje> maciek__: no.
06:19:51 <EvilTerran> Arnar, (renderRect $$ secondArg)
06:19:58 <EvilTerran> or whatever you want to call it
06:20:01 <Arnar> EvilTerran: ah.
06:20:13 <EvilTerran> renderRect `flip` secondArg :P
06:20:17 <Arnar> (renderRect <?> secondArg)
06:20:23 <Arnar> <?> serving as a placeholder for the missing arg
06:20:36 <EvilTerran> well, <_> is kinda taken by Applicative and its ilk
06:20:52 <EvilTerran> (renderRect --- secondArg)?
06:21:13 <EvilTerran> or ...
06:21:16 <Botje> renderRect `somethingElse` secondArg
06:21:17 <Botje> :o)
06:21:25 <Arnar> is ... possible?
06:21:34 <Arnar> although.. that implies there can be more than one
06:21:41 <EvilTerran> > let (...) = flip in (f ... x) y :: Expr
06:21:44 <lambdabot>   f y x
06:21:45 <Botje> heh heh :)
06:21:47 <Arnar> cool
06:21:52 <Botje> EvilTerran++
06:22:05 <Arnar> > let (__) = flip in (f __ x) y :: Expr
06:22:06 <EvilTerran> > let (???) = flip in (f ??? x) y :: Expr
06:22:10 <lambdabot>       Overlapping instances for Show ((a -> b -> c) -> b -> a -> c)
06:22:10 <lambdabot>        ar...
06:22:12 <lambdabot>  Terminated
06:22:15 <quicksilver> > let (...) = flip in (f a b c ... e f g) d :: Expr
06:22:16 <EvilTerran> __ is not infix
06:22:17 <Arnar> oops
06:22:18 <lambdabot>   Couldn't match expected type `a -> a1 -> b'
06:22:25 <EvilTerran> > let __ = 1 in __
06:22:27 <quicksilver> ^^ this is the problem, IMO.
06:22:29 <lambdabot>   1
06:22:38 <quicksilver> it feels like you should be able to use it anywhere
06:22:44 <quicksilver> and, of course, that's not how precedence works
06:22:45 <EvilTerran> quicksilver, yeah, i know =/
06:22:51 <quicksilver> > let (...) = flip in (f a b c ... e $ f $ g) d :: Expr
06:22:54 <lambdabot>   Add a type signature
06:23:01 <Arnar> quicksilver: right.. we need a new syntacitc sugar at the language level :)
06:23:02 <quicksilver> hmm. that should work, I thought.
06:23:20 <EvilTerran> quicksilver, f and g are too polymorphic
06:23:28 <quicksilver> trying to formalie "expressions with holes" leads you back to lambda notation
06:23:29 <Saizan_> ?seen nominolo
06:23:30 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I don't know when nominolo last spoke.
06:23:31 <EvilTerran> > let (...) = flip in (f a b c ... x $ y $ z) d :: Expr
06:23:33 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
06:23:35 <quicksilver> it's a road I've been down more than once.
06:23:41 <EvilTerran> also, the associativity of $ is wrong
06:23:55 <Arnar> rewrite (f a b _ c _ d e) to (\x1 x2 -> f a b x1 c x2 d e)
06:24:04 <EvilTerran> indeed, but an infix flip would cover the most basic (and so most common) case
06:24:12 <quicksilver> yes, agreed.
06:24:14 <nominolo> Saizan_: whatup?
06:24:22 <quicksilver> but a special case for 2-arg functions would annoy me
06:24:25 <EvilTerran> (map -?- xs), etc
06:24:28 <quicksilver> I don't think they're common enough to warrant it.
06:24:35 <EvilTerran> do fst, snd, curry, and uncurry annoy you too?
06:24:39 <quicksilver> yes.
06:24:45 <quicksilver> I never use any of those four :P
06:24:45 <EvilTerran> oh well
06:24:47 <EvilTerran> :P
06:24:48 <Arnar> they annoy me to :)
06:24:52 <Arnar> I still use them
06:24:59 <quicksilver> actually I very occasionally use curry/uncurry
06:25:04 <quicksilver> in a higher-order context
06:25:13 <quicksilver> never fst or snd
06:25:22 <besiria> what the.. i was trying the threadring bench on my pc and with +RTS -N2 -RTS i'm getting ~3min with no rts i'm getting 9s !?
06:25:24 <EvilTerran> pairs are thoroughly tied to arrows as well
06:25:48 <Arnar> how about this syntactic sugar idea? is it nonsense?
06:25:54 <quicksilver> EvilTerran: that's always annoyed me - in a low-level way - because it makes people think Arrows are "mostly" about pairing.
06:26:07 <quicksilver> EvilTerran: which distracts from what Arrows are really about.
06:26:13 <EvilTerran> Arnar, well, as quicksilver says, you rapidly end up back at lambdas
06:26:23 <Saizan_> nominolo: when we was talking about dependency analysis for gsoc this spring you mentioned delimited continuations, was that because of the work of Umut Acar et al. on adaptive computations?
06:26:39 <EvilTerran> quicksilver, see, if tuples were syntactic sugar for chains of snd-strict pairs and (), it wouldn't be a problem :P
06:26:57 <Arnar> EvilTerran: how so? I'm talking about arbitrary number of _-s at arbitrary positions
06:27:30 <EvilTerran> Arnar, where does a _-containing expression stop?
06:27:40 <nominolo> Saizan_: I don't think so
06:27:41 <EvilTerran> you need some kinda marker
06:27:46 <Arnar> hmm
06:27:49 <quicksilver> Arnar: take a look at http://www.haskell.org/pipermail/haskell-cafe/2007-July/thread.html#27845
06:27:51 <EvilTerran> let's call it "\" :P
06:27:52 <lambdabot> Title: The Haskell-Cafe July 2007 Archive by thread, http://tinyurl.com/59gvgh
06:27:58 <quicksilver> Arnar: the post by "Jules Bean" is particularly insightful.
06:28:06 <quicksilver> what a smart guy he must be :P
06:28:16 <Saizan_> nominolo: oh, ok :)
06:28:29 <Leaves> hello, do you know of a tutorial how to install cabal packages on ubuntu?
06:28:35 <nominolo> Saizan_: i actually don't remember telling you that
06:28:44 <nominolo> Saizan_: have a log? :)
06:29:10 <Saizan_> nominolo: mmh, maybe i can find it :)
06:29:29 <Arnar> quicksilver: ah.. I had to whois you to get the joke :)
06:30:00 <nominolo> Saizan_: maybe because of zipper = reified delim. continuation
06:30:25 <dcoutts> Leaves: check the cabal home page, top link is the instructions
06:31:15 <Arnar> quicksilver: ah, I get it.. your email explains it
06:31:28 <quicksilver> well, conor's reply challenges what I say.
06:31:38 <quicksilver> There might be space here for some neat sugar
06:31:43 <quicksilver> but it's not obvious where the sweet spot is
06:31:47 <quicksilver> lambda is pretty good.
06:32:13 <Saizan_> nominolo: yeah, probably, now that i found the log it was just me asking what knowledge would be useful for the project and you adding continuations :)
06:32:30 <nominolo> heh
06:32:59 <Saizan_> thanks anyway :)
06:33:01 <nominolo> Saizan_: yeah, there's some room for now work with delimited continuations
06:33:08 <Arnar> quicksilver: reading Conor's reply. so this would only be possible with explicit scoping (he uses {})?
06:33:10 <nominolo> *new* work
06:33:15 <Arnar> that kinda ruins it..
06:33:31 <Arnar> btw there should be a ascii code for a "hole"
06:33:42 <nominolo> Arnar: it's usually [ ]
06:33:44 <Saizan_> nominolo: for dependency analysis? have any specific pointers?
06:33:45 <Botje> an anti-char? :)
06:33:50 <Arnar> would be cool if future morphing displays would render it as an actual hole
06:34:01 <Botje> Arnar: well, there's always the goatse combinator
06:34:02 <Botje> =()=
06:34:03 <quicksilver> you need some notion of scoping.
06:34:04 <Botje> or ={}=
06:34:10 <quicksilver> explict or implicit.
06:34:16 <Arnar> quicksilver: yes..
06:34:19 <Botje> that hole-y enough for you? :)
06:34:20 <quicksilver> in a more rich language than text, you could use colours.
06:34:33 <quicksilver> or you can anchor it to some existing construct
06:34:48 <quicksilver> like "nearest enclosing () or definition)
06:34:52 <EvilTerran> quicksilver, colours'd basically be a funny way of displaying lambdas, right?
06:35:03 <quicksilver> ...but such rules can be confusing in practice.
06:35:15 <EvilTerran> anchoring to an existing construct like that would break some rather nice algebraic rules
06:35:20 <quicksilver> EvilTerran: well, I think we'd avoid naming parameters, and instead just use them left-to-right.
06:35:28 <EvilTerran> ah
06:35:33 <quicksilver> EvilTerran: *exactly*. THat was the problem with 'monadic subexpression'
06:35:41 <quicksilver> EvilTerran: (which was anchored to the nearest 'do')
06:35:50 <nominolo> Saizan_: not OTTOMH
06:35:58 <Arnar> quicksilver: one possibility of an implicit rule is use lambdas "extend as far to the right as possible", right?
06:36:04 <quicksilver> Yes.
06:36:06 <Arnar> and use braces to stop
06:36:06 <EvilTerran> i agree. we'd want some other kind of marker to indicate where to bind to for monadic subexpressions
06:36:23 <Saizan_> nominolo: 'k
06:36:31 <quicksilver> There is definitely a design space here, but I couldn't think of anything which I thought was enough better than lambda
06:36:33 <Arnar> s/braces/parentheses/
06:36:35 <quicksilver> to be worth the hassle.
06:36:39 <nominolo> Saizan_: did you finish your gsoc project?
06:37:22 <Saizan_> nominolo: yeah
06:37:30 <EvilTerran> quicksilver, i was thinking something like a <- at the start of a line in a do-block meaning "put any following monadic subexpressions here" could work
06:37:46 <nominolo> Saizan_: does it work well?
06:37:51 <Saizan_> nominolo: but the language for describing compilation rules is still quite low-level
06:38:10 <EvilTerran> do <- putStrLn $ f (<- readLine)
06:38:28 <EvilTerran> or as a line on its own, even; do <-; putStrLn $ f (<- readLine)
06:38:39 <Saizan_> nominolo: yup, it does everything required :) darcs pull code.haskell.org/~Saizan/cabal
06:38:40 <quicksilver> EvilTerran: *nod*
06:39:01 <Saizan_> nominolo: it's still only used for preprocessors and yhc there
06:39:04 <EvilTerran> seeing as i usually put a newline after "do" anyway, that'd be very minimal inconvenience for me :)
06:39:43 <quicksilver> EvilTerran: but you might occasionally surprise yourself if you wrote do <-; foo; bar; putStrLn $ (<- baz)
06:39:52 <EvilTerran> yeah
06:39:55 <quicksilver> EvilTerran: and you weren't expecting 'baz' to run before foo and b ar
06:40:01 <quicksilver> I mean, it's a rule and you've broken it.
06:40:09 <quicksilver> but the question is, is it pretty enough to be worth it :)
06:40:12 <EvilTerran> you'd have to be alert enough to write "do foo; bar; <-; putStrLn (<- baz)"
06:40:14 <nominolo> Saizan_: nice, includes QC tests
06:40:22 <EvilTerran> if it mattered
06:40:33 <quicksilver> EvilTerran: it's certainly a new way of making mistakes. But I guess any new feature would be that.
06:40:46 <quicksilver> EvilTerran: I think people anticipated mostly using this in monads with commutative effects anyway.
06:40:49 <EvilTerran> quicksilver, alternatively, "do <-" could introduce a special type of do block whose lines caught monadic subexpressions
06:41:11 <quicksilver> App (<- newSym) (<- newSym)
06:41:13 <nominolo> Saizan_: did that catch some bugs?
06:41:30 <quicksilver> (of course, App $ newSym <*> newSym works fine, but doesn't scale)
06:41:42 <EvilTerran> quicksilver, that might be less liable to provoke mistakes
06:41:47 <quicksilver> s/$/<$>/
06:41:49 <quicksilver> *nod*
06:42:07 <Saizan_> nominolo: more bugs in the tests than elsewhere :) but just writing down the properties has been quite useful
06:42:23 <Botje> quicksilver: but don't you lose sequencing in that fashion?
06:42:33 <Botje> how can you tell which <- happens first?
06:42:45 <quicksilver> Botje: left to right as presented on screen.
06:42:52 <quicksilver> but you're supposed to use it mostly when you don't really care.
06:42:56 <quicksilver> (as in the newSym case)
06:42:57 <Botje> ah
06:42:59 <nominolo> Saizan_: right.  I always forget how useful writing tests is even if they seem trivial
06:43:04 <EvilTerran> Botje, in that way, it's the same as App <$> newSym <*> newSym
06:43:17 <Botje> yeah. i can see that.
06:43:19 <nominolo> Saizan_: makes you think about semantics and often API, too
06:43:34 <Botje> i was thinking about something like login (<- getUsername) (<- getPassword)
06:44:22 <EvilTerran> (by "in that way", i mean wrt the left-to-right aspect)
06:44:40 <Saizan_> nominolo: exactly, i had some misconceptions about the use of the cache (where we store represenations of old values) and the tests cleared them out
06:44:49 <quicksilver> Botje: yes. That kind of thing would probably be recommended against.
06:45:01 <Botje> okay :)
06:45:07 <quicksilver> Botje: although in that precise example its simple to see the ordering, in more complex ones it wouldn't be.
06:45:21 <quicksilver> But when your monad is returning fresh values, or random numbers
06:45:29 <quicksilver> or writing to a commutative monoid
06:45:36 <quicksilver> or applying commutative transforms to a state monad
06:45:39 <quicksilver> you really don't care.
06:45:54 <quicksilver> even unification is commutative up-to getting the right answer.
06:46:19 <quicksilver> (the order you try to unify terms may make the type error appear in a different place, but it will not change whether or not it succeeds)
06:50:28 <Arnar> I read the paper by SPJ on the spineless tagless g-machine, from 1991
06:50:36 <Arnar> is that still the underpinnings of GHC?
06:50:59 <Arnar> btw that was one of the most enjoyable reads I've had for a long time
06:51:30 <ivanm> anyone here familiar with hmatrix?
06:55:40 <thoughtpolice> Arnar: I'm fairly certain quite a bit has changed over the past 17 years or so, but it is still fairly relevant - I still haven't read all the way through the paper yet
07:02:38 <quicksilver> Arnar: people who understand GHC better than I claim it is no longer either spineless or tagless.
07:02:50 <quicksilver> Arnar: however the general intuitions from that paper are still correct.
07:03:09 <EvilTerran> > let (<,>) = (,) in 1 <,> 2
07:03:13 <lambdabot>   mueval: Prelude.read: no parse
07:03:14 <EvilTerran> aww
07:03:51 * EvilTerran notes that the only place being able to use , in operators would be ambiguous would be infix declerations, which've really weird syntax anyway
07:03:53 <Arnar> quicksilver: ok, the main thing seemed to use code instead of tags and big branches
07:04:09 <EvilTerran> space-separating those would probably make more sense than comma-separating them anyway
07:04:13 <Arnar> I guess that's the "tagless" part
07:04:26 <EvilTerran> i guess you also couldn't have things like ,,, as an operator, because then (,,,) would be ambiguous
07:04:31 <Arnar> and the other big thing was the CPS nature of it.. if I understood correctly that was the "spineless" part
07:04:46 <Arnar> thoughtpolice: ok..
07:05:19 * EvilTerran is going to play around with strict-snd pairs as a representation of n-tuples, but wanted to be able to call his pair type "data a :, as = a :, !as"
07:06:19 <EvilTerran> i'll just call it :+ or something, seeing as a+b is (a,b) by another notation anyway
07:06:28 <EvilTerran> er, sorry, s/+/*/g
07:07:49 <quicksilver> EvilTerran: I suspect you will end up with something like HList won't you?
07:08:07 <quicksilver> EvilTerran: although HList isn't particular about strictness.
07:08:10 <EvilTerran> quicksilver, well, like one little bit of HList, yeah
07:08:13 <quicksilver> but is about nested pairs.
07:08:29 <EvilTerran> i'm not going for the whole type-indexed-lists, extensible-records lark
07:08:41 <EvilTerran> just a nicer formulation of tuples
07:08:46 * quicksilver nods
07:08:55 <ivanm> is there a generic power function?
07:09:04 <EvilTerran> there's three of them
07:09:06 <EvilTerran> ?type (^)
07:09:08 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:09:09 <EvilTerran> ?type (^^)
07:09:11 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:09:11 <EvilTerran> ?type (**)
07:09:13 <ivanm> as in Double -> Double -> Double
07:09:13 <lambdabot> forall a. (Floating a) => a -> a -> a
07:09:18 <EvilTerran> that'd be (**)
07:09:18 <ivanm> ahhhh, ** was what I wanted
07:09:20 <EvilTerran> ?src (**)
07:09:20 <lambdabot> Source not found. Sorry.
07:09:26 <quicksilver> ivanm: of course, no such function exists.
07:09:33 <quicksilver> ivanm: you have to restrict to positive bases.
07:09:38 <quicksilver> (or restrict the exponent)
07:10:00 <ivanm> well, I wanted to raise to a power of a quarter, etc.
07:10:26 <quicksilver> yes, then you want **
07:10:33 <Saizan_> EvilTerran: using a recursive gadt might be useful, maybe
07:11:04 <ivanm> quicksilver: why do you need restrictions? I realise that you can't have 0**(-ve), but in general?
07:12:09 <EvilTerran> Saizan_, eh, i don't think it's really needed for just tuples
07:12:09 <quicksilver> you can't have (-ve) ^ (arbitrary number)
07:12:19 <quicksilver> for example, -1 ^ (1/2) has to be i
07:12:28 <quicksilver> but what is -1 ^ (irrational) ?
07:12:28 <ivanm> duh, not thinking straight
07:12:46 <quicksilver> there is no analytic extension of ^ to the whole of R
07:12:51 <quicksilver> (let alone the whole of C)
07:13:32 <EvilTerran> Saizan_, seeing as "data a :*: as = a :*: !as" gives me ((x::a) :*: (y::b) :*: () :: a :*: b :*: ()), which reads the same as (x::a,y::b) :: (a,b)
07:13:51 <EvilTerran> albeit fuglier
07:14:20 <ivanm> oh sh*t... hmatrix keeps throwing gsl errors :s
07:14:29 * EvilTerran notes it might be possible to write some TH you wrap your whole program in to steal the tuple syntax
07:14:48 <quicksilver> EvilTerran: yes, indeed.
07:14:55 <quicksilver> EvilTerran: although a proper notion of 'source filter' might be nicer.
07:15:00 <EvilTerran> $(withPairTuples [d| {- the whole file -} |])
07:15:06 <quicksilver> type-safe whole-file preprocessing.
07:15:12 <EvilTerran> yeah, it'd be nice to not have to have a |]) at the end, at least
07:15:43 <quicksilver> a proper notion of type-safe whole file preprocessing would really open up the stage to haskell-like language development
07:15:52 <quicksilver> you could do all kinds of things as source transforms.
07:15:57 * EvilTerran notes that this might also be a job for uniplate
07:16:07 <quicksilver> of course the error messages would look like evil slimy things
07:16:10 <quicksilver> but you can't win em all.
07:16:14 <EvilTerran> yeah =/
07:16:28 <quicksilver> you need a formal ADT for GHC type errors
07:16:34 <EvilTerran> that'd be nice
07:16:35 <quicksilver> then you could do type-safe error post-processing
07:16:41 <quicksilver> to match your source pre-processing
07:16:50 <quicksilver> and then you'd really have a language construction toolkit.
07:16:59 <quicksilver> (does ocaml do some of this stuff with ocamlp?)
07:17:07 <EvilTerran> if we had a compiler that were factored into libraries for parsing, typechecking, etcetc, that'd be good
07:17:26 * dcoutts has finally booked flights and registered for ICFP
07:17:32 * EvilTerran has been thinking a bit about extensible parsers
07:17:55 <quicksilver> EvilTerran: that's the direction it's going, thanks to nominolo and others.
07:17:59 <quicksilver> EvilTerran: it's a long road though.
07:18:40 <EvilTerran> i think you'd want to represent them as a Map Nonterminal [Either Nonterminal Terminal] or something like that
07:19:28 <EvilTerran> probably have a compileParser function
07:19:52 <EvilTerran> but you could get an existing parser, add a bit to it that would previously be a parse error, then compile that
07:20:01 <EvilTerran> so you could trivially add syntax to an existing language (eg haskell :D)
07:20:33 <EvilTerran> you'd probably need sth like Data Types A La Carte for the parse tree
07:20:37 <quicksilver> isn't that complicated by the fact the parser isn't context-free?
07:20:46 <quicksilver> adding new syntax has non-local effects?
07:20:50 <EvilTerran> well, i haven't thought it through in full
07:21:05 <EvilTerran> but it'd need to be a lot more concrete than a monadic parser
07:21:14 <EvilTerran> and probably more so than an arrow parser, too, although that might be usable
07:22:54 <EvilTerran> ah well, this'll give me something to think about on the long walk i'm about to head off on :)
07:22:57 * EvilTerran -> away!
07:27:41 <quicksilver> ./win 27
07:27:43 <quicksilver> grrr
07:27:47 <quicksilver> ./lose!
07:28:06 <lilac> zsh: no such file or directory: ./lose!
07:28:29 <quicksilver> hmm. You really shouldn't set zsh to execute commands sent to you in IRC :P
07:28:49 * lilac is secretly a bot written in zsh script
07:29:40 <lilac> and in any case, if you think that's bad, you should see what that 'win' binary you just ran did :)
07:30:19 <ivanm> lilac: it told you where you wanted to go today?
07:31:00 <lilac> :( yes
07:31:03 * lilac feels dirty
07:31:56 * ivanm passes lilac a bar of soap aka a disk formatter
07:32:37 <Botje> you made soap magnetic?!
07:32:41 <Botje> best invention evar!
07:32:57 <ivanm> Botje: no, sliced bread is still better!
07:34:11 <Botje> :)
08:11:18 <Feuerbach> Can anybody halp with defining Either monad? I think I know what the problem is but have no idea how to fix it. http://hpaste.org/10138
08:11:41 <dmead> > mapM print [1..10]
08:11:45 <lambdabot>   mueval: Prelude.read: no parse
08:11:46 <lambdabot>  mueval: *** Exception: "<IO [()]>"
08:11:51 <dmead> > map print [1..10]
08:11:54 <lambdabot>   mueval: Prelude.read: no parse
08:11:54 <lambdabot>  mueval: [*** Exception: "<IO ()>"
08:11:57 <dmead> wat
08:12:03 <Feuerbach> If that helps, I'll use it for _one_ particular Either type, but I need do-notation for it
08:12:24 <Valodim> dmead: you can't use IO in lambdabot
08:12:39 <dmwit> Feuerbach: There's already an instance for Either, isn't there?
08:12:48 <dmead> ah yes
08:12:52 <Feuerbach> dmwit: no, there's only for EitherT
08:13:02 <dmwit> ?instances Monad
08:13:03 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
08:13:10 <dmwit> \bot disagrees
08:13:16 <Feuerbach> wow.
08:13:20 <dmwit> Feuerbach: But you need (Error e) => in front.
08:13:20 <quicksilver> there is one
08:13:27 <quicksilver> but Feuerbach's quesiton is still interesting.
08:13:32 <quicksilver> why won't his code infer?
08:14:03 <Feuerbach> quicksilver: because compiler isn't sure that Left _ -> x will typecheck
08:14:18 <xif> Hi. I read through the Tim Sweeney presentation about the possible use of Haskell in the future of game development. Is there any other material about it?  Anything that elaborates on the ideas in that presentation, or adds another perspective?
08:14:19 <Feuerbach> only I know that it must be "Left"
08:14:27 <dmwit> Feuerbach: You have to do
08:14:32 <dmwit> Left x' -> Left x'
08:14:42 <dmead> Feuerbach, don't use _
08:14:52 <Feuerbach> dmwit: good option, I'll try it
08:14:56 <dmwit> (i.e. you need to allow 'x' to become an Either of a different type)
08:15:01 <quicksilver> ah, of course.
08:15:07 <quicksilver> Feuerbach: do you understand?
08:15:15 <quicksilver> "x" could be Either Error String
08:15:18 <Wild_Cat> xif: Tim "Epic Games" Sweeney? Do you have a link to that presentation?
08:15:27 <quicksilver> but the intended return type of  "f" could be Either Error Int
08:15:32 <xif> Wild_Cat: sure: http://www.willamette.edu/~fruehr/254/Tim-POPL.ppt
08:15:33 <quicksilver> you have to allow the Left to 'switch types'
08:15:34 <Feuerbach> it works, thanks :)
08:15:37 <Feuerbach> yep
08:15:48 <quicksilver> stupid me for not spotting it.
08:15:57 <quicksilver> quicksilver-- # dumb
08:16:15 <xif> Wild_Cat: (if it's the first time you heard about this presentation, but are familiar with Tim and Epic, you're in for a surprise ;)
08:16:30 <Wild_Cat> Ta.
08:16:52 <Wild_Cat> xif: 404 :(
08:17:14 <xif> hm, sec, I'll find a better link (otherwise, I'll upload the one I have)
08:18:26 <xif> Wild_Cat: http://cag.csail.mit.edu/crg/papers/sweeney06games.pdf
08:18:28 <lambdabot> Title: Microsoft PowerPoint - Tim-POPL
08:18:34 <xif> seems the be the same one.
08:18:50 <Wild_Cat> This one works. Cheers.
08:19:27 <Feuerbach> > Right 3 >>= Right.(^2)
08:19:30 <lambdabot>   Add a type signature
08:19:44 <Feuerbach> > Right 3 >>= Right.(^2) :: Either Int Int
08:19:49 <lambdabot>       No instance for (Error Int)
08:19:49 <lambdabot>        arising from a use of `>>=' at <inte...
08:20:02 <dmwit> > fmap (^2) (Right 3) :: Either String Int
08:20:06 <lambdabot>   Right 9
08:20:21 <dmwit> > ap (Right (^2)) (Right 3) :: Either String Int
08:20:24 <lambdabot>   Right 9
08:21:23 <Feuerbach> dmwit: any ideas why ghci doesn't see Functor(Either a) even when I :m +Data.Either?
08:21:32 <arj__> join #postfix
08:21:50 <quicksilver> Feuerbach: I suspect it's in Control.Monad.Instances
08:21:58 <quicksilver> that's where the miscellaneous Functor instances live
08:21:58 <dmead> whats the correct way to map print over a list?
08:22:01 <quicksilver> (against all expectations)
08:22:05 <dmead> when the list has no IO in it
08:22:10 <quicksilver> dmead: mapM_ print [list]
08:22:11 <byorgey> dmead: use mapM_
08:22:19 <dmead> whats the _ for?
08:22:27 <quicksilver> to say you don't care about the return values
08:22:30 <dmhouse> dmead: it throws away the result
08:22:32 <dmead> ah
08:22:35 <quicksilver> (print returns a list of (), so you don't carea bout those)
08:22:40 <quicksilver> mapM print [list] would work fine
08:22:40 <dmead> ?src mapM_
08:22:40 <lambdabot> mapM_ f as = sequence_ (map f as)
08:22:48 <quicksilver> but would waste time constructing and discarding a list of ()
08:22:55 <dmead> mapM print  [list] won't work
08:22:59 <Feuerbach> quicksilver: why then haddock lists that instance for Data.Either? Is he smarter than ghci?
08:22:59 <dmead> or rather
08:23:00 <dmead> doesn't work
08:23:13 <byorgey> well, probably because it doesn't have the right type
08:23:20 <quicksilver> dmead: that was a kind of clumsy pseudo syntax
08:23:24 <Feuerbach> http://hackage.haskell.org/packages/archive/base/3.0.1.0/doc/html/Data-Either.html
08:23:26 <lambdabot> Title: Data.Either, http://tinyurl.com/68zx8m
08:23:28 <dmead> byorgey, thats like the most generic error in haskell
08:23:30 <quicksilver> dmead: as in mapM print [a,list,here]
08:23:30 <byorgey> mapM print [list] has type IO [()]
08:23:40 <byorgey> whereas mapM_ print [list] has type IO ()
08:23:46 <byorgey> dmead: yes, and also the most useful =)
08:23:53 <dmead> =)
08:24:04 <quicksilver> Feuerbach: haddock doesn't list instances where they are declared
08:24:17 <quicksilver> Feuerbach: it lists instances where it thinks you might be interested in finding out about them.
08:24:23 <quicksilver> Feuerbach: it's a kind of cross-linking feature
08:24:39 <byorgey> dmead: I think quicksilver's point was that if you used  'mapM print [list]' in a context which was expecting that type, it would correctly print out the list, just like mapM_
08:24:53 <dmead> right
08:24:59 <byorgey> but it would construct a useless list of ()'s
08:25:03 <quicksilver> and "do" blocks are written to not care about ignored return values
08:25:09 <quicksilver> which in some respects is a shame
08:25:17 <quicksilver> but in other respects the alternative would be a nightmare :)
08:25:52 <byorgey> quicksilver: why is it a shame?
08:26:41 <quicksilver> because arguably it indicates a bug if you discard a return value without explicitly asking to.
08:26:45 <quicksilver> in many APIs at least.
08:27:05 <quicksilver> but, equally, in many other APIs there are return values which are actually intended to be discarded quite often.
08:27:16 <quicksilver> it's one place the type checker could help us where it currently doesn't, though.
08:27:28 <Feuerbach> quicksilver: I thought when haddock lists an instance, it's at least (re-)exported from that module
08:27:37 <quicksilver> Feuerbach: nope.
08:28:23 <Feuerbach> and what can be the reason for Data.Either not to re-export instances?
08:28:52 <quicksilver> it doesn't import them.
08:28:57 <quicksilver> it has no idea those instances exist.
08:29:19 <quicksilver> I don't think threre is a good reason.
08:29:24 <quicksilver> Just a hysterical raisin.
08:29:42 <Feuerbach> ok
08:29:55 <quicksilver> instances are global in haskell anyway
08:30:01 <quicksilver> which is why there isn't a way to restrict import/export
08:47:15 <Wild_Cat> xif: hrmm. Epic considering a switch to a FP language is an interesting development.
08:47:37 <quicksilver> Wild_Cat: I was very disappointed that GLSL and HLSL are so incredibly non-FP-like.
08:47:43 <xif> Wild_Cat: definitely. I'm looking for more material about it.
08:47:55 <quicksilver> Wild_Cat: I mean, shaders always seemed like a potentially declarative concept
08:48:01 <quicksilver> and they went for a cut down version of C :-(
08:48:16 <Wild_Cat> I admit I agree with most of Tim Sweeney's point.
08:48:56 <Wild_Cat> and he's right about GHC's error messages being crap, even though he says they're a language misfeature where they're just an (important) implementation problem.
08:49:50 <quicksilver> Wild_Cat: it's a fact about the language that it's bloody hard to get the error messages nice.
08:50:01 <quicksilver> Wild_Cat: maybe it's unfair to call it 'misfeature'
08:50:12 <quicksilver> but it's definitely a property of the language.
08:50:30 <Wild_Cat> however, Haskell's the only language I know that fits all his requirements. ML is neither lazy nor threadable, IIRC.
08:50:32 <quicksilver> of course compiler writers solve hard problems all the time :)
08:50:36 <xif> Unreal 4 being written in a functional language would be huge. unfortunately, I can't find any evidence of how serious it is.
08:50:50 <xif> Wild_Cat: O'Caml might be an alternative he'd cosider.
08:50:55 <quicksilver> more likely they'd start by putting functional elements into their "scripting" language.
08:50:59 <quicksilver> I would guess?
08:51:15 <Wild_Cat> quicksilver: I doubt that. The scripting language is probably the most likely to remain imperative.
08:51:15 <xif> (it doesn't fit all his requirements, but Haskell doesn't quite fit them all as well)
08:51:41 <quicksilver> Wild_Cat: reactive scripting for game engines = win!
08:51:58 <quicksilver> Wild_Cat: just you wait until my haskell project written entirely in my spare time eclipse's epic's next blockbuster!
08:52:02 <quicksilver> or not.
08:52:02 <Wild_Cat> quicksilver: you can do event-driven imperative.
08:52:47 <Wild_Cat> and the scripting parts don't need to scale. They use no CPU time compared to the actual game (hence the switch to Lua, Python and UnrealScript).
08:53:07 <quicksilver> of course you can do event-driven imperative.
08:53:11 <quicksilver> but I still say reactive = win!
08:54:59 <Wild_Cat> also, the scripting has to remain the easiest part of the game engine to pick up, because it'll be exposed to the whole world. A game engine success is measured by its moddability. And you can't seriously expect kids with no experience in programming to pick up monads. "when X happens do Y" is a more immediate concept IMO ;)
08:57:01 <Saizan_> but writing reactive values is probably way simpler than coordinating event-driven callbacks?
08:57:14 <quicksilver> Saizan_: In principle. Given the right combinators.
08:57:22 <Wild_Cat> I have no experience in reactive programming, so I can't answer that.
08:57:36 <quicksilver> and disguising those combinators in a way which makes them attractive, perhaps even with a GUI
08:57:36 <Wild_Cat> I'm still in the process of "getting" the basic parts of Haskell, really ;)
08:57:58 <mapreduce> You might overestimate the difficulty of monads.
08:58:07 <quicksilver> I think reactive-style programming is more readily GUI-able / diagrammable than imperative programming.
08:58:17 <mapreduce> > map (*2) [1..10]
08:58:20 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
08:58:21 <quicksilver> but, I'm only guessing.
08:58:28 <quicksilver> well, informed guess.
08:58:30 <mapreduce> I think that's much easier than the equivalent for loop.
08:59:55 <Wild_Cat> mapreduce: to tell the truth, I still don't understand why lists are monadic.
09:00:47 <mapreduce> Wild_Cat: Consider List, which knows how to compute n elements.
09:01:05 <mapreduce> Wild_Cat: Consider also Maybe, which knows how to compute 1 or 0 elements.
09:02:00 <Wild_Cat> mapreduce: Both have trivial non-monadic definitions.
09:02:06 <mapreduce> One can write a function to apply a function to every element of either of these, but there's no obvious type that that function could have unless you have subtyping and make a Mappable interface or something.
09:02:28 <Wild_Cat> mmh... Right.
09:02:53 <mapreduce> Lists are monadic because you can make a monad instance from them.
09:02:55 <Saizan_> Wild_Cat: both are defined non-monadically in haskell too, it's just that we also note they have return adn (>>=) which obey the monad laws
09:03:53 <Wild_Cat> > let a = Nothing :: (Maybe Int) in map (*2) a
09:03:57 <lambdabot>   Couldn't match expected type `[a]'
09:04:09 <Saizan_> use fmap
09:04:12 <Saizan_> ?type map
09:04:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:04:16 <Saizan_> ?type fmap
09:04:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:04:26 <Wild_Cat> @src map
09:04:26 <lambdabot> map _ []     = []
09:04:26 <lambdabot> map f (x:xs) = f x : map f xs
09:04:31 <Wild_Cat> @src fmap
09:04:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:04:33 <Saizan_> map is the restriced version for lists
09:04:38 <Saizan_> @src Maybe fmap
09:04:39 <lambdabot> fmap _ Nothing       = Nothing
09:04:39 <lambdabot> fmap f (Just a)      = Just (f a)
09:04:47 <Saizan_> @src [] fmap
09:04:47 <lambdabot> fmap = map
09:04:54 <Wild_Cat> aha.
09:05:03 <Saizan_> are you familiar with type classes?
09:05:05 <Wild_Cat> @src mapM
09:05:05 <lambdabot> mapM f as = sequence (map f as)
09:05:12 <Wild_Cat> Saizan_: yup.
09:05:38 <Saizan_> ok then :)
09:05:38 <Wild_Cat> coming from an OO background, I identified type classes as a Very Useful Feature early on :D
09:05:58 <Twey> Haha
09:06:10 <Wild_Cat> and I'd probably have defined Mappable / Foldable type classes had I been writing the Prelude.
09:06:30 <mapreduce> Type classes are statically resolved.
09:06:34 <Saizan_> there's a Foldable :)
09:06:39 <Twey> I think there are classes that do that.
09:06:48 <Twey> Mappable would be Functor?
09:06:49 <Saizan_> Mappable = Functor
09:06:52 * Twey nods.
09:07:03 <mapreduce> @instances Functor
09:07:04 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:07:07 <quicksilver> type classes == OO classes is a poor intuition.
09:07:11 <Twey> See, I'm learning, I'm learning!  .o'a
09:07:13 <quicksilver> (just in case that's what you were thinking)
09:07:21 <Wild_Cat> quicksilver: type classes == OO interfaces, actually.
09:07:21 <quicksilver> type classes == interfaces is just slightly better
09:07:32 <quicksilver> type classes == operator overloading is the best, though.
09:07:42 <mapreduce> Emulating type classes in Java/C# is pain.
09:07:53 * Twey identified them with CLOS generics.
09:08:13 <Wild_Cat> okay, so Functor is what I'd have called Mappable. We're back to fmap being easy to define on Maybe and [] without resorting to monad laws. Or am I missing something?
09:08:23 <mapreduce> CLOS generics are dispatched at runtime.
09:08:35 <quicksilver> Wild_Cat: no, you're missing nothing.
09:08:45 <quicksilver> Wild_Cat: Maybe and [] are both vyer useful indeed without talking about monads.
09:08:56 <Saizan_> Wild_Cat: right, but Monad gives you more interesting operations than just fmap
09:08:59 <quicksilver> monads are something extra, on top of what we've discussed so far.
09:09:00 <Wild_Cat> so it still doesn't answer my original question, which is "why are they monads?"
09:09:09 <quicksilver> Maybe is a monad because of this:
09:09:25 <Twey> > (Just 5) >>= return . (*5)
09:09:28 <lambdabot>   Just 25
09:09:36 <Twey> > Nothing >>= return . (*5)
09:09:40 <lambdabot>   Nothing
09:09:42 <quicksilver> case mx of Nothing -> Nothing ; Just y -> case f y of Nothing -> Nothing; Just z -> case g z of Nothing -> Nothing; Just omega -> ....
09:09:48 <quicksilver> that's why you want maybe to be a monad.
09:09:50 <Saizan_> Twey: that reduces to fmap thogh :)
09:09:56 <mapreduce> Wild_Cat: Because they are instances of the Monad typeclass and follow it's laws properly.
09:09:59 <quicksilver> because when you start using maybe you end up with loads of case statements
09:10:09 <quicksilver> where the 'Nothing' parts trail off to Nothing
09:10:10 <mapreduce> its*
09:10:13 <quicksilver> and the 'Just' parts keep going.
09:10:20 <Twey> Saizan_: Aye, but not everything using bind does :)
09:10:26 <Wild_Cat> quicksilver: aha!
09:10:29 <quicksilver> The monad instance for maybe just abstracts that pattern
09:10:35 <quicksilver> "Nothing" meaning -> stop now, this isn't working
09:10:48 <Wild_Cat> it's a shortcut, then. Somewhat akin to exception propagation.
09:10:59 <quicksilver> it's very like exception propagation
09:11:01 <Twey> Aye.
09:11:06 <quicksilver> except we're storing no information in the exception
09:11:14 <Twey> (Either does that)
09:11:24 <quicksilver> "Either Exception a" is an upgrade of the maybe monad
09:11:24 * Twey frowns.
09:11:28 <Twey> I need to learn Either
09:11:29 <quicksilver> which has the same style of semantic
09:11:38 <quicksilver> but allows you to indicate "why we stoppped"
09:11:44 <quicksilver> instead of just "it didn't work"
09:11:48 <Saizan_> and list is another upgrade where the successful part gives multiple results
09:12:05 <quicksilver> (here 'Exception' is supposed to stand for any sensible type, chosen by you, to model things that go wrong)
09:12:14 <quicksilver> not some built-in Exception type, in general.
09:12:16 <Wild_Cat> quicksilver: so, your massive case above could reduce to answer mx = mx >>= f >>= g, right?
09:12:26 <quicksilver> Wild_Cat: >=> actually
09:12:30 <quicksilver> but that's the idea.
09:12:32 <Wild_Cat> where answer mx :: Maybe Result
09:12:41 <Wild_Cat> :t (>=>)
09:12:43 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:12:50 <Wild_Cat> :t (>>=)
09:12:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:13:09 <quicksilver> they're very similar.
09:13:28 <quicksilver> >=> is the associative version, in a way.
09:13:29 <Saizan_> >>= was right i think, you were feeding the content of the Maybe to f and g, not the whole maybe
09:13:47 <quicksilver> hmm, yes
09:13:56 <quicksilver> (mx >>= f) >>= g
09:13:58 <quicksilver> is the same as
09:14:03 <quicksilver> mx >>= (f >=> g)
09:14:07 <Saizan_> right
09:14:15 <Wild_Cat> Saizan_: well, I expect f :: WhateverMxReturnsAsJust -> Maybe ResultFromF
09:14:24 <quicksilver> same reason as f $ g $ x and f . g $ x
09:14:28 <Wild_Cat> and g :: ResultFromF -> Maybe ResultFromG
09:14:33 <quicksilver> only written the other way around.
09:14:39 <quicksilver> Wild_Cat: anyhow I think you got the idea :)
09:14:47 <quicksilver> slight errors on my part notwithstanding.
09:15:01 <Wild_Cat> Yeah, I think I get the idea.
09:16:52 <Wild_Cat> now what of lists?
09:17:11 <Twey> Lists... do combinin'
09:17:21 <Wild_Cat> propagation of [] instead of Nothing, or is there more to it?
09:17:51 <Saizan_> with lists you have multiple results
09:17:52 <Twey> > [1, 2, 3] >>= return . (*2) >>= return . (-3)
09:17:55 <lambdabot>       No instance for (Num (b -> b1))
09:17:55 <Wild_Cat> (actually no, propagation of [] makes no sense, it's pretty much automatic)
09:17:55 <lambdabot>        arising from a use of `negate' a...
09:17:58 <Twey> Ack
09:18:15 <lilac> > [1, 2, 3] >>= \x -> [2*x, 5*x]
09:18:19 <lambdabot>   [2,5,4,10,6,15]
09:18:34 <lilac> the list monad produces all possible results
09:18:40 <Saizan_> case mx of [] -> []; xs -> case concat (map f xs) of [] -> []; xs -> ....
09:19:07 <Saizan_> Wild_Cat: it models non-deterministic computations
09:19:57 <lilac> due to laziness, it performs a depth-first search with backtracking
09:19:57 <Wild_Cat> mmh... A kind of shortcut, again. I'm not certain it's more readable, unlike the Maybe one.
09:20:15 <quicksilver> Wild_Cat: try something like this then:
09:20:22 <lilac> Wild_Cat: list comprehensions are basically another way of using the list monad
09:20:29 <lilac> and they're very useful in practice
09:20:52 <Wild_Cat> lilac: yeah, due to similarities with the do notation, I somehow suspected LCs had to do with the monadic nature of lists.
09:21:02 <quicksilver> > do { suit <- "HDCS"; num <- "A23456789JQK"; return (suit,num) }
09:21:05 <lambdabot>   [('H','A'),('H','2'),('H','3'),('H','4'),('H','5'),('H','6'),('H','7'),('H'...
09:21:12 <quicksilver> house of cards!
09:21:16 * Twey laughs.
09:21:33 <quicksilver> the list monad lets you work with multiple possible worlds conceptually in parallel.
09:21:37 <quicksilver> (not really in parallel, though)
09:21:45 <quicksilver> so you can explore multiple possibilities at once.
09:21:59 <quicksilver> in reality it's a depth-first search, but you can cut branches
09:22:11 <quicksilver> and depth-first search is a fairly useful general technique.
09:22:12 <Beelsebob> > (fmap (,) "HDCS") <$> "A23456789JQK"
09:22:15 <lambdabot>   Couldn't match expected type `a -> a1'
09:22:22 <Wild_Cat> > [(suit, num) | suit <- "HDCS", num <- "A23456789JQK"]
09:22:25 <lambdabot>   [('H','A'),('H','2'),('H','3'),('H','4'),('H','5'),('H','6'),('H','7'),('H'...
09:22:28 <Beelsebob> > fmap (,) "HDCS"
09:22:31 <lambdabot>       Overlapping instances for Show (b -> (Char, b))
09:22:31 <lambdabot>        arising from a u...
09:22:47 * Beelsebob ponders why that doesn't work
09:22:48 <Wild_Cat> right, so LCs *are* syntactic sugar for do notation.
09:22:54 <Saizan_> > (,) <$> "HDCS" <*> "A23456789JQK"
09:22:57 <lambdabot>   [('H','A'),('H','2'),('H','3'),('H','4'),('H','5'),('H','6'),('H','7'),('H'...
09:23:04 <Beelsebob> well sure, but why doesn't the other work
09:23:08 <Beelsebob> > (fmap (,) "HDCS") <$> "A23456789JQK" -- this one
09:23:11 <lambdabot>   Couldn't match expected type `a -> a1'
09:23:14 <Saizan_> Wild_Cat: they do more than do-notation, since you can put guards
09:23:23 <Wild_Cat> Saizan_: right.
09:23:54 <Saizan_> Beelsebob: because <$> /= <*>
09:24:02 <Beelsebob> oh, no, neither it does
09:24:03 <Beelsebob> >.<
09:24:11 <Beelsebob> > (fmap (,) "HDCS") <*> "A23456789JQK" -- this one
09:24:15 <lambdabot>   [('H','A'),('H','2'),('H','3'),('H','4'),('H','5'),('H','6'),('H','7'),('H'...
09:24:19 <Beelsebob> better :)
09:24:33 <Saizan_> ?type guard
09:24:35 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:24:35 <lilac> Saizan_: i'm not sure that's true; monads permit guards without MonadPlus
09:25:12 <lilac> ?type \b -> do True <- return Bool; return ()
09:25:14 <lambdabot> Not in scope: data constructor `Bool'
09:25:18 <lilac> ?type \b -> do True <- return b; return ()
09:25:20 <lambdabot> forall (t :: * -> *). (Monad t) => Bool -> t ()
09:25:38 <Saizan_> sssh, that's fail and it shouldn't be there!
09:25:44 <Saizan_> ;)
09:25:59 <lilac> Saizan_: actually, i disagree with that, but i don't want to be flamed, so pretend i said nothing
09:26:08 <Wild_Cat> well, I have to be going. This was enlightening, thank you folks.
09:26:40 <Wild_Cat> see you around.
09:27:20 <Saizan_> lilac: a lot of monads lack a sensible definition of fail, and since it's not fundamental for the other operations i feels more reasonable to have it in a distinct class
09:27:48 <Saizan_> in fact in 1.4 they had MonadZero iirc
09:28:09 <Saizan_> s/i/it/
09:28:23 <lilac> Saizan_: would you prefer that (a) do notation with refutable patterns requires MonadFail, or (b) patterns in do are treated as irrefutable, or (c) something else ?
09:28:33 <Saizan_> (a)
09:29:50 <lilac> to be honest, (a) doesn't sound too bad, but i worry that it'd require lots of actually-irrefutable-but-Haskell-doesn't-know-that cases to have the ~ added
09:30:00 <lilac> i guess the ~ is good documentation, though...
09:30:39 <lilac> looks like Haskell' will keep Monad fail, in any case, so i guess we have to put up with it
09:30:41 <Saizan_> you can use that or a let
09:31:16 <lilac> quite frankly, the fact that let *doesn't* call fail on a pattern match error is in my opinion a bug
09:31:37 <Feuerbach> is there kind of zipper which "remembers" the root? I.e. which can reproduce partial ordering induced by the tree with root.
09:31:43 <lilac> i oftren find myself writing 'pattern <- return value'
09:32:46 <Saizan_> so you'd like let in do-notation to desugar to that?
09:33:02 <lilac> yes, i think that'd be an improvement
09:33:17 <lilac> or avoid the return and bind altogether
09:33:46 <lilac> although i guess you can't actually avoid them, can you? :)
09:33:55 <Saizan_> Feuerbach: what do you mean? zippers usually remember the root, but not in a O(1) to access point
09:34:42 <Saizan_> lilac: for fail to be useful you've to connect it with the rest of the monadic expression, so you can't avoid >>=
09:35:00 <lilac> right, i realised that a little too late :)
09:35:10 <lilac> IRC needs an 'undo' button :)
09:35:54 <lilac> you can avoid the return, though, i think?
09:36:00 <Saizan_> also you'd be implementing a non-recursive let, unless you require MonadFix
09:36:26 <Feuerbach> Saizan_: oh.. I think I got it
09:37:05 <lilac> you could still get recursion from "let ... in do"
09:37:33 <pmurias> why does haskell have both map and fmap?
09:37:55 <lilac> pmurias: i'm told it's because the Haskell98 committee didn't like polymorphism
09:38:03 <Saizan_> pmurias: so we don't have to explain the Functor typeclass to beginners that want to use lists
09:38:44 <lilac> Saizan_: it sounds to me like Haskell98 was in many ways a step backwards
09:40:40 <lilac> this MonadZero thing sounds pretty sensible
09:40:49 <Saizan_> lilac: i never used haskell before h98, but i tend to agree
09:40:56 * lilac likes the way proc notation requires exactly the typeclasses you use
09:41:44 <pmurias> so the map/fmap duplication was intendend rather then a historical consequence
09:42:49 <quicksilver> pmurias: something of both.
09:43:02 <quicksilver> it is a historical accident that the situation is as it is.
09:43:13 <quicksilver> but it was a concious decision to preserve that history in the standard.
09:43:32 <pmurias> seem a bit silly
09:43:36 <pmurias> * seems
09:43:53 <quicksilver> in retrospect I would favour "map" for the method of Functor, and mapList for the list specialisation.
09:44:14 <quicksilver> I think that meets the requirement for a monomorphic version for teaching and simpler error messages
09:44:17 * quicksilver shrugs
09:44:20 <quicksilver> it's a bit late now thaough.
09:50:02 <ddarius> Install a pre-H98 implementation
09:50:08 <ddarius> HBC is a decent one.
09:51:49 <quicksilver> ;)
09:53:40 <bos> @seen dons
09:53:40 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 8h 9m 53s ago.
09:53:46 <bos> @seen dcoutts
09:53:47 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #darcs, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 2h 36m 20s ago.
09:53:51 <bos> hm.
09:56:44 <ddarius> I wonder if I port all of Hackage to Haskell 1.4 if I can get the GHC folks to add a H14 flag.
10:00:23 <quicksilver> ddarius: I'm sure if you write the code for the H14 flag they'd commit it.
10:00:31 <quicksilver> Well, I'm not entirely sure, But I suspect they would.
10:01:12 <ddarius> I guess I could do that.
10:11:54 <augustss> a H14 flag would be cool
10:13:44 <twanvl> Do we have Haskell 14 already?
10:14:27 <augustss> if we 98 we have 14
10:14:39 <augustss> 7*14 = 98
10:14:41 <lilac> quicksilver: Haskell 1.4 had 'map' as the Functor method
10:15:27 <augustss> the eta rule was valid in H1.4
10:15:44 <lilac> (likewise (++) was in MonadPlus, filter was filterM and concat was join, i think)
10:16:25 <lilac> ... filter wasn't filterM but was similar in spriti
10:21:54 <psnively> Hello Haskellites!
10:23:23 <augustss> Hello Snivelite :)
10:23:45 <psnively> I'm more of a snivel-heavy, actually. :-D
10:23:55 <augustss> heh
10:24:54 <psnively> Anyone know what the status of JHC is, or DHC? I keep hoping for something like one of them, I guess. Supercompiler or non-lazy Haskell...
10:25:41 <Twey> Strict Haskell?  But why?
10:27:05 <psnively> Because of the difficulties in reasoning about space/time costs in lazy languages.
10:27:55 <roconnor> psnively: just space costs
10:28:19 <roconnor> psnively: the time costs are always less than or equal to the time costs of strict evaluation.
10:28:41 <b\6> is subtracting getCPUTimes how i should find how many ms something took? super accuracy isn't needed.
10:29:19 <roconnor> b\6: that's how I do it
10:29:22 <psnively> roconnor: Really? Hmmm.
10:29:32 <b\6> roconnor: thanks.
10:29:46 <roconnor> b\6: just be careful that what you want to evaulate is really being done between the two calls to getCPUTimes
10:29:56 <roconnor> psnively: almost by definition of lazy evaluation
10:30:13 <psnively> Almost.
10:30:48 <Deewiant> of course there's lazyness overhead
10:31:00 <Deewiant> s/y/i/
10:31:02 <roconnor> well, if you think that strick evaluation also entails access to mutation, then the argument becomes more complex.
10:31:25 <roconnor> and I'm talking about asymtotic time here.
10:31:44 <roconnor> sctrict
10:31:46 <roconnor> strict
10:32:00 <dblazakis> roconnor: wouldn't the (possibly much) larger amount of allocation churn create possibly significant runtime overhead?
10:32:10 <dblazakis> possibly ;-)
10:32:12 <roconnor> dblazakis: only a constant factor
10:32:29 <Deewiant> yeah, the /asymptotic/ costs are the same.
10:33:21 <lilac> a computer scientist returns home to find his house has been consumed in a fire. the fireman says "i'm sorry, 90% of the house was destroyed". the compsci says, "don't worry, it's only worse by a constant factor".
10:33:49 <psnively> Back later.
10:34:14 <roconnor> dblazakis: the reason lazy code is are sometimes slower in practice is exactly what you say.  The potentially large space usage creates a large overhead.
10:34:51 <dblazakis> roconnor: does the intelligence of the allocator affect this much? is it simply allocation overhead or are there other time sinks?
10:35:50 <roconnor> there is also the laziness overhead Deewiant talked about.  I'm not sure, but I think they pale in comparison to the allocation issues (granted they are also somewhat related to the allocation issues)
10:37:11 <roconnor> I doubt the intelligence of the allocator affects this much.
10:37:54 <dblazakis> i could imagine a lazy program missing the cache more often, but i don't know if that would be a reality or if it would be noticable if it did
10:39:15 <dblazakis> where's the obligatory spj paper showing me numbers? :-)
11:12:33 <Baughn> @src enumFromTo
11:12:34 <lambdabot> Source not found. :(
11:12:40 <Baughn> @src Float enumFromTo
11:12:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:13:45 * Baughn wonders why [0.0,0.2..3.8] winds up printing 3.800000000000001, when there is a perfectly good number that actually does print as 3.8
11:13:50 <roconnor> ugh, float shouldn't be a member of enum
11:14:15 <Botje> random fp weirdness :)
11:14:22 <Baughn> I'd claim it's convenient, except for stuff like this
11:14:47 <roconnor> I had this discussion before, and I think the conclusion was to split enum into two classes
11:14:55 <Baughn> Fortunately I don't have to deal with FP a lot. Passing ints into a gpu as floats was.. an adventure. ^^;
11:14:56 <Beelsebob> Baughn: I *think* it's because it's done with repeated adds
11:14:56 <roconnor> but I forget how that was supposed to work
11:15:12 <Beelsebob> I suspect the same thing is causing my mandelbrot implementation to be not quite right
11:15:46 <Baughn> Beelsebob: It's a possibility.
11:15:49 * Baughn goes looking for the source
11:16:34 <roconnor> Beelsebob: don't worry, the mandlebrot set isn't known to be computable. :)
11:16:53 <Saizan_> Baughn: 0.1 is not representable, so the errors accumulate afaiu
11:17:28 <Beelsebob> roconnor: yeh, it's my parallel version for the shootout -- it's gotta match their output
11:17:38 <Baughn> Saizan_: The errors /would/ accumulate (thus why you shouldn't iterate over floats), but I'm starting at 0.2, not 0.1 ;)
11:17:46 <Beelsebob> but 2 of the bytes are wrong
11:17:49 <roconnor> > map fromRational [0.0, 0.2, .. 3.8] :: [Float]
11:17:52 <lambdabot>   mueval: Prelude.read: no parse
11:18:01 <roconnor> > map fromRational [0.0, 0.2 .. 3.8] :: [Float]
11:18:05 <lambdabot>   [0.0,0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.4,3....
11:18:49 <Baughn> Saizan_: Actually, 0.1 /is/ representable, in the "it's the shortest textual representation for a FP number" sense
11:19:58 <Baughn> And thinking of them as ranges gives me less grief overall. ;)
11:22:50 <Saizan_> Baughn: well it's not representable with finite digits in binary, no?
11:23:33 <Baughn> Saizan_: Depends on your definition of "representable". I've given you mine.
11:24:10 <Saizan_> well ok, i was using the IEEE 754 one :)
11:24:23 <Baughn> The one where they have an exact rational value? Sure..
11:24:37 <Baughn> Things really do work better if you regard them as ranges, though. Try it. ;)
11:25:00 <Baughn> (For one thing, it explains why 0.1 prints as 0.1 and not its exact value)
11:31:28 <Myoma> @keal
11:31:29 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
11:31:37 <Myoma> ?faq can haskell pipe the raw irrational megaequation into an analog device
11:31:38 <lambdabot> The answer is: Yes! Haskell can do that.
11:34:29 <dmwit> I'm intrigued by the concept of controlling lasers with five irrational numbers.
11:34:44 <dmwit> Please: explain me how to spell a triangle in less than three corners using dark manifolds!
11:35:06 <Cale> Is that also from Keal?
11:35:15 <Cale> @keal
11:35:15 <lambdabot> all i know is i have experienced my own death unhappening...
11:35:22 <Cale> @keal
11:35:22 <lambdabot> what are epsilons?
11:35:59 <Myoma> what are epsilons!!
11:36:05 <Cale> @keal
11:36:05 <lambdabot> doubles and floats cause b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b) to fuck up
11:36:16 <Cale> @keal
11:36:17 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
11:36:21 <Myoma> @QEAL
11:36:22 <lambdabot> Unknown command, try @list
11:36:28 <Myoma> :[
11:36:40 <Myoma> @KEAL
11:36:41 <lambdabot> Unknown command, try @list
11:36:45 <Myoma> why does this not work ?
11:36:48 <Myoma> @nikon
11:36:48 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
11:42:05 <Myoma> @nikon
11:42:06 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
11:43:04 <dmwit> @nixon
11:43:04 <lambdabot> Sure there are dishonest men in local government. But there are dishonest men in national government too.
11:43:19 <dmwit> heh
11:46:07 <jeffersonheard> http://hpaste.org/10140 -- I get a compile error saying it cannot deduce (Ord a) from `compare`
11:46:29 <Myoma> jeffersonheard: try to move (Ord a, Eq a) => to the instance
11:46:33 <Myoma> instead of in the data
11:47:07 <Heffalump> (Ord a, Eq a) is redundant btw, you can always just use (Ord a)
11:47:08 <jeffersonheard> that's a thought...  but then not all instances of interval would be instances of Ord, no?
11:47:20 <Heffalump> jeffersonheard: are you using GHC and willing to use GHC extensions?
11:47:40 <dmwit> jeffersonheard: It's usually considered bad form to put class restrictions on a data type.
11:47:43 <jeffersonheard> happily
11:47:56 <Heffalump> then use the new where syntax for data declarations, and it'll work
11:48:02 <jeffersonheard> k
11:48:10 <dmwit> jeffersonheard: i.e. there's usually no good reason to prevent somebody from making an Interval out of something that's not an Ord instance, so long as they never need to use the Ord instance.
11:48:27 <Heffalump> dmwit: it's only bad form because Haskell 98 is broken.
11:48:39 <dmwit> Not really.
11:48:48 <dmwit> Or I should say: I disagree.
11:49:55 <jeffersonheard> dmwit, I can see why that's true in the general case, but this isn't library code, and what would an interval look like that can't understand conjunction, disjunction, and overlap?
11:50:12 <dmwit> It would look like an interval.
11:50:13 <jeffersonheard> which you can't have without an ordering, if all you have is a low and hi
11:50:28 <jeffersonheard> not really, since this is an interval on the number line
11:50:36 <jeffersonheard> it would look like a coding error
11:50:41 <dmwit> If I want an (Interval id const), who are *you* to stop me?
11:50:44 <dmwit> =)
11:51:00 <jeffersonheard> define your own interval type then, but don't try to use my code with it
11:51:16 <jeffersonheard> I'm the coder, after all.  I'm exactly the person to stop you from using bad data in my code
11:51:26 <jeffersonheard> 's what type checking's for
11:51:30 <dmwit> No, that's the type-checker's job.
11:51:31 <dmwit> Exactly.
11:51:50 <jeffersonheard> But I'm still using the type-checker
11:51:53 <dmwit> As soon as I try to do (compare (Interval id const))... *that* is when I want an error to occur.
11:52:32 <dmwit> But, as you say: this is a matter of taste.
11:53:03 <jeffersonheard> it is indeed
11:57:47 <Myoma> jeffersonheard: type checker doesn't stop you from using bad data
11:57:53 <dmwit> :t split
11:57:55 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
11:57:59 <dmwit> :t break
11:58:01 <Myoma> jeffersonheard: type checker ensures that _nonsense_ doesn't happen
11:58:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:58:13 <dmwit> > break (== ',') "a,b"
11:58:17 <lambdabot>   ("a",",b")
12:00:51 <Myoma> > (head [], 1/0, fromJust Nothing)
12:00:55 <lambdabot>   mueval: Prelude.read: no parse
12:00:55 <lambdabot>  mueval: (*** Exception: Prelude.head: empty...
12:01:08 <Myoma> > (map (+1) "foo", 7 + "car", reverse Nothing)
12:01:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe a1'
12:02:27 <nominolo> anyone care to review a 6-page draft paper about instruction scheduling, due on Sunday?
12:10:54 <zulusulta> hi how long does it take to learn haskell
12:11:11 <Myoma> 100 years
12:11:13 <Myoma> :))
12:11:21 <trofi> like any natural language :]
12:11:28 <Myoma> you can start writing real and useful programs in a week though
12:12:29 <zulusulta> is it easier to learn haskell or .net
12:12:32 <zulusulta> c#
12:12:47 <zulusulta> cause I know i can get a job with C#
12:12:49 <Myoma> I suggest you learn both, I don't think there's any other way you could know
12:13:08 <Myoma> (which one was easier to learn)
12:13:14 <zulusulta> is there a dot net users group on freenode?
12:13:18 <malune> if its jobs you are looking for, definitely go for C#
12:13:23 <zulusulta> i can't find it
12:13:33 <zulusulta> the thing is I am intrested in machine learning
12:13:35 <Myoma> I think there's a C# channel
12:13:44 <malune> however if you're passionate about programming, learn haskell
12:13:54 <malune> or even Scheme, which is a lighter beginning
12:14:19 <zulusulta> i am intrested in creating progams that can make intellingent decisions
12:14:25 <zulusulta> but i need a job
12:14:36 <malune> both languages allow you to create such programs...
12:14:55 <malune> but Prolog may be what you are looking for
12:14:58 <zulusulta> yeah but C# would get me job to pay for rent
12:15:09 <zulusulta> prolog has no batteries
12:15:14 <dblazakis> zulusulta: if you want a c# channel, try #mono on irc.gimp.net
12:15:24 <zulusulta> thanks
12:15:25 <malune> C has batteries, every language has some sort of communication with C
12:15:30 <Myoma> zulusulta: Batteries?
12:15:54 <zulusulta> framework, libraries
12:16:02 <zulusulta> stuff to do usefull things with
12:16:11 <malune> Python / Java / C#
12:16:21 <Myoma> zulusulta: It's possible to do useful things in Prolog
12:16:54 <malune> Myoma: he wants to be able to get hired though
12:17:22 <zulusulta> yeah need money in the bank
12:17:46 <Myoma> sitting around chatting on IRC never seems to generate much money ...
12:19:29 <zulusulta> lol
12:19:47 <zulusulta> yes but need ideas and inspiration
12:19:50 <malune> zulusulta: how much programming experience have you already got?
12:20:03 <zulusulta> scjp
12:20:19 <malune> ???
12:20:25 <Myoma> Sun Certified Java Programmer
12:20:45 * Myoma considers getting that
12:21:00 <malune> there are lots of jobs available for java programmers... so whats the problem?
12:21:18 <zulusulta> i am a qa
12:21:34 <zulusulta> once i got the cert i never touched java again
12:21:45 <malune> so can you programin java?
12:21:48 <Myoma> zulusulta: Why did you get it?
12:21:59 <zulusulta> yes\
12:22:14 <zulusulta> though it would help to land a job
12:22:31 <b\6> maybe you should find a job doing something you actually *like*.
12:22:37 <b\6> doesn't sound like computers/programming is it.
12:23:07 <zulusulta> yes but i spent 4 years getting a bachelors of comp sci
12:23:18 <b\6> not too late to admit it was a mistake.
12:23:20 <zulusulta> what do I do?
12:23:36 <Myoma> hehe
12:23:40 <malune> to be honest in the industry its probably better to have his attitude
12:23:53 <zulusulta> yes but i have no fall back plan
12:23:54 <malune> learn java, land a job doing entreprise software ...
12:24:10 <malune> thats what most companies seem to want
12:24:16 <_ar> zulusulta: what do you do in your freetime?
12:24:20 <zulusulta> dot net is way easier
12:24:20 <Myoma> @protontorpedo
12:24:21 <lambdabot> so given that how does haskell let one turn business calcualtion anreocrding of info into somethng liek a big spreadsheet?
12:24:26 <zulusulta> watch movies
12:24:36 <zulusulta> surf on the net
12:25:14 * nominolo is looking forward to read about zulusulta on the daily wtf
12:25:20 <Myoma> zulusultra: You should learn haskell! :p
12:25:29 <Myoma> zulusultra: It is a lot of fun
12:25:29 <malune> so you want something easy, which will let you write intelligent software, which will land you a job...
12:25:46 <malune> try Python, I guess
12:26:00 <Myoma> malune: Why not python over haskell ?
12:26:01 <zulusulta> i like python
12:26:10 <Myoma> s/not //
12:26:16 <zulusulta> i learnt it in a week
12:26:35 <_ar> zulusulta: how are your writing skills? you could be a consumer advocate, critic, etc.
12:26:38 <nominolo> that doesn't mean you can actually write decent programs in it
12:26:38 <malune> Myoma: because Haskell has a type system and is generally quite mathematical... Can you really imagine him getting his head around lazy evaluation, pattern matching, types, monads...
12:26:47 <zulusulta> thank job, i was scared u were going to say vb script
12:26:56 <_ar> malune: why not?
12:27:00 <Myoma> malune: You're right! Nobody could ever understand all those crazy things :P
12:27:08 <trofi> :]
12:27:28 <zulusulta> _ar: no minimum wage jobs
12:27:51 <malune> Myoma: I just think its a lot to learn, and can't really be classed as "easy"
12:27:53 <nominolo> i think drug dealing is kinda well-paid
12:28:04 <nominolo> of course, no benefits
12:28:04 <_ar> zulusulta: they're not wage jobs, you'd be self employed
12:28:31 <_ar> of course that is most likely actually worse than minimum wage jobs most of the time
12:28:40 <Myoma> malune: Is Python easy? Can I write more efficient more realible programs in python faster than in haskell?
12:29:03 <_ar> but it plays to the consumption you do in your free time
12:29:06 <malune> Myoma: maybe. :)
12:29:39 <malune> Myoma: but it is definitely easier to read & learn.. Could you have learnt haskell without knowing about lambda calculus & combinatorics?
12:29:43 <_ar> malune: anyone can get used to anything
12:29:48 <nominolo> more efficient only if it's a library call
12:30:08 <nominolo> malune: of course
12:30:20 <nominolo> why would you need that?
12:30:25 <Myoma> I don't know how combinatorics are relevant to haskell
12:30:34 <nominolo> Real Word Haskell contains no LC or combinatorics
12:30:44 <_ar> malune: you certainly can learn haskell without knowing lambda calculus and combinatorics is not very helpful
12:30:53 <malune> nominolo: real world haskell is for people who can already program..
12:31:06 <nominolo> not necessarily
12:31:24 <malune> nominolo: at least, that is what it says in the introduction...
12:31:31 <zulusulta> writing skills are good
12:32:34 <Saizan_> haskell is harder for people who can already program in imperative languages, probably :)
12:32:51 <malune> _ar: well I'm probably wrong anyway, but personally I needed to establish those fundamental principles before I could understand fp..
12:33:06 <malune> (to any degree)
12:34:14 <_ar> malune: i can't argue against your personal experience, but those fundamental principles are there because they've been abstracted from real world stuff.
12:34:19 <_ar> In the sense that real world stuff came first
12:34:42 <malune> _ar: I thought math came first... Church Turing thesis?
12:35:05 <Myoma> How is Church Turing thesis relevant to programmiNG ?
12:35:10 <Saizan_> it's not like math comes from nowhere :)
12:35:27 <malune> how is it not relevant to programming? i don't understand the question
12:36:11 <malune> Saizan_: yes, the greeks came first mwahaha
12:36:45 <dblazakis> i'm still missing how combinatorics is in any way related... do you mean combinatory logic?
12:36:53 <malune> dblazakis: yes
12:36:56 <_ar> malune: the study of functions came from considering rules which to one thing assign another. To each person assign their age, to each farm animal assign a monetary value.
12:37:19 <_ar> malune: it was because these kinds of rules are so common that people thought to study the type of rule itself
12:37:46 <dblazakis> ah, ok -- i still disagree, but i can see the argument :)
12:38:13 <Saizan_> combinatory logic is relevant for pointsfree
12:39:19 <_ar> malune: i guess all i'm trying to say is that you don't need to reason formally to reason correctly
12:40:51 <malune> _ar: I agree with that, but to truly understand what you are programming in FP, I still think exposure at least to the lambda calculus is extremely useful
12:41:47 <_ar> malune: i am not sure anyone truly understands =)
12:42:02 <Myoma> I do!!
12:42:03 <Myoma> :p
12:42:04 <_ar> but theory is good, when you're ready for it...
12:42:38 <_ar> imagine trying to learn something formal, like abstract algebra, without ever having an example to help guide your intuition
12:43:13 <malune> _ar: I guess all I'm trying to say is that when you start programming you are in a middle abstraction, where you grasp what is there... but its important to go in 2 orthogonal directions in your mind from there, one which goes towards the lambda calculus, and the other which goes towards understanding the more complex ideas in whichever language you are learning.
12:43:51 <malune> _ar: of course though I agree that you can never get to the bottom, or the top, of anything
12:44:03 <malune> (at least I don't think so)
12:47:02 <malune> _ar: that is, unless the Y combinator is the bottom. :)
12:48:03 <Saizan_> (Y id) is the bottom
12:56:04 <bos> @seen augustss
12:56:05 <lambdabot> augustss is in #haskell. I last heard augustss speak 2h 32m 9s ago.
13:03:01 <Myoma> does anyone know of some other papers about inverting folds?
13:07:22 <b\6> oh, boy. i missed you.
13:08:01 <mauke> so ... how about a threadWaitRead :: Fd -> STM ()? does that even make sense?
13:10:36 <koninkje> @pl \x y -> f x (g y)
13:10:37 <lambdabot> (. g) . f
13:14:14 <BMAway> Myoma: which papers has you already seen? :)
13:18:10 <Myoma> Inverting Functions as Folds - Mu, Bird
13:18:32 <im_alone> @ggl gasART
13:18:33 <lambdabot> Maybe you meant: ghc pl url
13:19:35 <im_alone> @google GasART
13:19:37 <lambdabot> No Result Found.
13:19:48 <im_alone> @google AppART
13:19:55 <lambdabot> http://www.appart.com/
13:19:56 <lambdabot> Title: AppArt�Hosted Brand Asset Management and Production Services
13:20:15 <RayNbow> @djinn (k -> k -> v) -> (k -> v)
13:20:16 <lambdabot> f a b = a b b
13:20:49 <Myoma> :t join :: (k -> k -> v) -> (k -> v)
13:20:51 <lambdabot> forall k v. (k -> k -> v) -> k -> v
13:21:06 <mauke> @. pl djinn (k -> k -> v) -> (k -> v)
13:21:07 <lambdabot> f = join
13:21:49 <im_alone> @google GasART resonance
13:21:51 <lambdabot> No Result Found.
13:26:53 <trofi> @hoogle unpack
13:26:53 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
13:26:54 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
13:26:54 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
13:27:04 <mmorrow> @hoogle c2w
13:27:05 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
13:27:08 <mmorrow> @hoogle w2c
13:27:08 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
13:27:16 <mmorrow> (useful)
13:27:39 <Saizan_> ?type toEnum . fromEnum
13:27:42 <lambdabot> forall a a1. (Enum a1, Enum a) => a1 -> a
13:28:09 <trofi> thanks. is there ByteStringed analogues for Parsec.string?
13:28:11 <mmorrow> true, but c2w/w2c have {-# INLINE #-} and supposedly usually get optimized away
13:28:35 <Myoma> BMeph_: It is good but I don't know if I can apply it to my problem
13:30:08 <mmorrow> Saizan_: how's parallelizing cabal coming? that paste the other day looked like an interesting problem.
13:31:37 <BMeph_> Myoma: Hm, it isn't my field, either. You could, though, look on Citeseer, for papers that reference that one, or other papers that Shin-Cheng Mu has written
13:32:02 <Saizan_> mmorrow: i kept that version for now, however the backend is there, it's mostly a matter of exposing the option in the UI e convert the compiling code for ghc to that
13:33:14 <mmorrow> Saizan_: is that in http://darcs.haskell.org/Cabal/ then?
13:33:16 <lambdabot> Title: Index of /Cabal
13:33:42 <mmorrow> or am i misunderstanding what that code was for?
13:34:20 <Saizan_> mmorrow: it's still only in my repo un c.h.o, i've to remove the mtl and fgl dependencies first
13:35:01 <mmorrow> Saizan_: cool. link?
13:35:26 <mmorrow> ah, found it
13:37:15 <Saizan_> mmorrow: i've just pushed a patch that enables parallel building by default for preprocessors
13:37:26 <mmorrow> nice nice
13:38:15 <mmorrow> getting now
13:39:10 <Saizan_> i'm not sure what's the best way to avoid getting all the messages interleaved on stdout
13:39:47 <mmorrow> this is the behaviour of make -jN, N>1
13:40:34 <Saizan_> ah, so there's no good way?:)
13:40:38 <Myoma> 'It is therefore an instance of the "generator - filter" paradigm that recurs frequently in functional programming" -- what is this ?
13:40:51 <mmorrow> Saizan_: i'm not sure. what ordering would you have them be in?
13:41:15 <mauke> probably something like 'generate hueg data structure first, filter later' ... but that's a lazy paradigm
13:41:53 <mmorrow> yeah, without laziness that would suck bigtime
13:43:28 <Saizan_> mmorrow: mmh, at least one line per process, instead of one character would be nice, maybe i've to play with buffering settings
13:43:45 <mmorrow> ohhh, i gotcha. haha.
13:43:54 <mmorrow> so it's just gibberish then
13:44:26 <dmead> > mean [1..10]
13:44:29 <lambdabot>   mueval: Prelude.read: no parse
13:44:38 <dmead> is there a mean?
13:44:44 <dmead> @hoogle mean
13:44:44 <lambdabot> No results found
13:45:09 <Myoma> :t liftA2 (/) sum length
13:45:12 <lambdabot>     No instance for (Fractional Int)
13:45:12 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
13:45:12 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
13:45:39 <mauke> :t liftA2 (/) sum (fromIntegral . length)
13:45:41 <lambdabot> forall b. (Fractional b) => [b] -> b
13:45:48 <Myoma> :t liftA2 (/) sum (foldr (const (+1)) 0)
13:45:50 <lambdabot> forall a. (Fractional a) => [a] -> a
13:46:16 <mmorrow> Saizan_: yeah definitely possible somehow. maybe somthing like a (T)Chan String, and a write thread or something.
13:47:20 <mmorrow> (where the String could be entire atomic messages, not just lines)
13:47:29 <Saizan_> yup
13:48:20 <Feuerbach> can I make list (as * -> *) a instance of some class (like Monad or Functor)?
13:48:35 <dmhouse> Sure.
13:48:42 <dmhouse> Although [] already has Monad and Functor instances.
13:48:45 <Feuerbach> how is it written?
13:48:50 <Feuerbach> no, it's my own class
13:48:50 <dmhouse> instance Monad [] where ...
13:48:59 <Feuerbach> thanks
13:49:12 <Myoma> :t undefined :: [] Integer
13:49:14 <lambdabot> [Integer]
13:49:27 <rwbarton> :t undefined :: [] 1
13:49:29 <lambdabot> [Unit]
13:49:41 <dmhouse> ?hoogle 1
13:49:41 <lambdabot> Parse error:
13:49:42 <lambdabot>   --count=20 1
13:49:42 <lambdabot>              ^
13:49:50 <dmhouse> Who defined that?
13:49:55 <Myoma> GHC.Generics.Unit
13:50:01 <mauke> @index 1
13:50:01 <lambdabot> bzzt
13:50:08 <dmhouse> Okay. How does it differ from ()?
13:50:18 <mmorrow> @src Unit
13:50:19 <lambdabot> Source not found. You speak an infinite deal of nothing
13:50:20 <dmhouse> Or is it for type-level numerals?
13:50:24 <dmhouse> ?hoogle Unit
13:50:25 <lambdabot> Data.Generics data Unit
13:50:25 <lambdabot> Data.Generics Unit :: Unit
13:50:25 <lambdabot> Language.Haskell.Syntax unit_con :: HsExp
13:50:48 <dmhouse> Prelude Data.Generics> :i Unit
13:50:48 <dmhouse> data Unit = Unit 	-- Defined in GHC.Base
13:50:56 <mmorrow> ah
13:50:58 <dmhouse> :t undefined :: 2
13:51:01 <lambdabot> Only unit numeric type pattern is valid
13:51:26 <dmhouse> Prelude Data.Generics> :t undefined :: 1
13:51:26 <dmhouse> undefined :: 1 :: Unit
13:51:29 <dmhouse> ^^ weird.
13:51:36 <dmhouse> It's some kind of magic.
13:52:09 <byorgey> what the heck?
13:52:24 <TomMD> A witch! Burn dmhouse
13:52:26 <dmhouse> rwbarton: what is this nonsense?
13:52:41 <mmorrow> to the stake!
13:54:13 <mmorrow> > typeOf (undefined::1)
13:54:17 <lambdabot>       No instance for (Typeable Unit)
13:54:18 <lambdabot>        arising from a use of `typeOf' a...
13:54:44 <nominolo> @unlet 1
13:54:45 <lambdabot>   Parse error
13:54:59 <mmorrow> oh nice, there's an unlet
13:54:59 <mauke> let == unlet
13:55:04 <mmorrow> aww
13:55:21 <mmorrow> > fix L.id
13:55:24 <lambdabot>   0
13:55:28 <dmhouse> :|
13:55:33 <mauke> :t L.id
13:55:35 <lambdabot> forall b t. (Num t) => b -> t
13:55:35 <mmorrow> tricksters
13:55:43 <mmorrow> > fix id
13:55:46 <dmhouse> > L.id 3
13:55:49 <lambdabot>       Ambiguous occurrence `id'
13:55:49 <lambdabot>      It could refer to either `L.id', defined...
13:55:52 <lambdabot>   0
13:55:52 <mauke> > L.id ()
13:55:56 <mmorrow> someone made it const 0
13:55:56 <lambdabot>   0
13:56:11 <dmhouse> ?unlet L.id
13:56:12 <lambdabot>   Parse error
13:56:17 <dmhouse> (How's that done?)
13:56:19 <dmhouse> ?undefine
13:56:23 <mmorrow> i don't think you can
13:56:24 <dmhouse> :t L.id
13:56:25 <mauke> @redefine id
13:56:26 <lambdabot> Not in scope: `L.id'
13:56:32 <dmhouse> Okay, it's ?undefine.
13:56:32 <mmorrow> without undefining everything
13:56:44 <dcoutts> bos: pong
13:56:47 <mmorrow> yeah, all or nothing it seems
13:56:57 <nominolo> dcoutts: ping
13:57:06 <_zenon_> omfg, it hurts soo bad to get salt in a wound
13:57:14 <dcoutts> nominolo: pong
13:57:21 <nominolo> _zenon_: yeah, don't do that
13:57:27 <mmorrow> _zenon_: add lime too
13:57:38 <dmhouse> _zenon_: hence the expression, one would guess.
13:57:46 <_zenon_> I got this mouth wound, I bit my check by accident
13:57:52 <dmhouse> _zenon_: I mean, if it were only *midly* painful to add salt to the wound, who would say that?
13:57:54 <_zenon_> and the little thing won't heal
13:58:07 <_zenon_> so I took a flake of salt and put it there.
13:58:07 <dcoutts> Saizan_: so are you writing about the outcome of the GSoC? I think we're going to put together some summary for the community.
13:58:19 <dmhouse> "It's like biting your lip" -- not really the same effect.
13:58:49 <_zenon_> dmhouse, maybe a gentleman? "May your bite in a mildly sour apple"
13:59:03 <Myoma> "so I took a flake of salt and put it there" lol
13:59:32 <Saizan_> dcoutts: i'm keeping tomorrow free to do that
13:59:35 <_zenon_> Myoma, yeah, I thought it might do something about the pain, and it did
13:59:55 <Myoma> _zenon_: Something to worry about is getting your teeth pulled out because you keep biting yourself
14:00:01 <mmorrow> _zenon_: i've had that. is it infected yet? gargle with <insert-the-stuff-you-disinfect-cuts-with-i-can't-think-of-the-name-right-now>  (but DONT! swallow any)
14:00:13 <Myoma> _zenon_: ...if you're looking for something to worry about  :)
14:00:22 <TomMD> So... anyone use Haskell? :-P
14:00:39 <_zenon_> Myoma, well, I would prefer not to loose my teeth though, what will I grind then?
14:00:57 <_zenon_> mmorrow, will it heal faster? I'll try though
14:01:09 <_zenon_> mmorrow, it's really annoying to being able to eat properly.
14:01:50 <mmorrow> hydrogen peroxide is the name
14:01:58 <TomMD> H2O2
14:01:59 <dcoutts> Saizan_: cool
14:02:13 <mmorrow> _zenon_: yeah, and it'll kill infection. this is what a doctor would have you do.
14:02:18 <dmead> sexy
14:02:27 <dmead> "*** Exception: /home/dan/cdc_haskell/mkt.hs:108:23-66: Irrefutable pattern failed for pattern (z : zs)
14:02:42 <_zenon_> mmorrow, oh, thanks.
14:02:43 <dmwit> I vote you write total functions from now on.
14:02:49 <dmwit> ;-)
14:02:52 <TomMD> dmead: I'd call that a need for CATCH - this was when running an open source app?
14:03:07 <mmorrow> _zenon_: (and do it a few times a day until it stops being a problem)
14:03:08 <dmead> nope
14:03:40 <_zenon_> mmorrow, I'll also add a mental note to stop biting myself.
14:03:45 <Myoma> dmead: Yeah it would be interesting to see a real example of a program written in a total way, do you  know any examples ?
14:03:56 <dmead> total way?
14:03:58 <mmorrow> _zenon_: heh
14:03:58 <dmead> what do you mean?
14:04:02 <b\6> you guys might want to check out my band 'iRREFUTABLE PATTERNS' latest album 'THE INTELLIGENCE OF THE ALLOCATOR'
14:04:06 <Myoma> dmead: every function being total
14:04:22 <TomMD> Myoma: By your definition does that mean we can't use type classes?
14:04:23 <dmead> meaning what exactly?
14:04:29 <opqdonut> b\6: heh
14:04:30 <dmead> pattern matching can't fail?
14:04:39 <TomMD> dmead: That would certainly be one result.
14:04:44 <Myoma> dmead: I thought you'd know what total meant since you used the term ...
14:04:58 <dmead> i did?
14:04:59 <mmorrow> > ([x,y]->(x,y)) [0..]
14:05:01 <lambdabot>   mueval: Prelude.read: no parse
14:05:11 <TomMD> Myoma: You are thinking of dmwit
14:05:12 <Myoma> dmead: Oh you didn't you have a similar nick to dmwit
14:05:18 <dmead> ah
14:05:20 <dmead> yea that  happens
14:05:22 <mmorrow> ghci> (\[x,y]->(x,y)) [0..]
14:05:22 <mmorrow> *** Exception: <interactive>:1:1-13: Non-exhaustive patterns in lambda
14:05:35 <mauke> > (\[x,y]->(x,y)) [0..]
14:05:37 <lambdabot>   mueval: Prelude.read: no parse
14:05:38 <lambdabot>  mueval: *** Exception: /tmp/113032543589885...
14:05:49 <b\6> what can be done for closed-source apps to satisfy the lgpl thing about providing a way to link to other versions of the library? i'm talking about stuff like sdl and openal.
14:06:04 <dmwit> Myoma: I try to write all my programs with only total functions.
14:06:05 <TomMD> b\6: Don't link in those libraries.
14:06:32 <dmwit> Myoma: So do many other people.
14:06:45 <dmwit> Myoma: xmonad, for example, is mechanically checked for totality using Catch.
14:06:47 <Myoma> I can't recall any such ..
14:06:49 <TomMD> b\6: Sorry, you said lgpl, hummm.  IANAL, but I didn't think lgpl libs posed much of an issue, do they?
14:06:50 <dmwit> (A very cool result!)
14:07:08 <Myoma> do you always use structural recursion??
14:07:10 <mauke> b\6: provide object code
14:07:44 <TomMD> dmwit, Myoma: To be fair, xmonad hasn't been checked using CATCH since version ~0.3 afaik.
14:08:15 <b\6> TomMD: think so. like this: http://www.libsdl.org/license-lgpl.php
14:08:17 <lambdabot> Title: Simple DirectMedia Layer
14:08:38 <sjanssen> dmwit, Myoma, TomMD: mostly because yhc sucks
14:08:54 <sjanssen> though I don't think StackSet has really changed since then
14:08:58 <b\6> i guess maybe somehow it's ok as long as it's not static.
14:09:09 <TomMD> sjanssen: Yes, I know.  ndm was working on bringing catch to GHC - not sure where that is.
14:09:49 <TomMD> b\6: If I were using Haskell for closed source apps I'd be concerned about GHCs use of gmp first and foremost.
14:10:18 <b\6> hmm, thanks for the info. reading.
14:12:02 <mmorrow> b\6: who're you selling a closed source app to?
14:12:32 <b\6> mmorrow: nobody's selling anything for a while, if ever. i'm just wondering.
14:12:32 <TomMD> mmorrow: Hint: the app is called "Windows Server 2010" ;-)
14:12:38 <b\6> damn it.
14:12:48 <b\6> don't release details of my proprietary project.
14:12:50 <mmorrow> we got you!
14:12:53 <bos> dcoutts: was getting about 1.5KB/sec out of hackage.haskell.org earlier, wondered if you knew who to prod.
14:12:54 <TomMD> Sorry!
14:13:05 <mmorrow> to the stake!
14:13:17 <mmorrow> :)
14:13:22 <dcoutts> bos: dons, who could ask their IT bod
14:13:40 <bos> ok, thanks!
14:13:55 <TomMD> bos: If you are on company time and money then this is just a good excuse to fly to Portland and do it yourself...
14:14:04 <TomMD> Could be fun.
14:14:22 <bos> TomMD: er, hardly.
14:15:21 <dmead> is there a convenient way to find out where a pattern match fails?
14:15:31 <dmead> if i have no idea what function failed
14:15:58 <Heffalump> pattern match failure should come with a message saying where, in GHC
14:15:59 <Myoma> line 108
14:16:06 <Heffalump> or do you mean what called the thing that went wrong?
14:16:29 <mmorrow> mkt.hs:108:23-66: Irrefutable pattern failed
14:16:35 <mmorrow>  mkt.hs:108:23-66
14:17:02 <mmorrow> yeah, finding out what called it is a /bitch/
14:17:11 <Heffalump> the ghci debugger can sometimes help
14:17:31 <Cale> Shouldn't the ghci debugger generally find it?
14:18:20 * mmorrow immediately begins rtfm
14:18:21 <dmead> ah
14:18:22 <dmead> hmm
14:18:43 <dmead> yea i can see i don't cover a pattern there
14:18:45 <dmead> but i'd think ghci would abe able to throw more info in said exception
14:18:48 <dmead> java style, etc
14:18:53 <dmead> with the backtrace and everything
14:19:03 <TomMD> Use Debug.Trace if you want that.
14:19:06 <dmead> ah
14:19:23 <mauke> TomMD: how does that give you a backtrace?
14:19:28 <TomMD> and ghci does have a debugger.
14:20:03 <nominolo> dmead: ghci -fbreak-on-exception
14:20:07 <TomMD> mauke: Yes, I spoke too soon, didn't I.  dmead: GHC debugger is what you want - assuming it doesn't drive you mad.  I like it, but some done.
14:20:10 <TomMD> *don't.
14:20:14 <nominolo> dmead: then :back
14:20:33 <nominolo> though, a more integrated UI would be nice
14:22:51 <dmead> so :set -fbreak-on-exception?
14:22:57 <dmead> and then :back when it dies?
14:23:05 <dmead> do i have to import debug.trace too?
14:23:22 <bos> http://www.realworldhaskell.org/blog/2008/09/05/speaking-in-silicon-valley-next-week/
14:23:24 <TomMD> dmead: No, ignore my redherring... its a useful but separate tool.
14:23:28 <lambdabot> Title: Real World Haskell » Blog Archive » Speaking in Silicon Valley next week, http://tinyurl.com/55tfx8
14:23:32 <dmead> ah
14:23:32 <dmead> k
14:23:41 <mmorrow> yeah, Debug.Trace doesn't
14:23:48 <mmorrow> just tried
14:24:47 * mmorrow has the same problem as dmead with someone elses code
14:24:55 <dmead> how do you continue when it breaks?
14:25:01 <dmead> or show the stack etc
14:25:03 <dmead> :S
14:25:15 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
14:25:17 <lambdabot> Title: 3.5.�The GHCi Debugger, http://tinyurl.com/2nxab2
14:25:24 <dmead> kewl
14:25:36 <TomMD> dmead: do see that link, but in brief ":back" ":history" etc.
14:25:46 <TomMD> oh, and ":help" ;-)
14:26:30 <dmead> =]
14:27:48 <dmead> cool
14:27:55 <dmead> this is way easier than gcc
14:30:34 <cr8xor> im looking into using haskell for some programs, what advantages does it have. can it use tcp protocls?
14:30:46 <mauke> :-|
14:31:13 <mauke> @faq can I hax the gibson?
14:31:14 <lambdabot> The answer is: Yes! Haskell can do that.
14:32:04 <mwc> cr8xor: look into Network
14:32:06 <TomMD> Drat, the troll left.
14:32:30 <mwc> actually, the only thing it doesn't have for networking is SCTP support... yet
14:32:57 <TomMD> mwc: It is missing a lot in networking.  So much that I considered writing a higher level "hsNetwork" library.
14:33:06 <olsner> hmm, what in the world *does* has SCTP support?
14:33:20 <TomMD> For a basic example - I don't think there is any "IPHeader" data structure with binary instances in Network.*
14:33:28 <mwc> olsner: linux, freebsd ;)
14:33:46 <mmorrow> someone came here a few weeks ago and asked an almost identical question as cr8xor. i thought he was a troll at first but he was serious.
14:33:52 <mwc> heh
14:33:58 <olsner> mwc: so, if you're building unix-only software that only has to speak to other unixen, you can actually use sctp? :P
14:34:10 <mwc> olsner: sure, or dedicated in house stuff
14:34:10 <TomMD> mmorrow: I was typing out a response saying as much when he left.
14:34:17 <mmorrow> heh
14:34:17 <mauke> "why so serious?"
14:34:46 <mwc> oughta be the new troll greeting
14:34:59 <mwc> anybody want to photoshop the joker's scar into a lambda?
14:35:10 <Heffalump> what does import "packagename" Foo in the sources of base3-compat mean?
14:35:32 <TomMD> I thought we could just have lambdabot do statistical recognition on peoples first questions - if it rates 'troll' then we have our lambdabot-net DOS them.
14:35:34 <mmorrow> Heffalump: oh, i was a comment in darcs changes in ghc about that
14:35:41 <mmorrow> one sec
14:36:03 <Heffalump> ok, I'll have a look for that then
14:36:18 <Heffalump> ah, -XPackageImports
14:36:21 <mmorrow> exactly
14:36:42 <Heffalump> when I first saw it in Data.Unique I wondered if <- had been implemented on the sly :-)
14:36:55 <mmorrow> haha
14:37:01 <ddarius> TomMD: That would be the wrong thing to do.
14:37:17 <mwc> Anybody have haskell badges, a la vim, xhtml, etc?
14:37:40 <TomMD> ddarius: Its not that I don't understand that, its that I don't know what the Right Thing (TM) is.
14:37:57 <mwc> TomMD: we could sent SPJ to their house with a neuralyzer
14:38:51 <olsner> if every troll got a house visit by someone explaining the errors of their ways, I think most would be too scared to troll #haskell ever again :D
14:39:41 <mwc> Right, I'll build an android combat chassis for lambdabot then, right after I finish the replicant body for @vixen
14:39:55 <mmorrow> botwars!
14:40:22 <mmorrow> p
14:40:57 <olsner> hmm, wouldn't that give lambdabot two bodies? isn't that a bit schizo?
14:41:13 <olsner> @vixen how many are there of you?
14:41:14 <lambdabot> let's just say a few
14:41:37 <Heffalump> where does the most recent version of hs-plugins live? http://www.cse.unsw.edu.au/~dons/hs-plugins/ ?
14:41:39 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
14:42:50 <mmorrow> Heffalump: http://code.haskell.org/~dons/code/hs-plugins/
14:42:51 <lambdabot> Title: Index of /~dons/code/hs-plugins
14:43:12 <mmorrow> (i think that's the most recent. where i get from at least.)
14:43:29 <Heffalump> oh, I looked on code.haskell.org, but not in ~dons :-)
14:43:43 <Heffalump> thanks.
14:44:36 <mmorrow> it's kinda hidden too, the if you goto  c.h.o/~dons then click  hs-plugins/ it takes you to the old page
14:45:33 <mwc> Galois conspiracy?
14:45:43 <mmorrow> i'd bet my bottom dollar
14:46:18 <Myoma> > fix ($)
14:46:20 <lambdabot>       Overlapping instances for Show (a -> b)
14:46:21 <lambdabot>        arising from a use of `s...
14:46:28 <mmorrow> ah, the link here is the correct one: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
14:46:35 <lambdabot> Title: HackageDB: plugins-1.3, http://tinyurl.com/5mbt3u
14:47:13 <mmorrow> Heffalump: whoa, looks like the one on hackage is newer than that darcs repo
14:47:42 <Heffalump> lol
14:48:29 <bos> @type fix ($)
14:48:31 <lambdabot> forall a b. a -> b
14:48:36 <bos> @type mfix ($)
14:48:37 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
14:48:37 <lambdabot>     Probable cause: `$' is applied to too many arguments
14:48:37 <lambdabot>     In the first argument of `mfix', namely `($)'
14:51:06 <Myoma> has anyone read Type Theory should eat itself
14:51:25 <hackage> Uploaded to hackage: xmonad-contrib 0.8
14:51:25 <hackage> Uploaded to hackage: xmonad 0.8
14:53:19 <skorpan> hm awesome
14:53:39 <mmorrow> Myoma: no, but if it's about what i think it might be i definitely want to
14:53:50 <mmorrow> Myoma: link?
14:54:01 <Myoma> http://www.cs.nott.ac.uk/~jmc/Publications_files/lfmtp08_jmc.pdf
14:54:04 <lambdabot> Title: Type Theory should eat itself
14:54:11 <mmorrow> Myoma: thx
14:54:56 <mmorrow> Myoma: exccccellent, just as i suspected
14:56:00 <Baughn> "Checker for type theory in type theory" <-- Incompleteness theorem doesn't get in the way?
14:56:31 <mwc> perhaps not completely
14:56:32 <Myoma> Baughn, that's what I am confused abuot
14:56:52 <Myoma> the Agda code is online I will look at it later
14:57:02 <Baughn> I'll have to read the paper, then. This should be good.
14:57:59 <Heffalump> is darcs.haskell.org throwing a wobbly again?
14:58:09 <bos> all of hackell.org is sucking
14:58:29 <Heffalump> grmph
15:03:31 <Feuerbach> which Haskell compilers are capable of producing code for old systems?
15:04:05 <Feuerbach> like Linux 2.4.32
15:04:21 <ddarius> All of them?
15:04:58 <Feuerbach> with ghc I get "FATAL: kernel too old" followed by segfault
15:05:15 <Feuerbach> it fails to access /dev/tty
15:05:35 <roconnor> @check  join . (uncurry (++)) === (uncurry (++)) . fmap join
15:05:37 <lambdabot>       precedence parsing error
15:05:37 <lambdabot>          cannot mix `(.)' [infixr 9] and `(===...
15:05:45 <Feuerbach> or maybe not, dunno
15:06:00 <roconnor> @check  \x -> ((join . (uncurry (++))) x) == (((uncurry (++)) . fmap join) x)
15:06:02 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
15:06:02 <lambdabot>        Expect...
15:06:24 <roconnor> @type join . (uncurry (++))
15:06:25 <Feuerbach> execve("./helloworld", ["./helloworld"], [/* 20 vars */]) = 0
15:06:26 <Feuerbach> uname({sys="Linux", node="riptide", ...}) = 0
15:06:26 <Feuerbach> open("/dev/tty", O_RDWR|O_NONBLOCK|O_NOCTTY) = 3
15:06:26 <Feuerbach> writev(3, [{"FATAL: kernel too old\n", 22}], 1FATAL: kernel too old
15:06:26 <lambdabot> forall a. ([[a]], [[a]]) -> [a]
15:06:43 <roconnor> @type (uncurry (++)) . fmap join
15:06:45 <lambdabot> forall a. ([a], [[a]]) -> [a]
15:07:10 <roconnor> ah, wrong fmap
15:07:40 <roconnor> @type (uncurry (++)) . (\f (a,b) -> (f a, f b)) join
15:07:42 <lambdabot> forall a. ([[a]], [[a]]) -> [a]
15:08:00 <roconnor> @check  \x -> ((join . (uncurry (++))) x) == (((uncurry (++)) .(\f (a,b) -> (f a, f b))  join) x)
15:08:03 <lambdabot>   mueval: Time limit exceeded
15:08:30 <roconnor> lambdabot: oh come on, at least tell me how many tests succeeded :P
15:08:34 <mmorrow> Feuerbach: which ghc is that with?
15:08:59 <Feuerbach> mmorrow: 6.8.2 (but compiled on another machine and linked statically)
15:09:25 <mmorrow> hmm, that might be the problem
15:09:38 <Feuerbach> how? and how can I solve it?
15:09:50 <mmorrow> maybe try building from src yourself?
15:10:35 <Feuerbach> mmorrow: that's a simple helloworld program. I have no hopes to build whole GHC there.
15:10:47 <mmorrow> ahh, so you have to bootstrap.
15:11:15 <ddarius> Feuerbach: You'd need to use an old GHC to build a newer one on the machine.
15:11:16 <mmorrow> i had this problem. i managed to get a ghc6.4, then built 6.8.3 with it (took a /long/ time :))
15:11:29 <dancor> how do you sleep in python
15:11:40 <bos> you ask on #python
15:11:46 <dancor> err haskell
15:11:59 * dancor wakes up
15:12:04 <Feuerbach> ddarius, mmorrow: building GHC there is not an option, anyway. I need just working statically linked binary
15:12:24 <bos> @hoogle delay
15:12:25 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
15:12:48 <mmorrow> Feuerbach: hmm, i guess you'll have to find one what was built on a machine whose kernel is similar to the one you're dealing with then (or something like that)
15:12:59 <ddarius> Install 2.4.32 on a different machine and build GHC there and the program you want and copy.
15:14:00 <dons> ?users
15:14:01 <lambdabot> Maximum users seen in #haskell: 497, currently: 472 (95.0%), active: 23 (4.9%)
15:14:06 <ddarius> You can try not linking statically
15:14:18 <Feuerbach> related question: can I disable pthread in produced binary? I'm sure it won't work there with pthread
15:15:36 <Feuerbach> ddarius: at least I'd like to link statically against libgmp. Is it possible?
15:15:47 <dons> yeah
15:15:51 <dons> optl-static
15:16:15 <Feuerbach> but ddarius suggesting that I don't link statically against core libs (libc?)
15:17:52 <mmorrow> Feuerbach: if i were you (i'm only speaking for myself) would find /some/ way to get /any/ ghc >= 6.4 on that machine, then build 6.8 with it
15:18:43 <ddarius> Feuerbach: Worst case scenario you can perform the link yourself.
15:18:44 <mmorrow> because it seems like it'd just be a continual pain in the ass to deal with moving binaries trying to get binaries you built on another machine working there
15:19:01 <mmorrow> s/moving binaries//
15:19:25 <Feuerbach> ddarius: how do I do that?
15:20:00 <Feuerbach> ld?
15:20:01 <ddarius> Another possibility would be to try to statically link the libc and co. from the target machine into the binary on the build machine.
15:20:02 <mmorrow> ghc -c   +   ghc  -optl-l... -optl-l...
15:20:10 <rwbarton> My program uses a particular RWS monad (e.g., RWS Integer String Double).  Is it a good idea to create a newtype for it, or is that silly?
15:20:18 <rwbarton> (should I just use a type synonym)
15:20:27 <Myoma> I  would just use type
15:20:51 <ddarius> rwbarton: Oftentimes you end up adding more things later, so newtyping isn't a bad idea.
15:21:35 <Feuerbach> ok, what about disabling pthreads?
15:21:52 <mmorrow> i have no idea about that one :)
15:22:09 <mmorrow> probably ask in #ghc
15:22:17 <Feuerbach> ok
15:22:33 <mauke> rwbarton: I newtype monads all the time
15:22:48 <mauke> also, (newtype deriving)++
15:23:00 <rwbarton> mauke: Yeah, but it's still several lines of newtype deriving :)
15:23:11 <mauke> how so?
15:23:31 <cads> is it really possible to make emacs display haskell using tex style math symbols for stuff like the lambda, arrow and composition operators?
15:23:53 <mauke> ... deriving (Functor, Monad, MonadReader Integer, MonadWriter String, MonadState Double)
15:23:58 <mauke> or am I missing something?
15:24:23 <Baughn> cads: Yes, sure, easily
15:24:36 <rwbarton> ok, several lines was a small exaggeration.
15:24:51 <Baughn> cads: M-x customize-group haskell
15:25:42 <roconnor> I newtype Monads all the time, ususally because I want to create a new set of "primitives" for my new monad, and hide the general state, environment, etc. operations.
15:26:36 <Myoma> roconnor: huh. I do the same, but I don't newtype
15:26:50 <mauke> then the general operations aren't exactly hidden
15:43:30 <dons> http://www.reddit.com/r/programming/comments/6zx8t/exponentials_of_containers/
15:43:32 <lambdabot> Title: Exponentials of containers : programming, http://tinyurl.com/5hwaxu
15:43:51 <ddarius> dons: Why on reddit?
15:43:57 <dons> why not?
15:44:06 <dons> reddit's boring otherwise.
15:44:39 * dons doesn't want to hear endless chrome stories, or how to use jquery.
15:44:43 <Cale> Yeah. If it wasn't for the occasional good post from dons or a few others, I wouldn't even look at the programming reddit anymore.
15:44:44 <ddarius> My, admittedly very underinformed, opinion is that most redditors will not find that particularly interesting.
15:44:58 <skorpan> at least it's not as painfully boring as slashdot
15:45:11 <ddarius> skorpan: You read slashdot?
15:45:18 <Cale> The programming reddit is about to die from overexposure :)
15:45:19 <dons> bos, nice talk coming up by the sound of it.
15:45:29 <skorpan> ddarius: absolutely not
15:45:30 <dons> Cale, yeah, its getting kinda saturated.
15:45:52 <dons> stories that a year ago would be very exciting get a lot of downmods (gpugen :(
15:45:55 <dons> ah well
15:46:07 <bos> dons: yeah, hope so.
15:46:19 <bos> reddit is both boring and broken.
15:46:26 <Cale> hmm, that guy uses strange notation...
15:46:42 <Myoma> that is Thorsten!
15:46:50 <dons> i wonder what a perfect news site would be like.
15:46:52 <Myoma> I read lots of his papers ...
15:47:05 <dons> commentary, community, quality, focus.
15:47:15 <dons> and regular updates.
15:47:32 <bos> and less of the swarming-horde-of-fandom nature.
15:47:52 <dons> Cale, there's something like 48k subscribers now
15:47:58 <dons> compared to maybe 1-2k when we started using it.
15:48:05 <dons> seems to have jumped a lot this year.
15:48:20 <ddarius> All that Haskell press pulled people in.
15:48:22 <dons> the days of it being a bastion of FP .pdfs is long gone
15:48:51 <dons> a .ps.gz made the top of reddit a year or two ago. no chance now.
15:49:09 <ddarius> Which ps.gz?
15:49:25 <Cale> Hehe, it would be neat to have a forum where to become a member, you are asked to prove some random easy theorem from category theory :)
15:49:33 <dons> i think it might have been one of gibbon's papers.
15:49:39 <dons> or possibly okasaki
15:50:14 <ddarius> Perhaps you should make an fppdf reddit.
15:50:17 <dmhouse> I quite like Haskell at the moment because of that. The language is just hard enough and just non-mainstream enough so that the only people who try it out are actually interested in programming.
15:50:31 <ddarius> Or to not be overly specific, cspapers
15:50:37 <dmhouse> No-one gets forced to learn Haskell for their job. This increases the quality of discussion dramatically.
15:50:48 <dons> dmhouse: some people do.
15:50:48 <Cale> We could start using the Haskell reddit more.
15:51:02 <Baughn> dmhouse: I have, recently, forced someone to learn haskell
15:51:17 <ddarius> dmhouse: This place is going downhill.
15:51:20 <Cale> Baughn: oh?
15:51:30 <Myoma> ddarius, lol
15:51:35 <dons> ddarius: you could hang out with smerdy in #ocaml :)
15:51:47 <Baughn> Cale: My cryptography teacher. That, or he's just marking them "working" without checking; I'm the only programmer in that class. ^^;
15:51:54 <ddarius> Ugh.  I can't stand O'Caml.
15:52:04 <dmhouse> dons: where do these people work?
15:52:05 <Myoma> ocaml is awesome
15:52:17 <jeffwheeler> I got into functional programming with OCaml.
15:52:23 <dmhouse> dons: I'm willing to bet it's a company that hires people that are actually interested in programming
15:52:26 <jeffwheeler> I found it as a good way to learn some of it.
15:52:35 <dons> ah, yes, <Smerdyakov> Really, good language design discourages random questions. Even if everyone knew about OCaml, its channel would have comparatively few questions
15:52:38 <roconnor> I didn't understand any of that notation for exponentials of containers
15:52:57 <Cale> It seems like the only one posting to the Haskell reddit at the moment is that stupid gst bot.
15:53:02 <ddarius> dons: But seriously, if this channel did go downhill enough, I'd simply leave.
15:53:05 <Myoma> dons: is this a better subject for #hasell-blah ?
15:53:14 <dons> ddarius: yeah, we don'twan that to happen.
15:53:23 <dons> so keep discussing hard things.
15:53:35 <dons> i mean, we've made it to 500 users
15:53:39 <newsham> is there a simple description of the algorithm for unifying two paramterized types in H-M?
15:53:45 <newsham> somewhere online
15:53:55 <dons> how much bigger does it get before things fall over?
15:54:06 <ddarius> newsham: Isn't it just unification?
15:54:07 <Myoma> newsham: I have code if you want
15:54:08 <dmhouse> Cale: is gst a bot? Whose?
15:54:14 <Cale> dmhouse: I don't know.
15:54:19 <Myoma> oh 'parametrized' types ?
15:54:21 <Cale> But it very much seems like a bot.
15:54:22 <dmhouse> Cale: he appears to have left a comment
15:54:27 <newsham> ddarius: *shrug*   pretend i dont know anything about type unification.
15:54:37 <Cale> hmm
15:54:38 <newsham> myoma: sure.  email newsham at lava.net?
15:54:42 <dmhouse> Cale: that doesn't rule out bot-ness, of course.
15:55:05 <patchwork> I would switch over to the haskell subreddit, but it doesn't seem to be updated very often
15:55:08 <dons> i think he's a person + rss + submit scripts
15:55:12 <Myoma> newsham: it is just first order unification for types, I don't know if that is what you were referring to, is it?
15:55:19 <newsham> i need to write something that takes two parameterized types and spits out a list of constraints if they can be unified
15:55:20 <dons> patchwork:  also, we don't want to live in a ghetto
15:55:31 <dons> we should be part of the mainstream language discussion
15:55:45 <patchwork> It does make sense though that as the community grows, it would fragment along interest lines
15:55:46 <Myoma> What does this 'parameterized types' mean?
15:55:56 <patchwork> That is one way to keep focus
15:56:01 <dons> yep
15:56:05 <Myoma> We should have less slagging off of people in #haskell :/
15:56:05 <ddarius> newsham: That would just be the normal unification algorithm unless, as Myoma is suggesting, you mean something unusual by "parameterized"
15:56:36 <newsham> (Foo a (X b a))   vs.    (Foo Int (X c c))     for example
15:57:03 <Myoma> oh and you want a = Int, b = Int, c = Int ?
15:57:04 <ddarius> @google "unification algorithm"
15:57:07 <lambdabot> http://www.geocities.com/Paris/6502/unif.html
15:57:07 <lambdabot> Title: An efficient linear unification algorithm
15:57:08 <newsham> should return affirmative with the constrant that a,b=Int on lhs and c=Int on rhs
15:57:21 <ddarius> Actually, read Shriram's PLAI
15:57:27 <Myoma> newsham, maybe useful http://rascal-haskell.googlecode.com/svn/trunk/Infer.hs
15:57:55 <ddarius> newsham: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/
15:57:59 <lambdabot> Title: Programming Languages: Application and Interpretation by Shriram Krishnamurthi, http://tinyurl.com/2bhkwx
15:58:07 <newsham> danke both of you.
15:58:23 <ddarius> newsham: That's an enjoyable hands-on approach to implementation including type checking.
15:58:59 <newsham> (need to write type checker to implement GUI for pluggable components...  *sigh*)
15:59:39 <Myoma> newsham: (There is also Typecheck.hs  in there)
16:00:03 <newsham> does your code have unicode in it?
16:00:09 <Myoma> of course!
16:00:27 <newsham> browser is showing it as ascii
16:01:04 <Myoma> set encoding to UTF-8
16:01:05 <newsham> i didnt know ghc supported unicode in srcs
16:01:23 <mauke> View>Character Encoding>UTF-8
16:01:34 <mauke> and it's showing it as Latin-1
16:01:39 <Myoma> yes it is nice to write x ≡ y nather than unify x y
16:01:40 <newsham> not using IE.  set your web server to return utf8 mime type! ;-)
16:01:54 * Myoma doesn't actually own google :p
16:02:42 <ddarius> Myoma: That is not very enterprising of you.
16:25:02 <mapreduce> :t (:)
16:25:04 <lambdabot> forall a. a -> [a] -> [a]
16:26:11 <roconnor> @type local
16:26:13 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
16:33:02 <mapreduce> @hoogle Boolean -> a -> Maybe a
16:33:03 <lambdabot> Warning: Unknown type Boolean
16:33:03 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:33:03 <lambdabot> Control.Parallel par :: a -> b -> b
16:33:27 <mauke> @hoogle Bool -> a -> Maybe a
16:33:27 <Myoma> @let bool true false True = true ; bool true false False = false
16:33:27 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:33:28 <lambdabot> Prelude asTypeOf :: a -> a -> a
16:33:28 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
16:33:29 <lambdabot>  Defined.
16:33:38 <Myoma> :t bool Just (const Nothing)
16:33:40 <lambdabot> forall a. Bool -> a -> Maybe a
16:33:53 <dmwit> :t \p x -> guard (p x) >> return x
16:33:54 <mauke> congratulations, you've just reinvented 'if'
16:33:54 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
16:33:55 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
16:34:03 <Myoma> if sucks
16:34:07 <mauke> @djinn Bool -> a -> Maybe a
16:34:08 <mapreduce> > bool True 5
16:34:08 <lambdabot> f a b =
16:34:08 <lambdabot>     case a of
16:34:08 <lambdabot>     False -> Nothing
16:34:08 <lambdabot>     True -> Just b
16:34:10 <lambdabot>       Overlapping instances for Show (Bool -> Bool)
16:34:10 <lambdabot>        arising from a use...
16:34:29 <EvilTerran> if should desugar to a prelude function so us -XNoImplicitPrelude folks could tinker with it
16:34:33 <dmwit> ?clear-messages
16:34:33 <lambdabot> Messages cleared.
16:34:43 <mapreduce> :t bool True 5
16:34:44 <lambdabot>     No instance for (Num Bool)
16:34:44 <lambdabot>       arising from the literal `5' at <interactive>:1:10
16:34:44 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
16:35:28 <mapreduce> @let bmap b a => if (b) then Just a else Nothing
16:35:29 <lambdabot>   Parse error
16:35:40 <mapreduce> @let bmap b a = if (b) then Just a else Nothing
16:35:41 <lambdabot>  Defined.
16:35:44 <mapreduce> too many languages error
16:35:49 <Myoma> 'bmap' :S ?
16:35:50 <mapreduce> > bmap True 5
16:35:53 <lambdabot>   Just 5
16:36:05 <dmwit> ?let bmap' b a = return a <* guard b
16:36:06 <lambdabot>  Defined.
16:36:09 <dmwit> :t bmap'
16:36:11 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Applicative f) => Bool -> a -> f a
16:36:41 <Myoma> > (bool Just (const Nothing)) True ()
16:36:44 <Myoma> > (bool Just (const Nothing)) False ()
16:36:45 <lambdabot>   Just ()
16:36:46 <lambdabot>  Terminated
16:37:04 <EvilTerran> ?type let bmap b a = guardA b *> pure a
16:37:05 <lambdabot> <no location info>:
16:37:05 <lambdabot>     not an expression: `let bmap b a = guardA b *> pure a'
16:37:06 <EvilTerran> ?type let bmap b a = guardA b *> pure a in bmap
16:37:08 <lambdabot> Not in scope: `guardA'
16:37:21 <EvilTerran> bah
16:37:48 <EvilTerran> ?type \p x -> if p then pure x else empty
16:37:49 <lambdabot> forall a (f :: * -> *). (Alternative f) => Bool -> a -> f a
16:38:10 <dmwit> if sucks ;-)
16:38:13 <Myoma> :t bool return (const mzero)
16:38:15 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> a -> m a
16:39:18 <dmwit> Myoma: You keep defining it with the arguments backwards; it's confusing me to no end. =P
16:39:54 <Myoma> backwards with respect toa
16:39:55 <Myoma> ?
16:40:02 <dmwit> ?src Bool
16:40:03 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:40:18 <dmwit> False first, then True
16:40:30 <bd_> , Show, Read, Enum, Bounded...
16:42:57 <mapreduce> @instances Monad
16:42:59 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:51:33 <mauke> grr. why is TypeRep not an instance of Ord?
16:52:09 <ddarius> What's the ordering?
16:52:18 <mauke> I don't care
16:52:29 <Myoma> axiom of choice
16:53:15 <mauke> it's all Ints and Strings internally
16:54:18 <ddarius> You can write your own Ord instance.
16:54:24 <TomMD> mauke: Similar complaint about Errno.
16:54:47 <TomMD> Things should always be an instance of Ord so long as they can be.
16:55:16 <mauke> ddarius: how?
16:55:41 <mauke> well, I could use unsafePerformIO
16:55:57 <ddarius> instance Ord TypeRep where compare = comparing show
16:56:11 <mauke> heh. hax!
16:58:03 <mauke> instance Ord TypeRep where compare = comparing (unsafePerformIO . typeRepKey)
17:03:53 <mmorrow> preflex: seen sjanssen
17:03:54 <preflex>  sjanssen was last seen on #xmonad 57 minutes and 47 seconds ago, saying: you'd have to check the bug tracker just in case there is one we haven't fixed
17:04:25 <mmorrow> @tell sjanssen got a first go at the TH string lookup optimizer working http://hpaste.org/10144
17:04:26 <lambdabot> Consider it noted.
17:04:29 <ddarius> preflex: seen preflex
17:04:29 <preflex>  what
17:05:27 <ddarius> preflex: seen razzledazzle
17:05:27 <preflex>  Sorry, I haven't seen razzledazzle
17:06:05 <augustss> preflex: seen jönssonligan
17:06:05 <preflex>  Sorry, I haven't seen jönssonligan
17:06:26 <Lemmih> mmorrow: Why have you expanded the case?
17:06:59 <amitprakash> how do i multiply two polynomials using haskell?
17:07:18 <mauke> a * b
17:07:18 <Myoma> amitprakash: Have you created a datatype to represent polynomials?
17:07:19 <EvilTerran> amitprakash, well, that depends - how are you representing them?
17:07:42 <amitprakash> Myoma, [(int,int)]
17:07:46 <EvilTerran> in short, what mauke said would work - you could make them an instance of Num
17:07:51 <Myoma> amitprakash: What does that mean?
17:07:57 <amitprakash> ie. degree,cofficient
17:08:01 * EvilTerran would go for [Int
17:08:02 <Myoma> ok
17:08:02 <EvilTerran> ]
17:08:03 <mmorrow> Lemmih: yeah, i gotta get rid of those lambdas. it worked out that it was easier to build it that way if i wanted it all in one function (and i was in hurry :)).
17:08:13 <Myoma> amitprakash: And you know how to do it on paper of course
17:08:25 <amitprakash> Myoma, yes.. multiplication is also ok
17:08:45 <amitprakash> Myoma, except how do i add terms with same power in list produced as result of product
17:09:05 <Myoma> amitprakash: I'd say that you can actually sum at the end
17:09:25 <amitprakash> Myoma, how should i approach that?
17:09:28 <mmorrow> Lemmih: i'm gonna clean the code up and i'll put it somewhere then
17:09:56 <Myoma> amitprakash: Have a way to multilpy [(int,int)] with (int,int)
17:10:10 <Myoma> amitprakash: the you can map that on [(int,int)] with [(int,int)], and sum the result
17:11:28 <bd_> @pl \(mx,my) -> map (\(vx, vy) -> (mx * vx, my * vy))
17:11:30 <lambdabot> uncurry ((map .) . flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (*)) . flip . (((.) . (,)) .) . (*))
17:11:53 <bd_> :|
17:12:20 <Myoma> @pl \m -> map (\v -> m*v)
17:12:20 <lambdabot> map . (*)
17:12:26 <ddarius> bd_: No worries.  That wasn't the right function anyway.
17:13:04 <dcoutts> Lemmih: do you know how I set the location of the happs data store, rather than the default '_local' ?
17:13:11 <Lemmih> mmorrow: Sorry, I didn't mean to put down the raw beauty of new code (:
17:13:28 <Lemmih> dcoutts: Yes, I do.
17:14:13 <mc__> I'd like to write a programm which shoud try to solve a rubric cube. What data structure what you recommend for the cube?
17:14:44 <dcoutts> Lemmih: great, I'm trying to consolidate the state into one configurable dir
17:14:54 <dmwit> mc__: ([(Color, Color, Color)], [(Color, Color)])
17:15:13 <dmwit> Actually, something isomorphic to that, but with a nicer interface.
17:15:20 <EvilTerran> ... how does that work out?
17:15:21 <mauke> ([(Badger, Badger, Badger)], [(Mushroom, Mushroom)])
17:15:36 <mc__> mauke: lol
17:15:39 <dmwit> EvilTerran: You keep track of the corners and edges separately, for obvious reasons.
17:15:39 <matthew-_> mauke: have you been drinking?
17:15:41 <amitprakash> Myoma, does this look correct ? http://pastebin.com/m7666a323
17:15:49 <mauke> matthew-_: no, I'm just tired
17:15:56 <EvilTerran> dmwit, ah, i see. and the middles don't move.
17:15:57 <matthew-_> mauke: have a drink then ;)
17:16:01 <dmwit> EvilTerran: Right.
17:16:36 <matthew-_> right, well I need to sleep
17:17:21 <mc__> but, the middles do move, dont they?
17:17:25 <Myoma> amitprakash: I would use,
17:17:25 <Myoma> data Term c = c :*×^: Integer
17:17:25 <Myoma> type Polynomial c = [Term c]
17:17:38 <dmwit> mc__: Have you ever played with Rubik's cube?
17:17:48 <mc__> dmwit: nope
17:18:01 <Myoma> so you can let (+) = (:) in   2:*×^:3 + 4:*×^:8 + []
17:18:14 <Myoma> × is supposed to look an x ...
17:18:16 <dmwit> mc__: You should try it first, it will make it much easier to figure out how to write a program to solve it. =)
17:19:03 <mc__> dmwit: i dont have one in reach :(
17:19:13 <dmwit> Here, have mine!
17:19:27 <mc__> :/
17:19:32 <EvilTerran> find one on the internet
17:20:06 <dmwit> Internet ones are hard to understand. =/
17:20:37 <Myoma> amitprakash: so I meant like, multiply x y = sum $ map (mul x) y where mul p (c :×^ i) = map (\(k :×^ j) -> (k * c) :×^ (i + j))
17:21:47 <Myoma> sum is a bit harder to define
17:24:42 <mc__> ah, alright, I think I understand the cube now, but I dont fully understand the data structure you suggested dmwit
17:25:33 <dmwit> mc__: Well, you'll notice that you can't just arbitrarily color a Rubik's cube.
17:26:10 <dmwit> For example, if there is a corner that is red, white, and blue in a solved cube,
17:26:22 <dmwit> then *any* unsolved cube must also have a RWB corner.
17:26:52 <dmwit> AND it's not enough for it just to have red, white, and blue; it has to have them in the same order as the solved cube!
17:27:00 <dmwit> (i.e. not red, blue, white)
17:27:43 <dmwit> Moreover, corner cubies and edge cubies (having only two colors) never interchange, for obvious reasons.
17:28:11 <dmwit> So, my suggestion would be to track the corner and edge cubies separately, and to determine some "order" for each.
17:29:00 <ddarius> Draw the Cayley graph and search it.
17:29:02 <dmwit> You could also do something more elaborate, in which you use (Color, Color, Color)^8 x (Color, Color)^12, but for me, (C, C, C)^n is sufficiently correct.
17:29:22 <mc__> now you lost me
17:29:46 <dmwit> ddarius: Right, this is essentially just graph search... but the graph is really big.
17:30:26 <ddarius> Myoma and her Unicode.
17:30:55 <dmwit> There's all kinds of clever tricks people pull to make solving the Rubik's cube more tractable.
17:31:21 <Myoma>  I can't find my rubiks cube
17:31:25 <dmwit> Actually, solving is easy: it's finding the optimal solution that's hard.
17:32:28 <mmorrow> Lemmih: heh
17:33:15 <dmwit> mc__: You might be interested in http://match.stanford.edu/bump/rubik.html or http://web.usna.navy.mil/~wdj/rubik_nts.htm
17:33:16 <lambdabot> Title: Mathematics of the Rubik's Cube
17:34:36 <amitprakash> Myoma, what does ^ do?
17:34:41 <mc__> dmwit: thank you, I'll have a look at it
17:35:15 <Myoma> amitprakash: (:×^) is an infix type constructor, like (:) is another
17:35:27 <Myoma> amitprakash: I used (:×^) where you use (,)
17:35:32 <amitprakash> ah ok
17:37:49 <amitprakash> Myoma, thanks a lot anyways.. i couldnt understand your code tho T__T
17:39:35 <Myoma> amitprakash: There's a different representation you could use that makes things much easier
17:40:12 <amitprakash> Myoma, i get the idea of using the map though :)
18:00:08 <cads> friends, is there a computer logical reasoning system that is able to derive from a naive algorithm a more sophisticated algorithm with smaller time complexity?
18:00:30 <roconnor> cads: automatically?
18:00:50 <cads> yes
18:00:51 <Myoma> I think Mercury can
18:00:56 <Myoma> the compiler
18:00:57 <cads> but lets say for simple cases
18:02:16 <pjdelport> cads: sounds like supercompilation
18:02:24 <cads> for example there is the exponential binary recursion form of fibonacci, from which it is simple to derive the linear simple recursion algorithm
18:02:41 <pjdelport> yeah, that's the kind of thing it does
18:02:42 <Myoma> cads, Can you show me that refinement ?
18:03:40 <cads> I don't know it in formal calculational reasoning, but derived it by hand pretty easily
18:04:49 <pjdelport> cads: http://delicious.com/pjd/supercompilation might interest you
18:04:51 <lambdabot> Title: pjd's supercompilation Bookmarks on Delicious
18:05:11 <cads> it's possible to derive a mixed recursion algorithm that computes fib in logarithmic time
18:05:20 <pjdelport> cads: Neil Mitchell has been working on supercompilation for Haskell
18:05:23 <pjdelport> http://www-users.cs.york.ac.uk/~ndm/supero/
18:05:25 <lambdabot> Title: Neil Mitchell - Supero
18:05:27 <cads> but that was really tough
18:06:12 <cads> pjdel: that looks very interesting
18:13:30 <bd_> cads: ln of the index, or ln of the result number?
18:15:41 <thatsright> http://tinyurl.com/5nve3z = haskell+googlecharts+tinyurl :)
18:21:10 <cads> bd, http://cubbi.com/fibonacci/algorithms.html algorithms 3a and 3b for F n are  O(log n)
18:21:12 <lambdabot> Title: cubbi.com: Algorithms for the calculation of Fibonacci Numbers
18:21:53 <cads> the matrix identity is really elegant
18:22:08 <bd_> cads: it can't be faster than O(lg(fib(n))) surely
18:22:17 <thatsright> is there a haskell tinyurl binding i couldnt find one on hackage
18:22:26 <bd_> although I'm not sure if O(fib(n)) = O(n)
18:22:44 <Myoma> thatsright: you could check how lambdabot does it
18:23:06 <cads> bd, nope, those algorithms evaluate fib(n) in ~log(n) steps
18:23:34 <bd_> cads: the thing is, in order to write 'n' to memory, you need O(lg(n)) steps :)
18:24:08 <bd_> since we're writing fib(n) to memory, O(lg(fib(n))) as well... possibly even O(lg(fib(n))lg(n)) ?
18:24:30 <Myoma> bd_: Your analysis seems slightly informal ...
18:25:07 <bd_> A bit... but if a number x has n digits in any numbering system, you'll need lg(n) steps to write it to memory at least
18:25:31 <bd_> if fib(n) dominates n - which my instinct says it does, although I have no proof to back it - then lg(fib(n)) dominates lg(n)
18:26:55 <cads> well fib n  = O(a^n)
18:27:14 <cads> err, maybe not big-oh
18:27:32 <cads> but it grows like an exponential function
18:28:06 <cads> so maybe the overhead of writing all those digits would make the algorithm heavier
18:28:15 <bd_> so, for sufficiently large n, the time spent writing the final result back to memory would dominate any true lg(n) computation function, if we assume all operations except the final write have O(1) access time to arbitrarily large integers
18:29:09 <andrewsw> Hi, I'm playing with project euler to learn some haskell, with a little Scheme experience to help down the FP path.
18:29:26 <bd_> if the intermediate memory access operations are O(lg n) as well, we still can't get any better than O(lg(fib(n))) :)
18:29:28 <Nafai> andrewsw: That's a great way, that's one of the things I've done to learn Haskell
18:29:40 <andrewsw> current problem is prime factors, and I have a solution
18:29:53 <cads> bd_: , that's linear time then, I think
18:30:25 <bd_> hmm, yeah, if fib n is indeed O(a^n)
18:30:44 <bd_> so O(n) at best
18:31:07 <cads> fib n = round (phi^n/sqrt 5) where phi = (1 + sqrt 5)/2
18:31:23 <Myoma> > let fib n = round (phi^n/sqrt 5) where phi = (1 + sqrt 5)/2 in fib 30
18:31:26 <lambdabot>   832040
18:31:29 <bd_> it's still better than the iterative method, which factoring in the memory access times would be O(n lg n)
18:32:07 <andrewsw> can I get some feedback on my solution: http://hpaste.org/10146
18:32:12 * FunctorSalad is trying to write the least-words haskell/category theory tutorial :) http://preview8.awardspace.com/tinycategory.awardspace.com/applicative.xhtml
18:32:15 <lambdabot> http://tinyurl.com/59vjhd
18:32:16 <andrewsw> please
18:32:19 <FunctorSalad> (a first draft)
18:32:21 <cads> Myoma: that identity fails at around n = 71 do to insufficient precision
18:32:29 <cads> at least on my machine
18:32:32 <Myoma> > let fib n = round (phi^n/sqrt 5) where phi = (1 + sqrt 5)/2 in fib 71 :: CReal
18:32:34 <lambdabot>       No instance for (Integral CReal)
18:32:34 <lambdabot>        arising from a use of `fib' at ...
18:32:36 <Myoma> :(
18:32:39 <Myoma> > let fib n = round (phi**n/sqrt 5) where phi = (1 + sqrt 5)/2 in fib 71 :: CReal
18:32:42 <lambdabot>       No instance for (Integral CReal)
18:32:42 <lambdabot>        arising from a use of `fib' at ...
18:34:07 <cads> I would like to calculate the complexity of using adaptable precision numbers for that formula
18:34:27 <pjdelport> FunctorSalad: the first diagram isn't entirely clear
18:34:40 <pjdelport> what are f and g?
18:35:22 <FunctorSalad> pjdelport: it's intentionally not formally complete, I'm trying to use as few symbols as possible
18:35:39 <haskellian> What would be a good typical example of concurrent programming to implement?
18:35:46 <cads> ﻿let fib n = (phi**n-(phi-1)**n)/sqrt 5 where phi = (1 + sqrt 5)/2 in fib 30
18:35:49 <cads> err
18:35:59 <haskellian> + if it is one that lets you use different approaches and shows their pros and cons
18:36:06 <cads> > ﻿﻿let fib n = (phi**n-(phi-1)**n)/sqrt 5 where phi = (1 + sqrt 5)/2 in fib 30
18:36:08 <lambdabot>   mueval: Prelude.read: no parse
18:36:25 <FunctorSalad> pjdelport: granted that thing is a bit confusing :) trying to allude to it being a bijection
18:36:26 <TomMD> haskellian: The best example of a concurrent program is a GUI + backend.
18:36:43 <Olathe> @type (**)
18:36:44 <pjdelport> FunctorSalad: sure, between curried and uncurried form?
18:36:45 <lambdabot> forall a. (Floating a) => a -> a -> a
18:36:46 <TomMD> Parallel programs are a bit less common.
18:36:48 <FunctorSalad> pjdelport: you can either start with f or g, the other is defined by the equations
18:36:54 <FunctorSalad> *with either f or g
18:37:20 <pjdelport> FunctorSalad: right, but it's not immediately clear that f and g are supposed to be the illustrated functions
18:37:33 <FunctorSalad> pjdelport: ah... misunderstood you then
18:37:57 <FunctorSalad> think I will just go with "curry g" and "g"
18:38:17 <Olathe> > a + b
18:38:21 <pjdelport> FunctorSalad: maybe you could have a dotted "curry" arrow pointing to the left, and "uncurry" pointing to the right?
18:38:27 <lambdabot>   a + b
18:38:30 <Olathe> > a % b
18:38:35 <pjdelport> or something like that
18:38:42 <Olathe> For some reason, that hangs.
18:38:46 <lambdabot>   thread killed
18:38:47 <cads> ﻿> ﻿﻿let fib n = (phi^n - (phi-1)^n) / sqrt 5 where phi = (1 + sqrt 5)/2 in fib 30
18:39:06 <pjdelport> FunctorSalad: without necessarily mentioning f and g, since nothing else seems to either
18:39:17 <Olathe> cads: Do you want a fast Fibonacci algorithm ?
18:39:22 <andrewsw> Nafai: yes, it seems a great way to start into it.
18:39:26 <Olathe> wli made a good one.
18:39:30 <cads> I've got two : D
18:39:33 <FunctorSalad> pjdelport: *nod*
18:39:37 <Olathe> OK.
18:39:48 <cads> trying to get that to work
18:39:48 <Olathe> > ﻿﻿let fib n = (phi^n - (phi-1)^n) / sqrt 5 where phi = (1 + sqrt 5)/2 in fib 1000000
18:39:50 <dmwit> > let ((a, b), (c, d)) $* ((a', b'), (c', d')) = ((a*a'+b*c',a*b'+b*d'),(c*a'+d*c',c*b'+d*d')); x $^ 1 = x; x $^ y | even y = let x' = x $^ (y `div` 2) in x' $* x' | odd y = x $* (x $^ (y - 1)) in ((1, 0), (0, 1)) $^ 32
18:40:04 <lambdabot>   thread killed
18:40:06 <lambdabot>   thread killed
18:40:10 <dmwit> bwahaha
18:40:10 <Olathe> Yay !
18:40:15 <cads> hehe
18:40:19 <Olathe> > let fib n = (phi^n - (phi-1)^n) / sqrt 5 where phi = (1 + sqrt 5)/2 in fib 1000000
18:40:40 <Olathe> cads: You have >       let fib n = (phi^n - (phi-1)^n) / sqrt 5 where phi = (1 + sqrt 5)/2 in fib 30
18:40:48 <Olathe> A bunch of weird stuff to start your lines.
18:41:01 <cads> why doesn't it work though?
18:41:05 <lambdabot>   thread killed
18:41:14 <Olathe> > let fib n = (phi^n - (phi-1)^n) / sqrt 5 where phi = (1 + sqrt 5)/2 in fib 30
18:41:17 <pjdelport> FunctorSalad: shouldn't the (.β) be (β.) ?
18:41:21 <lambdabot>   832039.9999999999
18:41:26 <Olathe> Looks like it works.
18:41:53 <Olathe> 832040 is the true value.
18:41:59 <cads> yes
18:42:05 <FunctorSalad> pjdelport: hmm right (when using the usual confusing convention)
18:42:13 <thatsright> does ghc use its own parser?
18:42:19 <cads> derived this stuff while I was in jail hehe
18:42:23 <Olathe> cads: Try saying > 5
18:42:28 <cads> > 5
18:42:38 <lambdabot>   5
18:42:41 <Olathe> Ahh.
18:42:42 <pjdelport> FunctorSalad: oh, it might be useful to note whichever convention you're using :)
18:42:46 <pjdelport> in that case
18:42:51 <Olathe> Before, it had some weird crap at the beginning. Now, it doesn't.
18:43:02 <Olathe> Did you copy and paste or something ?
18:43:59 <cads> weird crap as in something invisible? yeah I copied it from what I wrote earlier but that was supposed to be a legal statement as far as I know
18:44:15 <pjdelport> FunctorSalad: i just noticed the curry/uncurry is also reversed;  missed that initially
18:44:27 <Olathe> cads: Yep, something invisible.
18:44:33 <Olathe> Oh well.
18:44:36 <cads> I will work it out
18:44:51 <pjdelport> FunctorSalad: is the intended audience Haskell programmers?
18:44:51 <cads> I must go now, later
18:44:52 <FunctorSalad> pjdelport: one second, uploading new version with your suggestions
18:45:03 <dmwit> ?bot
18:45:56 <Olathe> How do I turn on timings on ghci ?
18:46:05 <FunctorSalad> done ( http://preview8.awardspace.com/tinycategory.awardspace.com/applicative.xhtml )
18:46:11 <dons> woop woop woop http://www.reddit.com/r/programming/comments/6zxv2/oh_yeah_xmonad_08_released/
18:46:22 <pjdelport> FunctorSalad: oh, the "← curry" and "uncurry →" arrows later are close to what i had in mind earlier
18:46:28 <Myoma> :set +s
18:46:35 <dons> u can haz the new xmonadz now
18:46:46 <andrewsw> sweet
18:46:51 <thatsright> what are -prof libraries for exactly?
18:46:53 <FunctorSalad> pjdelport: I'm not sure yet. I guess it's for people who already know a bit but would like to consolidate their knowledge with pretty diagrams
18:47:13 <Olathe> Myoma: Thanks :)
18:47:14 <dons> point of note: no new serious bugs found in the last release cycle.
18:47:34 <pjdelport> FunctorSalad: ok, i just thought that it might be a good idea to stick to Haskell's convention of (.), curry, uncurry and so on
18:47:41 <pjdelport> if it's aimed at Haskellers
18:47:52 <FunctorSalad> pjdelport: actually the idea is to illustrate examples of Applicatives by diagrams, but got a bit lost trying to explain how to deal with function types diagramaticall#y
18:48:22 <cjs> Hmmm. So how might I get "ghc -hidir ... -odir ... -e foo Foo.hs" not to use the compiled version of Foo.hs, but to use the compiled versions of everything else?
18:49:30 <dmwit> Olathe: Programming challenge: how big of a fibonacci number can you compute in under (say) 1s?
18:49:46 <Olathe> Oh, using wli's thing, pretty big.
18:50:14 <dmwit> Oh, somebody already's done this?
18:50:15 <dmwit> bummer
18:50:16 <pjdelport> FunctorSalad: maybe the "inserting an odd case" and "and another one" diagrams should be combined
18:50:28 <ddarius> dons: Serious bugs were found in the release cycle preceding that?
18:50:29 <pjdelport> FunctorSalad: that is, have id in the middle
18:50:34 <dmwit> Olathe: I was going to challenge you to beat my 6800000 in ghci. =)
18:50:39 <pjdelport> FunctorSalad: and 'unit' and 'eval' to the left and right
18:50:51 <pjdelport> FunctorSalad: it makes the symmetry much more obvious
18:51:12 <dons> ddarius: our competitors have serious bugs on a weekly basis
18:51:26 <dons> so just like to remind people
18:51:29 <FunctorSalad> pjdelport: hmm, but it's a different id. or are you proposing to start with the triangular identity situation right away?
18:51:55 <FunctorSalad> pjdelport: or I think you mean having the two different id's side by side
18:52:05 <Olathe> Let me try
18:52:35 <pjdelport> FunctorSalad: possibly
18:53:07 <cjs> Hm. Is there a way to tell runghc which function to evaluate?
18:53:08 <Olathe> dmwit: take 1 $ reverse $ show $ ffib 6800000 (11.75 secs, 135233744 bytes)
18:53:48 <dmwit> Olathe: It could be a difference in computer speeds; P IV, 3.2GHz here.
18:54:10 <Myoma> I start to get the impression with a bit more automation that correctness proofs can be realistic
18:54:31 <dons> Myoma: in which domain?
18:54:32 <Olathe> I'm trying it without show.
18:54:36 <Olathe> Maybe it'll be faster.
18:54:47 <dmwit> Olathe: Also, yes, I used (==) for my forcing function rather than show.
18:54:58 <Olathe> Man, this takes a while to print out.
18:55:00 <dmwit> Olathe: With show, 6.8e6 takes 4s.
18:55:11 <Myoma> like any of the standard libraries you use and programming
18:55:26 <cjs> Hm. I guess I can be evil and just move the .o out of the way before running the program with ghci -e, and move it back after.
18:55:36 <lambdabot> Plugin `dummy' failed with: thread killed
18:55:42 <Olathe> (41.75 secs, 495343928 bytes)
18:55:52 <dmwit> ewww, yeah, don't print the whole value
18:55:59 <Olathe> How do you use (==) ?
18:56:14 <Myoma> use rnf instead
18:56:15 <Olathe> (== 0) ?
18:56:24 <Olathe> rnf ?
18:56:46 <Olathe> ffib 6800000 == 0 (1.27 secs, 16670024 bytes)
18:56:49 <dmwit> Olathe: I use http://hpaste.org/10147
18:57:11 <dmwit> Olathe: Nice!
18:57:31 <FunctorSalad> pjdelport: it's a bit strange calling them "unit" and "eval", but I don't know a more specific name for the unit of the exponential :)
18:57:45 <dons> please support your leading open source haskell project by cabal installing xmonad-0.8 and telling us how it goes
18:57:49 <dons> :)
18:57:55 <haskellian> a
18:58:14 <haskellian> what do i need to do graphics in haskell?
18:58:18 <haskellian> opengl only?
18:58:24 <dmwit> dons: Does that show support for xmonad, or for cabal-install? =P
18:58:25 <dons> what kind of graphics?
18:58:37 <dons> dmwit: well, it shows support to devs of both projects :)
18:58:55 <FunctorSalad> haskellian: if you just want to render images to the screen, a quick way is SDL
18:58:57 <dmwit> haskellian: OpenGL is one favorite for hardcore 3D graphics, wxHaskell and Gtk2Hs are good for GUIs
18:59:12 <dons> i've used gd, gtk, opengl, sdl. all good.
18:59:13 <dmwit> and yeah, SDL is nice for 2D stuff
19:00:15 <haskellian> i want to do basic raytracing and/or casting
19:00:21 <dmwit> \bot sure seems dead
19:00:52 <dons> haskellian: raytracing eh? so blitting to a canvas, live?
19:01:14 <cjs> @yow
19:01:38 <cjs> Hm. Well, you can borrow the one on #mhailist if you like.
19:02:19 <haskellian> yes
19:02:36 <cjs> Though @yow isn't working so well there, either. :-) ("Couldn't find fortune file")
19:02:50 <Olathe> How unfortunate.
19:03:07 <pjdelport> misfortune strikes
19:03:15 <dmwit> Olathe: Out of curiosity, what is wli's implementation?
19:03:20 <Olathe> One sec.
19:03:20 <ddarius> dons: You didn't actually answer my question.
19:03:31 <Olathe> > let ffib :: Int -> Integer ; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g in ffib 30
19:03:47 <Olathe> @bot
19:04:42 <dons> ddarius: ah, let me check.
19:04:51 <dons> ddarius: i was trying to explain the motivation for that line.
19:05:46 <dons> looks like last crash bug was Thu Mar 27
19:06:30 <dons> there was an error fixed on May 2, that affected the OLPC.
19:06:59 <andrewsw> OT, I know, but was there a xine/xmonad crasher bug reported?
19:07:19 <dons> hmm, not that i know of.
19:07:25 <dons> people sometimes have trouble with nvidia twinview
19:07:30 <dmwit> andrewsw: If you've seen one, tell us about it in #xmonad.
19:07:48 <andrewsw> yeah, I haven't had time to do more than restart x.
19:07:52 <dmwit> dons: I think "xine" is a media player (unrelated to Xinerama).
19:07:56 <ddarius> dons: Are those in xmonad itself or in the X11 bindings?
19:07:57 <andrewsw> yes
19:08:19 <tibbe> dons: howdy, how's it going?
19:08:19 <dons> ddarius: one was xmonad, one was the X11 binding (which has indeed been the main source of bugs)
19:08:24 <dons> hey tibbe!
19:08:31 <dons> tibbe: still on track to visit in 2 weeks?
19:08:36 <tibbe> dons: yes
19:08:40 <dons> sweet.
19:09:06 <tibbe> dons: I'm trying to get something together during this and next weekend and if I do I can have a short talk about my web server
19:09:14 <dons> that'd be aweseom.
19:09:38 <dons> or any general tech talk of interest to a bunch of os, language, fp/formal methods and networky people
19:09:40 <tibbe> but there's one little knot to untangle first :)
19:09:57 <dons> the web server talk would be very good to see.
19:10:03 <tibbe> I could do a vaporware talk about Byte String Table ;)
19:10:11 <dons> tibbe: i'll send you some more details about the visit.
19:10:16 <tibbe> perfect
19:11:00 <andrewsw> not sure. what's the best way to tell?
19:11:04 <andrewsw> dang
19:13:42 * tibbe really needs to get a computer that linux and try out xmonad
19:14:39 <sjanssen> tibbe: what are you on now?
19:15:16 <tibbe> sjanssen: os x
19:15:24 <tibbe> sjanssen: I guess I could try it here
19:15:34 <tibbe> but I'm not sure how cooperative os x would be
19:15:44 <sjanssen> it works
19:15:53 <tibbe> :)
19:16:00 <sjanssen> only with X11.app and X11 applications, of course
19:16:01 <tibbe> but does it look beautiful? ;)
19:16:04 <tibbe> sure
19:18:16 <mmorrow> sjanssen: here's a first go at the TH string optimizer http://hpaste.org/10144
19:18:38 <lambdabot> I'll eat ANYTHING that's BRIGHT BLUE!!
19:18:41 <mmorrow> sjanssen: i still have to optimize the generated code => get rid of those lambdas
19:18:51 <mmorrow> @botsmack
19:18:57 <mmorrow> > 1
19:19:03 <sjanssen> mmorrow: GHC will kill the lambdas, I'm sure
19:19:04 <lambdabot> :)
19:19:10 <sjanssen> mmorrow: why [0]
19:19:10 <mmorrow> sjanssen: nice
19:19:23 <sjanssen> instead of 0
19:19:47 <mmorrow> sjanssen: oh, i made it so it can handle dups of the same string and put both values at its leaf
19:20:12 <sjanssen> ahh, I see
19:20:51 <mmorrow> i'm gonna put the code somewhere in a bit and i'll link you
19:21:30 <mmorrow> the type is
19:21:32 <mmorrow> deriveLookup :: (Lift a) => ExpQ -> [(String,a)] -> ExpQ
19:21:46 <mmorrow> i could just as well do
19:21:54 <mmorrow> deriveLookup :: (a -> ExpQ) -> ExpQ -> [(String,a)] -> ExpQ
19:22:03 <mmorrow> @src Lift
19:22:24 <mmorrow> class Lift a where lift :: a -> ExpQ
19:23:53 <ddarius> dons: You should make a count of all the crash inducing bugs in various window managers and compare.
19:24:17 <tibbe> ddarius: that would be cool
19:33:44 <dons> ddarius: that might actually be feasible
19:34:27 <TomMD> Do you know off hand what xmonads count is?
19:34:34 <TomMD> 10?
19:35:35 <dons> count of serious bugs?
19:36:12 <TomMD> Yes, ones that will cause the wm to exit.
19:36:19 <TomMD> or be unusable.
19:36:22 <dons> i don't know the count. sjanssen, any thoughts?
19:36:33 <dons> a dozen? something like that.
19:36:45 <dons> in the last year, i'd say a handful, yeah.
19:36:47 <TomMD> I was just thinking it probably only happened to me twice since May 2007.
19:36:51 <lambdabot>   thread killed
19:36:53 <dons> yeah.
19:37:04 <dons> i noticed i hadn't changed my xmonad since june. 3 months, no issues.
19:37:54 <Nafai> dons: Not even the config?
19:38:13 <TomMD> Config?  You can configure this thing!?!?  ;-)
19:40:43 <dons> Nafai: i haven't changed my config, no.
19:41:36 <Nafai> I guess if you get things working, why not?
19:42:23 <dons> main = dzen $ \x -> xmonad $ x
19:42:23 <dons>         { terminal           = "term" }
19:42:23 <dons>          `additionalKeys`
19:42:23 <dons>         [ ((modMask x , xK_p), runOrRaisePrompt defaultXPConfig { position = Top })]
19:42:28 <dons> that's all.
19:42:50 <lispy_> ?tell cale Looks like my server is having issues
19:42:53 <lispy_> Oh wait
19:42:56 <lispy_>  that won't work
19:42:59 <lispy_> Cale: ping?
19:43:01 <Nafai> Wow, that's it?
19:43:14 <Nafai> So the defaults are good enough for you?
19:43:26 <dons> i guess that's why they're defaults :)
19:43:38 <lispy_> dons: hey, sorry I totally forgot about our plans by Thursday
19:43:52 <lispy_> dons: I remembered them this morning
19:43:58 <dons> lispy_: 'sok, looks like the hackathon is on though
19:44:05 <lispy_> good deal
19:44:22 <TomMD> Another hackathon? When?
19:44:36 <dons> darcs hackathon.
19:44:51 <TomMD> Oh, ok.
19:44:54 <lispy_> late october
19:46:37 <Cale> lispy_: hello?
19:47:27 <lispy_> Cale: I don't know why but I lost my connection to olive
19:47:36 <Cale> lispy_: I can't ssh to it either
19:47:44 <lispy_> Cale: yeah, _just_ happened
19:48:01 <lispy_> Cale: I'm trying to contact someone...may need physical intervention but it's a friday
19:48:04 <Cale> @bot
19:48:22 <Cale> Seems lambdabot is not really alive either.
19:51:26 <golubovsky> @pl a + b
19:52:40 <golubovsky> @pl \g -> foldr (<+>) (map prFunc $ gFuncs g)
19:52:51 <cjs> Hey, you know, it occurs to me that I might have a spare day in Victoria after ICFP.
19:53:41 <cjs> Right, 'cause I decided not to do any of the developer tracks. Hackathon anyone?
19:53:53 <cjs> (That would be Saturday the 27th.)
19:54:48 <TomMD> cjs: You might want to send something to the cafe about that.
19:55:38 <cjs> Good thought.
19:55:57 <catechu> I'm a Haskell newbie. I've propped up some code with unsafePerformIO -- how can I figure out how to translate it to "safe" code?
19:57:13 <mmorrow> paste it @ hpaste.org
20:00:27 <roconnor> @paste
20:00:39 <roconnor> @hpaste
20:00:45 <roconnor> @where paste
20:00:52 <roconnor> @where lambdabot
20:01:45 <TomMD> www.hpaste.org/new
20:01:59 <roconnor> @TomMDsnack
20:02:08 <TomMD> :-)
20:04:39 <catechu> regarding my question about writing "safe" code: http://hpaste.org/10148#a0
20:05:59 <Myoma> what do you mean by "safe"
20:06:14 <catechu> Myoma: I used "unsafePerformIO"
20:06:34 <Myoma> I wish it would be called impureRunIO or something instead
20:06:57 * roconnor winces at the unsafeness
20:07:32 <Myoma> actually that's not as catchy as unsafePerformIO
20:07:40 <roconnor> catechu: make randomChoice :: [a] -> IO a
20:07:50 <TomMD> roconnor: Never look at the Linux kernel... or any kernel besides House.  Your head might explode.
20:08:11 <catechu> roconnor: I did this, but then how can I get the results?
20:09:51 * roconnor ponders this
20:09:59 <unmarshal> if i'd like to profile a program that doesn't have profiling libraries for an included package, is all hope lost or is there a way to skip over it?
20:10:08 <roconnor> catechu: there are lots of ways
20:10:45 <roconnor> catechu: using mfix or mdo would let you write the code in a similar way
20:10:52 * roconnor wonders if mfix is safe for IO
20:11:34 <dons> unmarshal: you need to install the profiling versions as well
20:11:38 <dons> e.g. cabal install foo -p
20:11:49 <catechu> roconnor: OK -- I'm interested in the canonical way of doing it
20:12:02 <unmarshal> thanks dons
20:12:05 <unmarshal> will give it a shot
20:12:12 <catechu> roconnor: Technically the unsafePerformIO works, but it's not "pure" :)
20:12:49 <mmorrow> roconnor: yes it's safe for IO
20:12:56 <mmorrow> (mfix)
20:12:56 <ddarius> Your main function is bizarre
20:13:50 <mmorrow> catechu: generatedTokens is pretty cool
20:13:53 <Cale> catechu: The only place you're calling that unsafePerformIO'd function is main, isn't it?
20:14:10 <mmorrow> yeah
20:14:30 <Cale> catechu: Why not just leave it as an IO action and execute it from main, rather than using unsafePerformIO?
20:14:33 <catechu> Cale: it is called in randomChoice -- selecing a random item from a list. this seemed straightforward enough to me
20:14:33 <roconnor> mdo { generatedTokens <- liftM ([first,second]++) $ sequence [ (getNextWord w1 w2) | (w1, w2) <- zip generatedTokens (tail generatedTokens)] }
20:15:00 <mmorrow> roconnor: will that produce results /immediately/ though?
20:15:02 <Cale> catechu: I mean, why not leave  randomChoice :: [a] -> IO a
20:15:03 <roconnor> I guess the canonical solution would be to use a loop with a pair of state variables
20:15:15 <roconnor> mmorrow: what do you mean?
20:15:26 <Cale> or, ah, I see
20:15:42 <Cale> You're calling it in getNextWord, which is defined in that let, okay.
20:16:01 <catechu> Cale: The only reason is that I was having issues "unIO"-ing the results
20:16:02 <mmorrow> sequence (repeat (return 0 :: IO Int))
20:16:09 <mmorrow> never returnsw anything
20:16:24 <mmorrow> i think he /needs/ unsafePerformIO here
20:16:36 <mmorrow> in the same way that getContents /needs/ it
20:16:57 <ddarius> getContents uses unsafeInterleaveIO
20:16:58 <Cale> Well, not necessarily. He could just pass in a StdGen...
20:17:18 <mmorrow> ddarius: that's essentially     \io -> return (unsafePerformIO io)
20:17:18 <Cale> :t newStdGen
20:17:24 <Cale> oh right, no bot
20:17:26 <Cale> hmm
20:17:58 <mmorrow> yeah, the only way i see is to either change randomChoice to not be IO, or use unsafePerformIO
20:17:59 <roconnor> mmorrow: oh
20:18:00 <ddarius> mmorrow: Roughly, but not actually and that is not an appropriate instance for GHC (which is why that is not its source.)  But the point is, unsafeInterleaveIO is a primitive on its own.
20:18:03 <roconnor> the infinite list
20:18:09 <Cale> mmorrow: Or take another parameter.
20:18:13 <ddarius> Using unsafeInterleaveIO is not equivalent to using unsafePerformIO.
20:18:14 <roconnor> I see the problem now.
20:18:26 <catechu> So my point of confusion is -- what is the "right" way of doing this?
20:18:35 <mmorrow> ddarius: i believe so
20:18:47 <catechu> My code does what I want it to do (almost), but this unsafePerformIO is bugging me
20:18:47 <Cale> catechu: I would use a StdGen more directly.
20:19:13 <Cale> newStdGen :: IO StdGen
20:19:17 <Cale> randomR :: forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
20:19:42 <Cale> (well, you already know about randomR
20:19:43 <Cale> )
20:22:02 <catechu> My problem is with the IO object -- in generatedTokens, if I change to using a StdGen, how can I "unwrap" the data and use it in the list comprehension
20:26:29 <roconnor> catechu: would mfix/mdo with a StateMonad/MonadRandom work here?
20:27:07 <roconnor> I think it would
20:27:24 <catechu> roconnor: I think so as well, my only question is how this is normally done
20:28:12 <roconnor> catechu: hmmm, I'm not sure I'd say normally.  But I think it is as good as or better than the normal way.
20:29:35 <catechu> roconnor: Is unsafePerformIO an avoided solution?
20:29:43 <Cale> catechu: generally
20:29:58 <roconnor> I would avoid unsafePerformIO in this instance.
20:30:34 <catechu> ok. Where can I learn how to accomplish what I'm trying to do? (that is, using a random item selector within a list comprehension)
20:31:04 <roconnor> the list comprehension isn't the problem, it is your tying the knot that is the issue
20:31:19 <roconnor> which points us towards an mfix/mdo solution.
20:31:31 <catechu> Tying the knot?
20:31:53 <roconnor> generatedTokens appears in the definition of generatedTokens.
20:32:22 <catechu> ok -- and that's an issue?
20:32:30 <roconnor> we call it tying the knot because generatedTokens is data rather than a function
20:32:52 <roconnor> catechu: it isn't wrong, but if you want to make it "monaic" you need to use mfix/mdo to do the same thing
20:33:48 <mmorrow> ddarius: so it's different in GHC because of optimizations http://www.mail-archive.com/cvs-all@haskell.org/msg11073.html
20:34:55 <catechu> roconnor: hmm...can I preserve the list comprehension, or would mfix/mdo require a restructuring of the code?
20:35:08 <Cale> http://hpaste.org/10148#a1
20:35:23 <Cale> That could be cleaned up a bit
20:35:49 <roconnor> catechu: I think you should be able to write what I wrote above with MonadRandom ... assuming someone has defined an instance of MonadFix
20:36:00 <ddarius> mmorrow: Meaning they have different semantics and semantic guarantees which is my point.
20:36:17 <Cale> the parameter to generatedTokens is actually unnecessary
20:36:25 <Cale> as an appropriate g is already in scope there
20:36:42 <Cale> But do you see what I did?
20:36:54 <mmorrow> ddarius: it's not clear to me that they /have/ different semantics (is this specified somewhere?), only that the ghc implementors decided that they felt that they should.
20:36:55 <roconnor> what Cale wrote would be the normal way of doing this.
20:38:59 <roconnor> I think an mfix solution would be cooler. ... if it works
20:39:00 <catechu> OK -- this is good, now I have an example to study
20:39:15 <Cale> catechu: The general principle of pure functions is that if the result depends on something, then that should be a parameter.
20:39:56 <Cale> catechu: In this case, the result depends on the state of the (pseudo) random generator, so that needs to be a parameter that gets passed along as the lazy list is built up.
20:40:42 <mmorrow> ddarius: here is yhc's hGetContents implem: http://hpaste.org/10149
20:40:43 <Cale> It's slightly unfortunate that I was unable to preserve the nice zipWith xs (tail xs) kind of recursion though.
20:40:48 <ddarius> mmorrow: Do you believe the latter example should be the same as the version inlined?
20:41:28 <ddarius> mmorrow: I'm well aware that some implementations implement unsafePerformIO that way.
20:41:28 <mmorrow> ddarius: i'm not sure, i have to think about it
20:41:59 <ddarius> mmorrow: Then think about it.  If you decide that they shouldn't be the same, then there you go.  If you decide that they should, talk to Simon.
20:42:01 <roconnor> aww, we need to write a MonadFix instance for Rand and RandT
20:42:21 <ddarius> s/unsafePerformIO/unsafeInterleaveIO
20:43:14 <mmorrow> ddarius: haha, you're funny. (i'm not patronizing)
20:43:30 <mmorrow> :)
20:45:31 <mmorrow> (i will get back to you though on which way i decide i think it should be, though)
20:45:39 <catechu> Thanks for your help guys!
20:45:45 <mmorrow> s/, though//
20:46:26 <roconnor> oh, just adding deriving MonadFix for Rand would work
20:46:52 <roconnor> s/Rand/RandT/
20:50:01 <ddarius> mmorrow: Actually, I misphrased the question (though you probably got the correct interpretation.)  As the email suggests, the question is if the bottom code snippet is a valid implementation of the top snippet.
20:50:28 <mmorrow> yeah, i was about to say something to that effect
20:53:59 <Myoma> @nikon
20:54:25 <Myoma> :( ...
20:57:15 <mmorrow> ddarius: ok, so the issue is if unsafeInterleavIO = return . unsafePerformIO and it gets inlined, then there's the possibility the unsafePerformIO can get floated out of the containing IO function. i'm not yet sure though what that would mean in terms of program behaviour..
20:57:41 <mmorrow> (i'm summarizing for my own sake)
21:01:46 <ddarius> mmorrow: What is the output of do () <- f 1; () <- f 2; ?
21:02:08 <mmorrow> i dunno, i'm about to check though
21:05:50 <dmwit> :t ($^)
21:06:40 <Cale> wait, what?
21:06:44 <Cale> Lambdabot is here?
21:06:53 <dmwit> Apparently only partly here. =P
21:07:15 <Cale> lispy's machine was b0rked.
21:07:28 <Cale> I'll see if I can ssh in now :)
21:08:37 <Cale> If it comes back, we'll know that something is working ;)
21:12:02 <mmorrow> ddarius: interesting
21:12:53 <Cale> ssh: connect to host codersbase.com port 22: Connection timed out
21:13:13 <Cale> ...
21:13:17 <Cale> How the...
21:13:27 <Cale> @bot
21:13:35 <lambdabot> :)
21:13:38 <Cale> hmm
21:13:43 <Cale> :t foldr
21:13:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:13:58 <Cale> Well, slow, but working at least.
21:14:11 <Cale> I can't ssh in.
21:14:31 <Cale> ah, I can :)
21:14:57 <ivanm> Cale: stop lying!
21:15:03 <Cale> Ah, it was a shitload of runaway mueval processes.
21:15:47 <Cale> @tell lispy Problem fixed? :)
21:15:47 <lambdabot> Consider it noted.
21:16:14 <ivanm> Cale: so there's no way of killing dead mueval processes?
21:16:30 <ivanm> I thought lambdabot switched to mueval because it was better than hs-plugins
21:16:32 <ivanm> :s
21:17:17 <Cale> There is, if I'm around. I suppose I could just have something do killall mueval once an hour. It might kill the occasional user request, but that's probably acceptable.
21:18:10 <ivanm> well, mueval dies enough as it is ;-)
21:21:09 <Olathe> Does anyone have any suggestions for http://hpaste.org/10151 (particularly speedups) ?
21:22:20 <roconnor> type Poly a b = [(a,b)]
21:23:09 <Olathe> Alright, I'll read up on making types.
21:23:15 <roconnor> newType Poly a b = Poly [(a,b)], perhaps
21:23:35 <roconnor> then you can consider making showPoly an instance of Show
21:23:54 <Olathe> Ahh, that would be nice.
21:24:00 <Cale> (With the type synonym, you won't have to change any of the code, but you don't get any direct benefits apart from tidying up the type signatures.)
21:24:23 <heatsink> Olathe: You may get speedup by specializing some functions for particular Num or Integral instances.
21:24:27 <roconnor> you could even consider make Poly an instance of Num
21:24:39 <Olathe> How do you specialize functions ?
21:24:47 <Olathe> Just change the type of them ?
21:24:50 <heatsink> In GHC there's a SPECIALIZE pragma
21:24:53 <Cale> With the newtype, you will have to do some explicit wrapping/unwrapping, but it means that you get to make it instances of various classes.
21:24:54 <Olathe> Ahh.
21:25:09 <Cale> Are you asking how to make things instances of typeclasses?
21:25:12 <heatsink> {-# SPECIALIZE lagrange :: [Int] -> [(Ratio Int, Int)] #-}
21:25:25 <Cale> Like, if you wanted your own instance of Num for Poly a b ?
21:25:29 <Olathe> No, how to "overload" a function for specialized argument types.
21:25:41 <Olathe> Yes, Num and Show would be great :)
21:26:09 <Cale> SPECIALIZE pragmas just get the compiler to generate code for polymorphic functions at specialised argument types
21:26:14 <Olathe> I'd like to be able to handle both Fractionals and Ratios.
21:26:19 <Olathe> Ahh, OK.
21:26:19 <Cale> typeclasses are how you 'overload' things
21:26:30 <Cale> But it's not quite just overloading.
21:27:03 <mmorrow> i was thinking about doing polys in more than one var, and i didn't write any code but was thinking something along the lines of  (say "x":=0, "y":=1, etc) Poly a = [(a,[(Int,Int)])]
21:27:09 <mmorrow> @Olathe ^^
21:27:10 <lambdabot> Unknown command, try @list
21:27:50 <Cale> mmorrow: I find that generalising to monoids is a rather nice way to do things.
21:28:02 <mmorrow> 2*x^7*y + x*y - 32*x === [(2,[(0,7),(1,1)]),(1,[(0,1),(1,1)]),(32,[(0,1)])]
21:28:04 <Cale> (that is, the monoid ring construction)
21:28:09 <mmorrow> Cale: interesting
21:28:27 <Cale> I'll look for my code...
21:28:32 <mmorrow> Cale: cool
21:29:38 * roconnor my multivariable polynomial implementation: http://r6.ca/FewDigits/_darcs/current/Data/Multinomial.hs
21:29:56 <roconnor> s/my/'s
21:30:09 <mmorrow> roconnor: interesting
21:30:57 <Cale> mmorrow: Then you just need a 'bag' monoid instance.
21:31:00 <roconnor> zP :: (Num a) => Polynomial (Polynomial (Polynomial a))
21:31:00 <roconnor> zP = constP yP
21:31:12 <Cale> hpaste is slow...
21:31:25 <Cale> Also, even though I tell hpaste to remember me, it never ever does.
21:31:41 <mmorrow> haha
21:31:46 <dmwit> Cale: I know, that's so annoying.
21:32:34 * mmorrow has his browser killall of its cookies/history/etc when it quits
21:32:43 <dmwit> bwuh
21:32:48 <dmwit> In case of FBI?
21:32:52 <roconnor> f = xP*xP*yP
21:32:52 <roconnor> prop_test_dx = dx f == 2*xP*yP
21:32:52 <mmorrow> zactly
21:33:55 <bos> @seen ketil
21:33:55 <lambdabot> ketil is in #haskell and #darcs. I don't know when ketil last spoke.
21:34:01 <roconnor> prop_test_dxy = dx (dy f) == dy (dx f)
21:34:01 <Cale> grr... is hpaste up, or does my connection just suck?
21:34:02 <Olathe> > (1%2) + (1::Int)
21:34:04 <lambdabot>   Couldn't match expected type `Ratio t' against inferred type `Int'
21:34:13 <Olathe> Inferred ?
21:34:16 <Olathe> Heheh
21:34:21 <ddarius> It's you.
21:34:38 <mmorrow> Cale: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
21:35:03 <Olathe> Why aren't Ratios Fractionals ?
21:35:06 <Olathe> Or are they ?
21:35:08 <Cale> http://hpaste.org/10152
21:35:21 <Cale> mmorrow: as soon as you said that, it finally finished :)
21:35:25 <roconnor> @instances Fractional
21:35:25 <lambdabot> Double, Float
21:35:37 <roconnor> hmm
21:35:43 <mmorrow> Cale: heh
21:35:43 <roconnor> doesn't list polymorphic instances
21:36:27 <Olathe> > let f :: (Fractional a) => a -> a; f a = a in f (1%2)
21:36:29 <lambdabot>   1%2
21:36:32 <Olathe> Ahh.
21:36:51 <mmorrow> Cale: hmm, this way looks nice.
21:37:11 <Olathe> > let f :: (Integral a) => (Ratio a) -> (Ratio a); f a = a/2 in f (1%2)
21:37:12 <lambdabot>   1%4
21:37:38 <Cale> You get normal polynomials by just using the additive monoid for Integer (and not using negative indices)
21:38:02 <Olathe> > let f :: (Integral a, Fractional b) => a -> b; f a = a/2 in f 1
21:38:02 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
21:38:16 <Cale> For multiple indeterminates, you just need a Bag/Multiset datatype with the union monoid.
21:38:33 <mmorrow> Cale: very cool
21:38:36 <Cale> For multiple noncommuting intedeterminates, you can just use the list/concatenation monoid.
21:39:32 <dons> > say [greek 10] -- supposed to work?
21:39:33 <lambdabot>   mueval: Prelude.read: no parse
21:39:41 <mmorrow> dons: i'll fix
21:39:51 <Cale> dons: local definitions might have been reset :)
21:40:06 <Olathe> What is greek ?
21:40:09 <ddarius> For multiple non-commuting, non-associative indeterminates, you can just use the Tree/Branch magma with identity!
21:40:24 <Olathe> > say "hi"
21:40:24 <lambdabot>   mueval: Prelude.read: no parse
21:40:38 <mmorrow> > say [greek 10]
21:40:39 <lambdabot>   mueval: Prelude.read: no parse
21:40:41 <mmorrow> ah
21:40:47 <Olathe> > say "hi"
21:40:48 <lambdabot>   hi
21:40:58 <Cale> ddarius: :)
21:40:59 <roconnor> @src say
21:40:59 <lambdabot> Source not found. My brain just exploded
21:42:29 <Olathe> roconnor: http://hpaste.org/10153
21:42:32 <mmorrow> heh, someone beat me to it
21:43:16 <mmorrow> > say [greek 10]
21:43:17 <lambdabot>   mueval: Prelude.read: no parse
21:43:23 <Cale> Of course, there are some other fun monoid rings... I wrote that code in order to play around with the ring over the monoid of Young tableux.
21:43:26 <mmorrow> @types greek
21:43:27 <lambdabot> Not in scope: `greek'
21:43:27 <roconnor> oh it does utf8 encoding.
21:43:33 <roconnor> in one line!
21:43:38 <Olathe> Yes, it's quite nice :)
21:43:40 <roconnor> take that C++
21:43:53 <Olathe> That's from mmorrow, iirc.
21:43:57 <mmorrow> > say [greek 10]
21:43:58 <lambdabot>   λ
21:44:01 <mmorrow> yes
21:44:31 <mmorrow> roconnor: heh, yeah. a utf8-encode one-liner
21:44:36 <Cale> hpastetwo is *so* much faster than hpaste for me
21:45:01 <mmorrow> Cale: isn't hpaste2 nice? i love it
21:45:11 <dons> mmm.
21:45:21 <dons> time to migrate over?
21:45:28 <dons> just move hpaste1 to a backup url
21:45:31 <dons> and start on the new hpaste?
21:45:47 <Olathe> Is there a way to transfer old pastes ?
21:45:50 <dons> i'll bug glguy to release it next week
21:45:56 <roconnor> mmorrow: I bet it could be shorter
21:45:59 <Olathe> Not sure how important keeping old pastes is.
21:46:01 <mmorrow> dons: i wouldn't complain
21:46:16 <Olathe> roconnor: Go for it :)
21:46:18 <mmorrow> roconnor: go for it.
21:46:19 <dons> i'm not sure we need to migrate. but just leave 'em up if people need it.
21:46:25 * roconnor goes for it
21:46:33 <dons> Cale: its a much simpler design.
21:46:38 <dons> just a database backing fastcgi app
21:47:02 <mmorrow> with takusen
21:47:06 * roconnor gives up
21:47:08 <dons> yeah
21:47:23 <mmorrow> roconnor: i'll hstidy it for you
21:47:52 <Cale> It might also have something to do with its location on the internet relative to me, though traceroute doesn't show any problems between me and hpaste.org.
21:48:21 * ddarius never has any performance problems with hpaste 
21:48:44 <mmorrow> roconnor: http://hpaste.org/10153#a1
21:51:27 <hackage> Uploaded to hackage: dotgen 0.1.1
21:52:21 <mmorrow> Cale: the highlighting feature is also nice. (un)highlighting a line is is immediately visible by everyone
21:52:34 <Cale> Hmm... I think the monoid ring construction might be a monad on the category of monoids.
21:53:23 <mmorrow> hmm, that'd be cool if it is
21:54:57 <ddarius> Cale: Probably is.
21:55:15 <Cale> With return just being the obvious thing, taking an element of the monoid to the element of the monoid ring, and join just multiplying through/adding the polynomials that the polynomial is constructed over
21:55:19 <mmorrow> hmm, how would you express the Monoid a contraint in the Monad instance though
21:55:29 <Cale> You can't make it an instance of Monad in Haskell.
21:55:33 <mmorrow> damn
21:55:36 <Cale> Because it's not a monad on Hask.
21:55:46 <mmorrow> ahh, yeah
21:56:03 <mmorrow> interesting...
21:56:47 <Cale> You can write a new typeclass specifically for monads in the category of monoids in Hask.
21:56:55 <Olathe> What is Hask ?
21:57:09 <Cale> The category of Haskell types and Haskell-definable functions between them.
21:57:13 <Olathe> Ahh.
21:58:36 <Cale> It's really kind of unfortunate...
21:59:35 <Cale> It's actually quite tricky to work out how to generalise typeclasses so that things like Set and, say, MonoidRing n can be instances of Monad.
22:00:17 <Cale> You can split up the Monad class in a horrible way...
22:01:40 <Cale> I wonder if there's a nice translation for typeclasses which would do the horrible splitting under the covers and allow you to define refined instances for which polymorphic class methods have their type variables restricted by a typeclass.
22:02:41 <mmorrow> Cale: that would be extremely handy
22:03:18 <Cale> That may make type inference a good deal harder in general though...
22:03:32 <Cale> For instance, what is the type of  fmap  in a general occurrence then?
22:04:24 <Cale> fmap :: (Functor f, ??? a, ??? b) => (a -> b) -> f a -> f b
22:05:03 <mmorrow> hmm
22:05:28 <Cale> It might have a class restriction, it might not...
22:05:54 <Cale> suppose it's applied to a function of type Integer -> Integer
22:06:41 <Cale> and then the type of that thing is... well, f Integer -> f Integer, but only for Functors f where Integer is in an appropriate class...
22:07:12 <mmorrow> i don't see problem, so i'm thinking i don't have a clear picture of how "the horrible splitting under the covers" would peak out
22:07:23 <mmorrow> *i don't see _the_ ...
22:07:50 <Cale> Well, how do you express the type of  fmap (+1)  in the new system?
22:09:08 <mmorrow> but wouldn't the constraint be on the a's in (Functor f) => f a, not on the functor f itself?
22:09:16 <Cale> right!
22:09:32 <Cale> But fmap (+1) is a polymorphic function.
22:09:39 <Cale> So it should work on different functors
22:09:47 <Cale> But which ones?
22:09:56 <mmorrow> i see.
22:10:20 <mmorrow> ok. so there'd have to be something like:
22:10:25 <Cale> If there's no instance of, say, Monoid for Integer, and I try to use it with my MonoidRing functor, then there's a problem.
22:10:29 <mmorrow> (it'll take me a sec to type this)
22:12:14 <mmorrow> instance Monad (MonoidRing n) | (Monoid a <- MonoidRing n a, ...) where ....
22:12:45 <mmorrow> or some way to indicate constraints on the type vars which you currently can't
22:13:21 <Cale> yeah, there's that, and then that needs to show up in type signatures for polymorphic functions...
22:13:27 <mmorrow> ugh
22:14:44 <Cale> Like  fmap (+1) :: (Num n, Functor f (Integer)) => f Integer -> f Integer
22:14:54 <mmorrow> f = fmap (+1) :: (Monoid a, Monoid b) => MonoidRing n a -> MonoidRing n b
22:15:06 <Cale> Recording the intermediate types at which the functor instance is used.
22:15:11 <Myoma> :t fmap (+1)
22:15:12 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
22:15:12 <mmorrow> yeah
22:15:26 <Cale> (because they might not all show up in the type signature otherwise)
22:16:04 <mmorrow> yeah
22:16:39 <mmorrow> i'm gonna put some thought into this
22:18:34 <Cale> actually, I think this is the closest I've ever come to actually managing something reasonable :)
22:20:05 <mmorrow> definitely, it seems like this way would be perfectly reasonable (pending figuring out some (hopefully) minor details)
22:21:11 <Cale> There is the problem of getting the appropriate instances of monoid to the places that they're needed.
22:21:30 <Cale> There might be module system issues... like usual.
22:21:39 <Cale> Separate compilation is a bitch.
22:21:42 <mmorrow> heh
22:22:45 <Cale> hmm...
22:22:46 <mmorrow> would that be any harder though than getting the instances of monoid to the places they're needed with  instance (Monoid a) => Foo (F a) where ...
22:22:49 <Cale> Maybe not too bad.
22:23:30 <Cale> When you're supplying the dictionary for Functor, you'll also have all the type information for what types it was applied at.
22:23:46 <mmorrow> exactly
22:23:57 <Cale> So you can supply any additional instances of monoid that'll be needed along with that dictionary...
22:45:24 <ajdhs> hi, does anyone here know anything about associated types?
22:49:11 <Twey> ajdhs: I don't know, maybe if you ask your question you'll find out :)
22:49:38 <heatsink> ajdhs, you can read chakravarty's paper http://www.cse.unsw.edu.au/~chak/papers/CKPM05.html
22:49:40 <lambdabot> Title: Research Papers of Manuel Chakravarty
22:51:26 <ajdhs> well essentially I have a class C a where { type P a :: * }
22:52:11 <ajdhs> but in the methods for C, I have some functions that only have arguments of type P a on the lhs (no arguments of type plain a)
22:52:16 <ajdhs> and this is giving me type errors...
22:52:32 <igli> hs has `class'?
22:54:05 <Cale> ajdhs: Which version of GHC?
22:54:13 <ajdhs> 6.9.20080825
22:54:35 <Cale> oh, okay, then they'll probably be interested in anything that you find.
22:54:51 <Cale> (I asked mainly because 6.8 has a broken implementation)
22:55:39 <ajdhs> yeah
22:58:51 <ajdhs> here's the code: http://hpaste.org/10155
22:59:10 <ajdhs> GHC complains that it can't match type P a with type P a1 in the arguments to bar
22:59:34 <ajdhs> it seems like I need to add a type annotation somewhere or maybe a type equality constraint, but I can't figure out where
22:59:51 <dons> anyone know what the 'parallel' package is called on ubuntu?
23:00:48 <ajdhs> because there's only one type involved in the signature of bar
23:01:04 <dons> haskell-parallel i guess
23:01:49 <dancor> is the set of all programs that compile context-sensitive?
23:02:32 <Lycurgus> ghc compile?
23:02:37 <dancor> heh sure
23:02:50 <Myoma> dancor: how could it not be ?
23:03:00 <Myoma> considering variable scope
23:03:26 <dancor> Myoma: i think i see that it is > context-free, and it's <= recursively enumerable
23:03:38 <Lycurgus> context-free stuff is usually useless
23:03:45 <Myoma> yes I think so too dancor
23:03:51 <Lycurgus> except in formal systems studies
23:04:10 <dancor> but i can't tell if it is context-sensitive or not
23:04:17 <Lycurgus> core-algorithm development and the like
23:04:33 <Myoma> dancor: What's your definition of context sensitive
23:04:48 <dancor> Myoma: can be generated by some context-sensitive grammar
23:05:14 <dancor> with rules of the form aAb -> acb etc
23:05:47 <Myoma> may be easier to prove it's not context free
23:08:42 <dons> BeelsebobWork_: erlang parallel binary trees doing ok, same parallelisation model, http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=hipe&id=2
23:08:51 <dons> BeelsebobWork_: ours is missing the parallel lib, i've asked
23:08:54 <lambdabot> Title: binary-trees Erlang HiPE #2 program | x64 Ubuntu : Intel® Q6600® quad-core Com ..., http://tinyurl.com/596q79
23:37:53 <dons> http://www.reddit.com/r/programming/comments/6zyum/wired_a_haskell_library_for_wireaware_hardware/ wired homepage
23:37:55 <lambdabot> Title: Wired: a Haskell library for wire-aware hardware design : programming, http://tinyurl.com/6hmpj5
23:50:32 <Myoma> dancor; I think you can put a^n b^n c^n in teh type system
23:50:41 <Myoma> does that do it?
