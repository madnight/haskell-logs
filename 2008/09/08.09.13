00:00:52 <alexey_r> Is there a multi-pattern lambda in Haskell?
00:00:54 <dmwit> ?hoogle Int -> (a -> m a) -> m a
00:00:55 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
00:00:55 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
00:00:55 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
00:00:59 <dons> alexey_r: only with case
00:01:05 <dons> \x -> case x of ...
00:01:28 <alexey_r> dons: Thanks, that's what I thought.
00:01:34 <dmwit> alexey_r: By the time you get to needing multi-pattern lambdas, you should maybe just name the function.
00:03:20 <dons> there's a discussion about the tradeoffs on the haskell-prime wiki
00:03:37 <ibid> dons, jinjing: feel free to submit per the usual procedure - but the all-chinese posts need to be excluded
00:04:49 <jinjing> guess i'll try implementing feed per tag first
00:08:05 <dons> go jinjing !
00:08:10 <dons> ibid: yeah, i wasn't sure what the policy was.
00:08:25 <dons> btw, the galois blog is still running along, i'm chasing up the terms&conditions.
00:08:36 <dons> it's v. annoying.
00:08:54 <ibid> :)
00:09:06 <dons> since , as you see, the blog is awesome, http://www.galois.com/blog/
00:09:08 <lambdabot> Title: Galois ‚Ä∫ Blog
00:12:07 <electronx> GpuGen very interesting
00:12:12 <electronx> and hyena
00:20:54 <TommyOnMac> morning
00:21:15 <Axman6> o/
00:31:20 * TommyOnMac is in the mood for type less, express more
00:31:45 <Myoma> hello
00:57:42 <goltrpoat> did anyone ever come up with a reasonable notion of inverses for type sum or product?
00:58:04 <dmwit> Well, there's intersection types.
00:58:12 <dmwit> That's like the opposite of a type sum, sort of.
00:58:26 <goltrpoat> well, sort of.
00:58:37 <dmwit> I can't imagine the inverse of a product being difficult.
00:59:17 <dmwit> Just project out the first (or second) element of the tuple.
00:59:17 <goltrpoat> i can try to define a\b = a - (a /\ b), and rather tenuously define complement for elements we already know about.
00:59:35 <goltrpoat> right, but then you end up with n inverses.
00:59:43 <goltrpoat> hence "reasonable"
01:00:17 <dmwit> I guess I don't understand what you're going for.
01:00:52 <goltrpoat> dunno, was wondering how much algebra i can put on the types.
01:03:10 <goltrpoat> i can do all sorts of things to them "forward," as in, products, sums, powers, derivatives, right.  so you'd expect some algebra to pop out.
01:03:59 <goltrpoat> problem is, products and sums actually act like products and sums, so we're not going to be able to rename them, and what the hell is the inverse of a type sum?
01:04:10 <Myoma> goltrpoat: logic
01:04:19 <goltrpoat> pardon?
01:09:51 <goltrpoat> myoma:  (-A) + B is undefined when we have types A and B.  we can ask for (A+B) + (-A), and (A+B) + (-B), and various other trivialities along those lines, but we should at least have a group, dammit.
01:11:32 <Myoma> goltrpoat: you can embed any algebra you like in the logic of type theory
01:12:19 <goltrpoat> myoma:  what, from first principles?
01:12:38 <Myoma> sure, axiomatize it or construct a model
01:12:51 <goltrpoat> yeah but.. fuck that :)  that's entirely useless
01:13:16 <Myoma> I don't think you understood what I said
01:13:33 <TommyOnMac> english, do you speak it?
01:13:35 <TommyOnMac> ;-)
01:13:36 <goltrpoat> ok, i'll pick an algebra.  i pick C.
01:14:17 <goltrpoat> where do we go from here?
01:15:00 <goltrpoat> a very big finite extension over Q once we define our type-level Z?
01:18:10 <dolio> The thing is, there are lots of ways where algebraic operations on types make sense and lead to interesting stuff, but there are probably just as many where there is no reasonable parallel.
01:18:22 <dolio> Or, at least, no one's figured out a good one yet.
01:18:59 <goltrpoat> huh?  of course algebraic operations on types make sense, types are an algebraic construct
01:19:04 <Myoma> dolio, the curry howard guys did a good job though, no?
01:22:39 <dolio> I mean you can (for no particularly obvious reason) make sense of types like (A^N)/N!, but then not make sense of types like A/N!.
01:24:05 <Lord_Illidan> Hi, can anyone point out some good tutorials for dealing with I/O in haskell?
01:24:11 <dolio> There's no good way I've seen of delineating which algebraic operations on types make sense, and which don't.
01:24:30 <Lord_Illidan> I'd like to read a text file, and perform some functions on it, for instance
01:24:37 <dolio> Just a list of ones people have made sense of.
01:28:34 <goltrpoat> dolio:  oh, right.  that's exactly what i was asking.
01:28:53 <goltrpoat> seems like we have a pseudo-division, sort of, but types are not a multiplicative group.
01:31:09 <goltrpoat> but i want an oompa loompa NOW
01:31:10 <goltrpoat> etc.
01:32:27 <dolio> And then you have lists, which are [a] = 1 + a + a^2 + ... = 1/(1 - a) (I think that's right), and you can take the derivative of that to get a sensible correlate for the derivative of [a].
01:33:05 <dolio> But I doubt you can make sense of arbitrary rational expressions of types.
01:33:22 <goltrpoat> exactly!
01:33:29 <goltrpoat> i can exponentiate them, but i can't divide them.
01:33:44 <goltrpoat> drive ya nuts, i tells ya.
01:35:49 <dolio> I think I got that right. It is 1/(1-a), no?
01:36:11 <dolio> Which shows that sometimes you can have -A, without it being applied to A+B or B+A.
01:36:15 <dolio> But not always.
01:37:00 <goltrpoat> not you got that right
01:37:04 <goltrpoat> er, not=no
01:37:11 <goltrpoat> right, sometimes.
01:37:46 <goltrpoat> can't you come up with a different type theory?
01:38:12 <goltrpoat> say we keep the categorical definition, but say that arrows are rng homomorphisms
01:40:15 <goltrpoat> doesn't break TC, does it?
01:41:01 <sereven> Lord_Illidan: try http://book.realworldhaskell.org/read/io.html
01:41:12 <lambdabot> Title: Chapter 7. I/O
01:41:14 <dolio> TC?
01:41:24 <goltrpoat> turing completeness
01:41:32 <goltrpoat> i was afraid i was suggesting coq.
01:42:14 <dolio> So all types would be rings, then?
01:42:40 <goltrpoat> most are, no?
01:42:46 <Lord_Illidan> Thanks sereven, I'll give it a go
01:44:05 <goltrpoat> i mean, we can turn lists into rings, we can do anything right
01:44:06 <goltrpoat> hehe
01:44:56 <dolio> I'm not sure I'm following. A + B is about forming the sum of two types. That doesn't rely on A or B being rings.
01:44:56 <Axman6> dolio: from my lectures last week, i believe it's 1/(1-a) (or 1/(1+a)) for a < 1
01:45:37 <dolio> Which would involve being to compute sums and products of values in A and B. I'm not sure I see how it'd help.
01:46:57 <goltrpoat> well, + turns into direct product, additive inverse can be defined in terms of complement set-wise, etc.
01:47:26 <goltrpoat> i'm sure this is entirely useless, btw, it'd be stupid if i was the first person to think of it.
01:48:06 <dolio> Heh.
02:12:41 <Daniel-Carl> Hello
02:16:18 <Axman6> DanielPet: o/
02:16:42 <DanielPet> Sorry, didnt have a registred nick :P
02:18:39 <Axman6> urgh, ghc 6.6 is so slow >_<
02:19:41 <DanielPet> I have a short list and a long list, is there an easy way to search in the long list with those in the short list?
02:19:54 <cads> I shall try something.
02:20:04 <cads> > let fac =  foldl f  [600851475143] [1..10000] where { f x y = if rem (head x) y == 0 && y /= 1 then (divy (head x) y):(x++[y]) else x; divy x y = if rem x y == 0 then divy (div x y) y else x} in fac
02:20:06 <lambdabot>   [1,6857,10086647,8462696833,600851475143,71,839,1471,6857]
02:20:28 <cads> hooray
02:20:41 <Axman6> cads: project euler?
02:20:47 <cads> I'm having a trouble with this
02:20:48 <cads> yes
02:21:26 <cads> I think that gives me the answer. However, in the file version of the program I have a problem: http://hpaste.org/10341
02:21:43 <cads> I must be organizing the file wrong
02:22:16 <cads> do you guys have an idea?
02:23:06 <dolio> cads: Your ghci stuff will default to Integer.
02:23:18 <dolio> euler_three is specified as Int, so it's overflowing.
02:23:28 <cads> ooooh!
02:23:39 <cads> thanks :)
02:24:33 <cads> that works, thanks for the observation, dolio
02:30:56 <Axman6> :t find
02:30:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
02:32:04 <Axman6> :t flip
02:32:06 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:32:26 <Axman6> :t flip find
02:32:27 <lambdabot> forall a. [a] -> (a -> Bool) -> Maybe a
02:32:54 <Axman6> :t flip find [1,2,3]
02:32:55 <lambdabot> forall a. (Num a) => (a -> Bool) -> Maybe a
02:33:36 <Axman6> DanielPet: findAll items list = map (\n -> find (==n) list) items
02:33:47 <Axman6> > let findAll items list = map (\n -> find (==n) list) items
02:33:48 <lambdabot>   mueval: Prelude.read: no parse
02:33:55 <Axman6> hmm
02:34:24 <Axman6> > let findAll items = map (\n -> find (==n) list)
02:34:25 <lambdabot>   mueval: Prelude.read: no parse
02:34:34 <Axman6> hmm
02:35:01 <Axman6> oh, whoops
02:35:09 <Axman6> @hoogle find
02:35:09 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
02:35:09 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:35:09 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
02:36:19 <Axman6> ok, 'findAll items list = map (\n -> find (==n) list) items' does work
02:37:04 <DanielPet> thanks, I will check it out!
02:38:00 <Axman6> need to import Data.List
02:58:02 <noZone> @hoogle find
02:58:02 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
02:58:02 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
02:58:02 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:00:44 <Axman6> @src Data.Foldable.find
03:00:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:00:56 <mc__> Is there a haskell convention for naming functions that return a boolean value? like "something-p" in Lisp
03:01:19 <Axman6> isSomething?
03:01:24 <Axman6> not afaik
03:01:43 <mc__> okay, just wanted to make sure
03:02:46 <Axman6> i'm no expert though
03:04:57 * papermachine uses something-p out of lispishness.
03:06:33 <Myoma> mc__: No there is not
03:06:41 <Myoma> :t null
03:06:42 <lambdabot> forall a. [a] -> Bool
03:09:29 <LeoD> :t forall
03:09:30 <lambdabot> Not in scope: `forall'
03:19:36 <dancor> can i silence one thread from writing to stdout
03:19:56 <dancor> or are fd's per process
03:20:20 <ulfdoz_> per process.
03:34:05 <sheyll> hi
03:34:24 <Myoma> hi sheyll
03:34:57 <sheyll> wtf does that mean: data init :& last = !init :& !last
03:35:19 <sheyll> source: http://www.informatik.tu-cottbus.de/~jeltsch/research/uustc-20080529-slides.pdf
03:35:22 <lambdabot> Title: cache:http://www.informatik.tu-cottbus.de/~jeltsch/research/uustc-20080529-slide ..., http://tinyurl.com/5x4veb
03:35:45 <Myoma> data And init last = And !init !last
03:36:39 <sheyll> Myoma: I see, so it is allowed to defined your own operator as Datatype/Constructor?
03:36:56 <Myoma> yes
03:37:53 <sheyll> I love it.
03:38:45 <Myoma> isn't GHC 6.10 out?
03:39:34 <chrisdone> any pages about defining data types with inheritance?
03:40:48 <dolio> If 6.10 is out, I missed the announcement.
03:41:02 <goltrpoat> myoma:  i heard "two weeks" earlier this week.
03:41:19 <Axman6> is it supposed to be out soon?
03:41:32 <sheyll> chrisdone: the second search result on google for exactly your question: http://www.haskell.org/haskellwiki/OOP_vs_type_classes
03:41:34 <lambdabot> Title: OOP vs type classes - HaskellWiki
03:42:03 <sheyll> chrisdone: sounds like this can be of interest?
03:42:47 <sheyll> chrisdone: I have read it, it is a nice read.
03:43:03 <Myoma> Is this number http://darcs.haskell.org/ghc/compiler/ghc.cabal
03:43:10 <Myoma> always the latest version of ghc?
03:44:32 <goltrpoat> yes.
03:44:41 <chrisdone> sheyll: I'm reading it anyway
03:44:52 <goltrpoat> and now you've killed #math with your not-math crap.  look what you've done!
03:47:50 <goltrpoat> it's somewhat amazing the amount of beer one can drink and still be relatively coherent.
03:48:42 <dolio> Takes training.
03:50:18 <sheyll> I would like to understand ArrowLoop. How would I create something like a simple counter?
03:50:25 <goltrpoat> ooh ooh.  it would appear that hilbert's basis theorem and the ascending chain condition would apply here
03:50:31 <goltrpoat> IS THAT MATH ENOUGH FOR YOU
03:50:37 <goltrpoat> i'm ok now.
03:51:36 <chrisdone> coherence is not necessarily relevance
03:51:43 <goltrpoat> well
03:51:56 <goltrpoat> technically, it's relevant, because both HBT and ACC do apply here.
03:52:24 <goltrpoat> whether or not that makes me an ideal in a polynomial ring with beer as exponentiation, who knows.
03:55:28 <goltrpoat> it is, however, vaguely amusing how CS people stop talking at the first sign of algebra, whereas algebra people start screaming at the first sign of CS.
03:56:03 <goltrpoat> (relevant things usually, no offense to any algebra people in the audience)
04:10:13 <chrisdone> @pl f x x
04:10:13 <lambdabot> f x x
04:10:26 <chrisdone> @pl (\x -> f x x)
04:10:27 <lambdabot> join f
04:11:33 <Cale> goltrpoat: Well, there are certain parts of CS which are extremely algebraic... formal language theory is almost indistinguishable from a refined theory of monoids.
04:11:37 <dolio> > loop (\(a,l) -> (l, a:l)) 5
04:11:38 <lambdabot>   mueval: Prelude.read: no parse
04:11:46 <goltrpoat> i kid, i kid.
04:12:46 <dolio> > id &&& id
04:12:47 <lambdabot>       Overlapping instances for Show (a -> (a, a))
04:12:47 <lambdabot>        arising from a use ...
04:12:54 <dolio> > loop
04:12:55 <lambdabot>       Overlapping instances for Show (a (b, d) (c, d) -> a b c)
04:12:55 <lambdabot>        arisin...
04:13:19 <dolio> > loop (\(a,l) -> (l, a:l)) 5 :: [Int]
04:13:20 <lambdabot>   mueval: Prelude.read: no parse
04:13:48 <dolio> Hmm...
04:14:38 <dcoutts> @seen CosmicRay
04:14:38 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 6h 30m 37s ago, and .
04:15:06 <im_alone> @google watkins
04:15:08 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
04:15:29 <im_alone> @google watkins markov
04:15:32 <dcoutts> @tell CosmicRay I'd send you a patch to drop the twidge dep on Cabal (it's an internal api that it probably should not be using) but I can't find the darcs repo
04:15:32 <dolio> @type loop (\(a,l) -> (l, a:l)) 5
04:15:33 <lambdabot> http://citeseer.ist.psu.edu/littman94markov.html
04:15:33 <lambdabot> Consider it noted.
04:15:34 <lambdabot> forall b. (Num b) => [b]
04:24:36 <dancor> under what conditions would x not happen in     forkIO (w >> x >> y) >> z
04:24:53 <dancor> w and z happen when i run my program, but x and y never do
04:25:10 <dancor> x is playing a sound file with run "timidity"..
04:25:14 <dolio> w throws an exception?
04:25:24 <dancor> w = print "hm"
04:26:19 <dolio> Then x does, before doing what you expect it to do?
04:26:40 <dolio> Or instead of.
04:27:52 <vegai> what would be the preferred way these days to access an sqlite db?
04:28:12 <vegai> no need for database abstraction, just for sqlite
04:28:59 <vegai> dons's haskell-sqlite, perhaps.
04:29:01 * vegai checks it out
04:29:14 <chrisdone> hdbc can do it
04:29:52 <Cale> Perhaps x takes forever?
04:30:02 <chrisdone> I had problems with it randomly locking specific table rows, though
04:30:24 <Baughn> I've had trouble with hdbc apparently having no way to run queries /outside/ transactions
04:30:45 <Baughn> That is to say, queries that would alter the sqlite db - it won't accept them inside a transaction
04:30:52 <dancor> dolio, Cale: it's the FIXME comment in http://dzl.no-ip.org:81/gitweb/?p=mull.git;a=blob;f=src/Ask.hs
04:31:17 <dancor> as run from   intvl   in http://dzl.no-ip.org:81/gitweb/?p=mull.git;a=blob;f=src/Mus.hs
04:31:25 <dancor> i guess haskore is probably doing something terrible?
04:31:45 <dancor> x is just debug printing "hm" so it should be finite
04:32:54 <Myoma> I think I figured out a kind of nice proof for pigeohole :)
04:33:10 <Cale> Myoma: Which pigeonhole?
04:33:52 <Myoma> having a list of n different elements all below n is impossible
04:34:05 <Myoma> (below n being {0,1,2,...,n-1})
04:34:14 <Cale> okay.
04:34:28 <Botje> uh?
04:34:35 <dolio> > length [0..n-1]
04:34:36 <Botje> 3 different elements below 3: {0,1,2}
04:34:36 <lambdabot>   mueval: Prelude.read: no parse
04:34:36 <lambdabot>  mueval: *** Exception: not a number
04:34:38 <Saizan> dancor: are you compiling? if so, are you using -threaded?
04:34:44 <dolio> > length [0..6-1]
04:34:46 <lambdabot>   6
04:35:00 <Myoma> oh sorry yes that was a silly blunder
04:35:05 <Myoma> having a list of _n+1_ different elements all below n is impossible
04:35:08 <dancor> Saizan: i'm compiling but not using -threaded.  should i be..
04:35:12 <Myoma> that's what I have written down
04:35:18 <Botje> yes!
04:35:24 <Botje> myoma++ :)
04:35:44 <Cale> That seems like its proof is fairly dependent on what assumptions you're allowed to make :)
04:35:46 <Saizan> dancor: i'd try it, since maybe haskore is using a bounded thread
04:36:04 <Myoma> I make no assumptions
04:36:12 <Cale> You must.
04:36:22 <Cale> (or you can't prove anything)
04:38:30 <dancor> Saizan: that worked!
04:39:23 <Myoma> I want to make a .swf animation of the proof :/
04:39:28 <Myoma> or something like that
04:39:30 <Saizan> dancor: cool :)
04:43:08 <nominolo_> :t \r x -> liftM (readIORef r) x
04:43:09 <lambdabot> Not in scope: `readIORef'
04:44:16 <dancor> tho i can't get cabal to build it that way, despite adding   ghc-options:    -threaded
04:48:39 <Myoma> found this http://www.cs.utexas.edu/users/EWD/transcriptions/EWD09xx/EWD980.html
04:48:42 <lambdabot> Title: E.W. Dijkstra Archive: The strange case of The Pigeon-hole Principle (EWD 980), http://tinyurl.com/4wr29n
04:50:32 <chrisdone> how can I tell haddock how to link to ghc's documentation pages for standard types like String and so forth?
04:51:30 <dancor> ah, ghc-options has to be in the executable: stanza
04:51:31 <dancor> sneaky..
04:53:59 <mc__> is there a library function which counts occurences of a item in a list?
04:54:01 <chrisdone> ‚ÄúWarning: main:JbovlasteDB: could not find link destinations for: GHC.Base.String‚Äù -- how does one help it find the link destinations?
04:55:39 <chrisdone> > let count v = length . filter (==v) in count 1 [1,2,4,2,1,5,1,4]
04:55:41 <lambdabot>   3
04:56:00 <chrisdone> I don't see one in Data.List
04:56:54 <mc__> alright
04:57:12 <hackage> Uploaded to hackage: ansi-terminal 0.5.0
04:57:12 <hackage> Uploaded to hackage: twidge 0.99.0.1
04:57:12 <hackage> Uploaded to hackage: twidge 0.99.0
04:57:13 <hackage> Uploaded to hackage: data-accessor-template 0.1.4
04:57:15 <hackage> Uploaded to hackage: data-accessor 0.1.4
04:57:25 * Cale wonders what twidge is.
04:57:53 <Heffalump> it's a twitter interface, IIRC
04:58:00 <dcoutts> yep
04:58:03 <Cale> ah
04:58:33 <papermachine> ooh, cool
04:58:36 <Heffalump> yay, data-accessor's licence changed
04:58:37 <papermachine> :3
04:58:48 <Cale> So I can flood my friends with lots of debugging information about what's going on in my Haskell programs.
04:58:53 <Cale> :)
04:58:58 <papermachine> Cale: I'd subscribe to that :D
05:00:50 <xpika> what is the code to convert [Char] to a ByteString?
05:01:04 <ivanm> does mueval have support for Control.Arrow?
05:01:08 <Heffalump> xpika: pack
05:04:45 <chrisdone> ivanm: I don't think so
05:04:49 <ivanm> :(
05:04:56 <chrisdone> ivanm: Œªb doesn't last time I checked
05:05:04 <chrisdone> > id &&& id $ 1
05:05:05 <Myoma> is Haskell' getting a new prelude?
05:05:06 <lambdabot>   mueval: Prelude.read: no parse
05:05:09 <ivanm> :o I thought the hs-plugins version did :s
05:05:31 <ivanm> dammit, I just worked out that the functions I just spent a while writing are absolute useless because I'd have to make them that generic that they'd become absolutely useless :s
05:05:52 <olsner> hmm, does one invocation of 'newline' in parsec also handle a "\r\n" sequence as a single newline?
05:05:54 <Myoma> ivanm: what ? o_o
05:06:40 <ivanm> Myoma: I had some code that was relabelling the nodes and edges in an FGL graph... so I thought I'd abstract it out to seperate generic updateNodes and updateEdges functions
05:07:00 <xpika> Heffalump:  Couldn't match expected type `Word8' against inferred type `Char'
05:07:18 <ivanm> except that updateEdges was pretty fugly, and to get it to do what I actually needed it to do would make it even more atrociously fugly :s
05:07:19 <chrisdone> xpika: import the char8 bytestring module
05:07:31 <olsner> or should I handle that by e.g. scrubbing the input before parsing or adding my own newline parser?
05:07:34 <Cale> ivanm: I'm waiting for a new release of mueval which fixes a lot of things.
05:07:35 <Toxaris_> xpika: try Data.ByteString.Char8 or [Word8] instead of String
05:07:41 <ivanm> Cale: *nod*
05:07:52 <Cale> ivanm: Apparently a lot of things are fixed in the new mueval, but gwern hasn't done a release.
05:07:55 * ivanm stares pointedly at gwern, who isn't actually here atm but anyway...
05:07:58 <ivanm> ;-)
05:08:06 <chrisdone> @seen gwern
05:08:06 <lambdabot> I saw gwern leaving #darcs, #xmonad and #haskell 2d 17h 49m 35s ago, and .
05:08:12 <ivanm> Cale: what's with gwern releasing 4 versions at once anyway?
05:08:13 <olsner> otoh, windows users be screwed someone who gets itched by it may fix that later at their leisure :P
05:08:18 <Cale> ivanm: I have no idea.
05:10:38 <Toxaris_> olsner: newline = char '\n', so it depends on the way the input is read, I guess
05:12:31 <xpika> in that case it would be better to convert the string to word8 because that's what Data.Binary likes
05:14:09 <olsner> my parsec parsers for line-based formats always get so ugly
05:14:53 <xpika> olsner: where does it get ugly?
05:16:54 <jinjing> is there a way to convert "utf-8 names" string to "utf-8" strings?
05:17:15 <olsner> things like leading and trailing whitspace, handling comments, parsing the newlines in the right place etc
05:17:40 <paczesiowa> olsner: why not use Config-File from hackage?
05:18:45 <sheyll> what do would a function most likelz do, if it was called repmin?
05:19:02 <olsner> hmm, in one case a while ago, that module would've replaced my parsing needs entirely... but now I'm parsing makefiles
05:21:46 <xpika> olsner: cant you write a function that does whitespace tok = skipMany (char ' ') >> tok >> skipMany (char ' ')
05:22:25 <DanielPet> Can someone help me? My depthFirst function doesn't loop! http://hpaste.org/10344?lines=true
05:23:16 <olsner> hmm, yeah, but I don't think that's very useful in a lot of places... 'tokens' isn't the best match for the file format I think
05:25:57 <DanielPet> I want it to expand to the depth 24
05:26:49 <DanielPet> but it gives me this:
05:26:51 <DanielPet> *Main> depthFirst [(0,0)] 0 []
05:26:53 <DanielPet> [(1.0,1.0),(1.0,0.0),(0.0,0.0)]
05:27:53 <Axman6> :t maybe
05:27:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:28:05 <olsner> and there are more kinds of whitespace than ' ', but in this case less than isSpace thinks, since newlines are whitespace according to that function while they have semantic significance in makefiels
05:30:11 <Baughn> For that matter, tabs have semantic significance too. So what whitespace is left?
05:31:28 <Axman6> @src (>>)
05:31:28 <lambdabot> m >> k      = m >>= \_ -> k
05:31:29 <Heffalump> why do both Control.OldException and GHC.Conc have an "uncaughtExceptionHandler" definition? I can't find any calls to the Control.OldException one.
05:31:38 <Axman6> @src (>>=)
05:31:38 <lambdabot> Source not found. stty: unknown mode: doofus
05:31:51 <Axman6> hmm, what's the point of (>>)?
05:32:02 <Baughn> Convenience
05:32:11 <Axman6> what does it do exactly?
05:32:12 <mc__> rofl http://www.haskellcounty.org/
05:32:12 <lambdabot> Title: The Official Haskell County Web Site
05:32:25 <Baughn> @undo do foo; bar
05:32:25 <lambdabot> foo >> bar
05:32:54 <Axman6> and... what's that do? :\
05:33:13 <Baughn> Er. Constructs an action that, when executed, first executes foo, then executes bar.
05:33:41 <Axman6> fair enough. and what sort of things would foo and bar be?
05:33:45 <Axman6> IO actions?
05:33:48 <Baughn> Actions.
05:34:04 <Baughn> IO actions, possibly, if you're in the IO monad. There are other monads.
05:34:22 <Axman6> got a good example?
05:34:38 <Baughn> > do foo <- [1..4]; bar <- [1..5]; return (foo,bar)
05:34:39 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
05:34:56 <Baughn> Mind you, I'm not so sure "action" is the right word for this
05:35:02 <Baughn> Just.. go read some more monad tutorials. ^_^
05:35:11 <Axman6> bah, i have -_-
05:35:19 <Axman6> they still confuse me
05:35:36 <Baughn> Anyhow. foo >> bar executes foo, throws away the result (leaving only the side-effects), then executes bar
05:35:49 <Baughn> foo >>= bar would execute foo, then hand the result as the first argument to bar
05:36:06 <olsner> > filter isSpace ['\0'..]
05:36:07 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
05:36:10 <Baughn> foo >>= \x -> bar, of course, is handy for /naming/ bar's result
05:36:18 <Baughn> @undo do x <- foo; bar x
05:36:18 <lambdabot> foo >>= \ x -> bar x
05:37:16 <Axman6> so something like putStr str >> something ?
05:37:25 <sheyll> :t isJust
05:37:26 <lambdabot> forall a. Maybe a -> Bool
05:37:49 <Baughn> Axman6: Given that putStr always just returns (), it's kinda pointless to keep its return value
05:38:01 <Baughn> Thus, >> is convenient. Much simpler than typing >>= \_
05:38:03 <Myoma> @src isJust
05:38:03 <lambdabot> isJust Nothing = False
05:38:03 <lambdabot> isJust _       = True
05:38:21 <sheyll> :t find
05:38:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
05:38:29 <Myoma> isJust x = if(x.constructor == Nothing) then return False ..............
05:38:48 <olsner> I'm always ambivalent about \x -> bar x instead of bar ... any time I see it in code I wonder whether I should dislike it for its redundancy or like it for documenting what x is (if 'x' is replaced with a descriptive variable name, that is)
05:39:02 <sheyll> x.constructor what does that mean?
05:39:32 <Myoma> sheyll: sorry, I was just complaining
05:39:57 <sheyll> @src find
05:39:57 <lambdabot> find p          = listToMaybe . filter p
05:40:18 <sheyll> @src listToMaybe
05:40:18 <lambdabot> listToMaybe []        =  Nothing
05:40:19 <lambdabot> listToMaybe (a:_)     =  Just a
05:45:09 <sheyll> DanielPet: I cannot really figure out what 1. previous in line 18 is supposed to mean
05:46:10 <sheyll> DanielPet: and 2. what does dirty mean?
05:46:45 <DanielPet> It returns the nodes which haven't been visited before and is within a matrix.
05:47:05 <DanielPet> DirtyNodes is the nodes which has been visited
05:47:19 <DanielPet> not been visited.
05:47:21 <Myoma> @gut-shapr
05:47:21 <lambdabot> shapr!!
05:48:29 <sheyll> so getAllFringes like draws the corners of a 3x3 square around leaving a "plus" untouched?
05:48:58 <sheyll> no just the center ...
05:49:21 <sheyll> still line 18 looks strange
05:50:45 * TommyOnMac falls off his chair, yhcjs demos lol and wow
05:50:54 <DanielPet> All functions has been checked except depthFirst. I dont know if I need strict evaluation or something
05:51:08 <Myoma> DanielPet: Why would you need that? :)
05:52:05 <DanielPet> It's an AI assignment, a broken vaccum cleaner that can only go in the direction of an L.
05:52:14 <sheyll> :t null
05:52:15 <lambdabot> forall a. [a] -> Bool
05:52:30 <Axman6> DanielPet: you almost vertainly don't need strict evaluation
05:52:41 <DanielPet> ok
05:52:52 <Axman6> c*
05:53:22 <Axman6> i've only seen one good use for it so far, and that was to abey the rules of the language shootout
05:54:39 <DanielPet> We are forced to use breath first
05:55:00 <Axman6> well figure out a way of doing that lazily ;)
05:55:03 <Myoma> DanielPet: what are you depth first searching?
05:55:24 <DanielPet> Sorry, depth first :P
05:55:28 <Cale> Strict evaluation can be important. The points at which it is important is when a large structure (with many separately-evaluatable parts) is being collapsed down to a small one (with few separately-evaluatable parts) whose value is smaller than its description.
05:55:59 <olsner> @pl flip id
05:56:00 <lambdabot> flip id
05:56:11 <paczesiowa> $
05:56:15 <Cale> For example, summing a list of integers, generally the sum will be smaller than the expression for it.
05:56:20 <Axman6> Cale: i guess seq would be using strict evaluation wouldn't it
05:56:24 <Cale> yes
05:56:36 <xpika> is there any major functional difference between a bytestring and a lazy bytestrng
05:56:38 <Axman6> i was just thinking about using !. m'bad
05:56:50 <olsner> paczesiowa: well, no, flip ($) seems to be the closest thing, but that's longer :P
05:56:57 <olsner> maybe Ä otoh
05:57:06 <Myoma> :t flip id
05:57:07 <lambdabot> forall b c. b -> (b -> c) -> c
05:57:16 <Cale> xpika: Lazy bytestrings can be infinite?
05:57:49 <Cale> xpika: Also, the complexity of many operations is different.
05:58:05 <paczesiowa> olsner: flipped $ looks the same:>
05:58:18 <sheyll> :t ((12 * 12)-1)/2)
05:58:20 <lambdabot> parse error on input `)'
06:00:18 <Axman6> :t (/)
06:00:19 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:12:13 <plutonas> does do 1 do 2 3 make sense?
06:12:42 <plutonas> i mean what would be the difference to do 1 2 3
06:14:33 <dcoutts> plutonas: I presume you mean for 1,2,3 there to stand for some other expressions
06:14:34 <EvilTerran> you mean (do foo; bar; baz) vs do (foo; (do bar; baz)) ?
06:14:40 <EvilTerran> they're the same
06:14:56 <plutonas> dcoutts: yes
06:15:20 <EvilTerran> (do foo; ...)  -->  foo >> (do ...)
06:15:22 <plutonas> EvilTerran: hm, ok, strange, because i found the second form written in a "book"
06:15:38 <EvilTerran> (do foo; bar; baz)  -->  foo >> (do bar; baz)
06:15:43 <dcoutts> and should be the same as do {do {foo; bar}; baz} by the monad laws
06:15:51 <plutonas> if you have, "two dozen short lessons in haskell" it's on page 119
06:15:55 <plutonas> and was wondering...
06:16:00 <EvilTerran> (do foo; (do bar; baz))  -->  foo >> do (do bar; baz)
06:21:36 <sheyll> DanielPet: I think I found your problem :)
06:22:27 <sheyll> ahh he has left to do his homework himself?
06:22:45 <Myoma> hehe
06:25:54 <ivanm> I know that I can use "fromMaybe (show x) $ cast x" to write a "show" function that acts as id on strings... is there one that acts as :[] for chars as well?
06:26:18 <Myoma> :t cast
06:26:19 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
06:26:26 <Myoma> :t \x -> fromMaybe (show x) $ cast x
06:26:27 <lambdabot> forall a. (Typeable a, Show a) => a -> String
06:26:27 <ivanm> i.e. show' "abc" = "abc", show' 'd' = "d", show' 2 = "2"
06:26:48 <EvilTerran> ?type \x -> fromMaybe (show x) (return.cast x)
06:26:49 <lambdabot>     Couldn't match expected type `a -> b'
06:26:49 <lambdabot>            against inferred type `Maybe b1'
06:26:49 <lambdabot>     In the second argument of `(.)', namely `cast x'
06:26:56 <ziman> :t fromMaybe
06:26:58 <lambdabot> forall a. a -> Maybe a -> a
06:26:58 <Myoma> > (\x -> fromMaybe (show x) $ cast x) "foo"
06:26:58 <EvilTerran> ?type \x -> fromMaybe (show x) (return <=< cast x)
06:27:01 <lambdabot>     Couldn't match expected type `a -> m b'
06:27:01 <lambdabot>            against inferred type `Maybe b1'
06:27:01 <lambdabot>     In the second argument of `(<=<)', namely `cast x'
06:27:01 <lambdabot>   "foo"
06:27:04 <Myoma> > (\x -> fromMaybe (show x) $ cast x) 34
06:27:06 <lambdabot>   "34"
06:27:09 <Myoma> > (\x -> fromMaybe (show x) $ cast x) 'x'
06:27:11 <lambdabot>   "'x'"
06:27:20 <EvilTerran> ?type \x -> fromMaybe (show x) ((:[]) <$> cast x)
06:27:21 <lambdabot> forall a. (Typeable a, Show a) => a -> String
06:27:23 <ivanm> ?type \x -> fromMaybe (show x) (fmap return.cast x)
06:27:25 <lambdabot>     Couldn't match expected type `a -> f a1'
06:27:25 <lambdabot>            against inferred type `Maybe b'
06:27:25 <lambdabot>     In the second argument of `(.)', namely `cast x'
06:27:42 <EvilTerran> > let f x = fromMaybe (show x) ((:[]) <$> cast x) in (f "123", f 'a', f 12)
06:27:44 <lambdabot>   ("\"123\"","a","12")
06:27:47 <Myoma> ivanm: Why don't you scap all the dynamic stuff and define a typeclass?
06:27:48 <EvilTerran> ta-dah
06:27:53 <EvilTerran> ivanm, there ye go
06:28:02 <ivanm> yeah, well... ;-)
06:28:13 <ivanm> when I brought that up once, sjanssen told me to use the dynamic approach :p
06:28:52 <ivanm> what, have class MyShow a where show' :: a -> String; with instances for String and Char?
06:29:03 <EvilTerran> note it's the sort of thing that's only pleasant at all in a language with type inference
06:29:08 <Myoma> I wouldn't call it show'
06:29:09 <EvilTerran> even though you're using dynamic types
06:29:26 <ivanm> wouldn't then having "instance (Show a) => MyShow a where show' = show" cause an overlap for String and Char?
06:29:33 <ivanm> Myoma: whatever I call it
06:29:37 <EvilTerran> and an undecidable
06:29:40 <ivanm> toString() maybe :p
06:29:42 <paczesiowa> -fallow-overlapping-instances
06:29:46 <ivanm> paczesiowa: *nod*
06:29:48 <olsner> is there no (<<) operator for monads?
06:29:52 <EvilTerran> -XOverlappingInstances, please
06:30:02 <EvilTerran> as i said, you'll need -XUndecidableInstances for that one, too
06:30:06 <ivanm> well, I was just going to do it as a LANGUAGE pragma anyway...
06:30:10 <Myoma> :t (<<)
06:30:11 <lambdabot> Not in scope: `<<'
06:30:18 <EvilTerran> olsner, it would appear not
06:30:30 <ivanm> EvilTerran: to define it for _|_?
06:30:51 <Myoma> ivanm: so don't write a Show a => MyShow a instance
06:30:55 <EvilTerran> "instance Show a => MyShow a" is undecidable
06:31:01 <EvilTerran> as well as overlapping all other instances
06:31:01 <ivanm> ahhhh
06:31:11 <ivanm> so is there any other way of doing it?
06:31:28 <EvilTerran> reinvent typeclasses <.<  >.>
06:31:38 <ivanm> heh
06:31:41 <Myoma> ivanm: Well you could scrap all the typeclass stuff and use Data.Dynamic ...
06:31:49 <EvilTerran> "this is hard to express in this type system. i'm going to make my own type system instead!"
06:31:50 <ivanm> if I want to use that class, would it be sufficient to just use (Show a) => or would I have to use MyShow
06:32:13 <ivanm> @remember EvilTerran this is hard to express in this type system. i'm going to make my own type system instead!
06:32:13 <lambdabot> Done.
06:35:25 <ivanm> EvilTerran: well, I sometimes think it'd be handy to have a way of having "if x is of type Foo do this, otherwise do that" without having to wrap a typeclass around it :s
06:36:45 <paczesiowa> that's easy I think
06:37:04 <paczesiowa> harder is if Foo is in class Bar than do this otherwise do that
06:37:46 <ivanm> paczesiowa: oh? how? using the Data.Dynamic stuff?
06:37:55 <paczesiowa> and making it have type a (because it does work for all types)
06:38:22 <paczesiowa> ivanm: now, with typeclass. what's wrong with using typeclasses?
06:38:43 <paczesiowa> it's still O(n) code
06:38:57 <ivanm> because it's annoying having to create a new typeclass just for one function,  and ensuring it works with all possible types?
06:39:45 <paczesiowa> annoying isn't that bad... much better than impossible or "I don't know how"
06:40:07 <ivanm> hmmm.... looks like those two extensions are either wrong or not all I need...
06:40:35 <ivanm> it wants TypeSynonymInstances (cos String=[Char] ?) and FlexibleInstances for the generic Show a => case
06:41:10 <paczesiowa> ivanm: what's the problem?
06:41:34 <ivanm> you say that MyShow class I was defining above?
06:41:59 <ivanm> Myoma: and EvilTerran said I'd need OverlappingInstances and UndecidableInstances, but ghc wanted more ;-)
06:42:48 <paczesiowa> ghc wants - ghc gets:>
06:43:38 <ivanm> dammit, and I can't just use (Show a) =>, I have to use (MyShow a) => which is more fiddly :s
06:44:29 <EvilTerran> ivanm, you'd need FlexibleInstances too, thinking about it
06:44:42 <paczesiowa> all this because you don't like doublequotes on shown strings?
06:45:00 <ivanm> EvilTerran: since I haven't written much code that uses extensions before... ;-)
06:45:04 <ivanm> paczesiowa: yah
06:45:14 <ivanm> s/don't like/don't want/
06:45:55 <Saizan> you could just convert to string (or id) earlier
06:45:56 <EvilTerran> because a h98 instance has to be "instance ((Class var+,)*(Class var+))? => Class var+
06:46:10 <EvilTerran> er, that last one should be Class (Type var+)
06:46:17 <ivanm> Saizan: but then I'd have to know that I _need_ to convert to String earlier!
06:46:24 <EvilTerran> (or var*, even)
06:46:30 <paczesiowa> ivanm: how about crusade for changing Show instance for String?
06:46:39 <EvilTerran> that'll never fly
06:46:43 <ivanm> nah, I can see where it _would_ be useful
06:46:47 <EvilTerran> it's not in keeping with the definition of Show
06:46:55 <ivanm> that read . show = id?
06:47:07 <EvilTerran> there is that, yes
06:47:43 <EvilTerran> also, derived instances at least produce valid haskell, so i get the impression hand-written instances are meant to too
06:47:54 <Saizan> EvilTerran: from your RE it looks like MPTCs are h98 :)
06:48:30 <EvilTerran> Saizan, i corrected it after that
06:48:37 <EvilTerran> <EvilTerran> er, that last one should be Class (Type var+) <EvilTerran> (or var*, even)
06:48:49 <EvilTerran> so "instance ((Class var+,)*(Class var+))? => Class (Type var*)"
06:49:21 <Saizan> i mean in the contexts, var+ means one or more vars, no?
06:49:25 <ivanm> gah, even if I use the Typeable route I'd have to specify Typeable everywhere! :s
06:49:48 <Saizan> however it's not important..
06:50:13 <EvilTerran> Saizan, ah, yes, good point
06:50:20 <EvilTerran> s/var\+/var/g
06:50:23 <EvilTerran> :P
06:57:14 <hackage> Uploaded to hackage: twidge 0.99.1
06:57:14 <hackage> Uploaded to hackage: ansi-terminal 0.5.0
06:57:14 <hackage> Uploaded to hackage: twidge 0.99.0.1
06:57:15 <hackage> Uploaded to hackage: twidge 0.99.0
06:57:17 <hackage> Uploaded to hackage: data-accessor-template 0.1.4
06:58:27 <ivanm> OK, how can I specify a class where I want a function to output an instance Ord, but I don't care what type it is?
06:59:07 <ivanm> i.e. class Foo a where foo :: (Ord b) => a -> b; instance Foo Int where foo = id
06:59:18 <ivanm> s/i.e./e.g./
06:59:29 <tristes_tigres> Hi
07:00:51 <CosmicRay> any haxml users here?  I'm trying to figure out how to make it deal properly with what is (presumably) unicode, like this: <text>@vyazovoi &#1085;&#1091;, &#1103; </text>
07:00:52 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
07:01:05 <CosmicRay> I'm not sure exactly what it is supposed to do there, but I'm pretty sure whatever it's doing isn't right
07:01:37 <CosmicRay> dcoutts: twidge is using git
07:02:05 <dcoutts> CosmicRay: ah, that'll explain why I couldn't find it :-)
07:02:16 <CosmicRay> dcoutts: git://git.complete.org/twidge ;-)
07:02:45 <dcoutts> CosmicRay: so I'd suggest just copying out that function, it's not ideal to depend on the Cabal lib for those kinds of util functions, they're primarily internal
07:02:58 <CosmicRay> dcoutts: that patch would be welcome.  don stewart reported that he got a compilation error.  I happen to know that he runs cabal 1.4, while I have 1.2.  and I suspect that's what the problem is
07:03:12 <CosmicRay> dcoutts: ok.  I can do that.
07:03:22 <dcoutts> CosmicRay: I doubt that's related actually
07:03:26 <CosmicRay> oh
07:03:36 <Saizan> ivanm: you've to use an existential type
07:03:40 <CosmicRay> well he got a type error in Ls.hs right where there's the call to wrapText
07:04:03 <ivanm> Saizan: come again?
07:04:17 <dcoutts> CosmicRay: oh, actually it is that. The impl and type changed between 1.2 and 1.4
07:04:27 <Saizan> ?google wikibook haskell existential type
07:04:30 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:04:33 <dcoutts> CosmicRay: another reason to just grab the code :-)
07:04:48 <CosmicRay> dcoutts: should I grab the 1.2 version or the 1.4 version?  was 1.2 buggy in some way?
07:05:10 <dcoutts> CosmicRay: the 1.4 version is obviously better, it's got a bigger number :-)
07:05:31 <CosmicRay> dcoutts: pardon me :-)
07:05:44 <dcoutts> CosmicRay: not much difference really, just factored differently
07:06:32 <ivanm> Saizan: ahhh... so would I do forall on the class declaration?
07:07:37 <ivanm> nope, that didn't work... ghc thre a parse error on forall :s
07:08:28 <tristes_tigres> ivanm: perhaps you should supply option to GHC permitting haskell txtensions
07:08:47 <ivanm> nah, worked it out... put it on the foo function instead
07:08:57 <ivanm> I _was_ enabling the extensions ;-)
07:09:42 <shapr> yarr!
07:10:38 <CosmicRay> shapr!
07:10:43 <dcoutts> @yarr!
07:10:44 <lambdabot> Aye
07:10:46 <shapr> CosmicRay!
07:10:53 * shapr boings cheerfully
07:11:00 <CosmicRay> shapr: I keep running into you... everywhere but here.
07:11:01 * shapr tries Twidge
07:11:04 <CosmicRay> yay
07:11:07 <CosmicRay> did you get it built?
07:11:18 <Myoma> hi shapr :)
07:11:20 <shapr> trying now
07:11:22 * shapr hugs Myoma
07:11:32 <CosmicRay> shapr: grab at least 0.99.1 if you haven't yet
07:11:38 <shapr> Yup
07:11:40 <Myoma> how come you are never in epigram ? *hug*
07:11:45 <dcoutts> CosmicRay: btw, I'll not be sending a patch I'm afraid. I'll probably have to learn how to use git one day but I'll probably wait 'til I've got some bigger task that needs it.
07:12:06 <CosmicRay> shapr: I will shortly post an 0.99.2 with proper utf8 support and no more incompatibility with cabal 1.4
07:12:11 <shapr> yay!
07:12:42 <CosmicRay> dcoutts: no problem.  I do still gladly accept the output of diff(1) ;-)  Also, check out my 5-minute git guide: http://software.complete.org/software/wiki/site/GitGuide
07:12:46 <lambdabot> Title: The Software.Complete.Org Site - GitGuide - Software.Complete.Org
07:13:00 <CosmicRay> dcoutts: that's linked to from software.complete.org/twidge -- designed to make it easy for people to contribute patches to any of my software
07:13:09 <shapr> Hm, build failure.
07:13:13 <CosmicRay> I, in fact, had two Git patches from Eric Kow this morning?
07:13:15 <dcoutts> CosmicRay: right'o, thanks
07:13:20 <CosmicRay> shapr: type error in Commands/Ls.hs?
07:13:24 <shapr> yup
07:13:31 <CosmicRay> shapr: this is the cabal 1.4 incompatibility
07:13:35 <ivanm> dammit, it still doesn't work :@
07:13:35 <shapr> oh
07:13:37 <CosmicRay> shapr: give me about 15 minutes
07:13:41 <shapr> ok!
07:14:40 <CosmicRay> oh yay the wrapText in cabal 1.4 is nicified.
07:15:13 <dcoutts> CosmicRay: see, I said the bigger number must be better :-)
07:16:08 <CosmicRay> :-)
07:16:20 <CosmicRay> now to go and update all my copyright statements
07:16:29 <tristes_tigres> dcoutts: Then windows 95 is better than NT 5 !
07:17:18 <dcoutts> > sort ["NT 5", "95"]
07:17:19 <lambdabot>   ["95","NT 5"]
07:17:33 <dcoutts> tristes_tigres: hmm, seems NT 5 is better
07:17:38 <ivanm> http://hpaste.org/10347 <- Saizan doesn't seem to work :s
07:17:50 <tristes_tigres> dcoutts: but the number is less !
07:18:18 <ivanm> yes, but it's got an NT wrapper function around it
07:18:26 <dcoutts> tristes_tigres: ok, I admit my system may be slightly flawed
07:18:46 <Beelsebob> > ("Windows " ++) . concat . sort $ ["me", "NT", "CE"]
07:18:47 <lambdabot>   "Windows CENTme"
07:19:02 <Beelsebob> uh...
07:19:06 <Beelsebob> oh, capital
07:19:07 <Beelsebob> fail
07:19:09 <tristes_tigres> ivanm: eval_suckiness (NT x) = 95 + x ?
07:20:17 <ivanm> tristes_tigres: technically, for all numbers x y, y = x + z always has a solution for z
07:20:57 <CosmicRay> shapr: do you have git installed?
07:21:26 <Saizan> ivanm: an existential will look like this data AnyOrd = forall a. Ord a => AnyOrd a; ... cluster :: a -> AnyOrd, but it won't work anyhow because of the type of compare
07:21:44 <ivanm> *nod* :(
07:21:49 <ivanm> any idea how I can solve this?
07:21:57 <CosmicRay> shapr: if so, can you git clone git://git.complete.org/twidge and let me know if it builds for you?
07:22:25 <shapr> ok
07:22:49 <CosmicRay> shapr: it has an added dep on utf8-string, BTW
07:23:12 <Saizan> ivanm: it depeds on how you're going to use the result of cluster, maybe you should make ClusterLabel a multiparam typeclass?
07:24:05 <ivanm> well, for cluster I'm going to be using it to sort and group objects
07:24:16 <ivanm> actually, I might want to show it as well...
07:25:14 <tristes_tigres> ivanm: but  eval_suckines :: ... -> Ord  not always
07:25:32 <ivanm> tristes_tigres: ummm..... what?
07:25:44 <Saizan> ivanm: try to see if the multiparam way fits with your code
07:26:10 <tristes_tigres> ivanm:  x y, y = x + z not always has a solution in class Ord
07:26:13 <shapr> CosmicRay: It built!
07:26:13 <ivanm> nope, because this is for a library where you're meant to be able to supply your own type
07:26:24 <CosmicRay> shapr: woot, thanks!  will upload then.
07:26:27 <ivanm> tristes_tigres: I did say numbers, and all numbers are instances of Ord
07:26:48 <tristes_tigres> ivanm: hmm? perhaps so
07:26:49 <Saizan> ivanm: and what's the problem with that?
07:27:02 <FunctorSalad> + in Ord?
07:27:06 <ivanm> Saizan: oh well, I suppose I could always get the user to supply the (Ord o) => a -> o function themselves rather than supplying an instance
07:27:12 <FunctorSalad> is that maximum?
07:27:44 <Saizan> ivanm: what's wrong with supplying an instance?
07:27:45 <CosmicRay> shapr: I seem to be somewhat monopolizing http://hackage.haskell.org/packages/archive/recent.html :-)
07:27:50 <FunctorSalad> nvm
07:27:53 <lambdabot> Title: HackageDB: recent additions
07:27:53 <shepheb> is there a way to get haddock 2 to give me /some/ hint of where the "parse error in doc string" actually is?
07:27:55 <ivanm> Saizan: oh, wait, you mean multiparam by specifying multiple types in the type?
07:28:04 <ivanm> I thought you meant Cluster1 | Cluster2 , etc.
07:28:10 <Saizan> ivanm: i mean a multiparameter type class
07:28:15 <tristes_tigres> any rumours on when ghc 6.9 is due out ?
07:28:20 <ivanm> so data Foo a b ?
07:28:51 <Saizan> ivanm: like class Ord o => ClusterLaber a o | a -> o where cluster :: a -> o; label :: a -> String
07:29:23 <ivanm> yes... but then how would I make Augmenet an instance of that?
07:29:46 <ivanm> would I have to convert Augment a to Augment a o or something?
07:29:49 <Saizan> instance (Show a) => ClusterLabel (Augmented a) where
07:30:04 <Saizan> instance (Show a) => ClusterLabel (Augmented a) Int where <same as before>
07:30:19 <ivanm> hang on... what does the | a -> o mean in the class declaration?
07:30:26 <ivanm> and does it require any extensions?
07:30:51 <Saizan> yup, it's a functional dependency, however MultiParamTypeClasses are an extension too
07:31:21 <Saizan> it meas that for every 'a' there can be only one 'o'
07:31:33 <ivanm> ahhh
07:31:48 <FunctorSalad> ivanm: just to save you some debugging, you have to enable some graph attribute to do arrows between clusters
07:31:49 <Saizan> it's needed because label doesn't mention 'o'
07:32:04 <FunctorSalad> (unrelatedly to the haskell prob)
07:32:07 * ivanm marvels how his project where he was going to write strictly H98 code has suddenly gained heaps of extensions in only a few hours :s
07:32:19 <Twey> Haha
07:32:22 <ivanm> FunctorSalad: hmmmmm?
07:32:23 <FunctorSalad> and you also need to use this "lhead" and "ltail" attribute or what's it called
07:32:29 <Twey> It's progress, ivanm!  :-P
07:32:33 <ivanm> oh, wait, in GraphViz?
07:32:37 <FunctorSalad> ivanm: yes ;-)
07:32:50 <ivanm> yeah, I don't think I'll be having arrows between clusters
07:33:42 <chrisdone> do (do foo <- System.IO.Strict.readFile "foo.txt"; getLine) getLine
07:33:44 <ivanm> besides, I'm having enough trouble hacking the graphviz library by matthew-_ to support undirected graphs and basic clusters (i.e. draw a ring around the cluster) let alone something like that ;-)
07:33:57 <chrisdone> I expected that ‚Äúfoo‚Äù would be garbage collected when I get to the second getLine
07:33:58 <Saizan> you could just fix the result of cluster to be something like Integer or Double and don't bother with the extra generality :)
07:34:04 <chrisdone> but this is not so
07:34:10 <chrisdone> any idea why?
07:34:38 <ivanm> chrisdone: because it's IO?
07:34:55 <chrisdone> ivanm: what?
07:35:29 <ivanm> actually, forget that... it's too late here for me to make any sense :p
07:35:55 <Saizan> well, garbage collection is not that predictable, is it?
07:35:56 <chrisdone> I think I'll check out profiling with ghc
07:36:07 <chrisdone> I dunno
07:38:05 <chrisdone> evidently not :P
07:38:40 <Saizan> ?hoogle performGC
07:38:40 <lambdabot> System.Mem performGC :: IO ()
07:41:35 <CosmicRay> shapr: is twidge working for ya?
07:45:00 <shepheb> I'm getting "parse error in doc string" even after removing all of the Haddock comments!
07:46:12 * shepheb notes that he's releasing a binary, not a library; moves all the usage documentation into a README and tells Haddock to shove it
07:51:10 <Twey> Hahahaha, shepheb
07:57:05 <hackage> Uploaded to hackage: dataenc 0.11.1
07:57:05 <hackage> Uploaded to hackage: twidge 0.99.2
08:04:51 <Myoma> woe is me
08:08:16 <skorpan> doesn't xmobar handle images, kind of like dzen2?
08:10:08 <chrisdone> is this a GHCi bug? http://hpaste.org/10349 (I'm on 6.8.3)
08:10:31 <dmwit_> Maybe you should derive Show?
08:10:39 <dmwit_> data Foo = Foo deriving Show
08:11:16 <chrisdone> the point is it doesn't give me an error when printing a Foo value from a Monad, it shows nothing at all
08:11:24 <Myoma> chrisdone: that's what happens
08:11:30 <Myoma> it's not a bug
08:11:38 <chrisdone> riight
08:11:47 <Myoma> chrisdone: try return ()
08:12:00 <chrisdone> what about it?
08:12:08 <Myoma> or don't try it, I don't mind
08:12:18 <chrisdone> I did try it
08:12:19 <chrisdone> what about it?
08:14:02 <chrisdone> ...
08:14:15 <dmwit_> chrisdone: derive Show and be done with it.
08:14:27 <chrisdone> bah, you are completely missing the point
08:14:30 <Saizan> chrisdone: if it's an action it doesn't require the result to be showable, sinche you might just be interested in the side effects
08:14:33 <dmwit_> I guess I am.
08:14:53 <Stinger> so monadic stuff only prints if it can?
08:14:54 <chrisdone> Saizan: right, ok
08:15:14 <Saizan> Stinger: exactly
08:15:18 <chrisdone> it appears so
08:15:43 <chrisdone> > show ()
08:15:44 <lambdabot>   "()"
08:15:46 <Saizan> it's the IO monad there, btw
08:16:18 <Stinger> what happens if you try a different monad
08:16:20 <Saizan> and it looks like () is an exception :)
08:16:34 <Axman6> :t ()
08:16:35 <lambdabot> ()
08:16:47 <Saizan> Stinger: it needs to be showable, just like any other pure value
08:17:00 <Stinger> so this is an IO special case
08:17:29 <chrisdone> *Main> (do return (); return 1)
08:17:30 <Stinger> ok fair enough
08:17:30 <chrisdone> 1
08:17:30 <chrisdone> *Main>
08:17:45 <chrisdone> an exception??
08:17:49 <chrisdone> why?
08:18:13 <Stinger> I don't think he means an exception in the terms of an error exception
08:18:21 <chrisdone> oh ok
08:23:55 <mwc> Stinger: more precisely, monad stuff prints if there's a Show instance for m a
08:24:12 <mwc> whcih will generally look something like instance Show a => Show (m a) where ...
08:24:38 <Heffalump> mwc: for a specific m?
08:24:48 <mwc> Heffalump: indeed. Should have used M
08:25:00 <BONUS> > Writer $ (3,[])
08:25:02 <lambdabot>       No instance for (Show (Writer [a1] a))
08:25:02 <lambdabot>        arising from a use of `sh...
08:41:20 <Maciej_> Hi! Is there a standalone package for reading images (jpg or bmp would be fine).
08:42:44 <paczesiowa> reading as what?
08:42:58 <Vq^> i have used Imlib for that but it might not be considered standalone
08:43:05 <Maciej_> I just want the pixel data in RGB format.
08:43:13 <paczesiowa> if you want to display it you can use gtk2hs
08:44:13 <Maciej_> Does gtk2hs provide reading from file system?
08:44:20 <paczesiowa> yes
08:44:34 <Maciej_> Ok, thanks!
08:44:52 <papermachine> Could someone remind me what the neat one-liner for the powerset of a list is?
08:45:16 <Myoma> :t filterM (const [False,True])
08:45:17 <lambdabot> forall a. [a] -> [[a]]
08:45:27 <papermachine> danke
09:08:36 <FunctorSalad> ivanm: there's an easy way to make a digraph into an undirected graph: edge [dir=none]
09:09:36 <FunctorSalad> so the undirected syntax is kinda redundant as far as I can see (maybe some of the details are different though)
09:10:08 <FunctorSalad> (I think it's explained in the "limitations" section of the docs)
09:21:54 <skorpan> \x -> "<fc=" ++ col ++ ">" ++ x ++ "</fc>"
09:21:56 <skorpan> @pl \x -> "<fc=" ++ col ++ ">" ++ x ++ "</fc>"
09:21:57 <lambdabot> (("<fc=" ++ col) ++) . ('>' :) . (++ "</fc>")
09:22:02 <skorpan> SMILEY MAN
09:24:23 <skorpan> is there any haskell function which given a string chops it and appends "..." to it if it's longer than a specified length?
09:27:30 <Twey> skorpan: trunc = ((++ "...") .) . take
09:28:49 <flux> @unpl  ((++ "...") .) . take
09:28:49 <lambdabot> (\ e h -> (take e h) ++ "...")
09:29:02 <flux> ah, much better :)
09:29:24 * Myoma prefers (\ e h -> take e h ++ "...")
09:29:34 <LeoD> bah!
09:29:40 <Myoma> but you also need to use take twice
09:30:25 <flux> but it's short, to-the-point and elegant! (even if wrong..) ;)
09:30:28 <Myoma> > (\e h -> take e h ++ "...") "abc(o)xyz!?$" 4
09:30:29 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
09:30:36 <Myoma> > (\e h -> take h e ++ "...") "abc(o)xyz!?$" 4
09:30:38 <lambdabot>   "abc(..."
09:30:48 <Myoma> > (\e h -> take h e ++ "...") "abc(o)xyz!?$" 15
09:30:49 <lambdabot>   "abc(o)xyz!?$..."
09:31:15 <Myoma> > (\e h -> take (length e) (take h e ++ "...")) "abc(o)xyz!?$" 15
09:31:16 <lambdabot>   "abc(o)xyz!?$"
09:31:18 <Myoma> > (\e h -> take (length e) (take h e ++ "...")) "abc(o)xyz!?$" 3
09:31:20 <lambdabot>   "abc..."
09:31:40 <Stinger> ((.(++"...")).)  . take
09:31:49 <flux> but it doesn't really match the specification
09:32:04 <Stinger> think I may have an extra . in there
09:32:50 <Stinger> @ty ((.(++"...")).)  . take
09:32:51 <lambdabot>     Couldn't match expected type `[Char] -> c'
09:32:51 <lambdabot>            against inferred type `[a]'
09:32:51 <lambdabot>     Probable cause: `take' is applied to too many arguments
09:32:59 <Stinger> bah :)
09:34:18 <Stinger> @ty ((++"...").)  . take
09:34:20 <lambdabot> Int -> [Char] -> [Char]
09:34:36 <olsner> @ty (.:)
09:34:37 <lambdabot> Not in scope: `.:'
09:35:42 <LeoD> @ty (.(:))
09:35:43 <lambdabot> forall c a. (([a] -> [a]) -> c) -> a -> c
09:35:49 <olsner> > let (.:) = (.).(.); trunc = ((++"...") .: (take . subtract 3) in trunc 15 (show [1..])
09:35:50 <lambdabot>   mueval: Prelude.read: no parse
09:36:01 <ddarius> > foldr (\x xs n -> if n > 0 then x:xs (n-1) else x:"...") (const []) "abcdef" 5
09:36:02 <lambdabot>   "abcdef..."
09:36:02 <olsner> > let (.:) = (.).(.); trunc = (++"...") .: (take . subtract 3) in trunc 15 (show [1..])
09:36:03 <lambdabot>   "[1,2,3,4,5,6..."
09:36:10 <ddarius> > foldr (\x xs n -> if n > 0 then x:xs (n-1) else "...") (const []) "abcdef" 5
09:36:11 <lambdabot>   "abcde..."
09:36:15 <ddarius> > foldr (\x xs n -> if n > 0 then x:xs (n-1) else "...") (const []) "abcdef" 10
09:36:16 <lambdabot>   "abcdef"
09:36:30 <skorpan> so... how's my function coming? :P
09:36:46 <ddarius> There's a nice higher order fold version.
09:36:48 <skorpan> i'm thinking i should just go for an if/then/else :P
09:40:11 <skorpan> > :t (=?)
09:40:12 <lambdabot>   mueval: Prelude.read: no parse
09:40:21 <skorpan> :t (=?)
09:40:22 <lambdabot> Not in scope: `=?'
09:44:35 <johnny4> hi, I need some help about PHP. Anyone here who can answer to a few questions ?
09:45:05 <ddarius> johnny4: This isn't a PHP channel.  Ask on #php if it exists or somewhere else.
09:45:40 <johnny4> thanks
09:46:06 <tomh_-_> typing #haskell instead of #php is apparently a common typo ~
09:47:30 <ddarius> @users
09:47:30 <lambdabot> Maximum users seen in #haskell: 504, currently: 468 (92.9%), active: 11 (2.4%)
09:48:38 <Stinger> heh 2.4%
09:48:48 <Stinger> few lurkers
09:52:20 <ddarius> There's usually only 10-20 people "active" at a time, but it is different people at different times.
09:54:19 <dons> ?yow
09:54:20 <lambdabot> Are you selling NYLON OIL WELLS??  If so, we can use TWO DOZEN!!
09:55:04 <mwc> I cover the Uzbekishtani through Syndey time zones... from Canada
09:57:12 <Myoma> ?parmer
09:57:12 <lambdabot> Maybe you meant: farber palomer
09:57:17 <Myoma> ?farber
09:57:17 <lambdabot> Don't put all your flamingos in one basket.
09:58:38 <Myoma> @palomer
09:58:38 <lambdabot> Blargh!
09:58:39 <Myoma> @palomer
09:58:39 <lambdabot> Blargh!
09:58:40 <Myoma> @palomer
09:58:41 <lambdabot> Hrmph
09:58:42 <Myoma> @palomer
09:58:42 <lambdabot> I think you're all nuts
10:02:20 <thoughtpolice> yay i didn't die in the storm last night
10:03:29 <ez> texas?
10:03:43 <skorpan> anyone using defaultPP with xmonad and ppUrgent?
10:04:25 <uep> Man, I'm doing yaht, and I'll tell you that I definitely don't get the Binary Tree section in "Type Basics."
10:05:00 <uep> Specifically, the solutions to treeFoldl and treeFoldr.
10:13:55 <byorgey> @arr !
10:13:55 <lambdabot> Yeh scurvy dog...
10:17:21 * AlexSuraci wishes there was a way to write regexps using /these/ instead of quotes
10:17:51 <Myoma> you can use [$rx| |] instead of / /
10:18:38 <AlexSuraci> how would that handle escaping things?
10:18:46 <thoughtpolice> quasiquoting ftw!
10:18:52 <AlexSuraci> e.g. matching (foo) with \(([a-z]+)\)
10:18:52 <thoughtpolice> ez: yes
10:19:32 <AlexSuraci> probably an unbased gripe, I know why it needs to be written like "\\(([a-z]+)\\)" when using quotes, just wondering if it's any different with quasiquoting
10:22:01 <ez> I used to be able to explore standard modules using :b in GHCi. This seems to have stopped with 6.8--is that right?
10:22:11 <ez> I get "module 'Foo' is not interpreted".
10:22:20 <Saizan> ez: use :browse
10:22:42 <ez> Saizan: Oh! Thanks. What's the difference?
10:23:01 <Saizan> ez: that now :b is short for :break :)
10:23:15 <Saizan> which is a command of the debugger
10:23:16 <ez> ah! the old switcheroo. got it.
10:34:19 <kaspyanand> hi
10:35:03 <kaspyanand> i am looking for explanation of a code of insertion sort
10:35:08 <kaspyanand> this is the code
10:35:11 <kaspyanand> sort []  = []
10:35:11 <kaspyanand> sort [x] = [x]
10:35:11 <kaspyanand> sort (x:xs) = insert (sort xs)
10:35:11 <kaspyanand>     where insert [] = [x]
10:35:11 <kaspyanand>           insert (y:ys) | x <= y    = x : y : ys
10:35:12 <kaspyanand>                         | otherwise = y : insert ys
10:35:27 <newsham> hmm..  why didnt haskell use x and + for tuple and either?  its nice notation
10:35:30 <Myoma> kaspyanand: I don't know, I would just say it's poorly written
10:35:40 <kaspyanand> ok
10:36:13 <ddarius> newsham: The MLs used * and it totally jacks their type signatures.
10:36:17 <Myoma> ?go algebra of programming with dependent types
10:36:21 <lambdabot> http://lambda-the-ultimate.org/node/2771
10:36:21 <lambdabot> Title: Algebra of programming using dependent types | Lambda the Ultimate
10:36:47 <newsham> ddarius: how so?
10:36:49 <Myoma> kaspyanand, there is a description in there ^
10:37:12 <ddarius> newsham: They end up with tons of parentheses
10:37:41 <newsham> you already need parens with (,).  do you get more with (... * ...) ?
10:38:29 <kaspyanand> Myoma,ok thanks
10:40:24 <dons> nice, http://okasaki.blogspot.com/2008/09/hey-you-got-your-loop-in-my-recursion.html
10:40:25 <lambdabot> Title: Teaching, Playing, and Programming: Hey, you got your loop in my recursion!, http://tinyurl.com/6r774e
10:40:36 <dons> might be useful insight for other people struggling with when to use recursion.
10:40:58 <shrughes> newsham: regarding either, what would x+y+z be?  Left (Left x), Left (Right y), Right z... meh.
10:41:01 <newsham> "dood, where's my loop?"
10:41:16 <Myoma> > x + y + z
10:41:17 <lambdabot>   x + y + z
10:41:22 <Myoma> > (x + y) + z
10:41:23 <lambdabot>   x + y + z
10:41:26 <Myoma> > x + (y + z)
10:41:28 <lambdabot>   x + (y + z)
10:41:32 <newsham> shrughes: thats a solved problem
10:41:48 <shrughes> newsham: and the solution is...?
10:42:01 <Myoma> shrughes!
10:42:08 <newsham> associativity as a convention
10:42:14 <Myoma> shrughes, It'll be (x + y) + z, Expr says so
10:42:20 <ddarius> newsham: It's kind of like [a,b,c] vs a:b:c:[], the latter is only a couple more characters but that misses the benefit that in [a,b,c] we don't need parentheses to disambiguate the precedence of a, b, and c if they are more complex expressions.
10:42:26 <shrughes> The answer I was looking for was "ugly", actually...
10:42:27 <ddarius> This makes it easier to read and write.
10:42:55 <Myoma> shrughes: that doesn't matter
10:43:03 <Myoma> shrughes: You can use functions to make it not ugly
10:43:11 <Myoma> inl inm inr
10:43:59 <shrughes> Pretty much if you have (x+y+z) you should just make a custom datatype
10:44:08 <newsham> kaspy: what do you want to know about that function?
10:44:33 <newsham> the idea is to form a sorted list of the tail (xs), and then insert the head (x) into that sorted list at the right place.
10:45:24 <newsham> ie:  [5,3,7,2] ->  5 and [2,3,7]   and then insert the 5 after the 3 and before the 7 to get: [2,3,5,7]
10:46:32 <newsham> the degenerate cases of sorting an empty list and a list with just one element are handled separately
10:47:06 <newsham> (although i think the singleton case is unnecessary)
10:47:26 <kaspyanand> newsham, thats the only way to implement?
10:47:39 <newsham> there's always another way :)
10:47:46 <kaspyanand> :)
10:47:50 <newsham> there are lots of ways to sort, and the insertion sort isnt really that great.
10:48:08 <kaspyanand> i was thinking of another approach for insertion sort
10:48:18 <newsham> since the number of steps goes up quickly as the length of the list grows (it's O(n^2))
10:48:29 <kaspyanand> yeah true
10:48:38 <Myoma> kaspyanand: as a fold (as used in the paper I linked), is the way I prefer
10:48:49 <newsham> well, for example, you could implement insert different.
10:48:52 <ddarius> > foldr insert [] [1,5,2,68,6,4,0,76]
10:48:54 <lambdabot>   [0,1,2,4,5,6,68,76]
10:49:02 <Myoma> kaspyanand: but you can get better algorithmic complexity if you use a tree instead of al ist
10:49:05 <newsham> > span (<5) [2,3,7]
10:49:07 <lambdabot>   ([2,3],[7])
10:49:37 <newsham> and you can use ddarius' code above to get rid of the explicit recursion
10:50:11 <newsham> (span also gets rid of the explicit recursion of "insert")
10:51:21 <newsham> asking "is that the only way" on #haskell is asking for trouble.  (see also: http://www.willamette.edu/~fruehr/haskell/evolution.html)
10:51:26 <lambdabot> Title: The Evolution of a Haskell Programmer
10:51:59 <newsham> ie. you could write an imperative insertion sort using State
10:52:23 <kaspyanand> i dont wana do imperative thats for another lang,C#
10:52:38 <ddarius> > foldl' (flip insert) [] [1,5,99,45,8,0,34]
10:52:45 <lambdabot>   [0,1,5,8,34,45,99]
10:53:30 <newsham> > foldr insert "the quick brown fox jumped over the lazy dogs."
10:53:31 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
10:53:31 <lambdabot>        arising from a...
10:53:34 <pdarnows> newsham: I'm trying to wrap my head a little tighter around State, would you mind a quick example?
10:53:37 <newsham> > foldr insert "" "the quick brown fox jumped over the lazy dogs."
10:53:38 <lambdabot>   "        .abcddeeeefghhijklmnoooopqrrsttuuvwxyz"
10:53:56 <ddarius> @src insert
10:53:56 <lambdabot> insert e ls = insertBy (compare) e ls
10:54:04 <ddarius> That's jacked up.
10:54:08 <ddarius> @src insertBy
10:54:09 <lambdabot> insertBy _   x [] = [x]
10:54:09 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
10:54:09 <lambdabot>                                  GT -> y : insertBy cmp x ys'
10:54:09 <lambdabot>                                  _  -> x : ys
10:54:11 <newsham> > runState (do { x <- get; put (x+2); modify (*3); return x; }
10:54:12 <lambdabot>   mueval: Prelude.read: no parse
10:54:15 <newsham> > runState (do { x <- get; put (x+2); modify (*3); return x; }) 5
10:54:16 <lambdabot>   (5,21)
10:54:48 * pdarnows strokes beard thoughtfully
10:54:50 <pdarnows> thanks
10:55:18 <newsham> anything in particular?
10:56:29 <pdarnows> newsham: I'm trying to use State with Map to do memoization for dynamic algorithms
10:56:42 <pdarnows> s/algorithms/programming
10:57:06 <hackage> Uploaded to hackage: citeproc-hs 0.1
10:57:18 <newsham> so when you do "get" you get a map, so you can do a lookup by "gets $ lookup k" or something like that
10:57:21 <kaspyanand> i had no idea that haskell had insert
10:57:52 <newsham> and you can use modify and map insertion functions to do inserts
10:58:18 <newsham> make helper functions for your lookups and inserts and the rest of your code should be fairly straightforward
10:58:28 <pdarnows> newsham: thanks, that's really helpful
10:58:38 <ddarius> > foldl' (flip $ foldr (\x ys@(y:ys') -> if x > y then y:ys' else x:ys) . (:[])) [] [2,7,4,9,0,2]
10:58:40 <lambdabot>   [0,2]
10:59:23 <kaspyanand> so in this case, foldr insert [] [1,5,2,68,6,4,0,76] , i dont understand how insert is applied to each element using []
10:59:46 <Myoma> kaspyanand: you know how the list is made of conses?
10:59:53 <kaspyanand> yes 1:2:3
10:59:56 <ddarius> > foldr (var "insert") [] [1,5,3,68,4,6]
10:59:57 <lambdabot>       Ambiguous occurrence `var'
10:59:57 <lambdabot>      It could refer to either `Data.Number.S...
11:00:04 <Myoma> kaspyanand, so what happens if you replace each cons with 'insert'?
11:00:09 <ddarius> > foldr (Data.Number.Symbolic.var "insert") [] [1,5,3,68,4,6]
11:00:11 <lambdabot>   Couldn't match expected type `a -> b -> b'
11:00:13 <Myoma> 1 `insert` (2 `insert` ( ...
11:00:20 <ddarius> > foldr (fun "insert") [] [1,5,3,68,4,6]
11:00:21 <lambdabot>       No instance for (SimpleReflect.FromExpr [a])
11:00:21 <lambdabot>        arising from a use ...
11:00:35 <Myoma> kaspyanand, fold does that replacement
11:00:53 <idnar> @type fun "insert"
11:00:54 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:01:12 <idnar> > (fun "insert") 5
11:01:13 <lambdabot>   Add a type signature
11:01:31 <ddarius> > fun "insert" 5 [2,4] :: Expr
11:01:33 <lambdabot>   insert 5 [2,4]
11:01:48 <idnar> oh yes, Expr
11:02:09 <Myoma> > foldr (\x y -> (fun "insert" :: Expr -> Expr -> Expr) x y) x [1,5,3,68,4,6]
11:02:11 <lambdabot>   insert 1 (insert 5 (insert 3 (insert 68 (insert 4 (insert 6 x)))))
11:02:22 <Myoma> > foldr (\x y -> (fun "insert" :: Expr -> Expr -> Expr) x y) (fun "nil" undefined) [1,5,3,68,4,6]
11:02:24 <lambdabot>   mueval: Prelude.read: no parse
11:02:24 <lambdabot>  mueval: insert 1 (insert 5 (insert 3 (inser...
11:06:30 <mc__> I'm looking for a function which "flattens" a list, like [[a]] -> [a]
11:06:33 <ddarius> Just var "nil"
11:06:38 <ddarius> @hoogle [[a]] -> [a]
11:06:38 <lambdabot> Prelude concat :: [[a]] -> [a]
11:06:38 <lambdabot> Data.List concat :: [[a]] -> [a]
11:06:38 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
11:06:55 <mc__> ddarius: thank you
11:09:22 <newsham> pdar: http://codepad.org/sqCLaEg1
11:11:17 <kaspyanand> myoma,now i get it, basically the element from list becomes the first argument to insert,so what is getting evaluated is insert 76 [], then insert 0 [76]
11:16:09 <newsham> pdarnows: you'd probably want to define a new type to hide the "State (M.Map Int String)" part, but i left it all in so you can see it all
11:16:40 <newsham> but "type MyState a = State (M.Map Int String) a" would hide it nicely
11:16:40 <pdarnows> newsham: thanks, I think I see how to do what I have in mind now
11:21:28 <newsham> "image of A under f" means { f x | x \in A }   ?
11:22:30 <pdarnows> newsham: I believe that's correct...image a.k.a. range
11:22:43 <Myoma> it's not image of f under A ?
11:23:05 <newsham> "n.b. f ` A is the image of A under f"
11:23:19 <Myoma> does that even typecheck o_O
11:25:37 <ddarius> Myoma: It's what A looks like when applied to f
11:26:39 <newsham> so the set of values x in A for which f x is defined?
11:26:51 <newsham> and not the set of values (f x) for x in A ?
11:27:05 <ddarius> If you draw A as a blob and f's codomain as another blob below A, then you can draw f as stick A into the lower blob making a (perhaps) smaller blob inside the lower one that is the image of A under f.
11:27:43 <ddarius> newsham: The latter not the former.  The former is typically called the support of f.
11:27:53 <ddarius> And it is only applicable when f is partial.
11:28:36 <newsham> danke.
11:32:16 <mc__> is there a way to stop list comprehension if a certain function returns False? I currently have this in my programm" [ x + x | x <- [1..num], num `isDivideable` (n * x) ] ". I'm not completely sure but I think that it takes a huge time generating a lot of numbers which are not included in the final list. Am I right?
11:32:30 <newsham> ?src takeWhile
11:32:30 <lambdabot> takeWhile _ []                 =  []
11:32:30 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
11:32:30 <lambdabot>                    | otherwise =  []
11:32:41 <Lord_Illidan> Hi
11:32:59 <mc__> thank you newsham
11:33:04 <Lord_Illidan> What's the best library to fetch a webpage off the net, and parse the contents?
11:33:43 <newsham> there are several libs for grabbing pages.  curl might be a good one.
11:33:58 <newsham> for parsing, if you're just doing an ad hoc parse (ie. scraping data) a tag soup library is usually easiest
11:34:42 <FunctorSalad> hmm... I have a (GADT?) constructor:      data Stuff a where MkStuff :: forall b, (Eq b) => Thing b -> Stuff a
11:34:52 <Lord_Illidan> What I'm looking for is this, basically. I have to grab a page off the internet, that page has a number inside it, and I use the number to create a new URL, and go to that webpage,  etc
11:34:57 <Lord_Illidan> It's a recursive process
11:34:59 <FunctorSalad> (with "Thing b" being Eq too)
11:35:13 <FunctorSalad> now I have trouble implementing Eq for Stuff a.
11:35:22 <Lord_Illidan> It's also part of the Python Challenge websites, if anyone recognises it :D
11:35:23 <newsham> lord: sounds like an old python challenge task.
11:35:29 <Lord_Illidan> newsham, exactly
11:35:46 <FunctorSalad> the intended behaviour is that MkStuff x = MkStuff y if type x == type y and x == y
11:35:54 <Lord_Illidan> But I'm doing them with haskell, already done well so far with it, and I prefer haskell to python tbh
11:35:57 <newsham> i would try the curl library and the tag soup library
11:36:01 <Lord_Illidan> Thanks
11:36:09 <Saizan> FunctorSalad: add a Typeable context
11:36:26 <newsham> unless you're already comfortable with aonther http fetching library (like network.http)
11:36:26 <FunctorSalad> Saizan: good idea
11:36:32 <FunctorSalad> thx
11:36:43 <Saizan> np
11:36:51 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl
11:36:52 <lambdabot> Title: HackageDB: curl-1.3.2.1
11:37:12 <newsham> (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP  would work well as an alternative, doesnt require any local C libs)
11:37:13 <lambdabot> Title: HackageDB: HTTP-3001.0.4
11:37:13 <FunctorSalad> Saizan: hmm but I still have to unsafe-cast x to compare it to y, right?
11:37:26 <Saizan> ?type Data.Typeable.cat
11:37:26 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup
11:37:27 <lambdabot> Not in scope: `Data.Typeable.cat'
11:37:28 <FunctorSalad> (don't know how the function is actually called)
11:37:28 <Saizan> ?type Data.Typeable.cast
11:37:29 <lambdabot> Title: HackageDB: tagsoup-0.6, http://tinyurl.com/6yh7v4
11:37:29 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
11:37:34 <FunctorSalad> ah
11:37:38 <Myoma> why don't you use data Stuff b a where MkStuff :: Thing b -> Stuff b a instead?
11:37:55 <Saizan> FunctorSalad: which does the type x == type y comparison for you
11:38:06 <Myoma> oh I see what you are doing
11:38:13 <FunctorSalad> Myoma: the real situation is:     data Term s where        Constructed :: forall a. (Sort s, ArgClass a) => (Constructor a s) -> a -> Term s
11:38:33 <FunctorSalad> the Term doesn't really care what the args type of the constructor was
11:38:44 <Saizan> FunctorSalad: so it becomes MkStuff x == MkStuff y = case cast y of Nothing -> False; Just y' -> x == y'
11:39:09 <FunctorSalad> Saizan: nice, I don't even have to compare the TypeReps myself that way
11:39:28 <Saizan> yeah :)
11:40:19 <Saizan> this feels like downcasting in OO
11:41:14 <FunctorSalad> hmm... would you do something else? to me it seems the a should be eliminated
11:41:55 <FunctorSalad> if I'm looking for a term of sort A, I don't care if it was created from a constructor that takes a B or a C, do I?
11:42:27 <FunctorSalad> maybe I shouldn't have used the type system and added an indirection layer, dunno
11:43:17 <yakov> hello
11:43:27 <shrughes> hi
11:43:31 <FunctorSalad> hi :)
11:44:25 <FunctorSalad> s/layer/layer instead/
11:44:55 <FunctorSalad> "unnecessary use of type system" :-)
11:46:37 <BMeph> FunctorSalad: That last line makes no sense. :)
11:46:49 <FunctorSalad> hmm...
11:46:57 <yakov> guys, what do you think about the book Introduction to Functional Programming Systems Using Haskell?
11:47:09 <FunctorSalad> BMeph: about the type system or the one before that?
11:47:24 <BMeph> FunctorSalad: The type system. :)
11:47:41 * FunctorSalad fails epically at disambiguation, since the "the one before that" also talks about the type system
11:48:51 <marcot> How do I wait for a child thread to end?
11:49:16 <dmwit> How was it created?
11:49:20 <dmwit> forkIO?
11:49:34 <marcot> I have to use mvar?  Isn't there something like waitForProcess?
11:49:39 <marcot> dmwit: yes.
11:49:49 <ddarius> marcot: You pass it a MVar to fill when it is done and have the other thread takeMVar
11:49:51 <Saizan> marcot: yeah, use a MVar
11:49:54 <dmwit> waitForProcess is fine, but then you have to create a separate process. =P
11:49:58 <dmwit> So, yeah, MVar.
11:50:04 <marcot> ok, thanks.
11:50:34 <newsham> write your own waitForProcess that creates an MVar, forkIO's your new thread with an extra cmd to write to the mvar, and then read the mvar.
11:50:35 <ddarius> marcot: Many times you don't need to wait on a child thread so associating a MVar with it to implement a waitThread function is just unnecessary overhead.
11:51:10 <dmwit> newsham: ...that's waitForThread.
11:51:33 <newsham> could be called waitForTheCowsToComeHome, I dont care.
11:51:44 <marcot> ok, I think passing an MVar is ok.
11:53:05 <FunctorSalad> marcot: IIRC the mvar docs has waiting for children as an example
11:53:08 * BMeph waits for the inevitable forkGodot; waitFor...
11:53:16 <marcot> FunctorSalad: I saw it here, thanks.
11:54:23 <newsham> forkHandle thr = do { m <- newEmptyMVar; forkIO (act >> putMVar m ()); return (readMVar m) }
11:54:43 <newsham> wait <- forkHandle myact; .....;   wait
11:54:52 <newsham> s/act/thr/
11:57:25 <newsham> no mvar passing needed
11:58:10 <dmwit> No threading needed, either.
11:58:25 <newsham> ?
11:58:37 <newsham> it doesnt wait until after .....
11:58:38 <dmwit> That doesn't return until the thread does.  So why bother?
11:58:53 <newsham> note th eputMVar doesnt evaluate inside forkHandle
11:59:26 <mc__> @hoogle [a] -> a
11:59:27 <lambdabot> Prelude head :: [a] -> a
11:59:27 <lambdabot> Prelude last :: [a] -> a
11:59:27 <lambdabot> Data.List head :: [a] -> a
11:59:31 <dmwit> Oh, return (readMVar m).
11:59:32 <newsham> forkHandle :: IO (IO ())
11:59:33 <dmwit> Cute. =)
12:00:29 <newsham> what is VCG in relation to proofs?
12:02:06 <mattam> Verification Condition Generation
12:02:26 <newsham> ty
12:03:19 <marcot> newsham: takeMVar...
12:03:31 <newsham> ty.  my bad.
12:03:52 <newsham> err... no, it says readMVar in Control.Concurrent.MVar
12:04:14 <ddarius> :t (readMVar, takeMVar)
12:04:16 <lambdabot> Not in scope: `readMVar'
12:04:16 <lambdabot> Not in scope: `takeMVar'
12:04:25 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
12:04:27 <lambdabot> Title: Control.Concurrent.MVar, http://tinyurl.com/2ykhtj
12:04:35 <ddarius> :t (Control.Concurrent.MVar.readMVar, Control.Concurrent.MVar.takeMVar)
12:04:36 <lambdabot> forall a a1. (GHC.IOBase.MVar a -> IO a, GHC.IOBase.MVar a1 -> IO a1)
12:05:13 <newsham> oh... readMVar is not what i wanted
12:05:21 <newsham> takeMVar is indeed.  ty, marcot.
12:06:10 <marcot> ok...
12:06:16 <ddarius> It depends on how many threads you want to use wait.
12:06:23 <newsham> yup.
12:16:03 <shapr> @seen CosmicRay
12:16:03 <lambdabot> I saw CosmicRay leaving #haskell-blah and #haskell 1h 30m 20s ago, and .
12:16:05 <shapr> hmm
12:16:13 <shapr> Twidge should say it's twidge, not web.
12:19:18 <ddarius> coroutine f = do send <- newEmptyMVar; recv <- newEmptyMVar; forkIO (takeMVar recv >>= f (\x -> putMVar send x >> takeMVar recv) >>= putMVar); return (\x -> putMVar recv x >> takeMVar send)
12:20:11 <kaol> will Haskell' remove fail from Monad?
12:21:00 <newsham> ddarius: whats the last forkIO'd putMVar for (which mvar?)
12:22:51 <ddarius> send
12:26:48 <ddarius> step yield n | n > 100 = return n | otherwise = yield n >>= step yield . (n+)
12:27:47 <ddarius> cocall <- coroutine step; cocall 1 -> 1; cocall 1 -> 2; cocall 1 -> 3; cocall 10 -> 13; cocall 100 -> 113; cocall 39 -> Blocked
12:28:58 <newsham> nifty
12:33:19 <dons> Arch Haskell Weekly News: http://archhaskell.wordpress.com/
12:33:19 <lambdabot> Title: Arch Linux and Haskell
12:33:30 <dons> feedback on how this should be structured to be relevant and useful, welcome.
12:33:54 <ddarius> We're going to need an aggregator just for all the "weekly" things
12:34:03 <dons> p.h.o :)
12:41:27 <newsham> http://codepad.org/GwtS6wMj
12:49:21 <ddarius> newsham: Now if you want to be silly make a scheduler using the coroutines.
12:50:36 <BMeph> dons: No, obviously, it should be weekly.haskell.org -- w.h.o :)
12:57:07 <hackage> Uploaded to hackage: panda 0.0.0.3
12:59:11 <adekoba> is there a way to force ghc to output *.prof? I have max heap size set (+RTS -M) and when the program goes above, the prof file is not output.
12:59:26 <newsham> ddarius: today is not the day for writing a kernel
13:01:45 <adekoba> ah, nevermind -i looks like it does the job
13:05:24 <scorch_> I have a list that looks like this: [[a,b,c,...]], and I want to be able to split it into [[a,b,c],[d,e,f],...]. Like "splitAt 3" but for each third element, and not just the first three
13:05:27 <adekoba> er, nevermind. -i is for heap profiling.
13:06:37 <dons> adekoba: which ghc are you using?
13:06:48 <adekoba> dons: The Glorious Glasgow Haskell Compilation System, version 6.8.2
13:06:56 <Saizan> scorch_: you can write that function with unfoldr and splitAt
13:06:57 <dons> so you want to a) set a max heap size, and b) ensure you get prof info even when it dies.
13:07:02 <adekoba> dons: yes
13:07:06 <dons> now i thought that was fixed in 6.8.x -- you always get a .prof
13:07:11 <dons> even on segfaults or the like.
13:07:54 <adekoba> dons:  I'm compiling with -prof -auto-all and running the program with +RTS -M100m -p -RTS
13:08:04 <dons> maybe just leave the -M flag off
13:08:20 <dons> otherwise, file a bug report.
13:08:21 <dons> ?bug
13:08:21 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:08:28 <dons> since profiling should work no matter how your program exits.
13:09:04 <adekoba> dons: that's the thing, though. The program runs into a loop and memory usage starts spiraling. I'm trying to see which function is the culprit.
13:09:35 <dons> can you give it smaller input?
13:09:41 * dons tests.
13:10:36 <adekoba> dons: the input is not very large... I don't think it has anything to do with that. I've fed it larger files before.
13:10:37 <scorch_> Saizan: thanks, I'll look into it
13:10:48 <adekoba> I'll file a bug report anyways
13:10:51 <dons> ah, so i get an empty .prof file.
13:11:31 <dons> simple test case:
13:11:35 <dons> main = print $ product [1..]
13:11:45 <dons> $ ghc -O -prof -auto-all A.hs --make
13:11:55 <dons> $ ./A +RTS -M100k -p
13:12:01 <dons> $ cat A.prof
13:12:01 <dons> $
13:12:18 <dons> so the bug report is basically: can't profile if the heap maximum is hit.
13:12:36 <adekoba> ok
13:12:46 <dons> while if it runs to completion (e.g. no -M flag, we get good prof data)
13:13:29 <adekoba> Is it supposed to output with ctrl-C?
13:13:30 <dons> @tell jinjing Is there any reason panda *requires* latest haxml. it isn't in many distros.
13:13:30 <lambdabot> Consider it noted.
13:13:34 <dons> adekoba: yeah.
13:13:44 <dons> maybe this has been fixed in ghc head.
13:13:50 <dons> since that was fixed recently.
13:24:27 <shapr> SyntaxNinja: You were in BOSTON?
13:24:34 <shapr> And you didn't call me??
13:24:36 * shapr sniffles
13:25:33 <newsham> drinks @ naked fish?
13:25:42 <dons> shapr: he was super busy i suspect. we had a *crazy* week on the east coast.
13:25:50 <shapr> Oh, ok
13:26:01 <shapr> newsham: Er, You've been to naked fish?
13:26:02 <dons> 4am to 2am days
13:26:09 <shapr> That's right by where I work.
13:26:20 <newsham> shapr: i used to work for guardent, based in waltham.
13:26:28 <shapr> ohhh :~)
13:26:43 <newsham> i was in sf, but spent several months out there
13:27:05 <shapr> I work near the Naked Fish in Billerica.
13:27:23 <pdarnows> I live in Cambridge
13:28:48 <dons> shapr, et al, anyone have suggestions for good software for organising daily goals.
13:28:54 <dons> kind of like software todo lists
13:29:21 <a-s> hello
13:29:28 <dons> postit notes, basically
13:29:35 <a-s> How can I generate the same random sequence many times? I tried using make-random-state, *random-state*, random and it does not work...
13:29:52 <dons> a-s: in haskell?
13:30:05 <a-s> I want to generate random seq in MIT scheme
13:30:10 <dons> wrong channel :)
13:30:11 <shapr> dons: I've been using Chandler lately, it's interesting.
13:30:27 <a-s> I know. Nobody answers on #scheme
13:30:37 <dons> a-s: well, we can tell you how to do it in haskell
13:30:41 <shapr> a-s: I can show you how to do it in Haskell! But I haven't done any Scheme in loooong.
13:30:42 <dons> would that help?
13:30:48 <shapr> Ooh, dons is a better resource.
13:31:01 <dons> i've not done scheme since about 2001
13:31:06 <newsham> nobody answered in #hotels, but maybe you guys can help.  I need a room in waltham on the weekend of oct 3rd.
13:31:08 <shapr> dons: Personally, I want a todo list that works more like Getting Things Done, I want to be able to 'split a thunk'
13:31:12 <shapr> newsham: haha
13:31:14 <dons> newsham: let me look.
13:31:14 <shapr> newsham: Seriously?
13:31:21 <newsham> no. not seriously.
13:31:22 <dons> shapr: yeah.
13:31:34 <shapr> newsham: Dang, I was *so* going to buy you your beverage of choice.
13:31:35 <dons> newsham: oh, i'll cancle that.
13:31:47 <shapr> And maybe even let you stay in my spare bedroom :-)
13:31:57 <a-s> I do not use haskell... In fact this haskell is the name of the inventor of the Y combinator?
13:32:05 <dons> that guy, yeah.
13:32:12 <shapr> a-s: You might like Haskell! It's fun!
13:32:13 <dons> kinda :)
13:32:19 <dons> it's like scheme, but shorter and faster.
13:32:23 <shapr> a-s: But I think Scheme is also good to learn!
13:32:28 <newsham> > randoms (mkStdGen 1) :: [Int]
13:32:30 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
13:32:35 <newsham> > randoms (mkStdGen 1) :: [Int]
13:32:36 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
13:32:44 <shapr> Oh, Sussman is giving a lecture at MIT on my birthday, I'm going to get my copy of SICP autographed, w00!
13:32:47 <newsham> the same every time..  but i dont think that will help you with scheme.
13:32:49 * dons tries "screenlets"
13:33:08 <shapr> dons: I want a tree that I can expand and add subnodes on demand.
13:33:10 <a-s> shapr: I know LISP
13:33:19 <a-s> and scheme
13:33:23 <shapr> a-s: I'm better with elisp myself.
13:33:25 <dons> shapr: yeah. *exactly*
13:33:32 <dons> trees with spliitting.
13:33:35 <shapr> Yeah!
13:33:37 <newsham> > ((+) 3 ((*) 5 8))
13:33:38 <dons> shapr: maybe we can write this in gtk
13:33:39 <lambdabot>   43
13:33:41 <shapr> Yeah!!
13:33:53 <dons> it's just a view onto a little Haskell Tree String
13:33:57 <shapr> Yeah, sounds great.
13:34:13 <shapr> I really like Chandler's sync feature.
13:34:28 <shapr> That way I can put in items at work or at home when I think of them.
13:34:30 <a-s> shapr: however I have never seen you on #emacs
13:34:37 <shapr> a-s: I still have ops on #emacs :-)
13:35:25 <dons> extra/tomboy 0.10.1-1 (gnome-extra) Desktop note-taking application for Linux and Unix
13:35:28 <dons> ?
13:35:33 * dons tries
13:35:44 <dons> patricia tries
13:35:45 <dons> hehe
13:35:46 <shapr> haha
13:36:37 <newsham> mac comes with a post-it program
13:36:43 <newsham> for leaving little yellow notes on your screen
13:36:51 <TomMD> I'd pay not to have that.
13:37:12 <newsham> you can probably rm it for free :)
13:37:34 <shapr> dons: Hm, I could get a gtk app working on win32 also...
13:37:39 * dons tries xpad
13:37:48 <dons> these things degenerate into text editors
13:37:56 <dons> but the key is to have a structured tree editor, i think.
13:38:02 <dons> with a super simple interface.
13:38:10 <shapr> Yup
13:38:19 <shapr> So maybe malcolm's widget?
13:38:26 <TomMD> Yellow sticky notes in my world: "Tom: That one piece of code broke.  While your fixing it could you make it parallel?  Oh, and land three more contracts while your at it - thanks!" -Management
13:38:39 <shapr> Sounds like my job...
13:38:40 <dons> heh
13:38:50 <adam> TomMD: I fail to see the problem.
13:38:52 <dons> this "could you make it parallel" is becoming more common
13:39:01 <shapr> You get requirements at the beginning of a cycle, in the middle of a cycle, and at the end. But that's not all the requirements!
13:39:13 <TomMD> adam: Now imagine you have a notes program on your computer so management can put them up without having to physically walk over...
13:39:26 <dons> heh
13:39:28 <dons> efficiency!
13:39:30 <shapr> I was recently castigated for doing a task exactly to the spec, rather than reading my client's mind.
13:39:37 <adam> TomMD: programs accidentally crash all the time. it's funny.
13:39:40 <TomMD> Efficiency begets waste.
13:39:54 <TomMD> adam: I keep telling people that about e-mails.
13:40:03 <dons> TomMD: never mind. soon you'll be a phd student, and no one will ask you to do anything!
13:40:08 <byorgey> hey, this tree-splitting thing sounds fantastic.  I've been using rememberthemilk.com, which works great EXCEPT for the fact that I can't split a todo item into sub-items.
13:40:12 <ozy`> TomMD: no, they have to physically access the computer to write the note
13:40:17 <TomMD> dons: I find that hard to believe.  Let me check.
13:40:24 <adam> dons: hah!
13:40:25 <TomMD> byorgey: does no one tell you to do anything?
13:40:31 <newsham> tommd: "sure, i'll fix bug #1 and add parallelism, will be done in 3mos."
13:40:46 <adam> OK, newbie alert, I have a question about a toy implementation of a factoring algorithm. my code is:
13:40:47 <adam> factor i | i == 1 = []
13:40:47 <adam>          | otherwise = [f] ++ factor (i / f) where f = ld i
13:40:52 <TomMD> newsham: Do you contract? ;-)
13:40:52 <dons> TomMD: well, maybe "teach these people recursion"
13:41:04 <newsham> tommd: i mean, thats the kinda response you should give.
13:41:13 <byorgey> TomMD: actually, no!  lots of people off-handedly suggest things I might like to do but which I am not required to do, however
13:41:16 <newsham> i dont currently contract, except through my employer (consulting firm)
13:41:18 <dibblego> adam, forall x. s/[x] ++/x:
13:41:18 <adam> the thing is, `factor (i / f)` is always an Int, because f is the smallest integer divisor of i.
13:41:24 <byorgey> like attend class, read this paper, ...
13:41:33 <adam> dibblego: I'm trying to understand this :)
13:41:41 <byorgey> =)
13:41:49 <adam> what I don't understand is, why does GHC complain?
13:41:50 <dons> do you use rememberthemilk?
13:41:52 <dibblego> adam, it is simpler, yet equivalent code, so it may help you understand
13:42:02 <adam> "No instance for (Fractional Int)"
13:42:06 <newsham> adam: do you want "div" instead of "/" ?
13:42:08 <dons> i / f
13:42:14 <newsham> > 5 `div` 3
13:42:15 <lambdabot>   1
13:42:19 <dons> > 5 / 3
13:42:20 <lambdabot>   1.6666666666666667
13:42:28 <TomMD> black magic!
13:42:30 <adam> dons: right, but as noted above, f _always_ divides i.
13:42:40 <adam> because f is defined to be the least divisor of i.
13:42:40 <dons> so use `div` :)
13:42:43 <newsham> div will work on Int -> Int -> Int
13:42:47 <adam> I see
13:42:57 <dons> its that you're using floating point division, but have constrained it to Int elsewhere
13:42:57 <adam> so you mean to tell me, I as a programmer know that, but the compiler can't?
13:43:02 <newsham> (/) wants some fractional type
13:43:03 <shapr> byorgey: So I'm thinking it should be called OmegaTodo
13:43:08 <shapr> Or YTodo
13:43:09 <dons> (/) and div are different operatoins.
13:43:14 <dons> :t (/)
13:43:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:43:16 <dons> :t div
13:43:17 <lambdabot> forall a. (Integral a) => a -> a -> a
13:43:19 * shapr grins
13:43:28 <newsham> you can use (/), but you'll have to add in type conversion operations
13:43:29 <byorgey> shapr: hehe, nice
13:43:47 <newsham> you as a programmer know a lot of things that the compiler doesnt.
13:43:54 <dons> also, using list concatenation will slow things down a lot
13:44:03 <a-s> Where can I find a minimal construction of a haskell system?
13:44:03 <adam> dons: OK, so the compiler barfs because `x / y` _could in certain situations_ lead to a fraction, even though I can easily prove that it would never do that in the above application.
13:44:12 <dons> adam: right.
13:44:16 <dons> it just looks at your types.
13:44:19 <adam> newsham: how would that type conversion go?
13:44:22 <TomMD> When I first started I wondered why (/) wasn't in a higher level typeclass. I guess I still wonder why it isn't "more polymorphic"
13:44:29 <dons> you've give it Ints, but used them with fractional functions.
13:44:39 <dons> and haskell doesn't magically coerce -- too many bugs lie down that path.
13:44:46 <newsham> > floor (fromIntegral (5 :: Int) / fromIntegral (3 :: Int))
13:44:46 <adam> dons: would it be useful to write a compiler that would try to infer that in this situation, `i / f` should always be an int?
13:44:48 <lambdabot>   1
13:44:56 <dons> adam: it'd be a theorem prover
13:44:57 <adam> newsham: cool.
13:45:10 <dons> since it would have to think about your algorithm to work that out.
13:45:10 <newsham> fromIntegral can convert to Float (for example), and floor can convert back to Int
13:45:28 <adam> dons: OK, feel free to suggest an alternative to the list concatenation there
13:45:36 <dons> yep...
13:45:42 <TomMD> I seem to remember a wiki about the multitudes of rounding functions.
13:45:46 <newsham> a-s: as in a minimal version of haskell written in haskell?
13:46:06 <adam> dons: also, is there no interest in combining theorem-prover features in a compiler?
13:46:24 <adam> which would solve a problem like in the example above.
13:46:34 <newsham> the type checker is a theorem prover.
13:46:47 <adam> hm, well, right.
13:46:55 <TomMD> As is "Static Contract Checking"
13:47:00 <dons> adam, there's interest. it is just hard :)
13:47:04 <newsham> I think you are confused as to why "/" doesnt work for you.
13:47:06 <dons> like NP hard.
13:47:07 <TomMD> Which might be in GHC 6.12, if that's what its called.
13:47:09 <adam> you could probably do operator overloading if you had that.
13:47:16 <dons> GHC 6.12 is getting close
13:47:18 <adam> newsham: nah, I figured it out.
13:47:26 <newsham> it has nothing to do with the fact that the compiler knows or doesnt know that one number perfectly divides another
13:47:39 <dons> where's your f = ld i defined?
13:47:41 <dons> the 'ld'
13:47:48 <adam> newsham: I understand that, but if you had that feature, you could overload /
13:47:52 <newsham> it has to do with the fact that (/) is defined to work (for example) on Float -> Float -> Float,  and div works (for example) on Int -> Int -> Int
13:48:03 <newsham> (/) is already overloaded
13:48:05 <newsham> ?type (/)
13:48:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:48:09 <adam> dons: in the same file; it returns the least divisor of i
13:48:10 <newsham> it works for all Fractional types
13:48:18 <dons> oh, lcd
13:48:20 <dons> > lcd 8
13:48:21 <lambdabot>   mueval: Prelude.read: no parse
13:48:31 <dons> oh, i thought we had an lcd
13:48:37 <adam> haha
13:48:41 <dons> > gcd 8 4
13:48:42 <lambdabot>   4
13:48:50 <tristes_tigres> > lsd
13:48:51 <lambdabot>   mueval: Prelude.read: no parse
13:49:06 <tristes_tigres> @vixen lcd
13:49:06 <newsham> ?type lcm
13:49:07 <lambdabot> forall a. (Integral a) => a -> a -> a
13:49:07 <lambdabot> tell me a joke.. I like men that makes me laugh
13:49:14 <dons> > lcm 8 4
13:49:15 <lambdabot>   8
13:49:37 <dons> > lcm 4 8
13:49:38 <lambdabot>  Terminated
13:49:43 <dons> > lcm 4 8
13:49:45 <lambdabot>   8
13:49:45 <adam> OK, I'll be back with more newbish questions later, so stay tuned
13:49:47 <dmwit> > 8 * 4 `div` gcd 8 4
13:49:49 <lambdabot>   8
13:49:55 <dmwit> ?src lcm
13:49:55 <lambdabot> lcm _ 0     =  0
13:49:55 <lambdabot> lcm 0 _     =  0
13:49:55 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
13:50:01 <adam> thanks dons, newsham, dibblego
13:50:05 <dmwit> quot, eh?
13:50:09 <dmwit> > lcm (-4) 8
13:50:11 <lambdabot>   8
13:50:21 <dmwit> quot... and then abs
13:50:32 <dmwit> ah
13:50:44 <dons> adam: accumulator passing style, http://hpaste.org/10353
13:50:51 <dons> much more efficient code
13:51:17 <dons> rather than using the stack and O(n) list appends, you just push onto an explicit stack
13:51:28 <adam> dons: cool, reading it now.
13:53:07 <scorch_> Saizan: about the thing I asked before; I've tried to find documentation and examples on unfoldr, but can't seem to find anything that's useful, and I've no idea how to solve it using unfoldr and splitAt...
13:53:25 <Saizan> ?type unfoldr
13:53:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:53:45 <dons> scorch_: so you use unfold whenever you have a single reduced value that you use as a seed to generate a more complex data structure
13:53:46 <scorch_> I've read it, but I don't understand it
13:53:48 <dons> unfolds are everywhere.
13:54:04 <dons> a lot of map/reduce algos are actually unfold >> fold
13:54:05 <dmwit> Yet Another Chunk implementation?
13:54:14 <dons> a lot of map/reduce algos are actually unfold >>= map >>= fold
13:54:21 <Saizan> > unfoldr (\xs -> if null xs then Nothing else Just $ splitAt 3 xs) [1..10]
13:54:22 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
13:55:10 <dons> shapr: http://toothpastefordinner.com/091308/more-than-three.gif
13:55:10 <scorch_> Saizan: why is the Just and Nothing needed?
13:55:20 <dmwit> > let ensure p x = guard (p x) >> return x in unfoldr (ensure (not . null . snd) . splitAt 3) [1..10]
13:55:22 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
13:55:25 <dons> scorch_: to terminate the unfold
13:55:32 <dons> otherwise it unfolds forever
13:55:37 <dmwit> > let ensure p x = guard (p x) >> return x in unfoldr (ensure (not . null . fst) . splitAt 3) [1..10]
13:55:38 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
13:55:48 <Saizan> scorch_: because you return Nothing when you've decided your list ends there
13:55:49 * RayNbow once used unfoldTree, unfoldr and partition to build a tree of circles
13:56:42 <RayNbow> unfolding = serious business :p
13:56:54 <Saizan> ?src unfoldr
13:56:54 <lambdabot> unfoldr f b  = case f b of
13:56:54 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
13:56:54 <lambdabot>    Nothing        -> []
13:57:27 <dons> unfoldr is beautiful.
13:57:38 <tristes_tigres> @vixen fold
13:57:38 <lambdabot> you're turning me on :)
13:57:39 <RayNbow> dons: do we have an unfold lambdacat?
13:57:45 <newsham> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
13:57:48 <lambdabot>  Defined.
13:57:59 <newsham> > unfoldUntil null (splitAt 5) "this is a test lalala"
13:58:00 <lambdabot>   ["this ","is a ","test ","lalal","a"]
13:58:27 <scorch_> what does Just do?
13:58:42 <newsham> data Maybe a = Nothing | Just a
13:58:49 <newsham> its a constructor for the Maybe type
13:59:17 <RayNbow> scorch_: the function used for unfolding should either return a new value+new seed or nothing
13:59:35 <dmwit> newsham: pretty =)
13:59:58 <newsham> dmwit: its undergone a few iterations of cleanup.  i use it often.  very nifty tool
14:00:19 <newsham> unfoldr is a neat tool, but too cumbersome to use directly
14:01:14 <scorch_> newsham: ah
14:01:34 <scorch_> thanks all for the help. :)
14:01:41 <RayNbow> newsham: the use of guard and return is nice :)
14:02:07 * tristes_tigres thinks the whole business with Haskell constructor is so simple, that no one understands it at first 
14:02:23 <dons> tristes_tigres: yeah, are data structures meant to be that easy? :)
14:02:25 <newsham> my earlier formulation was using   guarded f p x = guard (p x) >> return (f x)
14:02:38 <RayNbow> @karma newsham
14:02:38 <lambdabot> newsham has a karma of 0
14:02:43 <RayNbow> newsham++
14:02:49 <RayNbow> @karma newsham
14:02:49 <lambdabot> newsham has a karma of 1
14:03:00 <tristes_tigres> dons: it's sort of zen thing, you know ?
14:03:21 <tristes_tigres> int-e++
14:04:34 <RayNbow> @pl unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
14:04:34 <lambdabot> unfoldUntil = (unfoldr .) . (. (return .)) . liftM2 ((>>) . guard . not)
14:04:36 <newsham> i think someone else had suggested using "guard" to me.
14:05:20 <Myoma> :t (unfoldr .) . (. (return .)) .
14:05:21 <lambdabot> parse error (possibly incorrect indentation)
14:05:24 <Myoma> :t ((unfoldr .) . (. (return .)) . )
14:05:25 <lambdabot>     The operator `.' [infixr 9] of a section
14:05:25 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
14:05:25 <lambdabot>         in the section: `((unfoldr .) . (. (return .)) .)'
14:05:37 <Myoma> :t (((unfoldr .) . (. (return .))) .)
14:05:39 <lambdabot> forall b a b1 (m :: * -> *) a1 a2. (Monad m) => (a2 -> (a1 -> m b1) -> b -> Maybe (a, b)) -> a2 -> (a1 -> b1) -> b -> [a]
14:05:57 <tristes_tigres> Myoma: this is just sick? to wire code like that
14:06:24 <Myoma> :t ((.(.)).)
14:06:25 <lambdabot> forall c b c1 a a1. (a1 -> ((a -> b) -> a -> c1) -> c) -> a1 -> (b -> c1) -> c
14:10:05 * FunctorSalad still finds the interplay of currying and composition confusing...
14:12:48 <kenny__> hi, im using happy for parsing and when running: happy file.y  I get a "unused terminal:32", can someone give me an explanation on what this message means ?
14:13:04 <kenny__> "unused terminals: 32"
14:13:22 <FunctorSalad> in exponential notation the visual cues are a bit better: f :: A -> B, so "f^D :: A^D -> B^D"
14:13:47 <znutar> kenny__: Sounds like your grammar has a bunch of tokens defined that aren't used in the grammar
14:14:20 <FunctorSalad> or externally, "Mor(D,f) :: Mor(D,A) -> Mor(D,B)"
14:16:55 <FunctorSalad> let (‚Üí) _ f x = f . x
14:16:57 <FunctorSalad> > let (‚Üí) _ f x = f . x
14:16:58 <lambdabot>   mueval: Prelude.read: no parse
14:17:12 <FunctorSalad> hmm?
14:17:21 <dmwit> Needs an in clause.
14:17:44 <dmwit> > let (‚Üí) _ f x = f . x in 3
14:17:45 <lambdabot>   mueval: Prelude.read: no parse
14:17:52 <FunctorSalad> dmwit: I thought lambdabot had "let" as in ghci
14:17:59 <dmwit> FunctorSalad: Yes, via ?let
14:18:04 <FunctorSalad> ahhh
14:19:22 <FunctorSalad> but it seems like it doesn't like utf-8 on irc...
14:19:51 <FunctorSalad> > let (Œ±) = 3 in Œ±
14:19:52 <lambdabot>   3
14:20:01 <FunctorSalad> ...
14:20:44 <seydar> Twey: could strings be seen as an analogy for monads?
14:21:18 <Twey> Uh
14:21:23 <Twey> Well, they kind of are monads.
14:21:41 <Twey> type String = [Char], and [] is a monad :)
14:24:29 <FunctorSalad> > "abcdef" >>= ord
14:24:31 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Int'
14:24:45 <FunctorSalad> @type ord
14:24:46 <lambdabot> Char -> Int
14:25:00 <FunctorSalad> > "abcdef" >>= (return.ord)
14:25:01 <lambdabot>   [97,98,99,100,101,102]
14:26:01 <seydar> FunctorSalad: why did you need to do (return.ord)?
14:26:26 <byorgey> > (++ "!!") . (>> "AA") $ "Hello world !"
14:26:27 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAA!!"
14:26:48 <Twey> Because ord :: Char -> Int, and >>= needs a (a -> m b) on the right-hand side
14:26:54 <FunctorSalad> seydar: (>>=) requires the function on the right to return a monadic value, but "ord" returns a pure value, so I have to forget that it's pure
14:27:17 <seydar> oh, gotcha
14:27:28 <seydar> wow, that actually made sense
14:27:29 <byorgey> of course, for the list monad,  lst >>= (return.foo)  is just the same as  map foo lst
14:27:35 <Deewiant> > ord `liftM` "abcdef"
14:27:36 <FunctorSalad> > liftM ord "abcdef"  -- this is the abbrevation
14:27:36 <lambdabot>   [97,98,99,100,101,102]
14:27:37 <lambdabot>   [97,98,99,100,101,102]
14:27:37 * Twey nods.
14:27:44 <Deewiant> FunctorSalad: :-)
14:27:48 <FunctorSalad> ;-)
14:27:51 <Twey> Heh
14:27:52 <Baughn> "18961 svein     20   0 2155m 2.0g  10m S   88 68.5 948:01.24 lambdabot" <-- *scream*
14:27:55 <seydar> this is so awesome!
14:28:08 <Twey> Baughn: Cripes!
14:28:25 <kenny__> znutar: hmm thx.
14:29:08 <Baughn> Twey: I.. I think it may be leaking
14:29:46 <Twey> Baughn: I think it may.  Just a little.  :)
14:30:18 <seydar> there should be a tool called 'bail'
14:30:29 <seydar> where you can just take a bunch of memory from a program
14:30:33 <seydar> and see what the program does
14:30:36 <FunctorSalad> maybe we could add "((>>=) f) is like defining a linear map on a basis (f is that definition) and then extending it to the whole vector space" for those who're familiar with linear alg
14:30:44 <Baughn> seydar: Take it, and do what? Put into swap?
14:30:48 <FunctorSalad> add to the list of monad tutorials, that is ;-)
14:30:56 <seydar> Baughn: just take it from the program.
14:31:12 <Baughn> seydar: What, just drop it on the floor?
14:31:13 <seydar> Baughn: its like "bad program", and you take some candy from the greedy bastard
14:31:17 <Baughn> I think I know what it'll do. Crash.
14:31:26 <seydar> yea, but what if it doesn't?
14:31:32 <Baughn> It will
14:31:36 <seydar> it's missing half of its info, but it manages to keep going
14:31:40 <ben_m> Is there a difference between 'foo :: (Integral a) -> a -> a' and 'foo :: Integer -> Integer' ?
14:31:52 <ben_m> Make that => in the first example.
14:32:03 * Twey laughs.
14:32:10 <Twey> ben_m: Yes
14:32:32 <Twey> The latter only works with Integers, the former will work with anything that implements Integral
14:32:36 <ben_m> Don't laugh, I'm new to Haskell :/
14:32:43 <Twey> Sorry, wasn't laughing at you
14:32:49 <xerox> ben_m: do :info Integral in ghci to check out the imported instances
14:32:50 <Baughn> @instances Integral
14:32:51 <ben_m> Uh, what else but Integer implements Integral?
14:32:51 <lambdabot> Int, Integer
14:32:53 <Twey> The RAM discussion above :)
14:32:57 <ben_m> Ah.
14:33:00 <Twey> ben_m: Int, apparently
14:33:00 <Baughn> ben_m: Well, lots of things. ;)
14:33:00 <int-e> ben_m: Int, Word, Int8, Word8, ...
14:33:01 <ben_m> Thanks :)
14:33:05 <Baughn> @instances-importing Data.Word Integral
14:33:06 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
14:33:08 <Twey> ben_m: Plus anything else you want to make an instance.
14:33:16 <ben_m> Ok, thanks.
14:33:18 <Baughn> ben_m: Like my Word128 type
14:33:24 <seydar> Twey, do you live here?
14:33:29 <Twey> seydar: Pretty much :-P
14:33:33 <Baughn> Really nice being able to make my own integer types
14:33:45 <int-e> ben_m: in principle, polynomials can implement integral.
14:33:51 <Twey> I heard there's a String class a-comin'.
14:33:59 <seydar> ok, enough brain work for today
14:34:03 <seydar> adios everyone
14:34:08 <FunctorSalad> int-e: but in practice it's a bad idea for some reason? ;-)
14:34:11 <tristes_tigres> anyone heard when ghc 6.9 coming out ?
14:34:23 <Baughn> tristes_tigres: It won't. 6.10 will come out
14:34:38 <Baughn> 6.9 is the development branch - odd/even, like linux used to use
14:34:58 <tristes_tigres> Baughn: thanks, and what about 6.10  &
14:35:38 <Baughn> tristes_tigres: When it's done
14:35:40 <int-e> FunctorSalad: you get into trouble with the Ord instance that Real requires, and with signum and abs in the Num class.
14:35:59 <Baughn> tristes_tigres: Actually, real soon now. :)
14:36:00 <int-e> and of course, with toInteger :)
14:36:39 <Baughn> tristes_tigres: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases <-- In fact, see this
14:36:40 <lambdabot> Title: Status/Releases - GHC - Trac
14:36:54 <FunctorSalad> int-e: huh, is every Num a Real?
14:36:54 <tristes_tigres> Baughn : I hear that it's going to write the Haskell code itself using built-in AI engine ?
14:37:02 <tristes_tigres> Baughn: ok, thanks
14:37:03 <int-e> FunctorSalad: no, but every Integral is.
14:37:42 <mancalledhash> hi, has anyone here ever used HSLUA?
14:37:54 <FunctorSalad> int-e: I see...
14:38:00 <Baughn> tristes_tigres: No, but exceptions seem to be just about fixed
14:38:15 <Baughn> It's really getting good enough for serious work now
14:38:29 <Baughn> (Not that it wasn't, but not having to reinvent the wheel quite as much helps. :)
14:39:03 <Baughn> Oh, and shared libraries! Yay!
14:39:24 <Baughn> Ah, and rewriting haskell code using a built-in AI engine
14:39:38 <adam> in type notation, the way to denote a list of arbitrary types is [a], correct?
14:39:45 <Baughn> Yes
14:39:53 <adam> and there for, a list of lists of arbitrary types would be [[a]]?
14:39:58 <Baughn> Ayup
14:40:03 <adam> thank you.
14:40:18 <Baughn> Or [[bar]], whatever. Anything that starts with lowercase will do
14:41:23 <FunctorSalad> that way they must all be the same though... if you want heterogenous lists you can use existentials
14:41:36 <FunctorSalad> (they=the types)
14:44:24 <Baughn> Kinda. Right now, you /can't/ have heterogenous lists
14:44:41 <Baughn> You can certainly have homogenous ones whose single type happens to be using existentials internally, though
14:45:52 <mancalledhash> can someone tell me what this error means:  Not in scope: 'lua.dostring'
14:45:54 <Saizan> "right now"?
14:46:03 <thoughtpolice> existentials make for a good hiding place
14:46:13 <thoughtpolice> mancalledhash: are you importing qualified (hslua I'm betting)?
14:46:35 <mancalledhash> police I am using the example from the website
14:46:38 <mancalledhash> and it is not working :(
14:46:39 <thoughtpolice> all it means is it can't find that particular function, i.e. if you do 'import qualified Language.Lua as Lua' then you need 'Lua.dostring'
14:46:44 <chrisdone> is the module category Lang.Foo or Language.Foo?
14:47:02 <Saizan> Language
14:47:09 <chrisdone> thanks
14:47:27 <mancalledhash> I have to find Lua.Dostring?
14:47:32 <tristes_tigres> thoughtpolice: existentials a hiding place ? Camus would 've been ashamed of you
14:48:10 <thoughtpolice> ;]
14:48:44 <thoughtpolice> mancalledhash: no, Lua.dostring - the qualified import name is uppercase, function name starts lowercase
14:48:51 <thoughtpolice> it would be best to paste the code - http://hpaste.org
14:48:52 <mancalledhash> OH
14:48:57 <mancalledhash> I did lol
14:48:58 <thoughtpolice> unless that fixes it
14:49:01 <mancalledhash> THANKS :)
14:49:16 <mancalledhash> lowercase error oh my GOD
14:49:18 <tristes_tigres> Baughn: read a list of new stuff in 6.10, pretty impressive
14:49:50 <thoughtpolice> tristes_tigres: read it off hackage? a few things might not make it in
14:49:54 <thoughtpolice> but it's damn nice
14:49:58 <thoughtpolice> er, s/hackage/ghc trac/
14:50:02 <Baughn> thoughtpolice: Which things?
14:50:11 <Baughn> They /will/ fix the text i/o code, right? *Right*?
14:50:14 <thoughtpolice> Baughn: the new codegen won't make it in for one
14:50:26 <thoughtpolice> the build system is going under major overhaul for 6.12 anyway
14:50:39 <Baughn> New codegen..?
14:50:42 <thoughtpolice> and john's work will help to make ghc a cross compiler, so it's being put off till then
14:50:42 <Baughn> I don't see that on hackage
14:51:03 <thoughtpolice> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/NewCodeGen
14:51:06 <lambdabot> Title: Commentary/Compiler/NewCodeGen - GHC - Trac, http://tinyurl.com/63hck7
14:51:20 <Baughn> thoughtpolice: No, I was looking at http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
14:51:20 <thoughtpolice> also not sure about shared library support
14:51:22 <lambdabot> Title: Status/Releases - GHC - Trac
14:51:33 <thoughtpolice> right - it's in "things we plan to do for sure"
14:51:45 <thoughtpolice> john dias's backend revamp
14:51:53 <Baughn> Oh
14:51:53 <a-s> newsham: sorry, I was out.
14:52:05 <thoughtpolice> manual threw the new type constraints solver in a few days ago but it's not active yet iirc
14:52:08 <thoughtpolice> so that's done
14:52:11 <Baughn> But no shared libraries? That's a pity; I'm blocking some of my own work on that, waiting for it to get in
14:52:11 <thoughtpolice> (i think)
14:52:22 <a-s> No, I want to know how can we build a minimal haskell system
14:52:33 <thoughtpolice> Baughn: i've only heard a few things about it from simonm - it'd be better to ask him
14:52:35 <FunctorSalad> can't I pattern match partially applied constructors?
14:52:40 <newsham> a-s: like, what programs to install?
14:52:53 <Baughn> FunctorSalad: Sorry
14:53:00 <a-s> newsham: no, How to write a minimal haskell system
14:53:05 <FunctorSalad> (oh well, I can just fill them up with an undefined, right?)
14:53:08 <newsham> i dont understand your question
14:53:14 <thoughtpolice> Baughn: i remember when I just started learning haskell I managed to get C to load foreign haskell shared objects
14:53:16 <Baughn> FunctorSalad: Hang on, constructors of /what/? Actually, I do believe you can
14:53:19 <thoughtpolice> it was the most amazing hack ever
14:53:27 <Baughn> If you mean pattern-matching on just some of the record fields
14:53:27 <FunctorSalad> Baughn: of a data
14:53:29 <newsham> tp: you're alive.  congrats.
14:53:32 <thoughtpolice> FunctorSalad: I think datatype constructors have to be fully saturated in their arguments
14:53:34 <thoughtpolice> newsham: ty
14:53:36 <a-s> for example, to write a minimal lisp syste, it takes 2 pages of lisp, or 10K of C code
14:53:46 <FunctorSalad> thoughtpolice: for pattern matching or always?
14:53:54 <thoughtpolice> iirc, yes
14:54:00 <newsham> so you want to know how to write a haskell interpretter?
14:54:19 <newsham> the execution model is fairly simple.. its just non-strict lambda calculus evaluator.
14:54:20 <Baughn> FunctorSalad: You must match all the record elements, but there are syntactic extensions in ghc to help with that
14:54:33 <newsham> if you want to do a parser, and all the syntactic sugar, thats more work
14:54:55 <thoughtpolice> you can probably get an evaluator for something like core up in not much code
14:55:12 <Saizan> FunctorSalad: until you saturate the constructor you've something of type (a -> b) for some a and b, and you can't pattern match on that
14:55:14 <a-s> I will go
14:55:23 <a-s> see you soon
14:55:28 <FunctorSalad> Saizan: yeah
14:55:35 <tromp> see http://www.haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf
14:55:36 <lambdabot> Title: The Monad.Reader Issue 10
14:55:39 <FunctorSalad> so can I plugin "undefined"?
14:55:44 <thoughtpolice> newsham: the storm wasn't that bad, i actually got bored and went to sleep before the biggest part of it hit
14:55:52 <tromp> "Evaluating Haskell in Haskell"
14:55:52 <newsham> a-s: for example, here's a small interpretter for a lazy lambda calc language.  http://www.thenewsh.com/~newsham/x/obf.py
14:55:54 <Baughn> FunctorSalad: I don't quite remember, but something like "foo (Bar {x = 2, y = 4}) = baz" or some such?
14:56:14 <tristes_tigres> thoughtpolice: you in Texas ?
14:56:17 <thoughtpolice> resulting damage here around the uni: lots of tree branches and tree debris everywhere
14:56:22 <Baughn> FunctorSalad: That is, with named fields
14:56:24 <FunctorSalad> Baughn: hmm, for that I need to already have a fully applied constructor I think
14:56:26 <thoughtpolice> nothing else
14:56:28 <thoughtpolice> tristes_tigres: yes
14:56:30 <mancalledhash> I copied the first example from: http://haskell.org/haskellwiki/HsLua   and it still give me that out of scope errors.  I have installed the package and everything.
14:56:31 <lambdabot> Title: HsLua - HaskellWiki
14:56:31 <Baughn> FunctorSalad: Oh, and you can plugin _, not undefined
14:56:38 <Saizan> FunctorSalad: you can, but if you have strictness annotations in the data declaration it will become _|_
14:56:43 <Baughn> FunctorSalad: Use undefined, and it'll actually try to /match/. Which will throw an exception.
14:56:53 <Baughn> Well, unless you use an irrefutable pattern, I guess..
14:57:03 <tristes_tigres> thoughtpolice: so how many shotguns you keep in your pickup truck ? :-)
14:57:04 <FunctorSalad> Baughn: even if I use _ in the pattern match at the position of the undefined?
14:57:21 <Baughn> FunctorSalad: Er..
14:57:22 <FunctorSalad> yeah, I'm going to use a irrefutable
14:57:35 <Saizan> > case Just undefined of Just _ -> "just!"
14:57:37 <lambdabot>   "just!"
14:57:51 <FunctorSalad> Saizan: yeah I should just have tried it out ;-)
14:57:52 <ddelony> I've been playing around with Haskeel off and on. I think it's a neat language.
14:57:52 <Baughn> FunctorSalad: What I meant was, "foo (Bar 1 _ _) = ..." is okay, "foo (Bar 1 undefined undefined)" is not, even if the latter might work with irrefutables
14:58:21 <ddelony> My programming skill is "I don't know much, but I know what I like." :-)
14:58:26 <Saizan> Baughn: undefined there would just be a variable :)
14:58:44 <Baughn> Hmm, that's right
14:58:57 * Baughn sweatdrops. That would work too, except it's in twice.
14:59:04 <Saizan> yup
14:59:17 <ddelony> Hmmm, does anyone have experience using Haskell in game development?
14:59:26 <Baughn> ddelony: Sure
14:59:57 <thoughtpolice> mancalledhash: that page seems to be outdated then
15:00:05 <ddelony> Baughn: Good or bad experiences?
15:00:07 <thoughtpolice> you might have to piece some stuff together yourself
15:00:19 <Baughn> ddelony: Good. Very good.
15:00:21 <tristes_tigres> baughn: would it be fast enough for that ?
15:00:34 <thoughtpolice> tristes_tigres: 40, like everybody else here in dixie-land. :P
15:00:41 <thoughtpolice> i should say 40+
15:00:58 <tristes_tigres> thoughtpolice: /me feel envious
15:00:59 <Baughn> tristes_tigres: I'm happily multithreading /everything/. As I wouldn't be doing that in other languages, haskell is faster than those other languages.
15:01:08 <ddelony> Baughn: I wonder if lazy evaluation helps performance.
15:01:08 <Baughn> Never mind the scaling. :D
15:01:29 <Baughn> ddelony: Only when you use it to build algorithms that, otherwise, you wouldn't build
15:01:37 <Baughn> Which should be all the time
15:01:41 <thoughtpolice> ddelony: it can, and sometimes it can kick in the GC way more than necessary
15:01:52 <thoughtpolice> it's a double-edged thing but generally I've never had an issue with laziness
15:01:57 <thoughtpolice> then again I've never done game dev with haskell either
15:02:10 <thoughtpolice> take it as you wish
15:02:11 <tristes_tigres> baughn: how safe is that in terms of one of the threads dying ? Does it take down the whole house ?
15:02:12 <Baughn> I'm not really doing game dev right now, either. More of a tech demo.
15:02:27 <ddelony> I thought the explanation of functional programming by analogy with spreadsheets and SQL is interesting.
15:02:34 <mancalledhash> thanks thoughtpolice, I thought I was doing something wrong lol
15:02:35 <Baughn> I'm trying to make Spore look bad, letting you zoom /all/ the way in from a galactic overview. All the view. Right down to molecules. :P
15:02:49 <ddelony> I'm starting to think of Haskell programs as tables of values.
15:02:56 <thoughtpolice> mancalledhash: in particular dofile seems to be replaced with loadfile; you'll have to look for equivilents to e.g. dostring
15:03:07 <Baughn> ddelony: That's kind of backwards. It's more like spreadsheets and sql (sometimes) are limited examples of functional programming
15:03:31 <RayNbow> Excel lacks higher order function goodies
15:03:40 <thoughtpolice> mancalledhash: from my limited knowledge seems like 'callfunc' is what you want'
15:03:41 <Baughn> tristes_tigres: A thread dying? That would require some sever bugs in my code
15:03:44 <RayNbow> we need an Excel with HOFs! :p
15:03:59 <mancalledhash> THANKS, you gave me a starting point.  I almost gave up!
15:04:01 <tristes_tigres> baughn: your code has no bugs ?
15:04:14 <Heffalump> RayNbow: where I work, we've added them :-)
15:04:15 <ddelony> I know that one of the important steps in programming is representing programs in your head.
15:04:21 <RayNbow> Heffalump: really?
15:04:23 <Baughn> tristes_tigres: I'd like to think it's safe by construction. I haven't had much in the way of crashes - I've gone out of my way to make bugs show up in-game instead of actually /crashing/ it - but anything that escapes, I want to kill the program please.
15:04:41 <Heffalump> yep, really
15:05:16 <RayNbow> Heffalump: got any more info on it? (papers? blogposts? presentations?)
15:05:50 <Baughn> tristes_tigres: Though I suppose you /could/ have a program survive a thread dying.. eh, it wouldn't fit mine. Most of my threads are created through par, too.
15:06:19 <ddarius> SQL is closer to logic programming rather than functional programming.
15:06:58 <Heffalump> http://cufp.galois.com/2006/slides/HowardMansell.pdf - no technical details though
15:07:00 <lambdabot> Title: PowerPoint Presentation
15:07:06 <tristes_tigres> ddelony: sort of like a spreadheet where every cell could be spreadsheet ?
15:07:30 <Baughn> tristes_tigres: Haskell is like graph reduction. Start there
15:08:25 <tristes_tigres> Baughn: I could start there. but most people would go whaaa ?  Spreadsheet on the other hand is familiar to everybody
15:09:02 <Baughn> tristes_tigres: 's okay. I'm fine with keeping haskell as a secret weapon for the superior programming overclass.
15:09:14 <tristes_tigres> Baughn: DNRC ?
15:09:33 <ddelony> tristes_tigres: Interesting analogy.
15:09:36 <Baughn> tristes_tigres: EXPN?
15:09:47 <tristes_tigres> Baughn : Dogbet new ruling class
15:09:54 <tristes_tigres> dogbert
15:10:06 <Baughn> Nah. He's insufficiently technical.
15:10:30 <Baughn> The new world order will be ruled by.. dons.
15:12:06 <tristes_tigres> baughn: is haskell mulithreading oriented towrds this trend of mulitcore CPUs ?
15:12:19 <Baughn> tristes_tigres: Seems so. It certainly fits.
15:12:46 <xci> hey guys, yesterday I wrote a C primes sieve (void sieve(int until,int* out)) which I called from haskell with ffi, however, I faced a problem with the array size - I allocated memory for the output array in haskell, but when my C code finished calculating, it always had some extra space (you know, one cannot predict correctly how many primes will there be in a certain scope). I tried to realloc the pointer in C, but is obviously not the way to go and caused a crash
15:12:48 <RayNbow> Heffalump, is the work on Excel related to http://www.londonhug.net/2008/08/11/video-paradise-a-dsel-for-derivatives-pricing/ ?
15:12:54 <lambdabot> Title: Œªondon HUG ¬ª Blog Archive ¬ª Video: Paradise, a DSEL for Derivatives Pricing, http://tinyurl.com/6kmkek
15:13:38 <Baughn> xci: You're misunderstanding how realloc works, yes. It'll produce a /new/ array, then copy the contents of the old into the new one
15:13:39 <tristes_tigres> derivativePrice :: subPrimeMorgageBond -> Maybe Junk
15:13:42 <Baughn> And deallocate the old one
15:13:48 <Heffalump> RayNbow: kind of; Paradise is a sort of follow-on from that, where we actually generate a spreadsheet rather than programming in it directly.
15:14:02 <Heffalump> in both cases the spreadsheet uses HOFs though
15:14:07 <Baughn> xci: Probably you were freeing, or at least reading, the array in your haskell code. That makes it a double-free and/or reading unallocated memory..
15:14:09 <RayNbow> ah
15:14:33 <Baughn> xci: Anyhow, you're copying the data into some other structure on the haskell side, aren't you? In that case, why be in such a hurry to compact it?
15:14:56 <Heffalump> http://urchin.earth.li/~ganesh/icfp08.pdf is a paper (experience report) about Paradise that'll be at ICFP next week.
15:15:01 <lambdabot> Title: Paradise: A two-stage DSL embedded in Haskell
15:15:01 <tristes_tigres> Baughn: it does seem like programming a few thousand cores is going to take some big changes in thinking
15:15:01 <FunctorSalad> haskell syntax is fun =) a formula in the logic I'm coding now looks like "‚àÄ (\x -> meh x === blub x)", which is more or less zero overhead over the mathematical notation
15:15:12 <xci> Baughn: actually it packs it into a list and it is fine by me
15:15:48 <Baughn> xci: Packs it into a list, then presumably frees the array you were using - since you're allocating it in haskell, presumably via the GC.. er, how exactly are you allocating it?
15:16:08 <Baughn> xci: Anyway, sounds like there's just no reason to call realloc. If there /were/, then you should malloc the array on the C side to begin with.
15:16:26 <Japsu> Mui. xci
15:16:27 <xci> Baughn: yeah, I just was not sure if that can be done
15:16:32 <RayNbow> FunctorSalad: but how do you type the forall symbol? :p
15:16:32 <ez> FunctorSalad: try "‚àÄ $ \x -> meh x === blub x" for even less overhead, maybe.
15:17:00 <xci> Baughn: since it seemed a bit strange in the first place to control C's memory in haskell, why not let the C-code handle it by itself
15:17:04 <FunctorSalad> RayNbow: meta-x, set-input-method, TeX ;-)
15:17:16 <FunctorSalad> ez: :)
15:17:19 <xci> (this was just some random example on the internet I saw)
15:17:23 <xci> Mui. Japsu
15:17:30 <RayNbow> FunctorSalad: which editor? :p
15:17:36 <FunctorSalad> RayNbow: emacs
15:17:40 <RayNbow> Heffalump: thanks for the paper :)
15:17:42 <Baughn> xci: Well, you'll want to at least /free/ the memory on the haskell side, after you're done with it - right?
15:17:53 <FunctorSalad> then you can type "\forall", "\exists" etc.
15:17:59 <Baughn> xci: Or you could wrap it in an Array. there's a variant that specializes in wrapping C arrays, so..
15:18:04 <xci> Baughn: well, that is true
15:18:24 <FunctorSalad> mind you, only the syntax is from tex, it simply inserts unicode
15:18:31 <RayNbow> I wonder if there's a TeX IME for Windows...
15:18:54 <ben_m> How would I do this in Haskell? Loop from 1 to infinite, check for a condition and if the condition is met, print the current number and exit.
15:19:06 <ben_m> 'loop' :)
15:19:07 * RayNbow has currently only a JP IME installed
15:19:17 <Heffalump> print $ head $ filter cond [1..]
15:19:21 <xci> well, I guess I'll have to live with that - there are of course ways around this problem, maybe modify the function to return how many primes were returned and chop the remainder away in haskell-side or stuff like that
15:19:26 <ben_m> Thank you.
15:19:33 <xci> but I guess it is quite okay this way too
15:19:51 <Heffalump> you should try not to think so imperatively - "loop" and "exit"
15:20:00 <ben_m> I know, that's why I said 'loop'
15:20:16 <ben_m> I'm new to Haskell so I'm not used to how to do things that are simple in imperative languages.
15:20:17 <Heffalump> another way of looking at it is "print the first number between 1 and infinity that satisfies cond"
15:20:20 <ben_m> Love it thus far.
15:20:25 <ben_m> Yeah I know that.
15:20:25 <RayNbow> ben_m: you should escape the loop of imperative thinking ;)
15:20:26 <Heffalump> and that's exactly what my code is
15:21:03 <RayNbow> "you should break the loop of imperative thinking ;)" <-- replacing escape with break for more imperative reference :p
15:21:06 <RayNbow> *references
15:21:41 <FunctorSalad> \t\h\e\ \l\o\o ...
15:21:45 <ddelony> I'm not compeletely new to programming, but I've only written scripts in languages that start with "P".
15:23:11 <RayNbow> if you wrote scripts in Prolog, then you're pretty hardcore ;)
15:23:31 <xci> thinking of "erl" made me think of Perlang, which would at least be very hardcore if it existed :)
15:24:16 <RayNbow> xci: I don't want to think of the resulting syntax :p
15:24:31 <ddelony> RayNbow++
15:25:01 <ddelony> Prolog is a pretty neat language, though.
15:25:22 <xci> RayNbow: me neither :)
15:26:27 <|jedai|> P[ython|erl|rolog] others ?
15:26:31 <ddelony> I'm actually considering Haskell as a replacement for those other scripting languages.
15:26:43 <RayNbow> ddelony: Prolog traumatized many fellow students though when I had to take the course... :p
15:27:32 <RayNbow> but when I took another look at Prolog after 2 years had passed or something, it made more sense :)
15:27:33 <olsner> prolog <3
15:27:52 <ddelony> Of course, Lisp is king.
15:28:14 <|jedai|> PHP also, other languages starting by P ?
15:28:23 <RayNbow> Python
15:28:26 <RayNbow> oh wait
15:28:29 <RayNbow> you already mentioned that one
15:28:34 <TomMD> Yay, 5 patches left to darcs get.  Only 30 minutes!
15:28:55 <Vq^> Jedai: postscript :)
15:29:01 <xci> pascal :>
15:29:27 * RayNbow opens http://people.mandriva.com/~prigaux/language-study/diagram.png
15:29:40 <Vq^> PL/1
15:29:41 <Jedai> That's a bunch of real languages !! Is there something to the P letter ?? ^^
15:30:52 <Baughn> PIL
15:31:06 <Baughn> Parakeet
15:31:32 <RayNbow> http://esolangs.org/wiki/Language_list#P
15:31:34 <lambdabot> Title: Language list - Esolang
15:31:35 <Vq^> povray :)
15:31:36 <Jedai> Parrot
15:31:47 <Jedai> Well that's a VM so...
15:32:01 <Baughn> PARI/GP, Parser, Pawn, PBASIC, PCASTL, PEARL, PDL, Pico, Piet, Pike, PIKT, PILOT, Pizza...
15:32:33 <Baughn> http://en.wikipedia.org/wiki/List_of_programming_languages#P <-- I wonder if anyone has ever tried to learn them all
15:32:34 <lambdabot> Title: List of programming languages - Wikipedia, the free encyclopedia
15:32:36 <RayNbow> "PingPong manipulates the program flow control using a variety of operators which treat the IP as a ping-pong ball, which reflects off each flow control instruction at a 90-degree angle"
15:32:49 <Baughn> RayNbow: Hum. They stole that from an earlier language.
15:32:55 <RayNbow> yeah
15:33:04 <RayNbow> I can't remember the name of that one though :p
15:33:15 <Baughn> Although, the 90-degree-turn on /every/ flow control instruction is new
15:33:23 <Baughn> ..trivial to get around, but new
15:33:36 <ddarius> Logic programming is neat.  Prolog is a pretty hideous rendition of it.
15:33:54 <RayNbow> but the novelty of 2D-style languages starts to wear off...
15:34:11 <RayNbow> I wonder if anyone ever attempted to create a 3D (or higher) esolang
15:34:25 <Baughn> Oh, that's a good idea
15:34:32 <ddarius> RayNbow: There are arbitrarily high dimensional versions of Befunge
15:34:36 <Baughn> ..aww
15:35:03 <RayNbow> ah damn... :p
15:35:56 <fophillips> RayNbow: I have used a 4-dimensional language
15:36:16 <ben_m> Heffalump shouldn't it be last instead of head?
15:36:43 <Heffalump> ben_m: not if you want your program to ever terminate
15:36:51 <RayNbow> fophillips: which was? :)
15:36:53 <ben_m> That's why I'm wondering
15:37:00 <ben_m> But head would always be 1, wouldn't it?
15:37:06 <Heffalump> no, because filter comes first
15:37:11 <tristes_tigres> jedai: Piet http://en.wikipedia.org/wiki/Piet
15:37:12 <lambdabot> Title: Piet (programming language) - Wikipedia, the free encyclopedia
15:37:26 <ben_m> Oh, you're right.
15:37:50 <ben_m> I understand :)
15:38:15 <fophillips> RayNbow: 4DL
15:38:21 <ddarius> RayNbow, Baughn: If you want to make an esoteric language that might actually be useful, read up on some molecular biology and make a language that works like, say, combining amino acids.
15:38:35 <Baughn> ddarius: ...
15:38:43 <Baughn> You just want me to solve NP-complete problems in my compiler.
15:38:45 <pjdelport> chemputing
15:38:46 <ddarius> Incidentally, such a language would have a 3D working space.
15:38:51 <dons> aren't they just arbitrary term rewriting systems?
15:39:18 * dons wrote a polymer reaction simulator, it was all just term rewriting. lots of it.
15:39:34 <dons> i guess the control structures would have been a bit ... ad hoc?
15:39:56 <RayNbow> ddarius: my grades for biology in middle school went downwards after a short while... it's not something I'm good at ;)
15:40:19 <ddarius> Baughn: The trick is try to off-load the NP parts onto the programmer, just like we off-load the Turing-hard stuff onto the programmer in most programming languages.
15:40:29 <ddarius> RayNbow: Molecular biology /= biology
15:40:46 <Baughn> ddarius: Just because I can do turing-hard problems doesn't mean I can do np-complete ones
15:41:54 <RayNbow> ddarius: oh wait, molecular biology is more like chemistry then?
15:42:12 <ddarius> RayNbow: More like chemistry
15:44:51 <ddarius> RayNbow: You may want to look at amorphous computing for something related but much more abstracted than this particular view.
15:45:08 <tristes_tigres> sex ed DSL ?
15:47:33 <RayNbow> ddarius: I'll add the topic to my ever growing reading list :)
15:48:33 <ddelony> re: monads: MY BRAIN HURTS!!!
15:48:52 <TomMD> ddelony: At least you aren't alone!
15:49:09 <ushdf> > 1+2
15:49:11 <lambdabot>   3
15:49:13 <ddelony> Maybe I'm just missing some math background.
15:49:17 <ushdf> > lambdabot + ushdf
15:49:18 <lambdabot>   mueval: Prelude.read: no parse
15:49:24 <ushdf> >:OP
15:49:27 <TomMD> ddelony: Most people I talk to learn monads though learning to use various monads (such as the mtl).  Atleast, thats a good start.
15:49:48 <ushdf> i used xmonad for a while
15:49:54 <ushdf> then i found a reason to live
15:50:04 <ddelony> TomMD: Yeah, I find it easier to learn by looking at example code too.
15:50:09 <RayNbow> ddelony: changing things costs effort... the cost of changing the way you think is pain :p
15:50:27 <ushdf> functional programming and procedural programming all benefit from "rabbit hole"-type thought
15:50:48 <DanielPet> Is there a built in function that maps a function to array but which stops if it finds an non empty list. Like a foldl function that stops.
15:51:53 <TomMD> DanielPet: If your consumer stops on the condition then it won't matter if the mapping stopped thanks to lazy evaluation.
15:52:07 <TomMD> But to answer your question - no, I don't know of such a predefined function.
15:52:40 <RayNbow> > takeWhile (not . null) [[1,2,3], [4,5], [], [6,7]]
15:52:41 <lambdabot>   [[1,2,3],[4,5]]
15:53:04 <DanielPet> Thanks dude!
15:53:07 <RayNbow> oh wait
15:53:18 <RayNbow> should it stop if it finds a non-empty list or an empty list, DanielPet?
15:53:40 <RayNbow> (you originally said "non empty")
15:53:56 <DanielPet> it should stop if it find an non-empty list and return this non-empty list
15:54:27 <TomMD> Oh, I misunderstood.  (head . dropWhile cond) would do that, though its partial.
15:55:23 <DanielPet> Ill try to wrap my head around it. Thanks!
15:55:26 <TomMD> > head . dropWhile null $ [[], [], [1,2,3], [3,4,5]]
15:55:28 <lambdabot>   [1,2,3]
15:55:41 <olsner> *** Exception: main/InteractiveEval.hs:(184,13)-(188,46): Irrefutable pattern failed for pattern Data.Maybe.Just decl
15:55:47 <DanielPet> excellent
15:56:29 <luite> > find (not.null) [[],[], [1,2,3],[3,4,5]]
15:56:31 <lambdabot>   Just [1,2,3]
15:56:49 <TomMD> luite: yes, thanks.  Much better.
15:57:00 <TomMD> @hoogle find
15:57:01 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
15:57:03 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
15:57:05 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:57:08 <hackage> Uploaded to hackage: pandoc 1.0
15:57:39 * tristes_tigres would like a programming language where you program by building quircky towers from Lego 
15:57:58 <ushdf> i've been designing that for years
15:58:00 <ushdf> you stole my idea!
15:58:18 <tristes_tigres> ushdf: or by tying pieces of stirng !
15:58:19 <dons> aren't legos purely functional combinators? which you compose.
15:58:21 <dons> to build something.
15:58:26 <ushdf> that's great, isn't it?
15:58:27 <dons> but there aren't any higher order legos?
15:58:29 <tristes_tigres> colored ones
15:58:32 <ushdf> if you just had these little pieces of paper
15:58:35 <ushdf> that had function names on them
15:58:37 <RayNbow> > > fromMaybe [] $ find (not . null) [[],[], [1,2,3],[3,4,5]]
15:58:38 <lambdabot>   mueval: Prelude.read: no parse
15:58:47 <RayNbow> ah damn copy/paste
15:58:49 <RayNbow> > fromMaybe [] $ find (not . null) [[],[], [1,2,3],[3,4,5]]
15:58:50 <lambdabot>   [1,2,3]
15:58:55 <RayNbow> > fromMaybe [] $ find (not . null) [[],[]]
15:58:57 <lambdabot>   []
15:59:34 <tristes_tigres> what if you had a bunch of trained hamsters ? One picks non-empty box, other carries stuff in circle, a third dumps on the floor
15:59:45 <DanielPet> find wont work, the list Im working with takes a long time to calculate so I want a function that maps each value at the same time
15:59:45 <tristes_tigres> A language called Hamsters
16:03:17 <DanielPet> if I use map on an array, will the array be lazly evaluated, containing the function?
16:03:46 <TomMD> Yes
16:05:05 <DanielPet> so the array will be containing the functions?
16:05:30 <TomMD> > takeWhile (not . null) $ map (map (+1)) [ [1,2,3], [3,4,5], [], undefined ]
16:05:32 <lambdabot>   [[2,3,4],[4,5,6]]
16:05:43 <ddarius> DanielPet: Lists aren't arrays.
16:05:50 <SyntaxNinja> shapr: yeah, I was in boston but oh, so briefly.
16:05:55 <TomMD> DanielPet: No, the list will be of [a], but they are unevaluated thunks.
16:05:59 <SyntaxNinja> shapr: sorry I didn't call you. didn't really have any time for fun :(
16:06:15 <TomMD> DanielPet: You can make a list of functions.
16:06:39 <DanielPet> I see
16:06:49 <TomMD> map (\f -> f 1) [ (+2), (+3), (/ 4) . fromIntegral ]
16:06:56 <TomMD> > map (\f -> f 1) [ (+2), (+3) ]
16:06:58 <lambdabot>   [3,4]
16:07:27 <TomMD> @let funcList = [ (+2), (+3), (/ 4) . fromIntegral ] :: [Float -> Float]
16:07:28 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
16:07:33 <TomMD> hummm
16:08:20 <RayNbow> :t funcList
16:08:21 <lambdabot> Not in scope: `funcList'
16:08:26 <RayNbow> > funcList
16:08:27 <lambdabot>   mueval: Prelude.read: no parse
16:08:51 <xerox> > [(*2),(+10)] `ap` [1,2,3]
16:08:53 <lambdabot>   [2,4,6,11,12,13]
16:08:54 <DanielPet> so if I have a list of values and want to create a list of functions from it...
16:08:56 <Saizan> @let funcList = [ (+2), (+3), (/ 4) . fromIntegral ] :: [Float -> Float]
16:08:57 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
16:09:12 <TomMD> >  map (\f -> f 50)  [ (+2), (+3), (/ 4) ]
16:09:13 <lambdabot>   [52.0,53.0,12.5]
16:09:16 <TomMD> the point remains the same.
16:09:18 <xerox> (return a instead of [a,b,c] for a single param)
16:09:23 <TomMD> even when lambdabot is silly
16:10:04 <Saizan> ?ty [ (+2), (+3), (/ 4) . fromIntegral ] :: [Float -> Float]
16:10:05 <lambdabot>     No instance for (Integral Float)
16:10:05 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:22-33
16:10:05 <lambdabot>     Possible fix: add an instance declaration for (Integral Float)
16:10:38 <TomMD> :type (let valList = [1..5] in map (+) valList)
16:10:45 <TomMD> @type (let valList = [1..5] in map (+) valList)
16:10:47 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
16:11:08 <shapr> SyntaxNinja: No worries
16:11:17 <TomMD> DanielPet: Sure, lists can contain any type, see above for an example of converting a list of values to list of functions.
16:11:29 <DanielPet> I will! Thanks!
16:11:41 <shapr> dons: So, how many websites do I have?
16:14:48 <tristes_tigres> I was in boston. probably not again
16:15:06 <dons> shapr: hmm. a few :)
16:21:14 <subw_> hi, I have the following, kinda weird problem:
16:21:22 <subw_> I'm trying to write what is basically an imperative length function using IORefs.
16:21:33 <subw_> The thing is that I keep getting stack overflows for all lists that are longer than about 250000 items.
16:21:39 <subw_> My code is at http://hpaste.org/10355
16:23:43 <ddarius> subw_: Don't use modifyIORef
16:24:25 <DanielPet> What would you do if you had 3 values from the user, which is supplied at start,  and you don't want to send these values to every function as a parameter
16:24:51 <ddarius> modifyIORef' ref f = readIORef ref >>= \x -> writeIORef ref $! f x
16:25:06 <TomMD> DanielPet: Use the State monad?
16:26:22 <ddarius> TomMD: Why would you use a State monad if you are just passing the values around?
16:26:36 <RayNbow> ddarius: what's the problem with modifyIORef?
16:27:05 <RayNbow> (I have no experience with IORefs at all, but I'm interesting why they would cause stack overflows in subw_'s code example)
16:27:29 <RayNbow> *they -> modifyIORef
16:27:49 <subw_> ddarius: Your modifyIORef' works great! Thanks!
16:27:57 <TomMD> ddarius: I interpreted the question from DanielPet as a challenge to the IORef comment, so I just went with a pure alternative.
16:27:59 <DanielPet> But it doesn't need to change. It's still a constant.
16:28:22 <dons> modifyIORef should probably be strict by default. most of these modify functions get used on atomic element types.
16:28:23 <TomMD> DanielPet: The Reader monad is probably what you are looking for.
16:28:25 <dons> MVAr is similar.
16:28:44 <DanielPet> Ill check it out
16:28:46 <ddarius> RayNbow: Read 'Stack overflow' on the wiki.  It's the same concept just with a mutable variable instead of an accumulator parameter.
16:28:56 <TomMD> I've never used IORef, I always found that kind of funny.  MVar, STM, and Chans are all I ever need it seems.
16:29:19 <dons> yeah, makes more sense to use MVars --> like IORefs, but threadsafe.
16:29:40 <ddarius> TomMD: MVars are just IORefs for concurrent code.  If your code isn't actually concurrent, then you should not being using MVars but instead IORefs.
16:30:01 <TomMD> ddarius: I understand, but stick with my statement :-)
16:30:01 <dons> plan ahead :)
16:30:33 <ddarius> I don't think I've ever actually used STM for anything.
16:30:47 <TomMD> Oh, and I had fun benchmarking Chans not long ago - 700K write/read's a second.  Not bad.
16:31:01 <TomMD> I live and breath STM.
16:31:27 <dons> TomMD: with no modification?
16:31:34 <dons> just out of the box, carefully watching the strictness?
16:31:41 <TomMD> Nope, let me see if I have the program laying around.
16:31:59 <RayNbow> ddarius: ah right, it took some while to figure it out, but now I see the problem :)
16:32:01 <dons> i had a problem a couple of days ago that i suspect Chans are the cause of
16:34:12 <dons> i was thinking of crafting a lazy bytestring chan type
16:34:24 <shapr> bchan!
16:34:25 <dons> so you can have threads generating data, which is just read off without conversion
16:34:32 <dons> good for data generators, anyway
16:35:17 <ddarius> dons: There's needs to be an overhaul of the entire standard libraries making them have the reasonable strictness values by default.
16:35:36 <dons> ddarius: i agree. the atomic strictness, and specialisations, are all wack.
16:35:53 <dons> shapr: spent all day using Xpad 2.14
16:36:00 <dcoutts> make a library proposal
16:36:02 <TomMD> Gahh, got to take off.  dons, if you are curious I'll paste the producer consumer later, but it was a trivial 10 line thing.
16:36:02 <dons> pretty nice, though in the unstructured category
16:36:13 <dons> TomMD: ok. but it was just using standard Chan ?
16:43:00 <TomMD> dons: yes, it was using standard (Chan Int) write 1,000,000 ints and read them.
16:46:06 <TomMD> dons: I pasted it, but now I do need to run. Later
16:46:15 <TomMD> http://hpaste.org/10356
16:47:40 <ddarius> I imagine that would go a heck of a lot faster with TChans.
16:48:13 <dons> due to avoiding the blocking?
16:48:38 <ddarius> The optimism should be near ideal in this case.
16:48:56 <ddarius> It would be interesting to do a comparison between Chan and TChan for different numbers of readers and writers.
16:50:10 <dons> so i've an app that has 'cpu number' of writers, and one reader.
16:50:19 <RayNbow> > unfoldUntil null uncons $ [1..4]
16:50:20 <lambdabot>   [1,2,3,4]
16:50:21 <dons> each writing a chunk of data into the single channel.
16:50:34 <dons> i suspect TChans will be better. I should benchmark.
17:02:18 <newsham> > unfoldUntil (==0) (\n -> (n `mod` 2, n `div` 2)) 259
17:02:19 <lambdabot>   [1,1,0,0,0,0,0,0,1]
17:04:26 <newsham> > unfoldUntil (==0) (swap . (`divMod` 8)) 259
17:04:27 <lambdabot>   [3,0,4]
17:08:32 <mancalledhash> has anyone here ever embedded a scripting language into their Haskell Program?
17:09:48 <newsham> an embedded domain specific language?  or a preexisting standard scripting language?
17:10:32 <mancalledhash> a preexsiting one like python, ruby, etc..
17:11:34 <mancalledhash> I been searching on google for the longest and the only thing that came up was the lua bindings and I changed a few things to get it to work and still no luck lol
17:11:40 <newsham> dont know.. i havent heard of someone doing it.
17:11:50 <mancalledhash> oh :(
17:11:57 <newsham> but should be possible using FFI and the normal C API for the language
17:12:47 <mancalledhash> so I have to learn "C"
17:13:52 <dons> mancalledhash: you can call lua or python or applescript or perl or ...
17:13:59 <dons> but we usually just use Haskell as the scripting language
17:14:04 <dons> since it kinda rocks
17:14:19 <newsham> you could always pay someone else who already knows C.
17:14:23 <mancalledhash> lol yea it rocks but I can't find a working examle for python :(
17:14:30 <dons> oh, hpaste2 calls python.
17:14:30 <mancalledhash> lol newsham sounds like a good idea
17:14:33 <dons> it's on github.
17:14:56 <newsham> what python code does hpaste2 run?
17:15:03 <dons> pygments
17:15:16 <newsham> whats that?  pretty printing?
17:15:24 <dons> colorising
17:15:28 <mancalledhash> Im gonna check that out right now!
17:15:31 <Cale> mancalledhash: One interesting technique, depending on what the scripting language is to be used for is to design your program as a Haskell library, and of course provide a default 'main', but make things easy to customise. This is the approach seen in xmonad.
17:16:10 <Cale> Another way would be to use the GHC API to compile and load Haskell code at runtime.
17:16:29 <Cale> There are various wrappers for making that easier to do.
17:17:45 <newsham> http://github.com/glguy/hpaste/tree/master/src/Highlight.hs
17:17:49 <newsham> nifty
17:17:53 <mancalledhash> I will search some more, THANKS GUY
17:18:30 <dons> github has the slow
17:19:13 <mancalledhash> this code is easy to understand!
17:19:48 * dcoutts pushed 19 patches for the new hackage-server
17:19:55 <dcoutts> now with htpasswd support
17:20:12 <dons> sweet.
17:20:23 * dons has a plan for the tar.gz script. i'll implement it 
17:20:41 <dcoutts> it'll let us import the existing user accounts
17:20:50 <mancalledhash> ok I got to get the pyhon headers and it should work
17:20:53 <dons> cool, dcoutts .
17:20:56 <dons> i think that's important
17:20:58 <dcoutts> without making people change their passwords
17:22:41 <glguy> The trick I used in calling out to python was to wrap as much python logic in a wrapper as possible
17:23:02 <glguy> python written in python is easier to deal with than python written in c called from haskell
17:23:19 <dons> glguy: as much logic on the python side?
17:23:22 <dons> or the haskell side?
17:23:34 <glguy> of the logic pertaining to the python library
17:23:39 <glguy> as much on the python side as possible
17:23:44 <dons> that's interesting.
17:23:50 <dons> for C, we try to do as much on the Haskell side.
17:24:03 <dons> so perhaps python is sufficiently safe + different, that it makes sense to let it do its work.
17:24:16 <dons> while C is unsafe, but at least statically typed, so easier to do that on the haskell side.
17:24:17 <glguy> well, we don't have a native python ffi
17:24:31 <glguy> so you have a lot more code to write if you want the logic haskell side
17:24:33 <dons> true, perhaps a binding tool would change things.
17:26:29 <mancalledhash> More work on the python side is easier to deal with.  That makes sense.  I don't really like dealing with "C" all that much.  But just enough to get things working, I can deal with that.
17:27:07 <dons> it's about where you want to do the marshalling i guess. if there's already Python Storable instances, then haskell is easy. but if there isn't, then marshalling as little as possible makes sense.
17:29:09 <dons> the download page should have a big 'Download' link in the top left
17:29:16 <dons> before the 'xmonad comes in two parts' bit :)
17:29:28 <dons> i like the use of past versions link
17:29:38 <dons> looking good!
17:43:37 <TomMD> ddarius, dons: TChans are about half the speed of chans on this trivial example with a single reader and single writer (1M messages, 1.13 vs 2.3 seconds).  A more extensive testing would be interesting.
17:57:09 <hackage> Uploaded to hackage: pandoc 1.0.0.1
18:01:05 <Arnar> hey folks..
18:01:17 <Arnar> what's the best way to move packages from my user dir to the global one?
18:01:30 <dons> reinstall them. cabal install foo --reinstall --global
18:01:31 <dons> iirc
18:01:46 <Arnar> dons: thanks.. I'll try that
18:01:58 <dons> oh, you'll need sudo
18:02:09 <Arnar> of course
18:03:11 <Arnar> hmm.. "--reinstall" not reckognized
18:03:37 <Arnar> btw. I wish --global was default if the active user has write access to it
18:03:38 <dons> needs new cabal-install.
18:03:42 <Arnar> ok
18:03:46 <dons> grab the one on hackage.
18:03:48 <Arnar> I can upgrade with the oldone?
18:03:50 <dons> cabal install cabal-install
18:03:52 <dons> yeah.
18:04:00 <dons> cabal update first , likely
18:04:06 * Arnar remebers to use --global on that one :)
18:04:19 <glguy> Arnar: a better solution would probably be to support a .cabal file where that could be specified
18:04:34 <Arnar> glguy: you mean a ~/.cabal settings file
18:04:40 <glguy> yes
18:04:49 <Arnar> yes.. I'd be happy with that
18:05:03 <glguy> Arnar: or you could alias cabal
18:05:09 <glguy> to be cabal --global
18:05:11 <glguy> in your shell :)
18:05:12 <dons> user-install: True
18:05:19 <dons> in the .cabal/config
18:05:23 <dons> you can change that.
18:05:28 <glguy> well, there you go :)
18:05:31 <Arnar> glguy: true..
18:05:40 <Arnar> dons: ah.. nice, thx
18:05:47 <dons> cabal-install. it has the win.
18:06:35 <Arnar> it does.
18:08:37 <Arnar> dons: did O'Reilly have any problems with the RWH growing to 700 pages?
18:08:54 <dons> nope.
18:08:59 <dons> i think they liked that.
18:09:21 <Arnar> oh.. that's good :)
18:10:51 <Arnar> if I have a sourceball (.tar.gz) which has a xx.cabal file etc.. can I install with cabal-install and have it chase the dependencies for me?
18:11:01 <Arnar> i.e. for a package that is not on hackage
18:12:37 <Arnar> *sigh* can't upgrade cabal-install, fails on some pacakges, including regex-posix with  No instance for (Text.Regex.Base.RegexLike.Extract ByteString)
18:12:46 <dons> Arnar: yeah. you can.
18:13:02 <dons> reinstall regex-posix?
18:13:12 <dons> you might have to force some of the upgrades
18:13:30 <Arnar> no.. cabal upgrade cabal-install fails for four dependent packages, including regex-posix
18:13:36 <Arnar> aight
18:14:59 <Arnar> well.. have to sleep now.. will do this later :)
18:15:02 <Arnar> dons: thanks for the help
18:15:30 <ushdf> (+ ushdf dons)
18:15:36 <ushdf> ;););)
18:16:07 <mmorrow> ushdf: ushdf
18:16:14 <Saizan> Arnar: you want cabal install cabal-install, not upgrade
18:16:23 <Arnar> Saizan: oh, ok
18:16:36 <ushdf> that's me babe
18:16:40 <Arnar> Saizan: why?
18:16:42 <Saizan> upgrade will try to upgrade all your packages, iirc
18:16:49 <Arnar> oh, I see
18:16:56 <Arnar> <:P
18:17:48 <Arnar> Saizan: that just gives me a different ByteString error :)
18:18:12 <Arnar> think I'll leave it for now.. was just trying to install Twidge
18:18:22 <Arnar> not a matter of life and death, obviously :)
18:20:11 <dons> cabal install twidge didn't work?
18:20:46 <Saizan> if you've sufficiently old version of cabal-install it's not uncommon to get problems with bytestring
18:24:08 <newsham> cabal install cabal-install?
18:24:55 <ushdf> > 3260
18:24:56 <lambdabot>   3260
18:30:41 <ushdf> lambdabot is trying to make a fool of me
18:31:21 <Axman6> lambdabot will find your weakest point, and exploit it
18:34:26 <mmorrow> ushdf: are you a bot?
18:34:41 <ushdf> no
18:34:46 <mmorrow> k :)
18:35:02 <ushdf> tell me more about k ;)
18:35:13 <mmorrow> more about k ;)
18:35:24 <ushdf> That's interesting.  What do you think is the cause of that?
18:35:31 <mmorrow> indeed!
18:35:37 <ushdf> I've heard that as well.
18:35:47 <mmorrow> ninety four hundred...
18:35:53 <ushdf> Nineteen Eighty-Four.
18:36:03 <mmorrow> TELEVISION!
18:36:12 <ushdf> Bestiality!
18:36:16 <mmorrow> lol
18:36:17 <Olathe> None hundred and five !
18:36:23 <ushdf> Be quiet.
18:37:22 <ushdf> > mmorrow + ushdf
18:37:23 <lambdabot>   mueval: Prelude.read: no parse
18:37:50 <mmorrow> > fix ("ushdf:":)
18:37:52 <lambdabot>   ["ushdf:","ushdf:","ushdf:","ushdf:","ushdf:","ushdf:","ushdf:","ushdf:","u...
18:38:12 <dmwit> > mmorrow ++ ushdf
18:38:13 <lambdabot>   "lurve"
18:38:26 <mmorrow> whoa
18:38:38 <ushdf> =-o
18:38:49 <mmorrow> > mmorrow
18:38:52 <lambdabot>   "lur"
18:38:52 <Olathe> > (mmorrow, ushdf)
18:38:53 <lambdabot>   ("lur","ve")
18:38:58 <mmorrow> > dmwit
18:39:00 <lambdabot>   mueval: Prelude.read: no parse
18:39:01 <dmwit> he
18:39:04 <mmorrow> haha
18:39:06 <Olathe> > omg
18:39:07 <lambdabot>   mueval: Prelude.read: no parse
18:39:20 <ushdf> what on earth
18:39:38 <dmwit> butterflies!
18:39:45 <mmorrow> @let dmwit = fix error
18:39:45 * ushdf blushes
18:39:47 <lambdabot>  Defined.
18:39:51 <mmorrow> > dmwit
18:40:06 <lambdabot>   thread killed
18:40:16 <dmwit> ?karma
18:40:17 <lambdabot> You have a karma of 0
18:40:23 <dmwit> > say $ "dmwit++"
18:40:26 <lambdabot>   dmwit++
18:40:30 <dmwit> ?karma
18:40:30 <lambdabot> You have a karma of 0
18:40:34 <dmwit> Aw, shucks. =P
18:40:50 <mmorrow> i thought that was gonna work for a sec there
18:40:58 <Olathe> preflex is gone.
18:41:07 <dmwit> I just noticed that myself.
18:57:09 <hackage> Uploaded to hackage: libmpd 0.3.1
18:59:20 <newsham> > say "hi\ndmwit++"
18:59:23 <lambdabot>   hi
18:59:23 <lambdabot>  dmwit++
18:59:27 <newsham> ?karma dmwit
18:59:27 <lambdabot> dmwit has a karma of 0
19:00:01 <mmorrow> i just remembered that lb doesn't process input from itself
19:00:08 <newsham> ?fact: ?fact
19:00:09 <lambdabot> I know nothing about ?fact
19:00:12 <mmorrow> of course i meant herself
19:02:45 <bos> byorgey++
19:05:50 <FunctorSalad> @vixen what is your favourite snack?
19:05:50 <lambdabot> i dunno...
19:06:19 <FunctorSalad> hmm.
19:09:49 <stulli> @src fmap
19:09:49 <lambdabot> Source not found. You speak an infinite deal of nothing
19:10:25 <FunctorSalad> @src Maybe
19:10:26 <lambdabot> data Maybe a = Nothing | Just a
19:10:48 <FunctorSalad> stulli: hmm, you would have to get the instance sort for the relevant functor
19:10:55 <FunctorSalad> source, not sort
19:14:51 <stulli> FunctorSalad: i dont know what you mean, i just saw fmap the first time and wanted to know what it does
19:15:18 <dibblego> generalises map, (.) and so on
19:16:18 <Cale> stulli: fmap :: (Functor f) => (a -> b) -> f a -> f b
19:16:36 <FunctorSalad> stulli: it's part of the Functor class... what it does depends on the particular type that is declared an instance of Functor
19:16:40 <Axman6> what is a functor anyway?
19:16:45 <Cale> stulli: Which is required to satisfy the laws:  fmap id = id, and fmap (f . g) = fmap f . fmap g
19:17:03 <Cale> Axman6: In this context, it's a type constructor with fmap defined :)
19:17:04 <Olathe> @src Functor
19:17:05 <lambdabot> class  Functor f  where
19:17:05 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:17:09 <dibblego> Axman6, any instance of the Functor type-class that satisfies two laws
19:17:23 <Axman6> which laws are those?
19:17:29 <Cale> fmap id = id, and fmap (f . g) = fmap f . fmap g
19:17:38 <Axman6> righto
19:18:06 <Axman6> that's pretty easy. got an example of a functor?
19:18:11 <Cale> Lists
19:18:19 <Cale> (the obvious one)
19:18:25 <Cale> Where fmap is just the usual map
19:18:49 <Cale> Or obviously any data structure for which a function can be applied to all the elements which it's parametrised over.
19:19:05 <FunctorSalad> AFAIK the functor class is not used that often in haskell because most things have additional structure, like Monad or Applicative
19:19:05 <Axman6> so f a in (Functor f) => (a -> b) -> f a -> f b for be the input list?
19:19:13 <Cale> yeah
19:19:28 <Myoma> :t fmap :: (a -> z) -> ([a] -> [z])
19:19:30 <lambdabot> forall a z. (a -> z) -> [a] -> [z]
19:19:30 <Cale> In that instance, we have  fmap :: (a -> b) -> [a] -> [b]
19:19:48 <Cale> Another good example is functions from a fixed type e
19:19:51 <Axman6> any other examples? (and handy used uses for fmap?)
19:19:54 <Cale> That is, f = (e ->)
19:20:09 <Cale> In that case, we have:
19:20:16 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
19:20:27 <Cale> Which, you should be able to guess what it does :)
19:20:34 <FunctorSalad> if the f is also a monad, then (usually) fmap = liftM (if you're more familiar with liftM)
19:20:44 <Cale> Right, any monad is a functor.
19:21:03 <Cale> (In fact, being a functor is usually the first part of the definition of a monad :)
19:21:07 <FunctorSalad> but not in haskell due to overlapping instances ;-)
19:21:15 <Cale> There's no good reason in Haskell.
19:21:26 <Axman6> hmm, getting lost again -_-
19:21:35 <Cale> Just that someone left out the superclass definition when they defined the Monad class.
19:21:43 <FunctorSalad> yeah
19:21:51 <Cale> (it ought to read   class Functor m => Monad m where ...
19:21:53 <Cale> )
19:22:08 <FunctorSalad> hmm, maybe it's intentional so you don't have to define fmap before you define a monad
19:22:09 <Cale> So, for instance, IO is a functor
19:22:22 <Cale> FunctorSalad: Yes, that's the reason, but you can always define it as liftM
19:22:25 <FunctorSalad> (since the fmap would be redundant after the fact)
19:23:15 <Cale> It's perfectly acceptable to write   instance Functor MyMonad where fmap = liftM  and follow that up with a proper instance of Monad.
19:23:38 <FunctorSalad> another solution would be default implementations of superclass methods given by the subclass :)
19:23:44 <Cale> yeah
19:23:56 <FunctorSalad> (eq x y = x <= y && y <= x also comes to mind)
19:24:01 <Cale> Axman6: If you would like, I can provide the more general definition...
19:24:09 <FunctorSalad> (err I mean (==), not eq)
19:24:31 <Axman6> that would be good, if you can hang on a sec, helping someone in #macosx
19:24:34 <Cale> okay :)
19:24:36 <stulli> Cale, FunctorSalad : thanks, i think i understand this better now
19:24:49 <FunctorSalad> :)
19:27:07 <Axman6> urgh, stuff that. people who think they need to install sound cards in macs deserve no help from me
19:27:29 <Cale> ehehe
19:27:58 <Axman6> at least it's not a hackintosh idiot
19:28:00 <Cale> So anyway, do you know what a category is already?
19:28:06 <Axman6> anyway, you may carry on now :P
19:28:13 <Axman6> no..
19:28:35 <Cale> Okay... so a category C consists of the following data:
19:28:52 <Cale> A collection Ob(C), of objects of C (these can be anything at all)
19:29:27 <Cale> For each pair A,B of objects of C, a collection Hom(A,B) of arrows
19:29:36 <Cale> We write f: A -> B when f is an arrow from A to B
19:29:51 <Axman6> what is an arrow anyway?
19:30:00 <Cale> Anything at all that you like.
19:30:08 <Cale> They need not have any internal structure...
19:30:15 <Cale> However, there is an operation...
19:30:23 <Axman6> got an example? sounds very existential
19:30:49 <Cale> For every three objects A, B, C and arrows g: A -> B, and f: B -> C, there is an arrow f . g: A -> C which is their composite
19:31:15 <Axman6> ok
19:32:18 <Cale> Moreover, for every object A, there must be at least one arrow id_A: A -> A, such that for any f: A -> B, or g: C -> A, the composites  f . id_A = f, and id_A . g = g
19:32:29 <Cale> So, let's look at some examples...
19:32:45 <Cale> The obvious example sitting in front of us is the category whose objects are Haskell types
19:32:54 <Cale> and whose arrows are Haskell-definable functions
19:33:09 <Cale> and where the composition is composition of Haskell functions
19:33:13 <Cale> :t (.)
19:33:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:33:45 <Cale> Another, just slightly different, example is sets and functions in mathematics.
19:33:59 <Cale> But there are other examples...
19:33:59 <Axman6> i had no idea (.)'s type signature was so long. only ever looked at the source
19:35:17 <Cale> For instance, if we take any set of objects with what is called a preorder: this is a predicate <= so that x <= x for all x, and if x <= y and y <= z, then x <= z, we can turn that into a category by putting an arrow from x to y exactly when x <= y.
19:35:46 <Cale> (So for instance, the natural numbers, under their usual ordering, turn into a category with a single arrow n -> m when n <= m.
19:35:51 <Cale> )
19:36:46 <Cale> And of course, if we restrict the definition of a category so that there is only at most one arrow between any pair of objects, we see that we must have a preorder.
19:36:47 <Axman6> you're not saying addition are you?
19:37:00 <Axman6> indeed
19:37:00 <Cale> Not addition as such, no...
19:37:12 <Cale> The arrows there just tell you the ordering.
19:37:22 <Axman6> yeah, i get what you mean
19:37:47 <Cale> Another way we can restrict the definition of a category is to impose the condition that there's only one object.
19:38:00 <Cale> (but possibly many arrows)
19:38:10 <Cale> In that case, we get what is called a monoid.
19:38:31 <FunctorSalad> picture: ‚Ü∫
19:38:35 <FunctorSalad> ;-)
19:38:47 <Axman6> Cale: do you have an example?
19:38:50 <Cale> Oh... I left out an important part of the definition of a category...
19:38:53 <FunctorSalad> (of an arrow from the single object to itself)
19:38:56 <Cale> d'oh
19:39:07 <Cale> (f . g) . h = f . (g . h) whenever those make sense.
19:39:11 <ushdf> i had a hackinimac
19:39:15 <Cale> (that is, whenever the arrows line up)
19:39:19 <ushdf> one of those stupid blueberry fucks
19:39:33 <ushdf> every time i booted X it would start screeching uncontrollably
19:39:48 <Cale> So, one example of a monoid is, say, the natural numbers again, only with composition being addition.
19:40:09 <Axman6> ushdf: i assume you mean OS X? though if you mean X11, i can understand the screaming
19:40:18 <Cale> That is, just take one object, the arrows going from that object to itself are the natural numbers, and composing n with m gives n + m
19:40:19 <ushdf> no, X11
19:40:25 <Cale> The identity arrow in that case is 0.
19:40:31 <ushdf> it was a headache
19:40:39 <Cale> Because 0 + n = n and n + 0 = n
19:40:48 <Axman6> i see
19:40:48 <ushdf> i was 12 so..it resulted in me installing a different OS
19:40:56 <Cale> Axman6: Do you know about vector spaces?
19:41:16 <Axman6> i do, we're doing a lot on them at the moment in our maths course
19:41:20 <Cale> Ah, good.
19:41:32 <FunctorSalad> Cale: maybe the geometrical definition of category is more intuitive? :)
19:41:50 <Cale> Another category is given by the vector spaces over a given field, and the arrows between them being the linear transformations.
19:42:34 <Cale> You'll see a lot of this sort of pattern, if you take abstract algebra courses further: groups and group homomorphisms, rings and ring homomorphisms, and so on.
19:42:46 <Cale> Another example is topological spaces and continuous functions between them.
19:43:33 <ushdf> this is a lot like LISP isn't it
19:43:35 <Cale> So, most of mathematics can fit into this very general notation where you have some objects, and you have "structure-preserving" mappings between those.
19:43:49 <Myoma> ushdf: 'this'?
19:44:08 <Axman6> ushdf: how old are you anyway?
19:44:35 <Axman6> can't be much over 13 or so if you installed OS X on a hackintosh at 12
19:44:56 <ushdf> haskell is a lot like lisp, isn't it
19:45:01 <ushdf> i'm 19, i put debian on the imac
19:45:08 <Myoma> ushdf: I don't think they are very similar at all
19:45:11 <Axman6> oh, right
19:45:17 <ushdf> in the grand scheme of programming
19:45:18 <Cale> ushdf: uh... well, a little bit. They're also quite different.
19:45:21 <ushdf> no pun intended
19:45:31 <FunctorSalad> ushdf: I'd say the huge difference is the static type system
19:45:44 <Axman6> and haskell's readable ;)
19:45:56 <Cale> ushdf: Lisp doesn't (generally) have static types, is strictly evaluated, and usually has unrestricted side effects.
19:46:15 * ushdf nods
19:46:17 <Myoma> the only thing they both have is lambda ..
19:46:23 <FunctorSalad> I would guess lisp and haskell are similar demographically though ;-)
19:46:56 <Cale> Axman6: Another example of a category is provided by any directed graph, with the objects being the vertices, and the arrows being the *paths*, with composition of arrows being concatenation of paths.
19:47:09 <newsham> > ((+) 3 ((*) 4 5))
19:47:10 <lambdabot>   23
19:47:14 <newsham> looks the same to me
19:47:22 <ushdf> maybe a little more like ML
19:47:36 <Cale> Axman6: Anyway... a functor in general, is what we were aiming at :)
19:48:01 <Cale> Axman6: If C and D are two categories, a functor F: C -> D is two mappings:
19:48:04 <ushdf> > gcd 3598 230598
19:48:06 <lambdabot>   2
19:48:11 <ushdf> > gcd 3598 230597
19:48:13 <lambdabot>   1
19:48:20 <ushdf> :IO
19:48:35 <Cale> 1) An assignment for each object X of C, exactly one object (called FX) of D.
19:48:37 <ushdf> > gcd 3598 65535
19:48:38 <lambdabot>   257
19:48:47 <ushdf> now that's cool
19:48:56 <Cale> 2) For each arrow f: X -> Y in C, an arrow Ff: FX -> FY in D.
19:49:35 <Cale> This is subject to the restriction that: F(id_A) = id_(FA) and F(f . g) = (Ff) . (Fg)
19:49:49 <ushdf> > map (+ 2049824) [1..5000]
19:49:51 <lambdabot>   [2049825,2049826,2049827,2049828,2049829,2049830,2049831,2049832,2049833,20...
19:50:13 <newsham> ushdf: btw, you can /msg lambdabot > 1 + 2
19:50:17 <newsham> and it will msgyou back the response
19:50:17 <FunctorSalad> in other words, it maps triangles to triangles
19:50:23 <Cale> So it's sort of like a way to see objects and arrows in one category as objects and arrows in another (though it might collapse out some structure)
19:50:23 <ushdf> it's funnier this way
19:51:00 <Cale> Axman6: does that make sense?
19:51:07 <newsham> ?let a `divides` b = b `mod` a == 0
19:51:09 <lambdabot>  Defined.
19:51:09 <Cale> Axman6: It might be hard to absorb at first...
19:51:15 <newsham> > nubBy divides [2..]
19:51:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
19:51:41 <FunctorSalad> @src nubBy
19:51:41 <lambdabot> nubBy eq []             =  []
19:51:41 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:51:59 <Axman6> Cale: i think i get it, but i'm not sure
19:52:44 <Cale> Axman6: Okay... so let's see if I can come up with some convincing examples... Why don't we use Haskell :)
19:52:55 <Axman6> sounds like a plan
19:53:02 <newsham> wow, its almost like cale is leading us on
19:53:06 <Cale> So let's consider what a functor Hask -> Hask would look like.
19:53:18 <Cale> It would be two things:
19:53:25 <Myoma> newsham: soon we are all going to want to use haskell!
19:53:26 <Cale> 1) A mapping from types to other types.
19:53:48 <Axman6> sure
19:54:03 <Cale> (so, taking a type t to a type F t
19:54:04 <Cale> )
19:54:29 <Cale> and 2) For any arrow (a -> b), an assignment of a new arrow (F a -> F b)
19:55:04 <Axman6> would divides above be a mapping from Num to Bool, for instance?
19:55:34 <Axman6> (well, (somenumber `divides`) at least
19:55:36 <Cale> Well... explaining what kind of arrow divides is, can be a little tricky.
19:55:46 <Cale> It's sort of a bunch of arrows, because it's polymorphic.
19:56:16 <Cale> But category theory actually has a concept for it, called natural transformations, but I think we've bit off enough already at this moment :)
19:56:27 <Axman6> heh, ok
19:56:52 <Cale> But anyway, if we have a type constructor F
19:57:16 <Cale> That's an assignment of Haskell types to Haskell types, right?
19:57:25 <Axman6> sure
19:57:29 <newsham> by type constructor you mean  "data F a"  kinda thing, right?
19:57:36 <Axman6> Just 1 for example?
19:57:38 <Cale> and then all we'd need is a way to turn an arrow  a -> b  into an arrow  F a -> F b
19:57:42 <Cale> newsham: right.
19:57:45 <newsham> not the constructors like "Just" and "Nothing"
19:57:48 <Cale> Maybe, for example
19:57:49 <Myoma> Just is the data constructor
19:58:02 <Cale> Integer is a type
19:58:06 <Cale> Maybe is a type constructor
19:58:13 <Cale> Maybe Integer is a type
19:58:19 <ushdf> this language makes every part of my body scream in anguish
19:58:21 <Cale> IO is another type constructor
19:58:26 <Cale> IO Integer is a type
19:58:29 <ushdf> especially the appendix
19:58:32 <Axman6> ushdf: you'll learn to love it
19:58:38 <ushdf> i already do
19:58:43 <Cale> ushdf: What is wrong?
19:58:47 <Myoma> @w80 anguish
19:58:48 <lambdabot> *** "anguish" wn "WordNet (r) 2.0"
19:58:48 <lambdabot> anguish
19:58:48 <lambdabot>      n 1: extreme mental distress [syn: {torment}, {torture}]
19:58:48 <lambdabot>      2: extreme distress of body or mind
19:58:48 <lambdabot>      v 1: suffer great pains or distress
19:58:50 <lambdabot> [3 @more lines]
19:59:01 <ushdf> it has to do with voodoo
19:59:11 <newsham> i cant tell if ushdf is trolling or not
19:59:19 <Myoma> both
19:59:20 <Axman6> Cale: any chance i could come back yo this shortly? lunch is on, and getting cold
19:59:20 <Cale> ushdf: Ah, well, remind me to explain how lazy evaluation proceeds sometime.
19:59:25 <Cale> Axman6: ah, sorry :)
19:59:28 <Cale> Axman6: sure
19:59:31 <Axman6> s'aok :)
19:59:33 <Axman6> -a
19:59:33 <ushdf> i get how it works
19:59:49 <Cale> Is there any particular voodoo which you'd like me to dispel?
20:00:08 <ushdf> i am being turned into a rubber chicken
20:00:27 <ushdf> > map (** 2) [1..30]
20:00:28 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0,121.0,144.0,169.0,196.0,22...
20:00:32 <newsham> its like basic training.. break you down then build you up
20:00:38 <ushdf> why doesn't that return int
20:00:44 <newsham> ?type (**)
20:00:45 <lambdabot> forall a. (Floating a) => a -> a -> a
20:00:47 <Cale> > map (^2) [1..]
20:00:49 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:00:53 <ushdf> gotcha
20:00:54 <Myoma> @let square = join (+)
20:00:57 <lambdabot>  Defined.
20:01:00 <Myoma> > map square [6]
20:01:01 <lambdabot>   [12]
20:01:02 <newsham> join (*)
20:01:08 <ushdf> o.O
20:01:16 <Cale> That's double, not square :)
20:01:31 <Myoma> @let double = square . square
20:01:34 <lambdabot>  Defined.
20:01:34 <bd_> @let square = join (*)
20:01:36 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
20:01:37 <ushdf> i was wondering why he did that
20:01:37 <Myoma> > double 2
20:01:38 <lambdabot>       Ambiguous occurrence `double'
20:01:38 <lambdabot>      It could refer to either `L.double',...
20:01:43 <Myoma> :?
20:02:00 <bd_> @more
20:02:06 <ushdf> how do you say
20:02:14 <ushdf> raise each member of set [1..1000] to the power of the previous member of the set
20:02:15 <mgsloan> with the function "foo1 (f1, f2) = (map f1, map f2)" would it be possible to write a foo2 such that (foo2 map) is equivalent to foo1?
20:02:40 <Myoma> ushdf, try to reduce it to an easier problem you can already solve
20:03:00 <Myoma> ushdf, such as turing [(0,1),(1,2),..] into (0^1,1^2,...]
20:03:08 <ushdf> well if it was > map (^n-1) [1..1000] it would be fine
20:03:13 <mgsloan> it seems to me that it's difficult to write functions that take polymorphic functions as parameters, and use them in multiple contexts
20:03:16 <ushdf> that's not valid though
20:03:17 <Myoma> ushdf: $_
20:03:18 <Myoma> lol
20:03:22 <newsham> > let xs = [1..] in zipWith (^) xs (drop 1 xs)
20:03:23 <lambdabot>   [1,8,81,1024,15625,279936,5764801,134217728,3486784401,100000000000,3138428...
20:04:07 * ushdf bends the perl part of his mind over
20:04:11 <ushdf> oO
20:04:15 <ushdf> --___-oooooOOoO
20:04:19 <newsham> ushdf: [1..1000] is a list.  sets dont have "previous" (but its ok, lists do)
20:04:21 <ushdf> ----------_____________________-----------------------------------------//////////////////
20:04:37 <ushdf> sets are randomly ordered and not exclusive of their own members, yeah
20:04:45 <ushdf> not randomly ordered...uhh..irreverent to order
20:04:52 <newsham> not so much "randomly ordered" as unordered
20:04:54 * ushdf coughs up a lung
20:05:11 <newsham> remember kids, dont smoke.
20:05:13 <bd_> what do you mean by 'not exclusive of their own members'?
20:05:14 <Myoma> @quote random
20:05:14 <lambdabot> sioraiocht says: was dons PhD in writing random haskell libraries?
20:05:24 <ushdf> i mean that if a set contains 6 and 6 then it contains 6!
20:05:27 <Myoma> @quote
20:05:27 <lambdabot> pkhuong says: you'll probably still want unsafeEquality or whatever, though
20:05:27 <bd_> sets can only have one of any given element. Or rather, the idea of a count of identical elements is undefined
20:05:33 <ushdf> :]
20:05:49 <Myoma> @quote
20:05:50 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
20:06:23 <newsham> "does this guy look like he needs semantics?  <insert schneier>"
20:07:13 <ushdf> that makes it hard to disassemble...
20:07:37 <ushdf> that makes it easy to disassemble!
20:10:50 <ushdf> the restlessness of autumn is filtered through the wind screen, only short of the disappointments to follow
20:11:01 <ushdf> john c lilly hovers outside, screaming of the shortcomings of dolphins
20:11:09 <ddarius> mgsloan: That's not possible in H98.
20:11:16 <ushdf> > E.C.C.O.
20:11:18 <lambdabot>   mueval: Prelude.read: no parse
20:12:55 <mgsloan> ddarius - ah, yeah, it's an interesting case.. is it possible with some extensions?
20:14:41 <ddarius> :t let foo2 :: (forall a b.(a -> b) -> [a] -> [b]) -> (a -> b, c -> d) -> ([a] -> [b], [c] -> [d]); foo2 m (f, g) = (m f, m g) in foo2 map
20:14:43 <lambdabot> forall a b c d. (a -> b, c -> d) -> ([a] -> [b], [c] -> [d])
20:14:54 <mgsloan> ooh
20:15:07 <mgsloan> thanks!
20:15:29 <mgsloan> i guess currently existentials aren't inferred
20:16:00 <Myoma> :t let foo2 map (f1, f2) = (map f1, map f2) in foo2
20:16:01 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
20:16:24 <ddarius> mgsloan: That's a higher rank universal and they can't be inferred in general.
20:16:50 <dons> hey guys, any feedback on the new xmonad website twifkak is working on? http://xmonad.twifkak.com/
20:16:50 <lambdabot> Title: xmonad | the tiling window manager that rocks
20:17:53 <Axman6> dons: looks good. it
20:17:59 <Axman6> 's missing something though... not sure what
20:18:05 <mgsloan> ddarius - ah, interesting.. well it's awesome it's still possible
20:18:23 <dons> yeah, have a think.
20:18:59 <Axman6> i know, some gradients and stripes. web 2.0 it up!
20:19:05 <Axman6> just kiding ;)
20:19:11 <ddarius> dons: I'd switch where the screenshots and videos are with where the What's New section is.
20:19:21 <Axman6> kidding*
20:19:32 <ushdf> web 2.0 is like 1.0, but you're not allowed to enjoy yourself
20:19:43 <Axman6> and not use tables
20:19:52 <ushdf> except for tabular data!
20:19:58 <Axman6> exactly
20:20:06 <dons> nice idea ddarius
20:20:20 <ddarius> I'll look at the screenshots the first time I go to the site, not every time, but, (if I were actually interested) I'd want to see the What's New part every time so I shouldn't have to scroll for it.
20:20:25 <Axman6> even then, you're cooler if you avoiud tables, and make it look like you're using them ;)
20:20:39 <newsham> http://www.h-master.net/web2.0/image/(reflect)XMonad2.0BETA.png
20:20:52 <Axman6> dons: i don't think the two sides should be evenly sized
20:20:53 <ddarius> Also then it follows the propaganda.  Once you've been told why you want to use xmonad you can then see what it looks like.
20:21:37 <mgsloan> or swap what's new to the top, and keep it always pretty short
20:22:03 <mgsloan> I kinda like how prominent the screens / vids are
20:22:05 <ddarius> "main()" ? Bending to those C lovers
20:22:05 <Axman6> (Axman6'sidea . ddarius'idea) = make the left half bigger
20:23:59 <Axman6> hmm, i would love to continue this semitutorial with Cale, but i think i really need to get some electrical engineering study done now -_-
20:24:24 <Cale> Axman6: That's all right. I'd be happy to pick it up at any point if you're interested in it :)
20:24:33 <Axman6> cheers :)
20:24:33 <ddarius> newsham: Where is the water ripple effect?!
20:24:45 <Myoma> What do you get if you cross two categories?
20:25:08 <Axman6> see, this is what haskell does to you, it makes you really really nice! not like those cranky C guys
20:25:22 <ddarius> Myoma: Define "cross."
20:26:16 <ddarius> dons: With mgsloan, I would make sure "Screenshot" is visible on the page without scrolling or clicking.
20:26:56 <newsham> ddarius: edit the options if you like.
20:34:50 <dons> thanks guys
20:37:39 <Cale> dons: It should have a different quote every time the page loads :)
20:39:05 <dons> heh.
20:39:17 <dons> well, we're trying to position things more for why you want to use this.
20:39:19 <dons> rather than what it is.
20:39:29 <dons> so basically, productivity, efficiency. it makes your life easier.
20:39:37 <dons> now, there's some slogans that can help, or quotes.
20:39:42 <dons> hard to pick the perfect one.
20:42:07 <Myoma> we need something like ACL2 for Haskell
20:43:32 <ddarius> Proxima?
20:43:57 <Myoma> actually that thing edwardk was describing to do with specifications could be it
20:44:09 <ddarius> Something P ish or that worked with Proxima
20:44:17 <ddarius> Myoma: You could also look at Sparkle and Clean
20:44:32 <Myoma> oh yeah sparkle
20:48:54 <Adamant> is there any way currently to compile from Haskell to Java source code? (this is probably not practical, just had a weird idea)
20:50:15 * ddarius hadn't heard of galculator
20:50:23 <mgsloan> haskell -> jvm bytecode is most likely, and I think I remember hearing of some compiler or another that does this.. maybe yhc..
20:50:37 <dibblego> lambdavm
20:51:33 <Myoma> Adamant: I think it should be pretty easy to do
20:52:00 <Adamant> jvm bytecode is no gut, unless I could decompile it to Java source
20:52:01 <Myoma> the only non-trivial bit is compiling pattern matching
20:52:20 <Myoma> if you want to implement that I can give you some code to get started
20:52:56 <Adamant> Myoma: the main thing I'm wondering is whether it's worth it from a speed-power perspective instead of just coding in straight Java
20:53:19 <Myoma> Adamant: I think it would be better to just program in Java
20:53:38 <Adamant> yeah, I was just wondering if I could mix two hobbies
20:53:56 <Myoma> but if you want to embed a lazy language in java that's not a problem
20:54:39 <Adamant> I'm looking at doing something with Android, which is why I asked
20:55:23 <Adamant> and why the JVM bytecode solution doesn't work, since they use a register-based JVM called Dalvik
20:57:03 <dibblego> Adamant, you might consider Scala or Functional Java
20:57:44 <Adamant> dibblego: I looked at Scala a while back and it's kind of ugly, but it would probably be better than coding in regular Java
20:58:06 <Adamant> thank you for the reference, I think I'll take a look at it
20:58:07 <dibblego> Adamant, yeah it's ugly, but better than Java (which is not saying much)
21:01:16 <Adamant> dibblego: they have a project to add Scala source to Java source compiling support, but it's not finished or working at the moment
21:01:32 <Adamant> thanks though, this is something to keep my eye on
21:01:48 <newsham> isnt programatica for haskell like acl2?
21:02:12 <newsham> http://programatica.cs.pdx.edu/
21:02:15 <lambdabot> Title: The Programatica Project - Intro
21:02:45 <TomMD> newsham: Its more of a framework with which you can record evidence of the trustworthyness of a programs components.
21:03:11 <newsham> ok, but it has tie ins with agda or alfa or some such, no?
21:03:13 <TomMD> Or that was one aspect of Programatica.
21:03:55 <TomMD> newsham: I recall there being formal aspects, but not sure if any particular method was called out.
21:04:24 <TomMD> Its ashame no PSU people hang out here.
21:04:30 <TomMD> afaik
21:04:41 <newsham> yah, formal proof in alfa.
21:07:18 <newsham> seems like a mix of property testing, static checking and formal proofs would rock (scientifically speaking)
21:07:24 <mmorrow> Adamant: this talks about some of the problems with going STG -> JVM http://wiki.brianweb.net/LambdaVM/Implementation
21:07:30 <lambdabot> Title: Brian's Wiki: LambdaVM / Implementation
21:07:49 <mmorrow> this looks to be the biggest one
21:07:51 <mmorrow> We can't make direct branches. What should be a single direct jump instruction turns into an indirect jump back to the caller (who in running the interpreter loop), a conditional branch (while (c != null), followed by a virtual method call (memory read, and another indirect jump). And this is the best case scenario (there might be other stuff going on in the jvm under the hood). This is a lot of overhead.
21:08:51 <Adamant> mmorrow: thanks!
21:08:56 <mmorrow> :)
21:09:20 <newsham> mmorrow: what if you generated the entire code as a single JVM method?  then you can use goto's
21:09:46 <mmorrow> yeah, just like the whole-prog-in-main C method i guess
21:09:59 <mmorrow> but..
21:10:32 <mmorrow> (i dunno why i did the "..", i'm done ;))
21:10:45 <newsham> anticlimactic
21:10:47 <Myoma> newsham: You have a fixed size for each method though, You might hit against it really easily
21:10:47 <mmorrow> haha
21:11:17 <newsham> perhaps you can put several functions that need tail calls together in a single method, and have more expensive calls between those
21:11:22 <Myoma> s/fixed size/limit on the number of bytes/
21:11:31 <newsham> what does javac do when it needs to generate really long function?
21:11:46 <Myoma> You don't need to worry about tail calls since Java has mutation
21:11:46 <newsham> error?  split it automatically fr you?
21:12:35 <newsham> well half of these complaints on this page are wrt tail recursion
21:13:04 <mmorrow> Myoma: one could say that about C, but it's not true.
21:13:05 <ddarius> Programatica was what I was thinking of
21:13:24 <Myoma> mmorrow: I mean in implementing a lazy evaluator in java
21:13:26 <mmorrow> Myoma: except to the extent that you can use gotos w/in a single function to implement it.
21:13:46 <Myoma> you don't need goto, there are  do/while and for loops
21:14:00 <newsham> you dont need do/while, there are gotos
21:14:01 <newsham> ;-)
21:14:05 <Myoma> warning: back in kansas
21:14:13 <mmorrow> Myoma: ok, sure. point being you aren't using the regular function call method of doing things
21:14:33 <Myoma> mmorrow: of coursse this is only a normal way to program in haskell, scheme, etc
21:14:54 <newsham> mmorrow: i think it would be nifty to generate efficient JVM code for haskell first, and then offer fallback FFI for calling "normal" methods 2nd
21:15:11 <mmorrow> exactly, hence the difficulty of compiling such programs to a lang/vm which doesn't support the basic way that they work
21:15:14 <newsham> (says the man who isnt interested in runnin haskell in a jvm)
21:15:25 <mmorrow> (that was @Myoma)
21:15:35 <Myoma> mmorrow: I don't it find difficult...
21:15:38 <newsham> (that was re: myself)
21:15:49 <mmorrow> newsham: heh, me neither. but i think it's an interesting problem in general.
21:16:15 <ddarius> Myoma: +efficiently
21:16:15 <mmorrow> Myoma: well, it's not difficult if you're willing to take a perflormance hit
21:16:15 <Myoma> % ghc -e 'putStrLn $ unlines $ ["public class Long { public static void main(String args[]) {"] ++ replicate 50000 "System.out.print(0);" ++ ["} }"]' > Long.java
21:16:23 <Myoma> % javac Long.java Long.java:1: code too large
21:16:24 <newsham> hey, if htey can make an efficient non-strict lambda calc machine run fast on an ia32
21:16:30 <newsham> i dont see why they couldnt do jvm :)
21:16:53 <mmorrow> this is why apparently:
21:16:55 <mmorrow> jmp *-4(%ebx)
21:16:55 <Myoma> what performance hit? while(1) { } is slower than let x = x in x ?
21:16:57 <ddarius> newsham: The IA32 has arbitrary jmps
21:17:02 <newsham> myoma: wow, yet another reason to avoid javac.
21:17:05 <mmorrow> that single jmp has to be done with:
21:17:12 <newsham> ddarius: i have heard that
21:17:19 <mmorrow> (re pasting)
21:17:19 <Myoma> newsham: Because you can't write _50000_ line methods? lol
21:17:20 <mmorrow> We can't make direct branches. What should be a single direct jump instruction turns into an indirect jump back to the caller (who in running the interpreter loop), a conditional branch (while (c != null), followed by a virtual method call (memory read, and another indirect jump). And this is the best case scenario (there might be other stuff going on in the jvm under the hood). This is a lot of overhead.
21:17:39 * Myoma is always writing 50000 line do blocks in haskell..
21:17:40 <newsham> myoma: you havent established that it is a 50kloc limit
21:18:32 <newsham> and, yah, because it places an arbitrary limit.  i dont see why thats nto a good valid excuse
21:18:34 <ddarius> I wonder how many people have written by-hand Java that exceeds the compiler limits...
21:18:44 <newsham> ddarius: i'd wager more than 1.
21:18:46 <Myoma> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
21:18:48 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
21:18:48 <lambdabot> t63 t64 t65 t66 t67. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 ->
21:18:48 <lambdabot>  t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 ->
21:18:48 <lambdabot> t63 -> t64 -> t65 -> t66 -> t67 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44,
21:18:51 <lambdabot> t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67)
21:18:52 <Myoma> oh ...
21:18:53 <mmorrow> haha
21:18:59 <Myoma> I was hoping for an arbitrary limit ...
21:19:02 <mmorrow> 62
21:19:14 <bd_> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)`seq`()
21:19:15 <lambdabot> ()
21:19:23 <Myoma> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)`seq`()
21:19:25 <lambdabot> ()
21:19:30 <Myoma> what :S
21:19:32 <newsham> *chuckles*
21:19:34 <Myoma> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)`seq`()
21:19:36 <lambdabot>   ()
21:19:36 <mmorrow> you may have to actually exec it
21:19:48 <bd_> mmorrow: the type resolution demonstrates that the function exists, surely
21:19:52 <bd_> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)`seq`()
21:19:53 <lambdabot>   ()
21:20:07 <bd_> and here we instantiate it and force it
21:20:14 <mmorrow> db_: heh. i've seen the code which implement the arbitrary 62-tuple limit.
21:20:17 <bd_> not that the latter involves doing anything
21:20:20 <Myoma> > tail.reverse.(')':).tail.reverse.('(':).show.replicate 10$'x'
21:20:21 <lambdabot>   "\"xxxxxxxxxx)"
21:20:24 <bd_> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)1`seq`()
21:20:25 <newsham> anyone up for some (,,,,,,,) ascii art code?
21:20:26 <lambdabot>   ()
21:20:34 <bd_> > (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)1`seq`()
21:20:35 <lambdabot>   ()
21:20:42 <Myoma> > show.replicate 10$'x'
21:20:43 <lambdabot>   "\"xxxxxxxxxx\""
21:20:51 <Myoma> > tail.reverse.(')':).tail.reverse.('(':).show.replicate 10$0
21:20:52 <lambdabot>   "[0,0,0,0,0,0,0,0,0,0)"
21:21:11 <newsham> > (1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
21:21:12 <lambdabot>       A 160-tuple is too large for GHC
21:21:12 <lambdabot>        (max size is 62)
21:21:12 <lambdabot>        Workaro...
21:21:17 <mmorrow> boom
21:21:36 <Myoma> awwwwww
21:21:38 <Myoma> :(
21:21:41 <Myoma> @ @run (@run say.reverse.(')':).tail.reverse.('(':).tail.show.replicate 10$0)
21:21:47 <Myoma> @@ @run (@run say.reverse.(')':).tail.reverse.('(':).tail.show.replicate 62$0)
21:21:50 <lambdabot>   mueval: Prelude.read: no parse
21:22:01 <newsham> i guess you cant use tuples for DNS labels, which are max 63 chars each
21:22:10 <mmorrow> in the code it says "we really should support the max defined tuple, instead of imposing an arbitrary limit.."
21:22:39 <mmorrow> can't remember which file i saw that in though..
21:24:15 <mmorrow> > parens . hcat . punctuate comma . fmap int $ [0..62]
21:24:17 <lambdabot>   (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:24:20 <Myoma> what's an efficient lazy evaluator?
21:24:51 <Myoma> as opposed to the naive way one would implement it in a strict language with mutation
21:24:55 <mmorrow> um, what's your definition of "lazy evaluator"?
21:25:22 <Myoma> like an interpreter or compiler for a lazy language
21:25:29 <Myoma> anything that can run fibs = 1 : ...
21:25:46 <mmorrow> well, i suppose ghc is one example
21:25:54 <Myoma> yeah
21:26:08 <Myoma> I wonder if there are some important optimizations
21:26:23 <Myoma> compared to just taking WHNFs in a loop and rewriting the heap
21:26:24 <mmorrow> have you read the "making a fast curry" paper?
21:26:46 <Myoma> yes
21:27:00 <mmorrow> interesting i thought
21:27:44 <Myoma> like is there anything fundamental about STG for haskell as there is CPS for scheme?
21:28:05 <mmorrow> i'm not sure, but i'd definitely like to find out..
21:28:52 <ddarius> There isn't anything fundamental about CPS for Scheme.
21:29:22 <mmorrow> ooh, i remeber reading something (at this point old/outdated surely) about how someone rewrote something in yhc to use a register-based instead of stack based machine, and they saw a huge speedup
21:29:28 <mmorrow> i dunno if it was stg though
21:29:56 <ddarius> And there is nothing fundamental about STG as there are several other intermediate languages that have been used.
21:30:00 <mmorrow> here: http://nhc98.blogspot.com/2006/05/register-based-bytecode.html
21:30:02 <lambdabot> Title: malcolm: Register-based bytecode
21:47:28 <bos> dons: ping
21:47:39 <dons> bos: pong
21:48:46 <bos> dons: i wonder why there aren't bytestring functions for manipulating a string relative to its end. i mean, beyond the obvious of "the list API doesn't do that".
21:48:56 <Axman6> dons: you had something to do with the haskell stuff on Arch didn't you?
21:49:02 <thetallguy> bosdonspingdonsbospong
21:49:14 <thetallguy> There's got to be a joke in there somewhere
21:49:15 <bos> if i want to trim 2 chars off the end of a string, for example, i have to reverse . drop 2 . reverse
21:49:23 <dons> bos, there's some breakEnd and other *End functions
21:49:26 <dons> dropEnd et al
21:49:31 <dons> no no.
21:49:33 <dons> no reverse!
21:49:37 <bos> dropEnd?
21:49:50 <dons> spanEnd, breakEnd, elemIndexEnd
21:50:02 <dons> -- | 'breakEnd' behaves like 'break' but from the end of the 'ByteString'
21:50:02 <dons> --
21:50:02 <dons> -- breakEnd p == spanEnd (not.p)
21:50:02 <dons> breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
21:50:16 <dons> we could add dropEnd,
21:50:17 <bos> right, but that's by predicate,not by offset.
21:50:27 <dons> but it is of course, take (length - 2) or what ever.
21:50:33 <bos> aye.
21:50:41 <mmorrow> is length O(n) though?
21:50:47 <dons> no, O(1)
21:50:50 <bos> yes for lazy, no for strict.
21:50:52 <mmorrow> ahh, excellent
21:50:55 <mmorrow> oh
21:51:01 <dons> the *End functions are a bit ad hoc.
21:51:01 <dolio> Dude, just use unsafePerformIO and an IORef to remember how many times the predicate has been called. :)
21:51:05 <dons> i added ones i needed.
21:51:10 <bos> heh.
21:51:27 <dons> for lazy ones, we are careful not to go near the end. so you have to think about the complexity
21:51:44 <bos> working with strings can sometimes be a bit naff compared to e.g. python or perl.
21:52:14 <dons> apis wanted.
21:52:17 <bos> :-)
21:52:23 <dons> we never got around to doing the survey of the python string api
21:52:29 <dons> that was the plan , after bytestring
21:52:33 <bos> ah.
21:52:55 <bos> basically, python's slice notation is the bee's knees.
21:53:03 <mmorrow> heh
21:53:21 <dolio> Lazy byte strings actually lack the *End functions as I recall. Although that's somewhat more understandable.
21:53:34 <bos> slice :: ByteString -> Int -> Char
21:53:45 <bos> slice :: ByteString -> (Int,Int) -> ByteString
21:53:57 <bos> that's about it, except negative indices count from the back.
21:54:00 <mmorrow> couldn't reverse (in the strict case) be O(1) by having a "is-reversed" flag somewhere, then using that to determine which end to start from?
21:54:16 <bos> oh, and of course [:3] and [3:] are different.
21:54:25 <bos> so it would be more like
21:54:42 <bos> slice :: ByteString -> (Maybe Int, Maybe Int) -> ByteString
21:54:48 <dons> hmm
21:54:52 <bos> which wouldn't be any fun to write in haskell.
21:54:56 <dons> instance Num (Maybe Int)
21:55:12 <bos> "foo" `slice` (Nothing,Just 3)
21:55:14 <dolio> That probably only works well for strict strings, where you can implement the *End functions efficiently instead.
21:55:32 <dons> i wonder if there's some view pattern magic here.
21:55:45 <bos> dolio: the thing is, quite often you want to be able to manipulate the strings *easily*, and efficiency is a very distant second concern.
21:56:19 <dolio> Right, but I don't see how 'reverse . foo . reverse' is easier than 'fooEnd' either.
21:56:31 <bos> i didn't say it was :-)
21:57:21 <mmorrow> would be if reverse was O(1) (or at least would be equiv)
21:57:27 <hackage> Uploaded to hackage: MissingH 1.0.2.1
21:59:25 <ddarius> mmorrow: Adding a isReversed boolean would lead to a conditional branch for nearly every function
21:59:48 <klutometis> ushdf: sry to stalk you, man; but how can you hubristically C- scheme and /part without a challenge? ;)
22:00:30 <mmorrow> ddarius: perhaps it could be implemented without a conditional, ie with *,+ somehow
22:00:57 <mmorrow> it doesn't necessarily have to be a boolean
22:02:37 <mmorrow> isReversed :: BS -> Int in {1,-1};   s `at` i = (isReversed s * i) `mod` length s
22:03:00 <mmorrow> no test
22:04:27 <ddarius> mod?
22:04:47 <mmorrow> err
22:05:03 <mmorrow> > > (negate 4) `mod` 5
22:05:04 <lambdabot>   mueval: Prelude.read: no parse
22:05:06 <mmorrow> > (negate 4) `mod` 5
22:05:08 <lambdabot>   1
22:05:10 <mmorrow> yes
22:05:25 <mmorrow> > 4 `mod` 5
22:05:26 <ddarius> > 0 `mod` 5
22:05:28 <lambdabot>   4
22:05:28 <lambdabot>  Terminated
22:05:41 <mmorrow> ddarius: ok, modulo some minor twiddling
22:06:16 <Myoma> heh modulo
22:06:22 <mmorrow> ;)
22:10:23 <electronx> i need help optmizing this http://hpaste.org/10357
22:10:29 <ddarius> @hoogle uncons
22:10:30 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
22:10:30 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
22:10:30 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
22:10:44 <electronx> i'm a haskell noob :)
22:10:50 <ddarius> electronx: Ugh.
22:11:52 <ddarius> electronx: That code doesn't even make sense.  If length str == n then take n str == str, also don't use length
22:11:58 <ddarius> [x]++xs == x:xs
22:12:14 <ddarius> Avoid (implicitly) left associative uses of (++)
22:12:29 <ddarius> Use pattern matching and guards.
22:13:14 <electronx> i started haskell today :)
22:13:39 <ddarius> electronx: You've been around here for a while
22:13:50 <electronx> no ages ago
22:14:05 <electronx> but started doing stuff and learning today
22:14:15 <ivanm> FunctorSalad: ping!
22:14:26 <Axman6> electronx: what's that supposed to do a yway?
22:14:30 <Axman6> anyway*
22:14:51 <Axman6> and g'day
22:15:12 <electronx> run it
22:16:35 <electronx> *Main> ngram 3 "hello"
22:16:35 <electronx> ["hel","he","ell","el","llo"]
22:16:35 <electronx> *Main>
22:17:12 <Axman6> :|
22:17:52 <electronx> its for language identification
22:19:14 <Myoma> electronx: does the order matter
22:19:19 <electronx> nope
22:19:30 <Myoma> in that case, it seems like you could do
22:19:48 <Myoma> ngram n list = qgram n list ++ qgram (n-1) list
22:20:08 <Myoma> although you get some extra stuff you didn't have before..
22:20:21 <Myoma> where qgram 2 "hello" = ["he","el","ll","lo"]
22:20:39 <mmorrow> > let ngram n s = filter ((<=n) . length) . concatMap tails . tails $ s in ngram 3 "hello"
22:20:40 <lambdabot>   ["llo","lo","o","","llo","lo","o","","llo","lo","o","","lo","o","","o","",""]
22:20:57 <mmorrow> > let ngram n s = nub . filter ((<=n) . length) . concatMap tails . tails $ s in ngram 3 "hello"
22:20:59 <lambdabot>   ["llo","lo","o",""]
22:21:05 <mmorrow> um
22:21:15 <mmorrow> oh
22:21:32 <Myoma> @let qgram n = map (take n) . tails
22:21:34 <lambdabot>  Defined.
22:21:36 <Myoma> > qgram 2 "hello"
22:21:37 <lambdabot>   ["he","el","ll","lo","o",""]
22:21:43 <Myoma> :/
22:21:52 <mmorrow> > let ngram n s = nub . filter ((<=n) . length) . concatMap tails . inits $ s in ngram 3 "hello"
22:21:52 <Axman6> > concat . tails "qwerty"
22:21:54 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
22:21:54 <lambdabot>  Terminated
22:21:57 <mmorrow> > let ngram n s = nub . filter ((<=n) . length) . concatMap tails . inits $ s in ngram 3 "hello"
22:21:59 <lambdabot>   ["","h","he","e","hel","el","l","ell","ll","llo","lo","o"]
22:22:03 <Axman6> > concat $ tails "qwerty"
22:22:05 <lambdabot>   "qwertywertyertyrtytyy"
22:22:14 <Myoma> > (concat . tails . const "qwerty") ()
22:22:15 <lambdabot>   "qwertywertyertyrtytyy"
22:23:28 <Axman6> > map (take 2) $ tails "qwerty"
22:23:29 <lambdabot>   ["qw","we","er","rt","ty","y",""]
22:23:53 <Axman6> > map (take 3) $ tails "hello"
22:23:54 <lambdabot>   ["hel","ell","llo","lo","o",""]
22:24:15 <ddarius> ngram' looks very close to inits
22:25:12 <Axman6> > tails "hello" >>= (\l -> [take 3 l,take 2 l])
22:25:13 <lambdabot>   ["hel","he","ell","el","llo","ll","lo","lo","o","o","",""]
22:25:37 <Axman6> > nub $ tails "hello" >>= (\l -> [take 3 l,take 2 l])
22:25:38 <lambdabot>   ["hel","he","ell","el","llo","ll","lo","o",""]
22:25:56 <Axman6> how's that electronx?
22:26:17 <mmorrow> what about "he"
22:26:18 <Axman6> needs some work
22:26:23 <electronx> what about this http://hpaste.org/10358
22:26:33 <mmorrow> oh you got "he"
22:26:34 <Axman6> mmorrow: what about it?
22:26:36 <Axman6> :)
22:26:47 <mmorrow> what about "l"
22:26:55 <mmorrow> is that needed?
22:26:57 <Axman6> there was no l originally ;)
22:26:58 <electronx> no
22:27:13 <electronx> everything more then 1 only
22:27:18 <Axman6> electronx: so what do you actually need? my thing is pretty hardcocded
22:27:34 <Myoma> :t sequence . map take $ [3,2]
22:27:35 <lambdabot> forall a. [a] -> [[a]]
22:27:49 <Axman6> > filter (1 < length) $ nub $ tails "hello" >>= (\l -> [take 3 l,take 2 l])
22:27:50 <lambdabot>   Couldn't match expected type `a -> Bool'
22:28:01 <electronx> :t foldr
22:28:02 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:28:04 <Axman6> > filter (\n -> 1 < length n) $ nub $ tails "hello" >>= (\l -> [take 3 l,take 2 l])
22:28:05 <lambdabot>   ["hel","he","ell","el","llo","ll","lo"]
22:28:10 <mmorrow> > (\n xs -> nub $ tails xs >>= \l -> fmap (flip take l) [1..n]) 5 "helloqwerty"
22:28:11 <lambdabot>   ["h","he","hel","hell","hello","e","el","ell","ello","elloq","l","ll","llo"...
22:28:18 <mmorrow> > (\n xs -> nub $ tails xs >>= \l -> fmap (flip take l) [2..n]) 5 "helloqwerty"
22:28:20 <lambdabot>   ["he","hel","hell","hello","el","ell","ello","elloq","ll","llo","lloq","llo...
22:28:39 <electronx> how do you use foldr?
22:28:44 <Axman6> mmorrow: nice
22:28:48 <mmorrow> :)
22:28:53 <Axman6> @src foldr
22:28:53 <lambdabot> foldr f z []     = z
22:28:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:28:55 <Myoma> electronx: It depends what you want to do with it
22:29:13 <Axman6> argh, ghc 6.6 is so slow!
22:29:16 <Axman6> damn uni
22:29:21 <Myoma> electronx: Do you know how lists are built up? from conses
22:29:27 <electronx> ya
22:30:40 <electronx> is there a hash map struct in haskell
22:31:16 <mmorrow> Data.Map
22:31:43 <mmorrow> it's not a hash though
22:32:20 <Axman6> electronx: this bit is a little silly "if length str == n then [take n str]" could just be if length str == n then [str], i think...?
22:32:56 <electronx> ya :)
22:34:58 <electronx> well not as bad as ghc 6.4
22:35:59 <Axman6> electronx: they have that too
22:37:37 <electronx> my uni runs 6.4
22:37:43 <electronx> unbelievable
22:38:02 <mmorrow> oh dear. can you build your own local 6.8?
22:38:36 <electronx> can it be built with 6.4/
22:38:41 <Axman6> mmorrow:  i tried to, quota's too smell :(
22:38:44 <Axman6> electronx: sure
22:38:48 <mmorrow> electronx: yes
22:38:49 <Axman6> small even
22:38:53 <mmorrow> Axman6: that sucks
22:39:05 <electronx> I 200mb quota
22:39:09 <electronx> have*
22:39:12 <Axman6> yeah, need some way to get it on there. the thing has 4 cores, and i want to use them!
22:39:12 <mmorrow> electronx: it'll take a few hours though..
22:39:18 <Axman6> i have 300MB :\
22:39:26 <electronx> oh
22:39:36 <electronx> so 200mb is not enough?
22:39:42 <Myoma> ?faq can compiling GHC takes hours just to produce an error message about cabal
22:39:43 <lambdabot> The answer is: Yes! Haskell can do that.
22:39:44 <mmorrow> dang. maybe you can get by without the extra libs?
22:39:55 <mmorrow> Myoma: hehe
22:40:10 <electronx> i'll try put a support ticket
22:40:23 <electronx> they put ruby 1.8.7 on for me
22:40:37 <Axman6> i want a nice small pre compiled release of GHC :(
22:40:38 <mmorrow> electronx: since 6.10 is coming out within the week (i think), try to get that
22:40:52 <electronx> a week? really
22:40:52 <Axman6> what's new and cool in 6.10 anyway?
22:40:58 <electronx> Unicode :)
22:41:17 <dolio> All sorts of stuff.
22:41:19 <mmorrow> unicode, quasiquotes, parallell garbage collector, type families that work, ....
22:41:30 <dolio> View patterns.
22:41:35 <electronx> my project is due friday
22:41:55 <electronx> so probably no ghc 6.10
22:42:18 <mmorrow> 6.8.3 then i guess
22:42:55 <Myoma> view pattern -> cool!
22:43:26 <mmorrow> syntax error
22:43:38 <mmorrow> :)
22:43:58 <Myoma> parallell garbage collector?!
22:44:07 <mmorrow> s/l//
22:44:09 <mmorrow> yes!
22:44:09 <electronx> mmorrow are you a lecturer?
22:44:10 <Myoma> but.. haroop said ...
22:44:22 <Myoma> oh wait
22:44:27 <Myoma> it's ocaml that doesn't have one
22:44:38 <mmorrow> electronx: no
22:44:49 <Myoma> how is a parallel gc implemented? :)
22:44:58 <Myoma> "very carefully"
22:45:03 <mmorrow> electronx: that was my spelling error i was correcting ;)
22:45:32 <mmorrow> vewwwy cawwwwwefully, wascally wabbit
22:46:15 <ddarius> parallel /= concurrent/incremental
22:46:35 <electronx> i never realized how slow ruby was till i tried doing some real work in it
22:46:51 <electronx> its a shame really
22:46:54 <dons> it's pretty much the slowest thing short of shell.
22:47:09 <electronx> i had almost finished my project
22:47:09 <ddarius> Is it faster than shell?
22:50:09 <mmorrow> ddarius: i thought it was implemented in shell ...
22:51:16 <electronx> lol
22:51:31 <dolio> Nah. It's implemented in C. You can't implement a language without C.
22:51:37 <electronx> its more popular then haskell
22:52:04 <electronx> is entry barrier for haskell to high or something?
22:52:29 <Myoma> Am I implemented in C?
22:52:36 <ddarius> Myoma: Yes.
22:52:38 <mmorrow> yes!
22:52:41 <Myoma> :((
22:53:05 <mmorrow> would you feel better if you were implemented in ruby?
22:53:08 <Myoma> I bet it's a VM implemented in Prolog
22:53:36 <electronx> how is prolog more popular then haskell
22:53:47 <dolio> Is it?
22:53:49 <electronx> according to tiobe
22:53:58 <dolio> Who?
22:54:19 <electronx> http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
22:54:27 <lambdabot> Title: TIOBE Software: The Coding Standards Company
22:54:52 <mmorrow> wow, anywhere money is involved, you know the truth is being told!!
22:54:56 <ddarius> TIOBE hardly matters.  Also Prolog is like two times older than Haskell and is -the- quintessential logic language.
22:55:06 <Myoma> :D lol
22:55:17 <electronx> so how do we know how popular a lang is?
22:55:33 <Adamant> TIOBE has obvious problems.
22:56:08 <Myoma> I want to try out some new logic languages
22:56:13 <ddarius> electronx: We don't except in very, very broad strokes.
22:56:18 <Adamant> for one, some languages are hard to search for on search engines
22:56:44 <Adamant> Myoma: try Mercury?
22:57:41 <electronx> i havn't seen anything real implemented in haskell
22:57:50 <electronx> except haskell and darcs
22:57:54 <mmorrow> heh
22:58:16 <mmorrow> what's real?
22:58:20 <ddarius> and ghc and xmonad and Programatica and Yarrow and hmp3 and ...
22:58:34 <Myoma> Yarrow is nice
22:58:44 <electronx> those are crappy little apps except for ghc
22:58:49 <mmorrow> and many other languages, and financial-services software, and ...
22:59:23 <the_unmaker> oh yeah!
22:59:25 <the_unmaker> haskell
22:59:27 <electronx> most of the stuff i would classifiy as utilities
22:59:36 <the_unmaker> so is this happs thing usable for liek production websites?
22:59:45 <dolio> Is that better or worse than the crappy web apps people write in ruby?
22:59:45 <Myoma> electronx: You want to see real programs in haskell?
22:59:45 <dons> sure.
22:59:47 <Cale> the_unmaker: Apparently :)
23:00:03 <electronx> Myoma: ya
23:00:06 <Myoma> electronx: so write one :P
23:00:06 <Cale> electronx: What classifies as "real"?
23:00:10 <dons> openonomy is using happs. hpaste has been up for 12-15 months now.
23:00:17 <dons> so yeah, real apps.
23:00:26 <Myoma> electronx: (I'm half joking, it's actually easier to do than you would probably expect)
23:00:31 * dons tries to imagine what unreal apps would be
23:00:35 <dons> ones that crashed a lot?
23:00:37 <the_unmaker> I thought the ruby on rails train was go go going
23:00:40 <electronx> Myoma: i don't want to go down a street which may turn out to be a dead end road
23:00:41 <the_unmaker> har
23:00:49 <the_unmaker> most apps at my work are java
23:00:51 <the_unmaker> :(
23:01:08 <Myoma> electronx: OK ‚Äî back to C programming then?
23:01:17 <electronx> java maybe
23:01:22 <Cale> electronx: There's no particular reason why any given application I can think of could not be written in Haskell.
23:01:39 <DrSyzygy> Cale: you know any cohomology?
23:01:47 <Cale> DrSyzygy: A bit.
23:01:52 <Cale> DrSyzygy: But not a whole lot.
23:02:04 <DrSyzygy> Mind if I query you?
23:02:09 <Adamant> electronx: FWIW, Galois Connections has more or less bet it's company on Haskell
23:02:12 <electronx> haskell severly lacks in tools
23:02:12 <Cale> I don't mind.
23:02:19 <dons> electronx: what kind of tools?
23:02:22 <Cale> But I'm at a very introductory level here :)
23:02:33 <dons> i'm wondering what i'm missing from my day to day job, that i've not noticed.
23:02:36 <Myoma> tools.. it doesn't matter what they do .. they just have to exist
23:02:46 <Myoma> stuff that frobs and .. such
23:02:49 <dons> like debuggers, profiling, parser generators, documentation tools?
23:02:57 <electronx> ya
23:02:59 <dons> build systems, ..
23:03:03 <dons> so we have all those things.
23:03:04 <mmorrow> haha
23:03:14 <dons> ghci-debugger, ghc-prof, happy, haddock, alex, cabal, cabal-install
23:03:27 <dons> clearly, haskell's lacking in wide promotion of its great tools.
23:03:31 <mmorrow> (haha at the perception that such things don't exists)
23:03:38 <Myoma> you need a 1) frobnicator and 2) automatic refactorizer
23:03:47 <electronx> those tools really suck imho
23:03:49 <dons> electronx: have a look at hackage.haskell.org. it's now 1/4 the size of python's online library set.
23:03:52 <dons> electronx: how?
23:03:56 <dons> in comparison to?
23:03:58 <Adamant> how can they suck if you haven't used them?
23:04:03 <Myoma> electronx: I agree that the build system sucks ...
23:04:09 <dons> cabal?
23:04:12 <Adamant> since you didn't even know what they were
23:04:21 <Myoma> dons yeah, only because I'm too stupid to get it to work properly
23:04:23 <electronx> how about a proper ide for one
23:04:31 <Adamant> tried Visual Haskell?
23:04:36 <dons> an ide. yes. that's true.
23:04:38 <electronx> thats really old
23:04:44 <Adamant> seems like it might be up your alley
23:04:46 <dons> for java people, the ide issue is an odd one
23:05:01 <mmorrow> i wouldn't use an ide even if one existed
23:05:03 <dons> we just use edtirs
23:05:12 <Myoma> dons, but I can write haskell so it should be _easier_ than that to get cabal to work right?
23:05:19 <mib_95mn8zw1> Firefox could not install this item because of a failure in Chrome Registration. Please contact the author about this problem.
23:05:23 <dons> Myoma: well, what's wrong with cabal?
23:05:38 <dons> seems to work pretty well. we're getting 5-8 new libraries a day in cabal.
23:05:45 <electronx> dons: doesnt work in windows
23:05:50 <dons> cabal? sure it does.
23:05:59 <dons> it's very explicitly portable.
23:06:03 <mmorrow> electronx: does anything work in windows?
23:06:05 <dons> like most haskell, that doesn't use the unix lib.
23:06:08 <electronx> :0
23:06:19 <dons> electronx: how doesn't it work? specifics!
23:06:37 * dons wonders if electronx just has an out of date toolchain
23:06:40 <Myoma> dons, some bugs which make it impossible to build ghc unless you know how cabal works
23:06:46 <electronx> well how does it work in windows is the question
23:07:03 <mmorrow> electronx: you said you're using 6.4, right
23:07:17 <dons> oh. 6.4? that's two years old now.
23:07:17 <electronx> no at home i use 6.8.3
23:07:21 <dons> ok. good.
23:07:24 <mmorrow> phew
23:07:26 <DrSyzygy> ele: you asserted it doesn't work. not the same as asking whether it works
23:07:45 <dons> cabal works on windows. i think maybe electronx just hasn't used the tools yet.
23:08:09 <electronx> i have but could not get it to work this was a few months ago
23:08:20 <ddarius> "Bah.  I haven't used the tools yet because they all suck!"
23:08:23 <dons> have you tried cabal-1.4.x ?
23:08:34 <mib_95mn8zw1> it want install any updates are addons to firefox,it also crashs at startup
23:08:42 <dons> mib_95mn8zw1: wrong channel.
23:09:18 <dons> electronx: you can get an overview of the toolchain here, http://www.cse.unsw.edu.au/~dons/papers/CPJS08.html
23:09:18 <electronx> dons don't know which version it was
23:09:19 <araujo> Hello
23:09:19 <lambdabot> Title: Haskell: Batteries Included
23:09:31 <dons> electronx: ghc-pkg list Cabal
23:09:34 <Myoma> hi
23:09:35 <Cale> electronx: For the most part, just running GHCi in a terminal along with my text editor in another window, is more than enough of an IDE, I find.
23:09:54 <mmorrow> same here
23:09:59 * Myoma 3
23:10:03 <Cale> electronx: You might have different tastes, but I would recommend trying that and seeing if for some reason there is a problem with it.
23:10:04 <electronx> hmmmm
23:10:35 <dons> there seems to be enough for people to be getting their work done, so i'd say try the latest cabal, haddock and friends, then report back.
23:11:23 <dons> general rule: the more your tools can do, the more people expect your tools to do.
23:11:36 <electronx> lol
23:11:52 <electronx> hardly i think
23:11:59 <ddarius> It's quite true.
23:12:10 <ddarius> You can even "deduce" it.
23:12:15 <electronx> lol
23:13:36 <dons> electronx: well, anyway, what was the problem again with all the tools sucking? and the missing debuggers, profilers, parsers, doc generators that aren't missing?
23:13:40 <the_unmaker> I heard some drivel about darcs being slow, is that an evil fud?
23:13:53 <Cale> the_unmaker: It's true of darcs 1
23:14:02 <Cale> the_unmaker: But as far as I can tell, untrue of darcs 2
23:14:20 <mmorrow> yeah, i was pleasantly surprised by the improvement in darcs2
23:14:32 * ddarius should probably upgrade to darcs 2 sometime...
23:15:28 <Myoma> so dragon book recommends using flex?
23:15:38 <Myoma> and this is some parser generator for C ?
23:15:39 <dons> Myoma: that's 'alex' in modern speak.
23:15:45 <mmorrow> ==yacc
23:15:50 <mmorrow> err
23:15:51 <mmorrow> lex
23:15:52 <Myoma> dons; the problem is it's _not_
23:15:55 <mmorrow> bison==yacc
23:16:04 <Myoma> it seems a shame that all these people would write compilers in C instead
23:16:18 <ddarius> The dragon book is pretty old...
23:16:28 <Myoma> someone is reading it today :|
23:17:05 <the_unmaker> so what about haskell v common lisp
23:17:17 <Myoma> @protontorpedo
23:17:18 <lambdabot> can I build something that lets laptop users sync contacts and client dta over the net?
23:17:20 <Myoma> @protontorpedo
23:17:20 <lambdabot> how does haskell compare to say java?
23:17:21 <the_unmaker> there is a lot of talk of common lisp being a language where you can add any feature..
23:17:31 <scriptdevil> http://www.haskell.org/happy/doc/html/sec-using.html In the lexer section, we have lexer (c:cs) much before all specific characters. Isnt parsing done top down?
23:17:32 <lambdabot> Title: ChapterÔøΩ2.ÔøΩUsing Happy
23:18:09 <mrd> dragon book devotes far too much time to parsing.  it's a topic that was interesting in the 70s.  maybe.
23:18:44 <dons> yeah.
23:18:50 <ddarius> the_unmaker: That's not really all that true in a meaningful way, though in one sense it is quite true.  In some ways Scheme is better for that.
23:18:53 <dons> we need 'Modern Compiler Implementation in Haskell'
23:19:00 <Myoma> dons, right!
23:19:01 <dons> big gap in the market.
23:19:09 <mmorrow> very.
23:19:16 <scriptdevil> Maybe the guys creating pugs can pull out some doc
23:19:18 <ddarius> I don't think there would be a huge value-add over the ML one.
23:19:30 <dons> that's true enough. but it would be sexier.
23:19:34 <mmorrow> ddarius: link!
23:19:37 * Myoma would like to coauthor ..
23:20:05 <dons> simonmar and spj should write one. compilers and runtime systems for the 21st century
23:20:21 <Cale> scriptdevil: Handling of pattern matching is indeed done top to bottom.
23:20:31 <Adamant> the_unmaker: you don't have Lisp-style metaprogramming in Haskell unless you use Liskell, but you do have Template Haskell which is the regular Haskell method for metaprogramming. You can use laziness and higher-order functions to solve many of the reasons you need Lisp macros, but not all.
23:20:36 <Cale> scriptdevil: However, if none of the guards succeed, you get a fall through to the next pattern.
23:20:41 <ddarius> mmorrow: link to what?
23:20:43 <mmorrow> Myoma: we can write version 2
23:20:54 <mmorrow> ddarius: <ddarius> I don't think there would be a huge value-add over the ML one.
23:20:57 <Myoma> yay
23:20:58 <the_unmaker> Adamant: cool
23:21:02 <Cale> scriptdevil: (which is what is happening in that case)
23:21:05 <ddarius> @google "Modern Compiler Implementation in ML"
23:21:07 <mmorrow> ddarius: what was that in reference to?
23:21:07 <lambdabot> http://www.cs.princeton.edu/~appel/modern/ml/
23:21:07 <lambdabot> Title: Modern Compiler Implementation in ML
23:21:10 <mmorrow> awesome
23:21:22 <the_unmaker> there is another question: what is the difference between ml and haskell?
23:21:28 <Adamant> the_unmaker: I think it's worth learning both Scheme and Haskell
23:21:29 <mmorrow> 1998!?!
23:21:31 <mmorrow> pfft
23:21:34 <Elly> Haskell is lazy and has typeclasses :P
23:21:36 <ddarius> the_unmaker: ML will make your eyes bleed.
23:21:40 <Elly> also monads instead of imperativeness
23:21:40 <scriptdevil> Cale: isAlpha matches [a-zA-Z] only?
23:21:40 <the_unmaker> lol
23:21:42 <Cale> the_unmaker: Haskell is lazy and has typeclasses, and better control over effects.
23:21:51 <scriptdevil> Cale: thanks
23:21:51 * Elly is in the process, in fact, of writing a compiler in SML
23:21:55 <the_unmaker> <--not into my eyes bleeding thank you
23:22:06 <Elly> SML does not make my eyes bleed
23:22:07 <Cale> scriptdevil: I think so... unless it's somehow including some unicode characters in some way I'm unsure of :)
23:22:11 <ddarius> mmorrow: Better than 1986
23:22:23 <scriptdevil> Cale: thanks a lot
23:22:39 <mmorrow> ddarius: indeed, a sharp stick in the eye is better than a nuclear warhead
23:22:50 <mmorrow> :)
23:23:18 <Adamant> I think Haskell currently is a better bet for the future. having one main implementation and most effort being put into that implementation really helps in the long run.
23:23:32 <Elly> the thing that I really, really miss from Haskell in SML though
23:23:33 <ddarius> Computer geeks link too much.  'dragon book' to Google means the dragon book.
23:23:45 <Elly> is that in SML, you cannot do this: val x : a -> b; fun x y = ...
23:24:15 <Myoma> Elly, what
23:24:24 <Adamant> ddarius: it's also funny when computer terms that have a origin in non-computer language link directly to the computer term implementation first instead of second.
23:24:30 <ddarius> ML isn't going anywhere anytime soon.
23:24:38 <dons> OT: funny, politics, http://uk.youtube.com/watch?v=vBH1gleAyf4
23:24:39 <lambdabot> Title: YouTube - Tina Fey as Sarah Palin SNL
23:24:40 <the_unmaker> ML has an appserver, amazing
23:24:47 <Myoma> ddarius: yes it is! .. away :p
23:24:49 <Cale> dons: I was just watching that
23:24:55 <Elly> Myoma: you can't declare the type of a value apart from its binding :(
23:25:03 <Myoma> Elly, oh does that matter?
23:25:11 <Elly> Myoma: in Haskell you can do: x :: a -> b; x = ...
23:25:13 <Elly> Myoma: yes!
23:25:22 <Myoma> Elly, why would you ever write x :: a -> b ?
23:25:34 <Elly> Myoma: mixing the explicit types with the pattern-match for arguments makes it much harder to read either of them
23:25:39 <Elly> Myoma: track down type errors
23:25:42 <mrd> fun x (y:a):b
23:25:49 <mrd> but yea
23:25:55 <Elly> mrd: I know; my point is that you cannot separate them like you can in haskell
23:26:04 <dons> Cale: not even broadcast on the west coast yet :) internets rule.
23:26:06 <mrd> hey, what do you do to get around lack of functional record upate?
23:26:13 <Elly> I don't so far
23:26:13 <Myoma> I have not ever noticed that type annotations help to track down type errors
23:26:17 <Elly> I am hoping it will go away
23:26:24 <Elly> Myoma: really? I find them immensely useful
23:26:31 <Myoma> that's really weird
23:26:34 <mrd> that was a real killer for me in SML
23:26:35 <Elly> I find that a type error causes the compiler to infer wrong types far away in the program
23:26:37 <Myoma> I think I am the only one Elly
23:26:44 <mrd> Elly: even using modules?
23:26:49 <Elly> and adding explicit types pushes it back one layer of wrongness
23:26:52 <Myoma> haskell doesn't infer the wrong types.
23:26:53 <Adamant> dons: I was wondering if that was Fey, she wasn't credited
23:27:00 <Myoma> it tells you "This program makes no sense"
23:27:03 <Elly> mrd: signatures can declare types, but functions that aren't in the signature lose
23:27:11 <Elly> Myoma: SML will try to infer types as far as it can and fail at the end
23:27:20 <Myoma> Elly, what?
23:27:28 <Elly> Myoma: so to track back to the original type error, you add type annotations
23:27:30 <mrd> SML should be able to infer all types not in signatures
23:27:37 <Elly> mrd: unless you have a type error
23:27:40 <mrd> mm
23:27:41 <Elly> mrd: which is why I do that
23:27:49 <Myoma> If you have a type error it tells you that there is a type error.. right..?
23:27:53 <Elly> yes
23:28:06 <Elly> but it tells you where the error manifests, not where the error came from
23:28:16 <Elly> adding annotations pushes the manifestation closer to the source
23:28:17 <Myoma> and adding annotations changes the place it tells you about the error?
23:28:17 <mrd> this seems like the sort of thing that would strike less in SML than Haskell
23:28:21 <Elly> repeat until manifestation is source
23:28:22 <Elly> yes
23:28:35 <Myoma> assuming you have 5 pages of correct code
23:28:38 <mrd> since SML's type system is simpler, and requires annotations on modules
23:28:41 <Myoma> and I open one up and write
23:28:50 <Myoma> 78 = "wobble"
23:28:57 <Myoma> what happens?
23:29:03 <Elly> Myoma: a type mismatch at that line
23:29:23 <Elly> Myoma: the difficulty is when, for example, you have a dozen cases that all use foo, and in the topmost case you have used it the wrong way
23:29:38 <Myoma> so is the problem only really an issue if you have 5 pages of _probably correct but contains several bugs_ code?
23:29:41 <mrd> a = b; and far away is defined a and b to have different types
23:29:42 <Elly> Myoma: then SML will infer the wrong type for it and claim the other (correct) cases are in error
23:29:49 <dons> Cale: hehe, now it finally runs on tv.
23:29:56 <Elly> Myoma: yes, that is when the problem occurs
23:30:06 <Cale> dons: I download all my TV shows anyway.
23:30:14 <Elly> I've taken recently to writing very small functions and building in between to reduce the occurence of this problem
23:30:17 <Cale> (http://eztv.it/frontpage.php)
23:30:17 * Myoma just never gets into that situation :p
23:30:52 <Elly> it happens sometimes
23:31:05 <dons> cheers, Cale.
23:31:15 <Elly> I wish, mostly, that there were nicer syntax for annotating types
23:31:25 <the_unmaker> hey they have something called hadoop at work
23:31:29 <Cale> Their coverage of SNL is a bit spotty, but a lot of things they do a very nice job of.
23:31:45 <the_unmaker> it let a group of computers supposedly work together to quickly process problems
23:31:57 <the_unmaker> is there something like that in haskell?
23:32:26 <dons> mpi bindings.
23:32:43 * Elly sleeps
23:33:59 * Myoma has to write a very strange function
23:34:20 <Myoma> zipping a list with hypothesis ..
23:34:47 <ddarius> Myoma has achieved the ideal.  She simply writes correct code in the first place.
23:35:09 <Myoma> ddarius: it takes 'slightly' longer .. :)
23:36:30 <the_unmaker> I like linux, but now I want to learn to program.
23:36:36 <the_unmaker> <----probably crazy
23:37:06 <the_unmaker> compiling haskell port on freebsd 7
23:37:07 <the_unmaker> :)
23:37:15 <the_unmaker> <----feels sexy
23:38:45 <ddarius> I can honestly say that it is not everybody who can follow simple directions.
23:40:11 <the_unmaker> <----I can follow directions with holes in them
23:40:17 <the_unmaker> <----such is life of linux admin
23:40:30 <Myoma> =<< whoooosh
23:41:14 <the_unmaker> oh look at that ghc comes with an html users guide
23:42:10 <mc__> Is it possible to write list comprehension that generates the multiplies of a number like: 2,4,8,16,...  I was able to do it with a function and explicit recursion, but thats not what I want
23:42:29 <Myoma> mc__: What is the explicit version? Can you paste it here
23:42:38 <newsham> would be nifty if someone made a hadoop-a-like that did list homomorphisms on many machines
23:43:13 <newsham> mc: you want to generate 2*x for all x?
23:43:31 <newsham> or 2^x for all x?
23:44:44 <ddarius> > iterate (2*) 2
23:44:46 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
23:44:56 <newsham> he wants a list comprehension
23:45:00 <trofi> > [2^x | x <- [0..]]
23:45:02 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:45:07 <mc__> lol...exactly that
23:45:20 <newsham> yay, trofi did your homework.
23:45:30 <mc__> man, that shouldn't have been that hard to figure out
23:45:40 <dolio> ddarius' is probably more efficient.
23:45:40 <bd_> > (flip iterate 1 . (*)) 2
23:45:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:46:20 <trofi> the prettiest colution is on uncyclopedia/haskell
23:47:02 <newsham> fix$(<$>)<$>(:)<*>((<$>((:[{-)]$-}])<$>))(=<<)<$>(*)<$>(*2))$1
23:47:06 <newsham> > fix$(<$>)<$>(:)<*>((<$>((:[{-)]$-}])<$>))(=<<)<$>(*)<$>(*2))$1
23:47:07 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:47:08 <bd_> @hoogle fix
23:47:08 <lambdabot> Data.Function fix :: (a -> a) -> a
23:47:08 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
23:47:08 <lambdabot> module Control.Monad.Fix
23:47:14 <bd_> @hoogle (<$>)
23:47:15 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:48:48 <mmorrow> > fix (scanl (+) 1)
23:48:49 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:49:12 <ddarius> > let pows = 1:map (2*) pows
23:49:13 <lambdabot>   mueval: Prelude.read: no parse
23:49:15 <ddarius> > let pows = 1:map (2*) pows in pows
23:49:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:49:33 <Myoma> > fix ((1:) . map (*2))
23:49:35 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:49:48 <mmorrow> > fix ((0:) . scanl (+) 1)
23:49:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:50:04 <Myoma> @src scanl
23:50:05 <lambdabot> scanl f q ls = q : case ls of
23:50:05 <lambdabot>     []   -> []
23:50:05 <lambdabot>     x:xs -> scanl f (f q x) xs
23:53:37 <newsham> > ([1,2,4]...)
23:53:38 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
23:54:14 <Randroid> >  2 + 2 {- Impressive, no? -}
23:54:15 <lambdabot>   4
23:54:50 <Myoma> > ([2,3,5,7,11]...)
23:54:51 <lambdabot>   [2,3,5,7,11,22,48,100,192,341,567,893,1345,1952,2746,3762,5038,6615,8537,10...
23:55:07 <Myoma> > ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1]...)
23:55:09 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1048576,20971521,221249536,16357...
23:55:14 <dolio> Heh.
23:55:21 <newsham> > ([1,4,9,25]...)
23:55:22 <lambdabot>   [1,4,9,25,61,126,229,379,585,856,1201,1629,2149,2770,3501,4351,5329,6444,77...
23:55:35 * Myoma finds a great new source for "what comes next in the sequence" puzzles
23:55:59 <newsham> > ([1,4,9,16]...)
23:56:00 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
23:56:06 <electronx> has anyone written a we framework for haskell
23:56:10 <electronx> web*
23:56:12 <electronx> ?
23:56:16 <newsham> ?go happs
23:56:23 <electronx> happs is a server
23:56:28 <lambdabot> http://happs.org/
23:56:28 <lambdabot> Title: HAppS ‚Äî The Haskell Application Server
23:56:46 <newsham> happs is an application server, not a web server.
23:57:24 <trofi> why not? :]
23:57:24 <mmorrow> electronx: what features (in an enumerated list) would you expect from an app server? (i ask because i'm genuinely curious)
23:57:59 <electronx> dunno what ya mean?
23:58:20 <newsham> session state management,  presentation, input parameter parsing, ...
23:58:31 <mmorrow> electronx: something like (1) generate sql code from haskell data declarations (from haskell src), (2) autogen ...., (3) auto ....
23:58:34 <mmorrow> or something?
23:58:37 <electronx> ah
23:58:41 <electronx> m v c
23:59:04 <electronx> sessions
23:59:15 <electronx> html templating
23:59:18 <electronx> etc
23:59:22 <Myoma> etC?
23:59:24 <newsham> happs is your prog
23:59:36 <electronx> db backend
23:59:40 <electronx> caching
23:59:45 <electronx> hot swapping
