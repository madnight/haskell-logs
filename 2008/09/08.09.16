00:00:41 <Baughn> @type gfoldl
00:00:42 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
00:01:02 * Baughn winces
01:00:56 <BeelsebobWork> is it possible to express a truely polymorphic fixed point in Haskell's type system -- i.e. one that takes a function of type forall a b. a -> b, and runs it with the different type each time, eventually returning something of type exists c . c.  I'm guessing that it's not, but I'm not sure I see a reason why it needs dependant types
01:11:51 <mmorrow> Beelsebob: what do you mean "the different type each type"?
01:12:05 <BeelsebobWork> replace the latter type with time
01:12:13 <BeelsebobWork> oh, in fact I did say that
01:12:38 <mmorrow> err, no you're right
01:12:43 <mmorrow> s/type/time/
01:13:12 <BeelsebobWork> ah but you did make me spot the not quite dependant type in my thinking
01:13:21 <mmorrow> heh
01:14:02 <BeelsebobWork> my thinking was "supposing you had a function that when given integers produces characters, and when given characters produces floats, and when given floats produces floats, you could still compute a fixed point"
01:14:07 <BeelsebobWork> but such a type isn't expressable in haskell
01:14:11 <mmorrow> BeelsebobWork: one sec, i'll show you some haskell code generated by the cayenne compiler
01:14:19 <mmorrow> it's interesting
01:14:24 <BeelsebobWork> that would be nice
01:14:26 <Cale> electronx: still awake?
01:15:36 <quicksilver> BeelsebobWork: how could you detect when it was fixed?
01:15:43 <Mitar> is there a function for monadplus which would iterate a monadic function for example 10 times if it is failing? so if it succeeds it returns a result, otherwise it runs it again (until it succeeds or until it has tried 10 times - in later case it fails with the last error)
01:15:46 <Cale> @tell electronx Check out this paper re: things one can do regarding performance :) http://www.cse.unsw.edu.au/~rl/publications/recycling.html
01:15:46 <lambdabot> Consider it noted.
01:16:16 <BeelsebobWork> quicksilver: equality -- which I guess requires dynamic typing
01:16:23 <BeelsebobWork> in that you need to test type equality first
01:16:28 <BeelsebobWork> actually no it doesn't
01:16:48 <Cale> Mitar: msum (replicate 10 x) ?
01:16:50 <BeelsebobWork> it requires static typing to say equality is always false when called with arguments of different types -- which is an interesting statement to make
01:17:03 <Cale> :t msum
01:17:05 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:18:00 <BeelsebobWork> why is that not forall (m, n :: * -> *) a. (MonadPlus m, Monad n) => n m a -> m a
01:18:49 <dibblego> (Foldable n)
01:18:54 <Svrog> is cayenne still being developed?
01:18:54 <BeelsebobWork> indeed
01:18:59 <BeelsebobWork> was just thinking that wouldn't work with IO
01:19:18 <Cale> :t Data.Foldable.msum
01:19:20 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (MonadPlus m, Data.Foldable.Foldable t) => t (m a) -> m a
01:19:24 <BeelsebobWork> ah, cool
01:19:36 <BeelsebobWork> just no one thought of it when writing the prelude?
01:19:45 <Cale> Foldable is very recent.
01:20:10 <Cale> (whereas MonadPlus predates Haskell 98)
01:20:35 <quicksilver> BeelsebobWork: A function which when given integers produces floats, and when given floats produces floats, doesn't have type forall a b . a -> b
01:20:43 <Wild_Cat> @hoogle [Maybe a] -> [a]
01:20:43 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
01:20:43 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
01:20:43 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:20:48 <Cale> Also, ordinarily, msum is just foldr mplus mzero anyway
01:20:59 <BeelsebobWork> quicksilver: no, that was the flaw in my thinking -- as I explained in the channel
01:21:00 <quicksilver> BeelsebobWork: a function of type forall a b . a -> b can take any input type and produce any output type (chosen by the caller, as it were)
01:21:06 <quicksilver> sorry, maybe I missed something
01:21:27 <quicksilver> ah yes, you did say :)
01:21:34 <BeelsebobWork> quicksilver: I don't think the type of the functions I'm thinking of is expressable in Haskell's type system
01:21:44 <BeelsebobWork> and probably because functions with that kind of type occur very very rarely
01:21:46 <quicksilver> what you suggested has a type more like forall a . a -> (exists b . b)
01:21:51 <BeelsebobWork> indeed
01:22:27 <Cale> Did anyone else read "Recycle Your Arrays!"?
01:22:31 <quicksilver> which is expressible in GHC-extensions, and you could compose it.
01:22:37 <quicksilver> but type-equality isn't observable in haskell
01:22:51 <quicksilver> without 'cheating' and using Typeable
01:23:17 <quicksilver> however, forall a . Typeable a => a -> (exist b . Typeable b => b) would work
01:23:43 <quicksilver> and if you add an Eq constraint I think you can observe the fixed point you wanted.
01:23:46 <BeelsebobWork> quicksilver: yeh, I'm not sure the type of fix is expressable once you express the type of the function though
01:24:07 <BeelsebobWork> fix :: forall a . (a -> (exists b . b)) -> (exists c . c)?
01:24:32 <BeelsebobWork> one would hope that there was some relationship between the b and c
01:24:53 <quicksilver> fix :: forall a . (Typeable a, Eq a) => a -> AnyEqTypeable -> AnyEqTypeable
01:25:14 <quicksilver> where data AnyEqTypeable = forall b . (Typeable b, Eq b) => AnyEqTypeable b
01:25:34 <BeelsebobWork> heh, that's fun
01:26:43 <mmorrow> Beelsebob: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=47
01:27:05 <mmorrow> each expression is wrapped in cast, where cast = unsafeCoerce#
01:27:15 <BeelsebobWork> fun
01:27:18 <mmorrow> heh
01:27:34 <BeelsebobWork> yeh, that's pretty nasty
01:27:36 <mmorrow> but i believe this is the only way to get what you said
01:27:51 <mmorrow> ie, the type system is "turned off"
01:27:55 <BeelsebobWork> heh
01:28:02 <BeelsebobWork> so how does it deal with equality then?
01:28:22 <mmorrow> heh, that's a direct quote btw
01:28:58 <mmorrow> Beelsebob: by this point, it's already verified the programs correctness with its own type system, so this is the equiv of machine code from the point of view of cayenne
01:29:06 <BeelsebobWork> sure
01:29:17 <mmorrow> so the answer is, i've no idea :)
01:29:21 <mmorrow> hehe
01:29:26 <BeelsebobWork> lol
01:29:50 <mmorrow> here's a dir with haddock docks + a module dep graph for cayenne http://code.haskell.org/~morrow/cayenne/
01:30:01 <lambdabot> Title: Index of /~morrow/cayenne
01:30:02 <mmorrow> i'm finishing the Setup.hs for it actually as we speak
01:30:13 * Cale notices that wine takes an exceptionally long time to build :)
01:30:25 <Cale> This is almost as bad as GHC already :)
01:30:35 <mmorrow> whine?
01:30:38 <mmorrow> :)
01:30:43 <BeelsebobWork> Cale: not really that surprising given that you're building the whole of windows essentially
01:30:50 <Cale> I suppose so :)
01:31:19 <mmorrow> i've read that it's actually good enough to run photoshop/and equivalently intensive program in
01:31:24 <mmorrow> suprised me
01:31:37 <Wild_Cat> it's good enough to run most DirectX 9 games, actually.
01:31:38 <Svrog> mmorrow: is cayenne still being developed?
01:31:39 <Cale> It also does a fairly good job of games these days.
01:31:40 <mmorrow> s/and equiv.../an equiv.../
01:31:53 <Cale> I've played Portal and HL2 in it with no problems.
01:31:53 <BeelsebobWork> I think DX 9 games is pushing it
01:32:05 <BeelsebobWork> e.g. it doesn't work wonderfully on WoW -- which is DX 7
01:32:10 <Cale> I'm about to try Spore, but the beta is supposed to handle that better than the release version.
01:32:26 <Wild_Cat> I was extremely impressed when I tried it out at a LAN party, expecting a few hours of configuration woes, yet double-clicked warcraft3.exe and everything worked out of the box.
01:32:31 <mmorrow> Svrog: the webpage was last update in 1998 ;). i asked augustss if i could put it on hackage, he said package it and send him the patches and he'll upload.
01:32:39 <mmorrow> i'm almost done with packaging
01:32:41 <Svrog> ah
01:33:38 <Wild_Cat> it can even use native DLLs if its builtins lack functions. Which is how I've been trying out the Touhou Project shooters last week.
01:33:40 <Svrog> i was just recently looking at agda and cayenne and i had the impression that cayenne was no longer developed so checking out agda was more worthwhile
01:33:43 <mmorrow> Svrog: http://code.haskell.org/~morrow/cayenne/haddock/
01:33:44 <lambdabot> Title: cayenne-0.0: Cayenne
01:34:11 <Svrog> so i was just checking whether i might have been wrong about that
01:44:08 <Myoma> is restricting a functions domain by a predicate a monad?
01:47:19 <Mitar>  is there a monadplus version of find which would fail if there is no element matching a predicate?
01:47:40 <Myoma> :t find
01:47:41 <Mitar> red <- find isRed marks
01:47:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:47:44 <Mitar> for example
01:47:55 <Mitar> if there is no red in marks it should fail
01:48:01 <Myoma> :t maybe mzero return
01:48:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
01:48:20 <Myoma> :t (maybe mzero return . find ?p)
01:48:21 <lambdabot> forall (m :: * -> *) a. (?p::a -> Bool, MonadPlus m) => [a] -> m a
01:48:48 <Myoma> :t lookup
01:48:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
01:48:52 <Myoma> Mitar: I think it doesn't exist
01:49:04 <quicksilver> Mitar: just use maybe mzero return
01:49:12 <quicksilver> or name that if you wish.
01:51:10 <Mitar> what if I would use fromJust?
01:51:26 <Myoma> Mihar: would that work better?
01:51:52 <Mitar> i do not know ... fill plusmonad interpret its error as a mzero?
01:52:00 <Mitar> s/fill/will/
01:54:59 <plutonas> what exactly does this message mean: Couldn't match expected type `IO (Phrase -> Phrase)'  against inferred type `Phrase -> Phrase'. That there isn't any IO?
01:55:04 <Mitar>     No instance for (MonadPlus IO)
01:55:04 <Mitar>  ?
01:55:26 <Myoma> @instances MonadPlus
01:55:27 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
01:55:34 <plutonas> Mitar: hm, sorry i'm new and don't get it
01:55:50 <plutonas> but as there is a call to random in the function, shouldn't this be IO?
01:56:22 <Mitar> which random?
01:56:35 <plutonas> r <- randomIO :: IO Float
01:57:39 <ziman> plutonas, well, the error messages says you're using a (Phrase -> Phrase) function where the context requires an IO (Phrase -> Phrase) one
01:57:43 <ziman> *message
01:58:34 <plutonas> ziman: yes, but i don't exactly get what this means, because IO (phrase -> phrase) is supposed to mean that IO happens, and then it returns a phrase->phrase
01:58:43 <ziman> so you need to change the function or to change the context :) it would be clearer if you pasted the code
01:58:45 <plutonas> does the message mean that no IO happens?
01:58:46 <Mitar> a, plutonas, I was not answering to you ...
01:58:54 <plutonas> Mitar: oh
01:59:19 <plutonas> ziman: you mind if i paste privately? its homework and don't want to have it in the log
01:59:32 <Mitar> :-)
01:59:47 <Mitar> why not? asking for help is against rules?
02:00:09 <Mitar> i believe the idea is to learn - so if you will learn in a process ... that this is enough
02:00:26 <plutonas> Mitar: no asking for help is not against the rules, but pasting an answer (even incomplete) in a channel, so that people can google it later....
02:00:41 <Mitar> you should never paste to a channel
02:00:44 <Mitar> use hpaste
02:00:57 <plutonas> is this not googable?
02:01:17 <ziman> a quick fix would be to wrap the pure (Phrase -> Phrase) function in a return but that will not help you understand it, i guess
02:01:53 <Mitar> do not know .. try it
02:01:57 <ziman> plutonas, the context requires an IO action that, when performed, can have side effects and then produces a function (Phrase -> Phrase)
02:02:29 <ziman> what you have, is a pure Phrase -> Phrase function that does not need any I/O
02:02:29 <Mitar> but if we are talking about pasting, http://hpaste.org/10420 << i get a No instance for (MonadPlus IO) error here
02:02:46 <Myoma> Mitar, did you import the module that has the instance?
02:02:54 <Mitar> Control.Monad?
02:03:28 <ziman> plutonas, so you need to create an IO action that does nothing and just returns the pure function you already have
02:03:44 <plutonas> ziman: yes i understand that, byt my function is like functionname args = do; r <- randomIO :: IO Float; someother function call,
02:03:52 <plutonas> isn't randomIO an IO action?
02:04:27 <ziman> oh, i see.
02:04:48 <ziman> try parenthesizing: r <- (randomIO :: IO Float)
02:05:01 <Mitar> aaa Control.Monad.Error is
02:06:43 <plutonas> no parenthesizing doesn't help...
02:06:46 <plutonas> strange strange
02:06:49 <ziman> wait, i'm confused. The message says the pure function had type (Phrase -> Phrase)
02:07:25 <plutonas> yes without the parens, but this doesn't matter i thnik
02:07:38 <ziman> randomIO is IO Float; what's the relation?
02:08:13 <plutonas> as i understand IO(something), it means that the function does some IO and returns type something
02:09:17 <BeelsebobWork> plutonas: the parens are required because it was saying r had type IO Float
02:09:20 <BeelsebobWork> not the randomIO
02:11:14 <plutonas> hm, BeelsebobWork i'm not sure i get this last one...
02:13:24 <ziman> i thought the same but then i realized a <- b isn't an expression and can't have a type, can it?
02:14:11 <alar> does anybody have experience with numeric-prelude?
02:19:39 <sioraiocht> anyone know which library this error is demanding: ld: library not found for -ljpeg
02:20:38 <dcoutts_> sioraiocht: jpeg? :-)  I think I must not understand the question exactly
02:21:31 <sioraiocht> lol, well i have libjpeg, libgd...and it's still yelling at me
02:21:31 <sioraiocht> heh
02:22:06 <dcoutts_> sioraiocht: on linux or osx?
02:22:09 <sioraiocht> OSX
02:22:33 <dcoutts_> sioraiocht: is libjpeg a system lib on osx or do you need special linker paths to find it?
02:22:33 <yitz> @seen Lemmih
02:22:33 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
02:23:14 <sioraiocht> hrm, i'm not sure
02:23:18 <sioraiocht> dcoutts_: I'll look...
02:24:49 <sioraiocht> hrm, glib-config isn't showing -ljpeg...
02:24:54 <sioraiocht> just all the others...
02:25:52 <rlj> hi ppl
02:26:05 <rlj> how do i overload show for the type [Maybe Int] ?
02:26:17 <dcoutts_> > show [Nothing, Just 3]
02:26:19 <lambdabot>   "[Nothing,Just 3]"
02:27:12 <dcoutts_> rlj: is that ^^ what you meant?
02:27:23 <BeelsebobWork> rlj: newtype ListOfMaybeInts = LOMI [Maybe Int]
02:27:23 <BeelsebobWork> instance Show ListOfMaybeInts where
02:27:45 <rlj> dcoutts_: no, but let's start from the innermost part of the structure
02:28:44 <rlj> dcoutts_: i want to overload show for Maybe Int where the int can only be between 1 and 9. i want it to print a period (.) if the Maybe Int is Nothing and otherwise print the digit
02:28:58 <BeelsebobWork> rlj: you want what I just said
02:29:06 <dcoutts_> rlj: sounds like you want what BeelsebobWork suggests
02:29:13 <BeelsebobWork> the key to understanding why is that "type" does not introduce any new types
02:29:37 <Myoma> rlj: Why don't you not use 'show', just write a new function?
02:29:49 <BeelsebobWork> i.e. even the compiler cannot tell the difference between a value of type [Maybe Int] and one of type A (where A is defined as type A = [Maybe Int])
02:30:32 <rlj> Myoma: i'd prefer to have show work for my entire structure from the innermost part to the outermost. (a sudoku)
02:31:08 <sioraiocht> dcoutts_: turns out libjpeg is just a pain to install...
02:31:14 <BeelsebobWork> rlj: you may be misunderstanding the point of Show -- it doesn't provide pretty printing of data structures -- it provides printing of data structures in such a way that they're easily "Read"able back again
02:31:23 <BeelsebobWork> you may want the "Pretty" class instead
02:31:43 <Myoma> rlj, I don't know what you mean
02:32:10 <rlj> BeelsebobWork: alright then, in that case i might as well do specific prettyprinter functions which aren't overloaded shows
02:32:17 <BeelsebobWork> Myoma: I think he's saying he wants to be able to print a soduku board simply by calling "show mySodukuBoard"
02:32:40 <rlj> hm. thing is though
02:33:07 <rlj> BeelsebobWork: you said show helps to print data structures in a way that are easily readable back again
02:33:37 <rlj> BeelsebobWork: does that mean that by overloading show for a certain new type, i also get parsing back into the structure for free?
02:33:39 <BeelsebobWork> rlj: yes, so for example the standard instance of Show for lists has a complementing instance of Read which parses the output
02:33:45 <BeelsebobWork> no
02:33:53 <alar> BeelsebobWork: is there a class Pretty with default instances for all atandard types?
02:33:56 <BeelsebobWork> I mean that if you overload show, you break the complementing implementation of Read
02:34:09 <BeelsebobWork> there is such a class -- although I don't remember where it is
02:34:12 <BeelsebobWork> @hoogle pretty
02:34:13 <lambdabot> package pretty
02:34:13 <lambdabot> module Language.Haskell.Pretty
02:34:13 <lambdabot> Language.Haskell.Pretty class Pretty a
02:34:15 <rlj> BeelsebobWork: ok, so i still have to redo the work in reverse in overloading read then
02:34:20 <BeelsebobWork> there you go
02:34:25 <alar> cool
02:35:03 <Myoma> ♪ read "[Nothing,Just 1,Just 3]" :: [Maybe Int]
02:35:04 <lunabot>  [Nothing,Just 1,Just 3]
02:35:09 <rlj> BeelsebobWork: in which case it's not worth bothering. i'll just make my own prettyprinter and reader (to read from files)
02:35:22 <BeelsebobWork> indeed
02:35:26 <dcoutts_> BeelsebobWork: that pretty class is completely non-standard
02:35:28 <osfameron> we have to speak to the bot in unicode?!
02:35:39 <BeelsebobWork> dcoutts_: sure -- but it's a much better option than overiding Show
02:36:11 <dcoutts_> BeelsebobWork: indeed, just make it clear to people they have to make their own, that there isn't an existing one they can re-use
02:36:18 <BeelsebobWork> sure there is
02:36:24 <BeelsebobWork> it's in the pretty package on Hackage
02:36:24 <dcoutts_> BeelsebobWork: where?
02:36:32 <dcoutts_> no it isn't
02:36:41 <BeelsebobWork> that's what lambdabot just said
02:36:43 <BeelsebobWork> @hoogle Pretty
02:36:43 <lambdabot> module Language.Haskell.Pretty
02:36:43 <lambdabot> Language.Haskell.Pretty class Pretty a
02:36:43 <lambdabot> package pretty
02:37:05 <dcoutts_> BeelsebobWork: right, it's in the haskell-src package
02:37:11 <BeelsebobWork> oh, is it?
02:37:14 <dcoutts_> it's a custom per-package invention
02:37:22 <dcoutts_> we've also got a similar thing in Cabal
02:37:40 <dcoutts_> for application specific parsing and pretty-printing
02:38:03 <sioraiocht> dcoutts_: I have to make sure that certain flags are passed to the C-compiler when compiling the cbits portion of a cabal package
02:38:07 <sioraiocht> how would I modify it?
02:38:14 <sioraiocht> (the package, that is)
02:38:18 <dcoutts_> BeelsebobWork: the "package pretty" that hoogle reports there is just it matching a package name, not that the other entries are from that package.
02:38:31 <BeelsebobWork> kk
02:38:41 <BeelsebobWork> yeh, I'm just looking at it, I'd forgotten about that pretty printer
02:39:52 <dcoutts_> sioraiocht: cc-options
02:40:18 <sioraiocht> dcoutts_: as a field in the .cabal file?
02:41:42 <dcoutts_> sioraiocht: yep
02:41:52 <sioraiocht> dcoutts_: is there an ld-options as well? :)
02:42:41 <BeelsebobWork> how did linker ever get shortened to "ld"
02:43:17 <quicksilver> to match 'cc' and 'as' and 'ar', I guess
02:43:25 <quicksilver> people were very slow typists in those days
02:43:25 <BeelsebobWork> hmm?
02:43:33 <daf> linker, dynamic?
02:43:41 <BeelsebobWork> no, I mean where did the d come from
02:43:43 <daf> hmm, no
02:43:46 <quicksilver> 'LoaDer'
02:43:48 <quicksilver> I think?
02:43:53 <BeelsebobWork> ah, that would make sense
02:45:24 <dcoutts_> sioraiocht: indeed there is
02:45:50 <sioraiocht> dcoutts_: thanks
02:48:02 <sioraiocht> grr, I hate OS X today...
02:48:11 <sioraiocht> ld: warning in /usr/local/lib/libgmp.dylib, file is not of required architecture Undefined symbols: [etc]
02:48:16 <sioraiocht> anyone ever run into that?
02:49:33 <BeelsebobWork> sioraiocht: it indicates that your build of ghc is linking dynamically against libgmp, and you don't have it installed
02:49:50 <BeelsebobWork> or that the binary you have was built using such a version of ghc
02:50:07 <sioraiocht> why would ghc/ghci run fo eerything except this file, then?
02:50:26 <BeelsebobWork> because you're not doing anything with Integers in the other files
02:50:46 <sioraiocht> and I have those libgmp files installed
02:50:55 <BeelsebobWork> yes, but not for your architecture
02:51:10 <BeelsebobWork> i.e. either you have a PPC mac, but an Intel libgmp.dylib
02:51:13 <BeelsebobWork> or vice versa
02:54:43 <mgsloan> hrmm, that would be sweet if we had some reversable parsing combinators
02:55:19 <mgsloan> oh, heh.
02:55:27 <mgsloan> That conversation was a while ago
02:57:46 <sioraiocht> BeelsebobWork: I just recompiled libgmp, did not change the error message
02:58:11 <BeelsebobWork> sioraiocht: that doesn't sound too fun then -- where have you got ghc from?
02:58:18 <sioraiocht> BeelsebobWork: I compiled it
02:58:27 <BeelsebobWork> hmm
02:58:33 <BeelsebobWork> on PPC mac?
02:58:34 <sioraiocht> I think...
02:58:35 <sioraiocht> no
02:58:38 <sioraiocht> Intel mac
02:58:43 <sioraiocht> maybe i downloaded this version...
02:58:47 <sioraiocht> i could try recompiling =/
02:59:16 <BeelsebobWork> I'd suggest just "port install ghc" tbh
02:59:25 <BeelsebobWork> unless you need a specific version for some reason?
02:59:25 <sioraiocht> hah
02:59:33 <sioraiocht> I don't use any of the ports systems
02:59:38 <BeelsebobWork> how come?
02:59:45 <sioraiocht> they never put things where I want them
02:59:52 <BeelsebobWork> use --prefix then?
03:00:22 <retybok> is there a standard library function to remove duplicates in a sorted list
03:00:23 <retybok> ?
03:00:36 <BeelsebobWork> retybok: nub -- it does even better, no need for the list to be sorted
03:00:53 <retybok> BeelsebobWork: is it efficient if the list is sorted?
03:00:54 <BeelsebobWork> if you want it more efficient though, you may want map head . group
03:01:22 <sioraiocht> :t group
03:01:23 <retybok> BeelsebobWork: thanks, that helps a lot
03:01:24 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
03:07:24 <cjs> Is there a nice little in-memory relational database available?
03:07:37 <cjs> Ideally, not SQL-like....
03:09:24 <vegai> happs has something
03:10:20 <cjs> Actually, I can almost get by without it if I can find a decent way to find everything in a map where the key is within a given range.
03:17:03 <sjanssen> cjs: see Data.Map.split
03:18:44 <ToRA> or filterWithKey
03:22:21 <dancor> can i store a number in memory in IO ().  i.e. f :: IO () and f should be able to manipulate internally some x each time it is run.  like a static var
03:22:29 <dancor> i guess i could use an MVar
03:22:49 <dancor> even tho i'm not using threads
03:28:19 <sjanssen> dancor: there is also IORef
03:28:30 <sjanssen> dancor: but static variables are nasty
03:28:36 * BeelsebobWork ponders why anyone would want to do that
03:28:45 <dancor> sjanssen: ah nice.  yeah i'm using it with yampa
03:29:08 <BeelsebobWork> ugh
03:29:08 <dancor> the generation func is supposed to be :: IO (TDiff, Event e)
03:29:12 <BeelsebobWork> sounds painful
03:29:29 <sjanssen> dancor: is global state *really* necessary, or could you at least use a closure?
03:29:31 <dancor> i getCPUTime with each input event, but i need diffs
03:29:31 <Svrog> dancor: should check out reactive
03:30:18 <BeelsebobWork> indeed
03:30:27 <dancor> is yampa not cool anymore
03:30:30 <BeelsebobWork> then he'd only need diffE
03:30:30 <cjs> sjanssen: Ah, nice. Though I have to split twice, taking only part from each...
03:30:39 <Svrog> reactive is cooler ;)
03:30:43 <BeelsebobWork> much cooler
03:30:53 <BeelsebobWork> or possibly diffE . withTimeE
03:35:29 <cjs> Is a pair of splits likely to be faster than partitionWithKey on a 5000 element Map?
03:35:38 <cjs> s/faster/significantly faster/
03:36:33 <ToRA> split O(log n), partitionWithKey O(n)
03:36:48 <sjanssen> cjs: most likely
03:37:04 <dancor> BeelsebobWork: withTimeE is in fran?  i can't find fran for download
03:37:14 <BeelsebobWork> dancor: withTimeE is in Reactive
03:37:22 <BeelsebobWork> code.haskell.org/reactive
03:39:56 <Svrog> as for fran, it can be downloaded from here: http://conal.net/fran/
03:40:00 <lambdabot> Title: Functional Reactive Animation (Fran)
03:40:30 <BeelsebobWork> also, it's not quite just diffE -- it's withPrevEWith (subtract `on` fst) . withTimeE
03:40:42 <BeelsebobWork> (to only do the diff on the time values)
03:41:55 <opqdonut> ?pl \(a,b) -> (b,a)
03:41:55 <lambdabot> uncurry (flip (,))
03:42:49 <Baughn> "zipWith id" <-- Never a good start. :/
03:43:05 <BeelsebobWork> Baughn: uhhhh?
03:43:07 <BeelsebobWork> blimeh
03:43:23 <BeelsebobWork> oh
03:43:27 <BeelsebobWork> that's zipWith $
03:43:34 <BeelsebobWork> I guess that makes some sense actually
03:45:19 <Baughn> zipWith ($), anyway. Hmm, guess that one's more obvious to the reader.
03:45:37 <BeelsebobWork> yeh, I'd rather the $
03:47:23 <dancor> darcs vector-space compile fails on src/Data/Cross.hs:1:0: Couldn't match expected type `()' against inferred type `Basis s'
03:47:33 * dancor fuzzes the source
03:48:05 <Svrog> ah that reminds me, you'll need ghc 6.9 to compile the current version of reactive
03:49:34 * dancor _almost_ made it to waiting for the release
03:49:44 <Svrog> haha
03:50:35 <dancor> there is only source version right
03:50:59 <Svrog> i think there are nightly builds too
03:51:21 <Baughn> 6.10 will be out any day now, right? ;_;
03:52:14 <Svrog> not sure
03:53:58 <thoughtpolice> Baughn: RC is this friday
03:54:05 <thoughtpolice> probably a week or so after that
03:54:26 <thoughtpolice> i would think in the next few days a lot of things are going to hit cvs-ghc
03:55:06 * dancor cannot find nightly builds
03:55:09 <thoughtpolice> i'm just still hoping there's at least some form of DPH in there, along with the new type equalities solver (for assoc. types)
03:55:51 <malcolmw> main release of 6.10 will be at least 2 weeks after the RC is out, since ICFP takes up one of those weeks
03:56:26 <thoughtpolice> icfp would be a good testing ground for 6.10
03:56:54 <malcolmw> how so?  most people will be busy listening to the talks, not hacking
03:57:16 <thoughtpolice> just a thought :p
03:57:38 <hackage> Uploaded to hackage: panda 0.0.0.5
03:58:47 <Svrog> dancor: i'm not sure if this is it but give it a go: http://darcs.haskell.org/buildbot/head/
04:01:14 <retybok_> can anyone tell me what's wrong with this code? (http://hpaste.org/10421) It complains about "overlapping instances"
04:02:12 <Svrog> you derived a Show instance for Tree and then you wrote another instance
04:02:39 <retybok_> Svrog: so what does deriving (Show) mean?
04:02:56 <Svrog> it automatically creates an instance for Show
04:03:20 <Svrog> or rather a Show instance
04:03:27 <retybok_> Svrog: how can it guess what the show function does?
04:04:26 <Svrog> deriving only works for a small number of type classes - except for newtypes where it works for everything but  you have to use the GeneralizedNewtypeDeriving extension or something like that
04:05:11 <retybok_> Svrog: awesome
04:05:13 <retybok_> thanks
04:05:17 <Svrog> np
04:05:37 <dancor> Svrog: i can't find a way to grab a completed build.  it may just be there to tell ppl if head is currently building?
04:05:50 <EvilTerran> you can also use Data.Derive for automatic generation of more instances. it's an extra tool, tho, not part of the compiler.
04:06:04 <Svrog> dancor: yeah - i just noticed :(
04:06:17 <Svrog> i can't remember where the link was
04:07:07 <Jedai> If you're not on Windows, the HEAD is easy to build (as long as you're patient)
04:07:23 <dancor> Jedai: ok.  is there a git repo yet
04:07:27 <Svrog> if you've got a core 2 duo and run make -j 4 building ghc from sources isn't too bad
04:07:56 <Jedai> Yes there is one, you can find the adress somewhere on the developer wiki
04:08:42 <Jedai> Svrog: Still takes something like 20 minutes (and that's without the extra library)
04:08:44 <Svrog> http://darcs.haskell.org/ghc.git/
04:08:44 <lambdabot> Title: Index of /ghc.git
04:08:47 <dancor> oh and tada http://www.haskell.org/ghc/download.html#snapshots
04:08:48 <lambdabot> Title: The Glasgow Haskell Compiler
04:08:57 <Svrog> ah yeah that's it
04:09:06 * dancor truly is an internoob
04:12:31 <Olathe> How do I put a guard in a list comprehension ?
04:13:28 <Svrog> Jedai: yeah around 20 minutes - but thats not too bad compared to around 4 hours on my g5 imac :P
04:13:57 <Svrog> i remember last time i tried to build it on a g4 mac mini it took around 12 hours - but that was with extra libs
04:14:09 <Svrog> and then the build failed :(
04:14:12 <Svrog> haha
04:15:04 <quicksilver> Olathe: [x | x <- [0..6], x<3]
04:15:07 <thoughtpolice> i normally go with make -j6 for HEAD
04:15:13 <thoughtpolice> (core 2 duo)
04:15:33 <Jedai> Olathe, you just put the test, no keyword
04:15:50 <Olathe> Thanks :)
04:16:11 <Jedai> thoughtpolice: Is that really any better than -j3 on a dual core ?
04:16:21 <cad1> hey, I would like to create a list like [x*y|x<-[100..999]y<-[100..999]], but I'd like to create in a way that gives me the largest element of that list first, then the next smallest one, and so on. That list has ~800k elements but I'm looking for the greatest element that fulfills a property.
04:16:51 <cad1> Do you guys know of a handy way to order those numbers?
04:17:35 <daf> [999,998..100]?
04:17:35 <quicksilver> sounds like an euler project problem ;)
04:17:40 <Olathe> cad1: reverse.sort
04:17:55 <quicksilver> I assume cad1 is trying to do it without loading all 800k elements and then sorting them :P
04:17:56 <Jedai> Avoid duplicates
04:18:14 <Olathe> Perhaps.
04:18:22 <Jedai> 100  999 looks very much like 999  100...
04:18:23 <Olathe> He can do the property filter first.
04:19:18 <cad1> jedia, that does get rid of more than half of them
04:19:52 <Jedai> quicksilver : sorting 500k elements is hardly a problem (though of course it doesn't scale very well...
04:20:02 <Wild_Cat> I'd say start with [x * y | x <- [999,998..100]; y <- [100..x]]
04:20:19 <FunctorSalad_> Jedai: ? n*log(n) is not good?
04:21:28 <Jedai> FunctorSalad_ : The problem is the scaling of the list is in O(n^2) if I'm not mistaken (but if he really only needs 500k elements, this solution is ok)
04:22:08 <FunctorSalad_> Jedai: you mean the list comprehension?
04:22:13 <Olathe> Even with a very naive version, I get ghci to give the answer in 38.69 seconds.
04:22:39 <Olathe> That's with x <- [1..999], y <- [1..999]
04:22:56 <Jedai> Wild_Cat : unless I misunderstand I think he wants them completely ordered because he is searching for the greatest element to have a certain property, your solution won't do
04:23:03 <Olathe> And the filter after the sort.
04:23:27 <cad1> that's using reverse . sort x?
04:23:36 <cad1> q
04:23:51 <Olathe> Yes.
04:24:15 <Olathe> With the filter before the sort, it's 13.33 seconds naively.
04:26:58 <Olathe> Let's see if ghc is smart enough to turn filter a.sort into sort.filter a
04:28:02 <MyCatVerbs> Olathe: don't think it is, but you could put in a rewrite rule to teach it that.
04:28:06 <FunctorSalad_> you could pre-sort by lexicographical order...
04:28:26 <FunctorSalad_> err, not lexicographical
04:28:54 <FunctorSalad_> I mean the partial order "less than or equal on all components"
04:29:07 <Olathe> Ahh.
04:29:21 <Olathe> Has anyone made a nice set of rewrite rules ?
04:30:09 <sjanssen> Olathe: that is not really a valid rewrite rule
04:30:10 <FunctorSalad_> actually you wouldn't need to run a search algorithm on the partially ordered thingy, you could just walk the graph
04:30:45 <Olathe> Oh.
04:31:34 <FunctorSalad_> (start with (999,999), keep track of all nodes you have that are minimal in the partial order, pick the next node from the immediate predecessors of the minimal set)
04:31:37 <wjt> sjanssen: why would it not be valid, apart from maybe a broken Ord instance?
04:31:44 <FunctorSalad_> does that make sense?
04:32:11 <sjanssen> wjt: consider a predicate that occasionally returns _|_
04:32:34 <FunctorSalad_> where the immerdiate predecessors of (x,y) are of cource (x-1,y) and (x,y-1)
04:32:49 <FunctorSalad_> you even know in advance which of the two has smaller product ;-)
04:33:20 <FunctorSalad_> wjt: doesn't _|_ break everything anyway? ;-)
04:33:33 <cad1> FunctorSalad_: I think that's what I want to do
04:33:55 <wjt> sjanssen: ah, i see; then sort . filter a would yield _|_ but filter a . sort would produce x:...:xn:_|_
04:34:09 <sjanssen> wjt: exactly
04:34:28 <FunctorSalad_> cad1: we have "(x,y) <= (x2,y2) componentwise" => "(x,y) <= (x2,y2)" productwise
04:34:39 <FunctorSalad_> that property should somehow be useful for proving that this works ;-)
04:35:13 <FunctorSalad_> my "wjt:" line was actually in reply to sjanssen
04:36:25 <wjt> what's the ghc position on rewrite rules that remove bottoms?
04:39:10 <FunctorSalad_> I think you'd want to store the current minimal set in a priority queue, but maybe there's some nicer way in haskell?
04:39:38 <FunctorSalad_> ("minimal" in the partial order)
04:39:54 <cad1> FunctorSalad_: I don't know enough of haskell myself
04:40:05 <cad1> but I will mess around with the idea
04:40:22 <cad1> .. of creating a partial order
04:40:23 <lunabot>   parse error on input `of'
04:41:54 <salty-horse> hi. are any of the real world haskell editors around? I have a bug to report in the table of contents (no comment box)
04:42:33 <FunctorSalad_> . case () of { ()|"creating a partial order"=="" -> () }
04:42:34 <lunabot>  luna: no output
04:42:39 <FunctorSalad_> ;-)
04:43:20 <cad1> nice
04:47:27 <cad1> so i've got ﻿(x,y) <= (x',y')  if  x*y <= x'*y' and nifty rules like ﻿(x,y - 1) <= (x,y) and ﻿(x-1,y) <= (x,y) and put those together into a data structure?
04:48:06 <cad1> (hopefully one more well formed than that sentence!)
04:48:33 <cad1> I think I can do this on paper
04:55:20 <mperillo> hi
04:55:51 <mperillo> is it possible to write an heads function, so that heads "foo"  ==> ["f", "fo", "foo"] ?
04:57:38 <hackage> Uploaded to hackage: panda 0.0.0.5.1
04:58:12 <Wild_Cat> hrmm. cabal-install's bootstrap.sh is a nifty idea, but there's a but in it. Who do I report it to? dcoutts_ ?
04:58:37 <kaol> > inits "foo"
04:58:39 <lambdabot>   ["","f","fo","foo"]
04:58:56 <mperillo> kaol, thanks
05:20:04 <Wild_Cat> hrmm. bootstrap.hs doesn't actually work as well as I thought it did.
05:20:31 <Wild_Cat> Maybe I'll file a detailed bug report sometime tonight.
05:20:33 <Spark> he said, in the wreckage of the burning house
05:23:10 <Wild_Cat> aside from it being actually a bash (*not* sh, despite what its #! says) script, it just failed on missing deps, even though it was supposed to download those on its own.
05:24:14 <Wild_Cat> although in all fairness, I'd expect stuff like Network, HTTP and zlib to be part of the core GHC distribution.
05:25:22 <Baughn> Network /is/. HTTP and zlib.. not so much
05:26:32 <Wild_Cat> Baughn: meh. Then I have to wonder why the hell Ubuntu saw it fit to not make it part of the ghc6 package.
05:27:05 <MyCatVerbs> Wild_Cat: because they're insane?
05:27:10 <Baughn> Wild_Cat: It's part of the extra libraries - it makes sense - but you'd expect there to be a ghc6-full package too
05:27:12 <quicksilver> Network is not a core lib, IIRC.
05:27:26 <MyCatVerbs> Wild_Cat: I don't know. WHoever put together the Ubuntu GHC packages thought it'd be a good idea to split out *all* the libraries.
05:27:30 <quicksilver> ubuntu doesn't have to bundle the kitchen sink because it has a package system which works.
05:27:44 <MyCatVerbs> quicksilver: aye, it's not built by default when you build HEAD.
05:27:46 <Wild_Cat> MyCatVerbs: in all fairness, they also did that to Python. Yes, it's stupid too.
05:27:59 <MyCatVerbs> quicksilver: er, yes it does. It needs to bundle the kitchen sink because people actually want the kitchen sink.
05:28:17 <quicksilver> you don't get libssl without asking for it, or libgtk
05:28:25 <quicksilver> why should you get haskell-foo without asking for it?
05:28:33 <quicksilver> it's not like apt-get install is a difficult tool to use
05:28:47 <Wild_Cat> quicksilver: OTOH, you'd expect them to understand that when you install GHC, you plan to write, or at least compile, Haskell code, and as such get all of the standard library. Which is called *standard* for a reason.
05:29:06 <MyCatVerbs> quicksilver: because it is fantastically un-helpful to apt-get install ghc6-*, browse over to RWH, start trying out some of the examples... then nothing you type *works* because Shuttleworth's goons stripped all the default libraries out.
05:29:09 <Wild_Cat> but if Network isn't part of Base, then it's another problem.
05:29:10 <quicksilver> Wild_Cat: there is not haskell standard library.
05:29:32 <quicksilver> Wild_Cat: everything you (probably) think of as standard is called 'extralibs'
05:29:46 <quicksilver> it's included in some of the big downloadable bundle
05:29:59 <quicksilver> but the 'core' libraries have been as small as possible, and remain so.
05:30:05 <quicksilver> (if anything, getting smaller)
05:30:33 <MyCatVerbs> quicksilver: no it isn't. Not much of it, anyway. There's the ghc-release tarballs, and also ghc-release-extralib tarballs. ghc-release is what people consider to be the bare minumum, and it's big enough to be useful. Includes parsec, network, mtl, etc.
05:30:40 <quicksilver> MyCatVerbs: unhelpful in the sense of, if you can't be bothered to learn how to use your package manager, you can't program.
05:30:49 <quicksilver> MyCatVerbs: learning to use your package manager is a good idea.
05:31:08 <MyCatVerbs> quicksilver: yes! Perhaps you really can't program. Perhaps you're a complete n00blet learning from the ground up.
05:32:15 <Baughn> Then you probably won't mind that data.bytestring is missing
05:32:34 <quicksilver> MyCatVerbs: then you learn how to use your pacakge manager.
05:32:37 <quicksilver> it's part of the process.
05:32:44 <MyCatVerbs> Baughn: you will when your textbook uses it, you attempt to follow your textbook, and your code doesn't work.
05:32:53 <quicksilver> as a community, the haskell community should not subvert the package manager just to make it easier for newbies.
05:32:57 <MyCatVerbs> quicksilver: perhaps you don't want to have to loop through five damn hoops in order to start following the textbook you just bought this afternoon when you've only been informed about the existence of three of those hoops, and the inevitable result is going to be you hopping onto IRC and asking "why does none of the Network stuff in my Haskell textbook work?" and then you have to hope that there's some other Ubuntu luser lying around who can tell 
05:33:24 <quicksilver> strikes me that if there is a fault here, the fault is in RWH
05:33:37 <quicksilver> for not explaining how to install the needed libraries on a reasonable cross-section of OSes
05:33:46 <quicksilver> (and i haven't read RWH, so I could be wrong, maybe it does)
05:33:49 <MyCatVerbs> quicksilver: good luck writing a book with any _real world_ code in it without using libraries.
05:34:02 <quicksilver> I'm not advocating that ;)
05:34:12 <quicksilver> I'm advocating learning how to use the tools which install libraries.
05:34:25 <quicksilver> You can't pick up a GTK book and learn to program GTK without installing libgtk2-dev
05:34:29 <quicksilver> or whatever they call that these days.
05:34:54 <MyCatVerbs> And good luck explaining other peoples' package managers in every textbook you wish to publish. In another ten years, it is likely that the package management scene *will* have changed again. How do you plan to maintain the how-to-get-started chapter in a piece of dead tree?
05:36:49 <quicksilver> I don't.
05:36:53 <quicksilver> I expect people to be realistic.
05:36:55 <MyCatVerbs> equicksilver: yes we should. Newbies' experience is _important_, and the disk space taken up by installing the default libraries is a _rounding error_ on the amount of disk space that installing GHC6 in the first place costs anyway.
05:37:05 <quicksilver> Installing libraries requires doing stuff.
05:37:10 <quicksilver> you ahve to learn how to do stuff.
05:37:17 <quicksilver> in 10 years time you will have to learn how to do different stuff.
05:37:27 <quicksilver> package managers exist for a reason, it's not our place to subvert that.
05:37:29 <MyCatVerbs> What do you actually _gain_ by splitting the libraries out?
05:37:42 <quicksilver> reduced dependencies, decoupled releases
05:38:07 <MyCatVerbs> Bull poo. I'd accept that from, say, Arch, but not Ubuntu.
05:38:36 <MyCatVerbs> Ubuntu does single-giant-releases *anyway*, so it's not like it makes the slightest bit of difference to their users to have the dependencies decoupled.
05:39:02 <Baughn> MyCatVerbs: It makes a rather large difference if you're connecting via GPRS
05:39:06 <quicksilver> the go complain to ubuntu and tell them they are idiots and don't need a package management system.
05:39:11 <Baughn> (Speaking from experience here)
05:39:18 <quicksilver> this is not haskell's problem, maybe it's ubuntus
05:39:25 <MyCatVerbs> quicksilver: indeed it is.
05:39:44 <quicksilver> I for one, think dpkg is the single piece of software which has made the biggest positive difference to my computer experience
05:39:46 <MyCatVerbs> Baughn: no, if you're connecting via GPRS, you're already screwed. GHC is well over 100MB compiled with default libs.
05:39:57 <quicksilver> and I have 100 different reasons why I would not want to abandon packages
05:40:02 <Baughn> MyCatVerbs: Took me the better part of an evening to download, yes
05:40:07 <quicksilver> which I don't really feel like going through at length here :)
05:40:56 <MyCatVerbs> quicksilver: I'm not arguing against package management, I'm kvetching about utterly pointless masturbation with package managers.
05:45:47 <thoughtpolice> package managers == rox
05:46:10 <thoughtpolice> personally for haskell stuff though I always use cabal install - always get the latest and greatest and it's easy.
05:47:16 <Wild_Cat> thoughtpolice: what sparked the initial discussion was my trying to install cabal-install :p
05:47:38 <Wild_Cat> it has a bootstrap script, which downloads everything it needs, with the bizarre exception of Network.
05:48:25 <BeelsebobWork> thoughtpolice: for Haskell actually I often find that the Hackage version is a chunk out of date and that I need to use the darcs version
05:51:14 <thoughtpolice> BeelsebobWork: yeah that happens sometimes
05:51:48 <thoughtpolice> Wild_Cat: indeed - might want to talk to dcoutts
05:52:09 <Wild_Cat> thoughtpolice: yup.
05:52:24 <Wild_Cat> I'll file a bug report sometime tonight
05:53:53 <sjanssen> MyCatVerbs$ What do you actually _gain_ by splitting the libraries out?
05:54:14 <sjanssen> MyCatVerbs: the libraries are currently changing faster than GHC is
05:54:29 <MyCatVerbs> sjanssen: the versions of the libraries that Ubuntu ships aren't, though.
05:54:34 <FunctorSalad_> does an Ord have to be antisymmetrical?
05:54:42 <daf> MyCatVerbs: Ubuntu gets its packages from Debian
05:54:43 <FunctorSalad_> (in particular, will Set get confused if it isn't)
05:54:55 <sjanssen> coupling their release process slows down the rate of improvements and bug fixes
05:55:12 <MyCatVerbs> sjanssen: it's not useful to be in theory able to upgrade both independently if you never actually do.
05:56:53 <sjanssen> I would *love* to be able to update some libraries that are packaged with GHC
05:57:28 <sjanssen> eg. if Data.Map was in a separately upgradeable package, xmonad could support older GHCs
05:59:06 <sjanssen> MyCatVerbs: I also don't see why GHC in particular should bundle all libraries.  gcc doesn't bundle any libraries
05:59:46 <Wild_Cat> because a language implementation that doesn't come with a standard library is crippled, IMO.
06:00:33 <Wild_Cat> also, because C is mostly a systems programming language, where the default assumption is that code won't be portable unless you jump through Haruhi knows how many hoops.
06:00:53 <MyCatVerbs> sjanssen: Ubuntu's sensible enough to provide a build-essential package, which is fine.
06:01:09 <Wild_Cat> Haskell, OTOH, is more of an application programming language, where it's really really nice to just be able to type "ghc --make foo.hs" and have it Just Work.
06:01:23 <sjanssen> MyCatVerbs: so there should be a haskell-essential package
06:01:38 <MyCatVerbs> sjanssen: I'd also be just about happy with it if there were a single ghc6+batteries package that got you everything needed for, say, following SOE and installing cabal.
06:01:48 <sjanssen> MyCatVerbs: no need to make secondary users of Haskell install more than necessary
06:02:09 <quicksilver> it would be trivial to produce a haskell-soe or haskell-rwh virtual package
06:02:14 <sjanssen> MyCatVerbs: bleh, why SOE of all things?
06:02:20 <quicksilver> (virtual package = package which only contains dependencies)
06:02:54 <MyCatVerbs> sjanssen: because it's a popular textbook.
06:03:01 <Wild_Cat> sjanssen: "secondary users"?
06:03:33 <sjanssen> Wild_Cat: people who only use GHC indirectly.  Say they want to build xmonad, or darcs, but don't really hack Haskell
06:04:11 <sjanssen> these people don't need to install SOE on their systems
06:05:01 <Wild_Cat> sjanssen: OTOH, they need at the very least the dependencies of the software they're trying to build.
06:05:08 <MyCatVerbs> sjanssen: there are binary packages for darcs, and there soon should be one for xmonad (xmonad-lite, which provides a big-enough subset of xmonad.hs's configuration options).
06:05:44 <MyCatVerbs> sjanssen: and those people end up installing practically the lot anyway because both xmonad and darcs make use of all the interesting libraries.
06:05:57 <Wild_Cat> exactly.
06:06:05 <sjanssen> Wild_Cat: naturally, but these deps will generally be smaller than any standard that somebody choses
06:06:17 <thoughtpolice> that still doesn't mean GHC should bundle *everything* though
06:06:27 <sjanssen> and they definitely won't include bloat like SOE -- which has massive external deps, by the way
06:07:19 <Wild_Cat> sjanssen: I don't know about SOE, but basic libs for, say, network programming, text processing and compression look like things pretty much everyone will use.
06:08:08 <quicksilver> Wild_Cat: people trying to build software type "apt-get build-dep <software>" and get everything they need ;)
06:08:47 <sjanssen> MyCatVerbs, Wild_Cat: I do know, from experience with xmonad, that people do complain about the size of GHC as it is
06:08:49 <Wild_Cat> quicksilver: that's assuming the software they want has an associated .deb, in which case they don't need to build it at all.
06:09:00 <sjanssen> I would be strongly against any initiative to increase that size
06:09:50 <MyCatVerbs> sjanssen: they're stuck, then. GHC isn't going to get any smaller as time goes by.
06:09:58 <sjanssen> Wild_Cat: there are all sorts of occasions where they might need to build a package, for a newer version, under a different configuration
06:10:14 <Wild_Cat> I guess Python's batteries-included philosophy kinda spoiled me. That's something I've come to expect every HLL to have.
06:10:21 <MyCatVerbs> sjanssen: the solution to that particular issue is to use xmonad-lite, which can be installed purely as a binary.
06:10:24 <sjanssen> MyCatVerbs: wrong.  GHC 6.10's base library is smaller than 6.8's.  By all reports, 6.12 will be even smaller
06:11:05 <MyCatVerbs> sjanssen: the compiler itself will still be edging upwards byte by byte.
06:11:21 <quicksilver> Wild_Cat: the batteries-included philosophy is a reaction to crap or non existant package systems.
06:11:33 <quicksilver> it's really not a very valid philosophy in systems with working package systems.
06:11:44 <Wild_Cat> quicksilver: so is cabal-install.
06:11:55 <sjanssen> I think the Haskell Platform is a much smarter solution than fiddling with the GHC bundle
06:12:45 <MyCatVerbs> quicksilver: the batteries-included philosophy is a reaction to wanting to be able to just sit down with a fresh install and start hacking with a usable set of libraries, rather than try to second-guess which libraries you're going to want to install in addition, or having to stop half-way through to add libraries.
06:13:13 <sjanssen> MyCatVerbs: also, ask yourself why xmonad-light was ever conceived
06:15:01 <MyCatVerbs> sjanssen: because installing all ~140MB of GHC in order to configure xmonad is a leeeetle bit overboard.
06:15:59 <MyCatVerbs> sjanssen: not because installing ~3.6MB of Network.* is a little bit overboard. :P
06:16:51 <sjanssen> MyCatVerbs: every additional package adds up
06:17:40 <MyCatVerbs> Not installing the compiler at all removes that cost entirely.
06:18:14 <sjanssen> but sacrifices 75% of the attractiveness to xmonad
06:18:36 <MyCatVerbs> And most of those libraries are going to be necessary anyway for people who want to hack Haskell. For people who aren't going to be hacking Haskell, they really, really shouldn't need to install GHC in the first place. I would argue that xmonad.hs, while very elegant, is somewhat insane unless you make the assumption that the only people who will ever use xmonad are Haskell hackers.
06:19:17 <sjanssen> is it insane to configure emacs in elisp?
06:19:31 <Saizan> isn't the real solution to ship cabal-install with ghc and stop?
06:20:17 <MyCatVerbs> sjanssen: no. emacs is an elisp interpreter. emacs is *supposed* to be 20MB+ for a base install.
06:21:09 <MyCatVerbs> sjanssen: xmonad isn't an all-encompassing IDE. It *is* a little overboard for a 'light' window manager (which xmonad most certainly is, yay) to have a 100MB compiler dependency .
06:21:41 <daf> "light" is a very vague term
06:21:46 <MyCatVerbs> sjanssen: xmonad does not provide SLIME, and will never need to. Emacs does. xmonad does not need to supply viper-mode, a spell checker, a mail client, a nethack interface...
06:21:57 <MyCatVerbs> daf: jah, but it's safe to apply here.
06:21:59 <daf> simplicity of user interface is distinct from disk space usage
06:22:14 <daf> (and memory usage, CPU usage, etc.)
06:22:30 <MyCatVerbs> daf: fortunately, xmonad hits all host bases, except for disk space.
06:22:45 <MyCatVerbs> s/host/those/ (whut)
06:22:53 <MyCatVerbs> No dynamic linking ATM. :/
06:23:11 <daf> shrug
06:23:16 <sjanssen> MyCatVerbs: my point is that GHC doesn't really need to be 140MB
06:23:22 <daf> reducing disk space at the cost of flexibility is not a clear win
06:23:43 <MyCatVerbs> sjanssen: for secondary users, GHC could be made to be 0MB by not requiring it at all.
06:24:21 <MyCatVerbs> sjanssen: for primary users, GHC may as well be 140MB. They're almost certainly going to end up installing all those libraries - and more - anyway. Batteries-included is entirely appropriate when your goal is to write software.
06:25:11 <sjanssen> MyCatVerbs: why should the batteries included package be called "ghc6"?  Why should it be our only option?
06:25:52 <sjanssen> MyCatVerbs: a "haskell-platform" seems to satisfy both sides of the debate
06:25:55 * Philippa has developed on machines that wouldn't have room for a full batteries-included setup
06:25:57 <daf> the standard library is only going to be enough for a small number of applications
06:26:03 <sjanssen> haskell-platform metapackage, that is
06:26:03 <MyCatVerbs> sjanssen: because there's nothing interesting to be gained when an infinitesimal portion of users actually want ghc6 instead of haskell-platform.
06:26:11 <Philippa> note: on, not for
06:26:17 <daf> sooner or later, most developers will need to install extra libraries
06:26:22 <daf> and it's probably sooner
06:26:31 <MyCatVerbs> sjanssen: you're postulating the existence of users whose improbability is so enormous that I'm not really interested in them.
06:26:40 <Philippa> MyCatVerbs: you can kiss my arse, then
06:26:54 <sjanssen> MyCatVerbs: they exist!  They've whined to me in #xmonad about the size of GHC!
06:27:03 <sjanssen> MyCatVerbs: we would have more users if it was smaller!
06:27:11 <MyCatVerbs> sjanssen: wrong problem! The problem is that xmonad shouldn't depend on GHC at all.
06:27:15 <Philippa> the eee 701 really doesn't have room, for example. Nor do most PDAs, and I've been known to run haskell implementations on mine before
06:27:20 <MyCatVerbs> Philippa: you need ghc6, but you don't need mtl, network, bytestring..?
06:27:26 * CosmicRay notes that xmonad is awesome.  how could all of you let me wallow in KDE for so long?! :-)
06:27:31 <sjanssen> MyCatVerbs: I don't think you understand xmonad
06:27:34 <Philippa> MyCatVerbs: I've never /needed/ bytestring
06:27:41 <CosmicRay> also, does andrea rosatto IRC?
06:27:56 <sjanssen> CosmicRay: not anymore, I think
06:28:24 <MyCatVerbs> sjanssen: I do understand xmonad, and I think the approach is mildly crazy. The only people who even understand xmonad.hs well enough to be able to make any interesting use of it are Haskell hackers, who probably want to install GHC anyway.
06:28:36 <MyCatVerbs> sjanssen: at least, I believe I do, anyway. ;P
06:28:46 <CosmicRay> MyCatVerbs: I don't think that is true
06:28:47 <CosmicRay> MyCatVerbs: however
06:28:56 <CosmicRay> MyCatVerbs: how to make a *simple* xmonad.hs is severely underdocumented.
06:28:57 * Philippa points out that MyCatVerbs has been known to not understand things while thinking otherwise
06:29:10 * Philippa seconds that
06:29:10 <sjanssen> MyCatVerbs: I don't think that is really true.  You also can't discount the value of xmonad.hs as a Haskell gateway drug
06:29:14 <CosmicRay> I aim to fix that once I'm done hacking mine
06:29:15 <MyCatVerbs> Philippa: it's called "being human", I'm used to it.
06:29:25 <Philippa> a small library and it's no worse than any other config file format
06:29:32 <CosmicRay> there are a ton of fancy xmonad config files out there.
06:29:47 <MyCatVerbs> sjanssen: everyone else could happily get all the configurability they need with a simple config file format. xmonad-lite suffices for these uses.
06:29:57 <CosmicRay> but very few that separate out "ok, here's how you integrate dzen, here's how you change your modifier keys..." type of thing
06:30:04 <daf> I think the xmonad developers are right not to sacrifice its flexibility in the hope of getting more users
06:30:08 <Philippa> MyCatVerbs: so write the data-driven config file already
06:30:15 <daf> its very oddness is what enamours many of its users of it
06:30:20 <sjanssen> MyCatVerbs: if GHC lost 41MB (to fit just under the 100MB psychological barrier), we would have more users.  I'm pretty confident of that
06:30:20 <CosmicRay> Philippa: dare I mention ConfigFile here?
06:30:30 <MyCatVerbs> Philippa: no need. xmonad-lite's author already did. Problem solved.
06:30:33 <Philippa> CosmicRay: don't look at me, I don't use it
06:30:41 <CosmicRay> sjanssen: heh
06:30:57 <daf> CosmicRay: hey -- any more thoughts on http://software.complete.org/software/issues/show/69 ?
06:30:58 <lambdabot> Title: Haskell Database Connectivity - Feature #69: allow accessing ID of inserted row  ...
06:30:59 <Philippa> also, "everyone else" includes a pile of users who'll happily download other people's tweaked configs as a starting point
06:31:07 <CosmicRay> daf: let me pull that up, sec...
06:31:16 <Svrog> batteries included approach usually tends to package up a lot of substandard and inconsistent libraries that in turn become a standard of sorts (being packaged with a distribution and all) - i prefer to have a smaller set of more carefully thought out libraries as part of the main distribution
06:31:34 <ivanm> matthew-_: you around?
06:31:38 <Philippa> finally: as a developer you'd have to be crazy to rip out the parts of a FOSS project that make it usable /for you/...
06:31:41 <daf> CosmicRay: also, have you considered using YYYY/MM/DD format for dates? ;)
06:31:53 <Philippa> 'lo JaffaCake
06:31:59 <JaffaCake> hi there
06:31:59 <lambdabot> JaffaCake: You have 1 new message. '/msg lambdabot @messages' to read it.
06:32:07 <CosmicRay> daf: ah I think I had missed that you actually wrote a patch.  sweet.
06:32:15 <CosmicRay> daf: dates are a sore subject with me :-)
06:32:16 <ToRA> ivanm: he may be asleep - probably best to email him
06:32:19 <daf> CosmicRay: I think it will break ABI though :(
06:32:33 <CosmicRay> daf: the problem with dates are that there are n number of different ways that databases hand them back.
06:32:36 <daf> CosmicRay: I guess that doesn't matter in the absence of shared libraries thogh
06:32:40 <CosmicRay> daf: and then you have sqlite which doesn't even have a date type
06:32:45 <daf> CosmicRay: oh, I meant on that page that I linked to
06:32:48 <ivanm> ToRA: it's meant to be 2PM for him according to lambdabot's @localtime plugin :p
06:32:49 <CosmicRay> oh
06:32:58 <CosmicRay> daf: that is *still* a sore subject.  ruby code.  nuff said? ;-)
06:33:05 <daf> CosmicRay: ha, ok
06:33:09 <ToRA> ivanm: i know, but i know he was awake at 4am
06:33:20 <ivanm> ToRA: and I _did_ email him... I just remembered though that he's signed in here, in case he wants to talk directly rather than email back and forth ;-)
06:33:26 <ivanm> ToRA: oh... fair enough :p
06:33:34 <ToRA> ivanm: heh ok
06:33:46 <CosmicRay> daf: I wrote git support for redmine and that taught me that ruby is a language that wants to be both python and perl, and winds up doing neither particularly well
06:33:48 <ivanm> (that must have been when he got around to emailing me back the first time :p)
06:34:10 <CosmicRay> oh also I think ruby has a secret desire to be smalltalk's boyfriend or something
06:34:25 <daf> it's seeing Scheme behind Smalltalk's back
06:34:34 <CosmicRay> heh
06:35:00 <ivanm> CosmicRay: how did you arrive at the gender of those languages?
06:35:03 <CosmicRay> I guess one could say that python is a language that wants to be both haskell and perl, at that :-)
06:35:07 <retybok> I've come across this line: "    StackSet { current  :: !(Screen i l a sid sd)  " in the xmonad source code. Can someone tell me what the exclamation mark stands for? Or at least what it is called, so I can look it up...
06:35:09 <ivanm> (and so what gender would haskell be? :s )
06:35:20 <CosmicRay> ivanm: urm...  I only commented on ruby's gender :-)
06:35:23 <ivanm> retybok: strictness
06:35:34 <CosmicRay> ivanm: I dunno, Haskell has so many monads its hard to tell...
06:35:47 <retybok> ivanm: thanks
06:35:52 <sjanssen> retybok: it is called a "strict field".  It means that component is evaluated when the StackSet is constructed
06:35:58 <ivanm> current's value has to be fully evaluated (rather than using a delayed hunk) before being assigned
06:36:06 <daf> retybok: I think the annotated version of the code explains the motivation
06:36:15 <ivanm> CosmicRay: doesn't look like a monad-specific function to me... :s
06:36:24 <retybok> thanks a lot
06:36:25 <ivanm> oh, wait, response to wrong comment ;-)
06:36:47 <magthe> any ideas on how to convert a Day to an integer (epoch)?
06:36:59 <CosmicRay> ivanm: heh
06:37:00 <ivanm> System.Time have anything useful?
06:37:21 <retybok> daf: no, not a mention of "strict" :-/
06:37:22 <CosmicRay> a Day.  Is that frmo old-time or new-time?  (smells new-time to me)
06:37:44 <CosmicRay> I need to put some utilities for new-time into missingh
06:37:50 <Saizan> ivanm: not fully, only to WHNF
06:38:05 <CosmicRay> magthe: did you mean this Day?  http://www.haskell.org/ghc/docs/latest/html/libraries/old-time/System-Time.html#t%3ADay
06:38:07 <lambdabot> Title: System.Time, http://tinyurl.com/27ptdb
06:38:08 <ivanm> Saizan: true, forgot about that
06:39:31 <daf> retybok: http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source/StackSet.hs
06:39:34 <lambdabot> Title: Xmonad/Guided tour of the xmonad source/StackSet.hs - HaskellWiki, http://tinyurl.com/62n5dw
06:39:45 <daf> retybok: “A note about those exclamation points, as in workspace :: !(Workspace i l a): they are strictness annotations which specify ...”
06:39:55 <CosmicRay> magthe: if so, then what you have is a fragment of a CalendarTime.  If you have the whole CalendarTime, you can do it manually with the functions in System.Time, or use my timelocal or timegm here: http://software.complete.org/static/missingh/doc//MissingH/System-Time-Utils.html
06:39:56 <lambdabot> Title: System.Time.Utils, http://tinyurl.com/5nbbm9
06:40:20 <CosmicRay> you can use toCLockTime and then pick out the TOD x _ bits of the clocktime
06:40:32 <retybok> daf: thanks, I wasn't aware of that page
06:40:48 <daf> retybok: welcome! http://haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source is the home of the guided tour
06:40:50 <lambdabot> Title: Xmonad/Guided tour of the xmonad source - HaskellWiki, http://tinyurl.com/22vxvh
06:44:13 <magthe> CosmicRay: yes, that's the Day I mean
06:48:38 <magthe> CosmicRay: so, if I use toGregorian, then I get the fragment of the CalendarTime, the remaining pieces I don't really care about, then I can use timegm to convert to epoch... I suppose introducing a dependency on missingh isn't too bad since I'm already depending on hdbc ;-)
06:48:53 <CosmicRay> :-)
06:49:13 <CosmicRay> though of course you must have more of a CalendarTime than a Day to be able to convert to epoch
06:49:19 <magthe> there does seem to be some missing things in all of this though, conversion wise
06:49:21 <CosmicRay> in fact the Day is generally not relevant when converting to epoch
06:49:35 <CosmicRay> where is togregorian?
06:50:03 <magthe> CosmicRay: in http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Calendar.html#v%3AtoGregorian
06:50:10 <lambdabot> Title: Data.Time.Calendar, http://tinyurl.com/5u8p76
06:50:17 <CosmicRay> ah
06:50:20 <CosmicRay> that is the new time module
06:50:38 <CosmicRay> I'm not too familiar with it yet.  but this is a different Day than the one I had.
06:50:43 <magthe> CosmicRay: well, I'm only really interested in the date, not the time, so I thought using Day comes closest to that
06:50:47 <CosmicRay> the MissingH libraries won't help you with this kind of Day
06:51:14 <CosmicRay> magthe: unix programmers still will use the epoch format for that, and just use midnight or noon or something as the time
06:51:21 <magthe> CosmicRay: I suspect I can go that path still though... some testing is needed first
06:51:36 <CosmicRay> Data.Time is really powerful
06:52:02 <CosmicRay> I'm sure it has a way to convert that Day to an epoch format
06:52:16 <magthe> CosmicRay: the problem really came up since Day isn't an instance of SqlType (hint, hint)
06:52:31 <CosmicRay> ah ha :-)
06:52:42 <CosmicRay> and now you return to the sore subject I was speaking to daf about :-)
06:52:46 <rog> hi folks
06:52:52 <CosmicRay> which is to say that I hate dates in SQL
06:53:10 <CosmicRay> I mean, I like the fact that date types exist.
06:53:16 <CosmicRay> if only all databases would handle them the same wya.
06:53:38 <rog> if i want to declare two existential types in the same expression GHC, what's the correct syntax? i can't seem to get it right...
06:54:00 <quicksilver> rog: not sure what you mean. What syntax are you trying?
06:54:19 <rog> quicksilver: current attempt is: 	data RG a = (forall r. RandomGen r, forall r'. RandomGen r') => RG (r -> (r', a))
06:54:45 <quicksilver> (forall r r' . RandomGen r, RandomGen r') =>
06:54:46 <quicksilver> I think
06:54:56 <rog> ah, no comma...
06:55:06 <CosmicRay> magthe: however, it is probably legitimate to say that I ought to support the Data.Time stuff as well as the System.Time stuff
06:55:12 <CosmicRay> which is to say, not all that well but better tha nnothing ;-)
06:55:15 <quicksilver> the key point is that all the foralls go at the beginning of the context
06:55:54 <rog> quicksilver: that doesn't seem to work, sadly
06:56:03 <magthe> CosmicRay: haven't been able to find anything epoch related in Data.Time, so I agree that it's powerful, but I'm still to be convinced that it's anchored in the real world
06:56:13 <dolio> The "forall r r'." should not be in the parentheses.
06:56:50 <magthe> CosmicRay: I'm looking forward to better support for Data.Time in hdbc, but for now a quick hack will have to do :-)
06:56:51 <CosmicRay> magthe: http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock-POSIX.html
06:56:53 <lambdabot> Title: Data.Time.Clock.POSIX, http://tinyurl.com/25otgv
06:57:02 <CosmicRay> magthe: could you submit a bug at http://software.complete.org/hdbc?
06:57:03 <lambdabot> Title: Haskell Database Connectivity - Overview - Software.Complete.Org
06:57:16 <rog> dolio: that seems to work, thanks.
06:57:41 <daf> CosmicRay: I agree, they are sure tricky
06:57:56 <rog> is there a syntax definition for the language (inc. GHC extensions) somewhere? the user manual just seems to explain by example.
06:58:18 <daf> storing a unix timestamp works for most things, thankfully
06:58:42 <magthe> CosmicRay: will do... it's on my todo list for when I get home from work
06:59:27 <mapreduce> rog: The Haskell 98 Report
06:59:31 <mapreduce> @go the haskell report
06:59:33 <lambdabot> http://www.haskell.org/onlinereport/
06:59:33 <lambdabot> Title: The Haskell 98 Language Report
06:59:55 <rog> mapreduce: does that include GHC extensions, e.g. existential types?
07:00:19 <daf> rog: no
07:00:20 <rog> mapreduce: i was under the impression that it did not.
07:00:41 <rog> daf: so...
07:01:10 <mapreduce> rog: No.  Most likely each extension has its own documentation somewhere.
07:03:37 <thoughtpolice> rog: the ghc manual covers most of the extensions pretty roughly
07:04:28 <rog> i've found a pointer to the original article but sadly i need ACM membership to get hold of it.
07:04:45 <rog> so does everyone just find the syntax by trial and error?
07:04:57 <rog> or is it worth delving into the GHC source?
07:05:23 <_Dae_> anyone know if there is a backup of the Data.Array.Base documentation somewhere? The one at haskell.org seems to be broken
07:05:59 <rog> i guess that's the basic problem with using non-standard extensions.
07:06:25 <sjanssen> rog: have you tried the GHC manual?
07:06:58 <rog> sjanssen: e.g. http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html ?
07:06:59 <lambdabot> Title: 8.4.�Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
07:08:32 <rog> sjanssen: if so, it's not really very helpful on general syntax construction.
07:08:57 <rog> sjanssen: maybe there's a more comprehensive manual somewhere?
07:09:59 <sjanssen> rog: that's the one
07:10:08 <sjanssen> rog: hopefully those few examples are enough to get you started
07:11:19 <sjanssen> rog: also http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
07:11:21 <lambdabot> Title: 8.7.�Other type system extensions, http://tinyurl.com/3c7ura
07:13:05 <rog> sjanssen: yes, it got me started... and then left me in the lurch! (i.e. it didn't say anything about how to contruct a type with more than one existential type, and the syntax isn't very permissive...)
07:13:56 <rog> sjanssen: but it doesn't matter any more (in this case), 'cos i've got past the syntax checker. i'm just trying to deal with a
07:13:58 <rog> oops
07:14:00 <sjanssen> rog: huh, there are a few missing examples I think
07:14:10 <sjanssen> multiple variables can be separated by ,
07:14:22 <sjanssen> forall a, b. blah
07:14:36 <rog> sjanssen: i'm just trying to work out what a "Inferred type is less polymorphic than expected" error means now...
07:15:23 <rog> sjanssen: actually, the syntax that seems to have worked is this: 	data RG a = forall r r'. (RandomGen r, RandomGen r') => RG (r -> (r', a))
07:15:34 <rog> sjanssen: note, no comma.
07:15:57 <rog> sjanssen: (and a particular placement of brackets)
07:16:08 <dmwit_> ?ty id :: (a -> b) -> (a -> b)
07:16:10 <lambdabot> forall a b. (a -> b) -> a -> b
07:16:18 <dmwit_> rog: That's the syntax. ^^
07:16:44 <Saizan> ?ty \r r' -> const () (split r, split r')
07:16:45 <lambdabot> forall g g1. (RandomGen g1, RandomGen g) => g -> g1 -> ()
07:17:11 <sjanssen> rog: mm, yeah, no comma.  Not sure what I was thinking
07:17:12 <rog> ta
07:17:42 <rog> sjanssen: well, some things have commas, some don't. i guess the rhyme & reason comes from the original math notation
07:18:33 <rog> sjanssen: but i do find it a little confusing, as a haskell newbie. also: when to use "=" vs. when to use "where"
07:19:06 <sjanssen> rog: it data declarations, you mean?
07:19:06 <seanmce> i'm compiling with ghc via cabal on with 256M of ram. it's very slow, are there and options that would help?
07:19:11 <rog> sjanssen: but i'm sure there are sound grammatical reasons for all these little foibles...
07:19:56 <Saizan> seanmce: compiling what?
07:20:02 <rog> sjanssen: yes. declarations/definitions.
07:20:18 <seanmce> xmonadcontrib
07:20:18 <dmwit_> seanmce: If you're compiling GHC, *why* are you compiling GHC?
07:20:55 <seanmce> not compiling ghc, sorry
07:21:02 <rog> sjanssen: like why is it "instance Monad X where..." instead of "instance Monad X =..." ?
07:22:25 <shrughes> "where" is used to precede a list of definitions
07:22:26 <Saizan> rog: well '=' is only used for equations, where to group a set of definitions instead
07:22:54 <Saizan> seanmce: maybe --disable-optimization
07:24:51 <CosmicRay> SyntaxNinja: hi!
07:25:19 <rog> shrughes: indeed. i'm just saying that it seemed odd on first encounter. both uses are definining a new entity.
07:25:59 <shrughes> yeah, maybe
07:26:03 <dmwit> rog: Haskell syntax is ambiguous enough as it is... =P
07:27:06 <quicksilver> rog: = has a very traditional and precise usage
07:27:13 <quicksilver> rog: f [] = 3
07:27:21 <quicksilver> rog: f applied to the empty list *is* 3
07:27:30 <rog> dmwit: i certainly find its reliance on context rather than keywords quite hard to deal with at times.
07:27:31 <quicksilver> instance ... where is different.
07:28:04 <rog> quicksilver: i'm not sure that haskell's "=" is the same as the traditional "="...
07:29:27 <rog> quicksilver: or maybe it is...
07:30:05 <quicksilver> it is "a" traditional +
07:30:06 <quicksilver> =
07:30:08 <quicksilver> sorry ;)
07:30:23 <quicksilver> it's not symmetric like equality, it's more like definitional equality
07:30:27 <quicksilver> but it's a traditional use
07:33:58 <rog> dmwit: a nice example of the syntax's reliance on context i find in data definition. in "data X = X (Y, [X])" the three occurrences of X each mean a different thing, but as a newbie, they all look the same!
07:34:18 <quicksilver> rog: only two different ones.
07:34:23 <quicksilver> the first and last X mean the same.
07:34:52 <quicksilver> the practice of using constructor names as type names is quite rightly criticised, but it *is* convenient.
07:34:54 <ski> (but the last one is "written in the place of a value of that type")
07:34:55 <dmwit> rog: Yep, there are several namespaces in Haskell.
07:34:55 <rog> quicksilver: the second and the third are different really, because the second is defining a new data constructor, whereas the third is referring to it
07:35:14 <quicksilver> rog: no, the third is referring to the type, not the constructor.
07:35:21 <quicksilver> so it refers to the first.
07:35:21 <rog> true
07:35:23 <dmwit> rog: It's the first and third that are the same, not the second and third.
07:35:34 <quicksilver> and that's not a difference. It's still the same 'X' ;)
07:35:53 <quicksilver> but I agree with you about constructors and type names.
07:35:59 <quicksilver> that is a confusing convention.
07:36:09 <quicksilver> But we have limited syntactic space and it's useful to overload :(
07:36:45 <b4taylor> So any chance of getting an updated yi package?
07:37:07 <dmwit> b4taylor: I think it was just updated (on hackage) the other day; what in particular were you looking for?
07:37:13 <rog> quicksilver: the first defines. the third refers. i certainly found it confusing at first. i could have done with a little more keywordage in the syntax to make the distinctions clear...
07:37:14 <ski> (.. another convention is to use `data X = MkX (Y,[X])')
07:37:39 <dmwit> b4taylor: I'm not sure very many people are actively working on it, really, so if there's something you want, you might just have to write it yourself...
07:37:40 <ski> (.. more complete : data X = MkX {unX :: (Y,[X])}')
07:38:07 <b4taylor> dmwit: Isn't the version in the overlay like 0.2 or 0.3. Moreover it wants to downgrade all my other dev libs and ghc itself.
07:39:00 <b4taylor> Oh nice it has been updated.
07:39:05 <dmwit> b4taylor: This overlay... it sounds like a gentoo thing.
07:39:11 * dmwit knows nothing about gentoo
07:39:45 <b4taylor> Ah crap.
07:39:49 <b4taylor> Wrong channel p
07:39:49 <rog> ski: ... which reminds me: are there any plans to do a decent implementation of records in GHC. i came across a nice paper the other day (http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf) which seemed reasonable. i find the namespace pollution of record members quite hard to deal with.
07:39:50 <b4taylor> :p
07:39:51 <lambdabot> Title: Extensible records with scoped labels
07:39:53 <b4taylor> dmwit: Sorry.
07:40:02 <ivanm> b4taylor: ummm... I wouldn't trust the yi in the overlay
07:40:05 <ivanm> I'm still hacking on it :p
07:40:18 <b4taylor> #haskell and #gentoo-haskell look so similar.
07:40:19 <ivanm> if you really want yi, install it via cabal-install for now
07:40:56 <b4taylor> ivanm: Yeah, in the past I had problems manually installing it. User error most likely.
07:41:03 <ivanm> :o
07:42:30 <thoughtpolice> it is definitely much nicer to have yi available through cabal install
07:45:10 <SyntaxNinja> hi CosmicRay
07:46:42 <mmorrow> . let composeR f = [|($f .)|] ; goR = iterate composeR . composeR in vcat `fmap` (mapM (return . text . pprint . cleanNames =<<) . take 3 . drop 0 . goR $ [|id|])
07:46:42 <lunabot>  (id .)
07:46:42 <lunabot>  ((id .) .)
07:46:42 <lunabot>  (((id .) .) .)
07:47:29 <mmorrow> . let composeL f = [|(. $f)|] ; goL = iterate composeL . composeL in vcat `fmap` (mapM (return . text . pprint . cleanNames =<<) . take 3 . drop 0 . goL $ [|id|])
07:47:30 <lunabot>  (. id)
07:47:30 <lunabot>  (. (. id))
07:47:30 <lunabot>  (. (. (. id)))
07:48:29 <learningmacros> funny how much I miss stuff from Haskell now when programming in other languages
07:48:46 <learningmacros> if haskell doesn't become more popular it is because othe rlnguages has stolen all the good ideas
07:48:47 <learningmacros> """parseFile :: String -> {String: Review} -> {String: Review}"""
07:48:56 <learningmacros> just documenting my Python-programs...
07:50:51 <jinjing> lunabot?
07:50:55 <jinjing> @lunabot
07:50:55 <lambdabot> Unknown command, try @list
07:52:19 <Wild_Cat> learningmacros: OTOH, I dearly miss docstrings in every language that's not Python ;)
07:52:37 <rog> can anyone tell me what's wrong with this snippet? http://hpaste.org/10425
07:53:03 <rog> i get a "Inferred type is less polymorphic than expected" error
07:53:18 <osfameron> Wild_Cat: how are they different from documentation in Lisp/Java/Perl/etc. ?
07:53:28 <rog> (on the last line)
07:54:31 <Wild_Cat> osfameron: they're not comments. That is, they exist at runtime and don't need to be preprocessed. Open up a Python console, type help(whatever) and out comes the docstring (piped through less).
07:54:37 <learningmacros> wils_cat: true, they are very neat
07:55:20 <Wild_Cat> IIRC that also works when you drop into the debugger from a running program.
07:55:21 <byorgey> rog: hmm... I'm not exactly sure why you're getting that error, but is there any particular reason you have  RG (r -> (r', a)) rather than RG (r -> (r,a)) ?
07:55:42 <byorgey> seems sort of strange to allow two different RandomGen types like that
07:55:46 <jinjing> Wild_Cat: now if we have iHaskell, like iPython
07:55:47 <mmorrow> jinjing: use '.' or ']'
07:55:51 <mmorrow> . 42
07:55:51 <lunabot>  42
07:55:54 <osfameron> Wild_Cat: yeah, handy
07:55:55 <mmorrow> ] [0..]
07:55:56 <dcoutts_> Wild_Cat: I think you have a bug report for me, right?
07:55:56 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:56:18 <rog> byorgey: yes, because if i have the latter, then i get an error because it can't infer that the returned r is the same as the first.
07:56:20 <jinjing> mmorrow: why do we need 2 bots, or they are different?
07:56:21 <Wild_Cat> dcoutts_: right. Two, actually, both regarding cabal-install's bootstrap.sh.
07:56:33 <jinjing> .[1.0..]
07:56:33 <lunabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17.0...
07:56:44 <rog> byorgey: so this is my attempt to get around that.
07:56:52 <byorgey> rog: ah, right, but that's because r is an existential type, I think
07:56:56 <mmorrow> jinjing: lunabot does template-haskell, and imports some different modules/packages
07:56:59 <dcoutts_> Wild_Cat: good good
07:57:04 <jinjing> oh
07:57:07 <byorgey> rog: it would probably be easier to make r a parameter of RG along with a.
07:57:14 <mmorrow> . [|42|]
07:57:14 <lunabot>  LitE (IntegerL 42)
07:57:19 <Wild_Cat> dcoutts_: 1. #!/usr/bin/sh at the beginning of the script should be #!/usr/bin/bash . It can't be run with plain old sh due to stuff like pushd/popd being bash-only features.
07:57:24 <byorgey> RG r a = RG (r -> (r, a))
07:57:34 <mmorrow> . [d|data A a = A | B a|]
07:57:35 <lunabot>  DataD [] A [a_0] [NormalC A [],NormalC B [(NotStrict,VarT a_0)]] []
07:57:37 <byorgey> instance (RandomGen r) => Monad (RG r) where ...
07:57:45 <dcoutts_> Wild_Cat: I've eliminated pushd/popd
07:58:05 <Wild_Cat> 2. (not sure if that's a bug) it requires Network to be manually installed.
07:58:10 <rog> byorgey: that was what i've been trying to avoid, because then i'd have to change all occurences of RG and i'd rather avoid that, given that the client interface really doesn't care what types RG uses internally.
07:58:11 <byorgey> rog: does that make sense?
07:58:12 <dcoutts_> Wild_Cat: so it should be ok with /bin/sh
07:58:24 <dcoutts_> Wild_Cat: right, we assume that's already there since it's in a basic install
07:58:30 <byorgey> rog: hmm
07:58:30 <Wild_Cat> I only tested the last official release, not the darcs version.
07:58:48 <Wild_Cat> dcoutts_: it's not in Ubuntu's base GHC package. But fair enough.
07:59:02 <rog> byorgey: i did start off doing that, but thought existential types should make it possible to avoid it...
07:59:28 <rog> byorgey: hence my above attempt
07:59:29 <byorgey> rog: they might... but you will have a heck of a painful time with it =)
07:59:33 <dcoutts_> Wild_Cat: but it is in ubuntu's system, it's just that you're not installing a meta-package
08:00:02 <byorgey> rog: if I were you I'd send a message to haskell-cafe
08:00:02 <dcoutts_> Wild_Cat: but it's got another bug which is that it re-installs those packages even if you do have them installed already! :-)
08:00:16 <dcoutts_> Wild_Cat: it's basically pretty dumb
08:00:19 <quicksilver> rog: it helps if you paste the precise error message along with the code :)
08:00:50 <Wild_Cat> dcoutts_: yup, you can apt-get libghc6-network-dev. And there was a rather lengthy discussion about whether that was a good or bad thing that it not be included in Ubuntu's generic GHC package.
08:01:44 <quicksilver> rog: OK, the problem is that the first action "RG rt0" returns some randomGen, but you don't know which.
08:01:49 <Wild_Cat> (I guess what we *really* need is a Debian/Ubuntu "GHC and the 4 bloody AA batteries" meta-package)
08:02:11 <quicksilver> rog: then you try to feed that returned RandomGen (r1) to the second action rt1
08:02:14 <dolio> rog: r needs to be universal, not existential.
08:02:15 <quicksilver> rog: but, that doesn't match.
08:02:30 <quicksilver> rog: rt1 requires some *other* randomGen, but you don't know why.
08:02:49 <dolio> And, from experience, r' will need to be existential at the pair, not at the overall RG level.
08:02:54 <quicksilver> rog: have you, incidentlly, looked at MonadRandom, which seems to do what you're trying to do.
08:03:25 <jinjing> is there any coding style guide for haskell?
08:03:44 <rog> sorry, distracted by girlfriend arriving, back in 5
08:03:45 <retybok> what's wrong with this code? (appart from it's extreme ugliness... it fails at runtime with printf reporting a "bad argument") code:   mapM_ (\ x -> mapM_ (\ y -> printf "%d %d %.2f\n" x y (x+y) ) [0..7] ) [0..7]
08:05:37 <byorgey> @type \x -> mapM_ ( \y -> printf "%d %d %.2f\n" x y (x+y)) [0..7]
08:05:38 <lambdabot> forall a (m :: * -> *) b. (Monad m, Enum a, PrintfType (m b), PrintfArg a, Num a) => a -> m ()
08:05:59 <quicksilver> retybok: %.2f expects a Double or a Float, I imagine.
08:06:19 <byorgey> try fromIntegral (x+y)
08:06:23 <quicksilver> printf is painful to use in complex cases because it doesn't have proper types.
08:06:32 <quicksilver> byorgey: probably need to explicitly annotate it, in this case
08:06:40 <quicksilver> byorgey: otherwise no reason for it to default to Double
08:06:42 <byorgey> ah, right, of course
08:07:04 <byorgey> retybok: you could also try switching to a dependently typed language ;)
08:08:20 <retybok> thanks
08:09:45 <dmwit> Dependent typing seems like an overkill solution just for printing... =P
08:10:10 <dolio> rog: http://hpaste.org/10425#a1
08:10:23 <byorgey> dmwit: you can write printf really elegantly if you have dependent types though
08:10:23 <rog> quicksilver: yes, MonadRandom does seem to do what i was trying to do. i'm not quite sure how it manages to do it with only one type variable and no existential types, but i will! always interesting to see a canonical solution after struggling with a problem for a while...
08:10:43 <byorgey> but I was joking about retybok switching to such a language of course =)
08:11:20 <dmwit> rog: But MonadRandom has two type variables, of course.
08:11:27 <quicksilver> note that dolio's solution uses an existential inside an existential.
08:12:27 <rog> dmwit: not on the monad itself, which is what i was concerned about.
08:12:32 <dmwit> RandT g m a -- 'g' a generator type variable, 'a' a return value type variable
08:12:38 <halberd> I was thinking, everyone knows that counting LOC in a software project is a bad metric because it fails to encourage doing the same thing with less code
08:13:08 <osfameron> maybe you should measure lines of code in *either* direction ?
08:13:44 <halberd> so how about you have an adversarial arrangement where one programmer writes code and gets paid based on his LOC, and the other programmer examines that code to try to reduce its length without changing functionality, and gets paid some multiple of the lines he reduces, AND the second programmer's pay is deducted from the first programmer's pay
08:14:02 <dmwit> halberd: Almost all metrics are bad, including that one.
08:14:38 <halberd> the main problem is determining when the second programmer's work results in equivalent functionality
08:14:39 <osfameron> but that one is /amusing/
08:14:49 <dmwit> halberd: You almost certainly don't want an adversarial environment for your programmers; you want them to cooperate for maximum efficiency.
08:15:18 <quicksilver> depends what your objective is
08:15:23 <BeelsebobWork> halberd: the main problem is that your programs end up looking like this: ,3r6864>F~%$<7aoein‡au87Ç6∞)$•∞§
08:15:23 <dmwit> Probably the best setup is to pay them a bonus when company profits are up.
08:15:27 <quicksilver> if your objective is sick, sick, entertainment
08:15:34 <rog> dmwit: oh yes, i was looking as the MonadRandom class. oh well. i'd still like to be able to avoid more than one, but i guess it's not easy.
08:15:34 <dmwit> Tie their rewards to their results.
08:15:39 <quicksilver> then I think the adverserial system could be very funny.
08:15:53 <halberd> true Beelsebob so you would have to add in some kind of common-sense arbiter of code, someone to judge when the code reduction is uglier than it's worth
08:16:23 <dmwit> halberd: You've just introduced a very strange dynamic to the environment, which might involve some sneaky deals between original coder, adversary coder, and arbiter.
08:17:12 <learningmacros> can I make a destructive map inside a monad?
08:17:19 <dmwit> learningmacros: Yes, see HashMap.
08:17:31 <dmwit> Or STArray for more recent developments in that area.
08:18:47 <dolio> quicksilver: Actually, it uses an existential and a universal.
08:19:11 <mmorrow> you could even do something like  Map k (MVar v)
08:19:29 <dolio> The input RandomGen has to be universal, so that when you connect two together, the universal in the second can eliminate the existential from the fist.
08:19:31 <dolio> First, even.
08:22:18 <quicksilver> dolio: oh yes, of course.
08:23:29 <mmorrow> learningmacros: this looks possibly interesting: newtype MMap a b = MMap (Map a (b, MVar (MMap a b))
08:23:32 <learningmacros> $src MVar
08:24:35 <mmorrow> check out Control.Concurrent.MVar
08:24:58 <learningmacros> should that be Data.Map.empty?
08:25:11 <mmorrow> should what?
08:25:16 <learningmacros> and i need concurrney stuff in my nonconcurrent code because?
08:25:26 <learningmacros> Map ^^
08:25:40 <mmorrow> you could just swap /MVar/IORef/ if you like
08:25:45 <quicksilver> MVar just stands for 'Mutable Variable'
08:25:52 <quicksilver> it doesn't have to be used concurrently
08:25:55 <quicksilver> it's just safe to do so.
08:26:06 <learningmacros> ok
08:26:14 <learningmacros> newtype MMap a b = MMap (MMap a (b, MVar (MMap a b)))
08:26:17 <learningmacros> right?
08:26:23 <learningmacros> not: newtype MMap a b = MMap (Map a (b, MVar (MMap a b)))
08:27:13 <mmorrow> the second one
08:27:31 <learningmacros> how do i do let x = MMap "Terminator" 5 ?
08:27:44 <learningmacros> doesnt work, how do i construct an mmap?
08:28:23 <mmorrow> newMMap = MMap mempty
08:28:27 <quicksilver> frankly I think mmorrow is playing with your mind and this *really* is not what you want to do, learningmacros ;P
08:28:47 <mmorrow> yeah, i just threw that out there half seriously
08:29:05 <wjt> mmorrow: why the tuple?
08:29:15 <quicksilver> mmorrow's type is a cleverly nested deep map.
08:29:25 <quicksilver> learningmacros: most likely you just want Map a b.
08:29:38 <mmorrow> just to say that you can build structures with mutable vars just like you can immutable ones
08:29:56 <quicksilver> you can have "destruction" by constructing new values from old ones.
08:30:13 <mmorrow> Map a b is all i ever use, really
08:30:36 <quicksilver> the state monad is way of encapsulating 'new values form old ones'
08:30:44 <mmorrow> wjt: without the tuple, you can't actually store any values in it
08:31:14 <mmorrow> wjt: well, that's not entirely true, because you'd have the keys
08:31:35 <wjt> oh, i see what you're doing
08:31:51 <wjt> no, i don't. *splode*
08:32:02 <mmorrow> it'd be interesting to try diff variations on the inner map
08:32:05 <magthe> hmm, hacking up a function with signature Integer -> Day and its inverse took quite some time :(
08:32:15 * magthe feels his Haskell-fu isn't very strong
08:32:16 <mmorrow> newtype MMap a b = MMap (Map a (b, MVar (MMap a b))
08:32:19 <mmorrow> newtype MMap a b = MMap (Map a (b, MVar (MMap b a))
08:36:25 <quicksilver> #haskell : Sometimes we answer your question, sometimes we lay hideous traps which will devour your soul. It's a risk you take.
08:36:59 <sioraiocht> quicksilver: so true
08:37:03 <byorgey> @remember quicksilver #haskell : Sometimes we answer your question, sometimes we lay hideous traps which will devour your soul. It's a risk you take.
08:37:03 <lambdabot> Good to know.
08:43:24 <Taejo> > "foo" ++ ' '
08:43:26 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
08:43:31 <Taejo> as I thought
08:43:57 <Taejo> oh, precedence in my head mismatches precedence in my compiler
09:00:29 * BMeph wonders if the site 'haskelli.de' has been taken yet...
09:01:01 <kaol> Object "haskelli.de" not found in database
09:11:25 <birkenfeld> hmm... can someone explain what the ST monad is about?
09:11:35 <malouin> so the Prelude has this amazing divMod function -- now I want its inverse -- is that out there?
09:11:46 <Wild_Cat> it's like the Amiga monad, only less powerful.
09:11:54 * Wild_Cat ducks
09:12:01 <birkenfeld> malouin: inverse?
09:12:29 <birkenfeld> you mean a*b + c?
09:12:52 <malouin> birkenfeld: yeah
09:13:15 <birkenfeld> I haven't seen that as a function somewhere
09:13:28 <learningmacros> im trying to learn monads and sideffects in haskell
09:13:38 <learningmacros> basically monads can be combinated right?
09:13:43 <malouin> ok.  It's trivial to implement by hand, but so is divMod.
09:14:12 <learningmacros> im trying to implement a loop function/monad http://hpaste.org/10428
09:14:24 <learningmacros> it doesnt work though
09:14:31 <Stinger__> @ty ((+) .) . (*)
09:14:33 <lambdabot> forall a. (Num a) => a -> a -> a -> a
09:14:41 <quicksilver> birkenfeld: the ST monad is about IORefs
09:14:44 <quicksilver> birkenfeld: (or ST refs)
09:14:56 <Stinger__> @unpl ((+) .) . (*)
09:14:56 <lambdabot> (\ d g -> (+) (d * g))
09:15:04 <quicksilver> it's like the State monad, but its state is a freeform heap from which you can request new (typed) variables
09:15:29 <quicksilver> learningmacros: you're missing -> after \x
09:15:40 <birkenfeld> quicksilver: is there a "typical" usage example?
09:15:40 <quicksilver> learningmacros: and you don't want to "return" proc x
09:16:01 <quicksilver> birkenfeld: it's more often used for its array facilities STArray
09:16:19 <quicksilver> birkenfeld: which are implemented behind the scenes as mutable arrays so they might be faster than the pure equivalents
09:16:29 <quicksilver> formally speaking that's nothing you can't do with STRefs though
09:16:34 <quicksilver> (it's just an efficiency difference)
09:16:53 <quicksilver> learningmacros: probably, anyway. If proc is a monadic action, you just 'do' it, you don't 'return it'
09:17:12 <birkenfeld> ok...
09:17:17 <quicksilver> learningmacros: finally, 'do' syntax won't let you take the result of an action (acc) and not use it.
09:17:27 <quicksilver> learningmacros: you might want 'return acc' as a final line in the outer do-block
09:18:23 <quicksilver> birkenfeld: having written a fair number of haskell programs I've never used ST, if that's any indication :)
09:18:52 <quicksilver> birkenfeld: its interesting use is for 'newSTRef'. Although I suspect STUArray (mutable arrays packed in memory) is more common.
09:19:28 <learningmacros> http://hpaste.org/10429
09:19:36 <birkenfeld> quicksilver: okay
09:19:39 <learningmacros> meh
09:20:30 <Beelsebob> learningmacros: acc <- forM [1..n] proc
09:20:32 <quicksilver> learningmacros: you need parens around \x -> ...... proc x
09:20:44 <quicksilver> learningmacros: or, more commonly just a $ before the \x
09:20:53 <quicksilver> Beelsebob: true enough but I think he's experimenting ;)
09:21:01 <noecksit1> > 1+1
09:21:02 <lambdabot>   2
09:21:18 <noecksit1> > mod 26 4
09:21:19 <lambdabot>   2
09:21:33 <noecksit1> > putStrLn "hello world"
09:21:34 <Stinger__> can't \x -> do proc x just be proc?
09:21:35 <lambdabot>   mueval: Prelude.read: no parse
09:21:35 <lambdabot>  mueval: *** Exception: "<IO ()>"
09:21:54 <Stinger__> er yes already said right
09:22:16 <birkenfeld> @src forM
09:22:16 <lambdabot> forM = flip mapM
09:22:23 <birkenfeld> @src mapM
09:22:23 <lambdabot> mapM f as = sequence (map f as)
09:22:30 <birkenfeld> hah
09:22:41 <birkenfeld> I'm not stupid after all :)
09:29:42 <roconnor> > case undefined of { () -> () }
09:29:43 <lambdabot>   mueval: Prelude.read: no parse
09:29:44 <lambdabot>  mueval: *** Exception: Prelude.undefined
09:30:02 <learningmacros> he last statement in a 'do' construct must be an expression
09:30:15 <quicksilver> learningmacros: which which version of the code?
09:30:15 <learningmacros> still
09:31:58 <roconnor> why no parse?
09:32:03 <roconnor> > case () of { () -> () }
09:32:05 <lambdabot>   ()
09:32:21 <Beelsebob> > undefined
09:32:22 <lambdabot>   mueval: Prelude.read: no parse
09:32:22 <lambdabot>  mueval: *** Exception: Prelude.undefined
09:33:07 <quicksilver> roconnor: no parse on the error message
09:33:12 <quicksilver> AFAIK
09:33:33 <roconnor> oh
09:33:38 <roconnor> what does that mean?
09:34:39 <Eelis> . case undefined of { () -> () }
09:34:40 <lunabot>  luna: Prelude.undefined
10:43:28 <micahcowan> Is it possible to invoke ghc or friends with the program source as the argument (i.e., one-liners)? "main = getContents >>= mapM_ (putStrLn . reverse) . lines" and such progs
10:44:24 <shepheb> micahcowan: ghc -e 'print 3'
10:44:53 <shepheb> see also interact
10:45:00 <shepheb> @src interact
10:45:01 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:45:15 <wman> hi, anybody remembers the old hircules irc client ?
10:45:49 <shepheb> micahcowan: so you above example could be run as:  ghc -e 'interact (unlines . reverse . lines)'
10:48:25 <wman> or is sb. willing to test a port of hircules to recent ghc ? the thing is it compiles, but shows empty window, and i don't know whether its standard behavior, or just our firewall ...
10:50:11 <chrisdone> types at the start or at the end? :) http://github.com/chrisdone/lojbot/tree/master/Lojbot.hs
10:50:13 <lambdabot> Title: Lojbot.hs at master from chrisdone's lojbot — GitHub
10:50:31 <dancor> does ghc6.9 Control.Exception not have ioErrors?
10:50:37 <dancor> trying to build Network
10:51:41 <dancor> network-2.2.0.0 that is
10:54:58 <micahcowan> shepheb, of course you're right, thanks.
10:56:12 <dancor> where is network darcs anyway
10:56:46 <micahcowan> shepheb, though the example's wrong; s/b: ghc -e 'interact (unlines . map reverse . lines)'
10:56:59 <dancor> ah, http://darcs.haskell.org/packages/network
10:57:10 <lambdabot> Title: Index of /packages/network
10:57:54 <dancor> that one builds
10:58:16 * dancor keeps you updated bc he knows you care
11:05:19 <pcc1> if I have an IO monad encapsulated within a lazy state monad, can IO operations be skipped via laziness?  if not, how can I do this? interleave?
11:07:20 <Zao> pcc1: An IO action is not executed until it's executed, so you could build up a set of IO actions and selectively run some later.
11:09:58 <mattam> Could someone explain what the "vect n" monad of vectors of length n could be used for. I gather the unit is [repeat] and the [join] is taking the diagonal. The example is from http://www.e-pig.org/downloads/epigram-notes.pdf section 3.5
11:10:01 <lambdabot> Title: Epigram: Practical Programming with Dependent Types
11:13:02 <pcc1> hmm, looks liek I'll need a lazy andM
11:13:53 <lilac> mattam: sounds like SIMD
11:14:06 <shepheb> pcc1: sounds like liftM2 (&&)
11:14:41 <Apocalisp> Applicative is so my new favourite thing: (if' . null . f <*> show <*> f) n
11:15:27 <Apocalisp> written just like you would say it
11:15:41 <lilac> pcc1: i suspect that 'return . unsafePerformIO :: IO a -> IO a' may do what you want, but I'm not 100% sure.
11:17:34 <mattam> lilac: Well, you're not supposed to lose information in SIMD right?
11:17:54 <pcc1> shepheb: seems like it but I need it like "and" with a list of args.  if I combine with fold would it still be lazy?
11:18:25 <pcc1> lilac: hmm, would prefer to avoid anything unsafe if possible, I think "andM" can do it
11:18:30 <Baughn> chrisdone: So, how about that cafe post? (You may have guessed - I want to know the reason too)
11:19:06 <lilac> pcc1: sure. the unsafePerformIO trick appears to work, but it's not really referentially transparent :-/
11:20:41 <shepheb> oh, that kind of and
11:20:52 <shepheb> what monad?
11:21:23 <pcc1> combined lazy state and IO (well actually IO could change to something encapsulated)
11:22:01 <shepheb> okay, but could you and purely, and then do something monadic?
11:22:34 <pcc1> well the "conjuncts" involve monadic computation
11:23:00 <pcc1> and I'd like it to be lazy
11:23:58 <pcc1> hoogle (Monad m) => [m Bool] ->  m Bool
11:24:19 <pcc1> @hoogle (Monad m) => [m Bool] ->  m Bool
11:24:20 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:24:20 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
11:24:20 <lambdabot> Data.Generics.Basics fromConstrM :: (Monad m, Data a) => m a -> Constr -> m a
11:25:39 <pcc1> looks like I'll have to write one myself
11:26:02 <mc__> has anyone in here ever applied TDD to haskell?
11:26:44 <Myoma> ?veal TDD
11:26:44 <lambdabot> antiparsimony were 100% correct...
11:27:03 <byorgey> mc__: sure, take a look at QuickCheck, for example
11:27:24 <Jaak> QCDD
11:27:29 <Myoma> ?vera TDD
11:27:40 <lambdabot> *** "tdd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:27:40 <lambdabot> TDD
11:27:40 <lambdabot>      Telecommunications Device for Deaf
11:27:40 <lambdabot>  
11:27:40 <lambdabot> *** "tdd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
11:27:42 <lambdabot> [3 @more lines]
11:27:42 <mc__> byorgey: I'll do, thanks.
11:27:47 <Myoma> @more
11:27:47 <lambdabot> TDD
11:27:47 <lambdabot>      Time Division Duplex (mobile-systems)
11:27:48 <lambdabot>  
11:27:52 <guenni> hi, anybody here using ghc on win32?
11:27:53 <byorgey> Myoma: Test-Driven Development, I assume.
11:32:16 <pcc1> :q
11:32:22 <pcc1> oops
11:38:00 <FunctorSalad> does the "a" in a GADT decl like "data Term a where ..." mean anything?
11:38:12 <FunctorSalad> other than that the kind of Term is * -> *
11:38:44 <Baughn> FunctorSalad: No.
11:38:58 <Baughn> It's just a type parameter
11:39:16 <Baughn> (And, given that it's a GADT, of even less meaning than usual)
11:39:23 <Myoma> FunctorSalad: it may not be * -> *
11:39:29 <Myoma> or must it. .
11:39:43 <FunctorSalad> that's slightly confusing if a is used in the body too... maybe allow the syntax to "data Term :: (* -> *) where ..."?
11:39:55 <mrd> you can write data Term :: * -> *
11:40:03 <Myoma> the kind will be inferrend
11:40:19 <FunctorSalad> yeah I mean I don't want to give the variable a name if it's never used
11:40:44 <Myoma> I don't know if you need -XKindSignatures or not
11:41:04 <dejones> Any recommendations on a research paper to present to a group that is not familiar with Functional Programming (or Haskell)?  Maybe http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9516  ??
11:41:05 <lambdabot> Title: Introduction to functional programming - CiteSeerX
11:41:26 <FunctorSalad> Myoma: oh cool, that works
11:41:41 <FunctorSalad> namely, "data FreeApplicative :: ( * -> * ) where ..."
11:41:55 <Twey> dejones: 'Why Functional Programming Matters' is quite famous
11:42:28 <dejones> Twey: Yah, that was the other paper I had in mind...  Any preference for one or the other?
11:42:28 <dejones> :)
11:42:37 <FunctorSalad> Myoma: I'm used to ghc telling me in the error messages what I have to enable, so I didn't even look for sth like -XKindSignatures
11:42:44 <mrd> Y(FP)=FP(Y(FP))
11:43:17 <dejones> mrd: nice.  ;)
11:43:22 <Twey> dejones: I would certainly recommend WFPM, although I haven't read 'Introduction' so I can't compare :-\
11:43:26 <Myoma> ?wiki functional pearls
11:43:27 <lambdabot> http://www.haskell.org/haskellwiki/functional_pearls
11:43:40 <Myoma> dejones: there's a whole bunch of really good papers not on that page
11:43:51 <dejones> Myoma: (There is currently no text in this page)
11:43:57 <dejones> ?
11:44:05 <Myoma> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
11:44:07 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki, http://tinyurl.com/238y2c
11:44:18 <dejones> Myoma: It seems the page was moved: http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
11:44:20 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki, http://tinyurl.com/238y2c
11:45:18 <dejones> Myoma: or is that a different page..?
11:46:00 <dejones> I think it is the correct page.  :)
11:47:39 <sw17ch> for those of you who graduated with a CS degree, how many were in your graduating class?
11:52:08 <Baughn> sw17ch: Hm. Three?
11:52:15 <Baughn> Plus me
11:53:30 <sw17ch> Baughn: mind if i ask where?
11:53:45 <mrd> sw17ch: I wasn't in CS but I think there was about 100 people in my year
11:53:46 <sw17ch> i shuold clarifiy, also graduated in CS
11:54:01 <sw17ch> I graduated with CS and graduated along with 7 other CS majors.
11:54:09 <sw17ch> (i think)
11:54:21 <Baughn> sw17ch: Not at all
11:54:50 <Baughn> Before you ask, uit.no
11:55:02 <Nafai> sw17ch: I think there were like 15-20, but I can't remember for sure
11:55:32 <Baughn> There were ten-twenty in my class when we started. Quite typical fall-off, I guess..
11:55:34 <Nafai> sw17ch: But that might have included graduate students, I'm just thinking of those at the graduation dinner
11:55:45 <Baughn> Most got killed by the inexplicable calculus course
11:55:52 <dblazaki1> sw17ch: 35-50 i think
11:56:51 <sw17ch> wow...
11:56:55 <dblazaki1> sw17ch: graduated about 3 years after the collapse of the dot com bubble in the US, so our classes were huge for the first year, then most people failed :-)
11:57:11 <sw17ch> I'm just watching my old CS department making some sad decisions to attract students :(
11:57:23 <sw17ch> dblazaki1, wow...
11:58:00 <Myoma> :t ap
11:58:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:58:04 <sw17ch> in my case, it was a private i'll-be-paying-for-it-for-50-years liberal arts school... the CS graudates were either awesome, or awful
11:58:08 <Myoma> :t ap
11:58:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:58:25 <Baughn> [(+1),(+3)] `ap` [1..4]
11:58:32 <Baughn> > [(+1),(+3)] `ap` [1..4]
11:58:34 <lambdabot>   [2,3,4,5,4,5,6,7]
11:58:59 <sw17ch> any way, i was just curious. thanks.
11:59:40 <mapreduce> sw17ch: I'm not sure how my old CS dept could get any worse.
11:59:52 <dejones> sw17ch: undergrad class?  or grad-school?
11:59:53 <sw17ch> mapreduce, oh really?
11:59:54 <mapreduce> Move back to Pascal perhaps.
12:00:05 <Baughn> > (+) `ap` 2 3
12:00:06 <lambdabot>       Overlapping instances for Show (a -> a)
12:00:07 <lambdabot>        arising from a use of `s...
12:00:24 <sw17ch> dejones, i'm undergrad... i can't afford to move, and there aren't any universities near me that i could really pursue
12:00:29 <sw17ch> i *was* undergrad
12:00:31 <sw17ch> i'm done now
12:00:51 <sw17ch> i'd love to do graduate work some day, just can't afford it right now :)
12:00:59 <Apocalisp> hey man, Pascal served me well
12:01:28 <dejones> sw17ch: If you have good grades / test scores, grad-school usually gets paid for by research grants...
12:01:29 <Level2Tech> I wish you are right
12:01:47 <dejones> sw17ch: Just get accepted to a grad program, you do research with a prof, they pay your tuition + stipend, normally.
12:01:51 <sw17ch> dejones, i'd have no problem getting in, it's just a matter that i can't really move right now
12:01:53 <Level2Tech> Usually is a bit optimistic
12:02:02 <mapreduce> Apocalisp: Can you remember how to make a variable that could hold a string that's not bound to a max length at compile time?
12:02:07 <sw17ch> dejones, and i'd have to get used to a 50% pay cut :)
12:02:25 <Level2Tech> Sometimes or occasionally would be a better way to describe it
12:02:34 <Baughn> mapreduce: You couldn't, could you?
12:02:44 <Baughn> I still have nightmares of my 10,000-plus-line sorting module
12:02:46 <dejones> sw17ch: haha, well, that is a different story.  ;)
12:02:53 <mapreduce> Baughn: I believe you could get access to normal pointers.
12:03:00 <sw17ch> dejones, are you in a graduate program, or are you done?
12:03:02 <Baughn> mapreduce: Not in plain pascal
12:03:10 <mapreduce> Baughn: Turbo Pascal.
12:03:19 <dejones> sw17ch: I'm in my last semester of Master's program.  I just accepted a position with NVIDIA; I start in January.
12:03:20 <Baughn> mapreduce: Eh. Lucky you.
12:03:32 <sw17ch> dejones, friggen awesome! where at?
12:03:40 <sw17ch> (the mastersp rogram that is)
12:03:41 <mapreduce> I never did Pascal as part of a course.
12:04:00 <Baughn> We used pascal in high school
12:04:10 <Baughn> ..well, others used pascal. I did my very best to avoid it.
12:04:14 <dejones> sw17ch: Master's program at Univ of Kentucky.  NVIDIA in Austin, TX.
12:04:32 <sw17ch> dejones: you don't happen to know a Tim Brom do you?
12:04:39 <sw17ch> i believe he's attached to the physics department
12:04:47 <sw17ch> but working on a CS masters
12:05:16 * sw17ch apologizes for the Dutch Bingo
12:05:30 <aculich> sw17ch: what kind of stuff are you going to work on at nvidia?
12:05:44 <sw17ch> aculich, not me, dejones
12:05:53 <aculich> ah, yeah, sorry about that
12:05:59 <dejones> sw17ch: haha, yes, I know Tim pretty well actually.  I've had a few classes with him.  How do you know Tim?
12:06:17 <aculich> dejones: redirecting my question to you.... what kind of stuff are you going to work on at nvidia?
12:06:33 <sw17ch> hah! he was one of my good friend's room mates through college. he's a year ahead of me. he may take a position at my employer when he's done
12:06:48 <dejones> aculich:  "Senior Compiler Test Engineer"  -- not Haskell stuff -- I start in testing in the Compilers group since I don't have a PhD or 15+ yrs of experience, lol
12:06:52 <sw17ch> his friend and i are both at the same place... actually, tim's the last person who graduated in the 3 year window that i'm part of
12:06:55 <sw17ch> that doesn't work here
12:06:56 <Apocalisp> sw17ch: tie your research into global warming or black holes (or both!) and you're all set.
12:07:11 <aculich> ah, i was hoping it was haskell-related...
12:07:14 <dejones> sw17ch: Ah yes, Tim has told me that he hopes to get a position at your employer.  Embedded programming, right?
12:07:25 <aculich> ...there is someone already working on an cuda back end for haskell
12:07:35 <sw17ch> dejones: among other things. i do a lot of high level to low level integration (making 8 bit micros talk HTTP, etc...)
12:07:35 <Apocalisp> mapreduce, no. No, I don't. :)
12:07:40 <aculich> which is something i'm interested in
12:07:50 <sm> good morning all. Trying to cabal install hsp, I get Configuring haskell-src-exts-0.3.7... cabal: happy version >=1.17 is required but it could not be found. What to do ?
12:07:50 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
12:07:55 <dejones> aculich: Yes, that is Sean Lee.  He was an intern at NVIDIA over the Summer.
12:08:06 <dejones> aculich: I am going to look into his work -- maybe I can get to do some of that too.  ;)
12:08:08 <dcoutts> sm: install happy
12:08:16 <Apocalisp> mapreduce, oh wait... something about null-terminated strings.
12:08:18 <aculich> dejones: that would totally rock
12:08:20 <sw17ch> dejones: ah, well, say hi to Tim for me.
12:08:21 <noteventime> aculich: Link? )
12:08:33 <dejones> sw17ch: Cool stuff.  What's your name?  (For me to tell Tim, heh.)
12:08:34 <sw17ch> dejones, and if you're ever in the Grand Rapids area, look us up :)
12:08:40 <dejones> sw17ch: Definitely.  :)
12:08:42 <sw17ch> dejones, John Van Enk
12:08:55 <dejones> sw17ch:  Thanks.
12:09:08 <dejones> aculich: Yes, definitely.... Hopefully I get lucky, heh.
12:09:14 <aculich> noteventime: you want a link to steven lee's work? nothing is release so far
12:09:34 <stulli> Is there any state monad tutorial without using 'Random'?
12:09:38 <noteventime> aculich: I mean the Haskell/CUDA integration
12:09:45 <sm> dcoutts: I see, there is a happy 1.17 there. Wonder why it didn't see it
12:09:50 <dejones> noteventime: Sean Lee is his name.  He is at Univ of New South Wales.
12:09:58 <dcoutts> sm: it does not track build-tools yet
12:10:07 <dejones> noteventime, aculich: Sean Lee is sometimes on IRC too.  ;)
12:10:10 <aculich> dejones: well, you have my vote if that counts at all! heh
12:10:11 <sm> I see, thank you
12:10:19 <dejones> aculich: Hehe, thanks.  :)
12:10:25 <sm> many thanks for your cabal/hackage work
12:10:26 <aculich> dejones: yeah, i've talked to him a bit
12:10:30 <noteventime> dejones: I see
12:10:39 <dcoutts> sm: :-)
12:10:39 <dejones> noteventime: seanl is his IRC nick, I believe.
12:10:54 <dejones> Good talking to you all.  I gotta get back to work.  :)
12:10:55 <dejones> Cya.
12:10:59 <aculich> dejones: yeah, i'm working on some computer vision stuff with cuda... and i would much rather write in haskell than C if i could
12:11:08 <dejones> aculich: haha, I bet.  ;)
12:11:21 <pfo> ghc 6.9 is the development version of ghc?
12:11:28 <dejones> pfo: Yes.
12:11:44 <dejones> noteventime, aculich, sw17ch: Back to work, cya.  :)
12:11:51 <sw17ch> dejones, cya
12:11:52 <aculich> noteventime: http://www.cse.unsw.edu.au/~seanl/research.html
12:11:53 <lambdabot> Title: Sean LEE
12:12:28 <noteventime> aculich: I'll try to keep an eye on it :)
12:12:32 <noteventime> Thanks
12:13:04 <sm> dcoutts: happy installed, but I get the same message. How do I tell it everything is fine ?
12:13:29 <dcoutts> sm: configure again
12:14:06 <sm> in .cabal/ or somewhere ?
12:14:19 <sm> aha
12:14:44 <dcoutts> sm: oh, perhaps it's the $PATH thing?
12:15:14 <dcoutts> sm: currently cabal installs binaries to somewhere that's not on the default path, because we've not all been able to agree on what it should do
12:16:13 <sm> ok.. configure in the src dir gives the same message. Can cabal tell me where the happy files got installed ?
12:16:53 <dcoutts> sm: it'll have been installed to ~/.cabal/bin which is probably not on your path
12:16:58 <sm> ahh
12:17:24 <dcoutts> sm: you can either put that on your path, or tell cabal in future to put binaries in ~/bin, or to add symlinks into ~/bin
12:17:35 <pfo> why is it that the last haskell standard was issued nearly ten years ago?
12:17:46 <sm> great, that was it.
12:18:01 <BMeph> pfo; Because humans read slowly? ;)
12:18:05 <dcoutts> pfo: the new one is nearing completion
12:18:11 <pfo> haskell standardisation is not due to ansi/iso bodies?
12:18:59 <dcoutts> pfo: it was standardised by a committee and it was published in the journal of functional programming
12:19:22 <Baughn> A committee consisting of whom? Based on what authority?
12:19:28 <BMeph> pfo: My hope is, Haskell is inocculated to resist ANSI-bodies... ;p
12:19:42 <Baughn> That is to say, why is a haskell standard interesting, as opposed to just tracking ghc as best we can?
12:20:31 <pfo> BMeph: c++ is out of hope for any fixing since it's ANSI standardised and the last greater standard is from '98 (also like 10 years)
12:20:35 <dons> ?users
12:20:35 <lambdabot> Maximum users seen in #haskell: 511, currently: 498 (97.5%), active: 28 (5.6%)
12:20:46 <Botje> what about C++0x ?
12:20:52 <pfo> is GHC converging to the new standard or will it be something far off from what ghc implements now?
12:21:47 <Baughn> The standard is converging on ghc, more like. It will, hopefully, write down what is already standard practice in the various haskell implementations
12:21:59 <pfo> i see
12:22:02 <Baughn> Though it would be nice to have some actual compatibility breaches. Like fixing MonadZero. :/
12:22:26 <BMeph> pfo: I'd consider GHC a de facto standerd, and as a de facto standard, it's more of a challenge to the ambitious to do better, than an authority to be copied. :)
12:22:45 <BMeph> *standard
12:23:18 <BMeph> Baughn: And the whole Num thing... :/
12:23:28 <quicksilver> nonetheless, it seems likely that Haskell' will contain some of what is now in GHC and very little which is not now in GHC
12:24:22 <pfo> GHCi is kinda strange for me. it has no multiline support which makes it kinda useless as a REPL shell.
12:24:28 <pfo> is there any fix for this ?
12:24:36 <Myoma> pfo: it does
12:24:48 <Baughn> pfo: Anyhow, for most practical purposes, ghc defines haskell. There are sometimes reasons for using one of the others instead, in which case you'll care about the standard more, but anywhere ghc works at all it tends to be the best choice
12:25:09 <quicksilver> pfo: how does lack of multiline support make a repl useless?
12:25:29 <dons> ghci has multiline support!
12:25:35 <pfo> quicksilver: i want to use more than simple expressions.
12:25:36 <Baughn> pfo: The usual workflow is to have a scratch.hs (or whatever), then :reload instead of typing definitions into ghci where they can get lost
12:25:36 <dons> use :{ and :}
12:25:53 <pfo> how can i paste more than a line into ghci?
12:25:56 <quicksilver> pfo: all haskell expressions, however complex, can be expressed on a single line.
12:26:04 <dons> pfo: like so..
12:26:20 <mapreduce> When can ghci allow data, newtype, etc.?
12:26:24 <quicksilver> (in the sense of, without carriage returns)
12:26:27 <quicksilver> mapreduce: when you submit the patch.
12:26:32 <quicksilver> (or, shortly after that time)
12:26:36 <dons> ghci
12:26:37 <dons> Prelude> :{
12:26:37 <dons> Prelude| let f x | x > 1 = True
12:26:37 <dons> Prelude|         | otherwise = False
12:26:37 <dons> Prelude| :}
12:26:40 <dons> Prelude> f 2
12:26:40 <Valodim> is there a trim-function?
12:26:45 <bjrn> What's the hackage naming policy for software that's currently too slow to be usable in practice, but is still worth releasing?
12:26:46 <Valodim> as in, cut whitepsace left and right of a string?
12:26:47 <pfo> quicksilver: i know i don't want to convert multiline pastes to single line ones.
12:26:54 <dons> pfo: see above.
12:26:57 <dons> ghci supports multiline input.
12:27:00 <Deewiant> Valodim: reverse . dropWhile isSpace . reverse . dropWhile isSpace
12:27:01 <pfo> i see.
12:27:04 <dons> QED.
12:27:08 <quicksilver> pfo: dons gives a good answer. Nonetheless, I don't use it.
12:27:16 <Myoma> > (unwords . words) "          ?      "
12:27:17 <lambdabot>   "?"
12:27:19 <quicksilver> pfo: I use M-^ in emacs to combine my pastes into a single line :)
12:27:29 <quicksilver> pfo: or I dump it into test.hs and load it.
12:27:39 <pfo> i see
12:27:42 <Valodim> that reverse thing looks awfully inefficient :P
12:27:44 <guenni> how does one install "newer" packages with ghc?
12:27:46 <Deewiant> > (unwords . words) "  foo   bar  "
12:27:47 <lambdabot>   "foo bar"
12:27:50 <Deewiant> Myoma: breaks that
12:27:50 <Valodim> good thinking on words.unwords. thank you
12:27:51 <pfo> thanks
12:28:00 <Deewiant> Valodim: as you can see, it's not the same though
12:28:01 <Valodim> right but works for me
12:28:03 <quicksilver> guenni: cabal install is a good way
12:28:43 <guenni> quicksilver: I had hoped so, but it seems old versions remain and cause conflicts
12:28:53 <quicksilver> the old versions indeed remain
12:28:59 <quicksilver> but they should not, in themselves, cause conflicts.
12:29:16 <quicksilver> rather the conflicts are caused when you have a library which is compiled against an old version of something
12:29:21 <guenni> I get some "ambigous" symbol ...
12:29:23 <Baughn> guenni: You may have other (old) packages that depend on the packages you have upgraded. You must upgrade/reinstall those too
12:29:24 <quicksilver> and try to pull it in at the same time as a new version of the same thing
12:29:41 <quicksilver> unfortuantely you must recompile anything dependent on the things you have upgraded :(
12:29:55 <guenni> Baughn: that turns out to very very tricky
12:30:03 <Baughn> guenni: Doesn't it?
12:30:12 <Baughn> There are no simple solutions, though
12:30:28 <guenni> especially if you're on Win32 let me tell you
12:30:34 <Baughn> 6.10 should have a partial solution
12:31:01 <guenni> Baughn: thx, that makes me feel better
12:31:11 <Baughn> (Which will, unfortunately, come at the cost of performance; it'll disable cross-package optimization, if you use it)
12:31:16 <Apocalisp> Is there a type class for types whose values form a taxonomy?
12:31:33 <dons> ghc is a whole program compiler. we must just accept that.
12:31:38 <dons> and enjoy the performance win.
12:31:46 <quicksilver> Apocalisp: I think the answer is "No", but I'm intrigued. What kind of thing are you thinking of?
12:31:47 <guenni> quicksilver: is there some swithc where I can force recompilation?
12:31:53 <Myoma> when is 6.10 out?
12:32:07 <quicksilver> guenni: you'd have to ask someone who knows more about cabal than me
12:32:07 <Level2Tech> lol...sounds like haskell is a big hassel
12:32:16 <quicksilver> it seems like a sensible feature to ask for.
12:32:42 <guenni> I need help from somebody here who knows more about Cabal than quicksilver !
12:32:46 <Level2Tech> isnt that the enemy force in tradewars
12:32:48 <Baughn> Level2Tech: The tools aren't quite mature yet. Given that what they'd have to do to be mature is rapidly changing, that's okay
12:32:50 <dcoutts> guenni: you can cabal clean --save-config
12:32:56 <Level2Tech> man I loved trade wars and killing cabal
12:33:02 <Apocalisp> quicksilver, values that are subtypes/supertypes of one another but may not have any order.
12:33:04 <Level2Tech> ahh the days
12:33:18 <Baughn> Level2Tech: Anyway, the problem here is that haskell supports cross-module and cross-/package/ optimization, which no other language does
12:33:21 <Baughn> Or, okay, ghc supports it
12:33:24 <guenni> dcoutts: ?
12:33:49 <Baughn> Level2Tech: So it's a minor inconvenience to pay for a major plus, /and/ it will be togglable soon
12:34:03 <dcoutts> guenni: you wanted to recompile something, cleaning and building is one simple way
12:34:25 <dcoutts> guenni: or cabal build --ghc-option=-recomp or something like that, I forget the exact ghc flag
12:34:43 <pfo> Baughn: intel's c++ compiler supports whole program compilation/optimization
12:34:53 <guenni> dcoutts: so that is possible, good to know
12:34:58 <Baughn> pfo: But not cross-package optimization
12:35:05 <dons> yeah, there's lots of whole program compilers out there.
12:35:08 <pfo> Baughn: what exactly is that?
12:35:08 <dons> mlton
12:35:17 <quicksilver> -fforce-recomp
12:35:20 <Baughn> pfo: Things like inlining code from bytestring in programs that /use/ bytestring
12:35:20 <quicksilver> is the GHC flag, IIRC.
12:35:28 <dons> getting a library inlined into your program, specialised to it, and then awesomely fast == win
12:35:29 <dcoutts> quicksilver: ah yes, thanks
12:35:31 <pfo> yeah, i think even gcc will do that soon.
12:35:42 <Apocalisp> quicksilver, the specific application is geographical subdivisions.
12:35:47 <Baughn> Right. Cross-module optimization is getting common
12:35:49 <dons> Data.Binary, for example, is almost entirel inlined
12:35:50 <pfo> nice!
12:35:57 <Baughn> The uncommon thing is cross-package optimization
12:36:15 <quicksilver> Apocalisp: sounds like what I would call a partial order
12:36:24 <quicksilver> Apocalisp: I don't think there is a typeclass for that
12:36:32 <Baughn> But yeah, cabal could be more helpful. Suggesting "type cabal install-recursive foo to fix this", say
12:36:41 <quicksilver> would be interesting to see how useful it was
12:36:50 <pfo> is there any info on what (static) analysis GHC is able to perform?
12:36:50 <Apocalisp> quicksilver, that sounds about right. Values may be greater, lesser or equal, but also disjoint.
12:36:56 <guenni> quicksilver: is that a ghc flag, or a cabal flag?
12:37:09 <dons> pfo: sure. a big stack load of papers on this. see haskell.org/ghc
12:37:27 <quicksilver> Baughn: better still, on installing a new version of "foo" it should say "bar,baz and bam depend on the old version of foo, you may wish to recompile them by typing the following command..."
12:37:42 <quicksilver> guenni: it's a GHC flag which you pass to cabal using --ghc-option
12:37:48 <quicksilver> if I'm correctly understanding dcoutts
12:37:54 <dcoutts> right
12:38:00 <Baughn> quicksilver: Better still, "bar,baz and bam depend on the old version of foo, press enter to upgrade them as well or ctrl-c to cancel"
12:38:03 <guenni> thx
12:38:34 <Baughn> "Or type no to skip the upgrade, at your own risk"
12:38:51 <quicksilver> Baughn: better still "I have read your mind and not only have I reinstalled bar, baz and bam, but I've done your laundry and your ironing, made a curry for supper, and spend my spare cycles developing a new auto-parellisation flag for GHC 6.12"
12:38:54 <Level2Tech> Hey snaggletooth snitches
12:38:55 <quicksilver> now *thats
12:39:02 <quicksilver> * a version of cabal I could learn to love
12:39:22 <Baughn> quicksilver: That's right, I was going to look at that new mind-reading gadget..
12:39:36 <Baughn> Wonder if it's released to shops yet
12:39:42 <Apocalisp> I'll get cracking on the steam iron interface
12:39:52 <Baughn> Ah. No. Postponed to christmas, now
12:45:33 <bjrn> This is probably in the docs, but I can't find it. If a cabal file has both a library and executable, how do I build just the program?
12:46:13 <Deewiant> --disable-library-vanilla?
12:46:29 <dcoutts> bjrn: you cannot, it always builds all of it.
12:46:30 <Deewiant> not sure, never used that flag, but it sounds like it might be right :-P
12:46:44 <dcoutts> Deewiant: oh hmm, sneaky. I'm not sure what it'd do actually :-)
12:47:02 <Deewiant> if it's the dual to --disable-library-profiling then it might be that
12:47:56 <dcoutts> bjrn: if this is just a convenience thing I guess just put up with it, but if you really want to build them separately then it might want to make them separate packages
12:48:24 <spx2> are there SDL bindings for haskell ?
12:48:29 <Deewiant> yes
12:48:36 <spx2> can OOP be made in haskell ? (just out of curiosity)
12:48:39 <BMeph> dcoutts: Here's a fun one, if you have any ideas - how does my cabal installation know there are later versions available of packages I have installed?
12:48:41 <spx2> Deewiant: thank you :)
12:48:49 <Deewiant> ?hackage SDL
12:48:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL
12:49:09 <spx2> Deewiant: does haskell have something like cpan ?
12:49:10 <dcoutts> BMeph: because it has the hackage index (which you can update using cabal update)
12:49:12 <BMeph> dcoutts: When it bombs out w/ a 403 error every time I try a 'cabal update'? :/
12:49:16 <Deewiant> spx2: hackage is it
12:49:27 <Deewiant> with cabal-install being the tool
12:49:29 <spx2> Deewiant: I suspected that :)
12:49:34 <dcoutts> BMeph: sounds like you've got a dodgy proxy
12:49:58 <BMeph> dcoutts: Aye. Feel my pain.
12:50:06 <dcoutts> BMeph: if you've got the HTTP_PROXY, or http_proxy then try without
12:50:15 <spx2> can OOP be made in haskell ? (just out of curiosity)
12:50:16 <spx2> ?
12:50:22 <dcoutts> BMeph: if it's a transparent proxy then try the latest or dev version of the HTTP package
12:50:44 <Apocalisp> ?faq can OOP be made in haskell ?
12:50:44 <lambdabot> The answer is: Yes! Haskell can do that.
12:50:52 <spx2> wow
12:50:56 <spx2> Apocalisp: rly ?
12:51:00 <spx2> Apocalisp: maybe some examples ?
12:51:07 <spx2> Apocalisp: if you are kind :)
12:51:09 <guenni> anybody know where I can get Win32-2.1.1.1 from?
12:51:22 <BMeph> dcoutts: Likely, the proxy is corporate-controlled.
12:51:33 <Apocalisp> spx2, why would you want to though?
12:51:40 <spx2> Apocalisp: to be versatile
12:52:09 <Apocalisp> spx2: well, you could eat a bit of poison with your food and call yourself versatile.
12:52:16 <spx2> Apocalisp: does FP as functionality overpower OOP ? (I have done some FP but not very much)
12:52:39 <Apocalisp> spx2: I don't think that FP and OOP are disjoint, nor are they well defined.
12:52:51 <dcoutts> BMeph: ok, I'd try the darcs version of the HTTP lib, try with cabal update -v3 and also with wget/curl --whatever-the-flag-is-to-log-the-http-headers-sent
12:52:56 <spx2> Apocalisp: how long have you been coding haskell ?
12:53:10 <BMeph> dcoutts: Every time I try to get HTTP, it tries to reload network-2.2.0.0, which is bombing out on the sh.
12:53:21 <dcoutts> BMeph: ah you're also on windows ?
12:53:25 <Apocalisp> spx2, it's been a couple of years now, I think
12:53:31 <Baughn> What was the command to have ghci compile to object code, again?
12:53:43 <BMeph> dcoutts: Yeah - it's the corporation's idea, not mine. ;)
12:54:07 <dcoutts> BMeph: if you could report the log comparing cabal-install and wget/curl in a ticket that'd be really useful
12:54:19 <Baughn> -fobject-code. Doh.
12:54:49 <Baughn> ..of course, now I can't turn it off. :/
12:54:53 <dcoutts> BMeph: but as I say I think this has been noticed before and may be fixed in the darcs version of the HTTP package, so that's worth a try
12:55:00 <BMeph> dcoutts: Will do. Now to scan the wget man page... :)
12:55:04 <dcoutts> BMeph: either way I'd like to get to the bottom of it
12:55:20 <david48> Hi everyone.
12:55:38 <dcoutts> BMeph: when I looked at man wget I seem to recall finding an option to dump the response but not the request
12:55:45 <dcoutts> BMeph: lemme check man curl
12:55:59 <wolverian> hm. can I not declare a context in a GADT constructor type, if I use record syntax? GHC gives me a "malformed constructor result type" error.
12:57:31 <Baughn> I've got function names with unicode (norwegian) characters in. Is it at all possible to make ghci print them properly?
12:58:24 <Myoma> :(
12:58:28 <Myoma> it should happen automatically
12:59:17 <SamB_XP> Baughn: I suggest hurling large objects in the general direction of the UK
12:59:20 <opqdonut> wolverian: you mean like "data Foo a where Foo :: Ord a => a -> Foo a"
12:59:23 <opqdonut> ?
12:59:31 <Baughn> SamB_XP: Would Ceres do?
12:59:46 <SamB_XP> Ceres?
12:59:48 <spx2> Apocalisp: and how do you do OOP in it ?
12:59:48 <spx2> Apocalisp: and would you do OOP over FP for some projects ? if so,what projects ?
12:59:48 <spx2> Apocalisp: when do you choose between them ? why do you say they are not disjoint ? (I somehow agree here)
13:00:51 <Myoma> mattam: I'm not sure the monad has much use.. ap should be just like fmap on the vector I think?
13:01:22 <Baughn> SamB_XP: For shame. You don' even know about Ceres? ;_;
13:01:29 <Myoma> oh no, more like zipWith (flip ($))
13:01:44 <SamB_XP> Baughn: it sounds vaguely like a celestial body
13:01:55 <Baughn> Oh yeah. I've got four lines of slightly icky code at http://hpaste.org/10437; anyone want to tell me how I should have written it?
13:02:18 * Myoma wonders why you have added a ;
13:02:27 <Baughn> It fit the sentence.
13:02:40 <Baughn> (And my terminal is smart enough not to include the ; in the url)
13:02:48 * Myoma neither
13:03:23 <wolverian> opqdonut, data Foo a where Foo { a :: Int } :: Ord a => Foo a
13:03:45 <SamB_XP> why, why is x-chat so dumb about that ?
13:04:00 <opqdonut> you need to say "where Ord a => Foo { a :: Int } :: Foo a" perhaps?
13:04:12 <wolverian> didn't try. let's see.
13:04:12 <sw17ch> Baughn, isn't a ';' valid in URL's?
13:04:29 <wolverian> no, that's a parse error. :)
13:04:50 <Baughn> sw17ch: I don't recall seeing it, but it probably is
13:05:00 <wolverian> the manual doesn't have an example with record syntax + context (8.4.6), hmm.
13:05:06 <sw17ch> Baughn, actually, i'm certain it is. news.yahoo.com uses it on all their stories.
13:05:13 <sw17ch> Example: http://news.yahoo.com/s/ap/20080916/ap_on_bi_st_ma_re/wall_street;_ylt=AgRKSjQ6zUPhoVFW7RhHOa6s0NUE
13:05:15 <lambdabot> Title: Stocks fluctuate after Fed keeps rates unchanged - Yahoo! News, http://tinyurl.com/5f37ul
13:05:21 <Baughn> Hmm. http://foo.bar/baz;baz;baz
13:05:39 <SamB_XP> sw17ch: well, the times when it occurs at the end of a URL are surely MUCH less frequent than when it is used to punctuate the sentence in which the URL appears ...
13:05:41 <Baughn> It only skips a semicolon at the /end/. Nice terminal.
13:06:02 <sw17ch> SamB_XP, yes... good point :)
13:06:15 <sw17ch> Baughn, i suppose, statistically, your terminal is more correct than mine :)
13:06:16 <Baughn> I don't see why people complain so much. Apple did a good job on it. :P
13:06:34 <SamB_XP> ONE of those two cases, of course, must be handled manually -- it's only a matter of which one
13:06:39 <Baughn> Well, it would be nice not to have to pick "open url" from a menu, but..
13:06:56 <SamB_XP> Baughn: does it let you pick which browser to use ?
13:07:06 <Baughn> SamB_XP: No, just uses the default one
13:07:09 <Baughn> Firefox, that is
13:08:41 <Baughn> @pl zipWith ($)
13:08:42 <lambdabot> zipWith id
13:09:13 <Baughn> @pl \text key = let cycles = text :  zipWith ($) (map (flip ideaRunde) (take 8 subKeys)
13:09:13 <lambdabot> (line 1, column 11):
13:09:13 <lambdabot> unexpected "="
13:09:13 <lambdabot> expecting pattern or "->"
13:09:16 <mattam> Myoma: well anyway, I have proven the monad laws for it now :) ap is vectorized application if that's what you mean.
13:09:24 <Myoma> yess
13:09:38 <Baughn> @pl \text key = let cycles = text :  zipWith ($) (map (flip ideaRunde) (take 8 subKeys)  ++ [(flip ideaFinish) (last subKeys)]) cycles; subKeys = foo key in last cycles
13:09:38 <lambdabot> (line 1, column 11):
13:09:38 <lambdabot> unexpected "="
13:09:38 <lambdabot> expecting pattern or "->"
13:10:22 <mattam> I find it quite bizarre to lose most of the matrix by taking the diagonal. Maybe for some probabilistic computations it makes some sense (taking a sample or so).
13:10:23 <Myoma> hm mattam, will you post the code/proofs anywhere?
13:10:26 <Baughn> @pl \text -> text : zipWith ($) (map (flip ideaRunde) (take 8 subKeys)  ++ [(flip ideaFinish) (last subKeys)])
13:10:26 <lambdabot> (: zipWith id (map (flip ideaRunde) (take 8 subKeys) ++ [flip ideaFinish (last subKeys)]))
13:10:47 <david48> anyone familiar with HSCurses ? I have a problem with getCh
13:10:58 <mattam> Myoma: of course I can.
13:11:23 <dcoutts> BMeph: curl --trace-ascii tracefile url
13:11:47 * BMeph tries out curl on the system...
13:15:42 <wagle> what book has the acronym EGB?
13:15:53 <Botje> "elektronisch groene boekje"
13:15:59 <Zao> Escher Gödel Bach.
13:15:59 <Botje> but then that is probably not very relevant :)
13:16:04 <Zao> Insert correct spelling above.
13:16:16 <wagle> ah yes  thanks\
13:16:28 <bjrn> Isn't it GED: Gdel,Escher,Bach?
13:16:42 <wagle> uh yeah, actuallyu
13:16:54 <bjrn> In either case, it rocks.
13:17:27 <pfo> is there a haskell packet mgmnt system similiar to perl CPAN?
13:17:36 <Botje> hackage?
13:17:42 <Botje> with cabal-install
13:17:42 <wagle> well, i guess i'm still trying to figure out EGB (in same sentence as SICP and TAOCP)
13:18:59 <wagle> oo...  maybe "eternel golden braid"?
13:19:06 <mattam> http://www.lri.fr/~sozeau/research/coq/epigramming.html
13:19:13 <Deewiant> it's GEB: EGB
13:19:17 <lambdabot> Title: epigramming
13:19:36 <quicksilver> http://en.wikipedia.org/wiki/Image:GEBcover.jpg
13:19:48 <mattam> Myoma: here it is, with almost no comments though :)
13:19:51 <quicksilver> ^^ you can see why someone who has access to a copy of the cover might pick either abbreviation :)
13:20:28 <pfo> Botje: cabal-install is like perl's CPAN shell?
13:20:43 <Botje> pretty much
13:21:09 <learningmacros> hofstadter is great
13:21:12 <learningmacros> read!
13:21:20 <learningmacros> is template haskell easy to work with?
13:22:10 <learningmacros> could i add somehing like listcomprehensions with @ comprehension @ instead of using [] ?
13:22:21 <learningmacros> just asking, not that i owuld do exactly that
13:23:03 <quicksilver> I would say TH is not exactly easy ;)
13:23:18 <quicksilver> It's a typed macro system and you need to understand quite a bit about the AST it uses for haskell terms
13:23:40 <quicksilver> "quasiquoting" which will be new in 6.10 may be a better tool for something like a custom list comprehension.
13:24:20 <learningmacros> ast?
13:25:27 <pfo> any hints on why `cabal-install' install fails ? http://hpaste.org/10438
13:25:34 <quicksilver> learningmacros: abstract syntax tree
13:25:52 <Botje> sounds like your shell doesn't know about popd and pushd
13:25:57 <pao> Haskell is `pure` since function output depends only on input parameters.
13:25:57 <pao> Side-effects (depending on or mutating global state) compromises purity.
13:26:01 <pao> is that correct?
13:26:03 <learningmacros> quasiquoting is some leightwieght macrosystem inside haskell?
13:26:04 <Botje> pfo: what shell is that?
13:26:09 <learningmacros> and not in template haskell?
13:26:29 <dcoutts> pfo: grab the updated script that does not use pushd/popd darcs.haskell.org/cabal-install/bootstrap.sh
13:26:31 <Botje> pao: yes. Haskell hides all the side-effect nastiness in the IO monad
13:27:04 <quicksilver> learningmacros: http://haskell.org/haskellwiki/Quasiquotation
13:27:05 <lambdabot> Title: Quasiquotation - HaskellWiki
13:27:09 <pao> Botje:  thanks
13:27:09 <learningmacros> pao: yes but you can have sideeffecrs in haskell, with monads,
13:27:18 <quicksilver> learningmacros: I think quasiquotes are implemented in TH
13:27:22 <quicksilver> or part of them is
13:27:36 <pfo> Botje: bash
13:28:04 <mmorrow> yeah, you have to translate whatever ast you construct from an input string to the template-haskell ast (re: quasiquotes)
13:28:06 <MyCatVerbs> Botje: well. Not so much hides, as locks up. :)
13:28:07 <pao> learningmacros: isn't more correct to say that you can "emulate" side-effects using monads?
13:28:28 <pao> learningmacros: in fact monadic code is as pure as non monadic code...
13:28:31 <mmorrow> you don't actually need to construct an ast though..
13:28:41 <mmorrow> . [$rx|.*|]
13:28:44 <lunabot>      No instance for (Show (String -> Maybe [String]))
13:28:45 <Botje> pfo: weird. you should follow dcoutts' advice, then
13:29:32 <pfo> totally weired. bash supports pushd/popd
13:29:34 <mmorrow> . [$rx|([a-l]+)|] ['a'..'z']
13:29:34 <lunabot>  Just ["abcdefghijkl","abcdefghijkl"]
13:29:38 <MyCatVerbs> pao: you can happily simulate a side-effectful machine using a monad.
13:29:40 <pfo> but the new scripts seems to work just fine. thx.
13:30:15 <mmorrow> . (maybe [] tail . [$rx|([a-l]+)|]) ['a'..'z']
13:30:16 <lunabot>  ["abcdefghijkl"]
13:30:29 <pao> MyCatVerbs: exactly.. that is what I meant... haskell is _always_ pure... even when you write "monadic" "effectful" codew
13:30:41 <pfo> the script just stopped now, missing deps: HTTP >=3000 && <3002, network >=1 && <3
13:30:48 <MyCatVerbs> pao: not quite.
13:30:49 <pfo> the rest worked as expected
13:30:58 <MyCatVerbs> pao: everything except the IO monad. The IO monad is evil.
13:31:09 <quicksilver> MyCatVerbs: the code is still pure, in a sense
13:31:15 <quicksilver> it is a question of perspective.
13:31:17 <MyCatVerbs> pao: for all monads that can be called with runFoo from pure code, yes.
13:31:39 <geezusfreeek> it is still pure in that you are actually just constructing an imperative program, not performing the side-effects yourself
13:31:47 <pfo> and ~/.cabal exists with lib/ and share/ underneath it. also cabal 1.4.0.2 and zlib are installed.
13:31:59 <geezusfreeek> and the RTS is the "runIO" function
13:32:25 <dcoutts> pfo: you'll need network installed first, I guess you've got an extremely minimal ghc install
13:32:26 <Botje> .oO(runIO :: IO a -> IO a)
13:32:27 <lunabot>   Not in scope: `oO'
13:32:27 <lunabot>  <interactive>:1:52: Not in scope: `runIO'
13:32:42 <MyCatVerbs> pao: but since you can have monads that enforce sequencing of operations, you can use that to implement a simulation of side-effectful machine in a side-effectful manner - provided you can guarantee that the side effects internal to that simulation will never be visible to any other piece of code. The ST monad does exactly that - gives you mutable references and arrays, but no externally visible side effects. :)
13:33:28 <david48> anyone familiar with HSCurses ? I have a problem with getCh
13:33:44 <MyCatVerbs> pao: as opposed to simulating a side-effectful machine with pure code, which would be semantically identical but in practice give you slightly worse time and space complexities.
13:33:56 <pao> MyCatVerbs: in fact the problem is that "sideeffect-ful" is ill-defined (not defined at all)... haskell is always pure...
13:33:58 <lispy> http://stackoverflow.com/questions/68504/what-are-my-ideeditor-choices-for-haskell
13:34:05 <lispy> comment people!
13:34:18 <MyCatVerbs> pao: as long as no one can ever _observe_ whether or not you're using unsafeFoo under the hood, s'all good. ^^
13:34:29 <pao> the only trick is the IO monad that fakly represent all Input/Output world
13:34:42 <mmorrow> Botje: ;)
13:34:50 <learningmacros> lispy: emacs ofc
13:34:53 <Botje> :)
13:34:58 <learningmacros> there is no alternative that is even close
13:35:06 <MyCatVerbs> pao: nah, the IO monad isn't that bad. It just implements proper world-passing, but hidden behind the bind and return operators so that you can't mess it up by mistake. ;)
13:35:09 <lispy> learningmacros: ofc?
13:35:27 <geezusfreeek> emacs is the only one i have found that has decent support for haskell at all
13:35:30 <mmorrow> . (text . pprint . cleanNames) $(lift =<< reify ''IO)
13:35:32 <lunabot>  newtype IO a_0 = IO (State# RealWorld ->
13:35:32 <lunabot>                       (#,#) (State# RealWorld) a_0)
13:35:39 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''IO)
13:35:40 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
13:36:11 <bd_> :t reify
13:36:12 <lambdabot> Not in scope: `reify'
13:36:16 <mmorrow> . reify
13:36:17 <lunabot>      No instance for (Show (Name -> Q Info))
13:36:46 <mmorrow> i added instances of List for all the types in the TH ast in order to be able to do that..
13:36:52 <mmorrow> s/
13:36:56 <mmorrow> s/List/Lift/
13:37:33 <pao> I think referring to the IO monadic code as to "inpure code" is strictly uncorrect
13:37:45 <mmorrow> ("that" being lift the Info to an ExpQ which allows it to be spliced in as a non-meta value via $(..)
13:38:34 <mmorrow> . |\x -> x|]
13:38:34 <lunabot>   parse error on input `->'
13:38:38 <mmorrow> . [|\x -> x|]
13:38:39 <lunabot>  LamE [VarP x_0] (VarE x_0)
13:38:51 <mmorrow> . $(lift =<< [|\x -> x|])
13:38:52 <lunabot>  LamE [VarP x_1627399185] (VarE x_1627399185)
13:39:01 <mmorrow> . lift =<< [|\x -> x|]
13:39:01 <lunabot>  AppE (AppE (ConE LamE) (ListE [AppE (ConE VarP) (AppE (AppE (ConE Name) (App...
13:39:09 <mmorrow> . lift =<< lift =<< [|\x -> x|]
13:39:10 <lunabot>  AppE (AppE (ConE AppE) (AppE (AppE (ConE AppE) (AppE (ConE ConE) (AppE (AppE...
13:42:00 <lunabot>      Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
13:43:16 <Myoma> yay
13:43:48 <ElCerdo> how do you a Float with 5 digit without ingineer notation like a "%.5f" in printf style??
13:44:07 <Myoma> ♪ printf "%.5f" pi :: String
13:44:08 <lunabot>   Not in scope: `printf'
13:44:10 <Myoma> > printf "%.5f" pi :: String
13:44:11 <lambdabot>   "3.14159"
13:44:15 <Myoma> >_<
13:45:08 <ElCerdo> Myoma: thanks
13:45:12 <learningmacros> loop n proc = do   acc <- forM [1..n] proc
13:45:20 <learningmacros> he last statement in a 'do' construct must be an expression
13:47:29 <Botje> are you going to do anything with acc?
13:48:09 <Botje> if you're just going to return it, then do so
13:48:23 <Botje> or even shorten it to just loop n proc = forM [1..n] proc
13:48:35 <Botje> or juse loop = replicateM :)
13:50:59 <learningmacros> botje but that doesnt work
13:51:38 <Botje> (\bot needs a "doesn't work" factoid like #perl does)
13:51:43 <Botje> learningmacros: what do you mean by "doesn't work"
13:51:50 <learningmacros> wait
13:51:54 <learningmacros> proc should be func
13:52:03 <learningmacros> so i want to apply func to x
13:52:23 <Botje> which x ?
13:52:25 * Botje sees no x
13:52:37 <learningmacros> loop n proc = do,acc <- forM [1..n] \x -> do,proc x, return acc
13:53:38 <Botje> can you put that on hpaste?
13:53:46 <Botje> indentation matters in cases like this
13:55:35 <learningmacros> http://hpaste.org/10440
14:02:53 <Myoma> mattam, Equations looks great! Is it in trunk or somewhere, (I want to try to run through this script if possible)
14:03:23 <learningmacros> botje?
14:03:35 <Botje> sorry, back :)
14:03:52 <Botje> learningmacros: why are you doing return (proc x) ?
14:04:22 <Botje> that means acc has type m [m a]
14:04:25 <geezusfreeek> learningmacros: your code is equivalent to: loop n = forM [1..n]
14:05:04 <geezusfreeek> i will annotate your paste with simplification steps
14:05:26 <mperillo> I have executed interact (map toUpper) from ghci
14:05:34 <Botje> bad move :)
14:05:37 <opqdonut> :)
14:05:44 <Botje> hit ctrl-d or ctrl-z (if you're in windoze)
14:05:47 <newsham> ?type seq =<< (undefined :: IO [IO a])
14:05:48 <lambdabot>     Couldn't match expected type `b -> a'
14:05:48 <lambdabot>            against inferred type `IO [IO a1]'
14:05:48 <lambdabot>     In the second argument of `(=<<)', namely
14:05:59 <mperillo> Botje, that was my question
14:06:08 <mperillo> ctrl-d does not works!
14:06:13 <newsham> ?type join (undefined :: IO [IO a])
14:06:14 <Botje> might have to hit it twice
14:06:15 <lambdabot>     Couldn't match expected type `IO' against inferred type `[]'
14:06:15 <lambdabot>       Expected type: IO (IO a)
14:06:15 <lambdabot>       Inferred type: IO [IO a1]
14:06:18 <Botje> or use ctrl-c
14:06:22 <Twey> `loop = forM . enumFromTo 1` >.>
14:06:24 <Botje> i've done something similar
14:06:38 <Myoma> enumFromTo is such a ugly name
14:06:46 <newsham> ?type liftM sequence (undefined :: IO [IO a])
14:06:48 <lambdabot> forall a. IO (IO [a])
14:06:57 <newsham> ?type join $ liftM sequence (undefined :: IO [IO a])
14:06:58 <lambdabot> forall a. IO [a]
14:07:00 <Botje> mperillo: heh. indeed. you'll have to use ctrl-c
14:07:00 <Myoma> we should call it iota or ι
14:07:00 <Twey> Myoma: What would you call it?
14:07:05 <mattam> Myoma: it's in the trunk but some of the changes I've not commited yet.
14:07:06 <Twey> Heh
14:07:12 <mperillo> Botje, right, but this is strange
14:07:36 <Myoma> ♪ let ι n = [1..n] in zipWith (+) (ι 3) (drop 3 . ι 6)
14:07:37 <lunabot>      Couldn't match expected type `a -> [a1]'
14:07:43 <david48> anyone familiar with HSCurses ? I have a problem with getCh
14:07:57 <Myoma> ♪ let ι n = [1..n] in zipWith (+) (ι 3) (drop 3 . ι $ 6)
14:07:58 <lunabot>  [5,7,9]
14:08:04 <bjrn> Myoma: Is that a note character, or is my charset acting up?
14:09:43 <dancor> anyone get http://code.haskell.org/http to build with 6.9?  i get: Network/StreamSocket.hs:40:31:Class `Exception' used as a type
14:09:44 <lambdabot> Title: Index of /http
14:09:47 <newsham> ♪ let ι = (:[]) in ι 3
14:09:48 <lunabot>  [3]
14:10:10 <mrd> i see a note too
14:10:14 <mrd> musical haskell?
14:10:40 <newsham> > S.singleton 3
14:10:42 <lambdabot>   mueval: Prelude.read: no parse
14:10:49 * BMeph_ also sees the note. Looks like an eighth-note.
14:10:52 <newsham> > Data.Set.singleton 3
14:10:53 <lambdabot>   mueval: Prelude.read: no parse
14:11:05 <dancor> i guess namespacing of imports is different in 6.9.
14:11:20 <newsham> ♪ Data.Set.singleton 3
14:11:21 <lunabot>   Not in scope: `Data.Set.singleton'
14:12:43 <newsham> > S.singleton
14:12:44 <lambdabot>       Overlapping instances for Show (a -> S.Set a)
14:12:44 <lambdabot>        arising from a use...
14:12:47 <newsham> > S.singleton 3
14:12:48 <lambdabot>   mueval: Prelude.read: no parse
14:12:51 <newsham> why?
14:15:33 <newsham> does Data.Set form a monad similar to Data.List?
14:15:47 <newsham> is there some TH magic for set comprehensions?
14:15:55 <plutonas> how do you do debugging in haskell? I'm fighting with a function for the whole day, it would be great if i could print debugging messages at runtime
14:16:17 <newsham> pluto: you can use Debug.Trace.trace for some printing
14:16:31 <newsham> ?type trace
14:16:33 <lambdabot> Not in scope: `trace'
14:16:38 <newsham> ?type Debug.Trace.trace
14:16:39 <lambdabot> forall a. String -> a -> a
14:17:27 <newsham> keep in mind that it will trace when it is eval'd, which can be at weird times or never, due to non-strict eval
14:17:50 <newsham> you could also write small tests for pieces of your function
14:17:54 <newsham> to make sure they do what you want them to do
14:17:56 <plutonas> how do i run it?
14:18:10 <RayNbow> newsham: you want Set to be a monad?
14:18:12 <plutonas> newsham: all the functions seem to work perfectly
14:18:21 <newsham> fact 0 = 1; fact n = trace (show n) (n * fact (n - 1))
14:18:21 <plutonas> when i run the whole thing i have trouble though
14:18:40 <newsham> raynbow: just wondering if it forms a monad similar to the list monad.
14:18:45 <dancor> newsham: you'd think there'd be an easy way to hoogle/something for monad instances
14:18:46 <mmorrow> i got the haskell quasiquoter hooked in
14:18:54 <mmorrow> . fmap pp $ (\[$hs|LamE (x:y:zs) e|] -> LamE [x] (LamE [y] (LamE zs e))) `fmap` [|\x y z -> fmap id [0..]|]
14:18:56 <lunabot>  \x_0 -> \y_1 -> \z_2 -> fmap id [0..]
14:19:01 <dancor> newsham: i don't see anything in Data.Set and the List one is in Prelude
14:19:02 <RayNbow> newsham: the only problem is that Set only works for Ord types
14:19:04 <newsham> ie:  do { x <- set; y <- set2; return (x+y) }   for   { x+y | x in xs y in ys }
14:19:05 <RayNbow> newsham, http://hsenag.livejournal.com/11803.html
14:19:06 <lambdabot> Title: hsenag: Restricted monads in Haskell
14:19:34 <newsham> ?instances-importing Data.Set Monad
14:19:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:19:53 <mmorrow> . fmap pp $ (\[$hs|LamE x (LamE y (LamE z e))|] -> LamE [x,y,z] e) `fmap` [|\x -> \y ->  \z -> fmap id [0..]|]
14:19:55 <lunabot>      Couldn't match expected type `Pat' against inferred type `[Pat]'
14:20:06 <mmorrow> . fmap pp $ (\[$hs|LamE x (LamE y (LamE z e))|] -> LamE (concat[x,y,z]) e) `fmap` [|\x -> \y ->  \z -> fmap id [0..]|]
14:20:08 <lunabot>  \x_0 y_1 z_2 -> fmap id [0..]
14:20:09 <newsham> pluto: does my example make sense?
14:20:21 <mmorrow> pattern quotes FTW
14:20:38 <RayNbow> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros <-- more about trying to make Set a monad
14:20:39 <plutonas> newsham: just a sec
14:20:42 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
14:20:51 <mmorrow> err, actually that's not as good as it could be
14:21:04 <mmorrow> needs one more level of quoting in the patterns...
14:21:21 <RayNbow> :t (>>=)
14:21:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:21:56 <Myoma> ♪ pp [| \x -> x |]
14:21:57 <lunabot>      No instances for (Ppr ExpQ, Data ExpQ)
14:22:02 <mmorrow> . pp
14:22:03 <lunabot>      No instance for (Show (a -> Doc))
14:22:05 <Myoma> ♪ pp [#hs| \x -> x |]
14:22:05 <lunabot>   parse error on input `|]'
14:22:07 <Myoma> ♪ pp [$hs| \x -> x |]
14:22:08 <lunabot>      No instance for (Ppr (t -> t))
14:22:10 <newsham> raynbow: danke
14:22:15 <mmorrow> . [$hs|\x -> x|] 42
14:22:16 <lunabot>  42
14:22:27 <Myoma> ♪ pp [| [$hs| \x -> x |] |]
14:22:29 <lunabot>      No instances for (Ppr ExpQ, Data ExpQ)
14:22:47 <RayNbow> newsham: you're welcome :)
14:22:48 <learningmacros> however (Num (m b), Enum (m b))
14:22:51 <mmorrow> . pp `fmap` [| [$hs|\x -> x|] |]
14:22:52 <lunabot>  \x_0 -> x_0
14:23:00 <learningmacros> No instances for (Num (m b), Enum (m b))
14:23:00 <learningmacros>       arising from a use of `loop' at <interactive>:1:0-20
14:23:13 <RayNbow> newsham: actually, I once asked a very similar question in #haskell a few months ago :)
14:23:33 <newsham> i wasnt left folding at the time
14:24:31 <newsham> (flip dressUp stussy . seduce . reduce) me
14:27:11 <plutonas> newsham: do you have a link describing data.trace?
14:27:28 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html
14:27:31 <lambdabot> Title: Debug.Trace, http://tinyurl.com/y4usfz
14:27:49 <newsham> > Debug.Trace.trace "test" 3
14:27:50 <lambdabot>   mueval: Prelude.read: no parse
14:29:45 <Myoma> oh http://code.google.com/p/tapl-haskell/
14:29:46 <lambdabot> Title: tapl-haskell - Google Code
14:30:05 <Myoma> they aren't doing ATTAPL?
14:30:06 <plutonas> wouldn't putting trace calls in functions change their type?
14:30:08 <Myoma> that's a shame
14:30:25 <newsham> pluto: http://codepad.org/ieVfuerH
14:30:40 <newsham> ?type Debug.Trace.trace
14:30:41 <lambdabot> forall a. String -> a -> a
14:30:47 <newsham> the return value is the same as the 2nd arg
14:30:58 <stulli> Is there any state monad tutorial without using 'Random' or defining a custom monad? I just want to learn how to pass state, that cant be too difficult, can it?
14:31:23 <plutonas> newsham: i see, thanks will try out
14:31:31 <newsham> > runState (do { x <- get; return (x+2) }) 100
14:31:32 <lambdabot>   (102,100)
14:31:53 <newsham> > runState (return 3) 100
14:31:54 <lambdabot>   (3,100)
14:31:58 <newsham> > runState get 100
14:32:00 <lambdabot>   (100,100)
14:32:05 <dolio> Tutorial over!
14:32:06 <newsham> > runState (put 5) 100
14:32:07 <lambdabot>   ((),5)
14:32:09 <dolio> :)
14:32:16 <newsham> thats the gist of it
14:32:42 <stulli> newsham: hm, it seems my thoughts were too complicated
14:32:55 <stulli> ill hpaste with what i did
14:33:14 <stulli> http://hpaste.org/10442
14:34:04 <newsham> btw, you can "gets one"
14:34:07 <newsham> ?type gets
14:34:08 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
14:34:19 <newsham> ?src gets
14:34:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:34:31 <newsham> getTestOne = gets one
14:34:53 <stulli> ah, thanks
14:35:20 <newsham> putTestOne a = modify (\s -> s { one= a })
14:35:44 <newsham> modify f = do { s <- get; put (f s) }
14:36:28 <newsham> your runTest could be written more simply as a state program.
14:36:48 <newsham> runTest = do { val1 <- putTestOne 5;  val2 <- putTestTwo 10; ... }
14:37:04 <newsham> then main = print $ runState runTest <initial>
14:37:21 <newsham> the do-notation/state-monad will take care of chaining your newstates for you
14:37:28 <newsham> make sense?
14:37:30 <stulli> Aaaah, thats waht i have been looking for! Thanks a lot
14:38:26 <stulli> I wondered how to get rid off those newState' and newState'', because thats what i think would do the state monad for me
14:39:43 <stulli> The example in RWH was quite confusing for a newbie like me
14:40:36 <newsham> stulli: http://codepad.org/6IhkCxcA
14:40:41 <newsham> for example
14:41:23 <newsham> you can also use evalState or execState if you only want the fst or snd (ie. state or return value) fromthe computatin
14:42:00 <newsham> > evalState (gets (+2)) 100
14:42:01 <lambdabot>   102
14:42:04 <stulli> Yeah, read about execState and evalState.
14:42:05 <newsham> > execState (gets (+2)) 100
14:42:07 <lambdabot>   100
14:42:24 <stulli> But i didnt know how to put it all together...
14:42:36 <BMeph_> bos: Take notes, the revision material is already coming in... ;)
14:43:20 <newsham> i'm sure rwh is perfectly fine, just not personalized for each individual
14:44:06 <Myoma> ♪ exp pi - pi
14:44:07 <lunabot>  19.999099979189474
14:44:22 <bos> heh
14:44:39 <paggas> hello, i have a question, if i want to compile a source file into a relocatable with GHC, do i have to declare a module inside the file? and does the filename have to be the same as the module (e.g. module Foo where ..... , filename: Foo.hs)?
14:46:49 <stulli> newsham: yes, im sure i will understand this part of rwh now that i know the basics
14:47:51 <FunctorSalad> halp I've been running in circles with this for hours :( so I have some harmless data types, say data C... I want to define a structure whos values are either values from C, or *definitions* that ultimately expand to values of C
14:48:38 <FunctorSalad> the definitions can take parameters from C or say, String
14:49:00 <newsham> stulli: experimentation is a great way to understand this stuff
14:49:07 <newsham> in ghci or with lambdabot or codepad
14:49:12 <FunctorSalad> the definitions can also produce values that contain *other* definitions, and those should *not* be popped unless they're told to do so
14:50:20 <FunctorSalad> and the parameters can also be values from the "term that ultimately expands to C" type
14:50:28 <newsham> data Complex = Plain C | Formula C C C ;   ?
14:50:37 <paggas> hello, i have a question, if i want to compile a source file into a relocatable with GHC, do i have to declare a module inside the file? and does the filename have to be the same as the module (e.g. module Foo where ..... , filename: Foo.hs)? [sorry for the double posting, seems my connection is a little instable...]
14:50:53 <plutonas> newsham: how do i trace maybe values? i get an error trying this
14:51:15 <newsham> ?type Debug.Trace.trace
14:51:16 <lambdabot> forall a. String -> a -> a
14:51:24 <newsham> are you passing in a string and a value?
14:51:45 <plutonas> hm, no, just a maybe value i'd like t ohave printed
14:51:51 <plutonas> actually i use traceVal from your example
14:52:09 <plutonas> so like traceVal (Just "something")
14:52:11 <newsham> ?type \x -> Debug.trace.trace (show x) x
14:52:12 <lambdabot> Couldn't find qualified module.
14:52:17 <newsham> ?type \x -> Debug.Trace.trace (show x) x
14:52:19 <lambdabot> forall a. (Show a) => a -> a
14:52:27 <newsham> so that function will take any value, as long as its a Show
14:52:42 <newsham> your Maybe value is probably not an instance of Show
14:52:59 <newsham> Maybe a will be showable if 'a' is showable.
14:53:10 <newsham> so make sure you derive or instance Show for your subtype
14:53:22 <plutonas> hm, yes there's no show defined
14:53:35 <newsham> ie:  data Foo = This | That deriving Show
14:54:31 <Jaak> > 1 + 1 `mod` 2
14:54:32 <lambdabot>   2
14:54:55 <FunctorSalad> newsham: hmm... it should be easy to add new definitions in other modules, so I can't just put them all into one algebraic datatype as I think you suggested
14:55:33 <plutonas> newsham: can the problem be that the function that shoud deliver the value to trace is in another file
14:55:39 <plutonas> where Debug.Trace is not imported?
14:55:47 <plutonas> because i don't define any data, just some types
14:56:00 <FunctorSalad> I've redesigned this thing like 10 times and always run into problems (at least if I want to keep it type-safe and not cheat with dynamics or something)
14:56:18 <newsham> pluto: that shouldnt matter.  also your compiler should give you an error that tells you what the problem is
14:56:26 <newsham> but without more info i can only guess
14:56:54 <Saizan> FunctorSalad: seen Data Types a la Carte?
14:57:12 <FunctorSalad> Saizan: hmm, no?
14:57:30 <plutonas>     No instance for (Show ([[Char]] -> Maybe [[Char]]))
14:57:30 <plutonas>       arising from a use of `traceVal' at Chatterbot.hs:49:29-82
14:57:47 <newsham> functor: hmm.. you want to have a data type but not have it fully defined?
14:57:49 <newsham> i'm onfused
14:58:03 <newsham> pluto: its trying to show a function, and there's no good way for showing functions
14:58:20 <plutonas> hm
14:58:23 <plutonas> i see
14:58:24 <newsham> you probably forgot to apply an argument to a function
14:58:34 <plutonas> no it's curried :)
14:58:41 <Saizan> FunctorSalad: http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
14:58:43 <lambdabot> Title: cache:http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf - Google  ...
14:58:46 <newsham> sure, but its still one short of being a Maybe [String]
14:58:49 <newsham> which is prob what you expected
14:58:56 <Saizan> FunctorSalad: i think it might suit your needs
14:59:02 <plutonas> the problem is that when i call this function the argument gets curried further
14:59:12 <newsham> you could add type annotations to let the type checker help you track down where you went astray
14:59:52 <newsham> do you mean you forgot to put parenthesis in the right place?
15:00:04 <plutonas> newsham: you mean me?
15:00:08 <newsham> yes
15:00:13 <newsham> [11:56] < plutonas> the problem is that when i call this function the argument gets curried further
15:00:22 <newsham> the compiler is just doing what it is directed to do
15:00:22 <plutonas> no no, it's intented to be like this, but it's hard to debug i think
15:00:31 <plutonas> i don't do paren mistakes, am coming from lisp :P
15:00:51 <newsham> ?remember plutonas i don't do paren mistakes, am coming from lisp :P
15:00:51 <lambdabot> Done.
15:01:06 <plutonas> lol
15:01:07 <newsham> thats a keeper
15:01:17 <plutonas> lol, ok
15:02:32 <newsham> pluto: if you expect to get a Maybe [String] and you're getting a [[String]] -> Maybe [String]    then somewhere you need to apply an extra argument
15:03:10 <newsham> if its not obvious where, i would recommend adding more type annotations to your program so the type checker can tellyou where
15:03:58 <roconnor> ah coq is pretty good at catching divide by 0 errors statically
15:04:10 <plutonas> newsham: i know i need an extra argument, the problem is i want to keep it curried but also debug it
15:04:13 <roconnor> positive expected but received nat.
15:04:30 <plutonas> newsham: the thing is i have to do Eliza as homework
15:04:46 <plutonas> all the functions work fine, but the bot doesn't match all the phrases only some
15:05:04 <plutonas> so that's what i'm trying to figure out
15:05:47 <newsham> are you familiar with quickcheck?  perhaps there are some properties you can write to help test the functions to see why
15:05:48 <plutonas> the thing is that i have a function that uses another function and returns one that given the question gives an answer, the answer is wrong (the default one) but i need to figure out where the mistake happens
15:05:58 <plutonas> quickcheck?
15:06:28 <newsham> ?check \x -> (x :: String) == reverse (reverse x)
15:06:29 <lambdabot>   "OK, passed 500 tests."
15:06:42 <newsham> you write properties like that, and it can auto-generate test cases and test them
15:06:59 <plutonas> hm, i don't think this would help
15:07:07 <plutonas> i know which cases it passes and which not
15:07:11 <newsham> ie:  propRevRev :: String -> Property  ; propRevRev xs = reverse (reverse xs) == xs
15:07:28 <plutonas> i don't know where the mistake exactly is as the between functions are fine, probably in the "connections" i do something wrong
15:07:59 <Myoma> wait you wrote a program in haskell and it's buggy?
15:08:27 <mmorrow> FunctorSalad: do you mean at runtime or compile time? if at runtime, maybe something like  data C = ... | ... | ToC (forall a. (a, a -> C)) ?
15:08:28 <newsham> also you can step the program in ghci, but i'm not too familiar with how that works
15:09:01 <plutonas> Myoma: yes
15:09:02 <newsham> pluto: so split up your function where the connection happens, and make smaller test cases or traces or properties or step through it
15:09:19 <plutonas> newsham: the thing is that there are 2 connections
15:09:24 <plutonas> and both return functions
15:09:49 <newsham> i dont understand why thats a problem
15:09:59 <mmorrow> i'm not sure if that should instead be (forall a. ToC (a, a -> C)) , or if either of those is what you're looking for...
15:10:08 <plutonas> newsham: i can't check the connections
15:10:18 <mmorrow> (@FunctorSalad)
15:10:30 <plutonas> giving the arguments to the intermediate functions works, to the final one gives the wrong result
15:10:36 <FunctorSalad> mmorrow: hmm, at compile time but in other modules (but maybe even at runtime)... I tried the ToC approach but ran into some problem with it
15:11:08 <mmorrow> FunctorSalad: ahh, that shouldn't be hard at compile time... hmm
15:11:32 <newsham> *shrug* dont know what more to tell you without more info
15:12:42 <mmorrow> so you have some data C a = A a | B a | C (C a), and you want to have some meta-level datatype values of which represent expressions of type C a for some a?
15:12:45 <mmorrow> (@FunctorSalad)
15:13:14 <FunctorSalad> mmorrow: yeah, though C doesn't even have parameters
15:14:20 <FunctorSalad> mmorrow: maybe the "problem" with the ToC was just that I was too lazy to manually derive Show and so on for C (because a non-haskell98 constructor breaks "deriving")
15:14:22 <svat> What would be a good way to write the following? The set of all natural numbers which have 1s in only even bit positions (i.e. numbers that can be written as sums of powers of 4). I've tried "ns = 0 : concat [[4^x+y | x<-[0..]] | y<-ns]" and "ns = 0 : concat [[4^x+y | y<-ns] | x<-[0..]]", but both are clearly wrong...
15:14:56 <mmorrow> FunctorSalad: i hate manually deriving show! check out the derive pkg on hackage
15:15:17 <mmorrow> just throw whatever data decls you want whatever derived for in a scratch file, then
15:15:25 <mmorrow> $ derive -dShow Asdf.hs
15:15:36 <FunctorSalad> mmorrow: nice :)
15:16:07 <Myoma> svat: filter (all (== 1) . even . bits)
15:16:19 <Myoma> svat: but you have to implement bits and even
15:16:25 <Myoma> oh
15:16:26 <newsham> > even 2
15:16:27 <lambdabot>   True
15:16:34 <FunctorSalad> mmorrow: let me check whether there wasn't some more seriouss problem wiith the ToC...
15:16:36 <mmorrow> and it'll dump derive instance to stdout. the nice thing is that it doesn't check that types in datas /actually/ have instances of show defined for them. so you can get it to spit out the manual labor for you, then make one strategic change ;)
15:16:43 <Myoma> filter (all (== 0) . odd . bits)
15:16:51 <FunctorSalad> hehe
15:17:07 <newsham> convert each natural to bits, and then convert those back to naturals as if they were base 4 digits
15:17:41 <ddarius> Yeah, the simplest thing is probably to count up and simply filter out the ones that have a bit set in any odd position.
15:17:54 <mmorrow> FunctorSalad: hstidy is very nice for making the derive output somewhat prettier
15:18:02 <svat> newsham: heh, that's a nice trick
15:18:42 <newsham> just map (toBase4 . fromBase2) [0..]
15:26:04 <svat> yes, that works. But the kind of computation I was thinking of: S={0,1}; S=SU(4+S)={0,1,4,5}; S=SU(16+S)={0,1,4,5,16,17,20,21} ... etc -- what would be a way of doing something like that in general?
15:27:00 <Botje> Data.Set + fmap ?
15:27:17 <Botje> ah
15:27:22 <Botje> it's not a functor
15:27:23 <Botje> bugger :)
15:28:16 <Botje> > let s = Data.Set.fromList [0,1] in s `Data.Set.union` (Data.Set.map (+4) s)
15:28:17 <lambdabot>   mueval: Prelude.read: no parse
15:28:30 <dolio> It's not a Functor.
15:28:39 <dolio> It's a functor. :)
15:28:49 <opqdonut> :D
15:29:13 <Botje> svat: anyway, pasting that into ghci gives me fromList [0,1,4,5]
15:29:14 <Myoma> svat: let s = [0,1]
15:29:26 <newsham> http://codepad.org/nrb5MM0A
15:29:40 <Myoma> svat:  in s `merge` map (4+) s `merge` map (16+) s `merge` ...
15:29:52 <Myoma> svat:  and you can use recursion when you get bored writing out each case
15:30:15 <Myoma> although I actually did it wrong
15:30:24 <Myoma> but that's your fault for using '=' as assignment :P
15:30:33 <newsham> > let upd n = [n*4, n*4+1] in [0] >>= upd
15:30:35 <lambdabot>   [0,1]
15:30:37 <newsham> > let upd n = [n*4, n*4+1] in [0] >>= upd >>= upd
15:30:39 <lambdabot>   [0,1,4,5]
15:30:42 <newsham> > let upd n = [n*4, n*4+1] in [0] >>= upd >>= upd >>= upd
15:30:43 <lambdabot>   [0,1,4,5,16,17,20,21]
15:31:42 <BMeph_> > liftM2(+)[0,1] . map (*4) $ [0,1]
15:31:44 <lambdabot>   [0,4,1,5]
15:32:01 <BMeph_> > liftM2(+)[0,1] . map (*4) . map (*4) $ [0,1]
15:32:03 <lambdabot>   [0,16,1,17]
15:32:14 <newsham> > let upd n = [n*4, n*4+1] in [0] >>= replicateM 5 upd
15:32:15 <lambdabot>   [[0,1],[0,1],[0,1],[0,1],[0,1]]
15:32:16 <BMeph_> Almost...
15:32:19 <newsham> oopz
15:32:51 <BMeph_> > liftM2(+)[0,1] . map (*4) .liftM2(+)[0,1] . map (*4) $ [0,1]
15:32:52 <lambdabot>   [0,16,4,20,1,17,5,21]
15:32:57 <Myoma> > let upd = [n*4, n*4+1] in fix (>>= upd) [0]
15:32:58 <lambdabot>   Couldn't match expected type `a -> m b'
15:33:01 <Myoma> :/
15:33:09 <FunctorSalad> mmorrow: hmm, looks good so far... what was I thinking... adding the deriving clauses is way less of a problem than all the other messes I tried
15:33:14 <shepheb> I can't build hugs from darcs or the release. (I want to try it on my Nokia N810)
15:33:17 <Myoma> > let upd n = [n*4, n*4+1] in fix (>>= upd) [0]
15:33:18 <lambdabot>   Couldn't match expected type `(->) [t]' against inferred type `[]'
15:33:22 <mmorrow> FunctorSalad: :)
15:33:45 <BMeph_> > let upd = liftM2(+)[0,1] . map (*4)  in fix (upd.) [0]
15:33:45 <Myoma> > let upd n = [n*4, n*4+1] in f(>>= upd) [0]
15:33:47 <lambdabot>       Overlapping instances for Show ([a] -> [a])
15:33:47 <lambdabot>        arising from a use o...
15:33:47 <lambdabot>  Terminated
15:34:19 <opqdonut> Overlapping instances for Show arising from a use of Terminated
15:34:20 <newsham> > let upd n = [n*4, n*4+1] in iterate (>>= upd) [0]
15:34:22 <lambdabot>   [[0],[0,1],[0,1,4,5],[0,1,4,5,16,17,20,21],[0,1,4,5,16,17,20,21,64,65,68,69...
15:34:22 <opqdonut> indeed
15:37:46 <shepheb> anyone out there managed to build Hugs recently? I get a build error when building from darcs, and it fails to load the Prelude when I build it from the release source.
15:41:06 <Cale> shepheb: How are the binaries?
15:41:55 <shepheb> I have a working binary I grabbed from Arch
15:43:16 <shepheb> but that won't help when I'm cross-compiling for the Nokia; I won't have a binary available
15:43:47 <shepheb> it builds fine from the release source, both native and cross-compiled, but when run -- native, in scratchbox and on the device -- it fails to load the Prelude.
15:44:56 <shepheb> after grabbing the binary, the darcs build is progressing; we'll see if it has the same problem locating the Prelude.
15:46:08 <BMeph_> > let upd = ap[id,succ].ap[*4] in iterate upd [0]
15:46:09 <lambdabot>   [[0],[0,1],[0,4,1,5],[0,16,4,20,1,17,5,21],[0,64,16,80,4,68,20,84,1,65,17,8...
15:46:17 <BMeph_> @bs
15:46:17 <lambdabot>  Done.
15:46:23 <BMeph_> @bots
15:46:23 <lambdabot> :)
15:46:46 <lunabot>  :)
15:46:53 <mmorrow> ;)
15:47:00 <ddarius> BMeph_: So last upd?
15:47:20 <BMeph_> ddarius: ...sure! ;)
15:47:37 <Myoma> > let upd = ap[id,succ].ap[*4] in fix upd [0]
15:47:39 <lambdabot>   Couldn't match expected type `[t1] -> t'
15:47:39 <mmorrow> @type ap[id,succ].ap[*4]
15:47:40 <lambdabot> forall a. (Num a, Enum a) => [a] -> [a]
15:48:03 <newsham> > let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x)); fromBase n = unfoldUntil (==0) (\x -> (x `mod` n, x `div` n)); toBase n = foldr (\d x -> x*n + d) 0 in map (toBase 4 . fromBase 2) [0..]
15:48:05 <lambdabot>   [0,1,4,5,16,17,20,21,64,65,68,69,80,81,84,85,256,257,260,261,272,273,276,27...
15:48:25 <Myoma> > let upd n = [n*4, n*4+1] = fix (\x -> x ++ (x >>= upd))
15:48:26 <lambdabot>   mueval: Prelude.read: no parse
15:48:28 <Myoma> > let upd n = [n*4, n*4+1] = fix (\x -> x ++ (x >>= upd)) [1]
15:48:29 <lambdabot>   mueval: Prelude.read: no parse
15:48:29 <ddarius> How is that parsing?
15:48:36 <BMeph_> Maybe even shave off two chars by using +1 for succ... ;)
15:49:44 <Myoma> @ceal
15:49:44 <lambdabot> how do i search for someone saying 'Keal' in mirc
15:49:57 <newsham> > let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x)); fromBase n = unfoldUntil (==0) (\x -> (x `mod` n, x `div` n)); toBase n = foldr (\d x -> x*n + d) 0 in map (toBase 11 . fromBase 3) [0..]
15:49:57 <Myoma> @real
15:49:58 <lambdabot> Maybe you meant: keal read
15:49:58 <lambdabot>   [0,1,2,11,12,13,22,23,24,121,122,123,132,133,134,143,144,145,242,243,244,25...
15:50:05 <Myoma> @Keal
15:50:05 <lambdabot> i show how spell triangle in less than three corners using darkmanifold
15:50:22 <BMeph_> > let upd = sp[id,+1].ap[*4] in iterate upd [0]
15:50:23 <lambdabot>   mueval: Prelude.read: no parse
15:50:31 <ddarius> :t [*4]
15:50:32 <lambdabot> forall a. (Num a) => [a -> a]
15:50:38 <ddarius> 'the fuck?
15:50:39 <Myoma> :t sp
15:50:40 <lambdabot> Not in scope: `sp'
15:50:42 * BMeph_ weeps for the lobotobot...
15:51:03 <ziman> lobotomobot :)
15:51:06 <BMeph_> > let upd = ap[id,+1].ap[*4] in iterate upd [0]
15:51:07 <lambdabot>   [[0],[0,1],[0,4,1,5],[0,16,4,20,1,17,5,21],[0,64,16,80,4,68,20,84,1,65,17,8...
15:51:12 <Myoma> :t [1+1+1+]
15:51:13 <lambdabot> parse error on input `]'
15:51:17 <Myoma> :t [1+]
15:51:18 <lambdabot> parse error on input `]'
15:51:22 <Myoma> :t [+1]
15:51:23 <lambdabot> forall a. (Num a) => [a -> a]
15:51:25 <Myoma> :t [+1+1+1]
15:51:27 <lambdabot>     The operator `+' [infixl 6] of a section
15:51:27 <lambdabot>         must have lower precedence than the operand `(+)' [infixl 6]
15:51:27 <lambdabot>         in the section: `(+ 1 + 1 + 1)'
15:51:30 <Myoma> very oddd
15:51:32 <svat> :t (1+)
15:51:34 <lambdabot> forall t. (Num t) => t -> t
15:52:03 <BMeph_> Myoma: What's odd? (besides 1+1+1, heh-heh)
15:52:41 <dolio> The fact that GHC treate [+1] as a section is odd, since it isn't by H98, I believe.
15:52:48 <dolio> But that's been noted before.
15:54:50 <svat> dolio: It is reading [+1] as [(+1)], and it does that for all operators except unary minus which is special-cased. (I think.)
15:55:37 <dolio> Sure. But that's incorrect.
15:55:44 <dolio> > (+1, *2)
15:55:45 <lambdabot>       Overlapping instances for Show (a1 -> a1)
15:55:45 <lambdabot>        arising from a use of ...
15:55:51 <dolio> :t (+1, *2)
15:55:53 <lambdabot> forall a a1. (Num a1, Num a) => (a -> a, a1 -> a1)
15:55:57 <dolio> Also not correct.
15:56:22 <svat> why not correct?
15:56:24 <svat> :t [+1, *2]
15:56:26 <lambdabot> forall a. (Num a) => [a -> a]
15:56:37 <ddarius> Sections require parens.
15:56:57 <svat> oh ok
15:57:04 <dolio> Because the Haskell standard doesn't define that syntax as correct. :)
15:57:26 <dolio> :t (1+, 2*)
15:57:28 <lambdabot> parse error on input `,'
15:57:45 <shepheb> okay, my darcs build of hugs worked after I had the binary installed.
15:57:47 <dolio> It doesn't seem to be very consistent, either.
15:57:50 <shepheb> but that doesn't help me port it
15:58:17 <dolio> Since only sections of the second parameter work.
15:58:49 <dolio> Or first parameter. Depending on how you want to say things.
16:00:02 <mmorrow> i agree that it's incorrect syntax, but apparently 6.9
16:00:04 <mmorrow> 's
16:00:08 <mmorrow> parser accepts it
16:00:15 <mmorrow> .  (1+, 2*)
16:00:16 <lunabot>      A section must be enclosed in parentheses thus: (1 +)
16:00:18 <mmorrow> oops
16:00:26 <dolio> Well, it's only recently been noticed, to my knowledge.
16:00:35 <mmorrow> 6.9.20080504 ghci
16:01:01 <mmorrow> i've never seen that before. lunabot is running HEAD, so i guess someone corrected it
16:01:07 <dolio> I don't know how complex GHC's parser is, but it might be non-trivial to just dig in and fix it.
16:01:21 <mmorrow> i'd bet money on that
16:01:43 <dolio> :)
16:01:53 <jeffwheeler> With something like (+1), it seems to fill in the second argument, and skip over the first for that time. Is it possible to do this with non-binary functions, so I can "curry" the third argument, or something, of an arbitrary function?
16:02:40 <mmorrow> i tried messing with various haskell parsers, only to be crushed violently
16:03:02 <dolio> No. Haskell operators are all binary, more or less.
16:03:37 <jeffwheeler> So that weird backwards currying only works with operators?
16:03:49 <jeffwheeler> What's that called?
16:03:55 <dolio> Sectioning.
16:05:16 <dolio> If you had an Agda-like syntax, you might be able to have sectioning for more complex operators, like "if_then m else_" or something. Although they currently don't.
16:05:58 <dolio> But then, I don't see any obvious syntax for turning an arbitrary function into an N-parameter operator.
16:06:49 <jeffwheeler> That's true; I don't know how it would work syntactically, it just seems strange that one specific thing ("sectioning") let's you do it, while it seems rather strange outside of that. I guess your answer makes sense, though.
16:06:49 <Myoma> jeffwheeler: weird backwards _partial application_
16:07:01 <jeffwheeler> Myoma: what's the difference?
16:07:42 <dolio> Strictly speaking, currying is an operation of type ((a,b) -> c) -> (a -> b -> c)
16:08:38 <jeffwheeler> Hmm, okay; I'd always used them essentially interchangeably in the past.
16:08:40 <dolio> Whereas partial application is like ((a,b) -> c) -> a -> (b -> c) :)
16:08:43 <mmorrow> :t uncurry id
16:08:44 <lambdabot> forall b c. (b -> c, b) -> c
16:09:04 <mmorrow> :t flip . uncurry . flip $ id
16:09:05 <lambdabot> forall b c b1. b -> (b1, b1 -> b -> c) -> c
16:09:11 <mmorrow> :t curry . flip . uncurry . flip $ id
16:09:13 <lambdabot> forall a b c b1. a -> b -> (b1, b1 -> (a, b) -> c) -> c
16:09:41 <mmorrow> err, i'm sure somehow you can walk the arg down
16:09:51 <Myoma> curring is turning A×B×C...×X -> Z into A -> B -> C -> ... -> X -> Z, partial application (of B) is turning A×B×C...×X -> Z into A×...×X -> Z
16:10:15 <mmorrow> @pl \f -> \z x y -> f x y z
16:10:15 <lambdabot> flip . (flip .)
16:10:25 <mmorrow> :t flip . (flip .)
16:10:26 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> b -> a1 -> a -> c
16:11:00 <mmorrow> :t flip . (flip . (flip .) .)
16:11:01 <lambdabot>     The operator `.' [infixr 9] of a section
16:11:01 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
16:11:01 <lambdabot>         in the section: `(flip . (flip .) .)'
16:11:10 <mmorrow> :t flip . ((flip . (flip .)) .)
16:11:11 <lambdabot> forall a b c a1 a2. (a2 -> a1 -> a -> b -> c) -> b -> a2 -> a1 -> a -> c
16:11:33 <mmorrow> @pl \f -> \d a b c -> f a b c d
16:11:33 <lambdabot> flip . ((flip . (flip .)) .)
16:12:43 <mmorrow> @pl \f -> \a b c d -> f d a b c
16:12:43 <lambdabot> (((flip .) . flip) .) . flip
16:12:53 <mmorrow> cool
16:13:13 * mmorrow copypastes that one for later..
16:35:21 <plutonas> newsham: it was a case sensitive error :P
16:35:56 <newsham> it happens
16:36:15 <dons> awesome. 500k/s downloads from d.h.o
16:36:46 <plutonas> newsham: yeap, now i'm having another kind of problem, but this more a logic one
16:36:51 <Pseudonym> Woo, that means you should be able to download statically linked binaries within a week!
16:37:06 <paggas> say my code is something like { main = getArgs >>= \args -> (if null args then error "..." else XXX) >> ... } what would be the best thing to put in place of XXX, if i just want nothing to happen?
16:37:10 * dons slaps Pseudonym 
16:37:12 <dons> cheeky bugger
16:37:17 <Pseudonym> Yeah, well.
16:37:55 <Pseudonym> I actually think that reducing the size of statically linked binaries wouldn't be too hard in principle.
16:38:17 <Pseudonym> But you have to wonder if statically linked binaries are that useful in the circumstances where Haskell is maximally useful.
16:38:29 <dons> well. web apps
16:38:34 <dons> they are certainly useful there.
16:38:46 <Pseudonym> What, statically linked binaries?  Really?
16:38:47 <dons> deploying network appliances to customers with funky environments
16:38:51 <Pseudonym> Right.
16:39:02 <dons> those are the scenarios i've cared about static linking
16:39:07 <dons> and it's saved some headaches
16:39:11 <newsham> paggas: when (null args) error "oops"
16:39:38 <paggas> newsham: no, i mean, what no-op to put in the else?
16:39:40 <Pseudonym> One thing we did in Mercury once is a cool hack where we generated an object file for each procedure.
16:39:43 <thoughtpolice> yeah it's nice when you can just statically link happs stuff
16:39:44 <thoughtpolice> and drop it in
16:39:55 <paggas> because the parser wants an else...
16:40:03 <Pseudonym> And then let the linker do, essentially, inter-procedural dead code elimination.
16:40:06 <dons> anyone want to try to answer "Subject: [Haskell-cafe] How to check if two Haskell files are the same?
16:40:09 <dons> "
16:40:13 <dons> Pseudonym: that's what split objs does
16:40:17 <Pseudonym> Right.
16:40:20 <Pseudonym> Aha.
16:40:28 <Pseudonym> Well, it'd be interesting to compile the libraries with that.
16:40:31 <dons> let the linker to dead code.
16:40:39 <dons> right, it does on linux distros, usually
16:40:44 <pgavin> solaris 64 doesn't support static linking... so it doesn't work *everywhere* :/
16:40:46 <dons> so you get a 200k helloworld then
16:41:05 <newsham> paggas:   when (null args) error "error message"
16:41:10 <Pseudonym> Still smaller than GNU hello, then.
16:41:12 <newsham> paggas:   when (null args) (error "error message")
16:41:15 <newsham> ?type when
16:41:16 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:41:19 <plutonas> hm, does haskell have pattern matching for strings or lists of strings?
16:41:27 <pgavin> plutonas: both
16:41:30 <newsham> ?type error "message"
16:41:32 <lambdabot> forall a. a
16:41:39 <Saizan> paggas: "return ()" is the standard no-op for monads
16:42:23 <plutonas> not as arguments, i mean like having ["please", "*"] and ["blah", "blah", "please", "give", "me", "something"] and that it returns ["give", "me", "something"]
16:42:39 <pgavin> > let { f ["foo", "bar", _] = True ; f _ = False } in (f ["foo", "bar", baz"], f 1)
16:42:40 <lambdabot>       lexical error in string/character literal at character '\n'
16:42:43 <paggas> ahem, i guess the best would be to put the rest of main's code into else :) like { main = getArgs >>= \args -> if null args then error "oops" else ([rest of main]) }
16:43:10 <pgavin> > let { f ["foo", "bar", _] = True ; f _ = False } in (f ["foo", "bar", baz"], f 1)
16:43:11 <lambdabot>       lexical error in string/character literal at character '\n'
16:43:17 <plutonas> or maybe as a maybe value, so that we could get Nothing if it doesn't matching
16:43:20 <plutonas> does this exist?
16:43:20 <pgavin> stupid erc :/
16:43:20 <newsham> > f "please":_:xs = xs in f (words "please give me something")
16:43:21 <lambdabot>   mueval: Prelude.read: no parse
16:43:24 <idnar> pgavin: you have baz" without opening "
16:43:26 <plutonas> pgavin: is this for me?
16:43:31 <newsham> > f ("please":_:xs) = xs in f (words "please give me something")
16:43:32 <lambdabot>   mueval: Prelude.read: no parse
16:43:44 <pgavin> idnar: oh, lol
16:43:46 <newsham> > let f ("please":_:xs) = xs in f (words "please give me something")
16:43:48 <lambdabot>   ["me","something"]
16:43:58 <paggas> hmmm, didn't know of the when function
16:44:02 <pgavin> > let { f ["foo", "bar", _] = True ; f _ = False } in (["foo", "bar", baz"], f ["1"])
16:44:04 <lambdabot>       lexical error in string/character literal at character '\n'
16:44:27 <pgavin> > let { f ["foo", "bar", _] = True ; f _ = False } in (["foo",["foo", "bar", "baz"], f ["1"])
16:44:28 <lambdabot>   mueval: Prelude.read: no parse
16:44:31 <pgavin> I'm having a bad day :)
16:44:48 <pgavin> anyhow, you get the point
16:45:08 <plutonas> newsham: what happened to give?
16:45:20 <Stinger_> > "test" : "test"
16:45:22 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
16:45:23 <plutonas> perhaps i should use "please":xs?
16:45:24 <pgavin> > let { f ["foo", "bar", _] = True ; f _ = False } in (["foo", "bar", "baz"], f ["1"])
16:45:26 <lambdabot>   (["foo","bar","baz"],False)
16:45:29 <pgavin> yay
16:45:31 <pgavin> finally
16:45:36 <plutonas> i get a bit confused with all that
16:46:07 <pgavin> :t (:)
16:46:08 <lambdabot> forall a. a -> [a] -> [a]
16:46:15 <newsham> > let f ("please":x:xs) = xs ++ [x] in f (words "please give me something")
16:46:16 <lambdabot>   ["me","something","give"]
16:46:20 <newsham> there's give
16:46:43 <pgavin> plutonas: the right side of the : has to be a list of whatever is on the left of the :
16:46:48 <Stinger_> I guess string literals are interpretted differently in patterns?
16:47:01 <plutonas> hm, it's not exactly what i wanted though
16:47:02 <Botje> not really
16:47:05 <pgavin> Stinger_: sorta, but you can just replace the "" with [,]
16:47:10 <Botje> "test" is of type [Char]
16:47:15 <plutonas> could alter it perhaps, have to think
16:47:23 <Botje> and (:) is of type a -> [a] -> [a]
16:47:24 <pgavin> Stinger_: e.g. "test" -> ['t','e','s','t']
16:47:32 <Botje> you're feeding it "test" and "test"
16:47:38 <Botje> so yeah, it has a right to complain
16:47:46 <Botje> "test" : ["test"]
16:47:51 <pgavin> you'd want to do "test":["test2", "test3"]
16:47:54 <Botje> or "test" ++ "test"
16:48:03 <Stinger_> oh that pattern above was  not as interesting as I thought
16:48:14 <pgavin> or 'a':"test"
16:48:20 <pgavin> > 'a':"test"
16:48:21 <lambdabot>   "atest"
16:49:02 <newsham> perhaps you want a regexp matcher?
16:49:14 <Stinger_> I thought he was doing "please":blah as shorthand for 'p':'l':'e':'a':'s':'e':blah
16:50:20 <BMeph_> Sounds like you want something like a combo of 'when' and 'isPrefixOf'
16:51:04 <plutonas> newsham: i think regexp matcher would be better
16:51:24 <Saizan> > let foo x | Just rest <- stripPrefix "please" = rest in foo "pleaseblah"
16:51:25 <lambdabot>   Couldn't match expected type `[Char] -> Maybe [Char]'
16:51:34 <Saizan> > let foo x | Just rest <- stripPrefix "please" x = rest in foo "pleaseblah"
16:51:35 <lambdabot>   "blah"
16:51:41 <plutonas> actually i have a list of things like ("please *", "*") which means that whenever i meet please something i should substitute by the rest
16:51:50 <BMeph_> plutonas: Yeah, especially if you're planning on doing some weird, crazy pattern-in-a-pattern matching... ;)
16:51:51 <plutonas> of course i should repeat this for every possible match in my list
16:51:55 <dons> today's rather awesome galois tech talk:
16:51:58 <dons>   http://www.reddit.com/r/programming/comments/71u3q/using_theorem_proving_for_program_verification/
16:52:00 <lambdabot> Title: Using theorem proving for program verification :: (Talk, Slides) : programming, http://tinyurl.com/5bd8eu
16:52:06 <dons> about how to use theorem proving to do verification.
16:52:07 <plutonas> well it's my homework actually, but i don't know what tools to use
16:52:15 <dons> relvant to our interests.
16:52:20 <dons> Cale, i think you'll be interested.
16:52:24 <dons> on the mathier end of things.
16:52:31 <plutonas> i'm pretty sure there'll be something relevant
16:52:43 <BMeph_> dons: Do you know if the GpuGen talk got passed on to gpgpu.org? ;)
16:52:49 <newsham> dons: danke
16:52:52 <Stinger_> ey dons, is there anywhere in Aust that has(will have) your book at reasonable prices?
16:52:59 * BMeph_ winks and nudges dons, oh-so-knowingly...
16:53:41 <BMeph_> Stinger_: Austria? ;p
16:53:54 <plutonas> something like perls s/please// would be great
16:54:02 <Stinger_> nuts to Austria ;)
16:54:12 <gnuvince_> @instance Monad []
16:54:12 <lambdabot> Maybe you meant: instances instances-importing
16:54:18 <plutonas> or s/please (.*)/$1/ even better
16:54:23 <jeffz> Stinger_: amazon will probably be the cheapest
16:54:26 <plutonas> (if i remember perl correctly
16:54:26 <gnuvince_> @src [].>>=
16:54:27 <lambdabot> Source not found.
16:54:33 <gnuvince_> What's the syntax again?
16:54:35 <plutonas> is there something like that?
16:54:44 <gnuvince_> @src [].(>>=)
16:54:44 <newsham> ?src [] (>>=)
16:54:45 <lambdabot> xs >>= f     = concatMap f xs
16:54:45 <lambdabot> Source not found. Wrong!  You cheating scum!
16:54:51 <gnuvince_> newsham: thank you
16:54:54 <newsham> np
16:55:27 <Saizan> plutonas: there's Text.Regex
16:55:41 <newsham> > (\x -> [x*2, x*2+1]) =<< [5, 10, 20]
16:55:42 <lambdabot>   [10,11,20,21,40,41]
16:56:04 <BMeph_> @src (>>=) []
16:56:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:56:13 <newsham> > (\x -> [x*2, x*2+1]) `concatMap` [5, 10, 20]
16:56:14 <lambdabot>   [10,11,20,21,40,41]
16:56:20 <BMeph_> Never mind.
16:57:22 <newsham> dons: isnt the talk kinda preaching to the choir for galois though?
16:57:30 <newsham> you guys are already doing formal verification, no?
16:58:33 <plutonas> Saizan: in the docs of subRegex it sais
16:58:41 <plutonas> In the replacement string, "\1" refers to the first substring; "\2" to the second, etc; and "\0" to the entire match. "\\\\" will insert a literal backslash.
16:58:48 <plutonas> how do i seperate substrings?
16:59:03 <newsham> how do you want it separated?
16:59:19 <plutonas> like the example i gave before in perl for example
16:59:31 <plutonas> s/please(.*)/$1/
16:59:53 <plutonas> so if i have please and then anything, substitute it with the "anything" bit
17:00:07 <newsham> ahh, i havent used Text.Regex yet.
17:00:23 <plutonas> hm, they don't have examples in the docs :(
17:03:52 <newsham> I believe:  subRegex (mkRegex "test (.*) this") "test foo this" "x \\1"
17:04:04 <dons> newsham: yeah, it's more "what's the state of the art" kinda stuff.
17:04:12 <dons> we spec. use theorem proving too, fwiw.
17:04:17 <dons> which was the subject of this talk
17:04:31 <newsham> --> "x foo"
17:04:40 <newsham> dons: ahh
17:04:54 <plutonas> newsham: looks like working
17:04:58 <plutonas> thanks a lot
17:05:35 <newsham> hugs on codepad.org doesnt have Text.Regex
17:08:37 <plutonas> hm, this approach wouldn't work... have to find something else :(
17:08:57 <plutonas> because i should have the strings seperated by words
17:09:03 <plutonas> before doing anything
17:09:04 <newsham> > words "this is a test"
17:09:05 <lambdabot>   ["this","is","a","test"]
17:09:31 <plutonas> newsham: yes i know what words does, the thing is that i can't regex the result
17:09:32 <newsham> ?vixen do you think its possible to make an intelligent bot using a tree of regular expressions?
17:09:32 <lambdabot> why does everyone ask i'f on a bot?
17:09:36 <plutonas> and using unwords would b echeating
17:09:43 <newsham> ?vixen you're not?
17:09:43 <lambdabot> i think you know the answer to that one, silly
17:09:58 <Olathe> Hint: Silly is the answer.
17:11:38 <newsham> pluto: "please\w+(.*)" "how should I \\1?"
17:11:52 <newsham> you can use regexp to munch up the inter-word garbage
17:13:55 <plutonas> newsham: i don't quite get it, but i'm asking too much, where do you find this stuff? is there some page online?
17:14:05 <plutonas> listing this stuff?
17:14:31 <newsham> pluto: there are lots of stuf online about regular expressions.  I dont know if Text.Regex does it, but some packages use \w to denote "any whitespace" (ie. character class with space, tab, newline, etc..)
17:15:00 <newsham> also the ?vixen command in lambdabot is implemented as a tree of regular expressions.  its src is online.
17:15:15 <newsham> ?vixen where are you?
17:15:15 <lambdabot> i truely am
17:16:58 <newsham> src here http://code.haskell.org/lambdabot/Plugin/Vixen.hs
17:17:53 <newsham> binary state here: http://code.haskell.org/lambdabot/State/vixen
17:21:40 <plutonas> i don't think regexes are the right way
17:21:43 <plutonas> i get too confused
17:23:15 <plutonas> what i actually want is a function where i give a list of elements like this (["please", "*"],["*"]) and a phrase like that ["Can","you","please","inform","me"] and get ["Can","you","inform","me"]
17:23:39 <plutonas> i think pattern matching becomes too complicated in this case
17:24:14 <plutonas> regex matching i mean
17:24:23 <newsham> ?vixen i need help.
17:24:23 <lambdabot> pretty needy, aren't you?
17:24:30 <newsham> ?vixen can you help?
17:24:30 <lambdabot> of course i can
17:24:57 <plutonas> newsham: do you have an idea on how to implement this? i mean the algorithm, or what tool to use
17:25:09 <newsham> i dont know what you need to do.
17:25:26 <plutonas> write a function like i just described
17:26:08 <newsham> i dont understand your description
17:26:26 <plutonas> i want to write a function that takes 2 arguments
17:26:52 <plutonas> one is a phrase in the form derived using words
17:27:05 <FunctorSalad> > let iCanParseTwoStrings =
17:27:07 <lambdabot>   mueval: Prelude.read: no parse
17:27:13 <plutonas> like (words "Can you please inform me")
17:27:40 <plutonas> and the other argument should be ((words "please *"), (words "*"))
17:28:03 <plutonas> this means find please .* in the given phrase and substitute it by .*
17:28:58 <Stinger_> hmm the impossible seems to occur when I try to load gtk2hs
17:29:03 <newsham> why not just \x -> subRegex (mkRegex "please (.*)") x "\\1"
17:30:39 <plutonas> because this would work fine for String, but not (words String)
17:30:45 <plutonas> and this is what i need
17:32:09 <plutonas> anyway i'm too tired to think clearly, i'll continue tomorrow, thanks all for your help
17:32:15 <newsham> why not just \x -> subRegex (mkRegex $ unwords ["please",["(.*)"]) (unwords x) "\\1"
17:32:50 <plutonas> i don't think i'm supposed to use unwords
17:33:22 <plutonas> because words is called explicitly before the function i need to write...
17:34:32 <Stinger_> so,.. this wouldnt be homework would it?
17:35:05 <plutonas> Stinger_: i've said several times it's homework, i don't try to hide this
17:35:12 <plutonas> neither do i want someone to solve it for me
17:35:47 <plutonas> i just have no idea on the algorithm to use
17:35:53 <Botje> plutonas: write a function match that compares two strings
17:36:05 <spx2> how is Code Review carried on on googlecode ?
17:36:11 <Botje> match str1 str2 = str1 == str2
17:36:18 <Stinger_> yeah sorry, I haven't been following, but are you trying to make it too general perhaps?
17:36:22 <Botje> match "*" _ = True
17:36:37 <Botje> then, at each spot in the list, see if the pattern matches
17:36:48 <Botje> and if so, do the replace
17:37:24 <plutonas> Botje: sounds good, i'll try a bit more :)
17:37:26 <Botje> well
17:37:43 <Botje> match ("*":rest) _ = True
17:38:05 <Botje> match (str1:rest) (str2:rest2) = str1 == str2 && match rest rest2
17:38:11 <newsham> botje: http://blog.thoughtfolder.com/2008-02-04-even-more-beautiful-code-c-haskell-.html
17:38:13 <lambdabot> Title: Even more Beautiful Code (C → Haskell) — Thoughtfolder, http://tinyurl.com/5r96zg
17:38:13 <Botje> that's the gist of it
17:38:31 <Botje> yes?
17:38:51 <Botje> you probably mean plutonas  :)
17:39:11 <dons> spx2: don't they use their code review online tool?
17:39:53 <Stinger_> so anyone else had problems with gtk2hs under windows?  I have a panic while loading glib-0.9.13
17:40:55 <spx2> dons: what tool would that be ? the single code review thing I have found so far seems to be comments from other googlecode users
17:42:40 <dons> try googling for code review google web tools
17:42:41 <dons> or something
17:43:41 <spx2> dons yes..or something
17:45:54 <spx2> newsham: if you're watching a particular newsfeed reddit/hackernews/etc please tell me on which you found the article ? it seems like a very nice one
17:46:12 <newsham> i got it from someone on irc.
17:46:17 <newsham> or perhaps hwn
17:46:59 <spx2> hwn = ?
17:47:19 <newsham> http://sequence.complete.org/hwn/20080913
17:47:22 <lambdabot> Title: Haskell Weekly News: September 13, 2008 | The Haskell Sequence
17:49:56 <gnuvince_> I don't understand something in http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=ghc&id=2 : the 'when (m == 1) (print i)' line, isn't m an IO Int?  If so, isn't that line ill-typed?
17:49:59 <lambdabot> Title: thread-ring Haskell GHC #2 program | x64 Ubuntu : Intel® Q6600® quad-core Comp ..., http://tinyurl.com/6kujbr
17:50:49 <newsham> takeMVar l :: IO Int, then  m <- takeMVar l,  m :: Int
17:51:16 <gnuvince_> ah
17:51:17 <newsham> the variable binds the pure value
17:51:22 <gnuvince_> thanks newsham
17:51:24 <newsham> np
17:51:41 <gnuvince_> let m = takeMVar r would've given an IO Int, right?
17:51:53 <newsham> right.
17:51:58 <gnuvince_> Brainfart
17:52:00 <gnuvince_> Sorry.
17:52:46 <newsham> ?type (>>=)
17:52:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:53:06 <newsham> the "m a" value gets passed as the "a" arg to (a -> m b)
17:53:15 <newsham> thats the binding
17:54:46 <Refried_> heya... so nested guards never ended up happening, or did they?
17:54:52 <Refried_> i see some posts about them from 2006
17:57:40 <hackage> Uploaded to hackage: hstats 0.3
18:01:08 <newsham> hmm.. this thread-ring program,  cpu load: 4% 1% 0% 92%
18:01:17 <newsham> odd
18:06:21 <dolio> The shootout thread ring?
18:06:33 <newsham> yup
18:06:41 <dolio> That's, like, designed not to parallelize well. :)
18:06:46 <dolio> For some reason.
18:06:51 <newsham> the other submission use 75/25 ish and did worse
18:07:12 <newsham> i guess thats the "do you do good userland pseudo-threads" test
18:07:38 <Olathe> https on www.haskell.org gives security warnings :(
18:07:45 <newsham> the mandelbrot set one isnt parallelized?  seems like the most obvious win :)
18:08:00 <Olathe> Ahh, it's self-signed.
18:08:41 <newsham> add it to your root certs ;-)
18:08:48 <newsham> we all trust haskell.org, right?
18:09:48 <Olathe> How much are cheap certificates from well-accepted roots ?
18:11:04 <gnuvince_> There's something I don't understand with the thread ring program: how does one thread "call" another?
18:11:27 <gnuvince_> Or rather, "where" does ont thread call another?
18:11:44 <newsham> the MVar is blocking when you read from it when its empty
18:11:51 <newsham> and when you put a value in it, it wakes up the guy who is waiting
18:12:14 <newsham> they're all created empty except the first one in main
18:12:52 <gnuvince_> does takeMVar l leave l empty?
18:13:07 <dmwit> yeah
18:13:28 <dolio> It's really a rather weird benchmark. I'm not sure why they put it on the parallel machine.
18:13:44 <newsham> it measures context switch time.
18:13:50 <newsham> good microbenchmark
18:13:59 <newsham> going to kill everyone using kernel threads
18:14:20 <newsham> although it is odd in that most of the benchmarks on that site arent microbenchmark types
18:17:30 <dolio> Although I guess Simon Marlow said he was able to get it to run faster on a multi-processor somehow.
18:17:37 <dolio> With very careful tuning or something.
18:18:23 <dolio> I'm not sure how he did it, though.
18:19:03 <dolio> The second place haskell one looks like it ties certain threads to certain processors, but it isn't faster.
18:19:32 <dolio> (Which is, I thought, what he said he did; maybe it needs improvements in 6.10 to work right.)
18:19:46 <newsham> they should make it pass four tokens around the ring
18:19:56 <newsham> with different starting points
18:19:59 <newsham> that would be interesting
18:20:14 <Olathe> Does it output anything ?
18:20:33 <newsham> it outputs the final thread id when the passing count reaches zero
18:20:38 <dolio> Yes. Otherwise Haskell wouldn't do any work. :)
18:20:39 <newsham> ie. it computes a modulo
18:20:46 <dolio> They learned that one a long time ago. :)
18:21:37 <Olathe> What are you supposed to use as command line args ?
18:21:48 <newsham> it takes the count from cmd line
18:21:54 <newsham> and it passes the token that many times
18:21:58 <Olathe> Ahh.
18:22:00 <newsham> (individual passes, not orbits)
18:22:58 <gnuvince_> Are the monads really what confuse people learning Haskell the most?  The more I use it, the more I find that the lazy evaluation sends my head spinning
18:23:22 <intoverflow> people find it difficult to know when monads are to be used, and in which manner
18:23:41 <newsham> monads were more confusing than lazy evaluation to me, although i think reasonaing about space is definitely harder than in avg language once you get past the other stuff
18:23:47 <intoverflow> lazy evaluation gunks up the process for reasoning about programs, but monads (are percevied to) make it hard to write programs in the first place
18:24:00 <newsham> if you'veused coroutines in other languages, you have at least some practice with laziness
18:24:10 <dmwit> I think the biggest confusion point for people is conflating the IO-specific monadic interface and the generalized monad interface.
18:24:12 <newsham> what intoverflow said
18:24:20 <im_alone> the only future is massive vliw
18:24:37 <intoverflow> yeah, going from io to other monads is a step
18:24:43 <newsham> imalone: thats why the itanic is selling so well
18:24:45 <Olathe> im_alone: The future is German ?
18:24:48 <im_alone> fill the nops with another instructions
18:25:24 <gnuvince_> newsham: I use generators in Python quite often, but that's the thing, the laziness in Python is explicit.  In Haskell, I always have to remember that I can't assume something has been executed yet.
18:25:30 <gnuvince_> Maybe my head's too small
18:27:33 <roconnor> Hmm?
18:27:46 <roconnor> when writing pure code, one usually ignores execution order
18:27:54 <roconnor> and thinks of values
18:28:04 <newsham> gnuvince: *shrug* its just like you coded your whole program using generators and generator comprehensions w/o variables.
18:28:06 <roconnor> only in IO does execution order matter, and there it is explicitly spelled out
18:28:06 <gnuvince_> roconnor: I'm looking at a thread ring program with MVars
18:28:13 <im_alone> the order of execution is important for parallelism
18:28:26 <im_alone> overall for synchronizing the data
18:28:28 <intoverflow> roconnor: execution order matters in State as well as others
18:28:37 <roconnor> intoverflow: no it doesn't
18:28:44 <roconnor> @instances MonadFix
18:28:44 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:29:05 <roconnor> State is an instance of MonadFix, which illustarates how execution order doesn't matter.
18:29:05 <intoverflow> roconnor: what happens if you re-order a series of get's and set's?
18:29:21 <roconnor> a different sequence
18:29:35 <newsham> roconnor: explain MonadFix remark?  sounds interesting but i dont get it
18:29:38 <roconnor> but you can still use results of a state computation "before" it is computed
18:29:55 <intoverflow> I'm intruiged, but not sure I follow
18:29:58 <roconnor> newsham: have you read my TMR article on recursive do?
18:30:07 <newsham> no.  url?
18:30:11 <im_alone> merge two sequences of instructions in parallel, it will reduce the number of nops
18:30:38 <newsham> imalone: if you're evaluating pure code the order wont matter.
18:30:44 <roconnor> article here --> http://www.google.ca/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fwww.haskell.org%2Fsitewiki%2Fimages%2F1%2F14%2FTMR-Issue6.pdf&ei=ol3QSJvsM5r8gAKRveiAAQ&usg=AFQjCNHZCc3fg_VLaDh3CTSEYiuVk3U0fA&sig2=6PnsL5ZzU8SPc9iqODc1lw
18:30:45 <roconnor> wha
18:30:47 <lambdabot> Title: cache:http://www.google.ca/url?sa=t&source=web&ct=res&cd=1&url=http%3A%2F%2Fwww. ..., http://tinyurl.com/6ke9gg
18:30:47 <roconnor> sorry
18:30:49 <im_alone> but it will require the double size of bank of registers
18:31:11 <roconnor> article here --> http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
18:31:12 <lambdabot> Title: The Monad.Reader Issue 6
18:31:15 <BMeph> Is the backwards State example in the wiki?
18:32:33 <newsham> why do you use {}'s for mdo?  so you can indent labels weirdly?
18:32:45 <roconnor> although get and sets in the state monad are sequenced, things are not necessarily evaluted in that order
18:33:04 <roconnor> newsham: yes, I think that was the reason.
18:33:07 <newsham> bmeph: here's one http://luqui.org/blog/archives/2008/08/10/mindfuck-the-reverse-state-monad/
18:33:09 <lambdabot> Title: Mindfuck: The Reverse State Monad @ The dreams that stuff is made of, http://tinyurl.com/6rl5bw
18:33:39 <BMeph> roconnor: Thanks; I thought intoverflow would appreciate it. ;)
18:33:59 <intoverflow> roconnor, BMeph: indeed, very very cool
18:34:45 <roconnor> @type runState
18:34:47 <lambdabot> forall s a. State s a -> s -> (a, s)
18:34:49 <im_alone> for algebraic operations, the massive vliw is very good!
18:35:25 <newsham> > let upd n = [n*4, n*4+1] in iterate upd [0] -- how can I mfix on this upd function?
18:35:25 <roconnor> > runState $ do { set undefined; set 5; get} 1
18:35:27 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
18:35:27 <lambdabot>        Expect...
18:35:27 <lambdabot>  Terminated
18:36:37 <newsham> > flip runState 1 $ do { set undefined; set 5; get}
18:36:38 <lambdabot>   mueval: Prelude.read: no parse
18:37:25 <roconnor> > runState (do { put undefined; put 5; get}) 1
18:37:27 <lambdabot>   (5,5)
18:37:36 <roconnor> see how put undefined isn't evalued
18:38:03 <Olathe> > runState (do { put undefined; put undefined; get}) 1
18:38:04 <lambdabot>   mueval: Prelude.read: no parse
18:38:04 <lambdabot>  mueval: (*** Exception: Prelude.undefined
18:38:05 <roconnor> or isn't "evaluted"
18:39:08 <roconnor> that second put undefined was evaluted because it was demanded
18:39:19 <intoverflow> roconnor: would it be appropriate to think of this in terms of a reaching-definitions analysis?
18:39:36 <roconnor> intoverflow: indeed, you should think of all pure code that way.
18:39:48 <roconnor> and by pure I mean non IO
18:40:43 <roconnor> a lot of people thing that puts and gets are "evaluted" in the state monad, but they are only evaluted if they are "reachable"
18:41:18 <Olathe> roconnor: Ahh, state only stores the last put ?
18:41:30 <Olathe> > runState (do { put 5; put undefined; get}) 1
18:41:31 <lambdabot>   mueval: Prelude.read: no parse
18:41:31 <lambdabot>  mueval: (*** Exception: Prelude.undefined
18:41:33 <Olathe> Ahh.
18:41:39 <Olathe> > runState (do { put 5; put undefined; put 11; get}) 1
18:41:40 <lambdabot>   (11,11)
18:41:52 <Mitar> how could I repeat a monadic action which returns a boolean value until it is returning False?
18:42:05 <dmwit> You have to write the control structure yourself.
18:42:06 <roconnor> > runState (do { put 5; put undefined; x <- get put 11;  y <- get; return (y,x)}) 1
18:42:07 <lambdabot>       No instance for (MonadState (t -> State s t1) ((->) (s1 -> m ())))
18:42:07 <lambdabot>     ...
18:42:14 <roconnor> > runState (do { put 5; put undefined; x <- get; put 11;  y <- get; return (y,x)}) 1
18:42:15 <lambdabot>   mueval: Prelude.read: no parse
18:42:15 <lambdabot>  mueval: ((11,*** Exception: Prelude.undefined
18:42:23 <roconnor> in this example the 11 prints
18:42:35 <dmwit> Mitar: There's too many choices for the type of whileM, so it's not in the library. =)
18:42:39 <roconnor> but after the 11 is evaluted, the undefined is evaluted, and then the exception is thrown.
18:42:54 <BMeph> dmwit: Call it... whetever? ;)
18:42:55 <roconnor> so the puts are actually evaluted in reverse order.
18:42:58 <newsham> whileTrue act = act >>= again;  where again True = whileTrue act; again False = return ()
18:43:13 <roconnor> but again, one should just not think about evaluation order
18:43:26 <Olathe> That makes sense.
18:43:28 <dblazakis> @pl \f g x-> do { s <- f x; return $ g x }
18:43:28 <lambdabot> (line 1, column 13):
18:43:28 <lambdabot> unexpected "{"
18:43:28 <lambdabot> expecting variable, "(", operator or end of input
18:43:47 <Olathe> get returns the last put in code order, or something.
18:43:50 <Olathe> Not execution order.
18:44:03 <dmwit> ?pl \f g x -> f x >> return (g x)
18:44:03 <lambdabot> (. (return .)) . liftM2 (>>)
18:44:16 <dmwit> dblazakis: But that probably doesn't do what you want.
18:44:19 <roconnor> Olathe: that's right.
18:44:22 <Mitar> hmm, anything nicer?
18:44:25 <newsham> ?src (>=>)
18:44:25 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:44:33 <Olathe> Lazily evaluating state stuff is neat.
18:44:37 <dmwit> dblazakis: It throws away the result of (f x), and then does the (pure) calculation (g x)...
18:44:38 <Mitar> something like "sequence_ . takeWhile id . repeat action"
18:44:49 <Mitar> (of course this is not valid)
18:44:56 <dmwit> Mitar: takeWhileM has the same problem. =)
18:45:02 * roconnor is pleased that these examples illustrate things well.
18:45:11 <dblazakis> dmwit: doy! i meant g s
18:45:28 <intoverflow> roconnor: this has been very useful
18:45:29 <dmwit> ?pl \f g x -> f x >>= return . g
18:45:29 <lambdabot> (. (return .)) . flip . ((>>=) .)
18:45:32 <dblazakis> dmwit: my brain is moving super slow, is that just f x >>= return .
18:45:33 <dmwit> dblazakis: But:
18:45:36 <roconnor> > runState (do { put 5; z<- get; put undefined; x <- get; put 11;  y <- get; return (y,z)}) 1
18:45:38 <lambdabot>   ((11,5),11)
18:45:46 <dmwit> \f g x -> f x >>= return . g === liftM g (f x)
18:45:48 <newsham> if you defined whileM in terms of the more general monadic test case and action, you could easily use pure/return to use it w/ pures too
18:45:57 <roconnor> in this case the 11 and 5 are evaluted (in reverse order) and the undefined is ignored.
18:46:12 <dblazakis> :t liftM
18:46:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:46:33 <roconnor> > runState (mdo { put y; z<- get; put undefined; x <- get; put 11;  y <- get; return (y,z)}) 1
18:46:35 <lambdabot>   ((11,11),11)
18:46:36 <dmwit> dblazakis: Some people prefer to spell liftM as fmap.  For most cases, they're the same. =)
18:46:45 <dblazakis> :t fmap
18:46:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:47:02 <roconnor> > runState (mdo { put y; z<- get; put 22; x <- get; put 11;  y <- get; return (z,x)}) 1
18:47:04 <lambdabot>   ((11,22),11)
18:47:05 <newsham> <$>
18:47:06 <Olathe> I wonder how State is implemented.
18:47:08 <dblazakis> dmwit: ah, thanks
18:47:10 <Olathe> @index runState
18:47:10 <lambdabot> Control.Monad.State, Control.Monad.RWS
18:47:14 <roconnor> I'll let you think about how that works
18:47:15 <Mitar> and from all this possibilities ... which is nice?
18:47:42 <roconnor> @src State
18:47:43 <lambdabot> Source not found. There are some things that I just don't know.
18:48:04 <roconnor> State s a = s -> (a,s)
18:48:15 <Olathe> Hmm...
18:48:26 <Olathe> Control.Monad.State doesn't appear to have it in source.
18:48:31 <roconnor> Olathe: studying how state is implement is a good way to gain understanding of monads
18:48:37 <Olathe> Oh, wait.
18:49:01 <roconnor> see Control.Monad.State.Lazy
18:49:25 <roconnor> there is also Control.Monad.State.Strict
18:49:29 <Olathe> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
18:49:30 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6fo2zn
18:49:38 <Olathe> @src runState
18:49:39 <lambdabot> Source not found. :(
18:49:39 <roconnor> I haven't used it, but I think all these examples we have been doing would fail.
18:50:16 <Olathe> Where is runState defined ?
18:50:32 <Olathe> I'm looking in Control.Monad.State.Lazy, and it seems to use it, but not define it.
18:50:40 <roconnor> newtype State s a = State { runState :: s -> (a, s) }
18:50:43 <roconnor> defined there
18:50:53 <roconnor> standard Haskell trick
18:50:58 <Olathe> How does that work ?
18:51:11 <bjrn> Olathe: There's a nice explenation in RWH
18:51:12 <roconnor> runState is the one and only field of the State record
18:51:16 <Olathe> Ahh.
18:51:34 <roconnor> but we think of it as State being a wrapper and runState being the unwrapper
18:51:54 <newsham> rockonner: have you written any "real" (ie. for hardware) assemblers in haskell in this manner?
18:52:09 <Olathe> Ahh, OK.
18:52:13 <roconnor> no, just an assembler for the ICFP contest
18:52:27 <newsham> would be neat having mega-macro-assembler
18:52:32 <roconnor> they said they would accept solution files in .umz
18:52:50 <roconnor> so we sent in our archive in a compressed .umz file
18:53:03 <Olathe> Heheh
18:53:13 <roconnor> someone had an assember that he ported the backend for
18:53:29 <roconnor> so we got a LZW compressor
18:53:40 <roconnor> then i wront a UM-DOS shell around it
18:53:43 <roconnor> in assembly
18:53:48 <dblazakis> :t (<$>)
18:53:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:53:50 <roconnor> and I needed my own assember
18:55:03 <roconnor> I'm not certain this technique would scale up to a real life assembler.
18:56:35 <newsham> never know until you try :)
18:58:03 <roconnor> someone made an improvement to my code:
18:58:09 <roconnor> http://paste.lisp.org/display/36311/raw
18:58:15 <roconnor> or rather an imporvement to my idea
18:58:44 <roconnor> but I don't know who  eq  is.
19:00:37 * BMeph thinks an LLVM assembler would be...intriguing
19:03:36 <newsham> roconnor: is there a cost to your feedback?  are your labels always fixed in place or can it diverge?
19:05:18 <roconnor> newsham: I don't understand the question.
19:05:34 <roconnor> are you asking if the code can ever bottom out?
19:05:59 <newsham> when computing label offsets, whats the cost?  is it O(1) in the amount of labels and code?
19:06:33 <newsham> are there any variable length opcodes that make label positions move around depending on their values (ie. 1 byte offset for jumps +- 128bytes away)
19:06:38 <roconnor> I don't beleive there is any time cost to computing labels
19:06:59 <dblazakis> is using liftM infix stylistically OK?
19:07:16 <newsham> dbl: sure.  but you could also use `fmap` or <$> which are shorter
19:07:22 <roconnor> there is a memory cost with is O(n) where n is the largest distance between the first use of a label and where it is defined.
19:07:37 <roconnor> (when the label occurs after its use)
19:08:16 <roconnor> newsham: I'm careful so that all opcodes are independent of the labels.
19:08:20 <newsham> you basically get a 2-pass assembler for free.
19:08:27 <roconnor> this restriction removes some optimizations :(
19:09:32 <roconnor> newsham: the assember is 1-pass
19:10:03 <roconnor> I guess
19:10:27 <roconnor> I suppose you can argue that it kinda does two passes between a label use and it's definition.
19:10:47 <roconnor> I'm not sure I'd agree, but one could argue.
19:10:58 <newsham> ahh, you talk about the variable sized opcode thing a little with set vs. set32/set25
19:11:06 <roconnor> yep
19:11:33 <newsham> but... shouldnt something like that work if the results can converge?
19:11:33 <roconnor> it's okay to have "variabable sized" codes, so long as they don't vary on label values.
19:11:54 <roconnor> newsham: I think you can make it work if you can ensure the results converge
19:12:14 <roconnor> doing something like http://paste.lisp.org/display/36311 may help in that direction.
19:12:44 <roconnor> One needs peano numbers so that things are counted lazily
19:13:03 <roconnor> but the lists of instructions should be a proxy for lazy peano numbers
19:14:14 <roconnor> or semi-lazy numbers
19:14:18 <roconnor> something like
19:14:37 <roconnor> data SemiPeano = Num Integer | Succ SemiPeano
19:15:14 <roconnor> Hmm
19:15:20 <roconnor> even that might not be right
19:15:34 <roconnor> maybe you need SemiPeano = (Integer, [()])
19:15:53 <roconnor> because you need access to the Integer at the top of the structure, not the bottom.
19:15:56 <roconnor> anyhow
19:16:10 <roconnor> It's a tricky problem, but I think it could be done.
19:16:42 <roconnor> Hmm
19:16:54 <roconnor> maybe SemiPeano = Zero | Plus Integer SemiPeano
19:19:01 <newsham> good article.  i saw it before but hadnt had a chance to read it before.  thank you.
19:27:58 <Stinger_> >:( if objcopy removes ouput files on error in cygwin I'm going to be annoyed
19:28:13 <Olathe> > :(
19:28:14 <lambdabot>   mueval: Prelude.read: no parse
19:28:22 <Stinger_> heh
19:28:32 <Olathe> I think the order of that should be switched.
19:28:40 <Stinger_> > (:())
19:28:41 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
19:28:49 <Olathe> > :D
19:28:50 <lambdabot>   mueval: Prelude.read: no parse
19:28:55 <Olathe> > (:D)
19:28:56 <lambdabot>   mueval: Prelude.read: no parse
19:29:00 <Olathe> > (:p)
19:29:01 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
19:29:10 <Olathe> Bah.
19:33:09 <Stinger_> yay
19:33:13 <Stinger_> I fixed gtk2hx
19:33:27 <Stinger_> gtk2hs even
19:33:39 <Olathe> What does it do ?
19:33:54 <Stinger_> gtk2hs?
19:34:06 <Olathe> Yeah.
19:34:07 <Stinger_> its a haskell gtk binding
19:34:25 <Olathe> Ahh, OK.
19:34:34 <dmwit> What did you fix?
19:34:55 <Stinger_> ghc 6.8.3 breaks if the libs have .reloc sections in them
19:35:01 <Stinger_> so I removed them :P
19:35:24 <Stinger_> they seemed to be empty
19:36:53 <Stinger_> not really a fix as such, more of a ghc workaround
19:42:37 <AlexSuraci> Anyone know any info on this Hyena web server thing? http://github.com/tibbe/hyena/tree/master
19:42:38 <lambdabot> Title: tibbe's hyena at master — GitHub
19:42:54 <tibbe> AlexSuraci: just a bit ;)
19:43:00 <tibbe> it's not released yet
19:43:03 <AlexSuraci> Oh, hello :P
19:43:11 <tibbe> it's put up there so people can start looking at the code and hacking on it
19:43:35 <AlexSuraci> Ah, what can it do so far? Hello world?
19:44:10 <AlexSuraci> Not exactly sure how to use it
19:48:37 <newsham> tibbe has slides on his website.
19:48:56 <tibbe> newsham: I don't ;)
19:49:06 <tibbe> AlexSuraci: anything you want but it's not polished yet
19:49:12 <tibbe> and fast
19:49:17 <tibbe> it's like 1500 req / sec
19:49:27 <tibbe> I'm a bit busy at work now, sorry!
19:49:47 <AlexSuraci> no problem :)
19:50:19 <newsham> tibbe: i bet you do
19:50:20 <newsham> http://www.johantibell.com/Left_fold_enumerators.pdf
19:50:28 <lambdabot> Title: cache:http://www.johantibell.com/Left_fold_enumerators.pdf - Google Search
19:50:39 <AlexSuraci> yea, that's how I got here :P
19:50:39 <FunctorSalad> @type gfoldl
19:50:40 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
19:50:57 <tibbe> newsham: haha, oops, they were for the Galois presentation. not very good documentation though
19:51:09 <newsham> tibbe: i enjoyed them, although terse.
19:51:30 <FunctorSalad> maybe they should have abandoned the "one-letter type variables" convention for that signature
19:51:31 <tibbe> newsham: thanks
20:35:19 <lispy> That type signature is hard to digest
20:39:05 <lispy> I think the thing tripping me up in gfoldl is the polymorphic stuff
20:39:12 <lispy> what rank is that type sig?
20:39:21 <dolio> 2
20:39:21 <lispy> And where is Data defined?
20:39:27 <lispy> actually, how do you define Data?
20:39:30 <sjanssen> lispy: Data.Generics
20:39:41 <lispy> I guess Data is fine since data is the keyword?
20:39:51 <dolio> I believe gfoldl is the only required method for Data.
20:39:58 <lispy> sjanssen: oh, is this SYB stuff?
20:40:26 <sjanssen> lispy: right
20:40:35 <dolio> Although there are a bunch of other functions that can be defined in terms of it that are also in the class, I think.
20:40:55 <lispy> I have to be honest and say that when I learned about SYB it was too abstract for my new to haskell brain.  I've never gone back to look again.
20:41:21 <lispy> Do people use it much in practice?
20:41:56 <sjanssen> not a whole lot, I think
20:42:01 <sjanssen> but it can be rather handy
20:43:01 <dolio> I must say, it's not obvious what's being folded.
20:44:03 <roconnor> lispy: McBride threw up after reading SYB.
20:44:22 <roconnor> I think he was unimpressed
20:44:36 <dolio> Or, rather, what the analogue of the reduction function in foldr, say, is.
20:44:57 * lispy doesnt' get the McBride reference
20:44:58 <dolio> I guess it's the 'forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b'.
20:45:19 <roconnor> @who McBride
20:45:20 <lambdabot> Maybe you meant: echo ghc show thx what wn
20:45:26 <roconnor> sucks
20:45:55 <dolio> McBride is a badass, so you should value his opinion. :)
20:46:47 <lispy> is he a magician?
20:47:00 * lispy isn't able to find much about this mcbride on the google
20:47:14 <dolio> Google Conor McBride.
20:47:17 <lispy> I guess you could mean this guy: http://www.larrymcbride.com/
20:47:21 <lambdabot> Title: Larry 'Spiderman' McBride
20:47:46 <roconnor> @go Conor staring out the window
20:47:49 <lambdabot> http://www.cs.nott.ac.uk/~ctm/
20:47:49 <lambdabot> Title: Conor's out the Window
20:48:06 <dolio> Although Larry looks pretty badass, too.
20:48:25 <lispy> Epigram it seems
20:48:36 * dolio feels a sudden urge to buy Trim-Tex drywall products.
20:48:42 <roconnor> that's the McBride
20:49:19 <dino-> Perhaps you guys can help me with ErrorT http://hpaste.org/10443
20:50:09 <lispy> Mr. ErrorT pitties the fail
20:50:20 <dino-> I'm having a problem with that commented-out block, trying to have a liftIO $ do inside my ErrorT computation and be able to somehow signal that an error has occurred in that IO
20:50:35 <dino-> Is that other impl of bar the only way really?
20:51:02 <shrughes> dino- you could include the compiler error message
20:51:10 <dolio> Your commented block throws an error in the IO monad.
20:51:49 <roconnor> dino-: I'm suspicous of the some of those $ 's
20:51:56 <lispy> dino-: it's not strictly needed, but I do find it helpful to newtype my uses of monad transformers, like ErrorT
20:52:00 <ddarius> Personally, I'm leaning toward Uniplate for any SYB needs.
20:52:09 <dino-> dolio: It actually won't even compile. But how to make it reach out further to ErrorT?
20:52:15 <lispy> ($) is pretty safe now with the impredicative stuff in 6.8
20:52:18 <roconnor> oh wait, it isn't a compiling problem
20:52:21 <dino-> Or am I being nonsensical.
20:52:33 <shrughes> dino- you are being nonsensical :)
20:52:44 <dolio> dino-: To do it right, you need to lift the individual IO pieces, like in your uncommented block.
20:52:48 <dino-> lispy: Yeah, I do that in more real applications, typing the transformers.
20:52:49 <roconnor> ya, that throwError is totally different between the two blocks of code
20:52:52 <shrughes> i mean, what you say makes sense -- yes.  but what dolio just said.
20:53:02 <dino-> dolio: Ok, I wasn't sure if this was really the only way.
20:53:30 <dino-> The real code that I'm trying to do this with is actually a long lifted IO with HSQL code in it. And I'd like to fail in the middle perhaps.
20:53:49 <dolio> Although I am curious what compiler error you get. Something about ambiguous types maybe?
20:53:51 <shrughes> lispy: what is this about ($)?
20:53:51 <roconnor> dino-: one day putStrLn will have type (MonadIO m) => String -> m ()
20:53:58 <newsham> ?check \f x -> flip id x f == flip ($) x (f :: Int -> Int)
20:53:58 <lambdabot>       Overlapping instances for Show (Int -> Int)
20:53:58 <lambdabot>        arising from a use o...
20:54:09 <roconnor> dino-: and then you will be happy. :)
20:54:13 <dino-> Ok, thank you all.
20:54:32 <dino-> Oh, the error..
20:55:15 <dino-> http://hpaste.org/10443#a1
20:55:36 <dolio> Oh, that makes sense, too.
20:55:43 <roconnor> yep
20:55:57 <roconnor> @type throwError
20:55:59 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
20:56:04 <dolio> You need "throwError (strError "failed!")"
20:56:08 <dolio> Or something along those lines.
20:56:15 <roconnor> @instances MonadError
20:56:16 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
20:56:27 <dolio> @type strError
20:56:29 <lambdabot> Not in scope: `strError'
20:56:45 <lispy> shrughes: have you ever noticed that sometimes with rank-2 and higher polymorphic types that ($) gives you a type error that parens don't?
20:56:57 <roconnor> dino-: any reason to use you ErrorT instead of IOExceptions?
20:56:58 <dolio> @type strMsg
20:56:59 <lambdabot> forall a. (Error a) => String -> a
20:57:04 <dolio> There we are.
20:57:19 <shrughes> lispy: I was aware of that; never ran into it
20:57:32 <shrughes> but ok that's enough for me, thanks
20:57:34 <dino-> roconnor: The real code I'm working on has lots of thigns called in this ErrorT computation, not all of which are doing IO. But yeah, most of them are.
20:57:36 <lispy> shrughes: this happens because haskell is predicative instead of impredicative.  But, in ghc newer than 6.6 the ($) operator is actually impredicative.  And 6.8 does it even better than 6.6 did
20:57:47 <shrughes> oh
20:57:50 <roconnor> dino-: okay
20:57:55 <shrughes> how is this implemented?
20:58:00 <dolio> lispy: They took it out again.
20:58:18 <dolio> If not in one of the 6.8s, then somewhere in 6.9.
20:58:23 <ddarius> Impredicativity is a property of the type system, not particular functions.
20:58:41 <dino-> roconnor: But I see what you're saying, a possibility is there to make it all IO
20:58:41 <lispy> ddarius: true, but i thought they hack was specific to ($)
20:58:46 <lispy> shrughes: I don't know how it's implemented
20:59:00 <shrughes> ok, thanks
20:59:26 <lispy> shrughes: I don't even know the definition of impredicative other than it applies here :)
21:00:05 <shrughes> @src ($)
21:00:06 <lambdabot> f $ x = f x
21:00:12 <shrughes> meh :P
21:00:19 <lispy> dolio: probably better without it, but that means when 6.10 comes out some code I've written my stop working :(
21:00:37 <dolio> Yeah. Such is life.
21:01:04 <ddarius> lispy: You shouldn't have relied on non-standard, very experimental features.
21:01:04 <dino-> Thanks again. Very helpful.
21:01:36 <lispy> ddarius: well, I didn't rely on it intentionally.
21:02:44 <dolio> Looks like it still works in 6.8.3, so it must have been in my testing of 6.9.* a while ago that it was gone.
21:06:12 <lispy> I won't lie though, it was handy that ($) would work any place that parens worked
21:06:25 <lispy> It's just too bad that it's a non
21:06:30 <lispy> a non-standard feature
21:06:36 <ddarius> Impredicativity definitely has some benefits.
21:11:07 <dino-> roconnor: I take it back, most of the actions are not doing any IO at all.
21:11:18 <dino-> Now that I look at it all closely.
21:14:41 * humasect wishes he could 'forM xs \x-> f (g x)'
21:15:17 <ddarius> forM xs $ \x -> f (g x)
21:15:24 <humasect> and (do x) `with` $ abs r
21:15:59 <humasect> yep, ddarius .. it just seems \ should have a little more juice
21:17:02 <humasect> but , as i am better with function composition, parens and $ seem to be affecting allergies less ..
21:18:15 <koninkje> It'd be nice if when the {}s are explicit then 'do {...}' desugars as if it were '(do {...})'
21:18:30 <koninkje> though I'm not sure there's any way to do that, given what {}s are...
21:19:06 <humasect> hm.. sometimes we don't need to paren constructors (fundefs), and sometimes we do (lambda)
21:24:05 <dino-> Ah, I keep seeing this being talked about. The ($) is changing? This is probably going to get me as well.
21:24:12 <bbs> @src (xs)
21:24:13 <lambdabot> Source not found. I've seen penguins that can type better than that.
21:24:19 <bbs> lol
21:24:23 <bbs> lambdabot: screw you
21:24:30 <bbs> @stfu
21:24:30 <lambdabot> Unknown command, try @list
21:24:32 <bbs> @list
21:24:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:24:39 <lambdabot> bbs: And the horse you rode in on.
21:24:48 <humasect> ah, ($) is changing ? for 6.10? =) i cannot find information on where/how base is changing, only mention that base3-compat is being created
21:35:28 <dolio> ($) isn't changing. The type system is.
21:36:02 <humasect> oh, indexed ?
21:36:27 <humasect> quicksilver: are you here?
21:36:49 <dolio> I don't know if it's documented anywhere currently. What they're removing (if I'm correct) is left-to-right impredicative instantiation (I think that's what it's called).
21:36:55 <dolio> So you can look that up to see what it does.
21:37:11 <humasect> http://haskell.org/haskellwiki/GHC/Indexed_types <- ah, so it is not this
21:37:18 <lambdabot> Title: GHC/Type families - HaskellWiki
21:37:30 <humasect> (not just, rather)
21:37:34 <dolio> Well, that's changing, too. But it doesn't ahve to do with the working of ($).
21:37:48 <dino-> But I will still be able to use it like a 'pipe'?
21:37:59 <humasect> ah, here we go! (from 2006?) http://www.haskell.org/pipermail/cvs-ghc/2006-December/033150.html
21:38:01 <lambdabot> Title: patch applied (ghc): Add left-to-right impredicative instantiation, http://tinyurl.com/6o4vhv
21:38:41 <humasect> so it will likely change the behavior of: putStrLn $ "hello: "++show n >> return ()
21:38:47 <dino-> I kind of think of it like (flip |) <pipes in the shell>
21:38:55 <dolio> No. It only changes in cases like runST.
21:39:18 <dolio> Places where you have higher-rank types.
21:39:50 <humasect> ah, yes i see, i am not very smart tonight
21:44:20 <Heffalump> I thought that got removed again?
21:44:32 <dolio> Yeah. That's what we've been talking about.
21:44:34 <Heffalump> ah, you said that, sorry
21:44:42 * Heffalump should read more than one screen of scrollback :-)
21:44:50 <dolio> > runST $ return 5
21:44:52 <lambdabot>   5
21:44:58 <dolio> . runST $ return 5
21:44:59 <lunabot>   Not in scope: `runST'
21:45:00 <Heffalump> I didn't realise it was added so long ago.
21:45:18 <dolio> . length ([id] :: [forall a. a -> a])
21:45:19 <lunabot>      Illegal polymorphic or qualified type: forall a. a -> a
21:45:32 <dolio> > length ([id] :: [forall a. a -> a])
21:45:34 <lambdabot>   1
21:45:45 <Heffalump> what are . and > ?
21:46:08 <dolio>  . is mmorrow's bot, I believe. Executing haskell code.
21:46:12 <dolio> 6.9.something.
21:46:21 <dolio>  > is lambdabot doing the same thing.
21:46:28 <Heffalump> oh, two bots, I missed that completely :-)
21:47:06 <mmorrow> . [|()|]
21:47:07 <lunabot>  ConE ()
21:47:10 <mmorrow> :)
21:47:21 <dolio> Are rank-n types and all that enabled?
21:47:37 <mmorrow> rank-n are enabled, yes
21:48:24 * mmorrow looks what extensions are on
21:48:28 <dolio> Okay. Then, that error above might be a symptom of the lack of impredicative instantiation.
21:50:02 <mmorrow> Opt_TemplateHaskell, Opt_QuasiQuotes, Opt_ViewPatterns, Opt_RankNTypes, Opt_KindSignatures, Opt_UnicodeSyntax, Opt_MonomorphismRestriction, Opt_PatternGuards , Opt_ParallelListComp, Opt_ImplicitParams
21:50:46 <Heffalump> > let x = [| () |] in $(x)
21:50:47 <lambdabot>   mueval: Prelude.read: no parse
21:50:51 <Heffalump> . let x = [| () |] in $(x)
21:50:51 <lunabot>      GHC stage restriction: `x'
21:51:04 <Heffalump> huh?
21:51:05 <mmorrow> . $([|x|])
21:51:05 <lunabot>   Not in scope: `x'
21:51:11 <mmorrow> . $([|()|])
21:51:11 <lunabot>  ()
21:51:23 <Heffalump> how do you prevent IO in splices?
21:51:23 <dolio> . $( let x = [| () |] in x )
21:51:24 <lunabot>  ()
21:51:25 <humasect> this is quasi ?
21:51:33 <mmorrow> it's an added challenge doing them in a single expression
21:51:36 <Heffalump> oh, of course, silly me
21:51:38 <dons> Heffalump: hide reifyIO ?
21:51:55 <Heffalump> what about lift?
21:52:05 <Heffalump> or is Q not in MonadTrans?
21:52:06 <dons> maybe that too?
21:52:11 <dons> ah, prob. not.
21:52:15 <mmorrow> ooh, i have instances of Lift for /all/ the TH ast :)
21:52:19 <dons> no mtl dep.
21:52:46 <mmorrow> . pp $(lift =<< reify ''IO)
21:52:46 <lunabot>      Overlapping instances for Lift Info
21:52:54 <mmorrow> crap
21:53:12 * mmorrow fixes that
21:53:35 <electronx> anyone know why clean is faster then ghc?
21:53:35 <lambdabot> electronx: You have 1 new message. '/msg lambdabot @messages' to read it.
21:54:02 <dons> electronx: it has a good native code generator, so for the programs it can handle, it generates better asm.
21:54:22 <mmorrow> . pp $(lift =<< reify ''IO)
21:54:23 <lunabot>  newtype IO a_0 = IO (State# RealWorld ->
21:54:23 <lunabot>                       (#,#) (State# RealWorld) a_0)
21:54:42 <dons> electronx: the current ghc native code gen project is addressing that, fwiw.
21:54:53 <dons> ghc gets a modern code gen.
21:55:04 <electronx> ah
21:55:12 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=clean&lang2=ghc
21:55:16 <lambdabot> Title: Clean benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks Gam ..., http://tinyurl.com/2c3rjj
21:55:17 <electronx> cool so ghc might now close the gap on gcc
21:55:37 <dons> right. ghc has all these amazing mid level optimisations
21:55:44 <dons> but generates asm with lots of moves and spills
21:55:45 <mmorrow> Heffalump: ah, i just realized we're talking about diff lifts
21:55:56 <dons> so fixing that up in the next release cycle is pretty exciting.
21:56:04 <mmorrow> . pp $(lift =<< reify ''Lift)
21:56:05 <lunabot>  class Lift t_0
21:56:05 <lunabot>      where lift :: forall t_0 . Lift t_0 => t_0 -> Q Exp
21:56:06 <dolio> That's 6.12 material?
21:56:14 <Boney> is clean eager or lazy?
21:56:18 <Heffalump> I'm talking about the fact that Q is on top of IO and that it might be tricky to protect the bot from users getting at that
21:56:19 <electronx> lazy
21:56:30 <dons> since then you get three good things at once: great optimisations that no one else has (fusion, spec constr..), a great code coalescing register allocator, and a fast smp runtime
21:56:47 <Heffalump> is spec constr really that special?
21:56:55 <electronx> dons: is this going to be in ghc 6.12?
21:56:59 <dons> Heffalump: yeah.
21:57:04 <Heffalump> it's just a form of conditional constant propagation, isn't it?
21:57:05 <dons> turning code into data is pretty good.
21:57:14 <mmorrow> Heffalump: indeed. i use unsafePerformIO in the instances of Show for (Q Doc, Q String, Q Exp, Q [Dec], and Q Type)
21:57:19 <dons> Heffalump: hmm.
21:57:26 <mmorrow> . runIO
21:57:27 <lunabot>   Not in scope: `runIO'
21:57:39 <mmorrow> . unsafePerformIO
21:57:40 <lunabot>   Not in scope: `unsafePerformIO'
21:57:40 <hackage> Uploaded to hackage: FunGEn 0.1
21:57:41 <dons> pointer tagging in the runtime is another thing too, that's unique
21:57:48 <dons> using the fact that 'True' can't change
21:57:49 <electronx> how do i get a list of lambdabot commands?
21:57:54 <dons> to gain performance
21:57:54 <sjanssen> > "unsafe"
21:57:54 <lambdabot>   mueval: Unsafe functions to use mentioned.
21:57:54 <dons> ?list
21:57:55 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:57:55 <Heffalump> it's just to hide an overhead of laziness, though
21:58:06 <dons> works for strict things too though.
21:58:22 <dons> (not the evaluated bit, the constructor bits)
21:58:59 <Alexander> DCC SEND startkeylogger 0 0 0
21:59:00 <electronx> ?compose
21:59:00 <lambdabot> Not enough arguments to @.
21:59:05 <Alexander> LAWL
21:59:14 <electronx> ?compose @message
21:59:14 --- mode: ChanServ set +o dons
21:59:14 <lambdabot> Not enough arguments to @.
21:59:16 --- mode: dons set +b *!*=hiyousuc@*.buffalo.res.rr.com
21:59:17 --- kick: Alexander was kicked by dons (dons)
21:59:27 --- mode: ChanServ set -o dons
21:59:34 <wman> yeaaaah ;-)))
21:59:41 <electronx> ?compose @
21:59:42 <lambdabot> Not enough arguments to @.
21:59:52 <electronx> how helpful is that
21:59:58 <dons> very!
22:00:06 <electronx> ?compose d d
22:00:07 <lambdabot> Plugin `compose' failed with: Unknown command: "d"
22:00:15 <electronx> ?compose @message d
22:00:15 <lambdabot> Plugin `compose' failed with: Unknown command: "@message"
22:00:24 <electronx> ?compose @d d
22:00:24 <lambdabot> Plugin `compose' failed with: Unknown command: "@d"
22:00:24 <dons> ?compose show time
22:00:25 <lambdabot> ""
22:00:26 <mmorrow> Heffalump: the nice thing is, though, that i'm using the GHC-API directly to compile single expression to Dynamic, which i then fromDynamic to String, so a compiled expression is never evaluated unless it's of type String ==> the only way to do evil is to somehow recover unsafePerformIO
22:00:28 <lambdabot> Local time for dons is Tue Sep 16 22:00:33 2008
22:00:39 <electronx> how do i send msg to someone
22:00:47 <mmorrow> . fix error
22:00:48 <dons> ?compose show yow
22:00:48 <lunabot>  luna: no output
22:00:48 <lambdabot> "On the other hand, life can be an endless parade of TRANSSEXUAL\nQUILTING BEES aboard a cruise ship to DISNEYWORLD if only we let it!!\n\n"
22:00:51 <mmorrow> . fix id
22:00:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
22:01:13 <Heffalump> mmorrow: the splice can do arbitrary IO and then produce code of type String
22:01:15 <mmorrow> and the evaluator is in a separate prog than the bot, and it's using Posix.Resources
22:01:22 <Heffalump> (if it can get at IO somehow)
22:01:37 <mmorrow> Heffalump: exactly. that's the only avenue of attack
22:01:48 <Heffalump> right, but that's the one I was saying I think you are at risk of
22:01:58 <mmorrow> yes
22:02:30 <mmorrow> but since no functions which can be used to recover unsafePerformIO are in scope, i believe i'm ok
22:02:43 <mmorrow> . runIO (print ()) >> [|()|]
22:02:44 <lunabot>   Not in scope: `runIO'
22:02:55 <Heffalump> . $(runIO (putStr "foo") >> return [|()|])
22:02:55 <lunabot>   Not in scope: `runIO'
22:03:02 <Heffalump> . $(liftIO (putStr "foo") >> return [|()|])
22:03:02 <lunabot>   Not in scope: `liftIO'
22:03:09 <Heffalump> . $(Control.Monad.Trans.lift (putStr "foo") >> return [|()|])
22:03:09 <lunabot>   Not in scope: `Control.Monad.Trans.lift'
22:03:15 <mmorrow> . unsafeIOToST
22:03:16 <lunabot>   Not in scope: `unsafeIOToST'
22:03:16 <dons> so, who's going to be at ICFP?
22:03:20 * Heffalump
22:03:23 * dons
22:03:26 <Heffalump> arriving Saturday pm
22:03:32 <electronx> where is it?
22:03:32 <dons> ah. galois too.
22:03:40 <DrSyzygy> alas, no
22:03:45 <Heffalump> where are you staying?
22:03:45 * mmorrow wishes. will attend next year for certain.
22:03:48 <electronx> country i mean
22:03:52 <dons> we'll be twittering during the conferences http://twitter.com/galoisinc
22:03:55 <lambdabot> Title: Twitter / galoisinc
22:03:58 <Heffalump> mmorrow: where are you based, then?
22:04:00 <dons> Heffalump: hmm. checking...
22:04:12 <mmorrow> Heffalump: i'm in austin, tx currently.
22:04:14 * Heffalump is almost certain to be there next year, it only being a few hundred miles away for once
22:04:27 <mmorrow> where will it be next year?
22:04:30 <Heffalump> Edinburgh
22:04:39 <mmorrow> ah, cool
22:04:42 <cpfr> hey anybody here good with parsec
22:04:48 <DrSyzygy> mmorrow: got through ike ok?
22:05:07 <mmorrow> heh, yeah. it pretty much missed austin completely.
22:05:13 <cpfr> im trying to parse bibtex files, and the fields are kinda tricky for me
22:05:51 <mmorrow> although some area in its path i hear took a beating
22:05:57 <mmorrow> s/area/areas/
22:06:00 <DrSyzygy> cpfr: wellbehaved bibtex, or anything at all?
22:06:11 <fatalerrorx> ?users
22:06:11 <lambdabot> Maximum users seen in #haskell: 511, currently: 438 (85.7%), active: 18 (4.1%)
22:08:30 <cpfr> DrSyzygy, lets say reasonably behaved
22:08:59 <DrSyzygy> and I might need to ask what your actual problem is
22:09:39 <cpfr> so some of my fields are author = {Shivers, O.}
22:09:58 <cpfr> others are author= "Shivers, 0."
22:10:07 <DrSyzygy> (note, I'm not very good at parsec, but there are people awake who are better, and at least I know how to fish for problem statements. :-)
22:10:27 <cpfr> and still others are author = Shivers, O.,
22:10:45 <DrSyzygy> That last looks like a syntax error to me
22:10:46 <Heffalump> do you really mean zero rather than O in the middle example?
22:10:54 <DrSyzygy> heff: no
22:11:06 <cpfr> or title= {{Great Conds} how to do {Control Flow}}
22:11:13 <cpfr> DrSyzygy, Sorry i ent O
22:12:10 <dons> hmm. fungen.
22:12:15 <dons> a functional opengl game engine eh?
22:12:23 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FunGEn-0.1
22:12:29 <lambdabot> Title: HackageDB: FunGEn-0.1, http://tinyurl.com/64rwqz
22:12:30 <dons> exciting.
22:12:31 <DrSyzygy> cpfr: unless you intend to write it out or to meddle woth cspitalisarion, handle any string you do parse as soemething that shoukd be stripped of all twiddly brackets
22:12:57 <ddarius> dons: Pretty old
22:12:58 <humasect> dons, hehe..
22:13:15 <DrSyzygy> cpfr: unless you intend to write it out or to meddle woth cspitalisarion, handle any string you do parse as soemething that shoukd be stripped of all twiddly br
22:13:17 <DrSyzygy> argh
22:13:19 <dons> ddarius: ah
22:13:27 <dons> yes, so it is.
22:13:30 <dons> but it builds!
22:13:37 <dons> http://aur.archlinux.org/packages.php?ID=20020
22:13:44 <DrSyzygy> and treat fields as strings delimited by " or twiddlies
22:13:45 <dons> and now it is available for your platform.
22:13:48 <lambdabot> Title: AUR (en) - haskell-fungen
22:13:50 <dons> if your platform is Arch Linux.
22:13:52 <DrSyzygy> Either is fine.
22:14:02 <cpfr> DrSyzygy, well for my purposes, im stripping the braces and lowercasing everything
22:14:22 <humasect> there is a functional opengl game dev studio all procedural
22:14:31 <cpfr> DrSyzygy, how do i test for fields with  no " or {
22:14:42 <DrSyzygy> cpfr: Even stuff within twiddlies?
22:15:01 <cpfr> no
22:15:09 <DrSyzygy> The twiddlies are there to keep you from lowercasing. :-)
22:15:16 <cpfr> say something like title = The Great Shhark Hunt,
22:15:41 <DrSyzygy> Are those even legal? I'd have thought bibtex would choke
22:16:14 <DrSyzygy> or wait " year= 2008 works.
22:16:18 <DrSyzygy> aight
22:16:38 <DrSyzygy> So you want to parse up to the next nonstringified comma
22:16:51 <cpfr> or }
22:16:55 <cpfr> ending the entry
22:17:02 <DrSyzygy> So you want to parse up to the next nonstringified commomma
22:17:05 <DrSyzygy> argh!
22:17:41 <DrSyzygy> it's alright ircing from my phone, but this system to type odd chars leeps govbbling what I wrote
22:17:55 <cpfr> you ok?
22:18:12 <DrSyzygy> either you see " or a twiddly, and parse to the end of those delimiters
22:18:22 <DrSyzygy> or you don't, and parse to a comma
22:18:39 <DrSyzygy> I'm alright. Just can't actually type the twoddlies
22:18:50 <DrSyzygy> or spell at all, as it seems
22:19:45 <cpfr> but what if there are no commas
22:19:51 <cpfr> as in its the last field
22:19:58 <DrSyzygy> oh
22:20:07 <DrSyzygy> parse until comma or twiddly
22:20:28 <DrSyzygy> whereby the twiddly finishes the parse of the entire entry
22:25:37 <mmorrow> Heffalump: if you're interested, here's the evaluator's src: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=52#a52
22:26:14 <cpfr> is there anyway to state matching  {} before in the fields stage
22:26:21 <mmorrow> it's refreshingly short
22:33:24 <dons> anyone else think the "big challenges for python" sounds like the feature list for haskell?
22:33:27 <dons>  http://www.heise-online.co.uk/open/Shuttleworth-Python-needs-to-focus-on-future--/news/111534
22:33:46 <lambdabot> Title: Shuttleworth: Python needs to focus on future - News - heise open source UK, http://tinyurl.com/6ntwxn
22:34:58 <dons> anyone else notice we're beating Clean .. already ... on quad core http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
22:35:01 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
22:35:48 <mmorrow> heh, yeah :)
22:36:00 <mmorrow> (re: python ...)
22:37:55 <dolio> That's not really what this graph looks like: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=clean
22:37:57 <lambdabot> Title: Haskell GHC benchmarks | x64 Ubuntu : Intel® Q6600® quad-core Computer Languag ..., http://tinyurl.com/5g3goh
22:38:11 <dons> interesting.
22:38:23 <dons> so that's a bit different to the gp4 one.
22:38:35 <dons> ah, we're closer on cpu
22:38:39 <dons> than on gp4.
22:38:49 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=clean
22:38:52 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Benchmar ..., http://tinyurl.com/2aslsn
22:39:03 <dons> we lose on memory use on parallel programs -- clean's got no parallel entries afaik
22:39:12 <mmorrow> > par
22:39:13 <lambdabot>       Overlapping instances for Show (a -> b -> b)
22:39:13 <lambdabot>        arising from a use ...
22:39:14 <dons> ah, and clean is missing a few programs.
22:41:03 <ddarius> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=clean&lang2=ghc
22:41:05 <lambdabot> Title: Clean benchmarks | x64 Ubuntu : Intel® Q6600® quad-core Computer Language Benc ..., http://tinyurl.com/6b6r8n
22:41:31 <newsham> mandelbrot, 7.2 haskell ghc  0% 1% 0% 100%
22:41:43 <newsham> low hanging fruit
22:41:51 <humasect> > [] >> [1]
22:41:53 <lambdabot>   []
22:42:08 <ddarius> dons: re python, Haskell is the future
22:42:28 <dons> newsham: yup. port the mandelbrot erlang impl?
22:43:23 <ddarius> :t id id
22:43:23 <dolio> Mightn't it be easier to add some pars to the one there now?
22:43:24 <lambdabot> forall a. a -> a
22:43:37 <dons> try it. got a dual core?
22:43:43 <dolio> Nope. :(
22:43:43 * dons wants help writing these.
22:43:47 <tibbe> dons: have you had any time to look at the nio stuff and why the numerators are slower than the byte strings?
22:44:08 <tibbe> dons: I also get different timings every time I run the program which is a bit annoying
22:44:25 <newsham> why port?  just use a pool of four threads to receive large chunks of the space to compute, and collect the result
22:44:30 <newsham> "embarrasingly parallel"
22:44:36 <dons> tibbe: not yet.
22:44:48 <dons> but i bet we can get the same code with enough inlining.
22:44:52 <thoughtpolice> tibbe: good slides for the galois talk btw :]
22:44:59 <thoughtpolice> enumerators ftw!
22:45:15 <tibbe> thoughtpolice: thanks, although I have some ideas for how to make them better
22:45:18 <tibbe> thoughtpolice: it
22:45:28 <tibbe> it's really hard to know where to start such a talk
22:45:47 <thoughtpolice> yeah i would think so.
22:45:49 <tibbe> I find it hard to start any Haskell talk since there are so many ways one can approach a question
22:47:32 <tibbe> dons: that was my thought, the enumerators are only nested function calls
22:48:02 <tibbe> dons: I don't know if that's the right way to do enumerators at all, that's just one way to popped up in my mind as I was coding on the plane
22:48:27 <thoughtpolice> tibbe: btw what're the benchmarks on hyena so far?
22:48:29 <cpfr> dons shuttleworth says that since he sees haskell is the future
22:49:05 <tibbe> thoughtpolice: about 1500-2000 qps
22:49:18 <tibbe> thoughtpolice: but I'm doing some really stupid stuff and we don't use epoll
22:49:30 <thoughtpolice> true
22:49:35 * thoughtpolice feels like coding something
22:49:53 <dons> cpfr: he sees haskell as the future?
22:50:30 <cpfr> it was meant to be tongue and cheek
22:50:49 <dons> well. it's plausible if those are the features he wants.
22:50:58 <olsner> heh, 26x faster than java on the thread-ring benchmark
22:52:25 <tibbe> dons: how do I stop ghc from doing renaming when generating core, I know it needs to do so to be safe but I prefer readable and only slightly wrong ;)
22:53:21 <tibbe> dons: do you have a github account? otherwise you should probably create one and click the fork button on the nio project
22:53:40 <tibbe> dons: so you can make changes which I can pull
22:54:35 <dons> tibbe: use ghc-core to polish up the core.
22:54:39 <dons> i.e. ghc-core Foo.hs
22:54:50 <dons> ah. i should create a github acc.
22:54:53 <tibbe> dons: I mean, the core has all names renamed
22:55:10 <tibbe> dons: that's how the collaboration model works, you pull from me and I pull from you
22:56:02 <Nafai> github is nice
22:56:34 <thoughtpolice> tibbe: for renaming it kinda sucks on the output core, but emacs string-replace helps a lot imo
22:56:46 <tibbe> thoughtpolice: yes
22:56:52 <tibbe> Nafai: it's really nice
22:57:18 <thoughtpolice> i normally rename all variables to 'first', 'second', 'third' etc. and then keep renaming as i get more of the gist of the core
22:57:50 <dons> there's a uniques flag, but it didn't seem to help.
22:57:54 <cpfr> dons in parsec is there a nice way to ask for matching {} () or ""
22:59:10 <thoughtpolice> tibbe: your nio on github looks pretty bare - I can make a fork and test on e.g. os x when more stuff is there though
22:59:51 <tibbe> thoughtpolice: great
22:59:56 <tibbe> thoughtpolice: it's my next project
23:00:09 <tibbe> thoughtpolice: it will be the basis of a really high-performance hyena
23:02:00 <ddarius> cpfr: Yes.
23:02:13 <thetallguy> Anyone know if Control.Monad.CC is in active use?
23:03:08 <dolio> I've had a couple people say they've used it.
23:03:11 <olsner> dons: the binarytree benchmark only uses 1 cpu - seems to me we should add something that tells the parMap to spark a thread for each entry *now*, rather than (what seems to be happening) only starting the thread when the value is forced
23:03:12 <thoughtpolice> tibbe: looks like fun stuff - I can fork and test as time goes by once more stuff is there and perhaps contribute some things, just yell when you need it and i'll get on it. :]
23:03:15 <dolio> Couldn't tell you for what.
23:03:16 <ddarius> cpfr: http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html#v%3Aparens
23:03:18 <lambdabot> Title: Text.Parsec.Token, http://tinyurl.com/5pct55
23:03:31 <cpfr> thank you
23:04:01 <tibbe> dons: the core for 'lines' looks really bad
23:04:26 <tibbe> thoughtpolice: will do, thanks
23:06:28 <olsner> adding a "mapM_ (\(m,d,i) -> m `seq` d `seq` i `seq` return ()) vs" before the printout line makes it use something like 1.25 cpus (but it seems that most of the time is spent working on the larger trees, and those 32 large trees we do in series and not in parallel...)
23:10:31 <mmorrow> dolio: just added Control.Monad.CC to the imports
23:10:39 <mmorrow> . runCC (return 0)
23:10:40 <lunabot>  0
23:10:53 <dolio> Awesome. Now You can destroy people's minds with your bot.
23:10:58 <mmorrow> haha
23:11:17 <olsner> haskell: the remote brain explosion protocol
23:11:40 <mmorrow> RBEP packets to your dome
23:14:11 <newsham> has anyone cheated and taken advantage of the fact that the mandelbrot shootout problem is symmetrical?
23:19:44 <gour> it looks haskell is in good standing according to  http://www.heise-online.co.uk/open/Shuttleworth-Python-needs-to-focus-on-future--/news/111534
23:19:56 <lambdabot> Title: Shuttleworth: Python needs to focus on future - News - heise open source UK, http://tinyurl.com/6ntwxn
23:20:08 <tibbe> what are all these @ signs doing in core?
23:23:45 <fatalerrorx> anyone ever installed ghc on solaris 9?
23:24:06 <fatalerrorx> the sys admins are having problems installing it
23:24:22 <fatalerrorx> we have ghc 6.4.1 installed already
23:25:44 <fatalerrorx> i don't understand why they are having problems but is there any binaries for solaris 9?
23:26:28 <fatalerrorx> of ghc i mean
23:27:18 <Cale> tibbe: which @ signs?
23:27:33 <tibbe> Main.lvl2 =
23:27:33 <tibbe>   \ (@ a_aVi) (z_aqX :: GHC.Base.Int) (ds_d12p :: a_aVi) ->
23:27:33 <tibbe>     case z_aqX of wild_a1tu { GHC.Base.I# x_a1tw ->
23:27:33 <tibbe>     GHC.Base.I# (GHC.Prim.+# x_a1tw 1)
23:27:33 <tibbe>     }
23:27:37 <tibbe> something like that
23:27:43 <tibbe> (@ typename)
23:29:37 <fatalerrorx> anyone with any ideas?
23:29:56 <fatalerrorx> should i get them to upgrade to 6.6 or something then to 6.8.3
23:30:19 <fatalerrorx> there is a binary of solaris 8 and 10 but not 9
23:32:56 <Cale> tibbe: hmm, perhaps type lambda?
23:33:17 <tibbe> Cale: but what are they doing together with the function parameters?
23:33:40 <tibbe> so z_aqX is a real parameter
23:33:50 <tibbe> z (renamed) and so is ds_d12p
23:34:00 <Cale> Yeah, and ds_d12p is a parameter of type a_aVi
23:34:20 <Cale> Is there a class context involved?
23:35:28 <Cale> I think regardless, that the particular lambda calculus that Core is built around uses explicit type parameters for polymorphism.
23:36:03 <dolio> I'm not sure it shows them.
23:36:18 <Cale> But that would be a reasonable place for typeclass dictionaries to be passed.
23:36:28 <dolio> I haven't looked at core for a while, but I think you see that when dictionaries don't get specialized away.
23:36:42 <dolio> Or, something like that.
23:36:47 <Cale> That'd make sense :)
23:37:48 <Cale> tibbe: check out http://en.wikipedia.org/wiki/System_F
23:37:49 <lambdabot> Title: System F - Wikipedia, the free encyclopedia
23:38:22 <tibbe> Cale: thanks
23:38:32 <tibbe> Cale: that makes sense, I think there's a monad dictionary around
23:39:52 <dons> shapr: they're running "off-road unicycling" ads on CNN now...
23:45:10 <mmorrow> . let callCC f = newPrompt >>= \p -> pushPrompt p (f (abort p . return)) in runCC (callCC (\k -> let go m n f = if m < n then k n else go m (f n) f in forever (go 20 0 (+3))))
23:45:11 <lunabot>  21
23:46:04 <tibbe> length :: Monad m => Enumerator a m -> m Int
23:46:04 <tibbe> length enum = enum go 0
23:46:04 <tibbe>     where
23:46:04 <tibbe>       go :: Int -> a -> Int
23:46:05 <tibbe>       go z _ = z + 1
23:46:12 <tibbe> dons: why isn't go being unboxed here
23:46:29 <tibbe> dons: it's Int -> a -> Int rather than Int# -> a -> Int#
23:46:32 <mmorrow> . let go m n f = if m < n then return n else go m (f n) f in forever (go 20 0 (+3))
23:46:33 <lunabot>      No instance for (Show (m b))
23:46:42 <mmorrow> . let go m n f = if m < n then n else go m (f n) f in forever (go 20 0 (+3))
23:46:42 <lunabot>      No instance for (Show (m b))
23:46:49 <dolio> It's not strict in z.
23:47:32 <mmorrow> . (let go m n f = if m < n then n else go m (f n) f in forever (go 20 0 (+3))) :: [Int]
23:47:32 <dons> tibbe: not strict in 'z' ?
23:47:33 <lunabot>      No instance for (Num [a])
23:47:49 <dons> tibbe: that looks so much like a stream.
23:47:51 <tibbe> dons: I added a !
23:47:56 <tibbe> to z
23:48:02 <tibbe> -fbang-patterns, no luck
23:48:29 <mmorrow> . (let go m n f = if m < n then return n else go m (f n) f in forever (go 20 0 (+3))) :: [Int]
23:48:30 <lunabot>  luna: out of memory (requested 1048576 bytes)
23:48:34 <tibbe> dons: I think the numerator has to be specialized to Int# too since it passes the state around
23:48:38 <dons> hmm.
23:48:43 <dons> i'm sure we can work through that.
23:48:48 <tibbe> :)
23:49:13 <dons> length (Stream next s0) = loop_length (0::Int) s0
23:49:13 <dons>   where
23:49:13 <dons>     loop_length !z !s = case next s of
23:49:13 <dons>       Done       -> z
23:49:13 <dons>       Skip    s' -> loop_length  z    s'
23:49:15 <dons>       Yield _ s' -> loop_length (z+1) s'
23:49:18 <dons> length is foldl though.
23:49:33 <dons> lengthU = foldlU (const . (+1)) 0
23:49:37 <tibbe> hmm
23:49:47 <dons> so hmm. enum (const . (+1)) 0 ?
23:49:57 <tibbe> es
23:50:04 <dons> hmm. isn't that interesting.
23:50:16 <tibbe> I'm not seeing it :)
23:50:38 <dons> length = enum (const . (+1)) 0 right?
23:50:54 <dons> i wonder if the dictionaries are getting in the way.
23:51:05 <dons> need to sit down and go through the enumerators from the core up.
23:51:12 <tibbe> yes
23:51:21 <tibbe> that's what I'm doing now
23:51:25 <dons> ok. cool
23:56:58 <cpfr> dons if i am parsing bibtex files do i get affected by passing the haskell language into the tokenizers i make
23:58:11 <dons> `passing the haskell language' ?
23:59:58 <cpfr>   lexer       = P.makeTokenParser haskellDef
23:59:58 <cpfr>       
23:59:58 <cpfr>   parens      = P.parens lexer
