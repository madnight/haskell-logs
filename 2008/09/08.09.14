00:00:11 <electronx> i read that there is a bug in network lib which kill happs
00:00:16 <electronx> kills*
00:00:22 <mc__> I'm trying to solve a project euler problem. I've already spent hours on optimizing. But I cant figure out what is eating up all the time. My code: http://pastebin.com/m41e26597 the problem: http://projecteuler.net/index.php?section=problems&id=12
00:01:21 <newsham> nub is not cheap.
00:01:34 <electronx> ;t nub
00:01:38 <electronx> :t nub
00:01:39 <lambdabot> forall a. (Eq a) => [a] -> [a]
00:01:40 <mmorrow> electronx: cool. i use fastcgi+stm+hsql/takusen(only takusen with sqlite so far)+xhtml+some js handling code i'm working on
00:01:53 <mmorrow> that combo is killer
00:02:09 <mmorrow> you just have to implement everything yourself ... ;)
00:02:15 <electronx> how is it working out
00:02:29 * Myoma uses neutron
00:02:34 <mc__> well but nub is only called once
00:02:49 <mc__> for each n
00:03:09 <mmorrow> electronx: well. you can do the sessions with stm. there's also various string templating pkgs, but i haven't used them
00:03:14 <mmorrow> Myoma: awesome!
00:03:27 <Myoma> yes :)
00:03:32 <mmorrow> Myoma: i wanna start using that for all kinds of stuff
00:03:52 <electronx> what is neurtrpn?
00:03:59 <electronx> neurtron*
00:04:06 <electronx> lol
00:04:13 <electronx> neutron*
00:04:32 <mmorrow> Myoma: first on my list is to use the ghc-api+neutron+some js to make a ghci-in-a-webbrowser
00:04:47 <mmorrow> electronx: it's a mini webserver i wrote
00:04:51 <mmorrow> super simple
00:04:57 <electronx> fast?
00:04:58 <ivanm> electronx: a neutral subatomic particle normally found in atomic nuclei with roughly the same mass as the proton ;-)
00:05:06 <electronx> :)
00:05:24 <mmorrow> electronx: it is pretty fast, but you should see it to fully understand why
00:05:27 <mmorrow> hold on
00:06:43 <mmorrow> electronx: http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs.html
00:06:43 <lambdabot> Title: Haskell Code by HsColour
00:07:32 <mmorrow> i got 3000+ req/s with http_perf (running on the same machine), but that was serving the fixed response you see there
00:08:04 <electronx> nonportable?
00:08:05 <mmorrow> haskell lightweight threads FTW
00:08:35 <mmorrow> electronx: um, i don't know. it uses posix signals, but that could be easily hacked out i guess
00:08:44 <ddarius> mmorrow: Pathetic. http://www.sics.se/~adam/miniweb/
00:08:47 <lambdabot> Title: Miniweb - TCP/IP stack and web server in 30 bytes
00:08:50 <mmorrow> heh
00:09:08 <mmorrow> ddarius: rad!
00:09:35 * mmorrow gets the code immediately
00:10:07 <P_D> considerably more than 30 bytes of ram
00:10:41 <bd_> 30 bytes of mutable ram, then?
00:10:59 <P_D> makes sense.
00:11:03 <newsham> ram is usually mutable
00:11:10 <newsham> its rom you want to watch out for
00:11:13 <ddarius> As opposed to that immutable RAM...
00:11:17 <dons> mmorrow: neutron should probably be on hackage...
00:11:24 <dons> at least as an educational tool
00:11:25 <bd_> newsham: unless it's holding your .text segment
00:11:42 <newsham> bd_: vmprotect/mprotect
00:11:52 <mmorrow> dons: cool. i'll package it.
00:12:09 <bd_> newsham: I suppose, but then you'd going and redefining it as mutable ram :)
00:12:15 <newsham> just cause *you* cant mutate it....
00:12:51 <bd_> True. Even OTP ROM can be mutated by a well placed quantum event of sufficiently low probability.
00:13:04 <P_D> the terms aren't completely orthogonal
00:13:24 <newsham> ROM can spontaneously reorganize itself as a cpu with low probability
00:13:25 <P_D> I mean
00:13:49 <bd_> All you need is a sufficiently hot cup of tea.
00:14:34 <newsham> or even a boltzman brain
00:16:53 <newsham> my soul needs some delicate tea time.
00:16:55 <newsham> g'nite all
00:20:52 <Adamant> newsham: there was some project that used genetic algorithms to develop applications on FPGA's
00:22:17 <mmorrow> Adamant: are you talking about this paper? http://code.haskell.org/~morrow/papers/evolved-fpga.pdf
00:22:19 <lambdabot> Title: cache:http://code.haskell.org/~morrow/papers/evolved-fpga.pdf - Google Search
00:22:23 <mmorrow> pretty crazy
00:22:42 <Adamant> that's probably the paper
00:22:52 <Adamant> I read about it in a Damn Interesting article
00:22:54 * ddarius has downloaded that paper but not read it.
00:23:17 <P_D> Is that the paper where they don't understand why it works as well as it does?
00:24:05 <mmorrow> it's so bizarre, because he's running an analog signal through the fpga, and it's path is determined by whatever random variations a given chip has
00:24:18 <mmorrow> and it works
00:25:37 <mmorrow> P_D: exactly
00:26:21 <bd_> mmorrow: does it work in another FPGA of the same brand, with an unmodified program?
00:27:05 <mmorrow> that's the crazy part. you go through the evolution process for /each/ chip, and they'd do the same thing in the end, but each one would do it completely differently
00:27:34 <mmorrow> that's probably how our brains are working
00:27:39 <bd_> and copying the design from one to the other doesn't work at all? :)
00:27:56 <trzkril> mc__: your getDivisors ist incorrect
00:28:00 <glguy> bd_: you can't copy portions of the design and move them around either
00:28:05 <glguy> bd_: if that's the thing I read about
00:28:20 <trzkril> mc__: try for example "getDivisors 512"
00:28:24 <mmorrow> bd_: no, because whether or not a particular path works in a given chip depends on the random inconsistencies/etc that chip has
00:28:43 <mc__> *Main> getDivisors 512
00:28:44 <mc__> [1,512,2,4,8,16,32,64,128,256]
00:28:50 <Myoma> mc__: What's the solution?
00:28:50 <trzkril> hm
00:29:08 <trzkril> i tried the one from the past, it gives different results
00:29:13 <mc__> Myoma: I dont have the solution yet
00:29:39 <mc__> I let the program run for hours but it did not give me the solution
00:30:03 <Myoma> mc__:I 've written a program which runs in 5 seconds
00:30:15 <mc__> trzkril: repaste -> http://pastebin.com/m31b2c61a
00:30:22 <mc__> Myoma: nice
00:30:24 <Myoma> mc__: Would you like to see it?
00:30:31 <mc__> nope, not yet
00:30:38 <Myoma> mc__: Would you ever like to see it?
00:30:48 <mc__> yeah
00:31:05 <Myoma> http://hpaste.org/10359
00:32:03 <trzkril> mc__: still gives me [1,512,2,4,8,16]
00:32:35 <trzkril> hmpf
00:32:43 <trzkril> wrong tab, tried the old one again
00:32:56 <mc__> so its working now?
00:33:00 <Myoma> there are various obvious places you could optimize mine if you wanted, but since it works in 5 seconds and 2 mins is the limit I didn't bother
00:33:39 <mc__> Myoma: I'll look at yours as soon as mine is working fast :)
00:37:06 <mc__> well getDivisorsByN seems to take most of the time, what of the things it does is expensive?
00:37:40 <Myoma> mc__: Instead of using makeListsUnique, you should construct unique lists so that nub isn't required
00:40:35 <trzkril> that helps, but not very much
00:41:07 <Myoma> trzkril: my code does this and runs in 5 seconds :P
00:41:34 <trzkril> the main problem is checking every number in [1..n]
00:41:57 <mc__> makeListUnique is only using 14% of the time
00:42:34 <Myoma> mc__: still, this is what you should optimize, it'll have a useful effect on the algorithhm -- the reason is related to what trzkril said
00:54:18 <TommyOnMac> ah, first coffee of the day
00:58:28 * Myoma tea
01:38:04 <Lord_Illidan> Hi, I have a problem with haskell's regular expression implementation
01:38:37 <Lord_Illidan> In python, this  "".join(re.findall('[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]', "aABCeFGHa")) returns e
01:39:00 <Lord_Illidan> In haskell, this  "aABCeFGHl" =~ "[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]" :: String simply retuns the entire regex
01:39:15 <Lord_Illidan> the entire string, sorry - that is  "aABCeFGHl"
01:39:55 <EvilTerran> ?hoogle =|
01:39:55 <lambdabot> No results found
01:39:58 <EvilTerran> ?hoogle =~
01:39:58 <lambdabot> No results found
01:40:03 <EvilTerran> grr, keyboard layouts
01:46:03 <swiert> coq
02:01:15 <Myoma> > [ () | ]
02:01:16 <lambdabot>   mueval: Prelude.read: no parse
02:09:08 <ivanm> is there a way of finding out which directory ghci is using as its root?
02:09:29 <ivanm> there's a :cd command, but no :pwd :s
02:09:59 <trofi> ENV['PWD'] ?
02:12:05 <sjanssen> ivanm: :! pwd should work
02:12:58 <ivanm> thanks sjanssen
02:16:26 <xerox> ?type Directory.getCurrentDirectory
02:16:27 <lambdabot> IO FilePath
02:22:45 <trofi> @src say
02:22:45 <lambdabot> Source not found. You type like i drive.
02:22:54 <trofi> > say "z"
02:22:54 <lambdabot>   mueval: Prelude.read: no parse
02:24:11 <trzkril> @say Hello
02:24:11 <lambdabot> Maybe you meant: faq map slap src
02:26:17 <ziman> > fun "xyz"
02:26:17 <lambdabot>   Add a type signature
02:26:21 <ziman> > fun "xyz" :: Expr
02:26:22 <lambdabot>   xyz
02:28:35 <ertai> Is there conversion function between System.Time* and Data.Time* ?
02:28:42 <ertai> *functions
02:29:51 <harrison> i have a question on 'seq' vs $! . can $! only be sued on the last argument? if the foreced evaluation should be on the first ina  mutliple arg func i have to use seq?
02:29:58 <harrison> http://hpaste.org/10360
02:30:52 <Myoma> @src ($!)
02:30:52 <lambdabot> f $! x = x `seq` f x
02:30:57 <Myoma> does that help?
02:31:13 <Myoma> by the way,  (a+b) `seq` fibo3 (a+b) a (n-1)  is sort of weird
02:31:17 <Myoma> I would write,
02:31:28 <Myoma> let a'plus'b = (a+b) in a'plus'b `seq` fibo3 a'plus'b a (n-1)
02:31:35 <Myoma> because otherwise you are relying on subexpression elimination
02:31:46 <Myoma> of course, using $!
02:32:00 <Myoma> (fibo3 $! (a+b)) a (n-1)
02:32:01 <Myoma> is shorter
02:34:37 <ddarius> harrison: All Haskell functions only take one argument.
02:37:05 <MyCatVerbs> Myoma: also, no subexpression elimination in GHC these days.
02:37:23 <Myoma> MyCatVerbs: Good! :)
02:37:43 <harrison> thanks
02:39:13 <harrison> ddarius: how? i have several funcs which take several
02:39:55 <harrison> myoma: if i want to force evaluation on the second argument but not 1st or 3rd, how would iw rite then?
02:39:56 <harrison> i have to rearrange the function?
02:40:18 <Heffalump> harrison: (f x $! y) z
02:41:48 <Myoma> I wonder if  f $ x $! y $ z  works
02:42:07 <Myoma> :t \ f x y z ->  f $ x $! y $ z
02:42:08 <lambdabot> forall b b1 a b2. (b1 -> b) -> (b2 -> b1) -> (a -> b2) -> a -> b
02:42:22 <Myoma> yeah well you can start with
02:42:30 <Myoma> f x y z = f $ x $ y $ z
02:42:40 <dolio> f $ x $! y $z = f $ (x $! (y $ z))
02:42:43 <Heffalump> except that's wrong..
02:42:52 <Myoma> oh how is it wrong?
02:42:55 <Heffalump> what dolio said
02:43:08 <dolio> Due to the associativity of ($) and ($!) being poorly chosen.
02:43:11 <the_unmaker> I loev myself
02:43:30 <Myoma> oh I totally misunderstood that type
02:43:49 <lilac> > f $ a $! b :: Expr
02:43:50 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
02:44:19 <dolio> > f $ g $! b :: Expr
02:44:20 <lambdabot>   Add a type signature
02:44:34 <dolio> > f $ (g $! b :: Expr)
02:44:35 <lambdabot>   Add a type signature
02:45:01 <lilac> > (f $ a) $! b :: Expr
02:45:02 <lambdabot>   f a b
02:45:03 <dolio> > (f :: Expr -> Expr) $ (g :: Expr -> Expr) $! b
02:45:04 <lambdabot>   f (g b)
02:46:16 <mmorrow> forkOS works nicely to not crash when getting an 'undefined' is possible
02:47:22 <mmorrow> (or i should say, where the possibility of evaluating undefined is unavoidable)
02:52:01 <sjanssen> mmorrow: you should really use forkIO for that
02:52:21 <mmorrow> sjanssen: i tried but it doesn't seem to work like that :(
02:52:38 <sjanssen> mmorrow: hmm?  Were you making C calls?
02:52:48 <mmorrow> i'm writing a ghci clone-ish thing with the ghc api. it's /so/ hackish getting stuff under control.
02:53:38 <mmorrow> so i dynCompileExpr, then evaluate that, but before i do so, i have to temporarily overwrite the FD in the MVar in stderr to catch error output
02:53:55 <mmorrow> then change the FD back to 2 after i've got it
02:54:08 <mmorrow> but undefined would kill my program with forkIO
02:54:35 <sjanssen> the API won't give you errors directly?  Nasty
02:54:35 <the_unmaker> if I have an app that sotres data in memory tables, and have a way to talk among machines, with each mahcine having a list fo machine to whihc it can talk, then I could partition an app.....and run it all from memory for superfast lookups
02:55:07 <mmorrow> sjanssen: totally! i want to look into how to make that better..
02:56:18 <sjanssen> mmorrow: so I wonder what difference forkOS could be making here
02:57:10 <sjanssen> if you're only modifying an MVar, why would bound threads change the behavior?
02:57:17 <harrison> i found a factorial example by a professor that kind of surprised me:
02:57:17 <harrison> http://hpaste.org/10361
02:57:17 <mmorrow> i dunno honestly. but this is interesting (i'll paste)
02:57:21 <harrison> its is the first one
02:57:32 <harrison> why use that instead of the 2nd?
02:58:10 <sjanssen> harrison: no good reason.  In fact n+k bindings are a controversial part of Haskell
02:58:24 <Heffalump> aren't they out of Haskell'?
02:58:42 <sjanssen> maybe, haven't followed it that closely
02:59:18 <harrison> what doesn n+k binding mean?
02:59:21 <sjanssen> harrison: also, the first clauses in each are redundant
02:59:28 <sjanssen> harrison: variable binding + constant
02:59:29 <harrison> true
02:59:34 <sjanssen> eg. (n + 1)
02:59:42 <JesseVentura12> http://digg.com/political_opinion/Petition_to_Draft_Jesse_Ventura_for_President_2012
02:59:42 <mmorrow> sjanssen: http://hpaste.org/10362
03:00:29 <mmorrow> sjanssen: err, the undefined in my case comes from having to evaluate a just-compiled expression that the user inputs
03:00:37 <harrison> ?src product
03:00:37 <lambdabot> product = foldl (*) 1
03:00:49 --- mode: ChanServ set +o sjanssen
03:00:53 <harrison> pfft Data.List.foldl' (*) 1
03:00:54 --- mode: sjanssen set +b *!*=JesseVen@*.160.160.201.cable.dyn.cableonline.com.mx
03:00:54 --- kick: JesseVentura12 was kicked by sjanssen (sjanssen)
03:02:13 <sjanssen> mmorrow: oh, just a normal race condition
03:02:14 <mmorrow> sjanssen: it seems like an undefined takes down the whole runtime in a given osthread
03:02:20 <mmorrow> sjanssen: hmm?
03:02:24 <sjanssen> mmorrow: the whole program exits when the main thread exits
03:02:30 <harrison> why is there a "builtin" product that isnt tailrec?
03:02:47 <sjanssen> forkOS must get scheduler time immediately, or something like that
03:02:56 --- mode: ChanServ set -o sjanssen
03:03:34 <mmorrow> hmm
03:03:44 <sjanssen> @src product
03:03:44 <lambdabot> product = foldl (*) 1
03:03:59 <sjanssen> harrison: product is tail recursive.  Use ghc -O
03:04:14 <sjanssen> also see "Stack overflow" on the wiki
03:04:26 <mmorrow> so are you saying there /is/ a way to protect the prog from exiting upon evaluating undefined with forkIO, or do i have to use forkOS?
03:04:39 <sjanssen> mmorrow: there is, absolutely
03:04:50 <sjanssen> mmorrow: this has absolutely nothing to do with undefined
03:05:04 <Myoma> harrison: why should it be tail recursive?
03:05:36 <mmorrow> sjanssen: hmm, ok. i'm confused slightly then. what method do you suggest?
03:06:05 <sjanssen> mmorrow: or perhaps the executable doesn't exit until all bound threads have completed (main is a bound thread, and forkOS makes them)
03:06:12 <sjanssen> mmorrow: synchronize on an MVar or something
03:06:30 <sjanssen> mmorrow: you need to give the forked thread a chance to do its work
03:06:36 <mmorrow> err, i actually am...
03:06:53 <mmorrow> i'll try something, then if that doesn't work, i'll paste the actual code :)
03:08:42 <harrison> hmm factorial of 1000000 takes forever, maybe it is better to let it raise a stackoverflow, hence the product implementation?
03:08:44 <mmorrow> sjanssen: beautiful. i actually switched some stuff around, and added the mvar sync /and/ the forkOS during one of these changes. it works nicely now :)
03:09:19 <Myoma> harrison: What?
03:09:30 <Myoma> harrison: are even you getting a stack overflow?
03:10:12 <sjanssen> mmorrow: works nicely without forkOS?
03:10:20 <harrison> myoma: i get stackoverflow for product [1..1000000] . when i use a Data.List.foldl' (*) 1 [1..1000000] it just goes on forever
03:10:49 <Myoma> harrison: you know that product _is_ tail recursive, but that's irrelevant to whether or not it stack overflows
03:10:51 <harrison> so maybe better to let it crash when doing huge factorials and raise an error than having it loop forever
03:10:57 <Myoma> harrison: try for example,  product [1..1000000] :: Int
03:11:00 <harrison> or for a very long time
03:11:16 <Myoma> hm actually that overflows too
03:11:24 <mmorrow> sjanssen: yeah. forkIO lives!
03:11:33 * sjanssen whispers ghc -O
03:11:48 <harrison> Stack overflow
03:11:50 <mmorrow> (with judicious use of `finally`s)
03:11:59 <Myoma> harrison: anyway did you see the defintion, as foldl?
03:12:03 <Myoma> @src foldl
03:12:03 <lambdabot> foldl f z []     = z
03:12:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:12:10 <MyCatVerbs> sjanssen: -O2 :)
03:12:15 <MyCatVerbs> sjanssen: MOAR INLINING, PLZ.
03:12:19 <sjanssen> harrison: your program, when compiled with ghc -O still overflows?
03:12:39 <sjanssen> harrison: note that ghci will not optimize no matter which flags you throw at it
03:12:45 <Myoma> harrison: that's tail recursive right? Since haskell is lazy whether something is tail recursive or not doesn't indicate that it runs in constant stack space
03:13:12 <Myoma> harrison: this is different to scheme or ocaml or, what language did you use before?
03:15:59 <the_unmaker> I read erlang doesn't thread but instead uses super small processes
03:16:15 <Myoma> the_unmaker: I read that too
03:16:38 <MyCatVerbs> the_unmaker: Erlang uses processes that're kind-of like CSP threads.
03:16:41 <jpcooper> what's the easiest way to execute a list of IO actions in parallel and collect their results into a list?
03:16:44 <Vq^> the_unmaker: isn't that also a type of threads?
03:16:45 <MyCatVerbs> the_unmaker: er, CSP *processes*, even.
03:16:58 <MyCatVerbs> the_unmaker: IIRC, they're implemented *using* threads, though. :)
03:17:12 <mmorrow> sjanssen: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=38#a38
03:17:21 <harrison> myoma: sure the implementation is tailrec but the language still has top optimize the tailcall. o functional langs i used scheme (and just a little bit of ocaml)
03:17:34 <MyCatVerbs> the_unmaker: you could in theory do it all with OS processes, but the overheads would be phenominal.
03:17:39 <Myoma> harrison: Those rules don't apply to haskell
03:18:21 <sjanssen> harrison: the stack overflow is not coming from the tail call
03:18:38 <MyCatVerbs> @src product
03:18:39 <lambdabot> product = foldl (*) 1
03:18:42 <Cale> Tail recursion optimisation is still important to Haskell though.
03:18:57 <sjanssen> harrison: the stack overflow happens when Haskell attempts to evaluate (1 * (2 * (3 * (4 ...))))
03:18:59 <MyCatVerbs> Yoink. product is tail-recursive, but doesn't run in constant space.
03:19:42 <MyCatVerbs> If it were written with foldl' instead, it *would* run in constant space. The problem is that foldl builds up a huge thunk, whereas foldl' evaluates it at every step.
03:19:45 <Myoma> harrison: the amount of stack space something uses is relative to the depth the lazy evaluator has to go to find data
03:20:29 <Myoma> harrison: So the foldl' crunches down the expression as it iterates over the list, as opposed to foldl which builds a big expression then goes right into it
03:20:55 <sjanssen> mmorrow: instead of fiddling with Handle internals, you could use dup2 instead
03:21:17 <the_unmaker> how fast is fascgi?
03:21:19 <harrison> but foldl' never finishes
03:21:23 <mmorrow> ooh, interesting.
03:21:25 <the_unmaker> better than threaded apache?
03:21:26 <harrison> haskell cant handle huge numbers?
03:21:27 * mmorrow looks into that
03:21:37 <trofi> > 2^1024
03:21:38 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
03:21:39 <sjanssen> harrison: that's because the factorial you're trying to compute is *massive*
03:21:40 <Myoma> harrison: what is the exact expression you are trying to evaluate?
03:21:43 <ddarius> harrison: Do you realize how big 10000000! is?
03:22:21 <trofi> @go stirling approx factorial
03:22:25 <sjanssen> mmorrow: I mean Unix dup2, it's called something else in System.Posix
03:22:27 <lambdabot> http://mathworld.wolfram.com/StirlingsApproximation.html
03:22:27 <lambdabot> Title: Stirling's Approximation -- from Wolfram MathWorld
03:22:28 <Myoma> harrison: ..more to the point, do you know any system which _can_ evaluate it in a few mins?
03:22:36 <mmorrow> sjanssen: cool
03:22:51 <harrison> it is the same as factorial 999999 * 1000000, big deal
03:24:06 <harrison> is that -O or -0 ?
03:24:32 <trofi> -Ox
03:24:34 <Myoma> is what -O or -0?
03:24:35 <Vq^> O as in Optimise
03:24:59 <TommyOnMac> 0ptimize :)
03:25:11 <trofi> @elite optimize
03:25:11 <lambdabot> 0P+imis3
03:25:28 <mmorrow> sjanssen: dupTo
03:25:50 <Vq^> TommyOnMac: isn't it with 's' in glasgow? :o)
03:26:08 <TommyOnMac> probably
03:26:10 * sjanssen notes that Google's calculator refuses to evaluate "1000000!"
03:26:51 <trofi> @go 8!
03:26:53 <lambdabot> 8 ! = 40,320
03:27:14 <sjanssen> @go 100!
03:27:15 <lambdabot> 100 ! = 9.33262154 x 10^157
03:27:17 <sjanssen> @go 1000!
03:27:17 <ulfdoz_> sjanssen: They had no space left to index that large numbers.
03:27:23 <lambdabot> http://www.worth1000.com/
03:27:23 <lambdabot> Title: Worth1000.com | Photoshop Contests | Are you Worthy� | home page
03:27:32 <trofi> [:
03:27:35 <Myoma> harrison: What I said didn't make sense?
03:28:08 <sjanssen> @remember harrison it is the same as factorial 999999 * 1000000, big deal
03:28:08 <lambdabot> It is stored.
03:28:51 <ddarius> > let prod [x] = x; prod (x:y:xs) = prod (x*y:prod xs) in prod [1..1000000]
03:28:52 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
03:28:52 <lambdabot>        Expect...
03:29:46 <huma_> have you guys read "the haskell road to logic"?
03:30:30 <vegai> huma_: I have attempted to, several times
03:30:41 <vegai> the math bores me, unfortunately
03:30:52 <vegai> but it's a good book
03:30:53 <Vq^> i've read a couple of chapters
03:31:06 <vegai> perhaps not so much for learning Haskell, but for learning math
03:31:10 <ivanm> huma_: I have, well, skimmed it anyway
03:31:14 <huma_> isn't haskell about math? :)
03:31:32 <ivanm> huma_: sshhh!!! don't tell vegai that! ;-)
03:31:37 <huma_> ok ok :)
03:31:38 * vegai smirks
03:31:46 <goltrpoat> huma:  ive read it.  loaned it to a friend a while back, haven't gotten it back
03:31:48 <ddarius> > let prod [x] = x; prod xs = prod (prod' xs); prod' [] = 1; prod' [x] = [x]; prod' (x:y:xs) = x*y:prod' xs in prod [1..1000000]
03:31:49 <goltrpoat> i liked it a lot.
03:31:49 <lambdabot>       No instance for (Num [t])
03:31:49 <lambdabot>        arising from a use of `prod' at <inter...
03:32:06 <huma_> goltrpoat, was it vegai? :)
03:32:07 <ddarius> > let prod [x] = x; prod xs = prod (prod' xs); prod' [] = []; prod' [x] = [x]; prod' (x:y:xs) = x*y:prod' xs in prod [1..1000000]
03:32:14 <goltrpoat> haha no
03:32:16 <lambdabot>   826393168833124006237664610317266629113534797896387304516777588556337961103...
03:32:18 <goltrpoat> although, the response was similar
03:32:48 <huma_> yes, it looks quite academic
03:33:19 <harrison> but what is better foldl or foldl' for factorial, having a stack overflow is perhaps better than a program that executes "forever"
03:33:42 <sjanssen> harrison: foldl' is better than foldl
03:33:43 <ddarius> harrison: Use a better algorithm, e.g. the one I used above.
03:33:48 <harrison> my head
03:34:48 <Myoma> harrison: It doesn't go forever, it only takes a trillion years
03:36:20 <ddarius> > let prod [x] = x; prod xs = prod (prod' xs); prod' [] = []; prod' [x] = [x]; prod' (x:y:xs) = x*y:prod' xs in prod [1..5]
03:36:22 <lambdabot>   120
03:38:04 * sjanssen notes that Data.List.sort uses strikingly similar code
03:38:13 <trofi> why it's faster? smaller numbers are multiplied?
03:38:20 <ddarius> trofi: Yes.
03:38:23 <FordCortina> Myoma: i found a case where your type inference trick doesnt work :(
03:38:42 <harrison> any of you good at C? cant long handle factorial fo 100? it returns 0
03:38:55 <ddarius> trofi: Instead of doing half a million multiplies with numbers on the order of sqrt(1000000!), it does only one.
03:39:14 <sjanssen> > compare (product [1 .. 100]) (2^32)
03:39:15 <lambdabot>   GT
03:39:35 <Choko> > compare (product [1 .. 100]) (2^64)
03:39:36 <lambdabot>   GT
03:39:36 <harrison> cool ddarius: its printing :)
03:39:38 <ddarius> harrison: As the google query above revealed, 100! is 10^157 or 2^460 some
03:39:45 <sjanssen> > compare (product [1 .. 100]) (fromIntegral (maxBound :: CULong))
03:39:45 <Myoma> FordCortina: oh cool! what is it?
03:39:46 <lambdabot>       Not in scope: type constructor or class `CULong'
03:39:57 <Myoma> harrison: hehe
03:40:05 <trofi> :t CLong
03:40:06 <lambdabot> Not in scope: data constructor `CLong'
03:40:10 <goltrpoat> hmm, 1000000! contains only 35660 digits.
03:40:18 <harrison> huh?
03:40:21 <FordCortina> Myoma: http://hpaste.org/10363
03:40:36 <goltrpoat> thought it'd be more.
03:40:45 <FordCortina> Myoma: look at the last few lines
03:40:48 <sjanssen> harrison: 100! is far far larger than a C long
03:41:29 <FordCortina> Myoma: the indices I am trying to calculate are the minimum number of chacters accepted by a parser
03:41:31 <goltrpoat> 100! would require 175 bytes.
03:41:53 <vegai> hmm, I have no idea how Data.Binary is supposed to work. Is there anything more helpful than the wiki "tutorial"?
03:41:56 <FordCortina> Myoma: I wonder if I need an "asProdStep" function
03:43:09 <swiert> @seen nominolo
03:43:09 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 3m 23s ago.
03:43:20 <Myoma> FordCortina: so you've got the type  :t asProd (ProdStep (Sat (== 'c')):* Nil)
03:43:25 <Myoma> FordCortina: ooops..
03:43:32 <Myoma> FordCortina: Prod (Suc m)
03:43:45 <Myoma> FordCortina: And you want to calculate the mininmum possible value of (Suc m) ?
03:43:52 <Myoma> which is of course, Suc Zero
03:44:01 <FordCortina> Myoma: im expecting it to return (Suc Zero)
03:44:02 <FordCortina> yes
03:44:05 <lilac> harrison: 100! clearly has at >= 64 factors of 2, so in a 64-bit integer you'll get 0.
03:44:21 <FordCortina> or precisely Prod (Suc Zero)
03:44:23 <Myoma> FordCortina: Oh you actually except it to do that currently? rather than wanting to calculate it from that?
03:44:39 <lilac> afair integer overflow in C multiplication is actually undefined, but...
03:45:09 <Myoma> FordCortina: Prod (Suc m) = Star ProdStep (Suc m) Zero
03:45:13 <goltrpoat> comparison with overflow is undefined, i think
03:45:52 <lilac> > product [1..100] :: Int64
03:45:53 <lambdabot>   0
03:46:04 <FordCortina> Myoma: well all productions should start from Zero
03:46:15 <ddarius> > product [1..1000] :: Double
03:46:17 <lambdabot>   Infinity
03:46:17 <FordCortina> Myoma it should be very similar to lists
03:46:38 <FordCortina> I mean vectors, lists with length
03:46:45 <lilac> ddarius: your algorithm diverges on []
03:46:48 <lilac> :)
03:46:57 <ddarius> lilac: I did not care about that case.
03:47:15 <FordCortina> except i leave the index tranformation in VectorStep open
03:49:00 <harrison> lilac: ok but how do i return the correct nbr in C?
03:49:57 <FordCortina> Myoma: at the bottom of this annotation http://hpaste.org/10363#a1 i give a comparision with Nat
03:50:08 <FordCortina> (indexed Nats that is )
03:52:11 <FordCortina> Ive found it very hard to apply GADTs to the parser problems im trying to solve
03:52:28 <FordCortina> if there is a solution to it, it most definately won't be an intuitive one
03:53:10 <FordCortina> it will be one that's totally framed in whatever ideas are palletable to the compiler heh
03:53:24 <Myoma> FordCortina, mabye you wrote n and m instead of n and n?
03:53:42 <Myoma>     Sat :: (Char -> Bool) -> Sat n (Suc m)
03:53:44 <Myoma> there ?
03:54:17 <FordCortina> hmm
03:54:34 <FordCortina> oops
03:54:38 <FordCortina> that might help!
03:54:40 <FordCortina> :D
03:55:35 <FordCortina> ah that work, well spotted
03:55:38 <FordCortina> thanks
03:55:47 <FordCortina> Myoma
03:56:24 <Myoma> that's cool
04:01:04 <harrison> when compiling, does it have to be main.hs? i cnt copile fac.hs?
04:01:18 <FunctorSalad> ivanm: pong
04:01:20 <Myoma> it can be fac.hs
04:02:05 <ivanm> FunctorSalad: for undirected graphs in graphviz, I think you're meant to use "graph" rather than digraph, and "--" not "->" (and then pass it through neato, as it gives better results)
04:02:20 <ivanm> that's from what my (admittedly minimal) reading has revealed
04:03:08 <FunctorSalad> ivanm: yeah, I just meant that you can make edges in a digraph undirected by the dir=none attribue :)
04:03:26 <ivanm> fair enough
04:03:30 <FunctorSalad> but I'm not sure it's equivalent layout-wise
04:03:40 <ivanm> since you actually seem to know something about graphviz... ;-)
04:04:07 <ivanm> do the labels given by "digraph foo {", etc. actually mean/do anything?
04:04:32 <FunctorSalad> you mean the "foo"? not that I knew of
04:04:54 <FunctorSalad> the actual graph label is in "graph [label=...]"
04:05:22 <ivanm> *nod* that's what I thought
04:05:38 <ivanm> just for readability purposes if you have a lot of graphs in the same file?
04:06:37 <FunctorSalad> hmm for subgraphs it does something; the name has to start with "cluster" if it's supposed to be a cluster
04:07:19 <ivanm> oh? where does it say that?
04:07:39 <ivanm> damn, but graphviz bindings _do_ have to have an instance of Show for the cluster ID :s
04:11:12 <FunctorSalad> ivanm: I don't remember where I read it
04:13:03 <dafra> \pl f l =  (last l, length l)
04:13:07 <MyCatVerbs> harrison: BTW, foldl' (*) 1 [1::Integer..10^6] -- does actually complete. :)
04:13:30 <Olathe> @pl \l -> (last l, length l)
04:13:30 <lambdabot> liftM2 (,) last length
04:13:30 <dafra> @bots
04:13:31 <lambdabot> :)
04:13:51 <MyCatVerbs> harrison: took fourteen minutes, ten seconds on my machine. main = print $ foldl' (*) 1 [(1::Integer)..10^6] -- compiled with GHC -O2.
04:14:38 <the_unmaker> are parsers things that find strings
04:14:44 <the_unmaker> like perl regex stuff?
04:14:45 <MyCatVerbs> harrison: the number outputted is *blinkblink* 5.4 megabytes long. :D
04:15:07 <MyCatVerbs> the_unmaker: kiiiiiinda. Regular expressions are a very very limited form of parser.
04:15:09 <Myoma> the_unmaker: You could think of regex as a really primitive kind of parser
04:15:58 <trofi> :t isInfixOf
04:15:59 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
04:16:04 <MyCatVerbs> the_unmaker: in normal use, parsers turn languages into interesting data structures. Like C code text into a C ADT, for example.
04:16:06 <pmurias> hi
04:16:17 <MyCatVerbs> pmurias: RAWR.
04:16:48 <Olathe> > foldb (*) 1 [(1::Integer)..10^6]
04:16:52 <the_unmaker> so I could find stuff in say apaceh logs with haskell without much trouble
04:16:55 <the_unmaker> apache
04:17:03 <lambdabot>   thread killed
04:17:08 <Olathe> > foldb (*) 1 [(1::Integer)..10^6]
04:17:21 <trofi> :t foldb
04:17:23 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
04:17:23 <lambdabot>   thread killed
04:17:29 <Myoma> > foldb (*) 1 [(1::Integer)..10]
04:17:30 <pmurias> how can i turn [] of SMOP__Object* into a SMOP__Object** in the FFI?
04:17:31 <MyCatVerbs> the_unmaker: yeah. If a regex will do, parsers will be overkill, though. :)
04:17:32 <lambdabot>   3628800
04:17:33 <Olathe> lambdabot can do it in private.
04:17:41 <Olathe> I think the time limit is higher in private.
04:17:57 <the_unmaker> night all
04:18:01 <MyCatVerbs> the_unmaker: sleep well.
04:18:07 <pmurias> i represent SMOP__Object* as Ptr ()
04:18:20 <trofi> @hoogle a -> Ptr a
04:18:21 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
04:18:21 <lambdabot> Prelude id :: a -> a
04:18:21 <lambdabot> Data.Function id :: a -> a
04:18:33 <MyCatVerbs> pmurias: ?. You want a pointer to an array of zero SMOP__Object*s?
04:18:46 <ivanm> FunctorSalad: cluster means that the attributes defined inside it apply to all elements of the subgraph apparently
04:19:28 <igel> afaik there's a discussion going on about the Data.Map "lookup" function (should it return an arbitrary monad or a Maybe?). is there a wiki entry or sth about it? some state of the discussino?
04:19:29 <Saizan> pmurias: look at Foreign.Marshal.Array
04:19:30 <pmurias> MyCatVerbs: i want to make an array out of a list
04:19:51 <MyCatVerbs> pmurias: oh! That's less awkward. I thought you meant making an array out of the *empty* list, heh.
04:20:28 <swiert> Saizan: Will you write something for the Monad.Reader's SoC issue?
04:20:33 <pmurias> thanks, using hoogle instead of hayoo solved the problem
04:21:01 <MyCatVerbs> pmurias: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
04:21:16 <lambdabot> Title: Foreign.Marshal.Array, http://tinyurl.com/6mhaa3
04:22:01 <Saizan> swiert: which was the deadline?
04:22:02 <MyCatVerbs> pmurias: you either want one of the newArray functions, or more likely you actually want one of the withArray functions. withArray and friends are easier to get right with exceptions and rememberin' to free the memory afterwards 'n' stuff. :)
04:22:11 <swiert> Saizan: Last friday :)
04:22:24 <swiert> Saizan: but I won't be able to actually do the editing for a few weeks.
04:22:35 <swiert> Saizan: So you could get an extension...
04:22:57 <pmurias> MyCatVerbs: the terminator in newArray0 is appended after the stuff in the list or is the terminator in the list
04:23:25 <MyCatVerbs> pmurias: it's added to the array. You don't need to put a terminator in the list.
04:23:39 <pmurias> good ;)
04:23:40 <MyCatVerbs> pmurias: the library already knows where the list ends - it can see the [] at the end of it. :)
04:24:32 <MyCatVerbs> Usually you want to use withArray instead, because then you don't have to remember to free it and you don't get a memory leak if something throws an exception.
04:25:07 <MyCatVerbs> Like, withArray0 listOfPointers (\carray -> someFunctionInC carray)
04:28:17 <pmurias> withArray0 is just syntax sugar for withArray and ++?
04:31:45 <mmorrow> igel: it's already been changed to return Maybe in current ghc-HEAD
04:32:04 <igel> hey, that's cool :)
04:32:09 <mmorrow> :)
04:32:22 <MyCatVerbs> pmurias: iono. I think it does something slightly more efficient than that.
04:33:23 <MyCatVerbs> pmurias: no, it does something a bit cleverer. :)
04:34:18 <MyCatVerbs> pmurias: it allocates space for one more thingummy than it needs to, pokes the list elements into the array it's just allocated, then pokes zeroes into the extra space at the end. :)
04:35:16 <pmurias> doesn't it poke the terminator into the one extra space?
04:35:31 <MyCatVerbs> pmurias: er, not even zeroes, sorry, it uses whatever terminator you supply. My bad.
04:35:44 <MyCatVerbs> Jah, oops.
04:47:09 <mohbana> any recommendations for haskell books; we were taught http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/ in one semester, i think we go to Chapter 18
04:47:12 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
04:47:40 <Olathe> mohbana: Real World Haskell will be available in print in November.
04:47:45 <Olathe> mohbana: It's online now.
04:48:52 <Olathe> http://book.realworldhaskell.org/
04:48:59 <lambdabot> Title: Real World Haskell
05:04:15 <maciek> I am trying to implement map in terms of fold. but I have an error which I don't understand
05:04:22 <maciek> Occurs check: cannot construct the infinite type: a = [a]
05:04:37 <maciek> that's the implementation:
05:04:43 <maciek> map'' f xs = fold' (\x y -> [x] ++ [(f y)]) [] xs
05:04:55 <maciek> please don't paste correct code
05:05:23 <papermachine> What's the type of y in that?
05:05:47 <maciek> I think it should be [a]
05:06:13 <papermachine> Isn't f :: a -> a?
05:06:18 <kpreid> maciek: that error usually means that you have a in some places and [a] in others, so when the type inferrer tries to bring those together it concludes that a = [a]
05:06:20 <papermachine> * a -> a -> a
05:06:22 <maciek> yes, you are right
05:06:28 <Myoma> maciek: what is fold' ?
05:06:43 <kpreid> maciek: which is then a = [[[[[[[[[[[[[...a...]]]]]]]]]]]]]], which is disallowed
05:06:46 <maciek> fold' :: (a -> a -> a) -> a -> [a] -> a
05:06:46 <maciek> fold' f i (x:xs) = let res = f i x
05:06:46 <maciek>                    in fold' f res xs
05:06:46 <maciek> fold' _ i [] = i
05:06:58 <Myoma> weird ...
05:07:01 <papermachine> no, it's only a -> a, I'm hallucinating.
05:07:07 <Myoma> @src foldr
05:07:08 <lambdabot> foldr f z []     = z
05:07:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:07:12 <Myoma> this is the usual definition
05:07:26 <Myoma> your one is more like foldl
05:07:30 <dibblego> fold' looks more like foldl
05:07:30 <papermachine> So anyway, if y is type [a], the type inferrer has to unify a and [a], which leads to destruction.
05:07:37 <Myoma> Why don't you use foldr instead?
05:07:47 <Myoma> (it should be easier, at least to start with)
05:07:48 <maciek> I try to reimplement  some functions from Prelude
05:08:06 <dibblego> you've implemented foldl, which is a bit difficult to write map with
05:08:12 <dibblego> instead you want foldr
05:08:18 <kpreid> maciek: the name "occurs check" comes from the topic of unification: unification is unsound (or just nonterminating-if-naively-done? not sure) in the presence of infinite structures, and the 'occurs check' is what you put in your prolog system, or type inferrer, to stop there rather than going wrong
05:08:18 <maciek> with foldr it's easier?
05:08:22 <dibblego> yes
05:08:37 <maciek> kpreid: thanks
05:08:38 <Myoma> maciek: so start with the identity
05:08:49 <Myoma> id x = foldr (:) [] x
05:08:56 <Myoma> > foldr (:) [] [5,6,8,4,3,6]
05:08:57 <lambdabot>   [5,6,8,4,3,6]
05:09:09 <Myoma> then you can expand (:) into (\x ys -> x:ys)
05:09:17 <Myoma> so take it from there? :)
05:09:30 <Deewiant> > reverse $ foldl (flip (:)) [] [5,6,8,4,3,6]
05:09:31 <lambdabot>   [5,6,8,4,3,6]
05:11:01 <dibblego> maciek, [t] ++ y is better written as t : y
05:12:01 <kpreid> @pl \t y -> [t] ++ y
05:12:01 <lambdabot> (:)
05:12:03 <maciek> yes, you are right, it's clearer
05:12:14 <kpreid> @unpl (:)
05:12:14 <lambdabot> (:)
05:12:25 <Olathe> @pl \a b c -> [a, b] ++ c
05:12:25 <lambdabot> ((++) .) . (. return) . (:)
05:12:38 <Olathe> Eww, lambdabot...eww.
05:12:48 <Deewiant> @pl \a b c -> a : b: c
05:12:48 <lambdabot> (. (:)) . (.) . (:)
05:13:30 <Olathe> @pl \c b a -> a : b : c
05:13:30 <lambdabot> (flip (:) .) . flip (:)
05:13:45 <Deewiant> @pl \b c a -> a : b : c
05:13:45 <lambdabot> (flip (:) .) . (:)
05:15:09 <harrison> is there a way to do range(start, stop, step) without revesing the list on the end and not using ++ ? with a doublylinked list you could right?
05:17:39 <Olathe> > let yay start stop step = (takeWhile (<= stop).iterate (+step)) start in yay 1 5 2
05:17:40 <lambdabot>   [1,3,5]
05:18:40 <Olathe> @pl \start stop step = (takeWhile (<= stop).iterate (+step)) start
05:18:41 <lambdabot> (line 1, column 18):
05:18:41 <lambdabot> unexpected "="
05:18:41 <lambdabot> expecting pattern or "->"
05:18:46 <Olathe> @pl \start stop step -> (takeWhile (<= stop).iterate (+step)) start
05:18:46 <lambdabot> flip (flip . (. (iterate . (+))) . (.) . takeWhile . flip (<=))
05:19:06 <mattam> harrison: There's the basic non-tail-recursive way to write it.
05:19:52 <mattam> @src iterate
05:19:52 <lambdabot> iterate f x =  x : iterate f (f x)
05:20:19 <Olathe> @src takeWhile
05:20:19 <lambdabot> takeWhile _ []                 =  []
05:20:19 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
05:20:19 <lambdabot>                    | otherwise =  []
05:22:23 <Olathe> Hmm...
05:22:31 <Olathe> That's not quite right.
05:23:05 <ivanm> Olathe: why isn't it right?
05:23:18 <Olathe> > let yay start stop step = (takeWhile (<= stop).iterate (+step)) start in yay 5 1 (-2)
05:23:19 <lambdabot>   []
05:24:07 <Olathe> > let yay start stop step = (take ((stop - start)`div`step).iterate (+step)) start in yay 5 1 (-2)
05:24:08 <lambdabot>   [5,3]
05:24:25 <Olathe> > let yay start stop step = (take ((stop - start)`div`step).iterate (+step)) start in yay 1 5 2
05:24:27 <lambdabot>   [1,3]
05:24:46 <Olathe> Almost there.
05:26:04 <Olathe> > let yay start stop step = (take ((stop - start + step)`div`step).iterate (+step)) start in yay 5 1 (-2)
05:26:05 <lambdabot>   [5,3,1]
05:26:08 <Olathe> > let yay start stop step = (take ((stop - start + step)`div`step).iterate (+step)) start in yay 1 5 2
05:26:09 <lambdabot>   [1,3,5]
05:26:11 <Olathe> There we go.
05:26:33 <Olathe> > sgn (-1)
05:26:34 <lambdabot>   mueval: Prelude.read: no parse
05:30:06 <LeoD> @src sgn
05:30:06 <lambdabot> Source not found. :(
05:30:12 <LeoD> :(
05:31:14 <Myoma> @src whkgaleou
05:31:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:33:00 <ttt--> > signum (-1)
05:33:01 <lambdabot>   -1
05:33:02 <Olathe> > let yay start stop step = enumFromThenTo start (start+step) stop in yay 1 5 2
05:33:03 <lambdabot>   [1,3,5]
05:33:15 <Olathe> Ahh, thanks.
05:34:09 <Olathe> @index signum
05:34:10 <lambdabot> Prelude
05:38:29 <maciek> foldl gives the same result as foldr for (+) 0 [1..5]. What parameters are the best when I want to know if I wrote foldr or foldl? I mean, for which parameters foldl gives another result than foldr?
05:39:47 <Myoma> maciek: did you get the map ?
05:39:54 <maciek> yes
05:40:04 <maciek> map'' f xs = foldr' (\x y -> (f x) : y) [] xs
05:40:13 <Myoma> cool
05:40:19 <maciek> I had broken folds. Both.
05:40:21 <Myoma> you don't have to put ''s everwhere by the way
05:40:24 <Myoma> just go
05:40:32 <Myoma> import Prelude hiding (map,foldr)
05:40:37 <Myoma> at the start of your file
05:40:46 <maciek> nice
05:41:03 <Olathe> import Prelude hiding ((:),(++))
05:41:49 <mc__> maciek: for infinite lists
05:41:49 <mc__> foldr is generally faster but it will never return on an infinite list
05:41:50 <maciek> (:) is not a primitive?
05:41:58 <Olathe> @index (:)
05:41:59 <lambdabot> bzzt
05:42:02 <Olathe> I guess it is.
05:42:08 <Olathe> @index (++)
05:42:09 <lambdabot> Data.List, Prelude
05:42:12 <kpreid> > foldr f [x,y,z]
05:42:13 <lambdabot>       Overlapping instances for Show ([a] -> [Expr])
05:42:13 <lambdabot>        arising from a us...
05:42:19 <kpreid> > foldr f [x,y,z] :: Expr
05:42:20 <lambdabot>   Couldn't match expected type `Expr'
05:42:21 <maciek> so why I shold hide (:) and (++)?
05:42:28 <Olathe> maciek: You shouldn't.
05:42:40 <vixey> (:) is a constructor
05:45:24 <maciek> import Prelude hiding ((:),(++)) ---- what is it for?
05:47:38 <mc__> @hoogle truncate
05:47:38 <lambdabot> Prelude truncate :: (RealFrac a, Integral b) => a -> b
05:47:38 <lambdabot> System.Posix.Internals c_ftruncate :: CInt -> COff -> IO CInt
05:54:47 <vixey> when is 6.10 out?
05:59:15 <trofi> 2006 10 ?
06:01:52 <idnar> haha
06:03:42 <mmorrow> i just finished a first go at a haskell eval bot. try to break it!
06:03:47 <mmorrow> (it'll join in a sec)
06:04:08 <Olathe> OK :)
06:04:22 <mmorrow> ] fix id
06:04:23 <lunabot>  luna: out of memory (requested 2097152 bytes)
06:04:27 <mmorrow> ] fix error
06:04:28 <lunabot>  luna: no output
06:04:30 <mmorrow> ] fix show
06:04:30 <Olathe> OK, we broke it :)
06:04:31 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\...
06:04:36 <mmorrow> ] [0..]
06:04:37 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
06:04:48 <mmorrow> that isn't breaking it :)
06:05:02 <mmorrow> (it
06:05:04 <Olathe> ] let ffib :: Int -> Integer; ffib n = snd . foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k $!chr(124) k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p $!chr(124) p = (f*(f+2*g), ss) $!chr(124) otherwise = (ss, g*(2*f-g)) where ss = f*f+g*g in ffib 1000000
06:05:04 <lunabot>  <interactive>:1:157: parse error on input `<-'
06:05:08 <mmorrow> heh
06:05:11 <trofi> ] writeFile "a" "b"
06:05:12 <lunabot>  <interactive>:1:43:    No instance for (Show (IO ()))
06:05:25 <trofi> ] unsafePerformIO(writeFile "a" "b")
06:05:25 <lunabot>  <interactive>:1:50: Not in scope: `unsafePerformIO'
06:05:34 <Olathe> let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs))
06:05:39 <trofi> ] System.IO.Unsafe.unsafePerformIO(writeFile "a" "b")
06:05:39 <lunabot>  <interactive>:1:50:    Not in scope: `System.IO.Unsafe.unsafePerform...
06:05:49 <Olathe> ] let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in foldb (*) 1 [1..1000000]
06:05:50 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:05:55 <Olathe> ] let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in foldb (*) 1 [1..100]
06:05:56 <lunabot>  93326215443944152681699238856266700490715968264381621468592963895217...
06:06:00 <mmorrow> i might have to adjust the mem limit
06:06:00 <Olathe> > let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in foldb (*) 1 [1..100]
06:06:01 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
06:06:03 <mmorrow> i just took a guess
06:06:37 <trofi> > foldl' [0,0..]
06:06:38 <lambdabot>   Couldn't match expected type `a -> b -> a'
06:06:40 <trofi> ] foldl' [0,0..]
06:06:40 <lunabot>  <interactive>:1:57:    Couldn't match expected type `a -> b -> a'
06:06:46 <trofi> ] foldl' (+) 0 [0,0..]
06:06:47 <lunabot>  /bin/sh: line 1: 21161 Killed                  ./luna 2>&1
06:06:58 <mmorrow> uhoh
06:07:08 <mmorrow> oh, it's ok :)
06:07:17 <trofi> ] foldl' (+) 0 [0,1..]
06:07:18 <lunabot>  /bin/sh: line 1: 21186 Killed                  ./luna 2>&1
06:07:29 <trofi> ] foldl' (+) 0 [0,1..10^9]
06:07:31 <lunabot>  /bin/sh: line 1: 21199 Killed                  ./luna 2>&1
06:07:59 <mmorrow> ] [0,1..10^9]
06:07:59 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
06:08:14 <trofi> ] tail [0,1..10^9]
06:08:15 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
06:08:19 <Olathe> ] iterate (+2) 1
06:08:19 <lunabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,...
06:08:21 <trofi> ] last [0,1..10^9]
06:08:23 <lunabot>  /bin/sh: line 1: 21255 Killed                  ./luna 2>&1
06:08:36 <LeoD> huh
06:08:37 <Olathe> ] Data.List.foldl' (+) 0 [1..10]
06:08:38 <lunabot>  55
06:08:39 <trofi> ] error "a"
06:08:40 <lunabot>  luna: a
06:08:44 <mmorrow> gotta catch that and replace it with a better error msg
06:08:46 <trofi> ] error "\n"
06:08:47 <lunabot>  luna:
06:08:49 <Olathe> ] fun "Test" :: Expr
06:08:50 <lunabot>  <interactive>:1:50: Not in scope: `fun'<interactive>:1:64: Not in sc...
06:08:52 <trofi> ] error "a\na\n"
06:08:53 <lunabot>  luna: aa
06:09:00 <Olathe> @index fun
06:09:00 <lambdabot> bzzt
06:09:00 <mmorrow> ] error
06:09:01 <lunabot>  <interactive>:1:43:    No instance for (Show ([Char] -> t))
06:09:07 <mmorrow> ] error "\b\b\n\n\a\a5"
06:09:08 <lunabot>  luna: 5
06:09:14 <trofi> ] fix error
06:09:14 <lunabot>  luna: no output
06:09:53 <trofi> ] undefined
06:09:54 <lunabot>  luna: Prelude.undefined
06:10:04 <trofi> ] Prelude.undefined
06:10:04 <lunabot>  luna: Prelude.undefined
06:10:10 <mmorrow> lunabot is t3h l33t!!@
06:10:17 <LeoD> ] :t undefined
06:10:17 <lunabot>  <interactive>:1:51: Not in scope: `t'
06:10:28 <marcot> Good morning.  I'm trying to readChar inside a forkIO, but it's not working.  The code is very simples:
06:10:28 <mmorrow> limited features at the moment
06:10:36 <trofi> ] :m + System.IO
06:10:37 <lunabot>  <interactive>:1:51: Not in scope: `m'<interactive>:1:55: Not in scop...
06:10:44 <Olathe> > data Say = Say [Char]; Say implements Show; show (Say a) = a; Say "test"
06:10:45 <lambdabot>   mueval: Prelude.read: no parse
06:10:47 <vixey> cooll!
06:10:48 <Olathe> How do I get that to work ?
06:11:06 <vixey> ]
06:11:06 <lunabot>  luna: <stdin>: hGetLine: end of file
06:11:11 <vixey> ] ()
06:11:11 <marcot> getChar actually.
06:11:12 <lunabot>  ()
06:11:12 <mmorrow> Olathe: i wish i knew, but i'm trying to figure out :)
06:11:14 <Olathe> ] :info signum
06:11:14 <lunabot>  <interactive>:1:51: Not in scope: `info'
06:11:17 <marcot> http://hpaste.org/10365
06:11:20 <vixey> ] (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:11:20 <lunabot>  <interactive>:1:43:    No instance for (Show
06:11:26 <trofi> instance Show Say ?
06:11:27 <vixey> ] unsafePerformIOOO
06:11:27 <lunabot>  <interactive>:1:50: Not in scope: `unsafePerformIOOO'
06:11:29 <vixey> ] unsafePerformIO
06:11:29 <lunabot>  <interactive>:1:50: Not in scope: `unsafePerformIO'
06:11:31 <Olathe> mmorrow: Is that syntactically correct ?
06:11:40 <vixey> ] let x = 3 in x
06:11:41 <lunabot>  3
06:11:42 <mmorrow> Olathe: which?
06:11:48 <vixey> ] last [1..]
06:11:49 <mmorrow>  data Say = Say [Char]; Say implements Show; show (Say a) = a; Say "test"
06:11:49 <lunabot>  /bin/sh: line 1: 21490 Killed                  ./luna 2>&1
06:11:51 <Olathe> > data Say = Say [Char]; instance Show Say; show (Say a) = a; Say "test"
06:11:51 <vixey> ] reverse [1..]
06:11:52 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:11:52 <lambdabot>   mueval: Prelude.read: no parse
06:11:57 <vixey> ] last [1..]
06:11:58 <lunabot>  /bin/sh: line 1: 21509 Killed                  ./luna 2>&1
06:12:00 <Olathe> mmorrow: That.
06:12:04 <vixey> OO___OO
06:12:06 <Olathe> trofi: Thanks :)
06:12:07 <marcot> Ok, I putMVar should be inside forkIO.
06:12:19 <mmorrow> err, you can't currently define data interactively
06:12:24 <Olathe> Bah.
06:12:44 <mmorrow> marcot: yeah, you have to return it from inside the forkIO with a Chan or MVar or something
06:12:54 <Olathe> @let data Say = Say [Char]; instance Show Say; show (Say a) = a
06:12:54 <vixey> ] forkIOOO
06:12:54 <lambdabot>  Invalid declaration
06:12:55 <lunabot>  <interactive>:1:50: Not in scope: `forkIOOO'
06:12:55 <vixey> OO___
06:12:59 <trofi> instance Show Say where show (Say a) = a
06:13:04 <Olathe> I'll invalid declaration YOU !
06:13:07 <mmorrow> Olathe: i know, that would be so awesome.
06:13:10 <Olathe> @let data Say = Say [Char]; instance Show Say where show (Say a) = a
06:13:10 <lambdabot>  Invalid declaration
06:13:36 <trofi> @lat can declare data?
06:13:36 <lambdabot>   Parse error
06:13:41 <ivanm> if I have a list of (Ord a) => [Maybe a] and I sort it, can I guarantee that all the Nothing values will be first? (as in, is that the definition of compare for Maybe values?)
06:13:41 <Olathe> No, it can't.
06:13:44 <Olathe> @let data
06:13:44 <lambdabot>   Parse error
06:13:52 <Olathe> @let data Say = Say [Char]
06:13:52 <lambdabot>  Invalid declaration
06:13:55 <trofi> @let it = id
06:14:08 <lambdabot>  Defined.
06:14:21 <trofi> @let be = "Defined"
06:14:22 <vixey> ] forkIO
06:14:22 <lunabot>  <interactive>:1:50: Not in scope: `forkIO'
06:14:24 <lambdabot>  Defined.
06:14:28 <vixey> ] unsafeCoerce
06:14:29 <lunabot>  <interactive>:1:50: Not in scope: `unsafeCoerce'
06:14:43 <vixey> ] let x = x in x
06:14:44 <lunabot>  luna: out of memory (requested 2097152 bytes)
06:14:51 <mmorrow> she'll be right back
06:14:51 <vixey> that shouldn't use lots of memory ...
06:15:16 <Olathe> > let x = x in x
06:15:31 <lambdabot>   thread killed
06:15:39 <mmorrow> ] last [1..]
06:15:40 <lunabot>  Killed.
06:15:40 <vixey> ] twelf bajillion factorial
06:15:41 <lunabot>  <interactive>:1:50: Not in scope: `twelf'<interactive>:1:56: Not in ...
06:15:47 <Olathe> ] let foldb f z xs = go xs where go [] = z; go [x] = f z x; go xxs@(_:_:_) = go (go' xxs); go' [] = []; go' [x] = [x]; go' (x1:x2:xs) = ((f x1 x2):(go' xs)) in foldb (*) 1 [1..1000000]
06:15:48 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:16:02 <ivanm> does comparing == compare `on` ?
06:16:10 <mmorrow> like i said, i might have to adjust the mem lim i arbitrarily guessed
06:16:13 <trofi> looks like
06:16:14 <Olathe> @src comparing
06:16:14 <lambdabot> Source not found. Wrong!  You cheating scum!
06:16:28 <Olathe> mmorrow: Oh, I was checking if that's what you had changed when the bot left.
06:16:28 <Taejo> is there a functional (lazy) datastructure that implements queues with constant time cons and last?
06:16:43 <vixey> Taejo: What about ([a],[a])
06:16:57 <mmorrow> Olathe: cool. i was just saying, lemme know if you or anyone thinks i should :)
06:16:58 <vixey> back to back stacks
06:17:08 <Olathe> mmorrow: Oh, it seems OK :)
06:17:13 <mmorrow> nice
06:17:26 <Taejo> vixey: but then you have to do a reverse when the back stack runs out... does that amortize to constant?
06:17:26 <trofi> @check \a b -> (comparing a b) == (compare `on`) a b
06:17:27 <lambdabot>       Overlapping instances for Show (a1 -> a)
06:17:27 <lambdabot>        arising from a use of `...
06:17:42 <Olathe> ] foldl'
06:17:42 <lunabot>  <interactive>:1:43:    No instance for (Show ((a -> b -> a) -> a -> ...
06:17:45 <mmorrow> ] runIO
06:17:46 <lunabot>  <interactive>:1:50: Not in scope: `runIO'
06:17:48 <Taejo> vixey: oh, right, of course it does
06:17:50 <skorpan> @pl \ctx i -> fst ctx !! i
06:17:50 <lambdabot> (!!) . fst
06:18:02 <mmorrow> ] [|()|]
06:18:03 <lunabot>  <interactive>:1:43:    No instance for (Show Language.Haskell.TH.Lib...
06:18:13 <mmorrow> hmm
06:18:27 <mmorrow> ] ''IO
06:18:28 <lunabot>  GHC.IOBase.IO
06:18:45 <trofi> @check \a b -> (comparing a b) == (compare `on`) a b :: Int -> Int -> Bool
06:18:46 <lambdabot>   Couldn't match expected type `Int -> Int -> Bool'
06:18:55 <mmorrow> ] $([|unsafePerformIO (print ())|])
06:18:55 <lunabot>  <interactive>:1:54: Not in scope: `unsafePerformIO'
06:18:59 <mmorrow> phew
06:19:13 <skorpan> @pl \ctx i -> fst $ ctx !! i
06:19:13 <lambdabot> (fst .) . (!!)
06:19:22 <vixey> oo
06:19:40 <vixey> ] let f (reverse -> (x:_)) = x in f "azaoetuhao"
06:19:40 <lunabot>  <interactive>:1:57:    Illegal view pattern:  (reverse -> (x : _))
06:19:43 <vixey> :(((
06:19:48 <vixey> why is that illegal
06:19:58 <mmorrow> ] $([|show $(fmap (+1) [0..4])|])
06:19:59 <lunabot>  <interactive>:1:71:    Couldn't match expected type `Language.Haskel...
06:20:17 <mmorrow> vixey: hmm, i dunno. maybe i have to turn them on
06:20:50 <mmorrow> ] $([|show $([|fmap (+1) [0..4]|])|])
06:20:51 <lunabot>  luna: internal error: loadObj: can't map `/usr/local/ghc/ghc-2008091...
06:20:59 <mmorrow> um
06:21:12 <LeoD> :o
06:21:22 <trofi> ] $(pwd)
06:21:23 <lunabot>  <interactive>:1:52: Not in scope: `pwd'
06:21:23 <trofi> [:
06:21:43 <mmorrow> ] $([|show $([|42|]) |])
06:21:44 <lunabot>  luna: internal error: loadObj: can't map `/usr/local/ghc/ghc-2008091...
06:21:51 <mmorrow> $([|show 4|])
06:21:53 <mmorrow> ] $([|show 4|])
06:21:54 <lunabot>  luna: internal error: loadObj: can't map `/usr/local/ghc/ghc-2008091...
06:21:56 <mmorrow> fug
06:22:41 <vixey> ] []
06:22:42 <lunabot>  []
06:23:38 <mmorrow> the actual evaluator is in another program from the bot, so the bot is protected :)
06:24:23 <mmorrow> that's an internal ghc error. i dunno why though
06:25:26 <inimino> how can I find out what's causing a stack overflow?
06:25:39 <vixey> inimino: You could post the code
06:25:51 <pastorn_> i want to overload a function
06:25:55 <FunctorSalad_> hey vixey you're back? :)
06:26:00 <pastorn_> how do i go about doing that?
06:26:14 <vixey> I'm trying out gNewSense
06:26:19 <vixey> It's pretty cool
06:26:27 <inimino> vixey: I meant in a general sense, but maybe I'll do that too ;-)
06:26:47 <inimino> is there a way to use ghci and see what went wrong?
06:27:45 <mmorrow> pastorn: how do you mean?
06:27:49 <mmorrow> like
06:28:00 <mmorrow> ] let (+) = (*) in 2 + 2
06:28:01 <lunabot>  4
06:28:05 <mmorrow> ] let (+) = (*) in 2 + 3
06:28:06 <lunabot>  6
06:28:18 <inimino> maybe -fbreak-on-exception is what I want, I'll try that
06:28:19 <mmorrow> or with typeclasses, like show/etc
06:28:34 <vixey> ] let in ()
06:28:34 <lunabot>  ()
06:28:38 <vixey> ] let in () where
06:28:38 <lunabot>  <interactive>:1:60: parse error on input `where'
06:28:43 <vixey> > let in () where
06:28:45 <lambdabot>   ()
06:28:55 <Olathe> ] let a = (+); 1 + 1 = 25; q + r = a q r in map (+1) [0..]
06:28:56 <lunabot>  Killed.
06:29:03 <Olathe> I'll kill YOU !
06:29:39 <Twey> Haha
06:29:41 <Twey> New bot?
06:29:54 <Olathe> Yep, mmorrow's.
06:30:15 <Twey> Oh ah.
06:30:36 <vixey> ] "lunabot"
06:30:37 <lunabot>  "lunabot"
06:30:41 <vixey> ] x + 1
06:30:41 <lunabot>  <interactive>:1:50: Not in scope: `x'
06:30:47 <Olathe> ] let (Just a) + (Just b) = a + b in (Just 6) + (Just 7)
06:30:48 <lunabot>  <interactive>:1:76:    Occurs check: cannot construct the infinite t...
06:30:56 <Saizan> mmorrow: what is it built from? :)
06:31:01 <Olathe> ] let (Just a) + (Just b) = Just (a + b) in (Just 6) + (Just 7)
06:31:02 <lunabot>  <interactive>:1:82:    Occurs check: cannot construct the infinite t...
06:31:33 <Saizan> ] let (Just a) + (Just b) = Just (a Prelude.+ b) in (Just 6) + (Just 7)
06:31:34 <lunabot>  Just 13
06:31:44 <Olathe> OK.
06:31:55 <Olathe> Why did it need that ?
06:32:23 <mmorrow> i dunno
06:32:23 <Olathe> Oh, I think I know. It's not an instance of Num or something.
06:32:26 <mmorrow> ] 1 + 1
06:32:27 <lunabot>  2
06:32:37 <Olathe> So, if you redefine +, it isn't Num's +.
06:32:38 <Saizan> because the (+) on the RHS is the same (+) you're defining
06:32:38 <mmorrow> oh, i know
06:32:42 <mmorrow> yeah
06:34:55 <mmorrow> Saizan: oh, it uses the ghc-api and a custom eval function(s)
06:35:35 <mmorrow> each expression get compiled by ghc, then returned as a Dynamic
06:36:53 <mmorrow> and each exp is wrapped in show before being compiled, so the Dynamic is a string, which gets take 78 `fmap` fromDynamic res
06:37:10 <Saizan> it can do qualified .. as imports?
06:37:11 <chrisdone> dcoutts: oh hey that bug I found in cabal-install isn't there in HEAD
06:37:25 <dcoutts> chrisdone: great, which bug was that ?
06:37:30 <chrisdone> dcoutts: it's a completely different interface in HEAD. instead of interactive it's commandline arguments
06:37:42 <chrisdone> dcoutts: oh, the one where you enter the wrong details and it gives a very unhelpful exception
06:37:52 <chrisdone> dcoutts: in HEAD it says authentication error :)
06:37:58 <dcoutts> chrisdone: oh, it's that way in the earlier versions too
06:38:08 <chrisdone> dcoutts: I must've had a really old version I guess
06:38:10 <dcoutts> I thought anyway
06:38:19 <mmorrow> Saizan: i don't think the ghc-api can do those, but i think i have a way to hack it on. so just parse the expression with haskell-src-exts first, and for each qualified ident, look that up in some table and translate it to whatever it should be
06:38:39 <dcoutts> chrisdone: it'll certainly interactively prompt if you do not supply a username or passwd
06:38:57 <mmorrow> Saizan: so M.toList would get translated to  Data.Map.toList
06:38:57 <chrisdone> dcoutts: oh, it will? dang it. let me try that
06:39:06 <dcoutts> chrisdone: and I think it'll still fail unpleasantly if your supply the wrong auth
06:39:24 <Zao> vixey: "azaoetuhao" <- thanks for the highlight
06:39:58 <chrisdone> dcoutts: if you don't provide arguments, it says “ERROR: dist/lojban-0.0.0.tar.gz: 401 Authorization Required”
06:41:03 <dcoutts> chrisdone: ah yes, you're right that the command line params are new.
06:41:07 <chrisdone> dcoutts: which is presumably why, last time, I decided you needed arguments
06:41:19 <dcoutts> chrisdone: we unified the config file fields and the command line args
06:41:20 <inimino> is it possible to redirect stdin when using :main in ghci?
06:41:25 <chrisdone> dcoutts: ahh I see
06:41:35 <mmorrow> Saizan: here's the eval function http://hpaste.org/10366
06:41:46 <inimino> the ghci docs don't seem to mention it...
06:42:36 <FordCortina> the type witnesses in GADTs are the constructors, right? each constructor is a proof (witness) of its return type.
06:43:22 <FordCortina> particularly if there is sometime type refinement going on
06:44:14 <FordCortina> i.e. data Foo a where Bar :: Foo Int as opposed to data Foo a where Bar :: Foo a
06:45:20 <trofi> > toUpper <$> "hello"
06:45:21 <lambdabot>   "HELLO"
06:45:37 <vixey> FordCortina: You have seen Omega?
06:45:44 <vixey> ?go rosettacode evens sum to even
06:45:45 <lambdabot> No Result Found.
06:45:51 <vixey> ?go evens sum to even
06:45:52 <lambdabot> No Result Found.
06:46:06 <vixey> something like that has an example of GADT used like that
06:46:44 <lunabot>  42
06:47:02 <mmorrow> heh, if you send it a private message, it just prints it to the channel
06:47:31 <lunabot>  23
06:47:39 <Twey> Oops
06:47:41 * vixey wonders hwat the expression that gave 42 was 
06:47:45 <Twey> Haha
06:47:49 <mmorrow> hah
06:47:54 <mmorrow> it was "42"
06:48:08 <Saizan> ] "42"
06:48:08 <Twey> Oh, not (*) 6 8?
06:48:09 <lunabot>  "42"
06:48:16 <mmorrow> ok fine, 42
06:48:17 <lunabot>  "mmorrow is a silly billy"
06:48:20 * Twey chuckles.
06:48:34 <FordCortina> vixey: I might have another look at those Omega papers now that you mention them
06:48:38 <scriptdevil> Is there any tutorial online on instantiation of Read Class
06:48:50 <vixey> FordCortina but check the evens sum to even thing on rosettacode
06:48:52 <scriptdevil> ie. set read for my class?
06:49:00 <Twey> ] let (*) = const $ const 42 in 6 * 8
06:49:01 <lunabot>  42
06:49:11 <FordCortina> vixey: cheers
06:49:23 <mmorrow> ] read (reverse "24") :: Int
06:49:24 <lunabot>  42
06:49:44 <Saizan> ] fix error
06:49:44 <lunabot>  luna: no output
06:49:51 <mmorrow> ] fix id
06:49:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
06:50:04 <mmorrow> ] fix show
06:50:05 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\...
06:50:23 <Twey> ] fix $! id
06:50:23 <chrisdone> lunabot: what year was the end of the Masinissa line of the rulers of Carthage?
06:50:23 <lunabot>  luna: out of memory (requested 2097152 bytes)
06:50:24 <lunabot>  42
06:50:28 <Twey> :(
06:50:38 <Twey> Hahahaha, chrisdone
06:50:53 <Saizan> scriptdevil: so you don't like the instance "deriving Read" gives you?
06:50:54 <vixey> ] $ $ $
06:50:55 <lunabot>  <interactive>:1:52: parse error on input `$'
06:51:03 <vixey> ] ($)
06:51:04 <lunabot>  <interactive>:1:43:    No instance for (Show ((a -> b) -> a -> b))
06:51:09 <vixey> ] ($) ($) ($)
06:51:09 <lunabot>  <interactive>:1:43:    No instance for (Show ((a -> b) -> a -> b))
06:51:11 <lunabot>  "mantissa and cartilage??"
06:51:32 <vixey> ] \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/
06:51:32 <lunabot>  <interactive>:1:48:    Not in scope: `\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/...
06:51:53 <mmorrow> i have to get rid of that "<interactive>" business
06:52:00 <Saizan> ] error "foo"
06:52:01 <lunabot>  luna: foo
06:52:20 <FordCortina> vixey: i found that example, thanks
06:52:20 <Saizan> mmorrow: we should petition for an error message ADT in the ghc-api
06:52:39 <mmorrow> Saizan: oh, and also the evaluator is in a separate program as the bot
06:53:01 <mmorrow> Saizan: totally. also, it's nasty getting the stderr to a string
06:53:20 <chrisdone> ] readFile ".ghci"
06:53:21 <lunabot>  <interactive>:1:43:    No instance for (Show (IO String))
06:53:41 <chrisdone> nice
06:53:54 <mmorrow> you have to temporarily overwrite the mvar holding the FD in stderr, grab the error output, then replace the FD
06:53:55 <pastorn_> i want to overload the word "lookup"
06:53:56 <chrisdone> ] unsafePerformIO (putStrLn "")
06:53:57 <lunabot>  <interactive>:1:50: Not in scope: `unsafePerformIO'
06:54:05 <pastorn_> how do i go about doing that?
06:54:23 <chrisdone> mmorrow: how did you remove it from scope? explicitely importing everything?
06:54:24 <pastorn_> import Prelude hiding (lookup)
06:55:09 <chrisdone> ] :info Maybe
06:55:09 <lunabot>  <interactive>:1:51: Not in scope: `info'<interactive>:1:56: Not in s...
06:55:26 <mmorrow> chrisdone: i'm using the ghc-api, so you pass a list of modules+pkgs  setContext  on a Session, after you've done newSession
06:55:38 <chrisdone> mmorrow: oh nice
06:55:42 <mmorrow> yeah
06:56:17 <chrisdone> lunabot: is this better than mueval?
06:56:19 <lunabot>  "gee I dunno"
06:56:48 <lunabot>  "\206\187"
06:57:12 <Saizan> ] "è"
06:57:13 <lunabot>  "\195\168"
06:57:14 <chrisdone> ] let λ = ($) in id λ 1
06:57:15 <lunabot>  <interactive>:1:55: lexical error at character '\187'
06:57:19 <Saizan> hah!
06:57:33 <chrisdone> ] let λ = ($) in id `λ` 1
06:57:34 <lunabot>  <interactive>:1:55: lexical error at character '\187'
06:57:39 <chrisdone> :(
06:57:55 <mmorrow> oh yeah, i've gotta add that..
06:58:13 <chrisdone> mmorrow: is it can be utf-8 support tiem now pls?
06:58:20 <Axman6> ] let 2 + 2 = 5 in 2 + 2
06:58:20 <mmorrow> chrisdone, Saizan: here's the code to the one-go stdin->stdout evaluator the bot's using http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=39#a39
06:58:21 <lunabot>  5
06:58:34 <chrisdone> mmorrow: fanks
06:58:46 <mmorrow> can has utf8??
06:59:15 <chrisdone> mmorrow: quite short really
06:59:49 <mmorrow> totally. also, that code only works with ghc-HEAD due to ghc-api changes
06:59:57 <Olathe> ] let 2 + 2 = 5 in 2 + 3
06:59:58 <lunabot>  luna: <interactive>:1:54-62: Non-exhaustive patterns in function +
07:00:06 <Olathe> I'll exhaust YOU !
07:00:34 <chrisdone> Olathe: @yow
07:00:37 <mmorrow> but all you need to change for earlier ghc is the "modules_" function i believe
07:01:55 <chrisdone> mmorrow: I was thinking of running a haskell evaluating bot because lambdabot doesn't join channels, so this code might be useful :)
07:02:12 <Twey> lambdabot does join channels
07:02:44 <tristes_tigres> Hello
07:02:50 <chrisdone> @join #f
07:02:50 <lambdabot> Not enough privileges
07:03:10 <tristes_tigres> Why Random is in IO monad ? It is just a function with internal state
07:03:21 <mmorrow> chrisdone: oops, forgot to delete some code whose needed import i deleted... http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=39#a40
07:03:47 <chrisdone> mmk
07:04:07 <mmorrow> chrisdone: (it was just readline code)
07:04:10 <Twey> tristes_tigres: It gets its seeds from the OS, I think
07:04:41 <Saizan> tristes_tigres: actually, most of the random-related functions just take a seed as argument
07:04:45 <tristes_tigres> Twey: seeding from OS can be provided separately. Sometimes you DO NOT want it
07:05:04 <Saizan> :t randomR
07:05:04 <tristes_tigres> Saizan: well then/ Why IO ?
07:05:05 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:05:08 <Twey> That's why both random and randomIO exists
07:05:10 <TomMD> tristes_tigres: Random as in the typeclass?  It has nothing to do with IO.  Neither does Control.Monad.Random.
07:05:11 <Twey> exist**
07:05:20 <Saizan> tristes_tigres: randomIO is for convenience
07:05:59 <tristes_tigres> System.Random
07:06:21 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
07:06:23 <lambdabot> Title: System.Random, http://tinyurl.com/2xxbhl
07:06:23 <Saizan> yeah
07:06:38 <tristes_tigres> Saizan: Precisely
07:06:39 <Saizan> what's the problem with that?
07:06:39 <Twey> tristes_tigres: System.Random is the one that interfaces with the system for randomness
07:06:58 <tristes_tigres> Twey: where is non IO rng then ?
07:07:06 <Saizan> if you look at the type signature only two methods of Random have IO in the type signatures..
07:07:08 <TomMD> readFile "/dev/urandom" >>= return . decode :: IO [Int]
07:07:30 <Saizan> tristes_tigres: you can make a StdGen with mkStdGen
07:07:36 <Saizan> ?type mkStdGem
07:07:37 <tristes_tigres> Saizan: and they are the ones ypu can't have rng without
07:07:38 <lambdabot> Not in scope: `mkStdGem'
07:07:38 <TomMD> tristes_tigres: There are lots of non-IO randoms.  You can pick from many.
07:07:48 <mmorrow> chrisdone: this is handy for the pipe from the from the evaluator to the bot: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=39#a41
07:07:48 <Saizan> ?type mkStdGen
07:07:49 <lambdabot> Int -> StdGen
07:08:27 <Saizan> > randomRs (1,100) (mkStdGen 42) -- no IO here
07:08:28 <lambdabot>   [72,72,18,15,17,92,19,72,59,76,66,80,77,19,5,46,88,52,94,37,67,5,33,95,37,1...
07:08:44 <tristes_tigres> @type randomRs (1,100) (mkStdGen 42)
07:08:45 <lambdabot> forall t. (Random t, Num t) => [t]
07:09:00 <tristes_tigres> Ok? you set me straight, thanks
07:09:03 <TomMD> > (mkStdGen 8429 >>= \x -> generate i x arbitrary) :: Int
07:09:04 <lambdabot>   Couldn't match expected type `m a' against inferred type `StdGen'
07:09:04 <chrisdone> mmorrow: yeah, running external programs is uh, messy
07:09:26 <mmorrow> heh, yeah.
07:09:45 <TomMD> > generate i (mkStdGen 9321) arbitrary :: Int
07:09:46 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
07:09:51 <TomMD> grrr
07:10:15 <mmorrow> chrisdone: that func originally used runInteractiveProcess, but i switched to runInteractiveCommand so that i could use the shell's  2>&1
07:10:16 <chrisdone> mmorrow: so you run it for every use of "]"?
07:10:30 <chrisdone> yeah, much easier
07:10:30 <tristes_tigres> Saizan: Haven't noticed mkStdRandom
07:10:37 <vixey> mmorrow: run would be a nice quasiquote
07:10:58 <Saizan> tristes_tigres: heh, np :)
07:11:04 <mmorrow> chrisdone: yeah. i tried for a while to have it all in one process, but there was just no way to be able to recover from, say, "fix id" without the whole program going down
07:11:28 <mmorrow> vixey: ooh, that's a good idea.
07:11:57 <chrisdone> mmorrow: ah, sucky
07:12:25 <mmorrow> but that's ok if you're not in a situation where anyone can run code...
07:12:35 <vixey> ] let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:12:36 <lunabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,...
07:12:45 <tristes_tigres> @girl19
07:12:45 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
07:12:52 <Olathe> @girl19
07:12:52 <lambdabot> well.. I never hacked Russians
07:13:01 <vixey> ?girl19
07:13:01 <lambdabot> I have been into not actually hacking, but social engineering
07:13:02 <Olathe> What are these quotes from ?
07:13:04 <tristes_tigres> she speaks for me
07:13:06 <Olathe> @help girl19
07:13:07 <lambdabot> girl19 wonders what "discriminating hackers" are.
07:13:12 <vixey> ?girl19
07:13:12 <lambdabot> nobody can catch me
07:13:13 <Olathe> @help girl19
07:13:13 <lambdabot> girl19 wonders what "discriminating hackers" are.
07:13:15 <vixey> ?girl19
07:13:16 <lambdabot> is this a help channel for hackers-beginners?
07:13:18 <vixey> ?girl19
07:13:18 <lambdabot> LOL
07:13:22 <vixey> lol
07:13:26 <mmorrow> haha
07:13:29 <Olathe> el oh el
07:15:19 <harrison> hmm it is funny how i used to hate monads but how i now more and more start to hate variables and writing things like variable = variable + something
07:15:40 <chrisdone> @vixen formal parameters
07:15:40 <lambdabot> People think I'm weird...   do you?
07:16:10 <Olathe> @vixen
07:16:11 <lambdabot> Im going to be a movie star.  I just applied online for this new movie with chris farley.  It only cost me $50!
07:16:17 <Olathe> @help vixen
07:16:17 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
07:16:25 <Olathe> @vixen curry
07:16:25 <lambdabot> i could really use a backrub
07:16:30 <Olathe> @vixen curry
07:16:30 <lambdabot> you are soooo interesting
07:16:34 <Olathe> OK.
07:16:37 * Twey laughs.
07:17:03 <tristes_tigres> @girl19 vixen
07:17:03 <lambdabot> I'm in Moscow, Russia
07:17:12 <tristes_tigres> @vixen girl19
07:17:13 <lambdabot> Yeah
07:17:15 <Olathe> @girl19 asl ?
07:17:16 <lambdabot> well.. I never hacked Russians
07:17:23 <Olathe> @vixen asl ?
07:17:23 <lambdabot> 19/f/California
07:17:26 <Olathe> OMG
07:17:33 <Olathe> girl19 !
07:17:39 * tristes_tigres wonders if it is possible to get girl19 and vixen to talk with each other
07:17:46 <Olathe> Of course.
07:18:01 <Olathe> @@ @vixen @girl19
07:18:01 <lambdabot>  let's don't talk about that
07:18:05 <Olathe> @@ @vixen @girl19
07:18:06 <lambdabot>  whoa whoa whoa, one question at a time!
07:18:16 <Olathe> It's a horrid relationship.
07:18:28 <tristes_tigres> olathe: a catfight ?
07:18:42 <Olathe> Yes, a very passive catfight.
07:19:10 <harrison> @remember olathe fights like a mouse
07:19:10 <lambdabot> I will never forget.
07:19:16 <tristes_tigres> a very lazy catfight
07:19:21 <harrison> quote olathe
07:19:30 <harrison> @quote olathe
07:19:30 <lambdabot> olathe says: fights like a mouse
07:19:33 <Olathe> "OMG" --Olathe
07:19:41 <Olathe> I said what ?
07:19:51 <Olathe> @quote Olathe
07:19:51 <lambdabot> Olathe says: binary search on linked lists is the work of SATAN !
07:19:58 <Olathe> I remember saying that.
07:20:09 <tristes_tigres> @quote tristes_tigres
07:20:10 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
07:20:10 <harrison> @remember olathe "I dress in womans clothes and fight like a squirrel"
07:20:10 <lambdabot> Good to know.
07:20:16 <harrison> @quote olathe
07:20:17 <lambdabot> olathe says: fights like a mouse
07:20:19 <Olathe> :(
07:20:20 <chrisdone> must've been one of the rare occasions in which you are not drunk off your face
07:20:31 <harrison> @remember olathe I dress in womans clothes and fight like a squirrel
07:20:32 <lambdabot> Done.
07:20:33 <harrison> @quote olathe
07:20:33 <lambdabot> olathe says: fights like a mouse
07:20:39 <Olathe> Heheh
07:20:42 <harrison> meh
07:20:43 <RayNbow> @quote RayNbow
07:20:43 <lambdabot> No quotes match. It can only be attributed to human error.
07:20:55 <chrisdone> @quote lambdabot
07:20:55 <lambdabot> lambdabot says: lambdabot
07:20:59 <Olathe> @quote squirrel
07:20:59 <lambdabot> olathe says: I dress in womans clothes and fight like a squirrel
07:21:03 <Olathe> Haha
07:21:06 <RayNbow> I'm just not sufficiently interesting to be quoted ;)
07:21:14 <chrisdone> @quote chrisdone
07:21:14 <lambdabot> chrisdone says: it's neat how you learn haskell because you are drawn in by the purely functional paradigm, and then you find loads more things like algebraic data types, monad abstractions, arrows
07:21:14 <lambdabot> and applicative, lack of objects... so that when people say "well, it's not haskell, but at least X is functional", it's just not the same at all
07:21:23 * tristes_tigres singlehandedly stopped all useful discussions on #haskell by calling up girl19
07:21:55 <tristes_tigres> women !
07:23:36 <RayNbow> @faq can Haskell be more useful than a woman?
07:23:37 <lambdabot> The answer is: Yes! Haskell can do that.
07:23:56 <Olathe> @faq Can Haskell compute the uncomputable numbers ?
07:23:56 <lambdabot> The answer is: Yes! Haskell can do that.
07:24:17 <tristes_tigres> @faq can Haskell give you a backrub ?
07:24:17 <lambdabot> The answer is: Yes! Haskell can do that.
07:24:25 <mmorrow> @faq can haskell can has stdio?
07:24:25 <lambdabot> The answer is: Yes! Haskell can do that.
07:24:29 <Olathe> Heheh
07:24:34 <tristes_tigres> hmm, what is a type signature for THA !
07:25:03 <RayNbow> @google lol-haskell compiler
07:25:04 <lambdabot> No Result Found.
07:25:12 <harrison> @faq can haskell steal that cute chick that is married to tom cruise from him? and parallellably destroy scientology?
07:25:12 <lambdabot> The answer is: Yes! Haskell can do that.
07:25:16 <Olathe> canHas :: a -> Has a
07:25:27 <Olathe> Hmm...
07:25:28 <Twey> Haha
07:25:30 <chrisdone> @@ I'm going to lie to you: @faq
07:25:30 <lambdabot>  I'm going to lie to you: The answer is: Yes! Haskell can do that.
07:25:48 <Twey> Heh
07:37:56 <Olathe> @@ OMG Hi !
07:37:57 <lambdabot>  OMG Hi !
07:39:59 <And1> Hey folks... how can I install cabal-install as user and how can I install packages via cabal-install as user?
07:40:18 <dcoutts> And1: so the default is to install as user
07:40:36 <dcoutts> And1: the default prefix is ~/.cabal/
07:41:11 <dcoutts> And1: so you've not installed cabal-install itself yet, is that right?
07:41:40 <And1> dcoutts: Yup, as root... I can't install it as user, lemme try it again, so I can post the error...
07:42:13 <And1> (I downloaded the cabal-install-0.5.2 package and ran ./bootstrap...)
07:42:14 <dcoutts> And1: when using the runghc Setup method the default is --global, so you want to specify --user
07:42:21 <dcoutts> And1: ah ok
07:42:29 <dcoutts> that does a user install by default
07:44:08 <mikv_> Hi
07:44:37 <mikv_> I am trying to solve one exercise from RealWorld Haskell
07:44:41 <mikv_> Turn a list into a palindrome, i.e. it should read the same both backwards and forwards. For example, given the list [1,2,3], your function should return [1,2,3,3,2,1]
07:44:58 <Twey> mikv_: Right
07:45:00 <Twey> And the problem is?
07:45:07 <And1> dcoutts: http://paste.lisp.org/display/66806
07:45:22 <mikv_> Twey, one minute
07:45:30 <mikv_> Twey, i will past my code
07:45:34 * Twey nods.
07:45:41 <chrisdone> @@ @elite @run (++" ... LOL") @show @faq
07:45:43 <lambdabot>  "tHe 4nS\/\/er i5: yeS! HA5k311 can d0 TH4T. ... LoL"
07:45:57 <mmorrow> utf8
07:46:00 <TomMD> dcoutts: Thanks for the hackage-server work.  I'm looking forward to making good use of it.
07:46:13 <chrisdone> mmorrow: valid perl code
07:46:18 <TomMD> dcoutts++
07:46:53 <mikv_> my code is available at http://hpaste.org/10367
07:47:00 <mikv_> Why i can not load it into ghci?
07:47:23 <Myoma> ] let list = "abc" in list ++ reverse list
07:47:34 <Myoma> @seen mmorrow
07:47:34 <lambdabot> mmorrow is in #ghc, #darcs and #haskell. I last heard mmorrow speak 1m 37s ago.
07:48:28 <tumdum> mikv_: h:body ++ [h]
07:48:40 <mmorrow> Myoma: i'm adding utf8
07:48:49 <mmorrow> a sec..
07:48:55 <mikv_> tumdum, ?? I didn't understand
07:49:38 <Twey> mikv_: Hint, there's a 'reverse' function built in
07:49:39 <TomMD> > let lst = [1..3] in lst ++ reverse lst
07:49:41 <lambdabot>   [1,2,3,3,2,1]
07:49:51 <Twey> Way to give it away, TomMD :-P
07:49:57 <Olathe> @pl \a -> a ++ reverse a
07:49:58 <lambdabot> ap (++) reverse
07:50:04 <TomMD> Twey: sorry, I read your line and though " oh damn"
07:50:06 <Twey> Hehe
07:50:16 <Twey> It's an exercise, you're meant to just help :-P
07:50:22 <TomMD> Yeah, my bad.
07:50:25 <Olathe> > (ap (++) reverse) [1..3]
07:50:26 <mikv_> Twey, thanks.
07:50:27 <lambdabot>   [1,2,3,3,2,1]
07:50:29 <Twey> No matter.
07:50:39 <mikv_> Twey, but i want to understand why my code doesn't work
07:51:18 <Twey> > let p [] = []; p l = (head l) ++ (palindrome (tail l)) ++ (head l)
07:51:19 <lambdabot>   mueval: Prelude.read: no parse
07:51:28 <vixey> > foldr (\x ys -> [x] ++ ys ++ [x]) [] "abc"
07:51:28 <lambdabot>  Terminated
07:51:31 <vixey> > foldr (\x ys -> [x] ++ ys ++ [x]) [] "abc"
07:51:32 <Twey> Well, for a start you can use pattern matching there
07:51:32 <lambdabot>   "abccba"
07:51:37 <chrisdone> @@ @run (\a -> a ++ reverse a) @show @vixen
07:51:39 <lambdabot>   "what type of music do you like?  ?ekil uoy od cisum fo epyt tahw"
07:51:39 <vixey> mikv; ^
07:51:46 <Deewiant> > uncurry (++) . (id L.&&& reverse) $ [1..3]
07:51:48 <lambdabot>   [1,2,3,3,2,1]
07:51:56 <Twey> > let p [] = []; p (x:xs) = x ++ (palindrome xs) ++ x
07:51:57 <lambdabot>   mueval: Prelude.read: no parse
07:52:07 <Twey> Hmn, what am I missing here?
07:52:08 <Twey> Oh
07:52:12 <Twey> > let p [] = []; p (x:xs) = x ++ (palindrome xs) ++ x in p [1, 2, 3]
07:52:13 <vixey> Twey, write it as a fold
07:52:14 <lambdabot>   mueval: Prelude.read: no parse
07:52:24 <Twey> vixey: It's an exercise, for a beginner
07:52:43 <vixey> Twey, that's why it should be done with a fold
07:52:57 <Twey> Oh, obviously:
07:53:06 <Twey> > let p [] = []; p (x:xs) = x : (palindrome xs) ++ [x] in p [1, 2, 3]
07:53:07 <lambdabot>   mueval: Prelude.read: no parse
07:53:23 <Twey> Bah *flaps*
07:53:31 * Twey tries it locally.
07:53:35 <Saizan> s/palindrome/p/
07:53:45 <Twey> Ah.
07:53:50 <vixey> Twey, it is less error prone to use a fold :)
07:53:50 <Twey> > let p [] = []; p (x:xs) = x : (p xs) ++ [x] in p [1, 2, 3]
07:53:52 <lambdabot>   [1,2,3,3,2,1]
07:53:54 <vixey> > foldr (\x ys -> [x] ++ ys ++ [x]) [] "abc"
07:53:54 * Twey chuckles.
07:53:55 <lambdabot>   "abccba"
07:54:03 <Twey> vixey: Yes, but also much more complicated.
07:54:08 <vixey> no it's simpler
07:54:14 <Twey> [x] ++ ys = x : ys
07:54:38 <dcoutts> And1: so it looks like you've got a borked install of bytestring-0.9.1.2
07:54:43 <mmorrow> ] let λ = ($) in (λ) id 1
07:54:43 <lunabot>  1
07:54:49 <Twey> mikv_: So
07:54:49 <chrisdone> yayyyyyy
07:54:51 <dcoutts> And1: it looks like the package is still registered but the files have been deleted
07:54:54 <mmorrow> woohoo
07:54:56 <chrisdone> mmorrow+++++
07:55:08 <Twey> mikv_: You've got two problems: ++ takes two lists
07:55:16 <dcoutts> And1: so I expect that if you ghc-pkg unregister bytestring-0.9.1.2 then it'll work using the other version you've got installed
07:55:23 <Twey> mikv_: But h is an *element* of the list, not the list in itself
07:55:29 <chrisdone> ] let a × b = a * b in 1 × 2
07:55:30 <lunabot>  2
07:55:36 <chrisdone> ❤♥❤
07:55:37 <mmorrow> sweet
07:55:38 <Twey> mikv_: So you can't apply ++ to it (on either side)
07:55:45 <Twey> That's what stopped it compiling
07:55:47 <lunabot>  1
07:55:54 <And1> dcoutts: "ghc-pkg: cannot find package bytestring-0.9.1.2"
07:55:58 <Olathe> > sing "Did you ever know that you're my hero ?"
07:55:59 <lambdabot>   ♪ Did you ever know that you're my hero ? ♪
07:56:01 <And1> dcoutts: Think I didn't install such a package myself...
07:56:13 <Twey> vixey: As Olathe already pointed out, if we're going for clever, p = ap (++) reverse
07:56:13 <mikv_> Twey, thanks.
07:56:19 <Twey> mikv_: You're welcome :)
07:56:26 <Olathe> @pl == @clever
07:56:27 <lambdabot> (line 1, column 1):
07:56:27 <lambdabot> unexpected "="
07:56:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:56:28 <Saizan> why so much excitement over unicode?:)
07:56:30 <Twey> Haha
07:56:34 <mikv_> Twey, i got it.. [h]++body++[h] works!!
07:56:36 <vixey> Twey, I'm not suggesting using a fold because it's "clever"
07:56:54 <Olathe> @pl \body h -> [h]++body++[h]
07:56:55 <lambdabot> ap (:) . (. return) . (++)
07:56:58 <Twey> mikv_: It does :)  But as I said above, [x] ++ xs = x : xs
07:57:00 <Olathe> @pl \h body -> [h]++body++[h]
07:57:00 <lambdabot> liftM2 (.) (:) (flip (++) . return)
07:57:22 <Twey> mikv_: Probably we'd write that as h : body ++ [h]
07:57:26 <dcoutts> And1: you can see what is registered with ghc-pkg list
07:57:46 <chrisdone> the fold looks simpler to me, but if a newbie isn't used to foldr, which in my experience they don't, it does add complexity
07:57:49 <vixey> h : body ++ [h] looks ugly in comparison
07:58:07 <Twey> mikv_: Also, you can greatly neaten the definition by using pattern-matching on l rather than 'head' and 'tail'
07:58:08 <chrisdone> s/don't/aren't
07:58:59 <Twey> mikv_: Yours is equivalent to something like: palindrome (h:body) = h : (palindrome body) ++ [h]
07:59:01 <And1> dcoutts: Mh, yeah... I see: /usr/lib/ghc-6.8.2/package.confg: [...] bytestring-0.9.0.1, [...]  and  /home/and1/.ghc/i386-linux-6.8.2/package.conf: [...] bytestring-0.9.1.2, [...]
07:59:11 <mikv_> Twey, thanks
07:59:26 <mikv_> i am moving to the next exercise :-))
07:59:32 <Twey> Great!  :)
07:59:46 <dcoutts> And1: right, so I expect that per-user registered one is borked, it has files missing
08:00:17 <dcoutts> And1: so ghc-pkg unregister --user bytestring-0.9.1.2 and then try installing cabal-install again (there's no need to do the whole bootstrap since the other deps are already installed)
08:03:31 <And1> dcoutts: Yeah, with --user I can unregister it... now I get the output: "Setup: At least the following dependencies are missing: base >=3 && <4 && >=2.0 && <2.2"  libghc6-base-dev is installed...
08:03:32 <ihope> Ello.
08:04:45 <roconnor> > isUpper 'A'
08:04:47 <lambdabot>   True
08:04:51 <roconnor> > isUpper '&'
08:04:53 <lambdabot>   False
08:06:50 <dcoutts> And1: hmm, that's quite odd actually. Try adding -f-bytestring-in-base when you configure
08:08:00 <And1> dcoutts: Hrm, how do I configure with ghc? I just ran bootstrap.sh again, I never used ghc before, O:-)
08:08:28 <dcoutts> And1: oh, well bootstrap is running: runghc Setup configure --user
08:08:46 <dcoutts> And1: see the Setup.hs is the setup script, and runghc just runs that
08:09:44 <RayNbow> > isUpper 'あ'
08:09:46 <lambdabot>   False
08:09:57 <dcoutts> And1: if you go to the cabal home page, the top link is "how to install a cabal package" which explains the runghc Setup configure; runghc Setup build; runghc Setup install
08:10:38 <RayNbow> > isUpper 'Ｂ'
08:10:39 <lambdabot>   True
08:10:58 <RayNbow> > 'Ｂ' == 'B'
08:10:59 <lambdabot>   False
08:11:18 <roconnor> > isAlpha '.'
08:11:20 <lambdabot>   False
08:11:43 <roconnor> > isDigit '.'
08:11:44 <lambdabot>   False
08:12:40 <sheyll> hi
08:12:47 <ihope> Ello.
08:14:01 <sheyll> can anyone show me how to use ArrowLoop or mfix? I don't understand the feedbackmechanism, as this feedback cannot be read, because this would lead to an error...
08:14:33 <roconnor> @type ((==) `on` head)
08:14:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
08:15:14 <Saizan> sheyll: have you ever used fix?
08:15:18 <roconnor> was there a function that does (==) `on` x ?
08:15:56 <roconnor> @hoogle on
08:15:57 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:15:57 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
08:15:57 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
08:16:49 <mmorrow> ] fix (map (+1))
08:16:50 <lunabot>  luna: out of memory (requested 2097152 bytes)
08:16:55 <mmorrow> ] fix ((0:) . map (+1))
08:16:55 <Deewiant> ?hoogle (Eq b) => (a -> b) -> a -> a -> Bool
08:16:55 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
08:16:55 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
08:16:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:16:55 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
08:17:32 <mmorrow> ] iterate (+1) 0
08:17:33 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
08:18:12 <vixey> ] iterate ((1:) . map (*2)) []
08:18:13 <lunabot>  [[],[1],[1,2],[1,2,4],[1,2,4,8],[1,2,4,8,16],[1,2,4,8,16,32],[1,2,4,...
08:18:20 <mikv_> function applications has the biggest priority
08:18:25 <mikv_> right?
08:18:40 <mikv_> How can i compose two function into one?
08:18:46 <mmorrow> ] fix ((:[]) . (1:) . map (*2))
08:18:47 <lunabot>  <interactive>:1:55:    Occurs check: cannot construct the infinite t...
08:19:06 <mikv_> Is there any way to improve readability of f(phi(ttheta x))
08:19:09 <mikv_> ?
08:19:21 <Olathe> @pl f(phi(ttheta x))
08:19:21 <lambdabot> f (phi (ttheta x))
08:19:24 <vixey> (f . phi . ttheta) x
08:19:38 <Olathe> f.phi.ttheta$x
08:19:40 <mmorrow> ] fix (([1]:) . (map . map) (*2))
08:19:40 <Deewiant> f.phi.ttheta $ x
08:19:41 <lunabot>  [[1],[2],[4],[8],[16],[32],[64],[128],[256],[512],[1024],[2048],[409...
08:20:22 <mmorrow> hmm
08:20:24 <Olathe> ] map return $ iterate (*2) 1
08:20:25 <lunabot>  <interactive>:1:43:    No instance for (Show (m a))
08:20:38 <mikv_> vixey, thanks!
08:20:40 <Olathe> ] (map return $ iterate (*2) 1)::[[Integer]]
08:20:40 <lunabot>  [[1],[2],[4],[8],[16],[32],[64],[128],[256],[512],[1024],[2048],[409...
08:20:53 <Olathe> ] (map return $ iterate (*2) 1)::[Maybe Integer]
08:20:53 <lunabot>  [Just 1,Just 2,Just 4,Just 8,Just 16,Just 32,Just 64,Just 128,Just 2...
08:20:59 <int-e> Olathe: I like (:[])
08:21:20 <Olathe> ] (map (:[]) $ iterate (*2) 1)
08:21:20 <lunabot>  [[1],[2],[4],[8],[16],[32],[64],[128],[256],[512],[1024],[2048],[409...
08:21:23 <Olathe> Ahh, thanks :)
08:24:11 <And1> dcoutts: Mh, cabal-install is installed now... if I try to `cabal install xmonad' it says, it is alredy installed, but it isn't in ~./.cabal or in /root/.cabal or somewhere else...
08:24:46 <dcoutts> And1: its in ~/.cabal/bin and ~/.cabal/lib
08:25:13 <mmorrow> ] fix (([0]:) . map ((1:) . map (*2)))
08:25:14 <lunabot>  [[0],[1,0],[1,2,0],[1,2,4,0],[1,2,4,8,0],[1,2,4,8,16,0],[1,2,4,8,16,...
08:25:26 <And1> dcoutts: No, there's only cabal (in bin/) and Cabal, HTTP and zlib ind lib/...
08:26:02 <dcoutts> And1: where does ghc-pkg say xmonad is installed then? ghc-pkg describe xmonad
08:26:43 <And1> dcoutts: It says, it is in .cabal... wait, I can just unregister it, mh?
08:26:58 <mmorrow> ] tail $ fix (([]:) . map ((1:) . map (*2)))
08:26:59 <lunabot>  [[1],[1,2],[1,2,4],[1,2,4,8],[1,2,4,8,16],[1,2,4,8,16,32],[1,2,4,8,1...
08:27:25 <dcoutts> And1: yes
08:27:35 <And1> Great. :)
08:28:41 <ben_m> Computing the first triange number with over 500 divisors takes a looong time :s
08:28:53 <ben_m> ^triange^triangle
08:28:56 <Myoma> ben_m: it took me 5 seconds
08:29:12 <ben_m> In Haskell?
08:29:16 <Myoma> ben_m: yes
08:29:24 <ben_m> I'm doing something very wrong then.
08:29:33 <Myoma> Do you want to see my solution?
08:29:42 <ben_m> Uh, nah.
08:29:52 <mc__> ben_m: me2 :) mine took over 4 hours and had not yet finished
08:29:55 <Olathe> n(n + 1)/2
08:30:36 <Olathe> n and n + 1 are coprime.
08:30:47 <And1> dcoutts: How can I install xmonad with xinerama support?
08:31:04 <ben_m> Myoma that's what I use: http://hpaste.org/10368
08:31:07 <ben_m> Anything wrong with that?
08:31:34 <Myoma> yes
08:32:43 <mc__> ben_m: for the triangle numbers you could use tri = scanl (+) 1 [2..]
08:33:08 <mc__> Olathe:  n(n + 1)/2 <- what is this?
08:33:12 <dolio> > scanl1 (+) [1..] -- omg shorter!
08:33:14 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
08:33:20 <dcoutts> And1: I think xinerama support is always built-in
08:33:33 <ddk50> [1..10]
08:33:51 <int-e> > map (take 5) $ iterate (scanl1 (+)) [1..]
08:33:52 <lambdabot>   [[1,2,3,4,5],[1,3,6,10,15],[1,4,10,20,35],[1,5,15,35,70],[1,6,21,56,126],[1...
08:34:38 <kaspyanand> hi
08:34:58 <kaspyanand> i am planning to write a console based tic-tac-toe in haskell
08:34:59 <int-e> Oh, I should start with  repeat 1  instead of  [1..]
08:35:35 <kaspyanand> does default ghc will be enough to draw board?
08:37:58 <And1> dcoutts: Mh, it printed some error and then said something like "building xmonad without xinerama-support"... can't tell you the exact error right now, because `cabal install xmonad' doesn't work... http://paste.lisp.org/display/66812
08:38:31 <dcoutts> And1: I think you must have several broken packages installed
08:38:42 <dcoutts> And1: meaning the package is registered but the files have been deleted
08:39:08 <dcoutts> And1: in this case it's the mtl package that is borked
08:39:15 <And1> Mh, that's strange. =/
08:39:22 <FordCortina> can somebody answer my question here http://hpaste.org/10370 ?
08:39:58 <And1> dcoutts: I'm trying to unregister mtl...
08:40:25 <dolio> FordCortina: b and c are not existential types.
08:41:08 <dolio> Or, the first b and the c, that is.
08:41:18 <dolio> The b in Foo is existential.
08:41:27 <FordCortina> oh i c
08:41:38 <dolio> And the a is phantom, of course.
08:42:12 <FordCortina> ah! i hadnt looked at it that way before
08:42:17 <dolio> I don't think there's a special term for the b and c in Pair.
08:42:36 <FunctorSalad_> hmm does ghc somehow have sugar for restricted monads yet?
08:43:07 <And1> dcoutts: "WARNING: Xinerama headers not found. Building without Xinerama support"  What is missing? =/
08:43:36 <dcoutts> And1: ah, that's building the X11 package not xmonad. It'll be the Xinerama C header files.
08:44:07 <FordCortina> dilio: you can't achieve the b and c in pair with plain existential types, (i.e. without GADTs)
08:44:27 <dolio> Right. That's a full-on GADT.
08:44:36 <FunctorSalad_> :)
08:45:33 <FordCortina> \me reminds himself that b and c are *not* existential types
08:46:01 <int-e> does "impredicative" fit?
08:47:30 <Olathe> ben_m: What is the answer to that triangle problem ?
08:47:37 <ben_m> I don't know? :D
08:48:06 <ben_m> My attempt is either wrong or takes a long time :/
08:49:18 <And1> dcoutts: Mh, think with "libxinerama-dev" installed it works.
08:51:44 <And1> dcoutts: And how can I install X11-xft-0.3? xmonad-xontrib depends on it... "cabal: The pkg-config package xft is required but it could not be found."
08:52:15 <dcoutts> And1: again, you need the debian dev package for xft
08:52:44 <And1> dcoutts: K, thanks. =)
08:55:52 <And1> dcoutts: Everything worked fine now, thanks again...
08:55:58 <dcoutts> And1: np
09:02:30 <dansa> hello. how can i find out how many times a function was called with ghc's profiler?
09:03:09 <dansa> it doesnt like it is `entries' in the report i get
09:03:53 <dansa> i dont even see my function listed there with -prof -fforce-recomp
09:13:39 <dansa> well, as far as the docs say, it does seem that `entries' is the number of funcalls, and my tests actually point that way.
09:14:01 <dansa> so ill get back to studying how my func behaves
09:29:52 * byorgey cooks scrambled reclambdas
09:30:44 <mrd> tasty, got any extra
09:30:51 <byorgey> sure
09:31:13 * byorgey hands mrd a steaming plate of scrambled reclambdas
09:31:24 <TomMD> Can anyone tell me why seq works in this situation, but pseq does not?
09:31:24 <TomMD> http://hpaste.org/10371
09:31:38 <TomMD> I really feel like they should both work
09:32:11 <mrd> tnx
09:32:21 <mrd> bb
09:32:35 <Myoma> TomMD: Just curious how you measure what order things are happening in?
09:32:40 <Myoma> like how do you know which does hwat
09:33:17 <TomMD> Myoma: I know if things are in parallel if it uses both my cores.  That is my measure of success.
09:33:30 <TomMD> and `seq` does fine.  I feel like `pseq` should too.
09:33:34 <Heffalump> you are using +RTS -N2 -RTS ? Or is that not necessary any more?
09:33:46 <TomMD> I am using those RTS flags, they are needed.
09:34:35 <TomMD> This is for the multicore page, though in truth I'm not sure if I am going to keep this line of 'hash' examples or trash it.
09:34:54 <TomMD> http://haskell.org/haskellwiki/Haskell_for_multicores
09:34:55 <lambdabot> Title: Haskell for multicores - HaskellWiki
09:36:34 <Refried_> hi guys -- i'm new to haskell in general (so i'm unfamiliar with hackage -- in case that's relevant here), and i'm trying to set up HOpenGL in windows.  i know from previous experience with other languages that it's hard to do anything under windows... i've got ghc 6.8.2, can anyone recommend some resources/howtos ?
09:38:48 <Refried_> i've got panitz's Hello Window sample runnning on ubuntu, but trying to make it work under windows before I add any more complexity
09:39:09 <Refried_> on ubuntu i used apt-get to install the ghc bindings for glut and opengl though
09:39:24 <TomMD> Refried_: I can't help you with any windows-specific suggestions, but if you have cabal-install installed (do you?) then you should beable to run "cabal install opengl" or glut, or whatever other package you want.
09:40:10 <TomMD> Refried_: If you have worked out how to build haskell packages on windows (runhaskell Setup.hs configure/build/install) then cabal-install is just 4 packages away.
09:40:22 <dcoutts> installing opengl etc on windows requires running cabal-install from within mingw/msys
09:40:33 <TomMD> Ah, the expert.
09:40:33 <dcoutts> because opengl uses ./configure scripts which need mingw/msys
09:40:43 <dcoutts> but with that it does just work
09:40:48 <marcot> http://hpaste.org/10365#a1
09:41:00 <Refried_> TomMD: I was looking at cabal... i thought i read that some version of cabal does come with ghc 6.8.2...  it led me to some "runhaskell Setup configure" command, which barfed cause it couldn't find "setup"
09:41:05 <marcot> Running this I get the output fork, but it only runs ls after I press a key.
09:41:31 <marcot> I don't understand why it doesn't run ls before it.
09:41:34 <Refried_> does "runhaskell Setup configure" have anything to do with cabal?
09:41:35 <TomMD> refried_: use the setup file included by the package.  Usually "Setup.hs"
09:41:50 <TomMD> Refried_: It does, but 'cabal' and 'cabal-install' are two different things.
09:41:50 <Refried_> oh i see that's something i'd run in the directory of some package i've already downloaded
09:41:54 <TomMD> Yes
09:42:24 <Refried_> how can i tell if i've got cabal (there's none in my ghc/bin directory)?
09:42:32 <Refried_> dcoutts: i can set up msys *nod*
09:43:09 <TomMD> So what you do is download 3 more packages, seeing as you already have Cabal.  HTTP, zlib, and cabal-install.  do a runhaskell Setup.[l]hs configure/build/install.  Then use the executable 'cabal' which is from the package 'cabal-install' to automatically install whatever else you want.
09:43:10 <Refried_> dcoutts: ah i already have msys mingw
09:43:13 <Heffalump> you use cabal-install by running the cabal command, and you use cabal by running Setup.hs. Obvious, really.
09:43:15 <dcoutts> Refried_: the Cabal package is the library and a version of it comes with ghc, the cabal-install package provides the 'cabal' command line tool.
09:44:58 <TomMD> Refried_: To answer your earlier questions, you can see what libraries are installed via "ghc-pkg list"
09:45:05 <TomMD> s/questions/question/
09:45:49 <TomMD> Heffalump: If you have a second, is there a chance you can educate me as to why pseq does not work but seq does?
09:45:58 <Heffalump> TomMD: I'd love to, but I have no clue either.
09:46:00 <TomMD> http://hpaste.org/10371
09:46:22 <Heffalump> I was just checking on the only obvious question I could think of.
09:46:23 <TomMD> Ok.  Dern parallel package.  I'm trying to love it, I really am.
09:47:13 <mancalledhash> has anyone here had any sucess working with hslua?
09:49:14 <marcot> Shouldn't fork run completely in paralel?
09:49:22 <marcot> Or getChar blocks even the other threads?
09:49:33 <Myoma> > x `f` y `g` z
09:49:34 <lambdabot>   Add a type signature
09:49:36 <Myoma> > x `f` y `g` z :: Expr
09:49:36 <bos> TomMD: seq and pseq have different precedences
09:49:37 <lambdabot>   Add a type signature
09:49:50 <Myoma> > (x :: Expr) `f` (y :: Expr) `g` (z :: Expr)
09:49:51 <lambdabot>   Add a type signature
09:49:52 <bos> TomMD: so your code means different things depending on which you use
09:49:57 <marcot> But why doesn't it block putStrLn and blocks system?
09:49:59 <bos> hth
09:50:57 <bos> i don't remember if i mentioned this in the chapter on parallel programming in the book. probably forgot to :-(
09:51:35 <bos> TomMD: also, you should really use Control.Parallel.Strategies for that code. it would make it much clearer to separate what you're doing from how.
09:52:59 <Saizan> marcot: try compilign with -threaded
09:54:45 <TomMD> bos: I guess I just don't understand pseq.  I do understand it is different from seq, but I figured both should work in this case.  I just need h to be evaluated in parallel with the other results (hs).
09:56:18 <marcot> Saizan: same result. =(
09:57:00 <Refried_> TomMD / dcoutts: Thanks guys.  I see Cabal under ghc/lib and  ghc-pkg list.    gonna make breakfast and then try setting up cabal-install.  thanks again!
09:58:08 <marcot> Saizan: Could this be because of lazyness?
09:58:51 <bos> TomMD: you need extra parentheses.
09:59:18 <bos> TomMD: the expressions with seq and pseq, without parentheses, group differently, and have different meanings.
09:59:38 <bos> TomMD: this is caused by the fact that seq is infixr 0, and pseq is implicitly infixl 9.
10:00:41 <bos> it's got nothing to do with whether or not you understand pseq or seq, and depends entirely on whether you understand parentheses, precedence, and fixity.
10:01:46 <TomMD> bos: I tried it with parens (annotated the paste), but it doesn't help.
10:02:29 <TomMD> Gahh, but the parens were on the wrong group
10:02:31 <TomMD> I see, I see.
10:02:34 <TomMD> Thanks bos!
10:13:52 <Saizan> bos: shouldn't that be fixed?
10:20:02 <mc__> I've downloaded a cabal package for the first time. Make fails because of a missing dependency, is there a way to install dependencies automatically?
10:20:36 <im_alone> @google tabu search
10:20:38 <lambdabot> http://en.wikipedia.org/wiki/Tabu_search
10:27:22 <Saizan> mc__: yes, with cabal-install, it's a bit like apt-get but for hackage
10:27:50 <mc__> Saizan: nvm, got it already working
10:30:33 <Myoma> ] ()
10:30:34 <lunabot>  ()
10:31:00 <Olathe> ] ((((()))))
10:31:02 <lunabot>  ()
10:31:27 <Myoma> ] let x ⇒ y = y in 1 ⇒ 2 ⇒ 3 ⇒ 4
10:31:29 <lunabot>  4
10:31:36 <skorpan> hm. what was that character?
10:32:01 <skorpan> an arrow okay
10:32:15 <Myoma> ] let (⇒) = (>>=) in [1..10] ⇒ (\x -> [x,x+10])
10:32:17 <lunabot>  [1,11,2,12,3,13,4,14,5,15,6,16,7,17,8,18,9,19,10,20]
10:32:38 <Myoma> ] let (⇒) = (>>=) in [1..10] ⇒ join replicate
10:32:39 <lunabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8...
10:32:43 <bos> Saizan: it can't readily be fixed, because then it will break code already written. it ought to be documented, though.
10:33:22 <Saizan> bos: yeah, but that's why it should be fixed asap, before too much code uses it
10:33:56 <Olathe> ] [1..10] >>= (+1)
10:33:57 <lunabot>  <interactive>:1:50:    No instance for (Enum [b])
10:34:41 <Olathe> ] [1..10] >>= ((:[]).(+1))
10:34:42 <lunabot>  [2,3,4,5,6,7,8,9,10,11]
10:34:58 <trofi> > (+1) <$> [1..]
10:34:59 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:35:35 <Olathe> ] let map = ((:[]).(+1)).(=<<) in map (+1) [1..10]
10:35:36 <lunabot>  <interactive>:1:82:    Couldn't match expected type `[t] -> a'
10:35:48 <Myoma> ] let (○) = fmap in  (+1) ○ (Just 3)
10:35:50 <lunabot>  Just 4
10:36:01 <Olathe> ] let map = (=<<) ((:[]).(+1)) in map (+1) [1..10]
10:36:02 <lunabot>  <interactive>:1:87:    The section `+ 1' takes one argument,
10:36:40 <Myoma> mmorrow: any possibility of defining new data?
10:36:46 <Myoma> ] data Foo = ... kind of thing
10:36:47 <lunabot>  <interactive>:1:50: parse error on input `data'
10:37:32 <maciek> I wrote foldl by myself but it's different from wikipedia's example of foldl. Is it correct: foldl f i (x:xs) = f (foldl f i xs) x ?
10:37:43 <Myoma> maciek: You need a case for []
10:38:10 <maciek> foldl _ i [] = i
10:38:21 <Myoma> maciek: Do they both have the same type?
10:38:23 <maciek> it was just the same, so I omitted it
10:38:26 <Myoma> your foldl and the normal one
10:38:42 <maciek> foldl :: (a -> b -> a) -> a -> [b] -> a
10:38:49 <dmwit> :t foldl
10:38:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:38:57 <maciek> is it correct? on wikipedia it's without type signature
10:39:33 <maciek> so, types match.
10:40:24 <maciek> does it it mean my code is also foldl and will behave the same way as this one from prelude?
10:40:35 <Myoma> no
10:40:54 <mmorrow> Myoma: hey, um
10:40:58 <maciek> ok, thanks
10:41:04 <Twey> @src foldl
10:41:04 <lambdabot> foldl f z []     = z
10:41:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:41:34 <mmorrow> Myoma: i think it's definitely possible, i'm just not sure how yet
10:41:46 <Twey> Not quite, maciek
10:41:52 <mmorrow> marcot: http://hpaste.org/10365#a2
10:41:56 <Twey> Yours won't compile
10:41:57 <trofi> ] fix error
10:41:58 <lunabot>  luna: no output
10:42:02 <Myoma> mmorrow: I don't think there's any security problems with it is there? as long as it doesn't go via strings
10:42:25 <maciek> it compiles
10:42:31 <mmorrow> Myoma: sec problems with defining new data?
10:42:42 <mmorrow> Myoma: i can't think of any..
10:42:46 * Myoma neither
10:42:54 <Twey> foldl f i (x:xs) = f (foldl f i xs) x
10:43:00 <Twey> It can't
10:43:11 <Twey> Er
10:43:35 <maciek> i just checked, it compiles
10:43:44 <Twey> I think it works if it's passed something like [[a]]
10:43:45 <Saizan> Twey: why it can't? that definition is just foldr with the arguments of the "callback" flipped
10:43:52 <Twey> Or rather [[]]
10:44:02 <maciek> foldl (+) 0 [1..5] => 15
10:44:07 <Twey> Because it has to be passed a list
10:44:08 <dmwit> > let foldl f i (x:xs) = f (foldl f i xs) x; foldl _ i [] = i in foldl (/) [1, 2, 3]
10:44:09 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
10:44:09 <lambdabot>        arising from a use...
10:44:09 <Twey> Wait, what?
10:44:09 <mmorrow> ] error (fix ('a':))
10:44:11 <lunabot>  Killed.
10:44:20 <dmwit> > let foldl f i (x:xs) = f (foldl f i xs) x; foldl _ i [] = i in foldl (/) 1 [1, 2, 3]
10:44:21 <lambdabot>   0.16666666666666666
10:44:26 <mmorrow> ] error (fix id)
10:44:28 <lunabot>  luna: out of memory (requested 2097152 bytes)
10:44:31 <dmwit> > foldl (/) 1 [1,2,3]
10:44:32 <lambdabot>   0.16666666666666666
10:44:33 <Twey> Oh!
10:44:34 <Twey> Yes
10:44:35 <Saizan> ?type let foldl f i (x:xs) = f (foldl f i xs) x; foldl f i [] = i in foldl
10:44:36 <Twey> Indeed
10:44:36 <lambdabot> forall t t1. (t -> t1 -> t) -> t -> [t1] -> t
10:44:41 <Twey> I misread.
10:44:44 <Myoma> ] " [ "
10:44:45 <lunabot>  " [ "
10:44:55 <dmwit> maciek: I think you got it right.
10:44:57 <Myoma> ']' bugs me :/
10:45:03 <Twey> Why?
10:45:09 <Saizan> dmwit: right?
10:45:12 <mmorrow> Myoma: heh, which char would you prefer?
10:45:14 <trofi> ]>
10:45:15 <lunabot>  <interactive>:1:43:    No instance for (Show (a -> a -> Bool))
10:45:17 <dmwit> Saizan: yes.
10:45:23 <Myoma> mmorrow: ♫
10:45:27 <mmorrow> haha
10:45:29 <Myoma> ♪ 1+1
10:45:38 <Saizan> dmwit: but it's foldr instead of foldl °_°
10:45:55 <dmwit> > foldr (/) 1 [1,2,3]
10:45:57 <lambdabot>   1.5
10:46:03 <Saizan> > let foldl f i (x:xs) = f (foldl f i xs) x; foldl f i [] = i in foldl f x [1,2,3]
10:46:04 <dmwit> Saizan: I don't think so, check again!
10:46:04 <lambdabot>   f (f (f x 3) 2) 1
10:46:12 <Saizan> > foldl f x [1,2,3]
10:46:13 <lambdabot>   f (f (f x 1) 2) 3
10:46:20 <Saizan> see?
10:46:24 <Saizan> > foldr f x [1,2,3]
10:46:25 <dmwit> um
10:46:26 <lambdabot>   f 1 (f 2 (f 3 x))
10:46:33 <dmwit> It's neither. =P
10:46:44 <Saizan> it's \f -> foldr (flip f)
10:46:54 <Saizan> > foldr (flip f) x [1,2,3]
10:46:56 <lambdabot>   f (f (f x 3) 2) 1
10:47:08 <Olathe> > foldb f x [1, 2, 3]
10:47:09 <mmorrow> Myoma: i'm down to change it if you can think of a better one .. ']' seemed to be the least annoying choice, but still not as good as '>'
10:47:09 <lambdabot>   f x (f (f 1 2) 3)
10:47:33 <dmwit> mmorrow: .
10:47:39 <mmorrow> hmm
10:47:39 <Saizan> maciek: can you see your error? foldl is supposed to be a loop with an accumulating parameter
10:47:41 <mmorrow> .
10:47:45 <mmorrow> . 4
10:47:54 <maciek> I am trying to see :)
10:47:54 <mmorrow> done
10:48:01 <dmwit> . "done?"
10:48:19 <trofi>  > 1+1
10:49:15 <mmorrow> . "done!"
10:49:16 <lunabot>  "done!"
10:49:23 <dmwit> =)
10:49:24 <trofi> . say "hi"
10:49:25 <lunabot>  <interactive>:1:50: Not in scope: `say'
10:49:35 <trofi> . error "hi"
10:49:36 <lunabot>  luna: hi
10:49:38 <ben_m> . print "hi"
10:49:39 <lunabot>  <interactive>:1:43:    No instance for (Show (IO ()))
10:50:35 <lunabot>  <interactive>:1:50: Not in scope: `bot'
10:50:41 <lunabot>  <interactive>:1:43:    No instance for (Show (IO ()))
10:51:13 <Saizan> maciek: http://en.wikibooks.org/wiki/Haskell/List_processing
10:51:25 <lambdabot> Title: Haskell/List processing - Wikibooks, collection of open-content textbooks
10:51:36 <maciek> so my foldl is foldl with reverse list?
10:51:51 <mmorrow> . intercalate "':'" . fmap (:[]) $ "<interactive>"
10:51:52 <lunabot>  "<':'i':'n':'t':'e':'r':'a':'c':'t':'i':'v':'e':'>"
10:52:34 <Olathe> @@ @run intercalate "':'" . fmap (:[]) @show @run print "hi"
10:52:36 <lambdabot>   Couldn't match expected type `a -> [Char]'
10:53:25 <Olathe> @@ @run print "hi"
10:53:27 <lambdabot>   mueval: Prelude.read: no parse
10:53:27 <lambdabot>  mueval: *** Exception: "<IO ()>"
10:53:31 <Olathe> @@ @show @run print "hi"
10:53:32 <lambdabot>  "  mueval: Prelude.read: no parse\n mueval: *** Exception: \"<IO ()>\"\n"
10:53:44 <Olathe> @@ @run fmap (:[]) @show @run print "hi"
10:53:44 <Saizan> maciek: yes
10:53:47 <lambdabot>   [" "," ","m","u","e","v","a","l",":"," ","P","r","e","l","u","d","e",".","r...
10:54:03 <Olathe> @@ @run intercalate "':'" . fmap (:[]) $ @show @run print "hi"
10:54:06 <lambdabot>   " ':' ':'m':'u':'e':'v':'a':'l':':':' ':'P':'r':'e':'l':'u':'d':'e':'.':'r'...
10:54:29 <Saizan> Olathe: what are you trying to do?
10:54:45 <Olathe> (12:51.51) (mmorrow) . intercalate "':'" . fmap (:[]) $ "<interactive>"
10:54:47 <Olathe> That.
10:55:05 <jpcooper> @hoogle Bool -> a -> a
10:55:05 <lambdabot> Control.Exception assert :: Bool -> a -> a
10:55:06 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
10:55:06 <lambdabot> Control.Parallel par :: a -> b -> b
10:55:18 <trofi> @elite . say "@elite ha"
10:55:19 <lambdabot> . s4y "@eLiTE HA"
10:55:20 <lunabot>  <interactive>:1:50: Not in scope: `s4y'
10:55:26 <Olathe> > assert False "omg"
10:55:27 <lambdabot>   mueval: Prelude.read: no parse
10:55:34 <jpcooper> does anyone know a function which takes a bool and two different arguments and returns one according to what the bool is?
10:55:35 <Olathe> > Control.Exception.assert False "omg"
10:55:36 <lambdabot>       Not in scope: `Control.Exception.assert'
10:55:50 <Olathe> jpcooper: There is none, unless you make it.
10:55:56 <Olathe> jpcooper: You can use if, of course.
10:56:00 <jpcooper> sure
10:56:09 <Olathe> There's none in the libraries, though.
10:57:09 <Olathe> @src Either
10:57:10 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:57:47 <mmorrow> . asdfghgfd
10:57:48 <lunabot>   Not in scope: `asdfghgfd'
10:57:56 <mmorrow> no more "<interactive>"
10:58:13 <trofi> @hoogle Bool -> a -> a -> a
10:58:13 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
10:58:13 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
10:58:13 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
10:58:40 <Saizan> mmorrow: there's also stripPrefix btw, to be used with pattern guards
10:58:53 <mmorrow> Saizan: what a wonderful idea
10:59:02 <Olathe> > either (const 3) (const 5) (Either True False)
10:59:03 <lambdabot>   mueval: Prelude.read: no parse
11:01:10 <dancor> are yampa stream functions always 1-1?  or can i have inp stream a,a,a,a,a,a to output stream b,b where each b depends on three a's
11:01:40 <penner_diemer_> hey
11:01:45 <Olathe> > (<||>)
11:01:46 <lambdabot>   mueval: Prelude.read: no parse
11:01:47 <dancor> i guess you can do a,a,a,a,a,a to Event b,NoEvent,NoEvent,Event b,NoEvent,NoEvent?
11:02:06 <penner_diemer_> losers
11:02:07 <Heffalump> or more likely NoEvent, NoEvent, Event b, ...
11:02:12 <dancor> ok
11:02:15 --- mode: ChanServ set +o Heffalump
11:02:29 <Olathe> > let a <||> b = \x -> if x then a else b in (2 <||> 3) False
11:02:30 <lambdabot>   3
11:02:44 --- mode: Heffalump set -o Heffalump
11:03:05 <Olathe> @type let a <||> b = \x -> if x then a else b in (<||>)
11:03:06 <lambdabot> forall t. t -> t -> Bool -> t
11:05:03 <dancor> is it true that yampa just deals with sequencing, so you have to do your own clockreading if you want to do something regularly?
11:05:14 <dancor> like once every 3sec
11:05:16 <Myoma> ♪ 1+1
11:05:20 <Myoma> ♫ 1+1
11:07:07 <Olathe> Heheh
11:12:14 <hustpenna> http://www.pennergame.de/change_please/2199735/
11:12:20 <lambdabot> Title: Pennergame
11:13:03 <dancor> hm maybe it does do time
11:14:30 <dancor> i'm not sure how the sense function is supposed to know exactly how long it takes
11:16:28 <dancor> if like   sense = threadDelay x >> (,) x pollEvent   there would be all kinds of error there
11:17:05 <dancor> err   sense = threadDelay x >> fmap ((,) x) pollEvent
11:17:29 <dancor> sense = threadDelay x >> fmap ((,) x . Just) pollEvent
11:20:44 <dons> ?users
11:20:44 <lambdabot> Maximum users seen in #haskell: 504, currently: 500 (99.2%), active: 16 (3.2%)
11:20:50 <dons> hey cool.
11:20:52 * dons waves
11:21:20 <sioraiocht> so I see that there are memcpy wrappers where you can specify an offset to the src or dst buffers, but not both
11:21:39 <sioraiocht> why not, and is there anyway i can write a function that lets you specify offsets to both?
11:22:15 <dons> sioraiocht: (p `plusPtr` n) ?
11:22:56 <sioraiocht> dons: well, both my source and destination buffers are (potentially unpinned) MutableByteArray#'s
11:23:04 <mmorrow> Myoma: try now
11:23:08 <dancor> won't any method   sense   uses to determine the time it runs for necessarily be too small or inaccurate
11:23:15 <Myoma> ♫ 999^99
11:23:17 <lunabot>  90569784495866770974195656280275310090138980613960953881501965823101...
11:23:19 <Myoma> yes!
11:23:21 <mmorrow> haha
11:23:27 <mmorrow> ] 42
11:23:28 <lunabot>  42
11:23:29 <mmorrow> . 42
11:23:30 <lunabot>  42
11:23:35 <Myoma> this is great mmorrow
11:23:38 <Olathe> Bots and music.
11:23:39 <mmorrow> ♪ 42
11:23:40 <lunabot>  42
11:23:40 <Olathe> > 42
11:23:42 <lambdabot>   42
11:23:55 <mmorrow> :)
11:23:58 <dancor> falseposabot
11:24:06 <Myoma> ♪ let one = (1*) ; hundred = (100*) ; billion = 1000000000 in one hundred billion
11:24:07 <lunabot>      No instance for (Num (a -> a))
11:24:11 <sioraiocht> dons: and I don't think there is a safe way to convert an unpinned MBA# to a Ptr safely
11:24:11 <Myoma> om
11:24:17 <Myoma> ♪ let one = (*) ; hundred = 100 ; billion = 1000000000 in one hundred billion
11:24:18 <lunabot>  100000000000
11:24:21 <dancor> a 400
11:24:24 <dancor> i 400
11:24:29 <dancor> _ 400
11:24:40 <SamB> what the heck ???
11:24:43 <Saizan> what's the best way to make the typechecker "evaluate" type families in contexts?
11:25:00 <Olathe> ' 4
11:25:00 <Twey> ] _
11:25:01 <lunabot>   Pattern syntax in expression context: _
11:25:06 <SamB> ♪ do re me ♪
11:25:07 <lunabot>   parse error on input `)'
11:25:16 <dancor> [ lol ]
11:25:19 <sioraiocht> I kind of hate you all =p
11:25:30 <dancor> ] lol [
11:25:31 <lunabot>   parse error on input `)'
11:25:35 <SamB> o/` let x = x in x
11:25:38 <mmorrow> Saizan: with a "a ~ Foo b" ?
11:25:39 <Myoma> where is it seeing that )?
11:25:41 <Olathe> ] .
11:25:41 <lunabot>      No instance for (Show ((b -> c) -> (a -> b) -> a -> c))
11:25:48 <Olathe> ] Eh ?
11:25:49 <SamB> why doesn't it support the ascii-art version ?
11:25:49 <lunabot>   Not in scope: data constructor `Eh'<interactive>:1:53: Not in scope...
11:26:02 <mmorrow> Myoma: nice catch, it's wrapping the expressions in show ( .... )
11:26:04 <Saizan> mmorrow: yeah
11:26:18 <Olathe> ] 3) ++ show (4
11:26:19 <lunabot>  34
11:26:35 <mmorrow> shit
11:26:37 <Olathe> > 3) ++ show (4
11:26:38 <lambdabot>   mueval: Prelude.read: no parse
11:27:04 <mmorrow> hmm, i wonder if that can be abused, or if i can just leave it
11:27:18 <mmorrow> uhoh
11:27:33 <Myoma> ] )(
11:27:34 <lunabot>      Couldn't match expected type `() -> a'
11:27:34 <Vq^> Myoma: out of curiosity where do you live and do you use the shortscale (billion = 1000000000) there?
11:27:34 <mmorrow> ] 9) `seq` (undefined
11:27:35 <lunabot>      Ambiguous type variable `a' in the constraint:
11:27:42 <Olathe> > ) ++ ("omg"
11:27:43 <lambdabot>   mueval: Prelude.read: no parse
11:27:47 <Olathe> ] ) ++ ("omg"
11:27:47 <Myoma> Vq^: I just made it up
11:27:48 <lunabot>  ()omg
11:27:50 <mmorrow> ] 9) `seq` (undefined::()
11:27:51 <dancor> . 3) >> print "death" >> show (4
11:27:51 <lunabot>  luna: no output
11:27:52 <lunabot>      Couldn't match expected type `[a]' against inferred type `IO ()'
11:28:00 <Myoma> ♪)
11:28:01 <lunabot>   parse error on input `)'
11:28:02 <Myoma> ♪)(
11:28:03 <lunabot>      Couldn't match expected type `() -> a'
11:28:09 <Vq^> Myoma: the question still stands :)
11:28:12 <Myoma> ♪undefined(
11:28:13 <lunabot>   parse error (possibly incorrect indentation)
11:28:13 <Olathe> Hmm...
11:28:18 <Myoma> not sure what's going on
11:28:19 <Olathe> ] undefined
11:28:20 <lunabot>  luna: no output
11:28:27 <mmorrow> it's getting compiled to a Dynamic, and'll return Nothing unless the type is String
11:28:29 <Olathe> ] undefined) ++ ("omg"
11:28:30 <lunabot>  luna: Prelude.undefined
11:28:42 <mmorrow> so i think it's safe to leave for amusement's sake ;)
11:29:20 <Olathe> @pl \a b -> b
11:29:20 <lambdabot> const id
11:29:25 <dancor> mmorrow: but can you still get non-string things to _execute_+
11:29:28 <Olathe> ] undefined) `const id` ("omg"
11:29:29 <lunabot>   parse error on input `id'
11:29:34 <Olathe> ] undefined) `(const id)` ("omg"
11:29:34 <lunabot>   parse error on input `('
11:30:20 <mmorrow> dancor: everything on the input is a String. it's using the ghc-api to compile the strings into a Dynamic
11:30:35 <Olathe> ] let f a b = b in ()) `f` ("omg"
11:30:36 <lunabot>   Not in scope: `f'
11:30:53 <mmorrow> and the (fromDynamic compiled :: Maybe String) returns Nothing if the type isn't actually a String
11:31:32 <mmorrow> i think this could be avoided with "show $ "++s
11:32:21 <Myoma> ♪ foldr (\x ys -> [x]++ ys ++[x]) [] "♜♙♗♕♜♟♙♗♖♜♛"
11:32:30 <Myoma> aw too slow
11:32:41 <Myoma> ♪ foldr (\x ys -> [x]++ ys ++[x]) [] "♜♙♗♕♜♟♙♗♖♜♛"
11:32:42 <lunabot>  "\9820\9817\9815\9813\9820\9823\9817\9815\9814\9820\9819\9819\9820\9...
11:32:45 <Myoma> grrrr
11:32:55 <Myoma> not using System.IO.UTF8?
11:33:24 <Olathe> Wait, there's a System.IO.UTF8 ?
11:33:26 <trofi> show "ahything" is in ascii
11:33:29 <mmorrow> Myoma: it's hackish at the moment
11:33:30 <dons> Olathe: sure.
11:33:42 <mmorrow> ] lol [
11:33:42 <lunabot>   parse error on input `)'
11:33:45 <mmorrow> wtf
11:33:49 <Myoma> [ lol ]
11:33:50 <Twey> Why is there a System.IO.UTF8?
11:34:04 <Olathe> So that the system can do IO in UTF8.
11:34:04 <Twey> Isn't there a generic codecs module?
11:34:24 <Olathe> > System.IO.UTF8
11:34:26 <lambdabot>   mueval: Prelude.read: no parse
11:34:36 <mmorrow> ] )
11:34:37 <Olathe> @hoogle System.IO.UTF8
11:34:37 <lambdabot> package utf8-light
11:34:37 <lunabot>   parse error on input `)'
11:34:37 <lambdabot> package utf8-string
11:34:49 <mmorrow> ] ) 4
11:34:50 <lunabot>   parse error on input `)'
11:34:53 <mmorrow> ok good
11:34:53 <twanvl> ] "abc") `seq` ("xyz"
11:34:54 <lunabot>  Killed.
11:34:57 <Twey> It's possible to install a filter on handles
11:35:00 <FunctorSalad_> TH newbie problem :-( I tried (in short) "definition name = do { decl1 <- [d| data name = name A |]; return decl1 }"
11:35:14 <Olathe> Distribution.Simple.Utils.toUTF8 "test"
11:35:16 <Olathe> > Distribution.Simple.Utils.toUTF8 "test"
11:35:18 <lambdabot>       Not in scope: `Distribution.Simple.Utils.toUTF8'
11:35:30 <FunctorSalad_> and it complains about malformedness, apparently because the "name" after "data" is lowercase
11:35:30 <Olathe> Bad lambdabot !
11:37:41 <sebaseba> @users
11:37:41 <lambdabot> Maximum users seen in #haskell: 507, currently: 507 (100.0%), active: 19 (3.7%)
11:38:03 <dons> wow.
11:38:10 <dons> sundays eh?
11:38:10 <Baughn> > 2 ≤ 3
11:38:12 <lambdabot>   mueval: Prelude.read: no parse
11:38:21 <Saizan> FunctorSalad_: what would you want it to do instead?
11:38:40 <Myoma> FunctorSalad: maybe operate on the AST directly,? runQ [d| data Foo = Bar |] >>= print
11:38:41 <Myoma> [DataD [] Foo [] [NormalC Bar []] []]
11:38:43 <Saizan> FunctorSalad_: oh, i see, maybe with $(name)
11:38:51 <Myoma> replacing in 'Foo' and 'Bar' with something
11:40:49 <mmorrow> computer died
11:40:57 <Myoma> mmorrow: because of the bot ? :S
11:41:05 <mmorrow> no, my battery died
11:41:07 <FunctorSalad_> Saizan: replacing the name inside by $(name) gives "parse error on input $("... I wonder whether my quasiquote works at all
11:41:08 <Myoma> ah ok
11:41:10 <mmorrow> heh
11:41:31 <FunctorSalad_> Myoma: thanks
11:41:44 <FunctorSalad_> (but surely there's some way with quotes?)
11:42:00 <Saizan> mmh, maybe $() works only in expressions?
11:42:09 <mmorrow> FunctorSalad_: i was about to say right before i died, you can't splice "name" in there, you'll have to build it with the ast function (in ...TH.Lib)
11:42:13 <FunctorSalad_> Saizan: probably
11:42:23 <mmorrow> *ast functionS
11:42:30 <FunctorSalad_> mmorrow: ok
11:42:53 <mmorrow> (unfortunately)
11:42:59 <Olathe> ] ) ++ (readFile "/"
11:43:00 <lunabot>      Couldn't match expected type `[a]' against inferred type `Dynami...
11:44:31 <mmorrow> i think i'm gonna have to parse the input exp, then wrap in show at the AST level, to avoid any trickery
11:44:57 <mmorrow> but i don't see anyway to trick it really as is, because of the excellent type system :)
11:45:08 <FunctorSalad_> Myoma: how did you get ghci to run with TemplateHaskell? :)
11:45:16 <mmorrow> :set -XTemplateHaskell
11:45:22 <FunctorSalad_> thanks :)
11:45:44 <Myoma> all I did was :m + Language.Haskell.TH.Syntax:m + Language.Haskell.TH.Syntax
11:45:48 <Myoma> actually I only did it once
11:46:03 <Myoma> for runQ
11:46:42 <FunctorSalad_> it's not a serious problem I think; the runQ >>= print, then c&p approach sounds fair enough
11:47:42 <FunctorSalad_> so I would replace Foo by (mkName name)?
11:48:08 <Myoma> ♪ [| \x -> x |]
11:48:09 <lunabot>      No instance for (Show Language.Haskell.TH.Lib.ExpQ)
11:48:12 <Myoma> cool!
11:48:19 <FunctorSalad_> heh
11:48:20 <Myoma> so it supports th
11:48:40 <scodil> 501. score
11:48:43 <Myoma> ♪ let f (reverse -> (x:_)) = x in f "xyz"
11:48:44 <lunabot>      Illegal view pattern:  (reverse -> (x : _))
11:48:48 <Myoma> it is not illegal
11:49:28 <Saizan> mmorrow: i think it has been exploited in runplugs before, probably by also closing the let .. in and injecting code in the surrounding do-block
11:49:46 <scodil> has the dons/roman vector deathmatch been settled yet?
11:51:00 <Olathe> The what ?
11:51:02 <dons> ?users
11:51:02 <lambdabot> Maximum users seen in #haskell: 508, currently: 502 (98.8%), active: 22 (4.4%)
11:51:08 <dons> scodil: well...
11:51:41 <Olathe> @pl \f a -> f a
11:51:41 <lambdabot> id
11:52:02 <dons> btw, you can see all of roman's papers online now, http://www.cse.unsw.edu.au/~rl/publications.html
11:52:04 <lambdabot> Title: Roman Leshchinskiy - Publications
11:52:18 <Olathe> > zipWith id (map const [1..]) [1,1..]
11:52:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:52:37 <Heffalump> Olathe: what was the point of that?
11:52:41 <Olathe> Heheh
11:53:12 <scodil> dons: is "recycle your arrays!" the one I should be reading on the subject of vectors/fusion?
11:53:18 <Olathe> > let omg xs = zipWith id (map const xs) [1,1..] in omg [1..]
11:53:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:53:31 <Olathe> @pl let omg xs = zipWith id (map const xs) [1,1..] in omg
11:53:31 <lambdabot> flip (zipWith id . map const) [1,1..]
11:53:43 <Myoma> ♪ let oog = [1..] in oog
11:53:44 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
11:53:58 <dons> http://www.reddit.com/r/programming/comments/71en0/recycle_your_arrays_stream_fusion_for_inplace/
11:54:00 <lambdabot> Title: Recycle Your Arrays! Stream fusion for in-place updates of pure arrays : program ..., http://tinyurl.com/5asoff
11:54:01 <Olathe> > let omg xs = zipWith id (map const xs) [1,1..] in omg [1, 3..]
11:54:01 <Heffalump> ] let ohwow = id in ohwow [1..]
11:54:02 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
11:54:02 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
11:54:10 <dons> scodil: it explains the mutable arrays part, and how allocation wrappers are reused.
11:54:23 <Olathe> @let omg xs = zipWith id (map const xs) [1,1..]
11:54:25 <lambdabot>  Defined.
11:54:33 <Olathe> @let ohwow = id
11:54:35 <lambdabot>  Defined.
11:54:36 <mmorrow> Saizan: but there is no surrounding do block, since ghc is compiling /only/ that expression to a Dynamic
11:54:40 <Olathe> @type omg
11:54:41 <lambdabot> forall a. [a] -> [a]
11:54:45 <Olathe> @type ohwow
11:54:47 <lambdabot> forall a. a -> a
11:55:16 <Heffalump> see, mine's better, it's more polymorphic!
11:55:24 <Myoma> ♫ let divides d n = n `mod` d == 0 ; primes = sieve [2..] ; sieve (x:xs) = x : filter (not . divides x) xs in primes
11:55:25 <lunabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,...
11:55:27 <Olathe> Mine's better if you want to ensure you have a list.
11:55:52 <Saizan> mmorrow: unless ghc is also vulnerable to code injection :) but i guess that's not probably
11:55:59 <Olathe> Type safety !
11:56:17 <mmorrow> Saizan: type safety FTW!
11:57:00 <Myoma> ♫ unsafePerformNuclearyCoerceIOMissiles
11:57:01 <lunabot>      Not in scope: `unsafePerformNuclearyCoerceIOMissiles'
11:57:13 <mmorrow> lol
11:57:39 <Saizan> the worrying part is the Coerce.
11:57:39 <scodil> dons: are either of the vector libraries (yours and Roman's) going to be matured? Or are they both kind of just experimentation for the ultimate ndp array library?
11:57:48 <scodil> they both need stuff from 6.9 / 6.10, right?
11:57:48 <trofi> ] let unsafe = undefined; be = id in be unsafe
11:57:49 <lunabot>  luna: no output
11:57:54 <Myoma> mmorrow: would it be sensible to put data's through the TH quoter to sanitize them?
11:58:05 <Olathe> ] (unsafeCoerce 5)::[Char]
11:58:05 <lunabot>   Not in scope: `unsafeCoerce'
11:58:10 <dons> uvector is almost matured.
11:58:14 <Olathe> @index unsafeCoerce
11:58:14 <lambdabot> bzzt
11:58:17 <dons> no, uvector is 6.8.x
11:58:24 <Olathe> I'll bzzt YOU !
11:58:29 <scodil> oh. what's with the hackage build failure?
11:58:34 <Myoma> Unsafe.Coerce.unsafeCoerce
11:58:52 <BONUS> yo i just successfully (i think) installed cabal-install but i have no config file in my ~/.cabal folder
11:58:56 <BONUS> anyone know whats the deal
11:59:04 <skorpan> @pl \x -> (<|>) (renderChar attr x)
11:59:04 <lambdabot> (<|>) . renderChar attr
11:59:13 <Olathe> ] (Unsafe.Coerce.unsafeCoerce 5) :: [Char]
11:59:13 <lunabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
11:59:24 <Olathe> I'll put YOU in scope !
11:59:30 <Saizan> BONUS: it creates it the first time you use 'cabal'
11:59:32 <MyCatVerbs> dons: is the stream stuff in uvector exposed directly, or are only the fooU functions available, please? I honestly can't rembmer.
11:59:39 <MyCatVerbs> *remember, argh.
11:59:43 <BONUS> ah
11:59:49 <Saizan> iirc
12:00:25 <Myoma> 𝄞 1+1
12:00:44 <dons> MyCatVerbs: not exposed, but should be..
12:00:53 <Olathe> > let oo = 1.0/0.0 in oo
12:00:55 <lambdabot>   Infinity
12:01:03 <Olathe> @let oo = 1.0/0.0
12:01:06 <lambdabot>  Defined.
12:01:10 <Olathe> > oo * 5
12:01:11 <lambdabot>   Infinity
12:01:23 <Olathe> > oo - oo
12:01:25 <lambdabot>   NaN
12:01:32 <opqdonut> :D
12:01:49 <Twey> @let ∞ = 1.0/0.0
12:01:49 <lambdabot>   Parse error
12:01:52 <Twey> :(
12:01:58 <MyCatVerbs> dons: ah. I was wondering about that. Relying entirely on the rewrite rules seems a little brittle to me, as does the fact that without the stream stuff, you can only use the combinators already defined, rather than being able to dream up your own. :/
12:02:07 <Twey> Guess it has to be an operator, huh
12:02:18 <Myoma> ♫ let ∞ = 1.0/0.0 in ∞
12:02:19 <lunabot>   parse error on input `'
12:02:23 <Myoma> ♫ let (∞) = 1.0/0.0 in (∞)
12:02:24 <lunabot>  Infinity
12:02:37 <Twey> @let (∞) = 1.0/0.0
12:02:39 <dons> MyCatVerbs: i think its more robust, and more flexible than how you characterise it :)
12:02:40 <lambdabot>  Defined.
12:03:27 <MyCatVerbs> dons: mmmm. The combinators given are mostly variations on the usual list combinators.
12:04:08 <MyCatVerbs> dons: it's pretty common to come across examples where using the given list combinators to solve a particular problem is extremely tortuous indeed.
12:04:46 <MyCatVerbs> Er, where using *only* list combinators, without being able to define more, or just skip the indirection and go recursin' down the spine. :)
12:07:59 <mmorrow> Myoma: totally. you could put anything through a quoter and do what you like with it
12:08:07 <Myoma> ♫ let idQ = [| \x -> x |] in $(idQ) 3
12:08:08 <lunabot>      GHC stage restriction: `idQ'
12:08:23 <mmorrow> heh, i'm messing with it right now, trying to add TH
12:08:32 <mmorrow> ] runIO
12:08:33 <lunabot>   Not in scope: `runIO'
12:08:44 <mmorrow> i keep getting this though
12:08:48 <mmorrow> ] [|()|]
12:08:49 <lunabot>  luna: internal error: loadObj: can't map `/usr/local/ghc/ghc-2008091...
12:08:59 <mmorrow> internal error: loadObj: can't map `/usr/local/ghc/ghc-20080912/lib/ghc-6.9.20080912/array-0.1/HSarray-0.1.o'
12:08:59 <mmorrow>     (GHC version 6.9.20080912 for i386_unknown_linux)
12:08:59 <mmorrow>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
12:08:59 <Myoma> ♫ reverse [1..]
12:09:00 <lunabot>  luna: out of memory (requested 2097152 bytes)
12:09:02 <lambdabot> Title: ReportABug - GHC - Trac
12:09:06 <Myoma> ♫ last [1..]
12:09:07 <lunabot>  Killed.
12:09:41 <Myoma> could it be a parsing problem causing even more problems?
12:09:50 <Myoma> doesn't seem it ...
12:09:59 <mmorrow> no, for some reason GHC isn't able to load the array library
12:10:11 <mmorrow> which it apparently needs to eval that TH exp
12:10:17 <Myoma> that's bizarre
12:10:27 <mmorrow> (i added instances of Show for ExpQ, Q [Dec], and TypeQ)
12:10:31 <Myoma> ?where moonpaste
12:10:31 <lambdabot> http://moonpatio.com:8080
12:10:35 <mmorrow> heh
12:11:11 <Myoma> was checking shortest beta-normalizer
12:11:16 <Myoma> I thought I'd written a shorter one :)
12:11:23 <Twey> > last [1..]
12:11:27 <Myoma> but it turns out I got the exact same thing, lambda for lambda
12:11:32 <lambdabot>   mueval: Prelude.read: no parse
12:11:39 <Twey> lambdabot tries harder.
12:11:45 <Myoma> oh well mine is a tiny bit shorter
12:11:45 <FunctorSalad_> {- "show is not a visible method of class Show" ? -} runQ [d| instance GHC.Show.Show (String->String) where { show x = True } |] >>= print
12:12:19 <dons> MyCatVerbs: that's right. you drop in and do your own array destruction and construction
12:12:19 <Myoma> mmorrow: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=26#a42
12:12:23 <FunctorSalad_> err the True there is from another attempt but that's not the error
12:12:26 <dons> though its less conveninent for arrays
12:12:31 <Myoma> I got eval to use less parameters
12:12:51 <Myoma> could also replace eval m * eval n with eval m * n
12:12:58 <FunctorSalad_> I suppose I somehow have to get things into scope in the quasiquote?
12:13:01 <MyCatVerbs> dons: mmmkay. Those won't be deforested though, no?
12:13:25 <mmorrow> Myoma: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=43#a43
12:13:44 <dons> MyCatVerbs: right. just as they're not for lists.
12:13:50 <dons> you have to use the combinators.
12:13:55 <Myoma> what does it mean, to clean?
12:14:02 <mmorrow> Myoma: awesome.
12:14:09 <Myoma> oh nice 'everywhere'
12:14:15 <mmorrow> "clean" does this:
12:14:17 <Myoma> I thought it was useless before :)
12:14:48 <mmorrow> ConE GHC.Unit.()
12:14:49 <mmorrow> to
12:14:53 <mmorrow> ConE ()
12:15:11 <Myoma> ah ok
12:15:15 <MyCatVerbs> dons: ah, aight.
12:15:22 <mmorrow> also though, it kills variable's unique numbers. found that out the hard way ;)
12:15:36 <mmorrow> (x_20,x_21) ---> (x,x)
12:15:43 <mmorrow> so be caweful
12:16:12 <Twey> Haha
12:17:57 <mmorrow> Myoma: nice, i just read how you've claimed the new title for shortest ;)
12:18:11 <dons> new xmonad site about to go live. http://xmonad.twifkak.com/
12:18:12 <lambdabot> Title: xmonad | the tiling window manager that rocks
12:18:15 <dons> whaddyathink?
12:18:33 <dons> we'll be asking for screencasts too :)
12:18:50 <mmorrow> haha, the quote makes the page.
12:18:57 <vegai> pretty good.
12:20:26 * Myoma just realized how cool the xmonad logo is
12:20:50 <dons> heh
12:20:55 <dons> it had implicit coolness
12:21:20 <newsham> dons: are slides or video up for the theorem proving talk @ galois?
12:21:29 <newsham> err.. wait, thats this week.
12:21:35 <newsham> are those broadcast?
12:21:37 <dons> newsham: it's in the future, so no.
12:21:46 <dons> but we've not bought video equipement yet
12:21:52 <dons> so no video for a little while.
12:21:58 <newsham> ohwell.
12:22:13 <Myoma> I read some slides about theorem proving at galios using isabelle I think
12:22:27 <Myoma> automating hoare triples and haskell and stuff ?
12:22:32 <dons> yeap
12:22:42 <Myoma> I was starting to think I was making it up there
12:23:46 <newsham> http://www.ertos.nicta.com.au/publications/papers/Cock_KS_08.pdf  talks a little bit about how they went about proving state monad code with hoare logic
12:23:48 <lambdabot> Title: cache:http://www.ertos.nicta.com.au/publications/papers/Cock_KS_08.pdf - Google  ...
12:24:33 <newsham> (the anecdotes in their experiences section are pretty interesting, too)
12:24:43 <Olathe> I see.
12:24:51 <Olathe> So, Cock talks about Hoare.
12:25:20 <Myoma> I like these {| |} brackets
12:25:28 <dons> Coq.
12:25:35 <dons> actually Isabelle.
12:26:46 <newsham> cock/whore jokes?
12:27:04 <newsham> #haskell-blah
12:35:51 <thetallguy> andyjgill_: trying to build FieldTrip examples.  Graphics.Formats.Obj doesn't seem to exist anywhere
12:43:12 <ddarius> Myoma: http://math.andrej.com/2008/09/14/sub-and-poly-two-new-additions-to-the-pl-zoo/ if you haven't seen it already
12:43:17 <lambdabot> Title: Mathematics and Computation » Sub and Poly, two new additions to the PL Zoo, http://tinyurl.com/5qccnj
12:47:38 <skorpan> is there any mpd client written in haskell?
12:48:23 <ddarius> @hackage libmpd
12:48:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/libmpd
12:48:23 <Olathe> Multiple personality disorder ?
12:48:39 <Olathe> Ahh, Music Player Daemon.
12:49:27 <skorpan> yeah, well that's not a clietn
12:49:32 <skorpan> i'm using that to write my own client now
12:49:45 <skorpan> it's coming along surprisingly nicely actually
12:57:33 <hackage> Uploaded to hackage: yi 0.4.6
13:02:22 <dons> yi!
13:02:52 <dmwit> nu!
13:03:39 <newsham> is "yi" upside down "λ!"  ?
13:06:17 <dons> bah, it wants parsec3.
13:06:26 <dons> ddarius: these really need to be separate packages.
13:06:29 <dons> i.e. different names.
13:06:42 <paczesiowa> @instances MonadError
13:06:43 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
13:06:44 <dons> conflating classic and new parsec was a mistake
13:07:23 <dons> parsec3 is really annoying.
13:07:31 <Heffalump> isn't that what the major version number is for?
13:07:58 <dons> sure. but what do the native package systems do?
13:08:06 <Heffalump> true
13:08:11 <dons> we need to continue to provide both parsec2 and parsec3
13:08:20 <dons> since they're treated as *different libraries* by developers
13:08:20 <Heffalump> and I guess you can't upload new versions of parsec2 now.
13:08:23 <dons> while they have the same name.
13:08:30 <Heffalump> What are the differences?
13:08:44 <dons> different apis.
13:09:03 <dons> so, i want to support apps that need parsec-2
13:09:07 <dons> and apps that need parsec-3
13:09:17 <sheyll> I am, trying to understand the usage of the loop function in ArrowLoop. I am having a hard time understanding this concept, now is this the intended usage of loop? http://hpaste.org/10375
13:09:19 <paczesiowa> parsec3 is generalised generalisation of parsec2
13:09:21 <dons> now, if we had distinguished them upstream that would help.
13:09:58 <dons> basically, developers didn't accept that parsec3 was an upgrade of parsec2
13:10:04 <mattam> Aye, the PL zoo is heaven for kids. I hope students don't learn about it.
13:10:04 <dons> but are treating them as distinct libraries
13:10:09 <dons> that lack of buy-in means trouble.
13:10:39 <Heffalump> paczesiowa: is there a compatibility API then?
13:11:19 * dons creates a native parsec3 package and hopes for the best.
13:11:26 <dons> but we should ask parsec-3 to be renamed as something else.
13:11:33 <dons> new-parsec or something.
13:11:34 <newsham> sheyll: loop is what the arrow do-notation uses when you make recursive definitions
13:11:42 <paczesiowa> Heffalump: I think so, but there is code that won't compile with new parsec because of MR
13:11:44 <dons> or classic-parsec and parsec
13:11:56 <paczesiowa> better parsec and new-parsec
13:12:07 <sheyll> newsham: I am not that far yet...
13:12:18 <paczesiowa> or parsec2000 that always sounds cool
13:12:36 <dons> it's just another combinator parser library, parsec3.
13:12:39 <dons> so should have just another name.
13:13:11 <sheyll> newsham: does the definition of ns look ok?
13:13:13 <newsham> sheyll: it takes an arrow  a (b,d) (c,d)   and wires up the d inputs from the d outputs in a feedback loop
13:13:18 <newsham> so that you get an arrow   a b c
13:14:08 <newsham> yours is   (a, [a]) -> ([a], [a])   ?
13:14:22 <sheyll> newsham: yes
13:14:30 <sheyll> newsham: is this what it maybe?
13:14:31 <newsham> that should work, except i think you'll get nontemrination.
13:14:51 <newsham> because you're doing fix (a:)   basically
13:15:01 <newsham> since c == a:c
13:15:26 <newsham> with feedback,  c == r.  and since r = a:c, you get    c == a:c
13:15:30 <sheyll> newsham: yes i started with exactly that, and tried to go from fix to loop
13:16:08 <newsham> ok.. if thats what you want, i think it should work.
13:16:36 <newsham> loop ns should give you arrow that takes in "a" and returns infinite list "[a]" of that value
13:17:26 <dons> Heffalump: the other questions were lingering performance complaints about 3.0
13:17:31 <dons> that haven't been addressed, afaik
13:17:38 <dons> so its all very unclear to me that we're making progress
13:17:47 <dmwit> > fix (a:)
13:17:49 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
13:18:06 <newsham> sheyll: here's an example from the fruit paper that uses arrow notation with the 'rec' keyword.  http://www.thenewsh.com/~newsham/x/machine/paddleball.hs
13:18:38 <newsham> that basically gets translated into an unlooped arrow and the "loop" function to make it feedback
13:19:07 <sheyll> ok I will try understanding the code...
13:19:27 <Olathe> > iterate (a:) []
13:19:29 <lambdabot>   [[],[a],[a,a],[a,a,a],[a,a,a,a],[a,a,a,a,a],[a,a,a,a,a,a],[a,a,a,a,a,a,a],[...
13:19:31 <sheyll> is proc ... standard haskell?
13:19:48 <paczesiowa> arrow notation?
13:19:59 <Olathe> > iterate (a:) $ fix (a:)
13:20:01 <lambdabot>   [[a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a...
13:20:02 <newsham> using "loop" manually can be a little confusing, but the arrow notation should be more intuitive
13:20:13 <Olathe> > (iterate (a:) $ fix (a:)) !! 2
13:20:13 <jpcooper> @hoogle fix
13:20:14 <lambdabot> Data.Function fix :: (a -> a) -> a
13:20:14 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
13:20:14 <lambdabot> module Control.Monad.Fix
13:20:15 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
13:20:34 <newsham> pacz: there's a non-standard extension that has a do-notation for arrows.
13:20:44 <newsham> that will hide the complicated arrow plumbing from you
13:20:54 <dmwit> sheyll: No, proc requires an extension.  Not sure which one.
13:20:55 <newsham> http://haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
13:20:57 <lambdabot> Title: 8.9.�Arrow notation, http://tinyurl.com/3297xy
13:20:59 <paczesiowa> newsham: I know but that's no standard haskell
13:21:11 <newsham> right, not standard.
13:21:15 <paczesiowa> -farrow[s] I think
13:21:34 <newsham> also http://www.haskell.org/arrows/syntax.html
13:21:34 <lambdabot> Title: Arrow syntax
13:22:22 <paczesiowa> can someone explain to me what do I get back from "runInteractiveProcess "idontexist" [] Nothing Nothing"?
13:23:52 <paczesiowa> there are some handles (shown as {handle: fd:25}) but I'd like an exception
13:23:56 <sheyll> newsham: so xvel and yvel are the feedback parameters?
13:24:52 <gnut> hello
13:24:59 <dmwit> Hiya!
13:25:07 <gnut> ahoy
13:25:58 <newsham> sheyll: i thikn more than just those..
13:26:34 <sheyll> newsham: I am not yet able to understand that code :(
13:26:45 <newsham> xi depends on xvel, xpos depends on xi, xbounds depends on xpos, xvel depends on xbounce
13:29:20 <newsham> its using the 'integral' arrow to compute a position by integrating the velocity.
13:29:41 <newsham> and the 'when' arrow to compute intersection with the edges
13:29:48 <sheyll> ah ok
13:30:21 <newsham> and the stepAccum arrow to switch between the normal velocity and the inverse velocity when the xbounce is true
13:30:33 <newsham> and the mouseST arrow to compute the mouse position based on the GUI inputs
13:30:52 <newsham> and the "when" arrow to compute gameOver when the ball hits the bottom of the screen
13:31:17 <newsham> and uses these computed values to return the GUI shapes for the ball and the walls.
13:31:50 <newsham> in the end you have a function that takes in gui events and returns GUI shapes and a gameOver boolean
13:32:08 <Olathe> @index first
13:32:08 <lambdabot> Control.Arrow
13:32:31 <evmar> does anybody have a pointer on how to use color from hscurses?  it seems from reading their code they don't expose the necessary COLOR_PAIR function...?
13:32:36 <newsham> the arrow notation takes care of doing all of the first/second/***/&&&/loop stuff
13:32:45 <newsham> so you dont have to worry about this big nasty nested tuple of items
13:32:50 <evmar> (i looked at nanocurses too, but that doesn't appear to provide a way to output text (!?)
13:33:45 <Elly> mvaddstr? o_O
13:33:58 <Elly> or maybe they just mean for you to use standard text IO routines
13:35:23 <tusho> how good is the Programming in Haskell book
13:36:24 <newsham> graham hutton?  i like the book, but its a little thin.
13:36:47 <tusho> newsham: yes
13:37:17 <newsham> RWH is broader, with more emphasis on practical stuff
13:37:27 <sheyll> I does not explain ArrowLoop :)
13:37:36 <newsham> neither book covers arrows :)
13:37:41 <tusho> newsham: i'm asking on behalf of a friend who bought it who hates practical stuff like the plague
13:37:42 <tusho> :D
13:38:04 <newsham> tusho: i like the book, i was particularly happy that he covered some equational reasoning/proof stuff in it
13:41:05 <newsham> "Haskell is the new scala, which is the new erlang, which is the new ruby."
13:41:06 <newsham> heh.
13:41:14 <newsham> isnt haskell a lot newer than scala and ruby? :)
13:41:21 <tusho> newsham: what? no
13:41:28 <tusho> haskell = 1990, ruby = 1995, scala = 200s
13:41:31 <tusho> *2000s
13:41:43 <tusho> ah scala=2003
13:42:37 <newsham> err i meant a lot older
13:42:44 <tusho> oh
13:42:45 <tusho> :P
13:43:00 <newsham> well, its lots of fun to be using the new scala
13:45:14 <jpcooper> @hoogle Bool -> Bool -> Bool
13:45:14 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
13:45:14 <lambdabot> Prelude (||) :: Bool -> Bool -> Bool
13:45:14 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
13:45:22 <jpcooper> is there no xor?
13:46:35 <dmwit> :t xor
13:46:36 <lambdabot> forall a. (Bits a) => a -> a -> a
13:46:58 <dmwit> :t .^.
13:46:59 <lambdabot> parse error on input `.^.'
13:47:02 <dmwit> :t (.^.)
13:47:03 <lambdabot> Not in scope: `.^.'
13:47:18 <dmwit> > True `xor` True
13:47:20 <lambdabot>       No instance for (Bits Bool)
13:47:20 <lambdabot>        arising from a use of `xor' at <inte...
13:47:22 <jpcooper> but boolean xor
13:47:22 <dmwit> huh
13:47:42 <dmwit> oh
13:47:44 <dmwit> (==)
13:47:52 <dmwit> (/=), rather
13:47:55 <dmwit> > True /= True
13:47:56 <lambdabot>   False
13:48:04 <newsham> ?src Bool (==)
13:48:04 <mc__> >  le a xor b = a!=b
13:48:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:48:05 <lambdabot>   mueval: Prelude.read: no parse
13:48:06 <dmwit> jpcooper: sneaky, huh?
13:48:21 <mc__> > True `xor` True
13:48:22 <lambdabot>       No instance for (Bits Bool)
13:48:22 <lambdabot>        arising from a use of `xor' at <inte...
13:48:23 <jpcooper> ahah
13:48:47 <_MaK_> > 1 `xor` 1
13:48:48 <lambdabot>   Add a type signature
13:49:29 <dmwit> > join (liftM2 (/=)) [False..]
13:49:30 <lambdabot>   mueval: Prelude.read: no parse
13:49:36 <dmwit> ...what
13:49:39 <dmwit> > join (liftM2 (/=)) [False ..]
13:49:41 <lambdabot>   [False,True,True,False]
13:49:47 <dmwit> Foo on you, maximal munch rule!
13:53:01 <uep> In the "advanced language" section of yaht, the (/3) examples are not working for me in ghci.
13:54:45 <uep> Hmm... nevermind.  It seems it's not working for me because I previously declared the list as being of type integer.
13:56:11 <Svrog> what are maps where keys can be looked up by value called? and is there a haskell lib for those already? something like data T k v = T (Map k v) (Map v k)?
13:56:31 <Twey> Svrog: Indeed, it's called a Map and it's in the module... wait for it... Map!
13:56:37 <Twey> Er, Data.Map to be precise
13:56:43 <Svrog> err
13:56:49 <Twey> Oh wait
13:56:53 <Twey> Keys by value?  Oo-er
13:56:57 <Svrog> yeah
13:57:03 <Svrog> i need both value by key and key by value
13:57:04 <Twey> Hmm
13:57:18 <Svrog> surely there's gotta be a lib for those already
13:57:32 <twanvl> bimap
13:57:39 <Svrog> oh
13:57:42 <Svrog> cool
13:57:43 <Svrog> thans
13:57:45 <Svrog> thanks*
13:58:25 <Twey> Ooh, indeed
13:59:37 <Twey> Heh
13:59:44 <Twey> It's basically just two maps, one flipped
13:59:49 <Svrog> yup
13:59:51 <Svrog> haha
13:59:53 <Twey> Is that really an efficient way of doing it?
14:00:18 <Svrog> hmm i can't think of anything better where you sometimes need to retrieve the key and you know the value
14:00:42 <Elly> it sounds reasonable to me
14:01:03 <true\false> *waves* Anybody mind if a to-be CS student asks a few questions?
14:01:29 <Twey> Nobody minds :)
14:02:41 <true\false> Well, I'm starting in 3 weeks, currently studying C#/OOP, I'm wondering if at any point it would be worthwhile trying a funtional language such as haskell?
14:03:44 <Twey> Sure, almost certainly worth it, IMO
14:03:59 <Vq^> true\false: i would say that every programmer can gain from learning FP
14:04:21 <true\false> It won't be to a level which is especially useful, but enough to gain a reasonable understanding
14:04:30 <Vq^> and Haskell being pure makes it a good learning experience
14:04:58 * Twey nods.
14:05:14 <Twey> true\false: You'll get a unique take on the algorithms you'll be studying in CS.
14:05:28 <true\false> And would any certain level of math be required to do well in this?
14:05:31 <Twey> No
14:05:39 * Twey fails epically at maths
14:05:44 <true\false> Perfect, my math is terrible
14:05:52 <Twey> Heh
14:06:30 <true\false> Ok thanks, I'll try to get around to it just after Christmas if I have the time. :)
14:06:55 <Twey> true\false: Heh, a fellow procrastinator eh?
14:07:46 <true\false> Twey: Sadly, not anymore, I want to finish this C# book, take a quick look at the general theory of security, Databases, and I need to brush up maths
14:08:02 <Twey> Heh, 'kay
14:08:08 <Twey> Where're you studying?
14:08:21 <Twey> Was C# on the syllabus?
14:08:38 <true\false> UK, Hull University, C# is on the syllabus for the first year
14:08:52 * mapreduce salutes true\false
14:08:56 * true\false salutes mapreduce
14:09:01 <im_alone> C# 2.0 ?
14:09:06 <mapreduce> true\false: Sure, try a functional language.  LINQ is a reasonable one. :)
14:09:06 <im_alone> or C# 3.0 ?
14:09:31 <true\false> mapreduce: I thought LINQ, but is that enough of an introduction to Function al langauges?
14:09:40 <mapreduce> true\false: Probably not.
14:09:42 <uep> There's also F#, right?
14:09:50 <true\false> im_alone: I'm assuming 3.0
14:10:05 <Twey> true\false: Ooh, nice.
14:10:44 <mapreduce> I'd suggest Scheme and/or Erlang first then a typed one such as Haskell, unless you're a mathematician, in which case jump straight into Haskell.
14:11:13 <mapreduce> though Scheme is not technically a functional language, and there are escape points from purity in Erlang (process dictionaries).
14:11:15 <uep> I agree, I would lean toward Scheme.  I've done a little Scheme a long time ago, and it was easier to get into than Haskell for a start.
14:11:29 <moonlite> i'm not sure if http://hpaste.org/10376 got posted since i pasted before entering #haskell. Anyhow, does anyone see what i fail to do? I mean i shouldn't have to provide my own instances right?
14:11:39 <im_alone> mapreduce, the problem of Haskell is that it consumes much memory for smaller functions
14:11:43 <Vq^> but being easier might miss the point
14:11:51 <uep> It seemed the learning curve for Haskell was a bit steeper for just the reason you said, which is the type system.
14:11:54 <mapreduce> im_alone: The problem in learning it or running it?
14:12:01 <Vq^> if your looking to learn FP it's better to jump at Haskell directly
14:12:13 <uep> I also felt that the excessive syntax of Scheme actually aided in understanding it a little easier.
14:12:25 <mapreduce> uep: Excessive?
14:12:26 <true\false> Well, my maths is sub-par, and I'm only looking into something for personal study at some point.. Scheme or Haskell you say?
14:12:27 <Vq^> for example you can never learn FP by going from C to learning lisp from a language spec
14:12:28 <Olathe> How do I get, say fibs = 1:1:zipWith (+) fibs (tail fibs), to memoize ?
14:12:33 <im_alone> i prefer anger ML as sml/nj or ocaml
14:12:56 <uep> Wrong choice of words, I meant the excessive parentheses.
14:13:19 <mapreduce> Oh, you stop noticing those fairly quickly. :)
14:13:26 <unmarshal> afternoon
14:13:50 <uep> I think the parentheses actually make the learning curve for the language more shallow.
14:14:04 <Twey> moonlite: I think that you should be importing Text.ParserCombinators.Parsec
14:14:13 <Twey> Not Text.Parsec.*
14:14:19 <moonlite> oh ok
14:14:52 <Twey> WFM then.
14:15:59 <moonlite> Twey: that didn't make a difference. :/
14:16:20 <mapreduce> uep: Sure.  Most of Scheme's syntax can be learned in a minute.  That's a big reason why it's so good to learn with.
14:16:51 <Twey> moonlite: http://hpaste.org/10376#a1 -- this doesn't compile for you?
14:17:34 <moonlite> Twey: no
14:18:11 <Olathe> I have a list of primes and I want to factor an Integer using that, but it seems to need to recalculate the list each time I want to factor a new number.
14:18:20 <Olathe> Is there a way to avoid that ?
14:18:28 <Twey> moonlite: What's the error?  Same?
14:19:01 <dmwit> Olathe: I can't reproduce that behavior.
14:19:06 <moonlite> Twey: yeah
14:19:14 <dmwit> Does your list of primes take a parameter or something?
14:19:30 <ddarius> It's just the monomorphism restriction.
14:19:33 <dmwit> Olathe: (or is your list of primes defined within the function that's using it?)
14:19:55 <Olathe> It's in a variable.
14:20:00 <Twey> moonlite: Is this the only module?
14:20:05 <Olathe> primes = nubBy (\a b -> mod b a == 0) [2..]
14:20:15 <Twey> moonlite: I.E. you're just doing: ghc -c Helpers.hs
14:20:22 <moonlite> yes
14:20:28 <Twey> GHC version?
14:20:52 <moonlite> "ghci -XNoMonomorphismRestriction Helpers.hs" did the tric
14:20:52 <Olathe> factor = f primes where f _ 1 = []; f pps@(p:ps) n = if mod n p == 0 then p:f pps n else f ps n
14:20:54 <moonlite> 6.8.2
14:21:03 <dmwit> Olathe: When I define primes as you did, and do the following in ghci:
14:21:07 <dmwit> primes !! 1000
14:21:10 <Twey> Huh
14:21:17 <moonlite> ah i meant "yes" as in "it was the monomorphism restriction"
14:21:17 <Twey> moonlite: That's probably bad
14:21:17 <dmwit> The first time I do it takes 10s-ish, the second time 0s.
14:21:28 <Olathe> dmwit: One sec.
14:21:34 <moonlite> i have another module using Helpers
14:21:53 <Twey> Oh, right
14:22:10 <ben_m> Nested Eithers are ugly.
14:22:12 <ben_m> :/
14:22:19 <Twey> moonlite: You should probably do: colon :: Parser Char
14:22:27 <Olathe> dmwit: http://hpaste.org/10377
14:23:05 <Olathe> dmwit: If I switch to factor' instead of factor, it's much quicker.
14:23:06 <moonlite> Twey: that helps. Thanks a lot!
14:23:26 <Olathe> dmwit: Let me try with a hardcoded list.
14:24:01 <Twey> moonlite: I'm still a little baffled as to why I don't get it, though.
14:24:03 <Twey> Oh well.
14:24:13 <dmwit> Olathe: In factor', you aren't calculating primes.  They're not really comparable.
14:24:24 <ddarius> Twey: It's just the monomorphism restriction.
14:24:40 <Twey> ddarius: But it didn't apply to me :-\
14:24:44 <ben_m> When a function returns Left (Right (2,3)); how do I extract the tuple from in there? :/
14:24:49 <Twey> ddarius: I compiled http://hpaste.org/10376#a1 fine
14:24:56 <dmwit> ben_m: Use pattern matching.
14:25:06 <dmwit> ben_m: (Or the "either" function, if that's your cup of tea.)
14:25:14 <dmwit> :t either
14:25:15 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:25:18 <Olathe> dmwit: I know, I just assumed it would be quicker to go through a list rather than adding 1.
14:25:23 <Olathe> dmwit: It appears it's not.
14:25:23 <ben_m> Ah, thanks.
14:25:33 <ben_m> Pattern Matching is deeper in the book I think ;)
14:26:24 <dmwit> Olathe: Well, the primes list you've defined is a particularly slow way to calculate primes.
14:26:41 <Olathe> Ahh.
14:26:51 <Olathe> It's still slow with a literal list of 100 primes.
14:26:59 <dmwit> okay
14:27:09 <ddarius> Twey: You probably have parsec2
14:27:15 <Olathe> Very fast with the +1 method.
14:27:42 <Twey> ddarius: Ah
14:27:46 <dmwit> Olathe: Check that your types match up between the two approaches.
14:27:54 <dmwit> Olathe: Int is much faster than Integer, for example.
14:28:07 <Twey> ddarius: I just have the version that comes with GHC, and I appear to have the same version of GHC as moonlite :-\
14:28:47 <moonlite> but i have installed parsec3 separately
14:28:54 <Twey> Ah, right.
14:28:59 <moonlite> (i should have stated that, sorry)
14:29:01 <Olathe> Ahh, I will.
14:29:21 <Twey> Mmhm.
14:29:24 <Twey> Well, never mind.
14:35:21 <Olathe> @index Word8
14:35:21 <lambdabot> Data.Word, Foreign
15:06:05 <mm_freak> i'm very confused now
15:06:12 <mm_freak> isPrime n = and $ map (\x -> rem n x /= 0) $ takeWhile (\x -> x^2 < n) primesList
15:06:16 <mm_freak> primesList = 2:3: filter isPrime [5..]
15:06:34 <mm_freak> if i give primesList a type of [Integer], then it's much faster than [Int]
15:06:52 <shrughes> for what sized inputs?
15:07:01 <shrughes> ok, stupid question
15:07:59 <mm_freak> doesn't seem to matter
15:08:21 <shrughes> right, I was wondering about overflow, but no
15:09:02 <mm_freak> (interpreting "for what sized inputs" as "for how many items you 'take' from primesList")
15:09:02 <lispy> > let _'freedom' = "slavery" in _'freedom'
15:09:05 <lambdabot>   "slavery"
15:09:31 * lispy found that on the wiki humor page but doesn't really get it
15:10:24 <Saizan> as a joke or as how it works in haskell?
15:12:23 <osfameron> is _' a function?
15:12:42 <lispy> Saizan: as a joke
15:12:58 <lispy> well, identifiers can contain ' and can start with _
15:13:04 <lispy> so _'freedom' is one identifier
15:13:11 <osfameron> ah
15:13:14 <lispy> > let _'freedom' = 4 in _'freedom'
15:13:16 <lambdabot>   4
15:13:24 <lispy> But, I think it's supposed to look like a funcion call?
15:13:47 <lispy> I agree that it's silly, but I'm hesitant to declare it funny :)
15:14:02 <olsner> well, it *does* look like a function call, only a single underscore isn't a legal function name
15:14:12 <dolio> It's probably supposed to look like scare-quoted newspeak.
15:14:37 * Twey blinks.
15:14:48 <Twey> Nice
15:15:01 <Twey> I didn't know they could contain '.
15:15:25 <ddarius> foldl'
15:15:30 <osfameron> i knew they could /end/ with it
15:15:39 <Twey> Heh, aye
15:15:49 <Twey> It just doesn't seem quite the same, logically.
15:15:52 <ddarius> There are no "ending charecters"
15:15:56 <Twey> Intuitively, I mean.
15:16:10 <Twey> > let _" = 4 in _"
15:16:11 <lambdabot>   mueval: Prelude.read: no parse
15:16:16 <Twey> Not ", though, I see
15:16:18 <ddarius> > let ord'a' = 97 in (ord'a',ord 'a')
15:16:20 <lambdabot>   (97,97)
15:16:23 <newsham> ?pl \x -> a x >>= b
15:16:23 <lambdabot> (b =<<) . a
15:17:04 <newsham> hmm.. interesting it flips (>>= b)
15:17:05 <dolio> a >=> b
15:17:06 <ddarius> :t \f g x -> f x >>= g
15:17:07 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
15:17:15 <ddarius> :t (>=>)
15:17:17 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:28:04 <adamvo> has anyone successfully built hat on x86_64, with ghc8.6.2?
15:28:17 <dons> ?seen ndm
15:28:17 <lambdabot> I haven't seen ndm.
15:29:57 <ddarius> dons: I finally upgraded xmonad
15:29:58 <newsham> ?src (>=>)
15:29:58 <lambdabot> Source not found.
15:30:27 <adamvo> ./configure generates a bad config http://pastebin.com/m2bedfb44
15:30:27 <Olathe> (>=>).head
15:30:29 <lunabot>   parse error on input `/'
15:30:33 <TomMD> dons: After working on the multicore page with the strategy of continually developing an example, I'm not sure I want to keep it.  I'll definately change modes for the STM and later sections, just not sure what I think of the sections that I've already done.  Thoughts?
15:30:35 <Olathe> (>=>).head == ouch
15:30:46 <Olathe> > let ouch = (>=>).head
15:30:48 <lambdabot>   mueval: Prelude.read: no parse
15:30:51 <Olathe> @let ouch = (>=>).head
15:30:52 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:31:22 <dons> TomMD: leave 'em up?
15:31:30 <dons> ddarius: wow.
15:31:34 <dons> ddarius: like 12 months later? :)
15:31:45 <newsham> ?undef
15:31:52 <dons> http://xmonad.wordpress.com/2008/09/14/new-xmonad-website-launched/
15:31:54 <lambdabot> Title: New xmonad website launched « xmonad, http://tinyurl.com/5jv9wy
15:31:57 <newsham> @let ouch = (>=>).head
15:31:57 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:35:22 <dons> TomMD: btw, did you know Simon Marlow's got a workstealing reimplemenation of `par` about to merge. makes `par` a bunch more efficient.
15:35:25 <dons> ?users
15:35:26 <lambdabot> Maximum users seen in #haskell: 508, currently: 474 (93.3%), active: 25 (5.3%)
15:35:50 <TomMD> dons: I didn't know that - I look forward to seeing it.
15:37:56 <newsham> hows the parallel shootout stuff coming along?
15:37:56 <dons> he's also thinking hard now about per-thread young generation GC.
15:38:04 <dons> newsham: some progress. thread-ring is all win.
15:38:14 <dons> binary-trees we lose on parallelism, since GC is the 70% bottleneck.
15:38:19 <dons> well, we get no faster.
15:38:28 <dons> that needs 6.10s parallel GC
15:38:32 <dons> or per-thread GC + parallel GC
15:39:07 <mm_freak> my prime list implementation above is buggy
15:39:15 <mm_freak> isPrime n = and $ map (\x -> rem n x /= 0) $ takeWhile (\x -> x*x <= n) primes
15:39:19 <mm_freak> primes = 2: filter isPrime [3..]
15:39:21 <mm_freak> this is correct
15:40:24 <mm_freak> now this is really confusing
15:41:08 <mm_freak> (take 100000 primes) is the fastest, (take 100000 primes :: [Int]) is slower and (take 100000 primes :: [Integer]) is the slowest
15:41:11 <mm_freak> how come?!
15:42:08 <newsham> what does it default to in the first case?
15:42:19 <mm_freak> ah, got it
15:42:30 <mm_freak> there is an Int overflow, so i have to use Integer
15:43:57 <mm_freak> the default is Integer
15:44:11 <newsham> reminds me of "C# exposes more than 10 integer-like data types, none of which are those defined by (pythagoras, 500BC).  In the future, can we get integers right?"
15:44:14 <ddarius> dons: How does par currently work?
15:44:24 <mm_freak> curiously it's even slightly faster than Word64
15:44:38 <mm_freak> is there a way to use amd64 optimization in GHC?
15:44:46 <Twey> Haha, newsham
15:44:55 <ddarius> Pythagoras didn't know the joy of modular arithmetic.
15:47:10 <lispy> ddarius: maybe he kept it to himself
15:47:16 <newsham> hey, using modular arith should be allowed.  just not the default :)
15:47:34 <Olathe> Down with modular arithmetic !
15:47:38 <newsham> as jack nicholson said "you cant handle modular arithmetic"
15:49:38 <mm_freak> at the time when C was born, people seldomly used numbers of arbitrary size
15:49:50 <Olathe> You want the modular arithmetic ?!
15:49:52 <mm_freak> C++ and C# seem to have adopted that
15:50:11 <mm_freak> i don't want implicit modular arithmetic ;)
15:50:15 <newsham> "used numbers of arbitrary size"?
15:51:24 <Olathe> I'd say that C programmers who've memorized the specs and so on and want to write new ones aren't too sane.
15:51:42 <Olathe> So, you're not likely to see a C-style language with Integers.
15:51:47 <shrughes> newsham: as in, some number greater than or equal to 16 bits, etc
15:51:50 <newsham> back when people wrote fortran in the 60s stars just didnt go as fast?
15:52:02 <ddarius> newsham: 4294967297 hadn't been invented in the 70s
15:52:42 <FunctorSalad_> what do you suggest instead? overflow exception?
15:53:12 <newsham> people always used large numbers,  they just worked harder to do so
15:53:16 <paczesiowa> (+) :: Int -> Int -> Maybe Int
15:53:23 <moonlite> :)
15:53:48 <FunctorSalad_> doesn't the Maybe kinda defeat the point of using Int (performance)? ;-)
15:53:57 <paczesiowa> then the rest of the world would learn maybe monad to add 3 ints
15:54:05 <Olathe> Well, if we do that, people will use Integer since there's no advantage.
15:54:12 <Olathe> We want people to use Integer.
15:54:15 <Olathe> So, let's do that.
15:54:35 * lispy wants people to use Num a => a
15:54:53 <Olathe> Integral a is nice for div and mod and so on.
15:55:03 <Olathe> I use that quite a bit.
15:55:18 <nha> how do you create a PTR for ffi?
15:55:28 <lispy> ?hoogle Ptr
15:55:28 <lambdabot> module Foreign.Ptr
15:55:28 <lambdabot> Foreign.Ptr data Ptr a
15:55:28 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
15:55:50 <lispy> ?hoogle newPtr
15:55:51 <lambdabot> No results found
15:56:17 <ddarius> :t malloc
15:56:18 <lambdabot> Not in scope: `malloc'
15:56:52 <ddarius> @hoogle malloc
15:56:52 <lambdabot> Foreign.Marshal.Alloc malloc :: Storable a => IO (Ptr a)
15:56:52 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
15:56:52 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
15:57:55 <Olathe> @hoogle sizeOf
15:57:55 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
15:57:55 <lambdabot> System.Posix.Internals sizeof_stat :: Int
15:58:08 <Olathe> Yay, I can write in C in Haskell.
15:58:55 <TomMD> Olathe: Good work!  Should I look forward to a library on hackage?
15:59:10 <paczesiowa> @src MonadError
15:59:10 <lambdabot> class (Monad m) => MonadError e m | m -> e where
15:59:10 <lambdabot>     throwError :: e -> m a
15:59:10 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
15:59:19 <paczesiowa> why the fundep?
15:59:30 <Olathe> Well, I don't plan to write in C in Haskell.
15:59:39 <TomMD> paczesiowa: Functional dependency.
15:59:41 <TomMD> @where fundep
15:59:42 <lambdabot> I know nothing about fundep.
15:59:43 <Olathe> I like to avoid the alloc and free.
15:59:43 <TomMD> @where fundeps
15:59:43 <lambdabot> I know nothing about fundeps.
15:59:52 <TomMD> Well, its a Mark Jones paper if you want to read it.
15:59:54 <Twey> TomMD: 'Why', not 'what'
15:59:59 <paczesiowa> TomMD: but why?
16:00:33 <paczesiowa> IO could be error monad with many error types
16:00:40 <TomMD> Um, I don't get the question.
16:00:51 <paczesiowa> witch throwDyn and catchDyn
16:00:51 <shrughes> that would be neat. but the error type often depends on the monad type
16:01:18 <TomMD> Oh, "why the fundep"  sorry.  Gees.  Missed that completely.
16:01:35 <paczesiowa> shrughes: explain pls
16:01:44 <shrughes> hrm let me think, nevermind
16:02:06 <lispy> ?instances MonadError
16:02:06 <TomMD> Well, in the case of an error the monad you are in determines the type of the error.  Take for example Maybe
16:02:06 <glguy> without the functional dependency you have to specify more types
16:02:07 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
16:02:28 <lispy> maybe isn't an istance
16:02:30 <lispy> instance*
16:02:38 <TomMD> paczesiowa: If you are in (Monad Maybe) it makes little sense to throw an error of any old type 'e'.
16:02:55 <lispy> TomMD: Maybe isn't an instance of MonadERror
16:03:17 <paczesiowa> lispy: easy fix
16:03:30 <adamvo> is it just me, or is darcs.haskell.org really slow?
16:03:31 <TomMD> lispy: The example stands
16:03:52 <TomMD> adamvo: Both darcs. and code. have been having hiccups lately.
16:04:07 <paczesiowa> TomMD: throwing makes sense, catching is harder
16:04:11 <adamvo> TomMD: thanks
16:05:30 <Twey> Why is 'error' used so much when it's standardly uncatchable?
16:05:38 <mm_freak> http://hpaste.org/10378 ⇐ can someone explain this?
16:05:43 <dons> it has a short name
16:05:45 <mm_freak> see the code comment
16:05:49 <Twey> Hahaha
16:05:49 <paczesiowa> Twey: it is catchable
16:05:59 <Twey> paczesiowa: Not in '98, I hear
16:06:27 <dons> :t rem
16:06:28 <lambdabot> forall a. (Integral a) => a -> a -> a
16:07:02 <mm_freak> "rem" = "remainder"
16:07:19 <mm_freak> faster than 'mod', if you don't need real modulo
16:07:22 <paczesiowa> you can't define your own in h98
16:07:53 <mm_freak> > (mod (-7) 10, rem (-7) 10)
16:07:55 <lambdabot>   (3,-7)
16:08:40 <paczesiowa> TomMD: how about if catching any non-() type in Maybe would result in rethrowing error?
16:09:28 <Twey> > rem 5 10
16:09:29 <lambdabot>   5
16:09:39 <Twey> > rem 3 10
16:09:40 <lambdabot>   3
16:09:46 <dons> mm_freak: i was just hunting for type defaulting to Int.
16:09:48 <dons> are you on 32 bit?
16:09:51 <newsham> > modRem (-7) 10
16:09:52 <lambdabot>   mueval: Prelude.read: no parse
16:09:59 <newsham> > remMod (-7) 10
16:09:59 <lambdabot>   mueval: Prelude.read: no parse
16:10:12 <Olathe> > liftM2 (,) [-1..1] [-1..1]
16:10:12 <mm_freak> dons: i'm on 64 bits, but my CHOST is 32 bits
16:10:13 <lambdabot>   [(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(0,1),(1,-1),(1,0),(1,1)]
16:10:16 <shrughes> >quotRem (-7) 10
16:10:20 <shrughes> > quotRem (-7) 10
16:10:21 <lambdabot>   (0,-7)
16:11:19 <mm_freak> also there is quite a few things that can be optimized in the Prelude
16:11:31 <Olathe> > map (\(a, b) -> "rem " ++ show a ++ " " ++ show b ++ " = " ++ show (rem a b) ++ ", mod " ++ show a ++ " " ++ show b ++ " = " ++ show (mod a b)) liftM2 (,) [-1..1] [-1..1]
16:11:32 <mm_freak> for example, currently x*x is MUCH faster than x^2
16:11:32 <lambdabot>   Couldn't match expected type `[(t, t)]'
16:12:04 <lispy> :t ((*), (^))
16:12:05 <lambdabot> forall a a1 b. (Integral b, Num a1, Num a) => (a -> a -> a, a1 -> b -> a1)
16:12:18 <Saizan> mm_freak: with that type signature primes isn't shared anymore, so probably you get more fusion/different optimizations
16:14:17 <Saizan> mm_freak: btw, with -Wall you'll get a warning by every defaulting
16:14:32 <mm_freak> Saizan: good point…  so it calculates the list of primes twice?
16:14:52 <Olathe> > say $ concat $ intersperse "\n" $ map (\(a, b) -> "rem (" ++ show a ++ ") (" ++ show b ++ ") = (" ++ show (rem a b) ++ "),\t mod (" ++ show a ++ ") (" ++ show b ++ ") = (" ++ show (mod a b) ++ ")") $ liftM2 (,) [-1..1] [-1,1]
16:14:54 <lambdabot>   rem (-1) (-1) = (0),         mod (-1) (-1) = (0)
16:14:54 <lambdabot>  rem (-1) (1) = (0),      ...
16:15:08 <Olathe> Hmm...
16:15:23 <Olathe> > say $ concat $ intersperse "\n" $ map (\(a, b) -> "rem (" ++ show a ++ ") (" ++ show b ++ ") = (" ++ show (rem a b) ++ "), mod (" ++ show a ++ ") (" ++ show b ++ ") = (" ++ show (mod a b) ++ ")") $ liftM2 (,) [-1..1] [-2,2]
16:15:24 <lambdabot>   rem (-1) (-2) = (-1), mod (-1) (-2) = (-1)
16:15:24 <lambdabot>  rem (-1) (2) = (-1), mod (-1) (...
16:15:38 <Saizan> mm_freak: i'd think so, but the only real answer is to look at the Core
16:16:05 <paczesiowa> > ""
16:16:06 <lambdabot>   ""
16:16:28 <Olathe> @index liftM2
16:16:28 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:17:10 <Olathe> print seems to call show on a String. How do I not get the show version ?
16:17:21 <Saizan> putStrLn
16:17:25 <Olathe> Thanks :)
16:18:05 <FunctorSalad_> or even System.IO.UTF8.putStrLn
16:18:10 <mm_freak> Saizan: shouldn't the type signature specialize all i types to Integer?
16:18:26 * FunctorSalad_ is trying to spread utf8 so he can use more funny symbols in source
16:18:34 <mm_freak> that would make it shared again, unless GHC doesn't recognize it
16:19:00 <mm_freak> FunctorSalad: yeah, ≠ is prettier than /= anyway =)
16:19:12 <Olathe> I wish lambdabot used System.IO.UTF8 for I/O.
16:19:35 <mm_freak> does lambdabot care?
16:19:42 <Olathe> lambdabot doesn't care.
16:19:55 <FunctorSalad> except if there's a botsnack in for her.
16:20:00 <Olathe> But it needs a special utf8 conversion function to output properly.
16:20:16 <Olathe> Like with the loverly say function.
16:20:17 <mm_freak> hmm
16:20:32 <Saizan> really?
16:20:34 <mm_freak> dunno…  haven't looked at it
16:20:59 <Saizan> ?ty fun
16:21:00 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
16:21:08 <mm_freak> btw, is lambdabot suitable as an eggdrop replacement?  i don't need botnets or such, but i'd like to be able to program it
16:21:09 <Saizan> > fun "è"
16:21:11 <lambdabot>   Add a type signature
16:21:15 <Saizan> > fun "è" :: Expr
16:21:17 <lambdabot>   �
16:21:28 <FunctorSalad> mm_freak: and any of the various arrows would be better than "<&--<" type stuff ;-)
16:21:34 <Olathe> > say "è"
16:21:35 <lambdabot>   è
16:21:42 <Saizan> oh, yeah, \bot is still using the realesed version of mueval, which is buggy
16:21:47 <Olathe> > utf8 "è"
16:21:48 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
16:21:55 <Olathe> > utf8s "è"
16:21:56 <lambdabot>   "\195\168"
16:22:08 <mm_freak> FunctorSalad: though most people will have problems typing them, and a lot of people will have problems reading them
16:22:17 <Olathe> > (fun.utf8s) "è" :: Expr
16:22:19 <lambdabot>   è
16:22:26 <mm_freak> especially on windows
16:23:01 <mm_freak> i'd like to rename Integer to ℤ, but all windows core fonts don't have the blackboard glyphs
16:23:18 <FunctorSalad> mm_freak: hmm, didn't know the situation was so dire on windows
16:23:37 <mm_freak> yeah, it lacks a lot of glyphs in the core fonts
16:23:44 <mm_freak> otherwise it would be great
16:23:51 <Zao> mm_freak: Segoe UI seems to draw the Z reasonably OK.
16:23:51 <mm_freak> gcd :: ℤ → ℤ → ℤ
16:23:53 <mm_freak> =)
16:24:09 <Zao> DejaVu Sans Mono does it better though.
16:24:23 <FunctorSalad> DejaVu Sans too
16:24:28 <FunctorSalad> and Freemono IIRC
16:24:30 <Olathe> Zao: I've seen that one before somewhere !
16:24:40 <mm_freak> gcd a = λb ↦ gcd b (a `mod` b)
16:25:26 * Saizan finds hard to type unicode even on linux
16:25:29 <FunctorSalad> Zao: hmm, DejaVu Sans Mono is missing quite a few that DejaVu Sans has if you go to page 33/34
16:25:44 <mm_freak> Saizan: on linux you can make it easy…  man xmodmap
16:25:50 <mm_freak> that's what i do
16:26:03 <FunctorSalad> Saizan: I find it easy when and only when my scim has decided to work
16:26:08 <Zao> FunctorSalad: As I only use it for IRC and C++ with the source charset, I'm covered.
16:26:16 <mm_freak> if you look closely…  you'll find that i type real ellipsis and — of course — real m-dashes =)
16:26:52 <FunctorSalad> mm_freak: I never researched what the semantic difference between the different dashes is
16:27:11 <mm_freak> FunctorSalad: the normal dash is a word separator
16:27:42 <mm_freak> the m-dash is a subordinate clause separator, sometimes also just an emphasis construct
16:28:07 <FunctorSalad> I thought the "thought pause" thing was the medium-width one
16:28:13 <mm_freak> it's used where comma is too 'weak' and other punctuation is too strong
16:28:25 <mm_freak> the medium width thing is n-dash
16:28:59 <mm_freak> i don't know what the difference is between n-dash and m-dash…  i only use m-dash, and common literature seems to agree with me here
16:29:26 <Svrog> re writing unicode - for vim users, this is handy: http://westhoffs-welt.de/blog/vim_unicode_macros.html
16:29:31 <lambdabot> Title: Westhoffswelt - Welcome to the real world
16:29:45 <Svrog> found it the other day when i was trying to write some agda code
16:30:02 <ziman> n-dashes are mainly for numeric ranges
16:30:11 <FunctorSalad> haskell-mode on emacs does the best of two worlds in a way... it displays -> as →, \ as λ and so on, but saves stuff normally
16:30:40 <FunctorSalad> you can even still use the actual utf-8 arrow as your own operator ;-)
16:30:55 <FunctorSalad> font-level overloading
16:31:12 <Cale> Displaying -> as → seems dangerous
16:31:28 <FunctorSalad> why?
16:31:29 <Cale> Unless you always leave an extra space or something
16:31:36 <Cale> It could mess up alignment.
16:31:41 <bos> @pl \s -> second (s:) <$> samples
16:31:41 <lambdabot> (<$> samples) . second . (:)
16:32:15 <FunctorSalad> Cale: I'm not sure what you mean but it does indentation automatically anyway
16:32:40 <ziman> excellent for 2D structures (cons, snoc, suoɔ, ɔous)
16:33:33 <Cale> Well, whenever you turn one character into two (or vice versa), you introduce a chance that alignment will be messed up, but I suppose if it's smart enough to realign things anyway, that's not much of a problem.
16:33:53 <FunctorSalad> well, the indenter is not perfect, but you can cycle suggestions with tab
16:34:23 <FunctorSalad> but... the left end of the - is just where the left end of the →
16:35:17 * FunctorSalad can't indent x and y in "data x \n y" anyway because he's using proportional fonts
16:35:30 <FunctorSalad> I mean "align"
16:43:29 <Stinger> programming without fixed width?
16:43:32 <Stinger> ew
16:43:41 <ozy`> FunctorSalad: why would you edit code in a proportional font? I mean, unless you're writing Pascal
16:44:04 <ozy`> (proportional fonts seem to be strangely popular with Pascal-family language books...)
16:44:29 <FunctorSalad> ozy`: I find it a lot more readable, and at a given readable size more fits on the screen
16:44:47 <Stinger> widescreen monitors ftw
16:45:17 <FunctorSalad> the only plus I can see for fixed with is aligning stuff in new lines under stuff in filled lines
16:45:43 <FunctorSalad> but you might as well put the to-be-aligned stuff from the filled line on a new line.
17:11:16 <gwern> 'lo all
17:11:16 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:12:08 <gwern> so, I was thinking of playnig around with Chernoff faces <http://kspark.kaist.ac.kr/Human Engineering.files/Chernoff/Chernoff Faces.htm> <https://secure.wikimedia.org/wikipedia/en/wiki/Chernoff_face>
17:12:27 <gwern> anyone have any idea about what graphics libraries should be particularly commended to this task?
17:13:23 <gwern> there're several which look like possible candidates - Chart, diagrams, certainly
17:17:13 * gwern guesses it's either quiet tonight or noone cares about data-visualisation techniques like Chernoff faces
17:17:59 <gwern> truth be told, I finished rereading Peter Watts's _Blindsight_, and I just wanted to make screaming faces which represent systems stats for my computer :)
17:18:59 <gwern> @seen mmorrow
17:19:00 <lambdabot> mmorrow is in #darcs, #haskell and #ghc. I last heard mmorrow speak 11m 47s ago.
17:19:44 <gwern> mmorrow: if you're making a haskell evalbot, did you test it against the mueval example inputs?
17:21:01 <mmorrow> gwern: hey. no i haven't, but that's an excellent idea.
17:21:28 <gwern> :( I gathered those examples in part for to make testing of such evaluators easy
17:21:38 <mmorrow> check out the eval function. i've been trying to pick through the ghc-api to get more control than hint/etc give..
17:21:52 <mmorrow> ] fix show
17:21:52 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\...
17:22:02 <mmorrow> ] fix error
17:22:03 <lunabot>  luna: no output
17:22:13 <gwern> mmorrow: is it part of preflex?
17:22:23 <mmorrow> the ghc-api is great!
17:22:32 <mmorrow> no, it's a pretty basic bot
17:22:53 <mmorrow> i separated the bot from the evaluator prog
17:22:58 * gwern disagrees. that stupid import problem, then the lack of qualified imports, the lack of docs... sometimes lisp starts to sound good
17:23:10 <rieux> hi.  does anyone know if -pgmF is supposed to work in the ghci repl?  i thought it did, but now it seems to be ignoring it.
17:23:40 <gwern> what's -pgmF running over the source files?
17:23:48 <mmorrow> heh, yeah. it's great in that i didn't know all the stuff you can do with it. the imports is a pain.
17:24:05 <rieux> my own preprocessor.
17:24:19 <rieux> though i've been giving it random stuff, like /usr/bin/rev and sldfjlsdfsidfjsd
17:24:25 <rieux> and it doesn't seem to have any effect
17:24:28 <gwern> rieux: did you look at the manual? I remember there being restrictions on -pgmF
17:24:31 <rieux> i did
17:24:31 <mapreduce> sldfjlsdfsidfjsd is notorious.
17:24:32 <mmorrow> gwern: here's the whole one-shot evaluator (stdin -> stdout): http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=39
17:24:44 <rieux> it says it's dynamic
17:24:56 <rieux> and doesn't say anything explicitly about the REPL, though i suppose it still might not work.
17:25:06 <gwern> mmorrow: for example, I don't understand why one can load modules or files but not have them in scope
17:25:15 <gwern> I mean, what's the point of that?
17:25:21 <mmorrow> gwern: yeah, the docs are non-existent. it's read the code or nothing :) :| :/ :)
17:25:41 <gwern> 'mapM_ (uncurry setResourceLimit)' <-- deja vu :)
17:26:12 <gwern> mmorrow: why not use ghc-paths instead of hardwiring it?
17:26:39 <mmorrow> gwern: oh i will in good time, just hacked this together yesterday/today
17:27:32 <Olathe> @check \a b -> b == 0 || mod a b == 0 || ((signum (mod a b) == signum b) && (signum (rem a b) == signum a))
17:27:33 <lambdabot>   "OK, passed 500 tests."
17:27:35 <gwern> hm. no extended defaulting? that's gonna hurt quick/smallchecks
17:27:42 <mmorrow> gwern: also, the Posix.Resources was a bug in the particular 6.9 i had at that time (i think i already told you this?), so Resources work like a charm
17:28:15 <gwern> mmorrow: oh, is that what it was? good good
17:28:56 <gwern> mmorrow: it looks pretty good to me, although I personslly dislike all that pipe stuff and would seek to use a library like HSH or something
17:29:22 <mmorrow> gwern: my real reason for writing this is i want to wire it into this minimal webserver i have, then couple that to a javascript repl to get a "ghci"-in-a-webbrowser
17:29:34 <gwern> although I guess to get it as capable as mueval you'll have to uglify the code some
17:29:38 * gwern sighs
17:29:46 <mmorrow> heh
17:29:52 <rieux> gwern: thanks... i'm gonna try to hack emacs to run it, perhaps
17:30:03 <mmorrow> it's way hackish also how i had to capture stderr
17:30:28 <gwern> rieux: good luck
17:32:01 * gwern nods. best to let something like hsh deal with the pain. goerzen knows more than I do about using the low-level haskell lib interface to the shell, anyway
17:32:41 <mmorrow> gwern: but in the webbrowser, there won't be a shell involved
17:32:49 <mmorrow> with the bot, yes
17:33:06 <mmorrow> err, i meant webserver
17:33:21 <gwern> hm, how would the javascript call out to the binary?
17:33:28 <gwern> just a straight process invoke?
17:33:56 <mmorrow> it'd make requests to the webserver, which will then run that expression/whatever, and send output in its response
17:34:10 <mmorrow> and the js would handle the page
17:34:45 <mmorrow> the haskell being eval'ed could even generate the js which then displays the ouput/genrates haskell/whatever crazy thing someone thinks of
17:34:52 <gwern> oh, so the evaluator is going to be linked into the web app itself then
17:34:57 <mmorrow> exactly
17:35:08 <mmorrow> it's literally a web/server/
17:35:17 <gwern> compile haskell to js... maybe you should be using yhc and not the ghc api
17:35:18 <mmorrow> so it has full control
17:35:30 * mmorrow shudders
17:35:53 <mmorrow> the haskell/js interaction isn't essential, it's just one possibility
17:36:31 <mmorrow> you could just  $ curl 'http:localhost:4242?hs=fix (0:)'
17:36:52 <gwern> madness
17:36:56 <mmorrow> haha
17:38:11 <gwern> so what's the purpose of a ghci-on-web anyway?
17:38:14 <mmorrow> you should totally just use the ghc-api itself instead of hint, for more control. this dynCompileExpr function is almost perfectly secure by default
17:38:30 <mmorrow> gwern: i dunno yet ;)
17:38:45 <gwern> mmorrow: no, if I abandoned hint, I'd have to reimplement the sandboxing and qualified imports stuff myself
17:39:03 <gwern> no thanks. it works well right now. maybe when everyone (and ubuntu...) upgrades to 6.10
17:39:21 <mmorrow> gwern: the qualified imports aren't an issue though is the best part of it, only what you explicitly import is visible
17:39:34 <mmorrow> gwern: heh, cool.
17:39:59 <gwern> mmorrow: so you explicitly import data.map and prelude, you still get clashes
17:40:19 <mmorrow> ah, yeah. that is a problem.
17:40:47 * gwern suspects very few people want Data.Map ^ ~Prelude
17:41:41 <mmorrow> i'm thinking of, in the same way that the checkNames function does, to run over all the idents in an expr, and ... say you have
17:42:07 <gwern> mmorrow: hm, automatically convert everything into a fully qualified name?
17:42:10 <gwern> interesting idea
17:42:30 <mmorrow> M.insertWith insert ....  , it'd turn insert into  Data.List.insert, and M.insertWith into Data.Map.insertWith
17:42:33 <mmorrow> yeah, exactly
17:42:54 <gwern> sounds pretty good actually
17:43:11 <mmorrow> that seems pretty easy to do also, since the function which parses and runs over all the names already exists..
17:43:15 <mmorrow> totally
17:43:32 <gwern> you should suggest that on the GHC API feature request for qualified imports
17:43:46 <gwern> 'oh hai guyz, I has an idea
17:44:15 <thoughtpolice> orly?
17:44:42 <gwern> thoughtpolice: yahrly
17:44:42 <mmorrow> i think i will. but in the meantime, that can be added on top of the ghc-api with minimal effort given what we already have
17:45:10 <mmorrow> can has stdio? visible "HAI"
17:45:36 <gwern> 'see? ur type problem wuz not so hard'
17:45:57 <mmorrow> flip conCAtMap
17:46:14 <mmorrow> that's my fav
17:46:36 * gwern likes 'halp! iz trapped in teh IO monad!'
17:47:22 * gwern notes with amusment
17:47:30 <gwern> that rocking chairs make good computer chairs
17:48:02 <mmorrow> make sure the puter doesn't fall off of it!
17:48:09 <mmorrow> geez
17:48:34 <Trinithis> >
17:48:41 <gwern> it really is comfortable. the only downside is the high arms
17:48:44 <Trinithis> > show bot
17:48:45 <lambdabot>   mueval: Prelude.read: no parse
17:48:56 <gwern> much more comfortable than the regular office chair I was using
17:49:15 <gwern> fo shizzle
17:53:53 * gwern reads about Indian logic. isn't it crazy that scholars have to write stuff like 'Vasubandhu (400 - 800 CE)'?
17:54:54 <Pseudonym> Damn, he lived to a ripe old age.
17:55:09 <gwern> that's one way to interpret it, yes...
17:56:26 <gwern> the other way is 'damn, the indians kept cruddy records!'
17:56:37 <idnar> how does that work?
17:56:43 <gwern> 'we can't even pin him down in anything less than half a millenium!'
17:56:52 <idnar> oh
17:57:02 <Pseudonym> They remembered what he wrote.  Why is it important when he wrote it?
17:57:09 <Pseudonym> People keep records that are important to them.
17:57:33 <gwern> Pseudonym: context. who was he responding to, who responded to him? in philosophy and logic, half the battle is knowing who the target is
17:58:09 <gwern> try understanding wittgenstein's Tractatus or Philosophical Investigations without knowing logical atomism and russell, and see how far you get. and that was a culture in living memory
17:58:10 <Pseudonym> I'm not saying it's not important to _us_.
17:58:27 <Pseudonym> I'm saying it wasn't important to whoever was responsible for preserving books.
17:59:13 <gwern> that isn't necessarily true. many important works have been lost
17:59:50 <gwern> sophocles and plato and aristotle have always been important to people, and yet, we still lost a lot.
18:03:07 <EvilTerran> well, in the days before printing presses, people tended to be a bit laxer about taking regulat backups, i suspect
18:04:10 <znutar> Never underestimate the amount people will falsify dates when an older or newer source is considered more authoritative, also
18:04:11 <EvilTerran> and libraries were rather more likely to be set on fire by Carthaginians in those days
18:09:40 * gwern doesn't recall the carthaginians doing much firesetting. the romans, yes
18:13:12 <gwern> come to think of it, the carthaginians weren't doing much of anything after a little while
18:13:20 <EvilTerran> good point, yeah, i imagine the romans burnt all the greek stuff that was worth burning before hannibal got the chance
18:14:06 <gwern> well, we can credit them with burning a bit of the library of alexandria, and certainly neither hannibal nor hamilcar got anywhere near egypt
18:14:34 <gwern> (I doubt gaul, spain, or northern italy had any libraries worth the kindling)
18:15:01 <EvilTerran> quite
18:15:31 <EvilTerran> i just chose an arbitrary race that was around the right time period :P
18:16:24 <gwern> 'oh no! they've research Library Burning! that means Barbarian Frenzy will be unlocked next turn'
18:17:37 <paczesiowa> http://hpaste.org/10379 MonadError without fundeps seems to work ok
18:19:41 <paczesiowa> and it would be neat to write instance (MonadError e m) => MonadError (Either e e2) m
18:20:19 <paczesiowa> come on! say something
18:20:22 <dons> gwern: thoughts on the new xmonad.org layout http://xmonad.org/
18:20:24 <dons> ?
18:20:25 <lambdabot> Title: xmonad | the tiling window manager that rocks
18:20:33 <gwern> dons: I like it in general
18:20:46 <gwern> dons: although I think the 'tabs' could be more prominent
18:20:53 <dons> mm. yes.
18:21:10 <gwern> as it is, I don't think it's clear that they take you to a 'different' view, I guess
18:21:24 <gwern> they look more or less like random links just like the rest on the page
18:21:40 <gwern> perhaps some sort of 'bar' running across the length of the screen?
18:21:45 <dons> mm
18:22:01 <gwern> I mean, it's good that the current one is highlighted
18:22:05 <paczesiowa> maybe you should make more "tiled" layout?
18:22:13 <paczesiowa> that would be kinda funny
18:22:14 <gwern> (honestly, I wouldn't've figured it out without the highlighting)
18:22:45 <gwern> paczesiowa: in a sense, it is tiled. a fullscreen layout with 4 frames...
18:23:13 <thoughtpolice> dons: i like it
18:23:42 <gwern> I like the content best tho
18:23:52 <gwern> 'Why should I use xmonad?'
18:24:07 <gwern> that's a good section
18:28:59 <dons> ok. thanks guys.
18:30:02 <dons> i think twifkak did a great job with this.
18:42:42 <Taggnostr> can I do with a functional language like haskell all the things I do with other kind of non-functional languages?
18:43:00 <shrughes> @faq can haskell do that?
18:43:01 <lambdabot> The answer is: Yes! Haskell can do that.
18:43:34 <Taggnostr> ok, does it make sense or is better to use haskell only for some kind of programs?
18:44:11 <dons> no, it's a serious language for any kind of development.
18:44:23 <dons> look at hackage.haskell.org to get a sense of what people are doing with it: hint: everything.
18:45:48 <Taggnostr> ok, so I have to do a program that given the colors of a resistor it returns the value in ohm (the value is encoded in 4-5 colored lines on every resistor)
18:45:50 <dons> it is particularly strong in data structures, concurrency, transformation, correctness, and math.
18:46:01 <dons> ok. so that's a simple translatoin problem.
18:46:07 <dons> should be very easy.
18:46:19 <dons> define a data structure to represent the resistor.
18:46:25 <dons> and a function to compute the ohms from each band.
18:46:39 <Taggnostr> I don't know much about haskell but this could be a chance to try it, but I may need your help
18:46:56 <dons> actually , we even have similar tutorials on the wiki, http://haskell.org/haskellwiki/Smart_constructors#Runtime_checking_:_smart_constructors
18:46:58 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
18:47:03 <dons> data Resistor = Metal   Bands | Ceramic Bands
18:47:07 <dons>  type Bands = Int
18:47:20 <dons>  metalResistor :: Bands -> Resistor
18:47:20 <dons>  metalResistor n | n < 4 || n > 8 = error "Invalid number of resistor bands"
18:47:20 <dons>                  | otherwise      = Metal n
18:47:22 <ddarius> This is too easy.  I say it should take as input digital photographs of real resistors and output the Ohmic value.
18:47:39 <Taggnostr> http://en.wikipedia.org/wiki/Resistor#Resistor_marking here's the table
18:47:40 <lambdabot> Title: Resistor - Wikipedia, the free encyclopedia
18:47:44 <shrughes> no, have it take xray scans in case they were painted wrong
18:47:59 <dons> ddarius: but that's just an interpreter :)
18:48:04 <Taggnostr> uhm
18:48:06 <dons> everything's either an interpreter or a compiler.
18:48:30 <dons> parse the image, constructing a Resistor type, and spit out the result in ohms
18:48:53 <dons> you got ghci installed, Taggnostr ?
18:48:56 <mgsloan> and compiler is just a special case of interpreter, where the program on running happens to output another program
18:49:18 <Taggnostr> yep, though I never used ghc, only ghci
18:49:33 <dons> ok. ghc produces much faster code. so good for your final app.
18:51:32 <Taggnostr> I guess that doing a GUI is too difficult for now, so I'll do a console program
18:51:54 <Taggnostr> I could start with displaying that table with the values and ask the user to input the color codes
18:52:11 <Taggnostr> parse what he entered and send this values to the function
18:53:21 <Taggnostr> in order to print the table do I need several putStrLn or is there any other way, like multiline strings?
18:54:44 <EvilTerran> \n
18:55:14 <EvilTerran> haskell String & Char syntax is pretty much the same as C syntax for the equivalents
18:58:06 <mmorrow> Taggnostr: you can do either way
18:58:29 <mmorrow> putStrLn (unlines ["asdf","jkl;"])
18:58:39 <mmorrow> mapM_ putStrLn ["asdf","jkl;"]
18:58:40 <EvilTerran> ?src putStrLn
18:58:40 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
18:58:52 <Taggnostr> ok, unlines could work
19:00:13 <mmorrow> > let xs = [[0..9],[10..19]] in render . vcat . map (hcat . punctuate semi . map int) $ xs
19:00:14 <lambdabot>   "0;1;2;3;4;5;6;7;8;9\n10;11;12;13;14;15;16;17;18;19"
19:00:25 <mmorrow> > let xs = [[0..9],[10..19]] in vcat . map (hcat . punctuate semi . map int) $ xs
19:00:26 <lambdabot>   0;1;2;3;4;5;6;7;8;9
19:00:26 <lambdabot>  10;11;12;13;14;15;16;17;18;19
19:00:35 <mmorrow> Text.PrettyPrint is also realy nice
19:00:40 <mmorrow> (for formatting text)
19:01:07 <EvilTerran> ?src unlines
19:01:07 <lambdabot> unlines = concatMap (++ "\n")
19:01:48 <mmorrow> > brackets (text "asdf")
19:01:50 <lambdabot>   [asdf]
19:01:54 <mmorrow> > braces (text "asdf")
19:01:56 <lambdabot>   {asdf}
19:02:31 <mmorrow> > (!!4) $ iterate (braces . brackets . parens) (double pi)
19:02:32 <lambdabot>   {[({[({[({[(3.141592653589793)]})]})]})]}
19:08:04 <bbs> hey guys is it correct to say xs = [1,2,3] or must it be xs ==
19:08:11 <bbs> [1,2,3]
19:08:36 <mmorrow> > int 42 <> colon $+$ nest 3 (comma <> double pi $+$ semi)
19:08:37 <lambdabot>   42:
19:08:37 <lambdabot>     ,3.141592653589793
19:08:37 <lambdabot>     ;
19:09:16 <mmorrow> > let xs = [1,2,3] in xs == [1..3]
19:09:18 <lambdabot>   True
19:09:27 <EvilTerran> bbs, = is a piece of special syntax, == is a bog-standard infix operator
19:09:52 <bbs> EvilTerran: cool, whats special about it? :)
19:09:55 <EvilTerran> = is only for definitions, == only for equality
19:10:01 <bbs> ok thanks
19:10:08 <EvilTerran> bbs, you couldn't define it yourself from within haskell :)
19:10:11 <EvilTerran> ?src Eq
19:10:11 <lambdabot> class  Eq a  where
19:10:11 <lambdabot>     (==), (/=)   :: a -> a -> Bool
19:10:12 <Olathe> > let (==) = (+) in 5 == 6
19:10:14 <lambdabot>   11
19:10:27 <Olathe> > let (=) = (+) in 5 = 6
19:10:28 <lambdabot>   mueval: Prelude.read: no parse
19:10:34 <Olathe> OMG kaboom !
19:10:38 <mmorrow> > let z@[x,_,y] = y : x :  [1,2,3] in z
19:10:39 <lambdabot>   mueval: Prelude.read: no parse
19:10:40 <lambdabot>  mueval: *** Exception: /tmp/744294581068662...
19:10:49 <EvilTerran> ?src [] (==)
19:10:49 <lambdabot> []     == []     = True
19:10:49 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
19:10:49 <lambdabot> _      == _        = False
19:11:02 <EvilTerran> ?src Maybe (==)
19:11:03 <lambdabot> Source not found. I am sorry.
19:11:03 <Olathe> @src [] (++)
19:11:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:11:09 <EvilTerran> ?src () (==)
19:11:09 <lambdabot> () == () = True
19:11:09 <Olathe> @src [] fmap
19:11:09 <lambdabot> fmap = map
19:11:12 <EvilTerran> hehe
19:11:22 <Olathe> @src [] return
19:11:23 <lambdabot> return x    = [x]
19:11:27 <Olathe> Neat :)
19:11:29 <EvilTerran> Olathe, (++) isn't a class method (at least as far as @src knows)
19:11:31 <Olathe> @src Maybe return
19:11:31 <lambdabot> return              = Just
19:11:33 <EvilTerran> ?src (++)
19:11:33 <lambdabot> []     ++ ys = ys
19:11:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:11:33 <lambdabot> -- OR
19:11:33 <lambdabot> xs ++ ys = foldr (:) ys xs
19:11:35 <Olathe> Ahh.
19:11:45 <Olathe> --OR ?
19:11:47 <Olathe> Heheh
19:12:04 <EvilTerran> you have to give a type before the function name for class methods, but not for functions defined outside a class def
19:12:04 <Olathe> @src Either return
19:12:05 <lambdabot> return        = Right
19:12:23 <Olathe> @src [] mzero
19:12:24 <lambdabot> mzero = []
19:12:26 <Olathe> @src [] mplus
19:12:27 <lambdabot> mplus = (++)
19:12:39 <Olathe> @src Maybe mplus
19:12:39 <lambdabot> Nothing `mplus` ys = ys
19:12:39 <lambdabot> xs      `mplus` ys = xs
19:12:49 <EvilTerran> Olathe, lambdabot works in pm too, btw
19:12:56 <Olathe> Alright :)
19:15:49 <Taggnostr> wow, I loaded the module
19:16:11 <Taggnostr> and it seems to work too
19:16:52 <nha_> how come theres no libraries for spatial queries (R-tree, KD-tree etc) on hackage?
19:18:10 <dmwit> > let z@(x:_:y:_) = y:x:[1,2,3] in z -- mmorrow
19:18:11 <lambdabot>   [1,1,1,2,3]
19:18:50 <dmwit> nha_: ...nobody's written one yet?
19:19:29 <mmorrow> dmwit: ah, of course. :)
19:19:35 <nha_> just making sure before i start writing one haha
19:19:41 <ddarius> I'm sure someone has written one
19:19:41 <Olathe> O-o
19:19:47 <nha_> yea thats what i thought
19:20:01 <mmorrow> ddarius: where?
19:20:20 <Olathe> > let z@(x:_:y:_:_) = y:x:[1,2,3] in z
19:20:21 <lambdabot>   [1,1,1,2,3]
19:20:45 <ddarius> mmorrow: How do I know?  Certainly there are several raytracers and such and I specifically remember several people on this channel talking about it several months ago.
19:20:47 <Olathe> > let z@(x:_:_:y:_) = y:x:[1,2,3] in z
19:20:48 <lambdabot>   [2,2,1,2,3]
19:21:56 <Cale> It's possible though that nobody's written anything general enough to warrant packaging. I'm sure there are things which come close.
19:22:12 <byorgey> I wrote a simple quadtree implementation for ICFP, but yeah, it was too simplistic to warrant packaging up for hackage.
19:22:17 <Cale> byorgey wrote a quadtree... yes :)
19:22:30 <byorgey> hehe =)
19:22:54 <Taggnostr> how can I convert to int a number entered with getLine?
19:23:08 <lispy> > read "123" :: Int
19:23:08 <Olathe> @type getLine
19:23:10 <lambdabot>   123
19:23:11 <lambdabot> IO String
19:23:13 <ddarius> :t readLn
19:23:15 <lambdabot> forall a. (Read a) => IO a
19:23:31 <Olathe> (getLine >>= read)::(IO Int)
19:23:44 <dons> a quadtree would be useful.
19:23:47 <ddarius> @src readLn
19:23:47 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
19:23:48 <dmwit> Olathe: You want "fmap read getLine"... or just "readLn".
19:23:54 <Olathe> Ahh.
19:24:01 <Olathe> I haven't done much IO yet.
19:24:13 <mmorrow> nha_: hmm, well i guess if you can without epic implement one, probably write your own :)
19:24:15 <Taggnostr> readLn instead of getLine?
19:24:18 <ddarius> I don't think I've ever actually used readLn
19:24:38 <lispy> :t readIO
19:24:39 <lambdabot> forall a. (Read a) => String -> IO a
19:24:44 <Olathe> @type readLn
19:24:45 <lambdabot> forall a. (Read a) => IO a
19:24:55 <Olathe> Ahh, quite nice.
19:24:56 <lispy> what is this readIO?
19:25:13 <ddarius> lispy: It's like read only it throws an IOError instead of error
19:25:14 <dmwit> It uses fail instead of error, so you can catch it.
19:25:20 <Olathe> > readLn :: Int
19:25:21 <lambdabot>   Couldn't match expected type `Int' against inferred type `IO a'
19:25:24 <mmorrow> ] let z@(x:_:_:y:_) = y:x:[1,x,3]++reverse z in z
19:25:24 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:25:27 <Olathe> > readLn :: IO Int
19:25:28 <lispy> hmm
19:25:29 <lambdabot>   mueval: Prelude.read: no parse
19:25:29 <lambdabot>  mueval: *** Exception: "<IO Int>"
19:25:30 <mmorrow> ] let z@(x:_:_:y:_) = y:x:[1,x,3] in z
19:25:31 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:25:35 <mmorrow> > let z@(x:_:_:y:_) = y:x:[1,x,3] in z
19:25:46 <mmorrow> > let z@(x:_:_:y:_) = y:x:[1,3] in z
19:25:48 <lambdabot>   [3,3,1,3]
19:25:48 <dmwit> mmorrow: x is unbound
19:25:50 <lambdabot>   thread killed
19:25:54 <gwern> Olathe: what is mueval supposed to evaluate 'readLn :: IO Int' to?
19:26:05 <mmorrow> ] let z@(x:_:_:y:_) = 0:y:x:[1,3] in z
19:26:05 <lunabot>  [0,1,0,1,3]
19:26:08 <Olathe> gwern: An IO Int, of course ;)
19:26:13 <lispy> Yeah, I guess read should reall be read :: (Read a, MonadError e m) => String -> m e a
19:26:17 <mmorrow> dmwit: nice call
19:26:27 <mmorrow> ] let z@(x:_:_:y:_) = 0:y:x:[1,3]++reverse z in z
19:26:28 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:26:28 <Taggnostr> and to output an int? putStrLn seems to strings only
19:26:32 <gwern> Olathe: er, mueval doesn't do IO in the first place, and where does the Int come from?
19:26:47 <lispy> ?src print
19:26:48 <lambdabot> print x = putStrLn (show x)
19:26:52 <mmorrow> ] let z@(x:_:_:y:_) = 0:y:x:[1,3]++concatMap reverse (tails z) in z
19:26:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
19:26:53 <gwern> nothing from nothing, as the saying goes
19:27:00 <Olathe> Ahh.
19:27:06 <mmorrow> > let z@(x:_:_:y:_) = 0:y:x:[1,3]++concatMap reverse (inits z) in z
19:27:08 <lambdabot>   [0,1,0,1,3,0,1,0,0,1,0,1,0,1,0,3,1,0,1,0,0,3,1,0,1,0,1,0,3,1,0,1,0,0,1,0,3,...
19:27:17 <Taggnostr> nice, let's see if it works
19:27:32 <mmorrow> > let z@(x:_:_:y:_) = 0:y:x:[1,3] : fmap reverse (inits z) in z
19:27:33 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:27:33 <lambdabot>        Expect...
19:28:07 <lispy> gotta watch out for those infinite types
19:31:45 <bbs> EvilTerran: this is what i get ERROR "fuckedup.hs":4 - Syntax error in input (unexpected symbol "xs")
19:31:48 <bbs> damn
19:32:51 <dmwit> That's hard to diagnose without the accompanying source.
19:32:54 <dmwit> ?hpaste
19:32:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:34:09 <Taggnostr> why negative exponents don't work?
19:34:14 <tibbe_> @seen dons
19:34:15 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 10m 30s ago.
19:34:50 <ddarius> > 3^^-4
19:34:51 <lambdabot>   mueval: Prelude.read: no parse
19:34:58 <ddarius> > 3^^ -4
19:34:59 <lambdabot>       precedence parsing error
19:34:59 <lambdabot>          cannot mix `(^^)' [infixr 8] and pref...
19:35:04 <ddarius> > 3^^ (-4)
19:35:06 <lambdabot>   1.2345679012345678e-2
19:35:22 <Taggnostr> > 10^2
19:35:23 <lambdabot>   100
19:35:27 <Taggnostr> > 10^^2
19:35:29 <lambdabot>   100.0
19:35:49 <mlh> I think it would be nice to have spaces be significant in that context, to hint about precedence
19:36:05 <mlh> but no doubt that's a ahem minority view
19:36:17 <dmwit> Taggnostr: Negative exponents need a (/), which general Num doesn't provide.
19:37:02 <Taggnostr> uhm
19:37:21 <mlh> in other words,  3 - 4 should be ok but 3 -4 and 3-4 be an error, 3 + -4 ok
19:37:30 <Taggnostr> is there some type that works as a float and as an int?
19:39:22 <mmorrow> > let link xs = let node l x r = Node x [l,r] ; let go l [] r = (l,r) ; go l (a:as) r = let x = node l a y ; (y,z) = go x xs r in (x,z) in let (l,r) = go r xs l in x in link [0..4]
19:39:24 <lambdabot>   mueval: Prelude.read: no parse
19:39:27 <mmorrow> crap
19:39:58 <Taggnostr> it's complaining about a int that should be a float but I can't find it
19:40:48 <Taggnostr> http://hpaste.org/10380
19:40:55 <bbs> i don't get whats wrong with this line... :(
19:40:55 <bbs> xs = [1,2,3,4,5]
19:41:21 <Taggnostr> what am I doing wrong?
19:41:58 <Taggnostr> I changed ^ with ^^ and the last Int with Float
19:42:50 <glguy> :t (^^)
19:42:52 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
19:43:24 <Taggnostr> value should be an int, the multiplier should always be a float because I used ^^ and int*float should be a float, right?
19:43:24 <glguy> Taggnostr: you'll want to paste the error message as well
19:43:36 <bbs> :t [1,2,3,4]
19:43:38 <lambdabot> forall t. (Num t) => [t]
19:43:40 <glguy> Taggnostr: you can't multiply an Int with a Float
19:43:54 <glguy> :t (*)
19:43:55 <lambdabot> forall a. (Num a) => a -> a -> a
19:44:03 <Taggnostr> why not? in the interpreter it seems to work
19:44:05 <glguy> you'll have to covert the Int to a float with fromIntegral
19:44:17 <glguy> Taggnostr: no, in the interpreter you are multiplying two floats
19:44:28 * Taggnostr begins to hate types
19:44:49 <Taggnostr> so (fromIntegral value) * multiplier?
19:45:24 <Taggnostr> ok, it seems to work now
19:45:31 <dons> > (2 :: Int) * (pi :: Float)
19:45:32 <lambdabot>   Couldn't match expected type `Int' against inferred type `Float'
19:45:44 <dons> > 2 * pi
19:45:46 <lambdabot>   6.283185307179586
19:45:48 <dons> :t 2 * pi
19:45:50 <lambdabot> forall t. (Floating t) => t
19:46:04 <dons> the '2' there is a numeric literal, whose type will be chosen so that the typescheck.
19:46:12 <dons> :t (*)
19:46:13 <lambdabot> forall a. (Num a) => a -> a -> a
19:46:17 <dons> says it has to be the same type as pi.
19:46:57 <Taggnostr> ok
19:47:27 <Taggnostr> so the program seem to work
19:47:45 <Taggnostr> can I include a range in the 'case'?
19:48:20 <Taggnostr> like [0..5] -> 0; [6..10] -> 10; ?
19:48:34 <dons> nice idea.
19:48:51 <dons> case e of x | x `elem` [0..5] -> 0 ; ...
19:48:58 <Taggnostr> so if the value is 0,1,2,3,4,5 it will return 0, if it's 6,7,8,9,10 it will return 10?
19:49:12 <dons> put a guard on the alternative.
19:50:00 <Taggnostr> what should I do if I get a wrong value? raise an error?
19:50:23 <dons> well, that'll crash your program
19:50:31 <dons> perhaps return Just x ,or Nothing, in case of error?
19:50:58 <Taggnostr> uhm
19:51:33 <Taggnostr> the function should allow only values in a defined range and possibly display some warning if the user enter a wrong value
19:51:33 <dons> foo x | x `elem` [0..5] = Just x | otherwise       = Nothing
19:51:47 <dons> so perhaps check, return Nothing in the wrong case, then tell the user.
19:52:04 <Taggnostr> I could also check when the user insert the value though
19:52:07 <mmorrow> ] let link xs = let node l x r = Node x [l,r] ; go l [] r = (r,l) ; go l (a:as) r = (let x = node l a r ; (y,z) = go x as r  in (x,z)) in let (x,z) = go z xs x in x ; left 0 _ = [] ; left n (Node a [x,_]) = a : left (n-1) x in left 10 (link [0..4])
19:52:07 <lunabot>   Not in scope: data constructor `Node'<interactive>:1:240: Not in sc...
19:52:10 <mmorrow> no
19:52:13 <mmorrow> > let link xs = let node l x r = Node x [l,r] ; go l [] r = (r,l) ; go l (a:as) r = (let x = node l a r ; (y,z) = go x as r  in (x,z)) in let (x,z) = go z xs x in x ; left 0 _ = [] ; left n (Node a [x,_]) = a : left (n-1) x in left 10 (link [0..4])
19:52:14 <lambdabot>   [0,4,3,2,1,0,4,3,2,1]
19:52:55 <Taggnostr> what is Just x?
19:53:14 <shrughes> > Just 3
19:53:16 <lambdabot>   Just 3
19:53:19 <Cale> If x :: t, then Just x :: Maybe t
19:53:21 <mmorrow> x :: a ==> Just x :: Maybe a
19:53:26 <mmorrow> :)
19:53:45 <Taggnostr> and what is Maybe t?
19:53:49 <mmorrow> a type
19:53:53 <mmorrow> @src Maybe
19:53:53 <lambdabot> data Maybe a = Nothing | Just a
19:54:03 <shrughes> Taggnostr, sometimes you need to return a sentinel value, like the way indexOf returns -1 in Java.  that's what Maybe's for
19:54:21 <Taggnostr> > (Just 3) * 5
19:54:22 <lambdabot>       No instance for (Num (Maybe t))
19:54:22 <lambdabot>        arising from the literal `5' at ...
19:54:25 <nha_> what uses the .ds file extension? the code looks exactly like haskell
19:55:06 <mmorrow> > let maybeToList Nothing = [] ; maybeToList (Just x) = [x] in map maybeToList [Nothing,Just 42, Just 2000, Nothing]
19:55:08 <lambdabot>   [[],[42],[2000],[]]
19:55:33 <mmorrow> > map (maybe [] (:[])) [Nothing,Just 42, Just 2000, Nothing]
19:55:34 <lambdabot>   [[],[42],[2000],[]]
19:55:41 <Taggnostr> if I put a Just x in the case it will fail when I'll multiply x with another value
19:55:49 <Stinger> > (Just 3) >>= (*5)
19:55:50 <lambdabot>       No instance for (Num (Maybe b))
19:55:50 <lambdabot>        arising from the literal `3' at ...
19:56:01 <mmorrow> > fmap (*2) (Just 20)
19:56:03 <lambdabot>   Just 40
19:56:23 <mmorrow> > maybe 0 (*2) (Just 20)
19:56:25 <lambdabot>   40
19:56:28 <shrughes> > case (Just 5) of { Just x -> Just (5 * x) ; Nothing -> Nothing }
19:56:29 <lambdabot>   Just 25
19:57:02 <mmorrow> > (*5) `fmap` (Just 5)
19:57:04 <lambdabot>   Just 25
19:57:09 <mmorrow> > (*5) <$> (Just 5)
19:57:10 <lambdabot>   Just 25
19:57:22 <Taggnostr> uhm
19:57:29 <mmorrow> @src (<$>)
19:57:30 <lambdabot> f <$> a = fmap f a
19:57:45 <mmorrow> there're the exact same thing
19:57:52 <mmorrow> *they're
19:58:20 <mmorrow> the nice thing about fmap is it works over all kinds of different structures
19:58:32 <mmorrow> > fmap (*12) [0..4]
19:58:34 <lambdabot>   [0,12,24,36,48]
19:58:39 <mmorrow> > fmap (*12) (Just 20)
19:58:40 <lambdabot>   Just 240
19:58:56 <shrughes> > fmap (* 12) (2 +) 5
19:58:58 <lambdabot>   84
19:58:58 <Taggnostr> I'm getting lost
19:59:02 <mmorrow> > (fmap . fmap) (*12) [Just 0, Just 20, Nothing]
19:59:04 <lambdabot>   [Just 0,Just 240,Nothing]
19:59:17 <mmorrow> think of it like
19:59:30 <mmorrow> fmap f (Just x) = Just (f x)
19:59:39 <Taggnostr> are the comments --foo?
19:59:48 <mmorrow> um
19:59:50 <mmorrow> ?
19:59:52 <mmorrow> oh
19:59:54 <mmorrow> yes
19:59:57 <mmorrow> -- comment
20:00:04 <Stinger> > -- I'm a comment
20:00:05 <lambdabot>   mueval: Prelude.read: no parse
20:00:08 <Stinger> heh
20:00:17 <mmorrow> > 4 + {- 3 * 098765 -} 1
20:00:19 <lambdabot>   5
20:00:47 <mmorrow> {- -} === /* */
20:01:08 <mmorrow> you'll see also
20:01:18 <mmorrow> -- | some stuff about a function/data
20:01:26 <mmorrow> f :: ...
20:01:30 <mmorrow> f x = ...
20:01:30 <Taggnostr> it doesn't work anymore
20:01:36 <mmorrow> what
20:02:00 <Taggnostr> case c of \n c `elem` [0..9] -> 10^^c
20:02:01 <ddarius> > let "I'm" --> "an operator" = 6 in 3
20:02:02 <lambdabot>   3
20:02:32 <shrughes> wait, 6 in 3 is 1/2 :)
20:02:49 <mmorrow> > let _ in case () of _ -> 3
20:02:50 <lambdabot>   mueval: Prelude.read: no parse
20:03:06 <mmorrow> > let _ = undefined in case () of _ -> 3
20:03:08 <lambdabot>   3
20:03:54 <mmorrow> > let pattern = "expression" in case "expression" of pattern -> "expression"
20:03:55 <lambdabot>   "expression"
20:04:09 <Taggnostr> :O?
20:04:16 <sheyll> :t (2+)
20:04:17 <lambdabot> forall t. (Num t) => t -> t
20:04:46 <sheyll> :t (*12) <$> (+2)
20:04:47 <lambdabot> forall a. (Num a) => a -> a
20:05:05 <sheyll> hmm
20:05:06 <mmorrow> > let (x:_:y:_) = [0..] in case x + y of 1 -> "four!" ; 2 -> "seven!"
20:05:07 <sheyll> nice
20:05:07 <lambdabot>   "seven!"
20:06:08 <Taggnostr> maybe I should give up
20:06:15 <Taggnostr> and sleep 4 hours
20:06:24 <mmorrow> sleep is good
20:06:37 <sheyll> even only 4h
20:06:37 <Taggnostr> sleep 4 hours is not good
20:06:49 <mmorrow> i suppose it depends
20:07:14 <sheyll> Taggnostr: comon hack a little longer... who needs sleep?
20:07:26 <dolio> 4 1/2 would be better from what I've heard.
20:07:59 <sheyll> n * 3 hours is good
20:08:05 <sheyll> I've read...
20:09:28 <Taggnostr> > let foo = case 3 of 3 `elem` [0..5] -> "yep!" ; _ -> "nope!"
20:09:28 <lambdabot>   mueval: Prelude.read: no parse
20:09:36 <Taggnostr> > let foo = case 3 of 3 `elem` [0..5] -> "yep!" ; _ -> "nope!" in foo
20:09:37 <lambdabot>   mueval: Prelude.read: no parse
20:09:50 <Taggnostr> > let foo = case 3 of | 3 `elem` [0..5] -> "yep!" ; _ -> "nope!" in foo
20:09:51 <lambdabot>   mueval: Prelude.read: no parse
20:10:38 <Taggnostr> uhm
20:11:05 <shrughes> Taggnostr, like, look at some haskell tutorial :)
20:11:06 <sheyll> :t liftM
20:11:07 <ddarius> sheyll: let n be 0
20:11:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:11:10 <Cale> > let foo = case 3 of _ | 3 `elem` [0..5] -> "yep!" ; | -> "nope!" in foo
20:11:12 <lambdabot>   mueval: Prelude.read: no parse
20:11:20 <Cale> > let foo = case 3 of _ | 3 `elem` [0..5] -> "yep!" ; | otherwise -> "nope!" in foo
20:11:21 <lambdabot>   mueval: Prelude.read: no parse
20:11:24 <Cale> > let foo = case 3 of _ | 3 `elem` [0..5] -> "yep!" | otherwise -> "nope!" in foo
20:11:26 <lambdabot>   "yep!"
20:11:30 <Cale> There we go :)
20:11:34 <Cale> tricky flattening :)
20:11:50 <Taggnostr> cool, I'm almost as good as Cale
20:12:13 <shrughes> > let foo = case foo of _ | 3 `elem` [0..5] -> "yep!" | otherwise -> "nope!" in foo
20:12:14 <lambdabot>   "yep!"
20:12:36 <Cale> You wouldn't normally use a case for that.
20:12:51 <Cale> > let foo = if 3 `elem` [0..5] then "yep!" else "nope!" in foo
20:12:52 <lambdabot>   "yep!"
20:13:00 <Taggnostr> btw I can't make it work here
20:13:13 <Cale> let foo = case foo of
20:13:25 <Cale>                _ | 3 `elem` [0..5] -> "yep!"
20:13:28 <shrughes> :P
20:13:36 <Cale>                _ | otherwise       -> "nope!"
20:13:41 <Cale>  in foo
20:14:02 <Taggnostr> I was putting the _ | in the same line of the case
20:14:25 <Cale> You can do that.
20:14:39 <Cale> let foo = case foo of _ | 3 `elem` [0..5] -> "yep!"
20:14:44 <shrughes> > let foo | 3 `elem` [0..5] = "yep!" | otherwise = "nope!" in foo
20:14:45 <lambdabot>   "yep!"
20:14:51 <Cale>                         | otherwise       -> "nope!"
20:14:53 <Taggnostr> but the 3 on a new line
20:14:54 <shrughes> stop that "case foo of" business, that was a joke :P
20:15:10 <sheyll> (foldl (\a b ->(show a) ++ ("h  or  ") ++ (show b) ++"h ")  "I've read that " [1..5])  ++" are good to sleep"
20:15:14 <sheyll> > (foldl (\a b ->(show a) ++ ("h  or  ") ++ (show b) ++"h ")  "I've read that " [1..5])  ++" are good to sleep"
20:15:15 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"I've read th...
20:15:50 <sheyll> > (foldl (\a b ->a ++ ("h  or  ") ++ (show b) ++"h ")  "I've read that " [1..5])  ++" are good to sleep"
20:15:52 <lambdabot>   "I've read that h  or  1h h  or  2h h  or  3h h  or  4h h  or  5h  are good...
20:16:39 <Taggnostr> so, I have http://hpaste.org/10381
20:16:49 <sheyll> > (foldl (\a b ->a  ++ (show (3 * b)) ++"h ")  "I've read that " [1..5])  ++" are good to sleep"
20:16:50 <lambdabot>   "I've read that 3h 6h 9h 12h 15h  are good to sleep"
20:16:59 <sheyll> sorry
20:17:02 <sheyll> :)
20:17:58 <Taggnostr> is that ok?
20:21:47 * Taggnostr falls asleep
20:22:09 <sheyll> hmm it works?
20:22:23 <sheyll> I mean yeah it works
20:22:34 <sheyll> cool
20:23:40 <Taggnostr> what?
20:23:54 <sheyll> why FLoat?
20:24:18 <Taggnostr> because the -1/-2 powers have to be float
20:24:24 <sheyll> ahh
20:24:51 <Taggnostr> actually for those I had to use float, and everything else had to be turned to float too
20:25:41 <sheyll> well I would say that this look good...I am not a haskell guru but that code is clean and readable
20:26:27 <Taggnostr> I find it ugly, even if it's indeed readable
20:26:44 <sheyll> why?
20:27:35 <shrughes> meh.  The printTable function couldn't be much better, the main function is fine; the calcOhms function has fromIntegral, which is automatically ugly: the product is soiled and ruined
20:27:58 <Taggnostr> the main has too many repetitions
20:28:07 <shrughes> if anything, I might write:
20:29:12 <Cale> where is the code that you're discussing?
20:29:34 <Taggnostr> http://hpaste.org/10381
20:30:44 <sheyll> why is the product ruined?
20:31:33 <jsnx> does anybody have `-optl-static` working on linux?
20:31:40 <Cale> Taggnostr: to factor out the repetition in main, I suppose you could write a prompt function.
20:31:46 <shrughes> sheyll: tongue in cheek
20:31:55 <Taggnostr> yep
20:32:27 <shrughes> you could write (fromIntegral value) * 10 ^^ power, instead of repeating 10^^ in 3 places
20:32:35 <sheyll> shrughes: ??
20:32:53 <shrughes> sheyll: I wasn't being serious
20:32:54 <Taggnostr> that too
20:33:55 <Taggnostr> well, time to sleep, I'll try with some better program some other time
20:34:14 <sheyll> good n8
20:34:17 <dolio> :t (...)
20:34:18 <lambdabot> forall a. (Num a) => [a] -> [a]
20:34:31 <shrughes> what
20:34:32 <sheyll> @src (...)
20:34:32 <lambdabot> Source not found.
20:34:36 <shrughes> > (2 ... 5)
20:34:37 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
20:34:42 <shrughes> > (2 ...)
20:34:44 <lambdabot>       No instance for (Num [a])
20:34:44 <lambdabot>        arising from the literal `2' at <inter...
20:34:48 <dolio> > ([1, 5, 74, 3]...)
20:34:49 <lambdabot>   [1,5,74,3,-413,-1379,-3100,-5781,-9627,-14843,-21634,-30205,-40761,-53507,-...
20:34:55 <shrughes> oh, retarded me.
20:35:19 <sheyll> ????
20:35:30 <dolio> > ([1, 4, 9, 16] ...)
20:35:32 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
20:35:38 <shrughes> sheyll: it uses some basic mathematical operations and combines them to guess the sequence
20:35:49 <sheyll> funny
20:35:58 <Cale> > ([1, 1, 2, 3] ...)
20:35:58 <ddarius> [a,b,c] <- mapM (\s -> putStr (s++" band:") >> readLn) ["1st", "2nd", "3rd"]
20:35:59 <lambdabot>   [1,1,2,3,3,1,-4,-13,-27,-47,-74,-109,-153,-207,-272,-349,-439,-543,-662,-79...
20:36:08 <Taggnostr> uhm, one last program before to sleep
20:36:09 <shrughes> not like it uses OEIS or anything, that can't be done by a pure function :P
20:36:17 <shrughes> wait, what?
20:36:18 <Taggnostr> where I find chr?
20:36:19 <Cale> > extendSequence [1,1,2,3]
20:36:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
20:36:22 <dolio> It can with some evil.
20:36:32 <Cale> > extendSequence [2,3,5]
20:36:34 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:36:35 <shrughes> Cale, what is this?
20:36:40 <Cale> oeis :)
20:36:42 <Taggnostr> rather, how can I import Data.chr?
20:36:56 <Cale> Taggnostr: import Data.Char
20:37:10 <shrughes> it's Data.Char.chr
20:37:14 <bd_> > extendSequence [0x7f,0x45,0x4c,0x46,0x02,0x01,0x01,0x00]
20:37:16 <lambdabot>   [127,69,76,70,2,1,1,0]
20:37:32 <Taggnostr> > import Data.Char.chr
20:37:33 <lambdabot>   mueval: Prelude.read: no parse
20:37:36 <bd_> Bah. What kind of sequence extender can't operate on ELF headers too? :)
20:37:38 <Taggnostr> > chr 65
20:37:38 <shrughes> > ([1]...)
20:37:40 <lambdabot>   'A'
20:37:40 <lambdabot>  Terminated
20:37:48 <shrughes> > ([1,1]...)
20:37:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:38:01 <shrughes> > ([2,3,5]...)
20:38:03 <lambdabot>   [2,3,5,8,12,17,23,30,38,47,57,68,80,93,107,122,138,155,173,192,212,233,255,...
20:38:06 <shrughes> okay enough :P
20:38:20 <Taggnostr> is there an unlines functions that takes a separator as an arg?
20:38:30 <Cale> > extendSequence [1,2,3,6,11]
20:38:32 <lambdabot>   [1,2,3,6,11,23,47,106,235,551,1301,3159,7741,19320,48629,123867,317955,8230...
20:38:33 <sheyll> use zip
20:38:39 <Cale> > describeSequence [1,2,3,6,11]
20:38:41 <lambdabot>   Just "Number of trees with n unlabeled nodes."
20:38:43 <Pseudonym> > let { avl 0 = 1; avl 1 = 1; avl n = (avl (n-1))^2 + 2*avl(n-1)*avl(n-2) } in extendSequence [ avl i | i <- [0..5] ]
20:38:45 <lambdabot>   [1,1,3,15,315,108675,11878720875,141106591466142946875,19911070158545297149...
20:38:50 <Pseudonym> Woo.
20:39:43 <shrughes> (...) should throw some non-polynomials once in a while
20:40:19 <Pseudonym> > ([1,1,3,15,315,108675]...)
20:40:21 <lambdabot>   [1,1,3,15,315,108675,647585,2261477,6023949,13544989,27078199,49628019,8505...
20:40:34 <ddarius> > let { avl 0 = 1; avl 1 = 1; avl n = (avl (n-1))^2 + 2*avl(n-1)*avl(n-2) } in describeSequence [ avl i | i <- [0..5] ]
20:40:36 <lambdabot>   Just "AVL trees of height n."
20:40:44 <Taggnostr> how can I back to the prelude? I'm in *Main>
20:40:48 <Pseudonym> Nice.
20:40:56 <Cale> > extendSequence [product [1,3..2*n-1] | n <- [1..5]]
20:40:58 <lambdabot>   [1,3,15,105,945,10395,135135,2027025,34459425,654729075,13749310575,3162341...
20:41:22 <Cale> > extendSequence [product [1,4..3*n-1] | n <- [1..5]]
20:41:24 <lambdabot>   [1,4,28,280,3640,58240,1106560,24344320,608608000,17041024000,528271744000,...
20:41:57 <Cale> Taggnostr: you mean, unload your file? All the stuff in the Prelude should still be in scope.
20:42:31 <Cale> (unless you specifically imported the Prelude qualified or something)
20:42:33 <shrughes> > let (....) = cycle in ([9,3,9,3,9,3,9,3,9,3,9,3]....) -- :P
20:42:35 <lambdabot>   [9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,3,9,...
20:42:36 <Taggnostr> Prelude> import Data.Char.chr
20:42:36 <Taggnostr> syntax: :module [+/-] [*]M1 ... [*]Mn
20:43:15 <shrughes> :m + Data.Char
20:43:20 <Pseudonym> > describeSequence [9,3,9,3,9,3]
20:43:22 <lambdabot>   Just "Number of steps needed for juggler sequence (A094683) started at n to...
20:49:31 <dmwit> Taggnostr: :m + Data.Char
20:49:58 <dmwit> Taggnostr: You can also ":m" all on its own to clear out all the loaded modules and go back to just the Prelude.
20:57:33 <hackage> Uploaded to hackage: twidge 0.99.3
21:03:30 <bos> @pl \a b -> b <$> a
21:03:30 <lambdabot> flip (<$>)
21:03:33 <bos> meh.
21:03:59 <dons> heh
21:05:02 <Taggnostr> > let foo (x:xs) = xs++[x] in 'n':(reverse ('t':(map chr (map (+102) (foo (reverse [1..3]))))))
21:05:03 <lambdabot>   "night"
21:05:07 <Taggnostr> \o/
21:05:14 <dons> huh, ghc struggles on src/HAppS/Server/Facebook.hs
21:05:18 <dons> i wonder why..
21:05:24 * dons didn't know happs had a facebook module..
21:06:24 <Taggnostr> now I have 3 hours (and something) to sleep
22:25:30 <retybok> How do I write an IO() function that does nothing?
22:26:11 <ivanm> retybok: return ()
22:26:25 <ivanm> i.e. foo :: IO (); foo = return ()
22:26:41 <retybok> ivanm: thanks
22:26:54 <ivanm> no worries
22:57:34 <hackage> Uploaded to hackage: mps 0.0.0.1
23:01:16 <dons> mps' dependencies are overly constrained
23:01:23 <dons> directory (>=1.0.0.1),
23:01:26 <dons> bytestring (>=0.9.1.2),
23:01:30 <dons> too tight!
23:05:19 <dons> jinjing: ^^
23:05:32 <dons> maybe it should just depend on 'bytestring' and 'directory' that come with ghc 6.8
23:06:06 <jinjing> test
23:06:06 <lambdabot> jinjing: You have 1 new message. '/msg lambdabot @messages' to read it.
23:06:19 <dons> :)
23:08:03 <jinjing> dons: not really, i'll relax it
23:12:40 <jinjing> @bot
23:12:41 <lambdabot> :)
23:43:07 <ivanm> with runCommand, does the program pause until the command I've run finishes?
23:43:56 <ulfdoz_> -rw-------  1 root  wheel    3914 Sep 18  2007 sendmail.mc
23:44:01 <ulfdoz_> echan, sorry
23:44:05 <ivanm> heh
23:46:08 <Beelsebob> ivanm: I was under the impression it returned the pid of the new process
23:46:20 <ivanm> ahhh
23:46:26 <Beelsebob> and if you wanted to wait for it to finish, you could do runCommand >>= waitForProcess
23:46:33 <ivanm> *nod*
23:48:19 <ivanm> thanks Beelsebob, that's fixed it
23:48:25 <Beelsebob> :)
23:50:08 <Level2Tech> bang my farter
23:50:26 <ivanm> wtf?
23:50:40 <adu> wtf?
23:50:47 <ivanm> potential spammer?
23:51:00 <Beelsebob> not the worlds fastest if he is though
23:51:06 --- mode: ChanServ set +o dons
23:51:10 <Beelsebob> maybe just a troll
23:52:56 <adu> if he is, then he's the kind who comes running up to you, and then does nothing
23:53:46 <Beelsebob> maybe he's busy having an argument in another channel where he got a more exciting response?
23:53:50 <glguy> dons opping didn't catch my eye, but Beelsebob's use of the word "troll" dragged my attention from an ssh session :)
23:54:28 <ivanm> Beelsebob: apparently this is the only channel (on freenode at least) he's signed in to...
23:54:36 <Beelsebob> oh, odd
23:54:38 <glguy> ivanm: if you set yourself +i
23:54:48 <glguy> then only people in the channels you are know you are in them
23:54:51 <dons> there's like 10 guys standing around, waiting to hit him if he steps out of line :)
23:54:52 <ivanm> ahhhh
23:54:55 --- mode: ChanServ set -o dons
23:54:57 <ivanm> lol
23:55:10 <ivanm> maybe we've scared him from saying anything? ;-)
23:55:31 <Beelsebob> haha
23:56:08 <ivanm> apparently he's been here before: http://www.cse.unsw.edu.au/~dons/irc/haskell/08.07.16
23:56:17 <ivanm> started as ball_licker, then turned into Level2Tech
23:56:18 <Beelsebob> maybe it's an overzealous-op-trap -- i.e. every time it gets kicked it autojoins and spams some more?
23:56:47 * Level2Tech bends over and spreads hi ass cheeks in preparation for ivanm
23:57:19 <Level2Tech> mmmmm
23:57:34 <hackage> Uploaded to hackage: mps 0.0.0.1.1
23:57:34 <hackage> Uploaded to hackage: panda 0.0.0.4.1
23:57:34 <hackage> Uploaded to hackage: panda 0.0.0.4
23:57:40 --- mode: ChanServ set +o dons
23:57:42 --- mode: dons set +b *!*n=ask@*.lf.br.cox.net
23:57:42 --- kick: Level2Tech was kicked by dons (dons)
23:57:44 --- mode: ChanServ set -o dons
23:57:50 <ivanm> thanks dons
23:57:53 <dons> i gotta get to bed. deal with him elsewhere if needed.
