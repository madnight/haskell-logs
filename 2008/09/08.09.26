00:00:20 <rwbarton> @djinn Either Void b -> b
00:00:21 <lambdabot> f a =
00:00:21 <lambdabot>     case a of
00:00:21 <lambdabot>     Left b -> void b
00:00:21 <lambdabot>     Right c -> c
00:00:30 <rwbarton> what is "void"?
00:00:44 <dolio> Eliminator for Void.
00:01:10 <rwbarton> Oh, I see.
00:01:25 <rwbarton> @djinn Void -> a
00:01:26 <lambdabot> f = void
00:02:44 <pprakash> can somebody point me to Haskell syntax which discusses type declarations like this: type CFoldLeft coll val m seed = coll -> CollEnumerator val m seed
00:04:17 <dolio> There's not much to it. It declares a type alias.
00:04:32 <dolio> type Name variables = some-other-type
00:05:32 <dolio> Then any time 'Name variables' appears in a type, it gets replaced with 'some-other-type'.
00:05:32 <pprakash> essentially, rhs replaces the left
00:05:40 <dolio> Yeah.
00:05:52 <pprakash> great, thanks
00:06:17 <dolio> Of course, GHC keeps them around (sometimes) in error messages and such.
00:06:33 <dolio> Keeps the left-hand side, that is.
00:07:39 <unmarshal>  is there any case where you'd use the state monad in combination of the reader monad or is that redundant
00:07:46 <unmarshal> reading monad transformers step by step and they do it
00:07:53 <unmarshal> but i think its just for didactic purposes
00:08:27 <unmarshal> especially if what you're keeping state of is the same thing as what you'd be using reader for
00:09:16 <dolio> Well, if you have some global state that's mutable, and some that's read only, separating them makes sure you don't accidentally modify the read-only part.
00:09:18 <unmarshal> i.e.: type PMonad a = State Portfolio a
00:09:21 <unmarshal> type PMonad2 a = ReaderT Portfolio (State Portfolio a)
00:09:29 <unmarshal> dolio: yeah that makes sense
00:09:34 <unmarshal> but in that case i just mentioned it doesn't
00:09:44 <unmarshal> i just wanted to be sure i'm understanding this right
00:09:55 <dolio> There's even RWS and RWST that has reader writer and state all together in one monad.
00:10:23 <dolio> For read-only input, mutable state and write-only output, all separate.
00:10:37 <dolio> (And somewhat more efficient than stacking 3 transformers.
00:10:39 <unmarshal> yeah that's cool
00:10:44 <unmarshal> excellent
00:10:46 <unmarshal> thank you!
00:11:01 <unmarshal> i'm building some finance tools and need a mutable portfolio type, so this will work out nicely
00:11:04 <dolio> That's what you lose by keeping them separate. Performance.
00:11:18 <dolio> In the stacked transformer case, that is.
00:11:19 <rwbarton> Your PMonad2 case seems like the one where you'd want separate ReaderT and State the most, if your intention is to always have the original Portfolio accessible.
00:11:54 <unmarshal> cool, def wasn't what i intended but if i needed to do that, it makes sense
00:11:59 <unmarshal> thanks guys
00:12:00 <unmarshal> night
00:12:10 <rwbarton> I wonder if the optimizer can often do more with Reader x than State x, too
00:15:42 <Baughn> "ld warning: in /usr/local/lib/libgmp.dylib, file is not of required architecture" <-- *grumble*
00:26:32 <retybok> why doesn't this work? http://hpaste.org/10690
00:27:07 <rwbarton> @djinn (((a -> Void) -> a) -> a) -> ((a -> Void) -> Void) -> a
00:27:07 <lambdabot> f a b = a (\ c -> void (b c))
00:28:49 <rwbarton> retybok: Because where clauses attach to declarations, not expressions.  You can write  let a = ... in putStrLn $ show (a+a), or move the "let a = ..." to its own line and drop the "in".
00:29:45 <retybok> rwbarton: so there is no way to do this with a where clause?
00:30:35 <retybok> ah, I hadn't understood the let on its own line
00:30:40 <retybok> makes sense
00:30:41 <retybok> thanks
00:30:44 <rwbarton> retybok: No useful way.  (If you really wanted to, you could write  let action = putStrLn $ show (a+a) where a = ... in action)
00:31:00 <retybok> thanks again
00:31:07 <rwbarton> No problem
00:31:28 <rwbarton> :t \callcc b -> callcc (\c -> c (b c))
00:31:29 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> ((t -> t1) -> t) -> t2
00:35:49 <mc__> Hi! I have a problem with QuickCheck. I've read through the manual. But I dont get  how I'd test a method with 100 random numbers for example.
00:36:54 <mc__> Could someone please point me out the right direction?
00:38:15 <stulli> mc__: i suggest RWH: http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
00:38:24 <_zenon_> mc__ that would be the scaling of the tests
00:38:27 <lambdabot> Title: Chapter 11. Testing and quality assurance, http://tinyurl.com/46ejvv
00:39:33 <mc__> thank you! I did not realize that the book teaches QuickCheck
00:41:37 <_zenon_> stulli, actually, that was quite a good link, I was about to put the link to the original manual :P
00:58:07 <hackage> Uploaded to hackage: supercollider-midi 0.1
01:10:36 <retybok> Can someone explain what's wrong here? http://hpaste.org/10691
01:14:34 <hml> anyone here runing haskepp on mac os x?
01:14:38 <BeelsebobWork> retybok: most likely a garbage collection issue, but is there a reason you aren't just using parMap?
01:14:50 <FunctorSalad> hackage: heh... unsafeCollideHadrons
01:15:18 <BeelsebobWork> hml: haskepp?
01:15:46 <retybok> BeelsebobWork: no reason, where is it defined?
01:15:52 <glguy> let a=((read . head) args)::Int   is just let a = read (head args) :: Int
01:16:00 <glguy> no need for extra functions and parens ;)
01:16:04 <BeelsebobWork> retybok: Control.Parallel.Strategies
01:16:09 <retybok> glguy: I'm still learning :)
01:16:10 <glguy> did you run it with the RTS flag for more kernel threads
01:16:16 <glguy> -N2 iirc
01:16:19 <quicksilver> hml: yes, many of us are.
01:16:20 <retybok> glguy: yes, I did
01:16:25 <quicksilver> hml: osx quite popular in this channel.
01:16:26 <retybok> It only runs on one cpu
01:16:43 <retybok> BeelsebobWork: actually I wanted to experiment a bit with the Concurrent framework
01:17:13 <Itkovian> meuning
01:17:14 <BeelsebobWork> retybok: heh, I'd suggest experimenting with things that don't only need the nice pure interface of Control.Parallel.Strategies :)
01:17:32 <BeelsebobWork> also, you need to compile with -threaded, and run with +RTS -N<number of system threads>
01:18:08 <retybok> BeelsebobWork: I did all this stuff
01:18:14 <retybok> I'll try again, just to make sure
01:18:22 <hml> BeelsebobWork , quicksilver : what is the easiest way to install  haskell on osx?
01:18:23 <BeelsebobWork> then probably just the garbage collector getting in your way
01:18:29 <BeelsebobWork> hml: sudo port install ghc
01:18:51 <hml> err, isntall mac ports? I heard that it was shit
01:19:13 <BeelsebobWork> no, there seems to be some odd rumor to that effect going round
01:19:16 <BeelsebobWork> dunno why
01:19:26 <BeelsebobWork> MacPorts is a fairly stable, mature package management system
01:19:30 <hml> let's have a vote; ppl vote whether mac port is good or bad
01:19:36 <tnks> dibblego: so I just did an "apt-get search" for haskell packages, and it's nothing near what's on hackage.  Is there a packaging mechanism for Haskell?  Or do people just copy around source code?
01:19:39 <quicksilver> macports is less shit than the alternatives
01:19:47 <BeelsebobWork> I think quicksilver nailed it there
01:19:49 <retybok> yep, only one cpu
01:19:55 <quicksilver> I think source-based package management is about as sensible as wood-burning combustion engines
01:19:58 <dibblego> tnks, yes cabal-install
01:20:03 <quicksilver> but, since macports works, I use it.
01:20:03 <BeelsebobWork> retybok: profile it -- I bet you'll find most of your time is spent in the garbage collector
01:20:14 <ivanm> quicksilver: what's wrong with source-based?
01:20:24 <BeelsebobWork> ivanm: it takes friking ages
01:20:26 <quicksilver> ivanm: I don't want to waste 8 hours compiling ghc and apache.
01:20:26 <BeelsebobWork> and gats you no gain
01:20:35 <quicksilver> that's what I have distributions for
01:20:48 <quicksilver> installing a new package on this box (debian with decent net connection) takes under a second.
01:20:55 <quicksilver> installing a new package on my mac takes 1 hour - 8 hours
01:21:01 <quicksilver> depending how hard they are to compile.
01:21:17 <BeelsebobWork> unfortunately, fink, which has a binary distribution option is much more shit than ports
01:21:23 <retybok> BeelsebobWork: all right, I'll do that. I'll try with parMap too. Thanks for the help!
01:21:25 <BeelsebobWork> (in that it's very poorly maintained)
01:21:29 <quicksilver> fink's heart is in the right place
01:21:36 <quicksilver> but it doesn't have enough people working on it
01:21:40 <BeelsebobWork> idd
01:21:43 <quicksilver> so it doesn't have enough packages / new enough packages.
01:21:55 <BeelsebobWork> IIRC ghc was at 6.6 until only a month or two ago
01:22:13 <ivanm> quicksilver: only takes me about 25 minutes to compile ghc... :p
01:22:21 <quicksilver> ivanm: yes, but that's not really the point.
01:22:25 <ivanm> heh
01:22:30 <quicksilver> (8 hours was my iBook G4)
01:22:36 <ivanm> so you don't think much of all of us that use gentoo? ;-)
01:22:38 <BeelsebobWork> ivanm: snap, you have an 8 core mac pro don't you
01:22:56 <quicksilver> ivanm: I don't presume to question your decisions.
01:22:59 <quicksilver> I'm explaining mine.
01:23:05 <ivanm> BeelsebobWork: nope, just a c2d laptop
01:23:08 <BeelsebobWork> o.O
01:23:09 <ivanm> quicksilver: yeah, I know ;-)
01:23:15 <BeelsebobWork> how on earth do you compile ghc that fast?
01:23:21 <BeelsebobWork> my C2D laptop takes about 2 hours
01:23:38 <tnks> sound like some Gentoo fan made a noise.
01:23:51 <ivanm> BeelsebobWork: make that 1/2 hr
01:24:03 <ivanm> how old is yours?
01:24:05 <quicksilver> retybok: I had a bit of al ook at your code.
01:24:11 <BeelsebobWork> not very, but it is only 2Ghz
01:24:20 <quicksilver> retybok: most likely I can't answer your quesiton without seeing the definition of ll and facto.
01:24:25 <BeelsebobWork> but yeh... an 8 core 2.8Ghz MacPro takes 25 minutes
01:24:33 <BeelsebobWork> so I'm struggling to see how you're getting that speed
01:24:49 <quicksilver> retybok: I agree with BeelsebobWork that parMap is a better approach; but it's still interesting to ask why nmergeIO isn't working.
01:24:55 <Gast_314_> http://www.meine-privaten-nacktvideos.net?id=4812552
01:24:58 <BeelsebobWork> quicksilver: true dat
01:25:00 <quicksilver> BeelsebobWork: difference between single compile and full bootstrap?
01:25:06 <BeelsebobWork> quicksilver: could well be
01:25:09 <quicksilver> BeelsebobWork: macports does a full bootstrap IIRC.
01:25:10 <lambdabot> Title: Meine Homepage mit meiner Webcam , Bilder und Videos
01:25:11 <BeelsebobWork> I am talking full bootstrap here
01:25:33 <quicksilver> single compiles of ghc are 15-30 minutes on fast 2-core hardware
01:25:49 <quicksilver> but a full bootstrap is more (3x more perhaps?)
01:27:12 <moenicke> morning
01:28:52 <mc__> is it a good idea or simply useless to test little input methods?
01:29:52 <retybok> quicksilver: I'll post the full code in a moment
01:32:48 <retybok> Ok, I've reiplemented it with parMap, still no luck: http://hpaste.org/10692
01:34:50 <retybok> I should probably mention that I'm running the code on a bi dual-core xeon machine
01:35:27 <retybok> I think it's acutally a quad-xeon machine (no dual core), if that matters at all
01:35:51 <BeelsebobWork> retybok: use rnf, not rwhnf
01:36:18 <retybok> ok, I will try. What's the difference?
01:36:39 <BeelsebobWork> rwhnf reduces to weak head normal form -- i.e. it discovers it's not an empty list and then stops computing anything
01:36:47 <BeelsebobWork> meanwhile rnf reduces to normal form, completely
01:36:54 <retybok> awesome!
01:37:00 <retybok> I thought it was the contrary
01:37:05 <retybok> thanks for fixing my problem
01:37:12 <BeelsebobWork> that's got you the parallelism?
01:37:20 <retybok> yep
01:37:29 <BeelsebobWork> :)
01:37:48 <BeelsebobWork> that's possibly where it was missing in the other version too
01:37:50 <mc____>   where     (a,b) <- getInput     what is wrong with his?
01:38:04 <mc____> getInput returns IO (Int,Int)
01:38:17 <quicksilver> retybok: that was probably your problem with nmergeIO too
01:38:24 <quicksilver> retybok: all it does it 'evaluate' the lists
01:38:26 <BeelsebobWork> mc____: binds using <- must happen in a do block
01:38:32 <Deewiant> you can't put a monadic binding in a where
01:38:37 <quicksilver> (Which just forces them to [])
01:38:38 <BeelsebobWork> otherwise it doesn't know what order to do it in
01:38:42 <quicksilver> (or (x:xs))
01:39:12 <retybok> maybe they should be renamed to "no_parallelism" "good_parallelism_chose_me" for noobs like me ;-)
01:39:20 <BeelsebobWork> haha
01:39:32 <BeelsebobWork> rnf requires an NFData instance
01:39:50 <BeelsebobWork> so it's not quite so easy to use
01:40:15 <quicksilver> BeelsebobWork: I dislike the choice of 'r' because I keep thinking it should stand for 'recursive'
01:40:24 <quicksilver> (actually it presumably stands for 'reduce to')
01:40:29 <quicksilver> maybe that's just me, though.
01:40:34 <BeelsebobWork> quicksilver: yeh, I always guessed at reduce to too
01:40:43 <BeelsebobWork> nf and whnf would be nicer though
01:40:46 <retybok> most basic types seem to implement NFData, though
01:40:52 <BeelsebobWork> I didn't see the whnf in rwhnf first time I read it
01:40:53 <quicksilver> yes, any 'simple data' type should
01:40:58 <BeelsebobWork> retybok: yep
01:41:04 <quicksilver> basically anything that doesn't have functions or actions buried inside it.
01:41:16 <BeelsebobWork> all you need to do to implement it is write something for your type that forces all the inner bits
01:41:22 <retybok> that does limit quite a bit
01:41:25 <BeelsebobWork> i.e. strictness anotations everywhere
01:41:54 <quicksilver> retybok: I find all this slightly unfortunate
01:42:09 <quicksilver> Control.Parallel.Strategies requires you to understand GHC's evaluation model in quite some detail
01:42:21 <quicksilver> much more detail than the haskell language spec.
01:42:26 <BeelsebobWork> I'm not sure that's true quicksilver
01:42:30 <quicksilver> that feels like an abstraction leak, to me.
01:42:38 <quicksilver> but I don't have a better suggestion.
01:42:40 <BeelsebobWork> you don't need to understand any more than what "normal form" and "weak head normal form" are
01:42:51 <BeelsebobWork> which admitedly is more than you should
01:43:02 <mc__> Is it possible to test a method that does not take any parameters  but only does input using QuickCheck?
01:43:02 <BeelsebobWork> but it's not something specific to ghc -- it's general to all non-strict evaluators
01:43:17 <quicksilver> it's a specific ghc choice that seq = rwhnf
01:43:31 <BeelsebobWork> oh?
01:43:38 <quicksilver> seq is permitted, by its spec to do anything between rwhnf and rnf as long as it doesn't create bottoms
01:43:43 <BeelsebobWork> ah, I see
01:44:27 <BeelsebobWork> so rwhnf is not actually necessarily what it says on the tin
01:44:40 <BeelsebobWork> but instead "reduce to whatever your compiler reduces to when using seq"
01:44:54 <quicksilver> I'm not sure if that's true. Maybe rwhnf should be defined to be what it says on the tine
01:45:01 <quicksilver> but rwhnf = seq might not be true
01:45:09 <quicksilver> I honestly don't know.
01:45:20 <quicksilver> it just feels like the abstraction boundary is a bit weak here.
01:45:24 <BeelsebobWork> I'm fairly sure in the current implementation it is seq
01:45:41 <BeelsebobWork> yeh, but the abstraction boundary is weak in general when adding parallelism anotations
01:45:43 <quicksilver> I want to be able to define sensible parallel evaluation strategies without having to explain so much.
01:45:52 <quicksilver> but maybe I'm just too optimistic.
01:45:59 <BeelsebobWork> parallelism has nothing to do with what your program *is*, only to do with how it should be computed
01:46:25 <BeelsebobWork> so the only way to fix it is to build a super-clever-compiler that recognises where to stick `par`s itself
01:49:16 <quicksilver> BeelsebobWork: that's the perfect fix, certainly.
01:49:26 <quicksilver> I'm not sure it's feasible even in principle.
01:49:26 <mapreduce> Or a monad that does it?
01:49:34 <quicksilver> although I'm sure you can get some good heursitics.
01:49:41 <quicksilver> (feasible to get it perfect, I mean)
01:49:42 <BeelsebobWork> mapreduce: just putting something in a monad doesn't stop it being an abstraction leak
01:50:02 <BeelsebobWork> quicksilver: yeh, I doubt it's feasible too, at least not without a *lot* of inspired research
01:50:38 <mapreduce> BeelsebobWork: Are you considering parallelism to be something that should be hidden from interfaces?
01:50:48 <mapreduce> interfaces = function types
01:51:18 <BeelsebobWork> mapreduce: parallelism is something I should not have to write in my program -- a functional program describes what the result *is*, not how to get it
01:53:17 <BeelsebobWork> o.O did anyone else jut get sent a message from "SecurityTest" saying "dcc send startkeylogger 0 0 0"
01:53:28 <mapreduce> I'm suggesting to use a monad as an evaluation strategy.
01:53:41 <mapreduce> BeelsebobWork: That's an old mirc exploit.
01:54:35 <BeelsebobWork> mapreduce: yeh, I'm suggesting that that would be (a) messy (b) not something I should be describing in my program at all
01:55:11 <quicksilver> mapreduce: we're talking about either not having to specify the strategy at all
01:55:18 <quicksilver> or making the strategy as lightweight as possible
01:55:23 <quicksilver> DPH is in this direction, I think.
01:55:28 <mapreduce> I see.
01:55:37 <quicksilver> Control.Parallel.Strategies is relatively heavyweight
01:55:43 <BeelsebobWork> yeh, I need to have a good dig at DPH
01:55:44 <quicksilver> (although lighter than explicit threads, of course)
01:56:17 <Baughn> I wanted to rush in and claim the, no, Strategies is the best parallelism system yet.. but of course you're right.
01:56:36 <BeelsebobWork> well, strategies *is* the best yet
01:56:39 <BeelsebobWork> it's just not the idea
01:56:41 <BeelsebobWork> ideal*
01:58:08 <hackage> Uploaded to hackage: numeric-prelude 0.0.4
01:59:52 <BeelsebobWork> o.O
02:00:02 <BeelsebobWork> why did ghc just install itself with 700 permissions
02:18:42 <retybok> So no rnf for recursive data types?
02:19:39 <sjanssen> retybok: I'm just jumping in to the conversation here, but why couldn't there be rnf for recursive types?
02:19:51 <sjanssen> you only run into trouble for types that are cyclic
02:20:38 <retybok> sjanssen: well, they're not instances of NFData
02:21:20 <retybok> Maybe it would be possible to implement the interface for your data types, I just don't see how one would do that
02:21:21 <dolio> [a] has a NFData instance.
02:21:55 <retybok> dolio: but data MyType = MyType | Other doesn't
02:23:06 <dolio> So... write one?
02:23:26 <retybok> well, maybe, but I really have no idea how to do it
02:23:38 <retybok> I don't even know where to start
02:23:44 <Baughn> Seen in a duplicate instance declaration error: "instance [overlap ok] Typeable2 IOArray" <-- What sort of syntax is this?
02:24:17 <ivanm> is there a simple way of testing each distinct pair of elements in a list?
02:24:32 <ivanm> s/testing/applying a function on/
02:25:10 <dolio> instance NFData MyType where rnf ...
02:25:14 <BeelsebobWork> retybok: instance NFData MyType where rnf MyType = MyType; rnf Other = Other
02:25:25 <mc__> How would i get the (Int,Int) out of Maybe(Int,Int) ?
02:25:27 <BeelsebobWork> just add appropriate strictness anotations to make sure it all gets evaluated
02:25:28 <sjanssen> retybok: it isn't too difficult.  See the source for that module for examples
02:25:42 <BeelsebobWork> mc__: with pattern matching
02:25:48 <dolio> No strictness annotations needed.
02:26:02 <BeelsebobWork> dolio: they are for more complex things than the type he just gave
02:26:12 <dolio> Matching against a constructor in a branch is strict.
02:26:21 <mc__> BeelsebobWork: f Just(a,b) = ... for example?
02:26:22 <BeelsebobWork> unsafeFromMaybe (Just x) = x; unsafeFromMaybe Nothing = error "this is why it's unsafe"
02:26:23 <sjanssen> strictness annotations are never really needed
02:26:34 <sjanssen> one can always use `seq`
02:26:43 <BeelsebobWork> sjanssen: yes, but seq is just a strictness annotation
02:26:46 <BeelsebobWork> @src seq
02:26:47 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:26:49 <mc__> beelsebobis there a safe way too?
02:26:50 <BeelsebobWork> bah
02:26:58 <BeelsebobWork> mc__: yes -- do something sensible on the Nothing case
02:27:40 <dolio> seq x y = y, of course. :)
02:27:51 <sjanssen> BeelsebobWork: ah, sorry, thought we were talking about bang patterns
02:27:53 <retybok> BeelsebobWork: that's it?
02:28:04 <retybok> will that really do the job?
02:28:20 <BeelsebobWork> retybok: all you need to do is make sure that rnf is a function that really does evaluate something to normal form
02:28:34 <BeelsebobWork> so insert appropriate bang patterns/seqs/other strictenss annotations
02:29:08 <retybok> BeelsebobWork: all right, I see. Thanks!
02:29:17 <mc__> BeelsebobWork:  so what is wrong with this then? http://pastebin.com/m10fb0287
02:29:42 <BeelsebobWork> mc__: it'll give an even less useful error in the Nothing case that what I showed you
02:29:50 <BeelsebobWork> specifically, it'll give you "pattern match failure"
02:30:03 <Botje> mc__: you don't have to incorporate the Maybe into the type ..
02:30:17 <Botje> prop_validateInput (a,b) = .... ==> (a,b) == validateInput (Just (a,b))
02:30:48 <mc__> Botje: that does not change anything
02:31:00 <Botje> yes it does :)
02:31:07 <Botje> it stops quickcheck from generating Nothing as input
02:31:13 <Botje> which you are clearly not interested in
02:31:29 <BeelsebobWork> mc__: the other option is to use the maybe function to lift a non-maybe-typed function up
02:31:56 <BeelsebobWork> > maybe (\(x,y) -> x + y) (error "zomg nothing") (Just (5,6))
02:31:57 <lambdabot>       Overlapping instances for Show ((t, t) -> t)
02:31:57 <lambdabot>        arising from a use ...
02:32:02 <mc__> but I still get the same error
02:32:08 <Botje> what error?
02:32:09 <BeelsebobWork> o.O
02:33:22 <BeelsebobWork> oh, wrong way round
02:33:31 <BeelsebobWork> > maybe (error "zomg nothing") (\(x,y) -> x + y) (Just (5,6))
02:33:33 <lambdabot>   11
02:33:39 <BeelsebobWork> > maybe (error "zomg nothing") (\(x,y) -> x + y) Nothing
02:33:41 <lambdabot>   mueval: Prelude.read: no parse
02:33:41 <lambdabot>  mueval: *** Exception: zomg nothing
02:33:49 <mc__> this error http://pastebin.com/m7cbceebc
02:34:16 <BeelsebobWork> mc__: well... validateInput returns a Maybe
02:34:19 <BeelsebobWork> (a,b) is not a Maybe
02:34:22 <BeelsebobWork> that's easy to fix
02:35:59 <Botje> BeelsebobWork: if validateInput expects (a,b), why are you feeding it Maybe (a,b) ?
02:36:22 <BeelsebobWork> Botje: I'm not... mc__ is
02:36:25 <Botje> doh
02:36:33 * Botje slaps his irssi around a bit
02:36:36 <BeelsebobWork> hehe
02:36:43 <BeelsebobWork> also, I was talking bollocks about the error
02:36:46 <BeelsebobWork> I managed to miss a line
02:36:51 <Botje> mc__: you want prop_blah = Just (a,b) == validateInput (a,b)
02:37:27 <BeelsebobWork> mc__: also, that property is rather vaccuous
02:37:37 <BeelsebobWork> in that you're testing the function by running it's algorithm
02:38:11 <BeelsebobWork> what may be more interesting for you to do is to write a generator that always generates valid data
02:38:18 <BeelsebobWork> and remove the ==> part
02:38:51 <mc__> sorry, connection problems
02:39:02 <mc__> BeelsebobWork: how else should I do the test?
02:39:35 <BeelsebobWork> mc__: I'm not certain in this particular case -- this may be a case of something that's untestable
02:39:45 <BeelsebobWork> or at least, that exact property is
02:40:19 <BeelsebobWork> how about... anything that gets through validateInput doesn't cause the rest of your program to error out?
02:47:29 <mc__> BeelsebobWork: good idea
02:53:40 <mc__> but for that I would first have to implement the rest of the programm, ah what should I use for storing a tictactoe board, what do you think of a map?
02:53:52 <mc__> data structures are still confusing the hell out of me in haskell
02:53:57 <Botje> i'd use an array,really
02:53:59 <BeelsebobWork> I don't see why you would have to do that?
02:54:00 <Twey> An Array, mc__
02:54:20 <BeelsebobWork> you would only have to decide the output type -- most likely Either String SomethingInteresting
02:54:32 <Botje> board = listArray ((0,0),(2,2)) $ repeat Nothing
02:54:46 <mc__> BeelsebobWork: output type?
02:54:49 <Botje> replace Nothing with whatever your "empty place" is going to be :)
02:54:50 <Twey> data Piece = Nought | Cross
02:54:56 <BeelsebobWork> and you wouldn't even need to know what the SomethingInteresting was to write the property
02:54:59 <Twey> And the type would be Maybe Piece
02:55:06 <BeelsebobWork> because all you need to know is that it doesn't produce Left _ ever
02:55:24 <BeelsebobWork> (given input that validateInput said was good)
02:55:31 <Botje> #haskell: parallellising your homework answers!
02:55:41 <Twey> Haha
02:55:45 <BeelsebobWork> :D
02:55:59 <BeelsebobWork> @remember Botje #haskell: parallellising your homework answers!
02:56:00 <lambdabot> Okay.
02:56:10 <Twey> 's my favourite way of responding to homework questions
02:56:36 <mc__> my question was not a homework question
02:56:48 <Twey> Writing them in such a complex way that if the student wants to pass them off as their own, they have to actually understand all the principles involved
02:56:58 <Twey> Aye, mc__, we know :)
02:57:00 <BeelsebobWork> Twey: :D
02:57:24 <BeelsebobWork> Twey: hardly gonna encourage them that they actually want to study haskell
02:57:37 * Twey grins.
02:57:44 <Twey> Maybe not, but when you do it in Javascript it's a riot
02:57:56 <BeelsebobWork> haha
02:58:08 * BeelsebobWork pushes Twey into #squirrelfish
02:58:18 <Twey> #squirrelfish?  What's that then?
02:58:35 <BeelsebobWork> it's the channel for WebKit's javascript engine
02:58:44 <BeelsebobWork> it's reasonably interesting to hang about in actually
02:58:52 <Twey> Oh ah
02:59:02 <BeelsebobWork> mostly to watch them bitching about how V8 is horribly broken
02:59:17 <Twey> No WebKit-using browsers on Linux :(
02:59:23 <BeelsebobWork> yeh there are
02:59:28 <BeelsebobWork> Gnome browser does
02:59:34 <BeelsebobWork> and Konqueror has the option to use it
02:59:50 <BeelsebobWork> I believe they're in the process of dropping khtml
03:00:06 <Twey> Konq 4?
03:00:33 <BeelsebobWork> not sure -- I just know various people who have compiled it with WebKit
03:00:44 <Twey> Oh ah
03:02:52 <quicksilver> there is a compile of epiphany with webkit
03:02:53 <quicksilver> IIRC.
03:22:33 <mc__> whats wrong with this? board // ((0,0) , Just 1)
03:23:00 <mc__> this is the definitoin of board: let board = listArray ((0,0),(2,2)) $ repeat Nothing
03:23:57 <dancor> > let board = listArray ((0,0),(2,2)) $ repeat Nothing in board // [((0,0), Just 1)]
03:23:57 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:24:07 <dancor> anyway (//) takes a List
03:24:16 <mc__> ah
03:24:22 <dancor> lbot is totally wack
03:24:33 <Deewiant> > array
03:24:35 <lambdabot>       Overlapping instances for Show ((i, i) -> [(i, e)] -> Array i e)
03:24:35 <lambdabot>       ...
03:24:41 <Deewiant> > listArray
03:24:41 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:24:45 <Deewiant> > Array
03:24:45 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:24:56 <dancor> @ghc
03:24:56 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
03:25:20 <quicksilver> is listArray unsafe? surely not.
03:25:34 <Deewiant> quicksilver: anything with "Array" in it clearly is
03:25:39 <Deewiant> > let fooArray = 1 in fooArray
03:25:40 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:25:41 <quicksilver> Deewiant: why?
03:25:43 <quicksilver> ah.
03:25:44 <ziman> > let board = array ((0,0),(2,2)) $ zip (range ((0,0),(2,2))) (repeat Nothing) in board // [((0,0), Just 1)]
03:25:46 <lambdabot>   array ((0,0),(2,2)) [((0,0),Just 1),((0,1),Nothing),((0,2),Nothing),((1,0),...
03:25:48 <Deewiant> > let unsafeX = 1 in unsafeX
03:25:49 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:25:58 <quicksilver> mc__: I think there is an array version of //
03:26:10 <mc__> quicksilver: I'm using an array
03:26:24 <quicksilver> yeah, but you need to hide the Data.List version
03:26:29 <quicksilver> and make sure you get the IArray version.
03:26:29 * BeelsebobWork ponders if there's a Haskell board game DSL
03:26:31 <Deewiant> Data.List has \\
03:26:34 <Deewiant> it's // for arrays
03:26:37 <quicksilver> oh.
03:26:44 <BeelsebobWork> would be nice to have a DSL for specifying who's turn it is, how pieces can move etc
03:26:44 <Deewiant> ?ty (\\)
03:26:46 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:26:47 <Deewiant> ?ty (//)
03:26:49 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
03:26:49 <flux> beelsebobwork, I've wondered for a long time if there was a language for designing games
03:26:54 <mc__> I think it is using the array version
03:26:55 <mc__> *Main Data.Array> :t (//) (//) :: (Ix i) => Array i e -> [(i, e)] -> Array i e
03:26:58 <flux> beelsebobwork, but I was thinking something more like Prolog
03:27:03 <quicksilver> mc__: ok, what's the error then?
03:27:07 <BeelsebobWork> that would make sense flux
03:27:11 <quicksilver> mc__: "why doesn't this work" doesn't tell us much ;)
03:27:19 <mc__> quicksilver: sorry
03:27:58 <Deewiant> ?ty ((0,0) , Just 1)
03:27:59 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => ((t, t1), Maybe t2)
03:28:08 <Deewiant> mc__: ^ that's not [(i,e)], that's (i,e)
03:28:20 <flux> beelsebobwork, I've also wondered if you could express short "programs" board games - some games just appear to have quite large sets of rules, but they don't always make a set that feels coherent
03:28:41 <mc__> http://pastebin.com/m39fdcd7d
03:28:44 <flux> sort of like invariants that would make the game work :)
03:28:54 <BeelsebobWork> hmm, that's true
03:29:29 <BeelsebobWork> I guess I was thinking only of games that have sensible rule sets, like chess, checkers or the viking game
03:29:47 <mc__> quicksilver: there you can see the error
03:29:56 <quicksilver> mc__: I think Deewiant already answered :)
03:30:01 <quicksilver> \\ takes a list.
03:30:13 <quicksilver>  // also
03:30:38 <quicksilver> ah well, partly.
03:30:43 <mc__> quicksilver: oh, now I got it
03:30:45 <mc__> thank you both
03:30:50 <quicksilver> what you've written is a list of two things of different types :)
03:30:53 <quicksilver> that's the type error
03:30:53 <flux> beelsebobwork, oh, I was thinking games such as Puerto Rico
03:31:01 <quicksilver> you're missing a set of () just inside the []
03:31:07 <flux> although expressing Carcassonne in a prolog-like language might be interesting..
03:31:12 <BeelsebobWork> flux: yeh, it would be nice to be general enough to cover games like that
03:31:13 <mc__> yeah, already have it, thank you
03:32:03 <quicksilver> BeelsebobWork: I thought about it whilst working on one
03:32:17 <quicksilver> BeelsebobWork: it wasn't obvious to me you could get the right balance between expressivity and elegance
03:32:28 <quicksilver> BeelsebobWork: but, I need to think about it for quite a while longer.
03:33:02 <BeelsebobWork> quicksilver: I think that that's why I wanted to go for a subset of board games -- i.e. ones where you take turns to move pieces about a board
03:33:20 * quicksilver nods
03:33:29 <quicksilver> yes. The trick is choosing the interesting subset.
03:33:35 <BeelsebobWork> yep
03:40:19 <Deewiant> hpaste> Deewiant pasted "Timing various ways of snoc" at http://hpaste.org/10696
03:42:28 <quicksilver> Deewiant: in the case that 'ret' is a list
03:42:35 <quicksilver> Deewiant: $! is only checking if it's empty or not.
03:43:03 <Deewiant> quicksilver: yes, I am aware.
03:43:11 <Deewiant> in this case it's an Int, so that's fine.
03:43:20 <Deewiant> the whole thing is a quick hack.
03:43:25 <quicksilver> oh, I didn't read carefully enough :)
03:44:08 <Deewiant> it's just forcing the computation of 'length'.
03:46:18 <Deewiant> I was interested to see the (:)-reverse method perform so well, that was actually my motivation for doing the whole test.
03:46:53 <Deewiant> and to prove that (++) is really almost as dubious as (!!). ;-)
03:47:08 <Twey> Oo-er
03:48:39 <Twey> So a ++ [b] is better written as `reverse (b : (reverse a))`?
03:48:56 <Twey> What about `a ++ b`?
03:49:37 <Baughn> a++b has O(length a) cost, of course
03:50:27 <Baughn> That's usually fine, so long as you manage to avoid calling ++ again on the result of a++b. Call it in the expression constructing b instead - laziness to the rescue. :P
03:50:31 <Deewiant> Twey: more that, if you're doing a ++ [b] repeatedly you should instead consider building up the [b]s to append with (:) and then reverse it.
03:50:51 <Deewiant> and if you're doing a lot of ++, consider DList.
03:52:17 <Deewiant> correction: for the former, it's not "consider", it's "definitely do it by". :-)
03:52:19 <Twey> Baughn: But then doesn't reverse (b : reverse a) have O(length a^2)?
03:52:40 <Baughn> Twey: Eh? No, that'd be O(2*length a)
03:52:52 * Twey thinks.
03:52:54 <Twey> Oh aye.
03:52:56 <Twey> Sorry, I'm ill :-P
03:53:07 <Twey> Still, it's more expensive than a ++ [b]
03:53:07 <Baughn> I don't see how it could possibly be better than a ++ [b], though
03:53:16 <Baughn> Yeah. That's just /one/ copy.
03:53:26 <Twey> Laziness?
03:53:26 <Axman6> test it
03:53:30 <Deewiant> Doing n snocs with ++ to a list of length l is O(l*n)
03:53:47 <Deewiant> Whereas with (:) and reverse, it's O(l + n).
03:53:50 <Deewiant> I think.
03:53:55 <Baughn> Well, true
03:54:05 <Twey> Er, for my poor dumb brain before we proceed further: what's a snoc?  A cons in reverse?
03:54:10 <Baughn> That's if you reverse once at the end. With just one snoc, it doesn'T help
03:54:12 <Deewiant> Twey: append one element to the end, yeah.
03:54:21 <Twey> Ah
03:54:32 <Twey> Right
03:54:49 <Twey> So why isn't ++ defined in terms of reverse and (:)?
03:54:54 <Baughn> Twey: So: If you *must* snoc repeatedly, use reverse twice instead - or Seq, perhaps. But preferably, build up lots of bs before appending them to a
03:55:11 <quicksilver> Twey: because the win is only there if you (++) more than once.
03:55:11 <Baughn> Twey: Because it'd be slower
03:55:16 <quicksilver> Twey: ++'ing once is fine.
03:55:22 <Twey> Oh right.
03:55:28 <Twey> I seeee.
03:55:32 <quicksilver> so you'd need a clever fusion rule to notice multiple (++)s
03:55:40 <Baughn>  ((a ++ b) ++ c) ++ d is bad
03:55:42 <quicksilver> which would be neat, but like all rule approachs static only.
03:55:43 * Twey nods.
03:55:45 <Twey> It makes sense now.
03:55:47 <Baughn> a ++ (b ++ (c ++ d)) is good
03:55:51 <quicksilver> and if this occurs in real programs, I bet it isn't static.
03:55:53 <Baughn> (And does the same thing, of course)
03:56:19 <Deewiant> quicksilver: what do you mean, static?
03:56:29 <quicksilver> Deewiant: visible in the source
03:56:36 <Deewiant> gotcha.
03:56:39 <quicksilver> possibly after some inlining and so on.
03:56:41 <Baughn> Deewiant: Not triggered at runtime
03:56:46 <Baughn> Which would be nice, too
03:56:56 <quicksilver> 'visible with purely syntactic analysis'
03:57:07 <quicksilver> GHC's optimisations are all syntactic (like all compilers)
03:57:15 <quicksilver> sometimes you wish the RTS could spot things dynamically
03:57:22 <quicksilver> like hotspot.
03:57:24 <Baughn> Has anyone looked at adding support for that?
03:57:36 <quicksilver> in the specific context of GHC, not as far as I know.
03:57:43 <quicksilver> it's hard because GHC erases so much
03:57:46 <Baughn> ..true, but hotspot is much slower than ghc. Clearly, static analysis is a larger win if you must have one
03:57:56 <quicksilver> (and brining back what it erases is a cost)
03:58:05 <quicksilver> actually hotspot is much faster than GHC
03:58:10 <quicksilver> for a hundred different reasons.
03:58:45 <quicksilver> the general problem has been the subject of lots of research I have no doubt.
03:58:45 <Baughn> Hm. Wait, hotspot isn't the default java interpreter?
03:59:11 <Deewiant> it is, it's the Sun JVM.
03:59:26 <Baughn> Thought as much
03:59:41 <quicksilver> hotspot is faster than compiled C, in those cases where the JIT really kicks in.
03:59:42 <Baughn> ..so how come java applications all come across as sluggish, and it scores badly in the shootout?
03:59:50 <quicksilver> if that matters in real programs is up for discussion.
04:00:06 <Deewiant> java applications come across as sluggish mostly because the JVM takes 10 secons to start up, in my experience.
04:00:12 <Axman6> Baughn: think they usually take a long time to initialise
04:00:14 <quicksilver> it's a very impressive piece of software engineering.
04:00:33 <Deewiant> as for its shootout scores, it beats GHC in the single core benchmarks, for instance.
04:00:38 <Axman6> i think sun cop a lot of bad press for a lot of good work
04:00:59 <quicksilver> there are some really bad things about java
04:01:09 <Deewiant> as can be seen at http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=java&lang2=java the biggest problem is the startup time.
04:01:10 <quicksilver> but they are mostly in the libraries and to some extent the language design.
04:01:12 <lambdabot> Title: Java 6 -server benchmarks | Gentoo : Intel® Pentium® 4 Computer Language Bench ..., http://tinyurl.com/r88cc
04:01:19 <quicksilver> sun's VM is pretty impressive.
04:01:34 <Deewiant> when it actually starts running code, it's C++-level.
04:01:37 <matthew-_> sun's VM is in many cases world leading
04:01:46 <matthew-_> the hotspot system is awesome
04:01:48 <Axman6> java -server adds to the startup time i think, but it's faster at running things
04:02:03 <Baughn> I see. Then it would be very interesting to see the shootout rwith long-running tests
04:02:16 <Deewiant> yeah, -server just means that it JITs the whole code at startup.
04:02:17 <matthew-_> Axman6: yeah, it makes the profiler work harder and more code gets compiled to native
04:02:18 <Baughn> Say, chop off the first eight iterations, only count the last two
04:02:32 <Deewiant> Baughn: the startup time isn't included in the other benchmarks.
04:02:51 <Baughn> Deewiant: The optimization time would be, though
04:02:54 <Deewiant> I don't think, anyway, since otherwise all the times would be >= the startup time, which they clearly aren't. :-)
04:03:15 <Deewiant> Baughn: yeah, but it kinda has to be, because that's part of the actual runtime
04:03:27 <Baughn> Perhaps it caches those calculations? They'd be the same every time, right?
04:03:54 <Deewiant> What do you mean?
04:04:48 <Baughn> Well, with all this runtime optimization - and long startup times - it would make sense to cache that for the next time you run the program
04:05:01 <Deewiant> Baughn: you mean this? http://shootout.alioth.debian.org/gp4/faq.php#dynamic
04:05:03 <lambdabot> Title: Read the FAQ! | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks Game
04:05:49 <Baughn> Deewiant: Thanks. ^_^
04:05:54 <Deewiant> :-)
04:06:11 <Baughn> Although what I meant was, java should be storing the optimizations for reuse in the next invocation
04:06:59 <Baughn> ..that's... a rather unimpressive graph
04:07:58 <Deewiant> I'm still not clear on what you're after with "the optimizations". It profiles code at runtime and then aggressively optimizes the hot spots---all it remembers thereafter is that there was a hot spot at point X in the code, which has been optimized. (I guess, anyway.)
04:08:18 <Deewiant> Do you mean it should remember that the bytecode foo,bar,baz can be optimized to qux?
04:08:39 <Baughn> Or that spot foo, in class-file bar with hash baz, can be optimized to qux
04:09:00 <Deewiant> Why would it remember that? It's already optimized it. :-)
04:09:12 <Baughn> For the next time you run the application. -_-
04:09:21 <Baughn> That'd only be important if the benefit was actually large, though. The graph suggests it isn't
04:10:11 <Deewiant> Meh, I wouldn't like it storing optimization information in an on-disk database
04:10:38 <Axman6> couldn't it just modify the .class files?
04:11:27 <Baughn> Axman6: It might want to optimize them differently later, under different loads
04:11:38 <Baughn> Or the user might want to copy said file to a different computer
04:11:57 <Axman6> ah yeah, optimises to native code doesn't it
04:39:33 * BeelsebobWork really doesn't get why people insist on using the GPL or it's variants
04:40:26 <quicksilver> no? it's not all that hard to understand si it?
04:40:40 <quicksilver> they want to write free software and they want anyone else building on their work to keep it free?
04:40:55 <Zao> So basically, blackmail.
04:41:07 <BeelsebobWork> "keep" it free -- it's not free
04:41:14 <BeelsebobWork> if it was free, that restriction wouldn't be there
04:41:20 <SamB_XP> well, consider what MS would do given half a chance ...
04:41:24 <quicksilver> well for one very precise and particular definitoin of free
04:41:33 <quicksilver> I agree they redefined the word, but let's not argue about definitions?
04:41:36 <Zao> SamB_XP: Your bashing is rather irrelevant to the discussion.
04:41:39 <BeelsebobWork> SamB_XP: okay, considering -- they might actually use some GPLed code and make windows more compatible with it?
04:41:56 <SamB_XP> compatible ?
04:41:57 <SamB_XP> what ?
04:41:58 <quicksilver> "they want to write gnuish software and wany anyone else building on their work to keep it gnuish" ?
04:42:02 <Zao> SamB_XP: So what if they use your free library to improve interoperability of the OS or their products.
04:42:07 <Zao> I do not see any problems with that.
04:42:11 <quicksilver> Zao: no it's nothing like blackmail, don't be ridiculous.
04:42:13 <BeelsebobWork> SamB_XP: maybe if they were able to use the code they would be able to use it to interact well with others
04:42:18 <BeelsebobWork> instead af having to completely reimplement everything
04:42:19 <SamB_XP> Well, I think it's more relevant to applications
04:42:21 <Zao> "I don't earn anything, and thus should no-one else"
04:42:24 <quicksilver> Zao: blackmail is when I demand money in order to no expose pictures of your boyfriend.
04:42:41 <SamB_XP> quicksilver: ... Zao is gay?
04:42:48 <quicksilver> I don't know, or mind.
04:42:52 <quicksilver> that's not the point ;)
04:42:53 <Zao> SamB_XP: News to me.
04:42:55 <SamB_XP> or perhaps a girl?
04:44:06 <mm_freak> is there some preferred method to extract a range of elements from a mutable array, do reordering and then put them back?  in-place would be great
04:44:28 <quicksilver> I can entirely understand people not agreeing with the notion, and don't intend to argue.
04:44:38 <quicksilver> however I can't understand people not *understanding* the notion ;)
04:44:41 <quicksilver> it seems clear enough.
04:44:50 <SamB_XP> yeah, it's not actually blackmail
04:45:01 <BeelsebobWork> quicksilver: well to me it's a contradiction in terms -- they want things to be free... yet they don't make it free
04:45:17 <SamB_XP> BeelsebobWork: so ... they don'
04:45:30 <quicksilver> they have chosen a different definition of free, to you.
04:45:32 <SamB_XP> t have the BSD definition of Free ...
04:45:34 <BeelsebobWork> they impose constraints on work that *I* do, not work that they do in fact
04:45:47 <quicksilver> and to be fair, they go to enormous lengths to explain why they made that choice.
04:45:57 <quicksilver> there are essays and treatises on the subject :)
04:46:03 <Deewiant> and the constraints are essentially that you don't impose any additional constraints on others.
04:46:10 <BeelsebobWork> quicksilver: I think the enormous lengths they go to are perhaps an indication that it's a non-obvious thing to do
04:46:22 <quicksilver> yes, it's non-obvious.
04:46:29 <SamB_XP> it made sense at the time!
04:46:31 <vegai> GPL is fine, but admittedly they claiming it's the Freest Freedom in all of Freestania is a bit dishonest
04:46:35 <SamB_XP> and sometimes it makes sense now
04:46:35 <BeelsebobWork> Deewiant: exactly -- a contradiction -- they're imposing constraints on me and *my* work -- not on their work at all
04:46:36 <quicksilver> But most things which are against established orthodoxy are non-obvious.
04:47:29 <Deewiant> BeelsebobWork: yes, that's the license. Whether it's a contradiction or not depends on your definition of "free as in speech". :-)
04:47:32 <SamB_XP> BeelsebobWork: they don't wan't you wresting control of the project away from free codebases...
04:47:38 <quicksilver> In any case with due respect I'm going to call "off-topic" on this one.
04:47:46 <quicksilver> Let's take it to -blah if we're interested.
04:47:53 <BeelsebobWork> that's true
04:48:07 <SamB_XP> does that mean we get to include more sex in the discussion?
04:48:12 <quicksilver> I've seen this conversations run and run and I don't want it to happen here.
04:54:16 <mm_freak> hmm…  haskell's array functionality is quite limited =/
04:55:34 <Cale> mm_freak: oh?
04:55:53 <Cale> mm_freak: What's missing?
04:57:14 <mm_freak> Cale: simple functions like elemsRange, swapArray, etc.
04:57:40 <Axman6> swapArray?
04:57:40 <Cale> elemsRange?
04:57:48 <mm_freak> elemsRange like: get (MArray) or be (IArray) the list of elements from a certain range
04:58:00 <mm_freak> swapArray (MArray) like swap two elements
04:58:10 <mm_freak> i reinvent the wheel all the time, when writing array code
05:00:36 <Deewiant> swapArray a i j = do i' <- readArray a i; j' <- readArray a j; writeArray a i j'; writeArray a j i'
05:00:52 <Cale> The first is just  map (a !) (range (u,v)), or [a ! i | i <- range (u,v)], of course.
05:01:18 <mm_freak> Deewiant: yes, i've written that function a million times…  and that's exactly the point
05:02:12 <mm_freak> Cale: sure, but what is it for a mutable array?  sure, you can come up with a function quickly, but it's wasted effort to do that all the time, and the performance sucks
05:02:54 <Deewiant> mapM (readArray a) (range (u,v))
05:03:46 <mm_freak> it's just like for most interactive programs i reinvent a lot of monad functions all the time
05:03:51 <mm_freak> particularly 'while'
05:03:59 <Cale> mm_freak: What's wrong with the performance of those?
05:04:11 <Deewiant> whenM, ifM, whileM, yeah
05:04:44 <mm_freak> Cale: compared to equivalent C code it's bad, according to my benchmarks
05:05:15 <Cale> mm_freak: C code which builds a linked list?
05:05:44 <mm_freak> Cale: in many cases the list building isn't necessary…  you can avoid that easily in C
05:05:44 <rhox> hello, may someone help me with this http://pastebin.com/m464456b5 ?
05:06:03 <mm_freak> Cale: of course, if you add the development time, haskell is still much faster in most cases
05:06:08 <mm_freak> but IMO it could be done better
05:06:36 <mm_freak> Deewiant: whenM is there (simply 'when'), for ifM you'd just use the regular 'if' or 'case'
05:06:43 <Cale> Well, you might hope for map fusion, but if the map isn't fusing, you could of course do it by hand.
05:06:48 <mm_freak> Deewiant: but while is missing
05:06:58 <Cale> (which would be still not quite as ugly as the C code ;)
05:07:25 <Deewiant> mm_freak: whenM and ifM take m Bool, not Bool
05:07:34 <Deewiant> very handy in my experience
05:07:35 <mm_freak> hmm…  maybe i should become a base lib developer =)
05:07:51 <mm_freak> Deewiant: oh, never heard of them
05:08:10 <mm_freak> but what would they do other than extract the bool and check it?
05:08:28 <besiria>  i think i saw somewhere sth about removing monomorphism restriction
05:08:29 <Deewiant> whenM a b = do a' <- a; when a (b >> return ())
05:08:32 <besiria> 	  in haskell' , is that true?
05:09:06 <ivanm> rhox: you're mixing pure code with unpure
05:09:21 <ivanm> if you want to define pure variables in IO (), you need to use let
05:09:27 <quicksilver> besiria: yes.
05:10:06 <mm_freak> Deewiant: well, that would save a few characters of typing, but somehow it would feel incorrect to me
05:10:12 <mm_freak> i'd prefer to extract explicitly
05:10:49 <Deewiant> I've been thinking of writing a GHC extension that allows me to write "if <- foo" instead of "x <- foo; if x"
05:11:26 * besiria loves eta reduction
05:11:48 <mm_freak> Deewiant: why?  we have enough sugar already, don't you think?  really, that one additional line you need to write wouldn't kill you =)
05:12:13 <Twey> rhox: You basically just forgot your 'let' keyword.
05:12:30 <Deewiant> mm_freak: it's so common in my code that it's beginning to annoy me
05:12:32 <Zao> You should make it C-style and do   if *foo
05:12:39 <mm_freak> Deewiant: short code is often a virtue, but also often a nightmare
05:13:01 <Deewiant> mm_freak: I think it's much worse to have a variable called "x'" which is used only once
05:13:54 <mm_freak> true…  maybe 'if' should be a function instead of a language construct
05:14:12 <Deewiant> I'd still have to write ifM
05:14:38 <paczesiowa> and flip it inside-out
05:14:39 <mm_freak> not with a "swapped if"
05:14:59 <mm_freak> if' a b p = if p then a else b
05:15:06 <mm_freak> getSomeBool >>= if' whenTrue whenFalse
05:15:22 <zeno> anyone on ubuntu get yi running?
05:15:26 <Deewiant> yeah, and I'd still write ifM. ;-)
05:15:57 <paczesiowa> zeno: are you trying hackage or darcs?
05:16:12 <zeno> parodyoflanguage: with cabal
05:17:03 <paczesiowa> zeno: I had plenty of problems with installing that, try darcs version that worked out of the box
05:17:23 <mm_freak> Deewiant: well…  go ahead…  fortunately most auxilliary functions you have to rewrite all the time are in fact one-liners
05:17:24 <zeno> yi-0.4.6 depends on Cabal-1.4.0.2 which failed to install. cabal --version using version 1.4.0.2 of the Cabal library
05:17:37 <zeno> paczesiowa: thanks
05:18:06 <paczesiowa> zeno: 0.4.6? I did that when 0.4.4 was out so maybe they fixed it and broke other stuff
05:18:26 <Deewiant> mm_freak: including while. ;-)
05:19:13 <mm_freak> Deewiant: yeah, sure
05:19:17 <mm_freak> it's just annoying =)
05:19:43 <mm_freak> while p x c = if p x then c x >>= \y -> while p y c else return x
05:19:45 <mm_freak> all the time
05:19:48 <mm_freak> all over again
05:19:50 <byorgey> @seen solrize
05:19:51 <lambdabot> solrize is in #haskell. I last heard solrize speak 7h 19m 38s ago.
05:19:51 <Deewiant> once per project
05:19:58 <byorgey> solrize: you were looking for me?
05:20:05 <mm_freak> yeah, but i have a lot of small one-filers ;)
05:20:44 <Deewiant> mm_freak: make a private "utils" package and have them depend on that :-P
05:21:05 <mm_freak> since as soon as you get used to haskell, you hack up things quite fast, if you wouldn't have to write the same aux functions all over again, you'd probably save most of development time =)
05:21:44 <Deewiant> yep
05:29:24 <mm_freak> hmm…  it's sad that the GHC devs had to abandon darcs…  that turned a lot of people away from haskell and placed its maturity into question
05:29:44 <mm_freak> many people believe that haskell is almost useless in the real world
05:30:23 <Philippa> tbh, I'm not sure how many people that's affected who weren't having poison dripped into their ears by Jon Harrop
05:30:46 <mapreduce> darcs just has some algorithmic problems, I thought.
05:30:46 <quicksilver> mm_freak: I think it was a very hard decision to take for exactly that reason.
05:30:55 <mapreduce> That aren't related to Haskell.
05:31:01 <quicksilver> yes, the problem with darcs was not haskell.
05:31:10 <quicksilver> but of course mm_freak is right that it didn't 'look good'
05:31:14 <mapreduce> Then all is well.
05:31:19 <jeffz> mm_freak: who did it turn away?
05:31:27 <mapreduce> Haskell is better off without people who react like that.
05:31:37 <quicksilver> the way to show that haskell is mature is to provide counter exaples
05:31:42 <quicksilver> not worry about failures
05:31:52 <quicksilver> if we all write one excellent haskell application
05:32:02 <quicksilver> which breaks new ground, leads its field, and people love it
05:32:05 <quicksilver> there will be no more doubt
05:32:08 <quicksilver> who's up for that? ;)
05:32:16 <quicksilver> (one each, I mean, of course)
05:32:22 * mapreduce hears a pin drop.
05:32:23 <mm_freak> jeffz: a few people i know, some of which i convinced of haskell myself
05:32:42 <mm_freak> quicksilver: but what?
05:32:55 <Philippa> mm_freak: were they aware that darcs is in many regards a research project? That it's not just a clone of systems that already existed?
05:33:01 <mapreduce> mm_freak: Are you actually short of ideas?
05:33:13 <mapreduce> Every time I use software I have ideas about how it could be better. :)
05:33:27 <mm_freak> unfortunately many haskellers are so busy with theory that they aren't even interested in real world apps…  haskell is a true virtue for theoreticians
05:33:48 <Philippa> mm_freak: I think that's quite the misunderstanding too
05:33:50 <mapreduce> mm_freak: Can you give an example of such a haskeller?
05:33:51 <mm_freak> mapreduce: yeah, but then you look at how much effort it takes to rewrite it in a new language
05:34:09 <mm_freak> mapreduce: me
05:34:20 <Philippa> the theoretician contingent's pretty small, enough that I start to look that way
05:34:20 <zeno> ok got it to install, but Yi.Mode.Shim could not be found
05:34:26 <quicksilver> mm_freak: I'm writing a couple of games, some visualisation applications, a true relational database with full serialisation and synchronous replication and its own query language, and a Reactive-based network server framework.
05:34:31 <Philippa> (admittedly there are other reasons for that - I'm not good at getting stuff done full stop)
05:34:37 <quicksilver> mm_freak: so I reckon I have two or three of us covered.
05:34:44 <BONUS> or that guy who writes Comonad.Reader
05:34:51 <quicksilver> unfortunately I have a job ;(
05:34:57 <Philippa> what is true is that the biggest cases of real world haskell uses are behind NDAs or stronger
05:35:26 <quicksilver> oh yes, there is also my secret investment product which was single-handedly responsible for the last 9 months of financial turmoil
05:35:30 <quicksilver> but I'm not allowed to talk about it
05:35:39 <quicksilver> (sorry about the mess, guys, but it made my clients very rich)
05:35:45 <Deewiant> heh
05:35:50 <quicksilver> could never have done it without haskell.
05:35:56 <zeno> quicksilver: cool I just started a game server maybe ill use your framework :)_
05:35:57 <mm_freak> don't get me wrong…  IMO haskell is great
05:36:29 <mm_freak> but unfortunately not everybody likes to bother with the theory behind it…  those who do are mostly actually quite interested, and those who don't fail to use haskell
05:37:01 <Philippa> mm_freak: what do you have in mind with "the theory behind it"?
05:37:34 <mm_freak> Philippa: particularly monads and what it means to be "purely functional"
05:37:35 <Philippa> (FWIW, I know a number of intermittent dabblers who're slowly building to the point of being ready to use it for their real world apps, they just don't have time to absorb that much new stuff in one sitting)
05:37:50 <besiria> > <besiria>  i think i saw somewhere sth about removing monomorphism restriction
05:37:50 <besiria> <besiria> 	  in haskell' , is that true?
05:37:50 <besiria> *** #haskell modes: +tnc
05:37:50 <besiria> *** #haskell was created on Sunday 2006/11/26 8:42:48 AM
05:37:51 <lambdabot>   mueval: Prelude.read: no parse
05:37:54 <besiria> <Deewiant> whenM a b = do a' <- a; when a (b >> return ())
05:37:57 <besiria> *** seafood (n=sseefrie@220-244-208-214.static.tpgi.com.au) has quit:
05:38:00 <besiria> <ivanm> rhox: you're mixing pure code with unpure			[15:09]
05:38:04 <besiria> <ivanm> if you want to define pure variables in IO (), you need to use let
05:38:05 <besiria> <quicksilver> besiria: yes.
05:38:08 <besiria> <mm_freak> Deewiant: well, that would save a few characters of typing, but
05:38:10 <Philippa> mm_freak: which is a problem because 1) you don't need theory for monads and 2) you /need/ to get the consequences of being purely functional and that's not a matter of theory
05:38:11 <besiria> 	   somehow it would feel incorrect to me			[15:10]
05:38:15 <besiria> *** paczesiowa (n=paczesio@87-205-177-246.adsl.inetia.pl) has joined channel
05:38:18 <besiria>     #haskell
05:38:20 --- mode: ChanServ set +o quicksilver
05:38:21 <besiria> <mm_freak> i'd prefer to extract explicitly
05:38:24 <besiria> *** binrapt (i=binrapt@e180073079.adsl.alicedsl.de) has joined channel
05:38:24 --- mode: quicksilver set +b besiria!*@*
05:38:26 <ivanm> besiria: ummmm.... what are you doing and why?
05:38:27 <osfameron> being unforgiving of minor mistakes is great for robust mission critical stuff, but it does make it hard to get started for "just good enough" real world apps
05:38:33 <quicksilver> ivanm: he accidentally pasted.
05:38:40 <ivanm> ahhh
05:38:41 --- mode: quicksilver set -b besiria!*@*
05:38:54 <quicksilver> slip of the finger I imagine :)
05:39:11 <Philippa> mm_freak: tbh, that's not even about theory, it's "don't wanna learn a new paradigm"
05:39:19 <ivanm> I just saw my name pop up and was wondering why he'd pasted my previous two messages, then saw that he was pasting _everyone's_ ;-)
05:39:21 <besiria> sry
05:39:25 <quicksilver> besiria: it's OK :)
05:39:31 <quicksilver> besiria: finger slipped I imagine?
05:39:37 <mm_freak> Philippa: well, if you don't understand monads, at some time you'll arrive at a point where your code works but you just don't understand it yourself
05:39:37 <besiria> quicksilver: exactly
05:39:48 <quicksilver> it took me a while to remember that you can ban without kicking
05:39:54 <quicksilver> and that effectively silences someone.
05:40:00 <SamB_XP> oh does it?
05:40:01 <quicksilver> I'm not much good at this IRC lark.
05:40:02 <SamB_XP> cooooool
05:40:02 * quicksilver nods
05:40:32 <quicksilver> in a way it's a shame that irc clients have the anti-flood feature
05:40:33 <Deewiant> I'd've kicked without banning personally :-P
05:40:39 <mm_freak> Philippa: not using a language (no matter how great it is) is better than not understanding your own code
05:40:45 <quicksilver> otherwise they'd get sorted automatically.
05:40:49 --- mode: quicksilver set -o quicksilver
05:40:52 <mm_freak> (unlambda being an exception) =)
05:41:04 <besiria> > mconcat (fromList ["foo","bar"])
05:41:05 <lambdabot>   mueval: Prelude.read: no parse
05:41:11 <Philippa> mm_freak: there's an awful lot of STL users don't understand the innards of the STL, to pick an example
05:41:15 <zeno> @src unlambda
05:41:15 <lambdabot> Source not found. Sorry.
05:41:19 <Philippa> being willing to go a while without getting it all is important
05:41:33 <Philippa> come back and understand monads more later on, like when you're starting to build your own
05:41:37 <zeno> @hoogle unlambda
05:41:38 <lambdabot> package unlambda
05:41:44 <quicksilver> Philippa: I wouldn't be surprised if 100% of them didn't understand the entire innards :)
05:41:44 <mm_freak> Philippa: yes, but they understand their own code…  that's a difference…  although they don't understand templates well, they know why their code works the way it does
05:41:45 <Philippa> (and even then, you don't need to know the categorical definition let alone understand it)
05:42:07 <Philippa> mm_freak: and all you need to understand is return, >>= and the associated type constructor
05:42:25 <Philippa> oh okay, and the desugaring for do I guess
05:42:43 <Philippa> but you can get by on return, do and the constructor for your own code, even
05:43:03 <mm_freak> Philippa: until i understood the list monad, the code (do x <- [1,2,3]; y <- [4,5,6]; return (x+y)) appeared extremely confusing to me, so i wouldn't use it
05:43:15 <mm_freak> sure, understanding haskell monads, that code gets quite self-explaining
05:43:19 <mm_freak> but until then…
05:43:26 <Philippa> mm_freak: sure. So don't use the list monad until then
05:43:51 <mm_freak> yeah and now mix that with the bad habit of most people to be lazy to learn new stuff
05:44:05 <Philippa> and they don't learn the list monad until they've got a strong use case for it. Big deal?
05:44:08 <besiria> > mconcat ["foo","bar"]
05:44:09 <Botje> they'll be the first against the wall when the revolution comes
05:44:09 <skorpan> how do you group a list of elements into groups of three?
05:44:10 <lambdabot>   "foobar"
05:44:18 <Botje> @where chunk
05:44:18 <lambdabot> I know nothing about chunk.
05:44:21 <Botje> damn
05:44:23 <Botje> @src chunk
05:44:23 <lambdabot> Source not found. My pet ferret can type better than you!
05:44:26 <byorgey> ah, chunk =)
05:44:26 <Philippa> now if people're having similar trouble with error and state monads that's more problematic
05:44:29 <Botje> silly lambdabot.
05:44:39 <Philippa> but list's weird because it's effectively writing a local program in a whole unfamiliar paradigm
05:44:39 <byorgey> most-asked for function that's not actually in the standard libraries.
05:44:42 <Philippa> of course it's confusing!
05:44:54 <besiria> > mconcat (fromList ["foo","bar"] :: Seq String)
05:44:57 <lambdabot>   mueval: Prelude.read: no parse
05:45:04 <besiria> ?
05:45:20 <quicksilver> skorpan: chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
05:45:22 <Botje> anyway, skorpan: unfoldr (\l -> if null l then Nothing else Just ( splitAt 3 l)
05:46:12 <byorgey> besiria: weird, maybe Seq isn't imported
05:46:22 <Deewiant> > empty :: Seq String
05:46:24 <lambdabot>       Ambiguous occurrence `empty'
05:46:24 <lambdabot>      It could refer to either `Control.App...
05:46:24 <Botje> I just noticed this is really unfoldr (\l -> (splitAt 3) `fmap` listToMaybe l)
05:46:27 <byorgey> besiria: wait, that wouldn't typecheck anyway
05:46:29 <byorgey> @type mconcat
05:46:30 <lambdabot> forall a. (Monoid a) => [a] -> a
05:46:35 <byorgey> mconcat only works on lists
05:46:47 <quicksilver> Botje: no it's not.
05:46:55 <quicksilver> Botje: listToMaybe only gives you the first item.
05:46:59 <Botje> oh
05:47:02 <Botje> that's so sad
05:47:09 <Botje> it looks so beautiful otherwise :)
05:47:13 <quicksilver> ;)
05:47:31 <Deewiant> ?pl \x -> if null x then Nothing else Just x
05:47:31 <lambdabot> ap (flip if' Nothing . null) Just
05:47:47 <quicksilver> it's (guard . null $ l) >> return (splitAt 3 l)
05:48:01 <quicksilver> which is morally
05:48:15 <Deewiant> ?src guard
05:48:16 <lambdabot> guard True  =  return ()
05:48:16 <lambdabot> guard False =  mzero
05:48:16 <Botje> ugly :(
05:48:16 <quicksilver> (guard . null) >> (return . splitAt 3)
05:48:28 <quicksilver> but you need ReaderT constructors in there
05:48:33 <quicksilver> to make it work in haskell.
05:49:14 <quicksilver> (other wise it thinks you're working in the l -> a monad, not the l -> Maybe a monad)
05:49:21 <quicksilver> (and I meant MaybeT constructors, not ReaderT)
05:49:36 <quicksilver> I think this is an expressivity hole
05:49:39 <quicksilver> but I don't know how to patch it.
05:50:27 <Botje> compile with -XTelepathy
05:50:36 <besiria> > mconcat (toList (fromList ["foo","bar"] :: Seq String))
05:50:37 <lambdabot>   mueval: Prelude.read: no parse
05:50:44 <Deewiant> > fromList
05:50:46 <lambdabot>   mueval: Prelude.read: no parse
05:50:54 <Deewiant> doesn't know about it
05:53:05 <mm_freak> Philippa: i wouldn't have a problem with that since it's precisely the way i learned haskell
05:53:14 <mm_freak> i don't understand arrows, so i don't use them
05:53:48 <quicksilver> that's very odd.
05:53:51 <quicksilver> > Data.Sequence.fromList
05:53:53 <lambdabot>       Overlapping instances for Show ([a] -> Data.Sequence.Seq a)
05:53:53 <lambdabot>        aris...
05:53:57 <quicksilver> ^^ this error says its in scope
05:54:00 <quicksilver> > Data.Sequence.fromList ["foo","bar"]
05:54:01 <lambdabot>       Not in scope: `Data.Sequence.fromList'
05:54:10 <quicksilver> ^^ this one says it isn't.
05:54:12 <quicksilver> wtf ?
05:54:25 <besiria> wow i found a bug. im so proud :)
05:54:46 <Deewiant> lambdabot is so broken these days
05:57:50 <besiria> how could i concat Seq?
05:58:07 <Deewiant> foldr append empty
05:58:28 <Deewiant> where append = (><)
05:58:43 <besiria> thx
05:58:53 <Deewiant> ?src concat
05:58:53 <quicksilver> or use mconcat
05:58:54 <lambdabot> concat = foldr (++) []
05:58:56 <quicksilver> :t mconcat
05:58:58 <lambdabot> forall a. (Monoid a) => [a] -> a
05:59:07 <quicksilver> which is the natural generalisation of concat :)
05:59:28 <quicksilver> well if you have a list of seqs
05:59:32 <quicksilver> rather than a seq of seqs
05:59:33 <besiria> quicksilver: but first i need to do sth like toList, right?
05:59:40 <quicksilver> which do you have? a seq of seqs?
05:59:48 <besiria> o Seq of Strings
05:59:53 <Deewiant> quicksilver: no, in any case, since foldr is of course Data.Foldable.foldr ;-)
05:59:56 <quicksilver> oh, a Seq of strings.
06:00:01 <geezusfreeek> :t Data.Foldable.fold
06:00:02 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
06:00:06 <geezusfreeek> :)
06:00:06 <quicksilver> and you want 1 string, not 1 seq
06:00:14 <besiria> quicksilver: yeap
06:00:16 <quicksilver> yes, then you want just plain "fold"
06:00:19 <Deewiant> besiria: Data.Foldable.concat
06:00:21 <quicksilver> as geezusfreeek showed.
06:01:29 <geezusfreeek> @src Data.Foldable.concat
06:01:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:01:40 <geezusfreeek> well, it's concat = fold
06:03:50 <besiria> wow , beautiful! fold,concat is the great haskell thing i learned this day
06:06:17 <Deewiant> Foldable and Traversable should be in the Prelude
06:07:38 * geezusfreeek always wishes for more generic functions in the prelude and less specific ones
06:07:45 <geezusfreeek> well, almost always
06:07:49 <Deewiant> always
06:08:23 <geezusfreeek> if i rephrase to say more polymorphic and less monomorphic then i can say always
06:09:17 <Philippa> mm_freak: non-determinism's a lot weirder than pure FP though :-)
06:11:15 <mm_freak> Philippa: i get it quite well and since then i've found a lot of uses for it =)
06:12:03 <Philippa> fair enough. You can see why I think the list monad's a bit of a "don't do that, then" case though?
06:12:11 <subconscious> Can you put algorithms through lenses?
06:16:23 <besiria> i wish Prelude.map was fmap and Prelude.concat was Data.Foldable.concat
06:17:14 <Araneidae> I don't know if this is OT: the Ubuntu libghc6-cabal-dev depends on ghc6 == 6.6.1.  In other words, it refuses to install with ghc 6.8.2 installed!  This make sense to anybody?
06:17:21 <osfameron> what would be the disadvantage of that?
06:17:32 <osfameron> the error messages of a simple map on a list would be harder to read?
06:18:09 <Deewiant> yep, that's about it
06:18:24 <subconscious> I don't agree with tha
06:18:32 <subconscious> I think the error messages are not harder to read
06:20:28 <Deewiant> it's like getting "no instance of Num Char" instead of "expected an Int, got a Char"
06:21:37 <byorgey> Araneidae: that's strange indeed.
06:21:47 <BeelsebobWork> I would love Prelude.map to be implemented in terms of fmap
06:22:06 <BeelsebobWork> but to actually *make it* fmap I think is too far -- it's a specialisation for the common case
06:22:14 <BeelsebobWork> and documents the fact that you're using lists in your code
06:22:51 <Araneidae> byorgey, there seems to be a bug report: https://bugs.launchpad.net/ubuntu/+source/haskell-cabal/+bug/231099
06:22:58 <geezusfreeek> if i define a function which turns out to be polymorphic, i'd rather document that than the fact that i originally intended it to be for lists
06:22:59 <lambdabot> http://tinyurl.com/5y6pu6
06:23:10 <Araneidae> Think I'll install from source instead!
06:23:13 <ddarius> Beelsebob: What do you care how map is implemented?
06:23:54 <BeelsebobWork> ddarius: I don't really -- but I do care that it's a specialisation of fmap, not fmap itself
06:24:08 <BeelsebobWork> similarly, I care that (.) is a specialisation, and not fmap itself
06:24:50 <Deewiant> there's a clear advantage in being able to write "f . g . h" instead of "fmap f (fmap g h)"
06:25:07 <geezusfreeek> > (5 +) . [1, 2, 3, 4, 5]
06:25:08 <lambdabot>   Couldn't match expected type `a -> t' against inferred type `[a1]'
06:25:15 <ddarius> Beelsebob: Do you care that map isn't generalized because you think it is a bad idea or do you care simply because it is not H98?
06:25:16 <BONUS> uh you mean f . g $ h
06:25:17 <geezusfreeek> i thought lambdabot was all hacked up for that
06:25:26 <Deewiant> geezusfreeek: not since it broke (i.e. mueval)
06:25:27 <geezusfreeek> :t (.)
06:25:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:25:33 <geezusfreeek> oh
06:26:58 <Araneidae> Hum.  Bit puzzled about versioning of cabal.  http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package tells me to install version 0.5.2, but the (broken) Ubuntu package claims to install 1.1.3.  Eh?
06:27:00 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
06:27:12 <subconscious> I would like to have f ∘ g ∘ h
06:27:12 <geezusfreeek> BONUS: no Deewiant meant f . g . h in this case. f . g $ h would be fmap f (g h)
06:27:39 <BONUS> oh i see
06:28:28 <Araneidae> Oh good grief: that version must be ancient.  There's a 1.4.0.2 out there!
06:28:38 <BeelsebobWork> there's a 1.5.5 out there
06:28:43 <BeelsebobWork> although that's unstable
06:28:44 <Araneidae> where?!
06:28:50 <Araneidae> ok, I'll stick with stabl
06:28:52 <Araneidae> e
06:29:02 <Deewiant> 1.4.0.1 has worked fine for me so far
06:29:07 <BeelsebobWork> version numbering is the same as linux's old system -- odds are unstable, evens are stable
06:29:28 <Araneidae> Ahhh.  0.5.2 is the cabal-install version, 1.4... the cabal library version.
06:29:40 <Deewiant> ah, yes :-)
06:31:10 <geezusfreeek> BONUS: actually i think i was wrong. f . g $ h would be fmap f g h
06:31:38 <geezusfreeek> i hate precedence sometimes
06:32:10 <subconscious> @seen lunabot
06:32:10 <lambdabot> I saw lunabot leaving #haskell 1d 3h 55m 13s ago, and .
06:32:14 <Araneidae> Interesting: cabal's bootstrap.sh uses bashisms (pushd and popd) which fail given that it's invoked with /bin/sh
06:32:34 <Deewiant> sh doesn't have pushd and popd? O_o
06:32:36 <Deewiant> even cmd.exe has those
06:32:42 <Araneidae> Not classic sh, no
06:32:53 <Araneidae> Original sh is a bit basic, I'm afraid.
06:33:11 <Deewiant> in most cases original sh is miles ahead of cmd.exe :-P
06:33:25 <Araneidae> sh doesn't have array variables, so you can't have the directory array!
06:33:46 <Deewiant> it doesn't have to implementable in sh to be in sh :-)
06:34:00 <Araneidae> true, true.  Anyhow, guess I need to raise a bug report somewhere...
06:34:16 <mm_freak> Philippa: i fully agree with you but that's not how people think…  if they don't understand monads they feel like they don't understand the language and eventually abandon it
06:38:06 <Araneidae> Oh well: http://hackage.haskell.org/trac/hackage/ticket/354 , fixed in dev
06:38:13 <retybok> is there a build of ghc for IA-64 somewhere? There is no package for fedora on IA64, and apparently bootstrapping ghc isn't exactly trivial...
06:38:17 <lambdabot> Title: #354 (/bin/sh used for bootstrap.sh in cabal-install doesn't support pushd, popd ...
06:39:45 <ivanm> what are the layout rules for list comprehensions?
06:40:13 <ddarius> ivanm: There are none.
06:40:13 <Araneidae> Blast.  Cabal install bootstrap fails, and I don't know what to do next.
06:40:15 <Araneidae> Setup: At least the following dependencies are missing:
06:40:15 <Araneidae> HTTP >=3000 && <3002, network >=1 && <3
06:40:22 <ivanm> ddarius: *nod*
06:40:29 <Araneidae> I don't know what that means, let alone how to fix it!
06:40:42 <Deewiant> Araneidae: it means you need to install the HTTP and network packages.
06:40:55 <Deewiant> (this is what cabal-install what do for you if you had it installed)
06:41:01 <Araneidae> Ok... but I've never installed anything, which is why I'm installing cabal.
06:41:19 <Araneidae> Just so.  I've just run cabal-install/boostrap.sh, and that's what it's saying.
06:41:35 <Deewiant> yes, it somewhat sucks that you can't build cabal-install without having to install something manually first. :-/
06:41:38 <ddarius> ivanm: The rule is layout only begins after a 'do', 'where', 'let', or 'of'
06:42:08 <ivanm> *nod*
06:42:16 <Deewiant> Araneidae: you can find the packages at http://hackage.haskell.org/packages/archive/pkg-list.html
06:42:17 <lambdabot> Title: HackageDB: packages by category
06:42:26 <ivanm> ddarius: not even for an if/then/else?
06:42:37 <ddarius> ivanm: Nope.
06:43:03 <Araneidae> Where are these packages actually being installed?
06:43:23 <Deewiant> on *nix, I don't know.
06:43:31 <Deewiant> I think "user" installs go into ~/.cabal.
06:43:36 <Araneidae> It looks like the bootstrap managed to install quite a bit of stuff... maybe in ~/.cabal
06:43:40 <Deewiant> system-wide ones into the normal /usr places, I guess.
06:43:54 <Deewiant> on windows, system-wide ones go into %PROGRAMFILES%/Haskell.
06:44:34 <Araneidae> Hmm.  ok.
06:45:34 <Araneidae> Hmm.  Looks as if bootstrap managed to get started on HTTP, but forgot the network dependency.
06:46:17 <besiria> is there a reason why if/then/else became  a keyword and not a function
06:46:20 <mm_freak> Deewiant: two aux functions which are particularly annoying to rewrite all the time are modExp and gcdEx
06:46:32 <Deewiant> haven't needed either yet :-)
06:46:39 <subconscious> besiria: I assume it's because of the popularity of imperative langugase
06:46:46 <mm_freak> ah, and a fast primality test
06:47:03 <Deewiant> but yeah, some kind of Math module would be nice.
06:47:13 <mm_freak> yeah
06:47:25 <Deewiant> Math.Arithmetic.Modulo etc.
06:47:29 <mm_freak> interestingly it would be amazingly easy to implement into GHC, because GMP provides all those basics
06:47:29 <Deewiant> or whatever.
06:47:42 <subconscious> http://www.vex.net/~trebla/haskell/calculator/Calculator.html
06:47:49 <lambdabot> Title: Calculator
06:48:33 <ivanm> with the whole nub vs map head . group . sort debate, what happens if I _do_ want a sorted output?
06:50:52 <r3m0t> then... you sort it?
06:51:02 <besiria> subconscious:  this must be the case , but i've gotten so familiar with if/then/else that i prefer it than a lisp's if
06:51:18 <quicksilver> besiria: hysterical raisins.
06:51:34 <quicksilver> having said that, I like it.
06:51:51 <quicksilver> I don't think it should be correctly compared to having a function 'if'
06:52:12 <quicksilver> I think it should be seen as short version of "case cond of True -> thenpart; False -> elsepart"
07:15:14 <gbacon> I'm trying to run many random trials using replicateM n trial, but I'm having trouble getting it to run lazily
07:16:28 <inimino> wouldn't that run them sequentially?
07:16:50 <gbacon> ?src replicateM
07:16:51 <lambdabot> replicateM n x = sequence (replicate n x)
07:16:55 <byorgey> gbacon: what do you mean by 'lazily' in this context?
07:17:46 <gbacon> byorgey: if I were writing it imperatively, it'd be a simple counting loop, but I'm getting stack overflows
07:18:08 <gbacon> as though it wants to grab all the trials first and then go count the whole lot
07:18:40 <inimino> replicateM will run all of them before anything else in your program happens
07:19:22 <gbacon> I tried (liftM length . sequence . take 100000 . repeat) trial, but no dice there either
07:19:24 <inimino> pure code is lazy, but IO actions happen in order
07:19:30 <byorgey> no, in theory sequence should be able to come along behind replicate, processing trials as they are generated
07:19:47 <byorgey> the issue isn't order, it's whether this can be done in constant memory.
07:20:34 <byorgey> gbacon: it's probably not that all the trials are getting generated before they are processed, but that the processing part is too lazy so it is building up a big thunk.
07:20:45 <byorgey> gbacon: what do you do with the list which is the result of repliaceM n trial?
07:20:51 <byorgey> *replicateM
07:21:35 <gbacon> byorgey: I'm counting trials with a certain property.. it'd be a trivial loop with O(1) space if I were writing it imperatively
07:21:39 <inimino> byorgey: I think by laziness he expects the list to be created and consumed at the same time
07:22:03 <gbacon> inimino: correct, what's the proper term?
07:22:07 <inimino> but that won't happen because it's in the IO monad so it's going to have to keep the whole list around
07:22:12 <byorgey> right, laziness makes that possible
07:22:44 <byorgey> is it in the IO monad?
07:22:51 <byorgey> gbacon never said what monad is involved
07:22:52 <gbacon> yes, getStdRandom
07:23:00 <gbacon> i.e., IO
07:23:05 <inimino> ok
07:23:07 <byorgey> hm, inimino may be right
07:23:33 <byorgey> gbacon: much better would be to generate an infinite list of random numbers (using 'randoms') and create and process your trials with that
07:23:42 <byorgey> then IO will not be threaded throughout the whole thing
07:25:16 <inimino> yeah
07:25:53 <EvilTerran> ?hackage MonadRandom
07:25:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
07:26:06 <byorgey> or that =)
07:26:44 <EvilTerran> abstracts away the infinite list of random numbers, so it still looks like a stateful random number generator
07:26:45 <dmwit_> Or you could write an action that both produces and consumes one random number.
07:26:53 <dmwit_> Then replicateM will do what you want it to.
07:27:06 <dmwit_> (replicateM_ might even be better in such a case.)
07:27:33 <inimino> or write something that manages your state
07:29:26 <sw17ch> I want a function that runs an action and binds the action with itself until "fail" is called from that monad.
07:29:29 <sw17ch> Does such a thing exist?
07:30:30 <byorgey> @src forever
07:30:30 <lambdabot> Source not found. My pet ferret can type better than you!
07:30:50 <sw17ch> byorgey, ah yes... i thinks that's the one...
07:30:54 <sw17ch> @src Control.Monad.forever
07:30:55 <lambdabot> Source not found. Just try something else.
07:31:00 <byorgey> @type forever
07:31:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
07:31:11 <mightybyte> @pl (\n -> (n`mod`3) == 0)
07:31:11 <lambdabot> (0 ==) . (`mod` 3)
07:31:18 <dmwit> That doesn't do quite what you want, probably.
07:31:27 <dmwit> :t iterateM
07:31:28 <lambdabot> Not in scope: `iterateM'
07:31:31 <sw17ch> i do'nt think quite
07:31:35 <sw17ch> the part about stopping on fail isn't quite happening
07:31:48 <dmwit> And the binding to your own tail won't happen, either. =)
07:31:53 <sw17ch> :P
07:31:59 <sw17ch> it's along the right path though...
07:32:01 <pgavin> @seen dcoutts
07:32:02 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-icfp 17h 17m 19s ago, and .
07:32:09 <sw17ch> i want a forever which eventaully stops
07:32:13 <dmwit> :t \m x -> iterate (>>= m) (return x)
07:32:15 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> b -> [m b]
07:32:36 <dmwit> That will get you part of the way there, you just need a "sequence" that knows when to stop.
07:32:59 <EvilTerran> sw17ch, something that is to "forever" what "until" is to "iterate"?
07:33:00 <sw17ch> i was hoping for something along the lines of Fix
07:33:12 <EvilTerran> ?type until
07:33:13 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
07:33:18 <EvilTerran> ?type forever
07:33:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
07:33:41 <EvilTerran> ?src until
07:33:41 <lambdabot> until p f x | p x       = x
07:33:41 <lambdabot>             | otherwise = until p f (f x)
07:33:42 <sw17ch> EvilTerran: yes
07:34:04 <sw17ch> i have something arount here somewhere that odes that
07:34:12 <dmwit> ?index until
07:34:12 <lambdabot> Prelude
07:34:14 <EvilTerran> er, what "until" is to "fix", either
07:34:16 <EvilTerran> *even
07:34:21 <sw17ch> but for this situation, it seems better to use something like "do the action until it fails"
07:34:34 <EvilTerran> ?type let untilM p f x = do px <- p x; if px then x else untilM p f =<< f x in untilM
07:34:35 <lambdabot> forall (t :: * -> *) t1. (Monad t) => (t t1 -> t Bool) -> (t t1 -> t (t t1)) -> t t1 -> t t1
07:34:39 <sw17ch> in this case... (Just x) >>= ... >>= Nothing
07:34:42 <EvilTerran> hm
07:34:44 <sw17ch> will stop at the Nothing
07:34:56 <EvilTerran> should those be >>?
07:34:57 <sw17ch> instead of Nothing >>= Nothing >>= ....
07:35:10 <sw17ch> EvilTerran: with the maybe type, probably :P
07:35:13 <EvilTerran> (>>) rather than (>>=), i mean
07:35:27 <sw17ch> EvilTerran: but in this case i want to pass the result of the last action as the input to the next
07:35:37 <sw17ch> (hopefully in a tail-recursive way)
07:35:39 <EvilTerran> right
07:35:42 <sw17ch> (it's a game loop!)
07:35:53 <inimino> ah
07:36:15 <EvilTerran> ?src forever
07:36:15 <lambdabot> Source not found.
07:36:28 <dmwit> Just write one.
07:36:40 <dmwit> I think the obvious consensus here is that no, it doesn't really exist in the libraries.
07:36:49 <inimino> yeah
07:36:55 <sw17ch> yes... now i suppose the problem is picking up on when fail happens
07:37:05 * EvilTerran is looking at Control.Applicative.many, but it doesn't seem quite right
07:37:06 <dmwit> I recommend not trying to use fail for this.
07:37:18 <dmwit> Either have an explicit condition, or use a MonadPlus.
07:37:26 <sw17ch> dmwit: yeah, it was just the abstraction i figued it would exist as in a library
07:37:29 <sw17ch> but since it doesn't exist :P
07:37:43 <dmwit> There is no uniform way to catch a fail.
07:37:59 <sw17ch> It will probably be Either with a Right -> continue, Left -> finish
07:38:54 <sm> morning all
07:39:07 <sm> anyone familiar with setting up a web-based hoogle ?
07:39:34 <sm> is it possible to browse the code/config of http://haskell.org/hoogle/ ?
07:39:37 <lambdabot> Title: Hoogle
07:39:50 <dmwit> I think Hoogle is on Hackage.
07:40:01 <sw17ch> @hackage hoogle
07:40:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hoogle
07:40:04 <sw17ch> woot
07:40:19 <dmwit> ?hackage thisdefinitelydoesnotexist
07:40:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/thisdefinitelydoesnotexist
07:40:24 <dmwit> ;-)
07:40:28 <sw17ch> hahahah
07:40:37 <sw17ch> lambdabot: what a lazy bot
07:40:44 <sw17ch> making things like assumptions...
07:41:19 <dmwit> It certainly makes the response faster.  No h.org round trip. =)
07:41:37 <rizobs> join irc.esylum.net #bishes-chat type !rizobs for access to our pre-channel & fast bots
07:41:39 <rizobs> join irc.esylum.net #bishes-chat type !rizobs for access to our pre-channel & fast bots
07:41:41 <rizobs> join irc.esylum.net #bishes-chat type !rizobs for access to our pre-channel & fast bots
07:41:42 <sw17ch> i'd rather have a longer correct response than a short possibly correct one
07:42:33 <subconscious> how would you do this?
07:42:34 <subconscious>  unify x y = do deref'x <- deref x
07:42:34 <subconscious>                 deref'y <- deref y
07:42:34 <subconscious>                 case (deref'x, deref'y) of
07:42:36 <EvilTerran> > runStateT (forever $ do (x,y) <- get; guard (x /= 0); put (x-1,y+x)) (10,0)
07:42:37 <lambdabot>       No instance for (Show (m ((), (t, t))))
07:42:37 <lambdabot>        arising from a use of `s...
07:42:44 <subconscious> other than that way?
07:42:55 <EvilTerran> > runStateT (forever $ do (x,y) <- get; guard (x /= 0); put (x-1,y+x) :: StateT (Int,Int) Maybe ()) (10,0)
07:42:56 <lambdabot>   Nothing
07:43:00 <EvilTerran> hm
07:43:22 <EvilTerran> i guess that needs to be MaybeT (State (Int,Int)) ()
07:43:31 <dmwit> subconscious: What's wrong with that (other than the pointers)?
07:43:50 <EvilTerran> ?instances Error
07:43:51 <lambdabot> IOError, String
07:44:00 <dmwit> subconscious: If you really want to eliminate the case, you could write a function that does whatever that case does and then (liftM2 foo (deref x) (deref y)).
07:47:46 <EvilTerran> > runState (runErrorT $ forever $ do (x,y) <- get; guard (x /= 0); put (x-1,y+x)) (10,0) :: (Either String (), (Int,Int))
07:47:47 <lambdabot>   (Left "",(0,55))
07:48:21 <EvilTerran> sw17ch, there's an example of getting a meaningful result out of "forever" by using a MonadError
07:48:44 <solrize> byorgey, yeah, i just wanted to ask/mention about the blogroll in HWN
07:48:48 <EvilTerran> which lets you short-circuit the "tail" of a monadic computation, and so escape the "forever"
07:48:58 <byorgey> solrize: oh, what about it?
07:49:18 <sw17ch> EvilTerran, thanks
07:49:34 <solrize> byorgey, the one at the upper right hasn't changed since last march or something like that
07:49:36 <EvilTerran> it'd be a lot nicer with MaybeT instead of ErrorT
07:50:00 <byorgey> solrize: oh, on sequence.complete.org you mean?
07:50:03 <sw17ch> EvilTerran, yes, or with EitherT i'm guessing
07:50:06 <solrize> yeah
07:50:23 <EvilTerran> you could use execState instead of runState, too, seeing as the computation's "final value" is uninteresting (being of type ())
07:50:26 <byorgey> solrize: those are blogs actually hosted on sequence.complete.org
07:50:37 <byorgey> there aren't many which is why it doesn't update very often.
07:50:43 <solrize> oh i see, that isn't part of HWN?
07:50:46 <byorgey> nope
07:50:51 <solrize> aha.
07:50:55 <EvilTerran> sw17ch, er, ErrorT is what MTL calls the transformer version of Either
07:51:00 <solrize> where is hwn canonically hosted?
07:51:05 <EvilTerran> albeit with a stupid class constraint on the first parameter
07:51:08 <sw17ch> EvilTerran, oh... good point :)
07:51:12 <EvilTerran> MonadLib may have a more sensible EitherT
07:51:20 <byorgey> solrize: sequence.complete.org is the canonical host.
07:51:31 <byorgey> it just isn't used for much else these days.
07:51:35 <EvilTerran> sw17ch, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadLib
07:51:43 <lambdabot> Title: HackageDB: monadLib-3.4.4, http://tinyurl.com/5ku9e4
07:51:50 * EvilTerran wanders off
07:51:54 <solrize> k
07:52:01 <thoughtpolice> monadLib = niceness :]
07:54:02 <pmurias> when will be ghc 6.10.1 released?
07:54:58 <sw17ch> has 6.10 been released?
07:54:59 <byorgey> pmurias: the word on the street is, in a few weeks
07:55:07 <byorgey> there is a release candidate
07:55:11 <sw17ch> oic
07:55:21 <sw17ch> can this one boot strap from C again?
07:55:27 <byorgey> it kind of depends on how many bugs are found in the rc =)
07:55:39 <thoughtpolice> no it can't
07:55:49 <thoughtpolice> hc bootstrapping has been put off until 6.12
07:55:56 <sw17ch> D:
07:56:07 <thoughtpolice> because the build system is going under a massive overhaul in the HEAD after 6.10 has settled down
07:56:13 <FunctorSalad_> any particularly funny novelties in ghc 6.10?
07:56:15 <thoughtpolice> that is also why the new native code gen didn't make it in
07:56:16 <maltem> byorgey: since if too little are found, then we must assume that most bugs have not been fixed? or the other way around? :)
07:56:22 <sw17ch> will this overhaul allow me to port to an ARM chip finally? :D
07:56:22 <FunctorSalad_> (yes I know I should just read the list ;-))
07:56:28 <byorgey> maltem: hehe =)
07:56:43 <thoughtpolice> sw17ch: hopefully the new backend + new buildsystem will help ghc be more like a cross compiler
07:57:00 <byorgey> FunctorSalad_: I think it includes the Data Parallel extensions, and more solid support for type families
07:57:02 <sw17ch> yes... the C-- backend should be easier to port
07:57:16 <pmurias> FunctorSalad_: audreyt is waiting for quasi-quotes
07:57:24 <thoughtpolice> byorgey: there's DPH there in a certain form, type families should be fully working, parallel garbage collector, quasiquoting+viewpatterns
07:57:37 <thoughtpolice> all very nice things
07:57:45 <byorgey> ah, quasiquoting and view patterns! nice! =)
07:57:53 <FunctorSalad_> byorgey: I still have to look at those type families...
07:57:57 * byorgey is excited to play with quasiquoting
07:58:01 <byorgey> FunctorSalad_: me too
07:58:01 <thoughtpolice> type families = win
07:58:05 <thoughtpolice> quasiquoting = win
07:58:10 * sw17ch thinks quasiquoting syntax looks ugly
07:58:13 <thoughtpolice> especially because for QQ if you already have a parser
07:58:16 <FunctorSalad_> pmurias: isn't quasiquoting what the TH [| |] brackets do?
07:58:20 <thoughtpolice> you are about 90% done already
07:58:22 <byorgey> [q|uasiquoting|]
07:58:55 <thoughtpolice> if mmorrow ever makes a patch for ndm's derive package to derive TH lift, then you will have to do even LESS work to make a QQ for your language
07:59:00 <thoughtpolice> making one built on Language.C was cool
07:59:17 <pmurias> thoughtpolice: quasi-quotes support non-haskell syntax
07:59:45 <thoughtpolice> sure, we built a C quasiquoter, there's a regex one and even a javascript one
07:59:48 <thoughtpolice> it's real fun to play with
08:00:00 <FunctorSalad_> the syntax tree datatypes from the TH library are not that hard either though
08:00:09 <thoughtpolice> you just need a parser + a TH Lift instance
08:00:11 <thoughtpolice> and you are on your way
08:00:13 <FunctorSalad_> you can mostly figure it out from the @info
08:00:14 <subconscious> ugh no instance for Applicative (GenParser Char ())
08:00:18 <subconscious> there used to be :|
08:00:49 <FunctorSalad_> and don't have to learn any new syntax issues
08:00:55 <thoughtpolice> FunctorSalad_: the DPH stuff in the 6.10 release is usable but there are some pitfalls in there as well
08:01:04 <thoughtpolice> rl was real helpful in pointing them out to me
08:01:26 * FunctorSalad_ doesn't know about DPH :-(
08:01:29 <subconscious> @instances Applicative
08:01:30 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
08:02:42 <subconscious> how do I get the applicative instance back?
08:02:46 <thoughtpolice> but yes hopefully if 6.12 can bring a cross compiler with the new backend and a new build system, that would be lovely.
08:02:58 <thoughtpolice> i'll have to check out head and try the new codegen after 6.10 is settled
08:03:04 <FunctorSalad_> btw was the spices-can't-use-other-splices thing fixed? the doc says it's hard to get right, but maybe add a -XSplicesImFeelingLucky flag? :)
08:03:30 <FunctorSalad_> it's a bit annoying if you have some declareFoobar macro and need to declare several foobars referring to each other
08:05:21 <FunctorSalad_> or maybe that particular example worked, I didn't use it much yet
08:06:08 <subconscious> I wish they wouldn't keep breaking the libraries in incompatable ways
08:06:55 <pmurias> is possible to have vim (or any other vi clone) print the type of thing under the cursor
08:07:00 <pmurias> * it it
08:07:04 <pmurias> * is it
08:07:13 <FunctorSalad_> subconscious: I thought that was a feature, not a bug :)
08:07:30 <FunctorSalad_> (remaining small so you can fix things)
08:07:31 <quicksilver> pmurias: yes.
08:07:37 <quicksilver> pmurias: _t, I believe.
08:07:42 <quicksilver> but don't use vim :)
08:08:07 <pmurias> quicksilver: what vi-like editor should i use?
08:09:31 <FunctorSalad_> by the way, haskell-mode hint: it only shows prelude function types on its own but C-c C-t knows about all the functions currently loaded on the inferior haskell shell :)
08:09:39 <FunctorSalad_> really useful
08:11:58 <Araneidae> Think I'm missing something basic.  I've followed the instructions to build and install Yi (runghc Setup configure --user && runghc Setup build && runghc Setup install) and there's nothing to execute anywhere in .cabal.  Where's it gone?!
08:12:12 <quicksilver> pmurias: sorry, there was a missing word.
08:12:18 <quicksilver> pmurias: "I don't use vim" is what I meant to say
08:12:29 <quicksilver> pmurias: so my information may not be fully complete :)
08:12:49 <quicksilver> FunctorSalad_: in my experience it shows types in the current project too.
08:13:05 <quicksilver> FunctorSalad_: pehaps only when it's been loaded in inf-haskell, I'm not sure.
08:13:23 <dmwit> pmurias: I use http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ and it provides the _t command quicksilver referred to.
08:13:26 <lambdabot> Title: Haskell mode for Vim
08:13:46 <FunctorSalad_> quicksilver: but it doesn't show types of imported modules even when they're loaded, /unless/ you've C-c C-t that function already
08:13:53 <FunctorSalad_> then it remembers and shows it automatically
08:18:16 <quicksilver> FunctorSalad_: Ah.
08:18:28 <pcc1> if I have a module A which contains template haskell transformations, and a module B which uses those transformations, ghc does not recognise that B needs to be recompiled when A is (I get a message "compilation is not required"). is this a known bug?
08:18:30 <quicksilver> FunctorSalad_: thanks. that would explain it.
08:18:48 <pcc1> I mean, when A is changed
08:20:11 <inimino> is there a function somewhere for fast intersection on sorted lists?
08:21:02 <quicksilver> pcc1: is it http://hackage.haskell.org/trac/ghc/ticket/481
08:21:04 <lambdabot> Title: #481 (Recompilation check fails for TH) - GHC - Trac
08:21:32 <pcc1> quicksilver: yes, thanks
08:21:41 <quicksilver> no problem.
08:21:47 <quicksilver> my google-fu is strong :)
08:21:48 <maltem> Araneidae: er, it should be there, actually
08:22:07 <quicksilver> "inurl:trac  site:hackage.haskell.org template haskell recompilation"
08:22:25 <inimino> I want something like Data.List.intersect but I know the lists are sorted
08:22:31 <quicksilver> inimino: not in the standard lib, though.
08:22:38 <inimino> seems like it would be not that rare
08:22:41 <maltem> Araneidae: Do you have at least a copy of the executable in ./dist/build/yi/ ?
08:22:43 <quicksilver> inimino: you get the right complexity if you push through Data.Set.fromAscList
08:22:45 <pmurias> dmwit: how should i install it?
08:22:48 <Araneidae> maltem, maybe it's because I guilt from darcs head?
08:23:00 <quicksilver> inimino: (but you pay a constant factor for the translation to Set and back)
08:23:07 <inimino> oh, right
08:23:10 <quicksilver> inimino: hmm. Or if theu're not unique, that's a bad idea :)
08:23:19 <pmurias> i typed mkdir ~/.vim;vim haskellmode* and :%so and :q
08:23:23 <inimino> they are unique
08:23:31 <Araneidae> maltem, there are no executables in my Yi directory at all!
08:23:31 <maltem> Araneidae: no (unless you got a version where building fails, but then there should be an error)
08:23:33 <inimino> but it needs to be fast, so I'll just write it
08:23:46 <Araneidae> `find  -type f -perm /u+x` returns nothing
08:24:50 <Araneidae> When I used cabal to install it instead, cabal first said it's already installed and then when I said --reinstall successfully dowloaded and built something (still can't get it to run, tho...)
08:24:53 <maltem> Araneidae: and you really didn't get an error message about it?
08:25:14 <Araneidae> Blast: running yi cleared my scrollback bufffer :(
08:25:23 <Araneidae> Let me re-run the build
08:25:49 <Araneidae> Preprocessing library yi-0.4.7...
08:25:50 <Araneidae> Preprocessing executables for yi-0.4.7...
08:25:50 <Araneidae> Building yi-0.4.7...
08:25:50 <Araneidae> /usr/bin/ar: creating dist/build/libHSyi-0.4.7.a
08:25:59 <maltem> Araneidae: btw I think that runghc Setup does not install into .cabal by default, but that's probably not relevant here
08:26:04 <Araneidae> That's all it says, and there are still no executables to be found.
08:26:25 <maltem> Araneidae: apparently no frontend has been compiled
08:26:33 <Araneidae> Ok
08:26:42 <maltem> Araneidae: ok, I think I know what's going on
08:26:59 <Araneidae> Say more!
08:27:09 <dons> ?users
08:27:10 <lambdabot> Maximum users seen in #haskell: 516, currently: 475 (92.1%), active: 14 (2.9%)
08:27:24 <maltem> Araneidae: It didn't find enough libraries for any frontend, but it didn't tell you that's bad
08:27:50 <maltem> Araneidae: That's what I suppose anyway. Do you have vty installed?
08:27:56 <Araneidae> That makes sense.  This is a pretty fresh ghc install
08:28:07 <maltem> ah ok
08:28:17 <Araneidae> I didn't, but when I asked cabal to do the install I saw it installing vty, I think.
08:28:18 <maltem> Then start out with cabal install vty
08:28:26 <maltem> uh
08:28:34 <Araneidae> Yes it's there now.
08:28:42 <maltem> damn, theory gone.
08:28:58 <Araneidae> No, that could be right.  I probably have to rerun configure as well.
08:29:09 <Araneidae> Is there a clean step I can do?
08:29:16 <maltem> cabal clean
08:29:18 <pmurias> dmwit: thanks, it works now ;) but does it add to blank lines at the bottom of you terminal too?
08:29:24 <maltem> (in the source tree)
08:29:38 <Araneidae> Well ... but I didn't use cabal for the failing build, just runghc Setup.
08:29:57 <maltem> oh, that should be no matter. Alternatively try, runghc Setup clean
08:30:03 <maltem> that should be the same
08:30:16 <subconscious> how do you copy a structure with STRefs in it?
08:30:19 <Araneidae> Ok, building again.
08:30:41 <maltem> Araneidae: the -fvty flag could also help on configure
08:30:46 <quicksilver> subconscious: you mean you want to make new STRefs?
08:30:51 <subconscious> yes
08:30:58 <maltem> Araneidae: to make sure there will be an error if vty is not found
08:30:59 <quicksilver> by recursion.
08:31:02 <quicksilver> there is no general way.
08:31:03 <Araneidae> However, the build I do have (0.4.7, installed by cabal) fails when I run it.  (Seperate problem).
08:31:06 <quicksilver> uniplate might help.
08:31:29 <maltem> Araneidae: how does it fail?
08:31:51 <Araneidae> Launching custom yi: "/home/michael/.yi/yi-i386-linux"
08:31:51 <Araneidae> yi-i386-linux: Prelude.head: empty list
08:32:12 <Araneidae> I copied a yi.hs from http://code.haskell.org/yi/examples/ into ~/.yi
08:32:12 <lambdabot> Title: Index of /yi/examples
08:32:49 <maltem> Araneidae: maybe try --recompile-force (or --force-recompile, whatever was the right spelling)
08:32:56 <Araneidae> Without that it starts up, but whinges about not finding yi-i386-linux.  This time it's built it, but bails
08:33:18 <Araneidae> Aha: the new build has successfullly build dist/build/yi/yi!  I'll try installing it.
08:33:53 <Deewiant> -fforce-recomp
08:33:53 <Araneidae> That's better.
08:34:31 <maltem> Deewiant: no, that was a yi flag
08:34:31 <Araneidae> So to recap (it's a bit muddled): 1/ building yi from source in a fresh environment silently failed to notice vty was missing!
08:34:35 <quicksilver> abbreviations--
08:34:45 <Deewiant> maltem: ah, darn
08:34:45 <inimino> looks reasonable? http://hpaste.org/10703
08:34:53 <quicksilver> the thing about abbreviations is that it is so hard to forget which one you chose.
08:34:56 <mc__> I'm trying to do TDD for the first time. I wonder how one would test functions which only do I/O
08:35:10 <Araneidae> 2/ using cabal to install yi instead correctly installed vty (and some other stuff), but it's build wouldn't run properly...
08:35:25 <Araneidae> 3/ rebuilding from source once (2) was done seems ok (so far)
08:35:40 <inimino> mc__: did you look at HUnit?
08:36:13 <maltem> ad 1: Perhaps that's because *.cabal files cannot express "at least one frontend is needed"? not sure though
08:36:50 <mc__> inimino: I'm using QuickCheck
08:36:59 <maltem> ad 2: I suspect that your yi.hs wasn't suited for that yi version (the examples directory tends to be outdated, even)
08:37:07 <mc__> I just dont get it how to write the test for an I/O function
08:37:34 <Araneidae> maltem, yes that seems likely.  Now I guess I have figure out how to configure it properly!
08:37:47 <subconscious> why can't I use _ in type annotations?
08:37:58 <inimino> oh, I don't know QuickCheck
08:38:20 <Araneidae> Doesn't seem to understand <Home> and <end>, annoyingly, for a start.  Time to do some reading...
08:38:34 <mc__> well my question does not really have anything to do with QuickCheck itself anyways :)
08:39:42 <BeelsebobWork> mc__: there shouldn't really be any IO to test
08:39:56 <BeelsebobWork> it should all be in one or two functions at your top level
08:40:26 <BeelsebobWork> in the mean time, testing IO is rather infeasable, because you need to test side effects, which gets you back to the same story as trying to do testing for imperative programs
08:42:01 <inimino> you might just write an external program to do the test
08:43:40 <mc__> hm, dont like that Idea, does anyone in here use TDD? I just wonder what practice others use then.  Do you Simply skip the test for the I/O functions?
08:44:22 <subconscious> @report
08:44:22 <lambdabot> ()
08:44:38 <subconscious> this could like to the report
08:44:54 <idnar> @help report
08:44:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:44:56 <jeffz> what's wrong with testing side effects?
08:45:15 <quicksilver> mc__: the point is that quickcheck is not designed for IO ()
08:45:20 <quicksilver> mc__: so it *is* relevant.
08:45:22 <BeelsebobWork> mc__: in practice, I don't need to test IO functions, because the entirity of my IO based stuff is 4 lines
08:45:34 <quicksilver> however there are approaches that people use.
08:45:46 <quicksilver> if you can push all the testable stuff out of IO, that's great.
08:45:52 <quicksilver> if you can't, then...
08:46:03 <quicksilver> a nice, but heavyweight approach, is to abstract the IO out into something abstract
08:46:07 <quicksilver> and have a pure model of it
08:46:11 <thoughtpolice> jeffz: it's difficult
08:46:16 <quicksilver> I have a pure model of 'seekable files'
08:46:33 <quicksilver> which I use to test code which is designed to work with hSeek etc.
08:46:43 <mc__> I see
08:46:57 <quicksilver> (the pure model makes it into functions from ByteString -> result)
08:47:04 <quicksilver> or Bytestring -> Bytestring,a
08:47:08 <thoughtpolice> jeffz: at least, relative to pure functions, it's more difficult
08:47:25 <thoughtpolice> there was some paper about using quickcheck for the IO monad
08:47:32 <quicksilver> yes, there was
08:47:38 <quicksilver> there are various other approachs people have used
08:47:43 <quicksilver> including unsafePerformIO
08:47:44 <jeffz> thoughtpolice: do you mean more difficult to write automatic tests?  because it's not difficult to write side effecting tests manually
08:48:09 <inimino> mc__: what do you need to test?
08:48:53 <mc__> inimino: the function just reads to lines, tries to parse them as Int's and returns them as a tuple
08:49:08 <mc__> s/to/two
08:50:09 <thoughtpolice> http://www.cs.nott.ac.uk/~txa/publ/beast.pdf
08:50:15 <lambdabot> Title: Beauty in the Beast
08:50:17 <maltem> mc__: you could leave off the "reads" part, then you can test a pure function and just hope that file I/O is implemented properly
08:51:28 <mc__> i see
08:51:47 <inimino> mc__: or you could write an external test that feeds it lines and expects a certain output
08:52:10 <mc__> inimino: thats a bit overdoing it and it would not integrate nicely with my test suite
08:52:19 <inimino> but I'd do what maltem suggested for something so simple
08:53:57 <thoughtpolice> jeffz: no, hunit for example makes it pretty easy - but with pure (and total) functions, i just think it's easier to have just a declarative property that should hold, which is tested for you.
08:58:24 <pmurias> mc__: you could write a mock IO monad
09:01:24 <pmurias> or if you do lots of testing IO you could use TAP(testanything.org) and use perlish tools to process it
09:03:57 <subconscious> ok
09:04:11 <subconscious> I wrote out a unifier based from htat typed logic variables thing
09:04:26 <subconscious> it seems to work I tested it on type checking a page of code
09:05:19 <subconscious> ?where moonpaste
09:05:19 <lambdabot> I know nothing about moonpaste.
09:05:39 <subconscious> oh well, here it is with a couple examples http://hpaste.org/10704
09:06:16 <subconscious> so I would like to ask if there are some additions or anything which could be changed for the better?
09:07:07 <subconscious> (It may be possible to use TH to generate the instances automatically for a large class of data types)
09:10:09 <subconscious> oh I will add an occurs check actually
09:10:33 <ulrivo> hello. I was looking at a gtk2hs-tutorial today. Everything fine with ghc. But when testing with ghci I got a "panic error". I found a similar report at ghctrac, but I did not find a solution. Is it possible to use gtk2hs with ghci?
09:11:19 <dcoutts> ulrivo: on windows?
09:11:19 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
09:12:02 <ulrivo> dcoutts: yes...on windows
09:12:21 <dcoutts> ulrivo: on windows atm, you'll have to use gtk2hs with ghc --make
09:12:58 <ulrivo> dcoutts: what a pity. but thanks a lot for your answer
09:13:40 <dcoutts> ulrivo: I know it worked in an older release
09:14:19 <dcoutts> ulrivo: it's a new problem with a later mingw and the ghci linker, I think it's fixed in the latest ghc
09:14:41 <pgavin> dcoutts: c2hs in gtk2hs needs to be fixed for 6.10
09:15:01 <dcoutts> pgavin: ah 'k
09:15:12 <pgavin> dcoutts: I can do it, but I just wanted to let you know :)
09:15:14 <ulrivo> dcoutts: I googled for the error but could not find it. I am using the latest releases of ghci, gtk and gtk2hs
09:16:57 <dcoutts> ulrivo: sorry, I mean ghc-6.10 which is not quite released yet
09:18:28 <ulrivo> dcoutts: my error is with ghc 6.8.3
09:33:09 <Araneidae> How do I persuade Yi to build Yi.UI.Gtk?
09:34:09 <mm_freak> what's a "higher order language"?!
09:35:24 <Philippa> mm_freak: normally one that supports higher order functions or an equivalent
09:35:34 <Araneidae> Hmm.  There's a "flag gtk" entry in yi.cabal, but configure --gtk doesn't work.
09:35:49 <mc__> mm_freak: which means you can use functions as values
09:36:10 <Araneidae> So any functional language is automatically "higher order"?
09:36:18 <dcoutts> Araneidae: configure -f gtk
09:36:25 <Araneidae> -f?  Thanks.
09:36:55 <Araneidae> Ah: I see it in the help text now.
09:37:59 <Araneidae> Hmm.  I need the dependency "gtk >=0.9.13 && >=0.9.13" .. but `cabal install gtk` complains cabal: There is no package named gtk
09:39:28 <Nafai> Is it gtk2hs?
09:39:54 <thoughtpolice> dcoutts: what can you put in your ~/.cabal/configure to control where binaries installed with cabal-install go e.g. $HOME/bin?
09:40:09 <byorgey> yeah, if you want a gtk front end, you have to install gtk2hs, which unfortunately is not yet Cabalized
09:40:17 <byorgey> (unless someone did it while I wasn't looking)
09:40:21 <byorgey> @where gtk2hs
09:40:22 <lambdabot> http://haskell.org/gtk2hs/
09:40:28 <byorgey> you can download it from that website though
09:40:33 <Araneidae> Ok.  Thought I'd installed it as a dpkg, but maybe that didn't work properly.
09:40:59 <thoughtpolice> dcoutts: can you put something in your ~/.cabal/configure to control where binaries go?
09:41:05 <byorgey> well, installing the gtk libraries and headers themselves (which you will also need) is not the same thing as the haskell bindings to it
09:41:15 <mm_freak> Philippa, mc__: uhm…  that appears like a "functional language", not a "higher order language" =)
09:41:20 <Nafai> byorgey: How's school?
09:41:21 <thoughtpolice> (with cabal install 0.5.2)
09:41:35 <mc__> mc__: really? are you sure?
09:41:37 <Araneidae> I installed libghc6-gtk-dev which claimed to be part of gtk2hs, but I'll follow that link
09:41:39 <byorgey> Araneidae: don't worry, yi is particularly difficult to build, most things are much easier =(
09:41:55 <byorgey> Araneidae: ah, I see what you mean.  hm, then I'm not sure.
09:41:57 <Araneidae> thanks for the encouragement!  Well, it begins to work...
09:42:14 <byorgey> Nafai: it's great!
09:42:28 <byorgey> at the moment I'm working on a proof of type safety for System F + existential types =)
09:42:39 * Nafai has no idea what that means :)
09:43:01 <byorgey> well, a week ago, I didn't either! =)
09:43:16 <subconscious> I wrote a "simple" example http://hpaste.org/10705 :p
09:43:55 <subconscious> I hope that maybe occurs can be written better but hopefully gives an idea
09:45:09 <subconscious> but yeah I would appreciate any comments
09:45:19 <subconscious> (on the unification thing)
09:48:08 <Araneidae> Is Unification your own class, subconscious?
09:49:35 <Araneidae> Just looking for the whole story...
09:54:02 <Araneidae> subconscious, interested in your example ... but missing the important bit!
09:57:33 <_zenon_> omg, they are 702 users over at #PHP
09:58:04 <JuanDaugherty> not unusual, #debian and a number others are like that
09:58:50 <_zenon_> yeah, but debian is not a programming lang :)
09:59:03 <inimino> neither is PHP
09:59:07 * inimino ducks
09:59:10 <_zenon_> :)
09:59:19 <_zenon_> inimino, you are among friends here...
09:59:28 <inimino> hehe
09:59:46 * _zenon_ has to eat, damn... why do you have to eat?
09:59:52 <JuanDaugherty> "PHP and HTML Coder Needed - Great for Students"
10:00:27 <inimino> PHP is very easy to learn, it's true
10:01:05 <JuanDaugherty> no I meant the tired ass line, like "will lead to more work if this works out"
10:01:19 <inimino> heh
10:01:55 <inimino> "no pay, but a chance to get in on the ground floor"
10:02:18 <JuanDaugherty> Paklids All
10:04:30 <JuanDaugherty> *Pakled ( http://en.wikipedia.org/wiki/Pakled )
10:04:31 <lambdabot> Title: Samaritan Snare - Wikipedia, the free encyclopedia
10:06:14 <JuanDaugherty> <programProductX> Guru/Expert Needed is what I had in mind there
10:07:05 <inimino> heh
10:07:20 <subconscious> Araneidae: oops, sorry, that's here http://hpaste.org/10704
10:07:55 <subconscious> I'd like to have this in a good enough state that it should be actually useful on its own, which is why I'm fishing for comments about it
10:10:18 <subconscious> maybe I should automate it with TH
10:10:31 <subconscious> something akin to deriving Unifiable
10:11:29 <subconscious> would it be over complicating things to have it run in arbitrary monad plus transformers?
10:19:41 <Araneidae> Cheers.
10:20:30 <Araneidae> I'm thinking about unification, but I'm at a very basic level at the moment.  I'll see if I can understand your code!
10:20:52 <subconscious> ok ask me anything :)
10:21:17 <subconscious> I am trying to improve bits of this.. adding error message support
10:24:07 <Araneidae> There isn't an occurs method in that Unifiable!
10:24:19 <subconscious> hehe
10:24:25 <subconscious> I've added
10:24:27 <subconscious>  occurs :: Variable s tm -> tm -> Unify s Bool
10:24:31 <subconscious> since I pasted it
10:24:45 <subconscious> but there is no general definition, not sure if I can perhaps automate bits of it - I'll see
10:26:19 <Araneidae> Also ghc complains about the instance declaration:     Illegal instance declaration for `Unifiable s (T s)'
10:26:29 <Araneidae> Am I missing a ghc extension flag?
10:26:54 <Araneidae> Sorry: I should read the *whole* message!
10:38:01 <dons> hey guys, a job. there's a rumour going around that haskell has been accepted as a language for the ACM programmign contest, http://twitter.com/jcchurch/statuses/933573132
10:38:11 <dons> can anyone find more info on this, since it would be huge.
10:38:11 <lambdabot> Title: Twitter / James Church: Programming language gurus ...
10:38:20 <dons> "The Comp. is
10:38:20 <dons> now C, C++, Java, Python, and Haskell."
10:39:44 <znutar_> wow, that's surprising
10:40:12 <dons> this would be a big deal. lots and lots of people enter the contest.
10:40:21 <dons> and if haskell is the canonical functional language...
10:41:05 <znutar_> Are the ACM programming questions as amenable to a functional approach as say the ICFP tasks are?
10:41:56 <dons> ICFP isn't terribly amenable.
10:42:03 <dons> i'd say ACM is far more amenable. More mathy.
10:42:31 <subconscious> do view pattern like,
10:42:36 <subconscious> foo (x -> Nothing) = ...
10:42:41 <subconscious> foo (x -> Just e) = ...
10:42:51 <subconscious> get compiled away so that x is performed once?
10:43:07 <dons> you'd have to look at how views are compiled.
10:43:11 <subconscious> ok
10:43:17 <dons> that looks like:
10:43:26 <dons> foo x | Just e <- x = ..
10:43:33 <dons>        | otherwise = ...
10:43:39 <subconscious> I mean a function x
10:43:46 <subconscious> something that is non trivial to compute
10:44:06 <dons> right.
10:44:07 <dons> like above :)
10:44:14 <dons> pattern guards are less general than views.
10:44:19 <dons> but 'x' is arbitrary
10:44:41 <subconscious> um my code is different to your one
10:44:51 <dons> it is?
10:45:01 <dons> looks like you evaluate 'x' and case on it to me.
10:45:11 <subconscious> what I meant is say, foo 348 and (x 348) may be Nothing or Just "somethiing"
10:45:15 <dons> isn't it also just, foo x = case x of Just e -> .. ; Nothing -> ...
10:45:25 <subconscious> no, view patters are like
10:45:38 <subconscious> last (reverse -> e:_) = e
10:46:02 <dons> what's the desugaring of that, according to the views wiki page?
10:46:09 <subconscious> ~~>  last x = case reverse x in e:_ -> e
10:46:32 <subconscious> oh I think it desugards to something like  last x | e:_ <- reverse x = e
10:46:42 <dons> right. same thing I wrote :)
10:46:50 <subconscious> no different to what you wrote
10:48:59 <arjanb> hmm then what's the point of views other than looking different from pattern guard?
10:49:32 <dons> you can do parsing in the pattern match.
10:49:47 <dons> good overview, http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
10:49:48 <subconscious> @seen lunabot
10:49:49 <lambdabot> I saw lunabot leaving #haskell 1d 8h 12m 52s ago, and .
10:49:50 <lambdabot> Title: ViewPatterns - GHC - Trac
10:50:00 <arjanb> thx
10:52:48 <Deewiant> hpaste> Deewiant pasted "argh, ugly" at http://hpaste.org/10706
10:53:05 <plutonas> am i right that type is like aliasing complicated types, and data is for defining structures?
10:53:13 <Deewiant> yep
10:53:27 <subconscious> > liftM3 (,,) [0,1,2] [0,1] [0,1]
10:53:28 <lambdabot>   mueval: Prelude.read: no parse
10:53:37 <plutonas> Deewiant: was this for me? :)
10:53:45 <Deewiant> plutonas: yep :-)
10:53:49 <plutonas> ok, thanks
10:53:51 <subconscious> > let liftM3 f x y z = do x' <- x ; y' <- y ; z' <- z ; return (f x y z) in liftM3 (,,) [0,1,2] [0,1] [0,1]
10:53:52 <lambdabot>   [([0,1,2],[0,1],[0,1]),([0,1,2],[0,1],[0,1]),([0,1,2],[0,1],[0,1]),([0,1,2]...
10:54:01 <subconscious> haha
10:54:05 <Deewiant> not quite ;-P
10:54:05 <subconscious> > let liftM3 f x y z = do x' <- x ; y' <- y ; z' <- z ; return (f x' y' z') in liftM3 (,,) [0,1,2] [0,1] [0,1]
10:54:07 <lambdabot>   [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1),(2,0,0),(2...
10:54:49 <subconscious> @let liftM3 f x y z = do x' <- x ; y' <- y ; z' <- z ; return (f x' y' z')
10:54:51 <Deewiant> subconscious: not satisfactory, I don't want to compute lengths
10:54:52 <lambdabot>  Defined.
10:55:04 <Deewiant> > liftM3 (,,) [0..] [0..] [0..]
10:55:06 <lambdabot>       Ambiguous occurrence `liftM3'
10:55:06 <lambdabot>      It could refer to either `L.liftM3',...
10:55:09 <Deewiant> > L.liftM3 (,,) [0..] [0..] [0..]
10:55:11 <lambdabot>   [(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0...
10:55:14 <Deewiant> that doesn't work :-)
10:58:09 <hackage> Uploaded to hackage: xml 1.3.2
10:59:18 <arjanb> maybe i just need to used to them but now view patterns look only useful for obfuscation
10:59:44 <mm_freak> > [ (a,b,c) | a <- [0,1,2], b <- [0,1,2], c <- [0,1,2] ]
10:59:46 <lambdabot>   [(0,0,0),(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1...
11:00:59 <subconscious> arjanb,
11:01:15 <subconscious> mergeSort [] = []
11:01:18 <subconscious> mergeSort [e] = [e]
11:01:19 <subconscious> mergeSort (halve -> (left , right)) = (merge`on`mergeSort) left right
11:01:21 <subconscious> actualy I would write
11:01:24 <subconscious> mergeSort (halve -> left right)
11:01:30 <subconscious> but it's not implemented or something
11:04:54 <EvilTerran> > concat.concat . zipWith (zipWith zip) [[[(x,y,z) | x <- [1..]] | y <- [1..]] | z <- [1..]] $ [["foo","bar","baz"],["alpha","beta","gamma"]]
11:04:55 <lambdabot>   [((1,1,1),'f'),((2,1,1),'o'),((3,1,1),'o'),((1,2,1),'b'),((2,2,1),'a'),((3,...
11:05:19 <EvilTerran> er, those should be [0..], but that aside from that
11:06:54 <subconscious> I would really use a kind of 'caseM'
11:07:06 <subconscious> do x <- a
11:07:09 <subconscious>    case x of ...
11:07:11 <subconscious> is happening a lot
11:07:54 <inimino> what's that bit about (halve -> (left, right))?
11:08:08 <inimino> I don't see what you're doing there
11:08:14 <EvilTerran> that's view patterns
11:08:22 <EvilTerran> we've just been talking about em
11:08:28 <inimino> oh
11:08:42 <inimino> it's an extension?
11:08:45 <BMeph> Is there a fusion rule for maps and concatMaps?
11:08:48 <Feuerbach> Why in this code hGetContents is blocked even after the child exited? http://hpaste.org/10707
11:08:57 * inimino scrolls up
11:15:07 <inimino> wow, cool feature
11:17:22 <Deewiant> EvilTerran: that almost looks good, except for everything up to the list comprehension :-P
11:17:49 <EvilTerran> the important bit, then :P
11:17:54 <Deewiant> ?ty \x y -> concat.concat . zipWith (zipWith zip) x $ y
11:17:56 <lambdabot> forall a b. [[[a]]] -> [[[b]]] -> [(a, b)]
11:18:12 <Deewiant> see, that type signature's not at all obvious to me ;-)
11:18:23 <EvilTerran> ?type zipWith (zipWith zip)
11:18:24 <lambdabot> forall a b. [[[a]]] -> [[[b]]] -> [[[(a, b)]]]
11:18:32 <EvilTerran> ?type concat.concat
11:18:34 <lambdabot> forall a. [[[a]]] -> [a]
11:18:36 <EvilTerran> easy :)
11:18:39 <Deewiant> :-)
11:19:55 <Deewiant> > concat . zipWith zip [[(x,y) | x <- [0..]] | y <- [0..]] $ ["foo","bar"]
11:19:56 <lambdabot>   [((0,0),'f'),((1,0),'o'),((2,0),'o'),((0,1),'b'),((1,1),'a'),((2,1),'r')]
11:20:39 <dons> http://www.reddit.com/r/programming/comments/73r99/live_from_cufp_using_haskell_in_biotechnology/
11:20:41 <lambdabot> Title: Live from CUFP: Using Haskell in Biotechnology : programming, http://tinyurl.com/42sn97
11:20:42 <dons> there you go guys,
11:20:50 <dons> incase you didn't know the commercial FP users workshop is on today.
11:20:54 <dons> lots of great haskell talks
11:23:48 <pfo> still no papers from cufp?
11:24:28 <dons> pfo: videos.
11:24:35 <dons> commercial users don't have time to write papers.
11:24:36 <pfo> dons: where?!
11:24:44 <dons> they'll be online in the next few days.
11:24:48 <dons> last years one are online
11:24:50 <pfo> woot
11:24:51 <pfo> thx!
11:25:22 <Spark> icfp contest results out yet?
11:25:35 <Spark> ah yes
11:26:15 <Heffalump> does hackage have an RSS feed?
11:26:26 <pfo> Spark: only perliminary stuff
11:26:37 <dons> Heffalump: yeah
11:26:44 <dons> there's a link on hackage.haskell.org
11:27:17 <Heffalump> oh. So there is.
11:27:21 <Spark> i'd like to see a breakdown of progrmaming languages and score
11:27:27 <Heffalump> I looked for it before asking stupid questions, honest :-)
11:28:50 <dons> :)
11:32:19 <Feuerbach> Why in this code hGetContents is blocked even after the child exited? http://hpaste.org/10707
11:35:09 <subconscious> so would a Freezable typeclass be good to have with a unifier library?
11:37:41 <Xenoblitz> Guys, I needs me a graphics library :) Care to suggest? :)
11:37:55 <Feuerbach> Xenoblitz: hopengl?
11:38:07 <Feuerbach> (bindings to OpenGL)
11:38:29 <Xenoblitz> Feuerbach: I'll give it a look, thanks :)
11:38:36 <mc__> or hsdl
11:38:53 <mc__> which is probably simpler (but much less powerfull)
11:39:08 <Xenoblitz> http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics#Libraries
11:39:10 <lambdabot> Title: Applications and libraries/Graphics - HaskellWiki, http://tinyurl.com/4hjxmb
11:39:16 <Xenoblitz> i guess these are the ones avaible
11:39:21 <Xenoblitz> *available
11:40:01 <Xenoblitz> anyone ever used HGL?
11:40:17 <jeffz> Xenoblitz: yes, if you're looking for OpenGL examples, download the GLUT package from hackage, it includes a bunch
11:40:57 <Xenoblitz> mc__: thanks :)
11:41:01 <Xenoblitz> jeffz: thanks as well
11:41:02 <subconscious> Is there any way to freeze a structure with STRefs in it simpler than using a gensym/supply monad?
11:50:45 <subconscious> ugh there is no IdentityT :/
11:51:32 <EvilTerran> MonadLib has IdT
11:54:46 <subconscious> if I have, type Unify s a = ErrorT String (ST s) a
11:55:09 <subconscious> but I want to parameterize it on some transformer t, type Unify t s a = t (ErrorT String (ST s) a)
11:55:34 <subconscious> how do you write the new runUnifier ?
11:55:55 <EvilTerran> you can't without a class constraint on t in the type of runUnifier
11:58:59 <BMeph> IdentiT? ;)
11:59:03 <Saizan_> it's type Unify t s a = t (ErrorT String (ST s)) a, btw
12:03:29 <mml> any HTTP client library recommendations?  i was going to start staring at the curl bindings.
12:08:03 <subconscious> Araneidae, if you haven't got bored of me yet, I've improved the code a bit -- I could paste if you are still want to look
12:12:54 <subconscious> If you had two functions
12:12:58 <subconscious> freezeT' :: T s -> ErrorT String (GHC.ST.ST s) (F (Variable s (T s)))
12:13:26 <subconscious> and freezeT :: (Monad m, Eq t) => F t -> m (F String)
12:13:47 <dons> mml: libdownload ?
12:13:56 <dons> mml: i'd try the download or download-curl libs first.
12:14:01 <subconscious> you can't merge them without using a transformer?
12:14:04 <dons> then either HTTP or the curl library
12:14:30 * subconscious has to write them as two separate recursive functions
12:14:31 * EvilTerran tends to use HTTP
12:15:03 <mml> dons: download looks like it makes simple things simple
12:15:40 <EvilTerran> sometimes with HTTP-Simple
12:16:10 <dons> mml: i based it on the hpricot ruby library
12:16:29 <dons> download-curl is a bit more general, it supports lazy bytestrings
12:18:37 <dcoutts> Deutsche Bank is using HAppS for an internal trading system
12:18:40 <chr1s> dons: do you read whytheluckystiff's blog?
12:18:49 <dons> no, actually. should i?
12:18:51 <dons> probably should.
12:18:53 <chr1s> yes
12:19:11 <dons> ok :)
12:19:20 <chr1s> there's redhanded, which contains lots of interesting stuff but is discontinued: http://redhanded.hobix.com/
12:19:23 <lambdabot> Title: RedHanded » sneaking Ruby through the system
12:19:44 <chr1s> and now he's doing awesome things on hackety: http://hackety.org/
12:19:45 <lambdabot> Title: hackety org
12:19:45 <subconscious> dons, so I wrote out a unification class and some examples based on that paper typed logic vars, it seems to work (I can typecheck a page of code in some mini haskell language with it) so I guess it is hackage worthy? but I'd like to get some other peoples comments and someone to upload it if it is ..
12:19:55 <chr1s> e.g. http://shoooes.net/
12:19:56 <dons> yes.
12:20:00 <lambdabot> Title: Shoes • Colorful programs for Mac OS X, Linux and Windows
12:20:00 <dons> subconscious: you should upload it :)
12:20:13 <subconscious> mrf . . I have no hackage account still
12:21:28 <newsham> I want to print the output of "reify" (TH).  how do I accomplish that?
12:22:34 <RayNbow> oh man... sigfpe is awesome... http://sigfpe.blogspot.com/2008/09/on-writing-python-one-liners.html
12:22:36 <lambdabot> Title: A Neighborhood of Infinity: On writing Python one-liners., http://tinyurl.com/4jlm43
12:22:55 <newsham> proving that even in python, lambda calculus is turing complete
12:25:30 <mml> dons: this look familiar? <interactive>: /home/mml/.cabal/lib/download-0.3/ghc-6.8.2/HSdownload-0.3.o: unknown symbol `stat64'
12:25:50 <dons> mml: try download-curl
12:26:15 <subconscious> byorgey: hey, how are you proving it ?
12:26:32 <subconscious> like it would be cool to see the finished thing I guess
12:26:39 <jethr0> good evening, haskell
12:26:47 <subconscious> hi
12:26:57 <mml> dons++ whee!
12:27:21 <dons> mml: i think the C library, libdownload, that 'download' uses isn't widely portable
12:27:27 <dons> while download-curl is
12:29:59 <newsham> anyone here good with TH?
12:30:36 <jethr0> newsham: i'd be lying if i said i was
12:30:59 <newsham> do you know how to print the output of reify?
12:33:53 <newsham> main = putStrLn $(reify ''MyData  >>= lift . show)
12:33:54 <newsham> yay
12:35:30 <[R]ayne> Hm, I can't find the .emacs file in the home directory to install haskell mode for it. O_o
12:35:40 <subconscious> it may not exist
12:35:43 <mrd> creat one
12:37:47 <jethr0> newsham: have you had a look at my tutorial? http://web.archive.org/web/20061011050035/http://www.haskell.org/hawiki/TemplateHaskellTutorial
12:37:49 <lambdabot> Title: TemplateHaskellTutorial - The Haskell Wiki, http://tinyurl.com/4avffu
12:38:13 <jethr0> it's been ages since i've used TH, but i think i used reify in the tutorial
12:42:15 <newsham> jethr0: i just came across it
12:43:03 <jethr0> it took me ages to write, only to find out afterwards that scrap-your-boilerplate solves many of the mentioned problems in a MUUCH better and cleaner fashion ;)
12:44:20 <subconscious> I think I dont' understand scrap-your-boilerplate
12:45:08 <jethr0> subconscious: not that i fare much better, but what don't you understand?
12:45:17 <Botje> subconscious: i suggest you try uniplate first
12:45:18 <subconscious> I just use functions :L
12:45:26 <Botje> uniplate is much much easier to learn, imo
12:46:00 <Botje> once you've read how uniplate works, you'll understand SYB
12:46:29 <subconscious> ok
12:47:23 <mml> lately i type 'somethingMonadic >>= return . pureFunction' a lot
12:47:50 <subconscious> I think you can use liftM instead
12:47:50 <sjanssen> mml: fmap pureFunction somethingMonadic
12:47:51 <mml> is there a function that means the same thing as 'return .'?  it's short enough, but somehow i feel like this is a pattern
12:48:07 <subconscious> :t liftM ?pureFunction ?somethingMonadic
12:48:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m, ?somethingMonadic::m a1, ?pureFunction::a1 -> r) => m r
12:48:17 <subconscious> no I got it wrong
12:48:25 <subconscious> oh wait no it _is_ right
12:48:48 <dblazakis> fmap, liftM, or <$>
12:49:05 <mml> :t <$>
12:49:07 <lambdabot> parse error on input `<$>'
12:49:11 <dblazakis> as in pureFunc <$> sthMonadic
12:49:17 <mml> :t (<$>)
12:49:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:49:47 <sjanssen> mml: (<$>) is just an alias for fmap, and liftM is equivalent to fmap except it only works on Monads
12:50:40 <sjanssen> and since liftM is an abomination, fmap is preferred
12:50:56 <mml> sjanssen: thanks.  fmap works, but where is <$> defined?
12:51:09 <subconscious> what is bad about liftM?
12:51:16 <skorpan> it only works on monads
12:51:21 <subconscious> that's fine
12:51:31 <subconscious> I use monads sometimes ..
12:51:33 <skorpan> no, that's an abomination, which is why fmap is preferred
12:51:34 <sjanssen> mml: Control.Applicative
12:51:43 <sjanssen> subconscious: all Monads should be Functors
12:52:07 <sjanssen> liftM really only exists because of an oversight in Haskell '98
12:52:24 <ddarius> sjanssen: It definitely wasn't an "oversight"
12:52:29 <mml> sjanssen++.  <$> is easy to read
12:52:50 <sjanssen> s/oversight/mistake
12:53:19 <Beelsebob> strangely, I find <$> easy to read precicely where I'm using <*> too
12:53:38 <Botje> mmm
12:53:39 <ddarius> A deliberate mistake, yes.
12:53:44 <Botje> i always use liftM if i'm working with monads
12:53:50 <Botje> fmap just doesn't feel right :]
12:54:07 <Beelsebob> Botje: I always use liftA in that situation
12:54:08 <subconscious> I like liftM because it's part of liftM liftM2 liftM3 ...
12:54:27 <ddarius> liftM2 f x y = f <$> x <*> y
12:54:34 <jethr0> aahh
12:54:34 <ddarius> liftM3 f x y z = f <$> x <*> y <*> z
12:54:35 <Beelsebob> ddarius: that too
12:54:37 <Beelsebob> that's very nice
12:54:42 <sjanssen> why would anyone ever use liftA?
12:54:45 <jethr0> let's all use `ap`
12:54:57 * Beelsebob starts using ddarius's idiom
12:54:57 <Botje> ap is dead.
12:55:04 <Botje> <*> is the new ap
12:55:06 <Beelsebob> ap is dead, long live <*>
12:55:11 <jethr0> that's what i thought
12:55:24 <subconscious> idioms!
12:55:34 <skorpan> OT: what is this "j love" that rappers sometimes randomly put in their lyrics?
12:55:41 <subconscious> ?wiki idiom brackets
12:55:42 <lambdabot> http://www.haskell.org/haskellwiki/idiom_brackets
12:57:52 <newsham> why not liftM0 ?
12:57:58 <subconscious> :t liftM2
12:57:59 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:58:00 <subconscious> :t liftM
12:58:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:58:06 <subconscious> :t return
12:58:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:58:09 <hackage> Uploaded to hackage: GraphSCC 1.0.2
12:58:09 <hackage> Uploaded to hackage: GraphSCC 1.0.1
12:58:10 <ddarius> liftM0 = return
12:58:23 <ddarius> liftA0 = pure
12:58:28 <newsham> and liftM3 f x y z = f <$> x <*> y <*> z
12:58:38 <newsham> so... why no liftM0?
12:58:54 <dibblego> liftM2 f x y = f <$> x <*> y
12:59:06 <dibblego> liftM1 f x = f <$>
12:59:09 <subconscious> so anyone want to code review? :P
12:59:18 * subconscious has a (short) page of code
12:59:21 <dibblego> liftM0 f = pure f
12:59:45 <dibblego> liftM1 f x = f <$> x -- oops
12:59:52 <newsham> liftA0 = pure; liftA1 f x = pure f <*> x; liftA2 f x y = pure f <*> x <*> y; liftA3 f x y z = pure f <*> x <*> y <*> z
12:59:55 <jethr0> @paste
12:59:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:00:42 <jethr0> so, was that type hackery issue resolved that was mentioned in "@wiki idiom brackets"?
13:00:43 <newsham> liftA0 f = pure f; liftA1 f x = pure f <*> x; liftA2 f x y = pure f <*> x <*> y; liftA3 f x y z = pure f <*> x <*> y <*> z
13:01:22 <jethr0> > (+) <$> (Just 4) <*> (Just 3)
13:01:24 <lambdabot>   Just 7
13:01:29 <jethr0> cool
13:01:41 <jethr0> not sure i like the look of the code, but it's definitely neat
13:02:19 <jethr0> > let if' a b c = if a then b else c
13:02:20 <lambdabot>   mueval: Prelude.read: no parse
13:02:30 <Beelsebob> I like that *much* better than do x <- Just 4; y <- Just 3; return x + y
13:02:33 <jethr0> @let if' a b c = if a then b else c
13:02:35 <lambdabot>  Defined.
13:02:38 <subconscious> @let bool true false True = true ; bool true false False = false
13:02:40 <lambdabot>  Defined.
13:02:43 <subconscious> jethr0: ^ this is the one I like
13:03:04 <jethr0> > if' <$> (Just True) <*> (Just 4) <*> (Just 5)
13:03:05 <lambdabot>   Just 4
13:03:20 <Beelsebob> @let ifA c t e = if' <$> c <*> t <*> e
13:03:22 <lambdabot>  Defined.
13:03:31 <subconscious> :t ifA
13:03:32 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f Bool -> f a -> f a -> f a
13:03:33 <subconscious> :t liftM2 bool
13:03:34 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1 -> m (Bool -> a1)
13:03:37 <Beelsebob> > ifA (Just True) (Just 4) (Just 5)
13:03:39 <lambdabot>   Just 4
13:03:42 <subconscious> :t liftM3 bool
13:03:43 <lambdabot>     Ambiguous occurrence `liftM3'
13:03:43 <lambdabot>     It could refer to either `L.liftM3', defined at <local>:16:0
13:03:43 <lambdabot>                           or `Control.Monad.Logic.liftM3', imported from Control.Monad.Logic
13:03:44 <subconscious> :t liftA3 bool
13:03:45 <lambdabot> forall a (f :: * -> *). (Applicative f) => f a -> f a -> f Bool -> f a
13:03:59 <jethr0> subconscious: don't you mean "bool True a _ = a; bool False _ b = b"?
13:04:02 <subconscious> :t msplit
13:04:03 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m (Maybe (a, m a))
13:04:06 <subconscious> jethr0: no I do not mean that
13:04:12 <Beelsebob> > ifA (==5) (*2) (+6) 5
13:04:14 <lambdabot>   10
13:04:17 <Beelsebob> :)
13:04:17 <subconscious> @instances MonadLogic
13:04:18 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
13:04:26 <subconscious> @instances-importing Control.Monad.MonadLogic MonadLogic
13:04:27 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
13:04:29 <jethr0> subconscious: ;)
13:04:35 <sjanssen> @type L.liftM3
13:04:36 <lambdabot> forall t1 t2 t3 t4 (t :: * -> *). (Monad t) => (t1 -> t2 -> t3 -> t4) -> t t1 -> t t2 -> t t3 -> t t4
13:04:40 <FunctorSalad> Beelsebob: yesterday lambda didn't know about ifA
13:04:41 <sjanssen> @type Control.Monad.Logic.liftM3
13:04:42 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
13:04:43 <subconscious> :t observe
13:04:44 <lambdabot> forall a. Logic a -> a
13:04:54 <Beelsebob> FunctorSalad: now it does though :)
13:04:55 <sjanssen> hmm, why wouldn't those be the same?
13:04:59 <subconscious> > observe [1,2,3]
13:05:00 <lambdabot>   Couldn't match expected type `Logic a' against inferred type `[a1]'
13:05:00 <FunctorSalad> @t ifA
13:05:00 <jethr0> Beelsebob: i have not idea why that just worked ;)
13:05:00 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:05:04 <FunctorSalad> @type ifA
13:05:05 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f Bool -> f a -> f a -> f a
13:05:07 <Beelsebob> jethr0: becaues I defined it
13:05:10 <subconscious> > observe (msum . map return [1,2,3])
13:05:11 <lambdabot>   Couldn't match expected type `a -> [m a1]'
13:05:14 <subconscious> > observe (msum . map return $ [1,2,3])
13:05:16 <lambdabot>   mueval: Prelude.read: no parse
13:05:25 <Beelsebob> [22:03] Beelsebob: @let ifA c t e = if' <$> c <*> t <*> e
13:05:26 <FunctorSalad> Beelsebob: I was thinking of the one for arrows, not applicatives
13:06:15 <FunctorSalad> and why isn't there a liftMAnything yet? ;-)
13:06:26 <idnar> liftEverything
13:06:30 <jethr0> Beelsebob: i wasn't referring to the @let, but rather why the argument "5" was used by more than one function. i'll have to have another look at that code. is it in the (->) monad?
13:06:53 <Beelsebob> jethr0: it's the (-> a) applicative
13:06:54 <jethr0> FunctorSalad: what type would that function have?
13:06:55 <pfo> what exactly are the .hi files that ghc --make generates?
13:06:59 <jethr0> k
13:07:04 <subconscious> :(
13:07:20 <Beelsebob> @src Applicative ((->) a)
13:07:21 <dibblego> it's the S combinator
13:07:21 <lambdabot> Source not found. My mind is going. I can feel it.
13:07:26 <FunctorSalad> jethr0: the usual typeclass trick, "class IsLiftM a b where liftM :: a -> b", then you define it inductively
13:07:30 <Beelsebob> @instance Applicative ((->) a)
13:07:31 <lambdabot> Maybe you meant: instances instances-importing
13:07:32 <jethr0> subconscious: where are you expecting "observe" to come from
13:07:33 <Beelsebob> bah
13:07:44 <dibblego> (t -> a -> b) -> (t -> a) -> t -> b
13:07:54 <subconscious> jethr0: what do you mean?
13:08:05 <Beelsebob> @src ((->) a) <$>
13:08:05 <FunctorSalad> instance IsLiftM (a -> b) (m a -> mb) where ... and so on
13:08:06 <lambdabot> Source not found. I am sorry.
13:08:10 <pfo> .hi files are what?
13:08:13 <Beelsebob> @src ((->) a) (<$>)
13:08:14 <lambdabot> Source not found. Sorry.
13:08:25 <FunctorSalad> I haven't thought about whether there will be ambiguities though
13:08:38 <jethr0> i thought you were displeased with your "observe [1,2,3]" not working
13:10:25 <FunctorSalad> instance (Monad m, isLiftM m x y) => isLiftM m (a -> x) (m a -> y)       -- forgot the m parameter in isLiftM at first
13:11:08 <FunctorSalad> also it needs to be capitalized
13:11:26 <subconscious> I've seen  |>f<|^3  in papers to denote liftM3 f
13:13:19 <Cale> subconscious: Really? Whose paper?
13:14:02 <subconscious> this one http://strictlypositive.org/unify.ps.gz
13:14:30 <subconscious> It's a really cool proof actually :)
13:23:45 <prongla> can i hoogle from ghci in emacs?
13:24:57 <pfo> I'm trying some SOE examples - but on the first one i get this error: http://hpaste.org/10710
13:25:24 <subconscious> pfo: I think it's just an indentation problem
13:25:37 <subconscious> pfo: You seem to have typed tabs instead of spaces
13:25:54 <subconscious> instead of
13:25:55 <subconscious>            = do k <- getKey w
13:25:55 <subconscious>                     if k == ' '
13:25:57 <subconscious> it should be like
13:26:07 <subconscious> = do k <- getKey w
13:26:08 <subconscious>      if k == ' '
13:26:19 <subconscious> hm infact they are spaces but too many of them
13:26:58 <subconscious> (and you may also have to indent the 'then' and 'else' parts slightly?)
13:27:13 <RayNbow> @faq Can Haskell comfort me for having lost the gaming skills required to beat Megaman 9?
13:27:14 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:47 * RayNbow feels better now... :)
13:28:23 <prongla> anyone tried fsharp? opinions?
13:28:37 <jethr0> @faq does lambdabot answer any question posed to it in the affirmative?
13:28:37 <lambdabot> The answer is: Yes! Haskell can do that.
13:30:44 <pfo> subconscious: thx!
13:31:12 <Botje> @faw can haskell comfort me when i watch a scary movie?
13:31:13 <lambdabot> The answer is: Yes! Haskell can do that.
13:31:57 <_zenon_> Botje, are you watching a scary movie right now?
13:32:05 <Botje> just started silent hill
13:32:18 <tusho> Botje: you said scary movie
13:32:20 <tusho> :|
13:32:45 <Botje> any suggestions?
13:33:19 <_zenon_> :D
13:34:59 <jethr0> Botje: just stop after the first 30 minutes. it's scarier that way...
13:35:27 <Botje> i rather like the parts with all the barbed wire :]
13:35:33 <Botje> and the pyramid man is cool too
13:35:44 <_zenon_> Botje, This is scary: http://www.youtube.com/watch?v=wvsboPUjrGc
13:35:45 <lambdabot> Title: YouTube - Steve Ballmer going crazy
13:35:54 <jethr0> Botje: suggestions for what? scary movies?
13:36:32 <tusho> hmm
13:36:38 <tusho> lambdabot is the Final Solution to rickrolls
13:36:38 <tusho> :|
13:36:53 <tusho> http://www.youtube.com/watch?v=eBGIQ7ZuuiU
13:36:54 <lambdabot> Title: YouTube - Rick Roll
13:37:38 <jethr0> in a way "event horizon" is quite scary
13:37:42 <subconscious> ugh can we go to #haskell-blah for a bit?
13:38:13 <jethr0> @quote off-topic
13:38:16 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
13:38:28 <jethr0> @quote off-topic
13:38:30 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
13:38:34 <jethr0> grr
13:38:39 <_zenon_> ;)
13:40:18 <inimino> the good news is that my n^2 algorithm ran in only 8 minutes, the bad news is that was only over 1/34 of the data
13:41:04 <roconnor> > 8*34^2/60/24
13:41:06 <lambdabot>   6.422222222222222
13:41:15 <inimino> yeah
13:41:21 <roconnor> inimino: only 1 week to do it all
13:41:28 <inimino> yeah
13:41:48 <SamB_XP> so ...
13:41:50 <roconnor> you can start it running and you have a week to improve your algorithm
13:42:02 <SamB_XP> oh, I see
13:42:04 <inimino> that's true ;-)
13:42:20 <SamB_XP> that's the amount of time it would take ... not the time it needs to happen in ..
13:42:34 * SamB_XP was about to do roughly the same calculation ;-)
13:42:50 <inimino> hehe
13:43:18 <roconnor> inimino: better than the time I wrote an algorithm to sum a list of 2^308 elements
13:43:24 <roconnor> stupid exponential algorithms
13:43:32 <inimino> hehe
13:43:34 <Botje> 2^308? O_o
13:43:48 <roconnor> 308 seemed so small
13:43:53 <jethr0> roconnor: wouldn't that take kinda long, even with a mighty language as haskell?
13:43:53 <inimino> haha
13:44:20 <roconnor> jethr0: I stopped it after a running for a few minutes
13:47:31 <jethr0> i was looking for the ascii string "hello world" in PI, but soon figured out that i'd have to search quite a few places to ever find it
13:48:38 <lament> jethr0: fortunately there's a website to do that for you
13:49:00 <lament> http://www.angio.net/pi/piquery
13:49:05 <lambdabot> Title: The Pi-Search Page
13:49:20 <jethr0> i used the website, but it only has 400 million places. there is a university site that let's you download 4 billion places, but even that much is probably not enough for "hello world"
13:49:52 <inimino> run the Bible Code algorithm over it ;-)
13:49:56 <_zenon_> jethr0, do I dare wonder why?
13:50:03 <lament> of course this site only allows you to search base 10
13:50:05 <vinicius_> The string 1337 occurs at position 4,813 counting from the first digit after the decimal point.
13:50:23 <_zenon_> inimino, the bible code algorithm will find "Leet haxxor" on your cereal packages :P
13:50:51 <jethr0> _zenon_: the pi search site show the probability of finding a string of length 10 as very low even with many million places to search.
13:51:43 <_zenon_> jethr0, okay, I thought you had some kind of weird PI-fetish.
13:51:54 <_zenon_> but then, who hasnt? ;)
13:51:58 <vinicius_> > (1.0/10.0)**10
13:51:59 <lambdabot>   1.0000000000000006e-10
13:52:31 <jethr0> _zenon_: not really. i just found the idea of encoding any string as a start location in pi interesting. but seeing how low the probabilities are, i won't be hiding my next novel in Pi anytime soon
13:52:52 <inimino> interesting idea
13:53:04 <Cale> jethr0: Yeah, it's a terrible compression algorithm ;)
13:53:08 <jethr0> vinicius_: that's not taking into account how many digits you're looking in
13:53:39 <vinicius_> jethr0: of course not, I don't have the math/stats machinery to do it =p
13:53:50 <jethr0> i first got onto these kinds of ideas with the CSS encoding competitions. really cool in what media it is possible to convey information / data / programs
13:53:53 <Cale> It's not even clear that every sequence of digits occurs.
13:54:05 <inimino> isn't it?
13:54:07 <jethr0> Cale: yes, that's another problem
13:54:18 <vinicius_> yeah, my calc assumes random distribution
13:54:42 <vinicius_> which is way off, since pi has a low kolgomorv complexity
13:54:47 <Cale> In fact, we know so little about the structure of the decimal expansion of pi that at some point it could become nothing but some arrangement of 3's and 7's.
13:54:56 <lament> nobody seriously suggests that it would be non-random, we just can't prove anything
13:55:06 <inimino> true
13:55:12 <Cale> In fact, I think it would be really cool if it did ;)
13:55:15 <inimino> heh
13:55:23 <jethr0> lament: don't go there. randomness is a tricky thing to reason about ;)
13:55:33 <lament> Cale: yes, nine nine nine nine nine nine and so on
13:55:36 <inimino> that would definitely be cool
13:55:38 <jethr0> nah, my bet is on it going 000000000000
13:55:49 <inimino> but it seems highly improbable ;)
13:55:55 <lament> jethr0: that part was disproved a while back :)
13:55:56 <Cale> Of course, it can't end in an infinite string of any one digit.
13:56:14 <jethr0> i'd say it just stops at some point, but that would go against my admittedly spotty math education
13:56:20 <Cale> (because that would make it rational)
13:56:35 <Cale> Moreover, it can't end in any repeating string.
13:57:16 <jethr0> true, so even if it ends in an arrangement of 3's and 7's that would still need to have no structure and then you should be able to encode anything into those 3's and 7's, i guess
13:57:31 <inimino> doesn't that prove that it contains every possible sequence?
13:57:32 <Cale> It still would have some structure. Just not periodic structure.
13:57:46 <subconscious> inimino: No I don't think so
13:57:49 <lament> inimino: no
13:57:52 <vinicius_> no
13:57:54 <jethr0> but as i said, my math is sorely lacking and this is a few orders of magnitude beyond my number theory inklings
13:57:59 <inimino> hm
13:58:01 <Cale> In fact, it could end in a unary encoding of the primes, like 37737773777773....
13:58:26 <Cale> (well, probably could rule that specific one out somehow :)
13:58:32 <inimino> that's true
13:59:08 <vinicius_> anyway
13:59:18 <inimino> yes, I suppose on further thought there are infinitely many infinitely long sequences that don't contain any given sequence
13:59:23 <vinicius_> encoding anything as a pi sequence could make the number large
13:59:50 <vinicius_> I mean, too large.
14:00:04 <lament> pi is just a theory, anyway.
14:00:19 <inimino> a theory?
14:00:26 * sw17ch wonders if there's a practicle application for knowing Pi past a given specific precision
14:00:33 <vinicius_> in logic programming it probably is :)
14:00:39 <dmhouse> Depends on the precision.
14:00:40 <pastorn_> is there some datatype _ = N | S | E | W predefined in GHC somewhere?
14:00:52 <pastorn_> (so that i might avoid defining it mysef...
14:01:01 <inimino> pastorn_: I don't think so
14:01:04 <lament> pastorn_: unlikely.
14:01:19 <ddarius> Maybe Ordering
14:01:23 <lament> pastorn_: what about U | D | SW | SSW ?
14:01:31 * sw17ch wanders home...
14:01:36 <pastorn_> lament: huh?
14:01:36 <ddarius> Either Bool Bool
14:01:48 <inimino> peace symbol?
14:01:56 <inimino> no, nevermind
14:02:09 <dmhouse> Hmm, Maybe is like type-level succ. That's quite nice.
14:02:14 <pastorn_> nah... i just wanted to avoid implementing turn operation
14:03:57 <ddarius> pastorn: turnRight direction = toEnum ((1 + fromEnum direction) `mod` 4)
14:04:36 <BMeph> dmhouse: Except Maybe (Maybe a) doesn't quite do what you'd like... ;)
14:04:56 <inimino> well, not with N | S | E | W ...
14:05:12 <inimino> but N | E | S | W
14:05:23 <roconnor> > 64-28
14:05:25 <lambdabot>   36
14:05:26 <dmhouse> BMeph: why not? Maybe (Maybe ()) has elements Just (Just ()), Just Nothing and Nothing, as expected.
14:05:27 <pastorn_> turnR, turnL :: Direction -> Direction
14:05:27 <pastorn_> turnL = turnR . turnR . turnR
14:05:38 <subconscious> Mu Maybe = Nat
14:05:43 * pastorn_ is lazy as you wouldn't believe
14:05:45 <inimino> heh
14:06:03 <inimino> eh, the compiler's smart
14:06:38 <Cale> It's interesting that almost all real numbers (in the sense of measure) have the property that the average frequency of every digit in base b tends to 1/b, but it's very hard to show that even one particular number actually has this property. :)
14:07:38 <inimino> one particular number?
14:07:51 <inimino> why would that be harder than just counting them?
14:07:59 <lucca> ...what does "almost all" of an infinite set mean?
14:08:20 <dmhouse> The remainder have measure zero, in this case.
14:08:36 <ddarius> An unusual location but http://www.dspguide.com/ch34.htm
14:08:41 <lambdabot> Title: Explaining Benford's Law
14:08:45 <Cale> That is, to construct an example of a number such that for every base b, the average frequency of the occurrences of each digit tends to 1/b.
14:08:54 <dmhouse> Measure is a precise formulation which is approximated by the intuitive notion of "area" (in 2 dimensions).
14:08:59 <inimino> ah
14:09:04 <dmhouse> http://en.wikipedia.org/wiki/Measure_theory
14:09:06 <lambdabot> Title: Measure (mathematics) - Wikipedia, the free encyclopedia
14:09:42 <dblazakis> could come up with a way to count those that don't have the 1/b distribution of digits... err to prove they are countably infinite
14:09:42 <ddarius> Measure theory == probability theory with probabilities that are allow to be outside of [0..1]
14:09:46 <Cale> (and specifically, the measure in question here is the Lebesgue measure on R)
14:10:52 <dblazakis> ack, nevermind i suppose they aren't countable
14:10:57 <lucca> weeeird
14:13:21 <Cale> lucca: Basically, it means that the set of points which don't have the property can be covered by a countable collection of intervals where the sum of their lengths is arbitrarily small.
14:13:58 * BMeph thinks that "a precise formulation which is approximated" may not be aas precise as advertized... ;p
14:14:13 <Cale> BMeph: hm?
14:14:31 <inimino> it is precise, it's the intuitive idea that is vague ;-)
14:14:54 <pastorn_> @hoogle Enum
14:14:54 <lambdabot> Prelude class Enum a
14:14:55 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
14:14:55 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
14:15:26 <BMeph> inimino: Ah, the old "I'm not evil, I'm misunderstood" defense? ;)
14:15:42 <inimino> heh
14:18:19 <BMeph> ddarius: Thanks - maybe that book can help me with one (of many) side project of mine.
14:20:13 <Cale> Btw, for anyone interested in picking up measure theory: http://www.indiana.edu/~mathwz/PRbook.pdf
14:20:15 <lambdabot> Title: Modern Real Analysis William P. Ziemer
14:20:23 * quicksilver notes in passing that using fromEnum/toEnum to implement pastorn's turn violates the fourth wall.
14:20:37 <quicksilver> (well actually, it's deriving Enum that does that)
14:20:47 * _zenon_ should go to bed now
14:21:06 <inimino> lambdabot picks up titles from PDFs, huh, cool
14:21:57 <inimino> quicksilver: which fourth wall is that?
14:22:23 <olsner> the one between reality and fiction?
14:22:45 <quicksilver> well, yes, the metaphor comes from the stage
14:22:51 * BMeph has a cousin that went to IU...some 15+years ago. :)
14:22:54 <inimino> that's what I thought...
14:23:00 <quicksilver> but the point is that GHC's lightweight metaprogramming (derivign Show, Enum and so on)
14:23:02 <inimino> then I don't see the connection...
14:23:12 <quicksilver> violate common laws of program transformation
14:23:21 <quicksilver> programs aren't supposed to be able to see the names of their own variables
14:23:31 <quicksilver> (alpha conversion says you can rename them)
14:23:40 <inimino> oh
14:23:44 <quicksilver> similarly, names of constructors, order of constructors in a data declaration.
14:23:58 <quicksilver> all these things are conceptually safe to change/renumber/rename
14:24:07 <quicksilver> but if you use deriving Enum/Show, they aren't any more :)
14:24:20 <quicksilver> it's a bit like the fourth wall.
14:24:38 <quicksilver> variables just "are", they don't know they have names
14:24:38 <quicksilver> like characters in a play don't know they are actually actors.
14:24:39 <inimino> well, if you look at Enums as names of subsequent small integers, then it's not a problem anymore
14:25:02 <inimino> yeah, interesting analogy
14:25:07 <quicksilver> sure, but that's not the haskell view
14:25:29 <quicksilver> naively we want to think data A | B and data B | A are equivalent.
14:25:46 <quicksilver> (it's not like C,C++ enum which really is defined in terms of numbers)
14:25:49 <inimino> it's not the lambda calculus view
14:26:19 <inimino> but yeah, anybody that sees "deriving Enum" is going to think of C
14:27:22 <inimino> unless they don't, of course
14:31:07 <Cale> quicksilver: The order in which the terms of the type are listed in the data declaration is also used for Ord instances.
14:31:26 <Cale> (the derived ones)
14:32:24 <subconscious> say you have some term like
14:32:36 <subconscious> Foo (Bar X Y (Bar X))
14:32:47 <subconscious> and a function that can substitute :: Term -> Term -> Term
14:33:05 <subconscious> the you can partial apply (substitute <term> X) to have \z -> Foo (Bar z Y (Bar z))
14:33:32 <subconscious> are there any other ways to get that (\z -> ...)?
14:33:57 <Cale> (`substitute` X)?
14:34:10 <subconscious> I mean other than a substitution function
14:34:11 <Cale> But I think your type signature for substitute can't be right...
14:34:17 <opqdonut_> order of the arguments is perverse anyway
14:34:25 <subconscious> oh yeah thanks
14:34:29 <subconscious> substitute :: Term -> Term -> Term -> Term
14:34:41 <dibblego> is there a flip fmap somewhere?
14:34:41 <quicksilver> Cale: yes, that's right
14:34:54 <quicksilver> Cale: most of the deriving stuff violates this one way or another.
14:35:01 <quicksilver> Cale: after all it's metaprogramming.
14:35:19 <opqdonut_> subconscious: i'm not quite sure what you're after, but i'd say the only way is substitution
14:35:23 <subconscious> so I actually start with,  \z -> Foo (Bar z Y (Bar z))
14:35:24 <quicksilver> I'm not particularly claiming it's a problem.
14:35:34 <Cale> quicksilver: Right. It's too bad that we don't have a more general way to define ways to derive classes from the structure of a type.
14:35:39 <quicksilver> but it's somsething to be aware of, if you're thinking about equational reasons and automatic refactorings.
14:35:40 <subconscious> and I have to shove in some 'X' (that X comes from a supply/gensym monad)
14:35:40 <jethr0> dibblego: mapM?
14:35:51 <jethr0> sorry, forM
14:35:51 <subconscious> then I do some monadic operation on the inside of the lambda, and abstract it out again
14:36:11 <subconscious> what I'd really like is to do all that without a gensym
14:36:29 <dibblego> forM is not flip fmap
14:36:34 <subconscious> ..except I haven't figured out a way, so has anyone seen this or any ideas?
14:36:37 <inimino> what's a gensym?
14:36:46 <inimino> symbol generator?
14:36:53 <subconscious> inimino: I should get a totally unique symbol each time
14:37:07 <Heffalump> so each z should be different?
14:37:08 <subconscious> so basically a state monad with ["a","b",..] in it
14:37:18 <subconscious> no each z should be the same objcet
14:37:18 <inimino> ok, cool
14:37:39 <subconscious> it's just that I have to gensym some 'X' apply it, operate on the inside of the lambda, and the abstract that 'X' out again
14:37:42 <sjanssen> subconscious: what is wrong with using a substitution function?  Seems like the right solution
14:37:51 <subconscious> sjanssen: yes it does work
14:37:55 <Heffalump> subconscious: sorry, I don't understand what you mean
14:37:58 <opqdonut_> me neither
14:38:33 <subconscious> actually,
14:38:53 <opqdonut_> whats wrong with "fmap (\z -> Foo (Bar z Y (Bar z)))"
14:38:56 <subconscious> in this code, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=26#a42
14:39:11 <subconscious> um not that one, oops
14:39:24 <jethr0> dibblego: i am aware of that, hence the question mark. i was wondering if forM would be usefull to you, anyways
14:39:38 <dibblego> jethr0, ah right thanks, but no :)
14:39:43 <subconscious> in something like:  foo (Lambda m) = \x -> foo (m x)
14:39:49 <subconscious> since foo is pure that method works fine
14:39:50 <jethr0> :t flip fmap
14:39:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
14:39:56 <jethr0> :t forM
14:39:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:39:59 <subconscious> but if foo was monadic, how do you do this?
14:40:34 <subconscious> like fooM (Lambda m) = do g' <- gensym ; m' <- fooM (m g') ; return (substitute m' g')
14:40:41 <subconscious> that's the sort of thing I was describing earlier
14:40:48 <subconscious> (as a monadic version, which is pretty hairy)
14:41:02 <opqdonut_> what's wrong with that version?
14:41:25 <subconscious> opqdonut_: Specifically, It would be great if this could be done without using gensym
14:41:39 <opqdonut_> errr you mean generically?
14:42:04 <Heffalump> have you looked at Applicative?
14:42:05 <subconscious> I'm sure anything that works in this case would work for every case
14:42:50 <pjdelport> wooh, Applicative
14:45:13 <subconscious> would I write an Applicative instance for Term?
14:46:44 <subconscious> I need a way to sort of run monadic actions out from under a lambda
14:47:03 <subconscious> which is impossible? :)
14:47:31 <binrapt> What does Lisp have over Haskell? What advantages does Haskell have over Lisp?
14:47:45 <dons> ?faq
14:47:45 <lambdabot> The answer is: Yes! Haskell can do that.
14:48:15 <SubStack> haskellicious
14:48:59 <sm> lisp has macros and a conceptually simple non-lazy execution model and lack of types
14:49:59 <sm> haskell has laziness, purity, conciseness and a well-organized, effective community
14:50:05 <subconscious> did what I ask actually make any sense? :S
14:50:16 <jethr0> haskell has a powerful type system
14:50:48 <sm> damn, forgot that
14:50:55 <opqdonut_> subconscious: no, not really
14:51:01 <qwr> sm: lisp has types. at runtime.
14:51:21 <sm> I know. Trying to answer briefly
14:51:36 <jethr0> some lisps do for optimization reasons. is that a requirement to be a lisp?
14:53:09 <Peaker> How about: Haskell has a complex system to detect type mismatches at compile time, and Lisp doesn't?
14:53:16 * qwr thinks lisp is some combination of sexp, dynamic types, function values and macros
14:53:24 <jethr0> lisp systems tend to be very good at allowing code changes during runtime, leading to a very fluid development process, but lacking in static type safety compared to haskell
14:53:28 <dmead> lisp is a really simple language
14:53:50 <dmead> and who would set the requirements to "be a lisp"?
14:53:52 <opqdonut_> dmead: you can't really be saying that
14:54:03 <dmead> the syntax is very simple
14:54:05 <dmead> is what i mean
14:54:05 <ddarius> dmead: CL is certainly not simplye.
14:54:06 <Cale> I would tend to be glib about it and say that Haskell is typed, while (common) lisp is untyped, but perhaps I have a different version of what it means to be typed than many people.
14:54:16 <opqdonut_> yeah CL is extremely baroque
14:54:22 <opqdonut_> even scheme isn't that simple
14:54:22 <kyagrd> Hello
14:54:24 <jethr0> john mccarthy
14:54:31 <Cale> kyagrd: Hello!
14:54:46 <dmead> Cale, my proff used to say that "it's essential untyped"
14:54:51 <dmead> *essentially
14:54:55 <kyagrd> I'm now in CUFP and while I am sitting down I was trying out Yi
14:54:56 <opqdonut_> err, that "that" isn't really referring to the previous sentence
14:54:56 <Cale> yeah.
14:55:11 <dmead> CUFP?
14:55:12 <kyagrd> But it still doesn't work for me.
14:55:20 <subconscious> opqdonut_: well consider:
14:55:23 <dmead> haskellers
14:55:24 <subconscious> data T = App T T | Lam (T -> T)
14:55:24 <subconscious> foo (App m n) = App (foo m) (foo n)
14:55:24 <subconscious> foo (Lam m) = \x -> foo (m x)
14:55:27 <jethr0> like many things, lisp and scheme are extremely simple at their core. the devil lies in the detail (like with gensyms, sane macros, byte code compiling, optimization, ...)
14:55:29 <dmead> watch the debates tonight
14:55:33 <kyagrd> CUFP = comercial users of functional programing
14:55:34 <dmead> if you can vote in the electiojns
14:55:36 <dmead> ah
14:55:56 <subconscious> opqdonut_: What I want to do is write a fooM that's something like T -> m T
14:56:06 <kyagrd> Has anyone succeeded installing yi using cabal in linux (especially in debian)?
14:56:20 <dmead> whats yi?
14:56:24 <dmead> the text editor right?
14:56:27 * Cale will try
14:56:32 <jethr0> subconscious: i'm sorry i missed the first part of your discussion. but could you quickly recap what it is you're trying to do?
14:56:36 <opqdonut_> subconscious: fooM (App m n) = liftM2 App (foo m) (foo n)
14:56:39 <Cale> I'm pretty sure that I've gotten it to work that way in the past.
14:56:46 <kyagrd> Editor written in Haskell it was demonstrated in Haskell workshop
14:56:50 <Cale> I'll cabal update and try installing it.
14:57:00 <opqdonut_> err, those foo's should be fooM's
14:57:00 <dmead> ah
14:57:02 <subconscious> jethr0: everything should be in the logs
14:57:04 <kyagrd> I did it from scratch several times and updated as well
14:57:09 <jethr0> hehe
14:57:16 <Cale> kyagrd: How far does it get?
14:57:33 <subconscious> opqdonut_: yeah that works for the App case
14:57:35 <kyagrd> It compiles and installs all OK, the problem is
14:57:47 <dons> kyagrd: a bunch of people.
14:57:58 <dons> but i know the gtk frontend doesn't work on 64 bit (gtk bug)
14:58:01 <opqdonut_> and fooM (Lam m) = fooM . m = \x -> fooM (m x)
14:58:03 <dons> so you'll need the vty frontend.
14:58:06 <opqdonut_> what's the problem?
14:58:07 <kyagrd> As soon as it gets started it stucks with the error message Custom yi ("/home/kyagrd/.yi/yi-i386-linux") could not be launched!
14:58:19 <kyagrd> It is a vtk frontend
14:58:25 <subconscious> opqdonut_: that doesn't work though
14:58:30 <jethr0> subconscious: you should really have a look at the scrap your boilerplate stuff. that seems to me to solve many of your problems (which i'm too lazy to look up in more detail in the logs ;)
14:58:30 <kyagrd> frontend itself runs but it just gets stuck and only q (exit) works :(
14:58:37 <opqdonut_> subconscious: oh?
14:58:42 <subconscious> jethr0: no it doesn't relate to this
14:59:16 <bd_> you need to be careful with SYB though - using it incorrectly can lead to a lot of excess allocation (at least it did when I overused it)
14:59:21 <kyagrd> yi-i386-linux does not exist in my system but Yi just trys to launch it
14:59:48 <subconscious> so basically I am trying to find a way to write this in haskell such that it types and stuff
14:59:53 <kyagrd> I also tried the dev version from darcs still the same problem
15:00:27 <opqdonut_> subconscious: also, there's the problem that the original foo doesn't seem to type
15:00:36 <subconscious> it should be foo (Lam m) = Lam (\x -> foo (m x))
15:00:43 <opqdonut_> yeah :)
15:00:53 <bos> http://www.reddit.com/r/programming/comments/73smc/some_notes_on_the_future_of_haskell_and_fp/
15:00:54 <lambdabot> Title: Some notes on the future of Haskell and FP : programming, http://tinyurl.com/4fo7wn
15:01:57 <opqdonut_> subconscious: ah, now i guess i see the problem
15:02:10 <dons> future of haskell, read and vote up :)
15:03:14 <opqdonut_> subconscious: fooM (Lam m) = fmap Lam (fooM . m) ?
15:03:27 <subconscious> opqdonut_: does that work?
15:03:37 <opqdonut_> subconscious: checking it
15:03:53 <BMeph> Is that legit, Reddit'ing your own blog entry? I'm suspicious... ;p
15:04:05 <jethr0> subconscious: sorry, i'd love to help, but looking at the logs didn't really tell me in what context you're trying to accomplish what. maybe some of the other guys understand what you're really trying to do
15:04:11 <jethr0> example code would always help
15:07:31 <opqdonut_> subconscious: no, yeah, it can't work
15:07:41 <opqdonut_> since the transformation inside Lam has to bue pure
15:07:44 <opqdonut_> *be pure
15:07:59 <opqdonut_> or hmm
15:08:09 <subconscious> I wonder if there isn't some continuation passing way to write it
15:08:43 <bos> BMeph: no, it's pretty normal.
15:09:54 <ddarius> Isn't that encouraged?
15:10:36 <Cale> bos: By the way, I just had one small criticism regarding your other talk (at least I think it was yours...). I feel that we should generally try to avoid telling people that typeclasses are ad-hoc polymorphism. (Because there are really significant differences, even though they can be used to simulate it.) I suppose for some audiences though, that might be the quickest way to get the idea across.
15:10:50 <opqdonut_> hmm
15:11:09 <opqdonut_> if I remember my theory right, there's no way to go from T -> m T to m (T->T)
15:11:13 <opqdonut_> which is what this would need
15:11:23 <bos> Cale: yeah
15:12:04 <Cale> I didn't actually hear that talk though, I just saw some slides :)
15:12:13 <Heffalump> how do they differ from ad-hoc polymorphism (with pre-declared overloadable things)
15:12:16 <Heffalump> ?
15:13:10 <Cale> Heffalump: use of typeclass-polymorphic things can result in further typeclass-polymorphic things.
15:13:29 <opqdonut_> subconscious: the obvious solution of course is to parametrise T over a (possibly applicative) functor f
15:13:30 <Cale> Heffalump: That is, you don't have to pick an instantiation as soon as you use something.
15:13:49 <subconscious> opqdonut_: That's not obvious to me, how does that look?
15:14:30 <opqdonut_> data T f = App T T |Lam (T -> f T) -- one way
15:14:40 <ddarius> Heffalump: They have more structure.
15:14:40 <subconscious> and what happens with it?
15:14:59 <opqdonut_> well then writing fooM becomes trivial :)
15:15:07 <subconscious> how?
15:17:00 <opqdonut_> fooM (Lam m) = Lam (m >=> fooM) -- for fooM :: Monad m => T m -> T m
15:17:17 <Peaker> Cale: if types didn't have contexts (except for class methods themselves), would that mean that typeclasses only provide ad-hoc polymorphism?
15:17:37 <opqdonut_> but sorry, gtg now
15:17:40 <Cale> Peaker: Well, they would still have a bit more refined structure, but it would be closer.
15:18:15 <dolio> @type Data.Traversable.sequence :: Monad m => (a -> m b) -> m (a -> b)
15:18:16 <lambdabot>     Could not deduce (Data.Traversable.Traversable ((->) a))
15:18:17 <lambdabot>       from the context (Monad m)
15:18:17 <lambdabot>       arising from a use of `Data.Traversable.sequence'
15:18:26 <Cale> Peaker: If you had to pick a monomorphic instantiation wherever you applied a class member, then I would say it would be fine to call it ad-hoc polymorphism.
15:20:07 <Peaker> Cale: I'm not sure what that means - class member is a method?
15:20:14 <Cale> er, yes
15:20:20 <Cale> class method, sorry
15:20:33 <Peaker> well, you'd have to, because otherwise your function would need to include the class as a context?
15:20:37 <Cale> right
15:21:00 <Peaker> so without contexts, you have to pick monomorphic instantiations, no?
15:21:15 <Cale> I think you would yes,
15:21:21 <Cale> we're saying the same thing :)
15:21:33 <Cale> You'd still have something over traditional systems of ad-hoc polymorphism though, since the class provides a structure for instances to fill in.
15:21:38 <subconscious> opqdonut_: hm that has not got a valid kind
15:21:39 <Peaker> yeah, I thought you said there was a difference and that I was misunderstanding something ;)
15:22:00 <Cale> So you'd still know something about the type of a class method, wherever it occurred, without having to look at the instances or the surrounding context.
15:22:45 <Cale> Usually systems for ad-hoc polymorphism allow you to overload things at any type at all.
15:23:22 <Peaker> example?
15:23:40 <Cale> Say you have...
15:23:46 <Cale> class Ord t where
15:23:50 <Cale>   (<) :: t -> t -> Bool
15:24:21 <Cale> Then you know wherever (<) occurs that its parameters have the same type, and that it's producing a Bool, and that it's actually a function ;)
15:24:33 <tristes_tigres> Hello
15:24:43 <Peaker> Cale: how is it possible to have a system where you don't know those things?
15:25:05 <Cale> Peaker: You could have a system which just allowed you to define (<) many times at any type you wanted.
15:25:05 <Peaker> s/how/why :)
15:25:05 * subconscious gives up
15:25:34 <Cale> Peaker: and then differentiate between the definitions by making the type explicit in whatever way necessary.
15:25:51 <Cale> (at the location where you're calling it)
15:26:16 <Cale> Rather like:
15:26:20 <Cale> class Ord t where
15:26:20 <Peaker> but the args to (<) would still be of the same type?
15:26:22 <Cale>   (<) :: a
15:26:24 <Cale>   (<) :: t
15:26:26 <Cale> rather ;)
15:26:48 <subconscious> why is there no explanation about what == does in there http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/Data-STRef.html ?
15:26:50 <lambdabot> Title: Data.STRef, http://tinyurl.com/4azvmk
15:27:06 <Cale> subconscious: Because it's obvious?
15:27:11 <Peaker> so when using (<) you specify that it is a function of 2 args of same type, and only then the instance that has that type is used?
15:27:14 <Cale> subconscious: There's only one thing that it could possibly do.
15:27:17 <subconscious> It's not obvious to me
15:27:28 <Cale> subconscious: It tests if two STRefs are the same STRef.
15:28:10 <Cale> subconscious: It can't possibly check if they have the same value, because the result of (==) is not in the ST monad.
15:28:43 <Cale> Peaker: yeah.
15:28:58 <Cale> Peaker: So classes let you enforce something about the structure of the various overloadings.
15:29:27 <Cale> Peaker: Even when you don't use the fact that they let callers 'inherit polymorphism'.
15:30:22 <Peaker> Then ad-hoc polymorphism sounds kind of like adding types into the name, so we can re-use cool names
15:30:51 <Peaker> (Re-use (<) for other purposes, if they have type signatures other than a->a->Bool)
15:31:03 <Cale> Peaker: yes, it's very much like that
15:31:15 <Cale> Peaker: and so it's not nearly as powerful as typeclasses are.
15:31:24 <Cale> You can't do quickcheck with ad-hoc polymorphism.
15:31:55 <subconscious> > do (x@Just y) <- return 1 ; return (x,y)
15:31:56 <lambdabot>   mueval: Prelude.read: no parse
15:32:00 <subconscious> this is mad
15:32:04 <subconscious> you can't use @ in a monad
15:32:08 <subconscious> do syntaxx
15:32:20 <Peaker> One of the things most attractive about Haskell to me was the fact that names identified specific things, not different things in different "classes" (coming from an OO background)
15:36:46 <Cale> Oh, another thing which you certainly can't do with ad-hoc polymorphism, though it's a special case of what we've already talked about, is things like  instance Ord a => Ord [a] where ...
15:37:00 <Cale> Where you define infinitely many overloadings with a single definition.
15:37:33 <Peaker> Cale: that's definitely a cool property
15:38:05 <subconscious> I guess I am just really bad at haskell
15:38:17 <Cale> subconscious: What's wrong?
15:38:17 <subconscious> I think I can't program what I wanted to without unconstrained mutation
15:38:29 <Cale> What are you trying to write?
15:38:36 <subconscious> this stuff with lambda
15:39:00 <subconscious> I was writing a typechecker using the unification monad and HOAS
15:39:10 <subconscious> so I have got a data type with STRefs throughout it
15:39:20 <Peaker> > do { x@(Just y) <- (return (return 1)) ; return (x,y) }
15:39:21 <subconscious> that just doesn't work together
15:39:21 <lambdabot>       No instance for (Show (t1 (Maybe t, t)))
15:39:21 <lambdabot>        arising from a use of `...
15:39:41 <Peaker> funny, my ghci is ok with that
15:39:48 <dmwit> defaulting
15:40:03 <dmwit> Give it a specific monad to print from.
15:40:14 <Cale> > do { x@(Just y) <- (return (return 1)) ; return (x,y) } :: Maybe (Maybe Integer, Integer)
15:40:15 <lambdabot>   Just (Just 1,1)
15:40:53 <Peaker> subconscious: it appears you just need x@(spaced pat) and not (x@spaced pat)
15:41:20 <dmwit> Peaker: ghci probably defaulted to IO (Maybe Integer, Integer).
15:41:28 <Peaker> dmwit: Yeah, I just realized that too, thanks
15:41:40 <Peaker> (everything in ghci seems to be evaluated in IO by default)
15:42:06 <ddarius> @src Data.Set Monoid
15:42:07 <lambdabot> Source not found. You untyped fool!
15:42:27 <mattam> subconscious: STRefs and HOAS don't work together?
15:42:35 <Cale> If things don't have a type which is compatible with being an IO action, then print is applied to them, and if they do, then they're executed in the IO monad.
15:42:39 <subconscious> At least I can't make them useful together
15:42:56 <Cale> Also, these days, it seems that print is applied to the result in the latter case, but that's really annoying.
15:43:51 <mm_freak> no prolog channel =/
15:44:07 <inimino> there's a setting that turns that off
15:44:27 <Cale> Yeah, but it seems only to apply to some cases.
15:45:26 <ddarius> :t Data.Set.toList
15:45:27 <lambdabot> forall a. S.Set a -> [a]
15:48:08 <Heffalump> subconscious: I think you'd have to overload the HOAS result type  over a monad.
15:48:12 <Heffalump> (or bake in ST)
15:48:30 <Heffalump> hmm, perhaps that's not right.
15:48:35 <subconscious> well I am trying thing with data T m = App (T m) (T m) | Lam (T m -> m (T m))  at the moment
15:48:44 <subconscious> is that the right sort of idea?
15:49:10 <Heffalump> perhaps - though actually you want the embedded functions to be pure, presumably?
15:49:15 <Heffalump> Actually, why do you need STRefs?
15:49:23 <subconscious> my unification algorithm uses them
15:49:38 <Heffalump> why is doing unification on HOAS worthwhile?
15:49:59 <Heffalump> (I ask as someone who is writing a library that uses HOAS all the way down and realising it's not necessarily a very good idea)
15:50:28 <subconscious> Well I am starting the think I cannot do what I want with HOAS :)
15:50:34 <subconscious> but I was hoping to use it the whole way
15:51:00 <Heffalump> hmm, so why not pass in the STRefs as the parameters?
15:51:18 <Heffalump> i.e. make the STRef only appear in the Var constructors
15:51:34 <subconscious> data T s = TVar (Variable s (T s))
15:51:35 <subconscious>          | T s :-->: T s
15:51:36 <subconscious> like this?
15:51:51 <subconscious> (Variable means STRef)
15:52:03 <Heffalump> I guess, yeah.
15:52:28 <Heffalump> I would overload somehow so I could get pure terms too, though I'm not quite sure how to deal with s when doing that.
15:52:29 <subconscious> I suppose I could recursive over the whole structure to create a map from STRef -> Term
15:52:37 <subconscious> that would give a me a pure version of readST
15:52:39 <Heffalump> perhaps just data T s = TVar (s (T s)) | ...
15:53:02 <Heffalump> I'm not sure what you mean by that.
15:56:07 <subconscious> what library is it you are writing by the way?
15:56:30 <Heffalump> squiggle, an embedding of SQL
15:56:33 <subconscious> oh cool
15:56:38 <Heffalump> it doesn't need to do unification :-)
15:56:39 <subconscious> and has HOAS caused any awkwardness?
15:56:46 <Heffalump> yes, it can be really inefficient
15:56:54 <subconscious> hm ok
15:56:57 <Heffalump> suppose you have f :: Sql e -> Sql e
15:56:58 <subconscious> I am really stumped
15:57:02 <Heffalump> and optSE :: Sql e -> Sql e
15:57:15 <Heffalump> i.e. f is the HOAS function and optSE is a syntax tree optimiser
15:57:26 <Heffalump> then optSE . f is the obvious way to make an optimised f
15:57:33 <Heffalump> but then optSE gets rerun each time you apply f
15:57:39 <Heffalump> IM the optimised f
15:57:49 <subconscious> ah yeah
15:57:58 <subconscious> I think this is exactly the same problem I'm having
15:58:09 <subconscious> if you consider evaluation as effect, it can't happen under a lambda
15:58:09 <hackage> Uploaded to hackage: simple-sessions 0.1
15:58:09 <hackage> Uploaded to hackage: ixdopp 0.1
15:58:09 <hackage> Uploaded to hackage: preprocessor-tools 0.1
15:58:23 <Heffalump> yeah, that's kind of similar
15:58:26 <Heffalump> well, related.
15:58:37 <Heffalump> I did play some nasty games to rebuild HOAS functions.
15:58:38 <pfo>  is there a quick way to lookup the implementation of Prelude functions (in emacs, or ghci) ?
15:58:40 <Peaker> in L-Calculus, does \x->x x have a name?
15:58:46 <subconscious> Peaker: U
15:58:54 <Peaker> thanks
15:59:01 <Heffalump> http://code.haskell.org/squiggle/ has my code
15:59:01 <lambdabot> Title: Index of /squiggle
15:59:20 <subconscious> cool, thank you
15:59:20 <jethr0> @source lookup
15:59:20 <lambdabot> lookup not available
15:59:28 <jethr0> @source scanl
15:59:28 <lambdabot> scanl not available
15:59:40 <subconscious> Peaker: (U U) is called omega
16:00:22 <Peaker> subconscious: is that useful?
16:02:33 <dmwit> Peaker: Omega is usually the name for things that don't reduce.
16:02:40 <dmwit> (Not sure about the context here, though.)
16:02:46 <dmwit> i.e. an infinite loop
16:02:56 <Peaker> oh
16:03:05 <FunctorSalad_> well this omega here reduces to itself
16:03:30 <subconscious> oh well
16:03:37 <subconscious> since lambda prolog is broke
16:03:48 <subconscious> I think I will just use a first order reperesentation of syntax in haskell
16:04:44 <subconscious> that sucks :(
16:06:24 <FunctorSalad_> subconscious: what is broke?
16:06:37 <subconscious> teyjus
16:08:30 <dmwit> FunctorSalad_: That's what I meant.
16:09:48 <subconscious> I think I'm just really awful at programming in haskell and I just haven't realized it yet
16:10:03 <Heffalump> programming with HOAS is not easy.
16:10:21 <dmwit> ?go HOAS
16:10:22 <Heffalump> at least, I consider myself an expert Haskell programmer, and I found it hard.
16:10:24 <lambdabot> http://www.hoas.fi/webV2/ase_inetV2.nsf/Frameset?OpenForm&01
16:10:24 <lambdabot> Title: HOAS - Kotisivu
16:10:24 <FunctorSalad_> subconscious: I struggled with something that sounds similar recently and felt dumb too :)
16:10:36 <Heffalump> dmwit: Higher Order Abstract Syntax
16:10:45 <subconscious> writing an evaluator on HOAS is fine, and type inference for STLC (as HOAS) with first order types is really simple
16:10:53 <dmwit> Heffalump: Okay, I'll stay away. =)
16:10:53 <subconscious> I just think this is a fundamental problem with HOAS
16:11:03 <subconscious> like you can't have effects under a binding
16:11:35 <Heffalump> it doesn't really make sense to have effects under a binding.
16:11:35 <FunctorSalad_> effects under a binding?
16:11:42 <Heffalump> I don't quite understand what you really need.
16:11:47 <Heffalump> but I hope it's not that.
16:12:28 <Heffalump> the effects are meta-language effects, but the binding is an object-language binding (or intended to become one)
16:12:43 * subconscious *nod*
16:12:59 <subconscious> I think that is the root of the problem
16:13:15 <Heffalump> actually, I have a function in squiggle that does something like that. Let me look for it.
16:13:28 <subconscious> hi conal :)
16:13:37 <conal> subconscious: hi
16:13:52 <Heffalump> rebuildFuncM.
16:16:43 <subconscious> so the rebuildE function sort traverses the syntax, abstracting out variables that need to be represented as abstractions?
16:16:49 <subconscious> or am I misunderstanding that one+
16:17:08 <subconscious> sort of traverses*
16:18:00 <Heffalump> subconscious: it traverses the syntax rebuilding the expression from scratch.
16:18:29 <subconscious> ah, and it does this in order to evaluate things that had been applied to it so far?
16:18:34 <Heffalump> yep
16:18:54 <Heffalump> it's important both for speed (after an optSE) and for correctness of the dead code elimination pass
16:23:01 * subconscious should perhaps write a version of the unifier that uses functions for substitutions instead of ST
16:23:45 <Heffalump> I think if you want raw speed you shouldn't use HOAS anyway.
16:23:57 <sm> how do I specify the package name in haddock ?
16:24:00 <subconscious> I just didn't want to have to think about alpha conversion
16:24:06 <Heffalump> though I don't know for sure that it's necessarily less efficient
16:24:11 <Heffalump> yeah, that was my motivation too
16:24:17 <Heffalump> also it fits better with GADTs
16:24:36 <Heffalump> since the types of specific names match up for free
16:26:08 <FunctorSalad_> precomposition with functions looks like the natural choice for substitutions
16:26:17 <FunctorSalad_> not that I have much experience with this
16:26:39 <subconscious> FunctorSalad_: yeah it works out really concise
16:27:43 <FunctorSalad_> seems like one can't avoid plugging in symbols for Eq though?
16:27:57 <FunctorSalad_> or Show
16:29:05 <subconscious> Eq does simplify it but I don't think is essential
16:29:13 <subconscious> I have:  (i --> t) σ = \e -> if e == Var i then t else σ e
16:30:05 <FunctorSalad_> I mean for deriving Eq for the whole data structure
16:30:50 <subconscious> ah, so it's only applicable to first order data
16:31:11 <dibblego> ?index getArgs
16:31:11 <lambdabot> System.Environment
16:32:33 <Heffalump> FunctorSalad_: you just plug in the symbols when you want them, yeah
16:32:58 <FunctorSalad_> OTOH maybe you can capsule the problem away by deriving Eq for the function types that appear in your binders?
16:33:10 <FunctorSalad_> (with symbols, there)
16:33:57 <steven_ashley> Hi everyone. I just had a thought regarding case statements and would be keen to hear your thoughts. It is probably best shown using an example. "getState >>= case of { Nothing -> setState (Just 10) ; Just _ -> return () }". The expression in the case statement is removed and instead the case expression acts as a function.
16:34:16 <FunctorSalad_> hmm nevermind, I don't think this saves you from passing around the "fresh-index" counter
16:34:40 <Heffalump> I presume that deriving Eq doesn't work for function types. I've never actually tried to do it.
16:34:58 <FunctorSalad_> Heffalump: for function types Term -> Term
16:35:09 <shrughes> steven_ashley: others have had that thought too
16:35:20 <FunctorSalad_> you could check syntactic equality by plugging in symbols
16:35:26 <dancor> can lbot tell me e.g. that Monoid takes one var
16:35:28 <Heffalump> FunctorSalad_: yes, I know.
16:35:34 <Heffalump> But I doubt deriving Eq would work.
16:35:44 <steven_ashley> shrughes: I thought as much
16:35:50 <dancor> i want like   :k Monoid === ? -> *
16:35:55 <FunctorSalad_> maybe its my misuse of the word "deriving", I mean "instantiate" ;-)
16:36:04 <Heffalump> fair enough
16:36:12 <Heffalump> I do that
16:36:16 <dancor> @src Monoid
16:36:17 <lambdabot> class Monoid a where
16:36:17 <lambdabot>     mempty  :: a
16:36:17 <lambdabot>     mappend :: a -> a -> a
16:36:17 <lambdabot>     mconcat :: [a] -> a
16:36:25 <dancor> i guess that's strictly cooler
16:36:47 <shrughes> steven_ashley: http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase
16:36:48 <dolio> steven_ashley: http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase
16:36:51 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
16:36:52 <lambdabot> Title: LambdaCase - Haskell Prime - Trac
16:36:54 <dolio> Heh.
16:36:59 * subconscious rewrites everything as de bruijn
16:37:05 <steven_ashley> ahh, thanks :)
16:37:05 <FunctorSalad_> @kind Monoid
16:37:07 <lambdabot> Class `Monoid' used as a type
16:37:29 <FunctorSalad_> oh, right ;-)
16:40:34 <dons> btw, peoples, http://www.reddit.com/r/programming/comments/73smc/some_notes_on_the_future_of_haskell_and_fp/
16:40:36 <lambdabot> Title: Some notes on the future of Haskell and FP : programming, http://tinyurl.com/4fo7wn
16:40:42 <sm> it would be nice to be able to trigger ghci debugger from the code, like pdb.set_trace()
16:40:43 <dons> make sure you're up to date on the state of haskell
16:40:52 <subconscious> ?
16:41:05 <subconscious> or what?
16:41:14 <shrughes> you'll get kicked out of the channel, that's what.
16:41:14 <sm> thx dons!
16:41:23 <dons> damn straight.
16:41:27 <dons> no, its FYI.
16:41:37 <subconscious> what's new
16:41:48 <dons>     * per-thread GC collection coming
16:41:48 <dons>     * data parallel Haskell is in preview
16:41:48 <dons>     * new native code generator
16:41:48 <dons>     * haskell platform: batteries included on its way
16:41:48 <dons>     * Haskell Prime is going open source
16:46:13 <chadz> anyone play with Language.C much?
16:46:23 <chadz> i'm guessing analyseFunDef hasn't really been implememted yet, since it's type is:
16:46:26 <chadz> analyseFunDef :: MonadTrav m => CFunDef -> m ()
16:46:30 <chadz> or, am I just assuming wrong?
16:49:29 <FunctorSalad_> erm, why do I have "instance DC y y y2 y2" but get a "No instance for (DC (T Prop) (T x) Prop x)" error?
16:49:38 <FunctorSalad_> some relative of the DMR? ;-)
16:51:28 <subconscious> FunctorSalad_: forall x y, x doesn't necessarily equal y
16:51:40 <subconscious> FunctorSalad_: so I think it's scared of unifying Prop with x for that reason
16:52:07 <subconscious> (I am obviously guessing and don't actually _know_ though)
16:52:30 <int-e> chadz: it does something to the accompanying DefTable. But I haven't really played with it, so I don't know what exactly is happening there.
16:54:25 <FunctorSalad_> subconscious: ah, it doesn't want to restrict x to Prop?
16:54:44 <FunctorSalad_> I just looked at it from the "find any match" perspective ;-)
16:56:00 <Trinithis> @pl \f x y g -> f (g x) (g y)
16:56:00 <lambdabot> flip flip (flip id) . (((.) . ap) .) . (. flip id) . (.)
16:56:25 <Trinithis> @pl \f g x y -> f (g x) (g y)
16:56:26 <lambdabot> join . ((flip . ((.) .)) .) . (.)
16:56:30 <Trinithis> @pl \g f x y -> f (g x) (g y)
16:56:31 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
16:56:43 <Trinithis> @pl \x y f g -> f (g x) (g y)
16:56:43 <lambdabot> (. flip id) . flip . (ap .) . flip (.) . flip id
16:56:55 <Trinithis> what's that ap trick with functions?
16:57:04 <subconscious> :t ap
16:57:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:57:09 <chadz> int-e: well, without actually trying to learn how the entire api works i started writing a little callgraph generator. i've managed to get a list the functions [FunDef], now I just need to figure out how to go from (FunDef -> CFunDef)
16:57:10 <subconscious> :t ap (==)
16:57:12 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
16:57:15 <subconscious> :t ap (==) (+1)
16:57:16 <lambdabot> forall a. (Num a) => a -> Bool
16:57:21 <subconscious> :t const False
16:57:22 <lambdabot> forall b. b -> Bool
16:57:53 <Botje> f `ap` g = \x -> f x (g x)
16:57:56 <Trinithis> > ((+) `ap` (*2) ) 3
16:57:57 <lambdabot>   9
16:58:03 <Trinithis> ah now I remember
17:00:59 * [R]ayne Gives Trinithis a cookie. (:
17:01:17 <Trinithis> O.o
17:01:22 <int-e> chadz: you still have the function body around; note that  type Stmt = CStat  - the body is the Stmt part of the FunDef.
17:01:26 <int-e> chadz: does that help?
17:02:05 <chadz> yeah, i've gotten that far. i got hte the point where I'd have figure out I suppose what sort of CStat a function would be
17:03:00 <int-e> chadz: the outermost constructor will be CCompound, i.e. a block, I think.
17:03:11 <chadz> ah, good call
17:03:12 <chadz> makes sense
17:03:33 <chadz> the BlockItem'll define what' I'll want
17:05:23 <BMeph> @pl \f (a,b) -> f a b
17:05:23 <lambdabot> (`ap` snd) . (. fst)
17:05:36 <BMeph> ...
17:08:47 <pastorn_> hi again...
17:22:54 <pastorn_> @where modules
17:22:55 <lambdabot> I know nothing about modules.
17:23:24 <pastorn_> how does a module go about importing something in a parent folder?
17:24:35 <ddarius> All paths are relative to the directory you compile from (and any addition import paths)
17:25:00 <ddarius> If you are in Foo.Bar and you want to import Foo you just write 'import Foo'
17:27:13 <pastorn_> ddarius: thanks
17:27:18 <FunctorSalad_> say I have a type variable x in the context of a function type declaration. does "forall x" in the context mean that the instance must exist for all x, or for any x?
17:27:29 <pastorn_> it was a typo on my part that made me think something was wrong :/
17:27:38 <FunctorSalad_> (the variable x does not appear to the right of the =>)
17:32:36 <subconscious> why is GHC saying no instance for Applicative (ErrorT String (GHC.ST.ST s))
17:32:48 <eck> is there an estimated release date for ghc 6.10 yet?
17:33:55 <Heffalump> eck: a few weeks from now, AIUI
17:34:02 <Saizan_> subconscious: the mtl doesn't have many applicative instances
17:36:33 <eck> cool
17:47:22 * ddarius is losing to Haskell-Cafe.
17:47:31 <BMeph> What we need is a functional language that isn't so ambitious. Something that can help teach the functional paradigm, without depressing all those people who are going to be stuck programming in Java for the next five years before they get the seniority to work in a 'real' programming language. ;)
17:47:57 <Heffalump> BMeph: is this in reference to the CUFP discussion?
17:49:43 <dolio> Losing what?
17:49:46 <BMeph> Heffalump: No, actually, it's in response to the OS news reference last Friday, the "Haskell sucks 'cuz it makes me think about things" comment on Monday, and Cale's reply on Wednesday.
17:50:22 <BMeph> ddarius: Losing ground? Respect? Influence? Sanity? ;)
17:50:28 <Cale> BMeph: Out of interest, did anyone reply to my reply? I haven't gone back to check.
17:51:16 <BMeph> Cale: Nope, it's just the two comments. I'm debating adding something coherent, but I think you covered it all. :)
17:52:17 <subconscious> brrrrr why is it so hard to write a type checer
17:52:17 * sbahra shrugs
17:52:19 <dibblego> BMeph, do you have a link to this reference?
17:52:26 <sbahra> Why isn't haskell able to teach the functional paradigm?
17:52:27 <BMeph> Cale: Bah, as you were; there were seven comments, once yours came in. Yours is the last, though.
17:52:33 <sbahra> There isn't so much thinking required for the more basic things.
17:52:53 <dolio> Haskell isn't a conscious entity, and is therefore incapable of teaching anything? :)
17:53:02 <sbahra> You know what I mean.
17:53:07 <Cale> sbahra: I think it's quite capable of the task. It's far away from the languages which most *programmers* are used to though.
17:53:18 <dolio> @yow!
17:53:18 <lambdabot> Now I think I just reached the state of HYPERTENSION that comes JUST
17:53:18 <lambdabot> BEFORE you see the TOTAL at the SAFEWAY CHECKOUT COUNTER!
17:53:20 <sbahra> Cale, but that's because it's functional.
17:53:27 <Cale> sbahra: That's true. :)
17:53:31 <BMeph> dibblego: http://osnews.com/thread?331056 is what I was passed. Cale's comment should be stores somewhere - it's tight, relevant, and likely to be needed again... ;)
17:53:40 <lambdabot> Title: OSNews > Thread > "Haskell sucks." by axilmar
17:53:49 <dolio> There are universities that use Haskell as the intro language, no? So it can't be impossible.
17:53:58 <sbahra> dolio, I wish gwu.edu did :-(
17:54:08 * sbahra is organizing a lecture series with some people 
17:54:14 <dolio> Yeah. No US universities, I suspect.
17:54:16 <sbahra> But over here, they are teaching Scheme.
17:54:26 <sbahra> dolio, probably Yale, at the least.
17:54:47 <dolio> Well, I suppose that might make sense.
17:55:03 <dolio> What's CMU use? Some kind of ML?
17:55:35 <BMeph> sbahra: Haskell it quite able at it. It's too good at it - people keep getting the idea that you can't do any "side effects" in it, where the truth is, not only can you do it, but the program forces you to see it happening.
17:56:36 <newsham> TH splice question:  http://hpaste.org/10712
17:56:45 <dibblego> teaching Haskell to non-programmers is a dead cinch
17:57:05 <ddarius> Children have learned Haskell.
17:57:13 <ddarius> On their own no less.
17:57:29 <dibblego> I know a midwife who knows what a Functor is, after 5 minutes of explanation
17:58:00 <newsham> anyone hip to the TH wanna answer some questions?
17:59:31 <BMeph> @seen mmorrow
17:59:31 <lambdabot> I saw mmorrow leaving #haskell, #ghc and #darcs 2d 3h 44m 41s ago, and .
17:59:48 <BMeph> Ouch! Oh well, next victim... ;)
18:00:12 <Adamant> dolio: I know the UT institutions did
18:00:31 <dolio> UT?
18:00:35 <Adamant> UT Austin and UT Houston
18:00:40 <Adamant> University of Texas
18:00:44 <dolio> Oh. They use Haskell?
18:00:48 <Adamant> they did
18:00:52 <dolio> Nice.
18:01:03 <Adamant> I knew a guy who complained about them using it the intro language
18:01:07 <Adamant> probably justifiably.
18:01:10 <dolio> Heh.
18:01:59 <Adamant> I think the idea of learning Scheme and Haskell and such as a beginner language is generally flawed, unless your CS students are already math students.
18:02:05 <Adamant> or it's MIT
18:02:55 <dolio> Heh.
18:03:08 <Adamant> yeah, bash me. But it's my experience that teaching imperative programming is easiest for most student.
18:03:12 <Adamant> *students
18:03:17 <dolio> I don't know. I'm probably not the right person to make that judgment. :)
18:03:30 <dibblego> Adamant, because they have formed preconceptions already
18:03:44 <dibblego> children bork at x = x + 1
18:03:44 <Adamant> I think Scheme or Haskell should be the second language they learn.
18:03:51 <dibblego> certainly both of mine do
18:04:14 <dolio> I actually already knew multiple (imperative) languages by the time I got to college. I don't know how common that is.
18:04:33 <Adamant> dibblego: I'm talking about students who have zero experience with any programming language at all
18:04:47 <dibblego> Adamant, then I can teach them Haskell before the day is over
18:05:01 <Adamant> there's a known phenomena where it takes imperative students a while to get Haskell
18:05:03 <subconscious> dibblego: teach them to write what in haskell?
18:05:35 <dibblego> subconscious, the equivalent of what any typical newcomer from another language takes months to grasp
18:05:44 <sbahra> Adamant, because they are imperative.
18:05:54 <Adamant> dibblego: can you teach them to effectively use the IO monad and write programs equivalent to a imperative newbie in terms of IO?
18:05:57 <Adamant> because I doubt it.
18:06:03 <dibblego> Adamant, in about 10 minutes, yes
18:06:05 <subconscious> I don't beleive that
18:06:19 <Adamant> dibblego: your experience doesn't jibe with mine.
18:06:22 <sbahra> As a student who is learning haskell, I had to really *forget* the functional paradigm (and I found parallels with TLA, something I looked at before).
18:06:26 <Adamant> that's all I'm gonna say.
18:06:27 <newsham> oh, hmmm.. splices in places of types arent allowed yet.  blah
18:06:29 <dibblego> I've been teaching for years
18:06:29 <sbahra> s/functional paradigm/imperative/
18:07:08 <dibblego> the most progress I have ever made with an existing imperative programmer is having them write the Monad/Applicative for ((->) t) in 5 days
18:07:13 <sbahra> Adamant, also, "getting haskell" is much more different the "getting an imperative language", I would say.
18:07:33 <Adamant> dibblego: university intro CS students who may have wildly different backgrounds, including poor math skills?
18:07:35 <sbahra> Adamant, the average student would take quite a while to write an insertion sort in an imperative language...
18:07:48 <sbahra> Adamant, while this would be a very early exercise in haskell.
18:07:54 <dibblego> Adamant, yes, but not limited to just those
18:08:07 <Adamant> dibblego: and how much of this was taught in lecture as opposed to personal tutorial
18:08:13 <dibblego> Adamant, none
18:08:32 <Adamant> ok.
18:08:52 <Adamant> there is a real difference between personal attention and the reality of a lecture class.
18:08:56 <dibblego> indeed
18:10:16 <sbahra> Adamant, "I think the idea of learning Scheme and Haskell and such as a beginner language is generally flawed, unless your CS students are already math students."
18:10:21 <sbahra> Adamant, why?
18:11:18 <Adamant> sbahra: two reasons. One is that I don't they're necessarily the best languages for beginners. The second is that students can't do a lot of mainstream work with them, and tend to end up hating the language
18:11:24 <Adamant> *don't think
18:11:47 <sbahra> Yes, initially, I thought the functional paradigm was a joke personally (with scheme).
18:11:52 <Adamant> Scheme's already there, and if Haskell gets pushed in a similar situtation as Scheme the same thing happens.
18:12:00 <sbahra> But that's because I tackled it with imperative knowledge.
18:12:03 <Adamant> I've already seen it happen in fact.
18:12:29 <sbahra> Adamant, I see
18:12:31 <dibblego> they weren't beginners, they were tainted
18:12:42 <Adamant> dibblego: huh?
18:12:59 <sbahra> Well, again, how long would it take for 2 "average" beginners (1 learning imperative, 1 learning functional) to write an insertion sort, how about quick sort?
18:13:08 <sbahra> How about a graph coloring algorithm?
18:13:09 <Adamant> I've seen both people who had no experience and prior imperative experience do the same thing
18:14:02 <Adamant> and you are kidding yourself if you think pushing functional languages on the average CS undergrad makes them happy. they generally don't care and want to learn things that have industry use.
18:14:30 <BMeph> The real problem, is that for most imperative languages, a well-indexed reference manual of the commands can substitute for intermediate skill. This technique fails spectacularly in the case of Haskell. :)
18:14:33 <dibblego> the only other alternative to that proposition is a bad teacher (imposing the degeneration in the first place)
18:14:41 <Adamant> don't get it twisted, I like functional languages
18:14:53 <Saizan_> yeah, don't push haskell to CS newbies, we get too much of them asking questions here that way! :)
18:14:53 <dibblego> no untainted mind finds imperative programming intuitive
18:15:01 <Adamant> dibblego: you're being silly.
18:15:05 <BMeph> Yes, and I love imperative languages...in their place. ;)
18:15:20 <dibblego> no, I am speaking from countless observations
18:15:22 <Adamant> no programming is particularly intuitive
18:15:26 <dibblego> yes it is
18:15:30 <Adamant> including Haskell
18:15:32 <dibblego> my year old son thinks it is marvellous that this "ghci" thing can find words within words; now he doesn't have to compute them himself by thinking so hard
18:15:43 <dibblego> he'd already invented that computation before he knew ghci could do it
18:16:16 <Adamant> the bottom line is you're using a context-free language to express concepts the average human thinks of in their native language
18:16:23 <Adamant> that's never easy.
18:17:13 <Adamant> dibblego: your son can read at a year old?
18:17:19 <dibblego> I asked a Java programmer to remove the first 5 elements from a list of numbers, then remove all the remaining odd numbers and he started babbling about loops and things
18:17:25 <dibblego> Adamant, *7 year
18:17:30 <Adamant> ah
18:17:43 <subconscious> loops in java? crazy!
18:17:58 <dibblego> a non-programmer would solve that problem with "removeTheFirst 5 (removeThoseThatAreNot odd x)
18:18:19 <dibblego> but the Java programmer has a degenerate understanding of computer programming, that is unintuitive
18:18:22 <Adamant> yes, much like how you can program Lisp in English.
18:18:30 <subconscious> that's complete nonsense dibblego
18:18:32 <dibblego> or Haskell
18:18:56 <subconscious> and it's also biased, why are you singling out java when this applies to a class of languages
18:19:14 <dibblego> because Java is the most popular form of degeneration and so you can observe it yourself easily
18:19:51 <Adamant> dibblego: I'm being kindly sarcastic.
18:20:17 <BMeph> subconscious: Also, because if anyone's learning just one imperative language, it's Java. :|
18:20:26 <nanothief> I think that applies to any language, natural language is imprecise, and a lot of practice needs to be done in any language for people to learn how to write algorithms
18:21:35 <BMeph> The difficulty in learning something new, is not in how it's new, but in how the old things you already know look like they could apply, but do not.
18:23:47 <Adamant> also, no offense, but using your kid as representative example probably doesn't work. You're a pretty esteemed member here, you work with a language just recently coming out of research, and you're on Freenode when the majority of programmers are kicking back watching "The Office" so the odds that you have a IQ well above that of the average programmer are strong and that your kid got a fair amount of that via heritability. no offense intended in a
18:23:58 <Saizan_> i'd say that anything that offers multiple levels of abstractions is much more versatile and "natural" for reasoning than something that tends to flatten everything down to "loops" like java
18:24:15 <dibblego> Adamant, I am using my child as an example and betting that I can apply it to any reasonably smart child
18:24:30 <BMeph> Adamant: "Just recently"? Have you heard of Lua?
18:24:39 <dibblego> Adamant, though I have never done it with another child, I have done many things with non-programmers
18:25:22 <Adamant> dibblego: except a lot of people in CS are not necessarily all that smart.
18:25:27 <Adamant> they are certainly smarter than the average person
18:25:46 <Adamant> on average
18:26:01 <dibblego> yes I agree, with intellectually incapacitated people, it may serve best to propagate a degenerate model of thinking
18:26:02 <Adamant> BMeph: ?
18:26:42 <BMeph> Adamant: Confused by the topic change, or was I bing an @$$ in some other way? ;)
18:26:48 <Adamant> no, Lua
18:26:58 <Adamant> not seeing the relation to Haskell
18:27:31 <Adamant> unless you're talking about the fact it was inspired signficantly by Scheme like Ruby was
18:27:57 <dibblego> and I'm only on freenode because I recently had an ankle reconstruction and I can't do anything more interesting :)
18:28:13 <BMeph> Adamant: Lua's about fifteen years old. Kinda semi-obscure, but getting high exposure, thanks to Blizzard. Haskell's about five years older, and the last standard for it is ten years old, and rapidly getting obsolete. :)
18:28:19 <ddarius> dibblego: Like watch "The Office"?
18:28:29 <Adamant> dibblego: but that "interesting" thing would be hacking on ghc, admit it
18:28:32 <Adamant> ;)
18:28:51 <dibblego> I'd be squash training right now actually
18:28:55 <Adamant> ah.
18:29:04 <ddarius> Adamant: You don't need an ankle to hack GHC.
18:29:16 <ddarius> And programming is definitely not the most interesting thing to do.
18:29:20 * dibblego hobbles off
18:31:11 <Adamant> BMeph: Lua is probably not pushing things as much as Haskell does. There are Scheme implementations that are also designed for embedding like Lua, and Ruby and Javascript share the "imperative but functional and inspired by Scheme" niche.
18:31:50 <Adamant> although Ruby is also inspired by Smalltalk and IIRC Javascript by Self
18:32:49 <Adamant> ddarius: you are right.
18:35:51 --- mode: ChanServ set +o glguy
18:35:57 --- mode: glguy set -b *!*n=ushdf@*.syr.edu
18:37:27 --- mode: glguy set -o glguy
18:39:16 <lispy> javascript is also inspired by lisp, according to that famous Jamie Zwinski(sp?) guy that worked on netscape back in the day
18:39:58 <Adamant> lispy: I think the creator liked both CL and Scheme
18:40:30 <Adamant> it ended up being more toward Scheme because Javascript wasn't nearly as heavyweight then as now
18:40:42 <Adamant> and R6RS hadn't happened either
18:42:07 <lispy> wouldn't it be interesting if javascript had been R6RS?
18:42:52 <dolio> I'm sure that would have generated much less controversy.
18:46:54 * ddarius knows almost nothing about the final result of R6RS
18:47:03 <ddarius> R5RS for life
18:47:12 * ushdf knows enough about javascript to make weird PHP + JS toys
18:47:29 <ushdf> back in my day, we didn't have things like javascript
18:47:36 <ushdf> we went over to the computer of the people looking at our site
18:47:43 <ushdf> and fed it the assembly to make the page do what we wanted
18:48:04 <ushdf> i mean we drove there
18:48:32 <Adamant> ushdf: you didn't flip the switches on the PDP to toggle in the bits
18:48:37 <Adamant> in the rain
18:48:43 <Adamant> for 33 miles
18:48:50 <ivanm> you didn't just go and draw the webpage on paper for them and asked what they wanted to look like?
18:48:53 <subconscious> uphill both ways
18:49:07 <Olathe> With no legs.
18:49:30 <ivanm> s/driving/rolling/
18:49:30 <Adamant> and they hadn't invented the skateboard yet
18:49:46 <ushdf> how does the skateboard make it easier to go uphill?
18:49:55 <ushdf> in my personal experience, that works the other way
18:49:58 <Adamant> ushdf: it helps on the downhill
18:50:06 <ushdf> but it's uphill both ways!
18:50:11 <Adamant> right
18:50:16 <Adamant> then there's a downhill
18:50:20 <Adamant> and more uphill
18:50:21 <ushdf> no
18:50:24 <ushdf> the earth shifts while you're there
18:50:34 <ddarius> The coins never go my way.
18:50:35 <ushdf> there's a huge fulcrum in the middle of the road
18:50:38 * ddarius should never gamble.
18:50:50 <ushdf> and the weight is perfectly balanced on both sides, not considering you
18:51:04 <ushdf> so it shifts to whichever side you're standing on, it works a lot like C++
18:51:37 <subconscious> ddarius: me and my friend went to the fair with our.. graphing calculators once :)
18:52:02 <subconscious> ddarius: and we calculated how to beat the poker machine, we know exactly how to win by probabilities.. so we did that and lots all our money
18:52:09 <subconscious> lost*
18:52:13 * BMeph is old enough to remember sheltering paper tape from rain during a transport.
18:54:05 <lispy> > [False ..]
18:54:07 <lambdabot>   [False,True]
18:54:38 <ddarius> > [True, False ..]
18:54:40 <lambdabot>   [True,False]
18:54:59 <subconscious>  <Brent-tc> That I can't read that nonsense.
18:54:59 <subconscious> @remember <Brent-tc> Put it in readable format. XD What language is that even? VB?
18:54:59 <lambdabot> Nice!
18:55:33 <lispy> ?quote vb
18:55:34 <lambdabot> <Brent-tc> says: Put it in readable format. XD What language is that even? VB?
18:55:37 <Olathe> > liftM2 (>=) [True, False] [True, False]
18:55:39 <lambdabot>   [True,True,False,True]
18:55:47 <Olathe> > liftM2 (&&) [True, False] [True, False]
18:55:48 <lambdabot>   [True,False,False,False]
18:55:59 <lispy> hey now, stop making truth tales
18:56:01 <lispy> tables*
18:56:10 <Olathe> OK :)
18:56:19 <lispy> (I was just teasing)
18:56:20 <subconscious> ?go haskell bird tables
18:56:22 <lambdabot> No Result Found.
18:56:46 <sbahra> "<BMeph> Adamant: Lua's about fifteen years old. Kinda semi-obscure, but getting high exposure, thanks to Blizzard. Haskell's about five years older, and the last standard for it is ten years old, and rapidly getting obsolete. :)"
18:56:50 <sbahra> BMeph, obsolete? How so?
18:57:06 <sbahra> It looks to me like haskell is only becoming more and more popular.
18:57:10 <ddarius> sbahra: The standard, not the language
18:57:12 <Adamant> sbahra: well it's going to be replace with Haskell Prime shortly.
18:57:13 <sbahra> Oh
18:57:22 <dolio> It is?
18:57:29 <Olathe> What is Haskell Prime ?
18:57:31 <sbahra> "shortly"
18:57:37 <dolio> :)
18:57:40 <Olathe> The thing after Haskell 98 ?
18:57:40 <dolio> 2 years ago.
18:57:46 <Olathe> Oh.
18:57:59 <BMeph> sbahra: Think of how people talk about writing a Haskell program that complies with H98. Not as if it were the standard, so much as a stable point that every other Haskell compiler will understand. :)
18:58:30 <ddarius> "obsolete" is a bit strong
18:59:25 <BMeph> What was the recent reference to H' that mentioned how "after three years (we're) about 10% done"? :)
18:59:33 <sbahra> BMeph, wasn't clear you were referring to H'98
18:59:53 <ddarius> http://planet.haskell.org
18:59:54 <lambdabot> Title: Planet Haskell
19:01:38 <BMeph> ddarius: In my defense, I /did/ say "getting" obsolete. I meant it in the sense of becoming deprecated, but apparently, you folks just aren't fluent enough in BMeph yet... ;)
19:02:04 <BMeph> ddarius: Ah, thanks for the link. :)
19:09:13 <newsham> is there a command line option to make ghc emit the TH results?
19:09:38 <lispy> newsham: I don't know, but that would be cool.
19:12:11 <newsham> when I run   putStrLn $(myTest >>= lift . pprint)  and paste the results into my code, it compiles
19:12:21 <newsham> but when I do   $(myTest)  at the top level, it bombs out
19:12:38 <newsham> with an error that I dont understand
19:13:10 <Saizan_> newsham: something like -ddump-splices
19:13:45 <lispy> newsham: tell us the error
19:13:58 <lispy> newsham: usually you can't define the stuff in the same module that you use it
19:14:38 <newsham> test.hs:1:0: Illegal data constructor name: `x' When splicing generated code into the program
19:14:54 <newsham> also -ddump-splices isnt giving me an error about the arg, but isnt dumping anything for me
19:15:17 <newsham> (the macro is in a separate file)
19:16:11 <lispy> well, in the defense of the compiler, data constructors have to start with capital letters :)
19:19:01 <newsham> http://hpaste.org/10713
19:19:07 <newsham> thats the whole enchilada
19:19:15 <lispy> looking
19:21:03 <sm> what's a portable way to drop the last n elements of a list ?
19:21:21 <dibblego> reverse $ drop n $ reverse
19:21:22 <newsham> reverse . drop n . reverse
19:21:25 <ddarius> reverse . drop n . reverse
19:21:32 <lispy> that assumes a finite list though
19:21:33 <sm> thanks
19:21:41 <newsham> last n assumes a finite list
19:21:45 <dibblego> so does "the last n elements"
19:21:58 <lispy> yeah
19:22:02 <sm> if this url in infinite, I'm screwed :(
19:22:02 <ddarius> sm: Obviously this is not a good idea for performance.
19:22:15 <ddarius> (Incidentally, I'm wondering how you expect to write an unportable version.)
19:22:40 <sm> I figured there was some perfect fn that isn't in prelude or haskell 98 or something
19:22:57 <lispy> newsham: so I see some places where you have x's but your usage of TH is beyond whate I've done.  maybe someone else here can help
19:23:02 <sm> something in missingh probably. Wanted to exclude those
19:23:02 <newsham> i'm guessing my error has something to do with   [| x |]
19:23:03 <sm> thanks all
19:23:41 <lispy> ?hoogle last
19:23:42 <lambdabot> Prelude last :: [a] -> a
19:23:42 <lambdabot> Data.ByteString last :: ByteString -> Word8
19:23:42 <lambdabot> Data.List last :: [a] -> a
19:23:53 <Saizan_> > let dropEnd n list = zipWith const list (drop n list) in dropEnd 4 [1..10]
19:23:55 <lambdabot>   [1,2,3,4,5,6]
19:24:44 <ddarius> @remember sm if this url is infinite, I'm screwed :(
19:24:44 <lambdabot> It is stored.
19:24:51 <bd_> sm: http://hpaste.org/10714
19:24:52 * ddarius slightly misquotes
19:25:03 <sm> thank you for fixing it
19:25:09 * sm cheers.. fame at last
19:25:11 <bd_> should be able to handle infinite lists this way
19:26:07 <lispy> ?quote infinite
19:26:08 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
19:26:08 <lambdabot> like learn $ zip math haskell.
19:26:27 <lispy> byorgey++
19:26:54 <lispy> ?quote infinite
19:26:55 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
19:26:55 <lambdabot> like learn $ zip math haskell.
19:27:01 <dolio> Need that omega "monad".
19:27:05 <lispy> ah is that really the only quote?
19:27:51 <sm> I wish I didn't have to ask this again.. but what's a good built-in way of replacing a substring in a string ?
19:27:57 <ddarius> sm: Taking things off the end of a list is not behaviour you want to encourage.
19:28:05 <ddarius> It's bad enough we have init and last.
19:28:15 <lispy> Well, but Saizan's solution was perfect
19:28:21 <lispy> use the behavior of zipWith
19:28:45 <sm> but not terribly intention-revealing, I have to say
19:29:05 <lispy> Well, sure, it was terribly clever, but he hid that behind a nice name :)
19:29:10 <sm> true enough, never mind
19:29:17 <newsham> > let (a,b) = splitAt 5 "this is a test"; let c = drop 4 b in a ++ "WOO" ++ c
19:29:18 <lambdabot>   mueval: Prelude.read: no parse
19:29:33 <newsham> > let (a,b) = splitAt 5 "this is a test"; c = drop 4 b in a ++ "WOO" ++ c
19:29:33 <sm> thanks newsham
19:29:34 <lambdabot>   "this WOO test"
19:29:51 <sm> so when do we get regexps in the prelude, eh ? Eh ?
19:30:08 <lispy> sm: are you hacking darcs?
19:30:19 <sm> I'm hacking hoogle so I can hack darcs :)
19:30:19 <newsham> module MyPrelude where import Text.Regex.Posix
19:30:25 <sm> trying to fix those result links
19:30:50 <lispy> sm: ah, i was going to say if it was darcs then it already depends on regex...but yeah no idea about hoogle
19:31:01 <sm> and I am reduced to munging urls in the code
19:31:09 <subconscious> my code does not work :(
19:31:44 <BMeph> Well, time to see if I can get my cable modem talking to the 'net this weekend - see ya...
19:31:45 <ddarius> sm: Never.
19:32:39 <lispy> sm: ndm probably wouldn't mind if you used a Text.Regex, it seems pretty standard
19:33:23 <sm> hm. strange http://haskell.org/hoogle/?hoogle=text.regex doesn't find the module
19:33:24 <lambdabot> Title: text.regex - Hoogle
19:33:52 <sm> oh I see - superseded by regex-base!
19:34:06 <sm> so unhooglable. damn :)
19:34:07 <humasect> > liftM Just (return 5)
19:34:08 <lambdabot>       No instance for (Show (m (Maybe a1)))
19:34:08 <lambdabot>        arising from a use of `sho...
19:34:26 <newsham> Text.Regex.PCRE (on hackage) is a bit faster
19:34:33 <newsham> bbl
19:35:19 <humasect> > (liftM Just (return 5)) :: Maybe [Int]
19:35:20 <lambdabot>   Couldn't match expected type `[Int]'
19:40:03 <lispy> newsham: oh, did you try changing one x to y and the other to z and seeing if the error changes?
19:40:20 <lispy> newsham: maybe you could pinpoint which spot is erroring and focus there
19:40:22 <humasect> @hoogle a -> (a,a)
19:40:22 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
19:40:23 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
19:40:23 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
19:40:50 <sm> if I configure with --user (so it can see libs in ~/.cabal) does it stop looking in global ?
19:40:57 <sm> how can I make it see both ?
19:41:03 <Olathe> @hoogle (Unhooglable a, Hooglable b) => a -> b
19:41:03 <lambdabot> Warning: Unknown class Unhooglable
19:41:04 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:41:04 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:41:23 <lispy> ?seen dcounts
19:41:23 <lambdabot> I haven't seen dcounts.
19:41:27 <lispy> ?seen dcoutts
19:41:27 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-icfp 1h 24m 32s ago, and .
19:41:42 <lispy> sm: we need a cabal expert
19:41:48 <lispy> ?seen dons
19:41:48 <lambdabot> dons is in #haskell-icfp, #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 2h 35m 43s ago.
19:41:59 <lispy> but the two I know seem to be gone
19:42:01 <lispy> ?seen bos
19:42:01 <lambdabot> bos is in #haskell-icfp, #haskell and #ghc. I don't know when bos last spoke.
19:42:51 * sm tries to cabal-install --global more stuff and configure globally
19:43:07 <ushdf> ?seen ushdf
19:43:08 <lambdabot> You are in #haskell. I last heard you speak just now.
19:43:13 <ushdf> :D
19:43:18 <sbahra> D:
19:43:24 <lispy> sm: my experience has been that if you have it installed, user or globally taht cabal just finds it
19:43:26 <ushdf> > map (\x->sin(x)) [1..100]
19:43:27 <lambdabot>   [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.75680249530792...
19:43:35 <Olathe> Wasn't there another bot in here ?
19:43:38 <ushdf> > map (\x->sin(x)) [pi,2*pi..100*pi]
19:43:39 <lambdabot>   [1.2246467991473532e-16,-2.4492935982947064e-16,3.6739403974420594e-16,-4.8...
19:43:46 <ushdf> you little shit!
19:43:53 <Olathe> O...K
19:43:55 <sm> I see it complaining that regex-compat is hidden, but it's not
19:44:05 <ushdf> lambdabot, not you
19:44:15 <lispy> sm: I think that's a problem with the .cabal file then
19:44:29 <lispy> sm: cabal hides all the modules except those in the deps
19:44:32 <sm> ohh
19:44:34 <sm> thanks
19:44:45 <lispy> np, cabal is really misleading about that, I think it's been improved
19:44:51 <sm> tricksy.. dcoutts_ a warning in that case would be awesome
19:44:55 <sm> probably done it already
19:45:10 <bos> lispy: ?
19:45:10 <Saizan_> --user looks in both global and user
19:45:23 <Olathe> > let f x@(a%b) = show x ++ " = " ++ show a ++ "%" ++ show b in f (500%10)
19:45:24 <lispy> bos: needed a cabal expert, but I think we have it whipped?
19:45:24 <lambdabot>   mueval: Prelude.read: no parse
19:45:31 <Saizan_> the error about the hidden package is from ghc, that's why it's hard to fix in cabal
19:45:33 <bos> ok
19:46:21 <Olathe> Is (%) a constructor ?
19:46:30 <lispy> :t (%)
19:46:32 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:46:37 <sm> oh screw this
19:46:44 <lispy> Olathe: it should just be an operator
19:46:46 <Saizan_> Olathe: it doesn't start with : so no
19:46:49 <Olathe> Ahh.
19:47:14 <lispy> Olathe: note also, that since (%) takes the gcd of the arguments that it can't be a constructor :)
19:47:24 <lispy> > 2 % 10
19:47:26 <lambdabot>   1%5
19:48:06 <Olathe> @index (%)
19:48:06 <lambdabot> Data.Ratio
19:48:20 <lispy> ?hoogle Ratio a -> a
19:48:21 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
19:48:21 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
19:48:21 <lambdabot> Prelude id :: a -> a
19:48:21 <Olathe> What is the constructor ?
19:48:35 <lispy> Olathe: I bet it's hidden
19:48:45 <lispy> :% is my guess though
19:48:50 <Olathe> The source for Data.Ratio isn't helping much.
19:48:52 <Olathe> Ahh.
19:49:23 <lispy> -- | Rational numbers, with numerator and denominator of some 'Integral' type.
19:49:23 <lispy> data  (Integral a)      => Ratio a = !a :% !a  deriving (Eq)
19:49:27 <lispy> So yeah, :%
19:49:33 <lispy> :t (:%)
19:49:34 <lambdabot> Not in scope: data constructor `:%'
19:50:23 <Olathe> lispy: Where is that at ?
19:50:32 <lispy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Real.html#Ratio
19:50:34 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4wkpk4
19:51:07 <lispy> Olathe: I googled, haskell Data.Ratio, then I clicked the link to the haddock and then scrolled down to data Ratio, and clicked the Source link on the far riht
19:51:27 <Olathe> Ahh, thanks.
19:52:45 <sm> success. thanks all
19:56:44 <Olathe> > gcd 0 0
19:56:46 <lambdabot>   mueval: Prelude.read: no parse
19:56:46 <lambdabot>  mueval: *** Exception: Prelude.gcd: gcd 0 0...
19:56:48 <Olathe> Bah.
19:57:09 <Olathe> > lcm 0 0
19:57:10 <lambdabot>   0
19:57:35 <roconnor> wtf?
19:57:40 <roconnor> @src gcd
19:57:41 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
19:57:41 <lambdabot> gcd x y = gcd' (abs x) (abs y)
19:57:41 <lambdabot>    where gcd' a 0  =  a
19:57:41 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
19:57:50 <roconnor> lies
19:57:58 <roconnor> gcd 0 0 = 0
19:58:38 <roconnor> > gcd 0 5
19:58:40 <lambdabot>   5
19:58:43 <roconnor> > gcd 0 6
19:58:45 <lambdabot>   6
19:58:55 <roconnor> gcd 0 x = x
19:59:15 <Olathe> Right.
19:59:15 <roconnor> > gcd 0 (-6)
19:59:17 <lambdabot>   6
19:59:27 <roconnor> well gcd 0 x = abs x
19:59:30 <Olathe> > gcd 0 (1%2)
19:59:31 <lambdabot>       No instance for (Integral (Ratio t))
19:59:31 <lambdabot>        arising from a use of `gcd'...
19:59:49 <sbahra> http://digg.com/world_news/AIG_and_Collapse_PREDICTED_TO_THE_DAY_User_then_banned
19:59:52 <sbahra> very interesting read
20:00:07 <lispy> User_then_banned?
20:01:00 <roconnor> as I understand he got the date right and every other detail wrong
20:01:22 <roconnor> just a bunch of nonsense
20:01:40 <roconnor> find a pool of 365 users and one is bound to get a date right (and every other detail wrong).
20:01:45 <medfly> if we get 365 people, we can guess everything!
20:01:46 <medfly> yes
20:01:47 <Olathe> zomg !
20:01:56 * medfly pats roconnor 
20:01:59 <Olathe> Did he use Haskell ?
20:04:27 <sebaseba> @faq Can Haskell guess everything?
20:04:27 <lambdabot> The answer is: Yes! Haskell can do that.
20:05:07 <Olathe> @faq Can ghci on Windows accept more than a few hundred characters per line ?
20:05:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:05:36 <Olathe> Oh !
20:05:38 <Olathe> How ?
20:06:48 <lispy> ?faq Can Haskell cure male pattern baldness?
20:06:49 <lambdabot> The answer is: Yes! Haskell can do that.
20:09:28 <Olathe> @faq Stupid is as stupid does.
20:09:28 <lambdabot> The answer is: Yes! Haskell can do that.
20:12:23 <sm> quote-worthy: Haskell: it may be avoiding success, but it's certainly quite popular. --dougalstanton
20:12:23 <sm> have you a nick here, sir ?
20:17:12 <[R]ayne> ?remember dougalstanton Haskell: It may be avoiding success, but it's certainly quite popular.
20:17:12 <lambdabot> Done.
20:18:47 <SamB_XP> sometimes I wish we would avoid success better
20:19:03 <SamB_XP> like, moving fail and mzero to MonadZero ...
20:19:26 <SamB_XP> bringing back monad comprehensions ...
20:29:00 <ddarius> Bring back Haskell 1.4
20:29:31 <mrd> out with the new in with the old
20:33:31 <Cale> ddarius: agree!
20:34:04 <Cale> We need a Haskell branch for the language enthusiasts at least.
20:34:20 <ddarius> That would suck.
20:34:48 <zloog_> So if everything is Haskell 98. Does that mean nothing changed in the last decade?
20:34:56 <Cale> zloog_: It's not true.
20:35:12 <dolio> What's "everything"?
20:35:18 <Cale> zloog_: However, Haskell 98 is holding back progress in some areas.
20:35:18 <chrisdone> 42
20:35:22 <Adamant> everything has changed. but mostly in ghc.
20:35:42 <zloog_> Cale: Oh I see. So ghc isnt really Haskell 98?
20:35:46 <dibblego> it didn't change, it was given a world and a new world popped out the side side, sheesh!
20:35:54 <Cale> zloog_: It's many many extensions on top of Haskell 98
20:36:05 <chrisdone> dibblego: the sea side?
20:36:13 <zloog_> Cale: But no changes to language core?
20:36:30 <dolio> No changes to the standard.
20:36:33 <Cale> zloog_: Well, quite a few, but most are reasonably backwards compatible
20:36:45 <Cale> zloog_: It's just the standard hasn't kept up.
20:37:22 <Cale> zloog_: GHC can still give you something which is (reasonably close to) Haskell 98, but almost nothing targets that.
20:37:39 <Cale> (at least not specifically)
20:38:08 <zloog_> Oh i see
20:38:30 * mrd awaits Haskell [20]98
20:38:33 <zloog_> And is the haskell report the same thing as haskell 98 or a diffrent thing?
20:38:49 <Cale> Haskell 98 is a particular version of the Report.
20:39:14 * ddarius has no idea what zloog_'s mental model for these things is.
20:39:52 <zloog_> ddarius: Thats what im working on as well
20:40:24 <dancor> i have   f :: Rand g (IO ())   so of course i need to do   main = join $ evalRandIO f   but the interesting thing is that   main = evalRandIO f   compiles but hangs on run.  what's it doing?
20:41:24 <Cale> I could stand to have fewer libraries and more core language progress.
20:41:42 <Cale> I can't even learn all the libraries on Hackage now.
20:42:14 <Cale> I understand that people who actually want to do practical things with the language might see things differently though ;)
20:42:41 <ddarius> Core language progress seems reasonably decent.  The only real reason I would want a new Report is to fix some mistakes and make de facto standards actual standards.
20:42:49 <Nafai> Cale: Libraries are why I reach for a language like Python more often than others
20:43:16 <Cale> I'm more interested in conceptual programming than actual programming, I'm afraid :)
20:43:17 <ddarius> Anyway, library evolution and core language evolution are somewhat independent.
20:43:37 <Cale> ddarius: Well, one demands maintenance from the other.
20:44:28 <Cale> If you change basic things about how Haskell works, then libraries have to be updated to reflect it, or else, a system has to be in place to make different versions of Haskell work together.
20:45:01 <Cale> anyhow, bbiab
20:45:22 <pastorn_> @pl \f (x,y) -> (f x, y)
20:45:22 <ddarius> Cale: There will need to be transition support regardless.  Also, hopefully mutative changes won't be too common.
20:45:22 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
20:45:24 <dancor> why does this compile and run: main = return $ return ()
20:45:31 <ddarius> pastorn: first
20:45:31 <pastorn_> fuk dat...
20:45:39 <dancor> i also have main :: IO (IO ())
20:45:40 <geezusfreeek> :t return $ return ()
20:45:41 <ddarius> > first f (x,y)
20:45:42 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m (m1 ())
20:45:43 <lambdabot>       Ambiguous occurrence `f'
20:45:43 <lambdabot>      It could refer to either `L.f', defined a...
20:45:51 <dancor> so don't try to get out of it by using some other monad
20:45:52 <ddarius> @undefine
20:45:54 <pastorn_> @type first
20:45:55 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
20:45:57 <ddarius> > first f (x,y)
20:45:58 <lambdabot>   Add a type signature
20:46:03 <pastorn_> oh, right...
20:46:03 <ddarius> > first f (x,y) :: (Expr, Expr)
20:46:04 <lambdabot>   mueval: Prelude.read: no parse
20:46:07 <pastorn_> arrows
20:46:18 * pastorn_ wanted to keep things simple...
20:46:31 <ddarius> pastorn: Just replace a with (->).
20:46:36 <ddarius> This usage isn't using "arrows" at all.
20:46:41 <dancor> first is simple if you are only using it on the (->) arrow
20:46:57 <ddarius> With a = (->) you get, (b -> c) -> (b,d) -> (c,d)
20:47:05 <mrd> > first (+1) (1,2)
20:47:06 <lambdabot>   mueval: Prelude.read: no parse
20:47:16 * ddarius dislikes mueval.
20:47:34 <dancor> it's a bug with mueval -l, i'm sure of it..
20:47:55 <dancor> -l is acting like --no-op
20:48:22 <dancor> the funny part is how long it's been broken
20:49:15 <Saizan_> dancor: uh? L.hs works here
20:49:16 <ddarius> dancor: It can't be longer than some of the bugs in lambdabot, though those tend to be less annoying.
20:49:44 * ddarius Tries to connect what Saizan_ said to what dancor said.
20:49:48 <Saizan_> also, if -l didn't work we couldn't use any of the @let-defined things
20:50:08 <dancor> ddarius: i think   ~ mueval -l L.hs   works for Saizan_
20:50:16 <Saizan_> ddarius: heh, lambdabot uses -l to load definitions from L.hs
20:50:48 <Saizan_> dancor: it doesn't have in scope modules imported by the -l-ed file, that's true
20:51:02 <dancor> Saizan_: ya, is it not supposed to?
20:51:11 <dancor> basically, why is first not in scope for lbot
20:51:15 <Saizan_> no
20:51:30 <Saizan_> you've to import those with -m
20:51:42 <Saizan_> > first
20:51:43 <lambdabot>       Overlapping instances for Show (a b c -> a (b, d) (c, d))
20:51:43 <lambdabot>        arisin...
20:51:50 <Saizan_> it seems to be in scope..
20:52:12 <dancor> > (+1) *** (+2) $ (4, 5)
20:52:13 <lambdabot>   mueval: Prelude.read: no parse
20:52:20 <Saizan_> i'm not sure what's causing the read failure there, but it seems to be fixed in the darcs version
20:52:24 <dancor> > first (+3) (4, 5)
20:52:25 <lambdabot>   mueval: Prelude.read: no parse
20:53:38 <dolio> > first (3+) (4,5)
20:53:39 * dancor .oO(also why is mueval repo called mubot)
20:53:39 <lambdabot>   mueval: Prelude.read: no parse
20:54:21 <Saizan_> weird, it looks like it's in scope for typechecking but not for evaluation?
20:54:39 <Saizan_> and i'm not talking about :t
20:55:08 <dancor> Saizan_: ok, yeah fixed in darcs version
20:55:14 <dancor> who redeploys lbot
20:55:33 <Saizan_> dancor: is it fixed?
20:55:54 <dancor> Saizan_: for me installing darcs mueval made arrows work again
20:55:57 <dancor> like you said
21:01:08 <Saizan_> yep, mostly because Control.Arrow has been added to the list of modules imported by default
21:12:33 <lispy> some combination of gwern and Cale are the lambdabot deployment team
21:13:54 <SamB_XP> lispy: how come you haven't been inducted?
21:13:58 <SamB_XP> it is your box, isn't it?
21:14:23 <SamB_XP> (should that be "induced"?)
21:16:17 <lispy> SamB_XP: I was just thinking the same thing
21:16:30 <lispy> Probably because I told Cale that he had to deal with it :)
21:16:35 <SamB_XP> ah
21:16:47 <SamB_XP> Cale: induce him anyway!
21:16:50 <lispy> I wouldn't mind doing it once in a while, but I don't have the time to really do it
21:17:16 <SamB_XP> into the ... higher order of lambdabot deployment engineers?
21:17:55 <lispy> I would love to get lambdabot on the web working again though
21:18:11 <lispy> it would be super whizbang cool to host that off the official lambdabot
21:18:13 <ddarius> higher order of lambdabot deployment and management engineers or HOLDME
21:18:24 <lispy> ?vixen HOLD ME
21:18:25 <lambdabot> i like your screen name... what does it mean?
21:18:47 <lispy> ?vixen It means I'm a higher order kind of guy
21:18:48 <lambdabot> and now that I have finished with you, you may go!
21:18:52 <SamB_XP> @tell Cale induce lispy into the higher order of lambdabot deployment engineers plz kthxbai
21:18:52 <lambdabot> Consider it noted.
21:18:52 <lispy> :(
21:19:11 <SamB_XP> @remember ddarius higher order of lambdabot deployment and management engineers or HOLDME
21:19:11 <lambdabot> It is stored.
21:20:09 <luqui> I am now officially frightened.  Did I find a hacky special case in Haskell!?  Let's see if lambdabot can verify.
21:20:16 <luqui> :t let wtf = undefined :: Maybe (forall a. a -> a) in wtf >>= (\x -> return $ x 0)
21:20:17 <lambdabot> forall a. (Num a) => Maybe a
21:20:25 <luqui> :t let wtf = undefined :: Maybe (forall a. a -> a) in (\x -> return $ x 0) =<< wtf
21:20:26 <lambdabot>     Couldn't match expected type `t -> a'
21:20:26 <lambdabot>            against inferred type `forall a1. a1 -> a1'
21:20:26 <lambdabot>       Expected type: Maybe (t -> a)
21:20:47 <luqui> can anyone explain that?
21:21:16 <SamB_XP> luqui: not I!
21:21:27 <SamB_XP> @type (=<<)
21:21:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:21:39 <SamB_XP> @type (>>=)
21:21:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:22:05 <SamB_XP> luqui: but it seems like an issue with higher-rank polymorphism
21:22:23 <luqui> I found the issue.
21:22:30 <SamB_XP> hmm?
21:22:31 <luqui> kindof
21:22:31 <ddarius> The impredicativity hack?
21:22:46 <SamB_XP> kindof?
21:22:54 <SamB_XP> what does this have to do with kind inference?
21:23:10 <ushdf> tell us, luqui
21:23:12 * ushdf inches closer
21:23:14 <luqui> it's just about the argument order
21:23:21 <ushdf> he's lying!
21:23:24 <ushdf> he's a witch! burn him!!!
21:23:28 <luqui> lol
21:23:30 <SamB_XP> ushdf: he isn't
21:23:37 <SamB_XP> what ELSE could the problem be caused by?
21:23:45 <ushdf> witchcraft
21:23:47 * luqui is thankful that >>= wasn't given special attention or something
21:23:48 <ushdf> case closed!
21:23:58 <luqui> that's what it looked like at first
21:24:14 <SamB_XP> ushdf: Haskellers don't believe in witchcraft -- only wizardry
21:24:31 <SamB_XP> luqui: no of course not!
21:24:33 <lispy> luqui: oh, depending on the version of ghc you use ($) will work and not work with rank-n polymorphism
21:24:39 <ddarius> luqui: I suspect that the problem is due to the way impredicativity was hacked into GHC.  If I remember correctly, one aspect of it was that it resolved things left to right.
21:24:47 * luqui knew about that one, lispy 
21:24:49 <SamB_XP> lispy: that doesn't seem like the problem
21:24:50 <lispy> kk
21:25:03 <SamB_XP> lispy: since that part of the code is the same in both versions
21:25:10 <SamB_XP> the only difference was >>= vs. =<<
21:25:25 <SamB_XP> (and the arguments are swapped, obviously)
21:25:34 <dancor> if i want to run a cleanup function if my program is killed should i play with sigINT or is there something more generic
21:25:38 <lispy> SamB_XP: yeah, but then what about what ddarius said?
21:25:49 <ddarius> If this is correct, then issues like this is why the support is planned on being removed (if I recall that correctly)
21:25:49 <dancor> s/killed/interrupted
21:25:50 <ushdf> do you believe in hedonistic indulgements?
21:25:53 <lispy> dancor: I don't know if atexit will work here
21:26:17 <SamB_XP> ddarius: hmm?
21:26:28 <SamB_XP> they aren't just switching to a simpler way ?
21:26:41 <lispy> dancor: you might google around and see what things like sdl do, I think they have this same problem...at least I think.
21:26:44 <dancor> lispy: does that exist in libraries?
21:26:50 <dancor> i only know it as a c func
21:26:51 <SamB_XP> (or are they already using the simpler way ?)
21:26:53 <dancor> and can't find
21:27:03 <lispy> dancor: well, atexit is a C function, I don't know where a Haskell binding lurks.
21:27:23 <dancor> i thought maybe something with io finally
21:27:25 <bd_> atexit would be run after the RTS is shut down anyway, surely
21:27:39 <lispy> oh heh, there is that
21:27:42 <bd_> or well, the atexit callback
21:28:01 <lispy> dancor: I don't know if a braket in main will get run on sigINT
21:28:24 <lispy> dancor: but you could write a test program
21:28:36 <dancor> doing that now :)
21:29:35 <ddarius> SamB_XP: My understanding is that they used a hack that they noticed could be easily done.
21:29:48 <adu> hi
21:29:55 <lispy> dancor: this would be cool to know.  If it doesn't solve your problem, post your code and what you tried to haskell-cafe and I bet you'd have an answer within 24 hours
21:30:01 <bd_> also, an unhandled signal won't run atexit handlers :)
21:30:12 <bd_> in C that is
21:30:22 <lispy> bd_: ah, that was a part I wasn't sure about
21:30:24 <dancor> lispy: finally works
21:30:32 <lispy> dancor: hpaste?
21:30:46 <bd_> unhandled signals are defaulted at the kernel level, so libc doesn't get a chance to do anything clever.
21:31:15 <dancor> lispy: http://hpaste.org/10716
21:32:16 <adu> i think split should be part of the Prelude
21:32:36 <lispy> dancor: cool, I updated it to be a bit more Haskelly, but that's cool that works
21:32:38 * dancor clicks remember-me every time on hpaste but it never does D;
21:32:51 <dancor> nice
21:32:52 <lispy> dancor: yeah, I gave up on putting my name on there
21:33:15 <dancor> glguy: doitright ;)
21:33:55 * lispy tries to make a mental note that 'finally' does the right thing on sigINT
21:34:10 * dancor keeps a "selffaq"
21:34:55 <lispy> show off ;)
21:35:02 <adu> are there any diffutils written in Haskell?
21:35:13 <adu> like in darcs perhaps?
21:35:15 <lispy> adu: there is an LCS
21:35:24 <lispy> adu: and yeah, the darcs source
21:35:35 <dancor> i should actually showoff my selffaq via vcs website..
21:35:39 <adu> lispy: does it do its own diff? or does it use "diff"?
21:35:42 <lispy> adu: but extracting the diff code from darcs might be a tiny bit painful
21:35:52 <lispy> adu: I'm pretty sure it does either
21:35:53 <glguy> dancor: that feature was disabled for some reason
21:36:03 <glguy> dancor: it isn't "broken" its "half turned off" :)
21:36:09 <dancor> but it's in high demand!  :)
21:36:14 <dancor> only half?
21:36:19 <adu> lispy: tiny?
21:36:56 <lispy> adu: well, I just don't know how that part of the code works.  I know a lot of darcs, but the diff stuff is something I stay far away from.
21:37:10 <glguy> half: it is set not to work but the checkbox is still there
21:37:10 * dancor still thinks it's wrong that you can do main :: IO (IO ())
21:37:14 <adu> lispy: lol ok
21:37:18 <dancor> ah yes :)
21:37:24 <lispy> adu: and I bet it's parameterized to work on old FPS, new ByteString and probably normal haskell strings too...
21:37:54 <adu> cool
21:37:55 <lispy> I could see if I can spot it thought
21:38:16 <dancor> glguy: so, given that no one can remember why, what would happen if i like sent a patch to reenable
21:38:56 <glguy> dancor: someone would have to be able to build it
21:39:08 <dancor> bitrot?
21:39:19 <glguy> I don't have the right arch
21:39:21 <lispy> adu: for example, the code to actually diff doesn't seem to appear in http://darcs.net/src/Darcs/Diff.lhs
21:39:47 <dancor> glguy: what arch
21:39:51 <glguy> x86
21:40:10 <dancor> glguy: so you just scp binary to the server?
21:40:33 <glguy> dancor: I don't know, sorear used to build it for that server
21:40:37 <adu> lispy: hmm, thats kinda wierd
21:40:59 <adu> lispy: Lcs.lhs?
21:41:01 <lispy> adu: actually it may be in the function diff_from_empty
21:41:10 <lispy> adu: I think that one is important yes
21:41:22 <lispy> adu: but lcs.lhs can be found outside of darcs...on hackage even I think
21:41:33 <adu> really... cool
21:43:10 <adu> lispy: I want a custom diff tool, and I don't want to start from scratch
21:43:37 <lispy> adu: well you should definitely be able to get that from darcs, it's just a matter of figuring out where
21:43:41 <adu> like I think I want a "vertical" diff (thats what Wikipedia calls it)
21:44:03 <adu> its calls GNU diff a "horizontal" diff
21:44:19 <dancor> is that   diff --side-by-side
21:44:33 <adu> i dunno
21:44:47 <adu> I just want it to diff on chars rather than diff on lines
21:45:45 <lispy> adu: so getChanges seems to be what you want from Lcs.lhs
21:45:49 <adu> ok
21:45:58 <lispy> getChanges ::  [PackedString] -> [PackedString] -> [(Int,[PackedString],[PackedString])]
21:46:17 <lispy> now let's see if you can find an lcs that isn't part of darcs
21:47:08 <adu> lcs-0.2 is on hackage!
21:48:37 <lispy> adu: but the api it provides is totally different
21:49:12 <lispy> adu: I think I've helped as much as I can, good luck!
21:49:21 <adu> lispy: thanks
21:49:26 <lispy> you're welcome
21:50:25 <lispy> adu: if you make a char based diff, especially if it's based on the darcs source, then those patches would be welcomed in darcs.  We have use for such a kind of diff, but no one has ever taken the time to implement it.
21:50:34 <dmwit> ?oeis 70 836 4030 5830 7192
21:50:37 <lambdabot>  Weird numbers: abundant (A005101) but not pseudoperfect (A005835).
21:50:37 <lambdabot>  [70,836,4030,5830,7192,7912,9272,10430,10570,10792,10990,11410,11690,12110,1...
21:50:55 <lispy> ?penis 1 2 3
21:50:57 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
21:50:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:51:15 <lispy> gotta love the auto-correction ;)
21:51:45 <dolio> Well played.
21:51:49 <adu> lispy: I've already decided upon a syntax. It will be mostly "diff -u" compatible except in addition to [\ \+\-@] as starting lines, % will indicate a slightly modified line and %-[...] and %+[...] will indicate changes in the slightly modified line
21:53:17 <adu> lispy: if thats even possible... i guess i'll find out
21:54:42 <lispy> indentation and character based diffs are two things people often ask for with darcs
21:54:54 <lispy> They would be really cool patch types
21:55:16 <lispy> and if you have a vertical diff, I bet it could handle indentation
22:00:50 <lispy> adu: if you have questions about this project, or want to share, feel free to talk about it in #darcs.  I'm sure it would be welcomed discussion.  Especially if you get interested in contributing it to darcs.
22:01:20 <adu> lispy: ok that would be neat :)
22:08:41 <dancor> glguy: i'm trying to build hpaste, but i don't see withPastes defined anywhere.. is a file missing from the darcs repo or sumthin
22:14:50 <dons> btw, guys, if you want to know where haskell is heading, after this *huge* week at ICFP, check out Bryan's blog, http://twurl.cc/5a7
22:14:54 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » Some notes on the future of Haskel ...
22:15:24 <dons> so much as happened and been discussed this week, its the most important ICFP I've been to.
22:16:24 <cjb> dons: are there any writeups?
22:16:28 <cjb> (other than the one you just linked)
22:16:35 <cjb> I haven't heard anything about ICFP
22:16:49 <dons> that's the main thing so far. we all have to digest the innovations and direction changes.
22:17:03 <dons> it was astounding how many commercial users we have
22:17:31 <lispy> dons: welcome back to planet earth!
22:17:52 <dons> btw, its also on reddit, but reddit seems to have the suck at the moment, http://www.reddit.com/r/programming/comments/73smc/some_notes_on_the_future_of_haskell_and_fp/
22:17:55 <lambdabot> Title: Some notes on the future of Haskell and FP : programming, http://tinyurl.com/4fo7wn
22:17:58 <dons> lispy: heh. not back yet. one more day.
22:18:02 <dons> but most of the big things have happened.
22:18:17 <dons> platform, haskell prime, jobs, ... a few more stories are on the way too.
22:18:26 <lispy> jobs?
22:18:54 <dons> well, an awful lot of commercial users. people were talking.
22:19:02 <dons> pity the economy collapsed while we were in canada :)
22:19:12 <lispy> :(
22:19:23 <lispy> blame canada :)
22:19:41 <dons> that's what they say.
22:19:54 <maxote> do agree you China collapsed U.S.?
22:20:05 <cjb> .. what?  no.
22:20:51 <bd_> a lot of people made a lot of shortsighted, greedy decisions, none of which were fatal alone, but together resulted in a huge amount of value vanishing when it was too late to fix
22:21:12 <maxote> the richer will be a loser
22:21:20 <dons> heh.
22:21:26 <lispy> I can see this getting off topic fast :)
22:21:30 <dons> yes.
22:22:11 * lispy pushes more thesis revisions
22:22:16 <glguy> dancor: make sure you are using the hpaste-devel repo
22:22:17 <lispy> getting there...I hope
22:22:32 <glguy> dancor: the with- functions are probably template haskell magic
22:22:37 <glguy> HAppS has lots of it
22:23:24 <dons> glguy: why hpaste-devel ?
22:23:33 <lispy> dons: will I get a packet of information in the mail about getting to galois and what to expect when I gave the presentation?  Even better, can I go to a presentation before I have mine, so I know what to expect?
22:23:34 <dons> oh sorry.
22:23:36 <dons> i see.
22:23:47 <dons> lispy: yes, yes.
22:24:03 <dons> lispy, are you on the pdxfunc list?
22:24:14 <lispy> no, because i'm silly and didn't know about it
22:24:17 <dons> ah
22:24:24 <dons> so you would see all the announcements.
22:24:30 <dons> so how do you find out about tech talk annoucnements?
22:24:31 <bos> hiya dons
22:24:36 <dons> or how would you like to find out about them?
22:24:41 <dons> hey bos. had dinner?
22:24:50 <bos> sort of.
22:24:54 <lispy> dons: I would like to subscribe, where is the mailman page?
22:25:00 <dons> ?go pdxfunc google
22:25:02 <lambdabot> No Result Found.
22:25:05 <dons> ?go pdxfunc
22:25:07 <lambdabot> No Result Found.
22:25:08 * dons slaps lambdabot 
22:25:13 <dons> use the real google
22:25:19 <bos> dons: what about you?
22:25:35 * glguy is conferenced out
22:25:37 <dons> had dinner with howard and geoff
22:25:38 <lispy> dons: so it's a google group?
22:25:42 <dons> glguy: bah, 2 more days!
22:25:47 <dons> and then you have to drive me home :)
22:25:58 <glguy> I'm ready to go home tonight
22:26:01 <glguy> pack your bags!
22:26:02 <dons> bos, psyched for tomorrow?
22:26:08 <dons> i was pimping your talk all day
22:26:11 <bos> heh
22:26:20 <bos> it'll be fun
22:26:28 <lispy> dons: oh hrm, is the next meeting mine?  says oct 13th...
22:26:38 <dons> lispy: nah, there's on next week.
22:27:04 <lispy> maybe i'm lookign at the wrong thing, I'm on the 14th anyway
22:27:42 <bos> the hotel room furniture is atrocious for working at
22:27:53 <bos> my wrists hurt, and my arse is numb
22:28:02 <ivanm> bos: see, you should bring your own furniture whenever you travel... ;-)
22:28:11 <adu> wow
22:28:14 <adu> i got shivers
22:28:23 <dons> bos, you only need your brain and fingers. the arse is redundant
22:28:31 * bos gives up on the tabletop
22:29:10 <lispy> dons: while I have your attention, do you mind forwarding the most recent announcement to me...I don't see one in the google group for next week
22:29:10 <adu> no more "logjam" ... thats enough to give anyone a chill on their spine :)
22:29:29 <dons> hmm there's none yet for nextweek
22:29:32 <dons> since i'm in canada
22:30:08 <dmwit_> adu: I'm excited!
22:30:11 <adu> ghc++
22:30:14 <dmwit_> I hope it works like they say it's going to work.
22:31:01 <adu> dmwit_: it already works good enough for me :) I'm just excited about the standardization and popularity
22:31:31 <lispy> dons: well, I'm subscribed now so that's a start
22:31:42 <hml> given the following; how do I use cabal to  install  mtl, unix, and X11? : ghc-pkg list Cabal
22:31:44 <adu> subscribed?
22:31:45 <hml> /usr/lib/ghc-6.8.2/package.conf: Cabal-1.2.3.0
22:31:49 <dons> ok. so you'll see the annoucnement soon enough
22:31:53 <lispy> adu: to the pdxfunc group
22:32:35 <adu> lispy: ah ic, far far awaya
22:32:50 <dmwit> hml: cabal update && cabal install mtl && cabal install unix && cabal install X11
22:33:14 <lispy> adu: what part of the world are you in?
22:33:17 <hml> x@x:~/Desktop/xmonad-0.8$ cabal
22:33:17 <hml> bash: cabal: command not found
22:33:24 <dmwit> hml: If you want to install globally, stick a --global on each of the install steps.
22:33:33 <adu> lispy: MD, the closest fp group near me is FringeDC
22:33:36 <hml> dmwit: how do i check where  this 'cabal' is installed?
22:33:43 <dmwit> hml: Oh, sorry, I misread your Cabal version.
22:34:01 <dmwit> hml: You have two choices.
22:34:07 <adu> hml: should be in ~/.cabal
22:34:13 <lispy> adu: ah, you're near the people that made Morrowind and Oblivion though.  I bet those guys would be fun to talk to.
22:34:17 <dmwit> hml: Either grab the packages from hackage one at a time and chase down their dependencies, or
22:34:26 <hml> adu: ~/.cabal is non-existentn
22:34:30 <adu> dmwit: I wouldn't call it "choice" so much as its really hard to install to /usr/local
22:34:35 <dmwit> hml: grab the "cabal-install" package from hackage, source bootstrap.sh, then do the steps above.
22:34:44 <lispy> adu: they seem to be passionate about their game universe, which makes me think they'd be interesting people.
22:34:46 <hml> dmwit: or what? why don't i have 'cabal' given that ghc-pkg list Cabal shows a version?
22:34:49 <dmwit> adu: I don't know what you're talking about.
22:34:59 <dmwit> hml: Cabal used to be just a library.
22:35:16 <dmwit> hml: It's only in the last 2-3 months or so that it made the leap to consciousness. =)
22:35:41 <glguy> the cabal binary comes from the cabal-install package
22:35:44 <glguy> not the Cabal library
22:35:46 * lispy imagines dcoutts saying, "It's alive!  It's ALIVE!"
22:36:00 <adu> lol'
22:36:24 <lispy> 'cuz ya know, we built this hackage
22:36:37 <lispy> http://www.nabble.com/Hackage-needs-a-theme-song!-td19467156.html
22:36:42 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Hackage needs a theme song!
22:36:47 <lispy> (if you don't know the lyrics, then learn them now!)
22:36:59 <adu> we built this hackage on rock and roll o/^ o/^
22:37:12 <hml> wow; i love how that ./bootstrap.sh just wgets stuff and tries to install it; no fear at all of random crap
22:37:16 <dons> can't wait for the HW videos to be online.
22:37:22 <dons> all the cabal / hackage demos live.
22:37:44 * lispy hopes that the hackage video has the aforementioned tune in the bg ;)
22:38:09 <dons> no, but we did it live!
22:38:12 <lispy> adu: you mean, we built this hackage on lambda and types!
22:38:23 <adu> lispy: just doesn't have the same ring...
22:38:29 <dons> the audience could pull from dcoutt's laptop during the presentation, with build logs uploaded live to the screen
22:38:40 <lispy> whoa
22:38:45 <lispy> dons: that's crazy
22:38:46 <ivanm> :o
22:38:50 <dons> yeah, crazy AWESOME!
22:39:02 <lispy> most people would be afraid to be all "live" during a demo
22:39:06 <ivanm> so when can we expect hackage' to be released? :p
22:39:12 <dons> prob. next couple of weeks.
22:39:19 <adu> lispy: how about "built this hackage on lambda and pi..."
22:39:34 <adu> or am I confusing pi calculus and type theory... :/
22:39:39 <ivanm> lispy: well, one time when we had a group webapp demo with a live version (only group to do so!), some idiot decided to go and stuff it up whilst we were talking, and thus crashing it :@
22:39:41 <lispy> adu: the lyrics are on the haskellwiki if you want to edit
22:40:02 <dons> btw, guys, we need haskell app / dev screencasts.
22:40:11 <dons> show how to build something cool, quickly, with haskell.
22:40:18 <dons> get 'em on haskell.org, and take over the world.
22:40:23 <dmwit> Hey, I built something cool today!
22:40:35 * lispy is reminded of the SQL on Rails webcase
22:40:38 <lispy> cast*
22:40:41 <dons> roll an opengl game in 5 mins, write a compiler in 10 mins ...
22:40:43 <dons> 'zactly
22:40:56 <adu> dons: I can do that with my diff!
22:41:04 <lispy> the SQL on Rails was a spoof of ruby on rails though
22:41:32 <lispy> adu: if you want to update the lyrics: http://haskell.org/haskellwiki/Humor/Hackage_Theme_Song
22:41:34 <lambdabot> Title: Humor/Hackage Theme Song - HaskellWiki
22:41:58 <dmwit> http://hpaste.org/10717
22:42:10 <adu> lispy: cuz "lambda and pi" you can yell for a really long time...
22:42:20 <dmwit> It's dirty, but it's kind of fun to watch. =)
22:43:38 <lispy> dmwit: cool
22:43:46 <adu> dmwit: why don't you use "cast" when its definition is right there at the end as well?
22:43:56 <dmwit> adu: oversight
22:44:02 <adu> :)
22:44:34 <dmwit> I've just been adding the obvious next feature at each stage, so it's sort of a gross architecture right now (no cleanup phases yet). =)
22:44:52 <lispy> dmwit: I think that's the longest haskell program I've read that doesn't have a single explicit type
22:45:24 <dmwit> Well, it's all monadic, so none of it is mind-bending enough yet to need a type. ;-)
22:45:29 <lispy> dmwit: I have to wonder what your type errors must be like :)
22:45:41 * dmwit doesn't make type errors ;-)
22:45:54 <dmwit> No, but really, GHC's error reporting is really very good.
22:46:13 <lispy> yeah, it could be much worse
22:46:17 <lispy> But, it's not always good.
22:46:32 <ivanm> dmwit: you don't make type errors because you just redifine HM until it matches your code? :p
22:46:44 <dmwit> hee hee!
22:47:03 <lispy> It does poorly when you have mult phantom types and then you insist on bundling your values up in wrappers that existentially quantified those phantoms...when you you unwrap and get type errors it can be mind boggling
22:47:25 <dmwit> Like I said... I haven't done anything mind-bending yet.
22:47:30 <dmwit> ...and I hope not to. =)
22:48:01 <lispy> But, then like I said, it could be much worse
22:48:18 <lispy> For example, if it just said, "Type error." and halted.
22:48:29 <lispy> that would be really bad :)
22:48:51 <dmwit> Actually, now that I look at this code again, I think I might have a race condition.
22:48:56 * dmwit adds a bug to the tracker
22:50:47 <lispy> dmwit: do you have one bug tracker that you use for all your hobbie stuff?
22:50:52 <dmwit> yeah
22:50:57 <lispy> that's a good idea
22:51:12 <lispy> I have a friend that uses fogbugz that way since it's free for up to 2 devs
22:51:24 <dmwit> That's what I do.
22:51:28 <dmwit> I have me and a guest account.
22:51:34 <lispy> I should do that
22:51:58 <dmwit> I convinced byorgey to do the same, though he uses it only as a fancy "todo" list.
22:51:59 <lispy> I have 3 projects I really want to either start or finish
22:52:06 <lispy> heh
22:52:22 <lispy> I want to rename and finish helisp
22:53:11 <lispy> helisp is my re-implementation of emacs lisp that can run on the bare metal :)
22:53:22 <dmwit> Neat!
22:53:28 <dolio> Wow.
22:53:34 <dmwit> But... can it also control emacs?
22:53:35 <dolio> You should notify Xah Lee when you're done.
22:53:39 <lispy> it was intended to be plugged into yi so that we can emulate emacs
22:53:43 <dmwit> aah
22:54:03 <lispy> Xah Lee?  Oh when I said bare metal, I did mean with an OS, just not interpreted
22:54:27 <dons> oh.
22:54:32 <dolio> Yeah, he posted several elisp related rants to comp.lang.functional a couple months ago.
22:54:34 <dons> but you could run it on the halvm :)
22:55:06 <dolio> Apparently he's disappointed that it hasn't made much progress as a language lately.
22:55:07 <lispy> I also may switch it over to harpy, although i'm slightly fond of my asm code gen monad :)
22:55:13 <adu> lispy: or could it also allow yi to run emacs extensions??
22:55:15 <lispy> dolio: heh
22:55:18 <dons> dolio: lisp?
22:55:27 <dolio> Emacs lisp specifically.
22:55:34 <lispy> adu: yeah, that was the point. You could just plugin your existing emacs code into yi.
22:55:35 <dons> yeah, this entire week, there were 3 themes: haskell, ocaml, erlang.
22:55:40 <dolio> Although I think he antagonizes lisp in general for the same reason.
22:55:46 <adu> lispy: :)))))
22:55:53 <dons> there's experimental languages for doing other things, and Coq was pretty common.
22:55:54 <lispy> adu: this is to make it easier to transition from real emacs to yi
22:56:01 <dons> but in terms of real stuff, those 3 are the big players now.
22:56:14 <dons> and we're maybe 2 years or more ahead on the package/libraries front.
22:56:23 <dons> we actually have reusable code, and hundreds of packages :)
22:56:31 <dolio> Oh hey, did I miss the uvector release? :)
22:56:36 <adu> HNU yi ... just imagine
22:56:47 <dons> the yi demo was awesome too.
22:56:53 <dons> doing indenting based on layout == mega fun
22:57:30 <dons> btw, http://www.reddit.com/r/programming/comments/73smc/some_notes_on_the_future_of_haskell_and_fp/
22:57:32 <lambdabot> Title: Some notes on the future of Haskell and FP : programming, http://tinyurl.com/4fo7wn
22:57:35 <lispy> dons: well, ocaml is about 2 inches away from being replaced by F#
22:57:38 <dons> the best summary of what's happening so far.
22:57:45 <dons> lispy: yes. that was also a big theme.
22:57:46 <vegai> oh, someone had fun
22:57:52 <dons> if you're on windows lock-in.
22:58:10 <vegai> now for the biggest problem: How to convince a typical employer that sending me to ICFP is a good idea
22:58:17 <lispy> dons: yeah, it's going to be a hard niche, but then it keeps coming up on stackoverflow.com
22:58:19 <dons> vegai: oh, you're here??
22:58:25 <dons> no.
22:58:31 <dons> vegai: yes, that was a question.
22:58:34 <lispy> I need to head out
22:58:34 <vegai> no, you see I haven't solved that yet :)
22:58:38 <dons> how about an big official fp.com site
22:58:40 <lispy> g'night guys!  exciting times
22:58:49 <dons> that lists the language, and the commercial backers
22:58:55 <dons> and is offical looking enough to sell it to managers?
22:59:19 <dons> say you had yahoo, and a bunch of major banks, and microsoft and so on, as backers.
22:59:23 <vegai> perhaps I'll find a new employer or just get a vacation and pay it myself
22:59:28 <dons> then going to ICFP would be like going somewhere else awesome.
22:59:28 <vegai> ...next year
22:59:38 <dons> is edinburgh close?
22:59:45 <foxy-om> how do I hide an operator?  "import Data.Map hiding (`!`)" causes a parse error?
22:59:46 <vegai> close enough
22:59:57 <dolio> (!)
23:00:06 <foxy-om> thanks!
23:00:30 <dmwit> ((!))
23:00:40 <dolio> Backquotes infix-ize normal functions, and parents prefix-ize infix operators.
23:00:58 <dolio> Parens, even.
23:01:16 <vegai> dons: this year it was so far away that I didn't think it to be realistic to even try
23:01:22 <dons> yeah
23:01:36 <adu> dons: if i didn't know better, i'd say you were making things up, but I just happen to remember how thats all true
23:03:02 <adu> well, YouTube and Microsoft are certainly are...
23:03:32 <dons> adu: and yahoo rewrote delicious using erlang.
23:04:47 <vegai> I keep wondering whether or not it is ethical to secretly bring Haskell code to my company
23:04:56 <adu> hm, interesting, I once used delicious...
23:05:19 <dons> vegai: if it is for the good of humanity
23:05:36 <dons> i think we can expect developers to be able to read haskell now.
23:05:45 <dons> at least as much as say, m4 or sed :)
23:05:52 <dons> which certainly get used in weird situatoins
23:05:59 <dons> so just do it.
23:06:37 <adu> it wouldn't be for me... my job rests on the fact that people will always write bugs in C... if everyone used Haskell I'd be homeless
23:06:46 <adu> or work somewhere else...
23:07:11 <dolio> You can totally write bugs in Haskell.
23:07:18 <adu> dolio: lol
23:07:22 <glguy> dolio: ssh
23:07:30 <dons> we have Agda2!
23:07:44 <dons> i wonder if people will be saying in 5 years: "Is it ethical to use Agda in my company"
23:07:45 <glguy> dolio: if poeple knew that I'd be homeless
23:07:46 <glguy> !
23:07:53 <dolio> :)
23:08:11 <adu> dolio: much harder tho, all the easy ones like buffer overflows and non-exhaustive cases and segmentation faults are gone
23:08:12 <dons> glguy: my goal is to write a few new things in Agda.
23:08:16 <dons> just a function here and there.
23:08:32 <adu> dolio: you gotta think really hard to write bugs in Haskell
23:08:38 <glguy> ha
23:08:41 <[R]ayne> LOL
23:08:46 <vegai> I actually have a perfect candidate for a little bit of Haskell rewriting
23:08:46 <[R]ayne> I can do it!
23:08:53 <dolio> I've actually written my share of segfaults in Haskell, lately, too, but that's because I've been messing around with uvector stuff.
23:08:59 <[R]ayne> But then again I just started functional programming yesterday. :)
23:08:59 <dons> dolio: oi!
23:09:08 <glguy> uvector is C arrays for Haskell
23:09:08 <dons> dolio: -fsafe if you're scared :)
23:09:13 <glguy> with all the liabilities :)
23:09:13 <dons> glguy: -fsafe.
23:09:18 <glguy> and the speed
23:09:18 <dons> if you want checked exceptions.
23:09:24 <glguy> dons: that isn't the default
23:09:27 * dons ponders making it the default
23:09:32 <dons> but the speeds ... the speeds!
23:09:34 <dolio> Well, I wasn't scared. That might have made finding my bugs easier, though. :)
23:09:45 <dons> cabal install uvector -fsafe
23:09:47 <dons> that's all.
23:09:48 <adu> dolio: well, were you thinking hard?
23:09:56 <dons> i know. should a haskell library by default be unsafe?
23:10:00 <dons> probably not. its unethical.
23:10:02 <glguy> dons: cabal install anything else depending on uvector
23:10:09 <dons> glguy: nothing else does :)
23:10:18 <dons> since there's no introduction forms for uvector.
23:10:23 <glguy> solved
23:10:28 <dolio> adu: I was writing imperative sorts, so yeah, it was hard. :)
23:10:50 <dons> i think we have a good use case for uvector now thogh
23:10:54 <dons> malcolm's big imaging work
23:11:00 <dons> needs fast double arrays and friends. that fuse.
23:11:07 <dons> the result: pretty things.
23:18:12 <chr1s> yeah
23:18:20 <chr1s> we need more pretty things!
23:19:26 <adu> pretty things... :)
23:20:52 <adu> @remember dons the result: pretty things.
23:20:52 <lambdabot> Nice!
23:34:34 <dons> chr1s: right!
23:34:43 <ushdf> > 5
23:34:44 <lambdabot>   5
23:34:57 <ushdf> liar!
