00:10:51 <trofi> :t peek
00:10:52 <lambdabot> Not in scope: `peek'
00:19:30 <mmorrow> @let splitExt = fmap reverse . uncurry (flip (,)) . fmap (reverse . drop 1) . span (/='.') . reverse
00:19:32 <lambdabot>  Defined.
00:20:23 <Myoma> :t uncurry (flip (,))
00:20:24 <lambdabot> forall b a. (a, b) -> (b, a)
00:20:27 <Myoma> grrrr
00:20:29 <Myoma> @let swap = uncurry (flip (,))
00:20:29 <mmorrow> hehe
00:20:31 <lambdabot>  Defined.
00:20:40 <mmorrow> > splitExt "Binary.hs"
00:20:41 <lambdabot>   ("Binary","hs")
00:20:51 <mmorrow> > splitExt "Binary.asdf.gfds.hs"
00:20:52 <lambdabot>   ("Binary.asdf.gfds","hs")
00:21:03 <davidL> > splitExt "..."
00:21:04 <lambdabot>   ("..","")
00:21:12 <mmorrow> damn
00:21:28 <trofi> > splitExt ".cabal/"
00:21:29 <lambdabot>   ("","cabal/")
00:21:48 <mmorrow> yeah, it assumes it's a filname, not a filepath
00:21:58 <mmorrow> davidL brings up a good point though
00:22:33 <trofi> > splitExt "."
00:22:34 <lambdabot>   ("","")
00:22:47 <trofi> > splitExt "^.^"
00:22:48 <lambdabot>   ("^","^")
00:24:06 <mmorrow> that worked (?)
00:25:33 <davidL> why not let the user specify an extension, similar to basename(1)?
00:26:18 <Myoma> :t bool
00:26:19 <lambdabot> forall t. t -> t -> Bool -> t
00:26:20 <Myoma> @let ch _ [] = [[]] ; ch c (o:os) = bool ([os]:) id (o==c) (map (o:) (ch c os))
00:26:21 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
00:26:27 <Myoma> @let x = 1
00:26:29 <lambdabot>  Defined.
00:27:28 <mmorrow> davidL: thx
00:27:53 <Myoma> @let ch _ [] = [[]] ; ch c (o:os) = bool (os:) id (o==c) (map (o:) (ch c os))
00:27:55 <lambdabot>  Defined.
00:28:01 <Myoma> > ch '.' "x.p.z"
00:28:02 <lambdabot>   ["xp.z","x.pz","x.p.z"]
00:28:20 <Myoma> that was rubbish
00:29:33 <Myoma> @let let ch _ [] = [([],[])] ; ch c (o:os) = bool ((os,[]):) id (o==c) (map (second (o:)) (ch c os))
00:29:33 <lambdabot>   Parse error
00:29:44 <Myoma> @let ch _ [] = [([],[])] ; ch c (o:os) = bool ((os,[]):) id (o==c) (map (second (o:)) (ch c os))
00:29:44 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
00:29:54 <Twey> Errr
00:29:54 <Myoma> @let xh _ [] = [([],[])] ; xh c (o:os) = bool ((os,[]):) id (o==c) (map (second (o:)) (xh c os))
00:29:57 <lambdabot>  Defined.
00:30:02 <Myoma> > xh '.' "a.b.c"
00:30:03 <lambdabot>   [("b.c","a"),("c","a.b"),("","a.b.c")]
00:30:39 <mmorrow> heh
00:30:43 <mmorrow> @let dropPrefix pre s = fmap fst . dropWhile snd . zip s . (++repeat False) . zipWith (==) pre $ s
00:30:46 <lambdabot>  Defined.
00:30:53 <mmorrow> > dropPrefix "asdf" "asdfghjkl"
00:30:55 <lambdabot>   "ghjkl"
00:33:21 <Myoma> we should have a  coulpe of sessions
00:33:38 <Myoma> < for my prelude, > for normal, etc...
00:33:39 <Myoma> :p
00:34:24 <igli> sheesh Myoma why don't you ever try any of this in #friendly-coders?! ;)
00:34:44 <igli> i never see ANY hs in there and it's really annoying :)
00:34:55 <Myoma> haha ok
00:35:06 <mmorrow> @let splitExt_ ext s = maybe (splitExt s) (\ext -> (reverse . dropPrefix ext . reverse $ s, ext)) ext
00:35:08 <lambdabot>  Defined.
00:35:22 <mmorrow> > splitExt_ Nothing "Binary.hs"
00:35:23 <lambdabot>   ("Binary","hs")
00:35:31 <mmorrow> > splitExt_ (Just "y.hs") "Binary.hs"
00:35:33 <lambdabot>   ("Binary.hs","y.hs")
00:35:39 <mmorrow> gtahh!
00:35:54 <mmorrow> forgot to drop it there
00:35:57 <Myoma> :k Mu
00:35:58 <lambdabot> (* -> *) -> *
00:36:10 <igli> @bot :D
00:36:11 <lambdabot> :)
00:37:02 <igli>  <igli> @let splitExt_ ext s = maybe (splitExt s) (\ext -> (reverse . dropPrefix ext . reverse $ s, ext)) ext
00:37:03 <igli> [08:36] <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
00:37:08 <igli> what am i doing wrong?
00:37:13 <mmorrow> you can't redefine
00:37:19 <igli> ah ok
00:37:22 <mmorrow> and undefining kills everything
00:37:24 <mmorrow> :(
00:37:31 <mmorrow> so just use a diff name
00:37:33 <igli> fair enough
00:37:38 <igli> nice one :)
00:37:47 <mmorrow> :)
00:38:51 <Myoma> > let doesThisThingHaveViewPatterns (reverse -> (x:_)) = x in 654654757.5
00:38:52 <lambdabot>   mueval: Prelude.read: no parse
00:38:55 <Myoma> :|
00:39:02 <Myoma> @install ghc 6.9
00:39:02 <lambdabot> Not enough privileges
00:39:19 <quicksilver> I'm pretty sure that's not what view patterns look like anyway
00:39:25 <mmorrow> what if the output of make just started flooding the room
00:39:31 <quicksilver> isn't it (x:_) <- reverse ?
00:39:42 <mmorrow> that's pattern guards
00:39:48 <mmorrow> was just about to check that
00:39:54 <trofi> @help install
00:39:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:39:54 <Myoma> mmorrow: That would be awesome :D
00:40:49 <mmorrow> > let f xs | x:_ <- xs = x in f (show 654654757.5)
00:40:51 <lambdabot>   '6'
00:41:34 <mmorrow> > let f xs | x:y:_ <- xs = [y,x] | otherwise = [] in f (show 654654757.5)
00:41:35 <lambdabot>   ".6"
00:41:51 <mmorrow> um
00:42:07 <mmorrow> > show 654654757.5
00:42:08 <lambdabot>   "6.546547575e8"
00:42:10 <mmorrow> ah
00:42:53 <igli> "araujo" ++ (repeat '!')
00:42:57 <igli> > "araujo" ++ (repeat '!')
00:42:58 <lambdabot>   "araujo!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
00:43:02 <igli> yay :D
00:43:16 <hml> http://oreilly.com/catalog/9780596518554/ <-- is this how to dev for the iphone w/o using apple's tools?
00:43:19 <igli> now if only i could mem the char list one
00:43:21 <lambdabot> Title: iPhone Open Application Development | O'Reilly Media
00:43:39 <mmorrow> igli: ?
00:44:35 <davidL> > let basename = ((reverse <$>) .) . flip (stripPrefix . reverse) . reverse in basename "Binary.hs" ".hs"
00:44:36 <lambdabot>   Just "Binary"
00:44:42 <igli> heh sorry mmorrow, it's how we greet in #gentoo-haskell but it needs a diff formulation to repeat "string"
00:45:30 <mmorrow> ahh, so you mean cycle?
00:45:38 <igli> > let basename = ((reverse <$>) .) . flip (stripPrefix . reverse) . reverse in basename "/foo/bar/Binary.hs" ".hs"
00:45:38 <mmorrow> > cycle "!"
00:45:41 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
00:45:41 <lambdabot>  Terminated
00:45:47 <igli> ah yeah that's the one :)
00:46:03 <Myoma> > 'M' : cycle "u"
00:46:04 <lambdabot>   "Muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu...
00:46:10 <trofi> > fix (":] "++)
00:46:11 <lambdabot>   ":] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :] :]...
00:46:27 <igli> > "ivanm" : cycle "!11!!!"
00:46:28 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
00:46:38 <igli> > "ivanm" ++ cycle "!11!!!"
00:46:39 <lambdabot>   "ivanm!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11!!!!11...
00:47:01 <Myoma> > replicateMu 5
00:47:02 <lambdabot>   ["Mu","Mu","Mu","Mu","Mu"]
00:47:07 <mmorrow> haha
00:47:13 <igli> hehe
00:47:18 <Myoma> @kind Mu (Either (Either Integer (Mu (Either String))))
00:47:19 <lambdabot> *
00:47:43 <Myoma> @nikon
00:47:43 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
00:47:55 <igli> idk can't you just Integer|String ?
00:48:01 <igli> use^
00:48:25 <davidL> > replicateM 5 "Mu"
00:48:26 <lambdabot>   ["MMMMM","MMMMu","MMMuM","MMMuu","MMuMM","MMuMu","MMuuM","MMuuu","MuMMM","M...
00:48:43 <ivanm> igli: wrong channel, isn't it?
00:49:12 <igli> m00 ivanm dunno others seem to be doing silly strings ;)
00:49:16 <quicksilver> (Integer|String) gets proposed as a shorthand for Either, from time to time.
00:49:32 <quicksilver> (1|) for Left 1; (|"Hi") for Right "Hi"
00:49:36 <igli> hi quicksilver, sugar ftw :)
00:50:06 <quicksilver> it would certainly be quite fun but I don't see it as a big win. I don't use Either explicitly very often.
00:50:37 <igli> "fun in function" ;)
00:50:59 <igli> @kind Left
00:51:00 <lambdabot> Not in scope: type constructor or class `Left'
00:51:07 <igli> @kind Either
00:51:08 <lambdabot> * -> * -> *
00:51:14 <igli> ?
00:51:34 <Myoma> :kind Either a b
00:51:36 <Myoma> @kind Either a b
00:51:37 <lambdabot> Not in scope: type variable `a'
00:51:37 <lambdabot> Not in scope: type variable `b'
00:51:41 <Myoma> @kind Either () ()
00:51:42 <lambdabot> *
00:51:50 <Myoma> @kind Mu (Either ())
00:51:51 <lambdabot> *
00:52:11 <Myoma> @kind Mu (Either (Mu (Maybe)))
00:52:12 <lambdabot> *
00:56:17 <_zenon_> is there a kind command in ghci, or a kind package for this purpose?
00:56:41 <Myoma> yes
00:56:42 <rwbarton> Yes, :k
00:58:17 <_zenon_> thx
00:59:59 <igli> ktxhbye :D
01:01:08 <trofi> what do curly brackets mean in `ghc-pkg list' ? like this: `{HJScript-0.4.4}'
01:01:47 <ivanm> trofi: it's hidden
01:02:20 <trofi> because it's unusable?
01:02:34 <trofi> or superseded by something?
01:02:41 <solrize> http://hpaste.org/10156  so is there such a thing as a laziness annotation?
01:03:33 <mmorrow> trofi: uhoh. that means that one of the libs that pkg needs has been unregistered
01:04:09 <mmorrow> did you recently do any  ghc-pkg unregister foo-0.3.4 ?
01:04:13 <trofi> yep
01:04:17 <mmorrow> heh
01:04:27 <ivanm> well, doesn't that explain it? :p
01:06:04 <mmorrow> unfortunately cabal can't reregister, so you'll have to build again or (this is a VERY bad idea) add it to the package.conf by hand
01:07:03 <Myoma> @nixon
01:07:03 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
01:07:15 <trofi> i've removed old packages (hewer versions present in system). i can unregister hidden packages and reinstall them AFAIU
01:07:19 <[Head|Rest]> @stalin
01:07:20 <lambdabot> Unknown command, try @list
01:07:23 <[Head|Rest]> :/
01:07:35 <[Head|Rest]> @dzerzhinskiy
01:07:35 <lambdabot> Unknown command, try @list
01:07:45 <[Head|Rest]> @list
01:07:45 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:07:51 <Myoma> select(Head,[Head|Rest],Rest).
01:07:55 <mmorrow> trofi: you can  ghc-pkg hide _  and ghc-pkg expose _, but afaik ghc-pkg unregister _ is one way
01:08:28 <mmorrow> lol @nixon
01:08:49 <[Head|Rest]> @hoogle quine
01:08:50 <lambdabot> No results found
01:08:52 <Myoma> @. elite nixon
01:08:52 <lambdabot> sUre T|-|Er3 ARe DI$h0N3$+ /\/\eN iN LOC41 Gov3rn/\/\En7. bUT t|-|3rE aRe DizH0n357 /\/\En iN nA+iOna1 90\/erNMeNT 700.
01:08:53 <Myoma> @. elite nixon
01:08:53 <lambdabot> 4nY laDY \/\/h0 IS firS+ lADY LIK3S 8eIn9 fir$T |aDY. i d0N'7 (4R3 Wh4t T|-|Ey $Ay, th3y liKE I7.
01:08:54 <Myoma> @. elite nixon
01:08:55 <lambdabot> AnY laDy Wh0 IS fIRzt 14dy |ikeS 8eInG fIRST |aDy. I DoN'T (4RE wh4T th3Y zaY, THey |ike It.
01:08:57 <Myoma> @. elite nixon
01:08:57 <lambdabot> iF yOU Think The UnItED 5ta+ez0rz h45 STooD 5tI11, whO 8ui17 7he |ARg3sT z|-|OpPIng (En+3r IN +|-|e \/\/0R|d?
01:09:07 <trofi> :[
01:09:20 <[Head|Rest]> who is nixon? >.<
01:09:28 <mmorrow> he's not a crook!
01:09:38 <Myoma> I a/\/\ nO7 A CroOk.
01:09:49 <mmorrow> heh
01:09:58 * Myoma wants @greek
01:10:13 <trofi> @version
01:10:14 <lambdabot> lambdabot 4.2.1
01:10:14 <lambdabot> darcs get http://code.haskell.org/lambdabot
01:10:14 * Twey ponders.
01:10:14 <mmorrow> and it drop the first line of the iliad or something
01:10:20 <mmorrow> *drops
01:10:27 <mmorrow> ?
01:10:35 <Twey> > 'Œ±' - 'a'
01:10:36 <lambdabot>       No instance for (Num Char)
01:10:36 <lambdabot>        arising from a use of `-' at <interac...
01:10:45 <Twey> > ord 'Œ±' - ord 'a'
01:10:47 <lambdabot>   848
01:10:58 <Myoma> @@ @run say $ map (greek.fromEnum) @show @elite @nixon
01:10:59 <lambdabot>   œÄœÇŒ∏Œ≤Œ∏Œ∂œâœÖœâŒ≤ŒøœÑŒ∏Œ≥Œ∏Œ≤Œ∏Œ±œàŒºœâœÖœâœàŒªŒ≤œÄŒ∂Œ∏Œ∫Œ≤ŒªŒ∏œàŒªŒ∏ŒπŒ...
01:11:01 <Myoma> @@ @run say $ map (greek.fromEnum) @show @elite @nixon
01:11:03 <lambdabot>   œÄœÇŒ∏Œ≤Œ∏Œ∂ŒµŒ≤ŒøœÑŒ∏œÄŒ∏Œ≤Œ∏Œ±Œ∂Œ¥œâœÖœâŒµŒ¥Œ≤ŒºœÉŒ∏Œ≥œÑŒªŒ∏Œ∂Œ¥Œ∏œâŒµœÇœ...
01:11:05 <Myoma> ...
01:11:27 <Myoma> @@ @run say . take 15 $ map (greek.fromEnum) @show @nixon
01:11:28 <Twey> > let greek = (map (+ 848)) in greek "Hello"
01:11:30 <lambdabot>       No instance for (Num Char)
01:11:30 <lambdabot>        arising from a use of `+' at <interac...
01:11:30 <lambdabot>  Terminated
01:11:48 <mmorrow> that's gotta be fixed. it seems that it's currently chopping a utf8 char into two when it cuts the output and adds the "..."
01:11:49 <Twey> > let greek = (map $ chr . (+ 848) . ord) in greek "Hello"
01:11:50 <lambdabot>   "\920\949\956\956\959"
01:11:56 <Twey> > say $ let greek = (map $ chr . (+ 848) . ord) in greek "Hello"
01:11:57 <lambdabot>   ŒòŒµŒºŒºŒø
01:12:08 <Twey> Oh ah
01:12:11 <Twey> Surprisingly close
01:12:14 <Myoma> > map (greek.fromEnum) "hello"
01:12:16 <lambdabot>   "\949\946\953\953\956"
01:12:20 <Myoma> > say $ map (greek.fromEnum) "hello"
01:12:21 <lambdabot>   ŒµŒ≤ŒπŒπŒº
01:12:23 <trofi> > say "–™"
01:12:24 <lambdabot>   –™
01:12:26 <Twey> Eheh...
01:12:42 <Twey> Mine was closer :)
01:12:46 <mmorrow> i'll make a map to similar sounds real quick
01:13:06 * mmorrow took ancient greek for a few years
01:14:18 <trofi> > say $ map toLower "–•–∞"
01:14:19 <lambdabot>   —Ö–∞
01:15:36 <Myoma> > stars 42
01:15:38 <lambdabot>   ‚ú°‚ú°‚ú¨‚ú™‚ú≠‚ú°‚òÜ‚ú°‚òÜ‚ú∞‚ú∞‚úØ‚ú≠‚òÜ‚ú™‚ú∞‚ú¨‚ú°‚ú©‚ú≠‚ú≠‚ú™‚úß‚ú™‚ú≠...
01:15:43 <Myoma> > stars 73
01:15:45 <lambdabot>   ‚ú∞‚òÜ‚úß‚úß‚ú©‚ú°‚òÖ‚ú©‚úØ‚ú∞‚ú©‚ú™‚ú©‚ú≠‚úØ‚ú©‚òÖ‚ú™‚ú≠‚òÜ‚úØ‚ú™‚úß‚ú∞‚ú∞...
01:16:32 <_zenon_> > stars 1
01:16:34 <lambdabot>   ‚ú¨‚òÜ‚ú¨‚úØ‚òÖ‚úØ‚ú≠‚ú¨‚úß‚òÖ‚ú©‚ú¨‚ú≠‚ú©‚òÜ‚ú∞‚ú™‚úß‚òÜ‚ú≠‚ú≠‚úØ‚úß‚ú≠‚úØ...
01:16:38 <_zenon_> > stars 0
01:16:39 <lambdabot>   ‚ú∞‚ú∞‚ú∞‚òÖ‚úß‚úØ‚ú©‚ú©‚ú©‚òÜ‚ú∞‚úß‚ú™‚úß‚ú≠‚ú¨‚úß‚ú©‚ú¨‚ú™‚ú™‚òÜ‚úß‚ú¨‚òÜ...
01:16:46 <_zenon_> > stars (-1)
01:16:48 <lambdabot>   ‚ú¨‚òÜ‚ú¨‚úØ‚òÖ‚úØ‚ú≠‚ú¨‚úß‚òÖ‚ú©‚ú¨‚ú≠‚ú©‚òÜ‚ú∞‚ú™‚úß‚òÜ‚ú≠‚ú≠‚úØ‚úß‚ú≠‚úØ...
01:21:54 <Myoma> :t (1,0,-1)
01:21:55 <lambdabot> forall t t1 a. (Num a, Num t1, Num t) => (t, t1, a)
01:25:50 <mmorrow> @let fromGreek c = maybe [c] id (lookup c (zip greekAlpha ["a","b","g","d","e","z","\257","th","i","k","l","m","n","x","o","p","r","s","s","t","u","ph","ch","ps","\333"]))
01:25:53 <lambdabot>  Defined.
01:26:15 <mmorrow> the other way sucks because you have to catch "th" -> theta and such
01:26:30 <mmorrow> > say (concatMap fromGreek greekAlpha)
01:26:31 <lambdabot>   abgdezƒÅthiklmnxoprsstuphchps≈ç
01:27:42 <Myoma> > zip greekAlpha ["a","b","g","d","e","z","\257","th","i","k","l","m","n","x","o","p","r","s","s","t","u","ph","ch","ps","\333"]
01:27:43 <lambdabot>   [('\945',"a"),('\946',"b"),('\947',"g"),('\948',"d"),('\949',"e"),('\950',"...
01:28:38 <mmorrow> but what about "thephachacha"?
01:29:21 <mmorrow> need one char lookahead i guess
01:30:28 <mmorrow> Myoma: have you ever tried cayenne
01:30:29 <mmorrow> ?
01:30:38 <Myoma> no
01:30:48 <solrize> @seen byorgey
01:30:49 <lambdabot> I saw byorgey leaving #xmonad, #haskell-blah and #haskell 17m 37s ago, and .
01:31:08 <Myoma> why?
01:32:06 <mmorrow> it's cool. i got the src and built it the other day to check it out. i asked augustss about putting it on hackage and he said if i send him patches (that package it appropriately/make it build with cabal) he'd upload it. doing that now...
01:33:03 <mmorrow> Myoma: http://www.math.chalmers.se/~augustss/cayenne/index.html
01:33:15 <lambdabot> Title: Cayenne
01:33:27 <mmorrow> this paper is good: http://www.math.chalmers.se/~augustss/cayenne/interp.ps
01:35:07 <dons> mmorrow: awesome.
01:35:16 <dons> cabalising that'd be good
01:35:48 <mmorrow> dons: oh yesh
01:35:54 <mmorrow> :)
01:43:06 <Myoma> @w80 monomania
01:43:07 <lambdabot> *** "monomania" wn "WordNet (r) 2.0"
01:43:07 <lambdabot> monomania
01:43:07 <lambdabot>      n : a mania restricted to one thing or idea [syn: {possession}]
01:44:41 <ziman> @w80 polymania
01:44:42 <lambdabot> No match for "polymania".
01:48:11 <trofi> @hoogle finalizerFree
01:48:11 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
02:18:50 <solrize> mmorrow what happens if you have a language like that with no multiplication?  is type checking decidable?
02:20:56 <Myoma> multiplication?
02:21:17 <solrize> arithmetic multiplication
02:21:22 <solrize> x = y * z
02:22:17 <solrize> like, predicate logic over the natural numbers is undecidable (goedel's theorem)
02:22:34 <solrize> but if you only have addition and not multiplication (presberger arithmetic) then it's decidable
02:22:56 <solrize> but that's without higher order functions
02:23:11 <solrize> i guess you can define multiplication in terms of addition and hof's
02:23:17 <solrize> so it's still undecidable
02:24:13 <solrize> hmm actually you can do it with recursion in the totally obvious way
02:24:32 <mmorrow> solrize: hmm. i'm not sure exactly how you mean (and i'm just learning about dependent types), but i think you have the /option/ of having types depend on having rather than it being /required/
02:24:51 <Myoma> mmorrow:  Using Coq ?
02:24:52 <mmorrow> *depend on values rather than ...
02:25:12 <solrize> well the idea is you actually want to use that feature :)
02:25:14 <mmorrow> Myoma: oh, i wasn't talking about any lang in partic
02:25:31 <mmorrow> solrize: so you're saying you cannot do 5*2
02:25:33 <mmorrow> ?":
02:25:33 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
02:25:52 <solrize> you can do 5*x because that's just x+x+x+x+x
02:25:55 <solrize> you can't do x*y
02:26:02 <mmorrow> hmm
02:26:17 <solrize> but, cayenne has general recursion
02:26:24 <mmorrow> yeah
02:26:43 <solrize> so you can say product x y = (product (x-1) y) + y
02:26:49 <mmorrow> still though, i'm amazed that the types /always/ depend on the values
02:27:18 <solrize> i've never understood how recursion is done in predicate calculus, i should figure it out
02:27:19 <Myoma> that's structural recursion
02:27:25 <mmorrow> i guess i'm just not understanding something here
02:27:41 <mmorrow> anywho, almost done cabalifying cayenne!1 :)
02:28:43 <solrize> i have the impression you can write most programs in decidable fragments of arithmetic
02:28:44 <dons> next, cabalise epigram and agda
02:29:01 <dons> more foods for hackage. nom nom nom
02:29:06 <mmorrow> dons: i'll add those to the list :)
02:29:27 <solrize> cayenne compiles to an ML dialect?
02:29:31 <Myoma> write  some useful programs in Agda and cabalize it
02:29:35 <solrize> so that also has to be cabalized
02:29:38 <mmorrow> it'll compile to haskell!
02:29:42 <mmorrow> or lazy ml
02:29:44 <solrize> oh neat!  i didn't know that
02:29:44 <mmorrow> or agda
02:29:50 <solrize> i just looked at the paper about it, which said lml
02:30:21 <mmorrow> the compiling to haskell part is what got me excited about it
02:30:31 <solrize> did you read "the power of pi"?
02:30:44 <mmorrow> ok, the last thing i have to figure out is this:
02:30:54 <mmorrow> so in Main there's
02:30:56 <mmorrow> dfltCayenneDir = "/usr/local/lib/cayenne"
02:31:07 <mmorrow> how do i handle this under cabal?
02:31:11 <mmorrow> (@anyone)
02:32:29 <mmorrow> solrize: i don't think i've read that
02:32:40 <solrize> http://www.cs.nott.ac.uk/~wss/Publications/ThePowerOfPi.pdf
02:32:44 <lambdabot> Title: The Power of Pi
02:33:33 <[Head|Rest]> http://www.pornorip.net
02:33:34 <solrize> i really want to try that stuff someday but i'm kind of in the slow lane
02:33:47 <|Steve|> [Head|Rest]: Fan of prolog?
02:33:55 <[Head|Rest]> no
02:33:59 <Myoma> solrize: Try what ?
02:34:03 <[Head|Rest]> nya =^.^=
02:34:07 <Myoma> [Head|Rest]: You are valid Prolog
02:34:16 <solrize> myoma, dependent typed programming
02:34:23 <solrize> like in the power of pi paper
02:34:53 <Myoma> solrize: Is there any actual programs you want to write in a dependently typed setting?
02:35:24 <solrize> i thought the database example in that paper was pretty convincing
02:36:28 <solrize> swerdlykov (i forget how he spelled that) had a web template language with dependent types
02:36:52 <Myoma> yeah, he's doing it in SML
02:37:04 <Myoma> (which isn't dependently typed)
02:37:17 <solrize> hee
02:38:00 <solrize> cryptographic protocols are another example but i don't actually know how well the ideas apply
02:38:22 <Myoma> I was wondering what sort of stuff a compiler could do
02:38:53 <solrize> something like gadt's on steroids?
02:39:23 <Myoma> trying to find this thing again ..
02:39:54 <Myoma> yeah ATS
02:40:17 <Myoma> it's supposed to be faster than C
02:40:24 <solrize> ATS?
02:40:36 <Myoma> I'm curious if they get that efficiency from being strongly typed
02:40:52 <Myoma> this one http://www.cs.bu.edu/~hwxi/ATS/ATS.html
02:40:52 <lambdabot> Title: Home Page for ATS
02:41:40 <solrize> wow, this looks neat
02:42:42 <solrize> ml-ish syntax :(
02:48:31 <guenni> good morning everyone
02:48:43 <solrize> heh, they've got an implementation with unboxed ints.  i wonder if it checks for overflow.
02:49:07 <guenni> has anybody here been using polyparse?
02:49:19 <Myoma> solrize: yeah that's the sort of thing I guess that you can avoid having runtime checks for
02:49:28 <matthew-_> guenni: Yes!
02:49:45 <matthew-_> guenni: I use polyparse quite a lot. personally I prefer it to parsec
02:50:37 <guenni> matthew-_: great, could you paste some simple examples, cause I can't figure out how to even get started, I managed to use Parsec to use though
02:50:54 <matthew-_> guenni: so parsec has a richer basic library of combinators
02:51:08 <matthew-_> guenni: I suggest you look at the code to my graphviz package. eg http://hackage.haskell.org/packages/archive/graphviz/2008.7.11/doc/html/src/Data-GraphViz-ParserCombinators.html
02:51:14 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6corst
02:51:23 <guenni> matthew-_: thx
02:51:29 <hackage> Uploaded to hackage: benchpress 0.2.2.1
02:51:58 <matthew-_> guenni: and there are some more examples in http://hackage.haskell.org/packages/archive/graphviz/2008.7.11/doc/html/src/Data-GraphViz.html
02:52:00 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/69lnq9
02:52:18 <matthew-_> it's basically the same as parsec
02:52:34 <guenni> matthew-_: thx
02:52:59 <astrolabe> matthew-_: What does your grapviz package do?
02:53:23 <Heffalump> ooh, that looks handy (the graphviz package)
02:53:39 <matthew-_> astrolabe: takes a data.graph.inductive. Pushes it to dot format, runs it through dot, reads the positional info back and annotates the original graph with it
02:53:59 <matthew-_> it could easily extended and made more robust
02:54:01 <Heffalump> oh, hmm
02:54:07 <matthew-_> just a distinct lack of time right now
02:54:37 <matthew-_> err, you don't have to do the "read it back..." bit - you can just push straight to dot and generate, eg, png for it
02:54:57 <astrolabe> Interesting.  Thanks.
02:55:02 <guenni> say matthew-_ do you use it anywhere for interleaved 2 stage parsing?, I need to write a parser that identifies cell values from a csv file and the parses them again into a more complicated structure
02:55:37 <matthew-_> guenni: no, I've not done something like that, but I wouldn't have thought it would be too bad
02:56:07 <matthew-_> the first step would be to identify the cells, so you just need something that can understand quoted contents and escaped commas right?
02:56:17 <guenni> bingo
02:56:41 <guenni> which was easy to do with parsec
02:56:51 <guenni> but the problem was the second stage
02:57:28 <guenni> ie once I'd have the string value of the cell, I'd still need to turn it into something else
02:58:12 <guenni> and I also wanted that interleaved, ie not one stage entirely finished with the input but sort of streaming ..
02:59:37 <matthew-_> guenni: so the reason I like polyparse is that you can do lazy parsing, which is what you seem to be describing
03:00:14 <guenni> well one might be able to do all that with parsec too, I just can't figure out how
03:02:46 <Baughn> guenni: That's where laziness helps. If you have parsec return a stream, you can then parse that stream lazily
03:04:19 <guenni> well I would have wanted either parsec or polyparse to extract the string value from the csv cell, take that value parse it again into a more specific value rinse, repeat, row done, and so on
03:05:29 <guenni> now to get parsec for instance to extract the string value from the cell isn't difficult at all, but applying a second parser right after that was the problem
03:05:39 <guenni> I couldn't figure out how
03:06:10 <thatsright> how come there is no enumFromTo (..) for Bytestrings?
03:06:33 <Baughn> thatsright: How would you enumerate them? Diagonalization?
03:06:41 <Baughn> It'd work in theory, sure, but I'm not sure about the utility
03:07:04 <guenni> matthew-_: still there?
03:07:07 <sioraiocht> Baughn: I think he means like, Char -> Char -> ByteString
03:07:23 <Baughn> sioraiocht: That's pack . enumFromTo
03:07:38 <sioraiocht> except it involves creating a list, then
03:07:48 <Myoma> is the list really created
03:07:55 <Baughn> sioraiocht: Perhaps
03:07:57 <Myoma> pack ['a'..'z'] may get compilied ?
03:08:08 <sioraiocht> Myoma: yes
03:08:10 <Baughn> It might, yes. Depends on the optimizer
03:08:20 <Baughn> Even pack [a..z] might get optimized to take out the list
03:08:30 <sioraiocht> Baughn: how is it going to do that?
03:08:38 <EvilTerran> sioraiocht, with supero!
03:08:38 <sioraiocht> 'pack' is not fusible
03:08:53 <Baughn> sioraiocht: With fusion. A pity, then
03:10:48 <matthew-_> guenni: yes, sorry
03:11:42 <EvilTerran> guenni, you could do something with setInput
03:12:04 <EvilTerran> that's intended for doing includes and whatnot
03:12:26 <thatsright> does lambdabot do bytestrings?
03:12:42 <EvilTerran> ?type pack
03:12:43 <lambdabot> Not in scope: `pack'
03:12:55 <thatsright> ?type BS.pack
03:12:57 <lambdabot> [Word8] -> BSC.ByteString
03:13:08 <EvilTerran> > BS.pack "test"
03:13:09 <lambdabot>   Couldn't match expected type `Word8' against inferred type `Char'
03:13:14 <EvilTerran> er
03:13:21 <EvilTerran> > BS.pack $ map (toEnum.fromEnum) "test"
03:13:22 <lambdabot>   mueval: Prelude.read: no parse
03:13:29 <Baughn> > BSC.pack "test"
03:13:30 <lambdabot>   mueval: Prelude.read: no parse
03:13:52 <Baughn> ...this needs to get fixed, soon.
03:13:54 <thatsright> > BS.last (BS.pack $ enumFromTo 1 1000)
03:13:55 <lambdabot>   mueval: Prelude.read: no parse
03:13:58 <matthew-_> guenni: you want something like this for reading the cells, though obviously fix it for csv: http://hpaste.org/10158
03:14:11 <matthew-_> but I believe it handles quoting and escaping correctly
03:14:31 <matthew-_> err, that also uses the extra combinators from the graphviz package
03:15:10 <thatsright> Ôªø> BS.last (BS.pack $ enumFromTo 1 1000
03:15:20 <matthew-_> @seen FunctorSalad
03:15:21 <lambdabot> I saw FunctorSalad leaving #haskell-blah and #haskell 5h 43m 59s ago, and .
03:15:34 <thatsright> Ôªø> BS.last (BS.pack $ enumFromTo 1 100)
03:15:43 <thatsright> Ôªø> 1
03:16:21 <thatsright> Ôªø > 1
03:16:26 <thatsright> :(
03:16:47 <Baughn> thatsright: You killed \bot.
03:16:54 <guenni> matthew-_: thx
03:17:27 <matthew-_> guenni: oops, that first line should be readString = oneOf [quoted, nonquoted]
03:17:38 <guenni> EvilTerran: not sure what you mean with setInout
03:18:22 <guenni> matthew-_: does readString then deliver a string value that I can parse again?
03:18:56 <guenni> matthew-_: to turn it into a date for instance, or whatever?
03:19:17 <matthew-_> guenni: yeah, you could do that
03:19:43 <guenni> matthew-_: cool, that's exactly what I need then
03:23:46 <EvilTerran> guenni, i mean to feed the [String] result of a parser into more parsing
03:24:36 <thatsright> is there a fast [1..1000000] for arrays?
03:34:46 <Myoma> > [1..1000000]
03:34:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:38:25 <guenni> EvilTerran: sry, about setInput, is that from parsec?
03:38:50 <dbbddbdb> Hi!  Where do I make feature requests for Hoogle?
03:38:59 <EvilTerran> guenni, yes
03:39:00 <mmorrow> > let a = listArray (0,999::Int) [(1::Int)..1000] :: Array Int Int
03:39:00 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:39:07 <mmorrow> ugh
03:39:23 <Baughn> listArray is unsafe now?
03:39:28 <Myoma> > listArray
03:39:28 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:39:32 <EvilTerran> guenni, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#setInput
03:39:32 <Myoma> > array
03:39:35 <matthew-_> guenni: yeah, setInput and getInput are from parsec
03:39:36 <mmorrow> dbbbdbdbd: probably to the author :)
03:39:40 <lambdabot> Title: Parsec, a fast combinator parser
03:39:40 <lambdabot>       Overlapping instances for Show ((i, i) -> [(i, e)] -> Array i e)
03:39:40 <lambdabot>       ...
03:39:45 <matthew-_> they're slightly evil imho
03:39:48 <Myoma> > list
03:39:49 <lambdabot>   mueval: Prelude.read: no parse
03:39:52 <Myoma> > listA
03:39:53 <lambdabot>   mueval: Prelude.read: no parse
03:39:57 <Myoma> wha t???
03:40:12 <Baughn> > Array
03:40:12 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:40:14 <mmorrow> > unsafeCoerce########3
03:40:14 <lambdabot>   mueval: Unsafe functions to use mentioned.
03:40:45 <Myoma> how odd :S
03:41:07 <dbbddbdb> Oh, right, it has contacts on the first page
03:44:49 <mornfall> How do I run an external program and get its output in a String?
03:44:51 <mornfall> Pretty please...
03:45:16 <mornfall> System.Process seems aww so complex to do that simple thing.
03:45:29 <Baughn> mornfall: hGetContents is your friend
03:46:21 <mornfall> Hm.
03:46:26 <Myoma> Prelude System.IO System.Process> System.Process.readProcess "/bin/date" [] ""
03:46:27 <Myoma> "Sat  6 Sep 2008 11:46:21 BST\n"
03:46:27 <mornfall> Let's try.
03:46:38 <Myoma> seems pretty easy
03:46:39 <mornfall> Myoma: Even better. Danke sch√∂n.
03:47:26 <mornfall> Myoma: GHC docs don't have it on System.Process, that's why I haven't noticed. (looking at http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html)
03:47:28 <lambdabot> Title: System.Process, http://tinyurl.com/2uqkc5
03:47:33 <mornfall> Maybe it's the wrong place?
03:48:09 <mornfall> Myoma: Not in scope...?
03:48:11 <mornfall> Duh.
03:48:23 <mornfall> Prelude System.Process System.IO> System.Process.readProcess
03:48:27 <mornfall> <interactive>:1:0: Not in scope: `System.Process.readProcess'
03:48:28 <trofi> @hoogle String -> IO (a,b,c)
03:48:29 <lambdabot> Control.Monad.RWS.Lazy runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
03:48:29 <lambdabot> Control.Monad.RWS.Strict runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
03:48:29 <lambdabot> Control.Monad.RWS.Lazy runRWS :: RWS r w s a -> r -> s -> (a, s, w)
03:48:35 <trofi> @hoogle run :: String -> IO (a,b,c)
03:48:36 <lambdabot> Control.Monad.RWS.Lazy runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
03:48:36 <lambdabot> Control.Monad.RWS.Strict runRWST :: RWST r w s m a -> r -> s -> m (a, s, w)
03:48:36 <lambdabot> Control.Monad.RWS.Lazy runRWS :: RWS r w s a -> r -> s -> (a, s, w)
03:48:55 <mmorrow> guenni: this csv parser will handle an infinitely long csv file in constant mem: http://hpaste.org/10159
03:50:26 <mmorrow> Myoma: (that's from the new System.Process)
03:50:37 <mmorrow> ((i think))
03:51:16 <guenni> mmorrow: thx, but, the getting the csv file to [[String]] isn't really the problem, it's getting it into [SomeRecord] that is ...
03:51:29 <hackage> Uploaded to hackage: graphviz 2008.9.6
03:51:31 <mmorrow> just map your parser over the [[String]]
03:52:49 <guenni> I could but I have a hunch that there may be trouble this way ....
03:52:52 <mxc> hello everyone
03:53:06 <mxc> having a bit of trouble with library versions, getting this error:  Couldn't match expected type `BS.ByteString' against inferred type `bytestring-0.9.0.1
03:53:06 <mxc> .1:Data.ByteString.Internal.ByteString' In the expression:
03:53:08 <mmorrow> (and that really is the fastest csv parser i've seen, and i use it daily on monstrous csvs)
03:53:25 <mmorrow> (fastest for strings that is. i also have a bytestring version if you're interested)
03:53:35 <Baughn> mxc: Typically the result of mixing libraries that are compiled against different versions of bytestring
03:53:48 <mxc> baughn - right
03:53:58 <Baughn> mxc: Solution: recompile everything that depends on bytestring
03:54:05 <mxc> baughn - my question is, is there an easy wayto basically have cabal recompile everything?
03:54:13 <mxc> or do i have to do each pacakge individually?
03:54:21 <Baughn> mxc: cabal-install
03:54:44 <Baughn> mxc: It doesn't literally have a "recompile everything" command, but it takes very little work with sed and ghc-pkg to build a command line that does that
03:54:52 <Baughn> Though you might have to delete ~/.ghc first
03:54:57 <mxc> baughn - fair enough
03:55:01 <mxc> thanks
03:55:43 <ivanm> @tell dons the email for the author of hstats doesn't seem to work :s
03:55:44 <lambdabot> Consider it noted.
03:56:23 <mmorrow> guenni: the bytestring one does 205271 in 2.182s
03:56:33 <mmorrow> (lines)
03:56:45 <guenni> mmorrow: that's impressive
03:56:55 <mmorrow> i'll paste the bytestring one
03:57:03 <mmorrow> (i really should upload it to hackage)
04:02:28 <mmorrow> guenni: http://hpaste.org/10159#a1
04:04:20 <guenni> mmorrow: and thx again
04:04:59 <mmorrow> guenni: no problemo
04:05:34 <chrisdone> http://www.reddit.com/r/programming/comments/6zskp/haskell_scala_java_7_functional_java_java/c05bffe
04:05:37 <chrisdone> lulz challenge
04:05:37 <lambdabot> Title: redditnoob comments on Haskell > Scala > (Java 7 Functional Java) > Java, http://tinyurl.com/5fml8n
04:07:14 <mmorrow> chrisdone: lol
04:07:32 <ivanm> chrisdone: he's got a point though
04:07:46 <ivanm> using a simple contrived example doesn't prove haskell > java (even though it is!)
04:08:31 <chrisdone> ivanm: I know, the blog post was silly, but dude, space invaders challenge from a java programmer
04:09:11 <chrisdone> I hope he actually replies. this could be fun
04:09:14 <tusho> http://blog.tmorris.net/haskell-scala-java-7-functional-java-java/ that haskell code is awful
04:09:18 <ivanm> how do we know he's a java programmer?
04:09:22 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª Haskell > Scala > (Java 7 Functional Java ..., http://tinyurl.com/69qjjf
04:09:24 <tusho> it's ... completely opaque
04:09:31 <ivanm> tusho: there's better code in a comment
04:09:34 <tusho> ivanm: yeah
04:09:36 <tusho> but seriously
04:09:39 <chrisdone> ivanm: I hope he's a java programmer, anyway
04:09:40 <tusho> it's just a bunch of words and symbols
04:09:50 <conal> i'd like to make a mailing list on haskell.org for Reactive (a FRP library).  does anyone know how to get permission, as mentioned on http://haskell.org/mailman/admin ?
04:09:50 <tusho> it looks like what you'd write when stereotyping haskell
04:09:51 <lambdabot> Title: haskell.org mailing lists - Admin Links
04:09:53 <ivanm> is the blog author a haskell programmer?
04:09:54 <chrisdone> ivanm: he said "let's", which I presumed meant "you write some haskell, I'll write some java"
04:10:01 <ivanm> chrisdone: heh
04:10:08 <tusho> he is a scala
04:10:10 <tusho> programmer
04:10:15 <tusho> i remember from his previous posts
04:10:30 <tusho> my god
04:10:32 * chrisdone gulps
04:10:33 <tusho> that functional java...
04:10:35 <chrisdone> a s-s-scala programmer?
04:10:36 <tusho> jesus christ
04:10:40 <chrisdone> I.. I take it back!
04:10:44 <tusho> this guy is like ... the master of writing code that looks like a joke
04:10:47 <ivanm> chrisdone: in what way?
04:10:56 <chrisdone> ivanm: just joking
04:11:03 <tusho> well, bloody hell
04:11:03 <ivanm> heh
04:11:09 <ivanm> btw, does anyone know of a link on the Data.Map-based method of memoisation? Not that I want the memoisation aspects per-se, but can't quite recall how its done
04:11:11 <tusho> every single one of those programs are terrible, unreadable piles of crap
04:11:30 <chrisdone> tusho: uh, the Parsec one is, uh, amazingly beautiful?
04:11:38 <tusho> chrisdone: that's not in the article
04:11:42 <tusho> just the comments
04:11:46 <chrisdone> oh, screw the article
04:12:47 <tusho> [[So er thanks for all the comments everybody. There are no doubt more elegant solutions to this problem (heck, the existence of Parsec - QED). However, the ‚Äúthesis‚Äù (Bob) is to observe compositional aspects of the programs.]]
04:12:50 <tusho> lulz
04:13:14 <matthew-_> right, has anyone written any papers about errors in dependently typed languages?
04:13:26 <tusho> "Who else would submit the charge of amateurism (armaturism?) for variable names, but a self-proclaimed ‚ÄúJava Programmer‚Äù. tehe, how amusing :)" <-- Gee, the author is an ass as well!
04:14:04 <chrisdone> tusho: it's amusing that you think that :)
04:14:18 <tusho> chrisdone: i am a lovely, fluffy hypocrite
04:14:19 <Cale> What happens when you mess up the script that replaces profanity on your news site: http://www.barossa-region.org/Australia/CHRISTIAN-PASTOR-ARRESTED-AGAIN-FOR-loveUAL-buttAULT--DRUGS.html
04:14:20 <tusho> :D
04:14:29 <lambdabot> Title: CHRISTIAN PASTOR ARRESTED AGAIN FOR loveUAL buttAULT, DRUGS, http://tinyurl.com/64wuuo
04:14:37 <mmorrow> haha
04:14:42 <tusho> Cale: Needs more clbuttic or buttbuttination
04:14:46 <chrisdone> I lol'd
04:14:51 <tusho> http://www.google.co.uk/search?q=buttbuttination&ie=utf-8&oe=utf-8&aq=t&rls=org.mozilla:en-GB:official&client=firefox-a
04:14:52 <lambdabot> Title: buttbuttination - Google Search, http://tinyurl.com/5c4fn3
04:14:55 <tusho> and conbreatution
04:15:02 <mmorrow> ivanm: do you mean to one with an IORef/unsafePerformIO/Data.Map ?
04:15:03 <Cale> "Hornbuckle, 43, is accused of loveually buttaulting five parishioners of Agape Christian Fellowship in Arlington, where he serves as senior pastor."
04:15:15 <chrisdone> "automatic..." "butt.", "flourescent..." "butt."
04:15:31 <tusho> lovetuple
04:15:43 <chrisdone> Cale: hahaha
04:15:43 <ivanm> mmorrow: I seem to recall one with just Data.Map and no IO, safe or unsafe
04:15:54 <mmorrow> oh, i dunno then
04:16:14 <chrisdone> arrested on two counts of buttaulting
04:16:30 * chrisdone writes that word on his whiteboard
04:16:33 <zachk> whats buttaulting
04:16:36 <ivanm> this seems to be almost it... http://www.haskell.org/pipermail/haskell-cafe/2005-October/011601.html
04:16:38 <lambdabot> Title: [Haskell-cafe] Memoization, http://tinyurl.com/5695kh
04:16:40 <tusho> zachk: a clbuttic mistake
04:16:45 <ivanm> zachk: s/butt/ass/
04:16:53 <tusho> ivanm: s/butt/butt/? Wtf?
04:17:01 <zachk> is that like holding down Alt and pressing the Butt key on ones keyboard?
04:17:05 <zachk> Alt+Butt
04:17:08 <ivanm> tusho: heh
04:17:22 <tusho> zachk: you have a butt key on your keyboard?
04:17:47 * ivanm wonders if tusho is joking or actually has dodgy filtering software installed in his IRC client... :s
04:17:55 <zachk> i should just rebind caplocks to it
04:17:58 <tusho> ivanm: Hm?
04:18:08 <zachk> maybe its holding down the alt key with ones butt
04:18:19 <tusho> ivanm: (yes, i'm joking)
04:18:20 <tusho> :P
04:18:21 <zachk> though that would have to be large a butt key for my keyboard
04:18:23 <ivanm> *phew*
04:18:29 <ivanm> tusho: took you a while ;-)
04:18:39 <tusho> ivanm: i was waiting for you to act shocked when i denied it
04:18:49 <tusho> but you didn't say anything, so.
04:19:02 <ivanm> heh
04:19:42 <chrisdone> black persondly
04:20:05 <zachk> @faq can haskell help me translate haskell source, using only a subset of haskell as the input source, into Java for my comp sci proffesor?
04:20:05 <lambdabot> The answer is: Yes! Haskell can do that.
04:20:10 <zachk> sweet
04:20:10 <ivanm> mmorrow: what I was wanting it for was a lazy way of defining a whole bunch of (f n) values which are all independent on each other... I _could_ define them all myself when required and insert them into a map or something myself, but the memoization-way seems to simplify it
04:20:15 <tusho> safrican-american
04:20:31 <ivanm> zachk: sure, you just need to write a Data.Java library first
04:20:37 <zachk> safarican
04:21:31 * tusho is going to say *safrican-americans* instead of *sniggers* from now on
04:21:45 <Baughn> zachk: I believe there's a haskell-to-JVM compiler somewhere.. but I suppose you meant source-to-source
04:22:14 <zachk> yea source to source, i need to hand in source and i need it to look like human generated code
04:22:18 <Baughn> There's also a CL-to-java compiler somewhere, which I suppose is better than nothing
04:22:38 <Baughn> zachk: You might consider just using java. It's, er, educational. ^^;
04:22:39 <qwr> Baughn: it would be fun try java decompilers on the generated bytecode ;)
04:22:51 <zachk> what im doing would be more educational
04:23:01 <Baughn> True. If you actually write a compiler..
04:23:14 <Baughn> qwr: I have a feeling it would be unreadable
04:23:22 <tusho> zachk: fairly impossible :P
04:23:23 <zachk> its just a conjecture atm, though I am writing my java programs in haskell first
04:23:29 <zachk> i said subset of haskell
04:23:31 <mmorrow> ivanm: hmm, i just searched for the okasaki reference in that post, but didn't find it. i use this one sometimes for super expensive functions: http://moonpatio.com/blog/
04:23:32 <tusho> but er ... it's not hard to write java, you know
04:23:36 <lambdabot> Title: moonpatio
04:23:38 <qwr> Baughn: probably :)
04:23:39 <tusho> just tedious
04:23:39 <zachk> its just annoying
04:23:48 <Baughn> zachk: The laziness would be your greatest problem
04:24:02 <Baughn> zachk: For one thing, to look human-generated, you need a really good strictness analyzer
04:24:18 <zachk> Baughn: strictness analyzer?
04:24:30 <tusho> zachk: um...
04:24:36 <tusho> Yea... don't bother.
04:24:43 <ivanm> mmorrow: looks a bit more complicated than I need ;-)
04:24:46 <Baughn> zachk: ..if you don't already know what that is...
04:24:52 <tusho> Baughn: exactly my point ;-)
04:25:09 <Baughn> zachk: Um, you might be able to write a compiler, but the output most definitely will /not/ look human-generated. Or be readable.
04:25:12 <ivanm> M.fromList [(n,f n) | n <- [min..max]) is what I need, since I won't be using all values of n defined
04:25:15 <ivanm> laziness ftw!
04:25:20 <mmorrow> ivanm: if that were in a module, all it would export is
04:25:22 <mmorrow> memo :: (Ord a) => (a -> b) -> (a -> b)
04:25:31 <mmorrow> that's failry simple
04:25:36 <mmorrow> *fairly
04:25:53 <ivanm> well, I don't want to memoize the function
04:26:08 <ivanm> I just want to be able to get the result of (f n) for a given value of n
04:26:14 <mmorrow> yeah, just thought i'd give you the link in case
04:27:23 <mmorrow> ivanm: hmm, so memo makes an IORef containing a Data.Map, and anytime you call the function on a value it's already seen, it just looks it up in the map
04:27:26 <conal> there are also trie-based memo functions: http://haskell.org/haskellwiki/MemoTrie
04:27:27 <lambdabot> Title: MemoTrie - HaskellWiki
04:27:44 <dcoutts_> mxc: the latest version of cabal-install has a --reinstall flag, so you could "cabal install foo bar baz --reinstall"
04:27:53 <mxc> cool
04:27:54 <mxc> thanks
04:29:21 <ivanm> mornfall: O RLY? :o
04:29:44 <mornfall> ivanm: Duh?
04:30:19 <ivanm> sorry, meant mmorrow
04:30:25 <ivanm> blame dodgy autocomplete in xchat :p
04:30:55 <mmorrow> ivanm: Duh
04:31:14 <ivanm> heh
04:31:30 <EvilTerran> ivanm, /set completion_sort 1?
04:31:50 <ivanm> EvilTerran: which does?
04:32:05 <EvilTerran> sorts the tab completion by who spoke most recently instead of alphabetical
04:32:12 <ivanm> ahhh
04:32:30 <ivanm> no, I think the problem was that I did m-o-r-<tab> instead of m-m-o-r-<tab>
04:32:33 <EvilTerran> ah
04:32:53 <ivanm> since I already had that setting enabled via the gui ;-)
04:33:16 <EvilTerran> there's a gui setting for it?
04:33:20 <ivanm> mmorrow: so what, I then have "f' = memo f", then just use f' instead of f?
04:33:35 <EvilTerran> ah, so there is, that's easier :)
04:33:51 <mmorrow> ivanm: exactly
04:34:07 <ivanm> in that case... ;-)
04:37:47 <mmorrow> conal: that MemoTrie module is pretty cool
04:41:11 <ivanm> in a do-block, can items in the same let statement reference each other? (e.g. let a = 1;b = a + 1)
04:41:25 <mmorrow> yes
04:41:48 <Baughn> > do let {a = 1; b = a + 1}; [a]
04:41:50 <mornfall> Is there a generic version (with a predicate, say) of words/lines?
04:41:50 <lambdabot>   [1]
04:42:05 <mornfall> @hoogle (a -> Bool) -> [a] -> [[a]]
04:42:06 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
04:42:06 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
04:42:06 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
04:42:13 <Botje> @src words
04:42:13 <lambdabot> words s = case dropWhile isSpace s of
04:42:14 <lambdabot>     "" -> []
04:42:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:42:20 <Botje> you can generalize that, i think
04:42:42 <Baughn> mornfall: Not yet, though I believe someone is sticking one in ghc 6.9
04:42:51 <Baughn> At least, I hope so. Now, who was that again..?
04:43:02 <mmorrow> > let split p = uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "127.0.0.1"
04:43:03 <lambdabot>   ["127","0","0","1","","","","","","","","","","","","","","","","","","",""...
04:43:13 <mmorrow> > let split p = takeWhile (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "127.0.0.1"
04:43:14 <lambdabot>   ["127","0","0","1"]
04:43:37 <mornfall> mmorrow: Ahw.
04:43:53 <mmorrow> i just had to rewrite that about 10 times over the last week and it finally stuck
04:43:57 <mmorrow> :)
04:43:59 <mornfall> mmorrow: It's also wrong, since ".." would break it.
04:44:14 <mornfall> IIUIC.
04:44:16 <mmorrow> > words "              "
04:44:18 <lambdabot>   []
04:44:25 <mornfall> > words "a  b"
04:44:27 <lambdabot>   ["a","b"]
04:44:39 <mmorrow> > let split p = takeWhile (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "......."
04:44:40 <lambdabot>   []
04:44:57 <mornfall> > let split p = takeWhile (not . null)  . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split "a..b"
04:44:58 <lambdabot>   Couldn't match expected type `a -> Bool'
04:45:02 <mornfall> Bwah.
04:45:04 <mmorrow> > let split p = takeWhile (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (==' ') "      "
04:45:06 <lambdabot>   []
04:45:15 <mmorrow> > let split p = takeWhile (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "a..b"
04:45:16 <mornfall> > let split p = takeWhile (not . null)  . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "a..b"
04:45:17 <lambdabot>   ["a"]
04:45:18 <lambdabot>  Terminated
04:45:24 <mornfall> Right. See the bug? :)
04:45:27 <mmorrow> hmm
04:45:31 <conal> mmorrow: thx.  i like it, too.
04:46:01 <mornfall> mmorrow: The initial takeWhile is the problem.
04:46:18 <mmorrow> i still don't see it
04:46:33 <mmorrow> > let split p = take 10 . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "a..b"
04:46:34 <lambdabot>   ["a","","b","","","","","","",""]
04:46:40 <mmorrow> ahh
04:46:42 <mornfall> mmorrow: takeWhile (not . null)
04:46:58 <mmorrow> > let split p = takeWhile (not . null) . filter (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) in split (=='.') "a..b"
04:47:01 <lambdabot>   mueval: Prelude.read: no parse
04:47:01 <lambdabot>  mueval: ["a","b"*** Exception: stack overflow
04:47:06 <mornfall> Oopsla.
04:47:07 <mornfall> : - )
04:47:08 <mmorrow> oop
04:48:03 <mmorrow> whytf did that stack overflow??!
04:48:27 <mmorrow> oh, yeah
04:51:51 <mmorrow> ok got it
04:52:03 <mmorrow> > let split _ [] = [] ; split p xs = filter (not . null) . uncurry (:) . fmap (split p . drop 1) . span (not . p) $ xs in split (=='.') "a.........b....."
04:52:05 <lambdabot>   ["a","b"]
04:52:57 <mmorrow> @let list n c [] = n ; list n c xs = c xs
04:52:59 <lambdabot>  Defined.
04:54:30 <mmorrow> > let split p = filter (not . null) . uncurry (:) . fmap (list (const []) (split p) . drop 1) . span (not . p) in split (=='.') "a.........b....."
04:54:31 <lambdabot>   Couldn't match expected type `[[a]]'
04:54:34 <Myoma> why nto c (x:xs) = c x xs ?
04:54:49 <Myoma> :t split
04:54:51 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
04:54:54 <mmorrow> they're iso
04:55:11 <Myoma> :t (split .) . (:)
04:55:12 <lambdabot> forall a. (RandomGen [a]) => a -> [a] -> ([a], [a])
04:56:42 <mmorrow> @type \f -> (\x -> (\xs -> f (x:xs)))
04:56:44 <lambdabot> forall a t. ([a] -> t) -> a -> [a] -> t
04:56:59 <mmorrow> @type \f -> (\(x:xs) -> f x xs)
04:57:01 <lambdabot> forall t t1. (t -> [t] -> t1) -> [t] -> t1
04:57:22 <Myoma> :t \f -> (f .) . (:)
04:57:24 <lambdabot> forall c a. ([a] -> c) -> a -> [a] -> c
04:57:41 <Myoma> :t \f -> (uncurry f) . (head &&& tail)
04:57:42 <lambdabot> forall c a. (a -> [a] -> c) -> [a] -> c
04:57:45 <mmorrow> :)
04:57:58 <mornfall> Hm. case ... of is not allowed within a let?
04:58:26 <mmorrow> it has to be in an expression...
04:58:39 <mornfall> case of is not an expression?
04:58:42 <mmorrow> > let _ = case 0 of _ -> 1 in ()
04:58:43 <lambdabot>   ()
04:58:53 <mmorrow> case /is/ an expression
04:59:06 <mmorrow> but let <decls> in <exp>
04:59:21 <mmorrow> let 0 in 1
04:59:22 <mornfall> Ahw. I meant let in a do...
04:59:23 <mmorrow> > let 0 in 1
04:59:24 <lambdabot>   mueval: Prelude.read: no parse
04:59:28 <mornfall> Sorry for being unclear.
04:59:40 <mmorrow> err, i don't think that'll change anything
05:00:07 <mornfall> > do { let a = case 0 of 0 -> "a"; return a }
05:00:08 <lambdabot>   mueval: Prelude.read: no parse
05:00:19 <mmorrow> hmm
05:00:29 <mornfall> > do { let a = "a"; return a }
05:00:30 <lambdabot>   mueval: Prelude.read: no parse
05:00:32 <mornfall> Ah.
05:00:48 <mmorrow> ah
05:00:57 <mornfall> How'd you feed do ... to lambdabot?
05:01:19 <Myoma> > do { let {a = "a"}; return a }
05:01:20 <lambdabot>       No instance for (Show (t [Char]))
05:01:20 <lambdabot>        arising from a use of `show' a...
05:01:23 <mmorrow> > (do x <- return 2 ; return x) :: [Int]
05:01:24 <lambdabot>   [2]
05:01:27 <mornfall> Ah, right.
05:01:31 <mmorrow> > (do {x <- return 2 ; return x}) :: [Int]
05:01:32 <lambdabot>   [2]
05:01:56 <mornfall> > do { let { a = "a" } ; return a }
05:01:57 <lambdabot>       No instance for (Show (t [Char]))
05:01:57 <lambdabot>        arising from a use of `show' a...
05:02:01 <mmorrow> > (do { let a = "a"; return a})
05:02:03 <mornfall> > do { let { a = case 0 of 0 -> "a" } ; return a }
05:02:03 <lambdabot>   mueval: Prelude.read: no parse
05:02:04 <lambdabot>       No instance for (Show (t [Char]))
05:02:04 <lambdabot>        arising from a use of `show' a...
05:02:12 <Myoma> > do { let {a = "a"}; return a } :: [String]
05:02:13 <lambdabot>   ["a"]
05:02:18 <mmorrow> > (do { let {a = "a"}; return a})
05:02:19 <lambdabot>       No instance for (Show (t [Char]))
05:02:19 <lambdabot>        arising from a use of `show' a...
05:02:29 <mmorrow> > (do { let {a = "a"}; return a}) :: [String]
05:02:31 <lambdabot>   ["a"]
05:03:34 <qwr> > do { let {a = "a"}; return a} :: Maybe String
05:03:35 <lambdabot>   Just "a"
05:03:42 <mornfall> I'm always getting "parse error in pattern".
05:04:08 <mornfall> Lemme paste.
05:04:21 <mmorrow> > do let a = "a"; return a :: [String]
05:04:22 <lambdabot>   mueval: Prelude.read: no parse
05:04:26 <qwr> btw. ghci is also cool ;)
05:04:27 <mmorrow> > (do let a = "a"; return a) :: [String]
05:04:28 <lambdabot>   mueval: Prelude.read: no parse
05:04:40 <Myoma> > do { let {a = "a"} return a } :: [String]
05:04:41 <lambdabot>   mueval: Prelude.read: no parse
05:04:42 <mmorrow> > do {let a = "a"; return a} :: [String]
05:04:43 <lambdabot>   mueval: Prelude.read: no parse
05:04:55 <qwr> { } are required on one-liners... you don't have indention on one line ;)
05:05:17 <mornfall> Lemme paste 3 lines here, can't load hpaste (bad connection here):
05:05:19 <mornfall>        let verStr = currentS ++ case count of
05:05:19 <mornfall>                                   0 -> " (release)"
05:05:19 <mornfall>                                   n -> " (+ " ++ n ++ " patches)"
05:05:23 <mmorrow> > (do x <- return 2 ; return x) :: [Int]
05:05:25 <lambdabot>   [2]
05:05:27 <mornfall> This gives Parse error in pattern...
05:05:40 <Myoma> mornfall: Are you creating lisp
05:05:45 <Myoma> code
05:05:48 <mornfall> Myoma: What?
05:05:54 <Myoma> looks like sexps
05:05:59 <mornfall> D'oh.
05:06:03 <EvilTerran> not all parentheses are sexps
05:06:03 <mornfall> No intent to do that.
05:06:18 <mornfall> There aren't any parens there, really.
05:06:20 <Myoma> mornfall: you must show n
05:06:23 <EvilTerran> this looks like it's a status message or something
05:06:35 <mornfall> Myoma: That's a type error, not paste?
05:06:37 <Myoma> EvilTerran: hence me asking
05:06:42 <mornfall> Not parse, I mean.
05:06:55 <EvilTerran> Myoma, it doesn't seem relevant to the question, anyway
05:06:56 <mornfall> It definitely doesn't help, anyway.
05:07:11 <Myoma> mornfall: You will use code that does not typecheck?
05:07:17 <EvilTerran> mornfall, what's the line and column?
05:07:23 <EvilTerran> Myoma, it's not getting that far
05:07:34 <mmorrow> mornfall: i dont see a problem, i think we need to see the enclosing context
05:07:36 <mornfall> EvilTerran: They are all wrong, I believe.
05:07:39 <EvilTerran> anyway, he could have an instance Num [Char]
05:07:47 <hackage> Uploaded to hackage: maybench 0.2.4.1
05:07:47 <hackage> Uploaded to hackage: graphviz 2008.9.6
05:07:47 <hackage> Uploaded to hackage: benchpress 0.2.2.1
05:07:48 <hackage> Uploaded to hackage: dotgen 0.1.1
05:07:50 <hackage> Uploaded to hackage: xmonad-contrib 0.8
05:07:51 <mornfall> Hpaste loaded, hooray.
05:09:06 <mornfall> http://hpaste.org/10161
05:09:14 <mornfall> It says:
05:09:15 <mornfall> Setup.lhs:168:8: Parse error in pattern
05:09:29 <mornfall> But 168 is:
05:09:32 <qwr> mornfall: http://hpaste.org/10162
05:09:33 <mornfall>        return verStr
05:10:02 <EvilTerran> "parseVersionTag 't':'a':'g':'g':'e':'d':' ':v"
05:10:03 <EvilTerran> is wrong
05:10:20 <EvilTerran> you need parentheses around the parameter
05:10:29 <EvilTerran> that's (parseVersionTag 't'):'a':...
05:10:30 <mornfall> Groan.
05:10:48 <EvilTerran> function application always always ALWAYS binds tighter than any infix operator
05:10:52 <mornfall> EvilTerran: That fixed it. It's just ghc giving wrong line numbers that confused me. : - (
05:11:05 <mornfall> I haven't even looked at that line.
05:11:13 <EvilTerran> maybe ghc's counting from 0
05:11:18 <mornfall> EvilTerran: C'mon.
05:11:25 <EvilTerran> srsly
05:12:00 <mornfall> Okey, thanks again. I've just gotten a similar failure with let in do, so I'd thought it was the culprit.
05:12:02 <EvilTerran> off-by-one error could be the problem
05:12:10 <mornfall> I mean, in the past.
05:12:13 <EvilTerran> that was the only pattern i could see
05:12:20 <EvilTerran> you got "parse error in pattern"
05:12:25 <EvilTerran> i looked for patterns
05:12:57 <mornfall> I somehow matched them against 0, n in the case. But yeah, it now all makes sense.
05:15:08 <mornfall> Now I think that pattern my was other question: is there a way to write in a less hurtful way?
05:15:30 <mornfall> Other than `isPrefixOf` and then drop n, which is at least as bad, IMO.
05:17:10 <olsner> @hoogle dropPrefix
05:17:10 <lambdabot> No results found
05:18:01 <olsner> @hoogle String -> String -> Maybe String
05:18:01 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
05:18:01 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
05:18:01 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
05:18:22 <olsner> > stripPrefix "asdf" "asdf foo"
05:18:23 <lambdabot>   Just " foo"
05:27:02 <zachk> is the module namespace seperate from the type namespace in haskell?
05:28:04 <zachk> or can I have the names of modules match a data constructor ie. module Foo where data Foo=Foo (etc...) ?
05:28:24 <Baughn> That's not an "or". If they're separate, you can do that; if not, not.
05:28:29 <Baughn> And I'm pretty sure they're separate
05:28:33 <zachk> k
05:30:46 <solrize> @hoogle max
05:30:46 <lambdabot> Prelude max :: Ord a => a -> a -> a
05:30:46 <lambdabot> Data.Ord max :: Ord a => a -> a -> a
05:30:46 <lambdabot> Prelude maxBound :: Bounded a => a
05:30:57 <solrize> there's no maxBy?
05:31:05 <solrize> @hoogle maxby
05:31:06 <lambdabot> No results found
05:31:14 <int-e> @type maximumBy
05:31:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
05:31:28 <int-e> maxBy = id
05:31:36 <int-e> hmm.
05:31:41 <olsner> @hoogle (a -> a -> Ordering) -> a -> a -> a
05:31:42 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
05:31:42 <lambdabot> Data.ByteString.Lazy.Internal foldrChunks :: (ByteString -> a -> a) -> a -> ByteString -> a
05:31:42 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
05:31:44 <int-e> sorry, but close
05:33:28 <solrize> maxBy f a b = if (f a) > (f b) then a else b
05:34:38 <olsner> hmm, isn't that maxOn rather than maxBy?
05:35:01 <trofi> head . sortBy
05:35:20 <solrize> :t maxOn
05:35:21 <lambdabot> Not in scope: `maxOn'
05:35:53 <trofi> : max `on` f
05:35:56 <trofi> :t max `on` f
05:35:57 <lambdabot> forall b a. (SimpleReflect.FromExpr b, Show a, Ord b) => a -> a -> b
05:36:12 <solrize> hmm
05:36:13 <trofi> :t max `on` accessor
05:36:13 <solrize> good point
05:36:14 <lambdabot> Not in scope: `accessor'
05:36:23 <int-e> maxBy (?) x y | GT <- x ? y == x | otherwise = y
05:36:36 <ziman> @type max `on` ?fun
05:36:38 <lambdabot> forall b a. (?fun::a -> b, Ord b) => a -> a -> b
05:36:48 <int-e> (GT ==  without pattern guards)
05:40:45 <reified> Hi
05:41:25 <reified> are there any Haskell-specific IDEs except for Leksah and Yi?
05:41:51 <Baughn> reified: Emacs/haskell-mode
05:42:10 <ivanm> yi isn't an IDE...
05:42:41 <reified> Emacs makes my stomach hurt... I'm a vim guy
05:42:56 <ivanm> well, isn't there haskell stuff for vim?
05:42:58 <reified> ivanm: ok, Leksah only?
05:43:28 <ivanm> reified: there were some others that dies
05:43:34 <reified> ivanm: yep, but I was wondering if there is anything written in Haskell, for Haskell development
05:43:43 <ivanm> they were in haskell
05:43:49 <ivanm> @go IDE site:haskell.org
05:43:50 <lambdabot> No Result Found.
05:43:56 <ivanm> @go hIDE site:haskell.org
05:44:04 <lambdabot> http://www.haskell.org/haskellwiki/HIDE
05:44:04 <lambdabot> Title: HIDE - HaskellWiki
05:44:06 <ivanm> hIDE is an old IDE IIRC...
05:44:17 <ertai> reified: Yi is an editor written in Haskell
05:44:45 <reified> ah, hIDE -- "This project is currently orphaned. Creating a decent IDE is still an active research topic and many problems are yet to be resolved "
05:45:22 <Axman6> exit
05:45:53 <ivanm> Axman6: stage left?
05:45:55 <ivanm> ;-)
05:46:52 <Axman6> heh, no, talking my girlfriend through logging me off her comp, she missed the ctrl in the ctrl-a ctrl-d in screen ;)
05:49:12 <reified> guess I'll stick with vim for now
05:49:33 <ivanm> Axman6: heh
05:49:44 <ivanm> reified: there's a python-based IDE that wraps around vim...
05:49:51 <ivanm> pide IIRC...
05:50:04 <reified> ivanm: I heard about something like that
05:50:05 <ivanm> so it basically provides IDE-like features to vim
05:51:49 <reified> found the vim one: "uperior Haskell Interaction Mode (SHIM) : GHCi integration for VIM"
05:52:04 <reified> that's "superior"
05:55:18 <ivanm> I'm getting a segfault in my code! :o
05:55:29 <Axman6> hurrah!
05:55:43 <ivanm> I don't even know where from! :@
05:55:57 <Axman6> i've segfaulted GHCi before, but nothing i've compiled
05:56:06 * ivanm hopes it isn't due to mmorrow's memo library :s
05:56:14 <ivanm> Axman6: no, this is both!
05:56:31 <Axman6> :o
05:56:38 <Baughn> reified: In Emacs lingo, a "superior" program is one that runs within emacs itself, as opposed to inferior ones that run in child processes
05:56:52 <Axman6> but the glorious glasgow haskell compiler is infalible!
05:56:53 <Baughn> reified: This is relevant probably because it's meant to work like SLIME
05:57:23 <ivanm> reified: that's not the vim haskell stuff AFAIK... it just profides extra tools for emacs and vim
05:58:02 <ivanm> reified: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
05:58:03 <lambdabot> Title: Haskell mode for Vim
05:58:12 <ivanm> http://www.vim.org/scripts/script.php?script_id=1968 might also be useful
05:58:23 <lambdabot> Title: indent/haskell.vim - Haskell indent file : vim online
05:58:52 <reified> I was looking at: http://www.vim.org/scripts/script.php?script_id=2356
05:58:52 <lambdabot> Title: Superior Haskell Interaction Mode (SHIM) - GHCi integration for VIM : vim online
05:59:22 <reified> oh, it requires Ruby
05:59:27 <reified> "The script uses Ruby to spawn a GHCi process and communicate with it through pipes"
06:07:57 <Axman6> hurray, deleted my twitter account.
06:08:13 <trofi> what do i need from hackage to play with sqlite databases? sqlite, hsql-sqlite3, hsSqlite3, HDBC-sqlite3 ?
06:14:10 <heyll> hi
06:16:23 <ivanm> I don't suppose it's possible (without type hackery) to have an Array with indices of 10, 20, etc. rather than just 1, 2, etc.?
06:16:47 <chrisdone> buttaults cale
06:17:07 <Beelsebob> ivanm: wrap it in a type that divides all indicies by 10?
06:17:23 <ivanm> Beelsebob: which is what I was implying by type hackery :p
06:17:28 <Beelsebob> ah, okay
06:17:45 <Beelsebob> not an array I don't think, no
06:17:52 <ivanm> didn't think so... I'll just divide/multiply by 10 when doing stuff with it
06:18:04 <Beelsebob> although I can imagine various sparse data structures that would allow that reasonably efficiently
06:18:37 <ivanm> I _could_ use an Map... but an array would probably suit my needs better
06:20:03 <fnord123> when I run cabal update, I get an error "cabal: getHostByName: does not exist (no such host entry)'. any idea what might be the matter? wget works fine from the shell when I get http://hackage.haskell.org/packages/archive
06:20:05 <lambdabot> Title: Index of /packages/archive
06:20:10 <EvilTerran> i find it's better to start with a Map, then profile to see if it's actually slow enough for an Array to be necessary
06:20:28 <EvilTerran> with a bit of cleverness, the change-over should be fairly straightforward, if your algorithm's even suitable for Arrays
06:22:06 <dcoutts> fnord123: it's a dns lookup error
06:22:21 <dcoutts> fnord123: it's possible that your wget is not using a proxy but cabal is
06:22:54 <dcoutts> fnord123: check your $http_proxy or $HTTP_PROXY
06:23:16 <cinimod> @hoogle Data.ByteString.ByteString -> Int
06:23:16 <lambdabot> Parse error:
06:23:16 <lambdabot>   --count=20 "Data.ByteString.ByteString -> Int"
06:23:16 <lambdabot>                  ^
06:23:48 <cinimod> @hoogle ByteString -> Int
06:23:48 <lambdabot> Data.ByteString length :: ByteString -> Int
06:23:48 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
06:23:48 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
06:24:00 <cinimod> @hoogle ByteString -> ByteString
06:24:00 <lambdabot> Data.ByteString copy :: ByteString -> ByteString
06:24:00 <lambdabot> Data.ByteString init :: ByteString -> ByteString
06:24:00 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
06:24:51 <cinimod> Data.ByteString.reverse (Data.ByteString.pack [0xf0])
06:24:56 <cinimod> > Data.ByteString.reverse (Data.ByteString.pack [0xf0])
06:24:57 <lambdabot>   mueval: Unsafe functions to use mentioned.
06:25:21 <fnord123> dcoutts, I did have a problem w/ http_proxy, but I fixed it. the proxy was the one from the library. :) but now that I exported it to be null, I get this new issue.
06:26:00 <fnord123> If wget works fine, It's really surprising that cabal-install would have a dns error
06:27:14 <fnord123> I'll troubleshoot some more. Just thought I should ask in case it rang a bell like 'oh are you using 0.5.2? use some other version; known issue, etc"
06:29:28 <LeoD> is there a function giving me all elements of a list except the last one?
06:29:51 <dcoutts> fnord123: no, no known issues
06:29:56 <ziman> :t init
06:29:58 <lambdabot> forall a. [a] -> [a]
06:30:12 <ziman> > init [1..10]
06:30:13 <lambdabot>   [1,2,3,4,5,6,7,8,9]
06:30:21 <LeoD> nice, thanks
06:30:24 <dcoutts> fnord123: what platform ooi?
06:31:20 <fnord123> In ghci I did :m +Network.BSD and then getHostByName "hackage.haskell.org" and it worked fine
06:31:59 <fnord123> Ubuntu 8.04 here. ghc 6.8.2.
06:33:26 <fnord123> if i have the protocol on the request, it won't find it. (e.g. "http://hackage.haskell.org") so I think it's using the wrong url string
06:33:30 <dmhouse> ?src init
06:33:30 <lambdabot> init [x]    = []
06:33:30 <lambdabot> init (x:xs) = x : init xs
06:33:30 <lambdabot> init []     = undefined
06:33:56 <cinimod> @hoogle Word8 -> Word8
06:33:57 <lambdabot> Prelude abs :: Num a => a -> a
06:33:57 <lambdabot> Prelude negate :: Num a => a -> a
06:33:57 <lambdabot> Prelude signum :: Num a => a -> a
06:34:12 <ivanm> dammit, I need Double to be an instance of Ix :s
06:34:30 <dmhouse> ivanm: just declare one?
06:34:50 <dmhouse> Use a newtype if you're afraid of overlapping instances
06:34:54 <ivanm> @src Ix
06:34:54 <lambdabot> class (Ord a) => Ix a where
06:34:54 <lambdabot>     range           :: (a,a) -> [a]
06:34:54 <lambdabot>     index           :: (a,a) -> a -> Int
06:34:54 <lambdabot>     inRange         :: (a,a) -> a -> Bool
06:34:54 <lambdabot>     rangeSize       :: (a,a) -> Int
06:35:23 <ivanm> dmhouse: I'd have to have knowledge of what the increment is :s
06:35:53 <ivanm> oh well, the only time I'm using it I know what the increment is...
06:36:33 <dmhouse> ivanm: well, of course, use something sensible. How were you hoping to use Doubles to index an array if you don't have a concept of a "next element"
06:36:33 <dmhouse> You could always use a Map
06:36:33 <dmhouse> > 1 + 1
06:36:34 <lambdabot>   2
06:36:47 <dmhouse> Good, I'm still here. (Wireless just died briefly.)
06:37:33 <ivanm> heh
06:38:15 <ivanm> dmhouse: heh, I just switched from using mmorrow's map-based memo module because I kept getting segfaults :s
06:38:25 <dmhouse> Eep.
06:38:32 <dmhouse> mmorrow: shame on you!
06:39:06 <ivanm> then again, considering that I had a memo based on a memo based on a memo... ;-)
06:44:54 <dmhouse> > let go [] (_:xs) = xs; go (_:xs) (y:ys) = y : go xs ys; list = [1..10] in go (tail list) list
06:44:55 <lambdabot>   [1,2,3,4,5,6,7,8,9]
06:45:05 <thatsright> is there a function equivalent to f x y = y - (mod x y) ?
06:45:47 <dmhouse> thatsright: I would have thought that x `mod` (-y) would have that property, but mod is sometimes a little weird on negative numbers.
06:46:01 <dmhouse> Err, I mean (-x) `mod` y
06:46:10 <dmhouse> > (-3) `mod` 10
06:46:11 <lambdabot>   7
06:46:16 <dmhouse> Okay, that works.
06:46:30 <dmhouse> (It's more complicated if y is negative, but then why would you want a negative modulus?)
06:46:43 <ivanm> yay, now I get an error in the array index :s
06:47:15 <thatsright> dmhouse: good enough
06:49:01 <thatsright> dmhouse:  negative modulus blows my mind
06:49:16 <thatsright> dmhouse: but ill use it anyway
06:49:51 <dmhouse> thatsright: it's a bit more natural in the context of taking remainders, e.g. you could make sense of the remainder of 10/(-3) (although you have to be careful about your definition, which is why both mod and rem exist)
06:51:32 <ivanm> wtf? how can I have an error in my array index? :s
06:52:14 <dmhouse> thatsright: note that my solution doesn't have a negative modulus, though, I only mentioned that as a side-note
06:53:19 <dmhouse> x `mod` y is the element r of [0..y-1] such that y = q*x + r, with q an integer.
06:53:52 <dmhouse> This makes perfect sense if *x* is negative (and actually perfect sense if y is negative too, but it's not the only natural definition in that case)
06:53:54 <ziman> > -10 `rem` 7
06:53:55 <lambdabot>   -3
06:54:01 <dmhouse> > (-10) `rem` 7
06:54:02 <lambdabot>   -3
06:54:15 * dmhouse can never remember the precedence of -
06:54:19 <Saizan_> > (-10) `mod` 7
06:54:20 <lambdabot>   4
06:54:29 <dmhouse> > -10 `rem` 7
06:54:30 <lambdabot>   -3
06:54:39 <dmhouse> Okay, so you do need the parentheses.
06:54:48 <ivanm> oh, wait, that's how...
06:56:29 <thatsright> dmhouse: i forgot mod was just the remainder of integer division
06:57:04 <dmhouse> thatsright: hehe, actually what I just said was to try to convince you that that's not the best interpretation of mod :)
06:57:46 <dmhouse> thatsright: well, I guess that's fine as long as you remember the output of x `mod` y must always be in [0..y-1]
06:57:53 <dmhouse> > 10 `mod` (-4)
06:57:54 <lambdabot>   -2
06:58:05 <dmhouse> Aww, crap.
06:58:07 <dmhouse> Oh, of course.
06:59:20 <dmhouse> If y < 0 then [0..y-1] = [] so that doesn't make much sense, it's in [y+1..0] instead.
06:59:32 <dmhouse> Basically it's always an integer between 0 and y :)
07:00:25 <dmhouse> (That's not y.)
07:02:37 <ivanm> is there a simple way to get an entire row/column from an array?
07:03:14 <TomMD> Improve the array situation in haskell with a (another) custom library that has such a functionallity?
07:03:24 <TomMD> You're using Data.Array?
07:03:26 <dmhouse> ivanm: that doesn't really make sense?
07:03:29 <ivanm> (obviously, I can map (array !) over a list of indices formed from the row/column number zipped with all the indices in the other direction...)
07:03:37 <ivanm> dmhouse: why not?
07:03:44 <dmhouse> ivanm: oh, are you indexing with pairs?
07:03:48 <ivanm> yes
07:04:01 <ivanm> should have specified 2D array ;-)
07:04:10 <dmhouse> Sorry, for a minute I thought the index class was Enum, and pairs aren' instances of Enum, I don't think.
07:04:15 <dmhouse> ?instances Enum
07:04:16 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
07:04:30 <dmhouse> > [()..] -- *really* useful, I'm sure.
07:04:32 <lambdabot>   [()]
07:04:42 <ivanm> actually... since I'm going to want all rows, I can just do a groupBy . sort ...
07:04:47 <ivanm> dmhouse: lol
07:04:52 <ivanm> a 1-element array!
07:04:58 <Twey> @info Ordering
07:04:58 <lambdabot> Ordering
07:05:06 <Twey> What's an Ordering?
07:05:06 <ivanm> @instances Ix
07:05:06 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
07:05:08 <Saizan_> @src Ordering
07:05:09 <lambdabot> data Ordering = LT | EQ | GT
07:05:12 <Twey> Oh
07:05:14 <ivanm> @instances-importing Data.Array Ix
07:05:15 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
07:05:17 <Twey> > [LT..]
07:05:18 <lambdabot>   mueval: Prelude.read: no parse
07:05:25 <Twey> :-\
07:05:26 <Saizan_> > [LT ..]
07:05:27 <lambdabot>   [LT,EQ,GT]
07:05:31 <Twey> Uh?
07:05:32 <Twey> Oh
07:05:32 <Twey> Heh
07:05:37 <dmhouse> Twey: it parses as (.) from LT
07:05:55 <dmhouse> And you didn't give it any arguments, thus fail.
07:06:33 <ivanm> @pl \((x,y),z) -> (x,(y,z))
07:06:34 <lambdabot> uncurry (uncurry ((. (,)) . (.) . (,)))
07:06:38 <ivanm> heh
07:07:25 <dmhouse> I still think a competition to maximise length (output to ?pl) - length (input from ?pl) would be cool.
07:07:45 * ivanm loves it how generic tuple-based functions often look exactly like their type signatures
07:07:49 <dmhouse> Perhaps with minus points if the output uses alphanumeric chars
07:08:12 <ivanm> dmhouse: or maybe (output)/(input)*100 as a percentage increase?
07:08:42 <dmhouse> Ratios would work too./
07:08:49 <Baughn> @pl (a:b:(c,d):xs) -> d (a+map b xs*c)
07:08:49 <lambdabot> (line 1, column 16):
07:08:49 <lambdabot> unexpected ">" or "-"
07:08:49 <lambdabot> expecting variable, "(", operator or end of input
07:09:11 <dmhouse> Errors don't count.
07:09:11 <Baughn> @pl \(a:b:(c,d):xs) -> d (a+map b xs*c)
07:09:13 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip snd . (ap .) . flip flip fst . (((.) . (flip (.) .)) .) . (. (flip . ((*) .) . map)) . (.) . (.) . (+) .
07:09:13 <lambdabot> head) tail
07:09:22 <Twey> Yikes
07:09:43 <Twey> There are things that should never be represented in point-free... :-P
07:09:53 <dmhouse> ?pl (a,(b,(c,(d,e)))) -> ((((a,b),c),d),e)
07:09:53 <lambdabot> (line 1, column 19):
07:09:53 <lambdabot> unexpected ">" or "-"
07:09:53 <lambdabot> expecting variable, "(", operator or end of input
07:09:59 <dmhouse> ?pl \(a,(b,(c,(d,e)))) -> ((((a,b),c),d),e)
07:10:02 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . ((,) .) . (,)) .) . (,)) .) . (,))
07:10:36 <Deewiant> ?pl \(a,(b,(c,(d,e)))) -> ((((e,d),c),b),a)
07:10:39 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip (flip . ((flip . ((flip . ((,) .)) .))
07:10:39 <lambdabot>  .) . flip (flip . ((flip . ((,) .)) .) . flip (flip . ((,) .) . flip (,)))) . fst) snd
07:10:39 <lambdabot> optimization suspended, use @pl-resume to continue.
07:10:45 <dmhouse> Hah.
07:10:45 <Deewiant> ?pl-resume
07:10:48 <lambdabot> uncurry ((`ap` snd) . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip (flip . ((flip . ((flip . ((,) .))
07:10:48 <lambdabot>  .)) .) . flip (flip . ((flip . ((,) .)) .) . flip (flip . ((,) .) . flip (,)))))
07:11:01 <Baughn> Oh dear..
07:11:18 <dmhouse> ?pl \(a,b,(c,d,(e,f,g))) -> (((g,f,e),d,c),b,a)
07:11:18 <lambdabot> (line 1, column 6):
07:11:18 <lambdabot> unexpected ","
07:11:18 <lambdabot> expecting letter or digit, operator or ")"
07:11:18 <lambdabot> ambiguous use of a non associative operator
07:11:28 <Baughn> @pl \(a,(b,(c,(d,(e,(f,(g,h))))))) -> (a,b,c,d,e,f,g,h)
07:11:29 <Deewiant> can't handle triples
07:11:31 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . (flip .) . ((ap .) .) . flip flip fst . (flip .) . (((.) .) .) . flip flip snd . (flip .) . ((flip .) .)
07:11:31 <lambdabot>  . (((ap .) .) .) . flip flip fst . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
07:11:31 <lambdabot> . (((flip .) .) .) . (((((.) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .)
07:11:31 <lambdabot> .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . (,,,,,,,)) fst) snd) fst . fst) snd
07:11:33 <lambdabot> optimization suspended, use @pl-resume to continue.
07:11:38 <dmhouse> ?pl-resume
07:11:41 <Deewiant> heh
07:11:45 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip snd . (flip .) . ((flip .) .) . (
07:11:45 <lambdabot> ((ap .) .) .) . flip flip fst . (flip .) . ((flip .) .) . ((((.) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) .
07:11:45 <lambdabot>  (((flip .) .) .) . (((((.) .) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((
07:11:45 <lambdabot> flip .) .) .) . ((((flip .) .) .) .) . ((((((.) .) .) .) .) .) . (,,,,,,,) . fst) snd
07:11:46 <lambdabot> optimization suspended, use @pl-resume to continue.
07:11:49 <dmhouse> ?pl-resume
07:11:55 <Baughn> Some things should never be passed to @pl
07:11:55 <Saizan_> ..
07:12:01 <lambdabot> ap (flip ap snd . (. fst) . flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . flip flip snd . ((flip . ((flip . (ap .)) .
07:12:02 <lambdabot> )) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .
07:12:02 <lambdabot> ) . (((((.) .) .) .) .) . flip flip snd . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .) . flip flip fst . (flip .) . ((flip .) .) . (((flip .) .) .) . (((
07:12:03 <lambdabot> (flip .) .) .) .) . ((((((.) .) .) .) .) .) . (,,,,,,,) . fst) snd
07:12:05 <lambdabot> optimization suspended, use @pl-resume to continue.
07:12:06 <EvilTerran> enough!
07:12:06 <Deewiant> of course, just increasing the tuple size makes it grow really fast
07:12:07 <Saizan_> don't DoS it :)
07:12:10 <dmhouse> Hehe.
07:12:27 <Saizan_> @bot
07:12:27 <lambdabot> :)
07:13:02 <EvilTerran> ?type uncurry . uncurry (,)
07:13:04 <lambdabot>     Couldn't match expected type `a -> b -> c'
07:13:04 <lambdabot>            against inferred type `(a1, b1)'
07:13:04 <lambdabot>     Probable cause: `uncurry' is applied to too many arguments
07:13:08 <EvilTerran> ?type uncurry . uncurry (,,)
07:13:10 <lambdabot>     Couldn't match expected type `b -> c'
07:13:10 <lambdabot>            against inferred type `(a, b1, c1)'
07:13:10 <lambdabot>     In the second argument of `(.)', namely `uncurry (,,)'
07:13:12 <EvilTerran> gr
07:13:47 <Twey> ?type uncurry (,)
07:13:48 <lambdabot> forall a b. (a, b) -> (a, b)
07:13:51 <EvilTerran> ?type uncurry . uncurry . uncurry . uncurry . uncurry $ (,,,,,)
07:13:52 <lambdabot> forall b b1 b2 b3 a b4. (((((a, b4), b3), b2), b1), b) -> (a, b4, b3, b2, b1, b)
07:13:58 * Saizan_ wonders if there's a useful purpose for @pl-resume
07:14:44 <Peaker> what does it do?
07:15:07 <Baughn> Keep spamming
07:15:14 <Twey> Heh
07:15:22 <Deewiant> well, it reduces the expression
07:15:31 <Baughn> That was NOT "reduction".
07:15:34 <Peaker> heh
07:15:34 <Deewiant> but if it's so big that you need it it probably won't help much :-P
07:15:57 <dmhouse> It beta-reduces the expression.
07:16:02 <Saizan_> Peaker: @pl gives up after a certain number of steps of the "optimization" algorithm, @pl-resume makes it try again from where it stopped
07:16:07 <Baughn> @pl (a,(b,c)) -> (a,b,c)
07:16:07 <lambdabot> (line 1, column 11):
07:16:07 <lambdabot> unexpected ">" or "-"
07:16:07 <lambdabot> expecting variable, "(", operator or end of input
07:16:09 <dmhouse> \x -> f x => f
07:16:11 <Baughn> @pl \(a,(b,c)) -> (a,b,c)
07:16:11 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
07:16:57 <dmhouse> Saizan_: ah, so each of the outputs it gaves is a valid pointsfree form of the input?
07:17:32 <Deewiant> yep
07:19:50 <mc__> has someone in here tried bot haskell-mode and the textmate haskell bundle?
07:20:13 <olsner> someone should build something like pl that tries to shorten the expression as far as possible (not necessarily pointsfreeing it)
07:21:58 <ivanm> I don't think the Chart library likes xmonad... the title, resource and classname all get set based on the application creating the chart window, which means there's no way of using a generic mangeHook in xmoand for them :@
07:22:12 <dmhouse> olsner: in terms of numbers of characters?
07:22:56 <olsner> maybe number of tokens, to offset the length of identifiers (otoh, you'd like to favor standard functions with shorter names...)
07:25:23 <zi> hmm, could you print tables?
07:29:21 <thatsright> there is a blip between my sinewaves http://tinyurl.com/65fa7j
07:29:42 <thatsright> http://hpaste.org/10164
07:30:42 <Zao> drop the last element of the range.
07:30:54 <Zao> You most probably want the equivalent of the math range [0..f)
07:31:51 <Zao> You most probably want to keep the phase the previous wave started at for the next one, in case it doesn't end on the period.
07:34:14 <thatsright> Zao: that would require a sort of incremental sin wave function
07:35:54 <trofi> @src liftIO
07:35:54 <lambdabot> Source not found. You type like i drive.
07:36:09 <trofi> :t liftIO
07:36:11 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:39:41 <int-e> @type let swizzle = uncurry (uncurry . ((,) .) . (,)) in (uncurry . uncurry $ (,,)) . swizzle
07:39:42 <lambdabot> forall a a1 b. (a, (a1, b)) -> (a, a1, b)
07:39:50 <int-e> @type let swizzle = uncurry (uncurry . ((,) .) . (,)) in (uncurry . uncurry . uncurry $ (,,,)) . swizzle . swizzle
07:39:52 <lambdabot> forall a b a1 a2. (a1, (a2, (a, b))) -> (a1, a2, a, b)
07:40:11 <EvilTerran> ?type  uncurry (uncurry . ((,) .) . (,))
07:40:12 <lambdabot> forall b a a1. (a1, (a, b)) -> ((a1, a), b)
07:40:44 <EvilTerran> ?type (fst.fst &&& first snd)
07:40:45 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
07:40:48 <int-e> @pl \(a,(b,c)) -> ((a,b),c)
07:40:48 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
07:40:50 <EvilTerran> :D
07:41:07 <EvilTerran> ^ clearly superior
07:42:11 <EvilTerran> ?type second fst &&& snd.snd -- there's a nice symmetry with its dual, too
07:42:12 <lambdabot> forall a b d. (d, (a, b)) -> ((d, a), b)
07:43:21 <int-e> nice
07:44:24 <qwr> pointless unlambda programmers? :P
07:45:52 <int-e> I wanted a point-free version of \(a,(b,(c,(d,(e,(f,(g,h))))))) -> (a,b,c,d,e,f,g,h) with length linear in the number of variables.
07:46:21 <opqdonut> loads of uncurries?
07:46:26 <EvilTerran> ?type fst.fst.fst &&& (snd.fst.fst &&& first snd)
07:46:28 <lambdabot> forall a b b1 b2. (((a, b), b1), b2) -> (a, (b, (b1, b2)))
07:46:36 <EvilTerran> ah, other way
07:47:25 <opqdonut> :t uncurry.uncurry.uncurry $ (,,,)
07:47:27 <lambdabot> forall b b1 a b2. (((a, b2), b1), b) -> (a, b2, b1, b)
07:47:56 <int-e> opqdonut: wrong way of pairing, hence the need for swizzle :)
07:48:08 <opqdonut> yes, see what EvilTerran said
07:48:51 <EvilTerran> ?type uncurry . (uncurry .) . ((uncurry .).) . (((uncurry .).).) . ((((uncurry .).).).) . (((((uncurry .).).).).) . ((((((uncurry .).).).).).) $ (,,,,,,,)
07:48:52 <dmhouse> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
07:48:53 <lambdabot> forall a b a1 a2 a3 a4 a5 a6. (a6, (a5, (a4, (a3, (a2, (a1, (a, b))))))) -> (a6, a5, a4, a3, a2, a1, a, b)
07:48:54 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
07:48:54 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -
07:48:54 <lambdabot> > y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -
07:48:55 <lambdabot> > t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> (
07:48:58 <lambdabot> a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51,
07:48:59 <EvilTerran> yikes
07:49:01 <lambdabot> t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72, t73, t74, t75, t76, t77, t78, t79, t80, t81, t82)
07:49:03 <opqdonut> :D
07:49:04 <EvilTerran> mine got lost there somewhere
07:49:13 <EvilTerran> need a length limit on ?type output
07:49:15 <EvilTerran> ?type uncurry . (uncurry .) . ((uncurry .).) . (((uncurry .).).) . ((((uncurry .).).).) . (((((uncurry .).).).).) . ((((((uncurry .).).).).).) $ (,,,,,,,)
07:49:17 <lambdabot> forall a b a1 a2 a3 a4 a5 a6. (a6, (a5, (a4, (a3, (a2, (a1, (a, b))))))) -> (a6, a5, a4, a3, a2, a1, a, b)
07:49:32 <dmhouse> Heh, GHCi does print a type for tht.
07:49:35 <EvilTerran> that's O(n^2), unfortunately
07:49:36 <int-e> EvilTerran: great, but it still grows quadratically :)
07:49:38 <dmhouse> Oh aargh!
07:49:40 <dmhouse> Sorry, all.
07:50:37 <EvilTerran> int-e, you could do something in O(1) source space with TH
07:51:12 <EvilTerran> or maybe with Data.Generics
07:52:01 <ziman> wouldn't that be O(log n)? (you need to encode the number :) )
07:54:23 <adu> hi
07:55:41 <mapreduce> @pl \x -> x*x+x*x
07:55:41 <lambdabot> ap ((+) . join (*)) (join (*))
07:56:35 <EvilTerran> ?type ((+)`on`join(*))
07:56:37 <lambdabot> forall a. (Num a) => a -> a -> a
07:56:45 <EvilTerran> ?type (*2).(^2)
07:56:46 <lambdabot> forall a. (Num a) => a -> a
07:56:55 <EvilTerran> ^ that's what you want
08:02:20 <mapreduce> @pl \x -> 2*x*x
08:02:20 <lambdabot> (*) =<< (2 *)
08:03:17 <mapreduce> @pl \x -> x*x*2
08:03:17 <lambdabot> (2 *) . join (*)
08:03:31 <EvilTerran> it doesn't do x*x -> x^2
08:03:46 <olsner> x xor 2? :P
08:03:48 <mapreduce> So (. join) is the inverse of =<<?
08:04:18 <trofi> :t join
08:04:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:04:21 <trofi> :t return
08:04:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:04:28 <olsner> :t (. join)
08:04:29 <lambdabot> forall c (m :: * -> *) a. (Monad m) => (m a -> c) -> m (m a) -> c
08:04:59 <mapreduce> Why does it use c in that type rather than b?
08:05:12 <dmwit> It comes from the (.).
08:05:47 <olsner> :t (\f g -> g . join f)
08:05:53 <lambdabot> forall b c a. (a -> a -> b) -> (b -> c) -> a -> c
08:06:41 <trofi> :t (join.return)
08:06:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
08:06:57 <Saizan_> exit
08:07:03 <dmwit> Sorry, no.
08:07:27 <Saizan_> what a weird ssh session..
08:07:32 <olsner> exit: command not found. To exit, use quit.
08:07:36 <dmwit> Saizan_: hahaha
08:07:51 <mapreduce> password:
08:08:46 <Twey> hunter2
08:08:53 <chessguy_> @bot
08:08:53 <lambdabot> :)
08:09:00 <dmwit> Why are you typing *******?
08:17:50 <adu> the rain has stopped, yey
08:18:57 <mc__> it has 33¬∞ over here, too hot :(
08:19:11 <adu> mc__: are you a mason?
08:19:41 <mc__> nope, why do you ask?
08:20:03 <adu> mc__: 33 degree is the highest rank you can get in masonry
08:20:40 <adu> mc__: in addition to be an ambiguous temperature without an F or C
08:21:12 <mc__> adu:  33¬∞ C
08:21:18 <dmhouse> I'm guessing Celsius.
08:21:32 <dmhouse> 33 degrees Fahrenheit is not "too hot" for most people/
08:21:44 <dmhouse> Unless you're a block of ice, I guess.
08:22:22 <mc__> adu: are you a mason?
08:22:38 <adu> mc__: nope, I'm just paranoid :)
08:23:04 <mc__> hehe, alright
08:23:44 <adu> mc__: if I was I'd probably say something like "the potatos have been catapaulted" and you would know what I mean :)
08:23:56 <ttt--> hi, what would be a small set of haskell function with which you could express most things?
08:24:22 <adu> ttt--: filter and map
08:24:30 <ttt--> im not that experienced with haskell
08:24:36 <mc__> adu: and then I would say "the dogs are out of the house" and you would know that I understood
08:24:39 <adu> ttt--: the Prelude.* is also nice
08:24:47 <ttt--> im thinking, head and tail too, at least
08:24:48 <dmwit> ttt--: S, K, and I; so ap, const, and id
08:24:53 <dmwit> ;-)
08:24:56 <adu> mc__: lol
08:25:10 <ttt--> i was looking for the functions that make readable code
08:25:15 <dmwit> oh
08:25:24 <dmhouse> dmwit: don't even need id!
08:25:25 <Baughn> ttt--: If you want readable code, you'll want to use more than a minimal set. ;)
08:25:27 <dmhouse> ?type ap const const
08:25:28 <lambdabot> forall a. a -> a
08:25:40 <adu> ttt--: ya, but a:b is usually more useful than head and tail
08:25:42 <dmwit> ttt--: Yeah, learn the Prelude functions first; they get you a way to do everything you want to do.
08:25:45 <dmwit> dmhouse: right
08:26:01 <olsner> but are those functions turing complete in haskell? I thought it required a lesser type system to allow you to do that?
08:26:15 <adu> ttt--: there are millions of functions that make code more readable, its called HHL
08:26:17 <olsner> or at least one that allows infinite types
08:26:19 <dmwit> olsner: Right, you also need fix.
08:26:19 <dmhouse> olsner: they're complete in the untyped lambda calculus, so certainly in Haskell
08:26:27 <dmhouse> Oh, I see.
08:26:34 <Baughn> olsner: Does it matter? For practical reasons, you'd really want IO functions too. ^^;
08:26:34 <dmhouse> Yeah, certain applications of them are illegal in Haskell.
08:26:34 <ttt--> adu, what is HHL?
08:26:50 <Twey> Is there a function \ x y a -> x a || y a ?
08:26:52 <adu> ttt--: the Haskell Hierarchical Libraries
08:26:53 <olsner> Baughn: just stick 'em in interact :P
08:26:58 <ttt--> oh
08:26:59 <dmwit> Twey: liftM2 (||)
08:27:05 <Twey> Ah, thanks
08:27:16 <dmwit> ?pl \x y a -> x a || y a
08:27:16 <lambdabot> liftM2 (||)
08:27:19 <dmwit> ;-)
08:27:25 <olsner> (and probably a mapper that church-en/decodes lists and characters)
08:27:31 <Twey> Heh, ah
08:27:34 <dmhouse> olsner: well that's just sugar
08:27:35 <ttt--> is there a top 100 of most used haskell functions?
08:27:48 <ttt--> that would be fun to see
08:28:08 <dmhouse> olsner: Haskell desugars to the lambda calculus, I would think.
08:28:23 <dmhouse> (Obviously apart from IO.)
08:28:23 <Baughn> olsner: Hum. Reminds me of the time I wrote Elaborate Machinery (tm) to get stream i/o on an internet database
08:28:33 <Baughn> Turned out, it was much easier to use the IO monad
08:28:34 <adu> ttt--: not that i know of
08:29:06 <olsner> well, haskell has data that aren't lambdas ... and SKI can't express pattern matching on haskell data without some decoding outside of SKI
08:29:20 <dmhouse> olsner: for example?
08:29:52 <dmhouse> Hmm, actually, data Foo a = Foo (a -> a) won't desugar to LC
08:30:01 <dmhouse> You probably need Eq.
08:30:37 * dmwit thinks dmhouse may very well be confused
08:30:48 <adu> lol
08:30:57 <dmhouse> What I mean is, you obviously don't get pattern matching in LC
08:31:03 <dmhouse> But you can approximate a lot with Eq.
08:31:21 <olsner> with Eq?
08:31:23 <dmwit> Most of Haskell should be considered as extensions to \calc.
08:31:38 <dmwit> let/where-binding, pattern-matching, hell, even polymorphism doesn't really fit into the simply-typed \calc.
08:32:05 <trofi> :t if'
08:32:07 <lambdabot> Not in scope: `if''
08:32:23 <dmwit> trofi: ?pl uses if' test true false = if test then true else false
08:32:43 <trofi> nonstandard?
08:32:46 <dmwit> correct
08:33:08 <Baughn> It really, really should be standard. :'(
08:33:08 <dmwit> It's a bit of a wart, really, that if is syntax and not a Prelude function.
08:33:28 <Baughn> True. But given that it is, ghc could at least add if'
08:33:31 <ddarius> No it isn't.
08:33:53 <ddarius> It's a bit annoying that there isn't an "if" function.
08:34:40 <dmhouse> > let fact 0 = 1; fact n = n * fact (n-1); fact' = fix (\rec n -> if (n == 0) then 1 else n * rec (n-1)) in fact' 10 == fact 10 -- factorials without pattern matching
08:34:41 <lambdabot>   True
08:34:45 <dblazakis> dmwit: i thought let and where were just sugar for a lambda abstraction
08:35:03 <Tchakkazulu> Quick question. Is hIsTerminalDevice the preferred way of determining if a Handle is being piped or not?
08:35:16 <olsner> if/then/else as keywords do eliminate a few parens, although it's sad that the one language where if is finally implementable in the language, doesn't have if as a normal function :)
08:35:18 <dmhouse> This will work for most basic datatypes: integers, chars, bools... But not for some stuff, as I remarked. You need the types to be in Eq.
08:35:39 <dmhouse> olsner: well, guards are also implementable in the language
08:35:42 <dmwit> dblazakis: They can be treated that way, sure.
08:35:51 <dmhouse> olsner: as is, say, the list sugar.
08:36:20 <trofi> @hoogle Bool -> a -> a -> a
08:36:21 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
08:36:21 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
08:36:21 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
08:37:42 <dmwit> trofi: I sometimes define "bool f t b = if b then t else f", but in reality, it isn't really that useful very often.
08:38:37 <ziman> :t if'
08:38:39 <lambdabot> Not in scope: `if''
08:42:32 * lilac likes <?> :: (Monad m) => Bool -> a -> m a, and <:> :: Maybe a -> a -> a
08:42:55 <adu> its raining again
08:43:04 <lilac> where are you?
08:43:13 <adu> MD, US
08:43:28 <lilac> yeah, it's raining here in cambridge too :)
08:43:35 <ben_m> It's so hot here.
08:43:36 <ben_m> :/
08:43:38 <opqdonut> not raining here in helsinki
08:43:43 <opqdonut> but cold and overcast
08:44:01 <opqdonut> (wow, small talk)
08:44:39 <Peaker> Way too hot in Israel :(
08:44:50 <fnord123> raining in london
08:45:06 <dcoutts> just finished bucketing down in Oxford
08:45:22 <fnord123> oh so we'll get that in a few hours
08:45:35 <ziman> sunny but not that hot in Prague
08:45:59 <dmwit> lilac: Hey, I use that <?> all the time (under a different name).
08:46:12 <adu> lilac: I think its raining all across the eastern coast
08:46:18 <dmwit> Though I guess it's s/Monad/MonadPlus/.
08:46:22 <wjt> @ty maybe
08:46:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:46:27 <dmwit> I never thought of making it infix... that's probably very nice.
08:46:29 <wjt> @ty fromMaybe
08:46:30 <lambdabot> forall a. a -> Maybe a -> a
08:46:38 <wjt> lilac: <:> == flip fromMaybe?
08:46:46 <dmwit> wjt: Yeah, probably.
08:49:05 <adu> so does (<:>) = flip fromMaybe?
08:49:18 <adu> what does <?> do?
08:49:53 <adu> is that the <?> used in Parsec for errors?
08:52:59 <dmwit> <?> is like guard, I guess
08:53:10 <dmwit> It's actually not the thing I was thinking of.
08:53:44 <dmwit> :t let b <?> x = guard b >> return x in (<?>)
08:53:45 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => Bool -> b -> m b
08:53:46 <lilac> to be honest, it makes more sense as (MonadPlus m) => Bool -> a -> m a
08:53:53 <lilac> heh
08:53:56 <dmwit> I prefer
08:54:08 <dmwit> :t let p <?> x = guard (p x) >> return x in (<?>)
08:54:10 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
08:54:23 <adu> dmwit: the closest functions I can find are Control.Monad (guard, when) and Control.Exception (assert)
08:55:10 <dmwit> adu: see above, I'm sure the first is what lilac was referring to
08:55:38 <lilac> :t let True <?> x = return x; False <?> x = mzero
08:55:40 <lambdabot> <no location info>:
08:55:40 <lambdabot>     not an expression: `let True <?> x = return x; False <?> x = mzero'
08:56:02 <dmwit> :t let True <?> x = return x; False <?> x = mzero in (<?>)
08:56:04 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
08:56:20 <dmwit> That's behaviorally equivalent to b <?> x = guard b >> return x
08:56:39 <sheyll> hi
08:56:53 <dmwit> sheyll: Hiya!
08:57:03 <adu> dmwit: what's the difference between "return ()" and "mzero"?
08:57:32 <dmwit> adu: One returns something; the other doesn't.
08:57:44 <dmwit> > (return (), mzero) :: ([()], [()])
08:57:45 <lambdabot>   ([()],[])
08:57:56 <dmwit> > (return (), mzero) :: (Maybe (), Maybe ())
08:57:58 <lambdabot>   (Just (),Nothing)
08:58:04 <adu> ooh
08:58:23 <adu> I was thinking in terms of IO, but I see there is no MonadPlus IO instance... heh
08:58:27 <lilac> > let True <?> x = return x; False <?> x = mzero; (<:>) = flip fromMaybe in True <?> 42 <:> 17
08:58:28 <lambdabot>   42
08:58:49 <dmwit> ah, heh
08:59:01 <adu> now I get it
08:59:09 <ddarius> @instances MonadPlus
08:59:10 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
09:00:12 <adu> lilac: thats like a first-class if statement...
09:02:09 <lilac> ... except that "b <?> x" and "x <:> y" are actually useful by themselves :)
09:02:46 <adu> lilac: you should use <!> instead of <:>
09:03:00 <fnord123> http://groups.google.com/group/fa.haskell/browse_thread/thread/f958d3417241ef3e <-- looks like the same problem I'm havin
09:03:10 <lambdabot> Title: cabal update : getHostByName - fa.haskell | Google Groups, http://tinyurl.com/5gop6z
09:06:00 <dmwit> adu: I think it's meant to mimic C's ternary ?: operator.
09:06:20 <adu> dmwit: ya i know, I guessed that much
09:06:32 <dmwit> Okay, so why <!>?
09:06:54 <Olathe> Is there an included way to divide two numbers of the same type where Float -> Float -> Float and Integer -> Integer -> Ratio Integer and so on ?
09:07:44 <dmwit> No, but you should be able to make a typeclass for it without too much trouble.
09:07:54 <adu> dmwit: well, ? evokes truth testing so it makes sense, and ! evokes thoughts of C's not operator, which evokes the sense of "false", and in a<?>b<!>c the b is what happens when its true, and c is what happens when it is false...
09:08:06 <Olathe> Is there a way to use (/) or something short like that or are they all taken ?
09:08:21 <dmwit> adu: ah, you meant to replace the <:>, I see
09:08:32 <adu> Olathe: theres always "import Prelude ()"
09:08:45 <dmwit> Olathe: #, & are probably available.
09:08:56 <Olathe> Ahh. Does that only affect the code in that file ?
09:09:03 <dmwit> yes
09:09:07 <Olathe> Alright, thanks :)
09:09:08 <adu> Olathe: yes
09:09:36 <lilac> Olathe: "import Prelude hiding ((/))"
09:09:44 <adu> that works too
09:10:00 <Olathe> Ahh, thanks :)
09:10:06 <lilac> hiding all of the Prelude is perhaps overkill :)
09:10:28 <Olathe> Bah. Who needs the Prelude ?
09:10:49 * adu cheers for NumericPrelude
09:11:00 * lilac cheers for CalePrelude
09:11:09 <adu> ooo theres a CalePrelude?
09:11:22 <lilac> well, there's a variety of lambdabot hacks
09:11:34 <adu> I should put together an AduPrelude
09:12:10 * dmwit cheers for DmwitPrelude
09:12:34 * Olathe cheers for Cheerable
09:12:37 <adu> although I was actually thinking of something different for ? and ! in my prelude
09:14:36 <adu> (?) :: Elem m => m a -> a -> Bool, (!) :: (Item m, Ix b) => m a -> b -> a
09:14:42 <lilac> cheersFor :: (Cheerable c) => Haskellite -> PreludeReplacement -> Happier Haskellite
09:14:45 <adu> but that seems boring compared to lilac's
09:15:06 <dcoutts> fnord123: it's the same symptom at least
09:15:29 <dcoutts> fnord123: perhaps you can tell us your platform and we might be able to find a pattern
09:15:31 <dmwit> Elem, Item?
09:16:38 <adu> dmwit: silly classes that only support those functions, i.e. class Elem m where (?) :: m a -> a -> Bool
09:17:14 <dmwit> oh
09:18:19 <adu> I wanted to use it for Sets and Types, but that would require dramatic syntax changes...
09:18:59 <adu> so x::T, T?x, and x `isa` T were all roughly the same, but I'm slowly learning they can all be the same...
09:19:26 <adu> I don't think its even possible with TH
09:50:41 <mmorrow> looks like someone's gonna have to golf space invaders: http://www.reddit.com/r/programming/comments/6zskp/haskell_scala_java_7_functional_java_java/c05bffe
09:50:44 <lambdabot> Title: redditnoob comments on Haskell > Scala > (Java 7 Functional Java) > Java, http://tinyurl.com/5fml8n
10:19:16 <MarcWeber> Is there an howto on howto use hpc?
10:21:46 <Lemmih> MarcWeber: hpc --help?
10:22:34 <Lemmih> *hpc help
10:22:47 <MarcWeber> He, I've been looking for a very small usage example such as http://projects.unsafeperformio.com/hpc/
10:22:48 <lambdabot> Title: Haskell Program Coverage
10:22:59 <MarcWeber> However I already got the --decl-list .. amazing
10:36:42 <Xenoblitz> hi guys what is the website where i can post code to show in order to ask about it?
10:36:49 <Zao> hpaste.org
10:36:52 <cjb> I like codepad.org
10:36:56 <cjb> other people prefer hpaste
10:37:02 <Xenoblitz> cjb, zao: thanks
10:37:20 <cjb> (codepad actually runs your code, so it's easy to show people what the output is too)
10:37:59 <Zao> cjb: I thought it only ran C++>
10:38:34 <Xenoblitz> http://hpaste.org/10167
10:38:42 <Xenoblitz> i have what i think is the usual newbie layout error
10:38:45 <Xenoblitz> any ideas guys?
10:38:57 <cjb> Zao: nope
10:39:44 <Xenoblitz> the problem is surely in the last 3 lines
10:40:11 <Zao> Xenoblitz: then and else must be deeper than the corresponding if, I believe.
10:40:27 <Heffalump> yes, they must
10:40:29 <cjb> Zao: an example; http://codepad.org/zzJFFkXx
10:41:12 <Xenoblitz> zao, heffalump: fixed that... still same problem :/
10:42:19 <Heffalump> oh, you're missing an else, too
10:42:33 <Heffalump> in Haskell you always need an else, because if ... then .. else is an expression
10:42:39 <Xenoblitz> heffalump: oh :S
10:42:41 <Xenoblitz> hmmm
10:42:43 <Heffalump> you can use when from Control.Monad in this particular case
10:42:51 <Heffalump> when (foundBlockAtXY x y) $ do ...
10:42:54 <Xenoblitz> oh ok
10:43:09 <Heffalump> but normally there's no obvious default for the else part, which is why it can't be omitted.
10:43:44 <Xenoblitz> can i just use return ()
10:43:45 <Xenoblitz> ?
10:43:50 <Heffalump> yep
10:44:45 <[Head|Rest]> > product [1..10]
10:44:46 <lambdabot>   3628800
10:45:38 <Xenoblitz> thanks alot heffalump
10:45:40 <Xenoblitz> ;)
10:48:10 <qwerty> Hi. Newbie (and probably silly) question about State monad.
10:49:32 <MarcWeber> qwerty: Just put it :-)
10:49:34 <qwerty> Read about it, understand how it works. Just can't find it (unlike Maybe). Where is it (i.e. what to import) ?
10:49:47 <TomMD> Control.Monad.State
10:50:43 <qwerty> Is that the classic State of all the tutorials ? 'cause I keep getting to this class using features "not officially part of Haskell 98"
10:52:04 <Heffalump> qwerty: the MonadState class isn't Haskell 98
10:52:09 <Heffalump> the State and StateT types are fine.
10:52:23 <Heffalump> and State is exactly what you would see in a tutorial, because there's no other way to write it.
10:52:33 <Heffalump> (the name of the constructor, and strictness/laziness issues aside)
10:52:33 <ddarius> http://www.accu-usa.org/
10:52:44 <lambdabot> Title: ACCU (U.S.A.) - Silicon Valley Chapter
10:52:49 <ddarius> Heffalump: You could have a stricter version.
10:53:04 <Heffalump> ddarius: KUATBT ;-)
10:53:57 <qwerty> oh. ok. Thanks TomMD & Heffalump
10:54:07 <ddarius> @vera kuatbt
10:54:18 <lambdabot> No match for "kuatbt".
10:54:22 <Heffalump> how do I add one?
10:54:38 <Botje>  @where+ ?
10:54:59 <Heffalump> I thought @where+ was for @where.
10:55:29 <Heffalump> "Keep up at the back there", anyway. At least in my client, I mentioned strictness/laziness a good three lines before ddarius did.
10:56:32 <ddarius> Heffalump: It might not have been there when I wrote my response, but I probably just missed it.
11:04:03 <Jxcvc> How does Haskell differ from UML?
11:04:44 <Botje> one's a propaganda and communications machine for the imperative pigs
11:04:53 <Botje> the other is a programming language
11:05:04 <LeoD> hah
11:05:17 <Heffalump> lol
11:07:27 <Beelsebob> Jxcvc: that's one of the funniest trolls I've heard in a long time, thanks :)
11:07:59 <ddarius> Next week: "How does Haskell differ from a turnip?"
11:08:15 <kaol> one can be lambda-shaped and so can the other
11:08:30 <TomMD> Whenever someone says 'UML' I always think 'User Mode Linux'.  The other 'UML' is just that insignificant to me, I guess.
11:08:31 <Beelsebob> kaol: what's the difference between a duck
11:08:47 <Beelsebob> TomMD: is it significant to anyone/
11:09:06 <TomMD> Beelsebob: I try not to speak on behalf of the UML developers.
11:09:51 <thorkilnaur> Beelsebob, (on behalf of kaol): It neither wears a tie ...
11:10:19 <Beelsebob> thorkilnaur: not heard that answer before -- my usual one is "one of it's legs is both the same"
11:10:33 <Beelsebob> I like yours too though
11:12:10 <thorkilnaur> Beelsebob, In Denmark, the question is usually about the difference between an elephant ...
11:12:10 <ziman> "has both legs equally long. especially the right one."
11:12:34 <Beelsebob> ziman: hehe
11:12:37 <Beelsebob> thorkilnaur: interesting
11:14:39 <skorpan> i tried to a coca-cola bottle but couldn't
11:14:49 <thetallguy> I've heard the joke "What's the difference between a duck?", but I've never heard an answer
11:17:09 <thetallguy> The web says it's the same answer.  So, why is it a duck in the US and an elephant in Denmark?
11:17:25 <Heffalump> Danes have worse eyesight?
11:18:04 <thetallguy> lol
11:18:21 <thetallguy> More importantly, is it funny because it's a type error joke?
11:18:50 <binrapt> It's just partial application
11:18:56 <binrapt> Lacks an argument
11:19:11 <binrapt> Yeah but in the end it's a type error
11:19:17 <binrapt> Because there's no show instance for that
11:19:26 <Heffalump> <<function>>
11:24:03 <idnar> "What's the difference between a duck?"  "Because one leg's black, and the other one's also red."
11:26:44 <alsonk> as a lot of other people are probably doing, I'm looking at web app frameworks in Haskell.  have used ASP.NET, RoR, etc.  I've been thinking through how to do modules and extensions and have run into a roadblock...  Was hoping for some help thinking that through.
11:28:20 <alsonk> the area I'm having problems is with, for example, configuration settings.  I'd like to have a single class handle all configuration, but would like it to be extensible so that Caching, Authentication, could be added.
11:29:08 <alsonk> instance HasConfiguration a => HasConfiguration Caching a
11:30:11 <Heffalump> you're missing some parens
11:30:36 <TomMD> Parens are over rated.  Use money instead.
11:30:36 <amitprakash> whats wrong with this code? http://pastebin.com/m190807e6
11:30:40 <alsonk> Then hook 'a' up to Caching as a 'base' member of the Caching type
11:30:54 <Heffalump> HasConfiguration (Caching a)
11:31:03 <alsonk> That way I could string configurations together
11:31:57 <alsonk> myConf = CachingConfiguration {conf1 = x, conf2 = y, base = AuthConfiguration {conf3 = z, base = BaseConfiguration}}
11:32:24 <TomMD> amitprakash: 1) No main function 2) No error message included in paste.
11:32:37 <alsonk> would be fairly easy to add configuration modules to the code base and to 'myConf'.
11:33:05 <TomMD> Oh, and multipoly's last declaration is wacho.
11:33:25 <alsonk> I'm hoping to find some syntactic sugar that avoids : methodOnBaseConfiguration $ base $ base myConf
11:33:35 <TomMD> Hello byorgey - enjoying your courses and research?
11:33:44 <TomMD> ... what is your research looking like anyway?
11:33:57 <alsonk> would love it if I could use pattern matching in _class_ declarations
11:34:01 <byorgey> TomMD: yes, very much, thanks!
11:34:08 <Heffalump> alsonk: take a look at how MonadState etc give access to get/put even through layers of monad transformers
11:34:15 <Heffalump> also, what do you mean by pattern matching in class declarations?
11:34:28 <byorgey> TomMD: well, this fall at least, I'll be working with Stephanie Weirich on hacking up a new dependently typed language, with effects typing and some other features I don't quite understand yet =)
11:34:43 <TomMD> I'm eager to read more Penn papers ever since reading Peng Li's RTS work.
11:34:53 <byorgey> I'm excited about it, it may certainly develop into something more than just a semester independent study
11:35:01 * Heffalump disappears for dinner
11:35:06 <alsonk> be able to do something like _ :: a -> b
11:35:06 <byorgey> TomMD: RTS?
11:35:12 <TomMD> byorgey: Is this a lazy dependently typed language?
11:35:21 <TomMD> byorgey:  Run time system
11:35:25 <byorgey> TomMD: no, it will be call-by-value
11:35:26 <alsonk> then in the instance do f@_ = f $ base conf
11:35:40 <alsonk> rather f@_ conf = f $ base conf
11:35:56 <alsonk> essentially, standard object oriented stuff.
11:36:29 <byorgey> TomMD: partly because it's just one less thing to worry about, I guess, and partly because it really highlights the need for a good effect-typing system
11:36:29 <alsonk> if no function matches on this class, then try that function on the base class.
11:36:34 <byorgey> I think.
11:36:39 <byorgey> ask me again in a few months =)
11:36:44 <amitprakash> alsonk, any idea what i did wrong with http://pastebin.com/m190807e6
11:36:52 <TomMD> byorgey: Carful, I will ask.
11:36:56 <TomMD> ;-)
11:37:08 <alsonk> looking..
11:37:09 <byorgey> heh, please do =)
11:37:35 <alsonk> what's the error?
11:37:50 <TomMD> amitprakash: I did you fix the last declaration of multipoly?
11:38:06 <TomMD> You have no '=' after the functon guard.
11:38:13 <alsonk> agreed with TomMD
11:38:14 <fnord123> top
11:38:45 <amitprakash> TomMD, working on it :D
11:38:57 <amitprakash> TomMD, my net died :D
11:40:07 <ketil> @seen bos
11:40:08 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 14h 6m 12s ago.
11:41:15 <alsonk> Heffalump: MonadT is useful, but the lifting is explicit.  I'm trying to do it implicitly...
11:42:35 <Baughn> I don't suppose there's an implementation of Word128 around?
11:42:42 <dons> Baughn: yeah, in the Crypto package
11:42:54 <Baughn> Google found it, yep. ^^;
11:43:38 <Baughn> Hum. But depending on the Crypto package for, well, implementing cryptography.. might be frowned upon.
11:44:01 <Baughn> (Also, I'm really supposed to use lists of lists of (two, exactly) Word16s. Might newtype that.)
11:46:09 <dons> Baughn: maybe those extended word types should be in their own package.
11:46:18 <dons> Baughn: i needed them for lambdabot once too
11:46:27 <dons> Baughn: shall i do that?
11:46:50 <dons> Baughn: http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/Data-LargeWord.html
11:46:52 <lambdabot> Title: Data.LargeWord, http://tinyurl.com/64h7n5
11:47:06 <Baughn> dons: It would be handy, but right now I think I'll just stick Data/LargeWord.hs in my project
11:47:15 <Baughn> Suitably edited
11:47:20 <dons> ok.
11:48:05 <Baughn> dons: Hm. Which license is that?
11:52:02 <Baughn> dons: "RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph" <-- Your library broke my ghc
11:53:21 <ddarius> Baughn: Buy more stack slots.
11:54:17 <Baughn> ddarius: ..apparently. It works on 64-bit systems
11:54:25 <Baughn> Or it might be a linux vs. mac thing
11:55:33 <trofi> i'm absolutely out of theme, but maybe `ulimit -s' unvolved?
11:55:38 <Baughn> It is not
11:55:48 <Baughn> Hang on, testing a theory
11:55:54 <sioraiocht> is anyone here very familiar with 2-3 finger trees?
11:56:26 <mattam> sioraiocht: yes.
11:57:13 <sioraiocht> mattam: I was reading hinze's paper on them, and it talks about concatenation using an explicit Digit data type
11:57:30 <sioraiocht> but ti says that instead of writing the function(s) for this, it was better to actually write a program to generate the source code
11:57:39 <mattam> Yes.
11:57:42 <sioraiocht> I'm a bit confused about how to go about doing that
11:58:29 <Heffalump> alsonk: I don't mean MonadTrans, I mean the specific monad classes like MonadState.
11:58:35 <sioraiocht> do you have any suggestions about how i should think about doing this?
11:58:38 <Heffalump> They define how to implicitly lift get.
11:59:53 <mattam> Well, you have to generate the code of the functions from their type basically.
12:00:13 <sioraiocht> do not all cases have the same type?
12:02:01 <mattam> Eg. addDigits2 has to add 2 A's between 2 digits of A's, appendTree3 has to add 3 A's between two fingertrees of A's.
12:03:26 <dcoutts> sioraiocht: so how did it all go in the end? get any sleep before handing in?
12:03:36 <sioraiocht> dcoutts: why yes, three hours!
12:03:41 <dcoutts> heh heh
12:03:44 <dcoutts> not bad :-)
12:03:51 <sioraiocht> i got up earlier than i needed to
12:03:55 <sioraiocht> just in case, and all
12:04:09 <dcoutts> sioraiocht: so you're satisfied I hope
12:04:14 <sioraiocht> dcoutts: yes, very
12:04:27 <mattam> Each time, you pattern match on the structures on the left and right, and if they are both Deep nodes you look at the right of left structure and dispatch based on that.
12:04:50 <dcoutts> sioraiocht: great. I'll have to ask you to check the page I've added to my thesis on what we've learnt from your unicode project.
12:05:03 <sioraiocht> dcoutts: okay, certainly! :)
12:05:09 <sioraiocht> mattam: okay...thanks
12:05:22 <Heffalump> one MSc project = one page of a DPhil thesis? ;-)
12:05:24 <mattam> sioraiocht: It's been implemented already, why not use that code?
12:05:52 <sioraiocht> Heffalump: i know, ouch, right? =p
12:06:05 <sioraiocht> mattam: I plan on using this for a very specialised purpose
12:06:09 <Heffalump> I guess it loses something in being written about by someone else, too.
12:06:17 <sioraiocht> and I want to a) fully understand the implementation
12:06:21 <sioraiocht> so this is an exercise
12:06:25 <sioraiocht> and b) be able to adapt it
12:06:36 <mattam> okay.
12:06:44 <sioraiocht> I need access to the underlying structre that data.sequence provides an API over
12:07:59 <mattam> May I ask what you want to do with it?
12:08:16 <dcoutts> Heffalump: heh, well I'm making slightly different and very much summary points. If it helps, it's more like two pages :-)
12:08:42 <Heffalump> so what have you learnt?
12:09:40 <dcoutts> Heffalump: 1. that it works ok when the translation between underlying representation and the stream elements is not direct (ie in case of utf-8,16)
12:10:34 <dcoutts> Heffalump: 2. that significant code reuse is possible but that there are drawbacks which prevent it from being used as a complete solution, but hybrid seems fine.
12:11:06 <Heffalump> code reuse between what and what?
12:11:19 <dcoutts> Heffalump: different underlying representations and sharing operations over them
12:11:44 <dcoutts> by expressing the operations as stream functions and only having to write different stream/unstream ops for different representations
12:12:06 <dcoutts> and getting acceptable performance vs direct impls
12:12:41 <Olathe> If I do "import Predule hiding ((/))" in a file, how do I load that file so that its (/) replaces Prelude's (/) ? Do I have to do the hiding import there as well ?
12:12:56 <mmorrow> sioraiocht: have you looked at the code of the fingertree implem on hackage? in particular see the addDigits{0,..4} functions.
12:13:14 <dcoutts> Olathe: yes, you have to hide the prelude in each module where you want to use an alternative
12:13:23 <Heffalump> but you can import Prelude()
12:13:24 <Olathe> Bah. Alright, thanks.
12:13:26 <Heffalump> then import your module
12:13:28 <sioraiocht> mmorrow: no, i had been looking at Data.Sequence.  I will take a look at that, though
12:13:29 <mmorrow> sioraiocht: those should make it pretty clear how to generate them
12:13:37 <Heffalump> and have your module export the rest of the Prelude itself
12:13:38 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
12:13:40 <lambdabot> Title: HackageDB: fingertree-0.0, http://tinyurl.com/35pz7w
12:14:13 <sioraiocht> cheers
12:14:27 <mmorrow> :)
12:15:42 <Olathe> @list
12:15:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:15:43 <Olathe> @
12:15:49 <Olathe> Hmm.
12:15:53 <Olathe> That only works in private.
12:18:10 <Olathe> Are there any things autoloaded other than Prelude ?
12:18:11 <LeoD> > [1..2]
12:18:12 <lambdabot>   [1,2]
12:19:23 <dons> interesting outsider's view of haskell, http://stevenrbrandt.com/wordpress/?p=115
12:19:24 <lambdabot> Title: Regularly Expressing ¬ª Blog Archive ¬ª Learning Haskell
12:19:30 <dons> if that's the impression we're giving to the world, i'm happy
12:23:05 <Heffalump> now if you can just manage to give that impression to jdh..
12:23:10 <ddarius> This Haskell meme is indefatigable
12:24:18 <Twey> No, Olathe
12:24:28 <Olathe> Thanks :)
12:24:29 <Myoma> and this is what haskell hackers look like http://creature-art.com/
12:24:31 <lambdabot> Title: Creature Art
12:24:40 <Twey> (but Prelude auto-exports some things from other modules)
12:25:01 <ddarius> Myoma: A bunch of poorly drawn sketches.
12:25:02 <dons> ddarius: at least he doesn't mention memoisation
12:25:29 <Olathe> Ahh, never heard of exporting.
12:26:06 <ddarius> Thinking about it just now, I do wonder where he got his information.
12:26:50 <dons> ddarius: i was guessting RWH, or maybe a quick scan on haskell.org
12:27:15 <Heffalump> dons: do you get stats on the RWH preorder count, OOI?
12:27:26 <dons> hmm. i've not seen them yet.
12:27:36 <dons> we asked a while ago, and haven't heard back. should try asking again.
12:31:01 <Myoma> http://hackage.haskell.org/packages/archive/pkg-list.html
12:31:02 <lambdabot> Title: HackageDB: packages by category
12:31:05 <Myoma> searching for chess !
12:31:09 <Myoma> nothing on hackage
12:31:58 <mmorrow> Myoma: it looks like you'll get to stake out the prime namespace then :)
12:34:23 <dons> anyone done anything with qthaskell?
12:34:24 <dons> http://qthaskell.sourceforge.net/index.html
12:34:25 <lambdabot> Title: qtHaskell
12:34:31 <dons> i note it still builds out of the box with cabal
12:34:38 <dons> but has a AllRightsReserved license
12:34:40 <dons> which is weird.
12:34:46 <dons> it needs to be on hackage
12:35:16 <ddarius> dons: With an AllRightsReserved license, would it be appropriate to have on Hackage?
12:35:24 <dons> no.
12:35:32 <dons> so surely that's not what he intends... ?
12:35:48 <dcoutts> and I'm pretty sure hackage will reject packages with AllRightsReserved
12:35:59 <dons> it would.
12:36:07 <dons> i've asked the author to clarify.
12:36:22 <dons> seems *odd* we have this big binding, to a signficant gui lib, that is cabalised, but no on hackage.
12:37:48 <ketil> isn't qt restrictive in its licencing?
12:37:57 <dcoutts> no, it's GPL
12:38:06 <cjb> depends whether you find GPL restrictive ;-)
12:38:13 <ketil> So can you have a non-GPL binding?
12:38:27 <cjb> I think you can pay them for a commercial license
12:38:37 <dcoutts> ketil: yeah, but there's no point since the user of the binding is still bound by the GPL
12:38:52 <cjb> oh, I see what you mean.
12:38:55 <ketil> So....this binding is only useful for commercial licensees, then.
12:39:15 <dcoutts> well, if that was the intention but it seems unlikely
12:39:30 <ketil> I guess you can argue that it is somehow not a derived work...
12:39:40 <dcoutts> I think not :-)
12:39:42 <ketil> Probably just a misunderstanding.
12:39:43 <dcoutts> not a binding
12:40:01 <ketil> Well - it could be derived work of the commerically licensed library :-)
12:40:14 <dcoutts> heh, maybe
12:41:04 <dcoutts> I mean certainly the binding code on it's own can be redistributed under any license, but using it requires a license for qt
12:41:37 <dcoutts> which if you use the gpl will also require you to distribute the binding code under terms that are compatible with the gpl
12:45:17 <ketil> Uh.  qthaskell seems to be LGPLed?
12:45:28 <Heffalump> dcoutts: umm, the binding code would be a derived work
12:46:03 <ketil> http://sourceforge.net/projects/qthaskell/
12:46:56 <agcorona> hi
12:47:08 <ketil> (the page is also an example of what happens when somebody with too much time on their hands plays with javascript)
12:47:28 <dcoutts> Heffalump: probably, but even if one can argue it is not then it's still not usable unless it's compatible
12:55:31 <TomMD> Is there any current effort to revamp Crypto or is it still in a steady state.  I recall some talk about reworking it around the time of Hac 2008 1, but nothing happened.
12:56:42 * luqui got gnome working in conjunction with xmonad and is very happy :-)
12:57:12 <byorgey> luqui: excellent =)
12:57:23 <dons> ketil: that's what it says on the site, yes. not in the .cabal file.
12:58:33 <dons> hitting debian release cycles is hard
13:03:24 <ketil> dons: okay.  Thought maybe you'd missed it.  Anyway: we can download the LGPL version from SF, fix the cabal file, and put it on Hackage.  If need be.
13:03:43 <agcorona> are there a speed comparison between monadic and non monadic code?
13:04:13 <luqui> agcorona, that doesn't really make sense
13:04:26 <agcorona> for example using Maybe either as a monad or not monad?
13:04:26 <Heffalump> agcorona: monadic code goes at speed 3 and non-monadic code at speed 4.
13:04:34 <_zenon_> hehe
13:04:35 <Cale> agcorona: Monad combinators are just a particular API... it's not much different from calling any other functions
13:04:37 <Heffalump> agcorona: that would make no difference.
13:04:52 <Heffalump> well, it's possible that >>= is less or more efficient than an explicit case, but I doubt it.
13:05:15 <luqui> not after optimizations probably
13:05:19 <agcorona> yes but you for example can use list or maybe as monads or not. Are there a overhead for monad use?
13:05:26 <Cale> It's possible, I suppose, that the polymorphism adds a little bit of weight.
13:05:33 <agcorona> I just want to make sure
13:05:44 <luqui> agcorona, why, are you writing a speed critical application?
13:05:46 <Cale> But no, not a significant amount anyway.
13:05:55 <Heffalump> agcorona: do notation desugars in the front-end to >>= and return.
13:06:11 <Heffalump> if your code isn't polymorphic over the monad type then Cale's point is irrelevant
13:06:14 <agcorona> It would  not be very difficult to check the length of assember code or speed for each optimization option
13:07:03 <Cale> My guess is that if it does make a difference, that difference is always so incredibly small that it's the last thing you'll want to worry about.
13:07:05 <agcorona> Heffalump: but monadic code inser closures inside closures. this may add overheads
13:07:11 <agcorona> insert
13:07:12 <Heffalump> agcorona: huh?
13:07:17 <Heffalump> oh, right.
13:07:21 <Heffalump> yes, it's possible.
13:07:27 <T55555> hi, I define repeat x = x : repeat x, it is different as Prelude repeat x = xs where xs = x:xs; any reason Prelude defined that way ? more clear? better performance? what's diffirent compare to my def ? thanks.
13:07:37 <Heffalump> T55555: the Prelude one has more sharing
13:07:46 <Myoma> T55555: better performance
13:07:47 <Heffalump> and only allocates one cons cell
13:07:53 <Heffalump> your one keeps allocating
13:07:58 <agcorona> I just want to know once and for all how much overhead the monad adds
13:08:00 <Olathe> What's a cons cell ?
13:08:07 <Heffalump> (:)
13:08:07 <dmwit_> Olathe: (:)
13:08:22 <Heffalump> agcorona: well, it's not nearly that simple, so the question can't be answered once and for all.
13:08:27 <agcorona> the Clean language people say tnat monads adds a significant overhead. I ¬¥m not sure
13:08:29 <Igloo> agcorona: It depends what the optimiser does
13:08:33 <Cale> T55555: In the Prelude definition, a single constant is defined which is the result of the call to repeat. In your definition, the tail of the list is another, separate call to repeat.
13:08:56 <Olathe> So, it doesn't inline Prelude's repeat ?
13:09:02 <Olathe> And that saves a bit ?
13:09:06 <agcorona> Igloo: yes, I want to test the optimizer too on that
13:09:08 <Olathe> Or fully inline.
13:09:19 <Heffalump> Olathe: GHC doesn't inline recursive functions
13:09:19 <dmwit> Olathe: Er, no, that's not what wins here.
13:09:22 <Igloo> agcorona: But the optimiser might do something else tomorrow, so you can't answer it once and for all
13:09:45 <dmwit> Olathe: What wins is that (xs) points to itself.
13:09:45 <Cale> Olathe: It doesn't do common subexpression elimination, especially not across = signs.
13:10:06 <dmwit> Olathe: But (repeat x) does not point to itself, because it is a function.
13:10:08 <agcorona> Igloo: but at least it could be a good guide about where we are today
13:10:27 <Heffalump> agcorona: if you care a lot, go and run the experiments and let us know the answer
13:10:34 <dmwit> Olathe: I just read a paper two days ago that explains sharing in Haskell, do you want a link?
13:10:38 <Heffalump> but you'll need to run a lot of experiments
13:10:40 <Olathe> Ahh, OK.
13:10:45 <Olathe> dmwit: Sure :)
13:10:45 <agcorona> I tested it and the speed is the same
13:10:46 <Cale> agcorona: If you're afraid of using >>= and return for the list monad, you should be just as afraid of using the functions concatMap and (\x -> [x])
13:11:08 <Cale> Or for that matter, list comprehensions.
13:11:15 <agcorona> I have to re check with more heavy looops because the difference is not noticeable
13:11:15 <dmwit> Olathe: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016
13:11:17 <lambdabot> Title: A Natural Semantics for Lazy Evaluation - CiteSeerX
13:11:26 <Cale> (the list monad is the same thing as list comprehensions)
13:11:34 <Olathe> Why doesn't the optimizer automatically turn repeat x = x : repeat x into the one with xs ?
13:11:37 <luqui> agcorona, it's likely that the speed will be exactly the same
13:11:39 <agcorona> Cale: I just want to answer the Clean people
13:11:43 <Heffalump> Olathe: because it might leak space
13:11:50 <Heffalump> in general, anyway.
13:11:57 <Heffalump> In that case the leak would be tiny.
13:12:01 <Olathe> Why doesn't it do it nongenerally ?
13:12:05 <agcorona> For the Maybe monad at least, with no optimization
13:12:14 <Olathe> Do the implementers hate nongenerality for optimization ?
13:12:15 <Heffalump> actually, the leak would be non-existent
13:12:37 <Cale> It's interesting that this case would mean the exact opposite of a leak
13:12:40 <luqui> Olathe, no, it's just that figuring out when it won't leak is really hard.
13:12:48 <agcorona> I wanted to know if someone else tested that like me
13:12:55 <luqui> I suppose they could put in a special case just for that function, but that would be silly.
13:13:02 <Olathe> Can't it have a memory limit cutoff ?
13:13:04 <Heffalump> hmm. Can you always change foo x = ... foo x ... into foo x = let y = foo x in ... y ... ?
13:13:07 <Heffalump> without causing a leak
13:13:13 <Olathe> Od.
13:13:14 <Olathe> Oh.
13:13:21 <dmwit> Olathe: It amounts to memoization.
13:13:24 <Olathe> Do you mean a runtime optimization ?
13:13:25 <Olathe> Oh, OK.
13:13:27 <Cale> Olathe: It doesn't even know how much memory it's going to use while it's compiling it, and that's impossible to know.
13:13:33 <dmwit> Olathe: Which you don't really want to do in general.
13:13:34 <Olathe> I thought you meant a compiletime optimization.
13:13:47 <luqui> we do mean compile time optimization
13:13:53 <Olathe> Ahh, alright.
13:14:19 <Olathe> dmwit: Thanks for that link.
13:15:28 <newsham> hi
13:16:19 <T55555> ok. thanks. I know it should have some reason to define that way.  ( same as cycle function )
13:16:23 <Myoma> hello
13:16:28 <Myoma> @src cycle
13:16:28 <lambdabot> cycle [] = undefined
13:16:28 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:16:47 <Myoma> :t (cycle, concat . repeat)
13:16:48 <lambdabot> forall a a1. ([a] -> [a], [a1] -> [a1])
13:17:03 <Myoma> @free fix
13:17:05 <lambdabot> f . g = h . f => f (fix g) = fix h
13:17:05 <T55555> cycle x = x ++ cycle x  (==> bad performance )
13:17:19 <newsham> > cycle "vroom! "
13:17:21 <lambdabot>   "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroo...
13:17:23 <Heffalump> @quickcheck \x -> cycle x == concat (repeat x)
13:17:23 <lambdabot> Unknown command, try @list
13:17:31 <dmwit> > say $ cycle "vroom! "
13:17:32 <lambdabot>   vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom...
13:17:33 <Myoma> @src concat
13:17:33 <lambdabot> concat = foldr (++) []
13:17:37 <Myoma> @src repeat
13:17:37 <lambdabot> repeat x = xs where xs = x : xs
13:17:45 <Myoma> repeat = fix . (:)
13:17:50 <Cale> Heffalump: lazy smallcheck might be able to do that one :)
13:17:52 <byorgey> looks like newsham got a new motorcycle
13:18:06 <mapreduce> > fix ("vroom! "++)
13:18:08 <lambdabot>   "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroo...
13:18:13 <Japsu> @index fix
13:18:13 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
13:18:15 <byorgey> > ("motor! " `cycle`)
13:18:16 <lambdabot>   "motor! motor! motor! motor! motor! motor! motor! motor! motor! motor! moto...
13:18:21 <luqui> heh
13:18:29 <agcorona> This is my code to test speed differences between monadic and non monadic code: http://mibbit.com/pb/2MWTJ8
13:18:29 <T55555> thank lambdbot. we are discuss why not   repeat x = x : repeat x
13:18:35 <mapreduce> > repeat "new Runnable(){ public void run(){ "
13:18:38 <lambdabot> Title: Mibbit: PasteBin
13:18:39 <lambdabot>   ["new Runnable(){ public void run(){ ","new Runnable(){ public void run(){ ...
13:18:44 <mapreduce> bah
13:18:47 <agcorona> OPS
13:18:53 <agcorona> sorry
13:18:59 <Myoma> T55555: Can't the compiler do subexpression elimination?
13:19:03 <Japsu> > let cycle = fix . (++) in cycle "boo "
13:19:05 <lambdabot>   "boo boo boo boo boo boo boo boo boo boo boo boo boo boo boo boo boo boo bo...
13:19:20 <Heffalump> Myoma: in general no, because that introduces a space leak
13:19:26 <agcorona> dons ?
13:19:30 <Heffalump> but I was wondering above if you can always do it on recursive calls.
13:19:39 <dons> agcorona: ?
13:19:43 <dmwit> agcorona: take n . repeat = replicate n
13:19:52 <luqui> agcorona, yeah, those two will compile down to the exact same thing IIUC
13:19:58 <dons> its the same thing
13:20:04 <Myoma> m I can't think of one which can cause a space leak
13:21:02 <Myoma> > (fix . (:) . const 'x')()
13:21:03 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
13:21:15 <newsham> > let motor sounds = sounds "vroom! " in motor cycle
13:21:16 <lambdabot>   "vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroom! vroo...
13:21:20 <dmwit> :t foldM
13:21:21 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:21:23 <dons> agcorona: they're literally the same code.
13:22:06 <dons> agcorona: http://hpaste.org/10170
13:23:17 <FunctorSalad> newsham: =)
13:23:42 <dmwit> yesmonad = foldM f -- but with an incomprehensible special case for empty lists
13:25:09 <tibbe> good morning!
13:25:27 <FunctorSalad> evening :)
13:25:34 <dmwit> afternoon!
13:25:44 <dons> nice, haskell powered blog, http://jinjing.blog.easymic.com/
13:25:49 <lambdabot> Title: CÂ§ßË∞É
13:25:51 <dons> using kibro and panda
13:26:38 <FunctorSalad> good layout (seriously)
13:26:55 <dons> yeah
13:26:56 * FunctorSalad dislikes looooong side columns that distract you from the main text
13:28:47 <FunctorSalad> is there some convenience function from calling a Reader from a State or vice versa?
13:28:50 <FunctorSalad> *for
13:29:37 <FunctorSalad> (I guess I mean MonadReader and MonadState)
13:29:39 <znutar> why is the value of do {a <- "b"; b <- 'a' : a; c <- 'a' : a; return a} == "bbbb"?  That doesn't make any sense to me
13:30:16 <Heffalump> znutar: because you're working in a list monad
13:30:20 <Heffalump> what do you expect to happen?
13:30:48 <int-e> > do {a <- "b"; b <- 'a' : a; c <- 'a' : a; return (a, b, c) }
13:30:51 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
13:30:54 <newsham> functor: i wrote one at one point, but cnat find it.
13:31:11 <int-e> uhm. right, that doesn't typecheck
13:31:19 <znutar> I'm just not getting why it's duplicated and concatenated with each implicit >>=
13:31:40 <int-e> > do {a <- "b"; b <- "12"; c <- "xy"; return (a, b, c) }
13:31:48 <lambdabot>   [('b','1','x'),('b','1','y'),('b','2','x'),('b','2','y')]
13:32:02 <newsham> withRead act = get >>= runReader act
13:32:15 <allbery_b> HWN has a bad case of tl;dr :)
13:32:16 <dons> http://www.reddit.com/r/programming/comments/701ns/haskell_weekly_news_unicode_blog_engines_typed/
13:32:18 <lambdabot> Title: Haskell Weekly News: unicode, blog engines, typed printf : programming, http://tinyurl.com/5pwsfl
13:32:19 <dons> go go
13:32:24 <dons> allbery_b: hmm
13:32:24 <newsham> ?type \a -> get >>= runReader a
13:32:27 <lambdabot> forall (m :: * -> *) a b. (MonadState a m) => Reader a (m b) -> m b
13:32:33 <dmwit> > do { a <- "b"; b <- ['a', a]; c <- ['a', a]; return a }
13:32:34 <FunctorSalad> newsham: ah, right
13:32:34 <lambdabot>   "bbbb"
13:32:38 <dons> allbery_b: maybe time to change up the layout.
13:32:40 <allbery_b> (twice, "I didn't resd it but...")
13:32:41 <dmwit> znutar: Think of it this way.
13:33:05 <allbery_b> no, I'm not saying HWN itself is tl;dr; it *says* that twice
13:33:13 <dmwit> znutar: The variable a ranges over values in ['b'].
13:33:45 <dmwit> znutar: Once we have chosen a value for a, the value of b ranges over values in ['a', a], and the value of b ranges over values in ['a', a].
13:33:47 <newsham> ?type \a -> get >>= return . (runReader a)
13:33:48 <lambdabot> forall a (m :: * -> *) a1. (MonadState a m) => Reader a a1 -> m a1
13:34:08 <dmwit> znutar: So there are four possible pairs of (b, c) for any given a.  (They may not all be distinct.)
13:34:20 <allbery_b> this is actually one of the shorter HWNs since byorgey took over
13:34:22 <dmwit> znutar: Now, in the last line of the do, you throw away the values of b and c and just return a.
13:34:55 <dmwit> znutar: So, for each value of a, you get four copies of that value.
13:34:55 <Heffalump> hehe "I would tell you what the discussion has been about but I must confess that I haven't read it" (re <-)
13:35:05 <allbery_b> exactly :)
13:35:13 <FunctorSalad> newsham: I guess the other way (calling a MonadState from a MonadReader) is not so good because the reader would have to discard the changed state
13:35:22 <FunctorSalad> which might not be what you really want to be doing
13:35:30 <znutar> I guess it'
13:35:33 <Heffalump> I'd assumed that very few people apart from the protagonists are reading.
13:35:36 <newsham> unless it is what you want to do.. but yah :)
13:35:39 <znutar> ll make more sense if I unsugar it
13:36:01 <dmwit> znutar: It might also help to write it in comprehension form:
13:36:28 <dmwit> [a | a <- "b", b <- "wx", c <- "yz"]
13:36:53 <dmwit> But note that, for maximum confusion, we've spelled (b <- "wx") as (b <- [a, 'a']) instead.
13:37:41 <newsham> ?type \a -> evalState a <$> ask
13:37:43 <lambdabot> forall a a1 (f :: * -> *). (Functor f, MonadReader a f) => State a a1 -> f a1
13:39:58 <newsham> ?type \a -> ask >>= return . evalState a
13:39:59 <lambdabot> forall a (m :: * -> *) a1. (MonadReader a m) => State a a1 -> m a1
13:40:11 <animesh> hi
13:40:17 <Myoma> hello
13:40:58 <animesh> Hi Myoma, can you tell me how to enable xmonad 0.8 in gnome running on fedora 9
13:41:19 <dmwit> Try #xmonad. ;-)
13:41:47 <animesh> ok, thanks :)
13:43:55 <skorpan> what the heck
13:44:05 <shapr> jag har ingen aning!
13:44:06 <skorpan> the arch linux repos still don't have xmonad 0.8
13:44:18 <Cale> http://www.marriedtothesea.com/ -- haha
13:44:19 <lambdabot> Title: Married To The Sea: "The Champagne of Comics"
13:49:43 <FunctorSalad> is there some way to make the minibuffer in haskell-mode display the signature of more than just prelude functions (on curser-over)?
13:49:47 <FunctorSalad> *cursor
13:49:56 <shapr> yes
13:50:09 <shapr> But I never got around to automating it...
13:50:22 <shapr> It just looks up the signatures in a list, you can add to that list.
13:51:59 <FunctorSalad> shapr: hmm... is there some way to collect the signatures from everything in the ghc-pkg registry?
13:52:17 <dcoutts> FunctorSalad: what kind of sig are you thinking of ?
13:52:19 <shapr> iirc, I was stealing them from haddock interface files
13:52:41 <dcoutts> ah, exported api
13:52:53 <dons> "In actual fact a new release of qtHaskell is imminent
13:52:53 <dons> which, although much improved (imho), is still only a preview, but I'll
13:52:53 <dons> have a look a the license files prior to release."
13:52:57 <FunctorSalad> dcoutts: the type sig (emacs-mode displays it when you move over a known function)
13:53:01 <dcoutts> FunctorSalad: in ghc-6.10, the .hi files contain api hashes
13:53:02 <dons> a GPL freeware
13:53:14 <FunctorSalad> dcoutts: cool
13:53:23 <dcoutts> FunctorSalad: oh, I see. You could use a ghc-api prog to do that.
13:53:35 <FunctorSalad> dcoutts: what's that? a package?
13:53:38 <FunctorSalad> (ghc-api)
13:53:56 <dcoutts> FunctorSalad: the ghc api is a package called 'ghc' it's the api to the compiler
13:54:46 <dcoutts> in a sense the ghc package is ghc and the ghc and ghci programs are front ends to the ghc package
13:55:01 <FunctorSalad> dcoutts: I see. unfortunately I'm still running 6.8.3 :)
13:55:17 <dcoutts> FunctorSalad: ghc package comes with that too
13:55:31 <dcoutts> FunctorSalad: the api hash isn't important for your use case
13:55:50 <dcoutts> I didn't realise at first what kind of signature you meant
13:56:52 <mapreduce> Hmm, Haskell Weekly News is quite low in the google results for, er, Haskell Weekly News. :)
13:57:17 <newsham> has anyone made a serious map-reduce system using haskell?
13:57:23 <FunctorSalad> dcoutts: do you mean the command-line ghc-pkg can dump the exported api type sigs?
13:57:36 <FunctorSalad> or is it a module in the ghc package
13:57:51 <FunctorSalad> oh, think I misread your sentence
13:58:00 <dcoutts> FunctorSalad: no, I mean you could write a program that uses the ghc api to do that
13:58:26 <ddarius> @google "Haskell Weekly News"
13:58:26 <newsham> ie. something designed to run on a few dozen or hundred machines
13:58:30 <lambdabot> http://sequence.complete.org/
13:58:30 <lambdabot> Title: The Haskell Sequence | News about Haskell
13:58:53 <dcoutts> FunctorSalad: I thought there was some emacs shim thing that could already do this, but I don't use emacs so I'm not sure
13:59:35 <FunctorSalad> dcoutts: maybe I just have to set some emacs option, but these things tend to be hard to find...
14:00:05 <FunctorSalad> dcoutts: what do you use to write haskell then?
14:00:10 <shapr> vim!
14:00:17 <dcoutts> FunctorSalad: nedit and vim
14:00:20 <shapr> I think shim might already do that, good point.
14:00:25 <shapr> I never used shim much though.
14:00:27 <FunctorSalad> shapr: does it have a similar feature?
14:00:33 <shapr> I don't remember, sorry.
14:00:40 <FunctorSalad> shim? is that different from haskell-mode?
14:00:43 <mapreduce> I didn't realise sequence.complete.org was HWN, sorry.
14:00:53 <shapr> How do I install cabal on win32?
14:01:09 <dcoutts> shapr: same way as you do on unix, instructions are in the README
14:01:44 <shapr> ok
14:03:19 <newsham> ?brain
14:03:19 <lambdabot> Well, I think so, but Kevin Costner with an English accent?
14:03:59 <Myoma> @bran
14:03:59 <lambdabot> I think so, Brain, but we're already naked.
14:04:05 <Myoma> @quux
14:04:05 <lambdabot> Not enough privileges
14:04:09 <Myoma> :L
14:04:11 <Olathe> @quux
14:04:11 <lambdabot> Not enough privileges
14:04:17 <Myoma> who is the great quux
14:04:17 <shapr> I bet that's @quit
14:04:19 <Olathe> > say "Not enough privileges"
14:04:20 <lambdabot>   Not enough privileges
14:04:29 <trofi> > say "\n"
14:04:30 <lambdabot>   mueval: Prelude.read: no parse
14:04:32 <shapr> @quote myoma
14:04:32 <lambdabot> No quotes match. My brain just exploded
14:04:35 <shapr> aww
14:04:35 <trofi> > say "\\n"
14:04:36 <lambdabot>   \n
14:04:39 <shapr> @quote vixey
14:04:39 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
14:04:43 <trofi> > say "a\na"
14:04:44 <lambdabot>   a
14:04:44 <lambdabot>  a
14:05:27 <trofi> > say "1\n2\n3\n4"
14:05:29 <lambdabot>   1
14:05:29 <lambdabot>  2
14:05:29 <lambdabot>  3
14:05:29 <lambdabot>  4
14:05:41 <dmwit> > say "\n1\n2" -- lines up better =)
14:05:42 <FunctorSalad_> sorry, got disconnected
14:05:43 <lambdabot>   1
14:05:43 <lambdabot>  2
14:05:47 <dmwit> err...
14:06:02 <byorgey> > say "   abc"
14:06:04 <lambdabot>      abc
14:06:04 <FunctorSalad_> is this the latest version? http://code.haskell.org/shim/
14:06:05 <lambdabot> Title: Index of /shim
14:06:18 <byorgey> > say "\n\nfoo"
14:06:19 <lambdabot>   foo
14:06:43 <Myoma> shapr: <vixey> haskell and common lisp are pet language?
14:07:12 <newsham> ?fact: ?fact
14:07:12 <lambdabot> ?fact: ?fact
14:07:14 * shapr grins
14:07:20 <Myoma> ?where ?where
14:07:20 <lambdabot> ?where ?where
14:07:25 <shapr> @shapr shapr
14:07:25 * lambdabot orders her trained monkeys to punch shapr
14:07:27 <Myoma> ?why ?why
14:07:27 <lambdabot> Maybe you meant: ghc thx what wn
14:07:55 <newsham> > say "hi" ++ cycle "\n"
14:07:56 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
14:07:59 <Olathe> @help shapr
14:07:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:08:01 <Myoma> @pl (\u -> u u) (\u -> u u)
14:08:04 <lambdabot> ap id id (ap id id)
14:08:04 <lambdabot> optimization suspended, use @pl-resume to continue.
14:08:09 <Olathe> @sh
14:08:10 <lambdabot> Maybe you meant: shootout show . ? @ ask bf ft ghc id msg pl rc src thx v wn
14:08:12 <shapr> Olathe: I'm just not very helpful
14:08:30 <Olathe> @pl-resume
14:08:37 <lambdabot> ap id id (ap id id)
14:08:37 <lambdabot> optimization suspended, use @pl-resume to continue.
14:08:38 <Myoma> @pl-resum√©
14:08:39 <Olathe> @pl-resume
14:08:48 <Olathe> Myoma: Heheh
14:08:51 <lambdabot> ap id id (ap id id)
14:08:51 <lambdabot> optimization suspended, use @pl-resume to continue.
14:08:54 <Olathe> @pl-resume
14:08:55 <lambdabot> Plugin `pl' failed with: thread killed
14:08:58 <Olathe> Heh
14:09:00 <Myoma> Olathe,
14:09:01 <Myoma> :t ap id id (ap id id)
14:09:04 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
14:09:04 <lambdabot>     Probable cause: `id' is applied to too few arguments
14:09:04 <lambdabot>     In the second argument of `ap', namely `id'
14:09:06 <newsham> > say $ "hi" ++ cycle "\nx"
14:09:08 <lambdabot>   hi
14:09:09 <lambdabot>  x
14:09:09 <lambdabot>  x
14:09:09 <lambdabot>  x
14:09:10 <lambdabot>  x
14:09:12 <lambdabot> Plugin `pl' failed with: thread killed
14:09:14 <lambdabot> [21 @more lines]
14:09:19 <Olathe> Only 21 ?
14:09:21 <dmwit> uh...
14:09:27 <Myoma> @wole
14:09:28 <lambdabot> Maybe you meant: more vote
14:09:33 <Olathe> @Olathe
14:09:34 <trofi> and @more
14:09:34 <lambdabot> Unknown command, try @list
14:09:37 <Olathe> :(
14:09:39 <trofi> :]
14:09:43 <Myoma> @Unknown command, try @list
14:09:43 <lambdabot> Unknown command, try @list
14:09:44 <Olathe> No, :(
14:09:47 <Myoma> :p
14:10:05 <Olathe> > say "Unknown command, try @shapr"
14:10:09 <lambdabot>   Unknown command, try @shapr
14:10:17 <Olathe> @shapr
14:10:18 * lambdabot clobbers  with an untyped language
14:10:25 <Olathe> @slap
14:10:26 * lambdabot slaps  with a slab of concrete
14:10:32 <Myoma> @w80 clobbers
14:10:36 <lambdabot> No match for "clobbers".
14:10:39 <dmwit> ?help thx
14:10:39 <lambdabot> Plugin `help' failed with: Plugin/Dummy.hs:(19,19)-(42,62): Non-exhaustive patterns in case
14:10:44 <dmwit> ?thx
14:10:45 <lambdabot> you are welcome
14:10:50 <shapr> oops
14:10:50 <Olathe> @omg
14:10:50 <lambdabot> Maybe you meant: bug msg
14:11:01 <Myoma> @bug
14:11:10 <dmwit> ?help bug
14:11:19 <dmwit> ?not
14:11:29 <shapr> uh oh
14:11:32 <FunctorSalad_> cabal reports that ghc depends on some old versions of Cabal and bytestring, but the thing I want to install depends on newer versions?
14:11:38 <FunctorSalad_> how can I resolve that?
14:11:54 <shapr> implement cabal bug ?
14:11:59 <dcoutts> heh
14:12:16 <dcoutts> FunctorSalad_: if you need something that needs the ghc package then you are indeed constrained to useing the same versions of things it depends on
14:12:36 <FunctorSalad_> dcoutts: can I rebuild the ghc package to use the new versions?
14:12:40 <dcoutts> FunctorSalad_: nope
14:12:54 <dcoutts> FunctorSalad_: you just have to use the older versions
14:12:57 <FunctorSalad_> ok, how do I force the new package to use the old versions then?
14:13:23 <dcoutts> it should do automatically unless it needs later versions in which case there's a genuine conflict
14:13:57 <dcoutts> FunctorSalad_: which command complains? configure or install ?
14:13:58 <FunctorSalad_> apparently it doesn't need the later versions
14:14:03 <FunctorSalad_> dcoutts: configure
14:14:17 <FunctorSalad_> there's also a warning about missing "build type" though, maybe I should fix that first
14:14:23 <dcoutts> FunctorSalad_: ok, so configure isn't so smart yet, it just picks the latest version of everything
14:14:45 <dcoutts> FunctorSalad_: but it does support --constraint="bytestring <= 0.9.0"
14:14:57 <dcoutts> FunctorSalad_: the build type warning is independent
14:16:30 <Myoma> @quote strict
14:16:30 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
14:16:30 <lambdabot> thing is.
14:18:52 <FunctorSalad_> dcoutts: thanks. now the remaining error is that parsec depends on yet another bytestring version, guess I have to rebuild parsec with contraints too
14:19:07 <dcoutts> FunctorSalad_: try cabal install --dry-run
14:19:15 <binarybandit> @list
14:19:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:19:25 <dcoutts> FunctorSalad_: it'll tell you what it'd rebuild to install the thing you're building
14:20:08 <FunctorSalad_> dcoutts: right, it will rebuild parsec apparently
14:21:56 <alsonk> could I get some help with a rigid types issue?  http://pastebin.com/m3b77df82
14:23:12 <alsonk> The goal is to have Configuration which can be added on top of each other (kind of like Monad Transformers).
14:23:33 <mapreduce> @quote avoiding
14:23:33 <lambdabot> No quotes match. :(
14:23:50 <mapreduce> "Avoiding lambdas is pointless", mentioed in HWN.  I like that :)
14:24:11 <trofi> :t fromEnum
14:24:12 <darrint> What's the shortest code path to listening on a socket?
14:24:14 <lambdabot> forall a. (Enum a) => a -> Int
14:24:23 <trofi> :t toEnum
14:24:24 <lambdabot> forall a. (Enum a) => Int -> a
14:24:37 <trofi> (toEnum 3 :: Char)
14:24:40 <trofi> > (toEnum 3 :: Char)
14:24:43 <lambdabot>   '\ETX'
14:24:59 <trofi> > say "\ETX03green"
14:25:01 <lambdabot>   03green
14:25:38 <alsonk> I'm not sure why (ConfigurationClass cc ) is to rigid to match BaseConfiguration.  http://pastebin.com/m3b77df82
14:26:18 <dmwit> darrint: listenOn :: PortID -> IO Socket
14:31:38 <darrint> thanks
14:31:48 <dons> Found CPPFLAGS in environment: '-I/usr/local/include -I/home/dons/include'
14:31:48 <dons> configure: line 7: fastcgi.buildinfo.in: No such file or directory
14:31:48 <dons> cabal: Error: some packages failed to install:
14:31:49 <dons> fastcgi-3001.0.2 failed during the configure step. The exception was:
14:31:50 <dons> hmm.
14:32:04 <dons> i can't really imagine fastcgi has been broken since the release.
14:32:43 <dons> nope, it is broken. huh.
14:35:38 <BMeph> dons: Hm, it looks like someone changed the program - my output's at http://hpaste.org/10172
14:36:03 <BMeph> ... never mind.
14:36:08 <FunctorSalad_> alsonk: I'm no expert, but what if you try changing "parenclass = parent" to "parentclass x = parent x"?
14:36:08 <dons> 'changed the program' ?
14:36:16 <dons> yes, that's the expected output, BMeph if fcgi isn't installed
14:36:54 <dons> maybe it relied on a cabal bug to build
14:39:36 <BMeph> dons: Yes, I just noticed that it relies on a binding. One of the "disadvantages" of Open Source, I guess... :)
14:39:47 <dons> well, fcgi is pretty standard.
14:42:33 <dons> dcoutts: around?
14:44:08 <alsonk> FunctorSalad: thanks for checking into it.  the error remains, but now refers to 'x'...
14:45:00 <alsonk> I'm still hung up and the google isn't helping too much...
14:46:44 <FunctorSalad_> alsonk: tried making cc a parameter of CacheConfigurationExtension? unless you're deliberately using what I think is an existential type
14:50:02 <alsonk> FunctorSalad: yeah, I was considering that, but that would force the ordering of the configuration blocks.
14:50:12 <alsonk> So I guess I was going for an existential type...
14:53:17 <Saizan_> ?google wikibook haskell existentials type
14:53:20 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
14:53:20 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ...
14:53:41 <Saizan_> alsonk: that's a good introduction to them ^^^^
14:54:26 <alsonk> Saizan: thanks.  I'll re-read that, but my earlier readings didn't help too much with my issue...
14:54:51 <dmhouse> alsonk: any particular sticking points?
14:55:01 <Saizan_> alsonk: however in CacheConfigurationExtension you're not using an existential type, but rather a polymorphic component, i.e. whatever value you put into parent it must not be of a concrete type
14:55:03 <dmhouse> alsonk: I wrote most that article, I'd be interested to know if you have any suggestions or problems
14:56:42 <Saizan_> alsonk: so i think you want existensials but you've to give up on having parentClass
14:57:11 <alsonk> scraps.  parentClass is the big objective here.
14:57:24 <alsonk> it allows me to simulate a class hierarchy
14:57:33 <FunctorSalad> ok, so now I installed shim successfully, but emacs refuses to load it ("cannot open load file: shim")
14:58:07 <alsonk> dmhouse: your coverage of existential types was good.  Just don't know how it helps me fix my issue.  (probably because I'm not strong enough in ETs)
14:58:10 <dmhouse> FunctorSalad: where did you install it to?
14:58:18 <dmhouse> alsonk: ah, okay.
14:58:48 <FunctorSalad> dmhouse: /usr/local/bin/shim ... maybe I have to replace the example "~/emacs/shim" with just "/usr/local/bin" instead
14:59:32 <dmhouse> FunctorSalad: if you do (mapc 'print load-path) in a lisp-interaction-mode buffer, that will tell you all the places Emacs looks for shim.el[c]
15:00:08 <FunctorSalad> dmhouse: weirdly, it's just "shim" and it's a binary
15:00:24 <FunctorSalad> (the thing which Setup.lhs install installed)
15:00:31 <alsonk> Saizan: I change CCE to use a existential type and things are a bit better now.
15:01:22 <Saizan_> alsonk: yeah, that would work, but i'm skeptic about the usefulness of getParam on existentials
15:01:34 <dmhouse> FunctorSalad: there has to be an Emacs lisp part for Emacs to load, surely
15:02:26 <alsonk> Saizan: I'm trying to get a point where I can do getParam over a stack of configurations without have to unwrap the stack
15:03:08 <alsonk> e.g. getParam conf1 {c = 1, parent = conf2 {targetParam = 2}} targetParam
15:04:32 <Saizan_> alsonk: i see that, but targetParam :: SomeBaseClass -> Int, so you've to know the type of the base CC, while with existentials you're hiding it
15:04:36 <FunctorSalad> dmhouse: oh. the emacs lisp just merrily sits there in the dir where the .cabal file is :)
15:04:50 <dmhouse> FunctorSalad: hehe. Does the INSTALL say anything about it?
15:05:49 <sheyll> hi, what is the equivalent of a java BlockingQueue in haskell, I would like to write a tcp server for multiple clients?
15:05:52 <FunctorSalad> dmhouse: well... "Add this to your ~/.emacs file with the appropiate filenames" :)
15:06:03 <FunctorSalad> dmhouse: guess it doesn't matter where I put the .el now
15:06:12 <FunctorSalad> (as longs as it's in the load path)
15:06:15 <Saizan_> alsonk: you're basically trying to emulate extensible records, right? you might like the HList paper if you're prone on [ab]using the type system
15:06:37 <dmhouse> FunctorSalad: right. /usr/local/share/emacs/site-lisp and ~/elisp are common
15:06:45 <dmhouse> The former should already been in your load-path
15:07:15 <Saizan_> alsonk: however there might be more natural desing choices for what you want to do in haskell
15:07:24 <alsonk> Saizan: definitely trying to build extensible records.  Also, wanted it to have it be fast...
15:07:25 <sheyll> ok never mind my question, I have found the answer...
15:07:41 <alsonk> Saizan: definitely interested in more idiomatic ways to do this.
15:08:03 <alsonk> Saizan: any suggestions for idioms?
15:09:40 <Saizan_> alsonk: there are no idiomatic ways to have extensible records in haskell afaik, however the HList paper implements them, and the OHaskell paper tracts some other approaches
15:09:43 <hackage> Uploaded to hackage: test-framework 0.1
15:09:43 <hackage> Uploaded to hackage: fastcgi 3001.0.2.1
15:10:33 <Saizan_> alsonk: there are also quite a few proposals for supporting them natively in the type system
15:11:25 <Saizan_> alsonk: seen this page? http://www.haskell.org/haskellwiki/Extensible_record
15:11:27 <lambdabot> Title: Extensible record - HaskellWiki
15:11:28 <FunctorSalad> dmhouse: that did it, thanks again
15:11:40 <alsonk> Saizan: looking now
15:12:43 <dancor> can you write map nonrecursively using fix
15:12:54 <dmwit> ?pl \m -> getCurrentTime >>= \t -> (t, m)
15:12:54 <lambdabot> (getCurrentTime >>=) . flip (,)
15:12:58 <Myoma> dancor: that is recursive :)
15:13:18 <Myoma> :t foldr ((:) . ?f) []
15:13:19 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
15:13:49 <dancor> Myoma: well you know how they say that fix allows you to do recursion implicitly in the lambda calc
15:13:56 <Saizan_> ?type fix (\map f xs -> case xs of [] -> []; (x:xs) -> f x : map f xs)
15:13:58 <lambdabot> forall t a. (t -> a) -> [t] -> [a]
15:14:08 <ddarius> dancor: You can write any recursive function using fix.  Polymorphic recursion may cause issues in Haskell though.
15:14:34 <Saizan_> the translation between recursive-let and fix is mechanic
15:15:20 <Myoma> :t list
15:15:21 <lambdabot> forall t t1. t -> ([t1] -> t) -> [t1] -> t
15:16:18 <alsonk> Saizan: extensible records still don't seem to quite fit with what I want to do overall (the config example is a simple one).  I'm really trying to emulate an OO hierarchy (members + methods), so perhaps I should read up on OOHaskell.
15:17:09 <Saizan_> alsonk: yeah, but it won't be fast
15:17:46 <Myoma> > say (map chr (3:'6':"test"))
15:17:47 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
15:17:57 <Myoma> > say (map chr (3:(map ord ('6':"test"))))
15:17:59 <lambdabot>   6test
15:18:33 <Saizan_> alsonk: at least, OOHaskell isn't. however, may i ask you why you want to do that?
15:18:39 <alsonk> Saizan: actually, it looks as though OOHaskell will be a pretty useful tutorail
15:19:03 <Myoma> alsonk: Have you previous experience with OO programimng?
15:19:17 <alsonk> Saizan: been thinking about web frameworks and how the ones I'm familiar with work.  think that they provide useful frameworks and am looking to model them in Haskell.
15:19:20 <alsonk> Myoma: lots.
15:19:34 <dancor> Myoma: i think the compilable-programs-are-not-context-free proof is harder than just showing there is same a^n b^n c^n subset
15:19:39 <alsonk> Myoma: fair bit in haskell, too, though only as a hobby...
15:19:52 <Myoma> alsonk: Are you sure that OO approach is the best way to implement it?
15:20:18 <Myoma> dancor: why
15:20:42 <dancor> Myoma: bc when you use the pumping lemma you have to think about general w in L
15:20:50 <dancor> with |w| > p
15:21:09 <Saizan_> alsonk: OOHaskell is a quite interesting paper, but it uses HList so you might need to read that before
15:21:12 <Myoma> it's a theroem that a^n b^n c^n is not context free
15:21:27 <alsonk> Myoma: not sure.  that was what came to mind though (naturally, since I live in ASP.NET right now for work)
15:21:32 <dancor> Myoma: yeah but i just mean knowing something about a tiny subset of L may not tell you much about L
15:21:33 <Myoma> you can show your language is the union of that with other stuff
15:21:38 <alsonk> lived in RoR a year ago.
15:21:52 <dancor> Myoma: the set of all strings contains that L' and it is regular even
15:22:03 <Myoma> ok, I see what you mean now
15:22:58 <alsonk> an issue I have with OOHaskell is that IORef based and not so much type-ssytem based
15:23:09 <alsonk> (or so it appears based on cursory review)
15:23:15 <Myoma> every valid AST is context free -- but variable scope makes it context sensitive
15:26:05 <Saizan_> alsonk: it uses IORefs because objects are usually mutable in OO languages, but it also stretches the haskell type system to basically implement structural subtyping in it
15:27:23 <Myoma> alsonk: it may be better to use a functional approach
15:28:30 <flux> quite a round statement. it may be better to use OO also, no?-)
15:28:36 <dancor> actually, are the set of compilable programs recursively enumerable -- compilation is guaranteed to take a finite amount of time right?
15:28:50 <Saizan_> flux: not in haskell :)
15:28:53 <flux> it all depends on the word "better"..
15:28:56 <Myoma> flux: For a TCP server?
15:29:06 <Olathe> Haskell is taking FOREVER ! Oh, wait...
15:29:13 <Myoma> flux: I don't see any pointers that OO is especially practical
15:29:18 <ddarius> dancor: It depends on the language.
15:29:20 <dancor> ghc -Xnondeterminism
15:29:33 <flux> myoma, while there are pointers that functional paradigm is especially practical, and infact more suitable?
15:29:44 <dancor> ddarius: which ones aren't?  c++ templates come to midn
15:29:54 <alsonk> Myoma: not sure how to build datatypes on one another so that the inner datatypes are invisibly accessible from outside the child types.
15:29:54 <Myoma> flux: I don't know, they chose to use haskell
15:30:21 <flux> it very much depends on one's point of view. and I must also agree that functional paradigm goes very well with a functional language ;)
15:30:45 <ddarius> dancor: Any that can perform arbitrary computation at compile-time.  E.g. macro systems such as TH and Lisp's, template metaprogramming, Qi's type language, some dependently typed languages.
15:30:51 <flux> but perhaps OOHaskell does propose valid solutions to problems some people think they have
15:31:01 <alsonk> Myoma: my example above was  getParam conf1 {c = 1, parent = conf2 {targetParam = 2}} targetParam
15:31:08 <Myoma> alsonk: When I have that sort of dead end usually I try to take a few steps back and look for an alternative approach, maybe that's not possible in your case though
15:31:55 <Myoma> you want a mapping from paramater names to values, which can be extended?
15:32:14 <alsonk> ie. I want to pull targetParam out from n-levels away without doing targetParam $ parent conf
15:32:27 <Myoma> alsonk: Why not build it up with lambda
15:32:40 <alsonk> Myoma: what do you mean?
15:32:40 <Saizan_> flux: well, OOHaskell is not pratical, the paper concludes saying that it's mostly a proof of concept, maybe suitable for exploring possible variants on OO type systems
15:33:15 <Myoma> > let s = \x -> "not found" ; s' = \x -> if x == 1 then "one" else s x ; s'' = \x -> if x == 2 then "second" else s' x in map s'' [1,2,3]
15:33:16 <lambdabot>   ["one","second","not found"]
15:33:27 <Myoma> alsonk: such as that ?
15:34:08 <Myoma> (also if you do not have homogenous types then GADTs makes it possible to do things like,  Paramater ty -> ty  instead of String -> String)
15:34:53 <alsonk> Myoma: could you apply that to my example above?:  getParam conf1 {c = 1, parent = conf2 {targetParam = 2}} targetParam
15:35:25 <alsonk> Myoma: how would I extract targetParam without knowing how deeply in the data structure it resides.
15:35:53 <alsonk> Also, the types are heterogeneous.
15:36:38 <Saizan_> alsonk: why not make targetParam a method of a class?
15:36:47 <Saizan_> "typeclass" i mean
15:37:27 <alsonk> what happens when I apply that function to the outer parts of the datastructure?
15:38:11 <Saizan_> class Foo a where targetParam :: a -> TargetParamType, then you can make instances for wrappers that just call targetParam on the inner object
15:38:44 <michaelgg> j #f#
15:38:46 <michaelgg> er
15:38:52 <alsonk> Saizan: if I understand y'all's suggestion, that's kinda what I'm trying to do in my code...
15:39:18 <alsonk> Saizan: just trying to do that automatically
15:39:36 <alsonk> Saizan: rather autotypemagically
15:41:37 <Myoma> alsonk: You can use GADT to deal with hetrogenous
15:41:49 <Myoma> do you know how ?
15:42:19 <Saizan_> alsonk: so not like this? :) http://hpaste.org/10173
15:42:21 <Myoma> traversing down closures is automatic
15:42:35 <dancor> ddarius: maybe {TH programs that compile} is still recursively enumerable, because you can just keep letting the compiler run for longer and longer periods of time before killing it, on each possible program
15:44:15 <alsonk> Saizan: sorta.  but that's kinda brittle.  If you bury A down another level then HasInt B doesn't work anymore
15:44:31 <Myoma> alsonk: (it does)
15:44:48 <alsonk> Myoma: let me look more closely...
15:45:30 <Saizan_> well if you change B then you've to change its instance, yes
15:46:33 <dancor> who was interested in producing random compiling haskell functions (like stochasto-djinn)?  i was thinking it might be cool to start trying a general context-sensitive grammar production-generator (if the set is context-sensitive..)
15:48:28 <alsonk> Myoma: okay.  As long as everyone is HasInt, then it's okay.  But I think that I now need to write a targetParam function for every class.
15:48:47 <Myoma> alsonk: (I  would not do this with typeclasses)
15:48:55 <Myoma> it is a good way though
15:49:21 <alsonk> Myoma: the problem is that I don't know what functions I need at the start.  I need to be able to layer them on or under without having to modify the intervening classes or datatypes.
15:49:42 <Myoma> You want to change the program without modifying the code?
15:51:01 <alsonk> hmm... sorta, I guess.  I want to be able to do "targetParam myConf" whether myConf is conf1{conf2} or conf1{conf2{conf3}}} or conf3{conf2{conf1}}}
15:51:16 <Saizan_> alsonk: why do you need that?
15:51:31 <alsonk> so that I can layer configurations on top of each other easily.
15:51:32 <Saizan_> i mean, why is it so fundamental to your design?
15:51:42 <alsonk> typical OO stuff.
15:51:45 <Saizan_> configurations being?
15:52:02 <Saizan_> well, haskell is not OO by any means :)
15:52:20 <alsonk> configurations are just an example.  It's more for modules.  Adding an AuthenticationConfiguration and function very easily
15:52:31 <alsonk> Saizan: I'm not a Haskell newbie...
15:52:48 <mc__> actually the type system looks somehow a bit OO like to me, but probably I'm completely misunderstanding it ^^
15:53:17 <alsonk> Saizan: I've found some of ASP.NET and RoR's idioms very nice and am trying to use them in Haskell.  Perhaps square peg - round hole
15:54:10 <alsonk> Myoma: I think that you suggested stepping back and seeing if I can't reframe the problem, which I think is an excellent suggestion.
15:54:14 <Saizan_> alsonk: maybe you should look at xmonad, they have configurations that you can easily add and swap, just by importing new functions
15:54:26 * kolmodin is excited to read about the darcs sprint events
15:54:39 <alsonk> Saizan: cool.  I'll check it out.
15:55:59 <Saizan_> mc__: what do you find OO-like about haskell type-system?
15:56:41 <dancor> named records
15:57:03 <skorpan> i don't quite see what's so OO about it
15:57:10 <skorpan> it's in a bunch of non-OO languages as well
15:57:19 <skorpan> (other than haskell)
15:57:45 <dancor> typeclasses seem like interfaces too
15:59:24 <mc__> Saizan_: well I think of datatypes as classes without functions, and typeclasses are like interfaces. I've read somwhere that they are *not* like interfaces, but they still look like them to me
15:59:58 <skorpan> i think realworldhaskell says something about the relationship between type classes and OO interfaces
16:00:15 <mc__> yeah, it says that they are completely different
16:00:20 <mc__> but not why IIRC
16:00:52 <Saizan_> the main difference is that interfaces are types, while typeclasses aren't
16:01:38 <mc__> still kinda interface alike
16:02:25 <yitz> Saizan_: interfaces are virtual types, so it amounts to pretty much the same thing
16:02:51 <roconnor> Myoma: Try not to let Smerdyakov get to you.  Sometimes his comments aren't very helpful.
16:03:31 <lucca> hm, I really like tracking the RSS feed for new hackage packages... nearly every day something pops up and I think "Oh!  I need to go do something with that..."
16:03:32 <yitz> Saizan_: ie you can't instantiate an interface, only subtype it. Subtyping it is like saying that the subtype is a member of the class.
16:04:19 <mc__> but you could have a type corresponding to a typeclass
16:04:42 <Saizan_> yitz: and then you have a newbie asking why he can't have a list of [Show] full of Int Bool etc :)
16:05:15 <Myoma> roconnor: I am being totally off topic ~_~
16:05:26 <mgsloan> [Show] totally makes sense though!
16:05:33 <Saizan_> yitz: or data Vector = V Num Num Num
16:06:16 <Myoma> mmmm
16:06:18 <Saizan_> mgsloan: with data Show = forall a. => Show a, yes
16:06:20 <Myoma> weirda
16:06:29 <Botje> on april fools ghc should accept Nom too
16:06:32 <Botje> V Nom Nom nom
16:06:39 <Myoma> nobody has experimented with using real logic programming languages as type class?
16:07:34 <Saizan_> Myoma: backtracking in instance resolution gets a bit weird with separate compilation, afaiu
16:07:43 <hackage> Uploaded to hackage: test-framework 0.1.1
16:07:43 <hackage> Uploaded to hackage: edit-distance 0.1.1
16:08:01 <Myoma> yeah I was wondering about scrapping the module system and then implementing it with a logic language itsself
16:08:18 <Saizan_> i think it would be quite interesting
16:09:44 <mattam> Myoma: that's quite exactly how type classes are working in Coq right now.
16:10:15 <mattam> I don't get what the module system has to do with that...
16:12:33 <yitz> Saizan_: yeah, that's not the isomorphism I had in mind. :) I do think that they're essentially the same, but that doesn't mean that there's no room for confusion.
16:15:04 <Saizan_> mattam: don't you get the same problems as with OverlappingInstances when you start taking contexts in consideration for instance resolution?
16:16:33 <glguy> @seen dons
16:16:33 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 41m 25s ago.
16:17:31 <mattam> Saizan_: there is almost no control over which instance is chosen and ambiguity is not checked. What's the problem with OverlappingInstances?
16:18:12 <mattam> It's really meant for cases where you see the class as a predicate and only its satisfaction matters, not its actuall contents.
16:18:45 <Saizan_> mattam: eh, in haskell we care about the methods though
16:18:57 <mattam> Of course.
16:19:24 <mattam> It's only a matter of changing the proof search to return all results.
16:20:38 <mattam> I just didn't have time to implement that :)
16:22:20 <Saizan_> mattam: well the problem is that with modules you can have module A that imports B, and end up using different instances for the same type
16:22:44 <mattam> The truth is that it's also somewhat less important in Coq, because values can (and often do) index classes.
16:23:01 <mattam> I see.
16:23:38 <mattam> Is it decidable if two sets of instances overlap in this way?
16:23:47 <mc__> Coq is the worst name ever
16:23:53 <mattam> :)
16:23:56 <dancor> why not have build-depends implicitly include base and haskell98
16:24:20 <skorpan> a lecturer at my school briefly mentioned coq the other day in class
16:24:25 <dancor> is that preparation for h98 becoming obsolete?
16:24:34 <skorpan> "it's called coq which is no coincidence!"
16:25:08 <mattam> mc__: complain to G√©rard Huet
16:25:42 <dancor> does anyone have a cabal-build-depends-guesser
16:25:46 <mc__> I donnt feel like complaining...I mean it is too obvious...probably it is his kind of humor
16:25:47 <Saizan_> if instance resolution is still decidable than i'd think so, since you just have to follow both paths when both match, no?
16:27:36 <mattam> mc__: oh yes. He's a very delicate man. You know the Coq is our national animal.
16:28:08 <mc__> what  nation?
16:28:13 <dcoutts> dancor: what do you mean by a "cabal-build-depends-guesser" ?
16:28:16 <mattam> France of course.
16:28:23 <Myoma> @w80 Coq
16:28:24 <lambdabot> No match for "Coq".
16:29:11 <dancor> dcoutts: well i guess it doesn't have to guess, just keep running 'runhaskell Setup.hs build' adding to the build-depends like until it stops giving missing-depends errors
16:29:39 <dcoutts> dancor: yes, that's in principle possible and it's something we'll have in Cabal eventually
16:29:53 <chessguy_> @where Coq
16:29:53 <lambdabot> I know nothing about coq.
16:30:01 <mattam> Saizan_: yes, that seems possible.
16:30:12 <dancor> dcoutts: do you think its worth it for me to make a hacky script for now
16:30:20 <TomMD> There should be an @ltu plugin :-)
16:30:46 <dcoutts> dancor: how would you do it? ask ghc -M and ghc-pkg ?
16:31:27 <Saizan_> ghc -M lists modules from libraries?
16:31:50 <chessguy_> @where+ Coq http://coq.inria.fr/
16:31:50 <lambdabot> Done.
16:31:59 <chessguy_> just on principle
16:35:02 <dcoutts> Saizan_: hmm, no probably not
16:37:37 <dancor> dcoutts: i was just going to parse the error like i said
16:37:52 <dcoutts> dancor: heh, have fun
16:39:08 <dons> glguy:
16:39:19 <glguy> hi
16:41:08 <Saizan_> dancor: don't do that! i'm going to implement a depends-guesser in the next few hours(?) anyhow
16:41:14 <dancor> Saizan_: yay
16:49:20 <_zenon_> How are you supposed to acces to the value in the Writer monad? listen :: m a -> m (a,w) doesn't match with Writer [String] Int  where I want to use it.
16:49:35 <Myoma> you should use State zenon
16:50:17 <_zenon_> do { tell ["something"] ; x <- listen ; ....}                     Myoma, well, I want to do it with Writer to learn to use it. I've already used State before. Trying to get past that.
16:50:40 <_zenon_> The example from All about monads is pretty good.
16:52:04 <Myoma> @src Writer
16:52:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:52:36 <Saizan_> _zenon_: you use it like do x <- listen (tell ["somwthing"]); ...
16:52:56 <_zenon_> Saizan_, oooooo
16:53:56 <_zenon_> Saizan_, that cleared up quite a lot of confusion
16:53:59 <_zenon_> thanks a lo!
16:54:03 <_zenon_> ++t
17:07:43 <hackage> Uploaded to hackage: CouchDB 0.8.0.2
17:26:27 <glguy> Building fastcgi earns me: ld warning: atom sorting error for _fastcgizm3001zi0zi2zi1_NetworkziFastCGI_FCGXzuRequest_closure_tbl and _fastcgizm3001zi0zi2zi1_NetworkziFastCGI_FCGXzuStream_closure_tbl in dist/build/Network/FastCGI.o
17:26:35 <glguy> What causes that?
17:31:22 <malouin> _fastcgizm3001zi0zi2zi1_NetworkziFastCGI_FCGXzuRequest_closure_tbl and
17:31:29 <malouin> gah, bad paste, sorry.
17:41:04 <augustss> glguy: a bug in the linker on the mac, i believe
17:41:26 <glguy> a benign one?
17:41:45 <augustss> i've never had any problems with the resulting binaries, but i'm not sure
17:42:57 <glguy> OK, thanks.
17:53:01 <unmarshal> there anything better for binary deserialization than Data.BitSyntax?
17:54:41 <adekoba> I'm writing a library to parse and write ID3 tags for mp3's. Should I use binary or parsec, do you think?
17:55:33 <newsham> i wonder why nobody's built an industrial grade haskell map-reduce.  it would enforce the purity restrictions, provide a much richer language, and compile down to faster code that a hand-baked domain specific language
18:05:44 <mapreduce> How would you send new code to existing nodes
18:06:02 <newsham> ?
18:06:33 <CoryDambach> have you heard of GOOGLE
18:06:41 <CoryDambach> I'm pretty sure, that they have done it
18:07:02 <mapreduce> Suppose you have a Haskell map-reduce implementation - how would you envisage sending tasks to nodes, in terms of the code?
18:07:06 <CoryDambach> oh nevermind...Didn't see haskell*
18:07:17 <CoryDambach> Statement Withdrawn!
18:07:44 <hackage> Uploaded to hackage: yeganesh 2.0
18:10:04 <newsham> cory: there are some public ones, too.
18:12:28 <CoryDambach> Yes?  Please go on, I'm a noob, I just want to absorb some of the haskell culture
18:12:37 <CoryDambach> noob when it comes to haskell anyway
18:12:48 <newsham> public non-haskell map-reduce frameworks
18:12:58 <CoryDambach> Ahhh
18:13:24 <newsham> http://en.wikipedia.org/wiki/MapReduce#Implementations
18:13:26 <lambdabot> Title: MapReduce - Wikipedia, the free encyclopedia
18:13:41 <CoryDambach> You could almost certainly find a .net or java implementation of mapreduce, then just use a .Net haskell or Jaskell
18:14:13 <CoryDambach> I use alchemi for distributed computing on .Net
18:14:18 <newsham> dot net haskell?
18:14:26 <CoryDambach> Yeah, I'm sure someone's done it
18:14:28 <CoryDambach> h/o
18:14:45 <CoryDambach> http://www.cin.ufpe.br/~haskell/haskelldotnet/
18:14:47 <lambdabot> Title: The Haskell.NET Project
18:15:01 <CoryDambach> No releases on that one
18:15:03 <dmwit> CoryDambach: "No releases yet."
18:15:58 <newsham> is jaskell haskell?
18:17:07 <CoryDambach> I'm no haskell pro, so a few more qualifications for what makes jaskell haskell would help me answer you
18:17:21 <CoryDambach> http://jaskell.codehaus.org/
18:17:26 <lambdabot> Title: Jaskell - Home
18:17:48 <newsham> *shrug* just asking if its the same language or not.
18:18:58 <chessguy> hey Cale , your "Monads as containers" got headlined in an article about monads in C#: http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
18:19:00 <lambdabot> Title: Yet Another Language Geek : The Marvels of Monads, http://tinyurl.com/6pks8p
18:19:06 <shapr> DrSyzygy: hej!
18:19:34 <Cale> chessguy: heh, yeah, I saw that
18:20:39 <dbueno> Is there a function that will construct a Regex from a string that matches exactly that string?  In elisp, for example, this operation is called "quoting"
18:20:42 <chessguy> oh, you did comment
18:20:48 <dmwit> newsham, CoryDambach: Jaskell doesn't claim to be (and definitely is not) Haskell.
18:22:10 <amarit_03> lolica ce pulama este aici mah:))
18:23:00 <shapr> um
18:23:05 <shapr> portugues?
18:23:20 <CoryDambach> What makes it intolerable?  To me if it was close enough porting existing haskell apps shouldn't be hard right?
18:23:43 <CoryDambach> Whats the biggest haskell program anyway, like 300 lines :P
18:23:46 <newsham> dbueno: does concatMap . (intersperse "\\" . return)    work?
18:23:56 <shapr> CoryDambach: There are lots of large Haskell programs actually.
18:24:06 <TomMD> shapr: don't bother with trolls.
18:24:10 <shapr> ah
18:24:14 <shapr> CoryDambach: Are you trolling?
18:24:18 <CoryDambach> I'm just kidding...I know, but most haskell programs I've seen are very small
18:24:19 <CoryDambach> no
18:24:40 <shapr> CoryDambach: Have you looked at darcs, ghc, hws, InForM or others?
18:25:03 <CoryDambach> Glasgow haskell compiler...Yeah Darcs(heard of it but am drawing a blank)
18:25:09 <shapr> CoryDambach: On the good side, small haskell programs can have the functionality of large programs in other languages.
18:25:11 <dbueno> @type concatMap . (intersperse "\\" . return)
18:25:12 <lambdabot>     Couldn't match expected type `a -> [b]'
18:25:12 <lambdabot>            against inferred type `[[Char]]'
18:25:12 <lambdabot>     Probable cause: `.' is applied to too many arguments
18:25:12 <shapr> @where darcs
18:25:12 <lambdabot> http://darcs.net/
18:25:36 <newsham> > concat $ intersperse "\\" $ map return "test"
18:25:37 <dmwit> xmonad is into the 1000-line range these days, too.
18:25:37 <lambdabot>   "t\\e\\s\\t"
18:25:58 <newsham> i guess i meant  concatMap (\c -> '\\':c:[])
18:26:04 <dmwit> newsham: That looks dangerous.  Does "\\t" in a Regex match the <TAB> character?
18:26:16 * shapr hugs Myoma
18:26:34 <malouin> Hi #haskell -- so I'm reading "Tackling the Awkward Squad", and I'm not familiar with a notation for "algebraic laws" that the author uses on page 16 -- I'm assuming it's in common use; does anyone have a reference that explains the notation?
18:26:36 <newsham> oops.. yup
18:26:49 <shapr> CoryDambach: Have you written much Haskell? How do you think monad transformers compare to objects as abstractions go?
18:27:01 <CoryDambach> Yea I really like the beauty of haskell...
18:27:06 <CoryDambach> I have written very little
18:27:12 <CoryDambach> But if I understand your question
18:27:14 <shapr> This is your chance! ATTACK!
18:27:20 * shapr boings cheerfully
18:27:40 <CoryDambach> Monad Transformers == State Transistion Functions?
18:28:17 <dmwit> malouin: There's not much notation there; (=) is a behavioral equality, and the horizontal line means "these premises yield these conclusions."
18:28:18 <shapr> er, not exactly
18:28:32 <CoryDambach> I don't think I understand the question then
18:28:44 <malouin> dmwit: is . composition?
18:28:48 <shapr> CoryDambach: Where in Alabama are you?
18:28:56 <CoryDambach> Montgomery
18:28:59 <shapr> ah
18:29:04 <shapr> I'm from Birmingham mostly.
18:29:09 <CoryDambach> Cool
18:29:13 <dmwit> malouin: Ah, no, the '.' in a lambda-abstraction just marks the end of the variable name and the beginning of its body.
18:29:22 <shapr> But I live in Boston these days. Though I'm in Oak Ridge TN at the moment.
18:29:43 <dmwit> malouin: (\x. y) is a function whose argument is the variable 'x' and that returns 'y'.
18:29:47 <malouin> dmwit: ok.  I think that covers it.
18:29:52 <malouin> thanks much!
18:30:13 <shapr> CoryDambach: Have you gotten comfortable using monads in Haskell?
18:30:27 <newsham> the   lambda x . m2      is    \x -> m2     in haskell notation
18:30:37 <newsham> just printed up nicer
18:30:53 <CoryDambach> Somewhat
18:31:08 <CoryDambach> I was going to ask earlier
18:31:21 <CoryDambach> Where is the Haskell language specification?
18:31:35 <TomMD> @where haskell98
18:31:35 <lambdabot> http://haskell.org/onlinereport/
18:31:49 <TomMD> @where haskell'
18:31:49 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
18:32:26 <CoryDambach> Thank you!  I found the Gentle intro a tad too gentle, I'm a fan of rigorous language specs
18:32:41 <dmwit> Too gentle... now that is new.
18:33:30 <BMeph> Clever: "In order to get the unary "negative" operator, use (~) instead."
18:33:41 <CoryDambach> Seriously, They go about it in a tutorial like sense, I like hardcore specs like ecma-262 and such  Give me the productions and grammar, the rest is just framework...
18:34:19 <CoryDambach> http://haskell.org/onlinereport/decls.html - I'm in love
18:34:20 <lambdabot> Title: The Haskell 98 Report: Declarations
18:35:44 <CoryDambach> Will you guys be on much longer? My friend is hitting me up for some cod4
18:36:45 <newsham> we're open 24hrs
18:38:06 <CoryDambach> lol, I meant you breathing human beings who (since last time I was on earth) still need sleep.
18:38:39 <newsham> there are hot swap alternatives that cover downtime
18:41:56 <BMeph> London should be coming online in three hours. ;)
18:42:49 <Saizan_> dancor: still there?
18:48:30 <darrint> Is Data.ByteString.Lazy.hPut "lazy" in some non-obvious way?
18:50:33 <Saizan_> darrint: in general writes can't be "lazy", maybe it's a matter of buffering on the handle?
18:51:03 <darrint> Oh. bet that's it. Should I look for a flush function?
18:51:14 <Saizan_> ?hoogle hFlush
18:51:14 <lambdabot> System.IO hFlush :: Handle -> IO ()
18:51:20 <Saizan_> ?hoogle hSetBuffering
18:51:20 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
18:51:40 <darrint> thx!
18:51:46 <Saizan_> np
18:54:21 <darrint> ah. That was it. Thanks again.
18:54:44 <darrint> Is there a way in ghci to ask RTS what threads are running?
18:54:59 <dancor> Saizan_: ya
18:55:19 <Saizan_> dancor: if you want to be an alpha tester you can darcs get --partial http://code.haskell.org/hbuild and call it with the include paths and the exposed-modules or Main as parameters
18:55:19 <lambdabot> Title: Index of /hbuild
18:55:54 <Saizan_> darrint: i never read of such a feature
18:56:40 * dcoutts pushes more changes to the new hackage-server
18:58:08 <dons> go go go!
18:58:19 <dcoutts> it should now cabal install ok
18:58:23 <dcoutts> and find its data files
18:58:32 <dcoutts> and have a sensible organisation for its state files
18:59:49 <dcoutts> more feature hacking tomorrow
18:59:51 <dcoutts> g'night
18:59:55 <Saizan_> yay for a pure haskell server for haskell code :)
19:00:56 <newsham> > gsize "test"
19:00:57 <lambdabot>   mueval: Prelude.read: no parse
19:02:39 <adekoba> hey, would it be best to use Data.Binary or parsec for making a library that will parse mp3 files?
19:02:44 <Saizan_> dancor: if you try it let me know if it worked for you :)
19:03:07 <ddarius> adekoba: Data.Binary
19:03:11 <newsham> i would guess Data.Binary.  but not intimately familiar with the file format
19:03:46 <adekoba> ddarius: roight, thanks.
19:04:12 <newsham> if it has complex structure, you could use Data.Binary for the "tokenizing" phase and a parser for the structural form
19:04:54 <Saizan_> adekoba: see also binary-strict
19:05:21 <dancor> is Cabal 1.4.0.1 the latest version in cabal-install?  it has 1.4.0.2 at http://www.haskell.org/cabal/download.html.  i guess they aren't always in synch?
19:05:22 <lambdabot> Title: The Haskell Cabal
19:05:22 <adekoba> newsham: so it is possible to use parsec as a frontend to Data.Binary?
19:05:38 <dancor> oh wait
19:05:43 <newsham> the token typ eis parameterized, right?
19:05:57 <dons> adekoba: Data.Binary, no question.
19:06:00 <dons> its a binary format.
19:06:03 <dancor> nm i was confused
19:06:42 <newsham> Data.Binary is an amazing library for binary formats.
19:07:04 <ddarius> adekoba: You could do it, but Parsec is more geared to things with rich syntax and is not geared towards shoveling bytes as quickly as possible.
19:07:44 <hackage> Uploaded to hackage: ansi-terminal 0.3.0
19:07:55 <dons> a parsec-like combinator suite for Data.Binary would be a serious contribution.
19:07:58 <adekoba> yeah, makes sense. I guess I was relying on parsec's Either subsystem, where if a parse failed, the whole thing failed. I'm not sure how to go about using that with Data.Binary.
19:08:37 <ddarius> adekoba: Are you sure you need that for the MP3 format?  Most binary formats are designed to be able to be easily parsed in one pass.
19:09:36 <dons> adekoba: oh, you just force the result
19:09:41 <dons> adekoba: or use binary-strict.
19:10:46 <ddarius> dons: Some of the combinators, like many, may make sense, but I don't think there are many formats that would require backtracking.
19:11:27 <adekoba> so, for example, if I wanted to make sure that the file's magic header is ID3, I must do: "B.unpack <$> getLazyByteString 3 >>= \magic -> if magic == [73,68,51] then ..." ?
19:11:29 <dons> right. just a few of them. parsec-like
19:11:31 <dons> not full parsec.
19:11:41 <dons> adekoba: golden rule : never use unpack.
19:12:08 <newsham> when (magic /= [73,85,51]) $ fail "bad magic"
19:12:09 <adekoba> gah. Then B.pack on the [73,68,51]? Haha...
19:12:26 <dons> pack the short thing, don't unpack the long thing. for 3 bytes, it won't matter
19:12:30 <dons> but its kinda bad style for binary parsing.
19:12:54 <newsham> magic <- get; when (magic /= MAGIC) $ fail "bad magic"
19:13:06 <dons> is it a 4 byte int?
19:13:15 <dons> or specifically 3 bytes?
19:13:17 <adekoba> the magic is 3 bytes
19:13:19 <newsham> > map chr [73,85,51]
19:13:21 <lambdabot>   "IU3"
19:13:37 <adekoba> > map chr [73,68,51]
19:13:37 <ddarius> newsham: A little dyslexic?
19:13:38 <lambdabot>   "ID3"
19:13:56 <ddarius> adekoba: There isn't like a nul character following it or anything?
19:14:14 <adekoba> ddarius: no, following that is the version number, e.g. [0,4]
19:14:30 <newsham> magic <- replicateM 3 get; when (magic /= MAGIC)
19:15:07 <adekoba> newsham: would it be good style to use this method throughout?
19:15:20 * ddarius would personally read a word and mask, but he's hacked C++ and asm about as long as Haskell.
19:15:51 <newsham> *shrug*
19:18:05 <dons> yeah, define a type for   the mask
19:18:21 <dons> and define an instance Binary for it that reads a word and a mask
19:20:12 <newsham> newtype Magic = Magic Int deriving Binary;  getVersion m = m .&. 0xff;  getMagic m = m `shiftR` 8
19:20:25 <newsham> er..  Word32
19:24:07 <Myoma> shapr!
19:24:23 * shapr hugs Myoma
19:24:38 <shapr> Hiya my FP friend!
19:24:40 * Myoma hugs shapr
19:24:45 * shapr boings cheerfully
19:26:19 <dblazakis> how do I get the type classes a type is an instance of from interactive?
19:27:20 <TomMD> coutts really fixed up hackage-server - starts like a charm.  Just need to figure out how to add accounts :-)
19:28:58 * shapr boings randomly
19:32:44 <Cale> dblazakis: Try :info MyType
19:33:21 <dblazakis> Cale: perfect, thanks
19:33:27 <Cale> great :)
19:34:45 <Myoma> @quote Calvin
19:34:46 <lambdabot> thetallguy says: Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
19:38:45 <newsham> fortunately for haskell users, real world tigers are dividing in half every 2 years.
19:39:56 <dons> s/know better/not enough imagination/
19:47:33 <Myoma> @quote soccer
19:47:33 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
19:51:33 <Myoma> @quote insane.
19:51:33 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
19:52:03 <newsham> ?brain wonders if pinky is thinking what he's thinking
19:52:04 <lambdabot> I think so, Brain, but there's still a bug stuck in here from last time.
19:54:41 <ddarius> ?brain, "Are you thinking what I'm thinking?"
19:54:41 <lambdabot> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
19:55:23 <newsham> they should have called the command "pinky"
19:55:32 * ddarius is reminded of an old girlfriend.
19:55:35 <Myoma> @nixon
19:55:36 <lambdabot> Sure there are dishonest men in local government. But there are dishonest men in national government too.
19:55:48 <Adamant> @nixon
19:55:48 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
19:55:58 <Myoma> @. elite nixon
19:55:58 <lambdabot> (4$+R0 cou|Dn't E\/EN go To TH3 b4+hRoO/\/\ unL35S Th3 so\/i37 unIoN pU7 T|-|E NICKe1 iN T|-|E 7oIL37.
19:56:13 <newsham> ?farber
19:56:13 <lambdabot> The seeds I've sown have come home to roost.
19:56:30 <Myoma> ?farbar
19:56:30 <lambdabot> Nobody marches with the same drummer.
19:56:38 <Adamant> the best Nixon quote is the one about the Soviet Union and tape recording.
19:58:03 <BMeph> Nobody expects the Haskell Inquisition!
19:58:09 <BMeph> ;)
19:59:17 <Myoma> @devils ?
19:59:17 <lambdabot> No match for "?".
19:59:28 <Myoma> @vera WTF
19:59:29 <lambdabot> *** "wtf" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
19:59:29 <lambdabot> WTF
19:59:30 <lambdabot>      What / Where / Who / Why The Fuck (telecommunication, Usenet, IRC)
19:59:32 <lambdabot>  
20:00:15 <Myoma> ah,
20:00:15 <Myoma> @devils curse
20:00:17 <lambdabot> *** "CURSE" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
20:00:19 <lambdabot> CURSE, v.t.  Energetically to belabor with a verbal slap-stick.  This
20:00:21 <lambdabot> is an operation which in literature, particularly in the drama, is
20:00:23 <lambdabot> commonly fatal to the victim.  Nevertheless, the liability to a
20:00:25 <lambdabot> cursing is a risk that cuts but a small figure in fixing the rates of
20:00:27 <lambdabot> life insurance.
20:00:29 <lambdabot>  
20:01:31 <Myoma> @toeu
20:01:32 <lambdabot> 0. SamB: A way to get multiple results from a google search
20:01:34 <lambdabot> 1. dons: improve formatting of @dict
20:01:36 <lambdabot> 2. dons: write Haskell Manifesto
20:01:38 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
20:01:40 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
20:01:44 <lambdabot> [29 @more lines]
20:02:49 <dcoutts> TomMD: ah, accounts. :-)
20:04:35 <EvilTerran> "help toeu
20:04:39 <EvilTerran> @help toeu
20:04:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:04:44 <EvilTerran> ...
20:04:59 <EvilTerran> also, my " and @ keys appear to have switched to US layout without my keyboard's permission
20:05:38 <bos> @seen augustss
20:05:38 <lambdabot> augustss is in #haskell. I last heard augustss speak 2h 23m 52s ago.
20:07:45 <hackage> Uploaded to hackage: ansi-wl-pprint 0.3.0
20:17:27 * ddarius always enjoys his Catsters
20:31:02 <newsham> lots of ins and outs
21:05:47 <ajdhs> ?pl \x y -> g x (g y)
21:05:47 <lambdabot> (. g) . g
21:06:31 <ajdhs> \msg lambdabot ?pl \(x,y,z) -> (f x, f y, f z)
21:06:40 <Myoma> ?pl \(x,y,z) -> (f x, f y, f z)
21:06:40 <lambdabot> (line 1, column 6):
21:06:40 <lambdabot> unexpected ","
21:06:40 <lambdabot> expecting letter or digit, operator or ")"
21:06:40 <lambdabot> ambiguous use of a non associative operator
21:06:50 <Myoma> ?pl \(x,(y,z)) -> (f x, (f y, f z))
21:06:51 <lambdabot> uncurry ((`ap` snd) . (. fst) . (. ((. f) . (,) . f)) . (.) . (,) . f)
21:07:46 <hackage> Uploaded to hackage: ansi-wl-pprint 0.3.1
21:07:46 <hackage> Uploaded to hackage: ansi-terminal 0.3.1
21:09:32 <EvilTerran> > (f *** (f *** f)) (x,(y,z)) :: (Expr,Expr,Expr)
21:09:33 <lambdabot>       Ambiguous occurrence `x'
21:09:33 <lambdabot>      It could refer to either `L.x', defined a...
21:09:38 <EvilTerran> whaaa
21:09:44 <EvilTerran> > (f *** (f *** f)) (a,(b,c)) :: (Expr,Expr,Expr)
21:09:45 <lambdabot>   Couldn't match expected type `(Expr, Expr, Expr)'
21:09:52 <EvilTerran> > (f *** (f *** f)) (a,(b,c)) :: (Expr,(Expr,Expr))
21:09:53 <lambdabot>   mueval: Prelude.read: no parse
21:09:57 <EvilTerran> bastard
21:10:03 <EvilTerran> (sorry)
21:10:08 <EvilTerran> ?type f *** (f *** f)
21:10:09 <lambdabot> forall (a :: * -> * -> *) b c b1 c1 b' c'. (Arrow a, SimpleReflect.FromExpr (a b' c'), SimpleReflect.FromExpr (a b1 c1), SimpleReflect.FromExpr (a b c)) => a (b, (b1, b')) (c, (c1, c'))
21:10:16 <EvilTerran> doh
21:10:20 <ajdhs> ?pl \x y -> x y
21:10:21 <lambdabot> id
21:10:24 <EvilTerran> ?type \f -> f *** (f *** f)
21:10:25 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, (b, b)) (c, (c, c))
21:10:39 <EvilTerran> Myoma, there you go. finally.
21:11:53 <mmorrow> ?type \f -> ((f *** ((f *** (f *** f)) *** f)) *** f)
21:11:54 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a ((b, ((b, (b, b)), b)), b) ((c, ((c, (c, c)), c)), c)
21:12:46 <mmorrow> ?type \f -> (f *** f) *** f
21:12:47 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a ((b, b), b) ((c, c), c)
21:12:53 <mmorrow> ?type \f -> f *** (f *** f)
21:12:54 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, (b, b)) (c, (c, c))
21:13:07 <mmorrow> (***) and (&&&) are so great
21:13:51 <mmorrow> @pl \(x,(y,x)) -> ((x,y),z)
21:13:51 <lambdabot> ap (ap (flip (flip . ((,) .) . flip (,))) fst) snd . snd
21:14:07 <mmorrow> oh, oops
21:14:11 <mmorrow> @pl \(x,(y,z)) -> ((x,y),z)
21:14:12 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
21:14:28 <mmorrow> @pl \((x,y),z) -> (x,(y,z))
21:14:28 <lambdabot> uncurry (uncurry ((. (,)) . (.) . (,)))
21:15:28 <mmorrow> @pl (   uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))  )  .   (  uncurry (uncurry ((. (,)) . (.) . (,)))    )
21:15:28 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))
21:15:47 <mmorrow> @pl (\(x,(y,z)) -> ((x,y),z)) . (\((x,y),z) -> (x,(y,z)))
21:15:48 <lambdabot> uncurry ((`ap` snd) . (. fst) . ((,) .) . (,)) . uncurry (uncurry ((. (,)) . (.) . (,)))
21:17:29 <EvilTerran> let's not
21:17:39 <Myoma> :t (?x ?y ?x)
21:17:40 <lambdabot> Top level:
21:17:40 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
21:17:40 <lambdabot>       Expected type: t1 -> t -> t2
21:17:45 <Myoma> :t (?x (?y ?x))
21:17:47 <lambdabot> forall t t1. (?y::(t -> t1) -> t, ?x::t -> t1) => t1
21:22:05 <Axman6> @src (***)
21:22:06 <lambdabot> f *** g = first f >>> second g
21:22:15 <Axman6> @src (>>>)
21:22:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:23:30 <EvilTerran> >>> is a primative, iirc
21:23:33 <EvilTerran> ?src (<<<)
21:23:33 <lambdabot> f <<< g = g >>> f
21:23:39 <EvilTerran> ^ but that one isn't :P
21:23:54 <EvilTerran> ?src (->) (>>>)
21:23:55 <lambdabot> f >>> g = g . f
21:24:25 <EvilTerran> ?src Kleisli (>>>)
21:24:26 <lambdabot> Source not found. My mind is going. I can feel it.
21:24:29 <EvilTerran> hrm =/
21:24:40 <jeffwheeler> The 2001 quote needs a comma before "Dave".
21:31:15 <mmorrow> @type callCC
21:31:16 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
21:31:26 <mmorrow> @let let callcc = (\f -> \k -> f (const . k) k) :: ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
21:31:26 <lambdabot>   Parse error
21:31:31 <mmorrow> haa
21:31:32 <Myoma> @instances MonadCont
21:31:33 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
21:31:50 <Myoma> @src Cont
21:31:50 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
21:32:04 <Myoma> @src MonadCont
21:32:04 <lambdabot> class (Monad m) => MonadCont m where
21:32:04 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
21:32:29 <mmorrow> i'm unwrapping
21:32:38 <mmorrow> it works in ghci
21:32:58 <Myoma> @let cwcc = (\f -> \k -> f (const . k) k) :: ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
21:33:01 <lambdabot>  Defined.
21:33:04 <mmorrow> the :t .... ?x  ... possibilties in it are excellent
21:33:08 <Myoma> > cwcc ?x
21:33:10 <lambdabot>       Unbound implicit parameter (?x::(a -> (b -> r) -> r)
21:33:10 <lambdabot>                   ...
21:33:10 <mmorrow> yay
21:33:12 <Myoma> :(
21:33:14 <Myoma> > cwcc ?x ?y
21:33:16 <lambdabot>       Unbound implicit parameters (?x::(a -> (b -> r) -> r)
21:33:16 <lambdabot>                  ...
21:33:27 <mmorrow> > cwcc $ \k -> callCC $ \z -> (z . k) ?x
21:33:29 <lambdabot>       Occurs check: cannot construct the infinite type: r = (b -> r) -> r
21:33:29 <lambdabot>    ...
21:33:33 <mmorrow> > cwcc $ \k -> cwcc $ \z -> (z . k) ?x
21:33:34 <lambdabot>       Unbound implicit parameter (?x::(b -> r) -> r)
21:33:34 <lambdabot>        arising from a us...
21:33:41 <Myoma> > cwcc (\k -> ())
21:33:42 <lambdabot>   Couldn't match expected type `(a -> r) -> r'
21:33:43 <Myoma> > cwcc (\k -> k ())
21:33:44 <lambdabot>       Overlapping instances for Show ((() -> r) -> r)
21:33:44 <lambdabot>        arising from a u...
21:33:48 <Myoma> :t cwcc
21:33:49 <lambdabot> forall a b r. ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
21:33:59 <mmorrow> > cwcc (\k -> k () id)
21:34:00 <lambdabot>       Occurs check: cannot construct the infinite type:
21:34:00 <lambdabot>        b = (() -> b) ...
21:34:16 <mmorrow> > cwcc (\k -> k ()) id
21:34:17 <lambdabot>   ()
21:34:27 <Myoma> > cwcc (\k -> k (\u q -> q u))
21:34:28 <lambdabot>       Overlapping instances for Show (((t -> (t -> t1) -> t1) -> r) -> r)
21:34:28 <lambdabot>    ...
21:34:31 <Myoma> :t cwcc (\k -> k (\u q -> q u))
21:34:32 <lambdabot> forall r t t1. ((t1 -> (t1 -> t) -> t) -> r) -> r
21:34:35 <mmorrow> haha
21:35:18 <mmorrow> @type cwcc (\k -> (\x -> k (x,x))
21:35:19 <lambdabot> parse error (possibly incorrect indentation)
21:35:26 <mmorrow> @type cwcc (\k -> (\x -> k (x,x)))
21:35:28 <lambdabot>     Occurs check: cannot construct the infinite type:
21:35:28 <lambdabot>       a = (a -> r, a -> r)
21:35:28 <lambdabot>       Expected type: a
21:35:38 <Myoma> @type cwcc (\k -> (\x -> k ?huh))
21:35:39 <lambdabot>     Occurs check: cannot construct the infinite type: r = (b -> r) -> r
21:35:39 <lambdabot>     Probable cause: `k' is applied to too few arguments
21:35:39 <lambdabot>     In the expression: k ?huh
21:35:45 <mmorrow> @type cwcc (\k -> k id)
21:35:47 <lambdabot> forall r a. ((a -> a) -> r) -> r
21:35:57 <Myoma> @type cwcc (\k -> (\i -> ?i))
21:35:58 <lambdabot> forall a r. (?i::r) => (a -> r) -> r
21:36:01 <Myoma> @type cwcc (\k -> k (\i -> ?i))
21:36:02 <lambdabot> forall r t t1. (?i::t1) => ((t -> t1) -> r) -> r
21:36:05 <Myoma> oo...
21:36:27 <mmorrow> > cwcc (\k -> k 42) (*20)
21:36:28 <lambdabot>   840
21:36:34 <Myoma> :o
21:36:51 <mmorrow> it's very enlightening messing with the unrolled version
21:36:52 <Myoma> > cwcc (\k -> k (k 1)) (+1)
21:36:53 <lambdabot>       Occurs check: cannot construct the infinite type: b = (b -> r) -> r
21:36:53 <lambdabot>    ...
21:37:13 <Myoma> > 42*20
21:37:14 <lambdabot>   840
21:37:56 <Myoma> > cwcc (\k -> ?k (k 1)) (+1)
21:37:57 <lambdabot>       Unbound implicit parameter (?k::((b -> a) -> a) -> (a -> a) -> a)
21:37:57 <lambdabot>      ...
21:38:16 <mmorrow> haskell won't let you do that
21:38:31 <mmorrow> (i've tried)
21:39:03 <Myoma> hm
21:39:16 <mmorrow> > (cwcc $ \k -> 1 + cwcc $ \z -> k z) 1
21:39:17 <lambdabot>       Occurs check: cannot construct the infinite type:
21:39:17 <lambdabot>        b = b -> (b1 -...
21:39:20 <mmorrow> like in scheme
21:39:41 <mmorrow> err, infinite type errors
21:39:44 <Myoma> :t (cwcc $ \k -> 1 + cwcc $ \z -> k 0)
21:39:45 <lambdabot> forall b r b1. (Num b, Num (((b -> (b1 -> r) -> r) -> (b -> r) -> r) -> (b -> r) -> r)) => (b -> r) -> r
21:40:33 <mmorrow> but grabbing the inner z with the k, then sucking it to the outside, only to then have access to the inner part whenever you call the sucked-out z
21:40:42 <mmorrow> (if that makes any sense)
21:40:49 <Myoma> no it doesn't :p
21:40:54 <mmorrow> hold on
21:41:02 <Myoma> it's ok
21:41:32 <ajdhs> ?pl \x y -> (f *** f) x y
21:41:32 <lambdabot> f *** f
21:42:04 <Myoma> :t join . join $ (***)
21:42:06 <lambdabot>     Couldn't match expected type `(->)' against inferred type `(,)'
21:42:06 <lambdabot>       Expected type: (b -> c) -> (b -> c) -> (b -> c) -> a
21:42:06 <lambdabot>       Inferred type: (b -> c) -> (b -> c) -> (b, b) -> (c, c)
21:42:55 <ajdhs> :t join
21:42:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:43:02 <ajdhs> :t join.join
21:43:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
21:43:10 <ajdhs> join.join (Just Nothing)
21:43:23 <ajdhs> > join.join $ (Just Nothing)
21:43:25 <lambdabot>   Nothing
21:43:33 <ajdhs> join Nothing
21:43:42 <ajdhs> > join Nothing
21:43:44 <lambdabot>   Nothing
21:46:08 <Myoma> > (join . join . join . const (\x y u v -> (x + y)*(u + v))) () 2
21:46:10 <lambdabot>   16
21:49:49 <Axman6> :t sayFunc
21:49:50 <lambdabot> [Int] -> Expr
21:50:12 <Myoma> > sayFunc ((([]++[])++([]++[]))++(([]++[])++([]++[])))
21:50:14 <lambdabot>   map (\x -> 0) []
21:50:21 <mmorrow> Myoma: i was talking about something like this http://hpaste.org/10176, but i didn't quite know how to put it
21:50:28 <Axman6> heh
21:51:21 <Myoma> > sayFunc [0..0]
21:51:22 <lambdabot>   map (\x -> ) [0..0]
21:51:42 <Axman6> > map (\x -> ) [0..0]
21:51:43 <lambdabot>   mueval: Prelude.read: no parse
21:51:50 <Axman6> fail
21:52:08 <Myoma> @@ @run @run sayFunc [5,6,8,4,2]
21:52:11 <lambdabot>   [5,6,8,4,2]
21:52:15 <Myoma> @@ @run @run sayFunc [0,1,0]
21:52:18 <lambdabot>   [0,1,0]
21:52:56 <Axman6> > sayFunc [1,0,-1,0,1,0,-1]
21:52:57 <lambdabot>   map (\x -> (x^5 + (-15)*x^4 + 75*x^3 + (-135)*x^2 + 44*x + 30) `div` 30) [0...
21:53:27 <Axman6> > sayFunc [1,0,-1,0,1,0,-1,0,-1,0,1]
21:53:28 <lambdabot>   map (\x -> ((-22)*x^10 + 995*x^9 + (-19005)*x^8 + 200370*x^7 + (-1283016)*x...
21:54:57 <dmwit> > sayFunc (repeat 1)
21:54:59 <Myoma> @type let j=join(,);(x,y,z,w,p,q,u,v,h)=(j y,j z,j w,j p,j q,j u,j v,j h,()) in x
21:55:04 <lambdabot> (((((((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((
21:55:07 <lambdabot> ), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))), (((((((), ()),
21:55:10 <lambdabot>  ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())
21:55:13 <lambdabot> ), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))))), ((((((((), ()), ((), ())), ((
21:55:16 <lambdabot> (), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ()))))), ((((((), ()), ((), ())), (((), ()),
21:55:19 <lambdabot> [3 @more lines]
21:55:21 <lambdabot>   thread killed
21:55:27 <Myoma> wodms..
21:56:28 <Myoma> @aivr
21:56:28 <lambdabot> I want me grog!
21:56:48 <CoryDambach> ???
21:56:59 <dmwit> CoryDambach: It spell-corrects to ?arr
21:57:02 <dmwit> ?arr
21:57:02 <lambdabot> Swab the deck!
21:57:04 <dmwit> ?arr
21:57:05 <lambdabot> Aye
21:57:15 <mmorrow> @let shft = (\f -> \k -> f (flip id . k) id) :: ((a -> ((r->s)->s)) -> ((r->r)->r)) -> ((a->r)->r)
21:57:19 <lambdabot>  Defined.
21:57:21 <Axman6> Myoma: you're a monster, you'll hurt lambdabot's mouth
21:57:32 <CoryDambach> I'm so confused...
21:57:44 <Myoma> @w80 confused
21:57:45 <lambdabot> *** "confused" wn "WordNet (r) 2.0"
21:57:45 <lambdabot> confused
21:57:45 <lambdabot>      adj 1: perplexed by many conflicting situations or statements;
21:57:45 <lambdabot>             filled with bewilderment; "obviously bemused by his
21:57:45 <lambdabot>             questions"; "bewildered and confused"; "a cloudy and
21:57:47 <lambdabot> [20 @more lines]
21:57:56 <mmorrow> > cwcc (\k -> k 42) (*2)
21:57:58 <lambdabot>   84
21:58:01 <mmorrow> > shft (\k -> k 42) (*2)
21:58:03 <lambdabot>   84
21:58:06 <mmorrow> > cwcc (\k -> ($ 42)) (*2)
21:58:08 <lambdabot>   84
21:58:11 <mmorrow> > shft (\k -> ($ 42)) (*2)
21:58:13 <lambdabot>   42
21:58:27 <CoryDambach> @w80 befuddled
21:58:28 <lambdabot> *** "befuddled" wn "WordNet (r) 2.0"
21:58:28 <lambdabot> befuddled
21:58:28 <lambdabot>      adj 1: stupefied by alcoholic drink; "the wino's poor befuddled
21:58:28 <lambdabot>             mind"; "a mind befogged with drink" [syn: {befogged}]
21:58:28 <lambdabot>      2: perplexed by many conflicting situations or statements;
21:58:30 <lambdabot> [10 @more lines]
21:58:36 <Myoma> > shft (\k -> (k (k 42))) (*2)
21:58:37 <lambdabot>       Occurs check: cannot construct the infinite type: s = (s -> s) -> s
21:58:37 <lambdabot>    ...
21:58:54 <dmwit> mmorrow: O_o
21:59:09 <dmwit> oh, wait
21:59:16 <dmwit> > cwcc ($ 42) (*2)
21:59:19 <lambdabot>   84
21:59:22 <dmwit> > shft ($ 42) (*2)
21:59:24 <lambdabot>   84
21:59:27 <mmorrow> > shft (\k -> (k (k 42))) ?z
21:59:29 <lambdabot>       Unbound implicit parameter (?z::((s -> s) -> s) -> s)
21:59:29 <lambdabot>        arising fr...
21:59:31 <dmwit> ok =)
21:59:50 <mmorrow> > shft (\k -> (k (k 42))) (\f -> f id)
21:59:51 <CoryDambach> @w80 pneumonoultramicroscopicsilicovolcanoconiosis
21:59:52 <lambdabot> No match for "pneumonoultramicroscopicsilicovolcanoconiosis".
21:59:52 <lambdabot>       No instance for (Num ((s -> s) -> s))
21:59:52 <lambdabot>        arising from the literal `...
22:00:42 <mmorrow> > shft (\k -> (k (k ?x))) ($ id)
22:00:43 <lambdabot>       Unbound implicit parameter (?x::(s -> s) -> s)
22:00:43 <lambdabot>        arising from a us...
22:00:54 <mmorrow> > shft (\k -> (k (k fix))) ($ id)
22:00:56 <lambdabot>   mueval: Prelude.read: no parse
22:00:56 <lambdabot>  mueval: *** Exception: stack overflow
22:00:57 <Myoma> @devils mind
22:00:58 <lambdabot> *** "MIND" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
22:01:00 <lambdabot> MIND, n.  A mysterious form of matter secreted by the brain.  Its
22:01:02 <lambdabot> chief activity consists in the endeavor to ascertain its own nature,
22:01:04 <lambdabot> the futility of the attempt being due to the fact that it has nothing
22:01:06 <CoryDambach> @w80 floccinocinihilipilification
22:01:06 <lambdabot> but itself to know itself with.  From the Latin _mens_, a fact unknown
22:01:08 <lambdabot> [5 @more lines]
22:01:10 <lambdabot> No match for "floccinocinihilipilification".
22:01:17 <dmwit> mmorrow: At first I thought shft could tell the difference between (\k -> k 42) and ($ 42)... which would be very naughty indeed!
22:01:29 <mmorrow> dmwit: heh
22:01:52 <mmorrow> dmwit: forbidden magic
22:02:02 <dmwit> yeah!
22:02:10 <Myoma> @vore
22:02:10 <lambdabot> Maybe you meant: more vote
22:02:16 <Myoma> @more
22:02:17 <dmwit> But telling between (\k -> k 42) and (\k -> ($ 42))... well, I'm happy to believe that. =)
22:02:31 <mmorrow> @type shft
22:02:33 <lambdabot> forall a r s. ((a -> (r -> s) -> s) -> (r -> r) -> r) -> (a -> r) -> r
22:02:58 <mmorrow> ((a -> Cont s r) -> Cont r r) -> Cont r a
22:04:46 <Myoma> > length "floccinocinihilipilification"
22:04:47 <lambdabot>   28
22:05:17 <mmorrow> > shft (\k -> k 1) (*2)
22:05:19 <lambdabot>   2
22:05:26 <mmorrow> > shft (\k -> k 1 >>= k) (*2)
22:05:27 <lambdabot>   4
22:05:32 <mmorrow> > shft (\k -> k 1 >>= k >>= k) (*2)
22:05:34 <lambdabot>   8
22:05:46 <Myoma> > shft (\k -> return 1 >>= k >>= k >>= k) (*2)
22:05:48 <lambdabot>   8
22:06:13 <mmorrow> > cwcc (\k -> k 1 >>= k >>= k) (*2)
22:06:15 <lambdabot>   8
22:06:24 <mmorrow> > cwcc (\k -> return 1 >>= k >>= k) (*2)
22:06:26 <lambdabot>   4
22:06:47 <mmorrow> oh, it doesn't work since we're not in the cont monad
22:07:05 <mmorrow> maybe
22:07:56 <Myoma> > shft (\k -> return 1 >>= shft (\c -> return 2 >>= c)) (*2)
22:07:58 <lambdabot>       No instance for (Num (a1 -> (a -> a) -> a))
22:07:58 <lambdabot>        arising from the lit...
22:08:06 <Myoma> > shft (\k -> shft (\c -> return 2 >>= c)) (*2)
22:08:08 <lambdabot>   2
22:08:14 <Myoma> > shft (\k -> shft (\c -> return 2 >>= c >>= k)) (*2)
22:08:16 <lambdabot>   4
22:08:22 <Myoma> > shft (\k -> shft (\c -> return 2 >>= c >>= k) >>= k) (*2)
22:08:24 <lambdabot>   8
22:08:26 <mmorrow> @type shift
22:08:27 <lambdabot> forall a. (Bits a) => a -> Int -> a
22:08:53 <mmorrow> @let shftC f = Cont $ \k -> runCont (f $ Cont . flip id . k) id
22:08:56 <lambdabot>  Defined.
22:10:00 <mmorrow> > shftC (\k -> return 1 >>= k >>= k >>= k) `runCont` id
22:10:02 <lambdabot>   1
22:10:17 <mmorrow> > shftC (\k -> return 1 >>= k >>= k >>= k) `runCont` (*2)
22:10:18 <lambdabot>   8
22:10:24 <mmorrow> > callC (\k -> return 1 >>= k >>= k >>= k) `runCont` (*2)
22:10:26 <lambdabot>   mueval: Prelude.read: no parse
22:10:33 <mmorrow> > callCC (\k -> return 1 >>= k >>= k >>= k) `runCont` (*2)
22:10:35 <lambdabot>   2
22:11:32 <mmorrow> > callCC (\k -> k 1 >>= k >>= k >>= k) `runCont` (*2)
22:11:34 <lambdabot>   2
22:14:50 <Axman6> > Just 1 >>= (+1)
22:14:51 <lambdabot>       No instance for (Num (Maybe b))
22:14:51 <lambdabot>        arising from the literal `1' at ...
22:15:02 <Axman6> > (Just 1) >>= (+1)
22:15:03 <lambdabot>       No instance for (Num (Maybe b))
22:15:04 <lambdabot>        arising from the literal `1' at ...
22:15:25 <Axman6> :t (>>=) :: Maybe a
22:15:27 <lambdabot>     Couldn't match expected type `Maybe a'
22:15:27 <lambdabot>            against inferred type `m a1 -> (a1 -> m b) -> m b'
22:15:32 <Axman6> uh
22:15:37 <Axman6> :src (>>=) :: Maybe a
22:15:43 <Axman6> @src (>>=) :: Maybe a
22:15:43 <lambdabot> Source not found. It can only be attributed to human error.
22:16:11 <CoryDambach> OOOO
22:16:13 <CoryDambach> BURNED
22:16:20 * CoryDambach high fives lambdabot
22:16:21 <BMeph> Axman6: (+1) isn't a 'a -> Maybe b' function. :)
22:16:23 <Axman6> @src (>>=) :: Maybe Int
22:16:24 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:16:27 <Myoma> ?go "It can only be attributed to human error"
22:16:34 <lambdabot> http://www.sciflicks.com/2001/quotes.html
22:16:34 <lambdabot> Title: SciFlicks.com ---> 2001: A Space Odyssey - The Quotes
22:16:34 <Axman6> ah, so it isn't
22:16:57 <Axman6> > (Just 1) >>= (\x -> Just (x+1))
22:16:58 <lambdabot>   Just 2
22:17:02 <Axman6> good
22:17:15 <dmwit> ?src (>>=) Maybe
22:17:15 <lambdabot> Source not found. :(
22:17:35 <dmwit> ?src Maybe (>>=)
22:17:35 <lambdabot> (Just x) >>= k      = k x
22:17:35 <lambdabot> Nothing  >>= _      = Nothing
22:17:47 <L3v1> hi
22:18:08 <BMeph> L3v1: lo
22:18:42 <Axman6> i was wondering if Just a >>= f >>= g etc. could be reduced to Just a >>= (g . f), but i see how it can't
22:19:04 <L3v1> any idea about why splitAt is just implemented by take and drop in Data.List instead of an stand alone impletation?
22:20:00 <Myoma> L3v1: As a specification probably
22:20:12 <Myoma> :t splitAt
22:20:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
22:20:33 <dmwit> L3v1: Because why not?
22:20:48 <dmwit> It's O(m), where m is the input number, anyway.
22:20:49 <L3v1> waooh, there is a specification metions this func?
22:20:59 <Myoma> yes
22:21:03 <Myoma> Haskell Report
22:21:23 <L3v1> even O(m), though O(2m) ...
22:21:34 <dmwit> The Report specifies its behavior using take and drop, but under the hood it's likely to be done better.
22:21:43 <dmwit> ?source Data.List
22:21:43 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:21:50 <Axman6> L3v1: which is still O(m)
22:22:54 <dmwit> ?source GHC.List
22:22:54 <lambdabot> GHC.List not available
22:23:18 <dmwit> L3v1: Why do you think splitAt is implemented as (take, drop)?
22:23:53 <L3v1> ok, yesterday, i was talking about an function delete :: Int -> [a] -> [a]. when testing the code, i tried 3 ver codes.
22:24:56 <Axman6> > init [1,2,3]
22:24:57 <lambdabot>   [1,2]
22:25:11 <L3v1> ver A implemented by just take and drop, ver B by splitAt, and ver C is wrote directly.
22:26:17 <L3v1> A is 3~7% faster than B, and C is 10% faster than A.
22:26:21 <Myoma> @let delete 0 [] = []; delete 0 (x:xs) = xs ; delete n (x:xs) = x:delete (n-1) xs in map (flip delete "abcd") [1..]
22:26:21 <lambdabot>   Parse error
22:26:46 <Myoma> > let delete 0 [] = [] ; delete 0 (x:xs) = xs ; delete n (x:xs) = x:delete (n-1) xs in map (flip delete "abcd") [1..]
22:26:47 <lambdabot>   mueval: Prelude.read: no parse
22:26:47 <lambdabot>  mueval: ["acd","abd","abc","abcd","abcd*** ...
22:27:00 <CoryDambach> Do you guys have a favorite haskell book?
22:27:07 <Axman6> CoryDambach: this one
22:27:10 <CoryDambach> I don't see any in my local programming book stores
22:27:30 <Axman6> (this one == #haskell)
22:27:38 <CoryDambach> lol, K
22:27:49 <L3v1> and then, i look into the source of Data.List, i saw the line of splitAt.
22:28:43 <L3v1> splitAt n l = (take n l, drop n l)
22:29:22 <Axman6> L3v1: what's wrong with that? it's clear, and like dmwit said, it's probably implemented more efficiently under the hood
22:29:24 <Myoma> splitAts :: Int -> [a] -> ([a] -> [a], [a])
22:29:30 <L3v1> i guess that is why ver B is slower than A.
22:29:52 <dmwit> L3v1: Where do you see that?  I don't see that in the Data.List source at all.
22:29:54 <Myoma> L3v1, try it with splitAts? :)
22:30:11 <mmorrow> L3v1: you can do both in parallel (if you have > 1 cores) like  splitAt n l = let a = take n l ; b = drop n l in a `par` b `par` (a,b)
22:30:18 <Axman6> @src splitAts
22:30:18 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:30:24 <mmorrow> (i think that'll work)
22:30:29 <mmorrow> import Control.Parallel
22:31:04 <mmorrow> ghc -O2 -threaded --make Asdf.hs
22:31:11 <mmorrow> ./Asdf +RTS -N2 -RTS
22:31:33 <L3v1> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#splitAt
22:31:35 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/23ncyu
22:35:17 <dmwit> L3v1: Look farther in that file.
22:35:31 <dmwit> You were looking at an #ifdef section that doesn't get visited.
22:35:33 <L3v1> i am not very understand parallel way. and will have a view at splitAts.
22:35:47 <Myoma> L3v1, I invent splitAts
22:36:10 <Myoma> L3v1, let (f,g) = splitAt n xs in f g == xs
22:36:21 <Myoma> oops
22:36:23 <Myoma> L3v1, let (f,g) = splitAts n xs in f g == xs
22:37:22 <dmwit> L3v1: From that file: splitAt (I# n#) ls | n# <# 0# = ([], ls) | otherwise = splitAt# n# ls where ...
22:37:45 <dmwit> That splitAt is more efficient. =)
22:38:26 <mmorrow> L3v1: err, what i just suggested doesn't work at all ;)
22:38:49 <mmorrow> but a similar thing works with   sum xs / length xs
22:39:20 <L3v1> errrrrr, i dont very understand that code. could you give me a hand ?
22:39:35 <mmorrow> splitAt (I# n#) ls | n# <# 0# = ([], ls) | otherwise = splitAt# n# ls
22:39:49 <dmwit> '#' means unboxed
22:40:05 <dmwit> (You can think of it as "primitive" if you don't know what boxed means.)
22:40:35 <dmwit> So n# <# 0# does the comparison "on the bare metal" so to speak.
22:40:50 <Myoma> :t let  splitAts 0 xs = (id,xs)  ;  splitAts n (x:xs) = let (f,g) = splitAts (n-1) xs in ((x:) . f,g)   in splitAts
22:40:52 <lambdabot> forall t t1. (Num t) => t -> [t1] -> ([t1] -> [t1], [t1])
22:41:26 <dmwit> L3v1: Other than the #s, it's pretty straightforward recursion.
22:41:42 <mmorrow> 4 == I# 4#
22:41:47 <Trinithis> :t shft
22:41:49 <lambdabot> forall a r s. ((a -> (r -> s) -> s) -> (r -> r) -> r) -> (a -> r) -> r
22:41:59 <Trinithis> @src shft
22:41:59 <lambdabot> Source not found. I feel much better now.
22:42:08 <mmorrow> @let shft = (\f -> \k -> f (flip id . k) id) :: ((a -> ((r->s)->s)) -> ((r->r)->r)) -> ((a->r)->r)
22:42:09 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
22:42:16 <Myoma> @unfed
22:42:16 <lambdabot> Unknown command, try @list
22:42:23 <Trinithis> what's the semantics of shft?
22:42:28 <Trinithis> in english
22:42:30 <mmorrow> @let shiftCC f = Cont $ \k -> runCont (f $ Cont . flip id . k) id
22:42:33 <lambdabot>  Defined.
22:42:40 <mmorrow> this is what made it clear to me...
22:43:02 <mmorrow> > callCC (\k -> k 1) `runCont` (*2)
22:43:03 <lambdabot>   2
22:43:07 <mmorrow> > callCC (\k -> return 1) `runCont` (*2)
22:43:08 <lambdabot>   2
22:43:15 <mmorrow> > shiftCC (\k -> k 1) `runCont` (*2)
22:43:16 <lambdabot>   2
22:43:19 <mmorrow> > shiftCC (\k -> return 1) `runCont` (*2)
22:43:20 <lambdabot>   1
22:43:32 <mmorrow> .
22:43:41 <mmorrow> then you can do
22:43:50 <mmorrow> > shiftCC (\k -> k 1 >>= k) `runCont` (*2)
22:43:52 <lambdabot>   4
22:43:53 <L3v1> nmmm, i know sth. about box, and what does (I# n#) mean?
22:43:56 <mmorrow> > shiftCC (\k -> k 1 >>= k >>= k) `runCont` (*2)
22:43:57 <lambdabot>   8
22:44:05 <mmorrow> > callCC (\k -> k 1 >>= k) `runCont` (*2)
22:44:07 <lambdabot>   2
22:44:10 <mmorrow> > callCC (\k -> k 1 >>= k >>= k) `runCont` (*2)
22:44:11 <lambdabot>   2
22:44:37 <Trinithis> so the continuation gets 'repeated' ?
22:44:53 <mmorrow> it essentially (with shift) /becomes/ k
22:44:58 <Myoma> > callCC (\k -> 100 * (return 1 >>= k)) `runCont` (*2)
22:44:59 <lambdabot>       No instance for (Num (Cont b b))
22:44:59 <lambdabot>        arising from the literal `100' ...
22:45:15 <mmorrow> and shift doesn't abort like callCC does when you apply k to something
22:45:24 <Myoma> > callCC (\k -> (return 1 >>= k) >>= (100 *)) `runCont` (*2)
22:45:26 <lambdabot>       No instance for (Num (Cont a a))
22:45:26 <lambdabot>        arising from the literal `100' ...
22:45:46 <ivanm> if I have a tuple of type (a,a), is there a simpler way than (f***f) to apply a function to both elements in the tuple?
22:45:47 <Trinithis> oh
22:45:47 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
22:46:05 <Myoma> ivanm, simpler....?
22:46:27 <mmorrow> Trinithis: cool, huh.
22:46:33 <ivanm> Myoma: well, fmap f doesn't work...
22:46:37 <Trinithis> yeah :D
22:46:42 <mmorrow> :)
22:46:43 <ivanm> since it only applies the function to the 2nd element
22:46:46 <L3v1> oh, how do you pronounce `tuple
22:46:48 <L3v1> ?
22:47:05 <Myoma> 2pill
22:47:21 <BMeph> L3v1: You mean, "TOO-pull"? :)
22:47:32 <Myoma> tupple
22:47:34 * ivanm pronounces it something like "tah-pull"
22:47:53 <Trinithis> well, i think im going to bed... thanks for the insight mmorrow
22:47:59 <mmorrow> Trinithis: night
22:48:45 <L3v1> ok, thank you all, especially dmwit. thank you.
22:49:23 <L3v1> i m going, c u.
22:50:05 <BMeph> ivanm: Did you mean 'join(***)'? :)
22:50:31 <ivanm> @type join (***)
22:50:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:50:52 <ivanm> hmmmm.... not really that much simpler (by simpler, I meant shorter :p )
22:50:53 <ivanm> oh well
22:51:36 <Myoma> let t = join (***) in t f
22:51:45 <BMeph> ivanm: If your heart's set on it, you could always define an operator to do it for you. I use '<>', I believe. :)
22:51:54 <ivanm> fair enough
22:53:05 <mmorrow> ivanm: i usually just do (so i don't have ot import Control.Arrow)  f *** g = \(a,b) -> (f a,g b)
22:53:28 <mmorrow> :: (a -> c) -> (b -> d) -> (a,b) -> (c,d)
22:53:47 <ivanm> does it really make a difference between you defining that, and importing Control.Arrow?
22:53:59 <mmorrow> to me it does ;)
22:54:04 <ivanm> mmorrow: btw, for some reason my program kept segfaulting when I tried to use your memo package :(
22:54:16 <ivanm> had to resort to using arrays instead
22:54:23 <mmorrow> yeah, i saw your msg. heh. so you can't recurse with it...
22:54:37 <ivanm> looks like it
22:55:09 <mmorrow> yeah, it's like that with all memo funcs like that
22:55:46 <mmorrow> i can't remember what goes wrong, but i remember reading about it somewhere
22:56:06 <ivanm> :(
22:56:45 <reified> L3: I pronounce it tyuupull
23:02:45 <chrisdone> mmorrow hates importing things :p
23:04:52 <mmorrow> chrisdone: hah. it's true.
23:14:21 <ajdhs> is there any way to desugar a GHC-extended program into haskell 98?
23:14:43 <Myoma> ?where reality
23:14:44 <lambdabot> I know nothing about reality.
23:14:55 <dons> ajdhs: no.
23:15:03 <ajdhs> hm
23:15:07 <dons> ajdhs: not an arbitrary extension.
23:15:15 <dons> some constructs can be recoded in h98
23:15:25 <dons> type system things mainly, are the issue.
23:15:27 <ajdhs> of course
23:15:35 <Axman6> dons: you're in aus aren't you?
23:15:53 <dmwit> Huh, there's no Core -> Haskell conversion possible?
23:15:54 <dons> Axman6: i was. moved to the US a year ago.
23:15:58 <ajdhs> but it would be nice if such things as pattern guards, etc. could be automatically recoded
23:16:03 <Axman6> ah, righto
23:16:04 <dons> dmwit: right.
23:16:12 <Myoma> ajdhs: Why
23:16:12 <dons> ajdhs: oh, pattern guards can be.
23:16:22 <dons> you can look up the translation in the user's guide.
23:16:36 <dons> but there's little reason to aim at h98.
23:16:42 <P_D> does ghc's immutable array implementation ever optimize away unnecessary copies?
23:16:45 <dons> just make sure you use haskell' extensions only
23:17:01 <P_D> or am I thinking about it wrong
23:17:03 <dons> P_D: what kind of optimisation would that be?
23:17:18 <dons> and which immutable arrays?
23:17:30 <dons> (the uvector immutable arrays remove redundant copies via fusion)
23:17:39 <dons> (diff arrays remove redundant copies via transaction logs)
23:18:01 <dons> (mutable arrays remove redundant copies by destroying the history)
23:18:06 <P_D> I want to update an array functionally, but I'll never use the old array
23:18:08 <ajdhs> oh, has haskell98 been pretty much abandoned then?
23:18:19 <dons> ajdhs: subsumed. it was 10 years ago.
23:18:32 <dmwit> P_D: You might want to look at STArrays, then.
23:18:33 <ajdhs> heh, ok
23:18:33 <dons> a lot has been developed in typed, pure functional languages in that time.
23:18:40 <Axman6> are there plans for a new report?
23:18:43 <dons> haskell-prime is the new standard set.
23:18:44 <P_D> ok, thanks
23:19:03 <ajdhs> is there a definitive guide to what's going to be in haskell' and what's not, or is it still in flux?
23:19:44 <dons> http://hackage.haskell.org/trac/haskell-prime/wiki/Status
23:19:51 <lambdabot> Title: Status - Haskell Prime - Trac
23:20:42 <thoughtpolice> ajdhs: h98 is certainly nice but a lot of the extensions are incredibly useful and are sure to be in the next standard; lots has been done
23:20:46 <dons> the single most important result has be the introduction of extension flags.
23:20:53 <dons> so you can precisely state what you want to enable.
23:21:03 <dons> that allows people to write conservatibly haskell-prime programs
23:21:04 <thoughtpolice> associated types, MPTCs, existential quantification and rank types
23:21:04 <thoughtpolice> etc.
23:21:38 <ajdhs> ok
23:21:46 <ajdhs> thanks a lot guys
23:22:08 <thoughtpolice> imo that's kind of the reason lots of people see GHC as 'haskell' itself, once haskell' is codified I suspect the availability of compilers for it will stretch a bit beyond ghc
23:22:34 <thoughtpolice> especially considering all the great research in those areas has been done :]
23:23:06 <dons> i'm not sure it matters much if there are other compilers, just as long as the language is well defined.
23:23:26 <dons> it's a significant engineering effort, so concentrating effort to produce one killer compiler works for me.
23:23:39 <dons> it made much more sense early on to have competition between the groups, driving new language ideas.
23:23:50 <dons> after 20 years, its more of a stabilisation process.
23:23:57 <dons> people fork ghc now to do research
23:24:06 <dons> rather than writing new compilers from scratch
23:24:19 <dons> (though that does still happen: DDC, chameleon, epigram)
23:24:27 <stepcut> dons: what if GHC was more modular, so you compete in more specific areas
23:24:42 <dons> that'd help. it's definetely on the big side.
23:24:43 <thoughtpolice> indeed. but if someone wanted to, like I said lots of the research has been done so it could be much less of a trial-and-err process and more of just getting-it-done
23:24:47 <dons> and on the monolithic side.
23:24:57 <dons> thoughtpolice: yep.
23:25:13 <dons> you could do a good job starting with a clean implementation
23:25:15 <stepcut> dons: the GHC plugins GSoC project maybe have helped with that a bit I guess ?
23:25:17 <thoughtpolice> i still see a place for other compilers though, e.g. jhc which targets ISO C which is dandy useful
23:25:20 <dons> jhc did, for example.
23:25:35 <dons> thoughtpolice: right. that pushes ghc to lift its game.
23:25:49 <thoughtpolice> dons: it is one of my longer term goals to write at least a h98 compiler - i like john's reasoning behind it. plus I see it as not completely infeasible since yeah, the work's there, you just have to use it.
23:25:51 <dons> but pressure from entirely different languages is a driver now too.
23:26:16 <stepcut> DDC is intriguing
23:27:06 * stepcut still hasn't figure out which dependently-typed language to learn first
23:27:41 <Myoma> stepcut: Well what do you want to program?
23:27:44 <thoughtpolice> plus if i'm going to do that - library it! i suspect there's lots of pieces that might be useful out of a generable haskell compiler, e.g. codegen perhaps. plus there's already some stuff there, e.g. haskell-src(-exts) takes care of parsing entirely
23:27:55 <thoughtpolice> generable? :p
23:27:57 * thoughtpolice is tired
23:28:04 <stepcut> Myoma: real world applications, of course :)
23:28:13 <Myoma> yes  , such as ...?
23:29:04 <stepcut> Myoma: virtual synths and effects and web applications mostly
23:30:20 <thoughtpolice> for near-dependent types I really like the assoc types + gadts approach described in spj's paper. doesn't cover everything, but I think the approach could definitely be usable for adding invariants to general data structures without much hassle
23:31:13 <Myoma> thoughtpolice: what is the paper called?
23:31:16 <thoughtpolice> plus i do like associated types more than e.g. fundeps. easier to grok and are functional instead of relational
23:32:14 <thoughtpolice> Myoma: the general idea is kind of introduced in the intro, haven't gotten all the way through it (shows a real easy way to encode length on vectors at the type level, plus it's actually grokable by most I figure)
23:32:17 <thoughtpolice> Myoma: just a sec,
23:33:12 <thoughtpolice> http://research.microsoft.com/~simonpj/papers/assoc-types/index.htm
23:33:14 <lambdabot> Title: Indexed type families, http://tinyurl.com/5aho9t
23:33:17 <stepcut> I have some experience simulating dependent types in Haskell, but I think I would like to working with a real dependently typed language for a while
23:33:17 <thoughtpolice> "type checking with open type functions"
23:33:22 <Myoma> thanks
23:33:47 <Myoma> I don't think anything you can do in haskell is even remotely like dependent types
23:34:29 <thoughtpolice> oleg?
23:35:05 <P_D> is there an instance for fmap on >2 tuples hiding somewhere?
23:35:11 <thoughtpolice> he gets damn near there if nothing else
23:35:13 <dons> Myoma: sure there is.
23:35:49 <dons> its approaching a dependently typed language from System F
23:35:49 <thoughtpolice> speaking of oleg, perhaps converting some of his stuff would be a good stress for ghc's new assoc. types :]
23:36:12 <Myoma> > fmap (+1) ((((),3),2),1)
23:36:14 <lambdabot>   ((((),3),2),2)
23:36:41 <thoughtpolice> (i don't know if anything's been pushed to the HEAD yet about getting them 'working' though; not sure if the HEAD is far off from 6.8 in that area)
23:36:43 <P_D> it's ugly, but that works.
23:36:49 <thoughtpolice> have to ask ChilliX
23:36:54 <Myoma> P_D, why is it ugly?
23:37:07 <Myoma> > let (*) = (,) in fmap (+1) (() * 3 * 2 * 1)
23:37:09 <lambdabot>   ((((),3),2),2)
23:37:43 <P_D> you don't think it's uglier than (a,b,c)?
23:38:09 <Myoma> P_D: I'd have to see an entire program to form an opinion
23:38:21 <P_D> it's just one expression
23:38:46 <mornfall> Btw... anyone tried to do high-performance threaded computation in haskell? I have tried to benchmark the channel primitives, but they don't seem to stand up to what I can do in C++... :| It's some 6 vs 1.5 million integers per second pushing data from one thread to another...
23:38:54 <P_D> how do you write a short little length-safe thing
23:39:10 <Myoma> I'm not sure what you mean
23:39:24 <mornfall> (Well, 1.5 is around the best I got to, experimented with various options and channel implementations...)
23:39:33 <dmwit> P_D: It's easy to write such an instance if it doesn't exist already.
23:40:38 <P_D> OK:  how?  instance Functor (a,a,a) where chokes on kind mismatch
23:40:42 <dons> mornfall: using Strict.Chan ?
23:40:47 <dons> mornfall: or just normal lazy Chan?
23:40:49 <dmwit> instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)
23:40:57 <mornfall> dons: I tried both, and also the STM TCHan.
23:40:59 <mornfall> TChan*
23:41:02 <Myoma> P_D: I Think you have to use Triple a = Triple a a a
23:41:04 <dons> mornfall: i've certainly done some pretty heavy concurrency in general.
23:41:10 <dons> TChan would be slower.
23:41:16 <dons> (STM is a bit slower than MVars)
23:41:18 <mornfall> Yeah, t'was.
23:41:30 <dons> what are you doing in C++ though?
23:41:31 <dmwit> P_D: If you want it applied to all values in the tuple, then you have to use Myoma's trick.
23:41:43 <dons> machine-level semaphores?
23:41:50 <mornfall> dons: No locking there.
23:41:53 <Myoma> you can't write instance Functor (forall a. (a,a,a)) or /\a. (a,a,a) or anything like thta
23:41:57 <stepcut> mornfall: you used forkIO and not forkOS right ?
23:41:58 <mornfall> dons: Lockless ring-buffered FIFO.
23:42:07 <P_D> ok, thanks.
23:42:10 <mornfall> stepcut: I tried both. forkOS is much slower.
23:42:12 <dons> how is that comparable though?
23:42:22 <dons> or you're just trying to work out what  the overhead is?
23:42:29 <stepcut> mornfall: just checking ;)
23:42:30 <mornfall> dons: Sort of.
23:42:33 <Myoma> iirc you _can_ do that in system F and depndent types
23:42:45 <mornfall> dons: And whether it would be feasible to convert that to Haskell.
23:42:49 <dons> i'd just look at MVars versus Ptrs first, to try to work out what the threading overhead is.
23:43:07 <dons> and maybe look at what happens when you add extra cores (is that the goal?)
23:43:09 <mornfall> dons: I have sort of hoped that the Chan in Haskell wouldn't do locking (as it doesn't need to).
23:43:18 <dmwit> GHC seems fine with my first one if you want to have fmap apply only to the third element.
23:43:21 <dons> well, it is 2 MVars
23:43:31 <mornfall> Ah, hmm.
23:43:36 <mornfall> That might be a problem, then.
23:43:41 <dons> data Chan a
23:43:42 <dons>  = Chan (MVar (Stream a))
23:43:42 <dons>         (MVar (Stream a))
23:43:42 <mornfall> Locks are expensive.
23:43:44 <sjanssen> mornfall: you actually tested TChan?  There is a decent chance it will be faster
23:43:48 <dons> type Stream a = MVar (ChItem a)
23:43:53 <dons> with more mvars for each item.
23:44:06 <dons> yeah, might be time to hpaste some code.
23:44:16 <dons> data ChItem a = ChItem a (Stream a)
23:44:17 <mornfall> sjanssen: Let me actually re-try.
23:44:33 <dons> seems like a lot of MVars
23:45:21 <dons> i'm not sure anyone's studied the overhead of things other than basic transactional variables and mvars in a while. things like Chan are used, but don't get much love from optimisation hackers
23:45:42 <sjanssen> mornfall: there's also IORef which has no locking
23:45:47 <dons> an threadsafe, unboxed ring would be interesting.
23:45:59 <sjanssen> (but I don't necessarily encourage this in today's threaded world)
23:46:20 <mornfall> dons: Well, a ring is bounded, but there are ways to make it unbounded without use of locks.
23:46:28 <dons> yeah, given you can get, say, a 2-4x speedup just by adding more cores, that kinda hits back at the 4x slowdown on 1 core.
23:46:52 <dons> mornfall: if there's a very specific structure that works for you in C++, you might just port that?
23:47:01 <dons> and then use forkIO liberally
23:48:17 <mornfall> dons: I *think* it should work in general. I just don't have too much experience with low-level Haskell.
23:48:57 <dons> you could paste the code and we could talk about it  :)
23:49:07 <dons> hard to know what you're doing yet though
23:49:49 <sjanssen> mornfall: how does one guarantee safety in your buffer?
23:49:55 <sjanssen> (the C++ version, I mean)
23:54:37 <mornfall> sjanssen: It's a linked list of ringbuffers. Implementing a lock-less ringbuffer isn't that hard, you use two counters, right? The way they are linked together is from citeseer.ist.psu.edu/michael96simple.html
23:56:08 <dinc> Eaton Corporation  uses Haskell to control hybrid vehicles -Amazing! Never heard about haskell till now.
23:56:17 <mornfall> sjanssen: Actually, if you only demand one-reader-one-writer scenario, the presented algorith can be implemented without atomic operations altogether.
23:56:50 <mornfall> sjanssen: (And that's what I do. It's probably less general than the Haskell chan? Does it do multiple readers or multiple writers? (Or both?))
23:57:29 <sjanssen> mornfall: it makes no restrictions on the readers or writers
23:57:29 <dons> dinc: welcome.
23:57:31 <dons> ?users
23:57:32 <lambdabot> Maximum users seen in #haskell: 497, currently: 427 (85.9%), active: 9 (2.1%)
23:58:43 <mornfall> sjanssen: That makes sense. So a restricted channel with higher performance could make sense. (I only do point-to-point communication in my C++ program... although it might make sense to change that for a potential haskell rewrite...).
23:58:58 <mornfall> Hm. Way too many "make sense" instances. D'oh.
