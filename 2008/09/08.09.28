00:00:13 <FunctorSalad_> ivanm: :set prompt ""
00:00:16 <FunctorSalad_> ;-)
00:00:33 <sjanssen> Monadic aspects? :P
00:00:40 <Cale> adu: Well, for sufficiently polymorphic actions. The monad transformer library has a lot of sneaky instances which are designed to make it look like you can just use things from two 'base' monads in the same code. But that's not actually what you're doing.
00:01:43 <Cale> adu: What you're doing is constructing a 'big' monad in which there are primitive computations that are similar to some base monads (like State and Writer, etc.) that you're familiar with.
00:02:07 <Cale> Typeclasses are used to give these operations the same names.
00:02:21 <adu> i'm not familiar with Writer
00:02:28 <Cale> That's okay
00:03:09 <Cale> My favourite examples of a monad constructed using a monad transformer is probably  StateT s []
00:03:41 <ivanm> FunctorSalad_: any way of actually listing say the last component of the module path (e.g. Map for Data.Map)?
00:03:44 <Cale> Let's unravel what the computations in that monad really are
00:03:48 <adu> so that would make runState :: s -> [(a, s)]?
00:03:54 <Cale> yes, exactly
00:03:57 <FunctorSalad_> ivanm: I don't know
00:04:12 <FunctorSalad_> maybe the ghc user's guide does
00:04:18 <Cale> well, the field has that type, so  runState :: StateT s [] a -> s -> [(a,s)]
00:04:50 <Cale> Now, what does that do?
00:05:09 <Cale> It gives you a monad in which you have state-like actions get and put
00:05:31 <Cale> But you also have the ability to try multiple things.
00:06:28 <ivanm> FunctorSalad_: yeah, I think I've looked through there before :s
00:06:30 <Cale> It's an ideal monad for, say, solving a puzzle by filling things in.
00:06:35 <adu> oooo because its like a data record!
00:06:45 <Cale> Say s is a type for a (partially-filled) Sudoku puzzle
00:07:46 <FunctorSalad_> > runStateT (modify (*2)) [1..5]
00:07:47 <lambdabot>       No instance for (Show (m ((), [t])))
00:07:47 <lambdabot>        arising from a use of `show...
00:07:56 <Cale> Then you can write a function which takes a position and a value to fill it with, and looks to see if putting that value in that spot would yield a valid sudoku board.
00:08:02 <FunctorSalad_> > runStateT (modify (*2)) [1..5] >>= print
00:08:04 <lambdabot>       No instance for (Num [t])
00:08:04 <lambdabot>        arising from the literal `2' at <inter...
00:08:35 <Cale> If it does, then it sets the current state. If not, it does  lift []
00:08:38 * FunctorSalad_ is doing it wrong
00:08:59 <adu> trying multiple things? like finding the longest-common-sublist?
00:09:03 <Cale> (which basically causes backtracking, like the [] action does in the list monad)
00:09:24 <Cale> and then you can write a loop which just tries to fill the board in, in all possible ways, using that primitive
00:09:27 <mwotton> *sigh* first useful thing i've done for the haskell community in years, and it's a perl script hack...
00:10:06 <adu> Cale: how can [] be an action?
00:10:13 <mwotton> anyway, if anyone else uses flymake, emacs and literate haskell, the perl script at http://www.emacswiki.org/cgi-bin/wiki/FlymakeHaskell is better now...
00:10:13 <Cale> It's an action in the list monad
00:10:17 <lambdabot> Title: EmacsWiki: Flymake Haskell
00:10:31 <Cale> adu: You think of it as the computation which produces no result when run.
00:10:39 <Cale> adu: (in the computational frame of mind)
00:10:40 <adu> Cale: it's certainly a member, but an action?
00:10:58 <Cale> adu: Well, if you like thinking of monadic-values as actions.
00:11:14 <adu> I like thinking of monadic-values as members
00:11:21 <dolio> A list is a non-deterministic computation of one of its members.
00:11:33 <dolio> [] is a failing non-deterministic computation.
00:11:51 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; if even (x+y) then return (x,y) else []
00:11:52 <lambdabot>   [(1,5),(2,4),(2,6),(3,5)]
00:12:03 <ivanm> anyone here familiar with the pretty-printing library?
00:12:21 <ttt--> hi, i get this when trying to install haxr-th http://hpaste.org/10734
00:12:41 <ttt--> also, cabal install fails because it can't find the license file, i think
00:13:05 <Cale> So, in an action mindset, that says "pick x from [1,2,3] in all possible ways, then pick y from [4,5,6] in all possible ways. If x + y is even, then return it. Otherwise, don't produce a result."
00:13:22 <adu> Cale: its still a value, it doesn't do anything
00:13:36 <Cale> adu: I'm telling you how to interpret a list as doing something.
00:13:52 <Cale> You interpret the list xs as a computation which picks an element from itself.
00:14:00 <adu> oh ok
00:15:26 <adu> Cale: ooo like dolio said
00:15:31 <Cale> This is the view which makes the usual interpretation of return and >>= on "actions" make sense for the list monad.
00:15:59 <Cale> Of course, monads are really something which is abstract, but having metaphors like this computational one can help to understand what's happening.
00:16:32 <adu> its a nice one
00:17:24 <Cale> So if [] is a monad where you get to nondeterministically produce zero or more results, then StateT s [] is a monad where you get to nondeterministically produce zero or more results while manipulating a state of type s.
00:17:45 <Cale> However, that statement doesn't *completely* specify the behaviour.
00:18:16 <Cale> After all, does the state go back to its previous value when "backtracking" occurs, or does it continue through?
00:18:38 <Cale> And it turns out in this particular case, that backtracking causes the state to backtrack as well.
00:18:48 <sjanssen> 2 minutes into the Yi demo and I'm already impressed -- layout aware indenting!
00:19:07 <Cale> If you want the opposite behaviour, you'll need to get LogicT from hackage and LogicT transform the State monad :)
00:19:13 <adu> so x <- something in (StateT s []) would nondeterministically make x = (a, s)?
00:19:45 <Cale> It would nondeterministically make x = a, but also nondeterministically update the state to the corresponding state.
00:21:40 <Cale> Does that make sense?
00:22:07 <Cale> @unmtl StateT s [] a
00:22:07 <lambdabot> s -> [(a, s)]
00:22:22 <adu> i'm so confused
00:22:22 <adu> maybe i just need to try it out
00:22:25 <Cale> So, it's a function from initial states to result values and new states
00:22:32 <Cale> er
00:22:46 <Cale> But it gives a list of options for what the result and new state are!
00:23:07 <Cale> So we think of it as picking one of those options.
00:23:16 <Cale> (and doing so in all possible ways)
00:23:17 <Heffalump> the  state is carried around implicitly, like in a normal state monad
00:23:31 <Heffalump> but it forks along with the values
00:24:01 <Heffalump> @unmtl ListT (State s) a
00:24:01 <lambdabot> s -> ([a], s)
00:24:19 <Cale> ListT is broken though, so I wouldn't recommend it ;)
00:24:22 <Heffalump> whereas in that case, there's just one state
00:24:26 <Cale> But yeah
00:24:36 <Heffalump> only up to ordering, right?
00:24:53 <Cale> Well, yes.
00:25:05 <adu> Cale: what does unmtl mean?
00:25:22 <PeakerWork> What's the difference between LogicT and what ListT should have been?
00:25:49 <Cale> adu: It unravels what the underlying type is for a type constructed using the various monad transformers in the MTL.
00:26:00 <dolio> LogicT uses a continuation passing implementation.
00:26:25 <adu> @unmtl ST RealWorld
00:26:26 <lambdabot> ST RealWorld
00:26:26 <Cale> (and actually reliably produces something which satisfies the monad laws)
00:28:28 <dolio> Yeah, but what-ListT-should-have-been does that, too.
00:28:51 <adu> what's ListT?
00:29:26 <Cale> adu: A failed attempt at a monad transformer corresponding to the list monad.
00:29:51 <Cale> adu: (It's not a monad transformer, because for most monads, it doesn't give you something which satisfies the monad laws)
00:30:30 <adu> i think I really need an example, like using GenParser and IO together...
00:32:04 <Cale> Well, if GenParser had a monad transformer version... I think the newer Parsecs do, then you could parser-transform the IO monad
00:32:13 <Cale> and get a monad which can do IO while parsing things
00:32:57 <fynn> just to make sure: the way laziness is implemented in Haskell, if I send a list L to a function "foo (a:bs)", when foo is entered - only a is computed, correct?
00:33:05 <Cale> This might be useful, for example, if you want to parse in a filename somewhere along the line, and then push the contents of that file onto the front of the stream of tokens to parse.
00:33:21 <fynn> i.e. only the first element of L.
00:33:29 <adu> Cale: ya! that sounds useful
00:33:30 <Cale> fynn: Only the cons is computed.
00:33:46 <fynn> Cale: cool, thanks for confirming.
00:34:13 <Cale> fynn: That is, the expression is evaluated up to determining that the list is nonempty. The values a and bs still might be as-yet-unevaluated expressions.
00:34:56 <Cale> fynn: For example, evaluating  length (map f xs)  will never end up applying the function f.
00:35:23 <Cale> (or, well, it will never end up *evaluating* an application of f)
00:35:46 <fynn> Cale: ah, so in the case of foo, no element would be computed when the function is entered?
00:36:00 <fynn> foo would only make sure that the list has at least two elements?
00:36:30 <Cale> length (map f [1,2,3,4,5]) -> length (f 1 : map f [2,3,4,5]) -> 1 + length (map f [2,3,4,5])
00:36:32 <Cale> and so on
00:36:41 <Cale> at least one element, really
00:36:49 <Cale> xs might be []
00:36:50 * fynn nods
00:36:52 <Cale> er, bs
00:36:54 <fynn> right,
00:36:59 <fynn> thanks, it makes sense now.
00:38:04 <Cale> To lazily evaluate something, you evaluate the outermost (leftmost) function application which can successfully pattern-match.
00:39:52 <Cale> So in the example with length and map above, length needs to know if its parameter is [] or (x:xs) in order to compute its result, but map f [1,2,3,4,5] is not explicitly in one of those forms, so the map is evaluated, which succeeds in pattern matching (modulo syntax sugar), and produces a cons, which allows length to proceed on the next step.
00:47:27 <dolio> http://hpaste.org/10735
00:48:27 <dolio> That shows how ListT's non-monadness can get you genuinely different answers, I think.
00:48:53 <Eridius> what's ListT?
00:49:16 <dolio> Go look at the discussion about 20 minutes ago. :)
00:50:01 <Eridius> ok, so something about monad transformers
00:50:11 <dolio> It's a monad transformer that isn't really a monad transformer.
00:50:20 <Eridius> it might help if I knew about monad transformers ;)
00:50:36 <glguy> don't bother with ListT. using monadLib's choiceT
00:50:39 <dolio> Because ListT m is only a monad if m is a commutative monad, instead of any arbitrary monad.
00:51:02 <Eridius> unfortunately right now I have to re-build ghc, because I unregistered the bundled bytestring (to get gtk2hs to play nicely with the newer version), but the ghc-6.8.3 package itself depended on it :/
00:51:16 <fynn> Cale: thanks a lot.
00:51:22 <bd_> http://www.haskell.org/haskellwiki/ListT_done_right relevant, probably
00:51:34 <lambdabot> Title: ListT done right - HaskellWiki
00:52:11 <dolio> That page is essentially what's in monadLib's ChoiceT.
00:54:47 <adu> dolio: ok
00:55:05 <dolio> Oh good, we're replacing nub with a bunch of functions and a type class with functional dependencies. :)
00:55:38 <Axman6> i never understood where nub and nubBy got their names from
00:55:48 <dolio> @dict nub
00:55:48 <lambdabot> Supported dictionary-lookup commands:
00:55:48 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:55:48 <lambdabot> Use "dict-help [cmd...]" for more.
00:55:58 <dolio> @wn nub
00:55:59 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
00:55:59 <lambdabot> nub
00:55:59 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
00:55:59 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
00:55:59 <lambdabot>      3: the choicest or most essential or most vital part of some
00:56:01 <lambdabot> [5 @more lines]
00:56:07 <dolio> See 3, I guess.
00:56:29 <adu> @world02
00:56:39 <mwotton> is there a standard sorted_nub:: Ord a => [a]
00:56:44 <mwotton> -> [a]
00:56:50 <dolio> No.
00:56:52 <mwotton> ? i keep seeming to rewrite it...
00:57:09 <mwotton> ah well. guess it stays in the grungy utils file :)
00:57:10 <bd_> mwotton: map head . group . sort
00:57:30 <dolio> Adding one isn't a bad idea, except a good one would probably cause a circular dependency between Data.List and Data.Set.
00:57:39 <dolio> Not to mention their being in different packages.
00:57:51 <bd_> dolio: why would Data.Set be needed?
00:58:02 <bd_> the above is a perfectly good implementation with only Data.List :)
00:58:08 <dolio> Because it's a good set implementation.
00:58:14 <hackage> Uploaded to hackage: panda 2008.9.28
00:58:23 <dolio> map head . group . sort is not lazy.
00:59:06 <bd_> dolio: Nor is Data.Set.fromList
00:59:14 <bd_> ... oh, I see what you mean
00:59:21 <dolio> toList . fromList is also a bad implementation.
00:59:33 <dolio> You want to go down the list and keep track of the seen set.
00:59:48 <glguy> toList . fromList  does keep track in Set
01:00:07 <dolio> At least, presumably. toList . fromList is fine in some cases.
01:00:25 <bd_> @hoogle filterM
01:00:25 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
01:02:05 <bd_> :t \l -> evalState (filterM (\e -> do { s <- get; modify (Data.Set.insert e); return $ not (Data.Set.member e s) }) l) Data.Set.empty
01:02:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
01:45:17 <FunctorSalad_> mwotton: or just continue with the set in the first place?
01:45:39 <FunctorSalad_> with the Data.Set I mean
01:46:12 <FunctorSalad_> it /is/ essentially a sorted nub
01:47:37 <FunctorSalad_> dolio: why wouldn't Set.fromList do that? (keep track of the seen)
01:47:58 <FunctorSalad_> nvm, glguy beat me to it
01:48:22 <dolio> The problem is that fromList requires the entire list to construct anything.
01:48:51 <dolio> So, for instance, take 3 . toList . fromList looks at the entire list, instead of the first 3 unique elements.
01:49:10 <FunctorSalad_> isn't that implied by sorting?
01:49:28 <FunctorSalad_> (he was looking for a sorted_nub)
01:49:36 <dolio> Yes, but it's not necessarily a desirable property for a nub-alike.
01:58:14 <hackage> Uploaded to hackage: parseargs 0.1.2
02:26:11 <Mr_Awesome> is there a built in function for printing hexadecimal numbers?
02:26:47 <EvilTerran> ?hoogle Hex
02:26:47 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
02:26:47 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
02:26:47 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
02:26:51 <EvilTerran> ...
02:26:54 <EvilTerran> ?hoogle showHex
02:26:55 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
02:27:10 <EvilTerran> > showHex 3735928559 ""
02:27:11 <lambdabot>   mueval: Prelude.read: no parse
02:27:19 <EvilTerran> ...
02:28:35 <EvilTerran> ghci> Numeric.showHex 3735928559 ""
02:28:36 <EvilTerran> "deadbeef"
02:28:47 <mm_freak> ok, over the weekend i learned prolog and find it similarly great…  is there an easy way to combine the power of both languages?
02:28:52 <Twey> WHat's the "" for?
02:28:58 <Twey> mm_freak: Curry?  :-P
02:29:05 <ivanm> Twey: ShowS takes two strings IIRC
02:29:08 <ivanm> @hoogel ShowS
02:29:09 <lambdabot> Maybe you meant: hoogle hoogle+
02:29:12 <mm_freak> Twey: ?
02:29:16 <EvilTerran> Mr_Awesome, there you go. the result of converting the first parameter to hex is prepended onto the second parameter
02:29:16 <ivanm> @src ShowS
02:29:17 <lambdabot> type ShowS = String -> String
02:29:31 <Twey> Ah-huh...
02:29:41 <Twey> @type showHex
02:29:43 <lambdabot> forall a. (Integral a) => a -> String -> String
02:29:49 <Twey> Huh
02:29:55 <Twey> What's it for?
02:30:01 <Twey> @src showHex
02:30:01 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:30:24 <Mr_Awesome> thanks
02:30:25 <EvilTerran> composing ShowS functions then passing the resulting function a "" is unaffected, speed-wise, by how you bracket the (.)s
02:30:45 <EvilTerran> while assembling strings by (++) directly *is* affected by how you bracket the (++)s
02:32:13 <EvilTerran> so using ShowS functions to build a string will always give you O(n) behaviour, while using (++) might result in O(n^2) behaviour
02:32:16 <Mr_Awesome> ghci> Numeric.showHex 0 ""
02:32:50 <Mr_Awesome> heh, you just typed that in didn't you
02:33:30 <Mr_Awesome> i certainly look dumb
02:34:24 <EvilTerran> lambdabot wasn't co-operating, so i did it myself, yeah :)
02:34:27 <EvilTerran> "0"
03:07:16 <plutonas> what is the $ sign doing in haskell?
03:07:23 <Peaker> plutonas: apply func to arg
03:07:34 <Peaker> where it is: func$arg
03:07:47 <Peaker> plutonas: it is also with the weakest precdence which allows it to be used as syntax trickery to avoid ()
03:07:59 <matthew-_> it's just there to mess with precedence
03:08:06 <matthew-_> you don't ever have to use it
03:08:09 <plutonas> hm, i see, thanks
03:10:27 <Axman6> @src ($)
03:10:27 <lambdabot> f $ x = f x
03:10:32 <Axman6> plutonas: ^^
03:11:19 <matthew-_> @info ($()
03:11:20 <lambdabot> Unbalanced parentheses
03:11:21 <matthew-_> @info ($)
03:11:22 <lambdabot> ($)
03:11:31 <matthew-_> oh, it doesn't give infix
03:11:38 <Deewiant> @help info
03:11:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:11:57 <matthew-_> ohh, so it's not ghci's :i then
03:12:02 <plutonas> so f $ f2 n would call f2 using n as argument and then f on the result?
03:12:03 <Deewiant> no, it's not
03:12:11 <Deewiant> plutonas: yep
03:12:15 <plutonas> i get it
03:12:16 <Deewiant> equivalent to f (f2 n)
03:12:24 <plutonas> quite useful to simplify code
03:12:54 * Twey nods.
03:13:25 <Axman6> plutonas: it's a bracket remover basically
03:13:30 <Twey> It's often that you have `a (b c f (g d) e)` or something
03:13:45 <Twey> It's nice to rewrite that long-reaching bracket as `a $ b c f (g d) e`
03:14:20 <Beelsebob> plutonas: most people would argue that it's a nicer style to write f . f2 $ n
03:15:19 <Axman6> :t ($)
03:15:20 <lambdabot> forall a b. (a -> b) -> a -> b
03:15:25 <pfo> what is so special about ML's module system?
03:17:13 <ivanm> what do people think of the code I've written in http://hpaste.org/10737 ? is there a better/nicer way of doing this?
03:19:34 <Axman6> anyone know how to fix this error with yi? Launching custom yi: "/Users/Axman/.yi/yi-powerpc-darwin"
03:19:38 <Axman6> yi: /Users/Axman/.yi/yi-powerpc-darwin: executeFile: does not exist (No such file or directory)
03:20:00 <ivanm> Axman6: touch /Users/Axman/.yi/yi-powerpc-darwin :p
03:20:06 <ivanm> that'll make it exist, anyway...
03:20:09 <ozy`> Axman6: create a ~/.yi/yi.hs file and put anything in it
03:20:17 <maltem> @type concatMap words . lines
03:20:18 <lambdabot> String -> [String]
03:20:21 <Axman6> ah, righto
03:20:22 <maltem> @type words
03:20:23 <lambdabot> String -> [String]
03:20:24 <ozy`> yi will automatically compile and run it
03:20:29 <maltem> hm, are they different?
03:20:58 <ivanm> maltem: does words cover \n as well? I didn't know that :s
03:21:11 <ozy`> Axman6: that should probably be in the documentation actually...
03:21:26 <Axman6> yes. it really should ;)
03:21:31 <maltem> > words "a\nb\tc d"
03:21:33 <lambdabot>   ["a","b","c","d"]
03:21:34 <Beelsebob> > words "jam ham spam\nmonkies"
03:21:35 <lambdabot>   ["jam","ham","spam","monkies"]
03:21:51 <Beelsebob> > concatMap words . lines "jam ham spam\nmonkies"
03:21:51 <ivanm> maltem: oh, didn't think of that :s
03:21:52 <lambdabot>   Couldn't match expected type `a -> [String]'
03:21:53 <Axman6> ozy`: anything in particular that should be in there?
03:21:59 <maltem> ivanm: all whitespace, apparently :)
03:22:04 <Beelsebob> > concatMap words . lines $ "jam ham spam\nmonkies"
03:22:04 <ivanm> yeah :D
03:22:04 <ozy`> (I spent about a day and a half tearing my hair out on and off before it occurred to me to try that)
03:22:05 <ivanm> anyway, that was just there for testing
03:22:05 <lambdabot>   ["jam","ham","spam","monkies"]
03:22:43 <ivanm> I'm really going to convert it to taking in an instance of Show
03:22:43 <ozy`> Axman6: "you must create source files for a custom Yi before the editor will run at all?"
03:33:11 <ivanm> maltem: http://hpaste.org/10737#a2 \o/
03:36:04 <dolio> > render . hcat . map (text . show) $ [1..100]
03:36:05 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
03:36:20 <ivanm> dolio: that's using the pretty-printing library?
03:36:26 <dolio> > render . hsep . map (text . show) $ [1..100]
03:36:28 <lambdabot>   "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28...
03:36:30 <ivanm> I couldn't get it to work :s
03:36:31 <dolio> Yeah.
03:36:40 <ivanm> I'm wanting a roughly square block
03:37:50 <dolio> > renderStyle (Style PageMode 40 1.5) . hsep . map (text . show) $ [1..100]
03:37:51 <lambdabot>   "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28...
03:37:55 <dolio> Hmm.
03:38:50 <dolio> > renderStyle (Style PageMode 40 1.5) . sep . map (text . show) $ [1..100]
03:38:51 <lambdabot>   "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\...
03:39:01 <dolio> > render . sep . map (text . show) $ [1..100]
03:39:02 <lambdabot>   "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\...
03:39:03 <ivanm> I kept getting stuff like that as well :s
03:39:12 <ivanm> until I decided to give up and do it manually ;-)
03:39:42 <dolio> > render . fsep . map (text . show) $ [1..100]
03:39:43 <lambdabot>   "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n26 27 2...
03:39:48 <dolio> There we go. :)
03:40:09 <dolio> > render . fcat . map (text . show) $ [1..100]
03:40:10 <lambdabot>   "1234567891011121314151617181920212223242526272829303132333435363738\n39404...
03:40:26 <ivanm> :o dammit, I'm sure I tried that!
03:40:39 <dolio> > renderStyle (Style PageMode 40 1.5) . fsep . map (text . show) $ [1..100]
03:40:41 <lambdabot>   "1 2 3 4 5 6 7 8 9 10 11 12\n13 14 15 16 17 18 19 20 21\n22 23 24 25 26 27 ...
03:41:06 <dolio> So many seps and cats.
03:42:33 <Axman6> :t text
03:42:35 <lambdabot> String -> Doc
03:42:51 <Axman6> > text "123 456"
03:42:53 <lambdabot>   123 456
03:43:02 <ivanm> dolio: so what do the two numbers mean?
03:43:04 <Axman6> hmm, fair enough
03:43:25 <dolio> 40 is the line length. I'm not sure what the other one does, but that's the default according to the docs.
03:43:30 <ivanm> *nod*
03:46:31 <ivanm> @ty style
03:46:33 <lambdabot> Style
03:46:35 <ivanm> @ty Style
03:46:37 <lambdabot> Mode -> Int -> Float -> Style
03:47:27 <ivanm> oh, I know why it mightn't have worked here... I think I was treating Style as a record type for some reason :s
03:47:55 <dolio> Well, it is.
03:48:10 <dolio> > renderStyle (style { lineLength = 40 }) . fsep . map (text . show) $ [1..100]
03:48:12 <lambdabot>   "1 2 3 4 5 6 7 8 9 10 11 12\n13 14 15 16 17 18 19 20 21\n22 23 24 25 26 27 ...
03:48:33 <dolio> > length "1 2 3 4 5 6 7 8 9 10 11 12"
03:48:34 <lambdabot>   26
03:48:42 <ivanm> so why is it's type different?
03:48:46 <dolio> Those aren't nearly 40 characters long.
03:49:26 <dolio> Record stuff is just sugar for ordinary algebraic types.
03:49:34 <dolio> So you can still use the constructor like a non-record type.
03:50:04 <ivanm> dolio: it gives me much shorter lines here :s
03:50:08 <ivanm> ahhh
03:50:36 <dolio> > map length . lines . renderStyle (style { lineLength = 40 }) . fsep . map (text . show) $ [1..100]
03:50:38 <lambdabot>   [26,26,26,26,26,26,26,26,26,26,21]
03:50:56 <dolio> I think that fsep tries to equalize the line length as much as possible.
03:51:14 <ivanm> unless it's number of lines?
03:51:50 <subconscious> grumble
03:51:58 <ivanm> well, if I change the value of lineLength, I get different line lengths...
03:52:15 <Axman6> > map (text . show) [1..10]
03:52:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:52:27 <dolio> > map length . lines . renderStyle (style { lineLength = 40, ribbonsPerLine = 1.0 }) . fsep . map (text . show) $ [1..100]
03:52:28 <lambdabot>   [38,38,38,38,38,38,38,18]
03:52:32 <dolio> There we go.
03:52:48 <dolio> > map length . lines . renderStyle (style { lineLength = 40, ribbonsPerLine = 0.5 }) . fsep . map (text . show) $ [1..100]
03:52:49 <lambdabot>   [38,38,38,38,38,38,38,18]
03:52:53 <ivanm> so what does ribbonsPerLine do?
03:52:55 <dolio> > map length . lines . renderStyle (style { lineLength = 40, ribbonsPerLine = 2.0 }) . fsep . map (text . show) $ [1..100]
03:52:56 <lambdabot>   [20,20,20,20,20,20,20,20,20,20,20,20,20,18]
03:53:05 <dolio> "Ratio of ribbon length to line length"
03:53:10 <ivanm> hmmm.... seems to cap it as well...
03:53:18 <ivanm> dolio: heh, yes, but wtf is a "ribbon length" :s
03:53:21 <dolio> Whatever a ribbon is.
03:53:36 <dolio> Read the paper, I guess. :)
03:53:49 <ivanm> yeah, I tried skimming through it :s
03:54:01 <dolio> Increasing it clearly tends to equalize the line length, though.
03:54:09 <ivanm> *nod*
03:54:13 <dolio> Instead of trying to use as much of every line as possible.
03:54:59 <ivanm> wow, setting it to either 0 or 1 made it have 1 item/line :s
03:55:23 * ivanm might stick with his home-grown version
03:55:29 <ivanm> at least I know what it does and how it works! :p
03:55:37 <ivanm> using haskell in the first place is magic enough ;-)
03:56:10 <Twey> Haskell isn't magic!
03:56:18 <Twey> Well, not very magic :)
03:56:21 <ivanm> heh
03:57:48 <Twey> There's the whole constructing-a-value-that-gets-executed-by-magic thing
03:57:59 <Twey> But *other than that* it's largely very unmagic.
03:58:09 <subconscious> magic!?
03:58:47 <olsner> it's thunks all the way down
03:59:12 <dolio> C is magic. I hear it's written in itself!
03:59:15 <ivanm> heh
03:59:34 <Twey> Hahaha
03:59:38 <dolio> Unlike everything else, which is written in C.
03:59:39 <Twey> So is Haskell!
03:59:51 <ivanm> Twey: GHC = Haskell + C + Perl
03:59:54 <dolio> Or, I suppose that makes C like everything else. I'll have to meditate on this...
04:00:10 <ivanm> dolio: well, fortran isn't in C...
04:00:15 <Fuse_> Python is written in Python...
04:00:23 <ivanm> Fuse_: no, it's in C
04:00:27 <dolio> :) Are they done with that yet?
04:00:29 <ivanm> the default implementation, anyway
04:00:30 <Fuse_> No, it's Python
04:00:33 <Fuse_> check PyPy
04:00:40 <Twey> One of the implementations is Python, aye
04:00:46 <ivanm> Fuse_: PyPy /= Python (i.e. default implementation)
04:00:47 <Twey> ivanm: Perl?  PERL?!
04:00:54 * Twey feels a little sick.
04:00:56 <ivanm> @where EvilMangler
04:00:56 <lambdabot> I know nothing about evilmangler.
04:00:59 <ivanm> @quote mangler
04:01:00 <Fuse_> de facto not really 'default'
04:01:00 <lambdabot> Pseudonym says: All hail the Evil Mangler!
04:01:05 <Axman6> isn't perl6 done in haskell?
04:01:19 <Axman6> or pugs
04:01:22 <ivanm> Fuse_: the one being developed by the author is...
04:01:31 <ivanm> Axman6: well, the initial version anyway...
04:01:42 <ivanm> last I heard, the plan was to write Perl6 in Perl6, and use pugs to bootstrap
04:01:50 <olsner> ivanm: and don't forget the Satanic Splitter
04:02:03 <subconscious> good paper on syntax http://www.e-pig.org/downloads/notanum.pdf
04:02:14 <ivanm> Fuse_: I would call CPython the default implementation, seeing as how that's the version Guido works on AFAIK
04:02:16 <lambdabot> Title: I am not a number: I am a free variable
04:02:23 <Fuse_> ivanm: the point remains, there's nothing set in stone about compilers being written in C
04:02:48 <Cale> Compilers should generally be written in the language that they compile. :)
04:02:51 <Fuse_> and that C isn't alone in being written in itself: it's possible to do that elsewhere
04:02:58 <ivanm> Fuse_: you're not helping your argument, since last time I checked pypy was also an interpreter...
04:03:57 <dolio> I know C isn't the only thing written in itself. The programming public at large tends to treat it that way, though.
04:04:01 <Fuse_> yeah, so I used compiler interchangeably with interpreter - sue me. CPython is interpretted, too
04:04:07 <olsner> if the newly born language can't even be used to write its own compiler - what use is it?
04:04:17 * subconscious is sueing Fuse
04:04:17 <ivanm> Fuse_: yes, but I never claimed it wasn't ;-)
04:04:42 <ivanm> olsner: would _you_ want to write a brainfuck compiler in brainfuck? :p
04:05:03 <dolio> C is the magic language that gets to be at the bottom of the language implementation stack, and therefore is always necessary.
04:05:04 <olsner> no, but what use is brainfuck?
04:05:14 * kaol prefers compilers to be bootstrappable with just a C compiler
04:05:23 <ivanm> olsner: true
04:05:25 <subconscious> ivanm: Actually that's really easy to do
04:05:26 <Fuse_> dolio: what about asm?
04:05:27 <olsner> no-one's trying to prove that BF is useful, so no need to write the compiler in it :)
04:05:33 <ivanm> subconscious: :o
04:05:41 <ivanm> subconscious: a _compiler_ for brainfuck?
04:05:42 <subconscious> ivanm: If you just want to compile into C or something -- you should have a go it's a fun game
04:06:06 <ivanm> subconscious: after learning C for one semester to program microprocessors, I think I'll pass :p
04:06:08 <dolio> Thinking about writing a compiler directly in asm makes their brains explode, presumably. :)
04:06:18 <dolio> I don't imagine I'd relish writing parsers in asm.
04:06:20 * ivanm prefers Fortran {9{0,5},2003} to C
04:06:36 <Fuse_> I'm going to quote Wikipedia because it's clearly the indisputable source of all knowledge
04:06:36 <subconscious> yeah
04:06:38 <Fuse_> "The de facto standard for the language is the CPython implementation."
04:06:40 <Cale> If you believe that your language is good, you should write your compiler in it to see :)
04:06:45 <subconscious> I was reading the ALGOL 60 compiler the other day
04:06:55 <subconscious> It's all in some strange assembly language .. scary
04:07:14 <ivanm> Fuse_: OK, fine, just as GHC is only the "de facto" haskell compiler, and not the default
04:07:36 <ivanm> (IIRC, nhc is complete... are any of the others?)
04:07:42 <Fuse_> definitely. That's exactly what the designer said about GHC.
04:07:51 <luite_> what data structures should I use for fast access to bits in a stream? I have some large files compressed using a prefix (huffman) code, and want to write a fast decompressor in haskell
04:08:01 <dolio> Hugs, yhc, hbc...
04:08:10 <dolio> Hugs isn't a compiler, but...
04:08:16 <ivanm> Fuse_: though for all intents and purposes, it seems GHC almost defines Haskell
04:08:24 <ivanm> dolio: I though yhc hadn't had a release yet :s
04:08:33 <subconscious> luite_: Why would you need _access_ to bits to write that?
04:08:33 <ivanm> and isn't hbc long dead?
04:08:43 <dolio> Oh, there's jhc, too.
04:09:04 <dolio> Although it can be hard to get things to compile with it.
04:09:07 <Fuse_> ivanm: Haskell 98, yes. It's a semi-freeze. You should read his thoughts on it: http://www.techworld.com.au/article/261007/-z_programming_languages_haskell
04:09:11 <lambdabot> Title: Techworld - The A-Z of Programming Languages: Haskell, http://tinyurl.com/4aowzp
04:09:15 <ivanm> dolio: so it's not really complete then, is it...
04:09:18 <ivanm> Fuse_: yeah, I read it
04:09:19 <Cale> luite_: Basically the obvious choice would be ByteString.
04:09:37 <dolio> What does "complete" mean?
04:09:44 * subconscious is confused why you wouldn't use String ?
04:09:45 <Cale> luite_: Anything else will probably at least go via ByteString anyway.
04:09:55 <Fuse_> I tend to see 'complete' used with 'turing' but...
04:09:59 <Cale> subconscious: Performance.
04:10:00 <ivanm> wow, according to wikipedia, haskell wasn't influenced by any other languages... >_>
04:10:05 <Fuse_> hah
04:10:06 <Cale> ivanm: haha
04:10:12 <Fuse_> let's fix that
04:10:17 <ivanm> dolio: compiles apps according to H98?
04:10:43 <ivanm> yeah, there's miranda at the very least...
04:10:43 <dolio> Well, there are some tricky programs you can use to trip it up.
04:10:50 <luite_> Cale: hm ok, I guess some manual bit shifting wouldn't be too bad :)
04:11:05 <Cale> luite_: There's Data.Bits to manipulate Word8 values
04:11:43 <luite_> ah, tnx
04:11:58 <dolio> But the problem with jhc isn't necessarily that it doesn't implement H98, but that the stuff it's doing might run your computer out of resources.
04:12:24 <dolio> Because it does awesome whole-program optimization and so on.
04:12:35 <ivanm> are there any "main-stream" haskell implementations that aren't lazy? I know there's eager haskell, but only because wikipedia mentions it...
04:12:43 <ivanm> dolio: ahhh....
04:12:53 <ivanm> dolio: and tries to solve the halting paradox whilst doing so? :p
04:13:03 <dolio> I'm pretty sure yhc implements H98, too, at least.
04:13:19 <ivanm> they just never release?
04:13:40 <dolio> Who needs a release?
04:13:44 <ivanm> heh
04:14:00 <ivanm> it lets you make those really great ANNOUNCE emails that let people know you're still alive :p
04:14:30 <ivanm> though wikipedia calls hugs a compiler...
04:15:36 <ac_> keep forgetting the name of the function that splits a float into an integer and its fractional part
04:16:01 <dolio> @type properFraction
04:16:02 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
04:16:05 <ac> ah thanks
04:16:31 <Fuse_> ivanm: the page i'm on calls it a bytecode interpreter
04:16:40 <ivanm> Fuse_: I'm looking at the YHC page
04:16:44 <dolio> Flag down a grade schooler and ask them. Should be fresh in their mind. :)
04:16:46 <Fuse_> aah
04:18:18 <olsner> > properFraction pi
04:18:19 <lambdabot>   (3,0.14159265358979312)
04:18:25 <olsner> cool
04:21:40 <Fuse_> that's a pretty decent bot
04:22:37 <Axman6> why do you say that?
04:22:44 <Axman6> (it's true, just curious)
04:23:47 <Fuse_> treatment of hyperlinks and a sort of man pages for haskell functions. it struck me as neat.
04:24:06 <Fuse_> especially if it's coded in Haskell, as I'm guessing it is
04:26:53 <ac> say I have a function with this type: foo :: a -> (b, a) -- how do I turn that in to a [b] such that each a is fed in to the next call of foo?
04:27:04 <ac> should be able to use the State monad, no?
04:27:15 <dolio> unfoldr
04:27:56 <Deewiant> > let foo :: a -> (Int, a); foo = (,) 1 in unfoldr (Just . foo) []
04:27:59 <ivanm> unfoldr is quite cool...
04:28:00 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:28:06 <dolio> > unfoldr (Just . fmap (*10) . properFraction) pi
04:28:08 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,1,1,5,9,9,7,9,6,3,4,6,8,5,4,4,1,8,5,1,6,1,...
04:28:20 <Deewiant> heh, cute
04:28:57 <Deewiant> > take 50 $ drop 50 $ unfoldr (Just . fmap (*10) . properFraction) pi
04:28:59 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
04:29:02 <Deewiant> meh
04:29:03 <dolio> :)
04:29:11 <Axman6> :t unfoldr
04:29:12 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
04:29:13 <Deewiant> > take 50 $ drop 50 $ unfoldr (Just . fmap (*10) . properFraction) (pi :: CReal)
04:29:16 <lambdabot>   [1,-4,-2,2,1,0,-2,-5,-1,4,5,-4,-1,2,3,1,-2,-2,2,-4,4,1,-4,3,-1,-4,2,1,-1,0,...
04:29:19 <Deewiant> O_o
04:29:21 <dolio> > drop 50 $ unfoldr (Just . fmap (*10) . properFraction) (pi :: CReal)
04:29:36 <lambdabot>   thread killed
04:29:42 <BONUS> i wonder if unfoldr that uses the list monad instead of the maybe monad would be useful
04:30:21 <maltem> Uh... won't editline, as now used by ghci, recognize Ctrl-R ?
04:31:01 <Deewiant> > length . takeWhile (>= 0) $  unfoldr (Just . fmap (*10) . properFraction) (pi :: CReal)
04:31:03 <lambdabot>   4
04:31:07 <ivanm> BONUS: how would that work?
04:31:16 <Deewiant> > take 10 $ unfoldr (Just . fmap (*10) . properFraction) (pi :: CReal)
04:31:18 <lambdabot>   [3,1,4,2,-4,-1,3,-3,-5,4]
04:31:35 <BONUS> hmmm yeah i dont know exactly was just wondering
04:31:45 <dolio> Huh. Weird.
04:31:50 <BONUS> but i was thinkin that if a list had more elements than 1
04:31:55 <Deewiant> > properFraction (pi :: CReal)
04:31:56 <BONUS> it would just split the computation
04:31:57 <lambdabot>   (3,0.1415926535897932384626433832795028841972)
04:32:02 <maltem> BONUS: surely it would generate a tree?
04:32:04 <BONUS> i.e. fork it
04:32:05 <BONUS> yeah
04:32:19 <Axman6> @src unfoldr
04:32:19 <lambdabot> unfoldr f b  = case f b of
04:32:19 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:32:19 <lambdabot>    Nothing        -> []
04:33:17 <Deewiant> > properFraction (1.59265358979323846264338327950288419717 :: CReal)
04:33:19 <lambdabot>   (2,-0.40734641020676153735661672049711580283)
04:33:49 <Deewiant> > properFraction (1.5 :: CReal)
04:33:50 <lambdabot>   (2,-0.5)
04:33:54 <dolio> Well, that's interesting.
04:34:05 <Deewiant> that's a bug.
04:34:05 <subconscious> @src properFraction
04:34:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:34:14 <Deewiant> instance RealFrac CReal where
04:34:14 <Deewiant>   properFraction x@(CR x') = (fromInteger n, x - fromInteger n) where n = x' 0
04:34:22 <dolio> > properFraction (1.4 :: CReal)
04:34:24 <lambdabot>   (1,0.4)
04:34:28 <dolio> > properFraction (1.49 :: CReal)
04:34:29 <lambdabot>   (1,0.49)
04:34:36 <Deewiant> the sign of (snd . properFraction $ x) should be the same as that of x.
04:35:52 <dolio> > properFraction (-1.5 :: CReal)
04:35:53 <lambdabot>   (-2,0.5)
04:36:02 <dolio> Seems to be rounding.
04:36:17 <Deewiant> fromInteger n     = CR (\p -> n*2^p)
04:36:27 <Axman6> @index unfoldr
04:36:27 <lambdabot> Data.List
04:36:35 * besiria CGI is hard. Let's go shopping!
04:36:37 <dolio> > properFraction (-0.5 :: CReal)
04:36:38 <lambdabot>   (-1,0.5)
04:36:45 <dolio> > properFraction (0.5 :: CReal)
04:36:47 <lambdabot>   (1,-0.5)
04:37:39 <Gilly> mm, looking at the shootout this language called ATS is doing pretty well
04:38:03 <ivanm> Gilly: yeah, but by the looks of things they have a lot of C code embedded in their entries
04:38:41 <Gilly> ahh :)
04:38:57 <besiria> so how can embedded C code run faster than plain C
04:39:02 <olsner> @index CReal
04:39:02 <lambdabot> bzzt
04:39:21 <mattam> It's compiled down to C but with many optimisations that are safe only because the programs in ATS are strongly specified and proven correct.
04:39:22 <Gilly> i was just wondering because I never had heard of that language before
04:40:45 <ac> Deewiant: hm, I'm getting a stack overflow
04:40:54 <besiria> mattam: never thought of that
04:41:13 <Deewiant> ac: best thing to do is put the code at hpaste :-)
04:41:38 <mattam> It's the safety you gain by proving your program correct that's paying of here. In particular, there are linear types in ATS which allows very space-efficient compilation schemes.
04:44:22 <Gilly> what is a linear type?
04:44:39 <ac> http://hpaste.org/10740
04:45:16 <subconscious> Gilly: Well the type rules for it should ensure the object is used exactly once, never duplicated or forgotten
04:45:30 <ac> am I getting a very long list of thunks or something?
04:46:01 <Gilly> subconscious: ah, ok
04:46:58 <olsner> so, linear types are somewhat like uniqueness typing?
04:47:43 <subconscious> ac, yes, you could use (,) s $! (s + x)
04:48:19 <olsner> ac: yeah, I'd suspect funkyRand is producing large thunks
04:48:32 <Deewiant> I'd probably prefer "s `seq` (s, s + x)"
04:48:43 <olsner> or use a bang pattern for x
04:48:51 <subconscious> doesn't really matter
04:48:54 <subconscious> It's all the same
04:52:43 <ac> yeah, I tried adding a '!' to the x param, but it wouldn't compile
04:52:50 <maltem> Also: (funkyRand $!)
04:52:56 <Deewiant> ac: you need -XBangPatterns
04:52:56 <subconscious> ac, so did you try what I suggested?
04:54:17 <ac> Deewiant: ah, I thought -fglasgow-exts would do it
04:54:55 <Deewiant> hm, I'd've thought so too
04:54:58 <Deewiant> evidently not
04:55:40 <ac> subconscious: do I need XBangPatterns for using "$!"?
04:55:50 <Deewiant> ac: no, nor for my seq solution
04:55:55 <Deewiant> @src ($!)
04:55:56 <lambdabot> f $! x = x `seq` f x
04:57:17 <ac> ah that's good to know
05:02:37 <maltem> What about the randomRs issue though?
05:02:56 <ac> subconscious: so, your suggestion did take care of the stack overflow, but interestingly enough it appears to be slower than !x
05:03:27 <subconscious> ac, why is it slower?
05:04:38 <ac> just ran time a few times. It wasn't a very good test
05:04:44 <ac> it was consistent though
05:07:14 <maltem> ac: What's the running time of Deewiant's version, compared to the others? (forcing s  vs  forcing x  vs  forcing (s+x))
05:08:58 <ac> the former was .000 to .008 and the latter was around .01 seconds for 1000000 numbers
05:14:29 <Axman6> anyone else see the news of UCLA finding a new prime number? ((2^43112609)-1)
05:14:40 <subconscious> > (2^43112609)-1
05:14:53 <lambdabot>   316470269330255923143453723949337516054106188475264644140304176732811247493...
05:15:57 <Japsu> > length . show $ (2^43112609)-1
05:16:13 <lambdabot>   thread killed
05:16:41 <Japsu> > log (fromIntegral ((2^43112609)-1)) / log 10.0
05:16:47 <lambdabot>   Infinity
05:16:50 <Japsu> Bah
05:16:51 <Axman6> heh
05:18:05 <Axman6> @src (^)
05:18:05 <lambdabot> x ^ 0            =  1
05:18:06 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:18:06 <lambdabot>   where f _ 0 y = y
05:18:06 <lambdabot>         f x n y = g x n
05:18:06 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:18:07 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:18:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:18:42 <Axman6> > log 43112609
05:18:44 <lambdabot>   17.579326064493102
05:18:53 <Axman6> > log 43112609 / log 10
05:18:54 <lambdabot>   7.634604305387362
05:19:51 <Axman6> i hate that lambdabot got that answer so much quicker than my computer did :(
05:20:05 <Axman6> the (2^43112609)-1 bit i mean
05:20:39 <Axman6> length . show $ (2^43112609)-1
05:20:40 <Axman6> 12978189
05:28:06 <ac> hm, how do I make a thread pause?
05:32:50 <Botje> throw lambdas at it
05:34:19 <Axman6> hmm, how do i turn a Floating value into an Intagral value?
05:34:24 <Axman6> integral*
05:34:30 <Deewiant> round/floor/ceiling
05:34:48 <Deewiant> ?hoogle (Floating a, Integral b) => a -> b
05:34:49 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
05:34:49 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
05:34:49 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
05:34:49 <steven_ashley> > truncate 3.2
05:34:51 <lambdabot>   3
05:34:56 <Deewiant> yeah, and that
05:35:47 <Axman6> ah, i was just using round and sqrt the wrong way
05:40:17 <plutonas> how do i get from Maybe value to value?
05:40:31 <Botje> pattern match
05:40:36 <Axman6> fromJust i think?
05:40:40 <Axman6> :t fromJust
05:40:41 <lambdabot> forall a. Maybe a -> a
05:40:47 <Axman6> @src fromJust
05:40:47 <lambdabot> fromJust Nothing  = undefined
05:40:47 <lambdabot> fromJust (Just x) = x
05:40:49 <Botje> no. you should pattern match or use the maybe function
05:41:03 <Botje> unless you are completely sure you won't ever get a Nothing value
05:50:42 <subconscious> nobody has a type checker for syntax represented with be bruijn indices around?
05:50:55 <unenough> What do you do in haskell for persistence?
05:51:24 <subconscious> actually I think that paper has one.
05:55:29 <Lord_Illidan> Can I use nested guards in haskell?
05:55:49 <Beelsebob> is there a sensible way to get cabal to run happy on all .y files before compiling?
05:56:04 <jethr0> Lord_Illidan: couldn't you use guards with "&&"-connected predicates?
05:57:03 <mux> unenough: what kind of persistence?
05:57:27 <Lord_Illidan> I could, yes, but I take it nested guards are not allowed?
05:57:48 <subconscious> Lord_Illidan: What's a nested guard?
05:58:16 <jethr0> what do you see as the difference between "nested guards" and "&&"-connected predicates?
05:58:18 <plutonas> how do i access elements in a list by their index?
05:58:26 <Lord_Illidan> nothing, just a matter of syntax
05:58:27 <mux> :t (!!)
05:58:28 <lambdabot> forall a. [a] -> Int -> a
05:58:31 <plutonas> oh yes
05:58:34 <plutonas> thanks
05:58:38 <mux> but such indexing is O(n)
05:58:57 <Lord_Illidan> I hadn't thought of the "&&"-connected predicates though, silly me
05:59:12 <jethr0> plutonas: if you do a lot of random access you should use another data-type such as arrays.
05:59:31 <jethr0> but often a "map" over a list is what you want to do, which doesn't need indexed access
06:00:01 <plutonas> jethr0: i think it's ok, i'm just picking 2 elements of a list, a couple of times
06:00:14 <plutonas> and don't care so much about complexity for the moment
06:00:19 <plutonas> perhaps later on if everything works
06:00:51 <jethr0> plutonas: if you need any more help, feel free to paste your code
06:00:52 <jethr0> @paste
06:00:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:01:51 <plutonas> jethr0: sure, might do later thanks
06:04:10 <plutonas> what would be the opposite of !!
06:04:26 <plutonas> that is given an element, get it's position in the list
06:05:03 <EvilTerran> ?type findIndex
06:05:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
06:05:24 <jethr0> Data.List.elemIndex
06:05:29 <EvilTerran> ?type elemIndex
06:05:31 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
06:05:34 <EvilTerran> ?src elemIndex
06:05:35 <lambdabot> elemIndex x     = findIndex (x==)
06:05:39 <jethr0> > elemIndex 3 [1..10]
06:05:40 <lambdabot>   Just 2
06:06:02 <ivanm> hmmm.... is there a Maybe version of !!?
06:06:12 <ivanm> * (!!) ?
06:06:28 <EvilTerran> ?type \n -> listToMaybe . drop n
06:06:29 <lambdabot> forall a. Int -> [a] -> Maybe a
06:06:36 <jethr0> > [1..10]!!11
06:06:37 <lambdabot>   mueval: Prelude.read: no parse
06:06:37 <lambdabot>  mueval: *** Exception: Prelude.(!!): index ...
06:06:49 <EvilTerran> > listToMaybe . drop 11 $ [1..10]
06:06:51 <lambdabot>   Nothing
06:06:55 <EvilTerran> > listToMaybe . drop 5 $ [1..10]
06:06:56 <lambdabot>   Just 6
06:07:06 <ivanm> \o/
06:08:29 <Beelsebob> http://hpaste.org/10741 <-- wtf!
06:08:50 <Botje> did configure find it?
06:08:54 <Beelsebob> yep
06:09:09 <Botje> forgetful haskell? :)
06:09:09 <Beelsebob> oh odd though
06:09:12 <EvilTerran> has it changed since configure found it?
06:09:13 <Beelsebob> a reconfigure and it works
06:09:15 <Japsu> oblivious
06:09:18 <Beelsebob> wierd
06:09:29 <Lord_Illidan> I tried a projecteuler problem, gave it up in Java, and did it in 15 mins with haskell
06:10:23 <jethr0> the unlimited precision integers are a big help for the projecteuler problems
06:10:50 <jethr0> the problems are really geared either for a pen-and-paper proof, or a language with a sensible integer suport
06:11:06 <Lord_Illidan> what's funnier is that the length of the finished haskell solution is less than the length of the quarter finished java solution
06:11:39 <mm_freak> which problem are you solving?
06:11:43 <jethr0> to be quite honest, i think that solving many of the problems via brute force is rather a shame because in many cases the solution is faster found on paper than by programming it naively
06:12:45 <EvilTerran> i tend to go for a happy medium between the two
06:13:03 <mm_freak> jethr0: for many PE problems, you can find solutions, which require no computer at all…  but sometimes it's just more aesthetic to go with the less algebraic/analytic computer solution =)
06:13:07 <EvilTerran> try to find an efficient algorithm in my head; if an actual solution falls out then, bonus!
06:13:12 <EvilTerran> if not, implement it
06:13:22 <jethr0> yes, it's actually a nice way to formulate the math proofs in haskell and then just execute them.
06:13:31 <Lord_Illidan> This is my solution to problem 17.. if anyone wants to comment on it? http://hpaste.org/10742
06:13:32 <mm_freak> yeah
06:13:59 <mm_freak> Lord_Illidan: interesting…  mine is a bit different
06:14:07 <unenough> mux, you have some object/function and you want to persist it for a later haskell session
06:14:07 <Lord_Illidan> I then got the actual answer like this : foldr1 (+) (map length(map convert [1..1000]))
06:14:55 <mm_freak> http://hpaste.org/10743
06:14:57 <ac> I think what I actually wanted was: let (static, nextSeed) = runState (replicateM (w * w) (State funkyRand)) s
06:15:06 <jethr0> wouldn't (x-(x `div` 100)*100) be equal to (x `mod` 100)?
06:15:26 <Xenoblitz> hi guys... quick question... i have a module which I have called NameA.NameB and i want to import it in NameA.NameC... if i don't use the "." it imports but using . causes problems... any ideas?
06:15:36 <Lord_Illidan> jethr0, yikes, yes
06:15:57 <Lord_Illidan> got in a bit of a tizzy
06:16:04 <Lord_Illidan> mm_freak, yours is way better than mine
06:16:18 <mm_freak> Xenoblitz: yes, see it from a filesystem point of view
06:16:22 <EvilTerran> Xenoblitz, you mean "import NameB" works in NameA.NameC, but "import NameA.NameB" doesn't?
06:16:23 <Lord_Illidan> And I didn't think of using sum, I just leapt for the foldr lol
06:16:24 <ac> Deewiant: you can't get the last "seed" using unfoldr, right?
06:16:26 <mm_freak> Lord_Illidan: not necessarily
06:16:48 <mm_freak> Lord_Illidan: yours is longer, but in a way more elegant
06:16:48 <EvilTerran> Xenoblitz, or what?
06:16:59 <Xenoblitz> EvilTerran: if i remove all the dots and say replace them with _ it all works
06:17:06 <EvilTerran> ah...
06:17:14 <jethr0> my solution to that was a bit more verbose because i constructed the numbers with correct spaces just to throw them away later. also i used indexed lists like "| x `elem` [1..19] = ["one", "two", .....] !! (x-1)"
06:17:31 <EvilTerran> Xenoblitz, as ghc does it, the .s in module names indicate a folder heirarchy
06:17:42 <Xenoblitz> yes in fact
06:17:46 <Xenoblitz> i have a folder NameA say
06:17:48 <EvilTerran> Xenoblitz, NameA.NameB should be in "NameA/NameB.hs"
06:17:54 <Xenoblitz> yes
06:17:56 <EvilTerran> but then you need to make sure NameA is in a folder on the include path
06:17:57 <Xenoblitz> it is in fact
06:18:04 <Xenoblitz> hmmm
06:18:08 <Xenoblitz> this i didn't know
06:18:09 <mm_freak> jethr0: mine does correct spacing, too
06:18:14 <Lord_Illidan> I tried it in java but the case statement doesn't support ranges as in [21..29], so it would probably devolve into masses of if-thens
06:18:45 <jethr0> Lord_Illidan: "if (x >= 21 && x <=29)"
06:19:04 <Lord_Illidan> Yes, but a whole mass of those, if I used my algorithm
06:19:14 <Lord_Illidan> I mean, sorry
06:19:20 <Lord_Illidan> my previous algorithm was much worse
06:19:24 <Lord_Illidan> anyway, I prefer haskell to java
06:19:26 <EvilTerran> Xenoblitz, http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
06:19:31 <lambdabot> Title: 5.6.�Filenames and separate compilation, http://tinyurl.com/yyunf2
06:19:33 <jethr0> Lord_Illidan: true, not very pretty, but if you use the array-indexing trick above that would take care of a lot of your cases
06:19:40 <Lord_Illidan> Mine is similar to this, I guess http://www.haskell.org/haskellwiki/Euler_problems/11_to_20, I hadn't read it beforehand
06:19:42 <lambdabot> Title: Euler problems/11 to 20 - HaskellWiki
06:20:06 <Xenoblitz> EvilTerran: thanks I'll give it a look, though I'm using Hugs... i guess things are similar
06:20:07 <trzkril> Is there some standard way of combining predicates? Say I have "p :: a -> Bool" and "p' :: a -> Bool" and want "f :: a -> Bool" with "f x = p x && p'x".
06:20:16 <subconscious> liftM2 (&&)
06:20:18 <subconscious> liftA2 (&&)
06:21:19 <jethr0> > (&&) <*> (>4) <+> (>6) $ 7
06:21:20 <lambdabot>       Ambiguous occurrence `<+>'
06:21:20 <lambdabot>      It could refer to either `Control.Arrow...
06:21:44 <mm_freak> @pl \x -> p x && q x
06:21:45 <lambdabot> liftM2 (&&) p q
06:21:50 <EvilTerran> > (&&) <$> (>4) <*> (>6) $ 7
06:21:52 <lambdabot>   True
06:21:54 <mm_freak> that's ugly
06:22:01 <jethr0>  hehe
06:22:01 <EvilTerran>   True
06:22:25 <mm_freak> jethr0: well, write combinators
06:22:35 <trzkril> > LiftM2 (&&) (>4) (<7)
06:22:36 <lambdabot>   mueval: Prelude.read: no parse
06:22:37 <Lord_Illidan> Sum is just a fold operation, isn't it?
06:22:41 <Lord_Illidan> Internally
06:22:42 <trzkril> > LiftM2 (&&) (>4) (<7) $ 5
06:22:43 <lambdabot>   mueval: Prelude.read: no parse
06:22:57 <jethr0> trzkril: lowercase "l"
06:23:02 <mm_freak> p .&&. q = \x -> p x && q x
06:23:03 <trzkril> > liftM2 (&&) (>4) (<7) $ 5
06:23:04 <lambdabot>   True
06:23:08 <trzkril> thanks
06:23:18 <mm_freak> Lord_Illidan: yes
06:23:19 <EvilTerran> > let infixl 1 ¿, ?; (¿) = flip (<$>); (?) = (<*>) in (>4) ¿(&&)? (<7) $ 5
06:23:21 <lambdabot>   True
06:23:30 <mm_freak> Lord_Illidan: sum = foldl (+) 0
06:23:31 <EvilTerran> :D
06:23:45 <jethr0> wasn't "foldl" evil?
06:23:46 <Lord_Illidan> or foldl1
06:23:48 <jethr0> @src sum
06:23:49 <lambdabot> sum = foldl (+) 0
06:23:51 <jethr0> hmm
06:23:53 <mm_freak> jonafan: nope, why?
06:24:00 <mm_freak> Lord_Illidan: no, foldl1 fails for the empty list
06:24:00 <Lord_Illidan> Why is "foldl" evil?
06:24:07 <Lord_Illidan> mm_freak, aye, got me there
06:24:20 * jethr0 never quite understood when to use foldl vs foldl'
06:24:22 <EvilTerran> abstract concepts are not capable of evil
06:24:29 <EvilTerran> but foldl does tend to produce big thunks
06:24:32 <mm_freak> jethr0: foldl doesn't work with infinite lists, that's all
06:24:39 <Lord_Illidan> what's foldl`?
06:24:39 <EvilTerran> neither does foldl'
06:24:40 <jethr0> EvilTerran: are the capable of being "the root of all evil"?
06:24:46 <Eridius> foldl' is strict foldl
06:24:53 <mm_freak> but if you can use foldl, it's always preferable over foldr, because it's at least as efficient and usually more
06:25:01 <EvilTerran> jethr0, well, i don't believe in good and evil as absolutes, so not really :P
06:25:07 <jethr0> mm_freak: wouldn't you get a stack overflow with a VERY long list and foldl?
06:25:09 <Eridius> mm_freak: err no, foldr is appropriate when you're constructing a list as the accumulator
06:25:20 <mm_freak> jethr0: you'd get that with foldr as well
06:25:45 <mm_freak> Eridius: yes, never said anything against that =)
06:25:58 <jethr0> would you? hmm, i though it might somehow convert it into a tail-recursive function... but maybe that's undecidable in the general case
06:26:01 <Eridius> <mm_freak> but if you can use foldl, it's always preferable over foldr, because it's at least as efficient and usually more
06:26:06 <Lord_Illidan> foldr.com
06:26:07 <Lord_Illidan> foldl.com
06:26:08 <trzkril> well, when I try that here, i just get "No instance for (Monad ((->) a))"
06:26:09 <Lord_Illidan> :P
06:26:17 <trzkril> the liftM2 thing
06:26:28 <Eridius> jethr0: isn't foldl tail-recursive?
06:26:38 <mm_freak> Eridius: foldr is appropriate because it handles infinite lists, not because it's faster
06:26:40 <wjt> @src foldl
06:26:40 <Eridius> you get a stack overflow with long lists because it builds up big thunks, but foldl' should work fine
06:26:41 <lambdabot> foldl f z []     = z
06:26:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:26:43 <jethr0> @src foldl
06:26:44 <lambdabot> foldl f z []     = z
06:26:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:27:13 <jethr0> yes
06:27:17 <mm_freak> jethr0: as you see, foldl is tail-recursive
06:27:19 <Lord_Illidan> So how do I use foldl'? It's not in scope
06:27:30 <mux> @index foldl'
06:27:30 <lambdabot> Data.List
06:27:33 <mm_freak> add a seq (that's what foldl' does)
06:27:33 <Beelsebob> http://hpaste.org/10744 <-- does anyone see why there should be a syntax error on the line "import Data.Array"?  That was generated by happy, but won't compile
06:28:04 <ivanm> Beelsebob: has to be before the data statements
06:28:06 <Eridius> Beelsebob: imports have to show up at the beginning
06:28:07 <ivanm> I think...
06:28:15 <Beelsebob> ah, yeh that would make sense
06:28:23 <Eridius> the only thing that goes before imports is the module declaration
06:28:25 * Beelsebob ponders how to rejig his file so that happens
06:28:26 <ivanm> so happy stuffed up?
06:28:38 <Lord_Illidan> And regarding infinite lists, how can foldr handle infinite lists, if it begins folding from the last item of the list?
06:28:45 <EvilTerran> it doesn't
06:28:46 <ivanm> Beelsebob: maybe you need a different dance apart from the jig? :p
06:28:51 <EvilTerran> because laziness
06:28:56 <Lord_Illidan> http://www.zvon.org/other/haskell/Outputprelude/foldr_f.html
06:28:57 <Eridius> Lord_Illidan: check out the source
06:28:59 <Eridius> @src foldr
06:28:59 <ivanm> Lord_Illidan: if you have a short-cutting function
06:29:00 <Lord_Illidan> it takes the second argument and the last item of the list and applies the function, then it takes the penultimate item from the end and the result, and so on. See scanr for intermediate results.
06:29:03 <ivanm> @src and
06:29:03 <lambdabot> foldr f z []     = z
06:29:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:29:04 <lambdabot> Title: Haskell : foldr
06:29:04 <lambdabot> and   =  foldr (&&) True
06:29:08 <Lord_Illidan> Unless you apply take, that is?
06:29:11 <ivanm> @src any
06:29:11 <lambdabot> any p =  or . map p
06:29:14 <EvilTerran> Lord_Illidan, yes, that's how it'd work in a strict language
06:29:18 <ivanm> @src or
06:29:18 <lambdabot> or    =  foldr (||) False
06:29:22 <Axman6> > foldr (+) [1..]
06:29:23 <EvilTerran> Lord_Illidan, but it doesn't actually happen in that order in lazy evaluation
06:29:23 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
06:29:23 <lambdabot>        arising from a use...
06:29:25 <ivanm> Lord_Illidan: ^^ like that
06:29:34 <ivanm> Axman6: that needs an initial value
06:29:38 <Eridius> Lord_Illidan: check out foldr (:) [] [1..]
06:29:49 <Eridius> > take 10 $ foldr (:) [] [1..]
06:29:50 <Axman6> > foldr (+) 0 [1..]
06:29:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:29:52 <lambdabot>   mueval: Prelude.read: no parse
06:29:52 <lambdabot>  mueval: *** Exception: stack overflow
06:29:57 <Axman6> so it does, my bad
06:30:13 <EvilTerran> Lord_Illidan, if f isn't strict in its second parameter, evaluation can short-circuit out so (foldr f e <rest of the list>) is never actually evaluated
06:30:24 <Deewiant> ac: only if you place it in the list along with the rest
06:30:33 <EvilTerran> > foldr (||) False (False:True:undefined)
06:30:34 <lambdabot>   True
06:30:38 <EvilTerran> > foldr (||) False (False:False:undefined)
06:30:39 <lambdabot>   mueval: Prelude.read: no parse
06:30:39 <lambdabot>  mueval: *** Exception: Prelude.undefined
06:30:44 <mux> > foldr (flip (:)) [] [1..10]
06:30:46 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
06:30:46 <lambdabot>        Expect...
06:30:55 <mux> err
06:31:01 <mux> > foldl (flip (:)) [] [1..10]
06:31:03 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:31:22 <jethr0> @src reverse
06:31:22 <lambdabot> reverse = foldl (flip (:)) []
06:31:28 <Eridius> huh, neat
06:31:37 <Lord_Illidan> whew
06:31:38 <Deewiant> reverse . foldr (flip f) x y == foldl f x y
06:31:44 <Axman6> ,6,5,4,3,2,1]
06:31:45 <EvilTerran> > ($[]) . foldr (flip(.).(:)) id $ [1..10]
06:31:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:31:59 <EvilTerran> >:D
06:32:06 <Axman6> > foldl (flip (:)) [] [1..10] :: Expr
06:32:07 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
06:32:35 <Axman6> > foldl (flip (:)) [] [1..10] :: [Expr] -- ?
06:32:36 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:32:38 <Deewiant> > foldl (flip f) z [a,b,c,d,e]
06:32:39 <lambdabot>   f e (f d (f c (f b (f a z))))
06:32:45 <mux> also
06:32:46 <Deewiant> > foldr f z [a,b,c,d,e]
06:32:48 <lambdabot>   f a (f b (f c (f d (f e z))))
06:33:01 <Lord_Illidan> whew, and what mm_freak said about applying a seq to foldl to generate foldl', I didn't really get it either
06:33:11 <mux> > let map' f = foldr ((:) . f) [] in map' (+1) [1..5]
06:33:13 <lambdabot>   [2,3,4,5,6]
06:33:16 <Deewiant> ?src foldl'
06:33:17 <lambdabot> foldl' f a []     = a
06:33:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:33:24 <EvilTerran> aka
06:33:44 <jethr0> @src map
06:33:44 <lambdabot> map _ []     = []
06:33:44 <lambdabot> map f (x:xs) = f x : map f xs
06:33:45 <EvilTerran> foldl' f a (x:xs) = (foldl' f $! f a x) xs
06:33:53 <EvilTerran> ?src ($!)
06:33:54 <lambdabot> f $! x = x `seq` f x
06:34:01 <Lord_Illidan> Do I have to import something to use fold' in ghci?
06:34:03 <jethr0> hmm, thought map was defined based on a fold
06:34:06 <Eridius> Lord_Illidan: Data.List
06:34:09 <mux> Lord_Illidan: yes, Data.List
06:34:23 <mux> that's why I made that @index command earlier
06:34:28 <Lord_Illidan> ah, thought so, couldn't access it earlier on
06:34:43 <Philonous> Is it possible to implement foldl' with bang patterns?
06:34:56 <Lord_Illidan> I doubt ghci can show source like lambdabot?
06:35:17 <Deewiant> foldl' f !a (x:xs) = foldl' f (f a x) xs
06:35:23 <Deewiant> I think that's equivalent
06:36:04 <Philonous> Ah, ok, I think that looks much more readable
06:36:08 <EvilTerran> Deewiant, that's *slightly* stricter, i think
06:36:21 <Deewiant> yes, I thought it might be
06:36:24 <EvilTerran> > foldl' (flip const) undefined [1,2,3]
06:36:25 <trzkril> In which module is ((->) a) declared as an instance of Monad?
06:36:26 <lambdabot>   3
06:36:34 <EvilTerran> would be _|_ in that version
06:36:41 <Eridius> trzkril: Control.Monad.Instances, isn't it?
06:37:03 <EvilTerran> jethr0, you can define map as "map f = foldr ((:).f) []" if you want
06:37:06 <Deewiant> yeah, because it has to evaluate the first one as well, of course
06:37:07 <trzkril> indeed, thanks
06:37:12 <Deewiant> so you'd have to use a helper function
06:37:31 <jethr0> i know, have done it, just surprised it isn't defined as such in the prelude
06:37:37 <Deewiant> foldl' f a (x:xs) = go (f a x) xs where go !a (y:ys) = go (f a y) ys
06:37:39 <Deewiant> or so
06:38:10 <Eridius> jethr0: why should map be defined in terms of foldr? The real definition is a bit simpler
06:38:38 <Axman6> agreed
06:38:53 <jethr0> just a thing about using explicit recursion and optimization of base functions like folds
06:39:03 <Eridius> on a completely unrelated note, Tina Fey is absolutely amazing at portraying Palin: http://www.hulu.com/watch/36863/saturday-night-live-couric--palin-open#s-p1-st-i1
06:39:09 <lambdabot> Title: Hulu - Saturday Night Live: Couric / Palin Open, http://tinyurl.com/5x6hev
06:39:13 <subconscious> does anyone want to explain a bit about typechecking with de bruijn indices to me?
06:39:34 <subconscious> Eridius: boo! "Sorry, currently our video library can only be streamed from within the United States"
06:39:42 <Eridius> seriously? huh
06:40:17 <Eridius> watching that video, and watching the earlier one, it's easy to forget that I'm watching Tina Fey and not watching Palin herself
06:40:23 <Lord_Illidan> Does lambdabot allow the let command? like let x = 100?
06:40:29 * subconscious doesn't know who either of those people are :p
06:40:33 <Deewiant> > let x = 100 in x
06:40:35 <lambdabot>   100
06:40:42 <Eridius> subconscious: Tina Fey is an actress on SNL
06:40:43 <jethr0> @let x = 100
06:40:46 <lambdabot>  Defined.
06:40:59 <Eridius> subconscious: Sarah Palin is the VP candidate for McCain
06:41:03 <Lord_Illidan> @let x = 23
06:41:03 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
06:41:06 <Lord_Illidan> see
06:41:22 <subconscious> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=64#a64
06:41:30 <subconscious> I posted my derivation in alpha and de bruijn notation
06:41:49 <subconscious> what I don't understand is exactly how to um.. have it work
06:41:53 <subconscious> does anyone know?
06:45:11 <richardigel> hello! is there a nice IDE to try haskell?
06:45:42 <jethr0> richardigel: not exactly an IDE, but have you tried ghci?
06:45:45 <FunctorSalad_> HOAS Eq instances time again
06:45:56 <subconscious> FunctorSalad_: hehe :)
06:46:10 <FunctorSalad_> say I have a constructor Forall :: (C -> Prop) -> Prop
06:46:12 <FunctorSalad_> subconscious: :)
06:46:17 <subconscious> FunctorSalad_: I start to think HOAS is really useless except for writing an evaluator
06:46:21 <FunctorSalad_> I need to derive Eq for Prop
06:46:40 <subconscious> (or doing proofy stuff but that's not haskell)
06:46:45 <FunctorSalad_> so I'm wondering about generating fresh symbol indices to plug in
06:46:56 <FunctorSalad_> subconscious: hmm I like it so far
06:46:56 <subconscious> You can use my gensym monad if you want
06:47:02 <FunctorSalad_> subconscious: beats variables
06:47:07 <Cale> richardigel: Generally, I find that keeping a ghci window open alongside my favourite text editor (which is usually vim, but sometimes I like emacs too) is more than enough of an IDE for me :)
06:47:20 <Eridius> I've been really enjoying emacs's haskell support
06:47:34 <FunctorSalad_> subconscious: I was thinking that maybe I don't need to pass the indices around recursively in (==) after all
06:47:37 <Eridius> ^C^B opens up a ghci instance inside emacs, and ^C^L loads the current file into the ghci instance
06:47:37 <subconscious> Yeah I don't want to write out alpha conversion or mess with de bruijn indices but HOAS makes somethings impossible afaict
06:48:11 <FunctorSalad_> subconscious: I think I just need to substitute a symb into one level of quantifier and check whether they eval to equal terms?
06:48:27 <subconscious> FunctorSalad_: oh? my naive first implementation would be x == y = withGensyms (names \\ (freevars x ++ freevars y)) (symEq x y)
06:48:37 <ivanm> Eridius: yeah, now if only we had tab-completion inside the ghci instance like you do if launching ghci inside a standard terminal emulator :s
06:48:38 <subconscious> FunctorSalad_: where symEq traverses down doing the obvious instantiation
06:48:50 <Eridius> ivanm: yeah, I wonder why emacs can't provide that?
06:49:08 <Eridius> I did have to edit the haskell-mode, though, it was improperly thinking my ~/.cabal dir was a project.cabal file
06:49:12 <ivanm> Eridius: because it uses shell, I think
06:49:21 <Eridius> and making it so loading the current file into ghci was cd'ing to ~/.cabal first
06:49:27 <subconscious> FunctorSalad_: how do you ensure all the 'symb' are different?
06:49:28 <ivanm> Eridius: yeah, that's been fixed in CVS, but he doesn't want to release a new version yet :s
06:49:33 <subconscious> FunctorSalad_: (except for the same ones which should be equal)
06:49:39 * Eridius had to edit haskell-mode to reject the "*.cabal" file if it is, in fact, a dir
06:49:47 <ivanm> Eridius: I've gotten around it by making a dummy .cabal file in the root of my project
06:49:51 <Eridius> heh
06:49:55 <FunctorSalad_> subconscious: oh, you do it the other way around from my naive way. I generated the symbs first, then passed the counter down to the recursive calls (using State Int monad)
06:49:59 <Eridius> although I don't know how to recompile the .elc file
06:50:08 <subconscious> ah
06:50:45 <FunctorSalad_> don't know whether it makes any important difference
06:50:59 <subconscious> no I don't think so
06:51:02 <Eridius> can someone explain to me what the ((->) r) monad's purpose is? I haven't wrapped my mind around it yet, and ((->) r) doesn't have a description to tell me what it means
06:51:26 <subconscious> Eridius: you can do liftM2 (&&) p q with it
06:51:35 <Eridius> heh
06:51:38 <FunctorSalad_> Eridius: if you have a bunch of functions that all need to read from some fixed data of type r... it hides the passing around of r
06:51:39 <subconscious> :t sequence [(+1),(*2)]
06:51:40 <lambdabot> forall a. (Num a) => a -> [a]
06:51:43 <subconscious> > sequence [(+1),(*2)] 4
06:51:45 <lambdabot>   [5,8]
06:51:58 <FunctorSalad_> Eridius: for example, r = MyApplicationSettings
06:52:02 <besiria> in haskell-mode i can't see properly the signatures of symbols
06:52:16 <Eridius> FunctorSalad_: huh, ok, that explanation makes sense
06:52:20 <subconscious> Eridius: so every function is given the value 4 -- It's a bit like an immutable state monad
06:52:28 <subconscious> oh yeah that was just said
06:52:29 <Eridius> neat
06:52:48 <besiria> i mean the mini-buffer auto-shows the signatures of Prelude, but not the signatures of symbols that i've loaded
06:52:57 <Eridius> besiria: it has the signatures of Prelude hard-coded
06:53:00 <ivanm> Eridius: to recompile, open it up in emacs, and from the elisp menu choose byte-compile this file
06:53:01 <besiria> i have to manualy C-c C-t
06:53:15 <Eridius> ivanm: ah
06:53:22 <ivanm> besiria: enable doc-mode
06:53:29 <ivanm> * eldoc-mode
06:53:42 <FunctorSalad_> subconscious: anyway, how *can* there be var clashes?
06:53:59 <ivanm> Eridius: there's better ways (i.e. from the command line) of doing it, but that's how I always do it ;-)
06:54:04 <Eridius> ivanm: thanks
06:54:18 <Eridius> I was confused at first because my changes weren't even working, until I realized I had to delete the *.elc
06:54:20 * Eridius is a new emacs user
06:54:22 <FunctorSalad_> subconscious: (if you don't substitute symbols into quantifiers deeper down)
06:54:29 <Valodim> boo emacs :P
06:54:39 <Eridius> Valodim: what do you use?
06:54:42 <Valodim> [/obligatory comment]
06:54:50 <subconscious> FunctorSalad_: not sure what you mean
06:55:03 <Eridius> I usually use TextMate, but emacs's haskell support is really impressive
06:55:09 <FunctorSalad_> subconscious: neither am I ;-) I will try to write up a quick example
06:55:16 <subconscious> FunctorSalad_: If you just ensure that every symbol you put into the expression wasn't already in there, you're fine
06:55:29 <subconscious> to figure out what's already in there you have to apply something --
06:55:32 <Eridius> oh hey, any emacs users know how, in an I-Search, to jump to the *beginning* of the match instead of the end?
06:55:45 <subconscious> for that purpose you can just use a dummy
06:55:51 <ivanm> Eridius: as in first match, or the first char in the match?
06:56:01 <ivanm> if the latter, don't think you can, as it's find-as-you-type
06:56:03 <Eridius> ivanm: first char in the match
06:56:13 <ivanm> do reverse-isearch? :P
06:56:17 <Eridius> hah
06:56:27 <subconscious> but nobody has an idea where that '1' comes from in my paste?
06:57:56 <Eridius> subconscious: perhaps if I had any clue what de bruijn was ;)
06:58:32 <subconscious> Eridius: I've been following http://www.e-pig.org/downloads/notanum.pdf
06:58:34 <lambdabot> Title: I am not a number: I am a free variable
06:58:56 <Eridius> oh, this has to do with replacing variable references with indexes? Neat
06:58:58 <subconscious> It's really basic stuff, I am just not clear on how it should interact
06:59:05 <Eridius> I've always thought I should read up on that stuff
07:01:22 <FunctorSalad_> subconscious: I think my point is that (Plus (Var i1) (Var i2)) == (Plus (Var j1) (Var j2)) (/syntactical/ equality) iff i1 == j1 && i2 == j2... it doesn't matter whether i1 and i2 clash
07:01:41 <subconscious> but it does matter if they clash
07:01:42 <FunctorSalad_> since they never see each other in the equality test
07:02:03 <subconscious> consider,   'i1 + 'i1 == 'i1 + 'i2
07:02:11 <subconscious> this should definitely be False
07:02:19 <FunctorSalad_> subconscious: I don't allow free dummies
07:02:33 <subconscious> what do you mean by that ?
07:02:52 <FunctorSalad_> with "dummy" I mean a var generated by the equality test
07:02:59 <FunctorSalad_> "free" as in "free variable"
07:03:07 <subconscious> so where is   (Plus (Var i1) (Var i2)) == (Plus (Var j1) (Var j2))  coming from?
07:03:11 <FunctorSalad_> do you have a closed formula clash example?
07:03:20 <FunctorSalad_> subconscious: from a recursive call in (==)
07:03:26 <subconscious> oh I see what you're saying, then consider:  'i1 + 'i1 == 'j1 + 'j2
07:04:14 <FunctorSalad_> isn't that still non-closed?
07:04:17 <subconscious> j1 and j2 must be different
07:04:23 <subconscious> it's as closed as the example you gave above
07:04:42 <FunctorSalad_> the example wasn't a valid input to the entry point of (==)
07:04:53 <FunctorSalad_> it's an intermediate in the recursion... sorry wasn't clear about that
07:06:19 <FunctorSalad_> subconscious: here's an example implementation http://hpaste.org/10746
07:06:26 <FunctorSalad_> subconscious: I could well be missing something
07:06:40 <Eridius> to any emacs users: is there any way to configure it to render a tab such that I can actually tell there's a hard tab there?
07:06:44 <Eridius> that's one of the biggest things I miss from vim
07:06:58 <ivanm> yes, let me dig it up
07:06:59 <Eridius> also rendering trailing whitespace, but the hard tab thing is more annoying
07:06:59 <FunctorSalad_> (in this example, the user is not allowed to pass terms containing Dummies to (==))
07:07:12 <subconscious> I'm thinking about a case like,   Forall (\x -> Forall (\y -> In x y)) == Forall (\x -> Forall (\y -> In x x))
07:07:28 <subconscious> if x and y are equal (Dummy == Dummy so this is a problem), then you have a false positive
07:07:36 <ivanm> Eridius: trailing whitespace: (setq show-trailing-whitespace t)
07:07:54 <subconscious> so something like Dummy Gensym is required with x == y and x /= y
07:08:01 <Eridius> ivanm: didn't seem to do much when I executed that in a running emacs instance
07:08:01 <ivanm> you might also want (add-hook 'before-save-hook 'delete-trailing-whitespace)
07:08:04 <subconscious> oops
07:08:08 <Eridius> oh hey, it rendered the moment I hit return
07:08:09 <subconscious> ** with x == x and x /= y
07:08:18 <Eridius> ivanm: well no, I don't want to automatically remove trailing whitespace, I just want to know about it
07:08:22 <ivanm> add it to your .emacs, then at the end of the bracket do C-x C-e
07:08:36 <ivanm> as for tabs... I convert all my tabs to spaces :p
07:09:04 <ivanm> Eridius: have a look for whitespace on emacswiki.org
07:09:11 <ivanm> and try out ido-mode!
07:09:13 <Eridius> ivanm: I use spaces too, that's why I want to render hard tabs
07:09:20 <Eridius> ivanm: thanks
07:09:21 <Beelsebob> how does one add a bunch of files to a cabal source dist that have nothing really to do with building the binary (in this case a bunch of example input)
07:09:30 <FunctorSalad_> subconscious: hmm, seems correct... I was disregarding closures :(
07:09:31 <ivanm> Eridius: there'd be a way of doing it, I just don't know how
07:10:13 <subconscious> FunctorSalad_: IIRC you can do exactly what you wrote in lambda prolog by using pi quantification instead of 'Dummy'
07:11:43 <FunctorSalad_> pi quantification?
07:12:09 <FunctorSalad_> pi x. f x == pi y. f y?
07:12:17 <FunctorSalad_> err
07:12:22 <FunctorSalad_> pi x. f x == pi x. g x?
07:13:25 <FunctorSalad_> subconscious: now that I think about it, the gensyms aren't so bad... you can just liftM the (==) for types that don't need the gensyms, right?
07:13:47 <FunctorSalad_> it will just pass the counter through
07:13:49 <subconscious> no it is really awkward and bad to have to use gensyms :)
07:14:41 <FunctorSalad_> btw my example is a bit silly in not disinguising between props and terms ;-)
07:18:45 <FunctorSalad_> hmm where does it get awkward?
07:18:58 <subconscious> half way through writing a typechecker
07:20:05 <FunctorSalad_> ah, luckily I'm just doing a FOL
07:27:30 <Eridius> ugh, emacs's haskell-mode has horrible indentation for do blocks
07:29:01 <subconscious> @seen mmorrow
07:29:02 <lambdabot> I saw mmorrow leaving #haskell, #ghc and #darcs 3d 17h 14m 10s ago, and .
07:31:38 <pfo> cabal install yi-gtk fails with Setup.hs:22:15: Not in scope: `compilerPath'  - any solution?
07:34:19 <Axman6> http://www.strangehorizons.com/2001/20010402/biggest_numbers.shtmlwhat an awesome article
07:34:21 <lambdabot> http://tinyurl.com/3orqcd
07:43:02 <humasect> how come view patterns cause 'warning: pattern match(es) overlapped' ?
07:47:52 <shapr> Is anything nifty happening in the Haskell world lately?
07:49:06 <Taggnostr> I am reading on "real world haskell" that "A Char value represents a Unicode character."
07:50:04 <Taggnostr> I'd like to know something more about unicode support on haskell
07:51:16 <Taggnostr> I guess that strings are unicode too, is there a way to encode them in a utf-8 string for example? will it still be a string or will it have a different type?
07:54:08 <Botje> there's utf8 libs on hackage
07:54:09 <subconscious> nifty I am not sure but I wrote a little unifier and some examples
07:55:09 <metasyntax> Taggnostr: IIRC you can use UTF-8 in GHC source, but the default show and IO functions only output ASCII
07:55:55 <Taggnostr> uhm
07:55:59 <metasyntax> Taggnostr: http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
07:56:08 <Taggnostr> thanks
07:56:10 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
07:58:14 <hackage> Uploaded to hackage: hprotoc 0.3.1
07:58:14 <hackage> Uploaded to hackage: protocol-buffers-descriptor 0.3.1
07:58:14 <hackage> Uploaded to hackage: protocol-buffers 0.3.1
07:58:14 <hackage> Uploaded to hackage: cap 1.0.1
07:58:14 <hackage> Uploaded to hackage: cap 1.0
08:02:07 <Stinger> the html docs need buttons to collapse all children trees or something
08:02:54 <EvilTerran> i agree
08:04:05 <Stinger> I looked at trying to make a greasemonkey script, but it doesn't seem to lend itself well to that, and my limited js knowledge certainly didnt help
08:05:30 <Stinger> actually perhaps it is possible
08:05:45 <EvilTerran> it'll be possible, but potentially fiddle
08:05:46 <EvilTerran> y
08:06:02 <IsoPallo> Hmm... Was there some ready trick to repeat an IO action until it returns that what I want?
08:06:03 <humasect> @hoogle withGhc
08:06:03 <lambdabot> Distribution.Simple.LocalBuildInfo withGHCiLib :: LocalBuildInfo -> Bool
08:06:14 <IsoPallo> Like usin "until" somehow?
08:06:56 <IsoPallo> Or sequence?
08:07:22 <EvilTerran> not really, no
08:07:40 <EvilTerran> such a function would probably be called untilM, but there isn't one
08:07:44 <EvilTerran> ?src until
08:07:44 <lambdabot> until p f x | p x       = x
08:07:44 <lambdabot>             | otherwise = until p f (f x)
08:08:21 <EvilTerran> ?type let untilM p f x = do px <- p x; if px then x else untilM p f =<< f x in untilM
08:08:23 <lambdabot> forall (t :: * -> *) t1. (Monad t) => (t t1 -> t Bool) -> (t t1 -> t (t t1)) -> t t1 -> t t1
08:08:45 <EvilTerran> ... not quite right
08:08:59 <EvilTerran> ?type let untilM p f x = do px <- p x; if px then return x else untilM p f =<< f x in untilM
08:09:00 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> t1 Bool) -> (t -> t1 t) -> t -> t1 t
08:09:06 <EvilTerran> that's more like it
08:15:40 <plutonas> i have a small algorithmic problem, i have 12 different elements numbered 1-12 or from 12-24 etc. if x mod 12 == y mod 12 then x and y represent the same element. I want, given an element to map it somewhere in the range 52-67, how would i do this?
08:16:49 <plutonas> for example given element 48 it should be mapped to 60
08:17:14 <plutonas> of course i could add or subtract 12 until i get in the range, but there must be a better way using mod
08:17:17 <IsoPallo> Evil: Thanks!
08:17:18 <plutonas> that i can't think of
08:17:34 <Olathe> Find the multiple of 12 in it.
08:17:58 <Olathe> endValue div 12
08:18:04 <Olathe> `div`
08:18:58 <plutonas> how does this help?
08:19:05 <plutonas> isn't the remainder more important?
08:19:10 <Olathe> > let modRange low high n = modulus where modulus = high - low in modRange 52 67
08:19:11 <plutonas> oh
08:19:12 <lambdabot>       Overlapping instances for Show (t1 -> t)
08:19:12 <lambdabot>        arising from a use of `...
08:19:15 <Olathe> > let modRange low high n = modulus where modulus = high - low in modRange 52 67 5
08:19:16 <Saizan> 2/win 15
08:19:17 <lambdabot>   15
08:19:59 <Olathe> > let modRange low high n = multiple where multiple = modulus*(div high modulus); modulus = high - low in modRange 52 67 5
08:20:00 <lambdabot>   60
08:20:58 <Olathe> > let modRange low high n = breakPoint where breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low in modRange 52 67 5
08:21:00 <lambdabot>   7
08:21:40 <Olathe> > let modRange low high n = reducedN where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low in modRange 52 67 5
08:21:42 <lambdabot>   5
08:21:45 <plutonas> hm
08:21:53 * plutonas gets confused, will try to understand the code
08:22:31 <Ferdirand> how about \x -> ((x - 4) `mod` 12) + 52 ?
08:22:55 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low in modRange 52 67 5
08:22:56 <lambdabot>   65
08:23:01 <adekoba> how would I overwrite text in a normal text file? I tried using AppendMode, but it will only allow writing at the end of the file, and WriteMode erases the original file
08:23:08 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low in map (modRange 52 67) [0..15]
08:23:09 <lambdabot>   [60,61,62,63,64,65,66,67,53,54,55,56,57,58,59,60]
08:23:21 <Olathe> That's not quite right.
08:23:27 <subconscious> eek!
08:23:29 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in map (modRange 52 67) [0..15]
08:23:30 <lambdabot>   [64,65,66,67,52,53,54,55,56,57,58,59,60,61,62,63]
08:23:41 <Olathe> There we are.
08:24:07 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in map (flip mod 16) $ map (modRange 52 67) [0..15]
08:24:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
08:24:28 <Olathe> And it doesn't affect the class it's in, which is always good :)
08:24:45 <plutonas> Ferdirand: yours looks simpler
08:24:54 <plutonas> thanks all though
08:25:31 <Olathe> If you want mod 12, though, you need modRange 52 63
08:25:55 <adekoba> nevermind, one can overwrite text with ReadWriteMode
08:25:56 <Deewiant> > (\mn mx -> map (\x -> (x+mn)`mod`mx)) 52 67 [0..20]
08:25:58 <lambdabot>   [52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,0,1,2,3,4,5]
08:26:11 <Olathe> Ahh, nice !
08:26:14 <plutonas> Olathe: what exactly do you mean?
08:26:23 <plutonas> it's mod12 this way, no?
08:26:28 <Deewiant> ?pl \mn mx -> map (\x -> (x+mn)`mod`mx)
08:26:28 <lambdabot> (map .) . flip . (mod .) . (+)
08:26:32 <Olathe> plutonas: Well, you were talking about mod 12, but you gave a range with 16 elements in it.
08:27:32 <Olathe> > (\mn mx x -> (x+mn)`mod`mx) 52 67 0
08:27:34 <lambdabot>  Terminated
08:27:36 <Olathe> > (\mn mx x -> (x+mn)`mod`mx) 52 67 0
08:27:37 <lambdabot>   52
08:27:44 <Olathe> @pl (\mn mx x -> (x+mn)`mod`mx)
08:27:45 <lambdabot> flip . (mod .) . (+)
08:27:53 <plutonas> Olathe: yes true but any element in the range would do
08:28:15 <plutonas> i mean if it's 52 or 64, it's both good
08:28:18 <Olathe> plutonas: I know, but to use what I gave, you need that.
08:28:31 <plutonas> need what?
08:28:43 <Olathe> plutonas: The endpoints must have only 12 elements.
08:28:54 <Olathe> plutonas: Otherwise, it thinks the modulus is a bit larger.
08:29:00 <Deewiant> > (\mn mx -> map (\x -> (x`mod`(mx-mn))+mn)) 52 67 [0..20]
08:29:02 <lambdabot>   [52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,52,53,54,55,56,57]
08:29:11 <Deewiant> that's what I was trying to do :-P
08:29:13 <Olathe> Ahh, Even better.
08:29:18 <Deewiant> ?pl \mn mx -> map (\x -> (x`mod`(mx-mn))+mn)
08:29:19 <lambdabot> (map .) . (flip =<< ((flip . ((+) .) . flip mod) .) . subtract)
08:29:24 <Deewiant> meh
08:29:38 <Deewiant> ?pl \x -> (x`mod`(mx-mn))+mn
08:29:39 <lambdabot> (mn +) . (`mod` (mx - mn))
08:29:41 <Olathe> @pl (\mn mx x -> (x`mod`(mx-mn))+mn)
08:29:42 <lambdabot> flip =<< ((flip . ((+) .) . flip mod) .) . subtract
08:30:03 <Olathe> > let modRange = flip =<< ((flip . ((+) .) . flip mod) .) . subtract in map modRange [0..30]
08:30:05 <lambdabot>       Overlapping instances for Show (a -> a -> a)
08:30:05 <lambdabot>        arising from a use ...
08:30:12 <Olathe> > let modRange = flip =<< ((flip . ((+) .) . flip mod) .) . subtract in map (modRange 52 67) [0..30]
08:30:14 <lambdabot>   [52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,52,53,54,55,56,57,58,59,60,61...
08:30:29 <Olathe> Hmm...
08:30:42 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in map (flip mod 16) $ map (modRange 52 67) [0..30]
08:30:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
08:30:51 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in map (modRange 52 67) [0..30]
08:30:53 <lambdabot>   [64,65,66,67,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,52,53,54,55,56...
08:31:15 <Deewiant> 0 becomes 64?
08:31:33 <Olathe> Deewiant: Well, with a modulus of 16, sure.
08:31:46 <Olathe> > let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in map (modRange 52 63) [0..30]
08:31:47 <lambdabot>   [60,61,62,63,52,53,54,55,56,57,58,59,60,61,62,63,52,53,54,55,56,57,58,59,60...
08:31:54 <Olathe> With 12, you get that lovely thing.
08:32:29 <Deewiant> when mapping to a range [x,y) I'd map 0 to x :-)
08:32:31 <Olathe> @pl let modRange low high n = reducedN + multiple - (if reducedN <= breakPoint then 0 else modulus) where reducedN = mod n modulus; breakPoint = high - multiple; multiple = modulus*(div high modulus); modulus = high - low + 1 in modRange
08:32:31 <lambdabot> (line 1, column 112):
08:32:31 <lambdabot> unexpected "="
08:32:31 <lambdabot> expecting variable, "(", operator, "+", "-", ";" or "in"
08:32:51 <Ferdirand> \x min max -> min + ((x - min) `mod` (max - min))
08:32:54 <Olathe> Deewiant: Well, you can, if you don't want to preserve the class it's in.
08:33:04 <Olathe> > mod 52 12
08:33:05 <lambdabot>   4
08:33:18 <Deewiant> > mod 0 16
08:33:20 <lambdabot>   0
08:33:41 <Olathe> As you can see, if you map 0 to 52, you change it from 0 to 4, effectively.
08:34:03 <Olathe> 52 and 0 aren't the same mod 12.
08:34:06 <Deewiant> alright, I get your point.
09:01:33 <marcot> Good afternoon.
09:01:52 <marcot> How do I get the name of the modules of a installed package?
09:03:01 <maltem> ghc-pkg describe
09:03:23 <marcot> maltem: Is there a haskell function for it?
09:04:30 <maltem> marcot: possibly, somewhere in the Cabal or Ghc sources... but I don't know it
09:04:50 <marcot> maltem: ok, thanks.
09:05:01 <EvilTerran> packages aren't really an in-language thing
09:05:44 <marcot> EvilTerran: Yes, I was wondering something about the GHC API.
09:15:25 <edwardk> @seen bos
09:15:25 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 10h 8m 45s ago.
09:15:31 <edwardk> @seen shapr
09:15:31 <lambdabot> shapr is in #haskell-soc, #haskell-blah, #scannedinavian and #haskell. I last heard shapr speak 1h 27m 39s ago.
09:15:32 <bos> hi
09:15:42 <edwardk> hola
09:16:20 <edwardk> was just going to say i tripped over gold and went whoa, then i tripped over your blog entry and laughed as usual we're skirting around the same issues ;)
09:16:44 <bos> oh?
09:17:12 <edwardk> it cut a half a minute or so off of the build cycle for my toy project
09:17:29 <bos> oh, gold the linker.
09:17:31 <edwardk> yeah
09:17:39 <bos> yes, it's good stuff.
09:19:37 <edwardk> does anyone know if anyone is working on optimizing the ghc bytecode interpreter? i just remembered it was there and started digging through it. (i've been doing a lot of work on call-threading/trace treeing a similar bytecode and was curious if i should consider doing the same there)
09:19:53 <bos> i'm pretty sure it's not a focus of any effort.
09:20:04 <edwardk> fair enough
09:20:12 <bos> all the work happens on the native codegen side.
09:20:18 <edwardk> yeah
09:20:27 <edwardk> but it'd be nice to have a snappy ghci ;)
09:20:33 <bos> i'm sure that if you wanted to work on it, that would be welcomed. ghci is very slow.
09:20:53 <edwardk> i might do something, even if only to direct thread or call thread it
09:21:17 <chrisdone> I do a lot of my work in ghci, more schpeed would be really appreciated here
09:22:45 <edwardk> i have to admit i was struck by how much simpler their bytecode was than mine but then i realized they can call into compiled code from it so they don't have to deal with all the corner cases the main compiler does
09:23:12 <edwardk> and that unlike yhc it comes down on the 'right side' of the eval/apply vs. push/enter debate.
09:26:10 <marcot> I've seen Distribution.InstalledPackageInfo.  But I don't know where the String used in parseInstalledPackageInfo comes from.
09:26:21 <bos> right.
09:27:06 <Saizan> marcot: see Distribution.Simple.GHC.getInstalledPackages or similar
09:27:53 <Eridius> @pl \x y -> Just (x,y)
09:27:54 <lambdabot> (Just .) . (,)
09:28:59 <marcot> Saizan: this will still give me only the PackageIdentifier, which is not enough for parseInstalledPackageInfo.  My problem is to get from the PackageIdentifier to the package description, like ghc-pkg describe.
09:31:33 <subconscious> Has anyone seen this pattern: data Foo = ... Free Sym | Bound Integer & data Sym = Sym String | Local Integer ?
09:31:41 <subconscious> and in particular, know how to simplify it?
09:32:59 <Saizan> marcot: uhm, i'm talking about darcs Cabal where getInstalledPackages returns (PackageIndex InstalledPackageInfo)
09:34:06 <Saizan> marcot: however it essentially asks ghc-pkg :)
09:34:24 <Olathe> subconscious: You could probably change it to Sym String | Int Integer
09:36:31 <BONUS> i rly love the pl version of \xs -> zip xs (tail xs)
09:36:32 <BONUS> :]
09:38:50 <chrisdone> flip zip . tail ?
09:39:27 <chrisdone> no
09:39:33 <Saizan> @quote aztec
09:39:34 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
09:39:39 <EvilTerran> zip <*> tail
09:39:49 <chrisdone> @src ap
09:39:50 <lambdabot> ap = liftM2 id
09:39:55 <EvilTerran> might be better to make that (zip <*> drop 1), mind
09:40:00 <chrisdone> heh, I was getting to liftM2
09:40:14 <ddarius> liftM2 ($) would be clearer
09:41:55 <Eridius> @pl \x y -> Just (x ++ [y])
09:41:55 <lambdabot> (Just .) . (. return) . (++)
09:42:42 <Olathe> > typeOf (Just "hello")
09:42:44 <lambdabot>   Maybe [Char]
09:42:49 <Olathe> > show $ typeOf (Just "hello")
09:42:50 <lambdabot>   "Maybe [Char]"
09:43:00 <Eridius> interesting use of return instead of , say, (:[]). I guess they're the same thing in this context
09:43:14 <subconscious> @@ @djinn @run typeOf (\x -> x)
09:43:15 <lambdabot>  Error: Undefined type Add
09:43:30 <chrisdone> “Add type signature”
09:43:37 <chrisdone> > typeOf id
09:43:38 <lambdabot>   Add a type signature
09:43:43 <Deewiant> @. djinn type (\x -> x)
09:43:44 <lambdabot> f a = a
09:44:54 <Olathe> @. djinn type (\(x:xs) -> [])
09:44:55 <lambdabot> Error: Undefined type []
09:45:13 <Saizan> @djinn-env
09:45:13 <lambdabot> data () = ()
09:45:13 <lambdabot> data Either a b = Left a | Right b
09:45:13 <lambdabot> data Maybe a = Nothing | Just a
09:45:13 <lambdabot> data Bool = False | True
09:45:13 <lambdabot> data Void
09:45:16 <lambdabot> type Not x = x -> Void
09:45:17 <lambdabot> class Eq a where (==) :: a -> a -> Bool
09:45:19 <lambdabot> type Const a b = a
09:51:53 <marcot> Saizan: thanks, I was looking at Cabal-1.2.  This is just what I needed.
09:59:10 <bos> bloom filters and haskell = fast bioinformatics: http://www.serpentine.com/blog/2008/09/28/using-bloom-filters-for-large-scale-gene-sequence-analysis-in-haskell/
09:59:14 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » Using Bloom filters for large scal ..., http://tinyurl.com/3zaao8
10:04:06 <ddarius> bos: Intend to win the Most Practical Paper award?
10:06:03 <bos> ddarius: if it gets accepted at all, i'll be happy.
10:20:58 <ddarius> bos: Any relevant bioinformatics conferences to submit to?
10:21:24 <subconscious> @pl x * y = f x . g y
10:21:25 <lambdabot> (line 1, column 7):
10:21:25 <lambdabot> unexpected "="
10:21:25 <lambdabot> expecting variable, "(", operator, "*", "/", "`quot`", "`rem`", "`div`", "`mod`", ":%", "%" or end of input
10:21:35 <subconscious> @pl ohForGoodnessSake x y = f x . g y
10:21:35 <lambdabot> ohForGoodnessSake = (. g) . (.) . f
10:22:13 <subconscious> @tell someone there is a stupid bug in @pl
10:22:13 <lambdabot> Consider it noted.
10:22:29 <ddarius> subconscious: It's not a bug.  @pl doesn't accept the full Haskell language.
10:22:46 <someone> Hello.
10:22:47 <lambdabot> someone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:22:55 <subconscious> I claim it's a bug
10:22:55 <someone> @messages
10:22:56 <lambdabot> subconscious said 43s ago: there is a stupid bug in @pl
10:22:56 <ddarius> In fact, you can tell from the error message that it is using Parsec.
10:23:11 <subconscious> Since I wish it didn't work that way
10:23:47 <Saizan> fix it :)
10:23:48 <ddarius> subconscious: Then "fix" it
10:27:00 <Olathe> @ pl (x :% y) = (X, y)
10:27:09 <Olathe> @ pl \(x :% y) - (X, y)
10:27:13 <Olathe> @pl \(x :% y) -> (X, y)
10:27:14 <lambdabot> (line 1, column 6):
10:27:14 <lambdabot> unexpected "%"
10:27:14 <lambdabot> expecting "()", natural, identifier, "_" or "("
10:27:20 <Olathe> Yay, enter next to shift.
10:27:32 <Deewiant> @hoogle (:%)
10:27:33 <lambdabot> Warning: Unknown type :%
10:27:33 <lambdabot> Prelude undefined :: a
10:27:33 <lambdabot> Data.Array.Base arrEleBottom :: a
10:27:47 <Olathe> I think :% is the Ratio constructor.
10:28:04 <Olathe> Evilly hidden from us.
10:28:07 <Olathe> @src (%)
10:28:07 <lambdabot> x % y = reduce (x * signum y) (abs y)
10:28:12 <Olathe> @src reduce
10:28:13 <lambdabot> reduce _ 0 = undefined
10:28:13 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
10:28:13 <lambdabot>     where d = gcd x y
10:28:14 <Deewiant> @src Ratio
10:28:15 <lambdabot> data (Integral a) => Ratio a = !a :% !a
10:28:44 <karmazilla> python has easy_install for pypi... anything like it for hackage?
10:29:19 <shapr> edwardk: you called?
10:29:24 <shapr> @seen edwardk
10:29:24 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 1h 6m 13s ago.
10:30:50 <Saizan> karmazilla: cabal-install, i guess
10:31:13 <Saizan> ?where cabal-install
10:31:13 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:31:18 <adekoba> Is there another way to insert text into a file without having to read the entire file in memory, prepent the inserted text to the read text, then write the entire thing back?
10:31:48 <dmwit> Open it in append mode.
10:31:54 <EvilTerran> if you're appending.
10:32:20 <Olathe> @src (++)
10:32:20 <lambdabot> []     ++ ys = ys
10:32:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:32:20 <lambdabot> -- OR
10:32:20 <lambdabot> xs ++ ys = foldr (:) ys xs
10:32:40 <ddarius> adekoba: You can do it in constant memory equal to the size of the text to be inserted.
10:32:51 <adekoba> dmwit, EvilTerran: I mean insert in the beginning of the file
10:32:52 <EvilTerran> you could be a bit more efficient if you're inserting in the middle if you open it in read-write mode and use hSeek
10:33:08 <EvilTerran> in that case, you might as well do it as you described, i think
10:33:15 <adekoba> so no other way?
10:33:25 <EvilTerran> well
10:33:40 <EvilTerran> depending on the size of the file, you might want to do it in the way alluded to by ddarius
10:34:08 <EvilTerran> but there's no low-level support for efficiently inserting into a file except at the end
10:34:08 <dmwit> That's an awful lot of manual memory management.
10:34:53 <EvilTerran> if you wrote out to a different file to the one you're reading from, you could take advantage of lazy IO to do it in theoretically-constant memory
10:35:11 <ddarius> EvilTerran: I was talking about an in-place way.
10:35:37 <ddarius> The easy way would be to write out the prefix to a separate file, append the text to be inserted, and then append the remainder of the text.
10:35:41 <EvilTerran> ddarius, i figured, i was suggesting an alternative
10:36:27 <adekoba> I'm not sure I understand ddarius's suggestion. Do you mean reading one character from the to-be-inserted text, reading from the actual file, replacing the two, etc?
10:36:31 <ddarius> The in-place way would be to seek to the location to insert, copy the length textToInsert to a buffer, write out the text to insert, and repeat.
10:38:00 <adekoba> makes sense.
10:38:28 <adekoba> I'm trying to avoid temporary files. They frighten me.
10:38:45 <Olathe> Temporary files will get us all one day.
10:38:56 <adekoba> exactly
10:39:00 <ddarius> adekoba: Unless the file you are operating on is huge, the temporary file way is probably the easiest and fastest.
10:39:05 <karmazilla> Saizan: oh, looks like all I needed was cabal :)
10:39:06 <newsham> if only there was a mechanism for passing data from one program to another program withot using temporary intermediates
10:39:19 <adekoba> ddarius: It's not huge. It's an mp3 file.
10:39:22 <newsham> it could revolutionize the way you compose programs together
10:39:40 <ddarius> adekoba: In that case, in memory might be fastest and easiest.
10:39:58 <adekoba> ddarius: alright, I'll stick with that.
10:40:07 <adekoba> Thanks for the suggestions, everyone.
10:40:50 <ddarius> The temporary file way is actually safest.  If the power goes out using the in-memory or in-place way then you lose the input.
10:43:53 <adekoba> True, but I would rather not have to depend on temporary files for such simple operation. It may not be the safest, but to me, it's preferable.
10:44:15 <newsham> you have a battery and/or UPS, right?
10:44:27 <adekoba> lol, yes
10:47:38 <Olathe> You could insert a constant amount of text each time you open the file ;)
11:08:04 <roconnor> >40*25.5
11:08:07 <roconnor> > 40*25.5
11:08:09 <lambdabot>   1020.0
11:12:04 <RayNbow> > 40 * 25 + div 40 2
11:12:05 <lambdabot>   1020
11:12:32 <Olathe> > 40*25.5 :: Rational
11:12:33 <lambdabot>   1020%1
11:12:50 <pstickne> why is it %1?
11:13:04 <pstickne> (err, what does that mean?)
11:13:06 <dmwit> Because it's a Rational.
11:13:09 <Olathe> Because the denominator is 1.
11:13:10 <dmwit> > 3%5
11:13:11 <lambdabot>   3%5
11:13:16 <dmwit> > 3/5 :: Rational
11:13:18 <lambdabot>   3%5
11:13:23 <ddarius> > 40 * 25 + 40 `shiftR` 1
11:13:24 <lambdabot>   Add a type signature
11:13:31 <Olathe> You add a type signature !
11:13:40 <RayNbow> > 2^10 - 4
11:13:41 <lambdabot>   1020
11:13:45 <dmwit> Olathe: There's too many choices!
11:14:20 <pstickne> any reason why it doesn't come back as "3/5"?
11:14:36 <Olathe> pstickne: The people who made Data.Ratio are evil.
11:14:42 <pstickne> fair enough
11:14:59 <RayNbow> pstickne: % is a Rational constructor
11:15:11 <ddarius> RayNbow: :% is
11:15:19 <RayNbow> hmm
11:15:30 <RayNbow> oh right, infix constructors start with :...
11:16:01 <pstickne> > 3 % 5 % 7
11:16:03 <lambdabot>       No instance for (Integral (Ratio t))
11:16:03 <lambdabot>        arising from a use of `show...
11:16:18 <Olathe> > 3 / 5 / 7 :: Rational
11:16:19 <lambdabot>   3%35
11:16:56 <skorpan> is there any tutorial/FAQ on haskell-x11 (Graphics.X11)?
11:17:52 <Olathe> > let s n = say.map (\x -> if x == '%' then '/' else x).show $ n in s (3/5::Rational)
11:17:53 <lambdabot>   3/5
11:18:10 <Olathe> > let s n = say.map (\x -> if x == '%' then '/' else x).show $ n in s (40*25.5::Rational)
11:18:12 <lambdabot>   1020/1
11:18:15 <Olathe> Heh
11:19:51 <Olathe> > let s = say.map s'.show where s' "%1" = ""; s' "" = ""; s' ('%':xs) = '/':xs; s' (x:xs) = x:s' xs in s (40*25.5::Rational)
11:19:53 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
11:21:25 <Olathe> > let s = say.s'.show where s' "%1" = ""; s' "" = ""; s' ('%':xs) = '/':xs; s' (x:xs) = x:s' xs in s (40*25.5::Rational)
11:21:26 <lambdabot>   1020
11:21:29 <ddarius> > transpose $ tails "foobar"
11:21:30 <lambdabot>   ["foobar","oobar","obar","bar","ar","r"]
11:21:43 <Olathe> > let s = say.s'.show where s' "%1" = ""; s' "" = ""; s' ('%':xs) = '/':xs; s' (x:xs) = x:s' xs in s (1/3::Rational)
11:21:44 <lambdabot>   1/3
11:21:52 <ddarius> > tails "foobar"
11:21:54 <lambdabot>   ["foobar","oobar","obar","bar","ar","r",""]
11:24:42 <plutonas> can i match like that? (a,b):xs ?
11:24:48 <ddarius> Sure.
11:25:40 <Olathe> > let s ((a,b):xs) = (a, b) in s [(1, 2)]
11:25:41 <lambdabot>   (1,2)
11:26:25 <Olathe> > let s ((a,b):xs) = (a + b)*s xs in s [(1, 2), (3, 4)]
11:26:26 <lambdabot>   mueval: Prelude.read: no parse
11:26:26 <lambdabot>  mueval: *** Exception: /tmp/276200597140039...
11:26:43 <Olathe> > let s ((a,b):xs) = (a + b)*(s xs); s [] = 1 in s [(1, 2), (3, 4)]
11:26:44 <lambdabot>   21
11:28:04 <Olathe> > let dp xs ys = dp' (zip xs ys) where dp' ((a,b):xs) = (a * b)+(dp' xs); s [] = 1 in dp [1, 3] [2, 4]
11:28:05 <lambdabot>   mueval: Prelude.read: no parse
11:28:05 <lambdabot>  mueval: *** Exception: /tmp/157245798062194...
11:28:28 <Olathe> > let dp xs ys = dp' (zip xs ys) where dp' ((a,b):xs) = (a * b)+(dp' xs); dp' [] = 0 in dp [1, 3] [2, 4]
11:28:29 <lambdabot>   14
11:29:50 <ddarius> Superfluous parentheses
11:29:54 <Beelsebob> woohoo! Thesis sent off... time to insert beer!
11:30:56 <ddarius> > let dp xs ys = dp' $ zip xs yz where dp' ((a,b):xs) = a*b+dp' xs; dp' [] = 0 in dp [1,3] [2,4]
11:30:57 <lambdabot>   mueval: Prelude.read: no parse
11:31:05 <ddarius> > let dp xs ys = dp' $ zip xs ys where dp' ((a,b):xs) = a*b+dp' xs; dp' [] = 0 in dp [1,3] [2,4]
11:31:07 <lambdabot>   14
11:31:15 <ddarius> Or in the Haskell world
11:31:30 <ddarius> > sum (zipWith (+) [1,3] [2,4])
11:31:31 <lambdabot>   10
11:31:38 <ddarius> > sum (zipWith (*) [1,3] [2,4])
11:31:39 <lambdabot>   14
11:32:02 <ddarius> This makes me think about generalizing qsort...
11:32:14 <ulfdoz> @src repeat
11:32:14 <lambdabot> repeat x = xs where xs = x : xs
11:32:22 <ddarius> fix . (:)
11:33:03 <RayNbow> > sequence [numerator,denominator] >>> map show >>> intersperse "/" >>> concat $ 3%4
11:33:04 <lambdabot>   mueval: Prelude.read: no parse
11:33:14 <RayNbow> bah lambdabot...
11:33:31 <RayNbow> lambdabot still hates >>>
11:33:45 <Deewiant> none of Control.Arrow works
11:33:53 <subconscious> @let (>>>) = flip (.)
11:33:54 <lambdabot>  Defined.
11:33:57 <Deewiant> although if you do a @let it contradicts :-P
11:34:00 <subconscious> > sequence [numerator,denominator] >>> map show >>> intersperse "/" >>> concat $ 3%4
11:34:00 <lambdabot>       Ambiguous occurrence `>>>'
11:34:01 <lambdabot>      It could refer to either `L.>>>', defin...
11:34:04 <subconscious> @let (>>>>) = flip (.)
11:34:05 <lambdabot>  Defined.
11:34:09 <subconscious> > sequence [numerator,denominator] >>>> map show >>>> intersperse "/" >>>> concat $ 3%4
11:34:10 <lambdabot>   "3/4"
11:35:34 <Olathe> @pl let s n = s' (numerator n) (denominator n) in s
11:35:34 <lambdabot> liftM2 s' numerator denominator
11:36:50 <Olathe> @pl let s' n d = [show n, show d] in s'
11:36:51 <lambdabot> (. (return . show)) . (:) . show
11:37:07 <Olathe> @pl let s' f n d = [f n, f d] in s'
11:37:07 <lambdabot> liftM2 flip (((.) . (:)) .) (flip flip [] . ((:) .))
11:37:22 <subconscious> :t (flip flip [] . ((:) .))
11:37:23 <lambdabot> forall b a. (a -> b) -> a -> [b]
11:37:52 <subconscious> @pl f x = [x,x,x,x,x,x,x,x,x]
11:37:52 <lambdabot> f = ap (:) (ap (:) (ap (:) (ap (:) (ap (:) (ap (:) (ap (:) (ap (:) return)))))))
11:38:07 <Deewiant> :-S
11:38:20 <Deewiant> f = take 9 . repeat
11:38:43 <subconscious> @pl f x y = [x,y,x,y,x,y,x,y,x]
11:38:44 <lambdabot> f = liftM2 (.) (:) (ap (:) . liftM2 (.) (:) (ap (:) . liftM2 (.) (:) (ap (:) . liftM2 (.) (:) (flip (:) . return))))
11:38:52 <subconscious> @pl f x y z = [x,y,z,y,x,y,x,y,z]
11:38:54 <lambdabot> f = ap ((.) . (.) . (:)) (liftM2 (.) (:) . (ap (:) .) . liftM2 (.) (:) . ap ((.) . (.) . (:)) (liftM2 (.) (:) . (. ((. return) . (:))) . (.) . (:)))
11:39:08 <Olathe> > let s = say.liftM2 s' numerator denominator where s' n 1 = show n; s' n d = show n ++ "/" ++ show d in s (45/1::Rational)
11:39:09 <lambdabot>   mueval: Prelude.read: no parse
11:39:12 <Olathe> No parse ?!
11:39:24 <Deewiant> Olathe: "an error occurred"
11:39:32 <Olathe> zomg !
11:39:35 <Deewiant> up to you to figure out where the problem is
11:39:45 <subconscious> :t liftM2 (.)
11:39:46 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
11:39:47 <subconscious> :t liftM2 (.) (:)
11:39:48 <lambdabot> forall a a1. (a1 -> a -> [a1]) -> a1 -> a -> [a1]
11:40:00 <ddarius> > sequence [(:),(:),(:),(:),(:),(:),(:),(:)] '1' []
11:40:01 <lambdabot>   Couldn't match expected type `[a] -> t'
11:40:26 <Deewiant> ?ty sequence [(:)]
11:40:28 <lambdabot> forall a. a -> [[a] -> [a]]
11:42:43 <Olathe> @type \"omg" -> "zomg"
11:42:44 <lambdabot> [Char] -> [Char]
11:43:19 <Deewiant> > (\"omg" -> "zomg") "lol"
11:43:20 <lambdabot>   mueval: Prelude.read: no parse
11:43:20 <lambdabot>  mueval: "*** Exception: /tmp/44021692874793...
11:43:30 <Olathe> > (\"omg" -> "zomg") "omg"
11:43:32 <lambdabot>   "zomg"
11:43:34 <Olathe> ZOMG !
11:43:40 <mib_hlqlmc> hello... does anyone know the command to show at the end of each result the type of the answer?
11:43:57 <Olathe> There's :?
11:44:02 <mib_hlqlmc> i mean.. you type div 4 2 and it shows something like: 2 :: integer
11:44:23 <Olathe> Looks like +t
11:44:29 <Olathe> According to :?
11:44:42 <mib_hlqlmc> ?
11:44:47 <Olathe> ?!
11:44:47 <lambdabot> Maybe you meant: . ? @ v
11:44:57 <mib_hlqlmc> i remember the command was something like: sl ??
11:45:10 <mib_hlqlmc> sl l+... i don't know..can't remember
11:45:11 <Olathe> :set +t
11:46:31 <mib_hlqlmc> let me try.. one sec
11:46:41 <mib_hlqlmc> hugs is in another pc..
11:46:48 <subconscious> Are there any parsers for parsing a programming language more declarative than parsec?
11:48:16 <shrughes> parsec without >>=?
11:48:44 <opqdonut_> subconscious: well there's happy
11:48:48 <opqdonut_> a parser generator
11:48:56 <jethr0> > let {parts = (\(a,b) -> (a,tail b)) . break ('%'==); say s = let (a,b) = parts (show s) in if b == "1" then a else a++"/"++b} in say (14%1)
11:48:57 <lambdabot>   "14"
11:50:30 <jethr0> "more declarative"?
11:51:00 <jethr0> do you mean taking only a BNF description?
11:51:21 <subconscious> I mean less work
11:52:35 <jethr0> have you tried happy? is it a structured grammar (i.e. LALR1) or something ad hoc?
11:53:02 <jethr0> "happy:
11:53:08 <jethr0> grr
11:53:14 <shrughes> less work?  what's so bad about parsec?
11:53:38 <subconscious> it'll take about a page to get parsec to do what I want
11:57:46 <jethr0> subconscious: i can barely handle all that information you're providing ^_^
11:58:15 <hackage> Uploaded to hackage: maccatcher 0.0.0
11:58:15 <hackage> Uploaded to hackage: explicit-exception 0.0.1
12:01:09 <mib_hlqlmc> did you guys know how to see the type?
12:01:33 <mib_hlqlmc> i mean.. i type into hugs's console: mod 5 2
12:01:40 <mib_hlqlmc> and then returns: 1 :: integer
12:02:53 <mib_hlqlmc> does haskell interprets 2.34 as real or double? is there any diference between them?
12:02:55 <Deewiant> mib_hlqlmc: in ghci, :set +t
12:03:00 <Deewiant> :t 2.34
12:03:01 <lambdabot> forall t. (Fractional t) => t
12:03:07 <Deewiant> it can be anything!
12:03:07 <ddarius> mib_hlqlmc: There is no "real" type.
12:03:37 <jethr0> mib_hlqlmc: you don't mean ":type <expression>", do you?
12:03:49 <jethr0> > 2.34 :: Double
12:03:50 <lambdabot>   2.34
12:04:17 <ddarius> > 2.34 :: Rational
12:04:18 <jethr0> hugs also has ":set"
12:04:18 <lambdabot>   117%50
12:04:22 <mib_hlqlmc> hmm
12:04:25 <mib_hlqlmc> i use winhugs...
12:04:32 <mib_hlqlmc> it doesn't accept et +t
12:04:55 <mib_hlqlmc> i remember it began with "sl"
12:06:35 <jethr0> http://cvs.haskell.org/Hugs/pages/users_guide/options.html says ":set +t" should work in hugs. no idea about winhugs
12:06:40 <lambdabot> Title: Changing the behaviour of Hugs
12:06:56 <mib_hlqlmc> :(
12:07:58 <mib_hlqlmc> okkk.. anyway...
12:08:13 <mib_hlqlmc> which type does it return for a "sin" function
12:08:36 <mib_hlqlmc> and for "signum"
12:08:49 <Deewiant> ?ty sin
12:08:51 <lambdabot> forall a. (Floating a) => a -> a
12:08:52 <Deewiant> ?ty signum
12:08:53 <lambdabot> forall a. (Num a) => a -> a
12:09:33 <mib_hlqlmc> ook...
12:09:41 <mib_hlqlmc> thank you... didn't know about this "?"'s stuff :)
12:10:07 <jethr0> mib_hlqlmc: you should also be able to type ":type sin" in hugs
12:10:26 <headcrab> hmm.. sounds interesting
12:10:31 <headcrab> jethr0: ty
12:10:39 <headcrab> Deewiant: ty u 2
12:12:20 <FunctorSalad_> eh? since when are monads not applicatives? "No instance for (Applicative (State Int))"
12:12:30 <subconscious> recently
12:12:38 <FunctorSalad_> :o
12:12:38 <subconscious> I only noticed it from 6.9 ~> 6.10
12:12:49 <FunctorSalad_> I'm still on 6.8.3
12:13:35 <FunctorSalad_> oh well there's still `ap`
12:14:10 <jethr0> ?src Applicative
12:14:10 <lambdabot> class Functor f => Applicative f where
12:14:10 <lambdabot>     pure  :: a -> f a
12:14:10 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
12:15:21 <ddarius> @users
12:15:21 <lambdabot> Maximum users seen in #haskell: 516, currently: 513 (99.4%), active: 14 (2.7%)
12:17:05 <jethr0> @faq can haskell channel still grow?
12:17:06 <lambdabot> The answer is: Yes! Haskell can do that.
12:25:23 <EvilTerran> FunctorSalad_, subconscious: monads have never been applicatives
12:25:37 <EvilTerran> or rather, Monads have never been Applicatives
12:25:56 <EvilTerran> most Monad instances also have an Applicative instance defined, but this isn't enforced
12:26:02 <EvilTerran> because Applicative came later
12:26:25 <Deewiant> there's a ticket for making them applicatives though: http://hackage.haskell.org/trac/ghc/ticket/2316
12:26:27 <lambdabot> Title: #2316 (Add Applicative instances for all MTL Monads) - GHC - Trac
12:27:19 <geezusfreeek> would be nice to add the Applicative constraint to Monad
12:27:39 <geezusfreeek> in fact, i would be happier even with just adding a Functor constraint
12:28:15 <geezusfreeek> silly backward compatibility ;)
12:29:56 <ddarius> Adding the Functor constraint to Monad would actually not be that bad compatibility-wise.
12:30:15 <geezusfreeek> not as bad as Applicative, but it would still throw some stuff off
12:30:24 <Deewiant> instance Functor f where map :: (a -> b) -> f a -> f b.
12:30:28 <Deewiant> er
12:30:30 <Deewiant> class
12:30:39 <ddarius> Only applications that have Monads without Functor instances.
12:30:50 <ddarius> For libraries the user could supply any missing Functor instance.
12:31:06 <geezusfreeek> i hate orphans
12:40:01 <subconscious> would be cool to have someone to hack on this code with me :/
12:40:27 <subconscious> o rjust not haveing to write a parser
12:40:45 <inimino> what an un-geezusy sentiment
12:41:51 <inimino> subconscious: what's bad about writing parsers?
12:42:28 <subconscious> I just don't want to do it
12:42:42 <inimino> fair enough ;-)
12:42:56 <chr1s> parsers are lots of fun!
12:43:17 <subconscious> actually the most irritating thing is I don't know how to relate the parser and pretty printer
12:43:35 <chr1s> yeah, that's not entirely straightforward.
12:43:57 <chr1s> it'd be nice to generate both of them from the same source.
12:43:59 <inimino> so you anticipate writing both of them from scratch
12:44:22 <subconscious> I don't know any way to derive them both from one specification
12:44:32 <subconscious> I've seen a derivation of a parser from a pretty printer though
12:44:39 <subconscious> It's a lot of work ...
12:44:45 <sclv> see pickler combinators? but those are ugly.
12:45:09 <inimino> unless your language is horrifically complicated it's likely to be less work to just write both
12:45:16 <inimino> and even then...
12:45:17 <sclv> you can use them properly for, e.g., xml though.
12:45:25 <sclv> or a similarly constrained domain.
12:45:46 <subconscious> I just want to have infix operators, names and a couple binders (like lambda)
12:46:09 <subconscious> I can write pp as a fold .. but I can't invert that fold
12:46:17 <inimino> so your parser is going to be like 12 lines, just write it already ;-)
12:48:35 <subconscious> these pickler combinators are cool
12:50:05 <subconscious> there isn't any plaintext version of the code is there?
12:50:16 <sclv> theres also some parser generator out there somewhere that generates the code from a single description for the ast, the parser, and the pretty printer. it targets at least three language backends including haskell, and is mainly for teaching rather than production quality, I think? I can't for the life of me remember the name though.
12:51:23 <inimino> ugh, justified text
12:56:25 <subconscious> oh and ghci doesn't support unicode now :/
12:56:31 <ulfdoz> @src (++)
12:56:32 <lambdabot> []     ++ ys = ys
12:56:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:56:32 <lambdabot> -- OR
12:56:32 <lambdabot> xs ++ ys = foldr (:) ys xs
12:58:15 <hackage> Uploaded to hackage: storablevector 0.2
12:58:15 <hackage> Uploaded to hackage: midi 0.1.2
12:58:15 <hackage> Uploaded to hackage: haskore 0.0.5
12:59:36 <EvilTerran> subconscious, i'm pretty sure it does
12:59:37 <ulfdoz> Why does this neither consume cpu-time nor memory? let myRepeat x = xs where xs = xs ++ [x]
13:00:03 <subconscious> ulfdoz: what?
13:00:03 <EvilTerran> subconscious, but you need to configure your terminal and ghci and so on to work right
13:00:37 <EvilTerran> ulfdoz, it won't when you define it because it's not evaluated 'til you use it
13:00:50 <ulfdoz> subconscious: My ghci eats this fine. "take 10 $ myRepeat 0" causes neither load nor memory consumption. Obviously the definition is free of sense.
13:00:50 <EvilTerran> > let myRepeat x = xs where xs = xs ++ [x] in myRepeat 'a'
13:01:05 <lambdabot>   thread killed
13:01:16 <subconscious> ulfdoz: And does it give the right result?
13:01:17 <EvilTerran> ulfdoz, actually, now i look at it, that shouldn't work at all
13:01:34 <olsner> that should just loop
13:01:53 <EvilTerran> in order to get the first item of the list, it has to go through every recursive call to myRepeat, and there's an unlimited number of them
13:01:54 <ulfdoz> subconscious: It does not give a result. Intentionally, but it also doesn't harm, except that it does not terminate.
13:02:29 <subconscious> ulfdoz: So it's just made a little bend in the program, circled back on itsself, and the evaluator is running around in circluse
13:03:24 <ulfdoz> subconscious: If it would do anything, I 'd see it. But the ghci process idles fine.
13:04:01 <olsner> it actually does that for me too, idles rather than using any cpu
13:05:24 <subconscious> ulfdoz: Are you sure you are talking about that code you pasted?
13:05:31 <ulfdoz> subconscious: Yes.
13:05:37 <kosmikus> well, this is a case where it should actually be able to detect it's in an infinite loop
13:05:39 <subconscious> it should use up lots of heap space
13:05:47 <kosmikus> I think that if you compile it, it will actually throw an exception
13:05:55 <ulfdoz> I understand, that it runs in constant memory, because xs and [x] are constant functions.
13:06:05 <subconscious> xs and [x] aren't functions
13:06:06 <subconscious> @let myRepeat x = xs where xs = xs ++ [x]
13:06:07 <lambdabot>  Defined.
13:06:14 <subconscious> > myRepeat 0
13:06:30 <lambdabot>   thread killed
13:12:11 <ulfdoz> If I compile it, I get stack overflow.
13:12:51 <subconscious> the stack like:  todo: (++ [x]), (++ [x]), (++ [x]), ....
13:16:15 <ulfdoz> with main = putChar (last $ myRepeat '0') some loop-detection terminates the process.
13:20:56 <EvilTerran> does it matter which of these happens?
13:21:07 <EvilTerran> it's an implementation detail, they're all _|_
13:22:53 <CaBa> hei guys...
13:23:00 <ulfdoz> In real world not really. I'm just looking for an illustrative example to show the difference between cyclic and non-cyclic datastructures.
13:23:11 <CaBa> ulfdoz: lol
13:23:45 <CaBa> ulfdoz: seems like we are a cyclic data structure...
13:24:34 <ulfdoz> CaBa: Or you're the tail behind me.
13:25:15 <CaBa> ulfdoz: doubtful - i'd rather run away from u
13:25:17 <EvilTerran> ulfdoz, would a comparison of "repeat x = xs where xs = x:xs" and "repeat2 x = x : repeat2 x" work?
13:29:02 <ulfdoz> EvilTerran: Probably the best example one can get.
13:30:12 <ddarius> ulfdoz: http://web.archive.org/web/20061011010615/http://www.haskell.org/hawiki/TyingTheKnot
13:30:14 <EvilTerran> note that the difference is still an implementation thing
13:30:24 <lambdabot> Title: TyingTheKnot - The Haskell Wiki, http://tinyurl.com/5uftfe
13:33:24 <ddarius> Incidentally, this paged rocked: http://web.archive.org/web/20061011032657/www.haskell.org/hawiki/CommonHaskellIdioms
13:33:26 <lambdabot> Title: CommonHaskellIdioms - The Haskell Wiki, http://tinyurl.com/4g3rtq
13:36:22 <FunctorSalad_> is choice of typeclass method resolved at compiletime?
13:37:21 <scodil> if known, yes.
13:37:58 <Deewiant> and if not, no. :-P
13:38:08 <ddarius> In Haskell 98 there is only one situation where some kind of run-time evidence is required.
13:41:20 <ulfdoz> ddarius: thx, that helps.
13:44:36 <scodil> oh man storablevector has a mutable interface now. vector, uvector and storablevector need to have a 3way cage match to see who gets to succeed h98 arrays
13:47:45 <ddarius> @hackage uvector
13:47:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uvector
13:48:19 <ddarius> scodil: None of them.
13:48:45 <agcorona> 500 users
13:49:11 <scodil> yeah right i didn't mean polymorphic h98 arrays. I meant UArray, IOUArray and STUArray.
13:49:48 <agcorona> why so many people interested in  this language?
13:49:55 <agcorona> I don´t understand
13:50:10 <subconscious> agcorona: It's a pretty cool language :)
13:50:26 <agcorona> sure?
13:50:57 <subconscious> agcorona: Do you do any programming?
13:51:15 <agcorona> yes.
13:51:32 <agcorona> c#, Javascript...
13:52:40 <ozy`> agcorona: you ever used lisp or ML?
13:52:59 <ozy`> (the latter including F#, I guess)
13:53:16 * subconscious wishes F# didn't exist :(
13:53:52 <scodil> subconscious: why the animosity?
13:54:02 <subconscious> what?
13:54:02 <subconscious> aoe
13:54:10 <ozy`> subconscious: I guess they could have made a bastardized Haskell instead?
13:54:17 <scodil> why do you wish F# didn't exist?
13:54:21 <subconscious> ozy`: I wouldn't like that either
13:54:30 <subconscious> scodil: Same reason I wish D didn't exist
13:54:47 <ozy`> now that's just baffling
13:54:56 <Deewiant> subconscious: so why do you wish D didn't exist
13:55:00 <scodil> is that reason, "Because they should have gotten right the first time?"
13:55:10 <shrughes> agcorona: my straight answer would be that typeclasses are better than interfaces or ad-hoc overloading, and that the syntax is marvelous
14:01:15 <ozy`> subconscious: I see you still haven't clarified your resentment of D...
14:02:37 <jberryman> if I have a type that is basically Maybe with differently-named constructors, is there a way to define it in terms of Maybe so that I don't have to define a Monad and functor instance, etc?
14:03:03 <Baughn> jberryman: You couldn't just use Maybe?
14:04:02 <EvilTerran> jberryman, "newtype Foo a = Foo (Maybe a) deriving (Monad,Functor,...)"
14:04:09 <EvilTerran> although that needs the NewtypeDeriving extension
14:04:11 <Baughn> jberryman: anyhow, see http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#newtype-deriving
14:04:13 <lambdabot> Title: 7.4.�Type system extensions, http://tinyurl.com/25mnwa
14:04:23 <EvilTerran> note the "..." is metasyntax
14:04:44 <yitz> or type MyMaybe = Maybe, really = Just, nope = Nothing
14:05:17 <jberryman> EvilTerran: matasyntax?
14:05:41 <EvilTerran> as in, not part of the syntax of the language i'm describing (extended haskell)
14:05:42 <jberryman> *meta
14:05:53 <EvilTerran> part of the language i am using to describe (ie english)
14:06:13 <sw17ch> Is there a way to pass file handles between haskell and C?
14:06:13 <sw17ch> the int type, not the FILE type
14:06:31 <Baughn> sw17ch: Those are file descriptors, not handles
14:06:50 <sw17ch> Baughn, which, the integer for the FILE
14:06:52 <sw17ch> :)
14:06:58 <Baughn> sw17ch: And sure, see System.Posix.Files
14:07:11 <jberryman> right, thanks for the suggestions all.
14:07:41 <sw17ch> Baughn: thanks, taht's the one i was looking for
14:07:52 <sw17ch> (System.IO wasn't quite doing waht I wanted. :) )
14:08:33 <subconscious> jberryman: I don't think it's possible to write something like instance Isomorphism (p x) (Maybe x) => Monad p where ...
14:10:39 <humasect> > let myNothing = Nothing; myJust x = Just x;
14:10:40 <sw17ch> Grr... I need to use ByteStrings, File Descriptors, and Sockets...
14:10:40 <lambdabot>   mueval: Prelude.read: no parse
14:11:03 <humasect> sw17ch: it can be done =)
14:11:29 <sw17ch> humasect, I suppose this would be much easier if there was a Fd -> Handle function out there...
14:11:41 * sw17ch can't find it on hoogle
14:12:12 <humasect> there is network-bytestring 1st
14:12:45 <sw17ch> i'm using network-bytestring already
14:12:46 <humasect> also, Network.* is Handle, and Network.Socket.* is Socket
14:12:50 <humasect> ok
14:13:07 <sw17ch> humasect: are you familiar with TUN/TAP?
14:13:29 <sclv> ?hoogle fdToHandle
14:13:30 <lambdabot> No results found
14:13:36 <sclv> ?go fdToHandle
14:13:38 <lambdabot> No Result Found.
14:13:52 <humasect> hm somewhat, sw17ch
14:14:00 <sw17ch> humasect: i'm reproducing their bridge example
14:14:06 <sw17ch> tie two TAP devices together
14:14:10 <sjanssen> sclv: there's a function somewhere
14:14:26 <sclv> yeah -- its in GHC.Internal or such I think.
14:14:38 <sclv> GHC.Handle
14:14:47 <humasect> ah, i see sw17ch
14:16:42 <sw17ch> so, since i'm trying to do this fast... i'm going to let C open and prepare the TAP for me, and then pass the Fd to Haskell
14:17:05 <humasect> System.Posix.Types Fd :: CInt -> Fd ... then ... socketToHandle :: Socket (CInt,_,_,_,_) -> IOMode -> IO Handle ?
14:17:07 <sw17ch> unless the ifreq structure and ioctl have a good interface already
14:17:43 <humasect> go faster!
14:18:38 <sw17ch> hmm... socketToHandle...
14:18:57 <b\6> nice way to split interval into subintervals of size n or less like split 1 10 3 -> [(1,3),(4,6),(7,9),(10,10)]?
14:21:22 <humasect> > ([1,10,3])...
14:21:23 <lambdabot>   mueval: Prelude.read: no parse
14:21:29 <humasect> ch
14:21:38 <Baughn> b\6: splitAt' n xs = genericTake n xs : splitAt' n (genericDrop n xs)
14:21:46 <sjanssen> > (\n x y -> unfoldr (\i -> if i > n then Nothing else let i' = min y (i + n) in Just ((i, i'), i')) x) 3 1 10
14:21:48 <lambdabot>   [(1,4)]
14:22:05 <sw17ch> humasect: h <- fdToHandle' (fromIntegral fd) (Just System.Posix.Internals.Stream) True (show s) mode True
14:22:06 <sw17ch> :(
14:22:08 <b\6> thanks, looking.
14:22:15 <sw17ch> that's how socketToHandle does it
14:22:21 <Baughn> b\6: Although, that could be made more efficient by using splitAt. for some reason I didn't.
14:22:39 <humasect> sw17ch: ah.. where is fdToHandle' now
14:22:43 <EvilTerran> > (\lo hi step -> map (take step) . takeWhile (not.null) . iterate (drop step) $ [lo..hi]) 1 10 3
14:22:44 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
14:22:55 <sjanssen> > (\n x y -> unfoldr (\i -> if i > y then Nothing else let i' = min y (i + n - 1) in Just ((i, i'), i')) x) 3 1 10
14:22:56 <lambdabot>   [(1,3),(3,5),(5,7),(7,9),(9,10),(10,10),(10,10),(10,10),(10,10),(10,10),(10...
14:23:04 <sjanssen> hmpfh
14:23:07 <sw17ch> hah
14:23:11 <Beelsebob> close
14:23:13 <Beelsebob> but no cigar
14:23:18 <sw17ch> System.Posix.IO.fdToHandle
14:23:21 <sw17ch> duh
14:23:23 <sw17ch> :P
14:23:27 <humasect> oh. =)
14:23:42 <EvilTerran> > (\lo hi step -> [(i, iterate succ i !! (step-1)) | i <- [lo, iterate succ lo !! step .. hi]]) 1 10 3
14:23:43 <lambdabot>   [(1,3),(4,6),(7,9),(10,12)]
14:23:44 <sjanssen> > (\n x y -> unfoldr (\i -> if i > y then Nothing else let i' = min y (i + n - 1) in Just ((i, i'), i' + 1)) x) 3 1 10
14:23:45 <lambdabot>   [(1,3),(4,6),(7,9),(10,10)]
14:24:06 <sjanssen> there we go :)
14:24:26 <EvilTerran> > (\lo hi step -> [(i, prev j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. hi]]) 1 10 3
14:24:27 <b\6> thanks.
14:24:27 <lambdabot>   mueval: Prelude.read: no parse
14:24:48 <EvilTerran> hm
14:26:04 <BMeph> Evil: s/prev/pred/ maybe? ;)
14:26:31 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. hi]]) 1 10 3
14:26:32 <lambdabot>   [(1,3),(4,6),(7,9)]
14:26:45 <EvilTerran> yeah, that's the one
14:26:53 <EvilTerran> loses the last item, though
14:27:21 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. h+1i]]) 1 10 3
14:27:22 <lambdabot>       No instance for (Num (Expr -> a))
14:27:22 <lambdabot>        arising from the literal `1' a...
14:27:33 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. hi+1]]) 1 10 3
14:27:34 <lambdabot>   [(1,3),(4,6),(7,9)]
14:28:40 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. hi+step]]) 1 10 3
14:28:42 <lambdabot>   [(1,3),(4,6),(7,9),(10,12)]
14:28:51 * BMeph sighs
14:29:08 <humasect> :t (<*>)
14:29:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:29:51 <EvilTerran> > (\lo hi step -> [(i,j-1) | (i,j) <- (zip <*> (tail . (++[hi]))) . takeWhile (<hi) . iterate (+step) $ lo]) 1 10 3
14:29:52 <lambdabot>   [(1,3),(4,6),(7,9)]
14:30:03 <EvilTerran> > (\lo hi step -> [(i,j-1) | (i,j) <- (zip <*> (tail . (++[hi+1]))) . takeWhile (<hi) . iterate (+step) $ lo]) 1 10 3
14:30:04 <lambdabot>   [(1,3),(4,6),(7,10)]
14:30:12 <EvilTerran> ah, nvm
14:31:13 <b\6> thanks for working on it.
14:31:18 <b\6> at least it wasn't too easy.
14:31:48 <humasect> is one single view pattern designed to cause pattern overlap
14:33:12 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) [lo, iterate succ lo !! step .. hi]++[hi]]) 1 10 3
14:33:13 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
14:33:13 <lambdabot>        Exp...
14:35:31 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) ([lo, iterate succ lo !! step .. hi]++[hi+1])]) 1 10 3
14:35:32 <lambdabot>   [(1,3),(4,6),(7,9),(10,10)]
14:36:05 <BMeph> Clunky as all get-out, but it... hmm, let's get the border case a try. :|
14:36:12 <BMeph> > (\lo hi step -> [(i, pred j) | (i,j) <- (zip <*> tail) ([lo, iterate succ lo !! step .. hi]++[hi+1])]) 1 12 3
14:36:21 <lambdabot>   [(1,3),(4,6),(7,9),(10,12)]
14:36:33 * BMeph does a happy dance!
14:43:01 <_ar_> is there a concise way to repeat a monadic expression n times and sequence the results?
14:43:24 <ziman> :t replicateM
14:43:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:43:44 <ziman> (or replicateM_)
14:43:49 <_ar_> ziman: thank you. i suspected this had to be a common problem
14:44:15 <ziman> @src replicateM
14:44:16 <lambdabot> replicateM n x = sequence (replicate n x)
14:44:28 <BMeph> _ar_: What others see as problems, Haskell (and its programmers) see as opportunity! ;)
14:46:51 <_ar_> haha BMeph. it's good you guys are here, or i'd always be reinventing all of this boiler plate
14:46:59 <_ar_> i mean opportunity
14:47:15 <Cale> _ar_: Have a look through the stuff in Control.Monad
14:47:15 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:47:31 <_ar_> Cale: should i just browse the source? or is there some kind of guide
14:47:46 <_ar_> i'm really not sure what resources i should look to first when i have questions
14:47:48 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
14:47:50 <_ar_> is there a standard place to go?
14:47:50 <lambdabot> Title: Control.Monad, http://tinyurl.com/ykyqfl
14:47:56 <b\6> you can use hoogle to search by signature.
14:48:06 <sw17ch> my FFI-Foo is becoming stronger...
14:48:07 <sw17ch> :D
14:48:25 <_ar_> thank you Cale
14:50:13 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- you should definitely know about this index
14:50:14 <lambdabot> Title: Haskell Hierarchical Libraries
14:50:32 <Cale> It documents all the libraries that come with GHC by default.
14:50:50 <humasect> sw17ch=)
14:58:15 <hackage> Uploaded to hackage: haskeline 0.3.2
15:19:44 <keseldude> Cale: do you mind if I PM you? :)
15:19:58 <Cale> I don't mind
15:20:14 <ac> anybody have or know of some example code that uses the OpenGL frame buffer extension?
15:21:26 <ac> the Haskell interface seems simpler than the one defined by the OpenGL spec. How do you bind the frame buffer to a texture for example?
15:25:07 <ziman> i'm trying to `visualize' functions by giving an example of how they work: http://hpaste.org/10747 However, I get those errors and I can't figure out what's wrong (what's a1, b1?). Any ideas?
15:25:15 <FunctorSalad_> if I do createNamedPipe, open it with withFile and then hGetChar, I get EOF... how can I listen for input instead?
15:26:40 <Cale> ziman: when you write  x :: a  you're actually writing  x :: forall a. a
15:27:11 <Cale> ziman: That is, your type variable doesn't refer to the variable in the instance head (which is a bit unfortunate)
15:27:42 <ziman> oh :\
15:28:09 <ziman> i added the :: a because I thought it would fix another error
15:28:24 <arjanb> ziman: sometimes it help to remove type annotation to get better errors
15:28:29 <Cale> Right, the fact that it's ambiguous, most likely.
15:29:22 <jethr0> so now we have two advices: 1. sometimes add type annotations to improve errors, 2. other times remove type annotations to improve errors. sounds good to me ;)
15:29:33 <Cale> hmm, I wonder if you can stick a forall in there and make it work.
15:29:42 <jeffz> ac, I think I remember seeing some on one of the haskell mailing lists, can't remember which one though or when.
15:29:58 <ziman> http://hpaste.org/10747#a1 <-- this is what i was getting before i added the annotations
15:30:11 <Cale> Yes, indeed you can.
15:30:29 <Cale> http://hpaste.org/10747#a2
15:31:20 <newsham> otherwise the top "a" isnt scoped to the enclosed "repr :: a"
15:31:31 <newsham> and they are different a's
15:31:43 <Cale> *Main> (+) :: Int -> Int -> Int
15:31:43 <Cale> (fun 3 = (fun 3 = 6))
15:32:00 <Cale> (Kind of a strange notation, but the code works, anyway :)
15:32:08 <FunctorSalad_> here's my little pipe problem http://hpaste.org/10748
15:33:15 <Cale> FunctorSalad_: well, the pipe will be empty.
15:33:21 <ziman> thanks Cale :)
15:33:37 <newsham> but shouldnt the read block until someone opens the file?
15:33:45 <FunctorSalad_> Cale: sure but I'd like it to remain open and wait for someone to write to it
15:33:57 <FunctorSalad_> newsham: yes, hGetChar is supposed to block
15:34:02 <Cale> newsham: That is a good point. I wonder why it's nonblocking.
15:34:05 <ziman> is the forall the only way to bind the type variables in the instance head to the type variables in the annonations within the instance definition?
15:34:26 <newsham> ie:  mkfifo /tmp/in; cat /tmp/in & (sleep 5; echo hi > /tmp/in)
15:34:33 <newsham> the cat blocks until the echo happens
15:34:53 <Cale> ziman: Yes, though there might be other clever things you can try to do.
15:34:53 <newsham> is createNamedPipe doing a mkfifo?
15:34:54 <FunctorSalad_> Computation hGetChar hdl reads a character from the file or channel managed by hdl, blocking until a character is available. This operation may fail with: * isEOFError if the end of file has been reached.
15:35:18 <FunctorSalad_> newsham: createNamedPipe even says that it calls mkfifo
15:35:31 <newsham> functor: use strace/truss?
15:36:35 <newsham> see whats going on under the hood
15:36:43 <geezusfreeek> woah i missed that quickcheck 2 is on hackage now
15:37:03 <geezusfreeek> and just when i was about to try smallcheck
15:37:17 <Cale> FunctorSalad_: Can you give me your import list, just so I don't have to find out what modules things are in? :)
15:38:43 <Cale> hmm, System.IO, System.Posix and HSH?
15:39:29 <FunctorSalad_> newsham Cale: hehe, compiled it to run strace and compiling solved it
15:39:49 <FunctorSalad_> so ghci was the problem
15:39:49 <Cale> Oh, so maybe it was an interaction with GHCi.
15:39:52 <Cale> yeah
15:40:22 <FunctorSalad_> Cale: yes exactly these
15:40:47 <newsham>  71806 pipe     CALL  open(0x800d7e028,O_NONBLOCK|O_NOCTTY,<unused>0x1b6)
15:40:47 <newsham>  71806 pipe     NAMI  "./in"
15:40:57 <newsham>  71806 pipe     CALL  read(0x3,0x800d7e0c8,0x400)
15:40:57 <newsham>  71806 pipe     GIO   fd 3 read 0 bytes
15:40:57 <Cale> It might be that GHCi does something funky like put handles into nonblocking mode? Yeah...
15:42:11 <ac> jeffz: hm, did some more googling, can't find anything
15:42:15 <newsham> I think its supposed to block at open waiting for a connect
15:42:22 <newsham> and its being opened in non-blocking
15:42:33 <newsham> so it doesnt block there, so it gets an unconnected pipe (EOF)
15:42:49 <jeffz> ac, I probably read it through the http://news.gmane.org interface
15:42:53 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:43:33 <newsham> yah, when i open it in another language, it hangs at open until it becomes connected
15:44:28 <newsham> when I open in ghci the open returns immediately
15:44:43 <newsham> if I wait until someone sends data before I do hGetChar, then hGetChar succeeds
15:44:48 <newsham> but otherwise I get eof
15:45:03 <Cale> So, to avoid that, I suppose you could whip up your own openFile which uses openFd with appropriate flags.
15:45:12 <newsham> and it seems i can keep reading it after EOF and get more chars if more are sent
15:45:17 <jeffz> ac, hmm, a quick search shows that I may have been smoking crack.  could have sworn I saw someone ask about it before and they were answered
15:45:21 <newsham> or you can use select to wait for input
15:45:41 <newsham> there's a module which exposes select, no?
15:45:41 <FunctorSalad_> hmm I don't really need to run it in ghci :)
15:45:42 <jeffz> ac, I've only started poking around in HOpenGL myself, so I'm not too wise on the matter
15:48:07 <newsham> you could also keep polling the fd with hGetChar until you get one ;-)
15:48:29 <FunctorSalad_> and catch the exceptions?
15:48:40 <newsham> yah you'd have to catch it to ignore the eof
15:48:57 <newsham> i wouldnt recommend polling for anything other than a brute force hack
15:49:10 <FunctorSalad_> yeah
15:49:32 <newsham> When I open a FIFO (named pipe) and try to read from it, I get EOF immediately.
15:49:33 <newsham> This is a consequence of the fact that GHC opens the FIFO in non-blocking mode. The behaviour varies from OS to OS: on Linux and Solaris you can wait for a writer by doing an explicit threadWaitRead on the file descriptor (gotten from Posix.handleToFd) before the first read, but this doesn't work on FreeBSD (although rumour has it that recent versions of FreeBSD changed the behavour to match other OSs). A workaround for all systems is to open the FIFO for wri
15:50:03 <newsham> http://people.reed.edu/~carlislp/ghc6-doc/users_guide/faq.html
15:50:04 <lambdabot> Title: GHC FAQ
15:50:29 <newsham> treadWaitRead sounds reasonable
15:50:40 <allbery_b> short summary:  FIFOs are weird
15:51:06 <FunctorSalad_> hmm *ghc* seems to work fine, just ghci does that
15:51:20 <FunctorSalad_> (the faq says ghc)
15:51:37 <newsham> for me in ghc it is non-blocking at open
15:51:40 <newsham> err in ghci
15:51:42 <allbery_b> ghc wiuth or without -threaded?
15:51:48 <newsham> (w/o threaded)
15:51:48 <allbery_b> (ghci is always threaded)
15:52:31 <FunctorSalad_> allbery_b: without (assuming that's my default)
15:52:50 <allbery_b> that's eefault, yes.  I suspect if you use -threaded ghc will match ghci
15:53:20 <newsham> (who uses fifos?  :)
15:53:34 <FunctorSalad_> allbery_b: correct
15:53:41 <FunctorSalad_> (tried it)
15:55:57 <jpcooper> h
16:18:25 <badtruffle> how can I match even numbers in a where statement?
16:20:02 <Cale> badtruffle: er, in a function definition, you mean?
16:20:06 <badtruffle> yup
16:20:08 <badtruffle> sorry
16:20:12 <Cale> f n | even n = ...
16:20:18 <newsham> are you defining a function in a where clause that takes even numbers?
16:20:29 <Cale> f n | otherwise = ...
16:20:47 <Cale> (or you can leave out the second f n, since it's implied :)
16:20:50 <badtruffle> hmm
16:21:39 <badtruffle> cool, I'll try it
16:21:49 <badtruffle> thanks!
16:23:34 <newsham> conor mcbride does agda at the pub
16:26:40 <newsham> i wish there was a Real World Agda book
16:32:29 <Cale> newsham: :)
16:33:14 <Cale> What's with these people who ask questions on IRC and then leave immediately after? :)
16:33:37 <Cale> Don't they know that the only way to go is to have an IRC client running on your machine 24/7? :)
16:34:05 <ac> (in a screen session)
16:34:43 <Cale> I wish there was an equivalent of screen for X clients.
16:35:22 <ac> doesn't vnc more or less fit the bill?
16:35:50 <Cale> Well, I suppose if you need something like that, it's close enough.
16:36:15 <Cale> It would be nice though, given that X is already a network protocol, to be able to move X clients between servers.
16:36:46 <ac> how do video players work? CPUs simply aren't fast enough to write each pixel in each frame, and yet they do that and more considering they're decoding it at the same time
16:37:29 <mmorrow> @yow
16:37:29 <lambdabot> The FALAFEL SANDWICH lands on my HEAD and I become a VEGETARIAN ...
16:37:33 <ac> Cale: hm, that would be interesting
16:38:27 <ac> you could probably make a dummy x server that simply forwards everything to a specified "active" server
16:39:02 <ac> then you could restart X, and still have all your programs running
16:39:49 <mmorrow> i've tried to setup a dummy x server whose sole purpose is to be able to capture an image of the webpage at an arbitrary url. i wasn't successful, but only because i didn't try hard enough.
16:39:57 <ziman> well, not really, as the X server keeps pixmaps and stuff, doesn't it?
16:40:11 <mmorrow> (capture it via a screenshot of firefox/whatever)
16:40:25 <ziman> the client would have to resend the data
16:40:38 <tibbetts> Is there an alternative to HUnit which lets me specify tests with less verbosity/syntactic-redundancy? I feel like some kind of template haskell trickery could be helping me here.
16:40:54 <ac> ziman: you could probably make the dummy x server automatically send refresh requests to all the clients when you switched
16:41:00 <mmorrow> template-haskell trickery always is ftw :)
16:41:28 <dobblego> tibbetts, QuickCheck
16:41:52 <mmorrow> tibbetts: but i've never used HUnit, so i'm of no use.
16:42:11 <tibbetts> ac: Video players use special X interfaces (or sometimes hardware interfaces) to send lots of pixels to the display in a blit.
16:42:12 <roconnor> > 24*25.5
16:42:14 <lambdabot>   612.0
16:42:38 <mmorrow> , (0/0)/0
16:42:42 <lunabot>  NaN
16:42:43 <sjanssen> Cale: there is some work on this
16:42:51 <ac> tibbetts: but uncompressing it? Clearly it's an invalid assumption that it would take one operation per pixel to decode a video
16:42:58 <sjanssen> Cale: though it is not quite as simple as you might imagine
16:43:00 <mmorrow> , 0/(0/0)
16:43:01 <lunabot>  NaN
16:43:50 <yitz> lunabot: help
16:43:52 <ziman> > (`div` 10) . length $ liftM2 id (replicate 24 id) (replicate 255 id)
16:43:53 <lambdabot>   612
16:44:05 <mmorrow> lunabot knows only eval
16:44:13 <mmorrow> , 1
16:44:14 <lunabot>  1
16:44:15 <mmorrow> ] 2
16:44:16 <lunabot>  2
16:44:19 <eyu100> ] 2
16:44:20 <lunabot>  2
16:44:25 <eyu100> > []
16:44:26 <lambdabot>   []
16:44:37 <yitz> ] []
16:44:38 <lunabot>  []
16:44:38 <eyu100> > (>>=)
16:44:39 <lambdabot>       Overlapping instances for Show (m a -> (a -> m b) -> m b)
16:44:39 <lambdabot>        arisin...
16:44:43 <eyu100> > (show >>=)
16:44:44 <lambdabot>       Overlapping instances for Show ((String -> a -> b) -> a -> b)
16:44:44 <lambdabot>        ar...
16:44:46 <mmorrow> , $(tupE (mapM lift [0..9]))
16:44:47 <lunabot>      Couldn't match expected type `[b]'
16:44:52 <mmorrow> , $(tupE (mapM lift [0..9::Int]))
16:44:53 <lunabot>      Couldn't match expected type `[b]'
16:44:58 <mmorrow> , tupE
16:44:59 <lunabot>      No instance for (Show ([ExpQ] -> ExpQ))
16:45:08 <mmorrow> , $(tupE (fmap lift [0..9::Int]))
16:45:11 <lunabot>  (0,1,2,3,4,5,6,7,8,9)
16:46:06 <ac> , 1 + 1 -- what's with the ","?
16:46:07 <lunabot>   parse error (possibly incorrect indentation)
16:46:25 <mmorrow> also, it can't handle comments at eol due to a technicality
16:46:29 <tibbetts> ac: I'm not sure what you're getting at. Most operations in the codec will span multiple pixels, though the average is going to be more than one clock tick per pixel per frame. 30fps at 1600x1200 is only 57 million pixels a second though.
16:46:37 <mmorrow> (to be corrected ;))
16:47:01 <mmorrow> ac: that's lunabot's trigger-char
16:47:05 <ddarius> > 24*1600*1200*4
16:47:06 <mmorrow> (among others)
16:47:06 <lambdabot>   184320000
16:47:45 <tibbetts> dobblego: QuickCheck is interesting, but I don't think it helps me much when writing tests by hand.
16:47:55 <ac> ah right, I missed a few orders of magnitude
16:47:56 <mmorrow> ddarius: how's hsimagemagick coming ;)
16:48:17 <dobblego> tibbetts, it only does in that you no longer write tests by hand
16:48:54 <ddarius> mmorrow: I added a gtk2hs front end, but the thing is just a hack.
16:49:14 <ddarius> A pretty hack, but a hack.
16:49:14 <ddarius> A nice blending of computer graphics, image processing, and high dynamic range rendering though.
16:49:14 <mmorrow> ddarius: heh, rad! where?
16:49:36 <tibbetts> I don't really see how it could replace all hand coding of test cases, but that might be because I haven't drank the koolaid yte.
16:50:01 <dobblego> tibbetts, it is called "automated specification-based testing" because it is indeed automated
16:50:11 <ddarius> tibbetts: Unit tests are a special case of quickcheck tests.
16:50:19 <dobblego> @check \a b -> a + b == b + a -- would you rather write this?
16:50:20 <mmorrow> hack's are allowed when the alternative is nonexistence, i believe
16:50:20 <lambdabot>   "OK, passed 500 tests."
16:50:26 <mmorrow> s/'//
16:50:46 <bd_> @check \a b -> a + b == b + (a :: Float)
16:50:47 <lambdabot>   "OK, passed 500 tests."
16:50:58 <bd_> @check \a b -> a + b - b == (a :: Float)
16:50:59 <lambdabot>   "Falsifiable, after 11 tests:\n-3.6\n-5.0\n"
16:51:03 <ddarius> tibbetts: And there is still reason to have hand-crafted cases.  Certainly any failure cases the automated techniques find should be added as unit tests.
16:51:27 <tibbetts> Ah, good point, I can write some of my tests as QuickCheck tests without parameters. Though QuickCheck seems to have the same repeat-yourself nature as HUnit.
16:51:51 <sjanssen> tibbetts: what do you find yourself repeating?
16:52:00 <dobblego> tibbetts, if you are repeating yourself, please ask in here so we can whip you :)
16:52:34 <tibbetts> If I want to be able to test all the properties in a module, it seems like I have to put them in a list.
16:52:50 <tibbetts> Except I just ran into this "script" which may get around that.
16:52:54 <sjanssen> tibbetts: yes, this is true
16:53:08 <sjanssen> tibbetts: and yes, there are a few scripts that avoid that :)
16:53:44 <tibbetts> I'm allergic to tests systems which make it easy to lose track of a test and not run it, because I'm not OCD enough to avoid that mistake.
16:54:13 <mmorrow> tibbetts: you could sed/parse the src and extract the tests possibly (if they're named in an identifiable way)
16:54:19 <mmorrow> s/sed/grep/
16:54:35 <mmorrow> well, probably both ;)
16:54:56 <_ar_> is there documentation for hscurses?
16:54:59 <tibbetts> Sure, though parsing the source is gross. Non-Haskell languages mostly have introspection facilities to make this easy.
16:55:20 <mmorrow> tibbetts: compilers do it all the time :)
16:55:35 <tibbetts> Sorry. Parsing the source with sed is gross.
16:55:41 <mmorrow> very true
16:55:45 <mmorrow> use haskell-src-exts
16:56:01 <mmorrow> it's pretty good with 90% of code ghc would accept
16:56:07 <ddarius> mmorrow: Other than the hslToRgb code which is pretty much copied from the Wikipedia, there isn't really any library code their.  Everything is intentionally specialized to the problem.
16:56:13 <ddarius> You can also simply put your properties directly in a list to begin with.
16:56:17 <ddarius> But the script is the more idiomatic way.
16:56:37 <tibbetts> Oh, I failed to mention I'm lazy and don't actually want to yak shave in my test system much. I was just hoping to find out what my best existing option was. Sounds like QuickCheck is the fashion of the day.
16:57:16 <sjanssen> tibbetts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTF is probably what you want
16:57:17 <lambdabot> Title: HackageDB: HTF-0.1
16:57:23 <SamB_XP> doesn't the yak hair interfere with the electronics anyway?
16:57:33 <mmorrow> ddarius: we should remedy that. i've thought about doing something imagemagicky, but never got past the choice of representing the image data.
16:57:33 <SamB_XP> also, how do you fit a yak in your test system?
16:57:38 <_ar_> answering my own question: http://hackage.haskell.org/packages/archive/hscurses/1.3/doc/html/UI-HSCurses-Curses.html
16:57:40 <lambdabot> Title: UI.HSCurses.Curses, http://tinyurl.com/3s7n75
16:58:07 <tibbetts> "The HTF uses Template Haskell to collect all tests and properties, so you do not need to write boilerplate code for that purpose." score.
16:58:07 <mmorrow> ddarius: it'd be sweet to do it with a Ptr Word8, then generate asm with harpy ;)
16:58:15 <hackage> Uploaded to hackage: happs-tutorial 0.4.1
16:58:15 <hackage> Uploaded to hackage: happs-tutorial 0.4
16:58:42 <tibbetts> yaks exist in most test systems, it's a common problem.
17:00:08 <ddarius> mmorrow: What I may do and have wanted to do is make a color package that has all these conversion functions in them as well as the operations you typically want (adding, scaling, clamping, etc.)
17:00:35 <mmorrow> ddarius: that'd be very handy and definitely a step in the direction.
17:03:37 <ac> so I want to generate a lot of very poor random numbers as quickly as possible, and get the seed afterwords
17:03:51 <ac> here's what I have so far: http://hpaste.org/10749
17:04:09 <ac> is there a better/faster way?
17:06:33 <mmorrow> ac: the mersenne-random package is /way/ faster that System.Random i've found
17:06:55 <ddarius> ac: Use the mersenne library?  That doesn't meet the requirement of poor though.
17:07:18 <Ikkebr> where can I find some good content about haskell i/o ?
17:08:20 <ddarius> @where rwh
17:08:20 <mmorrow> ddarius: heh, that is true
17:08:20 <lambdabot> http://book.realworldhaskell.org/read/
17:08:29 * mmorrow just hit quit by accident
17:08:42 * mmorrow is slightly liquored up
17:09:08 <byorgey> Ikkebr: check out that link above ^^^
17:10:30 <Ikkebr> ok thanks :p
17:12:01 <byorgey> Ikkebr: why the :p ?
17:13:48 <mmorrow> Ikkebr: what're you looking for?
17:14:26 <mmorrow> Ikkebr: (seriously)
17:14:39 <Ikkebr> i have some haskell homework
17:14:45 <Ikkebr> but i'm a little stuck
17:14:53 <mmorrow> on what?
17:15:39 <Ikkebr> i need to write a function that reads integer numbers from the keyboard until I get a 0, and when that happens I must show all numbers that were previously entered
17:16:08 <bd_> what have you tried so far?
17:16:35 <byorgey> Ikkebr: a good place to start is with the type of the function.
17:17:24 <Ikkebr> i was thinking about having a list of the values and appending the values i read to this list
17:17:36 <Ikkebr> and when I get a 0 I just print the list
17:18:03 <bd_> sounds like a good start
17:18:32 <mmorrow> that's a good start. an explicitly recursive function with an accumulator...
17:19:37 <Ikkebr> that's where I get stuck :p
17:19:42 <Ikkebr> I'm not sure how to do it
17:19:50 <Ikkebr> how to implement it actually
17:20:02 <mmorrow> here's a similar function without io, but taking a list
17:20:20 <mmorrow> , let go n acc [] = reverse acc ; go n acc (x:xs) = if n==x then reverse (x:acc) else go n (x:axx) xs in go 20 [] [0..]
17:20:21 <lunabot>   Not in scope: `axx'
17:20:26 <mmorrow> , let go n acc [] = reverse acc ; go n acc (x:xs) = if n==x then reverse (x:acc) else go n (x:acc) xs in go 20 [] [0..]
17:20:27 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
17:20:39 <mmorrow> that's pretty much boilerplate
17:20:42 <bd_> mmorrow: I don't think that'll be exactly the same; he needs to read the list in before he does anything with it
17:20:46 <_ar_> is there a sleep function somewhere?
17:20:57 <Pseudonym> @hoogle sleep
17:20:58 <lambdabot> No results found
17:20:58 <bd_> and then there's no need to explicitly recurse to print it - mapM_ and friends can help
17:21:03 <bd_> @hoogle threadDelay
17:21:04 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
17:21:04 <Pseudonym> @index sleep
17:21:04 <lambdabot> System.Posix.Unistd, System.Posix
17:21:07 <Pseudonym> RIght.
17:21:11 <mmorrow> but imagine at each step, he's reading a line, rather than pattern matching on the list
17:21:16 <Pseudonym> Is that only on pthreads, though?
17:21:28 <Pseudonym> No, threadDelay is on everything.
17:21:33 <mmorrow> (well, reading a line, then doing read(s))
17:21:38 <bd_> I suppose
17:22:03 <mmorrow> that's the only explicitly recursive way i can think of doing it...
17:22:25 <mmorrow> (or using forever + callCC or throwDyn or something)
17:22:29 <_ar_> thank you Pseudonym , bd_
17:24:00 <sjanssen> there's a really simple solution with interact
17:24:39 <bd_> sjanssen: I don't think the homework assignment is looking for that :)
17:24:45 <bd_> it's probably looking for the explicitly recursive solution
17:24:56 <mmorrow> yeah, i dunno what he's allowed to use
17:26:18 <sjanssen> hmm, I suppose the simple interact solution isn't quite right -- since numbers should be printed only after 0 is encountered
17:27:01 <bd_> you could make it strict on the entire list
17:27:03 <mmorrow> is there a takeWhileM :: (a -> Bool) -> IO a -> IO [a] ?
17:27:27 <mmorrow> (or whatever one would call it)
17:27:55 <bd_> @hoogle takeWhileM
17:27:56 <lambdabot> No results found
17:28:17 <bd_> well in any case interact can do it, just use reverse . reverse to force it to build the entire list before doing anything
17:28:17 <sjanssen> bd_: right, just stick an rnf in
17:30:27 <mmorrow> , let takeWhileM p io = let go p acc io = do x <- io ; if p x then return (reverse (x:acc)) else go n (x:acc) io in go p [] io in takeWhileM (==0) (return 0)
17:30:28 <lunabot>   Not in scope: `n'
17:30:35 <mmorrow> , let takeWhileM p io = let go p acc io = do x <- io ; if p x then return (reverse (x:acc)) else go p (x:acc) io in go p [] io in takeWhileM (==0) (return 0)
17:30:36 <lunabot>      No instance for (Show (m [a]))
17:30:52 <mmorrow> , let takeWhileM p io = let go p acc io = do x <- io ; if p x then return (reverse (x:acc)) else go p (x:acc) io in go p [] io in takeWhileM (==0) (return 0 :: Maybe Int)
17:30:53 <lunabot>  Just [0]
17:32:26 <mmorrow> (i don't think that's straightforward enough to be "giving it away" (i hope))
17:32:52 <Ikkebr> lol :p
17:32:54 <Ikkebr> that's evil code
17:32:57 <mmorrow> heh
17:33:45 <mmorrow> probably would look a lot less evil nicely formatted...
17:35:05 <dobblego> @seen edwardk
17:35:06 <lambdabot> I saw edwardk leaving #haskell-blah 6h 58m 54s ago, and .
17:35:21 <ac> ddarius, mmorrow: yeah, the mersenne library is a _lot_ faster
17:36:15 <mmorrow> ac: way. :)
17:37:56 <mmorrow> Ikkebr: that should probably be called "untilM" or something i guess
17:38:05 <Ikkebr> thanks for your effort :p
17:38:33 <Ikkebr> but i don't think i have enough haskell skill to understand that :p
17:41:23 <Ikkebr> but now I believe i'm not stuck anymore :p
17:41:25 <Ikkebr> so thanks
17:42:22 <mmorrow> :)
17:42:49 <dobblego> class T m where plus' m a -> m a -> m a; pure' :: a -> m a -- what is the name of this thing?
17:43:40 <sciolizer> MonadPlus?
17:44:04 <mmorrow> Monadoid without identity?
17:44:07 <dobblego> it's more general
17:44:15 <dobblego> Semigroupoid?
17:44:15 <ozy`> hey, are lists (and by extension, strings) actually implemented as linked lists everywhere?
17:44:41 <dobblego> ozy`, yes, data [] a = [] | a : [] a
17:44:47 <ozy`> or is there some degree of optimization with arrays under the hood?
17:44:56 <dobblego> arrays are not an optimisation
17:45:03 <ozy`> dobblego: well yeah, I know the exposed interface is that of a linked list...
17:45:21 <ozy`> not even for strings?
17:45:28 <dobblego> not ever
17:45:29 <mmorrow> sometimes the list gets optimized away, but never implemented as an array
17:45:35 <sciolizer> If you want efficient strings, use ByteStrings.
17:45:37 <sciolizer> At least in GHC.
17:46:17 <sciolizer> And Hugs, I guess.
17:47:02 <ozy`> (s/array/vector/ in everything I said above, if it's more appropriate)
17:47:35 <dobblego> ozy`, lists can perform better than arrays in many common scenarios
17:47:40 <Ikkebr> mmorrow
17:47:41 <Ikkebr> readintlist :: [Int]->IO()
17:47:41 <Ikkebr> readintlist x = do
17:47:41 <Ikkebr> 		newvalue <- readLn
17:47:41 <Ikkebr> 		if (newvalue == 0)
17:47:41 <Ikkebr> 			then putStr (printlist (reverse x) ++ "\n")
17:47:43 <Ikkebr> 			else readintlist (newvalue:x)
17:47:48 <Ikkebr> that did the trick for me :p
17:48:03 <ozy`> dobblego: I'm well aware of that
17:48:26 <dobblego> ozy`, then "optimising to an array" is a misnomer
17:50:35 <EnderMB> Hey all. Can anyone recommend a good IDE/Text Editor for use with loads of different languages (C, Haskell, Perl, Prolog, Java and C# mainly)
17:50:36 <ozy`> dobblego: tell me this, then. does ghc (for example) try at all to allocate list elements within the same cache line?
17:50:41 <bjrn> I'm packaging a package. cabal sdist adds everything, except my README. What's the proper way to add this file to the tar?
17:50:51 <Ikkebr> EnderMB notepad++
17:50:53 <bjrn> packaging a program even :)
17:51:04 <ddarius> ozy`: No.
17:51:39 <SamB_XP> @karma notepad
17:51:39 <lambdabot> notepad has a karma of 3
17:51:44 <SamB_XP> hehe
17:51:48 <ddarius> However, if they are allocated sequentially then they will be contiguous in memory unless a GC occurs in between
17:51:48 <SamB_XP> only 3?
17:51:52 <SamB_XP> @karma SamB
17:51:52 <ddarius> @karma vim
17:51:52 <lambdabot> vim has a karma of 0
17:51:52 <lambdabot> SamB has a karma of 0
17:51:56 <SamB_XP> @karma SamB_XP
17:51:57 <lambdabot> You have a karma of 0
17:52:05 <SamB_XP> is there a vim++ too ?
17:52:07 <bjrn> @karma chameleon
17:52:07 <lambdabot> chameleon has a karma of 0
17:52:19 <mmorrow> Ikkebr: awesome
17:52:21 <ozy`> ddarius: okay, that works for me
17:52:28 <EnderMB> Ikkebr: Is it possible to put some sort of shortcut to automatically run/compile a program in Notepad++, regardless of language?
17:52:41 <EnderMB> I'm not going to pretend to know what I'm talking about
17:52:44 * EnderMB is a student
17:53:17 <SamB_XP> Cale: WHAT have you done with the KARMA ?
17:53:21 <mmorrow> vim++
17:53:23 <mmorrow> vim++
17:53:24 <mmorrow> vim++
17:53:27 <mmorrow> @karma vim
17:53:28 <lambdabot> vim has a karma of 4
17:53:29 <Cale> SamB_XP: hm?
17:53:37 <Cale> SamB_XP: I don't know.
17:53:57 <Cale> SamB_XP: Lambdabot seems to randomly lose state sometimes. I'm not sure why it happens.
17:54:04 <mmorrow> bjrn: lol
17:54:25 <sciolizer> It seeks purity.
17:55:05 <SamB_XP> Cale: hmm, perhaps it's gwern's fault?
17:55:12 <Ikkebr> EnderMB not sure :|
17:55:15 <SamB_XP> @ask gwern what have you done with the KARMA?
17:55:15 <lambdabot> Consider it noted.
17:56:22 <EnderMB> At the moment I'm running Dev-C++, NetBeans, GNU Prolog and loads of other things to write my programs, but I'd like to condense it into just one program that'll run my programs regardless of what I'm using.
17:58:15 <hackage> Uploaded to hackage: happs-tutorial 0.4.2
17:58:30 <EnderMB> My university believes that Programming = Java/NetBeans, so when I attempt to try something different I just get blank stares from lecturers
18:00:03 <Elly> owned :P
18:00:22 <Elly> EnderMB: use vim and write a keybinding for it
18:00:59 * ddarius wonders where all the emacs people are.
18:01:01 <EnderMB> I've tried both Emacs and Vim but both scare the crap out of me
18:01:28 <EnderMB> To be honest I think I'm just going to ditch the IDE's altogether, commit to Vim/Emacs and code through the tears
18:01:55 <ddarius> EnderMB: There are a whole lot of choices here.  There are tons of programmable editors.  Pick one that you like.
18:02:39 <jeffz> Emacs scared me once upon a time, now it's like a third arm.
18:03:37 <Saizan> bjrn: extra-source-files: README
18:04:00 <bjrn> Saizan: That preferred to data-files?
18:04:04 <Saizan> bjrn: http://www.haskell.org/cabal/release/latest/doc/users-guide/authors.html#general-fields
18:04:07 <lambdabot> Title: Creating a package, http://tinyurl.com/5bk455
18:04:33 <EnderMB> To be honest I think it's more a lack of experience over anything else
18:04:36 <Saizan> bjrn: data-files is for files needed at runtime by the program, it seems
18:04:55 <bjrn> Saizan: Ah cheers mate, will use extra-source-files
18:08:05 <ozy`> jeffz: that analogy is perfectly appropriate
18:09:30 <ozy`> learning vim is like becoming a martial artist... learning emacs is like becoming Zaphod Beeblebrox
18:09:56 <bjrn> jeffz: The doctors gave you an extra arm to treat the arthritis? *ducks*
18:21:17 <dobblego> class T m where mzero' :: m a; mappend' :: m a -> m a -> m a -- is this in the standard libs without the need for bind/unit?
18:21:30 <ddarius> @src MonadPlus
18:21:30 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:21:41 <dobblego> MonadPlus requires >>=/return
18:22:21 <dolio> Monoid.
18:22:33 <dobblego> the forall a. is in the wrong position
18:23:23 <dolio> instance Monoid (m a) where mempty :: m a ; mappend :: m a -> m a -> m a
18:23:31 <dolio> For whatever your m is.
18:23:47 <Axman6> MonadPlus requires mplus doesn't it?
18:26:33 <ddarius> Possibly Applicative would be appropriate?
18:27:00 <dobblego> I've managed it with Monoid, thanks
18:33:53 <Ikkebr> how do I convert an input line that has n numbers into a list?
18:34:52 <shrughes> > words "hello whatever blah hey sup"
18:34:54 <lambdabot>   ["hello","whatever","blah","hey","sup"]
18:35:10 <Ikkebr> thanks shrughes
18:35:53 <Ikkebr> but how do I cast "7" into 7 ?
18:36:15 <shrughes> > read "7" :: Integer
18:36:17 <lambdabot>   7
18:36:38 <shrughes> The type you're converting it to is probably implied
18:36:43 <Ikkebr> ok :p
18:37:21 <shrughes> > foldl (\x y -> 10 * x + digitToInt y) "1234"
18:37:23 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
18:37:27 <shrughes> > foldl (\x y -> 10 * x + digitToInt y) 0 "1234"
18:37:28 <lambdabot>   1234
18:38:16 <Eridius> @pl \x y -> 10 * x + digitToInt y
18:38:17 <lambdabot> (. digitToInt) . (+) . (10 *)
18:38:30 <Eridius> > foldl ((. digitToInt) . (+) . (10 *)) 0 "1234"
18:38:32 <lambdabot>   1234
18:39:12 <shrughes> yuck
18:39:41 <Eridius> sure, that example's a bit messy, but <3 point-free style
18:40:18 <shrughes> > foldl ((+) . (10*)) 0 . map digitToInt $ "1234"
18:40:19 <lambdabot>   1234
18:41:00 <shrughes> > foldl ((+) . (10*)) 0 . map (on (-) ord '0') $ "1234"
18:41:02 <lambdabot>   -1234
18:41:05 <shrughes> erm.
18:41:10 <Eridius> what's on?
18:41:38 <shrughes> > foldl ((+) . (10*)) 0 . map (flip (on (-) ord) '0') $ "1234"
18:41:39 <lambdabot>   1234
18:41:45 <Eridius> having fun?
18:41:54 <shrughes> on f g x y = f (g x) (g y)
18:42:11 <Eridius> ?type on
18:42:12 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:42:40 <shrughes> > sortBy (compare `on` length) ["hey", "whatt", "", "234"]
18:42:42 <lambdabot>   ["","hey","234","whatt"]
18:43:01 <bd_> :t on
18:43:02 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:43:06 <bd_> oh, someone already did :)
18:43:10 <Eridius> neat. is there a version for other numbers of arguments?
18:43:11 <Axman6> hmm, on looks useful... i just don't know what for
18:43:15 <bd_> @hoogle on
18:43:15 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:43:15 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
18:43:15 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
18:43:19 <bd_> Axman6: shrughes just gave an example
18:43:19 <Eridius> or do you just have to nest on?
18:43:25 <Axman6> yeah
18:43:30 <Axman6> but apart from that :P
18:43:34 <Axman6> i guess it works
18:43:37 <shrughes> I'm not sure where you need it for more than 2 arguments
18:43:40 <Axman6> for more than that
18:43:57 <Eridius> shrughes: constructing extremely wacky point-free stylings?
18:46:15 <shrughes> ((. g) .) . on f g
18:46:32 <Eridius> I'm not even going to figure that one out :P
18:46:34 * Eridius has to leave in a couple minutes
18:46:42 <bd_> :t \ f g -> ((. g) . ) . on f g
18:46:43 <lambdabot> forall b c a. (b -> b -> b -> c) -> (a -> b) -> a -> a -> a -> c
18:47:01 <bd_> @pl \ f g -> ((. g) . ) . on f g
18:47:02 <lambdabot> ap ((.) . (.) . flip (.)) . on
18:47:38 <bd_> @pl \ f g a b c -> f (g a) (g b) (g c)
18:47:39 <lambdabot> join . ((flip . ((flip . ((.) .)) .)) .) . join . ((flip . ((.) .)) .) . (.)
18:47:42 <shrughes> oh OF COURSE!  it makes perfect sense now
18:47:53 <shrughes> pointless notation indeed
18:47:54 <bd_> @. unpl pl \ f g a b c -> f (g a) (g b) (g c)
18:47:55 <lambdabot> (\ z -> (\ az b c f i -> ((\ bi n o r -> z (bi o) (n r)) >>= \ ao -> ao) az c f (b i)) >>= \ aa -> aa)
18:48:11 <Axman6> wow...
18:48:22 <bd_> is that... even the same function? o_O
18:48:25 <bd_> @. t . unpl pl \ f g a b c -> f (g a) (g b) (g c)
18:48:25 <lambdabot> Plugin `compose' failed with: Unknown command: "t"
18:48:28 <bd_> @. type . unpl pl \ f g a b c -> f (g a) (g b) (g c)
18:48:30 <lambdabot> forall t t1 t2. (t2 -> t2 -> t2 -> t) -> (t1 -> t2) -> t1 -> t1 -> t1 -> t
18:48:35 <seafood> Is there a away to use runhaskell with #! inside a shell script that doesn't require the file to have a .hs extension?
18:48:36 <bd_> huh
18:50:03 <dcoutts> @yarr!
18:50:03 <lambdabot> Keelhaul the swabs!
18:50:53 <dons> ?yow
18:50:53 <lambdabot> I HAVE to buy a new "DODGE MISER" and two dozen JORDACHE JEANS because
18:50:54 <lambdabot> my viewscreen is "USER-FRIENDLY"!!
18:51:26 <ushdf> oO
18:51:51 <ushdf> > my love for you
18:51:52 <lambdabot>   mueval: Prelude.read: no parse
18:51:54 <Axman6> it's not nice to drug bots guys
18:52:02 <bjrn> I failed my innuendo check.
18:52:10 <bjrn> What's the bot talking about?
18:56:14 <Eiler> ghc --make -O2 HelloWorld.hs -o helloWorld" what is the -O2 flag, and shouldnt the -o be -O?
18:56:50 <Olathe> It's the second level of optimization and no, O is different.
18:57:07 <Olathe> O is the zero optimization, I think, and o is output file.
18:57:50 <Eiler> ah ye o is output, what levels of optimizations is there and which one is preferred?
18:57:59 <Olathe> O2 is the one most use.
18:58:04 <Axman6> -O is optimise, -O1 is the same, -O2 is do as much as you can (which doesn't do much afaik)
18:58:07 <bjrn> Eiler: compilers since GCC usually have the -O0, -O1, -O2 and -O3 flags to specifiy optimizaion. -O2 is the most common by far.
18:58:10 <ushdf> give me optimizations or give me money
18:58:12 <Olathe> I think O3 has some possibly-false optimizations.
18:58:16 <hackage> Uploaded to hackage: happs-tutorial 0.4.3
18:58:18 <Axman6> -o is just the output file
18:58:32 <Axman6> Olathe: pretty sure -O3 doesn't work with ghc
18:58:39 <Olathe> Ahh, that might be a problem, too ;)
18:58:51 <Axman6> well, it may, but it's no different to -O2, which isn't much (if any) different to -O
18:58:57 <Eiler> bjrn: yes with gcc but thats difference, thats for c, i dont think ghc has -O3
18:59:28 <Axman6> ---opt-)2 might work if gcc's used
18:59:29 <dolio> For GHC, anything above 2 is equivalent to 2.
18:59:35 <Axman6> -opt-O2*
19:00:05 <Olathe> @yow
19:00:05 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
19:00:09 <Eiler> can i write anything to ghc to see what the different optimizations does or do i have to look in the docs?
19:00:41 <Axman6> Eiler: could look at the core if youwanted...
19:01:01 <bjrn> The simple functional programming language
19:01:10 <bjrn> or whatever they called it :)
19:01:18 <Eiler> core.. isnt there just some description of the flags, ghc --help doesnt show the different optimizations
19:01:35 <adekoba> hey. I want to read a file strictly (otherwise the file is not read), but the bytestring returned must be a ByteString.Lazy. Would it be best just to force evaluation of a ByteString.Lazy.readFile with $!! ?
19:09:35 <gnuvince_> On Ubuntu (Hardy Heron), what package must I install to get Control.Parallel?
19:12:05 <adekoba> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel
19:12:07 <lambdabot> Title: HackageDB: parallel-1.0.0.1, http://tinyurl.com/3nrtz5
19:12:25 <adekoba> it isn't with base?
19:12:43 <gnuvince_> adekoba: doesn't seem to be included in the GHC package on Hardy Heron
19:13:30 <Saizan> gnuvince_: maybe libghc6-parallel-dev
19:13:55 <gnuvince_> Saizan: that doesn't appear in my package list.
19:14:11 <dolio> There's no hardy package that would obviously include it.
19:14:23 <dolio> I think they may have forgotten it.
19:14:31 <gnuvince_> :(
19:14:55 <BMeph> Oh, adekoba: why not use the non-lazy version of readFile? :)
19:15:00 <Saizan> install from the teh sources, it's easy :)
19:15:11 <adekoba> BMeph: because that would return a strict bytestring :\
19:15:28 <adekoba> BMeph: gives me all kinds of errors for mixing the two
19:16:54 <Saizan> adekoba: creating a lazy bs from a strict one is cheap, fromChunks . (:[])
19:18:11 <dons> btw guys, check it out, http://www.reddit.com/r/programming/comments/74140/bloom_filters_haskell_fast_gene_sequence_analysis/
19:18:13 <lambdabot> Title: Bloom filters + Haskell = fast gene sequence analysis : programming, http://tinyurl.com/4jbxy6
19:18:16 <dons> mega awesome.
19:18:34 <adekoba> Saizan: works, thanks
19:19:43 <Axman6> dons: nice comment ;)
19:20:21 <dons> well, i guess he just doesn't know why. and it is obvious why they measured against C.
19:20:27 <dons> bioinf /= comp. sci.
19:20:35 <dons> so some of the obvious things dont' translate.
19:20:51 <Axman6> one needs speed, the other needs geek popints
19:20:57 <Axman6> points*
19:21:02 <Axman6> i hate this keyboard -_-
19:24:15 <Axman6> how long did it take them to map the human genome?
19:48:52 <Eiler> ghc error: "Could not find module 'Primes':" how do i fix that?
19:49:45 <Saizan> ?hackage monadLib
19:49:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadLib
19:50:23 <Saizan> Eiler: do you have a file called Primes.hs with a "module Primes where" at the top of it?
19:51:14 <Eiler> umm no.. maybe i should have. i just have import Primes (isPrime)
19:52:18 <Saizan> yeah
19:57:48 <Eiler> wonder if it is something of the ghc files i am missing
19:59:55 <Saizan> no, Primes is not a standard module
20:00:22 <Saizan> so you're either supposed to write it yourself or you're missing some sources from the code you're working on
20:01:23 <Eiler> okay
20:16:08 <Eiler> will program speed differ between a precompiled program and one i run through ghci?
20:16:29 <shrughes> yes
20:16:38 <Eiler> much?
20:17:32 <bd_> yes :)
20:18:00 <shrughes> severely :P
20:18:07 <bd_> orders of magnitude
20:19:07 <shrughes> 0 is an order of magnitude :P
20:19:23 <Adamant> bytecode interpretation vs. a very advanced modern optimizing compiler. you be the judge.
20:20:49 <_ar_> shrughes: maybe not? since orders of magnitude are measured as powers of some positive real?
20:20:57 <_ar_> but i'm just being picky
20:21:15 <ddarius> 10^-∞
20:21:23 <shrughes> _ar_ what do you mean?  orders of magnitude are powers of any real
20:22:15 <shrughes> and 0 orders of magnitude means you multiply by 10^0 i.e. 1
20:22:39 <_ar_> shrughes: 0 is only possible if 0 is the base, which is totally useless
20:22:43 <_ar_> oh i see you meant as the power
20:23:43 <crutcher> Hey, I'm trying to solve a monadic IO problem the clever way. I'm working on the (trivial) problem https://www.spoj.pl/problems/TEST/
20:23:45 <lambdabot> Title: 13 Sphere Online Judge 7 (SPOJ) 1 f - Problem TEST 153
20:24:38 <_ar_> shrughes: sorry about that, i thought you were saying something different
20:24:43 <crutcher> And I've got a solution, but I'm looking for a better answer.
20:25:37 <crutcher> I have some idea that i could do something like: map print $ takeWhile (/=42) $ repeat (getLine >>= return . read)
20:25:43 <crutcher> but of course, that has the wrong types
20:26:04 <crutcher> so I'm looking for a monadic version of takeWhile
20:26:06 <crutcher> ideas?
20:26:24 <shrughes> interact $ unlines . takeWhile (/= "42") . lines
20:26:32 <shrughes> oh
20:28:37 <crutcher> is this even reasonable?
20:29:05 <shrughes> a while loop? sounds like some totally obscure programming language principle
20:30:20 <crutcher> let's see, I need something with a type of the form: Monad m => (a -> Bool) -> [m a] -> [m a]
20:30:36 <Cale> crutcher: impossible
20:30:53 <shrughes> possible, but it won't do what you want
20:30:59 <Cale> crutcher: Maybe more like  Monad m => (a -> Bool) -> [m a] -> m [a]
20:31:19 <crutcher> Cale: okay, I see that now.
20:32:05 <shrughes> crutcher: I think by a reasonable definition of 'better', the right way to do this is just to write a recursive function
20:32:34 <crutcher> oh, that's easy. that's how I did it the first time.
20:33:04 <crutcher> but I'm trying to churn through the monadic approach
20:34:39 <Cale> sequenceWhile f [] = return []; sequenceWhile f (x:xs) = do v <- x; if f v then return [] else (do vs <- sequenceWhile f xs; return (v:vs))
20:35:02 <mml> how can i have lambdabot search for functions with a type i give it?
20:35:21 <Cale> @hoogle [a] -> Int
20:35:21 <lambdabot> Prelude length :: [a] -> Int
20:35:21 <lambdabot> Data.List length :: [a] -> Int
20:35:21 <lambdabot> Prelude head :: [a] -> a
20:35:37 <mml> Cale++
20:35:38 <Cale> mml: If that's what you mean
20:35:48 <mml> @hoogle [[a]] -> [a]
20:35:49 <lambdabot> Prelude concat :: [[a]] -> [a]
20:35:49 <lambdabot> Data.List concat :: [[a]] -> [a]
20:35:49 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:35:50 <Cale> There's also djinn, which writes functions based on types
20:36:00 <dobblego> join
20:36:06 <mml> :t join
20:36:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:36:14 <Cale> @djinn (a -> c) -> (b -> c) -> Either a b -> c
20:36:15 <lambdabot> f a b c =
20:36:15 <lambdabot>     case c of
20:36:15 <lambdabot>     Left d -> a d
20:36:15 <lambdabot>     Right e -> b e
20:36:15 <dobblego> > join [[1,2,3], [4,5,6]]
20:36:17 <lambdabot>   [1,2,3,4,5,6]
20:36:45 <shrughes> @djinn Monad m => (a -> Bool) -> [m a] -> m [a]
20:36:46 <lambdabot> Error: Undefined type []
20:36:46 <Cale> Or concat, yeah ;)
20:36:48 <shrughes> meh
20:36:49 <crutcher> neat
20:36:55 <Cale> > concat [[1,2,3],[4,5,6]]
20:36:56 <lambdabot>   [1,2,3,4,5,6]
20:37:00 <shrughes> @djinn Int -> Bool
20:37:01 <lambdabot> Error: Undefined type Int
20:37:07 <shrughes> @djinn Integer -> Bool
20:37:08 <lambdabot> Error: Undefined type Integer
20:37:08 <shrughes> what?
20:37:17 <Cale> djinn doesn't know about Int/Integer
20:37:18 <mml> i'm looking for collate [[1,2,3],[4,5,6]] -> [1,4,2,5,3,6]
20:37:19 <shrughes> oh
20:37:22 <Cale> Or lists.
20:37:28 <mml> i have written it, but wondered if that wheel was already out there
20:37:30 <shrughes> it doesn't know that I was looking for a primality test either :P
20:37:38 <mml> even works on lists of differing lengths
20:37:58 <Cale> > concat . transpose $ [[1,2,3],[4,5,6]]
20:38:00 <lambdabot>   [1,4,2,5,3,6]
20:38:09 <Cale> collate = concat . transpose
20:38:28 <mml> > transpose [[1,2,3],[4,5]]
20:38:29 <lambdabot>   [[1,4],[2,5],[3]]
20:38:41 <mml> > concat . transpose [[1,2,3],[4,5]]
20:38:42 <lambdabot>   Couldn't match expected type `a -> [[a1]]'
20:38:46 <mml> > concat . transpose $ [[1,2,3],[4,5]]
20:38:47 <lambdabot>   [1,4,2,5,3]
20:38:59 <mml> perfecto
20:39:04 <Cale> > concat . transpose $ [[1,2,3],[4,5],[6,7,8]]
20:39:05 <lambdabot>   [1,4,6,2,5,7,3,8]
20:40:45 <newsham> > concat . transpose $ ["testing", cycle "-"]
20:40:46 <lambdabot>   "t-e-s-t-i-n-g-------------------------------------------------------------...
20:43:35 <roconnor> > concat . transpose $ ["testing", cycle "."]
20:43:36 <lambdabot>   "t.e.s.t.i.n.g................................................................
20:46:18 <crutcher> Cale: cool, that works, but you inverted the if/then/else cases
20:46:31 <crutcher> Cale: you wrote, effectively, sequenceUntil
20:48:04 <bd_> @hoogle sequenceUntil
20:48:05 <lambdabot> No results found
20:48:14 <papermachine> @djinn (a -> a) -> a
20:48:14 <lambdabot> -- f cannot be realized.
20:50:48 <Cale> crutcher: oh, yes I did
20:51:12 <crutcher> thanks though, that helped me a lot :)
20:56:13 <thetallguy> Anyone have a copy of the ICFP '08 proceedings handy?
21:00:31 <BMeph> thetallguy: Something I can get for you? ;)
21:01:33 <thetallguy> I'm reading Hinze's Pearl.  In Section 2.3, there are three laws about the interleave function.  The first one makes no sense to me
21:01:43 <thetallguy> I'm wondering if the PDF I have has a bug in it.
21:02:15 <thetallguy> In mine, it asserts that a stream c interleaved with itself is equal to itself
21:05:18 <Saizan> maybe it's a constant stream?
21:05:29 <BMeph> thetallguy: Saizan got it - ""
21:05:55 <BMeph> "We let s, t and u range over streams and c over constant streams."
21:05:58 <thetallguy> Ah, right.  Yes, he did say that c would represent constant streams.
21:06:00 <thetallguy> Thanks.
21:06:17 <mauke> @seen preflex
21:06:18 <lambdabot> preflex is in #perl6, #xmonad, #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when preflex last spoke.
21:06:31 <BMeph> thetallguy: Hey, you pointed another fun paper our way; thank You! ;)
21:06:37 <thetallguy> I read that part last night.  Funny, I knew that was going to annoy me.
21:06:56 <lispy> have you guys heard of strong functional programming?
21:06:59 <thetallguy> dons said last night he thought it was the best pearl yet
21:07:09 <lispy> er, sorry, i mean, total functional programming
21:07:48 <thetallguy> lispy: I think it refers to a language that doesn't allow partial functions
21:07:56 <lispy> the semantics and type system can be similar to haskell/sml but only allow total functions to be defined
21:08:10 <lispy> thetallguy: yeah
21:08:20 <thetallguy> lispy: right.  A total function is one that is well defined on all inputs
21:08:26 <lispy> I was reading a paper from LtU about it, kinda neat but no implementation was proposed
21:08:38 <thetallguy> the Maybe type is used to convert a partial function into a total one.
21:09:09 <lispy> No examples of that in this paper.  Instead general recursion was removed :)
21:09:17 <thetallguy> Ouch!
21:09:26 <thetallguy> I hate when that happens.
21:09:31 * thetallguy crosses his legs.
21:09:33 <dobblego> it has to be
21:09:35 <lispy> only structural recursion was allowed, as a convienent form of primitive recursion
21:10:17 <lispy> to deal with infinite streams they had primitives for declaring codata
21:10:26 <BMeph> The main point I think, is that 1) The language is not TC; 2) It's still useful for a lot of problems you want to solve. :)
21:10:40 <BMeph> Er, s/point/point*s*/ ;p
21:10:43 <lispy> BMeph: right, that was the thesis of the paper I read
21:10:48 <thetallguy> Right, that's what i remember hearing, but I didn't read the paper.
21:11:04 <BMeph> I just finished reading it last week sometime. :)
21:11:19 <lispy> The section of codata/corecursion/co* was a bit...confusing not having heard of that stuff before.
21:11:29 * BMeph gasps
21:12:20 <BMeph> I would like to see comonads explored for use more in Haskell, but frankly, ed K's extras package has a WHOLE lot of "extra" in it... ;)
21:12:48 <Saizan> lispy: that's like in Agda
21:13:19 <lispy> Oh, so one thing the author talked about was that the distinction between lazy/strict doesn't exist in total functional programming.
21:13:37 <lispy> But, then gave insufficient justification to make me understand how that works :)
21:13:54 <mrd> lispy: easy enough: everything must terminate :)
21:13:55 <Saizan> BMeph: we use codata/corecursion everyday in haskell, we just don't make the distrinction with data/recursion
21:14:09 <lispy> He gave one example, where defining (&) by cases in Haskell misses two cases...
21:14:28 <BMeph> Saizan: That's a truthful, but not very helpful observation... ;p
21:14:44 <lispy> mrd: See I don't get how that's useful.
21:15:05 <BMeph> Saizan: It reminds me of my explanations to my Java-hacking friend about type purity. :)
21:15:09 <lispy> mrd: lazy evaluation gives short cut computations
21:15:46 <sebaseba> what's type purity?
21:15:49 <Saizan> BMeph: more details :) http://sigfpe.blogspot.com/2007/07/data-and-codata.html
21:15:50 * lispy just keeps PL theory to himself at the office, it ganers too many blank stares followed by terminated conversations
21:15:50 <lambdabot> Title: A Neighborhood of Infinity: Data and Codata
21:16:06 <mrd> lispy: well the point is that it's strongly normalizing, so no matter which order you take, you get the same result. and it's guaranteed to terminate.
21:16:46 <BMeph> lispy: I thought his use of (&) was in demonstrating how it's implemented as strict in the first argument, which can be a problem if you don't give it the "right" order to evaluate the arguments.
21:17:25 <Saizan> (btw, which paper is this?)
21:17:33 <lispy> BMeph: yeah, because you could give it _|_ & True
21:17:49 <lispy> Saizan: total functional programming, by (I think) D. Turner
21:18:06 <lispy> Saizan: http://lambda-the-ultimate.org/node/2003
21:18:11 <lambdabot> Title: Total Functional Programming | Lambda the Ultimate
21:18:20 <Saizan> thanks
21:18:32 <lispy> BMeph: Okay, I think I get it now.
21:18:48 <BMeph> Straight to the paper: http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751_0768_turner.pdf
21:19:02 <lambdabot> Title: cache:http://www.jucs.org/jucs_10_7/total_functional_programming/jucs_10_07_0751 ..., http://tinyurl.com/2fcfrr
21:19:05 <chreekat> newbie question: how do I fix the problem with this function? "f c = filter (\x -> mod c x == 0) [2..sqrt(c)]".
21:19:24 <mauke> chreekat: you need to convert around sqrt
21:19:31 <lispy> > \f c filter (\x -> mod c x == 0) [2..sqrt(c)]
21:19:32 <lambdabot>   mueval: Prelude.read: no parse
21:19:35 <lispy> > \f c -> filter (\x -> mod c x == 0) [2..sqrt(c)]
21:19:37 <lambdabot>       Overlapping instances for Show (t -> a -> [a])
21:19:37 <lambdabot>        arising from a us...
21:19:50 <lispy> :t \f c -> filter (\x -> mod c x == 0) [2..sqrt(c)]
21:19:51 <lambdabot> forall t a. (Floating a, Integral a) => t -> a -> [a]
21:20:09 <mauke> chreekat: floor (sqrt (fromIntegral c))
21:20:27 <chreekat> ah fromIntegral
21:20:39 <lispy> :t c `mod` x == 0
21:20:41 <lambdabot> Bool
21:20:46 <mrd> get rid of the sqrt(c) :)
21:22:08 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..]
21:22:09 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:22:44 <lispy> > let divisors c = filter (\x -> c `mod` x == 0) [2.. floor (sqrt (fromIntegral c))] in divisors 100
21:22:46 <lambdabot>   [2,4,5,10]
21:23:25 <lispy> > let divisors c = filter (\x -> c `mod` x == 0) [2.. floor (sqrt (fromIntegral c))] in divisors 28
21:23:27 <lambdabot>   [2,4]
21:24:29 <lispy> > let isPrime p = p `elem` (nubBy (\x y -> y `mod` x == 0) [2..]) in isPrime 1043
21:24:37 <chreekat> ug. truncate(sqrt(fromIntegral c)). I'd sorta hope that .. some part of that would be automatic
21:24:45 <lambdabot>   thread killed
21:24:58 <mrd> @type sqrt
21:25:00 <lambdabot> forall a. (Floating a) => a -> a
21:25:08 <mrd> it produces a fp number so you have to do something with that..
21:25:13 <lispy> oh heh, `elem` there is kinda not gonna work at all.
21:25:16 <mrd> haskell is strongly typed
21:25:36 <lispy> ?hoogle isqrt
21:25:36 <lambdabot> No results found
21:25:41 <BMeph> chreekat: Welcome to "Do-What-I-Damn-Well-Said" World... ;)
21:26:01 <lispy> :t floor . sqrt . fromIntegral
21:26:03 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
21:26:35 <lispy> I guess we could have that isqrt for Integral couldn't we
21:27:16 <chreekat> ok thanks guys
21:28:50 <lispy> > let isPrime p = p `elem` (takeWhile (<p) (nubBy (\x y -> y `mod` x == 0) [2..])) in isPrime 1043
21:28:52 <lambdabot>   False
21:28:58 <lispy> > let isPrime p = p `elem` (takeWhile (<p) (nubBy (\x y -> y `mod` x == 0) [2..])) in isPrime 3
21:29:00 <lambdabot>   False
21:29:03 <lispy> doh!
21:29:14 <lispy> > let isPrime p = p `elem` (takeWhile (<2*p) (nubBy (\x y -> y `mod` x == 0) [2..])) in isPrime 3
21:29:16 <lambdabot>   True
21:29:20 <lispy> > let isPrime p = p `elem` (takeWhile (<2*p) (nubBy (\x y -> y `mod` x == 0) [2..])) in isPrime 1043
21:29:23 <lambdabot>   False
21:29:26 <lispy> There we go
21:29:40 <lispy> close enough for IRC ;)
21:29:44 <BMeph> lispy: Or make an Integral permutation function. :)
21:30:39 <BMeph> let iPerm f = floor . f . fromIntegral
21:31:41 <lispy> Why do you call that a permutation?
21:32:17 <BMeph> Whoops, s/permutation/conjugation/
21:33:06 <lispy> Also, does not fit my working model of conjugation.  I think of conjugation as something you do with group elements like, pdp^(-1) is conjugation of d by p
21:33:12 <BMeph> I thought it was called a conjugation, but I found the info on a page describing permutation.
21:34:07 <Axman6> @index liftM
21:34:07 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
21:34:17 <lispy> liftM gets around
21:34:22 <lispy> But, as I'm told, prefer fmap
21:34:24 <mauke> @index liftA
21:34:24 <lambdabot> bzzt
21:34:39 <mauke> @hoogle liftA
21:34:39 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
21:34:39 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:34:39 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
21:34:49 <Axman6> @index immediately
21:34:50 <lambdabot> bzzt
21:35:14 <BMeph> Yeah, it isn't true conjugation, just more-or-less conjugation type wise
21:35:46 <BMeph> lispy: Is it a letter thing?
21:35:50 <ddarius> You could probably make a reasonable case for extending conjugation to a section and retraction.
21:36:10 <BMeph> lispy: Say, do you prefer cofmap/coFmap over liftW? ;)
21:36:29 <lispy> BMeph: I like liftM, but I've been told to prefer fmap
21:36:39 <ddarius> lispy: Do what you want.
21:36:43 <lispy> BMeph: I think the reason had to do with prelude
21:36:44 <dons> ?yow
21:36:45 <lambdabot> When I met th'POPE back in '58, I scrubbed him with a MILD SOAP or
21:36:45 <lambdabot> DETERGENT for 15 minutes.  He seemed to enjoy it ...
21:36:48 <ddarius> I use both and <$> as wel
21:37:18 <lispy> ddarius: <shrug> I came here after being told to use fmap instead of liftM and the consensus here was to use fmap as well...
21:37:28 <mauke> the recommended solution is to redefine (.) and use that instead
21:37:47 <sjanssen> bleh
21:37:51 <ddarius> lispy: Don't believe everything you hear on the internet.
21:37:59 <ddarius> mauke: Blech
21:38:38 <lispy> > (+1) . [1..3]
21:38:39 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
21:38:41 <BMeph> It's interesting how Applpicatives and Monads seem to get a lot of play, while Arrow slowly gets left behind.... It makes me feel sorry for 'em - Arrows, that is. There should be more instances for them. :/
21:39:08 <lispy> Oh, did we finally ungeneralize (.) in lambdabot?
21:39:15 <lispy> :t (.)
21:39:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:39:26 <visof> i'm trying to install ghc-6.8.3 but i get make[1]: *** [install.library.base] Error 1
21:39:30 <visof> make[1]: Leaving directory `/usr/local/ghc-6.8.3/libraries'
21:39:38 <ddarius> BMeph: It's the notation that is or is not getting used, not the abstractions.  Most uses of Applicative operators are for monads.
21:39:47 <BMeph> lispy: Heh-heh, a staunch resister to the proselytes of the Church of Cale... ;)
21:40:08 <Stinger> visof, somewhere upward there should be a real error
21:40:15 <visof> also get this installPackage: LICENSE: copyFile: does not exist (No such file or directory)
21:40:27 <lispy> BMeph: I didn't like the generalized (.) lambdabot, but only because I lke lb to match prelude :)
21:41:33 <Axman6> that defun haskell tutorial is really good
21:41:42 <lispy> BMeph: but maybe Cale can get his way with Haskell' for some value of '
21:41:58 <BMeph> lispy: Heh-heh. :)
21:42:37 <Axman6> bos: if you're arround, just wanted to say those slides from your defun tutorial thing are really good
21:43:12 <Saizan> i prefer fmap since it can be optimized for the monad in question, while liftM always uses >>=
21:43:15 <lispy> I have to admit, after reading the paper on total functional programming, I'd love to see the core of haskell changed so that it has a new layer...the inner most is total functional, surrounded by the lazy pure layer, and then surrounded by the IO layer we all know and love
21:44:00 <BMeph> Saizan: Do you have any use cases for your "optimization"? :)
21:44:11 <Cale> lispy: The main reason that (.) isn't generalised is that mueval doesn't (didn't) support qualified imports.
21:44:30 <Saizan> BMeph: yes, my monad that automatically infers parallelism :P
21:44:34 <Cale> There's a new version that does, but I'm not sure if it's on hackage yet
21:45:48 <BMeph> Cale: Have you considered having a separate @run symbol to activate the "Cale-ified" evals? ;)
21:46:27 <Cale> BMeph: I have.
21:46:38 <Cale> BMeph: It's possible that might even be reasonable with mueval.
21:46:51 <BMeph> Calle: Ooh, joy! ;)
21:48:06 <lispy> so excited he didn't get the tab completion right :)
21:50:28 <bos> Axman6: thanks
21:50:49 <Axman6> there isn't a video of it i take it?
21:50:55 <bos> no, sorry
21:51:02 <Axman6> pitty
21:51:13 <Axman6> anyway, well done, very nice presentation :)
21:52:04 <BMeph> lispy: Naugh, I usually don't even use tab-completion. That way, I flub up people's names by being "almost" right.
21:52:25 <BMeph> lispy: In other news, I think my wireless keyboard needs a battery change. :/
21:53:00 <ddarius> BMeph: That's the way to be.
21:53:24 <lispy> BMeph: Should have used a Haskell keyboard, batteries included!
21:53:36 <BMeph> lispy: ;p
21:54:00 <BMeph> ddarius: Almost-right, or running low on power? ;)
21:55:13 <ddarius> BMeph: No tab completion.
21:57:15 <dobblego> @users
21:57:15 <lambdabot> Maximum users seen in #haskell: 516, currently: 467 (90.5%), active: 14 (3.0%)
21:58:54 <BMeph> bos: Nice work on the filter paper! I'm still reading it, and I'm not sure if I can add anything to help the Reddit OP to "get a clue," but it looks good so far as I see.
22:05:26 <Axman6> hmm... i feel i'm losing my haskell mojo... i need something to write that's not overly difficult, but challenging
22:06:01 <binrapt> Write an IO completion port client in Haskell
22:06:17 <Axman6> a what?
22:06:19 <binrapt> Oh damn you're on a Mac
22:06:29 <Axman6> i am
22:07:03 <dons> Axman6: go through the happs-tutorial?
22:07:22 <Axman6> can't get happs running properly, and no one seems to know why :\
22:07:31 <dons> cabal install happs?
22:07:32 <Axman6> searchpath does some odd stuff
22:07:38 <dons> don't use searchpath?
22:07:55 <dons> we have cabal for a reason :)
22:08:15 <Axman6> yeah i've used cabal to install HApps-Server and stuff. i'll do away with sp then i guess :0
22:08:18 <Axman6> :)*
22:08:24 * Axman6 needs a shave
22:08:48 <Axman6> i'll get on that after i finish bos' RWH slides
22:09:06 <Axman6> hmm... it appears i already have, ha
22:11:50 <yakov2> I read somewhere that Haskell is a part of the lisp family. Is that true?
22:12:11 <Axman6> well it's a functional language... does that count?
22:12:15 <dons> its a grandchild of lisp.
22:12:24 <yakov2> dons in what way?
22:12:34 <dons> lisp is cited in the haskell 98 report as being a foundational influence.
22:12:45 <yakov2> okay
22:12:56 <dons> but lisp inspired ML, and Haskell is based largely on ML, Hope, Orwell, and some other languages from the 80s
22:13:11 <yakov2> okay
22:15:51 <lispy> Miranda
22:16:12 <lispy> yakov2: have you read the history of haskell paper?
22:16:42 <ozy`> lispy: did you just watch that fruity oaty bars commercial by any chance?
22:17:06 <lispy> yakov2: http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
22:17:08 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
22:17:13 <lispy> ozy`: The one from serenity?
22:17:37 <lispy> ozy`: 'cause I was just naming Miranda as foundational influence to Haskell
22:18:13 <Cale> But calling Haskell part of the lisp family of languages seems very wrong by now :)
22:18:29 <ozy`> lispy: I know... that was the joke... ._.
22:18:45 <Cale> Haskell is much more a descendent of ISWIM than it is of Lisp.
22:19:23 <Cale> (also, SASL and KRC, and Miranda which was already mentioned)
22:20:27 <BMeph> It's as bad as the folks who claim Forth is a Lisp. I mean, c'mon, is this the PL version of lolcats?!? ;)
22:24:22 <ozy`> "ISWIM can be looked on as an attempt to deliver LISP from its eponymous commitment to lists, its reputation for hand-to-mouth storage allocation, the hardware dependent flavor of its pedagogy, its heavy bracketing, and its compromises with tradition."
22:24:45 <ozy`> ISWIM looks a lot like ML.... or should I say, ML looks a lot like ISWIM?
22:25:08 <dons> yes. sounds like haskell.
22:25:37 <dons> haskell delivers lisp from only lists, low level-ness, impurity, bracketing, and tradition.
22:25:42 <dons> and lack of types.
22:26:51 <ozy`> functional purity still strikes me as a little crazy... but then, I haven't gotten very far yet in learning Haskell
22:27:34 <dons> try doing parallelism without it :) or transactional memory. or reasoning about your code. or optimisation. or refactoring.
22:27:51 <dons> it makes all those a lot easier, purity is haskell's most signifcant decision.
22:27:56 <int-e> or laziness.
22:28:23 <dons> laziness would be intractable without purity.
22:28:34 <dons> so laziness was the hair shirt that kept haskell pure.
22:28:44 <dons> enabling things like monads, fusion and stm to be found
22:29:25 <Elly> dons: lisp is low-level?
22:30:03 <Cale> I think laziness is more important than SPJ makes it sound in his recent talks, and I think he knows this, but purity is even more important, and so he wants to push that harder :)
22:30:04 <dons> do they do endomorphisms?
22:30:23 <Elly> what does that have to do with low-level?
22:30:41 <dons> the high level abstractions used in haskell aren't found in lisp, because it is a lower level language.
22:30:58 <dons> its tied up in commitments to low level decisions, that prevent some kinds of abstraction.
22:31:02 <ozy`> dons: don't get me wrong, I understand the point behind having pure functions... but making the entire language pure and then going ahead from there is... a little baffling
22:31:05 <Elly> like what?
22:31:10 <ozy`> .... and laziness even more so
22:31:12 <dons> which isn't surprising. the first language born isn't going to be the perfect language.
22:31:29 <dons> Elly: like impurity, lack of algebraic data types, and over-commitment to cons cells.
22:31:52 <dolio> I don't think you can claim transactional memory as an outgrowth of Haskell sticking to pure functions.
22:31:56 <Elly> I suspect the lisp guys view haskell as being under-committed to cons cells :p
22:32:09 <dons> dolio: only the software aspect making retry tractable.
22:32:11 <Elly> lack of algebraic data types lets you have things like apply and format
22:32:16 <lament> haskell is over-committed to lists
22:32:19 <dons> C people think Haskell is under-committed to pointers.
22:32:27 <mauke> Elly: er, haskell has printf
22:32:31 <mauke> that's format right there
22:32:32 <dons> :t printf
22:32:33 <lambdabot> forall r. (PrintfType r) => String -> r
22:32:46 <dons> > printf "%s %c" "hehe" '!'
22:32:47 <lambdabot>   Add a type signature
22:32:50 <dons> > printf "%s %c" "hehe" '!' :: String
22:32:51 <lambdabot>   "hehe !"
22:32:56 <Elly> delicious typeclasses
22:32:57 <dons> > printf "%s %c" "hehe" '!' :: IO String
22:32:58 <lambdabot>   mueval: Prelude.read: no parse
22:32:58 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
22:33:01 <dons> heh
22:33:06 <dons> mueval : i know you not.
22:33:20 <dons> Cale, why do we use mueval anyway?
22:33:32 <dons> we had a perfectly wonderful runplugs, with a paper written about it.
22:33:49 * dons doesn't understand the motivation for some sweeping lambdabot changes
22:34:09 <Cale> dons: Well, ask gwern :)
22:34:14 <Elly> also, apply :O
22:34:41 <Cale> Elly: You can do things a bit like apply with typeclasses. But apply is not as useful as it's cracked up to be.
22:34:52 <Elly> Cale: macros! :D
22:34:55 <dons> metaprogramming is an orthogonal issue.
22:35:03 <dolio> Presumably, the motivation is to break lambdabot into more manageable pieces so that we get fewer of the random bugs and data loss and such. :)
22:35:05 <Saizan> we have template-haskell :)
22:35:12 <dons> dolio: but runplugs was a separate piece.
22:35:17 <Cale> There is Template Haskell. Admittedly, TH is *much* more messy than any lisp macro system.
22:35:20 <dons> and we've replaced it with something else, just because.
22:35:28 <dolio> Although mueval answering "no parse" to everything it doesn't like isn't great. :)
22:35:34 <dons> it sucks.
22:35:43 <dons> runplugs had a rich dsl for doing useful error messages.
22:35:52 <Cale> There's apparently a new mueval which fixes a lot of the problems but gwern hasn't put it on hackage.
22:35:58 <Saizan> dons: really?
22:36:03 <Cale> and I don't know what to do to install it otherwise
22:36:11 <dons> remember it would print useful suggestions based on the error messages?
22:36:27 <Saizan> dons: i thought those were just ghc error messages
22:36:27 <dons> it was also extensively vetted for safety
22:36:38 <dons> no, it would take the error, parse it, and make more useful recommendations.
22:36:51 <dons> but that's been discarded rashly with a gwern commit. just because.
22:37:00 <dons> so what does mueval provide over runplugs? why did we replace it?
22:37:15 <quicksilver> lack of zombie processes?
22:37:25 <Saizan> i think the main reason was to use the ghc-api for evaluation, and yeah zombies
22:37:25 <quicksilver> memory + CPU time rlimits?
22:37:27 <dons> no. since runplugs was forked by lambdabot
22:37:31 <dons> and lambdabot cleaned up zombies.
22:37:36 <dons> quicksilver: no, runplugs did that.
22:37:37 <quicksilver> well, it didn't.
22:37:38 <dons> in 2004.
22:37:48 <quicksilver> There were tens of zombie processes on the host.
22:37:50 <dons> quicksilver: if its forking mueval, then the issue is not related to runplugs.
22:37:56 <dons> ok. so someone broke that too.
22:38:01 <quicksilver> (I did point out that zombies don't really matter)
22:38:06 <dons> no double forking?
22:38:14 <dons> well, mueval's an external app, isn't it?
22:38:16 <dons> like runplugs?
22:38:23 <Saizan> yes
22:38:25 <dons> so neither are the cause of zombies. lambdabot's fork handling is.
22:38:29 <quicksilver> and runplugs' rlimits did not work.
22:38:38 <dons> yes they did. they're unix rlimits.
22:38:46 <dons> so someone broke that too.
22:38:48 <BMeph> Man, oh MAN! Gwern's not butting package changes of his own on hackage, other folks besides dons are announcing reddit posts... what is this, the end of the world? ;p
22:38:52 <dons> there's a paper about how runplugs works.
22:38:56 <quicksilver> well, the people who adminned that machine told me they didn't.
22:39:02 <BMeph> *putting
22:39:17 <quicksilver> the IRC bot would return after 3 seconds
22:39:25 <quicksilver> but the subprocess kept running and consuming resources for longer
22:39:28 <quicksilver> someone told me.
22:39:33 <quicksilver> might have been Cale :)
22:39:46 <dons> so someone broke that.
22:39:52 <quicksilver> you're probably right.
22:39:55 <dons> it just used standard System.Posix.Resource limits
22:40:02 <quicksilver> but we didn't appear to have anyone willing and capable to fix it.
22:40:10 <Cale> The problem with the zombies is that mueval has a bug.
22:40:19 <dons> why are we using mueval?
22:40:20 <quicksilver> except gwern, whose willingness and capability was to switch it to mueval.
22:40:29 <Cale> dons: Because gwern put it in.
22:40:36 <dons> ok. and there's no patch vetting.
22:40:50 <Saizan> well, the zombies were a problem also before mueval
22:40:52 <dons> so anything goes in. even if it is a pessimisation.
22:40:57 <dons> sigh.
22:41:07 <dons> maintainers are so important.
22:41:23 <quicksilver> when there is only one person prepared to put in the time
22:41:24 <dons> shrug. there's nice code for error messages in the runplugs code
22:41:28 <dons> if anyone cares.
22:41:29 <quicksilver> that person ends up taking the decisions.
22:41:32 <quicksilver> it was ever thus.
22:41:43 <dons> i just don't like things working being broken unnec.
22:41:49 <quicksilver> neither do I.
22:42:00 <quicksilver> But being myself unable to donate the time to get it fixed...
22:42:12 <quicksilver> I am unable to criticise gwern, who at least put in the time to get some things fixed.
22:42:26 <dons> its frustrating. i spent about 2.5 years working on lambdabot, and maybe 1100 patches
22:42:46 <dons> so when things like runplugs, which were very carefully written to be useful, are thrown away for non-obvious reasons, i cry a little.
22:42:52 <quicksilver> I can see that that is frustrating.
22:42:56 <quicksilver> But we had a broken bot.
22:43:04 <quicksilver> It was consuming absurd amounts of resource on that server.
22:43:11 <quicksilver> (which has very limited memory)
22:43:14 <quicksilver> something had to change.
22:43:15 <dons> > printf "%s %c" "hehe" '!' :: IO String -- this was solved 4 years ago
22:43:16 <lambdabot>   mueval: Prelude.read: no parse
22:43:16 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
22:43:43 <ozy`> > "pizza"
22:43:45 <lambdabot>   "pizza"
22:43:50 <ozy`> > "pizza" -- hut
22:43:51 <lambdabot>   "pizza"
22:44:07 <dons> i don't really see how mueval could help in any way. runplugs isn't the problem. looking at resource handling and process forking is. so its a non-solution. just tweaking random things.
22:44:09 <Saizan> that's just a little weird gwern's policy decision, that IO-things must throw exceptions
22:44:33 <dons> and he threw away the trusted module base as well, so we re-did all the security.
22:44:45 <dons> who knows what security model mueval implements.
22:46:05 <Axman6> dons: hmm, this happs tutorial isn't that good. i don't know what i'm actually doing here, just copying the code :\
22:46:15 <dons> quicksilver: it feels like random tweaking. absurd amounts of memory was due to persistant history logging. rlimits breaking is some low ffi detail with the unix library. replacing runplugs is just a non sequitor.
22:46:29 <dons> but commits bits have been handed out, and there's no editor, so .. oh well.
22:46:46 <lispy> why do people say GADTs don't play well with FDs?  Is this actually documented?
22:47:29 <quicksilver> dons: if you say that, I'm sure it's true.
22:47:43 <dons> ?uptime
22:47:43 <lambdabot> uptime: 7d 23h 2m 44s, longest uptime: 1m 10d 23h 44m 29s
22:47:48 <quicksilver> dons: when the crisis arose, there was nobody saying that, and certainly nobody who understood the problem willing to fix it.
22:47:49 <dons> does anyone know what patch finally fixed the crashes?
22:47:57 <dons> was it sjanssen fixing the history logging?
22:47:57 <lispy> dons: you're making me nervous about hosting lambdabot :)
22:48:12 <dons> lispy, i would be. you need a clear discussion about what mueval does.
22:48:39 <dolio> lispy: I think the type refinement from GADTs doesn't inform fundeps, or something like that.
22:48:39 <dons> what is its security model?
22:48:47 <Saizan> i'd say mueval is paranoic about security
22:49:10 <dolio> Let me see if I can construct an example...
22:49:17 <dons> this was written about runplugs, http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
22:49:19 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
22:49:24 <lispy> dolio: hmm...I was thinking about combining them, but people just tell me they don't work well together, but that's a little too uninformed :(
22:49:31 <dons> it includes known exploits, and solutions.
22:49:51 <lispy> dons: honestly, I've just been trusting Cale's judgement
22:50:01 <dons> but Cale's not looking at the patches, he's just applying htem.
22:50:14 <lispy> I see :(
22:50:31 <Cale> If someone else wants to look at the patches instead, go for it :)
22:50:42 <dons> maybe its all ok, i don't know. but the parse regression is glaring and ugly. the mueval changes seem to be a non-sequitor.
22:50:59 <dons> and no one knows what patch it was that fixed the actual problem with staying up. (i'm only speculating it was sjanssen's)
22:51:04 <quicksilver> dons: mueval's security model contains daft substring checking
22:51:06 <quicksilver> > listArray
22:51:07 <lambdabot>   mueval: Unsafe functions to use mentioned.
22:51:10 <Cale> Apparently all the major bugs in mueval have been fixed, but they require a newer haskell-src-exts than is on hackage.
22:51:13 <dons> quicksilver: strings?
22:51:16 <dons> not type checking?
22:51:20 <Saizan> dons: both
22:51:27 <quicksilver> the substring 'array' is right out.
22:51:33 <Cale> (which is dumb)
22:51:34 <quicksilver> even though there exist pure and safe array functions.
22:51:36 <quicksilver> annoying.
22:51:38 <Saizan> and the string checking is just dumb..
22:51:41 <dons> so that's a non sequitor.
22:52:08 <lispy> Wait, I'm not even using FDs
22:52:29 <dons> ok. i'll see if i can tear out mueval and replace it with runplugs, which was safe, and ran for 4 years before, and has a documented security model we actually understand.
22:52:31 <Saizan> it has been replaced by identifier checking, which is slightly better
22:52:40 <lispy> I just want to put type class constraints in gadts.  Is this not going to work?  I really don't understand the problem here.
22:52:42 <dolio> lispy: http://hpaste.org/10756
22:52:54 <quicksilver> lispy: type class contraints in gadts is fine.
22:52:55 <dolio> Type class constraints in GADTs works.
22:53:03 <quicksilver> lispy: indeed, it's one of the things they introduced
22:53:14 <quicksilver> (contrains on constructors which are actually useful)
22:53:25 <dons> the other big security issue is auditing the in scope modules.
22:53:31 <lispy> http://hpaste.org/10757
22:53:46 <lispy> dolio, quicksilver: that's what I have in mind
22:54:12 <lispy> any reason why that shouldn't work?
22:56:27 <sjanssen> dons: why tear out mueval?
22:56:41 <sjanssen> dons: I've looked at the code a bit, and I think its safe
22:56:52 <int-e> > )
22:56:53 <lambdabot>   mueval: Prelude.read: no parse
22:57:27 <ozy`> > ()
22:57:29 <lambdabot>   ()
22:57:35 <Cale> I wonder where Niklas Broberg is.
22:57:39 <dolio> lispy: I'm a little confused at the purpose of the class, but I imagine it'll work as you expect.
22:57:44 <sjanssen> dons: the substring checking stuff is just an extra "precaution" that I haven't convinced gwern to remove yet
22:58:01 <Cale> He's apparently the maintainer of haskell-src-exts?
22:58:19 <int-e> sjanssen: where is the read that fails there?
22:58:41 <lispy> dolio: It is confusing, but the thing is, we have a totally unsound unsafeCoerceP :: p x y -> p a b, function and I'm looking at ways to make it safe.  One idea, was to restrict the coerced types to be existential phantom types so that you can't actually cause a segfault.  Not sure if this will work yet
22:58:42 <dolio> int-e: Failing to parse the error message.
22:58:44 <sjanssen> dons: I think removing runplugs (or at least spinning it out of lambdabot) is a good move.  I think lambdabot is easier to build now
22:58:53 <Saizan> if we get darcs mueval installed that Prelude.read is gone, at least..
22:58:56 <sjanssen> dons: I note that hs-plugins seems to break every single ghc release
22:59:02 <dons> sjanssen: that's ok, but wouldn't that mean cabalising runplugs?
22:59:16 <dons> sjanssen: i'm happy if it doesn't use hs-plugins, but has the same security model.
22:59:24 <sjanssen> dons: that could be done, but I really don't see anything wrong with mueval
22:59:24 <Cale> Saizan: How would I do that?
22:59:25 <dons> and um. parsing behaviour.
22:59:32 <dolio> lispy: Sounds pretty crazy. :)
22:59:36 <dons> > printf "%s %c" "hehe" '!' :: IO String -- this was solved 4 years ago
22:59:37 <lambdabot>   mueval: Prelude.read: no parse
22:59:37 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
22:59:47 <dons> sjanssen: so all the nice glue on the lambdabot side for handling runplugs errors is gone.
22:59:54 <Saizan> Cale: get the code from here http://code.haskell.org/mubot/ , cd mueval and install it with cabal
22:59:55 <lambdabot> Title: Index of /mubot
23:00:02 <sjanssen> dons: yeah, that should be resurrected
23:00:03 <dons> so basically, runplugs should have been cabalised, replaced with a bytecode loading call to ghc-api, done.
23:00:23 <Cale> Saizan: If that works, then why the heck is it not on hackage?
23:00:52 <Saizan> Cale: gwern's is waiting for a haskell-src-exts release that fixes some bugs, iirc
23:01:04 <Cale> Right, but it builds without that?
23:01:10 <Saizan> yes
23:01:12 <sjanssen> @seen gwern
23:01:12 <lambdabot> I saw gwern leaving #haskell 1d 13h 12m 2s ago, and .
23:01:13 <Cale> grr
23:01:19 <Cale> What the heck?
23:02:08 * Axman6 senses frustration in the haskosphere
23:02:17 <sjanssen> dons: anyway, mueval has all the safety precuations runplugs did -- remaining issues are functionality only
23:02:34 <Cale> Actually, I'm not sure about that.
23:02:54 <Cale> It seems to fail miserably when people give nonterminating strings to error.
23:03:12 <Saizan> that's also improved in the darcs version
23:03:16 <Cale> okay
23:03:19 <int-e> > error "Hi!"
23:03:31 <int-e> ?!
23:03:31 <lambdabot> Maybe you meant: . ? @ v
23:03:33 <lambdabot>   mueval: Prelude.read: no parse
23:03:33 <lambdabot>  mueval: *** Exception: Hi!
23:04:19 <int-e> > error "\nHi!"
23:04:20 <lambdabot>   mueval: Prelude.read: no parse
23:04:20 <lambdabot>  mueval: *** Exception:
23:04:20 <lambdabot>  Hi!
23:04:35 <Cale> > error "Hi!"
23:04:35 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:04:38 <Cale> ...
23:04:44 <Saizan> ..error is now banned?!?
23:04:45 <Cale> okay, that's, dumb.
23:04:47 <int-e> no it definitely doesn't have all the precautions that lambdabot had.
23:05:06 <sjanssen> > fail "Hi!"
23:05:07 <lambdabot>       No instance for (Show (m a))
23:05:07 <lambdabot>        arising from a use of `show' at <in...
23:05:16 <sjanssen> fail.
23:05:35 <Cale> > fail "Hi!" :: State Integer a
23:05:37 <lambdabot>       No instance for (Show (State Integer a))
23:05:37 <lambdabot>        arising from a use of `...
23:05:39 <int-e> > fail "Hi!" () :: ()
23:05:40 <lambdabot>   * Exception: Hi!
23:05:46 <Cale> heh
23:05:50 <Cale> there you do
23:05:51 <Cale> go*
23:05:59 <glguy> good thing we have a type system to catch that stuff for us
23:06:06 <vegai> so, hmm. What's going on?
23:06:10 <vegai> lambdabot rewrite?
23:06:56 <Cale> blacklisted = const False
23:06:59 * Cale edits.
23:07:17 <int-e> . o O ( blacklisted = const True )
23:07:41 <Cale> Heh, blacklist everything :)
23:07:57 <Cale> > error "Hi!"
23:07:57 <lambdabot>  Terminated
23:07:59 <Cale> > error "Hi!"
23:07:59 <lambdabot>  Terminated
23:08:01 <Cale> hmm
23:08:13 <Cale> > fail "Hi!" () :: ()
23:08:14 <lambdabot>  Terminated
23:08:17 <sjanssen> > mempty :: ByteString
23:08:17 <lambdabot>  Terminated
23:08:26 <Saizan> > ()
23:08:26 <lambdabot>  Terminated
23:08:47 <glguy>  @let err = error gets around the blacklisting
23:08:57 <glguy> more directly
23:09:14 <glguy> not as directly as removing it though :)
23:09:20 <Cale> I wonder what that's about now..
23:09:22 <Cale> > 1 + 1
23:09:22 <lambdabot>  Terminated
23:09:42 <int-e> @let foo=unsafePerformIO# -- ?
23:09:42 <lambdabot>   Parse error in expression: HsPostOp (HsVar (UnQual (HsIdent "unsafePerformI...
23:10:23 <sjanssen> glguy: damn, that is a huge hole
23:10:34 <int-e> ah. no Magic has.
23:10:36 <sjanssen> though the module whitelists should be fine
23:11:16 <Cale> > 1 + 1
23:11:18 <int-e> > let 1#1 = 42 in 1#1
23:11:19 <lambdabot>   2
23:11:19 <lambdabot>   <no location info>: Parse error in pattern
23:11:27 <Cale> > error "Foo"
23:11:28 <lambdabot>   * Exception: Foo
23:11:32 <Cale> okay...
23:11:40 <lispy> The only rule I know about mueval is that if you import hiding an unsafe function people can still get to it
23:11:50 <int-e> > error (error "Foo"))
23:11:50 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 27}
23:11:50 <lambdabot> ...
23:11:52 <int-e> > error (error "Foo")
23:11:54 <lambdabot>   * Exception: Foo
23:12:00 <Cale> > System.IO.Unsafe.unsafePerformIO (return 5)
23:12:01 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:12:05 <Cale> hmm
23:12:13 <Cale> I wonder how it knows that.
23:12:33 <Cale> > print "hello"
23:12:34 <lambdabot>   * Exception: "<IO ()>"
23:12:34 <int-e> it checks for "unsafe" as a substring
23:12:37 <BMeph> > print "unsafe"
23:12:38 <lambdabot>   * Exception: "<IO ()>"
23:12:43 <Cale> Why is that an exception?
23:12:47 <lispy> > unsafeFoo
23:12:48 <lambdabot>   Not in scope: `unsafeFoo'
23:12:55 <int-e> hmm.
23:13:00 <BMeph> > performIO
23:13:01 <Cale> I removed the substring checking bit.
23:13:01 <lambdabot>   Not in scope: `performIO'
23:13:03 <int-e> > let unsafe = unsafe in unsafe
23:13:18 <lambdabot>   thread killed
23:13:19 <glguy> unsafeIOToST available any more?
23:13:19 <int-e> hmm hmm. ok, I misread the code, or I read a different version.
23:13:28 <Cale> > 1 + 1
23:13:29 <lambdabot>   2
23:13:37 <Cale> > unsafeIOToST
23:13:37 <lambdabot>       Overlapping instances for Show (IO a -> ST s a)
23:13:37 <lambdabot>        arising from a u...
23:13:38 <sjanssen> > unsafeIOToST (return ())
23:13:39 <lambdabot>   <<ST action>>
23:13:41 <Cale> heh
23:13:50 <sjanssen> so we need to edit the module imports
23:14:04 <glguy> > runST (unsafeIOToST (print 2))
23:14:06 <lambdabot>   ()
23:14:31 <Cale> @undefine
23:14:37 <Cale> ...
23:14:41 <Cale> > unsafeIOToST
23:14:42 <lambdabot>       Overlapping instances for Show (IO a -> ST s a)
23:14:42 <lambdabot>        arising from a u...
23:14:44 <Cale> okay.
23:15:04 <Cale> Now the question becomes where the heck the import list is.
23:15:12 <sjanssen> Mueval.Context
23:15:14 <Cale> Because it sure isn't the one I have in L.hs
23:15:26 <Cale> ah
23:15:39 <sjanssen> it is not immediately clear whether restricted imports are allowed
23:15:50 <Cale> I wonder what happens if we make that list empty.
23:16:12 <glguy> > runST (unsafeIOToST (Control.Concurrent.killThread =<< Control.Concurrent.myThreadId))
23:16:12 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:16:47 <sjanssen> @let fuzzy = unsafeIOToST
23:17:02 <glguy> > runST (unsafeIOToST System.exitFailure)
23:17:10 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:17:12 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
23:17:24 <sjanssen> > runST (fuzzy $ print 1)
23:17:24 <lambdabot>  Terminated
23:17:25 <Cale> > unsafeIOToST
23:17:26 <lambdabot>  Terminated
23:17:30 <Cale> > 1
23:17:30 <lambdabot>  Terminated
23:17:32 <Cale> hmm
23:17:38 <Saizan> Cale: btw, i sent you a patch about that removeFile error
23:17:53 <Cale> oh.
23:18:10 <glguy> > runST (unsafeIOToST System.getEnv)
23:18:10 <lambdabot>  Terminated
23:18:15 <Cale> don_t-fail-if-cleanup-is-not-necessary-in-plugin_eval_comp.dpatch?
23:18:20 <dolio> > let r :: IORef a ; r = runST (unsafeIOToST (newIORef undefined)) ; cast :: a -> b ; cast a = runST (unsafeIOToST (writeIORef r a >> readIORef r)) in cast
23:18:20 <lambdabot>  Terminated
23:18:25 <Saizan> Cale: yup
23:18:32 <sjanssen> glguy: modules must be imported, and System isn't in the context by default
23:18:38 <glguy> sjanssen: :(
23:18:47 <int-e> @botsnack
23:18:47 <lambdabot> :)
23:18:50 <sjanssen> glguy: this is a key feature for security
23:18:51 <Cale> okay, I have that here, I just forgot to apply somehow
23:18:55 <glguy> sjanssen: ha!
23:19:03 <glguy> sjanssen: like anti-virus on voting machines
23:19:17 <sjanssen> glguy: Haskell has unsafePerformIO -- imports must be controlled
23:20:00 <BMeph> glguy: Heh-heh. ;)
23:20:10 <Deewiant> > 1
23:20:13 <lambdabot>  Terminated
23:20:19 <sjanssen> glguy: restricting to a known safe set of modules is the only way to do it
23:20:30 <glguy> sjanssen: I recognize that. it doesn't make it any better
23:20:38 <sjanssen> glguy: so the implication of "doing it wrong" is totally off base, IMO
23:20:40 <glguy> We have a strongly typed language!
23:20:43 <sjanssen> unless you want to fork base
23:20:52 <glguy> the types tell us if there are effects
23:20:56 <glguy> we wrapped them in monads!
23:21:02 <glguy> (some exceptions may apply)
23:21:42 <glguy> it just means that every Haskell program that relies on base can't be trusted based on its types
23:21:48 <glguy> it is an unfortunate situation
23:22:01 <Cale> uh oh...
23:22:06 <Cale> Well, we'll see
23:22:17 <Cale> I'm getting the "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8" problem here
23:22:25 <Cale> @seen Cale
23:22:33 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
23:22:35 <sjanssen> animaforge.net?
23:22:36 <Cale> yep
23:22:51 <Saizan> sjanssen: lispy's machine
23:22:54 <sjanssen> dons: lambdabot is probably crashing less because its on a new host
23:23:08 <Deewiant> > 1
23:24:13 <Cale> ...
23:25:14 <int-e> huh. readFile and writeFile are considered unsafe. appendFile isn't.
23:25:15 <Saizan> i think the seen module really doesn't expects lambdabot to be closed with @quit
23:25:35 <Saizan> s/doesn't//
23:25:42 <Cale> hmm
23:25:49 <glguy> > print ()
23:25:57 <glguy> this stuff is supposed to work, to show the type
23:25:57 <lambdabot>  Terminated
23:25:59 <Cale> that's still not going to work :)
23:26:02 <int-e> > 1
23:26:07 <lambdabot>  Terminated
23:26:08 <Cale> no mueval yet
23:26:10 <glguy> not to be black-listed out
23:26:10 <int-e> oh
23:26:20 <glguy> putting us on par with every other language's bot
23:26:36 <int-e> @let the = fun begin
23:26:38 <Cale> > 1
23:26:42 <lambdabot>  <local>:1:10: Not in scope: `begin'
23:26:44 <int-e> sorry, cale
23:26:46 <int-e> @undefine
23:26:48 <lambdabot>  Terminated
23:26:54 <Cale> ugh
23:27:03 <Saizan> > ()
23:27:10 <lambdabot>  Terminated
23:27:37 <Cale> ah, cabal somehow installed a length 0 mueval.
23:27:42 <Cale> I have no idea.
23:28:03 <Saizan> disk full?
23:28:20 <lispy> hey now, no filling up the partitions
23:28:32 <sjanssen> Cale: run out of memory while linking?
23:28:52 <lispy> Should be plenty of disk space left
23:29:04 <Cale> there appears to be plenty of space...
23:29:30 <Cale> > 1
23:29:32 <lambdabot>   1
23:29:34 <Cale> okay
23:29:42 <Cale> Try unsafe stuff now. :)
23:29:49 <int-e> > fix error
23:29:50 <lambdabot>   /tmp/3930835062116630113:5:34: Not in scope: `fix'
23:29:54 <Cale> hmm...
23:29:56 <int-e> ow.
23:30:00 <Cale> Maybe there are no imports.
23:30:07 <int-e> > Control.Monad.Fix.fix error
23:30:07 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:30:15 <Cale> It should be using L.hs though, which is importing lots of stuff.
23:30:21 <int-e> > Control.Monad.Fix.fix (flip fail ())
23:30:21 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:30:32 <Cale> I wonder why those are considered unsafe.
23:30:43 <Cale> Maybe not in the module whitelist?
23:30:53 <Saizan> > let fix f = let x = f x in fix error
23:30:53 <int-e> > Control.Monad.Fix.fix (():)
23:30:53 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:30:53 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
23:30:53 <lambdabot>  ...
23:31:39 <Saizan> > let fix f = (let x = f x in x) in fix error
23:31:40 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:32:09 <int-e> > fix (const 1)
23:32:10 <lambdabot>   /tmp/6240490365454031862:5:38: Not in scope: `fix'
23:32:17 <Saizan> Cale: i think only what's exported by L.hs gets in scope
23:32:24 <Cale> @let fix f = x where x = f x
23:32:25 <lambdabot>  Defined.
23:32:29 <Cale> > fix error
23:32:30 <lambdabot>       Ambiguous occurrence `fix'
23:32:30 <lambdabot>      It could refer to either `L.fix', defin...
23:32:35 <Cale> ...
23:32:36 <int-e> huh!
23:32:58 <Cale> Saizan: L.hs has no export list, so it exports everything
23:33:08 <Cale> (Except imported modules?)
23:33:15 <Saizan> everything defined there
23:33:20 <Saizan> not everything imported
23:33:21 <Cale> mm...
23:33:21 <sjanssen> Cale: yes, except imported modules
23:33:30 <Cale> Okay, well, that much is easy enough to fix.
23:33:32 <int-e> > let fix f = (let x = f x in x) in fix (('\n':) . error)
23:33:33 <lambdabot>   "\n* Exception:
23:33:33 <lambdabot>  * Exception:
23:33:33 <lambdabot>  * Exception:
23:33:33 <lambdabot>  * Exception:
23:33:33 <lambdabot>  * Exception:...
23:33:39 <opqdonut_> :D
23:33:43 <opqdonut_> great spam
23:34:32 <Cale> mm... apart from having to export user-defined stuff explicitly.
23:34:44 <Saizan> there's a show too much or several less
23:35:22 <Cale> That behaviour there is okay, I think.
23:35:37 <Cale> Well, I suppose it would be nice to limit the number of lines further.
23:36:19 <glguy> whoa, ocaml builds in a matter of minutes
23:36:28 <glguy> is it written in C?
23:36:33 <idnar> heh
23:36:44 <mauke> no, ocaml AFAIK
23:37:01 <glguy> I wanted to install coq from macports
23:37:10 <glguy> had to build ocaml first, figured I could go make some tea
23:37:54 <mauke> well, it has ocamlopt.opt
23:38:02 <mauke> OPTOMIZED
23:38:10 <int-e> > toDyn ()
23:38:11 <lambdabot>   /tmp/113800741031806639:5:34: Not in scope: `toDyn'
23:38:47 <int-e> > Data.Dynamic.toDyn ()
23:38:47 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:39:16 <lispy> I think, "Unsafe function(s) mentioned." would be more clear
23:39:32 <lispy> the "to use" keeps causing parse errors in my brain :
23:39:33 <lispy> :)
23:39:44 <Saizan> > Any.Module.Name.Is.Unsafe (?)
23:39:44 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:39:49 <Cale> ah, here's a problem
23:40:06 <glguy> using regexps to check safty properties?
23:40:17 <Cale> We're hopefully not doing that.
23:40:18 <int-e> > Prelude.head [42]
23:40:18 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
23:40:27 <mauke> perl does it and it works fine!
23:40:33 <Cale> Yes, every module name is unsafe atm.
23:40:50 <glguy> ?type ask
23:40:51 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
23:40:56 <int-e> > head.tail[42,23]
23:40:57 <lambdabot>   Couldn't match expected type `a -> [a1]'
23:41:03 <int-e> > head.tail$[42,23]
23:41:05 <lambdabot>   23
23:41:16 <Cale> Hint requires that in order to use setTopLevelModules, the module to set as top-level must be interpreted.
23:41:26 <Cale> But our current machinery compiles L.hs
23:41:28 <int-e> @let td=toDyn
23:41:29 <lambdabot>  <local>:2:3:
23:41:29 <lambdabot>      Ambiguous type variable `a' in the constraint:
23:41:29 <lambdabot>        `Typ...
23:41:35 <int-e> @let td x=toDyn x
23:41:36 <lambdabot>  Defined.
23:41:39 <int-e> > td 1
23:41:40 <lambdabot>   <<Integer>>
23:41:56 <glguy> > toDyn 1
23:41:57 <lambdabot>   /tmp/3901492498497450252:5:38: Not in scope: `toDyn'
23:41:59 <int-e> @let is far more permissive than mueval itself
23:41:59 <lambdabot>   Parse error
23:42:13 <Cale> Of course.
23:42:24 <Saizan> oh, yeah, @let just appends to a file
23:42:28 <int-e> and L.hs imports a lot of interesting things. Can we use Data.Dynamic to build unsafeCoerce?
23:42:47 <lispy> Youc an use Data.Dynamic to build unsafeCoerce
23:42:52 <Cale> int-e: Not without the ability to write an instance.
23:42:53 <lispy> oleg did it
23:42:58 <glguy> @let done = Control.Monad.ST.unsafeSTToIO exitFailure
23:42:59 <lambdabot>  <local>:3:7: Not in scope: `Control.Monad.ST.unsafeSTToIO'
23:42:59 <lambdabot>  
23:42:59 <lambdabot>  <local>:3:37: ...
23:43:02 <glguy> err
23:43:08 <glguy> anyway..
23:43:09 <Cale> You need to write a bad instance of Typeable.
23:43:18 <lispy> Yeah, that's true.
23:43:28 <Cale> glguy: L.hs imports things properly ;)
23:43:35 <Cale> glguy: So that function isn't imported.
23:43:38 <Saizan> @let instance Eq (a -> b) where
23:43:38 <lambdabot>  Invalid declaration
23:44:18 <glguy> @let instance Eq (a -> b) where -- = 1
23:44:18 <lambdabot>  Invalid declaration
23:46:13 <Cale> hmm...
23:46:30 <int-e>  @let uses the expression parser built into lambdabot to check its argument
23:46:51 <Cale> I wonder if I just created a module which reexported all the stuff we wanted from various modules...
23:47:09 <Cale> Can things be re-exported qualified?
23:47:19 <int-e> nope
23:47:23 <Cale> right.
23:47:28 <Cale> grr.
23:49:03 <Saizan> uhuh, the new hint seems like it would solve the problem about imports
23:49:12 <Cale> New hint?
23:49:47 <Cale> Where do I get that?
23:49:48 <Saizan> mueval uses hint, and the 0.2.5 version (only in darcs) allow you to set a toplevel module
23:49:54 <Cale> aha
23:50:03 <Cale> Where is the darcs repo?
23:50:22 <Saizan> darcs get http://www.glyc.dc.uba.ar/daniel/repos/hint
23:50:30 <lambdabot> Title: Index of /daniel/repos/hint
23:50:55 <Saizan> see examples/example.hs
23:52:01 <int-e> > toConstr (Left 1)
23:52:02 <lambdabot>   Add a type signature
23:52:07 <Cale> --   Modules must be interpreted to use this function.
23:52:07 <Cale> setTopLevelModules :: [ModuleName] -> Interpreter ()
23:52:10 <int-e> > toConstr (Left (1 :: Int))
23:52:11 <lambdabot>   Add a type signature
23:52:20 <Stinger> bleh, js needs list comprehensions
23:53:00 <int-e> > toConstr (Left 1 :: Either Int Int)
23:53:01 <lambdabot>   /tmp/5364377600182283110:5:38: Not in scope: `toConstr'
23:53:11 <mauke> s/list comprehensions/sanity/
23:53:22 <int-e> this is interesting. it parses the expression in a different context than it gets executed in.
23:53:28 <Saizan> Cale: yeah, so setTopLevelModules ["L"] should give the right scope
23:53:41 <Cale> Saizan: L is an object file though.
23:53:53 <Cale> (lambdabot compiles it...)
23:54:08 <Saizan> yeah, but it throws it away, currently :)
23:54:09 <Cale> Maybe it'll work anyway?
23:55:25 <Saizan> runplugs linked against L.o, mueval just reinterprets L.hs via hint, afaiu
23:55:31 <nha_> does anyone know if theres a performance penalty in hopengl for using haskell loop constructs to do callList multiple times instead of passing the C array of indices for the multi display version
23:55:45 <Baughn> nha_: There is
23:55:53 <Cale> Saizan: hmm, but it's already calling setTopLevelModules
23:56:03 <Baughn> nha_: There's always /some/ FFI overhead, sorry
23:56:05 <Cale> Saizan: Was that fixed in the latest version or something?
23:56:27 <nha_> well i was more interested if opengl does something different with the array version
23:56:28 <Cale> @undefine
23:56:32 <Baughn> nha_: (That said, it should be some unnoticably tiny percentage of the time taken by the actual opengl call)
23:56:35 <Cale> > sort [1,3,2]
23:56:36 <lambdabot>   /tmp/1399092882366882507:5:46: Not in scope: `sort'
23:56:38 <Cale> hmm
23:56:43 <nha_> like if it just sends it directly to the driver or if preprocesses it into displayList calls
23:56:51 <Baughn> nha_: drawElements, etc.?
23:57:14 <Baughn> nha_: Yeah, it can send those directly to the card. They're, by and large, far more efficient than display lists
23:57:14 <nha_> callList vs callLists for opengl DisplayLists
23:57:20 <Baughn> Oh..
23:57:27 <nha_> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-DisplayLists.html#t%3ADisplayList
23:57:29 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.DisplayLists, http://tinyurl.com/278rxm
23:57:29 <Baughn> Well, callLists should be more efficient too, but only slightly. :P
23:58:07 <Baughn> nha_: If you /really/ want better performance, use a STATIC_DRAW VBO or two
23:58:16 <hackage> Uploaded to hackage: haskore 0.0.5.1
23:58:35 <nha_> hmm ok thanks
23:58:57 <Saizan> Cale: oh, sorry, i misread the comments in example.hs, the only new feature are qualified imports
23:59:14 <Cale> I don't understand why this isn't working.
23:59:37 <Cale> I can see that lambdabot is passing L.hs to mueval as a -l parameter
