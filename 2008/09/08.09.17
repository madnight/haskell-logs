00:02:04 <dons> what's the problem?
00:02:35 <bluejay|T61> Can anyone pose me a easy Haskell problem for a beginner like me? :)
00:02:58 <bluejay|T61> Something like "Build a Conway Series with a single line of code!"
00:03:11 <Pseudonym> bluejay: Why not start on Project Euler?
00:03:25 <cpfr> do i really need to pass in the language definition to parse some parenthesis
00:03:27 <glguy> @seen dons
00:03:28 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 1m 23s ago.
00:04:55 <bluejay|T61> Pseudonym// Bah, I easily get tempted to resort to Python or C when I work on Project Euler problems >_<
00:05:09 <mmorrow> cpfr: you could always do the parens by hand (if that's all you're parsing), but if not just use whichever lang def is closest to what you want, then change that template as you see fit
00:05:12 <Nafai> bluejay|T61: I second the recommendation for Project Euler.  I've used that and it was a great way for me to focus on the basics of Haskell
00:05:32 <thetallguy> Is there a wiki page on how to write Haskell documentation?
00:05:34 <bluejay|T61> I see. Thanks for advises guys
00:05:42 <mmorrow> thetallguy: the haddock docs :)
00:05:53 <bluejay|T61> advices*
00:06:03 <thetallguy> I mean, a style guide.
00:06:11 <mmorrow> http://www.haskell.org/haddock/doc/html/index.html
00:06:12 <lambdabot> Title: Haddock User Guide
00:06:13 <mmorrow> oh
00:06:16 <cpfr> mmorrow, its just whats in the parens isnt much
00:06:28 <thetallguy> I'd like to add a bit that says, never write anything like this: The first, of course,  is newPrompt, which should be straight forward enough.
00:07:16 * thetallguy stomps around looking for the author
00:07:47 <fatalerrorx> why does ghc have a binary for solaris 8 and 10 and not 9?
00:07:58 <fatalerrorx> seems strange
00:08:43 <dons> fatalerrorx: no one provided one.
00:08:51 <dons> glguy: yo
00:10:11 <fatalerrorx> dons: do you know if ghc builds with 6.4.1
00:10:21 <fatalerrorx> my admins can't get it to build
00:10:58 <dons> should do, yes.
00:11:10 <dons> all 6.x series should build later 6.x series.
00:11:18 <dons> you should have them talk to glasgow-haskell-users@
00:11:21 <fatalerrorx> ok
00:11:48 <fatalerrorx> i'm trying to build it myself currently
00:12:00 <fatalerrorx> i won't be able to do make install
00:12:11 <BeelsebobWork> fatalerrorx: is it not in IPS?
00:12:18 <fatalerrorx> IPS?
00:12:30 <BeelsebobWork> Image Packaging System -- Solaris' package manager
00:12:43 <fatalerrorx> how do i check?
00:13:40 * BeelsebobWork tries to remember
00:14:20 <BeelsebobWork> oh fail, my bad -- IPS is only available on OpenSolaris atm :(
00:16:43 <fatalerrorx> hehe
00:17:06 <fatalerrorx> so i stuck with ghc 6.4.1
00:17:18 <fatalerrorx> terrible
00:18:20 <BeelsebobWork> well, that or figure out why 6.8 won't build -- at least in the 6.x series i've found it reasonably easy to build ghc
00:18:34 <BeelsebobWork> but it may be more fun on solaris
00:18:39 <fatalerrorx> lol
00:18:54 <fatalerrorx> i have never built ghc from source
00:19:09 <fatalerrorx> it seems to be building fine atm
00:19:43 <BeelsebobWork> you have followed the destructions on the web page, right?  With the running sh boot and such things?
00:19:50 <fatalerrorx> yeah
00:21:07 <fatalerrorx> except i don't have root privs
00:22:12 <fatalerrorx> can't i use say ghc on windows to generate the solaris binary?
00:23:06 <BeelsebobWork> fraid not
00:23:15 <BeelsebobWork> I don't think any of the Haskell compilers support cross compiling atm
00:23:32 <fatalerrorx> :(
00:23:46 <BeelsebobWork> there's a fair number of people who want it though, so it may get added some time if we're very very lucky
00:23:55 <BeelsebobWork> lots of people wanting to run it on crazy things like iPhones
00:24:05 <fatalerrorx> how long does ghc build for?
00:24:13 <fatalerrorx> hours?
00:24:27 <BeelsebobWork> on my machine, about 20-30 minutes -- but that's a quad core xeon
00:24:27 <vegai> fourish
00:25:23 <luite_> lol I wonder how long ghc takes to build on an iphone :)
00:25:38 <BeelsebobWork> really quite a long time at a guess
00:25:44 <BeelsebobWork> it is a reasonably powerful machine though
00:25:55 <vegai> how much memory is on that thing?
00:25:59 <BeelsebobWork> 128MB
00:26:05 <BeelsebobWork> and a 400Mhz ARM
00:26:11 <vegai> hm, can it actually do it in 128MB?
00:26:14 <fatalerrorx> how do i check what this thing is running?
00:26:19 <BeelsebobWork> apparently so -- people have done it
00:26:20 <fatalerrorx> on solaris
00:26:27 <BeelsebobWork> ps -ax | grep
00:26:40 <BeelsebobWork> or do you mean using CPU?
00:26:43 <fatalerrorx> cpu
00:26:46 <BeelsebobWork> in which case top -ocpu
00:27:30 <fatalerrorx> i mean how do i find what hardware its running
00:28:26 <BeelsebobWork> oh, I see
00:28:31 <BeelsebobWork> good question
00:32:39 <mmorrow> cat /proc/cpuinfo
00:32:53 <tibbe> GHC is to smart, it optimized away all my code!
00:33:09 <fatalerrorx> cat: cannot open /proc/cpuinfo
00:33:18 <mmorrow> what are you on?
00:33:28 <fatalerrorx> spar solaris
00:33:29 <mmorrow> that was for linux
00:33:31 <mmorrow> ah
00:33:31 <fatalerrorx> sparc*
00:33:36 <mmorrow> i'm not sure then
00:34:28 <Baughn> @src Ordering
00:34:29 <lambdabot> data Ordering = LT | EQ | GT
00:34:35 <Baughn> @src Ord
00:34:36 <lambdabot> class  (Eq a) => Ord a  where
00:34:36 <lambdabot>     compare      :: a -> a -> Ordering
00:34:36 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
00:34:36 <lambdabot>     max, min         :: a -> a -> a
00:35:09 <mmorrow> . pp $(lift =<< reify ''Ord)
00:35:10 <lunabot>  class Eq a_0 => Ord a_0
00:35:10 <lunabot>      where compare :: forall a_0 . Ord a_0 => a_0 -> a_0 -> Ordering
00:35:10 <lunabot>            < :: forall a_0 . Ord a_0
00:36:07 <mmorrow> the th prettyprinter needs improving
00:36:32 <wman> fatalerrorx: brother google says http://www.lifeaftercoffee.com/2006/02/27/getting-hardware-information-in-solaris/    http://www.unixville.com/~moazam/stories/2004/05/17/newbieSysadminGuideToSolaris.html    (hope its as actual/dated as your system)
00:36:34 <lambdabot> Title: 11 Life After Coffee 65 » Getting Hardware Information in Solaris, http://tinyurl.com/6xumrs
00:36:37 <Baughn> > let c 8 1 = LT; c 1 8 = GT; c a b = compare a b in maximumBy c [1,8,2]
00:36:39 <lambdabot>   2
00:39:16 <fatalerrorx> wman: doesn't work :( but thanks
00:39:16 <tibbe> dons: so the naive thing doesn't work well at least
00:39:27 <tibbe> dons: lots and lots of core for wc -l
00:39:36 <Baughn> > let c 8 1 = LT; c 1 8 = GT; c a b = compare a b in maximumBy c [1,8,2,8,1]
00:39:37 <lambdabot>   1
00:39:48 <dons> tibbe: ok. stick it in an example somewhere.
00:40:02 <dons> getting the underlying fold primitive a precise as possible will be the key.
00:40:12 <dons> tibbe: i'll hack it on the bus to icfp. if not before.
00:40:20 * dons -> bed
00:40:29 <tibbe> dons: cool, gnight
00:40:47 <tibbe> dons: you can use the code on the repo as a base
00:40:55 <tibbe> dons: wcEnum is good
00:48:12 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''CC)
00:48:13 <lunabot>  newtype CC ans a = CC {unCC :: (CCT ans Identity a)}
00:48:23 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''CCT)
00:48:24 <lunabot>  newtype CCT ans m a = CCT {unCCT :: (Cont ans m a -> P ans m ans)}
00:48:32 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''Cont)
00:48:32 <lunabot>   Not in scope: type constructor or class `Cont'
00:48:36 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''P)
00:48:37 <lunabot>   Not in scope: type constructor or class `P'
00:48:52 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''[])
00:48:53 <lunabot>  data [] a = [] | a : ([] a)
00:49:03 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify '[])
00:49:04 <lunabot>  Constructor from []: [] :: forall a . [] a
00:49:20 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''(->))
00:49:21 <lunabot>      Can't find interface-file declaration for data constructor GHC.Base.Fals...
00:49:40 * mmorrow hates that error msg
00:50:17 * mmorrow notes to himself to open a ticket
00:50:22 <fatalerrorx> ../includes/GHCConstants.h:292:22: Not in scope: `zd'
00:50:22 <fatalerrorx> ../includes/GHCConstants.h:295:26: Not in scope: `zd'
00:50:22 <fatalerrorx> ../includes/GHCConstants.h:297:25: Not in scope: `zd'
00:50:22 <fatalerrorx> ../includes/GHCConstants.h:299:22: Not in scope: `zd'
00:50:22 <fatalerrorx> <<ghc: 31277288 bytes, 8 GCs, 1225330/2356132 avg/max bytes residency (2 samples), 17M in use, 0.00 INIT (0.00 elapsed), 0.13 MUT (0.78 elapsed), 0.07 GC (0.08 elapsed) :ghc>>
00:50:23 <lunabot>   parse error on input `in'
00:50:23 <lunabot>   parse error on input `in'
00:50:23 <lunabot>   parse error on input `in'
00:50:24 <lunabot>   parse error on input `in'
00:50:24 <fatalerrorx> make[1]: *** [stage1/main/Constants.o] Error 1
00:50:26 <fatalerrorx> make: *** [stage1] Error 1
00:50:41 <fatalerrorx> anyone know why this happens?
00:50:55 <mmorrow> preflex: hai
00:51:09 <mmorrow> that looks like a zencoding maybe?
00:51:35 <mmorrow> zd ==> $
00:51:47 <mmorrow> (un-zencoded)
00:52:00 <mmorrow> that's all i've got
00:52:08 <mmorrow> sleeeep
00:52:41 <fatalerrorx> hmm
00:52:48 <mmorrow> . (text . pprint . cleanNames') $(lift =<< reify ''Tree)
00:52:49 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
00:52:59 <fatalerrorx> i have no idea how to get this to build
00:53:06 <fatalerrorx> i'm giving up
00:53:22 <mmorrow> i've never built on solaris
00:53:44 <mmorrow> it's pretty smooth going on linux though
00:53:49 <fatalerrorx> i don't get why they can't just use linux
00:54:04 <mmorrow> sucky
00:54:05 <fatalerrorx> there is nothing about sparc processors
00:54:10 <fatalerrorx> special*
00:55:11 <fatalerrorx> ocaml builds fine
00:55:24 <fatalerrorx> why can't ghc
00:58:54 <mmorrow> probably because it doesn't matter enough to anyone that it does. but it seems to matter to you, so maybe when you get it built, contribute your binary/fixes and it'll build perfectly :)
00:59:19 <fatalerrorx> lol
00:59:23 <mmorrow> hehe
00:59:33 <fatalerrorx> i don't know how to fix it :)
00:59:54 <mmorrow> i hate that part.
01:00:00 <fatalerrorx> lol
01:01:03 <bluejay|T61> http://quark.me/ss/tamaki-1221638412.jpg <- maybe i have too many tabs open?
01:04:38 * BeelsebobWork doesn't understand how people get that many tabs open
01:05:48 <olsner> I've heard of people having somewhere around 2-500 tabs open... those people tend to find weird bugs in both browser and operating system :P
01:06:10 <mmorrow> bluejay|T61: add the system monitor realtime graphs to your gnome-panel. it'll change your life.
01:06:39 <mmorrow> also, geyes on the panel is a nice touch as well imho ;)
01:06:51 <olsner> the binary-trees benchmark needs a parMapReduceRange
01:07:15 <BeelsebobWork> olsner: are you looking at the one currently submitted?
01:07:34 <olsner> Beelsebob: yes
01:07:50 <bluejay|T61> mmorrow// haha x_x
01:08:01 <BeelsebobWork> olsner: in that case, dons and I already put together a parallel one -- you might want to look at that on the shootout page in the hawiki
01:08:10 <BeelsebobWork> if you can improve it'd be much appreciated
01:08:26 <BeelsebobWork> (we expect to get down to 13 seconds instead of 45 with the one we put together)
01:09:10 <olsner> the simple parMap one doesn't seem to do anything at all in parallel on either the shootout or on my computer
01:09:25 <BeelsebobWork> you need parMap *and* give it -A350
01:09:30 <BeelsebobWork> otherwise the garbage collector kills it
01:09:41 <BeelsebobWork> -A350M
01:09:55 <olsner> aha, the RTS flags would need tuning on the shootout as well
01:10:31 <BeelsebobWork> the parMap one hasn't been scored on the shootout
01:10:43 <BeelsebobWork> only submitted
01:12:06 <BeelsebobWork> interesting
01:12:12 <BeelsebobWork> the old mandelbrot gives bad output
01:12:17 <BeelsebobWork> that suggests my new one may actually be correct
01:12:22 <olsner> http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ghc&id=2
01:12:24 <lambdabot> Title: binary-trees Haskell GHC #2 program | x64 Ubuntu : Intel® Q6600® quad-core Com ..., http://tinyurl.com/5ag9be
01:12:44 <BeelsebobWork> oh, yeh, they have done it
01:12:49 <BeelsebobWork> yeh, it needs a -A350 to work well
01:13:12 <olsner> I think you need to remove -qm and -qw as well
01:14:53 <olsner> with those options and -A350M it still doesn't parallelize
01:14:55 <olsner> (for me)
01:16:15 <BeelsebobWork> odd
01:16:24 <BeelsebobWork> it parallelised for both me and dons
01:16:35 <BeelsebobWork> we were both seeing about 300% CPU usage on quad core machines
01:17:35 <olsner> seems -qm "Don't automatically migrate threads between CPUs" is the culprit for me
01:17:52 <BeelsebobWork> could well be
01:19:05 <BeelsebobWork> this is what I see happening... http://hpaste.org/10444
01:19:22 <BeelsebobWork> (-H300 needed on mac because -A seems to be buggy)
01:21:17 <BeelsebobWork> are you able to roughly duplicate that? or is there something odd going on?
01:21:53 <olsner> yeah, I can duplicate that reliably using -A350M or -H300M
01:22:09 <BeelsebobWork> cool :)
01:22:14 <BeelsebobWork> is your one faster still?
01:22:21 <olsner> but adding -qm (like the shootout does) breaks it :P
01:22:33 <BeelsebobWork> that must be it then
01:22:42 <BeelsebobWork> I guess it needs to shuffle some of the smaller trees around between CPUs
01:24:03 <BeelsebobWork> yeh, I see roughly the same speedup that the shootout does with -qm i.e. 26s -> 15s, but down to 6s without it
01:24:52 <BeelsebobWork> so is your version with parMapReduceRange faster still?
01:25:04 <olsner> I might attempt a parMapReduce thingy after work and see how that works out, the rest was just workarounds for using the wrong options
01:26:00 <BeelsebobWork> I wanna poke dons now, but he went to bed
01:26:06 <olsner> that should be able to divide the work evenly between cpus
01:26:07 <BeelsebobWork> it looks like my mandelbrot program is actually correct
01:26:19 <BeelsebobWork> he held of submitting it because it gave slightly different output to the old one
01:26:29 <BeelsebobWork> but it appears that the old one is wrong according to the shootout
01:26:42 <olsner> off to work I am
01:29:00 <olsner> happy benching :)
01:29:36 <wman> take it easy, guys, you don't want to kill all the competitors at once ;-)) let them fry for a while ;-)
01:32:05 <bluejay|T61> http://wiki.quark.me/iroki/haskell <- a little haskell page on my wiki x_x
01:32:08 <lambdabot> Title: Haskell - いろキ
01:36:22 <Baughn> I've got nifty unicode symbols turned on in haskell-mode, but they don't show up when printing. Is there a way to fix this?
01:36:57 <quicksilver> the problem is, they're not really there (in the buffer)
01:37:00 <quicksilver> they're just a display hack.
01:37:08 <Baughn> I'd like a print hack, then
01:37:10 <quicksilver> I don't know if there is an equivalent printing hack :)
01:51:13 <fatalerrorx> omg this is a nightmare
01:51:38 <fatalerrorx> can't get ghc onto the machines and ruby dies after 600mb memory
01:51:48 <fatalerrorx> i'm fucked
01:53:18 <Cale> fatalerrorx: What's up?
01:53:23 <Vq^> fatalerrorx: what are you trying to do?
01:53:25 <Cale> fatalerrorx: What kind of machines are they?
01:53:33 <fatalerrorx> solaris
01:53:38 <fatalerrorx> 9
01:53:43 <Vq^> fatalerrorx: what kind of program are you constructing?
01:53:57 <fatalerrorx> text categorisation
01:54:18 <fatalerrorx> its my uni assingment
01:54:46 <fatalerrorx> i asked the admins for ghc but they couldn't put it on
01:54:56 <fatalerrorx> :(
01:55:04 <bluejay|T61> [Screenshot] http://quark.me/ss/tamaki-1221641701.jpg
01:55:06 <Vq^> fatalerrorx: and it has to run on that solarisbox?
01:55:12 <fatalerrorx> yeah
01:55:16 <Baughn> fatalerrorx: You can't compile your own?
01:55:21 <Baughn> Or download your own?
01:55:24 <bluejay|T61> oops
01:55:31 <fatalerrorx> Baughn: no ghc for solaris 9
01:55:40 <bluejay|T61> [Screenshot] http://quark.me/ss/tamaki-1221641736.jpg
01:55:42 <Baughn> fatalerrorx: That would be an issue for the admins too, then.
01:55:59 <fatalerrorx> Baughn: yeah
01:55:59 <dibblego> bluejay|T61, what are you doing?
01:56:13 <Cale> Oh, that's interesting. The binaries available claim to work for 8 and 10
01:56:13 <bluejay|T61> dibblego// i just love that one line of code so much x_x
01:56:26 <fatalerrorx> Cale: ya but not 9 :(
01:56:28 <bluejay|T61> i wanted to show it to others in this channel x_x
01:56:48 <bluejay|T61> iterate (concatMap (\x -> [intToDigit (length x), (head x)]) . group) "1"   <- this code
01:57:15 * fatalerrorx goes it for some fresh air
01:57:16 <Cale> bluejay|T61: Have enough tabs open in your browser? ;)
01:57:24 * fatalerrorx out* :)
01:57:43 <bluejay|T61> lol opening up my browser is scary
01:57:47 <bluejay|T61> it lags my system haha
01:57:51 <Baughn> How would you render a function called "CBCIDEA" (all acronym) as a haskell function name?
01:57:56 <Vq^> fatalerrorx: only cc(1) left then :P
01:58:14 <Cale> Baughn: If that's an acronym, probably lowercase the whole thing?
01:58:35 * Vq^ agrees with Cale
01:58:49 <Cale> Or come up with another name ;)
01:58:57 <osfameron> not _CBCIDEA? ;-)
01:59:17 <Cale> I've seen people do cBCIDEA, but that's pretty ugly.
01:59:27 <osfameron> if it's an implementation of a foreign naming convention (say, spreadsheet functions), then it might be useful to have it visibly distinct ?
02:00:03 <osfameron> _'CBCIDEA'
02:00:11 <osfameron> the scare quotes show appropriate contempt for the name
02:00:47 <Cale> hehe
02:03:56 <bluejay|T61> my first code in haskell: [1...]
02:04:02 <bluejay|T61> and i had to press Ctrl+C immediately
02:04:12 <Axman6> [1...]?
02:04:20 <bluejay|T61> yeah haha
02:04:27 <dibblego> [1..]
02:04:28 <Axman6> not [1..]? :)
02:04:33 <bluejay|T61> ooh oops
02:04:35 <bluejay|T61> x_x
02:05:18 <bluejay|T61> anyhow! my first actual meaningful code: fibs = 1:1:[x| x<- zipWith (+) fibs (tail fibs)]
02:05:20 <Cale> > [1..]
02:05:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:05:25 <bluejay|T61> amazing haskell
02:05:30 <Cale> :)
02:05:33 <bluejay|T61> you can "define" fibonacci sequence!
02:05:38 <Cale> yep :)
02:05:55 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
02:05:56 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:06:06 <bluejay|T61> what does nubBy do?
02:06:22 <bluejay|T61> omg, Cale
02:06:22 <Cale> Removes duplicates according to some comparison function
02:06:35 <bluejay|T61> you just wrote a code that i was going to work on
02:06:36 <bluejay|T61> :(
02:06:58 <Cale> There are lots of ways to get the sequence of primes. Perhaps try for another way :)
02:07:05 <BeelsebobWork> Cale: oh... that's a rather lovely implementation
02:07:14 <Cale> (the code I wrote is short, but not very fast)
02:07:18 <Axman6> bluejay|T61: fibs = 1:1:zipWith (+) fibs (tail fibs) is cleaner
02:07:30 <bluejay|T61> Axman6// oh that reminds me of a question
02:07:38 <bluejay|T61> What does : exactly do?
02:07:48 <bluejay|T61> i don't get why i get an error when i do something like       list = 1:1
02:07:56 <Cale> bluejay|T61: 1 isn't a list
02:08:02 <bluejay|T61> i thought they simply concatenated elements
02:08:02 <Wild_Cat> :t (:)
02:08:03 <lambdabot> forall a. a -> [a] -> [a]
02:08:04 <bluejay|T61> in to single list
02:08:05 <Axman6> conses it... and i've forgotten what cons means, ha. construct? hmm
02:08:17 <Cale> bluejay|T61: : takes an element and a list, and prepends the element onto the front of the list
02:08:25 <bluejay|T61> oh...
02:08:36 <Axman6> bluejay|T61: 1:2:3:[] == [1,2,3] == 1:[2,3]
02:08:38 <bluejay|T61> so it's kind of opposite of (x:xs)
02:08:42 <BeelsebobWork> bluejay|T61: if you want a list to start off with, you want []
02:08:51 <BeelsebobWork> so the list with 1 and 1 in is 1:1:[]
02:08:51 <bluejay|T61> i see
02:09:01 <Cale> bluejay|T61: you mean... opposite of pattern matching against it?
02:09:05 <pao> can anyone sugget a more idiomatic solution for http://hpaste.org/10445?
02:09:18 <Baughn> Yay. Finally found a use for scanr.
02:09:21 <bluejay|T61> Cale// yeah
02:09:38 <BeelsebobWork> pao: I'm not seeing what it's trying to do?
02:10:03 <pao> BeelsebobWork: it's the Damerau-Levenshtein algo
02:10:07 <pao> @google Damerau
02:10:08 <osfameron> edit distance?
02:10:09 <lambdabot> http://en.wikipedia.org/wiki/Damerau-Levenshtein_distance
02:10:41 <pao> osfameron: yep, but it takes into account transposition
02:11:15 <quicksilver> pao: well you could make it look a bit nicer with guards
02:11:16 <Axman6> bluejay|T61: (x:xs) is just pattern matching for somthing at the head of a list, and the tail of the list
02:11:41 <osfameron> I'd not heard of Damerau, there's a similar algo coded as Text::Levenshtein in Perl
02:11:48 <pao> quicksilver: that's what is suspected... but how? :-)
02:12:11 <bluejay|T61> yeah, but i somehow felt it's opposite of : in that (x:xs) "breaks up" in a sense
02:12:18 <bluejay|T61> and : ties them back together
02:12:35 <Axman6> not really
02:12:37 <bluejay|T61> haha i don't know, that was just a random newbie remark
02:12:39 <pao> osfameron: Damerau can be seen as an extension of Levenshtein
02:13:25 <pao> quicksilver: it's mainly a "style" exercise... :-)
02:13:54 <Cale> pao: http://hpaste.org/10445#a1
02:13:56 <Cale> ?
02:13:57 <Baughn> @pl \plain lastCrypt -> crypter' (zipWith xor plain lastCrypt)
02:13:58 <lambdabot> (crypter' .) . zipWith xor
02:14:46 <pao> Cale: great
02:14:53 <pao> Cale: thanks a lot
02:14:58 <Cale> No problem :)
02:15:59 <Axman6> i don't get how (f .).g works. how is that different to f.g?
02:16:14 <aempirei> oi
02:16:17 <BeelsebobWork> Axman6: think about how (f.) is different to f
02:16:21 <Axman6> > (f .).g x
02:16:23 <lambdabot>       Overlapping instances for Show (a1 -> a -> c)
02:16:23 <lambdabot>        arising from a use...
02:16:26 <BeelsebobWork> @t (f .)
02:16:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:16:28 <Axman6> > (f .) . g x
02:16:29 <lambdabot>       Overlapping instances for Show (a1 -> a -> c)
02:16:29 <lambdabot>        arising from a use...
02:16:32 <Cale> heh
02:16:41 <quicksilver> pao: hmm. mine came out much the same as cale's
02:16:43 <Axman6> :t (f .)
02:16:44 <lambdabot> forall b c a. (SimpleReflect.FromExpr c, Show b) => (a -> b) -> a -> c
02:16:50 <BeelsebobWork> Axman6: f is the function that does "f" to things
02:16:54 <quicksilver> pao: http://hpaste.org/10445#a2
02:16:59 <BeelsebobWork> (f .) is the function that does "f" *after* things
02:17:05 <aempirei> is there some library that takes and Integer and packs for me
02:17:11 <Axman6> got an example? :\
02:17:12 <aempirei> iunto like 32bit vals or 16 bit bvals
02:17:22 <aempirei> kinda like i guess [Char] or (Char,Char,Char,Char)
02:17:32 <aempirei> for likepacking network structs and stuff
02:17:33 <pao> quicksilver: thanks to you too
02:17:38 <quicksilver> Axman6: sure.
02:17:41 <aempirei> or something similar to perl pack()
02:17:43 <quicksilver> > reverse "hello"
02:17:44 <lambdabot>   "olleh"
02:17:58 <quicksilver> > (("foo"++).) . reverse  $ "hello"
02:17:59 <lambdabot>   Couldn't match expected type `a -> [Char]'
02:18:04 <Cale> > (((*2) .) . (+)) 3 5
02:18:05 <lambdabot>   16
02:18:13 <Baughn> @src scanr
02:18:13 <lambdabot> scanr _ q0 []     =  [q0]
02:18:13 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
02:18:13 <lambdabot>     where qs@(q:_) = scanr f q0 xs
02:18:16 <quicksilver> > (("foo"++).) reverse "hello"
02:18:17 <lambdabot>   "fooolleh"
02:18:17 <pao> try to compare that with pseudo code in wikipedia article... it's amazing...
02:18:45 <Cale> > (3 + 5) * 2
02:18:48 <lambdabot>   16
02:18:54 <Axman6> quicksilver: and (f .) .g?
02:19:00 <bluejay|T61> i have absolutely no idea how (((*2).).(+)) 3 5 returns 16
02:19:02 <bluejay|T61> D:
02:19:19 <BeelsebobWork> Axman6: in general ((unaryFunction .) . binaryFunction) arg1 arg2 is a useful pattern
02:19:24 <Cale> It's possibly easiest to see what's going on if we apply it to some arguments by hand
02:19:29 <BeelsebobWork> meaning apply binaryFunction to arg1 and arg2
02:19:30 <Axman6> ah, i see
02:19:36 <BeelsebobWork> and then push the result into unaryFunction
02:20:17 <Cale> ((f .) . g) x y = ((f .) (g x)) y = (f . (g x)) y = f (g x y)
02:20:18 <Axman6> so that'd be the same as unartFunc (binaryFunc arg1 arg2)?
02:20:35 <Cale> See how that works?
02:20:42 <BeelsebobWork> Axman6: exactly -- as Cale just proved to you
02:20:42 <Axman6> kind of...
02:21:02 <Cale> Make sure you follow each of the steps in my proof. :)
02:21:06 <Axman6> ok, that's not so hard
02:21:40 <BeelsebobWork> and you already know when (f . (g .)) is useful
02:21:41 <bluejay|T61> Cale// can you explain this step  ((f .) (g x)) y = (f . (g x)) y  for me?
02:21:46 <BeelsebobWork> because you've already been writing that one lots
02:21:49 <Cale> sure
02:21:50 <Axman6> @unpl (f .) . g
02:21:50 <lambdabot> (\ d i -> f (g d i))
02:21:54 <BeelsebobWork> because (.) is right associative
02:21:58 <Cale> bluejay|T61: (f .) is an operator section
02:21:59 <bluejay|T61> i don't understand how parenthesis gets removed like that
02:22:00 <Axman6> see, why didn't someone say that? :P
02:22:10 <BeelsebobWork> Axman6: say what?
02:22:19 <Cale> bluejay|T61: When applied to a function h, it gives (f . h)
02:22:23 <Axman6> the unpl thing makes it pretty clear
02:22:28 <BeelsebobWork> heh
02:22:36 <BeelsebobWork> Axman6: in general it's useful to think of (.) as a unary function
02:22:48 <BeelsebobWork> that takes one argument, and does it after things
02:22:49 <bluejay|T61> Cale// yeah i get that part
02:23:04 <bluejay|T61> just like compound function in math x_x
02:23:10 <Cale> Actually, (.) is an associative operator, so it doesn't matter so much that it's right associative :)
02:23:15 <Axman6> BeelsebobWork: like a bash pipe, but backwards? (in syntax)
02:23:22 <Cale> Axman6: yes
02:23:24 <BeelsebobWork> Axman6: indeed
02:23:25 <Axman6> f|g == g.f
02:23:30 <Axman6> huzzar
02:23:37 <Baughn> > scanr f 0 [1..4]
02:23:38 <lambdabot>   Add a type signature
02:23:42 <Baughn> > scanr f 0 [1..4] :: [Expr]
02:23:43 <lambdabot>   [f 1 (f 2 (f 3 (f 4 0))),f 2 (f 3 (f 4 0)),f 3 (f 4 0),f 4 0,0]
02:23:53 <Baughn> > scanl f 0 [1..4] :: [Expr]
02:23:54 <lambdabot>   [0,f 0 1,f (f 0 1) 2,f (f (f 0 1) 2) 3,f (f (f (f 0 1) 2) 3) 4]
02:23:59 <Cale> and just like bash will run the program g before it runs the program f, so will haskell apply the function g before it applies f
02:24:16 <Cale> (Interestingly enough)
02:24:19 <BeelsebobWork> (but not necessarily run it first because of lazyness)
02:24:23 <Cale> g will be applied to (f x)
02:24:26 <Axman6> @unpl (f .(g .))
02:24:26 <lambdabot> (\ d -> f (\ i -> g (d i)))
02:24:47 <Axman6> uh.. hm
02:25:01 <bluejay|T61> oh Cale, sorry i meant to ask you this step: (f . (g x)) y = f (g x y)
02:25:05 <bluejay|T61> not the one before
02:25:12 <Cale> BeelsebobWork: (I was just pointing out that under lazy evaluation, the order that the functions get evaluated is the same as the order which bash would execute the programs)
02:25:25 <Axman6> @src (.)
02:25:25 <lambdabot> (f . g) x = f (g x)
02:25:31 <BeelsebobWork> Cale: uh? no?
02:25:32 <Cale> bluejay|T61: Ah, that's using the definition of (.)
02:25:37 <Axman6> bluejay|T61: ^^ if you haven't seen it yet
02:25:45 <bluejay|T61> isn't  (f . (g x) ) y =  ( f ( g x) ) y ?
02:25:50 <BeelsebobWork> Cale: just writing them with (.) doesn't magically make one get evluated before the other
02:26:03 <Axman6> bluejay|T61: no
02:26:20 <Cale> BeelsebobWork: Under lazy evaluation, the left parameter to (.) will always be evaluated first.
02:26:28 <Axman6> since (g x) is like an argument to f
02:26:38 <BeelsebobWork> Cale: oh, I see
02:26:39 <BeelsebobWork> yes
02:26:47 <bluejay|T61> Axman6// yeah (g x) is an argument to f
02:26:52 <Axman6> it's like map (g x) [1..]
02:27:01 <bluejay|T61> so   f ( g x ) instead of f (g x y )
02:27:09 <Cale> bluejay|T61: uh...
02:27:24 <Cale> bluejay|T61: But the functions we're composing in the particular example here are not f and g
02:27:32 <Cale> bluejay|T61: they're f and (g x)
02:27:41 <Axman6> bluejay|T61: and in f (g x) y, y is an argument to f, not g
02:28:01 <BeelsebobWork> bluejay|T61: look at the definition of (.) -- (.) f g x = f (g x) -- this means that (.) f (g x) y = f ((g x) y)
02:28:24 <BeelsebobWork> and then you can dispose of the parens inside
02:28:28 <BeelsebobWork> and get to f (g x y)
02:28:35 <bluejay|T61> where can i see that definition, BeelsebobWork ?
02:28:41 <BeelsebobWork> @src (.)
02:28:41 <lambdabot> (f . g) x = f (g x)
02:28:42 <Cale> Because whenever you have f x y z, what it really means is ((f x) y) z
02:28:44 <Axman6> @src (.)
02:28:44 <lambdabot> (f . g) x = f (g x)
02:28:55 <Axman6> damn it BeelsebobWork! quitit!
02:29:00 <BeelsebobWork> hahahahahaha
02:29:07 * Cale goes to play Spore under wine :)
02:29:34 <fatalerrorx> 10,800,000 how much mem should 10.8 million words take up?
02:29:54 <BeelsebobWork> fatalerrorx: depends on the architecture
02:30:06 <Axman6> fatalerrorx: depends what you meean by words...
02:30:16 <BeelsebobWork> but on x86, 43.2MB
02:30:17 <fatalerrorx> lets say 10 char each
02:30:20 <BeelsebobWork> assuming it's packed well
02:30:30 <BeelsebobWork> (IIRC a word on x86 is 32 bit)
02:30:32 <Axman6> heh, had a feeling you didn't mean binary words
02:30:37 <fatalerrorx> well ruby it needs over 600mb mem
02:30:41 <Axman6> BeelsebobWork: wrong words :P
02:30:48 <BeelsebobWork> Axman6: yeh, I was just getting that
02:30:49 <fatalerrorx> then dies
02:31:14 <Axman6> > 1.08*10^11
02:31:15 <lambdabot>   1.08e11
02:31:22 <Axman6> rawr, ha
02:31:23 <Stinger_> haha
02:31:28 <Axman6> anyway, that many bytes :P
02:31:44 <Axman6> > 1.08*10^11 / 1024
02:31:45 <lambdabot>   1.0546875e8
02:31:47 <BeelsebobWork> I'd go with 8 bits per char... in a string that means 8 bits for the char and 32 bits for a pointer, so 50 bytes per word
02:31:54 <Axman6> > 1.08*10^11 / 1024 /1024
02:31:56 <lambdabot>   102996.826171875
02:31:59 <BeelsebobWork> so you're looking at ~ 540MB
02:32:05 <Axman6> > 1.08*10^11 / $ 1024*1024
02:32:06 <lambdabot>   mueval: Prelude.read: no parse
02:32:12 <Axman6> > 1.08*10^11 /  1024*1024
02:32:13 <fatalerrorx> oh crikey
02:32:13 <lambdabot>   1.08e11
02:32:16 <plutonas> handleReductions x:xs = ((subRegex (mkRegex "*") (unwords (fst x)) "(.*)"),
02:32:16 <plutonas>                          (subRegex (mkRegex "*") (unwords (snd x)) "\\1")):
02:32:16 <plutonas>                         (handleReductions xs) <-- why do i get parse error in this function?
02:32:17 <fatalerrorx> thats heaps
02:32:22 <BeelsebobWork> fatalerrorx: this is why packed strings are useful
02:32:24 <fatalerrorx> i was blaming ruby
02:32:31 <Axman6> > 1.08*10^11 /  (1024*1024)
02:32:33 <lambdabot>   102996.826171875
02:32:42 <fatalerrorx> maybe i should comput things on the fly
02:32:43 <BeelsebobWork> fatalerrorx: oh, this is ruby, not Haskell?
02:32:47 <Axman6> hmmm
02:32:55 <bluejay|T61> reviewing myself..    ((f .) . g) x y = ( (f.) (g x) )y = (f . (g x) ) y = f ( (g x) y ) = f ( g x y )      ooh i got it :D
02:32:55 <fatalerrorx> i was gonna port to haskell
02:33:02 <BeelsebobWork> if it's ruby, then I would expect about 100MB, given that the strings should be stored as arrays
02:33:03 <Axman6> plutonas: not indented enought
02:33:05 <BeelsebobWork> not lists
02:33:22 <fatalerrorx> because i thought it ruby was just crap
02:33:27 <plutonas> Axman6: reeally? strange... how should it be indented?
02:33:29 <BeelsebobWork> well ruby is just crap fatalerrorx
02:33:33 <fatalerrorx> i guess its info overload
02:33:34 <bluejay|T61> just for clarification, is     ( f . . g)      same as       ( (f.) . g )     ?
02:33:44 <BeelsebobWork> fatalerrorx: look at ruby on the language shootout
02:33:44 <quicksilver> bluejay|T61: f . . g is an error
02:33:45 <Axman6> plutonas: look up the off side rule
02:33:47 <fatalerrorx> overlode*
02:33:54 <quicksilver> Axman6: what are you talking about?
02:33:56 <bluejay|T61> quicksilver// oh really? how come?
02:34:02 <osfameron> BeelsebobWork: you're conflating ruby-the-language with ruby-the-vm
02:34:05 <Baughn> > tail $ scanl f 0 [1..5]
02:34:06 <lambdabot>   Add a type signature
02:34:10 <Baughn> > tail $ scanl f 0 [1..5] :: [Expr]
02:34:11 <fatalerrorx> BeelsebobWork: yeah buts its so nice to program in :)
02:34:11 <lambdabot>   [f 0 1,f (f 0 1) 2,f (f (f 0 1) 2) 3,f (f (f (f 0 1) 2) 3) 4,f (f (f (f (f ...
02:34:13 <osfameron> I think most people, including ruby programmers agree with the latter being crap
02:34:16 <quicksilver> Axman6: I see nothing wrong with the indentation plutonas pasted.
02:34:21 <BeelsebobWork> fatalerrorx: yeh, but Haskell's much nicer to program in
02:34:33 <Axman6> quicksilver: looks like it's a space too far left on the last line
02:34:37 <plutonas> Axman6: i know things should be indented, but i think i have it right
02:34:43 <quicksilver> Axman6: that doesn't matter
02:34:49 <quicksilver> Axman6: it's not a layout construct.
02:34:55 <fatalerrorx> BeelsebobWork: i can't use ghc cos solaris 9 don't support it
02:34:59 <Axman6> sure it is
02:35:04 <BeelsebobWork> fatalerrorx: fail
02:35:08 <Axman6> whatever a layout construct is...
02:35:09 <quicksilver> Axman6: No. It is not.
02:35:09 <BeelsebobWork> use yhc instead?
02:35:14 <BeelsebobWork> not that that'll make it fast
02:35:16 <fatalerrorx> hahaha
02:35:18 <plutonas> Axman6: even putting the last line more to the right it does yield the same error
02:35:26 <Axman6> ok
02:35:26 <plutonas> what have i done wrong?
02:35:32 <FordCortina> if I have multiple versions of a given library, how do I tell which version is loaded when I import something in a source file?
02:35:41 <FordCortina> is there a command in ghci?
02:36:05 <quicksilver> plutonas: you have not put brackets around (x:xs) on the LHS
02:36:15 <Axman6> @src scanl
02:36:16 <lambdabot> scanl f q ls = q : case ls of
02:36:16 <lambdabot>     []   -> []
02:36:16 <lambdabot>     x:xs -> scanl f (f q x) xs
02:36:18 <quicksilver> Axman6: layout only matters in layout constructs.
02:36:23 <quicksilver> Axman6: such as 'do' or 'case'
02:36:31 <plutonas> ooops thanks
02:36:31 <Axman6> ok
02:36:36 <quicksilver> a plain expression is not a layout construct and you can indent it all over the shop.
02:36:57 <Axman6> i've just had problems in the past with things like where statements
02:37:13 <Axman6> but that makes sense
02:38:08 <FordCortina> for instance.... the source file im looking at has "import Data.Binary"
02:38:19 <FordCortina> but when i load it in ghci
02:38:23 <quicksilver> the top-level is a layout construct, but only in the sense that things with a zero indent are new defintions
02:38:35 <FordCortina> and do :show packages
02:38:36 <quicksilver> as long as you indent by at least one space it's a continuation.
02:38:42 <FordCortina> binary is not displayed
02:38:45 <FordCortina> why?
02:39:09 <sjanssen> FordCortina: I believe it will only be displayed after you attempt to evaluate an expression using it
02:39:24 <plutonas> quicksilver: can there be another error in my function? running it gives [("*** Exception: user error (Text.Regex.Posix.String died: (ReturnCode 13,"repetition-operator operand invalid")) does this mean that recursion is wrong?
02:39:26 <quicksilver> FordCortina: generally, the latest version is loaded.
02:39:36 <quicksilver> plutonas: No. That's a regex error.
02:39:42 <quicksilver> plutonas: it's a bug in your regex, not your haskell.
02:39:44 <FordCortina> sjanssen: hmm that's what I feared
02:39:45 <plutonas> oh ok
02:40:04 <quicksilver> FordCortina: it will generally pull in the latest versions of all packages, as far as dependencies allow
02:40:25 <sjanssen> quicksilver: what do you mean about "as far as dependencies allow"?
02:41:09 <quicksilver> sjanssen: well if you pull in package foo-1.0 and foo-1.0 is compiled against bar-0.1, that will pull in bar-0.1 even if a newer bar is available, won't it?
02:41:26 <sjanssen> FordCortina: it will always pull in the version with the highest number that is not hidden
02:41:32 <quicksilver> ah, OK.
02:41:39 <sjanssen> quicksilver: no, GHC makes no attempt to do that
02:41:52 <sjanssen> cabal-install will try, though
02:42:20 <sjanssen> FordCortina: if a module is in several packages of different names, GHC will insist that you name specific packages
02:45:13 <FordCortina> so is there any way to work out which library versions GHC is using for the file im looking at?
02:47:11 <humasect> hello quicksilver , do you work on hopengl ?
02:47:49 <quicksilver> not on it, no.
02:47:51 <quicksilver> with it sometimes.
02:47:56 <humasect> ok
03:05:39 * Baughn gains a new appreciation for `using`
03:05:48 <Myoma> :t using
03:05:49 <lambdabot> forall a. a -> Strategy a -> a
03:05:55 <Myoma> oh yeah
03:06:14 <Baughn> Oh yes. Is there a common name for "`using` seqList rnf"?
03:09:04 <aempirei> http://www.twentygoto10.com/blog/2008/09/17/lol-haskell-sings/ - audio synthesizer in haskell 98
03:09:09 <lambdabot> Title: 20 GOTO 10 » Blog Archive » LOL, Haskell Sings
03:09:12 <plutonas> i have something i don't know how to do. i have a list with 11 2-tuples. also i have some element, i want in case this element matches a first element of a 2-tuple, to substitute it by the second element, and then use this to continue checking, until no 2-tuple matches. What would you propose me?
03:09:32 <plutonas> don't know if i explained it very well
03:09:48 <TGEN> good afternoon
03:10:17 <TGEN> quick question: is it possible to overload the multiplication operator/function (*) to work on a String and an Int?
03:10:25 <dobblego> plutonas, I think you want to map/filter, but I am unclear, perhaps you can give an example?
03:10:27 <humasect> instance Num String where
03:10:47 <Myoma> TGEN: Just import Prelude hiding ((*)) then you can use it how you like
03:10:53 <Axman6> hmm, i can't get HOpenGL working -_-http://pastebin.com/m6c37a449
03:11:10 <plutonas> dobblego: map wouldn't do because it changes the list
03:11:14 <pozic> TGEN: not with the (*) from the Num class.
03:11:20 <TGEN> Myoma: but that would make me lose the usual integer/float/etc multiplication functionality?
03:11:20 <plutonas> well not exactly but you see what i mean
03:11:21 <plutonas> example
03:11:25 <Axman6> :t (*)
03:11:27 <lambdabot> forall a. (Num a) => a -> a -> a
03:11:27 <Myoma> TGEN: yes
03:11:31 <humasect> Axman6: set display callback
03:11:36 <TGEN> hmm
03:11:40 <pozic> TGEN: you would need to write your own class NumTGEN a b
03:11:43 <humasect> Axman6: displayCallback $= return () <- will do it
03:11:43 <Axman6> humasect: hmm?
03:11:46 <dobblego> plutonas, I suspect you want that? "to substitute it by the second element"
03:12:01 <plutonas> if the list is [("can you *", "*"),("please *", "*")
03:12:02 <Axman6> what do i do with that?
03:12:04 <pozic> TGEN: that's not Haskell 98 anymore, however.
03:12:06 <TGEN> well, I guess just picking a different operator identifier is cleaner then
03:12:10 <Myoma> TGEN: You could use a different operator like × if you wanted to keep the * around
03:12:17 <plutonas> and then i have "can you please blah blah"
03:12:17 <TGEN> right
03:12:19 <humasect> Axman6: throw it in right before mainLoop
03:12:24 <plutonas> or better
03:12:25 <Axman6> ok, cheers
03:12:26 <TGEN> thanks for the quick reply folks :)
03:12:30 <plutonas> "please can you blah blah"
03:12:43 <plutonas> after the function runs i should have "blah blah"
03:12:47 <humasect> Axman6: ^_^
03:13:06 <plutonas> first it would remove can you, and then please
03:13:10 <pozic> TGEN: also, the readability of programs is inversely proportional to the amount of overloading in your program.
03:13:15 <plutonas> i know how to do the substitution already have code for that
03:13:26 <plutonas> but don't know how to go through the list, pick the intermediate result
03:13:28 <Axman6> oh whoot, it's working on OS X. used to need to use X11
03:13:32 <Axman6> thanks a lot humasect :)
03:13:33 <plutonas> until there's nothing more to change
03:13:44 <humasect> Axman6: you're welcome, no problem +)
03:13:53 <Axman6> what does that line do btw?
03:13:54 <humasect> so , why not instance Num String then, guys ?
03:14:05 <Axman6> since, i am doing a tutorial... would be helpful to know ;)
03:14:18 <plutonas> dobblego: was the example good? :)
03:14:22 <Baughn> @pl concat (map f foo)
03:14:23 <lambdabot> f =<< foo
03:14:31 <Baughn> ...no.
03:14:32 <lunabot>   parse error on input `..'
03:14:42 <humasect> Axman6: that is where you would do all the GL calls. glut will call the display callback whenever the window is dirtied by window system or GLUT.postRedisplay <window> is called
03:14:45 <plutonas> Baughn: was that for me?
03:14:46 <pozic> humasect: are you referring to muliplying a String with e.g. an Int?
03:14:50 <Baughn> plutonas: No, for me
03:14:53 <plutonas> ok
03:15:16 <humasect> pozic: i don't remember who wanted to add java-like operations to strings
03:15:18 <Axman6> humasect: ok, you've lost me. but i shall continue on for now
03:15:20 <Baughn> :t mappend
03:15:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
03:15:44 <pozic> humasect: you can multiply "1" and "2" if you write the Num instance for String.
03:16:02 <humasect> Axman6: ah my apologies, feel free to ask more
03:16:16 <Myoma> pozic: You can write a num instance such that "foo"*3 == "foofoofoo"
03:16:18 <Axman6> ok, thanks
03:16:37 <pozic> Myoma: yes, you can do that too.
03:16:38 <humasect> pozic: ah, i see. so .. instance Num (String,Int) why not?
03:16:56 <pozic> humasect: you can also do that.
03:17:00 <humasect> ok
03:17:07 <Myoma> pozic: So what's the issue?
03:17:36 <humasect> that (,) makes a better ($)
03:17:38 <pozic> Myoma: I don't understand your issues.
03:17:40 * humasect closes the window
03:18:11 <Myoma> pozic: excuse me?
03:18:16 <Axman6> humasect: well waddya know, that's basically the code in the next example, how handeh
03:18:29 <humasect> Axman6: hehe^_^
03:18:39 <quicksilver> Myoma: but you can't do "foo"*(3::Int) == "foofoofoo"
03:18:48 <quicksilver> (with the standard Num class)
03:18:55 <Myoma> quicksilver: I know that
03:19:20 <quicksilver> I imagined you did, but I felt it was good to point it out
03:19:32 <plutonas> anyone?
03:22:35 <nha__> @src map
03:22:35 <lambdabot> map _ []     = []
03:22:35 <lambdabot> map f (x:xs) = f x : map f xs
03:33:50 <BeelsebobWork> http://hpaste.org/10446 <-- anyone see where this is trying to make the inifinite type?
03:34:06 <plutonas> actually my problem is to go through the list until there is no more change (in one go through)
03:36:41 <Myoma> plutonas: Is it possible in one go?
03:36:54 <plutonas> Myoma: probably not
03:36:57 <Myoma> plutonas: What if you had "x" and rules that replace x with y and y with x
03:37:10 <plutonas> Myoma: no no, it's not the case
03:37:25 <plutonas> my rules will only remove stuff from a phrase, and maybe alter the order while removing
03:37:43 <Myoma> oh, if the string always gets shorter thats good news
03:38:01 <Myoma> what if you have "oxo" and a rule that removes "x" a rule that removes "oo" ?
03:38:06 <plutonas> but i'll have to have a clean go, without any alternation as an end condition (at least as i see it
03:38:23 <plutonas> it will be removed after 2 gos
03:38:25 <plutonas> go's
03:38:42 <plutonas> well i don't have this case here
03:38:44 <Myoma> ok so you could have, iterateProgress (remove "x" . remove "oo")
03:39:08 <Myoma> and you can of course construct (remove x . remove ...) from [x,y,..] using a function
03:39:21 <Saizan> BeelsebobWork: it looks like that error message is utterly unhelpful, since the variable 'a' doesn't appear in the type signatures
03:39:27 <Myoma> iterateProgress f x = let fx = f x in if fx == x then x else iterateProgress f fx
03:39:29 <BeelsebobWork> Saizan: indeed
03:39:30 <plutonas> Myoma: it's not exactly removing only
03:39:48 <Myoma> plutonas: Does that mean this approach can't be applied?
03:39:59 <plutonas> hm, the approach maybe yes
03:40:05 <plutonas> but need to understand iterateProgress
03:41:34 <plutonas> in which module is iterateProgress in?
03:41:44 <plutonas> or it what you defined?
03:41:50 <quicksilver> plutonas: it's in the module #haskell.Myome
03:41:54 <quicksilver> :P
03:41:58 <humasect> Beelsebob: uh, i get that randomly too.
03:54:12 <Axman6> hmm, in http://www.haskell.org/haskellwiki/OpenGLTutorial1, after adding the reshape function, nothing different happens. i'm wondering what was supposed to happen before adding that (i had tried resizing the window before and after)
03:54:26 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
03:56:53 <Myoma> :(
03:56:56 <Myoma> why the comma
03:57:12 <lilac> BeelsebobWork: can you paste the code?
03:57:36 * Axman6 pokes quicksilver since he seems to know somehting about HOpenGL
03:57:41 <Myoma> Is there any document that says what expect dates are for GHC?
03:57:47 <BeelsebobWork> lilac: http://hpaste.org/10447
03:57:58 <humasect> Axman6: whereabouts on the page ?
03:58:15 <Axman6> the last code snippet
03:58:35 <Baughn> @find mappend
03:58:36 <lambdabot> Not in scope: type variable `mappend'
03:58:40 <quicksilver> Axman6: the reshape callback is called when you resize your window
03:58:41 <humasect> ah, it just triggers GL to redisplay when window changes size. nothing special
03:58:42 <Baughn> @locate mappend
03:58:42 <lambdabot> Unknown command, try @list
03:58:43 <Myoma> @hoogle mappend
03:58:43 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
03:58:49 <Axman6> i get the same behaviour with and without the reshape method
03:59:02 <humasect> yep in OSX it is not really needed as much.
03:59:08 <Axman6> ah, excellent
03:59:15 <quicksilver> withut the reshape callback your viewport shouldn't adjust, shoudl it?
03:59:30 <humasect> eh it is cheap to calc vp in display anyway
03:59:32 <Axman6> quicksilver: it does
03:59:33 <quicksilver> the reshape callback should be needed to get the display automatically resizing to your window.
03:59:36 <quicksilver> odd.
04:00:22 * humasect shudders at "    vertex $ (Vertex3 ((-0.2)::GLfloat) (-0.2) 0)"
04:01:32 <Axman6> yeah, that did look a little odd to me too
04:02:00 <humasect> hopengl manages to make opengl more complicated
04:02:22 <quicksilver> I find hopengl makes it quite a bit simpler in some ways.
04:02:30 <quicksilver> but the typeclasses are a bit of a pain.
04:02:51 <humasect> yeah. i wonder why the whole thing could not have been reduced to types
04:03:03 <humasect> and have one IO fun
04:03:14 <humasect> well, one to get, one to set
04:03:59 <quicksilver> mind you the typeclasses only really intrude when you have lots and lots of constant numbers.
04:04:14 <humasect> anyway Axman6 do not worry much about it, if you have a wrapper for vertex, texture, and color calls, things are OK
04:04:15 <quicksilver> in real code I normally find I have at least one variable in there and that collapses the type ambiguity
04:04:25 <Myoma> humasect: Yeah I never realized that you could just define something to make  vertex3 (-0.2) (-0.2) 0  or whatever work
04:04:28 <Axman6> righto
04:05:21 <humasect> Myoma: hehe yeah. it is harder when one is starting to learn haskell at all beginning with a library such as hopengl ...
04:05:42 <humasect> quicksilver: oh ?
04:06:19 <humasect> ah, actually i think i know just what you mean
04:06:46 <quicksilver> if it's vertex $ Vertex3 (-0.2) (-0.2) r
04:06:46 <lilac> BeelsebobWork: data a :*: b = Prod (a, b) ?
04:07:01 <quicksilver> and r's type is constrained by (e.g) the top-level type sig of this function
04:07:03 <quicksilver> you're OK.
04:07:12 <humasect> GL calls are so ultra-simple that i just make a simple type wrapper so i have barely and IO calls at all except for entry, GLUT callbacks, and file handling
04:07:41 <BeelsebobWork> lilac: data (f :*: g) a = Prod {unProd :: (f a, g a)}
04:08:18 <humasect> ah, yep quicksilver . but that can make it a little too dynamic for some, it can of course thread beyond that top level (it is, after all, 'a' for data Vertex3)
04:09:20 <quicksilver> well most of the time your code (even if it is manually generated verts) looks more like the section 2 of that tut
04:09:20 <humasect> (glVertex can only be int, double, or float, in the spec.)
04:09:34 <quicksilver> I.e. a big mapM_ over a list
04:09:47 <quicksilver> and then you just need to give a type to the list, which is quite a natural thing to do anyway.
04:10:20 <humasect> mhm=) until the program then becomes more biological and less artificial. perhaps.
04:20:28 <viktator> hi, it would be very helpful if anyone could help me with this:
04:20:38 <viktator> Im trying to grasp the randomizer in Haskell
04:20:55 <viktator> what if i want to make a list of 50 random numbers
04:21:35 <quicksilver> "randoms" produces an infinite list
04:21:36 <Saizan> > take 50 (randomRs (0,100) (mkStdGen 42))
04:21:37 <lambdabot>   [25,87,93,25,28,30,4,74,51,36,62,79,55,81,36,93,83,39,67,7,87,59,36,55,54,3...
04:21:38 <viktator> Im trying to use the System.random library, stdgen and all that
04:21:41 <quicksilver> you could take the first 50 of those.
04:22:09 <quicksilver> do gen <- getStdGen; list <- take 50 (randoms gen)
04:22:44 <viktator> ok, thanks ill check that out
04:23:44 <ToRA> > runState (replicateM 50 (State $ randomR (0,100))) (mkStdGen 42)
04:23:45 <lambdabot>   ([25,87,93,25,28,30,4,74,51,36,62,79,55,81,36,93,83,39,67,7,87,59,36,55,54,...
04:24:08 <ToRA> also lets you keep the source of randomness at the end
04:24:26 <ziman> > snd $ runState (replicateM 50 (State $ randomR (0,100))) (mkStdGen 42)
04:24:27 <lambdabot>   1197738977 1474978066
04:24:46 <Myoma> @@ @run map ord @show @yow
04:24:46 <ziman> what's that space there?
04:24:47 <lambdabot>   [73,39,109,32,97,108,115,111,32,112,114,101,45,80,79,85,82,69,68,32,112,114...
04:24:48 <Myoma> @@ @run map ord @show @yow
04:24:50 <lambdabot>   [73,32,75,65,73,83,69,82,32,82,79,76,76,63,33,32,32,87,104,97,116,32,103,11...
04:25:15 <quicksilver> ziman: entirely arbitrary
04:25:21 <Myoma> ziman: the seed is two integers
04:25:21 <plutonas> finished finally!!!
04:25:22 <quicksilver> ziman: that's teh Show/Read format for StdGens
04:25:30 <quicksilver> it's a bit broken really
04:25:34 <ziman> quicksilver, oh, i see
04:25:38 <quicksilver> should me (MkStdGen 123 456)
04:25:41 <plutonas> what is the command to use ghc to compile the files? till now i load them in ghci only
04:25:48 <quicksilver> plutonas: ghc --make file.hs
04:25:48 <humasect> @src (++)
04:25:49 <lambdabot> []     ++ ys = ys
04:25:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:25:49 <lambdabot> -- OR
04:25:49 <lambdabot> xs ++ ys = foldr (:) ys xs
04:25:51 <ziman> a specific Show instance
04:26:14 <quicksilver> a misguided one.
04:26:15 <quicksilver> IMO.
04:26:27 <plutonas> quicksilver: thank you
04:26:34 <ToRA> > read "hello" :: StdGen
04:26:36 <lambdabot>   12802 1
04:27:15 <plutonas> quicksilver: and how is the executable named?
04:27:25 <plutonas> ok, got it
04:27:39 <Axman6> > foldr (:) [1,2,3] [4,5,6] :: Expr
04:27:40 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
04:27:52 <Axman6> > (foldr (:) [1,2,3] [4,5,6] ):: Expr
04:27:53 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
04:27:58 <Axman6> bleh
04:28:34 <humasect> so, a type can be faster/less expensive than lists themselves ?
04:29:18 <quicksilver> humasect: lists are not hte most efficient representation for everything.
04:29:23 <quicksilver> they're fine for certain things
04:29:24 <Myoma> > foldr (fun "(:)") (SimpleReflect.var "[1,2,3]") [4,5,6]
04:29:26 <lambdabot>   (:) 4 ((:) 5 ((:) 6 [1,2,3]))
04:29:31 <quicksilver> Sequences are better for random appends, say.
04:29:41 <humasect> ah, sequences you say? ok, interesting
04:29:49 <quicksilver> Data.Sequence, that is.
04:29:53 <humasect> yep, kk
04:31:12 <humasect> cool, looks neat, thanks
04:32:35 <retybok> is there a function, that given something, returns a representation of its type
04:32:43 <Myoma> :t typeRep
04:32:44 <lambdabot> Not in scope: `typeRep'
04:32:53 <Myoma> :k TypeRep
04:32:54 <lambdabot> *
04:33:02 <Myoma> @hoogle TypeRep
04:33:03 <lambdabot> Data.Typeable data TypeRep
04:33:03 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
04:33:03 <lambdabot> Data.Typeable typeRepKey :: TypeRep -> IO Int
04:33:16 <retybok> Myoma: thanks!
04:33:31 * shapr hugs Myoma
04:34:05 <quicksilver> retybok: 'typeOf'
04:34:10 <quicksilver> is the simplest answer
04:34:18 <quicksilver> (it relates to the stuff Myoma pasted)
04:38:15 <Baughn> @hoogle trace
04:38:15 <lambdabot> Debug.Trace trace :: String -> a -> a
04:38:15 <lambdabot> module Debug.Trace
04:38:15 <lambdabot> package traced
04:41:16 <humasect> :t (>>=)
04:41:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:41:24 <retybok> actually I'm trying to return a default value when "read" fails, but I can't manage to do it
04:41:35 <humasect> readIO or reads
04:41:56 <humasect> maybeRead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing }
04:42:12 <retybok> humasect: thanks!
04:42:17 <humasect> but that does not work in all cases, watch out
04:42:29 <retybok> humasect: so when doesn't it work?
04:42:34 <humasect> the easiest i am using is 'catch' with readIO
04:42:47 <humasect> lists
04:43:00 <retybok> ok, I'm just trying to read floats :)
04:43:03 <Saizan> lists?
04:43:20 <humasect> yep it fails if the string is a list itself (it is how it checks for "if it doesnt fail" for a list of chars.)
04:43:35 <humasect> let maybeRead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing }
04:43:41 <humasect> > let maybeRead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing }
04:43:43 <lambdabot>   mueval: Prelude.read: no parse
04:43:48 <humasect> oh, ok then=)
04:43:55 <Saizan> @let maybeRead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing }
04:43:58 <lambdabot>  Defined.
04:43:59 <humasect> ah, thanks
04:44:13 <humasect> > maybeRead "[4322,234,52,5,2,34234,6,62,435]" :: [Int]
04:44:14 <lambdabot>   Couldn't match expected type `[Int]'
04:44:28 <Myoma> > maybeRead "[4322,234,52,5,2,34234,6,62,435]" :: Maybe [Int]
04:44:29 <lambdabot>   Just [4322,234,52,5,2,34234,6,62,435]
04:44:40 <Saizan> it seems to work
04:44:41 <humasect> ah sorry i am half asleep whenever i am online.
04:45:07 <humasect> yep, i was getting Nothing when the readIO was passing, in this project
04:45:35 <humasect> i didn't look into it =(
04:46:14 <Sartak> :t reads
04:46:16 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:47:29 <humasect> it could even be because input had newlines, i do not know, but i trust the readIO method^_^
04:50:33 <Saizan> the holy church of readIO?
04:50:38 <Saizan> ?src read
04:50:39 <lambdabot> read s = either error id (readEither s)
04:50:44 <Saizan> ?src readEither
04:50:45 <lambdabot> Source not found.
04:51:52 <Saizan> however i guess readIO is accepting trailing whitespace, as in maybeRead s = case reads s of { [(x, rest)] | all isSpace rest -> Just x; _ -> Nothing }
04:52:13 <quicksilver> readIO is very icky :P
04:52:20 <humasect> | in case? =)
04:52:22 <quicksilver> humasect is a bad person for using it.
04:52:33 <humasect> i didn't feel bad until you tell me this. =)
04:53:05 <Saizan> humasect: yup, a guard
04:53:36 <humasect> oh..guard = smart pattern ?
04:54:52 <humasect> ok, neat, i am a bad person for not yet being familiar enough, but that i made real on my own. =) why is readIO icky, quicksilver ?
04:55:32 <Myoma> :t readIO
04:55:33 <lambdabot> forall a. (Read a) => String -> IO a
04:55:58 <Saizan> well yes, you can put a boolean expression after |, and if it evaluates to False than that pattern doesn't match
04:56:10 <Saizan> "then"
04:56:11 <humasect> ohh wow. =)
04:56:39 <quicksilver> humasect: because 'read'ing is a pure operation
04:56:42 <quicksilver> there is no need for it to be in IO
04:56:46 <Saizan> > let fac n | n <= 0 = 1; fac n = n * fac (n-1) in fac 5
04:56:47 <lambdabot>   120
04:57:04 <quicksilver> you might well want to parse in pure code with no IO nearby; and you should do so
04:57:19 <humasect> quicksilver: right. so it just throws exception, of course this is the ugly part. but that is also what it is entirely, too. it would have to not exist to be not doing what it is meant to do, right ?
04:57:26 <SamB_XP> it should be in Maybe or something though ...
04:57:36 <humasect> yep, that is when i use maybeRead
04:57:41 <hackage> Uploaded to hackage: heap 0.4.0
04:57:41 <hackage> Uploaded to hackage: AutoForms 0.4.2
04:57:45 <quicksilver> the maybeRead is much nicer thing.
04:57:52 <quicksilver> it's silly to use IO 'just for' exceptions.
04:58:05 <quicksilver> exception-handling behaviour exists in Maybe and Either, much more elegantly.
04:58:13 <humasect> yep, of course, quicksilver. so it should be removed, and maybeRead added to libraries in its place
04:58:33 <Myoma> humasect: easier said than done
04:58:48 <quicksilver> I doubt they'll remove readIO if it was in haskell98 (which I think it was)
04:58:57 <quicksilver> adding a readMaybe should definitely be done though.
04:59:18 <humasect> aha. hmm. how does mueval handle it ?
04:59:24 <humasect> > e 3 42kp 3p ++ 1][2 ;  >.,,
04:59:25 <lambdabot>   mueval: Prelude.read: no parse
04:59:31 <humasect> thread just dies ?
04:59:51 <Saizan> process just dies
04:59:56 <humasect> hehe
05:00:17 <Saizan> i still don't get where that read was used, however it's fixed in the darcs version
05:00:20 <Saizan> . 1
05:00:21 <lunabot>  1
05:00:49 <humasect> read is just a fancy case stmt
05:01:27 <quicksilver> everything in haskell is just a fancy case stmt
05:01:27 <humasect> how is list monad used ?
05:01:37 <humasect> > [1,23,4,5,2] >>= (\x-> [x,x+1])
05:01:39 <lambdabot>   [1,2,23,24,4,5,5,6,2,3]
05:01:47 <humasect> yeah=)
05:01:49 <profmakx> uhh
05:01:49 <quicksilver> GHC core is basically just case statements, function application, and primops
05:01:52 <Myoma> humasect: if you  do  x <- xs ; y <- ys ; ...
05:02:08 <Myoma> humasect: You can think of it as nondeterministically pick the right 'x' and 'y' from xs and ys
05:02:40 <quicksilver> it feels like breadth-first search through all possibilities
05:02:41 <Myoma> > do x <- [1..10] ; y <- [1..10] ; guard (x*y == 21) ; return (x,y)
05:02:42 <lambdabot>   [(3,7),(7,3)]
05:02:44 <humasect> hmm *ponder*
05:02:45 <quicksilver> (although actually it's depth-first)
05:03:18 <humasect> quicksilver: hehe=)
05:03:54 <ivanm> matthew-_: you around?
05:04:30 <humasect> > do x <- [0..9]; y <- [0..9]; return x+y
05:04:32 <lambdabot>       No instance for (Enum [t])
05:04:32 <lambdabot>        arising from the arithmetic sequence ...
05:04:39 <humasect> right i see ..
05:04:48 <Myoma> return x+y = (return x)+y
05:04:51 <Deewiant> > do x <- [0..9]; y <- [0..9]; return (x+y)
05:04:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8...
05:05:37 <Myoma> @2d6
05:05:40 <matthew-_> ivanm: yes!
05:05:43 <Myoma> @die 2d6
05:05:43 <lambdabot> 2d6 => 3
05:05:44 <quicksilver> > do x <- [0..12]; y <- [0..x]; z <- [0..y]; guard (z*z == x*x + y*y); return (x,y,z)
05:05:45 <lambdabot>   [(0,0,0)]
05:05:50 * humasect waits for brain to catch up
05:05:51 <matthew-_> ivanm: sorry, my internet at home is up the spout
05:05:52 <mapreduce> > do x <- [0..9]; y <- [0..9]; z <- [0..9]; return (x+y+z)
05:05:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9,10,2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8...
05:05:54 <Myoma> @roll 2d6
05:05:54 <lambdabot> Consider it noted.
05:06:00 <Myoma> huh...
05:06:04 <Deewiant> @die 2d6
05:06:04 <lambdabot> 2d6 => 8
05:06:06 <mapreduce> Can you generalise that to n lists?
05:06:39 <Myoma> :t sequence . replicate ?n
05:06:40 <lambdabot> forall (m :: * -> *) a. (?n::Int, Monad m) => m a -> m [a]
05:06:41 <ivanm> matthew-_: fair enough... did you get the patches I sent for your graphviz library?
05:06:56 <matthew-_> ivanm: yes, but I've not had a chance to look at them yet, sorry
05:06:57 <Myoma> > (sequence . replicate 3) [1..6]
05:07:07 <lambdabot>  Terminated
05:07:07 <matthew-_> ivanm: hopefully this evening I'll read through them
05:07:08 <ivanm> matthew-_: fair enough
05:07:10 <ivanm> \o/
05:07:21 <humasect> > do (return [0..9])+[0..9]
05:07:22 <lambdabot>       No instance for (Num [[t]])
05:07:22 <lambdabot>        arising from a use of `+' at <intera...
05:07:22 <retybok> how can you store say a list of ints in a file in binary format?
05:07:24 <Myoma> ♪ (sequence . replicate 3) [1..6]
05:07:24 <lunabot>  [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,1,5],[1,1,6],[1,2,1],[1,2,2],[1,2,3],[1,...
05:07:29 <Myoma> ♪ (sequence . replicate 34 [1..6]
05:07:29 <lunabot>   parse error (possibly incorrect indentation)
05:07:31 <Myoma> ♪ (sequence . replicate 34) [1..6]
05:07:32 <lunabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,...
05:07:48 <ivanm> Myoma: are you just showing off now by having a bot respond to unicode musical characters?
05:08:08 <quicksilver> > do x <- [1..20]; y <- [1..x]; z <- [1..y]; guard (x*x == y*y + z*z); return (x,y,z)
05:08:10 <lambdabot>   [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8),(20,16,12)]
05:08:13 <quicksilver> that's what I meant :)
05:08:18 <humasect> hehe
05:08:35 <Myoma> ♪ (map sum . (sequence . replicate 34)) [0..1]
05:08:35 <humasect> hmm..
05:08:35 <lunabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
05:08:45 <Myoma> @oies 0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2
05:08:46 <lambdabot>  1's-counting sequence: number of 1's in binary expansion of n (or the binary...
05:08:46 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
05:10:12 <humasect> retybok: storablevector might be neat
05:11:25 <Saizan> retybok: or look at Data.Binary, .Put if you need a specific format
05:11:26 <humasect> > fmap (+10) (40,60)
05:11:27 <lambdabot>   (40,70)
05:14:13 <Myoma> Is there anything on haskell.org or otherwhere that says when GHC 6.10 comes
05:14:38 <Myoma> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
05:14:40 <lambdabot> Title: Status/Releases - GHC - Trac
05:14:47 <retybok> Saizan: thanks, I'll look it up
05:15:35 <retybok> Saizan: it's not even in the standard library???
05:16:06 <Saizan> retybok: no
05:16:10 <Saizan> ?hackage binary
05:16:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
05:16:20 <Deewiant> "the standard library" is essentially only the Prelude plus a couple of random functions
05:17:28 <retybok> are you saying there is no way to dump a list of ints into a file without relying on external libraries?
05:18:26 <Saizan> yeah, you can do the splitting of the Int into bytes with Data.Word + Data.Bits
05:18:28 <Deewiant> define "external"
05:18:42 <Saizan> and then print those "bytes" with putStr
05:18:58 <retybok> Saizan: ok, I'll look into that
05:19:17 <Deewiant> retybok: why not just get the library that does it for you
05:19:36 <Saizan> exploiting the fact that putStr essentially uses latin1 as encoding, but that is going to change soon
05:20:27 <Deewiant> it doesn't look like the H98 IO module has anything for binary writing
05:20:41 <quicksilver> :t hPutBut
05:20:43 <lambdabot> Not in scope: `hPutBut'
05:20:45 <quicksilver> :t hPutBuf
05:20:47 <lambdabot> Not in scope: `hPutBuf'
05:20:49 <quicksilver> hmm
05:20:49 <Saizan> hPutBuf is the better you get
05:20:56 <quicksilver> yup.
05:21:00 <Deewiant> and it's not in H98
05:21:05 <quicksilver> oh really?
05:21:22 <Deewiant> I don't see it in the haddocked source for GHC's IO module
05:21:52 <Deewiant> that is to say, at http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/src/IO.html
05:21:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5gkgqu
05:21:55 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhPutBuf
05:21:57 <lambdabot> Title: System.IO, http://tinyurl.com/sbkmj
05:22:04 <Deewiant> yes, System.IO, but that's not H98
05:22:07 <MyCatVerbs> quicksilver: if you check the library docs for IO (as opposed to System.IO), you'll note that it's not there.
05:22:15 * quicksilver nods
05:22:22 <quicksilver> I see that you are right, yes ;)
05:22:27 <quicksilver> I'm quite surprised.
05:22:27 <MyCatVerbs> IO and friends are the H98-specific versions.
05:23:47 <MyCatVerbs> Meh. H98 is somewhat... abstract. I guess it makes sense for messy things like binary I/O and encodings (what if you have nine-bit-bytes? etc) to be implementation-specific, rather than for the spec to become enormous.
05:25:10 <SamB_XP> MyCatVerbs: well, I think it was more that they hadn't figured out what to do for those than concerns about spec bloat ...
05:25:46 <SamB_XP> not that we've got it figured out yet or anything ;-P
05:25:59 <MyCatVerbs> SamB_XP: yeah, I guess. Premature standardization and all that. But H98 would be rather larger if you dragged in everything needed for binary IO and nice character encoding support.
05:26:51 <SamB_XP> that's true. but it wouldn't be necessary for the spec to say HOW it would be implemented, would it?
05:26:54 <quicksilver> MyCatVerbs: binary IO would be nice, though.
05:27:00 <quicksilver> even if they took a punt on the encoding
05:27:08 <MyCatVerbs> SamB_XP: you're right, though, premature standardization is a much more important issue than spec size.
05:27:31 <SamB_XP> a reliable way of performing binary IO, at minimum, should be in the spec
05:27:50 <SamB_XP> since it's fairly clear what that would do
05:28:01 <MyCatVerbs> quicksilver: then you'd have to put something like IOArray into the spec, though.
05:28:01 <SamB_XP> and it's also a rather important thing to be able to do ;-)
05:28:22 <SamB_XP> you don't need IOArray just to get binary IO
05:28:37 <Saizan> putBytes/getBytes
05:28:51 <Saizan> with [Word8]
05:28:52 <Deewiant> putBytes :: [Word8] -> IO ()
05:29:00 <MyCatVerbs> Yeah, okay.
05:29:01 <Deewiant> probably hPutBytes with a Handle but anyway
05:29:08 <MyCatVerbs> But now you've dragged in Data.Word. ;)
05:29:21 <Deewiant> Word is already H98, no?
05:29:22 <SamB_XP> so?
05:29:27 <SamB_XP> Data.Word isn't that big a deal
05:29:35 <MyCatVerbs> SamB_XP: so nothing. Data.Word isn't a big deal.
05:29:44 <Deewiant> indeed, Word is H98
05:29:58 <SamB_XP> Data.Word isn't, but it's not that complicated
05:30:11 <quicksilver> yeah, I was just hoping for [Word8] -> IO ()
05:30:16 <quicksilver> I think that's a reasonable thing to ask for.
05:30:19 <Deewiant> Word evidently exports all of Data.Word
05:30:21 <quicksilver> anyhow, it is what it is ;)
05:30:22 <SamB_XP> and arguably should be standardized anyway
05:30:32 <SamB_XP> Deewiant: what?
05:30:37 <MyCatVerbs> SamB_XP: I'm just expressing a certain level of contentment with the current situation. I think having messy issues like fast IO, binary IO, and character encoding be up to implementations is just about fine. Though you're right that binary IO is the least messy of those and *could* have been in the spec, I think it's okay enough that it isn't.
05:30:38 <SamB_XP> you mean that was all standard already?
05:30:42 <Deewiant> SamB_XP: http://www.haskell.org/ghc/docs/latest/html/libraries/haskell98/src/Word.html
05:30:53 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5ev3sx
05:31:17 <Saizan> i don't need it in the spec, but in System.IO
05:31:47 <Saizan> it's not really reasonable to ask me to go via ByteString for getByte
05:32:01 <SamB_XP> indeed
05:32:09 <Saizan> or to allocate a pointer for hGetBuf
05:55:09 <MarcWeber> dcoutts_: What do you think about making cabal have some knowledge about stuff such as NewException? It could define some cpp options automatically. I think this flag will be used a long time and other compilers will follow. However this will end up in having many ifdefs ?
05:55:47 <dcoutts_> MarcWeber: we provide a way of checking the version numbers of all dependent packages
05:55:56 <dcoutts_> which is sufficient for that problem
05:56:16 <MarcWeber> dcoutts_: cabal itself is using this :)
05:57:32 <MarcWeber> So the way to go is adding if base > xx then define flag NewException..
05:57:41 <hackage> Uploaded to hackage: cgi 3001.1.7.0
05:58:40 <dcoutts_> MarcWeber: cabal has to be able to be built with ghc --make, and not any Cabal features
05:59:01 <dcoutts_> since it has to boostrap, so it cannot use the mechanism for testing versions of deps
05:59:53 <MarcWeber> dcoutts_: So how to get to know which base version is starting to use NewException? As patches can be reordered in darcs I can't use the repository itself to find out, can I ?
06:00:12 <dcoutts_> MarcWeber: base 4
06:02:26 <FordCortina> yippee i got Yi working on os x :)
06:03:29 <PeakerWork> is it possible instead of checking version numbers, to check available features/bugfixes to more gracefully handle backports/etc?
06:22:29 <sw17ch> ?bot
06:22:29 <lambdabot> :)
06:22:50 <sw17ch> dcoutts_: ping
06:22:52 <thoughtpolice> happybot
06:22:56 <thoughtpolice> :]
06:23:00 <dcoutts_> sw17ch: pong
06:23:01 <sw17ch> :)
06:30:21 <Wild_Cat> hrmm. I'm seeing a lot of talk about software transactional memory. Maybe I should see what it's all about.
06:31:37 <Wild_Cat> (...and for the record, I'm disappointed to see Mark Shuttleworth has jumped into the "manual threading for performance is the way of the future" bandwagon.)
06:31:44 * _Dae_ once again manages a 5x slowdown of the program he's trying to improve
06:33:13 <thoughtpolice> locks and conditions are the only way to multithread. locks and conditions are multithreading. we are borg.
06:34:32 <Wild_Cat> yeah, that's the un-idea.
06:35:14 <_Dae_> Yeah, come on. It's soo much easier to deal with a simple lock than having to go into all the silly things with par and strategies....
06:35:53 <Axman6> @undo do {f; b;}
06:35:54 <lambdabot> f >> b
06:36:11 <Axman6> @undo do {x <- f; b x;}
06:36:11 <lambdabot> f >>= \ x -> b x
06:36:36 <Axman6> that cound just be f >>= b right?
06:36:58 <Deewiant> ?pl f >>= \x -> b x
06:36:58 <lambdabot> b =<< f
06:37:10 * edwardk waves hello.
06:37:18 <subconscious> hiya
06:37:50 <fatalerrorx> > log(0)
06:37:50 <Axman6> @src Maybe (=<<)
06:37:50 <lambdabot> Source not found. I feel much better now.
06:37:53 <lambdabot>   -Infinity
06:38:08 <Axman6> @src (=<<)
06:38:08 <lambdabot> f =<< x = x >>= f
06:38:08 <fatalerrorx> hmm what should i make log 0 equal?
06:38:21 <Axman6> fatalerrorx: -Infinity
06:38:30 <fatalerrorx> 0?
06:38:41 <Axman6> that's log(1)
06:39:06 <fatalerrorx> > log(0.2)
06:39:07 <Axman6> what's wrong with -Infinity?
06:39:07 <lambdabot>   -1.6094379124341003
06:39:18 <fatalerrorx> lots :)
06:39:23 <kig> there is no shared memory, shared memory is a lie
06:39:34 <subconscious> fatalerrorx: leave the function undefined at that point
06:40:10 <quicksilver> -Infinity is a good answer. undefined is the answer if you want to restrict the range.
06:40:16 <Axman6> > map log [0..10]
06:40:17 <lambdabot>   [-Infinity,0.0,0.6931471805599453,1.0986122886681098,1.3862943611198906,1.6...
06:41:00 <Deewiant> > map log [-5..5] :: [Complex Double]
06:41:01 <lambdabot>       No instance for (Enum (Complex Double))
06:41:02 <lambdabot>        arising from the arithme...
06:41:07 <Axman6> > map (log . (10^)) [0..10]
06:41:08 <Deewiant> :-/
06:41:08 <lambdabot>   [0.0,2.302585092994046,4.605170185988092,6.907755278982137,9.21034037197618...
06:41:19 <Deewiant> > log (exp 1)
06:41:20 <lambdabot>   1.0
06:41:33 <Axman6> ah, right. it's ln
06:41:42 <Deewiant> > logBase 10 100
06:41:43 <lambdabot>   2.0
06:42:48 <zachk> @src (>>=)
06:42:48 <lambdabot> Source not found. It can only be attributed to human error.
06:43:14 <Axman6> @src Maybe (>>=)
06:43:14 <lambdabot> (Just x) >>= k      = k x
06:43:14 <lambdabot> Nothing  >>= _      = Nothing
06:43:32 <zachk> ahhh thank you Axman6
06:43:39 <Axman6> @src List (>>=)
06:43:40 <lambdabot> Source not found. Wrong!  You cheating scum!
06:43:43 <Wild_Cat> @src IO (>>=)
06:43:43 <lambdabot> m >>= k     = bindIO m k
06:43:43 <Deewiant> @src [] >>=
06:43:44 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:43:47 <Axman6> @src [] (>>=)
06:43:47 <lambdabot> xs >>= f     = concatMap f xs
06:44:19 <Axman6> @src Either (>>=)
06:44:19 <lambdabot> Left  l >>= _ = Left l
06:44:19 <lambdabot> Right r >>= k = k r
06:44:54 <BeelsebobWork> @src bindIO
06:44:54 <lambdabot> bindIO (IO m) k = IO ( \ s ->
06:44:54 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
06:44:56 <Deewiant> This is my Monad. There are many like it, but this one is mine.
06:45:40 <BeelsebobWork> Deewiant: ?
06:46:06 <Deewiant> Just kidding about the 4 versions of >>= we've seen thus far :-P
06:46:18 <Axman6> is <- a function, or part of the language?
06:46:26 <shrughes> part of the language
06:46:26 <quicksilver> part of the language
06:46:32 <Axman6> ok, cheers
06:46:35 <quicksilver> it's a special syntax for >>=, basically
06:46:44 <Deewiant> > let a <- b = 1 in 2 <- 3
06:46:45 <lambdabot>   mueval: Prelude.read: no parse
06:46:54 <quicksilver> "a <- foo" is "foo >>= \a ->"
06:47:03 <quicksilver> with a little careful placement of parentheses as needed
06:47:29 <Wild_Cat> @src (<-)
06:47:29 <lambdabot> Source not found.
06:47:38 <quicksilver> before do notation, you saw a lot of code of the form 'foo >>= \a -> bar >>= \b -> baz >>= \c ->'
06:47:49 <quicksilver> you still do in, e.g., ML
06:47:55 <Axman6> yuck
06:47:56 <Wild_Cat> that's pretty ugly.
06:48:41 <subconscious> ocaml has do notation
06:48:48 <quicksilver> subconscious: ?
06:48:54 <subconscious> well it does not actually but someone added it with camlp4
06:48:58 <quicksilver> Wild_Cat: you get used to it.
06:49:09 <Deewiant> with line breaks it's not that bad
06:49:19 <quicksilver> yeah, normally a line break after each ->
06:49:23 <BeelsebobWork> indeed
06:49:31 <BeelsebobWork> in fact, it's really not much worse than do notation
06:49:34 <quicksilver> the main thing I didn't like about it is it messes up emacs' ocaml indentation
06:49:38 <Wild_Cat> it still hurts the eyes. Especially in a language that tries to look elegant. :p
06:49:41 <quicksilver> which is the mode's fault :P
06:49:53 <BeelsebobWork> Wild_Cat: that's because you're doing something inelligant
06:49:57 <quicksilver> of course in ocaml it's actually
06:49:59 <quicksilver> fn x =>
06:50:02 <quicksilver> not \x ->
06:50:07 <quicksilver> or whatever, I forget
06:51:07 <Axman6> all the ocaml i've read i found really hard to understabd
06:51:16 <Axman6> understand too -_-
06:51:49 <Axman6> maybe i should use it... mine's not much better
07:00:14 <sw17ch> can any one think of a problem which does not have an elegant solution?
07:00:32 <sw17ch> (within the bounds of reason)
07:00:36 <subconscious> sw17ch: 4 color theorem? :)
07:00:44 <sw17ch> subconscious, good one :)
07:00:45 <ski_> sw17ch : halting problem
07:00:57 <shrughes> talking to Exchange servers?
07:01:09 <sw17ch> alright, how about i rephrase that...
07:01:16 <bd_> Anything to do with the x86 architecture.
07:01:21 <sw17ch> can any one think of a problem, which has a solution, but does not have an elegant one?
07:01:32 <sw17ch> :)
07:01:34 <Wild_Cat> sw17ch: anything Microsoft.
07:01:45 <shrughes> sw17ch: using MAPI in .NET
07:02:15 <sw17ch> while all technically correct, none of you managed to answer the actual question :P
07:02:26 <shrughes> yes
07:02:30 <quicksilver> sw17ch: fermat's last theorem?
07:02:38 <Wild_Cat> sw17ch: Traveling salesman?
07:02:43 <sw17ch> quicksilver: ah, very good
07:02:49 <quicksilver> sw17ch: human reproduction?
07:02:52 <im_alone> @google wilson theorem
07:02:54 <lambdabot> http://en.wikipedia.org/wiki/Wilson's_Theorem
07:03:00 <subconscious> I haven't read  wiles proof ..
07:03:10 <subconscious> but... I think it's is probably extremly elegant
07:03:10 <ivanm> I have a bunch of objects with x-y values, and need a way to store the distances between each pair of objects such that for object v, I can quickly find all objects within a specified distance of v... what would be a good way of doing this? Map ob (Map ob dist) ?
07:03:44 <sw17ch> ivanm: quadtree!
07:03:46 <quicksilver> ivanm: kd-trees? quadtree?
07:03:57 <ivanm> never heard of either of them... :s
07:04:01 <quicksilver> (this is an area there has been lots of research on)
07:04:01 * ivanm wikis
07:04:06 <ivanm> *nod*
07:04:11 <sw17ch> http://en.wikipedia.org/wiki/Quadtree
07:04:12 <lambdabot> Title: Quadtree - Wikipedia, the free encyclopedia
07:04:16 <sw17ch> ivanm ^^
07:04:23 <ivanm> heh, just looked it up myself
07:04:48 <sw17ch> wow, that's actually a good article...
07:06:00 <ivanm> hmmm... not quite sure if that's actually what I need/want...
07:06:14 <ivanm> after I find the distances, I won't need the spacial co-ordinates any more
07:06:29 <quicksilver> well your solution was quadratic in the number of objects
07:06:38 <im_alone> p is prime if and only if (p-1)! = -1 (mod p)
07:06:39 <quicksilver> if that is fine for you then yes, it's trivially the fast solution.
07:07:00 <quicksilver> the study of quadtrees and friends is based on the assumption that quadratic space usage is not acceptable :)
07:07:05 <ivanm> quicksilver: using Maps?
07:07:13 <ivanm> heh
07:07:28 <quicksilver> yes.
07:07:29 <subconscious> ♪ (-1)`mod`111
07:07:30 <lunabot>  110
07:07:37 <subconscious> ♪ (product [1..111-1])`mod`111
07:07:38 <lunabot>  0
07:07:38 <ivanm> is there a haskell implementation of quadtrees anywhere?
07:07:45 <quicksilver> you were using a map as an associative array (ob,ob) -> dist
07:07:54 <quicksilver> so that uses space proportional to the number of (ob,ob) pairs
07:07:55 <ivanm> OK, how come we suddenly have another bot here?
07:08:00 <quicksilver> = quadratic.
07:08:01 <ivanm> quicksilver: *nod*
07:08:08 <subconscious> ♪ (-1)`mod`11
07:08:09 <lunabot>  10
07:08:11 <subconscious> ♪ (product [1..11-1])`mod`11
07:08:12 <lunabot>  10
07:08:17 <ivanm> but with a quadtree, wouldn't I have to recalculate the distance each time?
07:08:35 <quicksilver> yes.
07:08:55 <quicksilver> if you're storing the difference between every pair that is quadratic :P
07:09:21 <ivanm> yeah, I know...
07:09:44 <ivanm> but time-wise, wouldn't the quadtree take longer if I'm wanting to find which other objects are within a certain distance of it?
07:10:10 <quicksilver> yes.
07:10:17 <quicksilver> the quadratic space solution is the fastest.
07:10:23 <ivanm> *nod*
07:10:30 <quicksilver> there are always high-space quick solutions: cache everythign!
07:10:36 <quicksilver> precalculate every possible code path.
07:10:52 <ivanm> I don't think time/space would be such a big problem, since I think my program would be limited by FGL anyway for the rest of it :p
07:10:57 <ivanm> heh
07:11:50 <im_alone> > 18! mod 19
07:11:51 <lambdabot>       No instance for (Num (Array (t -> t) e))
07:11:51 <lambdabot>        arising from the litera...
07:12:06 <im_alone> > fact(18) mod 19
07:12:07 <lambdabot>   mueval: Prelude.read: no parse
07:12:10 <ivanm> whereas for the quadtree... I can't really think of a way of finding objects within a given distance without searching all of them (well, you could probably optimise it slightly by knowing that if you're in one corner, you mightn't need to look in the opposite corner...)
07:12:17 <shrughes> > product [1..18] `mod` 19
07:12:18 <lambdabot>   18
07:12:19 <subconscious> @let wilson n = (product [1..n-1])`mod`n
07:12:23 <lambdabot>  Defined.
07:12:58 <im_alone> @let wilson n = ((product [1..n-1])`mod`n) - n
07:12:59 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
07:13:07 <subconscious> @undef
07:13:09 <quicksilver> ivanm: then you need to think harder.
07:13:18 <im_alone> @let wilson n = ((product [1..n-1])`mod`n) - n
07:13:19 <lambdabot>  Defined.
07:13:24 <im_alone> wilson 19
07:13:28 <quicksilver> ivanm: algorithms like 'find nearest' and 'find all in distance < n' are the bread-and-butter of kd-trees and quad-trees
07:13:30 <ivanm> quicksilver: considering that it's rather late here and I need sleep... ;-)
07:13:32 <im_alone> > wilson 19
07:13:33 <lambdabot>   -1
07:13:38 <subconscious> > map wilson [2..]
07:13:39 <lambdabot>   [-1,-1,-2,-1,-6,-1,-8,-9,-10,-1,-12,-1,-14,-15,-16,-1,-18,-1,-20,-21,-22,-1...
07:13:43 <im_alone> > wilson 20
07:13:44 <lambdabot>   -20
07:13:51 <shrughes> ivanm: if your node in the quadtree is atop a region that can't be reached, you don't have to traverse it
07:14:05 <subconscious> > filter (((-1) ==) . wilson) [2..]
07:14:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:14:10 <ivanm> shrughes: "atop"
07:14:20 <im_alone> wow!
07:14:56 * subconscious expects someone to @pl wilson next :p
07:15:33 <Deewiant> @pl wilson
07:15:34 <lambdabot> wilson
07:15:54 <quicksilver> @pl wilson n = ((product [1..n-1])`mod`n) - n
07:15:55 <lambdabot> wilson = (-) =<< mod =<< product . enumFromTo 1 . subtract 1
07:16:03 <quicksilver> that's actually quite nice
07:16:05 <quicksilver> as such things go.
07:16:16 <subconscious> yeah that's surprising
07:16:22 <subconscious> no flip . ap (.)
07:16:51 <subconscious> > filter ((==) (-1) . (-) =<< mod =<< product . enumFromTo 1 . subtract 1) [2..]
07:16:51 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in filter (liftA2 (&&) (not . (`elem` primes)) (((-1) ==) . wilson)) [2..]
07:16:52 <lambdabot>   Couldn't match expected type `a -> Bool'
07:16:52 <lambdabot>  Terminated
07:17:04 <subconscious> ♪ filter ((==) (-1) . (-) =<< mod =<< product . enumFromTo 1 . subtract 1) [2..]
07:17:04 <lunabot>      Couldn't match expected type `a -> Bool'
07:17:29 <lunabot>      Couldn't match expected type `a -> Bool'
07:17:35 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in filter (\x -> (not (x `elem` primes)) && (((-1) ==) $ wilson x)) [2..]
07:17:38 <cads> are type classes necessary for monads?
07:17:44 <subconscious> cads: no
07:17:51 <lambdabot>   thread killed
07:17:54 <subconscious> :t (-) =<< mod =<< product . enumFromTo 1 . subtract 1
07:17:56 <lambdabot> forall a. (Integral a) => a -> a
07:17:58 <BeelsebobWork_> oh, duh
07:18:03 <BeelsebobWork_> need orderedElem
07:18:05 <subconscious> :t ((==) (-1) . (-) =<< mod =<< product . enumFromTo 1 . subtract 1)
07:18:06 <lambdabot>     Couldn't match expected type `m b' against inferred type `Bool'
07:18:06 <lambdabot>       Expected type: a -> m b
07:18:06 <lambdabot>       Inferred type: a -> Bool
07:18:15 <subconscious> oh :[
07:18:18 <im_alone> is prime this mersenne number 2305843009213693951?
07:18:21 <im_alone> > wilson 2305843009213693951
07:18:21 <subconscious> ♪ filter ((==) (-1) . ((-) =<< mod =<< product . enumFromTo 1 . subtract 1)) [2..]
07:18:22 <lunabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
07:18:41 <lambdabot>   thread killed
07:18:43 <quicksilver> cads: no, but they're necessary for convenient use of them.
07:18:50 <quicksilver> cads: e.g. the overloading of mapM
07:19:00 <cads> I see
07:19:03 <quicksilver> (otherwise you pass a monad dictionary to each such call)
07:19:27 <cads> i'm debating whether to play with Helium and do some of my learning there
07:19:29 <subconscious> lunabot++
07:19:32 <subconscious> lambdabot--
07:19:52 <cads> but helium is sans type classes
07:20:07 <subconscious> ?where helium
07:20:08 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
07:20:10 <im_alone> ♪ filter ((==) (-1) . ((-) =<< mod =<< product . enumFromTo 1 . subtract 1)) [230584300921369395]
07:20:11 <lunabot>  luna: out of memory (requested 1048576 bytes)
07:20:34 <subconscious> oh looks like helium is just not finished yet
07:20:34 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in filter (\x -> (not (x `elem` (takeWhile (< (sqrt x)) primes)) && (((-1) ==) $ wilson x)) [2..]
07:20:35 <lambdabot>   mueval: Prelude.read: no parse
07:21:26 <Deewiant> gotta love those useful error messages
07:21:29 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in filter (\x -> (not (x `elem` (takeWhile (< (sqrt x)) primes))) && (((-1) ==) $ wilson x)) [2..]
07:21:30 <lambdabot>   Add a type signature
07:21:43 <Deewiant> it's like a typical microsoft product
07:21:48 <Deewiant> "didn't work. please try again."
07:21:50 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Int]) in filter (\x -> (not (x `elem` (takeWhile (< (sqrt x)) primes))) && (((-1) ==) $ wilson x)) [2..]
07:21:51 <lambdabot>       No instance for (Floating Int)
07:21:51 <lambdabot>        arising from a use of `sqrt' at <...
07:22:08 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Int]) in filter (\x -> (not (x `elem` (takeWhile (< (sqrt (fromIntegral x))) primes))) && (((-1) ==) $ wilson x)) [2..]
07:22:09 <lambdabot>       No instance for (Floating Int)
07:22:09 <lambdabot>        arising from a use of `sqrt' at <...
07:22:12 <ivanm> quicksilver: would this data structure do what I want? if so, how would it compare to a quadtree or using maps? http://hackage.haskell.org/packages/archive/bktrees/0.2.1/doc/html/Data-Set-BKTree.html
07:22:15 <BeelsebobWork_> bah, where's that now?
07:22:24 <lambdabot> Title: Data.Set.BKTree, http://tinyurl.com/5cnyw8
07:22:39 <subconscious> @let isqrt = floor . sqrt . fromIntegral
07:22:41 <lambdabot>  Defined.
07:22:42 <subconscious> :t isqrt
07:22:43 <lambdabot> forall a b. (Integral b, Integral a) => a -> b
07:22:52 <Deewiant> BeelsebobWork_: sqrt results in a floating as well
07:22:52 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Int]) in filter (\x -> (not (x `elem` (takeWhile (< (floor (sqrt (fromIntegral x)))) primes))) && (((-1) ==) $ wilson x)) [2..]
07:23:05 <quicksilver> ivanm: that looks like a perfect fit
07:23:07 <lambdabot>   thread killed
07:23:12 <quicksilver> because it's optimised exactly for your use case
07:23:15 <im_alone> @let is_wilson n = (((product [1..n-1])`mod`n) - n) == -1
07:23:15 <ivanm> \o/
07:23:16 <quicksilver> I've never used them though :)
07:23:17 <lambdabot>  Defined.
07:23:20 <ivanm> quicksilver: heh
07:23:25 <subconscious> instead of (< (floor (sqrt (fromIntegral x)))))))))))))) use (< isqrt x)
07:23:33 <BeelsebobWork_> oh? useful
07:23:44 <subconscious> I gave a really naive definition though
07:23:45 <ivanm> quicksilver: well, since no-one has been considerate enought to put a quadtree library on hackage... :p
07:23:48 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Int]) in filter (\x -> (not (x `elem` (takeWhile (< (isqrt x)) primes))) && (((-1) ==) $ wilson x)) [2..]
07:23:50 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
07:23:51 <SyntaxNinja> Philippa: your example of not getting things done was like 2 years old :)
07:23:57 <subconscious> :t \x -> (< (isqrt x))
07:23:59 <lambdabot> forall a a1. (Integral a, Integral a1) => a1 -> a -> Bool
07:23:59 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Integer]) in filter (\x -> (not (x `elem` (takeWhile (< (isqrt x)) primes))) && (((-1) ==) $ wilson x)) [2..]
07:24:00 <subconscious> :t \x -> (< isqrt x)
07:24:02 <lambdabot> forall a a1. (Integral a, Integral a1) => a1 -> a -> Bool
07:24:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:24:09 <subconscious> less brakets are required
07:24:48 <BeelsebobWork_> > let primes = nubBy (\x y -> y `mod` x == 0) ([2..] :: [Integer]) in filter (\x -> (not (x `elem` (takeWhile (<= (isqrt x)) primes))) && (((-1) ==) $ wilson x)) [2..]
07:24:51 <im_alone> > is_wilson 12345678
07:24:55 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:25:02 <lambdabot>   mueval: Prelude.read: no parse
07:25:07 * BeelsebobWork_ wonders why that's not playing right
07:25:11 <subconscious> im_alone: it's way to big to compute 1234568 )
07:26:03 <subconscious> ♪ [$rx|checking if rx is added yet|]
07:26:03 <lunabot>      No instance for (Show (String -> Maybe [String]))
07:26:08 <subconscious> great
07:26:38 <subconscious> ?hackage regex
07:26:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex
07:26:54 <im_alone> http://en.wikipedia.org/wiki/Formula_for_primes#Formula_based_on_a_system_of_Diophantine_equations
07:26:56 <lambdabot> Title: Formula for primes - Wikipedia, the free encyclopedia, http://tinyurl.com/2m8w7g
07:27:03 <Deewiant> ?hackage is not a search
07:27:03 <cads> > sum [1..1000000]
07:27:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/is not a search
07:27:09 <lambdabot>   mueval: Prelude.read: no parse
07:27:09 <lambdabot>  mueval: *** Exception: stack overflow
07:27:27 <subconscious> ♪ maybe [] tail $ [$rx|^([+-])?([0-9]+)\.([0-9]+)|] (show $ negate pi)
07:27:28 <lunabot>  ["-","3","141592653589793"]
07:27:57 <ivanm> is there any particular reason people are using lunabot rather than lambdabot?
07:28:19 <lunabot>   Not in scope: `help'
07:28:27 <lunabot>   Not in scope: `help'
07:28:38 <ivanm> grrr..... it won't let me /msg it :@
07:28:39 <im_alone> ivanm, yes, lunabot has better functions than lambdabot
07:28:44 <ivanm> im_alone: in what way?
07:29:05 <subconscious> I hope lambdabot will eventually use lunabots eval, it's much better
07:29:16 <im_alone> ♪ let is_wilson n = (((product [1..n-1])`mod`n) - n) == -1
07:29:17 <ivanm> subconscious: what, you don't like mueval?
07:29:17 <lunabot>   parse error on input `)'
07:29:21 <ivanm> who wrote lunabot?
07:29:34 <subconscious> no support of let or data yet though
07:30:25 <ivanm> why would you want data support?
07:30:38 <im_alone> ♪ ((((product [1..n-1])`mod`n) - n) == -1) 31337
07:30:38 <lunabot>   Not in scope: `n'
07:30:38 <lunabot>  <interactive>:1:76: Not in scope: `n'
07:30:45 <Saizan> lunabot and mueval evaluate expressions basically in the same way, it's mostly that \lb is using a buggy version of mueval
07:30:54 <subconscious> ♪ (\n -> ((((product [1..n-1])`mod`n) - n) == -1)) 31337
07:30:55 <lunabot>  luna: out of memory (requested 1048576 bytes)
07:31:08 <subconscious> Saizan: But lunabot has view patterns and TH
07:31:16 <im_alone> > is_wilson 31337
07:31:25 <lambdabot>   True
07:31:58 <ivanm> Saizan: *nod*
07:32:14 <Saizan> TH was disabled in \lb for security reasons, iirc, for view patterns, are they in any stable release of ghc?
07:32:28 <subconscious> I don't think so
07:33:06 <im_alone> Jones 1976 proved that a given number k + 2 is prime if and only if the following system of 14 Diophantine equations in 26 variables has a solution in the natural numbers
07:33:52 <subconscious> im_alone : can you code it in haskell :p
07:34:08 <im_alone> uffff!
07:34:23 <subconscious> im_alone: My favorite is mills constant
07:36:29 <im_alone> Jones 1982, exists such a set of equations of degree only 4, but in 58 variables
07:36:46 <im_alone> @google Jones algebraic geometry
07:36:51 <lambdabot> http://www.encyclopedia.com/topic/algebraic_geometry.aspx
07:36:51 <lambdabot> Title: algebraic geometry Research | Find algebraic geometry Articles | Encyclopedia.co ...
07:38:05 <thoughtpolice> Saizan: they got pushed into the HEAD a while back actually
07:38:16 <thoughtpolice> i don't think it would be hard to backport it to like 6.8 though
07:38:25 <thoughtpolice> (like audreyt's patch to bring QQ to 6.8)
07:38:41 <Saizan> thoughtpolice: they will be in 6.10, i guess?
07:39:30 <chylli> when I use HDBC.ODBC to connect my mysql db, I got an error: *** Exception: (unknown)
07:39:34 <chylli> who can help me ?
07:39:58 <MarcWeber> chylli: There is a special HDBC catch method which can print more info.
07:40:03 <thoughtpolice> Saizan: yeah I was playing around with them in my HEAD build
07:40:04 <MarcWeber> HAve a look at the code or sample code
07:40:21 <thoughtpolice> they've been in the HEAD since like, real early this year I think
07:40:42 <chylli> MarcWeber: thanks.
07:41:19 <MarcWeber> chylli search for catchSql
07:41:47 <chylli> MarcWeber: where can I search ? by wiki ? or hackage ?
07:42:30 <chylli> Prelude Database.HDBC.ODBC Database.HDBC> conn <- connectODBC "DSN=test" *** Exception: (unknown)
07:43:15 <MarcWeber> chylli Get the code of the libs and grep that.
07:43:25 <chylli> MarcWeber: thanks
07:44:24 <MarcWeber> Its defined in Database/HDBC/Utils.hs
07:44:38 <chylli> ok. thanks. reading now.
07:45:23 <subconscious> ♪ (\n -> 36*n^2 - 810*n + 2753) `fmap` [0..44]
07:45:23 <lunabot>  [2753,1979,1277,647,89,-397,-811,-1153,-1423,-1621,-1747,-1801,-1783,-1693,-...
07:46:10 <MarcWeber> chylli /Database/HDBC/Utils.hs there is handleSqlError :: IO a -> IO a
07:46:14 <MarcWeber> This will print the content
07:47:10 <chylli> ok
07:47:33 <chylli> got it
07:47:36 <chylli> MarcWeber: thanks
07:47:44 <MarcWeber> you're welcome
07:48:58 * BMeph_ wants to see a non-script language where you can "un-declare" a variable...
07:49:14 <Saizan> ?seen mmorrow
07:49:15 <lambdabot> mmorrow is in #haskell, #darcs and #ghc. I last heard mmorrow speak 6h 42m 36s ago.
07:49:33 <MarcWeber> BMeph_ :-) I think that's done by scoping..
07:49:48 <BMeph_> MarcWeber: Minty-fresh scoping? ;p
07:50:18 <quicksilver> BMeph_: dynamically or lexically?
07:51:00 <mapreduce> BMeph_: You can do it in Erlang's interpreter.
07:51:35 <Axman6> and octave i believe
07:51:44 <BMeph_> Hm... let's try s/non-script/non-interpreted/
07:52:10 <BMeph_> quicksilver: By those rules, I guess it'd have to be lexically.
07:52:18 <Twey> What would the point of that be?
07:52:44 <Twey> We've got garbage collectors and shadowing :)
07:53:00 <mapreduce> BMeph_: Erlang is a compiled language.  Perl is part-compiled.  There are two C interpreters in the codebase I am trying to avoid reading at work.
07:53:00 <subconscious> erlang  doesn't have gc?
07:53:07 <Axman6> BMeph_: and what about the good old i = null;?
07:53:09 <chylli> MarcWeber: Access denied for user 'chylli'@'localhost' (using password: YES)\"]"})
07:53:21 <chylli> MarcWeber: but I can access test db by isql and mysql
07:53:22 <Twey> mapreduce: *Two* C interpreters?
07:53:26 <Twey> o.@
07:53:27 <mapreduce> Twey: Yes.
07:53:31 <Twey> Oh dear.
07:53:39 <BMeph_> Axman6: What blashphemous profanity do you speak? o.O
07:53:43 <MarcWeber> chylli you can connect by socket or by TCP/IP
07:54:10 <MarcWeber> chylli: Maybe that's the difference
07:54:18 <quicksilver> BMeph_: lexically you can say "let x = Void in ... " or something daft like that
07:54:23 <leimy> subconscious: why would you think it doesn't have GC?
07:54:26 <Axman6> BMeph_: where null = undefined >_>
07:54:40 <subconscious> leimy: I think it does, I'm not sure what Twey meant
07:54:55 <chylli> MarcWeber: I think it is decided by /etc/odbc.ini, isn't it ?
07:55:18 <MarcWeber> chylli: That's one way. you may also have a local odbc conf if I recall correctly
07:55:20 <leimy> subconscious: ah
07:55:48 <BMeph_> quicksilver: quicksilver, you daft Punk, you! ;p
07:55:57 <quicksilver> ;)
07:56:04 <quicksilver> hell yeah.
07:56:05 <chylli> MarcWeber: you mean ~/.odbc ? I set it but isql dosnt work with it.
07:56:58 <MarcWeber> chylli: Sorry, my knowledge has vanished :-) You need to look it up in the docs. All I remember is that there are two different ODBC implementations for linux
07:57:19 <chylli> MarcWeber: thanks again. I will google it.
07:57:41 <hackage> Uploaded to hackage: xhtml 3000.2.0.1
07:57:43 <MarcWeber> But there is also a antive hdbc-mysql driver
07:58:09 <chylli> MarcWeber: really ? i think there is not.
07:58:42 <MarcWeber> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb-hsql-mysql
07:58:58 <chylli> MarcWeber: oh, hsql
07:58:59 <daf> MarcWeber: HSQL != HDBC :)
07:59:02 <chylli> :p
07:59:04 <MarcWeber> sory, I've mixed them up :)
08:07:08 <retybok> Is there a way to write a chunk of binary from a Foreign Ptr to a file? I can't seem to find any...
08:08:49 <quicksilver> retybok: hPutBuf
08:09:08 <quicksilver> retybok: but use a ForeignPtr directly is probably daft.
08:10:52 <retybok> quicksilver: In which module is hPutBuf?
08:11:16 <Deewiant> retybok: System.IO
08:11:25 <Deewiant> ?index hPutBuf
08:11:25 <lambdabot> System.IO
08:11:32 <retybok> thanks again
08:12:47 <vegai> is readFile guaranteed to read in one byte at a time?
08:13:21 <quicksilver> vegai: no, I don't think so.
08:13:57 <chylli> hdbc doesn't read user & password configuration in /etc/odbc.ini, why ?
08:14:01 <vegai> so, if I do "do o <- readFile "foo"; let s = (drop 0x224 o)" then s might have whatever?
08:14:26 <quicksilver> ?
08:14:40 <Zao> vegai: s will be a thunk to the rest of the contents.
08:14:43 <quicksilver> s will have the whole of the file "foo" except not the first 0x224 characters
08:15:07 <vegai> and "character" might not be 1 byte?
08:15:23 <quicksilver> bytes
08:15:29 <quicksilver> I should have said.
08:15:38 <Deewiant> is it guaranteed that it's bytes, though
08:15:38 <vegai> ok, right. Good
08:15:45 <Zao> In the standard IO, each byte read is expanded to one Char.
08:15:50 <quicksilver> Deewiant: not by the standard, no.
08:16:00 <quicksilver> Deewiant: just by my knowledge of what GHC (and hugs) do in practice.
08:16:01 <Deewiant> what with the future UTF-8 IO coming and all
08:16:06 <quicksilver> agreed.
08:16:11 <Deewiant> yeah, so you shouldn't really rely on that
08:16:42 <daf> I'm not convinced by implicit decoding being the Right Thing
08:17:13 <quicksilver> in a language with a Unicode Char, getLine should attempt to read 'chars'.
08:17:30 <quicksilver> we never got a consensus on the best way to handle encoding
08:17:45 <EvilTerran> at least we're not distinguishing between octets and bytes today :P
08:17:50 <quicksilver> but the new ad-hoc solution - assume UTF8 - is better than the current adhoc solution - assume single bytes.
08:17:56 <Zao> Unless you can always deduce the encoding automatically, guessing is virtually useless.
08:18:06 <daf> it makes sense that we should optimise for the common case and that the common case is text processing
08:18:11 <quicksilver> a clearly documented default is a workable solution.
08:18:13 <EvilTerran> that's what a leading ZWNJ is for
08:18:18 <quicksilver> hence UTF8.
08:18:27 * Zao huggles the BOM.
08:18:42 <daf> quicksilver: I thought it was going to try and work out what the system encoding was somehow and use that
08:18:46 <daf> perhaps by looking at the locale
08:18:57 <vegai> is there something like readFile that is guaranteed to read in bytes?
08:19:01 <Zao> daf: Data can be in any encoding.
08:19:13 <Zao> If I send you a file over the internets, what encoding is that?
08:19:43 <quicksilver> daf: no, they decided that a simple 'assume UTF8' was simpler to understand, simpler to document.
08:19:52 <daf> Zao: sorry, could you be a bit more condescending?
08:20:02 <quicksilver> I have some sympathy for the position.
08:20:12 <Zao> daf: Any such meaning was not intended.
08:21:10 <daf> Zao: ok, perhaps I misjudged
08:21:20 <daf> quicksilver: I think that's a good decision
08:21:29 <daf> quicksilver: it means that behaviour is much more predictable
08:21:31 <vegai> oh well. I can evade the problem by converting this legacy data into something more sensible and scrap my conversion code
08:21:36 <daf> quicksilver: well, consistent
08:21:42 <vegai> or can I. Not sure. That might be borderline illegal
08:22:04 <quicksilver> daf: yes. When perfection is not possible, predictability is good.
08:22:10 <quicksilver> daf: mind you, I'm doubting my memory now.
08:22:59 <daf> quicksilver: hmm: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
08:23:01 <lambdabot> Title: Status/Releases - GHC - Trac
08:23:05 <daf> quicksilver: "# Consensus was that Text I/O should always use the current locale encoding. "
08:23:08 <daf> :/
08:23:09 <quicksilver> damn.
08:23:23 <quicksilver> daf: I was presenting the case I argued for, not the one they decided on.
08:23:24 <quicksilver> ohewell.
08:23:29 <Deewiant> well, that's awfully crap
08:23:50 <Deewiant> basically means that I'll avoid the default I/O like the plague :-P
08:23:50 <daf> disappointing
08:24:33 <quicksilver> I can't find the discussion now.
08:30:02 <Twey> What's the 'External Core'?
08:30:34 <quicksilver> daf: if you're interested, the thread is here, I think http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/thread.html#14411
08:30:44 <lambdabot> Title: The Glasgow-haskell-users February 2008 Archive by thread, http://tinyurl.com/67wrx9
08:33:25 <Saizan> ?where binary
08:33:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
08:33:38 <vegai> the factor guys solved the encoding thing rather nicely, I seem to remember
08:34:19 <daf> hmm, I wonder what they mean by C
08:34:42 <daf> (when they say that C uses the locale encoding)
08:34:53 <dolio> ANSI C?
08:35:55 <Baughn> BMeph_: Common lisp. You can unbind symbols.
08:36:52 <subconscious> hmm
08:36:56 * subconscious wonders hat BMeph is working on
08:38:10 <daf> dolio: AFAIK, ANSI C functions make no attempt to do decoding/encoding
08:38:36 <BMeph_> subconscious: "[07:48]	* BMeph_	wants to see a non-script language where you can "un-declare" a variable..."
08:38:59 <BMeph_> subconscious: Just idle curiousity. :)
08:39:20 <quicksilver> daf: fgetws does
08:39:25 <quicksilver> and friends.
08:39:42 <dolio> My bad. The newest standard isn't ANSI anymore.
08:39:58 <quicksilver> the libc "wide character" functions, which are the only ones which you would expect to cope with unicode, use the system locale to decide on encoding.
08:40:13 <Deewiant> it isn't? I thougth they were all both ISO and ANSI
08:40:18 <Deewiant> s/gth/ght/
08:40:20 <daf> quicksilver: aha
08:40:52 <daf> only using the locale encoding for terminals seems more reasonable
08:41:09 <quicksilver> dolio: C99, POSIX.1-2001
08:41:10 <Deewiant> best would be to convert to UTF-16 for windows terminals
08:41:11 <quicksilver> apparently :)
08:41:28 <Deewiant> and then use WriteConsoleW
08:41:35 <quicksilver> daf: well you can read us going round and round in circles between the three possibilities.
08:41:38 <quicksilver> in the thread
08:41:47 <daf> and Simon is right that new installs would be unaffected
08:42:01 <quicksilver> distinguishing between terminals and non-terminals makes it hard to write simple programs which don't care fi they're connected to a terminal or not.
08:42:17 <quicksilver> it's surprising if "foo" and "foo > bar" do something rather different.
08:42:28 <quicksilver> mean while, locale is obviously a bad metric for file encoding
08:42:30 <Deewiant> my vose is for "UTF-8 everywhere except UTF-16 for windows terminals"
08:42:33 <Deewiant> argh, can't type
08:42:35 <Deewiant> s/vose/vote/
08:42:39 <quicksilver> but on the other UTF8 is the wrong choice in many situatiosn.
08:42:54 <quicksilver> My vote was for "UTF8 everywhere" because it's an easy rule to rememember and explain.
08:43:02 <quicksilver> But my vote (and Deewiant's vote) don't actually matter.
08:43:08 <daf> mmm
08:43:29 <quicksilver> in fact it was also discussed outside that thread, in IRC, at great length.
08:43:40 <quicksilver> it's a discussion which never resolves because it's based on a value judgment
08:43:46 <quicksilver> "which one of these three bad things is least bad"
08:43:59 <daf> nod
08:44:28 <BeelsebobWork_> can anyone think of a type which has read . show /= id, and the Show instance does not produce the Haskell code for producing the value?
08:45:40 <dolio> Show not producing the Haskell code for the value is something of a no-no.
08:46:18 <wjt> Lots of Data.Time Show instances produce human-readable output rather than Haskell code
08:46:24 <Deewiant> well, for floating point types the former applies :-)
08:46:33 <wjt> but most such types lack Read
08:47:12 <dolio> Actually, the show instance for floating point types allegedly goes to great pains to make sure that you get the same thing back when you read it in.
08:47:18 <dolio> Regardless of rounding schemes.
08:47:40 <quicksilver> wjt: yes, they're evil too.
08:47:43 <quicksilver> ;)
08:47:49 <Deewiant> @check \n -> read (show n) == (n :: Float)
08:47:50 <lambdabot>   "OK, passed 500 tests."
08:47:55 <Deewiant> hm, not bad
08:48:38 <dolio> read . show might not be the identity on Maps and Sets, if you count differently balanced internal representations as different.
08:48:59 <dolio> Although that's a questionable choice already.
08:49:15 <dolio> And their show instances produce Haskell code.
08:49:28 <wjt> lack of Read isn't Data.Time's biggest problem
08:49:53 <quicksilver> dolio: modulo a stupid and hard to resolve problem with qualified modules :(
08:50:08 <Deewiant> @check \n -> let m = n**(1/3) :: Float in read (show m) == m
08:50:09 <lambdabot>   "Falsifiable, after 2 tests:\n-1.6\n"
08:50:12 <quicksilver> wjt: what is? I've coped with it fairly well.
08:50:15 <dolio> Sure. I don't see any easy way to fix that.
08:50:25 <Deewiant> bah, NaN
08:51:17 <quicksilver> dolio: Yeah. Stupid and hard to resolve :(
08:51:54 <wjt> quicksilver: It seemed remarkably difficult to get the difference between two LocalTimes in any kind of useful format
08:53:00 <quicksilver> wjt: I would convert them both to UTC and then use diffUTCTime
08:55:33 <wjt> quicksilver: i did.  and then i got back an effectively opaque value that I had to turn into a number of seconds with floor and then run around wielding `mod` 60 angrily until I had the difference in useful units
08:55:50 * quicksilver laughs
08:55:54 <quicksilver> I don't think it's very opaque.
08:56:03 <quicksilver> it is a custom numerical type.
08:56:08 <wjt> sure
08:56:10 <quicksilver> you can convert it to Double with realToFrac
08:56:37 <quicksilver> it's not a Double because it's more accurate than a double.
08:56:56 <wjt> sure, and I can write hms :: NominalDiffTime -> (Int, Int, Pico) pretty easily
08:57:05 * quicksilver nods
08:57:10 <wjt> i should actually spend less time complaining and more time writing the patch
08:57:23 <quicksilver> it might be poorlydocumented but I don't think it's actually broken.
08:57:28 <quicksilver> it seems quite sensible to me.
08:57:41 <hackage> Uploaded to hackage: haskeline 0.3
08:57:43 <quicksilver> although I don't claim to understand (or particularly care about) leap seconds, so that part I dont' worry about.
08:57:47 <wjt> the types are sensible (but lacking helper functions), once I'd figured them out
09:00:30 <birkenfeld> hmm, I've been wondering about this for the last few days
09:00:42 <birkenfeld> let's say I want to write an interpreter for a language like Python
09:00:54 <birkenfeld> how would I represent the objects of this language in Haskell?
09:01:17 <birkenfeld> basically, I have to be able to pass them around quite freely
09:01:31 <subconscious> birkenfeld: I would do it in ST for the mutation
09:02:10 <subconscious> so just a map from instance variable names to mutable values, and perhaps store the hierarchy info too
09:03:17 <quicksilver> doesn't sound like a good case for ST to me.
09:03:29 <quicksilver> why not just use a map from names to values
09:03:45 <subconscious> because you can mutate the values
09:03:53 <quicksilver> just update the map
09:04:59 <birkenfeld> so an object would be just a map of name->value pairs...
09:05:18 <Saizan> but the value is really a reference most of the time in python
09:05:43 <subconscious> quicksilver: the map would be something outside of each object? but objects can reference each other, so I don't think that would work
09:05:55 <quicksilver> you need identity for objects, yes
09:06:01 <quicksilver> I just use some natural source of identity
09:06:02 <quicksilver> like numbers
09:06:09 <quicksilver> data ObjectID = ObjectID Int
09:06:22 <quicksilver> the Int is a 'pointer' for your VM
09:06:25 <subconscious> oh I get it
09:06:28 <quicksilver> then your global heap is just
09:06:33 <quicksilver> Map ObjectId Value
09:06:35 <Axman6> > map (\n -> lobBase 10 $ 1/(10^n)) [1..10]
09:06:36 <lambdabot>   mueval: Prelude.read: no parse
09:06:40 <Axman6> > map (\n -> logBase 10 $ 1/(10^n)) [1..10]
09:06:42 <lambdabot>   [-0.9999999999999998,-1.9999999999999996,-2.9999999999999996,-3.99999999999...
09:06:47 <quicksilver> where 'Value' is something like data Value = IntValue | StringValue | ObjetValue
09:06:48 <birkenfeld> quicksilver: so what type is the Value?
09:06:56 <Axman6> > map (\n -> logBase 10 $ 1/(10**n)) [1..10]
09:06:56 <birkenfeld> hm, ok
09:06:57 <lambdabot>   [-0.9999999999999998,-1.9999999999999996,-2.9999999999999996,-3.99999999999...
09:07:11 <Axman6> > map (\n -> logBase 2 $ 1/(2**n)) [1..10]
09:07:13 <lambdabot>   [-1.0,-2.0,-3.0,-4.0,-5.0,-6.0,-7.0,-8.0,-9.0,-10.0]
09:07:22 <quicksilver> and Objects are something like a map from properties to values and a class
09:08:21 <quicksilver> (IntValue and StringValue as special cases may not be necessary, but it may be simpler or more efficient to have special cases for primitive types at some level)
09:08:53 <birkenfeld> hmm
09:09:16 <birkenfeld> so basically, when creating an object, you allocate a new ObjectID
09:09:50 <subconscious> What's the benefit of a single map with everything in it over ST?
09:10:51 <quicksilver> what's the benefit of using ST?
09:11:03 <quicksilver> using a map is simpler and more explicit
09:11:08 <quicksilver> those aren' huge benefits, I admit.
09:11:14 <subconscious> using ST is simpler :p
09:11:20 <quicksilver> how is using ST simpler?
09:13:53 <ToRA> slightly ot, but does anybody know the status of comboboxes with the nicer list/treemodel in gtk2hs?
09:13:58 <ToRA> i'm having problems gettng them to work
09:14:19 <dcoutts_> ToRA: not ottomh, you could ask on gtk2hs-devel
09:15:28 <ToRA> 'k
09:20:45 <pfo> (how) can i use a list comprehension to generate the interval [-1.0 1.0] in 0.01 increments?
09:21:16 <subconscious> > [ x | x <- [-1.0,-1.0+0.01,1.0] ]
09:21:17 <lambdabot>   [-1.0,-0.99,1.0]
09:21:19 <subconscious> > [ x | x <- [-1.0,-1.0+0.01..1.0] ]
09:21:21 <lambdabot>   [-1.0,-0.99,-0.98,-0.97,-0.96,-0.95,-0.94,-0.9299999999999999,-0.9199999999...
09:21:32 <pfo> nice, thx!
09:21:40 <subconscious> > [ x | x <- [-1.0,-1.0+0.01..1.0] ] ::CReal
09:21:41 <lambdabot>   Couldn't match expected type `CReal' against inferred type `[a]'
09:21:45 <subconscious> > [ x | x <- [-1.0,-1.0+0.01..1.0] ] ::[CReal]
09:21:49 <lambdabot>   [-1.0,-0.99,-0.98,-0.97,-0.96,-0.95,-0.94,-0.93,-0.92,-0.91,-0.9,-0.89,-0.8...
09:22:18 <Dybber> > [-1.0,-0.99..1.0]
09:22:19 <lambdabot>   [-1.0,-0.99,-0.98,-0.97,-0.96,-0.95,-0.94,-0.9299999999999999,-0.9199999999...
09:23:24 <Zao> If you want exactly 201 elements, you may want to consider some other method.
09:23:56 <Zao> Which that method produced anyway, meh.
09:23:57 <pfo> i just want to have discrete (2d) grid
09:25:13 <Axman6> map ((-1).(*0.01)) [1..201]
09:25:22 <Axman6> > map ((-1).(*0.01)) [1..201]
09:25:23 <lambdabot>       No instance for (Num (a -> c))
09:25:23 <lambdabot>        arising from a use of `negate' at...
09:25:35 <quicksilver> > [-1.0,-0.99..1.0] :: Rational
09:25:37 <lambdabot>   Couldn't match expected type `Rational' against inferred type `[a]'
09:25:40 <quicksilver> > [-1.0,-0.99..1.0] :: [Rational]
09:25:42 <lambdabot>   [(-1)%1,(-99)%100,(-49)%50,(-97)%100,(-24)%25,(-19)%20,(-47)%50,(-93)%100,(...
09:25:49 <quicksilver> Zao: that version should be exact.
09:25:57 <Axman6> > map (\n -> n*0.01-1) [1..201]
09:25:58 <lambdabot>   [-0.99,-0.98,-0.97,-0.96,-0.95,-0.94,-0.9299999999999999,-0.92,-0.91,-0.9,-...
09:26:00 <quicksilver> (you can then coerce it back to Duble if you wish)
09:26:04 <Axman6> > map (\n -> n*0.01-1) [0..201]
09:26:06 <lambdabot>   [-1.0,-0.99,-0.98,-0.97,-0.96,-0.95,-0.94,-0.9299999999999999,-0.92,-0.91,-...
09:37:01 <newsham> here's a fun program a friend wrote.  http://www.the-mathclub.net/site/code/synth.hs
09:37:29 <newsham> takes an input text file specifying notes and writes out audio data
09:39:36 <Beelsebob> isn't his frequency function broken?
09:39:53 <Beelsebob> i was under the impression that the notes were not evenly spaced in the octave... quite
09:40:07 <newsham> they are in the well tempered tuning, which is what we use in the west
09:40:39 <newsham> 12 notes evenly spaced between 1 and 2 on an exponential scale.
09:41:09 <lament> newsham: cute
09:41:37 <quicksilver> well, or evenly space in a geometrical scale
09:41:44 <quicksilver> depending which terminology you prefer :)
09:41:45 <quicksilver> but yes.
09:42:07 <quicksilver> doubling every octave, so 2^(1/12) per semitone
09:42:26 <newsham> unless you're into purity.  ;-)
09:42:30 <lament> (insert a long rant about how equal temperament has killed music)
09:42:36 <Beelsebob> I thought you had to deal with a pythagorian comma though
09:42:49 <lament> Beelsebob: no, it's in pythagorean tuning that you have to deal with the pythagorean comma
09:43:05 <newsham> then you get all sorts of wacked out rations of   n / (2^m)  for integers n and m, and their inverses
09:43:18 <newsham> ratios even
09:43:34 <quicksilver> Elf picks up a wacked out food ration.
09:43:37 <lament> the sad reality is that it never makes much sense to limit music to a tiny subset of possible pitches
09:43:42 <Beelsebob> hence why E sharp and D flat are the same note
09:44:24 <quicksilver> Beelsebob: that's not quite what you meant to say :)
09:44:24 <newsham> my synth has a setting that can change the temperament, and the pure tuning doesnt sound all that much different from the well tempered one
09:44:35 <Beelsebob> quicksilver: no, no it isn't
09:44:36 <Beelsebob> >.<
09:44:49 <newsham> of course if you were playing a song that modulates several times, it would sound horrid
09:45:03 <Beelsebob> lament: it makes sense when you have to be capable of reading the music at any kind of speed
09:45:10 <Beelsebob> but mostly I agree
09:45:12 <lament> the difference between the natural third and the equal-tempered third is definitely audible, i'd say by all the same people who can hear the difference between a third and a fourth
09:45:40 <newsham> yes, its audible, but its not a huge difference.
09:45:45 <newsham> also the minor 7th
09:46:17 <lament> no, it's not huge
09:46:35 <newsham> haskell purity > tonal purity
09:47:05 <lament> equal temperament is superior to any other system dividing the octave into 12 semitones...
09:47:16 <lament> despite what a bunch of nuts have to say about it...
09:47:40 <lament> but there's certainly a strong case for _not_ dividing the octave into anything quite so discrete
09:47:57 <lament> ...and playing the violin
09:47:57 <lunabot>   parse error on input `..'
09:48:17 <newsham> fretless guitar.
09:48:20 <lament> or that
09:48:29 <micahcowan> It's superior, until you modulate. :)
09:48:41 <newsham> violins modulate quite nicely
09:48:44 <lament> micahcowan: equal temperament is superior, _especially_ after you modulate
09:48:57 <lament> and violins don't have problems with modulation, most of the time
09:49:17 <newsham> violins have feedback systems
09:49:20 <Baughn> > show id
09:49:20 <newsham> in their control unit
09:49:21 <lambdabot>       Overlapping instances for Show (a -> a)
09:49:21 <lambdabot>        arising from a use of `s...
09:49:28 <lament> newsham: yeah, advanced circuitry!
09:49:37 <micahcowan> The best evolution can provide
09:51:54 <micahcowan> lament, sorry, I was speaking of perfect temperament, not equal, of course.
09:52:55 <Baughn> @instances Show
09:52:56 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
09:53:04 <lament> right, the case against perfect (or any other non-equal) temperament is that it restricts modulation
09:53:20 <lament> and the whole evolution of western music has been towards more modulation
09:53:27 <sebaseba>  I was following http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation, and I think there's a mistake in step in the 4th step from the last. Could somebody check?
09:53:28 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
09:53:35 <micahcowan> Though not so much, for violin. I'm a pianist, though, so perfect ain't gonna happen. :)
09:53:40 <lament> not that it matters in, say... rock
09:53:43 <sebaseba> *in the 4th from last step
09:53:45 <subconscious> why did you add a comma to the url :/
09:54:00 <sebaseba> sorry :/
09:54:03 <daf> newsham: neat!
09:54:03 <micahcowan> I read once that when violins play solo, they naturally play in just temperament (as opposed to when playing with a group, obviously).
09:54:39 <lament> micahcowan: some pianists tune have their pianos tuned to the approximate guess of what bach's well temperament would have been like, to play the well-tempered clavier
09:54:43 <lament> micahcowan: yes, that's true
09:55:59 <sebaseba> I believe the 4th to last step should be   getIt (magic 2 (1+(1+1))) (2-1)
09:56:19 <newsham> micahcowan: electronic keyboards can do pure tunings
09:57:28 <lament> newsham: it's only pure until the first modulation
09:57:45 <lament> which will happen a few notes into the music :)
09:57:57 <newsham> unless you're fast on the draw and change the tuning key.
09:58:13 <lament> unless you're playing punk rock or something
09:58:27 <lament> then it's quite feasible to stay in one tuning... :)
09:58:56 <newsham> if you're playing rock, you just need a chord organ with three buttons
10:02:26 <actor> can i do ["a".."z"] to generate the alphbet? no. but is there something similar?'
10:03:02 <ddarius> > ['a'..'z']
10:03:04 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
10:03:21 <Zao> That's a rather narrow alphabet.
10:04:33 <lament> > ['s'..'u']
10:04:34 <lambdabot>   "stu"
10:04:36 <actor> in china perhaps
10:04:49 <actor> ['i'..'i']
10:04:50 <micahcowan> ... shutdown from a "Critical ACPI trigger", batteries at 99%. WTF...
10:04:50 <Deewiant> > filter (liftM2 (&&) isLower isAscii) [minBound..maxBound]
10:04:50 <lunabot>   parse error on input `..'
10:04:52 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
10:05:14 <Deewiant> ^ much safer, makes sure you didn't typo and do ['a'..'y'] instead
10:05:33 <BMeph_> sebaseba: What's going to force the (1+1) to be evaluated, especially before it's even seen by 'magic'? :)
10:06:48 <actor> huh?
10:06:55 <actor> ['a'..'z']
10:06:56 <sebaseba> BMeph_: but it is seen my 'magic', since it must be expanded... no?
10:07:03 <sebaseba> *by
10:07:34 <sebaseba> BMeph_: because of the first pattern in magic:   magic 0 _ = []
10:08:09 <sebaseba> BMeph_: the (1+1) must be evaluated to see if it maches 0
10:10:40 <BMeph_> sebaseba: Hm, that's a good point. Why not at the fifth-to-last, then? ;)
10:16:05 <BMeph_> sebaseba: ...no, never mind, you got it right. Nice! :)
10:18:13 <sebaseba> BMeph: great, then I
10:18:20 <sebaseba> l'll correct the wiki
10:18:27 <sebaseba> thanks!
10:26:43 <micahcowan> Is exception handling an extension over Haskell 98?
10:28:26 <micahcowan> n/m, it's right there in "Extensions to Haskell 98".
10:30:31 <ddarius> micahcowan: Some of it is, not all of it.
10:31:00 <micahcowan> ddarius, right, AFAICT, basic IO exceptions are Haskell 98, the rest is an extension?
10:31:22 <ddarius> micahcowan: Catching anything but IO exceptions is as well as generating some of them.
10:32:32 <thoughtpolice> dons: I think I'm going to demo xmonad tomorrow at a CS meeting. i just got it up and running in my archlinux virtual machine and it's nice and how I like it. :]
10:33:44 <thoughtpolice> (critera is it to be "bring your favorite app" and xmonad is one of them. i would use it on OS X if it was just less hassle.)
10:34:11 <mc__> thoughtpolice: would it be possible?
10:34:42 <thoughtpolice> mc__: it's been done
10:35:28 <thoughtpolice> the problem is you can't get fullscreen with the stock leopard X11 distro because it's slightly broken in that respect, so if you want that you have to use tiger's X11, and on top of that it can only manage x11 apps naturally, nothing aqua based, so you'd have to rebuild a lot of stuff from source against X11
10:35:46 <thoughtpolice> (by fullscreen I mean cover up the menu bar and the dock)
10:36:21 <mc__> there is no way to get a wm to manage aqua windows, is there?
10:36:49 <thoughtpolice> doubtful, but you'd have to ask someone who knows more about that particular koolaid for a more accurate answer
10:37:34 <thoughtpolice> mc__: but it's totally doable. i will say the first new computer I get and put linux on will have xmonad there pronto.
10:39:09 <Baughn> thoughtpolice: Or you can install a newer X11 package; they're being updated regularly
10:39:15 <Baughn> The one that comes with leopard is broken, yes
10:39:16 <shepheb> xmonad can be made to run on OSX, but it'll only manage X windows, not aqua ones.
10:39:28 <Baughn> ..in so many ways. Now if only they'd fix opengl...
10:39:29 <lunabot>   parse error on input `in'
10:39:38 <Baughn> lunabot: Stop responding to "."
10:40:09 <dolio> Stop beginning your messages with periods. :)
10:40:17 <Baughn> ..no
10:40:18 <lunabot>   Not in scope: `no'
10:40:52 <Zao> "..." is quite a valid "sentence" on IRC :)
10:41:01 <Baughn> ...
10:41:02 <lunabot>   parse error on input `..'
10:41:21 <sebaseba> is there a tool I can use to see all the intermediate evaluation steps for an expression?
10:41:25 <FunctorSalad> will Data.Map fail horribly if the Ord instance is not antisymmetrical or will it just be more inefficient?
10:41:58 <Baughn> Right. Anyhow. Not having a 64-bit os x machine at hand (I get it in a week), is the package on haskell.org/ghc 64-bit-capable? Alternately, does it compile cleanly in 64-bit mode?
10:42:16 <FunctorSalad> (for values containing functions it's hard to give a antisym. ord instance)
10:42:46 <Baughn> FunctorSalad: Ah. Define antisymmetric?
10:43:09 <zachk> how do i convert an Int to a Double, in haskell?
10:43:18 <Beelsebob> zachk: fromIntegral
10:43:30 <FunctorSalad> Baughn: that it's not possible that x <= y and y <= x, unless y=x
10:43:31 <Baughn> > fromIntegral (2::Int) :: Double
10:43:32 <lambdabot>   2.0
10:43:46 <zachk> thank beelsebob
10:43:49 <zachk> you
10:44:11 <Baughn> FunctorSalad: So, it might be cyclical. Hmm..
10:44:17 <dolio> So your ordering has an x and y such that x > y and y > x?
10:44:18 <Baughn> FunctorSalad: I think it'll fail horribly.
10:44:35 <FunctorSalad> Baughn: hmm, since this depends on the Eq instance maybe I should ask instead: "is it bad if the Eq instance considers things equal that aren't identical for your purposes"
10:44:36 <dolio> What happens for 'compare x y'?
10:45:27 <Baughn> FunctorSalad: Well, it'd overwrite x with y, at least
10:45:34 <FunctorSalad> dolio: say I have data X = X (Int -> Int) String and want to derive Eq and Ord for it
10:45:45 <Baughn> FunctorSalad: It might work. It might not. It depends on the internals of map.
10:45:48 <FunctorSalad> now I need to store Xs in a Map or Set
10:45:48 <Baughn> I sure wouldn't want to try it.
10:46:11 <dolio> So it compares only based on the string?
10:46:14 <FunctorSalad> but I can't Eq or Ord the function, so I have to compare on the String and hope that there aren't to values with same string and different function
10:46:25 <Baughn> FunctorSalad: If that hope is /correct/, then you'll be fine
10:46:38 <dolio> That's not really antisymmetric, is it?
10:46:57 <zachk> say I need printFbutToString to save the string for latter IO action, how coud that be done
10:47:04 <dolio> Unless your "=" is totally removed from your "<=".
10:47:11 <FunctorSalad> dolio: well, it is antisymmetric with respect to the Eq instance which is also coarse :)
10:47:15 <dolio> That is, you're referring to some "=" that you can't even compute.
10:47:22 <FunctorSalad> yeah
10:47:32 <FunctorSalad> it's not antisymmetric with respect to bit-identity or whatever
10:47:47 <dolio> Well your = can't examine the function, either.
10:47:52 <dolio> Eq, that is.
10:48:34 <FunctorSalad> dolio: yes, that's what I was trying to say. if we take (==) = (==) `on` string and compare = compare `on` string, ...
10:48:35 <dolio> I don't think Map/Set takes Eq into account, though. I suspect it uses either just compare or <=.
10:48:57 <dolio> Probably compare.
10:49:04 <FunctorSalad> then compare is antisym. w.r.t. (==) but (==) identifies things that might logically be distinct
10:49:37 <FunctorSalad> I guess I'll have to tag the X with a unique Int or something then
10:50:40 <dolio> Yeah. If you can have values with the same string, but different functions, but want them to be treated distinctly, you need some other method to distinguish them.
10:51:04 <dolio> Of course, with a unique int, you could have the same function and string, but different ints.
10:51:26 <dolio> Technically you can decide equality on Int -> Int. It just takes a while. :)
10:51:46 <FunctorSalad> hehe, because it's finite?
10:51:54 <dolio> Yeah. Finite domain.
10:52:38 <dolio> And decidable equality on the range, of course.
10:52:59 <mattam> FunctorSalad: well, I had a similar concern with [Set.map], does it supposes you give order-preserving maps?
10:53:32 <dolio> Of course, I'm not sure you can order them...
10:53:38 <FunctorSalad> mattam: interesting, haven't thought about that... it would allow a more efficient impl
10:53:48 <FunctorSalad> mattam: there *is* a "fromAscList" constructor
10:53:52 <FunctorSalad> ("ascending")
10:54:29 <FunctorSalad> dolio: extensionally (Int -> Int) is finite too
10:54:47 <mattam> Yep. I'm thinking about it because I wrote a Set interface in Coq with setoids, and I considered requiring that property. I guess Haskell's set uses a fold + add but who knows.
10:55:22 <FunctorSalad> mattam: you could check order-preservingness in O(size(first set)) though
10:55:48 <mattam> Hmmm
10:55:52 <FunctorSalad> mattam: or you could just make a "map" and a "mapMonotonous" function
10:57:24 <kosmikus> I'd prefer the latter. It makes sense to map non-order-preserving functions on a set. But it would be nice to have a more efficient, more restricted algorithm available if desired.
10:57:37 <mattam> FunctorSalad: that's actually the case! http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Set.html#v%3AmapMonotonic
10:57:46 <FunctorSalad> mattam: hehe
10:58:02 <kosmikus> good :)
11:00:02 <dolio> > let [u,l] = map toInteger ([maxBound, minBound :: [Int]) ; s = u - l in s ^ s
11:00:04 <lambdabot>   mueval: Prelude.read: no parse
11:00:15 <dolio> > let [u,l] = map toInteger ([maxBound, minBound] :: [Int]) ; s = u - l in s ^ s
11:00:31 <lambdabot>   thread killed
11:05:25 <pcc1> can anyone explain why I get this error: http://hpaste.org/10454
11:07:07 <dolio> Redacted5 probably needs RankNTypes to work.
11:07:18 <dolio> Or, Rank2Types, at least.
11:13:39 <dolio> For instance, the type "Redacted5 -> Foo" is actually an alias for "(forall m. (Monad m) => Redacted1 m -> Redacted4 -> m Redacted4) -> Foo"
11:14:27 <matthew-_> hmm. photos have started appearing
11:14:32 <matthew-_> agh, ww, sorry
11:15:15 <pcc1> hmm, I will only need to use that type on its own, is there a workaround? would rather not have to use a fixed monad
11:16:11 <dolio> I believe the way around it would be to make it 'type Redacted5 m = Redacted1 m -> Redacted4 -> m Redacted4'
11:16:23 <dolio> Then you can write types like '(Monad m) => Redacted5 m'.
11:16:27 <dolio> If that's what you want.
11:16:42 <pcc1> ok, will see if that can work, thanks
11:16:43 <dolio> I'm not sure there's any way to bake the monad constraint into Redacted5.
11:24:44 <dpiponi> Anyone here work at google?
11:26:52 <dolio> I thought there was a google guy who hung out in #haskell-blah sometimes.
11:28:39 <pcc1> if I have a value of type (Monad m) => Redacted5 m is it safe to coerce into Redacted5 IO ?
11:29:23 <dolio> Coerce?
11:29:46 <micahcowan> Does NHC98 lack support for the hierarchical modules proto-extension?
11:30:16 <pcc1> the value is initially untyped as it comes from a plugin (hs-plugins).  I need to cast it to the appropriate type, but the "correct" type gives me the error message I showed you before
11:32:39 <dolio> Redacted5 IO is just a specialization of (Monad m) => Redacted5 m. I wouldn't expect any coercion to be necessary.
11:33:24 <pcc1> yes sure, but the implementation needs to be able to handle that I'm lying about the correct type of the function
11:42:56 <mmorrow> @seen Saizan
11:42:57 <lambdabot> Saizan is in #darcs, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan speak 22m 23s ago.
11:43:08 <mmorrow> Saizan: yo
11:44:05 <actor> @seen mmorrow
11:44:05 <lambdabot> mmorrow is in #haskell, #darcs and #ghc. I last heard mmorrow speak 57s ago.
11:44:20 <actor> @seen actor
11:44:20 <lambdabot> You are in #haskell. I last heard you speak just now.
11:44:32 <actor> @seen actor
11:44:32 <lambdabot> You are in #haskell. I last heard you speak just now.
11:45:22 <mmorrow> @seen lambdabot
11:45:22 <lambdabot> Yes, I'm here. I'm in #math, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it,
11:45:22 <lambdabot>  #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-
11:45:22 <lambdabot> uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
11:45:55 <pastorn_> that's quite a lot
11:55:50 <actor>  deriving (Eq, Ord, Show)
11:55:59 <actor> do i always have to do that?
11:56:48 <sw17ch> actor: if you want instances of Eq, Ord, and Show derived for you ...
11:57:11 <actor> but i could do show sometype without hvaing derived show
11:57:34 <actor> lambdabot when do you estimate that you will become slefaware?
11:57:38 <actor> are you already?
11:57:43 <actor> @lambdabot
11:57:44 <lambdabot> Unknown command, try @list
11:57:52 <sw17ch> actor: do you have an example?
11:57:55 <actor> @quote lambdabot
11:57:55 <lambdabot> lambdabot says: Listen, broccoli brains, I don't have time to listen to this trash.
11:58:22 <actor> data Car = Car { brand :: String, year  :: Int, plate :: String }
11:58:40 <actor> and why do i have to delcare Car on both sides?
11:58:58 <Botje> the left side is your type
11:59:05 <dibblego> actor, the left side is the data type declaration and the right side is the constructor name, you can name each whatever you like
11:59:06 <Botje> the right side is your data constructor
11:59:18 <Botje> you could have data Car = Wreck { brand ..... }
11:59:21 <actor> wait now is ee the difference
11:59:21 <BMeph_> actor: The first Car is the name of your data type. The second is the name of your type constructor. :)
11:59:37 <actor> diff with show i mean
11:59:56 <sw17ch> actor: data Car = MakeMeACar { brand ... }
11:59:59 <actor> what is eq nd ord? i guess equality and order? but how are they used?
12:00:03 <sw17ch> left == type, right == constructor
12:00:17 <dibblego> actor, Eq gives you == and /= while Ord gives you <, > and others
12:00:21 <actor> if i do sort [Car] can i say what element to sort on?
12:00:22 <dibblego> > 7 == 8
12:00:23 <lambdabot>   False
12:00:30 <dibblego> > 7 < 8
12:00:31 <Botje> actor: try typing :info Ord in your hugs or ghci
12:00:31 <lambdabot>   True
12:00:38 <sw17ch> @index orderBy
12:00:38 <lambdabot> bzzt
12:00:41 <sw17ch> dangit...
12:00:47 <sw17ch> is there an orderBy?
12:00:50 <actor> data Car_ =
12:00:50 <actor>     Brand | Year | Plate
12:00:57 <dibblego> sw17ch, compare?
12:01:01 <Botje> that will give you the declaration of those typeclasses, which methods they need, and which instances they have
12:01:02 <actor> i saw that definition, but i dont get how to construct it
12:01:08 <Botje> sw17ch: there's a sortBy in Data.List
12:01:16 <sw17ch> Botje: yes, that's the one
12:01:31 <Botje> actor: you can use compare and sortBy
12:01:52 <Botje> sortBy (\a b -> (brand a) `compare` (brand b)) list_of_cars
12:02:03 <Botje> or what people here generally do: sortBy (compare `on` brand)
12:02:13 <Deewiant> or even better: sortBy (comparing brand)
12:03:41 <Botje> both have merits
12:03:53 <Botje> I've had to define both comparing and equating (for groupBy) a lot
12:04:02 <Botje> whereas you can just do (cpùâre
12:04:05 <Botje> argh
12:04:15 <Botje> whereas you can just do compare `on` and (==) `on`
12:06:24 <Deewiant> ?src comparing
12:06:24 <lambdabot> Source not found. :(
12:06:37 <Deewiant> bah
12:06:49 <Deewiant> well anyway, comparing p = compare `on` p
12:07:07 <dibblego> @type (compare `on`)
12:07:09 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
12:07:18 <Deewiant> @type comparing
12:07:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:07:39 <Deewiant> hm, equating isn't in base
12:07:57 <Botje> well, yeah
12:08:02 <Saizan> uhm we should have uniqueness typing to make hGetContents safe
12:08:07 <dcoutts_> Deewiant: but it should be!!
12:08:11 <Botje> I used to define comparing f a b = (f a) `compare` f b
12:08:18 <Botje> with appropriate parens
12:08:35 <dcoutts_> but I got shot down when proposing we add Data.Eq.equating to match Data.Ord.comparing
12:08:42 <dcoutts_> I might try again
12:09:05 <Deewiant> do try
12:09:14 <Deewiant> ?ty do try
12:09:15 <lambdabot> Not in scope: `try'
12:09:20 <dcoutts_> Deewiant: I'll need more people to support it this time
12:09:24 <Deewiant> ?ty do Control.Exception.try
12:09:25 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
12:09:38 <dolio> Counter proposal: remove comparing!
12:09:39 <Deewiant> dcoutts_: was there opposition, then? O_o
12:09:40 <dibblego> dcoutts, I will
12:10:07 <dcoutts_> Deewiant: yes, some people said we should deprecate equating and always use (==) or compare `on` f
12:10:08 <birkenfeld> Botje: does "comparing" calculate (p x) once per item or once per comparison?
12:10:37 <dcoutts_> but groupBy ((==) `on` fieldFoo) just is not as nice as groupBy (equating fieldFoo)
12:10:42 <dolio> fooBy generally computes once per comparison.
12:10:49 <dcoutts_> dibblego: thanks
12:12:00 <Botje> birkenfeld: once per comparison, unfortunately.
12:12:12 <Botje> birkenfeld: you can use a schwartzian transform to good effect, though
12:12:13 <birkenfeld> wouldn't it make sense to provide a DSU-style sort?
12:12:29 <dcoutts_> DSU-style?
12:12:45 <birkenfeld> ah sorry, short for "decorate-sort-undecorate"
12:12:52 <birkenfeld> which means just schwartzian transform :)
12:13:06 <Botje> it's easily written, though
12:13:14 <Deewiant> ?ty \p -> sortBy (comparing p)
12:13:15 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
12:13:18 <Deewiant> ?ty \p -> map fst . sortBy (comparing snd) . map (ap (,) p)
12:13:19 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
12:13:20 <dcoutts_> ah, like map snd . sort .map (\x -> (f x, x))
12:13:29 <Botje> map snd . sortBy (comparing fst) . map (ap (,) f)
12:13:37 * SamB_XP gets out his schwartz and gets it tangled with birkenfeld's
12:14:00 * birkenfeld steps on SamB_XP's knee
12:14:52 <SamB_XP> I guess the schwartz wasn't with me ?
12:15:27 <SamB_XP> oh, wait, that was actually my stunt double
12:16:15 * birkenfeld tries to sort out map (ap (,) f)
12:16:27 <djsiegel> http://hpaste.org/10456 -- can someone help me figure out why the line with getDirectoryContents causes a discrepancy between the inferred IO [FilePath] and the inferred type a -> a1 ?
12:16:50 <djsiegel> *expetected type IO [FilePath] and inferred type a -> a1 ?
12:17:52 <dolio> Precedence issues.
12:18:09 <Deewiant> $!
12:18:27 <dolio> "... >>= mapM_ $ \f -> ..." is (... >>= mapM) (\f -> ...)
12:18:30 <SamB_XP> I hope they fix that damn fixity ...
12:18:45 <dolio> Not (...) >>= mapM_ (\f -> ...)
12:18:52 <Deewiant> > fix ($)
12:18:53 <lambdabot>       Overlapping instances for Show (a -> b)
12:18:53 <lambdabot>        arising from a use of `s...
12:18:57 <Deewiant> :-/
12:19:02 <birkenfeld> hmm, what is preferable:  (id &&& f)  or  (ap (,) f)  ?
12:19:07 <SamB_XP> Deewiant: no, not fix ($)
12:19:25 <Deewiant> SamB_XP: fix (>>=) ?
12:19:36 <SamB_XP> I hope they CHANGE the fixity declarations for ($) and ($!)
12:19:44 <lament> SamB_XP: vote Obama!
12:19:46 <Deewiant> heh
12:19:49 <SamB_XP> this has nothing to do with function applications
12:19:57 <djsiegel> thanks dolio, will try that
12:20:01 <SamB_XP> lament: how do I vote for people to be on the Haskell committee?
12:20:03 <micahcowan> What does the Prec in showsPrec and readsPrec stand for?
12:20:15 <SamB_XP> I didn't know Obama was interested in being on the committee, anyway
12:20:17 <micahcowan> "Preceding" portion of the string?
12:20:21 <sioraioc_> SamB_XP: Obama brings all hope and change, DUH
12:20:21 <Igloo> Precedence
12:20:25 <dolio> Operator precedence.
12:20:25 <SamB_XP> I thought he wanted to be US president!
12:20:29 <micahcowan> Doh, yeah, okay.
12:20:36 <SamB_XP> he won't have time for Haskell at the same time!
12:20:54 <sioraioc_> SamB_XP: It doesn't matter, his general Hope and Changeiness will radiate out to Haskell
12:21:20 <sioraioc_> from the white aura surrounding him
12:21:40 <dolio> It gets passed in the lowest precedence that your operator has to be to not require parentheses to not conflict with the stuff around it.
12:21:45 <dolio> (I think that's right.)
12:22:52 <birkenfeld> I gather there's no preference :)
12:23:30 <dolio> id &&& f is probably marginally less obscure.
12:23:59 <birkenfeld> I'll never really get the (-> r) monad
12:24:11 <Heffalump> it's the simplest one!
12:24:17 <Heffalump> well, after Identity
12:24:24 <birkenfeld> hmm
12:24:28 <birkenfeld> Maybe!
12:24:30 <SamB_XP> Heffalump: well, it's also rather easy to get confused about
12:24:41 <Heffalump> just think of it as providing a global constant.
12:24:42 <SamB_XP> perhaps he'd find the Reader monad easier to understand ;-)
12:24:56 <SamB_XP> the types are a bit clearer there
12:25:15 <birkenfeld> well, I at least understood what it does
12:25:32 <Heffalump> which, Reader?
12:25:35 <birkenfeld> ye
12:25:36 <birkenfeld> s
12:25:45 <Heffalump> (->) r is just stripping off the newtype wrapper
12:26:15 <SamB_XP> Heffalump: which, unsurprisingly, makes it easier to get things confused in one's head
12:26:22 <Heffalump> that is true
12:27:17 <birkenfeld> ok, the "global constant" picture helps a bit
12:27:43 <dolio> Looking at (->) r as a global constant monad doesn't exactly make it easy to figure out that ap is the S combinator.
12:28:08 <birkenfeld> perhaps, if I knew the S combinator
12:28:27 <dolio> Sfgx = fx(gx)
12:28:33 <dibblego> S is the Applicative for ((->) r) or the ap function
12:28:54 <dibblego> @type ap
12:28:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:28:57 <birkenfeld> hmm, it seems like hayoo doesn't find record accessor names
12:29:07 <dibblego> (r -> a -> b) -> (r -> a) -> (r -> b)
12:29:08 <SamB_XP> hayoo?
12:29:15 <SamB_XP> is that a hoogle compettitor ?
12:29:22 <birkenfeld> looks like
12:29:23 <birkenfeld> http://holumbus.fh-wedel.de/hayoo/hayoo.html
12:29:23 <dolio> Where have you been?
12:29:29 <lambdabot> Title: Hayoo!
12:29:39 <Deewiant> hayoo searches hackage
12:29:51 <SamB_XP> when do we get Haskell Live Search ?
12:30:03 <actor> anyone know Scala? would it be possible to have a typesystem liek Haskells in Scala? I mostly mean so you don't hve to declare every variable
12:30:05 <Deewiant> Hive Search?
12:30:15 <actor> or haskells typesystem is very tied to puroty?
12:30:18 <actor> purity?
12:30:22 <dibblego> actor, yes I know Scala, no its type system is nowhere near as clever as Haskell
12:30:27 <subconscious> actor: no, purity isn't related
12:30:34 <SamB_XP> actor: the typesystem is not tied to purity
12:30:38 <actor> it is so much typing, feels so primitive
12:30:48 <SamB_XP> but purity sure works better with such a nice typesystem
12:30:58 <actor> declare this, declare that. but otherwise nice language, nice compromise
12:30:59 <Apocalisp> Scala does have marginal type inference
12:31:07 <stepcut> is there a shorthand for (`mplus` mzero) in this expression, ((return $ Just 1) `mplus` mzero)
12:31:21 <SamB_XP> stepcut: uh ...
12:31:23 <dolio> Yes. Remove it. :)
12:31:24 <SamB_XP>  how a bout )
12:31:26 <subconscious> > ((return $ Just 1) `mplus` mzero)
12:31:26 <Twey> Isn't that a no-op?
12:31:27 <lambdabot>       No instance for (Show (m (Maybe t)))
12:31:27 <lambdabot>        arising from a use of `show...
12:31:28 <Twey> Heh
12:31:30 <dibblego> `mplus` mzero is identity?
12:31:34 <Twey> Aye
12:31:36 <subconscious> > ((return $ Just 1) `mplus` mzero) :: [Maybe Integer]
12:31:37 <lambdabot>   [Just 1]
12:31:42 <subconscious> > (return $ Just 1) :: [Maybe Integer]
12:31:43 <lambdabot>   [Just 1]
12:31:55 <SamB_XP> didn't they tell you the Monoid laws?
12:31:55 <stepcut> ok, what I actually have is: (Just <$> lookRead "prevSubExprNum") `mplus` mzero :: RqData (Maybe Int)
12:32:17 <dibblego> stepcut, instead of writing 7, do you write 7 + 0?
12:32:28 <Twey> (Just <$> lookRead "prevSubExprNum") :: RqData (Maybe Int)
12:32:49 <subconscious> :t (Just <$>)
12:32:50 <stepcut> normally lookRead will fail if prevSubExprNum does not exist, but I want to modify it to return a maybe value instead
12:32:50 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (Maybe a)
12:33:16 * stepcut supposes he should see what the current code actually does when it is run
12:33:47 <SamB_XP> stepcut: if that `mplus` mzero actually does something, the Monoid is broken
12:33:57 <stepcut> SamB_XP: yes, something felt funny
12:34:10 <Saizan> stepcut: you want it to return Nothing instead of failing in the RqData monad?
12:34:11 <subconscious> @src Monoid
12:34:12 <lambdabot> class Monoid a where
12:34:12 <lambdabot>     mempty  :: a
12:34:12 <lambdabot>     mappend :: a -> a -> a
12:34:12 <lambdabot>     mconcat :: [a] -> a
12:34:16 <stepcut> Saizan: yes
12:34:26 <subconscious> @src MonadPlus
12:34:26 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:34:33 <Saizan> stepcut: then it's `mplus` return Nothing
12:34:39 <subconscious> :t mplus
12:34:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:34:59 <stepcut> Saizan: shouldn't, mzero == return Nothing ?
12:35:05 <Saizan> no
12:35:16 <Saizan> Nothing here is the result of the action
12:35:20 <Saizan> not part of the monad
12:35:50 <Saizan> even if RqData might be implemented with MaybeT or anything related
12:36:18 <Twey> stepcut: (return Nothing :: Maybe a) == Just Nothing
12:36:36 <Saizan> ?ty return Nothing
12:36:37 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a)
12:37:13 <SamB_XP> > mzero == Nothing
12:37:14 <lambdabot>   True
12:37:22 <SamB_XP> > mzero == return Nothing
12:37:23 <lambdabot>       No instance for (Eq (m (Maybe a)))
12:37:23 <lambdabot>        arising from a use of `==' at...
12:37:38 <SamB_XP> > mzero == return Nothing :: [Maybe a]
12:37:39 <lambdabot>   Couldn't match expected type `[Maybe a]'
12:37:46 <SamB_XP> > mzero == (return Nothing :: [Maybe a])
12:37:47 <lambdabot>   False
12:38:55 * SamB_XP wonders if it would be possible to set the cordless phones in his house to play different instrument's parts in the same song ...
12:40:18 <stepcut> ok, the universe is safe. (`mplus` mzero) does not work, but (`mplus` (return Nothing)) does ;)
12:40:45 <subconscious> > Nothing `mplus` (return Nothing)
12:40:46 <lambdabot>   Just Nothing
12:41:34 <stepcut> and, of course, (`mplus` (return mzero)), works
12:41:50 <pcc1> ok, my copy of ghc seems to have forgotten what "forall" means: > :t (undefined :: forall a. a) <interactive>:1:22: Illegal operator `.' in type `forall a . a' (Use -XTypeOperators to allow operators in types)
12:42:20 <stepcut> pcc1: forall is not H98, so you have to enable it
12:42:38 <Saizan> pcc1: use -fglasgow-exts or -XRank2Types or -XExistentialQuantification or ..
12:42:57 <pcc1> there's an -XRank2Types ???
12:43:31 <Saizan> -X can be followed by any language extension keyword
12:44:02 <Saizan> but you usually set those with {-# LANGUAGE .. #-} pragmas at the top of your module
12:45:08 <pcc1> no, someone was talking about Rank2Types before, googled it, found this: http://hackage.haskell.org/trac/haskell-prime/ticket/60 , assumed it didn't exist, completely redid part of my impl
12:45:10 <lambdabot> Title: #60 (add RankNTypes or Rank2Types) - Haskell Prime - Trac
12:46:58 <Saizan> pcc1: http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html <-- ghc supports all those
12:47:00 <lambdabot> Title: Language.Haskell.Extension, http://tinyurl.com/2c2g5y
12:47:09 <SamB_XP> pcc1: many of the things suggested for haskell prime are already implemented in GHC ;-P
12:47:25 <dcoutts_> Saizan: well, almost all of them :-)
12:47:53 <SamB_XP> dcoutts: which ones doesn't it support ?
12:48:39 <Saizan> i can spot ExtensibleRecords
12:48:55 <dcoutts_> and HereDocuments
12:49:07 <Valodim> dons: in the Data.ByteString documentation, there is an alternate definition of split given as split == splitWith . (==)
12:49:18 <dcoutts_> and there's one that it didn't but may do now to do with records and {...} syntax
12:49:22 <Valodim> shouldn't it be split == splitWith (==)
12:50:07 <dcoutts_> Valodim: yes
12:50:24 <dolio> No it shouldn't, should it?
12:50:40 <Valodim> with that dot it would be like, compare first then splitWith
12:50:40 <dcoutts_> oh, hmm
12:50:45 <dolio> splitWith . (==) = \c -> splitWith (c==)
12:50:47 <Valodim> which doesn't make sense :P
12:50:50 <dcoutts_> split c == splitWith (==c)
12:50:55 <dcoutts_> split == splitWith . (==)
12:51:08 <dcoutts_> erm too many ==, but you get the idea
12:51:15 <Valodim> ..thinking..
12:51:16 <lunabot>   parse error on input `..'
12:51:22 <Deewiant> ...
12:51:23 <lunabot>   parse error on input `..'
12:51:28 <dcoutts_> hah
12:51:43 <olsner> hmm, is (x - y `div` z) == (div (x-y) z) or (x - (div y z))?
12:51:57 <Saizan> the latter
12:51:58 <olsner> > (5 - 5 `div` 5)
12:51:59 <lambdabot>   4
12:52:05 <olsner> ok
12:52:42 <jinjing> @bot
12:52:42 <lambdabot> :)
12:57:42 <hackage> Uploaded to hackage: haskeline 0.3.1
12:59:34 <pcc1> what's the difference between T -> Maybe a and T -> forall a. Maybe a
12:59:58 <subconscious> the forall a. :?
13:00:11 <Heffalump> pcc1: nothing, if the type is at top-level
13:00:25 <Heffalump> since the first type is implicitly quantified over any free type variables
13:00:46 <Heffalump> and a forall in result position can be moved to scope over the whole type if the variable isn't free in any other parts of the type
13:01:11 <Heffalump> it's rather different if there's a type variable 'a' in scope
13:07:15 <olsner> @index add
13:07:15 <lambdabot> bzzt
13:07:20 <olsner> > add 3 4
13:07:21 <lambdabot>   mueval: Prelude.read: no parse
13:20:13 <waynemokane> hi, has anyone run into this error when building ghc?  "timer_create: Invalid argument"
13:20:33 <stepcut> waynemokane: there was a thread about that recently on haskell-cafe
13:22:06 <stepcut> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-March/014498.html
13:22:09 <lambdabot> Title: timer_create, http://tinyurl.com/4z8zgh
13:22:48 <dcoutts_> waynemokane: it's because the ghc binary you've got was built for a newer kernel, try the binary for ghc-6.8.2 instead
13:23:32 <SamB_XP> why are we building for specific kernels ?
13:24:10 <dcoutts_> SamB_XP: we're not but if you build with glibc-2.4 for example then it uses stuff that will not work with glibc-2.3
13:24:24 <waynemokane> ok, well I am trying to build this x86_64 "unknown linux" and getting it
13:24:37 <SamB_XP> oh?
13:24:38 <waynemokane> if I have a working build 6.6.1, should I use that to try to build 6.8.3 from source, instead?
13:24:43 <SamB_XP> why?
13:24:45 <dcoutts_> waynemokane: yes
13:24:51 <waynemokane> ok, I'll try that first
13:24:53 <dcoutts_> waynemokane: or use the binary from 6.8.2
13:25:18 <waynemokane> dcoutts_: ok, haven't even dl'ed that yet...but will keep it in mind as an opion
13:25:20 <waynemokane> thanks
13:25:57 <dcoutts_> SamB_XP: I think it's possible to specifically say that you do not want to use the later stuff I think if you define something or other to compile it against current C lib headers but have it work with older C libs
13:26:15 <dcoutts_> SamB_XP: but it's certainly not the default
13:26:57 <dcoutts_> SamB_XP: also, whenever you have ./configure tests for features and you build it on the latest stuff, then that binary it's not going to work on an older system without that stuff
13:27:44 <dcoutts_> SamB_XP: so in this case it's something like there's a configure test for the newer funky timers which get used if available, but then if you build on a current machine and deploy to an older then you're stuffed
13:28:10 <waynemokane> crap... seems like this is stopping me from building 6.8.3 from source, as well
13:28:20 <waynemokane> checking for path to top of build tree... pwd: timer_create: Invalid argument
13:28:36 <waynemokane> does that mean by ghc 6.6.1 binary is actually built for a newer kernel as well?
13:29:32 <dcoutts_> waynemokane: so you downloaded the 6.8.3 source tarball and it gives that problem?
13:30:29 <dcoutts_> waynemokane: the problem you describe is more what I'd expect from the 6.8.3 binary tarball
13:31:28 <dons> http://www.reddit.com/r/programming/comments/720q3/parsing_the_linux_kernel_with_haskell_experience/
13:31:30 <lambdabot> Title: Parsing the Linux kernel with Haskell: experience with Language.C : programming, http://tinyurl.com/4tuzww
13:31:31 <dons> woot!
13:33:15 <dcoutts_> dons: he shouldn't be amazed, I'd done that test already and fixed all the bugs :-)
13:33:25 <dons> :)
13:33:28 <dcoutts_> (and there were several)
13:33:38 <dons> dcoutts_: we can buy you a beer .
13:33:42 <dcoutts_> yay
13:33:52 <dons> i think the static analysis team is keen to move off CIL
13:33:55 <dcoutts_> dons: I found some pretty scary code actually :-)
13:34:08 <dcoutts_> old style gnu static array and struct initialisers
13:34:11 <jinjing> you can compile C with haskell?
13:34:34 <dcoutts_> dons: hmm, that's interesting, I thought CIL was supposed to be the thing
13:34:37 <subconscious> Can you interpret C in haskell?
13:34:43 <Heffalump> not yet :-)
13:34:48 <dcoutts_> dunno, but you can parse it
13:35:02 <Heffalump> shouldn't be that hard
13:35:19 <Heffalump> (if you don't care about speed)
13:35:25 <dons> dcoutts_: the slow.
13:35:34 <dcoutts_> dons: I'd not seen those performance numbers before, only 3x slower vs gcc is pretty good
13:35:50 <dons> yup. and there's tuning to be done i think.
13:35:54 <dons> gcc has had some time to prepare :)
13:36:13 <dcoutts_> yeah, when I did the first version I was still using a String lexer
13:36:29 <mbeddoe> i have an IO heavy program that does some log file processing and i'm benchmarking it on a few different machines.  On my macbook pro, it takes 11 seconds.  On this AMD computer it takes 5 minutes.
13:36:31 <TomMD> dcoutts: hackage-server still doesn't actually read/use the htpasswd files, right?  I noticed a lot of patches but my quick test was a no go.
13:36:34 <mbeddoe> has anyone seen anything ridiculous like that before?
13:36:39 <mbeddoe> both ghc 6.8.3
13:36:40 <dcoutts_> dons: I think the current Language.C uses a ByteString lexer, but I'm sure there's still improvements to be made there
13:36:45 <subconscious> mbeddoe: Yes, loads of times
13:36:52 <mbeddoe> have you tracked it down?
13:37:04 <dcoutts_> TomMD: it can import it with --import-accounts or something
13:37:12 <subconscious> mbeddoe: by that I just mean loads of people have had problems with log parsing and mentioned it in here
13:37:19 <mbeddoe> i see
13:37:22 <subconscious> mbeddoe: they should all write a wiki page or something
13:37:26 <mbeddoe> hehe
13:37:26 <dons> mbeddoe: using lazy bytestrings?
13:37:29 <mbeddoe> yes dons
13:37:37 <dons> good. compiled with -O2 ?
13:37:39 <mbeddoe> yes
13:37:44 <dons> ok.so then it comes down to algorithms and libraries.
13:37:53 <dons> i.e. what you're actually doing to the stream
13:37:59 <mbeddoe> so i'll pastebin the code
13:38:03 <mbeddoe> it's not the best haskell code in the world
13:38:10 <mbeddoe> but i wouldn't expect it to take more than 2x the time on a different computer
13:38:26 <dons> yeah. might be the version of the bytestring library varying?
13:38:29 <TomMD> dcoutts_: That fails for me - I'll play with it some more.
13:38:32 <mbeddoe> that is what thought
13:38:34 <dons> using 0.9.1.2 on both machines?
13:38:34 <mbeddoe> i'll try now
13:38:36 <mbeddoe> thanks
13:38:39 <dcoutts_> TomMD: fails how?
13:38:41 <mbeddoe> how do i check lib version
13:38:43 <mbeddoe> from command line?
13:38:47 <dons> ghc-pkg list bytestring
13:39:12 <mbeddoe> thanks, trying now
13:39:28 <TomMD> dcoutts_: That is, I try to upload a package using the username and password that I created my htpasswd file with, but the auth window just re-opens
13:39:44 <actor> how do i do: update elem if member, insert if not member
13:39:50 <TomMD> dcoutts_: If I hit cancel I get the 'auth failed' web page.
13:39:50 <actor> i have to write my own for that?
13:39:52 <mbeddoe>     bytestring-0.9.0.1
13:39:59 <mbeddoe> and on my laptop im on 9.1.2
13:40:00 <mbeddoe> that must be it
13:40:01 <mbeddoe> lol
13:40:06 <mbeddoe> anyway, this kinda freaked me out
13:40:10 <mbeddoe> i'm trying to sell haskell in my company
13:40:11 <mbeddoe> for data processing
13:40:16 <TomMD> dcoutts_: Rather "Not authorized" is the entire page, tags and all.
13:40:17 <mbeddoe> this comes in way behind ruby
13:40:19 <mbeddoe> hhehe
13:40:26 <dcoutts_> TomMD: ah so the import claims to work but then the auth fails
13:40:34 <dons> mbeddoe: so you're doing something wrong then :)
13:40:41 <dons> ruby is the definition of slow.
13:40:57 <SamB_XP> try .BAT
13:41:00 <TomMD> $ ./hackage-server --import-accounts=./state/users
13:41:01 <TomMD> hackage-server: initialising...
13:41:01 <TomMD> hackage-server: ready, serving on 'myhost' port 5000
13:41:01 <TomMD> dcoutts_: ^^^
13:41:10 <mbeddoe> dons: most definitely :)
13:41:13 <dons> good streaming bytestring programs should outperform C, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
13:41:15 <lambdabot> Title: sum-file benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks G ..., http://tinyurl.com/o8pll
13:41:16 <mbeddoe> thanks for help, i feel a little better now
13:41:28 <mbeddoe> we do a lot of backend data processing, data warehouse stuff
13:41:32 <SamB_XP> dons: have you tried .BAT?
13:41:33 <mbeddoe> and we use ruby with inline C
13:41:34 <mbeddoe> it's ridiculous
13:41:41 <dons> crazy.
13:41:41 <dcoutts_> TomMD: hmm, it worked for me, you were using htpasswd to create that file right?
13:41:46 <SamB_XP> I'm pretty sure it's slower than Ruby
13:42:00 <TomMD> dcoutts_: Correct
13:42:18 <dons> mbeddoe: ok.i'll have a quick look.
13:42:23 <dons> mbeddoe: do you have a data file somewhere?
13:43:05 <dcoutts_> TomMD: could you make a dummy one (using a fresh passwd that you don't use elsewhere) that demonstrates the problem and send me the file and tell me the actual passwd and I'll see if I can reproduce it
13:43:26 <mbeddoe> yeah one second
13:44:00 <TomMD> dcoutts_: Will do.
13:44:08 <dcoutts_> TomMD: thanks
13:44:08 * dcoutts_ disappears
13:44:15 <dolio> Someone was describing the process of executing a .bat here not too long ago.
13:44:18 <dolio> It was pretty insane.
13:45:04 <dolio> It's hard to imagine Ruby being worse.
13:45:40 <mc__> whats so bad about ruby?
13:45:44 <mbeddoe> so upgraded bytestring
13:45:49 <mbeddoe> and went from 5 mins to 20 seconds
13:45:51 <mbeddoe> that's more like it
13:45:51 <olsner> is ghc always single-threaded during GC?
13:46:34 <mc__> olsner: yes
13:46:41 <dolio> Ruby is slow, currently.
13:46:47 <mc__> there is an experimental multi-threaded GC IIRC
13:47:13 <mc__> dolio: it is slow, but there are new implementations on the way
13:47:33 <mc__> and in a lot of situations performance does not matter anyways
13:47:59 <mc__> it is a beautiful and fun to use language IMHO
13:48:08 <dons> mbeddoe: aweseom.
13:48:19 <dons> so that's likely the Data.Map inlining issue with old bytestring
13:48:31 <dons> now , there's a *bunch* of improvements we can make to that code too
13:48:32 <dons> so all good
13:49:25 <olsner> so, GC time ends up being 5% of the used cpu time, but 20% of the wall-clock time since it's single-threaded :(
13:51:43 <dolio> Should get better with 6.10, hopefully.
13:51:50 <olsner> parallel gc?
13:51:55 <dolio> Yeah.
13:52:06 <olsner> sounds nice :D
13:53:26 <dons> olsner:  yeah, we need the parallel GC to land
13:53:31 <birkenfeld> I gather parsec does bytestrings now?
13:53:33 <dons> olsner: but try for now  using -AfooM
13:53:40 <dons> where foo is some decent default heap size
13:55:00 <birkenfeld> how fast is it compared to the standard string version?
13:55:51 <mbeddoe> anyone know of a Base64 lib that uses ByteStrings?
13:57:14 <olsner> yeah, -A400M something did OK (i.e. just as good as the previous version), much larger sizes only led to starting to swap
13:57:21 <pcc1> could someone tell me why this happens: http://hpaste.org/10461
13:58:19 <olsner> on the other hand, RAM is cheap - I could go get myself another 4GB :D
13:58:42 <actor> http://hpaste.org/10462 , help please
13:59:23 <actor> i guess the problem might be update doesnt do what i want /think it does
13:59:43 <stepcut> actor: should update take another arguement ?
14:01:37 <stepcut> actor: also, insert replaces the value if it already exists, so that code doesn't seem to do anything that insert alone would not ?
14:05:21 <actor> i will give it a "string" and a type if string exists it should update "string"s elems/values with the instance of type
14:06:43 <actor> stepcut: ok that not whA TI WANT
14:06:46 <actor> oops
14:07:01 <subconscious> @seen luqui
14:07:02 <lambdabot> I saw luqui leaving #haskell and #perl6 2d 14h 51m 40s ago, and .
14:07:28 * subconscious wants to ask a computer science type question :/
14:07:29 <stepcut> what do you mean by update ?
14:07:48 <bbs> :t [1,2,3]
14:07:49 <lambdabot> forall t. (Num t) => [t]
14:08:01 <SamB_XP> subconscious: ... there are other types of questions ?
14:08:06 <actor> key: [val], if key exists then key: [val,val2] else key: [val]
14:08:31 <stepcut> actor: insertWith might be what you want
14:08:47 <stepcut> actor: or insertWith'
14:08:52 <stepcut> actor: insertWith' (++)
14:08:59 <Beelsebob> subconscious: I don't think luqui is the only computer scientist in here ;)
14:09:17 <Beelsebob> (not saying anyone'll be able to help, but you've got a damn good chance in here)
14:09:59 <actor> http://hpaste.org/10464
14:10:27 <actor> messily written ^^ but thats what i want
14:12:31 <Beelsebob> actor: insertWith' (++) then
14:12:53 <stepcut> insertWith (++) "x" [5] (fromList [("x",[4])])
14:13:14 <Beelsebob> > insertWith (++) "x" [5] (fromList [("x",[4])])
14:13:15 <stepcut> or perhaps union instead of ++ depending on what you want
14:13:15 <lambdabot>   mueval: Prelude.read: no parse
14:13:39 <stepcut> Beelsebob: this doesn't work either:
14:13:41 <stepcut> > Data.Map.insertWith (++) "x" [5] (Data.Map.fromList [("x",[4])])
14:13:42 <lambdabot>   mueval: Prelude.read: no parse
14:13:52 <stepcut> not sure why mueval does not like it
14:16:02 <olsner> Beelsebob: my parMapReduceRange changes for binary-trees didn't do much timewise (but I seem to get slightly better results with -A650M, if that's of any worth)
14:16:34 <olsner> seems the GC is the culprit whatever which way you bend it
14:16:46 <Beelsebob> olsner: interesting -- dons and I tuned the -A param for a while... but we may only have found a local minima
14:16:57 <Beelsebob> yeh, GC was what was happering us
14:17:10 <Beelsebob> we were seeing ~80% time spent in GC before upping -A
14:19:04 * quicksilver thinks there should be insertMonoid
14:19:30 <stepcut> insertWith mappend
14:20:26 <dons> olsner, Beelsebob btw, we can't use -Afoo for binary-trees
14:20:33 <dons> the ruling is that only default GC settings are allowed
14:20:41 <Beelsebob> oh? how come?
14:20:46 <olsner> oh, joy, we're screwed :D
14:20:52 <actor> thanks inserWith is ehat i wanted
14:21:09 <Beelsebob> other languages are allowed to use whatever memory allocation strategy they like, why are we not too?
14:22:48 <quicksilver> stepcut: yes, I know.
14:22:55 <stepcut> :p
14:23:21 <Baughn> Someone release ghc-binarytrees, then. ^_^
14:23:30 <yrlnry> I have code that has data ListX a b = ....  ;  newtype ListY a = ListX a;  newtype ... = ... ListY a ... ;   but if I try to get rid of the apparently superfluous ListY, it fails.  Please see http://hpaste.org/10467 for details.
14:23:33 <Beelsebob> haha
14:23:33 <SamB_XP> Baughn: how will THAT help ?
14:23:36 <actor> http://hpaste.org/10466
14:23:45 <quicksilver> the ruling is "any feature, switch, strategy, or approach which enables haskell to do unreasonably well, will be disallowed"
14:24:01 <Beelsebob> quicksilver: haha
14:24:18 <Beelsebob> dons: was there any reason why -qm was turned on?
14:24:20 <quicksilver> yrlnry: your ListY is not what you think it is.
14:24:25 <yrlnry> What do I think it is?
14:24:26 <SamB_XP> quicksilver: then why are we playing that stupid game?
14:24:27 <actor> mappend
14:24:31 <actor> ?
14:24:40 <quicksilver> yrlnry: your 'newtype ListY' has no relation to the previoslu defined ListX
14:24:45 <actor> Couldn't match expected type `[a]' against inferred type `Review'
14:24:46 <actor>     In the third argument of `M.insertWith', namely
14:24:49 <actor> ^^
14:24:52 <quicksilver> yrlnry: it happens to use (as a constructor) the name which ListX uses (as a type)
14:24:56 <quicksilver> yrlnry: but they are unrelated.
14:24:58 <yrlnry> Ah!
14:25:03 <dons> Beelsebob: no that i know of
14:25:19 <quicksilver> SamB_XP: because we may learn something on the journey, even if the destination is uninteresting.
14:25:35 <Beelsebob> dons: that was seriously hurting performance when I tested, so at least getting that turned off is a good plan
14:26:35 <olsner> if the only way to get improved benchmarks is making ghc smarter, then I guess that leads to us having a better ghc
14:26:36 <yrlnry> Then what do I want?
14:27:03 <quicksilver> Beelsebob: I suspect that flag depends quite heavily on OS kernel and/or CPU architecture. Although the simpler answer is it may just be broken :)
14:27:07 <Beelsebob> olsner: certainly, it would be nice to get a ghc that tweaks the size of the gc generations out of it
14:27:24 <Baughn> Certainly, I seem to have to use -Afoo unreasonably often
14:27:38 <Baughn> A bit of autoconfiguring (based on GC time?) would be good
14:27:39 <Beelsebob> quicksilver: both me (on OS X), and olsner iirc on linux got the same result
14:27:49 <Beelsebob> Baughn: indeed, it would be nice
14:28:23 <SamB_XP> of course, it would also be good to have thrash time taken into consideration ;-)
14:28:28 <yrlnry> I still have a lot of trouble knowing which tokens are type constructors and which are value constructors.
14:28:39 <yrlnry> Thanks.
14:29:12 <Baughn> SamB_XP: True, but the default allocation zone is - what, 100k?
14:29:18 <olsner> without -qm you at least get something like 1.5x parallelism even with default GC settings
14:29:18 <Baughn> That's unreasonably small on any modern system
14:29:57 <Beelsebob> indeed -- surely we can get away with at least 4M
14:30:21 <Baughn> ..that'd be a bit much
14:30:21 <lunabot>   Not in scope: `that'd'
14:30:21 <lunabot>  <interactive>:1:57: Not in scope: `be'
14:30:27 <Beelsebob> lol
14:30:33 <Baughn> 512k, say?
14:30:40 <Beelsebob> it would also require fixing -A on OS X
14:30:51 <quicksilver> yrlnry: I think you wanted newtype List = Mu ListX
14:30:56 <Baughn> What's up with that? I do see the gc acting very oddly on os x
14:30:58 <quicksilver> yrlnry: not (ListX a), just ListX
14:31:06 <quicksilver> yrlnry: because Mu has kind (* -> *) -> *
14:31:08 <Baughn> What's it doing, exactly?
14:31:17 <quicksilver> its parameter should be a type constructore not a ground type
14:31:19 <yrlnry> ListX has kind * -> * -> *.
14:31:24 <Beelsebob> Baughn: I *think* -AnM tells it to start by doing a big malloc
14:31:24 <yrlnry> Which is the wrong kind.
14:31:26 <quicksilver> oh.
14:31:30 <Beelsebob> and malloc on OS X is fucking slow
14:31:31 <yrlnry> That's why I wanted Mu (ListX a).
14:31:40 <Baughn> Beelsebob: Because malloc on os x is calloc
14:31:42 <quicksilver> I didn't read carefully enough.
14:31:46 <quicksilver> hmms.
14:31:48 <SamB_XP> Baughn: what?
14:31:57 <SamB_XP> Baughn: why the heck is that?
14:31:58 <Baughn> SamB_XP: The OS X default malloc zeroes memory
14:32:06 <Beelsebob> that would explain it
14:32:08 <Baughn> SamB_XP: Presumably, at this point, for hysterical raisins
14:32:09 <SamB_XP> that sounds bug-inducing
14:32:13 <Beelsebob> it may be an idea to link against dlmalloc
14:32:17 <Baughn> There are lots of OS X apps that assume malloc'd memory is zeroed
14:32:28 <SamB_XP> Baughn: see what I mean?
14:32:29 <Baughn> Beelsebob: Or call mmap directly?
14:32:32 <SamB_XP> bug-inducing!
14:32:37 <Baughn> SamB_XP: Yeah. Bug-indeed.
14:32:39 <yrlnry> What I really want is to use "List a" as a transparent synonym for Mu (ListX a).
14:32:41 <Beelsebob> Baughn: that too
14:33:28 <Baughn> SamB_XP: Listen for yourself. If you preload a different malloc library when loading itunes, the audio buffer starts off unzeroed and all itchy and scratchy
14:33:45 <yrlnry> Everytbhing I'm doing works fine with ListX a.  For example, I have a "cons" function of type a -> Mu (ListX a) -> Mu (ListX a).  But I would like to be able to *say* that it has type a -> List a -> List a.
14:33:58 <Baughn> SamB_XP: Well, in honesty, only third-party apps seem to actually *crash* with a different malloc. Adobe is a big offender.
14:34:01 <SamB_XP> Baughn: so are you going to email me a copy of OS X or something so I can try it ?
14:34:05 <Wild_Cat> right, this must be a stupid question because I'm late: why does http://hpaste.org/10468 fail to compile/import in ghci with "Parse error in pattern"? (assuming Text.HTML.TagSoup is imported)
14:34:11 <Wild_Cat> s/I'm/it's/
14:34:25 <subconscious> yrlnry: I don't think haskell can do that
14:34:31 <Baughn> SamB_XP: I could. Or you could download a copy and run in vmware or something.
14:34:34 <Botje> Wild_Cat: add parens around your pattern
14:34:34 <subconscious> yrlnry: perhaps with a type compose you could get close though
14:34:40 <subconscious> ?wiki TypeCompose
14:34:40 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
14:34:42 <Botje> extract ((TagOpen ...):(...):_)
14:34:52 <yrlnry> I thought there was some syntax in Haskell for making new synonyms for old types.
14:34:52 <subconscious> something like that even
14:35:03 <subconscious> yrlnry: yes there is, but I don't think it would work in this case
14:35:05 <SamB_XP> what about "type"
14:35:10 <Wild_Cat> is it *that* stupid? Ghost.
14:35:12 <subconscious> i.e. type List a = Mu (ListX a)
14:35:22 <ddarius> type List a = Mu (ListX a)
14:35:23 <yrlnry> Yeah, I just remembered that.
14:35:25 <SamB_XP> subconscious: so why wouldn't that work ?
14:35:37 <Baughn> Beelsebob: But okay, -A20m on OS X would allocate a 20MB buffer up front, and zero it. This would take.. a millisecond?
14:35:40 <Baughn> What's the deal?
14:35:46 <subconscious> SamB_XP: I was sure it wouldn't work until a few seconds ago
14:35:54 <yrlnry> Yes, that's what i wanted.  Thanks.
14:35:55 <quicksilver> yrlnry: you missed a constructor
14:36:05 <quicksilver> yrlnry: (did you work this out alraedy? I looked away)
14:36:15 <quicksilver> newtype List a = List (Mu (ListX a))
14:36:29 <yrlnry> quicksilver: I need to be using "type" instead of "newtype".
14:36:36 <quicksilver> well that's an alternative soltuion yes
14:36:46 <quicksilver> but what I'm saying fixes the newtype version ;)
14:36:48 <yrlnry> Yours is not actually what I want, but thanks.
14:36:54 <quicksilver> I always forget constructors on newtypes.
14:37:08 <yrlnry> How is yours different from data List a =  List (Mu (ListX a))  ?
14:37:33 <quicksilver> representation efficiency
14:37:46 <quicksilver> there isn't "really* a 'List' constructor-thunk
14:37:49 <quicksilver> it's compiled away
14:37:53 <quicksilver> it's just there for the type-checking phase
14:38:10 <yrlnry> The constructor isn't optimized away for single-constructor datatypes?
14:38:11 <mmorrow> @tell guenni http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=54#a54
14:38:12 <lambdabot> Consider it noted.
14:38:14 <quicksilver> no
14:38:18 <quicksilver> because of bottoms, yrlnry
14:38:23 <yrlnry> Aha.  Okay.
14:38:26 <quicksilver> _|_ is different from 'Foo _|_'
14:38:40 <quicksilver> if Foo is data, but if Foo is a newtype-constructor they are actually not different.
14:38:49 <yrlnry> Right.  My rejoinder was going to be "geez, SML/NJ had that optimization twenty years ago".
14:38:53 <quicksilver> ;P
14:39:02 <jsnx> i notice that ~/.cabal/config includes a "global install" configuration setting -- but it's not clear how i install globally and how i install locally
14:39:04 <yrlnry> But in a strict language it's different.
14:39:10 <yrlnry> This language is way too complicated.  I should have stuck with FORTRAN IV.
14:39:26 <Baughn> Or Cobol. At least they /tried/ to make that simple.
14:39:31 <jsnx> yrlnry: or sed
14:39:46 <subconscious> Forth!
14:39:49 <yrlnry> I have to admit that sed utterly defeated me.
14:39:52 <subconscious> what is simpler :)
14:40:07 <yrlnry> I tried to use the "hold space" once and ran screaming.
14:40:17 <jsnx> yrlnry: it gets easier with time
14:40:30 <yrlnry> \I'm fluent in over 14 million forms of communication, but the hold space totally kicked my ass.
14:40:58 <yrlnry> Well, thanks again.  I have exactly what I want now and I understand what was wrong with the other thing.
14:42:23 <mmorrow> @tell guenni fixed a type in a comment http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=54#a55
14:42:23 <lambdabot> Consider it noted.
14:42:42 <mmorrow> @tell guenni gah, i meant "typo"
14:42:43 <lambdabot> Consider it noted.
14:45:37 <birkenfeld> hmm, what about that "Clean" language that seems to beat Haskell quite often at the shootout?
14:45:49 <subconscious> what does "what about" mean?
14:45:50 <birkenfeld> it looks quite like Haskell
14:45:57 <birkenfeld> what does it do differently?
14:46:20 <actor> http://hpaste.org/10469
14:46:29 <actor> oops wrong chanel
14:46:31 <subconscious> I think they can get some mutation instead of reallocation at times haskell can't because of the uniquness types
14:46:38 <subconscious> I'm basically guessing though, I don't know if that's true
14:47:18 <yrlnry> Ho come i can type "3 :: Int" into GHCI and it is acceptable, but if I put it in a file 3.hs and :r "3.hs", it says "3.hs:1:0: Invalid type signature"?
14:47:33 <yrlnry> Is Int in the wrong default namespace or something?
14:48:49 <birkenfeld> yrlnry: you can't have expressions in files, you need equations
14:48:52 <ddarius> yrlnry: Files are lists of declarations (well modules are).  The GHCi repl takes expressions or statements.
14:49:02 <dons> ?users
14:49:03 <lambdabot> Maximum users seen in #haskell: 511, currently: 485 (94.9%), active: 21 (4.3%)
14:49:25 <yrlnry> Yeah, why do I keep forgetting this?  Thanks.
14:49:39 <subconscious> has anyone designed a IO _and_ computation monad?
14:49:57 <Heffalump> what does that mean?
14:51:46 <yrlnry> subconscious: I can refer you to a bunch of interesting papers on how to compose different monads.
14:53:45 <subconscious> data Delay a = Now a | Later (Delay a)
14:54:01 <subconscious> instance Monad Delay where
14:54:01 <subconscious>  return = Now
14:54:09 <subconscious>  Now a >>= k = k a
14:54:24 <subconscious>  Later a >>= k = Later (a >>= k)
14:54:28 <dons> interesting type.
14:54:43 <subconscious> and everyone knows IO
14:54:44 <subconscious> :)
14:54:48 <subconscious> but I want both??
14:55:07 <subconscious> http://www.informatik.uni-bonn.de/~ralf/WG2.8/22/slides/tarmo.pdf
14:55:12 <lambdabot> Title: Partiality is an Effect
14:57:01 <subconscious> nobody has written one, I guess
14:57:23 <Heffalump> can you make a DelayT?
14:57:48 <subconscious> and simply DelayT IO ?
14:57:51 <Heffalump> yeah
14:58:03 <Saizan> mmh, Delay is the free monad of Identity?
15:02:44 <subconscious> m
15:02:44 <subconscious> m
15:02:51 <subconscious> Delay (IO ())
15:03:58 <mmorrow> instance Functor (DelayT m) where ...
15:04:04 <mmorrow> instance Monad (DelayT m) where ...
15:04:46 <newsham> your two >>= defns return diff types
15:05:18 <subconscious> program = do
15:05:19 <subconscious>   return (putStrLn "foo")
15:05:19 <subconscious>   return (return ())
15:05:20 <subconscious> does not work :)
15:05:24 <Wild_Cat> hrmm. How quaint. TagSoup has no canonicalizeAttributes function.
15:25:55 <ddarius> newtype FreeMonadT f m a = FreeMonadT { runFreeMonadT :: m (Either a (f (FreeMonadT f m a))) }; instance (Monad m, Functor f) => Functor (FreeMonadT f m) where fmap f = FreeMonadT . liftM (f +++ fmap (fmap f)) . runFreeMonadT; instance (Monad m, Functor f) => Monad (FreeMonadT f m) where return = FreeMonadT . return . Left; m >>= k = FreeMonadT $ either (runFreeMonadT k) (return . Right . fmap (>>= k)) =<< runFreeMonadT m; instance (Functor f) => MonadTrans
15:25:55 <ddarius>  (FreeMonadT f) where lift = FreeMonadT . liftM Left
15:27:41 <mbeddoe> i'm trying to build HsOpenSSL-0.4.2 and it's linking bytestring-0.9.0.1.1 instead of the new bytestring-0.9.1.2, how do i force it to ignore the old version?
15:28:13 <bos> mbeddoe: have you looked at its .cabal file? it might have a hard dependency.
15:28:14 <ddarius> s/runFreeMonadT k/runFreeMonadT . k
15:28:21 <mbeddoe> it says
15:28:29 <mbeddoe>     build-depends: base >= 3, bytestring, time >= 1.1.1, old-locale, network>=2.1.0.0
15:28:49 <bos> are you sure that bytestring is installed properly? ghc-pkg -l
15:29:08 <mbeddoe>     binary-0.4.3.1, bytestring-0.9.1.2, cgi-3001.1.6.0, curl-1.3.2.1,
15:29:09 <mbeddoe> yes
15:29:36 <bos> is the new bytestring in the user package list, or the system package list?
15:29:47 <mbeddoe> ah
15:29:50 <mbeddoe> that must be it
15:29:52 <mbeddoe> installing --global
15:29:53 <mbeddoe> one sec
15:33:28 <jsnx> consider the case where i have some value v, and i want to get the maximum that v could be
15:33:38 <jsnx> i maxBound :: (type of v)
15:33:45 <jsnx> i want maxBound :: (type of v)
15:33:59 <jsnx> i'm not sure how to do that, though
15:34:08 <dolio> maxBound `asTypeOf` v
15:34:30 <jsnx> dolio: thanks
15:36:32 <humasect> how does one make a Monad or Functor instance for a type which doesn't "contain" anything (ie. is kind * and not * -> *)
15:36:55 <dolio> Those aren't monads/functors.
15:37:04 <humasect> sequences ?
15:37:39 <Heffalump> monoid, perhaps?
15:37:52 <dibblego> humasect, you simply can't, but why are you wanting to (so that we can correct it)?
15:38:15 <humasect> it is monoid now .. but the convenience of return () and sequencing/lifting will be missed
15:38:31 <dibblego> it can't be missed, because it was never going to be sensible
15:39:10 <Heffalump> you can define a Const monad.
15:39:18 <Heffalump> but it would be rather obfuscated
15:39:31 <humasect> how come ? the code is being seduced from IO monad into no monad, but is still sequenced (into recursive list)
15:41:37 <humasect> hmmm
15:46:59 <subconscious> how do I prove my transformer is a valid one?
15:47:48 <ddarius> You prove that it satisfies the monad transformer laws however you like.
15:48:43 <Heffalump> the monad transformer laws just being the obvious lifting of the monad laws
15:51:45 <subconscious> for any monad m, transform m is a monad?
15:51:58 <subconscious> nothing else matters
15:52:38 <ddarius> I believe you'd also have to prove that lift is a monad homomorphism.
15:54:52 <Heffalump> what does that mean? lift . return = return ?
15:55:02 <subconscious> :t lift . return
15:55:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => a -> t m a
15:55:20 <subconscious> return on the monad transformer = lift . return on the normal monad ?
15:55:32 <Heffalump> that's what I said :-)
15:55:41 <subconscious> oh I thought you were asking
15:55:59 <Heffalump> well, I asked if that's what a monad homomorphism meant.
15:56:26 <ddarius> Heffalump: lift . return = return, lift . fmap = fmap . lift, lift . join = join . lift . fmap lift = join . fmap lift . lift
15:56:44 <Heffalump> ah.
15:56:55 <Heffalump> oh yeah.
15:57:06 <ddarius> That should be (more than) what is necessary.
15:57:19 <Heffalump> lift (m >>= f) = lift m >>= (lift . f)
15:57:34 <Heffalump> I expect that and lift . return = return form a complete set.
15:57:54 <Heffalump> easier to understand than the fmap/join rules :-) (to me)
15:58:01 <ddarius> Heffalump: Yes they do.
15:58:36 <ddarius> Though, the lift . fmap = fmap . lift should be true by parametricity (assuming the fmaps are actually the action of a functor)
15:59:15 <dcoutts> jsnx: cabal install has --global and --user args, or set the default in the ~/.cabal/config
16:03:24 <Markov> hello haskellers!
16:03:24 <Markov> ?
16:03:24 <Markov> ?
16:03:27 <Markov> ?
16:03:29 <Markov> ?
16:03:31 <Markov> ?
16:03:33 <Markov> ?
16:03:40 <actor> sorry
16:03:47 <Botje> uh. hi?
16:03:58 <Botje> you had our attention at the first question mark.
16:04:04 <Zao> actor: I wouldn't rank that bot "useful".
16:04:07 <actor> is it ok if i let my markov-chain based bot on here?
16:04:15 <Zao> actor: Most likely "no".
16:04:16 <Botje> oh.
16:04:22 <lispy> what are the normal ways to avoid stackoverflow?  You could improve your basecase, but what else?
16:04:36 <actor> lispy: strictness
16:04:41 <Botje> lispy: find out where thunks accumulate and force them timeyl
16:04:43 <actor> tailrecursion
16:04:43 <Botje> *timely
16:05:06 <actor> zao: well it might never be useful, or it might, but it might be funny
16:05:10 <actor> i wont do the ???
16:05:52 <Zao> actor: I cannot see how it would contribute to the channel in any way, apart from being annoying.
16:05:59 <subconscious> I can't implement Dom for DelayT
16:06:32 <subconscious> lispy: Why is the stack overflaw happening?
16:07:58 <lispy> subconscious: I'm actually just looknig for solutions to stackoverflow not debugging anything specific
16:08:56 <subconscious> Well knowing why it happens (in general or in specific cases) is the first thing
16:14:09 <newsham> cale was explaining the nature of stack overflows in haskell the other day
16:14:09 <FunctorSalad> any recommendation for a high-level library to let people view and enter data over the web? (server-side logic)
16:14:12 <newsham> but i cant find it in the irc logs
16:14:37 <FunctorSalad> ... and high-level/simple please ;-)
16:14:38 <lunabot>   parse error on input `..'
16:14:40 <lispy> FunctorSalad: HApps seems to be catching on and it has some tutorials
16:14:52 <newsham> but they key point was that the stack isnt the same as the evaluation stack you think of in other languages.  its the depth of the left most unevaluated expression
16:14:52 <lispy> FunctorSalad: is it different than what you want?
16:14:59 <FunctorSalad> lispy: this "WebFunctions" looks nice but last update seems to be 2005
16:15:23 <lispy> newsham: ah my question may not be approriate here as it wasn't meant to be Haskell specific
16:15:35 <subconscious> lispy: is it about lazy evaluation?
16:15:38 <FunctorSalad> lispy: hmm I don't know about HApps but my uninformed impression was that it is a bit low-level
16:15:56 <newsham> what language and what kind of stack overflow?
16:15:59 <subconscious> lispy: or stack overflow in strict settings or other?
16:16:48 <FunctorSalad> I guess I should get some vague idea of what my thing is going to look like first :)
16:17:04 <aempirei> is there any normal libraries that pack data into strings ?
16:17:18 <aempirei> like packing a inteeger into a 4 byte string in network byte oreder
16:17:20 <aempirei> stuff like that
16:17:47 <cads> what do I need to install to use the Graphics.UI.GLUT library?
16:17:57 <actor> zao: is it generally allowed with bots on irc?
16:21:09 <newsham> hi ae.
16:21:26 <newsham> aempire:  "binary" (Data.Binary) on hackage.haskell.org
16:21:48 <newsham> lets you construct functions that describe how to pack data into ByteStrings, which can easily convert to normal strings
16:22:23 <newsham> its a monadic interface.
16:23:34 <mmorrow> actor: what does the bot do?
16:23:35 <aempirei> ok cool
16:23:36 <aempirei> excellent
16:25:14 <mmorrow> (to everyone), let me know if having lunabot eval on "." is more annoying than useful
16:25:42 <mmorrow> ...
16:25:42 <lunabot>   parse error on input `..'
16:25:59 <subconscious> I am happy with ♪
16:26:08 <mmorrow> ] 4
16:26:09 <lunabot>  4
16:26:36 <mmorrow> thank Myoma for the notes idea
16:26:55 * subconscious  
16:27:41 <newsham> soon we'll need #haskell-bots
16:28:04 <subconscious> or perhaps.. one that works :p
16:28:22 <newsham> > fix bot
16:28:23 <lambdabot>   mueval: Prelude.read: no parse
16:28:45 <mmorrow> ooh, and #haskell-bot-battle as well, where they compete in some predetermined game
16:29:10 <mmorrow> and losers are banned :)
16:29:27 * mmorrow chuckles
16:30:27 <subconscious> oh great
16:30:32 <subconscious> *Main> main
16:30:32 <subconscious> fib 50 = *** Exception: stack overflow
16:30:34 <subconscious> :/
16:31:12 <subconscious> so.... I need to implement a monadic omegarace that does terminate
16:31:19 <mmorrow> hmm, a "loop-breaker" bot would be useful (one that somehow detects bot loops, and kicks the loopers)
16:31:40 <newsham> sub: what kinda fib impl?
16:31:47 <mmorrow> bottom-up fib is nice
16:33:44 <andrewsw> noob question: is there a no-op function? a function that can be passed around that will do nothing to it's arguments?
16:33:48 <mmorrow> . let fib m n = m : fib n (m+n) in fib 0 1 !! 50
16:33:49 <lunabot>  12586269025
16:33:57 <mmorrow> . let fib m n = m : fib n (m+n) in fib 0 1
16:33:57 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:34:05 <subconscious> ♪ (id (id id) id) 3
16:34:06 <lunabot>  3
16:34:13 <newsham> andrew: every function has to return a value.  they all do "nothing" in the sense that they dont have side effects.
16:34:31 <newsham> perhaps "const" is what you want?
16:34:37 <subconscious> @src sequence
16:34:37 <lambdabot> sequence []     = return []
16:34:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:34:37 <lambdabot> --OR
16:34:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:34:38 <newsham> > const 5 "testing"
16:34:39 <lambdabot>   5
16:34:54 <andrewsw> aha, probably const.
16:35:12 <newsham> map (const 5) [1..8]
16:35:15 <newsham> > map (const 5) [1..8]
16:35:16 <lambdabot>   [5,5,5,5,5,5,5,5]
16:35:18 <BMeph_> andrewsw: If not id. :)
16:35:27 <newsham> > map id [1..8]
16:35:28 <lambdabot>   [1,2,3,4,5,6,7,8]
16:35:34 <andrewsw> oh, id is better.
16:35:51 <newsham> other useful weird thing is "undefined" which has any type.
16:35:53 <mmorrow> @type const id
16:35:54 <lambdabot> forall a b. b -> a -> a
16:36:07 <BMeph_> Haskell: Where lazyness and the id rule. ;)
16:36:08 <mmorrow> @type flip const
16:36:10 <lambdabot> forall a b. b -> a -> a
16:36:12 <andrewsw> yes. I want to map different functions onto the same set of data, but one of those functions needs to leave the data untouched.
16:36:23 <newsham> that's id
16:36:24 <newsham> ?src id
16:36:25 <lambdabot> id x = x
16:36:26 <newsham> ?type id
16:36:27 <lambdabot> forall a. a -> a
16:37:01 <mmorrow> . (iterate id id !! 10000) 42
16:37:02 <lunabot>  42
16:37:41 <mmorrow> . foldr (.) id (replicate 10000 id) $ 42
16:37:42 <lunabot>  42
16:37:59 <Apocalisp> > 6 * 9
16:38:00 <lambdabot>   54
16:38:03 <Apocalisp> huh
16:38:15 <dolio> You were expecting 42?
16:38:26 <mmorrow> hahaha
16:38:32 <Apocalisp> oh, different bot
16:38:38 <mmorrow> :)
16:38:38 <Apocalisp> my bad
16:39:54 <Apocalisp> ?src unzip
16:39:54 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
16:40:26 <andrewsw> BMeph_: id is it. so to speak. thanks
16:40:42 <BMeph_> andrewsw: :)
16:41:22 <newsham> > unzip $ map (splitAt 2) (words "this is a test")
16:41:23 <lambdabot>   (["th","is","a","te"],["is","","","st"])
16:41:58 <mmorrow> hmm
16:45:27 <mmorrow> . zipWith (++) [unzip $ map (splitAt 2) (words "this is a test")]
16:45:28 <lunabot>      Couldn't match expected type `[a]'
16:45:57 <mmorrow> . uncurry zipWith (++) . unzip $ map (splitAt 2) (words "this is a test")]
16:45:58 <lunabot>   parse error on input `]'
16:46:02 <mmorrow> . uncurry zipWith (++) . unzip $ map (splitAt 2) (words "this is a test")
16:46:03 <lunabot>      Couldn't match expected type `(a -> b -> c, [a])'
16:46:10 <mmorrow> . uncurry (zipWith (++)) . unzip $ map (splitAt 2) (words "this is a test")
16:46:11 <lunabot>  ["this","is","a","test"]
16:46:21 <mmorrow> haha, perfect sentence for that
16:46:45 <mmorrow> . uncurry (zipWith (++)) . unzip $ map (splitAt 2) (words "that is a test")
16:46:46 <lunabot>  ["that","is","a","test"]
16:46:51 <mmorrow> oh
16:47:02 <newsham> you're just zipping up what you unzipped
16:47:06 <Olathe> > words "this is a test"
16:47:07 <lambdabot>   ["this","is","a","test"]
16:47:10 <mmorrow> yeah, hold on
16:47:15 <newsham> btw, why doesnt the bot know how to use control.arrow?
16:47:16 <mmorrow> . uncurry (zipWith (++)) . unzip $ map (splitAt 2) (words "this si a test")
16:47:17 <lunabot>  ["this","si","a","test"]
16:47:18 <newsham> > first (+1) (1,2)
16:47:19 <lambdabot>   mueval: Prelude.read: no parse
16:47:20 <mmorrow> crap
16:47:29 <Olathe> . Control.Arrow.liftM2
16:47:30 <lunabot>   Not in scope: `Control.Arrow.liftM2'
16:47:36 <Olathe> @index liftM2
16:47:36 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:47:38 <mmorrow> . liftA
16:47:39 <lunabot>   Not in scope: `liftA'
16:47:41 <mmorrow> . liftA2
16:47:41 <subconscious> ♪ map (head &&& length) . group $ "foobar"
16:47:42 <lunabot>   Not in scope: `liftA2'
16:47:42 <lunabot>  [('f',1),('o',2),('b',1),('a',1),('r',1)]
16:47:50 <Olathe> @index liftA2
16:47:50 <lambdabot> bzzt
16:47:52 <Olathe> @index liftA
16:47:52 <lambdabot> bzzt
16:47:54 <mmorrow> hmm, i have Control.Arrow imported
16:47:57 <Olathe> I'll bzzt you !
16:47:59 <subconscious> ♪ concat . (uncurry replicate) $ [('f',1),('o',2),('b',1),('a',1),('r',1)]
16:48:00 <lunabot>      Couldn't match expected type `(Int, [a])'
16:48:02 <ddarius> newsham: If the language optimizes tail-calls, you can easily discover stack overflows simply by evaluating by hand using basic rewrite rules (beta reduction in the FP world)
16:48:06 <subconscious> ♪ concat . (flip (uncurry replicate)) $ [('f',1),('o',2),('b',1),('a',1),('r',1)]
16:48:07 <newsham> ♪ (first concat) $ map (splitAt 2) (words "this is a test")
16:48:07 <lunabot>      Couldn't match expected type `a -> c' against inferred type `[b]'
16:48:09 <lunabot>      Couldn't match expected type `([[a]], d)'
16:48:15 <subconscious> ♪ concat . (uncurry (flip replicate)) $ [('f',1),('o',2),('b',1),('a',1),('r',1)]
16:48:16 <lunabot>      Couldn't match expected type `([a], Int)'
16:48:22 <subconscious> ♪ concat . map (uncurry (flip replicate)) $ [('f',1),('o',2),('b',1),('a',1),('r',1)]
16:48:23 <lunabot>  "foobar"
16:48:27 <subconscious> :(
16:49:09 <mmorrow> . arr
16:49:10 <lunabot>      No instance for (Show ((b -> c) -> a b c))
16:49:34 <Philonous> @src concatMap
16:49:35 <lambdabot> concatMap f = foldr ((++) . f) []
16:49:44 <mmorrow> (=<<)
16:49:58 <subconscious> concatMap = concat . map
16:50:15 <subconscious> actually that's probably wrong :/
16:50:16 <Philonous> That's what I thought
16:50:17 <Pseudonym> :t concatMap
16:50:18 <subconscious> :t concat . map
16:50:19 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:50:19 <lambdabot>     Couldn't match expected type `[[a]]'
16:50:20 <lambdabot>            against inferred type `[a1] -> [b]'
16:50:20 <lambdabot>     Probable cause: `map' is applied to too few arguments
16:50:20 <Pseudonym> :t concat . map
16:50:21 <lambdabot>     Couldn't match expected type `[[a]]'
16:50:21 <lambdabot>            against inferred type `[a1] -> [b]'
16:50:23 <lambdabot>     Probable cause: `map' is applied to too few arguments
16:50:23 <subconscious> :t concat . map ?f
16:50:25 <lambdabot> forall a a1. (?f::a1 -> [a]) => [a1] -> [a]
16:50:28 <newsham> ♪ first (+1) (1,2)
16:50:29 <lunabot>  (2,2)
16:50:33 <Pseudonym> :t \f -> concat . map f
16:50:34 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:50:35 <mmorrow> . (=<<) ((:[]) . (*2)) [0..9]
16:50:36 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
16:50:44 <mmorrow> . concatMap ((:[]) . (*2)) [0..9]
16:50:45 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
16:50:55 <newsham> ♪ (first concat) (["th","is","a","te"],["is","","","st"])
16:50:56 <lunabot>  ("thisate",["is","","","st"])
16:51:13 <newsham> ♪ (first concat) $ unzip $ map (splitAt 2) (words "this is a test")
16:51:14 <lunabot>  ("thisate",["is","","","st"])
16:51:16 <mmorrow> yes, that's kinda what i was going for
16:51:43 <newsham> ♪ (concat &&& concat) $ unzip $ map (splitAt 2) (words "this is a test")
16:51:44 <lunabot>      Couldn't match expected type `[[a]]'
16:52:05 <Pseudonym> All the dollar signs, they hurt my eyes.
16:52:21 <newsham> ♪ (concat *** concat) $ unzip $ map (splitAt 2) (words "this is a test")
16:52:22 <lunabot>  ("thisate","isst")
16:52:28 <newsham> can never get &&& and *** straight
16:52:44 <Pseudonym> @hoogle (><)
16:52:45 <lambdabot> Data.Sequence (><) :: Seq a -> Seq a -> Seq a
16:52:48 <ddarius> Pseudonym is clearly not America
16:52:49 <Pseudonym> Hmm.
16:52:49 <ddarius> n
16:53:05 <mmorrow> whoa, wtf is >< from
16:53:07 <mmorrow> ?
16:53:18 <newsham> concatenating sequences
16:53:18 <ddarius> It says right there
16:53:24 <Pseudonym> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,c)
16:53:24 <lambdabot> No results found
16:53:25 <Pseudonym> @hoogle (a -> b) -> (c -> d) -> (a,c) -> (b,d)
16:53:26 <lambdabot> No results found
16:53:28 <Olathe> @index (><)
16:53:28 <lambdabot> Data.Graph.Inductive.Query.Monad, Data.Graph.Inductive.Query, Data.Graph.Inductive
16:53:31 <Pseudonym> That's ti.
16:53:32 <Olathe> From thaose.
16:53:32 <mmorrow> oh, i though that was a class method or something
16:53:39 <newsham> ?type (|>)
16:53:40 <lambdabot> Not in scope: `|>'
16:53:41 <Pseudonym> I want that in Data.Function.
16:53:41 <dancor> newsham: ya bc "&" feels right for "pair both"
16:53:46 <newsham> ?hoogle (|>)
16:53:46 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
16:53:46 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
16:53:46 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
16:53:48 <mmorrow> that must be a new addition to Sequence, or i'm just blind
16:53:53 <Pseudonym> Not hidden away in Data.Graph.Inductive.Query/
16:54:00 <Pseudonym> :t Data.Graph.Inductive.Query.><
16:54:02 <lambdabot> parse error on input `Data.Graph.Inductive.Query.><'
16:54:06 <Pseudonym> :t (Data.Graph.Inductive.Query.><)
16:54:07 <lambdabot> forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:54:14 <mmorrow> ah, ok
16:55:02 <Pseudonym> ?free f :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:55:03 <lambdabot> h . q = f1 . g => p . f2 = f3 . k => $map_Pair h p . f q f2 = f f1 f3 . $map_Pair g k
16:55:38 <ziman> @djinn (a -> b) -> (c -> d) -> (a,c) -> (b,d)
16:55:39 <lambdabot> f a b (c, d) = (a c, b d)
16:55:39 <Olathe> @help free
16:55:39 <lambdabot> free <ident>. Generate theorems for free
16:56:29 <Olathe> @free f :: Int -> Int
16:56:29 <lambdabot> f = f
16:56:32 <Olathe> Yes !
16:56:58 <Pseudonym> @free f :: forall a. a -> Bool
16:56:59 <lambdabot> f = f . g
16:57:03 <Olathe> @free f :: Int -> Int -> (Int -> Int)
16:57:03 <lambdabot> f = f
16:57:13 <Olathe> Wow, the ideas this thing inspires.
16:57:22 <Pseudonym> Olathe: You only get theorems when you have polymorphism.
16:57:27 <Olathe> Ahh.
16:57:33 <Pseudonym> @free join :: M (M a) -> M a
16:57:34 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
16:57:37 <BMeph_> mmorrow: I use (><) as uncurry (***), but AFAIK it isn't actually in C.Arrow, though. :)
16:57:51 <Olathe> @free f :: forall a. a -> a -> (a -> a)
16:57:51 <lambdabot> g . f x y = f (g x) (g y) . g
16:57:52 <Pseudonym> Or my favourite:
16:58:01 <Pseudonym> @free naturalTransformation :: F a -> G a
16:58:01 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
16:58:07 <BMeph_> mmorrow: If that's the (><) that you're thinking of. :)
16:58:50 <mmorrow> interesting. i didn't know about that (or any) >< until now
16:59:10 <Pseudonym> mmorrow: It's hidden away where nobody can find it.
16:59:15 <Pseudonym> I think it should go in Data.Fucntion.
16:59:18 <Pseudonym> It's REALLY useful.
16:59:27 <ddarius> @free f :: (a -> Int) -> (b -> Int)
16:59:27 <lambdabot> f (k . g) = f k . h
17:00:16 <newsham> whats the diff with (***) ?
17:00:35 <newsham> > ((+1) *** (*2)) (10,20)
17:00:36 <lambdabot>   mueval: Prelude.read: no parse
17:00:46 <newsham> ♪ ((+1) *** (*2)) (10,20)
17:00:47 <lunabot>  (11,40)
17:00:53 <BMeph_> mmorrow: I like it uncurried better, since it matches the shape of the data better. :)
17:00:58 <newsham> wouldnt that do the same thing as  (+1) >< (*2)   ?
17:01:04 <Pseudonym> Just wondering, why ♪ here?
17:01:15 <newsham> because lambdabot doesnt like me
17:01:15 <mmorrow> Myoma :)
17:01:22 <Pseudonym> > ((+1) *** (*2)) (10,20)
17:01:22 <mmorrow> (@Pseudonym)
17:01:23 <lambdabot>   mueval: Prelude.read: no parse
17:01:35 <BMeph_> newsh: You mean ( (+1),(*2)) ><) ;)
17:01:39 <Pseudonym> It doesn't import Arrow or something?
17:01:53 <newsham> ♪ ((+1) Data.Graph.Inductive.Query.>< (*2)) (10,20)
17:01:54 <lunabot>   Not in scope: `Data.Graph.Inductive.Query.><'
17:02:58 <newsham> ((+1) >< (*2)) (10,20)   -->   (11,40)
17:03:07 <newsham> looks like the same as *** to me
17:03:15 <BMeph_> newsham: But defining (><) as uncurry (***). :)
17:03:36 <subconscious> :t uncurry (***)
17:03:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
17:03:42 <BMeph_> newsham: The way you're using it, it is the same.
17:04:17 <newsham> oh, you mean  ((+1), (*2)) >< (11,40)   ?
17:04:20 <newsham> tuple application
17:04:29 <subconscious> I call it $$
17:04:46 <subconscious> (f,g) $$ (x,y) = (f x, g y)
17:04:49 <newsham> ?src (,) fmap
17:04:50 <lambdabot> fmap f (x,y) = (x, f y)
17:04:50 <BMeph_> newsham: Now, the version using triples...all-but-useless, but very "fun"-looking. ;)
17:05:03 <subconscious> the triple one is $$$ :)
17:05:21 <mmorrow> . ((+1) *** (*2)) (10,20)
17:05:22 <lunabot>  (11,40)
17:05:31 <newsham> ?instances-importing Control.Applicative Applicative
17:05:36 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
17:05:52 <BMeph_> subconscious: I think of it as a 'transpose' between (,) and (->). ;)
17:05:58 <newsham> an alternate applicative for (,) perhaps?
17:06:13 <newsham> hmm.. i guess that wouldnt work
17:06:51 <newsham> its kinda applicative-like, but not a functor.
17:06:58 <newsham> sorry, rambling...
17:07:33 <dcoutts> data Mu f = Mu (forall r. (f r -> r) -> r)
17:07:34 <dcoutts> data Nu f = forall s. Nu (s, s -> f s)
17:08:11 <dcoutts> the under appreciated Nu
17:09:46 <Apocalisp> (Functor f) => f (a, b) -> (f a, f b)
17:09:51 <Apocalisp> @hoogle (Functor f) => f (a, b) -> (f a, f b)
17:09:51 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
17:09:51 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
17:10:01 <dancor> has anyone gotten cabal-install to work with ghc 6.9
17:10:23 <Olathe> @. pl unpl (((==0).).flip mod)
17:10:24 <lambdabot> flip flip 0 . ((==) .) . flip mod
17:10:25 <Olathe> Eww.
17:10:26 <dancor> i guess many of the libraries it has wouldn't build anyway?
17:10:43 <dancor> not if they used old exception stuff
17:10:44 <Cale> dancor: It would be somewhat surprising if they didn't.
17:11:09 <Apocalisp> @hoogle (Functor f, Arrow a) => f (a b c) -> a (f b) (f c)
17:11:09 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
17:11:09 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
17:11:33 <Twey> @src zip
17:11:33 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:11:33 <lambdabot> zip _      _      = []
17:12:51 <dancor> Cale: well that's good :)  currently running my build of cabal-install always hangs on Resolving dependcies until it eats alls memory
17:14:58 <dancor> i wasn't sure if it's me-specific or if it's kind of a known-problem that will be fixed for ghc 6.10
17:15:08 <ddarius> yrlnry: It could have been worse, it could have been: data Mu f = Mu (f (Mu f))
17:16:07 <Cale> dancor: I would almost expect cabal-install to be packaged with 6.10 in the end...
17:16:17 <Cale> At least I *hope* something like that is in the works :)
17:16:22 <dancor> that would cool
17:16:25 <dancor> be
17:21:40 <BMeph_> Cale: Say, I don't know how useful it is, but it looks intriguing...
17:22:33 <Cale> BMeph_: what?
17:22:44 <BMeph_> Cale: (><) :: forall a b f. (Functor f) => (f a, f b) -> f (a, b)
17:23:07 <Cale> oh?
17:23:23 <Cale> I don't think you can write a function with such a type...
17:23:36 <Cale> You can certainly do the opposite.
17:23:55 <Cale> You could also make a class for functions like that.
17:24:01 <BMeph_> Cale: Currently, I just use (><) = uncurry (***), but it may have more uses (i.e., a sub for 'zip')... :)
17:24:16 <Cale> :t uncurry (***)
17:24:17 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
17:25:37 <BMeph_> Cale: Well, technically, I guess it'd be a substitute for 'uncurry zip' so, maybe even more non-useful... :)
17:25:41 <ddarius> :t fmap fst &&& fmap snd
17:25:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
17:26:08 <Saizan> ?type uncurry (liftA2 (,))
17:26:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
17:27:44 <BMeph_> :t uncurry zip
17:27:45 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
17:28:01 <BMeph_> Got the types right, good. :)
17:28:06 <dancor> does anyone think it would be useful to allow things like   a `f g` b
17:28:21 <dancor> for  f g a b
17:28:50 <EvilTerran> ?let infixl 9 «, »; («) = flip ($); (») = ($)
17:28:50 <lambdabot>   Illegal character ''\171''
17:28:52 <EvilTerran> grr
17:29:24 <EvilTerran> . let infixl 9 «, »; («) = flip ($); (») = ($) in [1,2,3] «zipWith (+)» [4,5,6]
17:29:28 <lunabot>   lexical error at character '\171'
17:29:33 <EvilTerran> grr!
17:29:38 <EvilTerran> dancor, anyway, you get the idea
17:29:49 <dancor> EvilTerran: cool
17:29:51 <mmorrow> hmm, i though lunabot allowed unicode
17:30:00 <Saizan> lambdabot should too
17:30:02 <dancor> yeah isn't that the point of lunabot?
17:30:16 <mmorrow> . let (») = 4 in (»)
17:30:17 <lunabot>   lexical error at character '\187'
17:30:28 <EvilTerran> actually, i think i tend to use infixl 1 for those
17:30:36 <mmorrow> . let (») = (+) in (») 7 8
17:30:37 <lunabot>   lexical error at character '\187'
17:30:41 <mmorrow> weird
17:30:46 <EvilTerran> it might be that » isn't an operator character
17:30:51 <EvilTerran> or an alphanumeric
17:31:03 <mmorrow> yeah, that's gotta be it
17:31:15 <Saizan> it works in ghci
17:31:40 <Saizan> >  let (») = (+) in (») 7 8
17:31:42 <lambdabot>   15
17:31:48 <EvilTerran> er
17:31:56 <mmorrow> . let (») = (+) in (») 7 8
17:31:57 <lunabot>   lexical error at character '\187'
17:32:01 <mmorrow> wtf!!
17:32:05 <mmorrow> arg
17:32:18 <mmorrow> hmm
17:32:19 <EvilTerran> > let (») = (,) in 7 » 8
17:32:20 <lambdabot>   (7,8)
17:32:33 <EvilTerran> > let infixl 9 «, »; («) = flip ($); (») = ($) in [1,2,3] «zipWith (+)» [4,5,6]
17:32:34 <lambdabot>   [5,7,9]
17:32:46 <EvilTerran> ... did someone do something to lambdabot?
17:32:47 <lunabot>   parse error on input `..'
17:33:14 <EvilTerran> ?let infixl 1 «, »; («) = flip ($); (») = ($)
17:33:14 <lambdabot>   Illegal character ''\171''
17:33:17 <EvilTerran> wat
17:33:42 <mmorrow> apparently this is '\171' ű
17:33:57 <mmorrow> maybe your chat client is mangling it?
17:34:03 <EvilTerran> i detect a bug in ?let
17:34:11 <mmorrow> ah, maybe that's it
17:34:11 <EvilTerran> seeing as it worked for > but not ?let
17:34:16 <Olathe> > say "\171"
17:34:17 <lambdabot>   «
17:34:23 <mmorrow> hm
17:34:30 <mmorrow> oh, oops
17:34:35 <mmorrow> i checked 0x171
17:34:45 <mmorrow> (which is ű)
17:37:54 <Saizan> > isSymbol '«'
17:37:56 <lambdabot>   False
17:37:59 <Saizan> hah!
17:38:07 <actor> so could you create a optionally declared Scala?
17:38:18 <actor> if haskells typesystem isnt tied to the purity...
17:38:32 <actor> or it it the object-orientation that is in the way?
17:38:46 <Saizan> actor: the problem with type inference in Scala is the subtyping, afaiu
17:38:48 <dons> you could do some type inference in scala (i thought you already could?)
17:38:59 <actor> there seem to be some
17:39:32 <actor> I think Scala is like the choice for the pragmatic "get stuff done now" functional programmers
17:39:35 <actor> a good mix
17:39:40 <actor> but i hate all the typing
17:39:47 <bbs> hey guys
17:39:48 <Saizan> is '«' defined to be a symbol, by Unicode?
17:39:51 <actor> it feels so primitive
17:41:21 <bbs> is there a way to take two sorted lists and merge them into one sorted list?
17:41:28 <bbs> i mean easily and recursively
17:42:11 <TomMD> @seen dcoutts
17:42:12 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 34m ago.
17:42:19 <Olathe> bbs: Sure.
17:42:26 <BMeph_> . isSymbol '«'
17:42:27 <lunabot>   lexical error at character '\171'
17:42:45 <bbs> @seen bbs
17:42:46 <lambdabot> You are in #haskell. I last heard you speak just now.
17:42:50 <bbs> haha
17:42:51 <BMeph_> thhhhhhhhhhhhhhhhhhhpt! :p
17:43:12 <Olathe> > let merge aas@(a:as) bbs@(b:bs) = if a < b then a:merge as bbs else b:merge aas bs in merge [1, 5, 7] [3, 4, 10]
17:43:13 <lambdabot>   mueval: Prelude.read: no parse
17:43:13 <lambdabot>  mueval: [1,3,4,5,7*** Exception: /tmp/76495...
17:43:33 <Olathe> > let merge aas@(a:as) bbs@(b:bs) = if a < b then a:merge as bbs else b:merge aas bs; merge [] bs = bs; merge as _ = as in merge [1, 5, 7] [3, 4, 10]
17:43:35 <lambdabot>   [1,3,4,5,7,10]
17:44:00 <Olathe> @type let merge aas@(a:as) bbs@(b:bs) = if a < b then a:merge as bbs else b:merge aas bs; merge [] bs = bs; merge as _ = as in merge
17:44:01 <lambdabot> forall t. (Ord t) => [t] -> [t] -> [t]
17:45:33 <Olathe> @free forall t. (Ord t) => [t] -> [t] -> [t]
17:45:34 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
17:46:30 <Olathe> @free merge :: forall t. (Ord t) => [t] -> [t] -> [t]
17:46:30 <lambdabot> Extra stuff at end of line
17:46:39 <bbs> Olathe: thanks
17:46:43 <Olathe> You're welcome.
17:46:46 <bbs> :)
17:49:17 <thoughtpolice> @seen ndm
17:49:17 <lambdabot> I haven't seen ndm.
17:49:57 <mmorrow> there's something messed up with how lunabot's handling unicode, trying to figure it out...
17:56:44 <mmorrow> . let (λ) = (+) in (λ) 3 4
17:56:45 <lunabot>  7
17:57:02 <mmorrow> it must be ghc-HEAD, because that works but ...
17:57:04 <dolio> Oh man, a bot with unicode.
17:57:11 <mmorrow> . let (») = (+) in (») 7 8
17:57:12 <lunabot>   lexical error at character '\187'
17:57:15 <mmorrow> that doesn't
17:57:24 <mmorrow> and i'm doing the unicode correctly..
17:57:33 <mmorrow> dolio: hehe
17:57:59 * BMeph_ hands dolio a dish towel, to catch the stray drool...
17:58:09 <BMeph_> ;)
18:00:15 <mmorrow> . (\λ -> λ) 0
18:00:16 <lunabot>  0
18:00:31 <mmorrow> i though it was supposed to allow (λ x -> x) 0
18:00:32 <Twey> . let x Δ y = y - x in 8 Δ 16
18:00:32 <lunabot>   Not in scope: data constructor `'
18:00:32 <lunabot>  <interactive>:1:73: Not in scope: data constructor `'
18:00:37 <Twey> Hmnhmn
18:00:41 <Saizan> mmorrow: my patch that has been included in haskell-src-exts uses isSymbol, but isSymbol '»' == False
18:00:49 <Twey> . let x δ y = y - x in 8 δ 16
18:00:50 <lunabot>   Not in scope: `δ'
18:00:53 <Twey> Oh it's a capital
18:00:54 <Twey> Clever
18:00:58 <Twey> But fail :(
18:01:03 <Saizan> > isSymbol 'λ'
18:01:04 <mmorrow> Saizan: ah, ok. phew
18:01:04 <lambdabot>   False
18:01:08 <Saizan> uhm
18:01:22 <mmorrow> . isSymbol
18:01:23 <lunabot>   Not in scope: `isSymbol'
18:01:25 <mmorrow> damn
18:01:28 <Saizan> why does that work then?
18:01:36 <mmorrow> weird happenings
18:01:42 <Twey> Ohhh
18:01:47 <Twey> Because it isn't a symbol
18:01:48 <Twey> It's a letter
18:01:52 <mmorrow> ah
18:01:57 <mmorrow> truetrue
18:02:00 <Twey> . let δ = 5 in δ
18:02:01 <lunabot>  5
18:05:05 <Saizan> oh, let (λ) = (+) in (λ) 3 4 simply works because you can put parenteses around anything :)
18:05:22 <Saizan> it's not parsed as an operator.
18:05:46 <mmorrow> heh, tricky
18:05:49 <Twey> Aye
18:05:52 <Twey> Heh
18:08:20 <Saizan> > isPunctuation '»'
18:08:21 <lambdabot>   True
18:08:53 <bd_> > isPunctuation '※'
18:08:54 <lambdabot>   True
18:10:00 <Olathe> > isPunctuation 'Ｎｏｔ'
18:10:01 <lambdabot>       lexical error in string/character literal at character '\65359'
18:10:27 <newsham> > isPunctuation 'Ｎ'
18:10:28 <Olathe> > isPunctuation 'Ｎ'
18:10:28 <lambdabot>   False
18:10:29 <lambdabot>   False
18:10:50 <newsham> which versions of ghc allow unicode in src?
18:10:54 <Olathe> > let (Ｎ) a b = 5 in 2 Ｎ 4
18:10:55 <lambdabot>   mueval: Prelude.read: no parse
18:10:55 <mmorrow> > zip "Ｎｏｔ" $ fmap isPunctuation "Ｎｏｔ"
18:10:56 <lambdabot>   [('\65326',False),('\65359',False),('\65364',False)]
18:11:52 <mmorrow> > let a = "Ｎｏｔ"  in zip a (zip (fmap utf8 a) (zip (fmap isPunctuation a)))
18:11:53 <lambdabot>   Couldn't match expected type `[b]'
18:11:55 <newsham> > let (≥) = (>=) in 8 ≥ 3
18:11:56 <lambdabot>   True
18:12:00 <mmorrow> @type utf8
18:12:02 <lambdabot> Char -> [Char]
18:12:07 <mmorrow> oh
18:12:16 <mmorrow> > let a = "Ｎｏｔ"  in zip a (zip (fmap utf8 a) (fmap isPunctuation a))
18:12:17 <lambdabot>   [('\65326',("\239\188\174",False)),('\65359',("\239\189\143",False)),('\653...
18:13:50 <dolio> > let a = "Ｎｏｔ" in fmap (id &&& utf8 &&& isPunctuation) a
18:14:03 <lambdabot>   mueval: Prelude.read: no parse
18:14:10 <waynemokane> how can I call connectTo, which is of type HostName -> PortID -> IO Handle, from within a function that is (MonadIO a, State s) => s -> a s     ?
18:14:21 <andyjgill> The Haskell Symposium Schedule is just posted on http://www.haskell.org/haskell-symposium/2008/schedule.html
18:14:22 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Schedule
18:14:27 <waynemokane> getting a type inferrence error: Couldn't match expected type `a' against inferred type `IO'
18:14:37 <waynemokane> but a is (MonadIO a)
18:15:13 <mmorrow> @type liftIO
18:15:14 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
18:16:13 <thoughtpolice> right, you have to use liftIO to bring the IO action into the the 'MonadIO a' (whatever it might be
18:16:47 <mmorrow> dolio: lb has problems with &&& and *** for whatever reason
18:17:01 <thoughtpolice> the type signature states that this function can be run in the context of any monad which is an instance of MonadIO
18:18:00 <thoughtpolice> but while IO is an instance of MonadIO, the functions used in there have to be able to run in *any* instance of MonadIO - for example, ReaderT or something
18:18:19 <thoughtpolice> waynemokane: make sense?
18:18:42 <waynemokane> hmmm yes, I think so
18:18:52 <waynemokane> so liftIO is the ticket
18:19:27 <mmorrow> newsham: i'm not sure what versions. also, there might be a flag to turn it on in earlier versions (i think it's on by default in current ghcs?)
18:20:08 <MarcWeber> dcoutts: http://rafb.net/p/mUyOZz14.html Has there a change, do I have messed something up? Is there a LANGUAGE CPP missing within the source file?
18:20:13 <lambdabot> Title: Nopaste - No description
18:20:51 <thoughtpolice> waynemokane: right, the liftIO turns it from just 'IO a' into '(MonadIO m) => m a', so that when you lift it, that function can be used in any monad transformer or whatnot that is also an instance of MonadIO
18:21:54 <MarcWeber> dcoutts: Sorry, You've already seen it. I didn't pull
18:22:22 <thoughtpolice> waynemokane: another way of putting it is if you have some sort of monad transformer or something, if you make it an instance of MonadIO, you can use liftIO to bring regular IO actions into your monad
18:24:54 <djsiegel> http://hpaste.org/10456#a1 -- why does the final putStrLn in main cause a compile error? If I remove it, everything is fine. If not, the compiler thinks it belongs to the let expression.
18:25:35 <thoughtpolice> djsiegel: indent it to the same width as the 'forM' below it
18:25:36 <djsiegel> Ah, :retab fixed it. Damned tabs vs. spaces
18:26:25 <djsiegel> thoughtpolice, vim was hiding that from me :)
18:26:47 <djsiegel> how do I force spaces once and for all? I feel like I always change that setting in a config file, but it reverts
18:28:04 <MarcWeber> djsiegel: echo 'setlocal ...' >> ~/.vim/ftplugin/haskell.vim
18:28:59 <djsiegel> setlocal ...? I have that file, and it contains set expandtab
18:31:54 <MarcWeber> djsiegel: set can be overriden. setlocal is for that buffer only and will override the global setting..
18:32:38 <djsiegel> ok, so I should change it to that, ok, will try, thanks
18:41:15 <sjanssen> MonomorphismRestriction--
18:41:55 <thoughtpolice> need that be said?
18:41:57 <mmorrow> free(MonomorphismRestriction);
18:42:15 <sjanssen> segmentation fault
18:42:19 <mmorrow> heh
18:47:40 <waynemokane> aaah, Haskell, a little bit of rationality in a world that is otherwise collapsing
18:48:13 <ddarius> > pi
18:48:14 <lambdabot>   3.141592653589793
18:48:39 <Olathe> lambdabot had to ruin it with irrationality.
18:49:04 <mmorrow> > pi :: CReal
18:49:05 <lambdabot>   3.1415926535897932384626433832795028841972
18:49:07 <tautologico> an elegant weapon... for a more civilized time
18:50:02 <waynemokane> so in most applications doing client->server TCP communicatoin, the hGet* and hPut* functions are prefereable to sendTo and recvFrom?
19:20:48 <andyjgill> Evening all.
19:21:17 <cads> this statement    f n = foldl g [n] [1..floor $ sqrt $ n]      is giving me an error when I try to compile it,  No instance for (Floating Int)
19:21:20 <cads> any ideas?
19:21:42 <dons> can't sqrt 'n' ?
19:23:01 <cads> well,    I have   f::Integer->[Integer]
19:24:14 <dons> so what's 'g' do?
19:24:16 <Olathe> > let f n = foldl g [n] [1..floor $ sqrt $ n] in f 5
19:24:18 <lambdabot>       No instance for (SimpleReflect.FromExpr [t])
19:24:18 <lambdabot>        arising from a use ...
19:24:20 <dolio> Then n is an Integer.
19:24:29 <cads> I shall paste the code
19:24:32 <dolio> And you can't sqrt an Integer.
19:24:55 <chrisdone> any haskell screencasts?
19:25:38 <chrisdone> I just figured out how to use vnc2swf
19:25:56 <cads> http://hpaste.org/10476
19:25:59 <cads> that code works
19:26:39 <cads> the square root bit is substituted with plain n..
19:27:02 <cads> dolio, why doesn't sqrt work with an Integer?
19:27:09 <cads> grap
19:27:11 <dolio> @type sqrt
19:27:12 <lambdabot> forall a. (Floating a) => a -> a
19:27:21 <dolio> Integer isn't a member of the Floating class.
19:27:26 <cads> yeah that's the error
19:28:23 <Twey> How odd
19:28:38 <Twey> > sqrt 100 -- so this is an error?
19:28:39 <lambdabot>   10.0
19:28:44 * Twey blinks.
19:28:46 <Twey> Oh
19:28:49 <Twey> Aye.  :)
19:28:57 <dolio> 100 :: Num a => a
19:29:04 <Twey> > sqrt (100 :: Integer) -- this is
19:29:05 <lambdabot>       No instance for (Floating Integer)
19:29:05 <lambdabot>        arising from a use of `sqrt' ...
19:30:24 <dolio> > sqrt (fromInteger (100 :: Integer))
19:30:25 <lambdabot>   10.0
19:31:03 <ddarius> Use fromIntegral
19:36:43 <adu> hi
19:38:55 <chrisdone> hi
19:39:10 <BMeph> lo
19:39:12 <BMeph> ;p
19:39:40 <Olathe> > let iSqrt 0 = 0; iSqrt n = if leadingDigits*leadingDigits > n then leadingDigits - 1 else leadingDigits where leadingDigits = 2*iSqrt (div n 4) + 1 in iSqrt 25
19:39:42 <lambdabot>   5
19:40:40 <Olathe> Take that, nonintegral square root !
19:41:31 <adu> > let iSqrt 0 = 0; iSqrt n = if leadingDigits*leadingDigits > n then leadingDigits - 1 else leadingDigits where leadingDigits = 2*iSqrt (div n 4) + 1 in iSqrt 8
19:41:32 <lambdabot>   2
19:42:31 <Olathe> @let iSqrt 0 = 0; iSqrt n = if leadingDigits*leadingDigits > n then leadingDigits - 1 else leadingDigits where leadingDigits = 2*iSqrt (div n 4) + 1
19:42:33 <lambdabot>  Defined.
19:42:35 <adu> Olathe: so does iSqrt = (floor . sqrt)?
19:42:39 <Olathe> Sure.
19:42:53 <Olathe> > map iSqrt [0..]
19:42:55 <lambdabot>   [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,...
19:43:05 <Olathe> > map floor.sqrt [0..]
19:43:06 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:43:10 <Olathe> > map (floor.sqrt) [0..]
19:43:12 <lambdabot>   [0,1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,...
19:43:26 <roconnor> > map length $ group $ map iSqrt [0..
19:43:27 <lambdabot>   mueval: Prelude.read: no parse
19:43:32 <roconnor> > map length $ group $ map iSqrt [0..]
19:43:33 <Olathe> Only this won't have truncation issues with large Integers.
19:43:35 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
19:43:41 <Olathe> It'll give exact results.
19:43:55 <Olathe> roconnor: How very odd.
19:43:58 <adu> there are truncation errors?
19:44:10 <Olathe> Yeah, with sqrt, it gives doubles.
19:44:20 <Olathe> As far as I know.
19:44:24 <Olathe> Maybe it can use creal.
19:44:27 <adu> doubles?!?
19:44:36 <Olathe> > showCReal 5 (sqrt 5)
19:44:37 <lambdabot>   "2.23607"
19:44:38 <roconnor> Olathe: floor is uncomputable on CReals
19:44:39 <Olathe> Ahh.
19:44:47 <Olathe> roconnor: It's what ?
19:44:53 <roconnor> uncomputable
19:44:59 <roconnor> incomputable
19:45:07 <roconnor> acomputable?
19:45:12 <Olathe> Can it display the digits until the point ?
19:45:14 <ddarius> Surely it is semi-decidable.
19:45:16 <adu> whats a CReal?
19:45:25 <Olathe> If it can, it can read that.
19:45:57 <roconnor> ddarius: floor can be computed for non-integers
19:46:05 <Olathe> > takeWhile (/= '.') $ showCReal 5 (sqrt 5)
19:46:06 <lambdabot>   "2"
19:46:09 <Olathe> > read $ takeWhile (/= '.') $ showCReal 5 (sqrt 5)
19:46:11 <lambdabot>   mueval: Prelude.read: no parse
19:46:11 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
19:46:18 <Olathe> > (read $ takeWhile (/= '.') $ showCReal 5 (sqrt 5)) :: Integer
19:46:19 <lambdabot>   2
19:46:33 <roconnor> ddarius: ... techinically floor cna also be computed for inegers, but because there is no excluded middle, it it still can't be computed for all reals
19:46:54 <Olathe> Is there an example of a number where it can't ?
19:47:08 <Olathe> I'm not doubting it, I'm just interested in how it would fail.
19:48:38 <roconnor> Olathe: sum [(if (oddPerfectNumber i) then 0 else 1)/(2^i) | i <-[0..]]
19:49:17 <Olathe> Ahh.
19:49:20 <roconnor> well, you have to rewrite that sum so that it produces a CReal, but that can be done.
19:51:06 <adu> roconnor: why wouldn't that be 0?
19:51:12 <Olathe> That seems to be an infinite sum.
19:51:26 <Olathe> Are all the examples infinitely-long computations (on a real computer) ?
19:52:08 <Olathe> Hmm...
19:52:12 <Olathe> Actually...
19:52:19 <Olathe> I think that number is computable.
19:52:31 <Olathe> oddPerfectNumber is computable.
19:52:43 <Olathe> So, you can compute any digit you like.
19:52:54 <roconnor> adu: there might be an oddPerfectNumber
19:53:10 <Olathe> I can understand that it's unsolved, but not uncomputable.
19:53:32 <roconnor> oddPerfectNumber is computable
19:53:42 <adu> what is oddPerfectNumber?
19:53:50 <roconnor> and that sum above is geometric, and the limit can be computed as a CReal
19:53:56 <Olathe> I might be misunderstanding uncomputable, though.
19:54:12 <roconnor> adu: a famous unsolved problem about numbers.
19:54:15 <Olathe> I thought it was a number where an arbitrary digit can't be computed.
19:54:24 <ddarius> roconnor: That's not an example.
19:55:19 <roconnor> Olathe: ceiling of this number I stated above is not comptable
19:55:30 <adu> roconnor: I meant the integer part, wouldn't the integer part just be zero?
19:55:39 <roconnor> I'll leave it as an exercise to turn this into a number where floor cannot be computed :P
19:55:43 <Olathe> roconnor: Ahh.
19:55:53 <roconnor> my bad for messing that up
19:55:57 <Olathe> Well, that's easy enough :)
19:56:01 <roconnor> ceiling vs floor
19:56:05 <Olathe> floor and ceiling are closely related.
19:56:09 <roconnor> :)
19:57:03 <adu> doesn't floor x = -ceiling (-x)?
19:57:12 <roconnor> adu: yes
19:57:21 <Olathe> @check \x -> floor x = -ceiling (-x)
19:57:22 <lambdabot>   Parse error at "=" (column 15)
19:57:25 <Olathe> @check \x -> floor x == -ceiling (-x)
19:57:26 <lambdabot>   "OK, passed 500 tests."
19:57:42 <roconnor> @check \x -> floor x == ceiling (x)
19:57:43 <lambdabot>   "Falsifiable, after 0 tests:\n3.6666666666666665\n"
19:57:51 <roconnor> er
19:57:59 <roconnor> @check \x -> floor x == ceiling (x)-1
19:58:00 <lambdabot>   "Falsifiable, after 2 tests:\n-1.0\n"
19:58:02 <ddarius> roconnor: Why is the ceiling not computable?
19:58:04 <roconnor> good
19:58:29 <roconnor> ddarius: what is the ceiling of sum [(if (oddPerfectNumber i) then 0 else 1)/(2^i) | i <-[0..]]?
19:59:44 <dolio> 0, clearly.
19:59:53 <ddarius> roconnor: If it oddPerfectNumber returns true for some number, then it is 1, if it never returns true then it is 0.  Are you claiming that ascertaining this is undecideable?  Admittedly, in the latter case, as written, it will not terminate.
20:00:47 <roconnor> ddarius: I'm claiming there is no general solution to problems of this form.
20:01:38 <roconnor> how about ceiling of sum [(if (the ith proof in ZFC proves False) then 0 else 1)/(2^i) | i <-[0..]]?
20:01:46 <ddarius> roconnor: That's a different claim and irrelevant.  However, you could easily make a number using a similar format that is undecideable.
20:02:50 <roconnor> are you claiming that a ``If it oddPerfectNumber returns true for some number, then it is 1, if it never returns true then it is 0.'' is decidable?
20:05:42 <ddarius> It's definitely semi-decidable as written and if oddPerfectNumber does return true for some number it is completely decideable.
20:06:39 <roconnor> sure, floor and ceiling are "semi-decidable" in that it can be computed from some inputs
20:08:20 <roconnor> can floor and ceiling be computed for the values I give above?  I don't know.
20:08:24 <roconnor> maybe not
20:08:31 <ddarius> My main point is that using an unsolved problem here doesn't imply undecidability or even semi-decidability and is silly when there are perfectly good undecidable problems.
20:09:13 <roconnor> there are no perfectly good undecidable problems of this kind.  All of them are of this nature.
20:10:06 <roconnor> "this nautre" meaning that I require a Pi_1 problem.
20:10:45 <adu> whats Pi_1?
20:11:04 <roconnor> ddarius: do you consider (the ith proof in ZFC proves False) to be an undecidable problem rather than an unsolved problem?
20:11:56 <roconnor> adu:  a mathematical question of the form "forall n:nat, P(n)"  where P :: nat -> bool
20:12:24 <dolio> http://en.wikipedia.org/wiki/Arithmetical_hierarchy
20:12:25 <lambdabot> Title: Arithmetical hierarchy - Wikipedia, the free encyclopedia
20:12:28 <roconnor> e.g. forall n:nat, not (isOddPerfectNumber n)
20:13:17 <roconnor> (P has to be total and computable)
20:14:08 <ddarius> roconnor: Is "the ith proof in ZFC proves False" even decidable for a any given i in general?
20:14:37 <roconnor> ddarius: sorry, I mean "forall i, the ith proof in ZFC proves False"
20:14:49 <roconnor> er
20:14:57 <roconnor> ddarius: sorry, I mean "forall i, not (the ith proof in ZFC proves False)"
20:15:17 <BMeph> roconnor: Your "perfect number" problem is solipsistic. :)
20:16:00 <roconnor> BMeph: we aren't allowed to use Fermat's last theorm anymore. :P
20:16:17 <Runaro> ?type unzip
20:16:19 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
20:16:19 <Runaro> ?type ap
20:16:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:16:35 <Runaro> is there a function that captures this pattern?
20:16:40 <BMeph> roconnor: It's still solipsistic. Just because *you* don't know the answer, doesn't mean the answer is unknowable... ;p
20:17:28 <BMeph> Runaro: Which pattern? :)
20:18:09 <adu> roconnor: ya just be patient
20:18:29 <roconnor> BMeph: depends on what you mean by knowable.  Would we know the answer if we proved there were no odd perfect numbers in ZFC?, how about ZFC + exists infinite large cardinals? What if ZFC is found to be inconsistent?  What if PA is found to be inconsistent?
20:18:44 <Runaro> forall (f :: * -> *, t :: * -> * -> *) a b. (Bifunctor t, Functor f) => f (t a b) -> t (f a) (f b)
20:18:46 <Runaro> That pattern
20:19:31 <adu> roconnor: press enter, then wait while the mathematicians work, and then someone will find a way to dynamically update your system just in time for you to see "0\n>" before old age sets in :)
20:19:47 <ddarius> roconnor: Again, if someone finds an inconsistency then that is completely decidable.
20:19:48 <roconnor> :)
20:20:04 <BMeph> Runaro: (m:: * -> *) (k :: * -> * -> *) => m (k a b) -> k (m a) (m b)?
20:20:20 <roconnor> ddarius: okay name your perfectly good undecidable question that I can use.
20:20:21 <Runaro> yes, that
20:20:33 <BMeph> Runaro: (modulo various foralls and type var. declarations...)
20:20:52 <BMeph> :t on
20:20:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:21:02 <adu> roconnor: P(n) = not P(n)
20:21:31 <BMeph> Runaro: Well, it's not the same, but it looks like a type-level version of 'on'. :)
20:21:49 <ddarius> roconnor: Maybe I was wrong about that.  Certainly something more directly related to the Halting Problem would seem sensible.  However, you are the one making the claim ceiling on CReal is undecidable not just that there are examples where the correct output is unknown.
20:22:41 <Runaro> Bitraversable.bidist is the other way round
20:23:04 <ddarius> sum (if the ith program terminates then 0 else 1/(2^i))
20:23:26 <Runaro> bidist :: (Bitraversable s, Applicative m) => s (m a) (m b) -> m (s a b)
20:23:30 <ddarius> Actually there is no need for a sum there
20:24:49 <dolio> Isn't that easily 1?
20:25:11 <dolio> Construct a Turing machine that doesn't halt, compute its integer representation. That bit is set.
20:25:15 <ddarius> dolio: Not necessarily, but probably, but you can drop the sum or do every even one.
20:25:27 <ddarius> dolio: It depends on the definition of "ith program"
20:25:37 <roconnor> badReal n = sum (if the nth program does not terminate in i steps then 0 else 1/(2^i))
20:25:51 <roconnor> badInteger n = ceiling (badReal n)
20:26:00 <roconnor> badReal is computable
20:26:06 <Twey> 'badReal n = sum'?
20:26:17 <roconnor> if ceiling were computable badInteger were computable
20:26:26 <roconnor> badInteger solves the halting problem
20:26:32 <roconnor> ergo ceiling is not computable.
20:27:01 <dmwit> WRONG!
20:27:03 <Twey> badInteger _ = ceiling sum
20:27:26 <unmarshal> @seen dons
20:27:27 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 17m 35s ago.
20:27:37 <roconnor> badReal n = sum [if the nth program does not terminate in i steps then 0 else 1/(2^i)) | i<-[0..]]
20:27:55 <Twey> Oh, I se
20:27:56 <dmwit> You say, "If ceiling is computable, then badInteger is computable", but in fact the correct premises are "if ceiling is computable and badReal is computable, then badInteger is computable."
20:27:58 <Twey> Heh
20:28:00 <ddarius> I'm pretty sure you could construct a diagonalization argument with some such CReal by using the result on ceiling inside it.
20:28:19 <roconnor> dmwit: [22:26] <roconnor> badReal is computable
20:28:44 <ddarius> > ceiling (1.5 :: CReal)
20:28:46 <lambdabot>   2
20:29:19 <dmwit> mmm
20:30:15 <dmwit> But I do not think badReal is computable.
20:30:32 <BMeph> Runaro: Err, it'd be 'flip on', actually. :)
20:30:45 <roconnor> dmwit: it is although I didn't write out the real program.
20:30:50 <dolio> You can compute any binary digit of it.
20:31:02 <roconnor> the real program looks more like
20:31:14 <roconnor> badReal n = geometricSum 2 [if the nth program does not terminate in i steps then 0 else 1/(2^i)) | i<-[0..]]
20:31:17 <Runaro> Hmmm... so if Traversable.dist is m1 (m2 a) -> m2 (m1 a), and Bitraversable.bidist is m1 (m2 a b) -> m2 (m1 a) (m1 b), then what is m2 (m1 a) (m1 b) -> m1 (m2 a b)?
20:31:47 <roconnor> then I have to define geometricSum.  I leave that as an exercise.
20:32:13 <dmwit> roconnor: You're saying an arbitrary infinite sum is computable.  I simply don't believe you.
20:33:05 <ddarius> dmwit: It's just a sequence of bits.
20:33:33 <dmwit> I'm with you so far...
20:33:45 <Runaro> dmwit: Let me get the proof for you. Do you have an eternity to burn?
20:34:55 <dolio> badReal n = go (program n) where go p = case step p of Halt -> repeat 1 ; Next p' -> 0 : go p'
20:35:36 <dolio> In [Digit] form.
20:38:51 <leimy> So i've got this code using socket handles, testing with netcat
20:39:11 <leimy> and I'm getting all but the last character of the text I'm typing coming in with hGetLine
20:39:23 <leimy> Am I doing something obviously stupid here?
20:39:57 * BMeph admirably resists the wide-open cheap shot...
20:40:10 <mmorrow> um, by last char do you mean '\n'?
20:40:13 <dolio> No one but us theoreticians here.
20:40:33 <leimy> mmorrow: nope
20:40:38 <leimy> the character before that one.
20:40:51 <mmorrow> hmm, i dunno
20:40:52 <leimy> I'm expecting to lose the \n
20:41:04 <leimy> if I hook up two netcats I'm not getting that issue.
20:41:07 <mmorrow> are you flushing the Handle?
20:41:21 <leimy> that's what I'm wondering... if I should do that flush or if it's necessary.
20:41:25 <dmwit> Wow, that's a good one.
20:41:33 <mmorrow> you should flush, that always gets me
20:41:38 <dmwit> If you send two lines, does it drop one character per line?
20:41:49 <mmorrow> then i flush and all of a sudden ... everything work
20:41:50 * dmwit bets the final character comes through with the second line
20:41:53 <mmorrow> s
20:41:59 <leimy> well hGetLine is getting the newline for sure, or it wouldn't return :-)
20:42:07 <mmorrow> weird
20:42:09 <leimy> but the character *before* the newline isn't coming out
20:42:14 * mornfall suspects cr/lf trouble.
20:42:16 <leimy> and I print it to the terminal with putStrLn
20:42:18 <leimy> AH!
20:42:23 <leimy> totally could be cr/lf vs lf
20:42:28 <mmorrow> yeah, probably \r\n problems
20:42:34 <mmorrow> are you on windows?
20:42:36 <leimy> nope
20:42:39 <leimy> Mac OS X :-)
20:42:48 <mmorrow> hmm
20:42:48 <Twey> It doesn't strip the \r unless you're on Windows
20:43:06 <leimy> but still that's a pretty good hint.
20:43:12 <Twey> Platform-dependant EOL on sockets was not one of the smarter ideas in Network...
20:43:51 <mornfall> Twey: Does it really depend on the Network? I'd more expect the sender to decide on that...
20:44:04 <leimy> I'm going to change the code to not use hGetLine
20:44:15 <Twey> mornfall: hGetLine, applied to a socket handle, grabs the \r on Linux
20:44:37 <mmorrow> Twey's right
20:44:39 <mornfall> leimy: Well, you can try hGetContents and dump that in a single putStrLn or such.
20:44:48 <leimy> yeah
20:44:49 <mornfall> Twey: But not on windows?
20:44:53 <mmorrow> you can just check for '\r' and strip it if found
20:44:53 <Twey> Aye
20:44:57 <Twey> mornfall: Stupid, eh?
20:45:03 <mornfall> Twey: Incredibly.
20:45:28 <leimy> mornfall: That works just fine.
20:45:31 <mornfall> Twey: Would hGetLine be doing the stripping?
20:45:35 <leimy> hGetContents
20:45:44 <leimy> hGetLine is assuming it's going to get CR LF
20:45:47 <leimy> I suspect
20:45:54 <mmorrow> don't use hGetContents though if you don't want the Handle closed
20:45:58 <Twey> hAgnosticGetLine h = hGetLine h >>= return . takeWhile (not . (`elem` "\r\n"))
20:46:02 <mornfall> leimy: lines?
20:46:10 <Twey> mornfall: Aye
20:46:23 <mmorrow> Twey: you have to make sure you're only stripping an '\r' at the end though
20:46:30 <Twey> mornfall: It's because it's interface-independent
20:46:50 <Twey> mmorrow: I think that for most purposes, \r is as good as a newline
20:46:54 <mornfall> Twey: Well, that's, things combined, pretty silly. All of that separately makes perfect sense though...
20:46:55 <mmorrow> let go [] = [] ; go "\r" = [] ; go (c:cs) = c : go cs
20:47:07 <Olathe> Does anyone have any ideas for completing this: http://hpaste.org/10481
20:47:14 <Twey> mornfall: Yeah.
20:47:47 <roconnor> dmwit: I'm saying that an arbitrary (sub-)geometric series is always computable.
20:47:50 <Twey> mornfall: But I think there should be a separate couple of hLfGetLine and hCrLfGetLine functions somewhere.
20:48:03 <mmorrow> hGetLine' h = go `fmap` hGetLine h
20:48:09 <Olathe> invFact (fact n) will give (n `div` 2)*2
20:48:18 <mornfall> Twey: Yeah, that would make  sense. Probably not in stdlib tho?
20:48:27 <Runaro> @hoogle (Monad m, Arrow c) => m (c a b) -> m a -> m b
20:48:27 <lambdabot> Data.Map lookup :: (Monad m, Ord k) => k -> Map k a -> m a
20:48:27 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
20:48:27 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
20:48:29 <dmwit> roconnor: But you have to figure out where it starts (respectively, ends) before you can calculate it... which is not computable.
20:48:32 <Twey> I would put it in Network, probably
20:48:36 <mornfall> And a fat warning on hGetLine: don't use with inbound network traffic.
20:48:44 <Twey> Aye, heh
20:49:23 <roconnor> dmwit: to approximate the sub-geometric series to within (1/2^n) simply add the first (n+1) terms.
20:49:28 <mornfall> (It's just like network byte order...)
20:49:42 <roconnor> the remainder is guarenteed to be less than (1/2^n)
20:49:52 <dmwit> roconnor: Yes, and...?
20:49:59 <Runaro> @hoogle (Functor m, Arrow c) => m (a -> b) -> c (m a) (m b)
20:49:59 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
20:50:00 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:50:00 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:50:03 <roconnor> and that is all a CReal is.
20:50:24 <mornfall> cereal... : - ]
20:50:26 <dmwit> roconnor: Nevertheless, if you have run the calculation n steps, and summed to 0, you still don't know whether the sum is positive in the end or not.
20:50:28 * dolio thought he wrote a program to compute badReal above...
20:50:43 <roconnor> dmwit: that is why ceiling is uncomputable.
20:50:43 <dmwit> dolio: Your program *also* doesn't terminate.
20:50:55 <dmwit> roconnor: It's not the ceiling that's uncomputable!  It's the sum!
20:51:00 <dolio> It produces an infinite list of digits.
20:51:02 <roconnor> the sum is computable
20:51:03 <mmorrow> neither does [0..]
20:51:12 <BMeph> Runaro: @hoogle (Monad m, Arrow c) => m (c a b) ->c (m a) (m b)
20:51:13 * dmwit sighs
20:51:24 <dmwit> I think we disagree on what "computable" means.
20:51:27 <roconnor> all it means for a CReal to be computable is that it can be approximated arbitarily
20:51:30 <BMeph> @hoogle (Monad m, Arrow c) => m (c a b) ->c (m a) (m b)
20:51:30 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
20:51:30 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
20:51:44 <roconnor> dmwit:  it does't mean that it's decimal notation is computable
20:52:12 <Runaro> BMeph: unzip, ap, and <*>. What else? What is that _in general_ ?
20:52:15 <mornfall> Is CReal what I think it is? (An IEEE-formatted floating point number)?
20:52:24 <mmorrow> it's possible to compute infinite sums by symbolically taking their limit
20:52:24 <dmwit> For me, a function is computable if any *value* given as input has a terminating algorithm that produces an output.
20:52:26 <roconnor> mornfall: nope
20:52:28 <mmorrow> ie integrating them
20:52:30 <mornfall> OKey. : - )
20:52:31 <dmwit> But the sum you are proposing is not a value.
20:52:35 <dmwit> It is a computation.
20:52:42 <Olathe> mornfall: It's like a BigDecimal or something, but better.
20:52:53 <mornfall> Olathe: The name is confusing at best.
20:52:56 <dons> the name is confusing.
20:52:56 <roconnor> dmwit: functions are values. You know that :P
20:52:57 <mmorrow> the integral is a linear map of functions
20:53:06 <dmwit> mornfall: It's like a (Integer -> Integer).
20:53:15 <dmwit> mornfall: Where the Integer argument tells "how many digits" to comput.
20:53:21 <mornfall> Ah.
20:53:22 <mmorrow> a vector space where the "vectors" are functions to be more precise
20:53:24 <mornfall> Interesting.
20:53:41 <dmwit> roconnor: sum [anything goes here] -- is not a value
20:53:42 <roconnor> data CReal = CR_ (Int -> Integer)
20:54:12 <mornfall> roconnor: Wouldn't that Int there make it finite?
20:54:18 <roconnor> a valid CReal requires that function to be total.
20:54:20 <BMeph> Runaro: Great question. :)
20:54:25 <dmwit> mornfall: Yes, but you run out of memory first anyway.
20:54:29 <Runaro> BMeph: Thanks :)
20:54:35 <mornfall> dmwit: Good point. : - )
20:54:43 <BMeph> Runaro: I'm tuckered out from doing my generalized (><), though. ;)
20:55:15 <Runaro> That sounds fun
20:55:32 <dolio> "A computable number [is] one for which there is a Turing machine which, given n on its initial tape, terminates with the nth digit of that number [encoded on its tape]."
20:55:48 <leimy> Yeah f I do hGetChar, it's no problem, or hGetContents
20:55:56 <leimy> but hGetLine is giving me gas.
20:55:58 <roconnor> dolio: that is wrong.  I'll edit the wikipage
20:56:11 <leimy> it's as if it sees the \n and then expects the prior character to have been \r, so it drops it too.
20:56:18 <mornfall> roconnor: What's your definition?
20:56:22 <leimy> so I send "TEST" and get "TES"
20:56:24 <mmorrow> leimy: keep in mind that once you hGetContents, that Handle is as good as closed
20:56:30 <leimy> yes
20:56:37 <mmorrow> excellent
20:56:43 <Runaro> What's a generalised (><)? <+>?
20:56:47 <dolio> Well, it's quoting "Minsky", so I'm not sure how you're going to edit it. :)
20:56:47 <roconnor> mornfall: a CReal is a number that can be approximated to within any precision.
20:57:10 <mornfall> roconnor: CReal /= computable number, though.
20:57:32 <mornfall> roconnor: CReal can surely describe a non-computable number. It just won't compute then..?
20:57:54 <roconnor> a computable real is a number that can be approximated to within any precision.
20:58:04 <roconnor> by a computable function.
20:58:38 <Runaro> But can't you attain infinite precision by simply moving to base-CReal?
20:58:46 <Runaro> :)
20:58:58 <roconnor> Runaro: :)
20:59:12 <Runaro> CReal == 1
20:59:16 <Runaro> done and done!
20:59:20 <dolio> roconnor: There's a formal definition later that would likely be acceptable to you.
20:59:56 <roconnor> oh good.
21:00:24 <dolio> a is computable if given an arbitrary n, there's a computable function that produces a k such that (k-1)/n <= a <= (k+1)/n.
21:00:31 <BMeph> Runaro: It looks suspiciously like the reverse of your thing. :)
21:00:41 <dolio> k and n integers.
21:00:43 <roconnor> dolio: yes, that is correct.
21:01:23 <Runaro> BMeph: It does a bit. Yours is the sequential version and mine's the parallel one.
21:01:46 <mornfall> What's the definition of ceiling/floor again?
21:02:05 <mornfall> Because I don't quite see how they could be uncomputable, it seems.
21:02:12 <Runaro> What is this "computable"? Is pi computable?
21:02:22 <roconnor> ceiling is the smallest integer not smaller than x.
21:02:23 <mornfall> Runaro: Apparently so.
21:02:25 <dolio> Yes, pi is computable.
21:02:27 <roconnor> pi is computable
21:02:35 <Runaro> OK, good.
21:02:38 <roconnor> > pi :: CReal
21:02:39 <lambdabot>   3.1415926535897932384626433832795028841972
21:02:56 <Runaro> That's not pi, that's just a number very close to it.
21:03:03 <roconnor> true
21:03:06 <mornfall> Runaro: You can get arbitrary precision from it.
21:03:08 <mmorrow> this is pi
21:03:10 <mmorrow> . "pi"
21:03:13 <Runaro> right
21:03:13 <roconnor> > approxmate pi (1/100000)
21:03:15 <lambdabot>   mueval: Prelude.read: no parse
21:03:15 <lunabot>  "pi"
21:03:16 <bd_> > pi :: CInfinitePrecisionReal
21:03:17 <lambdabot>       Not in scope: type constructor or class `CInfinitePrecisionReal'
21:03:20 <bd_> darm :(
21:03:21 <bd_> darn*
21:03:24 <unmarshal> when profiling haskell programs, how can i add a cost center to an external function i call
21:03:27 <ddarius> > showCReal 200 pi
21:03:28 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
21:03:38 <unmarshal> for example inside Data.Binary.Get in runGet
21:03:48 <mornfall> Anyhow.
21:03:49 <ddarius> You can't.
21:04:27 <dolio> Search and replace with: ({-# SCC "runGet" #-} runGet) :)
21:04:28 <mmorrow> > last . fmap (flip showCReal pi) $ [0..=
21:04:29 <lambdabot>   mueval: Prelude.read: no parse
21:04:31 <mmorrow> > last . fmap (flip showCReal pi) $ [0..]
21:04:46 <lambdabot>   thread killed
21:04:47 <BMeph> Runaro: (><) :: forall b c d e (a :: * -> * -> *) (m :: (* -> * -> *). (Arrow a, Arrow m) => a (m b d) (m c e) ->  m (a b c) (a d e)
21:04:54 <roconnor> > fmap (flip showCReal pi) $ [0..]
21:04:57 <lambdabot>   ["3","3.1","3.14","3.142","3.1416","3.14159","3.141593","3.1415927","3.1415...
21:05:05 <mornfall> roconnor: So what's the exact problem with floor, anyway?
21:05:15 <mornfall> There's been some talk of sums...
21:05:35 <roconnor> mornfall: floor cannot be computed for all CReals
21:05:42 <mornfall> roconnor: And the problematic CReal is?
21:05:48 <BMeph> Runaro: Well, and mine uses two Arrows, or maybe two Bifunctors. I'll have to look at those some more to be sure. :)
21:05:55 <roconnor> there is no single CReal I can point to
21:06:04 <roconnor> But I can give suggestive examples
21:06:05 <mornfall> roconnor: But it looks like?
21:06:09 <dolio> What was wrong with that one above?
21:06:29 <roconnor> sum [(if (oddPerfectNumber i) then 0 else 1)/(2^i) | i <-[0..]]
21:06:30 <dolio> I suppose that was ceiling.
21:06:37 <roconnor> this was my original suggestive example
21:06:43 <roconnor> er right
21:06:49 <roconnor> that was my example for ceiling
21:06:58 <mornfall> roconnor: And are you sure that's CReal?
21:06:58 <roconnor> sum [(if (oddPerfectNumber i) then 0 else (-1))/(2^i) | i <-[0..]]
21:07:04 <roconnor> yes
21:07:15 <roconnor> because it can be approximated to arbitary precision
21:08:02 <mornfall> Ah, so that's the problem with definitions. If you require machine that can give n-th digit, you don't have that problem.
21:08:20 <mornfall> But if it can always give bounds that are "around" an integer, you are screwed.
21:09:03 <Olathe> How do I say (Bits a, Integral a) => without getting an ambiguous type error ?
21:09:05 <roconnor> mornfall: that and giving the nth digit isn't well defined.
21:09:16 <roconnor> because some numbers have more than one represenation
21:09:27 <roconnor> 0.9999... = 1.000000...
21:09:52 <mornfall> roconnor: No sensible way to pick representations?
21:09:54 <leimy> HAH
21:09:55 <leimy> OMG
21:10:00 <leimy> I just found "init" in my list code
21:10:03 <leimy> dropping that last char
21:10:05 <mmorrow> haha
21:10:06 * leimy needs to sleep more
21:10:07 <mornfall> leimy: LOL.
21:10:15 <leimy> oh well
21:10:33 <leimy> Haskell can't make you not be dumb...
21:10:38 <leimy> but at least the types lined up
21:11:14 <roconnor> :) Haskell doesn't know the difference between init and id :: String -> String
21:11:40 <mornfall> roconnor: And teaching it to know is impractical...
21:11:44 <mornfall> : - )
21:11:49 <dolio> Personally I'd vote for the halting number.
21:11:56 <roconnor> mornfall: I claim it is practical
21:11:58 <dolio> Although that's not any particular number.
21:12:06 <leimy> Anyway, that was funny, and I'm a total ass
21:12:12 <roconnor> mornfall: GADTs are a step in that direction
21:12:19 <roconnor> dependent types go all the way
21:12:47 <leimy> Using ReaderT for a socket handle abstraction around a connection is pretty neat per dons' irc bot thingy.
21:13:11 <leimy> certainly makes it easier to compose functions and forget the handle :-)
21:13:18 <dons> at least it teachers ReaderT :)
21:13:33 <mornfall> roconnor: I have heard of those. Not sure it practically solves that problem.
21:13:36 <leimy> dons: right, but apparently I borrowed "init" too :-)
21:13:45 <bluejay|T61> Cale// after some googling, i finally understood your code today ;)
21:14:00 <leimy> dons: I would have questioned the value of ReaderT without that... it's a good example.
21:14:08 <bluejay|T61> > take 10 $ nubBy (\x y -> y `mod` x ==0) [2..
21:14:10 <lambdabot>   mueval: Prelude.read: no parse
21:14:13 <roconnor> mornfall: you are not alone with that opinion
21:14:14 <bluejay|T61> D:
21:14:23 <bluejay|T61> > take 10 $ nubBy (\x y -> y `mod` x ==0) [2..]
21:14:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
21:14:27 <mornfall> roconnor: (Well, probably depends on how you define "that problem"...)
21:15:19 <mmorrow> . $(let g |.| f = [|$g . $f|] in foldr (|.|) [|id|] (replicate 4 [|show|])) 42
21:15:21 <lunabot>  "\"\\\"\\\\\\\"42\\\\\\\"\\\"\""
21:16:30 <dolio> I'm not sure how exactly you'd usefully distinguish id from init with dependent types.
21:16:43 <mmorrow> me neither, was justing trying to figure that out
21:16:45 <dolio> Unless your strings are vectors.
21:16:54 <dolio> Then you might notice that the size is changing.
21:17:19 <mornfall> dolio: You probably can notice with lists as well, if you can encode "emptiness" into the type already?
21:17:36 <mornfall> Anyhow, there's only so much semantic information you are willing to encode into type annotations.
21:17:45 <mornfall> Silly mistakes will always happen.
21:17:53 <dolio> Well, yeah. That's kind of an intermediate step.
21:17:54 <mmorrow> aren't types erased in the generated code though? or is that not always the case
21:18:15 <mornfall> mmorrow: They probably are -- types are ways to prove things about code statically.
21:18:19 <mornfall> At least in our case.
21:19:02 <mornfall> It might make it possible to eg. use the typechecker that certain lists are non-empty at certain points. IIUIC.
21:19:07 <mmorrow> hmm, then i don't see how id and init can be distinguished then
21:19:08 <mornfall> +to prove
21:19:32 <dolio> It's pretty easy, really.
21:19:35 <mornfall> mmorrow: Me neither, considering arbitrary situations.
21:19:37 <mmorrow> what if you don't know the length of a "String" at compile time
21:19:40 <mmorrow> yeah
21:20:03 <mmorrow> arbitrary situations is what i'm thinking of i guess
21:20:24 <Runaro> BMeph: Two binfunctors... that invites the question whether this can all be generalised further, to arbitrary kinds.
21:20:31 <dolio> But if you're only checking emptiness, it leads to a lot of empty-test/coersions, in my limited experience.
21:20:51 <BMeph> Runaro: Heh-heh. :)
21:21:04 <mornfall> dolio: That means? (Pardon my ignorance on the theory...)
21:21:11 <mmorrow> dolio: ah, so in that sense the type still exists in the generated code?
21:21:22 <mmorrow> (the check for emptyness)
21:21:34 <dolio> mornfall: Well, stuff like tail, init, and so on have types like: 'List NonEmpty a -> List Unknown a'.
21:21:52 <mornfall> dolio: That's even less than I would have expected...
21:22:01 <mornfall> dolio: Predicate abstraction.
21:22:08 <mornfall> Nothing groundbreaking.
21:22:18 <mmorrow> ohhhh, i see
21:22:23 <leimy> Reader lets you write code as if you've got some global variables... it's quite interesting
21:22:25 <dolio> So any time you get an Unknown back, you need to do a check: 'checkLength :: List Unknown a -> Maybe (List NonEmpty a)'
21:22:49 <mornfall> People do that to programs for ages to make them easier to verify.
21:23:41 <dolio> Whereas stuff like 'tail :: Vector (N + 1) a -> Vector N a' leaves you with information in the output.
21:23:58 <dolio> So hopefully you do tests in fewer places.
21:23:59 <mornfall> dolio: But you can't represent things like hGetLine.
21:24:00 <Runaro> @hoogle (Arrow d, Arrow c) => d (c a b) (c b a) -> c (d a b) (d b a)
21:24:01 <lambdabot> No results found
21:24:03 <Runaro> ah well
21:24:21 <b7j0c> hi, can anyone look at http://hpaste.org/10482#a0 and maybe help?
21:24:32 <mmorrow> mornfall: wouldn't it just be  hGetLine :: IO (List Unknown Char)
21:24:32 <b7j0c> i am having an instance declaration brainfreeze
21:24:33 <mornfall> dolio: Actually, you can only represent bounded vectors, which aren't very useful.
21:24:36 <dolio> hGetLine :: Sigma (N : Nat) (Vector N Char)
21:24:40 <mornfall> mmorrow: In the Vector case.
21:24:50 <mmorrow> hmm
21:24:59 <mornfall> dolio: Ah, hmm.
21:25:05 <mornfall> Another predicate trick? : - )
21:25:26 <dolio> There are no infinite vectors, of course, so lazy IO is out, maybe. :)
21:25:47 <dolio> Or, that's kind of a non sequitur.
21:25:52 <mmorrow> heh
21:26:03 <dolio> You need to know the length to build the Sigma type, really.
21:26:08 <mmorrow> couldn't you just use  N + infinity
21:26:57 <mmorrow> data N = Zero | One N | Infinity
21:26:58 <mornfall> dolio: Well, couldn't you just say Vector Unknown Char? Or such...
21:27:05 <mornfall> mmorrow: Icky.
21:27:11 <dolio> Unknown isn't a natural number. :)
21:27:15 <jinjing> @bot
21:27:15 <lambdabot> :)
21:27:24 <mornfall> dolio: Isn't Unknown an Everything? : - ]
21:27:32 <jinjing> @bot
21:27:32 <lambdabot> :)
21:28:19 <dolio> Anyhow, that sigma type kind of says that. "Sigma (N : Nat) (Vector N Char)" is a pair of some natural number N, and a vector of that length.
21:28:32 <mornfall> Unknown should be just able to unify with about anything. That of course adds back doors to the type system that might be unacceptable.
21:28:35 <dmwit> b7j0c: You need to unwrap the Floating instance.
21:28:58 <mmorrow> @type undefined
21:29:00 <lambdabot> forall a. a
21:29:04 <b7j0c> hi dmwit...can you explain a bit more? sorry for being dense
21:29:32 <dolio> Yeah. Many dependently typed languages go to some effort to keep undefineds/non-termination out.
21:29:33 <mornfall> mmorrow: Right. I don't know how the Empty, NonEmpty and Unknown bits play with type variables.
21:29:37 <dmwit> b7j0c: x :: Ptd -- this means that the Floating instance is wrapped in a Ptd constructor.  Note that the two "Ptd"s here are in different namespaces.
21:29:49 <dolio> Kind of ruins the theorem proving if you can prove false things. :)
21:30:14 <mornfall> dolio: Right, but building a theorem prover into type system *might* be overdoing it.
21:30:26 <dmwit> b7j0c: Consider starting with something like "distance (Pt (Ptd xa) (Ptd ya)) (Pt (Ptd xb) (Ptd yb)) = ...".
21:30:42 <dmwit> b7j0c: However, I'm not sure that the forall you've written there is doing quite what you think it is doing.
21:30:42 <b7j0c> yeah i see how it is wrapped due to the Ptd constructor...just don't know how to write the instance decl
21:30:46 <dolio> I don't know. They're pretty sexy.
21:30:52 <mmorrow> heh
21:30:57 <dmwit> b7j0c: You shouldn't need to write any instances, though you can.
21:31:07 <dmwit> b7j0c: I suggest the following, however.  (Let me annotate.)
21:31:18 <mornfall> dolio: Too many sexy things are undecidable, in this crappy world...
21:31:34 <b7j0c> thanks dmwit, i can bookmark the hpaste..
21:32:20 <dolio> Anyhow, you can do the Empty, NonEmpty, etc. stuff even in Haskell (GHC).
21:32:30 <mornfall> dolio: With GADTs?
21:32:34 <dolio> Yeah.
21:32:51 <b7j0c> thanks dmwit!!
21:32:52 <mornfall> I have had my GADT encounters in darcs not so long ago. I still don't fully understand that stuff.
21:32:59 <b7j0c> i will chew on that for a while
21:33:10 <b7j0c> i really appreciate the annotation and assistance
21:33:13 <mornfall> But I can roughly imagine how that'd work.
21:33:18 <dmwit> b7j0c: See the latest annotation, actually.
21:34:00 <b7j0c> so in your annotation, you would forgo the forall?
21:34:17 <dmwit> b7j0c: There are other approaches that let you express the constraint that you can only make a Point out of a Floating instance, but they're a bit more advanced, and you might not need it.
21:34:24 <dmwit> If you really do, we can talk about how to do that, too. =)
21:35:10 <b7j0c>  i think what you have provided should serve me very well, i appreciate the effort you have taken to help me
21:35:58 <mmorrow> mornfall: i got it when i realized they're just a way to carry a type along with a data so that type can be used in a type sig like  MyGADT (a->b) -> MyGADT a -> b  (and the contents of MyGADT can be arbitrary)
21:36:00 <mib_ugdbwjyp> .
21:36:01 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
21:36:23 <mmorrow> haha
21:36:24 <iamnotabee> .
21:36:24 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
21:36:39 <mmorrow> i gotta check eof ...
21:36:51 <iamnotabee> hi guys, i want to know what is the data type of a list
21:37:06 <dmwit> [a]
21:37:15 <mmorrow> . pp $(lift =<< reify ''[])
21:37:18 <lunabot>  data [] a_0 = [] | a_0 : ([] a_0)
21:37:24 <mornfall> dmwit: No, you got it all wrong. It's [b]... *hides*
21:37:36 <mmorrow> clearly it's a_0!
21:37:39 <dmwit> mornfall: ...up to beta reduction. =)
21:37:50 <Nafai> iamnotabee: Are you wanting to know about a particular list?
21:37:53 <Nafai> For example:
21:37:58 <Nafai> > :t [1, 2, 3]
21:37:59 <lambdabot>   mueval: Prelude.read: no parse
21:38:06 <Nafai> > @type [1, 2, 3]
21:38:08 <lambdabot>   mueval: Prelude.read: no parse
21:38:10 <mornfall> Without that >
21:38:13 <mmorrow> s/> //
21:38:15 <Nafai> Oh :)
21:38:52 <iamnotabee> i am trying to create a table , and the table hold 3 arguments, 1st argument is a string, 2nd argument is a list, 3rd is a list within a list
21:38:53 <mornfall> Anyhow, that's a pretty ugly type.
21:39:01 <Olathe> @type [1, 2, 3]
21:39:02 <Adamant> can you do UTF-8 with something like bytestrings?
21:39:02 <lambdabot> forall t. (Num t) => [t]
21:39:10 <dmwit> Adamant: Of course.
21:39:12 <mmorrow> Adamant: sure
21:39:16 <dmwit> Adamant: There are even libraries for it.
21:39:18 <dmwit> ?hackage encoding
21:39:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding
21:39:20 <dons> Adamant: they're just a stream of bytes
21:39:22 <iamnotabee> is this correct? data Table a = Table a [a] [a] [a]
21:39:28 <mmorrow> > utf8 '\26532'
21:39:30 <lambdabot>   "\230\158\164"
21:39:32 <mornfall> iamnotabee: Nack.
21:39:46 <mornfall> im_alone: Table a [a] [[a]]
21:39:53 <mornfall> im_alone: But it might be that a = String
21:39:53 <Adamant> sweet, thank you
21:39:59 <mornfall> im_alone: Eww.
21:40:00 <mmorrow> (utf8 is encodeUTF8)
21:40:09 <mornfall> im_alone: sorry, miscompletion
21:40:15 <mornfall> iamnotabee: that was for you.
21:40:33 <iamnotabee> mornfall: ok, i couldnt find this im_alone guy
21:41:43 <iamnotabee> is this correct data Table  a [a] [[a]] = Table a [a] [[a]] ? or only this? data Table  a  = Table a [a] [[a]]
21:42:00 <iamnotabee> the stuff that i want inside the list are all strings
21:42:09 <mornfall> Anyhow, I should have a shower and get ready for school. It's been nice chatting, see you around.
21:42:27 <mornfall> iamnotabee: data Table = Table String [String] [[String]] I guess.
21:42:29 <mornfall> -->
21:43:05 <mmorrow> or data Table a = One a | Two [a] | Three [[a]] depending on what you want
21:43:52 <iamnotabee> why data Table does not need a variable a? like data Table vs data Table a
21:44:55 <dolio> mornfall: http://hpaste.org/10484
21:47:39 <dancor> maybe  data Table {title :: String, colName :: [String], cell :: [[String]]}
21:48:25 <dancor> err  data Table = Table {title :: String, colName :: [String], cell :: [[String]]}
21:49:30 <dancor> iamnotabee: data declarations have variables (a's) iff you want to support any type
21:50:28 <dancor> so, depending on what your doing, your generalization could also be: data Table a = Table Table {title :: String, colName :: [String], cell :: [[a]]}
21:50:51 <dancor> err  data Table a = Table {title :: String, colName :: [String], cell :: [[a]]}
21:51:02 * dancor .oO(why am i such a typomess)
21:52:02 <BMeph> dancor: data Table a = MkTable {title :: a, colName :: [a], cell :: [[a]]} -- did you want this, maybe? ;)
21:54:13 <iamnotabee> oh, thanks guys
21:55:36 <iamnotabee> Table Table {title :: S ... hmm table table?
21:59:43 <iamnotabee> do i need to define the list more specifically if i want the list to have 3 items? [String] = ["apple","red","small"]
22:00:05 <iamnotabee> fruit :: [String, String, String] = ["apple","red","small"]
22:00:23 <mmorrow> dolio: cool
22:01:09 <dmwit> iamnotabee: Lists are arbitrary-length.
22:01:27 <iamnotabee> ok
22:01:56 <dmwit> You should definitely try to work through a tutorial, if you haven't yet. These things are sure to be explained. =)
22:02:51 <mmorrow> . ("apple","red","small")
22:02:52 <lunabot>  ("apple","red","small")
22:03:00 <mmorrow> @type ("apple","red","small")
22:03:04 <lambdabot> ([Char], [Char], [Char])
22:03:19 <mmorrow> == (String,String,String)
22:04:38 <mmorrow> . $(tupE (replicate 63 [|0|]))
22:04:39 <lunabot>      A 63-tuple is too large for GHC
22:04:47 <dmwit> what
22:04:48 <mmorrow>  (max size is 62)
22:04:48 <mmorrow>       Workaround: use nested tuples or define a data type
22:04:56 <DekuDekuplex> @djinn (Random a) => State StdGen a
22:04:57 <lambdabot> Error: Undefined type State
22:05:02 <mmorrow> . $(tupE (replicate 62 [|0|]))
22:05:03 <lunabot>      No instance for (Show
22:05:08 <mmorrow> what
22:05:49 <dmwit> mmorrow: Wow!
22:05:59 <dmwit> GHCi fails *silently*.
22:06:03 <mmorrow> hah, there really is no instance of show for 62-tuples
22:06:09 <DekuDekuplex> @djinn (Random a) => a -> a -> a
22:06:10 <lambdabot> Error: Class not found: Random
22:06:18 <dmwit> mmorrow: Oh, wait, never mind.
22:06:25 <dmwit> I was testing the wrong file. =)
22:06:48 <mmorrow> heh
22:06:50 <mmorrow> . $(tupE (replicate 15 [|0|]))
22:06:52 <lunabot>  (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
22:06:54 <mmorrow> . $(tupE (replicate 16 [|0|]))
22:06:56 <lunabot>      No instance for (Show
22:07:19 <dmwit> That's such a hack.
22:07:26 <mmorrow> totally
22:07:37 <dmwit> I wonder if there's a Haskell' proposal regarding n-tuples.
22:08:03 <mmorrow> i wish ghc handled larger than 62 for sure
22:08:26 <dmwit> Well, okay, that's a fair point.
22:08:27 <mmorrow> O(1) indexing and statically known size
22:08:50 <mmorrow> you'd use TH to deal with them unless you were insane, of course :)
22:08:52 <dmwit> The fact that I didn't know the limits until just now certainly does say something about how often I run into them.
22:08:55 <dmwit> But still. =)
22:09:14 <DekuDekuplex> @djinn (Int i) => i -> i -> i
22:09:14 <lambdabot> Error: Class not found: Int
22:09:24 <iamnotabee> i am having funny error Illegal type "Table -> String" in constructor application
22:09:46 <iamnotabee> i have defined my new data called Table
22:10:05 <mmorrow> dmwit: i didn't know until a week or three ago when chrisdone was using some parsing lib and he was hitting to limit with this massive mdo
22:10:37 <mmorrow> i don't know where the tuples were coming from, but he needed a 72 tuple
22:10:51 <dmwit> what.
22:11:04 <mmorrow> a lib of john meachams
22:11:20 <mmorrow> the tuples i guess were buried somewhere in the implementation
22:12:05 <DekuDekuplex> @djinn callCC ? ((a -> C b) -> C a) -> C a
22:12:05 <lambdabot> Cannot parse command
22:13:16 <DekuDekuplex> Hm ... djinn cannot parse "callCC ? ((a -> C b) -> C a) -> C a" here.
22:13:22 <mmorrow> dmwit: i can't find the lib he was using right now, but it was somewhere here: http://repetae.net
22:13:23 <lambdabot> Title: John Meacham's Homepage
22:13:48 <ski> @djinn x :: Bool
22:13:49 <lambdabot> Cannot parse command
22:13:50 <ski> @djinn Bool
22:13:50 <lambdabot> f = False
22:15:27 <DekuDekuplex> According to the Lambda the Ultimate entry for Djinn (http://lambda-the-ultimate.org/node/1178), the Djinn stand-alone can parse "callCC ? ((a -> C b) -> C a) -> C a", but not the Djinn plugin here, apparently.
22:15:28 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
22:15:52 <ski> @djinn ((a -> C b) -> C a) -> C a
22:15:53 <lambdabot> Error: Undefined type C
22:16:01 <dmwit> ?djinn-env
22:16:01 <lambdabot> data () = ()
22:16:01 <lambdabot> data Either a b = Left a | Right b
22:16:01 <lambdabot> data Maybe a = Nothing | Just a
22:16:01 <lambdabot> data Bool = False | True
22:16:01 <lambdabot> data Void
22:16:03 <lambdabot> type Not x = x -> Void
22:16:05 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:16:08 <ski> what would you like `C' to be defined as ?
22:16:21 <dmwit> ?unmtl Cont a b
22:16:21 <lambdabot> (b -> a) -> a
22:16:27 <ski>   type C a = Not (Not a)  -- ?
22:16:48 <DekuDekuplex> It doesn't really matter ... how about an Int?
22:16:51 <ski>   data C a = MkC (forall o. (a -> o) -> o)  -- ?
22:17:16 <dmwit> ?djinn-add type C a = Not (Not a)
22:17:18 <iamnotabee> how do I print out my table?
22:17:22 <dmwit> ?djinn-env
22:17:22 <lambdabot> data () = ()
22:17:22 <lambdabot> data Either a b = Left a | Right b
22:17:22 <lambdabot> data Maybe a = Nothing | Just a
22:17:22 <lambdabot> data Bool = False | True
22:17:22 <lambdabot> data Void
22:17:24 <lambdabot> type Not x = x -> Void
22:17:26 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:17:28 <lambdabot> type C a = Not (Not a)
22:17:32 <dmwit> Alright!
22:17:43 <dmwit> ?djinn ((a -> C b) -> C a) -> C a
22:17:43 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
22:17:53 <dmwit> DekuDekuplex: There you go! =)
22:17:59 <iamnotabee> showMeMyTable a = show(a) ?
22:18:00 <DekuDekuplex> Wow, thanks.
22:18:28 <DekuDekuplex> ?djinn callCC ? ((a -> C b) -> C a) -> C a
22:18:29 <lambdabot> Cannot parse command
22:19:03 <dmwit> DekuDekuplex: You have to send it only a type.
22:19:14 <dmwit> Or maybe a name and a type, but '?' surely isn't the right separator.
22:19:18 <dmwit> Let's try "::".
22:19:23 <iamnotabee> anyone know?
22:19:28 <dmwit> ?djinn callCC :: ((a -> C b) -> C a) -> C a
22:19:29 <lambdabot> Cannot parse command
22:20:00 <dmwit> DekuDekuplex: Anyway, it would give the same answer as above. =)
22:20:17 <iamnotabee> what does this mean? *** Does not match : [Char]
22:20:25 <DekuDekuplex> Strange ... according to the example code posted at http://lambda-the-ultimate.org/node/1178, the code should work as follows:
22:20:27 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
22:20:27 <DekuDekuplex> Djinn> callCC ? ((a -> C b) -> C a) -> C a
22:20:36 <DekuDekuplex> callCC :: ((a -> C b) -> C a) -> C a
22:20:40 <DekuDekuplex> callCC x1 x2 = x1 (\ c15 _ -> x2 c15) (\ c11 -> x2 c11)
22:21:00 <dmwit> DekuDekuplex: The prompts are a little different between the CLI and \bot.
22:21:14 <DekuDekuplex> Ah, that explains it.
22:21:16 <mmorrow> ?djinn ((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
22:21:16 <lambdabot> f a b = a (\ c _ -> b c) b
22:21:59 <ski> iamnotabee : you are somewhere passing a string where no string was expected (or vice versa)
22:23:07 <mmorrow> @src Cont callCC
22:23:08 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
22:24:24 <nkpart> Hey, does anyone have some code using System.Win32.Registry that I could read?
22:24:40 <iamnotabee> ski: how do i convert a table into a string?
22:24:56 <ski> what is a table ?
22:24:57 <iamnotabee> my table have multiple lists within.
22:25:14 <iamnotabee> data Table a = Table {tableName :: String, fieldName :: [String], records :: [[String]] }
22:25:24 <iamnotabee> i wanted to putStrLn myTable, but it won't work
22:25:27 <ski> you could either try adding `deriving Show' to the data type definition
22:25:40 <ski> .. or you could define your own custom string conversion
22:25:40 <lunabot>   Not in scope: `you'
22:25:40 <lunabot>  <interactive>:1:58: Not in scope: `could'
22:25:54 <mmorrow> > (unlines . fmap intercalate ",") [["asdf","qwert"],["12345","zxcvb"]]
22:25:56 <lambdabot>   Couldn't match expected type `[String]'
22:25:59 <ski> lunabot : ty fyi
22:26:51 <mmorrow> > (unlines . fmap (intercalate ",")) [["asdf","qwert"],["12345","zxcvb"]]
22:26:52 <lambdabot>   "asdf,qwert\n12345,zxcvb\n"
22:26:56 <mmorrow> ski: lol
22:27:36 <DekuDekuplex> ?djinn callCC ((a -> C b) -> C a) -> C a
22:27:36 <lambdabot> -- f cannot be realized.
22:28:13 <DekuDekuplex> Hm ... callCC expects a function f, apparently.
22:29:57 <DekuDekuplex> Not quite sure why, in "callCC ((a -> C b) -> C a) -> C a", the parameters do not allow realizing an f.
22:30:30 <ski> methinks djinn parses `callCC' there as a type-variable
22:31:58 <DekuDekuplex> ?djinn returnC ? a -> C a
22:31:58 <lambdabot> Cannot parse command
22:32:16 <DekuDekuplex> ?djinn a -> C a
22:32:16 <lambdabot> f a b = b a
22:32:37 <DekuDekuplex> Ah, same kind of problem here as well.
22:33:12 <DekuDekuplex> The \bot version of Djinn can't handle functions, apparently.
22:33:28 <ski> can't handle functions, how ?
22:33:29 <DekuDekuplex> The CLI version can.
22:33:55 <DekuDekuplex> Well, in the other version, "returnC ? a -> C a" returns the following:
22:34:00 <DekuDekuplex> returnC :: a -> C a
22:34:05 <DekuDekuplex> returnC x1 x2 = x2 x1
22:34:13 <DekuDekuplex> But here, it returns the following:
22:34:19 <DekuDekuplex> Cannot parse command
22:34:25 <DekuDekuplex> So there is a discrepancy.
22:34:28 <mmorrow> @src Cont
22:34:28 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
22:34:35 <ski> the definition is the same as the one lambdabot gave just above
22:34:53 <ski> as mentioned, the interface in lambdabot is not as polished
22:36:03 <DekuDekuplex> Okay.  Then I guess the question is, is there a way have the lambdabot interface correctly parse "returnC ? a -> C a" (perhaps using some alternative notation).
22:36:38 <mmorrow> ?djinn a -> ((a->r)->r)
22:36:38 <lambdabot> f a b = b a
22:36:42 <bluejay|T61> DekuDekuplex// just wondering....is there any allusion/meaning in your screenname?
22:36:58 <dons> i found this confusing, http://www.wetherobots.com/2008/09/17/guest-strip-by-ryan-estrada/
22:37:00 <lambdabot> Title: WE THE ROBOTS » Archive » Guest Strip by Ryan Estrada, http://tinyurl.com/4n433c
22:37:01 <bluejay|T61> DekuDeku reminds me of Deku Tree in Legend of Zelda: Ocarina of Time
22:37:05 <bluejay|T61> haha
22:37:26 <dons> i think there's an illustration of purity in there, but i can't quite be sure.
22:37:27 <DekuDekuplex> Actually, you're quite correct.
22:37:43 <DekuDekuplex> And the "plex" comes from "googolplex."
22:37:48 <bluejay|T61> oh
22:37:54 <bluejay|T61> lol i see
22:38:06 <DekuDekuplex> So, "DekuDekuplex" is 10 to the power of a Deku Tree-squared.
22:38:16 <bluejay|T61> yeah
22:38:22 <bluejay|T61> 10^(Deku^2)
22:38:27 <DekuDekuplex> Right.
22:38:44 <DekuDekuplex> That was fast.  I've never seen anybody else guess the etymology that fast.
22:40:21 <mmorrow> i lolled at the robot in the background on fire in the last cell
22:40:36 <ski> @djinn (Deku -> Bool) -> Either (Bool,Bool,Bool) Bool
22:40:36 <lambdabot> Error: Undefined type Deku
22:40:52 <DekuDekuplex> Haha.
22:40:56 <ski> hm, actually
22:41:04 <ski> @djinn (Bool -> Deku) -> Either (Bool,Bool,Bool) Bool
22:41:04 <lambdabot> Error: Undefined type Deku
22:41:10 <ski> would be more correct
22:43:43 <DekuDekuplex> @djinn (DekuTree Deku) => (Bool -> Deku) -> Either (Bool,Bool,Bool) Bool
22:43:43 <lambdabot> Error: Undefined type Deku
22:44:02 <DekuDekuplex> (Dekutree Deku) => (Bool -> Deku) -> Either (Bool,Bool,Bool) Bool
22:44:15 <DekuDekuplex> @djinn (DekuTree Deku) => (Bool -> Deku) -> Either (Bool,Bool,Bool) Bool
22:44:15 <lambdabot> Error: Undefined type Deku
22:44:30 <bluejay|T61> DekuDekuplex// lol i actually guessed it right after i saw it, but thought no one else would think like me >.<
22:44:46 <DekuDekuplex> Oops.  I meant to uncapitalize the 'T' in "DekuTree":
22:45:00 <DekuDekuplex> @djinn (Dekutree Deku) => (Bool -> Deku) -> Either (Bool,Bool,Bool) Bool
22:45:00 <lambdabot> Error: Undefined type Deku
22:46:54 <DekuDekuplex> Ah, I see what the '?' was used for earlier:  binding a function.
22:47:18 <DekuDekuplex> E.g., "f ? a->a" is supposed to bind f to the identity function.
22:47:34 <DekuDekuplex> So we just need to figure out how to tell the \bot to bind a function.
22:47:42 <ski> @list djinn
22:47:42 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
22:47:46 <ski> @help djinn
22:47:46 <lambdabot> djinn <type>.
22:47:46 <lambdabot> Generates Haskell code from a type.
22:47:46 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
22:47:48 <ski> @help djinn-add
22:47:48 <lambdabot> djinn-add <expr>.
22:47:48 <lambdabot> Define a new function type or type synonym
22:47:54 <ski> et.c.
22:48:14 <DekuDekuplex> djinn-add f a->a
22:48:24 <mmorrow> http://repetae.net/computer/tao.html
22:48:25 <lambdabot> Title: The Tao of Programming
22:48:43 <dmwit> DekuDekuplex: I don't understand why you're so against letting djinn name its result f.
22:48:48 <dmwit> ?djinn a -> a
22:48:49 <lambdabot> f a = a
22:48:54 <DekuDekuplex> ?djinn-add f a->a
22:48:54 <lambdabot> Cannot parse command
22:49:01 <sm> evening all
22:49:01 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
22:49:20 <dmwit> DekuDekuplex: You keep going on about naming, but it's really not that hard to just change the "f" at the beginning of the line to the name you want when you copy the function definition.
22:50:12 <sm> how do I actually deploy hsp and start serving pages ?
22:52:37 <dons> whoa. parallel C++ spec-norm http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=gpp&id=3
22:52:39 <lambdabot> Title: spectral-norm C++ GNU g++ #3 program | x64 Ubuntu : Intel® Q6600® quad-core Co ..., http://tinyurl.com/4lhedc
22:52:42 <dons> ok. we gotta get in on that action
22:52:46 <dons> just implement the same algo.
22:53:08 <dons> exciting.
22:53:18 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=all
22:53:20 <lambdabot> Title: spectral-norm benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/5zcma3
22:54:00 <dmwit> We're the next fastest, but C++ blows people away with all that parallelism.
22:54:03 <dmwit> man
22:54:13 <dons> yeah.
22:54:19 <dons> but they worked out the parallelisation.
22:54:22 <dons> which is the trick.
22:54:26 <dons> so now we just gotta do the same hting
22:54:47 <dons>    #pragma omp barrier
22:54:50 <dons> looks ominous
22:54:55 <dons>    #pragma omp parallel default(shared) num_threads(NUM_THREADS)
22:54:56 <dons> wild.
22:55:20 <dons> it's like there's a parallel strategies language embedded in the pragmas :)
22:55:24 <dons>       #pragma omp for      \
22:55:24 <dons>          schedule(guided)   \
22:55:24 <dons>          reduction( + : sumB, sumv
22:55:35 <Baughn> You forget. GHC users aren't allowed to use parallelism in the shootouts.
22:55:42 <dons> Baughn: false.
22:55:56 <dons> we're actively encouraged, and have friendly support from the shootout authors
22:56:08 <Baughn> Hm. That's not what I heard yesterday.
22:56:11 <dons> ass you see http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
22:56:13 <lambdabot> Title: thread-ring benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language ..., http://tinyurl.com/5ph2wt
22:56:14 <Baughn> But no GC tuning, still?
22:56:25 <dons> no. that's a particular special case. i think it was misreported.
22:56:37 <dons> the binary-trees benchmark is a GC test. the ruling is that GC hints aren't allowed in that benchmark.
22:56:38 <Baughn> Whee. That's ghc in single-threaded mode, isn't it?
22:56:40 <dons> for any language
22:56:47 <dons> Baughn: nope.
22:56:51 <dons> look at the cpu utilisiation
22:56:59 <DekuDekuplex> dmwit: Actually, it's not that I'm against letting djinn name its result f.  I just am confused about how to get the djinn \bot bind a function.
22:57:00 <dons> its just not migrating them much
22:57:06 <Baughn> Or the build log. Hmm
22:57:18 <dmwit> DekuDekuplex: Just give it a type and it'll give you an implementation.
22:57:26 <dmwit> DekuDekuplex: We've shown you scores of examples.
22:57:37 <ski> @djinn-add type C2 p o a = (a -> o) -> p
22:57:37 <dmwit> DekuDekuplex: Here's another, just in case you missed the other ones.
22:57:43 <dmwit> ?djinn a -> b -> a
22:57:44 <lambdabot> f a _ = a
22:57:47 <ski> @djinn a -> C2 o o a
22:57:47 <lambdabot> f a b = b a
22:57:55 <ski> @djinn C2 q p a -> (a -> C2 p o b) -> C2 q o b
22:57:55 <lambdabot> f a b c = a (\ d -> b d c)
22:58:00 <ski> @djinn C2 o o o -> o
22:58:00 <lambdabot> f a = a (\ b -> b)
22:58:05 <ski> @djinn C2 p o o -> C2 q q p
22:58:06 <lambdabot> f a b = b (a (\ c -> c))
22:58:11 <ski> @djinn ((b -> o) -> C2 p q q) -> C2 p o b
22:58:12 <lambdabot> f a b = a b (\ c -> c)
22:58:13 <ski> @djinn ((b -> C2 r r o) -> C2 p q q) -> C2 p o b
22:58:13 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
22:58:27 <ski> (.. can you spot which does what ?)
22:58:29 <mmorrow> @pl \a b -> a (\ c d -> d (b c)) (\ e -> e)
22:58:30 <lambdabot> flip flip id . (. (flip id .))
22:58:30 <dons> spec-norm isn't too hard.
22:58:35 <dons> i think we can do this
22:58:36 <DekuDekuplex> dmwit: I get it!  So the djinn \bot names its own functions!
22:58:59 <dmwit> DekuDekuplex: Yes.  Specifically, it names them 'f'.  ...as I've been saying. =P
23:00:40 <DekuDekuplex> @djinn a -> a
23:00:40 <lambdabot> f a = a
23:00:53 <dmwit> DekuDekuplex: Argh, sorry for being sour.  I'll go to bed now, and tomorrow I'll be cheerful again.
23:01:42 <DekuDekuplex> dmwit: No problem.  I'm still new with djinn, and am trying to figure out how to reproduce the examples at http://lambda-the-ultimate.org/node/1178 .
23:01:43 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
23:02:47 <DekuDekuplex> @djinn-type C a = (a -> r) -> r
23:02:47 <lambdabot> Unknown command, try @list
23:03:01 <kbateman> Could somebody help me out with http://hpaste.org/10486 ?  It should be quick.
23:03:19 <DekuDekuplex> @djinn-add C a = (a -> r) -> r
23:03:19 <lambdabot> Cannot parse command
23:03:59 <ski> that is not a valid definition
23:04:02 <ski> `r' is free
23:04:07 <ski> maybe you meant
23:04:17 <ski>   type C r a = (a -> r) -> r
23:04:17 <ski> ?
23:04:23 <ski> or
23:04:40 <ski>   type C a = forall r. (a -> r) -> r  -- i think djinn doesn't handle this, btw
23:04:58 <DekuDekuplex> Yes, that's right.
23:05:13 <DekuDekuplex> The first one.
23:05:22 <DekuDekuplex> type C a = (a -> r) -> r
23:05:35 <dmwit> That is not valid Haskell.
23:05:41 <dmwit> djinn does Haskell.
23:05:47 <dmwit> ergo, djinn will not do that.
23:06:01 <dmwit> However!
23:06:18 <dmwit> ?djinn-add CDesu a r = (a -> r) -> r
23:06:19 <lambdabot> Cannot parse command
23:06:23 <dmwit> oy
23:06:26 <dmwit> ?djinn-add type CDesu a r = (a -> r) -> r
23:06:40 <dmwit> ?djinn r -> CDesu a r
23:06:40 <lambdabot> f a _ = a
23:06:43 <ski> @djinn forall a. a -> a
23:06:43 <lambdabot> f a = a
23:06:45 <DekuDekuplex> Ah.
23:06:54 <ski> `forall' is not H98, right ?
23:07:01 <dmwit> ski: right
23:07:23 <DekuDekuplex> ?djinn-add type C a r = (a -> r) -> r
23:07:24 <ski> so, (FSVO does), djinn does more than haskell (98)
23:07:35 <dmwit> ?djinn exists a. a -> a
23:07:35 <lambdabot> -- f cannot be realized.
23:07:44 <dmwit> Holy cow, djinn does existentials?
23:07:53 <ski> not that i know of
23:09:04 <dmwit> ?djinn exists a. ()
23:09:05 <lambdabot> -- f cannot be realized.
23:09:08 <mmorrow> ? djinn (forall a. a) -> a
23:09:09 <dmwit> Oh, I guess not.
23:09:11 <mmorrow> ?djinn (forall a. a) -> a
23:09:11 <lambdabot> -- f cannot be realized.
23:09:35 <kbateman> http://hpaste.org/10486
23:09:42 <ski> it didn't do higher-rank universals, last i checked
23:09:45 <kbateman> I am really banging my head against newArray.
23:09:48 <dmwit> ?djinn (forall a. a) -> (forall a. a)
23:09:48 <lambdabot> f a = a
23:09:48 <DekuDekuplex> ?djinn-add type CDesu a r = (a -> r) -> r
23:09:53 <dmwit> ski: Take it back!
23:09:54 <DekuDekuplex> ?djinn-add type C a r = (a -> r) -> r
23:10:04 <ski> dmwit : shan't :)
23:10:08 <dmwit> DekuDekuplex: They're already there!
23:10:18 <DekuDekuplex> Okay, then:
23:10:25 <DekuDekuplex> ?djinn-add type CDeku a r = (a -> r) -> r
23:10:46 <dmwit> DekuDekuplex: It doesn't respond to ?djinn-add, even when it succeeds.
23:10:51 <ski> dmwit : yes, it can parse them, and represent them in the AST .. but it doesn't handle them correctly .. in your example above, it just unified two types .. nothing special
23:10:57 <DekuDekuplex> I see.
23:11:11 <dmwit> ski: *nods*
23:13:02 <DekuDekuplex> @djinn returnCDeku ? a -> CDeku a
23:13:02 <lambdabot> Cannot parse command
23:13:14 <DekuDekuplex> Oops.
23:13:18 <DekuDekuplex> Wrong usage.
23:14:26 <DekuDekuplex> @djinn returnCDeku ? a r -> CDeku a r
23:14:26 <lambdabot> Cannot parse command
23:15:54 <dmwit> Just drop everything up to and including the '?'.
23:16:05 <dmwit> ?djinn a -> r -> CDeku a r
23:16:05 <lambdabot> f a _ b = b a
23:16:11 <dmwit> ?djinn a -> r -> CDesu a r
23:16:12 <lambdabot> f a _ b = b a
23:16:15 <dmwit> ?djinn a -> r -> C a r
23:16:15 <lambdabot> Error: kind error: (KArrow (KVar 1) (KVar 3),KVar 2)
23:16:21 <dmwit> whoa
23:16:25 <ski> (maybe s/correctly/specially/ .. since possibly it handles the bound variables in them correctly on e.g. unification .. but no specific rules for `forall' in contravariant position)
23:16:33 <dmwit> Oh, there's now two definitions of C, heh.
23:17:54 <ski> i only see one
23:18:54 <DekuDekuplex> Maybe I'm just missing something, but if I drop everything up to and including the '?', then how do I differentiate between, say "returnCDeku ? a -> CDeku a" and "bindCDeku ? CDeku a -> (a -> CDeku b) -> CDeku b"?
23:19:09 <DekuDekuplex> Ok, to correct:
23:19:53 <dmwit> ...by their types?
23:19:54 <lunabot>   parse error on input `..'
23:19:58 <dmwit> bah
23:20:05 <DekuDekuplex> "returnCDeku ? a r -> CDeku a r" and "bindCDeku ? CDeku a r -> (a r -> CDeku b r) -> CDeku b r"?
23:20:14 <dmwit> I hereby formally retract my suggesting of '.' as a good introductory character for lunabot.
23:20:35 <ski> possibly ". " would be better
23:20:38 <dmwit> ?tell mmorrow I no longer think '.' is a good character for lunabot to watch for. =P
23:20:38 <lambdabot> Consider it noted.
23:20:57 <dmwit> DekuDekuplex: Yes.  They have different types.
23:21:58 <ski> DekuDekuplex : s/? a r ->/? a ->/ , s/(a r ->/(a ->/
23:22:15 <ski> (any guess of what the operators for `C2' are for ?)
23:24:44 <mmorrow> dmwit: heh. i'm thinking change it to a comma
23:24:44 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
23:24:52 <mmorrow> @messages
23:24:52 <lambdabot> dmwit said 4m 14s ago: I no longer think '.' is a good character for lunabot to watch for. =P
23:25:31 <dmwit> mmorrow: You should grep the recent logs and make a histogram of first characters. =)
23:26:24 <mmorrow> that's a good idea
23:26:43 <mmorrow> although i don't think i've ever seen anyone use a comma first
23:27:04 <dmwit> Just yesterday I would have said the same thing about an initial period...
23:27:09 <mmorrow> heh
23:27:12 <mmorrow> ,,,
23:27:13 <ski> fsbot on e.g. #emacs uses a comma, iirc
23:27:21 <mmorrow> nice
23:27:25 <DekuDekuplex> ?djinn a -> CDeku a
23:27:26 <lambdabot> Error: kind error: (KVar 1,KStar)
23:27:27 <mmorrow> changing to comma not
23:27:36 <mmorrow> s/not/now/
23:27:45 <jeffz> people could type … instead of ...
23:28:07 <jeffz> if they really mean to write an ellipsis :p
23:29:24 <ski> ,hello
23:29:25 <lunabot>   Not in scope: `hello'
23:29:55 <dmwit> mmorrow: http://hpaste.org/10488
23:30:31 <mmorrow> , arityT `fmap` [t|forall a b r.(a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)|]
23:30:31 <lunabot>   parse error on input `)'
23:30:41 <dmwit> It's not totally accurate, actually, now that I look at it.
23:30:52 <mmorrow> , arityT `fmap` [t|forall a b r.((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)|]
23:30:53 <lunabot>      No instance for (Show (Q Int))
23:30:57 <dmwit> But it bears out your decision to use ','. =)
23:31:04 <mmorrow> damnit
23:31:08 * mmorrow looks
23:31:48 <dmwit> Oh, yeah, ':' would have been a really bad idea.
23:32:11 <dons> i hope someone who knows haxml can look at Lev Walkin's email.
23:32:15 <dons> JaffaCake: ^
23:33:24 <DekuDekuplex> Gotta get back to work.  I'll try downloading djinn from http://darcs.augustsson.net/Darcs/Djinn and experimenting with how it differs from the \bot version.
23:33:26 <lambdabot> Title: Index of /Darcs/Djinn
23:34:03 <DekuDekuplex> Thanks, later.
23:34:14 <sjanssen> DekuDekuplex: I believe lambdabot uses the version from hackage.haskell.org now
23:34:26 <newsham> ?djinn (Either p q -> a) -> (p -> a, q -> a)
23:34:26 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
23:34:51 <DekuDekuplex> I heard that darcs was going to get replaced, but I thought it got reinstituted?
23:35:00 * dmwit blinks
23:38:01 <mmorrow> dmwit: http://hpaste.org/10488#a1
23:39:36 <mmorrow> i'm suspicious of that though, because of all the occurences of '<' as the first char
23:40:06 <mmorrow> , (int . arityT) `fmap` [t|forall a b r.((a -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)|]
23:40:07 <lunabot>  2
23:40:44 <ski> (.. what is not accurate ?)
23:41:21 <mmorrow> do you mean arityT of '<' as the first char?
23:41:25 <mmorrow> s/of/or/
23:41:38 <DekuDekuplex> sjanssen: Are you sure about djinn from hackage, because I just checked http://hackage.haskell.org/packages/archive/, and couldn't find a package there.
23:41:40 <lambdabot> Title: Index of /packages/archive
23:42:02 <DekuDekuplex> I.e., there was one, but the directory there was empty.
23:42:14 <DekuDekuplex> It was at http://hackage.haskell.org/packages/archive/Djinn/2005.12.14/.
23:42:14 <lambdabot> Title: Index of /packages/archive/Djinn/2005.12.14
23:42:35 <DekuDekuplex> sjanssen: But there were no packages there.
23:43:10 <DekuDekuplex> sjanssen: Only a directory with a log file.
23:43:10 <sjanssen> DekuDekuplex: it is known as "djinn" now
23:43:48 <sjanssen> @hackage djinn
23:43:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn
23:43:51 <DekuDekuplex> sjanssen: Okay, I see it now:
23:43:56 <DekuDekuplex> http://hackage.haskell.org/packages/archive/djinn/2008.8.10/
23:43:56 <lambdabot> Title: Index of /packages/archive/djinn/2008.8.10
23:44:30 <DekuDekuplex> Oh, not http://hackage.haskell.org/packages/archive/djinn/2008.8.10/?
23:44:31 <lambdabot> Title: Index of /packages/archive/djinn/2008.8.10
23:44:42 <DekuDekuplex> @hackage djinn
23:44:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn
23:45:43 <DekuDekuplex> @sjanssen Okay, so just use the version at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn .
23:45:43 <lambdabot> Unknown command, try @list
23:45:55 <DekuDekuplex> sjanssen: Okay, so just use the version at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn .
23:45:56 <lambdabot> Title: HackageDB: djinn-2008.8.10
23:46:04 <sjanssen> DekuDekuplex: right
23:46:21 <DekuDekuplex> sjanssen: Okay, thanks.  Will use that version instead.
23:48:04 <mmorrow> , return . fromJust =<< fromDataConI $(lift =<< reify 'Node)
23:48:06 <lunabot>  LamE [ConP Node [VarP a_0,VarP a_1]] (TupE [VarE a_0,VarE a_1])
23:48:16 <mmorrow> , return . pp . fromJust =<< fromDataConI $(lift =<< reify 'Node)
23:48:17 <lunabot>  \(Node a_0 a_1) -> (a_0, a_1)
23:48:58 <mmorrow> , $(return . fromJust =<< fromDataConI =<< reify 'Node) (Node 0 [Node 1 []])
23:49:00 <lunabot>  (0,[Node {rootLabel = 1, subForest = []}])
23:51:31 <mmorrow> , (text . show . $(return . fromJust =<< fromDataConI =<< reify 'LamE)) `fmap` (return . fromJust =<< fromDataConI $(lift =<< reify 'Node))
23:51:32 <lunabot>  ([ConP Data.Tree.Node [VarP a_0,VarP a_1]],TupE [VarE a_0,VarE a_1])
