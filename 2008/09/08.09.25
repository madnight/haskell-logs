13:51:02 --- topic: '["#haskell @ ICFP: #haskell-icfp", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]'
13:51:02 --- topic: set by dons on [Sat Sep 20 17:01:07 2008]
13:51:02 --- names: list (clog agcorona jonafan cinema_ Elly bos zloog yav pyNem dv_ Azmodan younder sunny345 OceanSpray vininim__ pao_ dcoutts [R]ayne swiert kaoskorobase sramsay vininim_ kyevan Leaves Ctta0s thoughtpolice aculich carllerche hugo__ tseg subconscious thetallgu1 cjs clanehin cjb jberg dmhouse ADEpt cinema takuan kimmell seliopou yitz FunctorSalad novas0x2a ahf geezusfreeek_ lasts czShadoW Wild_Cat Nocta^ masak gbeshers gogonkt`1 Itkovian andyt moonfart)
13:51:02 --- names: list (brandon dmwit__ zoq int-e Corun dort Valodim unmarshal tltstc Dybber lekro xerox bockmabe fxr thingwath dolio imphasing name jamii bringert CosmicRay Cs0 rdd astrolabe arjanb mrsolo olsner kombinator Jedai micahcowan mkrauskopf BONUS_ shteou Nshag whee mopped BCoppens eyeris Taggnostr luite_ bts- gbacon binrapt brweber2 pao Taejo jgrimes SyntaxNinja rodge twanvl ystael pjdelport sioraiocht hkBst _MaK_ mc__ byorgey cheng JuanDaugherty dblazakis)
13:51:02 --- names: list (falseep iblechbot pastorn_ abbe sad0ur RayNbow lurkymclurkleton mperillo hrehf cantor smg PsiOmega lorandi erg0t_ gnufied XGas ozy` araujo harinath gvdm Beelsebob alios_ ivanm Eridius Shurique astrobunny birkenfeld sm BeelsebobWork rue encryptio xinming_ Axman6_ therp linuxmain sereven Tomas Saizan necrobious EvilTerran shepheb tromp m_stone Alleria MyCatVerbs plutonas Blub\0 sbok yango solrize ax1z MrDomino minimaximus OnionKnight Associat0r)
13:51:02 --- names: list (rothjl bogner Saul_ heavensrevenge pastorn Averell Philonous Cobra| SamB_XP xd mm_freak dejones emma Cale eno felipe Adamant flyback leimy nwf thorkilnaur zever dibblego kpk u_quark mercury^_ parodyoflanguage jeffz jre2 sei_ r3m0t synthasee glguy DrSyzygy borism raxas jan_ funktio sebbe1991 Baughn chr1s eelco mattiast Vq^ qwr Zao ulfdoz dfranke zamez _muke scook0 b4taylor ziman bran chrisdone dcoutts_ mornfall dons pcc1 mwhitney gds trez)
13:51:02 --- names: list (tuukkah Nafai flux dionoea fophillips Liskni_si audreyt tero- vincenz Spark ertai Laney pragma_ xian laz0r elias` creaux ibid marmolak Deewiant Bleadof miasma Anthraxx profmakx nothingmuch idnar iggly Philippa Mitar LeoD orbitz kg4qxk anders^^ wagle dbelange jfredett_ vegai agentzh hjon im_alone mr_ank baaba Draconx nemik pa-ching kryptiskt Shimei lkjasa Vulpyne Olathe erg qebab jimki jk dino- lament tarbo scorch Ferdirand tchakkafaraway)
13:51:02 --- names: list (`CompanionCube quetzal- tmielika koninkje_away cods kennyv bitrot wolgo_ dancor Khisanth loupgaroublond kokekola kaol saccade freshhawk Jaak liesen r0bby moshisushi reqamst delYsid Boney osfameron daf elliottt bohanlon mrd- glith spoop levitation[A] lilac Pistahh bbs pdewacht Apocalisp And[y] ski shukhov pythonist obk stevan newsham wjt Choko SamB hhurtta dublpaws score allbery_b matveev_ noj Caelum tverwaes saiam stylus fnordus mux davidL)
13:51:02 --- names: list (issal acura regulate nasloc__ GNU\caust1c nnunley puusorsa twifkak thedward DuClare Arnar xsdg thetallguy TSC obraun zenhase Botje IsoPallo mascht jekor` Riastradh rog_ welterde SUNWjoejaxx slarba Sartak Heffalump integral Guest20327 mattam pengrate dufflebunk shrimpx djinni Somni quicksilver shawn Axioplase jamesjb klugez malouin SimonRC DRMacIver edwinb netcat arguile lucca tessier lambdabot Arcanthus _ar atsampson shapr dobblego geocalc)
13:51:02 --- names: list (DarthMeh uebayasi cognominal desp SubStack Samedhi PeakerWork gaagaaga3 arjanoosting boyscared pfo alesb roconnor Tigge dmead Kinks heller kosmikus hesselink MarcWeber mauke_ znutar mightybyte mike_mcclurg Lamperi opqdonut Mr_Awesome intoverflow Igloo bd_ sjanssen ksandstr Japsu matthew-_ authentic nha_ equanimity faXx jleedev joed aempirei hackage PHO_ kalven og nornagon_ inimino jql caitt3am ToRA sophacles_work cjay aeolist noZone randyt)
13:51:02 --- names: list (maskd rwbarton stevengrady sbahra TomMD mrd icks kpreid mapreduce jeremiah cpfr smtms mlh Eelis Plareplane @ChanServ Nanar ac shachaf_ sophacles ilyak ArneB yahooooo Tobsan eyck liyang kolmodin c9s Poeir Twigathy_ Megant lefant flori wadcom lispy Skyp ski_ taruti agemo earthy wolverian)
13:51:14 <matthew-_> ok, is this where "sparks" are used?
13:51:36 <sjanssen> matthew-_: there are N OS threads, and M Haskell threads.  The RTS choses which M Haskell threads execute on the N OS threads
13:51:49 <matthew-_> ok
13:51:52 <sjanssen> matthew-_: sparks are yet another thing
13:52:19 <matthew-_> so, IIRC, you can control the quantumm for the M Haskell threads
13:52:28 <sjanssen> right, with +RTS -N
13:52:36 <sjanssen> erm, no
13:52:40 <matthew-_> no, that's the number of threads
13:52:45 <matthew-_> it's -C or -V isn't it?
13:53:06 <sjanssen> matthew-_: oh, you're referring to the context switch time
13:53:07 <zachk> > (mod 720 360)*(2*pi/360)
13:53:08 <lambdabot>   Add a type signature
13:53:12 <matthew-_> sjanssen: yes!
13:53:21 <zachk> > (mod 720 360)*(2*pi/360)::Double
13:53:22 <lambdabot>       No instance for (Integral Double)
13:53:22 <lambdabot>        arising from a use of `mod' at...
13:53:29 <sjanssen> matthew-_: yeah, +RTS -? lists -C and -V
13:53:38 <zachk> how do i fix that
13:54:03 <matthew-_> sjanssen: so, my point is that a "Haskell thread" has to be suspended by the RTS and the OS-level thread running that Haskell thread then has to go run some other Haskell thread
13:54:15 <rwbarton> zachk: depends on what you want to do
13:54:18 <rwbarton> zachk: one option is
13:54:19 <matthew-_> so, at that point, can the Haskell thread be suspended literally anywhere?
13:54:28 <rwbarton> > (fromIntegral $ mod 720 360) * (2*pi / 360)
13:54:29 <lambdabot>   0.0
13:54:29 <sjanssen> > fromIntegral (mod 720 360) * (2*pi / 360) :: Double
13:54:31 <lambdabot>   0.0
13:54:48 <matthew-_> or does it require that computation reaches some sort of "suspension" point?
13:54:52 <Leaves> hello, do you know how to convert [Char] to [Word8] (where I think length word8List = 2 * length charList)?
13:55:17 <sjanssen> matthew-_: suspension points are wherever the thread allocates memory
13:55:34 <matthew-_> Leaves: that's not necessarily the case, think unicode. See the unicode libraries on hackage
13:55:38 <matthew-_> sjanssen: ahh, interesting
13:55:40 <matthew-_> thank you
13:55:49 <sjanssen> matthew-_: the RTS checks whether a "reschedule" flag is set each time it does a heap check
13:55:51 <rwbarton> > (mod' 720 360) * (2*pi / 360) -- more likely what you want
13:55:52 <lambdabot>   0.0
13:56:16 <matthew-_> sjanssen: is that a PSW flag or just an RTS flag or what?
13:56:32 <EvilTerran> Leaves, what encoding is it in?
13:57:06 <sjanssen> matthew-_: I'm not exactly sure where it is set
13:57:56 <mightybyte> @pl \s -> s == (nub s)
13:57:57 <lambdabot> ap (==) nub
13:58:36 <Leaves> EvilTerran: I think it is just ASCI, the input (for now) is just the way I enter sting in haskell, ie "bar"
13:58:44 <mightybyte> @src ap
13:58:45 <lambdabot> ap = liftM2 id
13:58:56 <Leaves> So, then I think a Char is alsmost the same a Word8?
13:59:09 <Leaves> But I though haskell did always reserve two bytes for a Char
13:59:18 <EvilTerran> > ord (maxBound :: Char)
13:59:19 <lambdabot>   1114111
13:59:37 <matthew-_> yup
14:00:14 <EvilTerran> > length . takeWhile (>0) . iterate (`div`2) . ord $ (maxBound :: Char)
14:00:15 <lambdabot>   21
14:00:19 <matthew-_> err, that "yup" was ww, in case it confuses anyone... ;)
14:00:52 <EvilTerran> Leaves, i think haskell supports the full unicode range in chars
14:01:27 <EvilTerran> it might be up to the implementation, i forget
14:01:34 <Leaves> ok, but can it also (safely) convert between String and [Word8]?
14:01:47 <EvilTerran> it's not in any encoding when it's in haskell
14:02:00 <EvilTerran> it's literally one Char per character (unlike C, where it's one char per byte)
14:02:07 <EvilTerran> when it's a [Char], that is
14:02:18 <EvilTerran> but what encoding do you want it in the [Word8]?
14:02:42 <zachk> 89 lines of code to setup a sun an earth and a moon
14:03:04 <sjanssen> Leaves: perhaps you want the utf8-string library?
14:03:10 <matthew-_> err, I thought ghc 6.10 was meant to be out for ICFP
14:03:16 <matthew-_> it doesn't seem to be out yet
14:03:31 <zachk> http://hpaste.org/10681
14:03:37 <EvilTerran> Leaves, as in, do you care if it only works for 8-bit characters, say?
14:03:40 <Leaves> EvilTerran: I'n not very familiar with unicode, so I'm not sure if I know what you mean, but for me it doesn't matter in what way it is converted to [Word8], just as long as I can convert it back (I'm going to encrypt and decrypt the [Word8])
14:03:49 <sjanssen> matthew-_: there was a beta right before ICFP
14:03:53 <EvilTerran> ah
14:03:55 <matthew-_> cheers
14:04:01 <EvilTerran> as sjanssen says, have a look at utf8-string
14:04:06 <EvilTerran> ?hackage utf8-string
14:04:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
14:04:11 <zachk> now to just finish my physics module and have some nice solutions to numerical differential equations controlling the gl
14:04:19 <zachk> peace
14:04:33 <Ctta0s> no one here has worked with gtk2hs on a Mac? :\
14:04:41 <EvilTerran> that deals with doing a reversable [Char] to [Word8] mapping
14:04:56 <Leaves> ok thanks, I will look into that
14:06:02 <subconscious> Ctta0s: I gave up trying to get it to work on mac
14:06:15 <Ctta0s> damn
14:06:30 <sbahra> @src last
14:06:30 <lambdabot> last [x]    = x
14:06:30 <lambdabot> last (_:xs) = last xs
14:06:30 <lambdabot> last []     = undefined
14:06:33 <Ctta0s> I had it working last year with MacPorts, but it's not working anymore
14:06:38 <pastorn_> what's the memory footprint for an Int?
14:06:41 <Ctta0s> blech
14:07:08 <pastorn_> i know it's 4 bytes, but is more allocated?
14:07:30 <dmead> theres a class Int and a machine Int
14:07:33 <sjanssen> pastorn_: yes, there is a word sized box also allocated
14:07:41 <dmead> machine Int is like an int in C
14:07:47 <Cale> An expression which evaluates to an Int can use arbitrary amounts of memory, though.
14:08:08 <Cale> So it depends on how you count :)
14:08:13 <pastorn_> heh
14:08:27 <pastorn_> my real problem is that i think that i run out of memory too fast
14:08:30 <pastorn_> hang on...
14:08:33 <pastorn_> @paste
14:08:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:10:03 <pastorn_> http://hpaste.org/10682
14:10:21 <pastorn_> run a diagnostics program like htop when running that
14:10:54 <pastorn_> on my 1.6GHz machine with 4 GB RAM it eats up all my resources within 30 seconds
14:11:46 <Beelsebob> pastorn: why the monadic code for printRun?
14:12:08 <pastorn_> Beelsebob: i was hoping of the GC to remember to collect more often
14:12:15 <pastorn_> it is a *little* better
14:13:32 <tristes_tigres> no ghc 6.10 *sniff *sinff*
14:14:18 <Leaves> hmpf, haskell seems really broken in ubuntu, it doesn't have the utf8-string package and the cabal package can't install..
14:14:33 <pastorn_> Leaves: i managed to do it...
14:14:43 <pastorn_> don't ask me how, but i have it at home...
14:14:57 * pastorn_ is at school
14:15:13 <Cale> Leaves: Ubuntu's packages for GHC are pretty much always a version out of date.
14:15:33 <Cale> Leaves: However, installing the generic linux binary for GHC isn't so bad.
14:15:58 <Leaves> Cale: and does that one include utf8-string or cabal?
14:16:11 <Cale> utf8-string isn't distributed with GHC at all.
14:16:12 <pastorn_> as it stands now ubuntu provides ghc 6.8.2
14:16:27 <pastorn_> Cale: will it be incorporated?
14:16:27 <Cale> You'll get some version of Cabal, but not a new one, and there won't be a Cabal-install
14:17:31 <Cale> So, if you want to keep your Ubuntu binary of GHC, what you can do is go to Hackage, and download a newer Cabal, and cabal-install package
14:18:00 <Cale> Cabal should hopefully install fine. For cabal-install, there will be 2 or 3 dependencies you'll have to grab.
14:18:01 <pastorn_> Leaves: that might have been what i did
14:19:05 <Leaves> ok, I will try that
14:19:48 <sjanssen> Leaves: what version of GHC do you have?
14:20:03 <Cale> Once you have those two, installing further packages is easy. :)
14:20:21 <Cale> (probably 6.8.2)
14:20:28 <Leaves> sjanssen: I have the default version of ubuntu 8.04, which is 6.8.2
14:20:57 <sjanssen> Leaves: hmm, that should be able to build utf8-string.  What is the error message?
14:21:45 <Leaves> sjanssen: the problem was that neither cabal or utf8-string are in the ubuntu repo, I ahevn't tried to build utf8-string manually
14:22:17 <sjanssen> Leaves: libghc6-cabal-dev
14:22:59 <Leaves> sjanssen: yeah, but that one gives an error (depends on a different version of ghc)
14:23:26 <sjanssen> Leaves: hmm, interesting
14:23:41 <sjanssen> Leaves: oh, it seems Cabal is built in to the GHC package now
14:23:46 <Beelsebob> pastorn_: http://hpaste.org/10682#a1?
14:23:56 <Leaves> there are more errors, for instance when installing ghc, you need to install ghc6
14:24:15 <Beelsebob> doesn't seem to eat the system
14:24:31 <sjanssen> Leaves: "apt-get install ghc6" doesn't work for you?
14:24:45 <toyvo> Hello! I'd like to simplify a function, or maybe find it if it exists in standard libs. So far I have this: let f <++> g = runKleisli (Kleisli f <+> Kleisli g); Kleisli looks like boilerplate, no?
14:24:49 <Beelsebob> it overflows way before it does
14:25:19 <Leaves> sjanssen: yes, but installing ghc gives an error (the metapackage is broken)
14:25:22 <Beelsebob> switched to Integer, and it's barely using any RAM here
14:25:56 <tristes_tigres> it seems ghc 6.10 is avaliable in "stable builds" but not yet released
14:26:01 <sjanssen> Leaves: weird, the package works fine here
14:26:05 <Beelsebob> 50MB and the numbers in the middle are already entire lines long
14:26:21 <subconscious> toyvo: it looks fine to me
14:26:45 <tristes_tigres> toyvo: what do you mean by "looks like boilerplate" ?
14:26:53 <subconscious> :t let f <++> g = runKleisli (Kleisli f <+> Kleisli g) in (<++>)
14:26:54 <lambdabot>     Ambiguous occurrence `<+>'
14:26:54 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-33
14:26:54 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:56:0-46
14:27:00 <subconscious> oh
14:27:08 <subconscious> :t let f <++> g = runKleisli (Kleisli f Control.Arrow.<+> Kleisli g) in (<++>)
14:27:09 <lambdabot> forall a (m :: * -> *) b. (MonadPlus m) => (a -> m b) -> (a -> m b) -> a -> m b
14:27:23 <subconscious> :t liftM2 mplus
14:27:24 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
14:27:33 <subconscious> I think these are the same thing are they not?
14:27:39 <toyvo> hmm..
14:27:55 <Leaves> sjanssen: also when you first remove ghc6 and then try to install ghc, it errors here
14:27:59 <subconscious> for the monad (a ->) assuming that exists
14:28:25 <subconscious> :t liftM2 mplus :: (a -> m b) -> (a -> m b) -> a -> m b
14:28:26 <lambdabot>     Could not deduce (MonadPlus m) from the context ()
14:28:26 <lambdabot>       arising from a use of `mplus' at <interactive>:1:7-11
14:28:26 <lambdabot>     Possible fix:
14:28:41 <sjanssen> Leaves: I don't have a
14:28:44 <sjanssen> "ghc" package
14:29:21 <toyvo> I was wondering if there was a tool that would give you an equivalent but 'nicer' expression. Tried Hoogle and it sort of works but not exactly
14:29:39 <Leaves> sjanssen: aptitude says ghc is a meta[ackage and that it is broken
14:29:49 <rwbarton> toyvo: @pl also sort of does that but not exactly
14:30:13 <Leaves> sjanssen: it says, selecting ghc6 instead of the virtual package ghc
14:31:06 <toyvo> rwbarton: @pl is a lambdabot comand or something?
14:31:11 <rwbarton> toyvo: yes
14:31:19 <toyvo> rwbarton: thanks
14:31:30 <yitz> toyvo: there are 2 tools like that. #haskell and haskell-cafe
14:31:47 <Beelsebob> rwbarton: I would argue that if you can't infer the pointless form yourself, it isn't nicer
14:31:48 <rwbarton> toyvo: but I doubt it knows about the Klesli arrow
14:31:59 <toyvo> yitz: :)
14:32:03 <Beelsebob> i.e. if it's easier to think about in a point free style, you probably figured it out already
14:32:05 <rwbarton> Beelsebob: I have seen many people use @pl and then say "oh, duh" :)
14:32:15 <Beelsebob> that's true I guess
14:32:22 <Beelsebob> my suspicion is they haven't thought though
14:32:31 <Beelsebob> that's certainly true when I've gone "oh duh"
14:32:42 <rwbarton> certainly they haven't thought properly, at least.
14:32:58 <toyvo> well for me as a beginner the most value would be from typing in a function and getting out a paper reference. Again, Hoogle sort of does that
14:33:20 <Beelsebob> toyvo: you might be interested in one of ndm's tools -- I can't remember the name
14:33:32 <Beelsebob> it detected when you had duplicated a function in the prelude
14:33:43 <Beelsebob> requires your code to go through yhc though
14:34:07 <toyvo> Beelsebob: interesting, will check that out. I certainly like some of ndm's work, like Uniplate.
14:34:26 <Leaves> ok, the manual installation of utf8-string worked, for cabal-install I had to get pretty much dependencies so this is easier for now..
14:36:33 <toyvo> By the way, it was indeed liftM2 mplus, just needed to import Control.Monad.Instances; thanks!!
14:37:15 <Apocalisp> @pl liftM2 mplus
14:37:15 <lambdabot> liftM2 mplus
14:37:26 <subconscious> how do you pronounce ⟦ and ⟧?
14:38:19 <geezusfreeek> square and square (as it appeared to me)
14:41:31 <pfo> what's the difference between ``where'' and ``let ... in ...'' ?
14:41:52 <subconscious> pfo: where comes afterwards
14:43:18 <yitz> pfo: where can apply to several guard expressions. let..in can be embedded inside an expression, not only outside the definition.
14:43:19 <dmhouse> One is an expression in its own right, one forms part of a function binding expression.
14:43:31 <dmhouse> > (let x = 1 in x) + 1
14:43:33 <lambdabot>   2
14:43:39 <dmhouse> > (x where x = 1) + 1
14:43:40 <lambdabot>   mueval: Prelude.read: no parse
14:43:52 <pfo> dmhouse: thx!
14:45:47 <yitz> > let shiftAbs n x | y < 0 = negate y | otherwise = y where { y = x + n } in shiftAbs 3 (-1)
14:45:48 <lambdabot>   2
14:51:06 * osfameron feeds his pet lisp-troll
14:51:30 * [R]ayne Gives osfameron a cookie :).
14:52:42 <osfameron> yeah, I think I should have just given him a cookie
14:53:17 <osfameron> I must stop getting defensive about Perl :-)  (I mean, I *know* it's not the perfect language, but it's not like it's polite to go to someone's house and crap on their floor just because you don't like their carpet)
14:53:56 * osfameron resolves to actually do some haskell next...
14:56:30 <SamB_XP> osfameron: but of course it's fine to pee on the floor because you don't like their dog, right?
14:57:00 <osfameron> as long as you ask the dog's permission first, I don't see why not
14:57:00 * [R]ayne Gives SamB_XP a cookie. :)!
14:57:10 <SamB_XP> osfameron: wait what ?
14:57:21 <SamB_XP> ... why do you ask the dog's permission ?
14:57:38 * SamB_XP was hoping for something more like "only if you are a dog" ...
14:58:04 <the_unmaker> hello, what is the difference between haskell threads and eralng threads?
14:58:06 <osfameron> heh
14:58:18 <the_unmaker> erlang
14:58:29 <SamB_XP> well, haskell threads are for Haskell, and erlang threads are for Erlang
14:58:35 <the_unmaker> ah ok
14:58:38 <the_unmaker> wow
14:58:41 <the_unmaker> that was buggin me
14:58:47 <SamB_XP> (is there something called Erlang threads anyway ?O)
14:58:47 <the_unmaker> fhew
14:59:05 <SamB_XP> I've heard of something called "processes" in Erlang ...
15:00:57 <SamB_XP> well, how about you ask some questions about Haskell threads instead of asking for differences between them and whatever Erlang has ?
15:04:26 <sjanssen> the_unmaker: as I understand it, the implementations of Haskell threads and Erlang threads are rather similar
15:04:58 <sjanssen> the_unmaker: lightweight threads that are scheduled across N OS threads (where N should be the number of CPUs you have)
15:05:13 <the_unmaker> ok
15:05:19 <pastorn_> Beelsebob:  i don't think you really tried my code...
15:05:27 <the_unmaker> does happs use threads so it works nicely on multicore?
15:08:09 <Baughn> the_unmaker: The main difference is that Haskell allows (and encourages) you to share data between threads, instead of sending messages. Since they're immutable that amounts to the same thing, except (a) it's faster, and (b) it doesn't work without shared memory
15:08:30 <the_unmaker> and for shared memory?
15:08:42 <Baughn> Then it works
15:09:02 <the_unmaker> what does it use for shared memory?
15:09:24 <pfo> I'm trying to learn from Haskell SOE and it uses the SOEGraphics module - is there a way to use it with GHC?
15:09:30 <Baughn> ..I"m not sure I understand what you mean
15:09:38 <pastorn_> Beelsebob: you actually show all the lines, not the length of the lines, leading to a lot of printing and not so much crunching
15:09:46 <pfo> or an api compatible module that can act as an replacement?
15:09:55 <Baughn> the_unmaker: That was for you
15:10:07 <Baughn> pfo: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk <-- Here
15:10:08 <lambdabot> Title: HackageDB: soegtk-0.9.12.2
15:10:08 <the_unmaker> to program something in haskell that uses threads and shared memory, is there a shared memory lib for haskell then?
15:10:17 <olsner> http://repetae.net/dw/darcsweb.cgi?r=jhc has jhc been dead since april?
15:10:18 <lambdabot> Title: darcs - jhc
15:10:21 <pfo> Baughn: thx!
15:10:35 <sjanssen> the_unmaker: there are several shared memory abstractions you can use
15:10:36 <Baughn> the_unmaker: Shared memory is the default situation; it's what you get when the program is running on just one computer
15:10:41 <sjanssen> the_unmaker: see MVars and STM
15:11:05 <Baughn> the_unmaker: Nothing special is needed, except OS support for.. okay, shared memory. Threads, cloning, shm, whatever.
15:11:33 <the_unmaker> ok
15:11:50 <the_unmaker> now what about a program that uses 2 nodes
15:12:01 <Baughn> Then you have a problem.
15:12:03 <the_unmaker> how do haskellers do that kind of thing
15:12:03 <pfo> i cannot install soegtk via cabal install - http://hpaste.org/10683
15:12:08 <pfo> any workaround?
15:12:20 <the_unmaker> oh
15:12:34 <the_unmaker> erlang seems to insinuate that it works among 2+ nodes
15:12:35 <Baughn> the_unmaker: Explicit message-sending, for the most part. There isn't anything as nice as erlang's system, to my knowledge
15:12:53 <Baughn> the_unmaker: Though it could be implemented fairly easily, I suppose..
15:12:54 <the_unmaker> so erlang is pretty good then
15:13:01 <Baughn> For clusters, yeah
15:13:15 <the_unmaker> hm
15:13:26 <the_unmaker> wow so much free software so little time...
15:13:35 <Baughn> Erlang forces you to /always/ use message-passing, though. Passing references /is/ much more efficient, if you can.
15:13:55 <the_unmaker> so on one big box haskell might win
15:14:06 <the_unmaker> but with pizza boxes erlang is easier
15:14:12 <Baughn> With that in mind, erlang wasn't really written for efficiency; it was written for stability in the face of software /and hardware/ bugs
15:14:23 <Baughn> Or, for that matter, deliberate sabotage
15:14:30 <the_unmaker> thats kind of a cool design viewpoint
15:14:39 <the_unmaker> if y askme
15:14:52 <pfo> if there a way to get gtk and cairo via cabal to install?
15:15:09 <Baughn> Right. Using Erlang pretty much assumes that you're okay with throwing money at the problem, and just want the best solution said money can buy (including money spent on extra programmers)
15:15:10 <mapreduce> It's interesting.  Haskell tries to eliminate bugs more than handle them.
15:15:12 <Saizan> pfo: you've to install cairo with the gtk2hs installer
15:15:45 <pfo> Saizan: why is this suff not on hackage?
15:15:55 <the_unmaker> Baughn: so haskell might alllow fewer programmer hours to go into a solution?
15:16:22 <Baughn> the_unmaker: In my experience, it almost always does - unless the solution is specifically something that requires/must work on a cluster
15:16:36 <mapreduce> Erlang seems to operate at a lower level of abstraction.
15:16:41 <Saizan> pfo: soegtk is on hackage, gtk2hs is not becasue its build system is still too complex for a cabal package, however -> http://www.haskell.org/gtk2hs/download/
15:16:42 <lambdabot> Title: Gtk2Hs » Download
15:16:43 <mapreduce> All the code looks the same.
15:16:46 <the_unmaker> hm
15:16:56 <the_unmaker> haskell seems to be pretty active
15:17:03 <pfo> Saizan: thx
15:17:04 <the_unmaker> wow
15:17:16 <the_unmaker> so for a beginning programmer on linux
15:17:20 <Baughn> mapreduce: Erlang also attempts to force your programs into patterns that are hard to break - I think that's what you're seeing
15:17:28 <the_unmaker> haskell gives ncier everything than perl
15:17:38 <the_unmaker> oh
15:17:44 <Baughn> Eg. the universal watcher/worker pattern you see
15:17:45 <the_unmaker> really
15:17:55 <olsner> (although that's not saying much... most everything gives nicer everything than perl)
15:17:55 <the_unmaker> hm
15:18:06 <Cale> olsner: haha
15:18:13 <the_unmaker> much pressure by sysadmin people around me to learn perl
15:18:21 <Baughn> the_unmaker: Um. If you don't actually have a shelf full of computers, and don't intend to get one anytime soon, I'd go with haskell over erlang anytime. :P
15:18:21 <the_unmaker> Im like if Im guna learn something
15:18:21 <Cale> @remember olsner most everything gives nicer everything than perl
15:18:21 <lambdabot> Done.
15:18:25 <the_unmaker> might as well elarn something good
15:18:29 <FunctorSalad> hmm... (>.) should bind weaker than (>>>) ... hard to find bug source
15:18:54 <cjs> If you need a scripting language, both Ruby and Python are about as common as perl, and much better languages.
15:18:59 <the_unmaker> no Im just a guy with a dream fo my own company and getting more money and enhancing my social life
15:19:15 <olsner> @quote olsner.*perl
15:19:16 <lambdabot> No quotes match. You speak an infinite deal of nothing
15:19:18 <mapreduce> the_unmaker: Go into insurance.
15:19:23 <olsner> @quote perl
15:19:24 <lambdabot> Tac-Tics says: In fact, @pl is a LB command that turns good Haskell INTO perl
15:19:25 <cjs> Starting your own company will certainly not enhance your social life.
15:19:28 <the_unmaker> insurance?
15:19:37 <mapreduce> Yeah, instead of programming.
15:19:38 <the_unmaker> insurance is a good scam
15:19:43 <mapreduce> Exactly.
15:19:44 <Baughn> the_unmaker: Another thing, once you understand haskell, you should find learning erlang to be pretty easy. It does have a number of concepts haskell doesn't, but you won'T find those anywhere else /either/. :P
15:19:47 <cjs> But you will get to do things like program in Haskell, if you want to.
15:19:50 <Cale> the_unmaker: Haskell would make a good first language, I think. Ideally, you'll eventually familiarise yourself with quite a few, but Haskell shouldn't lock you too much into a pattern of thinking which would make other things much harder to learn than otherwise.
15:19:54 <the_unmaker> heh
15:20:00 <pfo> any approach to  http://hpaste.org/10684 ?
15:20:02 <olsner> Cale: that's my second (I think) perl quote in lambdabot
15:20:03 <mapreduce> Cale: Scary error messages.
15:20:08 <the_unmaker> haskell is general purpose eh
15:20:13 <mapreduce> > "help" + 5
15:20:15 <lambdabot>       No instance for (Num [Char])
15:20:15 <lambdabot>        arising from the literal `5' at <in...
15:20:47 <cjs> Haskell is significantly more powerful than Erlang, and you'll pick up Erlang very easily if you know Haskell. The converse is probably not true.
15:20:48 <Cale> pfo: That usually indicates that you need to add a dependency to the .cabal file.
15:20:56 <the_unmaker> is yaht good for a knownothing guy like me?
15:21:09 <the_unmaker> ok then ill spend my hours with haskell
15:21:16 <the_unmaker> ok how about haskell vs common lisp?
15:21:25 <Cale> the_unmaker: If you go with yaht, make sure you read the web version, and not the PDF which doesn't have various corrections in it.
15:21:25 <the_unmaker> this is a tuff one eh
15:21:36 <the_unmaker> Cale: no kidding oh thanks
15:21:51 <roconnor> @src minimum
15:21:51 <the_unmaker> my main probem is not wanting to pay for a erlang book lol
15:21:52 <lambdabot> minimum [] = undefined
15:21:52 <lambdabot> minimum xs = foldl1 min xs
15:22:02 <[R]ayne> the_unmaker: I'm actually learning haskell as my first functional programming language myself.
15:22:03 <Baughn> the_unmaker: CLOS makes a good introduction to OO, in my opinion. You /will/ run into more OO later, and CLOS gives the 30,000 feet view.
15:22:13 <[R]ayne> And I'm using YAHT
15:22:14 <roconnor> heh, to bad it isn't minimum = head . sort
15:22:17 <[R]ayne> I'd recommend it.
15:22:19 <the_unmaker> you know I have that green book by hutton at home
15:22:20 <Cale> @quote #lisp
15:22:20 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
15:22:22 <pfo> Cale: this is stuff that comes from hackage :/
15:22:39 <Cale> pfo: Right. Nothing says all that stuff is 100% up to date :)
15:22:45 <the_unmaker> graham hutton and I found there were terms he was using I didn't understand
15:22:45 <subconscious> cjs, what?
15:22:49 <subconscious> why do you say that
15:22:55 <Cale> pfo: You could bug the maintainer, or try to fix it yourself :)
15:23:09 <the_unmaker> anyone else have trouble with the hutton book?
15:23:15 <pfo> Cale: but how to fix it was my question :)
15:23:17 <osfameron> pfo: I think it's now called Graphics.SOE ?
15:23:26 <Cale> pfo: one sec, I'll grab the package
15:23:27 <osfameron> that was how I resolved when I was working through SOE anyway iirc
15:23:38 <roconnor> WTF? 5x faster than BLAST?
15:23:41 <roconnor> that's crazy
15:23:49 <roconnor> 75 lines of haskell
15:23:54 <roconnor> that's crazy
15:24:09 <Cale> pfo: Okay, see the line in the cabal file which looks like   build-depends: base, gtk >=0.9.12, cairo >=0.9.12
15:24:16 <osfameron> olsner: hehe
15:24:21 <Cale> pfo: add ", old-time" to the end of it.
15:24:22 <Saizan> roconnor: what are you talking about?
15:24:41 <Cale> pfo: and then repeat that with any extra package problems you have of the same type
15:24:45 <roconnor> slides: http://www.slideshare.net/bos31337/haskell-for-the-real-world-presentation
15:24:47 <lambdabot> Title: Haskell for the Real World, http://tinyurl.com/3zquqa
15:24:49 <pfo> osfameron: but his looks like a hugs specific module not shipped with GHC, right?
15:24:56 <roconnor> I wonder if there is a blog post somewhere
15:25:01 <joel_> how would you do the equivalent of the C sleep() function in haskell?
15:25:23 <Cale> joel_: I usually use threadDelay
15:25:30 <Cale> joel_: from Control.Concurrent
15:25:33 <joel_> Cale: thanks
15:25:47 <roconnor> Saizan: slide 26
15:25:59 <Cale> joel_: There are closer approximations in the System.Posix libraries, but in the presence of multiple threads, probably won't do what you want ;)
15:26:23 <joel_> :)
15:26:39 <Baughn> We live in the matrix. And it's a VB6 application.
15:26:45 <osfameron> pfo: sorry, the only notes I have on it are here http://greenokapi.net/blog/2007/05/21/chapter-3-soe/
15:26:47 <lambdabot> Title: Chapter 3. SOE - Just another lambdabananacamel,
15:26:50 <FunctorSalad> Baughn: that explains a lot
15:27:12 <osfameron> pfo: but I'm definitely using ghc
15:27:23 <cjay> FunctorSalad: what exactly? :)
15:27:31 <chr1s> dcoutts_: it worked!
15:27:58 <FunctorSalad> cjay: hmm that would be #self-pity material ;-)
15:28:19 <cjay> ok
15:28:40 <Baughn> cjay: Last time the bus company tried to shut down a route, we all lost a day from the divide-by-zero error
15:29:09 <cjay> :D
15:29:18 <joel_> actually, is there a way to wait until all other threads have finished?
15:29:44 <subconscious> is the author of this on #haskell ?
15:29:45 <subconscious> http://code.google.com/p/tapl-haskell/
15:29:46 <lambdabot> Title: tapl-haskell - Google Code
15:30:05 <Baughn> joel_: mapM_ takeMVar threadList, I'm afraid
15:30:14 <olsner> hmm, forkIO should be forkIO :: IO a -> IO (MVar a)
15:30:16 <subconscious> (which is awesome, by the way :))
15:30:37 <pfo> osfameron: you just import Graphics.SOE with ghc? what version?
15:30:48 <joel_> Baughn: nice ;-)
15:31:45 <increpare> has anyone here gotten HOC working with OSX10.5?  I've just tried the official 0.7 release, as well as the googlecode svn rep copy, and different errors with both.
15:32:08 <Baughn> joel_: Just make sure you first takeMVar it /before/ forking. :P
15:32:37 <pfo> somehow hackage is missing quality control
15:32:42 <olsner> Baughn: hmm, you mean *don't* takeMVar before forking?
15:32:58 <osfameron> pfo: hmmm now I'm confused
15:33:25 <Baughn> olsner: ..yeah, never mind. Of course it'd make more sense to start with an empty MVar. >_<
15:33:25 <osfameron> pfo: bear in mind that I'm lazy and dim, and I managed to get hold of Graphics.SOE when I was even less able with haskell
15:33:43 <osfameron> istr I asked someone "where's SOEGraphics", they told me to look at Graphics.SOE and it JustWorked
15:33:48 <osfameron> but it doesn't seem to be in extralibs
15:33:53 <osfameron> or on hackage
15:34:04 <shapr> blame me?
15:34:07 <osfameron> yay!
15:34:07 <shapr> Oh right, for hpaste
15:34:12 <subconscious> you you you
15:34:16 <Saizan_> osfameron: it's the soegtk package, no?
15:34:20 <shapr> me me me!
15:34:41 <osfameron> Saizan_: no idea, that's what pfo's suggesting, but I don't remember that
15:35:11 <osfameron> oh, is it this: http://www.haskell.org/gtk2hs/docs/devel/Graphics-SOE-Gtk.html
15:35:12 <lambdabot> Title: Graphics.SOE.Gtk
15:35:12 <osfameron> ?
15:35:15 * subconscious huffs
15:35:24 <osfameron> it links to http://www.haskell.org/gtk2hs/docs/devel/Graphics-SOE.html which is 404
15:35:25 <subconscious> I have to get up in the morning
15:35:43 <cjay> don't huff kittens
15:36:07 <shapr> kitten huffing, w00!
15:36:17 <osfameron> HSOE-- # no effort made to maintain API used in the tutorial exercises
15:36:39 * subconscious huffs and puffs and doesn't have time to hack
15:36:43 <pfo> but how can i import Graphics.SOE.Gtk ?
15:36:44 <osfameron> yeah, me neither
15:36:50 <pfo> i installed gtk2hs
15:36:58 <osfameron> I was hoping to start writing an adventure game in COBOL :-(
15:37:15 <osfameron> pfo: ok... in ghci can you do :m +Graphics.SOE.Gtk   ?
15:37:17 <subconscious> osfameron: which implementation?
15:37:34 <osfameron> subconscious: Accucobol at work, but I just dl'd opencobol from ubuntu repos to play with
15:37:46 <subconscious> yeah I was gonna say opencobol looks pretty cool
15:38:03 <subconscious> or at least .. will be
15:38:08 <osfameron> subconscious: will be?
15:38:11 <pfo> osfameron: ghci can't find that module
15:38:15 <subconscious> well I haven't used it for anything
15:38:18 <pfo> osfameron: but i installed gtk2hs
15:38:29 <osfameron> pfo: :m +Graphics.<TAB>  does it show you anything else?
15:39:09 <pfo> osfameron: ghc-pkg lists gtk2hs as installed
15:39:16 <Saizan_> pfo: have you also installed the soegtk package? what does ghc-pkg list soegtk says?
15:39:48 <pfo> osfameron: Graphics.<TAB> completes to cairo and gtk stuff mainly (304 lines).
15:40:15 <osfameron> subconscious: "cool" relatve to what?  (Though according to olsner, it'll be better than Perl ;-)
15:40:15 <pfo> Saizan_: i skipped soegtk since gtk2hs seems to contain Graphics.SOE.Gtk according to the docs
15:40:50 <Saizan_> pfo: which docs?
15:40:57 <pfo> http://www.haskell.org/gtk2hs/docs/devel/Graphics-SOE.html
15:42:24 <the_unmaker> are macroes same as higher order functions?
15:42:44 <SamB_XP> hehehe, no ;-)
15:42:46 <pfo> the_unmaker: no!
15:43:07 <Heffalump> lazy higher-order functions often let you do things you'd need macros for in other languages
15:43:13 <olsner> ... the sound of a thousand higher order functions screaming out in terror!
15:43:31 <SamB_XP> ... more cleanly, too
15:43:49 <Apocalisp> in a monad, no one can hear you scream
15:44:04 <SamB_XP> Apocalisp: er ... don't you mean "in space"?
15:44:17 <SamB_XP> that reminds me of an awesome game
15:44:20 <Baughn> Apocalisp: Isn't the entire point of a monad that they /can/?
15:44:22 <ystael> in a monad, no one can hear you scream... you have to 'return scream'
15:44:24 <SamB_XP> spacehog by name
15:44:36 <osfameron> ystael: hehe
15:44:41 <pfo> Saizan_: any insight into gtk2hs docs?
15:44:43 <SamB_XP> tell scream
15:44:58 <Baughn> @let scream = tell scream
15:44:59 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
15:45:09 <Saizan_> pfo: i think the docs are generated from more than one package
15:45:18 <pfo> everyhing with haskell is very nice and all; the community (this chan rocks!) and the books and all that is very fine. but what really really sucks are the docs of the packages.
15:45:32 <olsner> ... but even if no one hears you scream, they'll feel you unsafePerformIO launchMissiles
15:45:35 <Saizan_> pfo: are you on unix?
15:45:37 <subconscious> pfo: the docs are fine
15:45:45 <pfo> Saizan_: yes
15:45:55 <SamB_XP> subconscious: they could be a heck of a lot better in many cases
15:45:55 <olsner> (maybe)
15:46:01 <pfo> subconscious: the docs are not the docs but rather just API reference
15:46:04 <Saizan_> pfo: so you installed from this? http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.9.13.tar.gz
15:46:16 <Apocalisp> ?type unsafePerformIO
15:46:18 <lambdabot> Not in scope: `unsafePerformIO'
15:46:21 <Baughn> pfo: With some toolkits, all you get are the type signatures. ;_;
15:46:32 <pfo> which is of course better than just API references in other langs
15:46:36 <pfo> but still ...
15:46:41 <Baughn> (WaSH, I'm looking at you!)
15:46:41 * subconscious tries to imagine what the difference between  API reference  and  docs  is
15:46:41 <SamB_XP> pfo: for more detailed documentation, see the GTK site ...
15:46:56 <SamB_XP> subconscious: API reference lacks glue
15:47:09 <Baughn> subconscious: Information /beyond/ the API. Tutorials, examples, design documents...
15:47:34 <Saizan_> pfo: if you installed
15:47:36 <Apocalisp> ...UML diagrams
15:47:36 <pfo> i think this was sarcasm on subconscious's side ...
15:47:38 * Apocalisp ducks
15:47:48 * olsner wonders how anyone ever manages to keep non-API docs remotely up-to-date
15:47:50 <pfo> the API reference != the docs
15:47:58 <SamB_XP> pfo: why do you think that?
15:47:58 * subconscious actually was trying to figure out the difference
15:48:01 <Baughn> olsner: Discipline.
15:48:06 <SamB_XP> see, you were unjust
15:48:13 <subconscious> yeah I should go
15:48:14 <pfo> oh.
15:48:15 <pfo> sorry.
15:48:17 <subconscious> :/
15:48:19 <Saizan_> pfo: how did you install gtk2hs?
15:48:25 <pfo> apt-get
15:48:34 <SamB_XP> olsner: by not changing that which they speak about so much that they become outdated
15:48:42 <Saizan_> pfo: ok, then also install libghc6-soegtk-dev
15:48:46 <SamB_XP> ... alternatively, not very well ;-P
15:49:13 <pfo> Saizan_: thx
15:49:13 <olsner> indeed :)
15:49:24 <pfo> Saizan_: didn't see it at first.
15:49:40 <SamB_XP> oh, the third alternative is with an army of maniacs
15:50:09 <Saizan_> pfo: as usual debian's packages tend to be finely splitted
15:50:31 <Baughn> "../.cabal/bin/alex: createSymbolicLink: does not exist (No such file or directory)" <-- Now what
15:50:42 <subconscious> I don't know where all these people get these ideas about tutorials and examples and such, I've always got by with a language reference and source code
15:50:43 <sm> has anyone added frames to haddock output ?
15:50:46 <pfo> Saizan_: they also seem to just work with other libghc-* stuff provided
15:50:55 * olsner goes to bed thinking about tomorrow's perl quotes
15:51:18 <subconscious> I don't know how I never came across these kinds of things though
15:51:49 <pfo> subconscious: then you where just looking at simple stuff or invested too much time with the guts of stuff.
15:52:06 <pfo> subconscious: which is of course very nice if you have the time and care about the details.
15:52:21 <subconscious> I try to keep things as simple as possible
15:52:29 <subconscious> but I do care about the details, also
15:52:51 <pfo> or does the haskell community comment code that good in general that reading the code alone is sufficient?
15:53:08 <subconscious> pfo: oh I am talking about I think, every language I've used, not just haskell
15:53:38 <pfo> subconscious: familiar with C++ ?
15:54:42 <pfo> subconscious: never mind C++
15:54:51 <osfameron> pfo: I'm heading to bed -- I'd be interested to read how you get on with installing Graphics.SOE in the end though
15:55:01 <pfo> subconscious: you learned haskell by just reading GHC implementation?
15:55:10 <pfo> osfameron: apt-get saved the day :)
15:55:31 <osfameron> pfo: oh, you already did it?  sorry, I missed the "yatta!" moment
15:55:43 <subconscious> actually I think I learned haskell from everyone in here :)
15:55:52 <SamB_XP> yay live docs!
15:56:00 <SamB_XP> take that, Windows Live!
15:56:00 <subconscious> (and reading/writing programs too)
15:56:15 <pfo> subconscious: that's not fair, ppl here are _way_ better than the *any* docs ;)
15:56:30 <subconscious> ok I still don't actually know what you mean by docs though
15:56:46 <subconscious> I know it's _not_ what I thought it was
15:56:52 <pfo> subconscious: API reference != docs
15:56:56 <SamB_XP> subconscious: have you seen the Parsec website?
15:57:04 <SamB_XP> Daan has docs there ...
15:57:12 <SamB_XP> they are nice docs
15:57:15 <pfo> subconscious: you need something which explains rationale, idea, why is stuff like that etc., any many more.
15:57:36 <SamB_XP> IMO
15:57:37 <subconscious> pfo: who would bother to type all that out?
15:57:56 <SamB_XP> subconscious: too few :-(
15:58:11 <subconscious> are you sure it matters though?
15:58:20 <subconscious> it seems like dilution
15:58:22 <pfo> of course!
15:58:46 <SamB_XP> you don't want too much of it
15:58:49 <pfo> i think you are the first guy i met who doesn't care for any docs at all!
15:59:12 <SamB_XP> and obviously the Parsec source is kind of important to read, too ...
15:59:42 <subconscious> well I might like docs
15:59:49 <subconscious> I don't know, I don't think I have seen some
15:59:50 <pfo> SamB_XP: of course, but i can't start by reading the implementation.
15:59:56 <SamB_XP> yeah
16:00:01 <sbahra> SamB_XP, why is it important to read?
16:00:04 <subconscious> I like papers
16:00:36 <SamB_XP> sbahra: read it and see!
16:00:38 <subconscious> pfo: is http://okmij.org/ftp/papers/LogicT.pdf a doc?
16:00:40 <lambdabot> Title: cache:http://okmij.org/ftp/papers/LogicT.pdf - Google Search
16:00:43 <SamB_XP> note that I'm talking about Parsec 2
16:00:46 <pfo> here same, but papers quite often lack detail.
16:00:50 <SamB_XP> I don't know about Parsec 3
16:01:09 <pfo> they convey the idea and show the theoretical grounding and such tough ...
16:01:19 <SamB_XP> few libraries are written up in papers
16:01:44 <SamB_XP> and perhaps most of THOSE are pretty printers
16:02:51 <pfo> subconscious: that's a paper describing the implementation and the idea, which is a perfect start.
16:03:32 <pfo> but as SamB_XP said papers are very rarely about the implementation/API.
16:04:07 <pfo> that's what the docs are for, the paper should provide an overview to other stuff as well and explain where stuff fits in the bigger picture.
16:04:10 <SamB_XP> well, it's more that most libraries that you'd want to use aren't written up in papers ...
16:04:23 <subconscious> yeah I don't understand this
16:05:18 <pfo> subconscious: but you do see the argument that there is more than just the API reference about some module?
16:05:51 <pfo> all that on the meta level and stuff?
16:06:05 <SamB_XP> even if it just be comments in the source file
16:06:09 <pfo> there's also the place for examples and use cases and everything.
16:06:24 <pfo> SamB_XP: nothing against reading fine code with good docs!
16:06:47 <pfo> SamB_XP: i expected that to be more the case with haskell since it supports literal programming out of the box.
16:07:05 <pfo> SamB_XP: but seems that only the "academics" use this features for writing their books :)
16:07:12 <SamB_XP> hehehe
16:07:45 <pfo> when i frist read about this the picture with write interface code with .lhs files and implementation with .hs
16:08:01 <SamB_XP> ???
16:08:13 <pfo> + come to my head
16:08:27 <mapreduce> s/with/was/ might help in parsing that.
16:08:38 * SamB_XP shakes the sentance in the hopes that the words will come down in a more sensible order
16:08:42 <pfo> that too
16:08:43 <pfo> sorry.
16:09:24 <dibblego> sentence
16:09:34 <pfo> i imagined that people would use .lhs files for writing the interfaces and .hs files for the details
16:09:47 <FunctorSalad> for the impatient, a good doc would be one that gives you the essential information you need to start figuring the rest out. the ones that mix the essential information in with huge paragraphs of trivialities are the worst ;-)
16:10:12 <the_unmaker> hm
16:10:13 <pfo> FunctorSalad: yeah
16:10:30 <pfo> but that certainly depends on your target audience
16:12:45 <the_unmaker> so about haskell and webapps......
16:15:23 <brweber2> awesome talk at jvm lang summit!
16:15:47 <pfo> brweber2: jvm like java virtual machine?
16:16:07 <brweber2> sorry, wrong window
16:16:14 <pfo> hehehe
16:16:18 <brweber2> just saw a functional lang on jvm presentation
16:16:27 <brweber2> I'm looking for something like haskell on jvm
16:16:41 <pfo> brweber2: wanna interace java code?
16:17:06 <pfo> brweber2: of do just want the portability of the java vm?
16:17:18 <pfo> +you
16:17:23 <brweber2> want to isolate side effects and run cross platform and be able to call java libraries
16:18:26 <pfo> my guess is that haskell won't run on jvm any time soon
16:18:31 <the_unmaker> on a jvm?
16:18:36 <the_unmaker> what the hell
16:18:37 <pfo> the lazy eval doesn't fit to the jvm
16:18:40 <brweber2> haskell won't
16:19:03 <brweber2> lazy eval can work on the jvm
16:19:13 <brweber2> but its not trivial I think
16:19:17 <brweber2> and tail recursion is a problem
16:19:59 <pfo> brweber2: i think SPJ once explained that a .NET interface would be quite a lot of work because of the lazy eval
16:20:17 <subconscious> brweber2: TCO is irrelevant and it is trivial
16:20:37 <ddarius> There was at one point a Haskell to JVM backend somewhere.
16:20:53 <brweber2> yeah and there is cal
16:20:57 <brweber2> which is similar to haskell
16:21:05 <subconscious> brweber2: theres code somewhere, search for Tail Calls Don't Exist in Haskell
16:21:14 <brweber2> but you have to work around tail calls on jvm b/c they aren't supported, but are possible
16:21:21 <Associat0r> wasn't there something like jaskell?
16:21:21 <subconscious> brweber2: no that is irrelevant
16:21:28 <subconscious> brweber2: java has while and for loops
16:21:33 <subconscious> and _mutation_
16:21:34 <brweber2> jaskell did exist, not supported anymore
16:21:39 <pfo> that's just an optimization
16:22:06 <subconscious> TCO doesn't apply to haskell
16:22:09 <Associat0r> Cal/Quark then but it ain't fully haskell
16:22:10 <dibblego> "tails calls on the JVM are not supported" is untrue; you must qualify with "the Sun JVM"
16:22:10 <subconscious> TCO applies to the STG IL
16:22:32 <SamB_XP> subconscious: Haskell needs TCO
16:22:32 <pfo> subconscious: STG?
16:22:37 <brweber2> ok, true, but most jvm's are sun
16:22:43 <pfo> subconscious: IL = intermediate lang?
16:22:43 <brweber2> for the majority of users
16:22:51 <subconscious> SamB_XP: No it doesn't, the code I mentioned should be a constructive proof
16:23:16 <SamB_XP> subconscious: tail calls DO exist, though
16:23:37 <ddarius> dibblego: It doesn't matter.  It's what is you can rely on.
16:23:37 <SamB_XP> they have to be optimized at SOME level
16:23:43 <subconscious> SamB_XP: It's a name for a completely unimportant syntactic category
16:23:52 <dibblego> ddarius, it's what is what?
16:24:08 <ddarius> s/is//
16:24:12 <subconscious> they don't have to ever be optimizated, because haskell is non strict
16:24:26 <SamB_XP> subconscious: I'm not talking about syntactic tail calls
16:24:31 <ddarius> subconscious: Strict functions are a subset of non-strict functions.
16:24:35 <subconscious> you should be :)
16:24:35 <SamB_XP> I'm talking about operational tail calls
16:24:44 <dibblego> ddarius, exactly why I mentioned it - working for IBM on WebSphere (which requires the IBM JDK) and the IBM JDK itself, it is a complete non-issue, hence the need for qualification of the statement
16:24:52 <ddarius> subconscious: If you are refering to that blog post, it is mistitled and misguided.
16:25:11 <subconscious> some kind of 'semantic' tail calls are not well defined and should not be called tail calls
16:25:33 <SamB_XP> subconscious: I'm talking about a low-level concept
16:25:42 <subconscious> SamB_XP: STG level?
16:25:48 <SamB_XP> subconscious: more generic than that
16:25:57 <ddarius> dibblego: In your situation, you're fine because you say are talking about particular one.  When someone says "JVM" with no context, any should be acceptable.
16:25:59 <subconscious> if you are talknig about TCO on some IL such as STG, that's fine
16:26:07 <subconscious> it's not haskell though and should not be confused with
16:26:21 <dibblego> ddarius, when they say "the JVM", they are kidding themselves
16:26:25 <the_unmaker> you know what would be a killer haskell app?
16:26:30 <the_unmaker> a monitoring system
16:26:42 <ddarius> dibblego: There is a specification for it, no?
16:26:43 <the_unmaker> something way less shitty than nagios
16:26:55 <dibblego> ddarius, I might laugh at this point :)
16:26:57 <allbery_b> I keep thinking about it, since nagios makes my head hurt and mon is somewhat annoying
16:27:02 <pfo> the_unmaker: where's the haskell context?
16:27:03 <allbery_b> that said, I lack the time
16:27:04 <SamB_XP> subconscious: there is a more-or-less direct correspondence between the low-level tailcalls and the source Haskell, though
16:27:07 <ddarius> dibblego: I didn't say "formal"
16:27:07 <the_unmaker> I was readin about hobbit
16:27:08 <subconscious> ddarius: why is it misguided (but I think the title is a joke)
16:27:11 <allbery_b> pfo: reliability
16:27:18 <the_unmaker> haskell does snmp?
16:27:20 <dibblego> ddarius, there is what masquerades as a specification, yes
16:27:20 <the_unmaker> right?
16:27:20 <pfo> allbery_b: i c
16:27:41 <the_unmaker> nagios is a disaster
16:27:46 <SamB_XP> subconscious: anyway ... lots of code depends on TCO in the sense that I mean
16:27:48 <subconscious> SamB_XP: I don't think that can be made formal, but maybe it can.. if it can it is certainly a different concept than tail calls as some inductively defined syntactic category
16:27:49 <allbery_b> that's one of the reasons I got into Haskell (I'm a sysadmin)
16:28:04 <SamB_XP> subconscious: sure
16:28:06 <ddarius> subconscious: Because TCO is still crucial for Haskell.  There are cases that it's irrelevant, but there are cases where it is absolutely necessary e.g. foldl.
16:28:10 <the_unmaker> allbery_b: I am too and I want to learn something more powerful than perl.
16:28:16 <the_unmaker> [esp since I dotn know perl]
16:28:24 <SamB_XP> subconscious: but that doesn't make it any less important to avoid blowing the stack!
16:28:44 <subconscious> ddarius: foldl' works in O(1) stack because of the graph getting mutated
16:29:03 <subconscious> ddarius: I don't think it is good to call that process tail calls, it is very different
16:29:05 <ozy`> optimization of any kind is only necessary for dealing with corner cases, which are demonstrably irrelevant to the principles of haskell's design
16:29:27 <SamB_XP> subconscious: actually, the concept I'm speaking of subsumes syntactic tail calls
16:29:27 <ddarius> subconscious: Haskell says nothing about a "graph" (but then it says nothing about TCO).
16:29:51 <SamB_XP> I don't think Haskell demands GC either ;-P
16:29:51 <subconscious> ok -- I view haskell evaluation as graph reduction
16:30:03 <subconscious> (well I view lazy evaluation this way)
16:30:21 <allbery_b> nothing is "more powerful" (see Turing completeness).  some things are morew resistant to coding errors etc.
16:30:30 <ddarius> subconscious: That's fine, but TCO is indifferent to that.  If you use graph reduction to get TCO, that's fine.  It's still TCO.
16:30:32 <the_unmaker> hm
16:30:48 <Eridius> what's the difference between regex-pcre and regex-pcre-builtin?
16:31:01 <SamB_XP> no matter how you slice it, anything that ends up making your webserver's stack grow ever-larger every time it goes around the loop is a BAD THING
16:31:07 <FunctorSalad> dunno but there's also pcre-light ;-)
16:31:10 <subconscious> ddarius: But tail calls aren't optimized into jumps, and you can get non tail calls 'optimized' by the exact same process to operate in O(1) stack
16:31:13 <SamB_XP> subconscious: agreed?
16:31:21 <Eridius> regex-pcre and regex-pcre-builtin appear to be the same thing, down to the description and sourceforge project
16:31:27 <subconscious> ddarius: In both ways, I don't see it in any way similar to TCO
16:31:31 <Eridius> but the versions are very slightly different. And since there's 2 packages, there must be *some* difference
16:31:40 <subconscious> SamB_XP: yes of course
16:32:10 <SamB_XP> subconscious: THAT is why you need this operational TCO
16:32:12 <ddarius> subconscious: TCO is a bad term.  TCO is indifferent to "jumps" too.
16:32:22 <SamB_XP> ddarius: hmm?
16:32:38 <subconscious> SamB_XP: You don't need TCO, but an execution model (such as graph rewriting) is essential, yes
16:32:55 <subconscious> (to reason about how much stack space is used)
16:32:57 <ddarius> subconscious: If you use beta-reduction and term rewriting you get TCO as well even though there are no jumps.
16:33:46 <subconscious> You cannot reason about haskell recursion the same way you reason about tail calls in scheme (which has a formal definition)
16:33:50 <SamB_XP> subconscious: my mental execution model is a simplified version of GHC's ;-P
16:34:32 <ddarius> subconscious: That's mostly true.  However, you can easily generalize the syntactic notion of "tail call" by providing accurate strictness information.
16:34:36 <SamB_XP> gee
16:34:44 <SamB_XP> apparantly McCain is a liar
16:34:47 <dibblego> apparently
16:34:49 <SamB_XP> I NEVER WOULD HAVE GUESSED
16:35:00 <SamB_XP> I thought that was his profession?
16:35:02 <ozy`> SamB_XP: what's the story this time?
16:35:21 <SamB_XP> I don't know, I was reading some manga and I saw an ad that said that
16:36:07 <SamB_XP> thankfully it only said that on the screen
16:36:07 <subconscious> ddarius: I think since you can take any tail recursive program and (with some strictness annotations or seq) have it run in the same stack as it would in scheme, but the reason it works is obviously not the same mechanism, and the mechanism of haskell is much more general -- that's really why I don't think the TCO term is suitable
16:36:12 <SamB_XP> not out loud ;-)
16:36:34 <subconscious> oops that didn't grammer correctly :/
16:36:49 <SamB_XP> subconscious: I don't really care what you call it, but you sure aren't going to get much done without it ;-)
16:37:09 <subconscious> SamB_XP: hehe that is true
16:37:24 <ddarius> subconscious: I'm saying I can formulate a notion of "tail call" that accurately captures the operational intuition (as the usual notion does in Scheme) given accurate strictness information.  I didn't say anything about adding strictness.
16:37:28 <subconscious> SamB_XP: I don't think there is a name for it (other than lazy evaluation)
16:37:36 <ddarius> This new notion would contain the old one as a special case.
16:38:43 <SamB_XP> of course, you don't actually need to do that unless you are trying to construct a provably-correct implementation ...
16:38:48 <subconscious> ddarius: if you did that,  it would presumable recognize things like  spam = print "spam" >> spam,  and it makes no sense to call that a _tail_ call -- I don't know a better name though
16:39:03 <SamB_XP> subconscious: I call it a tail call anyway
16:39:17 <ddarius> subconscious: Different words could be used but the actual name is beside the point.
16:39:41 <subconscious> using the wrong name brings over all our intuitions from strict languages
16:39:43 <subconscious> this is very dangerous
16:40:03 <SamB_XP> well, I'd be careful not to apply all of those intuitions unless the monad is appropriate for that
16:40:41 <SamB_XP> which IO is
16:40:50 <subconscious> SamB_XP: every program _should_ be provably-correct :)) doesn't mean you actually wrote out a proof though
16:41:25 <pjdelport> if a program runs in the wood, but no one is around to prove it, is it still correct?
16:41:35 <SamB_XP> subconscious: there's no way that it would be practical unless you rewrote tricky bits to suit the proof
16:41:36 <unmarshal> anyone remember the name of that haskell project it was like a visual programming environment
16:41:39 <unmarshal> with drag and drop
16:41:41 <unmarshal> kinda like max/msp
16:41:54 <SamB_XP> subconscious: it might even require radical reorganization
16:42:04 <allbery_b> hIDE?
16:42:12 <SamB_XP> (frankly, lots of programs aren't actually correct ;-P)
16:42:12 <allbery_b> visual haskell?
16:42:32 <subconscious> SamB_XP: sadly yeah, programs I use a lot like .. operating systems and so on
16:42:38 <subconscious> it really sucks actually
16:42:43 <unmarshal> not the visual studio plugin
16:42:46 <unmarshal> it was a bit diff
16:42:47 <unmarshal> cant remember
16:43:18 <Associat0r> leksah?
16:43:42 <unmarshal> hmm, not it.. thanks though
16:43:45 <unmarshal> 'll keep googlin
16:44:39 <bjrn> What's the Hackage policy on software written for teaching? That is software that is meant to be read, not used in practice.
16:44:43 <ddarius> subconscious: Tail calls still exist in Haskell, they are still relevant, and (in all current implementations) are still optimized.  It is -something else- that is breaking down when foldl stack overflows.  There is foldl examples that don't overflow the stack that would without TCO, e.g. reverse.
16:45:33 <subconscious> there is TCO done in say GHC
16:45:39 <allbery_b> eclipsefp plugin?
16:45:39 <SamB_XP> bjrn: POLICY?
16:45:42 <subconscious> that is true, because it compiles via STG
16:45:46 <subconscious> and it happens on STG
16:45:47 <SamB_XP> what makes you think we have something like that?
16:45:59 <bjrn> Hehe, surely must be some informal guidelines at least :)
16:46:37 <ddarius> subconscious: Again.  TCO is not an "implementation" thing.  You can characterize it independently of implementation.
16:47:15 <subconscious> when I say TCO I mean the actuall act of optimizing it out, not just recognizing a tail call
16:47:26 <bjrn> By the way this has nothing to do with Haskell but Anathem is awesome so far. Only read 100 pages tho.
16:47:59 <bjrn> Being Stephenson this means I don't really know what the book is about yet
16:48:24 <subconscious> hm I don't know, are you able to take as input a program and output whether or not it operates on O(1) stack
16:48:39 <SamB_XP> ddarius: but why bother?
16:48:45 <ddarius> subconscious: When I say TCO, I mean the property of functions like foldl running in constant -control- stack.  I don't say TCO for "tail call."
16:49:11 <ddarius> subconscious: That's not the requirement.
16:49:12 <subconscious> what stacks are there, I don't even think I heardof a control stack
16:49:26 <subconscious> I just imagine a big graph on a heap and a C program with a stack evaluating it
16:49:33 <ddarius> subconscious: "Control stack" is conceptual.
16:49:39 <ddarius> "Context" is another word.
16:49:39 <SamB_XP> subconscious: you know, the STACK
16:49:39 <SamB_XP> the one from C
16:49:46 <SamB_XP> except not actually because GHC uses a different one I think?
16:49:47 <Cale> subconscious: Why a C program? :)
16:49:47 <subconscious> is my model matching it?
16:49:52 <SamB_XP> dunno
16:49:52 <ddarius> SamB_XP: It doesn't have to be the "C" stack.
16:50:05 <SamB_XP> well, it's the same idea anyway
16:50:29 <subconscious> Cale: hmm I think that it what GHC does in reality, but by C I guess just mean that sort of language
16:50:42 <pastorn_> @pl \(n,b) -> b && n ==10
16:50:42 <lambdabot> uncurry (flip (&&) . (10 ==))
16:50:44 <Cale> subconscious: GHC compiles to native code these days
16:50:45 <pastorn_> yay
16:50:56 <Cale> (at least, by default)
16:50:57 <ddarius> subconscious: In term/graph rewriting, the context could be the rest of the expression that is not the immediate redex.
16:51:13 <pastorn_> @pl \(n,b) -> n == 10 && b
16:51:14 <lambdabot> uncurry ((&&) . (10 ==))
16:51:32 <subconscious> I see
16:52:02 <Cale> I imagine GHC's stack as representing the path taken from the root of the expression which is being inspected by a case-expression down to the outermost redex in it.
16:53:45 <ddarius> Actually that precise example I gave would not be reasonable.
16:56:37 <Saizan_> the base-3.0.3.0 compat package that comes with ghc-6.10 is going to cause a lot of troubles for cabal-install
16:57:58 <subconscious> oh Saizan, eventually I tried to install the cabal which is inside the GHC 6.10 sources, and it seems to have worked
16:59:25 <Igloo> Saizan_: Do you mean the infinite loop? If so, someone sent a patch for it a day or so ago
17:02:22 <Saizan_> Igloo: yeah, i sent that, when i was unaware of the trac ticket, but it just solves the infinite recursion, not the other assumptions broken by that package
17:03:05 <Igloo> Ah, OK
17:04:11 <SamB_XP> isn't it just great when someone gets told about their own patch ;-) ?
17:04:32 <Igloo> If you think the problems are insurmountable then can you let us know ASAP, please, and we might have to rethink shipping it?
17:05:50 <Saizan_> Igloo: i don't know the dependency resolver code so well, sorry, i think dcoutts has written most of it
17:08:34 <Igloo> OK, I'm sure he's on the case
17:08:50 <shapr> newsham: ping
17:11:17 <pastorn_> @pl \r (n,b) -> (n+1, b && (length r ==9))
17:11:18 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,) . (1 +)) . flip (&&) . (9 ==) . length
17:18:10 <pastorn_> @pl \fp -> readFile fp >>= return . length
17:18:11 <lambdabot> (length `fmap`) . readFile
17:18:32 <pastorn_> @type (length `fmap`)
17:18:33 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f Int
17:18:50 <newsham> shapr: hi
17:18:50 <lambdabot> newsham: You have 1 new message. '/msg lambdabot @messages' to read it.
17:22:36 <shapr> newsham: y0
17:24:43 <pastorn_> is there any good way to make conditionals pointsfree?
17:25:02 * pastorn_ can't think of any
17:26:42 <Cale> pastorn_: liftM2 is usually helpful
17:26:48 <SamB_XP> @pl if x == y then z else w
17:26:48 <lambdabot> if' (x == y) z w
17:27:43 <pastorn_> hehe
17:27:50 <pastorn_> @src liftM2
17:27:50 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
17:27:56 <SamB_XP> but it only works if you define it ;-P
17:28:16 <pastorn_> my code is going to look like shit
17:28:24 <pastorn_> @type if'
17:28:25 <lambdabot> Not in scope: `if''
17:28:41 <FunctorSalad> pastorn_: ArrowIf represents falsity as the empty list
17:29:30 <pastorn_> FunctorSalad: where? what?
17:29:40 <pastorn_> it's not in Control.Arrow...
17:29:55 <seydar> what *are* arrows?
17:30:01 <FunctorSalad> http://hackage.haskell.org/packages/archive/hxt/8.1.0/doc/html/Control-Arrow-ArrowIf.html
17:30:01 <shapr> poky things!
17:30:07 <lambdabot> Title: Control.Arrow.ArrowIf, http://tinyurl.com/4hcas2
17:30:28 <FunctorSalad> it's in hxt but the arrows there seem to be general-purpose
17:30:39 <pastorn_> seydar: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
17:30:40 <lambdabot> Title: Haskell/Understanding arrows - Wikibooks, collection of open-content textbooks
17:32:36 <seydar> thank you all!
17:32:38 <seydar> you all win!
17:32:39 <seydar> a prize
17:33:08 <FunctorSalad> in hxt everything returns a list (for example, getChildren :: IOSArrow XmlTree XmlTree)
17:33:26 <FunctorSalad> so it's convenient to just let the empty list double as "false"
17:34:05 <FunctorSalad> for example, getChildren >>> getText `orElse` constA "no children"
17:35:45 <SamB_XP> @src Monoid
17:35:45 <lambdabot> class Monoid a where
17:35:45 <lambdabot>     mempty  :: a
17:35:45 <lambdabot>     mappend :: a -> a -> a
17:35:45 <lambdabot>     mconcat :: [a] -> a
17:37:03 * SamB_XP was thinking about saying something about mempty, only he had been thinking that it was called mzero but realized that that was (supposed to be) in MonadZero
17:46:51 <pastorn_> http://hpaste.org/10685
17:47:00 <pastorn_> i could use some help with that
17:47:20 <pastorn_> speed is the goal here...
17:48:09 <Cale> pastorn_: Is it really faster?
17:48:42 <pastorn_> Cale: i don't know... i'm just avoiding nub since it's O(n^2)
17:48:53 <pastorn_> or maybe it's O(n!)
17:49:12 <Cale> That would be quite a bad algorithm ;)
17:49:24 <Cale> It's O(n^2) worst case.
17:49:33 <Cale> However, it's productive.
17:49:41 <pastorn_> right
17:50:02 <pastorn_> what is?
17:50:04 <pastorn_> nub?
17:50:15 <Cale> nub. It can operate lazily.
17:50:18 <Cale> > nub [1..]
17:50:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:50:25 <FunctorSalad> pastorn_: you could use a set, that would be O(n log n)
17:50:46 <pastorn_> FunctorSalad: heh, the overhead might be too costsome
17:51:07 <FunctorSalad> yeah
17:51:09 <pastorn_> as i wrote, it's just 9 elements
17:51:24 <pastorn_> though i could make myself a simple unbalanced binary tree
17:51:30 <Cale> Try nub' = map head . group . sort
17:51:35 <FunctorSalad> or some simple hash-table thing
17:51:38 <Cale> But that will sort the elements.
17:51:55 <roconnor> and requires Ord
17:52:20 <pastorn_> please annotate your suggestions :)
17:52:24 <Cale> Are you sure that the obvious code using nub is really too slow?
17:52:43 <pastorn_> Cale: no, that's more of a guess
17:53:00 <Cale> pastorn_: Note that the code you wrote has essentially the same complexity as the code with nub.
17:53:02 <roconnor> what is slow is never what you think :P
17:53:21 * roconnor shakes his fist at rotate
17:53:27 <newsham> > nub "premature optimization"
17:53:28 <Cale> In fact, it almost does the same thing as nub.
17:53:28 <lambdabot>   "prematu oizn"
17:53:57 <pastorn_> newsham: actually not, this is like the 10th time i'm doing this lab
17:54:15 <newsham> > unnub "prematu oizn"
17:54:15 <lambdabot>   mueval: Prelude.read: no parse
17:54:20 <pastorn_> i'm trying to make all my functions be as fast as possible
17:54:55 <newsham> it cant be that fast if its your 10th time.
17:55:04 <newsham> how many hours has it taken already?
17:55:12 <pastorn_> newsham: has what taken?
17:55:20 <newsham> the 9 other times
17:55:45 <pastorn_> heh, this is one of the first labs that the students that arrive at CS at chalmers get to do
17:56:20 <pastorn_> it's good training on working with lists
17:56:25 <pastorn_> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab3.html
17:56:29 <lambdabot> Title: Introduction to Functional Programming -- Lab 3
17:56:40 <pastorn_> this is D1
17:57:25 <newsham> i like this one http://web.math.unifi.it/users/maggesi/haskell_sudoku_solver.html
17:58:07 <hackage> Uploaded to hackage: graphmod 1.1.2
17:59:31 <ivanm> http://www.reddit.com/r/programming/comments/73hqm/does_literate_programming_help_you_in_what_way/c05kt12 <-- how is haskell literate programming not "real" literate programming?
17:59:33 <lambdabot> Title: jerf comments on Does Literate Programming help you? In what way?, http://tinyurl.com/4ouxtz
17:59:39 <luqui> Does anyone recognize a functor m with an operation of type:  m (m a -> a)
17:59:50 <luqui> is this equivalent to monad?
17:59:59 <dibblego> looks a bit like a comonad
18:00:04 <luqui> (looks like join... but I can't see how)
18:00:24 <pastorn_> @pl \xs -> let ys = filter isJust xs in ys == nub ys
18:00:24 <lambdabot> ap (==) nub . fix . const . filter isJust
18:00:40 <pastorn_> @type const
18:00:41 <lambdabot> forall a b. a -> b -> a
18:02:44 <pastorn_> @type ap
18:02:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:03:28 <pastorn_> how is ([a] -> [a]) a monad?
18:03:28 <cjb> hm, want to write something in haskell
18:03:34 <cjb> don't know what to write.
18:03:38 <cjb> this happens a lot.  :)
18:03:42 <pastorn_> cjb: project euler?
18:04:05 <pastorn_> @src ap
18:04:06 <lambdabot> ap = liftM2 id
18:04:07 <luqui> pastorn, it's not even  functor
18:04:08 <cjb> maybe, but I meant something that other people might want to use or be interested in afterwards
18:04:12 <bjrn> New Project Euler problem tomorrow :)
18:04:15 <dibblego> pastorn, forall t. ((->) t) is a monad since you can write it :)
18:04:47 <pastorn_> dibblego: i tried understanindg ((->) a) once
18:04:50 <pastorn_> didn't
18:04:57 <dibblego> (t -> a) -> (b -> t -> b) -> t -> b
18:05:02 <dibblego> oops
18:05:05 <dibblego> (t -> a) -> (a -> t -> b) -> t -> b
18:05:08 <luqui> pastorn, do you know about Reader?
18:05:27 <pastorn_> dibblego: how might i end up with something like ((->) a)?
18:05:32 <pastorn_> luqui: no
18:05:48 <dibblego> pastorn, that's a type constructor on its own; it just so happens that it is also a monad
18:05:51 <pastorn_> it's not partial application, is it?
18:05:56 <luqui> dibblego, I prefer join for that one, actually.  join :: (t -> t -> a) -> (t -> a); join f t = f t t.
18:06:04 <dibblego> it's a partially applied type argument, yes
18:06:05 <ddarius> pastorn: http://hpaste.org/10685#a1
18:06:31 <luqui> you can think of it like (a ->), or \x -> (a -> x)
18:06:34 <luqui> (type lambda)
18:06:50 <pastorn_> ddarius: i like that!!
18:06:52 <pastorn_> smart
18:07:06 <pastorn_> Data.Bits usually doesn't feel very haskell-y
18:07:54 <pastorn_> luqui: \x -> (\a -> x) ?
18:08:32 <luqui> pastorn_, oh, no.  the left arrow is the arrow from a lambda, as in (\x -> x + 1), the right arrow is *different*, it's the arrow for a type, as in Int -> Int.
18:08:43 <luqui> but there are no type lambdas anyway, it's just a way to think.
18:09:14 <pastorn_> i'm feeling that there's some fundamental thing here that i don't know about...
18:09:40 <luqui> at least you know you don't know.  next step is to know *what* you don't know :-)
18:10:46 <luqui> pastorn_, ok, so the ((->) a)  (a.k.a. Reader) monad just puts the entire computation under an assumed argument a.
18:10:59 <pastorn_> huh?
18:11:04 <pastorn_> what computation?
18:11:10 <luqui> the monadic one...
18:11:22 <pastorn_> where did that come from?
18:11:28 * pastorn_ gets dizzy
18:11:30 <luqui> so say you have: do { x <- foo; return (x+1) }
18:11:38 <luqui> be patient :-)
18:11:43 <pastorn_> ah, that's more like it!
18:11:59 <luqui> let's give it a name.   bar = do { x <- foo; return (x+1) }
18:12:18 <luqui> this is the same as: bar a = let x = foo a in x + 1.
18:12:22 <luqui> see the correspondence?
18:13:15 <pastorn_> well, foo in the do-function doesn't take an argument, but i get it
18:13:25 <luqui> likewise, do { x <- foo; y <- baz x; return (x+y) } becomes \a -> let x = foo a in    let y = baz x a in    x + y
18:13:39 <luqui> pastorn_, that's *exactly* it, it does take an argument
18:14:00 <luqui> because foo :: m Int, and m is (a ->), so foo :: a -> Int
18:14:55 <pastorn_> hang on... still writing down that second do-function
18:15:38 <luqui> ok.  just note how it takes a parameter a, and then sends that parameter to each subcomputation (foo, baz, ...)
18:17:44 <pastorn_> naaah, but see, how could i pass an argument to foo in bar
18:17:49 <pastorn_> bar = do
18:17:49 <pastorn_>   x <- foo
18:17:49 <pastorn_>   return (x+1)
18:18:30 <pastorn_> if any argumenst would be passed into bar they'd end up in the return statement
18:18:57 <pastorn_> so maybe if i gave it something like (. (+20)) then it would be ok...
18:19:07 <luqui> hmm, not quite sure what you're saying.
18:19:30 <pastorn_> bar = foo >>= \x -> return (x + 1)
18:19:44 <pastorn_> so how can i give argumenst to foo?
18:19:54 <luqui> well what is the type of foo?
18:20:00 <pastorn_> m Int
18:20:03 <luqui> and what is m?
18:20:10 <pastorn_> dunno
18:20:20 <luqui> we're talking about the ((->) a) monad right?
18:20:37 <pastorn_> might be Maybe, might be List or IO... what do i know?
18:21:01 <luqui> those are all monads.  so is ((->) a)
18:21:13 <luqui> so yeah, bar works on whatever monad foo is in.
18:21:29 <pastorn_> yeah
18:21:38 <luqui> but since we're trying to understand reader (or ((->) a)), let's assume foo is in that one
18:21:43 <lispy> bar y = foo x >>= \x -> return (x + 1)
18:21:59 <pastorn_> ooookay?
18:22:02 <luqui> lispy, what?
18:22:12 <lispy> 18:18 <pastorn_> bar = foo >>= \x -> return (x + 1)
18:22:12 <lispy> 18:18 <pastorn_> so how can i give argumenst to foo?
18:22:12 <luqui> so m = ((->) a)
18:22:16 <lispy> (I was answering that)
18:22:36 <luqui> so then what is the type of foo, which was m Int ?
18:22:50 <pastorn_> did you do a typo there?
18:22:56 <pastorn_>  bar y = foo x >>= \x ...
18:23:02 <lispy> oh yeah foo y
18:23:04 <lispy> sorry
18:23:27 <lispy> bar y = foo y >>= \x -> return (x + 1)
18:23:51 <luqui> right, which is certainly legal, and to be clear has nothing to do with our monad.
18:23:59 <pastorn_> luqui: ok... foo :: ((-> a) Int)
18:24:15 <luqui> well, modulo the typo you just made, yeah :-)
18:24:29 <luqui> foo :: ((->) a Int)
18:24:38 <luqui> which just means:  foo :: a -> Int
18:25:00 <pastorn_> heh, so type arrows can be prefix? kinda cool...
18:25:25 <luqui> yeah that's the hack that makes it possible for -> to be a monad :-)
18:25:27 <lispy> :t id :: ((->) a a)
18:25:29 <lambdabot> forall a. a -> a
18:25:41 <pastorn_> heh
18:25:52 <lispy> :t [1] :: [] Int
18:25:54 <lambdabot> [Int]
18:26:01 <lispy> That one can be prefix too
18:26:03 <pastorn_> luqui: so what kind of function is foo then?
18:26:16 <luqui> pastorn_, any kind.  one that takes an a.
18:26:19 <pastorn_> does it take an argument of type a and produce an Int?
18:26:23 <luqui> in this monad, "actions" are just functions from a.
18:26:29 <luqui> yes
18:26:29 <pastorn_> or is foo in itself a function from a to Int?
18:26:36 <luqui> uh... both?
18:26:39 <pastorn_> ok
18:27:08 <pastorn_> lemme guess...
18:27:43 <pastorn_> return :: (a -> m a); return x = \_ -> x
18:27:49 <lispy> f >>= g = do { a <- ask; b <- f a; return (g b) } -- I think this is bind
18:27:49 <pastorn_> or?
18:27:54 <luqui> > (do { x <- (+1); return x }) 41      -- odd demonstration.  (+1) :: Int -> Int, so (+1) :: m Int   for our m
18:27:56 <lambdabot>   42
18:27:59 <luqui> pastorn_,  exactly!
18:28:01 <pastorn_> gah!!
18:28:05 <pastorn_> not su much!!
18:28:09 <pastorn_> chill
18:28:51 <luqui> lispy, what are you talking about?
18:29:09 <lispy> luqui: isn't that how Reader ((->) a), defines (>>=) ?
18:29:29 <luqui> lispy, you mean in terms of do notation, which is itself defined in terms of >>=.
18:29:33 <pastorn_> let f = do {x <- (+1); return x}
18:29:34 <pastorn_> Prelude> :t f
18:29:34 <pastorn_> f :: Integer -> Integer
18:29:34 <luqui> doubtful :-)
18:29:44 <pastorn_> hmmm... I MIGHT be onto something here...
18:29:49 <vininim> @instances (>>=)
18:29:50 <lambdabot> Couldn't find class `(>>=)'. Try @instances-importing
18:30:00 <lispy> luqui: um...I didn't mean how is it implemented, just how it's semantically defined
18:30:00 <vininim> uh
18:30:11 <vininim> @src (>>=)
18:30:12 <lambdabot> Source not found. :(
18:30:13 <lispy> ?undo do { a <- ask; b <- f a; return (g b) }
18:30:14 <lambdabot> ask >>= \ a -> f a >>= \ b -> return (g b)
18:30:28 <luqui> m >>= f = \x -> f x (m x)
18:30:38 <luqui> that's what it means and how it is implemented :-)
18:31:02 <luqui> wait I might be confusing that with <*>...
18:31:11 <luqui> m >>= f = f (m x) x
18:31:14 <lispy> Doesn't Reader ((->) a), need to call ask?
18:31:16 <luqui> that's the one :-)
18:31:22 <luqui> ugh, with a \x -> in front
18:31:24 <pastorn_> hang on here... in (>>=) f :: (a -> m b)
18:31:57 <luqui> lispy, oh, if you do it the newtype way; i.e. Reader r a = Reader (r -> a), and define ask = Reader id, then yeah
18:32:17 <luqui> we're working directly on ((->) a) though, which is the same thing without the newtype
18:32:53 <pastorn_> m (:: m a) >>= f (a -> m b)= \x (:: ?) -> f x (m x) (:: m b, somehow...)
18:33:35 <luqui> (m :: r -> a) >>= (f :: a -> (r -> b)) = \(x :: r) -> f x (m x) :: r -> b
18:33:48 <luqui> I just replaced m with r ->, which is what it is in this case
18:34:21 <Olathe> In "class BuildList a r | r -> a where", what does "| r -> a" mean ?
18:34:21 <luqui> oh, but not \x -> f x (m x), that was wrong.  it's \x -> f (m x) x
18:35:00 <luqui> Olathe, that's a functional dependency. see haskell wiki
18:35:00 <bjrn> Olathe: http://www.haskell.org/haskellwiki/Functional_dependencies
18:35:02 <lambdabot> Title: Functional dependencies - HaskellWiki
18:35:08 <Olathe> Thanks :)
18:35:42 <pastorn_> weird
18:36:03 <thoughtpolice> Olathe: it basically means if you have BuildList TyA TyB, you can not also have BuildList TyA TyC -- TyA uniquely determines TyB, always
18:36:15 <thoughtpolice> so it establishes a relation for any two types
18:36:27 <pastorn_> let f = do {x <- (+1); return x} <-- this works and f :: Integer -> Integer
18:36:29 <pastorn_> but
18:36:44 <pastorn_> x <- (+1) doesn't work
18:36:54 <thoughtpolice> Olathe: personally I think assoc. types are easier to grok
18:37:09 <Olathe> thoughtpolice: Ahh, OK :)
18:37:14 <Olathe> Hmm, never heard of those.
18:37:23 <Olathe> Then again, I'm very new to type theory.
18:37:42 <Olathe> Functional dependencies seem very nice.
18:40:25 <thoughtpolice> i never knew what fundeps really meant for the longest time
18:40:39 <thoughtpolice> but i like associated types because they are more functional in nature than a fundep
18:41:49 <thoughtpolice> and with ghc 6.10 they should be pretty much fully go
18:42:08 <Olathe> Is there a page on associated types ?
18:42:19 <Olathe> I searched, but it didn't seem to find one.
18:42:19 <thoughtpolice> http://haskell.org/haskellwiki/GHC/Type_families
18:42:21 <lambdabot> Title: GHC/Type families - HaskellWiki
18:42:25 <Olathe> Thanks :)
18:43:03 <the_unmaker> haskell has good facilities for working on lists and sets? even complicated intersections?
18:43:46 <ddarius> > intersect "abcde" "def"
18:43:47 <lambdabot>   "de"
18:43:54 <thoughtpolice> Olathe: example - http://hpaste.org/10686
18:44:41 <thoughtpolice> i think you might see what i mean by 'more functional' :]
18:45:28 <vininim_> > gcs "attgccgat" "aaaagctcacct"
18:45:28 <lambdabot>   mueval: Prelude.read: no parse
18:48:18 <pastorn_> ddarius: did you use some special parameters for your notation?
18:48:22 <pastorn_> (!bitset)
18:48:34 <pastorn_> i can't seem to get it to typecheck
18:48:35 <ddarius> -XBangPatterns
18:49:03 <ddarius> There's also a more efficient shiftL called uncheckedShiftL somewhere.
18:49:10 <ddarius> (or something like that)
18:49:20 <pastorn_> difference?
18:49:40 <ddarius> shiftL checks for overflow and I guess throws an error in that case or something.
18:51:05 <pastorn_> btw, what's the notation for that -XBangPatterns?
18:51:23 <dibblego> it's a GHC extension
18:51:32 <pastorn_> {-#GHC lol lol -XBangPatterns lol lol -}
18:51:36 <ddarius> That's a commandline parameter or you can add a {-# LANGUAGE BangPatterns #-} or I don't understand your question.
18:52:00 <dibblego> that's called a Haskell comment
18:52:04 <dibblego> {- this is a comment -}
18:52:25 <int-e> pastorn_: uncheckedShiftl# (from GHC.Base) has an odd overflow in the shift, similar to C ... W# (uncheckedShiftL# (int2Word# 1#) 64#) gives 1 for me.
18:53:02 <int-e> > shiftL (1 :: Word) 64
18:53:03 <lambdabot>   0
18:53:31 <pastorn_>  shiftL (1 :: Word) 65
18:53:36 <pastorn_> > shiftL (1 :: Word) 65
18:53:37 <lambdabot>   0
18:53:44 <pastorn_> > shiftL (1 :: Word) 63
18:53:45 <lambdabot>   9223372036854775808
18:53:49 <pastorn_> nice
18:54:27 <Olathe> > (up :: Word)
18:54:28 <lambdabot>   mueval: Prelude.read: no parse
18:54:54 <pastorn_> @pl \x -> fromJust x ++ transpose x
18:54:54 <lambdabot> liftM2 (++) fromJust transpose
18:59:17 <pastorn_> ddarius: btw, why do you want to have !bitset?
18:59:24 <pastorn_> it's for strictness, right?
19:05:13 <ddarius> pastorn: Yes.  You don't want that integer to be boxed.
19:05:51 <pastorn_> boxed = lazy?
19:06:28 <ddarius> lazy => boxed, but no.
19:06:54 <pastorn_> what happends if it's boxed?
19:13:33 <lispy> pastorn_: do you know what the box is?
19:13:53 <pastorn_> lispy: no
19:14:39 <lispy> pastorn_: if I recall correctly, the box is a wrapper used at the C/asm level to hold the value.  I think it may help with things like garbage collection
19:14:53 <pastorn_> ok
19:15:06 <lispy> pastorn_: so not having the box (and the level of indirection it adds) speeds things up
19:15:13 <lispy> takes less memory, etc
19:15:22 <pastorn_> well, i'm allocating a Word16 for this, so i don't think the GC will be of much trouble here :D
19:17:08 <lispy> Oh, maybe the reason values get boxed is also to deal with laziness
19:17:21 <lispy> That would explain why ddarius said lazy => boxed
19:17:30 <pastorn_> yeah...
19:17:45 <lispy> So the thunk could be the box
19:18:04 <lispy> and if you don't need the thunk (because it's strict) then you can toss the box ad use the value directly
19:21:58 <pastorn_> @src splitAt
19:21:58 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
19:22:11 <lispy> I think the bit I was thinking about garbage collection is that you can use boxing as an alternative to tagging
19:22:23 <Cale> dibblego: heh, was that you commenting on the MSDN blog where the guy was discussing how people must follow the instructions provided in the API documentation?
19:22:37 <pastorn_> isn't it possible to do that quicker?
19:22:42 <Cale> pastorn_: yes
19:22:51 <dibblego> Cale, prolly :)
19:22:55 <Cale> pastorn_: The code provided by @src need not be the actual source.
19:23:01 <pastorn_> oh
19:23:08 <Cale> dibblego: The thing about GetEnvironmentStrings/FreeEnvironmentStrings
19:23:12 <pastorn_> @hoogle splitAt
19:23:12 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
19:23:12 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
19:23:12 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
19:23:13 <dibblego> yep
19:23:36 <Cale> I wrote this: http://blogs.msdn.com/oldnewthing/archive/2008/09/25/8965129.aspx#8965837
19:23:42 <lambdabot> Title: The Old New Thing : Even if a function doesn't do anything, you still have to ca ..., http://tinyurl.com/3zkfqn
19:25:45 <bd_> Cale: Unfortunately, the windows API didn't have that luxury at the time it was designed (due to simple compilers and extreme memory constraints), and inherited the basic design due to years of legacy code :)
19:26:15 <bd_> legacy third-party code*
19:28:48 <Cale> bd_: right.
19:30:09 <Cale> bd_: and it would probably be easier to throw it all away and start over than to try and patch things up slowly by deprecating some calls and making core language improvements :)
19:30:21 <Cale> bd_: I wonder what the corresponding calls look like in .NET ;)
19:30:29 <ddarius> Why would you call FreeEnvironmentStrings and then use the memory?
19:30:51 <Cale> ddarius: hm?
19:30:58 <bd_> Cale: mmm, unfortunately windows' commercial success depends on supporting legacy code
19:31:24 <bd_> ddarius: because it worked fine in NT4! and therefore you never noticed that routine X stored that pointer you passed it
19:31:49 <SamB_XP> than why can't Win64 run simtower?
19:31:56 <pejo> bd, just like Intel and AMD.
19:32:08 <ddarius> bd_: That's just a bug.  I'm talking about intentionally doing this.
19:32:10 <Cale> bd_: Right. On the other hand, I'm continually impressed at how well wine works these days, and it doesn't even have the benefit of being able to look at MS's code. :)
19:32:25 <SamB_XP> ddarius: um, what makes you think MS doesn't support bugs ?
19:32:30 <Saizan_> hah, when regions become widespread withFile-like functions will look like hazardly dangerous things
19:32:31 <bd_> Cale: http://msdn.microsoft.com/en-us/library/1h5xxewc.aspx is the .NET version, incidentally
19:32:32 <lambdabot> Title: Environment.GetEnvironmentVariables Method (System)
19:32:46 <SamB_XP> Saizan_: what ?
19:32:48 <ddarius> SamB_XP: That has nothing to do with what I said.
19:33:08 <Saizan_> ?type withFile
19:33:09 <lambdabot> Not in scope: `withFile'
19:33:13 <SamB_XP> ddarius: MS has a commitment to making even BUGGY code continue to work!
19:33:17 <SamB_XP> for some reason
19:33:26 <ddarius> SamB_XP: I'm not talking about MS's behaviour.
19:33:28 <SamB_XP> as long as it's sufficiently popular
19:33:29 <bd_> SamB_XP: because they have customers whose business depends on said buggy code
19:33:38 <bd_> if a new version of windows breaks the buggy code, the customers won't upgrade.
19:33:44 <Cale> bd_: Oh, good, and it appears there's no Free, because they're using garbage collection. :)
19:33:53 <SamB_XP> I always thought it was because they had customers who really hated it when their games stopped running
19:34:12 <ddarius> Cale: There's nothing particularly "CPS" about withFoo.
19:34:13 <bd_> Of course, this isn't microsoft's fault. But their customers don't know that. And their customers no longer have the consultant who wrote the code working for them; and may not have the source.
19:34:32 <bd_> But they keep using it. Because it works. On windows 3.1.
19:34:34 <SamB_XP> and it may have been written by a hardware vendor or something too
19:34:44 <bd_> And it had better work on every future version of windows too!
19:34:50 <Cale> ddarius: Well, you can view it as the withFoo function taking a local continuation as a parameter.
19:35:05 <SamB_XP> bd_: you do know that 3.1 apps don't work in 64-bit, right?
19:35:19 <bd_> SamB_XP: yeah, but they work on every version until there
19:35:20 <ddarius> Cale: Is every HOF taking a "local continuation"?
19:35:50 <SamB_XP> for no intelligable reason, considering they had 'em working on Alpha and so forth ...
19:35:54 <Cale> ddarius: In some sense, I suppose so. :)
19:36:00 <bd_> SamB_XP: nice, emulation?
19:36:01 <Olathe> Isn't there some kind of DOSboxy thing for running old Windows stuff ?
19:36:06 <SamB_XP> bd_: yes!
19:36:19 <SamB_XP> I have NO IDEA why they didn't just dust that off
19:36:21 <Olathe> Hmmm...I guess VMware or something would work.
19:36:24 <Saizan_> ddarius: the type nicely matches ContT IO in this case though :)
19:36:28 <Cale> ddarius: But with* functions are so naturally manipulated in the Cont monad, that it makes sense to think of them that way.
19:36:28 <bd_> SamB_XP: I guess they've finally decided to kill it?
19:36:42 <SamB_XP> bd_: I don't see how it saved them any work ...
19:36:44 <Cale> (or ContT over something, right.)
19:36:57 <bd_> SamB_XP: it takes work to 'dust off' that stuff :)
19:37:05 <SamB_XP> well, I mean, compared to all the explaining they have to do
19:37:10 <bd_> and to make sure it stays working, and to QA it, and to localize it, and etc...
19:37:18 <SamB_XP> localize what?
19:37:25 <bd_> SamB_XP: the configuration dialogs, if any
19:37:27 <bd_> and error messages
19:37:36 <bd_> and msdn documentation for it
19:37:43 <SamB_XP> um
19:37:55 <ddarius> What you're going to write callCC withFoo >> doStuff instead of withFoo doStuff?
19:37:57 <bd_> I mean, this is a full emulator now, I'm sure there are some user-visible strings lurking awway
19:38:05 <SamB_XP> hmm.
19:38:12 <bd_> but point is, yes, it's probably pretty close to release
19:38:17 <bd_> or well, pretty close to 'working'
19:38:20 <dibblego> I always forget about the widespread ignorance of what *really* happens inside corporate software development
19:38:27 <bd_> but they don't want to have to support 16-bit stuff forever, I guess
19:38:50 <bd_> besides, a third party can always write a emulator
19:39:28 <Saizan_> ddarius: more like do foos <- sequence [withFoo1,withFoo2]; ...
19:40:29 <Cale> ddarius: or something like  do x <- ContT (withFoo); doStuff x
19:40:47 <ddarius> This is "natural"?  I personally think describing withFoo as CPSy is obfuscatory and misleading.  It's just a HOF.
19:41:18 <Cale> ddarius: Suppose I want n things allocated with withFoo, provided to me in a list.
19:41:35 <ddarius> mapM withFoo list
19:41:58 <lispy> dibblego: which is?
19:42:15 <dibblego> like bd_ describes except a lot worse :)
19:42:28 <Cale> as in, withFoo :: (A -> IO B) -> IO B, and I have  doStuff :: [A] -> IO B, and I want doStuff to be passed a list of n values of type A
19:42:29 <shrughes> forM_ list . ((withFoo .) .)
19:42:44 <shrughes> ^^ not in response to your latest comment
19:43:00 <Cale> ddarius: Does that make sense? :)
19:43:17 <shrughes> Cale: still then, you can do a bunch of nested withFoos
19:43:39 <ddarius> You want withFoo $ \a -> withFoo $ \b -> doStuff [a,b] for an arbitrary deep nesting?
19:43:39 <Cale> shrughes: Yes, if n is not a variable, or you can write a handy little recursive function...
19:43:44 <Cale> ddarius: yes :)
19:43:55 <Cale> However, the monadic view makes things simpler.
19:44:02 <Cale> There's already a function which does this. :)
19:44:59 <shrughes> meh, it's not much of a win.  The real win would be getting my coworkers to accept WithFoo
19:45:04 <Cale> hehe
19:45:20 <shrughes> I've had to compromise with using blocks in some interesting ways
19:46:25 <Cale> :t \n -> runContT . replicateM n . ContT
19:46:26 <lambdabot> forall a (m :: * -> *) r. (Monad m) => Int -> ((a -> m r) -> m r) -> ([a] -> m r) -> m r
19:46:48 <Cale> So, modulo that wrapping/unwrapping, this is just replicateM.
19:47:25 <ddarius> Cale: I've never, ever seen someone do that and I don't see that particular case coming up and making a primitive withFoos is more idiomatic, more readable, and almost certainly more performant.  If you only had withFoo to work with then using that would be helpful, but it still isn't particularly CPSy.  It could be, but that is not what is communicated with 'with'.
19:48:09 <Cale> ddarius: I think of it as taking a continuation over which the resource that the function manages is allocated.
19:48:28 <Cale> But perhaps that's strange for lots of people :)
19:48:34 <shrughes> Cale: say that again?
19:49:06 <shrughes> "over" a continuation?
19:49:28 <Cale> That is, during the continuation's execution, the resource is made available.
19:50:53 <Cale> I suppose that the continuation style allows you to think of withFoo as if it were getFoo.
19:51:18 <ddarius> Cale: If what was passed was usually or intended to be "the rest of the program," I'd agree with you, but the idea is nested, block-like structure.  Note a foreach-like loop could have type: (A -> IO ()) -> IO () and again describing this as CPS-like is silly in my opinion.
19:51:20 <SamB_XP> Cale: so it has TWO continuations ?
19:51:54 <Cale> I'm not thinking of the *whole* program as being translated into CPS.
19:53:06 <Cale> SamB_XP: Well, it has the continuation up to the resource not being needed anymore, and then that returns, and there's a continuation through the rest of the program.
19:53:12 <Cale> So, at least two, yes.
19:53:25 <Cale> (as you have with any Cont/ContT monad computation)
19:55:23 <Cale> Is that nonsense?
19:55:33 <Cale> Or does it at least make some kind of sense.
19:55:56 <SamB_XP> I think it makes enough sense to get you committed
19:56:00 <Cale> Like, if you imagine the lifting of the with* style function to the ContT monad, (by just applying the ContT constructor)
19:56:10 * SamB_XP tries to figure out what repository to commit Cale to
19:56:25 <Cale> Then you get to use it in that monad as if it were get* instead.
19:57:06 <Cale> and it'll do the deallocation business somewhere at the end of the execution of the ContT action.
19:57:11 <ddarius> Cale: That's a good insight, but getFoo is significantly different from withFoo.
19:57:59 <Cale> ddarius: Well, in terms of not cleaning up after itself, sure.
19:58:47 <shrughes> okay it all makes sense
19:59:06 <Saizan_> here you can pretend that all the cleaning happens when you exit the ContT world
19:59:39 <ddarius> Cale: getFoo = ContT withFoo would be useful for when I wanted to work with some disparate set of things and not worry about allocation.  withFoo is when I want to specifically control the scope of allocation.
20:00:36 <Cale> ddarius: Of course, you control the scope of the allocation by the size of your ContT action, but yes.
20:01:20 <the_unmaker> is there any snmp monitor done in haskell?
20:01:54 <Cale> Everything you end up allocating in a ContT computation in that way, gets deallocated at the very end, and not somewhere before it... for that, you'd have to nest runContT calls.
20:02:02 <Cale> (which would be possibly too awkward)
20:02:46 <[R]ayneHaskell> Bah.
20:02:52 * [R]ayneHaskell Ghosts himself.
20:03:05 <ddarius> Cale: Which would be somewhat silly and suggest that you are going against the grain of that particular ContT usage (which is exactly the grain of usage with* supports).
20:04:07 <ddarius> Cale: It's like how, by using continuations, events and threads are dual but we don't usually say threads are CPSy events.
20:05:48 <Cale> ddarius: That's fair.
20:09:20 <Cale> the_unmaker: I don't know of any.
20:12:50 <lament> hey, where's ICFP? I can't find the address :(
20:14:31 <Olathe> http://www.icfpcontest.org/
20:14:32 <lambdabot> Title: ICFP Programming Contest 2008
20:15:24 <lament> no, the physical address of the ICFP conference...
20:15:39 <cjb> heh
20:15:47 <ddarius> OLathe knows not of this "physical world" you speak of.
20:16:17 <Olathe> http://www.icfpconference.org/icfp2008/local_info/travel.html
20:16:22 <lambdabot> Title: ICFP 2008 - Travel to Victoria, British Columbia
20:16:26 <Olathe> "The conference will be held at the Delta Victoria Ocean Pointe Resort and Spa located at 45 Songhees Road, Victoria, British Columbia, Canada.
20:16:49 <lament> true, thanks
20:16:56 <lament> i hope it's findable inside the hotel
20:17:54 <SamB_XP> lament: I'm sure the employees will be able to direct you in sneaking in to ICFP
20:18:00 <Olathe> Heheh.
20:18:17 <lament> nah, my boss is paying for me :D
20:18:26 <SamB_XP> oh
20:18:32 <lament> even though i do nothing related to FP...
20:18:44 <SamB_XP> wow sweet
20:19:02 <SamB_XP> so who was complaining about the registration closing a couple days early ?
20:19:34 <lament> me, iirc
20:19:56 <lament> but that was online registration
20:20:12 <SamB_XP> oh
20:20:16 <kyevan> offtopic: is the jabber.org xmpp server down for you, too?
20:20:22 <SamB_XP> lament: I thought it was you
20:20:30 <lament> yeah, i'm pretty sure it was me
20:20:30 <SamB_XP> I didn't realize it was possible to register offline
20:20:45 <lament> that's what the site says now: "Please register on-site"
20:20:48 <SamB_XP> so I was assuming you were going with the suggestion that was offered at that time
20:21:23 <lament> if i sneak in, and convince my boss to give me $230 in cash, that would be even better :)
20:21:26 <Olathe> Wait ?!
20:21:30 <Olathe> Isn't this the website ?
20:21:46 <lament> Olathe: yes...
20:22:06 <Olathe> It was a horrible joke.
20:22:22 <lament> yeah, pretty bad :)
20:23:17 * SamB_XP wonders why mcdonalds doesn't serve hotdogs
20:24:18 * ddarius would never buy a McDonald's hotdog, but then he almost never buys a McDonald's hamburger.
20:24:53 <SamB_XP> hey, I never said I thought they'd be worth buying
20:25:00 <SamB_XP> it just seems a bit odd that they don't sell them ;-)
20:25:08 <dolio> ddarius only buys the McRib.
20:25:15 <lament> maybe there was an antitrust suit!
20:25:32 <SamB_XP> all suits are antitrust
20:25:37 * ddarius should be having slow smoked ribs tomorrow.
20:25:46 <SamB_XP> probably because they are also backstabbing liars
20:25:49 <ddarius> SamB_XP: Mine's pinstriped.
20:26:12 <lament> mine used to be polka-dot but somebody cut out all the dots
20:26:14 <SamB_XP> ddarius: I thought slavery was illegal
20:26:22 <SamB_XP> lament: what?
20:26:27 <SamB_XP> you have a swiss coat?
20:26:30 <SamB_XP> er. suit
20:27:14 <lament> yes. It is made of moon rock.
20:27:26 <SamB_XP> what the ???
20:27:44 <pastorn_> this is the SECOND time today! either my brain isn't working now or i don't know what
20:27:56 <pastorn_> i would like to do some list recursion, to... say...
20:28:01 <Olathe> @yow
20:28:01 <lambdabot> Yow!  I want to mail a bronzed artichoke to Nicaragua!
20:28:09 <pastorn_> pair the sum of a list with the last value in the list
20:28:23 <ddarius> pastorn: Order a new brain.
20:28:30 <Olathe> let xs = (sum xs, last xs) ?
20:28:37 <Olathe> Or, with recursion...
20:28:40 <ddarius> Olathe: That certainly won't work.
20:28:51 <pastorn_> f (x:xs) = x + f xs
20:29:09 <Olathe> f lastOne sum listToGo
20:29:12 <Olathe> Maybe f'
20:29:26 <pastorn_> f [x] = 0 (somethingMagicalWith ,) x
20:29:29 <Olathe> f' previousItem sum xs =
20:29:47 <Olathe> f' previousItem sum [] =
20:30:11 <ddarius> Let's add an accumulating parameter and then ignore it
20:30:21 <ddarius> > foldl (flip const) (error "foo") [1..10]
20:30:22 <lambdabot>   10
20:30:31 <Olathe> f (x:xs) = f' x x xs
20:30:35 <pastorn_> it's impossible to do this with a stack of function applications, right?
20:30:36 <dmwit> > (sum &&& last) [1..10]
20:30:37 <lambdabot>   mueval: Prelude.read: no parse
20:30:44 <dmwit> pastorn_: No, of course not.
20:30:48 <dmwit> Why would you think that?
20:30:53 <pastorn_> syntax
20:30:59 <pastorn_> f (x:xs) = x + f xs
20:31:03 <pastorn_> f [x] = 0 (somethingMagicalWith , x
20:31:07 <dmwit> You're already wrong.
20:31:15 <dmwit> f (x:xs) /= x + f xs
20:31:17 <pastorn_> f [x] = 0 `(,)` x
20:31:36 <pastorn_> though that MIGHT work
20:31:39 <pastorn_> hmmm...
20:31:46 <Saizan_> the syntax for a tuple is (0,x)
20:32:07 <dolio> `(`(`(,)`)`)`
20:32:17 <Olathe> zomg
20:32:18 <Saizan_> but your first case is wrong, because it's trying to sum a number and a tuple
20:32:19 <pastorn_> Saizan_: i know, but i want a stack of function applications to be applied to the left value
20:32:30 <Olathe> You want a what ?
20:33:07 <Saizan_> pastorn_: just pattern match on the recursive call, extract the left value, and build a new tuple
20:33:24 <Saizan_> this is going to use O(n) stack
20:33:40 <pastorn_> Saizan_: yeah, i know
20:34:30 <Olathe> Do it without the stack of evilness.
20:35:03 <pastorn_> f [x] = let g a b = (a,b) in 0 `g` x
20:35:03 <pastorn_> f (x:xs) = x + f xs
20:35:10 <pastorn_> infinite type complaint
20:35:27 <Olathe> pastorn: You don't really need g.
20:35:34 <dmwit> Your (x:xs) case is still wrong, for the same reason it was wrong before.
20:35:49 <dmwit> And, yeah, g is kind of pointless there.
20:35:54 <Saizan_> pastorn_: i was talking about the (x:xs) case
20:36:15 <pastorn_> what's wrong with it?
20:36:15 <dmwit> pastorn_: What is the type of f?
20:36:34 <pastorn_> Num a => [a] -> (a,a)
20:36:37 <dmwit> pastorn_: Now, think about what that means on the RHS of the (x:xs) case.  (f xs) has what type?
20:37:15 <pastorn_> dmwit: "RHS"?
20:37:19 <dmwit> right-hand side
20:37:35 <dmwit> respectively, LHS =)
20:37:47 <Olathe> MHS
20:37:56 <pastorn_> oh, f xs :: (a,a)
20:38:01 <dmwit> exactly
20:38:02 <pastorn_> well, at least in the end it will
20:38:05 <Olathe> What is the type of x ?
20:38:07 * ddarius wonders how this PDF was made to be 6MB.
20:38:08 <pastorn_> a
20:38:18 <dmwit> pastorn_: So, do you know how to fix it now?
20:38:23 <pastorn_> no
20:38:31 <Saizan_> ok, so you can't sum an 'a' and a '(a,a)'
20:38:32 <dmwit> Pattern match on (f xs), as Saizan_ suggested.
20:38:33 <pastorn_> because i want a pair in the en
20:39:01 <Saizan_> and so?
20:39:06 <Olathe> pastorn: What is 3 + (5, 6) ?
20:39:15 <pastorn_> Olathe: syntax error
20:39:19 <dmwit> Olathe: I'm pretty sure we're past that particular misconception by now.
20:39:27 <SamB_XP> ddarius: oh, it was padded out with unreferenced porno
20:39:45 <Olathe> pastorn: Well, it's fine syntax.
20:39:50 <Saizan_> pastorn_: can you write a function that substitutes the first element of a tuple with something else?
20:39:52 <roconnor> > fmap (3+) (5,6)
20:39:54 <lambdabot>   (5,9)
20:40:00 * SamB_XP makes up a silly, but possible, explanation
20:40:22 <pastorn_> i don't think i will get it... could i please get the correct definition?
20:40:25 <Olathe> SamB_XP: PlagiarismError
20:40:34 <SamB_XP> Olathe: what ?
20:40:36 <pastorn_> i will probably understand a lot better when i see it
20:40:40 <SamB_XP> I didn't plaigerize it
20:40:43 <ddarius> SamB_XP: That would make more sense than the reality probably does.
20:40:50 <Olathe> SamB_XP: You have to reference the porno or else you've plagiarized it.
20:40:54 <SamB_XP> ddarius: sadly yes
20:41:00 <SamB_XP> Olathe: *groan*
20:41:03 <Olathe> ;)
20:41:08 <Saizan_> pastorn_: f (x:xs) = let (s,l) = f xs in (x+s,l)
20:41:20 <SamB_XP> Olathe: what I meant was ... image objects in the PDF that were not actually used in any of the pages
20:41:35 <Olathe> Ahh
20:41:50 <pastorn_> oh, riiiight...
20:41:52 <pastorn_> that
20:42:06 <SamB_XP> as I said -- doable but unlikely
20:42:34 <pastorn_> Saizan_: thanks :D
20:42:37 <newsham> ?src (,) fmap
20:42:37 <lambdabot> fmap f (x,y) = (x, f y)
20:42:54 <Olathe> @src (->)
20:42:54 <lambdabot> Source not found. Are you on drugs?
20:43:01 <Saizan_> @src (->) first
20:43:01 <lambdabot> first f = f *** id
20:43:30 <dmwit> ?src (->) (&&&)
20:43:31 <lambdabot> Source not found. You speak an infinite deal of nothing
20:43:36 <dmwit> ?src (&&&)
20:43:36 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
20:43:39 <pastorn_> Saizan_: i was thinking from the start of the list, i should've been thinking from the bottom...
20:43:56 <pastorn_> :)
20:44:23 <dmwit> pastorn_: But, you shouldn't bother writing the explicit recursion for anything but language practice.
20:44:27 <Saizan_> pastorn_: you should focus less on the order of evaluation and more on what things represent
20:44:28 <dmwit> Here's an alternative implementation:
20:44:35 <ddarius> pastorn: You shouldn't be thinking from the bottom, top, left, or right.  You should be thinking about the cases.
20:44:36 <dmwit> sumAndLast xs = (sum xs, last xs)
20:45:12 <pastorn_> dmwit: nah, that traverses the list two times
20:45:16 <pastorn_> can't have that :p
20:45:21 <SamB_XP> (_|_)s up
20:45:36 * SamB_XP can't get over that pun
20:45:37 <dmwit> pastorn_: sufficiently smart compiler, premature optimization, etc., etc.
20:46:09 <pastorn_> dmwit: well, i have to leart to optimize _somehow_ won't i?
20:46:13 <newsham> it would be cool if the bot could expand out definitions, like "?expand (sum &&& last)" could somehow give you "\xs -> (sum xs, last xs)", or further expand sum and last.
20:46:16 <dmwit> SamB_XP: It's a pretty good one, especially since (_|_) kind of looks like a bottom. =)
20:46:22 <ddarius> pastorn: The code you want to write would build up as many stack frames as list elements and then would unwind them, so you end up traversing the list twice as well.
20:46:28 <pastorn_> hence making shitloads of mistakes on the way
20:46:28 <SamB_XP> dmwit: that's what I meant about it being a pun
20:46:33 <dmwit> pastorn_: The first step in learning to optimize is learning to profile.
20:46:42 <Olathe> > foldr (\x (s, _) -> (s + x, x)) (0, 0) [1..100]
20:46:43 <lambdabot>   (5050,1)
20:46:45 <ddarius> newsham: When should it stop?
20:46:49 <Olathe> That didn't quite work.
20:46:56 <newsham> the first step in learning to optimize is picking the right optimization function
20:47:01 <SamB_XP> it looks a bit like a butt, AND it is a parenthesized form of the asciization of bottom
20:47:08 <Olathe> > foldl (\(s, _) x -> (s + x, x)) (0, 0) [1..100]
20:47:09 <lambdabot>   (5050,100)
20:47:15 <newsham> ddarius: after 1 step, unless directed by the user otherwise?
20:47:21 <newsham> *shrug*
20:47:30 <newsham> obviously lots of room for exploration of that question
20:47:30 <pastorn_> dmwit: that's probably true
20:47:41 <Olathe> > foldl (\(s, _) x -> (s + x, x)) (0, undefined) [1..100]
20:47:43 <lambdabot>   (5050,100)
20:47:56 <pastorn_> actually i managed to hook the ghc profiler up to a binary for the first time yesterday :)
20:48:08 <Saizan_> > foldl (\(s, _) x -> (s + x, x)) (0, undefined) [1..10000000]
20:48:10 <SamB_XP> pastorn: it's ALIIIIVE!
20:48:19 <lambdabot>   mueval: Prelude.read: no parse
20:48:28 <pastorn_> Olathe: nice
20:48:31 <dolio> Woo, stack overflow.
20:48:33 <ddarius> @quote ghc
20:48:34 <lambdabot> ghc says:  This is very gruesome indeed
20:49:04 <newsham> s/optimization function/objective function/
20:49:45 <Olathe> @bot
20:50:04 <lambdabot> :)
20:52:10 <the_unmaker> grue
20:52:15 <the_unmaker> so heh
20:52:25 <the_unmaker> making apps work among 100 boxes is tuff eh
20:52:27 <newsham> does lambdabot's eval not allow control.arrow.***?
20:52:37 <the_unmaker> i guess there is always load balancing
20:52:51 <dmwit> newsham: Yeah, Control.Arrow seems to be missing.
20:53:07 <newsham> how come it knows the types fromcontrol arrow but wont let you eval it?
20:53:13 <newsham> > (+1) *** (+2)
20:53:15 <lambdabot>       Overlapping instances for Show ((b, b') -> (b, b'))
20:53:15 <lambdabot>        arising from...
20:53:19 <shapr> the_unmaker: Have you considered writing an snmp monitor in Haskell? It wouldn't be difficult.
20:53:20 <newsham> > ((+1) *** (+2)) (1,1)
20:53:22 <dmwit> It turns out that :t and > are not the same plugin.
20:53:25 <lambdabot>   mueval: Prelude.read: no parse
20:53:26 <dmwit> (Maybe?)
20:53:31 <newsham> thats not :t
20:53:44 <dmwit> Oh, right.
20:53:49 <Olathe> > foldb (\(a, _) (b, x) -> (a + b, x)) (0, undefined) $ map (\a -> (a, a)) [1..1000000]
20:53:53 <lambdabot>   (500000500000,1000000)
20:54:18 <dmwit> I like foldb.
20:54:25 <dmwit> I use it every once in a while.
20:54:29 <newsham> ?src foldb
20:54:30 <lambdabot> Source not found. Sorry.
20:54:45 <dmwit> I wrote it based on some ideas from Oleg.
20:54:52 <dmwit> No type hackery, just the algorithm, though. =)
20:55:33 <Olathe> Interesting.
20:55:34 <dmwit> http://hpaste.org/10687
20:55:38 <Olathe> Cale wrote it, too.
20:55:39 <Olathe> http://hpaste.org/1893
20:56:03 <dmwit> Mmm, then his implementation is probably better than mine. =)
20:56:46 <dmwit> Oh, his has a different type.
20:57:14 <dmwit> I wonder why he uses g at all.
20:57:16 <Olathe> http://hpaste.org/10688
20:57:20 <Olathe> That's mine.
20:57:40 <dmwit> It seems like foldbCale f g z xs = g . foldbDmwit f z xs
20:57:56 <dmwit> His implementation is better, but his type is worse. =)
20:58:11 <Olathe> @type foldb
20:58:13 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
20:58:17 <Olathe> Let's see.
20:58:19 <dmwit> err... s/g ./g $/, of course
20:59:22 <newsham> wouldnt foldb make more sense on a tree?
20:59:34 <dmwit> newsham: It is exactly a tree fold on a list.
20:59:36 <Olathe> @let foldbDmwit op def xs = foldb1 op (def:xs) where foldb1 op = head . foldb'; pairwise (x:y:rest) = op x y : pairwise rest; pairwise shortList = shortList; foldb' xs@(x:y:rest) = foldb' (pairwise xs); foldb' shortList = shortList
20:59:38 <lambdabot>  Defined.
20:59:45 <Olathe> @type foldbDmwit
20:59:46 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
20:59:46 <newsham> so why do it on a list?
20:59:57 <dmwit> newsham: Because lists are pretty convenient to construct.
21:00:22 <dmwit> newsham: For example, foldb (*) 1 [1..n] is way faster and more convenient than just about any other multiplication order.
21:00:43 <Olathe> @let foldbCale f g z [] = z; foldbCale f g z [x] = g x; foldbCale f g z xs@(_:_:_) = foldbCale f g z (combinePairs xs) where combinePairs [] = []; combinePairs [x] = [x]; combinePairs (x:y:xs) = f x y : combinePairs xs
21:00:44 <newsham> let (a,b) = splitAt (length xs `div` 2) xs in zipWith f a b
21:00:46 <lambdabot>  Defined.
21:00:50 <Olathe> @type foldbCale
21:00:51 <lambdabot> forall a t. (a -> a -> a) -> (a -> t) -> t -> [a] -> t
21:00:54 <Olathe> Ehh ?
21:01:10 <newsham> why pair adjacent elements whe you can pair elements half a list away? :)
21:01:16 <dmwit> Olathe: I told you already the relationship between the foldb you know and the foldb Cale wrote.
21:01:32 <dmwit> newsham: Because elements half a list away aren't the same size, for example?
21:01:38 <int-e> newsham: so it works for associative operators which aren't commutative
21:01:50 <dmwit> There's a few reasons, yeah.
21:02:10 <newsham> i dont see what it has to do with associativity or commutivity
21:02:19 <dmwit> Worse, your version will take O(n log n) time just calculating length! =)
21:02:26 <Olathe> Well, if you multiply neighbors, commutativity is irrelevant.
21:02:37 <Olathe> If you multiply things halfway across a list, commutativity is required.
21:02:41 <int-e> (my favourite foldb has type (a -> a -> a) -> [a] -> a and doesn't work on empty lists)
21:02:43 <dmwit> newsham: If your operator isn't commutative, then (a * b * c * d) is different from (a * c * b * d).
21:02:52 <newsham> you're assuming a single mapping from trees to lists
21:03:02 <dmwit> That's true.
21:06:21 <pastorn_> i need to sleep now
21:06:29 <pastorn_> see ya laterz
21:06:37 <[R]ayne> Bai.
21:06:45 <Olathe> An excellent idea.
21:07:06 <Olathe> 11 PM is a poison that sneaks up on you and then kills you tomorrow.
21:08:13 <[R]ayne> 11 pm is usually just waking up for me.
21:08:19 <dmwit> ?remember Olathe 11 PM is a poison that sneaks up on you and then kills you tomorrow.
21:08:20 <lambdabot> I will remember.
21:08:48 <[R]ayne> ?remember Haskell is a bitching language.
21:08:49 <lambdabot> I will never forget.
21:08:57 <dmwit> ?quote Haskell
21:08:58 <lambdabot> Haskell says: is a bitching language.
21:09:09 <dmwit> [R]ayne: Probably not exactly what you were intending. =P
21:09:14 <[R]ayne> LOL.
21:09:19 <[R]ayne> I failed.
21:09:22 <Olathe> @forget Haskell is a bitching language.
21:09:23 <lambdabot> Done.
21:09:28 <[R]ayne> Hmmm...
21:09:34 <Olathe> I will never...I mean...umm...forget ?
21:09:39 <dmwit> ?quote Haskell
21:09:40 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:09:43 <dmwit> boo
21:09:46 <dmwit> ?quote Haskell
21:09:46 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:09:55 <Olathe> @quote
21:09:55 <lambdabot> mikaeli says: My friend bought a new laptop; it had MSBLASTER preinstalled. I couldn't believe it either and installed XP and the apps many times, run virus killers and everytime the blaster came
21:09:55 <lambdabot> back. Everything was packed on a rescue cd. And virus was in m$ works installation files.
21:10:04 <[R]ayne> ?remember Haskell I'm a bitching language
21:10:04 <lambdabot> It is forever etched in my memory.
21:10:09 <[R]ayne> That will look cool LOL.
21:10:16 <dmwit> Oh, hey, I bet this is a great clue for that bug!
21:10:28 <dmwit> ?quote Haskell
21:10:29 <lambdabot> Haskell says: I'm a bitching language
21:10:30 <[R]ayne> Whoa, binrapt was in here.
21:10:41 <[R]ayne> He's an old friend. >_> I didn't know he was into haskell.
21:10:46 <[R]ayne> He used to be a C++ freak o.o
21:10:53 <dmwit> He still might be.
21:11:00 <Olathe> @seen binrapt
21:11:01 <lambdabot> I saw binrapt leaving #haskell 1m 36s ago, and .
21:11:39 <Pseudonym> A lot of people like both Haskell and C++/.
21:11:47 <Pseudonym> Indeed, C++ makes more sense once you know Haskell.
21:12:06 <[R]ayne> He actually said he was "switching to functional"
21:12:10 <Olathe> I'll have to try that.
21:12:39 <lament> i suppose, once you can handle Haskell, you can handle anything
21:12:40 * ddarius likes Haskell and C++
21:12:43 <lament> even C++ and Perl
21:12:58 * ddarius dislikes Perl quite a bit
21:13:00 <Olathe> Even unlambda.
21:13:14 <ddarius> Unlambda is easy.  Just tedious
21:13:23 <Olathe> I was looking over that yesterday.
21:17:47 <lament> Unlambda is like C#, then
21:40:06 <dancor> (>>=) is called "bind"; what is (>>) called
21:40:25 <Olathe> "Throw that thingy away !"
21:40:35 <Olathe> @src (>>)
21:40:35 <lambdabot> m >> k      = m >>= \_ -> k
21:42:05 <Olathe> > (>>"A")$"Hello, world !"
21:42:06 <lambdabot>   "AAAAAAAAAAAAAA"
21:42:23 <Olathe> Perhaps replace.
21:44:17 <flux> @src (>>)
21:44:17 <lambdabot> m >> k      = m >>= \_ -> k
21:44:37 <dmwit> dancor: Maybe some variation on "sequence"?
21:45:02 <Olathe> > (>>"A")$Nothing
21:45:03 <lambdabot>   Couldn't match expected type `[]' against inferred type `Maybe'
21:45:10 <Olathe> > (>>'A')$Nothing
21:45:11 <lambdabot>   Couldn't match expected type `m b' against inferred type `Char'
21:45:37 <Olathe> > (>>'A')$Just 'b'
21:45:38 <lambdabot>   Couldn't match expected type `m b' against inferred type `Char'
21:46:06 <Olathe> > (>>Just 5)$Just 'b'
21:46:07 <dmwit> > Just 'b' >> Just 'a'
21:46:08 <lambdabot>   Just 5
21:46:08 <lambdabot>  Terminated
21:46:15 <vinicius> vut
21:46:18 <dmwit> Terminated?
21:46:19 <dmwit> > Just 'b' >> Just 'a'
21:46:20 <lambdabot>   Just 'a'
21:46:23 <Olathe> > (>>(return 5))$Just 'b'
21:46:25 <lambdabot>   Just 5
21:46:33 <Olathe> > (>>(return 5))$"omg, hi !"
21:46:35 <lambdabot>   [5,5,5,5,5,5,5,5,5]
21:46:47 <Olathe> Weird.
21:46:57 <dmwit> Olathe: Why are you using that wacky (>>foo)$ form instead of just writing >> foo?
21:47:03 <Olathe> Oh.
21:47:15 <Olathe> > (++"!!!").(>>"A")$"Hello, world !"
21:47:17 <lambdabot>   "AAAAAAAAAAAAAA!!!"
21:47:46 <Olathe> I don't know.
21:48:10 <dmwit> > ("hey" >> "AA") ++ "!!"
21:48:11 <lambdabot>   "AAAAAA!!"
21:49:09 <Olathe> That's easier to decipher.
21:49:19 <Olathe> We're going for pointlessness.
21:49:48 <Olathe> And indecipherability.
21:50:09 <Olathe> http://uncyclopedia.org/wiki/AAAAAAAAA!
21:50:12 <lambdabot> Title: AAAAAAAAA! - Uncyclopedia, the content-free encyclopedia
21:53:18 <dancor> dmwit: mm
21:53:46 <dancor> how do i find the source for the Monad instance of Function (Const m)
21:53:58 <dmwit> eh?
21:54:00 <dmwit> Function?
21:54:07 <dancor> Functor (Const m)
21:54:12 <dmwit> Const?
21:54:46 <dmwit> I would look in the module that defines Const. ;-)
21:54:53 <dolio> newtype Const a b = Const a
21:55:02 <dancor> the instance is mentioned in http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
21:55:13 <dmwit> That can't have a very interesting Functor (or Monad) instance.
21:55:15 <lambdabot> Title: Control.Monad, http://tinyurl.com/y25qsm
21:55:41 <dmwit> instance Functor (Const m) where fmap f (Const x) = (Const x)
21:55:44 <dolio> Yeah. fmap _ (Const a) = Const a
21:56:08 <dolio> I'm not sure you can do Monad. return is a problem.
21:56:10 <dmwit> I doubt it can have any Monad instance at all.
21:56:12 <dmwit> right
21:56:19 <dmwit> great minds, etc.
21:56:23 <dancor> dmwit: Const is defined in Control.Applicative, but the instance doesn't seem to be in http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html
21:56:25 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5avvxt
21:56:37 <dmwit> ?src Applicative
21:56:38 <lambdabot> class Functor f => Applicative f where
21:56:38 <lambdabot>     pure  :: a -> f a
21:56:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:56:52 <dmwit> That's because it's *really hard* to write pure.
21:57:06 <dmwit> ?djinn-add type Const a b = a
21:57:21 <dmwit> ?djinn b -> Const a b
21:57:22 <lambdabot> -- f cannot be realized.
21:57:27 <dmwit> =)
21:57:35 <rwbarton> That page contains both instance Functor (Const m) and instance Monoid m => Applicative (Const m).
21:57:49 <dmwit> Ah, yes, that's possible.
21:57:56 <dmwit> pure x = Const mzero
21:58:05 <dmwit> Or mempty, or whatever Monoid's thing is.
21:59:00 <dmwit> Similarly uninteresting for (<*>): f <*> (Const x) = Const x
21:59:28 <dancor> rwbarton: ah, i was confused.
22:00:13 <solrize> @seen byorgey
22:00:13 <lambdabot> I saw byorgey leaving #haskell-blah, #xmonad and #haskell 6h 41m 42s ago, and .
22:01:18 <dolio> Well, if you're doing monoids, you could even do (Const x) <*> (Const y) = Const (x `mappend` y).
22:02:15 <dmwit> Sure.
22:02:30 <dmwit> It's really a pretty vapid instance, though.
22:02:31 <dolio> That's probably in the Idiom paper, actually.
22:03:04 <dolio> Or, one of those.
22:03:17 <dolio> Whichever has the 'crush' function in it.
22:05:21 <dolio> Section 4 "Monoids are phantom Applicative functors"
22:12:55 <dancor> what is a good example of a Functor that's not an Applicative
22:13:11 <dmwit> Array is my favorite Functor counter-example.
22:13:59 <dmwit> Const m (without the Monoid m constraint) is also an example, though it's not as good a one, I think.
22:23:57 <nanothief> what is a good library to use to access a sqlite3 database? I found HaskellDB and HDBC, although I found a few blog posts saying that they were difficult to install/unmaintained
22:27:52 <dmwit> dcoutts_: ping
22:28:48 <dons> dmwit: he's in the pub i think.
22:28:59 <dons> nanothief: hdbc
22:29:07 <dons> nanothief: though takusen/sqlite is also good
22:29:14 <dmwit> ?ask dcoutts Did anything ever come of the comment at the end of this page? http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/2/
22:29:15 <lambdabot> Consider it noted.
22:29:15 <dons> nanothief: you could also use the normal sqlite bindings
22:30:08 <nanothief> dons: ok, which would you recommend? I'm not that great with haskell, so nice docs/tutorials would be nice
22:30:42 <ivanm> dons: just wondering... with the mean blog post you did a while back, is there any reason why you defined the "go" function rather than using a fold?
22:30:56 <ivanm> (i.e. is there a performance difference between implicit and explicit recursion?)
22:34:54 <nanothief> dons: hdbc looks very nice. Thanks for the hint
22:36:43 <dons> nanothief: there's a chapter on hdbc in "real world haskell", online.
22:37:02 <dons> ivanm: i think the second post explains this.
22:37:03 * ivanm wondered how long it would take dons to spruke his book... :p
22:37:09 <dons> the difference is the pair state in the fold
22:37:19 <dmwit> spruke?
22:37:47 <dons> ivanm: its online, free. no better resource for hdbc... :/
22:39:05 <dons> i guess ivanm didn't really mean "spruiking", that has some negative connotations imo.
22:39:22 <dons> oh, is that aussie slang?
22:39:24 <quicksilver> dons: is there a recommended way to use curses from haskell?
22:39:27 <ivanm> how does spruiking have negative connotations?
22:39:32 <ivanm> and yes, I meant spruik
22:39:43 <dons> ivanm: that i'm trying to sell goods.
22:39:51 <ivanm> http://en.wiktionary.org/wiki/spruik
22:39:54 <dons> quicksilver: hmm. hscurses is big, but there's nothing i really like.
22:40:06 <nanothief> dons: wow that book is awesome
22:40:08 <quicksilver> dons: vty?
22:40:11 <ivanm> dons: well, you do want people to buy/use it in the sense you didn't want all that work wasted
22:40:13 <dons> oh vty is ok.
22:41:04 <dons> quicksilver: seems to work for yi.
22:41:15 <dons> quicksilver: i can't help but think there's a pretty printer library waiting to write.
22:41:20 <dons> that dumps to curses
22:41:33 <ivanm> dons: OK, found your second post now... for some reason, I don't recall seeing that one :s
22:41:48 <tseg> I want to say: "if Just(x)=m then .. else ..", in a long series of conditionals. Is there a better way than "case m of {Just(x)->..; otherwise->..}"?  This requires progressive indentation.
22:41:48 <ivanm> (though I've made major use of your optimised list mean function :p)
22:41:59 <dons> heh
22:42:07 <dons> ivanm: we should rewrite the hstats package to use fusion
22:42:12 <quicksilver> dons: I guess it's not an itch that many people have
22:42:18 <quicksilver> tseg: Yes, probably.
22:42:28 <quicksilver> tseg: the Maybe monad is for patterns like that
22:42:50 <ivanm> dons: well, I can't contact the maintainer :s
22:42:52 <quicksilver> tseg: at least, if every "Nothing" branch is the same, or most of them are.
22:43:07 <ivanm> dons: the email address bounces :(
22:43:27 <dons> for hstats?
22:43:38 <ivanm> yeah
22:43:40 <dons> he's online. i spoke to him last week.
22:43:44 <ivanm> :o
22:43:44 <dons> hmm. let' see.
22:44:07 <tseg> I sometimes use "let Just(result)=do {x<-m; ..} % do {..} % .. in result", but this feels klunky.
22:44:38 <dons> ivanm: mbeddoe ?
22:45:25 <quicksilver> tseg: well, for example "if Just(a) = n then (if Just (b) = m then Just (a+b) else Nothing) else Nothing
22:45:46 <quicksilver> tseg: is written as do a <- n; b <-m; return a+b;
22:45:53 <quicksilver> or, inded, liftM2 (+) n m
22:45:55 <tseg> What would be nice is: "if just(x)=m && just(y)==n && .. then ..use(x,y).. else ..", and bind variables within a conditional, without the monad. Monads are nice until you need to use more than one simultaneously, and then it's combinator hell...
22:47:00 <dibblego> tseg, actually quite the contrary, you want <*>
22:47:06 <tseg> quicksilver, "if Just(a)=n then .. else .." gives me a syntax error. Is there an extension for that?
22:47:08 <RayNbow> it's busy in #haskell in the early morning :p
22:47:33 <quicksilver> fromMaybe (else part) (do x <- m; y <- n; return (use x and y))
22:47:52 <tseg> I'm not nearly smart enough to understand "liftM2 (+) n m", and even if I were, readers of my code wouldn't be. :-)
22:47:54 <quicksilver> tseg: I meant (==). I unconciously copied your error ;)
22:48:52 <RayNbow> > let add = liftM2 (+) in       Just 3 `add` Just 5
22:48:53 <lambdabot>   Just 8
22:49:11 <quicksilver> tseg: you can't have it both ways.
22:49:25 <quicksilver> tseg: you can't be smart enough to dislike nested ifs, and not smart enough to think about liftM2
22:49:29 <dibblego> do n' <- n; m' <- m; return (n' + m')
22:49:33 <quicksilver> liftM2 *is* the answer to nested ifs.
22:49:36 <quicksilver> (well, one of them)
22:50:17 <quicksilver> it might be easier to work iwth an actual, concrete fragment of code.
22:50:25 <quicksilver> which is why I tried to give my a+b example.
22:50:41 <tseg> ?src liftM2
22:50:41 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:51:35 <quicksilver> the monad and monadplus instances of Maybe are the general solution to complex patterns of if statements for Just x.
22:51:51 <quicksilver> the monad instance takes the view "as soon as we get a Nothing, we give up"
22:51:57 <quicksilver> a bit like exception handling
22:52:09 <quicksilver> the monadplus instance allows you to say "if we got a Nothing here, try something else"
22:52:13 <quicksilver> like 'catch'.
22:52:36 <quicksilver> combining the two you can do arbitrarily complex patterns
22:53:03 <tseg> I understand. I just like to avoid the point-free programming style. I find comprehension-like constructs so much easier to read and understand than the corresponding higher-order function invocations.
22:53:33 <dibblego> you should address that failure
22:53:39 <quicksilver> well do notaiton is a comprehension like structure.
22:53:50 <quicksilver> do notation is the pointful version.
22:53:56 <ivanm> dons: yup
22:54:21 <RayNbow> > let infixl 1 «, »; («) = flip ($); (») = ($) in     Just 3 «liftM2(+)» Just 5  -- I'm still digging EvilTerran's hack <3
22:54:23 <lambdabot>   Just 8
22:54:44 <quicksilver> (list comprehensions are just do notation for the list monad, with a slightly quirky syntax)
22:54:48 <dibblego> > let f n m = (+) <$> n <*> m in Just 3 `f` Just 8
22:54:50 <lambdabot>   Just 11
22:55:50 <RayNbow> dibblego: but backticks don't give me the same beautiful symmetry ;)
22:56:13 <tseg> quicksilver, thanks for the tips!
22:56:52 <quicksilver> not at all.
22:57:06 <quicksilver> it's easier to demonstrate with real code than abstract questions, though :)
22:58:13 <quicksilver> tseg: demonstrate with real code than abstract  questions, thoug
22:58:16 <quicksilver> sry
22:58:22 <quicksilver> tseg: http://hpaste.org/10689
22:58:33 <quicksilver> tseg: that's a longer example of maybe monad use from one of my programs.
23:02:24 <dancor> what's a good Arrow that's not a Functor
23:03:59 <quicksilver> dancor: all arrows will be functors
23:05:13 <quicksilver> dancor: you can build 'fmap' out of 'pure' and (>>>)
23:05:14 <tseg> ?src $
23:05:14 <lambdabot> f $ x = f x
23:05:14 <quicksilver> tseg: the $ after return is just to save a pair of ( .. ) aronud that whole gs expression.
23:06:00 <dancor> oh duh yeah (>>>) is like (<*>)
23:06:45 <dancor> but there's no Applicative instance of Arrow
23:06:45 <dancor> i guess no one cared
23:06:56 <dolio> @src WrappedArrow
23:06:57 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:07:27 <tseg> thanks for the example. writing a game in haskell, wow.
23:08:37 <dolio> WrappedArrow is the Applicative instance for arrows.
23:08:39 <RayNbow> @pl amap f = (pure f >>>)
23:08:39 <lambdabot> amap = (>>>) . pure
23:08:42 <dolio> I don't know why they did it that way.
23:10:01 <dancor> yeah they're nuts
23:11:03 <dancor> maybe they were afraid you would want PersonalArrow to be an Applicative in a different way?
23:11:23 <dancor> but it could be with newtype or whatevs right   hmm
23:11:48 <dolio> Well, if (->) r is defined as an applicative directly, it'd overlaps.
23:12:11 <dolio> Technically '(Arrow a) => Applicative (a b)' isn't a valid Haskell 98 header, either.
23:12:24 <dolio> Maybe that's why.
23:12:53 <dolio> Or instance head. Whatever they're called.
23:13:15 <dancor> is there anything else i should know about in Monad > Arrow > Applicative > Functor
23:13:34 <dancor> like NewSuperMonad or NewSubArrowSupApplicative
23:13:52 <dolio> I'm not sure Arrow is appropriate in there.
23:14:06 <dancor> it's not cool enough?
23:14:15 <dolio> It's different.
23:14:34 <dolio> Different kind, at least.
23:14:46 <dancor> are there other X with Monad > X > Applicative
23:15:13 <dolio> You can also stick stuff in there. Monad > Applicative > Pointed > Functor.
23:15:24 <dolio> Where Pointed has pure/return.
23:16:19 <tseg> @src Applicative
23:16:19 <lambdabot> class Functor f => Applicative f where
23:16:19 <lambdabot>     pure  :: a -> f a
23:16:19 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
23:16:24 <tseg> @src Pointed
23:16:25 <lambdabot> Source not found. :(
23:16:35 <dolio> Pointed is in category-extras.
23:16:42 * _zenon_ hopes the wifi won't be interesting today.....
23:17:10 <dolio> I'm not sure I can name any pointed functors that aren't applicative, off the top of my head.
23:17:33 <tseg> @src Category.Extras.Applicative
23:17:33 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:17:42 <tseg> haha nevermind
23:19:16 <dolio> And then you have Comonad > ??? > Copointed > Functor
23:22:27 <rwbarton> I suspect ??? may be  f (Either a b) -> Either (f a) (f b)
23:23:04 <dolio> Huh, interesting.
23:24:06 <rwbarton> That's kind of a guess.  Can it be derived from a comonad?
23:24:20 <dolio> I don't know. Let me try.
23:26:48 <dolio> That kind of looks like costrength, actually...
23:26:51 <tseg> @src Category-Extras.Applicative
23:26:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:26:56 <tseg> @src CategoryExtras.Applicative
23:26:56 <lambdabot> Source not found. My pet ferret can type better than you!
23:26:58 <rwbarton> (I took one of the definitions of Applicative and applied it to the category Hask^op.  But Hask^op is not a CCC, so I don't know how sensible an operation that is)
23:27:31 <rwbarton> Yeah, it should.
23:28:00 <rwbarton> Because Applicative = f x -> f y -> f (x, y), while strength = x -> f y -> f (x, y) (and is free in Haskell)
23:28:15 <dolio> Yeah.
23:28:20 <dolio> But costrength isn't.
23:28:24 <rwbarton> Right.
23:33:17 <dolio> That's actually exactly the type of bi-traverse, too, if there is such a thing.
23:33:19 <quicksilver> dancor: Monad and Arrow are more like parallel alternatives.
23:33:43 <quicksilver> dancor: in that they both treat effects but they are incomparable
23:33:50 <quicksilver> (after all, one has one parameter and one has two)
23:34:27 <dolio> Or, bi-sequence.
23:38:56 <dolio> I guess it'd be costrong colax comonoidal functors. :)
23:39:13 <dolio> If colax means anything. I don't know what lax means.
23:39:30 <rwbarton> People usually say oplax for some reason.
23:39:37 <dolio> Huh.
23:39:56 <rwbarton> oplax monoidal functor = functor F with a structure map F(X x Y) -> FX x FY, where x is the monoidal structure
23:40:42 <rwbarton> If x is just the product, every functor is oplax monoidal.
23:41:40 <rwbarton> (lax monoidal functor means the structure map goes the other way, strong monoidal means the structure map is an isomorphism.)
23:42:05 <_zenon_> is this cat-theory talk?
23:42:45 <rwbarton> Yes
23:43:35 <_zenon_> yeah, I figured.
23:47:38 <ivanm> rwbarton: theory of cats? you talking only about household-cats or the entire feline family?
23:47:39 <ivanm> ;-)
23:53:27 <rwbarton> dolio: So here's an interesting point about Copointed.
23:53:49 <rwbarton> When f is a functor, giving  pure :: forall a. a -> f a  is the same as giving  pure' :: () -> f ()  (i.e. pure'' :: f ())
23:54:33 <rwbarton> Giving  copure :: forall a. f a -> a  is almost the same as giving  copure' :: f Void -> Void , but not quite
23:55:07 <rwbarton> If I have  copure' :: f Void -> Void  and  x :: f a  I can only construct  (a -> Void) -> Void
23:55:10 <dolio> Hmm. How do you recover copure?
23:55:29 <rwbarton> which is not quite  a
23:55:41 <dolio> Ah, yeah.
23:56:27 <dolio> Interesting.
23:58:22 <rwbarton> It makes me think the Either thing is not totally wrong (because Either Void b = b) but also that there will be pitfalls in this area...
