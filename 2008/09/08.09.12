00:00:30 <sicp> if' True t e = t ; if' False t e = e , ok but then how to implemnt t and e?
00:00:59 <sicp> t e is then else right? or expresssions?
00:01:35 <shrughes> sicp, it's hard to understand what you're asking
00:02:31 <luqui> > let { metas = "\\&|"; escape = concatMap (\c -> if c `elem` metas then '\\':c:[] else [c]) } in escape "Do you like \\escaping | shells"
00:02:33 <lambdabot>   "Do you like \\\\escaping \\| shells"
00:03:03 <dancor> sicp: if you put that in some a.hs file (with a dummy   main = print 4) and do   ~ ghci a.hs    and then    :t if'    it will say    if' :: Bool -> t -> t -> t
00:03:15 <dancor> sicp: does that clear anything up?
00:03:43 <luqui> sicp, t and e are arguments .  so you say, like, if' True "foo" "bar", you will get "foo"
00:04:13 <luqui> dancor, why the dummy main?
00:04:14 <Beelsebob> sicp:
00:04:15 <Beelsebob> > let if' True t e = t; if' False t e = e in if' (5 > 6) "Five is less than six" "Five is better than sex"
00:04:16 <lambdabot>   "Five is better than sex"
00:04:21 <shrughes> > if' True "foo" (last (repeat "bar"))
00:04:23 <lambdabot>   mueval: Prelude.read: no parse
00:04:35 <dancor> luqui: oh, i compiled it first, not needed if you don't do that i guess
00:06:18 <sicp> now i see thanks
00:06:33 <sicp> ty very much
00:06:42 <sicp> a little bit wiser every day
00:07:03 <sicp> i really like haskell, scala seems like the more practical alternative for now though
00:07:33 <trzkril> ah, da sind die ganzen spaces hin, tz.
00:10:47 <sicp> ja dass deutsche liebe kann man nicht vergessen!
00:11:06 <sicp> sorry just some random german from me there
00:11:15 <dmwit> > expr "\xaf\x82" :: Expr
00:11:16 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
00:11:21 <dmwit> > fun "\xaf\x82" :: Expr
00:11:22 <lambdabot>   ï¿½ï¿½
00:11:43 <dmwit> > fun "\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00" :: Expr
00:11:45 <lambdabot>   ï¿½ï¿½ï¿½ï¿½
00:11:48 <dmwit> huh
00:13:22 <dmwit> Oh, hey, I can get \bot to spew NULLs at irc.freenode.net.
00:13:28 <dmwit> I wonder if that's bad.
00:13:51 <dmwit> > fun "before\x00\&after" :: Expr
00:13:52 <lambdabot>   beforeafter
00:13:58 <dmwit> I guess not. =P
00:19:39 <sjanssen> dmwit: I think the bot scrubs output
00:19:46 <sjanssen> I'm not entirely sure, though
00:25:27 <cads> I shall as a stupid question
00:25:41 <mmorrow> dmwit: did you mean this?
00:25:45 <mmorrow> > fun "\207\130\r\NUL\NUL\SOH\SOH\STX\STX\NUL" :: Expr
00:25:47 <lambdabot>   Ï‚
00:26:43 <dmwit> mmorrow: Turns out it was a bz2-compressed string.
00:26:43 <cads> ï»¿Is it possible to define f such that f = c_0, where c_0 is a constant, but also such that f(x) = g(x) where g is some normal algebraic function on x? Or is this totally nonsensical?
00:26:48 <mmorrow> ah
00:26:51 <mmorrow> haha
00:27:14 <mmorrow> i did (encode . decode) for utf8 and i guess it was that symbol by blind chance
00:27:17 <dmwit> cads: Yes, it is possible, by the power of type-classes!
00:27:30 <mmorrow> err, that's a greek sigma i believe
00:27:42 <mmorrow> i must have discarded the garbage actually
00:27:43 <cads> really?
00:27:46 <dmwit> > fun "a\rb" :: Expr
00:27:48 <lambdabot>   ab
00:28:05 <mmorrow> my encode/decode discard garbage as well
00:28:12 <dmwit> cads: really
00:28:40 <cads> it seems like the class of f would be undefined if only simple types could be used; how would we define it with type classes?
00:29:00 <dmwit> f :: WeirdClass a => a
00:29:14 <dmwit> Like so:
00:29:21 <dmwit> class WeirdClass a where f :: a
00:29:30 <dmwit> instance WeirdClass Int where f = 0
00:29:45 <dmwit> instance Num a => WeirdClass a where f x = 2 * x
00:29:53 <dmwit> oops
00:30:03 <dmwit> instance Num a => WeirdClass (a -> a) where f x = 2 * x
00:30:23 * dmwit goes to test it
00:32:04 <dmwit> It needs either a newtype wrapper or FlexibleInstances, but otherwise it shouldn't be a problem.
00:33:28 <cads> I will try to understand that
00:34:24 <dmwit> What bit don't you understand?
00:34:55 <dmwit> I'm leaving, but you should still ask, somebody else is sure to answer. =)
00:35:10 <cads> how to feed the code into ghci
00:35:20 <cads> I'll get it, thanks for the help :)
00:35:32 <lightstep> you need to paste it into a file and load it (with :l)
00:43:11 <dancor> cads: this is what i was able to get working from dmwit's comments: http://hpaste.org/10300
00:48:43 <Cale> dancor: Note that inside a class declaration, you can leave off the contexts which specify that the variable is of that typeclass...
00:48:56 <Cale> So it's enough to write   class WeirdClass a where f :: a
00:58:35 <lightstep> does the haskell' committee give rationale for its decisions? i didn't find any link for it in the status page or in the proposal tickets
00:59:03 <cads> dancor, I thank you for the code
00:59:19 <FalconNL> Hi everyone, I have a small question of about Parsec. When you try to parse an incomplete string you will get an error saying something like "unexpected end on input, expecting ...". Is there any way of getting a similar message when the parser does succeed? Let's use the following parser as an example: char 'a' >> option 'x' (char 'b' <|> char 'c'). If I parse an empty string I get "......
00:59:21 <FalconNL> ...expecting 'a'". If I parse "a" the parser succeeds and returns 'x'. What I need is something like "parser succeeded. expecting 'b' or 'c'". Does anyone happen to know if there's any way to get this information? I need it to provide something like Intellisense for a grammar I'm working on.
00:59:58 <quicksilver> lightstep: typically there is discussion.
01:00:08 <quicksilver> lightstep: not for every single decision, though.
01:00:14 <quicksilver> lightstep: which decision were you interested it?
01:00:25 <lightstep> magic underscore
01:01:07 <BeelsebobWork> magic?
01:01:15 <BeelsebobWork> what's the magic underscore?
01:01:19 <lightstep> http://hackage.haskell.org/trac/haskell-prime/wiki/MagicUnderscore
01:01:32 <lambdabot> Title: MagicUnderscore - Haskell Prime - Trac, http://tinyurl.com/3f7hh6
01:01:55 <BeelsebobWork> that's nothing to do with Haskell'
01:01:58 <BeelsebobWork> it's to do with jhc
01:02:15 <quicksilver> BeelsebobWork: it's a haskell prime proposal.
01:02:20 <BeelsebobWork> oh, is it?
01:02:21 <sjanssen> BeelsebobWork: it's a proposal for GHC
01:02:25 <quicksilver> BeelsebobWork: that's why that page is in the haskell prime wiki :P
01:02:25 <sjanssen> s/GHC/Haskell'
01:02:32 <BeelsebobWork> ah, I see
01:02:34 <sjanssen> though the two are almost equivalent :)
01:02:45 <BeelsebobWork> so what's there to give a rationale about?
01:02:51 <BeelsebobWork> have they made a descision on it?
01:03:34 <quicksilver> no, it's marked as 'maybe'
01:03:50 <quicksilver> lightstep: the only things you can check are the trac ticket, the wiki page and the mailing list
01:03:51 <sjanssen> I think undefineds need to look more scary than _
01:03:58 <quicksilver> lightstep: this one seems not to have been discussed on the mailing list.
01:04:16 <olsner> FalconNL: hmm, so you want an explicit fail function? I pretty certain parsec has those
01:09:00 <FalconNL> olsner: that does look like it does what I need it to. It needs parsec 3.0 though, so I'll go update GHC and see if works. Thanks.
01:14:16 <gvdm> hey, what functional/monadic shortcut/trick/technique/pure awesome is there to get the first monad value out of a list if it has Just the value in it, skipping initial ones with Nothing. example code at http://hpaste.org/10303
01:15:43 <dolio> There's not really a better way than that.
01:16:12 <opqdonut> > msum [Nothing,Nothing,Just 1,Just 2]
01:16:13 <dolio> Although you could rewrite it without explicit case and recursion, probably.
01:16:14 <lambdabot>   Just 1
01:16:17 <opqdonut> like that?
01:16:54 <quicksilver> opqdonut: yes that lifted through an abitrary monad 'm'
01:16:58 <opqdonut> mhmm
01:17:12 <quicksilver> gvdm: I've wanted that in the past.
01:17:13 <gvdm> so could go wrong
01:17:17 <lightstep> ?type msum
01:17:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:17:25 <quicksilver> gvdm: I defined 'orElse' as the binary version.
01:17:35 <quicksilver> gvdm: and then just folded it.
01:17:43 <gvdm> could you show me the code?
01:17:45 <lightstep> > mconcat [Nothing,Nothing,Just 1,Just 2]
01:17:46 <lambdabot>   Add a type signature
01:17:49 <quicksilver> it's the same as your code :P
01:17:56 <quicksilver> except I defined the binary one first.
01:18:17 <gvdm> oh well
01:18:26 <quicksilver> lightstep, opqdonut : it's something like runMaybeT . msum . map (MaybeT)
01:18:56 <quicksilver> assuming we choose the 'Maybe' MonadPlus for MaybeT, and don't lift the underlying one.
01:22:15 <lightstep> yeah
01:24:44 <hackage> Uploaded to hackage: gameclock 1.0.4
01:33:05 <cads> is anyone here familiar with the the interactive ruby shell (irb)?
01:33:33 <Eelis> cads: #ruby is probably a better bet ;)
01:33:41 <cads> hehe
01:34:30 <cads> I was wondering about an analogous shell for use with haskell
01:34:57 <BeelsebobWork> what does it do?
01:35:05 <BeelsebobWork> any more than evaluate chunks of ruby?
01:35:44 <cads> well there's that; you can declare functions and classes line by line
01:35:55 <BeelsebobWork> sounds a lot like ghci
01:36:00 <BeelsebobWork> but less powerful
01:37:13 <cads> I'll admit that I've got to learn more
01:37:53 <sicp> http://se-radio.net/podcast/2008-08/episode-108-simon-peyton-jones-functional-programming-and-haskell
01:37:59 <lambdabot> Title: Episode 108: Simon Peyton Jones on Functional Programming and Haskell | Software ..., http://tinyurl.com/5newum
01:38:01 <sicp> excellent spj podcast
01:38:12 <dolio> ghci doesn't let you define new datatypes. But other than that, it's a lot like irb.
01:40:17 <cads> I'll learn more before I complain :)
01:40:32 <BeelsebobWork> I'm worried that SPJ would like Haskell to be a microsoft product
01:42:09 <scorch_> http://hpaste.org/10305 <-- I have these types, and I want the types Profile and MolSeq to become instances of the class Evol, and every instance of Evol should implement a function 'distance'; how do I do it? I've tried to read up on classes and instances, but I don't get how it's supposed to be done... Any help?
01:43:37 <Axman6> BeelsebobWork: SPJ?
01:43:48 <BeelsebobWork> Axman6: Simon Peyton Jones
01:43:59 <BeelsebobWork> one of the main authors of ghc
01:44:03 <Axman6> ah, right
01:44:06 <dons> BeelsebobWork: heh, based on what?
01:44:18 <lightstep> scorch_, "instance Evol Profile where distance x y = ..."
01:44:30 <BeelsebobWork> dons: first couple of minutes of the podcast above
01:44:55 <dons> as in, MS packages it up nicely and makes it available for download with official support?
01:45:09 <dons> note that MS doesn't own anything haskelly.
01:45:09 <BeelsebobWork> he doesn't elaborate at all
01:45:20 <cads> peyton jones is just so delightful and energetic and nice seeming though; could he really want microsoft to absorb haskell?
01:45:34 <dons> there's nothing to 'absorb'.
01:45:51 <scorch_> lightstep: "Illegal instance declaration for `Evol Profile' (All instance types must be of the form (T t1 ... tn)"
01:45:54 <dons> haskell's an open source language design, with open source implementations.
01:46:07 <sjanssen> everything is BSD licensed with an open specification
01:46:08 <dons> all they could do would be to *reimplement* it. which isn't happening. they're busy reimplementing ocaml.
01:46:12 <Axman6> MS wiull find a way to make that... less fun
01:46:20 <Axman6> -u
01:46:34 <BeelsebobWork> dons: sure there is -- they are completely able to do the standard MS thing of inventing the language Haskell# and calling it the new standard
01:46:36 <BeelsebobWork> :P
01:46:42 <dons> umm...
01:46:56 <BeelsebobWork> it would of course be subtly different and incompatible
01:47:01 <Wild_Cat> I doubt MS has the money to waste on that.
01:47:15 <BeelsebobWork> I think MS has money to waste on a lot of things
01:47:19 <Axman6> BeelsebobWork: Haskell with objects
01:47:28 <sjanssen> they're busy doing that with F# anyway
01:47:29 <Axman6> BeelsebobWork: like vista? :P
01:47:31 <BeelsebobWork> they do after all just throw money at random researchers to work on whatever they want to do
01:47:32 <dons> so this entire discussion is based on what again?
01:47:33 <lightstep> scorch_, i didn't notice. 'type declarations are just synonyms, you can only define instances for a basic type, like those defined with 'data' or 'newtype'
01:47:43 <dons> spj talking about how haskell is not a MS product?
01:48:01 <BeelsebobWork> dons: no, just a comment
01:48:08 <dons> ok. then i wouldn't worry.
01:48:10 <sjanssen> dons: the interviewer says Haskell is not a MS product, SPJ confirms then says "alas"
01:48:10 <BeelsebobWork> saying "Haskell is not an MS product... unfortunately"
01:48:14 <BeelsebobWork> I'm not worrying
01:48:22 <dons> well, we'd have more corporate backing then.
01:48:26 <sjanssen> BeelsebobWork: he doesn't even say "unfortunately"
01:48:26 <dons> like F# does.
01:48:42 <dons> all he says is 'alas'.
01:48:45 <sjanssen> he says "alas", without any real inflection.  Meaningless IMO
01:48:59 <dons> yeah. given this is the guy that has pushed for open source dev, for the last 20 years.
01:49:09 <dolio> That's why F# is going to win and become the premier functional language for Real Development. :)
01:49:22 <dons> remember the old anti-trademark: 'haskell is open and free, and isn't the trademark of anybody'
01:49:23 <sjanssen> wha, JDH is here?
01:49:35 <dons> (opposite of Mirand(TM))
01:49:45 <BeelsebobWork> dons: heh
01:49:46 <dons> heh
01:50:48 <dolio> That's true. Open sourcing is a chief reason why Haskell exists.
01:50:52 <quicksilver> scorch_: as a rough guideline, never, ever use "type"
01:50:54 <dons> what's the cabal setting to strip executables?
01:51:18 <dons> look what happened to Miranda and Clean.
01:51:28 <scorch_> quicksilver: why not? O.o
01:51:40 <quicksilver> scorch_: because the point of the type system is to give you type safety
01:51:46 <quicksilver> scorch_: and 'type' doesn't do that
01:51:53 <quicksilver> because it doesn't declare new types
01:51:53 <scorch_> :/
01:51:56 <quicksilver> (bad name? maybe)
01:52:07 <quicksilver> type MolSeq = (SeqType, String, String)
01:52:09 <quicksilver> use
01:52:16 <quicksilver> data MolSeq = MolSeq SeqType String String
01:52:19 <sjanssen> synonym String = [Char]?
01:52:36 <quicksilver> sjanssen: in retrospect I think taht would be a better name for the keyword, yes.
01:52:44 <scorch_> quicksilver: our assignment requires the use of 'type' :(
01:52:52 <quicksilver> bah. useless assignment.
01:53:28 <sjanssen> scorch_: I think quicksilver is being a bit overzealous.  Type synonyms are certainly useful, you just need to know when data/newtypes are better
01:53:32 <osfameron> it's much easier to be able to use a type synonym than to have to declare all the operators you want to act on your datatype and mess with the lifting at every point...
01:54:16 <dolio> Poor clean... reliably beating us on the shootout. :)
01:54:25 <dons> note on quad core.
01:54:31 <dons> not.
01:54:37 <dons> or 64 bit
01:54:44 <dolio> Ooo, there's lots of new stuff there.
01:54:58 <scorch_> "Implement the type class 'Evol' and let 'MolSeq' and 'Profile' become instances of 'Evol'. All instances of 'Evol' shall implement a function 'distance'."
01:55:06 <slarba> is clean actively developed?
01:55:29 <sjanssen> dolio: that is probably evidence that performance is less important than other issues, otherwise we'd all use Clean
01:55:30 <dolio> They released some statement a couple months ago about making a Haskell front-end for their compiler.
01:55:34 <sjanssen> and nobody would use Ruby :)
01:55:35 <dolio> So someone must be working on it.
01:55:36 <dons> single core 64 bit, http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=all
01:55:38 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/4lrsyg
01:55:58 <dons> dolio: wasn't   that a year and some months ago?
01:56:07 <quicksilver> sjanssen: I'm always overzealous. It's more fun.
01:56:07 <dolio> Was it that long ago?
01:56:20 <dons> i think so. that was ages (the idea has been floating around for years)
01:56:25 <quicksilver> but, there is a point behind what I say. I very very rarely use 'type'.
01:56:33 <dolio> Huh. Time flies.
01:56:49 <sjanssen> quicksilver: yeah, same here
01:58:13 <dons> sjanssen: http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
01:58:14 <lambdabot> Title: thread-ring benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Language ..., http://tinyurl.com/5ph2wt
01:58:25 <dons> (control thread migration, and thread-ring runs ok on smp)
01:58:43 <JaffaCake> wow, nice
01:58:48 <sjanssen> dons: mwahaha
01:59:04 <dons> JaffaCake: i actually submitted a faster one, that explictily partitions the ring
01:59:10 <dons> but that's just the naive one with -qw -qm
01:59:13 <dons> 4% 1% 0% 92%
01:59:13 <sjanssen> dons: and that isn't even the version that cheats :)
01:59:34 <dons> right. that's "naive" -- i.e. the same program from the single core.
01:59:39 <dolio> Clean doesn't appear to even be on the x64 and quad-core rankings.
01:59:43 <JaffaCake> dons: so won't all the threads be running on one core then?
01:59:50 <dons> JaffaCake: mostly. see the numbers above
01:59:56 <dons> i submitted a proper version
02:00:02 <dons> that hasn't been uploaded yet it seems
02:00:07 <dcoutts> dons: recent cabal always strips exes, unless you configure with --disable-executable-stripping
02:00:17 <BeelsebobWork> dons: did you get my Mandelbrot program that parallelises and gains a little bit of time?
02:00:21 <dons> also , the parallel binary-trees, the easiest one,  http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ghc&id=2
02:00:23 <lambdabot> Title: binary-trees Haskell GHC #2 program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Com ..., http://tinyurl.com/5ag9be
02:00:25 <sjanssen> is overscheduling with "+RTS -N5" wise?
02:00:29 <dons> but failing due to missing parallel package on ubuntu.
02:00:41 <dons> sjanssen: probably not. i didn't pick those, that's igouy experimenting by the looks.
02:00:55 <dons> BeelsebobWork: i did get it to go faster. will revisit on the weekend.
02:00:58 <JaffaCake> dons: looks like the program still uses the main thread, that's probably a bad idewa
02:01:05 <BeelsebobWork> dons: oh, cool, what did you do with it?
02:01:32 <dons> JaffaCake: so should it: main = x <- newEmptyMVar ; do everything ; takeMVar x ?
02:01:39 <dons> is that how you get off the main thread?
02:01:49 <dons> where everything is a bunch of forkIO
02:01:55 <JaffaCake> right
02:02:10 <dons> so just let the main thread sleep, and unleash forkio threads for all the work. ok.
02:02:11 <JaffaCake> communication between the main thread and other threads is slow
02:02:14 <sjanssen> is it an advantage or disadvantage to execute each forkIO in the main thread?
02:02:25 <dons> ok. i've never tried measuruing that, but you've mentioned it a few times.
02:02:41 <JaffaCake> I'm wondering whether to change it
02:03:04 <JaffaCake> it's a performance gotcha, but it makes sense when you understand how bound threads work
02:03:08 <dons> JaffaCake: and -prof -threaded works in the head?
02:03:24 <JaffaCake> it does, but not with -N > 1
02:03:30 <dons> i'm doing a lot of smp parallel programming of late, so that's getting needed.
02:03:31 <dons> ah ok.
02:03:57 <JaffaCake> dons:  I have a patch to implement work-stealing for par, hoping to get it into 6.10
02:04:07 <JaffaCake> it improves par/seq and strategies quite a bit
02:04:10 <dons> oh, good.
02:04:16 <dons> `par` is still trial and error for me, mostly.
02:04:32 <JaffaCake> yeah, there are several reasons why you don't get good speedup
02:04:35 <dons> i'd love -prof-par or something, which printed the best thunks to add `par` to
02:04:36 <JaffaCake> we're tackling them one at a time
02:04:57 <dons> since at the moment i sort of hunt around for the expensive looking things, and the top level control
02:05:02 <JaffaCake> you should always use +RTS -A, otherwise the GC barrier kills you
02:05:10 <dons> yeah. i've noticed.
02:05:20 <dons> -A300M really improves binary-trees (2x faster)
02:05:29 <BeelsebobWork> JaffaCake: I discovered that +RTS -H is *much* better on OS X
02:05:43 <JaffaCake> better than what, not doing it at all?
02:05:50 <BeelsebobWork> no, better than -A
02:05:56 <JaffaCake> oh, interesting
02:06:01 <BeelsebobWork> -A causes about a minute of system activity on startup
02:06:04 <BeelsebobWork> (with 300M)
02:06:17 <dons> anyway, on quad core shootout, we do get free reign to parallelise all of http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ghc those
02:06:19 <lambdabot> Title: Haskell GHC benchmarks | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Languag ..., http://tinyurl.com/4qs7kc
02:06:21 <JaffaCake> dons: there are two issues: the cost of GC itself, which you can reduce by using lots more memory, and the cost of stopping all the CPUs to do GC
02:06:21 <BeelsebobWork> while -H gives roughly the same speedup to the program run but not all the system activity
02:06:30 <dons> and doing so should exercise most of the infrastructure, i suspect.
02:07:09 <dons> JaffaCake: ah, so that's why we see big improvements, just looking at -sstderr, and trying to lower then number of gcs done
02:07:09 <mmorrow> ?yow
02:07:10 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES ...
02:07:10 <lambdabot> Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
02:07:12 <JaffaCake> BeelsebobWork: that's very interesting, we should look into it
02:07:25 <mmorrow> just got yi working with HEAD
02:07:27 * dons current strategy, anything using `par` gets a -sstderr cycle.
02:07:43 <dons> hunt for gcs, trying increasing -A until 1-5% gc time.
02:07:54 <scorch_> quicksilver: But what should I do to let MolSeq and Profile (if they're still types)  become instances of class Evol?
02:07:55 <dons> then trial-and-error apply `par`
02:08:14 <JaffaCake> -A primarily reduces the number of minor collections, which reduces the number of barriers
02:08:32 <dons> what's the difference between -qw and -qm ?
02:08:38 <JaffaCake> we think that implementing independent GC for the young generations is a top priority
02:08:50 <JaffaCake> I'd have to look that one up :)
02:09:16 <quicksilver> scorch_: Haskell doesn't permit that.
02:09:19 <dons> so per-thread young generation collection?
02:09:21 <JaffaCake> ah, ok.  So -qm stops "load-balancing" migration
02:09:28 <quicksilver> scorch_: you could use GHC's extensions
02:09:33 <quicksilver> scorch_: 'FlexibleInstances'
02:09:40 <JaffaCake> whereas -qw stops opportunistic migration, that happens when a thread is woken up
02:09:47 <dons> oh. "load balancing" eh? i wonder what the load balancing strategy is.
02:09:52 <quicksilver> scorch_: to my mind, it's a daft exercise which forbids use of the standard 'data' and 'newtype' keywords but permits GHC extensions
02:09:56 <dons> we might need more docs on this. where would i look?
02:09:57 <quicksilver> but whatever works for your prof.
02:10:13 <dons> JaffaCake: also, numCapabilities needs to be put somewhere sensible, other than GHC.Conc :)
02:10:23 <JaffaCake> it's pretty stupid - we just look for idle CPUs and give them threads
02:10:32 <dons> ah ok.
02:10:33 <scorch_> quicksilver: heh, we're not even supposed to be using GHC, but hugs
02:10:44 <dons> JaffaCake: do you know of the erlang rts is smarter with its load balancing?
02:10:58 <JaffaCake> dons: but work-stealing improves the situation for par a lot, we haven't tackled threads yet but they could get the same treatment
02:10:58 <sjanssen> scorch_: hugs -98 will do the same thing
02:10:59 <Axman6> scorch_: use data, and leave comments to the effect that what you're being asked to do is not really supported/silly
02:11:02 <dons> i should read up on how they're doing smp.
02:11:18 <Wild_Cat> dons: IIRC the Erlang VM does load balancing by not doing any.
02:11:21 <JaffaCake> yeah, I'd be interested to know
02:11:33 <scorch_> sjanssen: ah, okey
02:11:35 <Wild_Cat> Erlang advises you to start one node per core.
02:11:45 <scorch_> Axman6: I got problems when I tried to switch to data instead of type
02:11:50 <JaffaCake> and they don't migrate processes?
02:11:52 <Axman6> dons: basically you do the load balancing in erlang
02:12:11 <Wild_Cat> JaffaCake: nope.
02:12:12 <dons> ok. so say, http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=hipe&id=2
02:12:14 <lambdabot> Title: binary-trees Erlang HiPE #2 program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Com ..., http://tinyurl.com/596q79
02:12:19 <dons> 55% 52% 88% 60%
02:12:28 <dons> maybe the 'pmap' just does a simple manual strategy?
02:12:44 <dcoutts> so they do not place erlang processes on nodes automatically? always explicitly placed?
02:12:47 <dons> i guess if particular strategies know something about how they should be balanced
02:12:53 <Axman6> most likely, though it may be there by default
02:12:56 <Wild_Cat> but since you always have boatloads of running processes on each VM and no locks, the thing scales well.
02:12:57 <dons> dcoutts: well, the above one seems to do it just like parMap
02:13:00 <dons> nothing explicit.
02:13:10 <dons> depthLoop(D,M) -> Results = rpc:pmap({?MODULE, depth}, [M], lists:seq(D, M, 2)),
02:13:17 <Axman6> dons: i think any pmap in erlang would just create a new process for all elements of the list
02:13:35 <dons> and how does it schedule them across the cores though?
02:13:40 <dcoutts> Axman6: but which nodes would it start the processes on?
02:13:52 <Axman6> the ones it's connected to i guess
02:13:55 <dcoutts> round robin?
02:14:01 <Axman6> possibly
02:14:04 <dons> erl -smp enable
02:14:08 <Axman6> in fact, i think that's pretty likely
02:14:09 <dons> so maybe that just does something simple.
02:14:15 <Axman6> yeah
02:14:17 <dons> like find the number of cores, and start N jobs.
02:14:57 <dons> JaffaCake: i wonder if at some point, apps compiled with -threaded should automagically use +RTS -Nx, where x is found by the rts.
02:15:00 <JaffaCake> erlang will have an advantage scaling beyond 8-16 cores, because they have completely independent heaps
02:15:24 <JaffaCake> dons: right, we've talked about that in the past I think
02:15:38 <quicksilver> +RTS -Nx could become an override
02:15:45 <quicksilver> the default could be chosen by the RTS
02:15:49 <JaffaCake> if we could show that it doesn't make things slower, I guess I'm happy
02:15:57 <quicksilver> (well it is already, but the default couuld not be always 1 ;P)
02:16:45 <dons> well, i'm not sure it wouldn't make things slower yet.
02:16:48 <dons> we're getting there though.
02:17:13 <JaffaCake> I'm worried that because we use spinlocks in places, if one of the capabilities gets descheduled performance could really suffer
02:17:31 <Axman6> dons: from what i remember of seeing examples of writing pmap code, it just spawns one process for each element, which then sends them back, and the recieving process recieves in order
02:17:43 <dons> JaffaCake: so more benchmark programs for you? and what's next: work stealing, then per-thread young gen. gc?
02:17:48 <_Dae_> It would be nice to have a sort of stricter version of par... one where you decide if you want to spawn a thread
02:17:49 <Axman6> http://yarivsblog.com/articles/2008/02/08/the-erlang-challenge/ for example
02:17:54 <lambdabot> Title: Yarivâ€™s Blog Â» Blog Archive Â» The Erlang Challenge
02:17:57 <dons> JaffaCake: do you have access to the T2 btw?
02:18:11 <dons> Axman6: yeah, so that's just parMap.
02:18:12 <JaffaCake> dons: right, work stealing and hopefully we'll get to the GC
02:18:19 <JaffaCake> not yet
02:18:21 <dcoutts> donri: not yet, I'll people accounts
02:18:24 <dcoutts> oops
02:18:28 <dcoutts> dons:
02:18:29 <dcoutts> ^^
02:18:55 <JaffaCake> dons: please send us benchmarks, yes
02:18:59 <dons> ok.
02:19:05 <dons> well, i'm working through the shootout.
02:19:08 <JaffaCake> especially ones that you haven't tuned, and don't work
02:19:20 <dons> oh, ok. i've lots of those :)
02:19:20 <JaffaCake> so we can find the bottlenecks
02:19:26 <Axman6> dons: yeah, but with the ability to give it a list of nodes, so it can be distributed
02:19:35 <dons> the fun with  `par` is that it looks like it'll work anywhere :)
02:19:40 <Axman6> not all that helpful for a haskell implementation though...
02:19:41 <dons> but it doesn't. so its a guessing game.
02:19:41 <_Dae_> dons: you working on the fankuch one?
02:19:45 <dcoutts> JaffaCake is allowed an account on the T2 once he sends in his comments on the project applicants ;-)
02:19:47 <dons> _Dae_: not yet. dive in!
02:19:58 <JaffaCake> mumble mumble
02:20:13 <dcoutts> JaffaCake: s'ok, we're not actually that short of time :-)
02:20:28 <dons> so i have a first transparently smp-ready lib to put on hackage too, btw. a random bytestring generator.
02:20:29 <JaffaCake> with the GHC RC supposedly in one week, I want to make a dent in the 87 tickets we still have open
02:20:34 <_Dae_> dons: Already have.... I've tried 3-4 different approaches, with ghc refusing to use any additional cores
02:20:54 <dons> you give it a seed and it gives you a random bytestring of however many gigs you want
02:21:06 <Axman6> _Dae_: i'm assuming you've cleared the .hi and .o files, and compiled with -threaded?
02:21:14 <dons> but uses a bunch of threads to unfold the chunks, and then reduce them in the main thread.
02:21:14 <dcoutts> JaffaCake: aye, so much to do before ICFP, I've also got a thesis draft to hand in. sigh.
02:21:21 <ac> dons: I fixed my cabal file. I'd copied the one from hsclock, hence the mistake.
02:21:23 <dons> so it'll be fun when we have more magically parallel libs.
02:21:31 <dons> then we'll need to think about how you compose them..
02:21:34 * Axman6 could be missing what the actual problem is...
02:21:59 <_Dae_> Axman6: yes, using theaded, running with +RTS -N2
02:21:59 * JaffaCake gets coffee
02:22:06 <dons> _Dae_: on linux?
02:22:15 <Axman6> _Dae_: what happens exactly?
02:22:16 <_Dae_> dons: yes
02:22:24 <dons> do other parallel programs work?
02:22:36 * Axman6 has an example you could try...
02:22:45 <Axman6> actually, no, that code's way too ugly to show
02:22:56 <_Dae_> dons: sure... I have other programs getting 75% total cpu load
02:23:04 <Axman6> but, it does get a near linear speedup when run on two cores
02:23:09 <Axman6> i wonder...
02:23:27 <_Dae_> Axman6: it runs the exact same time with +RTS -N2 and with -N1
02:24:34 <Axman6> can you show the code?
02:24:48 <_Dae_> http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=ghc&id=1
02:24:50 <lambdabot> Title: fannkuch Haskell GHC program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer L ..., http://tinyurl.com/54n3uw
02:25:03 <_Dae_> added a $ parBuffer 512 rnf p
02:25:42 <_Dae_> well... that's the most basic approach.... I also wrote a lazy parallel maximum, but with the same result
02:29:05 <_Dae_> 'nother version with the parMax code added..... http://hpaste.org/10306
02:29:45 <ketil> what's the fix for the linker errors using -optl-static (lots of pthread-related stuff)?
02:30:04 <ketil> (this always happens, but rarely enough that I keep forgetting)
02:42:05 <_Dae_> nevermind, I figuured out what was wrong.... plain old stupidity on my part
02:44:48 <SWAT95x_> arschi
02:44:56 <SWAT95x_> !k SWAT95x_
02:45:02 <Axman6> ...
02:45:07 <SWAT95x_> kick mich service xD
02:45:20 <quicksilver> just type /part or /quit , in most clients
02:45:22 <profmakx> geh doch einfach sterben SWAT95x_
02:45:37 <quicksilver> I guess that did the trick.
02:45:40 <profmakx> hehe
02:45:51 <profmakx> /join #haskell,0 does the trick, too
02:46:05 <SWAT95x_> wenn ich böse wörter sag müsste ich gekickt werden
02:46:07 <SWAT95x_> ol
02:46:09 <SWAT95x_> fuck
02:46:15 <SWAT95x_> huso
02:46:19 <Axman6> fail
02:46:28 <SWAT95x_> was ist das für ein scheiß Sevice
02:46:39 <chrisdone> profmakx: I forgot about that weird IRC property. why does it do that?
02:47:08 <quicksilver> that's weird, I saw his u-umlaut and double-s glyph
02:47:17 <quicksilver> I didn't think this toolchain was set up for such things.
02:47:18 <chrisdone> so did I
02:47:22 <quicksilver> someone say something in unicode?
02:47:28 <chrisdone> Î»_Î»
02:47:30 <_Dae_> quicksilver: why is that weird? Ã¥Ã¸Ã¦Ã¥Ã¸
02:47:41 <quicksilver> good, business as usual.
02:47:44 <quicksilver> none of that worked :)
02:47:45 <chrisdone> â€¢Â·.
02:47:53 <Axman6> quicksilver: what client are you using?
02:47:59 <quicksilver> I gues it's just 8859-1, which happenes to overlap unicode
02:48:06 <quicksilver> Axman6: irssi but that's not the problem.
02:48:14 <Axman6> i know, i use it too, on
02:48:16 <quicksilver> the problem lies in screen -> ssh -> iTerm
02:48:16 <Axman6> OS X
02:48:21 <quicksilver> which I can't be bothered to fix.
02:48:24 <Axman6> oh, yeah iTerm is fail
02:48:48 <Axman6> irssi -> screen -> ssh -> terminal works fine ;)
02:49:51 <Axman6> leopard's terminal added all the things that iTerm offered, without the suckage of iTerm, i was very happy about that
02:50:14 * quicksilver isn't using leopard.
02:50:34 <Axman6> ah, well, tiger's terminal was still better than iterm
02:50:56 <quicksilver> Axman6: not for me. It doesn't do tabs and it doesn't have 'bookmarks
02:51:09 <Axman6> it has bookmarks doesn't it?
02:51:40 <quicksilver> not in any way I can see.
02:51:53 <quicksilver> anyhow I use tabs heavily
02:52:42 <Axman6> i did like having tabs, but iterm was so painful, i couldn't keep using it
02:53:15 <Axman6> anyway, off topic.
02:58:45 <conal> dons: yesterday i was looking for an old xmonad slide presentation in which you talked about your experiences with QuickCheck an particularly how it helped you make more aggressive experiments, such as the zipper.  i couldn't find it.  any suggestions where to look?
02:59:08 <conal> dons: i'm doing some team indoctrination.
02:59:48 <BeelsebobWork> haha
03:00:56 <mattam> Axman6: you know Terminal has tabs as well, right?
03:01:03 <Axman6> i do
03:01:12 <Axman6> was talking about tiger
03:01:23 <mattam> ok
03:14:31 <Myoma> Progress in topic meaning ?
03:14:35 <Myoma> type safe .. ?
03:16:25 <BeelsebobWork> I would interpret it to mean guarenteeing that you get closer to some normal form with each step
03:16:30 <quicksilver> Myoma: probably a reference to STM
03:16:41 <quicksilver> Myoma: which is deadlock free and guaranteed to progress
03:20:45 <Axman6> anyone know of a way to install ghc 6.8.3 in less than 250MB, in a user dir?
03:20:52 <Axman6> on linux
03:21:39 <FunctorSalad> what's this STM? *embarassed*
03:21:54 <BeelsebobWork> FunctorSalad: Software Transactional Memory
03:21:56 <BeelsebobWork> IIRC
03:21:58 <Axman6> the precompiled versions are too large
03:22:11 <BeelsebobWork> you specify transactions that should be completed as atomic actions
03:22:17 <Deewiant> Axman6: maybe remove the profiling versions of libraries?
03:22:22 <FunctorSalad> heh, I thought it was "state transformer". no wonder the api seemed weird ;-)
03:22:28 <BeelsebobWork> hehe
03:22:41 <BeelsebobWork> the idea is that you can try to do a memory transaction
03:22:51 <BeelsebobWork> and it's possible that it'll get rolled back if it couldn't be done attomically
03:23:19 <Axman6> Deewiant: i was hoping for a precompiled version if possible, i think my quota may get filled while compiling
03:23:43 <Deewiant> Axman6: well you can take the precompiled version and remove *_p.a
03:23:53 <Axman6> hmm
03:24:21 <Deewiant> not sure if it will help enough, but somewhat at least
03:24:29 <Axman6> any idea how i'd do that, from the tar.bz2?
03:24:45 <Deewiant> I don't know if tar can remove stuff from within archives
03:24:50 <Axman6> yeah :\
03:25:10 <Deewiant> can you even unpack the archive in any case?
03:25:21 <ivanm> is there a good guide on how to use haddock?
03:25:57 <Myoma> ivanm: Better than the documentation?
03:26:16 <ivanm> duh, didn't think about looking at its documentation for some reason :s
03:28:16 <_Dae_> ivanm: heh, well there's so much lousy documentation floating around the interweb that noone would blame you
03:29:07 <ivanm> so basically -- | is before a type sig, and -- ^ is inline haddock?
03:30:05 <quicksilver> FunctorSalad: yes, as BeelsebobWork says. It's optimistic concurrency with consistency checks.
03:32:02 <FunctorSalad> optimistic = doesn't ask and rolls back if something happened?
03:32:26 <ivanm> is there a way to define a function such that if it's of type Foo, do this otherwise do something else?
03:32:55 <BeelsebobWork> FunctorSalad: exactly
03:34:41 <quicksilver> FunctorSalad: not just rolls back, but retries
03:34:58 <quicksilver> FunctorSalad: and will block until one of the things which caused it to rollback has changed ;)
03:35:16 <quicksilver> I recommend the paper on it.
03:35:25 <quicksilver> The elegant part is actually the way it composes
03:35:31 <ivanm> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphviz <-- is this for FGL graphs or standard graphs?
03:35:34 <lambdabot> Title: HackageDB: graphviz-2008.9.6, http://tinyurl.com/3wuh78
03:37:17 <FunctorSalad> ivanm: "gr" is fgl IIRC
03:37:40 <FunctorSalad> eh, I mean the convention of calling the Graph instance gr ;-)
03:37:50 <ivanm> FunctorSalad: that's what I thought, but he said for Data.Graph graphs :s
03:38:04 <ivanm> well, he's using the Graph class as well
03:38:04 <FunctorSalad> (fgl is Data.Graph.Inductive right?)
03:38:10 <ivanm> FunctorSalad: yeah
03:38:20 <ivanm> dammit, it doesn't do subgraphs either
03:38:43 <FunctorSalad> ivanm: should be easy to add
03:38:52 <FunctorSalad> (you mean graphviz subgraphs, right?)
03:39:02 <ivanm> yeah
03:39:24 <FunctorSalad> just a gotcha: you make a subgraph a cluster by having its identifier start with "cluster" o_O
03:43:00 <ivanm> hmmm... is Iavor here?
03:47:36 <ivanm> wow, there's at least three different graphviz bindings available on hackage :o
03:49:08 <dcoutts_> ivanm: is that all?
03:49:39 <ivanm> well, that's all I could find ;-)
03:49:44 <dobblego> @hoogle [a] -> Maybe (a, [a])
03:49:44 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
03:49:44 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (a -> d -> (a, q)) -> a -> d -> (a, [q])
03:49:44 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
03:49:57 <ivanm> fgl's internal one, graphviz and dotgen
03:50:03 <ivanm> dcoutts_: I _did_ specify on hackage ;-)
03:50:11 <ivanm> (since I know that you've got your own custom bindings)
03:50:21 <Myoma> @let list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
03:50:23 <lambdabot>  Defined.
03:50:24 <Myoma> :t list Nothing ((Just .) . (,))
03:50:26 <lambdabot> forall t1. [t1] -> Maybe (t1, [t1])
03:50:51 <ivanm> looks like dotgen is the only one that supports clusters, but it lists and pairs rather than a graph type for input :(
03:51:13 <FunctorSalad> surely there's a toList?
03:51:58 <ivanm> for graphs? there's functions to get the nodes, functions to get the edges, etc.
03:52:47 <ivanm> hmmmm..... what's the guideline for when unsafePerformIO is relatively 'safe'? when running the IO function doesn't change any state?
03:53:35 <_Dae_> I just got the weirdest bug trying to compile.... http://hpaste.org/10309
03:53:50 <quicksilver> ivanm: when it makes no difference to you if the action is performed once, never, or multiple times
03:54:06 <dolio> _Dae_: Lack of --make?
03:54:08 <ivanm> quicksilver: ummmmm...... what?
03:54:15 <quicksilver> ivanm: that's the side-condition.
03:54:20 <Axman6> bah, beat me to it dolio
03:54:21 <ivanm> oh
03:54:35 <quicksilver> "unsafePerformIO act" if you don't care if act might be performed never, once, or multiple times
03:54:37 <dolio> That's usually what undefined references mean.
03:54:38 <_Dae_> dolio: right on :) Thanks
03:54:42 <quicksilver> and you don't care exactly when it happens.
03:55:00 <ivanm> right, referential transperancy, etc.?
03:55:07 <quicksilver> the only time I've used it myself is unsafePerformIO . readFile
03:55:10 <quicksilver> and that was only a quick hack
03:55:25 <ivanm> cos this function doesn't look like it changes any state or anything, just passes stuff to a command, the parses the output: http://hackage.haskell.org/packages/archive/graphviz/2008.9.6/doc/html/src/Data-GraphViz.html#graphToGraph
03:55:31 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4hwkz6
03:55:44 <quicksilver> Yup.
03:55:53 <ivanm> good-o
03:55:55 <quicksilver> It is quite often safe to unsafePerformIO things which all external commands.
03:56:04 <ivanm> call them even? :p
03:56:12 <quicksilver> if that external command is "pure" in some informal sense
03:56:14 <quicksilver> quite ;)
03:56:23 <ivanm> \o/
03:56:56 <ivanm> yeah, so if it doesn't touch the input parameters and doesn't launch nuclear missiles it's all good?
03:57:06 <FunctorSalad> quicksilver: hmm that condition kinda makes "unsafeLaunchMissiles" unviable
03:57:29 <ivanm> FunctorSalad: depends... are your intentions pure when you launch them? ;-)
03:57:59 <FunctorSalad> ivanm: I meant the unknown number of repetitions condition ;-)
03:58:13 <ivanm> ahhh
03:58:28 <ivanm> because the second time there aren't any missiles to launch?
03:58:51 <ivanm> "purity" is roughly the same as injective?
03:59:02 <ivanm> no, wait, that's not right...
03:59:19 <Cale> Purity is similar to 'well-defined'
03:59:27 <ivanm> it has to be a function in the mathematical sense that f x has only one possible output
03:59:31 <Cale> yes
03:59:32 <EvilTerran> it means the inverse is injective
03:59:32 <ivanm> _that's_ what I was after
03:59:44 <Axman6> ivanm: unsafeLaunchMissiles [Missile 1..]
03:59:51 <Axman6> that way you don't run out
03:59:52 <EvilTerran> although not necessarily a proper function
03:59:52 <ivanm> Axman6: heh
04:00:03 <ivanm> unsafeLaunchMissiles = mapM_ unsafeLaunchMissile ?
04:00:05 <EvilTerran> the inverse is an, er, injective relation :P
04:00:10 <FunctorSalad> Axman6: producing the missiles lazily might be too slow though
04:00:25 <Axman6> god damnit, i need ghc in less than 250MB
04:00:29 <Axman6> rawr
04:00:54 <mapreduce> [rm Recursive Force Root, error, 1/0]
04:00:58 <ivanm> FunctorSalad: "hey, country X launched another nuke at us... we need to retaliate!!!" "oh, _now_ you want us to build that nuke for you?" ;-)
04:01:27 <FunctorSalad> isn't the "functions-are-actually-functions" condition referential transparency? so purity is synonymous to referential transparency?
04:01:44 <therp> is there any language that sees evaluation as something invertible? so for instance if (four1 = 2 + 2, and four2 = 4) then eval^-1 four1 != eval^-1 four2?
04:01:49 <FunctorSalad> ivanm: yeah
04:01:49 <therp> I'm not sure if I recall it correctly that I've read something like that on LtU
04:02:11 <Myoma> therp: Prolog, Curry, Janus, Inv, ...
04:02:28 <Axman6> anyone got any ideas on getting ghc installed in less than 250MB? :\
04:02:30 <Myoma> short answer, Yes!
04:02:32 <quicksilver> FunctorSalad: they are certainly very closely linked concepts and they both suffer flame wars about what exactly they mean ;)
04:02:45 <ivanm> Axman6: make ghc-light? :p
04:02:50 <FunctorSalad> quicksilver: I was afraid of that, hence the question
04:03:02 <ivanm> quicksilver: lol
04:03:02 <quicksilver> FunctorSalad: referential transparency I generally think of as 'it's always safe to replace a name by its definition'
04:03:23 <quicksilver> FunctorSalad: which is a property of all values, whether they be of function type or not.
04:03:44 <quicksilver> FunctorSalad: purity I think of as "a -> b" will always compute the same 'b' for a given 'a' and have no observable side-effects.
04:03:54 <quicksilver> other people may have other variations ;)
04:04:17 <mmorrow> if anyone's interested, here's a yi i just got to build with a ghc-HEAD from a few hours ago: http://code.haskell.org/~morrow/yi/
04:04:18 <lambdabot> Title: Index of /~morrow/yi
04:04:29 <therp> Myoma: thanks just found an interesting wikipedia article as link to the Janus article (reverisble computations)
04:04:43 <FunctorSalad> quicksilver: random thought, what's the equality on a and b?
04:04:56 <Axman6> bah, i should just request it be installed i guess :\
04:05:14 <ivanm> quicksilver: so what's an unobservable side effect? time passing, entropy increasing, etc.?
04:05:17 <quicksilver> FunctorSalad: I think that one's up for debate.
04:05:21 <Myoma> therp: really ?
04:05:23 <Myoma> what's the URL
04:05:27 <ivanm> i.e. stuff that doesn't affect our data? :p
04:05:29 <quicksilver> ivanm: normally we don't consider memory usage observable
04:05:35 <ivanm> *nod*
04:05:38 <quicksilver> ivanm: so space and time factors
04:05:43 <Myoma> previously wiki only knew about the other Janus
04:05:54 <FunctorSalad> the old intensional-vs.-extensional problem :(
04:05:55 <ivanm> the two-faced one?
04:06:05 <Beelsebob> tbh -- I would say that memory usage increasing and time passing are implementation errors
04:06:12 <Beelsebob> they're bloody difficult ones to get rid of
04:06:15 <FunctorSalad> I guess you don't want ref transparency to be up to an undecidable extensional equality ;-)
04:06:26 <quicksilver> FunctorSalad: as a computer scientist I'm happy to settle for observantional equality.
04:06:46 <therp> Myoma: could you give an example for prolog? Z=2+2 as goal would give me 4 for Z, and iirc atom is not distinguishable from the constant 4, nor is there any mechanism to invert both computations
04:07:35 <Myoma> therp, no, try it in a Prolog query loop, that's not what happens
04:08:18 <Myoma> therp, although numerics isn't the interesting stuff, http://gollem.science.uva.nl/SWI-Prolog/Manual/clpfd.html
04:08:19 <lambdabot> Title: SWI-Prolog 5.6.59 Reference Manual: Section A.7
04:09:46 <ivanm> matthew-_: ping
04:09:57 * _Dae_ has, after a long and hard struggle, managed to improve the Shootout fankuch benchmark from 20s to almost 4 minutes
04:10:30 <ivanm> _Dae_: how is that an improvement? I thought they were meant to run _fast_ :s
04:11:21 <quicksilver> _Dae_: that's a useful talent
04:11:26 <Adamant> nice. one of the writers of the Ada95 specifically recommends investigating Haskell
04:11:27 <quicksilver> _Dae_: c.f. http://thedailywtf.com/Comments/The-Speedup-Loop.aspx
04:11:30 <lambdabot> Title: The Speed-up Loop - The Daily WTF
04:11:37 <_Dae_> ivanm: I was being ironic :p It was more of a comment on the futility of my efforts to make it run in paralllel
04:12:09 <ivanm> ahhhh
04:12:22 <Axman6> _Dae_: got to remember that sometimes sparking a parallel computation can be more costly than just running the computation
04:12:38 <quicksilver> Axman6: that is supposed to be very seldom true in GHC
04:12:43 <quicksilver> sparking is supposed to be super-cheap
04:12:49 <Axman6> supposed to be, yes
04:12:55 <Axman6> hasn't been my experience
04:13:45 <_Dae_> Axman6: but the problem is they don't spark....ever... at all....
04:14:03 <Axman6> though, that has had a lot to do with the fact i was doing it entirely wrong, and not storing the results of the computations
04:14:19 <Axman6> _Dae_: got the code anywhere?
04:16:25 <_Dae_> Axman6: http://hpaste.org/10311
04:17:16 <_Dae_> nothing below line 76 is used.... it just illustrates some of the -other- ways I've tried to do this....
04:22:00 <_Dae_> when did the hpaste announce die btw?
04:22:27 <quicksilver> _Dae_: I've never thought about this problem before, btu I have one observation
04:22:33 <quicksilver> it's fairly memory heavy
04:22:57 <quicksilver> making it go ahead and do large chunks fo the list in parallel
04:22:59 <_Dae_> quicksilver: that it is, which is why I'm not just parMap'ing the whole thing
04:24:05 <_Dae_> quicksilver: well, isn't that what I want, or?
04:24:12 <EvilTerran> that might explain the lack of hpaste announcements
04:25:31 <quicksilver> _Dae_: not if it pushes you out of caches
04:26:28 <_Dae_> quicksilver: well, I could always reduce the chunk size... I figured I would mess with them when I had atually gotten the program to run in more than 1 thread....
04:26:44 <quicksilver> _Dae_: your OPTIONS doesn't mention -threaded
04:28:10 <_Dae_> quicksilver: using a makefile that does. I thinks +RTS -N2 gives you an error if it hasn't been compiled with -threaded
04:28:53 <quicksilver> ah, fair enough
04:35:51 <FunctorSalad> quicksilver: reading the "observational equality" paper now... do you know what the notation "{ s || Q:S=T } : (s : S)" means?
04:36:12 <quicksilver> FunctorSalad: not without reading the paper, no :(
04:37:22 <FunctorSalad> S=T is some equality on set that they're introducing, but I'm confused by the {  ... ||  .... }
04:37:30 <FunctorSalad> *sets
04:38:05 <FunctorSalad> and why that thing is supposed to be of type s, which is of type S in turn
04:38:45 <FunctorSalad> by "the" paper I'm referring to the first google hit, "observational equality now!" ;-)
04:40:17 <Eelis> is there a clean way to prevent page breaks in \begin{code}..\end{code} blocks with lhs2tex, other than by using figures?
04:41:11 <dcoutts_> Eelis: or by explicitly adding page breaks before
04:41:56 <dcoutts_> Eelis: I don't know of any particularly clean way unfortunately, ask a latex guru
04:41:56 <Eelis> dcoutts_: hm. not really a scalable solution, but at least it beats evil \parboxes that mess up indentation. thanks :)
04:42:26 <cjs> dcoutts_: Hey there. So, the whole -main-is thing turns out to be more subtle than I'd thought.
04:42:42 <dcoutts_> cjs: oh yes?
04:43:03 <cjs> Well, it turns out that the .o file is different for a -main-is compile versus a normal one. It's not just a linker flag.
04:43:32 <dcoutts_> ah
04:43:52 <dcoutts_> presumably because it adds a real main symbol
04:43:58 <cjs> And then when we get into wanting to run unit tests, well....
04:44:14 <cjs> Hm. You think that that's what it's doing?
04:44:30 <boegel> @seen gwern
04:44:30 <lambdabot> I saw gwern leaving #darcs, #xmonad and #haskell 1d 17h 26m ago, and .
04:44:37 <boegel> hmm
04:44:49 <cjs> I can check this. I'm just right now tweaking my build system to put .o files that use -main-is elsewhere. I.e., I have two copies, the non-main one and the main one.
04:45:17 <cjs> I was just lucky that I'd never happened to be building a program where a module was simultaneously built as a program and was used by something else.
04:45:32 <mattam> FunctorSalad: { s || Q:S = T } is an operator that builds an equality between s and s coerced by Q.
04:47:28 <cjs> Anyway, what I'm hoping to be able to do, and you might be able to give me some advice on this, is to be able to run my unit tests using compiled code, rather than interpreted, as much as possible.
04:47:50 <skorpan> > nub [1, 1, 1, 1, 1]
04:47:51 <lambdabot>   [1]
04:48:56 <Cale> > nub "mississippi"
04:48:57 <lambdabot>   "misp"
04:49:47 <FunctorSalad> mattam: ahhhhh thanks, so the "=" binds stronger than the ":" ;-)
04:49:54 <ylastman> hello.  Is there a standard version of Haskell?
04:50:07 <cjs> Haskell 98, yes.
04:50:09 <Botje> there's two, in fact
04:50:13 <Botje> haskell 98 and haskell'
04:50:18 <Botje> haskell' is in development
04:50:20 <mattam> FunctorSalad: Yeah, see a few pages later.
04:50:21 <Cale> Haskell' isn't finished.
04:50:24 <cjs> Don't forget Haskell 1.4! :-)
04:50:32 <ylastman> I am interested in knowing if I do a program on windows, do I have to change anything on linux?
04:50:48 <Cale> Yeah, Haskell 1.4 is probably a better standard than '98, but too bad it no longer has any implementations.
04:50:59 <Cale> ylastman: Probably not much...
04:51:10 <Cale> ylastman: Except obvious things regarding file paths.
04:51:18 <sclv> ylastman: you should use ghc on both as your compiler.
04:51:20 <cjs> ylastman: For me, though going the other way, I've found Haskell incredibly portable.
04:51:22 <lightstep> or if you use the win32api
04:51:54 <sclv> in general, you can do almost everything you can in windows on unix, but not the other way around always...
04:52:08 <ylastman> thanks!  I just wandered on Haskell a day ago.  It reminds me of pascal alot.
04:52:23 <BONUS> lol .. pascal?
04:52:26 <BONUS> how so
04:52:35 <EvilTerran> well, both're indentation-sensitive
04:52:41 <EvilTerran> both have list comprehensions
04:52:45 <quicksilver> both strongly typed and highly structured
04:52:48 <ylastman> things work right unlike when I do things in C/C++ LOL
04:52:53 <BONUS> hm
04:52:57 <Botje> pascal had list comprehensions?
04:52:58 <cjs> Both are bondage and discipline languages!
04:52:58 <Cale> EvilTerran: ... what? Pascal has list comprehensions?
04:53:02 <ylastman> it gets to the point
04:53:04 <Botje> I WAS CHEATED OUT OF LIST COMPREHENSIONS?!
04:53:08 <BONUS> are we talking delphi or pascal here
04:53:08 <sclv> the typed and structured thing sounds right, but I don't remember list comprehensions...
04:53:22 <ylastman> regular pascal
04:53:26 <Cale> Also, I don't remember Pascal being indentation sensitive.
04:53:32 <cjs> It was a joke, dudes. Pascal was never indentation-sensitive.
04:53:33 <BONUS> yeah its not
04:53:37 <BONUS> it has begin end things
04:53:37 <ylastman> lol
04:53:37 <BONUS> ah
04:53:38 <BONUS> haha
04:53:56 <ylastman> how long you all been using haskell?
04:54:05 <cjs> Man, I have never seen a channel so full of smart people tweaked so easily.
04:54:07 <EvilTerran> Cale, er, i thought he said python <.<  .>.>
04:54:16 <Cale> I've been using it around, oh, 5 or 6 years?
04:54:22 <BONUS> me, around 5 months
04:54:26 <sclv> :-p
04:54:31 <EvilTerran> Cale, python's the one people usually think is haskell-like
04:54:35 <Cale> right.
04:54:37 <ylastman> what languages did you all come from?
04:54:43 <EvilTerran> so i read what i expected to read rather than what was written
04:54:44 <Cale> EvilTerran: I figured you might have confused the two :)
04:54:52 <BONUS> english, haha
04:54:58 <ylastman> haha
04:55:05 <cjs> Me, six months.
04:55:20 <ylastman> any books you all can recommend?
04:55:41 <cjs> From ruby, and Java (eww!) before that. I like the Graham Hutton book.
04:55:53 <sclv> real world haskell is almost in print -- and you can read it online at the moment in its entirety
04:56:02 <Cale> ylastman: At the time I started learning Haskell? I'd used Basic, then C and C++, Pascal, Perl, a touch of PHP (enough to hate it), Java, Scheme, and a number of others to varying extents.
04:56:14 * Myoma cries - pigeonhole principle is evil
04:56:21 <Cale> Myoma: oh?
04:56:25 <EvilTerran> acornbasic on a BBC micro, then C, perl, SML, and haskell, here
04:56:48 <ylastman> whoaaa you all have a vast knowledge of languages!
04:56:51 <Botje> Myoma: indeed. equal rights for pigeons!
04:56:59 <Botje> ONE PIGEONHOLE PER PIGEON
04:57:09 <Botje> or better yet
04:57:11 <Botje> FREE THE PIGEONS!
04:57:14 <quicksilver> pascal -> logo -> basic -> z80 asm -> C -> "Object C" -> C++ _> Lisp -> Perl -> ML -> Haskell
04:57:15 <EvilTerran> then the uni forced java, oberon (the descendant of pascal that got dropped on its head as a baby), and caml on me
04:57:19 <BONUS> hehe w00t language listings
04:57:19 * Myoma tries to prove it all day
04:57:20 <sclv> ylastman: they're all roughly alike in the imperative side...
04:57:21 <quicksilver> plus a few side-alleys.
04:57:23 <ylastman> Any negatives about Haskell a noob should know about?
04:57:23 * Cale stuffs pigeons into people's mailboxes.
04:57:33 <Myoma> presumably its' possible by induction on something
04:57:34 * EvilTerran prefers the generalised pidgeonhole principle
04:57:59 <Cale> ylastman: Well, not that you should be too worried about. There are minor annoyances which most of us would like to change at some point.
04:58:11 <Cale> ylastman: There are also places where Haskell could develop.
04:58:13 <EvilTerran> "distributing N items into M containers, at least one container will contain at least ceil(N/M) items"
04:58:16 <BONUS> i did pascal -> javascript -> php -> java -> c -> python -> ruby -> haskell
04:58:22 <Botje> ylastman: haskell makes you hate how other languages suck.
04:58:34 <lightstep> ylastman, numeric coercion in haskell sucks
04:58:38 <Cale> I picked up python and ruby shortly after Haskell, but didn't do much with them.
04:58:48 <BONUS> im thinking of picking up erlang
04:58:53 <BONUS> although the syntax is butt ugly ugh
04:58:57 <Cale> Numeric coercion in Haskell is nonexistant, and that's usually a good thing :)
04:59:00 <Myoma> lightstep: Have you tried to fix it? I had a god with typeclasses but didn't get very far
04:59:04 <sclv> logo -> basic -> pascal -> C -> C++ -> Java -> Scheme -> smidges of prolog & asm in school -> php (in the workplace, yeech) -> haskell.
04:59:05 <EvilTerran> lightstep, i'd say it sucks less than the brokenness other languages engage in
04:59:20 <ylastman> it seems everyone tried python, ruby, and pascal and left.
04:59:29 <sclv> ohn, and perl somewhere too -- i hardly think of it as a language...
04:59:34 <ylastman> that is a good thing, because it mean I am doing something right
04:59:35 * EvilTerran also picked up javascript and VBA6 somewhere along the way
04:59:36 <BONUS> from using haskell, i curse everytime someone sets a variable to something and then changes it later
04:59:38 <BONUS> in other languages
04:59:45 <Myoma> ylastman: If we could just get people to not use them in the first place.. :)
04:59:50 <sclv> more like a set of magic incantations
04:59:58 <Botje> changing variable values should be a compile-time error :o)
05:00:00 <ylastman> yea but they got a great marketing team
05:00:03 <EvilTerran> i plan to learn python (for employability) and agda (for mind-breaking) at some point5
05:00:05 <FunctorSalad> ylastman: (scrolling down) the haddock usually says something about portability in the upper right corner. but no idea how authorative that notice is
05:00:06 <sclv> ?quote fromIntegral
05:00:07 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
05:00:22 <Cale> Eh, python and ruby are nice as far as imperative OO languages with no real type system that aren't Smalltalk go, but they're not exciting languages.
05:00:36 <lightstep> ?hoogle Double -> Int
05:00:36 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
05:00:37 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
05:00:37 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
05:00:58 <ylastman> how does haskell handle memory?
05:01:04 <Deewiant> well
05:01:06 <nornagon> magically
05:01:10 <EvilTerran> ylastman, that's implementation-dependent
05:01:10 <Botje> tenderly
05:01:10 <pao> Cale: nice... should be saved as a lamdabot citation :-)
05:01:15 <lightstep> Myoma, not really, i don't need it that much
05:01:16 <EvilTerran> unspecified by the report
05:01:23 <cjs> What's the program to dump info from an hi file?
05:01:29 <Myoma> lightstep: me neither.. it was kind of fun though
05:01:42 <Myoma> lightstep: in any case, I didn't end up with something useful
05:01:45 <ylastman> awww I see.
05:01:46 <Cale> ylastman: In fact, the Haskell standard says nothing about how expressions are actually evaluated, only what they ought to evaluate to.
05:01:46 <ylastman> :)
05:01:54 <EvilTerran> ylastman, but the way GHC does it is described in excruciating detail somewhere
05:02:04 <nornagon> EvilTerran: in the source
05:02:09 <nornagon> ;)
05:02:29 <ylastman> thanks
05:02:32 <EvilTerran> i mean in the commentary
05:02:44 <Cale> ylastman: To a good approximation, memory is allocated when data constructors are used to build values.
05:02:47 <ylastman> Im gonna be using it on XP (yea don't hate me) and ubuntu
05:03:02 <EvilTerran> nornagon, ylastman: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage
05:03:03 <lambdabot> Title: Commentary/Rts/Storage - GHC - Trac
05:03:21 <EvilTerran> there's your answer in more detail than you could possibly want at this stage :P
05:03:27 <Cale> As a beginner, I wouldn't worry about the details of memory management...
05:03:29 <guenni> hi has anybody managed to install regex-posix on win32?
05:03:37 <ylastman> thanks
05:03:39 <Cale> EvilTerran: ehehe
05:04:02 <Cale> (oh, there are useful links though)
05:04:15 <ylastman> what is the direction to go to create something like a chat server in haskell?
05:04:28 <Myoma> ylastman: You just do it
05:04:34 <nornagon> Network and Control.Concurrent, i guess.
05:04:36 <Cale> Well, you will want to get comfortable with I/O, and the network library.
05:04:39 <Myoma> (not kidding, it's that easy)
05:04:47 <ylastman> that sounds to easy!
05:04:49 <EvilTerran> you might want the IRC parsing package off hackage, if you're doing IRC
05:04:53 <FunctorSalad> ylastman: I think there's an irc package on hackage. maybe start from that
05:05:01 <Myoma> You don't need to learn how to make a fixed size buffer to stream a polling network read onto
05:05:06 <Myoma> you just code the actual program
05:05:07 <EvilTerran> it does parsing and command-construction for you
05:05:33 <ylastman> what!  that is impossible.  what about the server lowlevel code?
05:05:44 <lightstep> the compiler generates it
05:06:08 <Myoma> I'm not sure what you mean exactly, I'm just comparing something I read in haskell with something I wrote ages ago in C
05:06:10 <Cale> ylastman: I highly recommend playing around with pure programs that just calculate things without actually *doing* much first, and using the GHCi prompt as a kind of UI for free.
05:06:34 <Cale> ylastman: Once you get comfortable with basic values and types, learning to do I/O is easier.
05:06:39 <ylastman> ok will do :)
05:07:12 <Cale> (though I'm sure some people would disagree with me and tell you to just jump in...)
05:07:13 <ylastman> thank you all so much!  I think I will stick with this language.  What a nice community. I don't see the arrogance like the C/C++ people lol
05:07:25 <Cale> In any event, feel free to stick around and ask lots of questions.
05:07:32 <ylastman> oh I will be back :)
05:07:38 <Cale> We were all beginners once, and understand that it can be confusing :)
05:07:43 <ylastman> thank you all!
05:07:58 <ylastman> I read the hardest thing about haskell is forgetting what you know!
05:08:03 <Cale> Yeah.
05:08:15 <ylastman> im gonna go from the basics and work my way up.
05:08:20 <ylastman> See you guys later and thanks again
05:08:25 <Deewiant> and it's also the hardest thing about learning any other language after learning haskell ;-)
05:08:26 <Cale> It's a very different language, if you're used to the sort where you have lots of mutable variables whose values you change all the time.
05:09:23 <ylastman> one more question how can you make a game in haskell if values you can't change?
05:09:39 <Cale> Oh, well, parameters to functions can change :)
05:09:45 <ylastman> OH!
05:09:52 <Cale> In the sense that a function can call itself with different parameters.
05:09:54 <ylastman> you scared me there lol
05:10:20 <Cale> Wherever a variable is in scope, its value does not change though.
05:10:53 <Cale> Also, there are ways to use mutable state, in IO computations, and in other places, but you should learn to do things without it first :)
05:11:04 <ylastman> I understand
05:11:22 <ylastman> ha you explained with no mystery talk.  THANKS
05:11:44 <Cale> CompanionCube! Sorry for putting you in the Aperture Science Emergency Intelligence Incinerator!
05:13:15 <BONUS> haha
05:13:39 <Cale> ylastman: No problem!
05:16:52 <lightstep> wow, to me it sounded just like mystery talk
05:16:59 <lightstep> :)
05:19:11 <Cale> lightstep: hehe
05:19:24 <Cale> lightstep: Is there anything you'd care for me to explain?
05:20:10 <lightstep> no, haskell it too different to explain. you can only point to books and tutorials and hope for the best
05:20:22 <Myoma> huh, haskell is very simple
05:22:52 <lightstep> and all that about immutable variables variables. we can just programs, and see that variables are only: (1) let bindings (2) loop counters (3) actors, and then argue we have all as different features
05:23:16 <lightstep> s/just/analyse/
05:23:46 <BeelsebobWork> gah, the current nbodies code is horrible
05:29:55 <Myoma> Theorem 1.1. If n + 1 objects are put into n boxes, then at least one box contains two or more objects.
05:29:55 <Myoma> Proof. Trivial.
05:29:57 <Myoma> :/
05:30:29 <BeelsebobWork> ?
05:30:31 <ckyle_> the pigeonhole principle.
05:31:51 <loop> Myoma, http://planetmath.org/encyclopedia/ProofOfPigeonholePrinciple.html
05:31:52 <loop> :-)
05:31:55 <lightstep> you can prove that by induction
05:31:59 <lambdabot> Title: PlanetMath: proof of pigeonhole principle
05:32:03 <Myoma> lightstep: no I can't!
05:32:06 <BeelsebobWork> the average number of items per box is (n+1) / n, which is greater than 1.  At least one of the numbers being averaged must be greater than the average, or all the numbers being averaged must be equal.  In the latter case, one box contains greater than 1 obviously, in the former case at least one again
05:32:10 <BeelsebobWork> tit is trivial
05:32:16 <lightstep> Myoma, why not?
05:32:18 <Myoma> loop, yeah, it's a nice proof
05:32:21 <BeelsebobWork> and yeh, induction would give an easy proof too
05:38:39 <ckyle_> i would use a simple permutations/combinatorial argument.
05:38:46 <ckyle_> vs. induction
05:41:37 <Myoma> ckyle_: yeah permutations
05:41:52 <Myoma> I don't like writing out lemmas about permutations :p
05:43:24 <Myoma> I suppose I must
05:49:32 <kaol> Now that I know TH better, I rather like it. It's like a hammer and I'm seeing nails everywhere, now.
05:50:35 <Myoma> kaol: What will you do with TH?
05:51:05 <mancalledhash> hey all.  a few of you mentioned that Haskage has an IRC module/package.  Uh where can I find Haskage at?  I tried Google and Yahoo
05:51:27 <Myoma> It's hackage
05:51:30 <Myoma> ?hackage
05:51:31 <lambdabot> http://hackage.haskell.org
05:51:33 <mancalledhash> LOl
05:51:33 <Myoma> this is it
05:51:37 <mancalledhash> ok we not gonna mention it
05:51:41 <Myoma> :)
05:51:45 <Myoma> mention what?
05:51:56 <mancalledhash> mention I spelt it wrong
05:51:58 <mancalledhash> thanks again
05:52:12 <mancalledhash> <<< Noob Status is Not Leaving No Way Soon
05:52:29 <Myoma> aw.... I didn't mean to scare them away
05:52:56 <lightstep> it was ylastman
05:53:59 <kaol> Myoma: for marshalling XML and creating XSLT processors in haskell
05:57:12 <ckyle_> will learning Haskell grow hair on my chest? I'm a C programmer.
05:57:36 <Myoma> ?faq will learning Haskell grow hair on my chest?
05:57:36 <lambdabot> The answer is: Yes! Haskell can do that.
05:57:53 <hjon> how do i send eof to ghci when using hGetLine stdin? ctrl-d just produces ^D
06:00:00 <kosmikus> Eelis: the simplest solution should be to say \arrayhs just before \begin{document}
06:00:40 <Eelis> kosmikus: \arrayhs is new to me. i will look it up. thanks
06:00:54 <ckyle_> Are Haskell and LISP similar, or closely related? thx
06:01:03 <quicksilver> they are not similar.
06:01:07 <quicksilver> They are certainly related.
06:01:14 <quicksilver> But LISP is untyped and impure
06:01:25 <Lord_Illidan> Hi everyone
06:01:28 <quicksilver> whilst typing and purity are two of haskell's most obvious properties.
06:01:59 <ckyle_> so if i was very interested in LISP, i might be even more interested in Haskell? I'm looking for an excuse to learn something different...
06:02:18 <quicksilver> I think so, yes.
06:02:31 <quicksilver> Unless the part about LISP you really loved was self-modifying code and macros.
06:03:13 <Eelis> kosmikus: that's perfect! thanks again
06:04:01 <Lord_Illidan> I'm wondering about something rather basic. I am trying to write a small program that given a list, eg, "abcdefa", and a letter, eg: 'a', gives back a tuple containing the number of occurences of a and the list containing no values of a
06:04:40 <Lord_Illidan> so, eg, occurences 'a' "abcdefa" = (2,"bcdef")
06:04:46 <therp_> :t  partition
06:04:47 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:05:07 <Lord_Illidan> Now, I can get the seperate parts easily enough, and even make a tuple that way
06:05:22 <Lord_Illidan> But it seems wasteful, as it's recursing over the list twice
06:05:41 <therp_> Lord_Illidan: foo l = (length &&& id) . partition (== letter)
06:05:54 <therp_> :t (&&&)
06:05:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:06:04 <Eelis> :t first
06:06:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:06:07 <ckyle_> that looks scray
06:06:11 <ckyle_> scary
06:07:22 <Lord_Illidan> thedward, what does that code do?
06:07:27 <lightstep> @pf \c s -> let (l, r) = partition (== c) s in (length l, r)
06:07:27 <lambdabot> Maybe you meant: bf pl
06:07:35 <lightstep> @pl \c s -> let (l, r) = partition (== c) s in (length l, r)
06:07:35 <lambdabot> (line 1, column 13):
06:07:35 <lambdabot> unexpected "("
06:07:35 <lambdabot> expecting "()", natural, identifier or "in"
06:08:09 <lightstep> @pl \c s -> (\(l, r) -> (length l, r)) partition (== c) s
06:08:10 <lambdabot> (length (fst partition), snd partition) . (==)
06:08:15 <lightstep> @pl \c s -> (\(l, r) -> (length l, r)) (partition (== c) s)
06:08:16 <lambdabot> (first length .) . partition . (==)
06:08:26 <therp_> Lord_Illidan:  hmm.. give you a type error.. &&& isn't the right operator here..
06:08:48 <Deewiant> woot, @pl knows about 'first'
06:08:51 <lightstep> > (first length .) . partition . (==) 'a' "abracadabra"
06:08:53 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
06:08:59 <Lord_Illidan> Can I recurse over a tuple?
06:09:01 <scorch_> why can't I do something like this? http://hpaste.org/10312
06:09:11 <Deewiant> lightstep: needs more brackets
06:09:34 <Deewiant> > ((first length .) . partition . (==)) 'a' "abracadabra"
06:09:35 <lambdabot>   mueval: Prelude.read: no parse
06:09:41 <Deewiant> sigh
06:09:51 <Deewiant> I guess > still doesn't know about Control.Arrow
06:09:56 <lightstep> scorch_, you have two constructors named SeqType
06:10:16 <therp_> Lord_Illidan: foo l = (length *** id) . partition (== letter)
06:10:23 <lightstep> each data type should have different data construtors
06:10:24 <therp_> err s/letter/ll/
06:10:30 <Deewiant> (*** id) = first
06:10:39 <therp_> Deewiant: hm thnx
06:11:26 <therp_> Deewiant: ah now the type sig from eelis makes sense.. I looked at it briefly.
06:11:35 <lightstep> Lord_Illidan, you can't recurse over a tuple. the (***) operator applies two different functions to the two components
06:11:45 <scorch_> lightstep: how would I do to make a second data type contain a SeqType in it then?
06:12:10 <lightstep> scorch_, the syntax is data Profile = SeqType [[(Char, Float)]] Int String
06:12:14 <lightstep> err
06:12:21 <lightstep> data Profile = Prof SeqType [[(Char, Float)]] Int String
06:12:50 <lightstep> where you can change "Prof" to any name you want - it's the function that constructs profiles
06:13:10 <lightstep> sometimes that type name is used, "Profile" in this case
06:13:32 <lightstep> also for MolSeq, it needs to have a data constructor
06:15:05 <scorch_> lightstep: aha, thanks! One more thing; if I send a 'Profile' as an argument to a function, can I extract say the String using (_,_,_a)?
06:15:29 <lightstep> no, that pattern will be "f (Prof _ _ a) = ..."
06:17:19 <scorch_> and to create something of that datatype?
06:20:03 <lightstep> Prof will be a function that creates that data type (try printing its type in ghci)
06:20:05 <scorch_> (Prof [[('a', 1)]] 10 "foo")?
06:20:34 <lightstep> yeah
06:23:52 <scorch_> lightstep: thanks
06:24:36 <lightstep> welcome
06:27:32 <BeelsebobWork> @where ghc api
06:27:32 <lambdabot> http://haskell.org/ghc
06:27:48 <BONUS> hey
06:27:50 <BONUS> is equatable
06:27:51 <BONUS> a word
06:28:08 <BONUS> could you say that something belonging to the Eq class is equatable
06:28:14 <BeelsebobWork> equate |iËˆkwÄt| ...
06:28:15 <BeelsebobWork> DERIVATIVES
06:28:15 <BeelsebobWork> equatable |-tÉ™bÉ™l| |É™ËˆkweÉªdÉ™bÉ™l| adjective
06:28:18 <BeelsebobWork> looks good to me
06:28:33 <BONUS> kewl
06:29:17 <BeelsebobWork> @go GHC API docs
06:29:20 <lambdabot> http://www.haskell.org/ghc/documentation.html
06:29:20 <lambdabot> Title: The Glasgow Haskell Compiler
06:31:29 <Myoma> @w80 equatable
06:31:30 <lambdabot> No match for "equatable".
06:31:39 <Myoma> @w80 comparable
06:31:40 <lambdabot> *** "comparable" wn "WordNet (r) 2.0"
06:31:40 <lambdabot> comparable
06:31:40 <lambdabot>      adj 1: able to be compared or worthy of comparison [ant: {incomparable}]
06:31:40 <lambdabot>      2: conforming in every respect; "boxes with corresponding
06:31:40 <lambdabot>         dimensions"; "the like period of the preceding year" [syn:
06:31:42 <lambdabot>          {corresponding}, {like}]
06:32:13 <lilac_> comparable to me means more like Ord instance than Eq instance :-/
06:33:02 <lilac_> @w80 partitionable
06:33:03 <lambdabot> No match for "partitionable".
06:33:07 <ziman> http://dictionary.reference.com/search?q=equatable
06:33:08 <lambdabot> Title: equatable definition |Dictionary.com
06:33:47 <ziman> looks like a valid word
06:43:00 <Eelis> how come the foldl/foldr comes in a duo, but there's only one foldM (and not foldlM/foldrM)?
06:43:02 <purestorm> Hi, what is the reason that some local variables are not visible in ghci when setting a breakpoint and executing until there?
06:44:06 <kaol> @src foldM
06:44:06 <lambdabot> foldM _ a []     = return a
06:44:06 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
06:44:34 <byorgey> Eelis: good question.
06:45:02 <Saizan> ?type foldM
06:45:03 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
06:45:58 <Saizan> a foldrM with a similar type wouldn't be lazy as the normal foldr
06:46:31 <Saizan> ?type \f -> foldr f . return -- i use this when i need a foldrM-like
06:46:32 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> m a1 -> m a1) -> a1 -> [a] -> m a1
06:47:56 <Eelis> i see
06:48:17 <EvilTerran> purestorm, come execution time, some local variables may have been optimised away into nothingness
06:48:46 <purestorm> EvilTerran: How can I disable this? I mean for debugging, they are useful.
06:49:04 <purestorm> Especially given the fact that you cannot dump out stuff arbitrarily in Haskell.
06:49:13 <EvilTerran> i'm afraid i don't know
06:49:18 <EvilTerran> not really familiar with the debugger
06:49:31 <EvilTerran> that first comment was only an educated guess, anyway
06:49:51 <quicksilver> ghci doesn't do that kind of optimisation
06:50:00 <quicksilver> (as long as you're not debugging compiled code)
06:50:40 <quicksilver> purestorm: I don't really recommend debugging that way.
06:50:49 <purestorm> How else?
06:50:53 <quicksilver> I recommend debugging by factoring your code into small functions you call from ghci
06:51:01 <purestorm> hm
06:51:02 <quicksilver> and calling them at the values which appear to give the wrong answer
06:51:06 <purestorm> OK
06:51:19 <lilac_> http://metafoo.co.uk/howisioformed.html
06:51:26 <lambdabot> Title: How is io formed? - Yahoo! Answers
06:52:30 <FordCortina> this code is based on http://article.gmane.org/gmane.comp.lang.haskell.cafe/29517/, can anybody answer this question? http://hpaste.org/10314
06:52:52 <byorgey> lilac: hehe =)
06:53:05 <quicksilver> lilac: I like the way it is in the 'pregnancy' subsection of Yahoo! Answers
06:53:08 <FordCortina> This vector type he defines doesn't seem to compute its length, so i don't really see the point
06:54:52 <Myoma> FordCortina: did you read R* is the new [a] ?
06:55:10 <FordCortina> ive read some slides with that title.
06:55:20 <Myoma> yeah
06:55:56 <FordCortina> i think i understood about 10% of it. RStar is a parametric polymorphic expression of Empty/Build style types, right?
06:55:59 <Myoma> Nil :: Star f r r -- it's r not Zero
06:56:25 <Myoma> there are uses for it not being zero, in particular the Fins
06:56:30 <Myoma> Fin Family
06:56:51 <mxc> hello everyone
06:57:08 <mxc> could anyone point out a decent tutorial on FRP techniques?
06:57:22 <byorgey> FordCortina: in a dependently typed language, if you constrained vec to have type Vector n a (i.e. if you passed it as an argument to a function expecting a Vector) it would compute the index to be Suc Zero.
06:57:27 <Myoma> FordCortina, if you were able to write vec :: Vector _ Integer
06:57:33 <mxc> from apractical persepctive?  like if RWH had a FRP chapter
06:57:34 <byorgey> right.
06:57:34 <Myoma> then it would infer (Suc Zero)
06:57:42 <Myoma> since you can't write that, you have actually put Suc Zero yourself
06:57:45 <FordCortina> Myoma: aha
06:57:56 <FordCortina> im with you now... i tried to do that in haskell
06:58:02 <FordCortina> but i guess that's not possible heh
06:58:06 <byorgey> yeah, Haskell can't do that though =)
06:58:06 <Myoma> time to install Coq :p
06:58:24 * Myoma tries to get Ford to the dark side
06:58:31 <byorgey> FordCortina: if you're interested in playing around with it in a dependently typed language, try Agda
06:58:38 <byorgey> it's very similar to Haskell so easy to pick up
06:59:08 <Lord_Illidan> Hi, I've posted the following code http://hpaste.org/10315
06:59:10 <FordCortina> yeh... i have... it that im trying to take ideas from Agda and simulate them as best as possible using Haskell
06:59:21 <byorgey> FordCortina: ah, got it
06:59:29 <Lord_Illidan> Can anyone tell me if occ and finishedList in that code recalculate r?
06:59:52 <byorgey> Lord_Illidan: no, r will only be calculated once
06:59:54 <byorgey> it is shared
06:59:56 <quicksilver> mxc: No.
07:00:00 <Lord_Illidan> byorgey, ah good, thanks
07:00:01 <dblazakis> FordCortina: what have you simulated this far?
07:00:09 <dblazakis> *thus
07:00:15 <quicksilver> mxc: (I am not aware that any such tutorial exists; if you find one I'd like to see it too)
07:00:24 <byorgey> Lord_Illidan: whenever you give something a name in Haskell it will be shared and only calculated once (the first time it is needed).
07:00:36 <dmwit_> Lord_Illidan: It's implementation-specific, but I doubt very many implementations will calculate r twice there.
07:00:41 <mxc> quicksilver - will pass it on.  i feel like it would be fantastic for something i'm tying to do, if only i could understand it
07:00:44 <Lord_Illidan> I'm using ghc
07:00:51 <byorgey> dmwit_: ah, good point
07:00:55 <Lord_Illidan> That's lazy programming, right?
07:01:07 <byorgey> I always forget that Haskell is technically *non-strict*, not lazy =)
07:01:20 <FordCortina> dblazakis: I can detect left-recursion in recursive descent parsers at compile time. Surprisingly I can only to do this with MPTCs and FDs and not with GADTs
07:01:26 <Lord_Illidan> Or not..perhaps I am more confused than I let on
07:01:40 <byorgey> Lord_Illidan: yes, lazy evaluation ==> only evaluating r once.
07:01:44 <geezusfreeek> Lord_Illidan: ghc generally does not recalculate things
07:01:59 <dmwit> Wait, this isn't really related to laziness, is it?
07:02:13 <dmwit> Laziness says when something will be evaluated, not how many times.
07:02:20 <dblazakis> FordCortina: that's really cool, i just started playing with "almost dependent typed" things -- do you have any sample code?
07:02:28 <Philonous> lazyness = non-strictness + memoization
07:02:35 <byorgey> dmwit: hm, I thought sharing was part of the definition of laziness
07:02:49 <dmwit> Okay, maybe so.
07:02:52 <dmwit> =)
07:02:55 <geezusfreeek> i just say call-by-need when i need to be unambiguous
07:03:02 <byorgey> it was in that paper we read for plclub last week, at least =)
07:03:03 <FordCortina> dblazakis: I do have some, but I'm in the middle of writing up this work now
07:03:16 <dmwit> byorgey: Right. =)
07:04:09 <quicksilver> dmwit, byorgey : http://www.haskell.org/haskellwiki/Lazy_vs._non-strict
07:04:10 <lambdabot> Title: Lazy vs. non-strict - HaskellWiki
07:04:21 <Myoma> FordCortina, if you want a sneaky trick
07:04:24 <quicksilver> (In my experience these terms are used loosely and inconsistently)
07:04:32 <FordCortina> Myoma: :) prey tell
07:04:34 <dblazakis> FordCortina: i was playing with the thrist samples and can detect poorly formed stack programs (in the Cat example) but that's using the standard GADTs method
07:04:38 <Myoma> http://hpaste.org/10314#a1
07:04:54 <Myoma> (Maybe the same trick can be done a bit more elegantly, but that at least works)
07:05:13 <dmwit> quicksilver: Okay, so laziness does imply sharing.  Good.
07:05:19 <Myoma> oh you can put asVector back to asVector = asVector or asVector = undefined
07:05:23 <Lord_Illidan> Thanks for the link quicksilver
07:05:29 * Myoma (was trying a couple of things)
07:05:38 <FordCortina> oh thats cool, thanks Myoma
07:06:01 <Myoma> oh
07:06:01 <Myoma> asVector :: Vector x y -> Vector x y
07:06:01 <Myoma> asVector = id ; vec  = asVector ((VCons 1) :* Nil)
07:06:03 <Myoma> that's all you need
07:06:25 <Saizan> Philonous: memoization can be misleading, only CAFs are guaranteed to be shared in a lazy language
07:06:54 <Myoma> infers, vec :: (Num t) => Vector (Suc Zero) t
07:07:14 <byorgey> Myoma: ah, nice!
07:07:41 <Myoma> I was trying to do it by putting them in a SCC, but it's actually easier than that
07:07:46 <purestorm> How can I apply a pure function to an (IO t)?
07:07:50 <purestorm> in GHCI that is
07:08:14 <Myoma> purestorm: what is the type of te pure function?
07:08:16 <dmwit> purestorm: You lift the pure function into IO first.
07:08:27 <geezusfreeek> purestorm: you can bind the value of an action with x <- myIOAction
07:08:27 <dmwit> :t (>>=)
07:08:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:08:37 <geezusfreeek> purestorm: or you can use fmap
07:08:47 <dmwit> :t liftM
07:08:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:08:49 <geezusfreeek> or all kinds of things, depending what you need exactly
07:09:19 <purestorm> I have a function to extract an entry from a record-syntax created data value.
07:09:25 <geezusfreeek> purestorm: just fyi, liftM = liftA = fmap
07:09:58 <BeelsebobWork> uhhhh geezusfreeek+
07:10:00 <BeelsebobWork> ? even
07:10:09 <geezusfreeek> BeelsebobWork: hmm?
07:10:16 <BeelsebobWork> liftM = liftA = fmap?
07:10:21 <geezusfreeek> BeelsebobWork: yes
07:10:30 <geezusfreeek> :t liftM
07:10:32 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:10:34 <geezusfreeek> :t liftA
07:10:35 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
07:10:37 <geezusfreeek> :t fmap
07:10:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:10:38 <dmwit> BeelsebobWork: In *most* cases.
07:10:48 <BeelsebobWork> dmwit: sure -- but not in all
07:11:20 <dmwit> BeelsebobWork: Let's avoid the exotic cases for now; we're trying to help a confused new guy. =)
07:11:22 <Stinger_> yeah but typing out the approx. equals sign is a pita
07:11:27 <BeelsebobWork> dmwit: k
07:11:37 <BeelsebobWork> dmwit: just I would get more confused by that actually
07:11:49 <FordCortina> dblazakis: thanks ill have a look at thrist, ive never heard of it before
07:11:50 <Saizan> purestorm: http://www.haskell.org/haskellwiki/Monads_as_computation
07:11:51 <BeelsebobWork> I would instantly go "so why are they named differently then????"
07:11:51 <lambdabot> Title: Monads as computation - HaskellWiki
07:12:08 <geezusfreeek> it helped me when i first learned it
07:12:19 <dblazakis> FordCortina: Myoma actually gave me the link
07:12:24 <geezusfreeek> since i understood fmap but not liftA or liftM quite as well
07:13:10 <geezusfreeek> at least i'm not trying to argue about (.) :P
07:13:14 <BeelsebobWork> hehe
07:13:20 <Myoma> oh yeah thrists are neat - you can write a compiler with them and get a correctness proof for free
07:13:44 <Myoma> the epigram pearl and fp lunch has it
07:13:50 <FordCortina> Myoma: do you think there's any scope for using the indices computed in Stellar types with haskell class instances?
07:14:02 <Myoma> FordCortina: I have no idea what that means
07:14:26 <FordCortina> Myoma: say I want treat empty vectors differently from non-empty ones at runtime?
07:14:27 <Myoma> what are Stellar types?
07:14:55 <FordCortina> Stellar types = types that use RStar
07:15:03 <Myoma> if you want to treat them different at _runtime_ and not _compile time_, don't encode the length in the type
07:15:24 <Myoma> ah ok
07:15:36 <FordCortina> i guess i ment compile time, what i meant was *not* doing a runtime check
07:15:40 <Myoma> FordCortina, we should collect these terms somewhere...
07:16:16 <Myoma> yes I'm pretty sure that's possible -- I would not be surprised if I tried it out and it all went horribly wrong though
07:16:41 <Myoma> that happens sometimes :)
07:16:42 <FordCortina> that's what i feared :) it happens with most of my experiments
07:16:47 <Myoma> hehe
07:17:44 <Lord_Illidan> Any comments about my small "histogram"? http://hpaste.org/10315#a1
07:20:51 <Myoma> Lord_Illidan: That is fine but it can be written more efficiently using trees instead of lists
07:21:05 <Myoma> (Data.Set is an implementation of trees)
07:22:45 <Myoma> actually I think I should have said Data.Map
07:23:00 <Philonous> Saizan: Thanks for the hint. Though I don't quite understand (yet) what the implications are
07:23:36 <mrh> how can I retrieve the constructor type name if I have defined my own datatype as data MS = A { a :: String, b::String} | B { c :: String, d :: String} ?
07:23:44 <Lord_Illidan> Thanks Myoma
07:23:52 <Myoma> mrh: write a function by pattern matching to return the name
07:25:12 <mrh> Myoma: ok there's no easier way? I just need to type check..like A /= B
07:25:42 <quicksilver> working with constructor names directly is breaking the fourth wall
07:25:43 <geezusfreeek> wait, don't the monad laws mandate fmap f xs == xs >>= return . f ?
07:26:20 <mrh> quicksilver: the fourth wall ?
07:26:28 <Myoma> mrh: It's so so easy, there could not _be_ an easier way
07:26:30 <geezusfreeek> what are the edge cases where fmap /= liftM ?
07:26:39 <geezusfreeek> *exceptional
07:26:42 <mrh> Myoma: aha ok.
07:27:13 <luite> > map (head &&& length) . group $ sort "histogram test"
07:27:14 <lambdabot>   mueval: Prelude.read: no parse
07:27:19 <luite> :(
07:27:36 <luite> it does destroy the order of the elements in the histogram though
07:30:29 <quicksilver> geezusfreeek: Functors that aren't monads, for one.
07:30:52 <geezusfreeek> well i thought that case was too obvious to mention
07:30:59 <quicksilver> geezusfreeek: I think that's all BeelsebobWork means.
07:31:09 <geezusfreeek> ah, okay
07:31:18 <quicksilver> lists can be monads in two different ways, sort-of
07:31:25 <quicksilver> but those two ways have the same liftM/fmap
07:32:44 <mrh> Myoma: really easy would be if it would have generated a get funciton for the constructor name too. Right now I don't know how to get A or B :/
07:33:42 <luqui> mrh, what would be the type of this function?
07:34:23 <Myoma> mrh,
07:34:30 <Myoma> name the function
07:34:52 <quicksilver> mrh: google the fourth wall  if you're interested.
07:35:10 <quicksilver> but the point is, treating type names as strings is a lame dynamically types thing to do.
07:35:22 <quicksilver> (and constructor names similarly)
07:35:28 <quicksilver> mrh: what are you *actually* trying to do?
07:35:49 <quicksilver> you have two things of type M?
07:35:59 <quicksilver> and you want to check one is an 'A' and the other is a 'B' or something?
07:36:41 <mrh> yes..or actually compare them
07:37:18 <byorgey> hm, why doesn't just pattern-matching give you what you want?
07:37:23 <mrh> diff :: MS -> MS -> String diff a b | a /= b == "Not equal"
07:37:38 <mrh> that's what i want to do
07:37:50 <luqui> mrh, Oh!
07:37:52 <byorgey> oh, I see
07:37:58 <quicksilver> what do you mean by equal, though, mrh?
07:38:10 <quicksilver> is just having different constructors (A,B) enough to be not equal?
07:38:18 <quicksilver> or do you want to compare the string fields too?
07:38:18 <mrh> YES
07:38:31 <quicksilver> you don't care about the contents of the string fields?
07:38:33 <luqui> or rather, is having identical constructors enough to be the same?
07:38:34 <mrh> no
07:38:44 <mrh> just the constructors
07:38:53 <luqui> okay, you probably shouldn't use == then
07:39:08 <quicksilver> sameCons (A _ _) (B _ _) = False; sameCons (A _ _) (A _ _) = True;
07:39:13 <quicksilver> and the other two cases I missed out
07:39:24 <seanmce> how to I lambda abstract with a no arg function (this doesn't work): takesNoArgFunction (\ -> doSomething)
07:39:37 <byorgey> even better, just do  sameCons (A _ _) (A _ _) = True; another case for B B,  then sameCons _ _ = False
07:39:39 <luqui> I actually like this trick:  sameCons (A {}) (A {}) = True, ...
07:39:43 <Myoma> seanmce, doSomething
07:39:45 <quicksilver> then you can do diff :: M -> M -> String; diff a b = if sameCons a b then "Equal" else "Not Equal"
07:39:48 <Myoma> seanmce, i.e. you don't write the lambda
07:40:01 <seanmce> won't that call doSomething immediately?
07:40:10 <Myoma> seanmce, maybe, maybe not, it doesn't matter
07:40:16 <byorgey> seanmce: not until it is needed.
07:40:22 <luqui> seanmce, no!  and hooray for that!
07:40:33 <quicksilver> seanmce: there are no zero-argument functions. Or alternative "all values are zero argument functions"
07:40:33 <seanmce> in this case doSomething is spawn "program"
07:40:34 <luqui> (that is haskell's unique property)
07:40:41 <Myoma> luqui: yeah that's a nice trick
07:40:44 <byorgey> no need to simulate lazy evaulation by wrapping things in lambdas =)
07:40:50 <Myoma> I was surprised it works on non records too
07:40:56 <seanmce> i'll try it
07:41:19 <quicksilver> luqui: it is a nice trick, I guess I was trying not to blind mrh with yet more syntax :)
07:41:33 <luqui> quicksilver, right.  it's hard to resist, you know :-)
07:41:49 <mrh> quicksilver, luqui: ok..thought I didn't need a second function for comparing constructor names. I'll try this and be back with more problems later hhe :)
07:41:57 <quicksilver> it is very occasionally useful to have a 'related enum-style type' for a data; one which has corresponding constructors but no fields.
07:42:03 <quicksilver> not all that often though.
07:42:09 <seanmce> it's type matching to the return value, not the function
07:42:28 <quicksilver> seanmce: there is no difference between the return value and the function.
07:42:32 <seanmce> runOrRaiseAndDo run query afterRaise = raiseAndDo (spawn run) afterRaise
07:42:37 <luqui> typically I see that necessity as a design flaw of the sort that I am not encoding my redudancy well enough
07:42:52 <seanmce> runOrRaiseAndDo :: String -> Query Bool -> (Window -> X ()) -> X ()
07:43:08 <luqui> eg. data Foo = A String String | B String String | C String String, should actually be data FooType = A | B | C; data Foo = Foo FooType String String
07:43:09 <seanmce> wait, I messed up
07:43:23 <BONUS> is there any difference between Map.assocs and Map.toList
07:43:24 <BONUS> hm
07:43:38 <ivanm> BONUS: possibly output order?
07:43:46 <quicksilver> luqui: seomtimes. But that is only true if all the cons have the same fields.
07:43:47 <luqui> i.e. redunant constructors usually come at the same time as necessity to compare constructors...
07:43:51 <quicksilver> luqui: which is not the case in general.
07:44:10 <luqui> yeah, and in that general case, I usually don't want to compare on only constructors :-)
07:44:18 <luqui> it's an empirical observation, not a law.
07:44:18 <ivanm> BONUS: but it appears Map has a lot of duplicates anyway
07:44:36 <BONUS> yeah
07:44:58 <quicksilver> assocs is the historical name for that function
07:45:05 <quicksilver> toList is more consisten with other similar data types
07:45:11 <quicksilver> that's why they are both there, AFAIK.
07:45:23 <ivanm> quicksilver: is there a  class for datatypes like that?
07:45:35 <quicksilver> ivanm: well Foldable is the class for toList
07:45:42 <ivanm> *nod*
07:45:49 <ivanm> and for fromList?
07:45:53 <quicksilver> there isn't a class for fromList.
07:45:59 <quicksilver> it's less obvious what that would mean.
07:46:39 <byorgey> @type toList
07:46:41 <lambdabot> Not in scope: `toList'
07:48:18 <seanmce> it worked, thanks
07:50:18 <byorgey> seanmce: hooray =)
07:53:16 <FordCortina> Myoma: have you ever tried to write an instance of Show for RStar?
07:54:38 <FordCortina> im having a problem with the constraint, which basically says if the "step" function is in show, then so is Star
07:55:14 <Myoma> no I haven't, FordCortina
07:56:25 <byorgey> FordCortina: writing a Show instance for RStar sounds difficult, perhaps impossible
07:56:41 <Myoma> byorgey: oh we got a show instance for Mu the other day!
07:56:42 <byorgey> the problem is that existential type in the middle which gets hidden by the (:*), I think
07:56:47 <byorgey> Myoma: nice =)
07:56:49 <mrh> quicksilver: didn't work. error: "sameCons" is multiply defined
07:57:34 <Myoma> mm
07:57:41 <Myoma> It should be added to lambdabot I think
07:57:44 <Myoma> that would be great
07:57:58 <byorgey> FordCortina: see this, it is very related: http://heisenbug.blogspot.com/2008/08/id-like-to-see-but-do-you-want-to-show.html
07:58:00 <lambdabot> Title: don't count on finding me: I'd like to see, but do you want to Show?, http://tinyurl.com/5y3sdf
07:58:02 <Saizan> instance Show (f (Mu f)) => Show (Mu f) where ?
07:58:24 <byorgey> mrh: can you paste your code on hpaste.org?
07:58:25 <Myoma> something along those lines
07:59:46 <FordCortina> ah thanks byorgey
07:59:57 <mrh> byorgey: yea ok..just a minute
08:04:59 <mrh> byorgey: http://hpaste.org/10316
08:05:47 <igel> are there any code conventions for haskell?
08:06:03 <dcoutts_> igel: yes
08:06:08 <igel> using google i found a couple of really small pages addressing a few issues each
08:06:27 <igel> dcoutts_: where do i find them?
08:06:38 <dcoutts_> igel: http://urchin.earth.li/~ian/style/haskell.html
08:06:49 <lambdabot> Title: Good Haskell Style
08:07:15 <igel> thank you
08:07:23 <mrh> byorgey: what do u say ?
08:08:02 <byorgey> mrh: the last case should be  sameCons _ _ = False
08:08:15 <byorgey> all cases of a definition must have the same number of parameters
08:08:24 <byorgey> if you don't care about a parameter you can use the wildcard pattern, _
08:09:21 <mrh> byorgey: Thanks a million :)
08:09:26 <byorgey> mrh: sure =)
08:11:09 <quicksilver> mrh: as an aside, that "== True" doesn't do anything ;)
08:11:23 <quicksilver> "sameCons a b" is the same as "sameCons a b == True"
08:12:53 <mrh> alright, thanks for the tip :)
08:13:59 <BeelsebobWork> poor C programmers
08:14:12 <BeelsebobWork> C trains you to think that if doesn't take a boolean expression as it's argument
08:14:29 <BeelsebobWork> but instead some magical value that'll magically be interpretted by the if
08:16:08 <quicksilver> I'm in favour of (==True) in some circumstances
08:16:13 <quicksilver> where I think it's clearer.
08:16:17 <BeelsebobWork> really?
08:16:22 <BeelsebobWork> can you give me an example?
08:16:26 <quicksilver> I think "length . filter (==True)" is clearer than length . filter id
08:16:34 <BeelsebobWork> ah, I see
08:16:37 <BeelsebobWork> yeh, I agree with you
08:16:42 <Myoma> count True is nicer though
08:16:48 <quicksilver> but I didn't feel this was one of those case.
08:17:05 <BeelsebobWork> quicksilver: interestingly -- you're doing what I'm doing -- you're inventing a new name for a specialisation of id
08:17:11 <BeelsebobWork> your name happens to be (==True)
08:17:31 <quicksilver> yes.
08:17:36 <quicksilver> sometimes I prefer specialisations.
08:17:38 <quicksilver> It's a balance.
08:18:13 <BeelsebobWork> yeh
08:18:22 <BeelsebobWork> I wonder if there's a rule for where the balance is
08:18:29 <quicksilver> consistency is nice. It's nice ot be able to see the consistency between "length . filter (=="foo")" and "length . filter (==True)"
08:18:32 <Peaker> BeelsebobWork: I don't remember if you told me if that david guy who's working on that tutorial is in #haskell
08:18:48 <BeelsebobWork> Peaker: his IRC nick is camio, if you ever see him on
08:18:50 <Peaker> (hi, btw :-)
08:19:08 <BeelsebobWork> Peaker: also, with the number of people working with reactive now I'd expect a tutorial to pop up any time soon
08:19:17 * BeelsebobWork not looking at quicksilver in particular (honest)
08:19:17 <Peaker> BeelsebobWork: ah, ok.. any progress on Reactive?  conal said that there's an effort to remove the threads from the API?
08:19:34 <BeelsebobWork> Peaker: there's no IO and no threading in reactive now
08:19:46 * Peaker cabal-updates
08:19:55 <BeelsebobWork> I don't think it's on hackage in that state yet
08:19:57 <BeelsebobWork> only darcs
08:20:08 <BeelsebobWork> I think conal's working up towards a 1.0 release soon
08:20:11 <Peaker> where can I find some examples? I found the examples in the source dir pretty poor..
08:20:25 <BeelsebobWork> hmm, good question
08:22:01 <Peaker> is this the repo? http://cvs.haskell.org/darcs/packages/reactive/
08:22:02 <lambdabot> Title: Index of /darcs/packages/reactive
08:22:24 <BeelsebobWork> code.haskell.org/reactive
08:22:30 <BeelsebobWork> and sec on giving a nice example
08:22:53 <BeelsebobWork> this one is rather nice http://hpaste.org/10318
08:22:56 <FordCortina> why i put forall in a class constraint. i dont seem to get a syntax error. i.e. Show (forall s . f r s) => ...
08:23:06 <FordCortina> s/why/when/
08:23:19 <BeelsebobWork> Peaker: so, this is a text editor in Reactive
08:23:23 <FordCortina> so i guess maybe haskell allows this?
08:23:35 <BeelsebobWork> the bulk of the work gets done in stringUpdate
08:23:47 <BeelsebobWork> and that gets fmapped over the keypress event
08:23:52 <BeelsebobWork> and... that's about it
08:24:13 <Peaker> BeelsebobWork: what do I install for ListZipper?
08:24:33 <BeelsebobWork> I think david wrote that alone
08:24:43 <BeelsebobWork> so that's a fairly obvious list zipper implemntation
08:24:53 <lightstep> BeelsebobWork, what library is it based on?
08:25:01 <BeelsebobWork> that puts the cursor at the same place as the user's cursor
08:25:13 <BeelsebobWork> lightstep: the reactivity is done with Reactive, and the display with FieldTrip
08:25:25 <BeelsebobWork> (note, this is all david's code)
08:25:26 <conal> BeelsebobWork: i helped david factor out the ListZipper from the editor
08:25:49 <FordCortina> does haskell allow this sort of instance declaration?
08:25:50 <FordCortina> instance Show (forall r s . f r s) => Show (Star f r t)
08:26:03 <Peaker> conal: hey.. does ListZipper.hs have a URL? :)
08:26:09 * Peaker would like to run that example...
08:26:18 <lightstep> i can't find ListZeeper or FieldTrip in hackage or in google
08:26:41 <conal> Peaker: no.  i suggested david write it for learning and then look for a standard version on hackage.
08:26:58 <conal> lightstep: i haven't released FieldTrip or Reactive on hackage yet.  coming up.
08:27:10 <conal> lightstep: along with mailing list, wiki, and trac
08:27:40 <quicksilver> conal: many good things!
08:27:44 * quicksilver paces impatiently.
08:35:15 <lightstep> does the new reactive implementation use STM?
08:35:30 <quicksilver> lightstep: no.
08:35:40 <quicksilver> lightstep: the code we were looking at yesterday was just my explorations.
08:35:46 <lightstep> oh
08:35:51 <quicksilver> lightstep: conal's canonical repo uses a rather different method.
08:36:05 <quicksilver> which is believed to be deterministic
08:36:11 <quicksilver> although I'm not 100% sure I'm convinced it is ;)
08:36:25 <quicksilver> but I don't understand it fully yet.
08:36:37 <quicksilver> I was writing my own implementation to try to understand it all a bit better.
08:38:12 <lightstep> well, if the code will be available in a few days, it will probably be a nice read
08:39:05 <quicksilver> conal's code is available now
08:39:20 <quicksilver> http://code.haskell.org/reactive/
08:39:21 <lambdabot> Title: Index of /reactive
08:39:51 <lightstep> ah, i only looked at darcs.haskell.org
08:40:56 <hackage> Uploaded to hackage: heap 0.3.1
08:40:56 <hackage> Uploaded to hackage: panda 0.0.0.2
08:40:56 <hackage> Uploaded to hackage: gameclock 1.0.4
08:40:57 <hackage> Uploaded to hackage: CouchDB 0.8.0.3
08:40:59 <hackage> Uploaded to hackage: download-curl 0.1.1
08:46:40 <conal> quicksilver: there's also a bit of info on the wiki
08:46:43 <conal> @wiki reactive
08:46:44 <lambdabot> http://www.haskell.org/haskellwiki/reactive
08:46:58 <conal> oops.  previous comment meant for lightstep
08:47:30 <conal> lightstep: oh hi!  (just /whois'd you)
08:47:43 <lightstep> hi
08:48:07 <quicksilver> conal: yes, I
08:48:09 <quicksilver> ;)
08:48:13 <Peaker> the vector-space on hackage doesn't build...
08:48:15 <quicksilver> I knew about that wiki page, indeed ;)
08:48:34 <conal> Peaker: there's a note in vector-space.cabal that might explain
08:49:05 <conal> vector-space requires ghc 6.9 for working associated types.
08:49:15 <Peaker> conal: ah, thanks
08:49:32 <conal> i don't know how to give a clear automatic failure message
08:49:48 <conal> i love associated types.
08:50:15 <conal> they allowed bases and linear maps to work out beautifully!
08:50:32 <thoughtpolice> how do they say, 'made of win'?
08:51:37 <conal> lightstep: i'll totally replace that wiki page, btw.  it's mainly about an old version of reactive that didn't implement deterministic future or event merging.
08:52:27 <lightstep> it seems pretty close to version 0.5
09:01:17 <llimllib> I'm trying to play with this file: http://github.com/nostrademons/eve-language/tree/master/bootstrap/RunTest.hs in ghci
09:01:25 <lambdabot> Title: bootstrap/RunTest.hs at master from nostrademons's eve-language â€” GitHub, http://tinyurl.com/3vzdfh
09:01:37 <llimllib> when I :l RunTest, I can run the main function, which runs all tests
09:01:53 <llimllib> but I can't see the other functions
09:01:59 <llimllib> what am I missing?
09:02:34 <mmorrow> that module is only exporting main
09:02:52 <mmorrow> change "module Main (main) where" to "module Main where"
09:02:53 <llimllib> that's what Main(main) means then
09:03:00 <mmorrow> yes
09:03:04 <llimllib> sweet
09:03:06 <mmorrow> :)
09:03:23 <quicksilver> or delete the .o file
09:03:28 <quicksilver> so it's forced to load it interpreted
09:03:35 <quicksilver> and then it will make all symbols available anyway
09:03:48 <mmorrow> ah, nice catch. very trues
09:04:10 <bbs> anyone know a David Hemmendinger?
09:04:10 * mmorrow never loads .o files because they never seem to work ...
09:04:22 <bbs> hes my professor and i heard he might be in here ;>
09:04:44 <llimllib> both of those solutions work
09:04:47 <llimllib> thanks
09:08:19 <mmorrow> llimllib: here's an example of import/export syntax (ignore the fact that there are multiple As...(but some of the dup As don't clash) ;)) http://hpaste.org/10323
09:08:38 <Peaker> implementing a simple lambda calculus, I am wondering about a simple evaluate strategy for lexical, rather than dynamic scoping rules.. what is the simplest way?
09:09:39 <llimllib> mmorrow: thanks... I think I had made a module with an export before, but never compiled it and thus expected the hidden functions to be available from ghci
09:14:39 <mmorrow> Peaker: maybe something like Scope a = Env a | Scope { here :: Scope a , up :: Scope a , sibs :: [Scope a] } ?
09:15:03 <mmorrow> essentially a zipper on a (rose) tree
09:15:39 <mmorrow> err, maybe
09:15:42 <Peaker> mmorrow: what does the evaluator pass around?
09:15:52 <mmorrow> Scope a = Env a [Scope a] | Scope { here :: Scope a , up :: Scope a , sibs :: [Scope a] }
09:16:35 <mmorrow> Peaker: it carries around a (Scope a), which is the point of focus of the zipper
09:17:05 <Peaker> mmorrow: I think I need to read some about zippers.. Everyone seems to be using them :)
09:19:07 <mmorrow> Peaker: heh, "come on mann, everbody's doing it"
09:19:15 <Myoma> yay
09:19:22 <Myoma> ?yaw
09:19:22 <lambdabot> I have the power to HALT PRODUCTION on all TEENAGE SEX COMEDIES!!
09:19:36 <mmorrow> ?yawpitchroll
09:19:37 <lambdabot> Unknown command, try @list
09:19:44 <Myoma> ?yaw pitch roll
09:19:44 <lambdabot> Make me look like LINDA RONSTADT again!!
09:19:51 * Myoma zipz
09:19:52 <mmorrow> ?YOW
09:19:52 <lambdabot> Unknown command, try @list
09:19:57 <mmorrow> ?yow
09:19:57 <lambdabot> I want you to MEMORIZE the collected poems of EDNA ST VINCENT MILLAY
09:19:58 <lambdabot> ... BACKWARDS!!
09:20:07 <mmorrow> reverse . duh
09:20:20 <Myoma> :D
09:21:31 <_YKY_> Is that a palindrome
09:22:39 * BMeph wishes lambdabot really *did* have the power to halt production on all teenage sex comedies...dramas, too
09:30:21 <tibbe> I need a good paper to read in the gym, any suggestions?
09:32:45 <mattam> Theorems for Free!
09:35:58 <skorpan> Could not find module `Distribution.Verbosity': it is a member of package Cabal-1.4.0.2, which is hidden
09:36:04 <skorpan> please remind me about how to fix this
09:36:24 <Baughn> ghc-pkg expose Cabal-1.4.0.2, isitnot?
09:36:27 <dcoutts_> no
09:36:45 <mmorrow> skorpan: add/remove {<,<=,>,>=} from the build-depends: to force the correct choice
09:37:02 <Baughn> skorpan: Or, right, add it to build-depends first. Whoops.
09:37:14 <dcoutts_> yes :-)
09:37:25 <skorpan> so exactly what do i add?
09:37:33 <mmorrow> it's prob already there though, it's just not picking the correct version
09:37:45 <Baughn> skorpan: Tells cabal exactly what packages you want to use
09:37:47 <Peaker> Wouldn't it be nicer if lets would terminate by same-indentation-level, and did not require "in", like in "do" blocks?
09:37:56 <Baughn> Ideally you should add version requirements to that, too
09:38:00 <dcoutts_> mmorrow: all recent versions have had that module
09:38:22 <Baughn> Peaker: Not particularily. I appreciate the red in.
09:38:22 <skorpan> so how do i find out which package Distribution.Verbose is in?
09:38:36 <dcoutts_> skorpan: the error message says, it's in Cabal
09:39:00 <skorpan> hm, i should have guessed
09:39:59 <mmorrow> skorpan: what's the output of this?
09:40:03 <mmorrow> ghc-pkg list Cabal
09:40:19 <mmorrow> and this:
09:40:29 <mmorrow> cat *.cabal | grep Cabal
09:40:48 <skorpan> /usr/lib/ghc-6.8.2/package.conf:
09:40:48 <skorpan>     Cabal-1.2.3.0, Cabal-1.4.0.2
09:40:48 <skorpan>  
09:41:01 <skorpan> and where do i cat that?
09:41:02 <mmorrow> ok. so you have to force 1.4, so
09:41:28 <dcoutts_> Cabal-1.2 also contains Distribution.Verbosity
09:41:34 <mmorrow> open <whatever>.cabal in your editor, and change "Cabal" in the build-depends: field
09:41:43 <mmorrow> to "Cabal > 1.2"
09:42:02 * dcoutts_ doubts this is necessary
09:42:05 <mmorrow> err, maybe it should be the other way arounf
09:42:13 <dcoutts_> but then I have no idea what skorpan is building
09:42:29 <mmorrow> doesn't it pick the newer version if given the choice?
09:42:40 <skorpan> i'm building my mpd plugin for xmobar
09:42:41 <mmorrow> so it must be that he want the 1.2
09:42:59 <skorpan> it worked by just using "Cabal"
09:43:12 <mmorrow> oh, it wasn't there /at all/
09:43:14 <mmorrow> hehe
09:43:40 <skorpan> i'm actually quite surprised it worked pretty much flawlessly on the very first attempt :)
09:43:43 <dcoutts_> skorpan: so this is core you're writing that uses Distribution.Verbosity?
09:43:49 <dcoutts_> core/code
09:43:52 <skorpan> dcoutts_: yes
09:43:59 <skorpan> i'm taking the output from the command "mpc"
09:44:00 <dcoutts_> skorpan: why does it use Distribution.Verbosity?
09:44:13 <dcoutts_> I rather suspect it should not
09:44:14 <skorpan> using rawSystemProgramStdout
09:44:20 <skorpan> why should it not?
09:44:24 <dcoutts_> skorpan: Cabal is not just some utility library
09:44:44 <dcoutts_> skorpan: it's a rather big complex build system and the bits you are using are not a stable api
09:44:52 <skorpan> ah
09:45:04 <skorpan> so is there anything in some other package which does the same thing?
09:45:15 <skorpan> running a shell command and just returning its output
09:45:48 <dcoutts_> skorpan: well there's System.Process, but it does take some effort to make a usable function for capturing the stdout from that
09:46:28 <skorpan> there's always the alternative of making a program that connects to MPD by sockets and using the MPD protocol
09:46:29 --- mode: ChanServ set +o glguy
09:46:29 --- mode: glguy set -b *!*@gateway/tor/*!#haskell-ops
09:46:29 --- mode: ChanServ set -o glguy
09:47:16 <dcoutts_> skorpan: there's package popenhs but I don't know how well it works
09:47:22 <mrh> Im trying to divide two numbers as a float but it's not working. fromInteger 3 `div` fromInteger 38
09:47:33 <dcoutts_> skorpan: or copy the implementation of Cabal's rawSystemProgramStdout
09:47:36 * Peaker notes that dynamic scoping and Church booleans don't work together very well
09:47:37 <Myoma> > 3 / 38
09:47:39 <lambdabot>   7.894736842105263e-2
09:47:45 <lilac> mrh: div is integer division
09:47:52 <mrh> mhm ok
09:48:11 <skorpan> what the heck, there's libmpd for haskell
09:48:49 <lilac> Peaker: church booleans: const and flip const?
09:49:01 <Peaker> lilac: yeah
09:49:48 <Peaker> lilac: I am toying around with lambda calculus, I implemented a simple dynamically scoped evaluator - and tried checking some boolean logic, but my expression has multiple nested definitions and uses of the same lexical name..
09:50:11 <Myoma> Peaker, in haskell?
09:50:19 <Peaker> Myoma: yeah
09:50:48 <Myoma> Peaker: To get lexical scoping you can reflect haskell binding (lambda) into your term representation
09:51:10 <Myoma> data Term a = Var a | App (Term a) (Term a) | Lam (Term a -> Term a)
09:51:30 <Myoma> so you can write u = Lam (\x -> App (Var x) (Var x))
09:51:54 <Myoma> (even better you get lazy evaluation for free)
09:51:57 <Peaker> Myoma: thanks - I do want to get a feel for the mechanisms that implement lexical scoping, though
09:52:08 <Peaker> (and later, manually implement laziness too)
09:52:21 <Myoma> uh.. sounds like a waste of time
09:52:26 <Peaker> (this isn't a "practical" project :)
09:52:48 <Peaker> Myoma: why do you think it is a waste of time? Its just an educational thing I'm toying with
09:52:52 * Myoma wishes she hadn't bothered explaining all that now
09:53:06 <Myoma> Peaker: to implement scoping
09:53:54 <mmorrow> if you're generating asm, you have to do it manually..
09:53:58 <Myoma> I don't know every logic textbook I read goes over it in laborious detail -- maybe I am the only one tired of it
09:54:20 <Peaker> Myoma: Well, I don't like learning from books, I like toying around with implementations, getting my hands dirty
09:54:45 <Myoma> mmorrow: You can freeze a HOAS rep. easily
09:54:50 <mmorrow> Myoma: i just don't read those, then make it up as i go along ;)
09:55:00 <Myoma> turning into a first order structure like ASM
09:55:24 <Myoma> mmorrow: I couldn't figure out quantifier elimination and model theory without a book :(
09:55:27 <mrh> Myoma: hm well then there's something wrong with my code. http://hpaste.org/10325
09:55:49 <mmorrow> Myoma: if you had that goal from the beginning, but trying to reverse it after the fact can get you stuck
09:55:49 <Myoma> mrh: This is a horrible mistake of haskell you've come up against
09:55:51 <Myoma> :t length
09:55:52 <lambdabot> forall a. [a] -> Int
09:56:02 <Myoma> that _should_ be Num n => [a] -> n
09:56:11 <Myoma> but it's not so you have to use genericLength
09:56:14 <Myoma> :t genericLength
09:56:15 <lambdabot> forall b i. (Num i) => [b] -> i
09:56:20 <mmorrow> (as in designed the rep with that eventuality in mind)
09:56:20 <Myoma> or replace length with something sensible
09:56:34 <Myoma> mmorrow: huh?
09:56:50 <Myoma> I just mean HOAS in general
09:57:04 <Myoma> pass a gensym counter as you traverse down the AST
09:57:05 <mmorrow> i'm trying to think of how to phrase what i'm trying to get across
09:58:06 <mrh> Myoma: aha but genericLength does not exist in winhugs.
09:58:06 <mmorrow> i guess all i'm saying is that it's possible to lose information if you're going 1st order -> higher order -> first order
09:58:26 <Myoma> mrh: import Prelude hiding (length), length = foldr (const (+1)) 9
09:58:32 <Myoma> oops s/9/0/
09:58:50 <dcoutts_> mrh: it does, it's in the List module
09:59:03 <dcoutts_> @hoogle genericLength
09:59:04 <lambdabot> Data.List genericLength :: Num i => [b] -> i
09:59:14 <Myoma> mmorrow: if you consider variable names information, then yeah. You'd lose it with my rep but you could easy hook names into the term representation too
09:59:35 <Myoma> (you'd want to use them just as commentry though, because they might have clashes)
10:00:40 <mmorrow> Myoma: i agree with you that yours would work :)
10:01:28 <mrh> dcoutts_: ok so import Data.List ?
10:01:36 <dcoutts_> mrh: yes
10:01:50 <mmorrow> i can't think of an example of what i for some reason strongly suspect to be the case at the moment, nor can i really phrase it (these are related no doubt)
10:01:55 <mmorrow> i've gotta think about it
10:03:29 <mrh> dcoutts: ok I did that and replaced length with genericLength, still same problem
10:04:27 <dcoutts_> mrh: perhaps your calc diff also returns an Int
10:05:10 <dcoutts_> mrh: btw, what is seq in this context? is it something you defined or the standard seq ?
10:05:57 <mrh> something I defined
10:06:16 <mrh> dcoutts: you were right..calcdiff returned an int
10:08:49 <mrh> dcoutts: so I changed it to a float. but for example calcdiff [] [] = c. c is still an int. I guess fromInteger c converts it to a float?
10:09:32 <dcoutts_> mrh: the way to check is to ask winhugs, use :type fromInteger
10:10:36 <mrh> ye ok...well im only 2 weeks into haskell so bare with me :D
10:13:37 <dcoutts_> mrh: s'ok :-) I'm just trying to help you to answer your own questions :-)
10:14:33 <mrh> dcoutts_: ye and I appreciate it. Seems i got to define my own int->float
10:14:59 <dcoutts_> mrh: ah, it's fromIntegral you want
10:15:03 <dcoutts_> not fromInteger
10:15:10 <dcoutts_> :type fromIntegral
10:15:19 <dcoutts_> @type fromIntegral
10:15:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:15:33 <dcoutts_> @type fromIntegral (3 :: Int) :: Float
10:15:35 <lambdabot> Float
10:16:27 <dcoutts_> @hoogle Int -> Float
10:16:28 <lambdabot> Prelude toEnum :: Enum a => Int -> a
10:16:28 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
10:16:28 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
10:16:36 <guenni> mmorrow: hi, how is the "yi" slaying going, who's winning, who's whining?
10:17:10 <mrh> dcoutts: ok I'll try with fromIntegral.
10:17:57 <dcoutts_> @seen ndm
10:17:57 <lambdabot> I haven't seen ndm.
10:19:40 <mrh> dcoutts: thanks a lot man! solved my problem
10:20:20 <dcoutts_> mrh: pn
10:20:24 <dcoutts_> erm np
10:22:24 <dcoutts_> @seen ndmitchell
10:22:24 <lambdabot> I haven't seen ndmitchell.
10:24:18 <CosmicRay> @seen ndm
10:24:18 <lambdabot> I haven't seen ndm.
10:24:20 <dcoutts_> @tell ndmitchell hoogle Int -> Float should put fromIntegral higher, before extra args I think like [a] -> Int -> a
10:24:20 <lambdabot> Consider it noted.
10:24:22 <mrh> ok g2g now. thanks for all the help
10:25:21 <dcoutts_> @tell ndmitchell perhaps specialising to an instance of a class should be better than specialising an unconstrained polymorphic type
10:25:21 <lambdabot> Consider it noted.
10:29:50 <int-e> ndm
10:31:42 <snhmib> aqz
10:32:40 * FunctorSalad just realized that arbitrary utf-8 chars can be declared infix :D
10:32:51 <FunctorSalad> that much nicer than 3-character operators
10:32:57 <FunctorSalad> *that's
10:34:08 <PaderbornerPenne> http://www.pennergame.de/change_please/6555660/
10:34:10 <lambdabot> Title: Pennergame
10:34:40 <PaderbornerPenne> http://www.pennergame.de/change_please/6555660/
10:34:41 <lambdabot> Title: Pennergame
10:37:26 <marcot> Good afternoon.  In the build of hmp3, I'm getting the message: Warning: defaultUserHooks in Setup script is deprecated.
10:37:30 <marcot> Is this a bug in the package?
10:38:32 <Cale> Probably just a sign that it hasn't been updated in a while.
10:39:27 <FunctorSalad> is there a way to allow cyclic dependencies between files?
10:39:44 <FunctorSalad> I can't seem to split this one but it's getting huge
10:39:54 <Zao> FunctorSalad: Some kind of "boot" file, I believe.
10:40:05 <dons_> yay, we have 'parallel' on the shootout now.
10:40:12 <FunctorSalad> Zao: CPP #include will do it I guess
10:40:19 <dons> marcot: i'll update.
10:40:37 <FunctorSalad> dons: shootout?
10:40:42 <Zao> FunctorSalad: http://www.nabble.com/Mutually-recursive-cyclic-module-imports-p18998625.html
10:40:45 <marcot> dons: ok, I was going to do that, but then I'll just darcs pull later.
10:40:48 <lambdabot> Title: Nabble - Mutually-recursive/cyclic module imports, http://tinyurl.com/43ox3v
10:41:19 <Zao> You probably want to look into .hs-boot files if you use GHC.
10:41:32 <dons> FunctorSalad: http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=all
10:41:34 <lambdabot> Title: binary-trees benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Languag ..., http://tinyurl.com/69l8ag
10:41:39 <dons> but hmm, something weird is going on.
10:41:52 <FunctorSalad> (that haskell-mode's indexer/imenu is broken doesn't help)
10:42:10 <Zao> FunctorSalad: http://hackage.haskell.org/trac/ghc/ticket/2518
10:42:16 <lambdabot> Title: #2518 (hard-to-find .hs-boot docs) - GHC - Trac
10:42:39 <FunctorSalad> Zao: I see
10:44:01 <_Dae_> evenin'
10:46:28 <FunctorSalad> dons: I'm stupid, I can't find a parallel haskell entry on that list :(
10:46:46 <dons> FunctorSalad: there's binary-trees, but it looks like it's scores haven't been updated yet.
10:46:58 <dons> previously it didn't compile due to ubuntu not having libHSparallel:)
10:47:08 <marcot> dons: are you aware of a bug in the help window of hmp3?  It shows '\\' instead of '\'.
10:47:22 <marcot> > print '\\'
10:47:24 <lambdabot>   mueval: Prelude.read: no parse
10:47:24 <lambdabot>  mueval: *** Exception: "<IO ()>"
10:47:43 <dons> marcot: oh , 'show' :)
10:48:33 <hodgekin> has anybody implemented leijen's "extensible records with scoped labels" in ghc? (or any free haskell system, for that matter)
10:48:36 <marcot> dons: I think ' ' is not very good for saying space also..
10:49:01 <marcot> dons: wouldn't it be good if ? is help too?
10:49:09 <dons> JaffaCake: interesting, my well-partitioned thread ring is slower, http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
10:49:11 <lambdabot> Title: thread-ring benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Language ..., http://tinyurl.com/5ph2wt
10:55:04 <FunctorSalad> Zao: hmm... will ghc --make do cyclicity thing automatically or do I still need the .hs-boot?
10:55:10 <FunctorSalad> +the
10:55:21 <Zao> I believe you need to break the cycle.
10:56:59 <davidL> dons: does that machine not have parallel on it?
10:57:10 <dons> it does now.
10:57:22 <davidL> ah
10:58:30 * Myoma recommends not using cyclic modules
11:01:15 <FunctorSalad> why?
11:06:53 * roconnor recommends ghc support cyclic modules :P
11:07:12 <dons> you write a lot of those?
11:07:17 <ddarius> roconnor: It should, but oftentimes cyclic modules are an indicator of poor design.
11:07:22 <roconnor> not yet
11:09:04 <FunctorSalad> is anything speaking against #include? (assuming I don't actually want multiple modules)
11:09:10 <FunctorSalad> s/want/need/
11:14:25 <trofi> @unpl (,) -> (%)
11:14:25 <lambdabot>  Parse error at "->" (column 5)
11:14:43 <trofi> @pl \(a,b) -> (a%b)
11:14:44 <lambdabot> uncurry (%)
11:15:22 <dcoutts_> dons: I read rl's paper and I realised we'd already implemented a simple form of this for functional array fusion before we abandoned that for stream fusion.
11:15:34 <dons> yeah, that's what I was thinking.
11:15:40 <dons> the uniqueness stuff we tried.
11:15:51 <dcoutts_> dons: the allocating wrapper and the worker
11:15:52 <dons> reusing blocks
11:15:53 <dons> yep
11:16:05 <dcoutts_> dons: so we could do it for a map up followed by a map down
11:16:10 <dcoutts_> or something like that
11:16:23 <dons> i wonder if it is mentioned in the bytestring paper.
11:16:24 <dcoutts_> but no random access stuff like rl is doing of course
11:16:31 <dcoutts_> dons: I don't think it was actually
11:16:33 <dons> yeah, he's been working  on that since forever.
11:16:40 <dons> the random access/permutations stuff
11:16:52 <dons> but we've always wanted to exploit uniqueness
11:16:52 <dcoutts_> we just compared to the functional array fusion benchmarks
11:18:00 <pastorn_> i want to do x^y where x and y might be floats...
11:18:08 <pastorn_> what function do i use?
11:18:13 <sw17ch> :t (^)
11:18:14 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:18:29 <pastorn_> :t (^^)
11:18:30 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:18:44 <pastorn_> se that my exponent is integral in both cases....
11:18:45 <sw17ch> :t exponent
11:18:46 <lambdabot> forall a. (RealFloat a) => a -> Int
11:18:53 <dcoutts_> :t (**)
11:18:55 <lambdabot> forall a. (Floating a) => a -> a -> a
11:19:03 <dcoutts_> > 2.1 ** 3.2
11:19:05 <lambdabot>   10.74241047739471
11:19:08 <sw17ch> dcoutts_: ah, thanks, couldn't remember :)
11:19:22 <pastorn_> dcoutts_: danke, mein herr
11:19:23 <dcoutts_> sw17ch: it's always confusing that one :-)
11:19:33 <trofi> :t (^^)
11:19:35 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:19:36 <trofi> :t (^)
11:19:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:19:38 <trofi> :t (**)
11:19:40 <lambdabot> forall a. (Floating a) => a -> a -> a
11:19:56 <sw17ch> that seems like it could have been done better i suppose
11:20:09 <Cale> What does?
11:20:56 <sw17ch> ^^ vs ^ vs **
11:21:00 <ttt--> :t 1
11:21:01 <lambdabot> forall t. (Num t) => t
11:21:09 <marcot> hmp3 here suddently stops working, and if I close it's terminal it's not killed.  I try to kill it, but it can only be killed with -9.  It keeps using more and more RAM and the processor..
11:21:30 <Cale> The three exponentiation operators available in Haskell reflect three different kinds of exponentiation available in mathematics, which the notation we usually use unifies. Picking different notation here is important for polymorphism.
11:21:56 <Cale> (There's no good way around it, really)
11:22:18 <Heffalump> cleverer overload resolution
11:22:18 <loop> :t (^^)
11:22:19 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:22:51 <Cale> (^) only allows positive integer exponents, but only needs multiplication on the base type to do its work
11:23:05 <Cale> (^^) allows negative exponents, but needs inverses (or division)
11:23:25 <sw17ch> Cale: thanks, that does help to justify it :)
11:23:29 <Cale> (**) allows fractional exponents, but requires much more from the base type
11:23:43 <Cale> (you need to be able to define log and exp)
11:27:34 <marcot> dons: How do you think ogg support to hmp3 should be added?  ogg123 and mpg321 running both at the same time?
11:27:45 <dons> yeah, but someone needs to work on it   :)
11:28:22 <marcot> dons: but what about if someone will use only to listen mp3 or ogg, both will run anyway?
11:28:33 <dcoutts_> do it lazily!
11:28:35 <skorpan> hm... i have a function of type IO String and i want to perform another monadic action inside of it. that other monad, let's call it XYZ, instanciates MonadIO if that matters. how would i do that?
11:28:43 <skorpan> i really should know this, but... hey.
11:29:25 <dcoutts_> skorpan: you might like to look at tutorial on IO / do notation / monads
11:29:51 <skorpan> i do: do resp <- otherMonadFunction\n ... but it complains telling me it expects IO t
11:30:29 <dcoutts_> skorpan: and what is the type of otherMonadFunction ?
11:30:38 <marcot> Every time I close the terminal hmp3 is running, that bad behaviour happens.
11:30:44 <dcoutts_> skorpan: sounds like you might need to liftIO
11:30:44 <skorpan> XYZ (Maybe Other)
11:30:56 <skorpan> is it really liftIO? i experimented with that with no success
11:31:10 <dcoutts_> skorpan: to get from XYZ (Maybe Other) -> IO (Maybe Other)
11:31:14 <dcoutts_> :type liftIO
11:31:23 <dcoutts_> @type liftIO
11:31:24 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:31:33 <dcoutts_> oh, hmm I've got it backwards
11:31:52 <dcoutts_> skorpan: that'd explain why it doesn't worl :-)
11:32:07 <skorpan> :)
11:32:32 <dcoutts_> skorpan: so the answer then is that you don't want to get the overall result as IO, but as XYZ
11:33:38 <skorpan> dcoutts_: i want the "Other" in "XYZ (Maybe Other)"
11:34:09 <skorpan> this might be easier to explain if i just skip these codewords
11:34:17 <dcoutts_> skorpan: sure, inside XYZ, so just use do notation as normal
11:34:19 <skorpan> XYZ is Network.MPD, Other is "Song"
11:34:22 <Gilly> you might need to "run" the monad
11:34:34 <Cale> http://www.youtube.com/watch?v=SzzHjpRmrLU -- yay, a new Catsters video :)
11:34:35 <lambdabot> Title: YouTube - Adjunctions from morphisms 1
11:34:39 <skorpan> hm, that's true Gilly
11:35:08 <skorpan> AH YES
11:35:10 <skorpan> i got it know
11:35:55 <skorpan> thanks a lot Gilly
11:36:01 <skorpan> and you too dcoutts_ :)
11:36:05 <Gilly> np :)
11:39:26 <ddarius> skorpan: You should have a function runXYZ :: XYZ a -> ... IO a ... (perhaps with a different name).  You need to use that.
11:39:39 <skorpan> yep. it was withMPD.
11:39:44 <skorpan> works perfectly well now.
11:40:45 <mancalledhash> hello all, can someone point me to a chatserver or any kind of server written in haskell to use as an example?
11:43:03 <ddarius> @google "Haskell Web Server"
11:43:05 <lambdabot> No Result Found.
11:43:30 <ddarius> @google hws haskell
11:43:33 <lambdabot> No Result Found.
11:43:50 <ddarius> Freakin' lying bot
11:43:51 <dons> CAle, can you put the catsters on the theory section of the video wiki page?
11:47:59 <mancalledhash> Thanks ddarius
11:49:44 <Cale> dons: There were already a couple of links to them, I subsumed them into a link to their YouTube profile.
11:49:55 <dons> ok
11:50:44 <mmorrow> subsume :: ... would be a great function name
11:54:46 <Apocalisp> >foldl1 (+) []
11:54:51 <Apocalisp> > foldl1 (+) []
11:54:52 <lambdabot>   mueval: Prelude.read: no parse
11:54:53 <lambdabot>  mueval: *** Exception: Prelude.foldl1: empt...
11:55:17 <Apocalisp> is there a reason that foldl1 doesn't return the empty list for the empty list?
11:56:00 <Apocalisp> oh. duh.
11:56:10 <Apocalisp> :)
12:02:44 <HairyDude> is it possible to change the evaluation context for ghc -e so I can use e.g. >>> instead of Control.Arrow.>>> ?
12:04:02 <inimino> why can't I use / on two integers?
12:04:14 <Apocalisp> inimino, use div
12:04:37 <inimino> Apocalisp: I want a fractional result
12:04:48 <Apocalisp> ah! Use fromIntegral
12:05:01 <byorgey> > fromIntegral 6 / fromIntegral 5
12:05:02 <lambdabot>   1.2
12:05:04 <HairyDude> I could use (.) in this case but I like being able to build a pipeline from the start to the end, seeing as that's how my mind works :)
12:05:04 <Apocalisp> > 1 / 1
12:05:06 <lambdabot>   1.0
12:05:10 <inimino> I just don't understand why / isn't defined on all Num types
12:05:11 <byorgey> alternatively, you can also use Rationals
12:05:15 <Apocalisp> > 2 / 3
12:05:16 <byorgey> > 6 % 5
12:05:16 <lambdabot>   0.6666666666666666
12:05:17 <lambdabot>   6%5
12:05:25 <byorgey> inimino: because it has to give back the same type that you put in.
12:05:33 <byorgey> is not closed over the integers.
12:05:45 <byorgey> that was supposed to say, "/" is not closed over the integers.
12:05:51 <HairyDude> mathematically speaking, the integers don't form a field.
12:06:18 <inimino> byorgey: why can't it give back a different type?
12:06:38 <byorgey> inimino: because Haskell is rather strict about types.
12:06:43 <byorgey> @type (/)
12:06:44 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:06:58 <byorgey> that type says, it must give back the same type (a) as what you put in.
12:07:04 <HairyDude> 3 / 2
12:07:06 <HairyDude> oops
12:07:09 <HairyDude> > 3 / 2
12:07:10 <lambdabot>   1.5
12:07:13 <HairyDude> 3 `div` 2
12:07:16 <byorgey> I'm aware there are other languages that do an implicit cast.  it's just a design choice.
12:07:16 <HairyDude> > 3 `div` 2
12:07:18 <lambdabot>   1
12:07:20 * HairyDude slaps himself
12:07:43 <inimino> byorgey: couldn't have been defined as a â†’ a â†’ b?
12:07:49 <roconnor> In the future, with associated types, prehaps / could return an appropriate type
12:07:55 <HairyDude> inimino: what would b be?
12:08:13 <byorgey> inimino: well, a -> a -> b  means it should be able to give back *anything* you like.  that's certainly not what we want.
12:08:19 <roconnor> but associated types aren't part of Haskell 98
12:08:20 <ddarius> "He gave lectures on category theory in the forests surrounding Hanoi while the city was being bombed"
12:08:50 <inimino> well, replace 'b' with something reasonable, like Float
12:09:04 <skorpan> @pl \x -> (\y -> x y)
12:09:05 <lambdabot> id
12:09:07 <skorpan> awesome
12:09:12 <swiert> ddarius: who's that?
12:09:22 <HairyDude> roconnor: so the Fractional instance for Int gives (/) :: Int -> Int -> Ratio Int ?
12:09:23 <skorpan> @pl \x -> (\y -> func y) ++ x
12:09:23 <lambdabot> (func ++)
12:09:34 <HairyDude> (for example)
12:09:56 <marcot> dons: maybe replacing mpg321 with another player, that supports more formats, would be a better option, no?
12:09:57 <HairyDude> rather than being something floating point
12:10:01 <marcot> dons: like mpd, for instance?
12:10:55 <Twey> Grothendieck, swiert
12:11:16 <roconnor> HairyDude: perhaps
12:11:32 <inimino> I just find all that fromIntegral litter very unaesthetic
12:11:39 <HairyDude> you're not alone there
12:12:01 <roconnor> ya, implicit coecrions seems like a better solution
12:12:12 <swiert> Twey: ah thanks.
12:12:15 <roconnor> ... although they are a bit fragile
12:12:17 <ddarius> implicit coercions are evil
12:12:17 <byorgey> inimino: this is a particular instance of one of Haskell's major design principles, to choose theoretical elegance over convenience.
12:12:32 <ddarius> Except perhaps between actual subtypes.
12:12:38 <HairyDude> wait till you start working with newtypes, you have to litter your code with constructors and destructors that aren't even represented in the final code
12:13:31 <Myoma> HairyDude, is there no way to fix it/
12:13:32 <Myoma> ?
12:13:37 <ddarius> You shouldn't have to use fromIntegral very often.
12:13:41 <inimino> byorgey: if I understood why this was more theoretically elegant, maybe I'd be more sympathetic ;-)
12:13:47 <HairyDude> Myoma: fix what?
12:14:04 <byorgey> inimino: well, it's just the theoretical elegance of having a strong, static type system.
12:14:18 <byorgey> the language will never arbitrary and silently convert from one type to another.
12:14:35 <byorgey> if you have something of type a and you want something of type b, you must apply a function a -> b to it.
12:15:05 <HairyDude> except for the interactive prompt, and the monomorphism restriction, which are subject to defaulting
12:15:10 <ddarius> > fromIntegral (2^3000) :: Double
12:15:12 <lambdabot>   Infinity
12:15:23 <inimino> byorgey: it seems to me that the type system could be just as strong and the Number types just done differently and this would "just work"
12:15:46 <HairyDude> well everyone knows the numeric hierarchy is a crock anyway
12:16:05 <HairyDude> you can't define a sensible instance for a natural number type for example
12:16:14 <HairyDude> because you have to define (-)
12:16:29 <byorgey> true
12:16:44 <HairyDude> s/instance/Num instance/
12:16:48 <byorgey> I certainly wouldn't mind a better numeric hierarchy =)
12:16:53 <inimino> I don't want coercion of the inputs, I just want a / that works on any numbers
12:16:59 <byorgey> but you still wouldn't be able to apply / to integers
12:17:06 <HairyDude> inimino: with what meaning?
12:17:45 <inimino> HairyDude: with the obvious meaning, and a floating point return value
12:17:56 <ddarius> HairyDude: No one wants to fix the numeric classes to get implicit coercions.
12:18:06 <HairyDude> inimino: what obvious meaning would that be? division isn't defined on the integers
12:18:33 <roconnor> and even less defined on the Ints
12:18:37 <HairyDude> and when did I say anything about implicit coercion?
12:18:48 <ddarius> inimino: So just write x /. y = fromIntegral x / fromIntegral y and then you don't have to write it in that situation ever again.
12:18:59 <Myoma> ddarius: actually, I want to do it :)
12:19:09 <inimino> ddarius: yes, I might
12:19:13 <Myoma> ddarius: It's too hard for me though, I couldn't get it to work with the currnte typeclass setup
12:19:32 <HairyDude> there are alternative preludes out there
12:19:36 <byorgey> Myoma: I tried that once.  believe me, you don't want to go there.
12:19:42 <HairyDude> dunno how usable any of them are mind
12:19:50 <Myoma> byorgey: I already tried 3 times and then had a go in Coq
12:19:55 <byorgey> hehe
12:19:57 <inimino> HairyDude: division is defined on anything other that x/0, which could throw an exception
12:20:02 <Myoma> I don't think it's even possible in haskell, but I'm probably wrong
12:20:15 <HairyDude> inimo: it is? what's 3/2 as an integer then?
12:20:44 <inimino> HairyDude: I don't want an integer, I want a floating result
12:20:45 * Myoma basically just wants to write mean x = sum x / length x
12:20:55 <byorgey> Myoma: see http://haskell.org/haskellwiki/Generic_number_type
12:20:56 <lambdabot> Title: Generic number type - HaskellWiki
12:21:04 <byorgey> and see the mailing list discussion linked from there.
12:21:09 <ddarius> > let xs = [1,2,3,4] in sum xs / genericLength xs
12:21:11 <lambdabot>   2.5
12:21:14 <HairyDude> inimino: if you don't want an integer, then you don't want / defined on the integers
12:22:07 <dmwit> Also, division doesn't make sense on all instances of Num.
12:22:24 <dmwit> For example, suppose you define a Polynomial type; what should division be like there?
12:22:30 <HairyDude> anyway, I came here to ask a question, and nobody's answered it, so I'll repeat. Can I get ghc -e to let me say >>> instead of Control.Monad.>>> ?
12:22:38 <dmwit> It makes a lot less sense to "throw away the remainder" in that situation.
12:22:44 <skorpan> does xmobar's CPU utilization plugin support multiple CPUs?
12:22:48 <dmwit> HairyDude: I don't know of a way.
12:22:53 <byorgey> HairyDude: yes.  :set prompt=... or something like that.
12:23:03 <inimino> well, dmwit, that may be true, I don't know what fits Num
12:23:03 <Heffalump> there's no way to get hold of the name of a type without Data.Typeable, right?
12:23:05 <dmwit> byorgey: ghc -e # note the -e
12:23:24 <byorgey> ohhhhh
12:23:33 <dmwit> HairyDude: However, you can write Control.Arrow.>>>
12:23:38 <dmwit> (It's super-bulky, though.)
12:23:40 <FunctorSalad> is there some flag that can fix this: " Can't make a derived instance of `Show C' (`C' has non-Haskell-98 constructor(s))"?
12:23:44 <inimino> it just seems like there should be a / that "just works"
12:23:51 <byorgey> wait, I was totally confused.  ignore my statement about :set prompt.
12:23:58 <HairyDude> dmwit: yes, that bulkiness was the problem I was trying to solve :)
12:24:08 <inimino> but I'll just deal with it ;-)
12:24:10 <ddarius> inimino: There is.  You want to make one that "just almost sorta works except when it doesn't"
12:24:22 <HairyDude> tbh I'd like it if ghc -e just automatically imported Control.Arrow, it's just that useful
12:24:22 <dmwit> HairyDude: ghc -e "let (#) = (Control.Arrow.>>>) in ..." ;-)
12:24:23 <FunctorSalad> (as long as the type variable quantified over in that constructor is showable, Show should be derivable, right?)
12:24:41 <HairyDude> dmwit: oh, that's a point
12:24:50 <byorgey> if you set up imports in your .ghci, does ghc -e see them?
12:24:51 <HairyDude> dmwit: or even s/#/>>>/ :)
12:24:58 * dmwit nods
12:25:20 <inimino> ddarius: ok, I'll bite... what's the problem with having a / that returns Float?
12:25:34 <marcot> hmp3 is making loading so much my processor that it's getting very hot (more than 100oC) and shuting down (second time)... This when I close the terminal that contains it.
12:25:43 <inimino> ddarius: if the problem is that Num is too broad, then why not have a Divisible class?
12:26:03 <dmwit> HairyDude: You can also set up a file that imports your stuff, then do
12:26:05 <ddarius> inimino: I already illustrated one issue above.  The division of two Integers may overflow or underflow a Float and will likely not be precisely represented by a float.
12:26:14 <dmwit> HairyDude: ghc CommonImports.hs -e "foo"
12:26:24 <dmwit> HairyDude: (I just tested that, and it works like you want it to.)
12:26:57 <inimino> ddarius: all of which is equally true when fromIntegral is used
12:27:20 <ddarius> inimino: Indeed, but you have to explicitly choose to use fromIntegral.  I don't have a problem with -explicit- coercions.
12:27:36 <inimino> well, it's just a matter of taste, I suppose
12:27:48 <HairyDude> dmwit: oh why didn't I think of that! I already have such a file
12:27:51 * HairyDude slaps himself again
12:28:06 <ddarius> inimino: There are objective issues as well.  One is auditable, the other isn't (as much)
12:28:14 <HairyDude> thanks :)
12:28:22 <dmwit> HairyDude: Yup, I've just now aliased h to "ghc ~/programming/Dmwit.hs -e". =)
12:29:05 <HairyDude> heh
12:30:35 <inimino> ddarius: no doubt there are differences
12:32:03 <HairyDude> strange. quick test shows getContents didn't recognise ^D as EOF
12:32:38 <dmwit> HairyDude: Yeah, that's a weird thing indeed.  I seem to recall it's related to which buffering you set for some reason.
12:35:50 <maciek> Hi! Can You help me with refactoring one-liner? http://haskell.pastebin.com/m3b29f6c6
12:36:31 <Twey> Gah, what's the function that takes a list and repeats it an certain number of times?
12:36:51 <Twey> \n -> (take n) . cycle
12:36:56 <Myoma> > filter (not . null) . take 2 . tails $ "abcdefgh"
12:36:58 <lambdabot>   ["abcdefgh","bcdefgh"]
12:37:06 <Myoma> > filter (not . null) . map (take 2) . tails $ "abcdefgh"
12:37:07 <lambdabot>   ["ab","bc","cd","de","ef","fg","gh","h"]
12:37:15 <dmwit> Twey: concat . replicate?
12:37:21 <Myoma> > filter ((== 2) . length) . map (take 2) . tails $ "abcdefgh"
12:37:23 <lambdabot>   ["ab","bc","cd","de","ef","fg","gh"]
12:37:36 <maciek> thanks!
12:37:43 <Twey> dmwit: Is that so?  Thanks :)
12:37:50 <ddarius> (concat .) . replicate
12:38:06 <Twey> I thought there was a standard function
12:38:09 <Twey> But OK :)
12:38:27 <Myoma> :t (?f .) . ?g
12:38:28 <lambdabot> forall b c a a1. (?g::a1 -> a -> b, ?f::b -> c) => a1 -> a -> c
12:38:45 <ddarius> Twey: You could abuse some other functions to do it, I think, but it isn't a particularly common operation.
12:40:07 <HairyDude> also, I can't kill it with either ^C or ^\
12:40:33 <dmwit> maciek: One second, I have precisely this function in Dmwit.hs
12:40:59 <dmwit> Oh, Myoma already wrote it.
12:41:02 <dmwit> Well, anyway:
12:41:46 <dmwit> > let ensure p x = guard (p x) >> return x; chunk i = unfoldr $ ensure (not . null . fst) . splitAt i in chunk 2 [1..6]
12:41:47 <lambdabot>   [[1,2],[3,4],[5,6]]
12:42:45 <maciek> Myoma: is your version efficient? It generates all tails. Is it kind of lazy-magic which make it efficient?
12:42:48 <dmwit> Oh, also I misunderstood the function. heh
12:43:09 <dmwit> > let f = ap (zipWith (\a b -> [a, b])) tail in f [1..6]
12:43:10 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6]]
12:43:18 <Myoma> maciek: if you fix n at compile time it can be more efficient
12:43:20 <dmwit> But better is:
12:43:26 <dmwit> > let f = ap zip tail in f [1..6]
12:43:27 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6)]
12:43:39 <trofi> > oeis $ map (\x -> (x+1)*(3*x+2)`div`2) [0..]
12:43:40 <lambdabot>   mueval: Prelude.read: no parse
12:43:48 <maciek> dmwit: what about 3-tuples?
12:43:54 <trofi> > map (\x -> (x+1)*(3*x+2)`div`2) [0..]
12:43:55 <lambdabot>   [1,5,12,22,35,51,70,92,117,145,176,210,247,287,330,376,425,477,532,590,651,...
12:44:05 <dmwit> maciek: Yeah, it doesn't scale.
12:44:39 <dmwit> maciek: You have to define one for each "size" of result you want, so if you really want a dynamically-sized result, that approach doesn't work.
12:44:45 <Myoma> @src tails
12:44:45 <lambdabot> tails []         = [[]]
12:44:45 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
12:45:01 <Myoma> looks efficient I guess
12:45:12 <maciek> I need 5
12:45:17 <Myoma> you can write
12:45:18 <sw17ch> where does the definition of the List monad sit?
12:45:21 <maciek> 5-tuple would work
12:45:28 <dmwit> ?src (>>=) []
12:45:28 <lambdabot> Source not found. It can only be attributed to human error.
12:45:32 <dmwit> ?src [] (>>=)
12:45:33 <lambdabot> xs >>= f     = concatMap f xs
12:45:35 <Myoma> fives (a:b:c:d:e:xs) = (a,b,c,d,e) : fives xs
12:45:39 <Myoma> fives _ = []
12:45:44 <Myoma> this is the best possible
12:45:45 <sw17ch> ah, got it
12:45:48 <sw17ch> http://www.haskell.org/all_about_monads/html/listmonad.html
12:45:49 <lambdabot> Title: The List monad
12:45:56 <dmwit> Myoma: But that's wrong.
12:46:06 <Myoma> > let fives (a:b:c:d:e:xs) = (a,b,c,d,e) : fives xs ; fives _ = [] in fives [1..]
12:46:07 <lambdabot>   [(1,2,3,4,5),(6,7,8,9,10),(11,12,13,14,15),(16,17,18,19,20),(21,22,23,24,25...
12:46:14 <dmwit> fives (a:b:c:d:e:xs) = (a,b,c,d,e) : fives (b:c:d:e:xs)
12:46:19 <Myoma> > let fives (a:b:c:d:e:xs) = (a,b,c,d,e) : fives (b:c:d:e:xs) ; fives _ = [] in fives [1..]
12:46:20 <lambdabot>   [(1,2,3,4,5),(2,3,4,5,6),(3,4,5,6,7),(4,5,6,7,8),(5,6,7,8,9),(6,7,8,9,10),(...
12:46:36 <maciek> b-e-a-u-t-i-f-u-l
12:46:39 <Twey> http://swtch.com/~rsc/regexp/regexp1.html -- this doesn't apply to Haskell, does it?
12:46:46 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
12:46:59 <Twey> The pathological case given there doesn't seem to be an issue
12:47:11 <dmwit> Twey: It depends on which regexp library you use.
12:47:18 <dmwit> Obviously the PCRE library has that problem.
12:47:32 <Twey> Ah
12:47:33 <dmwit> But PCRE are not RE. =)
12:47:36 <Twey> The POSIX doesn't?
12:47:58 <dmwit> I wouldn't be surprised if most systems have a relatively efficient implementation of POSIX regexen.
12:48:15 * Twey nods.
12:48:30 <Twey> h.o down?  *sighs*
12:48:42 * Twey needs to make a local copy of the GHC docs
12:50:26 <sjanssen> Twey: loads okay for me
12:50:33 <sjanssen> perhaps a bit slow
12:50:49 <Twey> Ah, aye, it loaded eventually
12:51:07 <Twey> Took a couple of minutes
12:57:16 <HairyDude> dmwit: they are "regular expressions" in that they're a more advanced form of what most people think of as regular expressions... but not, in that they can describe languages that aren't really regular
12:59:04 <dmwit> The point I was trying to make was that PCRE probably *can't* be implemented in the efficient way described in that paper.
13:01:35 <BMeph> Isn't that (maciek's) problem in the "Things to avoid" section of the wiki? :)
13:01:42 <BMeph> ?wi Things to avoid
13:01:42 <lambdabot> Maybe you meant: wiki wikipedia wn
13:01:52 <BMeph> ?wiki Things to avoid
13:01:52 <lambdabot> http://www.haskell.org/haskellwiki/Things_to_avoid
13:05:03 <HairyDude> ooh, hoogle is a lot shinier these days
13:11:26 <HairyDude> is there a nicer file API than the one in System.Posix.Files ?
13:11:52 <HairyDude> it seems to depend on opaque POSIX types, like FileOffset not being an Int
13:12:38 <Saizan> System.IO ?
13:13:53 <HairyDude> ah yes
13:20:58 * BMeph thinks "pathologically crafted regular expressions" should be the new standard meaning for PCRE
13:25:01 <dons> JaffaCake: so -A300M is *required* for binary-trees, to get any parallelism.
13:25:03 * Heffalump gets reminded the hard way that Outlook and the internet don't agree on line-wrapping conventions for email
13:25:15 <dons> go Heffalump !
13:37:40 <marcot> dons: what do you think about the idea of using other software instead of mpg321?  I think running another program for each supported format is not a good idea.
13:39:00 <dons> marcot: i think using a library based over mplayer is better yes :)
13:39:06 <dons> we just want to keep the UI basically
13:39:16 <dons> but that's almost a rewrite. perhaps you'd actually like to try to do a rewrite
13:39:24 <dons> using modern media playing libs?
13:39:32 <marcot> hum..
13:39:33 <dons> whatever rhythmbox uses, for example
13:39:35 <marcot> this sounds interesting.
13:39:42 <dons> no external tools
13:39:46 <marcot> I'm afraid of rhythmbox.
13:39:49 <dons> just a media play ing library and a nice console skin
13:40:09 <marcot> But I can try to see what it uses..
13:40:18 <drigz> gstreamer
13:40:23 <dons> yeah.
13:40:24 <marcot> But the interface can be kept.
13:40:33 <dons> write a binding to that. and then use the hmp3 interface
13:40:37 <dons> since i like the ui too :)
13:40:41 <dons> its just the backend that's a pain.
13:41:03 <dons> i don't have time to work on it though.
13:41:06 <dons> ?users
13:41:07 <lambdabot> Maximum users seen in #haskell: 504, currently: 478 (94.8%), active: 15 (3.1%)
13:41:10 <marcot> ok, I'll take a look.
13:41:25 <marcot> But don't you think gstreamer is too much for it?
13:42:28 <dons> maybe...
13:42:37 <dons> we just want a nice media playing library.
13:43:25 <Myoma> what then?
13:43:37 <Saizan> there are binding to gstreamer inside gtk2hs, iirc
13:43:56 <marcot> Saizan: there are.
13:45:13 <marcot> Saizan: I'm checking if they're complete.
13:47:07 <marcot> Gotta go, I'll take a look at it latter.
13:50:54 <mc___> can I run actions in a where clause?
13:51:49 <Myoma> mc___: You can't really run actions anywhere
13:51:51 <Myoma> you can write
13:51:57 <Myoma> foo = do bar ; baz ; quux
13:51:59 <Myoma>  where bar = ...
13:52:11 <Myoma> unless the monad has a way like runState
13:52:52 <mc___> sorry, I dont really understand
13:53:19 <Myoma> what did you want to do?
13:54:55 <mc___> Myoma: well not this is how I tried is http://haskell.pastebin.com/m7b98f1bb
13:55:10 <mc___> I hope you get the idea of what I wanted to do
13:55:42 <mc___> ignore the copy & paste error in the last line
14:00:16 <Saizan> mc___: then no, you can't use "x <- foo" in a where
14:00:26 <Saizan> you can use that only in a do-block
14:00:47 <mc___> and there cant be a do block in a where block?
14:01:00 <_Dae_> It's a pity that so few of the haskell entires on the shootout are pure.... or even close
14:01:02 <drigz> mc___: you could but the name would only be bound within that do block
14:01:06 <Saizan> yes, but it looks like where foo = do ...
14:01:13 <drigz> mc___: if it helps, you can put lets into a do block
14:01:36 <mc___> lets?
14:02:37 <drigz> http://haskell.pastebin.com/m1f9e28eb
14:02:57 <Saizan> http://haskell.pastebin.com/m8ad4a5e
14:03:04 <drigz> in fact, i didn't read the code properly, but it'll have to be rearranged
14:03:08 <Saizan> heh :)
14:03:36 <Saizan> oh, yeah, you've to define a and b before you use them
14:03:50 <byorgey> note, Saizan's version is missing a "do" and an IO in the type
14:04:25 <drigz> http://haskell.pastebin.com/m339d0dfd perhaps
14:04:47 <mc___> what is the difference between let and where?
14:04:51 <byorgey> that ought to do it
14:04:58 <drigz> mc___: where goes afterwards
14:05:06 <drigz> mostly aesthetic
14:05:13 <byorgey> also, where can only go after declarations
14:05:22 <byorgey> whereas a 'let' can go before any expression
14:05:38 <FordCortina> there's no "in" in a "do-let" right?
14:05:44 <byorgey> FordCortina: right.
14:06:00 <drigz> FordCortina: i think if you use an 'in' you start a whole new expression
14:06:01 <byorgey> or rather, there doesn't need to be.
14:06:03 <drigz> rather than continuing the do
14:06:10 <drigz> maybe i'm wrong
14:06:10 <byorgey> right.
14:06:52 <byorgey> do {let foo = bar; baz} just gets desugared to  'let foo = bar in do {baz}
14:07:55 <sjanssen> @undo do {let foo = bar; baz}
14:07:56 <lambdabot>  Parse error at "}" (column 23)
14:08:10 <sjanssen> @undo do let foo = bar; baz
14:08:11 <lambdabot>  Parse error at end of input
14:08:27 <sjanssen> @undo do let {foo = bar}; baz
14:08:28 <lambdabot> let { foo = bar} in baz
14:10:01 <FordCortina> hmm the result of randomR doesn't seem to be monadic so, i dont thing they should be in a do expression
14:10:12 <FordCortina> s/thing/think/
14:10:22 <byorgey> @type randomR
14:10:24 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
14:10:31 <byorgey> oh, indeed
14:11:18 <byorgey> and then you also have to thread the new generators through manually =P
14:11:37 <byorgey> @type randomRIO
14:11:39 <lambdabot> forall a. (Random a) => (a, a) -> IO a
14:12:23 <FordCortina> last time i messed with this stuff was two years ago... i barely new what a monad was hehe
14:12:45 <byorgey> http://haskell.pastebin.com/m78480a15
14:13:02 <byorgey> mc___: see above
14:14:11 <mc___> byorgey: thank you, randomRIO is very handy in this case
14:14:57 <byorgey> mc___: yup, if you only want a few random values it's annoying to actually make a generator and so on.
14:15:35 <byorgey> otherwise, you can either use a generator to make a list of random numbers and thread that around, or use a Random monad which hides the generator plumbing
14:15:53 <byorgey> is the Random monad going to make it into the libraries anytime soon?
14:15:57 <byorgey> or maybe it's already there?
14:16:38 <mc___> I'd rather not use a monad, I do not yet really know what a monad is :)
14:16:38 <FordCortina> @hoogle Random
14:16:38 <lambdabot> module System.Random
14:16:38 <lambdabot> System.Random class Random a
14:16:38 <lambdabot> package random
14:16:53 <mc___> I'm 7 chapters away from monads
14:17:21 <sgillespie> hello
14:17:53 <FordCortina> mc___: IO is monad :D
14:18:01 <sgillespie> I have some questions about the spineless tagless g-machine as it pertains to the implementation of ghc
14:18:12 <FordCortina> is a*
14:19:38 <FordCortina> mc___: just don't get caught up in trying to work out "what monads are" in an abstract sense. you will just get confused. just keep doing practical examples
14:20:29 <mc___> FordCortina: I'd like to understand the concepts behind haskell, they are very interesting :)
14:32:47 <dons> JaffaCake: unfortunately, binary-trees spec won't allow -A flags :/
14:32:54 <dons> so this is a tough one without per-thread heaps.
14:39:05 * byorgey bakes lambdasnaps
14:39:10 <mc___> is there a standard method to sort a triple?
14:39:20 <byorgey> mc___: nope
14:39:47 <mc___> alright
14:46:26 <Cale> :t (\[x,y,z] -> (x,y,z)) . sort . (\(x,y,z) -> [x,y,z])
14:46:27 <lambdabot> forall a. (Ord a) => (a, a, a) -> (a, a, a)
14:46:47 <Cale> (triples aren't really meant for sorting :)
14:46:54 <guenni> mmorrow: hi, how is the "yi" slaying going, who's winning, who's whining?
14:47:10 <mmorrow> guenni: heh, i won!
14:47:28 <guenni> mmorrow: was it worth the bloodshed?
14:47:35 <byorgey> Cale: oh, nice, for some reason I don't think I would have thought of that =)
14:47:56 <mmorrow> guenni: i haven't had much time to mess with it yet, but it's all built and setup on newest ghc. from the looks of it, definitely worth it.
14:48:19 <guenni> mmorrow: so it did start up?
14:51:04 <mmorrow> guenni: yeah, started up and works nicely. the thing is though, it's fully customizable. everyone's yi is compiled from their personal config
14:51:20 <mmorrow> i just put the docs i built with mine here. so much stuff
14:51:22 <mmorrow> http://moonpatio.com/docs/yi.20080912-docs/
14:51:28 <lambdabot> Title: yi-0.4.4: The Haskell-Scriptable Editor
14:52:47 <guenni> mmorrow: where did you get version 0.4.4 from?
14:52:57 <mmorrow> and it's hooked into ghc, so you can dynamically eval code, typecheck code in random buffers, do anything that you can do with haskell in ghci, but unlike ghci you can mod the program itself
14:53:01 <mmorrow> the darcs repo
14:53:09 <mmorrow> http://code.haskell.org/yi
14:53:28 <mmorrow> err, code.haskell.org looks to be down currently :(
14:54:13 <mmorrow> i had to hack it slightly to get it working with ghc-HEAD
14:54:18 <guenni> here some unix dependency stops me from getting it compiled
14:55:01 <mmorrow> crappy. are you trying for osx or windows, because i bet there's someone who has it running on osx (?)
14:55:20 <mmorrow> (someone that know how to get around the problem)
14:55:33 <guenni> no choice here I need to have it run on windows
14:56:11 <guenni> and one day I will go after all those guys who make their packages depending on unix, that day will come!
14:56:17 <mmorrow> grr.
14:56:35 <mmorrow> it seems like this is the only (?) module that really requires unix http://moonpatio.com/docs/yi.20080912-docs/Yi-Process.html
14:56:36 <lambdabot> Title: Yi.Process
14:56:54 <mmorrow> maybe it could be hacked somehow to run on windows
14:58:34 <guenni> ghc on windows seems to be more problematic period
14:59:31 <mmorrow> i get that sense from various misc things i've read, but haven't really used it on windows much..
14:59:47 <mmorrow> ok, i'm off to eat
14:59:56 <guenni> bon apetite
15:06:48 <xpika> hpc is cool
15:11:00 <udoprog> how would i do if a wanted to declare a data that was a vector (list) containing anything derived from the class Num?
15:11:25 <udoprog> i am currently using: data Vector = Vector [Int] , but i want to expand it
15:11:53 <MyCatVerbs> Can't derive (many) instances automatically, but you can have, for example:
15:12:36 <MyCatVerbs> instance Num Vector where { a + b = zipWith (+) a b, ... }
15:12:50 <mc___> can  haskell itself solve equations?
15:12:55 <dons> ?faqq
15:12:56 <lambdabot> The answer is: Yes! Haskell can do that.
15:13:00 <MyCatVerbs> mc___: only in the type system. ;)
15:13:15 <dons> in ghc, equations solve haskell!
15:13:16 <mc___> MyCatVerbs: ?
15:13:26 <MyCatVerbs> mc___: (no. It doesn't have a unifier built in. It's not too painful to write one, but it's not a constraint programming language by itself).
15:13:27 <dons> mc___: the type system is a constraint solver.
15:13:51 <MyCatVerbs> mc___: sorry, I was making a half-joke. As in, it was a joke, but it was also true. :)
15:13:52 <mc___> I see, thank you
15:14:02 <udoprog> MyCatVerbs: but how would i declare a Vector to conain anything else than a list of Int's?
15:14:09 <mc___> MyCatVerbs: nevermind :)
15:14:35 <MyCatVerbs> udoprog: you could have a class Vector a, and instance (Num a) => Num (Vector a) where..., perhaps?
15:16:04 <MyCatVerbs> udoprog: or you could give some entirely different definition of Vector. Like if you're only interested in three-dimentional cartesian vectors, you could give the definition, data Vector3 = Vector3 Double Double Double, which defines that a Vector3 is built out of three double-precision floating-point numbers.
15:16:21 <MyCatVerbs> s/dimentional/dimensional/ (wow, I feel silly)
15:16:40 <udoprog> heh, not compared to my mistakes
15:17:35 <udoprog> so i could use something like data Vector = Vector [Int] | Vector [Integer] | Vector [Char] ... etc?
15:18:16 <dons> yikes.
15:18:25 <dons> that's a weird type
15:18:27 <MyCatVerbs> udoprog: no.
15:19:01 <MyCatVerbs> udoprog: you could have (Vector a), where you can then use (Vector Int), (Vector Float), (Vector Double) and so on. Vector (Vector Double), even. :)
15:19:21 <udoprog> ah, i see
15:19:37 <MyCatVerbs> udoprog: what you just gave was something like a tagged union type, which isn't what you want at all. Besides which, in a tagged union, the constructors have to have different names. :)
15:20:16 <dons> dcoutts_: Igloo , code.h.o down?
15:20:42 <MyCatVerbs> udoprog: so. Let's say we have data Vector3 a = Vector3 a a a -- yes? Now you've defined a constructor Vector3, which can be used like a function of type a -> a -> a -> Vector3.
15:21:18 <MyCatVerbs> udoprog: the 'a' in there is a type variable. Because there aren't any constraints on it, any old damn type you want can go in there. You could make Vector3 (SomethingIJustPulledOutOf MyNose), if you felt like it. ^^
15:21:29 <Igloo> dons: Looks like it
15:22:02 <udoprog> MyCatVerbs: kk, how would an instance declaration for Num look on that?
15:22:13 <MyCatVerbs> Or even data Vector a = Vector [a], in which case you've defined Vector :: [a] -> Vector a. e.g. (Vector [1::Int,2,3,4,5,6]) is of type Vector Int.
15:22:49 <MyCatVerbs> udoprog: depends how you want to define addition, multiplication and subtraction. ;)
15:24:01 <udoprog> i'm having problem with the first row, before the 'where' keyword
15:24:07 <MyCatVerbs> udoprog: instance (Num a) => Num (Vector a) where... says that, if 'a' is in Num, then so is 'Vector a'. e.g. Int is in Num, so Vector Int will be in Num too.
15:25:00 <udoprog> MyCatVerbs: k, thanks : )
15:25:42 <MyCatVerbs> udoprog: you could also give specific instances if you want to, like you could just say: instance Vector Double where... if you wanted, which just says outright that Vector Double is in Num. Usually more useful to do it by using typeclass operations though, because that way you only have to give one definition (for the Num case) and Haskell can infer it for you for _all_ the Num cases. ^_^
15:39:56 <cads> > let matri n = map (\k->map (\x->k^x) [1..n]) [1..n] in matri 4
15:39:57 <lambdabot>   [[1,1,1,1],[2,4,8,16],[3,9,27,81],[4,16,64,256]]
15:40:50 <hackage> Uploaded to hackage: cabal2arch 0.4
15:46:55 <cads> is there a more elegant way of expressing the above function?
15:47:07 <sjanssen> @seen dons
15:47:08 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 7m 17s ago.
15:47:24 <sjanssen> dons: the alternative instance for JSON's Result is dubious, I think
15:47:50 <dons> send in code :)
15:48:14 <sjanssen> is it intentional that Error x <|> Error y == Error x?
15:48:22 <sjanssen> Error y seems more useful
15:49:38 <Zao> > let f n = [[k^x | x <- [1..n]] | k <- [1..n]] in f 4
15:49:39 <lambdabot>   [[1,1,1,1],[2,4,8,16],[3,9,27,81],[4,16,64,256]]
15:49:59 <unmarshal> hackage lagging for anyone else?
15:50:12 <Zao> cads: Elegant enough?
15:50:18 <dons> elliottt: around
15:50:27 <dons> do you remember what the Alternative instance in JSON was about?
15:50:38 <dons> sjanssen: yeah, that looks dubious
15:50:45 <dons> opposite of what Monad Maybe would do
15:50:49 <dons> or is it.
15:50:55 <dons> no, first choice
15:50:55 <cads> I like your notation zao : )
15:50:56 <bos> > let f n = [k^x | x <- [1..n], k <- [1..n]] in f 4
15:50:57 <lambdabot>   [1,2,3,4,1,4,9,16,1,8,27,64,1,16,81,256]
15:51:06 <sjanssen> dons: also, the it seems more useful for the Maybe instance to parse null or the presence of an object
15:51:10 <bos> heh.
15:51:27 <cads> : )
15:51:30 <sjanssen> erm, maybe it does and I'm doing something else incorrectly
15:51:38 <dons> the null thing is weird.
15:51:43 <dons> since it inhabits every js type.
15:52:06 <bos> has Text.JSON seen some work lately? is it using overlapping instances yet?
15:52:11 <FunctorSalad> meh, lack of deriving for GADTs is a pain if you have a data with 20 constructors or so
15:52:20 <sjanssen> dons: I suppose you've worked with this a fair amount?  How do you handle nulls?
15:52:40 <dons> i've not used it in a while. but we do to /from decoding, so have more control
15:52:48 <dons> do you just want examples?
15:52:50 <sjanssen> maybe I should switch to XML, maybe they'd give an actual scheme
15:52:53 <dons> heh
15:52:59 <dons> what are you parsing?
15:53:00 <sjanssen> schema, rather
15:53:07 <sjanssen> damned dynamic typed pukes
15:53:10 <sjanssen> dons: twitter's output
15:53:15 <dons> ah yup.
15:53:22 <dons> maybe look at what the existing twitter binding does
15:53:26 <Zao> bos: You missed the grouping by N.
15:53:28 <dons> CosmicRay's got one too.
15:53:44 <bos> Zao: yes, i noticed.
15:54:34 <dons> seems like the json lib needs either more examples, or a different api.
15:54:38 <dons> people get stuck a lot.
15:54:45 <dons> something that doesn't seem to happen with Data.Binary
15:54:51 * dons ponders
15:55:59 <bos> i think the confusion arises in JSON's support for heterogeneous collections.
15:56:13 <bos> which we must wrap up with more layers of type gunk.
15:56:19 <sjanssen> dons: one thing that was confusing is that there is no clear String -> JSValue
15:56:23 <dons> yes.
15:56:33 <sjanssen> dons: decode is overloaded to do that, but it isn't typical
15:56:45 <dons> and there was tension inside galois about whether to do overlapping instances, or h98 string hack style.
15:56:58 <dons> bos, see http://www.phildawes.net/blog/2008/09/11/searching-arrays-in-x86-assembler-with-a-bloom-filter-pt-2/
15:57:08 <sjanssen> a synonym for decode at that type would be very useful, and would reduce the amount of times I have to use "::" at ghci
15:57:09 <lambdabot> Title: Phil Dawesâ€™ Stuff Â» Blog Archive Â» Searching arrays in X86 assembler with a  ..., http://tinyurl.com/3f8hmx
15:57:12 <bos> dons: his code made my eyes hurt.
15:57:24 <dons> if someone who's not already full loaded wants to think about sensible defaults for the mapping to json
15:57:30 <dons> i'm all ears and commit bits.
15:57:53 <sjanssen> dons: well, I don't want to break any code (changing serialization formats is bad)
15:58:18 <dons> right. but we can add new interfaces.
15:58:56 <zloog> hi all
15:59:19 <sjanssen> for now I use newtype Nullable a = Nullable (Maybe a)
16:00:17 <Stinger> is there a way to see what packages the online version of hoogle supports?
16:04:25 <udoprog> lass Mult a b c | a b -> c where
16:04:42 <udoprog> what exactly does 'a b -> c' mean here?
16:05:04 <roconnor> c can be infered from a and b
16:05:13 <udoprog> what ive gathered is that 'c is uniquely determined from a and b', but i cannot relate to that : P
16:05:33 <roconnor> I think the wiki has a reasonable explaination
16:06:01 <roconnor> If Mult Int Int Int is instantiated
16:06:01 <udoprog> what should i search on?
16:06:09 <roconnor> then Mult Int Int Char won't be
16:06:17 <roconnor> search for fundeps
16:06:22 <roconnor> or fundep
16:06:33 <roconnor> or functional dependencies
16:06:51 <roconnor> or multi-parameter type classes
16:09:22 <udoprog> so what is the practial difference?
16:11:38 <sjanssen> udoprog: it allows the compile to infer types more easily
16:11:57 <sjanssen> "a b -> c" lets the compiler know that if a and b are known, then c is known
16:12:20 <bos> where "more easily" == "at all" much of the time
16:12:50 <bd_> there is no ease. It's either possible or not :)
16:13:03 <sjanssen> eg. this can only be one type "Mult Int Int c => c", where it could be any number of types without that functional depedency
16:13:42 <udoprog> kk, i guess i'm gonna have to sleep on that and get back on it in the morning
16:13:46 <udoprog> thanks
16:13:52 <sjanssen> s/more easily/more often
16:14:01 <lispy> c.h.o is down again?
16:14:06 <TomMD> Yes
16:14:12 <sjanssen> lispy: up for me
16:14:18 <TomMD> Really?
16:14:19 <TomMD> humm
16:14:27 <sjanssen> http://code.haskell.org
16:14:29 <lambdabot> Title: Index of /
16:14:33 <sjanssen> up for the bot too
16:14:33 <lispy> hmm..yeah I just went to c.h.o and it is up...i'll try the specific url again
16:14:35 <TomMD> Ah, up now.
16:14:43 <TomMD> It wasn't working ten minutes ago for me.
16:14:51 <lispy> okay it went back up between me asking and you trying it sems :)
16:15:01 <sjanssen> TomMD: it seems all of the *.haskell.org servers have been rather slow today
16:15:12 <sjanssen> hackage too
16:15:14 <lispy> I thought the problem was traced to a bad switch
16:15:22 <lispy> But, it seems there may be other issues
16:15:48 <lispy> hmm...os c.h.o/happs-tutorial is not a demo?
16:16:05 <lispy> oh, maybe that's what happstutorial.com:5001 is
16:21:38 <elliottt> dons: the Alternative instance was supposed to take the first successful result
16:21:56 <elliottt> that second pattern is probably not necessary, and could be replaced with a pattern match on Error in the first argument
16:22:06 <ddarius> dbueno: Try insertWith'
16:22:16 <elliottt> Ok a <|> _ = Ok a; Error _ <|> b = b
16:22:33 <dbueno> ddarius: Hm, on the IntMaps?
16:23:20 <dbueno> ddarius: so there is a custom insertWith' I was using.  Is that what you're referring to?
16:23:58 <lispy> Oh laziness, how subtle your bugs are
16:24:14 * lispy assumes insertWith' is a strict version for performance reasons
16:24:22 <dons> for well, sensible reasons, yes.
16:26:08 <dan> ?src mod
16:26:08 <lambdabot> Source not found. My pet ferret can type better than you!
16:26:11 <dan> :t mod
16:26:12 <lambdabot> forall a. (Integral a) => a -> a -> a
16:26:14 <zloog`> Hi, I'm trying to run Picture.lhs from the haskell school of
16:26:14 <zloog`>         expression book. It is complaining about not being able to find
16:26:14 <zloog`>         Graphics.UI.GLFW though, so I went to http://glfw.sourceforge.net/ and
16:26:14 <zloog`>         did the install. It still does not see it. How do I control where ghci
16:26:15 <lambdabot> Title: GLFW - An OpenGL Framework
16:26:17 <zloog`>         looks to find modules?
16:26:29 <zloog`> opps, sorry for bad formating on that question.
16:26:40 <dbueno> ddarius: Is there something wrong with the insertWith' I provided?
16:26:45 <zloog`> running Ubuntu, if that matters.
16:28:23 <zloog`> Sorry, that was a C lib. no woder t didnt work...
16:40:05 <augustss> hi
16:43:19 <Heffalump> hi
16:43:56 <adekoba> hi hi hi
16:45:21 <augustss> Did you forget to proofread the job ad? :)
16:45:29 <Heffalump> err, why?
16:45:36 <Heffalump> I know I messed up the line-wrapping.
16:45:49 <augustss> There's one sentence in the general blurb that's repeated.
16:46:19 <Heffalump> the stuff at the bottom? I cut-and-paste that from elsewhere and barely skimmed it :-)
16:46:37 <unmarshal> hmm, can someone give me some insight here.
16:46:49 <unmarshal> why does foldl' (+) 0 [1..1000000] work out fine
16:46:51 <unmarshal> but this crashes
16:46:54 <unmarshal> mean'' x = foldl' (\(m,n) x -> (m+(x-m)/(n+1),n+1)) (0,0) x
16:47:02 <unmarshal> it's tail recursive
16:47:29 <unmarshal> keeping an accumulator as a tuple is only difference
16:48:49 <dmwit> You're building thunks inside the tuple.
16:49:06 <dmwit> (foldl' only promises strictness up to WHNF, so the first constructor.)
16:49:09 <dmwit> Try this instead:
16:49:27 <dmwit> mean'' x = foldl' (\~(m, n) x -> (m+(x-m)/(n+1),n+1)) (0,0) x
16:49:33 <unmarshal> sec
16:49:48 <ddarius> dmwit: That won't parse and doesn't make any sense.
16:49:50 <unmarshal>     parse error on input `->'
16:50:02 <dmwit> uh
16:50:10 <xci> Hey guys, I was trying to call a C-function from Haskell-code using edstrÃ¶m's blog, but my compiler complains parse error on import when I try out that 'foreign import' - am I missing some library or something?
16:50:21 <ddarius> unmarshal: If you don't mind using a GHC-only extension, simply write \(!m,!n) instead and enable BangPatterns.
16:50:30 <lispy> xci: -fffi I think
16:50:43 <unmarshal> okay
16:50:47 <unmarshal> will give it a shot
16:50:54 <unmarshal> make it strict?
16:50:58 <xci> lispy: as a compiler flag only?
16:51:14 <ddarius> unmarshal: That will cause m and n to be forced when the tuple containing them is forced.
16:51:20 <lispy> xci: yeah, in ghc/ghci you need to say -fffi on the command line
16:51:30 <lispy> xci: I think, I could have the flag wrong, but I think that was it
16:51:39 <unmarshal> okay, so this is just sitting around waiting to be lazily evaluated
16:51:45 <unmarshal> even though the list is being handled strictly?
16:52:25 <dmwit> unmarshal: What's actually happening is that the arithmetic inside the tuple is waiting to be lazily evaluated, even though it knows (strictly) that it is a tuple.
16:52:26 <lispy> unmarshal: it's as dmwit says, it's the tuples that are killing you
16:52:59 <dmwit> unmarshal: i.e. at each step of the fold, it evaluates the tuple up to the (,) constructor, then stops.
16:53:30 <unmarshal> okay that makes sense
16:53:32 <unmarshal> thanks guys
16:53:35 <unmarshal> trying out the solution now
16:53:45 <unmarshal> *Math.Statistics> mean'' [1..1000000]
16:53:48 <unmarshal> (500000.5,1000000.0)
16:53:51 <unmarshal> excellent
16:53:54 <unmarshal> thank you very much
16:54:02 <unmarshal> this is my first encounter with lazy evaluation problem
16:54:04 <unmarshal> many more to come i'm sure
16:54:31 <dmwit> unmarshal: But for speed, you might want to let the accumulator just accumulate the sum and length, then leave the division to the end.
16:54:40 <dmwit> (Since you're not returning any of the intermediary means.)
16:54:45 <unmarshal> good idea
16:54:47 <unmarshal> trying that now
16:55:14 <xci> lispy: yeah, that helped at least a bit :), thanks :)
16:55:48 <ddarius> unmarshal: Just read http://www.haskell.org/haskellwiki/Stack_overflow
16:55:50 <lambdabot> Title: Stack overflow - HaskellWiki
16:56:06 <unmarshal> i did, i was using foldl before that
16:56:10 <unmarshal> found the '
16:56:11 <dmwit> heh
16:56:16 <unmarshal> was still curious why it wasn't working :)
16:56:20 <unmarshal> thanks for you guys helps
16:56:49 <unmarshal> err
16:56:51 <unmarshal> that was broken
16:56:55 <unmarshal> thanks for your help guys
16:56:56 <unmarshal> lol
16:57:19 <TomMD> I've met a number of profs who would like to experiment with a pure, strict, functional language.  I know its a common statement, but it would be interesting to see.
16:57:38 <ddarius> TomMD: It's a common statement?
16:58:17 <ddarius> Also, it is easy enough to use ML or Scheme in a pure manner.
16:58:19 <TomMD> ddarius: I've heard it from many new comers on IRC and places like proggit.
16:58:42 <TomMD> ddarius: But I've also heard it from the likes of Tolmach and Gill.
16:59:29 <dbueno> ddarius: I assume you're thinking of what's been mentioned several times on the mailing list, where insertWith' was the answer to retainers.  But I'm using an insertWith', and I still have the problem.
16:59:34 <ddarius> What's there to experiment with?
17:00:17 <ddarius> dbueno: IntMap's doumentation doesn't have a alter function.  Where is that coming from (or is the online documentation just out of date?)
17:00:20 <lispy> Yeah, what is interesting about removing destructive updates?
17:00:52 <dbueno> ddarius, Yeah that's _really_ weird
17:01:02 <TomMD> I suppose 'experiment' is the wrong choice of words (on my part).  Rather, the expressed sentiment was that lazyness is interesting but not an overall benefit.
17:01:06 <dbueno> ddarius: It's been compiling since yesterday; I didn't even look at the docs, I just switched my imports
17:01:59 <augustss> TomMD: A Haskell with strict default would be interesting.  With laziness as an option, of course.
17:01:59 <xci> do you know how to do a CInt->Int transform?
17:02:01 <lispy> TomMD: I think Miranda fits the bill here.  I may be mistaken but I want to say it's like Haskell except strict?
17:02:10 <augustss> xci: fromIntegral
17:02:12 <TomMD> xci: fromIntegral
17:02:23 <augustss> lispy: it was lazy
17:02:40 <lispy> IMO, laziness becomes most interesting when the compiler has support to make it efficient.  That's my objection to just having a "lazy module" ala O'Caml
17:03:16 <lispy> and, python has a way to make thing lazy via generators.  But I wouldn't consider python to be interesting
17:04:53 <TomMD> Yeah, Python got dull to me quickly.  The only type errors it gave me crashed the program :-(
17:05:06 <lispy> I guess I have a hard time beliveing that if you allow both strict and lazy strategies that they would get equal treatment
17:05:28 <lispy> (equal treatment from the compiler construtor people)
17:05:49 <TomMD> lispy: I'd say Haskell comes closest.  Strictness is much more common here than lazyness is in any other language I see.
17:06:56 <lispy> Okay.  And we seem to have gotten here by using laziness as the generalization to strictness.  We do strictness analysis and have some a tricks to make some things strict.
17:07:17 <TomMD> Yep
17:07:42 <lispy> But, we still get bitten at times by laziness.  Usually because things can't be garbage collected soon enough or thunks build up too much.
17:07:57 <TomMD> lispy: I'm certainly not arguing.
17:08:24 <lispy> I'm just sort of enumareting what I know about the discussion
17:08:46 <lispy> oh another tuff spot seems to be lazyIO
17:08:52 <TomMD> When I ran into SPJs strictness work (early and mid 90s) it looked and sounded great to me.  When I spoke to him about it he seemed to feel like it was all for naught.
17:09:28 <ddarius> These things are aspects of lazy evaluation, not aspects of it being the default.  Eager evaluation has similar issues as well.  In the end, the point is to be cognizant of what is going on.
17:09:41 <TomMD> Really unfortunate.  It seems like an area that could have so much to offer.
17:11:43 <lispy> You can now live in Haskell it seems
17:11:51 <lispy> ?go Haskell, Oklahoma
17:11:55 <lambdabot> http://www.city-data.com/city/Haskell-Oklahoma.html
17:11:55 <lambdabot> Title: Haskell, Oklahoma (OK) Detailed Profile - relocation, real estate, travel, jobs, ...
17:13:30 <ddarius> lispy: There's a Haskell, TX as well.
17:14:29 <TomMD> Bah.  Haskell is just a fancy name for Portland.
17:14:39 <lispy> heh
17:14:52 <lispy> TomMD: are you in Portland too?
17:14:57 <TomMD> Soon.
17:15:31 <lispy> I guess we'll need to start having regular pub meetings for Haskellers in Portland
17:16:01 <TomMD> But pubs don't serve White Russians!
17:16:14 <Cale> I'm going to build a Port Land theme park... in Eugene.
17:16:40 <dmwit> You could have the Port Land LAN Porty.
17:17:04 <TomMD> If thats like a Hackathon then I'm in.
17:17:19 <lispy> Cale: wait, are you in Eugene Or?
17:17:27 <Cale> No.
17:17:31 <Cale> I'm joking :)
17:17:45 <Cale> I live in Canada. :)
17:17:52 <lispy> that's what I thought
17:18:04 <lispy> I just thought maybe you moved to Eugene at some point :)
17:18:35 <TomMD> Canada is neither brit nor aussie nor oregonian.  I now must rework my definition of a Haskell hacker.
17:18:42 <sgillespie> I'm trying to work out how the ghc STG Machine works when we generate Cmm
17:19:20 <thoughtpolice> @seen dons
17:19:20 <lambdabot> dons is in #darcs, #arch-haskell, #ghc, #xmonad and #haskell. I last heard dons speak 54m 57s ago.
17:19:26 <thoughtpolice> dons: ping?
17:19:32 <Cale> I just liked the idea of building a theme park named Port Land, not in Portland, but somewhere close by. Maybe right next to New 'Z' Land (one of 26 alphabet themed parks around the country).
17:19:43 <sgillespie> With a G Machine we have several Operations - Push, Enter, ReturnX
17:20:02 <sgillespie> I see that in ghci, but not during native code gen
17:21:38 <ddarius> TomMD: Quite a few South American Haskellers.
17:22:54 * lispy tries not to make any jokes about waxed and purely functional
17:23:12 <dmwit> sgillespie: I never actually finished the paper (so maybe you should ignore me), but I thought that the translation to Cmm was a translation *away* from the STG machine.
17:23:32 <araujo> ddarius, one here!
17:23:34 <dmwit> i.e. it's like Haskell -> STG -> Cmm
17:23:36 <Cale> http://thedailywtf.com/Articles/SQL-Injection-Protection--3.aspx -- ahaha :)
17:23:36 <xci> hmm, I made a prime sieve function with C, which works very well with C itself, however, when called from haskell it always returns a list full of zeroes, do you have a clue why this happens?
17:23:37 <lambdabot> Title: SQL Injection Protection * 3 - The Daily WTF
17:23:54 <Cale> xci: How does it produce its result?
17:24:08 <Cale> (and how are you reading that result)
17:24:20 <sgillespie> dmwit: what paper?
17:24:23 <xci> well, I am printing the result
17:25:03 <dmwit> sgillespie: Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine
17:25:11 <xci> ah well but seems that I am failing somehow
17:25:12 <Cale> Yeah, but, I assume you're calling the C function from Haskell?
17:25:34 <Cale> Presumably doing some FFI to import the function which does the sieving?
17:25:35 <xci> since it works somehow with ghci, though it seems to have some random pointer failures
17:25:39 <xci> Cale: yes
17:25:45 <sgillespie> Ahh.. I should read that one
17:26:48 <dmwit> sgillespie: People who ought to know say that GHC doesn't follow that architecture any more... but that it gives a good intuition about how it works, anyway.
17:26:50 <Cale> xci: And presumably you're doing malloc and free on the Haskell side of things?
17:27:02 <b\6> is there prettyprinting stuff that would help render aligned columns?
17:27:11 <sgillespie> sounds like a nice place to start anyhow
17:27:12 <xci> Cale: yes, but now I recompiled and relinked and now it seems to be working quite fine :)
17:27:18 <Cale> Ah, okay.
17:27:26 <Cale> :)
17:35:25 <Saizan> Data.Dynamic is not implemented as data Dynamic = forall a. Typeable a => Dynamic a for efficiency?
17:37:47 <dons> i doubt it is efficiency that is the reason.
17:38:21 <|jedai|> Saizan: It's implemented as data Dynamic = Dynamic Typerep Obj
17:38:51 <|jedai|> But I fail to see how your representation would work ? How would you cast back ?
17:39:20 <dons> the casting is the issue.
17:40:01 <vlan2> hi! i'm writing a concurrent program using forkIO (just a test). there is a client exchanging messages with two servers. i'm using Chan (i. e. Chan a) as a communications medium, so there are 3 chans (one chan per peer). it's important for me to have replies from servers multiplexed in the client's chan. and i got a problem. how should i define the type of the chan to be able to receive messages from two servers that send different (unrelated) ty
17:40:18 <lispy> also, in the HList paper didn't they discover that putting type class constraints into data declarations is a bad idea?
17:40:54 <dons> vlan2: it'll have to be say, Chan (Either A B)
17:41:08 <Jedai> vlan2: You don't, you just encapsulate both type in another sum type in order to differentiate at the end
17:41:08 <dons> where thread 1 sends Left foo, and thread 2 sends Right bar
17:41:48 <Jedai> And as dons said, Either is perfect for a sum of 2 different types ^^
17:41:49 <Cale> vlan2: your message was cut off.
17:41:58 <Cale> vlan2: (at "different (unrelated) t")
17:42:24 <vlan2> dons: isn't it mean that server1 has to know about server2? (they are coupled via type)
17:42:29 <Saizan> Jedai: i can use Data.Typeable.cast, no? i can always get the TypeRep back with typeOf anyhow
17:42:30 <Jedai> Cale: That's funny, me I got the "y" after the "t", do you think it's a client issue ?
17:42:47 <vlan2> Cale: ... (unrelated) types of messages?
17:43:04 <Cale> Jedai: It's secretly a problem with the IRC protocol.
17:43:24 <mmorrow> we can't stop here, this is bat country!
17:43:27 <Cale> Jedai: It's impossible for clients to know what the longest message they can send to the server is.
17:43:39 <Cale> (and thus, where to break messages)
17:43:43 <dmwit> Jedai: Servers with longer names can only accept shorter messages(!)
17:43:52 <Saizan> lispy: why is it a bad idea to put type class constraint on constructors?
17:44:34 <Cale> vlan2: I would probably use multiple Chans if I was sending multiple types of data. Using a sum type like Either would be another possibility.
17:44:36 <lispy> Saizan: I don't remember...Maybe in their case it was entirely to do with keeping type checking sane
17:44:51 <Cale> Saizan: Because they don't do anything but constrain the type of the constructor.
17:45:07 <Jedai> Saizan: I think lispy is confused with putting constraint in the data head, putting constraint on existential is fine (and a good idea to have useful existential)
17:45:14 <Cale> (In particular, they don't let you remove any class contexts from the types in your program)
17:45:44 <Saizan> Cale: ok, but that's valid for data Foo a => Bar a = .., i'm using data Bar = forall a. Foo a => ..
17:45:47 <Cale> ... unless, that is, you're using the GADT syntax, and GHC 6.8+
17:45:50 <Jedai> Cale: Saizan example wasn't data Typeable a => Truc a = Truc a
17:46:08 <Cale> oh -- in that case, that's just an existential
17:46:19 <Cale> There's no problem with that.
17:46:46 <Cale> (however, there are completely silly and useless existential types you can create)
17:47:33 <Cale> For example, something like  data Readable = forall a. (Read a) => ...
17:47:39 <Saizan> Cale: my main question was why we don't have Dynamic implemented as just an existential with Typeable, btw
17:47:43 <vlan2> Cale: yes, i'm aware of using multiple chans, but i just want to explore the type system a little bit. so doesn't it mean (in the case of Either) that server1 has to know about server2 because they share a type definition? i mean could they be written independently?
17:47:50 <Jedai> Saizan: You may be right that your definition of dynamic would work... I guess it's efficiency after all
17:48:42 <Cale> Saizan: Well, at some point, you're doing an unsafeCoerce anyway... so long as you have the appropriate information as to what type it's okay to coerce to, then you're good.
17:49:05 <dino-> I'm looking at the example in the very beginning of RWH: minima k xs = take k (sort xs)  In the text it says that "the list will only be sorted enough to find the k minimal elements" ..
17:49:28 <Jedai> vlan2: I don't see why they couldn't be written independently, why would you think so ?
17:49:46 <dino-> Is this saying that every element doesn't have to be visited to sort somehow?
17:49:51 <Cale> vlan2: well, each has to know at least a bit about what types of data they can send through the Chan, but you could wrap the function which writes to the given Chan, so as to restrict their ability to send messages over it.
17:50:10 <dmwit> vlan2: You could write a class, and make the type of the channel (Message a, Message b) => Either a b, or something like that.
17:50:28 <Jedai> dino-: If the sort is lazy enough (and every element still has to be visited, but it won't cost you as much as a complete sort)
17:50:42 <Cale> For instance, suppose that serverA is supposed to write messages of type A to the Chan, and serverB is supposed to write messages of type B.
17:51:41 <dmwit> dino-: (take k (sort xs)) runs in roughly k*log n time, n = length xs.  i.e. it's faster than doing a full sort.
17:51:46 <Cale> You could have a myChan :: Chan (Either A B), and then rather than passing that Chan off to the servers, you pass  (writeChan myChan . Left) to serverA and  (writeChan myChan . Right) to serverB
17:51:53 <dino-> What does full sort mean?
17:51:59 <dino-> I mean, how does this differ.
17:52:00 <Cale> and that ensures that they only have the ability to write appropriate messages into the channel.
17:52:00 <Jedai> dino-: For example, with quicksort (in a good case) it will cost O(n + k log n) I think
17:52:21 <Olathe> dino-: It doesn't have to finish sorting the array to give the results.
17:52:22 <dmwit> oh yeah, n + k*log n.
17:52:24 <Jedai> dino-: A full sort means you have to put all the elements in order
17:52:27 <Olathe> dino-: It can quit early.
17:52:38 <dino-> Ah, that did it: quit early
17:52:42 <Jedai> dino-: costing O(n log n)
17:53:10 <dino-> Still has to look at them all, but not fully "build the new list" or whatever takes place.
17:53:15 <dino-> in the "complete" sort ?
17:53:47 <vlan2> Cale: ok, i'll need a couple of minutes to think of it :)
17:53:51 <Jedai> dino-: With a lazy sort, (take k (sort xs)) won't evaluate (sort xs) completely, just enough to know the k first elements (which will cost less than a full sort)
17:55:13 <AlexSuraci> Is there an easy way to tell if a double is whole? (e.g. 1.0, 5.0, as opposed to 1.2)
17:55:22 <dmwit> :t properFraction
17:55:24 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
17:55:32 <jbapple> :t ceil
17:55:33 <lambdabot> Not in scope: `ceil'
17:55:33 <Cale> vlan2: This is also a decent way of controlling what threads have read access and what threads have write access to a Chan.
17:55:39 <AlexSuraci> trying some division/ceiling equality trickery and having trouble with types, thinking I'm making it too hard on myself :P
17:55:42 <jbapple> :t floor
17:55:43 <dmwit> :t ap (==) floor
17:55:44 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
17:55:44 <lambdabot> forall a. (RealFrac a, Integral a) => a -> Bool
17:55:51 <dino-> I see. Thank you
17:56:00 <Cale> vlan2: Just partially apply the functions which read and write the Chan in question, and pass the resulting functions to the threads, rather than the Chan itself.
17:56:08 <dmwit> Oh, yeah, ap (==) floor won't work.
17:56:17 <AlexSuraci> dmwit: thanks, that should help :)
17:56:36 <dmwit> :t fromIntegral
17:56:38 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:56:39 <Olathe> @pl \x -> x == fromIntegral (round x)
17:56:39 <lambdabot> ap (==) (fromIntegral . round)
17:56:52 <Jedai> :t (== 0) . snd . properFraction
17:56:53 <lambdabot> forall b. (RealFrac b) => b -> Bool
17:57:08 <dmwit> Yep, so at least a few solutions have been suggested. =)
17:57:14 <Olathe> > properFraction (0.5::Double)
17:57:16 <lambdabot>   (0,0.5)
17:57:19 <zloog> :t do
17:57:20 <lambdabot> Empty 'do' construct
17:57:29 <dmwit> zloog: do is syntax, not a function.
17:57:32 <zloog> Hrm, is there anywhere I can read up on what do actualy does?
17:57:38 <Olathe> > let do = 5 in do
17:57:40 <lambdabot>   mueval: Prelude.read: no parse
17:57:42 <mmorrow> Saizan: this made it crystal clear to me http://hpaste.org/10332
17:57:45 <dmwit> zloog: It introduces a block of code that evaluates in a monad.
17:57:47 <Jedai> zloog: It's just syntax sugar
17:57:55 <dmwit> zloog: Read any monad tutorial, and you'll find out right quick. =)
17:58:09 <dmwit> We can also just tell you the transformation here, if you're hip to the monad.
17:58:21 <zloog> ok, thats about what I figured, gonna go look into another monad tutorial. thanks
17:58:27 <dmwit> do { x <- m; y } ==> m >>= \x -> m
17:58:30 <dino-> Does the compiler choose different sort algorithms based on things like this?
17:58:33 <Saizan> mmorrow: 'it' being? :)
17:58:34 <dmwit> do { x; y } ==> x >> y
17:59:05 <dmwit> well...
17:59:17 <Jedai> dino-: No
17:59:47 <dmwit> do { x; y } ==> x >> do { y }, and similarly for the other case.  And there are some subtleties about pattern-matching to the left of an <-.
18:00:08 <mmorrow> Saizan: when/how/why you step "outside" of the type system, and when/why unsafeCoerce is necessary
18:00:09 <Jedai> dino-: That's just one of the benefits from working in a lazy language : sometimes a combination of function cost less than they would cost in a strict language.
18:01:03 <jbapple> I am trying to haddock a source file, but I keep getting: Warning: The documentation for the following packages are not installed. No links will be generated to these packages: Stream-0.2.6
18:01:12 <jbapple> Yet, I just installed the package
18:01:32 <Saizan> mmorrow: in those examples unsafeCoerce is simply a way to prove the false, though
18:01:44 <dmwit> jbapple: Did you haddock Stream?
18:01:45 <dino-> Jedai: I get that this is really more the point of that example in the early pages of RWH.
18:01:48 <Jedai> dino-: The real benefit from lazyness IMHO is better modularity, rather than better performance : in a strict language, you would have to rewrite half a quicksort to get the same results as (take k (quicksort xs)) gave us in our lazy language.
18:02:09 <mmorrow> Saizan: exactly. it's the only way to have that compile under haskell's type system
18:02:25 <jbapple> dmwit: I did  runhaskell Setup.lhs haddock before  sudo runhaskell Setup.lhs install
18:02:53 <Olathe> Jedai: I thought you could just do take k (sort xs) and get it slower.
18:03:04 <dmwit> jbapple: ...for Stream, or for the current thing you're building?
18:03:12 <Jedai> Olathe: I'm not sure what you just said...
18:03:17 <jbapple> dmwit: for Stream
18:03:23 <Saizan> mmorrow: i can sort of see the justification for fromExists, but not one for toForall
18:03:49 <Olathe> Jedai: Well, in a strict language, you could take a standard quicksort without modification and a standard take without modification and use take k (sort xs) and get the same result as Haskell.
18:03:50 <mmorrow> Saizan: they're dual :)
18:04:26 <ddarius> mmorrow: It's not sound so it's exactly the type of thing the type system is trying to prevent.
18:04:40 <jbapple> For the current thing I'm building, when I run cabal haddock -v3, I see that the documentation for QuickCheck is found in --read-interface=/usr/local/share/doc/QuickCheck-1.1.0.0/html
18:05:09 <jbapple> Yet, the Data.Stream interface is just sitting there in /usr/local/share/doc/Stream-0.2.6/html/
18:05:18 <dcoutts> jbapple: it gets the info from ghc-pkg describe QuickCheck
18:05:19 <Jedai> Olathe: Right but it wouldn't have the same performance so in a real program if this performance is important you would have to rewrite another function "quicktake" which would duplicate half the implementation of your quicksort
18:05:29 <mmorrow> ddarius: i never said it was sound. in fact, it's used to give up the type system's guarantees and make one's own
18:05:37 <dcoutts> jbapple: so if ghc-pkg is telling lies then there's not a lot Cabal can do
18:05:43 <mmorrow> eg Data.Dynamic
18:05:51 <Jedai> Olathe: whereas in Haskell you can just use (take k (sort xs)) and get excellent performance
18:06:24 <dino-> Thank you for explaining.
18:06:24 <Saizan> mmorrow: Dynamic at least compares types somehow
18:06:30 <jbapple> dcoutts: thanks, I'll look there
18:06:55 <dcoutts> jbapple: how did you install that package and its docs? if you think Cabal messed it up on installation then we could do with a bug report and details of how to reproduce it.
18:07:02 <mmorrow> Saizan: exactly. it's becomes the implementation's responsibility to preserve safety
18:07:03 <Saizan> mmorrow: and you could implement it without unsafeCoerce as JHC
18:07:13 <Jedai> Olathe: On this particular example it may not be striking, but you encounter the same kind of win in modularity in plenty of cases
18:07:38 <mmorrow> all GADTs are is the compiler doing the unsafeCoerce for you
18:07:47 <jbapple> dcoutts: I might have overwritten an old version foolishly. I'll do a clean make and see if it fixes it up
18:08:02 <jbapple> "ï»¿mmorrow: all GADTs are is the compiler doing the unsafeCoerce for you" belongs in HWN
18:08:07 <Jedai> Olathe: And sometimes the "performance difference" may be huge or even infinite (with infinite lazy data structures)
18:08:17 <mmorrow> jbapple: heh
18:08:45 <Saizan> mmorrow: with the difference that GADTs carry proofs of type equalities around
18:08:50 <Heffalump> GADTs don't involve any more "unsafeCoerce"-like things than normal types.
18:09:48 <jbapple> Heffalump: unsafeCoerce is just your brain doing GADTs for you
18:09:48 <ddarius> Heffalump: Exactly
18:10:33 <Heffalump> GADTs and normal types are purely static
18:10:40 <Heffalump> Data.Typeable/Dynamic is RTTI.
18:11:48 <uep> Is there a haskell tutorial that is considered the best one to start with?  Six months back I started through a tutorial, but eventually got stuck on some end-of-chapter problems.  I'd like to take a shot at it again.
18:12:05 <dmwit> ?where learn
18:12:07 <lambdabot> I know nothing about learn.
18:12:11 <dmwit> ?where YAHT
18:12:12 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
18:12:12 <mmorrow> Heffalump: all i'm saying is, it isn't typeable in haskell's base hindley milner type system. anything as such must use "unsafeCoerce", where this is defined as "doing something untypeable in haskell's base type system"
18:12:14 <dmwit> ?where gentle
18:12:15 <lambdabot> http://www.haskell.org/tutorial/
18:12:20 <dmwit> ?where learning
18:12:22 <lambdabot> I know nothing about learning.
18:12:24 <dmwit> huh
18:12:25 <mmorrow> it only sounds circular because we happen to be using haskell
18:12:27 <uep> Thanks.
18:12:30 <Heffalump> there's no such thing as a base type system, though
18:12:32 <ddarius> GADTs are not doing unsafeCoerce any more or less than normal algebraic data types or any other type for that matter.  It's all being "unsafeCoerced" to bits and back.
18:12:38 <dmwit> uep: Anyway, YAHT and the Gentle Intro are nice; RWH is, too.
18:12:40 <dmwit> ?where RWH
18:12:41 <lambdabot> is http://www.realworldhaskell.org/blog/
18:12:42 <Heffalump> you are giving HM types a special status they simply don't have
18:13:13 <mmorrow> i think i'm giving them a lesser status. i'm saying they aren't sufficient
18:13:15 <Heffalump> it's all about type erasure
18:13:25 <Heffalump> no static type system is sufficient
18:13:29 <mmorrow> yes!
18:13:53 <uep> Was yaht once in pdf form?  I think that might have been the one I tried.
18:14:26 <mmorrow> Heffalump: (as in "exactly!")
18:14:30 <Heffalump> but GADTs don't involve unsafeCoerce any more than 5+5 does
18:14:33 <uep> Nevermind.  Probably it, there's a link to the pdf on the page.
18:14:49 <Jedai> uep: Don't forget you can ask us questions anytime ! ^^
18:15:30 <Olathe> Except when we're closed.
18:15:56 <mmorrow> Heffalump: but from the point of view of a type system which can't type what something is doing, that something is using "unsafeCoerce" from this lesser type system's perspective
18:16:34 <jbapple> How do I remove an installed package, in order to do a clean install?
18:17:08 <Heffalump> if you like
18:17:12 <jbapple> ghc-pkg unregister left copies in my local register ï»¿/home/apple/.ghc/i386-linux-6.8.3/package.conf:
18:17:24 <Heffalump> but the lesser type system doesn't actually get used
18:17:28 <Saizan> mmorrow: my point was that GADTs at least extend h98 in a sound way, toForall/fromExists simply don't..
18:17:32 <mmorrow> perhaps i'm just inventing my own extremely nonstandard interpretating
18:17:33 <Heffalump> whereas there really is runtime typing and static typing.
18:18:00 <lispy> and GADT type checking is 100% decidable, riht?
18:18:03 <mmorrow> Heffalump: sure. only so much as the implementor of those systems can prove it.
18:18:09 <Jedai> mmorrow: Right, that's how Coq does it when it must extract too typed programs in lesser languages (at least it uses Obj.magic in OCaml, I didn't check the Haskell code)
18:18:40 <lispy> Jedai: I haven't tried, but I was told it uses unsafeCoerce in haskell sometimes
18:19:04 <thoughtpolice> @tell dons i'm trying some experiments with rl's vector package using uvector as a control but it won't build with ghc's HEAD - many newtypes in Data.Array.Vector.UArr have strict constructor fields (i.e. a !) but ghc now rejects them as an err
18:19:05 <lambdabot> Consider it noted.
18:19:27 <Jedai> mmorrow: Though Haskell type system is not just H-M so your interpretation is a bit shaky
18:19:27 <mmorrow> Cayenne compiles to haskell, and it wraps every expression in unsafeCoerce, because it's simply using the language's facilities (eg excellent compiler) as a vehicle to express it's own language
18:19:51 <thoughtpolice> mmorrow: how... dangerous :)
18:19:52 <mmorrow> yeah, that's where all the drama is coming in ;)
18:20:04 <mmorrow> (@Jedai)
18:20:07 <dcoutts> how can it be sure that the representations that ghc uses are the same?
18:20:27 <Heffalump> mmorrow: do you really mean every expression?
18:20:46 <mmorrow> Heffalump: i'll show you some output. gimme a sec
18:20:58 <mmorrow> i was like whoa!
18:21:03 <lispy> hpaste!
18:21:43 * mmorrow hope he remember correctly from a week ago, now that he's built it up so much
18:22:41 * lispy is turning blue from holding his breath
18:27:45 <mmorrow> hehe, http://hpaste.org/10332#a1
18:27:57 * lispy has passed out
18:27:58 <mmorrow> i /do/ remember correctly
18:28:50 <dbueno> ddarius: Data.IntMap from the tarball of containers contains IntMap.alter -- the docs must be out of date
18:29:09 <lispy> mmorrow: cast is cast :: a -> b?
18:29:29 <Heffalump> how can that top-level thing have a polymorphic type?
18:29:37 <lispy> I was wondering about that too
18:29:38 <Heffalump> does it guarantee only to call it at the right one?
18:30:01 * Heffalump pokes augustss to see if he's still around :-)
18:30:13 <mmorrow> lispy: it's literally defined as:   cast = unsafeCoerce#
18:30:35 <mmorrow> Heffalump: beats me
18:30:37 <Saizan> in GHC they also had to introduce Any since forall a. a was getting mangled by optimizations, no?
18:31:01 * Heffalump goes to bed
18:31:07 <lispy> Heffalump: good night
18:31:12 <mmorrow> night
18:32:10 <mmorrow> this is a better example: http://hpaste.org/10332#a2
18:33:36 <lispy> what is Cayenne?
18:33:39 <uep> ha, I even found my old code from when I was attempting the tutorial.  Unfortunately, I don't remember a whole lot about the syntax.
18:33:46 <dons> Saizan: i didn't know that.
18:33:46 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:33:48 <dons> where'd you hear that?
18:34:33 <Saizan> dons: a comment on the implementation of Dynamic in the trac, iirc
18:36:19 <mmorrow> i finally found the implem of "cast" http://hpaste.org/10332#a3
18:36:35 <dolio> Cayenne is a dependently typed language created by Lennart Augustsson.
18:37:16 <mmorrow> dolio: i'm packageing it for hackage. got delayed this week on account of work/hell. gonna finish tomorrow.
18:37:46 <dolio> Oh, nice. Should be fun to play around with.
18:37:58 <mmorrow> here's the haddock docs for cayenne (hierachified), plus a module dep graph http://code.haskell.org/~morrow/cayenne/
18:37:59 <lambdabot> Title: Index of /~morrow/cayenne
18:39:12 <dolio> Do any of those have actual documentation? :)
18:39:27 <uep> Could someone help me with an exercise from yaht?
18:39:34 <dolio> Not that I'd necessarily expect any, since it's a language implementation, not a library.
18:39:48 <dolio> (And it's probably old.)
18:39:58 <lispy> It's too bad, this isn't valid in a pattern match, foo ("blah":rest)
18:40:12 <lispy> er, well, it's too bad it doesn't mean what Iw ant it to mean :)
18:40:26 <mmorrow> dolio: not really
18:40:29 <dolio> View patterns.
18:40:31 <lispy> foo ("blah":rest) = foo ('b':'l':'a':'h':_)
18:40:42 <mmorrow> dolio: but the code is quite readable
18:40:43 <dmwit> foo xs | take 4 xs == "blah"
18:40:43 <dolio> foo (prefix "blah" => rest) = ...
18:40:52 <hackage> Uploaded to hackage: data-accessor-template 0.1.4
18:40:52 <hackage> Uploaded to hackage: data-accessor 0.1.4
18:41:22 <dolio> If the implicit maybe syntax is in there. I haven't tried them.
18:41:41 <uep> :-/
18:42:02 <dolio> uep: State your question. Someone will probably help.
18:42:27 <dmwit> Nobody wants to volunteer to help before they know the question. =)
18:42:57 <uep> I'm still very early in yaht, so I'm not sure I could even phrase it well.  Like I said... an exercise from yaht.  Early on even.  Very basic, I just don't understand the mechanics yet.
18:43:16 <dolio> We might be stumped by yaht, and embarrassed.
18:43:24 <uep> The exercise is the one at the very bottom of this page. http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics
18:43:40 <uep> My code is here: http://pastebin.com/d35c1c9a1
18:43:50 <uep> Now, I'm not just looking for an answer.  I'm looking to understand.
18:44:05 <dmwit> naturally
18:44:16 <uep> I think my two main problems are understanding the semantics of 'do' and the type system.
18:44:54 <uep> Bear with me, because it has been a while since I really dove into it, but at the time I couldn't figure it out from online resources.
18:44:55 <lispy> ?hoogle isPrefixOf
18:44:55 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
18:44:55 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:44:55 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
18:45:30 <dmwit> uep: You've got all kinds of correct code there! =)
18:45:52 <dmwit> uep: The only thing you should think about is this: my_sum is a pure function, and so shouldn't stand alone in a do block.
18:45:55 <uep> (I primarily did the first bit of yaht all in one night!)
18:46:02 <vlan2> Cale: got your idea, thanks :) it's quite a nice way to solve my problem :) here is the code http://hpaste.org/10333
18:46:21 <uep> Okay, my understanding is that do blocks are like... sequential code with side effects?  Order matters?
18:46:28 <dmwit> uep: Also: function calls don't require parentheses, and in fact parens can change the meaning!
18:46:34 <dmwit> foo() /= foo
18:46:52 <dmwit> "foo()" parses as "call the function foo with the argument ()".
18:47:03 <Cale> vlan2: It's odd that you chose to pass the functions inside another Chan though... is there any particular reason for that?
18:47:29 <dmwit> uep: That's partly right.  But it's also a requirement that each line of a do block have a monadic type -- i.e. must be able to do some kind of side effect.
18:47:38 <dmwit> (This is a first-order approximation.)
18:48:09 <dmwit> uep: Since the line "my_sum num" doesn't actually do any side-effects -- only calculate the sum -- it isn't allowed in a do block.
18:48:22 <dmwit> But if you printed the sum... now that would be a different story. =)
18:48:26 <Cale> vlan2: ah, perhaps I see... you want the client to be able to inform the servers which channel to write to, when it isn't in charge of creating them...
18:48:29 <dolio> Essentially, the problem with 'do my_sum num ; ...' is that you're not saying what to do with "my_sum num".
18:48:32 <vlan2> Cale: now i'm wondering is it something special about Either or it is just a type? i mean can i implement a type that has arbitrary number of cases?
18:48:47 <Cale> Yeah... Either is not special at all.
18:48:50 <Cale> It's defined as:
18:48:50 <dolio> It's like having a C function "void foo() { 5; }"
18:48:57 <Cale> data Either a b = Left a | Right b
18:48:57 <dolio> Although that's probaly valid C. :)
18:48:58 <vlan2> Cale: yep, servers receive a client's "address"
18:49:30 <uep> Thanks, I'm playing with the code based on your comments.
18:50:24 <dmwit> uep: Also, be careful when playing with ghci; it tends to confuse the monadic vs. non-monadic code issue a *lot* due to some implicit... "cast"s.
18:50:40 <dmwit> uep: You might like:
18:50:48 <dmwit> ?go the io monad for people who just don't care
18:50:52 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
18:50:52 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
18:50:56 <Cale> vlan2: The usual approach I would take is for the main to create the channels of communication beforehand, and pass the appropriate ends of the Chans involved off to the various things it forks, but I can see where a system of this type might be more flexible.
18:51:15 <uep> Okay, I'll take a look.
18:51:56 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO -- is my little introduction to doing I/O in Haskell. It doesn't get into details, but should give you the right way of thinking about things at least.
18:51:58 <lambdabot> Title: Introduction to IO - HaskellWiki
18:52:06 <uep> I may have read this a ways back, but I probably just didn't understand at that point.  I must have read like 10 monad articles before I had even tried the tutorial. (From reddit naturally).
18:52:41 <lispy> anyone know what isPrefixOf was added to Data.List?  (I care in terms of GHC version numbers)
18:52:51 <lispy> it exists in 6.6 right?
18:52:53 <lispy> What about 6.4?
18:53:01 <Cale> lispy: It's in Haskell 98, iirc.
18:53:08 <Cale> Maybe earlier?
18:53:20 <dolio> Prefix is old. Infix is the one you have to worry about.
18:53:23 <ddarius> 616 pages dedicated to the logarithmic integral...
18:53:27 <lispy> Cale: oh, okay, for some reason I thought it was added since I started using Haskell
18:53:34 <lispy> dolio: thanks
18:53:48 <heatsink> :t isInfixOf
18:53:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:53:49 <Cale> ddarius: I can imagine that :)
18:53:58 <vlan2> Cale: thanks a lot! :) i guess i can do some interesting stuff now. i'm playing with actors model, so i need dynamic graph where actors can change their connectivity and can be created dynamically too
18:54:57 <Cale> vlan2: You might even come up with a nice way of abstracting things further, once you see patterns popping up in the way that you're using the channels. I'm not experienced enough with it to really comment about that though :)
18:57:28 <vlan2> Cale: i'll certainly put a link here if i come up with some useful or interesting code implementing the actors model
19:00:50 <goltrpoat>  vlan:  is that cardelli's stuff
19:03:36 <goltrpoat> vlan:  if it's not, you may, uh, want to read that :)
19:03:42 <goltrpoat> the obliq papers in particular.
19:05:27 <vlan2> goltrpoat: no, i haven't heard of his papers. could you give some more info about him or his papers plz?
19:05:52 <dancor> am i crazy, or is hCsound not much better than just e.g. HSH.run "csound .."
19:05:55 <ddarius> @google Luca Cardelli
19:05:58 <lambdabot> http://lucacardelli.name/
19:05:58 <lambdabot> Title: Luca Cardelli
19:07:18 * lispy is afraid to tell dancor that he/she is crazy... ;)
19:07:26 <dons> Cale: Cetin Sert posting unicode src on haskell-cafe@ :) unicode is taking over
19:07:33 <dons>     r â† random m :: IO Word8
19:07:37 <dons> variate :: RGB â†’ RGB â†’ RGB
19:07:47 <dons> just needs to include whatever flags we actually use to compile this
19:08:10 <lispy> dons: yeah, I thought that was a cool post, but the compiling bit is maybe tricky
19:08:10 <vlan2> ddarius, goltrpoat: thanks :)
19:08:13 <augustss> @seen Heffalump
19:08:14 <lambdabot> Heffalump is in #haskell, #ghc and #darcs. I last heard Heffalump speak 37m 12s ago.
19:08:28 <lispy> augustss: he seemed to sign off for sleep a bit ago
19:08:33 <dancor> lispy: ok i'll keep poking around in the library in my quest for sanity
19:08:50 <lispy> dancor: I'm just teasing you though.  I haven't tried to use it
19:09:06 <dancor> this scares me in the examples/ :  runCsound "-W -otest3.wav test1.csd"
19:09:31 <lispy> heh, that does seem just like invoking it
19:09:50 <dancor> wheelreinvent.hs
19:10:46 * dolio still thinks of "Look out, Luke; it's a dancor!" whenever he sees dancor's name.
19:11:00 <shteou> I should look at Colin Runciman’s lazy wheel sieve so I can publish my own paper called “Reinventing the lazy wheel sieve in Haskell” :(
19:11:13 <dancor> darthcor
19:12:56 <lispy> dolio: heh, yeah, i've read it as rancor a couple times already :)
19:13:10 <dolio> You're the one who put it in my head.
19:13:32 <lispy> ah
19:13:43 <uep> Cale or dmwit: Is it possible to do something like what I'm attempting on line 28? http://pastebin.com/d352515fa
19:13:44 <dolio> It's all your fault!
19:13:59 * lispy : Corrupting #haskell since 2003
19:14:08 <dmwit> uep: Yes!
19:14:10 <dmwit> :t mapM_
19:14:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
19:14:35 <dmwit> uep: Also, you need to learn about the difference between function composition and function application.
19:14:59 <dmwit> uep: Basically, ponder this: how is f (g x) different from (f g) x?
19:15:03 <uep> dmwit: I definitely don't fully understand the syntax yet, but I'm trying.
19:15:06 <lispy> the latter requiring function resume and function coverletter
19:15:39 <dmwit> We have the two operators (.) and ($) to de-parenthesize those two expressions.
19:15:45 <dmwit> lispy: =)
19:16:12 <dmwit> uep: For now, it might help to write out explicit lambdas for your higher-order functions.
19:16:56 <dmwit> uep: i.e. instead of trying to use a pointfree version like (putStrLn (show (factorial))) -- which doesn't do what you want anyway -- use the pointful version (\x -> putStrLn (show (factorial x))).
19:17:22 <dmwit> As you get more comfortable with function composition, you'll want to move to the (\x -> putStrLn . show . factorial $ x) syntax.
19:18:08 <dmwit> Then, after a bit, you can start to see how the point-free version (putStrLn . show . factorial) can be nice.
19:18:12 <uep> dmwit: It had slipped my mind how to express lambdas.  I'm just coming back to this after a long stretch.  It's coming back fast, but I don't remember much outside of the concepts in that program thus far!
19:18:21 <dmwit> Okay!
19:18:28 <dmwit> uep: You could also just name the function.
19:18:31 <dmwit> i.e.
19:18:44 <dmwit> printFactorial n = putStrLn (show (factorial n))
19:19:05 <dmwit> uep: Oh, and on a side note: print x = putStrLn (show x).
19:19:28 <dancor> aka  print = putStrLn . show
19:19:35 <lispy> ?src print
19:19:35 <lambdabot> print x = putStrLn (show x)
19:20:13 <uep> I'll be honest, I don't remember what exactly the point operator does.
19:20:21 <uep> Function composition?
19:20:32 <heatsink> It's supposed to look like o
19:20:47 <heatsink> as in (f o g) x
19:20:53 <dmwit> uep: Exactly.
19:20:56 <dmwit> ?src (.)
19:20:56 <lambdabot> (f . g) x = f (g x)
19:22:58 <ivanm> does anyone know of a link that states what I can and can't do with BSD3 code? (I want to "steal" and modify some code from a library on hackage)
19:23:28 <dmwit> How about the BSD3 license itself?
19:23:30 <dmwit> It's pretty short.
19:23:41 <dancor> it's also pretty close to public domain
19:24:03 <dmwit> Three whole sentences. =P
19:24:32 <ivanm> dmwit: yeah, just not quite sure what I'm meant to do... if I copy and modify a module, where and how do I reference the original author?
19:25:06 <dancor> ivanm: i don't think you have to
19:25:21 <dmwit> Right, there's no mention of authorship in the license.
19:25:29 <dmwit> You just can't use the original author to endorse your fork.
19:25:34 <dancor> the sudo license variant actually says "3. The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission from the author."  :)
19:25:54 <dancor> oh maybe by sudo variant i mean bsd3 .. :)
19:25:54 <ivanm> well Iveto leave the original license in there, don't I?
19:26:09 <dmwit> yes
19:26:29 <dmwit> "Redistributions of source code must retain the above copyright notice, this list of conditions, and the following disclaimer."
19:26:35 <ivanm> so what, just have a seperate file calles "license-of-foo.txt" with that license in there?
19:26:46 <dmwit> yes
19:26:49 <ivanm> or have it at the header of the source file (something that the code doesn't have)
19:26:51 <ivanm> ?
19:26:55 <ivanm> *nod*
19:27:01 <dmwit> It's really that simple. =)
19:27:19 <ivanm> yeah, that's what I was after... because nothing anywhere says what I have to do :s
19:27:29 <ivanm> as in having a file, etc.
19:27:49 <dmwit> I think you can put the license basically anywhere.  In its own file, in a comment buried in the source somewhere, anything.
19:28:11 <ivanm> *nod*
19:28:23 <dmwit> You could even write it on a plane, as long as that plane was your only method of redistribution. =D
19:29:00 <dmwit> Any good image manipulation libraries for Haskell?
19:29:17 <ivanm> what kind of manipulation?
19:29:44 <dmwit> Let's say I wanted to drop every other row of an image.
19:30:12 <ivanm> dmwit: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/#cat:Graphics is the list...
19:30:19 <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/32qqg5
19:31:03 <dmwit> So... no? =P
19:31:15 <dmwit> Oh, there's bindings to ImageMagick, maybe those will work.
19:31:39 <ivanm> is that imlib? if so, I was about to suggest it
19:31:47 <ivanm> though I seem to recall seeing a png library at one stage...
19:31:51 <dmwit> Have you used imlib?
19:32:06 <dancor> imagemagick++.  also if the transformation is that simple it's really just a question of being able to read and write that format
19:32:50 <ivanm> me? no
19:32:57 <dmwit> dancor: Yeah, but jpg is a nasty format.
19:33:15 <dancor> looks like not imlib but: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsmagick
19:33:18 <lambdabot> Title: HackageDB: hsmagick-0.2, http://tinyurl.com/5cpj9z
19:33:24 <dmwit> imlib is... underdocumented
19:33:34 <dmwit> dancor: Yeah, that was the ImageMagick binding I was referring to.
19:33:40 <ivanm> ahhh
19:33:49 <ivanm> looking for "image" didn't return that ;-)
19:34:00 <dmwit> hsmagick is also undocumented =/
19:34:13 <dancor> i assume sdl-image can do jpg too
19:34:24 <ivanm> yeah, a lot of libraries are :(
19:34:40 <tautologico> is there an easy way to post syntax-highlighted scala code to a blog? preferably some javascript component that highlights on the fly, instead of a pre-processor like hscolour
19:34:43 <dmwit> dancor: I don't think SDL does this kind of transform.  Just affine stuff, texturing, display, etc.
19:34:59 <ivanm> tautologico: surely #scala would be a better place to ask?
19:35:07 <tautologico> sorry
19:35:10 <tautologico> I meant haskell code
19:35:20 <tautologico> (note the mention to hscolour at the end)
19:35:22 <dancor> dmwit: but couldn't you deal with   http://www.pygame.org/ctypes/sdl-api/SDL.SDL_Surface-class.html#pixels
19:35:27 <lambdabot> Title: SDL.SDL_Surface, http://tinyurl.com/3nvna7
19:35:31 <dancor> and do the manip yourself?
19:35:45 <lispy> tautologico: if the blog engine is in php you might look at geshi highlight. That seems to be what the haskellwiki uses
19:35:49 <ivanm> tautologico: ahhh... depends on the blog engine AFAIK
19:36:12 <dmwit> dancor: That's not the interface that Graphics.UI.SDL.Image offers. =)
19:36:16 <tautologico> ivanm: say, wordpress... they have a component for souce code, but it's very limited in the choice of languages
19:36:40 <dmwit> Or... does it?
19:36:42 * dmwit looks again
19:36:53 <ivanm> tautologico: wordpress.com? don't think you can
19:37:04 <dancor> dmwit: we'll never know due to underdocumentation ;)
19:37:33 <dancor> s/;)/;___;
19:37:46 <dmwit> Sad, but true.
19:38:22 <ivanm> when using the chart library, I didn't know half of the functions I could use because they didn't have type annotations, and thus haddock ignored them :s
19:38:23 <dmwit> surfaceGetPixels :: Surface -> IO Pixels
19:38:30 <dmwit> But no interface for Pixels. =/
19:38:41 <tautologico> I've seen people doing this in scala (so that's why I mixed up earlier)... someone has uploaded (to a known server) a style file for using scala with some javascript syntax highlighter
19:38:52 <tautologico> so even people who use blogspot or wordpress.com can call this code
19:39:27 <dmwit> http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.2/doc/html/Graphics-UI-SDL-Primitives.html # beautiful
19:39:29 <lambdabot> Title: Graphics.UI.SDL.Primitives, http://tinyurl.com/6eb5ys
19:39:34 <ivanm> tautologico: no idea, sorry :s
19:40:11 <davidL> dmwit: can't you use chopImage from hsmagick?
19:40:27 <tautologico> well, thanks anyway :)
19:40:50 <dmwit> davidL: Probably.  I haven't been able to read all the documentation for all the choices yet.
19:40:54 <dmwit> So thanks for the pointer. =)
19:41:13 * dmwit only just found the docs for hsmagick; they weren't linked from hackage for some reason
19:41:46 <ivanm> dmwit: maybe it couldn't be built on hackage?
19:41:56 <ivanm> because hackage doesn't have imagemagick installed?
19:42:06 <dmwit> probably
19:42:18 <lispy> hackage needs a theme song
19:42:30 <dmwit> davidL: ...even having found the docs, I *still* don't know if that will help.
19:42:36 <dmwit> =/
19:42:41 <lispy> "Yeah, we built this hackage on lambda and ..."
19:43:27 <bitrot> "...rock and roll..."
19:43:42 * bitrot ducks
19:43:53 <davidL> dmwit: "Chop() removes a region of an image and collapses the image to occupy the removed portion."
19:44:16 <davidL> dmwit: http://www.graphicsmagick.org/www/api/transform.html#chopimage
19:44:20 <lambdabot> Title: transform - Crop, flip, flop, roll, coalesce, etc.
19:44:33 <dmwit> davidL: Thanks.
19:44:46 <davidL> :)
19:50:21 <dons> dcoutts: did you see gameclock?
19:50:39 <dons> it's a lovely gtk2hs app. i think you should mention it on the gtk blog.
19:53:19 <lispy> quick, words that rhym with stack and are related to haskell
19:53:26 <lispy> oh, type hack
19:55:50 <uep> What's the difference between String and [Char]?
19:56:05 <dolio> There is no difference. String is an alias for [Char].
19:56:19 <dmwit> ?src String
19:56:20 <lambdabot> type String = [Char]
19:56:25 <bitrot> lispy: you're not writing a haskell (song|poem), are you?
19:56:45 <dolio> Which actually saves you no typing, interestingly enough.
19:56:54 <dolio> A couple actual keypresses, maybe.
19:56:59 <uep> Okay, thanks.  The tutorial says one thing, and the version of ghci I'm using says the other.
19:57:05 <dolio> Wait, no.
19:57:11 <lispy> we build this hackage
19:57:14 <uep> Well, defaults to the other.
19:57:20 <lispy> on lambda and types
19:57:37 <lispy> I'm looking fo a rhym to type class actually now
19:58:14 <bitrot>  mumble mumble GAS?
19:58:48 <dolio> Is this to the tune of We Built This City?
19:58:53 <lispy> dolio: yeah
19:58:57 <dolio> Oh man.
19:58:57 <lispy> I can show you what I have...
19:59:50 <lispy> http://hpaste.org/10335
20:00:49 * bitrot is either scared or enthralled..
20:01:42 <lispy> Obviously not finished
20:01:46 <lispy> Suggestions welcome
20:01:53 <lispy> The hardest part is finding words that rhym
20:02:01 <lispy> ryhm?  (I can't spell...)
20:02:04 <sereven> dcoutts: wow, that was easy. %cabal update; %cabal install gameclock; %gameclock :-) and dons, yes it is pretty sweet
20:02:26 <bitrot> lispy: something about "first pass"?
20:02:48 <sereven> first class?
20:03:01 <sereven> oh class class isn't so good
20:03:12 <dmwit> ivanm, dancor, davidL: In case you care, I ended up just using Gtk2Hs as a silent endorsement of well-documented libraries.
20:04:59 <lispy> Say you don't know me, or the parameters I pass
20:04:59 <lispy> Say you don't care who instances that type class
20:05:15 <davidL> dmwit: interesting, which part of the API?
20:05:31 <dmwit> Graphics.UI.Gtk.Gdk.Pixbuf
20:05:35 <dolio> My brain just exploded.
20:06:05 <davidL> ah, nice
20:22:01 <dmwit> Weird.
20:22:40 <dmwit> http://hpaste.org/10336
20:27:09 <ivanm> dmwit: heh
20:31:55 <lispy> http://hpaste.org/10335#a1
20:40:04 <lispy> and sent to -cafe :) http://www.haskell.org/pipermail/haskell-cafe/2008-September/047406.html
20:40:16 <lambdabot> Title: [Haskell-cafe] Hackage needs a theme song!, http://tinyurl.com/442p5p
20:40:53 <hackage> Uploaded to hackage: twidge 0.99.0
20:40:57 <ivanm> lispy: what tune is it meant to be sung to? We built this city?
20:41:03 <dmwit> yeah
20:42:24 <roconnor> When Credit-Suisse advertises a job in New York or London, how serious do you think they are about location?
20:42:55 <ivanm> roconnor: whichever one you want to be at, they'll assign you to the other :p
20:43:08 <ivanm> I'm guessing thanks to the powers of the internet, it wouldn't really matter
20:43:57 <roconnor> maybe I should apply anyways, but indicate that I won't move out of Canada
20:44:08 <lispy> roconnor: can't hurt
20:44:43 <lispy> roconnor: er, well I'd personally be willing to hera what they have to say about location before I make any claims about not moving
20:44:46 <lispy> roconnor: YMMV
20:44:46 <roconnor> I guess I should update my resume this weekend :)
20:44:58 <ivanm> roconnor: maybe if they offer you enough coin to move...? ;-)
20:45:44 <roconnor> hmm
20:46:00 <roconnor> well, I suppose there would probably exist an amount that would make me move
20:46:41 <ivanm> one million dollars! *puts pinky to corner of mouth*
20:47:25 <roconnor> :D
20:47:34 <roconnor> it's true
20:47:39 <roconnor> I'd move to London for that
20:47:52 <roconnor> still not sure about New York
20:47:58 <roconnor> depends on who wins their election
20:48:15 <mmorrow> roconnor: i've never lived in london, but the nyc is the nice. it's a different world.
20:48:17 <roconnor> Not that the UK is much better
20:48:46 <thoughtpolice> mmorrow: i want to visit nyc sometime - friends tell me it's awesome
20:49:09 <mmorrow> it's very awesome, it's own little world
20:49:14 <mmorrow> perhaps a spaceship
20:49:18 <mmorrow> heh
20:49:22 <ivanm> roconnor: lol
20:49:25 <roconnor> Did obama say he'd close gitmo?
20:49:29 <thoughtpolice> mmorrow: houston is pretty cool but i actually haven't left campus in the past 3 weeks
20:49:40 <thoughtpolice> no destination would be the culprit
20:49:42 * roconnor feels he is slowly drifting off topic
20:49:52 <thoughtpolice> although i am severely running short on deodorant & co. :[
20:49:54 <mmorrow> thoughtpolice: um. so how is the hurricane treating you?
20:49:56 <ivanm> there's a topic?
20:49:57 <bitrot> thoughtpolice: you actually like houston, tx?
20:49:58 <ivanm> @quote topic
20:49:58 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
20:50:06 <ivanm> nope, that's not what I was after...
20:50:07 <ivanm> @quote topic
20:50:07 <lambdabot> shepheb says: #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
20:50:12 <ivanm> ahhh, there we are
20:50:21 <thoughtpolice> mmorrow: it won't hit hard until later tonight
20:50:21 <bitrot> thoughtpolice: my brain is about to explode hearing that...
20:50:34 <thoughtpolice> the weather is bad right now but it'll get worse i'm sure
20:50:51 <bitrot> thoughtpolice: your city is sinking...just remember that
20:50:51 <mmorrow> thoughtpolice: ah. isn't it suppose to be 75mph+ min?
20:51:22 <mmorrow> what's category 2, 100mph?
20:51:34 <thoughtpolice> bitrot: understand that I come from a town of which the population is less than the students admitted to this university yearly and I moved directly here only ~3 weeks ago
20:52:00 <thoughtpolice> mmorrow: it's supposed to hit galveston with like 120mph winds
20:52:09 <thoughtpolice> by the time it gets here they'll probably be around 80mph or so
20:52:16 <mmorrow> snappp.
20:52:25 <bitrot> thoughtpolice: ok, you win...me too..but you'll learn :D (and move out of TX or to Austin)
20:52:37 <mmorrow> i'm in austin currently
20:52:47 <thoughtpolice> my sister lived close to austin while she was at college (georgetown)
20:52:55 <thoughtpolice> she now lives in portland
20:53:03 <thoughtpolice> since about 3 weeks ago :p
20:53:05 <ivanm> btw, is anyone here studying at edinburgh?
20:53:14 <bitrot> mmorrow: tomorrow is free bratwurst @ draughthouse pub on medical pkwy!
20:53:24 <mmorrow> ooh. austin weather ... portland weather. hmm...
20:53:50 <davidL> how is portland weather, I'm moving there in a week? (rainy, I hear)
20:53:52 <thoughtpolice> the only bigger town i've been in than houston was LA I think?
20:53:58 <mmorrow> bitrot: oh snap. the world is a small place :)
20:54:01 <thoughtpolice> and that was like 8 years ago when i was young
20:55:00 <thoughtpolice> mmorrow, bitrot: hehe, there's more people around this area than I thought :]
20:55:08 <bitrot> mmorrow: you know of the AustinFP group?
20:55:21 <mmorrow> bitrot: no, but i wanna be. you?
20:55:55 <mmorrow> (err, i wanna ...)
20:56:17 <bitrot> mmorrow: I attended the last meeting...a nice presentation on Clojure...check the haskell wiki for google group info
20:56:39 <mmorrow> bitrot: sweet
20:56:45 * mmorrow checks now
20:58:03 <bitrot> it's a handful of UT students and some industry folks
20:58:37 <bitrot> http://groups.google.com/group/austin-fp
20:58:41 <lambdabot> Title: Austin Functional Programmers | Google Groups
20:59:23 <thoughtpolice> there seem to be no FP groups here :[
20:59:36 <thoughtpolice> although maybe a chance to call out to people and start one
20:59:37 <mmorrow> bitrot: nice, just found the page.
21:00:06 <mmorrow> bitrot: ah, just saw your link
21:01:58 <bitrot> thoughtpolice: are you @ UH or Rice?  I seem to recall Dr. Scheme coming from a Rice group...
21:02:16 <bitrot> thoughtpolice: so you should be able to find a few...
21:02:40 <mmorrow> bitrot: cool. i'm definitely gonna head to the next meeting if i'm in town for sure.
21:03:44 <thoughtpolice> bitrot: UH
21:05:05 <bitrot> thoughtpolice: you're the one who asked on haskell-cafe, then...@ Clearlake campus?
21:06:03 <thoughtpolice> http://www.haskell.org/pipermail/haskell-cafe/2008-August/046194.html
21:06:06 <lambdabot> Title: [Haskell-cafe] Houston-area FPers?, http://tinyurl.com/4yz3dq
21:07:05 <thoughtpolice> i'm on the main campus
21:07:26 <bitrot> thoughtpolice: good for you...clearlake is "meh."
21:08:13 <thoughtpolice> from what I can see there are some people in this area but I'm surprised there's not a more formal group
21:08:22 <thoughtpolice> like i said it might be worth making the call and trying to form one
21:08:43 <bitrot> I bet you'll notice some interest.
21:09:44 <thoughtpolice> yeah it's just knowing where to shout at i'm thinking
21:09:48 <bitrot> esp. if you make noise @ Rice. (don't know much of UH)
21:10:32 <thoughtpolice> some of the profs. in the CS department seem to be into it
21:10:34 <bitrot> http://www.cs.rice.edu/CS/PLT/
21:10:35 <lambdabot> Title: Rice University Programming Languages Team (PLT)
21:10:38 <thoughtpolice> but i'd have to ask around more
21:11:06 <thoughtpolice> and forming a user group would naturally be awesome but then I have to find a mode of transportation :]
21:11:18 <shapr> @yow !
21:11:18 <lambdabot> There is no TRUTH.  There is no REALITY.  There is no CONSISTENCY.
21:11:18 <lambdabot> There are no ABSOLUTE STATEMENTS.   I'm very probably wrong.
21:11:25 <newsham> thoughtpolice: arent you in houston?
21:11:29 <thoughtpolice> hi shapr
21:11:31 <thoughtpolice> newsham: yes
21:11:33 <shapr> hiya thoughtpolice!
21:11:37 <shapr> thoughtpolice: Going for a swim today?
21:11:38 <newsham> no storm yet?
21:11:43 <thoughtpolice> oh no it's here
21:11:53 <thoughtpolice> just the very front of it or side or however you want to look at
21:12:03 <thoughtpolice> i'm sure it will get worse around 2-3am (it's about 11pm right now)
21:12:34 <thoughtpolice> on the upside
21:12:38 <thoughtpolice> i did get lots of free food and stuff
21:12:40 <thoughtpolice> which is awesome
21:14:53 <bitrot> "Hi thoughtpolice, you're about to drown.  Here, have a taco!"
21:15:15 <thoughtpolice> i'm on the 11th floor
21:15:21 <thoughtpolice> i think i should be alright
21:15:35 <thoughtpolice> and in approx. 30 seconds i'm sure a baseball or something is going to come flying through this window
21:15:46 <mmorrow> BOOOM
21:15:52 <bitrot> damn, you houston folk have a lot of floors.
21:16:27 <mmorrow> thoughtpolice: alright i'm out. don't die.
21:16:36 <thoughtpolice> mmorrow: no promises but i think i'll be fine. :]
21:16:51 <thoughtpolice> bitrot: it's not that great when 1/2 the elevators are broken all the time :[
21:16:56 <mmorrow> bitrot: i'm sure we'll be meeting in the near future :)
21:17:08 <thoughtpolice> seriously, i was in the elevator the other day and it went one floor down and broke
21:17:10 <bitrot> mmorrow: yes.  over functional beer, i'm sure.
21:17:16 <thoughtpolice> luckily it was on the floor and not inbetween
21:17:19 <mmorrow> precisely!!
21:17:49 <thoughtpolice> so i just pried the doors open and didn't have to worry about crawling out with the fear of the cables freakishly breaking at that exact moment and chopping me in half
21:19:29 <thoughtpolice> bitrot: while watching the news this morning over breakfast though there were reports of people who still hadn't left galveston though
21:19:38 <thoughtpolice> which doesn't surprise me but is still stupid imho
21:19:57 <lispy> maybe they had to work?
21:20:00 <bitrot> thoughtpolice: island people are stubborn as hell...and apparently like swimming *a lot*
21:20:31 <ivanm> dmwit: going back to my asking about BSD3, so if I leave that copyright notice in here (and fixing the library name), would it be sufficient in your opinion? http://hackage.haskell.org/packages/archive/graphviz/2008.9.6/doc/html/src/Data-GraphViz.html
21:20:33 <thoughtpolice> "work needed: hurricane fighters"?
21:20:33 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4hwkz6
21:21:43 <thoughtpolice> lispy: but seriously this morning at about 9am there were parts off the beach that already had water completely covering up stop-signs (like 8ft tall you know,) and people weren't leaving for whatever reason after the evac. orders I guess
21:21:50 <thoughtpolice> so they just got their names and SSNs taken down
21:23:17 <thoughtpolice> bitrot: i guess, but that's some damn hardcore swimmin'
21:23:21 <bitrot> hehe
21:23:35 <bitrot> IMHO, the best part of houston is how it looks in a rear-view mirror :D
21:23:52 <thoughtpolice> heh
21:23:57 <thoughtpolice> bitrot: weren't there some people evac.'n from austin?
21:24:12 <bitrot> i'll take cactus-ridden austin over flooding houston any day!
21:24:31 <bitrot> thoughtpolice: likely *to* austin..
21:24:46 <thoughtpolice> hm maybe i misheard the news the other day
21:24:50 <bitrot> maybe san antonio to austin.
21:25:31 <thoughtpolice> either way I just want this shit to be over with - my parents are all freaking out "omg we abandoned him down there in a death storm!!11!"
21:26:22 <bitrot> thoughtpolice: yeah, I was in Huntsville during H. Rita, and my folks flipped out as well.
21:26:49 <bitrot> not a branch from my apt's trees fell...
21:27:07 <thoughtpolice> i'm the only son *and* the youngest so naturally that is causing both my father and mother to flip
21:28:44 <bitrot> meh, you'll get rain, and houston's credit card processing capabilities might die, but no worries for this tiny raincloud.
21:29:08 <cjb> it looks pretty bad to me..
21:29:28 <thoughtpolice> i doubt it will be all that big a deal down here
21:29:31 <newsham> houston's only getting like 55-65mph winds
21:29:34 <thoughtpolice> galveston is obviously another issue entirely
21:30:12 <newsham> galveston emergency planning: "if you haven't evacuated yet, please write your ss# somewhere on yourself with a magic marker so we can identify your body"
21:30:19 <bitrot> yes, as a /barrier/ island, galvenston provides a /barrier/ for houston ;)
21:30:39 <thoughtpolice> newsham basically has it right
21:31:09 <newsham> according to my friend in houston that was a real statement on the news
21:31:13 * bitrot still doesn't understand why people actually live on that black-watered island...
21:32:16 <thoughtpolice> newsham: yeah like I said the NG went down there and found all the people they could who were staying and took down names locations and SSNs
21:32:17 <Nafai> thoughtpolice: Yeah, I doubt people were evacuating Austin
21:32:34 <Nafai> thoughtpolice: My in-laws live there.  Yes, there were a lot of people evacuating to there
21:32:55 <Nafai> People are freaking out in Austin.  She couldn't buy gas the other day and everyone is buying up all of the bottled water
21:33:09 <Nafai> I lived in Austin during Katrina and people were dumb then and we only got a little rain
21:33:22 <bitrot> Nafai: correction...*some* people are freaking out in austin.
21:33:38 <thoughtpolice> yeah like, all the gas stations here are dry
21:33:39 <Nafai> bitrot: True :)
21:33:46 <bitrot> most folks haven't batted an eye..
21:33:51 <thoughtpolice> no canned food or water either
21:33:53 <thoughtpolice> totally sucks
21:34:50 <bitrot> lots of beer on the shelves though
21:35:09 <bitrot> ...which indicates nothing is happening.
21:37:01 <Nafai> bitrot: At least in Austin :)
21:37:22 <bitrot> that's the best part :)
21:38:49 <bitrot> *yawn*
21:39:03 <bitrot> thoughtpolice: stay high and dry, sir.
21:40:33 <dons> yeah, you can use cnn reporters as flotation devices, if needed.
21:42:30 <ivanm> dons: what, do cnn reporters eat less donuts that those from other networks?
21:43:00 <dolio> More donuts would be better.
21:43:19 <bitrot> fat is bouyant, no?
21:43:27 <dolio> Right.
21:43:47 <dons> i just figure they're buoyant, and there's lots of them in houston tonight
21:45:00 <bitrot> reporters...what a strange bunch.  "Let's walk into a fray! Whee!"
21:45:20 <dolio> Nothing gets them out like a hurricaine.
21:45:37 <ivanm> dolio: would it? I'd have thought that fat reporters wouldn't be able to swim as well, and hence would drown taking you with them
21:45:49 <thoughtpolice> bitrot: i'll try :]
21:45:57 <thoughtpolice> just really sucks because I can't go outside to smoke
21:46:02 <thoughtpolice> not that i could light a fucking cigarette anyway
21:46:37 <bitrot> light inside and crack the door for exhalation?
21:46:43 <dolio> Well, that may be true. Purely from an unpowered floatation perspective, though, you want them to be as fat as possible.
21:47:09 <bitrot> if they're fat, and you fill their lungs (and seal!) with air, they'd be bonkers.
21:49:15 <dolio> If you're building a raft like the guy in the pirate comic in The Watchmen, for instance.
21:49:41 <ivanm> heh
21:50:19 <ivanm> "hey, so you're reporters coming to report the hurricane? have some donuts! and take one of these mysteriously sealed air masks whilst you're at it!!" ;-)
21:51:05 <bitrot> "*wheez* *cough* *inflate*"
21:54:03 <goltrpoat> nafai:  i think they're learning
21:54:16 <goltrpoat> no stupid traffic, was able to go to a gas station and buy beer
21:54:26 <Nafai> goltrpoat: Yay
21:54:33 <goltrpoat> and no one looked at me weird while stocking up on kleenex or whatever it is they do
21:55:09 <goltrpoat> i'm north though.  dunno what it's like downtown.
21:55:59 <goltrpoat> funny thing is, they're predicting 30mph winds and that's about it.
21:57:00 <bitrot> goltrpoat: it was 45ish when I moved my plants inside this morning.
21:57:26 <goltrpoat> 45ish?  where?
21:58:07 <bitrot> far west..."or so I heard".  maybe it was max gust-speed, dunno.
21:58:18 <Nafai> I used to live over on Far West
21:58:29 <goltrpoat> im a street over from far west
21:58:49 <goltrpoat> mopac and steck
21:59:22 <bitrot> goltrpoat: no shit.
22:00:02 <bitrot> goltrpoat: you know of the AustinFP group?
22:00:12 <goltrpoat> i know of it, haven't been
22:00:31 <goltrpoat> you must live right by musashino though.  that's a perk.
22:00:47 <bitrot> it's entirely too small...you should attend.
22:00:58 <bitrot> mushashino?
22:01:06 <goltrpoat> oh dear.
22:01:23 <goltrpoat> the best sushi place in austin is right by your house and you don't know about it.
22:01:41 <bitrot> I work near Triumph cafe..
22:01:55 <goltrpoat> oh i do like triumph cafe.  where do you work?
22:02:03 <bitrot> S3
22:02:35 <bitrot> the big citibank building @ spicewood & mopac
22:02:53 <goltrpoat> ah
22:04:04 <ivanm> anyone here familiar with the polyparse library?
22:04:25 <bitrot> hmm...on greystone...
22:05:01 * bitrot gets his bike to go check...
22:05:39 <goltrpoat> if i see anyone in my driveway on a bike, i'm shooting them no questions asked.
22:06:00 <goltrpoat> er i mean, just kidding.
22:06:05 <bitrot> :)
22:06:48 <bitrot> i'm surprised nobody has told me good..er.."best" sushi is around the corner..
22:07:21 <goltrpoat> definitely the best uni in town.  ankimo, too.
22:07:44 <goltrpoat> no one else is in the running.
22:07:59 <bitrot> I know what I'm eating tomorrow.
22:09:34 <goltrpoat> it's on the expensive side, take a date.
22:10:19 <newsham> hmm.. i cant reach www.ertos.nicta.com.au  can anyone else?
22:11:56 <goltrpoat> newsham:  negative.  pings, then sits there.
22:12:59 <lispy> http://209.85.173.104/search?q=cache:3VDyL0BVSjgJ:ertos.nicta.com.au/+www.ertos.nicta.com.au&hl=en&client=firefox-a&gl=us&strip=1
22:13:00 <lambdabot> Title: Home | ERTOS | NICTA, http://tinyurl.com/4xal5p
22:13:05 <lispy> google cache for the win
22:13:46 <newsham> goog cache for http://www.ertos.nicta.com.au/publications/papers/LeVasseur_UYCCLH_08.pdf plz
22:14:17 <lispy> well just want want want why don't you :)
22:14:51 <newsham> GET /LeVasseur_UYCCLH_08.pdf lispy/1.1
22:16:48 <lispy> newsham: http://digbib.ubka.uni-karlsruhe.de/volltexte/documents/11466
22:16:51 <lambdabot> Title: Pre-virtualization: soft layering for virtual machines
22:18:39 <newsham> are the other sel4 papers there too?
22:20:11 <lispy> newsham: I'm not sure.  I grabbed the paper title off the google cache and then googled for the paper
22:20:50 <lispy> newsham: good luck
22:22:38 <shapr> mmm code
22:23:18 <lispy> hey shapr
22:23:34 <shapr> hiya!
22:23:51 <shapr> How's code?
22:24:25 <shapr> cabal update sure is taking long.
22:24:31 * shapr wonders
22:24:46 <thoughtpolice> shapr: it does that sometimes
22:24:52 <shapr> weird
22:24:56 * shapr installs twidge
22:25:03 <thoughtpolice> i ^C and try immediately again and it chugs along quick
22:25:08 <thoughtpolice> normally, anyway
22:25:27 * shapr renames thoughtpolice to 11thFloorSwimmerInTX
22:25:31 * shapr grins evilly
22:25:38 <thoughtpolice> :]
22:25:49 <thoughtpolice> shapr: actually just went outside and smoked
22:25:53 <thoughtpolice> it's not *that* bad
22:26:02 <thoughtpolice> granted I was kind of under the building somewhat on the ground floor
22:26:16 <thoughtpolice> but there were people sitting outside on benches and whatnot
22:26:41 <shapr> And they were dry?
22:27:03 <thoughtpolice> the benches were on the opposite side of the building where the rain was typically coming from
22:27:08 <shapr> ah
22:27:31 <roconnor> I have a set of linearly independent vectors, how do I find a set of interger coefficents in order to get their linear combination to lie in a given rectangle?
22:27:39 <roconnor> integer
22:27:55 <thoughtpolice> so they were shielded for the most part, plus there's naturally a top above their heads too
22:28:02 <thoughtpolice> i'd have to take a picture to really explain
22:28:03 <shapr> Oh, so that's what bos looks like!
22:28:29 <shapr> thoughtpolice: Ok, pix!
22:29:05 <thoughtpolice> shapr: but a guy earlier who's dorms got mandatory evac (upperclass man) told me once when he lived in apartment on the second floor and when another hurricane hit here
22:29:13 <thoughtpolice> he literally had a boat tied to his pateo on the second floor
22:29:17 <shapr> whoa
22:29:22 <shapr> Now that's picture-worthy.
22:29:26 <thoughtpolice> word
22:29:37 <shapr> Hm, can anyone else cabal install twidge without errors?
22:30:01 <goltrpoat> thoughtpolice:  hmm?
22:30:01 <thoughtpolice> updating...
22:30:08 <dons> shapr: it needs an older haxml, fwiw.
22:30:27 <lispy> people here use twitter?
22:30:35 <shapr> ohh
22:30:35 <thoughtpolice> goltrpoat: yeah crazy stuff
22:30:49 <goltrpoat> thoughtpolice:  where was this?
22:30:50 <Nafai> lispy: Yes, in fact dons was talking about beer on twitter earlier tonight :)
22:30:59 <thoughtpolice> dons: you got my message? i can probably get you some patches to uvector by the weekend to get it to build on head
22:31:08 <thoughtpolice> goltrpoat: houston, tx
22:31:10 * lispy is pretty anti-twitter so was surprised
22:31:18 <dons> shapr: "rat. my cabal upload is badly in ned of help. fixing."
22:31:19 <shapr> Hm, I have both 1.13 and 1.19 installed.
22:31:23 <dons> thoughtpolice: most welcome.
22:31:33 <thoughtpolice> dons: 'cause it's kind of unfair to have ghc6.8-uvector vs. ghc6.9-vector
22:31:41 <ddarius> roconnor: Set up the inequalities and solve.  I'm too tired to work out the details.  Probably just linear programming.
22:31:41 <dons> yes please.
22:31:47 <ddarius> Though there may be a quicker way.
22:31:48 <thoughtpolice> i'm using uvector as the control
22:31:53 <shapr> I think it's amusing to send twitter client build errors via twitter.
22:31:57 <roconnor> ddarius: is there a linear programming hackage?
22:32:01 <thoughtpolice> i noticed vector misses part of the optimization that uvector catches
22:32:07 <thoughtpolice> in your micro-mean benchmark
22:32:12 <dons> roconnor: linear algebra?
22:32:14 <shapr> Dang, I forgot to eat today...
22:32:16 <bitrot> goltrpoat: who knew?  greysone has more than apartments!
22:32:21 <dons> thoughtpolice: oh, that's interesting!
22:32:26 <dons> thoughtpolice: in which part?
22:32:35 <ivanm> what's the function that splits a list into two: those that fulfill and predicate and those that don't? hoogle just gives me span and break :s
22:32:38 <dons> shapr: the brain needs mucho calories
22:32:41 <dolio> thoughtpolice: Is there something besides the strictness annotations in newtypes that causes it to fail on 6.9 now?
22:32:42 <shapr> Yeah
22:32:42 <thoughtpolice> dons: just a sec and i'll get core output
22:32:45 <ddarius> roconnor: Possibly.  Probably even.  But I don't know which one.
22:32:48 <dolio> I'm pretty sure I've already sent him a patch for that.
22:32:55 <lispy> roconnor: I would guess that you want to make them orthonormal
22:32:57 <thoughtpolice> dolio: not sure, ghc just turns that particular oversight into a total parse err now
22:33:06 <dons> hmm
22:33:09 <lispy> roconnor: grahm-schmidt or something
22:33:14 <thoughtpolice> i'll pull the uvector head and see where it goes
22:33:14 <roconnor> maybe I could use linear algebra
22:33:19 <roconnor> and then just round the coefficents
22:33:20 <dons> thoughtpolice: ok.
22:33:41 <dolio> I'm not sure the patch has been pushed yet.
22:33:52 <dons> dolio: i think i'll do a uvector release tomorrow.
22:33:58 <dons> and a couple of other things.
22:33:59 <dolio> Cool.
22:34:09 <thoughtpolice> dons: then I can get that to you tonight probably
22:34:14 <thoughtpolice> fixing it to build shouldn't be too big a hassle
22:34:19 <thoughtpolice> plus I have to read anyway
22:34:34 <dons> ok. thanks.
22:34:41 <dons> you got nothing else to do? :)
22:34:44 <thoughtpolice> dolio: what? the strictness-in-newtypes-is-now-an-err?
22:34:51 <lispy> roconnor: http://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process
22:34:52 <lambdabot> Title: Gramâ€“Schmidt process - Wikipedia, the free encyclopedia
22:34:57 <dolio> It is in 6.9. Or was when I tested it a while ago.
22:35:01 <dons> oh, the newtype strictness is gone, isn't it?
22:35:03 <dons> i thought i removed that.
22:35:04 <thoughtpolice> it's been pushed from what I can tell, nominolo_ showed output earlier
22:35:40 <thoughtpolice> dons: eh this hurricane business is interesting and I need to read some books anyway - I have an exam and quiz next week
22:35:56 <thoughtpolice> so other than that not really :] i just have to put my laptop up and go downstairs and i'll get it done
22:35:57 <dolio> Oh, yeah. I don't think that patch has been committed. Unless my uvector repository isn't pointed at the right place.
22:36:06 <dons> hmm
22:36:21 <dons> dolio: which one are you looking for?
22:36:23 <lispy> roconnor: once you have the gram-schmidt basis, maybe you can find common demoninators such that you have integers
22:36:42 <dolio> dons: The one that removes the bangs on all the newtypes in Data/Array/Vector/UArr.hs
22:36:53 <lispy> roconnor: beyond that guess, I'd check in #math
22:36:54 <dons> hmm
22:37:42 <dolio> They're still their in my uvector checkout, and darcs pull says no changes.
22:38:09 <roconnor> lispy: #math is useless.  They think every question is homework. :)
22:38:26 <lispy> roconnor: hehe, Then turn to #math's secret weapon...Cale
22:38:30 <ddarius> @google integer linear programming
22:38:33 <lambdabot> http://en.wikipedia.org/wiki/Linear_programming
22:38:33 <lambdabot> Title: Linear programming - Wikipedia, the free encyclopedia
22:40:05 * lispy mumbles something about working in the rationals and then using gcd
22:40:54 <hackage> Uploaded to hackage: twidge 0.99.0.1
22:43:16 <dancor> can ghci tell me where a function is defined
22:46:25 <lispy> dancor: :i somefunction
22:46:41 <lispy> dancor: but, hmm...that's not as cool as hoogle
22:47:28 <lispy> dancor: you could install lambdabot locally and all the plugins (like hoogle) and then use ghci on acid, but it's much much easier to just use the hoogle website or ping lambdabot from irc
22:49:11 <dancor> lispy: yeah i've done that
22:49:16 <dancor> lispy: just for a new library
22:49:28 <dancor> maybe i can get hoogle to look at new libraries?
22:49:33 <dancor> locally
22:49:55 <lispy> dancor: haskell tags are nice too
22:50:02 <lispy> dancor: works from both emacs and vi
22:51:36 <goltrpoat> speaking of that..
22:51:50 <dancor> lispy: oh about that, am i making this harder than it needs to be:
22:51:52 <dancor> find . -path ./_darcs -prune -o -name '*.*hs' -print | xargs hasktags -c
22:52:13 <goltrpoat> emacs+auctex+literate-haskell-latex+ghci
22:52:18 <goltrpoat> how the fuck does that work.
22:52:25 <lispy> dancor: my only experience with running hasktags is via the make target in the darcs repository
22:52:35 <lispy> dancor: look at http://darcs.net/GNUmakefile
22:52:36 <thoughtpolice> dons: http://hpaste.org/10338
22:52:39 <lispy> I gotta run
22:52:43 <lispy> good luck
22:52:47 <dancor> tx
22:53:07 * dancor checks out auctex
22:53:13 <thoughtpolice> dons: perhaps worth forwarding to roman? uvector catches this according to your post correct? (what options did you use exactly?)
22:56:33 <goltrpoat> dancor:  auctex is brilliant.  if it only worked with auto-fill-mode, it'd be a fucking godsend.
22:56:36 <goltrpoat> (says the windows guy)
22:58:30 <dons> thoughtpolice: that looks to me like fromList doesn't fuse?
22:58:38 <dons> uvector just uses enumFromToFracU.
22:58:46 <thoughtpolice> dons: that's actually what I was thinking just now
22:58:55 <thoughtpolice> so an api gap issue? that's with vector's head
22:59:14 <dons> possibly yes, it also has an enumFromTo i think.
22:59:16 <dons> or maybe it doesn't.
23:00:30 <thoughtpolice> it does not seem to be so
23:00:46 <dons> ok. so that's the issue.
23:00:51 <dons> generation has to fuse
23:00:56 <dons> so api gap.
23:01:02 <dons> but eh, vector is experimental.
23:01:06 <dons> uvector is all win however :)
23:01:09 <thoughtpolice> :]
23:01:12 <dons> it's aiming at a smaller target.
23:01:16 <thoughtpolice> it's always fun to play with the experimental
23:01:18 <dons> yep
23:01:43 <dons> so you're not panicky yet, thoughtpolice. maybe i should turn off cnn.
23:01:49 <dons> they're getting kinda silly about it.
23:01:55 <thoughtpolice> not really.
23:01:58 <thoughtpolice> it's windy
23:02:01 <dons> heh
23:02:01 <thoughtpolice> there is always wind in texas
23:02:21 <thoughtpolice> i came to accept that a long time ago
23:02:30 <dons> just one of those things, eh?
23:02:35 <thoughtpolice> to be fair we're not exactly getting the front of it though
23:02:48 <thoughtpolice> (unless cnn is talking about houston?)
23:02:58 <dons> no, the coast really.
23:03:42 <thoughtpolice> dons: yeah kinda, i'm new here but it's not that huge of a deal it seems. most of the people here are from houston so they're likely used to it
23:03:45 <thoughtpolice> nothing to really freak about
23:03:54 <thoughtpolice> dons: yeah I'm sure galveston is getting hammered right now
23:05:10 <bitrot> thoughtpolice: why is it windy in amarillo?
23:05:35 <thoughtpolice> bitrot: i live about an hour south of amarillo actually
23:05:59 <bitrot> thoughtpolice: answer: 'cause Oklahoma sucks....
23:06:13 <thoughtpolice> but i mean, it's windy. windy above average? probably, but still.
23:06:41 <dons> heh
23:07:08 <bitrot> thoughtpolice: the last time I was in amarillo, it was 22F and I couldn't believe it.
23:07:22 <bitrot> it was 45 back home!
23:08:22 <thoughtpolice> bitrot: yes, it can actually get cold up there sometimes :p
23:17:48 <dons> shapr: still getting type errors with twidge?
23:17:50 <dons> Commands/Ls.hs:228:24:
23:17:50 <dons>     Couldn't match expected type `[String] -> t'
23:17:50 <dons>            against inferred type `String'
23:19:36 <thoughtpolice> dons: email = dons at galois.com right (uvector patch)?
23:19:41 <dons> yup.
23:20:45 <thoughtpolice> dons: hm not sure if it sent but you might want to check in a minute
23:21:58 <dons> nothing yet.
23:22:50 <thoughtpolice> dons: used darcs send with msmtp instead - try again in a sec
23:24:09 <dons> got it.
23:24:16 <dons> cheers.
23:25:33 <thoughtpolice> now let the ridiculous comparisons begin!
23:26:09 <thoughtpolice> i'm interested in stream fusion and vector is immature so maybe something to play around with - i don't give my head build enough attention anyway outside of playing with e.g. view patterns and qq sometimes
23:26:10 <dons> pushed.
23:26:29 <dons> well, there's clearly more work on fusion to happen.
23:26:38 <thoughtpolice> for sure.
23:26:40 <dons> roman just submitted a paper to PADL about uniqueness and fusion.
23:26:48 <dons> i'll try to get it online soon. he's shy though :)
23:26:55 <dons> it's based on vector.
23:27:16 <thoughtpolice> neato torpedo - probably do good to look through the original paper too
23:30:25 <dons> thoughtpolice: http://www.cse.unsw.edu.au/~rl/recycling.pdf
23:30:27 <lambdabot> Title: cache:http://www.cse.unsw.edu.au/~rl/recycling.pdf - Google Search
23:30:52 <thoughtpolice> ty
23:38:03 <dons> ibid: should the panda author's blog be on planet.haskell, http://jinjing.blog.easymic.com/
23:38:08 <lambdabot> Title: Cå¤§è°ƒ
23:38:40 <dons> he's used kibro to build the panda blog engine, and writes about haskell, but not always in english
23:41:00 <jinjing> dons: sorry, about that, I usually blog about my personal life in chinese, and the engine does not support rss on tags yet
23:42:06 <dons> ah :)
23:42:55 <dons> jinjing: http://aur.archlinux.org/packages.php?ID=19808
23:42:56 <lambdabot> Title: AUR (en) - haskell-panda
23:43:34 <jinjing> dons: what's that -1 for?
23:43:50 <dons> -1?
23:44:00 <jinjing> 0.0.0.2-1
23:44:07 <dons> oh, arch package tag.
23:44:18 <jinjing> oh
23:45:01 <dons> so that's the first revision of the package.
23:45:55 <jinjing> i c
23:46:29 <papermachine> Panda looked really interesting, but I can't wrap my head around the redefinition of (.)
23:46:41 <papermachine> I know it's pretty common.
23:47:00 <dons> oh?
23:47:04 <dons> is it the flipped version?
23:47:07 <papermachine> Yeah.
23:47:11 <dons> i'm not sure why people do that :)
23:47:20 <jinjing> well hehe
23:47:28 <papermachine> :)
23:47:32 <electronx> anyone here use ruby and like it?
23:47:33 <dons> you see the ruby guys do it, when they come to haskell.
23:47:49 <dons> it's not very common, but it does sometimes happen.
23:47:55 <dons> i guess it helps with thinking about composition.
23:47:55 <papermachine> I kind of like Panda though
23:47:56 <jinjing> i just want to read from left to righ
23:48:00 <dons> yeah.
23:48:11 <electronx> my ruby code runs too slow sigh
23:48:12 <dons> even Craft of FP book did that.
23:48:24 <dons> electronx: hehe. ghc is an optimizing native code compiler.. :)
23:48:28 <dons> so haskell's waiting.
23:48:40 <electronx> ya
23:48:51 <electronx> to late for me to wrewrite my code
23:48:59 <electronx> rewrite*
23:49:03 <dons> lock in!
23:49:11 <dons> they tricked you, and now you're trapped :)
23:49:12 <electronx> due next friday
23:49:16 <electronx> :)
23:49:29 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ruby&lang2=ghc
23:49:31 <lambdabot> Title: Ruby benchmarks | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language Benchmarks Game, http://tinyurl.com/2nf5kc
23:49:35 <electronx> haskell doesn't support unicode though
23:49:44 <dons> electronx: ?
23:49:50 <dons> Char is a 32 bit unicode code point.
23:49:56 <dons> utf8-string parsers and prints unicode.
23:50:07 <dons> unicode is part of the language definition.
23:50:13 <electronx> i need to implement a simple we crawler
23:50:17 <electronx> web*
23:50:19 <bd_> and then none of the builtin IO stuff understands it? :)
23:50:25 <electronx> then ngram lang classifier
23:50:27 <dons> that's what the uft8-string package is for.
23:50:30 <dons> unicode io.
23:50:45 <dons> electronx: so use say, bytestrings + utf8-string + forkIO for massive parallelism ?
23:50:57 <electronx> :)
23:51:00 <bd_> true, but it seems a bit inconsistent. What charset is getLine converting from? :)
23:51:17 <dons> the builtin getLine?
23:51:28 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
23:51:35 <lambdabot> Title: HackageDB: utf8-string-0.3.1.1, http://tinyurl.com/3cjhwj
23:51:41 <bd_> indeed. It makes little sense to define Char as a unicode codepoint, then make all the (haskell report) IO operations ignore that fact :)
23:51:55 <electronx> i might use haskell for next project :)
23:51:56 <bd_> too late to fix it now I suppose
23:52:03 <dons> that's why the libraries for doing other kind of ones exist.
23:52:12 <dons> import System.IO.UTF8 (readFile)
23:52:13 <dons> et al.
23:52:21 <dons> simple, easy, and in the haskell platform.
23:52:23 <electronx> maybe i should use pythone
23:52:32 <electronx> python*
23:52:33 <dons> electronx: still slow.
23:52:46 <dons> why not haskell, btw?
23:52:54 <bd_> dons: yeah, but really the builtin IO should work in terms of Word8, and the unicode functions should declate a unicode codepoint type Unichar or similar. Because otherwise the semantics of the builtin IO functions can be confusing :)
23:53:04 <dons> you've got fast concurrency, efficient strings, unicode . html/xhtml/xml parsing. what else?
23:53:33 <electronx> beysian lib
23:53:34 <electronx> ?
23:53:36 <dons> sure.
23:53:47 <dons> i think. checking..
23:53:56 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ProbabilityMonads
23:53:59 <lambdabot> Title: HackageDB: ProbabilityMonads-0.1.0, http://tinyurl.com/5yjgbd
23:54:10 <dons> there might be some other things.
23:54:18 <dons> there's 750 packages on hackage, so hunt around.
23:54:21 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html
23:54:23 <lambdabot> Title: HackageDB: packages by category
23:54:43 <electronx> dons i also don't know haskell that well
23:54:55 <electronx> so i would need time to learn it
23:55:19 <dons> well, next time you need  fast, short, reliable code..
23:55:24 <dons> you know where to look.
23:56:33 <electronx> maybe should have learnt haskell and not ruby
23:57:48 <dmwit> You should learn both.
23:58:54 <electronx> not enough time
