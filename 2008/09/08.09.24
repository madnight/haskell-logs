00:02:08 <parodyoflanguage> Depends on the amount of coupling.
00:04:43 <TSC> Obviously if people waste time coupling instead of working then it will take longer
00:15:17 <stulli> So balanced binary trees are more efficient than hash tables in haskell? Why?
00:15:50 <dolio> You mean Data.Hashtable?
00:15:59 <dolio> Because Data.Hashtable isn't very good, presumably.
00:16:42 <stulli> I am reading RWH and it says "Internally, a map is implemented as a balanced binary tree" in Data.Map
00:16:58 <dolio> Yeah.
00:17:18 <sjanssen> stulli: Haskell is purely functional, hash tables don't work well in a pure setting
00:18:05 <stulli> sjanssen: So imperative languages have an advantage here because they can use hash tables more efficient?
00:18:24 <dolio> What makes you think hashtables are better than balanced trees?
00:19:27 <stulli> dolio: I learned that in some cases hash tables are better than binary trees (i.e. dictionaries)
00:19:29 <dolio> Of course, the new map library in the works is using tries.
00:19:52 <dolio> Which are better than balanced trees in some cases.
00:20:13 <Vq^> an very often better than hash-tables
00:20:14 <earthy> err... dictionaries are not necessarily binary trees...
00:20:33 <earthy> but it all *really* depends on usage patterns
00:20:45 <Vq^> dictionary is just another name for associative array, right?
00:20:54 <dolio> Yeah.
00:20:59 <dolio> Map, dictionary, ...
00:21:36 <sjanssen> stulli: in my opinion, hash tables are a bit overrated
00:21:50 <mapreduce> Could you use the imperative implementation of hashtables in Haskell from inside a State-like monad?
00:21:58 <sjanssen> stulli: yes, they provide many O(1) operations, but in practice O(log n) might as well be O(1)
00:22:08 <dolio> Lots of people (in my experience) refer to maps as "hashtables" too. :)
00:22:10 <stulli> sjanssen: thats what i meant
00:22:10 <Vq^> mapreduce: of course
00:22:30 <Vq^> mapreduce: there is even one in the standard libs
00:22:49 <stulli> sjanssen: ok, i didnt know about real life performance
00:23:26 <mapreduce> Vq^: Cool.
00:23:42 <Vq^> stulli: hash-tables usually have a fairly heavy hash-function and for some cases an ordinary binary tree is faster
00:24:02 <Vq^> stulli: and radix-trees/tries are usually faster than hash-tables in my experience
00:24:36 <Vq^> please correct me if thats far from the truth :/
00:25:47 <stulli> Vq^: Thanks for explaining. So i guess hash tables make sense for really large amounts of data?
00:26:06 <dolio> Hashtables are at least harder to get right.
00:26:34 <Vq^> yeah, you have to make sure you avoid their worst-case
00:26:40 <glguy> Vq^: I'll correct you. That hasn't been your experience ;)
00:27:07 --- mode: glguy set -o glguy
00:27:11 --- mode: ChanServ set -o glguy
00:27:20 <Vq^> glguy: thanks, thought i got the results mixed up :)
00:27:28 <Vq^> @karma+ glguy
00:27:28 <lambdabot> glguy's karma raised to 1.
00:27:59 <dolio> Woo. No more reincarnating as an earthworm for glguy.
00:28:21 * sjanssen finds it hard to believe that glguy's karma is actually 1
00:28:26 <dolio> @karma
00:28:26 <lambdabot> You have a karma of 0
00:28:26 <sjanssen> lambdabot: you're so forgetful
00:28:30 <dolio> @karma dons
00:28:30 <lambdabot> dons has a karma of 2
00:28:35 <dolio> Looks like it got reset.
00:28:51 <lament> @karma lambdabot
00:28:51 <lambdabot> lambdabot has a karma of 4
00:28:58 <Vq^> @karma shapr
00:28:58 <lambdabot> shapr has a karma of 1
00:29:03 <lament> lambdabot++
00:29:08 <sjanssen> @karma-all
00:29:08 <lambdabot>  "moritz"               79
00:29:09 <lambdabot>  "pmurias"              31
00:29:09 <lambdabot>  "ruoso"                26
00:29:09 <lambdabot>  "lwall"                25
00:29:09 <lambdabot>  "elpolilla"            20
00:29:11 <lambdabot> [158 @more lines]
00:29:15 <sjanssen> damned Perl guys
00:29:22 <dolio> Heh.
00:29:26 <Vq^> :/
00:29:27 <ivanm> why is lambdabot in perl? just to help them with pugs?
00:29:39 <ivanm> they should get their own! :p
00:29:42 <vegai> lambdabot is such a who...
00:29:53 <ivanm> @seen lambdabot
00:29:54 <lambdabot> Yes, I'm here. I'm in #haskell-icfp, #math, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.
00:29:54 <lambdabot> jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell,
00:29:54 <lambdabot> #ghc, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
00:30:02 <lament> ivanm: they can't, nobody ever wrote an irc bot in Perl!
00:30:04 <vegai> you see? she'll go anywhere
00:30:06 <sjanssen> ivanm: lambdabot probably joined due to the rise of pugs, I'm sure
00:30:10 <ivanm> lament: right...
00:30:19 <ivanm> well, can't they run their own instance?
00:30:30 <dons> ?yow
00:30:31 <lambdabot> I want you to organize my PASTRY trays ... my TEA-TINS are gleaming in
00:30:31 <lambdabot> formation like a ROW of DRUM MAJORETTES -- please don't be FURIOUS with me --
00:30:32 <Beelsebob> ivanm: that's harder than you think
00:30:33 <ivanm> look at all the non-haskell channels with lambdabot in them! :o
00:30:33 <dons> ?users
00:30:34 <lambdabot> Maximum users seen in #haskell: 516, currently: 443 (85.9%), active: 16 (3.6%)
00:30:42 <Beelsebob> lambdabot is *really* hard to get set up and working right
00:30:54 <vegai> rather.
00:30:59 <ivanm> Beelsebob: which not even #haskell can do, hence the continual crashing? :p
00:31:04 <sjanssen> the darcs version has gotten much better over the past few months
00:31:04 <Beelsebob> indeed
00:31:07 <lament> ...well, actually, you'd _think_ #unicycling is a non-haskell channel, but really, it is...
00:31:17 <dons> i think lambdabot has been fairly stable for the last few weeks
00:31:23 <juhp> heh - guess need karma for users in channel...
00:31:43 <lament> @karma c
00:31:43 <lambdabot> c has a karma of 0
00:31:49 <lament> c++
00:31:54 <vegai> @karma C++
00:31:54 <lambdabot> C++ has a karma of 0
00:32:00 <vegai> c++++
00:32:01 <vegai> @karma C++
00:32:02 <lambdabot> C++ has a karma of 1
00:32:02 <Beelsebob> why don't we just do @karma+ for every user in #haskell by 100 :P
00:32:06 <lament> c++++++
00:32:08 <vegai> oh, it worked
00:32:10 <Vq^> C++--
00:32:11 <lament> @karma c++++
00:32:12 <lambdabot> c++++ has a karma of 1
00:32:12 <Vq^> C--++
00:32:15 <vegai> Vq^: thank you.
00:32:25 <lament> @karma c--
00:32:25 <lambdabot> c-- has a karma of 1
00:32:30 <Vq^> :)
00:32:34 <Beelsebob> Vq^++
00:32:52 <Vq^> y√§y, im popular :)
00:33:28 <lament> the one with the highest karma washes the dishes!
00:35:16 <ivanm> is there any way of filtering @karma-all to only people in this channel?
00:35:31 * ivanm isn't up with the latest intricasies of lambdabot commands
00:51:26 <zeno> @karma c++-=100
00:51:26 <lambdabot> c++-=100 has a karma of 0
01:02:06 <lispy> why don't we refer to it as the GHC programming language?
01:02:27 <lispy> Seems like a lot of commonly used features are specific to GHC :)
01:02:45 <Cale> lispy: Haskell is a general term
01:03:35 <Beelsebob> lispy: I'm not sure that there are many commonly used features that aren't in Haskell 98 -- on the other hand, I'm sure that it's common that people use at least one feature not in H98
01:04:16 <Beelsebob> I do however support you, having had to endure a few years of people saying hat doesn't support Haskell -- it does, just no one writes Haskell
01:04:28 <dons> it's like ML
01:04:41 <dons> in the form of OCAml, SML/NJ, polyml
01:06:05 <Beelsebob> yep
01:08:41 <dons> let's port hat to ghc
01:08:49 <dons> so we can actually use it for you know, stuff
01:09:09 <quicksilver> ocaml is, in fact, a lot more different from ML than GHC is from haskell
01:09:14 <quicksilver> so maybe out situation is not all that bad :)
01:09:14 <dons> Beelsebob: seen the latest shootout scores, btw?
01:09:28 <dons> quicksilver: yeah i think its more like mlton/polyml/smlnj
01:09:32 <dons> ocaml is out on its own
01:09:45 <dons> haskell-of-glasgow
01:10:28 <Beelsebob> dons: I've been too busy hacking away at hs-plugins trying to get it to work with 6.10
01:10:50 <dons> what on earth do you want hs-plugins for? :)
01:11:08 * dons goes to bed. night
01:11:16 <Beelsebob> I don't really want hs-plugins specifically, but I do want to run a random chunk of Haskell code in a Haskell program
01:11:21 <Beelsebob> trying to do a little JIT compiling
01:12:59 <quicksilver> I thought of using hs-plugins to get a JIT-compiled query language
01:13:11 <quicksilver> (generating custom haskell code from the query and then getting it compiled)
01:22:34 <zeno> cabal install yi -fshim; yi-0.4.6 depends on Cabal-1.4.0.2 which failed to install.    cabal --vers cabal-install; version 0.5.2; using version 1.4.0.2 of the Cabal library
02:25:19 <osfameron> so which language won icfp comp?
02:49:01 <Deewiant> osfameron: I'm skimming through the video, ML won the lightning round
02:49:58 <vegai> wasn't it Java?
02:50:02 <vegai> and team smartass
02:50:15 <Beelsebob> yeh
02:50:19 <Beelsebob> Haskell was 4th and 5th
02:50:25 <osfameron> yeah, I can't watch video at work, and the webpage didn't seem to give an obvious summary :-)  (sorry, just being lazy *and* eager :-)
02:50:30 <Deewiant> yeah, Java
02:50:38 <osfameron> and last year was Perl?
02:50:43 <vegai> Java is a programming language of choice for the discriminating hacker.
02:50:48 * vegai throws up in his mouth a little :P
02:50:49 * osfameron faints
02:50:57 <Deewiant> Java C++ Java Haskell Haskell C C++ C C++ C++ Java C++ Java C++ Java C C++ Java Python Python
02:51:00 <Deewiant> top 20
02:51:25 <Deewiant> ML C# C++ Java C++ Java Java C++ Python Erlang
02:51:29 <Deewiant> top 10 for the lightning round
02:52:41 <Deewiant> haha, "I have to say that Java - as much as this hurts me - Java is the programming tool of choice for discriminating hackers"
02:53:52 <vegai> it's more about the people than about the platform, I suppose.
02:54:07 <quicksilver> remind what what the problem was this year?
02:54:10 <FunctorSalad_> what was the task?
02:54:13 <Deewiant> mars rover
02:54:23 <quicksilver> ah right
02:54:26 <Deewiant> avoid martians + boulders + pits and get to the goal
02:54:40 <quicksilver> yes, strikes me that problem mapped fairly well to standard OO modelling
02:55:24 <quicksilver> and yes, vegai, it's mainly the people :)
02:55:47 <quicksilver> familiarity with appropriate libraries helps a lot, too
02:55:55 <quicksilver> decent visualisation helps a lot with modelling
02:56:02 <quicksilver> picture tells a thousand words etc
03:14:18 <lilac> to be honest, this year's task seemed a bit weak to me. not sure what it was about it, but it wasn't much fun.
03:37:16 <_ar> is there a way to take [IO (x)] to IO([x]) ?
03:37:30 <subconscious> yes, sequence does that
03:37:54 <_ar> thank you subconscious
03:38:50 <Axman6> @hoogle [m a] -> m [a]
03:38:51 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:38:51 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:38:51 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
03:39:24 <Axman6> @src sequence
03:39:24 <lambdabot> sequence []     = return []
03:39:24 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:39:24 <lambdabot> --OR
03:39:24 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:38:04 <daoinall> Hi Everyone, I'm new to Haskell, and am considering using it for a project at work!  I'd just like to do a sanity check on my thinking....
04:38:26 <Axman6> what's the project?
04:38:57 <Axman6> @faq can daoinall use haskell to get the best possible result for his project?
04:38:58 <lambdabot> The answer is: Yes! Haskell can do that.
04:39:59 <SamB_XP> @faq can Haskell be totally the wrong choice for his project?
04:39:59 <lambdabot> The answer is: Yes! Haskell can do that.
04:40:24 <daoinall> it's a web application that involves quite a lot of database calls, I'm evaluating different languages, and am absolutely loving Haskell, but am also having a hard time justifying things like Monads ....
04:40:41 <vegai> always the monads :P
04:40:44 <Axman6> daoinall: seen HAppS?
04:40:49 <Eelis> @faq can Haskell get daoinall fired?
04:40:49 <lambdabot> The answer is: Yes! Haskell can do that.
04:41:30 * vegai smiles
04:41:43 <daoinall> I've seen some of HAppS, but I'm having a thinking failure about integrating lots of database IO with pure functions.
04:42:01 <vegai> seems to me that haskell+web is best done with haskell-fastcgi and hdbc
04:42:26 <daoinall> that's pretty much the plan :)  I'm planning on plugging fastcgi into lighttpd or apache.
04:42:35 <vegai> that's what I'm doing personally too
04:43:06 <vegai> it probably won't be as easy as doing it with another language and a comprehensive web framework, though
04:43:13 <vegai> but should be much more educational ..
04:43:20 <daoinall> Yeah
04:43:49 <daoinall> Web frameworks aren't too hard to come by though, in the company I work for, we rolled our own.
04:43:53 <daoinall> Sort of
04:43:58 <vegai> good ones are :)
04:44:46 <magthe> can't seem to find function for bit shifting... where should I be looking?
04:44:57 <SamB_XP> @doc Data.Bits
04:44:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
04:45:38 <Axman6> hmm... bitshifting in haskell doesn't sound at all right
04:45:52 <daoinall> very true! I have to integrate with our current presentation layer (although I can take some liberties :).  We currently have problems (I believe) with overuse of DB.  It's very easy to do when you have functions calling functions calling functions with DB calls all the way through....
04:46:06 <magthe> Axman6: I know, but I have a good reason for it ;)
04:46:11 <quicksilver> daoinall: not to put you off - haskell is awesome - but a large DB backed mission critical website is not going to be the easiest place to start ;)
04:46:18 <Axman6> good good :)
04:47:35 <daoinall> It's not mission critical (at least, not initially).  The idea is to put together the same simple(ish) dynamic page in a few systems and see what was nice and what was nasty.
04:48:31 <daoinall> and I love functional programming!  I did some lisp at school, and i've been getting all my colleagues to use Python list comprehensions, generator expressions and higher-order functions
04:48:51 <vegai> I had a weird result in running ab at a lighttpd + haskell-fcgi app, btw
04:48:52 <daoinall> but it's a fair point quicksilver!
04:49:02 <vegai> ab -n 16438 -c 129 resulted in 0 errors
04:49:09 <vegai> but ab -n 16438 -c 130 resulted in 16040 errors
04:49:24 <vegai> but I suppose this might be due to some socket limit in linux or something.
04:49:28 <Axman6> ha
04:49:36 <vegai> or in lighty
04:49:54 <Axman6> lighty's pretty robust
04:50:17 <Axman6> i need to move my server to using lighty is the frontend instead of apache some time
04:50:21 <vegai> this happened both when using forkIO and forkOS
04:50:30 <Axman6> atm, i'm using lighty for static content
04:50:36 <vegai> I'm tempted not to do a shared-nothing architecture web app
04:50:59 <vegai> it's gonna be agony if my app gets popular :P
04:52:23 <daoinall> sounds good vegai, what are you writing?
04:52:57 <vegai> it's silly. I'll finish it first :)
04:53:31 <daoinall> :)
04:55:09 * subconscious has written a regex matcher
04:55:35 <subconscious> don't know if it gives every match though
04:56:04 <Axman6> i'm playing with a primitive turing machine in haskell atm
04:56:06 <subconscious> can only assume
04:56:22 <Axman6> addition is harder than i thought it would be -_-
04:57:13 <Axman6> i'm struggling to even imagine how multiplication would work
04:57:34 <EvilTerran> Axman6, what's your tape alphabet?
04:57:38 <subconscious> Can you write subroutines in this turing thing
04:58:02 <Axman6> One, Zero, Star EvilTerran
04:58:19 <EvilTerran> that *would* make things tricky
04:58:21 <Axman6> subconscious: not really
04:58:29 <subconscious> there's your problem :p
04:58:45 <EvilTerran> you'd need a von neumann machine or similar to have subroutines, i guess
04:59:41 <Axman6> each action returns an Action type, which is A writethis LorR nextinstruction
05:00:01 <EvilTerran> nextstate, surely?
05:00:08 <Axman6> that's passed to the move function along with the current tape
05:00:27 <Axman6> well, that too :P
05:00:47 <EvilTerran> is your tape infinite in both directions?
05:00:52 <Axman6> yep
05:01:00 <EvilTerran> haskell makes that deliciously easy :)
05:01:10 <EvilTerran> it's a zipper!
05:01:18 <Axman6> data Tape = T [Ticket] Ticket [Ticket]
05:01:37 <Axman6> bah, writing this from scratch ;)
05:02:32 <EvilTerran> btw, unary numbers may be a bit easier than binary
05:02:38 <EvilTerran> if sillier
05:02:54 <EvilTerran> adding becomes fairly trivial, anyway
05:02:57 <Axman6> i was thinking of doing it using hex actually
05:04:30 <ejt> quicksilver: do you still have that FRP code you were playing with last week available somewhere ?
05:04:56 <Axman6> bah, this keyboard's so silly
05:05:07 <Axman6> it has three control keys
05:05:15 <quicksilver> ejt: sure
05:05:30 <quicksilver> ejt: conal's is almost certainly better, though ;)
05:06:00 <ejt> yours was smaller though I suspect ...
05:06:18 <ejt> just reading one of Conals papers now
05:06:37 <quicksilver> ejt: yes, it's a single file
05:06:42 <quicksilver> doesn't necessarily make it better :)
05:07:10 <ejt> can you paste the url again please ?  I'd like to read it again
05:07:41 <quicksilver> I'm just checking it's in a working state
05:08:06 <quicksilver> ejt: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=61#a61
05:08:12 <ejt> great, thanks
05:18:08 <subconscious> @w80 noetherian
05:18:11 <lambdabot> No match for "noetherian".
05:19:27 <ivanm> with haddock doccumentation, how does one classify stability and portability?
05:21:23 <subconscious> ‚ô™ let f91 n = if 100 < n then n - 10 else f91 (f91 (n + 11)) in map f91 [1..]
05:21:27 <lunabot>  [91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,...
05:24:47 <vincenz> > 1
05:24:48 <lambdabot>   1
05:25:07 <ivanm> you needed lambdabot to evaluate _that_ for you? :o
05:25:17 <vincenz> ivanm: no
05:26:08 <Beelsebob> > 2
05:26:09 <lambdabot>   2
05:26:17 <vincenz> ivanm: it's a way to check whether eval on lambdabot works
05:26:29 <Axman6> or echo at least
05:26:30 <pjdelport> > buckle "shoe"
05:26:31 <lambdabot>   mueval: Prelude.read: no parse
05:26:38 <zachk> what are some good books on haskell, or do any of you recommend structure and interperation of programming (SICP)
05:27:29 <ivanm> RWH, craft, SoE
05:27:35 <jeffz> http://haskell.org/haskellwiki/Books
05:27:38 <lambdabot> Title: Books - HaskellWiki
05:27:57 * ivanm still can't find a copy of the matroid book anywhere near him :(
05:28:28 <RayNbow> > succ 0
05:28:29 <lambdabot>   1
05:29:27 <moshisushi> anyone using ghci within emacs?
05:29:43 <jeffz> moshisushi: yes
05:29:47 <moshisushi> i wonder how to move up in the history
05:29:52 <jeffz> moshisushi: M-x ansi-term
05:30:00 <ivanm> moshisushi: ctrl+up
05:30:17 <ivanm> that will scroll through previous commands
05:30:18 <moshisushi> ah that easy
05:30:20 <moshisushi> :)
05:30:21 <ivanm> yup
05:30:30 <jeffz> if you use M-x ansi-term, readline enabled apps just work. along with being able to run various other programs, including inferior editors.
05:30:33 <ivanm> though I wish it had previous command completion :(
05:30:47 <ivanm> jeffz: but why would you want to run inferior editors?
05:30:56 <ivanm> when you're running the One True Editor? :p
05:31:14 <jeffz> ivanm: I don't, but it's capable of doing so.
05:32:29 <moshisushi> that's my snd question.. no tab-completion whatsoever?
05:32:41 <ivanm> moshisushi: don't think so :(
05:33:29 <ivanm> and C-tab, C-c tab, C-c C-tab don't seem to do anything
05:33:50 * jeffz doesn't want to repeat himself, but M-x ansi-term - tab completion works fine
05:34:47 <ivanm> jeffz: yes, but does C-c C-l work with that?
05:34:50 <moshisushi> jeffz hm ok well
05:35:06 <moshisushi> jeffz: but thats just a plain old terminal..
05:35:37 <jeffz> ivanm: no idea, I don't use it.
05:37:26 <subconscious> can't decide to use haskell or lambda prolog
05:38:33 <mmorrow> apparently ghc has a 65856 line limit on hs src files :(
05:38:39 <ivanm> mmorrow: :o
05:38:44 <subconscious> that's worse than java!
05:38:45 <subconscious> :P
05:39:03 <ivanm> I'm not sure what surprises me... that it has a line limit, or that you need a file longer than that limit! :o
05:39:12 <mmorrow> heh
05:39:25 <subconscious> hey mmorrow
05:39:28 <mmorrow> they must be using Word16s or some such nonsense
05:39:34 <mmorrow> hey
05:39:37 <subconscious> Have your ead that type theory should eat itsself paper?
05:40:02 <mmorrow> i've gone over it, but haven't sat down yet and actually understood it
05:40:08 <mmorrow> have you?
05:40:17 <Beelsebob> subconscious: a type inferrer implemented in its own type system?
05:40:47 <mmorrow> Beelsebob: i hesitate to summarize, since i'm not quite sure the punchline yet, but it looks very interesting
05:41:40 <ivanm> hmmmm..... the wiki mentions a cabal-mode for emacs, but the link goes to a domain squatter...
05:41:50 <subconscious> well I think they are going to do a type checker, which means they must also implement evaluation, which means they .. prove the logic is consistent in itsself -- this is confusing because I (a layperson) thought that was impossible by godels stuff
05:41:51 <ivanm> anyone have a copy of this? (or is it now included in haskell-mode?)
05:42:00 <subconscious> but maybe it's just that you can't rely on the proof or something ? I don't know really
05:43:22 <subconscious> btw I think the code they present in the paper doesn't have a termination proof but they intend to write one
05:44:15 <zachk> do any of you recommend programming in haskell for a cs undergrad?
05:44:46 <Axman6> zachk: very much so
05:45:04 <subconscious> zachk: oh no! You must have a PHD at _least_
05:45:16 <zachk> subconscious: hehehe
05:45:22 <ilyak> zachk: Why not?
05:45:48 <zachk> ilyak: englishval: No Parse
05:45:51 <mmorrow> although i've never fully gone over what it's actually saying, i have a feeling that godels incompleteness stuff isn't necessarily "the case" if you're working in other systems/with different assumptions about things/a different definition of "completeness" entirely...something like that
05:46:02 <subconscious> mmorrow: I got a new addiction, http://www.cs.nott.ac.uk/%7Etxa/publ/
05:46:03 <lambdabot> Title: Thorsten Altenkirch's drafts and publications
05:46:05 <subconscious> great papers !
05:46:15 <mmorrow> hehe, /me looks
05:47:06 <mmorrow> what's the link for that eat itself paper again. just tried to google it for Beelsebob, but it wasn't on the first pages of like 4 different searches..
05:47:38 <zachk> mmorrow: i liked godel, escher, and bach my douglas r hofstader I believe, basically you can come up with a number that encodes a false statement that is a true statement in the system you are using, it leads to a hole in any formal system, you can plug the hole, but then there will be a new hole, this is in any formal system complicated enough to do basic math proof's in
05:47:40 <subconscious> http://www.cs.nott.ac.uk/~jmc/Publications_files/lfmtp08_jmc.pdf
05:47:40 <Axman6> zachk: if you're really interested in Cs, there's a good chance you'll fall in love with haskell, and go and get your PHD by writing something awesome in it ;)
05:47:41 <lambdabot> Title: Type Theory should eat itself
05:48:28 <osfameron> good title!
05:49:06 <ivanm> Axman6: I'm not sure if my intended PhD will let me use haskell :(
05:49:13 <ivanm> maybe for code generation, but that's about it :s
05:49:18 <mmorrow> zachk: hmm, i have that book somewhere, i should take a look.
05:49:24 <zachk> axman6: C has always turned me off, i did scheme for awhile but i was getting anywhere in making "real programs", so i tried haskell
05:49:28 <Axman6> ivanm: what do you want to do?
05:49:42 <mmorrow> zachk: so, am i correct in this rephrasing of what you just said? ....
05:50:07 <ivanm> Axman6: I'm going to apply to uni of edinburgh for a combinatorial optimization project
05:50:16 <ivanm> on supercomputers, so it'll probably be C/Fortran
05:50:32 <Axman6> heh, fun
05:50:43 <ivanm> yeah
05:50:55 <Axman6> ghc --via-C >_>
05:50:57 <zachk> mmorrow: i dont see a rephrasing. if you have a formal system that isnt a toy, it will have a hole.
05:52:15 <subconscious> ivanm: -funroll-loops!
05:52:19 <zachk> mmorrow: the book uses a quite weak system to prove the godel incompleteness theorem, i got lost in the math by not doing the exercises, but got the gist of the book
05:52:34 <ivanm> subconscious: hmmmm? what, that I use gentoo?
05:53:00 <ivanm> Axman6: yeah, or the new Lang.C (or whatever the library is called)
05:53:17 <ivanm> Axman6: because last I checked, --via-C didn't output C code...
05:53:33 <Axman6> yeah, there is a way though, i think
05:55:29 <mmorrow> fix A. a /statement/ is a map f : A -> {True,False}. so let FA := { f |f : A -> {True,False}}. so you're saying there exists some sort of mapping  F : FA -> FA s.t. there exists an f `elem` FA for which f(s)=False, but F(f)(s)=True?
05:55:52 <mmorrow> A is "whatever"
05:56:29 <mmorrow> i guess just suppose it's a Set of "statements"
05:58:09 <mmorrow> so really all that says is
05:58:11 <mmorrow> True <--f-- s --F(f)--> False
05:58:30 <mmorrow> what is this F is what i don't understand
05:59:02 <ivanm> anyone here familiar with pandoc?
06:00:47 <mmorrow> i suppose the f there is the "mapping from statements to truth given the current context" or something
06:01:06 <mmorrow> so then F is a map of contexts
06:01:19 <mmorrow> hmm
06:21:03 <Axman6> bloody hell ghc takes a long time to compile on a G5
06:21:18 <Axman6> been at it for a good two hours so far
06:22:22 <MyCatVerbs> Axman6: go play some Quake. :)
06:22:53 <opqdonut> wow
06:22:56 <Axman6> that'll a) make it take longer and b) be very painful -_-
06:24:33 <mmorrow> i remember someone had a shell cmd to clear you cache. does anyone recall it (or an equiv)?
06:24:39 <mmorrow> s/you/your/
06:41:52 <Botje> which cache?
06:44:50 <mmorrow> cpu
06:45:05 <ivanm> mmorrow: run lots of garbage calculations?
06:45:29 <mmorrow> hmm, i guess that's easy enough
06:48:21 <Deewiant> might not necessarily clear it though
06:48:45 <Deewiant> unless it's literally the only program you're running
06:48:56 <Deewiant> the only 100% certain way is to shut down your computer
06:49:04 <Axman6> MyCatVerbs: write a really efficient kernel
06:49:15 <Axman6> uh, mmorrow
06:49:53 <MyCatVerbs> Axman6: yeah, okay. I need to do that for a coursework assignment later this year anyway... ;)
06:52:48 <mmorrow> Axman6: uh hai
06:53:07 <Axman6> the kernel thing was fot you
06:53:09 <Axman6> for*
06:57:05 <tibbe> I need a paper for the gym, any suggestions?
06:57:58 <ivanm> something that's sweat-absorbent?
06:58:09 <tibbe> ivanm: yes :)
06:58:55 <ivanm> well, I have no idea which brands of paper towel are available wherever you live... :p
06:59:01 <tibbe> :p
06:59:08 <tibbe> I want a Haskell branded one
06:59:52 <ivanm> lambdaConst paper! absorbs any parameter you care to pass in! :p
07:12:05 <sebaseba_> anyone using Aquamacs with haskell-mode?
07:12:45 <sebaseba_> default fonts aren't monospace, having alignment problems...
07:13:19 <Beelsebob> no idea about that -- I just use SubEthaEdit on OS X
07:22:45 <xsdnyd> hi
07:23:17 <xsdnyd> is it possible to implement a Show instance of a datatype with an additional parameter?
07:23:53 <xsdnyd> data MyData = Red | Blue    \n instance Show MyData Int where ....
07:23:55 <xsdnyd> like this
07:24:58 <ziman> afaik, no. what's the purpose?
07:25:00 <Baughn> xsdnyd: Er? What are you trying to do there, exactly?
07:25:01 <Saizan> what should that do?
07:27:39 <quicksilver> sebaseba_: aquamacs is the work of the evil one, sent to lead you from the true path.
07:27:54 <quicksilver> sebaseba_: use carbon emacs and your soul is safe.
07:27:57 <xsdnyd> ok i have this data Container = Cont { items: [Item] , ...}  data Item = Item { name : String, ...}, If i "show" the Container it calls show and each item and intersperses with "\n". so far so good. but the show function  of an item needs information from the container to show some things. so i have to have access to the container from the show function of the items.
07:28:08 <quicksilver> that's not what show is for.
07:28:10 <quicksilver> don't use show for that.
07:28:16 <xsdnyd> but i guess i just have to implement a function itemToString :: Container -> Item -> String...
07:28:20 <quicksilver> yes.
07:28:26 <xsdnyd> ok :-/
07:28:30 <xsdnyd> thx anyway
07:28:57 <sebaseba_> quicksilver: hard to lose the Mac keyboard shortcuts
07:29:03 <quicksilver> sebaseba_: which ones?
07:29:14 <quicksilver> (for example)
07:30:03 <sebaseba_> Command-Z/X/C/V ?
07:30:14 <sebaseba_> yes blasphemy, I know
07:30:38 <quicksilver> that is blasphemy.
07:30:55 <quicksilver> The reason that aquamacs' idea is flawed is that there is internal consistency in emacs shortcuts.
07:31:04 <quicksilver> By changing just a couple of them, you break that consistency
07:31:29 <quicksilver> if you wanted a different set of keybindings, you'd want to change every keybinding in every mode you ever used.
07:31:42 <quicksilver> and then ignore all the documentation on the 'net which helpfully uses default keybindings.
07:31:50 <quicksilver> to be honest, it's best to just suck it up and learn the defaults :P
07:32:01 <sebaseba_> well aquamacs doesn't change them as far as I know. It keeps the original emacs bindings with Ctrl and Alt, and retains the Mac bindings that use Command
07:32:02 <Baughn> The A-foo modifier is unused by default, isn't it?
07:32:29 <Baughn> But yes, I'd rather get rid of osx-mode-map entirely. If it annoyed me slightly more, I'd do just that; as it is, I'm mostly overriding it.
07:32:44 <Baughn> Having A-o as "switch to other buffer" is handy, for example
07:33:08 <Baughn> Or A-r. Load current buffer into whatever interpreter is appropriate for its type.
07:33:44 <sebaseba_> Also, I like Command-` to switch to other Aquamacs windows, like in all Mac applications
07:33:47 <quicksilver> sebaseba_: emacs doesn't have any original keybindings on Alt.
07:33:53 <quicksilver> as far as I recall.
07:33:58 <quicksilver> certainly no common ones.
07:34:08 <sebaseba_> quicksilver: Meta, then?
07:34:09 <quicksilver> they're on 'Meta'; which leaves you the choice where to assign Meta
07:34:12 <Baughn> Alt? What alt? My keyboard has no alt.
07:34:18 <quicksilver> I assign Meta to command as god intended.
07:34:33 <quicksilver> Because option (aka alt) is needed as a character entry key.
07:34:36 <ehtom> macs...
07:34:56 <quicksilver> ehtom: Hardware wise, this is my only complaint about the mac: too few modifier keys.
07:34:59 <quicksilver> One more and I'd be happy.
07:35:14 <Baughn> Well, there's esc..
07:35:29 <ehtom> not that i'm meaning to start a troll war, but don't you find the hardware *slightly* overpriced?
07:35:39 <quicksilver> ehtom: not when I bought it, no.
07:35:56 <quicksilver> when I bought my iBook G4 for 700GBP, it was extremely competitive with other good quality laptops at the time
07:35:59 <sebaseba_> ehtom: me neither
07:36:00 <quicksilver> (september 2005)
07:36:00 <Baughn> ehtom: I have a tendency to destroy laptops. Theirs hold up well.
07:36:28 <quicksilver> I've also had bad experiences in the past getting linux to work well with obscure bits of laptop hardware.
07:36:39 <quicksilver> (and obviously I never considered windows as an option)
07:36:59 <ehtom> Baughn: what about vaio's? (not that they're well priced either though :P )
07:37:04 <quicksilver> admittedly the bottom has fallen out of the laptop market and it's much harder to justify apple's prices today.
07:37:05 <Baughn> Yep. OS X has the happy conjunction of decent software and good hardware support
07:37:12 * BMeph wishes he could find a more reasonably-priced laptop with a Lexan(R) shell...
07:37:37 <Baughn> ehtom: They don't sell here in norway. Here, we get the option of (a) apple laptops, or (b) odd norwegian-branded laptops that usually have badly supported innards
07:37:38 <BMeph> ehtom: VAIOs are teh suck.
07:37:43 <Baughn> Well, or thinkpads
07:37:49 <Beelsebob> quicksilver: the MacBook is really rather nicely priced -- although admitedly the MacBook Pro is somewhat ludicrously expensive
07:38:22 <Beelsebob> you can get the same specs as the MacBook for much less money -- but you can't get the same specs in the same sized box cheeper
07:38:34 <quicksilver> Beelsebob: well a bottom end macbook is stil 700 GBP, exactly as it was 2 years ago.
07:38:45 <quicksilver> but you can get a pretty decent HP laptop for 400.
07:38:53 <quicksilver> apple haven't adjusted to the market.
07:38:55 <Beelsebob> yep, but it's huge in comparison
07:39:02 <quicksilver> [they probably don't need to, to be fair]
07:39:16 <quicksilver> 3 years ago, I can't count.
07:39:21 <ehtom> I haven't studied their laptops in detail (I dont buy laptops), but when I was looking at their desktops their best non-xeon desktop was ¬£1700... it was only a dual core with 2GB ram with the "option" to upgrade to 4GB for ¬£120 (~$220)
07:39:32 <Beelsebob> dell's is still ¬£750 (and is the same size), sony's is ¬£900
07:39:33 <Baughn> quicksilver: "which ls => /sw/bin/ls" - Does this look familiar?
07:39:43 <quicksilver> ehtom: their topup is ridiculously overpriced.
07:39:49 <Baughn> ehtom: Their memory is horribly overpriced, yes. Don't buy from them.
07:39:49 <quicksilver> ehtom: top-end, I mean.
07:40:01 <quicksilver> ehtom: comparing their bottom-end is more interesting.
07:40:12 <quicksilver> cheapest iMac is 800 GBP, and that's quite a nice machine for 800.
07:40:19 <quicksilver> although you can certainly get something cheaper.
07:40:24 <Beelsebob> the MacPro is ludicrously cheep as well
07:40:30 <ehtom> quicksilver: its not a top end machine though... for ¬£1700 I would expect a QX10000 and 3 graphics cards
07:40:41 <quicksilver> ehtom: as I say, the top end is horrendously overpriced.
07:40:42 <Beelsebob> the CPUs in it are worth the same amount as the entire machine
07:40:54 <quicksilver> ehtom: I do not attempt to justify those prices, it's madness.
07:41:07 <Beelsebob> ehtom: bear in mind that ¬£1000 of that price is for a really fucking good S-IPS screen
07:41:30 <daoinall> I ... think ... I'm ... starting ... to ... get ... Monads ...
07:41:33 <quicksilver> the bottom end of each range is where you get the reasonably good deal.
07:41:34 <quicksilver> daoinall: \o/
07:41:38 <opqdonut> :)
07:41:49 <Baughn> daoinall: You're wrong, but good luck anyway. :P
07:41:57 <Beelsebob> quicksilver: I'd even argue that the top end iMac is a very good deal, given how much the screen in it is worth
07:42:08 <luite> for me, the main problem with apple is the lack of mi range desktops (in terms of speed/expandability), there's a huge gap between the imac and mac pro
07:42:14 <ehtom> I dont think any screen is worth ¬£1000
07:42:24 <daoinall> hmm ... actually ... maybe ... not
07:42:29 <Baughn> For that matter, the macbook pro screen is a *lot* better than anything I've seen in cheap notebooks. Of course, it isn't cheap.
07:42:42 <Beelsebob> ehtom: no, not quite, dell is selling it for ¬£800
07:42:48 <ehtom> beelsebob: what's the mac that you think is a good deal?
07:42:48 <Beelsebob> (same panel)
07:43:00 <ehtom> good for dell... still wouldn't buy it
07:43:12 <ehtom> you can pay as much as you want for whatever you want
07:43:22 <Beelsebob> you haven't seen it then ehtom -- S-IPS screens are bloody expensive but also bloody good
07:43:29 <quicksilver> Beelsebob: not quite true about the xeons in the mac pro. But they probably do constitute about half the retail cost.
07:43:45 <quicksilver> ehtom: well that depends if you want it or not.
07:43:46 <luite> hm, I don't think the new imacs are s-ips anymore?
07:43:53 <mmorrow> heh, re flushing the cache: http://www.rtlinux-gpl.org/mailing_list/rtl.w5archive/0103/msg00133.html
07:43:54 <Beelsebob> quicksilver: the Xeon X5462 costs $1200, the standard MacPro has 2 of them and costs $2800
07:43:54 <ehtom> what does a s-ips screen do that normal screens don't?
07:43:54 <quicksilver> nobody's saying you have to like the screens :)
07:43:58 <lambdabot> Title: Re: [rtl] Disabling cache w/ CR0 bit 30, WBINVD: anyone have code?, http://tinyurl.com/5xjltv
07:44:07 <mmorrow> and a Makefile
07:44:08 <mmorrow> http://www.captain.at/programming/kernel-2.6/
07:44:14 <Beelsebob> ehtom: much much better color reproduction, much better contrast ratio, and much better viewing angle
07:44:16 <lambdabot> Title: Linux Kernel 2.6 - Compile Modules
07:44:31 <Beelsebob> like -- the colours are still identical at 170¬∞, not it's still readable at 170¬∞
07:45:11 <sebaseba_> quicksilver: I fixed the font thing myself. Thanks for the evangelism effort, but I'm sticking with what I like :)
07:45:35 <ehtom> beelsebob: sounds nice I admit
07:46:08 <Beelsebob> ehtom: you really need to see one to realise how good they are -- it's rather unfortunate that the low end iMacs don't have the same quality screens :(
07:48:24 <quicksilver> Beelsebob: I see xeon " E5462 Harpertown Core, 2.80GHz, FSB 1600MHz, 12MB Cache"s for GBP 540.66 each
07:50:01 <Beelsebob> ohh, they've come down a little, still, thats 2/3 of the cost of the machine tied up *just* in the CPUs
07:50:01 <Baughn> Beelsebob: Are they 18 or 24bpp, though?
07:50:11 <Beelsebob> Baughn: on the 24" ones, 24 bit
07:50:19 <Beelsebob> on the 20", 18 bit
07:50:21 <Beelsebob> which is lame
07:50:35 * Baughn wonders what his laptop uses
07:50:39 <ehtom> which machine are we talking about?
07:51:02 <mc__> is the macbooks display 18 or 24bpp?
07:51:10 <Baughn> That's what I'd like to know
07:51:12 <Beelsebob> 18, the MBP is 24bit
07:51:20 <mc__> every mbp?
07:51:22 <Beelsebob> yep
07:51:27 <Baughn> Even the first edition?
07:51:40 <Beelsebob> yep, the first edition MacBooks even were 24 bit
07:51:54 <Baughn> I've got a first-gen and a third (fourth?)-gen mbp here now. The latter seems to have much better visuals.
07:52:17 <mc__> i have a 3. edition macbook too and the display is great IMHO
07:52:25 <Beelsebob> backlight dying?
07:52:41 <Baughn> Beelsebob: More like born bad
07:52:51 <Beelsebob> lame :(
07:53:16 <Baughn> That said, *everything* about the newer one is better than the older. Which is still better than the even older, non-apple laptop, so..
07:53:29 <Baughn> Probably just the march of progress being all marchy
07:53:30 <quicksilver> 18bit displays really aren't that bad.
07:53:35 <quicksilver> the timewise dithering works well.
07:53:40 <Beelsebob> quicksilver: depends what you're doing with them
07:53:55 <Beelsebob> given that apple sells a lot of machines to artists and publishers, it's not that great
07:53:56 <quicksilver> You have to be a colour professional or someone very observant/bothered by such things for it to worry you.
07:54:08 <Baughn> quicksilver: Or just watch a lot of videos
07:54:16 <ehtom> what kind of a server can you buy for $5000?
07:54:27 <Baughn> One with lots of HDs. :P
07:54:27 <papermachine> The 80/20 rule applies to monitors as well.
07:54:28 <Beelsebob> Baughn: if you're seeing things like blacks not being black enough it's more likely a problem with contrast ratio
07:54:37 <Baughn> ehtom: Really depends on what you want
07:55:01 <palmerc> mmorrow: Having proved you can translate my Tree to the Data.Tree, I am now trying to do it the hard way
07:55:25 <quicksilver> ehtom: if your objective is maximum processing power you can probably get a 16 or 24-core rig for that
07:55:34 <quicksilver> although I'm not sure how expensive those motherboards are.
07:55:38 <ehtom> yes
07:55:39 <quicksilver> Not my normal shopping list ;)
07:55:58 <Baughn> You could get a much more powerful cluster for cheaper, but of course you have to structure your programs differently
07:56:17 <ehtom> so I was thinking... a mac pro costs $5k with no display, a ok ish graphics card and 1TiB HDD
07:56:26 <Beelsebob> ehtom: uh?
07:56:33 <Baughn> Or five or six tiny computers with weak dual-core processors, each with two 8800GT GPUs...
07:56:35 <Beelsebob> the MacPro costs $2.9k for that
07:57:02 <Beelsebob> unless you put the ludicrously pricey super-high-clock CPUs in
07:57:15 <Baughn> ehtom: If you really want a stationary mac, I'd advise you to look at getting a hackintosh. Unless you're in one of the unfortunate countries where they're illegal.
07:57:43 <ehtom> *cough* xen </endcough>
07:57:47 <Beelsebob> in fact, $2.4k for what you're describing
07:58:55 <quicksilver> ehtom: you don't buy a mac pro if you want a server.
07:59:00 <quicksilver> ehtom: you buy a mac proc if you want a mac
07:59:09 <quicksilver> (probaly as a high-end workstation)
07:59:13 <quicksilver> if you want a server, you buy a server.
07:59:14 <ehtom> beelsebob: made a slight mistake, thought it said one cpu, not two
07:59:15 <Beelsebob> and you don't put a decent graphics card in it if you want a server either
07:59:18 <palmerc> mmorrow: http://pastebin.com/d3eb3a16a I believe the last line the (treeToString xs) is wrong. I should be passing a 'tree'
07:59:42 <Beelsebob> ehtom: even with 2 CPUs it's $2.9k
07:59:47 <Baughn> Beelsebob: Well, if you want lots of computing power..
07:59:54 <ehtom> beelsebob: how are you working that out?
08:00:17 <ehtom> beelsebob: one 2.8Ghz xeon, 4gb, 1TiB, 8800GT == $3.2k
08:00:24 <Beelsebob> ehtom: 2x2.8Ghz CPU, GeForce 8800, and buying a hard disk from someone who isn't apple, and hence doesn't charge anywhere near as much for an upgrade)
08:00:24 <palmerc> The mac pro is sweet
08:00:28 <Baughn> I wonder if it'd be possible to write a h.264 encoder in opencl?
08:00:42 <ehtom> beelsebob: haha
08:00:46 <palmerc> and it makes an incredible server
08:00:49 <Beelsebob> similarly, buy your RAM elsewhere -- apple's is ludicrously overpriced
08:00:55 <quicksilver> Baughn: I think encoding is not so data-parallel as decoding
08:01:07 <palmerc> Yeah, there RAM is totally overpriced
08:01:08 <quicksilver> Baughn: because encoding requires "surrounding information" to make difficult decisions.
08:01:17 <palmerc> their
08:01:19 <quicksilver> Baughn: I'm no expert though :)
08:01:36 <Baughn> quicksilver: No, you're quite correct. That might not be fatal, but it is an issue.
08:01:39 <ehtom> palmerc: umm... why not buy a proliant or something if you want a server?
08:02:09 <Baughn> quicksilver: There could be ways around it, like pre-processing for scene breaks and then feeding the gpu multiple scenes in parallel
08:02:15 <Beelsebob> 32GB for MacPro is $2000 from crucial, or $10000 from apple
08:02:19 <palmerc> Well I would tend to put my own together, but when you start talking equivalent hardware the price differential isn't that big of a deal
08:02:43 <quicksilver> Baughn: yes, I presume you'd break it up as some very multipass algorithm where each pass was highly data parallel.
08:02:54 <palmerc> I really prefer Apple support over anything else
08:02:57 <quicksilver> Baughn: x.264 encoding is also quite difficult, as far as I understand it.
08:03:13 <Beelsebob> palmerc: for a base MacPro it's pretty difficult to build the same for less -- the Xeon chips as quicksilver just found are ¬£550 each, the motherboard is ¬£500, and that's you already at ¬£1600 when apple's selling it for ¬£1700
08:03:24 <palmerc> exactly
08:03:33 <palmerc> my mac pro has dual xeon
08:03:40 <palmerc> and 10GB or RAM
08:04:02 <palmerc> and I priced the same hardware out using parts and it is hard to compete
08:04:04 <Baughn> quicksilver: h.264 does a lot of clever things, but it's still basically understandable. The next-generation codec attempts to reverse-engineer the movie into vector graphics.. the one after that, it'll be busily building 3d models and scene graphs
08:04:16 <ehtom> http://www.tigerdirect.com/applications/SearchTools/item-details.asp?EdpNo=3877303&Sku=CP1-XEON-E5430
08:04:18 <palmerc> the RAM though is crazy
08:04:22 <lambdabot> Title: Intel Xeon E5430 Processor BX80574E5430A - 2.66GHz, 12MB Cache, 1333MHz FSB, Har ..., http://tinyurl.com/4jopv2
08:04:28 <ehtom> thats a decent looking xeon for ¬£250
08:04:36 <ehtom> but I dont really know much about xeons
08:04:52 <palmerc> This Mac Pro has 2x 3.2GHz Quad-Core
08:05:45 <Baughn> quicksilver: Suffice to say, parallelising h.266 should be worthy of a PhD in itself
08:05:54 <maltem> Baughn: and the next one will deduce a physical model of the surroundings?
08:06:14 <quicksilver> maltem: the next one will deduce the viewers mental model of the movie
08:06:22 <quicksilver> maltem: AND PROJECT IT INTO HIS DREAMS!
08:06:33 <quicksilver> (capslock was accidental but I liked it so I didn't correct it)
08:06:49 <Baughn> Perceptual coding is old hat, though. :P
08:06:49 <maltem> heh
08:06:50 <Beelsebob> ehtom: the E5430 is a *lot* slower than the E5462
08:06:54 <Beelsebob> it's got a much slower bus
08:07:00 <ehtom> ok
08:07:08 <quicksilver> memory bandwidth is the big thing these days
08:07:13 <Beelsebob> we have a MacPro 4 core here, and an HP machine with the chip you just highlighted
08:07:14 <quicksilver> so you have to look for the fastest FSB
08:07:25 <quicksilver> (and big caches)
08:07:28 <Beelsebob> the MacPro beats the HP machine by 40% in benchmarks
08:07:48 <palmerc> quicksilver: big caches will only help to a point
08:07:54 <ehtom> what's h.266 btw?
08:07:54 <boyscared> i don't get why most programmers need a $3000 macbook pro
08:08:03 <quicksilver> palmerc: yes, it's heavily application dependent
08:08:09 <Beelsebob> ehtom: h264 is a video codec
08:08:13 <Beelsebob> a very very highly compressing one
08:08:14 <quicksilver> boyscared: they don't.
08:08:17 <boyscared> i wanted a laptop, so i bought a 10yr old thinkpad off ebay for $100
08:08:17 <quicksilver> boyscared: they want them :)
08:08:28 <quicksilver> especially when someone else is paying.
08:08:33 <Beelsebob> hehe, indeed
08:08:33 * quicksilver knows whereof he speaks.
08:08:34 <Baughn> ehtom: h.264 is the current video codec. h.265 is the hypothetical next-generation one. Therefore...
08:08:34 <boyscared> i can write haskell and lisp on it just as good :)
08:08:41 <ehtom> boyscared: yes, but say that I needed a new computer and my university offered to pay for it....
08:08:44 <quicksilver> I type this on a MBP I didn't pay for.
08:09:01 <mc__> quicksilver: you are a thief?
08:09:15 <Beelsebob> at a guess, a uni paid
08:09:17 <quicksilver> a professional thief, yes
08:09:20 <quicksilver> I work in finance
08:09:23 <Beelsebob> hahaha
08:09:25 <quicksilver> *rimshot*
08:09:28 <boyscared> the nice thing about my 800Mhz laptop is that i can actually use it on my lap without getting a sweaty crotch
08:09:33 <mmorrow> palmerc: maybe something like this? http://pastebin.com/m28beeb64
08:09:51 <ehtom> Baughn: I see
08:09:59 <ehtom> quicksilver: quant?
08:10:16 <quicksilver> ehtom: no, nothing so exotic.
08:10:21 <quicksilver> (or so lucrative)
08:10:26 <quicksilver> foreign exchange
08:10:30 <ehtom> ah
08:10:37 <maltem> boyscared: That's where I envy you (looking down on my Macbook pro, bought used)
08:11:26 <ehtom> maltem: eww
08:11:32 <mc__> is this just my expression or are really  of #haskell mac users?
08:11:43 * ehtom doesn't have a mac
08:11:44 <mc__> s/expression/impression
08:11:49 <opqdonut> some are
08:11:53 * ehtom has a sensible gaming computer
08:12:05 <quicksilver> mc__: there are lots of academics or ex-academics here
08:12:12 <mc__> I see
08:12:14 <quicksilver> and the mac has gained a lot of traction in academia recently
08:12:18 <boyscared> basically, i just needed something that ran emacs fast enough to be usable
08:12:23 <ehtom> lol
08:12:26 <quicksilver> I was a complete linux-head
08:12:34 <mc__> me too
08:12:38 <quicksilver> but when my boss bought me a laptop on a research grant
08:12:47 <opqdonut> x61t <3
08:12:51 <quicksilver> his systems department said that OSX was less hassle for them to support
08:12:56 <MyCatVerbs> quicksilver: I was... until I found Bezerkely. :)
08:13:00 <quicksilver> (as opposed to linux)
08:13:07 <quicksilver> so that was an iBook
08:13:11 <quicksilver> and it kinda sorta converted me.
08:13:11 <ehtom> opensolaris kernel is very nice
08:13:13 <mc__> quicksilver: so thats why you use os x? or did you start to love it like me?
08:13:19 <quicksilver> I don't really love it.
08:13:27 <quicksilver> bits of it piss me off something chronic
08:13:28 <boyscared> 10 yr old thinkpad + freebsd + xmonad :)
08:13:37 <quicksilver> but it gives me most of the things I want/need
08:13:41 <MyCatVerbs> boyscared: mmmmmm, vintage. :)
08:13:42 <mc__> quicksilver: everything sucks at least in one way
08:13:46 <ehtom> mc__: why not use err... xen + stuffs instead of a mac if you just want os x?
08:14:15 <mc__> ehtom: because I like the hardware too, especially the laptops
08:14:17 <ehtom> bsd... "the little unix that could"
08:14:30 <mc__> the macbook is really a decent machine and the price is fair
08:14:36 <palmerc> mmorrow: that is really close
08:14:43 <ehtom> mc__: ah yes, laptops
08:14:52 <quicksilver> ehtom: why do that?
08:15:01 <ehtom> mc__: I keep forgetting that everyone except me uses a laptop
08:15:03 <quicksilver> ehtom: sounds like hard work, fragile, and probably ilegal
08:15:12 <mc__> I'd never buy a mac pro or something like thas, but i have had a hackintosh for a while
08:15:16 <earthy> 2 things worthwile from berkeley, both of them ending in sd, and one probably had an influence on the other... wasn't that it?
08:15:34 <maltem> mc__: only pity being they forgot that Intel chips get hotter than the old Gn chips
08:15:42 <ehtom> quicksilver: well, nice thing about using something like xen is that you can run multiple oses together
08:15:45 <palmerc> What does the $ do?
08:15:55 <Deewiant> @src ($)
08:15:55 <lambdabot> f $ x = f x
08:16:00 <earthy> palmerc: it's application spelled out as an operator
08:16:01 <mc__> maltem: I never had any heat problems with my mb
08:16:10 <mc__> though it can get quite hot
08:16:20 <maltem> mc__: mb or mb pro?
08:16:27 <mc__> mb
08:16:45 <boyscared> i'll upgrade my laptop when they can make one that runs for 8hrs on one battery and doesn't make annoying fannoise (while at the same time not being a palmtop)
08:16:46 <maltem> ah, then you save the other heat sink, the nvidia
08:17:28 <mc__> boyscared: buy a thinkpad t-series
08:17:37 <boyscared> i already have a T21 :)
08:17:49 <mc__> some new models are said to run over 10 hours
08:17:54 <boyscared> really?
08:18:02 <Deewiant> my r60 runs for about two hours
08:18:20 <mc__> boyscared: yeah, I cant recall exactly which model it was though
08:18:31 <quicksilver> ehtom: yes, that would be nice, but it is all hard work
08:18:35 <quicksilver> ehtom: I just have multiple computers
08:18:45 * quicksilver eyes the windows box to his right which is only used for testing IE6
08:18:51 <boyscared> i'll look into that, but it sounds like that can't be right
08:19:27 <palmerc> mmorrow: This version runs, after a couple of edits and provides desired output! http://pastebin.com/d4394839b
08:19:42 <maltem> quicksilver: you maintain an extra box just to be able to run IE?
08:20:10 <quicksilver> maltem: no, someone else maintains it.
08:20:13 <ehtom> quicksilver: well, getting windows to run properly on xen was a massive task
08:20:19 <quicksilver> maltem: that's what minions are for isn't it?
08:20:20 <maltem> heh ok
08:20:50 <ehtom> quicksilver: I had to screw around with so much stuff... worth it though: passmark gave 500 for VirtualBox, 700 for KVM and 1600 for XEN
08:21:13 <quicksilver> ehtom: virtualisation is a very interesting thing to play with in its own right.
08:21:22 <quicksilver> ehtom: but it isn't necessarily the simplest way to solve a particular problem.
08:21:41 <quicksilver> It's probably cheaper for my employers to buy a bottom-end dell desktop than to pay me to spend the time to get win32 running under xen :P
08:22:04 <ehtom> quicksilver: yeah, but what if you're compiling for that windows machine
08:22:10 <quicksilver> hmm.
08:22:15 <quicksilver> I'd seriously consider suicide.
08:22:21 <ehtom> slow computer = fail for compiling
08:23:24 <earthy> boyscared: ever looked at a dell latitude e6400... said to run for 19 hours.
08:24:26 <quicksilver> ehtom: in fact, I'd like to find the time to play with xen, but it's never quite at the top of my list.
08:27:08 <ehtom> xen is fast, but thats about all its got
08:28:37 <ehtom> the commercial version comes with a nice gui though, so I'm told
08:29:16 <PeakerWork> quicksilver: what are your conclusions about Reactive? Did you write some (preferrably graphic/visual) examples with it?
08:29:42 <mc__> how does it compare to yampa?
08:30:25 <PeakerWork> mc__: I think its supposed to be more functional.. Yampa does indeed have state and even exposes the sampling rate to that stateful code
08:30:31 <PeakerWork> mc__: I think Reactive avoids that
08:30:46 <PeakerWork> mc__: Also, it uses Applicative and not Arrows, I think
08:30:57 <mc__> I wonder how it solves certain problems then
08:30:59 <ehtom> has anyone here used CUDA on a 8800GT?
08:31:13 <PeakerWork> I thinks it also uses future values instead of streams (Not sure if Yampa indeed uses streams though)
08:31:42 <mc__> how would one could a non-trivial game without state?
08:31:53 <Beelsebob> ehtom: I've briefly played with it
08:32:02 <ehtom> beelsebob: how fast is it?
08:32:18 <Beelsebob> ehtom: euhm... depends what you're trying to do
08:32:29 <palmerc> mmorrow: to go from stringToTerm I think I need three cases. Empty string, AlphaNum, and Parens
08:32:30 <Beelsebob> if you mean how fast is it compared to a current gen card, then not that bad
08:32:43 <Beelsebob> the 8800 isn't that slow compared to them
08:32:47 <ehtom> its gonna be solving a system of pde's basically
08:32:50 <quicksilver> mc__: of course the game still has state
08:32:56 <Beelsebob> (it's a bit faster than a 9600, and a bit slower than a GTX260)
08:33:01 <quicksilver> mc__: it's just you don't use it in a stateful way.
08:33:06 <quicksilver> it's an approach, that's all
08:33:10 <quicksilver> (a good approach)
08:33:20 <mc__> yeah, but I dont quite get it :)
08:33:34 <quicksilver> PeakerWork: well, I have a totally trivial openGL example which just rotates a cube in response to keypresses
08:33:45 <quicksilver> PeakerWork: I'm trying to decide what to tackle next.
08:34:08 <quicksilver> mc__: the key thing we try to avoid is explicit passing of state, and explicitly 'updating' state and so on
08:34:10 <ehtom> beelsebob: I''m just trying to work out if its gonna be worth the bother to code this thing for cuda... only want to do that if its going to be quite a bit faster than my q6600
08:34:13 <quicksilver> because that is error prone.
08:34:23 <quicksilver> so if your core state is 'GameBoard'
08:34:30 <PeakerWork> quicksilver: does it work with cabal-gettable Reactive?
08:34:36 <PeakerWork> quicksilver: or the darcs repo?
08:34:36 <quicksilver> then instead of State GameBoard you use
08:34:40 <quicksilver> Behaviour GameBoard
08:35:03 <quicksilver> PeakerWork: No, because I use my own IO adapters
08:35:09 <quicksilver> which relate to my precise implementation
08:35:15 <Beelsebob> ehtom: depends what you're doing -- it's fairly hard to write good CUDA code, and it needs a massively parallel task
08:35:34 <PeakerWork> quicksilver: can you post the code somewhere so I can learn from it?  Perhaps in a form that is compile-able?
08:36:47 <ehtom> beelsebob: hmm... just found out that the 8800gtx has a max performance of 200 gigaflops... q6600 is significantly higher iirc
08:37:08 <ehtom> so I guess its not worth it unless I had a tesla or quadro card
08:37:15 <Beelsebob> ehtom: uh, you're unlikely to find a CPU that has anywhere near the performance of a GPU in terms of raw gigaflops
08:38:02 <Beelsebob> ehtom: current (very) high end CPUs are around the 20gflop mark
08:38:15 <ehtom> ok
08:38:16 <Beelsebob> so 200gflops is likely to give you a good speed up if you can actually use it
08:38:30 <quicksilver> slightly easier said than done, though :)
08:38:41 <quicksilver> enjoyable exercise, if you like that kind of thing.
08:38:53 <Beelsebob> indeed
08:38:55 <ehtom> massively parallel isn't gonna be a problem for this thinger - its sort-of a quantum mechanical fluid dynamics problem
08:39:11 <ehtom> i'll write some sort of semi prototype and see how it goes
08:39:12 <ehtom> thanks
08:42:13 <quicksilver> PeakerWork: I really don't htink it's a very interesting example, because the boiler-plate exceeds the interesting reactive part.
08:42:24 <mc__> quicksilver: and what would that behaviour do? how would it work?
08:42:39 <quicksilver> mc__: a Behaviour is intuitively like a time function.
08:42:51 <quicksilver> it means "this GameBoard varies over time"
08:43:03 <quicksilver> and you build up this time-varying value by combining other time-varying values
08:43:08 <quicksilver> and discretely-occuring values
08:43:25 <quicksilver> so it's a nice system of high level combinators (hopefully nice!)
08:43:49 <quicksilver> which are more compositional than standard approachs
08:43:53 <mc__> doenst yampa work the same?
08:44:02 <quicksilver> in broad brush-strokes yes, it works the same
08:44:12 <quicksilver> I'm not in a position to compare, I've never used yampa
08:44:17 <quicksilver> Beelsebob maybe can compare?
08:46:24 <Beelsebob> mc__: yampa is really not very nice and compositional
08:46:36 <Beelsebob> it enforces a very sequential style too thanks to arrows
08:47:02 <Beelsebob> it has some other problems too -- like the timer for recalculating stuff being tied to the display timer
08:47:14 <Beelsebob> this results in bad euler integration, and strictness prolems
08:47:32 <Beelsebob> (you need to strictify everything to be able to get it computed fast enough on the frame pass)
08:47:50 <Beelsebob> in general, I find reactive encourages a functional style much more, and usually ends up with simpler, better code
08:48:18 <mc__> what is euler integration?
08:48:18 <quicksilver> mc__: it would be nice to have more example reactive code out there so people can get a better feeling.
08:48:22 <quicksilver> which is why I'm writing some
08:48:30 <quicksilver> well, mainly for my own purposes
08:48:36 <quicksilver> but I hope other people will find it interesting.
08:48:38 <subconscious> mc__: It's not Runge Kutta
08:49:38 <mc__> I'll do a project for school this year, in haskell and I'd like to use something like yampa or reactive but I'm not yet sure which to choose, yampa offers better documentations thats really an advantage right now
08:49:59 <mc__> so I'd really appreciate you producing examples :)
08:50:45 <Beelsebob> mc__: euler integration is faked integration based on computing the area under the curve f as being sum (f x * timeIntervalSinceLastX)
08:51:10 <mc__> Beelsebob: thank you
08:51:32 <quicksilver> icfp-- # publishing results as a google video? What is the world coming to.
08:51:44 <osfameron> I guess it's laziness
08:51:46 <quicksilver> next time the results will be a flash app within a facebook application?
08:51:57 <osfameron> I hope they post proper results in some readable format soon too
08:52:00 <roconnor> link?
08:52:02 <subconscious> web 3.141
08:56:02 <quicksilver> roconnor: http://video.google.com/videoplay?docid=-4697764813432201693
08:56:03 <lambdabot> Title: ICFP programming contest 2008
08:59:26 <Deewiant> ?karma icfp
08:59:26 <lambdabot> icfp has a karma of -1
08:59:48 <Deewiant> I hoped they'd release they slides separately, maybe they will yet
09:00:28 <dblazakis> the slides are hard to read in the blocky video coding, i hope they release the slides sometime
09:00:38 <Deewiant> exactly
09:00:40 <subconscious> does anyone have a unification monad
09:00:41 <subconscious> ?
09:00:47 <subconscious> for first order term unification
09:02:46 <EvilTerran> subconscious, isn't that a noncomputable problem in general?
09:03:32 <EvilTerran> er, undecidable's the normal word, but still
09:05:48 <quicksilver> I don't know what subconcious means
09:06:04 <quicksilver> but you could certainly "store" variable : type judgements inside a monad
09:06:14 <quicksilver> that kind of thing is one of the poster-children that SPJ uses for monads.
09:06:36 <osfameron> the "this variable is very naughty and will not get any supper" monad ?
09:08:10 <Jaak> instance NaughtyBits [CENSORED] where
09:09:04 <Botje> giggle
09:10:20 <subconscious> ok then
09:19:49 <geezusfreeek> i love you
09:19:52 <geezusfreeek> oops
09:19:52 <geezusfreeek> wow
09:19:56 <geezusfreeek> wrong window
09:20:06 <byorgey> geezusfreeek: we love you too
09:20:19 <Jaak> group hug!
09:20:47 <geezusfreeek> :D
09:21:05 <idnar> heh
09:21:28 <geezusfreeek> xmonad's default behavior to switch focus when you accidentally bump the mouse got me that time
09:21:53 <byorgey> geezusfreeek: hehe, just set focusFollowsMouse = False
09:22:19 <geezusfreeek> byorgey, yes i just hadn't gotten around to do customizing xmonad much here at my new job yet
09:22:34 <byorgey> ok, fair enough =)
09:22:48 <geezusfreeek> doing it now though ;)
09:24:21 <dons> http://www.reddit.com/r/programming/comments/739y2/haskell_icfp/
09:24:22 <lambdabot> Title: Haskell @ ICFP : programming
09:27:45 <dons> http://www.reddit.com/r/programming/comments/739zb/typed_Œª_calculus_interpreter_in_agda/
09:27:45 <lambdabot> http://www.reddit.com/r/programming/comments/739zb/typed_Œª_calculus_interpreter_in_agda/
09:28:27 <geezusfreeek> aw come on i already posted that one to types.reddit.com :P
09:29:04 <quicksilver> everyone knows dons teh offishul reddit poster :P
09:29:15 * geezusfreeek cowers
09:30:24 <quicksilver> dcoutts++ # guerrilla style so it will not just disappear into the black hole that is the ACM digital library
09:31:39 <subconscious> did anyone run agda 2 in ghc 6.10?
09:39:20 <dons> geezusfreeek: types subreddit is a ghetto :)
09:41:40 <palmerc> mmorrow: Can I ask one more question about stringToTerm?
09:41:55 <Blub\0> mhh, I installed ghc on an ubuntu, and am trying to install hscurses
09:42:04 <Blub\0> cannot find it in aptitude, so I tried getting the sources
09:42:19 <Blub\0> `runhaskell Setup configure --prefix=/usr`   tells me: Setup.hs:2:28: Not in scope: `simpleUserHooks'
09:43:20 <Blub\0> what's simpleUserHooks?
09:43:37 <subconscious> looks a problem with cabal
09:46:17 <quicksilver> Blub\0: wrong version of cabal installed, I believe.
09:47:01 <Blub\0> well, ubuntu doesn't give me much choice there :P
09:47:31 <quicksilver> I can't even tell you if it's too old or too new
09:47:34 <quicksilver> but I'd guess too old
09:47:43 <dons> ?users
09:47:43 <lambdabot> Maximum users seen in #haskell: 516, currently: 476 (92.2%), active: 14 (2.9%)
09:47:52 <Blub\0> just tried version 1.2 now (tried 1.3 before), that one tells me: Setup: hscurses.cabal:24: 'Executable' stanza starting with field 'build-depends'
09:48:10 * Blub\0 slaps ubuntu
09:48:54 <ukl> hello. I've got a question concerning darcs and haskell builds; when I build, say, X11, and it updates some time in the future; i darcs pull the changes, rebuild it, install it again -- is that the right way to do it?
09:49:02 <ukl> like, just installing "over the old one"?
09:49:05 <gogonkt``> can i make GHC myself?
09:50:52 <Blub\0> will try to update cabal manually then >:)
09:54:32 <palmerc> I am trying to 'parse' a string back into my data type. http://pastebin.com/d20f937c9. So basically s1 to t1. The issue I am having at this moment is how to start.
09:54:36 <|jedai|> gogonkt``: Yes, you can
09:54:47 <gogonkt``> thx
09:54:48 <|jedai|> gogonkt``: But you need GHC to do so
09:54:58 <gogonkt``> = =
09:56:18 <Jedai> gogonkt``: In other words, you need a GHC binary not too old (>= 6.4) to build a current GHC (there are other method to support a new arch of course but they're much more complicated)
09:57:27 <gogonkt``> oh
09:57:39 <dons> great talk just now on "Systems Haskell"/Osker kernel at PSU.
09:59:16 <Jedai> gogonkt``: That's pretty standard procedure for compiler, you bootstrap them with something for the first time and then they bootstrap themselves for the next versions (GCC for example, though you may find some other C compilers able to compile it)
09:59:36 <palmerc> ghc just translates to C?
09:59:49 <palmerc> or no?
09:59:53 <dons> no, it generates native code directly, or bytecode, or C.
09:59:56 <Jedai> palmerc: Not anymore, it has a native backend
09:59:57 <gogonkt``> translate?
09:59:59 <dons> by default, it just spits asm out directly.
10:00:15 <dons> if you use -fvia-C, it generates C to be compiled via gcc.
10:00:26 <palmerc> and it the amount of runtime pretty stable. I noticed a fairly large binary for hello world
10:00:33 <palmerc> is
10:00:35 <palmerc> not it
10:00:36 * subconscious adds lots af type annotations to make cabal compile :/
10:00:40 <Jedai> palmerc: But it still got a C backend (sometimes still better than the asm backend though that will probably change fast)
10:00:44 <mm_freak> i'm reading about "higher order functions" a lot
10:00:50 <mm_freak> what is the "order" in this sense?
10:00:53 <subconscious> when you change  data  into  class  a lot of code breaks
10:00:54 <dons> the runtime is a smp-capable, thread scheduling, memory managing code base, about 50k lines of C.
10:01:11 <palmerc> I liked Chapter 1-3 od Real World Haskell for those like me starting out
10:01:41 <Jedai> mm_freak: first order function takes ordinary values as parameter, higher-order takes functions
10:02:16 <palmerc> dons: so the size of the runtime shouldn't grow too much unless you start importing things
10:02:19 <mm_freak> Jedai: yes, but what's the "order"?  what is a second order function?  a function, which takes only first order functions as arguments?
10:02:38 <Jedai> mm_freak: Yes, look at the type for more
10:03:27 <palmerc> And how well are you exploiting Thread-level Parallelism with Haskell?
10:03:38 <mm_freak> Jedai: can i say that the order is the number of pairs of parentheses i need to express the type of a function?
10:03:43 <mm_freak> + 1, that is
10:03:51 <Jedai> mm_freak: a -> b -> c is first order, (a -> b) -> c -> d is second order and so on. I believe
10:04:07 <Jedai> mm_freak: Probably more the depth
10:04:13 <mm_freak> or better yet, the level of depth
10:04:25 <mm_freak> ok, makes sense, thank you
10:04:35 <subconscious> actually a -> b -> c is higher order
10:04:42 <Jedai> There has to be some kind of reference somewhere
10:05:12 <Jedai> subconscious: No, I used a, b and c as substitute for ordinary (non-function) types
10:05:18 <subconscious> what was the point in changing Control.Exception into a typeclass
10:05:25 <Jedai> subconscious: this is first order
10:05:36 <subconscious> Jedai: no actually,  (a,b) -> c  would be first order
10:05:43 <subconscious> Jedai: a -> b -> c is definitely a higher order function
10:05:52 <gogonkt``> I think download bin package is better,6.6.1 in Gutsy :(
10:06:39 <Jedai> subconscious: Really, because it can returns a function, that is ?
10:07:04 <subconscious> yes
10:07:41 <palmerc> how do you get isAlphaNum?
10:07:43 <Jedai> gogonkt``: 6.6.1 is pretty old though, if you really want to develop for Haskell I would build myself a 6.8.3 in your place (or just use binary from haskell.org)
10:08:06 <gogonkt``> Thx a lot
10:08:10 <Jedai> palmerc: It's in Char or Data.Char
10:08:24 <Saizan> subconscious: don't you go higher order only if you take a function as parameter?
10:08:25 <palmerc> ghc Data.Char I think is correct
10:08:41 <subconscious> not by my definition of higher order
10:08:53 <dons> palmerc: the size of the runtiem is fixed. its about 150k
10:09:05 <dons> sorry. you dont mean 'runtime' in the sense i meant.
10:09:12 <dons> so yes, as you import things, the binary size grows
10:09:13 <Jedai> Saizan: That's what I would have said too, but I guess his definition is simpler and easier to apply, we need a reference somewhere
10:09:19 <dons> the bottom line is about 150k
10:10:22 <Saizan> subconscious: so by your definition A -> B -> C is 2th order and A -> B -> C -> D is third?
10:10:38 <Saizan> 2nd
10:10:43 <subconscious> ww
10:10:44 <subconscious> Setup: At least the following dependencies are missing:
10:10:44 <subconscious> base <3
10:10:47 <subconscious> this isn't good is it?
10:10:58 <JimCrayne> I actually read it "twoth order"
10:11:39 <subconscious> Saizan: I just say it's higher order it's not first order
10:11:40 <ddarius> dons: Did you see the images I made last night?
10:11:53 <Saizan> subconscious: i see
10:12:06 <dons> ddarius: no? url please.
10:12:35 <subconscious> does anyone know what I have to do to get base?
10:12:53 <ttt--> hi, im trying to uninstall bytestring-0.9.1.2 so only the earlier version is available..  how can i do this?  "ghc-pkg unregister bytestring-0.9.1.2" doesnt work, but " ghc-pkg list bytestring-0.9.1.2" shows an entry
10:12:56 <palmerc> So I have this string s1 = "f(one,g(two,three),h3(four))"
10:13:11 <Jaak> well... a -> b -> c is really a -> (b -> c) (by definition). so yes, higher order
10:13:12 <palmerc> and I pass it to stringToTerm x = Term (takeWhile isAlphaNum x)
10:13:23 <palmerc> This will grab f
10:13:26 <ddarius> dons: http://img99.imageshack.us/img99/2413/testid1.jpg  This is just the lines, though it should be easy enough to overlay the text.  (This is probably not what you were going for.)
10:13:48 <palmerc> or any other word
10:13:50 <dons> oh, that's very pretty
10:13:54 <dons> awesome.
10:14:07 <Saizan> subconscious: you already have base, but probably base-3 or -4, what are you trying to compile which requires an older version?
10:14:09 <mc__> a screensaver?
10:14:15 <subconscious> Cabal
10:14:21 <subconscious> I was hoping to use cabal to install agda 2
10:14:31 <dons> ddarius: ok. can i use that for the demo?
10:14:32 <Saizan> which version of Cabal?
10:14:48 <subconscious> 1.4.0.2
10:14:52 <subconscious> Just got that from http://www.haskell.org/cabal/download.html
10:14:53 <lambdabot> Title: The Haskell Cabal
10:15:24 <subconscious> oh maybe I should really be using cabal-install
10:16:13 <subconscious> none of this seems to wor
10:16:15 <subconscious> work
10:16:21 <ddarius> dons: The code that implements it is here: http://hpaste.org/10645 (plus some significant but easy preprocessing of the file in vim)
10:16:32 <Jedai> subconscious: You already have a version of Cabal (the library) with your GHC, you probably don't need a new one. You're searching for cabal-install (which contains "cabal" the executable√†
10:16:42 <gwern> 'lo all
10:16:50 <gwern> so is anyone here familiar with Chart?
10:17:15 * gwern is having trouble graphing non-functions; that is, circles like x^2+y^2=4.
10:17:20 <subconscious> I still get this ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty user package database then this is probably due to ghc bug #2201. The workaround is to register at least one package in the user package db
10:17:32 <dblazakis> dons: do you know if there will be videos of the ICFP talks?
10:17:39 <subconscious> I thought everyone said it was fixed and  no it's still here
10:17:57 <Saizan> subconscious: try the devel version of Cabal maybe?
10:18:02 <dons> beautiful, ddarius
10:18:08 <dons> you should put it on hackage
10:18:18 <Saizan> i think you need at least 1.5 to get it working well with ghc6.9 or 6.10
10:18:26 <ddarius> dons: To what end?
10:18:29 <subconscious> so
10:18:30 <subconscious> darcs get --partial http://darcs.haskell.org/cabal/
10:18:30 <subconscious> ?
10:18:34 <lambdabot> Title: Index of /cabal
10:18:38 <Saizan> yeah
10:18:39 <dons> ddarius: so we don't forget it.
10:18:58 <Blub\0> Oh i hate ubuntu so f-ing much <.<
10:19:04 <Blub\0> finally got a newer cabal version manually installed
10:19:11 <Blub\0> after figuring out how much I hate apt-get
10:19:30 <Jedai> Blub\0: apt-get is nice, but not for everything ;-)
10:19:37 <gwern> Blub\0: I hate how the deb package don't offer profiled ghc or gtk2hs; I hate the lack of 6.8.3; I hate the general lack of haskell packages. what do you hate?
10:19:57 <Blub\0> all of the above, + it misses forced installation
10:20:21 <gwern> also, I hate how some packages are just broken wrt ghc-pkg
10:20:23 <Blub\0> i accidently updated the unregister.sh file before removing the old pkg
10:20:28 <Blub\0> then removing failed...
10:20:35 <Blub\0> and it simply didn't want to reinstall it...
10:20:41 <Blub\0> so I had to manually edit the unregister.sh
10:21:02 <Blub\0> (luckily it's just 1 line :D)
10:21:29 <Blub\0> otherwise I would of just killed the server and made a trip to where it's located to install arch <.<
10:21:39 <Saizan> subconscious: 6.10 comes with Cabal 1.5.5, btw
10:21:48 <Blub\0> because I'm so ... angry at this thing already
10:22:22 <subconscious> I have installed 6.10 and cabal doesn't work
10:22:37 <subconscious> so I'm trying various things to get it to work. no luck yet
10:22:48 <Blub\0> finally I get a message I can actually deal with when trying to install hscurses: "Setup: At least the following dependencies are missing:"
10:22:50 <Saizan> subconscious: how it doesn't work?
10:22:57 <Blub\0> :D
10:23:02 <subconscious> It's like,
10:23:02 <subconscious> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
10:23:07 <subconscious> if you try to do anything with cabal
10:23:21 <Philonous1> I'm confused: In a type definition like (b -> c) -> a b c, what is "a b c" supposed to mean?
10:23:32 <Blub\0> phew, the mtl pkg is new enough ^^
10:23:46 <ddarius> Philippa: in 3 + f x y what does f x y mean?
10:23:55 <ddarius> Er Philonous1
10:24:14 <Philonous1> Oh, never mind, I just figured it out myself
10:24:21 <Philonous1> thanks anyway
10:24:27 <Blub\0> is it supposed to return a function taking 2 arguments?  (hey I'm new to haskell :P)
10:24:53 <subconscious> so I just installed that dev cabal and it compiled ok but still nothing works :/
10:25:02 <ddarius> Philonous1: As a rule, the type level syntax is almost identical to the term level syntax
10:25:04 <Philonous1> I was staring at that type for hours, but I guess a is just a binary type constructor
10:26:07 <mmorrow> subconscious: re: Control.OldException, this is my current hack:
10:26:09 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
10:26:10 <subconscious> does anyone know how to get rid of this "probably due to ghc bug #2201"?
10:26:18 <subconscious> mmorrow: I just annotated types manually :/
10:26:29 <subconscious> mmorrow: anyway the new dev cabal has fixed the problem it seems
10:26:52 <mmorrow> i did that at first, it was hell, then i found out about how Control.Exception -> Control.OldException and everything works nicely
10:27:16 <subconscious> I wish GHC could build and install software
10:27:21 <mmorrow> (i use that with big cabal packages that i want to fix in one-shot real fast)
10:27:21 <subconscious> then we wouldn't have this cabal thing
10:27:30 <Baughn> It's funny. I spent three hours debugging a wireless network, that was finally fixed by switching everyone from Reno to HTCP. So did I miss the real problem, or is Reno on the path to obsoletion already?
10:27:32 <Saizan> subconscious: that's quite weird, so runghc Setup.hs configure/build/install worked in the cabal repo but not for other packages?
10:27:51 <gwern> hm. I wonder if it is possible to programmaticaly decompose an expression like x^2+y^2=4 into two functions which create demicircles
10:27:52 <subconscious> Saizan: it's   cabal install foo  or cabal <whatever>  that doesn't work
10:28:17 <PeakerWork> BeelsebobWork: You say that Reactive "usually" ends up with more functional code, but I'm struggling to find examples of Reactive at all :)  Not to mention side-by-side comparisons with Yampa
10:28:37 <gwern> PeakerWork: frag! :)
10:28:42 <mmorrow> subconscious: personally, i've never gotten cabal-install to work. i think you have to start using it from a /fresh/ install, then /always/ use it for it to work..
10:28:57 * gwern notes that there are no useful comparisons to frag
10:29:05 <Saizan> subconscious: oh, you've to recompiler your cabal-install against the newer version of Cabal
10:29:32 <pcc1> is there a TH mechanism for treating expressions similarly to patterns?
10:29:58 <PeakerWork> gwern: is there a Reactive-based one? :)
10:30:19 * gwern isn't entirely sure what FRP lib frag was based on
10:30:21 <subconscious> I think that I can't compile cabal-install
10:30:30 <subconscious> it says:   Setup.hs: At least the following dependencies are missing: Cabal ==1.4.*, HTTP >=3000 && <3002, base <3 && >=2.0 && <2.2, zlib >=0.4
10:30:30 <mc__> gwern: it was yampa
10:30:37 <subconscious> and actually I have installed these programs a lot of times
10:30:38 <mc__> gwern:  you can read it in munc's thesis
10:30:53 <espaol20> Escriba el texto aquÌ....algien con espaÒollllllllll
10:31:01 <gwern> read? thesis? what
10:31:45 <Saizan> subconscious: when you install a new ghc you've to reinstall all the libraries, however that Cabal==1.4.* blocks you
10:31:50 * gwern is american. we don't go in for that sort of thing
10:31:59 <mc__> gwern: you can read in munc's thesis about frag that he used yampa
10:32:01 <subconscious> this is so confusing
10:32:14 <palmerc> split x = takeWhile isAlphaNum x, but how can you recurse when you hit a non-AlphaNum?
10:32:35 <Botje> you probably want span instead
10:32:45 <Botje> which returns the part after it too
10:32:52 <subconscious> Do you know what I should do then?
10:33:10 <Saizan> subconscious: yes, darcs get the devel version of cabal-install and install that
10:33:18 <subconscious> I can't build it though
10:33:21 <subconscious> oh
10:33:25 <subconscious> darcs I will try
10:33:27 <Blub\0> mhh, what are old-locale and old-time... I don't like the names
10:33:53 <Blub\0> and it seems like old-locale will shutup the message about missing old-locale, but create a new one about multiple System.Locale modules
10:34:50 <roconnor> Cale: if f and g are ring homomorisms from Q to R, is f==g?
10:34:57 <roconnor> Q is the rationals
10:35:05 <mmorrow> no
10:35:06 <roconnor> R is a random ring
10:35:42 <roconnor> oh?
10:35:50 <palmerc> Botje: ok so span will nicely split but the part I don't get is how to keep it going. split the remainder until it runs out of string
10:36:20 <mmorrow> let R /= the trivial ring, let f = Q -> 0 , and g = not that
10:36:44 <sw17ch> What are Haskell's primitive operations? Are there things which can't be decomposed?
10:36:44 <mmorrow> i mean to say, "not necessarily"
10:37:02 <roconnor> if R is the trival ring then there is only one fuction from anything to R.
10:37:08 <roconnor> oh
10:37:10 <roconnor> sorry
10:37:10 <mmorrow> err, i meant Q -> 1
10:37:12 <roconnor> misread you
10:37:34 <mmorrow> i always flip in my head whether to use 0 or 1 for init or terminal object ;)
10:37:58 <roconnor> mmorrow: wait, I got lost here.
10:38:01 <roconnor> :)
10:38:03 <mmorrow> heh
10:38:10 <roconnor> what is your example?
10:38:27 <Blub\0> so, what should I do when hscurses complains about old-locale and old-time being missing...
10:38:46 <mmorrow> ok, so let f be the ring hom mapping all of Q to 0 `elem` R
10:39:02 <roconnor> ring hom must preserve 1
10:39:38 <roconnor> and hence, ring hom must preserve all integers.
10:39:48 <subconscious> mmm
10:39:51 <subconscious> it says, Setup.hs: At least the following dependencies are missing:
10:39:52 <subconscious> HTTP >=3000 && <3002, base <3 && >=2.0 && <2.2, zlib >=0.4
10:40:05 <subconscious> so how do you intstall that stuff?
10:40:13 <subconscious> just using runhaskell Setup configure?
10:40:17 <mmorrow> err, let R = the reals, Q the rational. let f = (*0)
10:40:17 <gwern> unsurprisingly, cabal-install uses libraries, although I dunno about the base and http ones. a ghc version issue?
10:40:25 <gwern> subconscious: well, zlib is on hackage
10:40:29 <subconscious> gwern: Seems pretty stupid to me ...
10:40:37 <palmerc> I think this split [] = []
10:40:38 <palmerc> split x = span isAlphaNum x : split x
10:40:40 <mmorrow> f (x + y) = 0 = f x + f y = 0 + 0 = 0
10:40:42 <subconscious> gwern: If I wrote something like cabal I would hopefully not use any libraries
10:40:44 <roconnor> mmorrow: f isn't a ring homomorphism according to the definitions I have. :)
10:40:45 <palmerc> is close
10:40:46 <gwern> but isn't there a bootstrap script for cabal-install these days?
10:40:56 <roconnor> mmorrow: by ring I mean commutative ring with identity.
10:41:01 <gwern> subconscious: you would want to copy in all that library code?
10:41:07 <roconnor> by ring hom I mean preserving + * and 1.
10:41:11 <Saizan> synthasee: yes, there's also a bootstrap.sh
10:41:14 <mmorrow> ah, ok then.
10:41:18 <roconnor> :)
10:41:30 <mmorrow> take R to be Z_2
10:41:31 <Saizan> err, subconscious ^^^
10:41:37 <Botje> palmerc: you want something like (part1,part2) = span isAlphaNum x in part1 : split part2
10:41:59 <mmorrow> err, use Z_3
10:42:02 <palmerc> yes that makes sense
10:42:11 <roconnor> ok
10:42:15 <subconscious> boot.sh breaks  for the same reason
10:42:20 <subconscious> bootstrap.hs
10:42:24 <mmorrow> (i'm thinking through this as i'm going...)
10:43:10 <mmorrow> Z_2 injects into Z_3
10:43:11 <subconscious> If all went well then 'cabal' is in /Users/nono/.cabal/bin/
10:43:11 <subconscious> You may want to add this dir to your PATH
10:43:16 <subconscious> and it's not in there
10:43:48 <subconscious> really weird
10:43:48 <roconnor> mmorrow: that injection isn't a ring hom.
10:43:59 <mmorrow> Q -> Z_2, and Q -> Z_3 are not iso, since Image (Q -> Z_2 -> Z_3) /= Image (Q -> Z_3)
10:44:13 <mmorrow> roconnor: what definition are you using? :)
10:44:39 <roconnor> oh, wait, is the injection a ring hom?
10:44:56 <mmorrow> for a ring R, R/R === R -> 1
10:44:56 <roconnor> oh ya
10:45:06 <mmorrow> err, i meant to say
10:46:07 <mmorrow> well, R/R === Im (R -> 1)
10:46:45 <mmorrow> roconnor: oh, i meant the injection as in "the canonical injection"
10:46:51 <subconscious> Maybe I should use /ghc-6.10.0.20080921/libraries/cabal-bin
10:47:06 <mmorrow> like the "canonical" injection of Q into R, R the reals
10:47:43 <koninkje> sw17ch: let binding, function application, and case statement
10:47:44 <mmorrow> and an injection := monomorphism == into == one-to-one
10:47:45 <roconnor> f : Z_2 -> Z_3,  0 = f(0) = f(1+1) = f(1)+f(1) = 1 + 1 = 2
10:47:52 <roconnor> mmorrow: hence f is not a ring hom.
10:47:57 <sw17ch> koninkje: that's it, huh?
10:48:21 <mmorrow> hmm, gimme a sec to think
10:48:23 <sw17ch> koninkje: what about primitive math operations? are they compositions of those three?
10:48:29 <roconnor> mmorrow: I'm guessing that ring homs must preserve characteristic.
10:49:03 <koninkje> sw17ch: pretty much. Type classes are also fairly primitive, though they boil down to those three eventually
10:49:05 <mmorrow> why? that's not essential to ringness
10:49:19 <roconnor> mmorrow: just a conjecture :)
10:49:25 <mmorrow> heh
10:49:30 <sw17ch> koninkje, hmm... thank you :)
10:49:42 <koninkje> sw17ch: there are primatives/FFI calls other than those three, but those three are the primitives for the language
10:50:35 <mmorrow> ok, scratch this route. let's do it with products and sums
10:50:51 <sw17ch> koninkje, so, you can define an add operation with those three?
10:50:59 <sw17ch> (not that it's actually done that way)
10:51:33 <roconnor> mmorrow: f : char(p) -> char(q), 0 = 0 - 0 =  f(0) - q = f(p) - q = p - q, hence p = q
10:51:45 <roconnor> where char(p) is any ring of characteristic p
10:52:37 <koninkje> sw17ch: so for example, the implementation of (+)::Int#->Int#->Int# eventually comes down to assembly instructions, as everything must in the end; but in terms of the abstract machine that implements Haskell, let allows you to create something called (+), application allows you to construct an expression with it, and case allows you to evaluate that expression
10:53:06 <palmerc> Is this valid?
10:53:07 <palmerc> split str = part1 : split part2 where (part1,part2)=wordGet str
10:53:07 <palmerc> wordGet str = span isAlphaNum strsplit str = part1 : split part2 where (part1,part2)=wordGet str
10:53:08 <koninkje> (let also allows you to save the result of that evaluation somewhere)
10:53:10 <palmerc> wordGet str = span isAlphaNum str
10:53:44 <mmorrow> Q the rationals, R = QxQ. f : Q -> Qx1 -> QxQ , and g : Q -> QxQ such that (fst . g) === (snd . g) === id
10:53:48 <sw17ch> koninkje: i figured as much.
10:55:14 <roconnor> mmorrow: that seems promising.
10:57:11 <mmorrow> and Rx1 === R
10:57:23 <roconnor> mmorrow: but 1 -> Q is not a ring homomorphism.
10:57:33 <roconnor> becuase it doesn't preserve 1.
10:58:36 <mmorrow> hmm, i'm not used to not assuming maps aren't ring/whatever homs to begin with, so i'm stumbling ;)
10:58:59 <roconnor> I guess 1 is the teriminal object, and 2 is the initial object.
10:59:06 <roconnor> I'm not a CT expert.
10:59:10 <palmerc> apparently I recurse infinitely
10:59:17 <mmorrow> wait, how do you mean?
10:59:32 <mmorrow> 0 is initial, 1 is terminal
10:59:41 <roconnor> 1 is the ring with one element, and 2 is the ring with two objects.
10:59:52 <roconnor> notation is very confliciting.
10:59:57 <mmorrow> and A `sum` 0 == A    and A `prod` 1 == A
11:00:42 <mmorrow> so 0 is the zero ring
11:00:53 <roconnor> I'm using 1 and 2 as denoting the number of elements in the ytpe
11:01:04 <mmorrow> and 1 is {0,1}, 1+1=1
11:01:13 <mmorrow> err, no
11:01:30 <mmorrow> i dunno about that
11:01:32 <roconnor> the initial ring has {0,1}, the terminal ring has {0}
11:01:45 <mmorrow> what's the addition on the initial ring
11:01:56 <roconnor> mod 2
11:02:04 <mmorrow> ok, good
11:02:25 <roconnor> I relalize my proof that p = q holds in the ring of characterizic q
11:02:32 <mmorrow> so 1 -> R is a ring hom for every ring R
11:02:39 <roconnor> so really my conclusion is p == q (mod q)
11:02:49 <mmorrow> shit
11:02:50 <roconnor> ie p must divide q
11:02:57 <mmorrow> i'm flipping 0/1 again ;)
11:03:11 <roconnor> oh
11:03:14 <roconnor> shit
11:03:18 <roconnor> my initial ring is wrong
11:03:31 <roconnor> because I said there was no Z_2 -> Z_3 hom
11:03:45 <roconnor> so there is no initial ring I guess.
11:04:02 <roconnor> ... which is a suspicious conclusion.
11:04:09 <roconnor> oh
11:04:23 <mmorrow> hmm. in the cat of R-mods, the ring R is initial
11:04:26 <roconnor> is Z the initial ring?
11:05:15 <mmorrow> i can't remember
11:05:26 <roconnor> I think Z is the initial ring.
11:06:01 <mmorrow> that sounds right
11:06:24 <mmorrow> yes, that's right
11:06:32 <mmorrow> (commutative rings with unity)
11:08:00 <Cale> roconnor: Did you get your question answered?
11:08:09 <roconnor> nope
11:08:36 <mmorrow> oh wait. so if f,g : Q -> R as you said, and f ==g ==> R is the terminal object
11:09:20 <roconnor> I don't think you can conlcude that R is terminal.
11:09:36 <palmerc> I think this is right split str = part1 : split part2 where (part1,part2)=span isAlphaNum str
11:10:07 <palmerc> but what conditions do I need to add to prevent infinite recursion
11:10:13 <Cale> Right, for R to be terminal, you'd need a unique hom from any ring into it.
11:10:34 <palmerc> I tried split [] = [] and split "" = [] and neither stop it
11:10:41 <roconnor> Cale: My proof I was doing uses the existance of a ring hom Q -> R, but doesn't seem to care what that homomorphism is.
11:10:45 <mmorrow> oh yeah, i'm thinking only in term of Q
11:10:49 <mmorrow> *terms
11:10:52 <roconnor> which makes me suspect that there is only one.
11:10:55 <Cale> roconnor: Yes, if there is any hom Q -> R, then it is unique.
11:11:06 <roconnor> Cale: how do I show this?
11:11:11 <mmorrow> Cale: what's the reason?
11:11:12 <mmorrow> yes
11:11:13 <Cale> roconnor: First of all, it must send 0 to 0 and 1 to 1
11:11:17 <roconnor> proof sketch is all I need.
11:11:21 <mmorrow> ok
11:11:21 <roconnor> yep
11:11:38 <Cale> roconnor: and then f(1+1+...+1) = f(1) + f(1) + ... + f(1) = 1 + 1 + ... + 1 in the other ring
11:11:45 <roconnor> sure
11:11:52 <roconnor> f(n) = n
11:12:07 <mmorrow> ahh
11:12:12 <Cale> and we know that inverses of elements, if they exist in a ring, are unique
11:12:18 <roconnor> oh we do?
11:12:23 <roconnor> It's been so long
11:13:35 <Cale> Wherever 1/n gets sent, since 1 = f(1) = f(1/n * n) = f(1/n) * f(n), it must be an inverse for f(n)
11:13:35 <mightybyte> I've got a weird problem.  This program (http://hpaste.org/10648) terminates when running the ghc-compiled binary, but doesn't terminate when run from ghci.  Anyone have an idea why this might be?
11:13:51 <roconnor> yep
11:14:00 <roconnor> I'm just pondering the unique inverses thing
11:14:07 <subconscious> how do you know it doesn't terminate?
11:14:40 <roconnor> ah a*b = 1 and a0*b = 1 -> a*a0*b = a = a0
11:14:42 <mightybyte> subconscious: Ok, well maybe I don't *know*, but I waited a long time after it printed out the whole list that was printed from the terminating version...
11:14:52 <roconnor> that's what I was missing
11:15:42 <mmorrow> palmerc: takeWhile (not . isNull)
11:15:50 <mmorrow> err heh
11:15:53 <mmorrow> palmerc: takeWhile (not . null)
11:15:56 <Cale> roconnor: yep
11:16:12 <elliottt> ?bug
11:16:12 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:17:05 <elliottt> has anyone compiled vector-space using head or the 6.10 candidate?
11:17:17 <roconnor> Cale: this is very intresting, because (RingHom Q R) appears to be a type with at most one element, yet it without a constructive proof I don't see how to compute f.
11:18:07 <Cale> roconnor: What prevents the construction? Finding an inverse of an element in R?
11:18:07 <roconnor> Cale: if I claim R is a ring such that RingHom Q R exists, can you compute what f(1/n) is without me telling you anything about what RingHom Q R is?
11:18:44 <Cale> roconnor: well, I can apply the homomorphism you gave me ;)
11:19:34 <roconnor> lets say I don't give you the homomorphism, just a non-construcitve proof that it exists.
11:19:50 <roconnor> (ie a proof of ~(~(RingHom Q R))
11:19:53 <Cale> Heh, what a strange way of thinking ;)
11:20:07 <Cale> I get what you mean though.
11:20:20 <roconnor> if you could enumerate all the elements of R, then you can compute f(1/n)
11:20:45 <Cale> Of course, if you can compute inverses in R, then you're fine.
11:20:48 <roconnor> but the elements of R are not necessarily enumberable.
11:20:52 <Cale> (whenever they exist)
11:21:02 <Cale> For example, if R is a matrix ring, it's easy.
11:22:17 <roconnor> Cale: all I give you for R is a type, + * 0 and 1.
11:22:28 <roconnor> and of course ~(~(RingHom Q R))
11:22:43 <Cale> Right, I doubt it's doable.
11:23:01 <roconnor> and of course (((RingHom Q R) -> Void) -> Void)
11:23:10 <roconnor> ya. I doubt it too.
11:23:26 <roconnor> I can't ever remember encountering this situation before.
11:23:26 <subconscious> oh :(
11:23:44 <Cale> I don't think I've ever met a ring in which it was particularly hard to find inverses, but it's always for different reasons that inverses are possible to determine.
11:24:12 <roconnor> right, there appears to be no generic algorithm.
11:25:29 <joelalejandro> Hi everyone. I'm need some coding assitance. I'm working on a uni project, my professor asked us to do a solution of the Baguenaudier game (also known as Chinese Rings). I need to write a function that returns a list of movements to solve the game for "n" rings. The list is comprised of sublists of the form [1, 0] or [0, 1], where 1 means " the ring is hooked "  and 0 "the ring is not hooked". Any suggestions?
11:25:33 <roconnor> It has always been my position that types with at most one element have no computational content.
11:25:40 <roconnor> this seems to be a counter example.
11:27:27 <Cale> roconnor: Well, it depends on how expressive types can be. If a type is inhabited by a unique element if and only if one proposition entails another in some logic...
11:27:34 <Zao> joelalejandro: So what's your approach?
11:27:48 <boyscared> is work on mod_apache dead?
11:27:55 <boyscared> mod_haskell for apache i mean
11:28:10 <subconscious> teyjus has verisoning problems
11:28:13 <subconscious> ghc has cabal
11:28:14 <lispy> boyscared: i never hear people talking about it
11:28:15 <subconscious> :/
11:28:18 <subconscious> I can't use any languages
11:28:26 <lispy> boyscared: but hmm...I don't know the status.
11:28:48 <roconnor> Cale: I don't understand.
11:28:49 <boyscared> i checked out the site and the last update was in 2002
11:29:09 <boyscared> so, was curious if it got migrated to a different project or something
11:29:12 <joelalejandro> Zao: Well, the only hint I have is to create a function pull, that given n rings, returns a list of movements. Example, if I want to pull 2 rings, I do: pull 2, and I get [1, 0]. The same way, if I want to put 2 rings, I do: put 2, and I get [0, 1].
11:29:26 <gwern> Cale: anything interesting on the lb front?
11:29:28 <lispy> boyscared: but there are other ways now, WASH, HSP, HAppS, and Janus being the frameworks for using haskell to make webapps that come to mind.
11:29:41 <subconscious> lispy: What's Janus?
11:29:56 <boyscared> lisp: thanks, i'll give each of those a good look :)
11:29:57 <lispy> Janus is the framework used by the hayoo people
11:30:07 <lispy> Janus is also the hardest to find on google :)
11:30:23 <Cale> roconnor: Well, take any logical system whatsoever, and define a type Entails P Q, parametrised by propositions, which is empty if P does not entail Q, and has a unique element * otherwise.
11:30:41 <Cale> roconnor: That seems to have arbitrary amounts of content associated with it :)
11:31:11 <lispy> boyscared: my impression is that HAppS is the most mature but also the heaviest.  HSP may not be maintained (I couldn't tell) and I don't know about WASH.
11:31:14 <Cale> gwern: Well, I haven't done anything with it :)
11:31:29 <Cale> gwern: Let me know when the new stuff goes into hackage :)
11:32:03 <subconscious> why not hack on lunabot instead of mueval
11:32:13 <gwern> subconscious: crazy talk!
11:32:51 <lispy> gwern: if I got a project on c.h.o for autoproc would you be interested in becoming the maintainer?
11:33:04 <joelalejandro> Zao: any ideas?
11:33:07 <gwern> Cale: oh, actually, if I have time this week mueval will get qualified imports. hint finally got support it seems, although it was too buggy to even compile against darcs hint for the last couple weeks
11:33:16 <gwern> lispy: sure
11:33:20 <subconscious> joelalejandro: Have you written that yet?
11:33:27 <mc__> how's the status of reactive? when will the new version be ready?
11:33:27 <lispy> gwern: okay, I'll try to make a point of doing that.
11:34:31 <joelalejandro> subconscious: I haven't got the slightest idea of how to do it. I know I probably have to use a user-defined function called "headers", that adds the value x to every sublist of the list xs (as most of the project is based on that function).
11:34:59 <roconnor> Cale: it isn't obvious that it contains any content.  Depending on what you mean by content.
11:35:23 <Cale> roconnor: I mean, it could be arbitrarily hard to determine if that element exists.
11:36:05 <roconnor> depends what you mean by hard.
11:36:20 <lispy> gwern: are you gwern on c.h.o ?
11:36:25 <subconscious> joelalejandro: so you write headers?
11:36:36 <roconnor> I'm concerned about computational content, since I'm into constructive math.
11:36:45 <Cale> roconnor: Formally undecidable hard? :)
11:37:16 <Cale> Or any complexity class you could ask for, I suppose.
11:37:26 <roconnor> right.
11:37:40 <joelalejandro> yes, this is headers: http://hpaste.org/10649
11:37:41 <gwern> lispy: I'd better be
11:37:49 <joelalejandro> subconscious: http://hpaste.org/10649 this is headers
11:37:57 <subconscious> cool
11:38:11 <rwbarton> roconnor: Imagine you could specify the subtype of String -> Bool which contains only those functions f such that f x == x is a terminating Haskell program
11:38:57 <roconnor> rwbarton: ok
11:38:58 <Cale> rwbarton: uh...
11:39:20 <rwbarton> Presumably this is a uniquely-inhabited type, but if you actually had access to an element of that type, you could do more computations
11:39:20 <Cale> Type error?
11:39:24 <dmhouse> String -> Bool and f x == x?
11:39:35 <rwbarton> Sorry: f x == (x is a terminating Haskell program)
11:39:40 <subconscious> dmhouse: x :: String, (f x == x) :: Bool
11:39:47 <roconnor> oh
11:39:56 <gwern> 'The judges prize went to the LaTeX entry (of course): "Aside from demonstrating ubiquity of universal programming languages, this entry serves to remind us why we work on programming languages by showing how painful programming with bad or no abstractions can be."'
11:39:58 <roconnor> ok
11:40:31 <lament> same with Java eh
11:41:28 <lispy> gwern: okay, I made the request and we should both have permission to work on the project
11:41:51 <lispy> gwern: haha
11:42:00 <gwern> lispy: alright. when it's up send me a email and I'll test with a push I guess
11:42:45 <joelalejandro> subconscious: so, using headers, how can I come up with the program i need, given the hypothesis of pull and push as well ?
11:43:00 <roconnor> {f : String -> Bool | forall s, (f s = true) <-> {n | terminates_in_n_steps n s }}
11:43:02 <subconscious> joelalejandro: I dont' know hwat you mean hypothesis
11:43:07 <roconnor> I think I got that type right.
11:43:24 <joelalejandro> subconscious: pull 2 = [1, 0]; put 2 = [0, 1]
11:43:41 <roconnor> rwbarton: now what?
11:44:00 <rwbarton> roconnor: is that type uniquely inhabited?
11:44:01 <hugo_> hello
11:44:02 <roconnor> rwbarton: granted that this might not be a subtype
11:44:02 <zachk> how did team smartass win D:
11:44:08 <rwbarton> roconnor: I guess it depends on what you mean by ->
11:44:21 <roconnor> because the second part of the first dependent pair is not proof irrelevent.
11:44:37 <roconnor> rwbarton: function arrow
11:45:10 <roconnor> I use sigma types in place of subtypes, but they aren't really the same
11:45:10 <Cale> You're probably aware that if you take any propositional logic, you can form a category from the propositions where there's a unique arrow A -> B exactly when A entails B in the logic.
11:45:35 <Cale> (well, any propositional logic with reflexive and transitive implication)
11:45:37 <roconnor> Cale: only if you have quotients and/or subtypes.
11:46:57 <hugo_> im having trouble understanding hxt wiki at the haskell.org page :/
11:47:02 <subconscious> To get cabal working with GHC 6.10:  install the one in ghc-6.10.0.20080921/libraries/Cabal
11:47:13 <Cale> roconnor: You can form that category regardless :)  I suppose a good question is whether you can form a category like that which is enriched over some other category, but that's trickier :)
11:47:18 <subconscious> (you may have to do various other stuff which I did but forgot about too)
11:47:21 <hugo_> one of the first examples has this line: isXText t@(NTree (XText _) _) =  [t]
11:47:27 <hugo_> what does @ mean ?
11:48:09 <Cale> hugo_: It means that in this case,  t  will be bound to whatever it is that the following pattern matches.
11:48:09 <palmerc> t@(x:xs) means t will have a copy of all of the []
11:48:10 <Deewiant> > let f xs@(x:_) = x:xs in f [1]
11:48:11 <lambdabot>   [1,1]
11:48:33 <Cale> Not a copy as such, of course, but the actual thing :)
11:48:36 <subconscious> > let (x,y)@(u,v) = (1,2) in (x,y,u,v)
11:48:37 <lambdabot>   mueval: Prelude.read: no parse
11:48:37 <palmerc> right
11:48:40 <subconscious> that's a shame
11:48:43 <Cale> (but that's an implementation detail)
11:48:43 <palmerc> not a copy
11:48:47 <hugo_> its like a pointer ?
11:48:54 <subconscious> @ should just be like multiple patterns, it would be simpler
11:49:11 <subconscious> wow
11:49:11 <subconscious> cabal install readline
11:49:11 <subconscious> Resolving dependencies...
11:49:11 <subconscious> Heap exhausted;
11:49:19 <roconnor> Cale: sure, but in our RingHom Q R example, there are no obvious setoid or quotients.
11:49:37 <roconnor> Well, R might be a setoid or quotient.  It's unclear if this is relevent.
11:49:52 <palmerc> Cale: Whe you are splitting a string why can't I get it to not infinitely recurse?
11:50:12 <Cale> palmerc: what?
11:50:31 <hugo_> ohh
11:50:37 <hugo_> this @ is quite handy
11:50:39 <hugo_> :)
11:50:47 <hugo_> thank you very much
11:51:00 <palmerc> Take the sentence "Mary(had(little(lamb)))
11:51:02 <hugo_> inline pattern matching
11:51:22 <Cale> hugo_: inline?
11:51:25 <palmerc> if i write a split function so I end up with:
11:52:00 <palmerc> ["Mary","(","had"...
11:52:28 <subconscious> palmerc: if you are trying to parse that string into haskell data type I think you are doing it a bad way
11:52:33 <palmerc> split s = p1 : split p2 where (p1,p2)=span isAlphaNum s
11:52:42 <subconscious> cabal is totally broken :/
11:52:47 <Cale> palmerc: needs a base case
11:52:56 <palmerc> split "" = []
11:53:18 <palmerc> I have that one
11:54:22 <Cale> okay, and the next problem is that after your first split, the span will give an empty string as its first part, and the whole string as its second
11:54:23 <rwbarton> span isAlphaNum returns a pair (p1,p2) where p1 has alphaNums and p2 begins with a non-alphaNum.  If you pass that p2 back in, you're not going to get any alphaNums out, just ([], p2).
11:54:27 <palmerc> Cale: here is what I have http://pastebin.com/d1e71d108
11:54:55 <subconscious> palmerc: why are you doing it in this way?
11:55:05 <palmerc> I am honestly experimenting
11:55:13 <palmerc> I have no idea what I am doing
11:55:15 <subconscious> um
11:55:25 <subconscious> palmerc: I could suggest a more sensible way
11:55:32 <palmerc> sure
11:55:35 <Cale> split p [] = []; split p s = p1 : split (not . p) p2 where (p1,p2) = span p s
11:55:36 <palmerc> I am open to suggestions
11:55:42 <Cale> Try that :)
11:56:00 <Cale> (with isAlphaNum as the initial predicate, of course :)
11:56:17 <subconscious> write out your syntax rougly in BNF and then use Parsec to write a parser
11:56:33 <subconscious> it will come out very much like the BNF so that may be useful as a reference while you program
11:56:37 <palmerc> subconscious...
11:56:41 <Cale> But yeah, it sounds an awful lot like you ought to have a parser.
11:56:49 <palmerc> I agree
11:57:07 <Cale> Unless you're really just interested in breaking the string up into alphanumeric and nonalphanumeric portions.
11:57:39 <Cale> Prelude Data.Char> let split p [] = []; split p s = p1 : split (not . p) p2 where (p1,p2) = span p s
11:57:42 <Cale> Prelude Data.Char> split isAlphaNum "Mary(had(little(lamb)))"
11:57:42 <Cale> ["Mary","(","had","(","little","(","lamb",")))"]
11:57:55 <palmerc> mmorrow helped me get the data to a string in this iteration http://pastebin.com/m28beeb64
11:59:32 <subconscious> ‚ô™ unfoldr (Just . head . lex) $ "Mary(had(little(lamb)))"
11:59:41 <palmerc> At this point I am trying to get some sort of string parsing into some data structure. Mainly because I am still figuring out Haskell syntax
11:59:57 <subconscious> look at the parsec tutorial/manual
12:00:07 <subconscious> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
12:00:15 <subconscious> I think I leaned a good bit of haskell from this
12:00:15 <lambdabot> Title: Parsec, a fast combinator parser
12:00:42 <palmerc> not as in parallax of one arcsecond?
12:01:00 <palmerc> or less than the 12 parsecs the Falcon can do the Kessel run in?
12:01:57 <SamB_XP> now ... as I under stand it, this brag is a brag as to how little SPACE the falcon traverses to complete the run?
12:02:33 <SamB_XP> due to curvature near the Maw?
12:02:48 <palmerc> Actually in the Han Solo series of books it turns out the reason the ship did it so fast was because of that black hole he flew too close to
12:02:55 <palmerc> right?
12:03:26 <SamB_XP> palmerc: um, the Maw being possibly the largest cluster of black holes in the galaxy
12:03:37 <mmorrow> subconscious: didn't notice it got disconn
12:03:41 <mmorrow> , 42
12:03:46 <lunabot>  42
12:03:50 <subconscious> ‚ô™ unfoldr (Just . head . lex) $ "Mary(had(little(lamb)))"
12:03:51 <lunabot>  ["Mary","(","had","(","little","(","lamb",")",")",")","","","","","","","...
12:04:56 <mmorrow> , takeWhile (not . null) . unfoldr (Just . head . lex) $  "Mary(had(little(lamb)))"
12:04:57 <lunabot>  ["Mary","(","had","(","little","(","lamb",")",")",")"]
12:08:07 <lispy> :t Just . head . lex
12:08:08 <lambdabot> String -> Maybe (String, String)
12:08:19 <lispy> That's a cute function
12:09:15 <palmerc> yay! split works
12:09:18 <Deewiant> ?ty lex
12:09:19 <lambdabot> String -> [(String, String)]
12:11:37 <Taejo> ?ty unfoldr
12:11:39 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:12:11 <mc__> how's the status of reactive? when will the new version be ready?
12:12:26 <Taejo> unfoldr (\x -> Just (x+1, x)) 0
12:12:34 <Taejo> > unfoldr (\x -> Just (x+1, x)) 0
12:12:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:12:44 <Taejo> > unfoldr (\x -> Just (x, x+1)) 0
12:12:45 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:15:19 <subconscious> ‚ô™ let foo 0 = Nothing ; foo (flip divMod 10 -> (n,d)) = Just (d,n) in unfoldr foo 36524895
12:15:20 <lunabot>  [5,9,8,4,2,5,6,3]
12:15:31 <Deewiant> > unfoldr (\s -> case head (lex s) of ([],[]) -> Nothing; x -> Just x) "1foo-2"
12:15:32 <lambdabot>   ["1","foo","-","2"]
12:15:49 <subconscious> ‚ô™ foldr (\d n -> 10*n + d) 0 [5,9,8,4,2,5,6,3]
12:15:50 <lunabot>  36524895
12:16:10 <Taejo> who is lunabot?
12:16:48 <maltem> huh? what was that -> pattern syntax up there?
12:17:11 <Baughn> maltem: Where?
12:17:20 <zachk> its lambda notation
12:17:25 <skorpan> how is ">>" pronounced?
12:17:29 <maltem> Baughn: foo (flip divMod 10 -> ...
12:17:33 <Baughn> skorpan: "Then"
12:17:38 <Taejo> malouin: it's a view pattern
12:17:39 <zachk> i call it pipe-drop and i call >>= pipe
12:17:52 <Baughn> maltem: View pattern
12:18:01 <Baughn> Which means LB is running 6.10? -_-
12:18:02 <Taejo> malouin: the argument gets applied to the thing on the left and matched against the thing on the right
12:18:29 <maltem> Taejo, Baughn: Ah, sounds like I've read about that once upon a time. So that's a ghc extension nowadays?
12:18:43 <Baughn> maltem: Not yet. It's in 6.10, but 6.10 is still in beta
12:18:50 <maltem> ah ok
12:18:51 <Deewiant> view patterns are in 6.8.3, right?
12:19:28 <Baughn> Deewiant: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
12:19:31 <lambdabot> Title: Status/Releases - GHC - Trac
12:19:34 <Baughn> That suggests "not"
12:20:16 <Deewiant> evidently not
12:20:23 <Deewiant> wonder why I thought they were
12:20:42 <Baughn> There are enough extensions in it already, it's easy to miss some. :P
12:21:12 <palmerc> Is parsec in the standard library?
12:21:36 <palmerc> for ghc
12:21:50 <subconscious> it's called Text.ParserCombinators.Parsec or something
12:22:16 <palmerc> that was good
12:22:46 <Baughn> Extalibs, but if you installed the binary you have it
12:22:51 <Baughn> *extralibs
12:23:30 <subconscious> oh well I guess I have to implement my own unification monad
12:36:37 <subconscious> hey has anyone actually typed out the stuff from the paper Typed Logical Variables in Haskell and checked it works?
12:36:42 <subconscious> (and can hpaste the code :))
12:38:11 <dons> it'd be good to see it on hackage...
12:38:51 <subconscious> I just can't be bothered to implement unification _again_, and lambda prolog seems broken at the moment
12:41:59 <subconscious> yeah
12:41:59 <subconscious> Your search - unification site:hackage.haskell.org/cgi-bin/hackage-scripts/package - did not match any documents.
12:54:30 <boyscared> is this comment about tree monipulation in haskell correct: http://osnews.com/thread?331056
12:54:31 <lambdabot> Title: OSNews > Thread > "Haskell sucks." by axilmar
12:54:41 <boyscared> manipulation*
12:55:04 <subconscious> boyscared: yes
12:55:33 <EvilTerran> subconscious, not really, no
12:55:58 <dmwit> boyscared: I would say it is accurate to say, "building a Model-View-Controller-based program in Haskell is hard."
12:56:05 <subconscious> boyscared: I am sure that person finds it 'hard as hell' in haskell, and they have their own opinion..
12:56:09 <dmwit> But that is because MVC is a bad paradigm in the functional world.
12:56:12 <rwbarton> It's wrong: the task described is not trivial in imperative languages.
12:56:18 <EvilTerran> "you have to use the Zipper monad" is false, and "mix the useful code with visitation to the tree code" doesn't even make sense
12:56:22 <bd_> You could build your tree with IOVars or TVars, or you could just rebuild the tree from that point - whichever is easier...
12:56:29 <dmwit> There are other paradigms that are very useful, and that make the program he's describing both fun and easy to write!
12:56:42 <subconscious> @src Mu
12:56:42 <EvilTerran> you could represent the tree as a Map Int (Set Int) ...
12:56:46 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
12:57:03 <monochrom> Oh God, Java wins?
12:57:05 <dmwit> On the other hand, this was a very successful troll, if that's what it was. =P
12:57:09 <dmwit> monochrom: yep
12:57:11 <dmwit> Team Smartass
12:57:17 <EvilTerran> boyscared, also, it's what the perl folk call an "X and Y problem"
12:57:21 <dmwit> They are some very talented programmers. =)
12:57:26 <dufflebunk> Has anyone had a problem isntalling validate-0.0 with cabal install?
12:57:34 <boyscared> that's true MVC is better suited to OOP
12:57:38 <EvilTerran> as in, you want to solve problem X, but you instead ask for a solution for more specific problem Y
12:57:55 <EvilTerran> because you think that's the only correct way to solve X
12:58:01 <rwbarton> (Is it really a surprise that being smart/clever/good at programming problems is a bigger factor in the ICFP contest than choice of programming language?)
12:58:12 <EvilTerran> here, i don't know what X is, but Y is "make a Model-View-Controller application in Haskell"
12:58:14 <dufflebunk> I pasted the error message: http://hpaste.org/10651
12:58:26 <dmwit> EvilTerran: Exactly!
12:58:29 <rwbarton> (ah, I see dmwit already made this point.  Sorry)
12:59:08 <monochrom> Someone should win the ICFP using 6502 assembly next time. (Not implying 6502 hardware.)
13:00:04 <matthew-_> use djb's assembly language
13:02:43 <EvilTerran> http://www.perlmonks.org/index.pl?node_id=542341
13:02:45 <lambdabot> Title: XY Problem
13:10:14 <leimy> ByteString is pretty cool... Kind of wish it was the default string.
13:10:56 <leimy> My anagram thingy is about 2x faster for the input that I'm using (/usr/share/dict/words) with ByteString vs String on a Data.Map
13:11:05 <olsner> ... I kind of wish the default string was polymorphic in a way as to be both String and ByteString
13:11:17 <leimy> olsner: that would be great too
13:11:38 <skorpan> http://pastebin.com/d5b1908a6 <- could someone give me some thoughts on this?
13:11:45 <skorpan> i can't figure it out
13:11:55 * [R]ayne np: Lil Wayne - Dontgetit [09:52m/128Kbps/44KHz]
13:11:57 <skorpan> (i hope that all the relevant parts of the code is in there)
13:12:22 <skorpan> btw, this *is* homework, yes, but for a course that i already passed some four years ago. i'm doing this for fun.
13:12:44 * leimy wrote a program to cheat at word games last night in Haskell
13:12:51 <SamB_XP> skorpan: heh
13:12:53 <leimy> specifically facebook ones :-)
13:12:54 <sjanssen> leimy: heh, I've done that before
13:13:05 <SamB_XP> leimy: that's cheating ?
13:13:13 <leimy> I used Control.Parallel though
13:13:23 <leimy> I feel like I'm cheating :-)
13:13:30 * [R]ayne np: Lil Wayne - Got Money [04:04m/128Kbps/44KHz]
13:13:32 <SamB_XP> well than I guess you are
13:13:33 <leimy> my one friend was all like "look at my high score!"
13:13:46 <rwbarton> skorpan: I'm confused, you're generating a random <something> between 1 and 1337 and then throwing it away?  Why?
13:13:46 <SamB_XP> how'd he get 'em ?
13:13:51 <leimy> 52 lines of haskell later and I handed him his ass :-)
13:13:57 <skorpan> rwbarton: i just want the new stdgen
13:14:10 <dufflebunk> skorpan: I think the compiler can't decide which of the different instances of Num (integer, float, ...) is desired
13:14:13 <SamB_XP> leimy: how many clicks after that ?
13:14:27 <leimy> SamB_XP:  "clicks"?
13:14:30 <rwbarton> skorpan: How is it any better than g?  But yes, you can add a type annotation like (1 :: Int, 1337)
13:14:30 <skorpan> hm, that fixed it dufflebunk
13:14:41 <SamB_XP> leimy: what, does your program cheat via HTTP ?
13:14:52 <leimy> oh no, that'd be really awesome, and this is a flash game :-)
13:15:09 <leimy> you can key stuff in
13:15:12 <SamB_XP> see, I figured you had to click the mouse a lot to actually go through the game
13:15:19 <SamB_XP> but maybe not for a flashgame
13:15:44 <SamB_XP> I figured it was just some forms like the usual facebook fare
13:16:22 <skorpan> rwbarton: currently i'm just testing this through ghci, which is why i need to randomly generate an StdGen instead of using my own "mkStdGen <some number>" directly
13:16:52 <sjanssen> leimy: automating the typing shouldn't be incredibly difficult if you're on X11 -- sending synthetic key presses is pretty easy
13:16:55 * [R]ayne np: Lil Wayne - Dr. Carter [04:24m/128Kbps/44KHz]
13:17:09 <sjanssen> [R]ayne: please turn off your playlist display in #haskell
13:17:25 <skorpan> yeah or at least play some decent music
13:17:25 <skorpan> np: pet shop boys - a different point of view
13:17:25 <SamB_XP> sjanssen: but it seems like many apps ignore synthesized key events
13:17:29 * dolio snickers.
13:17:39 <sjanssen> SamB_XP: yes, often for security reasons
13:17:43 <SamB_XP> [R]ayne: yeah, only lambdabot is allowed to do that
13:17:56 <sjanssen> SamB_XP: you'd have to test if firefox/the embedded flash window will accept those events
13:18:02 <rwbarton> @vixen what kind of music do you like?
13:18:02 <lambdabot> i like Buddy Holly
13:18:03 <SamB_XP> sjanssen: so it seems highly likely that flash does too
13:18:26 <SamB_XP> and I'm fairly certain that flash gets it's own window -- I think all netscape plugins do
13:18:35 <[R]ayne> Oh shit, I didn't know that was on.
13:18:37 <[R]ayne> Sorry man.
13:18:59 <sjanssen> SamB_XP: yes, it creates a window that is child of the parent
13:19:09 <[R]ayne> Seriously, don't bitch at me I didn't even know it was on.
13:19:19 <sjanssen> [R]ayne: it's okay :)
13:19:31 <[R]ayne> Okay. :)
13:20:39 <leimy> sjansen: I'm on Mac OS X though :-)
13:20:48 <SamB_XP> [R]ayne: oh, I forgot to say ;-P
13:20:53 <leimy> X11 isn't really a nicely integrated piece of the system
13:20:58 <sjanssen> leimy: pssh, you probably have to use 47 undocumented APIs to accomplish this
13:21:16 <SamB_XP> also I don't think lambdabot ever listens to music, since I'm pretty sure she doesn't understand it ...
13:21:34 <EvilTerran> ?vixen What do you think of Mozart?
13:21:34 <lambdabot> maybe. do you?
13:21:38 <EvilTerran> pardon?
13:21:51 <SamB_XP> hahaha
13:22:04 <dufflebunk> Has anyone gotten errors when trying to install validate? http://hpaste.org/10651
13:22:09 <dolio> What, do you think of Mozart?
13:22:09 <EvilTerran> SamB_XP, i think i just prove your point
13:24:56 <leimy> sjanssen: sounds about right
13:26:50 <imphasing> Every time I try to understand monads, my brain goes on a vacation..
13:27:06 <imphasing> Anyone have a good resource that gives a somewhat straight forward review?
13:27:15 <EvilTerran> ?go you could have invented monads
13:27:23 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
13:27:23 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
13:27:44 <imphasing> EvilTerran, I just finished reading that :)
13:27:52 <imphasing> Problem is, I don't have a TON of haskell experience
13:27:59 <imphasing> I should probably spruce up on that :)
13:28:35 <EvilTerran> try to understand Functor first
13:28:47 <imphasing> EvilTerran, Alright, thanks
13:28:55 <EvilTerran> (that's my suggestion, anyway)
13:29:01 <dibblego> and mine
13:29:26 <imphasing> I'll understand this one day, even if it's the death of me.
13:29:33 <leimy> ?go eff yourself?
13:29:39 <lambdabot> http://www.xanga.com/effyourself
13:29:39 <lambdabot> Title: effyourself's Xanga Site
13:29:42 <leimy> heh
13:29:42 <ehtom> Theres a page that explains them pretty well
13:30:13 <ehtom> It explains them in terms of what you would have to do in order to make sure a sequence of statements was executed in a particular order
13:30:40 <imphasing> I just can't understand how that's possible, if nothing is for sure going to execute at any given time, at all
13:30:42 <ehtom> (i.e. pass a label to each function making them return a new label to go onto the next function)
13:30:50 <imphasing> They just seem to break the functional style, how I understand it
13:30:59 <ehtom> they do
13:30:59 <olsner> a monad is just a way of combining three pretty simple functions - that thing about them being insanely difficult and magical is just fear of the unknown talking (the tricky thing is groking when and for what they're useful)
13:31:07 <dibblego> no they don't
13:31:08 <leimy> imphasing: is  "f . g" not functional?
13:31:12 <leimy> f . g implies a sequence
13:31:18 <imphasing> I can see how continuation will give a sequence, though
13:31:29 <Deewiant> and "const x y" implies not executing something at all
13:31:32 <ehtom> dibblego: do statements is not "functional style"
13:31:35 <imphasing> If the '.' symbol means "continuation", then I can get that
13:31:38 <Deewiant> so you only need to understand (.) and const, really ;-)
13:31:39 <ehtom> imo
13:31:57 <dibblego> ehtom, maybe so, but do statements are another thing altogether
13:32:07 <ehtom> how exactly?
13:32:16 <ehtom> they're directly related to monads aren't they
13:32:20 <leimy> do statements are nothing but sequencing :-)
13:32:22 <lament> imphasing: (.) is functional composition, the little circle in math notation
13:32:24 <Deewiant> ?undo do a; b; c;
13:32:25 <lambdabot> a >> b >> c
13:32:32 <dibblego> it is a syntactical construct, where a monad is a mathematical construct that has nothing to do with "violating the functional style"
13:32:34 <lament> imphasing: (f . g) x = f (g x)
13:32:39 <rwbarton> monads don't require the existence of do expressions.  They're just syntactic sugar
13:32:57 <leimy> getLine >>= putStrLn
13:32:59 <leimy> that's the same as
13:33:03 <imphasing> lament, Isn't that the same as f $ g?
13:33:03 <lament> leimy: f . g does not imply a sequence, though.
13:33:07 <leimy> x <- getLine; putStrLn x
13:33:29 <rwbarton> ehtom: the IO monad is magical, because it's implemented by the run-time system.  I suggest learning about the State monad, and then thinking of IO as a bizarre special case
13:33:55 <leimy> yeah IO is not the best starting point for Monads IMO
13:34:00 <leimy> perhaps "Reader" is better
13:34:00 <sjanssen> pssh, IO is just State RealWord :P
13:34:08 <dibblego> having "taught monads" to enough people now, I am of the firm opinion that IO should come "as last as possible"
13:34:08 <SamB_XP> well, it's bizarre enough ;-)
13:34:16 <SamB_XP> sjanssen: yeah right
13:34:20 <sjanssen> Maybe is my favorite beginning Monad
13:34:27 <sjanssen> or maybe you even start with Identity
13:34:27 <leimy> Maybe or []
13:34:29 <dibblego> mine too, and List
13:34:32 <SamB_XP> as if the world stands still outside the program
13:34:32 <RayNbow> @bot
13:34:32 <lambdabot> :)
13:34:37 <RayNbow> > let f=(+0); g=(++[]); x = Nothing in (fmap f x, fmap g x)
13:34:38 <lambdabot>   (Nothing,Nothing)
13:34:39 <ehtom> I'm not particularly interested in the theory of monads
13:34:48 <dibblego> start with Maybe and List, then implement a function across both, note the repetition, can we be rid of it?
13:35:00 <leimy> ehtom: as well you should not be if you're a practical programmer
13:35:00 <ehtom> the example about the passing labels between functions seemed good enough to me
13:35:01 <geezusfreeek> :t (undefined :: b -> c) $ (undefined :: a -> b)
13:35:02 <lambdabot> forall c. c
13:35:25 <geezusfreeek> oops
13:35:58 <geezusfreeek> didn't think about the two 'b's not unifying
13:36:01 <imphasing> leimy, It's not in me to use something without understanding it.
13:36:15 <dibblego> imphasing, you already do use monads
13:36:16 <imphasing> I COULD just suck it up, and say "that's the way it works, oh well", but I require understanding :)
13:36:28 <leimy> imphasing: I think you can understand how to use most anything without understanding the theory
13:36:41 <leimy> imphasing: millions upon millions of people use televisions, few know how they work.
13:36:53 <imphasing> leimy, Yeah, and they suck :P
13:36:56 <leimy> but then analogies are crap :-)
13:37:02 <dibblego> imphasing, do you feel capable of writing these two functions? [a] -> (a -> [b]) -> [b] and Maybe a -> (a -> Maybe b) -> Maybe b
13:37:12 <leimy> All generalizations are false!
13:37:18 <imphasing> dibblego, Heeeellll no. I need to spend more time with haskell
13:37:23 <geezusfreeek> imphasing, (f $ g) x = (f g) x, but (f . g) x = f (g x)
13:37:24 <imphasing> The syntax still makes me cringe.
13:37:31 <dibblego> imphasing, what language are you familiar with?
13:37:40 <ehtom> leimy: your statement is a contradiction
13:37:41 <imphasing> dibblego, C#, C, Java, Perl, etc.
13:37:48 <imphasing> Most imperitive languages I get.
13:37:56 <leimy> ehtom: I know...
13:38:08 <leimy> ehtom: "This statement is false" is another fun one.
13:38:20 <BMeph> leimy: There are no absolutes! ;p
13:38:25 <leimy> hah
13:38:28 <leimy> I like that
13:38:29 <geezusfreeek> There does not exist a statement that is true!
13:38:45 <lament> Kill all extremists!
13:38:46 <dibblego> interface F<X, Y> { Y f(X x); } static <A, B> List<B> t(List<A> as, F<A, List<B> f) { ... and static <A, B> Maybe<B> u(Maybe<A> a, F<A, Maybe<B>> f) { ...
13:38:56 <Deewiant> my eyes!
13:39:05 <Deewiant> the goggles, they do nothing!
13:39:11 <SamB_XP> lament: that's not as paradoxical though
13:39:11 <lament> dibblego: :DDD
13:39:15 <SamB_XP> we could just kill everyone
13:39:17 <dibblego> Deewiant, ask any Java programmer, it's *way* more readable :)
13:39:20 <leimy> 98% of percentages are made up on the spot
13:39:36 <ehtom> dibblego: that looks kind of like C++
13:39:44 <Deewiant> dibblego: suure
13:39:44 <leimy> On a scale of 1 to 5 how do you rate scales of 1 to 5
13:39:55 <Deewiant> I generally rate them on a scale of 1 to 5
13:40:12 <SamB_XP> Deewiant: which goggles are you using ?
13:40:15 <EvilTerran> œÄ
13:40:18 <Deewiant> SamB_XP: all of them!
13:40:25 <SamB_XP> Deewiant: at the SAME TIME?
13:40:29 <SamB_XP> no wonder they don't help
13:40:31 <BMeph> imphasing: Do you get COBOL?!? Yikes, that's Scary! ;p
13:40:37 <EvilTerran> [minBound..maxBound::Goggle]
13:40:42 * leimy sadly wrote a lot of COBOL in college
13:40:43 <imphasing> BMeph, COBOL is pretty simple, but very ugly :P
13:40:49 <SamB_XP> Deewiant: hint: the lisp ones are buggy
13:40:50 <leimy> and x86 assembly... 16bit.
13:40:54 <imphasing> Just like assembly, which is even uglier
13:41:00 <Deewiant> Goggle undefined :: forall a. Goggle a
13:41:00 <EvilTerran> Haskell can be both simple and beautiful
13:41:13 <EvilTerran> or it can be complicated and ugly
13:41:15 <EvilTerran> but there you go
13:41:20 <Deewiant> SamB_XP: I figured the Haskell ones would overpower the rest anyway
13:41:20 <lament> just like life
13:41:23 <imphasing> EvilTerran, Same goes for most languages
13:41:24 <EvilTerran> some languages don't have the first option
13:41:35 <SamB_XP> Deewiant: I don't remember there being Haskell goggles
13:41:37 <BMeph> leimy: Out of all the ways to rate things, what are your top three? ;)
13:41:51 <SamB_XP> what's the date on your codex?
13:41:56 <lament> you guys should keep ind mind that Java is the programming language of choice for discriminating hackers
13:42:02 <EvilTerran> some languages can't even be simple but ugly *or* complicated but beautiful
13:42:11 <Deewiant> SamB_XP: I got it second-hand, not sure :-/
13:42:15 <SamB_XP> lament: what happened to 2D?
13:42:19 <ehtom> EvilTerran: in pretty much any language theres always some stuff that is unavoidably ugly
13:42:22 <EvilTerran> lament, i prefer hackers that don't discriminate
13:42:32 <EvilTerran> ehtom, i agree. i'm just saying some languages can't do anything else.
13:42:37 <lament> SamB_XP: it's Java, this year...
13:42:39 <ehtom> like java?
13:42:46 <EvilTerran> ish
13:42:57 <ehtom> lament: hackers use java?
13:43:11 <SamB_XP> ehtom: or they let non-hackers win the contest
13:43:14 <lament> ehtom: they not only use it, they won ICFP 2008 with it.
13:43:16 <SamB_XP> or they are just smart-alecks
13:43:23 <ehtom> ICFP is what?
13:43:26 <Deewiant> did they use Java in the last competitions?
13:43:31 <Deewiant> ?go icfp
13:43:31 <SamB_XP> well, the contest, not the conference
13:43:33 <lambdabot> http://www.icfpcontest.org/
13:43:33 <lambdabot> Title: ICFP Programming Contest 2008
13:43:53 <imphasing> I suppose the fact that I never went to school is going to impede my Haskell programming.. I have no degree in math :P
13:43:58 <znutar> C++ won in 2006 or so too
13:44:12 <Deewiant> C++ won 2007 evidently
13:44:20 <Deewiant> http://en.wikipedia.org/wiki/ICFP_Programming_Contest#Prizes
13:44:21 <lambdabot> Title: ICFP Programming Contest - Wikipedia, the free encyclopedia
13:44:34 <ehtom> My general opinion is that contests like that are irrelevant
13:44:36 <lament> imphasing: Haskell is a programming language, there's no need for a degree in math.
13:44:52 <Deewiant> it doesn't hurt, though. ;-)
13:44:55 <leimy> BMeph: Why is that wrong numbers are never busy?
13:44:56 <SamB_XP> imphasing: what is the point of a degree in snobbery ?
13:44:57 <imphasing> lament, It seems like a lot of Haskell is very math-oriented
13:45:08 <ehtom> I mean... has any new research been done?
13:45:08 <leimy> s/math/meth
13:45:08 <imphasing> SamB_XP, So you can tell others?
13:45:34 <ehtom> SamB_XP: math degrees are degrees in snobbery?
13:45:46 <BMeph> leimy: Are rhetorical questions even necessary? ;p
13:45:47 <lament> imphasing: it's math-oriented but you can ignore all that for practical programming
13:45:58 <SamB_XP> ehtom: oh, they aren't ?
13:46:00 <lament> imphasing: note that "ignore" is not the same as "not understand"
13:46:27 <leimy> I find we're better off just not understanding things, and having blind faith
13:46:30 <lament> imphasing: the difficult-to-understand stuff is not particularly mathy
13:46:44 <imphasing> For life, liberty, and the pursuit of parallelism; To haskell!
13:47:07 <leimy> Haskell: It's been parallelized from the neck up!
13:47:56 <ehtom> SamB_XP: Maths = Physics > Chemistry > Engineering > Biology >> Others
13:48:40 <leimy> >> Scalp Care
13:48:45 <imphasing> >> English
13:48:59 <ehtom> nah, the others are pretty much equivalent
13:49:18 <ehtom> and Others >> Anything ending with the word "studies"
13:49:31 <ehtom> cant forget that one
13:50:00 <imphasing> Alright guys, thanks for the help
13:50:04 <imphasing> I've got to go home and make some dinner
13:50:06 <lament> Advanced category theory studies?
13:50:09 <imphasing> Ciao :)
13:51:03 <ehtom> lament: if they made a course called that it would suck ass
13:51:25 <ehtom> lament: They would call it "Category Theory"
13:55:35 <sw17ch> ehtom: I don't know if those departments can have a sane implementation of Ord
13:55:56 <ehtom> Ord?
13:56:13 <sw17ch> Ord would be hard, Eq, Read, and Show would be fine :P
13:56:15 <sw17ch> even Enum
13:56:18 <sw17ch> but i don't think Ord works
13:56:40 <sw17ch> (unless Physics > Chemistry doesn't imply that Physics is more important/better than Chemistry)
13:58:10 <ddvlad> hey, is there by any chance a "here, you idiot, it's all you ever wanted to know about fmap" resource out there?
13:58:40 <dolio> How much do you want to know?
13:58:47 <Deewiant> yes, it's this channel :-)
13:59:05 <Botje> fmap is map for generic containers. the end :o)
13:59:26 <sw17ch> ddvlad: it's way easier than it seems
13:59:40 <RayNbow> > map (+1) [0..9]
13:59:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:59:42 <RayNbow> > fmap (+1) [0..9]
13:59:43 <Deewiant> in haskell 1.4 fmap was, in fact, called map.
13:59:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
13:59:45 <ehtom> sw17ch: it was order of difficulty
13:59:57 <RayNbow> > fmap (+1) Just 3
13:59:58 <sw17ch> ehtom: you have biology on the wrong end then... :\
13:59:58 <lambdabot>       No instance for (Num (Maybe a))
13:59:58 <lambdabot>        arising from the literal `1' at ...
14:00:03 <RayNbow> ah crap
14:00:05 <RayNbow> > fmap (+1) (Just 3)
14:00:07 <lambdabot>   Just 4
14:00:19 <ddvlad> hmm, I guess I'm off reading the instances of Functor then? ;-)
14:00:21 <RayNbow> (I should just use $ instead :P)
14:00:28 <ehtom> sw17ch: undergraduate degrees thereof
14:00:34 <Deewiant> @src Maybe fmap
14:00:34 <lambdabot> fmap _ Nothing       = Nothing
14:00:35 <lambdabot> fmap f (Just a)      = Just (f a)
14:00:40 <Deewiant> @src [] fmap
14:00:41 <lambdabot> fmap = map
14:00:43 <Deewiant> etc. :-P
14:00:44 <ddvlad> that maybe thing you did, RayNbow , was pretty nifty :)
14:00:54 <Deewiant> @src (->) fmap
14:00:54 <lambdabot> fmap = (.)
14:00:56 <sw17ch> ehtom: even then... my wife was doing some reasearch this summer dealing with carbon emissions and assimilation...
14:01:02 <sw17ch> that stuff is sooooooooooooo hard...
14:01:08 <ddvlad> Deewiant: hmm, i'd forgotten how useful lambdabot actually is
14:01:16 <RayNbow> ddvlad: you don't really need to read the instances of Functor
14:01:26 <Deewiant> yeah, they should be obvious to you ;-)
14:01:32 <ehtom> sw17ch: research != undergraduate... generally
14:01:49 <sw17ch> ehtom: ah... good point... Liberal Arts college and a very smart wife...
14:02:15 <ddvlad> okay, so i guess i'll just umm apply fmap next time i need it
14:02:19 <ddvlad> thanks, everyone
14:02:25 <Deewiant> fmap = liftM for monads
14:02:36 <sw17ch> ehtom: even so... biology is not to be trifled with :P
14:02:53 <matthew-_> meh, it's all a joke really
14:02:58 <matthew-_> none of it is right
14:03:05 <ehtom> sw17ch: i put it with the hard subjects, just its at the bottom of the hard subjects
14:03:08 <ehtom> where it belongs :P
14:03:23 <matthew-_> at best it's maths with reasonably intelligent guesses
14:03:23 <ehtom> well, biology > engineering is arguable
14:04:01 <matthew-_> arts are actually on top because at least there they bother admitting that they could all be wrong
14:04:01 <sw17ch> ehtom: well perhaps.... but you need concat [(repeat '>'),"Others"] instead of just the two
14:04:29 <ehtom> matthew-_: then you can argue the fact that you are talking to people on the internet right now is a "reasonably intelligent guess"
14:05:02 <matthew-_> the fact that it works is due to models of physics
14:05:13 <matthew-_> those models may be totally flawed and wrong
14:05:29 <matthew-_> but it doesn't stop people labelling them as "laws" of physics
14:05:35 <matthew-_> which is really quite laughable
14:06:00 <ehtom> no, its not
14:06:11 <lament> music > math > physics > chemistry > ...
14:06:12 <SamB_XP> matthew-_: prove it
14:06:20 <matthew-_> maths is man-made. The "real world" isn't
14:06:23 <SamB_XP> laugh about it and send us a recording
14:06:26 <matthew-_> SamB_XP: that's my point. you can't
14:06:47 <matthew-_> "proof" only has meaning in entirely abstract disciplines
14:06:57 <lament> proof only has meaning when you have axioms
14:07:12 <ehtom> matthew-_: They fucked up set theory once due to bad axioms btw
14:07:23 <ehtom> matthew-_: maths isnt quite as concrete as you may believe
14:07:26 <SamB_XP> ehtom: why do you say "once"
14:07:31 <ehtom> haha
14:07:35 <SamB_XP> I thought it was still f'd up
14:07:45 <ziman> physics is a theory, so talking about *laws* of physics is ok, in my opinion
14:07:48 <ehtom> well, there is a controvertial axiom
14:08:04 <matthew-_> ehtom: that's pretty ironic given the properties of concrete :P
14:08:37 <dons> http://www.reddit.com/r/programming/comments/73c3r/visualising_800_haskell_libraries/
14:08:40 <lambdabot> Title: Visualising 800 Haskell libraries : programming, http://tinyurl.com/4o57fz
14:08:40 <dons> woot
14:08:51 <cjs> @yow
14:08:51 <lambdabot> Maybe we could paint GOLDIE HAWN a rich PRUSSIAN BLUE --
14:09:18 <lament> dons: pretty!
14:09:42 <ehtom> matthew-_: as for the laws of physics... calling newton's laws "laws" is completely fine provided you're aware of the regions of validity
14:09:58 <dons> and yeah, we got a big old stack of libraries. watch out.
14:10:17 <matthew-_> dons: do you have a bigger version of that diagram?
14:10:37 <matthew-_> and it doesn't seem to be four-coloured ;)
14:10:56 <dons> http://blog.well-typed.com/wp-content/uploads/2008/09/package-sizes-all-crop.png
14:10:58 <matthew-_> ehtom: yep, fair enough, I totally agree with that.
14:10:58 <lambdabot> http://tinyurl.com/3z92av
14:11:16 <dons> there might be an svg versoin. chr1s ?
14:11:24 <matthew-_> dons: err, one with labels for all the dots?
14:11:34 * Cale replies to http://osnews.com/thread?331056
14:11:35 <lambdabot> Title: OSNews > Thread > "Haskell sucks." by axilmar
14:12:16 <sbahra> ehtom, I think it isn't only 1, but a lot of things.
14:12:18 <palmerc> when you write: parse cs | newcs == [] = t where (t,newcs)=parse_expr cs, this means newcs must be an empty list and t is what is going to be defined by the returned tuple
14:12:26 <sbahra> ehtom, but you're probably referring to the axiom of choice.
14:12:28 <dons> matthew-_: oh, check with chr1s and eelco
14:12:33 <dons> they have the input .dot files
14:12:44 <matthew-_> ahh, .dot eh?
14:13:01 <palmerc> Graphviz
14:14:09 <palmerc> And would someone like to suggest a better way to do this http://pastebin.com/d4d8c4f9c?
14:14:15 <palmerc> And would someone like to suggest a better way to do this http://pastebin.com/d4d8c4f9c
14:14:28 <palmerc> The ? mark was probably a bad idea
14:15:33 <Cale> palmerc: Well, there's the more structured way, of using a parsing library.
14:15:47 <palmerc> I was told to not use a parsing library
14:15:51 <Cale> ah, okay
14:15:54 <palmerc> I was hoping to make it clearer
14:16:04 <palmerc> I really think this looks tortured
14:16:18 <palmerc> and honestly I don't understand the mechanics
14:16:27 <Cale> okay
14:16:28 <palmerc> I have a feeling of what it is doing
14:16:48 <dons> hey guys, mod it up, the graph is awesome, http://www.reddit.com/r/programming/comments/73c3r/visualising_800_haskell_libraries/ :)
14:16:49 <lambdabot> Title: Visualising 800 Haskell libraries : programming, http://tinyurl.com/4o57fz
14:17:00 <Cale> Well, there are a lot of unhandled cases too...
14:17:31 <palmerc> I am sure
14:18:18 <palmerc> This appeared in a paper
14:19:47 <palmerc> http://arxiv.org/pdf/0808.2953
14:20:08 <palmerc> The paper is called Declarative Combinatorics ...
14:21:55 <palmerc> Cale: How do you know there are lots of unhandled cases
14:22:16 <FunctorSalad> hmm I thought implementing gfoldl is sufficient for data?
14:22:20 <Cale> palmerc: Well, I can't be certain that they'll never happen without checking. There are patterns which you're not matching against.
14:22:22 <dmwit_> Any better definition for this? onFirst f (a, b, c) = (f a, b, c)
14:22:25 <FunctorSalad> (class Data)
14:22:26 <dmwit_> :t fmap :: (a -> a') -> (a, b, c) -> (a', b, c)
14:22:27 <lambdabot>     Could not deduce (Functor ((,,) a' b)) from the context ()
14:22:27 <lambdabot>       arising from a use of `fmap' at <interactive>:1:0-3
14:22:27 <lambdabot>     Possible fix:
14:22:34 <Cale> palmerc: In particular, the empty list, in each case.
14:22:55 <Cale> palmerc: Or the case for parse_pairs when newcs is nonempty.
14:23:23 <rwbarton> It looks like that parse_pars function is intended to fail if its input isn't a balanced string of parentheses
14:23:34 <FunctorSalad> I implemented just gfoldl and ghc is throwing warnings at me :o
14:23:57 <palmerc> so for example pars_expr [] = [] should be there?
14:24:14 <palmerc> yes it should fail if the parens aren't balanced
14:24:50 <Cale> palmerc: Which would probably excuse you from handling those cases, but I usually like to program in a way which doesn't just bottom out when things fail.
14:25:36 <FunctorSalad> by the way, it refuses to derive Data for my GADT, yet the code of the instance declaration is exactly as for usual datatypes
14:25:39 <palmerc> Umm could you offer a suggestion on how to avoid that?
14:26:03 <rwbarton> Is Conal's name really Connan, or is that paper misspelling it?
14:26:12 <Deewiant> functions like "f (Just (Left 1, [_,_,x]), Nothing) = x + 2; f _ = undefined" are the best
14:26:22 <Cale> palmerc: In this case, it would involve changing the type of parse_pairs, so that it gives  Maybe T
14:26:49 <Cale> rwbarton: afaik, Conal's name is Conal :)
14:27:22 <SamB_XP> Cale: that seems like a reasonable assumption
14:28:03 <Cale> This code is not exceptionally difficult to read, but I would probably find 'let' more natural than 'where' in at least the helpers.
14:28:06 <chr1s> dcoutts: http://blog.tupil.com/a-small-mashup-of-upcoming-and-lastfm-in-haskell/
14:28:07 <palmerc> so parse_pairs :: String -> Maybe T
14:28:08 <lambdabot> Title: Tupil Code Blog ¬ª Blog Archive ¬ª A small mashup of Upcoming and Last.fm, in Ha ..., http://tinyurl.com/5d8jx7
14:28:12 <Cale> palmerc: right
14:28:35 <Cale> palmerc: Where the expectation is that if the string is not a bunch of balanced parens, it gives Nothing
14:29:02 <palmerc> how do you use let in place of where?
14:30:14 <dcoutts> chr1s: nice
14:30:32 <conal> rwbarton: which paper?
14:31:03 <quicksilver>  that latex ICFP contest entry is quite something.
14:31:14 <quicksilver> now *that* is a trick worthy of a discerning hacker.
14:31:41 <dmwit> ?src maximum
14:31:41 <lambdabot> maximum [] = undefined
14:31:42 <lambdabot> maximum xs = foldl1 max xs
14:31:52 <dmwit> Oh, it's a left fold.
14:32:03 <Cale> palmerc: something like this? (untested) http://pastebin.com/m13de8607
14:32:41 <Cale> Now, we still haven't handled a couple of empty cases.
14:33:33 <Cale> If you don't want to handle them at all, you can just change  (t,[]) -> Just t  into (t,[]) -> t, and delete the Nothing case, and it'll probably be fine
14:34:03 <dmwit> :t mconcat
14:34:04 <lambdabot> forall a. (Monoid a) => [a] -> a
14:34:32 <Cale> If you want to handle failure in a consistent way, the cleanest thing would be to use Maybe as a monad.
14:35:06 <dmwit> Monoid laws?  associativity, commutativity, mzero is the identity, any others?
14:35:18 <Cale> dmwit: not commutativity
14:35:27 <dmwit> Ah, good.
14:35:35 <Cale> dmwit: associativity, mempty is the identity, and that's it.
14:35:45 <dmwit> Excellent!
14:36:05 <dmwit> ?src mconcat
14:36:05 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:36:16 <dmwit> ?source Data.Monoid
14:36:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
14:39:05 <dmwit> huh
14:39:06 <Cale> palmerc: here's roughly what it would look like using the Maybe monad: http://pastebin.com/m58fbc6c9
14:39:27 <Cale> (I hope that's all correct, I've tried to be careful about the transformations, but I haven't actually run ghci on it :)
14:39:30 <dmwit> Did you know import Data.Monoid(Monoid(mappend)) is just as valid as import Data.Monoid(Monoid, mappend), according to GHC?
14:39:41 <palmerc> I am trying that
14:40:18 <quicksilver> no, but I'm not entirely surprised.
14:40:22 <rwbarton> http://arxiv.org/pdf/0808.2953
14:40:28 <palmerc> unfortunately i am trying to figure out parse errors
14:40:30 <rwbarton> conal: ^^
14:40:34 <quicksilver> that means you can import a method without importing the fact that it is a method.
14:40:37 <quicksilver> which makes sense.
14:40:39 <Cale> palmerc: oh, in my code?
14:40:40 <palmerc> Yeah the Paul Tarau paper
14:40:48 <palmerc> What do you think?
14:40:53 <palmerc> Cale: yes
14:40:57 <Cale> ...
14:40:59 <palmerc> Cale: but that might be me
14:41:11 <Cale> Sorry about that, where?
14:41:28 <Cale> It's probably something embarrassing :)
14:41:34 <palmerc> Cale: I am sure it is me
14:42:14 <Cale> my latest paste is fine, at least... it loads in ghci
14:42:33 <Cale> Seems to work as well :)
14:42:51 <palmerc> Cale: oh i will try that
14:43:32 <Cale> the other one does too...
14:43:37 <Cale> Where are you copy-pasting from?
14:43:47 <Cale> I find the edit box at the bottom is the easiest.
14:43:56 <palmerc> Cale: Oh that may because I tried 'reformatting' it
14:44:01 <Cale> (or possibly click the download link)
14:44:38 <Cale> palmerc: The vertical alignment of things is important.
14:44:43 <Baughn> ..if I didn't know beter, I'd say darcs pipelining patches is suddenly working
14:44:57 <palmerc> Cale: like in python
14:45:06 <palmerc> Cale: although python is easier :)
14:45:10 <Cale> palmerc: Also, make sure that your editor isn't surreptitiously placing tabs in the file.
14:45:23 <Cale> (because those tend to screw everything up real good)
14:45:25 <palmerc> my editor is vi
14:45:28 <palmerc> :)
14:45:31 <Cale> :set expandtab
14:45:57 <Cale> and possibly also smarttab
14:46:09 <palmerc> So it now gives Just
14:47:14 <Cale> when it succeeds
14:47:18 <Cale> and Nothing, when it fails
14:47:38 <Cale> (rather than throwing a horrible uncatchable exception)
14:47:55 <Cale> (well, not *quite* uncatchable, but hard to catch anyway:)
14:48:29 <ddarius> What you do is sic you dog on them and stay where you are.  They'll run around but eventually come back to where they were.
14:49:01 <Baughn> ddarius: A good idea, but there is no Dog library on hackage
14:50:33 <stepcut> is there a way to rewrite this type synonym to be 'pointfree', type Tup a = Maybe (String, a), aka, something like, type Tup' = Maybe . ((,) String)
14:50:35 <palmerc> Cale: That looks great
14:51:40 <Cale> stepcut: Using Conal's TypeCompose, I suppose there is :)
14:51:40 <dmhouse> stepcut: type synonyms can't be beta-reduced.
14:51:55 <Cale> stepcut: Except you don't quite end up with a synonym :)
14:52:04 <Cale> (you end up with a newtype)
14:52:41 <stepcut> or alternatively, how else can I use, newtype Fix f = In { out :: f (Fix f) }, to do, Fix (Maybe ((,) String)).  I can do it with newtype, but I wonder if there is a way to do it without ?
14:52:55 <Cale> I don't think so.
14:53:02 <stepcut> Cale: ok
14:54:33 <Cale> type synonyms are fairly weak anyway, and reqiure all their parameters (except with some GHC extensions, in the case of class declarations, and even that doesn't give you any additional expressive power)
14:54:43 <Cale> er, instance declarations, I mean
14:56:05 <stepcut> Cale: But, even with out type synonyms, I can't create a value of type, Fix (Maybe ((,) String)), unless i use a newtype ?
14:56:50 <dolio> That's not correctly kinded, is it?
14:56:57 <dolio> (,) String :: * -> *
14:57:03 <dolio> Maybe :: * -> *
14:57:33 <dolio> So Maybe ((,) String) gives a kind mismatch of * against * -> *
14:58:07 <dolio> You want: Fix (Maybe `O` (,) String)
14:58:20 <dolio> Where O is type composition.
14:58:38 <stepcut> dolio: right, that is what I originally asked, but I used . instead of `O`
14:59:23 <stepcut> dolio: well, the . got dropped along the way. But in any case, that is my desire, I just don't know if it can be done
14:59:34 <dolio> I think it can.
14:59:53 <dolio> Although using that type will involve a lot of wrapper constructors.
14:59:54 <stepcut> dolio: it is annoying that I can do, (Fix Maybe), (Fix []), and (Fix ((,) String)), but I can't Figure out, (Fix (Maybe `O` ((,) String)))
15:00:24 <dolio> newtype O f g a = O (f (g a))
15:00:59 <stepcut> my aim is to write, e' = In (Just ("hello, ", In (Just ("world.", In Nothing)))), but I don't think I can do that with out a newtype
15:01:11 <stepcut> newtype Tup a = Tup (Maybe (String, a))
15:01:11 <stepcut> e = In (Tup (Just ("hello, ", In (Tup (Just ("world.", In (Tup Nothing)))))))
15:01:55 <palmerc> Cale: so to for c == '(', if i want to have an alternative that grabs text can I add a second guard?
15:01:56 <dolio> e = In (O (Just ("hello, ", In (O (Just ("world.", In (O Nothing)...)
15:02:11 <stepcut> dolio: yeah, that is what I came up with
15:02:24 <stepcut> dolio: though, your newtype is a bit more general than mine, which is useful
15:15:12 <dmwit> Hackage is giving me trouble.
15:15:16 <shapr> @users
15:15:17 <lambdabot> Maximum users seen in #haskell: 516, currently: 488 (94.6%), active: 15 (3.1%)
15:15:27 <dmwit> It says: "could not extract yeganesh-2.1 directory from yeganesh-2.1.tar.gz".
15:15:30 <shapr> whee
15:15:32 <shapr> @users
15:15:32 <lambdabot> Maximum users seen in #haskell: 516, currently: 488 (94.6%), active: 15 (3.1%)
15:15:48 <dmwit> Could somebody sanity check me and extract http://www.dmwit.com/yeganesh/yeganesh-2.1.tar.gz?
15:16:03 <dmwit> (It has a yeganesh-2.1 directory here, as far as I can tell.)
15:16:29 <geezusfreeek> oops
15:16:41 <geezusfreeek> vmware's unity feature doesn't like xmonad
15:16:44 <geezusfreeek> :\
15:18:16 <geezusfreeek> in fact, nothing about vmware likes xmonad
15:18:35 <geezusfreeek> (running xmonad on the host, that is, not the guest)
15:19:17 <newsham> 3% activity.  wow.
15:19:38 * BMeph is looking at the yeganesh folder's contents...on a Windoze machine!
15:19:58 <dmwit> BMeph: Okay, so... hackage is just wrong, right?
15:21:52 <palmerc> :quit
15:22:24 <BMeph> dmwit: I guess - it isn't letting you upload? :)
15:22:50 <dmwit> I suppose I could probably upload it, but even if I did, I doubt it would show the correct information.
15:23:09 <dmwit> I'd rather hackage left yeganesh at the 2.0 version than hose down the page with wrong 2.1 info. =P
15:23:38 <dmwit> I don't know who to complain to, either...
15:24:03 <dmwit> I guess their bug tracker.
15:25:24 <dmwit> ...which I also can't do.
15:25:26 <dmwit> bah
15:26:16 <Saizan> dmwit: can't do == i've to login?
15:26:26 <dmwit> yes
15:26:43 <dmwit> I tried the obvious guest/guest guest/password etc., and they don't seem to work.
15:26:59 <Saizan> http://hackage.haskell.org/trac/hackage/ <-- see The Bug Tracker here
15:27:06 <lambdabot> Title: Hackage - Trac
15:27:22 <dmwit> Ah, thanks.
15:36:05 <Botje> any way to get the equivalent of DBL_MIN in haskell?
15:37:03 <Botje> hmm
15:37:08 <Botje> i found http://www.haskell.org/pipermail/haskell/2003-October/012926.html
15:37:09 <lambdabot> Title: Enum on Float/Double
15:37:11 <Botje> but elegant it is not :)
15:40:10 <dmwit> > last . takeWhile (>0) $ iterate (/2) 1
15:40:11 <lambdabot>   5.0e-324
15:40:17 <dmwit> > last . takeWhile (>0) $ iterate (/2) 1 :: Float
15:40:18 <lambdabot>   1.0e-45
15:40:24 <dmwit> Is that elegant enough for you? =)
15:40:27 <Botje> uhh
15:40:28 <Botje> well :)
15:40:37 <Botje> DBL_MIN is roughly 2e-308
15:40:50 <dmwit> Oh, what's DBL_MIN, then?
15:41:09 <Botje> it's the theoretical lower bound of a double in C
15:41:14 <Botje> if i understood correctly
15:42:32 <dmwit> I don't think so.
15:42:45 <dmwit> My test.c shows that 5e-324 is representable as a Double.
15:43:54 <Igloo> Is it an 80 vs 64-bit double thing?
15:44:50 <dmwit> In fact, C shows me that it can do 4.94066e-324, so let's see here:
15:44:56 <dmwit> > 4.94066e-324 :: Double
15:44:57 <lambdabot>   5.0e-324
15:45:05 <dmwit> > 4.9e-324 :: Double
15:45:06 <lambdabot>   5.0e-324
15:45:07 <tromp> that shld not be representable in any finite number of bits
15:45:47 <dmwit> > 94066 % 100000
15:45:48 <lambdabot>   47033%50000
15:46:08 <dmwit> tromp: *shrug* I'll paste my code.
15:46:30 <dmwit> http://hpaste.org/10653
15:46:48 <tromp> 0.05 isn't representable in a finite number of bits either
15:46:59 <dmwit> tromp: That's just not true.
15:47:04 <dmwit> tromp: Remember, we have a mantissa.
15:47:21 <tromp> what is 0.05 in binary?
15:47:30 <dmwit> 0.1 * 10^(-1)
15:47:31 <olsner> > last . takeWhile (/= 0.0) . iterate (/2) $ 1.0
15:47:32 <lambdabot>   5.0e-324
15:48:00 <tromp> what is 10^-1 in binary?
15:48:02 <dmwit> or even 101 * 10^(-2), if you prefer
15:48:15 <sjanssen> > decodeFloat 4.94066e-324
15:48:15 <dmwit> tromp: The -1 is stored in the mantissa, no?
15:48:16 <lambdabot>   (4503599627370496,-1126)
15:48:21 <sjanssen> > decodeFloat 4.9e-324
15:48:22 <lambdabot>   (4503599627370496,-1126)
15:48:31 <dmwit> Oh, no.
15:48:32 <dmwit> You're right.
15:48:34 <sjanssen> what is with all the extra spaces here?
15:48:42 <tromp> no, floating points is mantissa * 2^exponent
15:48:48 <dmwit> You're right, you're right.
15:49:02 * [R]ayne Gives sjanssen a cookie :).
15:49:13 <ddarius> > decodeFloat minBound
15:49:14 <FunctorSalad> for a type A, the number of "->" in expressions of the form "A = B -> C -> D -> ... -> Y" is bounded, right?
15:49:14 <lambdabot>   Add a type signature
15:49:21 <dmwit> tromp: Still, you can't argue with the code.
15:49:34 <ddarius> > decodeFloat (minBound :: Double)
15:49:35 <lambdabot>       No instance for (Bounded Double)
15:49:35 <lambdabot>        arising from a use of `minBound...
15:49:35 <dmwit> tromp: That code outputs "4.94066e-324" whether you understand why or not. =)
15:49:44 <FunctorSalad> (so I can do induction on the "length" of A)
15:49:51 <tromp> only integers times 2^-n have exact representations
15:50:20 <olsner> *rationals with a power-of-two denominator?
15:50:31 <dmwit> olsner: same thing
15:50:53 <olsner> :)
15:51:40 <EvilTerran> <dmwit> 0.1 * 10^(-1)  <- is that "10" a 2 in binary?
15:51:44 <ddarius> *dyadic rationals?
15:52:03 <dmwit> EvilTerran: I've already admitted I was wrong with that line.
15:52:07 <EvilTerran> ah, sorry
15:52:10 <dmwit> =)
15:52:10 <EvilTerran> was scrolled up
15:52:37 <EvilTerran> FunctorSalad, yes, as all types must be finite
15:53:08 <FunctorSalad> a type with A = A -> A would refute it but istr that that's impossible in simply typed lc
15:53:36 <FunctorSalad> there are other possible counterexamples though
15:53:36 <EvilTerran> indeed. that would be an infinite type :)
15:53:48 <FunctorSalad> how is "infinite" defined here?
15:54:03 <olsner> hmm, has anyone built a language with lazily evaluated typechecking as well as normal lazy evaluation?
15:54:07 <dmwit> The simply-typed lambda calculus only allows inductively defined types.
15:54:22 <dmwit> That is, any given type has a finite reason for existing... and hence is finite itself.
15:54:32 <FunctorSalad> ok, that makes sense
15:54:38 <dmwit> You could also have a calculus in which any type exists unless there is a finite reason for it not to.
15:54:48 <dmwit> In that case, you can get infinite types. =)
15:54:53 * EvilTerran boggles
15:55:10 * dmwit was just reading about coinduction -- very cool stuff
15:55:28 <FunctorSalad> so that calculus has been done, dmwit? :)
15:55:33 <olsner> hmm, that'd be interesting too, a language where you don't specify the type that anything *is*, only what it is *not*
15:56:00 <dmwit> FunctorSalad: I guess that depends on what you mean by "done". =P
15:56:03 <EvilTerran> that sounds obfuscated
15:56:43 <olsner> yes, perhaps that's something for #esoteric
15:56:59 * [R]ayne Gives EvilTerran a cookie also :).
15:57:23 <chrisdone> type Char = Not [Char]
15:57:28 <FunctorSalad> I think with that I should be able to prove that the "deep postcomposition" of a function of type A with a function of type Y -> Y2 is well-defined
15:57:38 <FunctorSalad> since Y can only match one tail of A
15:57:44 <EvilTerran> um, ok :)
15:59:10 <FunctorSalad> with that I mean we have f :: B -> C -> .... -> Y and g :: Y -> Y2 and produce a B -> C -> ... -> Y2 in the evident way
15:59:26 <dmwit> Oh, wow, I feel silly.
15:59:37 <dmwit> "Hackage accepts tar files, not gzipped tar files."
15:59:39 <dmwit> duh
15:59:57 <chrisdone> duurr hur hur
16:00:12 <chrisdone> @users
16:00:13 <lambdabot> Maximum users seen in #haskell: 516, currently: 464 (89.9%), active: 18 (3.9%)
16:00:32 <chrisdone> @quote dmwit
16:00:32 <lambdabot> dmwit says: Nobody quickcheck'd that @babel de en . @babel en de === id.
16:00:33 <sjanssen> dmwit: you should use 'Setup sdist' anyway
16:00:57 <sjanssen> (make sure you've listed the necessary files in your .cabal first)
16:06:40 <flyback> how did sethk die? and how old was he?
16:06:59 * flyback just wants to make sure he wasn't someone he knew on irc yrs ago
16:08:43 <FunctorSalad> is there some name for this maximum number of "->"s? order? rank?
16:09:29 <dmwit> arguments?
16:09:40 <dmwit> Rank is not really the same, I think.
16:09:42 <EvilTerran> FunctorSalad, you can have as many as you like, it just has to be a finite number
16:09:43 <olsner> arity?
16:09:50 <EvilTerran> or am i misunderstanding you?
16:09:54 <dmwit> Arity sounds good.
16:10:01 <EvilTerran> arity works, yeah
16:10:23 <FunctorSalad> EvilTerran: I mean the maximum number of "->" in expressions equal to a fixed type A
16:10:23 <olsner> @localtime
16:10:24 <lambdabot> Local time for olsner is Thu Sep 25 01:15:11
16:10:34 <EvilTerran> hm
16:10:37 <dmwit> olsner: Go to bed!
16:10:40 <olsner> weird, my clock applet says 1:14
16:10:57 <olsner> dmwit: I'm going to!
16:11:17 <olsner> I'm just a bit too skittish to actually sleep right now
16:11:23 <FunctorSalad> okay, "arity" does sound right
16:15:45 <Plareplane> @localtime
16:15:45 <lambdabot> Local time for Plareplane is Wed Sep 24 17:15:45
16:18:31 <dmwit> ?localtime
16:18:32 <lambdabot> Local time for dmwit is I like fish!
16:18:52 <EvilTerran> o.O
16:20:47 <byorgey> ?localtime
16:20:50 <lambdabot> Local time for byorgey is Wed Sep 24 19:20:48 2008
16:20:56 <byorgey> oooooookay
16:21:25 <dmwit> You can reply anything you want to a CTCP TIME, of course
16:21:39 <dmwit> Just because most clients do the right thing doesn't mean nobody can hijack it. =)
16:21:49 <sjanssen> @localtime
16:21:52 <lambdabot> Local time for sjanssen is Wed Sep 24 18:21:55 2008
16:21:52 <byorgey> hehe, I see =)
16:21:52 * [R]ayne Gives byorgey a cookie. :)
16:22:05 <byorgey> thanks [R]ayne!
16:22:05 <[R]ayne> @localtime
16:22:13 <lambdabot> Local time for [R]ayne is Wed Sep 24 18:22:16 2008
16:22:15 <sjanssen> hmm, can I forge a reply?
16:22:39 <dmwit> sjanssen: Sure, see my ?localtime above. =)
16:23:37 <sjanssen> dmwit: actually, what I'm wondering is if we can get lambdabot to print the "local time" business even if @localtime hasn't been issue
16:23:41 <sjanssen> d
16:23:58 <dmwit> Ah!
16:24:01 <dmwit> That's interesting.
16:24:04 <sjanssen> probably not
16:24:12 * sjanssen digs out the source
16:24:56 <sjanssen> lambdabot keeps a map of Nick -> [Nick] (the [] is where to send replies)
16:25:15 <sjanssen> so lambdabot will only announce the time if @localtime has been called
16:26:31 <SamB_XP> @localtime SamB_XP
16:26:33 <lambdabot> Local time for SamB_XP is Yesterday
16:26:57 <SamB_XP> you CAN reply manually, though ;-P
16:27:22 <sjanssen> not nearly as fun
16:39:54 <marcot> Hello, is there a function like getDirectoryContents, but that does this recursively, like find?
16:46:32 <FunctorSalad> @localtime
16:46:33 <lambdabot> Local time for FunctorSalad is ‚àû
16:46:39 <FunctorSalad> ;-)
16:58:04 <hackage> Uploaded to hackage: yeganesh 2.1
17:00:46 * flyback goes to cook a steak
17:11:57 <dons> ?users
17:11:58 <lambdabot> Maximum users seen in #haskell: 516, currently: 462 (89.5%), active: 12 (2.6%)
17:24:57 <FunctorSalad> hmm... if ghc doesn't throw an error about fundeps, does that mean that it has proven that the fundeps hold?
17:25:12 <Heffalump> FunctorSalad: yes
17:25:24 <Heffalump> (where "prove" is a rather strong word for a simple check)
17:25:24 <FunctorSalad> is it that simple?
17:25:25 <FunctorSalad> I'm still a bit too confused about the various flags too see which ones would make it undecidable
17:25:40 <Heffalump> fundep checking isn't undecidable, but type class instance selection canbe
17:26:00 <Heffalump> with UndecidableInstances
17:26:21 <FunctorSalad> so even then fundep checking is decidable?
17:26:23 <Heffalump> I would expect so, though I'm not 100% certain.
17:26:29 <Heffalump> I can't see why they wouldn't be.
