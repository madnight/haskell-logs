00:01:32 <dmwit> Ah, it's kind of like a combination of nl and grep.
00:01:58 <adu> dmwit: my goal was grep+head+tail+cut
00:03:40 <dmwit> I still prefer ack, I think.
00:06:02 <adu> I think i've heard of that before
00:08:32 <adu> dmwit: its complaining about ABCD
00:09:02 <dmwit> ABCD?
00:09:06 <dmwit> What is complaining?
00:09:09 <ivanm> EFGH?
00:09:12 <ivanm> ;-)
00:09:43 <adu> http://hpaste.org/10539
00:10:19 <dmwit> ghc --version?
00:10:39 <adu> eh, just warnings
00:10:42 <dmwit> Also, those are only warnings.
00:10:42 <dmwit> yeah
00:11:54 <adu> ew
00:12:04 <adu> why did it install in ~/.cabal/bin
00:12:08 <adu> no one ever does that
00:12:24 <dmwit> yeah =/
00:12:48 <dmwit> You have to give it root privileges to get it to end up in /usr/local/bin
00:13:08 <adu> I did, and it still installed in ~/.cabal/bin
00:13:19 <ivanm> adu: did you tell it to do a global install?
00:13:28 <adu> do
00:13:30 <adu> no
00:13:48 <adu> why would I have to do that when its been the default for every other package I've used?
00:15:09 <quicksilver> the default for cabal install is user, not global.
00:15:20 <quicksilver> that may have changed in a recent version?
00:15:36 <adu> why?
00:18:36 <adu> how do I perform a global install?
00:19:16 <musty> global install?
00:19:41 <dons> adu: --global
00:19:47 <dons> sprinkle sudo
00:19:59 <adu> dons: so bootstrap.sh --global?
00:20:26 <dons> oh. just make i think.
00:21:14 <adu> this is too confusing
00:22:08 <dmwit> adu: Yes, sudo source bootstrap.sh --global
00:22:26 <ttt--> hi, i installed yampa with cabal install, but the examples still give an error on load
00:22:50 <dmwit> ttt--: Hmmm.  Maybe the examples are using some extensions that you haven't enabled?
00:22:57 <dmwit> Almost certainly, now that I think about it!
00:23:05 <dmwit> ttt--: Try with -farrows or whatever that option is.
00:23:12 <adu> noooo, its downloading everything again
00:23:40 <ttt--> Elevator/Elevator.hs:44:26: parse error on input `->'
00:24:00 <dmwit> ttt--: Use "ghci -farrows", it's almost certainly what's wrong.
00:25:46 <adu> http://hpaste.org/10539#a1
00:25:59 <adu> its not working
00:27:35 <dmwit> bah
00:27:39 <dmwit> That's silly.
00:28:04 <adu> do I have to manually reconfigure it with --prefix=/usr/local ?
00:28:20 <ttt--> dmwit, that did it! thanks
00:32:20 <adu> sed -i '' -e s/--user/--global/g bootstrap.sh
00:32:23 <adu> that works
00:33:25 <melkart> hello. is there an haskell interpreter as a web application somewhere?
00:34:50 <dmwit> > "right here"
00:34:51 <lambdabot>   "right here"
00:34:57 <dmwit> ?go web front end lambdabot
00:34:58 <lambdabot> No Result Found.
00:35:04 <dmwit> aw, shucks
00:35:09 <ziman> or you can use codepad.org
00:43:01 <melkart> thank you, codepad.org is good
00:49:36 <adu> noooo
00:49:47 <adu> why is it putting stuff in ~/.cabal/lib?
00:49:55 <jsnx> i can't get codepad to working
00:50:11 <adu> I told it to install to /usr/local/lib
00:50:17 <jsnx> adu: there's some global install stuff in the config file, but i can't make it work
00:50:31 <jsnx> adu: how did you do that?
00:50:45 <dmwit> jsnx: codepad requires a full program, so be sure to include a "main"
00:50:46 <adu> http://hpaste.org/10539#a2
00:50:51 <electronx> :t hcat
00:50:52 <lambdabot> [Doc] -> Doc
00:51:16 <dmwit> jsnx: e.g. http://codepad.org/tZ6FuCLq
00:57:43 <TommyOnMac> is it 1st of April?
00:57:52 <TommyOnMac> ATS beats everything on shootout
00:59:28 <electronx> Tommy wich shootout?
00:59:34 <electronx> which*
00:59:43 <ivanm> @where shootout
00:59:43 <lambdabot> http://shootout.alioth.debian.org/
01:00:00 <mr_ank> depends on the platform, doesn't it?
01:00:46 <ivanm> never heard of ATS before :s
01:01:25 <electronx> faster then gcc???
01:01:58 <ivanm> it's syntax looks weird though :s
01:03:13 <TommyOnMac> quick, someone make a hs2ats translator
01:03:48 <electronx> it doesn't matter haskell will get this fast with time anyway
01:05:11 <TommyOnMac> people in all lang channels say things like that
01:05:28 <ivanm> even #brainfuck? :o
01:05:49 <TommyOnMac> never been in there :)
01:06:25 <electronx> there is no reason why haskell can't get there
01:06:26 * adu <3 BF
01:06:28 <aempirei> http://www.haskell.org/tutorial/monads.html section 9.2
01:06:29 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
01:06:30 <TommyOnMac> see you in #ats losers! ;)
01:06:34 <aempirei> the code example doesnt work
01:06:43 <aempirei> do x <- [1,2,3] y <- [1,2,3] True <- return (x /= y) return (x,y)
01:06:56 <aempirei> there sould be new lines
01:07:00 <aempirei> mispaste
01:07:47 <adu> aempirei: do you need help?
01:09:21 <aempirei> well the example doesnt compile
01:09:42 <aempirei> im just wondering why
01:10:25 <adu> aempirei: works for me
01:11:31 <aempirei> odd
01:11:35 <adu> aempirei: http://hpaste.org/10540
01:12:09 <adu> how were you trying to compile it?
01:13:44 <adu> > do x <- [1,2,3] ; y <- [1,2,3] ; True <- return (x /= y) ; return (x, y)
01:13:45 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
01:13:58 <adu> you can even use ghci
01:14:15 <adu> and lambdabot
01:15:22 <adu> aempirei: a more advanced answer might be that you didn't supply the boilerplate code like "module Main where"?
01:15:30 <jsnx> TommyOnMac: it looks beastly
01:15:42 <jsnx> TommyOnMac: but the dependent types are cool
01:16:03 <adu> aempirei: or that the Monad the "do" is doing is the list monad, and the main function requires an IO Monad?
01:17:26 <aempirei> ok i see the problem now thanks
01:17:45 <aempirei> i getthat now
01:18:56 <ziman> > maxBound :: Int + 1
01:18:57 <lambdabot>       No instance for (Show (+ Int Unit))
01:18:57 <lambdabot>        arising from a use of `show'...
01:28:08 <quicksilver> > (+)
01:28:09 <lambdabot>       Overlapping instances for Show (a -> a -> a)
01:28:09 <lambdabot>        arising from a use ...
01:43:52 <electronx> is it a good idea to write a search engine in haskell?
01:46:16 <adu> if you want to maintain this search engine, yes
01:47:38 <jinjing> @bot
01:47:39 <lambdabot> :)
01:47:42 <jinjing> @bot
01:47:42 <lambdabot> :)
01:48:01 <jinjing> @bot
01:48:01 <lambdabot> :)
01:50:55 <Axman6> jinjing: you right there?
01:51:40 <jinjing> Axman6: yes
01:56:35 <electronx> adu: i mean speed wise etc
01:56:50 <electronx> and lots of string operations
01:57:11 <electronx> maybe thats the bad thing about haskell string operations aren't so good
01:59:39 <papermachine> electronx: that's what bytestrings are for
02:01:30 <jsnx> > do { l0 <- [0..9] ; (:[2]) }
02:01:31 <lambdabot>       The section `(: [2])' takes one argument,
02:01:31 <lambdabot>      but its type `[t]' has n...
02:01:37 <jsnx> > do { l0 <- [0..9] ; (:[2]) l0 }
02:01:39 <lambdabot>   [0,2,1,2,2,2,3,2,4,2,5,2,6,2,7,2,8,2,9,2]
02:02:08 <jsnx> the list monad is neat but it is hard for me to imagine a use for it
02:03:26 <dibblego> > "http://host/hello there" >>= (\c -> case c of ' ' -> "%20"; _ -> [c])
02:03:27 <lambdabot>   "http://host/hello%20there"
02:03:28 <jsnx> the above pattern is essentially concat map
02:03:40 <dibblego> yes concat/map gives rise to bind
02:03:53 <jsnx> dibblego: oh, interesting
02:03:55 <electronx> bytestring aren't really good for unicode?
02:04:05 <dibblego> join = concat
02:04:09 <dibblego> fmap = map
02:04:18 <jsnx> electronx: you need to use them in conjunction with an encoding package
02:04:19 <dibblego> join + fmap -> bind
02:05:16 <jsnx> dibblego: now i can replace all uses of concatMap with >>= !
02:05:29 <dibblego> jsnx, with =<< actually, since concatMap is flipped
02:06:08 <jsnx> aha
02:06:12 <dibblego> @type \x f -> join (fmap f x)
02:06:13 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
02:06:17 <dibblego> @type (>>=)
02:06:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:11:37 <jsnx> > do { l0 <- [0..9] ; l1 <- (:[2]) l0 ; (:[3]) l1 }
02:11:38 <lambdabot>   [0,3,2,3,1,3,2,3,2,3,2,3,3,3,2,3,4,3,2,3,5,3,2,3,6,3,2,3,7,3,2,3,8,3,2,3,9,...
02:12:13 <jsnx> hmm
02:13:25 <dibblego> @check \f x -> (f =<< x) == f `concatMap` x
02:13:26 <lambdabot>       Overlapping instances for Show (a -> [b])
02:13:26 <lambdabot>        arising from a use of ...
02:13:33 <dibblego> @check \f x -> (f =<< x) == (f `concatMap` x)
02:13:34 <lambdabot>       Overlapping instances for Show (a -> [b])
02:13:34 <lambdabot>        arising from a use of ...
02:13:53 <Deewiant> it has to be able to print f in case it runs into a case which doesn't work
02:13:56 <dmwit> > [c | a <- [0..9], b <- [a, 2], c <- [b, 2]]
02:13:57 <lambdabot>   [0,2,2,2,1,2,2,2,2,2,2,2,3,2,2,2,4,2,2,2,5,2,2,2,6,2,2,2,7,2,2,2,8,2,2,2,9,...
02:14:22 <dibblego> why can it no longer print f?
02:14:25 <dmwit> Whoops, that last 2 should be a 3. heh
02:15:00 <Deewiant> f is a function so it doesn't have a standard show instance, and evidently something's mucked up since it says it has overlapping instances
02:15:29 <Deewiant> 2008-09-20 12:15:09 (lambdabot)      Matching instances:
02:15:29 <Deewiant> 2008-09-20 12:15:09 (lambdabot)        instance (Typeable a, Typeable b) => Show (a -> b)
02:15:32 <Deewiant> 2008-09-20 12:15:09 (lambdabot)          -- Defined in ShowFun
02:15:33 <Deewiant> 2008-09-20 12:15:17 (lambdabot)        instance (Test.SmallCheck.Serial a, Show a, Show b) =>
02:15:36 <Deewiant> 2008-09-20 12:15:17 (lambdabot)                 Show (a -> b)
02:15:38 <Deewiant> 2008-09-20 12:15:17 (lambdabot)          -- Defined in Test.SmallCheck
02:15:43 <dmwit> aaagh
02:15:47 <Deewiant> somebody might want to do something about that :-/
02:16:02 <ziman> > \y -> x + y :: Expr
02:16:03 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
02:16:03 <lambdabot>        arising from a use...
02:16:25 <electronx> (\y -> x + y) :: Expr
02:16:32 <electronx> > (\y -> x + y) :: Expr
02:16:34 <lambdabot>       The lambda expression `\ y -> x + y' has one argument,
02:16:34 <lambdabot>      but its typ...
02:17:35 <jsnx> > do { a <- [0..9] ; b <- [0..9] ; guard $ a + b < 10 ; [(a, b)] }
02:17:37 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1...
02:24:51 <jsnx> so each binding in the list monad is sort of a "for all"
02:25:06 <jsnx> coupled with a concat
02:25:13 <jsnx> so you can do searchs
02:25:22 <jsnx> neat
02:27:17 <Stinger> mapconcat
02:27:38 <Stinger> or concatmap... one of those
02:29:34 <subconscious> concatMap
02:35:15 <besiria> :t concatMap
02:35:17 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
02:35:34 <subconscious> :t (=<<)
02:35:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:40:42 <dibblego> jsnx, you can say that about any monad
02:47:42 <_muke> regex-tdfa-0.94 says that it depends on multiple versions of bytestring, and fails compilation. How do I solve this?
02:51:06 <electronx> how do i see executions steps in ghci
02:51:36 <electronx> ie i want to see an execution trace of an expression
02:51:49 <ziman> @go ghci steps
02:51:51 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
02:51:51 <lambdabot> Title: 3.5.ï¿½The GHCi Debugger
02:52:55 <ziman> i've never really used it, though
02:55:15 <electronx> thanks
02:55:57 <electronx> although its not what i need :(
02:56:36 <dmwit> electronx: Debug.Trace
02:56:42 <dmwit> But don't let it out that I told you.
03:01:20 <_muke> Im trying to build yi right now, but the regex-tdfa package that yi requires seems to have some dependency problems. Is this a know problem?
03:05:15 <thoughtpolice> _muke: I had no probelms installing yi-0.4.6 using cabal install
03:11:27 <FordCortina> hi, does anybody know of a way of getting ghc to report which registered libraries are no longer on the filesystem?
03:13:44 <ivanm> FordCortina: possibly ghc-pkg check
03:13:55 <ivanm> that will state which libraries have dependency problems...
03:14:47 <FordCortina> ivanm: i think it showing me which packages are registered.... but they are not necessarily on the filesystem
03:15:17 <dmwit> You've gone behind GHC's back!
03:15:19 <dmwit> oh noes
03:15:52 <FordCortina> i moved a bunch of folders into my /usr/local with Finder unfortunately Finder decided to actually remove what was already there :(
03:16:12 <FordCortina> and it didnt even just move those folders to the trash either
03:16:21 <FordCortina> just *poof* gone....
03:17:01 <FordCortina> i basically traded my haskell installation for a scala installation :(
03:17:13 <mc__> no good deal
03:17:16 <subconscious> progress!
03:17:31 <mc__> but thats just how unix works, it replaces folders, that is not finders fault
03:18:02 <dmwit> I'd probably just start GHC installing and ignore the system for a while.
03:18:07 <dmwit> Let it rewrite all its packages.
03:18:37 <FordCortina> mc__: really... if i had used the terminal... mv wouldnt have done that
03:18:47 <dmwit> Yes it would have.
03:18:57 <mc__> of course it would
03:19:09 <dmwit> It *might* have asked first, if you used mv -i.
03:19:40 <dmwit> ?go hole hawg unix
03:19:42 <lambdabot> http://www.team.net/mjb/hawg.html
03:21:04 <subconscious> how many ways does the regex  (A*)* match the string "AAAA"?
03:21:42 <mc__> 4 times?
03:21:58 <mc__> assueming that * has to be at least 1 character( not sure about that)
03:22:12 <ivanm> no, it means any number
03:22:15 <ivanm> + is at least 1
03:22:16 <subconscious> ok problem is that * can match 0 or more
03:22:22 <ivanm> yup
03:22:25 <subconscious> so {}* doesn't terminate
03:22:29 <mc__> oh i isee
03:22:30 <subconscious> aoeu
03:22:32 <ivanm> but how many it _will_ match depends on the regex engine
03:22:36 <FordCortina> dmwit: mc__ : ah, ic your both right. but mv basically stops you
03:22:40 <subconscious> and I don't know how to count that or not
03:22:48 <dmwit> subconscious: Why are you asking?
03:22:49 <ivanm> i.e. a lazy engine might cut out as soon as possible
03:22:58 <subconscious> so I counted 8 matches
03:23:48 <subconscious> but is that it?
03:23:56 <dmwit> (a+)+ matches aaaa 8 ways, yes.
03:24:10 <dmwit> But (a*)* matches aaaa in infinitely many ways.
03:25:18 <dmwit> FordCortina: mv only stops you because you don't have permissions on the destination files.
03:25:54 <FordCortina> dmwit: i was testing on my home folder
03:26:20 <FordCortina> dmwit: anyhow... ive got one heck of a mess to sort out
03:26:25 <FordCortina> ;(
03:26:29 <dmwit> =/
03:26:32 <dmwit> g'luck
03:26:36 <dmwit> I have to go to bed...
03:26:40 <dmwit> ?localtime
03:26:41 <lambdabot> Local time for dmwit is Sat Sep 20 06:27:55
03:26:45 <dmwit> yargh
03:26:49 <FordCortina> :S
03:27:21 <RayNbow> ?localtime
03:27:22 <lambdabot> Local time for RayNbow is Sat Sep 20 12:26:19 2008
03:29:45 <subconscious> http://hpaste.org/10541
03:29:47 <subconscious> this is my regex matcher
03:30:29 <subconscious> is it possible to make it always give every correct match and always terminate?
03:30:43 <subconscious> I am starting to think these two things exclude each other
03:34:18 <subconscious> no thoughts~
04:02:42 <BierSchaum> http://www.pennergame.de/change_please/2199735/
04:02:48 <lambdabot> Title: Pennergame
04:05:22 <Botje> urgh
04:05:24 <Botje> fucking spammers
04:09:59 <xci> hey guys, I need to define a long list, where the next value is the value of f(previous value). However, I need two consecutive values where n~10^10, which causes a problem, I cannot define this list recursively, as it'll blow its stack, and not in the manner of "sequ = 0:[x|x<-sequ]", as it'll go out of memory. It would be enough to just store the last two values, but my haskell experience does not allow me to come up with anything that would not use recursion or s
04:10:47 <subconscious> xci, using iterate didn't work because of lack of precision?
04:12:29 <BONUS> > take 10 $ iterate (*2) 2
04:12:31 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
04:13:01 <xci> subconscious: it goes out of memory in that case, too
04:13:12 <subconscious> xci, What gives you out of memory?
04:13:24 <subconscious> there are a couple reasons this could hapepn
04:13:38 <ziman> > (iterate (*2) 2) !! 100000
04:13:44 <lambdabot>   199800418602876901588806552866006718196085827810836338354305854772629166492...
04:13:46 <xci> yeah but as I
04:14:07 <xci> I'll have to call like (iterate (func) 0)!!(10^12)
04:14:40 <subconscious> xci, and what's the exact error message?
04:14:57 <xci>  out of memory (requested 1048576 bytes)
04:15:14 <subconscious> hm maybe you should hpaste the code, because currently it is not clear exactly what the problem is
04:15:26 <ziman> you're going to wait long :) and (!!) only supports Int arguments
04:15:33 <RayNbow> :t 10^12
04:15:36 <subconscious> > 10^12 :: Int
04:15:46 <ziman> it's negative
04:15:56 <lambdabot> forall t. (Num t) => t
04:15:57 <lambdabot>   1000000000000
04:16:44 <BONUS> :t genericIndex
04:16:45 <olsner> > maxBound :: Int
04:16:46 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
04:16:47 <lambdabot>   9223372036854775807
04:16:51 <olsner> 64-bit lambdabot :)
04:17:11 <xci> well, I am running on 64-bit system too
04:17:15 <xci> but yeah
04:17:21 <BONUS> [2,4..] `genericIndex` 8
04:17:26 <BONUS> > [2,4..] `genericIndex` 8
04:17:28 <lambdabot>   18
04:17:40 <RayNbow> I just tried locally...: iterate id 0 `genericIndex` (10^12)
04:18:25 <RayNbow> it's not good for your pagefile :p
04:18:53 <BONUS> ouch
04:19:34 <RayNbow> [0,0..] `genericIndex` (10^12) <-- this also hurts
04:20:29 <olsner> weird, is iterate too unlazy or is the indexing operators too unlazy?
04:20:41 <RayNbow> the latter
04:20:52 <RayNbow> they're too lazy
04:20:59 <BONUS> well the indexing operator doesn't know that it's all just zeros
04:21:01 <BONUS> it's not that smart
04:21:14 <RayNbow> *StrictIndex> iterate id 0 `strictIndex` 10^12
04:21:14 <RayNbow> 0
04:21:17 <olsner> well, but why does it have to keep a reference to the head of the list as it seems to?
04:21:33 <BONUS> does it?
04:21:39 <RayNbow> yes
04:21:57 <RayNbow> if each element of the list is defined in terms of the previous element...
04:22:13 <subconscious> xci, not going to hpaste ?
04:24:26 <RayNbow> http://hpaste.org/10542 <-- StrictIndex
04:24:32 <ziman> oh, then it's a list of gradually growing thunks
04:25:03 <BONUS> ah, cool
04:25:04 <ziman> and when you try to evaluate the desired one, the depth of the expression is large enough to overflow the stack
04:25:22 <lispy> quick what are the prime factors of 433
04:25:23 <RayNbow> you can also use rnf on infinite lists to force evaluation
04:25:26 <RayNbow> @hoogle rnf
04:25:27 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
04:25:41 <xci> subconscious: ah, well, probably not, I figured out that I am taking quite a bad route for solving this problem (I solve project eulers for training haskell)
04:25:43 <subconscious> lisipy: 433
04:26:24 <lispy> That's what I thought.
04:26:42 <BONUS> xci
04:26:45 <BONUS> which problem are you solving
04:29:06 <RayNbow> http://hpaste.org/10542#a1 <-- example use of rnf
04:29:27 <subconscious> please use a strict language :P
04:34:05 <xci> BONUS: 197
04:34:40 <BONUS> ah
04:34:49 <BONUS> i dont think you can solve that one that way
04:35:15 <BONUS> but i think you have to use some clever trick or other, that's why n is such a ridiculously high number
04:35:16 <xci> BONUS: yeah, I indeed cannot
04:35:35 <xci> nah, it's no ridicolously, but definitely will take more than one minute
04:36:58 <xci> which basically made me to think of a better solution mathematically, usually I have only tried to enhance my haskell skills with PE so I haven't usually used time on problems where one has to think, but I also found out that those requiring little thought also require fairly elementary coding only
04:37:06 <xci> so it won't push me forward
04:37:29 <BONUS> thats the thing with PE
04:37:47 <xci> though it'll probably turn out that those requiring mathematical thought won't still require any job on programming side
04:37:51 <BONUS> after solving about 80 or 100 problems, their difficulty doesn't challenge your programming skills, only your mathematical skills
04:38:12 <BONUS> i got practiced in haskell pretty nicely after solving around 80 or so problems
04:38:20 <ben_m> Can I have something like `case x of 5 or 10 -> foo; 15 or 20 -> bar`?
04:38:20 <xci> and I was fascinated with the problem of avoiding recursion in haskell
04:38:37 <BONUS> only i solved the first 50 and then 30 more in the 50-100 range
04:38:41 <subconscious> ben_m: No
04:38:51 <ben_m> :/
04:38:56 <subconscious> ben_m: case x of _ | x `elem` [5,10] -> foo can work though
04:38:58 <xci> well, I've mostly just skipped the most irritating questions
04:39:09 <ben_m> I see.
04:39:10 <subconscious> ben_m: but there are not disjunctive patten matches in general
04:40:13 <matthew-_> @src concatMap
04:40:13 <lambdabot> concatMap f = foldr ((++) . f) []
04:42:02 <matthew-_> @seen ivanm
04:42:02 <lambdabot> ivanm is in #haskell, #gentoo-haskell and #xmonad. I last heard ivanm speak 1h 19m 13s ago.
04:42:46 <hansfbaier> @seen drobilla
04:42:46 <lambdabot> I haven't seen drobilla.
04:42:55 <hansfbaier> @seen chrisdone
04:42:55 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 2d 9h 3m 58s ago.
04:46:20 <ben_m> Please someone tell me how I can make this work: http://hpaste.org/10543
04:46:33 <ben_m> It's part of a YAHT Exercise :)
04:46:43 <subconscious> ben_m: use the | like I said
04:47:00 <ben_m> How would I do that one more than one line?
04:47:20 <subconscious> but there is a different way altogether which I would go with
04:48:53 <subconscious> http://hpaste.org/10543#a1
04:49:23 <ben_m> Well that's not using a case, which was part of the exercise :)
04:53:15 <ivanm> hey matthew-_
04:57:24 <Peaker> ben_m: what's it supposed to do?
04:57:37 <Peaker> ben_m: "elem name name1" does not seem like a pattern?
04:57:48 <hackage> Uploaded to hackage: graphviz 2008.9.20
04:57:59 <ben_m> Ask for a name and if it's "John", "Simon" or "Phil" print how great Haskell is
04:58:07 <ben_m> If it's "Koen" print how fun debugging haskell is
04:58:10 <ben_m> And else, print "who are you"
04:58:16 <ben_m> First write it with if/else, then with a case
04:59:17 <Peaker> ben_m: Ok, I think you'd need to pattern-match the string as a list, then
04:59:18 <qwertiest> im using
04:59:19 <qwertiest> fst $ R.randomR (0,1) (R.mkStdGen 333) :: Float
04:59:33 <maltem> Anyone familiar with yi throwing an exception :: System.Glib.GError.GError? (i686, -fgtk or -fpango)
04:59:38 <qwertiest> but i get the same float every time, how do i get it to do a new seed?
04:59:53 <subconscious> qwertiest: snd
05:03:11 <qwertiest> graphics is embarasingly parallell i here, but is that only still graphics? games etc will have to have things executed in order(at least in some sense)
05:04:10 <qwertiest> sub: no what do you mean? thats another result but it is still repeating itself
05:05:12 <maltem> qwertiest: I suggest to have a look at the type of randomR, and to understand it (with our help)
05:05:29 <MedeaMelana> hiya
05:06:00 <maltem> qwertiest: it involves two type variables, a and g
05:06:20 <qwertiest> R.randomR :: (R.RandomGen g, R.Random a) => (a, a) -> g -> (a, g)
05:06:20 <maltem> qwertiest: a is the type of random values, in your case, Float
05:06:47 * ozy` pokes around
05:06:49 <maltem> qwertiest: g is the type of a generator of random values, typically StdGen
05:07:06 <ozy`> hey, does anyone use a text editor that's neither vi nor emacs? for writing haskell?
05:07:28 <wjt> so data.binary.get uses error when it runs out of bytes or something. i can't see a way to swaddle it in ErrorT without catching exceptions in io then unsafeperformio-ing in the lift implementation :/
05:07:40 <maltem> qwertiest: Note how randomR consumes a range and a generator, but produces a random value and a new (!) generator
05:07:42 <MedeaMelana> @ozy: I use Smultron or TextMate
05:07:42 <lambdabot> Unknown command, try @list
05:08:09 <maltem> qwertiest: That new generator is what you need for further values
05:08:45 <solrize> @seen byorgey
05:08:45 <lambdabot> byorgey is in #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 17h 7m 37s ago.
05:09:03 <Peaker> ben_m: like this maybe: http://hpaste.org/10543#a2 ?
05:09:31 <ben_m> Hm, yeah, that's probably the best way :D
05:10:07 <ben_m> Thank you.
05:10:55 <Peaker> afaik, there's no way to do pattern1 | pattern2 -> one_thing
05:11:54 <ozy`> MedeaMelana: hmmm
05:22:43 <qwertiest> but wtf i still dont see how calling this function will produce a new value each time
05:22:56 <qwertiest> isnt here soemthing readymade like random.random() in python?
05:23:07 <subconscious> qwertiest; well this isn't python
05:23:24 <qwertiest> well it is a language meant to be used right?
05:23:36 <subconscious> qwertiest; You will need to structure your program different than you would in python
05:27:33 <maltem> qwertiest: Well there are convenience functions, but they force you into the IO monad and make your program non-parallelizable
05:28:01 <qwertiest> maltem: ok what name do they have?
05:28:06 <qwertiest> http://hpaste.org/10546
05:28:26 <maltem> qwertiest: They are in System.Random. But please elaborate what you do not understand, or what you think is missing from my explanation
05:28:40 <subconscious> qwertiest: the type signature doesn't express that markovWalk can use randomness
05:29:06 <subconscious> qwertiest: You should have -> Random [Char] or something like that
05:29:33 <maltem> subconscious: rather, StdGen -> [Char]
05:29:40 <subconscious> maltem: That is not how I would do it
05:29:42 <maltem> subconscious: Or do we have a pre-defined Random monad?
05:30:05 <subconscious> qwertiest: Do you understand the use of monads?
05:30:05 <subconscious> a
05:32:51 <nipuL> http://hpaste.org/10547 natrually i get a type error on the second last line, my question is how to get a Clocktime from (State -> Clock ClockTime) ?
05:33:08 <qwertiest> sub: somewhat. yes i see i cant a pure function like i have now and use a random seed. i have to contain the blasphemy ina monad.
05:33:30 <qwertiest> so it has to be a markovWalk = do construct
05:35:57 <qwertiest> ?
05:36:53 <qwertiest> but when using randomness i must do a monad right, or can i use the seed nd have a pure function?
05:38:45 <lilac> ben_m: http://hpaste.org/10543#a3
05:50:06 <Olathe> qwertiest: If you use a seed that isn't gotten from IO, you can avoid a monad.
05:50:54 <ben_m> lilac that's nice :)
05:54:15 <Saizan> however you get your seed, you can use it in pure code
06:00:22 <slavik> are problems with cabal relevant here?
06:00:46 <Saizan> yes
06:01:01 <slavik> yay! :)
06:01:54 <slavik> I am trying to install Pugs through cabal, but it is saying that it can't find System.Console.Terminfo which is needed for haskeline, but terminfo package is installed and the version that is needed for haskeline
06:03:23 <slavik> I tried google, but couldn't find any relevant information :(
06:03:34 <Saizan> slavik: is terminfo listed in the build-depends field of the package that needs it?
06:03:56 <slavik> yes
06:04:19 <slavik> http://hackage.haskell.org/packages/archive/haskeline/0.3.1/haskeline.cabal
06:04:21 <lambdabot> http://tinyurl.com/48edjn
06:04:27 <Saizan> i see
06:05:05 <slavik> towards the bottom, it checks whether the system is win32 and if not, it depends on terminfo >=0.2.2 and unix>=2.0
06:05:23 <slavik> when doing list terminfo, cabal tells me that 0.2.2 is installed
06:05:44 * dcoutts suspects --user vs --global
06:05:44 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:06:03 <Saizan> dcoutts: that should warn on the package though?
06:06:35 <dcoutts> oh, hmm, yes
06:06:41 <Saizan> slavik: "ghc-pkg field terminfo import-dirs" should give you a directory, are the interface files there?
06:06:55 <dcoutts> in that case presumably the terminfo install is borked
06:07:00 <dcoutts> missing .hi files
06:07:14 <dcoutts> it'd help to know an actual error message
06:07:35 <slavik> hmm, terminfo  is not there
06:07:53 <slavik> is it supposed to install libraries inside my home dir?
06:08:05 <slavik> I think I might've screwed up the cabal installation
06:08:52 <Peaker> Can anyone look at http://hpaste.org/10548 and tell me if that's a reasonable way to implement lexically scoped lambda calculus?
06:09:09 <subconscious> Peaker: I think that's a terrible approach to use frankly
06:09:15 <Peaker> subconscious: Why?
06:09:32 <Saizan> slavik: the default when you use cabal-install is to install them undes ~/.cabal
06:09:48 <subconscious> Peaker: Want to see how I'd do it?
06:09:56 <Peaker> subconscious: note I intentionally do not want to implement lexical scoping in the "guest" language using that of Haskell itself, as I want to implement lexical scoping and laziness mechanisms, and not just let the guest inherit them from the host language
06:10:07 <Peaker> subconscious: for educational reasons :)
06:10:10 <Peaker> subconscious: sure
06:10:12 <subconscious> Peaker: Right, That's what I consider a terrible paproach
06:10:37 <Peaker> subconscious: oh, well you were fast to identify it :)
06:10:44 <subconscious> by the way, you shoulde use a strict language that doesn't have lambda to implement this
06:10:48 <slavik> Saizan: thing is, I want to install Pugs system wide
06:10:56 <subconscious> otherwise it's just silly
06:11:07 <Peaker> subconscious: well, I didn't use laziness or Lambda to implement it :)
06:11:23 <Saizan> slavik: then you can pass --global to cabal-install, and --root-cmd=sudo if you need it
06:11:42 <Peaker> subconscious: I am practicing Haskell. In languages I'm proficient with, it'd be too easy, and I wouldn't learn much...
06:12:16 <slavik> k
06:12:20 <subconscious> Peaker: Then you should write the best haskell code possible
06:13:00 <Saizan> like "cabal install --global --root-cmd=sudo Pugs"
06:13:12 <Peaker> subconscious: for real projects, I agree
06:13:28 * subconscious sighs
06:13:40 <Peaker> subconscious: I think there is merit to "Implement x,y,z without using features a,b,c"
06:14:37 <slavik> hmm, the problem with terminfo is still there, though
06:14:44 <subconscious> Peaker: "you should use a strict language that doesn't have lambda to implement this"
06:15:21 <subconscious> I agree with what you said but you aren't doing it
06:15:23 <Peaker> subconscious: I used a subset of Haskell whose laziness is not apparent? :)
06:15:39 <Peaker> (if it were strict, it'd still work)
06:15:59 <Peaker> (And the subset I used does not include lambda, either)
06:16:01 <Saizan> slavik: can you paste the error?
06:16:04 <Saizan> @hpaste
06:16:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:16:23 <Cale> Peaker: Did you use partially applied curried functions though?
06:16:38 <Peaker> Cale: nope: http://hpaste.org/10548
06:16:45 <subconscious> anyway, it's kind of annoying trying to suggest things when you just argue
06:17:24 <slavik> http://hpaste.org/10549
06:17:25 <Peaker> subconscious: sorry... I've been told of that before, that's all..
06:17:32 <Cale> ah, okay :)
06:17:33 <Peaker> subconscious: and I saw such implementations
06:17:43 <subconscious> such as?
06:17:55 <Peaker> subconscious: Philippa showed me one a while ago
06:18:03 <papermachine> I'm trying to use Data.ByteString. I can load it into GHCi with :m, but when I try to compile a program using it, I get http://hpaste.org/10550 :/
06:18:16 <Cale> papermachine: --make
06:18:18 <subconscious> link?
06:18:20 <papermachine> D'oh.
06:18:29 <Botje> perhaps ghc should mention this.
06:18:30 <Peaker> subconscious: I was mainly wondering if given that subset of Haskell, it was correct and reasonable.. I guess the latter is inapplicable when using a "subset' at all
06:18:35 <Cale> papermachine: It's unfortunate that flag is not default :)
06:18:45 <subconscious> Peaker: It's not reasonable to program like that no, like I said before
06:18:53 <Botje> would there be something bad about making --make the default?
06:18:56 <Peaker> subconscious: Yeah, I see
06:19:06 <Saizan> slavik: you're still installing it locally, however your terminfo package installation is borked, so you should ghc-pkg --user unregister terminfo first, so that it will be resinstalled
06:19:24 <papermachine> I was about to reinstall GHC too; thanks~
06:20:11 <Saizan> slavik: or just rm ~/.ghc if you think you may have screwed it
06:20:17 <Cale> Botje: The only reason I can imagine you'd want to leave it is backward compatibility, but since when did we start caring about that? :)
06:20:42 <slavik> Saizan: should I remove the .cabal dir, too?
06:20:47 <Botje> :)
06:20:58 <slavik> Saizan: I installed cabal before, but with --user
06:21:10 <slavik> I want to make cabal global now ...
06:22:50 <Saizan> slavik: that's not necessary
06:23:06 <slavik> hmm, I think removing .ghc did the trick
06:23:30 <slavik> trying to install Pugs now
06:24:01 <slavik> compiling Pugs now :)
06:24:13 <slavik> so, cabal is like apt for haskell packages and such?
06:24:21 <Saizan> yup
06:24:39 <shepheb> the GHC 6.10 Status Trac page says "Release candidate: Friday 19th September 2008" but I can't find it. based on the page history, that RC note was added on July 9th, so I guess it didn't happen
06:25:05 <slavik> and what book/tutorial can I read that would teach me haskell syntax? (I don't have a problem with the functional approach, but am having trouble with syntax errors)
06:25:48 <slavik> yay, it worked ^^
06:26:29 <slavik> Saizan: http://hpaste.org/10551 :)
06:26:35 <slavik> ty for the help
06:26:47 <Saizan> np :)
06:27:21 <Saizan> as for books there's "real world haskell" available online
06:28:18 <Saizan> http://www.haskell.org/haskellwiki/Tutorials
06:28:19 <lambdabot> Title: Tutorials - HaskellWiki
06:28:35 <slavik> here's another hypothetical question about haskell, since it is lazy, is it possible for it to cache function evaluation for specific arguments?
06:28:52 <subconscious> slavik: It's lazy so you _cant_ do that
06:29:07 <Saizan> subconscious: uh?
06:29:11 <papermachine> What?
06:29:45 <Saizan> you can surealy do that, it's just that implementations don't automatically, and in many cases it can be a waste
06:29:48 <subconscious> You can't write a function memoize s.t.   (memoize sqrt) is equivalent to sqrt excep uses a lookup table
06:30:01 <slavik> I see
06:30:05 <subconscious> (unless you use unsafePeformIO)
06:30:12 <papermachine> That can't be correct.
06:30:18 <papermachine> It's certainly possible to write functions that memoize.
06:30:25 <subconscious> papermachine: I claim it's not :p
06:30:28 <papermachine> Without unsafePerformIO.
06:30:36 <Saizan> subconscious: if you've a restricted domain you can do it e.g. with a lazy array
06:30:42 <slavik> but then how is it possible that haskell can do matrix multiplication faster than C, there was a post about it on the mail list I think
06:30:44 <Saizan> subconscious: or an immutable trie
06:31:11 <slavik> I'm assuming a very large dataset where it is possible that values appear in more than one place
06:31:13 <subconscious> Saizan: to implement that memoize ?
06:31:16 <qwertiest> System.Random	randomIO :: Random a => IO a
06:31:17 <subconscious> or something like it ?
06:31:24 <qwertiest> R.RandomIO (0,1)
06:31:26 <Saizan> subconscious: yeah
06:31:27 <qwertiest> Not in scope: data constructor `R.RandomIO'
06:31:29 <qwertiest> huh?
06:31:59 <papermachine> http://sequence.complete.org/node/263
06:32:01 <lambdabot> Title: Dynamic Programming in Haskell | The Haskell Sequence
06:32:04 <subconscious> @let memoize f = let results = map f [0..] in \x -> results !! x
06:32:09 <lambdabot>  Defined.
06:32:11 <Saizan> qwertiest: case counts
06:32:34 <subconscious> @run memoize (let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib) 300
06:32:49 <lambdabot>   thread killed
06:32:55 <subconscious> @run memoize (let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib) 100
06:33:00 <Saizan> subconscious: you're not memoizing the recursive calls
06:33:10 <lambdabot>   thread killed
06:33:21 <subconscious> Saizan: is it possible to?
06:33:27 <subconscious> I don't think so ...
06:33:46 <Saizan> you need to write fib in fixpoint style
06:33:48 <subconscious> You can write a fixMemoize, but that's a different thing
06:33:51 <subconscious> yeah ok
06:34:07 <eu-prleu-peupeu> hi
06:34:08 <subconscious> I maintain it's not possible to write memoize
06:34:24 <Saizan> you can write memoize for non-recursive functions then :)
06:35:13 <Saizan> slavik: i'm not sure about matrix multiplication, but being pure haskell offers the opportunity for very aggressive optimizations from the compiler
06:35:50 <slavik> k
06:37:05 <MedeaMelana> I've seen a memoize once which used unsafePerformIO.
06:37:14 <MedeaMelana> And despite that it was a very elegant one.
06:37:33 <Saizan> there's a SPJ paper on that, iirc
06:37:43 <subconscious> MedeaMelana: yeah I have nothing against it, I'm just saying lazyness and purity makes this impossible
06:38:03 <Saizan> i don't see where laziness hurt?
06:38:05 <subconscious> which is hopefully what slavik was wondering
06:38:24 <Saizan> and how do you write memoize with unsafePerformIO?
06:38:43 <slavik> yes, it is ...
06:39:32 <slavik> subconscious: the idea stems from the fact that haskell has no problems replacing a symbol with a function, so I was thinking that maybe it would remember a function call with the actual parameters and such
06:39:54 <subconscious> slavik: You know what happens with something like (\x -> x + x) (sqrt 4)
06:40:01 <subconscious> slavik: only computes sqrt 4 once..
06:40:14 <subconscious> slavik: but this is fairly different to actually constructing memo tables
06:40:47 <Saizan> btw, purity actually ensures that your memotable is correct
06:41:52 <slavik> subconscious: is that supposed to be x*x?
06:42:32 <subconscious> slavik: If you like :)
06:42:39 <subconscious> I don't think it makes much difference
06:43:10 <Saizan> slavik: (\x -> x + x) is a way to construct a function that takes an argument 'x' and returns 'x+x'
06:43:41 <qwertiest> R.randomRIO (0,1) works, but how can i get the itnerval between 0and 1 as a float and not just 0 and 1?
06:44:05 <subconscious> > fst (randomR (0,1)) :: Float
06:44:13 <slavik> hmm
06:44:16 <lambdabot>   Couldn't match expected type `(a, b)'
06:44:17 <subconscious> > fst (randomR (0,1) (mkStdGen 333)) :: Float
06:44:29 <lambdabot>   0.85639095
06:44:35 <subconscious> > fst (randomR (0,1) (mkStdGen 333)) :: Float
06:44:37 <subconscious> > fst (randomR (0,1) (mkStdGen 334)) :: Float
06:44:56 <lambdabot>   thread killed
06:44:56 <lambdabot>   thread killed
06:45:04 <subconscious> qwertiest: (if they had worked, you could note that the seed determines the number)
06:46:21 <qwertiest> sub: yes but then i get the same evrytime
06:47:47 <Saizan> qwertiest: randomRIO (0,1) is polumorphic, and defaulting makes it return an Integer, you can override defaulting by putting a type annotation, like IO Float
06:48:00 <qwertiest> ah wait now i see, i ahve an int param in my func, i could use that to generate the new seed
06:48:08 <Saizan> qwertiest: R.randomRIO (0,1) :: IO Float
06:48:43 <Saizan> since we don't have IO in lambdabot subconscious used the "pure" version of that function to demonstrate this.
06:50:04 <Saizan> s/polu/poly/
06:50:45 <qwertiest> awesome, i was so stupid before i didnt get the 333 stuff lol. so i just pass my accumulator as the seed
06:51:35 <qwertiest> so now i get a randomized sentence but i still get the same sentence every time i run the program
06:51:49 <qwertiest> so i need to call system clock or something?
06:52:16 <Saizan> you can use getStdGen in IO to get the system-initialized seed
06:52:56 <guenni> sry guys, I just came accross Data.IntSet, what is it?
06:53:07 <qwertiest> It's to avoid slowing down the average grocery
06:53:55 <qwertiest> @src getStdGen
06:54:03 <qwertiest> @type getStdGen
06:54:06 <lambdabot> Source not found. Where did you learn to type?
06:54:34 <lambdabot> thread killed
06:54:54 <Saizan> guenni: a Set specialized to Ints, so it can use a faster implementation
06:54:59 <qwertiest> @lambdabot -> suicide
06:55:42 <guenni> Saizan: thx, so it's nothing magical then
06:56:17 <eu-prleu-peupeu> http://www.phdcomics.com/comics.php?f=1071
06:56:24 <eu-prleu-peupeu> they nailed it :)
06:57:03 <guenni> is there some standard well known structure / container out there that does multi-indexing of its elements?
06:57:23 <Jedai> guenni: multi-indexing ?
06:57:40 <Cale> guenni: Well, there's PSQueue... which combines a priority queue with a Map
06:57:48 <hackage> Uploaded to hackage: hmpfr 0.1
06:58:43 <guenni> Cale: so when I have some [Record] and I want an index on several different fields of that record PSQueue can handle that?
06:58:53 <Cale> No, that's harder :)
06:58:55 <Cale> It would be nice to have a pure structure with an arbitrary number of independent fast indexes on the same elements. :)
06:59:12 <Cale> I suppose you can just keep around a bunch of Data.Map's.
06:59:38 <guenni> Cale: I was afraid of  that :(
07:00:09 <Cale> I'm not sure you can actually do better than that, in general...
07:00:43 <guenni> I had a look on Happs-IxSet which does seem to offer what I want, but the code is so dependent on extensions that I don't wonna use it
07:01:04 <Cale> I mean, in terms of space, it seems like you'd have to know something about how the different indexes were related in order to do better than just hanging on to a bunch of maps.
07:01:19 <guenni> besides I don't get how it's done
07:02:04 <Saizan> guenni: what you don't get about IxSet?
07:02:12 <guenni> everything
07:02:37 <guenni> the are the multiparameter type classes, the for-all stuff, ....
07:02:40 <guenni> and so on
07:02:44 <Olathe> > 1 + 1
07:02:50 <guenni> I mean I just can't follow the code
07:03:46 <guenni> then some parts of the code are for its interaction with the rest of Happs, ie. serializatin to disk and I cannot clearly identify it
07:04:23 <guenni> Cale: where can I find PSQueue?
07:04:30 <Saizan> heh, the problem is that if you have multiple indexes with different types it's not immediately easy to manage that
07:04:42 <Cale> On hackage, though it's more than likely not what you actually want here.
07:04:53 <Saizan> IxSet manages them with Data.Typeable, i.e. dynamic types
07:05:11 <guenni> yes, since it's put into a list
07:05:19 <Cale> It's just an example of something which manages multiple (two) indexes on a set of elements in order to provide fast operations.
07:05:21 <guenni> kind of elegant but also confugsion
07:05:36 <qwertiest> how do i patternmatch against 534901990 1
07:05:47 <guenni> Cale: I think it'd be wort a shot
07:05:48 <Cale> qwertiest: sorry?
07:06:11 <qwertiest> R.getStdGen :: IO R.StdGen
07:06:20 <qwertiest> returns something like 48348304 1
07:06:27 <qwertiest> i wamt the first of those
07:06:29 <Cale> oh, that's just how it's printed
07:06:42 <Cale> I'm not sure you can actually access that number directly.
07:06:52 <Cale> (You're not meant to, under ordinary usage.)
07:07:08 <Cale> You could of course, parse it out of the string, but why do you want access to it?
07:07:10 <qwertiest> i just want a new seed everytime i run the program
07:07:26 <qwertiest> cna i call systemclock perhaps?
07:07:27 <Cale> Oh, then do  g <- newStdGen  in your main somewhere.
07:07:36 <Cale> That'll give you a fresh generator.
07:07:39 <Jedai> qwertiest: R.getStdGen return a random generator (different every run)
07:07:52 <Cale> I recommend never using getStdGen.
07:08:09 <Jedai> qwertiest: You don't print the generator, you use it in randomR (or other such functions)
07:08:15 <Cale> (Unless you have a really good reason to...)
07:08:25 <guenni> Saizan: about the Data.Typeable: I'm not sure that this part is necessary though, I might just be required to provide functionality for the rest of Happs
07:08:55 <qwertiest> fst $ R.randomR (0,1) (R.mkStdGen n_words) :: Float
07:08:58 <Saizan> guenni: no, it's required
07:09:10 <guenni> Saizan: damn
07:09:13 <Jedai> qwertiest: Oh right, newStdGen is better because if you cal it several time in the same process you'll get different answer
07:09:14 <qwertiest> yes her ei need a new vale for n_words  every time
07:09:25 <guenni> that is the part I definitely hate
07:09:29 <qwertiest> jedai: can i usre it in a pure function?
07:09:39 <mxc> good evening/morning everyon
07:09:54 <guenni> mxc: good morning
07:10:01 <maltem> mxc, good afternoon
07:10:10 <maltem> (just for completeness)
07:10:23 <mxc> just out of curiosity, why is it that hashtables are generally implemented as impure, mutable data structures?
07:10:26 <Cale> qwertiest: You can't call newStdGen from a pure function because it's not pure.
07:10:35 <Saizan> guenni: it can be implemented without Data.Typeable, but with GADTs
07:10:38 <Cale> qwertiest: You can however, pass its result into a pure function.
07:10:39 <mxc> in haskell its in IO and in ocaml its a mutable, impure data structure
07:10:59 <Jedai> qwertiest: no, but normally you just thread your generator and split it if necessary, look at the Random Monad on the Wiki for an implementation that makes it easy and hide the ugliness
07:10:59 <mxc> was wondering about that the other day
07:11:27 <Cale> mxc: Because you can't get any benefit out of structural sharing from hashtables.
07:11:36 <Saizan> mxc: because the only good thing about an hashtable it's that the elements are stored in something similar to an array
07:11:47 <Cale> mxc: So updates would be O(n) if it were pure, defeating the whole point.
07:11:58 <Cale> mxc: Hashtables are overrated in my opinion anyway.
07:11:59 <guenni> Saizan: well that is good news, see my books can teach me nothing about the new type extensions, there all from before they were introduced
07:12:52 <guenni> Saizan: do you know of a rough sketch of IxSet(similar) with GADTs?
07:12:57 <Cale> mxc: They claim to have O(1) access time, but it's easy to show that, under the same assumptions, computing the hash must take at least O(log n) time.
07:13:18 <mxc> cale: the last point about hash functions is a good one, haven't thought of that
07:13:19 <Cale> mxc: So there's really not much benefit to hashtables over binary balanced trees.
07:13:57 <mxc> cale:  at least in ocaml, the Hashtbl module massively outperforms the native map module on large sets
07:14:05 <roconnor> mm, CPU time vs menory access time.
07:14:29 <SamB_XP> what about womenory access time?
07:14:54 <mxc> roconnor: good point, computing the hash is CPU time, walking a tree is memory time
07:15:14 <roconnor> still, nice theoretical point
07:15:15 <Cale> Well, it depends on what kind of data you're working with.
07:15:21 <Jedai> The hash has a better memory locality though
07:15:27 <qwertiest> this drives me crazy, cant i just somehow get a new number? wtf. how do i call system clock?
07:15:44 <Cale> If traversing the data you're indexing requires accesses to memory, it doesn't really matter anymore :)
07:15:45 <roconnor> @hoogle currentTime
07:15:51 <Jedai> qwertiest: You can't in a pure function
07:16:01 <roconnor> @bot
07:16:27 <Cale> qwertiest: The current time is not a constant.
07:16:39 <Cale> qwertiest: Why not just do what I suggested?
07:16:50 <Jedai> qwertiest: just thread the generator (the Random Monad will do it for you, basically you just have to  add MonadRandom to all your type, or something like that)
07:17:09 <Cale> qwertiest: In your main IO action, have  g <- newStdGen, and then pass g into the pure function you're using.
07:17:54 <Cale> qwertiest: Then that pure function can thread the generator it gets along, taking some care to thread along the new generator it gets when things like randomR are used.
07:18:40 <maltem> qwertiest: Btw with what Cale explains, we are back at my very first suggestion, namely, passing along new generators manually
07:18:41 <Cale> qwertiest: If you want a more automated way to take care of that, as Jedai points out, there are specialised monads you can use, but it's not usually that necessary.
07:21:02 <Saizan> guenni: http://code.haskell.org/~Saizan/IxSetTyped.hs , but it uses multiparam typeclasses and fundeps
07:21:21 <Saizan> s/it/it also/
07:23:35 <qwertiest> fst $ R.randomR (0,1) (R.mkStdGen seed) :: Float
07:23:55 <qwertiest> but the generator shuld be passed as what to creat ethe new value?
07:24:00 <Saizan> qwertiest: if you don't use "fst" you'll notice that randomR returns a tuple
07:24:06 <qwertiest> seed is the generator
07:24:21 <Saizan> qwertiest: where the first value is the generater number, and the second value is the new generator
07:24:32 <Saizan> ?type System.Random.randomR
07:24:44 <Saizan> @bot -- ?
07:24:59 <Jedai> qwertiest: let (randomValue, newGen) = R.randomR (0,1) gen
07:25:22 <qwertiest> System.Random.randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:25:22 <qwertiest> P
07:25:33 <Jedai> qwertiest: where gen was passed along and probably created by newStdGen or the result of another randomR
07:26:03 <Saizan> yeah, so if you have a generator you don't need mkStdGen
07:28:16 <qwertiest> " boss represents your average outcome of hack, like it was"
07:28:26 <qwertiest> " boss is a mouse by other startups. We certainly not"
07:28:38 <qwertiest> " boss is just the restrictions imposed by the factory premises"
07:28:42 <qwertiest> " boss is how much money for reading too high school"
07:28:45 <qwertiest> yay
07:30:08 <qwertiest> " boss is to write readable code. But even bother checking"
07:30:24 <qwertiest> " boss represents your head as humans in the other. Splitting"
07:30:27 <qwertiest> deep stuff
07:30:48 <maltem> ...
07:30:50 <papermachine> grats
07:31:05 <qwertiest> " boss represents your way, and claim this case that people"
07:31:11 <papermachine> I didn't fully grasp how easy it was to write repls in haskell.
07:31:13 <qwertiest> politicla philospopy
07:31:41 <maltem> Wow, why must any German discrete mathematics professor maintain their very own terminology? This is definitely annoying.
07:32:04 <Zao> maltem: From what I see, it seems to hold for all german science.
07:32:05 <Peaker> I am using ghci as a debugger. My breakpoints only seem to be in effect the first time the code runs... How come?
07:32:12 <SamB_XP> well, why does mine insist that the naturals start at 1, and claim that everyone who says otherwise is wrong?
07:32:23 <SamB_XP> as well as claiming that only barbarians use {} for the empty set?
07:32:58 * Peaker wants to be able to step through Haskell code and have emacs show me what expression is being worked with right now
07:32:59 <Jedai> papermachine: What's your question ?
07:33:06 <Peaker> Its crazy not to be able to
07:33:08 <guenni> Saizan: thank you very much, how did you do that in such a short time?
07:33:21 <shepheb> Peaker: +1, I want that too
07:33:35 <SamB_XP> this, despite the fact that our textbook defines the naturals as beginning with 0
07:33:37 <shepheb> it knows the line and column range, so easy to highlight
07:33:38 <Jedai> Peaker: I guess with haskell-mode support for ghc-debugger it could be done ?
07:33:43 <Saizan> guenni: i've written that some time ago :)
07:33:49 <Peaker> Jedai: ghc-debugger?
07:33:53 <maltem> Zao: maybe... it strikes me particularly in graph theory, though
07:33:58 <Peaker> Jedai: I am trying to use ghci as a debugger, and it seems to be broken, or very weird
07:34:03 <Jedai> Peaker: the debugger of ghci I mean
07:34:06 <Peaker> Jedai: my breakpoints are only stopped at once
07:34:17 <Peaker> Jedai: the next time I run the code, the breakpoints are ignored :(
07:34:28 <guenni> Saizan: you've had a similar need then?
07:34:34 <Peaker> so I have to restart ghci to break again?
07:34:40 <Peaker> that's crazy
07:35:05 <SamB_XP> Peaker: maybe if you stopped setting breakpoints in CAFs?
07:35:07 <maltem> SamB_XP: heh, true, that's one of the most popular hassles
07:35:31 <Saizan> guenni: i mostly didn't like the use of Typeable inside IxSet, and was going to use it for my website, which i never actually wrote :)
07:35:38 <Peaker> SamB_XP: CAFs are memoized?
07:35:56 <guenni> Saizan: lucky me then :)
07:36:01 <papermachine> Jedai: No question. Just awe.
07:37:39 <Peaker> the debugger is totally unusable. Every time I tried using it, I ended up thinking harder and/or using manual Traces instead.. :(
07:37:48 <Peaker> which takes longer than just stepping through
07:37:58 <SamB_XP> Peaker: no arguments there
07:38:24 <SamB_XP> it's almost totally unusable ... which is worse than totally unusable, because it gets your hopes up only to dash them
07:39:50 <Peaker> heh
07:39:58 <Peaker> How come Haskell doesn't have a good toolchain after so many years?
07:40:39 <jeffz> maybe it's to encourage people to think harder or to write more readable programs?
07:41:46 <Saizan> guenni: heh, you should probalby benchmark it, btw :)
07:42:04 <guenni> Saizan: your version?
07:42:36 <Saizan> guenni: yeah, if you're going to use it
07:44:10 <Beelsebob> Peaker: are you talking about trying to debug H98 code, or code that uses extensions?
07:44:54 <guenni> well what made HappsIxSet difficult wasn't the algo as such, it was the bendover backwards type stuff you had to do. If your stuff is basically the same algo with less of a type fuzz it then should run pretty much the same as the original, right?
07:46:47 <roconnor> what's a toolchain?
07:49:16 <Saizan> guenni: yeah, well, the part that extracts the indexes how of the record is different, i don't know which is faster, or if it actually matters much
07:51:18 <Saizan> s/how/out/
07:53:20 <Cale> Can one theoretically do any better in storing multiple indices into the same set than would be afforded by storing multiple Data.Maps?
07:53:21 <lambdabot> Unknown command, try @list
07:53:28 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
07:53:28 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
07:53:28 <lambdabot> :)
07:53:35 <lambdabot>   2
07:53:42 <Botje> @vixen holy lagged-up \bot!
07:53:43 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:53:56 <lambdabot> Plugin `dummy' failed with: thread killed
07:54:06 <lambdabot> I'm your huckleberry
07:55:02 <guenni> Saizan: you haven't used this much?
07:55:59 <Saizan> guenni: i've only tried some of the operations to see if it worked, as i said i never actually had a need for it
07:56:18 <guenni> Saizan: huh
07:56:26 <Saizan> guenni: so, no warrant, sorry :)
07:56:38 <Cale> hmm...
07:56:43 <guenni> Saizan: np, happy to have it
07:56:55 <Cale> Maybe something a bit like a spatial partitioning tree? Does that actually help?
07:57:03 <inimino> hm, I just noticed breakpoints are only applied once, then it seems Peaker was just complaining about the same thing
07:57:46 <inimino> but there seems to be another bug, where if you set a breakpoint on main, then getArgs returns something completely wrong
07:59:03 <inimino> maybe there's a better way to do what I'm trying to do...
07:59:05 <Saizan> Cale: where each index is a dimension?
07:59:11 <Cale> Saizan: yeah
07:59:41 <inimino> my program is running out of stack space, what's the easiest way to see what's on the stack when that happens?
08:00:08 <Cale> inimino: The stack doesn't actually refer to the same thing as one would expect from evaluation in strict languages.
08:00:15 <Saizan> Cale: is it easy to write it for N dimensions?
08:01:03 <inimino> Cale: I know it's not exactly the same, but there is a stack of /something/, and it's causing my program to crash, so is there a way to see what's going on?
08:01:40 <Cale> inimino: Well, you can :set -fbreak-on-exception and then :trace whatever it was that caused the stack overflow. But mostly, there are usually a few easy candidates to pick on.
08:01:55 <Cale> inimino: Do you have a recursive function which uses an accumulating parameter?
08:02:04 <Cale> inimino: Or a foldl (but not foldl')?
08:02:08 <inimino> Cale: can you use :trace after the fact?
08:02:23 <inimino> Cale: yes, I have a recursive function
08:02:31 <inimino> or several of them...
08:02:34 <Cale> Okay, hpaste it and I'll have a look :)
08:02:41 <inimino> ok
08:03:43 <leimy> > (\x -> foldl (+) 0 x)[1..1000000]
08:03:46 <lambdabot>   mueval: Prelude.read: no parse
08:03:46 <lambdabot>  mueval: *** Exception: stack overflow
08:03:50 <leimy> hmmmm
08:04:31 <leimy> > (\x -> foldl (+) 0 x) [1..10000]
08:04:33 <lambdabot>   50005000
08:04:46 <Cale> Right.
08:05:12 <Cale> inimino: If you'd like, I can show you how that stack overflow happens.
08:05:31 <leimy> I'm pretty curious :-)
08:05:39 <leimy> I didn't expect foldl to do that :-)
08:05:56 <Cale> foldl (+) 0 [1,2,3] --> foldl (+) (0+1) [2,3] --> foldl (+) ((0+1)+2) [3] --> foldl (+) (((0+1)+2)+3) [] --> ((0+1)+2)+3
08:05:56 <idnar> > (\x -> foldl' (+) 0 x) [1..10000]
08:05:57 <lambdabot>   50005000
08:06:00 <idnar> oops
08:06:02 <idnar> > (\x -> foldl' (+) 0 x) [1..100000]
08:06:03 <lambdabot>   5000050000
08:06:05 <inimino> hm
08:06:13 <Cale> Now, once you get there, it must find a reducible expression in ((0+1)+2)+3
08:06:21 <Cale> This is where the stack starts to grow.
08:06:40 <Cale> (the outermost redex is (0+1) there)
08:06:42 <leimy> ahh
08:07:02 <leimy> So it's building up the entire expression first?
08:07:04 <Cale> yes
08:07:08 <leimy> due to laziness :-)
08:07:27 <Cale> Right, laziness always evaluates the outermost reducible expression first.
08:07:37 <inimino> ok, I just ran my code before pasting it to make sure the overflow was still there
08:07:49 <Cale> And foldl is always reducible immediately into another foldl or the end result.
08:07:56 <leimy> inimino: wait... you were doing that too?
08:08:01 <leimy> I wasn't even in the channel
08:08:10 <leimy> but for some reason was looking at that same thing
08:08:21 <inimino> leimy: yes, synchronicity
08:08:39 <inimino> apparently hpaste didn't like my Unicode syntax :(
08:08:44 <leimy> inimino: I'd just call that "totally fucking weird" but then synchronicity is a better way to say it :-)
08:08:56 <inimino> http://hpaste.org/10552
08:08:58 <inimino> heh
08:09:37 <inimino> Cale: ^
08:09:52 <Cale> okay :)
08:11:05 <Cale> btw, if you find yourself using head and tail, consider using pattern matching instead
08:11:09 <psykotic> yo
08:11:14 <inimino> ok
08:11:14 <Cale> hello
08:11:27 <Cale> That is,  f (l:ls) = ...
08:11:38 <inimino> yeah, that's a good point
08:11:53 <Cale> head and tail are inherently dangerous :)
08:12:05 <Jedai> inimino: Why the hell are your <- and -> in a strange encoding ? Or is that hpaste ?
08:12:21 <Cale> Jedai: They were in unicode originally.
08:12:36 <Cale> or, something anyway
08:12:41 <inimino> Jedai: they are in UTF-8, but apparently the colorizer breaks each byte into a separate <span>
08:13:09 <Jedai> So that's hpaste (or hscolour ?) problem ?
08:13:15 <Cale> yeah
08:13:16 <inimino> hscolour bug
08:13:20 <leimy> I guess one could write stuff in CPS Haskell to get evaluation to happen sooner
08:13:28 <Cale> leimy: There's also seq
08:13:32 <leimy> yes
08:13:46 <Cale> Well, seq is very primitive, you can build things in terms of it which are more fun to use :)
08:13:54 <Cale> (Like foldl')
08:13:56 <leimy> yeah.. like seq one step of a foldl
08:13:59 <leimy> oh
08:14:00 <leimy> right :-)
08:14:40 <Cale> Also, if you compile with optimisations, the strictness analyser finds a lot of stuff anyway.
08:15:19 <Cale> inimino: How big would you expect the list (head ls : rom) to get?
08:15:59 <inimino> Cale: it shouldn't be too big, it's just the number of lines in an email message
08:16:10 <Cale> okay.
08:16:38 <Jedai> inimino: I think replacing your "s <- hGetContents; let ms = messages s" by "ms <- messages <$> hGetContents inhdl" would be better
08:17:06 <Jedai> I'm not sure it matters though (the optimizer may do what's needed)
08:17:12 <inimino> hm, ok
08:18:11 <Cale> Or just  fmap messages (hGetContents inhdl)
08:18:17 <Cale> It's the same thing in the end.
08:18:27 <inimino> ah
08:18:31 <Cale> hmm
08:18:36 <inimino> I don't know <?> yet
08:20:10 <Jedai> inimino: <$> is just an operator from Control.Applicative, here a synonim to fmap, liftM and ap, but nice in some occasion
08:20:11 <Cale> <$> is from Control.Applicative
08:20:45 <Jedai> That's when I realize how much synonym for this function we have....
08:20:47 <inimino> oh, ok
08:21:06 <inimino> yeah I just looked up fmap and was about to say, looks like liftM
08:21:40 <zachk> lazy primes http://hpaste.org/10553
08:21:43 <Saizan> ..it neve occurred to me that foldl' (++) [] can stack overflow while evaluating the second element if the list is big enough
08:21:44 <Jedai> inimino: fmap works on all Functor, and all Monad are functors where fmap is liftM
08:21:59 <inimino> ok
08:22:12 <Jedai> A foldr must be used there instead, no ?
08:22:26 <zachk> i keep liking haskell more and more
08:22:44 <Saizan> Jedai: yeah
08:23:00 <Jedai> @src concat
08:23:01 <lambdabot> concat = foldr (++) []
08:23:28 <Saizan> since foldl-ing (++) is asymptotically slower in the first place
08:23:35 <inimino> hm
08:24:25 <guenni> zachk: that might turn into a love/hate relationship pretty soon
08:24:42 <zachk> not when i have to use java for school
08:25:33 <qwertiest> peaker: checking out your lc-repl, what should i pass it?
08:25:53 <Jedai> It's because it's lazy bytestring though, with strict bytestring, the problem would be different (because append would be strict in it's second element)
08:26:20 <guenni> zachk: look the stuff with the lambda calculus only makes me spray my pants too, but wait til you get to Generic, Parametric type classes and other moving targets involving anything fancy with the type system
08:26:52 <inimino> Jedai: yeah, lazy bytestrings are the point of this exercise, I was trying to do this first without manually chunking the input
08:26:54 <Jedai> guenni: Most of the type system isn't a "moving target"
08:26:56 <Saizan> ?type Data.ByteString.Lazy.Char8.concat -- btw
08:26:58 <lambdabot> [BSLC.ByteString] -> BSLC.ByteString
08:27:34 <Jedai> @src Data.ByteString.Lazy.Char8.concat
08:27:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:27:55 <guenni> Jedai: that may be so but there are certainly some parts that are terribly complicated and confusing
08:28:36 <guenni> Jedai: and where it is also not clear how they relate to one another or if they complement each other
08:28:53 <Jedai> guenni: As said before, you don't need to know all the obscure extensions to use Haskell, even in a sophisticated fashion
08:29:08 <inimino> concat :: [ByteString] -> ByteString
08:29:08 <inimino> concat css0 = to css0
08:29:08 <inimino>   where
08:29:08 <inimino>     go Empty        css = to css
08:29:08 <inimino>     go (Chunk c cs) css = Chunk c (go cs css)
08:29:09 <inimino>     to []               = Empty
08:29:09 <Saizan> guenni: there are a lot of resources online that explains them though
08:29:11 <inimino>     to (cs:css)         = go cs css
08:29:43 <subconscious> that code uses GOTO??
08:29:50 <inimino> heh
08:29:51 <guenni> and there are also a lot of people willing to try to see you through, conceded :)
08:30:49 <guenni> Jedai: but since you are using the term "obscure" yourself :)
08:30:54 <papermachine> When using Prelude's putStr, do I need to flush the buffer somehow?
08:31:05 <Saizan> inimino: yeah, that's an unrolled foldr append :)
08:31:39 <Saizan> papermachine: or tune hSetBuffering
08:31:46 <Jedai> guenni: Well, they _are_ obscure, since Haskell has been the lab for type system extension approximating dependent typing but not dependent for a long time, it's only natural
08:32:01 <Saizan> s/tune/tune the buffering with/
08:32:10 <papermachine> The docs say that putStr is the same as putStrLn v_v;;
08:32:25 <Jedai> guenni: But the immense majority of Haskell code don't even touch them
08:32:28 <papermachine> I guess the \n flushes the buffer.
08:32:55 <guenni> zachk: I'll have you know that Java is a great language when you are a freelancer and get paid by the hour
08:33:24 <subconscious> guenni: It's currently popular to dislike java
08:33:29 <qwertiest> dd an instance declaration for
08:33:29 <qwertiest>       (Fractional (GLfloat, GLfloat, GLfloat))
08:33:32 <qwertiest> how?
08:33:33 <guenni> zachk: because everything in Java takes very very long while the meter is running
08:33:35 <leimy> Data.List.sum doesn't use foldl'
08:33:40 <leimy> should it? :-)
08:33:43 <inimino> Saizan: I see
08:33:49 <byorgey> leimy: arguably, yes
08:33:58 <subconscious> leimy: I think it should
08:33:59 <leimy> however it would not be completely lazy then I suppose
08:34:19 <leimy> I on the other hand AM completely lazy... (ask my wife)
08:34:26 <byorgey> leimy: indeed, but the situations where you actually want a lazy sum are pretty rare
08:34:27 <Jedai> leimy: It could but then some lazy number instances (Peano integer) wouldn't work well with it
08:34:39 <leimy> Jedai: ah.
08:34:44 <leimy> hadn't thought of that case
08:34:46 <byorgey> maybe there should just be a strict version sum' added.
08:34:56 <leimy> that's what I was just thinking
08:35:03 <leimy> I mean writing strict sum is trivial
08:35:04 <Jedai> Normally, sum is specialized for Int and Integer to a strict version (but on interpreted code it isn't)
08:37:26 <qwertiest> http://hpaste.org/10554
08:37:34 <qwertiest> sum'
08:37:37 <qwertiest> ^^
08:37:52 <leimy> I'd just do it with foldl' :-)
08:38:23 <Jedai> qwertiest: sum' = foldl' (+) 0
08:38:35 <leimy> as such :-)
08:39:03 <qwertiest> sum' = Data.List.foldl' (+) 0
08:39:05 <qwertiest> sure
08:39:09 <leimy> yep!
08:43:11 <zachk> wow my method of calculating primes is quite slow
08:43:27 <zachk> about 30 seconds for the first 10,000. i can do better then that
08:44:33 <Beelsebob> zachk: what was the method?
08:45:16 <Beelsebob> > nubBy (\x y -> y `mod` x == 0) [2..]
08:45:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:45:47 <jinjing> @src nubBy
08:45:47 <lambdabot> nubBy eq []             =  []
08:45:47 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:46:13 <papermachine> There's a wheel sieve on haskell.org somewhere that's more than fast enough for eulerish things.
08:47:38 <jinjing> this looks like a sieve
08:49:21 <qwertiest> is there a builtin for : drop x $ take y ?
08:49:45 <jleedev> http://haskell.org/haskellwiki/Prime_numbers
08:49:46 <lambdabot> Title: Prime numbers - HaskellWiki
08:49:46 <qwertiest> take-between x y
08:51:49 <lilac> > let primes = 2:filter (\m -> all (\n -> m `mod` n /= 0) $ takeWhile (\n -> n * n <= m) primes) [3,5..] in take 10 primes
08:51:50 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
08:52:30 <lilac> > let primes = 2:filter (\m -> all (\n -> m `mod` n /= 0) $ takeWhile (\n -> n * n <= m) primes) [3,5..] in last $ take 10000 primes
08:52:32 <lambdabot>   104729
08:55:08 <daf> hmm, does (..) not work for newtypes?
08:55:21 <daf> as in: import Network (PortNumber(..))
08:55:31 <daf> (I get: Not in scope: data constructor `PortNumber'
08:55:32 <daf> )
08:57:47 <inimino> hm, is there a way to get :trace to save more of the history?
08:58:02 <inimino> (than 50?)
08:59:33 <inimino> hm, I guess not
09:00:10 <qwertiest> take x $ drop y is more efficient than drop x $ take y right?
09:00:48 <opqdonut> no difference, really
09:01:24 <opqdonut> take x . drop y is more elegant in some way of course
09:02:41 <daf> inimino: quoth the manual âGHCi remembers the last 50 steps in the history (perhaps in the future we'll make this configurable).â
09:03:02 <inimino> daf: thanks
09:07:44 <leimy> hmm no scanl' either in Data.List
09:07:51 <qwertiest> drop 5 first then  take 2 means , 6..10 then takes 2 means 7 elems. take 7 drop 2 means traverse 9 elems right?
09:07:53 <leimy> I guess that one is pretty easy too
09:08:16 <leimy> seq for the win :-)
09:08:38 <qwertiest> take x . drop y is not the intention anyway
09:08:44 <qwertiest> ttakePart from to xs = take (to-from+1) $ drop (from-1) xs
09:08:48 <qwertiest> takePart x y xs = drop (x-1) $ take y xs
09:09:08 <dmwit_> leimy: You probably don't want scanl' so much.
09:09:15 <dmwit_> leimy: scanr', maybe
09:09:30 <lilac> if you're using the elements of the list anyway, scanl' seems somewhat redundant
09:09:41 <leimy> dmwit: true
09:09:51 <qwertiest> takePart 5 8 [1..10] [5,6,7,8]
09:11:11 <dmwit> qwertiest: ewww, it's one-indexed?
09:11:23 <qwertiest> one-indexed?
09:11:33 <qwertiest> well both are very fast
09:12:11 <qwertiest> one-indexed?
09:12:17 <dmwit> qwertiest: I would expect takePart 5 8 [1..10] to return [6,7,8,9].
09:14:01 <Jedai> daf: [a..b] is syntaxic sugar for enumFromTo, you can't import it, it works for every type which has a Enum instance
09:15:48 <daf> Jedai: X(..) means "X and all its constructors/accessors" in import statements
09:16:48 <leimy> dmwit: scanr' is not very obvious though :-)
09:17:05 <dmwit> daf: PortNumber is a data type with no public constructors.
09:17:08 <Jedai> daf: Oh Ã§a. Encore faut-il que le module exporte le constructeur
09:17:15 <leimy> could reverse a scanl' to get it :-)
09:17:25 <daf> dmwit: if I do "import Network", I get a constructor for it
09:17:38 <lilac> > let f = scanl1 (flip (-)) in f.f.f.f.scanl1 (+) $ [1..]
09:17:49 <lambdabot>   [1,-1,4,-4,10,-10,20,-20,35,-35,56,-56,84,-84,120,-120,165,-165,220,-220,28...
09:17:58 <Jedai> daf: You should use "fromInteger" (there's good reason for it, since it's not a simple application of the constructor on all platforms)
09:18:04 <leimy> hmmm
09:18:07 <leimy> actually one can't
09:18:13 <leimy> at least not obviously
09:18:19 * leimy leaves for a bit
09:18:40 <dmwit> daf: ...I don't.
09:18:46 <dmwit> daf: I get a type, but no constructors.
09:19:32 <daf> oh, PortNumber is a constructor for PortID?
09:19:47 <dmwit> Oh, yep. =)
09:19:55 <allbery_b> :t toEnum 22 :: PortNumber
09:19:57 <lambdabot>     Not in scope: type constructor or class `PortNumber'
09:20:04 <allbery_b> :t toEnum 22 :: Network.PortNumber
09:20:05 <dmwit> (Separate namespaces) ++
09:20:06 <lambdabot> Network.Socket.PortNumber
09:20:20 <dmwit> :t Network.PortNumber 22
09:20:21 <lambdabot> Network.PortID
09:20:24 <dmwit> hehehe
09:20:48 <daf> I'm still confused
09:20:56 <SamB_XP> @hoogle PortNumber
09:20:57 <lambdabot> No results found
09:20:58 <Jedai> intToPortNumber :: Int -> PortNumber
09:20:58 <Jedai> intToPortNumber v = PortNum (htons (fromIntegral v))
09:21:00 <SamB_XP> huh
09:21:20 <daf> oh, perhaps it's because there's a PortNumber type and a PortNumber constructor that's for a different Prelude Network> :t PortNumber 1234
09:21:23 <daf> PortNumber 1234 :: PortID
09:21:28 <daf> oops
09:21:32 <daf> oh, perhaps it's because there's a PortNumber type and a PortNumber constructor that's for a different type
09:21:38 <dmwit> daf: exactly
09:21:48 <daf> confusing!
09:21:49 <Jedai> daf: As you see, PortNumber is a newtype from Network.Socket which is newtyped (and it's constructor PortNum isn't exported for good reason)
09:21:50 <SamB_XP> it looks like the port numbers are kept in network byte order ...
09:22:15 <Jedai> daf: And it's also a constructor for PortID (but then it is exported)
09:22:55 <daf> Jedai: well, presumably the Integral instance does the right thing anyway
09:23:09 <Jedai> daf: Yeah, that's why you should use it
09:23:48 <daf> why have the exported PortNumber constructor at all then?
09:24:00 <dmwit> daf: ...so you can make PortIDs?
09:24:51 <Jedai> daf: You mean the exported constructor for PortID ? Because you can construct PortID from other things than numbers (protocols for example)
09:25:05 <daf> hmm, right
09:26:30 <dmwit> What do {} mean in ghc-pkg list lists?
09:27:09 <Jedai> daf: In other word you should never use the PortNumber type yourself, just use PortID, and when you write "PortNumber 10000" the right thing happens (thanks to the Num instance for PortNumber)
09:27:35 <Jedai> dmwit: That a dependance to this package has been unregistered (it's bad !)
09:27:51 <daf> Jedai: nod. that's what I was doing all along; I just got horribly confused :)
09:28:03 <dmwit> Jedai: That's fine, I've been messing around with manual unregistering.  So I'll just unregister those, too.  Thanks for the tip.
09:45:52 <qwertiest> what is the bets referencemanual for opengl/glut?
09:46:13 <Zao> For GL, the coloured books.
09:46:23 <Zao> For glut, most probably the bundled docs or the freeglut ones.
09:55:50 <dejones> Is it generally considered impolite to post an email on two mailing lists?  I have a problem with OpenGL in Haskell and I want to post on haskell-cafe and hopengl mailing lists...
09:57:49 <hackage> Uploaded to hackage: protocol-buffers 0.2.8
09:59:16 <Axman6> dejones: not afaik. usually a good way to ensure you get a reply i'd say
10:01:04 <SamB_XP> probably depends on which two. those two sound reasonable ...
10:01:41 <SamB_XP> now, cross-posting a question about whether to use emacs or vi to the emacs and vi newsgroups... that's generally considered bad form ;-)
10:01:51 <dejones> Heh, thanks. :)
10:17:49 <araujo> mmm...
10:17:56 <araujo> anybody using c.h.o here?
10:20:23 <dons> http://www.reddit.com/r/programming/comments/72jpn/ghc_on_opensparc_now_congratulations_to_sun/
10:20:26 <lambdabot> Title: GHC on OpenSPARC now! Congratulations to Sun / Haskell.org project winner: Ben L ..., http://tinyurl.com/3sjhyd
10:21:21 <araujo> nice :-)
10:22:42 <scodil> what's the status of hs-plugins?
10:23:01 <SamB_XP> uh ... purple alert?
10:23:09 <dons> unmaintained. patches accepted.
10:23:13 * araujo wonders how long it takes to approve c.h.o projects
10:23:17 <dons> use ghc-api if possible.
10:23:58 <dcoutts_> araujo: it's me who does it and I'm a bit busy :-)
10:24:06 <araujo> dcoutts_, oooh
10:24:12 * araujo hides and said nothing
10:24:18 <araujo> dcoutts_!!!!!
10:24:23 <dcoutts_> dons: oh, I see the announce is on reddit already :-)
10:25:14 <dons> see also haskell.org
10:25:37 * araujo blames dons for intimidating other languages communities through reddit
10:25:37 <dons> dcoutts_: you leaving soon? or tomorrow?
10:25:42 <dons> araujo: heh
10:25:52 <SamB_XP> araujo: *said* nothing?
10:26:20 <dcoutts_> dons: tomorrow early afternoon local time, arriving mid afternoon local time (yay for travelling in the right direction)
10:26:32 <dons> ah yes.
10:27:04 <araujo> SamB_XP, right .. I didn't know it was dcoutts :-P
10:27:08 <dcoutts_> dons: I've booked into a hostel in Seattle for tomorrow night and I'll catch the ferry early in the morning, should arrive about 11am on Monday
10:27:14 <dons> ok.
10:36:17 * dcoutts_ packs his Earl Grey tea
10:36:31 <dcoutts_> it's barbarian lands I'm travelling to I tell you
10:36:36 <mc__> yummy, earl grey
10:37:16 <dons> dcoutts_: oh no!
10:37:26 <dons> there's a wonderflu tea shop right near my house.
10:37:26 <dmwit> > 68 / 61
10:37:28 <lambdabot>   1.1147540983606556
10:37:35 <dons> but canada, well.. they should have tttea.
10:37:46 <dcoutts_> dons: oh great, well my supply ought to last until I hit Portland :-)
10:37:54 <dons> ok :)
10:38:29 <dons> dcoutts_: http://www.teazone.com/
10:38:30 <lambdabot> Title: BUY TEA ONLINE HIGH QUALITY LOOSE LEAF FROM THE TEAZONE.COM
10:38:52 <dons> hehe
10:38:54 <ben_m> map Char.toLower above_line
10:39:09 <ben_m> well
10:39:11 <dcoutts_> heh, looks nice
10:39:37 <scodil> dons: in uvector, UArr methods lengthU and indexU are hidden, defaulting to the O(n) stream versions and preventing new UArr instances. Is this on purpose?
10:39:55 <dons> well, yes. *but* the goal is to support both, sensibly.
10:40:10 <dons> i've patches in my inbox for this.
10:40:19 <dons> thanks for reminding me :)
10:40:32 * Nafai isn't sure he would go to a wonderflu shop
10:41:02 <dons> hehe
10:41:40 <scodil> yeah I don't mind having to specify which version (O(1) vs O(n)) but Data.Array.Vector.UArr is hidden in the .cabal so I don't have a choice :)
10:42:04 <scodil> do you have any plans to work in the R.L. array recycling stuff?
10:42:15 <dons> maybe. we could merge the two.
10:42:23 <dons> so how do you want the api hiding resolved?
10:43:08 <dons> the patch in my inbox just hides the fusible versions, it seems.
10:43:18 <dons> hunk ./Data/Array/Vector.hs 182
10:43:18 <dons> -import Data.Array.Vector.UArr hiding (lengthU, indexU)
10:43:18 <dons> +import Data.Array.Vector.UArr
10:43:48 <Olathe> YArr
10:43:53 <scodil> ack. who thought ctrl-w would be a good shortcut for /part
10:43:54 <dons> i guess uses expect O(1) things by default, but if they're programming for fusion, they can ask for the special onnes.
10:43:57 <dons> Olathe: hehe
10:43:59 <dons> good thinking.
10:44:06 <dons> dcoutts_: we should have called them YArrs
10:44:08 <Nafai> Olathe: You're a day late :)
10:44:13 <Olathe> Oh :(
10:44:31 <dcoutts_> dons: clearly
10:44:52 <scodil> dons: yeah I just need Data.Array.Vector.UArr un-hidden in the .cabal. The choice of which to make the default is a philosophical one I leave to you. That patch I sent was just to illustrate things, not meant to be a solution
10:45:05 <dons> ok.
10:45:14 <dons> yes, just exposing it in the .cabal might be enough for now.
10:45:18 <dons> i'll have a play with it this week.
10:46:12 <scodil> personally, I think its kind of silly to default to the O(n). Do you have any non-trivial examples that use indexU on streams?
10:46:22 <scodil> lengthU I can understand. like lengthU . filter
10:46:27 <dons> that's exciting. an mpfr binding on hackage. i was   working on just such a thing.
10:46:39 <dons> scodil: probably not, that's true.
10:46:54 <dcoutts_> scodil: on the other hand it's silly to write out the whole array if you just need one element
10:47:00 <dons> but its a philosophical thing. everything should fuse!
10:47:19 <dcoutts_> which is why it has to do both ways for these kinds of ops
10:47:22 <scodil> dcoutts_: yeah true that's the motivation. I just can't think of any code that would do that.
10:47:37 <scodil> indexU is redundant, tho. Its just dropU n . head
10:47:37 <dcoutts_> scodil: I'm sure there are cases
10:47:38 <ddarius> dons: Have you looked at APL-style dragging and beating?
10:47:54 <SamB_XP> ddarius: APL sounds abusive
10:48:05 <dons> nope.
10:48:42 <dcoutts_> scodil: admittedly there are probably fewer for fusible arrays than for fusible lists
10:48:53 <newsham> dcoutts is importing drugs?
10:49:12 <SamB_XP> newsham: what?
10:49:18 <dcoutts_> newsham: I hope the FDA would not see it that way
10:49:21 <newsham> [07:33] * dcoutts_ packs his Earl Grey tea
10:49:35 <SamB_XP> oh, you mean he's bringing some back from canada with him?
10:49:53 <SamB_XP> no?
10:50:00 <dcoutts_> no, I'm importing it into the USA and then re-exporting it to Canada
10:50:01 <SamB_XP> I don't think Earl Grey is a drug
10:50:10 <hjon> you have no idea, SamB_XP
10:50:10 <dcoutts_> SamB_XP: oh, you're so wrong
10:50:12 <newsham> it has caffeine
10:50:22 <SamB_XP> ... I mean, according to the FDA
10:50:25 * dcoutts_ needs is Earl Grey to get up in the morning
10:50:27 <hjon> :-D
10:50:32 <dcoutts_> total addiction
10:51:00 <ddarius> dons: It was introduced in this thesis: http://www.slac.stanford.edu/pubs/slacreports/slac-r-114.html  It was written in the 70's and obviously uses APL so might be a bit tough to read.
10:51:01 <lambdabot> Title: SLAC-R-114 -- An APL Machine
10:51:40 <Baughn> Is any of the stuff in Recycling Arrays actually implemented in ghc?
10:51:43 <SamB_XP> the packaging would suggest that it is considered to be a food ;-P
10:51:57 <dons> Baughn: yeah. that's the current implementation.
10:52:00 <scodil> Baughn: yeah its on hackage, called vector
10:52:20 <scodil> its experimental, though. I've found bugs. Or rather, omissions
10:53:04 <rwanderley> hi, am searching for sites where I can host darcs repositories, like http://freehg.org or http://github.com
10:53:13 <dons> rwanderley: code.haskell.org
10:53:15 <lambdabot> Title: Mercurial Hosting - freeHg.org
10:53:21 <rwanderley> dons: thanks :D
10:53:21 <dons> visit community.haskell.org, and request an account.
10:53:30 <dons> its not as fancy as github (its a bit older), but it gets the job done.
10:54:01 * Baughn is seriously pondering switching to git, actually. Darcs is nice, but.. oh so very slow
10:54:15 <rwanderley> ok, it's everything I need.
10:55:31 <dons> http://www.reddit.com/r/programming/comments/72juq/haskell_weekly_news_generics_pandoc_gadts_qt/
10:55:33 <lambdabot> Title: Haskell Weekly News: generics, pandoc, GADTs, Qt bindings, ICFP... : programming, http://tinyurl.com/3em9yx
10:55:36 <dons> Baughn: try darcs 2 first.
10:55:43 <dons> using darcs 2 format repos.
10:55:46 <dons> rather nice, imo.
10:56:09 <subconscious> why is ATS so fast
10:56:21 <Baughn> Hm. I'll try.
10:56:28 * atsampso1 notes he really ought to take "ats" off his list of highlights...
10:56:40 <subconscious> is it because of dependent types
10:56:42 <subconscious> ?
10:56:52 <dons> subconscious: a lot of parallel versions have been submitted for it.
10:57:13 <dons> it would be nice if it was because of dependent types, but i think its because hongwei xi parallelised a bunch of his programs :)
10:57:36 <dons> e.g. spectral-norm, http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=all
10:57:38 <lambdabot> Title: spectral-norm benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/5zcma3
10:57:49 <hackage> Uploaded to hackage: protocol-buffers 0.2.9
10:57:49 <dons> if we parallelise a few more, we'll be on top of the shootout too :)
10:58:15 <dons> ah, very nice parallel binary trees.
10:58:30 <subconscious> so basically it's because Hongwei Xi is really good at programming?
10:59:11 <dons> hmm. the language is low level and fast. and the current entries are parallelised.
10:59:27 <dons> e.g. http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=all
10:59:29 <lambdabot> Title: binary-trees benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Languag ..., http://tinyurl.com/69l8ag
10:59:35 <dons> only entry that comes close to decent utilisation.
10:59:46 <subconscious> can a Haskell -> ATS complier be fast?
11:00:12 <dons> though that might be cheating, that program. due to val () = gc_chunk_count_limit_set (1 << 15) // no max
11:00:15 <dons> not sure.
11:00:16 <SamB_XP> what is ATS?
11:00:23 <monochrom> Perhaps the best approach is to put Hongwei Xi inside your computer. :)
11:00:46 <subconscious> ATS is a programming language SamB
11:01:01 <dmwit> subconscious: It will certainly not be faster than compiling to ASM using all the optimizations GHC already has.
11:01:02 <dons> subconscious: look carefully at the entries. it is parallelism that is at play here.
11:01:18 <Baughn> dons: How experimental is darcs-2, exactly?
11:01:27 <dons> it isn't experimental?
11:01:40 <Baughn> "--darcs-2                  All features. Related repos must use same format [EXPERIMENTAL]"
11:01:40 <subconscious> dons but why would the erlang one gets 50% 50% 50% 50% ?
11:01:55 <subconscious> and ATS 94% 75% 75% 96%
11:01:58 <SamB_XP> Baughn: oh, you never mentioned the darcs 2 repository semantics ;-P
11:02:13 <subconscious> btw why are they comparing parallel programs with single thread ones?
11:02:28 <subconscious> SamB_XP: ATS has dependent types too
11:02:32 <SamB_XP> subconscious: 'cause nobody bothered to parallelize those?
11:02:53 <sm> Baughn, I think it's pretty solid, but not yet polished
11:02:56 <SamB_XP> subconscious: and in CPython's case, perhaps nobody can?
11:03:36 <newsham> hmm.. ghc's mandelbrot shoutout is now listed as "bad output"
11:04:05 <scodil> subconscious: also the ATS entries have a lot of inline C, using sse intrinsics
11:04:13 <dons> someone should have a go at parallel spectral-norm.
11:04:25 <dons> we have the fastest single core entry ,and there's examples for how to parallelise it.
11:04:28 <dons> so should be easy...
11:07:04 <ddarius> dons: This is shorter and more readable (though simpler I believe) http://serv2.ist.psu.edu:8080/viewdoc/summary?doi=10.1.1.52.3959  Check the references as well.
11:07:05 <lambdabot> Title: A New Approach to Vector Code Generation for Applicative Languages - CiteSeerX
11:08:05 <dons> ok. thanks ddarius
11:16:36 <newsham> are language shootout submissions archived in some darcs repository?
11:17:31 <scodil> dons: any plans to add sorting to uvector?
11:17:53 <tsar> is there way to do inheritance on datas?
11:18:33 <dmwit> Inheritance isn't done much in Haskell.
11:18:34 <tristes_tigres> tsar: instance delaraions ?
11:18:38 <dmwit> We use type classes instead.
11:18:52 <dmwit> They're a much more precise tool, I think.
11:18:52 <Beelsebob> ddarius: bloody hell, the new citeseer is 1000x better than the old
11:19:01 <dmwit> Beelsebob: yeah!
11:19:07 <tsar> if u get what i mean? data Enemy = Enemy { life ::Int, shots :: Int } data minion extends Enemy with bombagun
11:19:14 <tsar> :)
11:19:22 <tristes_tigres> dmwit: not done much means that it can be done ?
11:20:12 <dmwit> tristes_tigres: Well... I dunno.  Maybe with Dynamic?
11:20:17 * dmwit hasn't really seen it
11:20:27 <tristes_tigres> http://www.google.com/search?client=opera&rls=ru&q=site:wiki.haskell.org+inheritance
11:20:29 <lambdabot> Title: site:wiki.haskell.org inheritance - Google Search, http://tinyurl.com/3ehyxe
11:20:40 <tristes_tigres> nothing found
11:20:57 <tristes_tigres> with Data.Generic ?
11:21:50 <ddarius> Beelsebob: I'm not sure if you're being sarcastic or what makes you think that.
11:24:03 <tristes_tigres> hmm, still no GHC 6.10
11:24:17 <tristes_tigres> they said on Sept 19
11:24:51 <shrughes> i want my money back
11:25:04 <tsar> is there a simple drawLine(from, to)-functiom in openGL, i cant find a good API-doc
11:25:06 <monochrom> Heheheh
11:25:51 <monochrom> Two large electronics stores here also said new iPods on Sept 19. :)
11:25:57 <shrughes> tsar: it's generally glBegin(GL_LINES); glVertex(...); glVertex(...); glEnd().  Look for the haskell equivalent of glbegin
11:26:30 <shrughes> tsar: i'm pretty sure it's some function of type ShapeType -> IO a -> IO a
11:26:42 <shrughes> where "ShapeType" is some type with values such as GL_LINES
11:27:44 <ddarius> @hoogle renderPrimitive
11:27:45 <lambdabot> No results found
11:27:58 <shrughes> renderPrimitive :: PrimitiveMode -> IO a -> IO a
11:28:19 <dons> scodil: there's a patch in my inbox with a high performance sort.
11:28:39 <dons> scodil: so thanks, i'll apply both.
11:28:56 <scodil> I'm glad I asked cause I just started writing a sort function :)
11:29:42 <scodil> what kind of sort is it?
11:30:49 <tsar> where can I read Core?
11:31:30 <Jedai> tristes_tigres: Certain notions of inheritance can be found in HList or in the Data Types A La Carte method
11:32:30 <tristes_tigres> Jedai: is it in GHC distribution ?
11:32:48 <scodil> tsar: ghc -c MyModule.hs -ddump-simpl.  Or were you talking about papers about the Core language?
11:33:01 <Jedai> tristes_tigres: No, DTALC is a method and HList is a package
11:33:23 <tristes_tigres> Jedai: Then it does not exist :-)
11:33:56 <tsar> scodil: code
11:34:02 <Jedai> tristes_tigres: By this definition, none of your code exists either, so it don't matter anyway
11:34:27 <tsar> why are bytestrings not the standard strings?
11:34:36 <tsar> and why isnt qualified import standard?
11:34:43 <dmwit_> Because they weren't around when the standard was being made.
11:34:52 <tsar> so change the staNDARD...
11:34:55 <dmwit_> Because qualified is annoying for one-offs, and not a big hassle for big projects.
11:35:16 <tsar> one-offs?
11:35:18 <dmwit> They're working on a new standard, but it's not out yet.
11:35:32 <dmwit> In the mean-time, it's not so bad, really.  The library is there if you want to use it.
11:35:38 <tsar> yes
11:35:56 <dons> tsar: and they're restricted.
11:35:59 <dmwit> (One-offs are small, short projects, made to be used once or twice at most; they're mainly for automating some single-shot thing.)
11:36:13 <tsar> http://blog.tmorris.net/20-intermediate-haskell-exercises/
11:36:16 <lambdabot> Title: Î» Tonyâs blog Î» Â» Blog Archive Â» 20 Intermediate Haskell Exercises
11:36:30 <tsar> what is that? i odnt even get what inm supposed to do
11:36:44 <geezusfreeek> tsar: replace the error lines with code that type checks
11:36:55 <tsar> write some function that implemnts the declaration?
11:37:01 <geezusfreeek> right
11:37:16 <Baughn> tsar: When you write a while or for-loop in bash, that's a one-off. Hopefully. ;)
11:37:39 <monochrom> Haha, the comments also imply readers don't know what to do. :)
11:39:10 <subconscious> is ghc 6.10 out?
11:39:14 <dons> not yet.
11:39:39 <lilac> tsar: are we allowed to use furry = fmap for the first few? :)
11:39:47 <monochrom> Hahahaha
11:40:02 <geezusfreeek> i think that defeats the purpose :P
11:40:08 <lilac> aww
11:40:14 <Baughn> dmwit_: It would be nice to be able to say "import Data.Map(Map), qualified(...) as M" or some such. Just for compactness.
11:40:16 <monochrom> Hell, define fmap for all types there. Then use furry = fmap throughout. :)
11:40:29 <Baughn> dmwit_: Well, probably s/(...)// on that one, but you get the picture
11:40:44 <lilac> monochrom: you also need unicorn = return and banana = (>>=) :)
11:41:02 <monochrom> Oh oops, I didn't really read the whole thing.
11:41:08 <dmwit_> Baughn: But "qualified" and "as" are orthogonal, which makes that syntax a bit weird-looking to me.
11:41:27 <monochrom> monads go bananas
11:41:45 <Baughn> dmwit: The idea is that it's importing the same package twice, with distinct qualifications
11:41:54 <Baughn> That is, it's equivalent to the usual two-line Map import
11:41:58 <lilac> does anyone else think that (=<<) would be a better primitive than (>>=)
11:42:00 <dmwit> I know.
11:42:05 <monochrom> "haskell programming with furries, unicorns, and bananas"
11:42:21 <dmwit> lilac: I've sometimes thought (.) should be flipped, despite the strong mathematical background.
11:42:32 <dmwit> lilac: I can't say I've wished (>>=) was flipped, though.
11:42:38 <monochrom> I think that >>= is a better primitive than =<<.
11:42:53 <lilac> dmwit: well, given you want (.) flipped, i can understand that :)
11:43:10 <lilac> (>>=) hides the fact that it's a lift
11:43:20 <shrughes> >>= keeps the order of effects in the order of reading
11:43:24 <Baughn> Data flows right-to-left if you *don't* have (.). I can't say I mind it flowing the same with with (.).
11:43:37 <dmwit> Baughn: ...eh?
11:43:45 <lilac> (=<<) :: (a -> m b) -> (m a -> m b) makes it clear that it's a lift
11:43:46 <SamB_XP> that's true
11:43:49 <dmwit> Baughn: Oh, you mean function application?
11:43:53 <SamB_XP> should we flip ' ' as well ?
11:44:03 <monochrom> we should flip everything.
11:44:23 <Beelsebob> ddarius: it clearly gives the abstract, a link to the document and a bibtex entry
11:44:31 <monochrom> we should also flip everything we flip.
11:44:35 <Baughn> Why not? Let's change the operator names to arabic, while we're at it, so people don't assume they have the standard dictionary meaning.
11:44:38 <Beelsebob> as far as I'm concerned, those are the most important features
11:44:49 <monochrom> I agree with Baughn.
11:44:50 <Beelsebob> the old site had all sorts of other shit all over it
11:44:50 <SamB_XP> â­like this?
11:44:53 <Baughn> dmwit: Yes
11:44:54 <SamB_XP> hmm, no, that didn't work
11:45:17 * lilac thinks bind2nd would be a better name for flip too...
11:45:32 <SamB_XP> but arabic plays havoc with x-chat doesn't it?
11:45:42 <lilac> perhaps i'm giving away my C++ background with that one though
11:45:48 <monochrom> The old citeseer design focused on "what this cites" and "what cite this". That's why.
11:45:58 <Baughn>                             siht ekil edoc ot ekil d'I yas t'nac I
11:46:31 <halberd> if you change the operator to Arabic then people who speak Arabic might get confused and think it has the standard dictionary meaning
11:46:39 <Baughn> ..oh dear, off by one. Whoops.
11:46:46 <monochrom> If you have arabic haskell source code on your laptop and you enter the US, the customs may mistaken it to be terrorist code. :)
11:47:04 <scodil> just tell them its safe
11:47:22 <SamB_XP> scodil: like they'd believe you
11:47:38 <scodil> but its been proven!
11:47:57 <Baughn> @instances Ord
11:47:58 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:48:00 <monochrom> Do you know the latest US border laws on laptops?  They can take your laptop away for further study, and they don't have to argue with you.
11:48:01 <lilac> "look guys, we can mathematically prove this arabic text can't launch the missiles"
11:48:18 <lilac> "it's right there in the type"
11:48:25 <SamB_XP> ... which is ALSO in arabic
11:48:38 <monochrom> hehehe
11:48:42 <geezusfreeek> they should learn to read arabic, duh
11:48:46 <Baughn> monochrom: I suppose they'd put me in prison for my arithmetic coding assignment, then. :/
11:48:53 <SamB_XP> not that it would help much if it wasn't
11:48:56 * lilac wonders how you write unsafePerformIO in arabic
11:48:58 <SamB_XP> Baughn: why?
11:49:09 <Baughn> SamB_XP: http://en.wikipedia.org/wiki/Arithmetic_coding#US_patents_on_arithmetic_coding
11:49:09 <monochrom> 0123456789 :)
11:49:11 <lambdabot> Title: Arithmetic coding - Wikipedia, the free encyclopedia, http://tinyurl.com/ywz5wc
11:49:17 <tristes_tigres> lilac: watch sept 11 footage to learn how
11:49:35 <monochrom> Actually 0123456789 are a bit different from the original arabic.
11:49:37 <tristes_tigres> that was pretty unsafe
11:49:54 <lilac> tristes_tigres: are you suggesting that was an accidental side-effect of some supposedly-pure process?
11:49:55 <sbahra> monochrom, yes, how so?
11:50:05 <scodil> the original arabic was 987654321
11:50:10 <monochrom> hahaha
11:50:12 <sbahra> Originally, we were using abjadi numerals.
11:50:20 <sbahra> Of course, lacking 0.
11:50:27 <geezusfreeek> lilac: http://translate.google.com/translate_t#en|ar|unsafe%20Perform%20IO ... obviously going to be 100% accurate
11:50:27 <lambdabot> Title: Google Translate, http://translate.google.com/translate_t#en|ar|unsafe%20Perform%20IO
11:50:43 <tristes_tigres> lilac: Certainly !
11:51:51 <lilac> ??? ??????? ???? ??????? ????????
11:52:01 <tristes_tigres> it was just a bet on how small an jbject you can hit with a boing
11:53:52 <sbahra> It should just be: "a3mal I/O gher amn "
11:55:13 <SamB_XP> that's not how you spell boeing ;-)
11:55:32 <Baughn> is "take 2 (toList set)" going to be as efficient as using minView twice?
11:55:56 <Baughn> ..come to think of it, I need the resulting set too, so no matter.
11:56:26 <Saizan> in priciple it could be more efficient
11:58:03 <tristes_tigres> SamB: it did make a loud boing
11:58:14 <SamB_XP> it did ?
11:58:31 <niklaus> generating function coefficients any suggestions for libraries or software in linux
11:58:46 <salty-horse> hi. why does "round 2.5" evaluate to 2 while "round 3.5" evaluate to 4?
11:59:09 <SamB_XP> possibly round-to-even ?
11:59:18 <shrughes> > (round 2.5, round 3.5)
11:59:20 <salty-horse> SamB_XP, that seems to be the case, yes
11:59:20 <lambdabot>   (2,4)
11:59:24 <SamB_XP> > round 1.5
11:59:25 <lambdabot>   2
11:59:31 <mc__> salty-horse: because 2.5 is probably not 2.5
11:59:37 <shrughes> 2.5 should be exact
11:59:41 <SamB_XP> mc__: that isn't it at all
11:59:43 <Baughn> salty-horse: google://what every computer scientist should know about floating point
11:59:54 <subconscious> I want a better name than function call
11:59:57 <dons> arch haskell weekly updates, http://archhaskell.wordpress.com/2008/09/20/arch-haskell-news-sep-20-2008/
11:59:57 <subconscious> it's not a 'call'
11:59:58 <lambdabot> Title: Arch Haskell News: Sep 20 2008 Â« Arch Linux and Haskell, http://tinyurl.com/3owgbr
12:00:05 <dons> 576  packages :)
12:00:06 <subconscious> it's not an invokation .. what is it?
12:00:10 <Baughn> subconscious: dethunking
12:00:12 <SamB_XP> subconscious: applications
12:00:13 <SamB_XP> er.
12:00:14 <SamB_XP> application
12:00:19 <subconscious> ah thank you, that's perfect
12:01:02 <salty-horse> thanks Baughn
12:01:38 <tsar> anyone good at opengl? leaveMainLoop. i want to close everything and kill the process when i click close in the opengl window
12:01:44 <tsar> actionOnWindowClose = Exit
12:02:05 <tsar> but i dont get how to set actiononwindowclose, otuside main, and how to set it?
12:03:37 <ttt--> hi, something is failing when i try to install sqlite3 http://hpaste.org/10557
12:03:40 <ttt--> any ideas?
12:04:15 <Baughn> ttt--: You need to install sqlite3-dev, or whatever the package is called on your os
12:04:28 <Baughn> That is to say, its headers
12:04:53 <dons> go go go, http://www.reddit.com/r/programming/comments/72k4v/arch_linux_and_haskell_now_with_576_haskell/ :)
12:04:55 <Baughn> ttt--: "error: sqlite3.h: No such file or directory" <-- This is the critical line
12:04:59 <lambdabot> Title: Arch Linux and Haskell: now with 576 Haskell libraries and tools packaged : prog ..., http://tinyurl.com/4frs25
12:05:27 <ddarius> dons: All lies.  We all know there are no libraries for Haskell.
12:05:41 <dons> ddarius: hehe.
12:07:45 <ttt--> Baughn, thanks, it works now
12:10:07 <dons> ibid: did you get my email to subscribe arch-haskell news to p.h.o ? http://archhaskell.wordpress.com/feed/
12:11:51 <tsar> http://www.haskell.org/ghc/docs/latest/html/libraries/GLUT/Graphics-UI-GLUT-Begin.html#v%3AactionOnWindowClose
12:11:58 <lambdabot> Title: Graphics.UI.GLUT.Begin, http://tinyurl.com/4x26mf
12:12:00 <tsar> http://hpaste.org/10558
12:12:08 <tsar> how am i supposed to use it?
12:12:24 <tsar> http://hpaste.org/10559
12:12:49 <Baughn> ttt--: What are yoiu trying to do, exactly?
12:12:56 <Baughn> Er, tsar
12:13:06 <Baughn> tsar: First off.. mainLoop doesn't return. Ever.
12:13:56 <ttt--> im just trying some things out from the real world haskell book
12:14:08 <Baughn> Unless you call leaveMainLoop, that is. Which is not going to get called in your code, since you've got the call /after/ mainLoop..
12:14:12 <tsar> doesnt return?
12:14:16 <ttt--> oh
12:14:19 <Baughn> Not normally
12:14:31 <Baughn> tsar: leaveMainLoop is a freeglut extension. It works on linux, but isn't portable
12:14:42 <Baughn> tsar: Anyway, to use it, you'd have to have one of the callbacks calling it
12:14:43 <tsar> ok i use windows
12:15:21 <Baughn> Also, glut tends to get cranky if there isn't a display callback. Your clear callback should do fine.
12:16:14 <Baughn> tsar: Now, given that you've told glut to exit if you close the window (Which is also the default, I believe), you don't need to explicitly call leaveMainLoop either. Just close the window.
12:16:18 <Baughn> So, what's the problem again?
12:17:45 <tsar> it doesnt do that
12:18:09 <Baughn> What does it do?
12:19:05 <tsar> windows comes up, i close, it disappears, but the process is sitill running
12:19:19 <tsar> somehow in the background, emacs doesnt return to interpreter
12:19:41 <Deewiant> same here, that's what happens on windows
12:19:50 <Baughn> Hm. Well, that's not supposed to happen.
12:19:58 <tsar> http://hpaste.org/10560
12:20:20 <Baughn> Oh, hold on
12:20:30 <Baughn> tsar: OpenGL and GHCi don't play well
12:20:36 <Baughn> You'll have to compile and run as a program
12:20:40 <Deewiant> doesn't help
12:20:49 <Deewiant> because that's what I did ;-)
12:20:51 <Baughn> Might help later. *shrug*
12:21:47 <ttt--> are there any frameworks that do some kind of mapping of haskell data to sql databases?
12:22:32 <Baughn> Not that I know of. Sounds like an even worse idea than object-relational databases..
12:22:50 <ttt--> or does HDBC already do that
12:23:01 <Baughn> It is generally a good idea to make the database scheme /first/, but I can see tools generating some sort of haskell code to interface to it
12:26:04 <tsar> i tried compiled too. when i close the window the process vectorspace.exe is still running
12:26:30 <ibid> dons: i think i did
12:27:15 <dons> ibid: hmm, i don't see it in the list?
12:27:58 <dons> this site, http://archhaskell.wordpress.com/  this feed, http://archhaskell.wordpress.com/feed/ ?
12:27:59 <lambdabot> Title: Arch Linux and Haskell
12:29:12 <dejones> dons: A functional language, ATS, now tops C++ for 1st place on the quad-core shootout: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all --- are you going to let another functional language beat you?  You're the Haskell optimization master.  :)
12:29:14 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
12:29:34 <dons> dejones: we just need to *parallelise* not optimise.
12:29:40 <dons> that's why ATS is ahead :)
12:29:48 <dons> hint: submit a parrallel spectral-norm implementation
12:29:56 <dejones> dons: I'm joking really.  I know you are super busy right now with GHC release and other libraries and work.
12:30:12 <dons> submitting parallel shootout programs is something the community can do!
12:30:21 <ibid> dons: on what list?
12:30:35 <dons> ibid: the author list of feeds on planet haskell?
12:30:36 <ibid> dons: my pdo processing backlog isn't public, i think
12:30:49 <ibid> dons: i didn't say i've processed it, did i?
12:30:53 <dons> ah, so maybe just in the backlog :)
12:30:55 <dons> i see.
12:31:21 <dejones> dons: As soon as I get this parallel profiling support for GHC working, I'll have a reason to implement some parallel programs; so, I may just implement it then.
12:31:31 <tsar> http://www.haskell.org/haskellwiki/OpenGLTutorial1 did that, same thing, it draws the correct pciture but thn the process isnt killed when window is closed
12:31:32 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
12:31:32 <dons> good!
12:31:51 <dons> spectral-norm doesn't look too hard, http://shootout.alioth.debian.org/u64q/benchmark.php?test=spectralnorm&lang=all
12:31:51 * ddarius only has one core.
12:31:53 <lambdabot> Title: spectral-norm benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/5zcma3
12:31:54 <ibid> and i'm not going to today. no energy. perhaps because of my recent oral surgery, or perhaps just out of energy in general
12:31:55 <dons> very short.
12:32:00 <dons> ibid: 'sok.
12:32:23 <dons> the important thing is to have someone find the parallelisation strategy. then we just copy that.
12:32:35 <dons> e.g. translate the current leading lisp impl to faster multicore haskell.
12:33:04 <dejones> hm.
12:33:13 <dejones> yea, it is a pretty short program
12:33:23 <dons> it may be possible to just naively parallelise the current spectral-norm haskell entry
12:33:28 <dons> which is the fastest single core entry atm.
12:33:39 <dons> it's using local state.
12:33:55 <dons> powerMethod !i !n !u !v = allocaArray n $ \t -> replicateM_ i $ timesAtAv t n u v >> timesAtAv t n v u
12:34:11 <dons> so move the state insie, and run those things in parallel.
12:34:24 <dons> the replicateM_ looks stupidly easy
12:34:33 * dons tries.
12:34:43 <dons> patricia tries.
12:35:10 <dejones> lol
12:35:24 * ushdf ?
12:35:38 <ushdf> i figure if programming is an art of formal semantics
12:35:42 <ushdf> haskell is cubism!
12:35:56 <subconscious> hehe
12:36:08 <scodil> dons: is the stream library in uvector amenable to lazy ST code?  Like keeping an ST state thread in the Stream's state. Or do ST functions have to be run to completion in between Yields
12:36:26 <subconscious> assembly is pointillism
12:36:30 <newsham> simple MVar question:  http://hpaste.org/10561
12:37:20 <dejones> dons: Yah, replicateM_ does seem like the obvious place to parallelize.  Good job spotting that one so quickly.  :)
12:37:26 <newsham> hmm.. wait.. is mvar not a queue?  heh.
12:37:32 <dejones> dons is Yoda.  :)
12:37:45 <newsham> i need a chan not an mvar, nevermind
12:38:26 <tsar> http://hpaste.org/10562 , managed to draw a line, woot! still doesnt close properly though. just in case someone was interested in opengl too...
12:39:12 <scodil> tsar: the flush is unnecessary
12:39:31 <dejones> tsar: I can't seem to get opengl to link correctly when building Haskell programs.  :(
12:39:35 <Deewiant> tsar: I generally bypass the closing issue by using exitWith in response to alt+f4 or some such, I haven't managed to get clicking on the "X" to close the window working though
12:41:11 <newsham> i have a parallelized mandelbrot that does shootout in 6.2s with +N2 instead of 9.3s unparallelized.
12:41:27 <newsham> who do I talk to about shootout stuff?
12:42:05 <ddarius> newsham: Have you tried other -N values?
12:42:10 <subconscious> newsham: would you hpaste it, I'd like to see it
12:42:14 <dons> ./B 5500 +RTS -N2  19.30s user 0.03s system 198% cpu 9.755 total  /
12:42:15 <newsham> ddarius: i only have 2 cpus here.
12:42:18 <newsham> so I didnt try others
12:42:30 <ddarius> newsham: It's often beneficial to set it to one or two higher.
12:42:34 * dons loves naive parallelisation
12:42:36 <dejones> newsham: yes, please hpaste it.  I think you could also mail it to haskell-cafe mailing list, I'm sure others would like to see it.
12:42:44 <newsham> sub: http://www.thenewsh.com/~newsham/shootout/
12:42:45 <lambdabot> Title: Directory /~newsham/shootout/
12:43:07 <dons> so that just halved the running time.
12:43:13 <dons> so we may reclaim #1 on 4 cores :)
12:43:20 * dons tries on 4 cores.
12:43:22 <dejones> dons, lol
12:44:11 <dejones> newsham: which file is it in that directory?
12:44:27 <newsham> mand3.hs is parallelized, mand.hs is original, mand2.hs has comments (starting point for mand3)
12:44:30 <newsham> changes.diff.txt has changes
12:44:36 <dons> it's a little unsafe, using replicateM_ $ forkIO $ ...
12:44:41 <dejones> newsham: nevermind, I read the README  ;)
12:44:43 <dons> either we get the result, or we get NaN :)
12:44:46 <newsham> dons: why's that?
12:44:47 <dons> $ time ./B 5500 +RTS -N4
12:44:47 <dons> 1.274224153
12:44:47 <dons> ./B 5500 +RTS -N4  12.94s user 0.02s system 316% cpu 4.094 total
12:44:55 <dons> the threads are updating a global resource.
12:44:59 <dons> so we should really MVar-ify that.
12:45:09 <newsham> the threads dont modify any shared state
12:45:11 <dejones> dons: NaN?  Because no Mvars?
12:45:13 <dejones> Ahh
12:45:30 <newsham> they each write to their own buffer which is passed by mvar back to the IO thread
12:45:46 <dons> $ time ./B 5500 +RTS -N5
12:45:46 <dons> 1.274224153
12:45:46 <dons> ./B 5500 +RTS -N5  12.92s user 0.02s system 356% cpu 3.634 total
12:45:50 <dons> so that'll easily win on the shootout.
12:45:58 <dons> just have to get it to give the right result each time :)
12:46:01 <dejones> lol
12:46:17 <newsham> mandelbrot result compares identical to the unparallelized
12:46:29 <ddarius> newsham: dons isn't talking about the mandelbrot
12:46:38 <ushdf> > + 1 2
12:46:39 <lambdabot>   mueval: Prelude.read: no parse
12:46:40 <newsham> oh...
12:46:42 <newsham> apologies
12:46:46 <ushdf> > 1 + 2
12:46:47 <lambdabot>   3
12:47:00 <ushdf> > map (+ 2) [1..100]
12:47:01 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
12:47:11 <ushdf> > map (^ $_) [1..100]
12:47:12 <lambdabot>   mueval: Prelude.read: no parse
12:47:25 <ushdf> > map (** $_) [1..100]
12:47:27 <lambdabot>   mueval: Prelude.read: no parse
12:47:31 * ushdf forgets
12:47:32 <Olathe> > iterate (+1) 3
12:47:33 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
12:47:48 <matthew-_> ushdf: dude, this isn't perl ;-)
12:47:52 <dons> ah, i need to wait for them.
12:47:58 <ushdf> so many languages...
12:48:56 <dejones> dons: what for them?
12:49:02 <dejones> * why wait for them?
12:49:12 <dons> that's why it sometimes returns NaN
12:49:20 <dons> the main thread doesn't wait for the forked threads to all finish
12:49:23 <Olathe> > scanl1 (flip (^)) [1..100]
12:49:26 <dejones> dons: Oh, wait for all thread to finish?
12:49:27 <dejones> yea
12:49:30 <lambdabot>   [1,2,9,262144,6206069878660874470748320557284679309194219265199117173177383...
12:49:49 <dons> yeah
12:49:57 <Olathe> > scanl1 (^) [1..100]
12:49:59 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:50:15 <dons> its interesting: if the code is all in IO, it can be easy to parallelise using forkIO.
12:50:48 <Deewiant> > scanr1 (^) [1..5]
12:50:59 <ushdf> > gcd 1205984229 12043981209
12:51:02 <lambdabot>   mueval: Prelude.read: no parse
12:51:02 <lambdabot>  mueval: out of memory (requested 68157440 b...
12:51:05 <ushdf> > gcd 1205984229 1204398
12:51:06 <lambdabot>   3
12:51:07 <lambdabot>   3
12:51:11 <ushdf> > gcd 1205984229 1204399
12:51:13 <lambdabot>   1
12:51:17 <ushdf> > gcd 1205984229 1204400
12:51:18 <lambdabot>  Terminated
12:51:22 <Deewiant> > scanr1 (^) [1..4]
12:51:24 <lambdabot>   [1,2417851639229258349412352,81,4]
12:51:39 <Olathe> > map (gcd 1205984229) [1204398..]
12:51:51 <lambdabot>   [3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,1,1,3,...
12:53:08 * Baughn wonders where Data.Bag has gone
12:53:28 <dmwit> Maybe you haven't installed Edison?
12:53:50 <Baughn> Could be.
12:54:55 <Olathe> > let factor n = if n .&. 1 == 0 then 2:factor (shiftR n 1) else f' 3 n where f' _ 1 = []; f' p n = if mod n p == 0 then p:f' p (div n p) else f' (p + 2) n in factor 1205984229
12:54:58 <lambdabot>   [3,521,771583]
12:55:12 <Olathe> > let factor n = if n .&. 1 == 0 then 2:factor (shiftR n 1) else f' 3 n where f' _ 1 = []; f' p n = if mod n p == 0 then p:f' p (div n p) else f' (p + 2) n in factor 1204398
12:55:13 <lambdabot>   [2,3,3,13,5147]
12:57:08 <Deewiant> > map (head L.&&& length) . group $ [2,3,3,13,5147]
12:57:10 <lambdabot>   [(2,1),(3,2),(13,1),(5147,1)]
12:57:49 <hackage> Uploaded to hackage: uuid 0.1.1
12:57:50 <Olathe> Hmm...
12:57:51 <matthew-_> > let factor n = if n .&. 1 == 0 then 2:factor (shiftR n 1) else f' 3 n where f' _ 1 = []; f' p n = if mod n p == 0 then p:f' p (div n p) else f' (p + 2) n in factor 359334085968622831041960188598043661065388726959079837
12:58:05 <dejones> dons: are you saying in main: forkIO $ powerMethod 10 n u v  ?
12:58:07 <lambdabot>   thread killed
12:59:10 <Baughn> dmwit: ..I think I'm in love. This library needs to be in extra-libs.
12:59:22 <Olathe> > let factor n = [n] in factor 359334085968622831041960188598043661065388726959079837
12:59:24 <lambdabot>   [359334085968622831041960188598043661065388726959079837]
12:59:29 <dons> awesome, dejones, we're in business.
12:59:30 <Olathe> There, now it gets it :)
12:59:40 <matthew-_> Olathe: cheat ;)
12:59:47 <dejones> dons: did I help?  :)
12:59:49 <dejones> lol
12:59:50 <dmwit> Baughn: Oh, had you never seen Edison before?  Yeah, it's nice. =)
12:59:52 <dons> dejones: basically, powerMethod = replicateM_ $ forkIO $ ...
12:59:57 <dons> but then it needs to have the main thread wait.
13:00:02 <dons> using a children mvar list strategy.
13:00:10 <dons> which i just did. so testing on 4 cores now ...
13:00:22 <dejones> dons: nice!  I want to see the code when you're done.  :)
13:00:25 <dons> yep!
13:00:32 <Baughn> dmwit: I was going to use a bag as a queue. Now I have an actual queue. :D
13:00:33 <chr1s> dons: we should do a #haskell meeting somewhere in victoria.
13:00:42 <dons> chr1s: right!
13:00:42 <dmwit> hehehe
13:00:47 <dons>  chr1s #haskell-icfp
13:00:53 <chr1s> ah, yes.
13:01:00 * dejones wishes he could attend ICFP.  :/
13:01:23 <chr1s> dejones: you still have about a day to fly in ;)
13:01:27 <SamB_XP> why you go there NOW -- the contest is over ;-)
13:01:40 <dons> ok. 4 seconds on 4 cores
13:01:42 <dejones> chr1s: heh, it's not a "time issue" it is a funding issue.  ;)
13:01:47 <Olathe> Is there a way to make a "type" for all things that are Num, Bits, and Ix ?
13:01:55 <chr1s> dejones: hehe, I see.
13:01:58 <matthew-_> > let factor n = if n .&. 1 == 0 then 2:factor (shiftR n 1) else f' 3 n where f' _ 1 = []; f' p n = if mod n p == 0 then p:f' p (div n p) else f' (p + 2) n in factor (2^43112609 â 1)
13:02:00 <lambdabot>   mueval: Prelude.read: no parse
13:02:03 <dmwit> Olathe: Not really.
13:02:14 <Baughn> Olathe: (Num a, Bits a, Ix a) => a?
13:02:25 <Olathe> Ahh :(
13:02:29 <dmwit> Olathe: You can define a new class that has the same interface, and declare an instance for all things that are Num, Bits, Ix.
13:03:01 <dejones> dons: Alright, let's see the code.  Maybe post to haskell-cafe too?  Or your blog even.
13:03:04 <dmwit> instance (Num a, Bits a, Ix a) => NumBitsIx a where ...
13:03:13 <dejones> dons: I keep giving you more work, lol.
13:03:26 <dons> hang on...
13:03:29 <Olathe> Ahh...
13:03:31 <dejones> dons: :)
13:03:33 <Olathe> Alright, thanks.
13:03:33 <Deewiant> dmwit: that's class aliases, an extension which has been proposed but not implemented
13:03:37 <Deewiant> er
13:03:39 <Deewiant> Olathe: ^
13:04:01 <dmwit> In reality, though, it's not so bad to just type (Num a, Bits a, Ix a) each time you need it.
13:04:22 <ttt--> hi, i get an error: http://hpaste.org/10563  i think i have 2 different bytestring packages installed
13:04:49 <ttt--> do i need to uninstall the old one?
13:05:17 <Deewiant> rather, you need to build all your libraries against one or the other
13:05:18 <dmwit> Usually it's fine to have two versions of any particular library, so something else must be going wrong.
13:07:15 <Saizan> fps_maximum is explictly exported by ByteString?
13:07:40 <tsar> what does flush do?
13:07:56 <dmwit> tsar: It empties the buffer.
13:07:56 <SamB_XP> I once started implementing class aliases ... but then I found bugs in compiler I was doing it for that I couldn't see how to fix ...
13:07:58 <Baughn> tsar: Which one? hFlush? glFlush?
13:08:13 <Baughn> Well, "empties the buffer" is true in some sense for all of them
13:08:34 <dmwit> tsar: For files, that means writing to disk; for terminals, that means printing to screen; for network sockets, that means sending some data down the pipe; etc.
13:08:50 <Baughn> For files, that means flushing to the kernel
13:08:56 <dmwit> well, yeah
13:08:58 <Baughn> *Writing to disk* requires an fsync call. ;)
13:09:01 <dmwit> right
13:10:54 <Baughn> (It would be nice to have a call that tells it to write to disk as quickly as possible, but not actually wait to return until it has. Oh well.)
13:11:05 <Deewiant> Baughn: forkIO . flush
13:11:06 <Deewiant> ;-)
13:11:39 <Baughn> Deewiant: flush *doesn't*, as mentioned
13:11:41 <dmwit> That would seem to defeat the point of fsync.
13:11:52 <Baughn> dmwit: Not at all. Let's see..
13:11:55 <Deewiant> Baughn: ah yes, I see.
13:11:59 <dejones> dons: Crazy that the parallel Lisp implementation of spectral-norm takes 38KB of memory and the CPU utilization isn't all that great either...
13:12:00 <dmwit> The whole point of fsync is that you *know* that the disk is synched when it returns.
13:12:13 <Baughn> dmwit: Yes, but sometimes I don't care about that
13:12:20 <dejones> dons: C++ parallel implementation is much more efficient.
13:12:21 <Baughn> So yes, that's the point of fsync
13:12:48 <Baughn> For fflush, the point is to make other applications see the changes; it doesn't flush anything to disk at all, and it might be an hour until the OS decides to write it
13:12:53 <dmwit> forkIO fsync gives you no more guarantees than just not fsync'ing at all.
13:13:12 <Baughn> But sometimes I want to have something written to disk quickly, but don't mind doing some more work while the disk is writing
13:13:12 <tsar> what does flush do here then?
13:13:20 <dmwit> tsar: where?
13:13:22 <Baughn> tsar: As I was saying, /which flush/?
13:13:27 <Deewiant> GLUT.flush?
13:13:35 <ttt--> is there a way to find out which packages have been build using the old bytestring?
13:14:17 <Deewiant> ttt--: ghc-pkg describe... I /think/
13:14:50 <Baughn> tsar: If it's the glut one, you should be using swapBuffers instead
13:15:00 <tsar> DEE:YES
13:15:00 <ttt--> ok thanks
13:15:46 <Baughn> tsar: Besides that, the answer is very simple. For both flush and swapBuffers, it tells opengl to get what you've been drawing on the screen sometime in the bear future.
13:15:46 <Deewiant> Baughn: yeah, but what does it /do/.
13:16:18 <Baughn> (If you want it on the screen before the call returns, use glFinish instead. In practice, you don't.)
13:16:26 <Saizan> to implement something like tail -f one must use pooling?
13:16:37 <dmwit> inotify?
13:17:26 <bloggy-badger> Saizan: do you mean polling?
13:17:28 <dons> dejones: http://alioth.debian.org/tracker/index.php?func=detail&aid=311118&group_id=30402&atid=411646
13:17:30 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311118 GHC Haskell: paral ..., http://tinyurl.com/3r9bfg
13:17:47 <dons> i'll add it to the wiki
13:18:03 <Saizan> bloggy-badger: probably, i always get the number of o vs. l wrong
13:19:09 <dons> dejones: http://haskell.org/haskellwiki/Shootout/Parallel/SpectralNorm
13:19:10 <lambdabot> Title: Shootout/Parallel/SpectralNorm - HaskellWiki
13:19:13 <bloggy-badger> Saizan: pooling is managing a set or "pool" of ressources, polling is checking periodically for something
13:19:32 <Saizan> bloggy-badger: ok, so polling :)
13:19:43 <dmwit> Saizan: If you want strict backwards compatibility, polling is the way to go; if you don't mind requiring a newish version of the Linux kernel, inotify is nice.
13:19:54 <Saizan> dmwit: thanks, i'll look into that
13:19:56 <dejones> dons: Thanks!
13:20:46 <dejones> dons: CPU 3.78 sec, excellent.
13:20:59 <tsar> im confused on how vertex works:
13:21:01 <tsar> vertex $ (Vertex3 (0::GLfloat) (-0.9) (-0.3))
13:21:05 <dons> the only trick is the children waiting.
13:21:13 <tsar> this is a straight vertical line
13:21:13 <dons> otherwise, standard parallelisation there.
13:21:20 <tsar> from 0 0
13:21:33 <tsar> i thoguth 0.9 was x, 0.3 y
13:21:37 <tsar> so it shouldnt be straihgt. but it is
13:21:50 <tsar> anyway glut seems pretty easy to work with
13:22:19 <tsar> probably one of the easier interfaces to graphics since i muffled with pascal in high shcool lol
13:22:43 <dejones> dons: I am confused by this line: "allocaArray n $ \t -> timesAtAv t n u v >> timesAtAv t n v u", which was in the original and your's.  why call the function timesAtAv twice?
13:23:25 <ddarius> dons: IS the unboxing of that one loop necessary?
13:23:56 * dejones doesn't completely understand dons waiting trick.  ;)
13:24:00 <dejones> heh
13:24:50 <dons> ddarius: it used to be. not sure now. the key was getting an unchecked shift.
13:24:55 <dons> that *should* work in recent ghc's though
13:25:05 <dons> ddarius: legacy optimisations :)
13:25:15 <dons> most of the bang patterns would be uneeded too, i suspect
13:25:28 <tsar> hmm how can i keep the lines in the window when moving the window? when i move the window it "grabs the text from the screen"
13:26:24 <ddarius> dons: Wouldn't it be more sensical (though perhaps less performant) to return 'me' and use replicateM then wait =<< replicateM (...) ?
13:26:29 <jeffz> tsar, are you updating the screen?
13:26:55 <jeffz> tsar, if you don't redraw it and then move another window over it, it won't be repainted
13:27:19 <dons> ddarius: no idea. i just used the 'wait on children' example in Control.Concurrent.
13:27:28 <dons> so if that's what Simon Marlow reckons is the way to go, I'm fine with it.
13:28:11 <ttt--> is there a way to cabal uninstall a package?
13:28:16 <Deewiant> nope
13:28:27 <dons> ghc-pkg unregister foo
13:28:32 <Deewiant> if you want to force a reinstall, do... yeah, that
13:28:35 <ddarius> dons: What the heck?  wait should just be mapM_ takeMVar
13:28:39 <ddarius> That code is really bizarre
13:28:40 <Deewiant> but the files remain
13:28:55 <tsar> how do i repaint?
13:29:22 <dons> ddarius: hmm.
13:29:27 <dons> it has to take , then take.
13:29:32 <dmwit> tsar: Just admit your sins and invite Jesus into your heart. ;-)
13:29:44 <dons> mapM (takeMVar =<< takeMVar) children
13:29:44 <ushdf> i get a little nervous when i dooo, an -Syuuu
13:29:47 <dons> something like that.
13:29:54 <dons> ddarius: MVar [MVar ]
13:30:11 <ddarius> dons: I know, but I see no reason for that outer MVar
13:30:13 <Deewiant> I prefer a Chan ()
13:30:20 <olsner> ... not to mention all the use of peek and poke
13:30:21 <dons> the list is growing while we're waiting on it?
13:30:39 <tsar> dmwit: i did, he said i had to walk through the fires of hell and hed helpme. i politely declined and turned to #haskell instead
13:30:43 <dons> olsner: bare machine man.
13:30:46 <Deewiant> waitFor kids = forM_ kids . const . readChan
13:30:50 <dons> we could use STUArray
13:31:00 <olsner> or harpy :D
13:31:09 <ddarius> dons: Try powerMethod i n u v = mapM_ takeMVar =<< replicateM i $ do me <- newEmptyMVar; forkIO (child `finally` putMVar me ()); return me
13:31:19 <dons> ok.
13:31:50 <jeffz> tsar: if you are using glut, where if not in the idle callback have you put the code that puts things on the screen?
13:32:05 <olsner> would be fun to see if e.g. n-body and spectral-norm would be as fast with STArrays as they are with unsafe raw-memory operations
13:32:13 <newsham> dons: its faster on my dual cpu than the unparallelized.  how do I submit it to shootout?  I'll put it on the wiki now.
13:32:21 <jeffz> tsar, look at some of the examples
13:32:24 <dons> put it on the wiki, then i can submit.
13:32:30 <newsham> ok
13:32:33 <dons> i can test it on quad core, and i've a submission account.
13:34:06 <ddarius> dons: The benefit of the original wait children code would be that it can get rid of children immediately.  The code I've suggested will get rid of the synchronizing MVars in the order that the code was forked, not in the order that they finish.  For large values of 'i', this might be an issue (though not very likely)
13:34:15 <dons> ddarius: yes, it looks to be a bit slower
13:34:24 <dons> trying on quad core.
13:34:32 <tsar> jeff: i call a function display
13:34:38 <tsar> displayCallback $= display0
13:34:50 <ddarius> I imagine that it is the replicateM v. replicateM_ that makes the difference.
13:35:08 <dons> oh, looks ok on 4 core though
13:35:17 <dons> $ time ./D 5500 +RTS -N4
13:35:17 <dons> 1.274224153
13:35:17 <dons> ./D 5500 +RTS -N4  12.56s user 0.01s system 319% cpu 3.940 total
13:35:26 <dons> so same ball park. (lots of variation on 4 cores)
13:35:41 <dons> i'll submit it.
13:36:56 <dons> added it here,
13:36:56 <dons> http://haskell.org/haskellwiki/Shootout/Parallel/SpectralNorm
13:37:01 <lambdabot> Title: Shootout/Parallel/SpectralNorm - HaskellWiki
13:37:09 <dons> once the shootout accepts the first one, i'll update it with whatever is fastest at that point.
13:37:29 <dons> newsham: ping me when its on the wiki and ready to test.
13:37:34 <jeffz> tsar: if display0 is correct, it should work fine.
13:40:34 <tsar> http://hpaste.org/10564
13:40:40 <tsar> ^^ whole program
13:40:45 <ddarius> Well, I guess the real problem with my approach is that, modulo fusion, it will always produce a list of length (number of children) and then iterate over that whereas that is only the worst-case for the other code.
13:41:37 <Phyx-> Hi, evening everyone, i have a small question, i'm looking for a way to draw a 2d chess board in haskell, i thought of using GLUT, but the tutorial i found is unfortunately dated i think.. the call "displayCallback $= clear [ ColorBuffer ]" doesn't get accepted by the compiler
13:41:50 <Phyx-> anyone know of another tutorial i could use, or another lib?
13:42:18 <dmwit> Phyx-: What's the error?
13:42:51 <dmwit> ?hpaset
13:42:51 <lambdabot> Unknown command, try @list
13:42:54 <dmwit> ?hpaste
13:42:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:42:59 <tsar> phyx: it works for me on windows
13:43:08 <tsar> see http://hpaste.org/10564
13:44:34 <dons> Phyx-: just gtk2hs perhaps?
13:44:43 <dons> its been used for other 2d games
13:44:54 <dons> e.g. http://xiangqiboard.blogspot.com/
13:44:55 <lambdabot> Title: Xiangqiboard
13:45:29 <jeffz> http://www.haskell.org/haskellwiki/OpenGLTutorial1 http://www.haskell.org/haskellwiki/OpenGLTutorial2 very much work.
13:45:30 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
13:45:55 <dons> xiangqiboard: ./src/xiangqiboard.hs ghc --make ./src/xiangqiboard.hs
13:45:56 <dons> urgh :(
13:46:09 <dons> oh, its only one module. wow.
13:46:26 <dons> $ ghc -O2 --make xiangqiboard.hs
13:46:26 <dons> [1 of 1] Compiling Main             ( xiangqiboard.hs, xiangqiboard.o )
13:46:26 <dons> Linking xiangqiboard ...
13:46:27 <dons> nice.
13:46:50 <b_jonas> dons: isn't --make needed so it links some extra library to it automatically?
13:46:56 <jeffz> Phyx-: the examples including the glut haskell package also work.
13:48:55 <dons> b_jonas: yup
13:50:11 <b_jonas> by the way, do you suppose the module system of r6rs scheme is similar to that of haskell?
13:55:23 <dons> newsham: getting there,
13:55:24 <dons> $ time ./A 6400 +RTS -N4 > /dev/null
13:55:24 <dons> ./A 6400 +RTS -N4 > /dev/null  11.15s user 0.03s system 191% cpu 5.841 total
13:55:32 <dons> old entry,
13:55:33 <dons> H$ time ./Old 6400 > /dev/null
13:55:33 <dons> ./Old 6400 > /dev/null  6.99s user 0.01s system 99% cpu 7.015 total
13:55:47 <dons> oh,
13:55:48 <dons> $ time ./A 6400 +RTS -N5 > /dev/null
13:55:48 <dons> ./A 6400 +RTS -N5 > /dev/null  7.30s user 0.12s system 302% cpu 2.452 total
13:55:49 <dons> :)
13:55:53 <dons> hide that latency
13:56:04 <dons> $ time ./A 6400 +RTS -N6 > /dev/null
13:56:04 <dons> ./A 6400 +RTS -N6 > /dev/null  6.89s user 0.03s system 346% cpu 1.995 total
13:56:04 <dons> hehe
13:57:06 <MellowYellow> hey guys I just wanted to start learning haskell and started with this tutorial http://lisperati.com/haskell/ht1.html but I am getting an error that the Text.Regex module is missing. Any idea where I go from here? I figured it would be a basic module that would come with ghc, and I have no idea how to install/get other modules
13:57:49 <hackage> Uploaded to hackage: only 0.0.6.0
13:58:10 <Nafai> MellowYellow: What OS/distribution are you on?
13:58:19 <MellowYellow> ubuntu hardy 8.04
13:58:20 <b_jonas> MellowYellow: and which haskell compiler (ghc or other)?
13:58:25 <MellowYellow> ghc
13:58:56 <Saizan> did you isntall your ghc through apt-get or manually?
13:59:02 <MellowYellow> apt-get
13:59:17 <b_jonas> strange, one would think a beginner tutorial would explain you how to install stuff you need to follow it :-)
13:59:51 <MellowYellow> :) the instructions were simply to install ghc. Which supposedly would contain this module as it is a default library
14:00:33 <ushdf> >even 5
14:00:38 <ushdf> > even 5
14:00:39 <lambdabot>   False
14:00:41 <ushdf> > even 5
14:00:43 <lambdabot>   False
14:00:50 * ushdf burns lambdabot with a cigarette
14:00:51 <ushdf> > even 5
14:00:53 <lambdabot>   False
14:00:58 <Saizan> MellowYellow: then you can install libghc6-regex-compat-dev
14:01:02 * ushdf rips out his eye
14:01:03 <ushdf> > even 5
14:01:04 <lambdabot>   False
14:01:08 <ushdf> machine learning my ass
14:01:12 <newsham> dons: hmm.. you're seeing almost no speedup on mand?
14:01:23 <Saizan> MellowYellow: many other libraries are available as libghc6-$pkgname-dev
14:01:31 <Nafai> MellowYellow: sudo apt-get install libghc6-regex-base-dev libghc6-regex-compat-dev  libghc6-regex-posix-dev
14:01:41 <Saizan> MellowYellow: there's also hackage.haskell.org for source distributions
14:01:51 <Phyx-> tsar, dons oops, sorry, irssi was minimized, the error is "parse error on input `displayCallback'"
14:02:04 <dons> newsham: i'm seeing excellent speedup :)
14:02:08 <b_jonas> MellowYellow: well, I have seen packages in linux distros that contained less stuff than the vanilla package of that software :-)
14:02:09 <dons> 7s to 1.9s
14:02:23 <newsham> oh, the last "total" time == wall clock?
14:02:23 <dons> roughly 370% cpu
14:02:25 <b_jonas> but I've no idea if ghc is distributed with that module you need
14:02:30 <Phyx-> jeffz: yeah, i'm using that to try it out
14:02:34 <dons> total is wall clock
14:02:37 <dons> not total cpu time.
14:02:40 <Phyx-> just copy pasting it and it gives the error
14:02:52 <dons> we still use the same cpu time. just takes 1.9s wall clock
14:02:54 <dons> submitting...
14:02:55 <Phyx-> removing it a window briefly comes up, but then it complains about having no callback
14:03:03 <newsham> got it, i was looking at the "user" time and being confused
14:03:23 <ushdf> 2+2=5 is more endearing than 2+2=4
14:03:26 <MellowYellow> well that seems to have fixed the error, and it is goog to know where to look for additional modules now just apt-cache search libghc6 | grep <module name>
14:03:31 <ushdf> moreso 2*2=5
14:03:50 <MellowYellow> thanks a bunch
14:03:50 <ushdf> the love of irrationality is the essence of our humanity, to deny ourselves any realm of thought outside of what is reasonable is to rob ourselves of pleasure
14:04:05 <MellowYellow> so glad that there was a nice IRC channel to drop into and ask
14:04:30 <Nafai> MellowYellow: Yeah, #haskell is one of the best IRC channels I frequest
14:04:35 <Nafai> frequent, even
14:04:48 <Phyx-> dons: could it be the GLUT dll that i'm using?
14:04:54 * Nafai wonders if frequest means "frequently conquest" :)
14:05:00 <lament> i liked the "it is goog to know"
14:05:01 <Phyx-> tsar: which glut are you using on windows?
14:05:15 <dons> newsham: http://alioth.debian.org/tracker/index.php?func=detail&aid=311119&group_id=30402&atid=411646
14:05:17 <ushdf> would it be accurate to describe C# as bloatware?
14:05:17 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311119 GHC Haskell: paral ..., http://tinyurl.com/4dnnxz
14:05:18 <dons> submitted.
14:05:22 <dons> should be added in the next few days
14:05:42 <Phyx-> ushdf: no, it would be a very inaccurate description
14:06:04 <ushdf> how so?
14:06:10 <newsham> cool
14:06:43 <jeffz> Phyx-: a parse error is not related to a dll, dll is a runtime dependency, parsing your program is compile time
14:06:47 <Phyx-> because there's nothing bloat about it? from design to implementation it's a pretty nice language
14:07:16 <ushdf> then all these benchmarks are lying to me ;)
14:07:29 <Phyx-> jeffz: yeah ok, but i can't explain the parse error, i just literally type in what's in the hello world examples
14:07:40 <Phyx-> and use the needed -package
14:07:41 <smtms> ushdf, how do you benchmark bloat?
14:07:52 <ushdf> with as many other benchmarks as possible
14:07:56 <Nafai> With gtk2hs can I get mainQuit to return an exit code?
14:08:05 <Phyx-> your benchmark would depend on how competend you are with a language
14:08:11 <jeffz> Phyx-: maybe something is missing or you have a formatting error
14:08:11 <lament> i think by "bloat" he means it's slow
14:08:22 <ushdf> if in the process of abstracting algorithmic processes, you measure the efficiency of any given algorithm that's abstracted into a function
14:08:27 <lament> ushdf: that's not how the word "bloated" is usually interpreted
14:08:29 <ushdf> however difficult that may be
14:08:34 <tsar> phyx: i dont know, just hwat came with the latest haskell. 6.8.3, or maybe that s not the latest haskell btw
14:08:39 <newsham> dons: how long does it take for new submissions to show up?
14:08:40 <ushdf> i realize, i see programming languages as programs of their own, in a twisted sense
14:09:38 <ushdf> computers are just big mazes of rabbit holes...each successive level of abstraction is only successful when it's highly efficient, otherwise it must be undercut in order to have a truly efficient implementation of a piece of software
14:09:48 <ushdf> > 1/1/1/1/10
14:09:49 <lambdabot>   0.1
14:09:59 <ushdf> see?
14:10:04 <ushdf> > 1/10
14:10:06 <lambdabot>   0.1
14:10:22 <ushdf> terrible example
14:10:31 <roconnor> > iterate (1/) 10
14:10:33 <lambdabot>   [10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10...
14:10:33 <Phyx-> yes, as you're proving absolutely nothing...
14:10:50 <ushdf> i'm not trying to prove anything, there's obviously quite an element of subjectivity to this
14:11:08 <ushdf> just speaking from experience, i've consistently seen C# perform more slowly on benchmarks
14:11:35 <matthew-_> > (iterate (1/) 10) :: [Float]
14:11:37 <lambdabot>   [10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10.0,0.1,10...
14:11:50 <matthew-_> I thought 0.1 was irrational in IEEE floating point
14:12:38 <roconnor> it is
14:13:10 <matthew-_> > 10 == (1 / (1 / 10))
14:13:12 <lambdabot>   True
14:13:25 <matthew-_> > (10::Float) == (1 / (1 / 10))
14:13:26 <lambdabot>   True
14:13:36 <matthew-_> ok, in which case, I don't understand that
14:13:39 <roconnor> rounding
14:13:47 <matthew-_> ahh
14:14:05 <matthew-_> > (1000::Float) == (0.01 / (1 / 10))
14:14:06 <lambdabot>   False
14:14:34 <matthew-_> > (1000::Rational) == (0.01 / (1 / 10))
14:14:36 <lambdabot>   False
14:14:39 <matthew-_> oops
14:15:11 <matthew-_> epic failure in my ability to do maths
14:16:35 <Phyx->  > (1000::Rational) == (100 / (1 / 10))
14:16:45 <Phyx-> > (1000::Rational) == (100 / (1 / 10))
14:16:47 <lambdabot>   True
14:17:02 <kushal> Hi all
14:17:04 <ushdf> haskell occupies the same space in my mind as perl...i understand the fundamentals, i understand the semantics, i understand a handful of functions, but damn am i terrified of writing a program in it
14:17:14 <kushal> I just started learning Haskell
14:17:14 <ushdf> it's like black magic
14:17:23 <b_jonas> ushdf: yep, it has some learning curve
14:17:28 <newsham> its a lighter colored magic
14:17:34 <b_jonas> ushdf: not as bad as some other languages
14:17:44 <lament> it could be worse!!
14:17:48 <dons> ushdf: you understand the semantics of perl?
14:17:49 <ushdf> such as?
14:17:55 <b_jonas> it's not white magic, is it? I hate white magic
14:18:02 <kushal> Which book should I buy as a newbie ?
14:18:03 <ushdf> for the most part, dons
14:18:22 <b_jonas> let's say it's some colored magic, like green or blue or something
14:18:24 <ushdf> i'm at the point in perl where i can fix bugs in other people's code
14:18:29 <vixey> It's all magic
14:18:35 <vixey> Wizardry
14:18:40 <vixey> and witches
14:18:45 <matthew-_> perl has semantics?
14:18:47 <ushdf> yes
14:18:47 <Baughn> kushal: You can learn it perfectly well by reading online tutorials, but if you want a book.. hmm, the haskell school of expressions is nice
14:18:49 <lament> hot naked witches
14:18:55 <tsar> perl is just a bunch of hacks i thought
14:18:59 <kushal> Baughn, ok
14:19:00 <lament> kushal: real world haskell!
14:19:03 <Baughn> kushal: Lots more suggestions on the website
14:19:11 <kushal> Baughn, I am reading the links
14:19:13 <Baughn> lament: That one's not out yet. ^_^
14:19:14 <ushdf> computers are a bunch of hacks
14:19:21 <smtms> tsar, it's useful and that's what really important
14:19:22 <lament> tsar: a bunch of hacks glued together by patches!
14:19:22 <kushal> Baughn, thats why got confused
14:19:28 <matthew-_> hang on, I'll rephrase: "Perl has deterministic semantics?"
14:19:35 <lament> Baughn: the text is online!
14:19:43 <lament> and you can buy the book
14:19:47 <ushdf> define deterministic
14:19:48 <kushal> Baughn, about online tutorials ,
14:19:52 <lament> you just can't _get_ it yet :)
14:19:56 <vixey> Haskell has semantics?
14:19:56 <kushal> lament, link ?
14:20:03 <lament> kushal: google. real world haskell.
14:20:04 <smtms> ushdf, you can fix bugs in other people's Perl? you are a master ;-)
14:20:09 <kushal> lament,ok
14:20:15 <lament> kushal: it will be the only hit, because to everybody else, real world haskell is an oxymoron
14:20:26 <ushdf> well, one website in particular, an eight year old monolith of perl
14:20:31 <ushdf> i know it like the back of my hand
14:20:40 <Baughn> dmwit: The documentation is.. missing, but a lazy pairing heap has at least O(1) time for extracting the minimum element, right? (It's a heap)
14:20:45 <kushal> lament, got it :)
14:20:54 <smtms> matthew-_, Perl has a whole compiler/interpreter multiplied by the number of platforms it runs on as a description of its semantics ;-)
14:21:09 <dmwit> Baughn: At *least* O(1)?  I think that's safe to say. =P
14:21:10 <matthew-_> vixey: err, that's pretty interesting actually. I don't know of any paper that actually defines Haskell's semantics
14:21:16 <smtms> matthew-_, Perl 6 will be better in that regard
14:21:18 <vixey> matthew-: me neither :)
14:21:29 <dmwit> Baughn: (I don't know the answer to the question you meant to ask, though.)
14:21:32 <Baughn> dmwit: That sentence is right-associative
14:21:36 <matthew-_> smtms: yes, but the universe will have ended before it gets releasted
14:21:36 <b_jonas> wait, you're _that_ ushdf?
14:21:49 <dmwit> Baughn: ah, heh
14:21:49 <b_jonas> ushdf: if you can fix bugs in _that_ code, you're really a master of perl
14:21:50 <vixey> anyone played with linear types in ATS?
14:21:59 <humasect> > join [1,2,3]
14:22:01 <lambdabot>       No instance for (Num [a])
14:22:01 <lambdabot>        arising from the literal `1' at <inter...
14:22:01 <b_jonas> ushdf: for it's built in such a way that bugs be hard to fix
14:22:02 <smtms> matthew-_, Perl 7 is planned for around the second comming, so Perl 6 should be released earlier :-)
14:22:27 <dmwit> humasect: join :: [[a]] -> [a]... [1,2,3] doesn't match [[a]].
14:22:48 <humasect> dmwit: hm, is there a way to 'lift' into a list? (single element sometimes)
14:22:57 <dmwit> humasect: return
14:22:59 <dmwit> > return 3
14:23:01 <lambdabot>       No instance for (Show (m t))
14:23:01 <lambdabot>        arising from a use of `show' at <in...
14:23:04 <humasect> aha, right of course =) =)
14:23:07 <dmwit> > return 3 :: [Int]
14:23:09 <lambdabot>   [3]
14:23:14 <humasect> excellent thanks
14:23:20 <Baughn> humasect: Or ([])
14:23:25 <dmwit> (:[])
14:23:25 <humasect> oh?
14:23:30 <humasect> ah..
14:23:47 <b_jonas> Baughn: how so?
14:24:07 <Baughn> b_jonas: Eh?
14:24:08 <b_jonas> Baughn: do you mean (:[]) ?
14:24:13 <Baughn> Yes. Yes, I did.
14:24:14 <humasect> > liftM return $ (return 3 :: [Int])
14:24:15 <lambdabot>       No instance for (Show (m Int))
14:24:15 <lambdabot>        arising from a use of `show' at <...
14:24:16 <b_jonas> > (:[]) 5
14:24:18 <lambdabot>   [5]
14:24:28 <b_jonas> that looks like a smiley of some kind
14:24:39 <dmwit> > liftM return [3] :: [[Int]]
14:24:41 <lambdabot>   [[3]]
14:24:46 <dmwit> bit odd, though
14:24:51 <humasect> hehe ..
14:25:02 <tsar> can someone tell me: (Vertex3 (fx::GLfloat) fy 0) , what is each of the values here? and where can  i findthe documentation for it?
14:25:02 * vixey is wondering about it because there's this mysterious missing chapter in the manual
14:25:04 <dmwit> odd to use liftM instead of map, that is =)
14:25:25 <Baughn> tsar: It's a triple, plain and simple. Nothing to document.
14:25:28 <humasect> tsar: *.OpenGL.CoordTrans
14:25:34 <b_jonas> > [[x]|x<-[3]] -- is odder
14:25:35 <lambdabot>   [[3]]
14:25:41 <dmwit> tsar: Maybe take a look at the OpenGL book?
14:26:05 <dmwit> > [3 | even 3] -- not so odd, actually useful sometimes
14:26:07 <lambdabot>   []
14:26:10 <humasect> tsar: Vertex3 is constructor for x, y, z
14:26:30 <humasect> hm lifM return is definately the oddest.
14:26:48 <humasect> ..and just what i was looking for =)
14:27:06 <dmwit> Really?
14:27:12 <dmwit> What could the use case for that possibly be?
14:27:17 <humasect> yep, along with return by itself
14:27:26 <tsar> http://techguyinmidtown.com/2008/07/14/csv-parsing-haskell-versus-python/
14:27:26 <tsar> dmwit: which one?
14:27:28 <lambdabot> Title: CSV Parsing: Haskell versus Python Â« tech guy in midtown, http://tinyurl.com/6xrymq
14:27:32 <tsar> oh ok
14:27:39 <humasect> it fits in with something that is already a little hacked so it fits well
14:27:51 <tsar> so i could jsut replace ith with x y z
14:27:54 <Baughn> ..so, similar levels of hackishness? ^^;
14:28:07 <Baughn> tsar: (x,y,z), more like
14:28:14 <dons> int-e: want to try parallelising classic fannkuch?
14:28:27 <Baughn> tsar: Except that the opengl functions expect to get Vertex3s, not (a,b,c)s
14:28:29 <humasect> yep tsar . but hopengl is somewhat wrathful when it comes to be clean as well as typeful, so you may still need to (x::GLfloat)
14:28:36 <humasect> tsar: (the compiler will let you know.)
14:28:37 <dons> int-e http://shootout.alioth.debian.org/u64q/benchmark.php?test=fannkuch&lang=ghc&id=1
14:28:39 <lambdabot> Title: fannkuch Haskell GHC program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer L ..., http://tinyurl.com/54n3uw
14:28:42 <humasect> yep Baughn =)
14:28:43 <b_jonas> > {- of course, without messing with monads, we could also say -} map (:[]) [3]
14:28:44 <lambdabot>   [[3]]
14:29:02 <Baughn> humasect: Eh. Unlikely. If he /uses/ it, whatever function he passes it to will be specified to take a Vertex3 GLFloat or whatever.
14:29:03 <humasect> hm yep monad is definately involved
14:29:26 <humasect> Baughn: it can still leak all the way to literals which are untyped.
14:29:36 <humasect> *that are
14:29:44 <dmwit> humasect: I hope you're not doing something like (liftM return xs >>= foo).
14:29:53 <dmwit> If you are, you should just use (map foo xs).
14:30:01 <humasect> hehe, nope
14:30:06 <kushal> ok, in my small experiment, it can do great work
14:30:17 <humasect> but actually it is cleaning up , we will see shortly
14:30:55 <Baughn> dmwit: Thanks for the edison pointer, again; it let me cut off three lines of code, and probably an (lg n) factor of speed
14:31:32 <Baughn> (Though since I'm still really just aiming to beat mathematica, this is extreme overkill)
14:31:39 <kushal> I just tried 23462376427 ^ 2132323
14:32:08 <Baughn> kushal: It's still printing?
14:32:12 <fschwidom> hi, i need an advice how to change this simple testfunction
14:32:12 <fschwidom> https://svn.origo.ethz.ch/pl-test-suite/ghc6/TestEnv.hs so i gain the same functiality like this: /java/TestEnv.java or /python/TestEnv.py or /ruby/TestEnv.rb
14:32:15 <kushal> Baughn, yes
14:32:30 <kushal> going on for like 3 minutes :p
14:32:42 <kushal> and done :)
14:32:45 <ushdf> time to to use heavy psychedelics and pick up haskell
14:32:53 <ushdf> where's glguy, i want hpaste code
14:32:58 <b_jonas>  /msg evalj 23462376427x ^ 2132323
14:33:04 <humasect> ushdf+)
14:33:04 <b_jonas> though the result is truncated in that case
14:33:47 <b_jonas> hmm no, doesn't work
14:34:01 <b_jonas> both because of the missing bracket at the beginning and because it gives a timeout
14:34:11 <b_jonas> (a timeout before out of memory? strange)
14:36:53 <humasect> :t filter.concat
14:36:54 <lambdabot>     Couldn't match expected type `a -> Bool'
14:36:54 <lambdabot>            against inferred type `[a1]'
14:36:54 <lambdabot>     Probable cause: `concat' is applied to too many arguments
14:37:10 <humasect> :t (filter id).concat
14:37:11 <lambdabot> [[Bool]] -> [Bool]
14:37:24 <ushdf> has anybody written apache mod_haskell yet
14:37:31 <humasect> mod_cgi
14:37:34 <ushdf> meh
14:37:43 <Valodim> boo apache :P
14:37:51 <ushdf> <3 lighttpd
14:37:55 <Valodim> yessir
14:38:52 <newsham> dons: your submission uses -N6, but the code still has replicateM_ 4 . forkIO   (4 workers).  was that your intention?
14:39:46 <dons> newsham: hmm... that's interesting...
14:39:52 <dons> newsham: so that should be numCapabilities
14:39:55 <dons> in GHC.Conc
14:40:01 <dons> which is whatever   the value of N is
14:40:05 <newsham> ahh,  wasnt aware of that.  cool
14:40:06 <humasect> commas are bad style
14:40:30 <ushdf> internet is a revolution in language
14:40:55 <ushdf> languages will begin to merge
14:41:00 <humasect> isn't it only a language itself?
14:41:12 <ushdf> no
14:41:14 <ushdf> it's a network!
14:41:17 <humasect> the whole mess is one big language, for communicating nothing but more languageness.
14:41:17 <newsham> ushdf: bladerunner foresaw this.
14:41:24 <humasect> that is what communication is, ushdf
14:41:32 <ushdf> if you define language as protocol
14:41:40 <ushdf> and include physical manifestation in protocol
14:41:43 <humasect> there are many words for the same thing
14:41:46 <dons> newsham: strangely, forkIO 4, with -N6 is faster
14:41:59 <ushdf> that's true
14:42:04 <humasect> programming languages, networking languages, markup languages, social languages
14:42:16 <b_jonas> kitty pidgin
14:42:26 <humasect> yet all it does is change pixels on a screen =)
14:42:31 <ushdf> physics creates chemistry creates biology creates physiology and psychiatry creates political science
14:42:35 <newsham> i would think you wouldnt want more workers than there are cores, since they're so compute bound.
14:42:51 <humasect> ushdf: and it too goes in a circle, again and again, around and around =)
14:42:55 <newsham> not sure why -N5 or -N6 helps out
14:43:07 <ushdf> until the black holes come
14:43:15 <humasect> hehe^_^
14:43:26 <humasect> or we go to them, more appropriately=)
14:43:41 <dons> newsham: main thread + io manager thread + extra threads?
14:43:42 <ushdf> really neither are appropriate
14:43:44 <newsham> i guess -N5 lets the IO thread run concurrently with all 4 workers
14:43:55 <newsham> the program currently has 5 threads, 4 workers and the main io thread
14:43:56 <humasect> ^_^ such as the whole idea of it/them vs us
14:43:57 <ushdf> velocity is subjective
14:44:07 <newsham> unless there are some internal ghc threads
14:44:20 <humasect> all things tend to be subjective. even that is subjective... and that
14:44:54 <newsham> btw, I never free the pointer I get from mallocArray0.  I assume that's required?  not sure it would help pref much, but might if there's memory pressure
14:45:02 <ushdf> are physical constants subjective?
14:45:34 <ushdf> or is the knowledge of their consistency lacking in objectivity
14:45:44 <humasect> ushdf: the idea of something being constant sure is not constant =)
14:45:46 <SamB_XP> only if the laws of physics are broken
14:45:53 <newsham> do Foreign.Marshall.Array pointers get garbage collected?
14:46:04 <humasect> those laws have been changing since forever. just as physics is.
14:46:11 <ushdf> or if the laws of physics are inaccurate abstractions of more complex systems
14:46:23 <SamB_XP> ushdf: well, yeah, that's what I mean
14:46:33 <ushdf> only if*
14:49:27 <ushdf> there's a functional php extension, but both versions of the site (written in php) don't load
14:49:38 <ushdf> only parts of them
14:49:57 <humasect> f# is used to make web pages ~
14:50:05 <ushdf> it casts doubt on the quality of the extension
14:50:24 <ushdf> why wouldn't you have an e#
14:50:37 <ushdf> poor naming choice
14:50:50 * ushdf starts hemmorhaging and bleeds out on the floor
14:50:54 <humasect> is there a musical note, e# ?
14:51:01 <humasect> =)
14:51:18 <lament> yes.
14:51:27 <ushdf> it's f
14:51:36 <humasect> there we go
14:52:08 <lament> it's enharmonic to f, certainly :)
14:52:10 <ushdf> but it's a useless notation, people only do it to evade the constrictions of the scale, if f is already sharp
14:52:10 <humasect> its called f# because that is what it was named. it is just ocaml core with .net interface. but it makes web pages more fun than vb.net or c# certainly.
14:52:37 <humasect> that sounds like it may not have anything to do with your original task
14:52:43 <lament> ushdf: e# and f don't have to be the same note
14:53:22 <ushdf> are we going outside the tonic now
14:53:22 <humasect> we can wrap and synonym the notes as much as we want, the frequencies are still relative to each other in the patterns they exactly sound like they do.
14:53:59 <kushal> lament, that book is nice :)
14:54:09 <ushdf> e_6*(2^(1/12)) = f_6
14:54:09 <SamB_XP> humasect: you only know the 12th-root-of-2 based scale, don't you?
14:54:15 <ushdf> in Hz
14:54:19 <ushdf> or other frequency
14:54:26 <lament> ushdf: that's one possible tuning, yes.
14:54:29 <humasect> SamB_XP: there are infinite frequencies.
14:54:32 <ushdf> that's how it works in the tonic
14:54:43 <ushdf> no, that works with any base tuning
14:54:44 <lament> i don't think the word "tonic" means what you think it menas
14:54:54 <kushal> thank you all :)P
14:55:00 <kushal> good night
14:55:01 <ushdf> the 12-tone scale, tonic as shorthand
14:55:08 * humasect seems to be watching a very slow and ungraceful explosion of sorts.
14:55:16 <SamB_XP> ushdf: um, there are many other temperaments
14:55:22 <lament> humasect: you mean the universe? :)
14:55:25 <ushdf> of course
14:55:46 <humasect> any unskillful chain reaction would count perhaps
14:55:55 <lament> SamB_XP: in any temperament, given that you only have 12 notes per octave, of course e# == f
14:56:08 <SamB_XP> you guys aren't two up on music history, are you?
14:56:11 <SamB_XP> er.
14:56:14 <SamB_XP> s/two/too/
14:56:22 <humasect> are we supposed to be, like you are?
14:56:24 <lament> SamB_XP: read again what i just said...
14:56:32 * ushdf coughs
14:56:41 <SamB_XP> oh, wait, who said anything about 12 notes per octave?
14:56:55 <lament> hehe
14:56:57 <humasect> music *is* history. how can we capture it? to listen to it is to let it pass.
14:57:00 <ushdf> a lot of western music follows that pattern
14:57:09 <lament> SamB_XP: when people talk about "temperaments" they do usually mean 12 notes per octave
14:57:24 <ushdf> that's why i like the violin...lets you escape from it
14:57:34 <SamB_XP> lament: well, maybe they leave out a lot of the notes
14:57:36 <humasect> ushdf=)
14:58:03 <lament> SamB_XP: that's the point of having a tuning - leaving notes out :)
14:58:07 <lament> like e#
14:58:09 <ushdf> you have to play with harmonics on the piano in order to do anything resembling that
14:58:12 <SamB_XP> maybe they only include 5 sharps?
14:58:17 <SamB_XP> or five flats
14:58:48 <SamB_XP> or ... something
14:59:01 <SamB_XP> anyway, this whole 12th root business seems relatively modern
14:59:02 <lament> probably something, yeah
14:59:13 <ddarius> SamB_XP: It started with Bach.
14:59:27 <b_jonas> ushdf: are pianos tuned so precisely?
14:59:28 <SamB_XP> what did bach make?
14:59:37 <b_jonas> SamB_XP: spread pianos
14:59:37 <ddarius> @google The Well-tempered Klavier
14:59:40 <lambdabot> http://en.wikipedia.org/wiki/Well_Tempered_Clavier
14:59:40 <lambdabot> Title: Well-Tempered Clavier - Wikipedia, the free encyclopedia
14:59:43 <ushdf> they certainly are
14:59:53 <humasect> hehe, be well everyone =)
15:00:17 <lament> i thought SamB_XP was the expert on music history
15:00:23 <SamB_XP> not really
15:01:08 <SamB_XP> I just know enough to know that the logarithmic scale we are so familiar with is not the only way of doing things ...
15:01:23 <SamB_XP> and I've read that there are some drawbacks to it
15:02:11 <b_jonas> SamB_XP: there are drawbacks to any scale
15:02:22 <SamB_XP> I'm sure
15:02:33 <lament> SamB_XP: there're drawbacks to any restriction of something analogue to something discrete :)
15:02:44 <ushdf> i'd have sworn there was a granular synthesis program in the repos
15:02:58 <ushdf> if you have windows as well, get "granulab"
15:03:06 <ddarius> Down with the piano, up with the theremin.
15:03:21 <newsham> your ear prefers intervals that are harmonics.  ie: 3/4 (3rd harmonic, reduced two octaves),  5/8, 7/8, 9/16, ...
15:03:26 <SamB_XP> the trouble with theremin is that it's hard to play more than two notes
15:03:34 <newsham> well tempered just apromixates the omst common ones
15:03:41 <SamB_XP> newsham: yeah
15:04:04 <b_jonas> 7/8?
15:04:08 <SamB_XP> the pythagoreans would have murdered bach ;-P
15:04:11 <newsham> freq2 = freq1 * 7/8
15:04:22 <b_jonas> yeah, but 7/8 really?
15:04:24 <FunctorSalad> ushdf why are you dying? (just scrolled down)
15:04:40 <newsham> 7th harmonic, reduced 3 octaves (2*2*2)
15:04:41 <matthew-_> well, pythagorus did murder his own students
15:04:42 <b_jonas> I thought all the nice ones only had 2, 3, 5 as their prime factors
15:05:03 <SamB_XP> you know how much they hated radicals
15:05:55 <newsham> 7th harmonic is the major 3rd i believe.
15:05:59 <newsham> quite a pleasant sound
15:06:28 <lament> major third is 5:4
15:06:32 <newsham> hmm i might have gotten that wrong
15:06:32 <byorgey> 7th harmonic isn't a major 3rd.
15:06:32 <newsham> yah
15:07:03 <lament> i think 7th harmonic is exactly the weird one nobody wants
15:07:32 <byorgey> it's somewhere around a major 7th
15:07:41 <byorgey> but by that point the tuning systems are way off
15:08:26 <newsham> 7:4 is the maj 6th,  major 3rd down from the octave
15:09:19 <scodil> is the type of Streams, i.e., "data Stream a = forall s . Stream a (s -> Step s a) s" compatible with the ST monad? Is there a way to thread the s of ST s through there?
15:09:21 <lament> http://en.wikipedia.org/wiki/Harmonic_seventh
15:09:23 <lambdabot> Title: Harmonic seventh - Wikipedia, the free encyclopedia
15:09:46 <matthew-_> yes, but of course don't forget that brass instruments can only really form the odd harmonics
15:10:04 <matthew-_> and it's only the flare of the bell that creates the illusion of a real harmonic series
15:10:18 <SamB_XP> ?
15:10:28 <scodil> saxophones are brass :)
15:10:37 <matthew-_> saxaphones are the work of the devil
15:10:39 <newsham> blah, i got it wrong again.
15:10:44 <lament> saxophones are clearly wood :)
15:10:51 <matthew-_> and should never be considered in the same breath as "music"
15:10:53 <ushdf> saxophone was my second instrument
15:10:53 <Beelsebob> saxophones are woodwind
15:10:54 <scodil> the important parts anyway
15:11:11 <ushdf> listen to some free jazz, matthew
15:11:23 <matthew-_> I'd rather eat my nipples
15:11:30 <SamB_XP> matthew-_: that can be arranged
15:11:34 <ushdf> it's really incredible
15:11:37 <matthew-_> 0.o
15:11:47 <ushdf> i have been sitting here playing guitar while you all rambled on about music theory
15:11:57 <lament> loser
15:12:05 <lispy> haskell people
15:12:19 <ushdf> lispy
15:12:31 <newsham> http://www.phy.mtu.edu/~suits/badnote.html
15:12:32 <lambdabot> Title: Avoiding the 7th harmonic
15:12:41 <lispy> So, GADT type checking is completely decidable?
15:13:45 <matthew-_> also, of course don't forget that the well tempered piano and the modern ear does not use the normal harmonic series
15:13:55 <matthew-_> almost everything other than octaves is different
15:14:07 <ushdf> octave is a misnomer
15:14:27 <ushdf> it contains eight notes, strictly, but notes based on a subdivision of twelve
15:14:30 <newsham> matt: thats how this conversation kicked off
15:14:56 <b_jonas> ushdf: that's not why it's a misnomer
15:15:13 <b_jonas> ushdf: it's a misnomer because of the fencepost problem
15:15:23 <b_jonas> it contains seven notes if you count it in the same way
15:15:24 <lispy> I was wondering because the examples on Haskell-Cafe look tricky
15:15:26 <matthew-_> newsham: ahh, sorry. I'll be going to bed now ;)
15:15:26 <newsham> the 8th note is an identity, not the count of notes
15:15:37 <ushdf> that as well, and that there are usually two semitone steps between components
15:15:41 <lament> since you all are into music so much, would anyone know how much is a good mic?
15:15:55 <lispy> I guess, the type inference itself is easy, but then arriving at the type witness is slow at run-time not compile time?
15:16:07 <matthew-_> lament: to -blah
15:16:34 <ushdf> all my mics are stolen, lispy
15:16:36 <ushdf> lament
15:16:48 <ushdf> you can get decent quality for maybe 80 bucks
15:17:02 <ushdf> (ebay)
15:17:33 <ushdf> burn down the government@!!!
15:17:53 <scodil> wait, are you lamenting that you stole your mics, or that they were stole from you? Because if its the latter than directing him to ebay to buy mics is kind of ironic
15:18:04 <scodil> were stolen from you
15:18:20 <lispy> What part of this is haskell related?
15:18:26 <ushdf> i'm not lamenting, i'm talking to lament
15:18:33 <scodil> oh
15:18:33 <scodil> hah
15:18:37 <ushdf> it's a spiritual difference
15:25:06 <shrughes> > ([1,4,9]...)
15:25:08 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
15:25:36 <shrughes> > let (...)  [] = [0,0..]; (...) xs@(x:_) = scanl (+) x (join (zipWith (-) . tail) xs ...) in ([0,1,4]...)
15:25:37 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
15:26:06 <lispy> shrughes: interesting that first one works.
15:26:19 <lispy> > [1,4,9,...]
15:26:20 <lambdabot>   mueval: Prelude.read: no parse
15:26:24 <lispy> > [1,4,9,..]
15:26:25 <lambdabot>   mueval: Prelude.read: no parse
15:26:31 <lispy> er
15:26:37 <shrughes> > (...) [1,4,9]
15:26:38 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
15:26:39 <lispy> I guess it's been too long since I usde that syntax
15:26:46 <lispy> oh, (...) is defined in L
15:26:49 <shrughes> yah
15:26:52 <lispy> :t L.(...)
15:26:53 <lambdabot> Not in scope: data constructor `L'
15:27:05 <lispy> > [1,4,9..]
15:27:07 <lambdabot>   mueval: Prelude.read: no parse
15:27:08 <shrughes> [Integer] -> [Integer]
15:27:12 <shrughes> probably
15:27:19 <shrughes> er, or not.
15:27:34 <shrughes> > ([0, -0.25, 0]...)
15:27:35 <lambdabot>   [0.0,-0.25,0.0,0.75,2.0,3.75,6.0,8.75,12.0,15.75,20.0,24.75,30.0,35.75,42.0...
15:27:57 <olsner> hmm, IOUArray seems something like 10% slower than STUArray
15:28:34 <lispy> > [1,4..]
15:28:36 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
15:28:45 <lispy> that is allow, but not [1,4,9..[
15:28:52 <lispy> (with the right bracket)
15:29:17 <lispy> olsner: that seems odd
15:29:20 <Twey> :t (...)
15:29:21 <lambdabot> forall a. (Num a) => [a] -> [a]
15:29:27 <Twey> That's a function?  Haha.
15:29:39 <lispy> Twey: not a function in Haskell
15:29:43 <lispy> Twey: but, in lambdabot yeah
15:29:46 <Twey> Aha
15:29:48 <Twey> What does it do?
15:29:51 <Beelsebob> @src (...)
15:29:52 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:29:53 <shrughes> what do you mean 'in haskell'
15:29:55 <b_jonas> that's what I was about to ask too
15:30:01 <lispy> shrughes: in the standard libs
15:30:09 <shrughes> okay
15:30:12 <lispy> it's defineable in haskell obviously
15:30:21 <b_jonas> > (...)5
15:30:22 <lambdabot>       No instance for (Num [a])
15:30:22 <lambdabot>        arising from the literal `5' at <inter...
15:30:24 <b_jonas> > (...)[5]
15:30:25 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
15:30:28 <b_jonas> > (...)[5,2]
15:30:30 <lambdabot>   [5,2,-1,-4,-7,-10,-13,-16,-19,-22,-25,-28,-31,-34,-37,-40,-43,-46,-49,-52,-...
15:30:42 <b_jonas> > (...)[0,1,4]
15:30:44 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
15:30:58 <b_jonas> > (...)[1,2,4,8,16]
15:30:59 <lambdabot>   [1,2,4,8,16,31,57,99,163,256,386,562,794,1093,1471,1941,2517,3214,4048,5036...
15:31:05 <b_jonas> polynomial then
15:31:33 <Beelsebob> > (...)[0,1,8,27]
15:31:34 <lambdabot>   [0,1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,58...
15:31:43 <Beelsebob> that's nice
15:31:53 <dibblego> > (...)[1,2,4,8,16]
15:31:54 <dibblego> [1,2,4,8,16,31,
15:31:55 <lambdabot>   [1,2,4,8,16,31,57,99,163,256,386,562,794,1093,1471,1941,2517,3214,4048,5036...
15:31:55 <dibblego> ?
15:32:05 <shrughes> a 4th degree polynomial
15:32:22 <Beelsebob> I think it generates an n-1 degree polynomial when you give it a list of length n
15:34:54 <byorgey> > (...)[1,1,2,3,5,8]
15:34:55 <lambdabot>   [1,1,2,3,5,8,8,-6,-55,-173,-410,-835,-1539,-2638,-4276,-6628,-9903,-14347,-...
15:35:12 <byorgey> > ([1,2,3,4]...)
15:35:13 <lispy> have you guys ever heard of this haskell app:http://en.wikipedia.org/wiki/LOLITA
15:35:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:35:14 <lambdabot> Title: LOLITA - Wikipedia, the free encyclopedia
15:35:45 <byorgey> lispy: it's mentioned in the paper on parallel strategies, but I hadn't heard of it other than that
15:36:14 <lispy> This is the first time I've heard of it, and yet the article makes it sound rather significant
15:36:17 <lispy> and impressive
15:37:12 <byorgey> well, I think it was.
15:37:18 <byorgey> maybe still is?  I've no idea.
15:37:52 <lispy> hah
15:37:53 <lispy> #   Language:  Haskell 1.2
15:37:53 <lispy> # Compilers: hbc 0.999.6, ghc 0.22
15:37:59 <lispy> ghc 0.22??
15:38:05 <lispy> http://homepages.inf.ed.ac.uk/wadler/realworld/natlangproc.html
15:38:09 <byorgey> hehe, nice
15:38:57 <lispy> sadly, I can't actually find lolita
15:39:25 <Saizan> 50k lines of haskell? that's like 100 window managers
15:39:57 <lispy> ?remember Saizan [on LOLITA] 50k lines of haskell? that's like 100 window managers
15:39:58 <RayNbow> lispy: well, it's hard to find something if there are also other things called lolita
15:39:58 <lambdabot> Okay.
15:41:59 <lispy> 04:46:00<shapr>iirc, the LOLITA source was closed & proprietary.
15:42:09 <lispy> http://tuukka.iki.fi/tmp/haskell-2008-02-11.html
15:42:10 <lambdabot> Title: haskell-2008-02-11
15:42:25 <lispy> It seems others have gone down this road
15:49:33 <tsar> is there any point in me blogging about my experience with haskell? i like writing and i like haskell but i have some difficulties getting used to parts of it. i mostly do my real stuff in python but i write a lot of smaller fun programs in haskell. could be fit for blogarticles since the programs usually are only 30-100 lines.
15:49:49 <tsar> you think there is any interest for usch a blog?
15:50:05 <dibblego> yes, then others can help you improve
15:50:33 <jeffwheeler> If I install a package (in this case, HOC) with --global using cabal, can user packages depend on them? Or, do I need to reinstall the global packages as user packages?
15:51:19 <ushdf> 50k lines of anything is too big
15:51:57 <ushdf> that's not at all true
15:52:08 * ushdf wanders off
15:52:44 <dmwit> jeffwheeler: User packages may depend on global packages.
15:53:14 <olsner> nice, one inline pragma reduced my running time from 17s to 0.7s :D
15:53:31 <jeffwheeler> dmwit: okay, thanks
15:53:53 <jeffwheeler> In that case, is there any special meaning to packages surrounded by braces in ghc-pkg list?
15:54:35 <adu> the funk in function...
15:54:37 <dmwit> jeffwheeler: Yes, I was told earlier today it means that the package is missing some dependencies.
15:54:56 <dmwit> jeffwheeler: Note that some libraries depend on certain *versions* of other libraries.
15:54:59 <adu> dmwit: so did you try 'only'?
15:55:11 <jeffwheeler> dmwit: hmm, okay; I'll play with it a bit more, based on that
15:55:43 <dmwit> adu: Not much.  I haven't needed grep recently. =)
15:55:48 <jeffwheeler> HOC really needs to improve the installation process; I've gone through it a few times, and it always makes me pull my hair out.
15:57:45 <unenough> Zope
16:00:19 <adu> unenough: what about Zope?
16:00:34 <unenough> Nope.
16:00:47 <adu> jeffwheeler: I've built hoc a few times, I even tried cabal-izing it a few times
16:01:03 <unenough> i was typing /join #Zope but the stupid XChat put me in here while i was typing.
16:01:06 <adu> jeffwheeler: if you want I can send you a couple of my attempts
16:01:19 <unenough> while we're at it, zope sucks.
16:01:55 <unenough> EOF
16:02:49 <vixey> hi adu
16:02:49 <dmwit> unexpected character EOF: expecting '>' or "witticism"
16:02:56 <adu> vixey!
16:02:58 <tsar> http://hpaste.org/10567, anyone can give me a pointer about what to do with vector there to get what i want? i want a function that takes coordinates as input and returns "an object" that the funciton can draw. im gonna randomzie soem lines and i dotn want to write down each line by myself...
16:02:58 <jeffwheeler> adu: it's somewhat already cabal-ized; I can already "cabal install" parts of it, and then after ifgen'ing it, I can cabal-install the rest; it succeeds some of the time (like right now), but then I always have some problem between that point and getting an app running with it
16:03:00 <vixey> did you make much progress with your language?
16:04:04 <adu> jeffwheeler: I also made extensive modifications to "ifgen" so much so that I feel incredibly stupid for not submitting a patch
16:04:27 <jeffwheeler> hmm
16:06:16 <adu> jeffwheeler: like adding options for other bind-scripts, options for frameworks other than Foundation/AppKit, etc
16:06:44 <adu> and i renamed it hocgen :)
16:06:57 <jeffwheeler> Why not submit the patches, then?
16:07:05 <adu> jeffwheeler: ok
16:09:05 <povman> tsar: can you clarify?
16:09:19 <povman> tsar: are you talking about the vector function?
16:10:35 <povman> tsar: i'd store a vector as x and y, not polar. Also technically a 'vector' doesn't include a start point
16:12:02 <adu> jeffwheeler: one reason is that I have never heard back from the lead developer...
16:12:21 <adu> jeffwheeler: http://tetration.itgo.com/hs/hoc-ajr-maximal.tar.gz
16:13:02 <jeffwheeler> adu: well, fortunately I just got their version to compile correctly and finally got it running with Yi
16:13:22 <adu> nice
16:13:27 <jeffwheeler> adu: although I appreciate the package; I'll try it next time Yi breaks (by requiring old dependencies)
16:13:40 <adu> jeffwheeler: another reason is I can't decide which version I should send, since I have like 10 source trees for hoc
16:15:20 <adu> jeffwheeler: and some of the source trees are just moving things around, like "mv Tools/ hocwrap/" to see what would break :)
16:16:04 <adu> i personally think "InterfaceGenerator" is a terrible directory name
16:16:43 <adu> vixey: o my typechecker?
16:16:51 <adu> vixey: still stuck on "forall"
16:17:49 <adu> vixey: but I'm constantly adding new syntax, I can't wait to finish the parser...
16:23:44 * dancor never got latest reactive working needing ghc 6.9, but he did just realize near-latest is in cabal-install for ghc 6.8  :D
16:25:45 <thetallguy> dancor: really?  There was a dependency that I thought really needed 6.9
16:27:02 <dancor> reactive-0.5 compiled from cabal-install
16:27:02 * Heffalump waves from ICFP
16:27:20 * roconnor waves back
16:27:57 <Heffalump> I'm more sort of above it than at it right now
16:28:54 <SamB_XP> Heffalump: you're flying in?
16:28:58 <SamB_XP> or you're on the roof ?
16:29:20 <adu> roof?
16:29:25 <ushdf> this room got really trippy all of a sudden
16:29:43 <roconnor> Heffalump is high
16:29:49 * SamB_XP offers ADD to everyone
16:30:02 <Heffalump> SamB_XP: I'm in my room in the conference hotel
16:30:18 <adu> oic heh
16:30:26 <olsner> SamB: ADD as in attention-deficit disorder?
16:30:36 <SamB_XP> olsner: what else? an ADD instruction?
16:30:50 <olsner> hmm, dunno
16:31:13 <olsner> but it seems weird to offer disorders to other people... who'd accept freely?
16:31:17 * SamB_XP stares at the "black" Google Chrome installer on his desktop
16:31:36 <SamB_XP> olsner: well, actually I thought everyone already had it...
16:31:54 <SamB_XP> ... here
16:32:20 <olsner> well, who'd want *another* instance of ADD? :P
16:32:37 <SamB_XP> point
16:38:05 <SamB_XP> anyway, is it REALLY a disorder or is it just the next step ?
16:39:25 <qwr> what? ;)
16:40:00 <SamB_XP> qwr: what what?
16:40:50 <qwr> SamB_XP: what were you talking about? :P
16:41:11 <SamB_XP> qwr: are you lacking scrollback???
16:41:42 <qwr> which remainds... i have ADD with paying bills...
16:42:12 <qwr> SamB_XP: or trying to do poor jokes about ADD.
16:44:56 <halberd> most programming competitions involve individual problems that must be solved from scratch, without the element of maintaining code written by someone else
16:45:07 <x6d65> Can someone explain to me why GHC complains about a kind error for...
16:45:16 <x6d65> http://hpaste.org/10569
16:45:17 <tsar> povman yeah i know i was gonna do a vectorspace but then decided to draw some lines. lets call them arrows instead
16:45:41 <halberd> and a paragraph on the back of each one explaining what each one was?
16:45:46 <tsar> but i want to do something like generate 10 random arrows and draw them instead of doing for each color vertex vertex
16:46:08 <shrughes> x6d65: does "a -> [] -> []" make sense?
16:46:29 <bd_> shrughes: flip const?
16:46:43 <shrughes> bd_: [] is not a type
16:46:47 <bd_> oh, point
16:46:57 <SamB_XP> and THAT is the kind error ;-P
16:47:02 <shrughes> x6d65: I think you want push :: a -> stack a -> stack a
16:47:18 <povman> tsar: does your vector function work?
16:47:38 <olsner> hmm, with forM_ [x..y] I seem to always go through a lazily generated lists rather than an iteration (if I read the core correctly), but with my manual iteration iterateM_ x y I'm instead always getting the block of code sent as a closure rather than inlined
16:48:11 <povman> tsar: vector needs a 'do' for starters
16:48:59 <FunctorSalad> is it possible to make "cabal install" install the haddock as well?
16:49:13 <x6d65> shrughes: Ah, I see. Thanks.
16:49:31 <olsner> FunctorSalad: isn't it installed automatically if you've run 'cabal haddock' before installing?
16:49:45 <tsar> data Unpacker = forall a. Eq a => AnyUnpacker (LispVal -> ThrowsError a)
16:49:52 <tsar> Not a data constructor: `forall'
16:49:52 <tsar>     Perhaps you intended to use -XExistentialQuantification
16:50:04 <tsar> povman: no
16:50:13 <FunctorSalad> olsner: yeah, I meant "cabal install bazbar" where it does everything automatically
16:50:23 <FunctorSalad> olsner: that doesn't seem to have an haddock option
16:50:28 <FunctorSalad> *a
16:50:40 <olsner> oh, I see what you mean
16:51:04 <olsner> I don't think it has such an option, no
16:51:38 <povman> tsar: http://hpaste.org/10567#a1
16:52:11 <povman> then you should be able to do a loop in the display function, generating and drawing vectors
16:53:07 <povman> i'm off, cu
16:53:58 <andyjgill> Greetings from ICFP!
16:54:12 <dons> hey andyjgill !
16:54:29 <dons> andyjgill: galois' arriving late tomorrow, btw.
16:54:42 <andyjgill> In person?
16:54:54 <dons> in person. zombie-style.
16:55:06 <dons> it's going to be awesome :)
16:55:16 <andyjgill> its a nice hotel here.
16:55:36 <halberd> it would be interesting to have a competition in three parts, with 3 person teams, working on a 3-part problem--each person picks up where the previous person left off to solve the next part of the problem
16:55:41 <dons> http://www.galois.com/blog/2008/09/19/galois-icfp-see-you-there/ btw
16:55:41 <tsar> ty
16:55:42 <lambdabot> Title: Galois âº Blog âº Blog Â» Galois @ ICFP: See you there!
16:55:48 <halberd> that would encourage code maintainability
16:55:49 <dons> i'm going to try to blog the whole icfp week. :) with photos.
16:57:42 <andyjgill> Cool. I'll point the KU students to it.
16:58:04 <andyjgill> I see that John Harrison's talk in also there. Thanks.
16:59:10 <chr1s> more greetings from Victoria =)
16:59:35 <dons> andyjgill: yeah, harrison gave a great talk.
16:59:44 <dons> i set up #haskell-icfp btw.
16:59:59 <dons> but usually #haskell goes quiet during icfp, and we just use this channel to coordinate.
17:00:13 <andyjgill> Just joined!
17:00:16 <chr1s> dons: maybe put it in the topic.
17:00:21 <dons> good thinking
17:00:31 <brenden> i'm going to now ask a question which probably gets asked every 30 seconds
17:00:43 <chr1s> brenden: shoot.
17:00:45 <brenden> what should i read to start with haskell
17:01:00 <brenden> fyi: i am pretty experienced at coding C/C++ and various scripting langs
17:01:01 --- mode: ChanServ set +o dons
17:01:07 --- topic: set to '["#haskell @ ICFP: #haskell-icfp", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org ","Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
17:01:08 <brenden> so not new to programming
17:01:10 --- mode: ChanServ set -o dons
17:01:25 <dons> brenden: i'd say, "real world haskell" if you're an experienced programmer
17:01:28 <dons> ?go real world haskell
17:01:28 <chr1s> brenden: http://book.realworldhaskell.org/read/
17:01:37 <brenden> oman
17:01:40 <lambdabot> Title: Real World Haskell
17:01:41 <brenden> thanks bros
17:01:41 <lambdabot> http://www.realworldhaskell.org/
17:01:41 <lambdabot> Title: Real World Haskell
17:03:11 <x6d65> shrughes: http://hpaste.org/10569#a1
17:06:34 <fschwidom> i wish i could make classes in ghc6
17:06:50 <fschwidom> this would solve my problem
17:07:04 <shrughes> classes?
17:07:14 <fschwidom> show the hpaste post
17:09:27 <Baughn> fschwidom: What feature of classes are you missing?
17:11:16 <FunctorSalad> fschwidom I guess you don't mean what haskell calls classes?
17:11:34 <fschwidom> the fixed first parameter ans the possibility to have a data capsule
17:11:42 <fschwidom> s/ans/and
17:11:58 <Twey> fschwidom: 'Fixed'?
17:12:24 <FunctorSalad> in class methods the parameters can appear in any order
17:12:26 <Twey> The latter is solved by creating your own types
17:12:34 <dcoutts> bye folks! see (some of) you at ICFP! :-)
17:12:40 <Twey> 'bye dcoutts :)
17:12:50 <chr1s> dcoutts: see you at ICFP!
17:12:51 <FunctorSalad> class FooablePair a b where foo_it :: b -> a -> String
17:13:11 <chr1s> have a good flight.
17:13:19 <FunctorSalad> bye
17:13:35 <dcoutts> chr1s: thanks, and see you there
17:14:12 <newsham> is there a "time" like program that will report separately for each cpu?
17:14:15 <fschwidom> Twey: you mean the class type?
17:14:26 <newsham> (what does quad core shootout use to measure that?)
17:14:29 <Twey> fschwidom: There is no 'class type'
17:14:50 <Twey> fschwidom: I mean a new type, defined with the 'data' keyword
17:14:56 <Twey> (or 'newtype' in some cases)
17:15:13 <Twey> fschwidom: The only thing that Java-style classes do is move the first parameter of the method to before the method call, and provide a namespace for methods of that class
17:15:14 <lispy> Why are multiparameter type classes not in H98?
17:15:18 <fschwidom> it's possible to create an class like type
17:15:19 <lispy> Is there some drawback to them?
17:15:20 <fschwidom> t?
17:16:12 <Baughn> fschwidom: What does that /mean/? What would you like to do with it?
17:16:23 <Twey> The former is unnecessary syntax sugar (but you can define something like `($$) = flip ($)` if you want) and the latter is provided by modules.
17:16:34 <fschwidom> i want to have a datacapsule
17:17:00 <fschwidom> i need an object which is able to add numbers sequentially
17:17:01 <Baughn> That's not standard nomenclature. Again, what does it mean?
17:17:21 <Twey> Objects don't *do* things, functions do
17:17:28 <Baughn> Or, maybe, what code would you like to write?
17:17:46 <Baughn> Twey: ..well, modulo laziness
17:17:48 <tsar> can i zip to tuples?
17:17:52 <Jedai> lispy: The inference becomes harder with them, especially if you want them useful and add fundep too
17:18:11 <dibblego> @type zip
17:18:13 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
17:18:15 <Baughn> tsar: That's what zip does, yes.. or did you mean something else?
17:18:23 <Twey> Mmhm
17:18:33 <fschwidom> i want to write a test-function - i want to output the result of subsequent test-calls
17:18:36 <tsar> i want zip [1..10] [11..20] but with tuples
17:18:49 <tsar> tuple-zip (1..10) (11..20)
17:18:50 <ziman> > zip [1..10] [11..20]
17:18:52 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,18),(9,19),(10,20)]
17:18:52 <dibblego> > zip [1..10] [11..20]
17:18:54 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,18),(9,19),(10,20)]
17:19:04 <newsham> what is (1..10) ?
17:19:07 <tsar> yes but outer should be tuple
17:19:09 <fschwidom> sory for my bad english
17:19:22 <shrughes> it's [1..10]
17:19:22 <Twey> fschwidom: So you actually want mutable state?
17:19:33 <dibblego> > ([1..10], [11..20]) -- like this?
17:19:34 <monochrom> objects are overrated.
17:19:34 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
17:19:36 <fschwidom> yes
17:19:41 <shrughes> newsham: special Haskell syntax, equivalent to enumFromTo 1 10
17:19:47 <Twey> The usual way of doing that in Haskell is to pass the last value explicitly
17:19:50 <newsham> > (1..10)
17:19:50 <dibblego> mutable state is overrated
17:19:51 <lambdabot>   mueval: Prelude.read: no parse
17:19:52 <Twey> Or, you can use a list
17:19:57 <Jedai> fschwidom: The Writer Monad should be enough
17:20:07 <lispy> Jedai: suppose we don't want fundep, how much harder are we talking? undecidabel?
17:20:14 <fschwidom> Twey: and do reuse this value?
17:20:21 <lispy> Jedai: or just more rules to program?
17:20:28 <FunctorSalad> fschwidom: if you want to accumulate some results, maybe Writer is for you
17:20:31 <fschwidom> s/do/to
17:20:33 <newsham> > uncurry zip ([1..10], [11..])
17:20:34 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,18),(9,19),(10,20)]
17:20:54 <FunctorSalad> fschwidom: or State if your function also wants to read that value
17:21:24 <Twey> fschwidom: The function is (+1) -- it adds one to a number
17:21:30 <Twey> > (+1) 2
17:21:32 <lambdabot>   3
17:21:36 <Twey> Then you can add to that again
17:21:37 <Twey> > (+1) 3
17:21:39 <lambdabot>   4
17:21:40 <qwr> fschwidom: better tell what you try to achieve
17:21:54 <qwr> fschwidom: for what this state
17:22:40 <qwr> trying to copy some OO design into haskell usually serves no good
17:22:42 <tsar> http://hpaste.org/10571, why cant i do that?
17:22:43 <fschwidom> i startet a little testproject here https://svn.origo.ethz.ch/pl-test-suite/ghc6/
17:23:09 <fschwidom> but i implemented already real test classe in another languages: ...
17:23:18 <fschwidom> https://svn.origo.ethz.ch/pl-test-suite/java/
17:23:25 <fschwidom> https://svn.origo.ethz.ch/pl-test-suite/clisp/
17:23:33 <fschwidom> https://svn.origo.ethz.ch/pl-test-suite/python/
17:23:39 <fschwidom> ...
17:23:46 <newsham> tsar: "non-exhaustive pattern"
17:24:06 <newsham> there's no definition of arrow when the args arent of the form [(fx,fy), (tx,ty)]
17:24:39 <FunctorSalad> tsar: your "arrow" function only accepts lists that contain exactly two tuples
17:24:41 <Baughn> @instances MonadWriter
17:24:42 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
17:25:03 <Twey> fschwidom: If this is intended to be a 'programming language test suite', then your tests are flawed
17:25:32 <Twey> Haskell Doesn't Work Like ThatÂ®
17:25:51 <qwr> fschwidom: use state monad, if you want those counters.
17:25:55 <Twey> (and the CLOS one isn't really equivalent, either)
17:26:12 <Twey> State can kind of do what you want, aye
17:26:20 <Twey> It's still not an OO-style class, though.
17:26:25 <fschwidom> then the only way to make haskell tests is to check the output per diff
17:26:47 <Twey> fschwidom: You can output several things sequentially
17:26:51 <lispy> What is wrong with a programming language test suite?
17:26:58 <tsar> newsham: but i define it with no arameters so i dont understand how to change that
17:27:00 <Twey> print "foo" >> print "bar" >> print "baz"
17:27:13 <fschwidom> thanks for help
17:27:15 <newsham> you defined it with a parameter that is a list
17:27:16 <tsar> ghci doesnt complain when compiling..
17:27:22 <newsham> an dthat list has to contain two elements which are tuples
17:27:32 <newsham> "arrow [(fx, fy), (tx, ty)] = do"
17:27:37 <newsham> [...]  is the argument to arrow
17:27:40 <x6d65> Does anyone have a guess for what the first Integer in the type "eval :: RPN -> (Integer, [Integer])" might refer to?
17:27:45 <Twey> lispy: Well, it seems to be testing OO capability, and is being applied to Haskell :)
17:28:14 <x6d65> Where RPN is a [Symbol], and Symbol is basically a number or an operator.
17:28:30 <shrughes> x6d65: it could be the top of the stack, and [Integer] could be the rest of the stack
17:28:59 <newsham> ?dice 6d65
17:28:59 <lambdabot> 6d65 => 109
17:29:57 <x6d65> ?dice 6d6
17:29:57 <lambdabot> 6d6 => 18
17:30:31 <Baughn> Hm. I'd utterly forgotten about writer.
17:30:38 <x6d65> shrughes: I guess I'll go with that.
17:30:50 <Baughn> Useful little monad, too. This should be handy for educational purposes
17:31:09 <x6d65> Seems like error-checking is going to be a headache.
17:31:25 <lispy> Twey: ah, well Haskell does support a lot of well known OO techniques.  Just look at all the things they did in OOHaskell paper.
17:31:27 <tsar> ?dice 6d64
17:31:27 <lambdabot> 6d64 => 172
17:31:59 <monochrom> lispy: A programming language test suite shows the political bias of its author.
17:32:49 <lispy> monochrom: so we could have McCain and Obama write PL test suites to figure out their affiliation?
17:32:49 <newsham> > runWriter (tell 3 >> return 5)
17:32:50 <lambdabot>   Add a type signature
17:33:07 <Baughn> > runWriter (tell "3" >> return 5)
17:33:09 <lambdabot>   (5,"3")
17:33:25 <newsham> > runWriter (tell "3" >> tell "wee" >> return 5)
17:33:26 <lambdabot>   (5,"3wee")
17:33:40 <tsar> newsham: http://hpaste.org/10572
17:33:41 <Baughn> @instances Monoid
17:33:42 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:33:42 <dmwit> > runWriter (tell 3 >> return 5) :: (Int, Product Int)
17:33:43 <lambdabot>       No instance for (Num (Product Int))
17:33:43 <lambdabot>        arising from the literal `3'...
17:33:45 * Twey blinks.
17:33:47 <Twey> What is this?
17:33:57 <newsham> > runWriter (tell "3" >> tell "wee" >> listen 8)
17:33:58 <lambdabot>       No instance for (Num (Writer [Char] a))
17:33:58 <lambdabot>        arising from the literal...
17:34:04 <Twey> I would have thought that tell would overwrite
17:34:05 <dmwit> :t listen
17:34:05 <shrughes> > second ($"") $ runWriter (tell ("3":) >> tell ("wee":) >> return 5)
17:34:07 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
17:34:07 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
17:34:07 <newsham> > runWriter (tell "3" >> tell "wee" >> listen "!")
17:34:08 <lambdabot>   Couldn't match expected type `Writer w a'
17:34:10 <tsar> http://hpaste.org/10572
17:34:13 <monochrom> Paul Graham is the first celebrity to promote a politically biased programming language test suite. He deliberately rules out (+ 1).
17:34:14 <dmwit> Twey: mappend;
17:34:14 <newsham> what are listen and pass?
17:34:20 <Twey> Oh
17:34:27 <shrughes> > second ($"") $ runWriter (tell ("3"++) >> tell ("wee"++) >> return 5)
17:34:28 <lambdabot>   mueval: Prelude.read: no parse
17:34:43 <tsar> if it is passed [] i want to return nothing
17:34:47 <Baughn> listen lets you filter the currently written stuff, and return it. Censor lets you edit it.
17:34:51 <tsar> oe do nothing
17:34:58 <shrughes> > runWriter (tell ("3"++) >> tell ("wee"++) >> return 5)
17:34:59 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
17:34:59 <lambdabot>        arising from a...
17:35:06 <newsham> tsar: now arrow is defined for empty lists and for lists of length 2
17:35:35 <dmwit_> Actually, I guess you couldn't have a Monoid instance that simply overwrites; it wouldn't satisfy the Monoid laws.
17:35:35 <shrughes> > second ($ "") $ runWriter (tell ("3"++) >> tell ("wee"++) >> return 5)
17:35:37 <lambdabot>   mueval: Prelude.read: no parse
17:35:41 <shrughes> hrm
17:35:47 <lispy> monochrom: huh, so the "test suite" checks that certain, 'bad' things aren't possible?  I would have expected a more open test where you demonstrate handy functionality
17:35:50 <dmwit_> > second
17:35:52 <lambdabot>       Overlapping instances for Show (a b c -> a (d, b) (d, c))
17:35:52 <lambdabot>        arisin...
17:35:58 <Baughn> > execWriter (do tell [1..4]; tell [2,3,7]; censor (filter (< 5)))
17:35:59 <lambdabot>   Couldn't match expected type `Writer w a'
17:36:05 <newsham> > second (*2) ("test", 12)
17:36:07 <lambdabot>   mueval: Prelude.read: no parse
17:36:09 <shrughes> it's giving a parse error, that's the disturbing part
17:36:18 <newsham> > Control.Arrow.second (*2) ("test", 12)
17:36:19 <lambdabot>  Terminated
17:36:29 <shrughes> > (\(x,y) -> (x, y "")) $ runWriter (tell ("3"++) >> tell ("wee"++) >> return 5)
17:36:30 <Baughn> > execWriter (censor (filter (<5)) (do tell [1..4]; tell [2,3,7]))
17:36:30 <lambdabot>   (5,"3wee")
17:36:31 <lambdabot>   [1,2,3,4,2,3]
17:36:33 <monochrom> That is Paul Graham for you.
17:36:45 <dmwit_> ?undefine
17:36:56 <dmwit_> > second (*2) (1, 5)
17:36:57 <lambdabot>   mueval: Prelude.read: no parse
17:37:04 <newsham> what are writer's listen and pass methods?
17:37:05 <shrughes> What is mueval?
17:37:17 <Twey> The safe-Haskell-evaluator
17:37:23 <shrughes> say no more
17:37:46 <Baughn> > runWriter (listen (do tell [1..4]; tell [2,3,7]))
17:37:47 <lambdabot>   (((),[1,2,3,4,2,3,7]),[1,2,3,4,2,3,7])
17:37:48 <lispy> monochrom: yeah, PG is weird.
17:38:27 <dmwit> newsham: Their types say it all, really.
17:38:40 <newsham> ahh
17:39:00 <BONUS_> > runWriter (listen (tell "3") >>= \(_,w) -> tell "4" >> return w)
17:39:01 <lambdabot>   ("3","34")
17:39:37 <lispy> oh, do tell
17:39:49 <dmwit> ?undo do tell
17:39:49 <lambdabot> tell
17:40:20 <newsham> > runWriter (tell "lies" >> tell "sweet little lies")
17:40:21 <lambdabot>   ((),"liessweet little lies")
17:40:54 <Baughn> http://hpaste.org/10574 <-- For those of you experimenting with writer, I thought I'd paste a practical use of it. Look at the lowermost function.
17:42:25 <lispy> writer is awesome, BTW
17:42:30 <aempirei> the newsham
17:42:36 <lispy> I wrote a compiler and used writer to generate the ASM
17:42:37 <newsham> hey ae
17:42:41 <newsham> hows code?
17:42:48 <aempirei> man i think haskell is so funny i wish i learned it earlier on
17:42:50 <lispy> I had a code gen monad based on writer
17:42:57 <newsham> ae: thats what i keep trying to tell people
17:43:00 <newsham> but they dont listen
17:43:02 <aempirei> its really intuitive
17:43:11 <aempirei> i cant believe it gets a bad rep for bein confusing
17:43:14 <newsham> its ideal for math addicts
17:43:44 <aempirei> yea
17:43:50 <BONUS_> the more haskell i learn, the more i see how simple it actually is
17:43:56 <aempirei> the laziness is awesome
17:44:06 <aempirei> and the strictness of typing i really like
17:44:24 <lispy> not all haskell code is good and intuitive
17:44:34 <aempirei> well thats the programmer
17:44:41 <lispy> I don't want to point fingers, but I read a lot of crap Haskell code
17:44:52 <lispy> Okay, as long as you know :)
17:44:55 <newsham> lispy: ae used to work for a shop that makes heavy use of perl. i'm sure he's familiar with good and bad code :)
17:44:58 <aempirei> people blame perl for thart same problem
17:45:05 <aempirei> yea
17:45:09 <BONUS> you can write good and bad code in any language
17:45:11 <BONUS> except fortran
17:45:15 <Twey> And BASIC
17:45:19 <BONUS> and cobol
17:45:25 <dbelange> Hello.
17:45:26 <FunctorSalad> > let { f x = tell "in sqrt, " >> return (sqrt x);         g x = tell "in **3, " >> return (x**3) }        in runWriter (return 10 >>= f >>= g >>= f >>= g)
17:45:27 <Twey> And Brainfuck
17:45:27 <lambdabot>   (177.8279410038923,"in sqrt, in **3, in sqrt, in **3, ")
17:45:31 <shrughes> especially cobol
17:45:32 <aempirei> you still at isec
17:45:36 <newsham> ae: yup
17:45:39 <dbelange> Does anyone know where I can find a Haskshell for Linux?
17:45:42 <aempirei> are they gonna make you a aprtner
17:45:49 <FunctorSalad> a bit late, that was for the one who wanted to collect debug messages or something
17:45:53 <newsham> *shrug*  dunno..  doesnt really matter
17:45:57 <BONUS> if you have ghc installed just run ghci
17:46:00 <aempirei> my dad moved back to hawaii hes workin on maui right now
17:46:10 <aempirei> so ill be in town maybe in nov.
17:46:11 <newsham> maui's hella expensive
17:46:29 <aempirei> hows the cats
17:46:33 <aempirei> and thw wife
17:46:33 <lispy> dbelange: haskell for linux?  try ghc
17:46:46 <newsham> ae: wife, cat and baby.  all well.
17:46:53 <newsham> s/cat/cats/
17:46:55 <dbelange> Yarr, ghci should indeed work.
17:47:11 <aempirei> man marshall keeps wanting to program web apps in haskell i keep shakin my head i disdain
17:47:13 <monochrom> haskell gets a bad reputation of being confusing because there are too many bloggers.
17:47:18 <aempirei> oh what baby
17:47:20 <aempirei> what a baby
17:47:21 <aempirei> congrats
17:47:41 <newsham> ty
17:47:50 <lispy> aempirei: why od you want to avoid haskell for web apps?
17:47:52 <encryptio> monochrom: i always say "haskell is just as complicated as any other language when you deal with it at that level"
17:47:58 <aempirei> i should be married by thanksgiving
17:48:03 <olsner> hmm, this is weird... if I have my own function iterateM_ x y f = forM_ [x..y] f, and a rewrite rule iterateM_ = \x y f -> forM_ [x..y] f, my program gets twice as fast as when I use forM_ directly
17:48:17 <newsham> ae: we should take this to #haskell-blah
17:48:35 <aempirei> i ujs t lie programming web apps in an imparaive language with a long history of development and support for web apps
17:48:48 <aempirei> like php or ruby
17:49:26 <aempirei> lie/like
17:49:30 <newsham> ae: www.thenewsh.com/~jack for baby. also congrats on engagement
17:49:40 <aempirei> thanks
17:49:56 <BONUS> nice babby
17:49:58 <newsham> wanna join #haskell-blah for off-topic discussion?
17:50:42 <lispy> aempirei: ah.  Yeah, that's a chicken 'n egg problem until the early adopters do some thing successful
17:52:39 <newsham> bonus: ty
17:52:44 <x6d65> This is only vaguely related to web development in Haskell, but... can you do something like plugins with Haskell, where you have a server that can load in new (and redefined) modules without going down?
17:52:51 <aempirei> yes i don tfeel like trailblazing web app development in haskell since i dont care to do web dev in the first place
17:53:09 <olsner> @seen dons
17:53:09 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 40m 8s ago.
17:53:32 <monochrom> x6d65: it's harder but yes. lambdabot seems to do it.
17:53:33 <aempirei> were using lightthttp right now for some silly hobby stuff
17:53:41 <aempirei> it seems interesting as a programming exercise
17:53:53 <newsham> there are already a few trailblazers like wash, happs, hsp, etc..
17:53:56 <lispy> x6d65: yes, there are different ways to do this at the moment
17:53:57 <newsham> but its still web programming
17:54:36 <x6d65> I'm thinking about a sort of MUD, where you'd like to be able to add new objects, verbs, etc. to the system on the fly.
17:54:43 <lispy> x6d65: you could use hs-plugins for example.  With ghc there is the ghc-api that can allow some types of pluging in, but not as general as hs-plugins.
17:55:15 <lispy> x6d65: with such a structured api, you could probably just define an interface for the plugins and then load them via .so/.dll files
17:55:26 <olsner> dons: I ended up writing an STArray version of spectral-norm that is just as fast but not using any of that unsafe pointer stuff
17:55:37 <lispy> x6d65: another more language agnostic approach is to let them communicate via pipes
17:55:39 <newsham> or you could write an embedded language for plugins, and interpret them in your system
17:56:01 <lispy> newsham: yeah, actually, is it possile to use ghc as the embedded interpreter?
17:56:06 <aempirei> i wish more symbols were uppercase for type definitions
17:56:23 <Twey> x6d65: You're thinking of a MOO
17:56:33 <aempirei> and more symbols.like [] existed to overload or ddfine as types
17:56:40 <newsham> lispy: yah, you can interface with ghc internals or use hs-plugins to load haskell code dynamically
17:56:41 <aempirei> like {} or <b
17:56:45 <aempirei> <>
17:56:54 <aempirei> or even ""
17:57:04 <newsham> you can use :<
17:57:14 <newsham> just a litte more keyboard typing
17:57:25 <aempirei> ad hoc polymorphism would be nice yeah the : is goofy as the only uppercase
17:57:26 <x6d65> lispy: What do you mean by communicating by pipes?
17:57:31 <newsham> or you could use agda, which blurs the lines between types and values
17:57:39 <aempirei> ah
17:58:05 <lispy> x6d65: the programs send requests to each other and do some processing then reply
17:58:14 <newsham> agda's more mathy, more powerful type system, less practical for writing programs
17:58:23 <aempirei> cause forexample vector calc/lin algebra's magnitude/norm function
17:58:33 <aempirei> |a|
17:58:34 <lispy> x6d65: you could think of webservices as an example, but it's also like event loops in OO languages and message passing.
17:58:41 <aempirei> i wish u coukld define that correctly
17:59:03 <aempirei> thats a func def tho not a type def
17:59:15 <newsham> *nod*
17:59:40 <lispy> x6d65: often it's made simpler if both languages know a text based mini language for sending the requests
18:00:09 <lispy> x6d65: it's nice though, because then anything that implements the protocol can participate.  very agnostic, very plugin friendly
18:00:26 <aempirei> maybe you can do a patternmatch that makes it seem right
18:00:26 <lispy> x6d65: obviously not as high performance as compiled in solutions though
18:00:57 <aempirei> (|)a(|)=(Vector a) => norm a
18:01:04 <aempirei> something like that
18:01:20 <lispy> you could do (-|) and (|-) operators
18:01:25 <aempirei> ahh
18:01:27 <lispy> There was an example on Haksell-cafe recently
18:01:37 <lispy> so then you'd have -| a |-
18:01:44 <lispy> but, that's not really what you want
18:02:01 <x6d65> lispy: Are you imagining that you'd have a "verb" process that the main loop would dispatch to?
18:02:31 <newsham> or you could use "abs a" :)
18:02:32 <aempirei> jst the fact you can have functor names with symbols is a step up from most oop imperative langs tho
18:02:43 <aempirei> so i cant complain too much
18:03:03 <aempirei> whos goofy idea was it to make /= be not equal tho,
18:03:15 <BONUS> yeah thats pretty goofy
18:03:19 <aempirei> i get how it s more similar to mathy normal not equal symbol
18:03:19 <BONUS> i wish it was !=
18:03:21 <BONUS> but oh well
18:03:45 <Twey> > let (!=) = (/=) in 3 != 5
18:03:46 <lambdabot>   True
18:03:51 <lispy> x6d65: Well, yeah maybe that's a way to express it.  I was thinking, you make a small language for expressing the requests and then send messages in that language. You could, for example, us an XML schema.  This is how jabber works.
18:04:08 <lispy> I prefer != too
18:04:13 <newsham> have you seen lhs2tex yet?
18:04:21 <aempirei> were all just used ot !=
18:04:24 <lispy> I have a hard time remembering if it's =/ or /=
18:04:24 <newsham> lets you write literate code that is also latex src
18:04:27 <newsham> with nice typesetting
18:04:29 <aempirei> and some ppl are used to <>
18:04:42 <lispy> <> is not bad, but it has other cool uses :)
18:05:01 <lispy> ?hoogle (<>)
18:05:01 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
18:05:01 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
18:05:16 <aempirei> any time i aee <> as not equal it remind s me of being 6 yrs old
18:05:29 <aempirei> aee/see
18:05:48 <BONUS> reminds me of pascal
18:06:04 <BONUS> and now i've gotten used to stuff that begins with < and ends with > being a combinator
18:06:04 <newsham> ae: for example see http://www.thenewsh.com/~newsham/x/machine/khjk/
18:06:05 <lambdabot> Title: Directory /~newsham/x/machine/khjk/
18:06:06 <aempirei> yea reminds me of pet basic
18:06:18 <newsham> .lhs == src/tex, .pdf == typeset
18:06:19 <lispy> I'm actually kind of anti operators
18:06:22 <Twey> Reminds me of SQL
18:06:44 <lispy> For example, code I was reading yesterday defined both (.&&) and (..&&) with the same type signature and exported both :(
18:06:49 <lispy> No haddocks either
18:06:54 <BONUS> ugh
18:06:58 <Twey> Yuck :-\
18:07:04 <BONUS> operators should be defined sparingly, yea
18:07:04 <BONUS> h
18:07:07 <newsham> when typeset /=  looks decent :)
18:07:29 <HanDongSeong> ì
18:07:36 <HanDongSeong> oops... sorry.
18:09:29 <aempirei> ilike symbolic operatoras as long as they arent contrived
18:09:44 <aempirei> like the xor symbol is really cool loooking
18:09:56 <lispy> HughesPJ and arrows both define a ton of operators and it annoys me sightly, and that's considering both of them do it well.  There are plenty of times when people don't do it well
18:10:01 <aempirei> a circle with an x through it looks pretty tough
18:10:32 <newsham> aâbâc
18:11:10 <aempirei> thats why i really like latex
18:11:22 <aempirei> you can make everthing look fun and cool
18:11:28 <newsham> if you use a modern irc client you can do unicode on irc
18:11:28 <ddarius> > [(a,b,a/=b) | a <- [True,False], b <- [True,False]]
18:11:30 <lambdabot>   [(True,True,False),(True,False,True),(False,True,True),(False,False,False)]
18:11:49 <lispy> I use irssi, screen and terminal.app and I get unicode, so modern may not be that important :)
18:11:54 <aempirei> yea thats so overkill using unicode in haskell
18:12:15 <Twey> Maybe for you
18:12:16 <aempirei> like you better be ultra awesome to warrant using those symbols
18:12:20 <Twey> Not for Japanese people
18:12:31 <newsham> > let (â) = (*) in 1 â 2 â 3 â 4 â 5
18:12:32 <lambdabot>   120
18:12:34 <aempirei> touche
18:13:00 <newsham> > let (â) = (+) in 1 â 2 â 3 â 4 â 5
18:13:01 <Twey> Hmm
18:13:01 <lambdabot>   15
18:13:09 <Twey> > isAlpha 'è¶³'
18:13:10 <lambdabot>   True
18:13:32 <aempirei> unfortunately im on a sideick so i cant see your cool operators
18:13:43 <Twey> Except there are no capitals in Japanese...
18:13:48 <newsham> its circle-plus
18:13:52 <HanDongSeong> hi, i'm making a simple Win32 app with Haskell Graphics.Win32. i figured it out that a Win32 app works like: it calls the specified function only when a message occurs.
18:13:54 <HanDongSeong> what i want to do is to add some actions in the main loop, but the problem is that there's no main loop
18:13:56 <Twey> Does that mean no Japanese constructors?
18:14:03 <tsar> http://hpaste.org/10575 , how can arrow not compile when arrow 2 does? how can it deduct it s an erronous value thatwill be passed in col?
18:14:28 <HanDongSeong> so i think i should have separate threads and a shared space that contains state
18:15:14 <newsham> tsar: one has a "do" and one doesnt
18:15:27 <HanDongSeong> but i think this is really a non-haskell way
18:15:27 <lispy> HanDongSeong: Hmm...I thought this was solved by giving a function that takes an event and returns IO (), as a "call back"
18:15:28 <HanDongSeong> (not to mention that i couldn't find any way to do it)
18:16:14 <HanDongSeong> lispy, what i want to do is like, for example, to move a box on the screen constantly while waiting for user input
18:16:53 <HanDongSeong> callback function (wndProc, in a Win32 app) obviously can't do this
18:17:13 <HanDongSeong> since it is only called when an event happens
18:17:30 <lispy> Well, it can do it :)
18:17:37 <HanDongSeong> really?
18:17:40 <lispy> You could set a timer for example to keep sending you events
18:17:42 <tsar> changed and get: Couldn't match expected type `IO t'
18:17:42 <tsar>            against inferred type `GLfloat -> IO ()'
18:18:11 <lispy> HanDongSeong: you could have a timer that goes off and sends you the event to move the box
18:18:40 <lispy> HanDongSeong: if you really want to have a separate thread do the moving, that shouldn't be hard using forkIO
18:19:29 <fxr> Ä± just wrote a libev wrapper using ffi, is it ok to upload beta software to hackage ?
18:19:40 <HanDongSeong> yeah i was thinking about using forkIO, but can threads (made by forkIO) share a same space that contains state?
18:19:47 <lispy> HanDongSeong: you have this documentation, right? http://www.haskell.org/ghc/docs/latest/html/libraries/Win32/Graphics-Win32.html
18:19:49 <lambdabot> Title: Graphics.Win32, http://tinyurl.com/3h8lck
18:20:02 <HanDongSeong> lispy, exactly
18:20:11 <lispy> HanDongSeong: oh, you'll very likely want to use STM if you're sharing memory between threads
18:20:23 <lispy> HanDongSeong: are you familiar with STM?
18:20:42 <HanDongSeong> oh.. not even heard of it
18:21:32 <tsar> Couldn't match expected type `IO t'
18:21:32 <tsar>            against inferred type `GLfloat -> IO ()'
18:21:50 <aempirei> so i was using the list monad and was trying to print out each item in the list
18:21:55 <tsar> http://hpaste.org/10576
18:21:59 <HanDongSeong> lispy, can i deliberately make a WindowMessage happen?
18:22:14 <aempirei> i think the bind operator in this context of the list monad was confusing me
18:22:48 <lispy> HanDongSeong: yeah, you can post messages
18:22:57 <aempirei> becaus ei honestly didnt understand the type mismatch errors i was getting
18:23:08 <lispy> HanDongSeong: it's not a half bad way to make things happen inside your application...you use the same channel to communitate as the OS would use
18:23:24 <lispy> HanDongSeong: I forgot all the details on posting messages, but I've done it before
18:23:26 <newsham> haskell errors take a while to get used to
18:23:46 <lispy> HanDongSeong: STM is pretty sweet.  There are tutorials and what not.  Check the haskellwiki and the haskell-cafe mailing list archives
18:23:51 <newsham> > do { x <- [1..5]; y <-- "abc"; return (replicate x y) }
18:23:52 <lambdabot>   mueval: Prelude.read: no parse
18:24:00 <hydo> "If I needed to do web programming in haskell, I would start with ________"
18:24:03 <newsham> > do { x <- [1..5]; y <- "abc"; return (replicate x y) }
18:24:04 <lambdabot>   ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa","bbbb","cccc","aaaaa",...
18:24:20 <newsham> > [replicate x y | x <- [1..5], y <- "abc"]
18:24:21 <lambdabot>   ["a","b","c","aa","bb","cc","aaa","bbb","ccc","aaaa","bbbb","cccc","aaaaa",...
18:24:41 <newsham> hydo: happs probably.
18:24:45 <HanDongSeong> lispy: i'll check them out right now. thanks!!
18:24:53 <aempirei> so my naieve attempt was do x<-[1,2,3];putStrLn (show x);return x
18:25:02 <tsar> how can adding a parameter and not using it give an error!?
18:25:08 <newsham> ahh, you're mixing diff monads in the same do-block.
18:25:11 <hydo> newsham: thanks!
18:25:16 <aempirei> ohhhh
18:25:20 <lispy> hydo: personally, I would start with happs
18:25:21 <aempirei> putstrln is io
18:25:24 <newsham> yup
18:25:30 <aempirei> ooooo
18:25:51 <aempirei> so every monadic interfacwe seems to be vastly diffeent
18:26:02 <Twey> It's a very general pattern
18:26:11 <newsham> bind needs both sides to be the same monad
18:26:13 <newsham> ?type (>>=)
18:26:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:26:14 <aempirei> because i was having trouble rwrapping me head around the list one
18:26:27 <tsar> newsham, me?
18:26:45 <newsham> tsar: discussing ae's code.
18:27:12 <newsham> the data monads (ie. Maybe and List) are a bit different than the imperative looking ones (ie. State and IO)
18:27:32 <newsham> ie. in IO and State you're getting kind of a sequence of commands one after another
18:27:49 <newsham> in the list one, its like there are implicit loops going on
18:28:41 <newsham> > do { x <- [1..3]; y <- "abc"; return (x,y) }
18:28:42 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
18:29:17 <lispy> With the list monad you can approximate non-determinism
18:30:37 <lispy> also, you can use pattern matching in do-notation like a guard which is crazy/cool
18:30:48 <adu> hi
18:30:55 <lispy> > do Just 4 <- return 4; return ()
18:30:56 <lambdabot>       No instance for (Show (t ()))
18:30:56 <lambdabot>        arising from a use of `show' at <i...
18:31:18 <lispy> > do Just 4 <- return 4; return () :: [()]
18:31:19 <lambdabot>       No instance for (Num (Maybe t))
18:31:19 <lambdabot>        arising from the literal `4' at ...
18:31:24 <lispy> > do Just 4 <- return 4; return () :: Maybe ()
18:31:25 <lambdabot>       No instance for (Num (Maybe t))
18:31:25 <lambdabot>        arising from the literal `4' at ...
18:31:26 <aempirei> yea the seemingly many returns inthe list monads made me think i could just pop in a print stlatemetnt in the chain
18:31:30 <lispy> oh nevermind :)
18:31:40 <newsham> i dont like the use of the word "return"
18:31:44 <roconnor> > (do Just 4 <- return 4; return ()) :: [()]
18:31:45 <lambdabot>       No instance for (Num (Maybe t))
18:31:45 <lambdabot>        arising from the literal `4' at ...
18:32:01 <roconnor> > (do Just 4 <- return (return 4); return ()) :: [()]
18:32:02 <lambdabot>   [()]
18:32:07 <roconnor> o/
18:32:09 <roconnor> \o/
18:32:23 <aempirei> because i was havingyea return is weird to me it almost seems like a data tytpe constructor function
18:32:30 <aempirei> for IO a
18:32:57 <lispy> return is weird, "inject" makes more sense veen
18:33:04 <newsham> yah, or "wrap" or something like that
18:33:04 <lispy> :t retrun
18:33:05 <lambdabot> Not in scope: `retrun'
18:33:08 <lispy> :t return
18:33:09 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:33:12 <newsham> "pure", "monad" whatever.
18:33:20 <lispy> "monadify"
18:33:23 <newsham> > pure 3 :: [Int]
18:33:24 <lambdabot>   [3]
18:33:28 <Cale> heh
18:33:34 <lispy> :t pure
18:33:36 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:33:40 <Cale> return makes sense to me
18:34:06 <Cale> If you're thinking of monadic values as computations, then (return v) is the computation which does nothing and always returns v.
18:34:09 <newsham> Cale: it might make sense, but its deceiving to people who come from bcpl-style programming
18:34:38 <Cale> You could argue that 'class' is confusing too, since it doesn't mean what it does in Java ;P
18:34:54 <newsham> sure.  and it is a little bit, but not as confusing.
18:35:02 <monochrom> Hahahaha "bcpl-type"
18:35:19 <aempirei> class makes sense
18:35:26 <aempirei> it seems like a normal kinda class
18:35:31 <Cale> I think it can be assumed that everything in Haskell is different enough.
18:35:32 <newsham> class's meaning is different than OO class.
18:35:52 <Cale> 'class' is about as similar in Haskell and Java as 'return' is :)
18:35:54 <newsham> class is like java's interface.  and instances are sort of like java's class
18:35:54 <monochrom> "data A = ...", "type A = ...", "newtype A = ..." are confusing too.  I mean the choice of the words "data", "type", "newtype".
18:36:11 <newsham> now we're just being silly :)
18:36:23 <lispy> actually, I do wish haskell 'class' was 'interface'
18:36:30 <lispy> But, then 'type interface' seems weird
18:36:32 <hydo> Under the HAppS "Getting Started" section the third step is "sp ghc -isrc src/Main.hs .... "   What is 'sp'?  I'm apparently missing it.
18:36:49 <lispy> hydo: a typo?
18:37:29 <hydo> lispy: Yea, I thought that, but I can't come up with anything that makes sense.  It's definitely not 'cp'...
18:37:52 <hydo> I just figured it was some cabal or hs specific util that I hadn't installed for whatever reason.
18:38:22 <newsham> there's a #happs channel, too I think.  though this is a good place to ask, too.
18:38:24 <chrisdone> how does lambdabot address the truncation-of-irc-messages problem?
18:38:47 <hydo> newsham: good point, I'll ask there as well.
18:38:50 <Cale> chrisdone: By truncating everything much more restrictively.
18:39:22 <chrisdone> Cale: you mean (1) really short message limit and (2) hope?
18:39:33 <lispy> chrisdone: mostly (1)
18:39:41 <newsham> chris: bot failure is not catastrophic
18:39:48 <Cale> chrisdone: something like 80 characters
18:39:54 <chrisdone> newsham: yes
18:39:59 <lispy> well, unless you use ?unsafePerformMissileLaunche
18:40:16 <newsham> > unsafePerformMissileLaunch $ coords lispy
18:40:16 <lambdabot>   mueval: Unsafe functions to use mentioned.
18:40:16 <lispy> ?unsafePerformMissileLaunch
18:40:17 <lambdabot> Unknown command, try @list
18:40:20 <chrisdone> Cale: ah
18:40:45 * chrisdone considers reducing his bot's 380 limit ..
18:41:07 <newsham> > "1                    2                        3                  4                      5                         6                     7"
18:41:08 <lambdabot>   "1                    2                        3                  4        ...
18:42:06 <ddarius> > sqrt 10
18:42:07 <lambdabot>   3.1622776601683795
18:42:42 <aempirei> maybe im stupid but class just seemed to define a type class and overloaded methonds on members of the type class more or less
18:43:45 <newsham> class doesnt define any implementation (except for default definitions).  the implementation is in instance decls
18:44:01 <newsham> class decls just define the signatures of the interface
18:44:19 <aempirei> ah yea
18:45:09 <tsar> http://hpaste.org/10577, how would i write the [] case?
18:45:14 <Cale> Also, classes (well, objects) in Java carry functionality along with data. In Haskell, that functionality is carried separately, which means that functions can be polymorphic only in their result type.
18:45:25 <newsham> > showCReal 200 (sqrt 10)
18:45:26 <lambdabot>   "3.162277660168379331998893544432718533719555139325216826857504852792594438...
18:45:36 <aempirei> i think of data types as abstract containers sorta
18:46:04 <aempirei> so classes and methods on those class types just seem to be the classmethods on the container
18:46:18 <aempirei> im still new to haskell
18:46:25 <aempirei> so im retarded
18:46:44 <newsham> i've only been studying haskell for 3 years or so, so i'm still pretty retarded too
18:47:11 <ddarius> > 2003 * sqrt 10
18:47:12 <lambdabot>   6334.042153317264
18:47:13 <tsar> Nothing
18:47:15 <hydo> aempirei: The first rule of Tard Club is...
18:47:31 <chrisdone> .. you forget the first rule of Tard Club
18:47:48 <aempirei> its excellent tho the first thing i did in haskell was define a e list comprehension generating the primes
18:47:50 <ddarius> > 1006003 * sqrt 10
18:47:52 <lambdabot>   3181260.8129623705
18:47:58 <aempirei> and was like woo sweet lazy eval
18:48:16 <newsham> ?let a `divides` b == b `mod` a == 0
18:48:16 <lambdabot>   Parse error
18:48:23 <newsham> ?let a `divides` b = b `mod` a == 0
18:48:24 <lambdabot>  Defined.
18:48:29 <newsham> > nubBy divides [2..]
18:48:30 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:48:32 <ddarius> 3006001*sqrt 10
18:48:34 <tsar> [(Maybe a, b)] , how would i call that?
18:48:49 <ddarius> > 3006001*sqrt 10
18:48:50 <lambdabot>   9505809.808743808
18:48:57 <ddarius> > 3002 * sqrt 10
18:48:58 <lambdabot>   9493.157535825476
18:49:05 <lispy> :t unzip
18:49:06 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
18:49:35 <lispy> :t unzipWith
18:49:36 <lambdabot> Not in scope: `unzipWith'
18:49:46 <lispy> unzipWith would be... interesting
18:50:00 <lispy> aempirei: wait until you discover fix
18:50:23 <tsar> dropUntil :: [(Maybe a, b)] -> (b -> Bool) -> Maybe a
18:50:27 <lispy> > 433 `elem` (nubBy divides [2..])
18:50:28 <aempirei> i did it like [x|x<[2..],[y|y<-[2..x-1],mod x y]==[]]
18:50:28 <lambdabot>   True
18:50:31 <tsar> how d i call it?
18:50:40 <Cale> > fix ((0:) . scanl (+) 1)
18:50:41 <dejones> How can I pass a flag to "runghc Setup.hs configure" to specify the command for linking the GLUT library on my system (which is "-lglut")?
18:50:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:52:58 <newsham> dejones: you could always add it as an additional libraries setting in the *.cabal file
18:53:20 <aempirei> is there a hotnl ntohl
18:53:27 <aempirei> htonl
18:53:47 <aempirei> cause theres no way in lang to trst for endianness
18:54:00 <dejones> newsham: Well, I don't want it to be an additional library.  I want to specify how to link OpenGL and GLUT for configure so that when I install the Haskell OpenGL and GLUT packages, and they are used for a Haskell program, it is linked in the method I specify.  Does that make sense?
18:55:12 <newsham> *nod*  you want it to be used each time that package is linked against
18:55:18 <dejones> newsham: My problem is that configure of Haskell packages OpenGL and GLUT are incorrectly choosing to link the C-headers for OpenGL and GLUT (-lGL and -lGLU, respectively), so I get many linker errors.
18:55:49 <newsham> adding it as an additional library might do that, but i'm not sure.  i'm pretty weak on cabal.
18:56:07 <dejones> newsham: yah, I'm weak on cabal too.  Where is dcoutts_ when you need him?  :)
18:56:07 <dejones> hehe
18:56:12 <newsham> ae: some libraries do it for you.  you could always import it from libc if you wanted to.
18:57:08 <dejones> :(
18:57:09 <dejones> heh
18:57:11 <aempirei> oh cool libc bindingds
18:57:24 <edwardk> @seen dons
18:57:24 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 2m 18s ago.
18:57:45 <edwardk> i finally converted to xmonad
18:58:01 <aempirei> can libc bindings be bound as functional functors
18:58:08 <aempirei> not as monadic interfaces
18:58:15 <dons> edwardk:
18:58:18 <dons> yay
18:58:25 <dons> welcome aboard, ed
18:58:29 <edwardk> =)
18:58:33 <newsham> ae: yah, you can make pure functions and IO functions with FFI
18:58:40 <aempirei> nice
18:58:44 <newsham> for example sin from libm.a can be marked as pure
18:58:50 <aempirei> u can cause trouble with pure functions then
18:59:01 <aempirei> sounds like time 2 abuse it
18:59:08 <newsham> yah, there are several ways you can shoot yourself in the foot in haskell
18:59:15 <newsham> another is unsafePerformIO
18:59:18 <newsham> ?type unsafePerformIO
18:59:19 <lambdabot> Not in scope: `unsafePerformIO'
18:59:37 <newsham> ?type System.IO.Unsafe.unsafePerformIO
18:59:38 <lambdabot> forall a. IO a -> a
18:59:40 <dons> there's no static guarantee for the correctness of ffi bindings.
18:59:44 <dons> such a tool would be invaluable
18:59:49 <dons> i could not value it :)
18:59:57 <dons> it would be useful. please write it.
19:02:29 <newsham> ae: here's one way to test for endian: http://codepad.org/CrlzQC9z
19:02:42 <aempirei> lol gurantee for static bindings
19:02:50 <aempirei> aka intractablew math problems
19:04:56 <newsham> or with 32-bit numbers.  http://codepad.org/Yl5z56nj
19:05:01 <reltuk> anyone know if running env GHC_PACKAGE_PATH=... runghc Setup.hs configure --package-db ... should result in compiling _against_ --package-db, while the runghc which is running the compile uses GHC_PACKAGE_PATH (for example, the Cabal from the package path)?
19:07:23 <dejones> newsham: ghc -package GLUT -lglut Hello1.hs -o Hello1 --- works!  :)  I must specify the package and the library to link.
19:08:01 <dejones> I still don't really understand why that is necessary, aka why it doesn't figure out correctly how to link the library; but, at least I found a working solution.
19:09:12 <newsham> :\
19:10:05 <tsar> dropUntil :: [(Maybe a, b)] -> (b -> Bool) -> Maybe a , how do you call this function?
19:10:27 <tsar> @src maybe
19:10:28 <lambdabot> maybe n _ Nothing  = n
19:10:28 <lambdabot> maybe _ f (Just x) = f x
19:11:17 <newsham> call it with a list of (Maybe a, b) values,  with a function that turns b values to True or False values
19:11:24 <newsham> and get back a Maybe a
19:12:08 <lispy> What is so weird about dropUntil?
19:12:56 <newsham> > maybe 5 (+3) (Just 10)
19:12:57 <lambdabot>   13
19:13:01 <newsham> > maybe 5 (+3) Nothing
19:13:02 <lambdabot>   5
19:14:23 <lispy> > dropUntil [(Just 1, 0), (Just 2, 1)] (==1)
19:14:24 <lambdabot>   mueval: Prelude.read: no parse
19:14:40 <lispy> no parse?
19:14:52 <lispy> > [(Just 1, 0), (Just 2, 1)]
19:14:53 <lambdabot>   [(Just 1,0),(Just 2,1)]
19:15:00 <lispy> where is the parse error?
19:15:09 <newsham> > dropUntil
19:15:10 <lambdabot>   mueval: Prelude.read: no parse
19:16:01 <lispy> ?tell gwern mueval gives weird error messages about parse failure when given a function name that doesn't exist.
19:16:02 <lambdabot> Consider it noted.
19:16:31 <dejones> allbery_b: You there?  I'm the person having problems with OpenGL / GLUT linking errors on haskell-cafe.
19:16:43 <allbery_b> hm?
19:17:03 <dejones> allbery_b: You're Brandon S Allbery, right?
19:17:12 <allbery_b> yes
19:17:29 <dejones> allbery_b: You just replied to my email about linker errors for OpenGL / GLUT on haskell-cafe.
19:17:32 <dejones> :)
19:18:03 <allbery_b> I shouldprobably expand on muy last message, I know Unixy stuff but not HOpenGL (and not Debian/Ubuntu very well)
19:18:09 <dejones> allbery_b: Thanks for the replies.  I'm hoping one of the people from the hopengl mailing list will suggest a fix that is not an override.
19:18:44 <allbery_b> so I can't really help much with "so why does HOpenGL's configure get it wrong to begin with?"
19:18:50 <newsham> when installing libraries, somehow the libraries can remember the extra libs needed.
19:18:58 <allbery_b> that's not the point here
19:19:05 <dejones> allbery_b: Yah, I'm definitely confused why "configure" gets it wrong in the first place.
19:19:13 <newsham> i think if you compiled the opengl lib with the right cabal file, it would auto-link in the extra libs you need
19:19:15 <allbery_b> configureon his system thinks GLUT lives in -LGLU, but it's actually in -lglut
19:19:40 <dejones> newsham: configure gets it wrong, thinks "-lGLU" like allbery_b said.
19:19:43 <allbery_b> so when you try to use GLUT from an HOpenGL-using program, the link fails
19:19:57 <allbery_b> as it looks for a nonexistent libGLU.so
19:20:14 <newsham> the easy hack fix would be to edit configure and make it say -lglut
19:20:30 <ddarius> 1.1**2 / (11**3 * 1.01**2)
19:20:33 <newsham> or make sym link form libglut.* to libGLU.*
19:20:35 <allbery_b> except my experience with configure in general suggests that it might not actually be easy
19:20:37 <ddarius> > 1.1**2 / (11**3 * 1.01**2)
19:20:38 <lambdabot>   8.911782267335646e-4
19:20:42 <chreekat> I have totaly noob questions, just started reading through "yet another haskell tutorial" earlier today. The question is about one of the exercise in it. Question is:
19:20:44 <allbery_b> symlink was my suggestion
19:21:11 <chreekat> i've figured out how to get a list of numbers by asking for input, one at a time (this is exercise 3.10 btw)
19:21:18 <allbery_b> depending on ho convoluted the build rules in configure.in are, it can actually be pretty nasty.  (have seen both easy and unexpectedly *very* difficult)
19:21:23 <dejones> allbery_b, newsham: Symlink really isn't a fix either.  ;)  Configure is doing something wrong, I think that the package maintainer probably needs to fix it...
19:21:33 <olsner> dons: for lack of better ideas, I added my STUArray spectral-norm to http://www.haskell.org/haskellwiki/Shootout/Spectral#STUArray-based_solution
19:21:35 <lambdabot> Title: Shootout/Spectral - HaskellWiki, http://tinyurl.com/5yllr6
19:21:41 <dejones> allbery_b: Yes, the build rules for OpenGL and GLUT packages are not simple.
19:21:44 <chreekat> but i ccan't figure out how to go over the list and print the factorials
19:21:51 <newsham> dejones: its a hack fix, not a proper fix.
19:21:55 <dejones> newsham: yea.
19:22:11 <roconnor> @type mapM
19:22:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:22:16 <newsham> the real fix is not to use software that uses gnu configure ;-)
19:22:17 <allbery_b> yes, as I said in my last message, it's a workaround and someone who knows what's going on inside HOpenGL and/or Debian needs to look into a real fix
19:22:28 <roconnor> @type mapM_
19:22:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
19:23:20 <roconnor> chreekat: mapM and mapM_ will take command with one parameter and apply it to each element of a list in turn.
19:23:38 <roconnor> a command such as print
19:23:39 <dejones> allbery_b: I'm replying to your email suggesting that it may be a bug, so it gets the attention of the package maintainers.
19:24:06 <newsham> ?type mapM_ print [1..10]
19:24:07 <lambdabot> IO ()
19:24:37 <newsham> ?type mapM_ readFile ["a", "b", "c"]
19:24:38 <lambdabot> IO ()
19:24:42 <newsham> ?type mapM readFile ["a", "b", "c"]
19:24:43 <lambdabot> IO [String]
19:25:06 <allbery_b> ha.  the hopengl list just rejected my reply because I'm not a subscriber
19:25:19 <dejones> Anyway, gotta do some work work.  cya allbery_b and newsham.  Thanks for your help.  :)
19:25:25 <allbery_b> np
19:25:26 <dejones> allbery_b: No worries, I subscribed and replied to your mail.
19:25:32 <chreekat> roconnor: thanks. for completeness i'd like to find a solution that only uses things that had been introduced thus far in the tutorial
19:25:35 <dejones> Cya.
19:26:19 <roconnor> chreekat: oh.  I guess you can write your own recursive function that prints a list
19:26:31 <newsham> ?src mapM_
19:26:31 <lambdabot> mapM_ f as = sequence_ (map f as)
19:26:31 <roconnor> for the empty list, do thing (ie return ())
19:26:36 <newsham> ?src sequence_
19:26:36 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:26:52 <roconnor> for a non empty list, print the first element, and then print the tail of the list
19:26:56 <roconnor> recursively
19:27:13 <chreekat> hm ok let me give that a whack
19:27:43 <roconnor> for the empty list, do *nothing* (ie return ())
19:27:46 <roconnor> forgot the no
19:27:58 <roconnor> how embarassing
19:28:02 <chreekat> heh
19:28:34 <roconnor> > do {} :: [()]
19:28:35 <lambdabot>   mueval: Prelude.read: no parse
19:29:05 <roconnor> right, the last line of a do has to be special.
19:30:29 <newsham> > return () : [()]
19:30:30 <lambdabot>   Couldn't match expected type `m ()' against inferred type `()'
19:30:33 <newsham> > return () :: [()]
19:30:34 <lambdabot>   [()]
19:31:11 <chreekat> roconnor: ok, i think i'd tried this before. i think i got tripped up on the empty-list case
19:31:20 <chreekat> specifically i didn't know to return ()
19:31:24 <dons> olsner: what's the status?
19:31:29 <dons> easier to parallelise?
19:31:40 <newsham> do you know return?
19:31:47 <dons> ah, not a parallel version
19:31:48 <roconnor> chreekat: yeah, that's the tricky bit.  I haven't read the tutorial, so I don't know what you are supposed to know. :)
19:31:59 <dons> however, we could parallelise it too :)
19:32:10 <chreekat> i'm not sure the signifcance of return
19:32:17 <dons> olsner: by floating the alloc inside the loop
19:32:17 <chreekat> i think what i tried the first time was print_facts [] = []
19:32:35 <newsham> return takes a "pure" value (like 3) and returns a monadic value (ie. of type IO Int)
19:32:55 <olsner> hmm, I don't know.. ST seems harder to parallelise, IO shouldn't be too hard - just forkIO it and let each thread take a slice of the array or something like that
19:33:07 <nha__> is there a safe way to check if something is undefined
19:33:19 <dons> nha__: heh no!
19:33:22 <dons> there are no safe ways.
19:33:28 <chreekat> newsham: ok, interesting
19:33:30 <nha__> ok
19:33:31 <olsner> but I had a look at the parallel versions on the wiki, and they definitely seem fishy... I'm not sure what they're actually parallelising
19:33:31 <dons> olsner: yeah, forkIO $ runST perhaps ?
19:33:41 <dons> olsner: the 'repetition' loop
19:33:48 <dons> i.e. the thing that says, do this n times
19:33:56 <newsham> chreekat: () is just an empty value of type ()
19:33:56 <dons> one of the pointless busy loops
19:34:05 <newsham> its used sort of like "void" in C and java
19:34:06 <roconnor> @type ()
19:34:07 <lambdabot> ()
19:34:11 <roconnor> > ()
19:34:12 <lambdabot>   ()
19:34:32 <roconnor> @src ()
19:34:32 <lambdabot> data () = ()
19:34:38 <chreekat> ok. i think i was thinking lispy with [] (empty list) being equivalent to nil
19:34:52 <olsner> if I'm reading the code correctly it's doing something n times on the same memory area without synchronization
19:35:00 <ushdf> > iterate (succ) "h"
19:35:01 <lambdabot>       No instance for (Enum [Char])
19:35:01 <lambdabot>        arising from a use of `succ' at <i...
19:35:02 <newsham> if you werent familair with () you could always reutrn a dummy value like [] in its place
19:35:04 <EvilTerran> chreekat, see, they're both kinda similar to lisp's nil
19:35:07 <olsner> doesn't every iteration depend on the results put in the array by the previous iteration?
19:35:22 <ushdf> > succ "h"
19:35:23 <lambdabot>       No instance for (Enum [Char])
19:35:23 <lambdabot>        arising from a use of `succ' at <i...
19:35:25 <olsner> *shouldn't
19:35:32 <ushdf> > pred "h"
19:35:33 <lambdabot>       No instance for (Enum [Char])
19:35:33 <lambdabot>        arising from a use of `pred' at <i...
19:35:43 <ushdf> > > iterate pred 'h'
19:35:44 <lambdabot>   mueval: Prelude.read: no parse
19:35:48 <ushdf> > iterate pred 'h'
19:35:49 <lambdabot>   mueval: Prelude.read: no parse
19:35:49 <lambdabot>  mueval: "hgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIH...
19:35:54 <ushdf> that's better
19:35:58 <EvilTerran> chreekat, the distinction between (:)/head/tail for lists and (,)/fst/snd for pairs only appears because of our type system, which is why we have two constructs analagous to lisp lists
19:35:59 <newsham> > succ 'h'
19:36:00 <lambdabot>   'i'
19:36:04 <newsham> ?type "h"
19:36:05 <lambdabot> [Char]
19:36:07 <ushdf> > iterate succ 'h'
19:36:08 <lambdabot>   "hijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\138\13...
19:36:09 <newsham> ?type 'h'
19:36:10 <lambdabot> Char
19:36:12 <ushdf> :D
19:36:44 <ushdf> > iterate (^ 2) 1
19:36:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:36:49 <ushdf> > iterate (^ 2) 1.1
19:36:50 <lambdabot>   [1.1,1.2100000000000002,1.4641000000000004,2.143588810000001,4.594972986357...
19:37:07 <ushdf> > iterate (^ 2) 2
19:37:08 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
19:37:12 <olsner> dons: oh, and if you're parallelising my version in IO you might as well use the IOUArray version of it
19:37:16 <ushdf> mwahaha
19:37:27 <ushdf> > iterate (^ 65536) 65536
19:37:29 <lambdabot>   [65536,67411401254990734022690651047042454376201859485326882846944915676742...
19:38:28 <newsham> > iterate reverse "radar"
19:38:29 <lambdabot>   ["radar","radar","radar","radar","radar","radar","radar","radar","radar","r...
19:39:58 <EvilTerran> > let cs = map toUpper . filter isAlpha $ "Doc, note I dissent. A fast never prevents a fatness. I diet on cod." in cs == reverse cs
19:39:59 <roconnor> > fix show
19:40:00 <lambdabot>   True
19:40:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:40:06 <EvilTerran> :D
19:40:29 <ushdf> > foldl (*) [1..100]
19:40:30 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
19:40:30 <lambdabot>        arising from a use...
19:40:35 <ushdf> > foldl (+) [1..100]
19:40:37 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
19:40:37 <lambdabot>        arising from a use...
19:40:49 <roconnor> @type foldl
19:40:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:40:56 <dibblego> > foldl (*) [1..100] 1
19:40:56 <ushdf> > foldl (+) 1 [1..100]
19:40:57 <lambdabot>       No instance for (Num [t])
19:40:57 <lambdabot>        arising from a use of `*' at <interact...
19:40:57 <lambdabot>  Terminated
19:41:11 <ushdf> > foldl (+) 0 [1..100]
19:41:12 <lambdabot>   5050
19:41:20 <ushdf> it makes sense!
19:41:53 <ushdf> > foldl (++) 0 [a..z]
19:41:54 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
19:41:56 <newsham> > 1000 + sum [1..100]
19:41:57 <lambdabot>   6050
19:42:02 <newsham> > 100 + sum [1..100]
19:42:03 <lambdabot>   5150
19:42:17 <ushdf> > fold1 (**) 2 [1..100]
19:42:18 <lambdabot>   mueval: Prelude.read: no parse
19:42:23 <ushdf> > fold1 (*) [1..100]
19:42:24 <lambdabot>   mueval: Prelude.read: no parse
19:42:29 <ushdf> > fold1 (*) 0 [1..100]
19:42:30 <lambdabot>   mueval: Prelude.read: no parse
19:42:39 * ushdf gives lambdabot the death stare
19:42:48 <roconnor> > foldl (**) 2 [1..100]
19:42:49 <lambdabot>   Infinity
19:42:50 <newsham> fold-one?
19:43:00 <ushdf> was i typing that
19:43:08 <ddarius> You need a new font.
19:43:09 <roconnor> ushdf is using a courier font
19:43:18 <ushdf> irssi
19:43:32 <ushdf> > foldl (**) 2 [1..2]
19:43:33 <lambdabot>   4.0
19:43:36 <ushdf> > foldl (**) 2 [1..3]
19:43:37 <lambdabot>   64.0
19:43:58 <ushdf> i'm not quite sure what it's doing
19:44:37 <ushdf> > foldr (eq) [1..100]
19:44:37 <lambdabot>   mueval: Prelude.read: no parse
19:44:41 <ushdf> > foldr (eq) 2 [1..100]
19:44:42 <lambdabot>   mueval: Prelude.read: no parse
19:44:45 <ushdf> shut up
19:44:58 <newsham> > foldl (**) n [a,b,c]
19:44:59 <ushdf> > foldr (+) 2 [1..100]
19:44:59 <lambdabot>   ((n**a)**b)**c
19:45:00 <lambdabot>   5052
19:45:06 <electronx> can someone explain how this works in haskell 2 = x??
19:45:06 <dibblego> val x = 2; for(i <- [1..3]) x = x ** i; return x;
19:45:20 <Twey> dibblego: *twitch*
19:45:24 <electronx> (=) 2 x
19:45:32 <olsner> dibblego: that's not haskell1
19:45:38 <electronx> is it the same as (=) x 2
19:45:46 <dibblego> no, but it's "what it is doing", just without the update
19:46:02 <ushdf> > :d
19:46:03 <lambdabot>   mueval: Prelude.read: no parse
19:46:12 <newsham> > ((2**1)**2)**3)
19:46:13 <lambdabot>   mueval: Prelude.read: no parse
19:46:18 <newsham> > ((2**1)**2)**3
19:46:19 <lambdabot>   64.0
19:46:59 <roconnor> > (\x -> let 2=x in x) 2
19:47:00 <lambdabot>   2
19:47:03 <roconnor> > (\x -> let 2=x in x) 3
19:47:05 <lambdabot>   3
19:47:14 <roconnor> ... I'm probably not helping.
19:47:21 <electronx> no
19:47:24 <electronx> :)
19:47:30 <dons> hehe http://kushaldas.in/2008/09/21/my-way-of-testing-language/
19:47:36 <lambdabot> Title: My way of testing language | Kushal , kD & FOSS
19:47:48 <newsham> > let 2 = 5 in 2
19:47:49 <lambdabot>   2
19:47:51 <roconnor> electronx: what is the context for your question?
19:48:03 * ushdf has a problem with that expression
19:48:13 <ushdf> > let 2 = 5 mod 3
19:48:13 <lambdabot>   mueval: Prelude.read: no parse
19:48:19 <ushdf> > let 2 = (5 mod 3)
19:48:21 <lambdabot>   mueval: Prelude.read: no parse
19:48:24 <ushdf> you asshole!!
19:48:29 <roconnor> let ... in
19:48:44 <ushdf> > let 2 = (5 mod 3) in 2
19:48:45 <lambdabot>       No instance for (Num ((a -> a -> a) -> t1 -> t))
19:48:45 <lambdabot>        arising from th...
19:48:50 <electronx> what the
19:48:58 <electronx>  > let 2 = 5 in 4
19:49:08 <electronx>  > let 2 = 5 in 2
19:49:14 <ushdf> i think i killed him
19:49:20 <electronx> yup
19:49:22 <twanvl> > let 2 = 5 in 2
19:49:23 <lambdabot>   2
19:49:33 <roconnor> her
19:49:33 <electronx> > let 2 = 5 in 3
19:49:34 <lambdabot>   3
19:49:45 <ushdf> > let 2 = (5 mod 3) in 3
19:49:46 <lambdabot>       No instance for (Num ((a -> a -> a) -> t1 -> t))
19:49:46 <lambdabot>        arising from th...
19:49:59 <electronx> let 2 = x in x
19:50:02 <ushdf> > let 2 = (foldl (+) 2 [1..100])
19:50:03 <lambdabot>   mueval: Prelude.read: no parse
19:50:05 <electronx> > let 2 = x in x
19:50:06 <lambdabot>   x
19:50:16 <electronx> why is that legal in haskell
19:50:20 <electronx> 2=x
19:50:27 <electronx> lazy eval
19:50:35 <roconnor> let 2 = 5 in 3 will crash if 5 is not equal to 2 when this expression is inspected, and then it can never be inspected.
19:50:45 <roconnor> so it never crashes
19:51:04 <roconnor> > let (Just x) = Nothing in x
19:51:05 <lambdabot>   mueval: Prelude.read: no parse
19:51:06 <lambdabot>  mueval: *** Exception: /tmp/318341684945612...
19:51:06 <electronx> why can't it be inspected?
19:51:11 <ushdf> > map (**) 2 [1..100]
19:51:12 <lambdabot>   Couldn't match expected type `[t1] -> t'
19:51:17 <ushdf> > map (** 2)  [1..100]
19:51:18 <lambdabot>   [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0,121.0,144.0,169.0,196.0,22...
19:51:30 <roconnor> electronx: because no variable occurs on the left hand side.
19:51:38 <ushdf> > map (** 2)  [100..1000]
19:51:39 <lambdabot>   [10000.0,10201.0,10404.0,10609.0,10816.0,11025.0,11236.0,11449.0,11664.0,11...
19:51:44 <electronx> so its not bound to anything?
19:51:46 <ushdf> 10404!!!!
19:51:51 <ushdf> the mark of the beast
19:51:57 <roconnor> electronx: you could say that.
19:52:17 <electronx> roconnor: why does haskell issue an error?
19:52:22 <electronx> doesn't*
19:52:43 <ddarius> > let x@2 = 5 in x
19:52:44 <lambdabot>   mueval: Prelude.read: no parse
19:52:44 <lambdabot>  mueval: *** Exception: /tmp/144226570781039...
19:52:56 <electronx> @type (=)
19:52:57 <lambdabot> parse error on input `='
19:53:03 <electronx> what
19:53:07 <ddarius> = is just syntax
19:53:10 <electronx> @t (=)
19:53:10 <roconnor> electronx: I'd have to read the standard very carefully.
19:53:10 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:53:20 <ushdf> yeah
19:53:28 <ushdf> lambdabot you know me better than anyone
19:53:32 <electronx> lol
19:53:33 <ushdf> > my heart
19:53:34 <lambdabot>   mueval: Prelude.read: no parse
19:53:48 <roconnor> electronx: I'd consider issuing warning, perhaps not an error.
19:53:56 <electronx> ok
19:54:03 <roconnor> because it is the natural extension of a let expression with 0 variables. :)
19:54:06 <EvilTerran> an error would be invalid
19:54:31 <electronx> why?
19:54:34 <newsham> ?let someconst = 1234
19:54:34 <lambdabot>  Defined.
19:54:38 <EvilTerran> a compiler that produced an error would be non-report-compliant
19:54:47 <electronx> english please
19:54:48 <ushdf> ?let me live in peace
19:54:48 <lambdabot>   Parse error
19:55:08 <ushdf> he doesn't have much sympathy for me
19:55:17 <shrughes> ?let    where 1234 = 5
19:55:17 <lambdabot>   Parse error
19:55:19 <shrughes> aw
19:55:34 <shrughes> ?let    where k = 3
19:55:34 <newsham> > ([1,4,9]...)
19:55:37 <lambdabot>   Parse error
19:55:39 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:55:43 <roconnor> heard on #haskell: let motor noise = noise "vrooom! " in motor cycle
19:56:04 <ushdf> how does it know how to continue 1,4,9
19:56:13 <roconnor> 16
19:56:14 <ushdf> can you only use that in squares
19:56:15 <newsham> it has cleverness
19:56:23 <roconnor> @oesis 1,4,9
19:56:24 <lambdabot>  The squares: a(n) = n^2.
19:56:24 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
19:56:27 <EvilTerran> "cleverness"
19:56:30 <Axman6> > [1,4,9...]
19:56:31 <newsham> > ([1,8,27,64]...)
19:56:31 <lambdabot>   mueval: Prelude.read: no parse
19:56:32 <lambdabot>   [1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832...
19:56:34 <shrughes> > let (...)  [] = [0,0..]; (...) xs@(x:_) = scanl (+) x (join (zipWith (-) . tail) xs ...) in ([0,1,4]...)
19:56:35 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
19:56:46 <EvilTerran> > (...) [1,1,2,3]
19:56:47 <lambdabot>   [1,1,2,3,3,1,-4,-13,-27,-47,-74,-109,-153,-207,-272,-349,-439,-543,-662,-79...
19:56:50 <EvilTerran> er
19:56:50 <electronx> sometimes i find things really wierd in haskell
19:56:54 <EvilTerran> > (...) [0,1,1,2,3]
19:56:54 <shrughes> > let (...)  [] = [0,0..]; (...) xs@(x:_) = scanl (+) x (jzipWith (-) (tail xs) xs ...) in ([0,1,4]...)
19:56:56 <lambdabot>   mueval: Prelude.read: no parse
19:56:56 <lambdabot>  Terminated
19:57:07 <Olathe> > sayFunc
19:57:12 <lambdabot>   mueval: Prelude.read: no parse
19:57:12 <shrughes> > let (...)  [] = [0,0..]; (...) xs@(x:_) = scanl (+) x (zipWith (-) (tail xs) xs ...) in ([0,1,4]...)
19:57:14 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
19:57:25 <EvilTerran> ?type (...) -- this is where the magic happens
19:57:26 <lambdabot> forall a. (Num a) => [a] -> [a]
19:57:39 <Axman6> > say
19:57:40 <lambdabot>       Overlapping instances for Show ([Char] -> Expr)
19:57:40 <lambdabot>        arising from a u...
19:57:49 <electronx> whats the @ operator called?
19:57:58 <Olathe> > sayFunc [1,4,9]
19:57:59 <lambdabot>   map (\x -> x^2 + 2*x + 1) [0..2]
19:58:00 <Axman6> > sayFunc [1,8,27]
19:58:00 <electronx> forgot the name
19:58:01 <lambdabot>   map (\x -> 6*x^2 + x + 1) [0..2]
19:58:02 <shrughes> ushdf: given points (0,y0), (1, y1), ..., (n, yn), you can fit an n-degree polynomial, and (...) does just that
19:58:03 <ddarius> electronx: It's syntax.  It is read as "as" usually.
19:58:11 <bd_> > sayFunc [2,3,5,7,11]
19:58:11 <electronx> ok
19:58:12 <lambdabot>   map (\x -> (3*x^4 + (-22)*x^3 + 57*x^2 + (-14)*x + 48) `div` 24) [0..4]
19:58:19 <Olathe> That's basically what (...) does.
19:58:32 <_muke> i read that '@' is read as 'read as'... recursion?
19:58:33 <ushdf> that's amazing
19:58:35 <Olathe> It's a fast way of getting a polynomial.
19:58:37 <newsham> babbage did that once
19:58:38 <shrughes> > ([z]...)
19:58:40 <lambdabot>   [z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,z,...
19:58:46 <Olathe> And just continuing it.
19:58:50 <shrughes> > ([z, z + 1, z + 4]...)
19:58:51 <lambdabot>   [z,z + (z + 1 - z),z + (z + 1 - z) + (z + 1 - z + (z + 4 - (z + 1) - (z + 1...
19:58:55 <Axman6> > sayFunc [1,1,2,3,5,8,13]
19:58:56 <bd_> > ("It was the best of times"...)
19:58:56 <lambdabot>   map (\x -> (5*x^6 + (-93)*x^5 + 665*x^4 + (-2235)*x^3 + 3650*x^2 + (-1992)*...
19:58:57 <lambdabot>       No instance for (Num Char)
19:58:57 <lambdabot>        arising from a use of `...' at <inter...
19:59:06 <Olathe> bd_: Hahaha
19:59:06 <ushdf> >foldl (++) 1 [x]...
19:59:10 <_muke> ...
19:59:13 <ushdf> > foldl (++) 1 [x]...
19:59:14 <lambdabot>   mueval: Prelude.read: no parse
19:59:15 <bd_> hmmmmm
19:59:19 <ushdf> make me "xxxxxxxxxxx"
19:59:25 <ddarius> n points uniquely determine an n-1 degree polynomial
19:59:26 <bd_> > map toEnum ((map fromEnum "It was the best of times")...) :: String
19:59:28 <lambdabot>   mueval: Prelude.read: no parse
19:59:28 <lambdabot>  mueval: "It was the best of times*** Except...
19:59:32 <bd_> :|
19:59:43 <bd_> that needs to be plugged into project gutenberg
19:59:48 <ushdf> it already is
19:59:49 <Axman6> that'd lambdabot for it was the worst of times
20:00:00 <Axman6> that's*
20:00:19 <ushdf> > lambdabot
20:00:20 <lambdabot>   mueval: Prelude.read: no parse
20:00:26 * ushdf takes notes
20:00:56 <ushdf> i wonder if he can pass the mirror test
20:01:36 <shrughes> ?faq Can Haskell pass the mirror test?
20:01:37 <lambdabot> The answer is: Yes! Haskell can do that.
20:01:52 <shrughes> so lambdabot theoretically could..
20:02:16 <ushdf> is haskell turing complete
20:02:36 <Olathe> @faq Can Haskell complete Turing ?
20:02:37 <lambdabot> The answer is: Yes! Haskell can do that.
20:02:56 <Olathe> @faq Can Haskell complete me ?
20:02:56 <lambdabot> The answer is: Yes! Haskell can do that.
20:02:57 <ushdf> ([.]...)
20:03:01 <ushdf> > ([.]...)
20:03:02 <lambdabot>   mueval: Prelude.read: no parse
20:03:05 <roconnor> ushdf: haskell has fix
20:03:09 <roconnor> @type fix
20:03:10 <lambdabot> forall a. (a -> a) -> a
20:03:11 <ushdf> > ([m]...)
20:03:12 <lambdabot>   [m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,m,...
20:03:16 <ushdf> > ([o]...)
20:03:17 <lambdabot>   [o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,...
20:03:20 <ushdf> > ([ah]...)
20:03:21 <lambdabot>   mueval: Prelude.read: no parse
20:03:29 <newsham> ?type m
20:03:30 <lambdabot> Expr
20:03:34 <roconnor> > ("ah"...)
20:03:35 <lambdabot>       No instance for (Num Char)
20:03:36 <lambdabot>        arising from a use of `...' at <inter...
20:03:42 <ushdf> > ([a]...)
20:03:44 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
20:03:48 <ushdf> > ([y]...)
20:03:49 <lambdabot>   [y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,y,...
20:03:52 <Olathe> > iterate (\x -> x ++ head x) [omg]
20:03:53 <bd_> > map toEnum ((map fromEnum "ah")...) :: String
20:03:53 <lambdabot>   mueval: Prelude.read: no parse
20:03:54 <lambdabot>   "ahov}\132\139\146\153\160\167\174\181\188\195\202\209\216\223\230\237\244\...
20:04:03 <Olathe> > iterate (\x -> x ++ head x) [x]
20:04:04 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
20:04:04 <lambdabot>        Expect...
20:04:07 <ushdf> > ([r]...)
20:04:08 <lambdabot>   [r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,r,...
20:04:10 <ushdf> > ([o]...)
20:04:11 <lambdabot>   [o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,...
20:04:12 <ushdf> > ([a]...)
20:04:14 <lambdabot>   [a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,a,...
20:04:16 <ushdf> > ([d]...)
20:04:17 <lambdabot>   [d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,d,...
20:04:17 <shrughes> /msg lambdabot > ([x]...)
20:04:23 <bd_> :t (...)
20:04:24 <lambdabot> forall a. (Num a) => [a] -> [a]
20:04:31 <Olathe> > (\x -> x ++ head x) [x]
20:04:32 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
20:04:32 <lambdabot>        Expect...
20:04:33 <electronx> does haskell have arrays
20:04:34 <electronx> ?
20:04:37 <shrughes> yes
20:04:41 <electronx> how?
20:04:43 <ushdf> no
20:04:48 <Olathe> > (\x -> head x:x) [x]
20:04:49 <ushdf> haskell only works on huge blocks of data
20:04:50 <lambdabot>   [x,x]
20:04:52 <Axman6> Olathe: head s wouldn't be a list
20:04:58 <Olathe> > iterate (\x -> head x:x) [x]
20:04:59 <lambdabot>   [[x],[x,x],[x,x,x],[x,x,x,x],[x,x,x,x,x],[x,x,x,x,x,x],[x,x,x,x,x,x,x],[x,x...
20:05:01 <ushdf> and even then it asks a lot of obnoxious questions
20:05:03 <Olathe> Ahh, yes :)
20:05:25 <bd_> electronx: Data.Array :)
20:05:29 <electronx> ah
20:05:37 <Olathe> @pl iterate (\x -> head x:x) [x]
20:05:38 <lambdabot> iterate ((:) =<< head) [x]
20:05:39 <bd_> actually it has a few variants too
20:05:42 <electronx> does it have stuff like foldr defined?
20:05:47 <bd_> Data.UArray, Data.STArray etc
20:05:55 <bd_> I think there's a newarray package for that
20:06:16 <electronx> also can you store any type in the array?
20:06:32 <electronx> UArray a?
20:06:47 <Axman6> :t UArray
20:06:48 <lambdabot> Not in scope: data constructor `UArray'
20:06:49 <bd_> electronx: yes, the basic arrays store pointers to boxed values; there's also Unpacked Arrays (UArray) which can only hold certain types (and not _|_)
20:06:51 <Axman6> bah
20:07:10 <Axman6> > _|_
20:07:11 <lambdabot>   mueval: Prelude.read: no parse
20:07:19 <Axman6> > (_|_)
20:07:19 <bd_> _|_ is notation, not syntax :)
20:07:20 <lambdabot>   mueval: Prelude.read: no parse
20:07:29 <Axman6> :\
20:07:31 <bd_> _|_ includes infinite loops, division by zero, 'undefined', etc
20:07:46 <Olathe> > div 1 0
20:07:47 <lambdabot>   mueval: Prelude.read: no parse
20:07:47 <lambdabot>  mueval: *** Exception: divide by zero
20:07:56 <electronx> sometimes i find haskell confusing
20:08:04 <Axman6> > let f x = x:f x in f 1
20:08:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
20:08:06 <ddarius> electronx: See the fourth slide here: http://www.galois.com/~dons/slides/08-07-stewart.pdf
20:08:11 <electronx> but i'm sticking with it
20:08:12 <lambdabot> Title: cache:http://www.galois.com/~dons/slides/08-07-stewart.pdf - Google Search
20:08:19 <electronx> ok
20:08:35 <Olathe> That's an interesting title to a PDF.
20:10:19 <electronx> i like the what Simon said about haskell: if we keep adding features haskell may get too complicated for any mortal to maintain
20:10:29 <electronx> :)
20:10:52 <newsham> mortals use coq all the time
20:10:58 <electronx> coq?
20:11:11 <roconnor> @where coq
20:11:11 <lambdabot> http://coq.inria.fr/
20:11:18 <Olathe> That's a nice last page.
20:11:48 <roconnor> coq is simpler than GHC haskell.
20:12:09 <roconnor> at least coq's kernel
20:12:11 <electronx> lol
20:12:12 <roconnor> ...
20:12:20 <roconnor> maybe not coq itself.
20:12:29 <ddarius> Also Simon said "maintain" not "use"
20:12:35 <newsham> chess is simpler than ghc
20:12:39 <roconnor> actually, coq as a whole may be too complicated for any mortal to maintain
20:12:40 <newsham> at least the rules part
20:13:16 <electronx> maybe we should be researching genetic manipulation
20:13:22 <electronx> to make smarter people
20:13:25 <ddarius> "we" are
20:13:54 <roconnor> electronx: AI FTW
20:14:07 <electronx> AI in my opinion is a dead end road
20:14:22 <roconnor> A machine will pass the Turing test within 21 years.
20:14:23 <electronx> maybe for games and stuff but not real intelligence
20:14:24 <ddarius> All roads are dead end roads.
20:14:42 <ddarius> The Turing test isn't really that great.
20:14:43 <Twey> Heh
20:15:06 <Twey> People had trouble telling if Eliza was real or not...
20:15:07 <electronx> ddarius: i agree
20:15:14 <roconnor> and it will be solar powered :)
20:15:23 <electronx> ddarius: chat bots have no real ai in them
20:15:29 <roconnor> (possibly indirectly solar powered)
20:15:38 <electronx> just a whole bunch of speech rules
20:16:31 <electronx> far from real ai
20:16:39 <ddarius> roconnor: Almost everything on the surface of the earth is indirectly solar powered.
20:17:10 <roconnor> ddarius: For the purposes of this argument, I consider fossil fuels not to be solar power.
20:17:15 <electronx> lol
20:17:34 <electronx> i'm very glad
20:17:59 <roconnor> although I would consider surface geothermal to be solar power
20:18:10 <roconnor> to give you an idea what class of energy I'm considering.
20:18:30 <ddarius> roconnor: Perhaps the word you want is "sustainable"
20:18:31 <roconnor> deep geothermal wouldn't be solar power by any measure.
20:18:51 <ivanm> where's dcoutts home page with all his haskell snippets? I can't seem to recall the URL, but there's a file there that I wanted :s
20:18:51 <roconnor> ddarius: perhaps
20:19:00 <ddarius> roconnor: Does nuclear count?
20:19:27 <roconnor> not as solar power.
20:20:21 <roconnor> I'd identify sustainable with the class of energy I'm talking about (which excludes nuclear), but I'm not sure everyone would agree with this definition of sustainable.
20:21:11 <roconnor> not that I'm all that opposed to nuclear.
20:21:21 <roconnor> it's better than oil and coal.
20:22:28 <ivanm> roconnor: though it's less efficient
20:23:14 <roconnor> ivanm: meh.  Anything other than an antimatter reactor is inefficient. :)
20:23:28 <ivanm> roconnor: well, there's always fusion...
20:23:28 <Twey> And a heater.
20:23:30 <roconnor> Breader reactors are reasonable IIRC.
20:23:35 <bd_> antimatter is very much not a sustainable resource :)
20:23:41 <ivanm> tokomak reactor!
20:23:51 <roconnor> bd_: LOL
20:24:00 <Twey> bd_: Eh, half the universe is made up of it!  :-P
20:24:11 <bd_> Twey: or /is/ it?
20:24:47 <roconnor> only the LHC knows.
20:25:00 <noZone> Fractured rock geothermal is baseline, sustainable and substantial.
20:25:16 <roconnor> I'd bet against CPT symetry.
20:25:27 <roconnor> Symmetry has let me down too many times.
20:26:50 <roconnor> stupid Yang-Lee.
20:27:25 <lispy> the LHC is offline for another 2 months though
20:27:30 <lispy> Already needs repairs :(
20:28:02 <roconnor> I guess it is to be expected.
20:28:21 <bd_> Yeah, a black hole passing through the magnet would cause a lot of damage, I'd expect.
20:33:04 <lispy> bd_: yeah, but the cause wasn't even something cool like that: http://news.bbc.co.uk/1/hi/sci/tech/7626944.stm
20:33:06 <lambdabot> Title: BBC NEWS | Science/Nature | Hadron Collider halted for months
20:33:18 <bd_> lispy: are you sure?
20:33:52 <bd_> black hole -> electrical connection breaks -> quench
20:34:50 <roconnor> the black hole must have been traveling back in time from the future when the LHC was actually colliding particles.
20:35:02 <roconnor> now that is awesome.
20:35:23 <roconnor> maybe the LHC will cause the earth to be sucked into a black hole in the past.
20:37:11 <newsham> just in case, keep an eye on it: http://www.cyriak.co.uk/lhc/lhc-webcams.html
20:37:12 <lispy> ?google lookMb
20:37:16 <lambdabot> Title: lhc
20:37:17 <lambdabot> No Result Found.
20:37:24 <lispy> ?hoogle lookMb
20:37:24 <lambdabot> No results found
20:38:11 <lispy> why are the red lights going off in the webcam?
20:38:21 <lispy> and now the webcam is offline
20:38:23 <lispy> is this a joke?
20:38:48 <dmwit> Your powers of deduction astound me... =P
20:38:56 <lispy> hehe, now I watched the whole thing
20:39:20 <lispy> Sorry, I just saw a few frame before as I moved around my computer to different desktops...that's awesome
20:39:44 <dons> oh, so the world didn't end?
20:39:49 <dons> :)
20:39:55 * dmwit makes no promises
20:40:04 <noZone> Is the lhc a Lunatic Haskell Compiler?
20:40:18 <dons> oh. whoa. we really should claim the 'lhc'...
20:40:23 <ivanm> dons: sure it did... except that the scientists destroyed it about an hour before they turned the LHC on just so they could say that the LHC didn't destroy it!
20:40:32 <lispy> noZone: yeah, it creates backholes and prints <<loop>> when they appear
20:40:35 <newsham> liverpool haskell compiler?
20:40:47 <ahr_> does anyone know if parsec can play nicely with utf8 input?
20:40:52 <newsham> let hole = fix id
20:41:14 <dons> ahr_: just preprocess the stream with utf8-string
20:41:19 <dons> and you will be good.
20:41:20 <newsham> ahr: you would probably convert utf8 to unicode characters first
20:41:29 <lispy> little haskell compiler comes to mind, just a minimal compiler with BSD license for people that want to see how the language works
20:41:33 <ahr_> dons, ah excellent, will try that
20:41:37 <noZone> What does a black hole monad look like anyway?
20:41:48 <lispy> noZone: there is no return
20:41:50 <newsham> nozone: IO.  there's no escaping
20:42:01 <newsham> (except unsafePerform* .... doh)
20:42:09 <roconnor> newtype BlackHole a = ()
20:42:34 <roconnor> return a = ()
20:42:48 <roconnor> a >>= f = ()
20:42:53 <noZone> I like!
20:42:57 <roconnor> fail a = ()
20:43:13 <roconnor> runBlackHole _ = ()
20:43:14 <lispy> of course, that's not actually valid haskell...
20:43:26 <roconnor> it isn't?
20:43:33 <lispy> your newtype is wrong :)
20:43:39 <roconnor> oh right
20:43:43 <chrisdone> type Cthulhu a = ()
20:43:49 <roconnor> newtype BlackHole a = BlackHole ()
20:43:58 <bd_> data BlackHole a = BlackHole
20:44:04 <lispy> roconnor: but then you miht as well drop the () from the RHS
20:44:13 <bd_> lispy: you can't do that with a newtype ofc :)
20:44:20 <lispy> ah
20:44:23 <lispy> right
20:44:28 <lispy> because the newtype doesn't create anything
20:44:34 <chrisdone> #haskell: spoiling jokes since '05
20:44:36 <lispy> Well, it creates a new type, but not a new value
20:46:37 <lispy> runBlackHole (return Light) -- sorry not even this will escape :(
20:46:55 <ahr_> dons, excellent, that did the trick
20:47:04 <bd_> This looks like a job for unsafeEscapeBlackHole !
20:48:05 <bd_> hmm
20:48:25 <bd_> data WhiteHole a where WhiteHole :: (BlackHole a -> a) -> WhiteHole a
20:49:43 <JaMe[Dev]> hi
20:49:51 <JaMe[Dev]> away..
20:49:53 <ddarius> chrisdone: '05 ?
20:50:58 <lispy> ?djinn BlackHole a -> a
20:50:58 <lambdabot> Error: Undefined type BlackHole
20:51:10 <lispy> ?djinn help
20:51:10 <lambdabot> -- f cannot be realized.
20:51:21 <newsham> the regex-dna bench can be trivially parallelized by variants
20:51:27 <lispy> ?help djinn
20:51:27 <lambdabot> djinn <type>.
20:51:27 <lambdabot> Generates Haskell code from a type.
20:51:27 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
20:51:32 <newsham> mapM_ (printVars s2 s3) variants     is independant for each variant
20:51:50 <chrisdone> ?djinn a -> a
20:51:51 <lambdabot> f a = a
20:52:02 <scodil> ?djinn (a->b) -> Bool
20:52:02 <lambdabot> f _ = False
20:52:17 <lispy> ?djinn-data BlackHole a = BlackHole
20:52:17 <lambdabot> Unknown command, try @list
20:52:20 <chrisdone> ?djinn Maybe a -> a
20:52:20 <lambdabot> -- f cannot be realized.
20:52:25 <chrisdone> ;_;
20:52:39 <lispy> ?list
20:52:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:52:59 <lispy> ?djinn-add BlackHole a = BlackHole
20:53:00 <lambdabot> Cannot parse command
20:53:09 <lispy> ?djinn-add data BlackHole a = BlackHole
20:53:12 <chrisdone> ?djinn b -> ([a] -> b) -> [a] -> b
20:53:12 <lambdabot> Error: Undefined type []
20:53:25 <chrisdone> mmkay
20:53:28 <lispy> ?djinn BlackHole a -> a
20:53:28 <lambdabot> -- f cannot be realized.
20:53:35 <newsham> heh, the python regex-dna bench is 3x faster than the haskell one.
20:53:41 <newsham> eek
20:53:59 <chrisdone> newsham: link?
20:53:59 <lispy> That's unusual
20:54:04 <newsham> http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=python&id=1
20:54:06 <lambdabot> Title: regex-dna Python program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langu ..., http://tinyurl.com/3gvqw5
20:54:08 <dons> newsham: different regex engine.
20:54:11 <chrisdone> cheers big ears
20:54:12 <newsham> *nod*
20:54:13 <dons> it's all in the regex engine, this benchmark.
20:54:34 <newsham> but at least its trivially parallelizable
20:54:35 <chrisdone> yeah, it's a bit irrelevant
20:54:40 <newsham> so could get much faster on quad core
20:54:54 <newsham> but a new engine would be a huge win, too.
20:55:07 <dons> ok. just parallelise it
20:55:14 <tsar> @seen tsar
20:55:14 <lambdabot> You are in #haskell. I last heard you speak just now.
20:55:22 <tsar> @seen newsham
20:55:22 <lambdabot> newsham is in #haskell-blah and #haskell. I last heard newsham speak 27s ago.
20:56:17 <newsham> this would be a good one for `par` which i need to read up on
20:56:27 <chrisdone> @go haskell par
20:56:29 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html
20:56:29 <lambdabot> Title: 8.17.ï¿½Concurrent and Parallel Haskell
20:58:11 <lispy> dons: Oh, I do hope you learn a lot about iteratees by the darcs sprint.  They sound like a cool way to redo the darcs IO
20:59:38 <dons> lispy: yeah, i want to have a prototype bytestring iterator by the end of icfp.
21:00:05 <dons> lispy: do you have the canonical link for the darcs sprint?
21:00:20 <dons> need to drop it into my calendar.
21:00:23 <newsham> doesnt hyena have a bytestring fold enuemrator in it?
21:00:23 <lispy> link?  Hmm...I can check kowey's emails
21:00:27 <dons> newsham: right.
21:01:16 <lispy> dons: http://wiki.darcs.net/index.html/Sprints
21:01:17 <lambdabot> Title: Sprints - DarcsWiki
21:01:21 <dons> gracias
21:01:22 <lispy> dons: I found that from kowey's blog
21:01:34 <lispy> dons: this is also good: http://koweycode.blogspot.com/2008/09/darcs-hacking-sprint-25-26-october-2008.html
21:01:38 <lambdabot> Title: koweycode: darcs hacking sprint (25-26 October 2008), http://tinyurl.com/4rsmwx
21:02:57 <dons> ok. in my calendar now.
21:03:01 <dons> going to be a busy week.
21:03:40 <chrisdone> does parsec3 use bytestring?
21:04:56 <dons> i think it can.
21:05:00 <dons> i'm not sure it is efficient.
21:05:06 <dons> btw, http://okmij.org/ftp/Haskell/Iteratee/
21:05:11 <lambdabot> Title: Index of /ftp/Haskell/Iteratee
21:05:13 <dons> we have some sketched code to work from.
21:06:33 <chrisdone> cool
21:06:54 <ddarius> 10 â â
21:07:11 <dons> ddarius has fun with unicode.
21:07:23 <chrisdone> â¥ â¤
21:07:25 <lispy> dons: what day am I scheduled again?
21:07:44 <lispy> dons: the 7th of oct?
21:08:04 <lispy> I need to wrote my presentation :)
21:08:23 <lispy> write*
21:09:05 <dons> checking.
21:09:22 <dons> 7th or 14th. both are free.
21:13:00 <lispy> dons: moving to the 14th would actually be nice for me
21:13:20 <lispy> dons: the week before the 7th is going to be hecktic
21:14:11 <dons> ok.
21:14:18 <dons> it is done.
21:14:22 <dons> closer to the hackathon is good too.
21:14:28 <lispy> wow, that's I'll update my calendar
21:14:32 <lispy> er thanks*
21:16:53 <dons> :)
21:20:39 <chrisdone> I have a little module to query google and return a list of tuples Maybe [(String,String)] of url and description. bad idea to put this on hackage?
21:28:15 <lispy> ?hoogle [[a]] -> [a] -> Bool
21:28:16 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
21:28:16 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
21:28:16 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
21:28:28 <lispy> Um, none of those match
21:28:33 <lispy> Silly Hoogle
21:29:40 <BMeph> ?hoogle [a] -> a -> Bool
21:29:40 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
21:29:40 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
21:29:40 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
21:30:28 <lispy> elem has the right signature but not the right behavior
21:30:32 * BMeph shrugs
21:31:40 <lispy> :t \xs y -> any (\x -> x `isSuffixOf` y) xs
21:31:42 <lambdabot> forall a. (Eq a) => [[a]] -> [a] -> Bool
21:31:47 <lispy> That's what I had in mind
21:31:59 <Twey> It auto-delists it?
21:32:02 <Twey> Hmm
21:32:11 <Twey> Then...
21:32:21 <Twey> ?hoogle [[[a]]] -> [a] -> Bool
21:32:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
21:32:22 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
21:32:22 <lambdabot> System.Console.GetOpt Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a
21:32:36 <Twey> Er, what
21:34:41 <noZone> haskell :: abstraction -> distraction {- as in "driven to" -}
21:35:31 <stulli> Does anybody know about this cabal error? "Could not find module `Data.Tree': it is a member of package containers-0.1.0.2, which is hidden"
21:35:53 <glguy> stulli: You'll need to add containers to the build-depends
21:36:06 <stulli> glguy: how do i do that?
21:36:29 <glguy> stulli: look in the *.cabal file
21:40:00 <lispy> ?index isSuffixOf
21:40:00 <lambdabot> Data.List
21:40:08 <lispy> I thought that was in Prelude
21:40:27 <stulli> glguy: i got it now, thanks
21:40:27 <lispy> was it just moved at some point?
21:41:22 <Twey> is*fixOf have always been in Data.List, AFAIK
21:43:09 <lispy> huh, the way I read the h98 report I thought it was in prelude
21:43:24 <lispy> and then I thought I even found it in prelude, but maybe my ghci setting load Data.List
21:45:10 <ddarius> http://haskell.org/onlinereport/list.html
21:45:11 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
21:45:23 <ddarius> isInfixOf is not a standard Haskell 98 function
21:45:45 <lispy> right, but isSuffixOf and isPrefixOf both are
21:46:40 * ddarius doesn't understand why the "recitations" of course 6.302 refer to course 6.302
21:57:50 <hackage> Uploaded to hackage: ircbouncer 0.1
21:57:50 <hackage> Uploaded to hackage: lojban 0.1
22:12:49 <lispy> :t any
22:12:51 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:13:38 <lispy> :t \f y -> any (any f) y
22:13:39 <lambdabot> forall a. (a -> Bool) -> [[a]] -> Bool
22:13:54 <Olathe> @src pi
22:13:55 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:14:16 <lispy> the any (any ..) pattern is a bit odd to me, but I guess it's just a nested test
22:17:00 <ac> Axman6: you around?
22:17:57 <Olathe> Do any of the lists have any elements where...
22:18:01 <Olathe> Or something like that.
22:18:06 <Cale> lispy: you're asking if any of the lists have any element for which the test succeeds :)
22:18:16 <Cale> yeah :)
22:18:34 <Olathe> > any (any (==2)) $ map repeat [1..]
22:18:49 <lambdabot>   thread killed
22:20:43 <ozy`> hey folks, anyone recommend a particular indent size for cases where it doesn't really matter?
22:21:36 <Olathe> I like 4 spaces.
22:26:02 <Olathe> > iter
22:26:03 <lambdabot>   mueval: Prelude.read: no parse
22:39:31 <Axman6> ac: o/
22:41:19 <Axman6> ac: how're you going with those problems?
22:50:45 <ac> working on 13
22:50:50 <Olathe> > [(x, y) | x <- [1..], y <- [1..]]
22:50:52 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
22:51:20 <Axman6> which one was that?
22:51:34 <Olathe> > map (\x -> (\y -> (x, y)) [1..]) [1..]
22:51:36 <lambdabot>   [(1,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
22:51:50 <Olathe> > map (\x -> map (\y -> (x, y)) [1..]) [1..]
22:51:52 <lambdabot>   [[(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12...
22:51:55 <ac> don't quite see how it's possible, but I'm not willing to @src ap
22:51:56 <Axman6> [(x, y) | x <- [1..], y <- [x..]]
22:52:06 <Axman6> > [(x, y) | x <- [1..], y <- [x..]]
22:52:06 <Olathe> > map (\x -> map (\y -> (x, y)) [0..]) [0..]
22:52:08 <lambdabot>   [[(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11)...
22:52:08 <lambdabot>  Terminated
22:52:10 <ac> Axman6: it's ap
22:52:18 <visof> where can find isLower?
22:52:27 <Olathe> > let iter=g 1 where g n a=(let (i,j)=p 0 n in a!!i!!j):g(n+1)a;p::(Bits a,Integral a)=>a->a->(a,a);p r n=(if n.&.1==0 then p(r+1) else (,)r)(shiftR n 1) in iter $ map (\x -> map (\y -> (x, y)) [0..]) [0..]
22:52:29 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),(0...
22:53:09 <Olathe> > let iter=g 1 where g n a=(let (i,j)=p 0 n in a!!i!!j):g(n+1)a;p::(Bits a,Integral a)=>a->a->(a,a);p r n=(if n.&.1==0 then p(r+1) else (,)r)(shiftR n 1) in any (==2) $ iter $ map repeat [1..]
22:53:11 <lambdabot>   True
22:53:12 <Axman6> yeah, i think Cale told me that. talk to him, he'll help you out. he helped me a lot without giving (many) answser
22:53:34 <Axman6> > [(x, y) | x <- [1..], y <- [1..x]]
22:53:35 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5...
22:53:42 <Olathe> Take that, countably infinite lists of countably infinite lists !
22:53:47 <Axman6> > [ x+y | x <- [1..], y <- [1..x]]
22:53:49 <lambdabot>   [2,3,4,4,5,6,5,6,7,8,6,7,8,9,10,7,8,9,10,11,12,8,9,10,11,12,13,14,9,10,11,1...
22:54:15 <Axman6> > [ x-y | x <- [1..], y <- [1..x]]
22:54:16 <lambdabot>   [0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0,6,5,4,3,2,1,0,7,6,5,4,3,2,1,0,8,...
22:54:34 <Olathe> > let iter=g 1 where g n a=(let (i,j)=p 0 n in a!!i!!j):g(n+1)a;p::(Bits a,Integral a)=>a->a->(a,a);p r n=(if n.&.1==0 then p(r+1) else (,)r)(shiftR n 1) in any (==1000) $ iter $ map repeat [1..]
22:54:43 <Olathe> That might take a while
22:54:50 <lambdabot>   thread killed
22:55:07 <Olathe> But it actually works.
22:55:28 <Olathe> I suppose there might be issues with Int, though.
22:57:55 <hackage> Uploaded to hackage: kibro 0.1
22:57:55 <hackage> Uploaded to hackage: goa 3.0.2
23:01:29 <Axman6> oh man, ac, that one's way harder than a 6 btw
23:02:23 <ac> Axman6: wow is this actually correct?
23:02:42 <ac> Axman6: apple ma mf = banana (\x -> banana (unicorn . x) ma) mf
23:03:00 <ac> what the heck is apple used for?
23:03:20 <Axman6> apple (Just 1
23:03:23 <Axman6> rawr
23:03:38 <Axman6> apple (Just 1) (Just (+2)) = Just 3
23:04:11 <Axman6> yeah that's slightly different to what i have, but i'm pretty sure they're the same
23:04:19 <ac> it type checks
23:04:20 <Axman6> apple ma mf = banana (\x -> banana (\f -> unicorn (f x) ) mf) ma
23:05:43 <ac> What's a valid use for a value of type: (Monad m) => m (a -> b) -- ?
23:06:03 <lispy> :t return (+1)
23:06:04 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m (a -> a)
23:06:23 <lispy> ac: make more sense?
23:06:35 <ac> I understand the type... just when do you use it
23:06:35 <Axman6> > return fromJust :: Maybe
23:06:36 <lambdabot>       `Maybe' is not applied to enough type arguments
23:06:36 <lambdabot>      Expected kind `?',...
23:06:42 <Axman6> bah
23:06:45 <Axman6> > return fromJust :: Maybe a
23:06:46 <lambdabot>   Couldn't match expected type `a1'
23:06:51 <lispy> > do f <- return (+1); return (f 1) :: [Int]
23:06:53 <lambdabot>   [2]
23:07:24 <visof> which module can i find "ord" function ?
23:07:43 <Olathe> @index ord
23:07:43 <lambdabot> Data.Char
23:07:46 <Olathe> That one.
23:07:50 <ac> ok, moppy is obviously mapM. That should be easy
23:08:11 <Axman6> heh, looks easy, yes ;)
23:08:40 <Axman6> Cale sais it's easier if you fo sausage first
23:09:05 <Axman6> said*
23:09:50 <ac> heh. sausage.
23:10:10 <Olathe> The first one is easy: furry f as = []
23:10:43 <ivanm> @seen matthew-_
23:10:43 <lambdabot> matthew-_ is in #ghc, #haskell-blah and #haskell. I last heard matthew-_ speak 7h 15m 30s ago.
23:10:45 <Olathe> The second one is also easy: furry f a = Nothing
23:10:55 <ivanm> matthew-_: announcement sent!
23:11:34 <Axman6> furry's (>>=) right?
23:11:43 <Olathe> It's fmap
23:11:58 <Axman6> hmm, ok
23:12:16 <ac> Axman6: yeah of course...: moppy l f = sequence $ map f l
23:12:27 <ac> er, sausage
23:12:38 <Axman6> hehe
23:12:48 <Axman6> yeah, just need to figure out sausage now
23:13:46 <ac> or 'sausage . (flip map)'. I like the point free style way too much
23:13:58 <Axman6> i really don't
23:14:11 <Olathe> You'll lose your evil hatred of it soon.
23:14:32 <Axman6> my rule is, if you have more than one argument to the function, you should name them
23:14:45 <Olathe> f bob sue = ...
23:15:30 <Axman6> it's just showing off most of the time. I much prefer readable, understandable code to look how cool i am code ;)
23:15:42 <Olathe> Oh, sure.
23:15:49 <Olathe> But sometimes it makes things readable.
23:16:03 <ushdf> code is cooler when it's thrown about like cubism
23:16:30 <Olathe> double = map (*2) is a bit easier to read than double xs = map (\x -> x*2) xs
23:16:38 <lispy> Axman6: I think that's a good rule about pointfree
23:16:53 <Axman6> Olathe: yeah, but that's only got one argument ;)
23:16:58 <visof> > let encode n xs = [ chr ((ord x) + n) | x <- xs] in encode 3 "haskell is fun"
23:16:59 <lambdabot>   "kdvnhoo#lv#ixq"
23:17:07 <Axman6> so double = map (*2) is very readable
23:17:15 <Twey> Point-free is good when it *improves* readability
23:17:20 <Twey> Not when it detracts from it
23:17:22 <Olathe> mult xs ys = zipWith (*) xs ys
23:17:27 <Olathe> mult = zipWith (*)
23:17:35 <Olathe> I like the second one.
23:17:46 <lispy> ?src zip
23:17:47 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
23:17:47 <lambdabot> zip _      _      = []
23:17:51 <Axman6> Olathe: that's pretty clear too, as long as you know what xipWith does
23:17:54 <Axman6> zip*
23:17:55 <Olathe> Sure.
23:18:06 <lispy> er, weird, I expected zip = zipWith (,)
23:18:14 <Olathe> Or, rather...
23:18:28 <Olathe> mult xs ys = zipWith (\x y -> x*y) xs ys
23:18:32 <Olathe> Eww
23:18:49 <Axman6> that makes it less readable imo
23:19:28 <Olathe> > zipWith (,) [1..] [2, 4..]
23:19:30 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20),(11,22)...
23:19:42 <Axman6> dotP = sum $ zipWith (*) -- i think that's fine too
23:20:04 <Olathe> > sum []
23:20:05 <lambdabot>   0
23:20:38 <Axman6> it's just when you start using flip because you don't want to name things, things get hard to understand
23:20:40 <Olathe> @pl n->1%(2^n)
23:20:40 <lambdabot> (line 1, column 2):
23:20:40 <lambdabot> unexpected ">" or "-"
23:20:40 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
23:20:45 <Olathe> @pl \n->1%(2^n)
23:20:45 <lambdabot> (1 %) . (2 ^)
23:21:16 <Olathe> > sum $ iterate (/2) (1%1)
23:21:58 <Olathe> @hot
23:21:58 <lambdabot> Maybe you meant: ft let show vote what yow
23:22:00 <Olathe> @bot
23:22:01 <lambdabot> :)
23:22:27 <Axman6> Olathe: % == `mod`?
23:22:35 <Olathe> No.
23:22:39 <Olathe> > 5%10
23:22:43 <lambdabot>   1%2
23:22:44 <Olathe> If the bot'll wake up.
23:22:48 <Axman6> ah
23:22:50 <Olathe> It's a fracton.
23:22:52 <Olathe> fraction
23:23:05 <ivanm> Axman6: mod == mod ;-)
23:23:10 <Olathe> > iterate (/2) (1%1)
23:23:11 <ivanm> this isn't C...
23:23:12 <lambdabot>   [1%1,1%2,1%4,1%8,1%16,1%32,1%64,1%128,1%256,1%512,1%1024,1%2048,1%4096,1%81...
23:23:50 <Olathe> > scanl1 (+) $ iterate (/2) (1%1)
23:23:51 <Axman6> @index (%)
23:23:51 <lambdabot> Data.Ratio
23:23:51 <lambdabot>   [1%1,3%2,7%4,15%8,31%16,63%32,127%64,255%128,511%256,1023%512,2047%1024,409...
23:24:01 <Olathe> > scanl1 (+) $ iterate (/2) (1.0)
23:24:03 <lambdabot>   [1.0,1.5,1.75,1.875,1.9375,1.96875,1.984375,1.9921875,1.99609375,1.99804687...
23:25:19 <Olathe> > let sums = scanl1 (+) $ iterate (/2) (1.0) in dropWhile (\(a,b) -> a /= b) $ zip sums (tail sums)
23:25:21 <lambdabot>   [(2.0,2.0),(2.0,2.0),(2.0,2.0),(2.0,2.0),(2.0,2.0),(2.0,2.0),(2.0,2.0),(2.0...
23:25:22 <ac> Axman6: check this out... :-P
23:25:25 <ac> @src ap
23:25:26 <lambdabot> ap = liftM2 id
23:25:34 <Olathe> > let sums = scanl1 (+) $ iterate (/2) (1.0) in fst $ head $ dropWhile (\(a,b) -> a /= b) $ zip sums (tail sums)
23:25:36 <lambdabot>   2.0
23:25:37 <Axman6> and that's banana2?
23:25:48 <ac> Axman6: that's apple
23:25:55 <Axman6> ah
23:26:08 <Axman6> i mean lisfM2
23:26:23 <Olathe> @pl (\(a,b) -> a /= b)
23:26:24 <lambdabot> uncurry (/=)
23:26:35 <Axman6> @src curry
23:26:35 <lambdabot> curry f x y = f (x, y)
23:26:45 <Axman6> @src uncurry
23:26:45 <lambdabot> uncurry f p = f (fst p) (snd p)
23:27:18 <Axman6> what's the point of currying anyway?
23:27:20 <slavik> why are the different operators for exponentiation? ^ and **, why is there a difference? Couldn't one of them just act on Num?
23:27:35 <Axman6> :t (^)
23:27:38 <Axman6> :t (**)
23:27:38 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
23:27:39 <lambdabot> forall a. (Floating a) => a -> a -> a
23:27:57 <Axman6> @src (^)
23:27:57 <lambdabot> x ^ 0            =  1
23:27:57 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:27:57 <lambdabot>   where f _ 0 y = y
23:27:57 <lambdabot>         f x n y = g x n
23:27:57 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:27:59 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:28:01 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:28:02 <Axman6> @src (**)
23:28:03 <lambdabot> Source not found. Are you on drugs?
23:28:09 <Axman6> possibly
23:28:09 <slavik> I understand that, but why have different operators for integer and floats?
23:28:33 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs(tail xs) where xs = iterate f x0 in findFix (/2) 1.0
23:28:35 <lambdabot>   Couldn't match expected type `a -> [(a1, a1)]'
23:28:37 <Axman6> well it's integral powers or not
23:29:14 <ac> ok sausage is tough
23:29:23 <Axman6> indeed
23:29:27 <Olathe> It depends on how it's cooked.
23:29:47 <Axman6> it's cooked like so: sausage :: (Misty m) => [m a] -> m [a]
23:30:44 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (/2) 1.0
23:30:46 <lambdabot>   0.0
23:30:49 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (*2) 1.0
23:30:51 <lambdabot>   Infinity
23:30:56 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (+1) 1.0
23:31:12 <lambdabot>   thread killed
23:31:16 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (+1) 100000000000.0
23:31:31 <lambdabot>   thread killed
23:31:32 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (+1) 1000000000000000000000000000000000000000000000000.0
23:31:40 <Olathe> Bah.
23:31:42 <lambdabot>   1.0e48
23:32:04 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (`div` 2) 29384
23:32:17 <lambdabot>   0
23:34:06 <Olathe> > let findFix f x0 = fst.head.dropWhile(uncurry(/=)).zip xs$tail xs where xs = iterate f x0 in findFix (\x -> 1 + x/2) 1.0
23:34:19 <lambdabot>   2.0
23:34:44 <visof> @index fromInt
23:34:44 <lambdabot> bzzt
23:34:51 <visof> what is this?
23:35:06 <TSC> @pl (\ (a,b) -> (b,a) )
23:35:06 <lambdabot> uncurry (flip (,))
23:35:09 <TSC> Bah
23:35:20 <TSC> Isn't there something in Control.Arrow?
23:35:37 <Olathe> @hoogle (a, b) -> (b, a)
23:35:38 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
23:35:38 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
23:35:38 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
23:38:37 <visof> is there function that convert Int into the corresponding floating-point number ?
23:39:02 <Olathe> > (fromIntegral 5)::Double
23:39:12 <Olathe> lambdabot is slow.
23:39:16 <lambdabot>   5.0
23:39:33 <Twey> Thirteen seconds
23:39:37 <Twey> Time for another restart?
23:39:55 <Olathe> Can't it be restarted with cron or something ?
23:40:11 <Twey> Might be a good idea
23:40:22 <Olathe> Even every day would be nice.
23:40:24 <Twey> (or just fix the massive memory leak >.>)
23:40:33 <slavik> there is most likely an underlying issue
23:41:10 <Olathe> Oh, sure.
23:43:21 <lispy> Oh yeah, I've asked Cale to restart it via cron
23:43:40 <lispy> oh, the problem is runaway muevals
23:44:39 <lispy> :t 1
23:45:00 <lispy> weird
23:45:14 <lispy> I can see lambdabot running
23:45:35 <Olathe> Hi, lambdabot !
23:45:36 <Cale> just getting rid of some of the zombie muevals for you
23:45:53 <lispy> Cale: ah, I was kill -9ing them :)
23:46:01 <Olathe> The zombies have partially eaten lambdabot's brain.
23:46:02 <Cale> I have a script running to wipe out runaway muevals every hour or so.
23:46:05 <lispy> looks like you have a script for it
23:46:09 <Olathe> Ahh.
23:46:16 <hydo> Is there something funky I have to do to get packages noticed?  I installed ghc from the binary package on the site, and i'm trying to build cabal.  I built and installed 'network' but building HTTP complains that it can't find Network.Socket
23:46:33 <Cale> But it leaves zombies. If you run out of pids, the easy thing to do is restart lambdabot :)
23:46:38 <Axman6> > (fromIntegral 5)::Double
23:46:46 <lambdabot>   5.0
23:46:47 <lispy> Cale: lol, that's kinda sad
23:46:47 <hydo> but /usr/local/lib/network-x-x/ghc-x/Network/Socket.hi is there.
23:46:49 <Axman6> :\
23:46:51 <Cale> Otherwise, lambdabot is reasonably stable.
23:47:00 <Elly> why does it leave zombies?
23:47:04 <lispy> Cale: can't we just have lambdabot reparent them to init when they spawn or something?
23:47:18 <Cale> If you know how to do that, go for it :)
23:47:32 <lispy> I think I did it in C for an OS class once
23:47:52 <lispy> I'm clueless otherwise
23:48:21 <ivanm> lambdabot just told me I had 22-day-old messages :o
23:52:12 <stulli> If i have a function foo::Int; foo=5 Is it a difference when i write let foo=5 instead?
23:52:16 <sjanssen> lispy, Cale: see doubleFork from xmonad
23:52:46 <ivanm> is that the same as a two-pronged fork (e.g. those used at barbeques)? :p
23:55:25 <lispy> Cale: http://www.faqs.org/faqs/unix-faq/faq/part3/section-13.html
23:55:30 <lambdabot> Title: How do I get rid of zombie processes that persevere?
23:55:47 <lispy> Cale: the interesting bit is the posix part about signal handling...
23:56:14 <lispy> Since you are not interested in ``stopped'' children, only in terminated children, add SA_NOCLDSTOP to sa_flags.  Waiting without blocking is done with waitpid(). The first argument to waitpid should be -1 (wait for any pid), the third should be WNOHANG.
23:56:54 <sjanssen> lispy: see the very last paragraph if you're curious how xmonad avoids zombies
23:57:55 <lispy> sjanssen: ah, that's how we did the reparenting...I forgot how it worked because recalled there should be a way
23:57:55 <hackage> Uploaded to hackage: X11 1.4.3
23:58:15 <Twey> X11?
23:58:25 <Twey> Is that a horribly-confusing name for a package?
23:58:37 <Axman6> how is it confusing?
23:58:49 <Axman6> isn't it the X11 interface for haskell?
23:58:56 <Twey> Oh, right
23:58:59 <Twey> Heh
23:59:00 <lispy> Twey: actually, x.org is rewriting in Haskell now ;)
23:59:00 <sjanssen> Twey: it binds to libX11, couldn't be simpler :)
23:59:19 <Twey> lispy: *grin*
23:59:24 <Twey> Yes, clearly.  Silly of me.
23:59:29 <Axman6> i wish X11 would die
23:59:47 <lispy> Axman6: that's easy, just hit Ctrl+Alt+Backspace
