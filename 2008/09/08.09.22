00:00:47 <Axman6> why is ATS so fast? i've never heard of it before...
00:00:48 <Baughn> humasect: Intel os x, 32-bit
00:01:16 <Baughn> humasect: I've isolated it to the openal configure script not including al.h. Now I just need to figure out how to regenerate it.
00:03:11 <dons> Axman6: most of its programs have been parallelised.
00:03:20 <dons> it's all in how many parallel entries you submit at  the moment.
00:03:30 <dons> and its compiled and statically typed.
00:03:47 <Axman6> fair enough
00:04:24 <Axman6> dons: did you see that Ben is going to be doing that OpenSPARC thing?
00:04:24 <dons> so write some parallel fannkuch or pidigits! :)
00:04:30 <dons> Axman6: sure did.
00:04:32 <dons> :)
00:04:32 <Baughn> Also, doesn't ghc read LDFLAGS? It's having trouble finding libgmp. :/
00:04:46 <Axman6> i'll have to reply to him and congratulate him :)
00:04:47 <humasect> Baughn: ah, hm, i have the same system too then. the prebuilt works for me, with 6.8.3 + 10.5 ?
00:04:53 <Baughn> humasect: Yes
00:05:08 <humasect> hm, how very odd
00:05:10 <Baughn> humasect: 10.5.5, to be exact
00:05:25 <humasect> yep ok, me 10.5.4
00:05:41 <Baughn> humasect: The configure script does not include al.h, only alc.h; alc.h does not include al.h
00:05:53 <Baughn> Possibly it used to.
00:06:08 <humasect> ah, are these from 6.8.3 too , or darcs openal package ?
00:06:11 <Baughn> ..but I doubt it; that file's six months old.
00:06:16 <humasect> aha.
00:06:39 <Baughn> humasect: Eh? No, al(c).h are part of the OpenAL framework, not ghc/haskell at all
00:06:58 <humasect> i mean, which openal package , which contains this configure script, is attempted
00:07:14 <Baughn> 1.3.1.1
00:07:44 <humasect> ok, the one that comes with 6.8.3
00:07:55 <humasect> how strange the prebuilt doesn't work. just .. how strange
00:08:04 <humasect> wait, how come it doesn't ?
00:08:10 <Baughn> Actually, the one I built doesn't either
00:08:14 <Baughn> It just got a little further
00:08:58 <Baughn> The /reason/ it fails to work should be obvious. A lot of the configure scripts failed, which somehow made it think the values of those constants was -1 instead of failing
00:09:00 <humasect> i am using openal package to set up the device and start/stop the context, but a custom wrapper for everything else. there is sound indeed
00:09:28 <Baughn> I suppose that's possible. It isn't entirely nonfunctional, just.. mostly.
00:09:34 <humasect> Baughn: what is the test you have given to prebuilt OpenAL-1.3.1.1, which categorized it to be 'not working' ?
00:09:44 <Baughn> humasect: As a test, try "get alErrors" twice
00:10:01 <Baughn> If it's compiled badly, you'll get an error the second time. Possibly the first too, but definitely the second
00:10:02 <humasect> with or without an open device+context ?
00:10:23 <Baughn> Yes
00:10:34 <humasect> does yes == with or yes == without ?
00:10:37 <Baughn> Either
00:10:42 <humasect> oh hehe
00:10:47 <Twey> Heh
00:11:11 <humasect> checkErrors s = do {e <- getError; when (e /= (toConst NoError)) $ error $ "OpenAL error in '"++s++"': "++show e }
00:11:43 <humasect> hm, this is what i am doing, and calling randomly and often in this code
00:11:50 <Baughn> humasect: That's not what I asked you to run
00:11:56 <humasect> getError is ffi call
00:12:02 <Baughn> Yes
00:12:15 <Baughn> You're not supposed to call it directly.
00:12:20 <Baughn> You're supposed to say "get alErrors"
00:12:21 <humasect> why not? it works =)
00:12:30 <Baughn> Yes, it works, because you're /bypassing the breakage/
00:12:44 <Baughn> To check whether it's broken or not, you can't do that. >_<
00:13:02 <humasect> i use get+GLUT.errors with hopengl and that also works fine.
00:13:22 <Baughn> OpenGL works fine. This is OpenAL we're talking abojut.
00:13:45 <humasect> i just don't exactly have the environment required with all the side effects set up to 'test' get alErrors
00:13:45 <Baughn> For pity's sake, just.. type in ":m + Sound.OpenAL\nget alErrors" in a ghci prompt
00:13:51 <humasect> ah, ok
00:14:12 <humasect> [ALError *** Exception: unmarshalALErrorCategory: illegal value 0
00:14:24 <Baughn> Right. Yeah, yours is broken too.
00:14:45 <humasect> oh well, i'm glad i don't use it. hopengl/hopenal i just cannot trust in this project; for that reason among various others
00:15:05 <humasect> but i think too that 1.3.1.1 is not the latest
00:15:26 <humasect> there were changes in 10.4 -> 10.5 for openal which happened after the release of 1.3.1.1 i believe
00:15:44 <Baughn> 1.3.1.1 is the lastest
00:15:47 <Axman6> :q
00:15:49 <Axman6> whoops
00:15:57 <Baughn> There may be further darcs development, but no actual releases since
00:16:24 <humasect> ok, i think i got a later one from the darcs place
00:16:51 <humasect> ..to attempt getting it to run with windows, as, for pity's sake, it does not come with prebuilt ghc
00:18:13 <humasect> not the one in http://darcs.haskell.org/packages/
00:18:15 <lambdabot> Title: Index of /packages
00:18:46 <humasect> but i don't know. what is this mysterious http://darcs.haskell.org/ghc-6.10/ ? =)
00:18:47 <lambdabot> Title: Index of /ghc-6.10
00:19:03 <Baughn> Well, they /are/ getting ready to release it in a few days. ;)
00:19:50 <humasect> ah, ok. i was wondering about the release candidate too, that must be related.
00:21:32 <Baughn> The darcs version doesn't fix it. However, autoreconf does work with it, and it was very easy to fix
00:21:36 <Baughn> Now to send a patch.
00:22:42 <humasect> cool ^_^
00:23:39 <Baughn> humasect: By the way, what was wrong with opengl?
00:24:53 <humasect> hm, well i had to make a custom shell to use it at all interactively; but also needed some functions anyway which were unexposed with hopengl. also the wrapper is more tuned for this project, where hopengl was kind of a mess to work with.
00:25:05 <humasect> (it changes how opengl works, above all !)
00:25:26 <Baughn> Hmm. I haven't noticed anything like that
00:25:37 <humasect> it may depend on the application
00:26:23 <humasect> so now it ended up as a composable type anyway, which i couldn't have done [nearly as cleanly/easily] with hopengl
00:27:11 <humasect> (so rendering is done outside of IO, then composed there on display)
00:29:15 <humasect> (er, inside-inside of io..)
00:30:53 <Baughn> humasect: Patch sent, but you can grab http://brage.info/~svein/openal.patch if you want
00:31:33 <humasect> cool =) thanks
00:48:09 <Taejo> why does lines leave "\r" in the strings? it just failed me a tutorial
00:49:42 <Baughn> Taejo: It's only meant to strip newlines, not odd typewriter instructions
00:49:49 <jk> Taejo: check http://book.realworldhaskell.org/read/functional-programming.html
00:49:54 <lambdabot> Title: Chapter 4. Functional programming
00:50:03 <jk> Taejo: just beneath 'Warming up: portably splitting lines of text'
00:50:26 <Taejo> Baughn: lol
00:52:12 <Taejo> jk: it's not that I can't write my own... it's that I didn't know I needed to until my tutor told me I failed because I get an inexhaustive case errro
00:52:42 <mmorrow> Tell your tutor it's not your fault he's using windows.
00:53:16 <mmorrow> :)
00:53:44 <ozy`> and whose fault is it if he uses a mac? http://www.rsmw.net/ergo/sbs.png
00:53:50 <mmorrow> his own.
00:53:56 <mmorrow> ;)
00:54:20 <ozy`> </ham-handed segue>
00:55:06 <FunctorSalad> Taejo: I hope you just failed the automatic tests and that he will relook at it
00:55:15 <FunctorSalad> otherwise that would be nasty
00:55:43 <Taejo> mmorrow: he's not using windows
00:55:47 <mmorrow> ozy`: but grandma, what delicious looking appendages you have!
00:55:49 <Axman6> ozy`: that's the one on the left?
00:56:00 <Taejo> FunctorSalad: ya, he will
00:56:05 <ozy`> mmorrow: haha
00:56:14 <Taejo> but he doesn't know haskell, which makes it a little more tricky
00:56:24 <Axman6> ...
00:56:27 <kaol> > let x = [1..length x] in x
00:56:28 <ozy`> Axman6: the left one is MacVim
00:56:33 <Axman6> ah
00:56:42 <lambdabot>   thread killed
00:56:45 <FunctorSalad> Taejo: doesn't he just have to pass a file containing only \n to it?
00:56:52 <Beelse-YARR> okay, well that experience has put me off ever using git
00:57:03 <ozy`> (and if you have a really sharp eye, you'll note that the icon in the toolbar of the TextMate window is for Emacs...)
00:57:11 <Baughn> Taejo: If he /had/ been using windows, the automatic text-file conversion should have handled. As it is..
00:57:24 <Baughn> Taejo: Tell him not to pass windows files as input to unix programs running on unix
00:57:37 <FunctorSalad> speaking of that, the new emacs icon looks almost exactly the same as the iceweasel icon :|
00:58:40 <Axman6> ozy`: been porting themes then?
00:59:26 <ozy`> Axman6: yeah, but that's not the point of this screenshot. I was comparing the comprehensiveness of TM's and vim's syntax highlighting.... obviously they both fail hard in several places
00:59:32 <humasect> ahh novelty is running out in the world
00:59:33 <FunctorSalad> ozy`: pretty colours... is it one of the select-color-theme ones?
00:59:46 <ozy`> FunctorSalad: one of the which?
00:59:53 <FordCortina> the idea of *algebraic* data types comes from category theory right?
01:00:25 <FunctorSalad> ozy`: nvm, apparently you're just using the emacs icon, not emacs
01:00:43 <ozy`> FunctorSalad: that's TextMate, and the theme is a TM theme :p
01:01:10 <ozy`> the emacs icon is only there because for some reason, that file is assigned to open in emacs on my system
01:02:24 <FunctorSalad> FordCortina: hmm I'd say it comes from algebra (in particular, the idea of free algebras)
01:02:30 <ozy`> FunctorSalad: I uploaded the vim version, too, if you want to tweak it or something
01:02:35 <ozy`> http://www.rsmw.net/ergo/glitterbomb.vim
01:02:58 <FordCortina> FunctorSalad: :)
01:03:54 <FordCortina> FunctorSalad: I'll look into free algebras, thanks
01:04:33 <FunctorSalad> FordCortina: that term may be bad for googling, I mean this one: http://en.wikipedia.org/wiki/Free_object
01:04:34 <lambdabot> Title: Free object - Wikipedia, the free encyclopedia
01:06:15 <the_unmaker> ok I got this book by graham hutton and he doesnt define terms as he introduces them
01:06:19 <the_unmaker> basic stuff
01:06:20 <the_unmaker> jeez
01:06:28 <FunctorSalad> ozy`: thanks, I wouldn't know how to convert it to emacs though
01:06:54 <ozy`> FunctorSalad: me either... I don't know where to begin putting together an emacs color theme
01:08:04 <FunctorSalad> ozy`: there's a package for it http://www.emacswiki.org/cgi-bin/wiki?ColorTheme
01:08:06 <lambdabot> Title: EmacsWiki: Color Theme
01:08:13 <FunctorSalad> contains quite a few presets too
01:10:55 <FunctorSalad> HOAS is cool but how do you derive the common instances? :|
01:11:37 <FunctorSalad> (I'm referring to the problems with the constructor containing functions)
01:12:08 <FunctorSalad> I could plug in placeholder variables, but that seems hairy
01:15:20 <tero-> Any idea why "darcs push" hangs darcs to busy-loop? the patch is small and pretty trivial
01:18:32 <rwbarton> FordCortina: As a technical note, "lazy" algebraic data types like those in Haskell are more like (co)free/final coalgebras
01:19:01 <FunctorSalad> oh
01:23:24 <mmorrow> , let [n,s] = fmap (conE . mkName) ["N","S"] in fix ((n:) . scanl appE s)
01:23:25 <lunabot>  [ConE N,ConE S,AppE (ConE S) (ConE N),AppE (AppE (ConE S) (ConE N)) (ConE S)...
01:23:41 <mc__> tero-: darcs likes to take long
01:24:05 <mmorrow> oops
01:24:14 <humasect> @hoogle foldr
01:24:15 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
01:24:15 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
01:24:15 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
01:24:41 <mmorrow> , fmap (fmap pp) (let [n,s] = fmap (conE . mkName) ["N","S"] in iterate (appE s) n)
01:24:41 <lunabot>  [N,S N,S (S N),S (S (S N)),S (S (S (S N))),S (S (S (S (S N)))),S (S (S (S (S...
01:25:31 <tero-> mc__: it turned out that I hadn't pulled a conflicting patch from the main repository before pushing new stuff
01:25:44 <mc__> I see
01:25:46 <mmorrow> , (!!20) . fmap (fmap pp) $ (let [n,s] = fmap (conE . mkName) ["N","S"] in iterate (appE s) n)
01:25:47 <lunabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S N))))))))))))))))...
01:27:12 <humasect> camelCase is bad for hp
01:27:44 <FunctorSalad> hewlett-packard? hitpoints? horsepower?
01:28:21 <humasect> hitpoints
01:28:22 <mmorrow> hell pony?
01:28:24 <mmorrow> ahh
01:28:28 <humasect> health
01:29:33 <FunctorSalad> i_think it_is more_readable_than underscores_mixed_with spaces :)
01:29:47 <FunctorSalad> (quick, where are the spaces, there?)
01:30:01 <humasect> hehe
01:30:17 <ozy`> this is true
01:30:18 <humasect> but, hm it is better to mess with Making Things Pretty for types especially
01:30:54 <humasect> depends on one's background perhaps.. underscores are definately worse =)
01:31:02 <ozy`> what would really be great is if the two conventions were interchangeable, like in rails...... don't look at me like that
01:31:02 <humasect> regardless of background=)
01:31:15 <humasect> they are interchangeable in rails ?
01:31:26 <ozy`> for certain purposes yeah
01:31:29 <humasect> ocaml kind of made me laugh at first, seeing all the underscores. i didn't get it.
01:31:36 <humasect> (even though i didnt get the joke)
01:32:34 <ozy`> in ruby you use snake_case for some things and CamelCase for others... rails has a lot of things that show up in both contexts
01:32:48 <ozy`> so it uses code to map back and forth between them
01:32:51 <FordCortina> FunctorSalad: rwbarton: thanks
01:33:15 <humasect> ah, that can work well. ocaml almost does this too. List.add_elem
01:33:23 <Cale> ozy`: wow, that sounds kind of insane.
01:33:36 <ozy`> Cale: you can say that about most of rails, really
01:34:23 <ozy`> it's widely regarded as the worst possible test case for implementing a new ruby interpreter
01:34:53 <humasect> all things tend to have strong and weak points =)
01:36:11 <humasect> too much of anything is not very helpful
01:40:31 <humasect> liftM doesn't count
01:41:16 <electronx> are there any good sites that describ avl tree properly?
01:41:35 <electronx> i can't seem to understand how the rotations are being done
01:41:55 <electronx> i just can't visualize it
01:43:14 <electronx> can someone help me out
01:46:36 <electronx> anyone?
01:47:06 <ziman> electronx, http://kam.mff.cuni.cz/~ludek/ click Algovision, a window will pop up. Select Data Structures -> Tree Data Structures and Start Algorithm tour. Then click Next in the upper-left navigation panel until you get to AVL Tree (there are several `chapters'). Then you can use the other controls to play the animation.
01:47:08 <lambdabot> Title: Ludek Kucera's home page
01:47:26 <ziman> It's a Java app.
01:47:33 <electronx> thanks ziman
01:47:58 <ziman> it's an illustration, not a formal description.
01:49:11 <electronx> applet doesn't seem to work :(
01:49:23 <FunctorSalad> is there some convention for naming helper functions?
01:49:38 <FunctorSalad> otherwise I think "auxSomething" is not bad
01:49:39 <electronx> crashed my browser
01:50:05 <ziman> Is your java installation OK? The applet works here.
01:50:27 <electronx> crashes my browser for some reason
01:51:46 <electronx> applet fires up but clicking on it crashes it
01:52:44 <ziman> weird.
01:53:45 <electronx> ya
01:57:36 <smtms> electronx, you could try starting the applet stand-alone
01:58:04 <cpfr> so ... i think havent figured out how to generate lists of random numbers
01:58:04 <smtms> electronx, or try to think about the rotations as preserving the basic property of binary search trees - order
01:58:24 <cpfr> as i need them bounded between two user defined numbers
01:58:59 <electronx> smtms: i still find it hard to visualize
01:59:23 <electronx> i can't see how they are rotating the trees
01:59:29 <electronx> which way
01:59:43 <electronx> up down
01:59:47 <electronx> which nodes
01:59:59 <electronx> how do you pick which node etc
02:00:21 <electronx> all the explanations seem really bad
02:02:38 <humasect> FunctorSalad: in toplevel ? hm..
02:03:25 <cpfr> nvm got it
02:04:02 <humasect> maybe conventions are limiting.. and considering all functions are helper, the current convention to naming of their function can be clear enough
02:04:49 <humasect> though, they are often without type description.. for this project anyway, they stand out
02:05:19 <besiria> gmorning
02:09:01 <the_unmaker> wow lots of stuff seems to be being done in haskell
02:09:12 <the_unmaker> lots or paralell stuff n coroutines n stuff
02:09:31 <besiria> after  i write some haskell cgi i put it under my /usr/lib/cgi-bin and i'm fine?
02:09:32 <the_unmaker> the grahn hummon book I have is pissing em off though sicne he uses tersm without defining them
02:09:56 <humasect> besiria: sure as long as it can find #!/.../runghc
02:10:14 <besiria> humasect: hmm it must be in the PATH right
02:10:19 <humasect> yep
02:10:24 <humasect> or specified there
02:10:28 <besiria> humasect: ok sounds easy
02:10:36 <humasect> #!/usr/bin/runghc at the beginning of the .hs
02:11:17 <besiria> humasect: what about the permissions of the .cgi, must have rx for the webserver?
02:11:34 <humasect> i'm not sure , i think so yes
02:11:42 <besiria> humasect:  ty very much
02:11:59 <the_unmaker> anyone here read "programming in haskell" by hutton
02:12:06 <the_unmaker> Im having trouble with it
02:12:37 <ivanm> anyone know what this haddock-2 error is/means? haddock: internal Haddock or GHC error: renameDecl
02:14:12 <BeelsebobWork> I can't find any docs for this -- does anyone have any idea what the change to STArray in ghc 6.9 is?
02:14:17 <BeelsebobWork> (it now has 4 arguments, not 3)
02:15:53 <humasect> besiria: no problem =) i hope it works out
02:16:21 <humasect> ivanm: haddock 2 also died for me like this. i got latest darcs again and it works.
02:16:31 <humasect> (i had to build from darcs to fix it, i mean)
02:17:03 <ivanm> humasect: latest haddock darcs you mean?
02:17:12 <humasect> yep
02:18:20 <RayNbow> the_unmaker: I don't have that book, but what problem do you have?
02:18:24 <ivanm> hmmm.....
02:18:32 <ivanm> humasect: what were you getting the errors on?
02:19:12 <humasect> hm it was the first time i was using (the publically distributed) version of 2.0 haddock, on this project i am working on. the same error you are having i believe
02:19:51 <ivanm> well, I'm having it on xmonad-contrib from darcs
02:20:14 * ivanm tries using darcs trackdown to see if it can find the problem
02:21:47 <BeelsebobWork> where has Data.Generics.Basics moved to in base-4?
02:22:17 <younder> I have but one question. How lokg will it take me to learn haskell. I kow Lisp (Sceeme and CL) and i am eloquient in mathematics.
02:22:42 <ivanm> younder: you'll never finish learning, because the language is constantly evolving!
02:22:46 <humasect> hm, cool ivanm. i never used that feature before.
02:23:22 <ivanm> heh, except I lost what it said when I accidentally ran darcs changes and it filled up my terminal's buffer :s
02:23:47 <humasect> also, younder , sometimes it takes just the right attempt at just the right time, then it falls into place from there. aka- where 'learning' becomes 'doing' , and so there is no doing without learning as well
02:23:53 <humasect> hehe
02:24:19 <ivanm> but if you know lisp and are good at math, it'll definitely be easier
02:25:32 <Twey> As there is no doing without learning, ofttimes there is no learning without doing, brothers...
02:25:49 * Twey pulls his cowl over his head and walks off solemnly, hands folded.
02:25:59 <Twey> (left-fold, strict)
02:26:04 <besiria> i'm getting errors with cgi. i'm trying the example and i'm getting back 500 error unrecognized input, failed to load interface for main use -v to see the files searched for
02:26:08 <ivanm> I-e-esu domine, dona e is requie... *donk*
02:26:15 <Twey> Hahaha
02:26:18 <ziman> :D
02:26:20 <ivanm> (ala montius pythonius)
02:27:21 <BeelsebobWork> no one knows where Data.Generics has gone in ghc-6.9?
02:27:50 <ivanm> find /src/to/6.9/ -iname "*generic*" ;-)
02:28:24 <cpfr> is there any easy well in haskell to generate numbers with something other than a uniform distribution
02:28:40 <humasect> Twey=)
02:28:42 <ivanm> cpfr: well, the GSL random library can do gaussians, etc.
02:28:45 <ivanm> except it's in IO
02:28:53 <ivanm> cpfr: what kind of distribution did you want?
02:29:05 <younder> I was figuring abot 6 months. (about 2 years for a noob)
02:29:08 <cpfr> gaussians beta and dirchelet
02:29:11 <humasect> besiria: do you have main defined ?
02:29:15 <ivanm> BeelsebobWork: from what I can find, it's still at Data.Generics :s
02:29:24 <BeelsebobWork> ivanm: it's not in base-4
02:29:27 <BeelsebobWork> only base-3
02:29:35 <BeelsebobWork> I can't figure out what package it has moved to
02:29:45 <ivanm> cpfr: gaussians are easy: http://www.rosettacode.org/rosettacode/w/index.php?title=Random_Numbers#Haskell
02:29:48 <lambdabot> Title: Random Numbers - Rosetta Code, http://tinyurl.com/48m564
02:31:45 <quicksilver> younder: very hard to define 'learn'.
02:31:52 <quicksilver> younder: you can get the basics in 1 week, easily.
02:31:53 <besiria> humasect:  problem solved i had to rename from .cgi to .hs
02:32:00 <humasect> ahh, great besiria =)
02:32:01 <quicksilver> younder: some details will fall into place over the next month.
02:32:22 <ivanm> but you'll be stuck here asking people "how do I do foo?" for the rest of your life! :p
02:32:25 <younder> nice group you have got going here. Very helpfull. Mayby I will be back  (when I've learned the basics)
02:32:26 <besiria> humasect:  why is that anyway? runghc only runs .hs files? it must'nt be that
02:33:06 <humasect> besiria: hm, perhaps that is the case. but i think it might be webserver side, too. i am not sure
02:33:59 <younder> ivanm: I am used to that from Common Lisp
02:34:16 <cpfr> ivanm, thank you, i guess the answer is no one has written that haskell library yet :)
02:34:52 <ac> could someone hpaste their '~/.cabal/config'? Every time I run cabal it complains of a synatx error in there, but it looks fine
02:35:19 <ac> also, has anyone heard of Pivotal, or even better, gotten it to compile?
02:35:24 <quicksilver> cpfr: I've certainly read about some probability distribution stuff in haskell.
02:35:41 <quicksilver> cpfr: you may be interested in http://web.engr.oregonstate.edu/~erwig/pfp/
02:35:42 <lambdabot> Title: PFP - Probabilistic Functional Programming in Haskell
02:35:47 <ehtom> does haskell do multithreading automagically?
02:35:53 <quicksilver> cpfr: http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
02:35:57 <pozic> ehtom: no
02:35:59 <lambdabot> Title: Refactoring probability distributions, part 1: PerhapsT, http://tinyurl.com/ythywo
02:36:02 <thoughtpolice> yay dph!
02:36:03 <thoughtpolice> http://www.reddit.com/r/programming/comments/72rkv/data_parallel_haskell_fun/
02:36:05 <quicksilver> ehtom: not entirely automagically, no.
02:36:06 <cpfr> quicksilver, i really was surprised
02:36:06 <lambdabot> Title: Data Parallel Haskell fun : programming, http://tinyurl.com/4qsjem
02:36:11 <younder> Perhaps I should define my terms. Application developement. Web pages, databased, ligic inference, the lot.
02:36:13 <quicksilver> ehtom: slightly automagically, sometimes.
02:36:24 <cpfr> quicksilver, i remember this article!
02:36:33 <pozic> quicksilver: since when?
02:36:56 <quicksilver> pozic: the Control.Parallel stuff is slightly automagic.
02:36:57 <thoughtpolice> ehtom: above (reddit) link above I just wrote is a good example of slightly-automagically
02:37:13 <quicksilver> pozic: if so far as you can spark quite greedily, and it will only actually thread as much as it has capabilities.
02:37:18 <pozic> quicksilver: that's not my understanding of automatic.
02:37:34 <quicksilver> I did say 'slightly'
02:37:41 <quicksilver> and I said automagic :P
02:37:52 <pozic> quicksilver: slightly 1 is 0 here :)
02:37:59 <quicksilver> it is slightly automagic because you don't need to specify how many cores you have, or manage threads explicitly.
02:38:03 <quicksilver> that's quite a big win.
02:38:05 <quicksilver> when it works.
02:39:51 <ac> ok, that was easy. I just deleted ~/.cabal/config, and cabal automatically wrote a correct default one
02:40:04 <thoughtpolice> quicksilver: i just wrote that above post since i'm playing with dph and it's pretty automagic too :]
02:40:21 <cpfr> quicksilver, no luck
02:40:27 <thoughtpolice> of course to get performance I couldn't use the pretty [:..:] syntax,
02:40:34 <thoughtpolice> vectoriser is still in the works :]
02:41:18 <thoughtpolice> although 'U.sum (U.zipWith (*) xs ys)'  automatically using 2 cores is pretty nice still
02:41:20 <cpfr> ... well haskell loses this round, its ok ill just use it for gui, db, and parsing
02:43:41 <humasect> U = ?
02:44:05 <thoughtpolice> humasect: qualified module import
02:44:10 <thoughtpolice> so sum and zipwith don't clash with prelude names
02:44:13 <humasect> yep, is it Control.Parallel ?
02:44:17 <thoughtpolice> no
02:44:41 <humasect> ok
02:44:42 <thoughtpolice> uses the dph packages that you can build with the 6.10 beta
02:45:09 <thoughtpolice> cool stuff :]
02:45:54 <humasect> ac: i have not .cabal/config, and have heart of pivotal ^_^
02:46:29 <ac> does AltData.Typeable still exist?
02:46:55 <ac> and AltData.Dynamic? If so, which package are they in?
02:47:03 <thoughtpolice> Data.Dynamic and Data.Typeable
02:47:34 <ac> can't find them in cabal
02:47:54 <thoughtpolice> they're just in base
02:48:16 <humasect> is pivotal alive ?
02:48:41 <ac> I don't know. It sounds very interesting
02:48:50 <humasect> it indeed looks it too
02:48:58 <ac> Just ran across it via Google
02:49:18 <humasect> the project here has about half this same function
02:49:39 <ac> getting a build error: Could not find module `AltData.Typeable'
02:49:58 <ac> what project?
02:50:05 <humasect> rename to Data.Typeable
02:50:13 <humasect> and Data.Dynamic for AltData.Dynamic
02:50:49 <humasect> hm part of it is a procedural graphics engine with integrated editing/manip
02:51:14 <the_unmaker> how long will it take me to learn haskell? IM a linux admin who knows some bash
02:51:45 <humasect> the_unmaker: depends when you decide to stop learning it
02:51:57 <ac> humasect: heh. Very good answer
02:52:15 <humasect> hehe
02:52:25 <the_unmaker> I decided to stop not learning it, but graham hutton book is issing me off by not defining its terms
02:52:29 <ac> humasect: what language are you using in this project for the procedural graphics?
02:53:13 <humasect> the_unmaker: ok, well we have eyes in the front for a reason. move onto the next task =) if you need to come back to that book, you will. try something else for a bit ^_^
02:53:18 <humasect> ac: all haskell
02:53:22 <ac> ok, Pivotal has all sorts of build errors
02:54:31 <ac> humasect: what's the end function of the project? Building games?
02:55:07 <humasect> mostly, ac
02:55:32 <ac> what's the underlying graphics library? OpenGL?
02:55:59 <humasect> here is an old picture : http://img221.imageshack.us/my.php?image=picture7ip2.png
02:56:00 <humasect> yes
02:57:53 <ac> humasect: what're you using to compile Haskell expressions? hs-plugins?
02:58:16 <humasect> some ghc api, some read/show
02:59:10 <ac> Do you have a working version I could compile?
02:59:12 <humasect> it is commonly used together with custom interpreter (to use graphics)
02:59:26 <humasect> *custom ghci-like thing
03:01:37 <ac> did you write the custom ghci-like thing too?
03:02:04 <humasect> yep
03:02:21 <the_unmaker> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
03:02:22 <lambdabot> Title: Unifying events and threads
03:02:30 <the_unmaker> 10milion applevel threads
03:02:31 <the_unmaker> wow
03:02:35 <the_unmaker> wowww
03:02:36 <humasect> had to, opengl doesn't like to work otherwise, and the entire project is worked on interactively too so it needed some custom hooks
03:02:39 <the_unmaker> whats ntpl?
03:02:56 <the_unmaker> The thread library is type-safe, is relatively simple to implement, and has good performance.Â  Application-level threads are extremely lightweight (scaling to 10,000,000 threads!) and our scheduler, which is implemented as a modular and extensible event-driven system, outperforms NPTL in I/O benchmarks.
03:03:00 <humasect> and ghci is not easily exposed with ghc api apparently ^_^
03:03:21 <ac> yeah, I've looked in to hacking ghci
03:03:30 <humasect> cool, the_unmaker =)
03:03:53 <humasect> it was a huge milestone to get the shell working perfectly without leaking=)
03:03:56 <the_unmaker> unbelieveable eh?
03:04:23 <humasect> hehe kinda the_unmaker , but then, they are using much less resources than os-level threads (ie. fork)
03:04:59 <humasect> as in fork(). forkIO = applevel, forkOS = oslevel
03:05:10 <humasect> ac: also the same editor is used to sound synthesis
03:05:21 * BeelsebobWork giggles at all the discussions going on in #squirrelfish about the types of things like +
03:05:59 <ac> hah. the joys of weak typing
03:06:29 <BeelsebobWork> the joys of a language filled with special cases
03:06:48 <ac> yeah no kidding. I sort of like JavaScript, and sort of don't for it's rather weird spec
03:07:42 <BeelsebobWork> It's amusing the amount of bitching the squirrelfish devs do at V8, for breaking a *lot* of the wierd spec rules, because they can get more performance out of it
03:08:31 <ac> huh. That's interesting. Up until now, AFAIU, all the implementations implemented all the weirdness pretty much to the letter
03:08:43 <BeelsebobWork> indeed
03:08:49 <the_unmaker> so 10million threads sounds good
03:09:01 <BeelsebobWork> looks like squirrelfish is faster than V8 even on V8's benchmarks now anyway
03:09:06 <the_unmaker> does c or lisp or anything use 10mil threads or oz maybne?
03:09:31 <ac> humasect: I'd like to see more of this project of yours... is it open source?
03:10:18 <ac> If all the browsers are moving to byte code compiled JavaScript, why don't they just agree on a byte code? :-P
03:11:48 <Smokey`_> because it takes a lot of effort to get numerous large companies to agree on standardizing anything. and even then, nothing's for certain, and they could abandon it all of 2-3 years later.
03:12:15 <Smokey`_> it all, 2-3*
03:12:21 <ac> yeah I know. Way too much cooperation to ask for. But it seems like byte code plus HTML and other web technologies could work very well
03:12:36 <Smokey`_> indeed.
03:13:58 <ac> it would be the best of both worlds (Flash vs HTML + JavaScript)
03:14:45 <Smokey`> silverlight/moonlight is somewhat like that though - uses MSIL, gives you client-side control over HTML, plus various other multimedia related goodies.
03:16:00 <Smokey`> it's not 'built in' to the browser - but there are netscape/activex plugins for most browsers on most operating systems - so it's about as cross platform as you really need.
03:16:17 <ac> humasect: for a job? Or in a very early stage?
03:16:39 <humasect> ah, it is not open yet, ac ^_^
03:17:23 <mmorrow> does anyone know off the top of their head how to send a POST request via curl /with a body/ of my chosing?
03:17:26 <mmorrow> *choosing
03:17:36 <mmorrow> i have this
03:17:37 <mmorrow> curl -X POST http://localhost:4242
03:17:59 <mmorrow> ah. got it.
03:18:17 <ac> humasect: I'm getting pretty curious :-)
03:18:24 <humasect> ac: the editor is nearly finished, and so as well the rendering engine. the picture there only demonstrates a few tests that were being developed at that time
03:18:30 <humasect> hehe, i would too =)
03:18:43 <ac> humasect: how does user interaction work?
03:21:09 <besiria> for gzip i need zlib package , right?
03:22:45 <humasect> ac, mouse+kb. the ui changes magically
03:22:59 <mmorrow> besiria: yes
03:24:23 <besiria> what is preffered: to use the old-time or the new-time package for simple time things
03:24:39 <humasect> double clicking, dragging, it is all interactive, ac. the procedures too are done in such a way, all is integrated with the same shared toolset/interface
03:32:43 <ac> humasect: sounds like it might be fun to play with
03:33:08 <humasect> is your system mac ?
03:34:05 <ac> Ubuntu, but there are Macs around the house
03:36:49 <greenfish> hey, is there anyone available that can help me with haskell?
03:37:13 <ac> greenfish: what's up?
03:37:42 <Cale> greenfish: yep, should be a few :)
03:37:58 <Cale> greenfish: But we can't help if you don't ask a question!
03:38:30 <greenfish> k, i want to add an Int to a list, and return a value within the same If statement
03:39:00 <ac> you'll have to return the list too then
03:39:19 <ac> if I understand what you want
03:39:40 <humasect> ac: i am packaging up a how-to or document on usage in the next few days, coincidentally =)
03:39:41 <greenfish> looks kinda like    func n = if n > 1 then return 1 & 1:list else 2
03:40:09 <Cale> In Haskell the only effect which a function has is to return its result, and the only things which it can depend on are its parameters.
03:40:42 <Cale> So if you want to transform a list, the function must take the list as a parameter, and return the modified list as (part of) its result.
03:40:55 <Cale> So you could have something like:
03:41:21 <ac> humasect: cool. I'll check it out when you're done
03:41:25 <Cale> func n xs = if n > 1 then (1,1:xs) else (2,xs)
03:41:42 <ac> speaking of IDEs, is Leksah replacing hIDE 2.x?
03:41:44 <Cale> greenfish: Does that make sense?
03:42:12 <humasect> ac: ok ^_^
03:42:15 <greenfish> yeah, i think so. thanks
03:42:26 <Cale> greenfish: It takes some getting used to at first.
03:43:09 <Cale> greenfish: If you need help figuring out how your particular case works out, or have any other questions, don't hesitate to ask :)
03:43:09 <ivanm> anyone here use pandoc?
03:43:29 <greenfish> alright, thanks mate
03:43:37 <Cale> ivanm: I haven't but it looks cool...
03:43:55 <ivanm> yeah
03:44:21 <ivanm> I just wanted to know how one was meant to edit pandoc files... or just write markdown, etc. and then use pandoc just to convert/create files?
03:45:08 <Cale> I'm not sure that Pandoc has its own external file format.
03:45:27 <Cale> It has an internal data structure which it converts everything it reads into.
03:45:38 <ivanm> *nod*
03:45:59 <ivanm> well, it does have its own format... a slightly modified markdown format
03:46:05 <Cale> ah, okay
03:46:45 <Cale> prettyPandoc seems like it should preserve all the internal structure
03:46:56 <humasect> ac: hm i have seen leksah recently too. i could use a jump-to-error, above all, in the development process
03:47:32 <thoughtpolice> ivanm: yeah that's about it
03:47:46 <thoughtpolice> i normally have some file, i.e. index.text and then just run pandoc over it to create an HTML file
03:48:21 <thoughtpolice> (i'm using it for a new version of my website because it's easy, I already used markdown and I can just create a standalone and get things like math equations and whatnot)
03:48:25 <ivanm> *nod*
03:49:13 <ivanm> I was wanting to make a simple structured outline of a talk, etc. and was looking for a suitable mode in emacs, when I thought about markdown and remembered that pandoc is a haskell tool that supports it
03:53:13 <the_unmaker> NPTL?
03:53:17 <the_unmaker> what is that?
03:53:18 <the_unmaker> NPTL
03:53:40 <the_unmaker> The thread library is type-safe, is relatively simple to implement, and has good performance.  Application-level threads are extremely lightweight (scaling to 10,000,000 threads!) and our scheduler, which is implemented as a modular and extensible event-driven system, outperforms NPTL in I/O benchmarks.
03:53:48 <the_unmaker> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
03:53:51 <lambdabot> Title: Unifying events and threads
03:54:06 <RayNbow> #google nptl
03:54:12 <RayNbow> @google nptl
03:54:14 <lambdabot> http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library
03:54:14 <lambdabot> Title: Native POSIX Thread Library - Wikipedia, the free encyclopedia
03:57:31 <ac> humasect: I just tried to build Leksah, but it depends on the non-existant package sourceview
03:57:58 <the_unmaker> hm
03:59:41 <humasect> ah, hmm, hehe
03:59:49 <humasect> its not gtk ?
04:00:10 <humasect> gtk has a sourceview somewhere in its girth
04:02:03 <ac> Graphics.UI.Gtk.SourceView
04:02:12 <ac> I don't have it apparently
04:02:18 <ac> probably need a newer version of gtk2hs
04:02:36 <humasect> ah
04:09:25 <ivanm> ac: it's a compile-time option
04:11:31 <ac> ah. Looks like dcoutts took it out for the time being because it wasn't building
04:11:38 <ac> I'm not the only one with this problem
04:12:20 <ivanm> oh?
04:12:24 <ivanm> builds here...
04:16:02 <ac> guess I'll have to build the darcs version gtk2hs
04:16:50 <ivanm> ac: what for?
04:17:07 <ivanm> note that it requires gtksourceview IIRC
04:17:43 <Baughn> Every time I call Network.accept, I get "getNameInfo: does not exist" and my program dies. Now, I understand that network throws an IOError if it fails to look up the host, and I could catch that, but - what would happen to the connection? I don't want to just drop it.
04:18:35 <humasect> the, Network.listen connection?
04:18:40 <Baughn> Yes
04:19:17 <humasect> hm.. i think the error would not kill it in a catch (no GC)? but just a guess.
04:19:18 <Baughn> Oh. Fixed in 6.10
04:19:21 <humasect> oh!
04:19:25 <Baughn> It's an IPv6 issue
04:19:33 <Baughn> I'll just force IPv4 until it's released.
04:19:43 <Baughn> (http://hackage.haskell.org/trac/ghc/ticket/2005 <-- Details)
04:19:44 <lambdabot> Title: #2005 (localhost on mac causes getnameinfo error in safari.) - GHC - Trac
04:19:45 <humasect> ahh, good to hear that it is known/solved
04:20:31 <ac> ivanm: how do I get gtk sourceview?
04:21:18 <ivanm> ac: look in the cabal file for the arg you need
04:21:24 * ivanm has a look at the ebuild for it
04:21:48 <ivanm> duh, no cabal file :s
04:21:57 <ivanm> looks like you need --enable-sourceview
04:22:05 <ivanm> but it needs version 1.x of gtksourceview
04:23:17 <ac> what's odd is there's an ubuntu package libghc6-sourceview-dev, so the cabal package must've been there before
04:26:37 <pastorn> i'm reading the A-Z of languages interview with Simon Peyton Jones.
04:27:01 <pastorn> he mentions that haskells module system is very simple compared to the ML module system
04:27:09 <pastorn> how does the ML system work?
04:27:17 <humasect> more complicated than haskell's
04:27:23 <pastorn> doh!
04:27:27 <thoughtpolice> functors play a part there i think
04:27:43 <humasect> functors are not toys. it is serious business
04:27:47 <pastorn> hehe
04:28:51 <pastorn> i don't see the point of having a more complex module system... what is it that might be easier done if it were to be more complex?
04:29:25 <pastorn> would you ever want anything more than just importing and exporting methods?
04:29:30 <humasect> hm, recursive /cyclic dependency ?
04:29:39 <humasect> also ML has interface files
04:29:50 <pastorn> right, that might need a fix...
04:30:02 <pastorn> humasect: what are those?
04:30:17 <pastorn> like java interfaces?
04:30:19 <humasect> hm , i think like .h files are to .c files
04:30:24 <humasect> nope
04:30:30 <pastorn> ah, those king
04:30:32 <humasect> like headers, or .hs-boot in a way
04:30:35 <pastorn> *kind*
04:30:38 <humasect> ^_^
04:34:26 <ac> oh, I just had to rebuild gtk2hs after installing libgtksourceview-dev
04:35:51 <electronx> how to make this Strict data Tree a = Node a (Tree a) (Tree a)??
04:36:10 <electronx> Tree a = Node !a !(Tree a) !(Tree a)??
04:36:18 <electronx> that give me error for some reason
04:37:21 <electronx> anyone?
04:38:27 <humasect> (Tree !a) ?
04:38:33 * humasect has never used '!'
04:38:46 <electronx> me neither
04:38:56 <humasect> hehe
04:44:21 <electronx> sigh..
04:45:23 <pastorn> Tree a = N !a !(Tree a) !(Tree a) | E <-- why won't this work?
04:46:10 <maltem> pastorn: data?
04:47:29 <pastorn> maltem: well you COULD do that, but its wrong i tell you! WRONG!
04:48:47 <maltem> pastorn: I may be missing some context here
04:49:23 <pastorn> maltem: i'm just not thinking clearly today...
04:52:00 <maltem> anyway, with a LANGUAGE BangPatterns pragma, the above line (with the keyword "data" chimed in at the beginning) does work
04:52:41 <pastorn> maltem: :p
04:52:59 <maltem> so I'm missing the point of the question, somehow
04:53:04 <thoughtpolice> you don't need bang patterns
04:53:15 <thoughtpolice> strictness-declarations using '!' in data constructor fields is part of the standard iirc
04:53:18 <pastorn> @paste
04:53:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:53:19 <thoughtpolice> data Tree a = Leaf a | Node !a !(Tree a) !(Tree a)
04:53:23 <thoughtpolice> works fine loading it into ghci
04:53:25 <thoughtpolice> with no extensions
04:53:34 <maltem> thoughtpolice: ah sure, those are not patterns
04:53:56 <pastorn> http://hpaste.org/10597
04:55:03 <pastorn> seems to work...
04:56:47 <maltem> @seen ertai
04:56:48 <lambdabot> ertai is in #haskell.fr, #xmonad, #haskell, #darcs and #arch-haskell. I last heard ertai speak 15h 12m 49s ago.
05:00:03 * byorgey waves good morning to #haskell
05:00:03 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
05:00:40 <byorgey> @seen Taejo
05:00:41 <lambdabot> I saw Taejo leaving #haskell 3h 40m 47s ago, and .
05:01:46 <byorgey> @tell Taejo thanks for the nudge, I've been meaning to get around to that for a while.  the current darcs version can indeed output SVGs.
05:01:46 <lambdabot> Consider it noted.
05:04:56 <mc__> how would I check the quickchek properties?
05:08:27 <thoughtpolice> of what?
05:12:40 <byorgey> mc__: if you have a quickcheck property, you can check it using the 'quickCheck' function
05:13:31 <byorgey> for multiple properties, you can put them in a list of type  (Testable a) => [a]  and then run  mapM_ quickCheck list
05:13:55 <mc__> byorgey: I dont have the quickCeck function in scope
05:14:04 <byorgey> mc__: is this something you've written or something else?
05:14:10 <thoughtpolice> mc__: import Test.QuickCheck
05:14:30 <thoughtpolice> speaking of quickcheck I hope ndm applies my derive patches and puts them out there soon :]
05:14:55 <mc__> what do they do?
05:14:59 <thoughtpolice> $(derive makeArbitrary2 ''Thing) == automatic QC derivations = win
05:16:47 <mmorrow> thoughtpolice: totally.
05:17:02 <mmorrow> and Binary!!
05:17:03 <tsar> http://hpaste.org/10598 , how do i fix "test" ?
05:17:08 <thoughtpolice> mmorrow: yes!
05:17:11 <humasect> > fix "test"
05:17:12 <lambdabot>   Couldn't match expected type `a -> a'
05:17:16 <humasect> can't.
05:17:18 <Japsu> template haskell = copy-paste at language level = win
05:17:23 <mmorrow> heh
05:17:54 <thoughtpolice> mmorrow: first thing I did after I got my patches working = prop_derive_works = x == decode (encode x)
05:17:58 <thoughtpolice> to make sure i was not dreaming
05:18:00 <thoughtpolice> and it was good
05:18:18 <mmorrow> thoughtpolice: haha. siCK!
05:19:17 <thoughtpolice> unfortunately getting the QC derivations working was annoying 'cause I had to edit the AST that the derive package generated
05:19:43 <thoughtpolice> didn't properly understand type signatures
05:19:47 <mmorrow> heh, yeah me too. i just pretend like that didn't happen though ;)
05:20:19 <maltem> tsar: arrs contains IO actions (IO ()), and you're trying to print one of them
05:20:32 <mmorrow> and it wasn't able to infer some types if i recall correctly (of numeric literals) ...
05:21:13 <maltem> tsar: err, I mean lines, not arrs
05:21:42 <FunctorSalad> @arr
05:21:42 <lambdabot> Smartly me lass
05:21:44 <tsar> id guess printing io was what io was for. but ok it contaisn other ios
05:22:05 <thoughtpolice> mmorrow: in the case of like '0 :: Int' it generates something like 'SigE (LitE (IntegerL 0)) (ConT GHC.Base.Int)' when that last part has to be 'ConT (mkName "Int")'
05:22:13 <thoughtpolice> which was annoying :[
05:22:29 <mmorrow> hmm
05:22:31 <ehtom> I have r n s = r n-1 s + s/6 * n...
05:22:36 <mmorrow> , [|0 :: Int|]
05:22:37 <thoughtpolice> but it all works now
05:22:38 <lunabot>  SigE (LitE (IntegerL 0)) (ConT Int)
05:22:52 <thoughtpolice> it will say 'Int' is out of scope in that case
05:22:57 <ehtom> however it doesn't work
05:23:15 <mmorrow> won't it do that in the ConT (mkName "Int") case you mean?
05:23:16 <ehtom> whereas r n s = r nnew s + s/6 * n where nnew = n-1 does
05:23:24 <ehtom> how do I do this neatly?
05:23:41 <maltem> tsar: you're trying to print a GL drawing action on a terminal, how should that work out?
05:23:52 <mmorrow> , $(sigE [|0|] (conT (mkName "Int")))
05:23:53 <lunabot>  0
05:24:03 <mmorrow> , $(sigE [|0|] [t|Int|])
05:24:03 <lunabot>  0
05:24:07 <mmorrow> hmm
05:24:09 <thoughtpolice> mmorrow: no, in the case above when I tried to fix the AST in a rudimentary way I got errs 'GHC.Base.Int out of scope' - particularly ConT is :: Name -> Type
05:24:33 <thoughtpolice> so you have to 'mkName "Int"'
05:24:56 <mmorrow> ahhh, i gotcha. i think that's on account of derive using the code ouput by the TH prettyprinter as input src, and since
05:24:59 <mmorrow> , ''Int
05:24:59 <lunabot>  GHC.Types.Int
05:25:07 <mmorrow> GHC.Types isn't in scope...
05:25:14 <thoughtpolice> strageness
05:25:19 <mmorrow> that's why i love cleanNames
05:25:24 <mmorrow> , cleanNames ''Int
05:25:24 <lunabot>  Int
05:25:28 <mmorrow> :)
05:25:43 <mmorrow> , everywhere (mkT (mkName . nameBase)) ''Int
05:25:43 <lunabot>  Int
05:25:54 <thoughtpolice> but anyway everybody should use derive because *not* having to use a preprocessor (see: drift) is a super nice advantage, really
05:26:17 <thoughtpolice> would be nice to have an extended amount of auto-derivs but the ones that're already there are the ones I really care about
05:27:15 <mmorrow> totally, derive is awesome. i totally want to add to it. i've been thinking lately of useful things to derive other than class instances
05:27:39 <mmorrow> wow i'm totally psyched on totally apparently
05:27:55 <quicksilver> totally.
05:28:04 <mmorrow> totally!!
05:28:11 <thoughtpolice> totally dude, totally
05:29:00 <thoughtpolice> mmorrow: perhaps adding a TH Lift instance would be nice? then you would have to do even less work to write quasiquoters :]
05:29:44 <quicksilver> I thought there already was a way to auto-derive Lift.
05:30:17 <mmorrow> thoughtpolice: i should do that asap, since i have the code (stolen from igloo's th-lift and added-to slightly) right in front of me.
05:30:45 <mmorrow> quicksilver: yeah, igloo wrote the th-lift package, which does it nicely.
05:30:58 <thoughtpolice> mmorrow: ndm is real busy right now apparently but I suggest checking out the darcs repo and adding it
05:31:02 <thoughtpolice> that would be greatness :]
05:31:30 <mmorrow> ok, you've convinced me
05:31:31 <ehtom> what is a good ide for haskell?
05:31:36 * thoughtpolice wins
05:31:39 <mmorrow> heh
05:31:42 <thoughtpolice> ehtom: might want to check out leksah
05:31:45 <thoughtpolice> www.leksah.org
05:32:00 <jeffz> ehtom: depends which one you're most comfortable with, a lot of people use emacs, others vim
05:32:10 <thoughtpolice> mmorrow: also darcs2 did not like derive's darcs repository fyi
05:32:19 <thoughtpolice> i had to grab a copy of 1.0.9 and use it
05:32:31 <ehtom> jeffz: vim is fine, but it doesn't seem to highlight stuff
05:32:39 <mmorrow> luckily i still have darcs 1.something installed..
05:32:42 <wman> is there a way to force cabal to install packages to location other then <program files>/Haskell by default (ie. some environment variable, or other way so it wont have to be specified every time ?). or the only way would be to edit the sources & recompile ?
05:33:01 <_ar> ehtom: try :syntax on
05:33:05 <ehtom> 1/0.05 is 20... how do I make haskell treat such things as an integer as opposed to a real?
05:33:27 <ehtom> _ar: ah. that worked
05:33:43 <BeelsebobWork> ehtom: floor, ciel, round etc
05:33:44 <Zao> ehtom: div or quot
05:33:52 <thoughtpolice> mmorrow: but yeah hopefully you can get your patches in and ndm can have a fix-release and then things will be even more awesomer than ever. really, more people should contribute to it.
05:33:56 <Zao> Erm, or not :)
05:33:58 <_ar> ehtom: good, you can put that command in ~/.vimrc to make it the default
05:34:40 <thoughtpolice> like I said the main reason I shied away from drift was that it was an external preprocessor, meaning making it cabal-friendly wouldn't have been fun...
05:34:43 <ehtom> BeelsebobWork: thanks. Is there a reference for that sort of stuff?
05:35:34 <BeelsebobWork> ehtom: http://haskell.org/ghc/docs/latest/html/libraries/
05:35:35 <lambdabot> Title: Haskell Hierarchical Libraries
05:36:39 <ehtom> BeelsebobWork: thanks
05:36:57 <BeelsebobWork> also...
05:37:00 <BeelsebobWork> @src RealFrac
05:37:00 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
05:37:00 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
05:37:00 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
05:38:12 <BeelsebobWork> what does a Hash after a variable/constructor mean?
05:38:16 <Saizan> wman: there's a config file where you can set preferences, but i'm not sure where it is under windows, on unix it's ~/.cabal/config
05:38:29 <BeelsebobWork> (e.g. do (I# i#) <- get bh...)
05:39:13 <Saizan> BeelsebobWork: primop/unboxed
05:39:20 <BeelsebobWork> ah, k
05:39:32 <BeelsebobWork> next question -- where do the constructors S and J come from?
05:39:39 <BeelsebobWork> (in the context of a Data.Binary instance)
05:40:01 <Saizan> ?src Integer
05:40:02 <lambdabot> data Integer = S# Int#
05:40:02 <lambdabot>              | J# Int# ByteArray#
05:40:10 <BeelsebobWork> interesting
05:40:13 <BeelsebobWork> thanks a lot Saizan
05:40:17 <Saizan> np
05:40:42 <Baughn> But what if you want an integer larger than the address space?
05:42:18 <wman> saizan: thanks. btw,  on windows it is in $HOMEPATH\Application Data\cabal\config
05:43:14 <ehtom> why does haskell not let be do n * step where n is an integer and step is a double?
05:44:51 <thoughtpolice> :t (*)
05:44:52 <lambdabot> forall a. (Num a) => a -> a -> a
05:45:14 <BeelsebobWork> Saizan: have you got any idea what module they are exported from?
05:45:16 <quicksilver> ehtom: perhaps you want to use Rational, for exact fractions.
05:45:42 <thoughtpolice> ehtom: you can use anything with (*) that is an instance of Num but the two types must be the same as the signature implicates
05:46:05 <ehtom> ok, what do I do when I want to multiply different types?
05:46:27 <ehtom> I guess my last two questions are a subset of "how do I typecast stuff in haskell"?
05:47:06 <thoughtpolice> > (fromIntegral (5 :: Int)) :: Double
05:47:07 <quicksilver> fromIntegral is 'from integral type to any type'
05:47:07 <lambdabot>   5.0
05:47:21 <quicksilver> realToFrac is 'from any fractional type to any other fractional type'
05:47:37 <quicksilver> and to get back to an integral type, use round, ceil, or floor
05:47:40 <quicksilver> depending what you want.
05:47:58 <ehtom> ok... is that a haskelly way to do it?
05:48:00 <BeelsebobWork> Saizan: I see that GHC.Num imports GHC.Integer, but I don't actually see the source anywhere to verify that's where it comes from
05:48:05 <tsar> http://hpaste.org/10599 , IO a vs IO. how do i get from IOa to IO?
05:48:18 <quicksilver> ehtom: the haskelly way to do it is to use the right type for things, yes.
05:48:31 <quicksilver> ehtom: so if it is, in fact, guaranteed to be an integer, use an integral type.
05:48:36 <Baughn> tsar: It would help if you'd actually paste the error
05:48:43 <BeelsebobWork> tsar: return ()?
05:49:10 <Baughn> tsar: And you don't get from IO a to IO. IO a is an (incomplete) type; IO is a type constructor. IO (), maybe
05:49:55 <ehtom> ok
05:49:56 <ehtom> thanks
05:50:41 <tsar> http://hpaste.org/10600 , posted the wrong one before. when i call displaycalback in test it happens
05:53:05 <BeelsebobWork> tsar: well, what is a DisplayCallback?
05:53:14 <BeelsebobWork> look up the docs and find out what type it should be
05:53:40 <Baughn> IO (), actually..
05:55:45 <quicksilver> display2 (head lines) has the right type
05:55:46 <tsar> but what does a mean IO () a , a in general, is it a type of anything?
05:55:55 <quicksilver> the problem is the precedence
05:56:11 <quicksilver> your code reads as (displayCallback $= display2) (head lines)
05:56:16 <quicksilver> which is not what you want.
05:56:25 <quicksilver> putting () around (display2 $ head lines)
05:56:29 <quicksilver> will help it type check.
05:57:17 <maltem> tsar: a is a type variable, but any Haskell introduction will explain this in its first few chapters
05:57:18 <quicksilver> FYI, you don't need the (::GLfloat) you have 3x in the defn of 'arrow'.
05:57:26 <maltem> tsar: it means a can be any type
05:57:52 <Baughn> tsar: Mercury got ahead of me. As for "IO a", that pretty much just means "Some value of type IO a, where a is any type whatsoever"
05:58:12 <Baughn> tsar: Obviously you need to have other code telling it exactly what a /is/, but that's rarely a problem
05:59:12 <Baughn> So a function with type "IO a -> IO a" can be said document "This function does something with some IO computation, and passes through the result value" - with no information whatsoever about the type of that result, passing it through is the only thing it /can/ do
05:59:36 <tsar> ah quicksilver thanks
06:00:12 <Baughn> quicksilver: Say. Do you highlight on "mercury"?
06:00:19 <quicksilver> no ;)
06:00:34 <Baughn> Saying "quicksillver" just sounds so.. wrong. :/
06:02:25 <tsar> http://hpaste.org/10602
06:03:06 <tsar> basically the only thing i want is to be able to get a new value for the color of the line shere so i need a mapM_ which can map over 2 lists
06:03:16 <tsar> @src mapM_
06:03:16 <lambdabot> mapM_ f as = sequence_ (map f as)
06:03:36 <Baughn> tsar: zipWithM_?
06:04:31 <mm_freak_> return x >> return y >> return () :: IO ()  -- are x and y calculated here?
06:04:33 <tsar> baughn: not sure, zip isnt really what i want
06:04:58 <maltem> mm_freak_: no
06:04:58 <tsar> map2: http://hpaste.org/10604 , but for mapM_ ...
06:05:48 <quicksilver> mm_freak_: popular belief to the contrary, IO doesn't impose strictness or change haskell's evaluation order ;)
06:06:08 <maltem> tsar: mapx = zipWith
06:06:09 <mm_freak_> quicksilver: yeah, that's my question =)
06:06:16 <mm_freak_> so it sequences only functions specific to I/O?
06:06:29 <maltem> tsar: (approximately)
06:06:36 <quicksilver> there is no magical change to evaluation order
06:06:42 <quicksilver> it sequences *effects* not evaluation
06:06:47 <quicksilver> (in common with all other monads)
06:06:58 <Baughn> maltem: To force evaluation, have a look at Control.Parallel.Strategies
06:06:58 <quicksilver> to the extent that the effects demand evaluation, it happens.
06:07:03 <quicksilver> if they don't, it doesn't happen.
06:07:09 <mm_freak_> ok, the question was meaningless
06:07:12 <Baughn> mm_freak_: Which is also usable in pure mode, and is especially handy for parallelism
06:07:26 <quicksilver> "someIOAction [1..]" <- if this action demands the entire list, it will hang
06:07:36 <quicksilver> but if it ignores the list, or consumes only a finite quantity, it will not
06:07:44 <quicksilver> in which respect, it behaves exactly like a pure function :)
06:07:51 <quicksilver> IO actions can be strict in their arguments, or not.
06:07:55 <quicksilver> it's up to them :)
06:08:01 <mm_freak_> yes, that's naturalâ¦  i just somehow thought that IO binding demands the value
06:08:29 <Baughn> mm_freak_: Well, evaluate does.. only to whn form, though
06:09:03 <Baughn> That's when you want strategies, for handy forcing expressions that evaluate to ()
06:09:26 <mm_freak_> k
06:09:38 <quicksilver> hopefully it's not something you have to do often
06:09:47 <Baughn> (Nothing magic about evaluate, either. Seq, par or $! do the same)
06:09:49 <quicksilver> hopefully the default demand-driven evaluation is normally right.
06:09:59 <quicksilver> Baughn: there is something subtly magic about evaluate.
06:10:07 <Baughn> quicksilver: Compared to the other ones?
06:10:08 <quicksilver> Baughn: but it's not normally important or something you want.
06:10:15 <quicksilver> well it's not implementable using seq.
06:10:19 <quicksilver> (not quite)
06:10:44 <quicksilver> its raison-d'etre is to "Definitely" squeeze out a latent exception, I believe.
06:10:46 <mm_freak_> Baughn: i can't reproduce what you sayâ¦  isn't an Integer in WHNF?
06:11:00 <Baughn> mm_freak_: Yes, an Integer would be
06:11:03 <quicksilver> Baughn: 99% of the time people use evaluate, they could have used seq, though.
06:11:07 <Baughn> mm_freak_: Unless it's a thunk. :P
06:11:16 <mm_freak_> return (product [1..10000] `mod` 100) >>= \x -> return () :: IO () -- gives a result instantly
06:11:23 <mm_freak_> return (product [1..10000] `mod` 100) >>= \x -> x `seq` return () :: IO () -- takes some time
06:11:26 <Baughn> mm_freak_: Strategies is for more complex data, that have multiple parts that can be evaluated independently
06:11:55 <Baughn> mm_freak_: Right. The first one doesn't do any work at all.
06:12:27 <Saizan> mm_freak_: by "evaluate" he meant Control.Exception.evaluate
06:12:36 <Baughn> Some IO actions force evaluation. Some don't. return doesn't.
06:12:41 <mm_freak_> i'm not referring to strategies, just want to know in what way IO's (>>=) is strict
06:12:46 <Baughn> It isn't
06:12:47 <mm_freak_> it seems it isn't strict at all
06:13:08 <Baughn> Well, kind of. It does force earlier IO actions to execute
06:13:16 <Baughn> But *return* isn't strict
06:13:37 <mm_freak_> is it wrong to say that it's strict in world state?
06:13:58 <Baughn> No. That's its reason for existence
06:14:49 <mm_freak_> okâ¦  could i write a StrictId monad, which is the same as the identity monad, but the binding is strict in the value?
06:15:14 <mm_freak_> (Id x) >>= f = x `seq` f x
06:15:25 <dmwit> ?src ($!)
06:15:26 <lambdabot> f $! x = x `seq` f x
06:15:29 <Baughn> Sure, with the note that (short of restricting it to NFData instances) you can only make it strict in weak-head normal form
06:15:54 <tsar> Not in scope: `zipWithM_' , where is it?
06:16:05 <Baughn> So () would get evaluated fully, or any other single-thunk value, but with a list it'd just barely confirm that, yes, there's going to be a list at some point
06:16:12 <mm_freak_> Baughn: so if x is a list, then x `seq` () only calculates its head?
06:16:20 <Baughn> tsar: Control.Monad - lots of goodies in Control.*
06:16:42 <dmwit> ?index zipWithM_
06:16:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:16:46 <Baughn> mm_freak_: Yes, and it doesn't even reduce the head's value
06:16:57 <Baughn> > [undefined] `seq` ()
06:16:59 <lambdabot>   ()
06:17:04 <mm_freak_> hmmâ¦  interesting
06:17:06 <Baughn> > head [undefined] `seq` ()
06:17:07 <lambdabot>   mueval: Prelude.read: no parse
06:17:07 <lambdabot>  mueval: *** Exception: Prelude.undefined
06:17:39 <mm_freak_> > foldr (\x ys -> x `seq` (x:ys)) [] [1,2,3,4,5]
06:17:41 <lambdabot>   [1,2,3,4,5]
06:18:26 <maltem> mm_freak_: in other words, (thunk1:thunk2) is the whn form of a non-empty list
06:18:37 <Baughn> mm_freak_: I'm sure you're getting tired of hearing this, but forcing a particular evaluation order of things is exactly what Strategies is for. It has lots of very convenient functions in it - seqList, for example, can be usefully applied to lists where element N is a function of (one or more) preceding elements, to prevent stack overflows when accessing element 10^72 directly
06:19:13 <mm_freak_> Baughn: no, i'm not tired, but i'm not looking for a particular techniqueâ¦  i'm just curious =)
06:20:39 <Baughn> mm_freak_: Something like "list_producing_function `using` seqList rnf", or.. look up those functions. ;)
06:20:58 <Baughn> Then there's parList, which is just sweet..
06:21:52 <Baughn> Haskell is so easy to parallelize, it's funny. :P
06:25:10 <ehtom> just wondering... if I wrote an iterative function, like the fibonacci function and I told haskell to give me fib 20, then if I told it to give me fib 30, would it use the calculation it already carried out?
06:25:20 <mmorrow> just added Control.Parallel.Strategies to lunabot's imports
06:25:23 <mmorrow> , let xs = (replicate 100 [0..9]) in parList rnf xs `seq` xs
06:25:24 <lunabot>  [[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,...
06:25:26 <Baughn> ehtom: Depends on how you write it
06:25:45 <ehtom> ok, how do I write it so it remembers?
06:25:58 <ivanm> thoughtpolice: you said you used pandoc?
06:26:08 <Baughn> ehtom: Make the numbers a global list
06:26:21 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1 !! 30
06:26:22 <lunabot>  832040
06:26:25 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1 !! 1000
06:26:26 <lunabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
06:26:38 <mmorrow> bottom up
06:26:47 <Baughn> ehtom: Haskell doesn't memoize anything, really, but if you make it global it'll stay in scope and never be GCed
06:26:57 <ehtom> ok
06:27:12 <Baughn> ..actually, it's harder /not/ to make it keep the result, unless you make it a function of the index
06:27:27 <ehtom> thats what I did :P
06:27:38 <_ar> is there a common shorthand for something that takes f x to \x -> return (f x) ?
06:27:40 <ehtom> fib n = fib (n-1) + fib (n-2)
06:27:49 <Baughn> Right. Only the references you explcitly hang on to stay around
06:27:51 <_ar> whoops, takes f
06:28:01 <mmorrow> \f -> return . f
06:28:04 <mmorrow> == return
06:28:06 <mmorrow> oops
06:28:10 <mmorrow> (return .)
06:28:17 <Baughn> With "fibs 20", that would be fibs, but that's just a function, and fibs 20 (until you drop it), which is a single number - not a list
06:28:35 <_ar> mmorrow: aah yeah, that's kind of obvious once you think about it
06:28:37 <_ar> thanks
06:28:42 <mmorrow> _ar: :)
06:28:52 <mmorrow> _ar: i love @pl
06:29:03 <_ar> @pl?
06:29:03 <lambdabot> (line 1, column 1):
06:29:03 <lambdabot> unexpected end of input
06:29:03 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:29:04 <mmorrow> @pl \x -> return (f x)
06:29:04 <lambdabot> return . f
06:29:08 <mmorrow> @pl \f x -> return (f x)
06:29:08 <lambdabot> (return .)
06:29:10 <Baughn> Hmm
06:29:27 <mmorrow> @pl \x y -> g (f x y)
06:29:27 <lambdabot> (g .) . f
06:29:31 <thoughtpolice> ivanm: yeah
06:29:32 <Baughn> How /would/ you write a function that would return a list of fibonacci numbers, but not store them forever?
06:29:43 <conal> mmorrow: (fmap.fmap) g f
06:29:44 <ivanm> thoughtpolice: how did you install it?
06:29:45 <_ar> neat. what does pl stand for?
06:29:53 <Baughn> _ar: Pointless
06:29:57 <ivanm> I'm trying to fix up the gentoo ebuild for it, but can't work out how it builds the man pages :s
06:30:00 <thoughtpolice> ivanm: cabal install pandoc
06:30:03 <thoughtpolice> :p
06:30:09 <ivanm> so you didn't bother with the docs, etc.?
06:30:10 <mmorrow> conal: hmm
06:30:16 <Baughn> _ar: In lambda expressions like \a b c -> ... , a-c are called "points"
06:30:17 <thoughtpolice> ivanm: hm actually I *haven't* figured out where it puts the man pages and whatnot
06:30:39 <ivanm> I don't think cabal on its own can build them...
06:30:40 <mmorrow> @type (fmap . fmap) (g :: c -> d) (f :: a -> b -> c)
06:30:42 <lambdabot>     Could not deduce (SimpleReflect.FromExpr d, Show c)
06:30:42 <lambdabot>       from the context ()
06:30:42 <lambdabot>       arising from a use of `g' at <interactive>:1:15
06:30:52 <mmorrow> ahh
06:31:13 <mmorrow> @type (fmap . fmap) (*2) (+)
06:31:14 <lambdabot> forall a. (Num a) => a -> a -> a
06:31:18 <mmorrow> :)
06:31:21 <_ar> Baughn: okay. given the name, that makes sense
06:31:35 <mmorrow> , (fmap . fmap) (*2) (+) 92 49
06:31:36 <lunabot>  282
06:31:39 <mmorrow> heh
06:31:46 <conal> mmorrow: :)  you can arbitrarily compose fmap, first, to make composable "semantic editors"
06:32:10 <ehtom> am I right in thinking that a monad is just a label assigned to non-functional data types?
06:32:16 <opqdonut> no
06:32:43 <opqdonut> monads are a nice way of representing non-pure stuff, but there's nothing inherently non-functional in them
06:32:53 <mmorrow> conal: cool. also, "semantic editor" has a certain ring to it..
06:33:24 <thoughtpolice> conal: when are you going to release the new version of reactive? :]
06:33:31 <mmorrow> conal: i think i'll have to think about that though before i understand what that means
06:33:55 <conal> mmorrow: i like it.  a bunch of the theory is described in my paper "Tangible functional programming"
06:34:03 <Axman6> ehtom: would you call lists non-functional?
06:34:13 <mmorrow> hmm
06:34:15 <ehtom> no
06:34:19 * mmorrow checks it out
06:34:47 <ehtom> ok, maybe not general monads, but what about the IO monad?
06:34:48 <Axman6> well they're monads
06:34:53 <thoughtpolice> ehtom: monads are not non-functional. example: State monad, pure but you get state for your computations
06:34:57 <conal> thoughtpolice: soon, i hope!  this summer has been much more chaotic than i expected.  we've done a bunch of QuickCheck testing, but it's not in as good shape as i'd hoped by now.
06:35:16 <thoughtpolice> conal: yay :]
06:35:29 <thoughtpolice> ehtom: what about the io monad?
06:35:38 <conal> Monad is neither functional nor non-functional.  it's an interface, not semantics.
06:35:57 <mmorrow> oh nice. i tried to install eros a while ago, but wxhaskell et al stopped me dead
06:36:21 <Axman6> i think the best description i heard of the IO monad (whether it's true or not) is like the State monad, but its state is the outside world
06:36:42 <conal> mmorrow: yeah. sigh.  there's still no imperative gui library for haskell that installs reliably. :(
06:36:43 <thoughtpolice> i like http://haskell.org/haskellwiki/IO_inside
06:36:44 <lambdabot> Title: IO inside - HaskellWiki
06:36:54 <ehtom> ok, i'll have a look
06:37:03 <Baughn> Axman6: As it's possible to roll back the State monad, if that were true haskell would enable time travel
06:37:14 <thoughtpolice> conal: gtk2hs would be awesome if it could be cabalized as it stands
06:37:30 <Axman6> Baughn: well, it's a good way of thinking about it ;)
06:37:44 <conal> i'm moving away from 2D gui libs.  they're bulky and full of imperative baggage.  and at best end up looking like every else's UIs.
06:38:19 <FunctorSalad> what's the alternative? ;-)
06:38:52 <thoughtpolice> terminal output :]
06:39:06 <conal> FunctorSalad: where there's imagination, there are alternatives.
06:39:38 <mmorrow> conal: i had gtk2hs installed with 6.6, so i think it was just some left over trauma from that which contributed to me giving up on the wxhaskell install
06:40:26 <mmorrow> eros looks really cool though. i first saw it in the video of your google talk
06:40:26 <conal> mmorrow: which os?  i haven't gotten gtk2hs to install on windows.
06:40:42 <mmorrow> conal: on linux. it was an epic battle
06:40:48 <mmorrow> heh
06:41:02 <conal> mmorrow: (eros) thx!  i really want to get back to it.  and make a 3d-embedded version.  on top of reactive.
06:41:06 <thoughtpolice> i've never had an issue with installing gtk2hs, granted I didn't when I had 6.6
06:41:41 <mmorrow> conal: that sounds sweet. what do you mean by "embedded"?
06:41:57 <mmorrow> oh, "on top of reactive" (?)
06:42:39 <conal> mmorrow: i mean embedded in a 3d space rather than a 2d gui.
06:43:06 <Deewiant> getting gtk2hs+glade to work on windows took me a couple of days
06:43:42 <mmorrow> conal: ahhh, awesome!
06:44:08 <mapreduce> > fst (3, error)
06:44:10 <lambdabot>   3
06:44:53 <Deewiant> > snd (3, error)
06:44:54 <lambdabot>       Overlapping instances for Show ([Char] -> a)
06:44:54 <lambdabot>        arising from a use ...
06:44:54 <ziman> > snd (3, error)
06:44:55 <lambdabot>       Overlapping instances for Show ([Char] -> a)
06:44:56 <lambdabot>        arising from a use ...
06:45:01 <mmorrow> conal: would you use opengl for that?
06:45:02 <ziman> :)
06:46:23 <conal> mmorrow: probably opengl, yeah.  instead of struggling to get imperative libs to work, i'd like to go for a whole new look on top of a new, simple foundation, designed for functional programming and modern 3D graphics hardware.
06:47:13 <mmorrow> interesting
06:47:13 <conal> looks like opengl is dying.
06:48:05 <Baughn> conal: "Dying"? What do you base /that/ on?
06:49:01 <conal> Baughn: a few strands, including the content of opengl 3 and the rise of things like cuda & opencl.
06:49:25 * BeelsebobWork ponders what the modern equivalent of parsePackageName in cabal 1.5 is
06:49:31 <Baughn> conal: Nah. It might wind up becoming a layer on top of opencl, but it's not going away anytime soon
06:50:18 <conal> Baughn: it won't go away.  it'll be the living dead.
06:50:44 <Baughn> conal: I see no reason people would be calling opencl directly if all they want to do is put a couple of polygons on the screen
06:50:45 <conal> in other words, i don't expect much innovation/evolution to happen in opengl.
06:51:21 <Baughn> That's probably true. *Rendering* is dying; we'll be crossing over to raytracing soon enough
06:51:31 <BeelsebobWork> Baughn: I doubt that there are many people that only want to put a couple of polygons on the screen
06:51:41 <Saizan> BeelsebobWork: probably  Distribution.Text.parse
06:51:49 <matthew-_> conal: did you see the interview with sweeney on arstechnica the other day?
06:51:52 <BeelsebobWork> Saizan: genius, thanks
06:51:56 <conal> Baughn: raytracing is also rendering.
06:51:59 <BeelsebobWork> and raytracing *is* rendering -- it's just not rendering via rasterisation
06:52:03 <Baughn> (I'm getting pretty good realtime raytracing performance with cuda on an 8600M card)
06:52:03 <conal> matthew-_: yeah.  that's one of the strands i meant.
06:52:07 <Deewiant> matthew-_: he said C++ is the future so take it with a grain of salt ;-)
06:52:11 <conal> Baughn: cool!
06:52:16 <Baughn> conal: Oh, right. Rasterisation is dying. :P
06:52:21 <matthew-_> Deewiant: oh he's a haskell lover really ;)
06:52:31 <matthew-_> it's just not PC to admit it
06:52:38 <cads> raytracing adapts itself well to high polygon counts or even nonpolygon geometry representations
06:53:11 <Baughn> It adapts itself well to high-primitive-count scenes, or high-realism scenes. Shadows are *still* buggy with rasterisation, never mind reflections or caustics
06:53:20 <conal> Baughn: by "dying", i mean no longer undergoing significant evolution.  opengl will be a legacy api for a long time.  that legacy is what held back opengl 3.
06:53:29 <Baughn> ..never mind that you can replace a thousand polygons with a single sphere, either
06:53:41 <Axman6> are there any haskell ray tracers?
06:53:50 <Baughn> Probably a hundred
06:53:55 <Axman6> heh, good
06:54:14 <Baughn> Good ones? Not so much. Look to povray for that
06:54:22 <cads> rasterization still has a lot of efficiency hacks making it applicable to real-time rendering of advanced 'looking' effects
06:54:22 <Baughn> ..but a haskell front-end to povray would be great
06:54:55 <Baughn> cads: Once you get better-looking output in real-time from raytracing, who'll care?
06:55:10 <Baughn> We're not there yet, but  in a few years..
06:55:18 <cads> I agree
06:55:49 <cads> there have been harware based raytracing architectures for a while
06:56:30 <Baughn> We need to get those into common GPUs, but with this latest series..
06:57:10 <cads> what I think we'll see is hybrid methods mixing the data coherence of rasterization together with stochastic raytracing
06:57:13 <matthew-_> the distinction between gpu and cpu is going to go away within a few years
06:57:36 <Baughn> ..not likely. You still need something that's optimized for branching
06:57:54 <Baughn> GPUs/vector processors are good for number crunching, but that's not all a computer does
06:59:11 <cads> I think gpus and cpus and also the programming methods applicable to each will be generalized further
06:59:11 <matthew-_> if you look at the difference between directx 8 and 9 then really it's just making the gpu more programmable
06:59:19 <matthew-_> unlimited shader programs, etc etc
06:59:35 <Baughn> That's 9 vs. 10, I think
06:59:45 <matthew-_> you may be right, sorry
06:59:49 <Baughn> ..I'll stick to opengl. Vista is just not going to happen.
06:59:50 <matthew-_> and so really it's not a jump from there to adding in branch prediction, the whole 9 yards
07:00:01 <Axman6> cads: Apple are heading toward that with OpenCL which should be out in less than a year i believe
07:00:19 <matthew-_> well, you can look at opengl as a darwin - it's been so successful that it's held up the field unnecessarily for years
07:00:20 <Baughn> matthew-_: Branch prediction takes a /lot/ of hardware, though. It's not really something you want on a per-core basis. ;)
07:00:38 <Baughn> Instead, I'd expect to see massive hyperthreading in the gpu
07:00:53 <Baughn> Don't try to prevent stalls, just live with them
07:00:59 <matthew-_> oh I know, but at the same time, some modern cpus are throwing it out (or at least reducing it) and going back to simpler designs
07:01:04 <BeelsebobWork> Baughn: bear in mind that that's what graphics cards do already
07:01:07 <cads> hyperthreading is nice, but a generalized data parallelism processor would be quite a step above that
07:01:15 <matthew-_> plus compiler technology is rather better than it was 20 years ago
07:01:23 <BeelsebobWork> the Radeon 4870 is 1600 little vector CPUs on one chip
07:01:26 <matthew-_> the lack of a good branchpredictor is not as bad as it used to be
07:01:57 <tsar> ok i fixed the the program i osted before. its nice how composable haskell programs become once you get your head around allt he typing.
07:02:48 <Baughn> matthew-_: Right. With haskell, I'd be perfectly happy to just throw more threads at the cpu. :P
07:02:58 <cads> beelsebobwork, how general are those processing units?
07:03:10 <BeelsebobWork> cads: not quite general enough yet -- but getting very close
07:03:17 <BeelsebobWork> (general enough to run CUDA)
07:04:09 <cads> we've all seen impressive grid algorithms utilizing gpus to solve partial differential equation goodness
07:04:53 <Axman6> BeelsebobWork: wasn't CUDA nvidia?
07:04:59 <BeelsebobWork> Axman6: yes
07:05:00 <matthew-_> cuda is nvidia
07:05:08 <BeelsebobWork> but there are drivers for ATi cards too
07:05:19 <Axman6> how interesting
07:05:19 <matthew-_> it's C without function pointers and something else...
07:05:25 <BeelsebobWork> it gets JIT compiled to the shader engine
07:05:26 <matthew-_> and with some other stuff
07:05:34 <matthew-_> an awesome description, I know...
07:05:40 <BeelsebobWork> recursion
07:05:44 <BeelsebobWork> and something else
07:05:47 <matthew-_> that's the one
07:05:48 <BeelsebobWork> but I can't remember what just now
07:06:00 <BeelsebobWork> (even more awesome description)
07:06:05 <cads> wow, cuda is impressive
07:06:09 <cjay> is OpenCL much different from Cuda?
07:06:17 <BeelsebobWork> it's not a language for a start
07:06:18 <matthew-_> cads: yeah, based on that description...
07:06:19 <BeelsebobWork> it's an API
07:06:33 <BeelsebobWork> but apparently it's rather more powerful than Cuda
07:06:42 <BeelsebobWork> in that it allows direct access to graphics resources
07:06:51 <Baughn> cjay: More or less the same thing. Slightly higher-level, allows more operations, but it'S still a vector processing language
07:06:55 <BeelsebobWork> wheras cuda is very centred around "you're doing computation with this, not graphics"
07:07:08 <cjay> ok
07:07:31 <Baughn> Well, it's not like any of us have seen the completed language yet. :P
07:07:37 <BeelsebobWork> at the moment I just hope OpenCL catches on -- ending up with DirectX Compute Language being the standard would be horrible
07:07:44 <cpfr> hey does nub lazily?
07:07:50 <BeelsebobWork> Baughn: no, but apple anounced a fair amount at WWDC
07:07:55 <Baughn> cpfr: To the degree it can
07:08:05 <FunctorSalad> :) http://en.wikipedia.org/wiki/Image:Recursive_raytrace_of_a_sphere.png
07:08:07 <lambdabot> http://tinyurl.com/43fqkd
07:08:15 <BeelsebobWork> lazy enough to do this...
07:08:16 <BeelsebobWork> > nubBy (\x y -> y `mod` x == 0) [2..]
07:08:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:08:25 <FunctorSalad> an UI like that would be cool.
07:08:38 <Baughn> cpfr: Note that, while it's easy to use and doesn't require Ord, Data.Set/toList.fromList is still faster for large lists
07:08:58 <BeelsebobWork> FunctorSalad: heh, shame it's just spheres -- they're *easy* to raytrace
07:09:23 <cpfr> thanks Baughn and BeelsebobWork
07:09:27 <cpfr> that was awesome
07:09:28 <FunctorSalad> BeelsebobWork: UIs have the advantage that abstract shapes are fine though
07:09:37 <FunctorSalad> (compared to games)
07:09:44 <BeelsebobWork> FunctorSalad: yes and no -- I wouldn't like my UI to be entirely spheres :P
07:09:50 <matthew-_> I would expect a decent language to come out with larabee from Intel
07:09:50 <FunctorSalad> hehe
07:10:00 <matthew-_> which'll be C with extensions
07:10:01 <FunctorSalad> toruses too
07:10:09 <Baughn> It's going to be a few years before this settles down, either way
07:10:19 <BeelsebobWork> matthew-_: indeed -- larabee looks very interesting
07:10:30 <BeelsebobWork> I think nVidia may be underestimating intel
07:10:37 <BeelsebobWork> (or trying to play them down)
07:10:47 <ziman> @src nubBy
07:10:47 <lambdabot> nubBy eq []             =  []
07:10:47 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
07:11:06 <ziman> @src nub
07:11:06 <lambdabot> nub = nubBy (==)
07:11:31 <matthew-_> BeelsebobWork: from what I can see, nVidia are up a certain creek
07:11:36 <ziman> i thought nub was O(n log n)
07:11:57 <Baughn> ziman: It can't be, with only an Eq requirement
07:12:07 <BeelsebobWork> matthew-_: that's my assessment of the situation too, but I know a lot of people similarly in the know about graphics tech that say intel is up a similar proverbial creak
07:12:22 <matthew-_> interesting
07:12:43 <BeelsebobWork> matthew-_: I guess we'll find out in a year or two :)
07:12:51 <Philippa> I suspect we'll see a similar situation to the current one: Intel'll take the low end, nvidia'll hang on to the high for a fair while
07:13:03 <BeelsebobWork> Tim Sweeny certainly seems to be more interested in Larabee than in anything nVidia are making
07:13:11 <matthew-_> *Sweeney
07:13:14 <Baughn> If Intel really /wants/ the high end.. they've got a far larger budget than nvidia
07:13:26 <matthew-_> sorry to be pedantic, but that one gets misspelt a lot
07:13:37 <BeelsebobWork> Philippa: the thing is that if larabee is anything to go buy intel are going after "haha, now everyone's running raytracers and your chips aren't general enough nVidia"
07:13:56 * Baughn dreams of raytracers. ^_^
07:13:59 <cpfr> Baughn, the standard library is so huge is there any page that gives a whirlwind tour?
07:14:03 <Philippa> Beelsebob: yeah, that's not a year-or-two out though
07:14:11 <Baughn> cpfr: For what? Haskell?
07:14:14 <Philippa> that'll take three-to-five minimum
07:14:14 <BeelsebobWork> Philippa: I expect it is actually
07:14:21 <cpfr> yep
07:14:25 <BeelsebobWork> larabee is scheduced to come out in the next year Philippa
07:14:31 <Baughn> cpfr: Not that I know of, sorry
07:14:40 <cpfr> Baughn, no worries
07:14:48 <BeelsebobWork> and by intel's descriptions of it it's by no means aiming at low end
07:14:51 <Baughn> cpfr: Oh, and you'll want to add hackage/Edison to your working set. It's incredibly handy
07:14:58 <shepheb> cpfr: the Prelude and Data.List go a long way
07:15:01 <matthew-_> it'll be interesting. I would expect that when it comes out it will initially be poor as their drivers make a bad job of supporting opengl and directx
07:15:08 <Philippa> Sure. It'll then take a year or two for a decent range of games to exploit it
07:15:15 <matthew-_> but when games start writing directly to larabee, I suspect it'll fly
07:15:16 <cads> do you guys know of any advanced light-transport simulators implemented in haskell?
07:15:19 <Philippa> and /then/ some time for it to become expected
07:15:23 <BeelsebobWork> matthew-_: indeed -- but given that it and OpenCL are coming out at similar times...
07:15:27 <cads> I find h-ray
07:15:32 <BeelsebobWork> I expect it'll be very easy to write a very good OpenCL driver for it
07:15:37 <Philippa> that gives nvidia a fair while to achieve /enough/ generality
07:15:45 <Saizan> http://hpaste.org/10605 <- is this a bug or just really weird?
07:16:00 <FunctorSalad> Baughn: edison?
07:16:07 <BeelsebobWork> Philippa: yep, but during that time, intel will be the only company making chips that you can run *really* new high end games on
07:16:15 <cpfr> Baughn, i thought edison was absorbed by ghc
07:16:20 <Baughn> Saizan: That /has/ to be a bug
07:16:31 <Baughn> cpfr: It is? Not in 6.8, it asin't
07:16:33 <BeelsebobWork> Saizan: a little from column a, a little from column b
07:16:51 <Baughn> FunctorSalad: Data-structure library. Look it up on hackage
07:16:54 <Philippa> Beelsebob: that's the 3 year point. Before that, they're the only company that has one particular high end option supported, however shiny
07:17:23 <BeelsebobWork> Philippa: except that Tim Sweeney is already talking about releasing games based on something CUDA/OpenCL like next year
07:17:24 <Saizan> ?bug
07:17:24 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:17:39 <FunctorSalad> Baughn: oh, thought it must be something else since you had been talking about standard lib docs
07:17:56 <Baughn> FunctorSalad: Nah, just that it /ought/ to be standard
07:17:57 <Philippa> sure, but Tim's Tim: the Unreal engine != the majority of games, much as there's always some good stuff using it
07:18:07 <Deewiant> Saizan: heh, flipping the second to Show a, Eq a makes it work
07:18:09 <Philippa> and if it's CUDA-like, nvidia's DX10 parts'll do
07:18:17 <Philippa> especially the new current line
07:18:24 <Saizan> Deewiant: yeah, but it seems silly to require that
07:18:31 <Deewiant> yes, very
07:18:33 <Philippa> so: I don't think it's in the bag for Intel just yet
07:19:04 <matthew-_> I think all intel need to do is get larabee or its successor into a couple of consoles
07:19:17 <Philippa> matthew-_: that would certainly be market-changing, yeah
07:19:26 <matthew-_> and then they'll get themselves so embedded into the game dev tool chain that they'll create massive changes
07:20:04 <earthy> I don't quite see that happening yet though
07:20:19 <matthew-_> well I think the xbox 720 and PS4 are still some way out
07:20:21 <earthy> given the success of the Wii
07:20:26 <matthew-_> I don't know what IBM have up their sleves
07:20:39 <Philippa> earthy: the Wii's clearly just not doing the same thing at the PS3/360 though
07:20:39 <earthy> which gives some credibility to the claim that it's not the graphics dammit. :)
07:20:45 <earthy> true enough.
07:21:06 <quicksilver> sony plan for 10-year lifecycles, roughly.
07:21:11 <quicksilver> I don't know if MS have shorter plans.
07:21:15 <Philippa> basically the wii's getting large chunks of the casual market and anyone who wants to play 'traditional' stuff really needs one of the other two
07:21:26 * earthy nods
07:21:35 <matthew-_> I can't see MS or Sony abandoning their core markets
07:21:43 <quicksilver> I found tim's recent interview pretty boggling.
07:21:47 <matthew-_> I think they'll have to accept the wii was the won that got away
07:21:51 <quicksilver> Advocating multicore C++ as the way forward.
07:21:52 <matthew-_> *one
07:21:53 <tsar> i didnt think this was allowed: [((0,0),1,11),(...
07:21:59 <quicksilver> tsar: why not?
07:22:00 <tsar> i have (0,0) mixed with 1
07:22:06 <tsar> two diff types no?
07:22:08 <quicksilver> not mixed, that's a tuple
07:22:09 <earthy> however, all current-gen consoles show one important issue: stable sourcing of chips is even more important than capabilities
07:22:11 <Philippa> quicksilver: for him right now, it probably is. Nothing else is ready enough
07:22:13 <quicksilver> tuples can have any types.
07:22:14 <tsar> [1,"2"] disallowed....
07:22:20 <tsar> quick: oh cool, didnt know
07:22:25 <Philippa> earthy: heh. Yeah. I'm watching for power usage issues next gen, too
07:22:30 <tsar> or actually i did
07:22:31 * earthy nods
07:22:36 <tsar> but didnt think about it
07:22:41 <earthy> and Intel is *not* the player to beat in that market
07:22:48 <matthew-_> quicksilver: if he'd come out and said Agda was the way forward, people would laugh at him
07:22:50 <quicksilver> Philippa: well he meant as a replacement for GLSL (e.g.)
07:22:53 <earthy> TSMC comes to mind...
07:23:08 <quicksilver> Philippa: in my opinion, C++/threads is quite some way for being ready to replace GLSL.
07:23:15 <matthew-_> I suspect he doesn't really want to use C++ but he has no choice right now
07:23:26 <Philippa> matthew-_: me too
07:23:36 <earthy> Intel wins on processors because they really innovate in manufacturing process
07:23:46 <Saizan> Deewiant: did you try it on 6.8.3?
07:23:46 <Philippa> well, he has one but it's a strategic gamble and one that was painful enough for a gameplay scripting lang
07:24:02 <Deewiant> Saizan: yes, this was 6.8.3.
07:24:14 <Saizan> Deewiant: thanks, i still have .2 here
07:24:21 <earthy> however, for high-volume you don't want to be there, you want to be on well-understood well-tuned manufacturing processes
07:24:23 <matthew-_> no, wrt the current consoles, the only real winner is IBM
07:24:38 <Philippa> mmm. FWIW, I'm rating Atom. Enough that I'm tempted to make my next 'main' desktop a dual core atom or something and only boot something meatier for when I do play PC games (which is rather infrequently atm)
07:24:43 <matthew-_> getting your chips into all 3 consolse is a good idea
07:25:05 * Philippa suspects she'll get an all-45nm 360 if/when it's out...
07:25:06 <earthy> matthew-: obviously.
07:25:41 <matthew-_> Philippa: the problem is not Atom - it's more that the chipsets to go with it are currently hiddeous in terms of power draw. I'm not sure when the more efficient chipsets are due out
07:25:43 <BeelsebobWork> Philippa: 360?
07:26:06 <BeelsebobWork> XBox?
07:26:14 <matthew-_> have you looked at the new via cpu that only draws a bit more than the atom but is much much faster?
07:26:27 <Philippa> Beelsebob: yeah
07:27:09 <Philippa> matthew-_: doesn't help, but the atom-based stuff's still got a lower draw than eg mobile celeron
07:27:17 <Philippa> and yeah, more efficient chipsets good
07:27:44 <BeelsebobWork> Philippa: have you seen that most of the game devs are currently saying that even though the 360 has better hardware, the PS3 will overtake it in graphics quality very soon
07:27:45 <matthew-_> Philippa: http://www.trustedreviews.com/cpu-memory/review/2008/08/15/VIA-Nano-vs-Intel-Atom/p1
07:27:50 <Philippa> haven't looked at the via yet
07:27:56 <lambdabot> Title: VIA Nano vs Intel Atom - TrustedReviews, http://tinyurl.com/5rsxsu
07:27:59 <BeelsebobWork> purely because they can't get enough data onto a DVD to drive the XBox's graphics chip well enough
07:28:05 <Philippa> BeelsebobWork: I haven't, and I'm not surprised
07:30:02 <Philippa> I'm kinda expecting that FFXIII will come on multiple discs though
07:30:06 <Philippa> (on 360)
07:30:18 <BeelsebobWork> plausable
07:30:27 <BeelsebobWork> squishie is looking forward to that atm
07:31:47 <Philippa> it's somewhere on my to-buy list, certainly
07:31:59 <Philippa> I think it's kinda sad that my biggest reason to actually get a PS3 is Disgaea 3, much as I love the series
07:32:14 <BeelsebobWork> haha
07:32:29 <zachk> does ghc run on nano and atom?
07:32:31 <BeelsebobWork> I was very impressed with Enchanted arms actually
07:32:38 <Philippa> zachk: yeah, they're x86
07:32:45 <zachk> woot
07:33:09 <Philippa> I'm still kinda catching up on a pile of backlog, anyway. Only just played Mass Effect
07:33:25 <quicksilver> Philippa: FFXII will be two-disc on xbox, and will therefore be worse quality than PS3
07:33:37 <quicksilver> Philippa: they felt that 3-disk was a bridge too far.
07:33:41 <quicksilver> s/XII/XIII/
07:33:45 <BeelsebobWork> interesting
07:33:47 <quicksilver> I read that recently in an interview.
07:34:03 <quicksilver> apparently there is a natural 'break' in the game to jump from first disk to second anyhow.
07:34:09 <BeelsebobWork> I have to admit, not having to get up in the middle of the game and change disks is actually a damn good reason to own a PS3 for me
07:34:13 <BeelsebobWork> ah, I see
07:34:19 <Philippa> quicksilver: yeah, there always is
07:34:45 <quicksilver> well it woul dbe damn annoying if you went to return to an earlier area and had to reinsert earlier disk
07:34:50 <Philippa> there's a whole bunch you could potentially point out in XII
07:34:58 <quicksilver> most FF games have been "fairly free-roaming' towards the end of the game
07:35:05 <BeelsebobWork> quicksilver: it'd be like Riven all over again
07:35:07 <quicksilver> and some sidequests require you to 'roam right back'
07:35:25 <BeelsebobWork> awesome as Riven was
07:35:31 <Philippa> the next dashboard update's giving HD loading, isn't it?
07:35:31 * BeelsebobWork wants puzzle games like that again
07:35:53 <quicksilver> you'd think they could at least have an 'install extra content to hard disk' option.
07:36:08 <quicksilver> (maybe they will; that wasn't mentioned in teh interview I read)
07:36:13 * cads remembers how dramatic it was when you had to change the disk in FF-VII - it put you in great suspense, I loved it
07:36:40 <cads> you never had to change disks back around, if I remember correctly
07:37:47 <zachk> if you are a star war fan force unleashed is pretty cool
07:38:09 <zachk> i just love force choking wookies as darth vader
07:38:43 <Philippa> cads: hardly the most dramatic thing that happens around then in the game, mind
07:38:46 <BeelsebobWork> the iPhone version of that looks *really* good actually
07:39:35 <_ar> zachk: even if you're not. no one should be allowed to feel that powerful
07:39:55 <Philippa> eh, the demo didn't really do it for me
07:40:02 <cads> Well, I seem to remember that the first disk change, it happened after a pretty exhausting and demanding series of boss battles
07:40:15 <_ar> Philippa: hmm.. that's all i play are the demos =)
07:40:44 <cads> so there was great relief.. and at the same time you were going to a new continent and you had no idea what was coming up
07:40:45 <_ar> they're the right size for my attention span
07:40:47 <BeelsebobWork> the UI with gesture crazies is so cool
07:41:01 <Philippa> cads: remind me which side of the change you lose a party member?
07:41:15 <cads> I think that was 3rd disk :D
07:41:20 <Philippa> could've sworn that's first disc...
07:41:22 <Philippa> heh
07:41:52 <cads> gosh, I cried when they lost Aeris...
07:42:13 <cads> aanyways
07:42:41 * Philippa needs to figure out where she's eating tonight, anyway
07:43:15 <ivanm> Philippa: somewhere where there's food?
07:43:31 <cads> my little brother is into ff12 and it seems so non ff... recalling ff3/7/8/9, I feel like this: http://xkcd.com/479/
07:43:36 <lambdabot> Title: xkcd - A Webcomic - Tones
07:44:26 <cads> I don't like the music score in 12, and it seems like that whole world has no humor
07:44:29 <Philippa> ivanm: it's a starting point. Needs to be somewhere I, my girlfriend and a vegan friend of mine can all get food we'll like though, which is tougher
07:44:51 <ivanm> picky, picky :p
07:45:25 <FunctorSalad> steak house
07:45:28 <FunctorSalad> ;-)
07:45:32 <Philippa> okay, in the last case food they can eat is a good start
07:45:39 <matthew-_> FunctorSalad: I was about to suggest a cattle ranch ;)
07:46:04 <Philippa> well, it rules out Nandos because they're awful at providing the relevant info
07:46:53 <ivanm> matthew-_: was the announcement OK?
07:47:34 <matthew-_> ivanm: oh yes, many thanks
07:47:38 <BeelsebobWork> Philippa: I was under the impression that *nothing* at nandos was vegan
07:47:53 <ivanm> no worries ;-)
07:47:54 <BeelsebobWork> in that everything cooked goes on the same grill with the chicken
07:48:06 <matthew-_> ivanm: I guess next we should replace FGL so that it can deal with nested graphs properly
07:48:09 <quicksilver> "At Nandos we love vegetarians. All our chickens are vegetarian"
07:48:15 <BeelsebobWork> :D
07:48:15 <quicksilver> that cracked me up when I read it ;)
07:48:23 <quicksilver> I'm not sure a vegetarian would find it as funny.
07:48:28 <Philippa> Beelsebob: pretty much, yeah. Though that depends a little on your definition of vegan
07:48:39 <FunctorSalad> quicksilver: they actually say that? heh
07:48:46 <matthew-_> level 9 vegan: doesn't even cast a shadow
07:48:54 <quicksilver> FunctorSalad: it used to be painted on the wall of the restaurant.
07:48:56 * BeelsebobWork really struggled not to laugh at the vegans at IFL a few years back when they got served goulash with the meat picked out
07:48:59 <quicksilver> matthew-_: pocket mulching?
07:48:59 <zachk> i have toyed with vegetarianism, but it is darn hard to find food to eat around town
07:49:09 <BeelsebobWork> would have been rather cruel though :(
07:49:09 <quicksilver> matthew-_: or is that only level 5?
07:49:14 <FunctorSalad> quicksilver: I guess they figute that they don't have any reputation to lose with them anyway
07:49:17 <FunctorSalad> *figure
07:49:18 <Philippa> matthew-_: I know at least one vegan who's larger than I am
07:49:25 <matthew-_> quicksilver: I can't remember - what is that from? Simpsons?
07:49:28 <zachk> level 15 vegan: can walk through walls
07:49:36 <quicksilver> Philippa: I think matthew meant they won't eat anything that casts a shadow.
07:49:40 <quicksilver> it is, indeed, from the simpsons.
07:50:01 <quicksilver> the episode were lisa gets a crush on a leftist activist.
07:50:06 <matthew-_> yeah
07:50:19 <sw17ch> zachk: i have a lot of friends who are vegitarian... i love eating with them because they find the funnest ways to make food
07:50:24 <matthew-_> but I think the level 9 vegan - doesn't cast a shadow is from somewhere else
07:50:27 <sw17ch> wow, funnest
07:50:36 <sw17ch> please, some one tell me where i can hand in my geek badge
07:50:43 <quicksilver> http://en.wikiquote.org/wiki/The_Simpsons/Season_12#Lisa_the_Tree_Hugger_.5B12.04.5D
07:50:45 <lambdabot> http://tinyurl.com/4ys5vc
07:51:04 <Philippa> matthew-_: yeah, somewhere that wanted to run with the vegan = malnourished stereotype
07:51:27 <zachk> i dont dig tofu, it is disgusting, do you know anyone who eats soy beans? its not even a food
07:51:31 <Philippa> (granted, I've seen more than one example of someone with an eating disorder also going vegan, but that's not the point)
07:52:02 <matthew-_> Philippa: yup.
07:52:05 <quicksilver> gently cooked soy beans - edamame - are delicious.
07:52:13 <quicksilver> as served in the UK by wagamama, for example.
07:53:08 <Philippa> that's a point, I could go there still
07:53:23 <Philippa> ...wait, no. Bad call when one of the diners involved's dyspraxic, really bad call
07:53:41 <zachk> dyspraxic?
07:54:00 <Philippa> zachk: like dyslexia for movement, if you like
07:54:17 * quicksilver secretly harbours a theory that Philippa chooses her friends in order to maximise some secret set of adjectives.
07:54:27 <BeelsebobWork> lol
07:54:36 <pmurias> zachk: i eat eat soy with meat souce
07:54:37 <BeelsebobWork> maybe that's why she's a haskell geek
07:54:47 <Philippa> quicksilver: hah. Let's just say I don't have to?
07:54:49 <BeelsebobWork> one of the necessary friends is a functional programmer
07:55:07 <zachk> can you include yourself as a friend?
07:55:09 <matthew-_> is there a term for a dyslexia of monads?
07:55:13 <quicksilver> I was introduced to wagamama by Conor.
07:55:19 <quicksilver> That almost makes this on-topic again.
07:55:29 <r3m0t> wagamama is samey
07:55:33 <matthew-_> quicksilver: it's worth a try...
07:55:42 <quicksilver> r3m0t: so, don't eat there every day :)
07:55:44 <r3m0t> and edamame are way overpriced in restaurants
07:55:47 <zachk> I have just been using IO and List monad with $ and lots of lambda calculus and its way better then scheme
07:55:49 <r3m0t> (topic? what topic?)
07:56:23 <Philippa> matthew-_: "eumuch"?
07:56:32 <matthew-_> r3m0t: topic is everyone is at icfp so this channel descends into random stuff that we don't normally talk about
07:56:37 <zachk> I am sure I am missing out on alot...but I like having real exes written in something other then C, I find C disgusting
07:56:52 <Philippa> matthew-_: bah, I thought the topic was the problems my birthday is causing! :-)
07:57:07 <Philippa> ...you dated someone written in a programming language?
07:57:20 <zachk> > "how do i generate random numbers in lamdabot"
07:57:21 <lambdabot>   "how do i generate random numbers in lamdabot"
07:57:22 <matthew-_> eliza
07:57:32 <quicksilver> > randoms (mkStdGen 42)
07:57:33 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
07:57:38 <Philippa> @go cybering eliza
07:57:40 <lambdabot> No Result Found.
07:57:49 <Philippa> wow
07:57:50 <BeelsebobWork> @29d6
07:57:50 <lambdabot> Unknown command, try @list
07:57:55 <BeelsebobWork> @die 29d6
07:57:56 <lambdabot> 29d6 => 90
07:58:03 <ski> @vixen how do i generate random exes in lambdabot?
07:58:03 <lambdabot> yes, you do
07:58:04 <zachk> >> randoms (mkStdGen 1)
07:58:13 <zachk> > randoms (mkStdGen 1)
07:58:14 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
07:58:21 <BeelsebobWork> @die 1d10000000
07:58:21 <lambdabot> 1d10000000 => 8310543
07:58:26 <pmurias> how should i index the Pugs source code to be able to search where a given type is defined
07:58:29 <Philippa> @die already
07:58:30 <lambdabot> unexpected "a": expecting number
07:58:53 <quicksilver> pmurias: hasktags?
07:59:00 <Philippa> pmurias: quickest'd be to grep for "data TypeName", "type TypeName" or "newtype TypeName"?
07:59:28 <ski> @die 1d0
07:59:28 <lambdabot> 1d0 => 0
07:59:28 <zachk> > take 2 $ (\x->(mod x 6)+1) $ randoms (mkStdGen 6)
07:59:29 <lambdabot>       No instance for (Integral [a])
07:59:30 <lambdabot>        arising from a use of `mod' at <i...
07:59:46 <matthew-_> yeah, generate tags with hasktags and then just M-. in the one-true-editor
08:00:05 <zachk> > take 2 $ (\x->(mod (abs.fromIntegral x 6)+1) $ randoms (mkStdGen 6)
08:00:05 <lambdabot>   mueval: Prelude.read: no parse
08:00:09 <Deewiant> > randomRs (0,10) (mkStdGen 6)
08:00:11 <lambdabot>   [5,8,1,8,2,8,9,7,1,4,6,2,5,8,6,2,10,0,7,10,10,9,7,7,2,1,10,0,0,5,0,4,5,1,3,...
08:00:22 <matthew-_> ...because when you're off-topic already, starting an editor flame-war *is* appropriate...
08:00:32 <zachk> > take 2 $ (\x->((mod (abs $ fromIntegral x 6)+1)) $ randoms (mkStdGen 6)
08:00:33 <lambdabot>   mueval: Prelude.read: no parse
08:00:49 <Deewiant> zachk: needs a 'map'
08:00:53 <Deewiant> (at least)
08:01:02 <zachk> > take 2 $ map (\x->((mod (abs $ fromIntegral x 6)+1)) $ randoms (mkStdGen 6)
08:01:03 <lambdabot>   mueval: Prelude.read: no parse
08:01:13 <Deewiant> your mod takes only one parameter
08:01:18 <Deewiant> and your fromIntegral takes 2
08:01:47 <zachk> > take 2 $ map (\x->((mod (abs $ fromIntegral x) 6)+1)) randoms (mkStdGen 6)
08:01:48 <lambdabot>   Couldn't match expected type `[a]'
08:02:06 <zachk> enough time for data structures from someone who used to program with punch cards. latter
08:02:10 <BeelsebobWork> > take 2 . map (\x->((mod (abs $ fromIntegral x) 6)+1)) $ randoms (mkStdGen 6)
08:02:12 <lambdabot>   [3,3]
08:09:51 <araujo> hello
08:10:17 <araujo> anybody knows a 'copyFile' version that can refer to an existing directory?
08:12:27 <BeelsebobWork> araujo: you'll find an implementation of that in my mkbndl package on hackage
08:12:41 <BeelsebobWork> it's not abstracted into a library though, so you'll need to copy/pasta
08:12:56 <araujo> aaah, thanks Beelsebob
08:13:00 <araujo> that will make it
08:13:49 * araujo thinks Beelsebob isn't that bad as he was told
08:14:03 * BeelsebobWork ponders what araujo was told about me
08:14:11 <araujo> hah
08:14:31 <araujo> well, the other Beelsebob :-P
08:14:40 <BeelsebobWork> oh, *giggle*
08:15:12 <ski> what Beelsebob told his grandson ?
08:16:35 <pcc1> is there an easy way of searching through a TH data structure for all (say) ConP's and substituting as required, without having to write all the necessary cases oneself?
08:17:50 <BONUS> 4th monad rule: monads rule
08:17:59 <r3m0t> MONADS RULE OK
08:18:06 <BONUS> monads mo problems
08:18:12 <BONUS> ok just 2 puns i wanted to get out of my system
08:18:46 <RayNbow> > "monads" >> "rule" >> "ok!"
08:18:47 <lambdabot>   "ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!ok!"
08:18:57 <BeelsebobWork> hehe
08:18:58 <RayNbow> lambdabot agrees
08:19:20 <ski> in other news, monads ruled ok on online forum
08:19:26 <Saizan> pcc1: yes, with Data.Generics
08:19:53 * osfameron boggles
08:20:05 <r3m0t> RayNbow: how...?
08:20:13 <BeelsebobWork> Saizan: be careful recommending that -- it's gone in base-4
08:20:28 <r3m0t> :t (>>)
08:20:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:20:52 <r3m0t> :t ($(>>"ok!"))
08:20:53 <lambdabot> forall b a. (([a] -> [Char]) -> b) -> b
08:20:55 <Saizan> BeelsebobWork: it'll be in syb, i guess?
08:21:08 <BeelsebobWork> Saizan: I think that's where I found bits of it
08:21:18 <BeelsebobWork> it appeared to get spread out a bit
08:22:13 <quicksilver> pcc1: uniplate is good at that kind of thing.
08:22:24 <quicksilver> (and a more pleasant API, in my opinion, than Data.Generics)
08:23:22 <pcc1> Saizan, quicksilver: thanks
08:26:11 <nha__> theyre replacing Data.generics?
08:26:54 <BONUS> is there a way to get this forall type signature with kinds to show in ghci?
08:27:08 <Philippa> nha__: no, uniplate doesn't do everything Data.Generics does
08:27:13 <Philippa> it's just another option
08:27:26 <nha__> ah
08:29:22 <quicksilver> nha__: not replacing, no, just splitting it out of base.
08:29:41 <quicksilver> the goal is to make base as small as possible
08:30:33 <Deewiant> BONUS: -fglasgow-exts, not sure which extension is responsible
08:31:20 <pmurias> is it possible to make hoogle search my source tree?
08:31:45 <quicksilver> -XKindSignatures IIRC
08:32:14 <Deewiant> quicksilver: nope
08:32:19 <quicksilver> ah well.
08:32:33 <quicksilver> apparently IRW
08:32:35 <Deewiant> it does recognize the flag though
08:32:46 <Deewiant> IRW?
08:35:16 <BONUS> IRW?
08:35:41 <BMeph> BONUS, Deewiant: He recalled wrongly.
08:35:56 <BONUS> ah
08:35:57 <Deewiant> well, that was a new one :-)
08:36:20 <BONUS> although what kind of kind does it infer for class Foo f where bar :: f a
08:36:53 <Deewiant> bar :: forall (f :: * -> *) a. (Foo f) => f a
08:37:14 <BONUS> wait no hmm i didnt mean that
08:37:19 <BONUS> let me try and remember the example
08:37:37 <BONUS> hmm
08:37:45 <BONUS> could that also be * -> (* -> *)
08:37:49 <BONUS> no
08:37:53 <BONUS> (* -> *) -> *
08:38:13 <quicksilver> no.
08:38:19 <quicksilver> because 'bar' is a method, so it has a ground type.
08:38:45 <quicksilver> oh, I see where you're coming from.
08:38:46 <BONUS> yeah
08:39:18 <BONUS> f could take a (* -> *) and produce a ground type i think
08:39:18 <quicksilver> type variables which are unconstrained, kind-wise, are assumed *
08:39:24 <quicksilver> so in this case, a will be assumed *
08:39:28 <BONUS> ah
08:39:30 <BONUS> thats what i thought
08:39:31 <BONUS> but wasnt sure
08:45:49 <quicksilver> BONUS: I'm not sure there are any values of type forall f :: (* -> *) -> *, a :: * -> * . f a
08:46:09 <quicksilver> even if you fix f
08:52:41 <BONUS> yeah
08:52:54 <BONUS> i was just talking hypthotetically about how it infers kinds
08:53:01 <BONUS> because there are some kinds which are undecideable
08:53:26 <BONUS> as it would seem to em
08:53:27 <BONUS> me
09:05:51 * dons waves from ICFP
09:05:54 <dons> everyone's here. yaya.
09:06:02 * osfameron waves
09:06:09 <osfameron> I'll go next year when it's in Edinburgh!
09:06:17 <BeelsebobWork> ohhhh, edinburgh?
09:06:19 <BeelsebobWork> I may go too
09:06:27 <conal> (icfp) butler lampson just started speaking
09:09:17 <dons> i'm twittering for galois about it, http://twitter.com/galoisinc
09:09:22 <lambdabot> Title: Twitter / galoisinc
09:10:42 <matthew-_> oooo. I like edinburgh
09:10:52 <matthew-_> hmm. I could go up for the festival and just stay there
09:11:17 <matthew-_> is there a live audio feed from icfp?
09:11:24 <matthew-_> a la anglohaskell 2008?!
09:11:40 <dons> no, ACM...
09:11:46 <dons> it is all being video taped
09:22:26 <zachk> > randoms (mkStdGen 42)
09:22:28 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
09:23:21 <zachk> map (\x->(1+(mod (abs $ fromIntegral x) 6)) $ randoms (mkStdGen 42)
09:23:28 <zachk> > map (\x->(1+(mod (abs $ fromIntegral x) 6)) $ randoms (mkStdGen 42)
09:23:29 <lambdabot>   mueval: Prelude.read: no parse
09:23:44 <matthew-_> zack, that won't give uniform results
09:23:50 <matthew-_> *zachk
09:23:54 <zachk> why not
09:24:00 <matthew-_> as the positive range is bigger than the negative range
09:24:11 <ehtom> wow... I just wrote my first non c-like haskell program... infinite lists are very nice in haskell
09:24:18 <matthew-_> err, mmm. depends if it's int or integer I guess
09:24:52 <Saizan> > map (\x->(1+(mod (abs $ fromIntegral x) 6))) $ randoms (mkStdGen 42)
09:24:53 <lambdabot>   [4,2,6,6,5,4,6,3,1,6,2,6,3,2,3,2,4,1,5,4,5,2,4,4,5,4,1,3,4,1,3,4,5,4,1,6,4,...
09:25:06 <zachk> > map (\x->(mod x 6) $ map fromIntegral $ randoms (mkStdGen 42)
09:25:07 <lambdabot>   mueval: Prelude.read: no parse
09:25:24 <matthew-_> certainly bugs like that have lead to exploits based on rng issues in the past
09:25:28 <matthew-_> *led
09:25:35 <matthew-_> I can't spell. *sigh*
09:25:42 <zachk> > map (\x->(mod x 6)) $ map fromIntegral $ randoms (mkStdGen 42)
09:25:43 <lambdabot>   [3,5,1,5,2,3,5,4,0,5,5,1,2,1,2,5,3,0,4,3,4,5,3,3,2,3,0,2,3,0,2,3,2,3,0,1,3,...
09:25:50 <sheyll> hi
09:26:18 <sheyll> > extendSequence [1,2,3]
09:26:20 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
09:26:36 <sheyll> > extendSequence [1,2,4]
09:26:38 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:26:57 <sheyll> > extendSequence [1,4,9]
09:26:59 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
09:27:03 <matthew-_> > extendSequence [2,3,5,7,11]
09:27:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:27:20 <ehtom> > extendSequence [1, 11, 21,]
09:27:20 <Deewiant> > extendSequence [2]
09:27:21 <lambdabot>   mueval: Prelude.read: no parse
09:27:21 <lambdabot>  Terminated
09:27:26 <PeakerWork> > extendSequence [1,11,21,1211,111221,312211]
09:27:28 <lambdabot>   [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,132113111231...
09:27:29 <ehtom> > extendSequence [1, 11, 21]
09:27:31 <lambdabot>   [1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,92,3,13,23,33,43,53...
09:27:39 <PeakerWork> nice, it knows that one :)
09:27:41 <ehtom> omg
09:27:43 <ehtom> how does it know?
09:27:44 <matthew-_> hmm. this is quite magical
09:27:47 <Deewiant> it uses oeis
09:27:50 <sw17ch> > extendSequence [1,3,9]
09:27:51 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
09:27:53 <Deewiant> behind a bit of unsafePerformIO
09:27:57 <Deewiant> (IIRC)
09:28:02 <ehtom> oeis?
09:28:09 <Deewiant> ?go oeis
09:28:10 <ehtom> is that the big lookup library?
09:28:11 <lambdabot> http://www.research.att.com/~njas/sequences/
09:28:11 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
09:28:17 <Deewiant> yes
09:28:20 <sheyll> > extendSequence [1,2,5]
09:28:20 <ehtom> bleh... thats cheating :P
09:28:21 <lambdabot>   [1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
09:28:27 <Deewiant> :-P
09:28:29 <sw17ch> actually, how does the 1,11,21 sequence work?
09:28:38 <Deewiant> figure it out :-)
09:28:41 <ehtom> one, one one, two ones
09:28:42 <sheyll> > explainSequence [1,2,5]
09:28:42 <ehtom> etc
09:28:43 <lambdabot>   mueval: Prelude.read: no parse
09:28:54 <sw17ch> ohhhh...
09:29:03 <Deewiant> http://hackage.haskell.org/packages/archive/oeis/0.2/doc/html/Math-OEIS.html
09:29:07 <ehtom> its a word sequence as opposed ot a maths one really
09:29:10 <lambdabot> Title: Math.OEIS, http://tinyurl.com/4g7zw4
09:29:13 <ehtom> ot -> to
09:29:13 <ehtom> :P
09:29:23 <Deewiant> > lookupSequence [1,11,21,1211]
09:29:28 <lambdabot>   Just (OEIS {catalogNums = ["A005150","M4780"], sequenceData = [1,11,21,1211...
09:29:56 <matthew-_> > drop 10^10 $ extendSequence [2,3,5,7,11]
09:29:57 <lambdabot>       No instance for (Num ([Integer] -> [Integer]))
09:29:57 <lambdabot>        arising from a us...
09:29:59 <sheyll> > lookupSequence [1,2,5]
09:30:01 <lambdabot>   Just (OEIS {catalogNums = ["A000108","M1459","N0577"], sequenceData = [1,1,...
09:30:04 <Deewiant> I love the "example usage" there :-)
09:30:34 <Deewiant> > description <$> lookupSequence [1,11,21,1211]
09:30:36 <lambdabot>   Just "Look and Say sequence: describe the previous term! (method A - initia...
09:32:03 <ehtom> > extendSequence [2,3,5,7,11,13]
09:32:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:32:14 <ehtom> > extendSequence [2,3,5,7,11,13,17,23]
09:32:16 <lambdabot>   [2,3,5,7,11,13,17,23,37,47,61,73,83,101,103,107,131,137,151,173,181,233,241...
09:32:33 <ehtom> bah
09:32:43 <Deewiant> > description <$> lookupSequence [2,3,5,7,11,13,17,23]
09:32:45 <lambdabot>   Just "Numbers n such that n and 6n+1 are primes."
09:35:49 <ehtom> given a recursive list definition, how can I make haskell multithread it?
09:36:22 <Beelsebob> ehtom: using the par function, and the definitions in Control.Parallel.Strategies
09:36:31 <ehtom> ok
09:36:34 <ziman> > description <$> lookupSequence [3,7,13,37,43,67,73,79,97,127]
09:36:35 <lambdabot>   Just "Numbers n such that n and 4n + 1 both prime."
09:37:46 <PeakerWork> `fmap` is possibly easier to type than <$>
09:40:27 <ehtom> beelsebob: are there examples anywhere?
09:41:25 <dons> Beelsebob: did you see today's scores?
09:41:37 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=all
09:41:39 <lambdabot> Title: binary-trees benchmark | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Languag ..., http://tinyurl.com/69l8ag
09:41:45 <dons> probably temporary, due to GC hints.
09:41:56 <dons> Beelsebob: and overall, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=0&xloc=0&binarytrees=1&chameneosredux=0&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&meteor=0&nbody=1&pidigits=1&regexdna=1&revcomp=1&spectralnorm=1&threadring=1&calc=calculate
09:41:58 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/4yz5lw
09:42:01 <dons> but we need more parallel programs.
09:42:06 <dons> that #1 slot is so close...
09:42:32 <ehtom> what is ats
09:42:35 <dons> paralell regex-dna perhaps, based on the C++ one.
09:42:46 <dons> ehtom: dependently typed language with many parallel entries
09:43:07 <ehtom> also, that benchmark is very suspicious to me, since it lacks Intel C++ compiler, which everyone knows is the win
09:43:24 <dons> intel C++ on amd64 quad core?
09:43:32 <ehtom> q6600 = intel
09:43:35 <dons> ah.
09:43:47 <dons> then its a matter of time till the intel compiler becomes available
09:43:53 <ehtom> it already is
09:44:11 <ehtom> its horribly fast
09:44:16 <ehtom> but you need to use C++ :P
09:44:29 <dons> its a matter of time till its installed on the shootout box, i meant.
09:44:49 <ehtom> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
09:44:51 <lambdabot> Title: Create your own Ranking | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language Benchma ..., http://tinyurl.com/lepfo
09:44:55 <dons> right
09:45:12 <dons> that's the single core intel 32 bit box.
09:45:49 <dons> ATS is fast on single core too, i notice.
09:45:52 <dons> http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=all
09:45:54 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/4lrsyg
09:46:17 <quicksilver> ehtom: multithreading a recursive list is troublesome because recursive lists tend to have tight data dependencies making it hard to usefully multithread.
09:46:30 <quicksilver> I mean, adding the code annotaitons is easy :)
09:46:38 <quicksilver> but getting better than 100% core usage is hard.
09:46:53 <Deewiant> those ATS benchmarks are just terrible, code-wise.
09:47:12 <quicksilver> Deewiant: speaking as someone who knows ATS? or just they look terrible?
09:47:16 <ehtom> main thing is that haskell would appear to be the cleanest language out of the fast languages
09:47:28 <dons> Deewiant: why?
09:47:34 <ehtom> quicksilver: is there a haskell version of openmp or anything?
09:47:35 <Deewiant> quicksilver: they look terrible, and appear to be half written in C
09:47:38 <dons> ehtom: oh hmm. that's a good point.
09:47:40 <Deewiant> for instance, http://shootout.alioth.debian.org/u64/benchmark.php?test=regexdna&lang=ats&id=1
09:47:42 <lambdabot> Title: regex-dna ATS program | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Language ..., http://tinyurl.com/3ea8om
09:47:48 <dons> if you want high level parallelism -> haskell.
09:47:49 <Deewiant> half ATS, half C, from the look of it
09:48:27 <quicksilver> I was looking at the inline C, yes.
09:48:32 <quicksilver> dons: surely inline C can't be allowed?
09:48:40 <ehtom> thats kinda pointless
09:48:45 <ehtom> inline C
09:48:47 <quicksilver> dons: otherwise you could hack together Inline.C and then just use the gcc code :P
09:48:59 <Deewiant> http://www.reddit.com/r/programming/comments/72hmw/language_shootout_ats_is_the_new_top_gunslinger/c05i9ju complains about it
09:49:01 <lambdabot> Title: mfp comments on Language Shootout: ATS is the new top gunslinger. Beats C++., http://tinyurl.com/53h2z4
09:50:01 <quicksilver> ehtom: openmp? Isn't that a large ugly API attempting to shoehorn concurrency into languages with no native support for it?
09:50:04 <quicksilver> </troll>
09:50:21 <ehtom> "yes"
09:50:43 <quicksilver> ehtom: but seriously, do you have any concrete examples of stuff that openmp does that Control.Concurrent + Control.Parallel don't do?
09:50:52 <ehtom> I have zero
09:51:12 <ehtom> because I don't know how to use control.concurrent and control.parallel... i'm looking for a tutorial
09:51:26 <Deewiant> parMapM?
09:52:40 <Deewiant> i.e. a parallel for loop which does IO
09:53:44 <ehtom> are there any pages with simple examples like "how to parallelize fibs = 0:1: [i + j | (i,j) <- zip fibs (tail fibs)]"
09:54:00 <newsham> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
09:54:02 <lambdabot> Title: Chapter 24. Concurrent and multicore programming, http://tinyurl.com/3frdnx
09:54:31 <ehtom> wow... theres a whole free book on the net
09:54:33 <ehtom> thanks!
09:54:54 <newsham> second half of the chapter discusses "par" and friends
09:54:55 <Saizan> fibs is one of those recursively defined lists with tight data dependency
09:55:17 <Deewiant> intuitively I'd say that parallelizing fibs is useless
09:55:21 <Deewiant> I could be wrong
09:55:44 <newsham> is there a closed form for the fib sequence?
09:55:49 <ehtom> yes
09:55:58 <newsham> so you could parallelize that easily
09:56:07 <ehtom> ((1+sqrt(5))/2) ^ n + stuff
09:56:08 <ehtom> or something
09:56:17 <ehtom> well, I was just using fibs as an example
09:56:44 <newsham> here's some examples: http://haskell.org/haskellwiki/Shootout/Parallel
09:56:45 <lambdabot> Title: Shootout/Parallel - HaskellWiki
09:57:27 <ehtom> my actual problem is runge kutta: x = initalvalue : [ nextrunge yn n step | (yn,n) <- zip x [0,1..] ]
09:57:37 <chrisdone> > let diff x y = [ z | z <- x ++ y, z `notElem` x || z `notElem` y ] in [1,2,3,4] [3,4,5,6]
09:57:38 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
09:57:46 <chrisdone> > let diff x y = [ z | z <- x ++ y, z `notElem` x || z `notElem` y ] in diff [1,2,3,4] [3,4,5,6]
09:57:47 <lambdabot>   [1,2,5,6]
09:57:57 <chrisdone> anyone got a shorter solution?
09:58:19 <daf> heh, giving equal weight to time/memory/size brings Pascal to the top
09:58:22 <Deewiant> > [1,2,3,4] \\ [3,4,5,6]
09:58:23 <lambdabot>   [1,2]
09:58:24 <daf> leaving out memory puts Haskell first
09:58:37 <ehtom> daf: on what test?
09:58:41 <Deewiant> yeah, haskell's memory usage is troublesome
09:58:47 <daf> ehtom: all of them
09:58:55 <daf> Pascal is missing 5 though
09:59:03 <chrisdone> > let diff x y = [ z | z <- x ++ y, z `notElem` intersect x y ] in diff [1,2,3,4] [3,4,5,6]
09:59:04 <lambdabot>   [1,2,5,6]
09:59:33 <dons> Deewiant: to who?
09:59:42 <dons> oh, the parallel programs use more memory, that's true.
09:59:43 <Deewiant> > let diff x y = (x \\ y) ++ (y \\ x) in diff [1,2,3,4] [3,4,5,6]
09:59:45 <lambdabot>   [1,2,5,6]
09:59:50 <ehtom> daf: no it doesn't... time=1,mem=0,size=1 gives C++ Intel as the fastest
09:59:55 <Deewiant> dons: in general
10:00:11 <dons> depends on what you mean by "troublesom" :)
10:00:19 <Deewiant> whether it actually matters in most cases is up for debate, of course :-P
10:00:21 <daf> ehtom: I blame this crappy web interface then
10:00:23 <dons> harder to reason about: yes, in generally poor: definitely not.
10:00:30 <newsham> dons: are shootout programs allowed to use hackage packages?
10:00:41 <dons> newsham: on a case by case basis.
10:00:50 <dons> newsham: if at all possible, try not to use anything other than extralibs
10:00:56 <dons> i.e. what is available in an ubuntu package.
10:00:57 <ehtom> haskell should really be beating java though :S
10:01:08 <dons> it is?
10:01:14 <ehtom> not quite
10:01:16 <dons> and on 1/10000 the budget :)
10:01:19 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
10:01:21 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
10:01:22 <ehtom> well exacly
10:01:23 <newsham> for some reason the regex-dna lib doesnt compile for me in ghc6.8.2 using Text.Regex.Posix
10:01:30 <matthew-_> don't underestimate java
10:01:30 <newsham> but it does work (and is probably faster) w/ Text.Regex.PCRE
10:01:35 <ehtom> that set of benchmarks is bad imo
10:01:46 <ehtom> ats is at the top, when the code is dodge... also, no icc
10:01:50 <newsham> ehtom: they're benchmarks. of course they're bad :)
10:01:52 <dons> ehtom: hehe. why?
10:01:59 <dons> sure. there's lots of missing things.
10:02:00 <ehtom> also no java -Xm64s
10:02:07 <dons> just wait..
10:02:12 <ehtom> the gentoo one is alot better
10:02:25 <newsham> dons: any idea how to get the original regex-dna to compile (or why it doesnt for me)?
10:02:30 <Deewiant> dons: well, just looking at the shootout GHC appears to use between 2-5 times (2-15 times in the parallel ones) more memory than the equivalent C
10:02:35 <matthew-_> does the sun hotspot jit take advantage of x86 cpu extensions?
10:02:44 <dons> Deewiant: yeah, we've not tried at all to control memory use
10:02:54 <Deewiant> yeah, I figured
10:02:57 <dons> i'd expect it to use more memory than C though :)
10:03:00 <ehtom> the sun jit is very clever, it does everything
10:03:13 <matthew-_> right, so it's not really surprising it beats ghc
10:03:15 <ehtom> its the only reason java, which used to be hella slow is fastish now
10:03:18 <daf> there's a tension between code size and speed
10:03:19 <Deewiant> maybe after beating all languages in terms of CPU, we should start beating them in memory usage as well :-)
10:03:24 <dons> yeah. sure.
10:03:38 <daf> it's a shame that entries are optimised for speed in a way
10:03:54 <daf> ideally, of course, comprehensiblity would be objective :)
10:04:09 <ehtom> speed doesn't mean *that* much, way I see it is that haskell is like python, except fast
10:04:09 <Deewiant> dons: I'm just a bit annoyed at seeing haskell drop to the middle when all the multipliers are at 1
10:04:12 <chrisdone> benchmarks only exist to make fun of ruby
10:04:28 <matthew-_> @remember chrisdone benchmarks only exist to make fun of ruby
10:04:29 <lambdabot> Good to know.
10:04:44 <geezusfreeek_> that would be to make fun of Io
10:04:44 <ehtom> and python is about 10x more productive than java
10:04:55 <dons> ehtom: that's about right. well, also a bit fancier than python, but used for the same things.
10:05:04 <geezusfreeek_> i think haskell has almost nothing in common with python
10:05:16 <ehtom> fast programming :P
10:05:28 <ehtom> but yeah, other than that they're opposites
10:05:31 <daf> ehtom: ah, I was looking at the 64bit one
10:05:32 <besiria> omg ghc beats gcc in shootout quad
10:05:35 <besiria> gratz
10:05:36 <ddarius> chrisdone: That's the main thing I've gotten from it.
10:05:43 <newsham> they both have list comprehensions :)
10:05:52 <ehtom> besiria: please please ignore those benchmarks, they're dodge
10:06:35 <ehtom> imperative dynamic typed interpreted vs functional static typed compiled lazy evaluation
10:06:36 <ehtom> :P
10:06:37 <newsham> the quad game is just getting started
10:06:42 <newsham> new high scores expected
10:06:50 <dons> yes, we're seeing the first corner of the race.
10:06:55 <dons> there's still 60 laps to go
10:07:01 <ehtom> newsham: yeah, well I heard that haskell is the way to go for parallel processing
10:07:29 <besiria> hope so
10:07:49 <newsham> ehtom: you can hand code some pretty complicated and fast benchmarks in C, esp when the problems are small
10:08:04 <ehtom> of course C/C++ will always beat everything else
10:08:08 <ehtom> but so what?
10:08:15 <daf> not necessarily
10:08:32 <ehtom> C is practically assembler
10:08:49 <newsham> you can use assembler in your C shootout problems
10:08:59 <ehtom> what exactly is the point in that?
10:09:13 <ehtom> static void main () { nasm {} } :P
10:09:29 <newsham> hey, thats part of C.. why not allow it?
10:09:43 <newsham> soln might suffer on the sizeB metric
10:09:48 <ehtom> well its kinda pointless to do that imo
10:10:10 <newsham> python is tops in size metric right now
10:10:18 <newsham> ghc at 1.8
10:10:37 <ehtom> size of program isn't an issue these days
10:10:45 <newsham> sometimes it is.
10:10:47 <newsham> sometimes its not
10:10:54 <ehtom> it practically never is
10:10:59 <Deewiant> it's size of code
10:11:08 <daf> (source)
10:11:09 <newsham> thats what size i'm talking about
10:11:15 <ehtom> oh
10:11:24 <ehtom> so python has the shortest actual code?
10:11:29 <ehtom> I thought sizeB was binary size
10:11:36 <besiria> wtf is ATS language?
10:11:38 <Deewiant> sizeB[ytes], I think
10:12:04 <daf> ehtom: that would give interpreted languages quite an advantage :)
10:12:07 <Deewiant> besiria: http://www.ats-lang.org/
10:12:18 <lambdabot> Title: Home Page for ATS
10:12:19 <ehtom> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=all&lang2=icpp <-- that's very interesting
10:12:21 <chrisdone> besiria: looks pretty horrific to me
10:12:22 <lambdabot> Title: thread-ring benchmark | Gentoo : IntelÂ® PentiumÂ® 4 Computer Language Benchmark ..., http://tinyurl.com/47xt45
10:12:34 <ehtom> besiria: the ATS examples are 90% embedded C... ignore it
10:12:47 <Deewiant> not 90%, but enough that it doesn't count :-P
10:13:19 <dan_> > liftM2 [1..10] [1..10]
10:13:20 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
10:13:22 <besiria> chrisdone: it surely is. but it performs very well.
10:13:28 <dan_> ?src liftM2
10:13:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:13:36 <dan_> > liftM2 (,) [1..10] [1..10]
10:13:37 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
10:13:53 <Deewiant> > liftM2 (+) [1..10] [1..10]
10:13:55 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
10:15:03 <chrisdone> @src zipWith
10:15:04 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
10:15:04 <lambdabot> zipWith _ _      _      = []
10:16:07 <Deewiant> @check \a b -> zipWith (,) a b == liftM2 (,) a b
10:16:09 <lambdabot>   "Falsifiable, after 3 tests:\n[()]\n[(),(),()]\n"
10:18:20 <BONUS_> @src ap
10:18:20 <lambdabot> ap = liftM2 id
10:35:59 <pcc1> I have this code to match a particular TH constructor pattern: 'patternAsWild (ConP name str) | name == mkName "EasyPatterns.CTP" = WildP' but it doesn't seem to match
10:36:00 <olejorgenb> hm.. if I type
10:36:04 <olejorgenb> factorial n = if n == 0 then 1 else n * factorial (n - 1)
10:36:06 <olejorgenb> in hugs
10:36:27 <olejorgenb> I get Syntax error in input (unexpected '=')
10:41:20 <dan_> let factorial n = if n == 0 then 1 else n * factorial (n - 1); in factorial 10
10:41:23 <dan_> > let factorial n = if n == 0 then 1 else n * factorial (n - 1); in factorial 10
10:41:25 <lambdabot>   3628800
10:41:31 <dan_> seems fine to me
10:41:36 <dan_> you probably have an indentation problem
10:41:59 <dan_> > let factorial n = if n == 0 then 1 else n * factorial (n - 1); in factorial 2
10:42:00 <lambdabot>   2
10:42:14 <dan_> > let factorial n = if n == 0 then 1 else n * factorial (n - 1); in map factorial [1..20]
10:42:15 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
10:42:46 <dan_> olejorgenb
10:43:33 <olejorgenb> hm.. I type "factorial n = if n == 0 then 1 else n * factorial (n - 1)" directly in the prompt, maybe that's the problem? (everything is in one line=
10:44:00 <dan_> you don't have to
10:44:12 <olejorgenb> placing let in front give me unexpected end of input
10:44:19 <dan_> you don't want let
10:44:30 <dan_> let is just so lambdabot can parse a function
10:44:40 <dan_> and we can put a function inline in the channel
10:44:55 <olejorgenb> any other simple haskell expression I can try?
10:44:59 <dan_> check your intentation
10:45:02 <dan_> *indentation
10:45:32 <olejorgenb> but I don't have any :)
10:45:44 <dan_> oh
10:45:46 <dan_> oh
10:45:46 <dan_> yea
10:45:48 <dan_> do what i did
10:45:57 <dan_>  let factorial n = if n == 0 then 1 else n * factorial (n - 1); in map factorial [1..20]
10:46:14 <olejorgenb> sweet
10:46:20 <dan_> let <define functions or symbold> in <some expression to evaluate>
10:46:35 <dan_> capische?
10:46:44 <ehtom> factorial 0 = 1 factorial n = n * (factorial n -1)
10:46:45 <ehtom> :P
10:46:52 <olejorgenb> what if I want to add a function to the "global" namespace?
10:47:05 <dan_> you have to load a file
10:47:06 <olejorgenb> sorry, I should go read a tutorial :P
10:47:08 <dan_> it's not like lisp
10:47:10 <olejorgenb> ok
10:47:14 <dan_> where you can define anything at the prompt
10:47:28 <dan_> the prompt allows you to use the let syntax
10:47:43 <dan_> but you don't have access to any scopes, i beleive
10:47:57 <dan_> global or otherwise, outside your function
10:48:45 <mmorrow> in ghci you're sitting in a do block of the IO monad
10:49:18 <mmorrow> (literally)
10:51:13 <mmorrow> pccl: use the ''CTP notation (or 'CTP if CTP is a datacon)
10:51:26 <mmorrow> , ''[]
10:51:27 <lunabot>  GHC.Types.[]
10:51:30 <mmorrow> , '[]
10:51:30 <lunabot>  GHC.Types.[]
10:51:53 <mmorrow> , ''(,)
10:51:54 <lunabot>  GHC.Tuple.(,)
10:51:56 <mmorrow> , '(,)
10:51:56 <lunabot>  GHC.Tuple.(,)
10:52:00 <mmorrow> , ''Int
10:52:01 <lunabot>  GHC.Types.Int
10:52:03 <mmorrow> , 'Int
10:52:03 <lunabot>   Not in scope: data constructor `Int'
10:52:15 <Taral> , 'I3
10:52:16 <lunabot>   Not in scope: data constructor `I3'
10:52:19 <Taral> , 'i#
10:52:19 <lunabot>   Not in scope: `i'
10:52:19 <lunabot>  <interactive>:1:52: Not in scope: `#'
10:52:21 <Taral> hm
10:52:30 <mmorrow> , pp $(lift =<< reify ''Int)
10:52:31 <lunabot>  data Int = I# Int#
10:52:52 <mmorrow> (the {data,type}cons you're referencing have to be in scope)
10:53:04 <mmorrow> 'DataCon
10:53:07 <mmorrow> ''TyCon
10:53:23 <mmorrow> , ''(->)
10:53:23 <lunabot>  GHC.Prim.(->)
10:53:35 <mmorrow> , '(:)
10:53:36 <lunabot>  GHC.Types.:
10:53:49 <mmorrow> if you want to clean the name
10:54:01 <mmorrow> , (mkName . nameBase) ''Int
10:54:01 <lunabot>  Int
10:54:21 <mmorrow> , [|fmap id [0..9]|]
10:54:22 <lunabot>  AppE (AppE (VarE fmap) (VarE id)) (ArithSeqE (FromToR (LitE (IntegerL 0)) (L...
10:54:40 <mmorrow> oh, this instance of show already does the cleaning
10:56:27 <mmorrow> , let f name | name == ''Int = "asdf" | otherwise = [] in f (mkName "Int")
10:56:27 <lunabot>  ""
10:56:33 <mmorrow> , let f name | name == ''Int = "asdf" | otherwise = [] in f ''Int
10:56:33 <lunabot>  "asdf"
10:58:19 <birkenfeld> hmm, why can't I overload string literals to be a Parsec parser?
11:00:54 <Heffalump> birkenfeld: what goes wrong if you try?
11:01:01 <mmorrow> you'll probably have to use the bytestring variant?
11:01:20 <peter2> @type lex
11:01:21 <lambdabot> String -> [(String, String)]
11:01:50 <subconscious> @type yacc
11:01:51 <lambdabot> Not in scope: `yacc'
11:02:17 <pcc1> mmorrow: thanks
11:02:25 <peter2> @run  let f s = [ (1,r) | [("ok",r)] <- lex s ] in f "ok test"
11:02:26 <lambdabot>   Couldn't match expected type `(String, String)'
11:03:00 <peter2> I do not see why it cannot match the type :-/
11:03:13 <mmorrow> pcc1: no prob, also feel free to mess with TH on lunabot :)
11:03:22 <mmorrow> , 42
11:03:23 <lunabot>  42
11:04:09 <mmorrow> , lex
11:04:09 <lunabot>      No instance for (Show (String -> [(String, String)]))
11:04:17 <subconscious> âª data Test = Has | This | Been | Implemented
11:04:17 <lunabot>   parse error on input `data'
11:04:19 <subconscious> :(
11:04:24 <mmorrow> ,  let f s = [ (1,r) | ("ok",r) <- lex s ] in f "ok test"
11:04:25 <lunabot>  [(1," test")]
11:04:40 <mmorrow> âª [d|data Test = Has | This | Been | Implemented|]
11:04:41 <lunabot>  DataD [] Test [] [NormalC Has [],NormalC This [],NormalC Been [],NormalC Imp...
11:04:56 <mmorrow> âª pprint [d|data Test = Has | This | Been | Implemented|]
11:04:56 <lunabot>      No instance for (Ppr (Q [Dec]))
11:05:03 <mmorrow> âª pprint `fmap` [d|data Test = Has | This | Been | Implemented|]
11:05:04 <lunabot>  data Test = Has | This | Been | Implemented
11:05:30 <peter2> ach ok....
11:05:36 <mmorrow> heh
11:07:10 <ehtom> are there any numerical pde solution algorithms which play nicely with multithreading?
11:07:46 <mmorrow> , pp (let g |.| f = [|$g . $f|] in foldr (|.|) [|id|] (replicate 7 [|flip|]))
11:07:47 <lunabot>      No instances for (Ppr ExpQ, Data ExpQ)
11:07:54 <mmorrow> , pp `fmap` (let g |.| f = [|$g . $f|] in foldr (|.|) [|id|] (replicate 7 [|flip|]))
11:07:55 <lunabot>  flip . (flip . (flip . (flip . (flip . (flip . (flip . id))))))
11:08:05 <subconscious> :t flip . (flip . (flip . (flip . (flip . (flip . (flip . id))))))
11:08:06 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:08:07 <birkenfeld> Heffalump: I think I understand it now: I define an instance for Parser String, but since I don't use the parser's outcome, it infers type Parser a
11:08:39 <mmorrow> , $(let g |.| f = [|$g . $f|] in foldr (|.|) [|id|] (replicate 7 [|flip|])) subtract 10 5
11:08:40 <lunabot>  5
11:08:42 <mmorrow> , $(let g |.| f = [|$g . $f|] in foldr (|.|) [|id|] (replicate 7 [|flip|])) subtract 10 7
11:08:43 <lunabot>  3
11:09:26 <mightybyte> Any idea why "fact 1 1000000" gives a stack overflow for the definition "let fact p 1 = p; fact p n = fact (n*p) (n-1)"?
11:09:50 <mightybyte> Since it's tail-recursive, I'd expect the recursion to be optimized away.
11:10:01 <mmorrow> probably have to force the (n*p) thunk
11:10:05 <subconscious> mightybyte: In haskell, with lazyness, tail recursion isn't relevant
11:10:08 <birkenfeld> returning undefined from the parser seems to work
11:10:20 <peter2> what is lunabot?
11:10:34 <mmorrow> , let f !x = x in f "checking if bang patterns work"
11:10:34 <lunabot>   Not in scope: `f'
11:10:40 <mightybyte> subconscious: Hmm, then what is?
11:10:42 <subconscious> mightybyte: The reason it has a stack overflow is because there is a deep chain of (...(...*)*)
11:11:07 <mightybyte> subconscious: Ok, ...because of laziness.
11:11:09 <subconscious> mightybyte: the evaluator has to go deep into it to get the value out, whereas in a strict language than n*p would be evaluated as you rceursive
11:11:16 <mmorrow> this may do it   let fact p 1 = p; fact !p n = fact (n*p) (n-1)
11:11:19 <subconscious> mightybyte: You can flatten it out as you go by using strictness
11:11:25 <mmorrow> or equivalently
11:11:33 <birkenfeld> hah, that's neat
11:11:43 <birkenfeld> args <- between "(" ")" arglist
11:11:54 <mmorrow> this may do it   let fact p 1 = p; fact p n = let p' = n*p in p' `seq` fact p' (n-1)
11:12:03 <mmorrow> s/this may do it/or equivalently/
11:12:36 <mmorrow> the (n-1) doesn't need forcing since it has to be evaluated each recursion to check if it's (==1)
11:12:37 <mightybyte> mmorrow: Hmm, ghci gives me a parse error at the '!'.
11:12:54 <mmorrow> :set --bang-patterns
11:12:56 <subconscious> mightybyte: mmorrows seq version is good
11:13:00 <mightybyte> Ok
11:13:07 <mmorrow> err, -fbang-patterns
11:13:11 <mmorrow> something like that
11:13:23 <subconscious> if you see the foo `seq` f foo pattern happen a lot you might want to abstract it
11:13:30 <subconscious> like f $! foo or something
11:13:39 <mmorrow> you can also use bangs
11:13:41 <subconscious> and infact someone already did that
11:13:53 <mmorrow> @src ($!)
11:13:53 <lambdabot> f $! x = x `seq` f x
11:14:08 <subconscious> I wonder what seq does ..
11:14:08 <mightybyte> mmorrow: I think I've seen that before.
11:14:34 <mmorrow> the $! ?
11:14:50 <mightybyte> Yeah
11:14:50 <subconscious> ?docs seq
11:14:50 <lambdabot> seq not available
11:14:56 <mmorrow> seq is magic
11:15:10 <mmorrow> it's a primitive
11:15:18 <mightybyte> Yeah
11:15:50 <subconscious> seq Evaluates its first argument to head normal form, and then returns its second argument as the result
11:16:08 <subconscious> pseq says, Semantically identical to seq, but with a subtle operational difference: seq is strict in both its arguments, so the compiler may, for example, rearrange a seq b into b seq a seq b
11:16:15 <tsar> http://hpaste.org/10607 , can someone explain to me why it doesnt work as expected?
11:16:33 <subconscious> which one of the docs is telling the truth?
11:16:37 <subconscious> :p
11:16:39 <tsar> eventually it will be some sort of grapg-visualizer
11:17:01 <subconscious> tsar: "as expected"
11:17:03 <subconscious> ?
11:17:15 <Deewiant> tsar: your toPoints uses the same generator for both sides of the zip, so of course you'll get x == y
11:19:33 <mightybyte> mmorrow: Ok, the bang pattern works great when you turn them on.
11:19:37 <mightybyte> Thanks
11:20:07 <mmorrow> cool
11:20:58 <mightybyte> So even without the strictness, is the compiler optimizing that tail recursion to iteration?
11:21:37 <subconscious> mightybyte: You're intuitions from ocaml or scheme are not good ones to keep regarding lazy languages
11:22:03 <SamB_XP> what good does iteration do if it builds a stack-blowing pile of thunks?
11:22:04 <subconscious> mightybyte: You can via strictness, embed any tail recursive proceduce directly, but much more is possible than just writing 'tail recursive' functions
11:22:10 <mmorrow> yeah, but that isn't related to whether or not you're accumulating a huge thunk of thunks of ... in one of the func's args
11:22:36 <mightybyte> subconscious: Ok, well I'm just trying to figure out how to make haskell work in the practical cases of long loops that would overflow the stack.
11:22:49 <mmorrow> after 10 iterations, it'd look like this if it wasn't being forced
11:22:49 <subconscious> mightybyte: The actual evaluation process is by graph reduction though, so the whole inductive notion of tail call doesn't actually make sense
11:23:08 <mightybyte> subconscious: Ok
11:23:09 <mmorrow> > foldl f 0 [1..9]
11:23:10 <lambdabot>   Add a type signature
11:23:15 <mmorrow> > foldl f 0 [1..9] :: Expr
11:23:17 <lambdabot>   f (f (f (f (f (f (f (f (f 0 1) 2) 3) 4) 5) 6) 7) 8) 9
11:23:21 <DroneZilla> mightybyte: you avoid map, foldr, and trust only foldl, if you don't want stack overflow
11:23:23 <subconscious> mightybyte: Yeah any tail recursive program you have in ocaml or scheme, you can write directly in haskell -- and just add seq $! or bang patterns
11:23:24 <mmorrow> and after 100 ...
11:23:25 <SamB_XP> @type f
11:23:26 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:23:37 <subconscious> DroneZilla: oh that's not at all true
11:23:45 <DroneZilla> what ?
11:23:53 <mmorrow> depends
11:23:53 <SamB_XP> foldl is the worst!
11:23:54 <DroneZilla> why ?
11:24:01 <DroneZilla> foldl is tail recursive
11:24:05 <mmorrow> > foldl' (*) 1 [1..10000]
11:24:06 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
11:24:08 <DroneZilla> not foldr and map
11:24:18 <SamB_XP> > foldl (*) 1 [1..10000]
11:24:19 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
11:24:23 <SamB_XP> hmm.
11:24:27 <SamB_XP> > foldl (*) 1 [1..1000000]
11:24:27 <mmorrow> > foldl' (++) [] (replicate 1000 [0..9])
11:24:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,...
11:24:29 <lambdabot>  Terminated
11:24:34 <SamB_XP> > foldl' (*) 1 [1..1000000]
11:24:36 <DroneZilla> > foldr (*) 1 [1..100000]
11:24:39 <mmorrow> > foldl' (++) [] (replicate 100000 [0..9])
11:24:50 <lambdabot>   thread killed
11:24:51 <lambdabot>   thread killed
11:24:54 <sw17ch> is there a generic constraint solver anywhere?
11:24:54 <lambdabot>   thread killed
11:24:58 <subconscious> DroneZilla: Did you grok my comment about embedding any tail recursive strict code in haskell?
11:25:05 <SamB_XP> > foldl (+) 1 [1..1000000]
11:25:10 <DroneZilla> subconscious: could you prcise please
11:25:12 <lambdabot>   mueval: Prelude.read: no parse
11:25:12 <lambdabot>  mueval: *** Exception: stack overflow
11:25:20 <SamB_XP> > foldl' (+) 1 [1..1000000]
11:25:23 <lambdabot>   500000500001
11:25:40 <mmorrow> > foldr (+) 1 [1..1000000]
11:25:42 <rwbarton> tail recursion is not really the relevant concept.  e.g., map is "not tail recursive" but always runs in O(1) stack (unless used in a recursive definition, I suppose)
11:25:45 <lambdabot>   mueval: Prelude.read: no parse
11:25:45 <lambdabot>  mueval: *** Exception: stack overflow
11:25:52 <Saizan> DroneZilla: foldl builds up an huge thunk in the accumulator, and when you get to evaluate that it stack-overflows, foldl' is the solution
11:26:16 <subconscious> DroneZilla: "any tail recursive program you have in ocaml or scheme ..." that one?
11:26:25 <DroneZilla> map is hell in OCaml but in haskell you could use it if at last you use the in a tail recursve way
11:26:29 <mightybyte> Saizan: foldl' has the `seq` built in?
11:26:36 <Saizan> mightybyte: yup
11:26:40 <mmorrow> @src foldl'
11:26:40 <lambdabot> foldl' f a []     = a
11:26:40 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:26:41 <subconscious> DroneZilla: Do you know why, operationally, why this embedding works?
11:26:43 <mightybyte> Saizan: Ahh, nice.
11:27:12 <SamB_XP> subconscious: tricky to say given that Haskell is lacking in semantics ;-)
11:27:28 <SamB_XP> having neither operational nor denotational semantics
11:27:50 <Saizan> mightybyte: what i said is no more true if the accumulator is something more complicated, e.g. a tuple, since seq only forces the outermost constructor
11:27:52 <DroneZilla> subconscious: about whatare you talking
11:28:06 <subconscious> DroneZilla: I guess that means no
11:28:08 <mightybyte> Saizan: Ahhh
11:28:17 <mmorrow> mightybyte: yeah, in that case you'de do something like
11:28:19 <mightybyte> ...but then you'd use strict data constructors
11:28:39 <DroneZilla> foldl is a very beautiful function whic doesn't touh the stack or the memory
11:28:52 <subconscious> DroneZilla: that's false, look at SamBs example
11:28:56 <mmorrow> , foldl' (\(!a,!b) (c,d) -> (a+c,b+d)) (0,0) .....
11:28:57 <lunabot>   Illegal bang-pattern (use -XBangPatterns)
11:29:04 <mmorrow> grr
11:29:07 <SamB_XP> mightybyte: well, there's probably other ways to do it, like making the function passed to foldl' always force the relevant fields ...
11:29:21 <tsar> sub: \x y -> arrow (0, 0) x y) (0,0) is the real x, x is y and y is z.
11:29:31 <mightybyte> SamB_XP: Ok, just like mmorrow's example there.
11:29:48 <DroneZilla> is foldl the equivalent of List.fold_left ?
11:29:55 <tsar> wait y is color
11:30:00 <SamB_XP> DroneZilla: "doesn't touch the stack" isn't really good enough ;-)
11:30:09 <rwbarton> > foldl f z [a,b,c]
11:30:11 <lambdabot>   f (f (f z a) b) c
11:30:22 <subconscious> DroneZilla: they look similar but operationally they are very different, since the languages are strict vs lazy
11:30:33 <mmorrow> , foldl' (\(!a,!b) (c,d) -> (a+c,b+d)) (0,0) (zip [1..99] [2343..])
11:30:33 <lunabot>  (4950,236808)
11:30:57 <SamB_XP> DroneZilla: the thing is, foldl leaves a chain of thunks on the heap
11:31:01 <DroneZilla> I came from ocaml world, i don't know very well lazy world
11:31:09 <noZone> If only I had a faster /dev/null ... maybe a quad processor /dev/null server would do....
11:31:21 <DroneZilla> SamB_XP: why does it do that ?
11:31:21 <subconscious> âª let seq !x !y = y in undefined `seq` 4
11:31:22 <lunabot>  luna: Prelude.undefined
11:31:24 <rwbarton> DroneZilla: consider:
11:31:32 <Saizan> http://www.haskell.org/haskellwiki/Stack_overflow
11:31:32 <rwbarton> > foldl (\a b -> b) 0 [1, 2, undefined, 3]
11:31:33 <lambdabot> Title: Stack overflow - HaskellWiki
11:31:35 <lambdabot>   3
11:31:39 <SamB_XP> DroneZilla: because it doesn't force the values like foldl' does
11:31:56 <DroneZilla> foldl' is the equivalent of fold_left in ocaml ?
11:32:02 <dons> yes
11:32:10 <DroneZilla> okay
11:32:14 <DroneZilla> thx
11:32:21 <dons> Beelsebob: we need a new way to do binary-trees
11:32:22 <DroneZilla> a new world for me
11:32:49 <mightybyte> DroneZilla: Yeah, it's interesting all the places where laziness changes things.
11:33:04 <mmorrow> , rnf ((2+4+3,[0..9]),"asdfgfds"++"grewq
11:33:05 <lunabot>      lexical error in string/character literal at end of input
11:33:10 <mmorrow> , rnf ((2+4+3,[0..9]),"asdfgfds"++"grewq"
11:33:11 <lunabot>   parse error (possibly incorrect indentation)
11:33:13 <mmorrow> , rnf ((2+4+3,[0..9]),"asdfgfds"++"grewq")
11:33:14 <lunabot>  ()
11:33:27 <subconscious> what I find more interesting is to take a fresh view of things, and not learn haskell by diffing it against what I previously knew
11:34:14 <noZone> was what you previously knew different from what you previously thought?
11:34:45 <_andre> i wish there was a text with examples of code that takes advantage of lazyness when using stuff more complicated than lists, like Maps or lazy state monad vs. strict state monad
11:34:46 <mightybyte> subconscious: That's difficult.
11:35:27 <subconscious> _andre: I have an example of a lazy evaluator that makes good use of lazyness
11:35:41 <_andre> oh?
11:35:50 <_andre> link? :)
11:36:02 <subconscious> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=26#a44
11:36:25 <_andre> thanks
11:36:49 <subconscious> _andre: http://code.google.com/p/rascal-haskell/source/browse/trunk/HOAS.hs which is (still a toy) but more interesting language uses the same technique
11:36:51 <lambdabot> Title: rascal-haskell - Google Code, http://tinyurl.com/43bqod
11:37:06 <SamB_XP> when you use the lazy state monad, it seems that your program begins executing at the end ;-)
11:37:11 <dblazakis> sw17ch: http://people.csail.mit.edu/vganesh/STP_files/stp.html is what the harvard guys were using for their static anaylsis stuff (although, not sure if i would call it generic)
11:37:12 <lambdabot> Title: STP: A Fast Prover
11:37:16 <subconscious> hm google code is totally broken
11:37:43 <subconscious> _andre: (sorry that link is rubbish, this one is better http://rascal-haskell.googlecode.com/svn/trunk/HOAS.hs )
11:37:45 <sw17ch> dblazakis, hmmm... tahnks
11:37:57 <mightybyte> subconscious That moonpatio link times out
11:38:08 <subconscious> mightybyte, that's weird, it is working fine for me
11:38:17 <mightybyte> strange indeed
11:38:21 <mmorrow> mightybyte: really? can you ping it?
11:38:36 <mightybyte> mmorrow: Let's see...
11:39:06 <mightybyte> Oh, that port is probably blocked by the proxy.
11:39:21 <mmorrow> ah, ok good
11:39:44 <mightybyte> mmorrow: Yep, that was it.
11:45:50 <sebaseba> @users
11:45:51 <lambdabot> Maximum users seen in #haskell: 507, currently: 504 (99.4%), active: 21 (4.2%)
11:45:58 <dolio> @yow!
11:45:58 <lambdabot> You should all JUMP UP AND DOWN for TWO HOURS while I decide on a NEW CAREER!!
11:47:29 <subconscious> not that I have any clue what it is but...
11:47:32 <mmorrow> @nixon
11:47:32 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
11:47:47 <subconscious> did anybody write a lambda reducer or something using nominal logic?
11:47:54 <dolio> Is nixon new?
11:47:54 <PeakerWork> these days, MORE dignity!
11:48:01 <mmorrow> what;s nominal logic?
11:48:08 <subconscious> I don't know :P
11:48:10 <mmorrow> dolio: i saw vixey doing it
11:48:17 <mmorrow> s/vixey/Myoma/
11:48:26 <subconscious> s/Myoma/subconscious/
11:48:34 <mmorrow> um
11:48:52 <subconscious> mmorrow: (I jsut came across http://www.cs.cmu.edu/~jcreed/papers/wmm-rough.pdf )
11:48:53 <lambdabot> Title: cache:http://www.cs.cmu.edu/~jcreed/papers/wmm-rough.pdf - Google Search
11:48:59 <mmorrow> geez, i can't keep up with your name changes
11:49:27 <dolio> Oh, vixey was Myoma?
11:49:29 <dolio> Man.
11:49:46 <mmorrow> subconscious: ooh, looks interesting
11:49:53 <mmorrow> dolio: heh
11:50:11 <DrSyzygy> :t (((,)<$>).).(<*>)
11:50:12 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => f (a -> b1) -> f a -> f (b -> (b1, b))
11:51:20 <DrSyzygy> And what on earth does this MEAN?
11:51:56 <subconscious> âª ((((,)<$>).).(<*>)) Nothing Nothing
11:51:57 <lunabot>   Not in scope: `<$>'
11:51:57 <lunabot>  <interactive>:1:63: Not in scope: `<*>'
11:52:00 <subconscious> > ((((,)<$>).).(<*>)) Nothing Nothing
11:52:01 <lambdabot>       Overlapping instances for Show (b -> (b1, b))
11:52:01 <lambdabot>        arising from a use...
11:52:03 <mattam> Who are you subconscious ? :)
11:52:07 <subconscious> hmm
11:52:22 <SamB_XP> why is lunabot using âª for that?
11:53:09 <subconscious> mattam, If I ever find out ..
11:53:32 <PeakerWork> @unpl (((,)<$>).).(<*>)
11:53:32 <lambdabot> (\ e h -> ((,)) <$> (e <*> h))
11:53:39 <Saizan> > (((,)<$>).).(<*>) (pure (+1)) [1..3]
11:53:40 <lambdabot>   Couldn't match expected type `a2 -> a1 -> f a'
11:53:52 <mattam> No, seriously, you're a student in england right?
11:53:53 <subconscious> by the way you can do alpha equality with HOAS much easier than they did in this paper..
11:54:04 <subconscious> mattam, oh yeah, I am studying maths
11:54:13 <subconscious> mattam, I didn't know that's what you meant
11:54:37 <subconscious> well scotland
11:54:59 <mattam> Edinburgh?
11:55:28 <subconscious> not at edinburgh
11:55:52 <subconscious> (although switching to there does not seem a terrible idea)
11:56:58 <mattam> So you just got interested in functional programming and type theory out of curisosity?
11:57:34 <subconscious> yes
11:58:00 <mmorrow> SamB_XP: lunabot responds to `elem` "],âªâ«"
11:58:14 <DrSyzygy> , 2+2
11:58:15 <lunabot>  4
11:58:47 <mmorrow> SamB_XP: if you have a request for a char that doesn't conflict with regular speach, i'll add it
11:59:06 <mmorrow> comma used to be dot, but that didn't go too well
11:59:07 <mmorrow> ...
11:59:55 <dons> live tweeting from icfp, http://twitter.com/galoisinc
11:59:59 <lambdabot> Title: Twitter / galoisinc
12:00:21 <SamB_XP> dons: via sms, or?
12:02:04 <mmorrow> my money's on a signalling mirror and a blimp
12:06:59 <chrisdone> â½quote interrobang
12:12:43 * subconscious wonders if 6.10 is out
12:13:40 <gnuvince> Is there a good Haskell indentation script for vim?
12:14:31 <Beelsebob> subconscious: 3 weeks yet before that
12:17:07 <dolio> Do you have the "haskell mode for vim" stuff? I used to use that and the indentation didn't bug me too much.
12:17:14 <dons> newsham: submitted, http://alioth.debian.org/tracker/index.php?func=detail&aid=311131&group_id=30402&atid=411646
12:17:16 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311131 Haskell GHC: paral ..., http://tinyurl.com/4mfkc8
12:17:25 <dons> ./A +RTS -N4 -qw < /tmp/data  160.54s user 0.34s system 330% cpu 48.749 total
12:18:00 <newsham> interesting.
12:18:28 <newsham> do you see much diff from -N2 to -N4?
12:19:40 <dolio> gnuvince: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ if you don't have it.
12:19:42 <dons> a bit
12:19:45 <lambdabot> Title: Haskell mode for Vim
12:19:50 <dolio> I'm not certain if that does anything to indenting.
12:20:26 <newsham> also, how does PCRE do on a quad?
12:21:20 <newsham> i like how the parallelization is so clean in haskell on that example.
12:22:24 <sw17ch> referential transparency is one of the first things i miss when moving from Haskell to other languages....
12:22:49 <sw17ch> it drives me mad to the point where i want to write my own GC.. .but then realize that the variables would still be mutable... and i abandon the idea... and copy like mad
12:23:55 <newsham> sw17ch: you could just write a lambda calc evaluator in the language and go back to using referentially transparent code
12:25:42 <dons> newsham: trying pcre now, with instructions to the shootout guys on how to build it
12:27:05 <dons> newsham: whoa, pcre is way faster.
12:27:15 * byorgey makes higher-order coffee with cream and a cube of lambda
12:28:00 <newsham> faster than the g++ entry?
12:28:12 <subconscious> llol
12:28:17 <subconscious> sounds great
12:28:36 <ehtom> why does it matter that haskell is somewhat slower than C/C++ ?
12:28:44 <ehtom> for most applications its not important
12:28:48 <newsham> ehtom: we're playing a game.
12:28:53 <gnuvince> dolio: does that take care of the indentation too?
12:28:55 <newsham> we're trying to get the high score
12:28:59 <olsner> for benchmarks, being fastest is all there is :D
12:29:13 <dolio> gnuvince: It might. It's been a long time since I used it, let alone vim without it.
12:29:17 <ehtom> you guys can all code C/C++ too though rite?
12:29:29 <gnuvince> dolio: cause I don't see a indent/haskell.vim file in there.
12:29:44 <Vq^> ehtom: rite?
12:29:57 <ehtom> right
12:30:03 <subconscious> ehtom: I don't know C++
12:30:28 <dolio> Yeah. Maybe it doesn't change it. I'm not really sure. I don't remember the indenting being too bad back when I used it, though.
12:30:31 <newsham> ehtom: i'm from C.
12:30:40 <dolio> It'd indent do block correctly, for instance.
12:30:51 <PeakerWork> Actually knowing C++ is very difficult.  There are very few people who actually write "idiomatic" C++, where the idioms are Boost/STL style (and increasingly living in the template world)
12:31:09 <Deewiant> dons: how about DFA or TDFA?
12:31:18 <ehtom> well, C++ has alot of wierd stuff in it
12:31:18 <dolio> Is Boost really idiomatic C++?
12:31:24 <Vq^> i've written a few small things with C++, im quite experienced with C though
12:31:29 <PeakerWork> dolio: its so popular that it probably defines the idioms
12:31:31 <olsner> Deewiant: tdfa was about 20% slower than pcre for me
12:31:35 <dolio> Heh.
12:31:45 <ehtom> boost = what the stl should be
12:31:52 <Deewiant> DFA might be faster since it doesn't support group capturing
12:32:05 <Deewiant> although that might be needed for the benchmark
12:32:08 <PeakerWork> C++ is so unnecessarily and horribly complicated
12:32:28 <PeakerWork> and its exception semantics are horrible, and half of the language falls apart without exceptions
12:32:40 <dolio> Boost is like trying to use the template system to graft a decent language into C++. :)
12:32:48 <dolio> Instead of starting over and making a decent language. :)
12:32:52 <subconscious> heh
12:32:58 <olsner> hmm, regex-dfa hasn't been properly updated for the base split
12:33:00 <subconscious> oh this is really bugging me recently
12:33:16 <subconscious> all these people trying to "add closures" to languages instead of starting over
12:33:21 <subconscious> ...or using haskell
12:33:23 <dons> newsham: single core pcre outperforms quad core posix
12:33:23 <dblazakis> i had heard that large pieces of boost are being pulled into the latest standard drafts
12:33:33 <dons> quad core pcre outperforms everything.
12:33:41 <dolio> How is ATS, by the way? Anyone used it?
12:33:54 <dons> newsham: ./B +RTS -N4 < /tmp/data  25.92s user 0.21s system 264% cpu 9.883 total
12:33:55 <subconscious> the #ats channel is very empty :)
12:33:57 <dons> pcre.
12:34:10 <subconscious> though there was a couple in there yesterday
12:34:16 <newsham> nice.
12:34:24 * subconscious wishes that the section in the ATS manual about linear types wasn't .. missing 
12:34:35 <dolio> Wow, it has linear types?
12:34:53 <subconscious> seems undocumentedly to be the case
12:36:00 <ehtom> multithreading is wierd... doesn't apply to everything
12:36:09 <subconscious> I just had started to look at bits of the compiler.. not planning on programming in ATS
12:36:28 <ehtom> I spent some time this afternoon thinking about how I could multithread runge-kutta
12:36:33 <ehtom> "it don't work" :P
12:36:53 <subconscious> ehtom: I tried to write a multithreaded sort in haskell but it was just slower :(
12:37:01 <ehtom> lol
12:37:19 <olsner> hmm, regex-dfa: twice as slow as pcre
12:37:37 <Vq^> subconscious: how did you implement it?
12:37:45 <Deewiant> olsner: even slower than tdfa?
12:37:52 <olsner> mm
12:38:01 <subconscious> Vq^: I tried a whole load of stuff, none of which worked well
12:38:22 <ehtom> multithread is only gonna be quicker if each thread is "doing" something
12:38:22 <dolio> Runge-Kutta doesn't seem like it'd be an ideal candidate for parallelization, no.
12:38:22 <Deewiant> as I understand it the whole reason dfa exists is that it's a bit faster than tdfa but more limited :-P
12:38:28 <PeakerWork> The way performance behaves on the finer-grained issues, related to cache windows/hit/misses, multicores, instruction pipelines, branching penalties, etc is so complicated and obscure, and also kind of arch. dependent (even inside the x86 family)
12:38:32 <olsner> Deewiant: pcre took 10s for me, tdfa took 12s and 20s for dfa
12:38:33 <Vq^> subconscious: with how many threads and how large lists/arrays?
12:38:38 <dons> newsham: submitted, http://alioth.debian.org/tracker/index.php?func=detail&aid=311132&group_id=30402&atid=411646
12:38:41 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311132 Haskell GHC : para ..., http://tinyurl.com/5x7htn
12:38:43 <Deewiant> olsner: damn
12:38:47 <dons> 9s on quad core, verus 72 seconds for the current single core entry...
12:38:54 <Deewiant> olsner: I am surprised!
12:38:56 <subconscious> Vq^: I compare 1 with 2, and used various sizes of lists around 2^16
12:39:06 <subconscious> 1 thread with 2 threads
12:39:21 <ehtom> does lambdabot scan webpages to prevent goatse nonsense?
12:39:32 <Deewiant> doubtful
12:39:33 <olsner> nice, 9s will put us at number one :)
12:39:35 <SamB_XP> ehtom: of course not
12:39:36 <subconscious> ?faq does lambdabot scan webpages to prevent goatse nonsense?
12:39:36 <lambdabot> The answer is: Yes! Haskell can do that.
12:39:42 <SamB_XP> just don't go to
12:39:52 <SamB_XP> goatse.cx
12:39:57 <Vq^> subconscious: did you split the list and sorted it with one thread each and then merged it?
12:40:04 <olsner> SamB: or any of its myriad mirrors...
12:40:08 <ehtom> does the site still even exist?
12:40:15 <ehtom> I thought it went away years ago
12:40:15 <newsham> not only put it at #1, but when you factor in code size and cpu speed, it will be way way ahead
12:40:20 <ehtom> at least people stopped posting it
12:40:22 <SamB_XP> ehtom: you don't relly want to chekc, do you?
12:40:26 <ehtom> no
12:40:30 <ehtom> which is why i'm asking :P
12:40:33 <SamB_XP> I've seen it once
12:40:37 <newsham> the fastest entry (g++) is 2138bytes
12:40:38 <subconscious> SamB_XP: It's just some politician or something
12:40:38 <SamB_XP> it wasn't really that long ago
12:40:45 <newsham> haskell is aprox 500
12:40:47 <SamB_XP> subconscious: what?
12:40:52 <SamB_XP> no, it's really disgusting
12:41:00 <SamB_XP> once was MORE THAN ENOUGH
12:41:08 <subconscious> SamB_XP: It's not really disgusting, it's obviously not what you think it is
12:41:29 <dons> olsner: woo.
12:41:33 <SamB_XP> subconscious: are you sure?
12:41:38 <subconscious> 100%
12:41:39 <SamB_XP> I dare you to look again
12:42:03 <Deewiant> seems to be down
12:42:10 <Deewiant> or maybe my hosts file blocks it, hmm
12:42:30 <mmorrow> SamB_XP: don't worry, whether you look now or not, that image will be burned into your memory forever.
12:43:15 <Deewiant> ah yes
12:43:24 <Deewiant> it is indeed a politician or something
12:43:31 <Deewiant> don't recognize him
12:43:33 <subconscious> is it herny hyde?
12:43:53 <SamB_XP> they change it?
12:43:57 <Deewiant> no, it's bill o'reilly
12:44:15 <Deewiant> it's this picture: http://blog.kir.com/archives/oreillyconfused4.jpg
12:44:29 <Deewiant> which is evidently somewhat old
12:44:35 <Deewiant> so it's probably been like that for some time
12:45:03 <SamB_XP> how d'you figure?
12:45:06 <ehtom> i'm not looking :P
12:45:12 <SamB_XP> yeah, me either
12:45:18 <Deewiant> well the pic is referenced in a blog article from january 2007
12:45:29 <SamB_XP> who knows but that it resolves differently here
12:46:00 <Deewiant> wikipedia knows all, as usual
12:46:05 <Deewiant> On 2008-07-04, the site was relaunched featuring a picture of Bill O'Reilly and a legal disclaimer. The file name and alt text remained the same as before.
12:46:56 <SamB_XP> what was it like immediately prior to that?
12:48:49 <Deewiant> SamB_XP: just read the wikipedia article, http://en.wikipedia.org/wiki/Goatse.cx
12:48:50 <lambdabot> Title: Goatse.cx - Wikipedia, the free encyclopedia
12:52:16 <zloog_> Hi, does . always mean function composition?
12:52:27 <subconscious> not always
12:52:34 <subconscious> I could redefine it and use it for whatever I want,
12:52:44 <subconscious> but it is also used as qualified names
12:52:48 <zloog_> is there a buzzword I could lookup to find its other meaning?
12:52:48 <subconscious> > 3 Prelude.+ 4
12:52:50 <subconscious> for example
12:52:50 <lambdabot>   7
12:53:02 <subconscious> I don't know about buzzwords, but the Haskell Report should cover it
12:53:04 <subconscious> ?report
12:53:04 <lambdabot> ()
12:53:11 <subconscious> which has turned into a tuple ..
12:53:34 <zloog_> haskell report is a language definition?
12:53:48 <SamB_XP> maybe it was goetse.cz that I saw?
12:53:51 <dolio> ?where report
12:53:51 <lambdabot> http://www.haskell.org/onlinereport/
12:54:05 <subconscious> zloog_: yes, it's not the haskell I use though.
12:54:10 <dolio> ?report do { foo ; bar }
12:54:10 <lambdabot> do { foo; bar}
12:54:12 <DroneZilla> some stupid Class : class MonadMult m where; mone :: m () ; mmult :: m a -> m b -> m (a, b)
12:54:21 <dolio> ?report foo >> bar
12:54:21 <lambdabot> (foo >> bar)
12:54:24 <dolio> Hmm...
12:54:28 <zloog_> Oh i see
12:54:53 <subconscious> instance Monad m => MonadMult m where mone = return () ; mmult = liftM2 (,)
12:55:06 <DroneZilla> subconscious: yes, you're right
12:55:11 <zloog_> im working out of a book who's text is always slightly different from the source they provide. So it makes compiling each line tricky
12:55:29 <DroneZilla> it doesn't exit in the standard library I hope
12:55:33 <subconscious> ?report "http://www.haskell.org/onlinereport/"
12:55:33 <lambdabot> "http://www.haskell.org/onlinereport/"
12:56:12 <dolio> unit :: m () and pair :: m a -> m b -> m (a, b) is an alternative formulation of applicative functors, as I recall.
12:57:01 <dolio> pure a = fmap (const a) unit
12:57:29 <Deewiant> SamB_XP: ah yes, goatse.cz is the real deal
12:57:34 <dolio> ap mf ma = fmap (uncurry ($)) (pair mf ma)
12:57:59 <SamB_XP> Deewiant: you CHECKED?
12:58:05 <Deewiant> SamB_XP: sure
12:58:24 <Deewiant> I'm rather desensitized to goatse, it's not that bad
12:58:31 <Botje> goatse is back? :D
12:58:42 <Botje> ah yes. there it is
12:58:42 <Deewiant> not at .cx, but at .cz it is
12:58:44 <Botje> kick ass :)
12:58:58 <Deewiant> 2girls1cup was worse, and I managed that
12:59:05 <Deewiant> "BME pain olympics" or whatever I couldn't handle
12:59:06 <newsham> pair x y = (,) <$> x <*> y;  unit = ?
12:59:16 <newsham> pure () ?
12:59:47 <dolio> Yes.
13:00:38 <dolio> Of course, the unit/pair fomulation relies on the functor superclass, while the one in the libraries doesn't, I suppose.
13:01:04 <dolio> Or, converting from one to the other.
13:01:20 <dolio> pair x y = pure (,) <*> x <*> y
13:01:46 <zloog_> :t Blue
13:01:47 <lambdabot> Not in scope: data constructor `Blue'
13:04:37 <olsner> Deewiant: bme pain olympics... wow! that's... disgusting even by my standards
13:04:57 <Deewiant> I didn't get far
13:05:02 <Deewiant> haven't tried again
13:05:29 <olsner> maybe what I saw was only a short clip though, it was maybe a minute long
13:05:40 <PeakerWork> some guy I knew had goatse as his desktop background
13:05:48 <DuClare> NO, no no no!!
13:05:51 <DuClare> ffs
13:05:55 * DuClare dies
13:05:59 <zloog_> so you need a space before and after a .  to cause function composition?
13:06:02 <DuClare> What's up with this channel
13:06:07 <subconscious> zloog_: no
13:06:19 <Zao> Can't you take your nastiness to somewhere sane, like #0,000 or something
13:06:33 <zloog_> subconscious: Hrm, because when I put in spaces it succesfully compiled, so I'm kind of at a loss for what was happening
13:06:40 <Cale> zloog_: If you want to be sure about it, then yes.
13:06:50 <subconscious> zloog_: What is the code
13:06:52 <Zao> zloog_: If it can be seen as a module lookup, it will or something.
13:07:09 <rwbarton> zloog_: ConstructorName.function is bad, because it could be ModuleName.function
13:07:16 <rwbarton> zloog_: but function1.function2 is usually ok
13:08:22 <zloog_> Its from "The Haskell School of Expression" the line was "(withColor Blue . shapeToGraphic . rubberBall)" should be of type IO ()
13:09:01 <rwbarton> zloog_: yes, Blue is a data constructor (since it starts with a capital letter)
13:09:07 <sebaseba_> @users
13:09:07 <lambdabot> Maximum users seen in #haskell: 516, currently: 510 (98.8%), active: 29 (5.7%)
13:09:09 <zloog_> rwbarton: ahh, that would explain me getting a not in scope error. So If I understand you right you should leave a space if you are starting with a cap
13:09:13 <zloog_> rwbarton: heh thanks
13:09:34 <rwbarton> zloog_: right.  Many (most?) people use spaces around . all the time
13:09:34 <subconscious> zloog_: (I always put a space because it reads better but yes what you said is correct)
13:10:09 <zloog_> got it, thank you
13:14:53 <pmurias> how should i specify a C library in a Cabal file to be linked with the executable?
13:17:42 <sw17ch> pmurias: under the library section
13:17:52 <sw17ch> put "extra-libraries: whatever"
13:19:15 <sw17ch> pmurias, here's one of my cabal files with an example
13:19:15 <sw17ch> http://code.haskell.org/portaudio/portaudio.cabal
13:19:30 <pcc1> @hoogle State [t] t
13:19:30 <lambdabot> No results found
13:23:06 <ahr_> can anyone help with performance troubles for tokenizer (http://hpaste.org/10608)?
13:23:49 <ahr_> array concatination isn't the best solution, but the program runs correct but get's really slow on large inputs
13:25:24 <Botje> uh
13:25:31 <Botje> alphanum <|> noneof "..."
13:25:44 <Botje> alphanum is already not a part of those symbols
13:25:59 <Cale> ahr_: You mean list concatenation?
13:26:10 <ahr_> oh no
13:26:11 <ahr_> sorry
13:26:15 <Cale> ahr_: btw,  [x] ++ xs  is the same as x : xs
13:26:21 <ahr_> yes, indeed
13:26:30 <ahr_> i found the cause
13:26:34 <ahr_> I think :)
13:26:41 <ahr_> stupid mistake on my behalf
13:27:12 <ahr_> rest <- ...
13:27:17 <ahr_> that was simply not needed :)
13:27:32 <ahr_> put it there while thinking of something brilliant earlier today and forgot to remoove
13:27:47 <Cale> Do you really need both those 'try's in abbreviation? Isn't it disambiguated by the first character?
13:28:02 <dolio> Good ol' Bulat.
13:28:40 <camior> Anyone know how to get the haskell ALUT binding working on windows?
13:28:46 <ahr_> Cale, well, I want it to disregard it unless it parses the whole thing
13:28:55 <olsner> oh, what a trolly comment he made there
13:28:57 <ahr_> so I need try around the block, right?
13:29:10 <dolio> @remember Bulat Haskell was developed with goal to hide implementation details from egg-headed scientists and this obviously should have some drawbacks
13:29:10 <lambdabot> Okay.
13:29:23 <Botje> ahr_: well, no. try is only needed if your first block consumes input before failing
13:29:30 <Cale> ahr_: you should usually try to minimise the number of instances of try...
13:29:52 <Botje> try a <|> try b is generally useless if the two are distinct at the first step
13:29:56 <pmurias> sw17ch: thanks
13:30:25 <ahr_> you're right
13:30:27 <ahr_> of course
13:30:47 <Cale> at least, you could go with  a <|> try b  or try (a <|> b)
13:31:03 <Cale> (which should work out the same, unless I'm making a mistake)
13:31:09 <ahr_> it works to change to: parseAbbreviations = do abbrs <- try abbreviation
13:31:13 <Cale> yeah
13:31:26 <ahr_> and remove the ones above
13:31:41 <ahr_> of course
13:32:15 <ahr_> this is becoming much clearer :)
13:32:25 <ahr_> thanks
13:35:41 <ahr_> Cale, Botje, thanks, I managed to simplify the code a bunch :)
13:36:10 <Botje> also, do x <- ...; return x
13:36:13 <Botje> is the same as just ... :)
13:36:26 <ahr_> ah ok
13:37:18 <ahr_> Botje, oh my god, that makes things so much more readable :)
13:39:42 <tsar> http://hpaste.org/10610 , ambiguous type variable. hmm but why?
13:42:04 <Deewiant> tsar: for instance Color3 and Vertex3 take many possible types (Float, Double, possibly Int and such), it can't know which you mean
13:42:06 <sjanssen> tsar: probably the (0, 0)
13:42:51 <sjanssen> tsar: give those 0's fixed types and you should be okay
13:43:37 <Botje> just uncomment those types
13:43:42 <Botje> they're more than documentation, you know :p
13:46:34 <tsar> ah yeah turned them into GLfloats and it is fine
13:47:25 <tsar> ah i can uncomment in seeds instead?
13:47:46 <tsar> nope
13:48:18 <Botje> is there a good reason you didn't just use take 10 (R.randoms (0,1) seed) ?
13:54:51 <subconscious> anyone has a type checker that works on HOAS represented syntax laying around?
13:56:24 * subconscious does not know how to translate this line into haskell; typeof (abs R) (arrow A B) :- pi x\ (typeof x A => typeof (R x) B)
13:57:04 <tsar> botje: that i didnt know. also it doesnt work.
13:57:19 <tsar> ouldn't match expected type `R.StdGen -> [a]'
13:57:20 <tsar>            against inferred type `[a1]'
13:58:23 <Botje> tsar: ah, i meant randomRs :)
14:00:38 <tsar> how is randomR called?
14:00:48 <tsar> @src randomR
14:00:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:00:56 <tsar> @src System.Random.randomR
14:00:56 <lambdabot> Source not found. There are some things that I just don't know.
14:01:06 <tsar> @lambdabot you suck
14:01:06 <lambdabot> Unknown command, try @list
14:01:21 <tsar> @note lambda bot sucks
14:01:21 <lambdabot> usage: @vote <poll> <choice>
14:01:22 <Botje> @hoogle randomR
14:01:22 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:01:22 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
14:01:22 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
14:01:33 <Botje> ah. there we go
14:01:35 <gbacon> in general, is Maybe (Maybe a) better spelled as Either b (Maybe a)?
14:01:43 <tsar> lol wiat i am using it my code im blind
14:01:54 <dolio> What's b?
14:01:59 <Taejo> gbacon: well, the types aren't isomorphic... what's b?
14:02:00 <lambdabot> Taejo: You have 1 new message. '/msg lambdabot @messages' to read it.
14:02:12 <gbacon> dolio, Taejo: prolly ()
14:02:17 <tsar> take 10 (R.randomR (0,1) seed) doesnt work
14:02:19 <Botje> > take 10 (randomRs (0,1) (mkStdGen 42)) :: [Float]
14:02:20 <lambdabot>   [0.110407025,0.8453985,0.3077821,0.78138804,0.5242582,0.5196911,0.20084688,...
14:02:26 <dolio> If it's (), then why not use Maybe (Maybe a)?
14:02:27 <Botje> randomRs
14:02:31 <Botje> note the extra s
14:02:36 <dolio> If it's not (), then it has more information than Maybe (Maybe a).
14:02:46 <gbacon> foo (Just (Just x)) = ... looks weird
14:02:46 <tsar> ah nice botje
14:02:58 <pcc1> :q
14:03:19 <subconscious> :t Just . In . Just . In
14:03:20 <lambdabot> Maybe (Mu Maybe) -> Maybe (Mu Maybe)
14:03:42 <Taejo> :t join
14:03:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:03:47 <Twey> @info In
14:03:47 <lambdabot> In
14:03:53 <pcc1> a buddhist koan?
14:03:54 <Twey> Helpful
14:03:55 <subconscious> @src Mu
14:03:56 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:03:59 <Twey> What's an In?
14:04:01 <Twey> Heh
14:04:07 <rwbarton> @info Mu
14:04:08 <lambdabot> Mu
14:04:18 <int-e> In is the opposite of out.
14:04:20 <subconscious> @farbar
14:04:21 <lambdabot> His little red wagon came home to roost.
14:04:41 <gbacon> Taejo: to provide more context, I have a pairlist of keys to paths
14:04:58 <gbacon> I want to be able to distinguish between lookup misses and keys that I want to ignore
14:05:08 <gbacon> but join would conflate them
14:05:29 <Taejo> gbacon: ok
14:05:30 <subconscious> gbacon: You could have,   Found result | NotFound | Ignored
14:06:01 <subconscious> define some new data
14:06:30 <gbacon> subconscious: true, but it's a lot of overhead for one inner function
14:06:39 <subconscious> overhead
14:06:59 <subconscious> I don't think so
14:07:57 <dons> anyone else notice that data parallel haskell, with auto-vectorisation, will be in 6.10... ?
14:08:06 <dons> "beta", but still, the full thing.
14:08:18 <quicksilver> hmm. Nice.
14:08:18 * subconscious is waiting for GHC 6.10
14:13:01 <BONUS_> hey im writing something and i need some help with terminology
14:13:08 <BONUS_> would you consider Bool to be a type constructor
14:13:09 <BONUS_> or just a type
14:13:16 <subconscious> :k Bool
14:13:17 <lambdabot> *
14:13:31 <subconscious> Bool is a type
14:13:36 <subconscious> :k Maybe
14:13:37 <lambdabot> * -> *
14:13:39 <DrSyzygy> DRMacIver: Ping?
14:13:45 <subconscious> but Maybe is a type constructor
14:13:52 <DRMacIver> DrSyzygy: Pong
14:13:52 <BONUS_> yeah, that's what i thought too
14:14:11 <BONUS_> how about if you have
14:14:19 <BONUS_> data Foo a b = Foo a b
14:14:29 <BONUS_> Foo is obviously a type constructor
14:14:34 <BONUS_> and (Foo a) is as well, am i rite?
14:14:45 <subconscious> yes, Foo :: * -> * -> * and Foo a :: * -> * are type constructors
14:15:00 <rwbarton> hmm, is  (:) 3  a data constructor?
14:15:09 <BONUS_> and would you call (Foo Int) a value constructor
14:15:12 <BONUS_> or just Foo
14:15:16 <dons> rwbarton: its a value.
14:15:32 <rwbarton> Yeah, I would call it a value, or a partially-applied data constructor, but not a data constructor
14:15:41 <subconscious> I call Foo Int :: * -> * a type constructor
14:15:46 <rwbarton> Similarly I wouldn't call Either String a type constructor, I think
14:16:03 <tsar> botje: this is necessary: (R.randomRs (0,1) R.newStdGen)
14:16:05 <BONUS_> what would you call it then
14:16:07 <tsar> but not possible
14:16:29 <rwbarton> I'm kind of ambivalent about this
14:16:30 <quicksilver> rwbarton: well, Either String can be a member of constructor class 'Monad'
14:16:36 <Botje> tsar: newStdGen has type IO StdGen
14:16:41 <tsar> dd an instance declaration for (R.RandomGen (IO R.StdGen)
14:16:45 <quicksilver> rwbarton: but I agree this is an inconsistency in terminology.
14:16:49 <rwbarton> If I wanted to be formal, I would call it a partially-applied type constructor
14:16:55 <Botje> tsar: you need to do newStdGen separately
14:16:59 <subconscious> you can just call it a type constructor
14:17:14 <subconscious> I agree that it is bizarre to call (:) 3 a data constructor though
14:17:15 <Botje> gen <- newStdGen; take 10 (randomRs (0,1) gen)
14:17:35 <rwbarton> BONUS_: Basically, I'd call it a type constructor, but I'd have a slight twinge of guilt as I did so :)
14:17:52 <quicksilver> subconscious: it's not bizarre, it's quite simply wrong.
14:17:58 <BONUS_> haha
14:18:03 <subconscious> quicksilver, um yes that is what I am saying
14:18:05 <quicksilver> subconscious: a data constructor is something you can use in a pattern match.
14:18:11 <quicksilver> etc..
14:18:19 <subconscious> yes exactly what I mean
14:18:52 <roy_hu> hi, I just tried out ghc-6.10, but ghci in Emacs is giving me problems
14:19:02 <roy_hu> *Main> 3
14:19:02 <roy_hu> 3^J3
14:19:20 <roy_hu> Is it because ghci switched to libedit?
14:20:32 <subconscious> roy_hu: 6.10?!
14:20:57 <tsar> c1 <- R.newStdGen c2 <- R.newStdGen c3 <- R.newStdGens1 <- R.newStdGen
14:20:57 <tsar>   s2 <- R.newStdGen
14:21:13 <tsar> can i dot hat with something like: take 5 newStdGen?
14:21:21 <roy_hu> subconscious: yes, from http://www.haskell.org/ghc/dist/stable/dist/
14:21:30 <subconscious> great!
14:21:31 <lambdabot> Title: Index of /ghc/dist/stable/dist
14:21:34 <quicksilver> [c1,c2,c3,s1,s2] <- replicateM 5 newStdGen
14:21:35 <subconscious> thank you
14:21:38 <quicksilver> tsar: ^^
14:21:54 <quicksilver> tsar: but, it's probably a wrong thing to do, to create 5 stdgens like that :)
14:25:15 * subconscious gets compiler errors and gives up immediately
14:25:18 <subconscious> :/
14:25:35 <Botje> that's with any language
14:25:44 <Botje> it takes some time to figure out what the errors mean
14:25:47 <subconscious> especially anything called Cabal written in haskell :p
14:25:53 <subconscious> oh
14:26:12 <roy_hu> I used the binary package for x86_64 and it's working fine
14:29:32 <dons> olsner, newsham, Beelsebob what do we parallelise next?
14:29:48 <olsner> I found a cheat for fasta
14:30:02 <dons> oh?
14:30:10 <Beelsebob> looking at the current results, I'd say k-nucleotide
14:30:14 <olsner> the prng has an easily-predictable period :)
14:30:21 <dons> olsner: hehe
14:30:30 <dons> Beelsebob: hmm. so we need a naive impl. that we can hack.
14:30:48 <subconscious> by the way I read that ATS isn't fast because of dependent types
14:30:49 <dons> no one else has a parallel k-nuc though
14:30:55 <dons> subconscious: hehe.
14:30:57 <subconscious> so you were right dots
14:30:58 <subconscious> dons*
14:30:58 <dons> types help.
14:31:10 <dons> so at least they can do type erasure. but its low level, and parallel.
14:31:14 <dons> so that's the main win
14:31:16 <Beelsebob> erlang's is fairly parallel
14:31:22 <Beelsebob> 38/17/46/0
14:31:26 * dons scrolls down
14:31:27 <Beelsebob> the most parallel of all of them
14:31:36 <dons> ah yes
14:31:39 <dons> slow though
14:31:58 <Beelsebob> yeh, but we don't know if that's a case of the erlang compiler being pants or just not a good impl
14:32:26 <Beelsebob> I need bed just now though
14:32:40 <Beelsebob> hacking hs-plugins all day + writing thesis all evening == sleepy bob
14:32:42 <dons> lots of top level parallelism
14:32:43 <dons>         mapM_ (writeFreqs l sec) [1,2]
14:32:43 <dons>         mapM_ (writeFrame l sec) =<< mapM toseq strs
14:32:45 <quicksilver> dons: your regex-pcre version requires a non-base package and is herefore not admissible? or is that not the rule?
14:32:57 <dons> quicksilver: its not really the rule.
14:33:01 <dons> its a matter of "easy to install"
14:33:28 <dons> and being friendly.
14:33:29 <quicksilver> oh, ok. So if it's an ubuntu package you can use it?
14:33:35 <dons> it doesn't help when people flame on the list, i must say.
14:33:39 <quicksilver> ;)
14:33:39 <dons> quicksilver: yes.
14:33:42 <olsner> ATS' approach to parallelising fannkuch might be interesting though... basically, it iterates all permutations on each cpu, but only does the fannkuch thing on every nth one, but I think it requires cleaning up the current haskell implementation a bit to be able to hack that in
14:33:43 <dons> and even sometimes when its not a package
14:33:46 <ertai> What's needed in order to have haddock of our modules in hackageDB
14:33:50 <ertai> ?
14:33:50 <quicksilver> I think I don't help there; sorry.
14:33:56 <dons> olsner: yes, starting over perhaps
14:34:12 <dons> naive programs are easier to parallelise :)
14:34:51 <dons> c++ has a parallel reverse-complement
14:34:52 <Beelsebob> I also prefer to have naÃ¯ve ones up there just so we can go "look, it's so much easier to read"
14:35:13 <olsner> yeah, but it seems "naive" starray/ioarray fannkuch solutions lack some crucial piece of magic to get them up to speed
14:35:40 * Beelsebob goes to bed (really this time)
14:35:51 <dons> yes.
14:35:55 <dons> naive + parallel = good
14:36:16 <dons> olsner: i didnt' know we had STUarray fankuchs?
14:36:38 <dolio> I've written them. They're slower than the Ptr one.
14:36:58 <dolio> Due to lack of specialization in STUArray, I think.
14:36:59 <sjanssen> dons: do you know why the parallel binary-trees is disqualified?
14:37:13 <dolio> uvector is closer.
14:37:21 <sjanssen> dons: I think it might be because it makes the small trees in parallel, while the spec seems to say they must be created in order
14:38:07 <dons> sjanssen: we use -A hints
14:38:11 <dons> you can give no hints to the GC.
14:38:15 <olsner> http://haskell.org/haskellwiki/Shootout/Fannkuch has an IOUArray version which is basically a different translation of the Ptr version
14:38:16 <lambdabot> Title: Shootout/Fannkuch - HaskellWiki
14:38:32 <sjanssen> dons: ahh
14:38:33 <dolio> Although even uvector falls slightly short of how it could be, as I recall, because of that nested-whatever optimization that needs to be performed.
14:38:37 <dons> sjanssen: you can parallelise it freely atm
14:38:43 <dons> dolio: ah
14:38:56 <dons> sjanssen: the problem is 80% of the time spent doing sequential GC
14:39:03 <tsar> quick: why?
14:39:13 <dons> so moved into the alternatives
14:39:16 <tsar> why is  [c1,c2,c3,s1,s2] <- replicateM 5 newStdGen wrong?
14:39:17 <quicksilver> I remain surprised that inline C isn't against the rules. It seems weird.
14:39:23 <sjanssen> dons: has anyone tried parallelizing check and make rather than the coarse grained parallelism used now?
14:39:30 <quicksilver> tsar: that's not how you use random number generators.
14:39:35 <quicksilver> tsar: you generate one and split it
14:40:01 <newsham> doesnt newStdGen seed with pid+time of day+ other junk?
14:40:01 <tsar> is replicateM in Control.Monad?
14:40:13 <quicksilver> tsar: yes.
14:40:13 <newsham> doing that 5 times in rapid succession might not be so useful
14:40:23 <quicksilver> I wondered that, newsham
14:40:25 <quicksilver> but I'm not sure.
14:40:27 <newsham> btw, you can fork a generator once you get it
14:40:28 <rwbarton> quicksilver: that seems to be what newStdGen does.
14:40:41 <newsham> if thats what you really want
14:40:41 <dons> sjanssen: i have
14:40:46 <rwbarton> "Applies split to the current global random generator, updates it with one of the results, and returns the other."
14:40:54 <quicksilver> oh.
14:40:55 <dons> sjanssen: using `par` is a bit too heavy. but not all options have been explored
14:40:57 <quicksilver> that's OK then :)
14:40:58 <Saizan> newsham: i think newStdGen only seeds with that once, later it just split-s
14:40:59 <dons> needs some thinking
14:41:09 <quicksilver> tsar: I withdraw my objection.
14:41:10 <quicksilver> Almost.
14:41:10 <newsham> saizan: ahh.. makes sense.. thats prob much better
14:41:13 <sjanssen> dons: have the code somewhere?  I've got a version that only has a very small overhead over the sequential version
14:41:14 <quicksilver> it's still doing more IO than you need :)
14:41:23 <newsham> but... why not just make an infinite stream of the random values you want, and take what you need?
14:41:23 <dons> sjanssen: parallel GC, and work-strealing `par` will help in >6.10
14:41:31 <dons> sjanssen: ok. hunting
14:42:01 <tsar> newsham: but isnt that problem the same anyway you call newStdGen?
14:42:03 <subconscious> that comment Oleg wrote makes me wonder about it
14:42:10 <newsham> tsar: ?
14:42:14 <newsham> i dont understand your question
14:42:19 <subconscious> making an infinite stream of randoms and passing that into a pure function..
14:42:26 <subconscious> you have randomness inside the pure function?
14:42:29 <tsar> anyway it worked for my purpose. was there any other reason than newsham you didnt liekit quick?
14:42:31 <newsham> > randomRs (1,6) (mkStdGen 1)
14:42:32 <lambdabot>   [6,5,2,6,5,2,3,2,5,5,4,2,1,2,5,6,3,3,5,5,1,4,3,3,2,4,2,3,6,1,3,4,3,2,5,1,1,...
14:42:44 <dons> sjanssen: http://hpaste.org/10611
14:42:47 <dons> not sure its good
14:42:48 <newsham> you can use randomRs to get an infinite stream from a single generator
14:43:02 <tsar> fork a generator? howd i do that?
14:43:23 <quicksilver> "split"
14:43:24 <tsar> c1 <- R.newStdGen; c2 <- R.newStdGen; c3 <- R.newStdGen or [c1,c2,c3,s1,s2] <- replicateM 5 R.newStdGen
14:43:38 <newsham> tsar: see http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
14:43:40 <lambdabot> Title: System.Random, http://tinyurl.com/3yau3k
14:43:49 <tsar> if the first one is good, why not the second? the second is more rapid?
14:44:04 <tsar> basically replicate is repeat for unpure actions?
14:44:51 <newsham> > let (g,g') = split (newStdGen 1) in (fst $ randomR g (1,6), fst $ randomR g' (1,6))
14:44:52 <lambdabot>   Couldn't match expected type `t1 -> t'
14:45:07 <sjanssen> dons: okay, I think mine is a bit more clever, I'll post it in a bit
14:45:20 <newsham> > let (g,g') = split (newStdGen 1) in (fst $ randomR (1,6) g, fst $ randomR (1,6) g')
14:45:21 <lambdabot>   Add a type signature
14:45:26 <newsham> > let (g,g') = split (newStdGen 1) in (fst $ randomR (1,6) g, fst $ randomR (1,6) g') :: (Int, Int)
14:45:27 <lambdabot>   Add a type signature
14:45:30 <dons> sjanssen: sure. get it working on dual core, and i'll try on quad core
14:45:31 <newsham> *sigh*
14:45:36 <dons> you just aren't allowed to use -Afoo
14:45:39 <tsar> http://hpaste.org/10612, so you mean my seed function should be better?
14:46:03 <newsham> tsar: why do you want 5 generators?
14:46:56 <Botje> tsar: you could chunk the list you get back from randomRs
14:47:35 <newsham> zipWith yourfunc data $ randomR (1,6)
14:47:39 <roderyk> System.Time.ClockTime has a Show but no Read. Is there a convenient lib for getting the current clocktime with convenient to/from string operations? I just need a quick way to store/retrieve timestamps
14:47:44 <Botje> let s1:s2:c1:c2:c3:_ = unfoldr (Just . splitAt 10) randomRs (0,1) gen
14:47:46 <rwbarton> dons: are you allowed to do things like this? http://www.haskell.org/haskellwiki/SPOJ#Garbage_Collection
14:47:47 <lambdabot> Title: SPOJ - HaskellWiki
14:47:53 <newsham> zipWith yourfunc data $ randomRs (1,6) (mkStdGen 1)
14:48:25 <quicksilver> roderyk: don't use System.Time
14:48:29 <quicksilver> roderyk: use Data.Time
14:49:47 <bbs> http://rafb.net/p/4oqol839.html
14:49:52 <lambdabot> Title: Nopaste - haskell
14:49:59 <bbs> sorry i'm sort of stuck on the union fucntion
14:50:00 <bbs> :(
14:50:59 <Botje> bbs: first thing you do is line up your function arguments and equal signs a bit
14:51:35 <Botje> second thing:
14:51:49 <Botje> the case for [] [] is equal to the case for [] ys (just substitute [] for ys)
14:51:53 <roderyk> quicksilver: http://hackage.haskell.org/packages/archive/time/1.1.2.1/doc/html/src/Data-Time-Clock-UTC.html#UTCTime  UTCTime has no Read, Show
14:51:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4lvrwu
14:52:44 <Botje> bbs: pick one list as "base" list, and only add stuff from the other if it's not in base yet
14:52:52 <newsham> epoch = read "1970-01-01 00:00:00.0 UTC" :: UTCTime
14:52:55 <newsham> that works
14:53:09 <subconscious> > read "1970-01-01 00:00:00.0 UTC" :: UTCTime
14:53:10 <lambdabot>       Not in scope: type constructor or class `UTCTime'
14:53:24 <Botje> so something like union xs (y:ys) = if y `elem` xs then union xs ys else union (y:xs) ys
14:53:27 <newsham> with import Data.Time ?
14:53:34 <Botje> when you find ys is empty, just return xs
14:54:16 <roderyk> newsham: ah, my bad. I didn't import Data.Time just Data.Time.Clock. Thanks
14:54:25 <newsham> np
14:54:30 <Botje> bbs: also, that ["Error"] for nth is _REALLY_ bad
14:54:51 <subconscious> :t foldr (\x ys -> if x `elem` ys then ys else (x:ys))
14:54:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
14:54:54 <Botje> it restricts your type to work on [String] only
14:55:06 <bbs> Botje: what do you recommend?
14:55:09 <subconscious> > foldr (\x ys -> if x `elem` ys then ys else (x:ys)) "abcdef" "defgh"
14:55:11 <lambdabot>   "ghabcdef"
14:55:17 <Botje> error "nth: empty list given"
14:55:38 <bbs> subconscious: is that for me?
14:55:41 <Botje> :t error "nth: empty list given"
14:55:42 <lambdabot> forall a. a
14:55:43 <subconscious> no
14:55:47 <Botje> see the forall?
14:55:52 <Botje> it means error can take any type
14:55:52 <subconscious> you can have it if you want
14:55:58 <quicksilver> roderyk: that is not the case.
14:56:02 <bbs> OH!
14:56:04 <bbs> cool
14:56:06 <quicksilver> roderyk: it has both Read and Show.
14:56:36 <Botje> bbs: and taht solves your "not done" for delete, too
14:56:46 <quicksilver> roderyk: Show is in 'Data.Time.Format'
14:56:48 <Botje> just use error when your list is empty
14:57:39 <bbs> Botje: nth [] n = error "nth: empty list given"
14:57:41 <bbs> like that
14:58:04 <Botje> for example, yes
14:58:38 <bbs> Botje: i have two union's btw
14:58:45 <bbs> i don't get which one you said was right?
14:58:50 <roconnor> Cale: I take it  if R is a ring and a vector space then in order for it to be an algebra, an axiom is needed to state the ring operation has is compatible with the vector space scaler operation?
14:58:53 <Botje> uh, you have several
14:59:02 <Cale> roconnor: oh, yes :)
14:59:03 <bbs> yea 3
14:59:03 <bbs> oops
14:59:05 <Botje> but haskell thinks they all belong to the same function called union
14:59:20 <Cale> roconnor: they should be identical, and the zeroes should be the same.
14:59:24 <newsham> roder: http://hpaste.org/10613
14:59:50 <Botje> bbs: did you see what i said above, about union?
15:00:11 <bbs> Botje: yep
15:00:17 <Botje> try writing that
15:00:24 <bbs> i mean -- this is my first day on haskell
15:00:33 <bbs> i'm like infantalised after years of C
15:00:54 <rwbarton> roconnor: the easiest definition of an algebra over a field k is just a ring A with a ring homomorphism k -> A
15:00:56 <Botje> that's okay
15:01:00 <Botje> it takes some time to un-learn :)
15:01:34 <bbs> Botje: can you show me what a fully recursive version of union would be
15:01:35 <roconnor> rwbarton: the ring homomorphism is the scalar multiplication?
15:01:43 <bbs> the one you were talking about is bulky
15:01:48 <bbs> i wanna think more shallow
15:01:57 <rwbarton> roconnor: scalar multiplication by c is multiplication by the image of c, yeah
15:02:12 <subconscious> bbs: Have you encountered folds yet?
15:02:55 <bbs> subconscious: i've tried :(
15:03:01 <Botje> bbs: ^^
15:03:01 <bbs> i just don't wanna cheat and look in prelude
15:03:07 <Botje> or not
15:03:12 <Botje> looks like hpaste is dead again
15:03:15 <Botje> http://hpaste.org/10615
15:03:18 <sjanssen> dons: http://hpaste.org/10614 if you could try this on a quad core
15:03:31 <subconscious> bbs: well I think this function can be written neatly with a fold
15:03:59 <roconnor> Cale: the two operations don't quite have the same type so the can't be identical. :) Ah, right.  I have the them sharing the same Zeros because in my developement the module and the ring are extended from the same abilean group.
15:04:19 <bbs> subconscious: i'll look into that
15:04:26 <bbs> yo i really appreciate all the help
15:04:28 <sjanssen> dons: or even a dual core, I don't have access to one right now
15:04:36 <Cale> roconnor: Normally the scalars are identified with the multiples of 1 :)
15:04:45 <bbs> subconscious: Botje , also my teacher has me using hugs
15:04:51 <subconscious> bbs: You know how a list looks like [1,2,3] but under the hood it's really 1 : (2 : (3 : []))
15:04:51 <bbs> i've heard ghc --interactive
15:04:55 <bbs> blows it out of the warter
15:05:01 <Botje> ghci? yeah.
15:05:04 <bbs> subconscious: yea of course
15:05:14 <bbs> i mean not in haskell but memory wise
15:05:24 <bbs> put together with cons
15:05:27 <rwbarton> >  1 : (2 : (3 : []))
15:05:29 <lambdabot>   [1,2,3]
15:05:35 <subconscious> bbs: foldr (&) nil list will replace all the (:)'s with (&)'s and the [] with nil
15:05:46 <subconscious> bbs: so (1 : (2 : (3 : [])))  ~>  (1 & (2 & (3 & nil)))
15:05:52 <bbs> flipping brilliant
15:06:00 <subconscious> given suitable & and nil you can do loads of stuff
15:06:01 <bbs> i'm sure thats how its done in prelude isn't it
15:06:07 <subconscious> like
15:06:12 <olsner> awsum! parallel fannkuch :)
15:06:12 <geezusfreeek> > foldr (&) z [a,b,c,d,e,f]
15:06:12 <subconscious> > foldr (+) 0 [5,6,8]
15:06:13 <lambdabot>       Ambiguous occurrence `d'
15:06:14 <lambdabot>      It could refer to either `L.d', defined a...
15:06:14 <lambdabot>   19
15:06:18 <subconscious> > foldr (*) 1 [5,6,8]
15:06:19 <lambdabot>   240
15:06:20 <subconscious> etc..
15:06:42 <subconscious> bbs: anyway, if you wanted to write union using a fold, you could start with  foldr (\x ys -> ...)
15:06:58 <geezusfreeek> > foldr f z [a,b,c]
15:06:58 <bbs> subconscious: i'll take a look
15:06:59 <lambdabot>   f a (f b (f c z))
15:07:01 <subconscious> bbs: 'x' is the next element and 'ys' is the union so far
15:07:02 <bbs> thats good for me to look at
15:07:26 <subconscious> bbs: (by the way, really useful is to use :t or whatever it is in hugs to check the type of things as you program)
15:07:30 <roconnor> Cale: yeah, an normally Integers are identified with integer rationals. :P
15:08:01 <roconnor> > (1:Integer) + (1:Rational)
15:08:02 <lambdabot>   mueval: Prelude.read: no parse
15:08:14 <roconnor> > (1::Integer) + (1::Rational)
15:08:16 <lambdabot>   Couldn't match expected type `Integer'
15:08:23 <bbs> subconscious: thanks a lot
15:08:28 <geezusfreeek> bbs: http://cale.yi.org/index.php/Fold_Diagrams
15:08:34 <lambdabot> Title: Fold Diagrams - CaleWiki
15:08:45 <olsner> hmm, it's about 2-3 times slower, but more than 3-way parallel, so it came out faster...
15:09:06 <Cale> roconnor: yeah, I should be careful :)
15:09:13 <olsner> but not my much, and still slower than the Ptr version
15:09:29 <roconnor> Cale: I'm forced to be careful in Coq. :S
15:10:02 <bbs> geezusfreeek: subconscious Botje , thanks guys -- i'll be back
15:10:29 <Botje> byebye
15:10:31 <Botje> have fun!
15:12:26 <Cale> roconnor: I suppose a nice way to write it is that if .* is scalar and * is ring multiplication, then (a.*x) * (b.*y) = (a*b) .* (x*y)
15:12:55 <Cale> Where the first * on the RHS of that is in the scalar ring, and the second is in the algebra.
15:14:36 <wman> did ghc get a lot faster in compiling in circa last half year ? i've read a lot complains that it compiles pretty slow, but imho it smoked c++ (which was deemed faster) since the day i've tried it ...
15:14:49 <roconnor> Cale: I'm proving (a.*(x*y)) == ((a.*x)*y).
15:15:13 <Cale> Take b = 1 in the above.
15:15:20 <roconnor> yep
15:16:24 <sjanssen> wman: GHC 6.8 is a hair faster than GHC 6.6
15:16:41 <dobblego> what is the name of this: class X f where fmap' :: (a -> b) -> f a -> f b; pure' :: a -> f a
15:16:47 <wman> a hair faster == a bit faster ?
15:16:56 <sjanssen> wman: yeah
15:17:27 <rwbarton> dobblego: in math it might be called a "pointed functor"
15:17:29 <Saizan> dobblego: pointed functor?
15:17:35 <dobblego> ah cheers
15:17:52 <rwbarton> dobblego: it's Control.Functor.Pointed in category-extras
15:18:18 <dobblego> while you guys are about :) what about this one? class X m where mplus' :: m a -> m a -> m a; pure' :: a -> m a
15:18:20 <Cale> The reason for this naming is that it's a functor f together with a natural transformation 1 -> f, where 1 is the identity functor.
15:18:23 <dobblego> ah righto thanks
15:18:45 <ziman> what's the difference between (pure' x) and (fmap (const x)) ?
15:18:55 <rwbarton> dobblego: is it also a functor?
15:19:01 <Cale> In sets, functions 1 -> X (where 1 is a one-element set) are "pointed sets", that is, sets with an identified point.
15:19:02 <dobblego> rwbarton, no just as is
15:19:10 <ziman> besides you don't need a value
15:19:26 <dolio> @type fmap (const 2)
15:19:27 <lambdabot> forall t a (f :: * -> *). (Functor f, Num t) => f a -> f t
15:19:35 <rwbarton> dobblego: "monoid-valued non-functor"? :)
15:19:45 <dobblego> rwbarton, I was thinking along the same lines :)
15:19:47 <subconscious> I thought 1 -> X is called an element
15:20:03 <Cale> And a morphism of pointed sets is usually required to obey that the identified point is sent to the identified point.
15:20:08 <Cale> subconscious: It is.
15:20:13 <rwbarton> subconscious: Yes, either element or point depending on preference/context
15:20:33 <Cale> subconscious: The elements of X are the same as the different ways of identifying a specific point of X.
15:21:23 <sjanssen> @src mapM_
15:21:23 <lambdabot> mapM_ f as = sequence_ (map f as)
15:21:27 <sjanssen> @src sequence_
15:21:28 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:21:55 <Cale> The difference is that when one talks about pointed sets, one usually thinks of the category whose objects are functions 1 -> X for every set X, and whose arrows f: (1 -> X) -> (1 -> Y) are functions X -> Y making the obvious triangle commute.
15:22:28 <Cale> (That is, they preserve the point)
15:22:48 <subconscious> I thought they call this slice category ? :(
15:22:59 <subconscious> I'm really never going to _know_ this maths
15:23:00 <Cale> Yes, that's a name for the more general concept.
15:23:10 <subconscious> oh, I'm not totally wrong! :)
15:23:14 <Cale> This is the slice category under the object 1
15:25:55 <Cale> Similarly, you'd want a morphism of pointed functors to preserve the points. That is, it shouldn't just be any natural transformation eta: f -> g, but one for which pure_g = eta . pure_f
15:27:04 <kig> why is it that, as of yet, the reddit flamewar thread "Haskell is faster than C" fails to exist? [ http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all ]
15:27:06 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
15:27:15 <Cale> (If you can hack my slightly loose mixing of Haskell and category theory syntax :)
15:27:15 <Saizan> like lift?
15:27:58 <Cale> Saizan: yeah, usually lift is required to preserve return and join
15:28:15 <Cale> (and fmap, but that's enforced by the type system)
15:28:51 <Cale> kig: heh
15:28:59 <Cale> kig: That's been done a number of times
15:31:07 <ddarius> sjanssen: Switching to -fasm has made a big difference in compile times.
15:34:35 <sjanssen> ddarius: yeah, that's true
15:35:44 <subconscious> oh crumbs
15:35:45 <subconscious> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
15:35:45 <subconscious> user package database then this is probably due to ghc bug #2201. The
15:35:45 <subconscious> workaround is to register at least one package in the user package db.
15:35:49 <sjanssen> will GHC generate better code for (`div` 2) or (`shiftR` 1)?
15:35:50 <subconscious> this error is really really annoying
15:36:29 <subconscious> I actually really hate cabal
15:36:49 <dolio> `shiftR` 1, I think.
15:37:03 <subconscious> I probably use it all the time, but the only times I am aware of it, it's a problem
15:37:53 <dolio> Although I've not done very extensive testing.
15:38:54 <rwbarton> subconscious: I think the workaround is something like  old-ghc-pkg describe <pkg> | new-ghc-pkg register -   where <pkg> is the name of some package
15:39:59 <zloog_> :t lift0
15:40:00 <lambdabot> Not in scope: `lift0'
15:40:23 <subconscious> :t liftM2
15:40:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:40:25 <subconscious> :t liftM
15:40:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:40:31 <subconscious> :t return
15:40:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:41:03 <shapr> Olathe: Did you really send that message to me?
15:41:38 <wman> i changed the install-dirs global prefix in cabal config file and cabal-install does the right thing. but when building manualy  with Setup.hs, packages get installed in the old location (program files). is this where the "hardcoded" path in cabal library comes to action ?
15:43:58 <sjanssen> wman: the config file you edited only works with the 'cabal' command line tool
15:44:08 <wman> i noticed ;-)
15:45:19 <wman> so i would have to gut cabal the library and put in my own path ? or is there some magical environment variable ?
15:49:42 <sjanssen> wman: or you could use cabal the executable for everything
15:51:37 <Saizan> or have an alias that sets the option?
15:51:51 <Saizan> there's no ENV var, anyway
15:57:08 <mmorrow> lunabot now imports all of category-extras
15:57:11 <mmorrow> , runYoneda (Yoneda (\k -> [k 42])) (*2)
15:57:12 <lunabot>  [84]
15:57:30 <olsner> ] 3
15:57:31 <lunabot>  3
15:57:40 <roconnor> Cale: what do you call it when you have a ring that is a module over another ring (ie R[X])?
15:58:39 <DroneZilla> an extension ?
15:58:49 <tsar> where is unfoldr, data.list?
15:58:54 <zloog_> http://hpaste.org/10616 <-- Can anyone help me unpack what that lambda does in this 2 line function?
15:58:58 <tsar> @src Data.List.unfoldr
15:58:58 <lambdabot> Source not found. You type like i drive.
15:59:17 <rwbarton> roconnor: also an algebra.  The base ring of an algebra doesn't have to be a field
15:59:49 <DroneZilla> no it's not an algebra, it'a ring in his case
16:00:02 <Cale> roconnor: yeah... heh, it's also an algebra, or an R-algebra, where the thing is an R-module.
16:00:05 <Saizan> zloog_: it's just discarding the input 't' and returning 'x' as result
16:00:16 <mmorrow> a ring is a special case of a module
16:00:22 <wman> sjanssen: right, i keep forgetting it its enough to run cabal in the dir, it catches the package automatically ... thx
16:00:46 <zloog_> Saizan: a plain x, or a Beh x?
16:01:03 <Cale> http://en.wikipedia.org/wiki/Algebra_(ring_theory) -- see here :)
16:01:08 <roconnor> Cale: oh, an algebra isn't usually over a field?
16:01:10 <zloog_> Saizan: Also t is just a dummy name right?
16:01:14 <Saizan> zloog_: plain x, Beh is wrapped around the while lambda
16:01:14 <DroneZilla> a ring is more than just a module
16:01:25 <mmorrow> roconnor: you may be thinking of vector space...
16:01:26 <zloog_> Saizan: Ahh, thank you
16:01:31 <Cale> roconnor: It *usually* is... but some people generalise a bit.
16:01:38 <Saizan> zloog_: you could use _ instead of t there
16:02:47 <Cale> roconnor: Things get harder to deal with in the general case of course.
16:03:01 <Cale> Modules are much less nice than vector spaces.
16:03:20 <roconnor> Cale: one is called an algebra and the other is called an associative algebra?
16:03:50 <Cale> The term "associative algebra" is sometimes used, because some people define the term "algebra" without the condition that the multiplication be associative.
16:04:07 <roconnor> which multiplcation?
16:04:13 <Cale> The "ring" multiplication.
16:04:20 <Cale> (Of course, it's not properly a ring then.)
16:04:23 <roconnor> oh god.
16:04:45 <Cale> The reason for that is that there are many important nonassociative algebras of this sort.
16:04:45 <mmorrow> an algebra is a module with an /additional/ multiplication
16:04:52 <Cale> For example, Lie algebras.
16:07:17 <mmorrow> DroneZilla: a module is more than just a ring :)
16:07:23 <tsar> is zipWithM_ and replicateM monad transformers? or monad combinators?
16:07:38 <DroneZilla> mmorrow: yesof course
16:08:02 <Saizan> tsar: combinators
16:08:22 <tsar> http://hpaste.org/10617 , how do i keep it from repainting every time i do something to the window?
16:09:04 <ertai> I've added a package to hackageDB but the module is not linked to the documentation, what could be the problem?
16:10:08 <mmorrow> ertai: it take a bit for the docs to be built/linked/something, but they'll show up soon
16:10:12 <mmorrow> *takes
16:10:43 <ertai> mmorrow: OK thanks
16:10:50 * osfameron fails to get the point of http://blog.tmorris.net/20-intermediate-haskell-exercises/
16:10:53 <lambdabot> Title: Î» Tonyâs blog Î» Â» Blog Archive Â» 20 Intermediate Haskell Exercises
16:11:27 <Cale> A module is an abelian group with a ring action ;)
16:12:13 <Cale> (in the same sense as a vector space is an abelian group with a field action :)
16:15:48 <osfameron> ah, got the first one
16:16:03 * osfameron must practise reading type signatures instead of panicking
16:16:09 <allbery_b> urgh.  gtk2hs cellMode's values aren't documented, and the old cellEditable went away
16:16:16 <allbery_b> (nothing like backward compatibility)
16:21:01 <allbery_b> hm, no it didn't, it just moved somewhere else.  feh
16:21:18 <fxr> hi
16:22:41 <fxr> when working with Sockets
16:22:54 <fxr> should I set o_nonblock explicitly?
16:26:58 <mmorrow> and if you take the group to be the trivial group, then that module is iso to the base ring
16:27:11 <mmorrow> => rings are trivial modules
16:27:53 * allbery_b mutters incoherently --- do the docs agree with the modules at all?
16:28:01 <osfameron> if I don't understand the notation:  ((->) t)   what should I be looking at first?
16:28:14 <adu> hi
16:28:15 <mmorrow> a function from the type r
16:28:25 <BMeph> osfameron: ...the Haskell Report? ;)
16:28:27 <mmorrow> , (:) 0 []
16:28:28 <lunabot>  [0]
16:28:50 <allbery_b> you should recognize the infix-operator-as-function form and revise it to (t ->)
16:28:56 <mmorrow> @type id :: forall a. (->) a a
16:28:57 <lambdabot> forall a. a -> a
16:29:07 <zoq> fxr: depends on the intended usage. If there was a definite answer, it wouldn't make sense to let you choose, right?
16:29:09 <mmorrow> , ''(->)
16:29:10 <lunabot>  GHC.Prim.(->)
16:30:36 <osfameron> oh, the (->) is infix operator?
16:30:42 <osfameron> er, but -> isn't an operator is it?
16:30:50 <shrughes> nope, it's a type constructor
16:30:55 <osfameron> parens mean too many things in haskell...
16:31:20 <fxr> zoq: yup
16:31:22 <adu> why is it that there are like 3 definitions of the Comonad class?
16:31:32 <mmorrow> :k forall r. (->) r
16:31:33 <lambdabot>     `(->) r' is not applied to enough type arguments
16:31:33 <lambdabot>     Expected kind `*', but `(->) r' has kind `? -> *'
16:31:34 <conal> geezusfreeek: thanks much for the checkers patches.  i'm integrating them now.
16:31:38 <shrughes> osfameron you can have infix type constructors in haskell (or maybe with some extension), usually they begin with a colon character
16:31:42 <mmorrow> :k forall r. ((->) r)
16:31:43 <lambdabot>     `(->) r' is not applied to enough type arguments
16:31:43 <lambdabot>     Expected kind `*', but `(->) r' has kind `? -> *'
16:31:54 <mmorrow> :k (->)
16:31:55 <lambdabot> ?? -> ? -> *
16:32:35 <mmorrow> :k (->) (->)
16:32:36 <lambdabot>     `(->)' is not applied to enough type arguments
16:32:36 <lambdabot>     Expected kind `??', but `(->)' has kind `?? -> ? -> *'
16:32:53 * dancor doesn't understand what ?? -> ? -> * means as a kind
16:32:55 <mmorrow> i wish kinds were mess-with-able
16:32:55 <osfameron> shrughes: ok, like  1 :+ 2, which I recognize from HSOE.  But I didn't think of -> as a similar thing
16:33:06 <dancor> mmorrow: aren't they in clean
16:33:14 <mmorrow> i'm not sure
16:33:17 <shrughes> osfameron it isn't a similar thing -- :+ is a data constructor
16:33:19 <adu> dancor: well, ? means you don't know, and ?? means you really really don't know... :)
16:33:27 <osfameron> what does (t ->) mean then?  A function that maps from t to nothing?
16:33:40 <shrughes> osfameron but if you wrote  data x :+ y = Foo x y
16:33:47 <mmorrow> from t to "whatever"
16:33:48 <dobblego> it is the first argument applied so giving a type constructor of kind * -> *
16:33:52 <bbs> anyone have a good mergesort alg
16:33:54 <rwbarton> To resume an earlier thread, (->) t is a partially applied type constructor :)
16:34:08 <mmorrow> slash "something, but i haven't decided what yet"
16:34:09 <shrughes>  > type F a b = a -> b
16:34:15 <osfameron> mmorrow: aren't the "whatever"s usually given a letter?  (t -> a)  ?
16:34:19 <shrughes>  ^^ here, (t ->) is equivalent to (F a)
16:34:25 <idnar> dancor: it's basically like * -> * -> * if you ignore all the unboxed stuff
16:34:26 <shrughes> er, equivalent to (F t)
16:34:50 <shrughes> osfameron, consider the type synonym  "PseudoArray a = Int -> a"
16:34:50 <mmorrow> osfameron: i think it's analogous to (*2) as opposed to (\x -> x*2)
16:35:01 <idnar> I can never remember what ? and ?? actually mean, though
16:35:04 <shrughes> a function mapping integers to a value of type a is similar to an array of type a
16:35:44 <shrughes> osfameron: there, PseudoArray and ((->) Int) are both (the same) type constructor
16:37:02 <osfameron> hmmm ok
16:37:27 <shrughes> osfameron: and in general, "((->) t) a" could be regarded as a lookup table whose keys are of type t and whose values are of type a
16:37:50 <shrughes> osfameron: thus ((->) t) is the type constructor for a lookup table where the keys are of type t.
16:38:12 <osfameron> shrughes: I thought we were talking about a function rather than a table?
16:38:26 <shrughes> osfameron: what's the difference?
16:38:36 <shrughes> i mean, obviously they're different, okay.
16:38:50 <dancor> tables are frequently less compact ;)
16:39:01 <adu> so there's one definition with: class Comonad w where { extract, (=>>) } and then theres one with: class Comonad w where { extract, extend, duplicate }, which one is the more standard-ish one?
16:39:21 <shrughes> osfameron: a function, mathematically speaking, is just a lookup table.
16:39:26 <adu> and then theres one with class Comonad w where { counit, cobind }??
16:39:39 <adu> which one should I use?
16:39:49 <dancor> adu: is ? and ?? just like ?_1 and ?_2, or is there really a "really don't know"
16:40:42 <osfameron> shrughes: ok
16:41:35 <rwbarton> dancor: it's a ghc thing that has something to do with whether the types can be boxed.  e.g., the type a -> b can never be unboxed, but a and b could be
16:41:39 <rwbarton> compare
16:41:40 <rwbarton> :k Either
16:41:41 <lambdabot> * -> * -> *
16:41:49 <adu> :k Eq
16:41:50 <lambdabot> Class `Eq' used as a type
16:42:02 <adu> :k Monad
16:42:03 <lambdabot> Class `Monad' used as a type
16:42:13 <adu> :k Maybe
16:42:14 <lambdabot> * -> *
16:42:21 <shrughes> :k C#
16:42:22 <lambdabot> Not in scope: type constructor or class `C#'
16:42:24 <adu> :k ParsecT
16:42:25 <lambdabot>     Not in scope: type constructor or class `ParsecT'
16:42:43 <dancor> what is a really wack kind with lots of ?'s
16:42:46 <rwbarton> :k StateT
16:42:47 <lambdabot> * -> (* -> *) -> * -> *
16:43:04 <adu> :k GenParser
16:43:05 <lambdabot>     Not in scope: type constructor or class `GenParser'
16:43:24 <idnar> dancor: I think *, ?, and ?? are all you get
16:43:41 <shrughes> and #
16:43:43 <shrughes> and (#)
16:43:44 <fxr> I'm trying to write FFI interface to libev. Could anybody please take a look at it? I'm unable to run test.hs.
16:43:55 <idnar> oh right
16:43:57 <adu> fxr: sure
16:44:04 <fxr> http://labs.core.gen.tr/repos/hlibev/
16:44:05 <lambdabot> Title: Index of /labs.core.gen.tr/repos/hlibev
16:44:08 <shrughes> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
16:44:09 <idnar> where are those documented?
16:44:11 <adu> fxr: theres also hpaste.org
16:44:15 <lambdabot> Title: IntermediateTypes - GHC - Trac
16:44:23 <idnar> man, stop using the time machine
16:44:36 <fxr> adu: well I cabalized the package already
16:44:52 <adu> fxr: ok
16:45:43 <mmorrow> here's kind stuff (sadly it was mangled..) http://hpaste.org/10619#a0
16:45:44 <fxr> the problem is when i start the test server, I successfuly got the first response. But I'm unable to get the second response
16:48:02 <BMeph> adu: All three are equivalent (except for 'duplicate' is already defined in one of them).
16:49:10 <fxr> here is the output of test.hs if it will be helpful: http://hpaste.org/10620
16:50:42 <adu> BMeph: well if they're all equivalent and well, known, then why aren't any of them on hackage?
16:50:48 <adu> BMeph: wait, n/m: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
16:50:50 <lambdabot> Title: Control.Comonad, http://tinyurl.com/447cd9
16:50:58 <adu> BMeph: that makes 4 definitions...
16:51:02 <BMeph> adu: ...heh-heh-heh. ;)
16:51:20 <mmorrow> , pp $(lift =<< reify ''CoMonad)
16:51:21 <lunabot>      Not in scope: type constructor or class `CoMonad'
16:51:34 <mmorrow> , pp $(lift =<< reify ''Comonad)
16:51:36 <lunabot>  class Copointed w_0 => Comonad w_0
16:51:36 <lunabot>      where duplicate :: forall w_0 . Comonad w_0 => forall a_1 . w_0 a_1 ->
16:51:49 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify ''Comonad)
16:51:50 <lunabot>  class Copointed w => Comonad w
16:51:50 <lunabot>      where duplicate :: forall w . Comonad w => forall a . w a ->
16:52:11 <rwbarton> ,help
16:52:12 <lunabot>   Not in scope: `help'
16:52:13 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify 'duplicate)
16:52:14 <lunabot>  Class op from Comonad: duplicate :: forall w . Comonad w => forall a . w a -...
16:52:21 <mmorrow> rwbarton: heh
16:53:03 <mmorrow> i had to scour the category-extras docs for a test exp to see if it was working. i came up with
16:53:08 <mmorrow> , runYoneda (Yoneda (\k -> [k 42])) (*2)
16:53:10 <lunabot>  [84]
16:53:25 <mmorrow> pretty much Cont, but with an extra Functor at the end
16:53:54 <dolio> , (\k -> [k 42]) (*2)
16:53:55 <lunabot>  [84]
16:54:15 <mmorrow> , pp $(lift =<< reify ''Yoneda)
16:54:16 <lunabot>  newtype Yoneda f_0 a_1 = Yoneda {runYoneda :: (forall b_2 . a_1 ->
16:54:16 <lunabot>                                                              b
16:54:41 <mmorrow> newtype Yoneda f a
16:54:42 <mmorrow>   = Yoneda {runYoneda :: forall b. (a -> b) -> f b}
16:55:39 <mmorrow> dolio: lunabot has every category-extras module in scope :)
16:55:51 <mmorrow> (all 99 of them)
16:56:20 <dolio> Wow. edwardk is a busy guy.
16:57:59 <hackage> Uploaded to hackage: garsia-wachs 1.1
16:57:59 <hackage> Uploaded to hackage: garsia-wachs 1.0
16:59:54 <mmorrow> dolio: heh
17:00:13 <Olathe> If, in a library, I have data Whatever = A | B | C, is there a way to allow D or something to be added later ?
17:01:29 <Saizan> Olathe: sadly, no
17:01:33 <Olathe> Ahh.
17:02:07 <Olathe> What would be the best way, if I have various types of numbers in an algebra package, to allow the addition of, say, matrices or something ?
17:02:29 <Saizan> use a typeclass?
17:02:43 <Saizan> like we have for Num
17:02:46 <Olathe> If I use that, is parsing still possible ?
17:02:55 <mmorrow> or you can just use datatypes
17:03:01 <mmorrow> explicit dictionaries
17:03:06 <mmorrow> data Group a = Group { (+) :: a -> a -> a, ... }
17:03:18 <Olathe> Hmm...
17:03:29 <Olathe> Is there a way to allow, say, Reals to be added to Integers.
17:03:40 <Olathe> Or does Num screw that up ?
17:03:45 <mmorrow> i'm starting to be drawn more and more to using explicit dicts rather than type classes for some reason
17:03:48 <Olathe> I mean with (+)
17:03:58 <mmorrow> screw Num
17:04:00 <mmorrow> :)
17:04:10 <mmorrow> (you'd just shadow it)
17:04:15 <Saizan> you can't add anything to types
17:04:45 <dobblego> is there a library for Ruby that declares, for example, a Monad type and so on, such that it is usable in a production application?
17:04:59 <Saizan> oh, add in the sense of math addition, sorry
17:05:11 <mmorrow> Olathe: you'd have to do something like   GenericNum = IntGN Int | DoubleGN Double
17:05:16 <Olathe> dobblego: Not really, though someone wrote up a monad tutorial in it.
17:05:33 <newsham> does monad work for imperatives without lazy eval?
17:05:38 <dobblego> Olathe, that's all I have found too (I'm not interested in Monad specifically, I just want something that cal help make the language more usable)
17:05:38 <Olathe> mmorrow: Ahh, what would be a good way to allow users to add, say MatrixGN later ?
17:05:45 <Olathe> newsham: Sure.
17:06:01 <dobblego> newsham, I use a Monad type-class in Scala all day long
17:06:08 <Olathe> newsham: It's just a type of algebra structure.
17:06:17 <newsham> scala supports lazy evaluation
17:06:22 <dobblego> indeed, I use a degenerate form in Java even
17:06:41 <dobblego> newsham, I also use it in the subset of Scala without lazy eval
17:06:52 <newsham> cool
17:06:56 <mmorrow> maybe make a typeclass of a datatype which capture the properties/operations/whatev of such a thing, then user'd just have to implement those functions for their type
17:07:03 <mmorrow> s/of/or/
17:07:22 <mmorrow> wow, that sentence was mangled
17:07:24 <Olathe> Is there an easy way to allow a bunch of functions I'm writing to recurse only a certain number of times ?
17:07:52 <newsham> olathe: if you wrote them as non-recursive functions, and used "fix" to add recursion, you could make a limited fix
17:07:58 <newsham> that only allowed a certain depth
17:08:14 <Olathe> Hmm, that sounds decent. Thanks.
17:08:25 <mmorrow> or do the   where go m n ... | m < n = .. stop .. ...
17:08:45 <mmorrow> | otherwise = ... something ... go m (n+1) ...
17:09:56 <dancor> fix is kwlr
17:10:03 <mmorrow> heh
17:10:12 <mmorrow> true
17:11:37 <newsham> fix = recursion tinkering kit
17:25:21 <ertai> mmorrow: Is the haddock thing on hackage done periodically each day, in fact how often it is if you know?
17:27:00 <Olathe> shapr: Yep.
17:33:10 <mmorrow> ertai: i'm not sure how they do it, but it seems to get done within a few hours
17:33:24 <ertai> mmorrow: OK
17:39:18 <chr1s> dcoutts: what about a hackage interface hackaton on wednesday?
17:39:50 <dcoutts> chr1s: I'm not sure about a schedule yet
17:40:01 <dcoutts> but yes in principle, dunno about when exactly
17:40:40 <chr1s> sure. I'd say somewhere after dinner.
17:43:31 <wman> i have two pieces of code that work perfectly each on its own (LDAP dependent part & HDBC-ODBC dependent pat). but when i try to put them together they never run to completion. i discovered that just importing the LDAP module into the HDBC-ODBC dependent binary (and not using any of the imported functions) is enough to cause it to silently fail in the middle of execution. is there something i can/should try ?
17:45:28 <wman> i reinstalled ghc and rebuilt everything from scratch, GHC 6.8.3/win32
17:47:40 <SamB_XP> wman: you compiled it by HAND?
17:47:44 <SamB_XP> impressive!
17:48:10 <wman> ghc ? no, just happs & dependencies & LDAP & ...
17:48:12 <Olathe> `Wait ?
17:48:18 <Olathe> They make automatic compilers ?
17:48:29 <SamB_XP> you said you rebuilt EVERYTHING from scratch ;-P
17:48:44 <wman> yeah, windoze too ;-)
17:48:48 <SamB_XP> that would imply hand-compiling GHC, you know
17:49:44 <wman> i _reinstalled_ ghc implies i used prepared binary imho ;-)
17:51:13 <wman> but if it could help (and not only in getting rid of me for some period of time :-) i can try building my own ghc
17:55:38 <SamB_XP> well, it's more silly my way
17:55:49 <SamB_XP> wman: probably won't help
17:56:09 <SamB_XP> but you can't do it from scratch unless you want to take levels in Haskell Compiler
17:57:58 <wman> anything else i can do (other than declare this project cursed, because i had to give up on the erlang version, because of other strange errors encountered nowhere else) ?
17:58:45 <SamB_XP> hmm, you could try renaming the project in the hopes that the curse is name-related ;-P
17:58:59 <reltuk> wman: you have a minimal example which reproduces the problem?
18:00:37 <wman> something along the lines "a simple simple one-table select script functions ok, but never runs to completion as soon as i include a simple import  LDAP in the source"
18:01:53 <wman> i'll clean it up of unneeded bits and post it to hpaste
18:02:36 <reltuk> wman: does windows have something like strace?  watches a process and prints the calls into the kernel it makes...
18:03:14 <adu> reltuk: OllyDbg?
18:03:23 <reltuk> adu: if you say so...
18:04:01 <HanDongSeong> Hi. I used Data.Time.Clock.getCurrentTime and Data.Time.Clock.diffUTCTime in order to implement something like time.wait(). It works fairly now, but I think this is not a good way to do it. Can I make it better?
18:04:37 <reltuk> adu: looks like it might work...I would definitely be trying to use something to figure out where the program was getting hung up
18:04:41 <adu> HanDongSeong: what is time.wait()?
18:05:12 <HanDongSeong> adu: maybe time.sleep() would sound more familiar to you
18:05:22 <adu> reltuk: i was just guessing, i'm not that familiar with debugging/profiling
18:05:48 <HanDongSeong> adu: like, just doing nothing for specified length of time
18:05:49 <wman> tools by sysinternals could do the job, but it's hopeless, our f*cking "security" committee disabled the needed rights globally in the whole (win) domain - no exceptions :-(((
18:06:01 <adu> HanDongSeong: what language is that?
18:06:16 <HanDongSeong> adu: err... is it relevant?
18:06:30 <HanDongSeong> well, i think python has time.sleep() ...
18:07:44 <newsham> ?type Control.Concurrent.threadDelay
18:07:45 <lambdabot> Int -> IO ()
18:08:28 <HanDongSeong> yeah i saw it, but i want to use it in main...
18:08:32 <kpreid> HanDongSeong: On a modern computer, repeatedly comparing the current time is never the right thing.
18:08:48 <HanDongSeong> kpreid: exactly
18:08:48 <SamB_XP> hasn't been in ages
18:09:03 <SamB_XP> why, it wasn't even the right thing for all that long in DOS
18:09:08 <HanDongSeong> that's why i'm looking for a better solution
18:09:25 <lucca> wman: have you looked at what libraries the libraries are linked against?
18:09:36 <kpreid> HanDongSeong: threadDelay is the thing.
18:09:38 <lucca> i.e. conflicts therein
18:09:41 <newsham> main = print 1 >> threadDelay (1000 * 1000 * 5) >> print 2
18:09:59 <HanDongSeong> oh
18:10:53 <paczesiowa> any ideas on how to write func f that takes g :: a -> b but there may be/are additional constraints on a and b, and f does different things depending on g's constraints. does it even make sense?
18:11:35 <newsham> f g x | x < 5 = g x   | otherwise = g 0
18:12:05 <paczesiowa> newsham: that was for me?
18:12:22 <newsham> hopefully :)
18:12:52 <HanDongSeong> newsham, kpreid, thanks!
18:13:08 <newsham> yw
18:13:31 <rwbarton> paczesiowa: sounds like you want type classes (possibly overlapping ones)?   class Foo a b where f :: (a -> b) -> c
18:13:55 <paczesiowa> I'd like something like f g | g :: (Class a b)=>a->b = 1 | g::(Class3 a b a) => a -> b = 2 | otherwise =3
18:14:05 <rwbarton> instance Foo [a] [b] where ..., instance (Num a, Num b) => Foo a b where ..., etc.
18:15:05 <rwbarton> This is kind of a strange requirement because type classes are open--someone far away might make an instance for Class a b you weren't expecting, and then your f changes
18:15:26 <wman> http://hpaste.org/10622
18:15:30 <paczesiowa> rwbarton: yeah, it would be nice to have closed classes
18:16:43 <wman> lucca: i haven't, HDBC-ODBC probably uses the windows DLL's, LDAP is linked against openldap
18:16:51 <paczesiowa> wouldn't closed classes make few things easier and more decidable?
18:17:25 <wman> lucca: how should i check ?
18:18:26 <rwbarton> I suspect some of those things will soon be handled using type families, although I don't know anything about them
18:19:52 <paczesiowa> it would be nice to be able to write code on type level as easy as regular code without doing logical programming with classes and all those associated things I don't know yet
18:20:29 <newsham> pacz: use a lang w/ dependant types
18:20:48 <dolio> @seen mmorrow
18:20:48 <lambdabot> mmorrow is in #haskell, #darcs and #ghc. I last heard mmorrow speak 3m 23s ago.
18:20:48 <dmwit> paczesiowa: Closed classes can be achieved with data.
18:20:51 <newsham> downside is that you wouldnt get all that free type inference
18:20:59 <mmorrow> dolio: yoyo
18:21:10 <dolio> mmorrow: You've got a pretty recent 6.9, right?
18:21:10 <paczesiowa> dmwit: gadt?
18:21:16 <dmwit> normal data
18:21:19 <dmwit> Nothing special.
18:21:25 <mmorrow> yeah, i just built one one the 12th
18:21:31 <paczesiowa> dmwit: because all I need is just regular data but for the type level
18:21:35 <dolio> Does it do closed/total type families?
18:21:54 <mmorrow> hmm. how do i check. i'm not familiar with such beasts.
18:22:03 <dolio> Let me look up some syntax...
18:22:11 <mmorrow> sweet
18:22:14 <paczesiowa> dmwit: usually you do that with creating class as a type and adding instances as constructors
18:22:26 <dmwit> paczesiowa: exactly
18:23:00 <paczesiowa> dmwit: but think of type level arithmetic
18:23:02 <dolio> type TypeEq s t where TypeEq s s = TTrue ; TypeEq s t = TFalse
18:23:33 <paczesiowa> dmwit: you have Class HBool and instances for HTrue and HFalse, but that's not closed
18:23:35 <dolio> Probably stick some newlines in there.
18:23:46 <adu> HanDongSeong: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Unistd.html#2
18:23:47 <lambdabot> Title: System.Posix.Unistd, http://tinyurl.com/4y6alz
18:23:49 <paczesiowa> dolio: what's that?
18:23:49 * mmorrow checks
18:23:58 <dolio> Total type families.
18:24:18 <paczesiowa> dolio: sounds sweet, I'll wait those 3 weeks for new ghc
18:24:29 <dolio> We're not sure they're in yet. :)
18:24:36 <paczesiowa> damn
18:24:55 <HanDongSeong> adu: thanks :O
18:25:03 <dolio> But, if so, you can define things that would normally get rejected due to overlapping, for instance.
18:25:39 <paczesiowa> anyway all those papers on associated stuff seem hard, I prefer Oleg's type hackery
18:25:40 <lucca> wman: err, you're in windows?
18:26:02 <lucca> wman: openldap typically links against a variety of libraries...
18:26:57 <mmorrow> dolio: dang, doesn;t look like it
18:26:58 <mmorrow> totaltyfams.hs:3:16: parse error on input `where'
18:26:58 <mmorrow> Failed, modules loaded: none.
18:27:09 <dolio> Oh well.
18:27:19 <wman> llucca: yeay, win, you don't have to tell me how it sucks. what i would give for linux-only job ...
18:27:20 <mmorrow> i looked in DynFlags also for some flag i was missing and didn't see any
18:27:34 <paczesiowa> there was ghc beta I think, mmorrow you're trying with that?
18:27:35 <mmorrow> dolio: where'd you read/hear about that?
18:27:43 <dolio> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/TotalFamilies
18:27:46 <mmorrow> The Glorious Glasgow Haskell Compilation System, version 6.9.20080912
18:27:46 <lambdabot> Title: TypeFunctions/TotalFamilies - GHC - Trac, http://tinyurl.com/4vvoxf
18:28:00 <adu> HanDongSeong: but ya, threadDelay seems to be perferred as newsham said
18:28:02 <paczesiowa> mmorrow: I think beta was from yesterday
18:28:26 <dolio> I kind of doubt they added it in the past 10 days, but who knows.
18:28:27 <mmorrow> paczesiowa: sweet
18:28:29 <wman> lucca: i have openldap built just against openssl (and some basic deps, no sasl and such shenanigans)
18:28:49 <paczesiowa> too bad they don't have binaries for x86
18:29:43 <wman> lucca: from what i can remember : libiconv mingw-regex zlib
18:30:57 <mmorrow> total families lok innnnteresting
18:31:12 <mmorrow> *look
18:31:15 <dolio> Yeah. They'll be handy, I'm sure.
18:31:24 <lucca> shenanigans, heh
18:31:42 <lucca> what is the odbc side using?
18:31:43 <dolio> Since they let you do things that get denied due to termination conditions and such on open families.
18:32:02 <paczesiowa> why do they worry so much about typechecker termination? runtime termination doesn't bother anyone but those in high dependant towers, and it's runtime that launches missiles, not typechecking
18:32:49 <mmorrow> yeah, they seem so much better for reasons i'm not sure, but am fairly certain of this (if you know what i mean ;))
18:32:55 <bd_> paczesiowa: because if the typechecker doesn't terminate, then you have no idea if a validly typed program will be accepted
18:32:56 <mmorrow> heh
18:33:09 <bd_> ie, you could write well-typed programs, and they'd fail to compile, and it wouldn't be a bug.
18:33:13 <wman> lucca: just odbc32
18:33:44 <lucca> no ideas off the top of my head
18:33:50 <adu> :t unsafePerformLaunchTheRocketPoweredExplosiveDevices
18:33:51 <lambdabot>     Not in scope: `unsafePerformLaunchTheRocketPoweredExplosiveDevices'
18:33:58 <paczesiowa> bd_: so what? does it typecheck longer than your patience lasts? then do it the other way
18:34:31 <mmorrow> Myoma had a hillarious one the other day
18:34:33 * mmorrow finds it
18:34:34 <chrisdone> unsafePerformSurgeryWithRocketPoweredExplosiveDevices
18:34:38 <bd_> paczesiowa: or it typechecks forever
18:34:38 <mmorrow> unsafePerformNuclearyCoerceIOMissiles
18:34:42 <mmorrow> lol
18:34:46 <adu> lol
18:35:33 <paczesiowa> bd_: I still think that runtime nontermination is more dangerous
18:35:50 <shrughes> well duh
18:35:55 <bd_> sure, but compile-time nontermination means you don't know if your tools will work properly
18:35:59 <bd_> it's not like we're trading one for the other
18:36:27 <mmorrow> bd_: agda i believe kills it after a set number of recursions/something
18:36:39 <paczesiowa> bd_: then I work as long as I need to be sure, whereas poor enduser can't do anything to hung software
18:36:43 <bd_> mhm, and it turns out your well-typed program could've been resolved with just one more!
18:36:56 <bd_> paczesiowa: sure. but we don't need to trade them off, surely
18:37:04 <dolio> Is that recent? I've accidentally sent agda into a loop, and had to kill it off manually.
18:37:07 <mmorrow> ghc already has a fixed context depth when trying to resolve instance decls/probably other analogous things
18:37:23 <mmorrow> dolio: i'm not sure. i've only read about this...
18:37:28 <wman> lucca: if it helps (not likely) it runs printing the lines, then it gets stuck somewhere in the middle, sits there for a while without rising memory usage and then just exits without giving any error message at all..
18:37:29 <tsar> i have heard that lisp is safe. how? types are checked at runtime...
18:37:41 <mmorrow> and it may not even be agda i read about (but i think it was)
18:38:15 <paczesiowa> mmorrow: once I wrote some code that was typechecking for an hour and it was eating ram veeery slowly
18:38:21 <lucca> wman: heh, great
18:38:37 <paczesiowa> mmorrow: and it didn't hit no fixed limit
18:38:42 <mmorrow> paczesiowa: did it finish or did you kill it
18:38:43 <lucca> wman: i haven't looked much at the haskell ldap stuff yet; just judging from normal ldap stuff I do
18:38:43 <mmorrow> ?
18:38:58 <paczesiowa> mmorrow: killed it, found one of those loops in instances
18:39:03 <mmorrow> i haven't really used agda much.
18:39:09 <paczesiowa> mmorrow: that was ghc
18:39:10 <mmorrow> i may be recalling another lang
18:39:14 <mmorrow> paczesiowa: lol
18:39:23 <mmorrow> yeah, there are those..
18:40:41 <paczesiowa> anyway those TypeEq look a lot better than that famous TypeCast
18:41:08 <paczesiowa> with only one person on this planet that knows why there are 3 steps to fool typechecker
18:41:11 <wman> i'll try to build it in an vmware image and trace it there, no pesky policies. but what bothers me the most is that it's just importing the module that does the job. any mailing list i should pester ?
18:42:02 <reltuk> wman: do you have the code for the ldap module?
18:42:06 <adu> crap
18:42:23 <adu> i missed the non-termination conversation
18:42:36 <wman> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/LDAP
18:42:37 <lambdabot> Title: HackageDB: LDAP-0.6.4
18:43:02 <paczesiowa> adu: we haven't finished yet, or at least we haven't decided if we are finished:>
18:43:34 <adu> paczesiowa: lol, wow, that's funny on so many levels...
18:43:55 <paczesiowa> I do my best:>
18:43:57 <dolio> What's TypeCast?
18:44:43 <paczesiowa> @google oleg typecast
18:44:45 <lambdabot> http://okmij.org/ftp/Haskell/typecast.html
18:44:45 <lambdabot> Title: Type improvement constraint
18:45:20 <dolio> Oh, yeah. That stuff is pretty bad.
18:45:58 <paczesiowa> and when Oleg says that it is a hack then you know it's bad
18:46:28 <dolio> For instance, I think not-a-function might be something like 'type Fun a where Fun (a -> b) = TTrue ; Fun a = TFalse'
18:47:16 <dolio> Which... I don't think I've ever understood Oleg's solution to that. :)
18:47:21 <paczesiowa> wouldn't 'a' interfere?
18:47:37 <paczesiowa> Fun a ... Fun (a ->
18:47:45 <rwbarton> It doesn't seem like there should even be a solution to that
18:47:58 <dolio> Nah. The a at the top doesn't mean anything. It's just for specifying the kind of Fun.
18:47:58 <paczesiowa> rwbarton: why?
18:48:19 <paczesiowa> dolio: oh, I see
18:48:43 <adu> dolio: I only know one kind of Fun, good fun!
18:48:45 <dolio> Like you can do GADTs like "type Fin n where FZ :: Fin n ; FS :: Fin n -> Fin (S n)"
18:49:01 <dolio> I guess that's not the same, but still.
18:49:25 <dolio> You can rewrite it as "data Fin :: * -> * where ..." if you enable KindSignatures or something like that.
18:49:40 <dolio> Which is possibly less misleading.
18:50:35 <dolio> The names don't have the significance they do in Agda.
18:50:49 <paczesiowa> it should be also easy to write class IsFun a b | a -> b; instance IsFun (x->y) HTrue; instance IsFun x HFalse but it doesn't work. overlapping instances know which instance to choose but they don't tell that to fundeps
18:50:57 <tsar> when using Data.Graph, why is there no show function?
18:51:07 <tsar> cant i just do pring mygraph ?
18:51:32 <rwbarton> paczesiowa: I can't verbalize exactly why, except to say being of the form a -> b is a "closed" condition, you can observe it, but not being of the form a -> b is an "open" condition
18:51:42 <rwbarton> paczesiowa: just like I can't write  f _|_ = 2; f _ = 3
18:52:13 <paczesiowa> rwbarton: I don't like bottoms
18:52:24 <dolio> But the type system doesn't have bottoms, because it terminates. :)
18:52:26 <dolio> Boom.
18:52:49 <paczesiowa> I like typelevel bottoms then:>
18:53:05 <dolio> Heh.
18:54:09 <rwbarton> But it has a similar partial order, where unification is the join, and "bottom" is called "a"
18:54:14 <paczesiowa> tsar: wouldn't you render graph instead of showing it?
18:54:19 <adu> that TypeCast makes my heard hurt
18:55:04 <paczesiowa> adu: Oleg has explanation of it in HList paper if you like some more pain
18:55:37 <adu> I thought HList was ok, i read the first 2 pages in great detail
18:56:02 <paczesiowa> adu: don't judge the paper by it's abstract:>
18:56:29 <adu> paczesiowa: no, I didn't, I just stopped reading when he started making one typeclass-per-function
18:57:13 <paczesiowa> adu: I mean it is great, but hard at the end when he explains different tricks (splitting code in different modules to make it typecheck)
18:57:23 <paczesiowa> adu: what's wrong with that?
18:57:54 <adu> bad design imho
18:57:55 <paczesiowa> adu: it is type level function - and it will look like one with those total type families
18:58:19 <paczesiowa> Oleg and bad design does not unify
18:58:44 <dolio> I'm not sure about that.
18:59:04 <thoughtpolice> some of oleg's things are definitely more practical than others
18:59:06 <dolio> Oleg is all about doing things with the existing type system that should really be given a little direct attention. :)
18:59:31 <dolio> Among other things.
18:59:44 <thoughtpolice> but his stuff always impresses IMO. i am a believer of the thought that his brain has hindley-milner built into it
18:59:46 <adu> paczesiowa: then you're saying to use HList properly all my functions need to have a value-level implementation, and a type-level implementation with an identically named type-class?
19:01:06 <paczesiowa> adu: depends on how you use it, often you don't write such a code. have you seen OOHaskell? there is no single typeclass but it is heavily based on HList
19:01:18 <adu> dolio: like making a module with 100 type-level naturals when TH would suffice?
19:01:51 <adu> paczesiowa: I read the first 3 pages of the OOHaskell paper :)
19:02:26 <dolio> Well, I was thinking more like using type classes to do stuff that GADTs do, only less obviously.
19:03:05 <dolio> Or using type class hacks that only he understands to do stuff that total type families make trivial (although they were only recently invented, of course).
19:04:12 <dolio> Not that it isn't impressive.
19:04:21 <paczesiowa> adu: here's a little piece of OOHaskell code http://hpaste.org/8496 not a single typeclass
19:04:50 <SamB_XP> @go "oleg cat"
19:04:52 <lambdabot> No Result Found.
19:04:55 <SamB_XP> @go oleg cat
19:04:57 <lambdabot> No Result Found.
19:04:59 <adu> paczesiowa: but I think the goal HList tries to solve is critical, so much so that I think the solution of that goal should go in Prelude, but I don't think HList in it's entirety is very Prelude-worthy
19:05:01 <SamB_XP> @go oleg kitty
19:05:03 <lambdabot> http://profile.myspace.com/index.cfm?fuseaction=user.viewprofile&friendID=2263396
19:05:03 <lambdabot> Title: MySpace.com - Oleg - 34 - Male - Hermitage, TENNESSEE - www.myspace.com/olegvolk
19:05:12 <SamB_XP> @go oleg lambdacats
19:05:12 <sophacles> hey all, n00b question: what type of memory management does ghc use? i did: fact=1:2:[a*b|a,b<-zip fact (tail fact)]   and then did fact !! 100000 (a couple of those 0's were typos). it totally froze my linux box. i figured it would have OOMed itself (3GB mem, 1.5G swap...)
19:05:14 <lambdabot> http://arcanux.org/lambdacats_2.html
19:05:14 <lambdabot> Title: Lambdacats
19:05:25 <adu> paczesiowa: and i mean alot by that, because I don't think RealFloat is Prelude-worthy... :)
19:05:50 <paczesiowa> adu: what about HList is so critical?
19:06:13 <adu> paczesiowa: good question
19:06:19 <adu> hmm, i dunno
19:06:27 <adu> i know it when I think of it
19:06:50 <adu> its just been so long since I've thought explicitly about how critical it is...
19:07:00 <SamB_XP> http://arcanux.org/lambdacats_2.html#entry10
19:07:01 <lambdabot> Title: Lambdacats
19:07:42 <SamB_XP> that is oleg in a nutshell ;-)
19:08:27 <paczesiowa> adu: I love types and the only way to be able to write comfortably on the typelevel is to wait for next ghc versions with new spj types or wait for new oleg post and hope it will make you smart enough to write what you need
19:09:45 <adu> SamB:  ...#4 is so cute!
19:10:23 <adu> paczesiowa: what's spj?
19:10:34 <Cale> adu: Simon Peyton Jones
19:10:40 <adu> Cale: o
19:10:48 * adu hits head against wall
19:11:06 <Philippa> sophacles: the issue there isn't the memory management, you got it stuck in a loop. And yeah, GHC doesn't allocate from the OS as often as you would expect
19:11:12 <paczesiowa> adu: you should leave quietly:>
19:11:43 <adu> paczesiowa: if it was spelled SPJ i wouldn't have asked
19:12:08 <paczesiowa> adu: yeah, my bad
19:12:19 <dolio> @quote simonpj
19:12:19 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
19:12:35 <araujo> hahaha
19:12:58 <sophacles> Philippa, i was curious as to what would happen when i realized what i did, so i ran top, and the last update before freezin showed no free memory, and ghci had 3+GB in its name...
19:13:27 <Philippa> sophacles: yeah, if you get stuck in a non-strict loop you'll generate lots and lots of thunks
19:13:28 * araujo loves spj's simplicity approach
19:13:40 <sophacles> what is a thunk?
19:13:50 <Philippa> it's how lazy evaluation is implemented
19:13:52 <Olathe> It's an unevaluated function call or something like that.
19:14:00 <wman> something that will compute a value when its needed
19:14:04 <Philippa> it's either a value or the call that'll produce that value
19:14:10 <Olathe> Ahh.
19:14:11 <adu> I thought a thunk was a closure?
19:14:22 <Olathe> It's valuable or can be made valuable.
19:14:38 <sophacles> cool
19:14:40 <lispy> adu: a thunk can close over stuff, but the def. given above is the real one
19:14:41 <Philippa> adu: they're related, but not the same thing
19:14:55 <sophacles> whats a non-strict loop?
19:15:05 <Cale> A thunk is usually actually more like a sum than a pair.
19:15:14 <lispy> sophacles: one that is building an ever growing thunk without reducing it to an evaluated form
19:15:20 <SamB_XP> a thunk is generally a closure, but not vice-versa
19:15:37 <sophacles> lispy. is there a way to force strictness?
19:15:46 <lispy> sophacles: yeah, the primitive is seq
19:15:50 <SamB_XP> sophacles: you can force values, yes
19:15:53 <Philippa> yes, but you don't want to
19:15:57 <Cale> A closure is a pair consisting of some code and an environment mapping the free variables of that code to values. A thunk is *either* some code which will compute a value, or a value.
19:16:01 <Philippa> what's wrong here is the loop, not the laziness
19:16:03 <lispy> sophacles: oh and pattern matching
19:16:21 <adu> sophacles: like y x = x $ y x
19:16:41 <Cale> (generally that code is designed to update the thunk to the value that it computes)
19:16:43 <eyu100> > [1.0..2.0]
19:16:44 <lambdabot>   [1.0,2.0]
19:16:47 <Philippa> so a thunk may well be a closed term, but that doesn't inherently make it a closure
19:16:49 <eyu100> > [1.0..2.1]
19:16:50 <lambdabot>   [1.0,2.0]
19:17:00 <lispy> Cale: Do you think quantum mechanics is really just lazy evaluation of physics :)
19:17:01 <eyu100> > []
19:17:03 <lambdabot>   []
19:17:22 <eyu100> > 7 ^ 80
19:17:23 <lambdabot>   40536215597144386832065866109016673800875222251012083746192454448001
19:17:28 <eyu100> > 2
19:17:29 <lambdabot>   2
19:17:30 * Philippa passes lispy many Worlds
19:17:31 <eyu100> > 2^ 2
19:17:32 <lambdabot>   4
19:17:40 <eyu100> > 2 ^ (2 ^ 2)
19:17:41 <lispy> Schoedinger's cat is really in a thunk not a box
19:17:41 <lambdabot>   16
19:17:54 <eyu100> > (2 ^ (2 ^ 2))
19:17:55 <lambdabot>   16
19:17:59 <eyu100> > 2^ (2 ^ (2 ^ 2))
19:18:01 <lambdabot>   65536
19:18:07 <lispy> and when you open that box (evaluate that thunk) you update the cat's status
19:18:08 <eyu100> > 2^ (2 ^ (2 ^ (2 ^ 2)))
19:18:09 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
19:18:11 <Cale> lispy: heh, I'm not sure about that, but there is a sort of nice lazy evaluation strategy.
19:18:16 <adu> Cale: did you get my slides?
19:18:16 <thoughtpolice> @quote lispy Schoedinger's cat is really in a thunk not a box
19:18:17 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
19:18:18 <eyu100> > 2 ^ (2^ (2 ^ (2 ^ (2 ^ 2))))
19:18:24 <thoughtpolice> @remember lispy Schoedinger's cat is really in a thunk not a box
19:18:24 <lambdabot> I will never forget.
19:18:25 <Cale> adu: Yes, I think so :)
19:18:28 <rwbarton> sophacles: by the way, most of the allocation in that function is being done by the big-integer arithmetic library.
19:18:33 <lambdabot>   thread killed
19:18:47 <Olathe> > take 5 $ iterate (2^) 1
19:18:50 <lambdabot>   [1,2,4,16,65536]
19:18:53 <lispy> thoughtpolice: too bad I mispelled his name in that quote :)
19:19:05 <d00gs> newbie question: if I write a function   myRev (x:xs) = (myRev xs) : x;  myRev [] = []    then ghc complains about being unable to construct an infinite type. why?
19:19:07 <dobblego> foldr (^) 1 (replicate 5 2)
19:19:08 <lispy> I left out an r for sure, who knows what else I got wrong :)
19:19:09 <dobblego> > foldr (^) 1 (replicate 5 2)
19:19:14 <Cale> adu: It's nice to see what kinds of talks people are giving about Haskell :)
19:19:16 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
19:19:33 <adu> d00gs: you have to replace : with ++
19:19:39 <d00gs> ohh
19:19:39 <d00gs> duh
19:19:41 <d00gs> thanks
19:19:47 <roconnor> Cale: are you at ICFP?
19:19:54 <Saizan> and x with [x]
19:19:58 <Cale> d00gs: whenever you have  u : v, v *must* be a list, and u must be of the same element type as that list.
19:20:05 <Olathe> > scanl1 (^) $ repeat 2
19:20:07 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
19:20:08 <Cale> d00gs: : only adds things to the front of a list.
19:20:11 <lispy> :t (:)
19:20:14 <lambdabot> forall a. a -> [a] -> [a]
19:20:15 <Olathe> That didn't work.
19:20:22 <Cale> roconnor: no
19:20:30 <Olathe> > scanl1 (flip (^)) $ repeat 2
19:20:32 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
19:20:34 <Olathe> Yay !
19:20:37 <d00gs> Cale: yep, brain fart. been too long since my sicp class
19:20:41 <lispy> I think mixing up (:) and (++) is a common mistake for haskell beginners
19:20:48 <Cale> roconnor: I have no money to fly around with :)
19:20:57 <roconnor> :)
19:20:58 * lispy faxes Cale some money
19:21:05 <adu> d00gs: actually replace : x with ++ [x]
19:21:07 <Olathe> Hahahah
19:21:07 <Cale> Thanks! This will work great!
19:21:13 <roconnor> lispy: american money?
19:21:20 <d00gs> adu: yep, understood
19:21:25 <lispy> roconnor: monopoly, actually
19:21:32 <roconnor> :)
19:21:46 <lispy> my scanner rejected the USD I put on the lens...called me a counterfieter
19:21:50 <Olathe> Monopolist !
19:22:10 <adu> Olathe: you know tetration!
19:22:17 <Olathe> I do ?
19:22:20 <lispy> (we actually tried this at the office and the machine did actually notice it was fake money...)
19:22:24 <lispy> er real money
19:22:28 <lispy> and wouldn't do the scan
19:22:29 <wman> lispy: are you using Vista ? Thats DRM for you ;-)
19:22:31 <adu> Olathe: yes, you just calculated 2-tetra-5
19:22:37 <sophacles> another n00b question, im learning from the "haskell for C programmers" and the wikibook tutorials. are there any materials you reccomend?
19:22:37 <Olathe> Oh.
19:22:43 <lispy> wman: heh, this was the physical copy machine that refused
19:23:03 <lispy> sophacles: real-world haskell is the current hot book on haskell
19:23:12 <lispy> ?where rwh
19:23:13 <lambdabot> is http://www.realworldhaskell.org/blog/
19:23:15 <SamB_XP> lispy: what?
19:23:20 <Olathe> You print US dollars in other countries, other money in the US.
19:23:43 <roconnor> http://en.wikipedia.org/wiki/EURion_constellation
19:23:44 <lambdabot> Title: EURion constellation - Wikipedia, the free encyclopedia
19:23:53 <sophacles> cool. thanks for the help all, back to the learning.
19:23:54 <lispy> SamB_XP: what what?
19:23:58 <SamB_XP> lispy: what if you had wanted to copy some important information off of it?
19:24:04 <SamB_XP> such as a URL
19:24:32 <tsar> cant i just do pring mygraph ?
19:24:34 <lispy> SamB_XP: do what we did?  folded it in half and then overlayed the halves and printed copies of that? :)
19:24:35 <tsar> i have heard that lisp is safe. how? types are checked at runtime...
19:24:36 <SamB_XP> anyway, it's not like the copy would actually look anything like money
19:24:46 * adu emails Cale some money
19:24:52 <roconnor> what's cool is that you can print the EURion constellation on your own tickets and stuff to help prevent them from being copied.
19:24:58 <lispy> tsar: it has run-time type safety.
19:25:14 <Olathe> I wonder how they got those pictures on the Wikipedia article.
19:25:27 <Olathe> Or what would happen if you tried to print it.
19:26:09 <lispy> tsar: Compare with C (a well known type unsafe language), in which you can do things that don't have obvious problems, just undefined behavior.
19:26:35 <wman> roconnor: ah, now i know why they put those ugly yellow warts on our money ;-)
19:26:48 <lispy> tsar: lisp would complain, thus perserving the rules of type safety
19:27:10 <lispy> What were the parts of type safety again?  I recall progress, but what else?
19:27:59 <lispy> (Type-) preservation "Well typedness" of programs remains invariant under the transition rules (i.e. evaluation rules or reduction rules) of the language.
19:28:02 <lispy> Progress A well typed program never gets "stuck", i.e., never gets into an undefined state where no further transitions are possible.
19:28:27 <lispy> C tends to violate "Progress" I guess?
19:28:29 <roconnor> wman: what is your money?
19:28:48 <lispy> It keeps going but in an undefined state
19:28:53 <wman> roconnor: that should work with scanners to, shouldn't it ? a new way to bug our operators, who have scanning documents in ther work description too ;-)
19:29:03 <wman> roconnor: CZK
19:29:34 <wman> scanners to, -> scanners too,
19:30:43 <tsar> doesnt htis snetence contraqdtict itself: Type safety is a property of the programming language, not of the programs themselves. For example, it is possible to write a safe program in a type-unsafe language.
19:30:52 <SamB_XP> Olathe: digicam?
19:31:28 <lispy> tsar: I don't see the contradiction
19:31:56 <lispy> tsar: They are saying that, the language is inherently unsound, but particular programs in the language might be perfectly sound
19:32:46 <lispy> tsar: in most languages that lack type safety have some type safe parts.  When you use only those parts, the resulting program is safe.
19:33:05 <tsar> yeah i misinterpreted
19:33:16 <wman> it seems to me that an algorithm can be correct, but in type-unsafe lang there is no way to prove it?
19:34:00 <lispy> wman: I think you could still prove it, provided you only do type safe things in the algorithm
19:34:17 <bd_> proving correctness might be impossible in any case, in a turing complete language...
19:34:31 <wman> lispy: like no coercion ?
19:34:57 <bd_> although I'm not sure if you can turn an algorithm-comparer into a turing oracle
19:34:57 <tsar> is unsafePerformIO only for testing and should never be used ina real program?
19:35:16 <lispy> wman: coercion isn't always unsafe, or in some more sophisticated type systems you could prove that coercion was fine.  So your level of reasoning will matter I think.
19:35:25 <bd_> tsar: unsafePerformIO is used internally in certain libraries. It should only be used when you truly understand the guts of how GHC is implemented...
19:35:26 <SamB_XP> wman: at any rate, the compiler isn't expected to do so in a type-unsafe language, nor is the programmer
19:37:01 <lispy> I like the definition that unsafePerformIO is safe when you can't observe it through the exposed API.
19:37:08 <lispy> But, that's a very cyclic definition :)
19:38:23 <wman> can careless usage of unsafePerformIO lead to actions getting executed in wrong order ?
19:38:52 <dolio> Careless usage of unsafePerformIO can lead to segfaults.
19:38:53 <paczesiowa> yes
19:39:15 * lispy begins to wonder if students are doing homework or just asking good questions today
19:40:00 <thoughtpolice> wman: totally, that's why the IO monad sequentializes actions since the order things happen in is very critical
19:40:08 <chrisdone> lazy evaluation generally leads to unexpected order of evaluation with respect to unsafely performed IO, imo, which is demonstrated when newbies come to haskell and need a printf() debug substitute and use Debug.Trace and end up wtf'ing that it's printing out totally backwards
19:40:18 <thoughtpolice> and yeah you can use unsafePerformIO to create unsafeCoerce which is naturally bad :]
19:41:07 <bd_> unsafePerformIO can lead to actions getting executed multiple times, never mind the order :)
19:41:15 <chrisdone> ;_;
19:41:33 <chrisdone> but what about memoizing!?!?!â½
19:42:13 <bd_> chrisdone: in GHC's implementation of the threaded RTS, with multiple threads (+RTS -Nn), thunks may be executed multiple times, if two threads force one thunk at the same itme
19:42:16 <bd_> time*
19:42:25 <chrisdone> wow, that happens?
19:42:29 <bd_> I don't think unsafePerformIO has any kind of guards against this, though I could be wrong
19:42:47 <chrisdone> is that some kind of bug?
19:42:51 <bd_> chrisdone: yeah, if the thunk runs long enough then the RTS notices it and blocks one of the threads
19:42:54 <bd_> it's intentional
19:43:11 <bd_> for small thunks it's cheaper to allow it to be evaluated twice than to try to prevent this
19:43:13 <rwbarton> I assume it's to avoid paying a large locking overhead of some kind
19:43:14 <SamB_XP> there are two versions
19:43:19 <chrisdone> true
19:43:24 <bd_> for larger ones it finds out at the next GC
19:43:34 <bd_> or possibly sooner
19:43:36 <wman> that hit me once too, happs just served the same page without consulting the DB, so u jest have to do the heavy-lifting(tm) ;-)
19:43:43 <SamB_XP> one prevents multiple executions, the other at least guards against incomplete executions ...
19:43:57 <bd_> SamB_XP: of unsafePerformIO?
19:44:02 <wman> u jest -> i just (and i should probably get some sleep ;-)
19:44:04 <SamB_XP> bd_: yes
19:44:21 <lispy> unsafePerformIO can lead to losts of redundant IO actions even if you don't use threaded
19:44:52 <bd_> SamB_XP: is there one that's totally unprotected for when whatever you're doing is secretly completely pure, eg in bytestring?
19:44:59 <thoughtpolice> generally speaking unsafe* functions can lead to lots of things
19:45:15 <SamB_XP> bd_: not that I know of ...
19:45:47 <SamB_XP> bd_: but I think the latter one is probably fine for that case anyway...
19:46:08 <chrisdone> anyone got an IRC library which maintains the connection to the server for you and other nicities that you end up implementing every time you write an IRC program?
19:46:53 <wman> maybe lambdabot ?
19:49:12 <chrisdone> I mean a library.. I was thinking of adding something to Network.IRC
19:50:19 <wman> i saw lambdabot recommended when someone asked for irc library. even hircules (old irc client) was based on some lambdabot code ...
19:50:20 <Saizan> yeah, Network.IRC is only a parser/printer
19:51:58 <chrisdone> lambdabot is huge though, as a dependancy
19:52:06 <thoughtpolice> chrisdone: building something on-top of Network.IRC shouldn't be too troublesome
19:52:42 <chrisdone> I agree
19:52:49 <thoughtpolice> I used it for my own IRC bot and it's pretty straight forward, although right now it can only return String and not e.g. ByteString which would probably be nice if you're on multiple channels/server
19:53:01 <thoughtpolice> s/return/parse/
19:53:24 <thoughtpolice> i talked to trevor (the author) about it a while back, was thinking about making a parsec3 version
19:53:32 <Saizan> it would be very nice if someone wrapped it up as a library though
19:56:20 <chrisdone> I don't see why Network.IRC just has to be a text library
19:56:56 <roconnor> > map (\x -> 0^(0^x)) [0..]
19:56:57 <lambdabot>   [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:57:25 <Saizan> chrisdone: i actually think that's a little weird, since it's under Network.
19:58:10 <chrisdone> Saizan: yeah. âNetworkâ is a little dubious, it could easily be Text.IRC
19:59:52 <wman> just checked lambdabot, seems like the irc code is mainly localized in two modules
20:00:22 <chrisdone> right, IRCBase
20:00:37 <chrisdone> and Message
20:00:48 <Saizan> chrisdone: maybe you could contact the author and add the "Network" part to the package :)
20:03:08 <chrisdone> some of the stuff in here could be provided by Network.IRC
20:04:10 <chrisdone> actually most of it
20:04:15 <chrisdone> Saizan: right
20:04:38 <chrisdone> take this program: http://paste.lisp.org/display/67304 (rss2irc)
20:04:52 <chrisdone> the IRC connection stuff could be abstracted
20:06:01 <chrisdone> not sure why that program uses parallelism
20:08:24 <chrisdone> dons: why *does* it?
20:09:14 <dancor> anyone willing to look at the doAskMethod function in http://dzl.no-ip.org:81/gitweb/?p=mem.git;a=blob;f=src/Main.hs and tell me: 1) if it's hideous 2) tips to make it less so
20:10:53 <Saizan> chrisdone: well, you can't do it with less than two threads, one has to respond to pings while the other is sleeping :)
20:13:36 <chrisdone> Saizan: I mean the parallelism strategy
20:22:59 <mmorrow> good night
20:23:20 <TomMD> Good night
20:31:10 <wman> night
20:31:20 <wman> night
20:31:40 <wman> fuck, i had my window scrolled up ;-)
20:37:23 <dblazakis> how can i do this without using the do notation?  do { x < -f; g; return x}
20:37:44 <dblazakis> const?
20:37:48 <dblazakis> fmap const
20:37:49 <sjanssen> @undo do x <- f; g; return x
20:37:49 <lambdabot> f >>= \ x -> g >> return x
20:38:06 <sjanssen> @. pl undo do x <- f; g; return x
20:38:07 <lambdabot> (g >>) . return =<< f
20:38:07 <dblazakis> :t const
20:38:08 <lambdabot> forall a b. a -> b -> a
20:38:29 <sjanssen> dblazakis: const isn't right
20:38:45 <sjanssen> there is a function for this in Control.Applicative
20:38:49 <newsham> ?src (<<)
20:38:49 <lambdabot> Source not found. You speak an infinite deal of nothing
20:39:36 <sjanssen> @type (<*)
20:39:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
20:40:35 <newsham> doesnt Parsec have a (<<) which does that?
20:40:44 <HanDongSeong> what -package option should i give when compiling a code using STM?
20:41:14 <dblazakis> so why wouldn't liftM2 const f g work? (i haven't tried it, but just wondering where my logic is going wrong)
20:41:30 <dblazakis> oh wait wouldn't get evaluated
20:41:38 <dblazakis> hrm
20:42:12 <dblazakis> newsham: i don't see one
20:42:25 <newsham> do { x <- f; y <- g; return (const x y) }
20:42:41 <newsham> should run both f and g before returning x
20:42:58 <sjanssen> newsham: what is the point with const there?
20:43:08 <newsham> liftM2 const f g
20:43:20 <newsham> just expanding it
20:43:23 <sjanssen> ah
20:43:36 <dblazakis> oh, so it would work. i was confusing myself with the lift
20:44:08 <newsham> dblazakis: the value of y would never get evaluated past its whnf, but the side effects of g would already happen
20:44:33 <dblazakis> right, side effects are the point if i wasn't using the value anyway -- and why i wanted something const like
20:44:39 <newsham> *nod*
20:45:34 <dblazakis> thanks guys!
20:46:10 <newsham> i coulda swore there was a standard def for monads like (<*)
20:47:55 <dblazakis> i'm guessing there is something, it doesn't seem that rare, esp in parsec
20:49:28 <newsham> char '"' >> many digit << char '"'     stuff like that
20:50:00 <ddarius> *> <*
20:50:10 <ddarius> Applicative
20:53:29 <bran> has anyone written a style guide for haskell ...e.g. pep 8 (http://www.python.org/dev/peps/pep-0008/)
20:53:31 <lambdabot> Title: PEP 8 -- Style Guide for Python Code
20:53:45 <bbs> hey guys
20:53:49 <bbs> http://rafb.net/p/ISbaR716.html
20:53:51 <bbs> i'm lost
20:53:54 <lambdabot> Title: Nopaste - haskell help!
20:54:00 <bbs> i just want that to do a proper union of two sets
20:54:05 <bbs> and i'm getting a wrong type
20:54:43 <bbs> http://rafb.net/p/RZDZ3277.html
20:54:44 <lambdabot> Title: Nopaste - haskell help
20:54:47 <Cale> bran: The general rule is that things at the same level should be lined up, and things which are part of other things should be indented further. We generally use camelCase, and tabs do not occur anywhere in source files.
20:54:49 <bbs> and thats the error i am getting
20:54:55 <Cale> bran: Is that the sort of thing you're looking for?
20:54:57 <newsham> "union a ys" you're treating 'a" like an element and "ys" like a list
20:55:05 <newsham> but the other defs treat both args as a list
20:55:22 <bbs> newsham: i can't do that? how should i fix that?
20:55:35 <newsham> bbs: allyour definitions of union must have the same type of args
20:55:44 <bbs> namely no nested lists?
20:55:47 <newsham> what is the type of the union function you want?
20:55:54 <newsham> you can support nested lists
20:56:03 <newsham> but all of the types must be similar
20:56:26 <bbs> newsham: i mean like -- i take union [1,2,3,4] [2,3,4,5,5,6]
20:56:35 <bbs> and it returns [1,2,3,4,5,6]
20:56:37 <Cale> (therefore, if you assume a list is nested to some depth, you must assume that it's nested to the same depth in all the cases
20:56:38 <Cale> )
20:56:39 <newsham> for example in line 9:     "union x ys : union xs ys"  your first call wants to take an element and a list
20:56:46 <newsham> but your second call wants to take a list and a list
20:56:47 <bran> bbs: the 3rd case of your function is a different type than 1,2,4
20:57:17 <newsham> so you want something like   union :: [Int] -> [Int] -> [Int]   but perhaps more general?
20:57:29 * Cale starts to get frustrated with his connection and considers running downstairs to reset everything...
20:58:30 <newsham> (that was a question)
20:59:23 <bbs> newsham: yea
20:59:24 <bbs> exactly
20:59:27 <bbs> it needs to be ints
20:59:48 <newsham> ok, so do you see in line 9 of your paste how the first call to union passes Int and [Int]?
20:59:50 <bran> cale: some code i've seen uses do blocks with {} and ;
20:59:54 <newsham> instead of [Int] and [Int] ?
20:59:55 <bran> other uses whitespace solely
21:00:41 <newsham> if (x:xs) :: Int then x :: Int
21:00:51 <newsham> oops.. restate.   if (x:xs) :: [Int] then x :: Int
21:01:05 <bbs> newsham: so how can i fix that line
21:01:14 <bbs> grr haskell makes me so frusterated
21:01:36 <newsham> you dont make a call to union with an Int and an [Int].
21:01:40 <newsham> it just doesnt make sense.
21:01:41 <adu> lololol
21:01:57 <adu> http://www.lolcatbible.com/index.php?title=Genesis_1
21:02:01 <Cale_> bran: Yes, either style is fine, but people generally prefer layout when possible
21:02:01 <newsham> also you should probably explicitely state the type of union :: [Int] -> [Int] -> [Int] so you and the compiler are aware what you intend
21:02:03 <lambdabot> Title: Genesis 1 - LOLCat Bible Translation Project
21:02:08 <bran> bbs: you're really close
21:04:23 <tennin> I like verse 31
21:05:21 <TomMD> Does anyone have news on GHC 6.10?  I've been so very patient, but another month might cause me physical pain.
21:06:04 <dolio> They released a beta on Sunday.
21:06:20 <bbs> bran: i just don't get it
21:06:45 <newsham> bbs: can you see which definitions and calls obey that type and which dont?
21:07:11 <bbs>         union x ys: union xs ys
21:07:21 <bbs> that should be union xs ys: union x ys?
21:07:48 <newsham> lf "union :: [Int] -> [Int] -> [Int]
21:07:50 <bbs> the list would be on the left there and it wouldn't be left to right assosiative
21:08:26 <newsham> blah, gotta go
21:08:36 <adu> TomMD: physical? how so?
21:09:07 <TomMD> adu: I'm tearing my hair out over a bug ;-)
21:09:14 <adu> o
21:09:44 <TomMD> bbs: If you can see which instance is incorrect then try to inline that declaration in the calling function.
21:10:08 <adu> TomMD: i was hoping you were referring to RSI
21:10:14 <TomMD> RSI?
21:10:44 <adu> repetitive strain injury? or something
21:11:35 <qwr> bbs: the lines 2 and 3 really don't match ;)
21:12:05 <TomMD> adu: ah, yes - just was going through wikipedia: Religous Science International... Italian Social Republic ...
21:12:24 <qwr> bbs: and 8/9 is nonsense.
21:12:26 <Taggnostr> http://book.realworldhaskell.org/read/
21:12:31 <lambdabot> Title: Real World Haskell
21:12:49 <adu> RWH is the new CTL
21:13:00 <dmwit> CTL is the new TLA
21:13:16 <adu> whats TLA?
21:13:18 <Taggnostr> WTF?
21:13:24 <TomMD> Three letter acronym.
21:13:27 <dmwit> What's CTL?
21:13:33 <ivanm> according to where I've pre-ordered RWH, its due for publication on 19 October... is this right?
21:13:54 <qwr> bbs: so do something like x:xs and on line 3 and fix the if condition to do right thing for that
21:14:00 <Taggnostr> there's written november 2008 on the site
21:14:20 <adu> dmwit: oops, I meant K&R
21:14:23 <qwr> bbs: but currently the code smells bad magic ;)
21:15:19 <dmwit> adu: That is one *hell* of a typo!
21:16:49 <qwr> bbs: if elem x ys then union xs ys else x : union xs ys would type for example. i'm not going to guess what you really want that code to do... though
21:17:00 <bran> bbs: http://paste.lisp.org/display/67309
21:17:32 <bran> i think this is roughly what you meant to write
21:19:05 <dancor> my lambdabuild doesn't like "> first (+1) (2,3)"
21:19:22 <Olathe> > first (+1) (2,3)
21:19:23 <lambdabot>   mueval: Prelude.read: no parse
21:19:27 <sjanssen> does anyone know if specconstr works on Int arguments?
21:19:28 <dancor> i'm not alone!
21:19:42 <Olathe> > first
21:19:43 <lambdabot>       Overlapping instances for Show (a b c -> a (b, d) (c, d))
21:19:43 <lambdabot>        arisin...
21:19:49 <Olathe> > first (+1)
21:19:50 <lambdabot>       Overlapping instances for Show ((b, d) -> (b, d))
21:19:50 <lambdabot>        arising from a...
21:20:01 <Olathe> > first (+1) (2, 3)
21:20:02 <lambdabot>   mueval: Prelude.read: no parse
21:20:10 <Olathe> > first (+1) $ (2, 3)
21:20:11 <lambdabot>   mueval: Prelude.read: no parse
21:20:12 <dancor> anyway, this works: ~ mueval -m Control.Arrow -e 'first (+1) (2,3)'
21:20:13 <Olathe> Yay !
21:20:24 <dancor> but not  ~ mueval -l State/L.hs -e ..
21:20:41 <dancor> does -l not work like i think it does?
21:24:04 <dancor> , first (+1) (2,3)
21:24:08 <lunabot>      Ambiguous occurrence `first'
21:24:15 <dancor> , AT.first (+1) (2,3)
21:24:16 <lunabot>   Not in scope: `AT.first'
21:24:23 <dancor> , Control.Arrow.first (+1) (2,3)
21:24:24 <lunabot>  (3,3)
21:24:33 <dancor> > Control.Arrow.first (+1) (2,3)
21:24:34 <lambdabot>   mueval: Prelude.read: no parse
21:24:46 <dancor> @hoogle first
21:24:47 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
21:24:47 <lambdabot> Data.Monoid newtype First a
21:24:47 <lambdabot> Data.Monoid First :: Maybe a -> First a
21:24:53 <dancor> there is no other first!
21:24:55 <Cale> bran: one nice thing in Haskell is that nobody argues about how much things are indented, so long as the right things line up :)
21:25:52 * dancor is reminded of befunge by haskell's layout
21:26:06 <Cale> heh
21:26:38 <Cale> We should create a beFUNge which is purely functional, somehow :)
21:26:43 <dolio> Dude, we should totally switch to a C-like syntax.
21:26:47 <dancor> just for the pun of it
21:26:56 <dolio> For the noobs.
21:27:15 <Cale> dolio: We already can have braces and semicolons :)
21:27:17 <dancor> {} is there
21:27:26 <dolio> :)
21:35:00 <sjanssen> if anyone was curious: constructor specialization does work on Int constants
21:35:04 <sjanssen> rather handy, that
21:35:29 <Cale> For which small values?
21:35:38 <Cale> er...
21:35:42 <sjanssen> 1 and 0 is all I've tried so far
21:36:11 <sjanssen> Cale: it only specializes constants that are patterns on the LHS
21:36:20 <sjanssen> I think.
21:36:22 <Cale> ah
21:36:39 <sjanssen> though that would be an interesting experiment
21:37:19 <sjanssen> I'm trying to write some parallel recursive code, and I want to dispatch to the serial path after a few levels of recursion
21:37:23 <Cale> I was initially confused and thinking of pointer tagging.
21:38:14 <sjanssen> it looks like constructor specialization can help me do that without much pain
21:55:39 <roconnor> I'm thinking it is better to implement an algebra as a ring that happens to be a module, because the scaler operation can more or less always be turned into the ring operation.
21:56:54 <dmwit> Yeah.
21:57:00 <roconnor> so there is a kind of ring-normal form
21:57:27 * dmwit points at roconnor
21:57:31 <dmwit> what he said
21:57:43 * roconnor nods
21:57:48 <LunarCrisis> can I nest these two constructs to put the loop into the main factorial function? http://hpaste.org/10624
21:58:11 <dmwit> ?faq Can I nest these two constructs?
21:58:12 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:41 <LunarCrisis> =p
21:58:50 <LunarCrisis> ok, so then the question is, how?
21:59:04 <dmwit> I went ahead and added a "'" in there while I was demonstrating how.
21:59:31 <roconnor> I guess the function (fun x => scale x 1) from the field to the algebra isn't necessarily an injection?
21:59:34 <dmwit> Oh, and one more on the last line.
22:00:39 <LunarCrisis> I only see the one missing on the last line, where was the other one?
22:00:45 <roconnor> er the function from the ring that you are a module over to the algebra isn't ...
22:00:48 <kake05> asi se hace.. el otro esta mal hecho factorial n+1 = (n+1) * factorial n
22:01:01 <roconnor> if it is a field, I wouldn't be surprised if it must be injective.
22:01:16 <dmwit> LunarCrisis: I added one on the LHS, and you need another one on the RHS.
22:01:27 <LunarCrisis> ok
22:01:33 <dmwit> kake05: Hola!  Sabe que hay #haskell-es?
22:01:34 <LunarCrisis> cool, thanks for the demo dmwit!
22:02:36 <dmwit> kake05: (Y necesita ... como se dice "parentheses"? "(" y ")")
22:02:49 <dmwit> factorial (n+1) = (n+1) * factorial n
22:02:56 <kake05> dmwit: pero si no hay nadie en haskell es
22:03:04 <dmwit> =/
22:03:45 <kake05> bueno.. yo pase eso porq el pibe lo hice pero lo hiso recursivo
22:03:50 <kake05> y eso esta mal programado
22:04:27 <dmwit> kake05: Tiene un caso como "factorial 0 = 1"?
22:05:17 <kake05> si, lo tiene.. no viste que lo paso recien? pero igual, no se debe programar con recursividad cuando se puede hacerlo sin
22:06:12 <glguy> #haskell-es is a good placd for a conversation in Spanish
22:06:21 <dmwit> kake05: Ah!
22:06:25 <dmwit> > product [1..5]
22:06:26 <lambdabot>   120
22:06:38 <LunarCrisis> In scheme it's customary to use a word like 'loop' for small internal recursive functions. Does this read well in haskell as well? http://hpaste.org/10624#a3
22:06:55 <kake05> glguy: andate vos a charlar a la sala en español.. no hay nadie:P
22:07:08 <dmwit> LunarCrisis: It's okay, but usually it's preferred to turn it into a list operation.
22:07:11 <LunarCrisis> ok
22:07:24 <dmwit> LunarCrisis: My example above, "product [1..n]", is a great example of this.
22:07:24 <LunarCrisis> I've seen factorial n = product [1..n]
22:07:27 <dmwit> right
22:07:37 <dmwit> "loop" is fine
22:07:40 <LunarCrisis> I wasn't really asking for factorial, more how to nest loops nicely
22:07:51 <dmwit> right
22:07:52 <glguy> kake05: I don't understand Spanish. This is the English-speaking channel.
22:07:56 <LunarCrisis> and factorial is the perpetually convenient example =p
22:07:59 <LunarCrisis> thanks dmwit
22:08:11 <dmwit> LunarCrisis: Mostly, people just add a "'" for their inner loop.
22:08:38 <dmwit> glguy: He's complaining that there's nobody there in #haskell-es.
22:08:38 <kake05> dmwit: explicale a glguy que no hay nadie en la sala en español:P
22:08:48 <dmwit> One second.
22:08:50 <kake05> gracias, me leiste el pensamiento
22:09:11 <ddarius> Maybe it is #haskell.es?
22:10:03 <dmwit> Ah, so it is!
22:11:02 <kake05> google traslator
22:11:03 <kake05> there is never anyone in the Spanish channel
22:11:22 <glguy> but the conversation you and dmwit were having could be held there
22:11:26 <dmwit> Right.
22:11:29 <dmwit> You're right.
22:11:40 <dmwit> kake05: Estoy alli ahora.
22:12:50 <kake05> glguy:Why bother you so much that someone speaks Spanish?
22:14:06 <LunarCrisis> there should be a bot which connects the two channels through google translate XD
22:14:13 <glguy> kake05: This is the English-speaking channel. It is the common language that everyone who has joined can expect to communicate with
22:14:16 <LunarCrisis> that would be awesome, but totally useless
22:14:22 <glguy> other languages clutter of the channel for the others
22:14:47 <wman> kake: maybe he thought you are making fun of him ;-)
22:15:03 * dmwit notes that there wasn't that much other activity to "clutter"
22:15:13 <glguy> I don't have anything against Spanish-speaking individuals ;)
22:15:25 <dmwit> Still, you're right that it would have been more polite to move there.
22:16:09 <glguy> speaking in Spanish in #haskell is analogous to speaking of baseball in #haskell ;)
22:16:17 <dmwit> Not at all!
22:16:17 <wman> speaking about activities, how does #haskell feel about mildly sick jokes ? cause the ?faq command inspired something in me ;-)
22:16:25 <dmwit> People wander off-topic in English all the time. =D
22:16:38 <glguy> but they are similarly nudged :-p
22:16:53 * dmwit wonders if he hangs out in the same #haskell as glguy
22:17:23 <glguy> anyway, if you want to petition to change policies, #haskell-ops is the place to do it
22:17:34 <sjanssen> huh, there's a #haskell-ops?
22:19:26 -ChanServ(ChanServ@services.)- glguy set flags +VO on sjanssen.
22:19:41 -ChanServ(ChanServ@services.)- glguy set flags -O on sjanssen.
22:20:18 <dons> yo.
22:21:35 <dons> anyone know debian or ubuntu?
22:21:38 -ChanServ(ChanServ@services.)- glguy set flags -V on sjanssen.
22:21:44 <dons> and can find out if regex-pcre-builtin is available there?
22:21:54 <dons> something like: libghc6-regex-pcre-builtin-dev ?
22:22:51 <dancor> LunarCrisis: we could totally make a #haskell-en-all that did it for now..
22:23:32 <wman> dons: http://packages.debian.org/search?suite=all&keywords=haskell
22:23:35 <lambdabot> Title: Debian -- Package Search Results -- haskell
22:24:05 <dolio> I don't see any pcre packages.
22:24:12 <dolio> On ubuntu.
22:24:13 * Twey blinks at glguy.
22:24:17 <dons> right. so i think they've no packages for the pcre bindings
22:24:27 <dons> so i'll go back to igouy and ask that the hackage package be built.
22:24:48 <Twey> I do wonder why #haskell is English-language
22:24:51 <wman> debian got pcre-light, regex-base regex-compat & regex-posix
22:25:06 <Twey> There's a bunch of haskell.<lang> channels
22:25:17 <Twey> Why isn't the English-only channel #haskell.en?
22:25:25 <vininim> we're still trying to learn lojban
22:25:34 <rwbarton> Twey: We all speak different kinds of English here :)
22:25:45 <sjanssen> Twey: English is the de facto language of the internet
22:25:51 <glguy> Twey: nature of the Internet, same reason for example.ca vs example.com
22:25:56 <dons> wman: weird.
22:26:00 <dons> so no regex-pcre ?
22:26:01 <Twey> vininim: xu do ja'a go'i .i mi pu za go'i :)
22:26:10 <dons> its all rather arbitrary what has been packaged.
22:26:14 <dons> what we need is some kind of ... platform.
22:26:18 <dons> a haskell platform.
22:26:20 <dons> with batteries included.
22:26:21 <eelco> haha
22:26:26 <vininim> heh
22:26:27 <eelco> you pimp
22:26:30 <Twey> glguy: That's because America got there first and crushed all other languages technologically
22:26:39 <glguy> and here we are
22:27:06 <dons> let's talk 'mercan
22:27:26 <Twey> Ah c'n tawk Merkin bi'er than yew can tawk Merkin!
22:27:41 <joed> Dude..
22:27:43 <wman> dons: on that page it seems like no, but i don't have debian installed anywhere (all gentoo guy, it's easier to just install gentoo straight than to loose 2 days trying to fix debian and then turning to gentoo ;-))
22:27:49 <glguy> I guess ignorance is bliss
22:28:00 <dons> wman: yeah.
22:28:03 <dons> debian is a special case.
22:28:07 <dons> and ubuntu by implication
22:28:07 <mornfall> glguy: Agreed.
22:28:15 * Twey shakes vis head.
22:28:31 <dons> glguy is in canada at the moment. suspicous, no?
22:28:42 <Twey> Anyway, I don't like the idea of having a 'default' language
22:28:59 <Twey> Perhaps if it were a constructed universal language, but...
22:29:11 <mornfall> Twey: It's got practical advantages, though.
22:29:22 <dons> newsham: did you see regex-dna got updated?
22:29:27 <dons> still waiting on regex-pcre,
22:29:34 <dons> but we did get a bump even with regex-posix
22:29:36 <Twey> mornfall: Only for people in English-speaking countries
22:29:37 <ozy`> Twey: except, universal conlangs tend to suck...
22:29:40 <LunarCrisis> Twey, don't know about esperanto? =p
22:29:41 <mornfall> Twey: Untrue.
22:29:56 <wman> great joke and best summary of ubuntu i've seen : http://xkcd.com/424/
22:29:57 <lambdabot> Title: xkcd - A Webcomic - Security Holes
22:30:00 <ozy`> Esperanto sucks
22:30:05 <dons> sjanssen: so was binary-trees on hpaste ready?
22:30:09 <mornfall> Twey: I'm in Czech (or Slovak, depends on when exactly) speaking country and I still find it rather advantageous.
22:30:17 <Twey> Significant disadvantage for non-English-speakers, since a) they have to learn another language to do anything, and b) they've then got a significant disadvantage
22:30:38 <glguy> Twey: better for mornfall that we use french english *and* spanish?
22:31:09 <wman> mornfall:  where are you from (i'm from prague)
22:31:17 <mornfall> Twey: You should look at it the other way. It gives non-English-natives a distinct advantage of knowing two languages.
22:31:19 <lament> se habla haskell
22:31:21 <mornfall> wman: Right now, Brno.
22:31:25 <LunarCrisis> Hey, I'm learning Japanese
22:31:29 <LunarCrisis> we should work that in somehow
22:31:38 <mornfall> Twey: Which makes learning a third easier than it is for English-natives to learn second.
22:31:50 <mornfall> Twey: So basically, we win for a not-so-big investment.
22:31:52 <wman> cool, let everybody pick some different language ;-)
22:32:17 <wman> mornfall: not Invex, i hope ?
22:32:22 <ozy`> I say we should all speak Ithkuil
22:32:25 <mornfall> wman: There's Invex again?
22:32:30 <LunarCrisis> you know, if everyone just spoke and no-one listened to what anyone said, we wouldn't have this whole incompatible language problem
22:32:34 <mornfall> wman: No, faculty of informatics, and red hat.
22:32:45 <Twey> mornfall: Heh, fair point.
22:32:54 <lament> LunarCrisis: la la la i'm not listening
22:33:11 <mornfall> Twey: I actually heard English natives lament about how they suck at languages. : - ]
22:33:24 <Twey> Yeah, me too :-\  Frequently
22:33:24 <sjanssen> dons: http://hpaste.org/10614#a1 is my current version
22:33:31 <wman> well, we had to prepare a few notebook for our dumbheads (i mean bosses), so i guess it is ;-)
22:33:40 <lament> mornfall: that's only because the knowledge of english permanently damages their feeble brains
22:33:56 * mornfall giggles
22:34:04 <dons> sjanssen: is it good to go?
22:34:08 <dancor> shouldn't the dutch channel be #haskell.nl
22:34:10 <dons> want quad core testing?
22:34:21 <dancor> standardization thrown out the window
22:34:26 <ivanm> dons: any news on when RWH should be coming out?
22:34:29 <mornfall> wman: You're a student? Or something extraordinary got you over to #haskell?
22:34:40 <dons> ivanm: no news beyond 'november'
22:34:48 <sjanssen> dons: should be good to go, and yes please on the quad core testing
22:34:48 <dons> there's been no delays, afaik
22:34:51 <dons> ok.
22:34:54 <eelco> dancor: but dutch is also spoken in .be ;)
22:35:13 <ivanm> dons: well, the mob I'm pre-ordering from still says octoboer 16 :s
22:35:20 <Twey> lament: *chuckles*
22:35:28 <dons> ivanm: oh, that's wrong :)
22:35:29 <dancor> eelco: hey i'm not racist, ISO 639-1 is
22:35:56 <ivanm> heh
22:36:54 <lament> nl, be, those things aren't even countries :P
22:36:56 <wman> mornfall: yeah, something extraordinary, haskell itself ;-)
22:37:19 <lament> they're just cogs in the machine of the almighty union!!
22:37:31 <eelco> lament: according to wikipedia they probably are ;)
22:37:49 <dancor> until russia invades them
22:38:12 <wman> mornfall: not studying officially, but learning new languages is a hobby/fetish of mine, so you can count me even into this category ...
22:38:13 <lament> eelco: that's just because reality has a strong liberal bias
22:38:15 <glguy> Anyway, so back to Haskell ;)
22:38:38 <wman> glguy: where to ?
22:38:42 <wman> ;-)
22:38:53 <dancor> is there anything for ordered Map's
22:39:06 <dancor> it seems like you can do Map k (v, Int)
22:39:11 <thoughtpolice> dons: if I use data.binary to, say, serialize some data structure into a bytestring and feed it through the network with something like network-bytestring, will the result of the unpack on the other side of the line (by say another haskell application running on a different system/architecture) be identical or are there any pitfalls there?
22:39:22 <dancor> or define map-stuff on a list
22:39:40 <dancor> OR have internal reps of both a map and a list in some OMap type
22:39:53 <dmwit> I just got a bad surprise:
22:39:59 <dons> thoughtpolice: identical
22:40:08 <thoughtpolice> dons: yay.
22:40:10 <dmwit> > let factorial (n+1) = (n+1) * factorial n; factorial 0 = 1 in factorial 30 -- actually works
22:40:11 <lambdabot>   265252859812191058636308480000000
22:40:14 <dons> it uses network order encoding consistent across all haskell-binary implementations
22:40:21 <dmwit> BAH on n+k patterns.
22:40:49 <dancor> are those just hacked into pattern matching
22:40:51 <dancor> as a special case
22:41:23 <dancor> there are a lot of cool possibilities if you have all invertible functions
22:41:37 <dons> thoughtpolice: sounds like rl was greatful for the submission.
22:42:05 <mornfall> wman: : - )
22:44:31 <wman> why are n+k patterns so hated by some people ? there seem to be a few cases where they allow shorter definitions.
22:45:04 <dmwit> Because (+) is not a constructor.
22:45:14 <dmwit> Which makes it so non-orthogonal and weird.
22:45:19 <lament> some people have more respect for a language the smaller the size of its spec is
22:46:19 <wman> well, haskell is probably not going to beat scheme, at least until r10rs ;-)
22:48:14 <dons> no one hates them
22:48:19 <dons> they're just pointless :)
22:48:58 <wman> dmwit: if you look at them as just a convenient notation, they don't seem as ugly (probably got used to common lisp, macros and reader hooks too much for my own good)
22:49:35 <dmwit> wman: But (n+1) only matches positive numbers!
22:49:41 <dmwit> That is such a hack.
22:49:58 <lament> are n+k patterns convenient for actual programming, or only for stupid made-up examples with primitive arithmetic functions?
22:50:00 <wman> yeah, and if you know that fack, that makes it so convenient ;-)
22:50:13 <dmwit> > let foo (n+1) = n+1 in foo 0
22:50:14 <lambdabot>   mueval: Prelude.read: no parse
22:50:15 <lambdabot>  mueval: *** Exception: /tmp/862805554935284...
22:50:20 <dmwit> It makes equational reasoning void.
22:50:24 <dmwit> That is *bad*.
22:50:31 <quicksilver> there are other technical reasons to dislike them
22:50:38 <quicksilver> they interact poorly with language extensions
22:50:43 <quicksilver> but I forget the details
22:51:19 <dons> sjanssen: tested on dual core?
22:51:40 <sjanssen> dons: I don't have a dual core available at the moment?
22:51:53 <sjanssen> s/?/.
22:52:13 <wman> well, others who know haskell better probably know better than me, to me they just seemed like a compile-time transformation that could be used to your convenience. not that i would miss them terrinbly ...
22:52:14 <dons> ok. i think the strategy's a bit wonky then, couldn't get it to use more than 100%.:/
22:52:26 <dons> maybe its the GC.
22:53:15 <dons> ah, yes.
22:53:23 <dons> still only just over 100% cpu. weird.
22:53:36 <sjanssen> probably underscheduling, then
22:54:59 <dons> ./C 20 +RTS -N2 -A500M  29.09s user 1.12s system 102% cpu 29.387 total
22:55:01 <dons> best i could do.
22:55:34 <sjanssen> you took the second version on hpaste, right?
22:55:54 <dons> http://hpaste.org/10614#a1 ?
22:56:03 <sjanssen> right
22:56:18 <dons> something weird going on.
22:56:42 <sjanssen> try overscheduling it with +RTS -N4?
22:57:29 <dons> trying..
22:58:17 <dons> let me try on quad core too. i was just on dual core.
23:11:08 <kake05> chau hasta mañana. goodbye until tomorrow. addio fino a domani
23:23:21 <thoughtpolice> dons: you package new stuff for archlinux close to the speed of light, I swear :]
23:35:22 <dons> thoughtpolice: by the power of haskell!
23:35:45 <dons> haskell: indistinguishable from magic
23:36:15 <lament> dons: that's only because neither has side effects.
23:37:14 <dons> "This language is a sysadmins dream come true. Its simpilar to learn than c and more powerfull
23:37:17 <dons> than perl"
23:37:19 <dons> http://www.jcowie.co.uk/2008/09/haskell-the-verdict/
23:37:20 <lambdabot> Title: Haskell, the verdict! | James Cowie
23:37:22 <dons> wow. weird.
23:37:28 <dons> byorgey_: hwn worthy
23:37:30 <Vq^> reminds me of that land-of-lisp comic
23:46:52 <humasect> what is a promosing language?
23:47:09 <Pseudonym> That's one where promoses are first-class objects.
23:47:45 <humasect> interesting. i have only heard of conmoses
23:48:44 * Pseudonym programs with hylomoses, which use raspberries as brackets
23:49:46 <humasect> hehe
23:50:03 <humasect> you misspelt holymoses
