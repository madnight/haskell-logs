00:11:39 <ozy`> hmm, anyone know offhand if hoc can be built on leopard?
00:21:36 <Cthulhon> :t (+1)
00:21:37 <lambdabot> forall a. (Num a) => a -> a
00:21:49 <Cthulhon> [R]ayne
00:22:59 <[R]ayne> Ah
00:23:23 <Cthulhon> :t succ
00:23:24 <lambdabot> forall a. (Enum a) => a -> a
00:23:35 <Cthulhon> > succ 3
00:23:36 <lambdabot>   4
00:23:50 <Cthulhon> Again, [R]ayne.
01:26:09 <glguy> hmm, where do I get the "Program" library for coq?
01:33:45 <dbbddbdb> Is there a ctags/etags analog for making Haskell TAGS files?
01:34:02 <Feuerbach> dbbddbdb: yep, hasktags
01:34:11 <Feuerbach> it's included in ghc
01:35:53 <dbbddbdb> Right, thanks
01:41:30 <Feuerbach> How can I cast "ErrorT Identity a" to "ErrorT IO a"? (This seems to be possible, since I can cast "a" to "IO a" with "return".)
01:42:19 <Feuerbach> s/ErrorT/ErrorT e/
01:46:39 <dolio> @type ErrorT . return . runIdentity . runErrorT
01:46:40 <lambdabot> forall (m :: * -> *) e a. (Monad m) => ErrorT e Identity a -> ErrorT e m a
01:48:59 <Feuerbach> dolio: thanks
01:58:11 <hackage> Uploaded to hackage: WxGeneric 0.5.1
02:12:08 <retybok> I just watched the slides on the haskell platform. So when is the first release due?
02:13:03 <ivanm> retybok: let them all get home first! :p
02:13:35 <retybok> lol! was the talk just given? I had no idea, I just saw it on reddit
02:13:47 <retybok> But really, it's a great idea
02:13:54 <Jedai> retybok: Before Christmas ?
02:14:57 <Jedai> Seriouly though I would prefer they take some time to do it but create a rock-solid infrastructure for automated testing and building of the HP
02:15:23 <retybok> If I understand well they will include the best packages from hackage?
02:16:42 <aempirei> has anyone seen a rubiks cube solver in haskell yet
02:17:12 <aempirei> im interested in how anyone has defined the data type / search space
02:18:10 <aempirei> additionally im spending a lot of time in float/double to Int conversion
02:18:24 <ozy`> http://www.haskell.org/haskellwiki/Rubiks_Cube <== ?
02:18:25 <lambdabot> Title: Rubiks Cube - HaskellWiki
02:18:31 <aempirei> since tehre arent any Integral type trig functions
02:18:36 <aempirei> thanks ozy`
02:20:36 <Wild_Cat> @hoogle [String] -> IO ()
02:20:37 <lambdabot> Distribution.Make defaultMainArgs :: [String] -> IO ()
02:20:37 <lambdabot> Distribution.Simple defaultMainArgs :: [String] -> IO ()
02:20:37 <lambdabot> Distribution.Simple.Command noExtraFlags :: [String] -> IO ()
02:20:46 <aempirei> ive found that truncate is significantly faster than round
02:25:17 <dolio> round takes at least one more cycle, presumably.
02:25:41 <dolio> Unless it's built into the FPU, I guess.
02:32:41 <quicksilver> aempirei: I seem to recall someone solved the rubik's cube in the type system
02:32:45 <quicksilver> i.e. at compile time.
02:33:00 <Wild_Cat> I guess that's a stupid n00b problem, but: if I have a function that downloads a single file (return type IO ()) and want to download several files, it'd seem logical to mapM download [list of files], right? But if I do that, the compiler complains that my main function is of type IO [()]. How do I fix that?
02:33:48 <jethr0> Wild_Cat: sequence
02:33:48 <quicksilver> mapM_
02:34:00 <quicksilver> Wild_Cat: the _ discards the return value
02:34:08 <quicksilver> so it has tupe IO () instead of IO [()]
02:34:16 <Wild_Cat> quicksilver: brilliant. Cheers.
02:34:20 <jethr0> what quicksilver said
02:34:28 <quicksilver> could also use sequence_ ;)
02:34:44 <quicksilver> mapM (resp _) is just sequence (resp _) combined with plain old map
02:38:20 <Wild_Cat> great. Now my mass link downloader works. Next step: add filtering and a UI.
02:40:40 <Cale> Wild_Cat: wait, the compiler shouldn't actually complain that your main action has type IO [()], that's an acceptable type for main to have
02:40:41 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
02:41:01 <Wild_Cat> Cale: is it?
02:41:04 <Cale> yes :)
02:41:14 <Wild_Cat> ...Okay, in that case, I'll remove the explicit type declaration :p
02:41:24 <Wild_Cat> I thought main was supposed to be IO () and only IO ().
02:41:31 <Cale> main :: IO A  for any type A will work.
02:42:04 <Cale> It's also perhaps worth noting that although it's not as good a solution efficiency-wise, you could also just add  return ()  to the end of it.
02:42:12 <maltem> People, it's exciting to read news about ghc parallelization work. Wonder whether that will continue at that pace :)
02:42:41 <Cale> maltem: Well, it's what many of the researchers are geared on these days :)
02:43:05 <Wild_Cat> Cale: okay, thanks for the info.
02:43:55 <Cale> maltem: Specifically SMP multicore, since it seems like that will be upon us quickly, and it's easier to do automatic things with it than distributed computation.
02:44:34 <Cale> I'm excited about it too, despite not having a multiprocessor yet ;)
02:44:44 <maltem> Cale: Actually I hope that that work will make for a killer Bachelor thesis, FP not being very popular at my uni
02:45:35 <maltem> Cale: They're merely concerned about parallelization of imperative programs here
02:46:28 <Cale> Yeah, which is perhaps important for getting existing software to parallelise, but it seems like a backwards approach in general.
02:47:07 <maltem> Right, and that's why it's rather boring, seen for itself
02:50:09 <Cale> I wonder how well nested data parallelism would scale to the distributed setting... it seems like the main difference is that the overhead of moving things around is much higher, so you want to be extra certain about how things get chopped up.
02:55:11 <maltem> I think I'll have a look at the old Nepal paper again... things get more interesting now that ghc is going to integrate such stuff
02:57:49 <ivanm> maltem: "Nepal paper"?
02:58:12 <hackage> Uploaded to hackage: hmpfr 0.1.1
02:58:32 <maltem> ivanm: "Nepal - Nested data parallelism in Haskell"
02:58:59 <maltem> Not sure whether it's supposed to be an abbreviation :)
02:59:44 <ivanm> ahhhh
02:59:54 <ivanm> I guess it's a pseudo-abbreviation
03:00:13 * ivanm wonders if the 'l' is from parallelism or Haskell ... :p
03:01:02 <maltem> yeah :)
03:01:37 <maltem> ah, it's NEsted PArallel Language
03:01:55 <dolio> Ha! Neither!
03:02:29 <dolio> @yow!
03:02:29 <lambdabot> I am NOT a nut....
03:02:32 <ivanm> dolio: it's not my fault maltem gave me faulty data!
03:02:43 <ivanm> after all, there's the principle of GIGO! ;-)
03:02:55 <ivanm> lambdabot: so what are you then? ;-)
03:03:00 <dolio> @vera GIGO
03:03:02 <lambdabot> *** "gigo" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
03:03:02 <lambdabot> GIGO
03:03:02 <lambdabot>      Garbage In Garbage Out
03:03:02 <lambdabot>  
03:03:08 <dolio> Ah.
03:03:22 <dolio> That may be the shortest zippy fortune.
03:03:28 <ivanm> *nod*
03:15:21 <ivanm> *sigh* I have a function that returns an instance of class DynGraph, the results of which I pass through to a function that takes in an instance of DynGraph... why can't ghc be smart enough to just choose an instance for me :s
03:17:47 <maltem> just write a complexity analyzer for ghc!
03:17:55 <ivanm> heh
03:19:01 <maltem> that would be cool, actually. Transparently choose a data structure according to some performance heuristics :)
03:21:18 <ivanm> and I can't have the intermediary data structure be the same type as the outer one, unless I want to bring in more GHC extensions :s
03:24:10 <Beelsebob> quicksilver: you anywhere about?
03:31:57 <stevan> has anyone got the haskell array preprocessor (STPP) to work with recent versions of ghc?
03:39:25 <Eridius> am I correct in saying that @pl asks lambdabot to convert an expression into point-free style?
03:39:43 <Twey> You are
03:39:54 <Twey> @pl \x y -> x + y
03:39:54 <lambdabot> (+)
03:40:15 <Eridius> @pl \a -> 0:a ++ [0]
03:40:16 <lambdabot> (0 :) . (++ [0])
03:40:31 <Eridius> neat
03:46:15 <Eridius> @pl \x -> x * x
03:46:15 <lambdabot> join (*)
03:47:01 <Eridius> how do you ask lambdabot about what commands it accepts?
03:47:53 <maltem> @commands
03:47:53 <lambdabot> Unknown command, try @list
03:47:56 <maltem> @list
03:47:56 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:48:11 <maltem> voil√† :)
03:48:18 <Eridius> also, isn't join a monad function?
03:48:57 <maltem> oh yeah, it is. This is the (e ->) monad
03:49:12 <maltem> which lies in Control.Monad.Instances, iirc
03:50:13 <maltem> @type join
03:50:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:50:26 <maltem> In this case, that's, (e -> e -> a) -> (e -> a)
03:50:49 <Eridius> hm
03:51:14 <maltem> ((*) takes two arguments, but joiin (*) takes only one)
03:51:23 <Eridius> except it doesn't seem to be working for me
03:51:42 <Eridius> at least, in ghci. I may just be getting screwed up by ghci though
03:51:46 <plutonas> i would like to have a type, lets call it Type, that takes three possible arguments, argument1, argument2 and argument3, and then having a function f :: Type -> something to be able to call f argument2 for example and get the according result, how do i define Type?
03:51:49 <plutonas> got a bit confused
03:51:59 <maltem> Eridius: well did you import Control.Monad.Instances?
03:52:13 <Eridius> nope. that solves it
03:52:18 <Eridius> the error message was completely unhelpful
03:52:37 <maltem> Something with "no instance ...", I guess
03:53:05 <plutonas> did i explain it too complicated perhaps?
03:53:26 <maltem> plutonas: are the arguments types or values?
03:53:34 <Eridius> No instance for (Monad ((->) a))
03:53:49 <plutonas> maltem: i think types would do
03:53:54 <Eridius> now that I know what the problem is, I realize I should have been able to understand that
03:54:05 <plutonas> actually i want my function to act differently according to three cases
03:54:19 <maltem> Eridius: heh, one always thinks that, afterwards
03:54:23 <plutonas> but the argument are just to specify the cases, no values or whatsoever
03:54:27 <Eridius> :)
03:54:27 <plutonas> like case-names
03:55:33 <maltem> plutonas: Shall f be applicable to any Type bla, or only Type argument2?
03:56:47 <plutonas> maltem: all three arguments
03:56:51 <plutonas> i'll give an example
03:56:57 <maltem> that will be best
03:57:05 <plutonas> lets say i have an object and want to act different according to it's color
03:57:12 <plutonas> but it can only be white black or red
03:57:41 <plutonas> so i want to be able to define f something like
03:57:49 <maltem> plutonas: oh, then the arguments should be values, not types
03:58:11 <plutonas> f color | color == white = do this | color == black = do something else etc
03:58:20 <plutonas> hm
03:58:31 <maltem> data Color = White | Black | Red
03:58:48 <maltem> f White = ...; f Black = ....; f Red = ...
03:59:28 <maltem> That's data types in Haskell at their most basics :)
03:59:33 <plutonas> maltem: i see, it's similar to what i had
03:59:48 <plutonas> but on my assignment the prof has an example where he calls function f white
03:59:53 <plutonas> well i mean with lowercase
03:59:59 <plutonas> the real function is not similar to that
04:00:08 <plutonas> could that be possible?
04:00:25 <maltem> hm... you can do: white = White :)
04:00:37 <plutonas> hm, i see, well thanks a lot
04:00:43 <maltem> but the code could be anything
04:08:43 <Cale> plutonas: If you write f white = ...  then it matches the variable 'white' against any value at all.
04:09:12 <Cale> plutonas: (even if there's already a 'white' in the outer scope, this makes a new binding that shadows the other)
04:12:54 <Baughn> plutonas: If you turn on warnings, the compiler will tell you when this hapens
04:13:21 <jinjing> @bot
04:13:21 <lambdabot> :)
04:32:55 <Eridius> @pl \c -> zip3 [1..9] [10,20..90]
04:32:56 <lambdabot> const (zip3 [1..9] [10,20..90])
04:32:59 <Eridius> oops
04:33:01 <Eridius> @pl \c -> zip3 [1..9] [10,20..90] c
04:33:02 <lambdabot> zip3 [1..9] [10,20..90]
04:33:06 <Eridius> ok, that's what I expected it to say
04:33:19 <Eridius> @pl \a -> zip3 a [10,20..90] [100,200.900]
04:33:19 <lambdabot> flip (flip zip3 [10,20..90]) [100, 200 . 900]
04:33:22 <Eridius> oops
04:33:24 <Eridius> @pl \a -> zip3 a [10,20..90] [100,200,900]
04:33:25 <lambdabot> flip (flip zip3 [10,20..90]) [100, 200, 900]
04:33:29 <Eridius> ah yes, flip. That's what I forgot
04:44:25 <Eridius> @pl \a b -> tail (zip a b)
04:44:26 <lambdabot> (tail .) . zip
04:44:32 <Eridius> ahh
04:46:46 <subconscious> hi
04:47:04 <subconscious> I'm reading the paper Simply Easy!
04:48:00 <PatrickK> Hey I have a question regarding division of two expressions of type Int and getting back a fractional number for display.
04:48:19 <subconscious> oh I know how to do that
04:48:33 <Eridius> PatrickK: dividing integral values does integer division
04:48:34 <subconscious> fromInteger x / fromInteger y
04:48:57 <subconscious> or maybe it should be fromIntegral
04:49:12 <Eridius> either works
04:49:13 <SamB_XP> subconscious: the latter
04:49:26 <PatrickK> subconscious: I'll try it out. Thanks.
04:49:29 <SamB_XP> Eridius: he said Int, not Integer
04:49:33 <Eridius> oh wait, he said Int not Integer. So yeah, you need fromIntegral
04:50:00 <subconscious> ?quote fromIntegral
04:50:00 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
04:50:30 <Eridius> in any case, can it be assumed that haskell will always pick the Floating instance when it has a choice between a Floating or an Integral in evaluating a Num?
04:50:54 <PatrickK> It worked! Thanks all.
04:50:56 <SamB_XP> Eridius: the question makes no sense
04:51:22 <Beelsebob> I think I have an idea for the red/blue stack thread on haskell-cafe, but I'm trying to clarify exactly what the concept is
04:51:28 <Eridius> oh hrm, I thought / was overloaded for integer division too
04:51:36 <Beelsebob> when I pop an item, I should be left with the next item of the same colour at the top, right?
04:51:39 <Eridius> apparently that's `div`
04:51:43 <Eridius> so disregard my question
04:54:01 <SamB_XP> Eridius: it's not possible to overload in such an ad-hoc fashion in Haskell -- a method can only be provided by one class ...
04:54:19 <Eridius> SamB_XP: yeah, and I mistakenly thought (/) came from Num, not Fractional
04:54:43 <SamB_XP> the hierarchy isn't quite THAT bad
04:57:58 <Eridius> @list
04:57:58 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:58:20 <Eridius> @src ($!)
04:58:20 <lambdabot> f $! x = x `seq` f x
04:58:41 <Eridius> I've seen people use other prefixes for commands. What's the difference?
04:59:05 <dolio>  ?foo is the same as @foo
04:59:12 <dolio>  > is for evaluating expressions.
04:59:22 <ozy`> > "pizza"
04:59:23 <lambdabot>   "pizza"
04:59:35 <Eridius> ok, I was mostly wondering about ? vs @. Why 2 identifiers for the same thing?
04:59:38 <Eridius> s/identifiers/prefixes/
04:59:40 <dolio> And :t works like @type, roughly. (:k might work like @kind, I'm not sure).
05:00:21 <dolio> I don't know why there are two. There's another bot around here sometimes that uses ] and , (and a couple others) for evaluating expressions.
05:00:30 <dolio> !paste
05:00:34 <Eridius> huh
05:00:44 <dolio> hpaste responds to that when it's working (posts its url).
05:01:01 <subconscious> It's so weird, I thought I understood typechecking but I just cannot implement it
05:01:47 <opqdonut_> subconscious: sorry about that thing yesterday, I should've said "data T f = App (T f) (T f) | Lam (T f -> f (T f))"
05:02:05 <subconscious> opqdonut_: No worries, that also doesn't work though
05:03:07 <opqdonut_> oh?
05:03:47 <opqdonut_> another thought is that Lam probably has the wrong type, Lam Var T would work properly with monadic recursion
05:04:25 <opqdonut_> putting a pure function inside is what's the problem, the two immediate solutions are i) parametrising over a functor or monad ii) changing the Lam constructor
05:17:16 * Beelsebob ponders if this code misses the point of the Red-Blue Stack question... http://hpaste.org/10718
05:19:08 <dolio> It looks like you revised parts of it without compiling, unless I'm missing some context. :)
05:19:31 <dolio> I've ignored that thread. Is it an exciting problem?
05:21:06 <maltem> Hey, in the GHC 6.10 beta source tree there's still an ANNOUNCE file for ghc 6.4 around :)
05:22:05 <moenicke> i wonder what is wrong here: http://pastebin.com/d192901d7
05:22:20 <moenicke> isn't CString a Ptr CChar ?
05:23:32 <dolio> I doubt it. It's probably at least got a newtype wrapper (most of the CFoo things do).
05:24:00 <dolio> Also note that 'foo >>= return' is semantically equivalent to 'foo' except possibly in evil cases.
05:24:20 <jethr0> moenicke: i think you mean "newCString str >>= return"
05:24:38 <jethr0> + what dolio said
05:25:11 <Beelsebob> dolio: yeh, you're right
05:25:12 <jethr0> never mind, my haskell is really broken after excessive disuse ;)
05:25:19 <Beelsebob> needs a caps M in there
05:25:40 <Beelsebob> http://hpaste.org/10718#a1 <- this even
05:25:53 <Beelsebob> dolio: I'm not sure -- people have come up with clever solutions
05:26:00 <Beelsebob> I'm trying to figure out why that dumb solution doesnt work
05:26:46 <Beelsebob> I guess I'm introducing a few too many Emptys -- I should share that
05:27:07 <Beelsebob> http://hpaste.org/10718#a2 slightly better
05:27:08 <Eridius> how much traffic does haskell-cafe get?
05:27:14 <ozy`> lulz. my shell account has a ghc install, but it's version 6.4 and it won't run any of the stuff I feed it
05:27:20 <Beelsebob> Eridius: quite a bit
05:27:24 <Eridius> hrm
05:27:28 * Eridius has a habit of ignoring mailing lists
05:27:39 <Eridius> which means anything with moderate traffic just piles up messages until I end up deleting them all unread
05:27:40 <Beelsebob> I mostly ignore it, but every so often a topic catches my eye
05:27:56 <Beelsebob> and it's useful to have my own local archive that I can search fast
05:28:07 <Twey> Eridius: You look familiar
05:28:11 <dolio> I'm not sure what his pop example is getting at.
05:28:12 <Twey> Do I know you?
05:28:18 <dolio> Popping blue pops both a red and a blue?
05:28:20 <Eridius> Twey: I'm sorry I can't say the same for you. Maybe just a case of mistaken identity?
05:28:45 <Twey> No, memory failure on my part
05:28:52 <Twey> You asked about @pl earlier :)
05:28:55 <Eridius> ahh
05:28:56 <Beelsebob> dolio: the idea as far as I understand the question is that if you pop blue, it should remove the next blue item, and return a stack with the next blue item after that at the top
05:29:19 <Beelsebob> (and the oposite for red)
05:29:32 <dolio> And just delete the opposite colors in between?
05:29:43 <Beelsebob> that's what I understood from the question, yes
05:29:49 <dolio> Huh.
05:30:05 <Eridius> on a completely unrelated note, I'm really enjoying the Real World Haskell online book. It would have been nice if I'd run across this earlier instead of reading various tutorials about Monads ;)
05:30:19 <Beelsebob> personally I would have expected it to delete everything up to and including the next blue item
05:30:23 <Twey> It is handy, aye :)
05:30:25 <Eridius> I guess the problem is googling "haskell tutorial" doesn't bring up the book
05:30:36 <Beelsebob> rather than deleting everything up to but not including the next but one blue item
05:30:49 <Twey> If you ask here, you'll find plenty of people to recommend it :)
05:30:52 <dolio> Are you sure your pop is O(1)?
05:31:13 <Beelsebob> yes -- worst case is that it doesn't get the same colour, and it recurses once, immediately getting something of the same colour
05:31:19 <Beelsebob> so worst case is O(2)
05:33:29 <ozy`> Beelsebob: erm, O(2) -is- O(1) :p
05:34:11 <Beelsebob> exactly
05:34:23 <Eridius> anybody here use emacs for haskell?
05:34:59 <ozy`> Eridius: I get the impression everyone uses either that, or yi
05:34:59 * Eridius is a new emacs user, and is enjoying it's robust indentation support for haskell, but was wondering if there was a quick way to "indent" the = in an expression to match the same column as the previous one
05:35:09 <Eridius> yi?
05:35:14 <ozy`> yi.
05:35:27 <Eridius> huh, never heard of it before
05:35:28 <ozy`> http://www.haskell.org/haskellwiki/Yi
05:35:30 <lambdabot> Title: Yi - HaskellWiki
05:35:30 <dolio> Beelsebob: Well, my 5 minutes of thinking didn't yield any problems, but who knows? :)
05:35:32 <Eridius> yeah, just found that
05:35:48 <Eridius> hrm, experimental Cocoa frontend..
05:35:51 <ozy`> it's basically an emacs clone written in haskell
05:35:57 <maltem> Eridius: I wouldn't recommend yi right now unless you're willing to hack on it
05:36:00 <ozy`> and, I can't get the Cocoa part to work :p
05:36:05 <Eridius> maltem: oh?
05:36:08 <maltem> Eridius: which would be welcomed of course
05:36:18 <Eridius> heh
05:36:20 <Eridius> might be a neat project
05:36:45 <Eridius> hrm, yi in macports is obsolete
05:36:51 <Eridius> it even says so on that haskellwiki page
05:36:56 <Eridius> I wonder why it hasn't been updated?
05:37:10 <ozy`> I've given up on macports for... everything
05:37:14 <Eridius> oh?
05:37:16 <Eridius> that's disappointing to hear
05:37:35 * Eridius notes that he's a MacPorts committer, although he's pretty much been dormant for a while
05:37:36 <ozy`> and macports is certainly an immense disappointment
05:37:46 <Eridius> but if you have problems, I may be able to fix them. As long as you don't ask me to fix the dependency engine ;)
05:38:16 <ozy`> 80% of the ports I try to install either won't build, or won't run
05:38:40 <Eridius> well either 80% of what you try to install are esoteric ports that nobody's maintaining, or you've got a screwed-up system/macports install
05:39:01 <Eridius> in any case, if you want to give it another shot, I can probably help fix any broken ports
05:39:31 <Eridius> wtf? Why do I have darcs 1.0.9 installed in /usr/bin ?
05:40:40 <Eridius> oh, it's a symlink to /usr/local/bin/darcs
05:40:40 <Eridius> phew
05:40:43 <matthew-_> Eridius: because you meant to install bzr but did a major typo?
05:40:49 <Eridius> matthew-_: I actually use git
05:40:58 <Eridius> still, why do I have a manual install of darcs anyway? I thought I had it installed via MacPorts
05:41:53 <ozy`> IIRC that was one of the things I couldn't get working
05:41:59 <ozy`> through macports
05:42:00 <Beelsebob> dolio: thanks :)
05:42:11 <Eridius> ozy`: the only barrier to installing darcs I've ever been aware of is it requires ghc ;)
05:42:37 <Eridius> of course, ghc used to take something like 6 hours to compile on my computer of old. It takes about 45 minutes now, and I don't even have parallel compilation turned on in macports
05:42:38 <ozy`> yeah, I wound up installing it by hand
05:42:58 <ozy`> I, for one, am still using a computer of old
05:43:30 <Eridius> well, I'd like to encourage you to start using macports again, and feel free to bug me about any problems you have
05:46:29 <jimstutt> ?
05:46:36 <Eridius> !
05:49:13 <Eridius> huh. darcs get --partial is still downloading 1022 patches. Doesn't exactly sound "partial" to me
05:49:48 <matthew-_> they might be partial patches
05:50:01 <matthew-_> eg only lines removed...
05:50:20 <Eridius> pfft, I should just be able to download the current state of the tree with no history
05:50:27 <Eridius> hell, if this was git, I could probably get the full history in less time
05:50:49 <Eridius> of course, it's also going over http. git over http isn't particularly fast either, but if the the number of packs is low then it's alright
05:51:36 <subconscious> anyone know how to typecheck Pi quantification?
05:52:20 * subconscious can't get it right
05:53:00 <mattam> subconscious: You mean in a dependent type system?
05:53:04 <subconscious> yes
05:53:05 <Eridius> d'oh!
05:53:05 <Eridius> darcs: buildFdSets: file descriptor out of range
05:53:32 <Eridius> ugh, now the darcs get seems to be hanging
05:54:01 <Eridius> also, why does my computer think it's uploading at 1.35MB/s? That's not even possible on my connection
05:54:32 <mattam> subconscious: So the typing rules for Œ† x : A. B : Sort s or for Œª x : A. t : Œ† x : A. B ?
05:55:52 <subconscious> this one:  Œ† x : A. B : Sort s
05:56:11 <Eridius> oh hey, ignore my upload question. It's going over the LAN to my Apple TV
05:56:32 <subconscious> It seems to be the most complex rule
05:57:17 <plutonas> is there a function where i can map in pairs? for example first map first and second, then third and 4th, etc, and get a complete list at the end
05:57:45 <ozy`> maltem: who might I talk to about suggesting a seemingly esoteric feature for yi? (I ask you because you offered advice on it earlier)
05:57:55 <Baughn> plutonas: Sorry, nope
05:58:06 <plutonas> for example map add1-2 [1,2,3,4,5,6] -> [2,4,4,6,6,8]
05:58:13 <Baughn> Seems like such an obvious thing, but we don't even have splitBy..
05:58:19 <plutonas> so adding 1 to the first and 2 to the second, then 1 to the third and 2 to the 4th etc
05:58:32 <mattam> You need [Œì |- A : s‚ÇÅ], [Œì, x : A |- B : s‚ÇÇ] and (s‚ÇÅ, s‚ÇÇ, s) \in R where R declares the allowed products, right? (hoping the utf8 is right)
05:58:47 <Baughn> plutonas: You could apply splitAt repeatedly, but nothing premade
05:59:00 <plutonas> Baughn: hm, thanks
05:59:13 <plutonas> will see what i can do :)
05:59:19 <subconscious> ok I'll just try it
05:59:24 <maltem> ozy`: There's #yi, and there's the mailing list. You'll probably have more luck on the ml
05:59:40 <ozy`> ahhh
05:59:50 <mattam> The R relation is generaly functional (s‚ÇÅ and s‚ÇÇ determine s), but it depends on which sorts you have in your system of course.
06:00:16 <ozy`> maltem: thanks
06:00:20 <maltem> ozy`: http://groups.google.com/group/yi-devel
06:00:20 <mattam> Indeed that's
06:00:21 <lambdabot> Title: yi.devel | Google Groups
06:00:50 <mattam> Indeed the R relation determines largely in which system of the Œª-cube you are.
06:02:19 <subconscious> so my probelm is that I don't have a rule for ((Set,Var 0,_)
06:02:24 <Baughn> @pl \(a,b) -> a:f b
06:02:25 <lambdabot> uncurry ((. f) . (:))
06:02:28 <subconscious> and well I shouldn't, it would not make sense to
06:02:50 <mattam> subconscious: to typecheck though, you just have to typecheck the domain, ensure it gives you some sort s, then typecheck with the codomain and check it gives a sort as well and then check if they relate to something by R.
06:02:59 <subconscious> I don't know why I have inferred Var 0 somehow
06:03:44 <mattam> It's a type error if typechecking the codomain doesn't give you a sort.
06:04:37 <subconscious> I am trying to typecheck:  \(*) -> \(0) -> (0)  (de bruijn encoded)
06:04:48 <maltem> Hm... how should I go about installing a beta ghc? Is it ok if I just put it somewhere else than ghc 6.8, or will that do the package database any bad?
06:05:03 <mattam> So polymorphic identity.
06:05:03 <maltem> Or can it be run without installing?
06:05:04 <subconscious> so it tries to check [*] |- \(0) -> (0)
06:05:15 <mattam> Yes.
06:05:47 <mattam> Hmm, the second arrow is wrong, should be a lambda.
06:06:09 <mattam> Oh no, it's Œ† A, A -> A.
06:06:25 <subconscious> ah so the result should be:  [*] |- \(0) -> (0) : ‚àè(0) -> (0)
06:06:32 <mattam> The second 0 is wrong, it should be 1.
06:06:41 <subconscious> oh yes you are right
06:06:52 <Eridius> wtf, darcs keeps getting "file descriptor out of range" when it finishes pulling the patches for yi
06:07:27 <subconscious> hm
06:07:31 <subconscious> I have to put a (+1) somewhere :)
06:08:04 <subconscious> I don't know what's going wrong maybe I have handled the context wrong or something
06:08:14 <mattam> Yeah, -> should lift it's second argument.
06:10:22 <subconscious> ah! I see
06:10:33 <subconscious> if I do,
06:10:48 <subconscious> [x ; y ; z] |- foo
06:11:17 <subconscious> then you must check in a smaller context [ x ; y ] |- (fmap (+1) foo)
06:12:24 <Igloo> maltem: If you install it elsewhere then it won't conflict
06:12:28 <jimstutt> \q
06:12:55 <mattam> Hmm, nope, that would be (-1) if you remove something from the context (i.e. substitution decreases indices)
06:13:14 <subconscious> infact not quite fmap (+1) it should preserves local bindings but lift the ones taken out of scope
06:13:20 <mattam> But you can't always do that.
06:13:51 * Jan` thought she'd find Twey here
06:13:58 <mattam> The other way around is ok, it's weakening (vs. strengthening)
06:14:03 * Jan` doesn't know how she knew that...
06:14:15 <maltem> Igloo: thanks
06:14:32 <mattam> If foo is typed in x, y, z, it may not be typable in x, y.
06:15:01 * Jan` will be in her office
06:15:50 <subconscious> mm actually I am confused
06:15:58 * Eridius tries fetching yi one more time, this time building darcs with libcurl
06:15:59 <xian> excuse my newbie'ish question, but how do you declare the type of an inner function introduced by a let-expression?
06:16:21 <subconscious> perhaps I should rewrite this all without de bruijn representation
06:16:47 <Beelsebob> xian: let f :: Jam -> Ham; f x = Ham x in f (Jam 5)
06:17:04 <Botje> mmm. bacon.
06:17:05 <Beelsebob> (or replace the semicolon with a new line)
06:17:12 <Eridius> sweet, installing darcs using libcurl worked
06:17:45 <mattam> subconscious: I don't think that would help that much. De Bruijn fit dependent types very well.
06:18:42 <mattam> And you'd always have them underground with a localy-nameless representation.
06:19:03 <xian> Beelsebob: thanks. that's actually what i tried, but i had a syntax error in my type declaration.
06:22:09 <subconscious> so I can check: Lam Type (Lam Set (Var 0)) fine, but not (Lam Set (Lam (Var 0) (Var 0)))
06:22:36 <subconscious> (which should check, if you went further to \(x : Set)(y : x)(z : y) -> then it should not, of course)
06:24:20 <Eridius> I'm thoroughly confused. `cabal list cairo` shows a package named cairo, but `cabal install cairo` says there's no package named cairo
06:24:51 <mattam> I think your rule for checking Lam must be wrong.
06:24:51 <Eridius> oh wait, I bet it's listing cairo because that's locally installed
06:24:56 * Eridius just remembered, gtk2hs provides cairo, IIRC
06:55:56 <plutonas> how can i append recursively 2 elements on top of a list, something like f (x:xs) = (handle x):(handle-in-different-way (head xs)):(f (tail xs))?
06:56:41 <smtms> plutonas, you want to prepend two elements to a list (add them at the beginning)?
06:56:47 <plutonas> smtms: yes
06:57:02 <smtms> plutonas, do you know what 1:2:[3..10] gives you?
06:57:21 <plutonas> smtms: hm, nice
06:57:35 <plutonas> strange is that in the more complex code i have it doesn't seem to work, anyway thanks
07:19:00 <subconscious> how does this look?
07:19:01 <subconscious> gamma |- t, gamma;t |- m : U, gamma |- ‚àèt -> U
07:19:01 <subconscious> ----------------------------------------------
07:19:01 <subconscious>        gamma |- (\T -> x) : ‚àèt -> U
07:19:09 <Botje> plutonas: f (x:y:xs) = ...
07:19:25 <Botje> of course you need to pay attention you catch the [] and [x] case, then
07:19:32 <subconscious> the input is gamma and (\T -> x),  and it runs each rule on the top in order, then return ‚àèt -> U (if it didn't fail)
07:19:56 <plutonas> Botje: works now, had a typo... thanks
07:20:21 <subconscious> gamma is just a list of types, gamma !! 0 is the type of Var 0
07:20:39 <Eridius> hrm, cabal doesn't have a way to uninstall a package?
07:21:22 <subconscious> oops I have used upper and lowercase T for some reason, it should all be uppercase
07:27:44 <mattam> subconscious: seems alright.
07:31:15 <FunctorSalad> Eridius: you can hide or unregister it from ghc-pkg though
07:31:26 <FunctorSalad> (I don't think this will delete the files)
07:31:44 * Eridius ended up blowing away his entire set of cabal-installed user packages
07:32:15 <Eridius> whoa, gtk2hs fucks up when I have 2 versions of bytestring installed
07:32:23 <Eridius> I suppose I'd better unregister the old one
07:32:42 <mwotton> hey, have been out of things for a bit - what's the best tags setup for haskell + emacs?
07:33:27 <FunctorSalad> mwotton: wish I knew, but doing C-c C-l in a module that imports what you need and then doing C-c C-t while over a function will show its type
07:33:52 <FunctorSalad> in haskell-mode, of course
07:34:09 <FunctorSalad> C-c C-d will try to open the documentation
07:34:51 <ttt--> Eridius, i had the same problem a couple of days ago
07:35:43 <mwotton> FunctorSalad: the haddock docs?
07:36:03 <mwotton> the type is nice and all, but i want to be able to jump to the definition of something
07:36:27 <FunctorSalad> mwotton: yes... in the options you can set whether it looks on the web or <whereever> locally
07:36:50 <Eridius> wtf, gtk2hs fails to compile for a different reason now
07:36:58 * FunctorSalad thinks it would be cool if there was a single local haddock directory and cabal install installed to that
07:37:00 <Eridius>     Failed to load interface for `Data.ByteString':
07:37:00 <Eridius>       Perhaps you haven't installed the profiling libraries for package bytestring-0.9.1.2?
07:37:28 * FunctorSalad is scared of complex directory setups in /usr/local
07:37:31 <Eridius> how do I fix this?
07:38:32 <Eridius> hrm, I guess -p for cabal install
07:39:14 <EvilTerran> ... are you compiling a profiling version of gtk2hs?
07:39:29 <Eridius> I'm just compiling gtk2hs via macports
07:39:39 <Eridius> ...apparently that's a yes
07:42:19 <EvilTerran> weird
07:44:06 <matthew-_> and it's not my fault if people are abusable
07:44:18 <matthew-_> err, ww.
07:44:42 * matthew-_ slaps irssi around a bit
07:45:34 <fons> Hi all
07:45:48 <Eridius> hi
07:48:52 <mwotton> ah, hasktags + find . -name *.hs. that'll do.
07:58:16 <Eridius> wow, lots of warnings compiling yi
08:02:25 <dmwit> Huh, suddenly there's interest in yi.
08:08:25 <besiria> Control.Parallel.pseq guarantees that the first arg is evaluated first?
08:08:31 <roconnor> oregano is from the leaves?
08:08:42 <subconscious> yes to both
08:09:20 <roconnor> :)
08:09:32 <besiria> should i also add  rnf to pseq or this isn't necessary
08:10:01 <dmwit> It really depends on exactly what evaluation order you want.
08:12:00 * mwotton has spent the evening setting up git, emacs, ghc, cabal ana eshell, and may eventually actually write some code
08:12:29 * subconscious has spent the last two days rewriting code that doesn't work :/
08:12:34 <Baughn> besiria: To whn form, anyhow, yes
08:12:37 <dmwit> With that kind of power under your fingertips, you hardly even need to write code!
08:13:01 <Baughn> besiria: If you want more evaluation than just the least amount possible that isn't actually none, you'll need rnf or some such. using is handy too.
08:14:12 <FunctorSalad> subconscious: it happens, you learn something anyway :)
08:14:22 <besiria> i'm having troubles with  Data.Binary.decodeFile, so i saw somewhere in the mailing list about a solution
08:14:43 * FunctorSalad is haunted by bytestring version clash yet again :(
08:14:49 <besiria> and it had sth like rnf  `seq` hClose
08:15:41 <subconscious> Well I haven't learned why it doesn't work
08:17:14 <FunctorSalad> ok, ghc-pkg unregister bytestring-0.9.1.2 took my hxt down with it... *hopes cabal install hxt won't install the bytestring again*
08:23:35 <ttt--> im just trying out gtk2hs.. why does things like buttonNew have type IO Button and not just Button?
08:23:39 <ttt--> do*
08:24:01 <ttt--> If you are just building a window before displaying it
08:24:20 <Wild_Cat> ttt--: because you are *building* a window, not describing it.
08:24:30 <Wild_Cat> Window description is the realm of Glade.
08:25:09 <Olathe> @quote newspaper
08:25:09 <lambdabot> u221e says: I swear, reading Haskell source code is like trying to read a Chinese newspaper
08:25:47 <ttt--> I dont quite understand. What IO would buttonNew do?
08:26:47 <SamB_XP> ttt--: GTK isn't a purely functional GUI toolkit ;-P
08:29:03 <ttt--> Is it not possible to build up a description of a window like glade does, in haskell?
08:29:48 <ttt--> build it all up without IO, then display it
08:30:14 <Baughn> ttt--: It is, but not by just adding bindings
08:30:27 <Baughn> You'd have to write the code to do that, and it'd end up calling newButton anyhow
08:34:47 <dmwit> ttt--: newButton allocates memory, and returns a *pointer* to the button.  That is some IO right there.
08:35:16 <dmwit> (If you take a look at the docs, it's one of the first things they mention: they implement a reference semantics for their objects.)
08:44:39 <EvilTerran> you could build a description in pure haskell, then do all the actions in one go
08:51:13 <vininim> > foldl (*) 1 [9..6]
08:51:15 <lambdabot>   1
08:51:26 <vininim> heh
08:51:28 <EvilTerran> > [9..6]
08:51:29 <vininim> > foldl (*) 1 [6..9]
08:51:30 <lambdabot>   []
08:51:30 <lambdabot>   3024
08:51:32 <Baughn> > foldl' (*) [9,8..6]
08:51:32 <dmwit> > foldl (*) 1 [9,8..6]
08:51:34 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
08:51:34 <lambdabot>  Terminated
08:51:34 <lambdabot>        arising from a use...
08:51:53 <EvilTerran> > product [9,8..6]
08:51:54 <lambdabot>   3024
08:51:58 <Baughn> vininim: Oh, and you should pretty much never use foldl. foldl' is the right one
08:52:20 <vininim> well
08:52:33 <vininim> one less key to type
08:52:53 <vininim> specially when I`m using lambdabot as a calculator =P
08:55:19 <ttt--> EvilTerran, is there a lot to building a UI description?
08:56:03 <ttt--> i mean, is there a lot of code in GTK for it
08:58:26 <dmwit> ttt--: There's pretty much none.  One of their "TODO"s is to build a nice medium-level description language, I think.
08:58:30 <dmwit> ttt--: But see also Glade.
08:59:01 <EvilTerran> well, the simplest would be to have an ADT whose constructors mirrored the names of the functions for constructing widgets
08:59:04 <dmwit> Glade makes building GUIs pretty simple; it saves the description in a human-readable XML file (for some values of human-readable).
08:59:24 <EvilTerran> then it'd be a fairly simple fold over the ADT to assemble the appropriate IO action
08:59:33 <SamB_XP> dmwit: well, it's a lot better than compiled win32 dialog resources ;-P
08:59:34 <huma> do you guys work on http://en.wikibooks.org/wiki/Haskell?
08:59:36 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
08:59:49 <SamB_XP> dmwit: in addition to being resizable
09:00:26 <ttt--> Yes, that's what i was expecting to see in stead of IO actions
09:00:41 <ttt--> But if it is TODO, thats cool
09:07:08 <gwern> 'lo  all
09:07:38 <gwern> so does anyone know what exactly one calls those messages you sometimes see when doing a darcs pull, or where the docs are for that feature?
09:08:10 <dmwit> Which messages?
09:08:20 <dmwit> The patch names, long comments, date, ...?
09:08:43 <gwern> dmwit: ie, on pulling X11 you see stuff like 'don't forget to run autoconf!'
09:08:48 <dmwit> gwern: Also, your commit comment on xmonad-contrib was awesome.  "comments -> 80 characters per sjanssen"
09:08:57 <dmwit> gwern: That's just a patch name.
09:09:17 <dmwit> (Or maybe a long comment, depending on where it appears.)
09:09:40 <dmwit> gwern: If you darcs record without a -m, it will ask at the end: "Do you want to write a long comment?". ;-)
09:09:44 <gwern> dmwit: no, this is what I mean: http://hpaste.org/10720
09:09:58 <dmwit> Ah!
09:10:02 * gwern didn't see what was so awesome about that patch name, but I'm glad you liked it?
09:10:03 <dmwit> Yes, okay, that's different.
09:10:23 <dmwit> gwern: It's like, for each sjanssen, there's 80 characters of comment. =)
09:10:47 <Olathe> How many sjanssens are there ?
09:10:54 <dmwit> I know, I know, it was meant to be "because of sjanssen's suggestion, I dropped comments to 80 characters per line."
09:10:55 <SamB_XP> sjanssen: there must either be very few comments or very many of you
09:10:59 <dmwit> But I misread it at first. =)
09:11:19 <Olathe> There are probably lots of S. Janssens out there.
09:11:28 * dons waves from DEFUN Haskell developer tutorials
09:11:28 <Olathe> So, we're safe for a while.
09:12:10 <gwern> dmwit: ah. golfing sjannsen...
09:12:19 <dmwit> =D
09:12:34 <gwern> dmwit: so you don't know the darcs feature?
09:12:40 <dmwit> no
09:12:49 <dmwit> I thought it was maybe the "motd", but that seems to be empty in my X11 repo.
09:13:18 <SamB_XP> dmwit: wouldn't it be the motd of the repo you pull from that would be important?
09:13:29 <dmwit> Surely it would also pull the motd to my repo?
09:13:30 <newsham> the TH API seems confused at times about Q's.
09:13:31 <gwern> yeah, I looked at the motd
09:13:33 <dmwit> In case somebody pulled from me?
09:13:40 <SamB_XP> not surely
09:13:48 <dmwit> gwern: The docs do seem to indicate that it is the motd feature, though: http://darcs.net/manual/node5.html#SECTION00510080000000000000
09:13:49 <newsham> ie. sometimes its most convenient to get a Q [Dec] when the API calls for a [DecQ]
09:13:49 <lambdabot> Title: Configuring darcs
09:14:06 <gwern> hm, I see
09:14:10 <SamB_XP> newsham: sequence
09:14:12 <ddarius> :t sequence
09:14:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:14:14 <gwern> it must be imitating the unix /etc/motd
09:14:23 <gwern> not the first name I would've thought of
09:14:23 <newsham> whats the opposite of sequence?
09:14:25 <SamB_XP> er...
09:14:31 <SamB_XP> newsham: oh, oh
09:14:41 <SamB_XP> you're right!
09:15:07 <newsham> ie [d| ... |]  will return a Q [Dec],  but instanceD wants a [DecQ] arg
09:15:21 <SamB_XP> yeah, that's not nice is it
09:15:22 <newsham> you can always use InstanceD instead, but its not as perdy
09:15:23 <ddarius> :t map return <$> sequence
09:15:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[a]] -> [m [a]]
09:15:36 <EvilTerran> newsham, Data.Traversable.sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:15:47 <EvilTerran> is the closest we've got, i think
09:15:50 <newsham> *nod*
09:15:58 <SamB_XP> newsham: would you believe I was confused about your english?
09:16:07 <SamB_XP> I've convinced myself that that was the issue here ;-)
09:16:10 <EvilTerran> there'll be something arcane but formal in category-extras
09:16:17 <gwern> there always is
09:16:21 <newsham> sorry if any of the english wasnt clear :\
09:16:23 <EvilTerran> quite :)
09:16:33 <SamB_XP> newsham: well, it's english
09:16:37 <SamB_XP> what can you do?
09:17:10 <ddarius> :t \xs -> map return <$> sequence xs
09:17:11 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad f, Monad m) => [f a] -> f [m a]
09:17:17 <gwern> SamB_XP: use lojban
09:17:27 <SamB_XP> silly, I can't
09:17:30 <SamB_XP> I don't know it
09:17:53 <EvilTerran> newsham, InstanceD <$> [d|...|] ?
09:18:15 <SamB_XP> EvilTerran: oh, nice
09:18:23 <newsham> *nod* I'm using InstanceD already.. i was just complaining about the API having these weird consistency issues
09:18:33 <newsham> sometimes it wants to be a wigwam, sometimes it wants to be a teepee
09:18:38 <Saizan_> xs >>= instanceD . map return ?
09:18:40 <EvilTerran> well, InstanceD cxt type <$> [d| ... |]
09:18:49 <ddarius> newsham: The types of those things makes sense to me.
09:19:00 <fynn> Hey, is the presentation with the ICFP final results available anywhere?
09:19:11 <fynn> (besides that blocky Google Video that is)
09:19:12 <newsham> the presentation is on google video
09:19:19 <fynn> in before.
09:19:28 <SamB_XP> fynn: have you tried downloading the original ?
09:19:28 <matthew-_> newsham: yeah, but it's not really watchable
09:19:41 <fynn> SamB_XP: "original"?
09:19:48 <newsham> i watched it.  fwiw
09:20:04 <EvilTerran> i kinda see what you mean, newsham; seeing as it's easier to go [DecQ] -> Q[Dec] than the other way, it'd make more sense to ask for a Q[Dec] in some way
09:20:06 <EvilTerran> s
09:20:06 <fynn> you can't read the text on the screen, for one.
09:20:45 <fynn> in fact, are the results available in any textual format at all?
09:20:50 <gwern> SamB_XP: just run random text through a lojban syntax checker. you're guaranteed to be saying something meaninful if it checks!
09:20:55 <fynn> or the complete team roster, at least?
09:21:30 <Olathe> There are a lot of ways to say id.
09:22:28 <gwern> dcoutts: just the man I wanted to see
09:22:32 <dons> did people see http://www.reddit.com/r/programming/comments/73uyu/why_the_banks_collapsed_and_how_a_paper_on/
09:22:34 <lambdabot> Title: Why the banks collapsed, and how a paper on Haskell programming can help stop it ..., http://tinyurl.com/48hq8a
09:22:35 <dons> hehe
09:22:41 <Olathe> > foldr (\_ x -> x) [1..3]
09:22:42 <lambdabot>       Overlapping instances for Show ([a] -> [t])
09:22:42 <lambdabot>        arising from a use o...
09:22:48 <Olathe> > foldr1 (\_ x -> x) [1..3]
09:22:49 <dons> also, if anyone hasn't read this, they should: http://www.reddit.com/r/programming/comments/73smc/some_notes_on_the_future_of_haskell_and_fp/
09:22:49 <lambdabot>   3
09:22:51 <lambdabot> Title: Some notes on the future of Haskell and FP : programming, http://tinyurl.com/4fo7wn
09:22:52 <dons> the future of haskell.
09:22:55 <Olathe> > foldr1 (\x _ -> x) [1..3]
09:22:57 <lambdabot>   1
09:23:02 <gwern> dons: is it a retread of the financial contracts paper?
09:23:10 <gwern> 'we analyzed their contracts and the result was bottom!'
09:23:14 <dons> gwern: yes.
09:23:15 <Olathe> > let f x = foldr1 (\x _ -> x) $ repeat x in f 6
09:23:16 <lambdabot>   6
09:23:18 <gwern> :(
09:23:21 <Olathe> Neat.
09:23:35 <Olathe> > let f x = foldr1 (\_ x -> x) $ repeat x in f 6
09:23:37 <thetallguy> dons: we were discussion the whole transparency of contracts the other day
09:23:38 <Olathe> Even neater.
09:23:42 <gwern> hm, that reminds me, I need to add qualified imports to mueval
09:23:43 <vininim> is that haskell future from spj?
09:23:52 <lambdabot>   thread killed
09:23:53 <gwern> @seen dcoutts
09:23:54 <lambdabot> dcoutts is in #ghc, #haskell, #gentoo-haskell, #haskell-soc and #haskell-icfp. I don't know when dcoutts last spoke.
09:23:55 <gwern> @seen dcoutts_
09:23:55 <lambdabot> dcoutts_ is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I don't know when dcoutts_ last spoke.
09:23:58 <dons> gwern: he's in a tutorial.
09:24:02 <dons> sitting next to me.
09:24:02 <gwern> ah
09:24:10 <gwern> ...
09:24:12 <dons> bos is writing haskell for us.
09:24:16 <dons> at defun.
09:24:21 <dons> http://www.serpentine.com/blog/2008/09/27/slides-from-my-defun-2008-haskell-tutorial/
09:24:23 <lambdabot> Title: teideal glic deisbh√©alach ¬ª Blog Archive ¬ª Slides from my DEFUN 2008 Haskell  ..., http://tinyurl.com/426tbl
09:24:26 <newsham> ?faq could haskell save us from future economic collapse?
09:24:27 <lambdabot> The answer is: Yes! Haskell can do that.
09:24:38 <dons> see also http://twitter.com/galoisinc
09:24:38 <newsham> thats got to be one of the more far fetched blog themes i've read
09:24:39 <lambdabot> Title: Twitter / galoisinc
09:25:04 <gwern> @ask dcoutts so how does the 'send build reports to hackage' functionality I was reading about from the demo work? I looked through the source briefly but didn't see any .cabal/config option?
09:25:05 <lambdabot> Consider it noted.
09:25:42 <dons> gwern: it uploads it to the happs server
09:25:50 <dons> gwern: you enable it with --build-reports iirc
09:26:40 * gwern sniffs at the CLI option
09:27:43 <dcoutts> gwern: it's currently done using 'cabal report' but that's only a provisional ui we used for the demo
09:27:43 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:27:45 <thetallguy> so, how does one ensure that a datatype hides no information?
09:28:17 <dons> gwern: well, you could write a gtk interface
09:28:32 <gwern> that sounds like work
09:29:27 <dmwit> dcoutts: Did my gtk patch hit the mailing list?  I went and had a gander at the archives for the list, but didn't see it there.
09:29:30 <gwern> dcoutts: so what is planned non-provisionally?
09:29:40 <inimino> that "saving the world" post reminded me of E language
09:29:51 <newsham> dons: i noticed the shootout guys seem to be stuck on getting a debian pcre package.  is there none rolled yet?
09:30:32 <dcoutts> hia bos!
09:31:24 <thetallguy> newsham: I believe there is one: Package: libghc6-regex-base-dev
09:31:31 <dons> newsham: right, there is none, and not on ubuntu
09:31:33 <dons> thetallguy: that's the base.
09:31:37 <dons> we need libghc6-regex-pcre-dev
09:32:04 <newsham> thetallguy: http://alioth.debian.org/tracker/index.php?func=detail&aid=311132&group_id=30402&atid=411646
09:32:08 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311132 Haskell GHC : para ..., http://tinyurl.com/5x7htn
09:32:17 <newsham> errr.. yah, ubuntu is what i meant
09:32:25 <thetallguy> that link didn't work for m
09:32:48 <thetallguy> Hmm.. The description says that pcre is supported.  Let me look.
09:33:07 <newsham> oh.. hmm.. doesnt work for me in a new window either, but reload didnt seem to care, weird.
09:33:19 <newsham> ahh, reloaded in new window and it came up
09:33:24 <newsham> try again tallguy?
09:33:37 <dcoutts> dmwit: no idea sorry, I've not looked, I think you have to be subscribed
09:33:44 <mrd> what happened to tdfa?
09:33:47 <dons> thetallguy: see if you can find the regex-pcre package
09:33:53 <dmwit> dcoutts: fair enough, thanks
09:33:54 <dcoutts> gwern: not 100% sure yes, I've got some ideas
09:33:58 <dcoutts> yes/yet
09:36:31 <gwern> dcoutts: what's wrong with just blind http uploads?
09:37:02 <thetallguy> okay, I don't see that any of these provide Text.Regex.PCRE
09:37:32 <thetallguy> I'll see if it ppackages up.
09:39:04 <dcoutts> gwern: we'll have separate anonymous and detailed build reporting
09:40:09 * dons bets gwern wants anonymity and no reporting.
09:41:39 <gwern> why would I want that? as long as it respects $HTTP_PROXY I have no issue with detailed anonymous reports
09:42:07 <dcoutts> gwern: detail and anonymity are mutually exclusive
09:42:24 <dcoutts> gwern: a detailed report contains a build log
09:42:32 <dons> gwern: ok. good.
09:42:35 <dcoutts> ie lists paths, usernames etc
09:42:48 <newsham> mrd: I didnt try tdfa.
09:43:28 <gwern> hm. if someone is foolish enough to link usernames and true names, I suppose that could break pseudonymity
09:44:49 <mrd> it should be faster anyhow
09:51:05 <dons> bos is building "World of HaskellCraft" live at DEFUN :)
09:52:16 <Beelsebob> dons: I was actually considering writing an MMO in Haskell
09:52:25 <Beelsebob> but not in the traditional sense of what an MMO should be
09:52:42 * ddarius writes a single-player MMO.
09:52:49 <Beelsebob> haha
09:54:54 <thetallguy> dons: okay, i built.
09:54:58 <thetallguy> s/i/it
09:55:19 <Vq^> if by MM one can mean large amounts intelligent bots then it might not be so silly
09:55:31 <fynn> what's the purpose of the "Haskell Prime" thing?
09:55:47 <Beelsebob> fynn: to try and standardise on a standard that people might actually use
09:56:31 <fynn> Beelsebob: isn't Haskell already standardized? (aka the 98 report iirc)
09:56:40 <Beelsebob> fynn: yes, but no one uses Haskell 98
09:56:44 <skorpan> that's not a standard that anyone uses
09:56:49 <Beelsebob> we all use Glasgow Haskell instead
09:56:54 <dons> @seen kowey
09:56:54 <Beelsebob> (which is whatever ghc compiles)
09:56:54 <lambdabot> kowey is in #darcs. I last heard kowey speak 12m 18s ago.
09:57:11 <fynn> Beelsebob: so why not standardize around that implementation?
09:57:13 <thetallguy> dons: Package: libghc6-regex-pcre-builtin-dev ,   with source  deb http://deb.seereason.com/ubuntu hardy-seereason main
09:57:15 <lambdabot> Title: Index of /ubuntu
09:57:15 <cjs> Lots of things can break anonymity is very subtle ways.
09:57:32 <Beelsebob> fynn: because saying "Haskell is anything ghc compiles" means that no one will ever be able to write another haskell compiler
09:57:44 <Beelsebob> or any tool for haskel
09:57:46 <fynn> Python is standardized around CPython, and Ruby is standardized around MRI...
09:58:04 <fynn> and they both seem to work fairly well as communities.
09:58:08 <Beelsebob> yes, but they didn't just say "it's whatever this thing manages to interpret" , they created a new standard
09:58:12 <hackage> Uploaded to hackage: QuickCheck 2.1
09:58:12 <Beelsebob> this is what Haskell Prime is doing
09:58:23 <fynn> Beelsebob: actually, they haven't :)
09:58:25 <Beelsebob> it's incorporating a lot of the stuff that ghc compiles into a new standard
09:58:46 <fynn> MRI didn't even have specs of how it's working, let alone a standard.
09:59:01 <Beelsebob> fynn: look at it this way, at the moment there are *no* good debuggers, and *no* good refactorers for Haskell -- because the ones that exist can't keep up with ghc changing the language all the time
09:59:12 <Beelsebob> fynn: and you regard that as a *good* thing?
09:59:13 <dons> anyone have any thoughts on this wxHaskell build error http://hpaste.org/10722
09:59:13 <Beelsebob> pardon?
10:00:16 <fynn> Beelsebob: I'm not judging it any way, but pointing out that at least in the case of Ruby and Python, pseudo-"standardizing" around an implementation, far from harming the language, actually proved very beneficial.
10:00:48 <thetallguy> dons: url for source deb is here: http://deb.seereason.com/ubuntu/pool/main/h/haskell-regex-pcre-builtin/
10:00:50 <lambdabot> Title: Index of /ubuntu/pool/main/h/haskell-regex-pcre-builtin, http://tinyurl.com/3mfkmn
10:00:56 <Beelsebob> fynn: how would you propose we write (a) new compilers that do interesting things (b) debuggers (c) refactorers (d) ides (e) anything else then?
10:01:03 <Beelsebob> are we to be limited by only what ghc can do
10:01:03 <dons> thetallguy: oh!
10:01:04 <Beelsebob> ?
10:01:07 <fynn> in fact frequently the fact that Python was formed around a single implementation is cited as a reason for its success and popularization, compared to "standard-based" languages such as Lisp.
10:01:31 <kowey> dons: re http://hpaste.org/10722 - was that cabal install wx you just did?
10:01:34 <thetallguy> dons: David has gotten our cabal->debian tool working pretty well.
10:01:46 <dons> kowey: just runhaskell Setup build in the source rpeo.
10:01:52 <dons> thetallguy: ok. great.
10:01:54 <fynn> Beelsebob: arguably, the prolification of compilers (and platforms in general) isn't a Good Thing at all.
10:01:56 <subconscious> fynn: That just means the croud is wrong
10:02:08 <Beelsebob> fynn: it isn't?
10:02:19 <Beelsebob> you would like to be stuck with Windows ME and IE 6?
10:02:26 <fynn> Lisp had a standard and a ton of implementations. Smalltalk had the same. where are they now, compared to Python?
10:02:40 <Beelsebob> C has a ton of implementations
10:02:40 <subconscious> fynn: I use lisp more than I use python
10:02:42 <Beelsebob> so does C++
10:02:44 <Beelsebob> where are they?
10:02:44 <Cthulhon> ghc changes much faster than CPython.
10:03:18 <fynn> even funnier: Smalltalk had a ton of implementations, including several that beat the pants off MRI. Ruby has one implementation, MRI, that incidentally sucks hard.
10:03:27 <fynn> where is Smalltalk now, and where is Ruby...? :)
10:03:39 <Beelsebob> fyne: icc, mcc, msvcc, gcc, codewarrior etc...
10:03:45 <Beelsebob> there's *tons* of C compilers
10:03:50 <Beelsebob> and yet C is really popular
10:03:57 <Spark> it doesn't make any difference
10:04:00 <Beelsebob> exactly
10:04:03 <Cthulhon> Corellation != causation, etc.
10:04:18 <kowey> @seen shelarcy
10:04:18 <lambdabot> I haven't seen shelarcy.
10:04:19 <Beelsebob> my point is there isn't even corellation in this case
10:04:21 <fynn> Beelsebob: my point isn't that standard-based == failure. it's that implementation-based != failure.
10:04:23 <Beelsebob> let alone causation
10:04:36 <subconscious> fynn: How did you figure this out?
10:04:39 <Beelsebob> fynn: yes, but implementation-based is causing failure in Haskell at the moment
10:04:41 <fynn> so standardizing is not necessarily and automatically a good thing.
10:04:49 <Beelsebob> for example, there have been several attempts at debuggers
10:04:59 <inimino> fynn: unless you think that having a standard is a bad thing, I'm not sure what your point is
10:05:00 <Beelsebob> but they've all fallen into code rot because ghc moves so fast
10:05:06 <kowey> dons: the only thing I can think of off the top of my head
10:05:07 <Spark> languages with only one implementation usually are not that wide-spread though
10:05:12 <dons> Beelsebob: except for the one with ghc
10:05:21 <Spark> they are usually used for particular applications on particular platforms
10:05:23 <Spark> like php
10:05:29 <Spark> c is used for lots of things on lots of platforms
10:05:31 <Spark> so it has lots of compilers
10:05:34 <kowey> dons: is that wxcore has to be installed as root...
10:05:39 <Beelsebob> dons: true, not code rot -- but also not successful, it's like debugging C by staring at the assembler and hoping
10:05:50 <dons> kowey: oh. so while building, i need to build as root?
10:05:58 <fynn> Spark: Java had practically one implementation for a very long time.
10:06:05 <kowey> dons: well just the make install needs to be done as root
10:06:13 <Spark> fynn: what does "practically" mean
10:06:14 <subconscious> fynn: oh well, I can't follow your train of thought
10:06:18 <dons> ok. but i'm in the runhaskell Setup.hs build phase?
10:06:21 <fynn> or two, at most, with one of them not being actually necessary.
10:06:28 <kowey> dons: which is why I am confused :-)
10:06:38 <dons> it seems to be the linking phase.
10:06:40 <Spark> sun have produced several java implementations over the years
10:06:43 <Spark> for different platforms
10:06:45 <Cthulhon> I debug C by reading assembler with a debugger.
10:06:48 <Spark> and then they bought hotspot which was different
10:06:59 <Spark> there were also microsoft's blasphemous attempts, and well as hte ibm effort
10:07:06 <Spark> and then you have the free stuff like jikes
10:07:10 <Cthulhon> Well, more like reverse engineer...
10:07:16 <kowey> dons: once you've got the wxcore stuff running, the rest (the wx layer) is easy because it uses the Simple build method
10:07:24 <cjs> Actually, Ruby is a rather nasty little mess, when it comes to implementations.
10:07:40 <Spark> these cheap little languges often have bad implementations
10:07:44 <subconscious> hey say if you have
10:07:47 <Spark> i think lua has a lovely implementation though
10:07:55 <subconscious> Ctr (foo x) 34 (bar y)
10:07:57 <fynn> Spark: all those implementation from Sun still practically as a single implementation, just like CPython 1.5 and CPython 2.5 count as upgrades for a single implementation.
10:08:03 <fynn> *count as
10:08:09 <subconscious> what could you call the process of evaluting each of those members of the constuctor?
10:08:20 <subconscious> that is calculating foo x and bar y and rewriting in
10:08:41 <Cthulhon> The Java implementations for un are identical because Sun pumps out standards...
10:08:41 <Spark> fynn: there are also many java mobile platforms
10:08:44 <dons> kowey: right. so the challenge is getting wxcore to build.
10:08:51 <dons> looks like i need to investigate the linking.
10:08:56 <Cthulhon> *from Sun
10:08:58 <fynn> Beelsebob: this is really asking, rather than arguing, but what is the problem with GHC improving over time?  and are you saying that the purpose of standardization is to inhibit GHC from improving itself?
10:09:00 <dons> seems that i'm pretty close.
10:09:03 <inimino> subconscious: reduction?
10:09:26 <Beelsebob> fynn: there's no problem with ghc improving over time -- the problem is with there not being a standard that people use
10:09:35 <Spark> i think the only difference a standard makes is to allow you to easily write code that runs on many implementations
10:09:35 <Beelsebob> because if there's no standard, then what are you trying to debug?
10:09:37 <fynn> Cthulhon: yeah, my point is that Java is a pretty good example of a language that became popular despite having only one major implementation.
10:09:41 <Spark> it doesn't affect the development of the language much
10:09:49 <Cthulhon> With a Standard.
10:09:53 <Beelsebob> Spark: try writing a debugger for Haskell
10:09:54 <dons> Beelsebob: so we have an evolving standard
10:09:54 <kowey> dons: if you can get a hold of shelarcy and mads, they might be able to help more
10:09:59 <dons> that tracks the safe subset of ghc.
10:10:03 <dons> kowey: ok.
10:10:10 <Spark> Beelsebob: standards don't usually talk much about runtime details though, that's for the implementation
10:10:25 <Beelsebob> Spark: no, but they do fix things like what the language looks like
10:10:31 <Spark> it's much harder to debug msvc code with gdb than g++ code
10:10:35 <Beelsebob> so if your debugger works by annotating source code, you can actually parse it
10:11:03 <Beelsebob> or if your debugger requires compiling it with special symbols added, you can actually do the compilation yourself
10:11:03 <inimino> fynn: pointing out that successful languages have made mistakes is not an argument for making those same mistakes again
10:11:19 <Spark> standards don't usually talk about symbols though
10:11:20 <Beelsebob> dons: yep -- but from my experience of said evolving standard, trying to keep up with it to do things like debugging is night-on-impossible
10:11:22 <fynn> inimino: which mistakes have I pointed our above?
10:11:26 <Spark> at least the c standards don't
10:11:30 <inimino> (and it's not like Java is not well-specified)
10:11:36 <Spark> the java standards talk about the format of class files though
10:11:36 <dons> Beelsebob: let's just have one debugger tied to an implementation that is widely used.
10:11:38 <Beelsebob> Spark: no, they talk about syntax and semantics -- and given that you can write a compiler that inserts debugging symbols
10:11:48 <dons> so it has a hope of munging internal representations.
10:11:51 <Spark> but the symbols themselves won't be standard
10:11:57 <Spark> so anything that uses them will only work for a particular implementation
10:11:58 <Beelsebob> dons: I'd love that if ghc debugger was in any way a good debugger
10:11:59 <dons> if you want to do an external one, use ghc-api to do the parsing.
10:12:02 <subconscious> inimino: perfect! thank you
10:12:07 <dons> Beelsebob: i think ghci's debugger needs a ui.
10:12:09 <fynn> Beelsebob: write a better one.
10:12:14 <Beelsebob> fynn: I did
10:12:15 <dons> but hte foundations for everything we care about are there.
10:12:22 <Beelsebob> but ghc has changed lots
10:12:23 <subconscious> hehe
10:12:25 <Beelsebob> so it no longer works
10:12:40 <Beelsebob> dons: using ghc-api to parse it and add in annotations is nigh on impossible atm
10:12:43 <fynn> Beelsebob: so, update your debugger. how would this be different if it was bound by a standard?
10:12:44 <Beelsebob> because ghc-api changes so much
10:13:05 <Beelsebob> fynn: no, I'm not going to update it every time ghc changes -- I'm going to make it work on the standard
10:13:07 <Beelsebob> (which it does)
10:13:07 <fynn> the only way to solve your issue would be to prevent (forcibly) GHC developers from changing it.
10:13:10 <inimino> fynn: you seem to be arguing that standardization isn't worth the effort, because all it will do is enable other implementations, and those aren't needed because look at Java.
10:13:10 <kowey> dons: fwiw, i get the impression that the runhaskell Setup build is trying to run install-stuff which it shouldn't
10:13:20 <kowey> dons: based on the ghc-pkg update in that hpaste there
10:13:24 <Beelsebob> i.e. if you want the debugger to work, use standard Haskell
10:13:34 <Beelsebob> unfortunately, no one does, because Haskell 98 isn't a very useful standard
10:13:38 <inimino> fynn: if there's something else you are arguing for I missed it ;-)
10:13:41 <Beelsebob> with a useful standard though, people might actually use it
10:14:00 <newsham> I wrote some TH that lets me derive some classes for data types using a splice.  is there a way to somehow hook it into ghc so that I could just use "deriving Class" syntax?
10:14:18 <fynn> Beelsebob: I don't see how inhibiting GHC's progress is a good thing, even if it will ensure your debugger keeps working :)
10:14:28 <Beelsebob> fynn: no one is suggesting inhibbiting ghc's progress
10:14:33 <Beelsebob> only having a standard that people can actually use
10:14:39 <inimino> having a standard is a good thing not because it constrains GHC but because it documents the current state of the art
10:14:43 <Beelsebob> ghc can go and do research, and propose a new standard
10:14:51 <Beelsebob> and when that happens, *then* I'll update my debugger
10:14:54 <fynn> inimino: right, but look at what Beelsebob is arguing.
10:14:55 <cjs> So why does the changing standard make debugging an issue?
10:14:55 <matthew-_> but then it might stop being an academic language
10:14:57 <cjs> That won't work; GHC can change lots and still conform to '98.
10:14:58 <dons> kowey: ok.
10:15:03 <ddarius> newsham: No
10:15:03 <cjs> Your issue isn't the lack of a standard; it's that ghc changes its implementation on a regular basis. A better way of dealing with this might just be to update it for 6.8.3, and then say, "If you want the debugger to work, use 6.8.3."
10:15:07 <dons> Beelsebob: so how about using hpc somehow.
10:15:24 <Beelsebob> dons: hpc has the same issues as Hat... we use nhc to parse atm
10:15:31 <Beelsebob> but nhc doesn't support most of the extensions
10:15:39 <dons> well, hpc is integrated with ghc.
10:15:42 <Beelsebob> (most notably mptcs get in the way most of the time)
10:15:44 <dons> so it actually tracks the implementation.
10:15:54 <Beelsebob> oh hang on, hpc, I read hbc
10:16:02 * dons is happy to have only one debugger, and one coverage tool.
10:16:05 <Beelsebob> yeh, hpc doesn't track enough data, but I imagine you could base an implementation on it
10:16:09 <inimino> it's also worth having a standard to help people learn the language
10:16:22 <fynn> inimino: standards help people learn languages?!
10:16:37 <fynn> how many people learned Java by reading the formal standard?
10:16:38 <Deewiant> fynn: some people, yes
10:16:47 <inimino> well, I learned Haskell by reading H98
10:16:47 <subconscious> fynn: Yes
10:16:49 <fynn> or Python or Haskell or whatever.
10:16:49 <Deewiant> I've learned some things from it
10:16:49 <newsham> fynn: in as much as standards encourage stable course material
10:16:50 <dons> i suggest some nice practical textbook :)
10:16:54 <inimino> fynn: and that's how I learned Java
10:16:56 <dons> or come to a language tutorial.
10:16:56 <Beelsebob> fynn: how many people learn Java using Blue J though -- a seperate implementation of Jaa
10:17:02 * dons is in a haskell tutorial right now.
10:17:18 <subconscious> fynn: I like guessing what language constructs do, I prefer to have an unambiguous description -- this way I can actually know what my program does
10:17:20 <newsham> dons: soon you'll be writing code!
10:17:26 <fynn> Beelsebob: (you're saying you're not arguing for inhibiting GHC's progress, but in fact you are: "ghc can go and do research, and propose a new standard")
10:17:28 <inimino> practical texts are good too
10:17:30 <subconscious> fynn: I _don't_ like guessing* :)
10:17:32 <dons> newsham: i hope so!
10:17:38 <Beelsebob> fynn: how is that inhibbiting progress?
10:17:47 <Beelsebob> the ghc team will still be going and researching stuff
10:17:57 <Beelsebob> and when said stuff becomes stable, we'll get a nice shiny new language standard
10:18:01 <Beelsebob> that's exactly what's happening now
10:18:11 <fynn> Beelsebob: you're arguing that GHC would have to propose a new standard, and go through a ton of red tape and politics and what not, to change the implementation.
10:18:17 <Beelsebob> the ghc team did a crap load of research, and now things like mptcs are getting integrated into Haskell Prime
10:18:35 <fynn> that will, de-facto, slow down changes compared to how things are done now.
10:18:49 <inimino> actually implementation before standardization seems to work much better than the other way 'round
10:18:52 <Beelsebob> but... that *is* how things are done now fynn
10:18:59 <Beelsebob> we had one standard (H98)
10:19:02 <ddarius> fynn: He's not saying do things differently from how they are done now.  He is saying that this -is- how things are done now.
10:19:03 <Beelsebob> the ghc team did a lot of research
10:19:05 <inimino> I think we can all agree on that ;-)
10:19:09 <Beelsebob> now we're getting a new standard (Haskell')
10:19:11 <ddarius> The main problem is that Haskell 98 is 10 years old.
10:19:46 <dons> we're getting an evolving standard. one with a regular release cycle. it tracks what the state of research is, rather than trying to be an end-point.
10:20:03 <dons> regular release cycles, open source model, rather than a "this is it, done." standard.
10:20:19 <dons> since our community is still churning out new stuff and having debates.
10:20:20 <Beelsebob> it becomes a kind of "these things are vaguely stable and usable" guide
10:20:24 <inimino> that sounds good
10:20:28 <dons> not vaguely. actually stable.
10:20:33 <dons> like FFI.
10:20:34 <Beelsebob> e.g. GADTs are not in it, because they interact badly with classes etc
10:20:39 <dons> right. not even close.
10:20:49 <Beelsebob> but MPTCs are (just) because they're pretty stable
10:20:54 <dons> an actually stable set of closed debates we don't have to have again.
10:21:06 <fynn> Beelsebob: if anything, a popular implementation is generally much closer to practicality (and hence to actual stability) than an abstract standard.
10:21:07 <inimino> who determines what gets in it?
10:21:08 <subconscious> I don't know why they want to be back compatable though
10:21:22 <subconscious> is there anyone who actually likes the (-) operator and stuff like that?
10:21:25 <dons> inimino: its an open process. you submit things to the committee. to get on the committee you work on stuff
10:21:28 <Beelsebob> fynn: but GADTs for example are in glasgow Haskell
10:21:35 <Beelsebob> but not in the standard because they're *not* stable
10:21:53 <inimino> dons: so the committee is chosen by the current committee?
10:22:01 <ddarius> fynn: The only way an implementation could be more stable than a standard is if it never changed.
10:22:04 <subconscious> fynn: It's more practical to test things in a REPL or read an implementations source code than reading a reference manual?
10:22:35 <dons> inimino: by people who want to contribute getting a commit bit.
10:22:40 <Beelsebob> fynn: you seem to be under the mistaken belief that all of ghc's features are stable
10:22:41 <dons> inimino: like xmonad, or linux kernel.
10:22:49 <dons> if you do the work, and show competence, you get a commit bit.
10:22:53 <inimino> dons: ok, sounds good
10:22:58 <dons> yeah. we know open source works.
10:23:08 <inimino> yes
10:23:09 <dons> so let's do it to get the standard process going.
10:23:20 <dons> and it means regular release cycles, and constant improvement
10:23:29 <dons> rather than just some perfectly formed "finished" haskell.
10:23:33 <fynn> subconscious: regardless of theory, in practice more people learn languages by reading a textbook and toying with a major implementation. both of these are not facilitated by a standard. in fact, if there is a standard, and multiple implementations, both of these would be harmed.
10:23:34 <dons> haskell won't finish. until its dead.
10:23:35 <inimino> regular release cycles are good
10:23:37 <dons> and we don't want to kill it.
10:23:42 <ddarius> Other than significantly reducing the ambitions of Haskell', I don't see how this change of model will help.
10:23:57 <ddarius> the problems that are plaguing Haskell' that is.
10:23:57 <inimino> and, having all work done in the open is good
10:24:00 <dons> ddarius: the percent of hackage covered by the standard can be increased.
10:24:05 <dons> ddarius: regularly.
10:24:11 <Beelsebob> that would be nice actually
10:24:13 <dons> the current approach is an all-or-nothing one.
10:24:23 <fynn> Beelsebob: does it matter, really?  some languages have unstable or otherwise defective features; people just don't use them.
10:24:24 <Beelsebob> if Hackage had a "works within the standard" flag
10:24:25 <subconscious> fynn: That's what I meant about the crowd being wrong, Have you noticed how buggy .. all, software is today? I think toying around as if this is physics is misled and silly
10:24:28 <dons> now instead, the haskell-prime update can include an actual % of how much of hackage works agains the standard
10:24:33 <inimino> some other recent standards committees have made the mistake of throwing a completed spec over the fall to have it rejected by implementors
10:24:34 <sjanssen> dons: but the standard is now a moving target
10:24:36 <Beelsebob> fynn: that's the point -- people *do* use them in Haskell
10:24:44 <inimino> s/fall/wall
10:24:45 <Beelsebob> and it's nice know which ones are stable or unstable
10:24:49 <Beelsebob> to know which ones you want to use
10:24:49 <dons> sjanssen: that's right. it reflects what haskell actually is.
10:24:53 <dons> an open source project
10:25:05 <sjanssen> the nice thing about Haskell '98 is that we can definitively say "this compiler supports Haskell '98", or "this package only uses Haskell '98"
10:25:07 <dons> inimino: exactly.
10:25:07 <ddarius> dons: That's nice, but my impression was that Haskell' has stalled primarily do to the fundeps issue.
10:25:11 <fynn> Beelsebob: the community needs to better designate what's usable and what's not.
10:25:19 <dons> ddarius: right. so we do everything else.
10:25:33 <dons> when people work out whether fundeps or type families are best, we can close that ticket
10:25:33 <Beelsebob> fynn: yes -- and the community is doing that by calling the stable things "Haskell Prime"
10:25:34 <sjanssen> it would be nice to be able to say "this compiler supports Haskell 2009", and have "Haskell 2009" mean the same thing forever
10:25:38 <dons> but no need to stall on a single issue
10:25:42 <dons> let's just keep closing tickets
10:25:49 <dons> sjanssen: its exactly the xmonad release model, btw.
10:25:53 <ddarius> That doesn't seem like it accomplishes all that much as if we could just ignore fundeps Haskell' wouldn't have stalled, but we can't.
10:26:02 <dons> contributors get commit bits, we have a bunch of tickets -- mapping to research discussions
10:26:04 <sjanssen> dons: xmonad is software, Haskell is a specification
10:26:09 <dons> as conclusions are reached, dedicated people write up the result
10:26:18 <dons> and it gets integrated into the current standard by the core team
10:26:26 <dons> who puts out a release every ICFP.
10:26:26 <sjanssen> dons: and even xmonad makes releases that can be named
10:26:33 <fynn> subconscious: I don't disagree, but why do you think that standardization solves those issues?  a lot of bad, buggy software is written in standardized languages.
10:26:35 <dons> right. Haskell-2009
10:26:42 <dons> sjanssen: they'll be date tagged
10:26:53 <sjanssen> dons: oh, I missed this bit.  There will actually be a document produced each year?  That's better
10:26:57 <dons> sjanssen: yes.
10:27:04 <Beelsebob> fynn: exactly what is your argument *against* creating a standard anyway?
10:27:05 <dons> a document, and statistics on how well the standard covers hackage.
10:27:11 <subconscious> fynn: oh I don't think that, lots of people don't even read the standards when they do exist
10:27:12 <dons> so how it actually addresses "how haskell is used"
10:27:51 <subconscious> fynn: I imagine thought process like "The syntax is roughly like $language_ive_used_before so everything works in roughly the same way"
10:28:07 <inimino> fynn: standardization helps language and tool implementors, not so much language users (except indirectly)
10:28:10 <dons> so a) we have a tractable process. b) research discussions like GADTs or FDs don't block releases c) we have accounability against hackage d) we can hope that the changelog is incremental enough for hugs to track it
10:28:25 <dons> and most importantly, we make progress tracking real world haskell.
10:28:45 <fynn> inimino, Beelsebob: I'm not arguing against standardization. I'm arguing for standardization around a common implementation, which has proved successful for other open-source languages.
10:28:58 <fynn> i.e. standardizing around GHC.
10:29:08 <inimino> fynn: how is that effectively different from what is happening?
10:29:33 <dons> sjanssen: so its kind of the application of xmonad's project model to realworldhaskell's document preparation system
10:29:39 <dons> with coverage against hackage.
10:29:46 <fynn> inimino: I didn't say it was; but several people here are arguing against it :)
10:29:57 <Beelsebob> fynn: okay, and why are you arguing that it's going to be any better than a written standard?
10:30:23 <Beelsebob> just "it's been successful for Python and Ruby" is not a strong argument given that you can use "it's been successful for C and C++" for book standards
10:30:42 <fynn> Beelsebob: oh?  how did standardization help C++?
10:30:58 <Beelsebob> fynn: I didn't say it had helped -- I said it had been successful with a book standard
10:31:02 <dons> sjanssen: it reflects the fundamental nature of haskell: a transition platform from research to practice, that evolves
10:31:03 <fynn> afaik there isn't even a single implementation that fully implements the standard.
10:31:07 <sjanssen> dons: I think the moving target problem still applies, but significantly less because there will be a document produced each year
10:31:07 <dons> when the research stops, the language will stop.
10:31:09 <Beelsebob> there is actually fynn
10:31:12 <Beelsebob> gcc does now
10:31:23 <Beelsebob> and probably wouldn't if there wasn't a standard to work to
10:31:33 <dons> sjanssen: good to know.
10:31:57 <fynn> Beelsebob: well, maybe it changed in the last couple of years. but for the vast majority of the time C++ was becoming a popular language, there was no conformant implementation.
10:32:01 <Deewiant> Beelsebob: it doesn't support export templates
10:32:03 <Deewiant> or does it, now?
10:32:08 * subconscious starts to wonder if runError _really_ does what it says
10:32:09 <Deewiant> I thought only comeau did
10:32:13 <sjanssen> dons: it'd also be cool to have an especially cohesive version that one could purchase in book form :)
10:32:33 * sjanssen wants a version of the report to put on his bookshelf
10:32:35 <Beelsebob> Deewiant: I dunno, I just remember the big excitment at "g++ is the first fully compliant C++ compiler"
10:32:55 <dons> sjanssen: yes. the idea is every 5 years or so to do a 'major release'
10:32:57 <Beelsebob> fynn: so? what's your point?  That didn't mean that people weren't working towards having the standard implemented
10:32:58 <dons> i.e. print the standard.
10:33:06 <fynn> last I touched C++, ~7 years ago, there was no fully-compliant implementation.
10:33:07 <dons> and bump the major version
10:33:23 <Beelsebob> fynn: yep, it's wthin the last 3 years that g++ became compliant
10:33:33 <sjanssen> dons: have these details made it on the web yet?  All I've seen is a bit of blog buzz
10:33:33 <Deewiant> Beelsebob: it doesn't appear to, or at least I can't find any mention of it supporting it.
10:33:35 <fynn> and there were some substantial differences between implementations. C++ is _not_ a good example of standards helping a language gain mindshare and marketshare.
10:33:49 <dons> sjanssen: well, the discussions and planning only just took place
10:33:50 <inimino> fynn: in the cale of C++ the standard was an "average" over several not-quite-compatible sets of extensions
10:34:05 <dons> you'll see the full story and project site updated in the next few weeks
10:34:13 <Deewiant> Beelsebob: http://www.gnu.org/software/gcc/bugs.html#nonbugs_cxx says it doesn't.
10:34:14 <lambdabot> Title: GCC Bugs - GNU Project - Free Software Foundation (FSF)
10:34:19 <Beelsebob> Deewiant: interesting
10:34:21 <inimino> fynn: C++ is a good example of what *not* having an up-to-date standard can do
10:34:43 <fynn> inimino: most "standardized" languages are good examples of that problem.
10:34:52 <fynn> in fact, it's funny: standards tend to get outdated.
10:34:57 <dons> sjanssen: so i hope this time next year we'll be able to have a good chunk of haskell-2009 compliant xmonad.
10:35:01 <inimino> but the C++ implementation landscape is much richer obviously in the case of C++
10:35:11 <dons> sjanssen: and based on haskell-platform 2009
10:35:12 <Beelsebob> fynn: really? since when has C's standard been a problem?
10:35:21 <dons> so both library and language 'standard'
10:35:43 <Beelsebob> fynn: for a really good example of using the implementation as a standard, and it all going titsup, just look at HTML and CSS
10:35:59 <Beelsebob> everyone decided IE was the standard interpretter, and it made everything into a giant quagmire
10:36:11 <inimino> dons: that will be good for Haskell adoption
10:36:15 <dons> yep.
10:36:31 <dons> we're removing bottlenecks, stabilising things.
10:36:35 <dons> making the world a better place :)
10:36:40 <fynn> Beelsebob: hm?  HTML and CSS _had_ a standard.
10:36:42 <Beelsebob> fynn: my conclusion from this is that there's *no* correlation between standards documents and failure, and no correlation between implementation based standards and success
10:36:46 <inimino> one new Haskell user at a time?
10:36:53 <fynn> it's just that a major player (cough MS) didn't comply with it.
10:36:57 <Beelsebob> fynn: yes, and no one used it
10:37:00 <Beelsebob> and it all went titsup
10:37:10 <fynn> so, how is that a counter-argument?
10:37:15 <Beelsebob> instead everyone decided to use an implementation based standard
10:37:21 <Beelsebob> and it all went wrong
10:37:26 <fynn> that's like saying "sure, go ahead and write Haskell`, just make sure nobody uses it".
10:37:32 <inimino> well, technically, the HTML standard was never exactly usable
10:37:50 <inimino> but this discussion seems to be going far afield ;-)
10:37:52 <Beelsebob> fynn: no, it's like saying "if we all just carry on using <insert implementation here> instead of the actual standard, we'll be in trouble"
10:38:12 <Beelsebob> so lets make the standard usable, and then we might get some portability
10:38:26 <fynn> Beelsebob: to argue that, you'd have to provide an example of a standardized-by-implementation language that encountered difficulties.
10:38:34 <Beelsebob> fynn: html/css
10:38:41 <fynn> Beelsebob: HTML is a programming language?
10:38:41 <Beelsebob> it standardised on IE as an implementation
10:38:51 <Beelsebob> fynn: in a very limited non-turing complete way, yes
10:38:57 <fynn> no it didn't, and it's not a programming language.
10:39:07 <fynn> HTML is a markup language.
10:39:21 <inimino> the primary difficulty that HTML faced was due to not having any standard that accurately reflected the language as used in the real world
10:39:30 <Beelsebob> inimino: exactly
10:39:37 <Beelsebob> which is what Haskell Prime is trying to fix
10:39:54 <inimino> (and what HTML5 is fixing)
10:39:58 <Beelsebob> idd
10:40:06 <fynn> the problem with HTML is that a major implementation refused to adhere to the standard.
10:40:14 <fynn> that's completely different from the Haskell situation.
10:40:15 <inimino> both welcome advances, is far as I can see
10:40:23 <inimino> fynn: actually, that's not true
10:40:26 <Beelsebob> fynn: no, the major implementation *became* the standard
10:40:31 <fynn> the HTML standard (at least 4, probably 3 as well) is usable.
10:40:36 <inimino> though this is probably off-topic for #haskell
10:40:44 <younder> For a web browser implementors point of view the worst thing about HTML is no standard for error recovery
10:41:21 <fynn> Trident and HTML is basically like Haskell` and whatnot got approved as a standard, and then MS decided to ship a Haskell platform with every copy of windows, that's not compatible with Haskell`
10:41:21 <shepheb> anyone using viper to get the sweetness of Emacs' haskell-mode with a vim interface? does it work well?
10:41:22 <inimino> fynn: any actual browser implementation of HTML 4 as specified would not be viable in the marketplace
10:41:22 <Beelsebob> younder: from what I understand from sitting in #squirrelfish it's actually a case of "IE does this, so we have to break the standard here too"
10:41:24 <younder> Most of the "errors" reported to opera were in fact IE recovering from errors in a web page in a different way
10:42:08 <fynn> inimino: right, but that's a completely different situation than what we were discussing wrt Haskell...
10:42:38 <inimino> Beelsebob: that's right
10:42:39 <Beelsebob> fynn: there's a simple reason why saying "whatever ghc compiles is Haskell" is a bad plan -- there's *loads* of *really* unstable features in there
10:42:50 <fynn> and Beelsebob has still to provide an example of a troubled standardized-by-implementation language... :)
10:42:58 <inimino> fynn: I agree it is a different situation :-)
10:43:00 <fynn> Beelsebob: so mark them accordingly, and move on.
10:43:09 <Beelsebob> fynn: that's what Haskell Prime is *doing*
10:43:15 <Beelsebob> it's marking things as being stable
10:43:21 <inimino> fynn: what I'm not understanding is what course of action you are arguing for
10:43:48 <fynn> seriously, for a very long time everyone knew that continuations in Ruby weren't stable. so they were generally avoided. no casualties were reported.
10:43:52 <inimino> fynn: would you maintain the status quo?  abandon Haskell' and have no standard? or what?
10:44:20 <Beelsebob> inimino: he's saying just say "whatever ghc compiles is what we use"
10:44:28 <fynn> inimino: I'd standardize on GHC.
10:44:32 <Beelsebob> which gives no kind of measure of correctness
10:44:33 <fynn> right.
10:44:43 <Beelsebob> we can't ever say that ghc is correct, because we have nothing to measure it against
10:44:48 <sjanssen> fynn: but how can other implementations catch up to GHC?
10:44:57 <sjanssen> fynn: GHC changes every single day
10:45:01 <fynn> sjanssen: why is it important for that to happen?
10:45:01 <Beelsebob> it does... something... but who knows whether it's the *right* thing
10:45:05 <inimino> fynn: so you'd prefer to have no written standard, rather than having a standard that is based mostly on GHC, with input from all interested parties?
10:45:18 <dons> anyone can submit new tickets
10:45:25 <dons> and if they're accepted, ghc has to implement them
10:45:59 <inimino> s/based mostly on GHC/based on the current state of the art/
10:46:21 <Beelsebob> fynn: what if theres a contentious issue -- should we just blindly accept what simon & simon chose (not that i'd expect them to chose badly, but still)
10:46:32 <sjanssen> fynn: GHC (hopefully) isn't the last word in Haskell compiler technology.  There are lots of interesting techniques that GHC will never use, we should make it easier to write new compilers with new ideas
10:46:33 <Beelsebob> or should we as a community discuss which option we'd rather have
10:46:51 <inimino> fynn: it's important to have a vibrant community of competing compilers and tools
10:47:15 <ddarius> This argument is moot because nobody in the Haskell community wants to have it be a single-implementation language.
10:47:35 <fynn> standardized-by-implementation languages fare better than those based on abstract designed-by-committee languages.
10:47:56 <ddarius> Perl kicks Haskell's ass
10:47:59 <sjanssen> fynn: is that really true?  C, C++, Java all seem to have a standards process
10:48:00 <dons> yes. so now we have a standard that will be tied to what is actually used.
10:48:02 <vegai> fynn: haskell is both, though
10:48:14 <dons> finally, an accountable standard based on use.
10:48:21 <dons> rather than an abstract standard issued from on high.
10:48:42 <fynn> in fact in the discussion above were provided several examples of good languages with good implementations that failed miserably because of the designed-by-committee syndrome.
10:49:11 <fynn> sjanssen: the C++ wasn't fully implemented at all for the vast majority of the time C++ was taking over the market.
10:49:21 <fynn> *the C++ standard
10:49:25 <Beelsebob> fynn: exactly where? You've provided two examples of languages both of which have rather mediocre implementations
10:49:39 <Beelsebob> meanwhile, C has become extremely successful
10:49:45 <inimino> I think you'd be stretching to say that C++'s problems were caused by it having a standard as opposed to not having one
10:49:47 <Beelsebob> and got *many* good implementations
10:49:47 <fynn> in fact, we're not sure it is fully implemented right now. Java had a single implementation, by a single company.
10:49:58 <Beelsebob> fynn: what's Blue J then?
10:50:03 <inimino> Java also has a standard
10:50:03 <matthew-_> fynn: completely wrong
10:50:07 <newsham> java has had many implementations.
10:50:09 <Beelsebob> most people learn Java using BlueJ
10:50:13 <fynn> inimino: I'm arguing that fwiw, C++ might as well have no standard.
10:50:20 <fynn> newsham: but only one that really mattered.
10:50:20 <olsner> heh, nice quote from haskell-cafe: "Also... Who or what is an Oleg, and why do I keep hearing about it?"
10:50:20 <RayNbow> Beelsebob: BlueJ is evil :p
10:50:25 <Beelsebob> RayNbow: /agree
10:50:40 <newsham> fynn: thats a matter of perspective.
10:50:58 <Beelsebob> fynn: would C be where it is now without a strong standard?
10:51:03 <inimino> fynn: I think the gcc devs would argue that having a standard makes C++ a better language
10:51:04 <RayNbow> Beelsebob: the Delft University of Technology experimented with it for first year students last year... it failed :p
10:51:07 <fynn> newsham: is it?  what portion of the Java userbase ran a Java implementation that wasn't the official one from Sun?
10:51:10 <Beelsebob> if ICC wasn't able to implement the same language as gcc
10:51:20 <Beelsebob> RayNbow: UKC uses it on first year students
10:51:27 <newsham> fynn: I dont know.  can you answer your question?
10:51:31 <Beelsebob> it works rather well for teaching them an arse end of the universe language
10:51:41 <fynn> newsham: I can guess: maybe 1% :)
10:51:43 <sjanssen> fynn: which C++ compiler should be the standard implementation, then?
10:52:03 <newsham> fynn: well if we're going to make up statistics, surely i can make up one that backs my argument a lot better than 1% does.
10:52:09 <Beelsebob> fynn: which C compiler should be the standard implementation, and even... does it matter?
10:52:14 <newsham> i'll spare you the exercise
10:52:14 * RayNbow was a lab course assistent for the Java course last year...
10:52:27 <Beelsebob> RayNbow: ditto a few years back ... it was painful
10:52:29 <RayNbow> most of the exercises of the book can be completed by some copy/pasting
10:52:41 <inimino> well, I think most in the Haskell community would much prefer to use a language that has a standard
10:52:47 <Beelsebob> RayNbow: isn't that what Java is built for -- allowing you to copy/paste lots so you feel productive
10:52:48 <RayNbow> so students didn't really understand what they were doing
10:52:55 <inimino> I know I do
10:52:59 * shapr boings randomly
10:53:04 <newsham> i wonder how many users dalvik will have in a few years
10:53:05 * Beelsebob sits on shachaf_ 
10:53:09 <Beelsebob> shapr too
10:53:12 <Beelsebob> damn tab complete
10:53:17 <fynn> Beelsebob: I don't know enough about C's history to debate about it. but we gave several examples of: 1) languages standardized-by-committee that were harmed (sometimes fatally) by that.
10:53:22 <newsham> (btw, which part of "java" implementation are we arguing over?  the compiler portion or the VM portion?)
10:53:28 <Beelsebob> fynn: really? what examples?
10:53:32 <fynn> Lisp, Smalltalk
10:53:32 <younder> On Intel PC's Intel's C compiler is the one which other compilers are measured against (linx&windows)
10:53:42 <Beelsebob> fynn: I'd hardly call lisp dead -- it's used every day in emacs
10:53:46 <RayNbow> Beelsebob: I used to be fond of Java though... it was a rather nice language... (until Haskell crossed my path :p)
10:53:51 <Beelsebob> similarly smalltalk just evolved into Objective-C fynn
10:53:55 <fynn> Beelsebob: right, it's taking over the marketplace then ;)
10:53:58 <Beelsebob> which is used every day by Cocoa programmers
10:54:10 <Beelsebob> (and btw has a book standard)
10:54:12 <inimino> fynn: unless you have perfect knowledge, I'm not sure how you can argue what caused the decline of any one language
10:54:50 <fynn> inimino: there's no perfect proof for anything in this discussion. but one party has a lot of good examples to back itself up...
10:54:54 <Beelsebob> (it also just restandardised after apple's compiler implemented a load of cool new features)
10:55:06 <inimino> though I would agree that Lisp has been, um, hindered by poor standards processes
10:55:09 <Beelsebob> fynn: you have 2 bad examples
10:55:15 <Beelsebob> and are ignoring all counter examples
10:55:18 <Beelsebob> like for example C
10:55:22 <Beelsebob> and Objective-C
10:55:24 <Beelsebob> and Lisp
10:55:40 <inimino> I think the examples suggest that bad standards processes have bad results
10:55:43 <fynn> several good examples of languages dying because of standards, several good examples of languages where standards didn't matter (C++, Java), no example of a standardized-by-implementation language having any serious issue.
10:55:51 * shapr boings furiously
10:55:59 <Beelsebob> fynn: except for html
10:56:13 * Beelsebob sits on shapr and attempts to get his centre of gravity as low as possible
10:56:14 <fynn> Beelsebob: sorry, that's not a programming language, or a good example.
10:56:15 <inimino> it would be a mistake to ignore the differences between approaches to standardization though
10:56:16 <RayNbow> btw, is there any nice article/tutorial on making pointful definitions pointfree (manually)?
10:56:25 * RayNbow has a hard time doing it by hand :p
10:56:38 <newsham> i think haskell wiki has a points free article
10:56:55 <shapr> Beelsebob: WARGH!
10:56:58 <fynn> inimino: so the standardizing process either harms a language fatally (Lisp) or everyone just mostly ignore it so it doesn't hurt (C++) :)
10:57:01 <RayNbow> newsham: it does
10:57:08 <newsham> http://www.haskell.org/haskellwiki/Pointfree
10:57:19 <lambdabot> Title: Pointfree - HaskellWiki
10:57:46 <Beelsebob> fynn: you're just completely ignoring arguments now -- lisp is in *no* way dead
10:57:52 <inimino> fynn: that's not my perspective, but perhaps you should take it up on the mailing list ;-)
10:58:01 <Beelsebob> the standardisation process *didn't* harm it fatally
10:58:39 <fynn> Beelsebob: no, that's actually true. the most important thing happening in Lisp nowadays is SBCL, which is, de-facto, a move towards standardizing-by-implementation.
10:59:04 <subconscious> fynn: That's not true
10:59:10 <Beelsebob> fynn: uhhh, no SBCL is an implemenation of ANSI Common Lisp
10:59:12 <fynn> subconscious: how is it not?
10:59:15 <Beelsebob> it's an implementation of the book standard
10:59:24 <subconscious> fynn: This is not what's actually happening
10:59:32 <Beelsebob> first sentence on SBCL's web page... "Steel Bank Common Lisp (SBCL) is an open source (free software) compiler and runtime system for ANSI Common Lisp."
10:59:49 <subconscious> fynn: Do you actually use lisp?
11:00:00 <fynn> Beelsebob: the purpose of SBCL is to become a unifying standard. it's also CL comliant in the way several haskell implementations are Haskell 98 compliant.
11:00:10 <subconscious> fynn: That's not the purpose of SBCL
11:00:15 <Beelsebob> fynn: yet that's not what the SBCL devs say it is
11:00:24 <newsham> silly internet arguments
11:00:25 <Beelsebob> they say  "Steel Bank Common Lisp (SBCL) is an open source (free software) compiler and runtime system for ANSI Common Lisp."
11:00:29 <ddarius> newsham: Indeed.
11:00:34 <inimino> newsham: hear, hear
11:00:48 <younder> SBCL is a CL implementation. In addition LispWorks and Allegro CL are popular as is CLisp
11:00:56 <fynn> Beelsebob: right, a quote from the front project page is all the information relevant in this matter.
11:01:02 <subconscious> fynn: Do you actually use lisp?
11:01:09 <fynn> younder: right. it doesn't actually matter.
11:01:12 <inimino> sarcasm is uncalled for :-)
11:01:25 <Beelsebob> fynn: what the developers say it is is *very* important in discussing what the purpose of something is
11:01:41 <fynn> and saying "Lisp isn't dead because it's being used in Emacs" is, uhm... ;)
11:01:46 <inimino> heh
11:02:19 <subconscious> fynn: Do you have a reputable source or you just making this stuff up as you go?
11:02:26 <subconscious> fynn: .. and do you actually use lisp?
11:02:40 <fynn> subconscious: aren't you going to read me my rights first? :)
11:02:54 <subconscious> no I'm just going to assume nothing you say is true
11:03:03 <Beelsebob> which is probably a fair assumption
11:03:09 * fynn certainly hopes in ten years, we won't have to say "Haskell isn't dead because it's being used in Yi".
11:03:21 <Beelsebob> and even if it's not, it's a standard scientific approach
11:03:21 <inimino> hehe
11:03:31 <Beelsebob> "believe nothing until you can verify the result yourself"
11:07:08 <newsham> ?djinn ()
11:07:08 <lambdabot> f = ()
11:07:37 <Beelsebob> ?djinn (() -> ()) -> ()
11:07:38 <lambdabot> f a = a ()
11:07:42 <Beelsebob> interesting
11:07:53 <newsham> its weird that the () type has the same spelling as the () value
11:08:06 <Beelsebob> it is?
11:08:23 <newsham> I guess its not that weird
11:08:26 <newsham> Data Foo = Foo
11:08:30 <Twey> ?djinn (Integral a) => (Bool -> a) -> (a -> Bool) -> a
11:08:30 <lambdabot> Error: Class not found: Integral
11:08:43 <Twey> ?djinn (Bool -> Int) -> (Int -> Bool) -> Int
11:08:43 <lambdabot> Error: Undefined type Int
11:08:44 <newsham> s/Data/data
11:08:54 * Twey doesn't 100% understand ?djinn.
11:09:04 <Twey> newsham: It is pretty weird.
11:09:05 <matthew-_> about 42.5% of my data types have one constructor with the same name as the type
11:09:09 <newsham> twey: djinn gives you proofs
11:09:24 <newsham> ?djinn (a,b) -> (b,a)
11:09:24 <lambdabot> f (a, b) = (b, a)
11:09:36 <newsham> a proof that  P /\ Q -> Q /\ P
11:09:41 <subconscious> Twey, what's to not understand? It just produces values with a given type
11:09:44 <fynn> subconscious: (btw, to answer your question: yes, I did use Lisp several years ago. I left it because the implementation situation became hopeless. so there's one first-hand experience with how a standard can totally fsck things up :)
11:10:09 <newsham> ?djinn Either p q -> Either q p
11:10:09 <lambdabot> f a =
11:10:09 <lambdabot>     case a of
11:10:09 <lambdabot>     Left b -> Right b
11:10:09 <lambdabot>     Right c -> Left c
11:10:28 <fynn> there was a standard, there were several "fully compliant" implementations, and the language was dying.
11:10:30 <Twey> fynn: It is a rather ancient and incomplete standard.
11:10:31 <newsham> ?djinn Either p q -> (p -> r) -> (q -> r) -> r
11:10:31 <lambdabot> f a b c =
11:10:31 <lambdabot>     case a of
11:10:31 <lambdabot>     Left d -> b d
11:10:31 <lambdabot>     Right e -> c e
11:10:33 <Deewiant> indentation fail :-/
11:11:01 <dons> omg
11:11:02 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck-2.1
11:11:08 <lambdabot> Title: HackageDB: QuickCheck-2.1, http://tinyurl.com/3jsojc
11:11:15 <stepcut> is it possibly to implement a Functor instance for, newtype Func a = Func (a -> a)
11:11:51 <newsham> fmap x = Func id    ?
11:11:55 <fynn> Twey: agreed. still an example of why "standardized-by-committee" isn't necessarily a good thing, and sometimes it's unequivocally a bad thing.
11:12:06 <inimino> QC jumped from 1.1 to 2.1?
11:12:21 <Twey> Mm.
11:12:28 <matthew-_> dons: what's the omg for?
11:12:31 <newsham> fmap x = Func (\_ -> x)
11:12:35 <Twey> It would have been a good thing if they'd tacked some extra stuff on to make it useful.
11:12:44 <Twey> Haskell 98 has the same issue
11:12:55 <Deewiant> fmap f x = Func (f x)
11:12:58 <fynn> Twey: "the standard would have been good if it was good" :)
11:13:07 <Twey> Heh
11:13:08 <Deewiant> fmap f (Func x), of course
11:13:25 <Twey> If the standard had been written well, its effect on the language would have been positive :)
11:13:31 <lament> oleg's presentation was way over my head :(
11:13:31 <matthew-_> you see, this is why dates as versions are a good thing. people don't get upset by strange gaps in version numbers
11:13:39 <newsham> *sigh* cant think.  sorry
11:13:54 <r3m0t> matthew-_: wouldn't work for MySQL though
11:13:55 <sjanssen> dons: hell hath frozen over
11:14:34 <dons> 8 years later.
11:14:37 <dons> maybe 9 years.
11:14:47 <inimino> lament: was that on enumeration?
11:14:53 <lament> yes
11:14:58 <inimino> is it online?
11:15:08 <lament> source code at http://okmij.org/ftp/Haskell/Iteratee/
11:15:09 <lambdabot> Title: Index of /ftp/Haskell/Iteratee
11:16:12 <inimino> thanks
11:16:40 <newsham> stepcut:  (a -> a) -> (b -> b)  is kind of like a functional reference.
11:16:52 <inimino> I'm writing code that iterates over large input files, so I have a feeling this might be relevant
11:17:05 <newsham> if you have an invertible function (a -> b, b -> a) you can make an (a -> a) -> (b -> b)   pretty easily
11:17:17 <lament> inimino: if you treat them as streams, it might be
11:17:19 <stepcut> newsham: right
11:18:03 <mattam> stepcut: for functions you need exponential functors as defined in category-extras
11:18:14 <stepcut> mattam: ah
11:18:24 <inimino> in fact, BufferNaive looks a lot like what I tried before giving up and doing something much uglier...
11:18:34 <mattam> edwardk might have a post about that.
11:18:49 <mattam> At least they appear somewhere in his blog.
11:18:53 <subconscious> I think I implemented the Œª‚àè fragment of ECC correctly
11:18:54 <stepcut> mattam: ok, I look for that
11:19:14 <vegai> hmm, someone's trying to break in my ssh
11:19:16 * subconscious wishes there was a way to be sure :[
11:19:58 <mattam> It's basically what newsham said, you have xmap :: (a -> b) -> (b -> a) -> F a -> F b
11:20:43 <newsham> hmm.. there was a good blog post where the blogger was looking at functional references and made a weaker type of "arrow" and invertible functions
11:20:47 <vegai> oh, it's just freenode doing extra snoops. Weird
11:20:53 <mattam> subconscious: parse and check Coq terms :)
11:20:58 <newsham> kind of category theory approach to the fref thing.
11:20:59 <stepcut> mattam: ok
11:21:04 <newsham> looking for it now but havent found it yet
11:22:12 <subconscious> ah syntax
11:22:38 <mattam> :)
11:23:46 <subconscious> by the way is  there any other way one writes  k <- return$ eval gamma k  in do notation?
11:24:08 <dons> let k' = eval gamma k
11:24:10 <stepcut> my real challange is to implement: newtype Uni a = Uni ([a], [a] -> a); instance Applicative Uni where ...
11:25:26 <newsham> whats Uni represent?  you've got a list and a reduction function?
11:26:10 <stepcut> newsham: Uniplate
11:26:15 <mattam> Coq's pretty easy to parse actually, we use camlp4, which is more or less LL.
11:26:16 <stepcut> ?ty uniplate
11:26:18 <lambdabot> Not in scope: `uniplate'
11:26:56 <subconscious> ah I know what to test
11:26:57 <stepcut> newsham: I can implement most of the functions in uniplate using compos, but I have not yet figured out if I can implement uniplate and contexts via compos
11:27:05 <newsham> http://twan.home.fmf.nl/blog/haskell/References-Arrows-and-Categories.details
11:27:10 <newsham> thats the blog i was thinking of
11:27:18 <lambdabot> Title: References, Arrows and Categories - 21 thoughts, http://tinyurl.com/2v8het
11:27:38 <newsham> ahh, not familiar with uniplate
11:27:42 <subconscious> Metamathematical Investigations of a Calculus of Constructions
11:27:45 <dons> why don't we have any lock free data structure libraries?
11:27:50 <subconscious> there are some small examples
11:27:51 <shapr> Ed wrote some.
11:27:52 <stepcut> newsham: the idea is that for, uniplate (Neg x) = ([x], \e -> Neg e) ; uniplate (Sum x y) = ([x,y], \a b -> Sum a b)
11:27:56 <shapr> I agree though, we need more.
11:27:58 <dons> shapr: on hackage?
11:28:02 <shapr> Because you just can't pull off lock-free in C
11:28:05 <shapr> But you could with Haskell
11:28:10 <shapr> That would be a good place to really shine
11:28:28 <stepcut> newsham: the uniplate function returns the children of the top-most constructor, and a function which you can apply those children to in order to recreate the original value
11:28:34 <skorpan> what is the name for the datatypes with named parameters? just "records"?
11:28:34 <shapr> dons: http://lwn.net/Articles/292285/
11:28:41 <lambdabot> Title: lockless data structures? [LWN.net]
11:28:52 <dons> right.
11:29:59 <shapr> dons: I don't think Ed has anything lockless on hackage.
11:30:14 <dons> shapr: we're talking about edwardk?
11:30:18 <shapr> yup
11:30:22 <dons> ok. i'll bug him :)
11:30:25 <shapr> k
11:31:18 <newsham> stepcut: perhaps if you had   (\(a, b) -> Sum a b, \(Sum a b) -> (a,b))  as an invertible pair you could make an fmap ?
11:31:48 <newsham> actually i dont see how that helps since the tuples would have different shapes
11:32:35 <stepcut> newsham: one problem is that I don't have access to the constructor names, since I am trying to implement this generically
11:33:22 <newsham> wait..  how is that type working?    ([a,b], \a b -> Sum a b) and  ([a], \a -> Neg a)  ?
11:33:40 <stepcut> oops
11:33:59 <newsham> one is   a -> a -> Foo a, the other is a -> Foo a
11:34:00 <stepcut> ([a,b], \[a,b] -> Sum ab), ([a],\[a] -> Neg a)
11:34:02 <Jaak_> looks uniplatey
11:34:11 <stepcut> Jaak_: it is uniplate
11:34:37 <Jaak_> ah
11:34:38 <stepcut> uniplate :: Uniplate Œ± ‚áí Œ± ‚Üí ([Œ±], [Œ±] ‚Üí Œ±)
11:34:40 <ddarius> Yay, Uniplate just past the Mitchell Test.
11:34:50 <newsham> ok, so then how about:   mkSum [a,b] = Sum a b; unMkSum (Sum a b) = [a,b]
11:35:15 <newsham> then you can make an fmap out of   Uni [1,2,3] mkSum unMkSum
11:35:20 <Jaak_> reminds me to updare my code to new uniplate version
11:35:21 <newsham> no?
11:36:06 <Jaak_> update*
11:36:20 <newsham> err.. no, you would still need (a -> b) and (b -> a)  where fmap just takes (a -> b)
11:36:24 <stepcut> newsham: well, the idea is to do everything using the compos function -- which is the only function which knows the constructor names. The rest of the functions are supposed to be polymorphic
11:37:24 <newsham> I think you oculd make a class of Invertible functions and then make an InvFunctor class
11:37:34 <newsham> and maybe even InvApplicative ?
11:37:52 <newsham> but I'm thinking it wont work with normal Functor/Applicative
11:38:36 <stepcut> newsham: Yeah
11:39:28 <stepcut> newsham: I am going to see if I can get away with something like, newtype Uni a b = Uni ([a], [a] -> b), and then unify the a and b somewhere else
11:41:05 <Jaak_> oh yay! quickcheck 2.1 just hit hackage
11:43:27 <sheyll> hi
11:43:42 <sheyll> > extendSequence [6, 28, 496, 8128]
11:43:44 <lambdabot>   [6,28,496,8128,33550336,8589869056,137438691328,2305843008139952128,2658455...
11:44:11 <Olathe> > (...)
11:44:12 <lambdabot>   mueval: Prelude.read: no parse
11:44:21 <skorpan> @pl \x -> \y -> x * y + x + y
11:44:22 <lambdabot> join . ((+) .) . (flip =<< ((+) .) . (*))
11:45:04 <sheyll> does pl mean pointless?
11:45:08 <Olathe> > ([6,28,496,8128]...)
11:45:10 <lambdabot>   [6,28,496,8128,29642,71756,141188,244656,388878,580572,826456,1133248,15076...
11:45:25 <Olathe> How does extendSequence work ?
11:45:37 <sheyll> by calling http://www.research.att.com/~njas/sequences/Seis.html
11:45:38 <lambdabot> Title: Welcome to the On-Line Encyclopedia of Integer Sequences
11:45:41 <Olathe> > extendSequence [1]
11:45:44 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:45:49 <Olathe> > extendSequence []
11:45:51 <lambdabot>   []
11:46:02 <Olathe> > extendSequence [1125]
11:46:03 <lambdabot>   [1125,1155,1255,1344,1375,1485,1575,1600,1728,1875,1925,2240,2475,2625,2880...
11:46:12 <Olathe> > extendSequence [1125387487234234]
11:46:13 <lambdabot>   [1125387487234234]
11:46:50 <sheyll> > ([1, 6, 21, 71, 216]...)
11:46:52 <lambdabot>   [1,6,21,71,216,551,1206,2346,4171,6916,10851,16281,23546,33021,45116,60276,...
11:47:03 <Jaak_> > extendSequence [1,11,21,1211,1231]
11:47:05 <lambdabot>   [1,11,21,1211,1231,131221,132231,232221,134211,14131231,14231241,24132231,1...
11:47:58 <dons> sjanssen: do you think lambdabot has been more stable of late?
11:47:59 <dons> ?uptime
11:48:00 <lambdabot> uptime: 6d 12h 3m 2s, longest uptime: 1m 10d 23h 44m 29s
11:48:03 <dons> yes. definitely.
11:48:13 <dons> sjanssen: is that the "history logging disabled" patch?
11:48:15 <sheyll> jaak lol!!!111
11:48:44 <sheyll> thats the funniest series I have ever seen
11:48:55 <dons> heh kids.
11:49:05 <tristes_tigres> extendSequence [1, 1, 1, 1, 1,1]
11:49:12 <Cthulhon> > extendSequence [1,22,333,4444]
11:49:13 <tristes_tigres> @extendSequence [1, 1, 1, 1, 1,1]
11:49:14 <lambdabot>   [1,22,333,4444,55555,666666,7777777,88888888,999999999,10101010101010101010...
11:49:14 <lambdabot> Unknown command, try @list
11:49:38 <Olathe> > extendSequence $ map ord "omg"
11:49:39 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
11:49:50 <Olathe> > extendSequence $ map (fromIntegral.ord) "omg"
11:49:52 <lambdabot>   [111,109,103]
11:49:57 <tristes_tigres> @vixen sequence
11:49:57 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
11:50:08 <Olathe> > (map (fromIntegral.ord) "omg")...
11:50:10 <lambdabot>   mueval: Prelude.read: no parse
11:50:13 <Olathe> > ((map (fromIntegral.ord) "omg")...)
11:50:16 <lambdabot>  Terminated
11:50:17 <Olathe> > ((map (fromIntegral.ord) "omg")...)
11:50:19 <tristes_tigres> @vixen omg
11:50:19 <lambdabot>   [111,109,103,93,79,61,39,13,-17,-51,-89,-131,-177,-227,-281,-339,-401,-467,...
11:50:19 <lambdabot> I'm your huckleberry
11:50:32 <sheyll> @list
11:50:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:50:39 <Olathe> > map (chr.fromIntegral) ((map (fromIntegral.ord) "omg")...)
11:50:40 <lambdabot>   mueval: Prelude.read: no parse
11:50:41 <lambdabot>  mueval: "omg]O='\r*** Exception: Prelude.ch...
11:50:42 <Deewiant> ?ty (...)
11:50:44 <lambdabot> forall a. (Num a) => [a] -> [a]
11:50:56 <Olathe> > map (chr.flip mod 256.fromIntegral) ((map (fromIntegral.ord) "omg")...)
11:50:57 <lambdabot>   "omg]O='\r\239\205\167}O\GS\231\173o-\231\157O\253\167M\239\141'\189O\221g\...
11:51:07 <Olathe> > map (chr.flip mod 256.fromIntegral) ((map (fromIntegral.ord) "Hello")...)
11:51:08 <lambdabot>   "Helloz\141\163\178\171z\ACK1\216\211\245\f\225\&8\208c\166I\247V\a\166\202...
11:51:33 <Deewiant> > ([1 :+ 1]...)
11:51:35 <lambdabot>   [1.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 1.0,1.0 :+ 1...
11:51:53 <Olathe> > map (chr.flip mod (fromIntegral $ ord (maxBound :: Char)).fromIntegral) ((map (fromIntegral.ord) "Hello")...)
11:51:55 <lambdabot>   "Helloz\141\163\178\171z\ACK\1113904\1113559\1113042\1112308\1111307\110998...
11:52:07 <Olathe> > map (chr.flip mod (fromIntegral $ ord (maxBound :: Char) + 1).fromIntegral) ((map (fromIntegral.ord) "Hello")...)
11:52:08 <lambdabot>   "Helloz\141\163\178\171z\ACK\1113905\1113560\1113043\1112309\1111308\110998...
11:52:32 <Olathe> > ([1 :+ 2, 1 :+ 3]...)
11:52:33 <lambdabot>   [1.0 :+ 2.0,1.0 :+ 3.0,1.0 :+ 4.0,1.0 :+ 5.0,1.0 :+ 6.0,1.0 :+ 7.0,1.0 :+ 8...
11:52:46 <Olathe> > ([1 :+ 2, 1 :+ 3, 1 :+ 6]...)
11:52:47 <lambdabot>   [1.0 :+ 2.0,1.0 :+ 3.0,1.0 :+ 6.0,1.0 :+ 11.0,1.0 :+ 18.0,1.0 :+ 27.0,1.0 :...
11:52:55 <Deewiant> > [1 :+ 2, 1 :+ 3..]
11:52:56 <Olathe> > ([1 :+ 2, 2 :+ 3, 4 :+ 6]...)
11:52:57 <lambdabot>       No instance for (Enum (Complex t))
11:52:57 <lambdabot>        arising from the arithmetic s...
11:52:58 <lambdabot>   [1.0 :+ 2.0,2.0 :+ 3.0,4.0 :+ 6.0,7.0 :+ 11.0,11.0 :+ 18.0,16.0 :+ 27.0,22....
11:54:03 <Olathe> > ([1 :+ 1, 4 :+ 8, 9 :+ 27]...)
11:54:04 <lambdabot>   [1.0 :+ 1.0,4.0 :+ 8.0,9.0 :+ 27.0,16.0 :+ 58.0,25.0 :+ 101.0,36.0 :+ 156.0...
11:54:39 <Olathe> > ([1 :+ 1, 4 :+ 8, 9 :+ 27, 16 :+ 64]...)
11:54:40 <lambdabot>   [1.0 :+ 1.0,4.0 :+ 8.0,9.0 :+ 27.0,16.0 :+ 64.0,25.0 :+ 125.0,36.0 :+ 216.0...
12:06:10 <jethr0_> :t (:+)
12:06:11 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:07:20 <Olathe> > let (:=) a b = show a ++ " := " ++ show b in 5 := 6
12:07:21 <lambdabot>   Couldn't match expected type `Assoc t t1'
12:07:31 <Olathe> @type (:=)
12:07:33 <lambdabot> forall a b. a -> b -> Assoc a b
12:07:41 <Olathe> > 5 := 6
12:07:43 <lambdabot>       No instance for (Show (Assoc t t1))
12:07:43 <lambdabot>        arising from a use of `show'...
12:07:53 <Olathe> @src Assoc
12:07:53 <lambdabot> Source not found. You type like i drive.
12:12:27 <SyntaxNinja> @seen dons
12:12:28 <lambdabot> dons is in #haskell-icfp, #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 15m 14s ago.
12:14:19 <dons> SyntaxNinja: yo.
12:21:25 <subconscious> no I infer the wrong type for Succ  :(
12:49:20 <thetallguy> Anyone know if QuickCheck 2.1 is backwards compatible with 1.0?
13:06:09 <shapr> thetallguy: Sort of
13:09:38 <subconscious> ok I fixed the bug :)
13:10:11 <subconscious> ~2 days to write 100 lines of code :/
13:10:29 <subconscious> actually more than 100 but most of them are deleted
13:13:02 <newsham> are there any fixed-width signed integer types?  like Word32 but signed?
13:13:16 <Deewiant> Int32
13:13:17 <Igloo> Int32
13:13:26 <newsham> ty
13:14:18 <subconscious> you know how you usually intermix the WHNF and alpha equal tests to write an efficient Œ±Œ≤= test
13:14:42 <subconscious> in haskell (lazy) it is just as efficient to test if the normal forms are alpha equal?
13:15:04 <EvilTerran> wouldn't that test fail on infinite structures?
13:15:30 <subconscious> I haven't thought about them, they don't typecheck in my language anyway
13:17:47 <EvilTerran> or any non-terminating computation
13:18:08 <EvilTerran> if reduction to WHNF takes infinite time, it's not very efficient :P
13:18:27 <subconscious> yeah non terminating computations don't typecheck either ...
13:18:41 <EvilTerran> ah, you're implementing a total language?
13:18:45 <subconscious> yes
13:18:47 <EvilTerran> cool
13:44:55 <subconscious> :t schonfinkel
13:44:56 <lambdabot> Not in scope: `schonfinkel'
13:50:10 <ddarius> newsham: You do realize that such deriving code already exists?
13:52:19 <Olathe> :t Haskell
13:52:21 <lambdabot> Not in scope: data constructor `Haskell'
13:53:15 <Beelsebob> :t ghc
13:53:16 <lambdabot> Not in scope: `ghc'
13:53:30 <Beelsebob> @let ghc = undefined :: Haskell -> ImperativeCrap
13:53:31 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
13:53:34 <Beelsebob> :(
13:54:31 <Beelsebob> actually, that should be Haskell -> Either Error ImperativeCrap
13:56:32 <Olathe> String -> IO ()
13:57:10 <Beelsebob> String -> Bytestring if we're being pedantic i think
13:57:18 <Beelsebob> or well, IO () in fact
13:57:22 <Beelsebob> given that all haskell programs are
13:57:28 <Beelsebob> but what's inside the IO ()
13:58:12 <hackage> Uploaded to hackage: monadLib 3.4.5
13:58:12 <hackage> Uploaded to hackage: supercollider-midi 0.1.1
13:58:12 <hackage> Uploaded to hackage: QuickCheck 2.1.0.1
13:59:47 <dons> http://galois.com/~dons/videos.html
13:59:48 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Presentations (Video)
13:59:55 <dons> all the videos from the workshop!
14:00:07 <Beelsebob> awesome dons!
14:00:13 <erikc> hot, thx dons
14:00:14 <dons> malcolm did it all.
14:00:18 <erikc> thx malcolm
14:00:56 <Beelsebob> thanks malcolm indeed
14:01:25 <dons> can someone put the links on haskell.org's videos page/
14:01:36 <dons> maybe Videos/HW-2008/
14:11:19 <Cthulhon> http://paulspontifications.blogspot.com/2008/09/why-banks-collapsed-and-how-paper-on.html
14:11:20 <lambdabot> Title: Paul's Pontifications: Why the banks collapsed, and how a paper on Haskell progr ..., http://tinyurl.com/3p72v5
14:15:20 <ddarius> Which talk to watch first...
14:16:00 <dons> it's like christmas
14:18:36 <subconscious> It's a bit scary how category theory is appearing _everywhere_ recently
14:23:37 <_zenon_> subconscious, like..... on the back of milk-packages everywhere?
14:25:05 <_zenon_> subconscious, or more like on #haskell and haskell mailing list?
14:30:28 <dons> http://haskell.org/haskellwiki/Video_presentations/Haskell_Symposium_2008
14:30:31 <lambdabot> Title: Video presentations/Haskell Symposium 2008 - HaskellWiki, http://tinyurl.com/3ukddq
14:30:35 <subconscious> _zenon_: milk-packages
14:30:48 <Nafai> dons: Yay!
14:30:55 <subconscious> _zenon_: and most of the books I pick up
14:35:10 <subconscious> now I need to decide how to represent dat
14:35:11 <subconscious> data
14:35:17 <subconscious> how do you represent data?
14:35:23 <_zenon_> subconscious, :) hehe, maybe it's category theory that has been seeing you appearing everywhere lately!
14:35:31 <subconscious> lol
14:35:51 <_zenon_> subconscious, well it's a matter of perspective :)
14:35:58 <subconscious> I think I had assumed it was sort of silly and useless, but actually it is used in real mathematics
14:36:38 <dmwit> Cthulhon: That's the paper that got me interested in Haskell! =D
14:43:31 <_zenon_> subconscious, I particulary like the function language example using category theory. quite basic yes, but still elegant
14:43:48 <subconscious> Can you show me this?
14:44:12 <subconscious> I don't know about it
14:44:39 <_zenon_> subconscious, it's in the book "Basic Category Theory for Computer Scientists". I'll see if it find it somewhere here.. hang on
14:44:55 <subconscious> ah I should check the library for it
14:44:58 <adu> I started on the lcs stuff
14:45:02 <znutar_> that's a good book
14:45:12 <subconscious> what is lcs?
14:45:32 <adu> subconscious: LCS = longest common sublist algorithm
14:45:44 <adu> subconscious: its the algorithm behind GNU diff
14:45:53 <dons> ?users
14:45:53 <lambdabot> Maximum users seen in #haskell: 516, currently: 501 (97.1%), active: 13 (2.6%)
14:46:00 <BONUS_> hmm
14:46:05 <dons> 501 on a saturday afternoon eh?
14:46:08 <BONUS_> how would i go about creating a function that would work like
14:46:13 <dons> everyone quietly watching the videos?...
14:46:19 <BONUS_> f "a" = "a"
14:46:26 <BONUS_> f "foo" "bar" = "foobar"
14:46:32 <adu> but I ran into some problems with abstracting it out of darcs, so I think I'm just going to build my own diff from Data.List.LCS
14:46:32 <BONUS_> f "foo" "bar" "baz" = "foobarbaz"
14:46:40 <BONUS_> i imagine it would take some clever typeclassing
14:46:55 <matthew-_> BONUS_: aka concat
14:47:00 <BONUS_> yeah basically concat
14:47:03 <BONUS_> only like
14:47:08 <Olathe> BONUS_: http://okmij.org/ftp/Haskell/vararg-fn.lhs
14:47:17 <subconscious> BONUS_: It is done with typeclasses
14:47:26 <Olathe> BONUS_: You can use that with foldr1 (++) or something.
14:47:29 <BONUS_> ah, i'll read that paper
14:47:31 <BONUS_> yeah i know that
14:47:38 <BONUS_> i was interested in specifically what kind of typeclass magic
14:47:39 <matthew-_> @src concat
14:47:39 <lambdabot> concat = foldr (++) []
14:47:40 <BONUS_> i'd have to do
14:47:48 <_zenon_> subconscious, can't find a direct example of this on the web, but check your library for the book. It's from the MIT press
14:47:58 <Olathe> > printf "omg" "what ?"
14:48:00 <lambdabot>   Add a type signature
14:48:03 <Olathe> > printf "omg" "what ?" :: String
14:48:04 <lambdabot>   mueval: Prelude.read: no parse
14:48:05 <lambdabot>  mueval: "omg*** Exception: Printf.printf: f...
14:48:08 <Olathe> > (printf "omg" "what ?") :: String
14:48:10 <lambdabot>   mueval: Prelude.read: no parse
14:48:10 <lambdabot>  mueval: "omg*** Exception: Printf.printf: f...
14:48:11 <matthew-_> BONUS_: at a guess, you'd need at least a fundep
14:48:11 <BONUS_> i'm not implementing a concat, just toying with how to make it seem like a function can take n parameters
14:48:12 <Olathe> :(
14:48:23 <BONUS_> yeah, i imagine fundeps would be involved
14:48:39 <matthew-_> and two instances
14:48:47 <matthew-_> where one has the rhs as a function, which is the recursion
14:48:51 <matthew-_> and the other is the base case
14:48:53 <ToRA> > printf "omg%s" "what?" :: String
14:48:54 <lambdabot>   "omgwhat?"
14:49:10 <matthew-_> but that's just off the top of my head, and I've not read that paper, so it might not be right
14:49:11 <BONUS_> hm
14:49:27 <BONUS_> this look like a cool paper, i'll give it a read
14:49:45 <adu> BONUS_: you might do that with a typeclass "class Concat a where cat :: [a] -> ([a] -> Concat a)" then make an instance "instance Show ([a] -> Concat a) where show = ..."
14:50:13 <matthew-_> @type (printf "a%s" "b" :: (String -> String))
14:50:14 <lambdabot> String -> String
14:50:15 <BONUS_> yeah, i was thinking about something like that
14:50:18 <adu> BONUS_: but then again .. that might not work
14:50:50 <matthew-_> @type (printf "a%s" "b" :: (String -> a))
14:50:52 <lambdabot>     Could not deduce (PrintfType a) from the context ()
14:50:52 <lambdabot>       arising from a use of `printf' at <interactive>:1:1-16
14:50:52 <lambdabot>     Possible fix:
14:50:53 <adu> BONUS_: look at the implementation of printf
14:50:55 <BONUS_> i was thinking it wouldn't be hard to make a function that recursively returns functions that take strings, the hard part looks like making it an instance of Show
14:51:17 <matthew-_> BONUS_: you don't need to
14:51:25 <matthew-_> the rhs is either (String -> String) or String
14:51:30 <BONUS_> ah
14:51:34 <matthew-_> so obviously in the base case, you get it for free
14:51:50 <matthew-_> again, I'm still guessing... but I think this'd work ;)
14:52:04 <BONUS_> yeah hmm
14:52:53 <mwotton> hey, anyone using flymake and ghc here? Emacs just spins when i load it up, and i'm having trouble working out what could be wrong.
14:53:23 <subconscious> class Concat a where f :: (String -> String) -> a
14:53:23 <subconscious> instance Concat String where f s = s ""
14:53:23 <subconscious> instance Concat a => Concat (String -> a) where f s x = f (s . (x++)
14:53:35 <subconscious> )
14:54:31 <matthew-_> class Concat a where f :: String -> a; instance (Concat b) => Concat (String -> b) where f a = (++) a . f; instance Concat String where f a = a
14:54:42 <matthew-_> or some working variant thereof
14:55:24 <matthew-_> you might need a phantom param. Not sure.
14:55:36 <BONUS_> ahh
14:55:42 <BONUS_> hmm i'm beginning to see this yeah
14:56:09 <subconscious> hm that doesn't work matthew
14:56:21 <matthew-_> well, I didn't claim I'd tested it ;)
14:56:27 <TSC> mwotton: You can try setting debug-on-quit to t, then pressing C-g while it is spinning; it should give a backtrace
14:56:28 <subconscious> uh ok
14:56:33 <subconscious> not sure what it is pasted for
14:59:44 <dmwit> The following loads and works with -fglasgow-exts, at least: class Concat a where con :: String -> a; instance Concat String where con = id; instance Concat a => Concat (String -> a) where con s s' = con (s ++ s')
15:00:03 <subconscious> dmwit: DId you see the one I just wrote?
15:00:09 <dmwit> Very similar to that, yeah.
15:00:23 <dmwit> Same idea. =)
15:00:51 <mwotton> TSC: thanks, trying that. problem is that it locks up so hard that control-g doesn't seem to get through
15:01:40 <ArthurClemens> this is not so helpful compile error message: /usr/libexec/gcc/i686-apple-darwin8/4.0.1/ld: Undefined symbols: ___stginit_containerszm0zi1zi0zi1_DataziMap_
15:02:00 <ArthurClemens> while I have import Data.Map (Map)
15:02:01 <ArthurClemens> import qualified Data.Map as Map
15:02:23 <ArthurClemens> ghci runs ok, but ghc gives this error
15:03:01 <twanvl> You  need to compile with the --make flag, ghc --make Stuff.hs
15:03:44 <TSC> mwotton: You can also try C-z (to background it, if you're running in a console); when you foreground it, I think it will offer to crash+backtrace
15:03:45 <dmwit> I hear that future versions will have --make as a default flag, and require an explicit --no-make to turn it off.
15:04:03 <ArthurClemens> twanvl: thanks
15:08:26 <Baughn> Hm. What with List, why isn't Data.Set a monad?
15:08:53 <Baughn> I'm reading the haskell-cafe thread on containers, but so far they haven't explained /why/ it can't be one. :P
15:08:58 <subconscious> I think is a reason
15:08:58 <mwotton> TSC: yow, that's sorta nasty.   delete-directory("/")
15:09:07 <subconscious> maybe it's the Ord thing?
15:09:12 <ddarius> Baughn: There have been given two reasons why it isn't conceptually.
15:09:26 <mwotton> but i LIKE my root directory. i think i'd miss it..
15:09:28 <ddarius> (It is a categorical monad, but not the one captured by Haskell's Monad class)
15:09:46 <ddarius> As for why it isn't in Haskell, try it and find out.
15:10:36 <Baughn> Right, right..
15:10:38 <jethr0_> how about "join" as a union over sets and ">>=" as fmap? wouldn't that fulfill the monad rules?
15:10:58 <ddarius> jethr0_: (>>=) is only fmap for the identity monad.
15:11:09 <ddarius> jethr0_: The problem is Data.Set is not an instance of Functor
15:11:32 <subconscious> oh boring
15:11:41 <subconscious> it's not the kind of containers I was hopingaoe
15:12:04 <Baughn> @instances-importing Data.Set Functor
15:12:05 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:12:08 <ddarius> subconscious: You were hoping for Thorsten and co.'s work?
15:12:12 <subconscious> yeah :)
15:12:15 <jethr0_> hmm, could be an issue that fmap wouldn't uphold the set invariant or the set would contain potentially fewer elements after mapping over it
15:12:37 <Baughn> It certainly could, but I don't quite see where that is a problem either. ;)
15:12:49 <dibblego> @type fmap
15:12:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:12:54 <ddarius> jethr0_: The issue is fmap (+) leads to Set Int -> Set (Int -> Int) but Int -> Int doesn't have an ordering.
15:13:04 <dibblego> forall a b <--
15:13:32 <Baughn> Oh. So you can't instance Functor because the type you'd be mapping has a class restriction functor doesn't?
15:13:34 <jethr0_> ddarius: i wasn't aware that a set had to be ordered, but i guess equality on (Int -> Int) would also be an issue
15:13:38 <Baughn> Okay, that makes sense.
15:13:45 <dmwit> Baughn, jethr0_: The problem is the Ord constraint on the Set's contained type.  Haskell's Functor and Monad classes don't allow such restrictions; you must be able to construct monads (respectively, Functors) containing *any* type.
15:13:54 <dibblego> class OrdFunctor f where fmapOrd :: (Ord a, Ord b) => (a -> b) -> f a -> f b
15:14:12 <BONUS_> still aint
15:14:14 <dmwit> dibblego: Could work; you don't even need the (Ord a) constraint.
15:14:21 <BONUS_> hmm
15:14:26 <dmwit> (Set gives that for free.)
15:14:33 <dibblego> yes of course
15:14:47 <maltem> It wouldn't be a problem if there were a way to forbid any Set of a non-ordered type
15:15:17 <Baughn> dmwit: The only reason I have a problem with that is that Monad represents a common /syntax/, more than common semantics. The various monads are so very different..
15:15:17 <maltem> instead of having Ord constraints on every function on Sets
15:15:26 <ddarius> maltem: That's exactly what the Ord constraint does, that is -exactly- the problem.
15:15:46 <dmwit> Baughn: Oh, I'm not saying it's good.  I'm only explaining why Set isn't a Monad instance by default.
15:15:52 <Baughn> There's absolutely no question of swapping out one monad for another, ever. (Ignoring IOMonads and such)
15:16:19 <shrughes> most monads are actually very similar
15:16:26 <ddarius> Baughn: Every Monad still satisfies the interface that Monad represents.
15:16:28 <dmwit> Baughn: Well, that's not really true.
15:16:28 <ddarius> Set does not.
15:16:30 <jethr0_> @type Set
15:16:31 <lambdabot> Not in scope: data constructor `Set'
15:16:56 <Baughn> ddarius: And a useful interface it is. Just..
15:17:02 <dmwit> Baughn: There's plenty of monad transformer stacks that can be swapped out for more complicated stacks, for example.
15:17:17 <dmwit> That's sort of beside the point, though.
15:17:26 <Baughn> How come the type-checker can't propagate an Ord constraint out in the case where the monad type has a more restrictive type than Monad itself?
15:17:31 <maltem> ddarius: No that's not exactly what the Ord contraint does. You _can_ construct Sets of any type (empty, singleton)
15:18:09 <BONUS_> you just cant do anything useful with sets that dont contain Ord instances
15:19:07 <jethr0_> i can see that Ord is usefull for performance reasons, but don't you just need "Eq"? After all, a Set is an unordered collection of unique elements, is it not?
15:19:16 <dmwit> Baughn: err, what?  The problem is propogating the constraint *in*, not *out*.  i.e. you'd have to restrict (>>=) :: Ord b => Set a -> (a -> Set b) -> Set b.
15:19:26 <dmwit> But (>>=) is not restricted in that way.
15:19:27 <shrughes> jethr0_: Set is ordered
15:19:28 <BONUS_> yeah Ord is for performance
15:19:35 <jethr0_> k
15:19:46 <subconscious> Baughn: afaik typeclass dispatch sucks
15:19:46 <maltem> shrughes: Set is, but sets are not
15:19:56 <Baughn> dmwit: ..I'm not quite sure what I mean
15:20:11 <dmwit> jethr0_: Even with the Eq constraint, you're still stuck in writing instances for Functor, Monad. ;-)
15:20:18 <shrughes> you'd need the ability to parameterize a typeclass with respect to another typeclass
15:20:21 <subconscious> Baughn: It's really _inexpressive_, or I just don't know how to use it
15:20:28 <jethr0_> yes, i can see that
15:20:59 <Baughn> dmwit: But let's give it a try. Why can't monad be instanced for set in such a way that, although the instance requires Ord and Monad requires it doesn't, this only triggers an error if the typechecker find out that you are, in fact, at some point putting a non-Ord type in there?
15:21:17 <jethr0_> would you think extending the type system to allow restrictions on kinds would be possible? could dependent typing help or is that a completely different ballpark?
15:21:21 <shrughes> class Monad<T> m where { return :: T a => a -> m a ; ... } *evil laugh*
15:21:29 <dmwit> Baughn: You have to define (>>=) in your instance.
15:21:41 <dmwit> Baughn: That definition will necessarily put an (Ord b) constraint on (>>=).
15:21:49 <geezusfreeek> jethr0_, what kind of restrictions?
15:21:53 <dmwit> Baughn: But now, (>>=) doesn't match the type in the class's definition.
15:22:02 <dmwit> Baughn: ...so the compiler rejects it.
15:22:07 <ToRA> doesn't the restricted monads package do something to solve this?
15:22:21 <jethr0_> geezusfreeek: like propagating "Ord =>a" on a monad, as just being discussed
15:22:22 <maltem> Baughn: You wouldn't have fulfilled what the class declaration says
15:22:24 <Baughn> dmwit: Which would be fine in a dynamic language, and would crash at runtime if you ever tried using it in such a way that you put something non-Ord into the monad
15:22:27 <dmwit> Baughn: Have a look at sigfpe's blog, I think he actually tackles defining a new Monad class that deals with Set.
15:22:49 <geezusfreeek> jethr0_, so something that would be called "kind classes" or something?
15:22:54 <Baughn> dmwit: Now, of course haskell isn't dynamic, but I'd like to get the same effect - just erroring out at compile-time instead. :P
15:22:56 <dmwit> ?go sigfpe implicit prelude monad set
15:22:58 <jethr0_> i guess
15:23:02 <lambdabot> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
15:23:03 <lambdabot> Title: How to make Data.Set a monad
15:23:03 <ToRA> you want http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
15:23:04 <lambdabot> Title: HackageDB: rmonad-0.2
15:23:13 <ToRA> "A library for restricted monads based on associated datatypes. This allows datatypes such as Set to be made into monads. "
15:23:25 <r3m0t> what would be nice is several definitions of (>>=) and the compiler selects one which type-checks correctly
15:23:31 <jethr0_> cool, problem already "solved" ^_^
15:23:32 <Baughn> dmwit: I'll understand if that isn't possible. (Well, actually I won't, but I'll accept it until I understand the type theory involved.)
15:23:50 <maltem> Baughn: I'd like to move the Ord contraint from the functions to the constructors, and still have the type checker deduce it properly
15:24:03 <subconscious> Baughn: There are alternatives to haskell
15:24:04 <ddarius> The solution is not to try to finagle Set into Monad, the solution is to use a different class.
15:24:11 <r3m0t> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b /or/ (>>=) :: (MonadOrd m, Ord a, Ord b) => m a -> (a -> m b) -> m b
15:24:14 <subconscious> such as Chamelion
15:24:21 <subconscious> which has CHR for the typeclass dispatch
15:24:26 <Baughn> subconscious: I'm happy with haskell, though
15:24:29 <maltem> Baughn: I'm not sure how far you can take GADTs to do that, though
15:25:00 <subconscious> Baughn: It's really haskel with a different typeclass dispatch system
15:25:40 <Baughn> subconscious: Haskell isn't Haskell without #Haskell
15:26:10 <BMeph> Has anyone studied whether Bags can be monads? Or rather, Monads? ;)
15:27:10 <subconscious> what's the definitino of a bag
15:27:29 <BMeph> subconscious: You might know it better as a multi-set. :)
15:27:37 <subconscious> no I don't know what that is
15:27:42 <ddarius> subconscious: If a set is a function a -> Bool, a bag is a function a -> Natural
15:27:51 <ToRA> type Bag a = Set (Int, a)
15:27:58 <subconscious> ah I see
15:27:59 <ToRA> actually scrap that
15:28:12 <Baughn> type Bag a = Map a Int
15:28:17 <ToRA> yeah
15:28:22 <subconscious> why it is called a bag?
15:28:37 <ddarius> subconscious: Because it is like a bag of stuff.
15:28:44 <Baughn> Although, a list makes a perfectly fine bag
15:28:56 <ddarius> Baughn: A real life bag doesn't maintain ordering.
15:28:56 <ToRA> but a bag doesn't impose an order
15:29:06 <BONUS_> it still imposes Eq
15:29:16 <Baughn> A real-life bag doesn't guarantee ordering. There's a very good chance it maintains it. ;)
15:29:41 <BMeph> Baughn: How so? :)
15:29:53 <Baughn> Mm. Different kinds of ordering.. never mind
15:30:08 <Baughn> A Map "maintains ordering", in a sense, but not /your/ ordering, which I suppose is what you meant
15:30:31 <BMeph> Baughn: If I pull items out of a (real-life) bag, I usually get them out in a different order each time, even when I put them in in the same order each time. :)
15:31:15 <Baughn> BMeph: Not in haskell, you won't. In any case, my point was that it doesn't guarantee /anything/ about ordering, even the lack of it
15:31:20 <newsham> ddarius: some bags have pockets for that
15:33:12 <BMeph> newsham: You mean the way you can use sets-of-sets to impose an ordering? :)
15:33:22 <ushdf> any of you guys ever built a beowulf cluster
15:33:56 <Olathe> I built a Beowulf cluster of Beowulf novels.
15:34:04 <ushdf> wasn't one good enough?
15:34:11 <Olathe> Not if I wanted a cluster.
15:34:29 <bos> newsham: you've been doing some interesting hacking lately. where'd the TH stuff come from
15:34:32 <bos> er, ?
15:34:48 <subconscious> why are the things that are on here http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters on here?
15:34:50 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
15:35:08 <newsham> bos: i'm curious to see if i can embed something XDR compliant in haskell and I used Binary for other stuff recently.. just kinda part of that exploration
15:35:40 <dons> anyone know where to find thompson's `Software metrics and visualization for Haskell' paper?
15:35:48 <dons> a lot bunch of research done on good metrics.
15:35:49 <ushdf> actually, yes
15:36:23 <bos> newsham: i see
15:36:54 <ushdf> dons: http://web.archive.org/web/*/http://www.cs.kent.ac.uk/people/rpg/cr24/medina/
15:36:56 <lambdabot> Title: Internet Archive Wayback Machine, http://tinyurl.com/3gozft
15:37:09 <ushdf> good luck ;)
15:37:09 <dons> ooh..
15:37:12 <dons> heh
15:37:30 <dons> "The Medina library is a collection of functions and data structures written in Haskell to aid in the implementation of software metrics and visualisation techniques for programs written in Haskell.
15:37:39 <dons> so much work lost to the ages.
15:37:39 <subconscious> this is well documented http://www.lipl.googlepages.com/index.html
15:37:40 <lambdabot> Title: LIPL: a Little Idiotic Programming Language -- LIPL
15:37:43 <dons> all because ther ewas no hackage.
15:38:07 <ushdf> well, that was my best lead
15:38:08 <newsham> dont know if the xdr stuff will work out, but still should be fairly easy to do some non-xdr RPC stuff based on a few simple Binary decls
15:39:46 <bos> newsham: why do you want to do RPC over XDR?
15:40:12 <newsham> i dont have a specific need.  just curious.
15:40:28 <bos> it's a pretty old, hoary standard.
15:40:45 <newsham> sun rpc's standard's actually pretty clean.
15:40:52 <newsham> the DCE rpc stuff is a lot messier
15:41:14 <newsham> if anything, the complaint against sunrpc is its oversimplicity
15:41:25 <newsham> (i kinda like oversimplicity myself)
15:42:22 <bos> oh, there's nothing wrong with XDR. it's just really old.
15:42:33 <newsham> yah, me too :)
15:42:42 <bos> "hoary" simply means "showing signs of age".
15:42:54 <newsham> ahh, that word i didnt know
15:43:07 <subconscious> I'm not sure how to represent the data of a language
15:43:10 <subconscious> how should it be done?
15:43:36 <newsham> sub: depends on the language.
15:43:53 <newsham> there's the scheme in 48-hrs tutorial if that helps (that kind of language?)
15:44:03 <subconscious> something like haskell
15:44:37 <subconscious> say you have
15:44:39 <newsham> here's an example of how you could represent haskell code:  http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html#t%3ACon
15:44:41 <lambdabot> Title: Language.Haskell.TH, http://tinyurl.com/62bwzj
15:44:45 <subconscious> data Haskell = Var ... | Lam .. | etc
15:44:49 <newsham> oops, ignore the "#..." part
15:45:00 <subconscious> what do you add to handle every data and newtype ?
15:45:21 <newsham> | DataD Cxt Name [Name] [Con] [Name]
15:45:21 <newsham> | NewtypeD Cxt Name [Name] Con [Name]
15:45:37 <newsham> something like that
15:45:48 <newsham> except as a decl, which is a different type of node than an expression (variables, lambdas, etc)
15:45:50 <Saizan> subconscious: are you talking about runtime representation?
15:45:57 <subconscious> runtime and typecheck time
15:46:11 <subconscious> actually I only care about typechecking
15:46:19 <subconscious> for runtime I can probably compile away quite a lot
15:46:34 <newsham> for runtime you can convert your data types into lambdas
15:47:46 <newsham> http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/03-JansenKoopmanPlasmeijer-EfficientInterpretation.pdf
15:47:53 <lambdabot> Title: Efficient Interpretation by Transforming Data Types and Patterns to Functions, http://tinyurl.com/2drus8
15:48:28 <BMeph> So, has anyone mentioned an interest in writing an Inform (interactive-ficton) interpreter or compiler in Haskell? :)
15:49:32 <subconscious> newsham: how odd
15:49:51 <subconscious> newsham: it says that method is 30 to 800% slower than heliums way
15:49:51 <dino-> BMeph: That's popped into my head a couple of times.
15:50:04 <subconscious> newsham: I wwonder where they get the 'efficient' bit from
15:50:08 <jethr0_> wasn't there a project to do haskell in haskell as a google summer of code project? I know vincenz took a shot at implementing hindley-miller typechecking as an exercise in haskell
15:50:16 <dino-> Pretty sure I'm not up to writing compilers yet, though.
15:50:20 <newsham> subc: "if you have to call it efficient...."
15:50:43 <dino-> BMeph: Another thing I've wondered is: skip Inform altogether and build a new DSL for IF games. Have that compile to the Z-Machine bytecodes.
15:51:07 <BMeph> dino: Why not both? ;)
15:51:10 <dino-> I kind of found Inform to be.. ok I guess. Kind of "hoary"
15:51:48 <newsham> levenshtein "hoary" "horay"
15:51:49 <dino-> Sure, both. If you're compiling anything to those Z bytecodes, you've got a lot of the effort done.
15:52:13 <BMeph> dino-: I like the idea that Inform 7 is trying to use; NLP as a writing/programming tool. :)
15:52:35 <dino-> BMeph: It's a neat idea, I haven't used it though.
15:52:56 <dino-> There seemed to at least be a lot of problems with getting set up without their special graphical environment.
15:53:00 <BMeph> dino-: Me either - except, of course, by enjoying the results... :)
15:53:04 <dino-> at least initially I mean
15:53:15 <jethr0_> not quite what i remembered, but half way there: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.470 (Typing haskell in haskell)
15:53:16 <lambdabot> Title: Typing Haskell in Haskell - CiteSeerX
15:53:32 <subconscious> jethr0_: There's some subsets of haskell around
15:53:44 <subconscious> jethr0_: basically just like small lazy functional langs
15:54:00 <dino-> BMeph: Also, I seemed to see a lot of strife by people on usenet trying to do things with the I7 that should be easy for most PLs. I can't think of an example offhand though.
15:54:25 <jethr0_> i thought i had read about a project like pypy for haskell (i.e. a fully fledged haskell implementation in haskell). but maybe i'm thinking of yhc or jhc which go into different directions
15:54:47 <subconscious> jethr0_: does GHC not fit that criteria?
15:55:06 <Saizan> jethr0_: maybe hhi?
15:55:19 <dino-> BMeph: IIRC, I7 compiles down to regular zcode too, or maybe z8
15:55:45 <jethr0_> subconscious: i haven't looked at the ghc code that much. maybe. but for one thing it's probably a bit more complicated and also contains quite a bit of C, doesn't it?
15:55:57 <dons> jethr0_: aren't all implementations of haskell, other than hbc and hugs, like pypy
15:55:57 <dino-> Which is cool
15:56:05 <subconscious> jethr0_: I do find it very complex and I couldn't get around it easily
15:56:12 <jethr0_> Saizan: yes, could've been hhi
15:56:53 <BMeph> dino-: According to the LJ article I'm reading, I7 works by parse transformation to I6, which it then compiles.
15:57:37 <dino-> BMeph: I did not know that!
15:58:12 <hackage> Uploaded to hackage: attoparsec 0.5
15:58:36 <BMeph> dino-: I figured that a Haskell pgm that does the I7-to-I6 should be simple to whip up and simpler to maintain. Heck, I'm tempted to write one in TCL... ;p
15:58:41 <jethr0_> dons: to be honest i haven't look at much compiler/interpreter code recently. my guess would've been that for example ghc is rather heavy on C and other evil hacks. but i could well be wrong
15:59:11 <dons> nah.
15:59:21 <dons> ghc is all haskell, as most haskell compilers are.
15:59:37 <dons> except hugs is written in C, and hbc is written in lazy ML.
15:59:49 <dino-> BMeph: From what I got when first looking at I7, it looks like natural language, but it's really pretty rigid in what is allowed. I bet it wouldn't be too bad.
16:00:42 <pfo> when i define the two functions (sum,sum') like i've seen from http://www.haskell.org/haskellwiki/Pointfree - then these two are not equivalent; the first wich uses point-free style doesn't do sum [1.0,1.1..10.0], but the second form (point-full style) works as expected on [Double] - any reason why this is so?
16:00:44 <lambdabot> Title: Pointfree - HaskellWiki
16:01:17 <dons> newsham: can you package  the binary-deriver some how?
16:01:40 <jethr0_> i liked the idea of "lisp in small pieces" of building a VERY simple interpreter which you could then play around with (i.e. change evaluation style, ...) extremely easily
16:01:59 <newsham> dons: sure.  i'll hackage it up I guess.
16:02:30 <subconscious> jethr0_: me too - You can do lazy evaluation in just a few lines of code :)
16:02:34 <jethr0_> > foldr (+) 0 [1.0,1.1..10.0]
16:02:36 <lambdabot>   500.49999999999955
16:02:57 <jethr0_> > (\xs -> foldr (+) 0 xs) [1.0,1.1..10.0]
16:02:59 <lambdabot>   500.49999999999955
16:03:33 <jethr0_> pfo: what do you mean by "doesn't do sum"?
16:03:45 <pfo> i get en error from ghci
16:03:59 <jethr0_> subconscious: exactly. i was very impressed with the idea of tweaking your language so easily and powerfully
16:04:25 <jethr0_> pfo: could you paste your code? code be a monomorphism restriction.
16:04:38 <jethr0_> i.e. requiring you to give an explicit type for functions without arguments
16:04:47 <pfo> no instance for (Fractional Integer) arising from literal '10.0'
16:04:54 <pfo> jethr0_: sure, just a mom.
16:04:57 <dons> btw guys, complete video from the haskell symposium. http://haskell.org/haskellwiki/Video_presentations/Haskell_Symposium_2008
16:05:00 <lambdabot> Title: Video presentations/Haskell Symposium 2008 - HaskellWiki, http://tinyurl.com/3ukddq
16:05:03 <jethr0_> sum :: (Num a) => [a] -> a
16:05:18 <jethr0_> @paste
16:05:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:06:00 <jethr0_> pfo, my guess from the error message is that you've mixed numbers with and without fractional parts in your list
16:06:17 <pfo> jethr0_:  http://hpaste.org/10725
16:06:35 <jethr0_> try explictely typing your input list like "([1.0,1.1..10.0] :: [Double])"
16:07:03 <rwbarton> No, it's just the monomorphism restriction
16:07:41 <jethr0_> :t sum
16:07:42 <lambdabot> forall a. (Num a) => [a] -> a
16:07:42 <Saizan> pfo: since sum takes no formal parameters the typeclass constraint is resolved early, defaulting to Integer
16:08:10 <pfo> Saizan: oh, i see.
16:08:22 <pfo> this is called "monomorphism restriction" ?
16:08:23 <jethr0_> rwbarton: still, the error message is strangely unhelpful.
16:08:25 <inimino> what's XDR?
16:08:37 <newsham> http://www.faqs.org/rfcs/rfc1832.html
16:08:38 <lambdabot> Title: RFC 1832 (rfc1832) - XDR: External Data Representation Standard
16:08:45 <Saizan> pfo: yes
16:08:59 <subconscious> hm
16:09:05 <subconscious> I wish Charity was implemented in Haskell
16:09:07 <Saizan> pfo: you can lift it with :set -XNoMonomorphismRestriction
16:09:08 <subconscious> I could read its code ...
16:09:14 <pfo> i still don't understand why this doesn work as expected
16:09:36 <rwbarton> pfo: try entering your definitions of sum and sum', then do :t sum and :t sum'
16:09:42 <pfo> sine even the wiki says that both functions are equivalent (wich is evidently not true)
16:09:44 <pfo> sure
16:10:04 <jethr0_> pfo: there is a restriction in the type system that limits the amount of type inference on functions without arguments. hence, you will often have to supply explicit types for such functions
16:10:15 <Saizan> pfo: your sum :: [Integer] -> Integer, while sum' :: Num a => [a] -> a
16:10:16 <pfo> http://hpaste.org/10726
16:10:27 <pfo> why is sum' more general?
16:10:37 <jethr0_> pfo, they are equivalent if you type them both explicitely
16:10:54 <Saizan> pfo: because sine sum' has a formal parameter the monomorphism restriction doesn't apply to it
16:10:55 <maxote> what was used XDR for?
16:11:04 <newsham> sun (onc) RPC
16:11:08 <newsham> among other things
16:11:21 <jethr0_> > let sum :: Num a => [a] -> a
16:11:22 <lambdabot>   mueval: Prelude.read: no parse
16:11:25 <rwbarton> pfo: the justification is something like this.  Imagine you wrote   let x = (some complicated, expensive expression of type Num a => a)
16:11:33 <newsham> ie. NFS, NIS/YP
16:11:38 <jethr0_> @let sum :: Num a => [a] -> a
16:11:38 <lambdabot> Plugin `eval' failed with: .L.hi: removeFile: does not exist (No such file or directory)
16:11:42 <jethr0_> damn
16:11:57 <dino-> BMeph: One last thing: I think that they did really achieve something that was important with I7. That being making it more natural for story writers who are not 'heavy' programmers to build games. [sorry for the continued OT, everyone]
16:12:02 <rwbarton> pfo: would you find it surprising when  print (x :: Integer)  and then  print (x :: Double)  required computing x twice?
16:12:31 <pfo> there is no cast in haskell, right?
16:12:46 <inimino> I see
16:12:49 <newsham> there are type conversion functions, like fromEnum, toEnum, and fromIntegral
16:12:59 <jethr0_> pfo, there is no type coercion readily available
16:13:05 <Saizan> > let sum :: Num a => [a] -> a; sum = foldl' (+) 0; in sum ([1,2..10] :: [Double])
16:13:07 <lambdabot>   55.0
16:13:12 <IsoPallo> Typeable gives you some casting, no?
16:13:24 <pfo> why would anyone want to run ghci without  -XNoMonomorphismRestriction then?
16:13:40 <dmwit> pfo: ...see rwbarton's explanation.
16:13:41 <Saizan> pfo: because often it doesn't matter
16:13:45 <inimino> it calls 64-bit integers "hyper integers"
16:14:04 <rwbarton> (BTW, lots of people are not convinced by this explanation.)
16:14:14 <newsham> it does.
16:14:16 * dmwit raises his hand
16:14:25 <pfo> dmwit: sorry i do not understand what rwbarton wanted to tell me :/
16:14:28 <jethr0_> @wiki Monomorphism_restriction
16:14:28 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:15:27 <dmwit> pfo: The idea is that the MR protects you from some weird surprises.
16:15:46 <pfo> i see
16:15:51 <dmwit> pfo: Because there it restricts the type of a value, it prevents that value from being calculated several times, once at each type you instantiate it at.
16:15:58 <pfo> ghc error msgs are quite cryptic to me
16:16:02 <Saizan> while introducing others :)
16:16:11 <dmwit> Saizan: Sadly, yes. =P
16:16:16 <newsham> takes a while to get used to
16:16:26 <BMeph> dino-: Well, judging from how I7 works, that'd have to be the main point of it, no? :)
16:16:53 <jethr0_> pfo, as i said before, the error message you got was especially unhelpful. error messages can be intimidating, but most often the problem is pointed to quite clearly in the first 3 lines of the error message
16:16:58 <Olathe> Why would I want to prevent that ?
16:17:01 <rwbarton> But the weird surprises it introduces, it introduces at compile time
16:17:42 <pfo> at least
16:17:42 <jethr0_> + you need to get a feeling how the compiler "thinks" in order to understand the messages and how evaluation roughly works. after that it becomes much less frustrating ^_^
16:18:07 <pfo> I just started last week to learn haskell
16:18:08 <newsham> you dont need to know how th ecompiler works so much as how the type system works, no?
16:18:10 <Saizan> Olathe: if the value remains polymorphic it won't be shared even if you use it always with the same type, probably
16:18:21 <dons> pfo, welcome.
16:18:33 <rwbarton> BTW, the error messages will be much better if you write type signatures on all your functions (and this one you won't get at all!)
16:18:53 <pfo> i've read about that in the books.
16:18:57 <pfo> dons: thx
16:19:10 <jethr0_> yes, i concurr with rwbarton, that's very good advice for a haskell beginner, and as well for seasoned haskellers
16:19:34 * subconscious disagrees
16:19:35 <pfo> but with a seemingly trivial one-liner i thought that i didn't matter.
16:20:03 <rwbarton> ah but it was a two-liner :)
16:20:11 <pfo> :P
16:20:14 <rwbarton> You defined the function on one line, and used it on a second line :)
16:20:16 <jethr0_> if i run into error messages i don't quite get i tend to explicitely type the subexpression i thing the error lies in and that often helps make the error message much clearer to me
16:20:16 <Saizan> yeah
16:20:39 * subconscious uses -XNoMonomorphismRestriction and only writes type signatures when programming in haskell type system
16:20:40 <rwbarton> (Hmm, maybe it would be nice if ghci told you when it was defaulting a type)
16:21:18 <Saizan> (there's a warning you can turn for that in compiled code, maybe it works in ghci too)
16:21:30 <pfo> i don't quite get why the type system doesn't stick to the most general type in the first place ...
16:21:40 <dmwit> It's a heuristic.
16:21:44 <jethr0_> subconscious: at least in theory (never done it myself), i liked the approach of writing your program in types first with "undefined" as implementation to get the whole structure right before starting to "code".
16:21:46 <dmwit> Perhaps a poorly chosen one.
16:22:04 <pfo> with the pointfull version it does
16:22:11 <dmwit> Yes.
16:22:20 <dmwit> See the wiki page for more information on exactly how the MR works.
16:22:22 <subconscious> jethr0_: That's a great way to write programs too, That's sort of what I do in Coq, but I use haskell mostly like a dynamic typed language :p
16:22:40 <dmwit> (And the reason for it, as bad as that reason is.)
16:23:02 <MyCatVerbs> jethr0_: there's a line of thinking that says that, with sufficiently well-chosen data structures, the content of the program itself becomes a kind of of _inevitable_. :)
16:23:12 <Saizan> pfo: yeah, the restriction applies only to definition of the form let x = .. i.e no paramters, while the pointful version is of the form let x p1 = ...
16:24:04 <inimino> hm, I hardly ever (maybe never) use 'undefined', maybe I'm missing out
16:24:12 <pfo> Saizan: this decision is like a huge "WTF - why?!" to me. maybe i'll get it one day.
16:24:38 <subconscious> inimino: I don't use that actually, but the idea of a hole in the program which you can get the type of to fill in later is the good bit
16:24:53 <subconscious> inimino: (and you don't really get that in haskell unless you use silly type error tricks)
16:24:59 <jethr0_> MyCatVerbs: yes. especially with complicated recursive functions i find that once i've figured out the type of the function, there's little thought left, since it often just comes down to handling all constructors in a trivial way
16:25:10 <pfo> i like the type inference a lot, and i only placed signatures for function definitions, having to use them everywhere is kinda horrifying.
16:25:10 <Saizan> pfo: it's an arbitrary restriction introduced for the benefit of implementors
16:25:16 <inimino> subconscious: makes sense, yeah
16:25:22 <MyCatVerbs> jethr0_: that's not -quite- the same thing, I think.
16:25:29 <subconscious> pfo: Yeah I think it's horrible and hard to read but almost everyone disagrees with me :)
16:25:31 <jethr0_> without figuring out the types, however (like in scheme or lisp), figuring out the function can be messy
16:25:34 <Saizan> pfo: yeah, just use them for toplevel definitions
16:25:36 <rwbarton> pfo: Yeah, I mean put type signatures on function definitions, not everywhere.
16:25:39 <inimino> I might try doing that more when I have something that won't compile
16:26:02 <jethr0_> MyCatVerbs: i guess your point went much farther than my example ^_^
16:26:24 <inimino> I actually like to have something that compiles almost at every intermediate state when editing even if it doesn't work
16:26:24 <MyCatVerbs> jethr0_: it seems to me that what you're talking about there is something that comes up more often with interesting continuation-passing schemes - you find that once you've gotten the types worked out for CPS expressions, the code itself resembles @djinn output. :)
16:26:38 <inimino> (or run)
16:26:42 <Saizan> subconscious: it's really easier to skim through other people's code if toplevel definitions have a type signature
16:26:58 <subconscious> Saizan: yeah I haven't observed that
16:27:16 <subconscious> I'm sure that it is true for other people though -- just not the way I work
16:27:45 <jethr0_> MyCatVerbs: yes, i can see that. as i said, often it just comes down to handling all constructors in a trivial way
16:27:53 <subconscious> Saizan: Although, When I use a library I don't often look at the source code... just the signatures of the functions and the descriptions
16:28:11 <subconscious> (from the documentation not the sourec code)
16:28:24 <pfo> thank you guys
16:28:48 <MyCatVerbs> jethr0_: jah, that's it. Where the shape of the program almost seems to have been derived mechanically from the shapes of the data structures. :)
16:29:29 <Saizan> subconscious: me too, but for the same reason i find that types are a valuable documentation also when i hack on the code
16:29:56 <subconscious> I'm confused
16:30:08 <subconscious> Has anyone seenn these labeled types from epigram?
16:30:24 <jethr0_> "seen"? "labeled"?
16:30:39 <Olathe> "epigram" +
16:30:40 <Olathe> ?
16:30:47 <subconscious> they use„Äàl : t„Äâ| call „Äàl„Äât | return t
16:31:10 <Olathe> @where epigram
16:31:10 <lambdabot> http://www.e-pig.org/
16:31:12 <subconscious> and then they have a rule,  call „Äàl„Äâ(return t) ~~> t
16:31:20 <subconscious> what's the point? :S
16:31:28 <jethr0_> subconscious: are you talking about dependent types in general or about a specific epigram feature?
16:31:39 <subconscious> jethr0_: That ^
16:31:47 <pfo> what is this dependent types stuff all about?
16:33:03 <subconscious> pfo: Have you seen GADTs in Haskell?
16:33:35 <pfo> not yet
16:33:40 * subconscious is probably going ot remain confused
16:33:52 <inimino> pfo: well, it's like that ;-)
16:35:45 <jethr0_> dependent types allow a tighter connection between values and types. for example in the case of matrix multiplication you want to ensure that the matrix dimensions fit. with pure haskell you cannot(?) do this at compile time since all matrices will have the same type no matter what their dimensions
16:36:04 <subconscious> jethr0_: You can do that in Haskell using GADTs :)
16:36:21 <jethr0_> with dependent types you can restrict matrix multiplication to matrices with matching dimensions
16:36:33 <jethr0_> subconscious: hence i wrote "pure" haskell (i.e. excluding ghc extensions)
16:36:53 <subconscious> huh I like the extensions
16:37:29 <jethr0_> doing dependent typing-like things with GADTs can get pretty unwieldy rather quickly
16:37:39 <subconscious> doing dependent typing-like things with GADTs is impossible
16:38:57 <jethr0_> subconscious: i don't think i agree with that. with all available ghc extensions the type system is turing complete as far as i understand. and that should make quite a few "dependent-typing-like features" possible
16:39:34 <jethr0_> i.e. using peano numbers on type level
16:39:42 <subconscious> jethr0_: I just call it haskell stuff - like all the tricks you can do with hetrogenous types, typeclasses etc
16:42:19 <dmwit> Okay, *clearly* I don't understand threading.
16:43:02 <jethr0_> don't we all
16:43:25 <subconscious> to me, using threads feels like being a compiler
16:43:44 <subconscious> you have some idea of the way the algorithm should be .. but you have to unravel it
16:43:58 <subconscious> then again this was in C -- maybe it's better in haskell
16:43:58 <jethr0_> hence the beauty of STMs. with explicit threading the real fun starts with debugging
16:44:10 * subconscious has avoided doing anything concurrent since
16:44:14 <inimino> STM is geat :-)
16:44:25 <subconscious> actually, it would be cool to see some STM examples
16:44:38 <inimino> I have a trivial one
16:44:42 <Saizan> there are also algorithms which are inherently concurrent
16:44:46 <subconscious> hi edwardk
16:44:48 * jethr0_ thinks there are several papers, etc. on STMs
16:44:53 <jethr0_> with nice examples
16:45:01 <edwardk> heya subconscious
16:45:04 <dmwit> Okay, I get it now.
16:45:14 <dmwit> My world is no longer totally confused.
16:45:14 <Saizan> dmwit: wow, fast!
16:45:19 <dmwit> heh
16:45:25 <dmwit> I get one particular problem, anyway. =)
16:45:39 <subconscious> inimino: is it online ?
16:45:43 <inimino> huh, it's not as short as I remembered it
16:45:52 <jethr0_> dmwit: it's a never-ending alternation of insights and frustrations with explicit concurrency *g*
16:45:54 <inimino> subconscious: http://hpaste.org/7075
16:46:00 <dmwit> I was essentially polling the time to decide when to do some calculation.
16:46:04 <subconscious> ty
16:46:13 <dmwit> I figured, hey, you know what would make this both smoother and nicer on the CPU?
16:46:23 <inimino> more or less the first Haskell code I wrote so it may not be pretty
16:46:31 <dmwit> I could sleep for a couple thousand microseconds in between polls, since I know I only want updates every 0.01.
16:46:35 <dmwit> 0.01s
16:46:50 <dmwit> So I stuck a threadDelay in... and suddenly everything was *way* choppier.
16:47:05 <jethr0_> *brr*, mixing sleeping and waiting on signal
16:47:22 <dons> dmwit: maybe crank up the scheduler switching?
16:47:31 <dons> +RTS -i0.001s or something is the flag ?
16:47:32 <dmwit> dons: Yup, pretty much.
16:47:44 <dmwit> dons: Only, it was Gtk's scheduler I had to crank up. =)
16:48:15 <dmwit> The GUI was only yielding every 30ms, so my threadDelay of 5ms was really 35ms. =P
16:48:21 <inimino> subconscious: you run it with +RTS -threaded, and then connect to it with a Web browser and you have a little comet chat thing, the threads use STM to update the state
16:50:03 <wjt> it seems unfortunate that adding a 'yield' callback every n ms is still the recommended way to thread a gtk2hs application
16:50:12 <dmwit> yeah =/
16:51:04 <jethr0_> sounds like cooperative multitasking ^_^
16:51:13 <dcoutts> it is
16:51:34 <dcoutts> it works with the threaded rts too but that makes it easy to shoot yourself in the foot
16:52:11 <wjt> how so?
16:52:25 <jethr0_> foot-shooting is not as tolerated with the haskell crowd as with (for example) c++ programmers
16:52:30 <dcoutts> you could easily call gtk+ from different OS threads
16:53:15 <wjt> ah, so you can fork yourself a second thread to avoid having to do yield-polling, but then always have to add an idle callback for gtk+ functions?
16:53:31 * dolio snickers about monotonous functions. :)
16:53:51 <jethr0_> dolio: they are boring, just going in the same direction all the time
16:54:41 <dcoutts> wjt: we provide a way to post a gui action to the main thread, but there's nothing that enforces that
16:55:37 * FunctorSalad makes note to avoid gtk ;-)
16:55:58 <dmwit> Hey!
16:56:01 <dmwit> Gtk2Hs is very nice!
16:56:15 <dmwit> A lot nicer than any of the other options.
16:56:18 <FunctorSalad> dmwit: never seriously used it, was just scared by this discussion :)
16:56:20 <dcoutts> :-)
16:56:33 <jethr0_> at least it's very practical and probably more realistic than many of the more functional alternatives
16:56:34 <dmwit> In a lot of cases, you don't even need multi-threading in your GUI app.
16:56:37 <dcoutts> FunctorSalad: you get this problem for all GUI libs
16:56:50 <dcoutts> FunctorSalad: except very high level wrappers that address this specific problem
16:56:57 <FunctorSalad> hmm, ok
16:57:01 <vininim> Are there qt bindings for haskell? =p
16:57:05 <dcoutts> FunctorSalad: you get it for wx, gl, everything, qt
16:57:19 <dolio> There are.
16:57:25 <dmwit> Right.
16:57:34 <dcoutts> gl is threaded but you've still got to call it in the right thread
16:57:41 <dmwit> Gtk2Hs gets it at least as correct as any other Haskell binding.
16:57:41 <FunctorSalad> sorry, it wasn't meant as criticism, I just stumbled in
16:58:01 <dolio> I'm not sure how great they are, though. Last I looked, it was a bunch of modules with hundreds of functions (bunches with only slightly different names).
16:58:13 <hackage> Uploaded to hackage: attoparsec 0.5.1
16:58:13 <hackage> Uploaded to hackage: parameterized-data 0.1.3
16:58:13 <hackage> Uploaded to hackage: type-level 0.2.2
16:58:39 <dolio> And not much documentation.
16:58:42 <inimino> I have yet to see any GUI programming that isn't ugly
16:59:04 <dcoutts> inimino: try frp
16:59:09 <FunctorSalad> inimino: yeah
16:59:12 <dolio> Which frp? :)
16:59:13 <jethr0_> inimino: there are nice functional approaches, but i guess they are all still rather limited in their supported widgets, etc
16:59:24 <inimino> dcoutts: it looks interesting, I haven't gotten around to it yet though
17:00:25 <r3m0t>            
17:01:04 <dmwit>                       <- twice as much nothing as r3m0t
17:01:08 <FunctorSalad> is the problem to keep the UI responsive while the app is doing computations?
17:01:12 <Cthulhon>   
17:01:19 <dmwit> FunctorSalad: right
17:01:37 <r3m0t> dmwit: it's sstill nothing
17:01:57 <jethr0_> > length " "
17:01:59 <lambdabot>   1
17:02:06 <jethr0_> > length "  "
17:02:08 <lambdabot>   2
17:02:17 <subconscious> I figure it might be something to do with pattern matching on functions
17:02:19 <dmwit> FunctorSalad: For a lot of GUI-based apps, the actual calculations don't take long enough to notice anyway.
17:02:32 <subconscious> (regarding what I asked earlier)
17:03:18 <jethr0_> subconscious: you like sending people to the logs, don't you *g*
17:03:28 <subconscious> heh
17:05:03 <humasect> is it normal for cabal to desire the destination installation location of a package to something other than the runghc's own which built said package?
17:05:56 <dcoutts> humasect: I'm not sure what you mean but cabal installs to ~/.cabal by default
17:06:15 <dcoutts> which is not the same default as runghc Setup.hs
17:06:28 <dolio> subconscious: Do you have a paper with what you're talking about?
17:06:28 <dcoutts> it's --global or --user, cabal-install uses --user by default
17:06:29 <FunctorSalad> hmm, for me it installs in /usr/local/... by default
17:06:31 <dmwit> humasect: cabal just uses ghc-pkg to find already-installed packages, if that's what you're asking.
17:06:48 <dcoutts> FunctorSalad: yes, runghc Setup.hs uses --global by default
17:06:48 <dmwit> FunctorSalad: cabal-install, not the Setup.[l]hs
17:06:49 <FunctorSalad> ah, maybe it does --global automatically as root
17:06:55 <subconscious> dolio: It's in a bunch of texts on epigram (none of which I understand) but I'm reading Edwin Bradys thesis atm
17:07:05 <dolio> Hmm...
17:07:06 <humasect> dmwit: ah, so PATH is what is going on ^_^ cool.
17:07:21 <dmwit> humasect: What?  PATH has nothing to do with this, does it?
17:07:32 <humasect> to find ghc-pkg, no ?
17:07:36 <dmwit> oh
17:07:39 <humasect> where is the install path for package, by default?
17:07:41 <dmwit> You have two copies of ghc-pkg?
17:07:45 <humasect> yes
17:07:56 <dmwit> And the first one in your $PATH is not the correct one?
17:08:00 <humasect> ie. it is not enough to just call the right runghc
17:08:03 <humasect> yep.
17:08:05 <dmwit> Your setup is hosed. =P
17:08:21 <humasect> what are you talking about? i just have to set PATH to find the 'new' one.
17:08:38 <humasect> right? does cabal install call this external application 'ghc-pkg' using PATH?
17:08:44 <dmwit> probably
17:08:47 <dolio> Practical Implementation ...?
17:09:10 <dmwit> humasect: I'm not saying your system's unfixable, just that it's broken right now. =)
17:09:13 <dcoutts> humasect: cabal finds ghc-pkg based on where it finds ghc
17:09:25 <humasect> dmwit: you spelled 'elephant' wrong
17:09:44 <humasect> Installing executable(s) in /usr/local/bin \n Setup.hs: /usr/local/bin: copyFile: permission denied (Permission denied)
17:10:09 <humasect> dcoutts: should i runghc install --user ?
17:10:39 <dmwit> yes, or use sudo/su
17:11:05 <humasect> why does cabal like to install in this place, is it hardcoded? ghc-pkg has nothing to do with /usr/local/bin
17:11:49 <humasect> dmwit: ok, it does not know about --user ^_^ hmm.
17:13:05 <humasect> how do others do this, to put all of GHC into one place ?
17:13:19 <humasect> including cabal packages built with said GHC
17:13:41 <Saizan_> humasect: --user is a configure option
17:13:48 <humasect> "/usr/local/lib/numeric-prelude" eh ~
17:14:01 <humasect> ahh, cool =)
17:14:31 <humasect> oh, i see, this is what ~/.cabal is all about
17:15:28 <humasect> what is the purpose to have either system-wide or hidden-in-home choices? most of what comes with ghc are packages anyway, how can one keep this situation cleaner than it seems to be at the moment?
17:16:31 <dolio> Hidden-in-home doesn't require superuser access.
17:16:43 <Olathe> What are some useful cases in which a module wouldn't export anything ?
17:16:53 <dcoutts> Olathe: instances
17:16:55 <dmwit> humasect: I use ~/.cabal on the workstations at school, for example.
17:17:04 <humasect> right, dolio , so without SU access, where would they install GHC? .cabal? =)
17:17:05 <Olathe> Ahh.
17:17:07 <dmwit> humasect: Whereas I use my superuser powers at home to install everything globally.
17:17:26 <dmwit> humasect: ~/Programs/GHC/6.8.3 ;-)
17:17:36 <dolio> I don't know how a local GHC install goes.
17:17:47 <humasect> dmwit: GHC hides in /Library/Frameworks/GHC.framework/Versions/x.y -- where cabal still installs /usr/local
17:17:59 <dolio> Maybe it's installed globally, along with a few packages, but your users want to be able to install their own stuff.
17:18:00 <humasect> (for this system wide)
17:18:15 <dmwit> humasect: Try configuring with --prefix=/Library/...
17:18:38 <Saizan_> runghc Setup configure --help | less
17:18:44 <humasect> sure, dolio. they can do that even if cabal defaults to install along with GHC. i dont think this about usermode/SU mode
17:18:58 <humasect> dmwit: /Library/ is not exactly posix with bin and lib and share and such.
17:19:23 <Saizan_> humasect: you can customize all the paths via flags to configure
17:19:24 <humasect> cabal will install where, on windows? /usr/local? ?
17:19:29 <dmwit> humasect: Try Saizan_'s suggestion.  There are often separate commands to control the separate paths.
17:19:34 <humasect> ah, i see
17:19:43 <dolio> Where are your non-super users going to install stuff in that situation?
17:20:19 <humasect> dolio: hehe, what about those who *want* to install cabal stuff along with their ghc ?
17:20:45 <dolio> They can't, because the GHC is global, and they're not superusers.
17:20:47 <dmwit> I'm confused exactly what you're complaining about, humasect.  What do you want to do?
17:20:47 <humasect> some have it in /usr/ for example and want their cabal packages there .. it just seems like it should follow what GHC is already set up to be, in superusermode, where GHC is located.
17:20:56 <dolio> Anyhow, there's a cabal-install flag that tells it to install globally.
17:21:27 <inimino>  /usr/local is standard for anything installed manually
17:22:23 <inimino> that pretty much goes for anything Posixy unless you use --prefix
17:22:34 <inimino> not sure why cabal would be any different
17:22:46 <humasect> yep, that is right inimino
17:22:53 <humasect> but haskell's world is simply not global
17:23:21 <inimino> what do you mean?
17:23:59 * dolio is totally confused.
17:24:55 <humasect> hehe, do not worry about it. it will become obvious as it matures
17:25:29 * inimino resolves not to worry about it
17:26:52 <humasect> thanks for your help everyone, take care =)
17:40:27 <Olathe> Is there a reason to put f [] in f [] = ""; f xs = intercalate ", " $ map show xs ?
17:41:03 <dolio> > intercalate []
17:41:03 <Cale> Olathe: I don't think so.
17:41:04 <lambdabot>       Overlapping instances for Show ([[a]] -> [a])
17:41:04 <lambdabot>        arising from a use...
17:41:12 <Olathe> Ahh.
17:41:12 <Cale> > intercalate ", " []
17:41:13 <dolio> > intercalate ", " []
17:41:14 <lambdabot>   ""
17:41:15 <lambdabot>   ""
17:41:18 <Olathe> They have that in RWH.
17:41:29 <Olathe> The PutJSON thing.
17:41:36 <Cale> Maybe it was originally recursive?
17:42:20 <Olathe> I don't feel knowledgeable enough to leave a comment, though.
17:42:48 <Cale> You could leave a comment that the empty case is unnecessary.
17:43:20 <dolio> Something to do for the second edition. :)
17:43:46 <Cale> Or I can.
17:43:49 <inimino> something for the errata
17:44:26 <Olathe> Alright.
17:47:21 <stepcut>  Is there a way to make this function compile,
17:47:22 <stepcut> > apply f [] = f
17:47:23 <stepcut> > apply f (a:as) = apply (f a) as
17:47:23 <Olathe> Bah, I put it in, too :)
17:47:24 <lambdabot>   mueval: Prelude.read: no parse
17:47:24 <lambdabot>  Terminated
17:47:44 <Cale> stepcut: What would its type be?
17:48:01 <stepcut> 'f' has a type like, a, a -> a, a -> a -> a, etc. And it would be applied to the args in the list.
17:48:13 <stepcut> Cale: dunno, something involving Fix perhaps
17:48:26 <dolio> Something involving dependent types. :)
17:48:30 <stepcut> Cale: or Builder and associative types
17:48:38 <Cale> stepcut: f has *all* of those types?
17:48:55 <stepcut> the lightweight approach to generic data-type rewriting has something that looks like it should be adaptable
17:49:14 <stepcut> Cale: it would depend on which f you call the function with
17:49:26 <inimino> like printf?
17:49:35 <stepcut> inimino: I think so
17:49:54 <rwbarton> It's kind of the opposite problem to printf
17:50:02 <inimino> yeah
17:50:10 <Cale> stepcut: Don't you mean that it would depend on how many elements the list has?
17:50:14 <stepcut> the rewrite paper uses some associative types like:
17:50:16 <stepcut> > class Builder a where type Target a :: *
17:50:17 <stepcut> > instance Builder (b -> a) where type Target (b -> a) = Target a
17:50:19 <lambdabot>   mueval: Prelude.read: no parse
17:50:19 <lambdabot>  Terminated
17:51:09 <stepcut> Cale: well, I think that the arity of the function and the number of arguments in the list must be the same or it will result in a runtime error
17:51:11 <rwbarton> That looks like the printf problem, which, yeah, can be solved using functional dependencies or associated types
17:51:18 <Cale> apply :: (forall b. a -> b) -> [a] -> b
17:51:19 <Cale> apply f [x]    = f x
17:51:19 <Cale> apply f (x:xs) = apply (f x) xs
17:51:21 <Cale> that compiles
17:51:37 <rwbarton> Good luck calling it
17:52:00 <Cale> apply :: (forall b. b) -> [a] -> b
17:52:00 <Cale> apply f []     = f
17:52:00 <Cale> apply f (x:xs) = apply (f x) xs
17:52:05 <Cale> Of course, that does too.
17:52:38 <Cale> But of course, there are not many values of that type :)
17:52:44 <Cale> (forall b. b)
17:52:59 <dolio> There aren't many (forall b. a -> b).
17:53:06 <stepcut> yeah.. I was looking for the fundep / AT version
17:53:07 <Cale> That too :)
17:53:21 <subconscious> How do you use ATs?
17:53:32 <subconscious> in ghc 6.10 ?
17:53:39 <dolio> If you fiddle things, that's (a -> (forall b. b)), so a -> Bottom. :)
17:53:42 <Heffalump> subconscious: yes
17:53:51 <Heffalump> and they don't work very well even in 6.10
17:54:01 <subconscious> aw :(
17:54:32 <Heffalump> squiggle that I pointed you at before uses them quite a lot, and they kind of work, but I had to use unsafeCoerce a lot to hack around unimplemented stuff
17:57:39 <Saizan_> stepcut: something like this should work: class Apply f arg result where apply :: a -> [arg] -> result; instance Apply b arg r => Apply (a -> b) arg r where apply f (x:xs) = apply (f x) xs; instance Apply r arg r where apply r _ = r
17:57:45 <rwbarton> http://hpaste.org/10727 seems to work without any functional dependencies
17:58:11 <Saizan_> s/apply :: a/apply :: f/
17:58:31 <Olathe> rwbarton: That's with lists.
17:58:42 <Olathe> rwbarton: I think they wanted varargs originally.
17:59:13 <stepcut> Olathe: no, I wanted lists actually
17:59:24 <Olathe> Oh.
18:00:49 <dancor> what's an Arrow that is not naturally an Alternative
18:01:26 <Saizan_> an Applicative you mean?
18:01:55 <dmwit> ?src Alternative
18:01:56 <lambdabot> class Applicative f => Alternative f where
18:01:56 <lambdabot>     empty :: f a
18:01:56 <lambdabot>     (<|>) :: f a -> f a -> f a
18:02:03 <stepcut> rwbarton: cool, that seems to wok
18:02:04 <stepcut> work
18:02:22 <dmwit> ?src Applicative
18:02:22 <lambdabot> class Functor f => Applicative f where
18:02:22 <lambdabot>     pure  :: a -> f a
18:02:22 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:02:37 <dmwit> dancor: Id
18:02:39 <rwbarton> dancor: how about -> ?
18:04:51 <dmwit> Hm.
18:05:04 <dmwit> Is there an Applicative that has a natural empty, but no good <|>?
18:05:20 <dmwit> I wonder what the laws regarding <|> are.
18:05:40 <dmwit> (i.e. I presume <|> = const is somehow disallowed)
18:05:47 <dolio> Interacts with pure and <*> nicely.
18:06:18 <dolio> And whatever the zero is.
18:06:29 <dmwit> I can easily imagine the zero laws.
18:06:43 <dmwit> I'm not sure what "nice" means wrt to pure and <*>, though.
18:06:50 <Saizan_> the zero laws already disallow const
18:06:54 <dmwit> yeah
18:06:58 <dolio> (a <|> b) <*> c = (a <*> c) <|> (b <*> c)
18:07:18 <dmwit> Saizan_: But probably anything with a good empty can also be a "const" that respects zero, if you know what I mean.
18:07:26 <dolio> Same on the other side, probably.
18:08:18 <dmwit> Okay, so (zero <|> f = f; f <|> zero = f; f <|> g = f) have any problems?  Unless zero isn't a simple pattern, I guess.
18:08:20 <dolio> Nothings jumping out at me for pure.
18:08:56 <dolio> zero <*> a = a <*> zero = zero
18:09:33 <Saizan_> uhm
18:09:42 <dolio> I suppose IO violates that, though.
18:09:44 <dancor> ?src Id
18:09:44 <lambdabot> Source not found. It can only be attributed to human error.
18:09:51 <dmwit> newtype Id a = Id a
18:10:07 <dmwit> instance Functor Id where fmap f (Id a) = Id (f a)
18:10:12 <Saizan_> so what will (<|>) be for ZipList if zero = []?
18:10:43 <dolio> @instances Alternative
18:10:43 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
18:10:55 <dolio> @instances-importing Control.Applicative Alternative
18:10:56 <lambdabot> Maybe, WrappedMonad m, []
18:11:37 <dolio> <|> = ++ could work, possibly.
18:11:47 <dolio> [] ++ z = z ++ [] = z
18:12:00 <dolio> zip [] z = zip z [] = []
18:12:02 <dmwit> Saizan_: Okay, that's a good counterexample.  Thanks.
18:12:19 <Saizan_> dolio: it's not nice with (<*>)
18:12:27 <dmwit> (Good counterexample to the const-y <|>, anyway.)
18:12:50 <dolio> Yeah, that breaks it.
18:16:24 * Saizan_ wishes he could read the slides in the haskell symposium's videos
18:20:28 <r3m0t> how do you define a data structure that holds a finite number of elements?
18:22:03 <dmwit> r3m0t: data Three a = One a | Two a a | Three a a a -- for example
18:23:03 <dmwit> r3m0t: Another possibility is to use the module system like so:
18:23:09 <bd_> or just use (,,,) and etc
18:23:10 <dmwit> module Three where
18:23:16 <dmwit> newtype Three a = Three [a]
18:23:27 <dmwit> cons :: Three a -> Maybe (Three a)
18:23:39 <dmwit> cons x xs | length xs < 3 = Just (x:xs)
18:23:51 <dmwit>           | otherwise = Nothing
18:24:03 <dmwit> Then export cons, but not Three or Three(Three).
18:24:10 <r3m0t> ok, I get it
18:26:45 <BMeph> I thought the ZipList mzero was repeat [], not just []. :)
18:27:08 <dolio> That has type ZipList [a], though.
18:28:24 <dolio> In fact, that would be saying that zero = pure []
18:28:37 <Olathe> @type pure
18:28:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:28:50 <Olathe> @src pure
18:28:50 <lambdabot> Source not found. My mind is going. I can feel it.
18:29:22 <[R]ayne> Lmao!
18:30:09 <dancor> lmabdobot
18:30:53 <Olathe> Heheh
18:33:05 <younder> Have a problem with the following code:
18:33:06 <younder> http://hpaste.org/annotate/10728?oldId=0
18:33:44 <younder> get the error: couldnt match type (The -- lines)
18:33:56 <newsham> > 2^(43112609) - 1
18:34:09 <lambdabot>   316470269330255923143453723949337516054106188475264644140304176732811247493...
18:34:23 <younder> Do you know what is causing it?
18:34:44 <shrughes> Nope.  I'd have to look at it to know that.
18:34:50 <newsham> > length . show $ 2^(43112609) - 1
18:35:05 <dmwit> younder: patience =P
18:35:06 <lambdabot>   thread killed
18:35:36 <dmwit> younder: Okay.
18:35:52 <dmwit> younder: Check out the result of your base case for printListFac.
18:35:57 <dmwit> What's its type?
18:36:27 <younder> a null list
18:36:41 <Olathe> > length . show $ 2^(43112609) - 1
18:36:44 <dmwit> That's its value.  But you're basically right; the type is [a] (for any a).
18:36:49 <Cale> younder: That makes it a list, rather than an IO action
18:36:56 <lambdabot>   thread killed
18:36:57 <dmwit> younder: But that function needs to return an IO action instead.
18:37:02 <dmwit> younder: (Since it's doing IO. =)
18:37:29 <dmwit> younder: So, for now, just change [] to "return ()" on trust, then look at one of the many IO tutorials out there to figure out what's going on.
18:37:54 <Olathe> > floor (43112609 * logBase 10 2) + 1
18:37:55 <lambdabot>   12978189
18:37:56 <Cale> If v is any value, then  return v  is the IO action which does nothing, but returns that value, when run.
18:37:58 <younder> Ok. I'm new with this. Please be patient.
18:38:05 <Cale> younder: That's okay :)
18:38:05 <dmwit> younder: On a side note, there are many other changes I would make to use more library functions.  But you'll get there. =)
18:38:34 <younder> I'm still on page 17 in the tutorial..
18:38:35 <inimino> fg
18:38:40 * dmwit nods
18:38:42 <inimino> oops
18:38:59 * dmwit suddenly jumps out of the background and starts hogging CPU!
18:39:01 <Cale> younder: So essentially what your printListFac function is going to do is take a list, and build up an action for printing the factorials of the values in that list.
18:39:10 <inimino> heh
18:39:59 * Olathe attempts to switch to his terminal to halt dmwit...but fails :(
18:40:04 <newsham> olathe: big number
18:40:21 <Olathe> newsham: Yeah.
18:40:39 <newsham> takes 20sec just to compute "show" on my box
18:41:12 <Olathe> It freezes YouTube when I run it in ghci.
18:41:31 <newsham> you need a better scheduler :)
18:42:35 <Olathe> Heheh
18:43:35 <Saizan_> newsham: you know that Data.Derive can derive Binary and NFData ?
18:43:37 <Olathe> I decreased its priority. Hopefully it won't start doing IO.
18:46:25 <newsham> saizan: nope, didnt know.  what does its derivation look like for binarys for variant types?
18:47:21 <newsham> saizan: i have some extra features beyond simple derivation, such as the ability to choose the mapping between varians and the discriminant value
18:47:22 <Saizan_> newsham: a byte for identifying constructor and then the arguments
18:47:40 <newsham> but i will take a look at the data.derive stuff
18:48:17 <Olathe> > let untilCount p f n = f' 0 p f n; f' c p f n = if p n then c else f' (c + 1) p f (f n) in untilCount (==0) (`div` 10) 19
18:48:18 <lambdabot>   2
18:48:26 <newsham> ahh, interesting, it picks the smallest of byte/word/dword for discriminant
18:48:33 <newsham> for the given range
18:49:24 <subconscious> > let untilCount p f n = length . takeWhile (not p) . iterate f n in  untilCount (==0) (`div` 10) 19
18:49:26 <lambdabot>   Couldn't match expected type `a -> Bool'
18:49:30 <subconscious> > let untilCount p f n = length . takeWhile (not . p) . iterate f n in  untilCount (==0) (`div` 10) 19
18:49:32 <lambdabot>   Couldn't match expected type `a -> [a1]'
18:49:38 <subconscious> > let untilCount p f n = length . takeWhile (not . p) . iterate f $ n in  untilCount (==0) (`div` 10) 19
18:49:40 <lambdabot>   2
18:49:52 <subconscious> ugh that went well .........
18:50:29 <Olathe> I wonder how to easily do `div` 10^2, 10^4, 10^8 until it stops working.
18:50:39 <subconscious> use iterateProgress
18:50:50 <Olathe> @src iterateProgress
18:50:51 <newsham> is this Data.Derive stuff for generating sources or for TH?
18:50:51 <lambdabot> Source not found. I am sorry.
18:51:01 <Olathe> @type iterateProgress
18:51:02 <subconscious> iterateProgress f x = let fx = f x in if fx == x then x else iterateProgress f fx
18:51:03 <lambdabot> Not in scope: `iterateProgress'
18:51:27 <Olathe> Ahh, thanks.
18:51:31 <subconscious> ohh wait
18:51:41 <subconscious> you want to div _by_ 10^2 then 10^4
18:51:52 <subconscious> my function is useless for that then
18:52:12 <Saizan_> newsham: both
18:52:46 <Saizan_> newsham: there's a derive preprocessor, by you can also use $(derive derivation ''Type) in code
18:53:10 <younder> Ok. I get it to compile and run, but it aborts with a exception
18:53:12 <younder> http://hpaste.org/10729
18:53:29 <newsham> whats a good overview doc?  the hackage docs are huge and i dont know which one is the overview (if any)
18:53:32 <younder> non-exastive patterns.
18:53:51 <younder> How do I terminate this action?
18:53:56 <SamB_XP> hmm, my dad just went by carrying a harry potter book and holding his nose ...
18:54:22 <Saizan_> newsham: http://www-users.cs.york.ac.uk/~ndm/derive/
18:54:26 <lambdabot> Title: Neil Mitchell - Derive
18:54:41 <dmwit> younder: Why are you trying to bind the result of the print?
18:55:03 <inimino> younder: you need to handle the empty list at the end
18:55:20 <dmwit> younder: Just call (printListFac xs) at the end, as you were doing before, then add a "printListFac []" case like you used to have.
18:55:49 <inimino> younder: so add a line above, like printListFac [] = return ()
18:55:49 <dmwit> But instead of "printListFac [] = []", use "printListFac [] = <something that does IO here, say, return ()>".
18:55:50 <newsham> saizan: cool, i'll see if i cant fit my non-vanilla derivations into that.
18:56:18 <SamB_XP> newsham: ooh, chocolate derivations ?
18:57:21 <newsham> samb: ie. wrapBinary (apply a wrap/unwrap before/after get/put) and deriveEnum (derive binary with an explicit constructor to integer mapping)
18:57:22 <younder> ahh! thanks
18:57:35 <newsham> the other two are already covered by Data.Derive it seems
18:58:22 <newsham> invariably when i write something that seems kinda cool to me someone else has already done it.
18:58:32 <newsham> which I think is a neat thing
18:58:35 <minix_help_neede> newsham: me too for haskell
18:58:50 <minix_help_neede> im thinking diving into darcs
18:58:57 <minix_help_neede> is adarcs hard to get into?
18:58:58 <newsham> "minix help" ? :)
18:59:21 <minix_help_neede> newsham: i ahve a problem with minix and vmware, u have idea about that?
18:59:45 <newsham> nope.  is this minix3 or the old fashioned one?
18:59:50 <SamB_XP> what does that have to do with haskell?
18:59:59 <younder> Ok it works..
19:00:01 <minix_help_neede> minix3
19:00:03 <newsham> samb: i just asked because his nickname.
19:00:11 <minix_help_neede> actually someone posted to the newsgroup so i willt ry now
19:00:34 <newsham> minix: i'm pretty sure i booted the minix3 stock distribution in vmware5 at one point.  dunno about vmware 6
19:01:11 <newsham> maybe he can port ghc to minix3? :)
19:01:58 <SamB_XP> newsham: who would even notice ?
19:02:24 <SamB_XP> the number of people who use minix3 is probably smaller than the number of people who use Haskell!
19:03:27 <inimino> one would imagine so
19:03:56 <BMeph> BRB - fun with installs... :p
19:04:16 <dolio> I use nhc98 on hurd.
19:04:21 <dolio> With the Y windowing system.
19:04:25 <inimino> heh
19:04:26 <newsham> [15:56] < SamB_XP> what does that have to do with haskell?
19:04:33 <SamB_XP> dolio: YoY?
19:04:34 <newsham> just offering a plausible connection
19:04:43 <SamB_XP> newsham: yeah right
19:04:49 <SamB_XP> that's not plausible
19:04:59 <SamB_XP> plausible would be that he was thinking about it ;-)
19:05:02 <subconscious> so there's this http://people.cs.uu.nl/andres/LambdaPi/LambdaPi.hs
19:05:28 <SamB_XP> dolio: I can't tell if you are kidding or not
19:05:36 <dolio> Really?
19:05:56 <subconscious> they put the constructors Nat, NatElim, Zero, Succ,  Eq, EqElim, Refl, ... etc  in the data type
19:06:12 <inimino> a real Hurd user would have written GNU/Hurd
19:06:18 <subconscious> what if you wanted to support something like haskell 'data = ...'?
19:06:33 <newsham> inimino: that follows from the fact that there are no hurd users
19:06:43 <newsham> so therefore a real Hurd user -> anything
19:06:53 <subconscious> one way I guess is to have all the primitives you can define any new data type in there with, and the other option should be to have a generic <x> <x>Elim and constructors
19:08:11 <jeffz> having used GNU/Hurd, I would postulate that there are more minix3 users on the grounds of Hurds tendency to 'buy the farm'
19:08:32 <SamB_XP> inimino: point
19:08:48 <subconscious> are there other ways?
19:08:49 <newsham> i havent installed hurd in over a decade.  i doubt its made much progress in the intervening years
19:09:05 <SamB_XP> hmm, I think I installed it at some point in the past decade
19:09:16 <jeffz> the complete rewrite and redesign is its best hope
19:09:53 <SamB_XP> it wasn't terribly impressive
19:10:12 <SamB_XP> the way it handled device nodes was probably the most interesting thing about the experience ...
19:10:38 <jeffz> fuse has probably filled the niche it was tackling with translators
19:17:50 <Olathe> > let highPower base n = base in highPower 10 10^6
19:17:51 <lambdabot>   1000000
19:18:00 <Olathe> What am I doing wrong there ?
19:18:22 <SamB_XP> um ... you don't seem to be dowing any calculations ?
19:18:30 <SamB_XP> er. doing
19:18:31 <Olathe> > let highPower base n = base in highPower 10 1234
19:18:32 <lambdabot>   10
19:18:38 <Olathe> Oh.
19:18:52 <Olathe> @pl highPower 10 10^6
19:18:52 <lambdabot> highPower 10 10 ^ 6
19:19:02 <Olathe> @pl (highPower 10 10)^6
19:19:02 <lambdabot> highPower 10 10 ^ 6
19:19:06 <Olathe> Lovely.
19:19:20 <dmwit> ?pl highPower n = 10 ^ n
19:19:20 <lambdabot> highPower = (10 ^)
19:19:27 <SamB_XP> @pl let highPower base n = base in highPower 10 1234
19:19:28 <lambdabot> 10
19:19:28 <dmwit> You're doing ?pl wrong.
19:19:35 <SamB_XP> @pl let highPower base n = base in highPower x y
19:19:35 <lambdabot> x
19:19:41 <SamB_XP> @pl let highPower base n = base in highPower
19:19:41 <lambdabot> const
19:19:55 <dmwit> weird
19:19:57 <SamB_XP> Olathe: is that REALLY what you want highPower to do ?
19:20:05 <Olathe> I got confused by the precedence of ^.
19:20:16 <Olathe> No, I'm going to improve it, but that threw me off for a while.
19:20:24 <Olathe> I thought it was taking n instead of base.
19:20:38 <subconscious> nobody has read the simply easy paper? :(
19:21:51 <SamB_XP> subconscious: indeed -- nobody has read it
19:21:59 <SamB_XP> not even the reviewers or the author(s)
19:22:29 * subconscious makes a note to implements implicit parameters in the next version of SamB
19:22:43 <SamB_XP> lol
19:22:58 <inimino> would that be SamB_Vista?
19:23:03 * SamB_XP makes a note not to upgrade to SamB_Vista
19:23:18 * SamB_XP jabs inimino for taking the joke he was just making 
19:23:27 <inimino> hehe
19:24:37 <chrisdone> 17:23:30 SamB_Me has joined #haskell / 17:23:50 SamB_Me has quit #haskell (Connection reset by peer)
19:25:09 <SamB_XP> chrisdone: I have no recollection of this
19:25:16 <SamB_XP> can you find that in some official logs ?
19:25:30 <chrisdone> haha, did you actually use Me?
19:25:46 <SamB_XP> never
19:25:52 <chrisdone> lies
19:25:55 <SamB_XP> if I ever used that nick, it was a joke
19:26:12 <SamB_XP> I don't think I've ever even seen a computer that I knew was running ME
19:26:18 <foxy-om> http://hpaste.org/10730:  Windows procedure not linked in HSbase
19:26:44 <inimino> for that to be real, someone would have had to keep ME running for 20 seconds
19:27:21 <SamB_XP> inimino: as I said, if it happened I was kidding
19:27:31 <SamB_XP> I doubt it happened though
19:27:45 <SamB_XP> I tend to forget about ME's ever having happened
19:27:56 <chrisdone> I made it up. I guess time stamps make pretend quotes look realistic ;D
19:27:57 <SamB_XP> since it isn't really an ancestor of any OS I've ever used ...
19:28:28 <SamB_XP> see, I didn't think I would have made a joke like that
19:29:48 <jeffz> foxy-om: are you compiling with --make ?
19:30:02 <foxy-om> jeffz: yup
19:30:11 <dolio> ME isn't an ancestor of anything. They killed that branch after releasing it.
19:30:14 <jeffz> oh? :|
19:30:56 <SamB_XP> dolio: yeah
19:31:05 <SamB_XP> that's probably why it's not the ancestor of anything I've used
19:31:08 <dolio> For the best, probably.
19:31:14 <SamB_XP> since I haven't used it
19:31:22 <SamB_XP> dolio: oh, definately
19:31:25 <SamB_XP> it was a terrible idea
19:31:43 <SamB_XP> all the stability of 9x, all the compatability of NT
19:31:54 <SamB_XP> I mean really
19:32:04 <SamB_XP> what possible advantage could that give?
19:33:22 <SamB_XP> @seen chrisdone
19:33:23 <lambdabot> chrisdone is in #haskell. I last heard chrisdone speak 5m 26s ago.
19:33:30 <SamB_XP> hehehe
19:33:36 <bd_> SamB_XP: MS would get some upgrade revenue until people caught on?
19:34:25 * chrisdone points suspiciously at bd_
19:34:30 <shepheb> but enough to cover developing, marketing and selling it? I doubt they made money on ME overall.
19:35:15 <joed>  doubt it involved much development... It was a hurried disaster.
19:35:28 <jeffz> ME was shipped as OEM for awhile
19:35:32 <chrisdone> I remember getting a copy of Me, being so excited (‚Äòcause newer = better, right?) back when I was a windows fanboi
19:36:09 <SamB_XP> "the Y2K bug in a box" ... was that the advertising campaign ?
19:38:43 <BMeph> SamB_XP: I object to that characterization. I've run 98SE for months at a time, with nary a problem. ME, OTOH... ;p
19:39:12 <SamB_XP> BMeph: er, I was being sarcastic
19:39:18 <SamB_XP> you KNOW that
19:39:45 <BMeph> Yeah, but still, ... ;p
19:39:49 <SamB_XP> all the [in]stability of 9x and all the [in]compatability of NT
19:39:58 <SamB_XP> does that make you feel better ?
19:40:03 <idnar> Windows ME was far more unstable than 9x
19:40:09 <SamB_XP> or do I have to add [and more]
19:40:21 <idnar> I honestly can't think of comparably unstable operating system
19:40:28 <SamB_XP> anyway, never having used ME, I could only guess at this
19:40:44 <jeffz> idnar: pretty sure ME is considered 9x
19:41:01 <idnar> jeffz: I certainly wouldn't perpetrate such a heinous insult against 95 and 98
19:41:07 <SamB_XP> jeffz: ambiguous
19:41:17 <idnar> everyone would probably be better off pretending that ME never happened
19:41:22 <jeffz> as far as i can gather, it most closely resembles 98 in terms of compatability
19:41:32 <SamB_XP> idnar: isn't that what everyone does anyway
19:41:39 <idnar> there's absolutely no reason why any sane person would have used it for any nontrivial period of time
19:41:45 <idnar> SamB_XP: thankfully, yes :P
19:41:59 <jeffz> I used it for 3 years, never had a problem.
19:42:08 <scodil> I'm in the same boat as jeffz
19:42:15 <SamB_XP> I think those who have anything to remember have repressed the memories
19:42:23 <scodil> it wasn't fantastic, but it gave me no grief
19:42:44 <SamB_XP> those who haven't just don't ever have any reason to think about it, since it was a dead end
19:42:51 <chrisdone> I remember the crashes, and other weird problems. I remember vividly being confused about why a newer version would be worse. so I uninstalled, unhappily
19:43:41 <idnar> jeffz, scodil: you are the first people I've ever talked to who didn't have stupendously awful issues with ME
19:44:04 <SamB_XP> idnar: what about me
19:44:07 <SamB_XP> I didn't either
19:44:14 <chrisdone> that is a vacuous truth
19:44:22 <SamB_XP> still!
19:44:26 <scodil> I think it helped that it was pre-installed. I just happened to buy a dell when they were shipping just the right hardware. sheer luck
19:44:26 <idnar> SamB_XP: haha
19:44:30 <idnar> SamB_XP: you know what I mean
19:44:42 <SamB_XP> yes, and I think you know what I mean too
19:46:53 <idnar> SamB_XP: good, we have an understanding, then
19:47:03 <idnar> SamB_XP: I'll have my lawyers finalized the details with yours
19:47:30 <SamB_XP> idnar: it has been done
19:48:04 <SamB_XP> (that is to say, I don't think either of us has any lawyers anyway, so the cross product of our lawyers is empty ...)
19:48:49 <chrisdone> your lawyers do not agree
19:48:54 <chrisdone> woo vacuous truths!!
19:49:02 <chrisdone> okay, /me stops
19:49:07 <SamB_XP> chrisdone: that's not a vacuous truth
19:49:10 <dancor> chris done
19:49:27 <SamB_XP> for our lawyers not to agree, one of my lawyers would have to disagree with one of his lawyers
19:49:43 <SamB_XP> which would require us each to have at least one lawyer
19:49:50 <chrisdone> dan cor
19:50:19 <chrisdone> neither of your lawyers agree because you don't have any
19:50:30 <dancor> but the largest set of lawyers that pairwise agree is empty
19:50:55 <chrisdone> hehe
19:51:11 <SamB_XP> dancor: but it also consists of all of the lawyers!
19:51:30 <dancor> i'm sure this can be resolved with the axiom of choice
19:51:56 * chrisdone goes to watch season 2 of babylon 5. woo
19:52:10 <SamB_XP> don't get all non-constructive on me!
19:53:59 * roconnor applies hilbert's operators to get a function from the set of lawyers to a lawyer.
19:54:25 <SamB_XP> roconnor: you can't do that with a null set
19:54:34 <roconnor> yes I can
19:54:41 <SamB_XP> no, you can't
19:54:46 <roconnor> there is one function
19:54:47 <SamB_XP> a null set doesn't have any damn elements!
19:55:00 <roconnor> @djinn Void -> Lawyers
19:55:01 <lambdabot> Error: Undefined type Lawyers
19:55:10 <roconnor> @djinn Void -> a
19:55:10 <lambdabot> f = void
19:55:51 <SamB_XP> roconnor: okay, I don't understand what you meant up there then
19:56:57 <dolio> a^0 = 1
19:58:49 <Olathe> @djinn Void -> Void
19:58:50 <lambdabot> f a = a
19:58:57 <Olathe> @djinn OMG -> OMG
19:58:57 <lambdabot> Error: Undefined type OMG
20:00:07 <Olathe> @djinn Void -> [a]
20:00:07 <lambdabot> Error: Undefined type []
20:00:42 <dolio> djinn doesn't do recursive datatypes.
20:04:50 <chrisdone> haha.. first episode of season 2 ‚Äúwe don't know of character X will survive the coma‚Äù, then character X is seen in the main line-up in the opening credits
20:05:34 <dolio> Maybe they'll be in a coma for the entire season.
20:05:43 <SamB_XP> chrisdone: I guess they should have skipped the line up for that episode, eh?
20:05:56 <Olathe> Maybe they're in flashbacks.
20:05:58 <SamB_XP> dolio: then shouldn't they be in a coma in the lineup?
20:06:03 <chrisdone> SamB_XP: yeah
20:06:07 <dolio> Heh.
20:06:07 <Olathe> Flashbacks you've never seen before !
20:06:10 <idnar> opening credits always tend to be a bit spoiler-inducing
20:06:28 <SamB_XP> yes, but they also are often not included in first eps
20:06:29 <idnar> Battlestar Galactica (the new one) is particularly bad
20:06:46 <idnar> every single episode's opening credits end with a quick flash of frames taken from throughout the episode
20:06:55 <chrisdone> SamB_XP: haha. just two people stood up in their uniform looking graceful, and a guy in a bed next to them
20:07:13 <SamB_XP> chrisdone: or standing in a coma!
20:07:27 <SamB_XP> I guess that works better for encarbonated people ...
20:07:38 <idnar> haha
20:07:39 <chrisdone> idnar: yeah, that annoys me. I used to shut my eyes/look away. but then I discovered the skip feature on my player skips precisely the right amount
20:07:43 <chrisdone> hahaha
20:08:09 <SamB_XP> e.g. you have luke, leiah, and that slab with han solo in it ;-P
20:08:31 * chrisdone giggles
20:11:26 <idnar> chrisdone: remember; no-one here is exactly what he seems!
20:12:01 <SamB_XP> in fact, I am a construct from a parallel universe
20:12:36 <SamB_XP> not unlike your commander data, except with organic skin and my emotion chip is a bit less dangerous
20:13:54 <idnar> ugh, keep your Star Trek nonsense out of my Babylon 5
20:14:15 <humasect> hehe
20:14:24 <SamB_XP> oh, sorry, did I get the timeline confused again?
20:14:32 <SamB_XP> Commander Data hasn't been created yet, has he?
20:15:01 <humasect> i laughed in the wrong channel. i say that because nothing here is funny (yet)
20:15:02 <SamB_XP> why, I suppose Warp Drive hasn't even been invented yet?
20:15:50 <Cthulhon> Everyone knows Star Wars is the best scifi franchise.
20:16:23 <SamB_XP> Cthulhon: a bit short on human-ish androids, though
20:16:48 * noZone nibbles on Haskell biscuit.
20:16:54 <BMeph> Cthulhon: Star Trek: The universe big enough to have evolution *AND* Intelligent Design!
20:17:15 <Cthulhon> They have nursing droids with full nursing anatomy in Star Wars.
20:17:20 <SamB_XP> BMeph: as if ours isn't?
20:17:28 <Axman6> > "om" : repeat "nom"
20:17:30 <lambdabot>   ["om","nom","nom","nom","nom","nom","nom","nom","nom","nom","nom","nom","no...
20:17:34 <humasect> Cthulhon =)
20:18:01 <BMeph> SamB_XP: The way the main proponents of the theories go at it, I wonder... ;)
20:18:27 <SamB_XP> Cthulhon: well, if I said I as a bit like Gurgi, that wouldn't give anyone a very pleasant feeling, would it? except maybe in an ecchi kind of way...
20:18:36 <idnar> SamB_XP: what, C3PO isn't enough human-ish android for you?
20:18:48 <BMeph> So, is the current stock market chaos the result of "the Margin Call of Cthulhu"? 8D
20:18:57 <SamB_XP> idnar: he can't even eat
20:19:27 <chrisdone> I like how b5 has a kind of story arc, each episode is relevant and progressive
20:19:32 <SamB_XP> BMeph: would you believe that I believe in a combination ?
20:19:38 <idnar> chrisdone: weeeelll. not *each* episode
20:19:45 <idnar> chrisdone: the earlier seasons have a lot of side episodes
20:20:00 <SamB_XP> it would be kind of wierd if there were no side episodes
20:20:04 <idnar> but at least they're not complete throwaway episodes
20:20:09 <chrisdone> idnar: right
20:20:15 <idnar> SamB_XP: well, for example, 24 doesn't really have "side episodes"
20:20:17 <SamB_XP> sometimes you just have a mostly unrelated thing that happens
20:20:28 <SamB_XP> idnar: that's different
20:20:29 <Olathe> Axman6: Hahah
20:20:31 <idnar> indeed
20:20:37 <SamB_XP> it covers a twenty-four hour period
20:20:38 <chrisdone> e.g. we discovered X new tech, and here are we using it the next episode! rather than .. never hearing of it ever again
20:20:56 <SamB_XP> you can't afford for there to be a "slow day" in a twenfty-four hour timeline ;-P
20:21:25 <chrisdone> > cycle "twenfty "
20:21:27 <lambdabot>   "twenfty twenfty twenfty twenfty twenfty twenfty twenfty twenfty twenfty tw...
20:21:36 <SamB_XP> chrisdone: the next episode sounds a bit soon to be using it
20:21:56 <SamB_XP> they must have geniouses in Engineering ;-)
20:22:01 <chrisdone> SamB_XP: wellll you know what I mean, just at least some time in the future
20:22:18 <Axman6> @src cycle
20:22:19 <lambdabot> cycle [] = undefined
20:22:19 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:22:32 <Saizan> don't they need to publish a paper in some conference first?
20:22:43 <SamB_XP> talking about the engineers' progress wrt the technology, that I could see ...
20:23:00 <SamB_XP> Saizan: law of the sea says no!
20:23:00 <chrisdone> > join . repeat $ "schfifty five "
20:23:02 <lambdabot>   "schfifty five schfifty five schfifty five schfifty five schfifty five schf...
20:24:53 <chrisdone> that would be cute. in a book, say. I'm reading house of leaves and it references papers and sources (fictional, of course) in footnotes. the whole book is very multilevular
20:25:06 <Axman6> hmm, anyone seen this before, when using HAppS? i'm just trying to follow the three step simple start thing
20:25:22 <Axman6> http://hpaste.org/10732
20:25:33 <Axman6> when doing sp ghc -isrc src/Main.hs --make --run --http-port=5000
20:25:35 <SamB_XP> saiam: they have to publish it, but they don't have to wait for it to be published before they can use the tech
20:25:44 <ddarius> chrisdone: I'm pretty sure there are stories that do that.
20:25:51 <Olathe> > let f = "multilevular [" ++ f ++ "]" in f
20:25:53 <lambdabot>   "multilevular [multilevular [multilevular [multilevular [multilevular [mult...
20:26:06 <mrd> @dict multilevular
20:26:06 <lambdabot> Supported dictionary-lookup commands:
20:26:06 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:26:06 <lambdabot> Use "dict-help [cmd...]" for more.
20:26:09 <mrd> @all-dict multilevular
20:26:11 <lambdabot> No match for "multilevular".
20:26:19 <Saizan> Axman6: i suggest to not use sp, but rather cabal install HAppS-Server (or use the darcs version if you're on windows)
20:26:27 <Saizan> Axman6: there's also happs-tutorial on hackage
20:26:49 <Cthulhon> lambdabot knows lojban?
20:27:07 <Axman6> Saizan: OS X. i'll try the cabal method
20:27:08 <edwardk> @lojban
20:27:37 <Olathe> I wonder if f would overflow the stack.
20:27:46 <ddarius> Olathe: It won't.
20:27:54 <edwardk> @lojban lojban
20:27:57 <lambdabot> Error: 501 Syntax error, illegal parameters
20:28:03 <Olathe> @help lojban
20:28:04 <lambdabot> I perform dictionary lookups via the following 13 commands:
20:28:04 <lambdabot> all-dicts ... Query all databases on dict.org
20:28:04 <lambdabot> devils ...... The Devil's Dictionary
20:28:04 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
20:28:04 <lambdabot> elements .... Elements database
20:28:06 <lambdabot> [9 @more lines]
20:28:10 <Olathe> @lojban omg
20:28:11 <lambdabot> Error: 501 Syntax error, illegal parameters
20:28:17 <Olathe> Heheh
20:28:18 <edwardk> @lojban hello
20:28:18 <lambdabot> Error: 501 Syntax error, illegal parameters
20:28:27 <Olathe> I think that's a web error.
20:28:39 <Cthulhon> @lojban glibau
20:28:41 <lambdabot> Error: 501 Syntax error, illegal parameters
20:29:01 <Axman6> @lojban devils test
20:29:03 <lambdabot> Error: 501 Syntax error, illegal parametersError: 501 Syntax error, illegal parameters
20:29:07 <Axman6> :|
20:29:27 <Cale> Clearly, that doesn't work.
20:29:39 <edwardk> @lojban is busted
20:29:40 <lambdabot> Error: 501 Syntax error, illegal parametersError: 501 Syntax error, illegal parameters
20:29:48 <edwardk> @devils lawyers
20:29:49 <lambdabot> No match for "lawyers".
20:30:00 <edwardk> @devils attorney
20:30:00 <Cale> @devils lawyer
20:30:01 <lambdabot> No match for "attorney".
20:30:01 <lambdabot> *** "LAWYER" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
20:30:01 <lambdabot> LAWYER, n.  One skilled in circumvention of the law.
20:30:01 <lambdabot>  
20:30:04 <edwardk> aha
20:32:22 <chrisdone> %w glibau
20:32:24 <lojbot> lujvo {glibau}, with rafsi {gli, bau}, selrafsi {glico, bangu} (English, language), glossing to "English", "English speaker": g1=b1 is the English language, used by b2 to communicate b3.
20:40:51 <ozy`> there's a lojban bot?!
20:41:13 <Olathe> %help
20:41:14 <lojbot> commands: valsi (v, w), definition (d), translate (jt, t), grammar (jg, g), selma'o (s), ref, cll, lujvo, selrafsi (sr), jbobau (tavla), speak, more, help (h)
20:41:15 <ddarius> 76% of the people here are bots.
20:41:36 <dolio> Including ddarius.
20:41:44 <Olathe> %t hello
20:41:45 <lojbot> parse error
20:42:20 <Olathe> %w valsi lujvo
20:42:22 <lojbot> gismu {valsi}, with rafsi {val, vla}, glossing to "word": x1 is a word meaning/causing x2 in language x3; (adjective: x1 is lexical/verbal). Notes: See also {slaka}, {bangu}, {cmavo}, {cmene}, {gismu}, {jufra}, {rafsi}, {smuni}. .. 1 more result
20:44:40 <chrisdone> http://github.com/chrisdone/lojbot/tree/master/Lojbot.hs
20:44:46 <lambdabot> Title: Lojbot.hs at master from chrisdone's lojbot ‚Äî GitHub
20:46:21 <dancor> shouldn't lojbot be in the lojban haskell chan
20:46:30 <dancor> i guess they already know lojbon there
20:46:36 <chrisdone> I wasn't aware such a thing existed
20:47:00 <chrisdone> what's the name?
20:47:51 <dancor> some difficult to pronounce and remember five letter word (lojburn).  jk there's not even an esperanto haskell chan
20:48:07 <dancor> i guess it would be #haskell.jbo
20:49:29 <chrisdone> anything is on topic in #lojban provided it is spoken in lojban
20:50:27 <chrisdone> Olathe: I notice you joined and parted, you /topic and /names work without being in that channel, right?
20:51:23 <Olathe> I think so.
20:51:49 <Olathe> names should give you everyone without +i.
20:53:02 <Olathe> @seen fynn
20:53:02 <lambdabot> fynn is in #haskell. I last heard fynn speak 9h 40m 3s ago.
20:56:51 <Axman6> Saizan: well, i installed HAppS-Server with cabal install, and i still get the same error
21:05:04 <vinicius> liskell: what has science done.
21:05:47 <chrisdone> haha
21:08:59 <BMeph> We should have free time: make a Scheme-based Haslisp... >;)
21:10:03 <Saizan> Axman6: weird, which ghc?
21:13:15 <micahcowan> I can Haslisp?
21:20:22 <BMeph> micahcowan: Exactly... ;)
21:24:43 <fynn> vinicius: hah!
21:25:40 <Axman6> Saizan: 6.8.3
21:26:38 <BMeph> Axman6: Are you sure? Because it looks like he uses the 6.6 build... :)
21:27:06 <Olathe> > (fromIntegral ((2^10000) :: Integer)) :: Double
21:27:07 <lambdabot>   Infinity
21:27:18 <Olathe> Double: because some infinities are smaller than others.
21:27:41 <Axman6> BMeph: ?
21:27:54 <Axman6> The Glorious Glasgow Haskell Compilation System, version 6.8.3
21:28:26 <BMeph> Axman6: Oh, NM, I thought Saizan was asking about that Liskell, not your HAppS issue. :)
21:28:33 <humasect> Olathe=)
21:28:35 <Axman6> ah right ;)
21:30:16 <shrughes> > realToFrac (2^128 :: Double) :: Float -- because some infinities are even smaller
21:30:17 <lambdabot>   Infinity
21:30:57 <dolio> > floor (2^128 :: Float)
21:30:58 <lambdabot>   340282366920938463463374607431768211456
21:31:11 <dolio> > 2^128
21:31:13 <lambdabot>   340282366920938463463374607431768211456
21:31:16 <Olathe> > floor ((2^128) :: Float)
21:31:17 <lambdabot>   340282366920938463463374607431768211456
21:31:26 <Olathe> Hmm...
21:31:40 <dolio> > 2^128 :: Float
21:31:42 <lambdabot>   Infinity
21:31:47 <Olathe> Haha
21:32:00 <Olathe> I wonder how ghc does that.
21:32:16 <shrughes> > (2^128 - 2^104) :: Float
21:32:17 <lambdabot>   Infinity
21:32:29 <shrughes> > realToFrac (2^128 - 2^104 :: Double) :: Float
21:32:30 <lambdabot>   3.4028235e38
21:32:31 <shrughes> right.. :/
21:32:54 <shrughes> > round $ realToFrac (2^128 - 2^104 :: Double) :: Float
21:32:56 <lambdabot>       No instance for (Integral Float)
21:32:56 <lambdabot>        arising from a use of `round' a...
21:33:05 <shrughes> > round $ (realToFrac (2^128 - 2^104 :: Double) :: Float)
21:33:06 <lambdabot>   340282346638528859811704183484516925440
21:36:42 <Olathe> instance Floating Rational where pi = 22%7
21:38:53 <shrughes> instance Floating Integer where pi = 4
21:39:17 <dolio> No way, it's 3.
21:39:26 <shrughes> heretic! kill him!
21:39:32 <humasect> hehe
21:39:33 <dolio> My holy texts say so.
21:39:45 <humasect> > pi :: Integer
21:39:46 <lambdabot>       No instance for (Floating Integer)
21:39:46 <lambdabot>        arising from a use of `pi' at...
21:40:20 <humasect> holy promoses
21:45:34 <dons> ?yow
21:45:35 <lambdabot> Is it clean in other dimensions?
21:45:43 <dons> icfp over, haskell symposium over, cufp over, defun over.
21:45:49 <dons> a long long wild crazy week for haskell.
21:45:58 <thetallguy> how was cufp?
21:46:04 <dons> pretty huge.
21:46:16 <dons> thetallguy: you know haskell is powering garbage trucks and buses now?
21:46:24 <thetallguy> dons: !!!
21:46:35 <dons> hopefully the videos are up soon.
21:46:38 <thetallguy> computerized garbage trucks?
21:46:40 <dons> but check out what Eaton's been up to.
21:46:55 <dons> dsls for writing drivers for hydraulic control systems
21:47:15 <thetallguy> was that Mark Jones' talk?
21:47:21 <dons> no! Eaton's.
21:47:26 <dons> MPJs was at Boeing.
21:47:35 <dons> oh, haskell symposium videos up, http://haskell.org/haskellwiki/Video_presentations/Haskell_Symposium_2008
21:47:37 <lambdabot> Title: Video presentations/Haskell Symposium 2008 - HaskellWiki, http://tinyurl.com/3ukddq
21:48:03 <thetallguy> Oh, I see.  Haven't met him.
21:48:16 <dons> we got simon pj to install cabal-install at defun :)
21:48:27 <thetallguy> lol
21:49:19 <thetallguy> He's still running Windows, I assume?
21:50:19 <thetallguy> it was sort of sad at the first hackathon, nearly a hundred people, 80% linux, 19% Mac and SPJ running Windows.
21:51:32 <dons> hehe
21:53:42 <erikc> i dunno, windows has its charms, the only thing i like better about linux is package management and xmonad
22:00:57 <chrisdone> "80% linux, 19% Mac and SPJ running Windows." haha
22:01:00 <rothjl> i'm trying to program an air drag equation in opengl and i'd like to create a force in the opposite direction to the velocity. What's the best way to describe that?
22:01:03 <chrisdone> legend
22:01:34 <sebaseba> -b*v
22:02:08 <scodil> isn't drag a coefficient?
22:02:17 <scodil> s*v, for 0 < s < 1
22:02:25 <rothjl> i'm considering it relative to my velocity and at high velocity so it's b*v^2
22:02:45 <rothjl> so if i have a negative velocity...that would increase it's speed
22:03:38 <shrughes> so the force would be represented by a vector with value b*-v*|v|
22:03:43 <rothjl> i'm not worried about the propotionailty constant
22:04:37 <rothjl> ya, does || return the absolute value?
22:04:44 <shrughes> | | isn't haskell notation
22:05:07 <rothjl> how would i do it in haskell? sorry i'm new to haskell
22:05:19 <shrughes> well, how are you representing velocity?
22:05:31 <rothjl> actually trying to code opengl with haskell
22:05:40 <rothjl> velocity is a 3d vector
22:05:47 <shrughes> and so force would be the same
22:05:48 <Axman6> maybe learning haskell would be a better place to start ;)
22:06:22 <shrughes> force would be a vector with value b*|v|*-v
22:06:41 <scodil> well if you already know opengl then its a good way to learn haskell
22:07:03 <rothjl> does anyone know how to use || in haskell?
22:07:07 <shrughes> abs
22:07:09 <shrughes> > abs 34
22:07:11 <lambdabot>   34
22:07:17 <rothjl> nice
22:07:21 <scodil> can't do that on a vector
22:07:23 <shrughes> Except that if you're implementing a vector, you'd write your own absolute value function, and you wouldn't call it 'abs'
22:07:37 <Olathe> > True || False
22:07:38 <lambdabot>   True
22:07:42 <Axman6> isn't |v| the magnitude? (sqrt (a^2 + b^2 + c^2))?
22:08:04 <shrughes> It is the way I'm using it
22:08:07 <Olathe> > join (liftM2 (||)) [True, False]
22:08:09 <lambdabot>   [True,True,True,False]
22:08:29 <vinicius> you would probably write a euclidean space class and derive from it. =P
22:08:30 <Olathe> > let table f = join (liftM2 f) [True, False] in table (||)
22:08:31 <lambdabot>   [True,True,True,False]
22:08:33 <rothjl> in opengl i'm actually working with an IO type with three dimension so i may be able to use abs
22:08:37 <rothjl> i'll try it thx
22:08:49 <shrughes> rothjl: you won't use abs
22:08:50 <scodil> no you don't want abs
22:08:52 <Olathe> Ahh, that lovely ||.
22:09:20 <shrughes> say you have a vector.  maybe it's defined by the statement   "data Vec3 = V3 Double Double Double".
22:10:00 <shrughes> You would then find the magnitude by   "vectorMagnitude (Vec3 x y z) = sqrt (x*x + y*y + z*z)
22:10:08 <shrughes> :t magnitude
22:10:10 <lambdabot> forall a. (RealFloat a) => Complex a -> a
22:10:16 <shrughes> magnitude is a name that's already taken
22:10:40 <scodil> that's in the Prelude?
22:10:43 <rothjl> actually abs is working...i'm not actually working with a vector class
22:10:53 <scodil> rothjl: you're confusing us
22:10:53 <shrughes> I think it's in the Complex library
22:10:56 <rothjl> thx everone
22:11:03 <vinicius> complex? vut?
22:11:04 <scodil> wtf
22:11:10 <shrughes> wtf indeed
22:11:13 <scodil> he so doesn't want abs
22:11:27 <shrughes> maybe he's from a universe where they use the taxicab metric
22:11:32 <vinicius> :t complex
22:11:33 <lambdabot> Not in scope: `complex'
22:11:40 <vinicius> :t fromComplex
22:11:42 <lambdabot> Not in scope: `fromComplex'
22:11:50 <shrughes> vinicius: Data.Complex
22:12:11 <shrughes> > (w :+ x) * (y :+ z)
22:12:12 <lambdabot>       No instance for (RealFloat Expr)
22:12:12 <lambdabot>        arising from a use of `*' at <i...
22:12:15 <shrughes> meh
22:13:30 <vinicius> :t (:+)
22:13:32 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
22:14:40 <vinicius> > (0.27 :+ -0.47) * (0.1 :+ 0.753)
22:14:41 <lambdabot>       precedence parsing error
22:14:41 <lambdabot>          cannot mix `(:+)' [infix 6] and prefi...
22:15:02 <vinicius> > (0.27 :+ 0.47) * (0.1 :+ 0.753)
22:15:03 <lambdabot>   (-0.32691) :+ 0.25031000000000003
22:19:56 <sebaseba> vinicius: opa, usuario brasileiro de haskell?
22:21:43 <Olathe> > (0 :+ 0) :+ (0 :+ 5)
22:21:44 <lambdabot>       No instance for (RealFloat (Complex t))
22:21:44 <lambdabot>        arising from a use of `s...
22:30:30 <vinicius> sebaseba: yes =)
22:31:53 <roconnor> > exp (0:+1)
22:31:55 <lambdabot>   0.5403023058681398 :+ 0.8414709848078965
22:32:17 <Olathe> > floor (0 :+ 1)
22:32:18 <lambdabot>       No instance for (RealFrac (Complex t))
22:32:18 <lambdabot>        arising from a use of `fl...
22:32:25 <roconnor> > exp (0:+1) :: Complex CReal
22:32:27 <lambdabot>   0.5403023058681397174009366074429766037323 :+ 0.841470984807896506652502321...
22:32:31 <newsham> > length $ takeWhile ((<=2).magnitude) iterate (\y -> y*y+ (0.3 :+ 0.5)) 0
22:32:33 <lambdabot>   Couldn't match expected type `[Complex a]'
22:32:39 <vinicius> > exp(0 :+ (-1))
22:32:40 <lambdabot>   0.5403023058681398 :+ (-0.8414709848078965)
22:32:41 <scodil> exp $ (0:+1) * (pi:+0)
22:32:42 <newsham> > length $ takeWhile ((<=2).magnitude) $ iterate (\y -> y*y+ (0.3 :+ 0.5)) 0
22:32:46 <scodil> > exp $ (0:+1) * (pi:+0)
22:32:48 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
22:32:52 <scodil> crap
22:32:57 <lambdabot>   thread killed
22:33:03 <roconnor> > exp $ (0:+1) * (pi:+0) :: Complex CReal
22:33:04 <scodil> lambdabot's got a fault fpu
22:33:06 <lambdabot>   (-1.0) :+ 0.0
22:33:09 <scodil> there you go
22:33:11 <Olathe> > exp (0 :+ pi) :: Complex CReal
22:33:13 <lambdabot>   (-1.0) :+ 0.0
22:33:41 <newsham> > length $ takeWhile ((<=2).magnitude) $ iterate (\y -> y*y+ (0.9 :+ 0.6)) 0
22:33:42 <lambdabot>   2
22:38:42 <electronx> how does liftM make a method IO a?
22:39:02 <electronx> in the type its say m a
22:39:07 <electronx> not IO a
22:39:10 <newsham> make pretend "m" is "IO"
22:39:23 <electronx> m is alias for IO?
22:39:23 <newsham> ?type liftM
22:39:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:39:45 <newsham> IO matches (Monad m)
22:39:56 <electronx> okay
22:40:14 <newsham> (IO is an instance of Monad)
22:40:25 <newsham> ?instances IO
22:40:26 <lambdabot> Couldn't find class `IO'. Try @instances-importing
22:40:31 <newsham> ?instances Monad
22:40:32 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:40:49 <dons> m is a variable, you instantiate it to one of the types in the set of Monad
22:41:20 <Axman6> or in clear english, IO is an m
22:41:21 <electronx> so does haskell work out the m a should become IO a?
22:41:22 <Axman6> >_>
22:41:31 <electronx> that*
22:41:46 <electronx> or infer
22:42:48 <electronx> also does Array have all methods that are evailable to list?
22:43:21 <newsham> if you have (liftM reverse (readFile "foo"))   it works out that (a1 -> r) matches (String -> String) and (m a1) matches (IO String) and (m r) matches (IO String)
22:43:28 <electronx> i'm just wandering since haskell has no state array sort and list sort would have same peformance?
22:43:31 <scodil> electronx: no the Array methods are different from list. But you can convert an array to a list easily
22:43:38 <newsham> since reverse :: String -> String, and  readFile "foo" :: IO String
22:43:44 <electronx> newsham: thanks i get it now
22:43:56 <dons> interesting, http://dutherenverseauborddelatable.wordpress.com/2008/09/27/a-quick-update-on-batteries/
22:44:01 <lambdabot> Title: A quick update on Batteries ¬´ Il y a du th√© renvers√© au bord de la table, http://tinyurl.com/4c54wg
22:44:42 <electronx> i just have some methods that traverse arrays or list and i'm wandering if it would be faster to change to array?
22:45:01 <electronx> although i would lose the benefits of laziness
22:45:12 <newsham> for "traversing" lists work great
22:45:17 <scodil> probably not.  you only really need arrays for fast random access
22:45:23 <scodil> and arrays can be lazy
22:45:24 <ivanm> dons: so, with the Haskell Platform, what kind of batteries are going to be included? AA? ;-)
22:45:28 <electronx> that brings to another question is the gc in ghc fast?
22:45:57 <scodil> electronx: fast enough for me, but I never used any other gc'd languages before haskell so I don't know
22:46:07 <Olathe> @@ @run @run map (\x -> say ("liftM" ++ show x)) [2..5]
22:46:11 <lambdabot>       Occurs check: cannot construct the infinite type: m = (->) (m a3)
22:46:11 <lambdabot>      ...
22:46:13 <Olathe> Lots of liftMs.
22:46:27 <scodil> its terrible at collecting garbage from mutable arrays with boxed elements, though
22:46:43 <ivanm> dons: hmmm.... if the libraries in the haskell platform are meant to be cabal-installable, does this mean gtk2hs is out?
22:47:41 <electronx> scodil: viewing my process that does alot of stuff i can see mem use go to 300 then 50 then 60 then to say 400 then jump back down to 70 etc
22:48:08 <electronx> seems the gc could jump in faster to save mem
22:48:24 <electronx> this is because i'm using laziness alot
22:48:35 <scodil> electronx: you can reserve more memory at the start if you know you approx. how much you will use
22:48:44 <scodil> i forget the flag. +RTS -A  i think
22:48:58 <scodil> like ./MyProgram +RTS -A300M
22:49:12 <scodil> do I have that right?
22:49:16 <newsham> if your program is still referencing lots of data due to laziness, there's not much the gc can do about that
22:49:26 <newsham> the gc wont throw away data thats not yet trash
22:49:59 <electronx> i think most of the mem is due to the fact everything is a list :)
22:50:00 <Olathe> Since there's a way of doing varargs, is there a way of continuing to pass generated arguments to a function until it's an instance of Show ?
22:50:18 <electronx> maybe using more arrays will help?
22:50:22 <ivanm> newsham: we need pre-emptive GC! "You don't _really_ want that data, do you?"
22:50:24 <ivanm> ;-)
22:50:27 <Axman6> electronx: sounds like you need to have another look at your code, and see where you can write things better
22:51:02 <electronx> Axman6 the only way i can improve it is to make certain things tail recursive
22:51:02 <newsham> ivanm: if only the program knew ahead of time what data would never be referenced again
22:51:28 <Axman6> electronx: go for it then
22:51:34 <ivanm> *sigh* I need to work on my joke delivery, obviously...
22:51:36 <scodil> electronx: what are you storing in your lists?
22:51:42 <electronx> text
22:51:45 <electronx> words etc
22:51:49 <electronx> trigrams
22:51:51 <scodil> try ByteStrings
22:52:07 <electronx> scodil i did and it didn't really ad much speed
22:52:22 <electronx> and lists are more flexible
22:52:25 <scodil> then surely there's more going on
22:53:04 <electronx> yeah the gigabytes of html to parse etc
22:53:14 <dons> ivanm: we're not sure what to do with gtk2hs
22:53:29 <ivanm> *nod*
22:53:42 <Axman6> dons: include it and look the other way...
22:54:01 <ivanm> yeah, I've told dcoutts that he needs to go talk to the c2hs maintainer (dcoutts) to get it working properly with cabal (maintained by dcoutts)
22:54:03 <ivanm> ;-)
22:54:11 <scodil> sneak it in at the last second, "Hey how'd that get in there?!"
22:54:37 <ivanm> lol
22:54:58 <dons> why wouldn't we include it. it's the best thing for building good guis.
22:55:05 <dons> and we like getting stuff done.
22:55:16 <dons> i'm happy with requiring gtk2hs on every distro.
22:55:40 <Axman6> rawr, i want my MBP back
22:55:45 <Axman6> i miss `par` :(
22:55:50 <dons> http://galois.com/~dons/tmp/hackage.png its a lot of libraries :)
22:55:53 <ivanm> dons: because it doesn't support cabal yet?
22:56:23 <dons> ivanm: right. but since the platform is an native distro target, that might not matter.
22:56:28 <scodil> dons: what is that graph representing? (that's always my first question looking at info vis)
22:56:35 <dons> each node is a library
22:56:38 <dons> it points to things it needs
22:56:46 <electronx> who made it?
22:56:47 <dons> there are around 800 points.
22:56:51 <dons> electronx: tupil.com
22:57:03 <scodil> surely its a dag... right?
22:57:15 <ivanm> dons: *nod*
22:57:16 <dons> well, who knows... .:)
22:57:30 <electronx> looks like a giant ball of string
22:57:30 <dons> there's a lot of haskell code.
22:57:46 <dons> that's the dependency resolution you have to solve, if you want to build all of hackage.
22:57:50 <ivanm> what other large haskell libs/apps aren't cabalized? the compilers, darcs, what else?
22:58:05 <dons> qthaskell, gtk2hs, ghc, darcs, any large thing older than 5 years
22:58:16 <dons> the other 2 million lines of code are cabalised.
22:58:26 <newsham> your graph needs force-directed layout
22:58:33 <newsham> crazy layout
22:58:45 <dons> alternatively, http://blog.well-typed.com/wp-content/uploads/2008/09/package-sizes-all-crop.png
22:58:51 <lambdabot> http://tinyurl.com/3z92av
22:58:53 <dons> with bubbles representing the number of dependencies by size
22:58:54 <ivanm> dons: I thought qthaskell was new :s
22:59:08 <dons> it is new. but it isn't cabalised as it requires C++ programs to be built
22:59:14 <ivanm> and I can't see how any of the compilers could be cabalised :s
22:59:26 <dons> what if the compiler is 20 years old?
22:59:36 <dons> oh, you can*'t* see.
22:59:49 <ivanm> dons: oh? I thought that's what the extra lib flag in cabal was for...
22:59:51 <ivanm> dons: heh, yeah
23:00:00 * ivanm gives dons a pair of reading glasses
23:00:00 <dons> btw, the bubble graph is great to smack people with next time someone says there's not enough libraries.
23:00:06 <ivanm> been looking at screens for too long? :p
23:00:13 <scodil> or to see if they are colorblind
23:00:24 <newsham> i like the bubble one.. reminds me of those old charts for detecting color blindness
23:00:25 <dons> also good
23:00:31 <electronx> is curl thread safe?
23:00:36 <dons> electronx: yeah
23:00:38 <dons> the haskell binding is.
23:00:44 <dons> not curl the C library
23:00:51 <electronx> does it use a global lock?
23:00:57 <dons> the haskell library encapsulates the C calls with MVar locks to synchronise access per function
23:01:09 <electronx> ah
23:01:40 <newsham> http://www.efg2.com/Lab/Library/Color/colorblind3.jpg
23:01:53 <electronx> so it won't be that good when haskell gets a parrallel gc
23:02:05 <Olathe> How do I do a different instance for non-Show types than Show types in http://hpaste.org/10733 ?
23:02:33 <scodil> newsham: what am I supposed to be seeing there? I just see some gray dots. Does this mean I can't be a fighter pilot?
23:02:53 <dons> electronx: why? how is that relevant?
23:02:54 <newsham> i see "45" in orange dots
23:03:16 <dons> hopefully we won't be  using curl with large multicore, btw.
23:03:21 <electronx> dons: not but i want to use a for a web crawler
23:03:24 <electronx> sure*
23:03:28 <electronx> it*
23:03:47 <edwardk> @seen bos
23:03:47 <dons> electronx: right. have a look at urlcheck
23:03:47 <newsham> there are other libraries for grabbing web pages
23:03:47 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
23:03:48 <scodil> electronx: multiple processes?
23:03:55 <dons> for a multicore parallel 404 checker
23:03:56 <newsham> some of them in pure haskell
23:04:01 <dons> you could use that instead to do crawling.
23:04:08 <dons> electronx: on hackage. these are easy to write.
23:04:18 <dons> just use Chans to send jobs to threads that make network calls
23:04:22 <newsham> does multicore matter much for that?  its all going out through the tcp/ip stack anyway.
23:04:29 <Olathe> Even with greyscale, the 45 is there.
23:04:50 <sjanssen> newsham: concurrent requests are certainly necessary
23:04:52 <electronx> dons: thanks i take a look at it
23:05:01 <newsham> olathe: what do you see here?  http://blog.well-typed.com/wp-content/uploads/2008/09/package-sizes-all-crop.png
23:05:03 <lambdabot> http://tinyurl.com/3z92av
23:05:17 <newsham> sjanssen: *nod* but you can do that with threads and a single core effectively.
23:05:48 <Olathe> newsham: A thousand packages suddenly cried out and were silenced !
23:06:01 <sjanssen> newsham: sure
23:06:39 <bos> edwardk: ?
23:08:26 <Olathe> http://colorfilter.wickline.org/?a=1;r=;l=0;j=1;u=www.everwonder.com/david/colorblind.html;t=p
23:08:39 <lambdabot> Title: Colorblind Filter: @{[p( Are You Color Blind? )]}, http://tinyurl.com/3spm4n
23:08:47 <Olathe> Are you colorblind ? That simple test will help you to find out >;)
23:09:39 <electronx> dons: you made the parrallel url checker?
23:10:39 <dons> electronx: yup
23:10:44 <dons> it was for a blog post i never wrote.
23:10:51 <electronx> dons: :)
23:11:03 <dons> i use it to check the haskell weekly news for link typos
23:11:09 <dons> but i don't do the hwn anymore, so i dont :)
23:11:11 <electronx> dons: just wandering why do leave out type signatures for alot of methods
23:11:19 <dons> oh, i shouldn't do that.
23:11:28 <dons> hopefully all top level things have signatures
23:11:32 <ivanm> *tsk, tsk* naughty dons! :p
23:11:32 <electronx> :)
23:11:45 <dons> sometimes i don't for scripts.
23:11:50 <electronx> makes code harder to read
23:11:56 <dons> definitely.
23:12:05 <dons> turns it into python.
23:12:07 <newsham> <picture of dons> "does this guy look like he needs a type system?"
23:12:25 <dons> i definitely need it.
23:12:31 <newsham> eh, python lets you mix unrelated types in containers :)
23:12:39 <dons> oh, looks like it doesn't have types purely for marketing purposes.
23:12:42 <dons> i.e. a blog post.
23:12:45 <dons> its written like a blog post.
23:12:55 <electronx> dons: did you benchmarks it?
23:12:55 <ivanm> dons: how does adding types make it harder to read, or turn it into python?
23:13:07 <dons> electronx: it was faster than the linkchecker python script
23:13:13 <dons> but that's because ghc is faster.
23:13:13 <newsham> ivanm: i think he meant w/o types its kinda like python
23:13:22 <ivanm> ahhh
23:13:31 <dons> but it will spend most of its time waiting on the network
23:13:42 <dons> you might want to try using curl as the backend, and cranking up the curl options
23:14:04 <electronx> ok
23:14:05 <sebaseba> leaving out type signatures might make it easier to change code
23:14:23 <electronx> sebaseba: they're one line
23:14:53 <ivanm> sebaseba: but you shouldn't _have_ to change the code once you've written it properly! :p
23:15:03 <dons> it sometimes happens that you change monad stacks.
23:15:14 * ivanm had fun the other day changing his type sigs from a restricted, custom type alias to a generic class instance usage :s
23:15:15 <dons> that's the main thing i'd like refactoring tools for. since the transform is automated.
23:15:19 <newsham> ivanm: i guess all your homework is well spec'd?
23:15:19 <dons> otherwise, i don't find types get in the way.
23:15:34 <ivanm> newsham: heh
23:15:43 <FunctorSalad_> sebaseba: you can also (ab)use typeclasses for that ;-)
23:15:50 <electronx> dons: would it run happily with say 200 threads?
23:16:10 <sebaseba> FunctorSalad_: any examples?
23:16:34 <FunctorSalad_> I actually made one that amounts to "RefactorsTo a b where refactor :: a -> b" :)
23:17:11 <dons> electronx: i don't know. 200 threads is tiny, so i expect so.
23:17:22 <dons> ghc's been tested with a million threads, so i wouldn't worry yet :)
23:18:02 <electronx> cool
23:18:03 <electronx> thanks
23:19:31 <ivanm> what would people recommend as a "report format" (including images) to have my program generate?  I was thinking of using pandoc-compatible markdown, but it doesn't have scaling support for images (so conversion to latex for example could be iffy)
23:19:49 <dons> json?
23:20:05 <dons> needs inline images does it?
23:20:05 <dons> hmm
23:20:12 <ivanm> never heard of json...
23:20:12 <dons> 'binary' ?
23:20:26 <ivanm> what do you mean by binary?
23:20:54 <scodil> ones and zeros, probably    (don't shoot!)
23:20:58 <ivanm> heh
23:21:41 <ivanm> json isn't suitable, as it's meant to be an actual document
23:27:49 <ivanm> dons: as a programmer, what kind of output format would you prefer to read from a software analysis library?
23:28:00 <dons> xml?
23:28:09 <dons> but if it has lots of binary gunk in it.
23:28:09 <dons> hmm.
23:28:12 <dons> that's harder.
23:28:19 <dons> i'd probably use Data.Binary if only haskell tools were involved.
23:28:21 <ivanm> well, "binary gunk" == graphviz images
23:28:34 <ivanm> you'd actually _read_ xml? :o
23:28:40 <dons> i can parse xml
23:28:42 <dons> with xml parsers.
23:28:50 <dons> not for humans.
23:28:57 <ivanm> this is meant to be for humans ;-)
23:29:07 <ivanm> hence "read", rather than "parse" :p
23:29:31 <Axman6> yaml?
23:29:53 <ivanm> (the other option is that I restrict the image size when I create it, and thus avoid the issue of whether pandoc can scale it or not)
23:29:57 <dons> yaml/json then
23:30:05 <dons> but it has image gunk, so not sure.
23:30:19 <Axman6> html >_>
23:30:28 <Axman6> html + bz2
23:30:36 <ivanm> Axman6: yeah, I was thinking that...
23:30:59 <ivanm> but as for yaml/json... this is meant to produce an actual _document_, not some kind of human-readable data exchange format
23:31:17 <Axman6> LaTeX?
23:31:32 <Axman6> i don't really know what you're asking for
23:31:33 <ivanm> Axman6: problem with html IMHO is that you don't just have one file you can download, read etc. or print off
23:31:39 <ivanm> Axman6: yeah, that's my backup format
23:31:39 <mwotton> yay. flymake for haskell is sweet. now, if only i could get it properly working for lhs as well...
23:31:48 <Axman6> Apple web archives? :P'
23:32:42 <ivanm> Axman6: I'm writing a library to perform analysis of discrete data represented as a graph, which is then to produce a report on what it finds... a sample application I'll be writing using it is to analyse the structure of haskell code
23:34:09 <ivanm> (by "backup", I mean that's what I was originally thinking of)
23:35:29 <Olathe> > (1::t) + (2::t)
23:35:31 <lambdabot>       Could not deduce (Num t) from the context ()
23:35:31 <lambdabot>        arising from the li...
23:36:13 <Olathe> > let (a::t) = 1 in (1::t) + (2::t)
23:36:14 <lambdabot>   mueval: Prelude.read: no parse
23:41:21 <adu> i still don't understand monad transformers
23:43:41 <Cale> adu: They give you a somewhat convenient way to build up monads that you're interested in, from some starting monad.
23:44:26 <dons> http://www.reddit.com/r/programming/comments/73zma/arch_linux_haskell_590_haskell_packages_supported/
23:44:29 <lambdabot> Title: Arch Linux Haskell: 590 Haskell packages supported. QuickCheck 2 released. : pro ..., http://tinyurl.com/4ftxk5
23:44:31 <adu> maybe the problem is that I don't know enough monads
23:44:34 <dons> http://www.reddit.com/r/programming/comments/73zlz/all_2008_haskell_symposium_talks_on_video/
23:44:37 <lambdabot> Title: All 2008 Haskell Symposium talks, on video : programming, http://tinyurl.com/3lu2po
23:44:41 <Cale> adu: The important thing is that if you start with some monad M, and you apply your monad transformer T, then any M-action can be converted into a T M action.
23:44:47 <dons> someone released the videos. i was going to wait till monday for those.
23:44:47 <dons> oh well
23:45:08 <Cale> adu: Do you know the list monad?
23:45:14 <ivanm> dons: which version of haddock do you support on arch?
23:45:27 <dons> latest.
23:45:39 <ivanm> even though not all apps support haddock-2?
23:45:40 <Cale> adu: and State?
23:45:42 <adu> Cale: ya, [], IO, Maybe, State, GenParser ()
23:45:45 <Cale> okay
23:45:56 <adu> still working on Reader/Writer
23:45:58 <Cale> So let's have a look at the StateT monad transformer
23:46:13 <Cale> Recall that:
23:46:22 <Axman6> @src State sequence
23:46:22 <lambdabot> Source not found. There are some things that I just don't know.
23:46:23 <dons> ivanm: right.
23:46:39 <Cale> newtype State s a = State { runState :: s -> (s,a) } -- or similar
23:46:48 <adu> right
23:46:48 <Cale> and we had
23:46:54 <Cale> instance Monad (State s) where
23:47:02 <ivanm> dons: so what do you do with libraries where haddock-2 fails? user beware?
23:47:09 <Cale>   return x = State (\s -> (s,x))
23:47:44 <Cale>   x >>= f = State (\s -> let (s',v) = runState x s in runState (f v) s')
23:48:07 <Cale> So now let's look at the monad transformer version.
23:48:25 <dons> ivanm: we don't build the docs, we point them to the docs on hackage.
23:48:46 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (s,a) }
23:48:47 <ivanm> ahhhh, so you cheat! :p
23:48:58 <ivanm> dons: what about those libraries where hackage failed to build the docs?
23:49:23 <dons> there's no docs.
23:49:31 <Cale> So now, it's going to be that (StateT s m) is a monad, for any monad m
23:49:32 <ivanm> *nod*
23:49:37 <dons> i should emaill the authors, using hackage to do that.
23:50:10 <ivanm> dons: in some cases, it looks like it's hackage's fault (e.g. for the chart library, it needs gtk2hs which hackage doesn't have)
23:50:19 <dons> right
23:50:26 <Cale> The idea being that our (StateT s m) computation is a function from an initial state to an m-computation for computing a final state and a result.
23:50:51 <adu> Cale: ok, because the 'a' is missing its monad-ish... i can see that
23:51:00 <dons> btw guys, i really recommend hinze's functional pearl on streams
23:51:05 <dons> maybe the best pearl i've seen
23:51:55 <sjanssen> link?
23:52:14 <dons> on its way...
23:52:16 <Cale> Another way to think of that is that in the original State monad, we represented state computations as functions from initial states to (final state, result) pairs
23:52:40 <dons> http://galois.com/~dons/tmp/ICFP08.pdf (i got permission from hinze to releasE)
23:52:42 <lambdabot> Title: cache:http://galois.com/~dons/tmp/ICFP08.pdf - Google Search
23:52:42 <Cale> and now, we're representing them as "effectful functions" from initial states to (final state, result) pairs
23:52:52 <dons> someone should type up this code, and add it to lambdabot
23:53:00 <dons> the mapping of streams onto the naturals is amazing.
23:53:07 <dons> Cale, you'd love this paper.
23:53:33 <dons> everything's a one liner too, so fits in irc
23:53:46 <Cale> (in the same spirit as you can think of a function a -> IO b as an "effectful function" which computes a value of type b from a value of type a, but does some IO in the meantime)
23:53:51 <dons> he lifts streams into Num...
23:54:22 <adu> Cale: where are monad transformers used alot?
23:54:23 <FunctorSalad_> s -> m (s,a) or s -> (ms,ma) ?
23:54:32 <dons> so you can fib = 0 --> fib' ; fib' = 1 --> fib' + fib
23:54:34 <dons> its beautiful
23:55:13 <Cale> dons: I'll definitely check it out :)
23:55:21 <FunctorSalad_> @src StateT
23:55:22 <lambdabot> Source not found. :(
23:55:25 <FunctorSalad_> :(
23:55:43 <PeakerWork> Monad Transformers are such a bad name.  I think Haskell has a lot of "fancy sounding" names that don't imply a lot about what the actual thing is :)
23:56:28 <FunctorSalad_> yes "Monad Transformer" is slightly intimidating
23:56:29 <Cale> adu: Well, suppose you're designing a new library which is a monad. Sometimes you can use monad transformers to build up a "big" monad which has unrestricted effects of the sort that you'd like, and then (by not exporting everything) shape that down into a monad which has just the effects that you want.
23:56:44 <sjanssen> PeakerWork: what should they be called?
23:56:45 <dons> um, #haskell should drop some mods on this, http://www.reddit.com/r/programming/comments/73zlz/all_2008_haskell_symposium_talks_on_video/ since its our only video link atm to all the freaking videos.
23:56:47 <lambdabot> Title: All 2008 Haskell Symposium talks, on video : programming, http://tinyurl.com/3lu2po
23:56:59 <dons> i might rerelease the link on monady when people are actually around.
23:57:04 <Cale> I think "Monad Transformer" conveys exactly what monad transformers do.
23:57:10 <Cale> They transform monads into other monads.
23:57:13 <FunctorSalad_> sjanssen: warm fluffy converters?
23:57:16 <adu> Cale: right
23:57:29 <PeakerWork> sjanssen: Perhaps multi-monads, or monad-combiner
23:57:35 <adu> Cale: like does darcs use monad transformers? or parsec?
23:57:42 <PeakerWork> Cale: I think it implies how they do what they do, not what they do
23:57:51 <ozy`> PeakerWork: that's hardly a rare problem in programming languages... cf. C++, where every other new feature is "virtual"
23:57:55 <Cale> PeakerWork: I think it implies what they do.
23:58:00 <PeakerWork> Cale: as a user, monad transformers allow me to use multiple monads in the same code.. They do this by transformation, but that's implementation
23:58:08 <Cale> PeakerWork: What do they do besides transform monads into other monads?
23:58:14 <Cale> No, they don't :)
23:58:29 <Cale> This is a common misconception.
23:58:35 <FunctorSalad_> "multi-monads" sounds even more complex to me tbh
23:58:49 <Cale> Well, unless you mean that they let you lift computations in the old monad into the new one.
23:59:04 <Cale> In that sense, I agree with you.
23:59:08 <ivanm> in ghci, is there any option that lets you shrink the import line at the prompt?
23:59:45 <adu> Cale: but from what I've seen, you can just take code written in monad X and wrap it in OtherT and magically get it all to work, don't you need slight modifications to use both monads?
