00:13:57 <moosen> I was at the bookstore today and I found The Haskell School of Expression on the shelves and was wondering if that's a good book to start learning with.
00:14:53 <moosen> And so I though to seek opinions from y'all.
00:16:29 <moosen> What do you guys think about the book?
00:18:15 <quicksilver> moosen: the book is well respected.
00:18:21 <quicksilver> it is out of date, of course
00:18:38 <quicksilver> but that doesn't necessarily matter.
00:19:02 <moosen> Right now I'm trying to eat as many lambda calculus papers as I can understand, but that book seemed to focus more on the nuts and bolts of the language. At the same time, it would help for me to actually know haskell, I reckon, if I'm to experiment, and it touched on proofs by induction and other mathematical principles.
00:20:15 <moosen> quicksilver, would you recommend another book over it?
00:20:17 <quicksilver> yes. It is said to be a good book and the author is certainly very well respected.
00:20:31 <MarcWebe1> Can you use fundeps for instances only? (eg Class a where foo :: a, instance Class (A a -> A b) | a -> b ) ?
00:20:31 <quicksilver> You might also consider Hutton (Programming in Haskell, I think it's called)
00:20:40 <quicksilver> MarcWebe1: no.
00:21:34 <quicksilver> I suspect Hutton is more basic than SOE, but I'm not sure.
00:21:59 <quicksilver> moosen: http://www.haskell.org/haskellwiki/Books
00:22:05 <MarcWeber> quicksilver: quicksilver It would be useful to have ..
00:22:07 <paczesiowa> Prelude Main> :step main \n *** Exception: (unknown) is that debugger exception or code exception ?
00:22:11 <lambdabot> Title: Books - HaskellWiki
00:22:40 <quicksilver> MarcWeber: In some ways it would. I think it would destroy the universe though.
00:26:50 <mmorrow> paczesiowa:
00:26:51 <mmorrow> ghci> throwDyn ()
00:26:52 <mmorrow> *** Exception: (unknown)
00:27:05 <mmorrow> i dunno where it's coming from though...
00:28:07 <paczesiowa> mmorrow: I tried debugging gtk frontend for yi
00:28:35 <paczesiowa> mmorrow: but I get different exception then by launching yi
00:28:49 <mmorrow> ah geez, it's probably coming from deep withing the bowels of some ffi code..
00:29:16 <mmorrow> *within
00:29:53 <mmorrow> i haven't used gtk much, so i can't really be of any help :(
00:30:48 <paczesiowa> funnt thing is, my main fun from yi.hs has "yi $ defaultConfig { ...}" and it crashes, if I put "print 2 >>" before it, it crashes without printing, so looks like some really weird error:/
00:31:01 <MarcWeber> mmorrow Isn't there a way to use ghci to stop on errors? (debugging feature) which is used to find Prelude: empty head errors ?
00:31:40 <paczesiowa> I'm looking at debugger tutorial from monad.reader and it starts with :step main
00:31:46 <paczesiowa> and that doesn't work
00:32:49 <mmorrow> MarcWeber: there may very well be. My personal strategy is to never use head/anything that can fail unless it's blindingly obvious that that's impossible :)
00:33:01 <quicksilver> it wouldn't surprise me if ghci debugger can't cope with gtk.
00:33:06 <quicksilver> getting gtk to work in ghci isn't easy.
00:33:18 <quicksilver> I speak from ignorance though.
00:33:42 <Twey> Or maybe to use listToMaybe instead of head...
00:33:45 * mmorrow shudders at the thought of having to debug gtk ffi code
00:33:59 <mmorrow> paczesiowa: good luck
00:34:03 <Twey> Heh
00:34:40 <paczesiowa> they say that debugger can only inspect ghci object code
00:34:52 <paczesiowa> does cabal install that by default?
00:34:58 <quicksilver> No.
00:35:05 <quicksilver> that's what you get when you interpret some code
00:35:09 <quicksilver> not when you compile it.
00:35:15 <quicksilver> if I understand what you're saying correctly.
00:35:36 <paczesiowa> there is a flag for cabal "--enable-library-for-ghci"
00:35:41 <mmorrow> MarcWeber: someone had the nice idea (don't remember where i read about it) to use ghc {-# RULE ... #-} rewrite rules to rewrite all occurences of head/whatever to a version of the same that somehow signals where it is if it gets an empty list
00:35:47 <quicksilver> paczesiowa: I don't think that is even possible.
00:35:58 <quicksilver> paczesiowa: I don't think ghci bytecode ever gets written to disk.
00:36:02 <quicksilver> it's just stored in memory.
00:36:05 <paczesiowa> but I don't know what's thedefault, and I don't know how to reinstall
00:36:32 <mmorrow> MarcWeber: but that still wasn't able to give very good location info in the /best/ case ..
00:37:04 <paczesiowa> too bad that dcoutts is asleep
00:37:42 <moosen> Do you guys think that there is any benefit to learning the beginner's features of haskell using the helium interpreter?
00:38:09 <mmorrow> moosen: err, i would just get ghc and start messing around in ghci
00:38:19 <paczesiowa> moosen: yes
00:38:25 <paczesiowa> > 1 + True
00:38:28 <lambdabot>       No instance for (Num Bool)
00:38:28 <lambdabot>        arising from the literal `1' at <inte...
00:38:36 <mmorrow> at the very least, ghci's error messages will be better than most other's
00:38:42 <paczesiowa> serious wtf for beginners
00:38:55 <mmorrow> oh, helium is the teaching one, right?
00:38:59 <rwbarton> helium is specifically designed to have good error messages
00:39:15 <moosen> no type classes though
00:39:18 <mmorrow> ahh, ok. in that case it probably will be good.
00:40:16 <mmorrow> moosen: hmm, sounds like then it's a pretty restricted subset of haskell
00:41:46 <moosen> I don't really grok type classes yet
00:42:03 <mmorrow> i wonder how it does 'show'?
00:42:08 <mmorrow> > show 9
00:42:11 <lambdabot>   "9"
00:42:13 <mmorrow> > show [1,2]
00:42:16 <lambdabot>   "[1,2]"
00:42:19 <mmorrow> > show (Just "asdf")
00:42:21 <paczesiowa> how do I re/uninstall packages?
00:42:22 <lambdabot>   "Just \"asdf\""
00:42:32 <paczesiowa> besides rm -r .cabal
00:42:44 <mmorrow> sudo ghc-pkg unregister <exact-pkg-name-here>
00:43:22 <paczesiowa> what does it have to do with cabal?
00:43:34 <mmorrow> that doesn't delete it though, but unless i was /really/ low on disk space, i'd just leave it be
00:43:45 <moosen> > show (let f n = n where n = "error")
00:43:48 <lambdabot>   mueval: Prelude.read: no parse
00:43:59 <mmorrow> paczesiowa: ghc-pkg is cabal-related
00:44:04 <moosen> hm
00:44:06 <quicksilver> paczesiowa: cabal is a tool for building packages, which happens to include some tools to install them.
00:44:07 <mmorrow> hmm
00:44:14 <quicksilver> paczesiowa: however the package database does not belong to ghc.
00:44:15 <mmorrow> oh
00:44:19 <quicksilver> paczesiowa: duh
00:44:25 <quicksilver> does not belong to CABAL
00:44:26 <quicksilver> sorry
00:44:27 <mmorrow> moosen: i think it was the where
00:44:30 <quicksilver> it bleongs to GHC :)
00:44:33 <cjs> It's weird that type classes seem to be a difficult concept for many. I found them much simpler than many other things in Haskell.
00:44:40 <paczesiowa> I want to reinstall yi with that ghci flag, but cabal does nothing since it is already installed
00:44:53 <quicksilver> moosen: let needs an in
00:44:54 <moosen> mmorrow, wanted to see what show does with an expression that's wrong
00:44:54 <cjs> It's really just properly typed "duck typing."
00:45:00 <mmorrow> moosen: err, actually that wasn't an exp
00:45:04 <cjs> s/properly typed/typechecked/
00:45:05 <quicksilver> > show (let f n = n where n = "error" in 1)
00:45:09 <lambdabot>   "1"
00:45:31 <mmorrow> > 3945(((
00:45:33 <lambdabot>   mueval: Prelude.read: no parse
00:45:33 <quicksilver> paczesiowa: run Setup.hs configure again yourself.
00:45:51 <moosen> hm
00:45:58 <moosen> must study more
00:46:09 <mmorrow> > show ()
00:46:12 <lambdabot>   "()"
00:46:39 <mmorrow> > read (show [(0::Int)..9]) :: [Double]
00:46:43 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0]
00:46:46 <Twey> > show undefined
00:46:50 <lambdabot>   mueval: Prelude.read: no parse
00:46:50 <lambdabot>  mueval: "*** Exception: Prelude.undefined
00:47:20 <newsham> > show (fix id :: Int)
00:47:24 <lambdabot>   mueval: Prelude.read: no parse
00:47:24 <lambdabot>  mueval: "*** Exception: stack overflow
00:47:27 <mmorrow> heh
00:47:59 <mmorrow> > show (typeOf(undefined::Int))
00:48:03 <lambdabot>   "Int"
00:48:20 <mmorrow> > show (typeOf(undefined::a))
00:48:23 <lambdabot>   Add a type signature
00:48:33 <mmorrow> > typeOf(undefined::a)
00:48:36 <lambdabot>   Add a type signature
00:49:34 <quicksilver> > let intToDouble :: Int -> Double; intToDouble = read.show in intToDouble 3
00:49:38 <lambdabot>   3.0
00:49:47 <quicksilver> a super-inefficient fromIntegral! woot!
00:50:20 <moosen> has haskell been used much for symbolic math and theorem proving?
00:50:49 <dons> moosen: yeah. particularly the latter
00:51:14 <dons> moosen: http://haskell.org/haskellwiki/Applications_and_libraries/Theorem_provers
00:51:16 <lambdabot> Title: Applications and libraries/Theorem provers - HaskellWiki, http://tinyurl.com/6zhnxu
00:51:17 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Hardware_verification
00:51:19 <lambdabot> Title: Applications and libraries/Hardware verification - HaskellWiki, http://tinyurl.com/62kg6c
00:51:24 <Twey> quicksilver: I think it's considered good style to put spaces around the '.' for composition.
00:51:45 <dons> moosen: i work at a company that relies on haskell+theorem proving, too, fwiw
00:51:46 <Twey> foo.bar reads to me as module lookup.
00:51:51 <quicksilver> Twey: Maybe. I Just "don't care". :P
00:51:57 <paczesiowa> damn, reinstalled yi and still the same exceptions
00:52:03 <moosen> those are such wonderful subjects
01:11:21 <BeelsebobWork> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc <-- how come someone submitted a threadring using -N4?
01:11:23 <lambdabot> Title: Haskell GHC benchmarks | x64 Ubuntu : Intel® Q6600® quad-core Computer Languag ..., http://tinyurl.com/5ku9zc
01:11:28 <BeelsebobWork> it was *way* faster using -N1
01:12:56 * quicksilver doesn't know.
01:13:11 <quicksilver> BeelsebobWork: my reactive implementation has working Event, Reactive, mappend and snapshotR. Yay :)
01:13:20 <BeelsebobWork> quicksilver: awesome :D
01:13:30 <quicksilver> BeelsebobWork: and Event Char (connceted to 'getChar') and Event () (a timer)
01:13:35 <BeelsebobWork> sounds like you're making the most progress of all the people who tried implementing it again
01:13:56 <quicksilver> just need to do some interesting examples of Behaviour.
01:14:18 <BeelsebobWork> :) shiny
01:14:24 <quicksilver> BeelsebobWork: I intend to email it to conal, I'll CC you if you tell me your email address. Unless there is a mailing list for FRP?
01:14:41 <BeelsebobWork> I don't think there is one yet -- although it was being discussed
01:14:53 <BeelsebobWork> so yeh, CCing tom.davie@gmail.com would be good
01:16:39 <quicksilver> noted. thanks :)
01:17:54 <quicksilver> BeelsebobWork: what I now understand is unsatisfactory is that, although I implement Event using Future, my mappend for Event 'cheats'.
01:17:55 <BeelsebobWork> hmm, *ponders who to ask about the threadring program getting slowed down so much*
01:18:01 <BeelsebobWork> oh?
01:18:03 <quicksilver> it uses the internals of Future itself.
01:18:09 <BeelsebobWork> oh, fail
01:18:12 <quicksilver> it woudl obviously be more elegant to treat Future as a black box
01:18:16 <quicksilver> with appropriate combinators.
01:18:25 <BeelsebobWork> is your interface to future different then?
01:18:42 <quicksilver> my interface to future consists of two functions :)
01:18:55 <quicksilver> blockingReadFuture :: Future a -> IO a
01:19:08 <quicksilver> and buildFuture :: IO a -> IO (Future a)
01:19:21 <BeelsebobWork> ah, I see
01:19:33 <quicksilver> I don't think that's enough to implement mappend elegantly.
01:19:47 <BeelsebobWork> hmm, I wonder if the condition that it's failing on is "cooperative threads… and other programs with custom schedulers will be listed as interesting alternative implementations"
01:19:55 <quicksilver> in particular, the Future which 'mappend' constructs is not one using 'buildFuture'
01:20:08 <quicksilver> (and it can't be, because mappend is *outside* IO, while buildFuture is inside IO)
01:20:14 <BeelsebobWork> ah, I see
01:20:25 <BeelsebobWork> yep, makes sense
01:20:31 <quicksilver> so basically my Future only has one constructor and that's hidden in IO.
01:20:42 <BeelsebobWork> so is it impossible for your Event mappend to block then?
01:20:45 <quicksilver> the semantics of buildFuture is "take this IO action and make a future which calls it only once"
01:21:05 <quicksilver> BeelsebobWork: my mappend can block, but it cheats by using Future internals.
01:21:10 <BeelsebobWork> oh
01:21:19 <BeelsebobWork> so do you gain anything by using IO in future then?
01:21:31 <BeelsebobWork> in that wasn't the reasoning for that that it highlighted when you could block?
01:21:36 <quicksilver> well, it's the right type :)
01:21:49 <quicksilver> I mean, it's a bit fiddly to explain.
01:21:55 <quicksilver> Futures and Events aren't in IO, of course.
01:22:05 <quicksilver> but you can only observe them from a harness which lives in IO
01:22:18 <quicksilver> so it's not really a problem if their internals use IO, as long as that is hidden internally.
01:22:28 <BeelsebobWork> hmm
01:24:06 <quicksilver> basically I haven't had to expicitly implement 'merge'
01:24:17 <quicksilver> which is the basis of conal's Monoid impl.
01:24:31 <quicksilver> however, 'merge' is probably the correct primitive and I probably should implement it :)
01:24:52 <quicksilver> nonetheless, I will show you both my current implementation out of interest, before I fiddle.
01:24:54 <BeelsebobWork> hmm, yeh
01:24:56 <quicksilver> this one does appear to work.
01:25:01 <BeelsebobWork> :)
01:25:12 <quicksilver> (and involves no unsafePerformIO)
01:53:26 <Xenoblitz> hi people
01:53:44 <Axman6> o/
01:54:04 <Xenoblitz> wanted to ask a quick question to anyone who is willing to answer
01:54:46 <Axman6> rule #1 or IRC: don't ask to ask, just ask
01:55:12 <Xenoblitz> hehe thanks :)
01:55:45 <Xenoblitz> i have this function moveWellDown :: Brick -> State Well ()
01:55:55 <Xenoblitz> and i want to call it with runState
01:55:58 <Xenoblitz> is it possible?
01:56:20 <Twey> Yep, Xenoblitz
01:56:40 <Xenoblitz> Twey: how does one pass the Brick parameter?
01:56:40 <Twey> runState (moveWellDown someBrick) someWell
01:56:48 <Xenoblitz> OUCH
01:56:52 <Xenoblitz> ok thanks twey
01:56:54 <Twey> Remember, currying
01:57:07 <Xenoblitz> yes
01:57:10 <Twey> moveWellDown someBrick returns a 'function' of type :: State Well ()
01:57:11 <opqdonut> :D
01:57:15 <opqdonut> great example
01:57:18 * Twey nods.
01:57:34 <Xenoblitz> thanks... this channels has been helpful than most books :)
01:57:39 <Twey> Heh
01:57:40 <Xenoblitz> i mean these are things you don't find in books
01:57:46 <Xenoblitz> *channel
01:57:59 <Twey> Have you tried RealWorldHaskell, on the subject of books?
01:58:08 <Xenoblitz> i have read the beta of it
01:58:12 * Twey nods.
01:58:18 <Xenoblitz> its good
01:58:24 <Twey> Well, the aim of that book was to try to provide that sort of thing :)
01:58:29 <Xenoblitz> not a style i like but on the whole i think i'll buy it later on
01:58:39 <Xenoblitz> could be just me
01:58:43 <Twey> Principles of use rather than the bare rules from which one can derive them
01:58:44 <Xenoblitz> i was rushing
01:58:45 <Twey> Must be :-P
01:58:47 <Xenoblitz> to start working on my project
01:58:55 <Twey> 'kay :)
01:58:57 <Xenoblitz> yes could be
01:58:59 <Xenoblitz> no i liked it
01:59:03 <Xenoblitz> at one point i was refering to it
01:59:04 <Xenoblitz> all the time
01:59:18 <Xenoblitz> hehe
01:59:20 <Twey> Heh
01:59:27 <Xenoblitz> 99% i'll buy it cause it seems a good book
01:59:31 <Xenoblitz> :P
01:59:33 <xsdnyd> hi
01:59:36 <Xenoblitz> not 100% cause i'm broke xD
01:59:36 <mapreduce> I like the Haskell wikibook, though it gets a bit ropey halfway through.
01:59:37 <Xenoblitz> lol
02:00:06 <Xenoblitz> when is the book out Twey?
02:00:08 * Wild_Cat plans to buy RWH as soon as amazon.fr starts shipping it.
02:00:55 <Xenoblitz> anyways i will check the website later ;)
02:00:59 <Xenoblitz> thanks again guys
02:01:51 <xsdnyd> what is the most elegant way to realise an associative array? i want to have such a thing as [(String, String)].
02:01:51 <xsdnyd> my should output the second string of the pair when the input is the first pair. Like this get::String -> String.
02:02:25 <Wild_Cat> xsdnyd: have a look at Data.Map
02:02:53 <mmorrow> too bad it's not imported currently in lambdabot
02:02:53 <mmorrow> cough
02:03:17 <xsdnyd> Wild_Cat: ok will do. can i specify the map as a constant function? like myMap :: Map String String
02:03:27 <xsdnyd> but how do i specify the contents...
02:03:42 <xsdnyd> without the use of an insert function or something. it should be a constant map.
02:04:13 <mmorrow> > let xs = zip [0..] ['a'..'z'] in xs
02:04:16 <Wild_Cat> :t Data.Map.fromList
02:04:17 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i'),(9...
02:04:22 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
02:04:35 <xsdnyd> ah cool thx
02:04:47 <pjdelport> myMap "foo" = "bar"; myMap "frob" = "quux"
02:04:49 <Wild_Cat> > Data.Map.fromList [(1, 2), (2, 3)]
02:04:52 <lambdabot>   mueval: Prelude.read: no parse
02:05:34 <mmorrow> > let xs = zip [0..] ['a'..'z'] ; f i = maybe [] (:[]) (lookup i xs) in [f 9232, f 12, f 1]
02:05:39 <lambdabot>   ["","m","b"]
02:06:04 <Twey> Xenoblitz: Mid-November, I believe
02:06:07 <Twey> You can pre-order it
02:06:38 <Xenoblitz> Twey: cool, thanks :)
02:07:14 <Twey> No problem :)
02:07:26 <sjanssen> interesting idea of the moment: use TH to generate an ideal lookup function at compile time
02:09:15 <mmorrow> sjanssen: hmm. what do you mean by "ideal"?
02:09:37 <sjanssen> mmorrow: there are a variety of things to optimize for, of course
02:10:29 <sjanssen> I was specifically thinking about String lookup -- there you would generate a trie-like structure of 'case' statements
02:11:15 <MarcWeber> sjanssen: What information do you want to use?
02:11:42 <mmorrow> sjanssen: oh cool, totally. in a rough sense (or not so rough depending..) a TH happy.
02:12:08 <sjanssen> mmorrow: right, but I'm not nearly so ambitious
02:12:12 <mmorrow> heh
02:12:28 <MarcWeber> Map.fromList $ map (\a -> (a,a)) ['a'..'z'] from example can only be optimized if you know that you'll ask for the value of key n 99 % of cases and you'll aske for the others in 1 % of all cases
02:12:56 <sjanssen> MarcWeber: it can be optimized in other ways
02:13:15 <sjanssen> it wouldn't give a O reduction in time, but I imagine there are some gains to using functions rather than data
02:14:07 <mmorrow> \s -> case s of '-':s -> case s of {'h' -> help ; 'v' -> version} ; _ -> usage
02:14:17 <MarcWeber> sjanssen: Then your map has to be known at copmile time as well?
02:14:56 <sjanssen> MarcWeber: right, I'm specifically thinking about maps known at compile time
02:15:06 <sjanssen> though we can generate functions at run time as well...
02:15:08 <MarcWeber> I guess bechpress can help us figuring that out?
02:15:28 <MarcWeber> sjanssen: Which use case do you have in mind?
02:15:33 <mmorrow> heh
02:15:38 <mmorrow> case ...
02:16:00 <MarcWeber> sjanssen: Can you  specify a small example so that we can try the difference using bechpress ?
02:16:35 <sjanssen> MarcWeber: I don't really have an example in mind
02:17:03 <mmorrow> MarcWeber: say you want to parse command line options, then you could just take a list of strings and generate a case tree that determines the string optimally
02:17:22 <mmorrow> or s/opts/whatever/
02:17:37 <sjanssen> command line options don't really need the speed, I would imagine
02:17:47 <MarcWeber> Mmh that's done once. And that will not take much time compared to starting up the application etc anyway.
02:17:58 <mmorrow> yeah, heh, i realized that was a weak example half-way through... :)
02:18:12 <mmorrow> but image a parser for some language
02:18:35 <mmorrow> ReadP without the runtime overhead of interpreting anything
02:19:22 <mmorrow> s/image/imagine/
02:20:26 <mmorrow> i recall a paper that described using template-haskell for optimizing image filter code at compile time
02:22:16 <dcoutts> mmorrow: pantheon or some name like that, a 'th' version of the original 'pan'
02:23:07 <mmorrow> dcoutts: yeah, that's exactly it
02:26:17 <mmorrow> this one's really good: http://www.haskell.org/th/papers/Unrolling_and_Simplifying_Expressions_with_Template_Haskell.ps
02:27:13 <lambdabot> http://tinyurl.com/6kxwpb
02:27:14 <mmorrow> here's the pantheon one: http://www.haskell.org/th/papers/th-pan.ps
02:27:44 <mmorrow> i don't know why i'm not just linking to the page i'm looking at: http://www.haskell.org/th/papers.html
02:27:46 <lambdabot> Title: Template Haskell papers
02:31:29 <thatsright> > 2
02:31:32 <lambdabot>   2
02:32:02 <BeelsebobWork> > 3
02:32:05 <thatsright> > parse (manyTill (anyChar) (char '{')) "" " fgdfg{content} fsf"
02:32:06 <lambdabot>   3
02:32:08 <lambdabot>  Terminated
02:32:10 <BeelsebobWork> > 4
02:32:14 <lambdabot>   4
02:32:15 <BeelsebobWork> it's gotta break some time
02:32:19 <BeelsebobWork> surely it can't get 5 right
02:32:22 <BeelsebobWork> > 5
02:32:27 <lambdabot>   5
02:32:29 <BeelsebobWork> :(
02:33:03 <thatsright> Beelsebob, ironically it was ol' parsec
02:33:48 <MarcWeber> mmorrow: sjanssen  http://rafb.net/p/mvfEbQ71.html Something like this?
02:33:49 <lambdabot> Title: Nopaste - No description
02:34:56 <mapreduce> > let 2 = 3 in 2
02:34:59 <lambdabot>   2
02:35:36 <mapreduce> > let 2 = 3 in 2 + 2
02:35:39 <lambdabot>   4
02:36:02 <EvilTerran> in "let 2 = 3", 2 is a constructor, not a variable
02:36:14 <EvilTerran> > case 3 of ~2 -> 2 + 2-- equivalent
02:36:18 <lambdabot>   4
02:39:38 <cjs> Hm. Linking is very slow compared to compiling. Compiling 35 modules with --make and -O1 takes about .25s, linking one program that uses those takes 1.5s.
02:39:45 <cjs> I wonder how I can reduce that link cost?
02:39:59 <BeelsebobWork> cjs: I've noticed that on some platforms but not on others
02:40:02 <Twey> Who cares?  :-P
02:40:08 <BeelsebobWork> e.g. on OS X linking appears to be much faster than compiling
02:40:20 <Twey> Build time is pretty unimportant in my book...
02:40:23 <cjs> Really!
02:40:50 <cjs> It is for me, since I run tests very frequently (several times a minute).
02:41:02 <Twey> Hmm
02:41:20 <Twey> Also, your build speeds are already insane
02:41:27 <cjs> The issue is, of course, that my build system is currently relinking six different programs, even when they don't need relinking, making me sit around for ten seconds before my tests run.
02:41:32 <Twey> 35 modules in under two seconds?  What?
02:41:44 <cjs> Oh, wait, that's with --make and no unmodified modules. :-)
02:41:50 <cjs> But usually there's not a lot modified.
02:42:15 <cjs> Obviously, some sort of dependency checking to see if a binary needs to be relinked would help. It appears that --make doesn't do that.
02:43:12 <Twey> Oh, right.
02:43:20 * Twey nods.
02:44:38 <cjs> Oh, -static is the default, apparently.
02:45:01 <cjs> Ok, I can build those 35 modules in 10 seconds from clean.
02:45:12 <cjs> Not bad. It's a good 3000 lines of code, too.
02:45:32 <sjanssen> cjs: are your tests CPU intensive?
02:45:37 <cjs> No, not really.
02:45:45 <sjanssen> I'd just use 'runghc' then
02:45:57 <mmorrow> MarcWeber: i'm thinking essentially that, but replace the Map by case statements...so essentially turning the tree that represents the map into a tree of syntax representing case statements
02:46:21 <mmorrow> "automated hardcoding"
02:46:32 <cjs> Hm. That could work well, especially since my runghc wrapper uses compiled versions when available.
02:46:41 <mmorrow> (but for strings a tree would be better than a Map)
02:46:41 <cjs> I'm already using ghci for a lot of my unit testing.
02:46:43 <MarcWeber> mmorrow. The second function match l "foo" = "foo" should be pretty similar to a case statement
02:46:45 <mmorrow> s/tree/trie/
02:46:49 <sjanssen> cjs: doesn't runghc already do that?
02:47:16 <cjs> sjanssen: Well, my wrapper sets up the build paths appropriately. I use a separate build dir for the .o files and all.
02:47:32 <sjanssen> MarcWeber: but who knows what code GHC generates for: case x of "asdf" -> foo
02:47:32 <mmorrow> MarcWeber: where is this match function?
02:47:36 <cjs> However, no, runghc is not particularly fast, either.
02:47:56 <mmorrow> MarcWeber: errr, n/m i got it
02:48:12 <thatsright> can someone help me convert this simple regex to parsec? http://codepad.org/T33Gxo4a
02:49:36 <cjs> A full set of tests (unit and functional) takes about 22s. But the functional tests are almost nothing; it's mostly runghc running 18 different sets of unit tests in different files.
02:49:45 <MarcWeber> mmorrow: But I'm not even sure I've complied with -O or such.. So take those results with care.
02:50:01 <cjs> I think runghc's startup time is killing me there, and I don't see any obvious solution.
02:50:16 <mmorrow> MarcWeber: cool
02:50:18 <cjs> Well, I'd love to run all my unit tests from one compiled binary, but then I'd need to export them from the modules, wouldn't I?
02:50:37 <mmorrow> MarcWeber: ahh, i just realized where you got those stats from
02:51:00 <MarcWeber> mmorrow: I've said benchpress would be a nice tool for this lines ago
02:51:27 <mmorrow> MarcWeber: i just didn't realize that that's where those numbers came from
02:52:08 <sjanssen> oh, interesting
02:52:22 <sjanssen> erm, nevermind
02:53:02 <cjs> Grr. "PIC not defined for this platform".
02:53:08 <cjs> No dynamic linking for NetBSD.
02:57:02 <sjanssen> MarcWeber: your 'func' method is particularly bad if strings have long common prefixes
02:57:53 <sjanssen> MarcWeber: http://hpaste.org/10116
02:59:23 <MarcWeber> sjanssen It should have been a small template  to make you fill in your particular case.. You could'nt tell me about a real use case before
02:59:52 <sjanssen> there isn't actually a real use case
03:00:10 <thatsright> does anyone know what the perl regexp /a(.*)a/ is in parsec?
03:00:50 <MarcWeber> token "a" >> many (anyToken) >> token "a" or such @ thatsright
03:01:01 <sjanssen> thatsright: char 'a' >> many anyChar >> char 'a'
03:01:20 <MarcWeber> >> many (anyTaken) >>= \r -> token "a" >> return r
03:01:43 <thatsright> i was considering that a regex can grab that from anywhere inside the line
03:02:18 <sjanssen> thatsright: perhaps regexps are the best thing for your application?
03:02:19 <cjs> Hm. -main-is is not just a linker option. What changes in the .hi and/or .o files when I compile with that?
03:02:25 <MarcWeber> thatsright: (try thelastFunc) <|> (anyChar >> thelastFunc)
03:05:22 <cjs> It seems not to be just an export thing; even if I export main, it won't link if I've compiled Foo.hs without -main-is Foo and try to link with -main-is Foo.
03:22:31 <xsdnyd> hi
03:23:49 <quicksilver> sjanssen: that won't backtrac the anyChar so it will never see the final 'a'.
03:24:49 <xsdnyd> i have a function which uses "do". the function should return an IO (). so far so good. now i have a list of Strings. and a function which processes each string and returns an IO (). the function signature looks like this: process :: String -> IO (). now i want to apply this function to the whole list. therefore i use: map (process) list. but haskell complains because in the do function i can only call function which return IO and not [IO]. i 
03:25:06 <Botje> correct.
03:25:14 <Botje> look at the sequence function
03:25:16 <Botje> :t sequence
03:25:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:25:27 <Botje> it takes your [IO ()] and turns it into IO [()]
03:25:36 <xsdnyd> that is cool!
03:25:37 <Botje> of course you can combine map and sequence:
03:25:40 <Botje> :t mapM_
03:25:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
03:25:44 <Botje> which is what you want, i believe
03:25:48 <xsdnyd> yeap exactly
03:25:56 <xsdnyd> thank you very much
03:26:15 <Botje> np, have fun :)
03:27:51 <thatsright> this is the best i could come up with manyTill (anyChar) (char '{') >> manyTill (anyChar) (char '}')
03:28:48 <quicksilver> that doesn't sound right.
03:29:14 <quicksilver> isn't it just
03:29:27 <quicksilver> char '{' >> manyTill anyChar (char '}') ?
03:29:44 <quicksilver> although there is also between
03:30:10 <quicksilver> between (char '{') (char '}') (many anyChar)
03:30:23 <quicksilver> ^^ but I don't know if that works to be honest.
03:30:44 <Botje> the trick is to not use anychar :)
03:30:59 <Botje> btu rather something that doesn't match { or }
03:31:46 <EvilTerran> noneOf "{}"
03:31:47 <quicksilver> Botje: well that's the point of manyTill
03:31:49 <quicksilver> Botje: surely?
03:31:55 <quicksilver> (that you don't need to do that)
03:31:58 <EvilTerran> instead of anyChar
03:32:09 <Botje> uh, why yes :)
03:32:10 <Botje> woops
03:32:36 <quicksilver> although I strongly suspect that thatsright is going to want to nest things in a moment.
03:32:59 <EvilTerran> i find parsec's semantics get a lot less confusing if you try to never rely on the asymmmetry of <|>
03:33:13 <EvilTerran> then you don't need try anywhere near as often, either
03:34:12 <quicksilver> replace <|> with a <||> b = try a <|> b ?
03:39:14 <EvilTerran> sure, if you don't mind throwing performance out the window
03:39:44 <quicksilver> I don't.
03:39:51 <quicksilver> I've never had a parser be a bottleneck.
03:40:02 <quicksilver> Maybe one day I will, and then I'll solve the problem a different way :)
03:41:15 * Saizan_ has done a lot of exercises on manually converting a grammar to LL(1)
03:43:24 <quicksilver> Saizan_: I wrote a sort-of combinator parser in lua which let you express a grammar as BNF and factored out left recursion automtically, and collected unique prefix information.
03:43:38 <quicksilver> Saizan_: although it wasn't complete. It only worked on the grammar I wanted it to work on (the lua grammar, in fact)
03:43:52 <quicksilver> it was a fun/painful exercise, variously.
03:46:58 <Saizan_> yeah, same feeling here :)
03:47:44 <Beelsebob> quicksilver: it does happen
03:48:04 <quicksilver> Saizan_: basically I read the algorithms for eliminating left recursion in the dragon book, and I thought "WTF? This book expects me to implement an algorithm by hand? Isn't that what computers are for?"
03:48:16 <Beelsebob> e.g. my obj model loader spent about 99% of it's time in the parser
03:48:23 <quicksilver> Beelsebob: Sure. Lots of things happen. I'm not going to spend time worrying about the ones that don't happen to me.
03:48:33 <quicksilver> (a.k.a. premature optimisation)
03:48:41 <Beelsebob> yep, true true
03:48:46 <Botje> Beelsebob: that could just mean your application is hyper-efficient ;)
03:48:46 <mmorrow> sjanssen, MarcWeber: http://hpaste.org/10116#a1
03:49:00 <Beelsebob> Botje: no, it meant the parser was hype-inefficient :P
03:49:05 <quicksilver> I'm sure my obj loader spends 99% of its time in the parser. It *is* mainly just a parser. On the other hand, it loads my models in milliseconds, and that's fine.
03:49:21 <Beelsebob> quicksilver: yeh, it didn't
03:49:25 <quicksilver> if I had to load 1 million models and it was then too slow, I'd take another look ;)
03:49:55 <Beelsebob> it was more that it took about 30 seconds for models with about 1,000,000 polys
03:53:21 <quicksilver> Heh. I don't have any 1M poly models :)
03:55:18 <xsdnyd> hi, i have a datatype: data My = A | B | C (Maybe Bool). now i want to check wether a variable is C. regardless if the Maybe Bool ist Just True or Nothing or something like that.
03:55:51 <xsdnyd> how can i check if it is C?
03:56:00 <xsdnyd> var == C (_) doesn't work obviously
03:56:15 <xsdnyd> case var of Proved (_) -> True?
03:56:19 <Saizan_> isC (C _) = True; isC _ = False
03:56:38 <conal> quicksilver: i'm thinking about event semantics and about removing my ordering assumption for simultaneous occurrences.  Besides scanlE for non-commutative functions, there's the more basic problem of stepper (or switcher).  I don't know how to choose which of two simultaneous values to change.  Any ideas?
03:57:05 <Saizan_> xsdnyd: or that, yeah, if C = Proved, and you don't need the parens around _
03:57:28 <xsdnyd> Saizan_: ok cool. thx
03:58:14 <conal> quicksilver: on the up side, the model of E = Set :. (,) T does lead to the desired meanings for Monoid, Functor and Applicative.  Probably Monad also.
03:58:47 <conal> quicksilver: or s/Set/Bag
03:58:57 <thatsright> what is parsec for   not (char 'a')
03:58:59 <thatsright> anychar but (char 'a')
03:59:33 <thatsright> is there an easy haskell way to evaluate "1 + 2 * 3" from its string form?
04:00:14 <mmorrow> satisfy (not . (=='c'))
04:00:35 <conal> thatsright: perhaps http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
04:00:36 <lambdabot> Title: HackageDB: mueval-0.6.4
04:00:48 <quicksilver> conal: Well if you remove the ordering criterion it can only be non-deterministic.
04:01:00 <quicksilver> conal: so you have to decide if that's a semantics you're prepared to live with.
04:01:02 <mmorrow> > 1 + 2 * 3
04:01:05 <lambdabot>   7
04:01:08 <mmorrow> > 1 + 2 * 3(((
04:01:11 <lambdabot>   mueval: Prelude.read: no parse
04:02:37 <conal> quicksilver: it's easy to see the nondeterministic interpretation.  i'm not sure it's the only one.
04:02:49 <quicksilver> conal: alternatively you can say that "Event :. Set" is a monad, but "Event" alone isn't.
04:03:10 <quicksilver> join :: (Event (Set (Event (Set))) -> Event Set
04:03:11 <quicksilver> is fine.
04:03:19 <quicksilver> Set/Bag if you prefer.
04:03:23 <lilac> @@ @run @run say (fix ('(':) ++ fix (')':))
04:03:30 <lambdabot>   mueval: Prelude.read: no parse
04:04:01 <conal> quicksilver: how would Event :. Set help?
04:04:17 <conal> quicksilver: and under what interpretation of Event?
04:04:54 <quicksilver> well I'm saying that arbitrary a-valued Events fail to be a monad
04:04:57 <quicksilver> as discussed yesterday
04:05:05 <quicksilver> but (Bag a)-valued Events are a monad.
04:05:14 <quicksilver> so Event :. Bag is a monad even if Event is not.
04:06:05 <conal> quicksilver: what makes you think Bag/Set helps?
04:06:36 <quicksilver> because then you don't need to choose an order.
04:06:48 <quicksilver> the join would concatenate all the Bags
04:06:51 <Olathe> @@ @run @run say "(fix ('(':) ++ fix (')':))"
04:06:57 <lambdabot>   "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
04:08:16 <Olathe> @. run run sayFunc [5,7,9,11,13]
04:08:22 <lambdabot>   [5,7,9,11,13]
04:08:30 <opqdonut> sayFunc?
04:08:38 <EvilTerran> ?type sayFunc
04:08:39 <Olathe> > sayFunc [5,7,9,11,13]
04:08:41 <lambdabot> [Int] -> Expr
04:08:43 <lambdabot>   map (\x -> 2*x + 5) [0..4]
04:08:54 <mmorrow> @type sayFunc
04:08:57 <lambdabot> [Int] -> Expr
04:08:58 <Olathe> It gets the polynomial that makes that list.
04:09:04 <EvilTerran> interesting
04:09:14 <mmorrow> @. run run say "asdfg"
04:09:19 <lambdabot>   mueval: Prelude.read: no parse
04:09:25 <EvilTerran> i'd be inclined to make it Num a => [Int] -> a -> a
04:09:26 <opqdonut> heh, nice
04:09:32 <mmorrow> @@ @run @run say "1"
04:09:39 <lambdabot>   1
04:09:40 <EvilTerran> you could get a similar result by passing in "x", then
04:09:42 <conal> quicksilver: thx.  i see what you mean.
04:09:47 <EvilTerran> (or anything else Expr)
04:10:04 <Olathe> Hmm...
04:10:23 <Olathe> That's a decent idea.
04:10:44 <mmorrow> @@ @run @run say "@@ @run @run say \"1\""
04:10:50 <lambdabot>   mueval: Prelude.read: no parse
04:10:57 <mmorrow> ah
04:10:58 <quicksilver> conal: I'm not entirely convinced by my own argument, by the way :)
04:11:06 <quicksilver> conal: none of the solutions seems entirely elegant.
04:11:15 <Saizan_> it's not like say is doing anything special..
04:11:30 <mmorrow> i'm trying to figure out how this syntax works
04:11:34 <mmorrow> i think i just did
04:11:53 <conal> quicksilver: i don't imagine the Event :. Set solution would be useful with the other combinators, e.g., switcher/stepper.
04:11:54 <Axman6> > sayFunc [1,4,9,16]
04:11:57 <lambdabot>   map (\x -> x^2 + 2*x + 1) [0..3]
04:12:08 <Axman6> heh
04:12:26 <Axman6> > sayFunc [1,4,9,16,25,36]
04:12:30 <lambdabot>   map (\x -> x^2 + 2*x + 1) [0..5]
04:12:48 <Axman6> > sayFunc [0,1,4,9,16,25,36]
04:12:52 <lambdabot>   map (\x -> x^2) [0..6]
04:12:58 <quicksilver> conal: No. It was more of an observation than a solution.
04:13:06 <Axman6> ok, that's pretty damn cool
04:13:31 <conal> quicksilver: that's what took me a while to get.
04:13:50 <quicksilver> conal: sorry :(
04:14:10 <conal> quicksilver: np.  i don't mind my own confusion.
04:14:13 <Axman6> > sayFunc [0,0,2,6,12,20,30,42,56,72]
04:14:16 <lambdabot>   map (\x -> x^2 + (-1)*x) [0..9]
04:14:40 <Axman6> > sayFunc [2,0,0,2,6,12,20,30,42,56]
04:14:43 <lambdabot>   map (\x -> x^2 + (-3)*x + 2) [0..9]
04:14:43 <quicksilver> conal: I'm not sure how much I like 'switcher' as a basic combinator.
04:14:48 <quicksilver> conal: I think I prefer 'snapshot'
04:14:55 <mapreduce> > sayFunc [2,0,0,8,0,9,0,4]
04:14:58 <lambdabot>   map (\x -> (471*x^7 + (-11375)*x^6 + 108339*x^5 + (-515165)*x^4 + 1269534*x...
04:15:06 <Axman6> heh
04:15:10 <conal> quicksilver: they serve pretty different purposes, don't they?
04:15:27 <mmorrow> > say [greek 10]
04:15:29 <quicksilver> conal: well, yes.
04:15:31 <lambdabot>   λ
04:15:38 <conal> quicksilver: (in that switcher makes a behavior (or reactive), while snapshot makes an event.)
04:15:39 <Axman6> > sayFunc [0,0,0,0,7,0,0,0]
04:15:39 <mapreduce> Where do I get sayFunc?
04:15:43 <lambdabot>  Terminated
04:15:44 <quicksilver> conal: but I think you can build Reactives (and thus Behaviours) with stepper
04:15:52 <Olathe> mapreduce: That's such an awesome polynomial, I'd call it the polynomial of the day !
04:15:53 <quicksilver> conal: build Events with snapshot
04:15:59 <quicksilver> conal: and combine them with <*>
04:16:00 <Olathe> One sec.
04:16:06 <quicksilver> conal: and I think that's all you need isn't it?
04:16:41 <mapreduce> > length $ sayFunc [2,0,0,8,0,9,0,4]
04:16:44 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
04:16:57 <mapreduce> > length . show $ sayFunc [2,0,0,8,0,9,0,4]
04:17:00 <lambdabot>   133
04:17:04 <quicksilver> conal: oh, and "join" for Behaviours.
04:17:17 <Olathe> mapreduce: http://hpaste.org/10117
04:17:23 <quicksilver> conal: my point is really that switcher is just stepper + join.
04:17:40 <quicksilver> conal: and I think joinB is a more intuitive combinator than switcher.
04:18:07 <mapreduce> Olathe: That's astonishing.
04:18:30 <conal> quicksilver: yes, switcher = stepper + join on reactives.  join was the one thing i couldn't do for behaviors.
04:18:54 <Axman6> Olathe: um, wow.
04:19:00 <conal> quicksilver: i'm probably not getting it.
04:19:08 <quicksilver> conal: Oh, what's the problem with join on behaviours? I didn't think this through.
04:19:22 <quicksilver> I jsut naively thought that it would be like join on (Time ->)
04:19:39 <conal> quicksilver: semantically, no problem.  it'd be exactly as you said.  (a monad morphism)
04:19:40 <opqdonut> > sayFunc [0,0,0,0,0,0,1]
04:19:44 <lambdabot>   map (\x -> (x^6 + (-15)*x^5 + 85*x^4 + (-225)*x^3 + 274*x^2 + (-120)*x) `di...
04:20:07 <conal> quicksilver: i couldn't see how to reduce a join on behaviors to a reactive time function.
04:20:13 <mmorrow> @type lex
04:20:15 <lambdabot> String -> [(String, String)]
04:20:32 <mmorrow> > lex "\\x -> x"
04:20:36 <lambdabot>   [("\\","x -> x")]
04:20:40 <conal> quicksilver: since the outer behavior could change continuously to new reactives.
04:20:48 <conal> quicksilver: rather than only discretely
04:20:56 <quicksilver> oh, I see. Hmm.
04:21:00 <quicksilver> good point!
04:21:28 <conal> quicksilver: too bad, though!  since the semantic monad is right there.
04:24:36 <mmorrow> > let tokens = takeWhile (not . null) . concatMap (uncurry (:) . fmap tokens) . lex in tokens "\\x -> x"
04:24:39 <lambdabot>   ["\\","x","->","x"]
04:24:50 <mmorrow> @let tokens = takeWhile (not . null) . concatMap (uncurry (:) . fmap tokens) . lex
04:24:53 <lambdabot>  Defined.
04:26:55 <mmorrow> > tokens . show . sayFunc $ [1,4,9,16]
04:26:58 <lambdabot>   ["map","(","\\","x","->","x","^","2","+","2","*","x","+","1",")","[","0","....
04:28:19 <quicksilver> conal: Hmm. You want 'evaluateAt :: Time -> Behaviour a -> a' to implement that join.
04:28:26 <quicksilver> conal: but that breaks abstraction.
04:28:36 <quicksilver> conal: (because there is nothing to stop you calling it at future times)
04:33:24 <mmorrow> hi sclv
04:33:36 <sclv> hi
04:34:02 <sclv> I got perturb working using existential types.
04:34:02 <mmorrow> did you ever get that IEEE monad working?
04:34:07 <mmorrow> hah
04:34:10 <mmorrow> nice
04:34:46 <mmorrow> is there some code somewhere i could peek at?
04:35:00 <sclv> not at the moment.
04:35:04 <sclv> I'll try to package it up as a patch this weekend -- not sure what the module should be.
04:36:00 <mmorrow> cool. hmm, just to make sure i'm straight on the issues you were having in that perturb paste, what exactly was going wrong?
04:36:16 <sclv> the evaluation got optimized out.
04:36:16 * mmorrow finds the paste
04:36:39 <sclv> now the notion is just that it takes something of (forall a. Floating a => a) as an argument and then has a function that explicitly delays the reduction of polymorphism, which is just id with the right signature.
04:36:47 <mmorrow> sclv: ah, ok. so the existential types served to hide something from the optimizer?
04:37:02 <mmorrow> hmm
04:37:10 <trzkril> Nein, eben nicht.
04:37:36 <sclv> right -- by keeping it polymorphic until the last minute the compiler can't share it.
04:38:01 <sclv> it works in GHCI at least -- I haven't tested with -O2, e.g.
04:38:19 <mmorrow> sclv: ahhh, sly. are you still using the implicit MVar?
04:38:39 <sclv> yeah. I think I need to document the whys a bit.
04:39:11 <mmorrow> sclv: the why wrt the MVar itself, the fact that it's implicit, or neither?
04:39:31 <sclv> both -- and other things too -- i.e. why one wants a monad, etc.
04:40:14 <sclv> Or to make a start at least. I'm not expert enough to say, e.g., what a ratio that's "too high" of deviation to value is, etc.
04:40:30 <sclv> Perturb I think works on its own for numerical stability testing.
04:40:52 <sclv> But otherwise the monad would be, I guess, for algorithms that want to test, e.g., overflow bits explicitly.
04:44:02 <bringert> is there any existing (overloaded) function for turning tuples into lists?
04:44:31 <bringert> I can't think of a way to do this with existing functions, would need to define my own class
04:45:35 <mmorrow> sclv: i had a numerical analysis class where we had to code this one example which served to illustrate when stability breaks down/what not to do and i remember it being really enlightening, but i can't remember what it was at all. i'm gonna try to find out though,  i seem to recall it was a well know case/example.
04:46:14 <sclv> bringert: surely generics could do the job?
04:46:15 <Saizan_> bringert: i think you can do it with SYB
04:46:16 <mmorrow> sclv: i think maybe it would be a nice little prog for to go into a tests/ folder or something
04:46:25 <sclv> of course the outcome would be overly generic, but...
04:46:30 <mmorrow> s/for//
04:46:47 <sclv> mmorrow: yeah, that would be really useful.
04:47:06 <mmorrow> cool, i'll work on that
04:48:15 <bringert> sclv, Saizan_: yeah, but that's a bit of a slegdehammer
04:48:25 <bringert> sledge
04:48:33 <sclv> so is a big ol typeclass (not that I haven't done it myself, but...)
04:49:21 <sclv> also, you can write it so it explicitly goes only one level deep...
04:49:25 <sclv> then it seems just about right.
04:49:40 <conal> quicksilver: mike spivey's paper "Combinators for breadth-first search" has some similarities to the awkwardness of events and multiple occurrences.  including failure of associativity and the introduction of bags.  what made me think of it is that the event monad is a sort of breadth-first search if cost == time.
04:49:55 <quicksilver> conal: Yes.
04:51:18 * EvilTerran wanders in
04:51:46 <Cale> hmm... it's a shame that a lot of the stuff in the "Stretching the Storage Manager" paper doesn't actually seem to work because StableNames don't have an instance of Ord.
04:52:25 <quicksilver> seems like StableNames deserve an instance of Ord, though.
04:52:56 <quicksilver> conal: I have this fuzzy sensation that we probably shouldn't try to build reactives out of events that have simultaneous occurences.
04:53:16 <quicksilver> conal: almost like there should be a type-level distinction between events with guarantees distinct occurrences and those that don't.
04:53:23 <quicksilver> but that would be a mess, wouldn't it?
04:53:27 <Cale> Their whole existence is basically to act as keys in maps... so it's really amazing that they don't.
04:54:15 <EvilTerran> bringert, you might be able to do it somehow with Data.Generics
04:54:41 <yitz> @pl \(a,b) -> [a,b]
04:54:42 <lambdabot> uncurry ((. return) . (:))
04:55:08 <EvilTerran> bringert, i think it'd be pretty straightforward with uniplate
04:55:35 <conal> quicksilver: well, we could force non-simultaneity by altering the model and mappend.  i.e., remove all but one occurrence.
04:55:36 <yitz> bringert: I once started writing a library that provides an overloaded (!!) for tuples.
04:55:44 <bringert> EvilTerran: sure, but it seems like it's common enough (maybe not) that there should be a Haskell 98 class for it
04:55:58 <yitz> bringert: coming from Python at the time, it seemed like a natural thing to want to do.
04:56:08 <bringert> ah
04:56:19 <quicksilver> conal: Yes. Or combine with a combining function (a -> a -> a). Or require it to be a monoid and use mappend.
04:56:21 <yitz> bringert: it soon became clear that if you need that, you shouldn't have been using tuples to begin with.
04:56:22 <bringert> it needs to be a two-parameter type class, doesn't it
04:56:47 <bringert> right, my reason for using tuples here is a bit odd
04:56:56 <bringert> it's to make the code look good in lhs2TeX :-)
04:56:59 <quicksilver> conal: but I personally feel that 'sometimes' you want them and 'sometimes' you don't; in general simultaneous occurances are good, but not when you want to turn something into a Reactive.
04:57:11 <bringert> then I paddle like crazy under the surface to make it actually run
04:57:25 <sclv> http://code.haskell.org/~sclv/staticrecord/Data/TupleLevel.hs
04:57:34 <yitz> bringert: oh dear
04:57:40 <bringert> I want to make it look like something that computational linguists can understand
04:57:44 <sclv> MapFromTuple is the bit...
04:58:07 <sclv> it would be better to autogen it with th
04:58:12 <EvilTerran> bringert, it'd be a lot easier if n-tuples were syntactic sugar for strict-snd pairs and ()
04:58:19 <EvilTerran> =/
04:58:27 <yitz> bringert: ah, I see. yeah, square brackets mean something different for them. but still...
04:58:27 <conal> quicksilver: yes.  those combining options make sense to me.
04:59:20 <conal> quicksilver: interestingly then Event a is very like Reactive a, when a is a monoid
04:59:31 <conal> quicksilver: where mempty corresponds to non-occurrences.
04:59:57 <conal> quicksilver: though then we wouldn't get a search-style monad
05:00:22 <yitz> bringert: it doesn't sound like abusing Haskell's syntax is likely the best way to implement a DSL
05:00:37 <bringert> yitz: so what is?
05:01:14 <quicksilver> conal: I already thoguht it would be nice to have a combinator Monoid a => Event a -> Reactive a
05:01:33 <quicksilver> conal: and, mostly, I would anticipate using that for commutative monoids; therefore the order of simultaneous occurrences wouldn't matter.
05:01:39 <conal> quicksilver: oh yeah.  that combinator does soud nice.
05:02:00 <quicksilver> conal: it's rather like accumR anyhow.
05:02:03 <yitz> bringert: well, wouldn't the two usual approaches be either force them to eat Haskell, or write your language parser from scratch outside Haskell syntax?
05:02:24 <bringert> yitz: yeah, but neither of those is very optimal either
05:02:35 <bringert> the first because I can't force the reader to do anything
05:02:42 <quicksilver> Bringert Antoinette says: Let them eat haskell!
05:03:06 <_zenon_> Setup.hs: Agda.cabal:15: 'Executable' stanza starting with field 'library
05:03:06 <bringert> the second because it's lots of work, and I want to take advantage of the Haskell type checker
05:03:08 <_zenon_> hs-source-dirs'
05:03:10 <_zenon_> When trying to build Agda
05:03:20 <_zenon_> someone knows what the problem is due to?
05:03:20 <bringert> _zenon_: try upgrading Cabal
05:03:28 <EvilTerran> bringert, surely it won't be that much of a problem if you define your notation up front
05:03:45 <quicksilver> conal: I intend to write some increasingly complex example programs to inform my intuition of what combinators are useful in practice :)
05:03:46 <EvilTerran> bringert, i've seen papers that use all sorts of weird notation, but it's ok because they tell you so beforehand
05:03:49 <quicksilver> conal: I'll let you know how it goes.
05:03:52 <bringert> EvilTerran: yeah, sure, I just want to lower the threshold as much as possible
05:03:58 <_zenon_> Allrighty, well, it's actually for a friend (honestly), he's taking the course Types for Programs and Proofs
05:04:02 <conal> quicksilver: that'd be great.  thx.
05:04:21 <mmorrow> bringert: you can do it like this, but it's not that great since it can't be polymorphic (??i'm not /positive/ about this) :
05:04:23 <bringert> since there's other weird stuff that I'm forcing them to deal with
05:04:28 <mmorrow> > let y = ((7,(6,((5,4),3))),(2,(1,0))) in listify (const True::Integer->Bool) y
05:04:31 <lambdabot>   mueval: Prelude.read: no parse
05:04:38 <yitz> bringert: how much more of Haskell syntax do you need? If this is really a perfect fit for Haskell syntax in many ways, except for the round/square brackets bit then maybe yes.
05:04:39 <mmorrow> [7,6,5,4,3,2,1,0]
05:04:54 <conal> quicksilver: note monoidR :: (Ord t, Monoid a) => EventG t a -> ReactiveG t a
05:05:07 <mmorrow> @type listify
05:05:09 <lambdabot> forall r a. (Typeable r, Data a) => (r -> Bool) -> a -> [r]
05:05:11 <bringert> yitz: not that much of the syntax, but I need the type checker
05:05:18 <conal> quicksilver: (from Reactive.hs)
05:05:19 <yitz> bringert: otherwise, it shouldn't be too hard to write your language.
05:05:27 <quicksilver> conal: ah yes, that's what we were talking about :)
05:05:28 <yitz> bringert: you get type checking
05:05:52 <bringert> yitz: how? other than writing my own type checker?
05:06:56 <yitz> bringert: your parser translates your DSL into Haskell objects of various types that you define
05:07:48 <conal> quicksilver: i like this idea of an event as a reactive monoidal value, since the monoid provides the non-occurrences and how to combine simultaneous occurrences.
05:07:53 <bringert> yitz: hmm, ok, with a GADT. can get problematic with polymorphic types though
05:08:46 <bringert> yitz: anyway, I actually want to be able to say at the end that the code I have give (that looks like math) is actually Haskell with just a bit of simple syntactic sugar
05:08:47 <quicksilver> conal: *nod*
05:08:54 <bringert> given
05:08:58 <yitz> bringert: yeah. if it's too complex for that, the next option might be a preprocessor that translates the DSL directly into Haskell.
05:08:58 <quicksilver> conal: I just don't know if it will be too restrictive to enforce that always.
05:09:32 <bringert> yitz: which I'm actually doing, I'm using lhs2TeX for it
05:09:38 <bringert> I know, it's a bit perverse
05:09:39 <yitz> bringert: one option for the preprocessor language is TH, as EvilTerran pointed out, but it could also be in Haskell itself.
05:09:48 <EvilTerran> i did?
05:10:06 <yitz> EvilTerran: you didn't?
05:10:12 * yitz scrolls back
05:10:27 <conal> quicksilver: i wonder also.  it'd mean at least changing some programs to use more explicit monoids, like Sum or Product.
05:11:00 <yitz> EvilTerran: oops. you said generics. right, also that.
05:11:10 <EvilTerran> :)
05:12:25 <yitz> bringert: is it for yourself, because you want to use lhs2TeX, or because you want to impress others that they are using Haskell and didn't even know it?
05:12:47 <bringert> yitz: not sure :-)
05:13:02 <bringert> yitz: all of the above
05:13:29 <dcoutts_> lhs2tex is really great
05:13:48 <bringert> I am already using lhs2TeX, I want the stuff to be more understandable than haskell code, and I want to still be able to typecheck and run it, to catch typos
05:13:50 * dcoutts_ is never going back to the silly hs latex macros
05:14:00 <FunctorSalad> incidentally, I've been thinking about a really simple DSL for commutative diagrams
05:14:25 <conal> FunctorSalad: that'd be nifty!
05:14:27 <FunctorSalad> xypics is way too verbose for most things
05:14:34 * bringert does the Lennart Augustsson dance
05:14:44 * bringert makes it haskell 98
05:15:23 <quicksilver> FunctorSalad: xypics is like assembly language. It's a good target :)
05:15:27 <FunctorSalad> on the other hand, if you want a quick diagram, it'll usually be some standard shape like triangle or square, so a simple triangle_diagram function would do
05:15:37 <quicksilver> but you want to layer something on top.
05:15:38 <mmorrow> FunctorSalad: awesome!
05:15:46 <quicksilver> FunctorSalad: have you tried Paul Taylor's diagram package?
05:15:57 <FunctorSalad> quicksilver: no, lemme see
05:16:38 <yitz> @go Paul Taylor diagram
05:16:50 <lambdabot> http://www.dcs.qmw.ac.uk/~pt/diagrams/
05:16:50 <lambdabot> Title: redirection to www.PaulTaylor.EU/diagrams
05:17:42 * EvilTerran was thinking earlier about a rather arcane hypothetical evaluation order
05:18:00 <EvilTerran> the GC knows which thunks still have handles to bits of data, right?
05:18:18 <quicksilver> EvilTerran: well, it scans them.
05:18:31 <quicksilver> it doesn't keep some global table of thunk accessibility AFAIK.
05:18:35 <EvilTerran> i was thinking, after evaluating a thunk, you could see which other thunks were still using that bit of data, and pre-emptively evaluate them
05:18:39 <EvilTerran> if it did have such a table
05:19:03 <EvilTerran> s/that bit of data/any bits of data that may've been freed up by evaluating the first thunk
05:19:23 <EvilTerran> not sure how well this'd work in practice
05:19:35 <EvilTerran> and it'd mean strange things for strictness, unless it was implemented very cleverly
05:19:58 <EvilTerran> but it seems to me that it could make stuff like "sum xs / length xs" not use loads of memory
05:20:26 <yitz> EvilTerran: as a general mechanism it could have its problems
05:20:30 <EvilTerran> yeah
05:20:34 <quicksilver> it only has such information 'transiently' during a pass, as far as I know.
05:20:39 <EvilTerran> i know solving that problem in general is Hard
05:20:46 <quicksilver> of course in principle it could collect it.
05:20:47 <EvilTerran> but it struck me as a novel approach
05:20:50 <yitz> EvilTerran: like - what if that other thunk also reference hugeExpensiveCalculation.
05:21:16 <yitz> EvilTerran: or something of type IO MissileLaunch
05:21:32 <EvilTerran> well, IO wouldn't be a problem unless you're unsafePerformIO'ing
05:21:39 <mmorrow> bringert: i dunno what version of ghc you'll be using for this, but if it's >= 6.9 then the new -XQuasiQuotes extension is really neat
05:22:33 <EvilTerran> and, if it references hugeExpensiveCalculation, it may be possible to partially evaluate it into two thunks, one which uses hugeExpensiveCalculation and one which uses the data in question
05:22:54 <EvilTerran> i don't mean speculatively evaluate to WHNF, just until the data isn't being used any more
05:23:09 <EvilTerran> or maybe not even that far
05:23:23 <lilac> EvilTerran: certainly sounds interesting. tho tbh i'd prefer if GHC was smart enough to see that (/) is strict and that 'sum xs' and 'length xs' were recursing down the same list, and transform them to recurse down it together :)
05:23:41 <lilac> although operationally i think what you're suggesting amounts to the same thing
05:23:53 <EvilTerran> yeah, it kinda does
05:24:10 <bringert> mmorrow: thanks, that looks nice. I hadn't seen that before.
05:24:29 <EvilTerran> "(sum xs) doesn't need the first (:) in xs any more, is anything else using it? ah, (length xs) is - let's get that out of the way"
05:24:39 <mmorrow> bringert: you just need two parsing functions, one (:: String -> PatQ) and one (:: String -> ExpQ), then your parsers are run at ghc compile-time, and if either parser calls fail ghc'll report it just like it was a haskell error
05:25:00 <quicksilver> EvilTerran: it's definitely an interesting kind of optimistic evaluation.
05:25:03 <EvilTerran> it also strikes me as being somehow related to breadth-first evaluation
05:25:08 <quicksilver> EvilTerran: what if that thunk turns out to be _|_ though?
05:25:47 <EvilTerran> quicksilver, well, i guess you could impose some kind of limit on how far to evaluate
05:26:00 <Cale> (and ignore exceptions)
05:26:01 <quicksilver> but any particular thunk could be _|_
05:26:09 <quicksilver> it's hard to tell...
05:26:19 <EvilTerran> and, if it throws an exception, i expect you can devise a mechanism to sit on the exception until the normal evaluation rules would need it
05:26:31 <EvilTerran> quicksilver, not if you're not reducing as far as WHNF, though
05:26:37 <mmorrow> bringert: i have some code in a repo that i've been using as support for making QQs if you're interested: http://code.haskell.org/~morrow/code/haskell/th-utils/
05:26:38 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
05:26:50 <quicksilver> yes, I don't think exceptions are a big problem. you can just put an exception-thunk there.
05:26:56 <Cale> It would be similar to `par`ing the other thing.
05:27:04 <Cale> (but maybe time-limited)
05:27:08 * quicksilver nods
05:27:12 <EvilTerran> to get around non-termination, you could say "only try to a certain depth of thunks" or whatever
05:27:18 <bringert> mmorrow: I probably won't be using quasiquotes now, since lhs2tex is enough, but it's good to be aware of the possibility
05:27:38 <Xenoblitz> hi guys... yesterday botje and Saizan_ suggested that i use a function to update State Well () from within State Game () ... the function suggested has the type MonadState Game a => State Well b -> a () ... thought it had the type State Game ()... can someone plz explain to me what the type at hand means?
05:27:49 <quicksilver> EvilTerran: surely a thunk of depth 0 can be _|_
05:27:56 <quicksilver> EvilTerran: let x = x in x
05:28:00 <mmorrow> bringert: cool
05:28:17 <EvilTerran> quicksilver, well, you could evaluate that n times (albeit without it changing each time) then give up
05:28:28 <quicksilver> oh, I see what you mean.
05:28:45 <EvilTerran> by "thunk depth" i mean the number of times you replace a thunk with another thunk
05:28:51 <lilac> although that situation would never come up
05:28:53 <EvilTerran> (or the same thunk, in the (fix id) case)
05:29:00 <Botje> Xenoblitz: hello again
05:29:01 <lilac> since you'd never have forced x in the first place
05:29:03 <quicksilver> yes you could do 'n' steps for some suitable small-step semantics.
05:29:16 <quicksilver> lilac: yeah but it could be something like that only cleverer ;)
05:29:17 <Xenoblitz> Botje: hi there ;)
05:29:21 <Botje> what part of the type don't you understand?
05:29:27 <EvilTerran> or you could launch the evaluation in another thread
05:29:45 <quicksilver> EvilTerran: and hope it doesn't become uninterruptable-bottom :)
05:29:46 <EvilTerran> but then you could get the code grinding to a halt trying to free up some bit of data
05:29:50 <cjs> quicksilver: Existential types saved my life. I am SAVED!
05:29:58 <EvilTerran> and some other bit of data, and a gazillion other bits of data
05:30:01 <EvilTerran> all in their own threads
05:30:03 <quicksilver> cjs: spread the word! sing it brother!
05:30:05 <Xenoblitz> Botje: its just beyond me at this point in time :/
05:30:53 <Xenoblitz> Botje: I mean i understood what the function itself does... but the function header leaves me baffled
05:30:56 <Botje> well, it's really the most general type GHC can derive
05:31:07 <Xenoblitz> yeah in fact i did :t hehe
05:31:07 <EvilTerran> quicksilver, alternatively, i imagine it'd be possible to statically identify thunks that definitely will free up a certain bit of data
05:31:17 <quicksilver> EvilTerran: like strictness analysis.
05:31:18 <Botje> that type is more general than the type you want
05:31:25 <Botje> which is State Well () -> State Game ()
05:31:29 <EvilTerran> say, ones that correspond to a function pattern-matching on its parameter
05:31:40 <quicksilver> EvilTerran: marking thunks as "sufficiently simple" for some definition of "sufficiently simple"
05:31:41 <Xenoblitz> :Botje ah it makes much more sense now
05:31:46 <Xenoblitz> oops xD
05:31:46 <EvilTerran> quicksilver, exactly
05:31:53 <Xenoblitz> Botje: ah it makes much more sense now
05:31:56 <Botje> :)
05:32:06 <Botje> you can just go function :: State Well () -> State Game ()
05:32:07 <quicksilver> EvilTerran: there already is an optimisation for thunks which are pattern matches on their own parameter.
05:32:14 <quicksilver> EvilTerran: it's called "selector-thunk" I think.
05:32:15 <Xenoblitz> Botje: Abstract types confuse me sometimes
05:32:26 <Botje> that's okay
05:32:28 <Xenoblitz> Botje: thanks again Botje... now it makes sense
05:32:31 <quicksilver> EvilTerran: and I have a feeling it runs at GC time rather like you are suggesting. I'm not sure.
05:32:36 <Botje> the reason it uses State Well b instead of State Well ()
05:32:42 <EvilTerran> quicksilver, yeah, but i doubt it speculatively evaluates it to free up the constructor cell
05:33:02 <Botje> is because you're only interested in using the state, not the result
05:33:17 <Xenoblitz> Well is fixed... the value isn't
05:33:21 <Botje> yeah
05:33:23 <Xenoblitz> types i mean
05:33:27 <Botje> you're using execState inside the function, right?
05:33:28 <Xenoblitz> ok cool
05:33:33 <Xenoblitz> erm runState
05:33:43 <Xenoblitz> oh fudge... i am using runstate
05:33:43 <quicksilver> EvilTerran: no, it doesn't, but I think it *does* notice if that thunk got evaluated later
05:33:45 <Xenoblitz> but i am doing
05:33:48 <quicksilver> EvilTerran: (because something else referrred to it)
05:33:55 <quicksilver> EvilTerran: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks
05:33:57 <Xenoblitz> (_, newWell) = runstate f .....
05:34:01 <Xenoblitz> i guess execState is enough
05:34:03 <lambdabot> Title: Commentary/Rts/Storage/HeapObjects - GHC - Trac, http://tinyurl.com/2y6qst
05:34:05 <Xenoblitz> cause i just need the state
05:34:05 <EvilTerran> mmhmm
05:34:13 <Botje> Xenoblitz: try changing that to ((), newWell) = ...
05:34:24 <quicksilver> EvilTerran: that commentary page is a very good read if you're interested in this kind of thing.
05:34:25 <Botje> and see how GHC changes the type
05:34:31 <Xenoblitz> ok sure 1 sec
05:34:33 <yitz> EvilTerran: if you evaluate thunks indiscriminately to depth n, you might multiply the execution time of a big calculation by n
05:34:41 <EvilTerran> "The garbage collector "peeks" at the selectee's tag (in its info table). If it is evaluated, then it goes ahead and does the selection, and then behaves just as if the selector thunk was an indirection to the selected field. If it is not evaluated, it treats the selector thunk like any other thunk of that shape."
05:34:44 <Botje> this definition is better because it works with any type of State Well calculation, but this one is for education :)
05:35:02 <EvilTerran> ^ that sounds very much like what i was thinking of, although my plan involved evaluating a little more agressively
05:35:07 <EvilTerran> yitz, bah, constant factors :P
05:35:11 <Botje> s/^this/your original/
05:35:16 <Xenoblitz> Botje: MonadState Game a => State Well () -> a ()
05:35:20 <Xenoblitz> Botje: hehe thanks
05:35:20 <quicksilver> EvilTerran: well this is only a very special case. It's only for selectors.
05:35:24 <EvilTerran> indeed
05:35:30 <Botje> Xenoblitz:  :)
05:35:36 <quicksilver> EvilTerran: (and only for single-constructor types like tuples)
05:35:43 <Botje> the original definition is better though.
05:35:46 <EvilTerran> well, i'll keep thinknig about this
05:35:47 <Xenoblitz> Botje: what about the ... what's it called... erm... the MonadState Game a part
05:36:06 <EvilTerran> i keep meaning to make a toy statically-typed lisp to try these things out in
05:36:14 <Botje> it means "there must be an instance for MonadState Game a"
05:36:21 <Xenoblitz> Botje: yeah i can understand the more generic the types the better... but i'm just learning so its fine for me like you said State Game () -> State Well ()
05:36:28 <Botje> if you do :i MonadState
05:36:34 <Botje> you'll see there's a number of instances defined
05:36:39 <Botje> of which State is one
05:37:03 <Botje> since you use get, which is part of the MonadState interface, GHC must use the most general type it can
05:37:22 <yitz> :i MonadState
05:37:30 <Botje> @info monadstate
05:37:31 <lambdabot> monadstate
05:37:31 <Botje> maybe
05:37:36 * Botje hits lambdabot 
05:37:38 <Botje> bad bot!
05:37:40 <Xenoblitz> Botje: I know i am using it... but I can't get this part of it... class Monad b => MonadState a b | b -> a where
05:38:03 <Botje> that's a big load there :)
05:38:19 <Xenoblitz> i'm using it without understanding it to be honest...
05:38:20 <Botje> what that type means, informally:
05:38:26 <Xenoblitz> :)
05:38:55 <Botje> "if you're looking for an instance of Monadstate a b, b must be a monad. The type of a shouldn't matter when looking for an instance"
05:39:33 <Xenoblitz> ok that's ok
05:39:36 <Botje> if you look a bit past that
05:39:38 <Xenoblitz> what about the b -> a
05:39:45 <Botje> you"ll see "instance MonadState s (State s)"
05:39:49 <Botje> that's a functional dependency
05:40:00 <Xenoblitz> yeah i see that
05:40:02 <Botje> don't worry about that, it helps the type inferencer
05:40:13 <Xenoblitz> ok :)
05:40:31 <Xenoblitz> so what is in essence this class saying?
05:40:44 <Botje> the instance or the class definition?
05:40:53 <Xenoblitz> may i ask both?
05:40:54 <Xenoblitz> lol
05:41:03 <EvilTerran> if there is an instance MonadState m a, that means m is a state monad with state of type a
05:41:44 <Xenoblitz> brain.fries();
05:41:45 <Xenoblitz> lol
05:41:48 <Xenoblitz> hehe
05:42:01 <Botje> Xenoblitz: specialize it to your case:
05:42:01 <Xenoblitz> yeah ok :)
05:42:23 <Botje> the return value of your function was MonadState Game a => ... a ()
05:42:33 <Botje> so if you overlay that with the class definition
05:42:40 <Botje> s is bound to Game
05:42:44 <Botje> the state parameter
05:42:48 <Botje> and m is bound to "a"
05:43:12 <Botje> so get has type "a Game"
05:43:13 <yitz> @vixen if there is an instance MonadState m a, that means m is a state monad with state of type a
05:43:14 <lambdabot> i enjoy talking to you
05:43:30 <Botje> the instance you want to use is the State instance
05:43:42 <Botje> so a must be State Game
05:43:47 <Botje> uh
05:43:55 <Botje> yeah.
05:44:15 <Xenoblitz> still a bit confused
05:44:18 <Botje> so the m from the class must also be State
05:44:21 <Xenoblitz> but i'll keep it for future reference
05:44:37 <Botje> you'll get what it means once you start using the RWS monad
05:44:42 <Botje> or monad transformers
05:44:44 <Xenoblitz> i don't know why they use single letter types... that's probably what's confusing me... substituting letters in my mind
05:45:01 <Xenoblitz> yeah i guess
05:45:04 <Xenoblitz> thanks the same Botje :)
05:45:09 <Xenoblitz> i appreciate the time and patience
05:45:28 <Botje> np
05:45:31 <Botje> let it sink in for a while :)
06:02:10 <FordCortina> why would a Char be an element of a BitSet? Wouldn't that make it a ByteSet?
06:03:36 <Botje> maybe they're 1-bit Chars
06:03:37 * Botje runs
06:03:51 <FordCortina> Botje: heh
06:04:12 <ddarius> Actually they are represented by words and they represent Unicode codepoints not bytes.
06:09:38 <FordCortina> hang on... a BitSet is a compact collection of Bit-Words right? so it could be a compressed collection of Bytes if the word length is 8?
06:15:50 <FordCortina> i get confused because BitSet such as this http://java.sun.com/javase/6/docs/api/java/util/BitSet.html
06:16:08 <FordCortina> seem to be just a collection of index bits
06:16:15 <FordCortina> indexed*
06:16:27 <yitz> @Data.Bits.bitSize (undefined :: Char)
06:16:28 <lambdabot> Unknown command, try @list
06:16:37 <yitz> > Data.Bits.bitSize (undefined :: Char)
06:16:40 <lambdabot>       No instance for (Bits Char)
06:16:40 <lambdabot>        arising from a use of `bitSize' at <...
06:17:27 <FordCortina> im asking because im trying to understand the example on page 5 of mark jones' paper
06:17:46 <yitz> > log (fromIntegral (maxBound :: Char)) / log 2
06:17:49 <lambdabot>       No instance for (Integral Char)
06:17:49 <lambdabot>        arising from a use of `fromInteg...
06:18:14 <yitz> > log (fromIntegral $ fromEnum (maxBound :: Char)) / log 2
06:18:14 <FordCortina> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.26.7153&rep=rep1&type=pdf
06:18:18 <lambdabot> Title: Type Classes with Functional Dependencies, http://tinyurl.com/5oswpc
06:18:18 <lambdabot>   20.087461546321563
06:18:53 <yitz> > maxBound :: Char
06:18:56 <lambdabot>   '\1114111'
06:18:58 <FordCortina> instance Col lects Char BitSet where ...
06:19:25 <yitz> > 2^20
06:19:29 <lambdabot>   1048576
06:20:09 <yitz> > '\1114112'
06:20:12 <lambdabot>       lexical error in string/character literal at character '1'
06:20:32 <yitz> > '\1114111'
06:20:35 <lambdabot>   '\1114111'
06:21:05 <yitz> > showHex 1114111 ""
06:21:08 <lambdabot>   mueval: Prelude.read: no parse
06:21:18 <yitz> > Numeric.showHex 1114111 ""
06:21:21 <lambdabot>   mueval: Prelude.read: no parse
06:22:18 <udoprog> is it possible to define a datatype which can only assume specific values, like a datatype to hold DNA sequence parts (GATC)?
06:22:19 <yitz> @type Numeric.showHex
06:22:22 <lambdabot> forall a. (Integral a) => a -> String -> String
06:22:47 <quicksilver> udoprog: data Base = G | A | T | C
06:23:11 <udoprog> quicksilver: how can i then define it as an instance of Show?
06:23:31 <quicksilver> udoprog: data Base = G | A | T | C deriving Show
06:23:32 <quicksilver> ;)
06:23:50 <quicksilver> although you're free to write the show instance by hand if you prefer.
06:24:20 <yitz> > 1114111
06:24:20 <udoprog> will 'show foo' where foo is of the type Base show a string containing "G" (as example)?
06:24:23 <lambdabot>   1114111
06:25:29 <lilac> > ord (maxBound :: Char)
06:25:30 <quicksilver> udoprog: yes.
06:25:33 <lambdabot>   1114111
06:25:42 <quicksilver> udoprog: the default show deriver uses haskell syntax
06:25:48 <quicksilver> show G = "G"
06:25:51 <quicksilver> (and the others the same)
06:26:29 <yitz> 1114111 = 0x10ffff
06:26:31 <lilac> > minimum [n | 2^^n > ord (maxBound :: Char), n <- [1..]]
06:26:34 <lambdabot>       No instance for (Fractional Int)
06:26:34 <lambdabot>        arising from a use of `^^' at <...
06:26:43 <lilac> > minimum [n | 2^n > ord (maxBound :: Char), n <- [1..]]
06:26:46 <udoprog> quicksilver: that was too easy, thanks : )
06:26:58 <lambdabot>   thread killed
06:27:14 <FordCortina> oh actually i suppose the word length doesnt matter
06:27:29 <yitz> > head [n | 2^n > ord (maxBound :: Char), n <- [1..]]
06:27:31 <udoprog> quicksilver: how would i define a datatype that is a sequence of Base?
06:27:37 <udoprog> or a list*
06:27:50 <lilac> yitz: hehe, good point :)
06:27:56 <lambdabot>   thread killed
06:28:10 <yitz> > head [n | n <- [0..], 2^n > ord (maxBound :: Char)]
06:28:18 <quicksilver> udoprog: I would just use [Base] personally.
06:28:19 <luite> what's a good way to generate an infinite list, where each element is a function of the previous?
06:28:26 <Zao> iterate?
06:28:30 <quicksilver> udoprog: no need to define a new type when a perfectly good one exists.
06:28:39 <quicksilver> > iterate (*2) 1
06:28:44 <yitz> @botsnack
06:28:45 <luite> Zao: ah thanks
06:28:45 <lambdabot>   thread killed
06:28:45 <lambdabot> :)
06:28:48 <quicksilver> :(
06:28:50 <quicksilver> > iterate (*2) 1
06:28:54 <yitz> > head [n | n <- [0..], 2^n > ord (maxBound :: Char)]
06:28:55 <lambdabot>  Terminated
06:28:58 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:28:59 <lambdabot>  Terminated
06:29:09 <udoprog> so i could just use a type defination if i would like tro use it as String is to [Char]?
06:29:10 <quicksilver> luite: there you go, amidts the 'Terminated'
06:29:14 <yitz> > head [n | n <- [0..], 2^n > ord (maxBound :: Char)]
06:29:15 <quicksilver> udoprog: sure.
06:29:24 <quicksilver> udoprog: type Gene = [Base]
06:29:37 <udoprog> great, thanks again
06:29:43 <quicksilver> udoprog: but I don't find synonyms like that very useful. I would need a good reason not to just use [Base] directly.
06:29:56 <ertai> Is there a commonly used, short way for (\x->x-42)?
06:30:03 <quicksilver> (subtract 42)
06:30:04 <lilac> > head [n | n <- [20..30], 2^n > ord (maxBound :: Char)]
06:30:09 <quicksilver> ;)
06:30:17 <yitz> quicksilver: often it's good just as documentation
06:30:36 <lambdabot>   21
06:30:36 <lambdabot>   21
06:31:01 <_zenon_> ertai,  you can oftan find those "short ways" with :pf if you have the point free package
06:31:01 <yitz> finally
06:31:04 <yitz> @botsnack
06:31:05 <lambdabot> :)
06:31:05 <ertai> quicksilver: thanks
06:31:11 <lilac> @type (+ -42)
06:31:15 <lambdabot>     The operator `+' [infixl 6] of a section
06:31:15 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
06:31:15 <lambdabot>         in the section: `(+ - 42)'
06:31:18 <_zenon_> @pl (\x -> x - 42)
06:31:18 <lambdabot> subtract 42
06:31:28 <lilac> @type (+(-42))
06:31:30 <lambdabot> forall a. (Num a) => a -> a
06:31:36 <yitz> @type (+ negate 42)
06:31:38 <lambdabot> forall a. (Num a) => a -> a
06:31:54 <_zenon_> lilac, nice one.
06:32:03 <ertai> lilac,_zenon_,yitz: thanks
06:32:42 <lilac> > (-1*).(42-) $ 45
06:32:45 <lambdabot>       The operator `*' [infixl 7] of a section
06:32:45 <lambdabot>          must have lower prece...
06:33:02 <lilac> > negate.(42-) $ 45
06:33:06 <lambdabot>   3
06:35:20 <quicksilver> lilac: unary minus I HATES it.
06:35:25 <quicksilver> made of fail, it is.
06:37:02 <udoprog> quicksilver: how would i override the show declaration for [Base] so i can make them appear like a String (and not comma separated)?
06:37:26 <quicksilver> udoprog: (a) don't.
06:37:36 <quicksilver> (b) if you really want to know, the answer lies in 'showList'
06:37:42 <quicksilver> but this is not what Show is for.
06:37:43 <MarcWeber> udoprog: hoogle for showList
06:37:57 <quicksilver> Show is for producing output which is valid haskell code.
06:38:07 <quicksilver> if you want a pretty-printer of your own design, don't call it 'show'
06:38:54 <MarcWeber> udoprog: You should find exactly this question in one of the recent haskellcafe mailing posts
06:40:18 <udoprog> k, won't use show for that purpose in the future
06:41:25 <MarcWeber> udoprog: You may, but you should only do so if there is no chance that anyone else might use Show / Read to serialize the daat
06:41:55 <quicksilver> you still might regret it.
06:42:11 <quicksilver> ghci uses Show instances when you're playign around interactively.
06:42:22 <quicksilver> having a correct (that is, haskell-interpretable) Show instance is very handy
06:42:28 <quicksilver> as you can copy and paste test cases
06:42:31 <quicksilver> or counterexamples.
06:42:47 <quicksilver> I've regretted every time I've had to debug code which had funny Show instances :)
06:43:39 <udoprog> yeah, i can see why that is very useful : P
06:50:01 <cjs> Unless, of course, the Show instance uses value constructors that are not publically available. (ByteString, cough cough.)
06:50:23 <quicksilver> cjs: the ByteString Show instance should really generate 'pack "foo"'
06:50:30 <quicksilver> cjs: but, there is a scoping problem there ;(
06:50:37 <quicksilver> which is a limitation of all show instances.
06:50:41 <cjs> It would be much nicer if it did.
06:50:42 <quicksilver> they don't work with qualified imports.
06:50:44 <cjs> Easier to read, too.
06:50:57 <cjs> How about Data.ByteString...pack "foo"?
06:51:11 <quicksilver> e.g. Data.Map generates "fromList ..."
06:51:20 <quicksilver> but people normally import that qualified so it's not much use.
06:51:23 <quicksilver> annoying, that is.
06:51:40 <quicksilver> but there is no way for a symbol to know what qualification its been imported into :(
07:03:18 <mapreduce> :t uncurry
07:03:20 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:04:19 <RayNbow> @djinn (a -> b -> c) -> (a, b) -> c
07:04:20 <lambdabot> f a (b, c) = a b c
07:07:17 <RayNbow> http://www.reddit.com/r/haskell/comments/6zkjr/bringing_the_power_of_gpus_to_haskell/ <-- ah damn... my computer doesn't have a powerful GPU...
07:07:20 <lambdabot> Title: Bringing the Power of GPUs to Haskell : haskell, http://tinyurl.com/5bxsqo
07:09:29 <Xenoblitz> Guys... got a mini-problem: I have a function
07:09:31 <thoughtpolice> RayNbow: my graphics card is enough for CUDA so that will be fun to play with when it's ready :]
07:09:37 <Xenoblitz> moveDown :: State Game ()
07:09:37 <Xenoblitz> moveDown
07:09:37 <Xenoblitz>   = do g         <- get
07:09:37 <Xenoblitz>        Game w b  <- return g
07:09:37 <Xenoblitz>        actionOnWell (moveWellDown b) w
07:09:38 <Xenoblitz>        actionOnBrick (moveBrickDown b)
07:09:57 <Xenoblitz> actionOnWell have type State Well () -> State Game ()
07:10:05 <quicksilver> Xenoblitz: more than a couple of lines = don't paste it here. But carry on now.
07:10:24 <RayNbow> thoughtpolice: thank you for rubbing it in :p
07:10:24 <Xenoblitz> actionOnBrick has type State Well () -> State Game ()
07:10:35 <Xenoblitz> quicksilver: sorry guys
07:10:42 <quicksilver> Xenoblitz: it's OK. please continue.
07:10:44 <Xenoblitz> i got an error in that and i can't figure it out
07:10:49 <quicksilver> what error?
07:11:02 <quicksilver> you seem to be giving actionOnWell two parameters
07:11:08 <quicksilver> from what you just told us, it only has one.
07:11:10 <quicksilver> is that the problem?
07:12:01 <Xenoblitz> oh wait you are right... the type of actionOnWell (moveWellDown b) w is actually Brick -> State Well () -> State Game ()
07:12:06 <Xenoblitz> so no its not the problem
07:12:14 <Xenoblitz> the error i am getting is
07:13:03 <Xenoblitz> actionOnWell (moveWellDown b) w term actionOnWell type State Well () -> State Game ()
07:13:03 <Xenoblitz> does not match a -> b -> c
07:13:22 <quicksilver> that's exactly what I said.
07:13:36 <quicksilver> it's telling you actionOnWell is declared to take 2 parameters
07:13:41 <quicksilver> sorry, 1 parameter
07:13:48 <quicksilver> and youre giving it two..
07:15:01 <Xenoblitz> i guess same goes for actionOnBrick
07:15:05 <Xenoblitz> thanks quicksilver
07:15:28 <Xenoblitz> sorry if that was a newbie question all the way...
07:16:06 <quicksilver> not at all.
07:16:18 <quicksilver> by the way, I think you can condense those two lines
07:16:22 <quicksilver> into just
07:16:24 <quicksilver> Game w b <- get
07:16:27 <quicksilver> (the first two lines)
07:16:39 <Xenoblitz> oh ok :)
07:17:29 <Twey> Is it just me, or do other people try to use record syntax everywhere in case you decide to insert a new value into your type too?
07:17:56 <Xenoblitz> quicksilver: you were right, it works
07:18:14 <quicksilver> Xenoblitz: yay ;)
07:18:29 <quicksilver> Twey: it's certainly a good idea for the kind of type you can imagine adding a field to.
07:18:38 <quicksilver> Twey: I find my types fall into two categories:
07:18:50 <quicksilver> Twey: (1) small, often abstract, types which definitely don't use record notation.
07:19:23 <quicksilver> Twey: (2) huge, ugly, record types which encode some kind of state or something like that.
07:19:38 <quicksilver> Twey: I often add new fields to type (2) so I'm pleased with the ability to make that easly.
07:19:52 <quicksilver> if I change type (1) it's normally abstract anyway and users of the code don't need ot be changed.
07:20:03 <Philippa> though field names may be useful for other reasons
07:21:14 <matthew-_> would it be accurate to say that GADTs subsume phantom types?
07:21:31 <Twey> Aye, quicksilver.
07:21:45 <quicksilver> matthew-_: I wouldn't say that.
07:21:54 <quicksilver> GADTs permit you to use phantom types, as in
07:21:59 <quicksilver> ...where Bar :: Foo a
07:22:06 <matthew-_> quicksilver: exactly
07:22:10 <thoughtpolice> matthew-_: well, GADTs allow you to express the same idioms as phantom types
07:22:18 <quicksilver> but they don't really subsume them. Just give a different syntac for them.
07:22:23 <matthew-_> ok
07:22:24 <thoughtpolice> personally I find GADTs clearer myself
07:22:43 <matthew-_> oh yes, I'm just trying to describe the relationship between phantom types and GADTs
07:23:02 <thoughtpolice> although regular run-of-the-mill phantom types are always acceptable if I don't want extensions for some reason
07:23:48 <quicksilver> I think GADTs give a new syntax for phantoms but they are orthogonal to them.
07:27:41 <thoughtpolice> for the most part yeah; phantom types are really an idiom, GADTs are full blown extension that can express the same things
07:28:06 <matthew-_> gotcha, cheers
07:28:51 <Philippa> insofar as phantom types are an extension, GADTs subsume that extension
07:29:28 <Philippa> and yeah, they are a minor extension to at least some algebraic datatype schemes
07:31:25 <Cale> Wow, I find this incredibly surprising: If C is a small category, and C is complete (has all small limits), then there is at most one arrow between any two objects of C.
07:31:57 <Cale> That means that if C is complete, and there is a pair of parallel arrows f,g: A -> B in C, then the objects of C must be a proper class :)
07:32:27 <quicksilver> because completion "creates" too many objects to keep it small.
07:32:41 <Cale> yeah
07:33:20 <quicksilver> at most one arrow -> C is a partial order.
07:33:32 <Cale> preorder
07:33:46 <quicksilver> complete pre order = pre order with all lubs and gubs
07:33:52 <quicksilver> which makes it a lattice, perhaps?
07:34:29 <Cale> hmm, do we really get that there are no cycles?
07:36:43 <quicksilver> Cale: OK, a lattice up to isomorphic objects :)
07:36:54 <quicksilver> Cale: who cares about isomorphic objects, the category can't tell them apart.
07:37:01 <Cale> right.
07:37:40 <quicksilver> actually we do get that there are no cycles
07:37:47 <quicksilver> that would be a second arrow A -> A
07:38:15 <Cale> Doesn't it just mean that the composite of any cycle of arrows is the identity?
07:39:08 <Cale> There's an equivalence of categories with a lattice though.
07:39:13 <Cale> I'll agree about that :)
07:41:57 <guenni> I need to parse CSV files, using parsec, into a list of some type of record. So I did it pretty much by hand and the had a look the CSV File Parsing example from "Real World Haskell" which shows you how to parse a csv file into [[String]]. That helps to take care of quoted values and split up the comma separated fields, but doesn't show how to continue parsing the strings from the fields into other values, ie. Ints, LocalTime, etc. 
07:42:45 <dmwit> read, parseTime respectively
07:42:57 <dmwit> ?hoogle parseTime
07:42:58 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
07:42:58 <lambdabot> Data.Time.Format class ParseTime t
07:43:16 <guenni> dmwit: the values are in some obscure German format
07:43:34 <Philippa> guenni: yeah, you might want to use parsec strictly for the inner part
07:43:35 <dmwit> Take a look at the docs, it's still likely possible with parseTime.
07:43:36 <guenni> and there are values that also need further parsing
07:43:52 <dmwit> (parseTime takes a format string)
07:44:13 <dmwit> But yes, you should also learn a bit about Parsec; it's really quite nice.
07:44:22 <mmorrow> guenni: so since those are diff types, they can't be in a list together. so maybe do something like data Cell = IntC Int | IntegerC Integer | DoubleC Double | StringC String | TimeC Localtime deriving (Eq,Ord,Show,Read)
07:44:35 <Philippa> mmorrow: I think the point here is that read isn't good enough
07:44:48 <Philippa> guenni: there's a manual for parsec linked to in the docs, you may find that helpful
07:45:01 <guenni> I had hoped I could do some sort of preparsing this way so I would not have to code scanning for "" into every specific parser
07:45:03 <mmorrow> Philippa: but guenni will surely face this problem after the parsing works :)
07:45:13 <Philippa> I'd suggest writing a parser for one record, and doing parse . lines?
07:45:17 <quicksilver> guenni: two-stage parsing is very sane.
07:45:27 <quicksilver> guenni: parsing first into [String] and then parsing the fields.
07:45:37 <guenni> quicksilver: yep
07:46:31 <mmorrow> guenni: this is a handy function as well:
07:47:19 <mmorrow> readM :: (Read a) => String -> Maybe a   readM s = case reads s of [] -> Nothing ; [(a,_)] -> Just a
07:49:15 <guenni> Philippa: do you happen to know how the parsec docs coin this sort of 2 phase parsing? (Tokenizing?)
07:49:37 <guenni> Scanning, Lexing?
07:49:38 <mmorrow> then say you define the Cell datatype like above, then you can do (this is the last thing): class Val a where toCell :: a -> Cell    fromCell :: Cell -> a
07:50:35 <guenni> mmorrow: I see what you mean but this approach means a lot of boilerplate coding
07:51:02 <mmorrow> then you can have a [[String]] and do     (map . map) (maybe EmptyC toCell . readM) :: [[String]] -> [[Cell]]
07:51:16 <mmorrow> parsing done.
07:51:18 <guenni> mmorrow: I think some sort of preparsing and the further parsing would be better
07:51:44 <mmorrow> definitely. so what stages do you have in mind?
07:52:39 <guenni> 2, one that takes care of the possible quotes and commas and then one that turnes the string into a more specific value
07:53:17 <mmorrow> String ->(lines)-> [String] ->(map csvRow)->[[String]]->(stuff)->[[Cell]]
07:53:21 <mmorrow> or something
07:53:33 <guenni> yeees, sort of
07:54:25 <mmorrow> the beauty of (.) is that once you've written your funcs to "do one thing and do it well",  (h . g . f)  now does 3 things and does them all well ;)
07:55:28 <osfameron> as long as none of them take more than 1 argument...
07:56:36 <mmorrow> of course you'd define the composite function appropriately..
07:56:54 <osfameron> or use the boobies operator :-)
07:57:00 <mmorrow> haha
07:57:52 <mmorrow> let stringToCells = map (map (maybe EmptyC toCell . readM) . parseCsvRow) . lines
07:58:02 <mmorrow> or if you prefer
07:58:35 <mmorrow> err
07:58:51 <quicksilver> how is that supposed to know which instance of 'toCell' to choose?
07:59:05 <mmorrow> true true
07:59:11 <mmorrow> crap
07:59:12 <quicksilver> (or which instance of readM, equivalently)
07:59:18 <mmorrow> yeah, double trouble
07:59:22 <guenni> lol
08:00:30 <guenni> sorry guys but I had been giving that some thought myself before I asked, it's nice to see that others come up with similar solutions just to discover the same problem :)
08:01:40 <guenni> I was thinking, on the cell level, scan, extract string, pass string to value parser, etc ...
08:01:58 <guenni> repeat, row done
08:03:20 <mmorrow> what i actually do for that is have a parser that goes through char by char and (e.g.) if it encounter a '.' it'll "cross off" the IntC/IntegerC option and continue until it's found a unambiguous choice, then do (e.g.) (DoubleC . read)
08:03:44 <RayNbow> hmm, how do you get a pretty ">>>" in a TeX document?
08:04:32 <mmorrow> guenni: yeah, that sounds very sane.
08:05:39 <jnr> hey guys is anyone generous enough to give me five bucks im willing to do anything aye please guys
08:05:44 <mmorrow> guenni: if you're parsing csv's that are even slightly larger than just a little big the row-at-a-time is crucial
08:06:10 --- mode: ChanServ set +o quicksilver
08:06:17 <Arnar_> hey guys..
08:06:34 <jnr> hey guys is anyone generous enough to give me five bucks im willing to do anything aye please guys
08:06:42 --- mode: quicksilver set +b *!*=smeegal1@*.ispone.net.au
08:06:42 --- kick: jnr was kicked by quicksilver (quicksilver)
08:06:48 <guenni> mmorrow: I figure I know how to code this using parsec, but I also think parsec also provides this functionality in an elegant way so I just need to find it
08:07:27 <Arnar_> so.. what symbols exactly can I use for my operators (or where can I find a list)?
08:07:27 <mmorrow> guenni: for example, the csv parsing package currently on hackage doesn't return /any/ results until the /entire file/ has been parsed. on top of that, say there's an error in cell 100 on line 539203 ... it'll hand you Nothing
08:07:42 <Arnar_> I guess ; and | are out, right?
08:08:24 <mmorrow> guenni: actually, it'll never make it to that line number, but you know what i mean
08:08:30 <quicksilver> Arnar_: in the report. ; is out, | is allowed.
08:08:38 <quicksilver> Arnar_: but not just one | on its own.
08:08:54 --- mode: quicksilver set -o quicksilver
08:08:56 <Arnar_> quicksilver: ok.. so || should be fine..
08:09:09 <Arnar_> quicksilver: looked in the report.. didn't find it.. I'll look again
08:09:11 <Arnar_> thx
08:10:20 <mmorrow> guenni: so i guess what i'm saying is ... don't have a parsec parser that handles more than one line. then map thatParser . lines   (or something)
08:10:33 <mmorrow> s/then//
08:11:06 <dmwit> or mapM thatParser . lines, so that you can do all the error-handling at once
08:11:15 <mmorrow> or that
08:12:06 <mmorrow> key though being you get the results of parsing the first row immediately after it sees a '\n'
08:12:19 <mmorrow> so it'll run in constant memory
08:12:21 <cjb> xxbxo
08:12:24 <cjb> Oops.
08:12:29 <mmorrow> even for a 1,000,000 line csv file
08:13:06 <mmorrow> or infinite for that matter
08:13:27 <dmwit> Oh, well, then Parsec can't do that.
08:13:55 <thoughtpolice> polyparse?
08:14:03 <mmorrow> dmwit: whatd'you mean? it'll be fine if it only does a single line
08:14:11 <mmorrow> (or not?)
08:14:19 <dmwit> mmorrow: Right.
08:14:29 * mmorrow nevar uses parsec for this very reason
08:15:04 <mmorrow> dmwit: oh, you're saying it /will/, correct?
08:15:10 <mmorrow> it should
08:15:13 <guenni> I'm pretty certain Parsec does have built in support for lexing parsing, I just haven't figured out where to find it in the docs
08:15:32 <dmwit> mmorrow: I'm saying that if you mapM parser . lines, it will not return until it has parsed *all* the lines.
08:15:41 <mmorrow> dmwit: yuk
08:15:44 <dmwit> mmorrow: But map parser . lines would be OK.
08:16:02 <mmorrow> yeah, but you can always do something like
08:16:08 <dmwit> mmorrow: Well... what do you expect?  It has to decide whether the Either constructor should be Left (parse error) or Right (parse success).
08:16:10 <lilac> mmorrow: you actually can work around that parsec problem
08:16:23 * lilac has code to do so, but not here, sadly
08:17:00 <lilac> essentially, you write a parser which parses one item then saves the parser state, and call it repeatedly feeding the previous state into the next parse
08:17:00 <mmorrow> [Either ParseError [Cell]]  as you're result without much loss of efficiency
08:17:04 <mmorrow> gah
08:17:12 <mmorrow> *your
08:17:49 <lilac> mine produces something like ([Cell], Maybe ParseError)
08:18:20 <mmorrow> heh, six or a half dozen
08:18:44 <mmorrow> i like the pair better
08:18:49 <lilac> mmorrow: you never get more than one parseerror, so...
08:18:56 <mmorrow> haha, true
08:19:33 * lilac has a background project to implment a table-driven arrow-based GLR parser :)
08:19:34 <mmorrow> err, well if it's also parsing each individual cell into some datatype you could
08:20:04 <mmorrow> lilac: that sounds interesting. how's it coming?
08:20:15 <lilac> pretty terribly, to be honest :)
08:20:22 <mmorrow> hehe
08:20:35 <xci> what extensions do you guys recommend for haskell typing in vim?
08:20:46 * lilac wishes for arrT :: Arrow a => TH.Expr -> a b c
08:20:58 <mmorrow> hmm
08:21:04 <lilac> the type system insists on getting in the way :(
08:21:06 <dmwit> xci: :set autoindent
08:21:25 <lilac> and i find myself having to use makeStableName to identify rules :/
08:21:26 <dmwit> xci: Also http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
08:21:29 <mmorrow> lilac: what's an example of such an Exp you'd pass in?
08:21:30 <lambdabot> Title: Haskell mode for Vim
08:21:31 <xci> dmwit: no, I mean like, plugins
08:21:42 <mmorrow> (just a quick trivial one or something)
08:21:59 <lilac> mmorrow: the idea would be that proc-notation would implicitly wrap everything in [| ... |]
08:22:12 <lilac> then i could build the tables at compile-time with TH
08:22:57 <lilac> as it is, i still can, but the compiled code won't be as tight i think
08:23:17 <mmorrow> oh cool. we were just talking about a very similar thing earlier.
08:24:47 <lilac> i got as far as looking at how hard it'd be to add a 'procT' notation to GHC. conclusion: too hard :)
08:25:13 <mmorrow> lilac: i'm currently reading through this, it seems very applicable to such things: http://www.haskell.org/th/papers/Unrolling_and_Simplifying_Expressions_with_Template_Haskell.ps
08:25:15 <lambdabot> http://tinyurl.com/6kxwpb
08:26:02 <mmorrow> lilac: hmm. so the problem is that you can't do arrow notation in a [| ... |], right?
08:27:42 <lilac> well, that'd solve it too, but it'd be a bit of a pain to have to wrap everything in [| ... |]
08:28:04 <mmorrow> isn't there an arrow-notation pre-processor from before the syntax was directly supported? i'm thinking maybe you could somehow use TH + the preproc and get it done somehow
08:28:33 <lilac> there is a preprocessor, yes. and that's probably the eaiest way.
08:29:12 <kaol> every [| |] can be unwrapped by replacing the code with a function call and putting the code in another module
08:29:25 <mmorrow> but i bet it could be done so that you write the code how you want, then that preproc gets applied automatically by TH at compile time, so it'll be transparent
08:44:27 <lilac> kaol: not true. putting a symbol in [| |] in another module introduces a typeclass dependency (i forget what)
08:45:14 <kaol> hmm... I suppose I'm talking about something that I don't know, again.
08:45:42 <lilac> the typeclass is Lift
08:46:09 <lilac> basically, the compiler needs to be able to transform a value of type T into an Exp
08:46:54 <lilac> it can do that for most types (anything with a Data instance should be OK) but not (eg) for functions
08:49:31 <kaol> wait... why does, say, runQ [| id|] work then? id's a function.
08:55:55 <lilac> kaol: heh, oops. the restriction i was talking about was for variables, as in "f x = [| x |]" (here, f :: Lift a => ExpQ)
08:56:30 <lilac> kaol: the problem with moving the code out of the [| ... |] is that you can no longer manipulate it
08:57:55 <lilac> (eg, runQ [| id |] and runQ [| \x -> x |] are different)
09:00:25 <lilac> and "(\x -> [| x |]) id" is different again
09:00:44 * kaol got LamE [VarP x_0] (VarE x_0) from runQ [| \x -> x |]
09:01:43 <kaol> but I'm not really afraid of writing expressions directly myself. [| |] is just a nice shorthand sometimes.
09:02:10 <quicksilver> it's easier to read
09:02:15 <quicksilver> that's the most important point to me
09:02:20 <udoprog> if i wan't to read a data that was defined like 'data Seq = MolSeq String Int', what string would i pass to 'read'?
09:02:45 <quicksilver> 'MolSeq "hello" 4'
09:02:47 <zachk> how do i shut off the monomorphism restriction in ghci
09:02:47 <quicksilver> for example
09:02:58 <quicksilver> (note you have to escape " inside ")
09:03:09 <quicksilver> "MolSeq \"hello\" 4:
09:03:11 <quicksilver> "MolSeq \"hello\" 4"
09:03:14 <quicksilver> sorry ;)
09:03:28 <Elly> my constructive logic class is doing currey-howard today :D
09:03:37 <kaol> the only way I found for getting the type Maybe Int for my SigE was with [t| Just Int |] >>= return . SigE (or something like that, I don't feel like checking my code)
09:05:23 <udoprog> quicksilver: i get some 'error in string/character literal at character ...'CC
09:05:38 <quicksilver> udoprog: yes, the single quotes were for clarity
09:05:42 <quicksilver> you can't actually write it that way
09:05:47 <quicksilver> it has to be double quotes for haskell strings
09:05:52 <lilac> zachk: set -fno-monomorphism-restriction
09:06:06 <shapr> hi Brenda, learning Haskell?
09:06:13 <lilac> zachk: or :set -XNoMonomorphismRestriction in more recent versions, probably
09:08:40 <udoprog> quicksilver: peow, now got it working, thanks a bunch
09:09:00 <udoprog> btw, what's that ::'Type' acter the read argument?
09:09:47 <quicksilver> it's only necessarily to resolve ambiguity
09:09:54 <quicksilver> you may nto need it, if there is no ambiguity.
09:10:04 <quicksilver> a priori, "read" can return anything
09:10:14 <quicksilver> > read "3" :: Int
09:10:19 <lambdabot>   3
09:10:19 <quicksilver> > read "3" :: Double
09:10:23 <lambdabot>   3.0
09:10:26 <quicksilver> > read "3" :: Float
09:10:29 <lambdabot>   3.0
09:10:30 <quicksilver> ...and so on.
09:10:50 <quicksilver> however, if you did (read "3") + x, in a context where haskell already knew that 'x' was Int.
09:10:57 <quicksilver> you wouldn't need the annotation, because it can deduce it.
09:11:39 <udoprog> ah, so if i use read in a context where haskell can deduce what the type is, it is not necessary?
09:11:56 <quicksilver> udoprog: precisely.
09:12:19 <quicksilver> type annotations are only necessary when haskell can't figure it out on its own.
09:13:35 <udoprog> great, thanks
09:20:06 <_zenon_> quicksilver, oh well "you wouldn't need the annotation, because it can deduce it." <--- it would select the type that makes it work, maybe you meant "Integer" in your head, but x is "Int"
09:21:39 <quicksilver> _zenon_: then your program is wrong :P
09:22:18 <_zenon_> quicksilver, of course.
09:25:15 <_zenon_> I just didn't like the "figure it out" , should have been "infer"
09:26:24 <_zenon_> Of course, one may argue about the "sapientness" <-- yeah, I know!  of the haskell system
09:30:39 <mdmkolbe> I've found a bug in the bootstrap script for caball-install, where should I report that?
09:32:40 <pozic> I might be mistaken, but the reduce part of MapReduce is still going to take Theta(size of output), no matter how many CPUs you have and thus makes it suitable for only some purposes?
09:36:15 <pozic> Never mind it.
09:36:23 <zenon> omg, wth
09:39:46 <desp> Hey guys.
09:40:09 <desp> Do you know if you can use the PrettyPrint module to print stuff with aligned = signs, for instance?
09:40:16 <desp> foo   = bar
09:40:24 <desp> foooo = bar
09:40:47 <Lycurgus> why not?
09:41:05 <desp> Yeah, what I really mean to ask is -- how. ;)
09:41:24 <Lycurgus> POP
09:41:33 <quicksilver> desp: group them into two vertical Docs I think
09:41:43 <quicksilver> desp: one with the names and one with the "= values"
09:41:52 <quicksilver> desp: (I don't use the PP modules much but I think that's the idea)
09:41:57 <desp> Hm, thanks.
09:44:33 <Twey> Trin?  ithis?
09:45:24 <Trin> Twey: Trin from CZ. Do I know you?
09:46:25 <Twey> Trin: No, no, just thought you were someone else.  Pardon me.
09:46:40 <Trin> Twey: np
09:50:52 <lilac> pozic: for some applications (like merge sort), Reduce can work via divide-and-conquer
10:04:35 <pozic> lilac: the reduce phase is still Theta(n) in that case.
10:07:36 <lilac> i guess so :)
10:21:40 <xci> how can I make an Int->Float conversion for lists?
10:21:51 <JimCrayne> who admins the wiki?
10:21:55 <JimCrayne> for ghc
10:22:03 <xci> so that if I want to be able to type  a = zipWith (/) [2..1000000] (map (phi) $ [2..1000000]), where both lists are [Int]
10:22:21 <JimCrayne> fromInteger
10:22:29 <JimCrayne> @type fromInteger
10:22:31 <lambdabot> forall a. (Num a) => Integer -> a
10:22:34 <lilac> @type fromIntegral
10:22:36 <lambdabot> forall a b. (Num b, Integral a) => a -> b
10:23:20 <lilac> xci: what type do you want as the result?
10:25:08 <xci> [Float]
10:25:33 <xci> I used fromIntegral, and I think it does the trick for me
10:28:00 <xci> or at least it seemed to do, thanks :9
10:28:01 <xci> :)
10:31:01 <dons> Cale: http://www.reddit.com/r/programming/comments/6znyi/popl_logo_design_contest/
10:31:04 <lambdabot> Title: POPL logo design contest : programming, http://tinyurl.com/6ku39q
10:31:17 <dons> design a logo for POPL, win tshirts+cookies, meet Wadler et al.
10:32:47 <Beelsebob> dons: did you see that threadring has been run using -N4 on the benchmark shootout?
10:32:49 <Beelsebob> do you know why?
10:32:55 <dons> oh
10:33:06 <dons> i know igouy is experimenting.
10:33:13 <Beelsebob> igouy?
10:33:55 <dons> the shootout guy.
10:34:00 <Beelsebob> oh, okay
10:34:18 <Beelsebob> I did realise we may be cheating on all the parallelised benchmarks
10:34:24 <dons> why?
10:34:30 <Beelsebob> in that it demands that no one uses their own scheduler
10:34:35 <Beelsebob> which ghc's runtime does
10:34:37 <mmorrow> hehe
10:34:40 <dons> user-land.
10:35:09 <Beelsebob> hmm? as in, if it's in the runtime it's fine?
10:35:15 <dons> of course.
10:35:16 <mmorrow> what would perl do then?
10:35:22 <dons> since how do you think erlang et al is going to fly?
10:35:37 <Beelsebob> yeh, good point
10:35:46 <Beelsebob> it would also be a rather odd benchmark otherwise
10:35:55 <Beelsebob> "how fast can you yell at the operating system to do this threading problem?"
10:36:10 <bjrn> Speaking of Erlang any of you know something for Haskell that's syntactically close to Erlangs Bitsyntax? Don't know how that'd supposed to work, but it'd be nice.
10:36:23 <Igloo> Beelsebob: Where does it talk about schedulers?
10:37:16 <Beelsebob> end of the problem description... "Programs may use kernel threads, lightweight threads… cooperative threads… and other programs with custom schedulers will be listed as interesting alternative implementations. Briefly say what concurrency technique is used in the program header comment."
10:37:40 <dons> lightweight threads.
10:37:50 <Igloo> Beelsebob: URL?
10:37:52 <Beelsebob> yeh, it's not so clear what the rule actually is
10:37:55 <dons> custom schedulers mean "written by the user"
10:37:56 <Beelsebob> Igloo: http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
10:37:59 <lambdabot> Title: thread-ring benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Language ..., http://tinyurl.com/5ph2wt
10:38:01 <dons> no, it's clear. they don't mean the runtime.
10:38:03 <Igloo> thanks
10:38:04 <Beelsebob> dons: okay, makes sense
10:38:14 <Beelsebob> dons: I'm not so convinced that it's clear
10:38:19 <Beelsebob> but if that's what they've told you
10:38:24 <dons> yeah.
10:38:38 <Igloo> I can't even parse that
10:38:52 <Igloo> Is the bold bit supposed to be one sentence?
10:39:01 <mmorrow> probably ambiguous on purpose..
10:39:21 <dons> nah.
10:39:29 <dons> the shootout is pretty straightforward.
10:39:36 <dons> people are far too suspicious of it.
10:39:53 <dons> you're just supposed to use whatever scheduler your language runtime has
10:39:56 <mmorrow> heh. also, i wearing a tin foil suit along with my hat right now.
10:39:57 * Igloo suggests someone mails them, asking them to clarfy it
10:39:58 <Beelsebob> Igloo: yeh, it's ambiguous
10:40:13 <mmorrow> *i'm
10:40:17 <Beelsebob> how much of "lightweight, cooperative, and custom schedulers" is meant to be in the banned section?
10:40:26 <mmorrow> totally
10:41:11 <Beelsebob> also though, I think the benchmark would be pointless if it just made everything use the OS threads
10:41:22 <dons> Beelsebob: i've mailed the shootout guys asking clarification of what they're doing with GHC.
10:41:30 <Beelsebob> cool :)
10:41:31 <dons> i expect isaac's just experimenmting.
10:41:32 <mmorrow> i guess the ... , ... , /and/ ...  disambiguates it somewhat
10:41:46 <dons> i've proposed they leave things as is, and we enable +RTS -N4 as parallel submissions are created.
10:41:50 <Beelsebob> mmorrow: I'm not sure it does
10:41:58 <Beelsebob> it would do if it had only one ... in it
10:42:00 * mmorrow goes to look at it in context
10:42:01 <Beelsebob> and two ands
10:42:19 <sw17ch> ?seen ddarius
10:42:19 <lambdabot> I saw ddarius leaving #haskell, #haskell-overflow and #haskell-blah 4h 13m 50s ago, and .
10:42:24 <Beelsebob> dons: hmm? so you're proposing leaving threadring using -N4?
10:42:53 <mmorrow> lol
10:43:02 <Beelsebob> I'd say that's somewhat flawed -- in that I'd say it's a major advantage of the language that it can do small threads that don't do much, much more efficiently than the OS can
10:43:22 <Beelsebob> and the benchmarks should after all be pointing out what languages are good at
10:43:31 <mmorrow> not only are the multiple '...'s, but they started the bold font in the middle of a list
10:43:38 <dons> Beelsebob: i'm proposing leaving as it was before -N4 by default
10:43:45 <mmorrow> *not only are there...
10:43:47 <dons> and then, on demand, adding -N4 to new submissions
10:43:47 <bjrn> If I pattern match on say (n+1), does the + here mean the same thing as (+) or is it a different kind of pattern-matching-+? Are there other infix operations other than + I can pattern match on?
10:43:58 <Beelsebob> ah, I see, yeh that makes sense dons
10:44:28 <dons> we need some more parallel programs
10:44:37 <Beelsebob> we do that
10:44:38 <dons> binarytrees was the easiest, but could be tuned further
10:44:46 <dons> threadring for exampel
10:44:51 <dons> simonmar worked out how to do it.
10:44:55 <Beelsebob> oh?
10:45:00 <dons> you tied ring/N segments to each cpu
10:45:08 <dons> then just rotate around the cpus
10:45:27 <dons> since they can't actually run in parallel, at least you save on some context switching overhead by spinning up the other cores
10:45:41 <dons> i don't have time to work on this though
10:45:42 <Beelsebob> sounds fun
10:45:56 <Beelsebob> I'm not sure it'll be faster than the ghc runtime spinning around on it's head though
10:46:02 <dmhouse> bjrn: n+k patterns are a special case
10:46:18 <dons> Beelsebob: well, SimonM got improvements on 2 cores.
10:46:25 <Beelsebob> oh?
10:46:30 <Beelsebob> hmm, that sounds weird
10:46:38 <Beelsebob> in terms of not being able to run in parallel
10:46:40 <bjrn> dmhouse: Ah cheers. Are there any practical reasons for not allowing arbitrary binary operations, if you somehow specificy how to break a potential match into pieces?
10:46:44 <dmhouse> bjrn: the report contains information on how to desugar them, I think f (n+k) = <expr> goes to f n' = let n = n' - k in <expr>
10:46:50 <Beelsebob> so how do you offset the overhead of switching CPU in the middle?
10:47:05 <dmhouse> bjrn: you're basically asking for view patterns.
10:47:05 <dons> Beelsebob: http://www.reddit.com/r/programming/comments/6o4yi/ghc_doesnt_even_break_a_sweat_with_a_million/c04f24i
10:47:07 <lambdabot> Title: simonmar comments on "GHC doesn't even break a sweat with a million threads", http://tinyurl.com/6syjy7
10:47:09 <dmhouse> ?google view patterns haskell
10:47:12 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
10:47:13 <lambdabot> Title: ViewPatterns - GHC - Trac
10:47:16 <bjrn> dmhouse: Ah thanks, will check it out
10:47:37 <Beelsebob> hmm, interesting dons
10:49:48 * Beelsebob ponders -- mandelbrot should be *really* easily parallelisable
10:50:00 <dons> also, the string search problems.
10:50:15 <dons> anywhere where the benchmark is broken up into phases
10:50:21 <dons> we can speculate on things
10:50:32 <Beelsebob> interestingly, it doesn't specify the algorithm for mandelbrot
10:50:36 <dons> seems like pidigits could probably do with extra threads as well
10:50:39 * Beelsebob ponders writing a sherman contour crawler
10:50:41 <dons> running ahead computing results
10:50:51 <dons> pidigits is just a lazy list generator
10:51:02 <dons> nbody too,
10:51:06 <Beelsebob> indeed -- are the digits generated independantly?
10:51:07 <dons> has well known parallel impls.
10:51:29 <dons> nsieve seems intuitively parallel
10:51:40 <dons> you use multiple threads to mark off each prime multiples
10:51:52 <dons> doesn't matter if you have a contest and mark the same bit twice
10:51:57 <ptolomy2> Hm. How do I tell cabal to also install the profiling version of bytestring?
10:52:05 <ptolomy2> Or, for that matter, to uninstall an installed package?
10:52:06 <dons> cabal install bytestring -p
10:52:07 <bjrn> --with-library-profiling iirc
10:52:11 * Beelsebob sits and tries to understand how the mandelbrot implementation works
10:52:13 <dons> ghc-pkg unregister bytestring
10:52:25 <ptolomy2> cabal install bytestring -p seems to be a no-op.
10:52:28 * ptolomy2 tries again.
10:52:32 <dons> Beelsebob: might be easier to just reimplement from scratch
10:52:35 <dons> since they're so low level
10:52:38 <mmorrow> is the string-search one gone?
10:52:38 <Beelsebob> dons: might be
10:52:44 <dons> they're really tuned for single core
10:52:51 <Beelsebob> dons: do you know if I can get away with writing a sherman contour crawler?
10:53:01 <dons> no idea.
10:53:06 <Beelsebob> hmm
10:53:09 <dons> probably has to be the same algo
10:53:15 <Beelsebob> yeh, that was my thought
10:53:16 <dons> you just get to add a strategy
10:53:20 <Beelsebob> but it doesn't specify *which* algo
10:53:25 <mmorrow> string-search looks to be gone
10:53:50 <dons> the pidigits loop looks doable
10:53:58 <dons> there's a list comprehension at the top level
10:54:14 <dcoutts_> ptolomy2: if you're using the latest cabal-install then you can cabal install bytestring -p --reinstall
10:54:55 <dons> there's an erlang parallel mandelbrot
10:54:59 <JimCrayne> i wonder why free pascal performs better than c in memory usage on the shootout
10:55:16 <dons> Beelsebob: http://alioth.debian.org/tracker/index.php?func=detail&aid=311051&group_id=30402&atid=411646
10:55:19 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311051 erlang (parallel)  ..., http://tinyurl.com/6qmtwb
10:55:39 <dons> Beelsebob: also erlang parallel binary trees http://alioth.debian.org/tracker/index.php?func=detail&aid=311038&group_id=30402&atid=411646
10:55:41 <lambdabot> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311038 Erlang binary-tree ..., http://tinyurl.com/638mmy
10:55:47 <ptolomy2> dcoutts_: It seems that I'm not.
10:56:38 <dcoutts_> ptolomy2: cabal install cabal-install !!
10:56:46 <dcoutts_> :-)
10:57:23 <dcoutts_> you may also need to "cabal update", if "cabal list cabal-install" tells you that 0.5.1 is the latest version
10:57:42 <ptolomy2> Neat. :)
10:57:48 * ptolomy2 likes software that takes care of itself.
10:57:54 <dmead> hey all
10:57:58 <dmead> > NAN
10:58:00 <lambdabot>   mueval: Prelude.read: no parse
10:58:04 <trofi> > Nan
10:58:06 <dmead> _|_
10:58:08 <lambdabot>   mueval: Prelude.read: no parse
10:58:12 <dmead> > _|_
10:58:15 <lambdabot>   mueval: Prelude.read: no parse
10:58:24 <dmead> is not a number, or bottom programmable?
10:58:33 <trofi> > 1/0
10:58:37 <lambdabot>   Infinity
10:58:39 <trofi> > 0/0
10:58:43 <lambdabot>   NaN
10:58:57 <dmead> (0/0) == (0/0(
10:59:03 <trofi> > NaN
10:59:04 <dmead> > (0/0) == (0/0)
10:59:07 <lambdabot>   mueval: Prelude.read: no parse
10:59:08 <lambdabot>  Terminated
10:59:12 <dmead> > (0/0) == (0/0)
10:59:15 <lambdabot>   False
10:59:32 <trofi> :t NaN
10:59:34 <lambdabot> Not in scope: data constructor `NaN'
10:59:55 <sw17ch> :t Infinity
10:59:58 <lambdabot> Not in scope: data constructor `Infinity'
11:00:05 <dmead> @hoogle bottom
11:00:06 <lambdabot> Test.QuickCheck.Batch bottom :: a
11:00:06 <lambdabot> Data.Array.Base arrEleBottom :: a
11:00:06 <lambdabot> package ChasingBottoms
11:00:21 <mmorrow> > isNaN 42
11:00:22 <trofi> > minBound :: Int
11:00:27 <lambdabot>   -9223372036854775808
11:00:27 <lambdabot>  Terminated
11:00:40 * Beelsebob ponders if floats or ints are faster on moders CPUs
11:00:42 <mmorrow> > isInfinite 43
11:00:46 <lambdabot>   False
11:00:50 <matthew-_> Beelsebob: ints
11:00:56 <matthew-_> by miles
11:01:01 <Beelsebob> are you sure?
11:01:10 <matthew-_> yes
11:01:16 <im_alone> you have to push floats to ST
11:01:18 <Beelsebob> considering that modern vector units can do 4 floating point multiplies in a clock cycle?
11:01:26 <dmead> > itNan (0/0)
11:01:30 <lambdabot>   mueval: Prelude.read: no parse
11:01:31 <dmead> > isNan (0/0)
11:01:34 <lambdabot>   mueval: Prelude.read: no parse
11:01:36 <matthew-_> only if you generate code that uses them
11:01:38 <trofi> same for ints, no?
11:01:58 <Beelsebob> trofi: no, ints have remained roughly as fast as they always have been as far as I'm aware
11:02:06 <Beelsebob> vector units almost always are floating point only
11:02:17 <Beelsebob> matthew-_: yeh, question is ... can ghc
11:02:22 <matthew-_> Beelsebob: no
11:02:32 <matthew-_> ghc does not generate any non-generic-x86 instructions
11:02:33 <Beelsebob> even via a C compiler that auto-vectorises?
11:02:43 <trofi> sse[2..] not only FP math aware afaik
11:02:44 <matthew-_> yeah, that would be your only hope
11:02:46 <Beelsebob> matthew-_: even with -f-viac?
11:03:13 <matthew-_> well, the via C is really just compiling very very low level C
11:03:21 <Beelsebob> yeh, I know
11:03:23 <matthew-_> you could try dumping it
11:03:30 <Beelsebob> but the C compiler *might* be able to deal with it
11:03:48 <matthew-_> but I'd be suprised if a C compiler could infer enough info back into it to start making use of those units
11:04:20 <dons> we'd really need vector primops
11:04:31 <dons> to guarantee it came out to the C compiler in the right form.
11:04:53 <matthew-_> right, but you really want the NCG to work for this stuff - not the via-c stuff right?
11:05:12 <dons> yep
11:05:17 <dons> http://www.reddit.com/r/programming/comments/6zo7p/modular_monad_transformers/
11:05:19 <lambdabot> Title: Modular Monad Transformers : programming, http://tinyurl.com/67l6uo
11:06:22 <matthew-_> but, frankly, given the issues with L2 miss and endless stalls due to loading thunks from ram, making use of such units would, I would guess, result in < 1% speed up in the general case
11:08:03 <matthew-_> right, time to go hunt ice cream...
11:09:44 <dmead> hey guys
11:09:47 <dmead> i have i have a list
11:09:48 <dmead> say
11:09:56 <dmead> > [1..10]
11:09:59 <lambdabot>  Terminated
11:10:04 <dmead> wat.
11:10:05 * Twey snorts.
11:10:08 <Twey> Pay no heed
11:10:08 <Saizan_> > [1..10]
11:10:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:10:17 <dmead> kay, a list like that
11:10:18 <Twey> It's lambdabot's time of the month
11:10:20 <dmead> ah
11:10:39 <dmead> how would i eliminate 3, but leave the structure of the list intact
11:10:45 <dmead> and just have an empty element
11:10:58 <Zao> Define "empty element".
11:11:08 <Zao> Bottom?
11:11:10 <dmead> [1,2,,4]
11:11:17 <dmead> empty element
11:11:27 <Saizan_> you can't..
11:11:27 <Deewiant> > map (\x -> if x == 3 then Nothing else Just x) [1..10]
11:11:31 <Saizan_> why do you want that?
11:11:31 <lambdabot>   [Just 1,Just 2,Nothing,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
11:11:35 <Zao> You can use the Maybe monad.
11:11:36 <dmead> ah
11:11:39 <dmead> gotcha
11:11:44 <Saizan_> yeah, you can use Maybe
11:11:58 <dmead> Saizan_, because i need to keep the list structure
11:12:07 <Deewiant> I think there's a combinator for that so it can be written shorter, but I forget what it is
11:12:08 <dmead> it's for a database, rows have to line up
11:12:38 <dmead> > print (Just 3)
11:12:41 <lambdabot>   mueval: Prelude.read: no parse
11:12:41 <lambdabot>  mueval: *** Exception: "<IO ()>"
11:12:42 <matthew-_> dmead: if you care about performance and are doing lots of indexing then you may want to look at the UArray stuff
11:12:52 <trofi> :t doReadFile
11:12:58 <dmead> it's not a terrible lot of stuff
11:13:02 <lambdabot> Not in scope: `doReadFile'
11:13:08 <dmead> but more than you want to do by hand
11:13:18 <dmead> i think the maybe solution is pretty easy
11:13:19 <mmorrow> dons: i could've sworn i saw an asm snippet from you somehow arrived at from haskell using mmx registers. am i mistaken?
11:13:39 <mmorrow> if not, how do i do this?
11:14:22 <dmead> > 10 == Just 10
11:14:23 <JimCrayne> it'd be even cooler if it used the gpu
11:14:26 <lambdabot>       No instance for (Num (Maybe t))
11:14:26 <lambdabot>        arising from the literal `10' at...
11:14:34 <dmead> Maybe 10 == Maybe 10
11:14:37 <dmead> > Maybe 10 == Maybe 10
11:14:40 <lambdabot>   mueval: Prelude.read: no parse
11:14:47 <lilac> @type map (join $ (>> return) . guard . (/=3)) [1..10]
11:14:49 <lambdabot> forall a (m :: * -> *). (Enum a, Num a, Monad m, MonadPlus ((->) a)) => [m a]
11:14:57 <lilac> > map (join $ (>> return) . guard . (/=3)) [1..10] :: [Maybe Int]
11:15:00 <lambdabot>       No instance for (MonadPlus ((->) Int))
11:15:00 <lambdabot>        arising from a use of `gu...
11:15:05 <lilac> ;-(
11:15:13 <dmead> :<
11:15:17 <JimCrayne> > Just 3 == Just 3
11:15:20 <lambdabot>   True
11:15:34 <dmead> > 3 == Nothing
11:15:38 <lambdabot>       No instance for (Num (Maybe a))
11:15:38 <lambdabot>        arising from the literal `3' at ...
11:15:45 <JimCrayne> > Just 3 == Nothing
11:15:46 <dmead> > Nothing == Nothing
11:15:51 <lambdabot>   True
11:15:51 <lambdabot>  Terminated
11:15:54 <dmead> > Nothing == Nothing
11:15:58 <lambdabot>   True
11:16:21 <lilac> @hoogle Bool -> a -> Maybe a
11:16:22 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:16:22 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:16:22 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
11:16:31 <JimCrayne> > map Just [1..10]
11:16:34 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
11:17:00 <trofi> @help check
11:17:00 <lambdabot> check <expr>
11:17:01 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
11:17:22 <dmead> > Just 4 < Just 3
11:17:24 <trofi> @check (curry.uncurry) = id
11:17:24 <lambdabot>   Parse error at "=" (column 17)
11:17:26 <lambdabot>   False
11:17:29 <trofi> @check (curry.uncurry) == id
11:17:30 <lambdabot>       No instance for (Eq ((a -> b -> c) -> a -> b -> c))
11:17:31 <lambdabot>        arising from...
11:17:48 <ToRA> > map (ap ((>>) . guard . (3 /=)) Just) [1..10] -- lilac
11:17:52 <lambdabot>   [Just 1,Just 2,Nothing,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
11:18:01 <lilac> @@ map (@pl \x -> @undo do a <- return x; guard (a /= 3); return a) [1..10]
11:18:02 <lambdabot>  map ap ((>>) . guard . (3 /=)) return [1..10]
11:18:06 <dmead> you can pattern match agains Just, right?
11:18:08 <JimCrayne> > liftM2 (<) (Just 4) (Just 3)
11:18:11 <lambdabot>   Just False
11:19:07 <trofi> @check (uncurry.curry) == id
11:19:09 <lambdabot>       No instance for (Eq (((a, b) -> c) -> (a, b) -> c))
11:19:09 <lambdabot>        arising from...
11:19:47 <JimCrayne> dmead, yes
11:20:10 <dmead> =]
11:20:11 <Beelsebob> @hoogle a -> (a,a)
11:20:14 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
11:20:16 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
11:20:18 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
11:25:54 <lilac> @pl \a -> (a,a)
11:25:55 <lambdabot> join (,)
11:29:29 <Beelsebob> Hmm, well that's hopeful -- my version that prints a big bulky character representation to the terminal is already much faster than the one we have up there
11:42:21 <roconnor> @type \f -> (f.)
11:42:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:43:41 <roconnor> @type \f -> (.f)
11:43:43 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
11:45:04 <Jedai> @type >>>
11:45:07 <lambdabot> parse error on input `>>>'
11:45:14 <Jedai> @type (>>>)
11:45:16 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
11:58:05 --- mode: irc.freenode.net set +o ChanServ
12:14:11 <sw17ch> is there a nifty way to use the Parsec to parse, but also keep track of how many characters/bytes/elements have been consumed thus far?
12:14:43 * Beelsebob ponders where he lost parallelisation
12:15:08 <trofi> sw17ch: parser has user state parameter (st)
12:15:10 <Deewiant> sw17ch: well, there's the sourcePos stuff
12:15:15 <Deewiant> as well as that
12:15:36 <sw17ch> trofi, the user state parameters is probably where this would be saved... but i don't want to do length checking on each produced token
12:15:55 <sw17ch> I was half hoping to pull it out of the Stream state... but i'n not sure how that works yet
12:16:06 <Beelsebob> anyone see why the parMap in this does nothing at all? http://hpaste.org/10127
12:16:12 <trofi> there's yet getInput (not very handy though)
12:16:23 <trofi> or getPareserInput
12:16:41 <Deewiant> hmm, actually it seems you can only get a SourcePos from a ParseError?
12:17:00 <maltem> Deewiant: getPosition?
12:17:01 <trofi> @hoogle getParserInput
12:17:02 <lambdabot> No results found
12:17:02 <sw17ch> Deewaint, getPosition
12:17:04 <sw17ch> i think
12:17:09 <trofi> @hoogle getInput
12:17:10 <lambdabot> Language.Haskell.ParseMonad getInput :: Lex r String
12:17:10 <lambdabot> Text.Parsec.Prim getInput :: Monad m => ParsecT s u m s
12:17:10 <lambdabot> Text.ParserCombinators.Parsec.Prim getInput :: Monad m => ParsecT s u m s
12:17:15 <maltem> sw17ch: Yeah, that should be what you look for
12:17:15 <Beelsebob> dons: don't suppose you have any insight?
12:17:25 <Deewiant> ah, I missed that one
12:17:28 <sw17ch> maltem: getPosition isn't what i want
12:17:40 <trofi> sw17ch: getInput?
12:17:41 <maltem> oh, why?
12:17:48 <sw17ch> getInput might be...
12:18:07 <sw17ch> position is a tuple (File,Line,Column)
12:18:11 <maltem> ah, you want a character count rather than a column count
12:18:16 <sw17ch> maltem, exactly
12:18:27 <trofi> @hoogle getParserState
12:18:28 <lambdabot> Text.Parsec.Prim getParserState :: Monad m => ParsecT s u m (State s u)
12:18:28 <lambdabot> Text.ParserCombinators.Parsec.Prim getParserState :: Monad m => ParsecT s u m (State s u)
12:18:33 <roconnor> sw17ch: what on earth are you trying to do? :D
12:18:33 <sw17ch> when i start parsing something, i want to be able to ask "what's the index of the next character"
12:18:37 <newsham> what's the fixity of `f` ?
12:18:38 <trofi> it contains all the data
12:18:56 <trofi> :info (`f`) ?
12:19:21 <sw17ch> roconnor, uhhh.... something that maps the tokens to the original code they correspond to
12:19:38 <newsham> trofi: doenst say
12:19:53 <sw17ch> roconnor, TokBlock => "{\n\tint i = 0;\n\treturn i;\n}"
12:19:56 <roconnor> sw17ch: ... and File,Line,Column won't do that?
12:20:06 <sw17ch> roconnor, it's a lot slower than an index
12:20:42 <sw17ch> i could just trace the file until i find the correct position, but it'd rather say "seek here, read this far"
12:21:16 <roconnor> oh
12:21:25 <roconnor> does Parsec work with ByteStrings?
12:21:34 <sw17ch> yes
12:21:42 <roconnor> neat
12:21:44 <Deewiant> 3.0 does
12:21:47 <sw17ch> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-ByteString.html
12:21:47 <Deewiant> 2.0 doesn't IIRC
12:21:49 <lambdabot> Title: Text.Parsec.ByteString, http://tinyurl.com/5btw7a
12:22:18 <trofi> but you can't use use `letter` combinator effectively?
12:22:36 <trofi> or string
12:24:26 <sw17ch> there aren't any ways to hook my own function into the parser to control the user state, is there?
12:25:33 <trofi> to define your owh get/put/update funs?
12:26:36 <sw17ch> the Consumed data type looks interesting...
12:27:14 <sw17ch> oh! that might be it!
12:27:35 <sw17ch> runParsecT :: Sate s u -> m (Consumed (m (Reply s u a)))
12:28:14 <sw17ch> hrm.. but probably not
12:31:10 <FordCortina> what's a first-order datatype?
12:36:14 <mmorrow> > tokens "(\\x -> x)"
12:36:17 <lambdabot>   ["(","\\","x","->","x",")"]
12:37:11 <matthew-_> > tokens "(λx -> x)"
12:37:14 <lambdabot>   ["(","\955x","->","x",")"]
12:37:21 <matthew-_> fail
12:37:37 <mmorrow> heh
12:39:36 <mmorrow> let tokens = takeWhile (not . null) . concatMap (uncurry (:) . fmap tokens) . lex
12:39:42 <Beelsebob> gah, why will this not parallelise
12:40:40 <joelalejandro> Hi there... I'm having a problem creating a function that locates the minimum value of a list of type [a]. I'm supposed to use Bounded a, Ord a => [a] -> a  as the function's type signature, yet I get Hugs' error: "Unresolved overloading" when I try to execute listMin [] or listMin [1, 2, 3]. Here is a paste-bin of what I'm talking about. http://pastebin.com/m799693b0
12:41:13 <joelalejandro> any ideas of what am I doin' wrong?
12:42:02 <Beelsebob> joelalejandro: it's because Hugs can't figure out what type 1, 2 and 3 are
12:42:14 <Beelsebob> they could be any one of Int, Integer, Rational, Float, Double etc
12:42:36 <opqdonut> wow, somebody uses hugs
12:42:53 <joelalejandro> opqdonut: Don't have a choice. At uni they make us use it...
12:42:54 <Beelsebob> and yeh, as opqdonut says in a somewhat roundabout way -- use ghci, not hugs
12:43:00 <Beelsebob> oh, that's lame
12:43:05 <joelalejandro> Beelsebob: Yeah. I know.
12:43:09 <Beelsebob> ghci gives *way* better error messages
12:43:26 <cjb> joelalejandro: are your teachers the hugs authors or something?  :)
12:43:34 <sw17ch> What if i define my own Stream, or hide the stream instance for the Text.Parsec.String?
12:43:36 <opqdonut> hugs isn't developed actively afaik
12:43:37 <cjb> I guess hugs was pretty popular interactively five years ago or so
12:43:41 <joelalejandro> cjb: Lol. They'd wish.
12:43:46 <cjb> maybe they didn't update their course since then
12:43:49 <sw17ch> have uncons increment a state variable, and then store it off...
12:43:50 <sw17ch> that might work
12:47:41 <rwbarton> sw17ch: maybe a stream whose initial value is zip [0..] stringToParse, with uncons throwing away the index half of the pair
12:48:15 <sw17ch> rwbarton, i was thinking something similar
12:49:10 <joelalejandro> Beelsebob: Besides doing listMin [1,2,3]::Int, can I do anything else to fix it?
12:49:10 <joelalejandro> Besides doing listMin [1,2,3]::Int, can I do anything else to fix it?
12:49:24 <Beelsebob> not really, no
12:50:14 <joelalejandro> Beelsebob: Okay then :) Guess I'm not gonna trouble myself anymore with that then XD
12:50:53 <joelalejandro> Thanks for helping out people ;) See ya.
12:54:12 <rwbarton> Beelsebob: btw, not sure why the parallelism isn't working, but your pack function is wrong on lists of length a multiple of 8
12:54:42 <Beelsebob> rwbarton: hmm? oh, so it is -- it pads an extra byte on
12:56:23 <Beelsebob> this makes very little sense
12:56:44 <Beelsebob> it should be really easily parallelised
12:57:24 <dmead> > 1 />= 2
12:57:27 <lambdabot>   mueval: Prelude.read: no parse
12:57:31 <dmead> damn
12:57:36 <dmead> i want not greater than or equal to
12:57:38 <dmead> :P
12:57:44 <Beelsebob> > 1 < 2
12:57:48 <lambdabot>   True
12:57:50 <dmead> what boolean negation?
12:58:01 <dmead> > Not (1 < 2)
12:58:05 <lambdabot>   mueval: Prelude.read: no parse
12:58:12 <Beelsebob> > not (1 >= 2)
12:58:15 <lambdabot>   True
12:58:18 <dmead> > True /=  (1 < 2)
12:58:21 <dmead> ah
12:58:21 <lambdabot>   False
12:58:30 <Beelsebob> > (neg (>=)) 1 2
12:58:33 <lambdabot>   mueval: Prelude.read: no parse
12:58:42 <Beelsebob> oh, apparently not
12:58:44 <Beelsebob> either way, <
12:59:06 <Myoma> > (flip (<)) 1 2
12:59:10 <lambdabot>   False
13:02:05 <mmorrow> > flip (<) 1 2
13:02:09 <lambdabot>   False
13:15:21 <Beelsebob> hmm, conclusion -- Data.ByteString needs an NFData instance
13:23:40 <Myoma> @undo [ x | Just x <- [Nothing,Just ()] ]
13:23:41 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) [Nothing, Just ()]
13:24:26 <Botje> also known as catMaybe
13:24:31 <Botje> *catMaybes
13:25:13 <jiyunatori> hi there. I recently updated some haskell stuff on my archlinux and I can't recompile xmonad anymore - it cannot find some installed modules anymore. Isn't there some kind of magic command to refresh ghc's module path or something ?
13:28:22 <zulusulta> hello
13:28:27 <zulusulta> i have a question
13:28:37 <zulusulta> how easy is it to get a haskell job?
13:28:55 <Beelsebob> not very
13:29:21 <Beelsebob> I think I know of 3 companies that really go after Haskell coders
13:29:34 <Beelsebob> Galois, Anygma, and ... oh, maybe that's 2
13:29:47 <newsham> ?seen luqui
13:29:48 <lambdabot> I saw luqui leaving #haskell and #perl6 1d 13h 20m 23s ago, and .
13:30:00 <zulusulta> i am intrested in automated trading
13:30:05 <bjrn> You can always get a phd and teach haskell to undergraduates :)
13:30:09 <zulusulta> its seems to play a role in it
13:30:14 <zulusulta> teaching sucks!
13:30:22 <Beelsebob> teaching is *really* good fun
13:30:29 <zulusulta> you have to spoon feed people
13:30:32 <Beelsebob> I couldn't get enough of it
13:30:43 <Beelsebob> I didn't find that
13:30:54 <Beelsebob> I found I had to come up with 50 different ways to explain the same thing
13:30:56 <Heffalump> how many Haskell coders do Anygma have?
13:31:01 <zulusulta> to learn compsci all u need is c and a database
13:31:03 <bjrn> Teaching open minded people is great. Not so those who've already decided they want to become the next Carmack, and only need C++.
13:31:12 <Beelsebob> Heffalump: at the moment -- 5
13:31:21 <Beelsebob> but that's out of a total staff of 7 people
13:31:32 <Heffalump> do they have many vacancies?
13:31:46 <Beelsebob> not at the moment no, but we may do in the future
13:31:52 <bjrn> A few days ago some guy said he coded Haskell at AT&T
13:31:57 <Beelsebob> oh?
13:31:59 <Beelsebob> interesting
13:32:10 <tromp> @oeis 4,6,4,8,4,9
13:32:11 <lambdabot>  Number of squares dividing n by prime signature: A046951(A025487).
13:32:11 <lambdabot>  [1,1,2,1,2,2,3,2,1,3,4,3,2,4,4,3,2,4,6,4,4,1,4,3,5,6,4,4,2,6,3,5,8,6,5,2,6,8...
13:32:25 <Beelsebob> o.O
13:32:29 <bjrn> I don't think it was an official Haskell positions tho, he used Haskell for maintenenance tasks, iirc.
13:32:34 <Heffalump> we (Credit Suisse) have 3 or so Haskell programmers
13:32:41 <zulusulta> wow
13:32:48 <zulusulta> automated trading?
13:32:50 <Heffalump> we don't do autoamted trading, no
13:32:53 <Beelsebob> oh yeh -- I can remember credit suisse advertising
13:32:57 <Heffalump> at least not the group with Haskell programmers
13:33:09 <zulusulta> derivaties?
13:33:14 <Heffalump> yeah
13:33:28 <zulusulta> f&o
13:33:39 <Heffalump> ?
13:33:46 <zulusulta> futures and options
13:33:57 <Heffalump> rather more than that
13:34:05 <bjrn> Heffalump: You have any idea if they have haskell positions in switzerland?
13:34:11 <Heffalump> no, we don't
13:34:23 <bjrn> Ah, shame.
13:34:26 <zulusulta> that sounds like big bucks for a team lead
13:34:28 <mrsolo> from real world haskell..
13:34:29 <mrsolo> Remember that if we want to define a new variable inside ghci, the syntax is slightly different from that of a Haskell source file: we need to put a let in front.
13:34:31 <mrsolo> why?
13:34:46 <Heffalump> mrsolo: ghci behaves a bit like do notation
13:34:57 <Heffalump> after all, there's state being set up
13:35:08 <zulusulta> need to know finace, comunicate well and be driven + know hasell
13:35:18 <mrsolo> ah
13:35:32 <zulusulta> at least 100,000 usd +
13:35:54 <mrsolo> rare haskell job!
13:36:12 <Heffalump> 100K USD isn't that much given London or New York living costs.
13:36:31 <Beelsebob> no, especially considering you can get more than that just for knowing Haskell + OpenGL
13:36:36 <Beelsebob> and that's in Antwerp
13:36:36 <Guest28835> Heffalump: I live on $15 per day
13:36:37 <zulusulta> yes but is sure beats India
13:36:41 <sw17ch> Heffalump, I make half that, but i live in the midwest where living expenses are a third of elsewhere... so... :)
13:36:42 <tristes_tigres> hi
13:36:48 <nus> zulusulta: cut off haskell, and you still get a (pretty good) job anywhere
13:37:03 <tristes_tigres> There are haskell jobs out there ?
13:37:09 <zulusulta> nus: still in tech?
13:37:09 <dons> tristes_tigres: hell yeah.
13:37:12 <Guest28835> and I don't have a job.. I daydream in a field of flowers for most of the day
13:37:23 <Heffalump> Guest28835: that's your mistake :-)
13:37:29 <Guest28835> I have been trying to learn haskell because I want to write a program which simplifies equations...
13:37:34 <tristes_tigres> dons : in the US or in Europe ?
13:37:39 <dons> http://haskell.org/haskellwiki/Haskell_in_industry
13:37:41 <lambdabot> Title: Haskell in industry - HaskellWiki
13:37:44 <nus> zulusulta: if you "communicate well", you find jobs *anywhere*
13:37:45 <dons> both, of course.
13:37:54 <Beelsebob> dons: well -- I can equal the speed of the other Mandelbrot program
13:37:55 <Myoma> Guest28835: I have thought about that a bit
13:37:55 <tristes_tigres> dons: that list looks pretty scarce
13:37:59 <Beelsebob> but I use 4 cores to do it >.<
13:38:11 <Guest28835> Myoma: my idea was I have lots of versions of a function which can perform a simplification step...
13:38:12 <dons> looks ok to me, tristes_tigres :)
13:38:27 <Myoma> haskell simplify boolean expression
13:38:29 <Myoma> oops
13:38:30 <Myoma> :p
13:38:34 <Myoma> I meant to google for that ...
13:38:35 <tristes_tigres> Yeah? i have a question about simplifying? too
13:38:37 <dons> Beelsebob: that's good.
13:38:37 <Guest28835> Myoma: like.. first it parses the equation into haskell data structs
13:38:39 <Guest28835> Myoma: heh
13:38:52 * Myoma tries to find a paste that was up somewhere
13:38:55 <dons> Beelsebob: so maybe check how the erlang one is partitioning things.
13:39:00 <Guest28835> Myoma: then it would do things like make 0*anything 0 or 1*anything anything.. but it could have more complex rules too
13:39:12 <dons> term rewriting engine, eh?
13:39:22 <Beelsebob> dons: discovered an interesting thing though -- because ByteString.pack is lazy (and doesn't have an NFData instance), it can't be parallelised with parMap
13:39:30 <Myoma> Guest28835: Yes I think that is a good way, but a tricky thing is making sure that the simplyfying always terminates
13:39:35 <dons> well, you need to add an NFData instance
13:39:37 <Guest28835> Myoma: and if I can simplify equations in that way, then I should be able to write a function which integrates equations (the real goal)
13:39:51 <Guest28835> Myoma: yes! but I figure haskell is good with infinite things...
13:39:53 <Myoma> Guest28835: Cool, I have been reading about the Ricsh algorithm
13:39:55 <tristes_tigres> Fnyone read the "programming with arrows" by hughes ?
13:40:02 <Beelsebob> dons: yeh -- but that requires knowing the internal representation
13:40:12 <Heffalump> Beelsebob: fromChunks . toChunks ?
13:40:13 <dons> not so hard.
13:40:14 <Myoma> have you heard of it
13:40:15 <Myoma> ?
13:40:31 <Guest28835> Myoma: it needs to detect infinities.. like it is allowed to add +1-1 to the equation if it helps it simplify it somehow.. but it shouldn't do it otherwise
13:40:31 <Beelsebob> Heffalump: sounds like a fairly bad way to do it given that I'm trying to make this more efficient
13:40:40 <tristes_tigres> In this article there's discussion of ArrowTransformer class
13:40:54 <Heffalump> sorry, I meant toChunks . fromChunks. And toChunks should be free, AIUI.
13:40:59 <nus> dons: I vaguely (mis?)remember reading you've been poking @factorization in HS, anything you know of implementing GNFS?
13:41:05 <Myoma> <Guest28835: I found a way to be sure the simplifyer terminates by writing it as a fold
13:41:08 <Guest28835> Myoma: it's risch not ricsh I assume
13:41:08 <Heffalump> I guess you don't want the copy, though.
13:41:34 <tristes_tigres> Myoma: anything like Arrowtransformer vclass in the article ?
13:41:35 <Guest28835> Myoma: well, it can get into simplification loops too.. do you have a table?
13:41:41 * sw17ch thinks there are a lot more companies which use haskell, but don't know it :)
13:41:46 <Myoma> tristes_tigres: I have no idea
13:41:56 <Beelsebob> Heffalump: yeh, I'd rather not
13:42:01 <Myoma> Guest28835: what kind of a table?
13:43:08 <Guest28835> Myoma: a table of all the different states it has already been in so it doesn't loop
13:43:26 <Myoma> Guest28835: no, that is the beauty of it , let me show you an example
13:43:31 <Guest28835> Myoma: please do
13:43:42 <tristes_tigres> Say, one wants to define a class for simplifying expressions
13:44:21 <matthew-_> um, does someone have the logs from yesterday's ghc meeting?
13:46:20 <dmwit> tristes_tigres: ...a *class* for simplifying expressions?
13:47:21 <tristes_tigres> dmwit: like the class ArrowTransformer in the article by John Huges
13:47:37 <Myoma> Guest28835: I couldn't find the old paste but here's the basic idea http://hpaste.org/10128
13:47:59 <dmwit> tristes_tigres: I'm just surprised by the "class" requirement.  Why not just a function for simplifying expressions?
13:48:08 <dmwit> Can the expressions be of different types?
13:48:33 <tristes_tigres> dmwit: how do you know when to apply it ?
13:48:35 <Myoma> Guest28835: It's don't know what bound writing it as a fold puts on how much simplification you can do, but given that all the functions you use in the fold terminate, the fold will also terminate
13:49:05 <dmwit> tristes_tigres: I must be misunderstanding in a catastrophic way.  Apply it when you want to simplify the expression, of course.
13:49:30 <Myoma> Guest28835: (Before this I had a whole series of functions which I applied in a loop until nothing happened again, it worked but the logic of it wasn't obvious)
13:49:37 <Guest28835> Myoma: oh
13:49:42 <tristes_tigres> dmwit: I think the idea of class in the article by Hughes is to enable comipler to simplify it
13:50:07 <tristes_tigres> dmwit: like I am telling the compiler that a+a and 2*a is the same thing
13:50:13 <Guest28835> Myoma: i'm still trying to understand the paste.. sorry my haskell isn't great
13:50:20 <dmwit> tristes_tigres: oho
13:50:30 <dmwit> tristes_tigres: I don't think that kind of thing can be done in pure Haskell.
13:50:44 <dmwit> tristes_tigres: However, in GHC, you *are* allowed to write "rewrite rules".
13:50:48 <tristes_tigres> dmwit: that's the way I understand this part of the article
13:50:49 <Guest28835> Myoma: it only works for addition
13:51:01 <dmwit> tristes_tigres: Which article?  (Link?)
13:51:03 <tristes_tigres> dmwit: yes ! that must be it
13:51:11 <hackage> Uploaded to hackage: alsa-midi 0.3.2
13:51:11 <hackage> Uploaded to hackage: midi 0.0.7
13:51:11 <hackage> Uploaded to hackage: data-accessor 0.1.3
13:51:23 <bos> @seen dcoutts
13:51:24 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #darcs, #haskell-overflow and #haskell-soc. I last heard dcoutts speak 57m 12s ago.
13:51:30 <dcoutts> hia bos
13:51:33 <bos> howdy hey.
13:51:36 <tristes_tigres> dmwit http://www.math.chalmers.se/~rjmh/afp-arrows.pdf
13:51:41 <lambdabot> Title: Programming with Arrows
13:52:12 <Myoma> Guest28835: yes it is just a simplified example to illustrate the idea, One could add a Mul constructor to the Term, and the fold, and then add simplification rules -- but also you could abstract it so that it has binary and unary operators in the fold
13:52:14 <bos> dcoutts: is there anything i can do to get the binary and binary-strict packages to converge into one?
13:52:23 <Heffalump> does Henning Thielemann IRC?
13:52:24 <tristes_tigres> rewrite rules are not pure haskell ?
13:52:34 <bos> dcoutts: it seems an awful shame to have both, and binary-strict has some very nice features.
13:52:34 <Myoma> Guest28835: Do you think you will implement the Risch algorithm?
13:52:37 <Guest28835> Myoma: that is basically what I was thinking then
13:52:45 <Guest28835> Myoma: I may try to implement it
13:52:45 <Myoma> (Or what methods may you use ?)
13:53:01 <Myoma> Guest28835: That would be great!
13:53:05 <tristes_tigres> dmwit: page 31
13:53:06 <Guest28835> Myoma: I wanted to do what you are doing basically.. except with a lot more rules
13:53:44 <dcoutts> bos: right, the solution is to have the binary be based on the cont style in binary-strict, but outputting a strict bytestring is not a good approach imho, the lazy is much more general.
13:53:54 <bos> right.
13:54:05 <dcoutts> bos: the question is simply time
13:54:20 <bos> dcoutts: if i send you patches, will you have time to vet them?
13:54:29 <dcoutts> bos: not before ICFP
13:54:32 <Myoma> Guest28835: One thing which I don't think can be expressed as a fold, are situations like,  ((a + 1) + (-1)) --> a, but as you could see in the example (a + (1 + (-1))) works fine
13:54:37 <bos> ah. cooking up some papers?
13:54:42 <Guest28835> Myoma: the trouble is, I wanted to simplify stuff using trig functions too.. and things can get circular
13:54:52 <dcoutts> bos: trying to get a draft of my thesis in to my supervisor before I go
13:54:53 <Myoma> Guest28835: so one possibility is to represent associative operators as multisets
13:55:01 <bos> dcoutts: oh, good luck!
13:55:12 <tristes_tigres> Myoma: can you tell GHC to apply such rules as a part of optimization ?
13:55:12 <Myoma> Guest28835: How does trig simplification work?
13:55:13 <dmwit> tristes_tigres: Ah, this is a bit more subtle.
13:55:21 --- mode: irc.freenode.net set +o ChanServ
13:55:26 <Guest28835> Myoma: I tried to do it in scheme first.. but I gave up when I realized I was writing haskell
13:55:31 <Myoma> tristes_tigres: Yes, that's something totally different though
13:55:33 <dcoutts> bos: thanks :-)
13:55:40 <tristes_tigres> dmwit: Do I understand that the actual simplification is carried out by ghc ?
13:55:44 <Guest28835> Myoma: like, sin^2+cos^2=1 kind of rules
13:55:49 <dcoutts> bos: don and I might be able to look at it during or after ICFP
13:55:50 <bos> dcoutts: i can see how that might have you preoccupied.
13:55:53 <dmwit> tristes_tigres: No, they are not using rewrite rules.
13:55:59 <dcoutts> bos: heh, just a bit
13:56:05 <dmwit> tristes_tigres: They are adding runtime overhead in exchange for runtime introspection.
13:56:09 <bos> dcoutts: i'll drag you both into a hotel room and make you read the patches.
13:56:19 <bos> no whiskey until they're pulled.
13:56:19 <dcoutts> bos: hah, right'o
13:56:25 <Myoma> Guest28835: Do you know an example which could cause circularity?
13:56:42 <dcoutts> bos: I might select a different poison
13:56:52 <Guest28835> Myoma: it might see  (sin x)^2 / (1 - (cos x)^2) and need to simplify it to 1.. but there are 2 ways to do it
13:56:56 <tristes_tigres> dmwit: who is applying those simplification rules and when ? I thought it is the compiler
13:57:11 <dcoutts> bos: that or I'll need some serious re-education in the ways of whiskey :-)
13:57:33 <Myoma> Guest28835: Ah, I see, pehaps making the fold relational and trying every simplification could work? i.e. using a monad like [] or LogicT
13:57:40 <Guest28835> Myoma: I don't have good examples right now, but I remember in the past at least with integrating equations with trig functions in them, you can get circular quite easily
13:57:44 <Myoma> s/relational/monadic/
13:57:46 <Leimy> dcoutts: whisky > whiskey :-)
13:57:59 <bos> dcoutts: condemned to the victoria re-education camps
13:58:06 <bjrn> Can someone think of a good name for this function? I selected something at random here: http://hpaste.org/10129
13:58:13 <Guest28835> Myoma: yeah, but it should do breath first, not depth.. and maybe even needs a priority scheme so it doesn't spend much time if it is making things more complicated
13:58:20 <dmwit> tristes_tigres: It looks like the simplification rules are being done at runtime, no?
13:58:35 <dmwit> (I may also be misunderstanding the paper, as I only skimmed it quickly rather than reading carefully.
13:58:36 <dmwit> )
13:58:37 <Guest28835> Myoma: sometimes you have to make the equation uglier before it can look nice again though
13:58:41 <Myoma> Guest28835: If you used the nondeterminism idea then yeah, breadth first could work well I suppose, but if you have an infinite search space.. How can one know when to stop looking?
13:59:10 <Guest28835> Myoma: good point.. you won't
13:59:38 <tristes_tigres> dmwit: that is my question. when and how they are carried out ?
13:59:42 <Guest28835> Myoma: it could print the current best guess.. and wait for the user to decide if it should stop or not
13:59:49 <dmwit> ?index getArgs
13:59:50 <lambdabot> System.Environment
14:00:43 <Guest28835> Myoma: I will have to read a lot more about the risch algorithm
14:01:01 <Guest28835> Myoma: I have no problem writing a program which can take derivatives.. that is easy, but integration has always eluded me
14:01:21 <Myoma> Guest28835: I only found out about it yesterday, and I haven't read about its implementations/approximations but it's facinating
14:01:46 <Guest28835> Myoma: maybe your fold method would work better if it had rules to rearrange the equation..
14:01:46 <tristes_tigres> Guest: symbolic integration is a solved problem? but it is very complicated
14:01:58 <Guest28835> Myoma: my idea was to have a rule that a + b = b + a
14:02:01 <Myoma> Guest28835: I think I read on Shans site, derivation is compositional but integration isn't -- which explains why the difficulty is like that
14:02:12 <tristes_tigres> dmwit: why do you think that it is performed at runtime ?
14:02:36 <Myoma> Guest28835: Oh well one idea I had was to represent chains of associative operators (such as + * etc) as multisets
14:02:38 <Guest28835> Myoma: then you can see clearly there would be looping.. but if you blocked loops, then it could work
14:02:39 <dmwit> tristes_tigres: All the magic seems to come from introducing extra constructors to the Arrow type, then using them in the Arrow evaluator.
14:02:42 <dmwit> That's all run-time work.
14:02:52 <Guest28835> Myoma: that works too.. but it's a pain
14:03:01 <Myoma> Guest28835: oh it wouldn't be a pain in haskell :)
14:03:07 <Guest28835> Myoma: and I want to refactor things.. like a*(b+c) = a*b + a*c
14:03:16 <Guest28835> Myoma: that could just be another rule
14:03:17 <tristes_tigres> dmwit: so I can not inspect whet the simplified expression looks like
14:03:21 <Myoma> Guest28835: *nod*
14:03:39 <dmwit> tristes_tigres: Well, since everything is a function... no.
14:03:57 <dmwit> tristes_tigres: You would have to be able to print functions.
14:04:11 <Guest28835> Myoma: just write in a bunch of rules like that.. and eventually it should be able to simplify anything...
14:04:13 <tristes_tigres> dmwit: I could define instance of show for them
14:04:17 <dmwit> tristes_tigres: (Although there is a typeclass which includes a lot of the most common function types, and which implies Show.)
14:04:20 <Myoma> Guest28835: (btw I think it would be possible to lift the constructors into multisets in the fold itsself, I suppose there's some things which couldn't be done in the fold.. but I havent got any examples of them yet)
14:04:25 <dmwit> tristes_tigres: right
14:04:44 <dmwit> tristes_tigres: I think it's either Data.Dynamic or Data.Generics or so that has the thing I'm talking about.
14:04:45 <Guest28835> Myoma: but is there any advantage of using the multisets.. to me it seems like an extra complication
14:04:49 <dmwit> > id :: Int -> Int
14:04:51 <lambdabot>       Overlapping instances for Show (Int -> Int)
14:04:52 <lambdabot>        arising from a use o...
14:04:56 <tristes_tigres> dmwit: can ghc optimizer be made to simplify expressions
14:05:09 <dmwit> tristes_tigres: Yes.
14:05:18 <Guest28835> Myoma: if you have rules that says it can swap a+b to b+a, then eventually it should be able to figure everything out anyway.. maybe it is less efficient though
14:05:26 <dmwit> tristes_tigres: Do you mind my asking what you're trying to accomplish?
14:05:26 <Myoma> Guest28835: Yes it is more complicated, but a + b + c and c + b + a would be represented in the same way, which may make some things easier (while it may make others harder)
14:05:28 <tristes_tigres> dmwit: rewtie rules ?
14:05:50 <dmwit> tristes_tigres: Either with rewrite rules, or with computation in the type system (as type-system computation is done at compile-time).
14:06:09 <Myoma> Guest28835: If you have a whole AST with say, 20 +'s in it, then you have to try all 2^20 permutations
14:06:18 <tristes_tigres> dmwit: it's just some vague idea of not having to do simplifications in some DSL myself
14:06:29 <Guest28835> Myoma: right, could be more efficient
14:06:29 <Myoma> Guest28835: That's probably feasable, but I'm not sure how you'd actually _program_ it
14:06:31 <tristes_tigres> dmwit: but make GHC do them for me
14:06:53 <dmwit> tristes_tigres: Right, I was just wondering at a higher level what you're trying to accomplish.  Why do you need simplified expressions?
14:06:54 <Myoma> Guest28835: IT seems like you'd have to travers ethe whole AST numbering the operators, then flipping them all in turn, maybe there is a neater way though?
14:07:07 <tristes_tigres> dmwit: to speed up execution
14:07:22 <Guest28835> Myoma: well I wanted to just brute force at least at first..
14:07:31 <dmwit> tristes_tigres: Premature optimization, etc. etc.
14:07:38 <tristes_tigres> dmwit: or to have a human-readable expression out of some complex one
14:07:45 <Guest28835> Myoma: so yes, one of the rules would flip things around and do stuff like (a+b)+c = a+(b+c)
14:08:03 <Guest28835> Myoma: and make sure if it already had gotten to that equation that it stops.. hence a table of some kind
14:08:23 <dmwit> tristes_tigres: That is a much better reason, but simplification there will likely depend a lot on the language the expression is coming from.
14:08:51 <Guest28835> dmwit: wait.. are you guys talking about simplifying equations too?
14:08:54 <tristes_tigres> dmwit: it's some simple special-purpose DSL that does not yet exist
14:08:56 <Myoma> Guest28835: I think you could brute force in that way and have the table implicit by using a nondeterminism mnoad
14:09:17 <Myoma> tristes_tigres: Why don't you quasiquote it
14:09:41 <Guest28835> Myoma: yeah, I like it.. and the same concept could work for integration too
14:09:47 <tristes_tigres> myoma: I just may do that. Then ghc will simplify it, right ?
14:10:04 <Myoma> tristes_tigres: You implement the syntax and semantics of what is quoted
14:10:14 <tristes_tigres> Guest28835: you know that there's algorithm for symbolic integratin, right ?
14:10:30 <Myoma> tristes_tigres: so i.e. [$myawesomecompile| 1 + x |] could compile into the assembly code or whatever
14:10:33 <tristes_tigres> Myoma: right. What about simplifications ?
14:10:34 <Guest28835> tristes_tigres: I know! but this would be more fun
14:10:41 <Guest28835> tristes_tigres: really I should implement both
14:10:59 <Myoma> Guest28835: Actually I think tristes_tigres could use your simplifer :)
14:11:07 <tristes_tigres> Guest: but it is very complex and no one , as far as I know, fully implemented
14:11:16 <Guest28835> heh, since it works for anything.. even simplifying haskell code
14:11:19 <Myoma> tristes_tigres: ..so you could probably implement a version that doesn't do any simplification for the time being
14:12:00 <tristes_tigres> Myoma: it does not compile into anything
14:12:17 <Myoma> tristes_tigres: "it" ?
14:12:28 <Myoma> tristes_tigres: . being that program which you have not written?
14:12:50 <tristes_tigres> myoma: Yes
14:13:10 <tristes_tigres> myoma: it's a language for some specialized task
14:13:10 <Myoma> tristes_tigres: I certainly agree then :p
14:13:27 <tristes_tigres> myoma: I do not need to com[ile it into asm or C
14:13:43 <Myoma> tristes_tigres: Don't implement that then
14:14:08 <tristes_tigres> myoma: I do want to be able to execute it
14:14:40 <tristes_tigres> myoma: after I execute everyone making smartass comments ^-)
14:15:01 <Myoma> tristes_tigres: You've lost me, I don't know what you're talking about
14:15:36 <tristes_tigres> Myoma: perl is DSL that does not compile into anything
14:15:48 <tristes_tigres> or regexps
14:16:13 <tristes_tigres> you just use it
14:16:17 <Myoma> tristes_tigres: Why do you think regexps don't complie into anything? I know several that do
14:16:55 <Myoma> tristes_tigres: Something being compiled doesn't require you to open up a command line and wait -- it could happen during the interpretation of the lanugage the embedded language is hosted on
14:16:56 <tristes_tigres> myoma: I know too, but it is not a necessary property of DSL to cm[ile into some other language
14:17:26 <tristes_tigres> myoma: in that sense, yes, everything is compiled into assembler
14:17:32 <Myoma> tristes_tigres: If you are doing simplification on an AST, that is a compiler, you can stage it using quasiquotes -- which is why I suggested it
14:17:52 <jeffwheeler> I'm confused, installing the Haskell Objective-C bindings (HOC).
14:18:02 <Arnar> hi all
14:18:20 <jeffwheeler> $ runhaskell Setup.hs configure tells me that it cannot find the dependency HOC-1.0
14:18:33 <tristes_tigres> myoma: the simplified version in the scenario that you proposed is not accessible, right ?
14:18:38 <jeffwheeler> but running $ ghc-pkg list and $ cabal list --installed both list HOC-1.0
14:19:05 <Arnar> I'm looking for examples of how to handle fixpoints in logic..
14:19:06 <dcoutts> jeffwheeler: runhaskell Setup.hs configure does a --global install by default
14:19:20 <Arnar> i.e. I'm writing a function to evaluate the satisfaction of a logic formula..
14:19:27 <Arnar> which can be defined as a fixpoint..
14:19:27 <dcoutts> jeffwheeler: because that was always the default, we changed it for cabal-install to do per-user installs by default.
14:19:30 <Arnar> anyone?
14:19:47 <Myoma> Arnar: I'm not really sure what you mean by a fixpoint, can you show me an example?
14:20:00 <tristes_tigres> myoma: it's some internal compiler representation
14:20:13 <dcoutts> jeffwheeler: and if it's doing a global install then it's vital that it not look at any packages registered in the per-user package db as they would not be available upon installation.
14:20:16 <Japsu> > fix f
14:20:17 <dcoutts> jeffwheeler: make sense?
14:20:19 <lambdabot>   Add a type signature
14:20:24 <Myoma> tristes_tigres: The IR would be something like data Term = Var Name | Const Integer ...
14:20:31 <jeffwheeler> dcoutts: sorry, got a call
14:20:33 <jeffwheeler> one second
14:20:36 <Japsu> > fix f :: Expr
14:20:39 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
14:20:47 <quicksilver> win 20
14:20:53 <Japsu> lose 20
14:20:55 <Valodim> :t fix
14:20:56 <Arnar> Myoma: yes.. I can show an example.. do you know modal logic?
14:20:58 <lambdabot> forall a. (a -> a) -> a
14:21:10 <Japsu> modal logic *shudder*
14:21:16 <Arnar> Japsu: fix doesn't help me here.. unless I define the logic satisfaction as afunction on sets
14:21:23 <Guest28835> is there a way to make lambdabot ask itself a question so it loops...
14:21:24 <tristes_tigres> Myoma: quasiquotes is what I am thinking about, like you suggested
14:21:26 <Arnar> Japsu: which is not really feasible
14:21:27 <Myoma> Arnar: No, I only studied the usual stuff
14:21:32 <Japsu> meh
14:21:41 <Arnar> Myoma: ok.. trying to think of a good fixpoint example without using modal operators..
14:21:47 <jeffwheeler> dcoutts: okay, I apologize; didn't mean to send a message and then have to leave :)
14:21:56 <dcoutts> jeffwheeler: np :-)
14:21:57 <Arnar> Myoma: you've seen epistemic logic?
14:22:02 <Arnar> common knowledge and all that
14:22:10 <tristes_tigres> > fix (/2.0)
14:22:20 <Myoma> not really :[
14:22:25 <lambdabot>   thread killed
14:22:27 <Arnar> Myoma: no worries..
14:22:55 <Myoma> Arnar: I only really studied predicate linear and some higher order logic
14:22:57 <Arnar> basically a fixpoint in a logic formula is like recursion
14:23:31 <Arnar> which doesn't really make sense without modal operators
14:23:44 <Myoma> Arnar: I guess that is why I don't understand it.. :)
14:24:09 <Myoma> Do you just need to iterate a function until you reach a fixed point?
14:24:18 <Arnar> Myoma: yes..
14:24:23 <Arnar> Myoma: well
14:24:50 <Arnar> I'm looking for a neat way to define it on higher level
14:25:02 <Myoma> @iterateProgress f x = let fx = f x in if x == fx then x else iterateProgress f fx
14:25:03 <lambdabot> Unknown command, try @list
14:25:07 <Myoma> @let iterateProgress f x = let fx = f x in if x == fx then x else iterateProgress f fx
14:25:11 <lambdabot>  Defined.
14:25:42 <jeffwheeler> dcoutts: that gets me past the configure stage, thanks. Now I'm back at the error from before I tried redoing everything: when GHC is loading packages for compilation, it runs into "unknown symbol: '___stginit_HOC . . . Debug_", unable to load package HOC-1.0"
14:26:05 <Myoma> > iterateProgress (`div` 2) 1024
14:26:09 <lambdabot>   0
14:26:09 <Arnar> Myoma: ok..
14:26:12 <dcoutts> jeffwheeler: using template haskell ? or in ghci once the packages are installed?
14:26:13 <Myoma> there is that sort of ting
14:26:17 <Arnar> Myoma: let me try to paint the picture for you
14:26:23 <Myoma> ok
14:26:25 <Arnar> I have a state machine
14:26:31 <Arnar> basically just a directed graph
14:26:31 <jeffwheeler> dcoutts: HOC uses template haskell, afaik
14:26:42 <tristes_tigres> > fix  sandwich
14:26:44 <Arnar> in this case it happens to be a DAG (which makes things computable)
14:26:45 <lambdabot>   mueval: Prelude.read: no parse
14:27:00 <Arnar> so.. say p is a state in the machine
14:27:01 <dcoutts> jeffwheeler: does ghci -package HOC-1.0 work ?
14:27:13 <Arnar> and p as outgoing arrows with labels on them
14:27:16 <jeffwheeler> dcoutts: same error
14:27:28 <dcoutts> jeffwheeler: and you've tried re-installing HOC ?
14:27:39 <tristes_tigres> sandwich :: Bread -> Lettuce -> Salami -> Onions -> Lettuce -> Food
14:27:42 <Arnar> Myoma: I'm evaluating "does state p satisfy (logic) formula F?"
14:27:44 <jeffwheeler> I'm trying to install it now. :)
14:28:01 <Arnar> Myoma: one operator is <a>F'..
14:28:03 <dons> dcoutts: someone at galois wants to install a manpage with cabal
14:28:06 <jeffwheeler> I was getting the error as part of the installation process; I was installing HOC-Foundation, which depends on HOC.
14:28:11 <dons> dcoutts: that's not a dara-files, i guess
14:28:19 <jeffwheeler> I installed HOC in the first place with just cabal install in the root.
14:28:20 <dons> so something that will be placed in the --docdir path?
14:28:20 <dcoutts> dons: we've got no support for that atm
14:28:30 <dons> is --docdir used?
14:28:32 <Arnar> Myoma: i.e. p satisfies <a>F' iff there is an arrof from p to some p' labelled with a and p' satisfies F'
14:28:40 <dcoutts> dons: ah but a man page needs to go somewhere specific, not just docdir
14:28:45 <Arnar> Myoma: <a>. is the modal operator here..
14:28:49 <roderyk> tristes_tigres: sandwich :: Bread -> Maybe Lettuce -> Maybe Salami -> Maybe Onions -> Maybe Lettuce -> Food
14:28:56 <dons> true, but in a pinch we could fake it. :)
14:29:10 <tristes_tigres> roderyk: yeah, I guess
14:29:19 <dcoutts> dons: there's a mandir variable internally but to use it at the moment you'd need a custom Setup.hs
14:29:23 <Arnar> Myoma: let's say I want to see if there is a path from p, all arrows labelled with a -- to a state that satisfies som formula G
14:29:26 <Myoma> Arnar: I nee
14:29:30 <Myoma> Arnar: I see*
14:29:40 <Arnar> Myoma: then I can ask that question with a fixpoint:
14:29:45 <tristes_tigres> roderik: but Maybe Salami ???
14:29:57 <dcoutts> dons: you could also file a feature request
14:29:58 * tristes_tigres likes salami
14:30:04 <Arnar> does p satisfy   fix X.(G or <a>X)
14:30:17 <Arnar> Myoma: that's basically a recursion
14:30:18 <dons> dcoutts: ok, thanks.
14:30:24 <Cale> http://www.basicinstructions.net/2008/09/how-to-select-t-shirt.html -- fix tshirt
14:30:26 <lambdabot> http://tinyurl.com/5je9fx
14:30:38 <dmhouse> "Service Unavailable"
14:30:40 <dmhouse> Boo!
14:30:40 <roderyk> tristes_tigres: it's a silly concept. Any real restaurant would use sandwich :: Bread -> [Ingredients] -> Food :-)
14:30:43 <mapreduce> @src Monad
14:30:43 <lambdabot> class  Monad m  where
14:30:43 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
14:30:43 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
14:30:43 <lambdabot>     return      :: a -> m a
14:30:43 <lambdabot>     fail        :: String -> m a
14:30:56 <Zao> roderyk: Wouldn't Bread count as an ingredient?
14:30:58 <dons> Cale: btw, did you see my link to the POPL logo contest?
14:31:01 <Arnar> a way to evaluate is to check if p satisfies G, if not (since we have an or) we find a possible <a> arrow, follow it and recurse
14:31:03 <Cale> dons: yeah
14:31:08 <dons> ... :)
14:31:09 <Cale> Heh, I should remove fail from that definition out of spite.
14:31:16 <roderyk> Zao: how do you make a sandwich w/o bread?
14:31:20 <dmwit> roderyk: Surely it would be [Ingredient], not [Ingredients]. ;-)
14:31:30 <tristes_tigres> roderik: Bread-> [Ingidients] -> Money -> Food
14:31:34 <Zao> roderyk: Would  rye [] :: Food -- be a proper sandwhich?
14:31:35 <roderyk> dmwit: got ahead of myself ;-)
14:31:52 <Myoma> Arnar: so one way might be to use a nondeterminism monad to search over the whole graph at once?
14:32:10 <dmwit> sandwhence
14:32:12 <Arnar> Myoma: well.. the fact that we're searching over the graph is a property of the <a> operator
14:32:22 <Arnar> Myoma: there are other operators that behave differently
14:32:26 <dmhouse> Cale: hehe, great T-shirt.
14:32:32 <tristes_tigres> instance Bread => Rye
14:32:32 <dmhouse> There has to be a better one, though.
14:32:33 <roderyk> Zao: as long as they pay, why not? : )
14:32:38 <Arnar> Myoma: there is a way to do this at a higher level, independent of the operator
14:32:39 <dmhouse> "I'm with everyone who isn't with me"?
14:32:53 <Arnar> Myoma: I'm pretty sure it has been done before.. just looking for example code :)
14:33:03 <tristes_tigres> deriving Sandwich
14:33:48 <Arnar> Myoma: if you interpret logic formulas as sets (i.e. the formula F represents the set of states that satisfy F and no other states).. then there is a trivial algorithm
14:34:00 <Myoma> oh ?
14:34:18 <Myoma> I guess that sets may be infinite though, and then it's not computable ?
14:34:19 <Arnar> Myoma: then this becomes just an iteration
14:34:41 <Arnar> Myoma: as long as you are careful of negation, a recursive logic formula becomes a monotonic function on sets
14:35:12 <Arnar> then you just iterate that function until you reach a fixpoint (which exists due to Tarski's fixed point theorem)
14:35:34 <Arnar> careful about negation*
14:36:06 <tristes_tigres> dmwit: good point
14:36:19 <dmwit> ?
14:36:43 <tristes_tigres> dmwit instance Ingredient => Salami deriving Sandwich
14:38:06 <FunctorSalad_> @hoogle ApplicativeMonad
14:38:07 <lambdabot> No results found
14:38:11 <FunctorSalad_> @hoogle MonadApplicative
14:38:12 <lambdabot> No results found
14:38:31 <FunctorSalad_> how's the workaround to consider a monad as an applicative called again?
14:38:39 <Heffalump> overlapping instances
14:38:45 <FunctorSalad_> oh, they did that?
14:38:50 <Heffalump> did what?
14:38:57 <FunctorSalad_> use overlapping instances
14:39:05 <Heffalump> if you enable overlapping instances, you can define instance Monad m => Applicative m where ...
14:39:11 <Heffalump> if you don't, you can't
14:39:13 <FunctorSalad_> usually we tell people that that's not so good :)
14:39:18 <FunctorSalad_> yeah
14:39:18 <Heffalump> I may have misunderstood your question.
14:39:35 <FunctorSalad_> no, just surprised me because I thought they were considered problematic
14:39:41 <FunctorSalad_> (overlapping inst.)
14:39:46 <Heffalump> yes, they are
14:40:07 <Saizan_> there's WrappedMonad
14:40:38 <Saizan_> which is used to avoid the overlapping instance
14:45:13 <newsham> does anyone have TH code for generating field accessors for structures?
14:45:31 <newsham> s/structures/records/
14:46:36 <Heffalump> newsham: data-accessor-template
14:46:40 <Heffalump> or something like that
14:46:52 <newsham> ?
14:46:52 <Heffalump> annoyingly data-accessor is GPLed (and I guess -template is too)
14:47:01 <Heffalump> a hackage package
14:47:02 <newsham> is this on hackage?
14:47:13 <newsham> danke.  i dont mind GPL, I'm not looking to use, just steal ideas :)
14:56:14 <zulusulta> endorphins
14:56:22 <zulusulta> i need endorphins
14:57:41 * Cale passes zulusulta a bottle of hot sauce. This should make your body produce them.
14:58:06 <chris_st> greetings all -- a noob question: why does "map (5 -) [1,4,9,14]" produce the same results as "map ((-) 5) [1,4,9,14]"?
14:58:38 <Myoma> simply because ((-) 5) = (5 -)
14:58:41 <Igloo> (5 -) == (\x -> 5 - x) == (\x -> (-) 5 x)
14:59:29 <Saizan_> if you want (\x -> x - 5) you've to write the lambda or use (subtract 5)
14:59:59 <chris_st> But if I define (in ghci) "let subt a b = a  - b" and then do map (5 `subt`) [1,4,9,14] and map (`subt` 5) [1,4,9,14] I get different results (which is what I'd expect)
15:00:28 <Saizan_> chris_st: ((-) 5) corresponds to (subt 5)
15:00:33 <TomMD> hummm, bytestring-0.9.0.1.  Time to upgrade.  I'm somewhat surprised arch doesn't custom spin GHC builds with updated libraries.
15:00:45 <chris_st> or map (^2) [3,5,7,9]  versus map (2^) [3,5,7,9]
15:00:57 <Saizan_> and (-5) is not subtraction because of unary minus
15:01:03 <Saizan_> (-5) == negate 5
15:01:24 <chris_st> I thought putting the - in parens made it the function...?
15:01:37 <Saizan_> yeah, but it also makes it prefix
15:01:42 <Myoma> chris_st: It's true in general, just not the case of '-'
15:01:42 <FunctorSalad_> Cale: never noticed any endorphins from hot sauce :(
15:01:54 <Saizan_> so the argument you pass it is the _first_
15:02:00 <chris_st> Myoma: Well, I almost understand :-)
15:02:07 <Myoma> > (map (/ 1) [5,26], map (1 /) [5,26])
15:02:10 <chris_st> EXCEPT that '^' behaves differently
15:02:10 <lambdabot>   ([5.0,26.0],[0.2,3.8461538461538464e-2])
15:02:11 <Myoma> > (map (+ 1) [5,26], map (1 +) [5,26])
15:02:14 <lambdabot>   ([6,27],[6,27])
15:02:18 <Myoma> > (map (- 1) [5,26], map (1 -) [5,26])
15:02:20 <Saizan_> e.g. like ((^) 2) == (2^)
15:02:21 <lambdabot>       No instance for (Num (a -> b))
15:02:21 <lambdabot>        arising from a use of `negate' at...
15:02:24 <Myoma> *boom*
15:02:27 <Myoma> :t (^)
15:02:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:02:29 <roconnor> > (-(-5)) 5
15:02:31 <Myoma> (^) has a funny type
15:02:32 <lambdabot>       No instance for (Num (t -> a))
15:02:33 <lambdabot>        arising from a use of `negate' at...
15:03:00 <chris_st> Myoma: how funny?
15:03:10 <Myoma> It's not a -> a -> a
15:03:11 <Saizan_> it doesn't really matter here
15:03:45 <Botje> Myoma: that's because you can implemenet a^b with b integral very easily
15:04:09 <FunctorSalad_> and efficiently :)
15:04:23 <FunctorSalad_> (square and multiply)
15:04:36 <Botje> does the ghc implementation do repeated squaring?
15:04:45 <chris_st> Well, thanks for the help.
15:04:58 <FunctorSalad_> don't know, but it would make sense since Integral gives you (div 2) IIRC
15:05:14 <FunctorSalad_> @src Integral
15:05:15 <lambdabot> class  (Real a, Enum a) => Integral a  where
15:05:15 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:05:15 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
15:05:15 <lambdabot>     toInteger           :: a -> Integer
15:05:22 <Myoma> @keal
15:05:23 <lambdabot> #haskell needs to take its meds
15:05:25 <Myoma> @keal
15:05:25 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
15:05:33 <dmhouse> Keal quotes! I've missed them.
15:05:38 <Myoma> @keal
15:05:39 <lambdabot> bot seems useless
15:05:42 <dmhouse> More, more!
15:05:43 <dmhouse> ?keal
15:05:44 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
15:05:49 <Myoma> :D
15:05:50 <Myoma> @keal
15:05:51 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
15:05:54 <dmhouse> Anyone got the original Keal logs?
15:06:07 <Myoma> I would like to read them
15:06:07 <jeffwheeler> What is Keal?
15:06:12 <Myoma> @keal
15:06:12 <lambdabot> tomorrow i share next mathematical secrety
15:06:14 * jeffwheeler hids.
15:06:19 <jeffwheeler> * hides (fail)
15:06:31 <FunctorSalad_> that "lesbian" things doesn't parse
15:06:34 <FunctorSalad_> *thing
15:06:47 <dmhouse> ?help keal
15:06:47 <lambdabot> keal. Talk like Keal
15:07:02 <dmhouse> jeffwheeler: some idiot who was here a while back. Said some very funny things.
15:07:07 <dmhouse> ?keal
15:07:08 <lambdabot> making a bot of me is highly offensive
15:07:12 <dmhouse> Hehe.
15:07:20 <FunctorSalad_> *g*
15:07:36 <FunctorSalad_> are these actual quotes or markov?
15:07:45 <dmhouse> No, I think they're actual quotes.
15:07:53 <jeffwheeler> Those are pretty awesome.
15:07:56 <dmhouse> ?where lambdabot
15:07:56 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:08:07 <dmhouse> The source code knows more, IIRC
15:08:16 <FunctorSalad_> someone seems to dislike mathematicians ;)
15:08:16 <Cale> @keal
15:08:17 <lambdabot> i aint running that on my puter
15:08:19 <Cale> @keal
15:08:20 <lambdabot> proofs are no longer sound
15:08:25 <Cale> @keal
15:08:26 <lambdabot> bot defective
15:08:27 <Cale> @keal
15:08:27 <lambdabot> it is very easy to go off topic
15:08:42 <Cale> @keal
15:08:42 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
15:08:43 <roderyk> anyone work with HGL? I currently have a simple recursion that just collects keys in a window (getKey, isCharKey, and keyToChar) until a non-char key is pressed, but I get segfaults after a couple keypresses. Should I be using some kind of X delay/sleep() function between recursive calls to keep it sane?
15:09:01 * FunctorSalad_ goes pets is unikitten (unicorn kitten hybrid)
15:09:11 <dmhouse> ?version
15:09:12 <lambdabot> lambdabot 4.2.1
15:09:12 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:09:20 <FunctorSalad_> s/is/his/
15:09:24 <Myoma> @protontorpedo
15:09:25 <lambdabot> whera re the end user apps?
15:09:27 <Myoma> @protontorpedo
15:09:27 <lambdabot> where was haskell during th internet boom?
15:09:29 <Myoma> @protontorpedo
15:09:29 <lambdabot> how abut vs APL
15:09:35 <Myoma> haskell vs APL!
15:10:03 <Saizan_> yeah, where are the end user apps, mh?
15:10:28 <jeffwheeler> Quotes are here: http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Quote/Text.hs
15:11:04 <jeffwheeler> @stewie
15:11:04 <lambdabot> Unknown command, try @list
15:11:08 <jeffwheeler> :(
15:11:21 <dmhouse> Keal quotes source - http://code.haskell.org/lambdabot/Plugin/Quote/Text.hs
15:11:23 <FunctorSalad_> btw @list could be made more helpful ;)
15:11:43 <FunctorSalad_> (would be too long for the channel but for query)
15:11:44 <dmhouse> "Actual quotes from an asshat called Keal over Jan 12-14 2006."
15:12:07 <jeffwheeler> Surely not /all/ those quotes could have come from one day. . .
15:12:18 <dmhouse> jeffwheeler: 12-14 is three days ;)
15:12:28 <dmhouse> Also: Reappared as OrangeKid,
15:12:41 <jeffwheeler> Doh. Don't know what I was thinking.
15:15:15 <dmhouse> Originals: http://tunes.org/~nef/logs/haskell/06.01.11 http://tunes.org/~nef/logs/haskell/06.01.12 http://tunes.org/~nef/logs/haskell/06.01.13 http://tunes.org/~nef/logs/haskell/06.01.14
15:15:28 <chris_st> Wow... Keal was... just... wow.
15:15:47 <chris_st> Where should I look to find Haskell open source libraries?
15:16:02 <chris_st> I don't want to reinvent wheels...
15:16:07 <dmhouse> chris_st: hackage?
15:16:10 <dmhouse> ?where hackage
15:16:10 <lambdabot> http://hackage.haskell.org/
15:16:18 <chris_st> Thanks!
15:17:21 <dmhouse> ?brain
15:17:21 <lambdabot> I think so, Doctor. But are these really the legs of a show girl?
15:17:48 <yitz> @. vixen brain
15:17:49 <lambdabot> is that really what you want to know?
15:18:09 <yitz> @. vixen keal
15:18:10 <lambdabot> i thought you knew
15:19:11 <jeffwheeler> ?help vixen
15:19:11 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
15:23:08 <dmhouse> ?protontorpedo
15:23:09 <lambdabot> so is haskell going to redo x windows and make it better?
15:23:15 <Myoma> 23:40:32 <newsham> who wrote keal?
15:23:15 <Myoma> lol
15:24:24 <Guest28835> Myoma: I'm beginning to realize I can't even find the information needed to begin implementing the risch algorithm
15:24:40 <Myoma> Guest28835: I think it is described in a book
15:24:49 <FunctorSalad_> what does it do?
15:25:04 <Guest28835> Myoma: yeah, I need to get it.. I'm in a library
15:25:04 <roconnor> rumour has it that no one has ever implemented risch's algorithm.
15:25:13 <Myoma> Guest28835: I think it would be possible to do quite a wide range of integration using the same kinds of methods and heuristics that we do
15:25:19 <Myoma> roconnor: yeah
15:25:28 <Myoma> roconnor: And nobody wrote a knot untangler I think
15:25:33 <Guest28835> Myoma: like what we were talking about before?
15:25:56 <Myoma> Guest28835: More like the symbolic integration stuff you get in math books
15:26:40 <roconnor> oh wikipedia says this
15:26:48 <roconnor> No software (as of March 2008) is known to implement the full Risch algorithm, although several computer algebra systems have partial implementations.
15:27:04 <Guest28835> yeah
15:27:13 <Guest28835> partially implement it would be a lot of work
15:27:28 <Guest28835> I assume anyway.. I don't know anything about it since I don't have the book
15:28:51 <Guest28835> the library doesn't have it either :(
15:42:59 <Myoma> @keal
15:42:59 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
15:43:10 <dmhouse> ?keal
15:43:11 <lambdabot> proofs are no longer sound
15:43:13 <dmhouse> ?keal
15:43:14 <lambdabot> i changed my user od
15:43:18 <dmhouse> Oh these are all brilliant
15:43:19 <Myoma> I love this guy ...
15:43:20 <dmhouse> Oh these are all brilliant
15:43:23 <dmhouse> ?keal
15:43:23 <lambdabot> can GMP support KealDigit? I invent KealDigit
15:43:54 <Spark> is he a complete cock
15:44:02 <Myoma> @keal
15:44:03 <lambdabot> they dumbified you
15:44:21 <Spark> there is strong evidence of his phallic status
15:44:43 <dmhouse> Spark: take a look at all the quotes in the λb source
15:44:51 <dmhouse> http://code.haskell.org/lambdabot/Plugin/Quote/Text.hs
15:44:59 <dmhouse> (Scroll down to `kealList'.)
15:45:58 <lilac> hold on, these are quotes from an actual person?
15:47:06 <dmhouse> lilac: oh yes.
15:47:15 <dmhouse> Original logs: http://tunes.org/~nef/logs/haskell/06.01.11 http://tunes.org/~nef/logs/haskell/06.01.12 http://tunes.org/~nef/logs/haskell/06.01.13 http://tunes.org/~nef/logs/haskell/06.01.14
15:48:53 <Myoma> can you make animations with inkscape
15:49:09 <Spark> i have done, but only using a sed script
15:49:36 <Spark> basically, no
15:49:37 <malune> @keal
15:49:37 <lambdabot> can haskell compile flash animations and java apps?
15:50:37 <malune> lambdabot is a troll
15:50:37 <Myoma> @keal
15:50:38 <lambdabot> antiparsimony were 100% correct...
15:50:42 <Myoma> @keal
15:50:42 <lambdabot> i lack in verbal and social expression
15:50:50 <lilac> @keal
15:50:50 <lambdabot> intuitive != imperative
15:50:57 <dmwit> they make it green both ways once
15:51:14 <dmhouse> ?yhjulwwiefzojcbxybbruweejw
15:51:15 <lambdabot> "\""
15:51:26 <lilac> ?yow
15:51:27 <lambdabot> I have a VISION!  It's a RANCID double-FISHWICH on an ENRICHED BUN!!
15:52:28 <dmwit> whats the first thing you see when you look at a human. surface meat
15:53:06 <Adamant> ?stewie
15:53:07 <lambdabot> Unknown command, try @list
15:55:38 <malune> i'm perturbed, how do haskell compilers handle trailing (delay) s which to me should logically occur when compiling an entirely normal order evaluated language? Is there some doc somewhere I can read
15:56:11 <Myoma> malune: What
15:56:19 <dmwit> malune: delay?
15:56:54 <malune> Myoma: dmwit: yeah, as in (delay, promise and force)
15:57:15 <Myoma> malune: That is not how haskell compilers work
15:57:16 <dmwit> ah, there are no explicit laziness constructs in Haskell.
15:57:21 <dmwit> (Is that what you're talking about?)
15:57:29 <dmwit> Everything is lazy unless otherwise specified.
15:57:44 <Myoma> hi hi
15:58:07 <malune> yeah, thats precisely what I mean, if everything is lazy (or delayed), then doesn't this cause an enormous amount of delayed code which never gets evaluated?
15:58:15 <Myoma> malune: perhaps
15:58:16 <dmwit> malune: Yes!
15:58:18 <malune> (but is still in existence somewhere)
15:58:21 <shapr> hi Myoma!
15:58:25 <dmwit> malune: And there's nothing faster than code that doesn't get executed. =D
15:58:26 <Myoma> malune: But since we don't want that, we program in such a way that it doesn't happen
15:58:38 <Myoma> hey shapr:)
15:58:56 <dmwit> malune: You should note that it's not like we're keeping a copy of the unevaluated code in memory.
15:58:59 <Trinithis> hi Myoma!
15:59:03 <Myoma> hellllo
15:59:15 <dmwit> malune: Just a pointer to the code.
15:59:18 <FunctorSalad_> how do I file a problem report for a ghc documentation page? send a mail to the maintainer given at the top? (libraries@haskell.org)
15:59:26 <Trinithis> like the hello in that sienfeld episode...
15:59:39 <dmwit> malune: You might like the STG paper, it explains how GHC is implemented.
15:59:43 <malune> dmwit: so what happens to this unevaluated code? I was just watching SICP and they claimed one problem with lazy languages was that it caused this trailing accumulation of delayed thunks
15:59:58 <malune> STG paper?
15:59:59 <FunctorSalad_> (and do they want small nitpicks or not?)
16:00:05 <Myoma> malune: SICP isn't a good way to understand how lazy evaluation works
16:00:15 <dmwit> malune: Yes, if you write things incorrectly, you can create the equivalent of a stack overflow.
16:00:20 <bd_> malune: if it's not forced (ie, if the program's execution doesn't depend on it) then it sticks around until the GC detects it's unreferenced and destroys it
16:00:22 <dmwit> malune: (STG paper: http://citeseer.ist.psu.edu/peytonjones92implementing.html)
16:00:41 <bd_> malune: when it's forced, the delayed thunk is overwritten with the final result of the delayed computation
16:00:53 <dmwit> malune: But then, if you write things incorrectly, you can create a stack overflow in strict languages, too.
16:00:55 <dmwit> =)
16:01:09 <malune> bd_: that sounds like memoization
16:01:13 <bd_> malune: yep :)
16:01:39 <bd_> malune: note that GHC is clever enough to detect in some cases that a thunk will always be forced, and in such cases it can actually remove the laziness (but only if it can prove that the program's execution will not be changed by doing so)
16:02:02 <dons> yeah, i wonder what the state of lazy languages was when SICP was written
16:02:03 <dmwit> "with KealDigit quantum crackproof encryption possible" -- wut.
16:02:10 <dons> basically no analysis was possible back then.
16:02:26 <malune> dons: Miranda is the language they reference
16:02:31 <dons> right.
16:02:37 <dons> the proto-haskell interpreters
16:02:38 <int-e> who invented `seq`?
16:02:47 <dons> no strictness analysis, no optimisations.
16:03:00 <dons> int-e: that's a really good question!
16:03:16 <dons> int-e: so the Eval class in general
16:04:31 <ddarius> dons: It wasn't so much the state of the language, but the state of the language know-how.
16:05:47 <dons> int-e: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg01145.html
16:05:49 <lambdabot> Title: ADTs and strictness
16:06:01 <dons> "Suppose we had a class
16:06:01 <dons> 	
16:06:01 <dons> 	class Data a where
16:06:01 <dons> 	   seq :: a -> b -> b
16:06:01 <dons> "
16:07:05 <dons> int-e: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00837.html
16:07:06 <lambdabot> Title: Strictness in Haskell
16:07:22 <dons> "ased on this we can define Miranda's "force" and "seq":
16:07:28 <dons> so looks like it goes back further.
16:08:27 <bjrn> Is seq used in any other form than  v `seq` f v ?
16:08:54 <dons> int-e: http://www.cse.unsw.edu.au/~dons/haskell-1990-2000/msg00139.html
16:08:55 <lambdabot> Title: Polymorphic class operations
16:08:58 <sjanssen> bjrn: that is certainly a common use
16:09:03 <sjanssen> we call it $!
16:09:08 <dons> "(In some implementations it may be possible to make strict a built-in
16:09:09 <dons> function, but it serves to illustrate the point anyhow.)
16:09:09 <dons> "
16:09:23 <dons> the type of strict is
16:09:23 <dons> strict :: forall a,b. Strict a => (a -> b) -> a -> b
16:09:28 <bjrn> sjanssen: Nice, didn't know about that :)
16:12:55 <newsham> how do I get the constructor-function "Just" from TH?
16:13:00 <newsham> ie: I want  \x -> Just x
16:13:28 <Trinithis> what?
16:13:34 <Trinithis> just type in Just?
16:13:57 <Igloo> newsham: Is 'Just what you want?
16:13:57 <newsham> AppE <just> ...
16:14:07 <Igloo> Or [| Just |] ?
16:14:25 <Myoma> :t Just
16:14:27 <lambdabot> forall a. a -> Maybe a
16:14:39 <newsham> hmm.. I could use [| Just |]   but then I will have to be in Q land.
16:14:41 <newsham> but i guess that works.
16:14:42 <int-e> dons: interesting, thanks
16:14:44 <dons> i'd recommend  any student of haskell to trawl through the early 90s mailing list archives.
16:14:50 <dons> see how a lot of these decisions came to be.
16:15:06 <Trinithis> which decisions?
16:16:27 <dons> language things.
16:19:11 <chrisdone> @hoogle (a,b) -> (a -> b -> c) -> c
16:19:12 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
16:19:12 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
16:19:12 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
16:19:16 <chrisdone> duh
16:20:51 <mrsolo> ...We cannot print functions in Haskell, which is ultimately why the interpreter complained...
16:20:55 <mrsolo> never?
16:21:00 <Myoma> mrsolo: Of course we can!
16:22:38 <mrsolo> realworldhaskell wrong?
16:23:02 <Myoma> > (+1)
16:23:05 <lambdabot>       Overlapping instances for Show (a -> a)
16:23:06 <lambdabot>        arising from a use of `s...
16:23:13 <Myoma> lambdabot used to do it
16:23:17 <chrisdone> > putStrLn ""
16:23:18 <bd_> mrsolo: It's theoretically possible, but not in a useful way.
16:23:19 <bd_> > a + b
16:23:23 <lambdabot>   mueval: Prelude.read: no parse
16:23:23 <lambdabot>  mueval: *** Exception: "<IO ()>"
16:23:23 <lambdabot>  Terminated
16:23:29 <Myoma> it is possible in a useful way
16:23:38 <chrisdone> <IO ()> is a useful one
16:23:38 <Myoma> (very small values of useful)
16:23:52 <Myoma> ?go a fun show instance for functions
16:23:55 <lambdabot> http://muaddibspace.blogspot.com/2008/06/just-fun-show-instance-for-functions_27.html
16:23:55 <lambdabot> Title: Muad`Dib: Just a fun Show instance for functions
16:24:22 <Myoma> you can print out a function which is equivalent if it has finite domain and finite objects in the range
16:24:35 <bd_> heh
16:24:46 <bd_> neat, but not very useful :P
16:24:50 <bd_> particularly for partial functions
16:24:56 <Myoma> so that's what 2% of haskell functions!
16:25:04 <bd_> Or functions with infinite domain
16:25:09 <Myoma> oh they have to be computable and total to
16:25:56 <mrsolo> ok..so realworld ismostly correct
16:28:13 <Myoma> designing ffis is boring ...
16:28:51 <dmwit> You can also print the *type* of functions at runtime, given some (pretty easily satisfied) constraints.
16:29:18 <bd_> mrsolo: Well, the example of printing a function there involves brute-forcing every possible input and making a massive lookup table :)
16:29:36 <bd_> It /works/, but... it's not really generally useful :)
16:29:43 <Trinithis> What's the code for printing a function's type?
16:29:59 <dmhouse> Trinithis: in GHCi? :t
16:30:05 <Trinithis> using show
16:30:16 <dmhouse> Using Typeable?
16:30:22 <Trinithis> oh
16:30:37 <bd_> > show (typeOf [42::Int])
16:30:40 <lambdabot>   "[Int]"
16:30:50 <Myoma> > show (typeOf (\x -> x))
16:30:53 <lambdabot>   Add a type signature
16:31:11 <bd_> Myoma: (\x -> x) needs to be resolved to a concrete type before it's instantiated to pass to typeOf
16:31:13 <Trinithis> show $ typeOf id
16:31:20 <Trinithis> > show $ typeOf id
16:31:24 <lambdabot>   Add a type signature
16:31:24 <bd_> mind you, the instantiation is lazily eliminated, but it still needs a fixed type
16:31:34 <dmwit> > show . typeOf $ (id :: Int -> Int)
16:31:37 <Trinithis> oh i see
16:31:38 <lambdabot>   "Int -> Int"
16:31:41 <bd_> > show $ typeOf (let f = id; g = id (42 :: Int) in f)
16:31:44 <lambdabot>   Add a type signature
16:31:47 <bd_> > show $ typeOf (let f = id; g = f (42 :: Int) in f)
16:31:50 <lambdabot>   Add a type signature
16:31:50 <dmwit> > typeOf $ (id :: Int -> Int)
16:31:53 <bd_> hmmm
16:31:54 <lambdabot>   Int -> Int
16:31:55 <dmwit> No "show" needed, you guys.
16:31:57 <dmwit> =)
16:32:01 <bd_> monomorphism restriction I guess
16:32:14 <dmwit> No, there's no MR there.
16:32:22 <dmwit> That's the point.
16:32:30 <dmwit> f is polymorphic
16:32:34 <bd_> ahhh
16:32:36 <bd_> right
16:33:54 <lilac> is there a better name for a monomorphic type?
16:34:20 <dmwit> concrete type
16:34:26 <malune> man, the book "real world haskell" is so good! i am excited
16:34:39 <Myoma> what is the def. of monomorphic type
16:34:40 <Trinithis> has it been published yet?
16:34:57 <Trinithis> monomorphic type has no foralls
16:35:02 <mrsolo> nov the website says
16:35:07 <dmwit> Myoma: Something like, "there is exactly one type in the set of types satisfying this relation".
16:35:12 <malune> Trinithis: I'm not sure, I think its still beta
16:35:20 <lilac> what's a "ground type"? is that the same thing as a concrete type?
16:36:22 <Jedai> malune: It's finished though they're still modifiying it a little bit, the publication shouldn't be too far off (and I'll buy it for sure)
16:36:53 <lilac> dmwit: i would think something generative would be better
16:37:07 <Myoma> @w80 generative
16:37:20 <lambdabot> *** "generative" wn "WordNet (r) 2.0"
16:37:20 <lambdabot> generative
16:37:20 <lambdabot>      adj 1: having the ability to produce or originate; "generative
16:37:20 <lambdabot>             power"; "generative forces" [syn: {productive}] [ant:
16:37:20 <lambdabot>             {consumptive}]
16:37:22 <lambdabot> [4 @more lines]
16:37:26 <malune> Jedai: yeah i am definitely buying it. Having read the first few chapters, its the best Haskell book i've found. And the exercises are great.
16:37:43 * dmwit notes that he is just now reading TaPL and has not gotten to the polymorphism chapter yet
16:37:55 <gwern> "When I first heard of Ruby on Rails, I wanted to start a project called "Haskell on Heels", but then again I didn't need that. Just liked the name."
16:38:58 * Botje pictures lambdabot in high heels
16:39:02 <Botje> *rrr*
16:39:51 <bd_> gwern: Ruby's already got Shoes, you'll need to think of something more original
16:40:02 <bd_> maybe 'Haskell on Helmets'?
16:40:22 <unenough> Haskell on Heroin
16:40:28 <JimCrayne> lol
16:40:52 <Olathe> Waskell
16:41:23 <unenough> maybe if it's called iHaskell it will become popular
16:43:06 <dmwit> the Haskell Rascal
16:43:14 <mapreduce> iCurry
16:43:59 <unenough> is there a Haskell for Dummies
16:44:25 <unenough> they would have to re-define "Dummies" (i.q. < 160)
16:44:26 <roconnor> Mmm, modular monad transformer
16:44:51 <roconnor> sweet, mtl-1.1.0.1
16:45:11 <Myoma> I didn't get the modular monad transformer stuff
16:45:37 <roconnor> oh
16:45:47 <roconnor> that was just a link to the existing mtl
16:45:49 <roconnor> :/
16:45:55 <Myoma> how it is different from normal mtl
16:46:33 <roconnor> It doesn't require O(n^2) instance delcarations
16:46:41 <roconnor> is my understanding
16:46:44 <Myoma> ok
16:48:32 <roconnor> I was disappointed with the MTL paper because the operations for the monads seems arbitary, and in some cases simply wrong
16:48:39 <roconnor> there were no laws with the operations
16:49:01 <roconnor> so I didn't know what a MonadWriter really is.
16:49:15 <roconnor> It sounds like this might help.
16:49:57 <roconnor> I wonder if he will remove/fix the suspicious pass operation
16:50:40 <bd_> MonadWriter is something that lets you add together a bunch of stuff, for some definition of add :)
16:51:09 <roconnor> bd_: have you ever used pass?
16:51:13 <bd_> yes
16:51:23 <bd_> let me find where I used it :)
16:51:58 <roconnor> there is no MonadWriter w (ContT r m), and I blame pass for this.
16:52:33 <bd_> hmm
16:52:54 <Saizan_> ?type pass
16:52:56 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
16:53:06 <bd_> roconnor: If you use callCC to implement a loop, what should be done with the inner Writer?
16:53:27 * roconnor bets bd_ did something like pass (liftM (,f) x)
16:53:55 <Saizan_> roconnor: i think i've implemented pass simply by running the m (a,w -> w) with return as continuation
16:54:23 <bd_> wait, no, I did: censor (const []) . listen
16:54:33 <bd_> not pass
16:54:50 <roconnor> @type censor
16:54:52 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
16:55:11 <bd_> @src censor
16:55:11 <lambdabot> Source not found.
16:55:14 <roconnor> bd_: ya, I'd be happy if censor was part of the signature rathre than pass
16:55:27 <bd_> censor makes more sense imo :)
16:55:27 <roconnor> censor is something that I think I could work with.
16:55:31 <bd_> hmm
16:55:53 <bd_> ah
16:55:59 <roconnor> and I bet is how pass is used in ever haskell program in hackage.
16:56:01 <bd_> I see why it can't be implemented otherwise
16:56:18 <bd_> wait
16:56:22 <bd_> maybe it can with MonadFix
16:56:32 * roconnor is still wrapping his head around the callCC question.
16:56:49 <roconnor> continuations make me dizzy
16:57:16 <bd_> pass m = fmap fst . mfix (\(_, modF) -> censor modF m)
16:57:17 <Saizan_> modular monad transformers?
16:57:18 <bd_> I think
16:57:26 <bd_> (untested :)(
16:58:13 <bd_> actually
16:58:20 <bd_> hmm, doesn't typecheck
16:58:42 <roconnor> bd_: Isn't doesn't callCC defined for any ContT m ?
16:58:57 <roconnor> what it does for the writer monad is whatever it does.
16:59:02 <lucca> too many verbs
16:59:53 <roconnor> Saizan_: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111
16:59:57 <lambdabot> Title: FP Lunch » Blog Archive » Modular Monad Transformers
17:02:06 <bd_> roconnor: right, but you'd have to examine its effects when used with the underlying monad to decide how to wrap it
17:02:28 <roconnor> that's true for all monad transformers :)
17:03:02 <bd_> hmmmm
17:03:07 <bd_> :t  \m -> liftM fst mfix (\p -> censor (snd p) m )
17:03:09 <lambdabot> forall a a1 w. (MonadWriter w ((,) a), MonadFix ((,) a)) => (a, (a1, w -> w)) -> a
17:03:16 <bd_> why is this turning into a ((,) a) instance?
17:03:25 <Olathe> @src censor
17:03:26 <lambdabot> Source not found. Are you on drugs?
17:03:52 <bd_> roconnor: anyway, censor is less powerful than pass
17:04:04 <roconnor> yes
17:04:12 <roconnor> but it is the only way that pass is used
17:04:27 <bd_> roconnor: One option would be to just use a state monad
17:04:41 <bd_> It would be easy enough to make a newtype wrapper that makes state act like writer
17:04:51 <roconnor> and if censor was defined in MonadWriter instead of pass, then ContT (Writer w)  would be an instance of MonadWriter.
17:06:21 <roconnor> or more importantly ContT mw would be an instance of MonadWriter for any mw that is an instance of MonadWriter.
17:06:33 <bd_> aha:
17:06:37 <bd_> :t :t \m -> mdo { (rv, modF) <- censor modF m; return rv }
17:06:38 <lambdabot> parse error on input `:'
17:06:38 <bd_> :t \m -> mdo { (rv, modF) <- censor modF m; return rv }
17:06:40 <lambdabot> forall w (t :: * -> *) t1. (MonadWriter w t, MonadFix t) => t (t1, w -> w) -> t t1
17:06:53 <nha_> wow i diddnt know (,) was a function haha
17:06:56 <bd_> evil, but works :)
17:07:01 <bd_> I think.
17:07:04 <bd_> (also untested ;)
17:07:11 <roconnor> bd_: it has the right type
17:07:22 <Pseudonym> So it must work!
17:07:29 <bd_> I'm feeling too lazy to test it right now :)
17:08:01 <bd_> but yeah, ContT doesn't seem to lend itself to MonadFix-ification much
17:08:08 <Pseudonym> This is a new instance of Knuth's Excuse.  I've only type checked, I haven't tested it.
17:08:10 <roconnor> Pseudonym: :D  It's pretty easy to write broken code of the write type with fix and presumably mfix as well.
17:08:16 <roconnor> s/write/right/
17:08:30 <bd_> true
17:08:56 <bd_> but this shows why pass is more powerful than censor in the absense of MonadFix
17:09:39 <roconnor> More powerful isn't always better
17:09:50 <roconnor> more powerfull means fewer instances
17:10:31 <bd_> Well, there are instances of MonadWriter which have pass but not MonadFix... :)
17:10:36 <bd_> so MonadFix is 'too powerful'
17:10:53 <FunctorSalad_> learning parsec... say I have "(try x) <|> y". if x fails, then y is silently tried, right? but is there a way to make the whole thing fail if some horrible error is encountered in x?
17:11:57 <Myoma> you could have x succeed, but return a horrible thing
17:12:04 <FunctorSalad_> =)
17:12:16 <Myoma> (and case on it)
17:12:18 <Saizan_> and call pfail if that happens
17:12:30 <bd_> @hoogle pfail
17:12:30 <lambdabot> Text.ParserCombinators.ReadP pfail :: ReadP a
17:12:30 <lambdabot> Text.ParserCombinators.ReadPrec pfail :: ReadPrec a
17:12:32 <Cale> FunctorSalad_: Well, the idea behind (try x) is that the parser consumes no input if parsing x fails. However, I believe parsec also has exceptions, so you could throw an exception?
17:12:38 <luqui> eg. ContT (Writer w)
17:12:38 <preflex>  luqui: you have 1 new message. '/msg preflex messages' to read it.
17:12:50 <Saizan_> or pzero, or mzero, or what is called :)
17:13:09 <bd_> Saizan_: fail? :)
17:13:16 <FunctorSalad_> Cale: exceptions seperate from monadic fail?
17:13:37 <Saizan_> Cale: (<|>) will "catch" the exceptions, iirc
17:13:40 <Cale> FunctorSalad_: yeah. (and monadic fail is just evil, use MonadPlus or the parser combinators)
17:13:51 <bd_> FunctorSalad_: You put a ContT on top of the parsec monad, and wrap try in something like:
17:14:56 <bd_> try' m = do { old <- getState; rv <- callCC $ (\ret -> setState (WrapperNewtype ret); fmap Right m }; setState old; case rv of Left s -> old rv; Right v -> return v }
17:15:18 <bd_> er, (do { \ret .... });
17:15:34 <bd_> downside is now you need to lift all your parsec combinators
17:15:35 <FunctorSalad_> maybe I should say what the context is :) say x parses a start tag, then a string, then an end tag. if there is no start tag, it should just fail. but if there is a start tag but no end tag, an error should be thrown to toplevel. maybe there's something simple I'm overlooking
17:16:03 <Philonous> :t curry ketchup
17:16:05 <lambdabot> forall a b. a -> b -> a
17:16:14 <FunctorSalad_> bd_: thanks but ContT would be a first time too... one after the other :)
17:16:17 <bd_> FunctorSalad_: tag = do { tagName <- startTag; contents <- manyUntil tag (endTag tagName) } or something?
17:16:25 <bd_> I ... think manyUntil requires the ending element
17:16:47 <bd_> manyTill*
17:16:55 <bd_> :t manyTill
17:16:56 <lambdabot> Not in scope: `manyTill'
17:17:06 <bd_> :t Text.ParserCombinators.Parsec.Combinator.manyTill
17:17:08 <lambdabot> forall tok st a end. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st end -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
17:17:17 <FunctorSalad_> bd_: yes. the question is how manyTill fails if it fails (I should just try it ;))
17:17:33 <bd_> try it :)
17:18:48 <Saizan_> FunctorSalad_: can't you just use try only on startTag instead of the whole x?
17:19:29 <Saizan_> FunctorSalad_: so once you've parsed startTag you've commited on that branch
17:20:40 <dobblego> can you make GHCi be explicit with forall quantifiers?
17:20:51 <luqui> dobblego, :set
17:20:57 <luqui> gives you a whole bunch of options
17:21:00 <luqui> (that's one of them)
17:21:04 <dobblego> luqui, thanks
17:21:40 <FunctorSalad_> Saizan_: hmm... so if (try start) >> (manyTill end) fails in the start phase, it won't have consumed any input?
17:21:55 <dmwit> correct
17:22:02 <FunctorSalad_> that should work then
17:22:09 <dmwit> orrr.... no
17:22:34 <Saizan_> the problem is if it fails at the first token of (manyTill end)
17:22:52 <Saizan_> since i think that won't consume any input, but you want it to fail horribly
17:22:53 <dmwit> s/if it fails/if it doesn't fail/
17:23:12 <dobblego> there is a GHCi option -fno-print-explicit-foralls but it already doesn't print explicit foralls?
17:23:54 <Saizan_> no, wait, you will consume the startTag input, so (<|>) won't use y
17:24:11 <Saizan_> however test this, i've not used parsec so much :)
17:24:34 <dmwit> FunctorSalad_: (try start >> manyTill end) <|> y -- almost certainly does not do what you want, sadly
17:24:37 <dobblego> the GHC manual says that explicit foralls are printed, yet my observations suggest this is not true, wtf?
17:24:44 <Saizan_> dmwit: why?
17:25:06 <dmwit> FunctorSalad_: If "start" fails, it reduces to "manyTill end <|> y".
17:25:14 <dmwit> err... @Saizan_
17:25:32 <FunctorSalad_> that's unexpected
17:25:37 <Saizan_> really?
17:25:53 <Saizan_> so try masks error?
17:26:03 <dmwit> try acts as if its argument consumes no input when it fails.
17:26:26 <Saizan_> but it still fails.
17:26:30 <Saizan_> i thought
17:26:41 <dmwit> oh... that might be right
17:26:42 <FunctorSalad_> what's the value of the try then?
17:26:50 <EvilTerran> yes, it still fails
17:26:52 <dmwit> Never mind me. =P
17:27:08 <EvilTerran> try just means that, even if the parameter did consume input, you can still fall through a <|>
17:28:03 <mrsolo> very impress with real world haskell so far :-)
17:29:15 <FunctorSalad_> in do { value <- try start; ... }, value will be of type "a", won't it? so what's value if start fails? undefined?
17:30:14 <Myoma> we should reinvent the JVM using dependent types for type safety
17:30:16 <FunctorSalad_> (where a is the a in Parser a)
17:30:20 <int-e> FunctorSalad_: there won't be a value
17:30:25 <Myoma> that way we can remove silly things like checkcast
17:30:31 <mrsolo> it, is that ghci only variable?
17:31:01 <Myoma> by 'we' I mean someone else - who actually has a chance of doing it
17:31:02 <int-e> FunctorSalad_: if start fails, the whole expression fails. 'try' just allows parsec to backtrack to the beginning of start if start fails
17:31:33 <FunctorSalad_> int-e: ok, that is what I want it to do I think...
17:41:28 <Cale> http://www.youtube.com/watch?v=g47V6qxKQNU -- new Catsters videos up :)
17:41:29 <lambdabot> Title: YouTube - General limits and colimits 1
17:43:02 <dobblego> is it possible to get explicit foralls in GHCi? I see only lies
17:43:03 <Olathe> Cale: Are there any Haskell packages or whatever that will do stuff like polynomial factorization and other algebra ?
17:43:19 <Cale> dobblego: -fglasgow-exts ?
17:43:37 <dobblego> Cale, that works, oddly
17:43:41 <Cale> Olathe: hmm, I'm not sure about polynomial factorisation.
17:44:33 <Cale> Olathe: You could look around on Hackage... there's a bit of stuff.
17:44:59 <Olathe> Alright, I'll check there. Thanks :)
17:45:38 <malune> are there any good haskell teach yourself videos?
17:46:45 <thetallgu1> not that I know of, but there SPJ's OSCon talk from 2007 was quite accessible to people outside the FP community
17:47:17 <malune> thetallgu1: yeah I've seen that, is there anything closer to university lectures?
17:47:35 <thetallgu1> not that I know of.
17:48:10 <malune> :<
17:48:54 <mmorrow> Olathe: there's this, but i don't know much about it. http://www.haskell.org/docon/
17:48:55 <lambdabot> Title: DoCon the Algebraic Domain Constructor
17:51:35 <TomMD> So when I'm getting from darcs.h.o and it stops on a random patch can I wait this out or will it never start going again?
17:51:53 <TomMD> The first time I waited about ten minutes and it didn't get any further.
17:52:15 <mmorrow> whenever that happens i just kill first ask questions later
17:52:36 <mmorrow> and then try to get it by other mean / try again
17:52:39 <TomMD> That should be lambdabots @faq answer.
17:52:59 <Myoma> @nixon
17:53:00 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
17:54:01 <chrisdone> can anyone write this better? http://hpaste.org/10130
17:54:04 <mmorrow> TomMD: ha
17:54:17 <chrisdone> other than just translating directly to a regex library or w/e
17:54:29 <mmorrow> hiya Myoma
17:55:21 <chrisdone> I think parsing the wild card string with parsec, and producing a new parser from it, would be totally sweet, but maybe OTT
17:56:16 * chrisdone tries anyway
17:57:34 <mmorrow> parsers like the one in that paste are super fast
17:58:37 <Myoma> hey mmorrow :)
17:58:56 <mmorrow> how's chess?
17:59:13 <Myoma> I haven't done anything since I figured out the right HTML yet
18:00:02 <Myoma> I'm hoping I will find some chess library so I don't have to write all the rules out myself
18:00:04 <mmorrow> heh, that was a pretty slick page
18:00:31 <mmorrow> oh, yeah that'd be rough.
18:00:53 <mmorrow> hmm, i wonder how that's even organized
18:01:13 <mmorrow> or if there's one "common" way it's done or something
18:01:22 <Myoma> I doubt it :p
18:02:08 <mmorrow> yeah
18:02:49 * Myoma is mostly unrolling loops in some java code
18:03:05 <mmorrow> haha, awesome.
18:03:29 <mmorrow> by hand?
18:03:50 <Myoma> in my head
18:03:59 <Myoma> I'll code it later
18:04:32 * mmorrow had a completely different picture in his head of what was happening
18:04:36 <Myoma> hehe
18:04:39 <mmorrow> ha
18:08:53 <Olathe> mmorrow: Thanks :)
18:12:02 <bos> @seen dons
18:12:03 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 1h 40m 8s ago.
18:15:44 <chrisdone> lojbot: w *is*
18:15:44 <lojbot> entry ``*is*'' not found, or invalid
18:15:58 <chrisdone> ;_;
18:16:13 <chrisdone> lojbot: d *is*
18:16:13 <lojbot> gismu {badna}, glossing to {banana}: $x_{1}$ is a banana/plantain [fruit/plant] of species/breed $x_{2}$. (See also {grute}.)
18:16:14 <lojbot> 2679 more results. use the more command
18:16:32 <chrisdone> mmorrow: doesn't really break a sweat. fast enough
18:20:57 <dons> bos
18:22:40 <wman> hello, is any1 happs-savvy awake ? ;-)
18:22:40 <bos> hey hey
18:22:49 <bos> dons: what's happening with the haskell platform?
18:23:10 <dons> we're hammering it into shape. the meta-package lives at code.haskell.org/haskell-platform
18:23:27 <dons> there's a new hackage written, running on code.haskell.org, that tracks build reports, and does more QA.
18:23:51 <dons> and we're putting together a script to make a .tar.gz from the metapackage -- an equivalent of extralibs.
18:23:56 <dons> that'll be hp 1.0
18:23:58 <TomMD> is that based on happs (can't remember what that ones called)?
18:24:02 <dons> yep
18:24:09 <dons> http://code.haskell.org:5000/
18:24:10 <lambdabot> Title: Index of /
18:25:11 <dons> bos, does that clarify things? basically, hp 1.0 will be extralibs, but produced via the metapackage
18:25:21 <dons> then we go into a 6 monthly addition/review/release cycle
18:25:27 <bos> nice.
18:25:28 <dons> independent of ghc releases
18:26:07 <bos> does the metapackage have some sort of familiar representation? is it e.g. a new piece of cabal functionality?
18:26:24 <dons> the only change is that it is a dependency only package
18:26:29 <dons> so it provides probably only docs.
18:26:35 <dons> but you can: $ cabal install haskell-platform
18:26:36 <bos> i see.
18:26:40 <dons> and get the real deal.
18:26:41 <bos> very nice.
18:26:52 <dons> yeah, then we do meta-things like tracking the status of each distro in supporting it
18:26:56 <bos> and it's tied to specific versions of each package?
18:27:02 <dons> yeah.
18:27:06 <bos> rather than ranged versions? cool.
18:27:14 <dcoutts> bos: like a gnome release
18:27:17 <dons> its a specific release set.
18:27:28 <bos> so you're under the gun to ship this around or before the 6.10.1 RC?
18:27:41 <dons> we just need to have an extralibs -matching tar.gz
18:27:49 <dons> distros can then support ghc as is
18:27:58 <dons> but the full platform dev cycle starts after ghc
18:28:03 <dons> and distro support will be independent.
18:28:25 <bos> ok, so 6.10.1 will have a traditional extralibs, just built with the platform tools?
18:28:41 <dons> yep.
18:28:47 <bos> we could really do with a distro-packagers list.
18:28:50 <dons> ghc + core is the ghc release. they'll provide an extralibs.tar.gz
18:29:05 <dons> yeah, its very unclear how haskell is supported on each platform.
18:29:14 <dons> tracking that, and awarding visible brownie points, should help.
18:29:20 <bos> it's also unclear to platform owners what's going on :-)
18:29:28 <dcoutts> heh
18:29:31 <dons> yes, that's a concern.
18:29:34 <bos> a central point of communication would help with that.
18:29:40 <dons> we need to be a bit more public about getting out what the situation is.
18:29:41 <dcoutts> bos: right, that's one point of the platform
18:29:44 <dons> spj's been asking for that.
18:30:01 <bos> cabal-devel seems to be consumed with this endless silly discussion over whether cabal is a dessert topping or a floor wax.
18:30:04 <dcoutts> bos: just like gnome, to tell people what it is they need to distribute
18:30:11 <bos> dcoutts: yes.
18:30:28 <bos> who wrote the happsified version of hackage?
18:30:36 <dcoutts> bos: heh, yeah, well ghc-users, on cabal-devel we tackle serious subjects like patches :-)
18:30:47 <dcoutts> bos: Lemmih and me
18:31:13 <dcoutts> Lemmih visited Well-Typed HQ for a few weeks and we hacked on it in the evenings
18:31:34 <bos> dcoutts: personally, i'm very happy with Build.Simple and the general direction cabal has taken. i like the idea of making it more modular, too. but incorporating both build and other metadata is important, and you've got that right.
18:31:34 <dcoutts> I'm pretty pleased with it as an architecture, I think it'll be more extensible
18:31:44 <bos> ah, cool.
18:31:50 <bos> happs proving OK to work with?
18:31:53 <dcoutts> yeah
18:32:04 <dcoutts> at least with guidance from one of the main authors :-)
18:32:15 <dcoutts> the docs are terrible, but the api is good
18:32:18 <dons> hopefully it'll be as stable as hpaste -- that's been remarkably reliable, so i'm hopeful.
18:32:59 <dcoutts> so far it's pretty light on memory use
18:33:02 <bos> time to send the monthly nag to augustss to see if i can get his latest llvm changes.
18:33:59 <bos> dcoutts: are you going to be at ICFP?
18:34:15 <dcoutts> bos: yep
18:34:26 <bos> cool.
18:34:32 <dcoutts> bos: you're going to teach me about whiskey remember? :-)
18:34:38 <bos> :^)
18:34:46 <dons> hehe
18:34:53 <dcoutts> try and convince me it's not just water filtered through a peat bog
18:35:01 <dons> oh boy.
18:35:14 <bos> it's filtered through a totally yummy peat bog!
18:35:19 <TomMD> ... I really didn't understand what I was missing.
18:35:24 <Pseudonym> dcoutts: Of course not.  It's also been stuck in rotting wood for years.
18:35:28 <TomMD> ICFP == Whisky.
18:35:38 <TomMD> *whiskey
18:35:41 <dons> apparently, Tom. you're missing out! :)
18:35:49 <bos> i could also school you in cachaca, which is made from agribusiness waste.
18:35:56 <dcoutts> hah hah
18:35:57 <Pseudonym> This kind of reminds me of homeopathy.  It's not just water, it's also been shaken!
18:36:27 <dcoutts> bos: you make it sound so appetising
18:36:28 <dmhouse> dcoutts: just think about what eggs are...
18:36:56 <dcoutts> dmhouse: yeah, I know
18:37:12 <dcoutts> it's not that I'm averse to eating peat bogs because they're dirty or something
18:38:31 <bos> once they've been sitting in poison for long enough, the dirt hardly matters.
18:39:48 <Pseudonym> I have a problem with drinking something that really should be used to clean a cut.
18:40:04 <Pseudonym> Oh, wait, that's vodka.
18:41:12 <dmhouse> Or... water.
18:43:05 <wman> anybody knows how to stop happs from mangling my diacritic characters ?
18:43:46 <wman> i tried to serve cp1250 - no luck, i tried converting to UTF-8, its even worse ;-)
18:44:21 <TomMD> rss and HAppS-? had conflicting dependencies for versions of HaXML when installing hackage-server on a clean system.
18:44:43 <Saizan_> wman: are you setting the encoding properly?
18:44:49 <bos> whoa, binary-strict can do alternative parsing.
18:45:07 <Saizan_> wman: in the http headers or in the html
18:45:12 <TomMD> Fixed by manually installing an older version of rss (3000.0.0), fyi.
18:45:37 <dcoutts> bos: yeah, continuations are great. I want to do that. I don't think it costs much performance.
18:45:38 <Saizan_> bos: yeah, it supports errors :)
18:45:41 <wman> how it's done properly ? like meta ! [....] ?
18:46:07 <bos> dcoutts: from reading the code, it's free if you don't use it.
18:46:31 <dcoutts> bos: well, the cost of constructing new continuations and passing them around, but yeah, not so expensive
18:46:53 <bos> but the continuations are already used for partial results, so the added cost of supporting alternatives is zero.
18:47:01 <dcoutts> bos: we originally didn't put in decent error handling because we were worried about the cost, but as we've learnt more about cont monad styles that's evaporated
18:47:22 <bos> the partial result bit is the killer app for me, but alternatives-for-free doesn't hurt.
18:47:43 <dcoutts> bos: our first experience was in binary too actually, that using cont monad for the serialisation optimises really well, most continuation constructions get inlined.
18:47:45 <Saizan_> wman: <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <-- like this
18:48:53 <bos> isn't the current Builder just a difference list?
18:49:09 <wman> i tried that, for cp-1250 and utf-8. is there any way to stop it from converting characters into the &#...; form ?
18:50:15 <Olathe> How do you get lambdabot to tell you what module something's in ?
18:50:28 <Saizan_> wman: it depends on how you're constructing the output, really
18:50:44 <Saizan_> ?index foldl'
18:50:45 <lambdabot> Data.List
18:51:47 <Olathe> Thanks :)
18:52:16 <wman> saizan: HDBC-ODBC -> String -> Iconv -> Text.XHTML -> toResponse
18:52:18 <TomMD> Starting compiling hackage-server was pretty easy.  It start in a blink of an eye, but I'm not yet sure how to configure it.
18:53:00 <TomMD> dcoutts: If I were to figure out hackage-server and blog about building/configuring ones own 'hackage' would the info be obsoleted too soon?  This is assuming I figure out the config.
18:53:44 <haskellian> id i want to create a new syntax, like [1,3..10] -> [1,3,5,7,9] do I have to do that "outside" the langage then? or is there some macro-like functiona  la lisp?
18:54:08 <wman> might as well try to set the page encoding to cp852 (the original) and see what happens ;-)
18:54:36 <TomMD> > [1,3..10]
18:54:40 <lambdabot>   [1,3,5,7,9]
18:54:41 <Saizan_> wman: if you're using Text.XHTML i suggest to feed it a String of unicode codepoints and use latin1 as the encoding in the page
18:55:01 <haskellian> wrong forum, meant to aks in ocaml lol
18:55:11 <TomMD> :-)
18:55:30 <Saizan_> wman: because Text.XHTML escapes chars > 255 and latin1 corresponds to unicode codepoints for <= 255
18:56:26 <Armored_Azrael> Is there a symbol for the maximum value of the Int datatype on a system?
18:56:32 <wman> i thought UTF-8 had all chars < 255
18:57:36 <Saizan_> no utf8 is byte-compatible with unicode only for ascii
18:57:36 <bos> wman: nope.
18:58:27 <Armored_Azrael> a la INT_MAX in C?
18:58:42 <Saizan_> > maxBound :: Int
18:58:45 <lambdabot>   9223372036854775807
18:58:56 <Armored_Azrael> Thanks
19:00:45 <wman> to rephrase it more correctly, utf-8 uses series of 8-bit values to encode possibly multi-byte characters, sounds better ?
19:02:11 <wman> would it be possible to block any attempts at conversion/html-escaping done on the string i'm passing to it ?
19:03:00 <wman> force it to just swallow the string i'm shoving down it's throat and render it verbatim ?
19:03:29 <Saizan_> wman: look in the haddock, there's something like primHtml for that iirc
19:03:37 <dcoutts> TomMD: if you don't mind I'd hold off a few days, so I can fix some stuff before announcing it properly (and having something that can actually be cabal-installed)
19:03:56 <wman> thx
19:04:13 <dcoutts> TomMD: but in the mean time, do play with it, do the install, import the data, play around and tell me what I have to fix :-)
19:05:10 <dcoutts> TomMD: but certainly in the end one of the points was to make it easier to set up new instances, so yeah I'd be happy for you to write about it
19:05:36 <dcoutts> TomMD: I'm actively working on it, so it shouldn't be too long to wait
19:06:36 * dcoutts :: Sleep -> IO ()
19:08:04 <TomMD> @tell dcoutts I'll hold off.  One thing to note is, when installing from a clean setup, the version of HaXML required by rss and that required by one of the HAppS packages conflict.  I needed to install rss-3000.0.0 to get it to build.
19:08:05 <lambdabot> Consider it noted.
19:13:08 <Myoma> @w80 kepler rosette
19:13:10 <lambdabot> *** "Kepler" wn "WordNet (r) 2.0"
19:13:10 <lambdabot> Kepler
19:13:10 <lambdabot>      n : German astronomer who first stated laws of planetary motion
19:13:10 <lambdabot>          (1571-1630) [syn: {Johannes Kepler}, {Johan Kepler}]
19:13:10 <lambdabot>  
19:13:12 <lambdabot> [9 @more lines]
19:18:42 <Olathe> Is there a way to add a function that has different implementations for each Num instance ?
19:19:25 <dons> using type classes?
19:19:38 <Jedai> Olathe: Not directly, but you can just create a Num2 typeclass
19:20:29 <Olathe> Ahh, thanks.
19:20:30 <Jedai> Olathe: anyway you would need to write one method for every instance even if you could "add a method" to Num
19:20:53 <Olathe> How do you say that, say, Integer is an instance of Num2 ?
19:21:02 <Jedai> Olathe: If your Num2 inherit from Num, you can use all the method from Num in the method for Num2
19:21:25 <Jedai> instance Num2 Integer where yadayada
19:21:31 <Olathe> Ahh, thanks.
19:21:56 <Jedai> Do you know typeclass basics ?
19:23:33 <Olathe> Not really.
19:24:40 <Olathe> @hoogle (Integral a) => Int -> a
19:24:41 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:24:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:24:41 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
19:24:42 <Jedai> Olathe: Learn about it, it's one of the feature that sets Haskell apart from some of the other functional languages, it gives you some pretty sweet overloading and you can do some crazy things once you really master them
19:24:55 <Olathe> Alright, I will :)
19:25:19 <Olathe> I'm going through RWH at the moment, so I'll get to them eventually.
19:25:38 <Jedai> @type fromIntegral
19:25:40 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:26:27 <Olathe> > let a :: Int -> Integer; a n = fromIntegral n in a (5::Int)
19:26:31 <lambdabot>   5
19:26:37 <Olathe> :t let a :: Int -> Integer; a n = fromIntegral n in a (5::Int)
19:26:39 <lambdabot> Integer
19:27:34 <araujo> haskell.org down?
19:27:37 <cads> hey, you guys have any suggestions for (very) introductory paper in category theory?
19:28:18 <cads> umm, papers, even
19:28:46 <cads> Things I'e found jump directly to notation I've neer seen defined before
19:29:00 <araujo> nvm
19:29:04 <araujo> very slow here
19:30:04 <mgoldman> So, I'm trying to build the latest cabal library (Cabal-1.1.6) and when try to build, it tells me that Text.PrettyPrint is in the hidden module pretty
19:30:17 <ivanm> mgoldman: "latest"? :o
19:30:18 <mgoldman> ghc-pkg shows pretty as exposed
19:30:24 <ivanm> that is nowhere near the latest ;-)
19:30:32 <mgoldman> well, latest available from hackage.haskell.org
19:30:42 <ivanm> @hackage Cabal
19:30:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Cabal
19:30:59 <ivanm> mgoldman: ummmm.... 1.4.0.2 is the latest...
19:31:06 <ivanm> even there
19:31:25 <ivanm> the "other versions" section lists them in _increasing_ order, and don't include the latest...
19:31:27 <mgoldman> Hmm, I must have mis-read what I was wanted to pull
19:31:32 <ivanm> heh
19:31:33 <mgoldman> sorry, mild dislexia
19:31:42 <ivanm> so you _are_ using 1.4.0.2?
19:31:45 <ivanm> which version of ghc?
19:32:15 <dmwit> ivanm: Give him a chance to try the right version... ;-)
19:32:33 <ivanm> dmwit: heh, k
19:33:28 <mgoldman> Indeed
19:33:40 <mgoldman> Now that I've quit being retarded, this may work
19:35:17 <Olathe> Can someone tell me why Int instead of Integral is inferred at http://hpaste.org/10132#a1 ?
19:37:46 <TSC> Olathe: Could it be because of length?
19:37:59 <TSC> Or !!
19:39:35 <mgoldman> That worked
19:39:38 <Olathe> It could be.
19:40:06 <Olathe> Ahh, I think it probably is.
19:40:08 <Olathe> Let me check.
19:40:53 <Olathe> TSC: Ahh, that worked. Thanks a lot :)
19:52:40 <mgoldman> Soon I will have xmonad back on my computer.
19:52:56 <mgoldman> I'm amazed at how much I loathe other window managers now.
19:53:08 <dons> hehe
19:53:20 <mgoldman> I blame you dons!
19:53:41 <thoughtpolice> or should you blame others for writing sucky window managers?
19:53:59 <mgoldman> A little from column a, a little from column b.
19:54:17 <mgoldman> xmonad happens to match how I want to interact with the computer amazingly well.
19:54:30 <mgoldman> I didn't even know that was how I wanted to interact until I had tried it.
19:54:45 <mgoldman> and then, bam, instant muscle memory.
19:56:29 <thoughtpolice> i do miss xmonad since I got this macbook. sure it works, but I don't want to go through the hassle of having to reinstall lots of applications and build them against x11 instead of cocoa, and plus leopard's X11 is slightly broken so total full-screen isn't possible
19:56:40 <thoughtpolice> when i get another computer and install linux it will be the first thing there though, I guarantee it
19:57:33 <cjb> thoughtpolice: why not install Linux on your current one?  ;-)
19:58:07 <thoughtpolice> i see no reason to get rid of leopard after I have put this much work into getting it set up the way I want
19:58:22 <dons> that's lock-in for you :)
19:58:26 <thoughtpolice> plus I find OS X in general to be an interesting playground of various ideas (xnu's architecture is really interesting, for example)
19:58:49 * Myoma finds OS X extremly unreliable and crashy
19:59:03 <Myoma> I would probably think the same of anything though
19:59:19 <cjb> now that I've gone to all the trouble of setting up this automatic machine to hit me in the face, it'd be so much trouble to turn it off :)
19:59:30 <thoughtpolice> i've actually crashed linux more times than os x, which is exactly one time
19:59:45 <thoughtpolice> (note, it was because I deliberately wrote a device driver to do so because I was bored and curious)
20:00:10 <mgoldman> So, are we excluding actual flakey hardware from linux crashes?
20:00:15 <thoughtpolice> cjb: it would be a good analogy if it felt like OS X was constantly hitting me in the face, but it doesn't.
20:01:53 <thoughtpolice> note I certainly don't agree with a few apple practices (see: dtrace, although it was 'fixed' in a certain way I guess) and probably never will - but that's not exactly unusual for any business, I've found.
20:02:37 <thoughtpolice> mgoldman: I meant I wrote the device driver for the linux system - i've never crashed this leopard install
20:02:42 <thoughtpolice> sorry, worded improperly
20:03:17 <thoughtpolice> i think the worst thing that happened was that aqua seemed to lock up while I was using spaces so I had to reboot, but that's it.
20:04:16 <wman> is there any other way than using Text.Prinf.printf to stop ghc from escaping characters in output ?
20:04:35 <Myoma> putStr . return $ 'x'
20:04:49 <Myoma> putChar 'x'
20:08:12 <dons> wman: show ?
20:08:20 <dons> oh, to stop. putStr
20:08:23 <mgoldman> Hmm, rxvt seems to be doing something strange.  <enter> is not being seen as an end of line but a literal ^m by applications
20:08:25 <wman> probably it's show doing it for me for a data ... derive Show
20:11:22 <ivanm> wman: you mean that you want "\n" to be treated as a newline, etc.?
20:11:53 <Myoma> @mike
20:11:53 <lambdabot> Maybe you meant: dice more time wiki
20:12:09 <roconnor> @src print
20:12:10 <lambdabot> print x = putStrLn (show x)
20:12:19 <ivanm> > let escape ('\"':xs) = '\\' : '\"' : escape xs; escape (x:xs)    = x : escape xs; escape []        = [] in escape "\thello\n"
20:12:23 <lambdabot>   "\thello\n"
20:12:35 <wman> no, i'm getting desperate debugging some codepage conversion code, so i'm tring to print it out to console. and it's giving me the awful trigraphs
20:12:40 <Myoma> > id "\thello\n"
20:12:44 <lambdabot>   "\thello\n"
20:12:55 <ivanm> whoops, that's not right
20:13:01 <ivanm> > let escape ('\\':xs) = '\\' : '\\' : escape xs; escape (x:xs)    = x : escape xs; escape []        = [] in escape "\thello\n"
20:13:03 <roconnor> > read "\thello\n"
20:13:04 <lambdabot>   "\thello\n"
20:13:07 <lambdabot>   mueval: Prelude.read: no parse
20:13:07 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
20:13:11 <roconnor> > read "\thello\n" :: String
20:13:15 <lambdabot>   mueval: Prelude.read: no parse
20:13:15 <lambdabot>  mueval: "*** Exception: Prelude.read: no pa...
20:13:40 <wman> so, if i would provide my own show definition using string concatenation, would it stop being so fucking helpful ? ;-)
20:13:44 <ivanm> OK, shouldn't that have worked?
20:13:52 <roconnor> > show "\thello\n"
20:13:56 <lambdabot>   "\"\\thello\\n\""
20:14:04 <rwbarton> ivanm: there aren't any backslashes in the string you're passing it.
20:19:12 <mmorrow> wman: try utf8-string
20:19:40 <mmorrow> > greekAlpha
20:19:42 <wman> defining my own show sufficed ;-)
20:19:43 <lambdabot>   "\945\946\947\948\949\950\951\952\953\954\955\956\957\958\959\960\961\962\9...
20:19:48 <mmorrow> > say greekAlpha
20:19:52 <lambdabot>   αβγδεζηθικλμνξοπρςστυφχψω
20:20:01 <Myoma> yes
20:20:09 <mmorrow> say (greek 10)
20:20:11 <mmorrow> > say (greek 10)
20:20:14 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
20:20:19 <mmorrow> > say [greek 10]
20:20:22 <lambdabot>   λ
20:20:26 <Myoma> > (say . map toUpper . const greekAlpha) ()
20:20:30 <lambdabot>   ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΣΤΥΦΧΨΩ
20:20:31 <wman> the derived version does the conversion :-(
20:20:54 <mmorrow> Myoma: sweet! i didn't know toUpper worked with unicode
20:21:51 <mmorrow> wman: yeah, from what i understand, come 6.10 unicode IO'll be baked in.
20:22:25 <mmorrow> > sup 7
20:22:29 <lambdabot>   mueval: Prelude.read: no parse
20:22:53 <wman> well, i'm not even trying unicode, just some non-ascii chars i wanted to see for real ;-)
20:23:12 <mmorrow> however you want to call it :)
20:23:21 <Myoma> it would be cool if ⟦⟧ ⟨⟩ ⟪⟫ ⦅⦆ etc got put into the parser as parens
20:23:28 <Myoma> ones that you can redefine
20:23:34 <mmorrow> oh yesh
20:23:46 <mmorrow> they are /so/ many cool things that could be done with unicode
20:24:02 <wman> mmorrow> you mean that national chars in windows-1250 or cp852 are called unicode too ?
20:24:16 <mmorrow> oh, ok you're right
20:24:17 <mmorrow> ;)
20:24:42 <mmorrow> windows is still around?
20:25:13 <mmorrow> > say "\8704"
20:25:16 <lambdabot>   ∀
20:25:24 <mmorrow> > maxBound :: Char
20:25:27 <lambdabot>   '\1114111'
20:26:15 <roconnor> @type mfix return
20:26:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
20:26:34 <mmorrow> @type return (fix id)
20:26:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
20:27:07 <roconnor> @instances MonadFix
20:27:09 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:29:14 <Myoma> > mfix 1
20:29:17 <lambdabot>       No instance for (Show (m a))
20:29:17 <lambdabot>        arising from a use of `show' at <in...
20:29:21 <Myoma> > mfix 1 :: [Integer]
20:29:24 <lambdabot>       No instance for (Num (Integer -> [Integer]))
20:29:24 <lambdabot>        arising from the li...
20:29:25 <Myoma> :t mfix
20:29:28 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
20:29:37 <Myoma> > mfix (:) :: [()]
20:29:40 <lambdabot>   Couldn't match expected type `[()]'
20:29:51 <mmorrow> > mfix (:[])
20:29:56 <lambdabot>  Terminated
20:30:31 <Myoma> > mfix $ (:[]) . ("x"++)
20:30:34 <lambdabot>   ["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
20:31:57 <mmorrow> > (say . concat) (mfix $ (:[]) . (greek (negate 1) :))
20:32:01 <lambdabot>   ωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωωω...
20:32:04 <mmorrow> crap
20:32:10 <mmorrow> > (say . take 10 . concat) (mfix $ (:[]) . (greek (negate 1) :))
20:32:14 <lambdabot>   ωωωωωωωωωω
20:32:28 <dons>  (:[]) . (greek (negate 1) :) is an awesome bit of haskell
20:33:00 <mmorrow> heh, capture the frustation with '-' among so many other things
20:33:17 <mmorrow> (all of the other things are good though)
20:35:35 <wman> goddamn 15-year-old legacy apps, goddamn freaking old .dbf files, and goddamn kamenickych charset, the not quite so cp852. every time i have to touch this $%^  i spend 2 days just looking for the right conversion tables cause the old ones miraculously don't work, and even when in the old php app iconv does the right thing, somehow it doesnt now
20:36:13 <Olathe> > let map' _ _ [] = []; map' fhead frest (x:xs) = fhead x:map frest xs in map' (+1) (+2) [0..]
20:36:17 <lambdabot>   [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
20:36:24 <wman> how should one more or less painlessly kill himself ?
20:36:29 <Olathe> Is there a function like map' already ?
20:36:55 <lament> wman: certain drugs, there's info online
20:37:11 <Myoma> Olathe: f . head &&& map g . tail ?
20:37:16 <parodyoflanguage> wman: Life will do that on it's own.
20:37:27 <lament> for more extravagance, tie a buch of high explosives to your hed
20:37:27 <Myoma> :t uncurry (:) . (?f . head &&& map ?g . tail)
20:37:30 <lambdabot> forall a b. (?g::a -> b, ?f::a -> b) => [a] -> [b]
20:37:30 <lament> *head
20:37:36 <Olathe> Myoma: Thanks.
20:37:37 <parodyoflanguage> > 1
20:37:41 <lambdabot>   1
20:37:46 <wman> parodyoflanguage: life is the most cruel form of suicide i know of ...
20:38:13 <lament> wman: only when it involves foxpro/dbase
20:38:24 <parodyoflanguage> wman: What's bugging ya?
20:38:44 <wman> and windows, and diacritics, and other, so called normal people ... ;-)
20:39:09 <parodyoflanguage> Ah, character mappings.
20:40:27 <parodyoflanguage> > foldr (+) [1,2,3]
20:40:30 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
20:40:30 <lambdabot>        arising from a use...
20:40:47 <parodyoflanguage> > foldr (+) 0 [1,2,3]
20:40:50 <lambdabot>   6
20:41:49 <Olathe> > scanr (+) 0 [1,2,3]
20:41:53 <lambdabot>   [6,5,3,0]
20:42:03 <Olathe> > scanr1 (+) 0 [1,2,3]
20:42:06 <lambdabot>   Couldn't match expected type `[t1] -> t'
20:42:09 <Olathe> :(
20:42:18 <Myoma> > scanr1 (+) [1,2,3]
20:42:21 <Olathe> :t scanr1
20:42:22 <lambdabot>   [6,5,3]
20:42:23 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
20:42:25 <parodyoflanguage> Hmm...dunno scanr yet.
20:42:39 <Olathe> It gives the intermediate results for foldr
20:42:59 <Olathe> It starts with 0, then goes to 3, 5, 6.
20:43:12 <parodyoflanguage> Olathe: Only backwards?
20:43:25 <Olathe> Well, from the right (foldr is from the right)
20:43:43 <Myoma> :?
20:43:48 <Myoma> I don't like that idea
20:43:53 <Myoma> foldr isn't from any direction
20:44:57 <parodyoflanguage> ah
20:45:32 <parodyoflanguage> Myoma: Then what's the difference between foldr and foldl? :)
20:45:53 <Myoma> foldr is a fold, foldl just gums the stuff in the list together
20:47:11 <parodyoflanguage> > foldl (+) [1,2,3]
20:47:13 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
20:47:14 <lambdabot>        arising from a use...
20:47:20 <parodyoflanguage> > foldl (+) 0 [1,2,3]
20:47:23 <lambdabot>   6
20:47:25 <parodyoflanguage> Bah, did it again :)
20:47:32 <dons> Prelude> foldr (:) [] [1..10]
20:47:34 <dons> [1,2,3,4,5,6,7,8,9,10]
20:47:42 <dons> > foldl (flip (:)) [] [1..10]
20:47:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
20:48:35 <parodyoflanguage> > foldr (flip (:)) [] [1..10]
20:48:38 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
20:48:39 <lambdabot>        Expect...
20:48:58 <dons> foldl (') is a tail call though. that's probably the biggest difference. foldr is that natural fold, it recurses under the constructor, foldl' is the imperative loop.
20:49:44 <mmorrow> @src concat
20:49:44 <lambdabot> concat = foldr (++) []
20:49:50 <mmorrow> @src reverse
20:49:50 <lambdabot> reverse = foldl (flip (:)) []
20:49:54 <mmorrow> @src sum
20:49:54 <lambdabot> sum = foldl (+) 0
20:49:58 <mmorrow> @src product
20:49:58 <lambdabot> product = foldl (*) 1
20:50:30 <dons> that's kinda broken.
20:50:43 <Myoma> > flip (foldr (:)) "ioo" "quu"
20:50:47 <lambdabot>   "iooquu"
20:51:01 <mmorrow> yeah
20:51:47 <mgoldman> So did something happen to defaultGaps in xmonad?
20:51:47 <mmorrow> (yeah about sum/prod)
20:51:51 <dons> in reality, those functions use a manual foldl'
20:51:56 <dons> mgoldman: wrong chan? #xmonad :)
20:52:18 <dons> sum     l       = sum' l 0
20:52:18 <dons>   where
20:52:18 <dons>     sum' []     a = a
20:52:18 <dons>     sum' (x:xs) a = sum' xs (a+x)
20:52:19 <mgoldman> Noted
20:52:36 <dons> still relies on strictness analysis though
20:52:45 <dons> {-# SPECIALISE sum     :: [Int] -> Int #-}
20:52:55 <dons> so ... finally, that's enough to make it work on Int.
20:52:58 <dons> all rather awkward.
20:53:33 <mmorrow> i always do sum and prod as foldl' (+) 0  foldl' (*) 1 "just to be sure"
20:53:41 <dons> yep
20:53:49 * Myoma uses foldr (+) 0
20:53:56 <mmorrow> lol
20:54:08 <Myoma> it works because I don't use lists longer than 10
20:54:35 <mmorrow> wow, if you start using your toes tou can double that
20:55:04 * roconnor couldn't figure out what to use for sum :: [a -> Integer] -> a -> Integer
20:55:05 <Myoma> dunno why anyone would calculutate numbers with haskell though
20:55:08 <roconnor> foldl or foldr
20:55:17 <dons> Myoma: eh, why?
20:55:30 <roconnor> numbers are so unstructured
20:55:38 <roconnor> might as well be working with the untyped lambda calculus
20:55:43 <dons> :)
20:55:44 <roconnor> and goedel codes
20:55:55 <roconnor> or goedel codes
20:56:15 <Myoma> :t foldr (liftM2 (+)) id
20:56:17 <lambdabot> forall a. (Num a) => [a -> a] -> a -> a
20:56:19 <roconnor> people only use numbers because they have "hardware support"
20:56:29 <Myoma> ummm
20:56:35 <roconnor> and "thousands of years of history":/
20:56:41 <dons> just that.
20:56:52 <dons> stupid memes.
20:56:53 <Myoma> :t foldr (\f g -> uncurry (+) . f &&& g) id
20:56:55 <lambdabot>     Occurs check: cannot construct the infinite type: c' = (a, c')
20:56:55 <lambdabot>       Expected type: a1 -> c'
20:56:55 <lambdabot>       Inferred type: a1 -> (a, c')
20:57:11 <roconnor> Myoma: ya, but is foldl more efficent?
20:57:19 <roconnor> I assumed not
20:57:22 <roconnor> so I used foldr
20:57:24 <Myoma> roconnor: what  efficient ?
20:57:25 <roconnor> but I didn't know
20:57:37 <roconnor> foldr (liftM2 (+)) id  vs  foldl' (liftM2 (+)) id
20:57:42 <mmorrow> not stack overflowing and crashing the breathing machine/airliner
20:57:49 <roconnor> er
20:57:54 <roconnor> I think that id should be (const 0)
20:58:04 <Myoma> ok
20:58:10 <mmorrow> :)
20:58:23 <Myoma> I think they both suck
20:58:23 <Olathe> @let id = (const 0)
20:58:26 <lambdabot>  Defined.
20:58:30 <mmorrow> um
20:58:32 <roconnor> dons: types are catching up :)
20:58:40 <mmorrow> > fix id
20:58:43 <lambdabot>       Ambiguous occurrence `id'
20:58:43 <lambdabot>      It could refer to either `L.id', defined...
20:58:49 <Myoma> why don't you add an accumulator parameter and write it in ocaml^H^H^H^Hadd strictness annotations
20:58:56 <roconnor> or prehaps I should say algebraic / inductuve data types are catching up
20:58:56 <dmwit> > fix Prelude.id
20:59:00 <lambdabot>   mueval: Prelude.read: no parse
20:59:01 <lambdabot>  mueval: *** Exception: stack overflow
20:59:08 <mmorrow> > fix L.id
20:59:12 <lambdabot>   0
20:59:16 <dons> nice ffi tutorial, http://www.reddit.com/r/programming/comments/6zrep/using_c_from_haskell_a_short_introduction/
20:59:19 <lambdabot> Title: Using C From Haskell: A Short Introduction : programming, http://tinyurl.com/58367y
20:59:25 <BMeph_> roconor mempty? :)
20:59:32 <dons> we need a decent reddit story, there's so much dumbass downmodding there now.
20:59:37 <Myoma>  roconnor: Ways to use hardware support to speed up the abstract data types
20:59:39 <dons> even the gpu/haskell story died. so sad.
20:59:48 <roconnor> Myoma: meh, I'd rather the complier add an accumlating parameter. :)
20:59:55 <BMeph_> s/ m/: m/
21:00:07 <mmorrow> haskell's ffi rocks
21:00:32 <roconnor> Myoma: what do you mean?
21:00:59 <dons> reading that, i think he must have learnt from RWH.
21:01:27 <dons> oh hehe, yes. he mentions that at the end.
21:01:37 <bos> gpu hm?
21:01:54 <dons> didn't see it bos?
21:01:59 <bos> nope
21:02:09 <dons> http://www.galois.com/blog/2008/08/29/gpugen-bringing-the-power-of-gpus-into-the-haskell-world/
21:02:13 <lambdabot> Title: Galois › Blog › Blog » Bringing the Power of GPUs to Haskell, http://tinyurl.com/5s7fwn
21:02:59 <bos> this one of chillix's students?
21:03:06 <bos> thanks for the pointer.
21:03:09 <Myoma> I want to have lambdabot print out the core versoin of some code
21:03:19 <dons> bos, yup.
21:03:26 <dons> Myoma: omg no.
21:04:46 <Myoma> roconnor, I'd write it like this
21:04:49 <Myoma> aaa x [] _ = x
21:04:49 <Myoma> aaa x (f:fs) o = aaa $! (x + f o) fs o
21:05:00 <Myoma> but that isn't a foldr or foldl afaict
21:05:19 <Myoma> oh (aaa $! (x + f o))
21:05:51 <Myoma> so.. maybe it can be done but I don't see it
21:05:56 <roconnor> how sad.
21:06:16 <roconnor> stupid operational semantics
21:06:42 <Myoma> :t (sum . ) . map
21:06:44 <lambdabot> forall a b. (Num b) => (a -> b) -> [a] -> b
21:07:04 <roconnor> :t (sum .) . sequence
21:07:06 <lambdabot> forall a a1. (Num a1) => [a -> a1] -> a -> a1
21:07:11 <dons> mm. this ffi post is nice. if that's the kind of things people are able to do after reading RWH, i'll be happy.
21:07:51 <roconnor> (sum .) . sequence is even better than that foldl foldr crap.
21:08:01 <dons> ?src sequence
21:08:02 <lambdabot> sequence []     = return []
21:08:02 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:08:02 <lambdabot> --OR
21:08:02 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:08:13 <dons> ?src sum
21:08:14 <lambdabot> sum = foldl (+) 0
21:08:14 <roconnor> well
21:08:16 <dons> heh
21:08:26 <roconnor> I guess it is both foldl and foldr crap
21:08:32 <roconnor> best of both worlds :P
21:08:32 <dons> there's no escape!
21:08:37 <Myoma> you can't fuse foldl with a foldr can yo
21:08:37 <Myoma> u
21:08:50 <roconnor> I doubt it
21:09:25 <roconnor> then again, you can't fuse with your accumulating parameter function either
21:09:39 <roconnor> I'd like to see these 4 functions pitted against each other.
21:09:57 <mmorrow> to the death
21:10:10 <mmorrow> (==StackOverflow)
21:11:12 <roconnor> (sum .) . sequence looks the best to me
21:11:28 <mmorrow> did you time it with -O2
21:11:28 <roconnor> I could believe it is equvalent to the accumulating parameter function.
21:11:28 <dons> yeah, no fusion though.
21:11:34 <dons> its a bit inside out.
21:11:42 <roconnor> the sequence bit will fuse.
21:11:58 <dons> well, its just foldr, so yeah, with something that generates a list.
21:12:15 <Myoma> when you guys say fuse you mean that the compiler does it and when I say fuse I mean to do it with algebra :p
21:12:25 <roconnor> mmorrow: no, I'm just making a prediction
21:12:46 <roconnor> Myoma: I understand that the compiler does it with algebra :P
21:12:55 * Myoma wont trust it 
21:14:44 <roconnor> Myoma: won't trust it to be correct, or won't trust it to actually rewrite the program?
21:14:51 <dons> i wish there was a way to aggregate to p.h.o, just this article, or just that article. not every blog needs to be subscribed
21:15:02 <dons> but guest bloggers who write maybe one haskell article, they don't get aggregated.
21:15:18 <Myoma> I don't have a clue what it does I just expect it to run the program
21:15:20 <roconnor> dons: can't you filter the feed?
21:15:48 <dons> roconnor: i mean, i'd like to submit an article someone writes, without syndicating them
21:15:56 <chrisdone> dons: yeah, I refrained from putting some things on my blog because it would appear on planet haskell and be completely irrelevant
21:16:00 <dons> e.g. http://blog.bjrn.se is all python
21:16:03 <lambdabot> Title: blog.bjrn.se
21:16:05 <dons> but one really nice haskell article
21:16:06 <ivanm> dons: maybe you should write your own planet clone!
21:16:13 <dons> so i'd like to go to p.h.o, and click 'submit'
21:16:21 <chrisdone> can't you filter by entries tagged haskell?
21:16:26 <dons> and we'd have just one article from this 'guest author'
21:16:29 <dons> chrisdone: yeah, if he tagged it
21:17:01 <dons> so i want a planet-like aggregator, but with a 'submit' button for editors.
21:18:10 <roconnor> planet haskell isn't about haskell, it's about haskellers
21:18:43 <ivanm> though I wish people utilised those options in blog engines so that you have a "to read the rest of the article, click here" link
21:18:55 <ivanm> rather than having the entire long blog post on p.h.o :s
21:19:11 <dons> ivanm: i guess you just end up with the haskell subreddit at that point.
21:19:20 <dons> or a spin on that idea.
21:19:32 <ivanm> heh
21:19:46 <ivanm> who is it that puts all those posts on the haskell subreddit?
21:19:53 <roconnor> ivanm: I always felt that was the job of the agrigator rather than the author.
21:20:10 <dons> ivanm: isn't it the gst bot?
21:20:16 <ivanm> roconnor: oh? but how does the aggregator know when its a logical place to stop?
21:20:21 <ivanm> dons: gst is a bot? :o
21:20:36 <roconnor> ivanm: after the first paragraph?
21:20:51 <ivanm> roconnor: true...
21:29:54 <Crypt0> Hey
21:41:24 <cads> is it necessary to know formal concepts from category theory in order to understand and create monads?
21:43:30 <Heffalump> cads: no
21:45:10 <Cale> cads: It's unnecessary even to understand how monads relate to category theory at all.
21:45:35 <Cale> cads: If you'd like, a monad is just a library which supports a particular API.
21:46:30 <Cale> If you implement a new library which supports that API (and supports it in a way which follows a few simple rules), you have a new monad :)
21:48:00 <dmwit> Not only you have a new monad; you have a whole slew of useful library functions pre-made which operate on your library.
21:48:16 <dmwit> Control.Monad is one of the cooler modules we have.
21:50:31 <cads> I have the feeling that I just need to get to coding up a few examples
21:51:55 <cads> the way I understand it, a monad is a type used to wrap another type to give it a state or a way of input or output without side effects
21:52:36 <cads> but it's a little hard to understand how that is possible
21:56:40 <rwbarton> Well, it is sometimes said that the state only appears to exist from a viewpoint "inside" the monad.  Viewed from the "outside", it's just functions being composed together in a certain way (for the State s monad).
22:01:15 <newsham> its a "wrapper" type (if you will) with a way to combine them together (in such a way that the intermediate value is exposed)
22:01:23 <rwbarton> Likewise with the [] monad and nondeterministic computation vs. keeping a list of all the possibilities.
22:02:11 <newsham> > do { x <- Maybe 3; y <- Maybe 5; return (x*3 + y*21) }
22:02:14 <lambdabot>   mueval: Prelude.read: no parse
22:02:24 <newsham> > do { x <- Just 3; y <- Just 5; return (x*3 + y*21) }
22:02:28 <lambdabot>   Just 114
22:03:22 <newsham> > do { x <- ReadFile "foo"; y <- ReadFile "bar"; return (x ++ y) }
22:03:25 <lambdabot>   mueval: Prelude.read: no parse
22:03:32 <newsham> > do { x <- readFile "foo"; y <- readFile "bar"; return (x ++ y) }
22:03:36 <lambdabot>   mueval: Prelude.read: no parse
22:03:36 <lambdabot>  mueval: *** Exception: "<IO [Char]>"
22:04:27 <newsham> > do { x <- [5,3]; y <- "ab"; return (replicate x y) }
22:04:31 <lambdabot>   ["aaaaa","bbbbb","aaa","bbb"]
22:05:28 <newsham> got   Maybe Int mixing with Maybe Int,   IO String mixing with IO String, and [Int] mixing with [Char]
22:33:03 <Olathe> If I have [(a, Int)], where the Ints are unique and sorted, is there any simple function to fill in the gaps from 0 to the maximum one ?
22:34:17 <Olathe> Hmm, never mind. I think I found a better way.
22:43:01 <ivanm> are there any numeric line-fitting, etc. libraries?
22:44:47 <BMeph> Olathe: grats on figuring out a dif't sol'n, but I'm still curious - with what were you going to fill in those gaps? :)
22:44:48 <cads> ivan, let me know if you find something interesting
22:46:12 <BMeph> ivanm: I've seen folks doing it on-the-fly in-channel lately - try poking around the 'vector-space' library, you should find something there, if only a referent to something else. :)
22:46:31 <ivanm> *nod* thanks BMeph
22:46:38 * ivanm is also looking through hmatrix
22:47:51 <cads> hmatrix looks pretty interesting
22:50:07 <ivanm> is the "linear least squares" problem that hmatrix refers to the same as using least squares to fit data to a straight line?
22:51:38 <cads> a least squares fit of a polynomial in general might be considered linear
22:52:43 <cads> i.e. optimizing over a linear space of polynomials
22:58:58 <Myoma> > (9^9+9)*9
22:59:02 <lambdabot>   3486784482
23:19:38 <ivanm> how do people successfully google for haskell-related things without including results of other haskells (as in people's names, university of haskell, etc.)? :s
23:20:04 <cads> > let f n = n==0 1 | n*f (n-1) in [1..5]
23:20:07 <lambdabot>   mueval: Prelude.read: no parse
23:20:24 <cads> poo
23:22:27 <cads> ivan, I've found that just surfing from haskell sites is more informative
23:22:39 <cads> haskell.org is real good
23:23:10 <ivanm> yes, but not everything haskell related is on h.o
23:23:40 <cads> and then if your searching if your term is haskell + (programming related term) it usually returns few non haskell related results I'e found
23:28:57 --- mode: ChanServ set +o dibblego
23:29:13 --- mode: dibblego set +b *!*i=sss@*.190-136-203.telecom.net.ar
23:29:15 --- kick: Macarena25 was kicked by dibblego (dibblego)
23:29:19 --- mode: dibblego set -o dibblego
23:29:30 <ivanm> who was this macarena person?
23:29:55 <dibblego> spammer
23:30:31 <ivanm> how'd you know? I didn't see any spam up above :s
23:30:56 <malune> is there a list datatype in haskell which can contain arbitrarily nested lists?
23:31:07 <dons> a tree :)
23:31:16 <ivanm> BMeph: did you mean the vecotr space library that requires ghc 6.9?
23:31:50 <malune> dons: but is there one which uses native lists?
23:31:59 <dons> a tree type that uses lists?
23:32:02 <dons> Data.Tree, I guess.
23:32:08 <BMeph> ivanm: Oh, does it? I hadn't checked, sorry. :\
23:32:32 <ivanm> heh
23:32:42 <dons> -- | Multi-way trees, also known as /rose trees/.
23:32:42 <dons> data Tree a   = Node { rootLabel :: a , subForest :: Forest a }
23:32:42 <dons> type Forest a = [Tree a]
23:32:50 * ivanm wonders if it'd be worth it to dig out his old notes on how to implement linear least squares and implement it
23:33:20 <malune> dons: interesting i didn't think of it like this. :) thanks
23:36:35 <thatsright> i can't define this even though the manual said so
23:36:50 <thatsright> ﻿ mulop   =   do{ symbol "*"; return (*)   } <|> do{ symbol "/"; return (div) 
23:42:26 <thoughtpolice> thatsright: works fine for me in GHCi, but you want "mulop symbol = do { symbol "*"; return (*) } <|> do { symbol "/"; return (div) }"
23:42:34 <thoughtpolice> (I think, anyway)
23:42:54 <Myoma> thatsright: There is an infix parser in parsec
23:43:05 <Myoma> oh you are probably using it
23:44:55 <thatsright> thoughtpolice: symbol is a function
23:46:34 <thoughtpolice> thatsright: then what's the err?
23:48:20 <thatsright> ill codepad it
23:49:44 <ivanm> dons: I must say, your mean function you had in your blog post a couple of months ago seems to work better than the one in the hstats package...
23:49:56 <ivanm> even though the only difference that I can find is that it uses a fold :s
23:50:23 <thatsright> http://codepad.org/RE2KKoxI
23:50:46 <dons> ivanm: hmm.
23:50:53 <thatsright> source : http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
23:50:55 <lambdabot> Title: Parsec, a fast combinator parser
23:51:03 <ivanm> dons: http://hackage.haskell.org/packages/archive/hstats/0.2/doc/html/src/Math-Statistics.html
23:51:05 <dons> ivanm: oh, fold with no-monomorphic state?
23:51:10 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6hknuu
23:51:18 <dons> yeah, it has a lazy pair.
23:51:29 <dons> should submit a patch to the author
23:51:34 <dons> and a link to the post explaining why.
23:51:56 <dons> hmm. a lot of classical haskell there.
23:51:58 <ivanm> dons: I even managed to make a generalised version of yours! \o/
23:52:01 <dons> cov xs ys = sum (zipWith (*) (map f1 xs) (map f2 ys)) / (n - 1)
23:52:06 <dons> could be a fusion testsuite!
23:52:27 <ivanm> heh
23:52:30 <dons> ivanm: submit a patch to the author (and some QC tests testing equivalence)
23:52:42 <ivanm> ummm.... I've never touched QC :s
23:53:04 <dons> ?check myqc == yourqc
23:53:06 <lambdabot>  Terminated
23:53:26 <ivanm> hmmmm... and QC will make up data?
23:53:38 <dons> yeah
23:53:42 <dons> check the testing chapter of RWH
23:53:47 <ivanm> heh
23:53:48 <dons> should be able to use the examples there
23:53:48 <thoughtpolice> thatsright: 'symbol' expects a TokenParser but you give it a string is the problem
23:53:57 <ivanm> dons: you're really pushing your book, aren't you :p
23:54:14 <dons> well, it's online.
23:54:16 <ivanm> @slap expensive australian bookstores
23:54:16 <dons> and free.
23:54:17 * lambdabot pokes expensive australian bookstores in the eye
23:54:18 <dons> so ... :)
23:54:20 <ivanm> dons: true
23:54:27 <dons> pity the .au dollar declined so much :(
23:54:32 <ivanm> yeah :s
23:54:37 <dons> would have been 50 bucks a month ago
23:54:41 <dons> now its like 75.
23:54:54 <thatsright> dons: will i one day see real world haskell in borders?
23:54:56 <ivanm> dons: last I checked, it's still around $90 for pre-order here :s
23:55:08 <dons> that's a fair bit.
23:55:12 <dons> want me to send you a copy? :)
23:55:17 <ivanm> dons: \o/
23:55:20 <dons> it'll probably be in the unsw bookshop at some point.
23:55:27 <ivanm> what's the QC library to load into ghci?
23:55:36 <dons> thatsright: in borders, i guess so. do they have o'reilly books?
23:55:43 <dons> ivanm: Test.QuickCheck
23:56:09 <thatsright> dons: they had an ocaml and an erlang book
23:56:25 <dons> oh, well, i'd say definitely then
23:56:49 <dons> yeah, looks like it is in borders already
23:57:13 <dons> thatsright: http://www.borders.com/online/store/SearchResults?keyword=real+world+haskell&type=0&simple=1
23:57:15 <lambdabot> Title: Real World Haskell - Borders - Books, Music and Movie, http://tinyurl.com/6q6zfn
23:57:40 * dons has no idea how the distribution end of things works
23:57:44 <dons> they just seem to appear
23:58:32 <dons> maybe we should do a "recommend RWH to a java programmer" campaign :)
23:58:51 <ivanm> is there a QC function that does the same as lambdabot's ?check ?
23:59:01 <dons> guerilla RWH: go into borders and replace the java books with copies of RWH. hehe
23:59:09 <dons> ivanm: quickCheck
23:59:11 <ivanm> @remember dons maybe we should do a "recommend RWH to a java programmer" campaign :)
23:59:12 <lambdabot> I will never forget.
23:59:52 <ivanm> dons: doesn't that require a pre-done function? :o
