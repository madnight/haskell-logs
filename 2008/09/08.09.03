00:00:04 <winter> I just read some of the Supero supercompilation stuff.  Now I'm wondering if there is any serious funding of projects like this to improve Haskell compilation?
00:00:27 <winter> Anyone got any grants from Intel, for example?
00:03:21 <mmorrow> winter: i'm not sure about grants, but compilation is always improving rapidly (not that it's bad nor that it can't always be improved). also, Control.Parallel can /hugely/ speed code up if used in the right way (which isn't always obvious or even known).
00:03:49 <dons> MS is funding data parallel haskell, and fusion research.
00:03:55 <winter> nice
00:05:36 <mmorrow> err, clarifying, what's not known is not that that can be the case (although that's true to an extent), but exactly where/how/when to use parallel annotations
00:06:09 <mmorrow> winter: check this out. this blew my mind two days ago http://hpaste.org/10103
00:06:17 <moosen> morrow, check this out:  let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)}
00:06:43 <mmorrow> @type let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)}
00:06:45 <lambdabot> <no location info>:
00:06:45 <lambdabot>     not an expression: `let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div
00:06:45 <lambdabot> (n-1) 2) ; (l1,l2) = l ((div n 2)-1)}'
00:06:57 <mmorrow> @type let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)} in f
00:06:59 <lambdabot> forall a a1. (Num a1, Integral a) => a -> a1
00:07:05 <moosen> hrm
00:07:17 <mmorrow> err, i did "in f", that might be wrong
00:07:32 <mmorrow> i'm still groking
00:08:15 <mmorrow> > let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)} in f 0
00:08:20 <lambdabot>   1
00:08:22 <mmorrow> > let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)} in f 1
00:08:26 <lambdabot>   1
00:08:36 <mmorrow> > let f n = fst (l n) where l n | n<2 = (1,1) | n==2 = (2,1) | n > 2 = if (rem n 2)==1 then (k1^2+2*k1*k2,k1^2+k2^2) else ((l1+l2)^2+l1^2, l1^2+2*l1*l2) where {(k1,k2) = l (div (n-1) 2) ; (l1,l2) = l ((div n 2)-1)} in fmap f [0..]
00:08:40 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
00:08:44 <mmorrow> heh, nice
00:09:02 <moosen> wow, nice
00:11:16 <moosen> the algorithm is logarithmic, as it uses formulas for writing  F (2n) from F(n) and F(n+1)
00:11:57 <winter> mmorrow: that was a nice speadup with the  Control.Parallel version.  What hardware was it running on?
00:12:12 <mmorrow> moosen:interesting
00:12:18 <mmorrow> winter: i'll paste
00:13:09 <mmorrow> winter: http://hpaste.org/10103#a1
00:13:55 <mmorrow> moosen: what is the relation of that algo to the explicit closed-form solution to the fib recurrence relation?
00:16:11 <mmorrow> that's pretty cool, don't think i've seen it that way before :)
00:16:18 <winter> mmorrow: Why did it perform so much better if it is only a 2 CPU machine?
00:16:32 <moosen> mmorrow: it springs from a double number identity that can be derived from the original relation
00:17:11 <winter> impressive though
00:17:19 <moosen> http://www.cubbi.org/serious/fibonacci/algorithms.html the descriptions of algorithms 3a and 3b tell more
00:17:21 <lambdabot> Title: cubbi.com: Algorithms for the calculation of Fibonacci Numbers
00:17:36 <mmorrow> winter: in the single core case, it has to traverse the list to get the length, then again while summing, whereas in the >1 core case it can do those in parallel => just one pass
00:17:49 <mmorrow> moosen: sweet
00:17:58 * mmorrow looks
00:20:03 <mmorrow> nice
00:20:28 <moosen> the matrix equation is especially elegant, as is the fact that you can derive the fact recursion algorithm from it
00:20:46 <moosen> I derived it from binet's formula while I was in jail :)
00:21:02 <cpfr> !!
00:21:12 <mmorrow> moosen: heh
00:21:12 <Twey> moosen++
00:21:33 <moosen> but that was very messy, and the matrix method shames me :)
00:22:21 <mmorrow> moosen: have you seen hmatrix?
00:22:54 <mmorrow> a nice demonstration in the tutorial: http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/hmatrix.pdf
00:22:59 <lambdabot> Title: A simple scientific library for Haskell
00:23:02 <mmorrow> homepage: http://www.hmatrix.googlepages.com/
00:23:03 <lambdabot> Title: - hmatrix
00:23:07 <moosen> I'll check it out
00:23:16 <mmorrow> it's pretty nice
00:23:20 * mmorrow vanishes
00:23:35 <moosen> still very new to haskell (3 days )
00:26:17 <mmorrow> nice. that tutorial gives some nice examples along with the ouput/etc. it'd be a great place to start, especially if you know some/all/whatever of the math
00:27:03 <moosen> there is one matrix problem I've been itching to implement for months now...
00:27:33 <moosen> and i've been wondering if lapack has an interface in haskell
00:27:52 <moosen> so thanks :)
01:15:40 <bos> @seen dons
01:15:40 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 1h 11m 51s ago.
01:37:58 <paczesiowa> does Ashley Yakeley hang out here?
01:39:01 <quicksilver> I don't think so. If he does, I don't know his nick.
01:40:24 <paczesiowa> I just found his (at first I though that Ashley was female name) HBase, some crazy stuff there...
01:41:11 <paczesiowa> and I was wondering how old that code is
02:01:33 <paczesiowa> what's this: args <- ?getArgs; ?
02:01:55 <ivanm> no idea what the question mark is meant to do there
02:02:07 <BeelsebobWork> indeed
02:02:28 <BeelsebobWork> but it binds the output of the getArgs action to the variable args
02:02:38 <Cale> Implicit parameter? :)
02:02:49 <paczesiowa> doWithArgFiles :: (?stdin :: PeekSource IO (Maybe Word8),?getArgs :: IO [String]) =>(PeekSource IO (Maybe Word8) -> IO a) -> IO [a];doWithArgFiles f = do{args <- ?getArgs;doWithFileNamesOrStdin args f;};}
02:03:28 <Cale> yeah, implicit parameter... I'm not sure why you'd pass that action as an implicit parameter, or a parameter of any kind though
02:03:36 <paczesiowa> no pragmas at the top of the file
02:03:51 <paczesiowa> is that legal haskell?
02:04:51 <Cale> Well, maybe it was compiled by passing a -X option to GHC or using -fglasgow-exts
02:05:49 <quicksilver> paczesiowa: it's not h98, no. I must have been intended for glasgow-exts.
02:07:19 <trzkril> tja, unforseen consequences...
02:07:20 <paczesiowa> even hugs has that extension
02:15:31 <quicksilver> paczesiowa: yes, implicit parameters was a rather popular extension for a while.
02:15:36 <quicksilver> it's gone badly out of fashion though.
02:16:14 <paczesiowa> those HBase sources have 2002 as date in license headers
02:16:19 <paczesiowa> old enough?
02:19:05 <Taejo> is there a function like read, but which returns Maybe a instead of a?
02:19:26 <paczesiowa> wrap reads
02:20:21 <Taejo> thanks
02:20:32 <quicksilver> Taejo: let readMaybe s = case reads s of [(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing
02:20:38 <paczesiowa> Taejo: or use Safe.readMay
02:20:50 <quicksilver> if you're not fussed about trailing spaces you can make it slightly simpler.
02:21:12 <paczesiowa> Taejo: from safe package
02:21:57 <Taejo> paczesiowa: don't want to use non-builtins... it's for an assignment and my tutor doesn't now haskell, so I don't want him to have to mess about with installing dependencies
02:22:36 <paczesiowa> fair enough:)
02:24:04 <yitz> paczesiowa: readMaybe = listToMaybe . map fst . reads
02:24:37 <Taejo> yitz: that has rather different semantics
02:25:00 <ivanm> is there a guide on how to use the Chart library anywhere? the docs don't actually say what anything does or how to use it :s
02:25:04 <yitz> Taejo: yes, a bit, but it's simplest and usually what you need.
02:25:47 <paczesiowa> yitz: if his tutor doesn't know haskell then readMaybe = listToMaybe . map fst . reads might result in failed assingment
02:26:44 <Taejo> paczesiowa: not really... he said I could use Haskell, so he has to accept Haskell idioms. But I'd have to add wodges of comments
02:26:46 <yitz> paczesiowa: hehe. I hope not. I think it's a lot nicer than a messy case.
02:30:04 <paczesiowa> Taejo: than make safe read of type (MonadError e m, Error e, ReadS a) => String -> m a, big pile of haskell idioms:>
02:30:17 <Taejo> hehe
02:30:39 <yitz> paczesiowa: :)
02:32:14 <Saizan_> ReadS is not a class :)
02:32:24 <yitz> Taejo: if it's important to reject trailing garbage, you can use listToMaybe . map fst . filter (null . snd) . reads
02:32:24 <paczesiowa> typo:>
02:32:42 <yitz> s/S//
02:32:49 <Taejo> yitz: that's quite nice
02:32:56 <paczesiowa> @pl \s = case reads s of [(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing
02:32:56 <lambdabot> (line 1, column 4):
02:32:57 <lambdabot> unexpected "="
02:32:57 <lambdabot> expecting operator, pattern or "->"
02:33:21 <paczesiowa> @pl (\s = case reads s of [(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing)
02:33:21 <lambdabot> (line 1, column 5):
02:33:22 <lambdabot> unexpected "="
02:33:22 <lambdabot> expecting operator, pattern or "->"
02:33:29 <paczesiowa> @pl (\s -> case reads s of [(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing)
02:33:30 <lambdabot> (line 1, column 52):
02:33:30 <lambdabot> unexpected ">"
02:33:30 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
02:33:41 <paczesiowa> > ()
02:33:47 <lambdabot>   ()
02:34:00 <Taejo> @pl (\s -> case reads s of {(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing})
02:34:01 <lambdabot> (line 1, column 24):
02:34:01 <lambdabot> unexpected "{"
02:34:01 <lambdabot> expecting variable, "(", operator or ")"
02:34:16 <Taejo> @pl (\s -> case reads s of {[(v,sps)] | all isSpace sps -> Just v ; _ -> Nothing})
02:34:17 <lambdabot> (line 1, column 24):
02:34:17 <lambdabot> unexpected "{"
02:34:17 <lambdabot> expecting variable, "(", operator or ")"
02:34:32 <rwbarton_> pl doesn't like case
02:38:02 <yitz> > let readList = unfoldr $ listToMaybe . concatMap reads . tails in readList "Here is my list: 13, 17, 19, and 23. Oh, also 29." :: [Int]
02:38:05 <lambdabot>   [13,17,19,23,29]
02:38:56 <mmorrow> > let readM = list mzero (return . fst . head) . filter (all isSpace . snd) . reads in readM (show pi) :: Maybe Double
02:39:00 <lambdabot>   Just 3.141592653589793
02:39:29 <mmorrow> err, didn't mean to put that specific stuff in readM
02:39:32 <yitz> @type list
02:39:33 <lambdabot> forall t a. t -> ([a] -> t) -> [a] -> t
02:39:53 <mmorrow> let list z f xs = if null xs then z else f xs
02:40:10 <mmorrow> the list equiv of  maybe
02:40:31 <EvilTerran> that'd be "list z f [] = z; list z f (x:xs) = f x xs", wouldn't it?
02:40:43 <mmorrow> list mzero return [0..9] :: Maybe [Int]
02:40:44 <mmorrow> > list mzero return [0..9] :: Maybe [Int]
02:40:48 <lambdabot>   Just [0,1,2,3,4,5,6,7,8,9]
02:41:00 <mmorrow> EvilTerran: yes
02:41:07 <EvilTerran> expanding out the (:) before passing it to f makes it possible to do some fancy pointsfree stuff
02:41:12 <yitz> @index list
02:41:12 <lambdabot> bzzt
02:41:24 <mmorrow> err, but f know it's getting a nonempty list
02:41:28 <EvilTerran> as well as making it explicit in the type of f that there's at least one element
02:41:30 <mmorrow> @type (head&&&tail)
02:41:32 <lambdabot> forall a. [a] -> (a, [a])
02:41:34 <yitz> @hoogle list
02:41:35 <lambdabot> module Control.Monad.List
02:41:35 <lambdabot> module Data.List
02:41:35 <lambdabot> package list-extras
02:42:01 <yitz> is that new?
02:42:10 <mmorrow> i just defined it earlier ;)
02:42:33 <EvilTerran> it also makes it more consistent - otherwise z should take a list as well, just one that's always [] :P
02:43:09 <mmorrow> well, i suppose you say the same thing about the first arg to maybe
02:43:18 <EvilTerran> ?type maybe
02:43:20 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:43:24 <mmorrow> but since they're both mzero/mempty ...
02:43:34 <Taejo> I <3 #haskell
02:43:44 <mmorrow> you just pass in the image of them
02:43:46 <EvilTerran> the first arg to maybe only takes the matched constructor's parameter, tho, it leaves out the Just
02:44:03 <Taejo> ask a simple question, get your answer, and ten minutes later the debate is still going
02:44:05 <EvilTerran> so it'd be consistent with "maybe" to define "list" my way
02:44:09 <mmorrow> yeah, this is the asymmetry between lists and Maybe
02:44:15 * EvilTerran has thought about this one :)
02:44:49 * yitz isn't convinced that there really is any good analogue.
02:45:06 <mmorrow> suppose it was    list z f xs = if null xs then z else fmap f xs
02:45:21 <Saizan_> well, if you take maybe as the chuch encoding, then foldr is the analogue
02:45:22 <EvilTerran> "list f e [] = e; list f e (x:xs) = f x xs" is in my "toolkit" file
02:45:24 <mmorrow> then you wouldn't have the option of not mapping to another list
02:45:31 <mmorrow> heh
02:45:45 <EvilTerran> Saizan_, indeed, "maybe" is the catamorphism for Maybe, i guess
02:46:18 <mmorrow> Saizan_: interesting
02:46:23 <mmorrow> EvilTerran: yeah
02:46:48 <mmorrow> so list should be whatever the image of maybe is in []
02:47:38 <Saizan_> so it should take only the head?
02:48:03 <mmorrow> i don't believe that's the implication
02:48:07 <EvilTerran> i can describe an algorithm for devising "maybe" and "list"
02:48:25 <mmorrow> make a commutative diagram (square) :)
02:48:29 <EvilTerran> and it'll get my type for list - that's why i use that one, it feels more consistent to me
02:48:37 <mmorrow> nice
02:49:10 <mmorrow> EvilTerran: i believe they're isomorphic
02:49:16 <Taejo> can somebody explain the meaning and purpose of coarbitrary in QuickCheck's Arbitrary class?
02:49:27 <EvilTerran> "the deconstructor function takes a parameter for each constructor of the type, with the same type as the constructor, only with the return type replaced with a new type variable"
02:49:38 <paczesiowa> Taejo: I think for generating random functions
02:49:41 <mmorrow> @type \f -> (\x xs -> f (x:xs))
02:49:43 <lambdabot> forall a t. ([a] -> t) -> a -> [a] -> t
02:49:53 <mmorrow> @type \f -> (\(x:xs) -> f x xs)
02:49:55 <lambdabot> forall t t1. (t -> [t] -> t1) -> [t] -> t1
02:49:59 <EvilTerran> Just :: a -> Maybe a; Nothing :: Maybe a; so maybe :: (a -> b) -> b -> b
02:50:28 <EvilTerran> (:) :: a -> [a] -> [a]; [] :: [a]; so list :: (a -> [a] -> b) -> b -> [a] -> b
02:50:42 <EvilTerran> whups, "maybe :: (a -> b) -> b -> Maybe a -> b"
02:50:50 <mmorrow> i think Saizan_ nailed it with foldr
02:50:53 <hackage> Uploaded to hackage: hscolour 1.10.1
02:51:06 <EvilTerran> mmorrow, that's a different equivalence though
02:51:38 <EvilTerran> that's "the catamorphism function takes takes a parameter for each constructor of the type, with the same type as the constructor, only with all appearances of the type in question replaced with a new type variable"
02:51:49 <EvilTerran> it's the same for Maybe
02:51:52 <paczesiowa> @instances MonadError
02:51:53 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
02:51:58 <mmorrow> EvilTerran: hmm, interesting. have to tinker/do some work. will think about it.
02:52:03 <EvilTerran> but it gives you different results for recursive types
02:52:03 <mmorrow> be back in a few
02:52:09 <paczesiowa> why there is no MonadError () Maybe
02:52:36 <EvilTerran> for non-recursive types, the only appearances of the type in question are the return type of the constructors, so it's always the same
02:52:54 <mmorrow> EvilTerran: there. that's the asymmetry.
02:53:02 <EvilTerran> mmorrow, huh?
02:53:14 <paczesiowa> > let read' x = case reads x of { [(a, b)] | all isSpace b -> return a; _ -> failWith $ strMsg "no parse"} in case read' "23" of {Just n -> n+1; Nothing -> 0}
02:53:17 <lambdabot>   mueval: Prelude.read: no parse
02:53:17 <mmorrow> (between (Maybe a) and [a])
02:53:22 <Saizan_> i guess category theorists have a name for list too
02:53:23 <EvilTerran> different algorithm for going from types to functions, different results
02:53:50 <EvilTerran> it just so happens that the result is the same in both algorithms for non-recursive types
02:53:53 <mmorrow> EvilTerran: err, what i was trying to say is that you just said what i was trying to figure out how to say
02:54:10 <mmorrow> wrt Maybe a and [a]
02:54:24 <EvilTerran> i could start yammering about type-level fixedpoints now, but i may just end up confusing everyone, myself included
02:54:24 <mmorrow> ([a] is recursively defined)
02:54:33 <mmorrow> heh, ok bbl
02:54:49 <paczesiowa> Taejo, yitz: actually that MonadErrorified read wasn't a joke. read' x = case reads x of { [(a, b)] | all isSpace b -> return a; _ -> failWith $ strMsg "no parse"} you can use witch matching on maybe constructors, but you can also use it in more interesting monads
02:55:35 <Saizan_> type MaybeF a r = Either () a, type Maybe a = Mu (MaybeF a) :)
02:55:57 <EvilTerran> Maybe a ~~ a + 1; [a] ~~ mu as. a*as + 1
02:56:09 <Taejo> omg, just did rm *.hs instead of rm *.hi
02:56:14 <Taejo> not good
02:56:18 <opqdonut> luckily you have version control?
02:56:22 <EvilTerran> catamorphisms for those types are "maybe" and "foldr"
02:56:23 <Taejo> nope
02:56:27 <paczesiowa> I think it would be a lot easier if every function that returns Maybe a or Either e a would return MonadErrorified result, you don't loose anything but you gain something
02:56:45 <yitz> paczesiowa: you mean throwError instead of failWith?
02:56:49 <paczesiowa> :D no time for irc now I guess
02:56:56 <paczesiowa> yitz: yeah
02:57:03 <EvilTerran> paczesiowa, yeah, you gain loads of "ambiguous type" errors, i'd wager :P
02:57:17 <paczesiowa> EvilTerran: example?
02:57:37 <paczesiowa> failWith is ocaml, right?
02:57:47 <paczesiowa> @src failWith
02:57:48 <lambdabot> Source not found. Wrong!  You cheating scum!
02:57:50 <EvilTerran> ... too early in the morning to think of an example. i may be wrong, but i vaguely recall hearing that as an argument against that
02:58:09 <EvilTerran> ?hoogle MonadError
02:58:09 <lambdabot> No results found
02:58:14 <EvilTerran> ?src MonadError
02:58:14 <lambdabot> class (Monad m) => MonadError e m | m -> e where
02:58:14 <lambdabot>     throwError :: e -> m a
02:58:14 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
02:58:25 <EvilTerran> actually, there's what you lose - h98 compatibility
02:58:34 <EvilTerran> you need MPTCs and fundeps for MonadError
02:58:51 <yitz> paczesiowa: maybe (throwError $ strMsg "no parse") return . readMaybe
02:59:39 <yitz> EvilTerran: all of these things are going to need explicit type sigs anyway
02:59:54 <paczesiowa> yitz: why?
03:00:09 <paczesiowa> if you patternMatch against Just then you don't need that
03:00:23 <yitz> that's often the case for Read stuff.
03:00:25 * EvilTerran goes back to thinking about "Maybe a ~~ a + 1; [a] ~~ mu as. a*as + 1", and a fancy word he can use that'll give him "maybe" and "list" instead of "maybe" and "foldr"
03:01:00 <opqdonut> :)
03:01:04 <paczesiowa> "patternMatch" damn, I talk in camelCase now...
03:01:19 * EvilTerran notes that also "Maybe a ~~ mu as. a + 1"
03:01:52 <opqdonut> heh
03:02:20 <yitz> EvilTerran: why are maybe and foldr analogous? When the list is non-empty, foldr uses the initial value in the subsequent calculation, whereas maybe does not.
03:02:33 <EvilTerran> yitz, because they're both catamorphisms
03:02:45 <EvilTerran> it's just Maybe's catamorphism isn't that interesting because it's a non-recursive type
03:02:54 <opqdonut> yitz: you give maybe an initial value too
03:03:00 <opqdonut> that gets used in the Nothing case
03:03:03 <quicksilver> yitz: foldr uses the initial value because (:) has a recursive case.
03:03:10 <yitz> opqdonut: but you ignore it when the Maybe is non-empty
03:03:19 <quicksilver> yitz: (and that recursive case will eventually be [], which triggers the initial value)
03:03:30 <EvilTerran> yitz, you ignore it when the list is infinite, too
03:03:32 <quicksilver> since Maybe doesn't have any recursion, it doesn't happen.
03:03:40 <EvilTerran> :P
03:03:43 <opqdonut> yitz: well you can ignore the initial value for an infinite list ;)
03:03:48 <opqdonut> gah, EvilTerran beat me to it
03:04:06 <quicksilver> which proves that there are two adjuctions between maybe and lists.
03:04:11 <quicksilver> one takes Just a to [a]
03:04:17 <quicksilver> and the other takes it to (repeat a)
03:04:30 <yitz> quicksilver: ah, thanks, that explains it.
03:04:33 <opqdonut> and nothing gets taken to [] on both counts
03:05:04 <quicksilver> (if you believe that lists can be infinite, which is not actually true on the naive categorical interpretation. But Oh well)
03:05:22 <EvilTerran> "Maybe a ~~ mu as. a + 1; [a] ~~ mu as. a*as + 1" -- catamorphisms are "maybe" and "foldr" respectively, but, if you ignore the "mu as." in both, the equivalent to catamorphisms are "maybe" and "list" respectively
03:05:34 <yitz> quicksilver: iow, lists as direct sums
03:05:51 <yitz> quicksilver: as opposed to direct products
03:06:17 <EvilTerran> dunno how you'd express that more formally. probably with much faff and many highly polysyllabic words. :P
03:07:35 <EvilTerran> i think Saizan_ may've been on to something talking about "type MaybeF a r = Either () a, type Maybe a = Mu (MaybeF a)" a minute ago
03:08:20 <EvilTerran> MaybeF a as = a + 1; ListF a as = a*as + 1
03:08:50 <EvilTerran> mu (MaybeF a) ~~ Maybe a; mu (ListF a) ~~ [a]
03:10:12 * EvilTerran ponders
03:11:26 <EvilTerran> ah well. i'm happy talking about "deconstructors" that are the same as catamorphisms for non-recursive types and different for recursive ones. :)
03:12:05 <quicksilver> I think 'Deconstructor' sounds like someone who might star on a program involving brightly coloured lycra suits and massively oversized padded earbuds.
03:12:30 <EvilTerran> wat
03:12:36 <opqdonut> :D
03:12:56 <rwbarton_> EvilTerran: It's like the difference between  data List a = Nil | Cons a (List a)  and  data List a = Nil | Cons a [a].
03:13:58 <EvilTerran> rwbarton_, yeah, i was just thinking something like that, although in different terms :)
03:28:18 * EvilTerran runs into confusion in trying to use TH
03:28:55 <EvilTerran> is there something simpler which lets you examine the structure of data declerations at compile-time?
03:29:50 <quicksilver> Uniplate?
03:29:54 <quicksilver> SYB?
03:30:08 <ivanm> magic?
03:30:10 <EvilTerran> uniplate doesn't really let you examine the structure of data decls
03:30:13 <EvilTerran> SYB is runtime :P
03:30:27 <EvilTerran> ... i guess DrIFT and Derive might suit
03:30:44 <EvilTerran> http://repetae.net/computer/haskell/DrIFT/ http://www-users.cs.york.ac.uk/~ndm/derive/
03:30:45 <lambdabot> Title: DrIFT Homepage
03:31:02 <matthew-_> ghc plugins
03:31:21 <quicksilver> well, uniplate examines the structure are compile-time on your behalf, so that you can make decisions based on that at runtime.
03:31:43 <quicksilver> I appreciate that isn't exactly what you asked for but it would have been sufficient for some of the things you may have been trying to do :)
03:32:47 <rwbarton_> Is there some syntax that lets me associate the same right-hand-side with two or more patterns in a case statement?
03:32:51 <EvilTerran> i was hoping to write a preprocessor construct that derived catamorphism and/or deconstructor functions for a given type
03:33:07 <quicksilver> rwbarton_: no. It is an occasionally requested feature.
03:33:09 <EvilTerran> rwbarton_, "where"
03:33:12 <EvilTerran> :P
03:33:28 <rwbarton_> EvilTerran: the right hand side is shorter than the pattern :)   It doesn't matter much here.
03:33:34 <quicksilver> EvilTerran: where scopes over multiple guards but not multiple patterns.
03:33:44 <EvilTerran> case ... of { Foo x -> fooOrBar x; Bar x -> fooOrBar x; ... } where fooOrBar x = ...
03:33:53 <quicksilver> right, you have to push the 'x' through
03:34:09 <EvilTerran> the difficulty of scoping across multiple patterns is they might bind different variables, or the same variable with different types
03:34:40 <rwbarton_> EvilTerran: yeah, that occurred to me as a possible problem.  In my case they're just constants built out of constructors
03:35:09 <matthew-_> if you could put monadic sequencing or at least mplus as a pattern guard?
03:35:29 <EvilTerran> you could have it so that, if two patterns with the same RHS had the same variable, they were restricted to be the same type, and you could only use variables that appeared in both patterns
03:35:36 * quicksilver nods
03:35:43 <quicksilver> You could, and it would be occasionally useful.
03:35:52 <EvilTerran> it'd be nice for things like "zip _ [] = zip [] _ = []; zip (x:xs) (y:ys) = (x,y) : zip xs ys"
03:35:53 <quicksilver> (for function definitions as well as cases)
03:36:15 <quicksilver> I briefly discussed it with SPJ once.
03:36:22 <quicksilver> He couldn't think of any reason not to do it, just it isn't done.
03:37:09 <matthew-_> how far through this paper are you?
03:37:09 <yitz> quicksilver: then analagously you'd have case ... of Foo x -> Bar x -> rhs
03:37:11 <matthew-_> ww
03:37:22 <quicksilver> yitz: definitely.
03:37:34 <EvilTerran> (incidentally, that's the syntax i would propose - i'd probably suggest "zip xs ys = case (xs,ys) of ([],_), (_,[]) -> []; (x:xs,y:ys) -> (x,y):zip xs ys" as the other version, as the multiple ->s look a bit odd to me
03:37:52 <quicksilver> I think the multiple ->s look nice.
03:38:04 <EvilTerran> eh. i'd use either syntax happily :)
03:38:33 <EvilTerran> and the multiple ->s version would play nicer with pattern guards
03:38:35 * yitz thinks they look odd, but that = and -> should work the same way.
03:40:01 <EvilTerran> it'd be difficult to parse "Foo x | Just y <- bar x, Baz y ->" vs "Foo x | Just y <- bar x, baz y ->"
03:40:02 <yitz> zip _ [], zip [] _ = []
03:40:02 <lilac> zip _ [], [] _ = []
03:40:07 <lilac> hehe :)
03:40:19 <EvilTerran> but, if the first was  "Foo x | Just y <- bar x -> Baz y ->", no problem!
03:40:26 <yitz> lilac: I beat you. this time.
03:40:59 <EvilTerran> although i'd hope sane folk would put a newline before "Baz" in that case. that's doing my head in all in one line. :P
03:41:07 <yitz> EvilTerran: this is a new strain of "leaning toothpicks syndrome"
03:41:25 <EvilTerran> suddenly, arrows everywhere! thousands of them!
03:41:34 <EvilTerran> http://www.boltcity.com/copper/copper_036_signpost.htm
03:41:36 <lambdabot> Title: copper - signpost
03:42:53 <yitz> EvilTerran: hehe
03:43:22 <skorpan> http://tapthehive.com/discuss/This_Post_Not_Made_In_Chrome_Google_s_EULA_Sucks
03:43:26 <lambdabot> Title: TapTheHive - This Post Not Made In Chrome; Google's EULA Sucks, http://tinyurl.com/54tn6r
03:45:01 <Taejo> is there a tool to convert .hi files to a human-readable form?
03:47:02 <ivanm> Taejo: surely you can read it... understanding it is probably a different story though :p
03:47:16 <Taejo> thanks ivanm
03:48:22 * ivanm takes a bow
03:48:58 <EvilTerran> Taejo, still trying to recover your code from that stray rm?
03:49:03 <Taejo> yes
03:49:22 <Taejo> I was hoping to at least extract the names of my constructors so I don't leave one out
03:49:56 <EvilTerran> i think the only solution that'd recover everything would've been to unmount the drive immediately and try to do some kinda traditional data recovery
03:50:33 <Taejo> EvilTerran: well I didn't notice for a while, but as soon as I did, I unmounted and grepped the partition, but didn't come up with anything
03:50:41 <EvilTerran> =/
03:50:50 <EvilTerran> i'd think you could at least extract the number of constructors for each type somehow, so you'd know if you missed one, but not know which one
03:51:02 <EvilTerran> not sure
03:51:16 <Taejo> EvilTerran: good old "strings" got the constructors
03:52:05 <EvilTerran> hurray
03:53:54 <cjs> You guys don't have fsdb?
03:54:04 <Taejo> cjs: what's fsdb?
03:54:37 <cjs> It's a debugging tool for FFS. You aim it at a raw filesystem and it lets you do things like find a deleted inode and extract the file data from it.
03:54:47 <binrapt> Have any of you used Haskell for webdev? :p
03:55:15 <cjs> Basically, you could use it to find the directory from which you rm'd the file, look at the deleted entries in that dir (if they've not been overwritten with new entries) to get the inode of the file you want, and then go find that inode to get the data.
03:55:19 <binrapt> It sounds complicatedhm
03:55:52 <Taejo> cjs: what filesystems does it work on?
03:56:10 <cjs> Well, the BSD one works only on FFS, The Berkely Fast Filesystem.
03:56:34 <Taejo> ah, I see
03:56:41 <EvilTerran> binrapt, well, a few of us've used HAppS
03:56:42 <EvilTerran> ?where happs
03:56:43 <lambdabot> http://happs.org
03:57:00 <quicksilver> happs is most definitely complicated though :)
03:57:06 <binrapt> lol
03:57:10 <EvilTerran> is it?
03:57:17 <binrapt> Yeah I wanted to use ghci with cgi-bin actually
03:57:18 <quicksilver> Beelsebob: can I ask you a rather ill-formed question about FRP semantics?
03:57:18 <EvilTerran> i've not yet found that to be the case
03:57:40 <quicksilver> EvilTerran: what I mean is 'different', of course. Foolish mistake to make.
03:57:42 <EvilTerran> binrapt, there's a CGI module somewhere too, i think
03:57:50 <EvilTerran> ?hackage CGI
03:57:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CGI
03:57:52 <binrapt> Yeah there is mod_haskell and all
03:58:01 <binrapt> But I don't have root on that box anyways
03:58:03 <EvilTerran> ?hackage cgi
03:58:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cgi
03:59:24 <EvilTerran> the cgi package's probably what you want, then, if you have the priviledges to put stuff in cgi-bin but not much else
04:01:03 <EvilTerran> if the host lets you use binaries for cgi, you could upload compiled haskell to cgi-bin
04:01:51 * EvilTerran takes this opportunity to plug nearlyfreespeech.net , as they have ghc 6.8.3 available for CGI purposes
04:04:05 <binrapt> :O
04:05:38 <Twey> Wow, that's pretty awesome, EvilTerran
04:05:41 <Twey> Your company?
04:05:54 <EvilTerran> hah, i wish
04:06:09 <EvilTerran> if it was mine it'd've been a shameless plug :P
04:06:13 <EvilTerran> that was just a plug
04:07:19 <rwbarton_> > let g Nothing = 1 ; g (Just _) = 2 in let f ~x@(Just y) = g x in f Nothing
04:07:23 <lambdabot>   mueval: Prelude.read: no parse
04:07:23 <lambdabot>  mueval: *** Exception: /tmp/905731014537127...
04:07:42 <rwbarton_> "*** Exception: /tmp/2381868682160214634:59:84-102: Irrefutable pattern failed for pattern (x@(Data.Maybe.Just y))"  why?
04:07:43 <EvilTerran> various folk i know have hosted stuff with nearlyfreespeech, and i've helped out a bit and am pretty impressed so far, so i'm happy to recommend them to folk
04:08:22 <EvilTerran> "f ~x@(Just y) = g x" might as well be "f = g", i think
04:09:02 <rwbarton_> Sure, suppose g also takes y as a second parameter, but ignores it when y is Nothing
04:09:20 <EvilTerran> > let f ~x@Nothing = "nowt"; f _ = "fallthrough" in f (Just "testing")
04:09:23 <lambdabot>   mueval: Prelude.read: no parse
04:09:23 <lambdabot>  mueval: UnknownError "GHC reported errors a...
04:09:59 <Taejo> @pl return x = P (\toks -> (x, toks))
04:09:59 <lambdabot> return = P . (,)
04:10:09 <EvilTerran> ghci> let f ~x@Nothing = "nowt"; f _ = "fallthrough" in f (Just "testing")
04:10:11 <EvilTerran> "nowt"
04:10:25 <EvilTerran> yeah, so the ~ binds less tightly than the @, so the whole thing's irrefutable
04:11:10 <EvilTerran> as you're not using the y, and it's in an irrefutable pattern, the whole thing may as well not be there, leaving you with "f ~x = g x", which might as well be "f = g"
04:11:21 <rwbarton_> Yes, but that's not what ghci seems to think
04:11:25 <EvilTerran> ... aha, i see
04:11:42 <EvilTerran> ~x@(Just _) is different from x@ ~(Just _)
04:11:55 <rwbarton_> oh
04:11:56 <EvilTerran> in the former, the constructor has to match before it'll bind the variable
04:12:09 <rwbarton_> Yeah, I tried the second but it is a syntax error.  But maybe I need more parentheses
04:12:17 <EvilTerran> because the variable and constructor are in the same pattern, not separated by a ~
04:12:43 <rwbarton_> Yep, that fixed it, thanks
04:12:46 <EvilTerran> ~ only applies at the one level, it doesn't affect everything underneath it
04:13:11 <ivanm> the Chart library uses RGB values for colours... is there any way I can get n equally spaced apart colours?
04:13:20 <rwbarton_> ~x@(Just _) is the same as x@(Just _) then?  because ~x is the same as x
04:13:36 <EvilTerran> no, because the Just will be matched irrefutably in the former
04:13:48 <EvilTerran> so the pattern will always match
04:14:02 <EvilTerran> but you'll get an error if you try to use x and the parameter was Nothing
04:14:12 <EvilTerran> because the Just is no more irrefutable than the x is
04:14:48 <rwbarton_> oh, as opposed to going on to the next pattern or whatever.  ~x@(Just _) = ~(x@(Just _))
04:14:58 <EvilTerran> x@(~(Just _)) is the same as plain x, though
04:14:59 <EvilTerran> yeah
04:15:20 <EvilTerran> ~ binding tighter than @ would be pointless
04:15:38 <EvilTerran> because you can only have a variable on the left of @ anyway, and those always match even if you don't put a ~ in there
04:15:46 <Taejo> > break (== '=') "==foo"
04:15:49 <lambdabot>   ("","==foo")
04:15:54 <Taejo> > break (/= '=') "==foo"
04:15:57 <lambdabot>   ("==","foo")
04:16:03 <EvilTerran> > span (== '=') "==foo"
04:16:07 <lambdabot>   ("==","foo")
04:16:11 <EvilTerran> ?src break
04:16:12 <lambdabot> break p =  span (not . p)
04:16:19 <Taejo> thanks EvilTerran
04:16:21 <binrapt> error while loading shared libraries: libreadline.so.5: cannot open shared object file: No such file or directory
04:16:30 <binrapt> lol trying a binary dist was a bad idea I guess
04:16:57 <Taejo> ?type (&&&)
04:16:59 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:17:12 <Cale> binrapt: Just install libreadline
04:17:36 <binrapt> No root
04:17:39 <Taejo> @where (&&&)
04:17:39 <lambdabot> I know nothing about (&&&).
04:17:41 <Cale> (you couldn't have built it without readline anyway)
04:17:43 <binrapt> And I bet there will be 50 more .so's to come
04:17:53 <Cale> No, it's just libreadline and libgmp
04:17:56 <binrapt> Yeah I could try to build it, the box just sucks and it'll take forever
04:18:04 <binrapt> Ok
04:18:08 <Cale> You could install them in your user directory
04:18:49 <Cale> (and set LD_LIBRARY_PATH accordingly)
04:19:09 <quicksilver> installing programs without root on linux is always fiddly, this isn't a GHC problem. Actually GHC is pretty manageable since it only has 2 dynamic library dependencies and most haskell libraries install locally without trouble.
04:19:44 <binrapt> Can I get them via RPMs without root? Hm
04:20:00 <binrapt> It's Red Hat on a x86_64
04:20:05 <quicksilver> you can unpack the RPM by hand and put the .so in the right place and hope.
04:20:11 <quicksilver> I've never tried it I must admit.
04:20:12 <ivanm> OK, when haddock is used to build docs, does it create docs for all functions in the file, or only those with haddock comments?
04:20:19 <binrapt> Haha
04:21:07 <Taejo> ivanm: i think it does all the exported ones
04:21:35 <ivanm> well, there's a whole bunch of functions, etc. that aren't in the haddock docs for Chart that are exported :s
04:21:54 <Taejo> ivanm: maybe you need to pass a flag
04:22:38 <shapr> @yow !
04:22:39 <lambdabot> ... I see TOILET SEATS ...
04:22:55 <shapr> @quote dons
04:22:56 <lambdabot> dons says:  ah, it *is* like haskell, I see: Jiffy Pop is the family fun treat. No other brand of popcorn offers a self-contained popping pan. It can even be used outdoors.
04:23:03 <shapr> hah
04:23:10 <ivanm> unless this is another haddock 1 vs 2 issue :s
04:24:31 <cjs> It usually creates them for everything exported, in my experience.
04:26:21 <binrapt> lol damn, unpacking an RPM is a bitch
04:26:32 <binrapt> rpm2cpio blah
04:30:56 <Olathe> > sumPow 1
04:31:01 <lambdabot>   \x -> (x^2 + x) `div` 2
04:35:19 <EvilTerran> ?type sumPow
04:35:21 <lambdabot> Int -> Expr
04:35:30 <EvilTerran> > map sumPow [0..]
04:35:34 <lambdabot>   [\x -> x + 1,\x -> (x^2 + x) `div` 2,\x -> (2*x^3 + 3*x^2 + x) `div` 6,\x -...
04:35:35 <Saizan_> ivanm: do they have type annotations?
04:35:54 <ivanm> type annotations = haddock annotations?
04:36:01 <Saizan_> no
04:36:04 <EvilTerran> no, type annotations = "... :: ..."
04:36:11 <Saizan_> just explicit type signatures
04:36:12 <ivanm> oh, not all of them
04:36:18 <ivanm> is that why?
04:36:19 <ivanm> :@
04:36:22 <Saizan_> yeah
04:36:44 <Saizan_> haddock doesn't typecheck the code, it just parses signatures
04:37:14 <ivanm> *nod*
04:43:58 <mcnster> !hoogle umask
04:44:13 <shapr> Anyone heard of any Haskell <-> Google gears integration?
04:44:25 <mcnster> ?hoogle umask
04:44:26 <lambdabot> System.Posix.Internals c_umask :: CMode -> IO CMode
04:45:51 <mcnster> hmmm... i see no System.Posix.Internals in my docset, that's odd
04:46:18 <shapr> too bad hoogle doesn't also tell you which cabal package includes that code.
04:47:01 <Saizan_> it's probably unix
04:49:05 <mm_freak_> ok, i'm carefully writing a monad tutorial right now to increase haskell's comprehensibility and populariy…  but what can be done to make a real breakthrough?
04:49:26 <mm_freak_> i'd like to see haskell being deployed more than it is now, especially outside of academia
04:49:38 <shapr> well, it's improved dramatically in the last five years.
04:50:14 <Axman6> mm_freak_: you sure you can make monads easy to understand? i mean, there must be hundreds of articles trying to help people understand them...
04:50:23 <shapr> Five years ago there was one Haskell company, now there are several Haskell-primary-language companies, and quite a few companies that use Haskell to produce business stuff.
04:50:34 <shapr> Monad aren't hard! They're simpler than objects even.
04:50:40 <quicksilver> Axman6: well, monads are easier to understand than quite a few OO concepts.
04:50:42 <mm_freak_> Axman6: i'm developing a new way to explain them easily
04:50:57 <mm_freak_> they're only hard if your interpretation is hard
04:51:00 <quicksilver> Axman6: the problem is that most of the tutorial-readers already know (or think they know) OO and don't remember how hard it was.
04:51:00 <Axman6> i find OO stuff pretty easyc :\
04:51:03 <Axman6> easy*
04:51:14 <shapr> I think the biggest break through will happen when people realize that monads are simpler/easier than objects.
04:51:18 <Axman6> i never found it hard
04:51:24 <quicksilver> you find it easy now, Axman6. You did not when you learnt it first.
04:51:30 <quicksilver> I don't believe you, I'm afraid :)
04:51:32 <shapr> Axman6: Yeah, I agree with quicksilver
04:51:39 <quicksilver> I've taught programming to enough people over the years.
04:51:44 <quicksilver> of all kinds of ability levels.
04:51:53 <Axman6> ok, i understand objects in java pretty well :P
04:51:54 <shapr> I clearly remember how it took me several days of deep focus to figure out this crazy instance idea.
04:51:59 <mm_freak_> shapr, quicksilver: i think, the two concepts are unrelated, so comparison would not make much sense
04:52:05 <Axman6> Objective-C, not so much (which i learn first)
04:52:09 <shapr> mm_freak_: No, they're both abstractions.
04:52:16 <quicksilver> mm_freak_: Yes, comparison of the concepts does not make sense.
04:52:27 <quicksilver> mm_freak_: comparison of how hard they are to learn is meaningful though.
04:52:33 <shapr> And in fact, they're both often used as state-hiding abstractions, so there is a possible axis of comparison there.
04:52:38 <mm_freak_> shapr: monads and surreal numbers are both abstractions, too
04:52:46 <shapr> hm, interesting point
04:52:49 <quicksilver> mm_freak_: many of the 'Monads are too hard' crowd learnt OO. That's my point.
04:52:50 <mm_freak_> quicksilver: true
04:53:13 <quicksilver> "haskell cannot be useful because monads are too hard" is no more (or less) valid that "Java cannot be useful because OO is too hard"
04:53:18 <shapr> yeah
04:53:32 <shapr> Especially since the Java libraries are far more confusing than the language itself.
04:53:44 <Axman6> i don't agree with you
04:53:54 <shapr> J2EE, shall  I compare thee to a summer's day in the depth of the sahara?
04:54:03 <Axman6> i don't like java, but i do find it pretty intuitive
04:54:09 <mm_freak_> quicksilver: unfortunately, besides OOP being hard, it is much more intuitive for most people, while monads are something you can't see or touch
04:54:13 <shapr> Axman6: Have you tried Python?
04:54:27 <shapr> mm_freak_: You can't see or touch objects.
04:54:29 <mm_freak_> that's why people take the effort to learn OOP much more than monads, because they know they will understand it
04:54:36 <Axman6> maybe a little, but not all that much
04:54:37 <shteou> You ever tried touching virtual inheritance?
04:54:41 <Axman6> never took my fancy
04:54:50 <shapr> mm_freak_: exactly! Now people just have to realize they will understand monads just as easily!
04:54:54 <mm_freak_> shapr: i mean, the concept itself is taken from the real world
04:55:00 <mm_freak_> monads are something purely theoretic
04:55:02 <shapr> um, really?
04:55:08 <shapr> I disagree.
04:55:21 <mm_freak_> you disagree about the technical aspect
04:55:23 <mm_freak_> and i do, too
04:55:32 <mm_freak_> but look at the name and what the basic idea is
04:55:42 <mm_freak_> you have objects with properties and methods
04:55:44 <shapr> if object/instance is blueprint/actual item, then monads are just a conveyer belt.
04:55:48 <shapr> tadah!
04:55:49 <mm_freak_> that sounds intuitive
04:55:54 <shapr> um, no
04:56:14 <shapr> sure, real world objects have properties, but they don't have methods
04:56:33 <shapr> in fact, multimethods are a lot closer to the real world
04:56:39 <quicksilver> I don't think OO is particularly intuitive but I do take your point.
04:56:39 <Axman6> @src (>>=) :: Maybe Int
04:56:40 <lambdabot> Source not found. :(
04:56:44 <Axman6> :(
04:56:47 <mm_freak_> you can start your car or feed your pet, which is a method
04:56:52 <quicksilver> "objects with identity" is something we can see in the real world.
04:57:05 <mm_freak_> it is intuitive to most people…  that's a difference
04:57:05 <Saizan_> @src Maybe (>>=)
04:57:06 <lambdabot> (Just x) >>= k      = k x
04:57:06 <lambdabot> Nothing  >>= _      = Nothing
04:57:07 <quicksilver> "classes" also - like "apple".
04:57:11 <mm_freak_> yeah
04:57:18 <mm_freak_> objects with identity, good point
04:57:21 <quicksilver> so you start with some useful intuitions about classes and objects.
04:57:26 <quicksilver> but then it all falls aparat.
04:57:32 <quicksilver> actually programming with OO isn't remotely intuitive.
04:57:34 <Axman6> objects are easy. classes are plans for making new objects
04:57:38 <quicksilver> but I agree you get a handle to start with.
04:57:40 <shapr> but then, programming isn't intuitive
04:57:40 <Saizan_> mm_freak_: i think you should start with typeclasses, monads are just a nice special-case
04:57:46 <quicksilver> shapr: true.
04:57:50 <Axman6> (class = plan for car, instance object = the car)
04:57:54 <mm_freak_> yeah, but you have a good starting point with an example from real world, which readers will immediately understand
04:58:01 <shapr> Axman6: What about prototype based programming? That seems more intuitive than objects to me...
04:58:15 <Axman6> it may to me too, if i knew what it was :)
04:58:16 <shapr> I think the dual hierarchy of OOP is needlessly confusing
04:58:38 <Spark> dual hierarchy is intuitive
04:58:39 <osfameron> prototype OO is still OO
04:58:41 <shapr> prototype oriented programming, with javascript, cecil, self, etc is where you only have instances, never classes.
04:58:41 <mm_freak_> Saizan_: my tutorial is expecting that the reader is familiar with the basics of the type system
04:58:45 <Spark> in daily life, classes and objects are distinct
04:58:45 <osfameron> what's the dual hierarchy?
04:58:49 <shapr> oh, time to board my flight, bye!
04:58:51 <Spark> adjectives and nouns
04:58:56 <FordCortina> @src flip
04:58:57 <lambdabot> flip f x y = f y x
04:59:00 <mm_freak_> hf, shapr
04:59:08 <osfameron> OO has adjectives now?
04:59:10 <quicksilver> Spark: I don't really think it's adjectives and nouns.
04:59:11 <FordCortina> :t flip
04:59:13 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:59:19 <quicksilver> Spark: class = "car"; object = "this car over here"
04:59:28 <Spark> class = car-like
04:59:35 <quicksilver> No, class = "car.
04:59:35 <Spark> when you consider inheritance :)
04:59:48 <quicksilver> subclass = "ford mustang"
04:59:51 <purestorm> Hi. Is it possible to say "read n bytes" with Parsec where n depends on a previously parsed sequence of digits which is interpreted as a number?
05:00:04 <quicksilver> purestorm: yes.
05:00:09 <mm_freak_> class = car-like is more like haskell's type system
05:00:15 <Axman6> instance = my ford mustang
05:00:24 <quicksilver> Axman6: right. "this one here"
05:00:28 <quicksilver> a particular one.
05:00:29 <mm_freak_> class = "car" is OO
05:00:47 <Axman6> anyway, enough of OO, someone explain monads clearly
05:00:50 <Axman6> ... go!
05:00:53 <Spark> it doesn't have to be an adjective but it does have to be a description
05:00:55 <mm_freak_> =)
05:00:57 <quicksilver> purestorm: do { n <- parseNumber; bytes <- parseBytes n }
05:01:09 <purestorm> Ah, and then use state?
05:01:19 <purestorm> Hrm, I hoped there was something like a parametrizeable many.
05:01:24 <purestorm> But fair enough... :)
05:01:26 <quicksilver> purestorm: you don't need states explicitly.
05:01:30 <quicksilver> the 'n' is the number.
05:01:34 <mm_freak_> purestorm: there is
05:01:35 <dmhouse> quicksilver: that do block won't work
05:01:42 <FordCortina> :t \f x y -> f y x $ elem
05:01:43 <lambdabot> forall t t1 b a. (Eq a) => (t1 -> t -> (a -> [a] -> Bool) -> b) -> t -> t1 -> b
05:01:48 <osfameron> oh the duel hierarchy is the class vs metaclass thing?  That does confuse me certainly.
05:01:55 <quicksilver> dmhouse: is was incomplete. Or did you mean something else?
05:01:57 * dmhouse hasn't been following, but is pretty sure you need an expression at the end oof that
05:02:03 <FordCortina> :t (\f x y -> f y x) $ elem
05:02:05 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
05:02:11 <dmhouse> quicksilver: oh, you followed it up with a `}', which made me assume that was it
05:02:16 <quicksilver> purestorm: you don't need a paramterised many. Many is for when you don't know how many.
05:02:24 <quicksilver> purestorm: when you do, you can just use 'replicateM'
05:02:26 <purestorm> quicksilver: But I know how many :)
05:02:48 <quicksilver> purestorm: do { n <- parseNumber; stuff <- replicateM n oneThing; .... }
05:03:04 * Axman6 is waiting for a clear monad explanation...
05:03:06 <quicksilver> purestorm: replicateM n is like many, except you know how many.
05:03:19 <quicksilver> Axman6: are you happy with a pure function (a -> b) and what it means?
05:03:30 <Axman6> how about... what is the point of >>=?
05:04:14 <Axman6> quicksilver: takes an a, and returns a b, yes?
05:04:25 <mm_freak_> Axman6: i won't tear monads apart…  i'll explain them as a whole
05:04:37 <quicksilver> Axman6: and it's a mathematical function, so it always returns the same 'b' for a given 'a'.
05:04:48 <Axman6> yep
05:05:02 <quicksilver> Axman6: well monads is things like (a -> m b) which is a *computation* but not necessarily a function
05:05:13 <quicksilver> which computes 'b' from 'a' but may do other things along the way.
05:05:24 <quicksilver> the study of which kinds of "other things" is how you classify different monads.
05:05:52 <Axman6> like IO does IO, and returns something after that?
05:05:56 <quicksilver> Yes.
05:06:07 <mm_freak_> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/f41e33857cc52047/f7157ff67415a9f3#f7157ff67415a9f3 ⇐ i'll use this post as the basis
05:06:10 <lambdabot> Title: side-effects, I/O, and the lot - comp.lang.functional | Google Groups, http://tinyurl.com/5c27gk
05:06:23 <quicksilver> in particular it might not always return the same 'b', or it might not return at all (might crash), and so on
05:06:47 <purestorm> http://hpaste.org/10104 <-- This does not work, quicksilver. I'm a newbie, any ideas?
05:06:54 <Axman6> so it doesn't work like a function
05:06:56 <mm_freak_> (and i'd like to hear your feedback for that post)
05:07:00 <BeelsebobWork> quicksilver: sorry, I missed your question upchannel
05:07:07 <purestorm> argh
05:07:08 <BeelsebobWork> only realised when I went home for lunch
05:07:21 <purestorm> nvm
05:08:37 <quicksilver> BeelsebobWork: that's OK :)
05:08:48 <quicksilver> BeelsebobWork: you have a moment now?
05:08:50 <BeelsebobWork> sure
05:09:17 <quicksilver> BeelsebobWork: I have probably a really stupid semantic block.
05:09:30 <quicksilver> BeelsebobWork: suppose I have two different Event streams
05:09:45 <quicksilver> and I have some useful behaviour which evolves, depending only on the first stream.
05:09:51 <BeelsebobWork> uhhuh
05:10:27 <quicksilver> then some time later the behaviour evolves so after a certain point it 'suddenly' starts taking notice of the other Event stream.
05:10:36 <BeelsebobWork> k
05:10:42 <quicksilver> does it 'suddenly' get a backlog of all previous events on that stream?
05:10:46 <quicksilver> or does it start from where it is?
05:10:54 <BeelsebobWork> hmm, good question
05:10:57 <quicksilver> I can't quite see how the high level semantic stuff defines this.
05:11:10 <quicksilver> it ought to be an algebraic question not an implementation one.
05:11:38 <quicksilver> I have a feeling the question is poorly stated and if correctly stated the answer would be obvious :)
05:12:04 <BeelsebobWork> word from conal is that yes you'll get the backlock
05:12:07 <BeelsebobWork> backlog*
05:12:11 <BeelsebobWork> but that this is nothing new
05:12:32 <BeelsebobWork> it's roughly equivalent to suddenly deciding you want to read into the middle of an infinite list
05:12:49 <BeelsebobWork> so as with lists, you can get space/time leaks
05:12:57 <BeelsebobWork> and you have to be a little careful to dodge them
05:13:26 <quicksilver> conal: oh, you're here :)
05:14:00 <quicksilver> BeelsebobWork: *nod*. I think probably choosing the 'right' combinators to build up your complex behaviours avoids this problem.
05:14:07 <quicksilver> BeelsebobWork: I'm not sure what the 'right' combinators are yet.
05:14:10 <BeelsebobWork> that sounds likely
05:14:13 <conal> yes
05:14:35 <conal> part of my motivation for multi-occurrence events, unlike the very first fran.
05:14:48 <quicksilver> conal: I've had some very useful conversations with BeelsebobWork over the last few days and re-read the paper lots of times.
05:15:07 <conal> quicksilver: oh, nifty.
05:15:07 <quicksilver> conal: making a determined effort to make some of my in development programs FRP or at least 'more FRP-like'
05:15:16 <conal> :) :)
05:15:37 <quicksilver> conal: e `mappend` e definitely *should* have double occurences for each event, shouldn't it?
05:15:59 <conal> quicksilver: yes
05:16:13 <quicksilver> that's what I thought. compositionality goes a bit screwy without that.
05:16:20 <conal> exactly
05:16:44 <quicksilver> conal: in terms of hooking up legacy code and doing simple examples, I'm finding "Event (IO ())" a useful type.
05:17:34 <conal> quicksilver: i bet.  also Reactive (IO ()) and Behavior (IO ())
05:17:44 <conal> though really O, rather than IO
05:18:05 <quicksilver> I'm not sure how useful Behaviour (IO ()) is
05:18:17 <quicksilver> it's bit weird to sample a continuous stream of IO actions.
05:18:26 <conal> as i said, they're not really IO
05:18:29 * quicksilver nods
05:18:30 <conal> they're output
05:18:33 <quicksilver> yes, really they're O.
05:18:42 <conal> the point is to have functional semantics
05:18:46 <conal> not IO
05:18:51 <BeelsebobWork> quicksilver: how about one that at every time produces the O actions required to render the screen
05:18:53 <quicksilver> I prefer to think of the Behaviour one as more like a pair (Behaviour a, a -> IO ())
05:19:03 <quicksilver> obviously by 'fmap' that's the same thing :)
05:19:08 <quicksilver> so maybe I'm being silly.
05:19:08 <conal> right
05:19:11 <BeelsebobWork> that sounds like an entirely likely Behavior (O()) to me
05:19:21 <quicksilver> yes, it is the same BeelsebobWork ;)
05:19:24 <quicksilver> I think I'm being daft.
05:19:37 <conal> maybe not.  i have a similar discomfort, in that i don't know a theory of O
05:19:53 <quicksilver> conal: well as a gradual process we can push O back.
05:20:09 <conal> quicksilver: please say more about "push O back"
05:20:32 <quicksilver> conal: hide it in the RTS in the way that the implementation of IO is hidden in teh GHC RTS
05:20:39 <Axman6> is there a reason why there's no separate I and O monads? seems like the idea could have some benefits...
05:20:40 <quicksilver> and eventually pretend it doesn't exist.
05:20:40 <conal> yes!
05:21:08 <conal> quicksilver: that's exactly what i want to do.  eliminate IO entirely from Haskell's programming model, moving it into the RTS.
05:21:08 <quicksilver> Behaviour (O ()) isn't quite enough for a useful program.
05:21:17 <quicksilver> You want to control how often it gets called.
05:21:24 <quicksilver> "as often as possible" or "up to 30 fps" or something.
05:21:44 <conal> quicksilver: yeah.  there's a big creative space there.  even just in specification.
05:21:52 <quicksilver> and things like opening new windows introduce new 'output behaviours'
05:22:08 <quicksilver> but maybe that is all hidden inside a suitably large output monoid.
05:22:45 <quicksilver> conal: I'm developing my own reactive implementation. Not beacuse I don't trust yours, but because I need to think it through concretely.
05:23:07 <quicksilver> conal: After a few reads of your paper, I find the whole Event/Reactive/Future mutual recursion a convincing model.
05:23:22 <quicksilver> conal: however, I don't find your chosen implementation of Future entire convincing.
05:23:27 <conal> quicksilver: cool.  i keep hearing about people doing their own implementations.  i'm glad the ideas are giving rise to some inspiration.
05:23:38 <quicksilver> I'm trying to build my own. It may well be that it will eventually converge to exactly yours.
05:23:44 <quicksilver> at which point I will understand why you did it that way.
05:24:01 <conal> quicksilver: makes sense to me.  i'd like to hear how it goes.
05:24:03 <Axman6> quicksilver: and then you level up
05:24:25 <conal> quicksilver: about output, maybe the theory of TV/Eros will give an answer.  it keeps interactive/displayable separable from pure values, so they're bothy usable and composable.
05:24:31 <quicksilver> conal: I think you're finessing something when you say "The semantics of futures can also be used as an implementation"
05:24:52 <quicksilver> conal: I don't think they can, really, because the semantics is from an abstract mathematical standpoint where you can 'see the future'.
05:25:05 <quicksilver> conal: that's a common view to take for semantics, of course.
05:25:15 <quicksilver> conal: but once you're programming you can't see the future any more, so your implementation can't.
05:25:22 <quicksilver> Axman6: heh ;)
05:25:33 <quicksilver> Axman6: FunctionalProgrammer needs more food!
05:26:12 <cjs> So if I wanted to implement a modular system in Haskell, where someone could compile a Haskell module that comforms to the interface as a shared lib, and I'd load it dynamically, how would I go about doing that?
05:26:22 <Axman6> > lambdasnack quicksilver
05:26:25 <lambdabot>   mueval: Prelude.read: no parse
05:26:32 <quicksilver> cjs: GHC already has most of the bits and pieces of that.
05:26:35 <Axman6> sure...
05:26:41 <cjs> Got a module name for me?
05:26:41 <conal> quicksilver: an implementation see the future?
05:26:52 <quicksilver> cjs: it does, in principle, support dynamic loading of modules, it's just not exported functionality. GHCi uses it.
05:26:57 <conal> quicksilver: mine does
05:26:58 <quicksilver> cjs: and hs-plugins uses it.
05:27:03 <cjs> Ah.
05:27:18 <quicksilver> conal: well, your implementation is clever, but it relies on concurrency and blocking values.
05:27:36 <quicksilver> conal: I'm not saying that's not clever - it is - but in my mind it falls short of a direct implementation of the semantics.
05:27:42 <conal> quicksilver: just on unamb, which is for me part of the rts.
05:27:49 <quicksilver> conal: I'm also not 100% sure it's Haskell.
05:27:55 <conal> :)
05:28:13 <quicksilver> so you can't really claim you're inheriting the simple (although not written down) semantics of haskell to give your implementation meaning.
05:28:22 <quicksilver> you're doing something clever, which works, but needs proving.
05:28:23 <quicksilver> IMO.
05:28:24 <conal> btw, i'm going to factor unamb out of reactive, so people will more easily understand it as its own purely functional primitive.
05:28:33 <cjs> Oh, and look at that, it's another module by dons.
05:28:45 <quicksilver> purely functional primitive ... with an undecidable side condition.
05:28:53 <quicksilver> that's a pretty big caveat.
05:29:05 <quicksilver> it's only pure when you use it right.
05:29:30 <conal> right
05:29:39 <quicksilver> cjs: that's what ghci is doing after all, when you reload your code after a change.
05:29:55 <quicksilver> cjs: it's dynamically linking in the new code (which conforms to a known interface)
05:30:00 <cjs> Hm. Right.
05:30:14 <conal> quicksilver: i don't know how to make that condition be statically checked, short of dependent types.
05:30:16 <quicksilver> cjs: however there isn't a really easy interface to it for ordinary users, AFAIK.
05:30:20 <quicksilver> hs-plugins is the best.
05:30:36 <quicksilver> conal: You can't. It's undecidable in general.
05:30:55 <conal> quicksilver: proof generation is.  proof checking isn't.
05:30:56 <quicksilver> conal: which is, kind of, the problem.
05:31:02 <quicksilver> right.
05:31:09 <conal> that's what i meant about dependent types.
05:31:14 <quicksilver> ok, understood.
05:31:20 <cjs> I am not an ordinary user. :-)
05:31:20 <quicksilver> conal: none of this is meant to criticise.
05:31:44 <quicksilver> conal: just to underscore the hidden depths between your cheerful statement "The semantics of futures can also be used as an implementation" ;)
05:31:56 <conal> quicksilver: :)
05:32:06 <quicksilver> conal: I didn't recognise the hidden depths until the second or third time I read it.
05:32:35 <conal> quicksilver: yes indeed, there's considerable subtlety there.  it took me a very long time to come up with this new approach.
05:32:45 <cjs> Ooo, it's got eval, too. This is good stuff.
05:32:51 <quicksilver> conal: so do you and BeelsebobWork work together these days? Or are you just both interested parties in the same stuff?
05:32:56 <FordCortina> :t \x -> x + x
05:32:58 <lambdabot> forall a. (Num a) => a -> a
05:32:59 <conal> quicksilver: and a week of pacing, doodling, and mumbling to myself to come up with unamb and its use.
05:33:17 <conal> quicksilver: BeelsebobWork & i work together.  in the same room atm.  until i head back to the US.
05:33:35 <quicksilver> conal: cool.
05:34:33 <quicksilver> conal: is there a good reference on what combinators are necessary to use Reactive, independent of implementation?
05:34:50 <quicksilver> conal: I was missing something important which isn't in the paper. BeelsebobWork found it for me : it's called "snapshot" in your source.
05:35:18 <quicksilver> (and it's not implementable with the primitives either)
05:35:22 <quicksilver> I wonder what else is needed?
05:36:10 <BeelsebobWork> quicksilver: e `snapshot` O rf = f <$> (withTimeE e `R.snapshot` rf) where f ((t,a),tfun) = (a, tfun `apply` t)
05:36:24 <quicksilver> BeelsebobWork: yes, I found the source.
05:36:28 <BeelsebobWork> it is implement{able|ed} with the primitives though
05:36:32 <quicksilver> BeelsebobWork: but R.snapshot has to be primitive.
05:36:36 <BeelsebobWork> oh, I see
05:36:47 <RayNbow> what's a good introductory paper on FRP?
05:36:53 <conal> quicksilver: for now the source jumbles up the functional (no-IO) interface and some stuff required to hook it up to imperative systems (affectionately named "legacy adapter").  it'll be much better sorted out when we're done with this project.
05:37:08 * quicksilver nods
05:37:25 <conal> quicksilver: i want to make it hard for people to mix functional and IO code.  so they notice the difference.
05:37:40 <quicksilver> my gut is you can get quite a long way with fmap, switcher, snapshot, mappend.
05:38:00 <quicksilver> you need a primitive to create timed events, e.g. a 1 second ticker.
05:38:28 <conal> quicksilver: yep.  easy to define in terms of the representation.
05:38:33 <mcnster> ?hoogle exec
05:38:34 <lambdabot> Control.Monad.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
05:38:34 <lambdabot> Control.Monad.RWS.Strict execRWS :: RWS r w s a -> r -> s -> (s, w)
05:38:34 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
05:38:38 <quicksilver> conal: I have an observation that join for Event and join for Reactive are completely different.
05:38:53 <quicksilver> conal: that seems surprising given how closely linked the types are.
05:39:09 <conal> quicksilver: right.  Event is sort of like [], while Reactive is more like ZipList
05:39:10 <quicksilver> conal: join for reactive is "obviously" right. join for event could have been either one, it seems to me.
05:39:59 <mcnster> is there a haskell library fn for exec(3)?
05:40:36 <lilac> @hoogle exec
05:40:36 <lambdabot> Control.Monad.RWS.Lazy execRWS :: RWS r w s a -> r -> s -> (s, w)
05:40:36 <lambdabot> Control.Monad.RWS.Strict execRWS :: RWS r w s a -> r -> s -> (s, w)
05:40:36 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
05:40:40 <conal> quicksilver: for me as well, Event is the least compelling/inevitable of the type in Reactive.
05:41:00 <quicksilver> conal: you mean everything about Event? or just its monad instance?
05:41:07 <lilac> @hoogle runCommand
05:41:07 <lambdabot> System.Process runCommand :: String -> IO ProcessHandle
05:41:24 <Cale> :t System.Posix.Process.executeFile
05:41:26 <lambdabot> FilePath -> Bool -> [String] -> Maybe [(String, String)] -> IO ()
05:41:48 <Cale> (if you're looking for that close of a match ;)
05:42:21 <quicksilver> conal: I'm not convinced that Monad/Applicative for Event will be useful. If you want Applicative for event, applicative for the corresponding Reactive feels like a cleaner notion.
05:42:22 <Cale> There's also a bunch of stuff in System.Process which isn't so Posix specific.
05:42:40 <mcnster> great!  thx Cale :)
05:42:49 <Cale> HSH is rather good if you're just looking to have a convenient way to run programs and capture/pipeline their output.
05:43:08 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH
05:43:08 <quicksilver> conal: (rationale: with f <*> a, in a reactive "f" and "a" "exist" at all times t. In an event, they only exist at discrete times and it's not obviously a sensible thing to do)
05:43:13 <lambdabot> Title: HackageDB: HSH-1.2.6
05:43:14 <Cale> http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH.html
05:43:16 <lambdabot> Title: HSH, http://tinyurl.com/5olmj5
05:43:21 <conal> quicksilver: you're not the only Event monad skeptic.  (and btw, i explained in the paper why i don't expect the Applicative instance of Event to be useful.)
05:43:21 <Cale> (check out examples :)
05:43:38 <quicksilver> conal: you did, yes. And the same caveat applies to its Monad instance too.
05:43:48 <conal> quicksilver: i don't think it does
05:43:51 <mcnster> no, i want to replace the haskell process never to be seen again, but i'll keep HSH in mind
05:44:24 <quicksilver> conal: typical Monad instance usage is "do { k <- keypresses; m <- keydetailevents k; return (m,k) }
05:44:46 <quicksilver> conal: I'm not sure the event instance makes that do anything very meaningful.
05:46:51 <quicksilver> conal: anyhow, I'm pretty sure `mappend` and `fmap` are the most interesting things to do with Events.
05:48:29 <conal> quicksilver: brb. BeelsebobWork is distracting me.
05:48:36 <quicksilver> conal: no worries.
05:49:24 <lilac> suppose I have an Arrow a with a function a (b,c) (a c d) -> a b d. is this equivalent to a Monad?
05:50:57 <mmorrow> mcnster: \cmd -> system ("exec "++cmd)   ?
05:51:02 <Saizan_> ?type app
05:51:04 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
05:51:25 <mcnster> ?hoogle select
05:51:26 <lambdabot> Text.XHtml.Frameset select :: Html -> Html
05:51:26 <lambdabot> Text.XHtml.Strict select :: Html -> Html
05:51:26 <lambdabot> Text.XHtml.Transitional select :: Html -> Html
05:51:31 <Saizan_> lilac: yes ^^^
05:51:50 <lilac> Saizan_: how do you implement app in terms of my function?
05:52:03 <mcnster> this may be more problematic, but is there a haskell lib fn for select(2)?
05:52:36 <mmorrow> mcnster: there's one in ghc with a comment to the effect of "split this into a lib, it'll be useful"
05:52:51 * mmorrow finds where (you can import it of course)
05:55:13 <mcnster> mmorrow, i haven't found it yet, is it in the standard libs?
05:57:55 <BeelsebobWork> sorry quicksilver, I've relinquished conal
05:59:02 <mmorrow> mcnster: line 1234  http://darcs.haskell.org/libraries/base/GHC/Conc.lhs
05:59:34 <quicksilver> mcnster: you don't need select if you just want to use it on standard Handles (including sockets)
05:59:48 <quicksilver> mcnster: you just use them. They are select()'ed under the hood.
05:59:48 <mmorrow> mcnster: at the very least, it'll give you an example it being accessed via the ffi
05:59:56 <mmorrow> yeah, what quicksilver said
06:00:07 <Saizan_> lilac: app = foo (arr (\((arrow,b),_) -> arr (const b) >>> arrow)) where foo is your function
06:00:34 <quicksilver> Saizan_: nice :) I was trying to give him that answer and couldn't quite get it straigth.
06:00:55 <Saizan_> the 'c' was getting in the middle :)
06:01:40 <mcnster> thx mmorrow :)
06:03:08 <lilac> Saizan_: thanks! :)
06:03:10 <mmorrow> :)
06:03:14 <conal> quicksilver: back.  here's my thinking about the Event monad.  An event is a generator of timed values.  An event-valued-event then generates generators, and join flattens it into lots of timed values.
06:03:44 <conal> quicksilver: for instance, there could be an event of someone enterring a room, with the value being an event of that person speaking.
06:03:49 <quicksilver> conal: Yes, I do think that 'join' makes some kind of sense.
06:04:04 <quicksilver> conal: but somehow that doesn't quite justify it being a monad ;)
06:04:18 <conal> quicksilver: no??
06:05:03 <quicksilver> just an intuitive feel, I guess.
06:05:14 <quicksilver> therefore likely to be wrong :)
06:05:16 <conal> quicksilver: as i said, you're not alone in your skepticism.  and i don't mind.  maybe i'll come up with some compelling demonstrations.  though i do hope to replace Event with something more compelling.
06:05:25 <quicksilver> replace it entirely?
06:05:33 <quicksilver> gosh, it seems like a good model for incoming events to me.
06:05:51 <conal> quicksilver: replace the semantic model.  which for me *is* the type.
06:06:02 <quicksilver> Ah.
06:06:07 <fophillips> Is there a reason “0 .&. 1 == 0” returns an error but both “>= 0” and “<= 0” don’t.?
06:06:28 <conal> quicksilver: for instance, it doesn't satisfy the type-class morphism properties that the other types all do.
06:06:30 <quicksilver> fophillips: an ambiguous type error, would that be?
06:06:38 <fophillips> quicksilver: yep
06:06:51 <quicksilver> fophillips: because defaulting only applies to expressions using only Prelude types.
06:06:55 <quicksilver> sorry, Prelude classes.
06:07:05 <quicksilver> and 'Data.Bits.Bits' isn't a Prelude class.
06:07:15 <quicksilver> defaulting is a bit weird and mostly useful for interactive things like ghci.
06:07:26 <quicksilver> conal: hmm, what do you mean?
06:08:19 <mmorrow> > 0 .&. (1::Int) == 0
06:08:22 <lambdabot>   True
06:08:24 <conal> quicksilver: for the other types, i specified the semantics of the methods in a succinct, systematic manner, saying that the semantic function is a class morphism.
06:08:43 <mmorrow> > 0 .&. (1::Word8) == 0
06:08:44 <quicksilver> conal: right. Yes, I understand.
06:08:46 <lambdabot>   True
06:08:55 <mmorrow> > 0 .&. (1::Int64) == 0
06:08:58 <lambdabot>   True
06:09:13 <conal> quicksilver: i've been seeing that pattern a lot over the last year or two.  even with memo tries, recently.
06:09:33 <quicksilver> conal: Behaviour = Reactive `o` Fun Time is really really nice, by the way.
06:09:37 <conal> quicksilver: i take it as a sign from the gods that i'm on a good track, though i don't see where exactly it leads.
06:09:54 <conal> quicksilver: thx!  that was quite a flash of insight for me.  :)
06:09:57 <quicksilver> I have often thought that there ought to be a way to decompose the continuous and discrete components like that but never found it.
06:10:33 <conal> quicksilver: in retrospect, it seemed so obvious.  but i didn't see it for many years.
06:10:37 * quicksilver nods
06:10:44 <quicksilver> stuff always seems obvious in retrospect.
06:10:49 <quicksilver> it's quite annoying, really ;)
06:11:08 <quicksilver> s/always/often/
06:11:28 <conal> "At first people refuse to believe that a strange new thing can be done.  Then they begin to hope it can be done. Then they see it can be done. Then it is done and all the world wonders why it was not done centuries ago." (Frances Hodgson Burnett)
06:11:41 <mmorrow> :)
06:12:03 <lilac> is there a proof that Monad can't be derived from ArrowChoice?
06:12:27 <mmorrow> @src ArrowChoice
06:12:28 <lambdabot> Source not found. You type like i drive.
06:12:50 <lilac> @type left -- primitive
06:12:52 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
06:13:29 <conal> quicksilver: i expect Event to turn into something simple & "obvious".  it still feels like "work" to me.  i.e., that i'm making it work instead of seeing something else that already wants to work.
06:14:36 <conal> quicksilver: oh.  btw, quickcheck testing turned up that one of the monad laws fails for Event.  oops!
06:14:53 <quicksilver> conal: was going to ask you that :)
06:15:11 <Saizan_> lilac: nothing rigorous i think, but ArrowChoice lets you do a decisions with a finite number of cases, while in (>>=) :: m a -> (a -> m b) -> m b, 'a' can be a type with infinite values
06:15:18 <quicksilver> conal: in an interesting way, or just something stupid to with _|_s and delayed evaluation.
06:15:41 <conal> quicksilver: so, as you said "somehow [join] doesn't quite justify it being a monad ;)"
06:15:45 <quicksilver> ;)
06:15:55 <conal> quicksilver: simultaneous occurrences can get re-ordered.
06:16:00 <cjs> Hm. How can I arrange a setup such that I store opaque state given to me by something. A la file handles or whatever?
06:16:26 <quicksilver> cjs: abstract data type? controlled by the 'Something'
06:16:32 <quicksilver> data FooHandle -- don't export the constructor.
06:16:42 <quicksilver> conal: I don't think that's a big failing.
06:16:46 <ivanm> if I want to read text entered at the prompt, it's just readLn, isn't it?
06:16:46 <quicksilver> conal: but maybe I'm wrong.
06:16:57 <cjs> Right, I was thinking that, but suppose I have another thing with the same interface that I want to use, and I don't know which one I'm using?
06:17:03 <cjs> (And don't want to know.)
06:17:03 <quicksilver> conal: I don't think the order of simultaneous occurances should be relied upon.
06:17:13 <conal> quicksilver: well, i was shooting for True and i hit False.  ;)
06:17:17 <lilac> Saizan_: yes, but... the (a -> m b) can only make finitely many choices if it terminates, so i'm not 100% convinced
06:17:31 <quicksilver> cjs: data AnyOldFoo -- dont export the constructor ;)
06:17:39 <conal> quicksilver: maybe so (ordering).  though i don't know how to eliminate the importance.  considering accumE.
06:17:48 <cjs> Basically, I've got several different ways to read in a market feed, and I want to just hook up to one of these, and let it convert whatever format it's reading into my generic format.
06:17:53 <cjs> But some of these functions need state to do that.
06:18:03 <quicksilver> cjs: you might make AnyOldFoo as an exhaustive list of the possibilities, or you might make it a dictionary with an existential, or you might make it a typeclass with an existential.
06:18:11 <cjs> E.g., they have to keep a dictionary to translate names into different names.
06:18:15 <cjs> existential?
06:18:35 <quicksilver> @go haskellwiki existential types
06:18:46 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
06:18:46 <lambdabot> Title: Existential type - HaskellWiki
06:19:08 <conal> quicksilver: btw, i'm delighted with your interest and deep explorations in FRP & Reactive.
06:19:25 <quicksilver> conal: yes, it might be observable, but I would not necessarily think it 'matters'.
06:19:49 <quicksilver> conal: I would be inclined to define `mappend` as being non-deterministic in what it does with simultaneous events
06:19:55 <quicksilver> (which makes the monoid commutative)
06:20:10 <conal> quicksilver: hm. change the semantic model to powersets?
06:20:23 <quicksilver> which would imply it's not safe to use accumE unless you have a suitable commutativity condition.
06:20:27 <quicksilver> e.g. you don't care :)
06:20:53 <conal> quicksilver: yeah.  we could do that.   another "undecidable side condition" ;)
06:21:04 <quicksilver> conal: change the semantic model to streams of bags of occurences.
06:21:13 <Saizan_> lilac: how do you write something like "bar >>> arr (\x -> (readFile x,()) >>> app" with ArrowChoice? readFile :: FilePath -> () ~> String
06:21:29 <quicksilver> and specify all your operations as being non-deterministic in the order of simultaneous occurence, I guess.
06:21:35 * quicksilver shrugs
06:21:36 <quicksilver> maybe it's too high a cost to pay.
06:21:56 <quicksilver> conal: I always view the list monad, for example, as being 'order shouldn't really matter'
06:22:08 <conal> quicksilver: oh -- the bag monad
06:22:10 <quicksilver> it's just an implementation quirk that it does.
06:22:11 <quicksilver> yes.
06:22:17 <Elly> bag monad?
06:22:20 <osfameron> why shoultn't it matter?
06:22:25 <osfameron> a List *is* explicitly ordered
06:22:29 <quicksilver> I wouldn't write code in the list monad which depended on order.
06:22:31 <lilac> Saizan_: you'd need to generate a set of choices like "if it starts empty then this, or if it starts with '\0' then that, or if it starts with '\1' then the other thing, or..."
06:22:35 <quicksilver> osfameron: because it models non-determinism.
06:22:45 <dmhouse> Elly: a multi-set
06:22:47 <osfameron> oh?
06:22:48 <quicksilver> osfameron: and when a function returns multiple values, there is no preferred order in those values.
06:22:50 <dmhouse> Elly: with duplicates, without ordering
06:22:52 <Elly> why is that a monad? o_O
06:22:57 <osfameron> I thought it modelled a cartesian product
06:23:02 <quicksilver> osfameron: that's my model. You may have your own.
06:23:09 <EvilTerran> Elly, it's modelled by the list monad
06:23:09 <quicksilver> I'm not trying to say my way is the only way :)
06:23:13 <osfameron> heh
06:23:15 <quicksilver> but that's the way I choose to think of it.
06:23:29 <quicksilver> osfameron: it does model cartesian product.
06:23:34 <EvilTerran> Elly, it's just that a true bag monad would be unordered
06:23:38 <quicksilver> osfameron: but it doesn't matter which order you present the results of the product.
06:24:03 <quicksilver> osfameron: tossing two coins, say. Doesn't matter if I present the results as HH TH HT TT or TT TH HT HH
06:24:03 <EvilTerran> Elly, so (return x `mplus` return y) would be the same as (return y `mplus` return x)
06:24:19 <dmhouse> You can get the bag monad from the list monad by changing the Eq instance, and not exporting functions like head, tail and (!!)
06:24:33 <Saizan_> lilac: yeah, but that's no more parametric on 'a' for a start, also it's not really doable
06:24:55 <lilac> Saizan_: it'd need a typeclass to do the structural recursion
06:24:56 <quicksilver> conal: I write (just for fun) openGL programs and games which have quite complex modality.
06:25:21 <quicksilver> conal: modality and events in an imperative setting are a pain.
06:25:22 <EvilTerran> you could think of Omega as being closer to a bag monad - as the ordering isn't very intuitive, it may as well not be ordered
06:25:25 <lilac> Saizan_: but i /think/ it's possible, at least
06:25:31 <conal> quicksilver: very much!
06:25:35 <EvilTerran> http://hackage.haskell.org/packages/archive/control-monad-omega/0.2/doc/html/Control-Monad-Omega.html
06:25:38 <lambdabot> Title: Control.Monad.Omega, http://tinyurl.com/5crxz4
06:25:45 <quicksilver> conal: "I received a mouse click but what it actually means depends what mode I'm in, hmm, let me see"
06:25:51 <quicksilver> conal: so, I seek a better way ;)
06:26:09 <tusho> damn, i really need a reddit killfile to get rid of americanhellyeah.
06:26:27 <quicksilver> conal: that's kind-of what motivated my question to BeelsebobWork about events and backlogs. When I switch mode I don't want to suddenly get all the old keypresses.
06:26:35 <quicksilver> conal: I don't think I will, as long as I use the right combinators.
06:26:55 <EvilTerran> tusho, if reddit doesn't support it itself, there may well be a ffx extension or greasemonkey script to do it
06:27:01 <tusho> EvilTerran: yes, i believe so
06:27:06 <conal> quicksilver: i hope so.  that's my intention.  if it's not easy, i'd like to rework the interface.
06:27:14 <tusho> hm i think i could use a stylish script to kill it off
06:27:22 <EvilTerran> or that :)
06:27:25 <tusho> it's only comments, really, submissions never get on /r/programming so i don't need to worry about them
06:27:34 * tusho opens Stylish
06:28:02 <lilac> Saizan_: i think it might be possible to get (ArrowChoice a, Data b) => a (a b c, b) c
06:29:28 <quicksilver> conal: one of these programs is also network capable and if I can get that bit using network Events that will be even more fun.
06:29:43 <ivanm> is there any way I can force the parametric type for a function in a where block to be the same type for the overall function?
06:29:45 <quicksilver> conal: although actualy it currently uses Chans in a mostly-functional way and that's not really so far off FRP.
06:29:55 <cjs> quicksilver: I'm not sure that existential types are the solution to my problem.
06:30:01 <quicksilver> ivanm: you need -XScopedTypeVariables
06:30:05 <quicksilver> ivanm: or whatever it's called.
06:30:22 <quicksilver> @go ghc scoped type variables
06:30:24 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
06:30:25 <lambdabot> Title: 8.7.�Other type system extensions
06:30:55 <conal> quicksilver: definitely.  network-based FRP events.
06:31:23 <ivanm> thanks quicksilver
06:31:40 <purestorm> Hm, is there already a function like http://hpaste.org/10105? Does it even make sense? I want to apply the function if the argument is not Nothing...
06:31:48 <ivanm> is there a reason that that has to be an extension? (because when they wrote the report they didn't think about such scenarios?)
06:31:51 <cjs> Basically, I might call openFoo and get back a { handle, readFunc, writeFunc } combination. Or openBar and get back the same thing (or so it appears to me). readFoo and writeFoo want me to keep their state, i.e., the handle, and give it back to them when I call them, and store it for them in between. Or something like that.
06:32:20 <Saizan_> lilac: i don't think so since 'left' doesn't give you anything that can flatten  () ~> (a ~> b) to (a ~> b)
06:32:27 <ivanm> just checking: is the reason dons explicitly writes the type signature for "go" here is to ensure that Int and not Integer gets used? http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16#fast
06:32:29 <lambdabot> Title: Haskell hacking
06:32:34 <EvilTerran> purestorm, that's fmap
06:32:36 <cjs> I guess the more traditional FP way to do this would be to have a function that you call, and it returns a new version of itself along with the return value, and you call that the next time, and so on. Then it can use a closure (an ever-growing one, unfortunately) to keep the state it needs.
06:32:37 <EvilTerran> ?src Maybe fmap
06:32:38 <lambdabot> fmap _ Nothing       = Nothing
06:32:38 <lambdabot> fmap f (Just a)      = Just (f a)
06:32:48 <purestorm> ah, nice
06:32:54 <quicksilver> cjs: that sounds exactly like an existential to me.
06:33:02 <EvilTerran> fmap is a lot of useful things :)
06:33:15 <cjs> Hm. How does the existential get back the stuff in the opaque object?
06:33:28 <quicksilver> exists a . { handle :: a, readFunc :: a -> IO String; writeFunc :: String -> IO () }
06:33:41 <quicksilver> cjs: you pass it to itself.
06:33:44 <quicksilver> readFunc handle
06:33:48 <purestorm> thx
06:33:52 <quicksilver> GHC knows they must be a matching type 'a'
06:33:57 <quicksilver> even though ti doesn't know what type that is.
06:33:57 <thoughtpolice> ivanm: yeah, if you do 'let x = 1' it'll be Integer by default, so you want Int + Strictness to = unboxed register values
06:33:57 <EvilTerran> ?type fmap
06:34:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:34:03 <Saizan_> lilac: i'd be very interested if you can write it though :)
06:34:06 <cjs> In other words, a handle is () to readFoo, but a Dictionary Whatever to readBar.
06:34:10 <ivanm> thoughtpolice: *nod*
06:34:17 <cjs> Oh, really.
06:34:32 <cjs> Hm. Ok, I'd better go play with this a bit.
06:34:36 <EvilTerran> purestorm, in that type, f can also be [], giving you map, or (Either e), giving you a function that leaves Lefts unchanged but modifies Rights
06:34:50 <cjs> So it won't let me pass a readFoo's handle to a readBar, then?
06:34:52 <EvilTerran> purestorm, or f can be any monad, giving you liftM
06:35:04 <quicksilver> cjs: no, it wouldn't.
06:35:08 <ivanm> what's the syntax for putting LANGUAGE pragmas at the top of files? can I have more than one in a {-# #-} block?
06:35:11 <EvilTerran> purestorm, it all comes down to the types, really :)
06:35:14 <quicksilver> cjs: the types would statically not match.
06:35:18 <cjs> Wow.
06:35:21 <purestorm> EvilTerran: hehe
06:35:23 <EvilTerran> ivanm, {-# LANGUAGE ThisExtension, ThatExtension #-}
06:35:23 <quicksilver> ivanm: separated by commas, afaik.
06:35:25 <purestorm> thanks
06:35:28 <cjs> Haskell's type system just kinda blows my brain sometimes.
06:35:29 <EvilTerran> :)
06:35:34 <ivanm> aaahhhhhh, commas!
06:35:38 <ivanm> that's what I forgot ;-)
06:35:44 <cjs> But I think I see how this is working.
06:36:25 <EvilTerran> > fmap f (Just x)
06:36:28 <lambdabot>   Add a type signature
06:36:31 <EvilTerran> > fmap f (Just x) :: Expr
06:36:34 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Maybe b'
06:36:35 <EvilTerran> ... no, wait
06:36:55 <quicksilver> cjs: existential types are such an obvious and natural extension
06:36:56 <EvilTerran> > fmap f (Just x) :: Maybe Expr -- i wish the SimpleReflect types could default more elegantly
06:36:59 <lambdabot>   Just (f x)
06:37:03 <quicksilver> I suppose there are good reasons they weren't in h98
06:37:10 <quicksilver> but I find them very handy, occasionally.
06:37:11 <ivanm> hmmm... I'm now getting parse error on #-} :s
06:37:12 <EvilTerran> > fmap f [x,y,z] :: [Expr]
06:37:16 <lambdabot>   [f x,f y,f z]
06:37:25 <ivanm> {-# LANGUAGE ExistentialQuantification, ScopedTypeVariables #-} <-- isn't this right?
06:37:29 <EvilTerran> > fmap f (Left x) :: [Expr]
06:37:31 <lambdabot>   Couldn't match expected type `[a]'
06:37:46 <EvilTerran> ah, sod it. too much fankling with explicit types. you get the idea.
06:37:49 <Baughn> Since hpaste is down.. http://hpaste.org/10106 <-- Anyone feel like scanning this code for obvious improvements? (To clarity/brevity, not performance)
06:38:07 <purestorm> Is there something like C++ bind2nd in Haskell or should I rather use (\x -> f x myvalue)?
06:38:21 <ivanm> purestorm: flip f myvalue
06:38:22 <lilac> Saizan_: i think that it would be deeply strict in the RNF sense, and would only work on types with a finite number of inhabitants anyway (since otherwise the resulting chain of arrows would be non-terminating). so it's probably not very useful :)
06:38:29 <purestorm> ivanm: sweet
06:38:42 <EvilTerran> > (`f` x) y :: Expr
06:38:46 <lambdabot>   f y x
06:39:03 <EvilTerran> purestorm, you can use a right-section of the function, too :)
06:39:08 <lilac> > let bind2nd = flip in map (bind2nd (/) 3) [1..10]
06:39:11 <lambdabot>   [0.3333333333333333,0.6666666666666666,1.0,1.3333333333333333,1.66666666666...
06:39:40 <EvilTerran> purestorm, as (`f` x) = (flip f x). the report says that exactly, iirc.
06:40:05 <EvilTerran> > map (/3) [1..]
06:40:10 <lambdabot>   [0.3333333333333333,0.6666666666666666,1.0,1.3333333333333333,1.66666666666...
06:40:42 <opqdonut> > iterate (/3) [1..]
06:40:42 <opqdonut> :)
06:40:44 <lambdabot>       No instance for (Fractional [t])
06:40:44 <lambdabot>        arising from a use of `/' at <i...
06:40:47 <opqdonut> no, wait
06:40:49 <opqdonut> > iterate (/3) 1
06:40:52 <lambdabot>   [1.0,0.3333333333333333,0.1111111111111111,3.7037037037037035e-2,1.23456790...
06:41:00 <lilac> to be honest, renaming 'flip' to 'bind2nd' makes it much easier for me to think about :)
06:41:23 <mattam> > (/3) 3
06:41:27 <lambdabot>   1.0
06:41:33 <ivanm> OK, how do I enable -XScopedTypeVariables in the file itself? I can't seem to get it working :s
06:42:04 <cjs> {-# OPTION -XScopedTypeVariables #-} is maybe what you're looking for?
06:42:27 <ivanm> duh, I had it working, the parse error was elsewhere :s
06:42:31 * ivanm can't read error messages :s
06:42:35 <EvilTerran> {-# LANGUAGE ScopedTypeVariables #-}
06:42:58 <ivanm> dammit, even with that extention I get type errors (matching expected to inferred type) :s
06:43:14 <cjs> EvilTerran: oh, that's better. Thanks.
06:43:30 <bringert> kosmikus: this is probably an FAQ, but is there a way (a hack I suppose) to render ->  as a dot in lambda expressions (but not in types)?
06:43:35 <EvilTerran> ivanm, i think you need to use explicit forall.s to introduce a scoped type variable?
06:43:56 <bringert> kosmikus: and I don't really care what -> in case expressions becomes
06:44:00 <EvilTerran> ivanm, see http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
06:44:02 <lambdabot> Title: 8.7.�Other type system extensions, http://tinyurl.com/3c7ura
06:44:21 <ivanm> yeah, I'm looking through it
06:44:40 <EvilTerran> "A declaration type signature that has explicit quantification (using forall) brings into scope the explicitly-quantified type variables, in the definition of the named function."
06:44:46 <bringert> kosmikus: heh, I guess I can just invent a new symbol to use in lambda expressions, then have it be "->" in newcode style, and "." otherwise
06:45:39 <ivanm> EvilTerran: *nod* ... how do I do forall for two types? forall a b . <signature> ?
06:45:45 <EvilTerran> yep
06:45:57 <ivanm> \o/ it's working now!
06:45:58 <ivanm> thanks EvilTerran
06:46:46 * ivanm finally finished writing an extremely polymorphic version of dons' optimized lazy-list mean function \o/
06:47:21 <purestorm> So, say I have a constructor "C Integer" and a associative list [(String, C)]. How do I get "Just anInt" or "Nothing" from lookup? Just (C x) = lookup "key" list does not work, apparently.
06:47:27 <quicksilver> "Extreme Polymorphism : For when Extreme Ironing no longer gets your blood rushing"
06:48:00 <quicksilver> purestorm: that works, but crashed when you get nothing.
06:48:19 <quicksilver> purestorm: case lookup "key" list of Just (C x) -> Just x; Nothing -> Nothing
06:48:24 <quicksilver> purestorm: is a systematic way.
06:48:40 <BeelsebobWork> so conal, you don't like this? mapMWithKey ∷ Monad m ⇒ (κ → α → m β) → Map.Map κ α → m (Map.Map κ β)
06:48:49 <quicksilver> purestorm: alternatively, fmap (\(C x) -> x) (lookup "key" list)
06:49:49 <kosmikus> bringert: your last suggestion is certainly the easiest possibility
06:50:06 <kosmikus> bringert: it's probably possible to achieve something similar with TeX hackery
06:50:23 <conal> BeelsebobWork: sadly i haven't found the magic emacs font.  still missing "::"
06:50:52 <kosmikus> bringert: forall.fmt contains code that allows . after forall to be formatted as . rather than a circle. one can set up similar functionality that typesets the first arrow after a lambda as a dot.
06:51:08 <purestorm> quicksilver: Is the (\(C x) -> x) somehow already defined in Haskell somewhere?
06:51:13 <bringert> kosmikus: thanks
06:51:24 <bringert> kosmikus: I'm relying to lhs2TeX to get working haskell anyway, since I have introduced new binding operators, so I might as well do the same for ->
06:51:34 <kosmikus> bringert: ok
06:51:41 <bringert> kosmikus: the only problem being that the source becomes more unreadable
06:51:55 <quicksilver> purestorm: only if you defined it in the type.
06:52:15 <quicksilver> purestorm: a relatively common idiom is "newtype C = C { unC :: Integer }"
06:52:27 <quicksilver> purestorm: then \(C x) -> x is simply 'unC'
06:52:40 <purestorm> Ah, awesome
06:53:07 <quicksilver> or of course, instead of record selector hackery you can just do
06:53:10 <kosmikus> bringert: the TeX stuff shouldn't be too difficult either
06:53:11 <quicksilver> unC (C x) = x
06:53:32 <bringert> kosmikus: yeah, looking at forall.fmt now, should be just copy and paste, with alpha-conversion
06:55:16 <bringert> kosmikus: a nice thing would be to match sequences of tokens on the left hand side of %format
06:55:52 <bringert> kosmikus: e.g. %format "\" x "->" e = "\lambda" x "." e
06:56:14 <bringert> could have non-trivial semantics though
06:56:14 <purestorm> quicksilver: Thanks a ton.
06:59:31 <cjs> Ok, quicksilver, now you're in trouble.
06:59:31 <BeelsebobWork> anyone know if there's a good UTF symbol for >>=?
06:59:38 <cjs> You broke my ghc!
06:59:43 <BeelsebobWork> I've found ≫
06:59:47 <cjs> It just told me its brain exploded!
07:01:18 <quicksilver> cjs: you can't open up an existential with 'let'
07:01:21 <quicksilver> cjs: you have to use 'case'
07:01:38 <kosmikus> bringert: difficult to do due to the way the parser of lhs2TeX works
07:02:10 <cjs> Actually, the let was a relatively minor complaint. It just told me to use pattern matching instead.
07:02:26 <cjs> It was when I used pattern matching that I got the, "My brain just exploded." message.
07:02:34 <mm_freak_> @src IO
07:02:34 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
07:02:43 <cjs> This is probably some sick joke that ghc likes to play on poor programmers. :-)
07:02:46 <kosmikus> bringert: does www.cs.uu.nl/people/andres/lambda.fmt work for you?
07:02:59 <mm_freak_> what's (# #) ?
07:03:18 <bringert> kosmikus: heh, you beat me to it, testing...
07:04:03 <lilac> mm_freak_: strict tuple
07:04:08 <lilac> s/strict/unboxed/g
07:04:18 <mm_freak_> ah, thanks
07:04:30 <bringert> kosmikus: looks good, thanks!
07:05:01 <bringert> kosmikus: I think there should be more space after the dot
07:07:11 <kosmikus> bringert: updated
07:07:38 <BeelsebobWork> :t first
07:07:40 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:08:02 <bringert> kosmikus: nice!
07:08:45 <bringert> kosmikus: it's getting to the point where I can just avoid writing maths in latex altogether, and just write (almost) haskell
07:08:53 * kosmikus has recently spent a few hours to add an --agda flag to lhs2TeX
07:09:09 <bringert> which is translatable to real haskell, type checked and run
07:09:11 <kosmikus> one nice side effect is that you can use unicode with lhs2TeX easily
07:09:15 * EvilTerran has got into the habit of writing his pseudocode and pre/postconditions for imperative code in haskell
07:09:30 <bringert> good bye to typos in math stuff
07:09:46 <kosmikus> yes, exactly
07:09:54 <kosmikus> I try to typecheck as much as possible
07:10:10 <kosmikus> with \inlinehs you can also typecheck math/code that's in the middle of a paragraph
07:10:33 <kosmikus> but much of this could be made easier
07:10:41 <kosmikus> I have a few ideas, but too little time
07:10:45 <kosmikus> I need interested students :)
07:10:50 <bringert> I'm writing about natural language semantics, and I won't even say that the formulas I show are actual code until the end
07:11:07 <EvilTerran> bringert, awesome, teach people haskell by stealth :D
07:11:34 * Twey laughs.
07:11:39 <EvilTerran> i like that as a way of teaching haskell to people who've never seen FP (or even programming) before, actually
07:11:42 <EvilTerran> present it as maths, not programming
07:12:29 <Wild_Cat> FP looks a *lot* like maths. That's what first struck me when I was taught Haskell.
07:13:12 <EvilTerran> if you say "programming", people start thinking about variables and loops and mutation and whatnot
07:13:13 <dmhouse> > [ (x,y,z) | x <- [1..100], y <- [x..100], z <- [y..100], x^2 + y^2 == z^2 ]
07:13:18 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(7,24,25),(8,15,17),(9,12,15),(9,40,41),(10,24,...
07:13:31 <dmhouse> That's what first drew me into Haskell, I remember. "Wow, it's just like set builder notation!"
07:13:49 <EvilTerran> > [(x,y,z) | z <- [1..], y <- [1..z], x <- [1..y], x^2 + y^2 == z^2]
07:13:59 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24...
07:17:00 <Axman6> EvilTerran: any benefits to using the way you wrote it?
07:17:11 <BeelsebobWork> Axman6: it's an infinite list of them
07:17:14 <BeelsebobWork> and it's more efficient
07:17:20 <Axman6> righto
07:17:51 <quicksilver> Axman6: the list-monad doesn't work with more than one infinite list.
07:18:02 <quicksilver> but it works with just one, if you make it the 'first' one.
07:18:07 <Taejo> in quickcheck, is there a function to create n random values of an Arbitrary instance?
07:18:09 <Ayu08> @seen quicksilver
07:18:09 <lambdabot> quicksilver is in #haskell-soc, #haskell and #ghc. I last heard quicksilver speak 7s ago.
07:18:10 <Axman6> ah, ok
07:18:13 <Ayu08> @seen cale
07:18:13 <quicksilver> and there is no point trying y>z anyway.
07:18:13 <lambdabot> cale is in #haskell, #haskell-overflow and #ghc. I last heard cale speak 1h 34m 51s ago.
07:18:28 <quicksilver> the omega monad works with multiple infinite lists
07:18:37 <quicksilver> at the cost of a 'funny' order.
07:18:51 <Axman6> quicksilver: i'm still waiting for you to finish your explanation of monads :P
07:18:53 <Ayu08> quicksilver, is that a clothing brand name? heard somewhere
07:19:11 <Ayu08> quicksilver: sounds familiar
07:19:56 <Ayu08> > 1+1
07:20:00 <lambdabot>   2
07:20:02 <EvilTerran> Axman6, also, mine won't have duplicates with the same triple, only with x>y and y<x
07:20:07 <Ayu08> >1+1
07:20:25 <quicksilver> it's a clothing brand name without a 'c' yes.
07:20:39 <quicksilver> Axman6: I did finish it :) that was all.
07:20:44 <EvilTerran> Ayu08, quicksilver is an archaic name for mercury
07:21:01 <Ayu08> EvilTerran: hi mr terran, what is arachaic
07:21:16 <EvilTerran> old
07:21:16 <Ayu08> EvilTerran: sounds like you are from starcraft or something
07:21:24 <scook0> it means "old, and generally not used anymore"
07:21:31 <EvilTerran> plenty of scifi had terrans, long before starcraft
07:21:35 <Ayu08> Evilterran: i heard that they could use mercury to make gold or something
07:21:48 <Wild_Cat> no, that's lead.
07:21:55 <Axman6> Ayu08: used in the processing of gold i believe
07:21:56 <Ayu08> EvilTerran: alchemy or something
07:22:08 <Axman6> and no, alchemy doesn't work
07:22:08 <EvilTerran> actually, it's platinum that actually works, but that costs more, so it's a bit pointless
07:22:19 <EvilTerran> and the process of knocking a proton off it to make gold is also very expensive
07:22:33 <Ayu08> EvilTerran: are you a haskell + science teacher?
07:23:00 <EvilTerran> nah, i'm just a lowly computer science undergrad :)
07:23:03 <Axman6> Ayu08: this stuff is pretty basic chemistry ;)
07:23:29 <Ayu08> hmm ok
07:23:31 <Wild_Cat> Axman6: depends. I find that small amounts of lead in the correct shape and mixed with certain other chemicals can easily be converted into gold or most other forms of currency. The process is called a submachine gun.
07:23:36 <Ayu08> just wandering
07:24:03 <Ayu08> when i type 1:2:[] it becomes [1,2]
07:24:11 <Botje> yes
07:24:18 <Botje> that's because the latter is syntactic sugar for the former
07:24:32 <Ayu08> wow you do remember about syntatic sugar
07:24:54 <Botje> syntactic sugar makes programming more fun!
07:25:07 <lilac> Wild_Cat: i find the same items can be converted to fifteen-to-life, by the same process. this suggests the process is not pure.
07:25:11 <RayNbow> syntactic sugar is bad for your teeth :p
07:25:29 <Ayu08> ok back to tpic
07:25:30 <Botje> RayNbow: only if you eat your code :D
07:25:31 <Ayu08> topic*
07:25:32 <lilac> robBank :: bullets -> gun -> IO (Either JailTime Money)
07:25:45 <Ayu08> so how do i make my winhugs to keep on storing those data
07:25:56 <Botje> you can't. put it in a file or use ghc
07:25:59 <Ayu08> so like once i have [1,2] then i want to store extra stuff, like 3 and 4
07:26:10 <RayNbow> Botje: and instead, we usually feed the code to the compiler who then has to cope with the insane amount of sugar :p
07:26:14 <Wild_Cat> lilac: yeah. It's not lazy, either. People can die even before they're examined.
07:26:15 <RayNbow> poor GHC...
07:26:17 <slarba> question: I have a function p :: Foo a, p = ... runSTArray perform. perform is :: ST s (STArray s Int a) which creates an array, modifies and returns it. Now compiler expects type STArray s Int a1, not STArray s Int a which it infers
07:26:19 <Ayu08> in c programing, there is some kind of temp variable for it, or use array
07:26:33 <slarba> what's wrong?
07:26:35 <lilac> Wild_Cat: i don't know... i wouldn't rob a bank unless i'm forced to
07:26:46 <slarba> as soon as I fix a to a spesific type, it compiles
07:26:52 <Ayu08> Botje: store in a file?
07:26:59 <Botje> Ayu08: sorry, i'm missing context
07:27:06 <Botje> i assumed you were talking about storing definitions
07:27:10 <Ayu08> Botje: what are you missing?
07:27:23 <RayNbow> Botje: Ayu08 wants to append values to the list I think
07:27:39 <camio> Anyone know of something like: iterateMaybe :: (a -> Maybe a) -> a -> [a]  ?
07:27:45 <Botje> you can't do that in haskell
07:27:47 <Botje> camio: unfoldr?
07:27:54 <Ayu08> RayNbow botje: what is append
07:28:06 <Botje> > [1,2] ++ [3,4]
07:28:11 <lambdabot>   [1,2,3,4]
07:28:20 <Ayu08> botje: so append is plus?
07:28:23 <Botje> but you can't alter the original list
07:28:36 <Ayu08> Botje: why i can't alter them?
07:28:36 <Botje> Ayu08: uh, in this case, sure
07:28:42 <camio> Botje: Thanks. I suspected there'd be something like that.
07:29:17 <thoughtpolice> slarba: it might have to do with the fact that ST has a rank-2 type?
07:29:27 <thoughtpolice> slarba: can you hpaste it?
07:29:31 <Ayu08> Botje: ???
07:29:50 <lilac> @type unfoldr . (fmap (join (,)) .)
07:29:52 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
07:30:08 <lilac> ^^ camio
07:30:09 <Ayu08> @seen botje
07:30:09 <lambdabot> botje is in #haskell.dut and #haskell. I last heard botje speak 1m 32s ago.
07:30:18 <camio> lilac: Thanks
07:31:04 <purestorm> Hi. Uhm, say... I have defined some data types and want to parse them from JSON. Say, I take some existing JSON parser so I need to convert between the given JSON data type tree and my own data types. Some questions 1) the right way to mark entries in my data types is Maybe T, right? 2) What is the right way to do error handling? If an entry for my data types is missing, should my conversion function use Maybe and return Nothi
07:31:11 <Ayu08> hey guys, i just wandering, does haskell have exception handling?
07:31:22 <Ayu08> "exception handling": like c programming
07:31:36 <Axman6> Ayu08: you don't reallt get exceptions in haskell
07:31:39 <Axman6> y*
07:31:49 <Ayu08> axman6: reallty ?
07:31:50 <opqdonut> in pure code, people usually use the Error monads
07:31:58 <opqdonut> in IO code there are exceptions
07:32:05 <opqdonut> that work kind of like the ones in imperative languages
07:32:08 <Axman6> and stop thinking of Haskell in terms of C ;)
07:32:27 <Axman6> :t error
07:32:29 <lambdabot> forall a. [Char] -> a
07:32:35 <quicksilver> error-monads give a very similar user experience to exception handling.
07:32:53 <quicksilver> seen from an appropriate distance, with a squint they "are" exception handling.
07:33:00 <quicksilver> the key point is not to have to check failure after every operation
07:33:06 <quicksilver> but have failures "automatically cascade"
07:33:12 <quicksilver> up to the place which is prepared to handle them.
07:33:25 <Ayu08> o_o what is an error monads
07:33:28 <binrapt> Which Haskell interpreters use JIT optimisation by default?
07:33:34 <Ayu08> slow down guys ^_^ " too fast for newbies
07:33:58 <Axman6> Ayu08: how are you learning haskell?
07:34:24 <Ayu08> using the yaht pdf
07:34:32 <Ayu08> studying by myself is hard abit haha
07:34:41 <thoughtpolice> binrapt: none
07:34:43 <thoughtpolice> (afaik)
07:34:48 <Ayu08> do you guys go to haskell or something?
07:34:54 <Ayu08> haskell school*
07:35:03 <thoughtpolice> no, you stick around on #haskell :)
07:35:06 <quicksilver> binrapt: I'm pretty sure neither of the common ones (hugs/ghci) do anything JIT.
07:35:08 <lilac> Ayu08: haskell has exceptions which can be caught as an IO action, but they're not used much for error handling
07:35:10 <Axman6> you're making it harder for yourself if you try and relate it to C, imo
07:35:13 <Botje> #haskell is the haskell school
07:35:14 <binrapt> Ok :<
07:35:22 <Botje> all the cool kids hang around the lambda playground :)
07:35:25 <quicksilver> binrapt: I woudln't be entirely surprised to hear that the obsolete but rather clever hbc did.
07:35:39 <Ayu08> Botje: lambdabot sounds like a robot lamb
07:35:47 <RayNbow> @bot
07:35:47 <lambdabot> :)
07:35:56 <binrapt> I was considering using Haskell for webdev hahaha
07:36:21 <Botje> binrapt: i assume you've looked at HappS, then? :)
07:36:22 <binrapt> But the box it runs is terrible and should run high performance stuff hmm
07:36:26 <Ayu08> hmm
07:36:30 <binrapt> Isn't that a server?
07:36:37 <binrapt> This runs on Appache
07:36:41 <binrapt> Via cgi hackage
07:36:46 <slarba> thoughtpolice: I already found a solution... kind of. The trick was to rewrite the type signature of p as p :: forall a. <copypaste right side of '=' from type Foo a = ... >
07:36:50 <Axman6> binrapt: go with lighttpd
07:36:55 <binrapt> No root
07:37:21 <slarba> thoughtpolice: funny since saying "type Foo a = forall a. ..." does not produce the desired resut :)
07:37:42 <thoughtpolice> slarba: heh
07:38:00 <Ayu08> anyone here touch on prolog?
07:38:12 <slarba> thoughtpolice: like typechecker is not looking "inside" the type alias
07:38:36 <slarba> thoughtpolice: is it possible to say something like "type forall a. Foo a = ..." ?
07:39:44 <Saizan_> slarba: what if you just omit the forall?
07:39:50 <thoughtpolice> slarba: don't think so
07:39:54 <lilac> slarba: can you hpaste?
07:42:35 <binrapt> Axman6: tried to compile lighthttpd but it doesn't even work lol
07:42:36 <binrapt> configure: error: pcre-config not found, install the pcre-devel package and build with --without-pcre
07:43:00 <Axman6> try installing pcre-devel...
07:43:05 <binrapt> No root
07:43:12 <binrapt> Would require lots of hackage eh?
07:43:19 <Ayu08> anyone here touch on prolog before?
07:43:21 <Axman6> not necessarillt
07:43:23 <Axman6> y*
07:43:29 <Ayu08> axman6?
07:44:16 <slarba> Saizan_: no, does not compile
07:44:24 <slarba> ok I'll hpaste
07:44:29 <Ayu08> does this exist? type height = Sides , so ... data Shape = Rectangle Sides
07:45:06 <Ayu08> does this exist? type Sides = Float , so ... data Shape = Rectangle Sides Sides
07:45:41 <Axman6> yes
07:45:57 <Ayu08> axman6: which 1 are you referring to? prolog or type?
07:47:19 <Axman6> the type
07:48:27 <slarba> here http://hpaste.org/10107
07:48:52 <Ayu08> hmm
07:49:21 <Ayu08> Q:: a-> a -> b -> b -> Quad a b (is it same as) data Quad a b = Q a a b b
07:49:31 <quicksilver> slarba: yes. that is the behaviour of scopedtypeinstances
07:49:36 <Ayu08> why they switch position?
07:49:37 <quicksilver> slarba: (it has nothing to do with ST, by the way)
07:49:54 <slarba> quicksilver: yes the title was a bit misleading :)
07:50:09 <quicksilver> slarba: the 'a' in the type sig of perform is a totally different 'a' to the 'a' in the type sig of p
07:50:22 <quicksilver> slarba: all type variables in separate signatures are free, and distinct.
07:50:37 <slarba> quicksilver: yeah, but how to "bind" them
07:50:40 <quicksilver> slarba: if you want them to be the same you (a) turn on scopedtypeinstances, which you have obviously done
07:50:44 <quicksilver> and (b) use an explicit 'forall'
07:50:52 <quicksilver> which marks a binding scope for type variables.
07:50:54 <slarba> okay
07:51:01 <quicksilver> p :: forall a . Foo a
07:51:03 <quicksilver> would work too
07:51:13 <quicksilver> (the Foo a vs [a] -> [a] part is a red herring)
07:51:21 <lilac> @type iterate
07:51:23 <lambdabot> forall a. (a -> a) -> a -> [a]
07:51:46 * binrapt wonders what's more efficient, running Haskell code via hugs via cgi on the Apache server or running PHP scripts using the PHP mod it comes with
07:52:38 <Ayu08> o_o anyone here?
07:52:43 <Ayu08> need some help
07:53:10 <dmhouse> binrapt: I suspect PHP
07:53:11 <lilac> Ayu08: what's up?
07:53:26 <dmhouse> binrapt: seeing as it's much more domain-specific
07:53:28 <RayNbow> > foldr f z [1,2,3,4]
07:53:32 <lambdabot>   f 1 (f 2 (f 3 (f 4 z)))
07:53:35 <Ayu08> lilac: i want to ask about this : data Quad a b = Q a a b b, the constructor is Q a a b b?
07:53:57 <binrapt> dmhouse isn't running the process over and over again heavy too? As opposed to mod_php being in memory all the time
07:53:58 <lilac> Ayu08: there, Quad is a type constructor and Q is a data constructor
07:54:02 <binrapt> Ready to execute
07:54:16 <Twey> lilac: The function Q makes a Quad.
07:54:19 <dmhouse> binrapt: yes, that too. There are many reasons :)
07:54:20 <Twey> Er, Ayu08 ^
07:55:05 <Ayu08> Twey: hi TWEY
07:55:24 <lilac> Ayu08: Quad is a type function which takes two types and produces a type. Q is a (normal, value-level) function which takes four values and returns a Quad a b, for appropriate a and b
07:55:26 <Ayu08> wait, trying to write down what you guys say
07:55:44 <lilac> Ayu08: so there's a function Q :: a -> a -> b -> b -> Quad a b
07:56:13 <Twey> Hello, Ayu08 :)
07:56:14 <slarba> quicksilver: thanks :) every day something to learn :)
07:56:16 * lilac wonders if GADTs are easier to teach :)
07:56:56 <quicksilver> lilac: only if the learner already understands type signatures properly.
07:57:07 <quicksilver> lilac: and personally I prefer to teach 'data' before / at the same time as functions.
07:57:43 <Ayu08> oh ok
07:58:09 <Ayu08> im still confused with the terms data constructor and type constructor
07:59:06 <Ayu08> so do you mean Quad a b produces Q a a b b?
07:59:13 <Axman6> Q 1 2 'a' 'v' would have the type Quad Int Char
08:00:01 <Twey> Ayu08: 'Type constructor' is a function that constructs a type.
08:00:21 <Twey> 'Data constructor' is a function that constructs a datum.
08:01:12 <lilac> Ayu08: some care is required. there are two separate, but similar, languages in haskell; a language of types and a language of values
08:01:14 <Ayu08> twey: datum? o_o
08:01:26 <lilac> Ayu08: datum is singular of data
08:01:44 <Ayu08> lilac: comparison between singular data vs plural data?
08:01:51 <Ayu08> lilac: example of singular data
08:01:58 <Twey> 'Data' isn't singular
08:01:59 <lilac> yes, that's it. one datum, many data.
08:02:06 <Twey> You can't have 'a data'
08:02:19 <lilac> but it's like dice; data is accepted as singular by many people these days
08:02:20 <Twey> Only 'some data' (plural) or just 'data' (uncountable)
08:02:22 <RayNbow> oh great... a Latin related discussion? :)
08:02:29 <Twey> lilac: I've never heard someone say 'a data'
08:02:34 <Twey> Or 'one data'
08:02:37 <Twey> And it sounds wrong
08:02:48 <lilac> Twey: "this data is ..."
08:02:55 <Twey> Uncountable
08:03:04 <lilac> that'd be "these data are...", no?
08:03:08 <Twey> Like 'this water is' or 'this sand is'
08:03:17 <lilac> fair point :)
08:03:31 <lilac> i stand corrected. back to haskell now? ;-)
08:03:36 <Twey> Haha, aye
08:04:04 <eu-prleu-peupeu> hi
08:04:06 <Ayu08> o_o...
08:05:31 <Ayu08> so data is singular, datum is plural (in other words, many data) ?
08:05:38 <Twey> No
08:05:41 <Twey> Other way around
08:06:00 <Ayu08> so data is plural, datum is singular?
08:06:08 <Twey> Plural or uncountable, aye
08:06:13 <Ayu08> what is aye
08:06:18 <Twey> I think lilac takes exception to having this discussion here
08:06:23 <Twey> ##English if you're still confused :)
08:06:31 <Ayu08> what does aye means
08:06:38 <Twey> 'Yes'
08:06:41 <binrapt> lol
08:06:47 <Ayu08> oh , isnt it easier to say yes
08:06:53 <binrapt> Aye
08:06:56 <Ayu08> lol
08:07:08 <Ayu08> what's with the water and sand
08:07:20 <Ayu08> i heard you guys mentioning about it, but i do not know what is happening
08:07:31 <Axman6> Ayu08: may i ask how old you are?
08:07:55 <RayNbow> .my... Malaysia?
08:08:33 <Ayu08> o_o?
08:08:39 <Axman6> yeah that confused me too
08:08:47 <Axman6> never seen .my before
08:09:05 <lilac> Ayu08: so... Quad is a function in the language of types; it takes two types and produces a type.
08:09:06 <RayNbow> Ayu08 is n=Ayu11@28.69.50.60.brf01-home.tm.net.my * Ayu12 <-- it's your address :p
08:09:16 <RayNbow> (/whois Ayu08)
08:09:24 <Ayu08> you don't need to post it here  -_-"
08:09:58 <lilac> Ayu08: the type produced by "Quad a b" is inhabited by values of the form "Q c d e f", where c :: a, d :: a, e :: b, f :: b
08:10:30 <Axman6> lilac: wayta make it really confusing there :P
08:10:41 <Twey> Mmmm
08:10:52 <lilac> Axman6: yeah, maybe i'm not helping :(
08:11:14 <Axman6> Ayu08: do you get what i mean if i say Q "hello" "world" True False is of the type Quad String Bool?
08:11:33 <Ayu08> yup
08:11:40 <FunctorSalad> any category-extras adepts here? :)
08:12:08 <FunctorSalad> not sure I get the definition of Control.Category... so the objects are still all haskell types, but the morphisms can be different?
08:12:35 <Saizan_> FunctorSalad: yup
08:13:00 <FunctorSalad> so do you throw an exception if a type doesn't make sense for your category?
08:13:13 <Axman6> so what data Quad a b is saying is that the type has parts Q a a b b, where the a's have to be the same kind of data, and the b's have to be the same kind of data (and the a's and b's could be the same type also)
08:13:42 <alexey_r> Hi! Can any Haskell compilers be installed on a USB drive?
08:13:45 <Axman6> Q "hello" "world" 1 2 creates a piece of data, with the type Quad String Int
08:13:59 <Saizan_> FunctorSalad: uhm, that looks like restricted monads, not sure if there's also a restricted category class
08:14:03 <Axman6> Ayu08: so, got that?
08:14:07 <Ayu08> got that
08:14:11 <Axman6> good
08:14:51 <Axman6> so, could you tell me what the type of [1,3,2,5] would be?
08:15:06 <Ayu08> hmm
08:15:47 <Axman6> give it a go
08:15:54 <Axman6> doesn't have to be right
08:16:41 <_zenon_> Tip: It's a list of something
08:17:23 * Axman6 should sleep soon
08:18:05 <_zenon_> Ayu08, if it's too hard, you can test the types of things with ghci
08:18:12 <Ayu08> Int?
08:18:21 <_zenon_> (in ghci)        :i [1]
08:18:22 <malcolmw> alexey_r: I would have thought any of them, provided you have a big enough USB drive
08:18:34 <Ayu08> how do i test it out on my winhugs?
08:18:41 <Axman6> Ayu08: not quite. it would be [Int]
08:18:47 <_zenon_> I meant :t <--- not :i
08:18:49 <Axman6> since it's a list of Ints
08:19:08 <Ayu08> not [Int,Int,Int,Int] ?
08:19:25 <Axman6> no
08:19:31 <Ayu08> ok
08:19:33 <_zenon_> Well strictly speaking, it could be a list of Integers as well (Integers having more capacity)
08:19:42 <Axman6> since, lists can only contain elements of the same type
08:19:59 <Axman6> > [1,"a", True]
08:20:02 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Bool'
08:20:36 <Axman6> that error might not mean much to you, but it's saying that you can't use multiple types in a list
08:21:09 <Axman6> _zenon_: yeah, but he's used to C, so ya know, infinity is still an unknown :P
08:21:21 <cjs> Existential types!
08:21:27 <Axman6> IEEE float infinity doesn't count
08:21:36 <Twey> Haha
08:21:42 <_zenon_> Axman6, yeah, I know it was kind of pickish to say it, but still felt it had to be said
08:21:42 <cjs> Speaking of which, anybody got a clue for me on this error message? http://hpaste.org/10108
08:22:06 <quicksilver> cjs: Yes. You let something existential escape.
08:22:13 <quicksilver> You can't do that because it won't always be the same thing.
08:22:23 <quicksilver> existential cat has to stay in its box
08:22:41 <cjs> I can't just stand outside the box with a club and club it if it tries?
08:22:54 <cjs> Anyway, hmmm...how did it escape here?
08:23:26 <quicksilver> without seeing your code it's going to be hard to say :P
08:23:39 <cjs> It's up on the hpaste. :-)
08:24:00 <cjs> Oh, well a bunch is in the error message, and the declarations I appended.
08:24:07 <quicksilver> no it's not.
08:24:14 <Ayu08> >1*2
08:24:20 <quicksilver> ah , yes.
08:24:29 <quicksilver> well the st in IO (st,FeedMessage) is escaping.
08:24:48 <Axman6> Ayu08: needs a space after the >
08:24:53 <RayNbow> <quicksilver> existential cat has to stay in its box <-- is there a lambdacat for this? :p
08:24:57 <quicksilver> you want to package that back up in a FeedConnection.
08:25:02 <cjs> Ooops...it was supposed to be a FeedConnection.
08:25:04 <Ayu08> Axman: ok thanks
08:25:07 <Ayu08> > 1*2
08:25:11 <lambdabot>   2
08:25:28 <quicksilver> cjs: package it back up, inside the case.
08:25:48 <quicksilver> do (st',msg) <- feedConRead cst state;
08:25:57 <quicksilver>    return (FeedConnection st',msg)
08:26:08 <cjs> How about just changing the type of feedConRead to return IO (FeedConnection, FeedMessage)?
08:26:25 <quicksilver> that allows it to change mid stream to a different kind of connection.
08:26:31 <cjs> Hm!
08:26:33 <quicksilver> sounds like surprising behaviour.
08:26:34 <cjs> I like that!
08:26:36 <quicksilver> wouldn't do any harm
08:26:46 <quicksilver> but if you don't expect that to happen, I wouldn't do it ;)
08:26:57 <cjs> Hey, if it wants to change itself midstream to something else, that's not my problem. I just use it.
08:27:04 <MarcWeber> Can someone have a look at http://hpaste.org/10109 and tell me why ghc can't see that st31 should be st3 ?
08:27:05 <quicksilver> RayNbow: no, but there really should be.
08:28:02 <cjs> Actually, I could see potential uses for it. Then I could have different kinds of connections for "setting up" and "running", for example.
08:28:25 <quicksilver> you can indeed.
08:28:26 <cjs> Or a transparent fallback market feed if the main one failed.
08:28:34 <cjs> This is cool shit.
08:28:38 <quicksilver> explore the design space, that's what I say.
08:28:46 <cjs> Me too!
08:29:22 <cjs> I can't believe I've gone this long without existential types. I needed these desperately months ago.
08:29:34 <cjs> They should teach this stuff before monads.
08:29:47 <cjs> (Actually, I suppose they would if it were part of Haskell '98.)
08:30:15 <MarcWeber> cjs: Hehe, than you know how to use them but you don't know how to output the result :-)
08:31:17 <mib_d82r0zie> .
08:32:46 <thoughtpolice> cjs: certain simple extensions are hard for me to imagine not having - MPTC's are an example
08:33:05 <quicksilver> I very seldom use MPTCs.
08:33:18 <quicksilver> It all depends on your style, and what kind of problem you're normally tryin to solve.
08:33:31 <MarcWeber> MPTC?
08:33:31 <quicksilver> Actually I very rarely use (non-standard) TCs at all.
08:33:50 <quicksilver> MarcWeber: Multi Parameter Type Class
08:34:22 <thoughtpolice> yeah I normally am not one to use MPTCs or write them for that matter, but they are all over the place and I'm not an oldie, so I wonder sometimes.
08:34:43 <quicksilver> MonadState is a handy MPTC.
08:35:19 <thoughtpolice> yeah, mtl's Monad* classes use them quite a bit
08:35:33 * Axman6 waves goodnight
08:35:55 * MarcWeber wonders wether Saizon has time again to help me master this problem?
08:36:12 <MarcWeber> s/Saizon/ Saizan_ /
08:37:01 <dino-> Is there a way I can have the older Haskell Hierarchical Libraries index format without the search form?
08:37:17 <dino-> I'm ok with regen of docs myself if necessary.
08:48:00 <Ayu08> p
08:48:12 <Twey> q
08:48:22 <Ayu08> Twey, how do i register on irc?
08:48:38 <Twey> Ayu08: /msg nickserv register <password> <email>
08:48:58 <Ayu08> what nickserv should i use?
08:48:58 <MarcWeber> Ayu08: see also  /msg nickserv help
08:49:15 <MarcWeber> Ayu08: nickserv is a chat bot.
08:49:56 <Ayu08> marcweber: ^_^
08:50:20 <RayNbow> NickServ is ChanServ's sibling
08:50:41 <Twey> NickServ, ChanServ and MemoServ
08:50:45 <Twey> They're triplets
08:51:30 <Saizan_> MarcWeber: pong, what's the problem?
08:51:52 <MarcWeber> Saizan_: No longer sure. Maybe its solved
08:54:22 <Saizan_> is there an implementation of monitors (as in synchronization) in haskell?
08:54:47 <MarcWeber> Saizan_: Don't understand your question? How/ when is such a thing used?
08:55:31 <quicksilver> Saizan_: MVars are the universal synchronisation construct :)
08:55:42 <quicksilver> Saizan_: (I've forgotten exactly what the semantics of a monitor is)
08:55:49 <Saizan_> MarcWeber: to encapsulate some shared state between threads and ensure proper synchronization
08:55:57 <quicksilver> I think I had a discussion about them a year or two ago.
08:56:32 <quicksilver> ISTR my conclusion was that most of the htings monitors were used for, were simpler with MVars.
08:56:39 <MarcWeber> Saizan_: STM or MVars ?
08:56:47 <quicksilver> I seem to further remember that the other party in the conversation was not convinced ;)
08:57:31 <Saizan_> quicksilver: heh, i'd have to try, but i'm writing something that's getting not so elegant with MVars and wondered if i could get better with monitors
08:57:55 <MarcWeber> Saizan_: Are you allowed to talk about this use case?
08:57:57 <quicksilver> Ok, I'm wrong.
08:58:08 <quicksilver> The conversation I refer to was about condvars, not monitors.
08:58:11 <quicksilver> closely related.
08:58:17 <Saizan_> yeah, closely
08:58:20 <quicksilver> Saizan_: maybe you could say what semantics you would like froma monitor?
08:59:37 <Saizan_> i'm implementing a JobPool, which has two methods launch :: JobPool m a -> m a -> m (), and collect :: JobPool m a -> m (Maybe a)
09:00:15 <MarcWeber> Saizan_: and only 10 should run at once or such?
09:00:20 <Saizan_> yeah
09:00:20 <MarcWeber> Saizan_: cmd line app?
09:00:25 <zard1> .
09:00:55 <Saizan_> and if there's an exception in 'm' i should get all the computed results before that exception is rethrown by collect
09:01:14 <Saizan_> (it's to implement make -j for cabal)
09:02:08 <Husio> where can I find some code for haskell beginner?
09:02:10 <quicksilver> have the spawner increment an MVar Int ?
09:02:56 <Vq^> Husio: are you searching for some demonstration?
09:02:57 <BMeph> quicksilver: Like the Santa problem,? :)
09:03:08 <MarcWeber> Saizan_: http://rafb.net/p/RyGpxt82.html
09:03:09 <Vq^> Husio: or simple examples?
09:03:14 <lambdabot> Title: Nopaste - No description
09:03:32 <MarcWeber> Saizan_: I'v written this once. First I had an MVar implementation, but using STM is much more convinient..
09:03:38 <zard1> Husio:
09:03:44 <zard1> Husio: http://book.realworldhaskell.org/read/getting-started.html#starting.string
09:03:51 <lambdabot> Title: Chapter 1. Getting Started, http://tinyurl.com/5r9u2l
09:03:52 <Husio> I'm reading the 'programming in Haskell' book, and wan't to see some real code, but not to compicated
09:04:51 <MarcWeber> Husio: Not sure.. Maybe get started with a library such as filepath which can be found on hackage
09:04:56 <Husio> thanks
09:05:07 <camio> @hoogle a -> (a->b) -> (a,b)
09:05:08 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
09:05:17 <MarcWeber> Husio: Do you know what cpp is?
09:05:32 <camio> Hrm
09:05:44 <Husio> c pre procesor?
09:06:14 <MarcWeber> Husio: yes, its used there. So you won't struggle with it if you know about it :)
09:06:38 <MarcWeber> Saizan_: Does this come close to your needs?
09:07:05 <Deewiant> camio: flip (id &&&)
09:07:26 <Saizan_> MarcWeber: not far, but using multiple MVars doesn't fit here
09:07:44 <Phyx-> Hi, i was wondering if it's possible to get the source to visual haskell somewhere?
09:07:53 <camio> Deewiant: thanks
09:08:02 <MarcWeber> Saizan_: Mvars are only used to collect the results.
09:08:07 <camio> Deewiant: How did you find that?
09:08:09 <MarcWeber> Saizan_: How does your needs differ?
09:09:33 <Saizan_> http://hpaste.org/10110
09:10:00 <Deewiant> camio: \x f -> (id x, f x) is the same as \x f -> (id &&& f) x which is that. :-)
09:10:36 <Saizan_> MarcWeber: i need to get results as soon as they are produced, and get the possible errors last, in the sense that i want the results of all the actions runned, also i need to launch jobs incrementally, not everything in a list
09:10:49 <Saizan_> s/everything/all at once/
09:10:58 <Saizan_> that paste is what i've got so far :)
09:11:55 <MarcWeber> Saizan_: and collect should hang until the next result is availible and return Nothing if no more are running?
09:12:07 <Saizan_> MarcWeber: right
09:12:18 <Phyx-> hmm alternatively, does anyone know who i could contact about getting the source for it?
09:12:27 <int-e> @type ap (,) ?f
09:12:29 <lambdabot> forall a b. (?f::a -> b) => a -> (a, b)
09:12:45 <Deewiant> ?ty ap (,)
09:12:47 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
09:13:00 <MarcWeber> Saizan_: So my implementation differs from what you need in "any order" ? :-)
09:14:55 <MarcWeber> Saizan_: Then I would use another var, not only jobLimit and running but also results beeing a list of results beeing ready for beeing taken. Then you're done.
09:15:30 <quicksilver> or a Chan for results being ready
09:15:49 <quicksilver> (depends slightly on what blocking behaviour you want)
09:15:59 <MarcWeber> quicksilver: I've looked them up .. You were faster
09:16:29 <MarcWeber> quicksilver: Does'nt matter so a list should do. Saizan only cares about wether results are availible, not about the order
09:17:08 <quicksilver> Chans are useful if you want to process the results incrementally.
09:17:38 <quicksilver> Mvar [a] is more useful if you only ever want the whole thing.
09:17:49 <MarcWeber> just use liftM (listToMaybe) $ readTvar results to get the next result
09:18:10 <MarcWeber> and modifyTVar (newResult:) results to add one
09:18:32 <MarcWeber> then if running count > 0 do retry
09:18:46 <MarcWeber> to not return Nothing
09:19:05 <quicksilver> "liftM (listToMaybe) $ readTvar" does not remove the result.
09:19:10 <quicksilver> you will keep reading the same one.
09:19:21 <Saizan_> the Chan doesn't help much, since the real problem is knowing when not look for results anymore, without errors you can just check the number of jobs launched vs. collected, but with errors you've to be clever, since i want the error to be reported last
09:19:27 <MarcWeber> quicksilver: aehm.. sorry you're right
09:19:37 <quicksilver> you can actually do it with an MVar ([a])
09:19:40 <quicksilver> but it's fiddly
09:19:49 <quicksilver> need to remove elements when you take them
09:19:55 <quicksilver> Chan is easier because that's what it is for :)
09:19:59 <quicksilver> (resp. TChan)
09:20:20 <MarcWeber> quicksilver: What does this actually mean?
09:20:41 <MarcWeber> You may not return failures because you don't know wether jobs will be started which don't fail?
09:20:51 <quicksilver> I don't know what Saizan_ means :)
09:20:58 <quicksilver> I didn't understand that bit either.
09:21:09 <MarcWeber> Saizan_: We need some more explanation
09:21:21 <Saizan_> well, those jobs have side effects right? so the user can see if they are performed or not
09:21:28 <quicksilver> you can have an MVar () 'finished' for each job
09:21:38 <quicksilver> which gets 'put' whether it fails or succeeds.
09:21:46 <quicksilver> and some master thread can wait on them all.
09:22:17 <Saizan_> quicksilver: that's more or less what i'm doing http://hpaste.org/10110
09:22:19 <Deewiant> I use a Chan () for that purpose
09:23:27 <MarcWeber> Saizan_: MapM lauchnch [jA, jB, jC]  now jA finishes first but with failure. Then you want to return results of jB and jC before the failure of A, right?
09:25:03 <Saizan_> MarcWeber: depends, if jB and jC are started before jA finishes yes, if not it doesn't matter
09:27:15 <MarcWeber> Saizan_: So you need two result lists: one containing success only, the other the failures. Then you try to pop from the success list first. If that fails you try popping from failures. If that failes and running count = 0 return Nothing else retry
09:27:57 <MarcWeber> Do you want me to code up an example?
09:28:42 <Saizan_> no it's ok, it's a nice excuse to try STM :)
09:28:48 <Twey> MarcWeber: Uhm
09:28:52 <Twey> Why not just a Chan Bool?
09:29:05 <Twey> True for success, False for failure?
09:29:12 <Saizan_> Twey: i want results
09:29:21 <Twey> Ah
09:29:25 <Saizan_> also i want them not in the order they complete
09:29:28 <Twey> Chan Maybe a?
09:29:37 <Twey> Oh, OK
09:29:41 * Twey nods.
09:29:51 <MarcWeber> Twey: A chan will return results in order. Saizan want the results in any order but if there are multiple results which can be collected the failure should be returned last
09:30:11 * Twey nods.
09:31:04 <MarcWeber> Saizan_: You should definitely try STM because it's perfectly suited for this kind of problem and is much easier than using MVars
09:32:26 <Saizan_> MarcWeber: yeah, it looks nice, you get to program it like a spin loop and get a reasonable blocking implementation
09:39:15 <MarcWeber> woahh..! that's cool. I only have to finish the template haskell implementation. Then I'll be able to write validated  XML code like this : http://rafb.net/p/kUbGMd43.html
09:39:16 <lambdabot> Title: Nopaste - No description
09:39:59 <eu-prleu-peupeu1> is there any 2d barcode haskell generator ? :D
09:40:53 <MarcWeber> eu-prleu-peupeu1 I only know about LaTeX and the php pdf library.. search hackage and the haskell mailinglist for announces
09:41:07 <Saizan_> MarcWeber: you've redefined ($)? or how do you apply a tuple?
09:41:28 <MarcWeber> Saizan_ Typo
09:41:37 <Saizan_> there's sparklines, iirc
09:43:46 <eu-prleu-peupeu1> olright MarcWeber
09:44:17 <quicksilver> MarcWeber: type checked at compile time?
09:50:27 <ddarius> eu-prleu-peupeu1: A QR code generator?
09:57:13 <purestorm> Is there a better way to split a list into n-entry wide chunks than "tail (map fst (take 5 (iterate ((splitAt 2) . snd) ([], [1..10]))))"
09:57:28 <purestorm> s/2/n/, s/[1..10]/myList/
09:58:33 <skorpan> purestorm: are you sure you shouldn't escape those square brackets? and the period?
09:58:40 <chrisdone> is this chrome browser the most commented and voted upon reddit entry ever?
09:58:46 <skorpan> chrisdone:
09:58:49 <skorpan> oops nvm
09:58:49 <Botje> unfoldr (\l -> if null l then Nothing else SplitAt n l) list
09:58:52 <Botje> purestorm:  ^^
09:59:08 <Botje> bah
09:59:13 <Botje> should be Just $ splitAt ...
09:59:32 <Deewiant> heh, SplitAt
10:20:39 <Peaker> EvilTerran: nice alternate nick! :)
10:25:08 <EvilTerran> Peaker, ty. 'tis an anagram. my third nick is "irrelevant" :D
10:25:30 <Peaker> If I didn't understand it was an anagram, I don't think I'd find it very nice :)
10:26:29 <EvilTerran> my third nick is also anananagram, i mean :P
10:28:31 <Peaker> EvilTerran: did you choose your nick to have nice anagrams?
10:28:41 <Peaker> There are no anagrams for Peaker in /usr/share/dict/words
10:29:20 <EvilTerran> not really, no. originally "Irrelevant" was my primary nick, but it provoked too many stupid comments and got beeped at random times
10:29:28 <Peaker> there are a few more "evil" anagrams too.. you could use "VileRanter" maybe :)
10:29:38 <EvilTerran> so i switched to this, and now i just get the odd comment about starcraft
10:29:40 <_zenon_> Well... seems like monad is still unregistered ;)
10:29:54 <chrisdone> _zenon_: do you have the balls to use it?
10:29:56 <Peaker> lets see how long that lasts
10:30:12 <_zenon_> chrisdone, that's the question of course, I don't have the balls
10:30:48 <chrisdone> (“do you have the gonads to learn monads?”)
10:30:51 <_zenon_> It's like taking a nick like Erdos and then go join #math
10:33:50 <_zenon_> "join the nomads and use the monads"
10:34:04 <_zenon_> do it like the nomads, use monads
10:34:13 <_zenon_> not so catchy actually
10:34:48 <_zenon_> monads, a different *kind* of nomads
10:35:48 <lilac> monads, better than a kick in the gon[REDACTED]
10:35:59 <MarcWeber> Is it possible to do [d| $(mkName "funcName") = 7 |] somehow?
10:36:02 <Twey> chrisdone: Americans don't get 'gonads' jokes
10:36:12 <chrisdone> Twey: oh, really? shame
10:36:30 <Twey> ... except Haskellers, I guess, 'cause they've had it explained to them by every Brit with whom they discuss monads :-P
10:36:56 <chrisdone> yeah. “lol sounds liek gonads” “uh, yes, anyway... this is called bind...”
10:38:12 <_zenon_> Learn monads in a månad
10:38:12 <_zenon_> ;)
10:38:22 <_zenon_> nah, not that funny now when I read it.
10:39:21 <chrisdone> @happy-slap _zenon_
10:39:21 <lambdabot> Unknown command, try @list
10:49:01 <tromp> can i make a type for a range of integers like 1..9 ?
10:49:54 <roconnor> tromp: you can make a data type with 9 constructors.
10:49:55 <tromp> guess i can newtype and make it instance of Enum
10:50:06 <roconnor> that might be better
10:50:18 <tromp> but i won't be able to use the literals 1 , 2, ... , 9 then
10:50:27 <tromp> :t 1
10:50:28 <lambdabot> forall t. (Num t) => t
10:50:38 <roconnor> if you make it an instance of Num, you can
10:50:58 <roconnor> but you cannot statically check that they are in the range
10:51:13 <Deewiant> (Maybe (),Maybe (),Maybe (),Maybe ()) should work
10:51:26 <chrisdone> ?coi
10:51:27 <lambdabot> Maybe you meant: join yow
10:51:55 <roconnor> s/Maybe ()/Bool/  ?
10:52:11 <Deewiant> Maybe () is isomorphic to Bool
10:52:30 <roconnor> How about (Bool -> Bool) -> Bool ?  :P
10:52:38 <matthew-_> instance Monad Bool ?
10:52:48 <_zenon_> tromp, are you thinking something along the lines of Ada?
10:53:16 <roconnor> matthew-_: Maybe () isn't a monad either, although Maybe is a monad.
10:53:25 <matthew-_> well quite
10:53:27 <tromp> i dont't know Ada. just wondering what is the most pure way to define a coordinate in some game
10:53:48 <tromp> @src Enum
10:53:48 <lambdabot> class  Enum a   where
10:53:48 <lambdabot>     succ                     :: a -> a
10:53:48 <lambdabot>     pred                     :: a -> a
10:53:48 <lambdabot>     toEnum                   :: Int -> a
10:53:48 <lambdabot>     fromEnum                 :: a -> Int
10:53:50 <lambdabot> [3 @more lines]
10:53:58 <tromp> @src Bounded
10:53:58 <lambdabot> class  Bounded a  where
10:53:58 <lambdabot>     minBound, maxBound :: a
10:54:55 <EvilTerran> tromp, if you're willing to use TH, you could make Num instances for ExpQ and PatQ so $(9) would work
10:55:16 <tromp> no, i'm not willing to resort to TH:(
10:55:56 <EvilTerran> or not bother with those instances, 'cos it'd be messy, and write sth like $(digit 9)
10:55:58 <tromp> i also find myself defining another Maybe just for the sake of different constructor names
10:56:09 <chrisdone> to use template haskell is to admit you secretly love Common Lisp!
10:56:17 <tromp> instead of Nothing/Just i want to use Empty/Stone
10:56:32 <roconnor> that sounds reasonable
10:56:37 <tromp> unfortunately haskell doesn't allow Constructor aliases
10:57:02 <tromp> so i cant reuse Maybe
10:57:19 <mmorrow> MarcWeber: ghci> :t \n e -> valD (varP n) (normalB e) []
10:57:19 <mmorrow> \n e -> valD (varP n) (normalB e) [] :: Name -> ExpQ -> DecQ
10:57:20 <roconnor> you probably don't want to reuse Maybe, it comes with a lot of baggage
10:58:08 <tromp> right, i dont mind redefining my own
10:58:23 <tromp> still not sure about coordinates though
10:58:45 <tromp> guess i could just use Int
10:59:20 <tromp> > succ 'A'
10:59:23 <lambdabot>   'B'
10:59:37 <tromp> although any big enough instance of Enum would be fine
11:00:04 <tromp> all i need is pred succ minBound and maxBound
11:00:37 <roconnor> I like your newtype idea
11:01:47 <Saizan_> or write your code polymorphically
11:02:07 <Saizan_> so that you can change the board size (or what is it) by changing the type
11:03:18 <tromp> right; make Coord a class
11:03:38 <tromp> then i can also use different types for Xccord and Ycoord
11:03:43 <tromp> to make them display differently
11:05:35 <Taejo> I propose an esoteric language where smileys are code... oh wait, there already is one (:[])
11:05:53 <Taejo> (8-)
11:06:29 <tromp> does class declaration require a where?
11:06:51 <tromp> or could i just have a class (Enum a, Bounded a, Show a) => Coord a
11:06:52 <mmorrow> only if there are functions attached
11:07:23 <Taejo> what's the point of a class if it has no functions?
11:07:26 <tromp> guess i might want Eq a in there as well
11:07:36 <tromp> it has all those of its superclasses
11:07:39 <Deewiant> I guess what you want is class aliases
11:07:50 <Taejo> ok
11:07:54 <Deewiant> which don't exist and can't be simulated AFAIK
11:08:47 <Taejo> Deewiant: doesn't "instance A a => B a" make B a class synonym for A?
11:09:05 <Deewiant> I don't know, does it
11:09:13 <Deewiant> I've never tried; may or may not work
11:09:35 <laz0r> you know what i would like? if there would be some kind of a 3D engine written in haskell out there
11:09:35 <Taejo> I don't see why it shouldn't
11:09:37 <laz0r> so i could look at that
11:10:05 <mmorrow> data A = A   data B = B         class Letter a        instance Letter A    instance Letter B      thisWillCompileOnlyIfArgIsALetter = id :: (Letter a) => a -> a
11:11:29 <mmorrow> said another way, it lets you be polymorphic in the arg, but restrictively (to instances of the class)
11:11:55 <Peaker> frag has some sort of a 3d engine
11:12:22 <laz0r> Peaker: yes, i looked at frag already
11:12:39 <laz0r> i would have wished for something that is more... abstract
11:12:51 <laz0r> or high-level
11:19:00 <_zenon_> I searched the net for some nice haskell-ich fashion
11:19:25 <_zenon_> found a lot of lambda stuff, like lambda earrings, pins, tiepin etc.
11:19:45 <_zenon_> Alas, those are only sold on gay-movement sites
11:20:01 <_zenon_> apparently, the gay movement adopted the lambda symbol in 1976?
11:21:19 <EvilTerran> never heard that
11:21:32 <Peaker> The gay and Haskell communities are closely related
11:21:33 <_zenon_> However, Church used it before 1976, so it's safe :)
11:22:03 <_zenon_> And I'll never tell that to my buddies, :)
11:22:37 <_zenon_> http://en.wikipedia.org/wiki/Lambda_Literary_Awards
11:22:38 <_zenon_> For example
11:22:49 <_zenon_> lambdabot dead?
11:22:54 <_zenon_> gaybot :p
11:23:13 <_zenon_> http://en.wikipedia.org/wiki/Lambda_Legal
11:23:16 <Deewiant> ?botsnack
11:23:16 <lambdabot> :)
11:23:32 <_zenon_> Hm, someone deactivated the link reading thingy?
11:27:32 <newsham> main = putStrLn . (++ "!!") . (>> "AA") $ "Hello world !"
11:28:10 <_zenon_> > (execState $ do {get >>= \x -> put (x+1) >>= return}) 10
11:28:12 <newsham> if lambda is so gay, why did turing invent turing machines?
11:28:13 <Deewiant> > (>> "AA") "Hello world !"
11:28:14 <lambdabot>   11
11:28:17 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAA"
11:28:40 <Deewiant> ah, that's the one from uncyclopedia
11:28:53 <_zenon_> Hehe, funny thing Turing was gay then!
11:29:23 <Wild_Cat> wait, are you implying Gordon Freeman is gay?
11:30:16 <_zenon_> Hm, you might have to explain the connection there.
11:30:22 <_zenon_> Maybe I've had too much coffee
11:30:58 <Wild_Cat> Gordon Freeman. Of Half-Life fame. You know, the game that has more lambda symbols than a Haskell source file.
11:31:19 <_zenon_> Ah.... hehe
11:31:31 <_zenon_> Hm, maybe. Or the developers over at valve are super-gay
11:33:05 <name> can i somehow match the first elem of a list using pattern matching?
11:33:20 <Peaker> name: f (x:xs) = x is the first elem of a list?
11:33:32 <Deewiant> ?src head
11:33:32 <lambdabot> head (x:_) = x
11:33:33 <lambdabot> head []    = undefined
11:33:42 <name> ahh. i am stupid :)
11:33:43 <Peaker> name: or do you mean: f (Just x:xs) = x is inside a Just in the first elem of a list
11:34:05 <name> thank you
11:35:36 <dancor> what is metacompilation, i can't really tell from http://en.wikipedia.org/wiki/Metacompilation
11:35:37 <lambdabot> Title: Metacompilation - Wikipedia, the free encyclopedia
11:37:03 <_zenon_> You really ought to think once and twice about using the lambda symbol.... http://www.lambdabusiness.com/
11:37:08 <lambdabot> Title: LambdaBusiness.com - Gay Business Directory
11:37:17 <tromp> > succ ()
11:37:21 <lambdabot>   mueval: Prelude.read: no parse
11:37:21 <lambdabot>  mueval: *** Exception: Prelude.Enum.().succ...
11:38:07 <tromp> ['1','0'..]
11:38:11 <tromp> > ['1','0'..]
11:38:14 <lambdabot>   "10/.-,+*)('&%$#\"! \US\RS\GS\FS\ESC\SUB\EM\CAN\ETB\SYN\NAK\DC4\DC3\DC2\DC1...
11:38:34 <tromp> > drop 10 ['1','0'..]
11:38:35 <Saizan_> [1,0..]
11:38:37 <lambdabot>   "'&%$#\"! \US\RS\GS\FS\ESC\SUB\EM\CAN\ETB\SYN\NAK\DC4\DC3\DC2\DC1\DLE\SI\SO...
11:38:47 <tromp> > drop 20 ['1','0'..]
11:38:50 <lambdabot>   "\GS\FS\ESC\SUB\EM\CAN\ETB\SYN\NAK\DC4\DC3\DC2\DC1\DLE\SI\SO\r\f\v\n\t\b\a\...
11:38:57 <tromp> > drop 30 ['1','0'..]
11:39:00 <lambdabot>   "\DC3\DC2\DC1\DLE\SI\SO\r\f\v\n\t\b\a\ACK\ENQ\EOT\ETX\STX\SOH\NUL"
11:39:32 <tromp> > pred False
11:39:35 <lambdabot>   mueval: Prelude.read: no parse
11:39:35 <lambdabot>  mueval: *** Exception: Prelude.Enum.Bool.pr...
11:40:24 <nominolo> @seen lemmih
11:40:25 <lambdabot> I saw lemmih leaving #haskell-blah and #haskell 15h 32m 12s ago, and .
11:46:13 <name> what am i doing wrong? http://paste.pocoo.org/show/84296/
11:48:30 <Jedai> name: Your type "a -> [a] -> Bool" tell you're given anything, a list of anything and return a Bool, but in the body of your function you use isDivieAble that in turn use mod, which don't work on "anythin"
11:48:30 <EvilTerran> name, as it stands, your type signature says isPrime has type "[a] -> a -> Bool
11:48:31 <EvilTerran> " for *any* type a
11:48:37 <Jedai> ?type mod
11:48:39 <lambdabot> forall a. (Integral a) => a -> a -> a
11:49:03 <name> without any type signature it doesn't work either :)
11:49:09 <EvilTerran> ^ mod's type indicates that it only works on such types "a" that are instances of the "Integral" typeclass
11:49:11 <Jedai> As you see mod only work on types in the Integral typeclass
11:49:46 <EvilTerran> ?type sqrt
11:49:48 <Jedai> name: sqrt only works on Floating instances
11:49:48 <lambdabot> forall a. (Floating a) => a -> a
11:49:59 <name> so i'd need to "cast" it?!
11:50:03 <EvilTerran> there aren't any types that instantiate both Integral and Floating
11:50:16 <EvilTerran> name, or you could re-phrase "first > (sqrt nmb)"...
11:50:31 <EvilTerran> you can write an equivalent expression that doesn't require sqrt
11:50:32 <Jedai> name: Yes, though "convert" it would be more correct
11:50:53 <Jedai> name: Or you can just (^ 2) the other side...
11:50:55 <hackage> Uploaded to hackage: zip-archive 0.1.1
11:52:33 <name> i'm somehow struggling with the type sys it seems
11:53:08 <JimCrayne> Is there any activity on the replacing GMP front?
11:53:42 <dcoutts_> JimCrayne: some, but not a lot. It's a hard thing to replace, it works so well.
11:53:46 <nathanic> JimCrayne: why do people want to replace it?
11:54:12 <dcoutts_> JimCrayne: there's a simple haskell impl, but obviously the performance on larger integers is terrible.
11:54:45 <JimCrayne> http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
11:54:47 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac
11:55:53 <JimCrayne> i'd be fine with keeping it if it is truely the best we can do, but then i think we should make it more convenient to dynamically link to it at least, on windows... perhaps that's already been done.
11:56:51 <Jedai> name: Mainly with the numeric hierarchy, which is normal if you come from a less discriminating background (Perl, Python, Ruby, PHP, ...)
11:57:02 <name> python :)
11:57:20 <Jedai> name: But you get better performances and more coherence in the Haskell way
11:57:34 <dcoutts_> JimCrayne: I'm sure you can dynamically link to it even on windows but it's a pita, since where do you put the gmp.dll so that all the exes ghc generates can use it?
11:58:03 <dcoutts_> JimCrayne: it'd be ok for deployment though
11:58:08 <JimCrayne> system32 i suppose
11:58:12 <Jedai> name: in theory we could write a big AllNum typeclass that would subsume all the numeric type but I don't think it's a good idea
11:58:20 <dcoutts_> JimCrayne: right, exactly, that's the problem.
11:58:27 <name> Jedai: and more errors ;(
11:58:33 <JimCrayne> why is that a problem?
11:58:48 <dcoutts_> JimCrayne: people will scream if your installer puts anything in system32
11:58:55 <name> http://paste.pocoo.org/show/84299/ the error messages of ghci are not really helpful for me
11:58:57 <Jedai> name: compile-time errors, instead of runtime surprises
11:59:00 <JimCrayne> they will?
11:59:19 <dcoutts_> JimCrayne: yep, it's certainly not recommended practise
11:59:27 <trofi> -Wl,-rpath= analogue for windows would help
11:59:38 <Jedai> name: Think again, 0.5 is a floating point...
11:59:44 <name> Jedai: so?
11:59:46 <Jedai> ?type (^)
11:59:48 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:59:48 <JimCrayne> well we can just have it be standard practice to have it in the same folder as the exe
11:59:54 <trofi> :t (**)
11:59:55 <name> Jedai: 2 ^ 0.5 is a legit calculation, right?
11:59:56 <lambdabot> forall a. (Floating a) => a -> a -> a
12:00:01 <trofi> :t (^^)
12:00:03 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:00:06 <dcoutts_> trofi: right, if only. there are isolated assemblies but they can only be installed by admin
12:00:27 <JimCrayne> every haskell problem would have it's own version of libgmp to deploy with, but that's defacto the way it is now anyway.
12:00:43 <JimCrayne> s/problem/program
12:01:02 <dcoutts_> JimCrayne: right, like I said that's fine for deployment but not random hacking. when I ghc --make foo -o foo.exe, I want that foo.exe to work. if I have to copy a load of dlls into the same dir as the foo.exe then I'll be annoyed.
12:01:04 <Jedai> name: No, it is not, (^) works on integral powers and use a faster/more precise algorithm than (**) that works on floating point but use exp and log
12:01:04 <name> so i need to convert my Int to a float?
12:01:25 <Jedai> name: Think again, I even gave you the answer before
12:01:26 <dons> sweet. we got lolmagnets for the office.
12:01:32 <JimCrayne> well we can have static linking for the random hacking case i suppose
12:01:42 <dcoutts_> JimCrayne: yeah, so it might all work fine
12:01:50 <dons> @users
12:01:51 <JimCrayne> ghc --dynamic_gmp --make foo -o foo.exe
12:01:51 <lambdabot> Maximum users seen in #haskell: 497, currently: 490 (98.6%), active: 19 (3.9%)
12:01:57 <Jedai> name: instead of using sqrt or equivalent, you just have to take the square of the other side of the inequation
12:02:16 <JimCrayne> or --deploy-gmp
12:02:19 <JimCrayne> something like that
12:02:21 <Jedai> name: (first * first) > nmb
12:02:26 <dcoutts_> dons: we need to get the haskell-platform package working. we need a .tar.gz that anyone can build starting from just ghc+core libs.
12:02:38 <Jedai> name: That's much more efficient and the standard way to do it
12:02:47 <JimCrayne> hmmm
12:03:00 <dons> dcoutts_: hmm. so hackage+the meta package+cabal install?
12:03:03 <JimCrayne> sometimes we need a deployed executable to be self contained tho
12:03:08 <dons> or a .tar.gz with no additional requirements?
12:03:12 <name> Jedai: hum?
12:03:15 <dcoutts_> dons: the latter
12:03:23 <dons> ok. so assumes a ghc + core packages?
12:03:23 <tromp> was there a ghc option to compile a non Main module into executable?
12:03:26 <name> Jedai: i'm confused
12:03:26 <dcoutts_> dons: right
12:03:38 <dons> ok. so some kind of 'flattened' dependency tree for the hp package  i guess.
12:03:56 <dons> sounds like a job for cabal, eventually: "give me a .tar.gz of this project and its deps"
12:04:13 <dcoutts_> dons: right, except that it needs to bootstrap itself
12:04:26 <Jedai> name: That's basic arithmetic : for positive real "a > sqrt b" is equivalent to "a * a > b"
12:04:30 <dons> so the main question is the build system
12:04:39 <dcoutts_> dons: so here's my plan. the tarball would contain all the other packages and a script. the script would build cabal-install and then use that to install everything
12:04:46 <dons> a very thin Makefile?
12:04:50 <name> Jedai: i see. i think i solved it with fromIntegral :)
12:04:51 <JimCrayne> Has anyone tried talking to the FSF?  maybe they can give us some security, by issuing a special statement or license for libgmp... to clarify that ghc programs can link to it without issue...
12:04:51 <dons> yep
12:04:56 <dons> that sounds good.
12:04:58 <dcoutts_> dons: straight portable sh script
12:05:00 <dons> really simple sh or make
12:05:03 <dons> yeah
12:05:07 <Jedai> name: That's heavy and inefficient
12:05:30 <dcoutts_> dons: should work on osx and windows too (though we'll have an installer there)
12:05:31 <JimCrayne> we can write an open letter or something on petition.org or something like that.
12:05:46 <JimCrayne> we'd probably get slashdotted
12:05:59 <trofi> you could hold .exe and libgmp.dll in same dir to make it work
12:06:02 <dons> dcoutts_: ok. so we do a cabal install of the hp packages, take the src out of ~/.cabal and put it in a new place. add the sh scirpt.
12:06:05 <dons> tar it up.
12:06:05 <dcoutts_> JimCrayne: there's no problem though, we just dynamically link it
12:06:12 <quicksilver> Beelsebob: it works :) Have an event + future implementation good enough to build an 'Event Char' from stdin and use mappend :)
12:06:14 <dons> so a script to construct this is needed.
12:06:38 <dcoutts_> dons: right, we should make a builder script and add it to the platform darcs repo
12:06:58 <dons> ok. do you want me to put this plan on the wiki?
12:07:09 <dcoutts_> dons: if we do it right, then people testing said tarball could also automatically upload results to a special hackage server
12:07:11 <dons> at some point we need a bug tracker for platform tasks.
12:07:16 <dcoutts_> dons: I guess so
12:07:17 <dons> that'd be good.
12:07:46 <dcoutts_> dons: so, first thing, I'm going to try and get a public hackage server instance running and accepting build reports
12:07:54 <dons> ok.
12:08:01 <dons> i'll work on the script then
12:08:03 <dcoutts_> ok
12:08:31 <JimCrayne> dcoutts, yeah it would be nice to be able to statically link tho... say you want to make an installer program in haskell... it's rather inconvenient if it can't be a stand-alone executable.
12:09:04 <dcoutts_> JimCrayne: that's the use case for the pure-haskell integer lib, who cares about int performance there?
12:09:35 <dons> actually, what happened with the pure haskell integer lib?
12:09:40 <dons> it should be hackaged.
12:09:59 <dcoutts_> dons: there are two I think, a standalone one and Igloo's simple one
12:10:18 <JimCrayne> where do i look to learn how to use the pure-haskell lib in place of gmp?
12:10:32 <dcoutts_> JimCrayne: same page you referenced earlier
12:10:58 <kolmodin> dons: http://code.haskell.org/arch/i686/, you only support x86_64 atm?
12:10:59 <lambdabot> Title: Index of /arch/i686
12:11:24 <dcoutts_> dons: I checked cabal-install on windows today for packages like opengl which uses ./configure scripts. Works fine.
12:11:54 <dcoutts_> dons: I'll catch up later.
12:11:55 * dcoutts_ disappears
12:14:00 <JimCrayne> have you actually used this?  If it only replaces integer with its own but leaves ghc's garbage collection etc dependent on gmp then it's not much practical use...
12:14:28 <roconnor> ghc's garbage collection is dependent on gmp?
12:14:33 <JimCrayne> i think so
12:14:37 <roconnor> that's insane
12:15:05 <JimCrayne> well i dont know for sure... so if someone wants to correct me.. by all means
12:15:24 <matthew-_> why wouldn't the RTS just allocate and free blocks that the gmp can use?
12:15:47 <quicksilver> maybe there are some particular memory management hurdles int he gmp api (I'm just guessing)
12:16:03 <matthew-_> it would seem like we're all guessing ;)
12:16:14 <dons> JimCrayne: hmm, the runtime let's gmp allocate
12:16:14 <stepcut> maybe garbage collection needs Integer instead of Int in-case you have more than 4GB of RAM ;)
12:16:25 <dons> it's not so much that the 'GC depends on Integer' :)
12:16:48 <matthew-_> stepcut: dcoutts pointed out to me the other day that Int follows the platform bit size
12:16:50 <roconnor> I could believe that the GC depends on gmp in that gmp has tricky allocation issues that need to be managed specially
12:17:08 <dons> the runtime makes allowances for gmp (it has its own primops)
12:17:17 <JimCrayne> hmmm
12:17:34 <stepcut> matthew-_: yeah, but you don't get to use all the bits according to H98
12:17:37 <int-e> yes and no. for efficiency and better cooperation with the garbage collector, ghc replaces gmp's allocation functions by versions that allocate byte arrays on the heap
12:17:51 <Igloo> It ought to be fairly easy to remove the GMP bits from teh rest of GHC is you are using another Integer library
12:18:04 <matthew-_> stepcut: true. And I don't know if the number of bits lost are constant or linear to the platform bit size
12:18:18 <Igloo> You just compile in a chroot without gmp installed, and when the compile break delete what it failed to compile
12:18:57 <dons> nice.
12:19:22 <matthew-_> stepcut: that is the kind of provisioning up with which the H98 standard did not put! ;)
12:19:33 <JimCrayne> it should be even easier tho
12:19:39 * name is doing it wrong :(
12:19:42 <JimCrayne> imo
12:19:51 <stepcut> matthew-_: indeed.
12:20:01 <JimCrayne> like have a switch, --no-gmp
12:20:06 <JimCrayne> boom
12:20:26 <JimCrayne> yes i know i'm free to make the mods...
12:20:39 <dons> is gmp a problem?
12:20:57 <quicksilver> stepcut: the RTS doesn't use Int for pointers. It uses Addr# or Ptr# or whatever they are called.
12:21:09 <Igloo> That sounds like something that would bitrot, though
12:21:11 <quicksilver> stepcut: so the RTS doesn't worry about the restrictions of Int when using pointers.
12:21:24 <stepcut> quicksilver: makes sense, I was mostly joking
12:21:51 <matthew-_> tongue was nine tenths firmly embedded in cheek
12:21:58 <JimCrayne> yeah, in practice it can be. mostly because of the license issue.... it makes a pretty big inconvenience that is a lot of discouragement from using ghc for some applications... it seems to me.
12:22:00 <stepcut> however, I do not refrain from using Integers freely in my code, so it's possible the RTS has some that it does not require
12:22:02 <quicksilver> dons: gmp has a license problem according to some people
12:22:14 <quicksilver> dons: and a performance problem according to some others
12:22:16 <dons> JimCrayne: that's interesting. i've never seen that in the wild.
12:22:36 <stepcut> hrm, the connection between the two halves of my last sentence is not as strong as the sentence may suggest
12:22:42 * stepcut wrote none of the RTS
12:22:44 <dons> if there is a single commercial user who has ruled it out on the basis of the license, i'd like to know.
12:23:01 <dons> and the other commercial users would probably like to know why too :)
12:24:30 <quicksilver> in my mind, the worst thing about gmp is that we don't even bind to most of its fast primops
12:24:38 <dons> yes.
12:24:50 <dons> a survey of how much we actually use would be interesting.
12:24:56 <int-e> right, the example I was most unhappy about so far was bit tests.
12:24:56 <dons> and how to get Integer bindings for the rest of it.
12:25:15 <dons> since since we're paying the price of having it, we may as well use it for everything Integerable
12:25:19 <JimCrayne> well i'm going to be doing a sort of peice-meal re-write of an installer pretty soon at my company.. It would be nice to let ghc do the linking, especially since i've seen my coworker have to deal a lot with the problems of doing his own linking.
12:25:29 <name> i want the ceiled valued of the square root of a number, how do i get that?
12:25:55 <dons> JimCrayne: cool. so you mean haskell tool, that is packaged up, to which you do manual static linking?
12:25:56 <JimCrayne> the main reason for doing our own linking is avoiding license issues.
12:26:13 <dons> yeah, there should be a documented standard approach for this
12:26:25 <dons> since all commercial users potentially want to deal with it.
12:26:32 <JimCrayne> he's doing it on the  mac, and id be on windows
12:26:51 <dons> we should just have say, a wiki page, and a tool on hackage, for doing the linking
12:26:55 <dons> solve it once, everyone benefits.
12:26:59 <JimCrayne> yes
12:27:02 <tromp> try newton-raphson iteration, name
12:27:18 <dons> JimCrayne: and you want to do more than just pass -optl-static ?
12:27:24 <JimCrayne> or give us more fine grain control on how and what ghc links to
12:27:26 <name> namely i want to do [2..ceiling (sqrt num)]
12:27:30 <name> tho that doesn't seem to work
12:27:32 <dons> ok.
12:27:34 <mixis> quicksilver: isn't gmp LGPL? what's the issue with that one?
12:28:00 <newsham> > ceiling (sqrt 10)
12:28:04 <lambdabot>   4
12:28:13 <newsham> > [2 .. ceiling (sqrt 10)]
12:28:16 <lambdabot>   [2,3,4]
12:28:23 <JimCrayne> i think there are only 6 ops from gmp used... my coworker had originally intended to just rewrite them all...
12:28:29 <newsham> what problems are you having?
12:28:29 <name> isPrime [] nmb = isPrime [2..ceiling (sqrt nmb)] nmb gives me an error although isPrime [2..4] nmb doesn't
12:28:36 <dons> JimCrayne: huh.
12:28:43 <dons> *that's* interesting.
12:28:50 <name> that doesn't seem to make sense to me
12:28:53 <dons> hmm...
12:28:53 <stepcut> mixis: LGPL does not allow static linking, and ghc does static linking I think ?
12:28:55 <newsham> nmb is an integer.  try   sqrt (fromIntegral nmb) ?
12:29:01 <dons> stepcut: not of libgmp
12:29:07 <dons> only of haskell libs, by default.
12:29:11 <dons> libgmp is always dynlinked.
12:29:12 <name> same
12:29:25 <JimCrayne> what?
12:29:29 <dons> JimCrayne: this is relevant to glasgow-haskell-users@
12:29:39 <dons> you might want to summarise your concernes and approaches there.
12:29:39 <JimCrayne> libgmp is staticly linked... by default... well depends what platform
12:29:44 <stepcut> dons: ok, I couldn't remember the details from the last time this came up
12:29:44 <dons> oh, mayb.e
12:29:48 <name> i don't get it. why does 2..ceiling (sqrt 100) not work but 2..4 does
12:29:51 <dons> dynlinked on linux/* anyway.
12:29:59 <newsham> name: types
12:30:02 <dons> $ ldd `which xmonad`
12:30:02 <JimCrayne> it's statically linked on windows i believe... which is bad
12:30:06 <dons> 	libgmp.so.3 => /usr/lib/libgmp.so.3 (0x00007f254de6f000)
12:30:11 <int-e> add, sub, mul, gcd, div (4x), and, or, xor, com(plement) ... more than 6.
12:30:19 <newsham> name: can you put the code up at codepad.org?
12:30:21 <roconnor> @type ceiling
12:30:23 <int-e> and that's just the primops
12:30:23 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:30:39 <stepcut> on *my* linux system for atleast one ghc generated binary, libgmp3 is dynamically linked
12:30:51 <dons> so i'd like to see 2 things: JimCrayne, could you mail glasgow-haskell-users@ with your concerns, and the approaches you're trying. int-e, could you summarise what bits of libgmp we actually use?
12:31:13 <dons> so from there we can document exactly what needs to be done to satisfy license requirements
12:31:21 <name> newsham: http://paste.pocoo.org/show/84302/
12:31:24 <JimCrayne> int-e, maybe i mis-remembered, maybe he only had six left to go and had already re-written the rest.
12:31:25 <Igloo> There's a lot of stuff about this on the wiki already
12:31:27 <dons> and look at how to a) extend the Integer bindings, b) replace gmp with C-based rewrite.
12:31:35 <matthew-_> @seen dcoutts_
12:31:36 <lambdabot> dcoutts_ is in #darcs, #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 19m 41s ago.
12:31:36 <dons> Igloo: yeah.
12:31:43 <dons> so link in all the other gmp stuff.
12:31:47 <dcoutts> hia matthew-_
12:31:57 <Igloo> And you can look at the integer packages to see what API you need to provide
12:32:07 <dons> int-e: what are the barriers to binding more of gmp?
12:32:08 <roconnor> > ceiling (sqrt 100)
12:32:12 <lambdabot>   10
12:32:20 <JimCrayne> If he re-wrote a lot of gmp stuff, would people be interested in that? having just a replacegmp.o to statically link with which just re-impliments all the ops from gmp that ghc depends on?
12:32:25 <EvilTerran> > head . dropWhile ((<100).(^2)) $ [0..
12:32:27 <dons> JimCrayne: definitely.
12:32:28 <roconnor> > [2..ceiling(sqrt 100)]
12:32:28 <lambdabot>   mueval: Prelude.read: no parse
12:32:29 <dcoutts> matthew-_: ah, just got your email
12:32:29 <EvilTerran> > head . dropWhile ((<100).(^2)) $ [0..] -- doh
12:32:33 <lambdabot>   [2,3,4,5,6,7,8,9,10]
12:32:33 <lambdabot>  Terminated
12:32:51 <JimCrayne> dons, He wasn't necessarily interested in efficiency mind you... just getting the job done.
12:32:52 <dons> JimCrayne: since that provides one big assurance: if you can't solve the linking clause, you can ditch gmp.
12:32:54 * Igloo would love it if we could make a reasonably simple, fast enough Haskell impl, but I don't know if that's achievable
12:32:56 <dons> JimCrayne: indeed.
12:33:19 <roconnor> Igloo: what do you mean by fast enough?
12:33:20 <dons> Igloo: maybe in C--
12:33:22 <name> i don't really get why that doesn't work
12:33:22 <JimCrayne> well i can grab the code from him and post it somewhere... and all who are interested can flush it out.
12:33:22 <Igloo> People who actually need fast 10000 digit numbers can use a Gmp type from a gmp package
12:33:42 <dons> JimCrayne: do you know where the gmp discussion on the wiki is, and which list to discuss this on?
12:34:10 <roconnor> Igloo: Coq has an integer library implemented using trees of ints.  We could extract that.
12:34:20 <dons> Igloo: btw, will you be at ICFP? or did I ask that already.
12:34:22 <JimCrayne> it would be a drop in replacement for gmp
12:34:24 <newsham> name: http://codepad.org/XEz6Wfib
12:34:26 <newsham> that type checks.
12:34:34 <dons> we should start planning a #haskell meetup for one of the evenings.
12:35:29 <Igloo> roconnor: In http://hackage.haskell.org/trac/ghc/ticket/601 GHC itself got 8.2% slower with integer-simple. That's not fast enough
12:35:31 <lambdabot> Title: #601 (Replace GMP) - GHC - Trac
12:35:37 <Igloo> (See the penultimate comment)
12:35:37 <int-e> dons: the replaced allocation functions mean that normal FFI bindings (using foreignptr and the like) won't work. All currently bound functions are primops, and I'm unsure how to convert from gmp's return values to the correspondinge bytearrays otherwise. Another issue is the precise interaction with the garbage collector.
12:35:47 <dons> Igloo: but good enough for licensing requirements.
12:35:48 <Igloo> dons: I won't, and you did  :-)
12:35:50 <name> that type system is killing me
12:36:11 <dons> int-e: hmm. ok.
12:36:16 <Igloo> dons: Sure, but I'd like to have something fast enough that we can purge GMP from GHC proper
12:36:27 <JimCrayne> so you could basically use it without modifying ghc at all... could be a good interim solution and if we open source it and people write some good test-units for it... that would be good.  Perhaps over time we can improve it's efficiency too.
12:36:28 <int-e> dons: So the best trodden part so far is adding new primops, which is a rather heavy change.
12:36:30 <dons> i wonder if the allocation functions are still necessariy
12:36:39 <int-e> s/part/path/
12:36:47 <dons> do we know what the switch to 'normal' ffi marshalling is?
12:36:54 <Igloo> But if we're going to use something we wrote ourselves then it would be nice if it was really simple, so we can easily fix it when it breaks
12:37:11 <int-e> dons: they help performance (a lot, I suspect), in particular free becomes a noop
12:37:25 <dons> int-e: ah, so yes, like bytestrings in the heap.
12:37:28 <gwern> @quote excluded
12:37:29 <lambdabot> balor says: Darcs appears to ignore the law of the excluded middle (setCurrentDirectory: failed (Success))
12:37:30 <Igloo> Personally I don't think performance for huge integers is important for the built-in type, as you can use bindings to C libraries if you need speed
12:37:39 <dons> int-e: but without the ForeignPtr overhead
12:38:06 <dons> Igloo: interesting point. and now we can't use the full C lib for speed as it stands
12:38:08 <gwern> Igloo: why bind merely to C? LET'S ALL ASM IN ACCORDANCE WITH THE SOCIALIST LIFESTYLE!
12:38:15 <dons> gwern--
12:38:32 <stepcut> maybe we can get a Integer library added as a program on the shootout, and then we can just pick the fastest one ;)
12:38:48 <dons> stepcut: heh. the pidigits is a integer lib test
12:38:48 <Igloo> gwern: Because the fast Integer implementations are all in C (well, and a bit of asm)?
12:38:51 <dons> everyone uses gmp
12:38:57 <JimCrayne> dons, for people concerned about licensing, and doing our own linking etc.. there are only really two libraries of concern, gmp and readline.  If we could just have a ghc switch to ensure these libs are not linked with that would solve the problem.
12:38:57 <newsham> gwern: FFI isnt specific to C.
12:39:01 <newsham> you can bind to asm.
12:39:13 <gwern> that - that was my point -_-
12:39:16 <newsham> as long as you obey common calling conventions.
12:39:23 <stepcut> JimCrayne: readline is already optional, right ?
12:39:24 <dons> JimCrayne: right. so readline has been ditched for editline, and gmp has the pure reimplementation/linking exclusions
12:39:36 <dons> gmp's the only required lib now.
12:39:59 <newsham> has anyone written a decent multi-precision math library in haskell?
12:40:24 <Igloo> newsham: "decent" meaning what?
12:40:36 <newsham> usable, realistic? :)
12:40:47 <Igloo> == fast?
12:40:57 <newsham> not overly slow.
12:41:23 <Igloo> mine isn't fast enough for GHC, IMO
12:41:33 <Igloo> Isaac or Iavor wrote one that I haven't tried
12:41:34 <stepcut> One approach might be to implement a slow, but correct Integer library that you can be optionally used in GHC, and then let someone else worry about fast?
12:41:57 <Igloo> stepcut: "optionally" is a pain for maintenance
12:42:24 <stepcut> Igloo: right, that is the potential downside
12:42:26 <JimCrayne> if we release a partial rewrite of gmp which haskell programs can link against statically without license issue, is it possible/likely that it could be maintained as part of ghc?
12:43:12 <stepcut> Igloo: the upside is that it splits the problem in to two pieces: (1) decoupling GHC from GMP (2) making fast Integers. It may be that some people would be interested in doing (2), but not if they have to do (1) ?
12:43:52 <Igloo> stepcut: GHC is already decoupled from GMP, in teh sense that you can drop in an Integer library that doesn't use it
12:43:56 <camio> Anyone have experience getting freeglut and haskell working on windows?
12:44:29 <stepcut> Igloo: it sounds like you will still get linked against GMP though due to the RTS ?
12:45:03 <Igloo> stepcut: Yes, but that doesn't stop you making fast Integers
12:45:17 <newsham> the idealistic side of me thinks we should eat our own dog food and write more of the runtime in haskell.
12:45:19 * stepcut is still working on correct Decimals
12:45:23 <JimCrayne> also, can we make it the default on windows that programs which link with gmp do so dynamically...
12:45:38 <newsham> the pragmatic side thinks if we toss gmp for something slower, or make it optional, people will feel pain or just avoid using the newer/slower alternative
12:46:26 <JimCrayne> newsham, more likely scenario is people stop using gmp even when they could use it and it is superior... just to avoid thinking of the license issue.
12:46:43 <newsham> i dont see a problem with that. :)
12:46:53 <newsham> if they find it acceptable, why not.
12:46:55 <JimCrayne> unless htey're doing some programs which require really fast mp of course
12:47:15 <newsham> the more we eat our dog food the more we're inclined to make our dog food taste really good
12:47:23 <JimCrayne> yeah
12:47:28 <JimCrayne> true
12:47:32 <newsham> and the more honest our propaganda is
12:48:04 <stepcut> JimCrayne: but, they might be able to use GMP as a 3rd party library if they need fast mp ?
12:48:28 <stepcut> JimCrayne: they would just need a different Integer type, like GMPInteger ?
12:48:44 * gwern wonders if one could quantify the loss of haskell productivity/activity in the last few days due to the start of the academic year
12:48:49 <JimCrayne> well... if we take the approach of just re-implimenting the GMP interface that GHC requires, then of course, it's totally interchangeable, binary compatible even.
12:49:10 <stepcut> JimCrayne: right, I am not against that either ;)
12:49:12 <JimCrayne> and like i said, my co-worker has done this already, all but 6 functions i believe
12:50:26 <stepcut> Integers want to be free
12:50:38 <newsham> i thought that was the Naturals
12:50:54 <stepcut> Naturals want to be free
12:51:08 <JimCrayne> there is a draw-back to this approach i think... certain optimizations could not be made, the constraints we have from using gmp would be still there.
12:51:41 <JimCrayne> and it might take energy away from a better solution in that sense..
12:51:48 <SamB_XP> both of them do!
12:52:14 * SamB_XP has odd ideas involving existentials at this point
12:52:29 <JimCrayne> but perhaps its best we not let the perfect be the enemy of the good
12:52:54 <SamB_XP> what's the good?
12:53:24 <moosen> GMP is the GNU Mulpiple Precision arithmetic library? What licensing issues are there?
12:53:26 <gwern> good would apparently be a gmp-alike in haskell
12:53:33 <JimCrayne> the good in this case is a partial re-write of gmp under a bsd style license that specifically implements just what GHC needs.
12:53:55 <SamB_XP> moosen: well, it's not BSD
12:53:58 <gwern> perfect would apparently be some crazy researchy haskell library using advanced techniques for safety and/or performance
12:54:05 <moosen> does the GNU license limit what you can do with it in commercial software?
12:54:06 <gwern> no doubt with an olegian flavor...
12:54:16 <SamB_XP> moosen: yes!
12:54:28 <newsham> gpl is LGPL though, no?
12:54:32 <newsham> so shouldnt be such a big issue
12:54:35 <gwern> it also limits what you can do with it in noncommercial software...
12:54:41 <int-e> Igloo: do you know what the purpose of GMP_SYMS in rts/Linker.c is? none of those symbols seem to be used anywhere else. (Used symbols are found in Primops.cmm and in sm/Storage.c (__gmp_set_memory_functions))
12:54:52 * gwern notes that when it comes to the GPL, commercia/noncommercial is irrelegant
12:55:00 <gwern> *irrelevant
12:55:01 <SamB_XP> irrelegant?
12:55:22 <SamB_XP> @remember gwern * gwern notes that when it comes to the GPL, commercia/noncommercial is irrelegant
12:55:23 <lambdabot> I will remember.
12:55:25 <moosen> i always thought you could do whatever under the sun
12:55:43 <SamB_XP> moosen: no, that's the 1- or 2- clause BSD license
12:56:03 <Igloo> int-e: I'd guess they used to be needed but aren't any more, but I don't know
12:56:32 <SamB_XP> (the 3-clause license, which is more popular at the moment, is nearly that good too, of course)
12:56:44 <gwern> (...in the future, I shall claim that 'irrelegant' meant it was a pointless and uninteresting distinction and not a weird typo)
12:57:38 <newsham> err.. s/gpl is LGPL/gmp is LGPL/
12:58:13 <gwern> come to think of it, what license is the GPL? :)
12:58:50 <Botje> public domain
12:58:51 <Botje> !
12:59:01 <newsham> gpl says you give away the code free, and you can integrate it into your own code if your own code is also given away free
12:59:15 <newsham> lgpl says you can link against it without giving away your own code free
12:59:19 <gwern> the GPL is the-license-that-is-not-a-license. how very zen
12:59:33 <JimCrayne> i think the problems are mostly practical, if you want you can provide a solution that just makes it very very convenient to ship libgmp.. and  you can even statically link as long as you provide a simple way of re-linking the ghc generated binaries to a different version of libgmp.
13:00:34 <JimCrayne> but implementing all that seems to me more work than just re-implimenting the necessary gmp functions.
13:00:38 * moosen hopes for a future anonymized internet where all licensing is purely uneforceable and I can do whatever with any code I get, whether it was free and meant to stay free, completely free, or "free'd" from a corporation
13:01:06 <newsham> moosen: hahahaha
13:01:07 <Japsu> irrelegant ;D
13:01:07 <newsham> thats rich
13:02:25 <moosen> okay it's a little naive
13:02:34 * gwern thinks that would be unsatisfactory; then they'd get you by DRM and binary blobs. there's a difference between an actual FLOSS community and a couple hackers squatting over disassembler output
13:04:13 <JimCrayne> gwern, but if you can take a binary and relink it etc, then i think legally it would count just like dynamic linking..
13:04:36 <JimCrayne> it woudl be like our own version of dynamic linking rather than the windows standard way...
13:04:44 <SamB_XP> wow, the jane street partners actually read the code? neat. I guess it's only common sense, considering what the code is for, but common sense is rather scarce lately ;-).
13:05:21 <gwern> it's not like what is linking is well defined
13:05:44 <gwern> I'd hate to see that ever brought to court. it's one of the weaker areas in the licenses
13:05:53 <int-e> dons: http://hpaste.org/10111 is a quick overview
13:06:21 <dons> int-e, huh. thanks.
13:06:27 <dons> we're really not using gmp very much.
13:06:29 <dons> odd.
13:06:52 <dons> it seems that if we use libgmp, we should at least have a GHC.Integer that exports all the useful things.
13:06:59 <dons> though the primop requirement is hurtful
13:07:09 <dons> still, that's costing us performance and flexibility.
13:07:10 * int-e really wonders how this gmp stuff interacts with parallel GC ... but one point with primops is that they do all their allocation in a single thread, and the nurseries are thread local, right?
13:07:11 <JimCrayne> another approach, which to me is more satisfactory than actually replacing gmp or anything like that... but probably not realistic, is get the FSF to give us some kind of clarifying statement or license exception.
13:07:47 <JimCrayne> i suppose the FSF would then have to put that to a vote or something...
13:08:11 <JimCrayne> and soon everybody would be arguing over the merits of the GPL etc...
13:08:14 <Igloo> I don't see why the FSF would want to do that
13:08:19 <JimCrayne> me neither
13:08:22 <JimCrayne> well
13:08:28 <JimCrayne> just to keep us using gmp
13:08:41 <JimCrayne> it was licensed under the lgpl to encourage its use after all
13:08:58 <JimCrayne> they didn't choose to license it under the gpl
13:09:49 <dons> hmm. i wonder what the haskell community would look like if we were properly organised. grassroots style.
13:10:16 <dons> 'tell a friend about haskell', 'haskell on twitter', run it as a grassroots campaign :)
13:10:24 * araujo greets dons 
13:10:32 <quicksilver> become a fan of haskell on facebook.
13:10:38 * Vq^ greets araujo 
13:10:43 <quicksilver> videoblog about haskell.
13:10:52 * araujo greets Vq^ 
13:11:04 <Botje> 'march against imperative programming'
13:11:08 <quicksilver> make lolcats about haskell
13:11:12 <quicksilver> oh, we did that last one.
13:11:16 <Botje> lambda bumperstickers!
13:11:32 <JimCrayne> the revolution will be declared
13:11:43 <JimCrayne> i remember seeing t-shirts with that slogan
13:11:45 * araujo takes his lambda shield and monad sword
13:12:01 <dons> i think there's things from say, obama's online campaign we could learn from.
13:12:31 <Deewiant> send a text message to all haskell users when a new GHC is out?
13:12:48 <dons> yeah!
13:13:05 <JimCrayne> Anyway.. it seems to me unlikely that the FSF would be sufficiently motivated to make any exception... especially if it might be controversial.
13:13:05 <dons> the best organised open source community wins.
13:14:07 <JimCrayne> if we were an official organization, we could purchase AMC membership and grant it to our members as an organization.... right?
13:14:08 <gwern> I always worry when I hear this sort of thing about overhyping haskell
13:14:25 <gwern> AMC == ACM?
13:14:27 <dons> 20 years of underhyping.
13:14:40 <rwbarton_> ==gwern, hyperorganization can look creepy from the outside
13:14:42 <JimCrayne> yeah ACM
13:14:49 <dons> and besides, mainstream programming sucks. we want a brigher future for all programmers:)
13:14:54 <JimCrayne> maybe we could get a little discount that way
13:14:58 <dons> now is the time we turn back the imperative tide!
13:15:16 <zulusulta> eh why does mainstream programming suck?
13:15:16 <JimCrayne> we could call ourselves a labour union
13:15:30 <dons> now is the time we embrace clean, renewable persistant data structures
13:15:34 <zulusulta> u guys need a corportae sponser
13:15:36 <gwern> we fill fight them in the registers, we will fight them in the caches; we shall fight them in the core, and even in the backing store. And we shall never surrender!
13:15:38 <int-e> dons: the biggest technical downside of this gmp hack is that binding gmp via FFI is not really possible. (the allocation functions get in the way of memory management)
13:15:42 <zulusulta> like google did for firefox
13:16:00 <dons> zulusulta: yeah, there's something of that already, but its not official
13:16:08 <dons> e.g the hackathons are sponsored.
13:16:16 <gwern> that would be excellent; google's paid them hundreds of millions, and FF has benefitted immensely
13:16:21 <int-e> dons: so it's rather complicated to find out how large the performance penalty would actually be.
13:16:37 <dons> int-e: ok.
13:16:49 <dons> so we can't just do ForeignPtr management?
13:17:24 <dons> hehe. /me notes there's now debian and macports pushes for cabal2arch-like automation
13:17:27 <int-e> we'd need our own copy of gmp, separate from the one the rts uses, or an rts without gmp.
13:17:47 <int-e> at least without the allocation function hack.
13:19:03 * gwern ponders. 'the revolution will not be interpreted'? 'the revolution will not be ducky'? 'the revolution will not be manually gc'd'?
13:19:11 <int-e> dons: the evil part of the hack is that it allocates a bytearray, but nothing is actually pointing to that byte array before the gmp function returns. the primop adjusts the pointer so the RTS will recognize the memory area as a bytearray.
13:20:08 <ketil> We few, we well-typed few.  We bunch of lambdas.
13:21:02 <dons> int-e: huh
13:21:03 <gwern> 'the revolution will not be untyped' just sounds weird because of the apparent double negative
13:21:18 <gwern> 'this is my id function. there are many like it, but this one is mine.'
13:22:21 * nathanic expects the pickings for HWN quotes will be pretty good after this little spurt
13:22:22 <brweber2> anyone here take part in fringedc?
13:22:51 <Wild_Cat> "The revolution will revolve."
13:22:57 <gwern> nathanic: nah, I think byorgey only selects from @remember'd ones
13:23:20 <byorgey> It's true.
13:23:34 <byorgey> from @remember or preflex: remember'ed ones
13:23:42 <RayNbow> http://www.reddit.com/r/programming/comments/6zhg5/functional_programming_considered_harmful/ <-- w...t...f...
13:23:44 <lambdabot> Title: Functional Programming Considered Harmful! : programming, http://tinyurl.com/6358nh
13:23:56 <byorgey> so, nathanic, if there are some you think were good, @remember them
13:24:36 <byorgey> sometimes I do put in some I thought were particularly funny if I was following #haskell when they were spoken, even if no one @remembered them, but that's rare
13:24:40 <Botje> RayNbow: it's functional _JAVA_
13:24:43 <Botje> of course that's harmful!
13:24:44 <Botje> :p
13:24:45 <gwern> nathanic: only *you* can stop forgetfullness!
13:24:46 <int-e> well, adding functional programming to java sounds incredibly awkward.
13:26:04 <Wild_Cat> Functional Java is atrocious. I've tried.
13:26:26 <Wild_Cat> You end up with 15 lines for a simple map operation.
13:26:36 <RayNbow> the only thing I try to achieve when I write Java is to be as referential transparent as possible
13:26:38 <Wild_Cat> and lost type safety in the process. Well, lost back in the <1.5 days.
13:27:15 <Botje> RayNbow: so your setters don't really set anything? :D
13:27:29 <nathanic> @remember gwern we fill fight them in the registers, we will fight them in the caches; we shall fight them in the core, and even in the backing store. And we shall never surrender!
13:27:30 <lambdabot> Done.
13:27:40 * gwern would like an Irish setter
13:27:48 <Wild_Cat> Collections.map(new Transformer<T1, T2>() { public T2 transform(T1 foo) { return whatever(foo); }}, myCollection); // Ain't that cute?
13:27:56 <SamB_XP> don't you think that title is innappropriate for the URL, though ?
13:28:18 <RayNbow> Botje: I didn't say I would be 100% referential transparent ;)
13:28:39 <zulusulta> is it better to use c++ or haskell for ai?
13:28:44 <EvilTerran> no
13:28:50 <SamB_XP> what the heck is AI
13:29:00 <JimCrayne> artificial intelligence
13:29:04 <JimCrayne> i assume
13:29:11 <zulusulta> Thanks Jim
13:29:15 <SamB_XP> I know what it stands for, but what *is* it?
13:29:20 <JimCrayne> oh
13:29:26 <gwern> zulusulta: I would say that given the hairy algorithms AI uses, you'd be best served by a language that doesn't bother you with low-level details
13:29:33 <gwern> since AI is Hard enough...
13:29:33 <JimCrayne> yeah perhaps too broad a question to answer
13:29:33 <zulusulta> fuzzy rules, ml
13:29:39 <zulusulta> machine learning
13:29:55 <Botje> zulusulta: GHC is almost sentient
13:30:00 <SamB_XP> Botje: hah
13:30:01 <JimCrayne> lol
13:30:01 <SamB_XP> is not
13:30:10 <Botje> no need to use crappy imitations to implement "artificial" intelligence
13:30:10 <Botje> :p
13:30:22 <SamB_XP> if it were, it wouldn't diverge given non-terminating rewrite rules
13:30:25 * gwern studiously avoids claiming that haskell is better than python or ruby or scheme or common lisp for difficult algorithms, but I am fairly sure c++ would be a productivity drain in this context. although the game developers seem to like c++...
13:30:57 <zulusulta> great how does it take to learn haskell?
13:30:58 <Wild_Cat> gwern: Game devs like C++ for core engines. The actual game logic is usually implemented in Lua, Python or UnrealScript.
13:30:59 <SamB_XP> gwern: I don't think they like using C++ to write AIs in ;-)
13:31:03 <JimCrayne> i've heard C complimented for use in doing genetic programming...
13:31:12 <Wild_Cat> and recently, they've began switching to middleware for AI.
13:31:29 <SamB_XP> maybe important algorithms that AIs make use of, but not the AIs themselves
13:31:47 <SamB_XP> Wild_Cat: middleware?
13:31:48 <gwern> Wild_Cat: oh, really? ok then, I guess that bolsters my point even more
13:32:06 <SamB_XP> Wild_Cat: what sort of middleware
13:32:14 <Wild_Cat> SamB: aye. I began seeing logos in games a year or so ago... Let me find the name.
13:32:22 <JimCrayne> if you are evolving your program genetically, a low level might be advantageous... but i'm not knowlegeable enough to be confident in that assertion..
13:32:37 <Botje> they use Havok of PhysX to do physics nowadays
13:32:40 <Botje> s/of/or/
13:32:47 <SamB_XP> oh, that's different
13:32:55 <SamB_XP> physics isn't the same thing as AI ;-P
13:32:56 <Wild_Cat> SamB: http://en.wikipedia.org/wiki/Kynapse
13:32:57 <lambdabot> Title: Kynapse - Wikipedia, the free encyclopedia
13:33:02 <SamB_XP> oh, kynapse?
13:33:07 <SamB_XP> is that a neural net software?
13:33:34 <dcoutts> dons: any idea what to do about Neville's Q about a haskell.org link?
13:33:50 <Wild_Cat> SamB: I don't know the details -- only that it's the AI middleware used in Crackdown and a couple other games I played this year (maybe Mass Effect?)
13:33:57 <znutar> looks like kynapse is primarily just robust fast pathfinding
13:34:04 <SamB_XP> hmm, it looks like kynapse is mostly a library of routines to use in AI
13:34:11 <SamB_XP> for games
13:34:35 <JimCrayne> (4:32:34 PM) Joe Crayne: should be http://jerkface.net/~joe/jmp.c
13:34:35 <JimCrayne> (4:34:04 PM) Joe Crayne: let me know if anybody is going to do anything with it
13:34:39 <dcoutts> dons: see also the SFC email and mention of how to handle sponsorship
13:34:39 <SamB_XP> since game AIs need to be able to come up with plans to get from A to B ...
13:34:59 <Wild_Cat> Can't say the AI in Crackdown was stellar, though. Then again, it's not like I gave it a chance to do much other than get blown up in my endless rocket-powered fury.
13:35:04 <JimCrayne> that's the beginning of a gmp replacement module for ghc
13:35:18 <SamB_XP> and to find a good place to shoot at C from ...
13:36:14 * Wild_Cat takes a look at TagSoup.
13:36:31 <greendemon> There is a Functor class for mappable things, and Foldable for foldable things, is there something like Filterable for things that can be filtered?
13:36:39 <greendemon> Basically I want to filter a tree
13:37:28 <RayNbow> greendemon: you could express the filter as a fold
13:38:18 <dons> dcoutts: ok. looking.
13:38:51 <greendemon> hm
13:38:52 <RayNbow> greendemon: but the Foldable class doesn't really preserve the structure of the tree
13:39:23 <greendemon> I noticed Data.Tree also is an instance of Traversable
13:39:25 <RayNbow> (that last sentence is not quite well formulated)
13:39:32 <greendemon> but I can't really figure out how that works
13:40:50 <quicksilver> greendemon: neither is good enough.
13:40:59 <quicksilver> greendemon: if you remove elements how do you adjust the structure?
13:41:03 <quicksilver> (Traversable doesn't know)
13:41:21 <quicksilver> greendemon: one approach is to use "Monoid"
13:41:28 <quicksilver> and use that to piece together the remains
13:41:38 <quicksilver> but it's not easy to make Data.Tree a useful instance of monoid
13:41:46 <greendemon> basically I thought if you remove an element, you remove all the children
13:41:48 <quicksilver> you end up with long thin trees (i.e. lists)
13:42:00 <quicksilver> greendemon: that's a very sensible answer
13:42:08 <quicksilver> greendemon: but 'Traversable' couldn't do that.
13:42:08 <zulusulta> http://mult.ifario.us/p/there-are-apparently-lots-of-haskell-jobs
13:42:12 <Wild_Cat> grr. Haskell not allowing trailing commas in lists is annoying.
13:42:17 <quicksilver> (Traversable doesn't know what children are)
13:42:19 <lambdabot> Title: there-are-apparently-lots-of-haskell-jobs
13:42:22 <nathanic> Wild_Cat: agreed
13:42:28 <quicksilver> greendemon: so really you're talking about something useful, but very specific to trees
13:43:14 <greendemon> ok, perhaps I should write it from scratch then
13:43:33 <greendemon> I just thought it might already exist somewhere in the standard library
13:43:42 <newsham> hrm... Network.Http.Request is instance Show but not Read :(
13:43:56 <newsham> is there a lib that does parsing?
13:45:24 <Wild_Cat> nathanic: the strange thing is that trailing commas are allowed in lots of places (imports, module declarations...), just not in lists.
13:45:40 <greendemon> ok, thanks for the help
13:45:46 <RayNbow> greendemon: you could define a generic foldTree function for Data.Tree
13:45:46 <sjanssen> newsham: is the Show instance a standard instance, or is it a custom made pretty printer?
13:46:01 <newsham> Show is for serialization according to the docs
13:46:09 <greendemon> RayNbow: I think I will :)
13:46:10 <newsham> but no comparable deserialize that i can see
13:46:57 <greendemon> or at least a filterTree
13:47:57 <Saizan_> newsham: if the constructors are exported you can use standalone deriving
13:48:05 <_rkl_> newsh.
13:48:08 <newsham> hi rkl.
13:48:21 <newsham> saizan: so if i write a nontrivial parser all my problems will be solved.
13:48:24 <newsham> horray for libraries
13:48:54 <sjanssen> newsham: that is not what Saizan_ said
13:49:02 <Saizan_> nathanic: standalone deriving is a GHC extension
13:49:15 <sjanssen> however, you can't use standalone deriving anyway, because the Show instance isn't derived
13:49:16 <Saizan_> err, newsham
13:50:34 * sjanssen wants to start a campaign against custom Show instances
13:50:59 <SamB_XP> sjanssen: ADTs (where A stands for Abstract) need them
13:51:22 <sjanssen> SamB_XP: I suppose that is true
13:51:41 <newsham> sjanssen: ahh, i misunderstood what he was saying
13:51:46 <newsham> but yah, i dont think it helps
13:52:33 <sjanssen> SamB_XP: but in most cases, it isn't an issue of abstraction
13:52:50 <SamB_XP> sjanssen: true enough
13:53:08 <Saizan_> i want serialization of functions
13:53:21 <SamB_XP> now THAT is ;-P
13:53:31 <Saizan_> and a pony!
13:54:03 <newsham> instance Binary, instance Serializable ?
13:54:19 <newsham> but anyway.. anyone know of an http lib that will parse http msgs?
13:55:43 <SamB_XP> newsham: isn't that one of the main functions of most HTTP libs?
13:56:06 <newsham> samb: i would have assumed.. but the ones on hackage.. not seeing it.. :(
13:56:08 <SamB_XP> newsham: do you know one that won't?
13:56:13 <SamB_XP> oh really?
13:56:31 <newsham> maybe i'm being dense?
13:56:32 <dafra> @where trie
13:56:33 <lambdabot> I know nothing about trie.
13:56:35 <SamB_XP> I don't remember the name of the one I've used before ...
13:56:41 <newsham> obviously they have to parse responses to give results
13:56:45 <SamB_XP> possibly Network.HTTP ?
13:57:13 <dafra> does anyone know a trie implementation ?
13:57:21 <newsham> thats what i'm looking at.
13:57:26 <newsham> i'll pull src and see if i cant find more info
13:57:32 <newsham> the haddocks dont seem to show any parsing funcs
13:58:31 <Saizan_> dafra: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore <-- there's a TernaryTrie module here
13:58:34 <lambdabot> Title: HackageDB: EdisonCore-1.2.1.2, http://tinyurl.com/3bnhme
13:58:47 <stepcut> isn't there a GSoC trie project ?
13:58:48 <Saizan_> dafra: also Data.IntSet is implemented with a trie, iitc
13:59:25 <dons> a patricia tree, which is a kind of sneaky bit trie
13:59:30 <dafra> Saizan_: thanks
13:59:37 <dons> the int keys end up as bits in the trie path
13:59:41 <newsham> parseRequestHead
13:59:43 <newsham> not exported :\
14:01:09 <kowey> so... I had somebody in #darcs just now who couldn't build darcs because "Fedora ghc (or ghc in general) seems to be b0rk3d on PPC64"
14:01:21 <kowey> is there any advice I can give him?
14:01:56 <kowey> the issue is something about it being a registerised GHC (/me has no idea what that means)
14:02:30 <kowey> and he says that the only packages which are available are ghc 6.8.2
14:02:50 <CosmicRay> before I reinvent the wheel...  is there an implementation of read that returns Maybe or Either instead of throwing an exception when there is an error parsing?
14:03:17 <Saizan> CosmicRay: not in the standard libraries
14:03:28 <Igloo> There is reads
14:03:32 <CosmicRay> Saizan: right.  but this seems like a common enough requirement
14:03:42 <Deewiant> mread is coming, I believe
14:03:49 <Igloo> I hate to think how you'd reinvent the wheel without it
14:04:03 <CosmicRay> Igloo: right, which is what I'd use to reinvent the wheel
14:04:12 <Saizan> yeah, readM xs = case reads xs of [(x,rest)] | all isSpace rest -> Just x; _ -> Nothing
14:04:31 <Igloo> OK, "instead of throwing an exception" made me think you didn't know about it
14:05:08 <CosmicRay> Igloo: I even think that I wrote such a thing once.  I just have this aversion to writing code, however small, if there's an existing, tested piece of code that does what I want
14:06:53 <dons> CosmicRay: there's a well known maybeRead
14:07:02 <dons> e.g. a non-toy read :)
14:07:22 <dons> this guy, http://www.haskell.org/pipermail/libraries/2008-February/009213.html
14:07:24 <lambdabot> Title: Proposal: Add Text.Read.maybeRead :: Read a => String -> Maybe a, http://tinyurl.com/6yeemn
14:09:01 * kowey tries rephrasing
14:09:15 <kowey> does anybody have GHC working on PPC64? (err Linux)
14:09:57 <CosmicRay> dons: exactly what I'm after.  Thanks.
14:10:45 <Saizan> i'm not sure how the fail version really helps, are we supposed to parse the error string to find the cause?
14:11:15 <dons> Saizan: you're not supposed to manipulate the error msg, no.
14:18:43 <BMeph> LordMetroid: Shouldn't you be "LadyMetroid"? :)
14:19:07 <LordMetroid> Why would I want to change my name?
14:19:19 <LordMetroid> Seriously, this is my name
14:23:05 <Botje> you wouldn't happen to play ETQW as well, would you?
14:58:28 <dcoutts> @tell gwern found and fixed the cause of the redefinition warnings with Cabal HEAD
14:58:28 <lambdabot> Consider it noted.
15:07:03 <jekor> Does anyone know how to spawn a Network.FastCGI binary as an unpriviledged user? I've tried spawn-fcgi and get an "Permission Denied" error if I try to use -u nobody (or any -u for that matter), but it works if I run it as root.
15:22:06 <ddarius> mmorrow: It took you two hours to write that?
15:23:03 <chrisdone> jekor: perhaps -u www-root
15:23:25 <mmorrow> ddarius: i already had most of it written, but it took me two hours of staring/rearranging/realizing how to organize it
15:24:52 <jekor> grep www /etc/passwd
15:24:52 <jekor> lighttpd:x:107:1010:added by portage for lighttpd:/var/www/localhost/htdocs:/sbin/nologin
15:25:16 <jekor> I tried as lighttpd, but that didn't work as well. This may be a Linux thing.
15:26:52 <jekor> If I chpst -u whatever program.fcgi, it also fails. But if I try to run it as the user whatever, it succeeds. It's very strange.
15:31:28 <jekor> It just seemed like maybe something strang was going on with linking or somesuch. I've never seen anything like this, but the binary seems perfectly fine.
15:32:29 <jekor> OK, I think I found the problem.
15:33:07 <jekor> Apparently user nobody is allowed to execute binaries only from certain directories? At least, moving it into /usr/bin fixed the problem.
15:33:08 <jekor> Thanks.
15:34:09 <dmhouse> jekor: no problem.
15:37:19 <jekor> dmhouse: :P
15:41:01 <luite> is there a standard function like nub, that removes duplicates from a sorted list?
15:41:28 <luite> nub obviously does that, but is not very efficient :)
15:41:32 <int-e> map head . group
15:41:46 <int-e> (no. but it's fairly simple to imlement)
15:42:07 <luite> ah, sounds good
15:54:43 <mmorrow> * sjanssen wants to start a campaign against custom Show instances
15:54:55 <mmorrow> me too! they screw everything up! :)
15:55:18 <saml> yah let's go for overloading toString method like Java
15:56:02 <saml> how would you do it without custom Show instance?
15:56:14 <mmorrow> make a new class or something?
15:56:32 <saml> Show is already a class, why make new one?
15:57:39 <ddarius> We already have a new class.  It is called Binary.
15:57:46 <ddarius> (Probably not the direction you were thinking.)
15:57:53 <mmorrow> the most recent annoyance re: custom show instances is with language-c. so, /if the Show instance doesn't produce valid haskell syntax, then you can get prettyprinting for free by (putStrLn . prettyPrint . fromRight . parseHsExp . show)/
15:58:13 <gwern> @tell dcoutts ack. gcc error fixed. however, I still see these macro redefinition errors. I see them when compiling lambdabot, but not xmonad, for example. I believe they are related to the Lambdabot_paths module
15:58:13 <lambdabot> Consider it noted.
15:58:43 <mmorrow> that's my "beef" with them :)
15:59:43 <dcoutts> gwern: I found it, but I've not pushed the fix.
15:59:44 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
15:59:44 <ddarius> mmorrow: That's a crappy beef
15:59:57 <mmorrow> read also won't work with such instances
16:00:09 <dcoutts> gwern: the problem was package names containing '-'
16:00:14 <mmorrow> which is an even bigger beef i guess
16:00:23 <gwern> dcoutts: what, like lambdabot-utils?
16:00:24 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:00:31 <mmorrow> it's like an entire cow, actually
16:00:49 <gwern> @messages
16:00:50 <lambdabot> dmhouse asked 2d 3h 37m 30s ago: why listArray is considered unsafe
16:00:50 <lambdabot> dcoutts said 1h 2m 21s ago: found and fixed the cause of the redefinition warnings with Cabal HEAD
16:00:56 <dcoutts> gwern: right, we were generating cpp macros with names using '-' too, now map them to _ so it's all good
16:01:24 <ddarius> You can easily define Read/Show instances that work fine together but don't produce valid Haskell syntax.
16:01:27 <dmhouse> gwern: this is the first you've spoken in #haskell in two days?
16:01:51 <gwern> dmhouse: so it seems!
16:02:19 <gwern> dmhouse: what's listarray and why do you think it is safe?
16:02:36 <rwbarton_> > "Array"
16:02:37 <lambdabot>   mueval: Unsafe functions to use mentioned.
16:02:47 <gwern> hm
16:03:12 <dmhouse> ?hoogle listArray
16:03:13 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:03:13 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:03:13 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
16:03:19 <dmhouse> This is where it originally came up
16:03:35 <gwern> > "array"
16:03:38 <lambdabot>   "array"
16:04:02 <rwbarton_> listArray r es  is just  array r (zip (range r) es)
16:04:06 <dmhouse> Prelude Data.Array.IArray Data.Array> Data.Array.listArray (1,10) ['a'..]
16:04:06 <dmhouse> array (1,10) [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g'),(8,'h'),(9,'i'),(10,'j')]
16:04:21 * gwern wonders why darcs.haskell.org is so very very slow tonight
16:04:33 <gwern> ah, Context bans "Array"
16:05:02 <gwern> wait, I import Data.Array by defailt, so why is it on the blacklist...
16:05:03 <dons> current use appears ok, gwern.
16:05:49 <mmorrow> ddarius: you can. but then you can't use any of the tools for manipulating haskell expressions with such shown strings and then read them back in. so i guess /this/ is a clearer way to state my problem with them. since you're writing the Show/Read instances by hand in this case anyway, it would be just as easy to use MyShow/MyRead. then proper Show/Read instances could be autoderived. also, once Show/Read are written, they can't be
16:05:50 <mmorrow> redefined without zapping the offending code since you can't override instances (unless i'm just not aware of how?).
16:05:58 * gwern shrugs and removes it from the blacklist
16:06:09 <Igloo> dons: total B/W use is low, yes, but connections are still slow
16:06:16 <mmorrow> eg, package.conf is a valid haskell expression.
16:06:20 <dons> Igloo: hmm
16:06:36 <dons> time for mirrors.
16:06:41 <Igloo> dons: Like nominolo said, the peaks don't seem to actually be related to the problem
16:06:59 <mmorrow> so i can   cat package.conf | hstidy -e   or s/hstidy -e/anything that parses haskell expressions and does something with the AST/
16:07:07 <dons> well, some of them seem to match 'can't load at all' times.
16:07:09 <ddarius> mmorrow: The problem is Show is overloaded.
16:07:11 <gwern> all I know is that a darcs pull of cabal-install has been stuck on 'identifying' for a good 20 minutes
16:07:35 <dcoutts> gwern: darcs.h.o is having some serious network problems
16:07:36 <dons> load is fine.
16:07:52 <gwern> dcoutts: no kidding
16:08:37 <mmorrow> ddarius: i don't understand what you mean by that. the added "inconvenience" of  pprint' = putStrLn . myshow?
16:08:49 <mmorrow> err, s/pprint'/print'/
16:09:32 <ddarius> mmorrow: That's one case.  Another more inconvenient one is the use of the REPL, an extension of that one is print listOfMyThings, etc.
16:10:00 <ddarius> Show should be split into several classes with different uses intended.
16:10:25 <ddarius> If you want a class that produces (and consumes) Haskell expressions, call it AsHaskell or something.
16:10:40 <ddarius> If you want a class for textual serialization use another class.
16:10:58 <ddarius> If you want a class for display for human consumption, use another class.
16:11:07 <ddarius> Right now Show does all of that and arguably then some.
16:12:20 <mmorrow> ddarius: yes. that's the root of what i'm getting at i guess. having a way that's guaranteed to produce a String which is a valid haskell expression represented that datum would be ideal. then another class for prettyprinting.
16:12:56 <mmorrow> currently Show is trying to do both at once, but in any one instance only one of these can be accomodated
16:13:04 <gwern> @tell Cale if people kvetch to you about array stuff not working, get latest mueval from darcs
16:13:04 <lambdabot> Consider it noted.
16:15:45 <mmorrow> ddarius: luckily derive can derive Show. hmm, maybe i'll add a small mod that s/Show/Show'/ these.... excellent, that's actually a workable temp solution.
16:19:21 <newsham> haskell needs an http library
16:19:40 <dons> another one?
16:19:41 <chrisdone> haskell needs more http libraries?
16:19:55 <newsham> we can stop when we get one that works.
16:20:08 <chrisdone> libcurl not good enough?
16:20:12 <dons> newsham: would you be able to write one?
16:20:21 <dons> a pure haskell, bytestring one wouldn't be *too* hard, I think.
16:20:24 <newsham> something thats suitable as a building block for both clients and servers and proxies
16:20:29 <dons> and nano-http libs used to be the main thing.
16:20:32 <nha_> is hackage broken
16:20:34 <newsham> dons: if i had two weeks of free time i could.
16:20:36 <dons> newsham: you've surveyed the available ones on hackage?
16:20:37 <newsham> but i dont :(
16:20:39 <dons> nha_: how so?
16:20:52 <dons> nha_: works for me.
16:20:53 <newsham> i looked over Network.HTTP which seems to be the main haskell one
16:20:53 <nha_> connections are hanging
16:20:57 <nha_> only on the packages though
16:20:58 <dons> nha_: hmm
16:21:00 <nha_> the main listing works fine
16:21:08 <Igloo> It's probably cached somewhere
16:21:20 <newsham> it doesnt provide exposed functions for unmarshalling.
16:21:46 <newsham> its more of a http-request library
16:21:55 <newsham> and not suitable for tihngs like proxies or http testing
16:23:02 <Saizan> i think we can extract one from the various webservers
16:23:51 <newsham> yah, there's various progs which have their own parser, like HWS
16:24:01 <newsham> and HAppS
16:25:23 <Saizan> tibbe was/is working on one with an incremental parser for his webserver, iirc
16:26:12 <dons> nha_: yep, the admins are on it. some network components not quite handling the load
16:26:24 <nha_> ok cool
16:26:41 <dons> its a good time to think about setting up the chalmers server as a mirror
17:03:17 <newsham> I'm trying to install hdbc-odbc and it is failing to compile because it cant find <sql.h> and <sqlext.h>.  I'm guessing there's some C library prereq, but not sure which and not too familiar with this odbc stuff.. anyone know what i need?
17:03:32 <newsham> (this is for mysql, btw.. i imagine i also need the mysql-odbc connector?)
17:03:46 <newsham> ahh.. I htink "unixODBC" ?
17:11:36 <dons> some of the mathy guys might be interested in the next galois tech talk, http://www.galois.com/blog/2008/09/03/pretty-printing-a-really-long-formula-or-what-a-mathematician-could-learn-from-haskell/
17:11:38 <lambdabot> Title: Galois › Blog › Blog » Pretty-Printing a Really Long Formula (or, “What a ..., http://tinyurl.com/5tg6mg
17:13:33 <newsham> does galois put tech talks online?
17:14:33 <dons> newsham: currently slides and abstracts, hopefully video soon
17:15:37 <dons> since there's some freakin' good tech talks. :) (audreyt, spj, hutton, pierce)
17:15:59 <newsham> i would expect no less from galois :)
17:16:38 <dons> so yeah, a lot of quality FP and formal methods speakers.
17:17:14 <tibbe> Saizan: I am/was
17:24:52 <dons> see also last week's talk, http://www.reddit.com/r/programming/comments/6zipn/programming_gpus_with_data_parallel_haskell_slides/
17:24:55 <lambdabot> Title: Programming GPUs with Data Parallel Haskell :: Slides : programming, http://tinyurl.com/6g7djy
17:25:19 <chrisdone> @hoogle (a -> m b) -> (b -> m c) -> m c
17:25:20 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:25:20 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
17:25:20 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
17:25:25 <chrisdone> oh yeah
17:27:31 <gwern> @tell Cale good news everyone! we just got a delivery contract to Regulus Prime... er, Data.Map.map (+1) $ Data.Map.fromList [(1,2), (3,4)]
17:27:31 <lambdabot> Consider it noted.
17:27:46 <Cale> huh?
17:27:46 <gwern> @tell Cale ignore that last. I meant to say, Hint just got qualified imports. I may have it in mueval by friday
17:27:47 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:27:47 <lambdabot> Consider it noted.
17:27:56 * gwern occasionally despises copy-paste
17:28:04 <newsham> anyone have examples of accessing mysql using hdbc?
17:28:24 <chrisdone> I didn't know there was a mysql driver for hdbc
17:29:08 <newsham> through odbc.
17:30:46 * gwern feels cheerful. if qualified imports are fixed, that's the last of the mueval bugs and problems is it not?
17:31:58 <gwern> (that news almost makes up for finding out that some of my personal information has been stolen by identity thieves)
17:32:09 * gwern decides to call today a wash
17:32:18 <newsham> wow..  really?  yours?!   ;-)
17:33:09 <newsham> (sorry to hear)
17:38:01 <TomMD> Hummm. I just got a double free error with a program compiled by ghc-6.8.2.  Should I test with head?
17:38:48 <SamB_XP> double free error?
17:38:58 <SamB_XP> that sounds like a ... C ... thing ... don'tcha think?
17:39:06 <TomMD> in 'C' thats:
17:39:06 <TomMD> x = malloc(500);
17:39:06 <TomMD> free(x);
17:39:06 <TomMD> free(x);
17:39:09 <TomMD> yes.
17:39:15 <TomMD> sorry, thought you were actually asking.
17:39:31 <SamB_XP> ... so why would changing *Haskell* compilers help?
17:39:47 <TomMD> But... there is no FFI that I am using so I figured the RTS might be to blame.
17:39:59 <TomMD> ... checking my bytestring library...
17:41:36 <TomMD> It happens "+RTS -NX - RTS" when X > 3 it seems.
17:41:47 <SamB_XP> huh
17:41:53 <dons> interesting.
17:41:57 <SamB_XP> wow
17:41:58 <dons> two threads hitting the same finaliser?
17:42:04 <SamB_XP> I didn't even have to say his name!
17:42:14 <dons> MVars needed on all finalisers
17:42:34 <dons> TomMD: coming to ICFP?
17:42:45 <SamB_XP> maybe the RTS *is* to blame?
17:42:56 <Igloo> TomMD: Can you try linking with -debug?
17:43:06 <TomMD> dons: Grrrr no.  I have too much training and too little time.  I am rather irritated that I miss it for a second year of really wanting to go.
17:43:09 <SamB_XP> though not in the obvious way
17:43:19 <Igloo> TomMD: And if it still happens, try running it in gdb
17:43:43 <TomMD> Igloo: Will do, but I am starting to think I have a bad compiler
17:43:43 <TomMD> Igloo: running with +RTS -N3 -RTS had 4 good runs then a SIGSEGV
17:44:15 <SamB_XP> TomMD: what makes you think it might be fixed in teh head? simon cat?
17:45:04 <TomMD> SamB_XP: For me its just a habbit before reporting bugs of trying the most recent copy of the software first (if I have time).
17:45:16 <SamB_XP> TomMD: I doubt you have time ;-P
17:45:53 * SamB_XP attempts to convey by body language that he thinks GHC's build system needs work
17:45:55 <TomMD> SamB_XP: If darcs can pull one night and it can compiler another... well, then I can spare an evening to try the result.
17:46:39 <TomMD> Igloo: Haven't been able to crash it yet when compiled with -debug (trying with -N4)
17:46:50 <TomMD> Does that mean anything?
17:47:05 <TomMD> err, scratch all that.
17:47:13 <Igloo> It means that you can't get gdb to tell you what the problem is  :-)
17:47:20 <Pseudonym> SamB_XP: Is not fixed in teh HEAD.
17:47:38 <Pseudonym> teh bild sistm
17:47:54 <dons> Pseudonym: we got "lolmagnets" at work this week specifically so we can make bug reports to each other in that form.
17:48:11 <SamB_XP> dons: lol
17:48:32 * SamB_XP is a bit punchy tonight
17:48:43 <dons> lolmagnetz i should say
17:49:06 <Igloo> I'd ask what a lolmagnet is, but I'm too scared of what the answer might be
17:49:20 <dons> magnets with words that give you lolz
17:49:22 <SamB_XP> Igloo: he just said
17:49:31 <Pseudonym> http://icanhascheezburger.files.wordpress.com/2008/08/funny-pictures-cat-fixes-your-lols-for-you.jpg
17:49:33 <lambdabot> http://tinyurl.com/6nfg9h
17:49:34 <Igloo> Oh, fridge poetry things?
17:49:36 <SamB_XP> "fixed" "teh" "head"
17:49:45 <SamB_XP> "has"
17:49:46 <dons> yeah. but with lolcat words and spelling :)
17:49:53 <SamB_XP> "cheeseburger"
17:50:00 <SamB_XP> "u"
17:50:18 <dons> i should take a photo: haskell + programming + lolcats + reddit. == perfect storm
17:51:20 <SamB_XP> "needz"
17:51:21 <SamB_XP> "plz"
17:51:27 <SamB_XP> "ur"
17:51:31 <SamB_XP> "hai"
17:51:47 <SamB_XP> "trapd"
17:51:58 <SamB_XP> "doggeh"
17:52:01 <SamB_XP> "kitteh"
17:52:14 <SamB_XP> "o noes"
17:52:24 <TomMD> igloo: internal error: RELEASE_LOCK: I do not own this lock: Task.c 269
17:52:28 <TomMD> I got a nice error that time.
17:52:48 <Pseudonym> Sounds like your compiler and/or libraries are seriously fscked.
17:52:48 <SamB_XP> "sez"
17:52:59 <SamB_XP> "problim"
17:53:05 <SamB_XP> "wuz"
17:53:29 <SamB_XP> btw, http://arcanux.org/lambdacats_2.html#entry10
17:53:29 <Pseudonym> Or, I guess, you could have some bad memory.
17:53:30 <lambdabot> Title: Lambdacats
17:53:56 <TomMD> Pseudonym: Possible, but I find that unlikely.  New laptop and passed memtest just a couple months ago.
17:54:02 * Pseudonym nods
17:54:05 <SamB_XP> TomMD: run it again
17:54:05 <Pseudonym> Just a thought.
17:54:20 <SamB_XP> just, you know, in case
17:54:34 <SamB_XP> it will save a lot of headscratching if your memory fails, yes?
17:55:09 <Olathe> hai u needz ur cheeseburger o noes trapd kitteh sez problim wuz doggeh
17:55:11 <Igloo> TomMD: OK, can you file a ticket please? It sounds like there's more going on that just a double-free, which would probably have been easy to fix
17:55:52 <Pseudonym> Someone should grab all the captions off icanhascheezburger and put them in a Markov chain generator.
17:56:02 <TomMD> Igloo: Will do.
17:58:52 <SamB_XP> Pseudonym: well, the first part is probably the part requiring more effort
17:58:59 <SamB_XP> isn't it?
17:59:35 <Pseudonym> I would think so, yes.
17:59:43 <Pseudonym> The captions are stored in text form, at least on recent ones.
17:59:51 <Pseudonym> For easy searching purposes.
18:00:21 <SamB_XP> oh, that's nice
18:01:04 <Pseudonym> BRB
18:01:09 <SamB_XP> "kthxbai"
18:01:21 <SamB_XP> one of the magnets would say "kthxbai"
18:02:01 <SamB_XP> dons: so are you also getting a collection of wacky cat magnets ?
18:02:33 <SamB_XP> dons: and does your magets collection include \ and -> ?
18:03:37 <Pseudonym> Hmm.
18:03:40 <newsham> hah, i have to install QT to build the mysql-odbc connector.
18:03:51 <newsham> how high can you pile it :)
18:04:16 <newsham> someone could in theory write a direct MySQL connector for HDBC, right?
18:04:31 <SamB_XP> newsham: well, it isn't turtles all the way down
18:04:31 <Pseudonym> OK, fixed.
18:04:44 <SamB_XP> Pseudonym: fixed what?
18:04:58 <SamB_XP> you made the markov generator thing?
18:05:14 <Pseudonym> No, I stopped my IRC client from consuming all of memory.
18:05:18 <Pseudonym> Which is far mroe important./
18:05:24 <Pseudonym> stil karnt tipe tho
18:05:36 <SamB_XP> ah, yes, that IS more important
18:05:50 <SamB_XP> for when it does *that*, it probably dies soon after, no?
18:06:03 <SamB_XP> and then where would your scrollback be?
18:06:30 <Pseudonym> Exactly.
18:08:20 <chrisdone> Pseudonym: there's already a Data.MarkovChain library on hackage ;)
18:09:31 <Pseudonym> Oh, I've got markov chain code sitting around.
18:09:52 <Pseudonym> http://andrew.bromage.org/darcs/dynamicmarkov/
18:10:16 <Pseudonym> Erm.
18:10:26 <Pseudonym> OK, web server started now.
18:10:36 <paczesiowa> how am I supposed to install yi-gtk with yi>=0.4?
18:14:01 <rwbarton_> paczesiowa: IIRC you're not, yi-gtk merged into yi in version 0.4 or something
18:15:13 <paczesiowa> so why there is no gtk dep in yi?
18:16:12 <rwbarton_> maybe because gtk isn't cabalified/on hackage, i.e., it's an untracked dependency?  (just guessing)
18:16:28 <paczesiowa> that would make sense
18:16:54 <paczesiowa> oh, there are flags for cabal packages
18:17:10 <paczesiowa> there should be advertised on hackage
18:17:20 <paczesiowa> *they
18:19:26 <paczesiowa> cabal seems a lot like gentoo portage
18:19:48 <paczesiowa> but faster
18:19:48 <dcoutts> paczesiowa: well, they're both source based package managers I guess
18:19:52 <dcoutts> heh heh
18:20:00 <dcoutts> that's because it's written in a decent language ;-)
18:21:18 <paczesiowa> dcoutts: just curious, can cabal package depend on other package and require that package to have some flag set? because that is the moste retarded thing in portage that makes me furious
18:21:45 <dcoutts> paczesiowa: no, they cannot. packages are expected to export the same api regardless
18:21:52 <dcoutts> it's by design
18:22:25 <dcoutts> if you need it exposing different things, like different backends then those should be separate packages
18:22:57 <paczesiowa> makes sense. so why yi got merged together?
18:25:51 <paczesiowa> dcoutts: would cabal still be faster if pollluted with 20k packages?
18:26:33 <dcoutts> paczesiowa: we've not looked much at optimisation, I'm sure it could be a lot faster than it is now
18:27:18 <paczesiowa> it is fast enough, but I was wondering if it isn't because there are very little packages on hackage
18:32:30 <jeeves__> So, I have here a C-wrapping module that uses preprocessor-like directives such as #def{ ... C code} and #let ...
18:32:43 <jeeves__> Are those part of c2hs? I can't find them in the documentation
18:36:14 <mulletron> does anyone know of a music (id3, flac etc) tag reading library that has haskell bindings?
18:39:13 <dons> paczesiowa: i wonder, at the current rates, when we'll have 20k packages.
18:39:24 <mornfall> It'll take a loooong time.
18:39:32 <dons> mulletron: check on hackage, if you don't see one, chance to write a new lib.
18:39:45 <dmwit> \o/
18:39:47 <dons> mornfall: i guess so. 1k in 1.5 years, roughly.
18:40:00 <dons> so we'd be talking about say, 10 years, assuming things get faster.
18:40:05 <dmwit> My first hackage package!
18:40:35 <mornfall> Oh. gtk2hs is not on hackage? How come?
18:40:50 <dmwit> They're working on cabalizing it, still.
18:41:19 <mornfall> Even CPAN didn't yet reach 15k.
18:41:20 <mulletron> dons: heh - good point :p
18:41:34 <dcoutts> dmead: heh, still, yep, it's been a while
18:41:34 <mornfall> (14269 seems to be the current number.)
18:41:37 <dcoutts> oops
18:41:47 <dcoutts> dmwit: I mean, silly tab completion
18:42:02 <mulletron> a couple claim to do it, eg hpodder claims to read id3 tags
18:42:09 <dmwit> dcoutts: Changing build systems can be hard work.
18:42:40 <dmwit> dcoutts: Are you guys sponsored/funded?
18:42:49 <dcoutts> dmwit: yes and it's reliant on new features in cabal.
18:43:00 <dcoutts> dmwit: sponsored? what for cabal hacking?
18:43:11 <dcoutts> dmwit: Saizan_ was funded to do a GSoC project
18:43:22 <dmwit> oh?
18:43:32 <dmwit> Was it to cabalize Gtk2Hs? =P
18:43:35 <dcoutts> so it's getting closer, with Saizan_'s code we were able to build cairo, which is one of the gtk2hs components
18:43:58 <dcoutts> dmwit: no, a dependency framework for Cabal, which is the major missing plank in Cabal
18:44:09 <dmwit> I look forward to the day when Gtk2Hs splinters into several separate projects, actually.
18:44:15 <dcoutts> and needed to support complex pre-processors properly, pre-processors like c2hs
18:44:19 <dcoutts> which gtk2hs uses heavily
18:44:20 <dmwit> ah
18:44:32 <dcoutts> we've got test code with that working
18:44:50 <dcoutts> it may take a little while to get into a real Cabal release
18:45:20 <chrisdone> cabal: bsAuthGen wanted
18:45:20 <dcoutts> but after that there's still at lot to do in gtk2hs, mainly in getting rid of our c2hs fork and using the mainline one
18:45:21 <paczesiowa> it will still be a pita on windows to install gtk2hs, right?
18:45:21 <chrisdone> is this a program?
18:45:57 <dcoutts> chrisdone: sounds like a http authentication error that has not been handled very gracefully
18:46:16 <dcoutts> paczesiowa: is it a pita now? I thought the installers were ok
18:46:20 <chrisdone> dcoutts: ah, okay. I'll check my details by trying the hackage site
18:46:48 <dcoutts> chrisdone: can you file a ticket explaining how to get that behaviour, that'd be great
18:47:06 <dcoutts> chrisdone: it sounds like bad error handling in cabal's use of the HTTP lib
18:47:11 <dcoutts> which we should fix
18:47:17 <paczesiowa> dcoutts: installers are ok. installing through cabal will require to install gtk
18:47:35 <chrisdone> dcoutts: okay let me check
18:48:27 <chrisdone> dcoutts: ah, simply entering the wrong password. I'll file a ticket
18:48:29 <dcoutts> chrisdone: were you doing an update/download or something? I'm guessing it's a http proxy that needs authentication
18:48:37 <chrisdone> dcoutts: uploading a package with hackage
18:48:37 <dcoutts> chrisdone: ohh, hmm. ok.
18:49:17 <dcoutts> chrisdone: thanks, that'll help us not to forget
18:49:58 <chrisdone> no problemo
18:51:00 <hackage> Uploaded to hackage: lojban 0.0
18:51:00 <hackage> Uploaded to hackage: yeganesh 1.1
18:51:27 <dons> nice
18:52:47 <vininim> oh, I tried learning lojban once.
18:53:23 <dcoutts> dons: heh, one annoyed darcs.h.o user there ('Kili' on ghc-cvs list) might be worth posting that the problem was diagnosed and fixed
18:54:35 <dcoutts> g'night folks
18:54:57 <chrisdone> dcoutts: is this ok? http://hackage.haskell.org/trac/hackage/ticket/348
18:54:59 <lambdabot> Title: #348 (Wrong login details for `cabal upload' is not handled gracefully) - Hackag ...
18:54:59 <chrisdone> dcoutts: ah, night
18:56:44 <chrisdone> if I want to try fixing this, I should try HEAD and if it's still there fix it in HEAD, right? you don't maintain old versions..
18:57:42 * chrisdone not very experienced with open source contribution
18:57:45 <dcoutts> chrisdone: it's not fixed I'm sure. If you look in the source of the HTTP lib you'll find the default bsAuthorityGen     = (error "bsAuthGen wanted")
18:58:08 <dcoutts> chrisdone: so yeah, grab Cabal HEAD and cabal-install HEAD
18:58:12 <chrisdone> dcoutts: right, I saw that
18:58:14 <chrisdone> dcoutts: right-o
18:58:35 <dcoutts> chrisdone: and in Distribution.Client.Upload use setAuthorityGen
18:59:00 <chrisdone> ok
18:59:10 <dcoutts> chrisdone: probably the right generator would be to print something saying that the details were incorrect
18:59:57 <dcoutts> and return Nothing, or if you like call the promptUsername/Password again
18:59:58 <chrisdone> dcoutts: indeed
19:00:09 <dcoutts> which would want to be factored out
19:00:21 <chrisdone> dcoutts: that seems logical to me
19:00:38 <dcoutts> chrisdone: have fun
19:00:41 <chrisdone> ;)
19:00:41 * dcoutts really goes to bed
19:01:24 <dcoutts> chrisdone: btw, could do worse than to send a patch to the HTTP maintainer setting the default to return Nothing rather than error
19:02:43 <chrisdone> dcoutts: yessir
19:07:37 <paczesiowa> damn, gtk frontend for yi doesn't work:/ exception :: System.Glib.GError.GError
19:08:10 <chrisdone> GUI for code editor = lolwut?
19:08:55 <paczesiowa> you get nice scrollbars
19:09:25 <paczesiowa> well, as nice as gtk is inside qt env
19:10:02 <mulletron> is there a more sane way of doing c++ bindings than http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell ?
19:10:05 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
19:11:11 <Cale> mulletron: Make C bindings to the C++ library first?
19:11:32 <paczesiowa> there are qt bindings, but developer didn't release any script that made those. maybe ask him to in an email
19:12:08 <mulletron> thanks guys - I'll have a look into it
19:18:31 <chrisdone> wow I've never seen this syntax for a top level defintion
19:18:37 <chrisdone> Just foo = someMaybeThing
19:18:44 <chrisdone> is that an extension/
19:19:13 <chrisdone> @let Just foo = Just 1
19:19:14 <chrisdone> > foo
19:19:17 <lambdabot>  Defined.
19:19:18 <lambdabot>   mueval: Prelude.read: no parse
19:19:27 <chrisdone> bo selecta
19:20:10 <Olathe> > 5
19:20:13 <lambdabot>   5
19:20:32 <chrisdone> yeah it says no parse for, uh, errors not about parsing, I think
19:21:27 <rwbarton_> Almost all errors, with some exceptions which are ironically in fact parse errors.
19:21:30 <rwbarton_> > )
19:21:33 <lambdabot>   mueval: Prelude.read: no parse
19:21:39 <rwbarton_> Oh, that's new maybe.
19:22:00 <thetallguy> chrisdone: what's a lojban?
19:22:27 <chrisdone> thetallguy: it's a constructed spoken language. see wikipedia://lojban
19:22:54 <thetallguy> chrisdone: could you please add that to the description field in your Cabal file and reupload?
19:22:57 <Olathe> scanl1 is neat
19:23:21 <chrisdone> thetallguy: sure
19:23:33 <Olathe> I wonder if there's a scanl1 $ map function.
19:23:38 <jeeves__> anyone knowledgeable about FFI to C around?
19:23:48 <Olathe> @type scanl1
19:23:50 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
19:24:34 <thetallguy> chrisdone: I'm both interested in what lojban is and in seeing better cabal descriptions so I don't have to scrounge around the net to find out what the new hackage packages are all about.
19:24:42 <Olathe> > scanl1 (\a b -> a + b^2) [0..10]
19:24:46 <lambdabot>   [0,1,5,14,30,55,91,140,204,285,385]
19:25:36 <Olathe> @pl \xs -> (\a b -> scanlf (a (mapf b))) xs
19:25:37 <lambdabot> (scanlf .) . (. mapf)
19:26:05 <Olathe> @pl scanlf (. (. mapf))
19:26:05 <lambdabot> scanlf (. (. mapf))
19:26:50 <Olathe> @pl scanl1 (((+).).(.(^2))) [1..10]
19:26:51 <lambdabot> scanl1 (((+) .) . (. (^ 2))) [1..10]
19:26:55 <Olathe> > scanl1 (((+).).(.(^2))) [1..10]
19:26:58 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> c
19:26:58 <lambdabot>        Exp...
19:27:34 <Olathe> @pl (\a b -> scanlf (a (mapf b)))
19:27:35 <lambdabot> (scanlf .) . (. mapf)
19:28:31 <Olathe> > let scanMap sf mf = scanl1 ((sf.).(.mf)) in scanMap (+) (^2) [0..10]
19:28:34 <lambdabot>       Occurs check: cannot construct the infinite type: c = c -> c
19:28:34 <lambdabot>      Proba...
19:28:37 <Olathe> Bah.
19:30:27 <Olathe> > let scanMap sf mf = scanl1 ((.mf).sf) in scanMap (+) (^2) [0..10]
19:30:30 <lambdabot>   [0,1,5,14,30,55,91,140,204,285,385]
19:32:49 <dons> "Emacs needs to compete or die - and the competition is the browser."
19:33:14 <lament> i don't think emacs needs to compete :)
19:33:18 <dons> or, firefox is turning into emacs
19:33:34 <dons> everything turns into a scriptable glue of components with a gui
19:34:42 <chrisdone> haha, yeah. oh suddenly I'm going to start writing code in firefox
19:35:43 <Olathe> Stop coding in Haskell. Use Javascript.
19:35:53 <dons> everything's a web app now. hmm, maybe i should turn xmonad into a browser plugin
19:37:26 * araujo should really get into writing that haskell browser soon
19:37:42 <chrisdone> araujo: me too
19:38:22 <araujo> chrisdone, been with that idea for a while .... chrome stole my idea for the engine though
19:38:24 <araujo> :-P
19:40:19 <ddarius_> Bah.  I'd say a web-based browser would be next, but someone made one of those a while ago.
19:40:40 <chrisdone> araujo: personally I want a browser that just reads JSON and/or XML or like TagSoup, and display everything in a simple all-about-the-content manner
19:41:12 <chrisdone> araujo: basically greasemonkey but faster and without seeing it load the page first (ugh)
19:46:28 <Olathe> > let scan elemF prevF combF = scanl1 ((.elemF).combF.prevF) in scan (^2) id (+) [1..10]
19:46:32 <lambdabot>   [1,5,14,30,55,91,140,204,285,385]
19:48:48 <mmorrow> was just reading the logs re: haskell, web browsers and js
19:48:52 <mmorrow> hell yeahs!
19:49:12 <mmorrow> when 6.10 comes out i'm gonna put a js QQ on hackage
19:49:16 <mmorrow> here's some misc from it
19:49:18 <mmorrow> http://hpaste.org/10114
19:49:43 <mmorrow> (i'm about to paste a practical use example...)
19:51:00 <hackage> Uploaded to hackage: lojban 0.0.0
19:51:45 <lament> 0.0.0?
19:52:17 <chrisdone> yes
19:52:23 <lament> ambitious
19:53:07 <chrisdone> lojban will out-live haskell
19:53:16 <BMeph> chrisdone: bmonad?;) -- 'b' for 'browser, natch.
19:53:41 <Olathe> That's only because lojban isn't important enough to replace.
19:53:45 <chrisdone> BMeph: hehe
19:53:50 <chrisdone> Olathe: so?
19:54:16 <Olathe> > sing So !
19:54:19 <lambdabot>   mueval: Prelude.read: no parse
19:54:20 <Olathe> > sing "So !"
19:54:24 <lambdabot>   ♪ So ! ♪
19:54:26 <chrisdone> araujo: using webkit seems like a fun idea..
19:54:45 <Olathe> Well, time for bed.
19:54:47 <araujo> chrisdone, yeah ... I had that idea
19:54:51 <araujo> well, have
19:55:00 <araujo> I still want to see/use a haskell browser
19:57:38 <mmorrow> practical use examples:  http://hpaste.org/10114#a2
19:58:05 <mmorrow> araujo: if only the whole "html redering thing" was out of the way ....
19:58:11 <mmorrow> *rendering
19:58:47 <mmorrow> i imagine it wouldn't be that hard to make a js interpreter
19:59:06 <mmorrow> someone already has one on hackage actually
19:59:11 <lament> it would be hard to make a good one
20:00:49 <mmorrow> yeah, it'd definitely be a little work
20:02:23 <mmorrow> err, well. when i personally was fiddling with one for my own use or something, i'd only have expressions and the functional pieces of js, and omit the rest...
20:02:31 <mmorrow> s/when/if/
20:03:40 <mmorrow> chrisdone: heh, 0.0.0
20:04:16 <chrisdone> well, I couldn't delete 0.0, and wanted to update the package's description
20:06:11 <mmorrow> yeah, i hate botching some small detail, a typo or something, then having to bump a whole 0.1..
20:06:52 * chrisdone nods
20:09:03 <mmorrow> oh, i forgot to mention the best part about having the js embedded in the hs. /all/ syntax errors are caught at haskell's compile time /and/ you get line/col numbers and an error description of the js error from ghc :)
20:09:27 <mmorrow> (well, the content of the error msg depends on the parser, but WebBits is pretty nice)
20:10:23 <Pegazus> Hi! Does anyone know where I can find some good benchmarks of speed, memory, efficiency, development time maybe bugs and that kind of thing (Or at least any of those things) of Haskell vs other languages? (by good I mean one with serious programs, not the 10 line progam benchmark)
20:11:13 <chrisdone> yeah that's cool
20:11:29 <chrisdone> Pegazus: google the computer language shootout
20:11:46 <chrisdone> Pegazus: http://shootout.alioth.debian.org/
20:11:47 <lambdabot> Title: The Computer Language Benchmarks Game
20:13:57 <Pegazus> thanks chirsdone... anythign more comes to your mind? :)
20:14:42 <chrisdone> I'm not aware of other stuff, other people might be
20:14:50 <dons> Pegazus: there were studies done in the early 90s
20:14:57 <dons> Pegazus: but these kind of things are very rare.
20:15:06 <mmorrow> Pegazus: do you have a link to an example of the kind of thing you're looking for?
20:15:07 <dons> Pegazus: look for the Ada, C++, Haskell paper
20:15:11 <dons> by Hudak et al
20:15:18 <mmorrow> ah, yeah. that's a good one
20:15:36 <dons> but really, academic comparisons in small studies aren't terribly convincing.
20:15:59 <dons> maybe if there were more of them.
20:15:59 <mmorrow> and that was from 1994...
20:16:02 <mmorrow> http://www.haskell.org/papers/NSWC/jfp.ps
20:17:28 <andyjgill> Evening all.
20:17:46 <Pegazus> thanks mmorrow
20:29:16 <thetallguy> Evening Andy.
20:29:40 <chrisdone> lojbot: jt coi ro do
20:29:41 <lojbot> (^coi /greetings/ ro /every/ /(of)/ do /you/^)
20:31:42 <lament> lojbot: jt ni'oni'o zemo'o fenki ke tcati kansi'u
20:31:43 <lojbot> ni'o /new topic/ ni'o /new topic/ (ze /7/ mo'o /section ordinal/) [<<^fenki /crazy/ /[type-of]/ ke / / ^tcati /tea-ish/ /[type-of]/ kansi'u /being respectively accompany-ing/^^>>]
20:33:03 <chrisdone> la .alis.
20:33:20 <chrisdone> alice in wonderland ^_^
20:34:17 <lament> lojbot: jt ke
20:34:18 <lojbot> parse error
20:35:27 <mmorrow> chrisdone: nice.
20:36:07 <chrisdone> {fenki tcati kansi'u} is  crazy-tea party, whereas {fenki ke tcati kansi'u} is crazy tea-party. {ke} is like haskell's $, in some ways
20:36:45 <chrisdone> mmorrow: :D
20:40:16 * mmorrow thinks of a lojban quasiquoter, which makes him think of a LOLCODE quasiquoter, which makes him laugh audibly to himself
20:40:46 <dons> why doesn't the haskell community produce *the* canonical lolcode implementation?
20:40:46 <chrisdone> DON'T DO IT!
20:40:53 <mmorrow> HAI
20:41:01 <mmorrow> CAN HAS STDIO?
20:41:02 <bd_> I thought parrot was working on that?
20:41:03 <chrisdone> oh no he's already changing!
20:41:05 <dons> anyone want a verified lolcode2coq compiler?
20:41:11 <mmorrow> sick!
20:41:23 * chrisdone pukes a little, with excitement
20:41:24 <dons> srsly.
20:41:25 <mmorrow> as in "awesome!"
20:41:52 <mmorrow> LOLCODE is friggin hillarious
20:42:01 <chrisdone> as long as I can write the code in my web browser, emacs is obsolete
20:42:17 <FunctorSalad> is "NOM NOM NOM" implemented yet?
20:42:34 <mmorrow> all we need is a LOLCODE ast datatype collection and a parser. then it's game on
20:43:23 <chrisdone> parser error: unexpected N at collumn 1
20:43:34 <FunctorSalad> :)
20:44:35 <mmorrow> <interactive>:4329:0: Not in scope: `KTXBYE'
20:45:31 <FunctorSalad> missing H?
20:45:37 <mmorrow> bingo
20:46:16 <mmorrow> all the error msgs should be LOLencoded too
20:46:27 <rwbarton_> "I made you a KTXBYE, but I eated it"
20:47:09 * rwbarton_ someday wants to write a compiler with backends for all the obscure/joke languages
20:47:50 <chrisdone> NO THEY BE STEELIN MAH `KTHXBYE'
20:48:15 * FunctorSalad also like starting function names with "iCan<use of function>"
20:48:21 <FunctorSalad> *likes
20:49:15 <chrisdone> mmorrow: http://blogs.chron.com/techblog/WindowsLiveWriter/OHNOES1Thebucketwalrusisdead_90B7/bucket_3.jpg
20:49:25 <lambdabot> http://tinyurl.com/56af3n
20:49:31 <mmorrow> hahahh
20:50:03 <mmorrow> the filename is hillarious in and of itself
20:50:28 <FunctorSalad> the wikipedia "cuteness, as exhibited here by a kitten" kitten is dead too :-(
20:50:29 <mmorrow> err, directory name
20:50:41 <FunctorSalad> (so said the discussion page)
20:50:56 <abbe> how do I remove 'Just' from 'Just "string"' ?
20:51:15 <abbe> I mean I want to concatenate Just "string" with another string "abcd"
20:51:23 <chrisdone> fromJust or fromMaybe (choose the latter if you haven't used isJust before hand)
20:51:25 <mmorrow> abbe: what do you want Nothing to map to? []?
20:51:33 <FunctorSalad> @type maybe
20:51:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:51:46 <pjdelport> abbe: usually, you would work within the Maybe
20:51:51 <mmorrow> > maybe [] id (Just "asdfghjkl")
20:51:53 <FunctorSalad> the first arg is the value for the nothing case
20:51:54 <lambdabot>   "asdfghjkl"
20:51:55 <abbe> (System.Posix.Env.getEnv "HOME") ++ "/.Xmodmap"
20:51:59 <mmorrow> > maybe [] id Nothing
20:52:04 <lambdabot>   []
20:52:20 <chrisdone> > fromMaybe "" Nothing
20:52:20 <pjdelport> > fmap ("abc"++) (Just "def")
20:52:24 <mmorrow> > maybe 0 length (Just "asdfghjkl")
20:52:27 <lambdabot>   ""
20:52:28 <lambdabot>   Just "abcdef"
20:52:28 <lambdabot>  Terminated
20:52:29 <chrisdone> oh shi-
20:52:33 <mmorrow> > maybe 0 length (Just "asdfghjkl")
20:52:36 <pjdelport> > fmap ("abc"++) Nothing
20:52:37 <lambdabot>   9
20:52:40 <lambdabot>   Nothing
20:53:08 <mmorrow> > maybe 0 length Nothing
20:53:12 <lambdabot>   0
20:54:08 <pjdelport> abbe: you can either apply fmap (++"/.Xmodmap") to the result of getEnv
20:54:14 <pjdelport> to get another Maybe String
20:54:24 <abbe> okay
20:54:27 <FunctorSalad> > do { x <- Just "myhome"; return (x++"/.Xmodmap") }
20:54:30 <lambdabot>   Just "myhome/.Xmodmap"
20:54:33 <pjdelport> or you can handle the Nothing case by providing a default
20:54:40 <pjdelport> to get a plain String
20:54:41 <abbe> mmorrow: that works :)
20:54:56 <mmorrow> maybe [] id =<< getEnv
20:55:09 <abbe> mmorrow: is there any maybe function also ?
20:55:32 <mmorrow> abbe: i don't understand
20:56:02 <mmorrow> abbe: did you mean a function called "also"?
20:56:09 <abbe> mmorrow: maybe :: b -> (a -> b) -> Maybe a -> b
20:56:13 <abbe> mmorrow: got it ^^^ :)
20:56:19 <mmorrow> ahh
20:56:20 <vininim> > unfoldr Just (1, 1)
20:56:23 <mmorrow> :)
20:56:23 <lambdabot>   mueval: Prelude.read: no parse
20:56:31 <vininim> oo
20:56:44 <chrisdone> mmorrow: if getEnv is type Maybe [a] then the f in a >>= f must return a Maybe type..
20:57:02 <mmorrow> oh, i'm thinking of a diff getEnv
20:57:13 <pjdelport> :t System.Posix.Env.getEnv
20:57:15 <lambdabot> String -> IO (Maybe String)
20:57:18 <mmorrow> which actually isn't maybe at all...
20:57:25 <chrisdone> heh, it is ENCASED
20:57:26 <mmorrow> ahh, ok that one
20:57:26 <dmwit> mmorrow: You might also like fromMaybe, it's just like "maybe x id", but without the "id". =)
20:57:33 <nha_> whats CAF in profiling data?
20:57:39 <FunctorSalad> chrisdone: trapped in IO monad :-(
20:57:49 <pjdelport> nha_: constant applicative form, IIRC
20:57:51 <dmwit> nha_: It's a top-level binding.
20:57:54 <mmorrow> dmwit: i actively avoid that function :)
20:58:00 <dmwit> mmorrow: ...why?
20:58:03 <chrisdone> FunctorSalad: forever :: IO () -> IO ()
20:58:16 <dmwit> mmorrow: I avoid fromJust, but why avoid fromMaybe?
20:58:19 <mmorrow> because i just use (\x -> maybe x id)
20:58:27 <abbe> pjdelport, mmorrow, FunctorSalad: :)
20:58:32 <chrisdone> but that's longer.. and less clear..
20:58:35 <mmorrow> and the id there is usually not id
20:58:38 <abbe> s/:)/thanks/
20:58:51 <mmorrow> (for me). and i like the consistencey that always using it brings
20:58:59 <dmwit> Well, yeah, when it's not id, maybe is nicer.
20:59:00 <mmorrow> *consistency
20:59:08 <chrisdone> fromMaybe just makes it clear that you don't want to do anything with the value, you just want the value
20:59:42 <mmorrow> and also, you have to import Data.Maybe to get that
20:59:47 <chrisdone> (obviously.. but it seemed worth saying at the time)
20:59:52 <dmwit> ?index maybe
20:59:53 <lambdabot> Data.Maybe, Prelude
20:59:55 <mmorrow> eh
20:59:57 <mmorrow> :)
21:00:00 * dmwit blinks
21:00:14 <dmwit> Prelude has "maybe"?  prelude++
21:00:24 <mmorrow> ?index either
21:00:25 <chrisdone> I pretty much always have Data.Maybe imported
21:00:25 <lambdabot> Data.Either, Prelude
21:00:29 <chrisdone> so many useful functions
21:00:35 <chrisdone> ie, two
21:00:38 <mmorrow> maybe and either are my pals
21:00:41 <chrisdone> catMaybes<3
21:01:09 <rwbarton_> abbe: if you just want to fail horribly in the Nothing case, you can write    Just x <- getEnv "HOME"
21:01:13 <FunctorSalad> it isn't confusing enough yet... we also need fromNothing that takes a default argument in case the arg isn't Nothing
21:01:15 <dmwit> chrisdone: I pretty much always have Control.Applicative/Arrow/Monad.Reader, Data.Char/Function/Ix/List/Maybe/Ord/Ratio imported... =P
21:01:21 <chrisdone> catMaybes = map fromJust . filter (isJust) (not implemented that way, but that's pretty much what it does)
21:01:24 <mmorrow> > (maybe mzero return =<<) [Nothing, Just 42, Nothing]
21:01:27 <chrisdone> dmwit: so do I :\
21:01:27 <lambdabot>   [42]
21:01:44 <chrisdone> dmwit: I seem to use <$> specifically, all the time
21:02:23 <dmwit> :t Control.Applicative.empty
21:02:25 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
21:02:26 <chrisdone> the “foo <- pureStuff . yayPure <$> impureIOStuff” idiom
21:02:53 * dmwit prefers fmap
21:03:07 <chrisdone> mmorrow: nice use of list monad
21:03:15 <abbe> rwbarton_: Just x <- getEnv "HOME" ? what is the use of Just here, the return value of getEnv is already Maybe [char] ?
21:03:29 * abbe is confused about use of <- :(
21:03:39 <dmwit> Or, alternatively, just doing "foo <- impureIOStuff; impure . pureStuff . yayPure $ foo"
21:03:43 <chrisdone> dmwit: it's like ONE LETTER LONGARR
21:04:01 <dmwit> chrisdone: Actually, it's usually *three* characters longer!
21:04:09 <chrisdone> dmwit: good point!
21:04:13 <chrisdone> ;_;!!
21:04:15 <dmwit> But my second alternative is two characters shorter.
21:04:23 <pjdelport> > mconcat [Nothing, Just 42, Nothing]
21:04:25 <lambdabot>   Add a type signature
21:04:33 <rwbarton_> abbe: Just x <- ... matches the result of ... against the pattern Just x, and if it matches binds x to the String contained in the Maybe String
21:04:34 <chrisdone> dmwit: yeah, but mine is more concise, and allows you to pattern match on the result
21:04:38 <FunctorSalad> read that as "longarg". long arg is LONG.
21:04:50 <chrisdone> dmwit: (more concise meaning, on one line)
21:05:05 <dmwit> chrisdone: You're still doing something with foo on the next (few) line(s).
21:05:11 <dmwit> chrisdone: So it's not more concise.
21:05:22 <dmwit> Pattern matching I will grant you.
21:05:58 <chrisdone> yeah, but I am doing something with a value that has a name, rather than the result of some functions applied to some temporary value..
21:05:59 <abbe> > do { Just x <- Just  "myhome"; return x;} -- rwbarton_
21:06:02 <lambdabot>   Couldn't match expected type `[Char]'
21:06:35 <rwbarton_> abbe: what's the type of your getEnv function?
21:06:47 <dmwit> > do { Just x <- Just "myhome"; return x }
21:06:49 <lambdabot>   Couldn't match expected type `[Char]'
21:06:52 <dmwit> huh
21:06:56 <FunctorSalad> abbe: right, if you just want to get rid of the Maybe then doing both the pattern match and the "<-" is redundant
21:06:57 <abbe> rwbarton_: getEnv :: String -> IO (Maybe String)
21:06:58 <dmwit> > do { Just x <- Just "myhome"; return x } :: Maybe String
21:07:01 <lambdabot>   Couldn't match expected type `[Char]'
21:07:03 <chrisdone> (wibble,wobble) <- smooze . bifflewop <$> iCanHasIO -- lovely
21:07:08 <dmwit> oh oh
21:07:10 <ddarius> > let catMaybes xs = [x | Just x <- xs] in catMaybes [Nothing, Just 42, Nothing]
21:07:10 <rwbarton_> abbe: <- gets rid of the IO, Just x gets rid of the Just
21:07:14 <lambdabot>   [42]
21:07:17 <dmwit> > do { Just x <- Just (Just "myhome"); return x } :: Maybe String
21:07:21 <lambdabot>   Just "myhome"
21:07:21 <mmorrow> i just realized that
21:07:28 <dons> doug auclare sure writes a lot, http://www.reddit.com/r/programming/comments/6zjr4/fuzzy_unification_parser_in_haskell/
21:07:30 <mmorrow> concatMap = (=<<)
21:07:30 <lambdabot> Title: Fuzzy unification parser in Haskell : programming, http://tinyurl.com/5wqec5
21:07:35 <pjdelport> > mconcat $ maybeToList <$> [Nothing, Just 42, Nothing]
21:07:39 <lambdabot>   [42]
21:07:41 <chrisdone> mmorrow: winnage
21:07:46 <mmorrow> > (=<<) show [0..9]
21:07:49 <lambdabot>   "0123456789"
21:08:15 <chrisdone> > [0..9] >>= show
21:08:18 <lambdabot>   "0123456789"
21:08:24 <chrisdone> O_~
21:08:33 <mmorrow> > (id=<<) . map (replicate 2) $ [0..9]
21:08:36 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]
21:08:44 <dmwit> (id=<<) = join
21:08:52 <mmorrow> > replicate 2 =<< [0..9]
21:08:52 <dmwit> (= concat, here)
21:08:52 <chrisdone> omgoptimised
21:08:55 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]
21:09:08 <abbe> rwbarton_: then why is that not working, since Right Hand Side of <- is Just "string", and according to pattern matching, x should get "string" assigned.
21:09:09 <pjdelport> > join replicate =<< [0..9]
21:09:12 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:09:14 * FunctorSalad thinks inference of the monad without any annotations is one of the more confusing haskell styles
21:09:18 <mmorrow> yeah, (id=<<) looks prettier though than "join"
21:09:19 <mmorrow> ;)
21:09:47 <rwbarton_> abbe: the proper analogue without doing any real IO would be
21:09:48 <dmwit> wut
21:10:03 <mmorrow> > (id=<<replicate) =<< [0..9]
21:10:07 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:10:11 <rwbarton_> do { Just x <- return (Just "myhome"); return x }
21:10:18 <chrisdone> it's awesome when you have like three >>= calls, all working in separate monads, on the same line
21:10:29 <mmorrow> totally
21:10:48 <FunctorSalad> if the choice of monad is the main point of the line, I think it should be made explicit
21:10:48 <abbe> rwbarton_: what is doing IO actually means ?
21:10:52 <chrisdone> I think I confused loads of redditers by pasting some code like that
21:11:07 <mmorrow> oops
21:11:13 <chrisdone> someone mentions haskell and I'm like oh gawwd look at this!!
21:11:48 <dons> chrisdone: heh
21:11:49 <chrisdone> s/someone mentions haskell and//
21:12:27 <chrisdone> http://www.reddit.com/r/programming/comments/6yuct/ask_progit_how_do_you_come_up_withchoose_names/c058jye
21:12:29 <lambdabot> Title: Fallacy comments on Ask Progit: How do you come up with/choose names for your pr ..., http://tinyurl.com/6pbsk4
21:12:50 <chrisdone> I just assume everyone on reddit knows haskell :P
21:14:07 <chrisdone> mmorrow: when can I get quasiquoted haskell in haskell?
21:14:39 <mmorrow> chrisdone: what ghc do you have?
21:14:42 <rwbarton_> chrisdone: You mean for template haskell expressions?  Isn't that built in to template haskell?
21:15:06 <mmorrow> rwbarton_: i have a (somwhat complete) haskell quasiquoter
21:15:51 <rwbarton_> does it do the same thing as [| ... |]?
21:15:59 <mmorrow> so  [$hs| [|fmap id|] |]   for example
21:16:21 <mmorrow> but the thing is, you can arbitrarily manipulate the haskell AST /before/ it gets spliced
21:16:32 <mmorrow> [$hs|id|] :: a -> a
21:16:39 <mmorrow> [|id|]::ExpQ
21:16:52 <chrisdone> mmorrow: I have .3, is it in .9?
21:17:07 <mmorrow> haha
21:17:27 <mmorrow> err, in case you were serious, yes
21:17:45 <mmorrow> really though, did you ever get 6.9 working ok?
21:18:06 <chrisdone> nah, same problem as vixey. I gave up and did something else
21:18:22 <mmorrow> sucky. what's the problem? (linker errors?)
21:18:43 <chrisdone> no the ghc-pkg issue with zero registered packages and that nonsense
21:19:12 <mmorrow> ohh. i just successfully built head a week ago, and that problem's fixed
21:19:21 <chrisdone> I might try it then
21:19:40 <mmorrow> chrisdone: also, i have a tarball of a head snapshot from june that vixey managed to get working
21:19:48 <chrisdone> mmorrow: oh sweet. link?
21:19:52 * mmorrow finds it
21:20:31 <mmorrow> http://code.haskell.org/~morrow/ghc/ghc-6.9.20080619.tar.bz2
21:20:52 <chrisdone> cheers big ears
21:21:32 <mmorrow> no prob bob
21:21:39 <mmorrow> make distclean && bash boot && ./configure --prefix=/usr/local/ghc/ghc-6.9.20080619 && make -j10 && sudo make install
21:22:03 <mmorrow> (or whatever prefix)
21:22:29 <chrisdone> do I press enter after that?
21:22:32 <chrisdone> :P
21:22:34 <mmorrow> NO!
21:22:41 <chrisdone> don't be stewpid!
21:22:51 <mmorrow> :)
21:23:03 <chrisdone> guess I better plan something to do while it's compiling
21:24:04 <chrisdone> mmorrow: what's the j10?
21:24:08 <mmorrow> 10 threads
21:24:23 <chrisdone> does that actually make it faster on a one core machine?
21:24:31 <mmorrow> probably not
21:24:34 <chrisdone> lulz
21:24:40 <mmorrow> err, i'd at least do -j2
21:24:44 <mmorrow> i dunno though
21:24:55 <chrisdone> I bet it's faster for when one thread is waiting for IO
21:25:05 <mmorrow> yeah true
21:33:29 <abbe> what is the difference between String, and [Char] ?
21:33:44 <abbe> :set +t
21:33:49 <abbe> > do { Just x <- System.Posix.Env.getEnv "HOME"; return x;}
21:33:49 <lambdabot>   mueval: Unsafe functions to use mentioned.
21:33:54 <chrisdone> one's atype aliasD[D[D[D[D[D
21:33:59 <chrisdone> what the hell
21:34:07 <chrisdone> that's what happens when I'm compiling. I can't even type :((
21:34:46 <abbe> chrisdone: hmm..., so can I use ++ on String and [Char] ?
21:34:48 <stepcut> abbe: mostly the name you see in the code and the error messages
21:35:34 <stepcut> abbe: yep. and FilePath too, since it is just another alias
21:35:56 <abbe> > do { Just x <- System.Posix.Env.getEnv "HOME"; return x ++ "abcd";}
21:35:56 <lambdabot>   mueval: Unsafe functions to use mentioned.
21:36:11 <abbe> oops, BtW, I get this: Couldn't match expected type `String' against inferred type `Char'
21:37:04 <rwbarton_> abbe: You need more parentheses:  return (x ++ "abcd")
21:37:11 <abbe> Expected type: [String], Inferred type: [Char]
21:37:54 <abbe> rwbarton_: hmm.., that works ? But why do I need parentheses ? for some kind of precendce issue ?
21:38:15 <rwbarton_> abbe: Yes.  function application like "return x" always binds tighter than any other operation
21:38:23 <rwbarton_> abbe: return is just a function, not a keyword
21:38:38 <stepcut> abbe: it is seeing that as, (return x) ++ "abcd",  because normal function application (aka, stuff like, f x) is stronger than infix operators
21:38:50 <mmorrow> > return 0 :: [Int]
21:38:54 <lambdabot>   [0]
21:38:55 <mmorrow> > return 0 :: Maybe Int
21:38:58 <lambdabot>   Just 0
21:39:05 <mmorrow> > return 0 :: IO Int
21:39:07 <ddarius> abbe: There is no difference between String and [Char].  They are exactly the same thing.
21:39:08 <lambdabot>   mueval: Prelude.read: no parse
21:39:08 <lambdabot>  mueval: *** Exception: "<IO Int>"
21:39:25 <abbe> stepcut, rwbarton_: oh, okay :)
21:40:11 <stepcut> also, you could do, return $ x ++ "abcd",  instead of, return (x ++ "abcd")
21:40:13 <abbe> thanks ddarius, rwbarton_, and stepcut :). 'return is just a function, not a keyword' is helpful. :)
21:41:17 <mmorrow> > return (return 0) :: [Maybe Int]
21:41:21 <lambdabot>   [Just 0]
21:41:23 <mmorrow> > return (return 0) :: Maybe [Int]
21:41:27 <lambdabot>   Just [0]
21:42:21 <mmorrow> > ($ 0) =<< return return :: [Int]
21:42:24 <lambdabot>   [0]
21:43:18 <mmorrow> > return 0 :: [Int]
21:43:21 <lambdabot>   [0]
21:48:21 <abbe> thanks mmorrow, it is clear now :)
21:53:12 * BMeph thinks the 'return' function was a deliberate choice, to shock imperative programmers out of their 'normal' attitudes
21:54:12 <chrisdone> what would it have been otherwise?
21:54:40 <bd_> Isn't 'unit' the category theory term?
21:54:53 <rwbarton_> Yeah, 'unit'
21:55:11 <rwbarton_> It doesn't sound like something that creates an "action" though.
21:56:39 <chrisdone> I see, I see
22:10:23 <thoughtpolice> huh, MS will be having a career far at my uni. tomorrow. :] perhaps a chance to see what they think of people on campus with haskell experience
22:10:29 <thoughtpolice> s/far/fair/
22:10:51 <dons> thoughtpolice: mention F# i guess
22:10:58 <newsham> whats the conversion between lazy and non-lazy bytestring?
22:11:00 <Heffalump> I doubt there'll be enough of a cross-section of devs there to find one that is keen.
22:11:20 <Heffalump> But they certainly do have projects which would be interested, I think.
22:12:45 <thoughtpolice> dons: I find F# interesting as well, I'll mention both if I get the opportunity. :]
22:13:05 <thoughtpolice> dons: they are also having a seminar here on friday as well
22:15:09 <chrisdone> mmorrow: still compiling
22:19:53 <mmorrow> chrisdone: heh
22:28:04 <quicksilver> newsham: toChunks / fromChunks
22:33:31 <chrisdone> mmorrow: finished
22:33:32 <chrisdone> so that's...
22:33:53 <chrisdone> 55 minutes of compiling
22:34:00 <mmorrow> nice
22:34:15 <chrisdone> now to install
22:34:27 * chrisdone watches more ricky gervais clips
22:34:29 <mmorrow> yesh. i'll get links to quasiquoters :)
22:38:55 <mmorrow> http://code.haskell.org/~morrow/code/haskell/th-utils/
22:38:55 <mmorrow> http://code.haskell.org/~morrow/code/haskell/c-qq/
22:38:56 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
22:38:56 <lambdabot> Title: Index of /~morrow/code/haskell/c-qq
22:39:00 <mmorrow> http://code.haskell.org/~morrow/code/haskell/metaquote/    (this is the hs qq, but it deps on plugins ... which i have a patch to build on 6.9 /if/ you get Cabal-1.3 somewhere)
22:39:01 <lambdabot> Title: Index of /~morrow/code/haskell/metaquote
22:39:11 <mmorrow> and i'm unclusterfucking the js-qq now
22:39:33 <mmorrow> (the haskell qq doesn't actually /need/ plugins though and all the parts of that repo that dep on it can be removed while still getting the qq)
22:55:04 <chrisdone> spankyou, mmorrow
22:56:47 <Trinithis> would anyone know how to install Glade support for gtk2hs (0.9.13)?
22:57:36 <mmorrow> chrisdone: i collected everything you need here: http://code.haskell.org/~morrow/ghc/
22:57:38 <lambdabot> Title: Index of /~morrow/ghc
22:57:44 <mmorrow> chrisdone: you're velcome
23:19:14 <bos> sioraiocht: ping
23:19:29 <sioraiocht> bos: pong
23:19:57 <bos> sioraiocht: any sign of your new unicode shininess being released?
23:20:19 <sioraiocht> bos: probably in a week or so.  I submit my dissertation tomorrow
23:20:34 <sioraiocht> and I have a few things to do after that before it's ready for released
23:20:36 <sioraiocht> *release
23:20:57 <bos> congrats on the submission.
23:21:08 <bos> still going to continue on to a phd?
23:21:31 <sioraiocht> yep
23:21:42 <sioraiocht> I literally take like, no time off
23:21:56 <sioraiocht> I have two grant proposals due in october
23:23:16 <bos> oof. what's your thesis topic going to be?
