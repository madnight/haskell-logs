00:00:13 <ivanm> heh
00:00:21 <jsnx> wow, are all you guys aussies?
00:00:26 <ivanm> this has free delivery as well
00:00:28 <Axman6> i should go order that
00:00:36 <ivanm> jsnx: well, Axman6 and I am, dons used to be
00:00:47 <Axman6> and no one else matters :)
00:00:54 <ivanm> lol
00:01:19 <ivanm> dons: can you beat that price? if not, I might order it...
00:02:51 <Axman6> dons: i've just sent ben an email. hope he's into the idea
00:05:30 <kosmikus> dons: amazon.de is using the same weird text as a synopsis ...
00:05:55 <ivanm> gah, the Chart library is confusing me :s
00:06:10 <ivanm> kosmikus: obviously us non-US customers are too dumb to get the _real_ synopsis ;-)
00:06:44 <kosmikus> possible :)
00:08:26 <kosmikus> ivanm: however, UK people would have to be considered US customers according to your reasoning
00:09:47 <jsnx> all the synopsii look fine from here in the U.S.
00:10:22 <jsnx> can't see the "weird" text y'all are talking about
00:10:59 <jsnx> wow, it looks like amazon won't ship my pre-order till late in november
00:11:43 <kosmikus> ivanm: actually, I was wrong regarding the UK. amazon.co.uk has both texts
00:12:08 <Axman6> heh
00:13:44 <dons> kosmikus: :/
00:14:39 <Cale> Of course, RWH is available for free too. I'm glad they were allowed to leave it up. :)
00:15:08 <electronx> its pretty good too
00:15:15 <electronx> read it now
00:15:17 <Axman6> hardcopy > digital
00:15:20 <electronx> reading*
00:15:22 <thoughtpolice> oleg dazzles -cafe with enumerators yet again!
00:15:51 <Cale> I think I've actually probably read more text on-screen than on paper in my life.
00:16:07 <Korollary> Wow. Who the hell wrote that synopsis
00:16:07 <Axman6> me too
00:16:11 <kosmikus> dons: don't worry. I'll buy it anyway ;)
00:16:49 <Cale> Which synopsis?
00:17:04 <dons> thoughtpolice: yeah. well, i'm hoping he has some nice answers
00:17:09 <Cale> oh, the one on fishpond?
00:17:10 <Korollary> http://www.amazon.de/dp/0596514980
00:17:21 <dons> Korollary: isn't it insane? a crazy person.
00:17:33 <dons> i've contacted o'reilly.
00:17:44 <kosmikus> dons: it reads as if a child has written it
00:17:49 <thoughtpolice> dons: i'm reading through it now
00:17:54 <dons> does the german one mention Pascal too?
00:18:06 <kosmikus> yes, it's the same (English) text
00:18:09 <Axman6> dons: so, what prices would you be offering if you sent some back to Aus? (signed of course ;)
00:18:11 <Cale> ahahaha
00:18:17 <dons> Cale: http://www.dymocks.com.au/ProductDetails/ProductDetail.aspx?R=9780596514983&amp;Producode=9780596514983
00:18:22 <lambdabot> Title: Welcome to Dymocks Online. More for Booklovers., http://tinyurl.com/3wm6zx
00:18:27 <dons> major wtf.
00:18:32 <Korollary> "...it's a fairly fast and brief tutorial..." of 704 pages???
00:19:01 <kosmikus> Korollary: people used to books on XML might say that ...
00:19:01 <Axman6> urgh, why is everything capitalised?
00:19:40 <dons> compare with the publisher controlled amazon.com page, http://www.amazon.com/gp/product/0596514980?ie=UTF8&tag=reaworhas-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0596514980
00:19:41 <kosmikus> that seems to be specific to the .au site. the text on amazon.de and amazon.co.uk doesn't have everything capitalized
00:19:49 <lambdabot> http://tinyurl.com/5ow2fw
00:19:55 <dons> "This easy-to-use, fast-moving tutorial introduces you to functional programming with Haskell."
00:20:04 <dons> so maybe they did some freestyle translation :)
00:20:15 <electronx> i was going to buy rwh
00:20:16 <kosmikus> dons: have you seen amazon.co.uk? it has the synopsis "filled in" between the official text and the "about the authors" part
00:20:24 <dons> hmm.
00:20:35 <electronx> but it comes out in december 8
00:20:52 <dons> dec 8?
00:20:55 <dons> where'd you see that?
00:21:02 <electronx> amazone.com
00:21:08 <electronx> amazon.com*
00:21:32 <dons> oh, interesting. Publisher: Media, Inc. (December 5, 2008)
00:21:39 <dons> no one tells me anything.
00:21:45 <electronx> Publisher: Media, Inc. (December 5, 2008)
00:21:50 <electronx> ya
00:22:01 <dons> i'd not be surprised if that date doesn't turn out to be wrong :)
00:22:08 <dons> considering the publisher is "wrong" too.
00:22:18 * Korollary is confused by many negatives
00:22:19 <electronx> so when does it come out?
00:22:37 <dons> nov. some time, from what i've heard.
00:22:47 <Korollary> You mean you'd not be surprised if the date turns out right?
00:22:59 <dons> Korollary: i'd not be surprised if that date was wrong.
00:23:08 <dons> i.e. i expect it is wrong.
00:23:11 <jsnx> dons: do you think it could be earlier?
00:23:11 <dons> sok?
00:23:14 <dons> yeah.
00:23:20 <dons> but then again, they don't tell me anything.
00:23:35 <Korollary> They'd have to shoot you.
00:24:03 <electronx> lol
00:24:26 <electronx> seems like a good book though very thorough with good explanations
00:24:48 <Korollary> You're number 15060 in amazon.de's bestselling english books already.
00:25:01 <dons> only 15000 books to go.
00:25:06 <jsnx> "customer's bought this book with anathem"
00:25:07 <dons> then we'll be in the big time :)
00:25:15 <dons> oh, stephenson eh?
00:25:27 <jsnx> yeah
00:25:34 <micahcowan> Just got that myself.
00:25:55 * dons finds the whole publishing process incoherent 
00:26:26 <Korollary> It's funny that Search Inside the Book is not available although the whole thing is online.
00:26:43 <dons> ah, i think there's some way for us to do that.
00:26:51 <micahcowan> I've used google at least once or twice, with site:book.realworldhaskell.com
00:26:52 <dons> the authors can add links and blog posts and stuff.
00:27:03 <micahcowan> .org, whatever
00:27:32 <pao> hi ... is there a library for implementing sets using an ordered list?
00:27:37 <Korollary> "www.Haskel-Usa.com       Gas Booster, Air Pressure Amplifier High Press. Systems, Quick Delivery"
00:27:53 <dons> pao, Data.Set ?
00:28:04 <dons> an implementation of sets.
00:28:09 <dons> not a library for implementing sets.
00:28:19 <dons> a library *for* implementing sets *using lists* would be Data.List :)
00:28:41 <pao> dons: wrong question :-)
00:29:11 <pao> dons: is there a library that implements sets using an ordered list... correct version :-)
00:29:31 <dons> ah, Data.List has intersect/difference/union, using the list type.
00:29:48 <dons> if you're operating on sets, i'd suggest Data.Set though
00:30:18 <pao> dons: I've seen... but it does not require an ordered list... the consequence is that nub is O(n^2)
00:30:48 <pao> dons: so the best practise is to always use Data.Set if you have performance concerns... right?
00:30:53 <dons> yeah
00:31:02 <dons> use the right type for the right job.
00:31:05 <dons> kosmikus: coming to ICFP?
00:31:13 <pao> dons: thanks
00:31:40 <kosmikus> dons: yes, I'll arrive tonight (Friday), relatively late. going to be at WGP tomorrow ...
00:32:02 <Vq^> pao: almost always, if you're working with Ints IntSet might be better
00:32:18 <dons> cool. look forward to catching up.
00:32:34 <pao> Vq^: thanks
00:33:04 <kosmikus> dons: when are you going to arrive?
00:33:10 <dons> sunday evening.
00:34:11 <kosmikus> good. looking forward to it too.
00:45:25 <Axman6> "All our book prices are better than AmazonTM. Guaranteed."
00:46:45 * Axman6 orders RWH from them...
00:47:10 <Cale> Our price = Amazon's price - 1 penny.
00:52:43 <Axman6> yay, just pre-ordered my copy og real world haskell :)
00:53:01 <jsnx> Axman6: what delivery date do they state?
00:53:34 <Axman6> none
00:53:45 <jsnx> !!
00:54:09 <jsnx> they'll ship it when it's done!
00:54:21 <micahcowan> Axman6, together with Anathem? ;)
00:54:46 <Axman6> micahcowan: hmm?
00:55:04 <micahcowan> <jsnx> "customer's bought this book with anathem"
00:55:27 <Axman6> no idea what that is...
00:56:14 <micahcowan> http://www.amazon.com/Anathem-Neal-Stephenson/dp/0061474096/
00:56:22 <micahcowan> By the author of "Snow Crash", among others.
00:56:34 <jsnx> if it's anything like the cryptonomicon, it's an indulgence in techno-babble, subtle homo-eroticism and american might
00:56:38 <micahcowan> Just released this month.
00:56:53 <micahcowan> I couldn't really get into cryptonomicon, somehow. Maybe I'll try again sometime.
00:57:45 <hackage> Uploaded to hackage: panda 2008.9.19.2
00:57:45 <hackage> Uploaded to hackage: panda 2008.9.19.1
00:58:15 <jsnx> i read about a sixth of it, by following just one timeline through it, skipping anything else
01:01:00 <bringert> kosmikus, ivanm: http://www.amazon.co.uk/Real-World-Haskell-Bryan-OSullivan/dp/0596514980 also has the Pascal blurb
01:01:04 <lambdabot> http://tinyurl.com/4v87p6
01:03:14 <Axman6> "This title is due for publication on 19 October 2008. Your copy has been reserved and we will ship it to you as soon as possible after the release date."
01:03:55 <micahcowan> Which title? RWH?
01:04:52 <Axman6> yeah
01:04:59 <Axman6> so, a month to go
01:05:14 <micahcowan> I don't see that here. Are you using .com, or some other (.co.uk?)
01:05:30 <Axman6> i'm using fishpond.com.au
01:05:43 <Axman6> god damn, pokki is so addictive!
01:06:06 <micahcowan> Heh.
01:06:32 <electronx> pokki?
01:09:22 <Axman6> trying to find something on the net...
01:09:39 <Axman6> http://ephemeral-inspiration.blogspot.com/2005/08/food-of-gods-pocky-pretz-pretenders.html
01:09:41 <lambdabot> Title: The Journal of Ephemeral Inspiration: Food Of The Gods: Pocky, Pretz & Pretender ..., http://tinyurl.com/3mqvr4
01:10:48 <Axman6> helps if you spell it correctly...: http://en.wikipedia.org/wiki/Pocky
01:10:49 <lambdabot> Title: Pocky - Wikipedia, the free encyclopedia
01:11:49 <micahcowan> pokki is likely how it's spelled in Japanese. „Éù„ÉÉ„Ç≠!
01:12:56 <micahcowan> pokkii, rather.
01:13:00 <BeelsebobWork_> Has anyone ever hit a bug with mkstemps where a directory with a name starting with '-' caused it to bail?
01:15:45 <kosmikus> bringert: yes, I had seen that already
01:18:02 <dons> hopefully the publishers will fix this up, now they know about it.
01:22:45 <kosmikus> dons: I've googled for the first sentence of that synopsis, and found ~30 links, some of them duplicates. There seem to be a few more online bookstores having that text, but none of them seem to be US bookstores.
01:27:19 <dons> strange. thanks kosmikus, i'll follow this up.
01:33:49 <niklaus> which are good books for functional programming , i mean in general apart from haskell , i'm new to this
01:34:12 <Stinger__> what level?
01:34:18 <Stinger__> oh new, right
01:34:18 <niklaus> noob
01:34:20 <Stinger__> SICP?
01:34:50 <niklaus> and
01:34:52 <Stinger__> aka structure and interpretation of computer programs (if I recall correctly) scheme book
01:35:04 <BeelsebobWork_> anyone ever seen this happen before? http://www.cs.kent.ac.uk/people/rpg/tatd2/directory.png
01:37:19 <micahcowan> BeelsebobWork_, perhaps drop the trailing slash?
01:37:31 <BeelsebobWork_> still false
01:37:43 <BeelsebobWork_> I can't figure out what triggers it -- it works for the other wierd named directory in there
01:37:56 <Stinger__> those are some .. interesting directory names
01:38:03 <BeelsebobWork_> yeh, temp directories
01:38:10 <Stinger__> nonprinting chars in there perhaps?
01:38:13 <Cale> BeelsebobWork_: That's a different directory name.
01:38:18 <BeelsebobWork_> Cale: it is?
01:38:18 <micahcowan> I was going to ask that same question.
01:38:27 <Cale> BeelsebobWork_: Only the first few characters match.
01:38:38 <micahcowan> Ah, so it is.
01:38:38 <BeelsebobWork_> oh, so it is
01:38:42 <micahcowan> ;)
01:38:43 <BeelsebobWork_> that's wierd
01:38:47 * BeelsebobWork_ goes hunting bugs elsewhere
01:39:06 <BeelsebobWork_> Cale: trying to debug hs-plugins temp file creation
01:39:15 <Cale> hmm
01:39:29 <Cale> I wonder why it's so broken on 6.9...
01:39:38 <BeelsebobWork_> well, most of it wasn't 6.9 errors
01:39:44 <BeelsebobWork_> most of it was cabal 1.5
01:39:53 <BeelsebobWork_> and this one I haven't figured out yet
01:40:40 <BeelsebobWork_> there were a few changes to ghc-api in 6.9 though, but they're worked through now
01:42:55 <niklaus> any other than SICP ? i wan the concepts
01:43:34 <BeelsebobWork_> SICP really gives you the concepts
01:43:37 <BeelsebobWork_> it's a bloody good book
01:43:57 <abbe> true BeelsebobWork_ :)
01:46:19 <profmakx> when's 6.10 due to be released?
01:46:27 <profmakx> ghc, that is
01:49:07 <micahcowan> Hm. Links from the comments feed on RWH are 404'ing. dons?
01:49:56 <micahcowan> Was there massive page renaming? :)
01:53:45 <Cale> micahcowan: it's been changed from /beta to /read
01:54:03 <micahcowan> That's not it.
01:54:33 <micahcowan> deftypes.html, funcstypes.html
01:55:34 <micahcowan> the former seems to be defining-types-streamlining-functions.html now. The last comment with a link to that URL is 7:14 am Sep 18 (and is the latest comment on the "all comments" feed)
01:58:19 <BeelsebobWork_> Cale: figured it out -- it's not 6.9 at all -- it's that the temp directory name contains a 'X' -- which the mkstemps function replaces with something random
01:59:57 <BeelsebobWork_> I'm not quite sure of the correct behovior here, but presumably gettemp should be only looking for the Xs in the last path component?
02:14:01 <mapreduce> dons: I plan to make the tiny IRC bot I wrote following your tutorial pull RSS feeds and dump the URLs into a channel.  Would you advise anything specifically for that?
02:16:12 <BeelsebobWork_> Cale: System.Eval.eval "5 + 6" [] should give me something back, right?  I'm not using this wrong?
02:28:58 <ac> has anyone read about NewSpeak?
02:29:24 <mapreduce> doubleplusungood
02:31:33 <quicksilver> ac: of course we have. We're geeks :P
02:32:03 <niklaus> any good books on OOP
02:32:13 <niklaus> SICP ?
02:34:03 <mapreduce> niklaus: SICP is an excellent book on OOP (tongue firmly in cheek here).
02:34:17 <mapreduce> You get to implement OOP for a language that doesn't come with it built in.
02:34:31 <ivanm> I don't recall any OOP stuff in SICP :s
02:34:50 <niklaus> i want to learn the basics and good things. some suggested smalltalk
02:35:05 <niklaus> for concepts
02:35:09 <ivanm> isn't smalltalk _the_ OOP language?
02:35:24 <araujo> ivanm, yea
02:35:28 <araujo> ivanm!!!!
02:36:48 <araujo> niklaus, yeah, ST is definitely one of the best language to grasp at OOP
02:37:00 <araujo> niklaus, I recommend Smalltalk, Objects and Design
02:37:17 <ivanm> then again, since FP > OOP why do you want to learn OOP? :p
02:37:51 <niklaus> when i read about these objects i need to understand the design, then convert it to haskell with FP approach , porting stuff
02:38:44 <mapreduce> ivanm: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3 - search for 'dispatch'.
02:38:45 <lambdabot> Title: Structure and Interpretation of Computer Programs, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-22.html#%_sec_3.3
02:38:55 <ivanm> mapreduce: oh, the dispatch lookup stuff?
02:39:03 <ivanm> didn't think of that as OOP...
02:39:08 <mapreduce> Well, it is.
02:39:22 <mapreduce> Try to tell me the difference between that and a vtable.
02:39:46 <ivanm> if there's anyone else here from oz thinking of buying RWH, fishpond just gave me a $10 voucher after Axman6 sent me an info email from them
02:40:10 <ivanm> mapreduce: "vtable"? haven't heard of that...
02:40:14 <mapreduce> Crap, I thought this discussion was happening on ##csharp for some reason.
02:40:14 * Axman6 o/
02:40:19 <ivanm> then again, all my OOP was in Java :s
02:40:24 <ivanm> mapreduce: lol
02:40:41 <mapreduce> ivanm: A vtable is terminology for C++ - a table for looking up virtual method calls at runtime.
02:41:03 <ivanm> ahhh
02:41:13 <mapreduce> In Java you'd have one of those per class (same for C++).
02:41:51 <ivanm> *nod*
02:41:57 <quicksilver> java has (or had) an optimisation bug which didn't always use vtables
02:42:03 <quicksilver> thus breaking library abstraction and upgrades
02:42:04 <quicksilver> whoops.
02:42:13 <ivanm> lol
02:42:17 <mapreduce> quicksilver: What bug's this?
02:42:34 <quicksilver> if the compiler notices that a method is "not really virtual" because it is never overridden in practice
02:42:41 <quicksilver> it skips the virtual dispatch and generates a direct call.
02:42:56 <quicksilver> if you then upgrade your library in an API-preserving way, but add an override to that method
02:42:56 <mapreduce> The source compiler or the bytecode -> machine code compiler?
02:43:01 <quicksilver> it breaks.
02:43:04 <quicksilver> the source compiler.
02:43:12 <quicksilver> I presume sun fixed it.
02:43:17 <ac> quicksilver: did you understand what it adds to SmallTalk?
02:43:19 <quicksilver> I stopped being interested in java about 10 years ago :)
02:43:21 <mapreduce> Ok, I guess this is from around 10 years ago, because I've never heard of it.
02:43:22 <mapreduce> heh
02:43:38 <mapreduce> quicksilver: What you said is still true for constants though.
02:44:17 <quicksilver> separate compilation, except not quite.
02:44:40 <quicksilver> you could argue that this is why separate compilation is a broken idea. Or you could use this as an argument for 'Just In Time optimisation'
02:45:02 <mapreduce> Yes.
02:45:11 <mapreduce> Separate compilation causes many backside pains for the Scala compiler.
02:48:15 <ivanm> dons: how much do you get for each copy of RWH sold?
02:55:01 <mapreduce> The answer is in a monad that lacks an 'extract'.
02:58:34 <Deewiant> instance Monad Bank where...
02:59:52 <Cale> BeelsebobWork_: try this:  eval "5 + 6 :: Integer" [] :: IO (Maybe Integer)
03:00:23 <BeelsebobWork_> Cale: yeh, I've just discovered that -- but there was a seperate bug
03:01:06 <BeelsebobWork_> It was seeing the warnings about use -O0 not -Onot in 6.9's output and deciding that meant the build had failed
03:01:13 <BeelsebobWork_> it's working now
03:01:23 <BeelsebobWork_> is there a sensible place to send the patches to?
03:01:54 <Cale> I suppose dons should still have access to everything needed.
03:03:10 <BeelsebobWork_> do you know how I can send darcs patches without using darcs send (I don't know how to config sendmail to make it work)
03:03:39 <Cale> darcs send -o filename.dpatch
03:03:42 <Deewiant> darcs send has an option to make a file
03:03:46 <Deewiant> and that's it :-)
03:04:24 <BeelsebobWork_> cheers
03:04:30 <Cale> http://www.youtube.com/watch?v=mLQfRn7rJV0 -- ahahaha
03:04:35 <lambdabot> Title: YouTube - McCain's Key Demographic
03:08:53 <mapreduce> I wouldn't have thought YouTube was McCain's key demographic.
03:09:36 <Cale> (you should see pretty quickly that he's joking :)
03:10:07 <Cale> Oh, that's just the page title of course :)
03:11:12 <mapreduce> Yeah, I try not to watch videos at work.
03:12:03 <quicksilver> it's been scientifically proven that 5-10 youtube videos per day improves productivity of 80% of workers by at least 40%.
03:12:52 <Axman6> [Source: Report: A study of workers at YouTube]
03:15:28 <swc|x> Having an affair with a co-worker also improves productivity apparently
03:15:52 <profmakx> sure you didnt want t o say "impede" swc|x ;)
03:16:05 <swc|x> :)
03:16:15 <_Dae_> swc|x: True, but only if you keep it down to a single co-worker
03:16:31 <quicksilver> improves it short-term but there is a serious negative payback in the medium term
03:16:34 <quicksilver> one way or anothr.
03:17:00 <_Dae_> if you're having an affair with half the department, most of your day will be taken by either consuming said affaris, or keeping them from the other co-workers
03:18:06 <swc|x> _Dae_, well, multitasking does negatively impact productivity and focus
03:18:46 <_Dae_> swc|x: I know, it's all I've achieved in getting haskell to multitask :p
03:21:15 <swc|x> "In fact, flirting might even have some indirect benefits on the job, says Reeder, citing research conducted at the University of South Alabama in 2003 showing that people who don't flirt very much have lower energy levels and rate themselves as less attractive than people who flirt a lot."
03:21:16 <swc|x> http://www.cnn.com/2008/LIVING/worklife/02/05/work.spouse/index.html
03:21:18 <lambdabot> Title: Platonic work flirting: Good for business? - CNN.com, http://tinyurl.com/2zxmv2
03:22:05 <swc|x> Try flirting about haskell, C++ or Python and you won't have much luck though
03:22:14 <swc|x> I know, I tried
03:22:21 <tennin> verb
03:22:33 <_Dae_> You're not supposed to flirt about them, but WITH them
03:22:33 <quicksilver> I bet you've got a nice pair of monads, baby?
03:23:13 <_Dae_> Hey, you're one urely functional piece of programming
03:23:16 <_Dae_> *purely
03:23:24 * swc|x groans
03:23:57 <Axman6> i'll compose your functions
03:24:23 <Axman6> Just me >>= you
03:24:49 <swc|x> Try demonstrating dependency injection to the Java girl in the cubicle farm
03:25:19 <ScottMichael> fac n = if n > 0 then n * fac (n-1) else 1
03:25:19 <ScottMichael> (!) = fac
03:25:20 <swc|x> you need to protect against resource leakage
03:25:22 <ScottMichael> not wokring
03:25:33 <_Dae_> swc|x: somehow, that sounds really really wrong
03:25:34 <ScottMichael> i thought i could do that®
03:25:43 <swc|x> hehehe
03:25:45 <BeelsebobWork_> ScottMichael: what's not working about it?
03:25:52 <ScottMichael>  pat ::= !pat
03:26:08 <ScottMichael> does hat have to be added or is that an explanation of principle. of bangpatterns
03:26:33 <Axman6> well, ! is a strictness annotation isn't it?
03:26:33 <BeelsebobWork_> ScottMichael: a bang pattern makes something strict
03:26:39 <BeelsebobWork_> f !x /
03:26:41 <BeelsebobWork_> bah
03:27:00 <BeelsebobWork_> f !x = ... means "compute x in WHNF before starting this"
03:27:19 <BeelsebobWork_> ScottMichael: exactly what is the error, and what are you trying to accieve
03:27:22 <ScottMichael> fac n = if n > 0 then n * fac (n-1) else 1
03:27:22 <ScottMichael> (#) n = fac n
03:27:32 <ScottMichael> now this doesnt generate an error
03:27:39 <ScottMichael> ut when callin g # 5 i get nothing
03:27:43 <ScottMichael> no result at all
03:27:53 <_Dae_> On a more serious note, I need to create a datastructure akin to list, where "take n $ reverse xs" is a constant time operation. In c I guess I would make a weird sort of doubly linked list to ahieve it, but not quite sure what to do in haskell
03:27:57 <ScottMichael> im just trying to use a symbol insetad of a word as fucntion name
03:28:00 <BeelsebobWork_> well no, you've not defined # to be a binary operator ScottMichael
03:28:24 <BeelsebobWork_> ScottMichael: what do you expect g # 5 to do?
03:29:04 <ScottMichael> fac 5
03:29:15 <BeelsebobWork_> and what is the 'g' supposed to mean?
03:29:25 <ScottMichael> g is nt there
03:29:31 <ScottMichael> calling
03:29:36 <Axman6> oh, heh
03:30:03 <BeelsebobWork_> > let fac n = if n > 0 then n * fac (n-1) else 1; (#) n = fac n in (#) 5
03:30:05 <lambdabot>   mueval: Prelude.read: no parse
03:30:17 <lilac> , let (!) n = if n > 1 then n * (n!) else n  in (5!)
03:30:18 <lunabot>      No instance for (Num (t -> t1))
03:30:28 <BeelsebobWork_> damn you lambdabot being crap
03:30:47 <lilac> greh
03:30:54 <Axman6> > let (!) n = if n > 1 then n * (n!) else n  in  ! 5
03:30:56 <lambdabot>   mueval: Prelude.read: no parse
03:31:01 <lilac> > let (!) n = if n > 1 then n * ((n-1)!) else n  in (5!)
03:31:02 <lambdabot>   120
03:31:07 <Axman6> > let (!!!) n = if n > 1 then n * (n!) else n  in  !!! 5
03:31:09 <lambdabot>   mueval: Prelude.read: no parse
03:31:12 <lilac> > let (!) n = if n > 1 then n * ((n-1)!) else n  in (500!)
03:31:14 <lambdabot>   122013682599111006870123878542304692625357434280319284219241358838584537315...
03:31:15 <Axman6> fail
03:31:17 <lilac> win
03:31:21 <BeelsebobWork_> yay lilac
03:31:22 <Axman6> nice work
03:31:47 <Deewiant> > let (!) = product . enumFromTo 2 in (500!)
03:31:51 <lambdabot>   122013682599111006870123878542304692625357434280319284219241358838584537315...
03:33:22 <Axman6> > let (!) = product . enumFromTo 2 in (1!)
03:33:23 <lambdabot>   1
03:33:28 <Axman6> ah, excellent
03:33:31 <Axman6> > let (!) = product . enumFromTo 2 in (0!)
03:33:33 <lambdabot>   1
03:33:35 <BeelsebobWork_> gah
03:33:51 * BeelsebobWork_ ponders how to write a Typeable instance for "newtype Compiler x = C (Int -> (String, Int))"
03:34:09 <Axman6> > let (!) = product . enumFromTo 2 in ((-2)!)
03:34:11 <lambdabot>   1
03:34:15 <Deewiant> :-)
03:34:23 <Axman6> > enumFromTo 2 1
03:34:25 <lambdabot>   []
03:34:32 <Axman6> > enumFromTo 2 2
03:34:33 <lambdabot>   [2]
03:34:41 <Axman6> ah, right. how nice
03:34:50 <quicksilver> BeelsebobWork_: some reason you don't want to derive it?
03:34:57 <Deewiant> @check \n -> n < 2 ==> enumFromTo 2 n == []
03:34:58 <lambdabot>   "OK, passed 500 tests."
03:35:06 <BeelsebobWork_> quicksilver: hmm? what would the derived instance produce?
03:35:27 <quicksilver> I dunno. It normally just works in my experience.
03:35:35 <quicksilver> I guess they produce a fresh TyCon for Compiler
03:36:46 <BeelsebobWork_> quicksilver: it declares that it can't derive it, even with cunning newtype deriving
03:36:47 <BeelsebobWork_> o.O
03:37:03 <BeelsebobWork_> which makes sense
03:37:11 <BeelsebobWork_> given that x doesn't appear anywhere on the RHS of the type
03:39:04 <quicksilver> BeelsebobWork_: I wouldn't have thought that would matter. typeOf is a type function not a value function.
03:39:10 <quicksilver> so it doesn't need to inspect the value.
03:39:22 <quicksilver> and "Compiler Int" and "Compiler Char" are distinct types
03:39:27 <quicksilver> even thought they have the same terms.
03:39:32 <BeelsebobWork_> quicksilver: yeh, but how would it inspect the type without inspecting the value and asking for it's type?
03:39:41 <quicksilver> the type-checker tells it its type
03:39:49 <quicksilver> Typeable is, fundamentally, a compile-time computation.
03:40:18 <BeelsebobWork_> I'm not sure that's true for polymorphic values
03:40:26 <BeelsebobWork_> s/values/types/
03:40:51 <quicksilver> that is an interesting point.
03:41:10 <quicksilver> but surely
03:41:20 <BeelsebobWork_> it would require it to generate an instance for every possible type passed to the constructor at compile time
03:41:21 <quicksilver> erm..
03:41:36 <BONUS> um, wouldnt it just infer all the types and that's it?
03:41:42 <quicksilver> don't you just defer to the type of the inner bit
03:41:57 <quicksilver> typeOf (Compiler a) == TyCon "Compiler" $ (typeOf (undefined :: a))
03:42:06 <quicksilver> that's a bizarre non-syntax
03:42:07 <BeelsebobWork_> oh, that's an interesting one
03:42:09 <quicksilver> mixing types and terms
03:42:12 <quicksilver> but do you see what I mean?
03:42:14 * BeelsebobWork_ tries that definition
03:42:35 <BeelsebobWork_>   typeOf (C x) = mkTyConApp (mkTyCon "Compiler") (typeOf (undefined :: a)) <-- this?
03:42:40 <quicksilver> yes.
03:42:47 <quicksilver> assuming you have the right scoped type thing working
03:42:50 <quicksilver> and 'a' is the right thing
03:43:34 <BeelsebobWork_> hmm, that produces an interesting error that I'm not sure I understand
03:43:47 <quicksilver> :t myTyConApp
03:43:56 <BeelsebobWork_> http://hpaste.org/10511
03:43:57 <lambdabot> Not in scope: `myTyConApp'
03:44:05 <BeelsebobWork_> :t mkTyConApp
03:44:06 <lambdabot> TyCon -> [TypeRep] -> TypeRep
03:44:32 <quicksilver> thanks :)
03:44:42 <quicksilver> BeelsebobWork_: do you need -XScopedTypeVariables?
03:44:48 <quicksilver> and an explicit 'forall' in the instance
03:44:51 <quicksilver> to start a type-scope
03:45:08 <BeelsebobWork_> yes, apparently I do
03:45:15 * BeelsebobWork_ ponders if that type error could have told me that
03:45:17 <quicksilver> does that fix it
03:45:19 <quicksilver> \o/
03:45:27 <BeelsebobWork_> well, it compiles now -- just checking if it works
03:45:29 <quicksilver> why couldn't GHC derive this though?
03:45:34 <quicksilver> surely this is the 'obvious' instance?
03:46:05 <BeelsebobWork_> success!
03:46:07 <mnislaih> I wish derived Read instances used Parsec or a ReadP extended with error reporting
03:46:23 <BeelsebobWork_> Prelude NM8.Core> interpret $ compilerToInterpreter ((lit (+) "+") $$ (lit' 5) $$ (lit' 6))
03:46:23 <BeelsebobWork_> 11
03:46:26 <ScottMichael> but none of that works ina module to load
03:46:28 <BeelsebobWork_> :)
03:46:28 <mnislaih> writing my own Parsec parser for a record type is annoying
03:46:42 <BeelsebobWork_> quicksilver: I'm not sure it is obvious
03:46:51 <BeelsebobWork_> in that normally you would have a value on the RHS to work with
03:47:04 <BeelsebobWork_> rather than having to play with undefined and scoped type vars
03:47:19 <quicksilver> BeelsebobWork_: it's not obvious in haskell syntax, I agree.
03:47:24 <quicksilver> BeelsebobWork_: but I feel it shoul dbe obvious to the compiler
03:47:28 <BeelsebobWork_> possibly
03:47:30 <quicksilver> BeelsebobWork_: which is not confined by such details :)
03:47:30 <mnislaih> does any of the Drift/Derive tools automate the generation of Parsec parsers for datatypes with records ?
03:47:42 * BeelsebobWork_ goes and asks in #ghc
03:48:50 <quicksilver> mnislaih: you want something 'like' Read but using a better parser framework?
03:49:01 <ScottMichael> is haskell better than lispf or creating DSLs?
03:49:16 <mnislaih> quicksilver: oh yes. I want Read to generate user friendlier parser
03:49:25 <Axman6> DSLs?
03:49:34 <ScottMichael> could i create a macro-ish "when"-control structure in haskell? without template haskell
03:49:46 <ScottMichael> domain specific languages
03:50:00 <mnislaih> quicksilver: specially for record datatypes, often used for quick configuration files
03:50:17 <quicksilver> mnislaih: DrIFT supports something called 'Parse' which is along those lines
03:50:25 <quicksilver> I don't know anything about it though
03:50:42 <mnislaih> quicksilver: thanks, I'll take a look
03:52:46 <mnislaih> quicksilver: oh, but it uses the Hutton-Meijer combinators, which do no error reporting (do they?)
03:53:23 <mnislaih> I don't think so: newtype Parser a   = P (Pos -> Pstring -> [(a,Pstring)])
03:55:56 <ac> so I started doing these: http://blog.tmorris.net/20-intermediate-haskell-exercises/
03:55:59 <udohateme> FACT #6: Blacks are 6 times as likely to have I.Q.'s of 50 to 70which put them in the slow learner (retarded) category, while Whites areten times more likely to score 130 or over. (15) (16) (18) (23)
03:55:59 <udohateme> FACT # 7: The U.S. government's PACE examination, given to 100,000university graduates who are prospective professional or administrativecivil-service employees each year, is passed with a score of 70 or aboveby 58% of the whites who take it but by only 12% of the Negroes. Among topscorers the difference between Negro and White performance is even morestriking: 16% of the white applicants make scores of 90 or above, whil
03:55:59 <udohateme> eonly one-fifth of one percent of a Negro applicants score as high as 90--aWhite/Black success ration of 80/1. (27)
03:56:02 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª 20 Intermediate Haskell Exercises
03:56:03 <udohateme> FACT #8: Differences between Negro and White children increase withchronological age, the gap in performance being largest at the high schooland college levels. (31) (26)
03:56:06 <udohateme> FACT #9: White/Negro I.Q. differences are constantly excused as resultsof environmental variations. but at least five studies that have attemptedto equate socio-economic backgrounds of the two races indicate no significantchange in relative results. As environment improves, the Negro does betterbut so does the White. The gap is not decreased. (26) In fact, extensiveresearch by DR. G.J. McGurk, associate Professor of Psyc
03:56:11 <udohateme> hology at VillanoveUniversity, reveals that the gap in intelligence between Blacks and WhitesINCREASES where socio-economic levels of both races are raised to the middleclasses. (18)
03:56:14 <udohateme> FACT #10: In 1915, Dr. G.W. Ferfuson took 1000 school children inVirginia, divided them into 5 racial categories, and tested them for mentalaptitude. On average. full-blooded Negroes scored 69.2% as high as Whites.Three-quarter Negroes scored 73.0% as high as Whites. One-half Negroes scored81.2% as high as Whites. One-quarter Negroes scored 91.8% as high as Whites.All of these Blacks lived as and considered themselves "N
03:56:19 <udohateme> egroes."Their environments and "advantages" or disadvantages were exactlythe same. (14) Also see (26)
03:56:20 <ac> will someone ban him already?
03:56:31 --- mode: ChanServ set +o quicksilver
03:56:36 --- mode: quicksilver set +b *!*=adsfstas@*.160.162.72.cable.dyn.cableonline.com.mx
03:56:36 --- kick: udohateme was kicked by quicksilver (quicksilver)
03:56:38 <quicksilver> sorry.
03:56:44 <ac> so I started doing these: http://blog.tmorris.net/20-intermediate-haskell-exercises/
03:56:46 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª 20 Intermediate Haskell Exercises
03:56:46 <quicksilver> @ops
03:56:46 <lambdabot> Maybe you meant: docs oeis pl
03:56:50 <ac> the first two are easy
03:57:00 <ac> but the third one involves (->), which I've never seen before
03:57:09 <BONUS> its the function type
03:57:15 <BONUS> (->) a b is like a -> b
03:57:24 <quicksilver> you've never seen (->) ?
03:57:26 <quicksilver> ;)
03:57:30 <ac> not the way it's used...
03:57:34 <ScottMichael> m <- parseMovies
03:57:35 <ScottMichael>   print m
03:57:37 <quicksilver> :t (+)
03:57:37 <skorpan> ac: what are you supposed to solve in those exercises?
03:57:38 <lambdabot> forall a. (Num a) => a -> a -> a
03:57:40 <ScottMichael> how do i make that one row?
03:57:47 <quicksilver> ac: there are -> ...
03:57:51 <skorpan> ScottMichael: parseMovies >>= print
03:57:54 <ac> skorpan: you're just suposed to replace every "error" with a non-bottom implementation
03:58:01 --- mode: quicksilver set -o quicksilver
03:58:03 <skorpan> ac: what does "non-bottom implementation" mean?
03:58:15 <quicksilver> something which actually works.
03:58:23 <ac> skorpan: just replace 'error "todo"' with something that type checks
03:58:24 <ScottMichael> someone throught out the racist?
03:58:27 <skorpan> oh
03:58:45 <quicksilver> polymorphism means there is only one correct answer for most of them.
03:58:47 <ac> skorpan: so the first one is simply "map"
03:59:01 <BONUS> :t fmap
03:59:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:59:04 <skorpan> ac: so it couldn't me anything else?
03:59:12 <skorpan> be*
03:59:28 <ac> skorpan: uhm.. fmap would work I believe :-P
03:59:42 <skorpan> i mean since you said "is simply"
03:59:59 <ac> skorpan: I just meant that one was easy, as well as the second one
04:00:33 <Axman6> @src fmap
04:00:34 <lambdabot> Source not found. Maybe you made a typo?
04:00:39 <ac> hmm, fmap works for the second one too. I had used liftM
04:00:42 <Axman6> @src Maybe fmap
04:00:42 <lambdabot> fmap _ Nothing       = Nothing
04:00:42 <lambdabot> fmap f (Just a)      = Just (f a)
04:00:52 <Axman6> @src [] fmap
04:00:52 <lambdabot> fmap = map
04:01:05 <BONUS> ac: this about this: (a -> b) -> (t -> a) -> (t -> b)
04:01:09 <Axman6> @src Either fmap
04:01:09 <lambdabot> fmap _ (Left x) = Left x
04:01:09 <lambdabot> fmap f (Right y) = Right (f y)
04:01:28 <quicksilver> using fmap is cheating, by the way.
04:01:36 <quicksilver> if your intention is to get value from the exercise.
04:01:36 <BONUS> why is it cheating
04:01:36 <ac> quicksilver: it doesn't work on the third one :-P
04:01:47 <quicksilver> BONUS: because the exercise is about fmap.
04:01:56 <BONUS> hmm yeah
04:02:00 <quicksilver> BONUS: just using the built in definition is not doing the exercise :P
04:02:13 <BONUS> but i think there's value in identifying that its fmap
04:02:22 <BONUS> also i dont think ((->) t) is an instance of Functor
04:02:27 <BONUS> so you cant use fmap there
04:02:33 <ac> right. That's what I just discovered
04:02:34 <quicksilver> you may think that.
04:02:37 <quicksilver> You'd both be wrong.
04:02:43 <ac> Maybe if I imported something...
04:02:56 <quicksilver> but I don't want to spoil the fun of working it out.
04:03:04 <ac> quicksilver: thanks :-)
04:03:20 <BONUS> oh yeah
04:03:24 <BONUS> Reader monad
04:03:25 <BONUS> doh
04:03:30 <ac> BONUS: damn you
04:03:35 <BONUS> :X
04:04:11 <Axman6> BONUS: what're you wokring on?
04:04:26 <BONUS> http://blog.tmorris.net/20-intermediate-haskell-exercises/
04:04:29 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª 20 Intermediate Haskell Exercises
04:06:41 <Axman6> ah, looks fun
04:07:00 <quicksilver> oleg++ # tirelessly fighting the good fight
04:08:40 <Axman6> ok, stumpped on what ((->) t) means :|
04:08:43 <ac> hm, so if I understand the type signature of #3, it should look like this: (a -> b) -> (a -> t) -> (b -> t)
04:08:51 * ivanm wishes there was a way of not having a legend for a particular plot in the Chart library :s
04:08:53 * Axman6 reads logs
04:08:56 <BONUS> yeah
04:09:08 * ac thinks
04:09:09 <BONUS> (->) a b is another way of writing a -> b
04:09:15 <BONUS> wait ac no
04:09:15 <BONUS> its
04:09:19 <BONUS> t -> a and t -> b
04:09:20 <dibblego> ac, other way around
04:09:23 <Axman6> yeah, i see that now
04:09:27 <ac> ah ok
04:09:35 <dibblego> (->) is a type constructor of kind * -> * -> *
04:09:44 <dibblego> ((->) t) is a type constructor of kind * -> *
04:09:45 <BONUS> think aobut how (+) 3 4 is like 3 + 4
04:09:55 <BONUS> so (->) a b is like a -> b
04:10:37 <Axman6> hmm. htf does that one work
04:10:44 <ac> BONUS: right. Ok, so now I implement this. (I'm not familiar with the reader monad, so I'm going to ignore that hint)
04:10:48 <Axman6> (a -> b) -> (a -> t) ->  (b -> t) :|
04:11:11 <Axman6> oh, hmm
04:11:15 <dibblego> @type fmap
04:11:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:11:23 <dibblego> now replace f with t ->
04:11:31 <dibblego> (a -> b) -> (t -> a) -> (t -> b)
04:12:35 <Axman6> furry f t = t . f ? :\
04:13:04 <dibblego> does it satisfy identity and composition?
04:13:28 <Axman6> i don't know... does it? not totally sure what you mean
04:13:44 <BONUS> when something is a functor, there are two laws it should satisfy
04:13:48 <Axman6> wait, no
04:13:59 <ac> uhm... can't it just be '(.)'?
04:14:08 <dibblego> maybe :)
04:14:14 <ac> that type checks
04:14:15 <BONUS> hint: yes
04:14:26 <dibblego> certainly if it satisfies the functor laws
04:14:40 <dibblego> furry id = id
04:14:57 <ac> so where's that already implemented?
04:15:00 <dibblego> furry (f . g) == furry f (furry g) -- something like that (I am stoned on painkillers, sorry)
04:15:13 <ac> nm, that question doesn't make sense
04:15:15 <BONUS> ac: Control.Monad.Instances
04:15:42 <BONUS> furry (f . g) = furry f . furry g
04:15:43 <BONUS> i think
04:15:48 <Axman6> ah ha, yeah (.) does work, and i see how. hurray
04:16:33 <ac> BONUS: so you're saying Control.Monad.Instances actually does implement fmap for '(->) t'?
04:16:39 <BONUS> yeah
04:16:48 <BONUS> also Monad
04:17:02 <BONUS> (->) t is also a Monad, which is really kewl
04:17:09 <BONUS> > join (*) 8
04:17:11 <lambdabot>   64
04:17:25 <quicksilver> actually it can't fail to satisfy those laws, I don't think
04:17:26 <Axman6> i still find that messed up
04:17:36 <ac> Axman6: yeah, makes my head hurt
04:17:48 <dibblego> it's also an Applicative (which is in between Functor and Monad) - which happens to be the S combinator
04:17:48 <quicksilver> because (->) actually *is* a functor, any attempt to write furry with the right type, will satisfy the laws
04:17:56 <quicksilver> theorems for free / parametric polymorphism.
04:18:09 <quicksilver> (_|_s aside)
04:18:14 <Olathe> furry = const 0
04:18:15 <BONUS> really? i didnt know that
04:18:18 <ac> Functor is more or less specific than Monad?
04:18:18 <Olathe> It's so obvious.
04:18:23 <quicksilver> Olathe: doesn't have the right type.
04:18:26 <BONUS> more general
04:18:43 <quicksilver> (a -> b) -> (a -> t) ->  (b -> t)
04:18:44 <BONUS> Functor more or less means something that can be mapped over
04:18:48 <quicksilver> you have to have exactly this type.
04:18:56 <BONUS> t -> a and t -> b imho
04:18:57 <quicksilver> and there is only one option, in haskell, because of parametricity.
04:18:59 <quicksilver> which is clever.
04:19:08 <quicksilver> BONUS: sorry, I copy-pasted the wrong line :)
04:19:11 <BONUS> hehe
04:19:11 <Olathe> Ahh, I missed the type.
04:19:32 <ac> @src Functor
04:19:32 <lambdabot> class  Functor f  where
04:19:32 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
04:21:33 <ac> which is the exact same type as furry
04:21:44 <Axman6> ok, the Fluffy (EitherLeft t) one manes no sense to me. i don't know what it's asking for
04:22:01 <ac> Axman6: it's asking to implement fmap for EitherLeft ;)
04:22:06 <dibblego> ac, furry is a euphemism for fmap and Fluffy is a euphemism for Functor (sorry, you may alreayd know that)
04:22:14 <ac> dibblego: yeah
04:22:19 <Axman6> oh, well that's pretty easy isn't it?
04:22:38 <dibblego> take a look at the kind for Either
04:22:40 <dibblego> @kind Either
04:22:42 <lambdabot> * -> * -> *
04:22:47 <dibblego> there are two functors
04:22:52 <dibblego> Either t
04:22:56 <dibblego> and (flip Either) t
04:23:14 <dibblego> they are EitherLeft and EitherRight
04:23:43 <Olathe> @djinn (a -> b) -> [a] -> [b]
04:23:44 <lambdabot> Error: Undefined type []
04:23:51 <Olathe> OK.
04:23:58 <Olathe> @djinn (a -> b) -> m a -> m b
04:23:59 <lambdabot> -- f cannot be realized.
04:24:07 <Olathe> That thing is no help at all.
04:24:56 <ac> their's a kind mismatch here... Either takes two types
04:25:02 <ac> *there's
04:25:03 <Axman6> yeah
04:25:08 <Axman6> i don't get how that works
04:25:09 <mapreduce> @djinn (Monad m) => (a -> b) -> m a -> m b
04:25:09 <lambdabot> Error: Class not found: Monad
04:25:15 <SamB_XP> hah!
04:25:27 <ac> can all of these be solved with djinn BTW?
04:26:55 <mapreduce> I think the answer is yes, but you have to rephrase them.
04:27:22 <ac> ah there is not a kind mismatch, because the type is '(EitherLeft t)'
04:27:54 <Axman6> why is it not EitherLeft t u?
04:28:48 <Axman6> ah, i think i get it
04:29:20 <Axman6> nope -_-
04:29:31 <Twey> Hmn?
04:29:37 <Twey> What's up, Axman6?
04:30:26 <Axman6> problem 4 on http://blog.tmorris.net/20-intermediate-haskell-exercises/
04:30:37 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª 20 Intermediate Haskell Exercises
04:30:49 <dibblego> ac, many of them can, but not all
04:31:04 <ac> Axman6: think I'm close... seems like you should be able to use 'either' from Data.Either somehow
04:31:06 <dibblego> (theoretically that is, as quicksilver said about the (->) t functor)
04:31:19 <Cale> Axman6: Fluffy takes a type constructor
04:31:23 <Twey> Oo-er
04:31:27 <Beelsebob> quicksilver: oops, we fail at searching bug reports -- it's been fixed :)
04:31:51 <Cale> Axman6: remember that if Fluffy f, then we have furry :: (a -> b) -> f a -> f b
04:32:18 <Cale> So f must be something which can be applied to one more type parameter.
04:32:36 <Cale> Axman6: does that help?
04:32:37 <quicksilver> Beelsebob: heh.
04:32:46 <Axman6> not really. i think i got that part
04:32:48 <quicksilver> Beelsebob: ah well, our hearts are in the right place.
04:33:06 <Cale> So in this case, if we're to have Fluffy (EitherLeft t), then furry :: (a -> b) -> EitherLeft t a -> EitherLeft t b
04:33:08 <quicksilver> win 20
04:33:13 <quicksilver> lose 30 :(
04:33:22 <Beelsebob> quicksilver: :)
04:33:24 <Axman6> oh, i see
04:34:04 <Axman6> but not really. rawr
04:34:06 <quicksilver> Beelsebob: at least we were only 2 days behind the curve on that one.
04:35:17 <ac> Axman6: yeah, I'm still working on it too
04:35:37 <Axman6> Cale: i don't get what needs to be changed firstly. and i'm guessing that i need two versions, for EitherLeft (Left a) and (Right a)?
04:35:38 <ac> Axman6: #4 should have a higher difficulty than #3
04:35:58 <Axman6> indeed. i think i'll move on to others for now (like [], easy... iv you've seen the def :P)
04:36:16 <dibblego> why do you think it should be of a higher difficulty?
04:36:50 <Cale> Axman6: You need to handle both possible cases, yes.
04:37:02 <SamB_XP> what about warm and Fuzzy ?
04:37:23 <Axman6> dibblego: because it's difficult... :)
04:37:29 <Cale> Axman6: There are very few things which will typecheck and not be a correct solution :)
04:38:08 <Cale> So if you have a fair understanding of what types things should be, you can figure out where to get things of those types, and it should lead you directly to the solution :)
04:38:21 <mnislaih> @seen gwernBranwen
04:38:21 <lambdabot> I haven't seen gwernBranwen.
04:38:25 <mnislaih> @seen gwern
04:38:25 <lambdabot> I saw gwern leaving #haskell 3d 18h 21m 11s ago, and .
04:38:43 <Axman6> Cale: i guess i don't have that then
04:38:51 <SamB_XP> ""?
04:38:55 <dibblego> I think apple is perhaps the only example where there are two "intuitive" but inequivalent solutions
04:38:57 <SamB_XP> what does she mean by that?
04:39:26 <Cale> Axman6: Where are you getting stuck?
04:39:32 <ac> I'm thinking #4 should be: furry :: (a -> b) -> (EitherLeft t a) -> (EitherLeft t b) -- but I keep writing functions with infinite types
04:39:50 <Cale> ac: That's right, it should.
04:40:10 <dibblego> ac, you can verify that you at least have the types right by using error as the implementation
04:40:11 <SamB_XP> ac: you must be doing something wrong ;-P
04:40:13 <Axman6> oh, i think i get it now...
04:40:27 <dibblego> or not (can you put a type declaration on an instance?)
04:40:53 <Axman6> would  the (a -> b) part take Left a and Right a?
04:41:29 <Axman6> s/and/or
04:41:34 <Cale> Axman6: Think of it this way... furry is passed a function of type (a -> b), and an EitherLeft t a
04:41:56 <Cale> That is, either  EitherLeft (Left x)  where x :: t
04:42:08 <Cale> Or EitherLeft (Right y)  where y :: a
04:42:18 <Axman6> seems like it should just be furry f (EitherLeft a b) = EitherLeft a (f b)
04:42:20 <Cale> The goal is to produce something of type EitherLeft t b
04:42:30 <Axman6> ah right. ok
04:42:32 <niklaus> can anyone help what is the number of ways 31 can be written as sum of primes,answer is 111, how do we get this by euler transform. in haskell i can get the answer by writing a recurrence
04:42:35 <Cale> Axman6: The EitherLeft data constructor doesn't have two parameters
04:43:23 <ScottMichael> let tops = map (\r -> m M.! (idn r)) reviews
04:43:27 <ScottMichael> print tops
04:43:33 <ScottMichael> map (\r -> m M.! (idn r)) reviews >>= print
04:43:35 <ScottMichael> no go
04:43:46 <ScottMichael> why not?
04:43:46 <Axman6> ok, i get it now...
04:43:52 <ScottMichael>  Couldn't match expected type `IO' against inferred type `[]'
04:44:06 <ScottMichael> cant i combine it into one step?
04:44:19 <Cale> ScottMichael: map f reviews  will be a list.
04:44:32 <Cale> ScottMichael: not an IO action, so it can't be on the left of >>=
04:44:41 <Cale> ScottMichael: What you probably want is mapM
04:44:47 <Cale> er...
04:44:50 <Cale> actually no :)
04:45:12 <Cale> What you probably want is print (map ...)
04:45:44 <Cale> You're just defining a constant and then using it on the next line, so you can splice in its definition. :)
04:45:54 <Axman6> well, got somewthing that type checks
04:46:06 <Cale> Axman6: Then it is almost certainly right :)
04:46:44 <Axman6> heh, no show instance
04:46:49 <ScottMichael> lol true
04:46:51 <ScottMichael> print $
04:47:34 <Cale> niklaus: could you clarify that a bit?
04:47:56 <araujo> malcolmw, ping
04:48:23 <quicksilver> ScottMichael: you need >>= where you had <-
04:48:27 <niklaus> Cale, like 10 = 3+7 , 3+2+5, 5+5 ,etc
04:48:30 <Cale> niklaus: Why do you believe the result can be obtained by the Euler transform of some generating series?
04:48:31 <quicksilver> ScottMichael: but, if you only have "let .. ="
04:48:39 <quicksilver> ScottMichael: then you just substitute the whole expresion
04:48:43 <quicksilver> ScottMichael: does that explain teh difference?
04:48:55 <ScottMichael> yes
04:49:08 <Cale> niklaus: (Other than the fact that the Euler transform is self-inverse)
04:49:12 <niklaus> Cale, actually in one of the forum posts i saw it
04:49:14 <ac> hm... this seems to work: eitherLeft f (EitherLeft (Left a)) = EitherLeft $ Left $ f a; furry = eitherLeft
04:49:22 <Axman6> *Main> furry (+1) (EitherLeft (Left 2))
04:49:22 <Axman6> EitherLeft (Left 3)
04:49:30 <Axman6> *Main> furry (+1) (EitherLeft (Right 2))
04:49:30 <Axman6> EitherLeft (Right 2)
04:49:40 <niklaus> Cale, i really have no clue except i usually such posts from that author is true
04:49:45 <Axman6> i don't think that's right somehow... but i could be wrong?
04:51:01 <dibblego> Axman6, looks right to me
04:51:07 <Axman6> hmm.
04:51:23 <Cale> niklaus: Just to check that we're talking about the same thing... do you mean the transform which sends sum over k >= 0 of a_k x^k to sum over k >= 0 of s_k x^k where s_k = sum over n = 0 to k of (-1)^n (k;n) a_k, and (k;n) is the binomial coefficient?
04:52:11 <Axman6> so "furry f (EitherLeft (Left x)) =  EitherLeft (Left (f x))" would be correct then?
04:52:25 <ScottMichael> which is the best library to do graphics in ahskell?
04:52:27 <dibblego> yes, map the function on the Left side
04:52:28 <ScottMichael> does  haskell come with opengl?
04:52:33 <dibblego> and the Right should be identity
04:52:35 <ScottMichael> iw ant 2d/3d
04:52:40 <Axman6> ScottMichael: HOpenGL
04:52:53 <Cale> ScottMichael: GHC typically comes with an OpenGL library
04:53:05 <Cale> If not, you can get it from hackage.
04:53:23 <ScottMichael> and should be easy to use
04:53:25 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL
04:53:26 <lambdabot> Title: HackageDB: OpenGL-2.2.1.1
04:53:42 <niklaus> Cale, i think so but i fail to see a connection, where are they generally used
04:53:50 <niklaus> Cale, in what context
04:56:20 <humasect> hm, where is 6.10 rc ? ^_^
04:57:16 <quicksilver> ScottMichael: most people do not find OpenGL easy to use :)
04:57:24 <SamB_XP> yeah
04:57:33 <quicksilver> however the haskell binding is quite nicely typed and I like it.
04:57:35 <ac> ok, so I've got an implementation for 'EitherLeft t'... so where's the predefined implementation?
04:57:46 <Cale> niklaus: Well, I'm not sure what this problem has to do with the Euler transform at all.
04:57:46 <SamB_XP> it's rather imperative in general ...
04:58:11 <humasect> its easy to wrap OpenGL into a type
04:58:25 <Cale> niklaus: The Euler transform gives you the "nth forward differences" of a sequence, but I don't see how that's useful here.
04:58:27 <ScottMichael> Graphics.UI.Gtk' is what iw ant ?
04:58:33 <quicksilver> well that's Gtk
04:58:37 <Cale> niklaus: Maybe some kind of inclusion-exclusion thing?
04:58:39 <quicksilver> which is not openGL, but it is a nice thing :)
04:58:42 <quicksilver> maybe you'd like it.
04:59:30 <SamB_XP> ScottMichael: what did you want to use the library for ?
04:59:31 <Cale> niklaus: If I was to write down a generating series, the first thing that would come to mind is that the number we're after is the coefficient of x^111 in the product over primes p of 1/(1-x^p)
04:59:32 <niklaus> Cale, thanx
04:59:33 <ac> if it was plain Either instead of EitherLeft, I could say: furry f e = either f id e -- or something close to that
04:59:48 <Axman6> @src Either fmap
04:59:48 <lambdabot> fmap _ (Left x) = Left x
04:59:49 <lambdabot> fmap f (Right y) = Right (f y)
05:00:37 <ac> :t fmap Either
05:00:39 <lambdabot> Not in scope: data constructor `Either'
05:00:52 <Axman6> :t Either fmap
05:00:53 <lambdabot> Not in scope: data constructor `Either'
05:01:00 <Axman6> bah
05:01:04 <SamB_XP> hey, does anyone know a good mnemonic for quaternian multiplication ?
05:01:11 <ScottMichael> is it a 3d library?
05:01:14 <ac> I know there's a way to look at the type signature of an instance
05:01:28 <quicksilver> ij = k is all you need to remember isn't it/
05:01:29 <SamB_XP> ScottMichael: what are you looking to write ?
05:01:30 <Axman6> :t fmap :: Either
05:01:32 <lambdabot>     `Either' is not applied to enough type arguments
05:01:32 <lambdabot>     Expected kind `?', but `Either' has kind `* -> * -> *'
05:01:32 <lambdabot>     In an expression type signature:
05:01:33 <ScottMichael> sam: draw soem graphs, visualizing data, later perhaps a 3dgame
05:01:33 <quicksilver> ScottMichael: and that's alphabetical
05:01:40 <Axman6> :t fmap :: Either a b
05:01:42 <lambdabot>     Couldn't match expected type `Either a b'
05:01:42 <lambdabot>            against inferred type `(a1 -> b1) -> f a1 -> f b1'
05:01:42 <ScottMichael> but thats later...
05:01:49 <quicksilver> SamB_XP: and that's alphabetical
05:01:53 <quicksilver> ScottMichael: (sorry)
05:01:54 <SamB_XP> ScottMichael: three-d graphs ?
05:02:00 <Cale> niklaus: Because the set of partitions into primes decomposes as an infinite product: product over primes p of {p}*, where the set {p}* is just {(), (p), (p,p), ...}. That is, you decide how many times you'd like to pick each prime, and the weights add. (We're using ordinary, rather than Dirichlet generating series)
05:02:05 <ScottMichael> quick: huh?
05:02:07 <Axman6> damn it lambdabot
05:02:20 <quicksilver> Axman6, ac: there isn't. YOu can look at the src for some of them.
05:02:28 <SamB_XP> what's alphabetical ?
05:02:29 <quicksilver> to look at the type-sig for an instance you need to annotate it
05:02:34 <quicksilver> SamB_XP: ij = k
05:02:41 <quicksilver> (and that's all you need to remember, I think)
05:02:45 <ScottMichael> sam: nah mostly 2d but if 3d is possible good. really what im looking for is the easiest way to do simple graphics in haskell. like if u know python, pygame
05:02:49 <quicksilver> doesn't everything else follow?
05:02:57 <ScottMichael> however pyagem is pretty big so i odnt expect that to exist for haskell
05:03:02 <ScottMichael> ill look into gtk or sdl
05:03:06 <SamB_XP> ScottMichael: oh, you want HSDL or something ?
05:03:18 <niklaus> Cale, maybe i've to study all that , tnx for help
05:03:23 <SamB_XP> pygame is, after all, overgrown SDL bindings ;-P
05:03:28 <humasect> there is a hw accel 2d engine and game tools in dev, but i cant talk about it
05:03:42 <humasect> ah, good
05:03:43 <SamB_XP> humasect: you just did
05:03:51 <humasect> did i?
05:03:55 <SamB_XP> humasect: signed an NDA or something?
05:04:09 <humasect> kind of like that
05:04:16 <SamB_XP> humasect: you said that it's under development!
05:04:28 <humasect> yep, but maybe that is mostly all i can say=)
05:04:34 <ScottMichael> boya at leats opengl i icnluded in haskell
05:04:35 <Cale> niklaus: So if I ask my computer algebra system to extract the coefficient for me, I get that there are 83447 ways to write it, provided that I haven't made a mistake (I've been up a long while :)
05:04:58 <Axman6> ScottMichael: man, your typing's worse than mine :P
05:05:03 * SamB_XP is just giving humasect a hard time about saying "I can't talk about it" while talking about it ;-)
05:05:04 <ac> where is fmap for Either defined?
05:05:09 <humasect> hehe=)
05:05:12 <Cale> niklaus: Oh, write *31* as a sum of primes
05:05:25 <Cale> Yes, I get 111
05:05:32 <humasect> ac: GHC.Base ^_^
05:05:43 <niklaus> Cale, which algebra system do you use
05:05:45 <Cale> SeriesCoefficient[Product[1/(1 - x^Prime[n]), {n, 1, PrimePi[31]}], {x, 0, 31}] --> 111
05:05:49 <Cale> Mathematica.
05:05:49 <SamB_XP> what is this, some project euler problem ?
05:06:07 <humasect> ac: look in Prelude for class Functor
05:06:07 * SamB_XP recommends mathemantica
05:06:14 * Axman6 got mathematica for free
05:06:19 <humasect> ac: and Data.Either
05:06:26 <SamB_XP> Axman6: HOW!
05:06:40 <Cale> SamB_XP: Often universities can give you a copy.
05:06:43 <niklaus> Cale, how do we do the same in haskell
05:06:44 <Axman6> our uni has a licence which allows them to give it to students
05:06:59 <Axman6> must've cost an arm and a leg
05:07:00 <SamB_XP> man, I wish mine had bought that one
05:07:08 <quicksilver> humasect: it's not in the Prelude or Data.Either.
05:07:13 <quicksilver> humasect: it's in Control.Monad.Error :)
05:07:17 <SamB_XP> but NOOO, students only get to use it on-campus
05:07:19 <Cale> niklaus: We'd need a library for generating series, which is altogether possible to write.
05:07:29 <humasect> data Either a b = Left a | Right b 	-- Defined in Data.Either   -- says ghci
05:07:30 <Axman6> SamB_XP: not us :)
05:07:37 <SamB_XP> I'm pretty sure wolfram's website told me that ;-)
05:07:38 <quicksilver> humasect: he asked about fmap.
05:07:52 <Cale> niklaus: In fact, there might be something available on Hackage. This isn't really much better than brute force though.
05:08:00 <humasect> yep. fmap is in class Functor which is in Prelude is it not? or GHC.Base, which was my first reply
05:08:10 <quicksilver> humasect: fmap for either is in Control.Monad.Error
05:08:15 <Axman6> pretty sure our uni has a special licence, which differs from the normal institution one
05:08:17 <quicksilver> it is not in the Prelude, not in Data.Either.
05:08:17 <humasect> ohh
05:08:29 <humasect> i did not know it was for Either.
05:08:32 <quicksilver> ;)
05:08:38 <quicksilver> 13:05 < ac> where is fmap for Either defined?
05:08:53 <Cale> actually, I wonder.
05:08:54 <Beelsebob> it's not fmap for either though
05:08:55 <SamB_XP> Axman6: there are several standard flavours
05:08:59 <Beelsebob> it's fmap for Either String
05:09:00 <humasect> why do i only come here when i am retarded, deaf, and blind?=)
05:09:04 <Beelsebob> (aka Error)
05:09:41 <quicksilver> Beelsebob: I think it's fmap for Error e => Either e
05:09:46 <quicksilver> Beelsebob: if we're going to be pedantic :)
05:09:50 <Beelsebob> hehe
05:09:53 <Beelsebob> fair enough
05:09:54 <quicksilver> but commonly one might call that fmap for Either.
05:09:56 <SamB_XP> humasect: so you can't read our messages ?
05:10:02 <quicksilver> humasect: to amuse us? :)
05:10:10 <humasect> i am blind but not illiterate yet=)
05:10:16 <Beelsebob> quicksilver: I dislike that because there are two obvious definitions of fmap for Either
05:10:22 <humasect> hehe, yep quicksilver
05:10:39 <humasect> > fmap (+5) (4,5)
05:10:41 <lambdabot>   (4,10)
05:10:46 <Axman6> :|
05:10:52 <Beelsebob> it's a shame we can't define constructor synonyms
05:10:57 <humasect> how come it is not doing to the first part of (,) ? what is the use ?
05:11:04 <ac> ah, I can "cheat" with #5 like so: cheatEitherRight f (EitherRight e) = EitherRight $ fmap f e
05:11:05 <Beelsebob> it'd be nice to be able to define Error = Left and Good = Right
05:11:13 <ac> just have to import Control.Monad.Error
05:11:16 <humasect> Beelsebob: that really can't be done ? not even with newtype ?
05:11:29 <Beelsebob> humasect: how would one do it with newtypes
05:11:35 <Axman6> ac: bah, totally missing the point :P
05:11:37 <Beelsebob> newtype is for creating new types, not new constructors
05:11:43 <humasect> i am not sure, i have never used newtype.
05:11:49 <ac> Axman6: well you can't cheat for EitherLeft, because it flips it
05:12:01 <humasect> i've always tried to make synonyms and just thought it was my error that it didn't work. what is "type" for anyway ?
05:12:10 <ac> Axman6: the default fmap maps the Right side and not the Left side
05:12:12 <ScottMichael> GLUT: Warning in <interactive>: The following is a new check for GLUT 3.0; update your code.
05:12:12 <ScottMichael> GLUT: Fatal Error in <interactive>: redisplay needed for window 1, but no display callback.
05:12:15 <ScottMichael> hmmpf
05:12:20 <Beelsebob> humasect: type is for creating type synonyms
05:12:24 <Beelsebob> not constructor synonyms
05:12:25 <humasect> ScottMichael: set displayCallback $= ..
05:12:33 <ac> There should be an fmapLeft in Control.Monad.Error
05:12:35 <Botje> type Vector = (Int, Int, Int)
05:12:36 <Botje> and such
05:13:16 <humasect> ah, right right.   and type Something = Either String Int ?
05:13:26 <humasect> isn't that a good synonym for constructor ?
05:13:35 <Botje> it's only a type synonym
05:13:41 <Botje> you don't get a data constructor
05:13:46 <quicksilver> the defaul fmap could only possibly map the Right
05:13:47 <humasect> hm yes i see.
05:14:00 <quicksilver> due to the way type application and functors work in haskell.
05:14:10 <humasect> it would be very useful to add types ..
05:14:46 <humasect> quicksilver: but one can use fmap however they want, right ? there is no special syntax or any code that relies on their use, in base at least, right ?
05:15:03 <quicksilver> not much relies on fmap, that'true
05:15:10 <quicksilver> but that doesn't help you write a left-version of it
05:15:16 <quicksilver> its type forces it to be a right-version
05:15:26 <humasect> sure fmap f (a,b) = (f a,f b)
05:15:36 <quicksilver> we're talking about Either.
05:15:38 <quicksilver> not pairs.
05:15:48 <quicksilver> but the pair thing doesn't work, in fact.
05:15:55 <quicksilver> for the same reason.
05:15:56 <humasect> but fmap always works on rights
05:16:00 <quicksilver> pair-fmap also has to be right
05:16:04 <quicksilver> for exactly the same reason.
05:16:13 <quicksilver>  fmap f (a,b) = (f a,f b) won't typecheck.
05:16:15 <humasect> what reaason?
05:16:19 <humasect> oh, is that so
05:16:23 <Botje> @type fmap
05:16:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:16:26 <humasect> because ((,) a) is the def ?
05:16:31 <Botje> yes
05:16:34 <humasect> hmm~
05:16:42 <quicksilver> Functor is a type-class for type constructors of kind :: * -> *
05:16:45 <SamB_XP> @type \f (a,b) -> (f a, f b)
05:16:47 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
05:16:51 <quicksilver> the type (a,b), which is really (,) a b
05:16:55 <ScottMichael> humasect set displayCallback $= ..  ?
05:17:00 <quicksilver> is only composed of a :: * -> * in one way
05:17:02 <quicksilver> which is
05:17:06 <ScottMichael> i just started so i have no ieda what to do
05:17:08 <quicksilver> ((,) a) b
05:17:10 <humasect> ScottMichael: yep glut is complaining at you that there is no display callback set for the window
05:17:27 <humasect> ah, hmm
05:17:29 <quicksilver> ScottMichael: start with an example application
05:17:31 <ScottMichael> any simpel thing i could set it to?
05:17:33 <quicksilver> don't start from scratch
05:17:36 <quicksilver> your head will explode.
05:17:39 <humasect> ScottMichael: yep, displayCallback $= return ()
05:17:43 <quicksilver> there is an opengl tutorial on the wiki you could start with
05:17:51 <quicksilver> and jason dagit did some of the nehe-tuts for haskell, too
05:17:53 <humasect> hopengl is a bad idea to start with, really
05:18:02 <ScottMichael> thanks i will i just saw this example and saw i could get a window up
05:18:03 <humasect> except with the tutorial mentioned
05:18:13 <quicksilver> http://www.haskell.org/haskellwiki/OpenGLTutorial1
05:18:14 <lambdabot> Title: OpenGLTutorial1 - HaskellWiki
05:18:30 <humasect> what is the common use of monoids? `mappend` ?
05:18:38 <quicksilver> humasect: you can of course newtype things to get the other Functors.
05:18:45 <Axman6> i find that tutorial kind of lacking tbh. i want to know what else i can do with HOpenGL
05:18:49 <humasect> monad syntax are special to just monads/monadplus, which both much 'contain' something
05:18:52 <quicksilver> humasect: but (,) and Either themselves can only be Functors rightwise.
05:19:02 <quicksilver> Axman6: it's only to get you started.
05:19:06 <humasect> Axman6: look for *actual* opengl tutorials =)
05:19:16 <humasect> then you will need to translate them to hopengl, if you can bear it
05:19:17 <quicksilver> Axman6: once you get the hang of it, you should just follow ordinary opengl tuts written in C or C++
05:19:23 <ScottMichael> ok bi got the window up it doesnt terminate as it should. but now i have soemwheer to start
05:19:28 <Axman6> haven't managed to find any really(but haven't looked very hard)
05:19:32 <ScottMichael> but you suggets i start with gtk or sdl instead?
05:19:32 <quicksilver> Axman6: and laugh at the ridiculous hoops the C or C++ programmer has to jump through.
05:19:41 <Axman6> hehe
05:19:44 <quicksilver> the net is awash with opengl tuts
05:19:48 <quicksilver> try nehe or the wikibook
05:19:54 <humasect> ScottMichael: glut on osx isn't so great, if that is what you are using, it may never 'close correctly' unless with apple-q
05:20:21 <Cale> http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1/
05:20:23 <ScottMichael> windows
05:20:24 <lambdabot> Title: Michi‚Äôs blog ¬ª Blog Archive ¬ª OpenGL programming in Haskell - a tutorial (pa ..., http://tinyurl.com/ea6tc
05:20:43 <Cale> (also note part 2 and 3 on that blog)
05:21:14 <humasect> ah.. if mainLoop is the last thing called, then hopengl may make that impossible period
05:21:49 <humasect> ScottMichael: what would you like to do?
05:21:58 <Cale> humasect: make what impossible?
05:22:38 <humasect> Cale: i mean to say, if mainLoop is the last call in the application (main), and it doesn't quit cleanly, by apple-q, alt+f4, or close button, then there is nothing else one can do, without freeglut
05:23:27 <Cale> ah yeah, you need to do something in a callback to tell it to quit properly.
05:23:35 <humasect> they are not supported without freeglut
05:23:50 <quicksilver> yes, GLUT is for toys.
05:24:03 <quicksilver> consider it a useful toolkit to hack something quick together without pulling in another library dependency.
05:24:13 <quicksilver> for anything 'real' you will want a better mainloop.
05:24:14 <humasect> ^_^
05:24:21 <quicksilver> it *is* handy for quick hacks though.
05:24:24 <humasect> i have yet to look at GLFW
05:24:38 <humasect> but sdl is very nice and rock solid
05:24:53 <humasect> (both are alternatives for opengl useage, for others )
05:25:09 <quicksilver> yes, glfw/sdl/wx/gtk are your haskell options
05:25:17 <quicksilver> for a more capable shell around opengl
05:25:27 <quicksilver> wx/gtk are probably only sensible choices if you also want to use their toolkits.
05:25:29 <humasect> without ghci, of course
05:25:33 <Cale> humasect: By the way, monoids are everywhere. Addition and multiplication of different kinds of numbers provide lots of examples. Also, concatenation of strings, the set of functions from any type to itself (under composition).
05:25:45 <quicksilver> although I've been known to pull in wx for its image loading and font rendering facilities
05:26:01 <ac> I played Braid today... anybody seen that game?
05:26:10 <humasect> Cale: monoids in theory, or actual Monoid, with mappent/mempty/mconcat ?
05:26:23 <Axman6> ac: have you had a look at Exercise 6?
05:26:24 <humasect> mother kraid?
05:26:27 <Cale> humasect: both
05:26:31 <ac> Axman6: I'm still beating #4 to death
05:26:44 <Axman6> heh, ok :)
05:26:56 <ac> Axman6: actually, I finished that, and I'm making comments for each one on which module to import to get the appropriate fmap
05:27:05 <subconscious> ac: looks like it was written in the 90s
05:27:06 <Cale> humasect: The Monoid class is rather handy in conjunction with things like Writer/WriterT, or Data.Foldable.
05:27:09 <humasect> Cale: hm, i wrote a monoid for the type composable gl wrapper, but not sure how to start applying it. i haven't anywhere to start, so i have been composing plain lists
05:27:10 <malcolmw> araujo: pong
05:27:11 <Axman6> heh, ok
05:27:23 <ac> subconscious: Braid? No way... have you played it?
05:27:25 <humasect> Cale: ah, i see, i will look at Foldable again
05:27:32 <Axman6> i've realised what most of them have been so far. which i probably a good sign
05:27:50 <quicksilver> ac: doesn't that rather spoil the game?
05:28:14 <ac> quicksilver: I'm doing it for future reference
05:28:19 <quicksilver> ac: (or did you not mean comment on the blog?)
05:28:23 <Cale> humasect: For instance, if you take the monoid to be multiplication, then WriterT over list, together with the convention that the sum of the numbers attached to the elements of any list you give is 1 gives you a "probability monad"
05:28:39 <ac> quicksilver: I was going to make a comment on the blog with all of those, because they're not obvious. I'll give a spoiler warning
05:28:59 * quicksilver shrugs
05:29:15 <quicksilver> well when I looked at that blog it was immediately obvious to me which wellknown haskell typeclasses it is about
05:29:17 <Cale> Of course, the most common monoid to use with Writer/WriterT is something like lists of strings under concatenation, for logging.
05:29:30 <humasect> Cale: ohh~~ interesting indeeed
05:29:31 <Cale> humasect: Another really good example is Finger Trees.
05:29:31 <quicksilver> but I assumed that it was not nice to give the game away
05:30:41 <Cale> humasect: Finger Trees are a kind of tree datastructure which is parametrised on a (specific kind of) monoid. By picking different monoids, you can get all kinds of fancy things, from fast sequences (Data.Sequence) to priority queues, to interval sets.
05:31:10 <humasect> that sounds like just the thing i need at this very moment ! hm=)
05:31:27 <Cale> You often obtain the best available asymptotic complexity for implementing those things too, which is pretty cool :)
05:31:33 <quicksilver> Cale: if only that was exposed.
05:31:38 <humasect> asymptotic you say..
05:31:48 <quicksilver> Cale: (I mean if only the code for Data.Sequence exposed a nice fingertree polymorphic in its measure)
05:31:49 <Cale> (and decent practical speed)
05:31:52 <humasect> quicksilver: there is a hidden finger tree in base ?
05:31:58 <Cale> Yes.
05:31:58 <humasect> ahh
05:31:58 <quicksilver> yes, it's in Data.Sequence
05:32:11 <quicksilver> but it's special-cased that that case.
05:32:17 <ac> huh, you don't actually have to import any of those modules to use fmap if you use "ghc --make". Why is that?
05:32:21 <Axman6> rawr! i just can't get Exercise 6 :(
05:32:35 <quicksilver> so you dont' see the beautiful polymorphism in Monoid.
05:32:37 <Cale> But you can get the general one from Data.Sequence... the nice examples are all in the paper though, and not implemented :(
05:32:47 <Cale> Er, I meant to say...
05:32:48 <subconscious> We expect to release GHC 6.10 around ICFP 2008.
05:32:48 <subconscious> Release candidate: Friday 19th September 2008.
05:32:52 <Cale> From Hackage
05:32:52 <ac> because the name is imported in Prelude, and 'ghc --make' just figures out what to link to?
05:33:04 <Axman6> seems as if i need something that's (m a -> a)
05:33:05 <humasect> http://hpaste.org/10513
05:33:09 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
05:33:11 <lambdabot> Title: HackageDB: fingertree-0.0, http://tinyurl.com/35pz7w
05:33:37 <humasect> Axman6: more info?
05:33:54 <subconscious> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
05:33:55 <lambdabot> Title: Status/Releases - GHC - Trac
05:34:09 <subconscious> how do you get 6.10?
05:34:11 <Axman6> humasect: http://blog.tmorris.net/20-intermediate-haskell-exercises/
05:34:13 <lambdabot> Title: Œª Tony‚Äôs blog Œª ¬ª Blog Archive ¬ª 20 Intermediate Haskell Exercises
05:34:39 <Cale> Axman6: Which problem?
05:34:46 <Cale> 7?
05:34:50 <Axman6> 6
05:34:52 <araujo> hi there malcolmw
05:34:57 <Cale> oh
05:34:57 <quicksilver> 6 is rather a nice problem :)
05:35:05 <malcolmw> araujo: can you login yet?
05:35:06 <Axman6> and damn annoying
05:35:17 <Axman6> i can't think of a generic way of doing it
05:35:26 <Cale> Axman6: That annoyance is worth hacking at for a while :)
05:35:44 <Axman6> its (>>=) right?
05:35:48 <humasect> subconscious: it looks not released yet, as RC
05:35:50 <Cale> banana is.
05:35:57 <Cale> Or rather =<< is banana
05:35:58 <araujo> malcolmw, thanks for solving my issue with the ssh key, look, the problem was that copy/pasting my ssh key into the request box wasn't working good ... the white spaces of the key split into newlines and it was giving an error , can you check that?
05:36:00 <Axman6> what about furry' then? :\
05:36:05 <Cale> furry' is fmap
05:36:07 <humasect> so Data.Sequence is a more specific fingertree
05:36:17 <Axman6> :|
05:36:18 <Cale> humasect: yeah
05:36:22 <araujo> malcolmw, yeah, it is working now ... but now I am having problems using 'createtrac'
05:36:25 <Axman6> i get how furry is fmap...
05:36:26 <humasect> coolness
05:36:38 <Cale> Axman6: Okay, furry' is liftM, but same thing :)
05:36:45 <subconscious> so it's not possible to get?
05:36:48 <malcolmw> araujo: I don't look after createtrac - try dcoutts or Igloo
05:36:48 <humasect> hehe
05:37:01 <Axman6> Cale: ok, well i still can't see how to get it
05:37:02 <humasect> subconscious: we've been deceived=)
05:37:10 <humasect> subconscious: well it is still the 19th.
05:37:23 <Axman6> i mean, i can't just say furry' f (m a) = m (f a) right?
05:37:23 * araujo pings dcoutts & Igloo 
05:37:25 <ac> Axman6: ok, on to #5... ooh another Class
05:37:36 <Cale> Axman6: Okay... well, let's play around a bit with the parts we have.
05:37:39 <araujo> malcolmw, ok, thanks .. and can you check the ssh box issue?
05:38:09 <Igloo> araujo: What's the problem?
05:38:11 <Axman6> Cale: gimme a sec.. i can almost see it
05:38:20 <malcolmw> araujo: copy/paste is usually down to the operating system or browser, not the web form itself
05:38:23 <humasect> quicksilver: do you feel, Seq is stronger than lists, more strict, more cleaner/morespecific/faster/lessexpensive etc ? in this case, when recursive lists are used as composable sequences
05:38:29 <humasect> (and it is not a monad)
05:39:04 <araujo> malcolmw, using firefox here on Gentoo linux ... trying to edit the box, the white spaces split into newlines and the form wasn't being accepted
05:39:09 <araujo> Igloo, query?
05:39:15 <Axman6> oh, type checked :D
05:39:31 <Cale> Axman6: Okay, it's probably right then :)
05:39:39 <Axman6> Cale: pm? (so i don't ruin it for others...)
05:39:43 <ac> Axman6: hm... this looks suspiciously like a Monad, but it's not complete
05:39:51 <quicksilver> humasect: it's not stronger more or more expressive.
05:39:52 <Cale> Axman6: sure, I'll PM you the thought process I'd go through
05:39:59 <Cale> ac: It is complete. :)
05:40:01 <quicksilver> humasect: it is more performant but more complex.
05:40:12 <Cale> ac: But nothing is said about the laws :)
05:40:12 <humasect> ah, that makes sense. thanks
05:40:19 <malcolmw> araujo: I think Igloo wants to know what is failing with createtrac
05:40:43 <quicksilver> humasect: in particular O(1) cons at *both* ends, O(log n) append
05:40:51 <quicksilver> humasect: and O(log n) indexing.
05:41:01 <araujo> malcolmw, correct, just asking him if I could query him, anyway, it is giving me this error:
05:41:05 <araujo> $ createtrac himerge
05:41:05 <araujo> getgrnam failed: No such file or directory
05:41:05 <araujo> createtracdir failed at /usr/local/bin/createtrac line 14.
05:41:11 <humasect> ahh, that is useful. very very useful in this case
05:41:12 <araujo> Igloo, ^^
05:42:48 <Igloo> araujo: There is no himerge project
05:43:57 <ac> :t id
05:43:58 <lambdabot> forall a. a -> a
05:44:09 <ac> why can't I whisper lambdabot?
05:44:15 <quicksilver> you can /msg him
05:44:22 <quicksilver>  /msg lambdabot @type id
05:44:31 <quicksilver> (the short form :t doesn't work in PM, I have no idea why)
05:44:44 <ac> ah, that's what was confusing me
05:44:55 <BeelsebobWork_> quicksilver: her!
05:45:00 <BeelsebobWork_> what an insult to the poor bot :(
05:45:05 <BeelsebobWork_> @botsnack
05:45:05 <lambdabot> :)
05:45:19 <araujo> Igloo, ooh .. mm..
05:45:24 <araujo> Igloo, now I see
05:45:32 <ac> ok, so how is '(>>)' different from 'const'?
05:45:41 * araujo request one
05:45:43 <subconscious> :t (>>)
05:45:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:45:46 <subconscious> :t (const)
05:45:47 <lambdabot> forall a b. a -> b -> a
05:46:04 <ac> it's the same function with a little more restrictive type, right?
05:46:08 <subconscious> ac: no
05:46:11 <BeelsebobWork_> araujo: maybe you mean "how is (>>) different from liftM2 const"
05:46:16 <subconscious> ac: try  putChar 'x' >> putChar 'y'
05:46:23 <humasect> @type empty
05:46:24 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
05:46:25 <BeelsebobWork_> but even then they're not quite the same
05:46:27 <subconscious> ac: vs  const (putChar 'x') (putChar 'y')
05:46:40 <BeelsebobWork_> actually, yes they are
05:46:43 <BeelsebobWork_> liftM2 does run both
05:46:48 <humasect> do any lambdabot fancy features come into ghci ?
05:46:59 <humasect> and will ghci features be exposed into ghc api ?
05:47:00 <subconscious> humasect: all of them
05:47:13 <humasect> ah, @unpl and @pl and other fancy ones ?
05:47:19 <BeelsebobWork_> @pl fromJust . unsafePerformIO . (flip eval) [] . (++ (" :: " ++ showsTypeRep (head . snd . splitTyConApp . typeOf $ x) "")) $ cx
05:47:19 <lambdabot> fromJust (unsafePerformIO (eval (cx ++ " :: " ++ showsTypeRep (head (snd (splitTyConApp (typeOf x)))) []) []))
05:47:39 <BeelsebobWork_> @pl \x cx -> fromJust . unsafePerformIO . (flip eval) [] . (++ (" :: " ++ showsTypeRep (head . snd . splitTyConApp . typeOf $ x) "")) $ cx
05:47:40 <lambdabot> ((fromJust . unsafePerformIO . flip eval []) .) . flip (++) . (" :: " ++) . flip showsTypeRep [] . head . snd . splitTyConApp . typeOf
05:49:28 <ichigo> is anyone here familiar with ruby?
05:49:38 <araujo> ichigo, some here
05:51:29 <ac> ok, so 'banana' is '(>>=)' (with first two args swapped), and 'unicorn' is 'return', and "furry'" is 'liftM', but what about '(>>)'? You can't implement '(>>)' in terms of 'return' and '(>>=)' can you?
05:51:54 <BeelsebobWork_> sure you can
05:51:54 <subconscious> ac: (>>) is defined in terms of (>>=)
05:52:03 <subconscious> ac: and it is in a similar way to const
05:52:17 <ac> @src (>>=)
05:52:17 <lambdabot> Source not found. My brain just exploded
05:52:21 <jayaund> andr√©s?
05:52:25 <subconscious> :t \m f -> m >>= f
05:52:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:52:27 <ac> @src (>>)
05:52:28 <lambdabot> m >> k      = m >>= \_ -> k
05:52:43 <ac> aaaack that's an uggly def
05:52:49 <subconscious> ac: No it isn't
05:52:57 <ac> (it just looks line line noise at first glance)
05:52:59 <BeelsebobWork_> it is?
05:53:10 <ichigo> araujo: what do you think about the dynamic typing discipline of ruby?
05:53:20 <BeelsebobWork_> ac: that's why people defined it
05:53:29 <araujo> ichigo, oh well.. this kind of questions .. hah ...
05:53:33 <BeelsebobWork_> they needed that line noise lots
05:53:44 <Deewiant> would you have preferred "(>>) = (. const) . (>>=)"? :-P
05:53:51 <ichigo> hehe, yeah, I couldn't think of the exact question I wanted to ask
05:54:15 <araujo> ichigo, I prefer static typing languages, but dynamic typing has its room in this world too, I think ruby is one of the few sane dynamic languages out there
05:55:51 <ichigo> I've got a friend in the ruby on rails crowd which swears that the dynamic aspect lends an amazing freedom of expression
05:55:57 <BeelsebobWork_> Deewiant: liftM2 const
05:55:59 <ScottMichael> hmm the opengl tutorial on miachel johanssons blog is nice, easy to do simple things fast, thanks for the link, that is what i wanted
05:56:08 <quicksilver> ichigo: the only people who say that are people who don't understand static typing.
05:56:16 <quicksilver> which is not intended as a criticism
05:56:20 <ScottMichael> once you just get something up then the rest comes usually
05:56:40 <quicksilver> I don't understand tae kwon do, for example :)
05:56:47 <Twey> Heh
05:56:49 <Deewiant> BeelsebobWork_: needs a flip
05:56:54 <Deewiant> but better :-)
05:56:59 <ac> hm... would this work: m >> k = m >>= (flip const) -- ?
05:57:11 <subconscious> ac: What is the type infered?
05:57:19 <Twey> Or rather, it comes from people who *do* understand static typing, but the Java/C/C++ way
05:57:19 <subconscious> ac: and how does it compare with the actual type of >>
05:57:31 <quicksilver> Twey: that is a subset of "not understanding" :)
05:57:34 <BeelsebobWork_> Deewiant: so it does
05:57:37 <ScottMichael> well i want the computer to be my slave, not the other way around. In java i feel like a slave static int final bololean = new controlhandlerin.gmuppet is int of int of int.
05:57:46 <Twey> quicksilver: *chuckles*
05:57:50 <ichigo> right, I imagine that algebraic typing is quite amazing
05:57:51 <ac> :t \m k -> m >>= (flip const)
05:57:52 <lambdabot> forall t a a1. (a1 -> a) -> t -> a1 -> a1
05:58:01 <ac> looks like I fail
05:58:05 <araujo> ichigo, ruby is a nice language .. expressive and powerful, though I am not sure if you want to talk about it in here , hah
05:58:07 <BeelsebobWork_> @type (liftM2 (flip const))
05:58:08 <Twey> ichigo: In Haskell, you can usually write as if it were a dynamic language.
05:58:09 <lambdabot> forall a2 a1 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a2
05:58:18 <Axman6> ac: which exercise?
05:58:23 <BeelsebobWork_> > [1,2,3] >> [4,5,6]
05:58:25 <ac> Axman6: my own
05:58:25 <lambdabot>   [4,5,6,4,5,6,4,5,6]
05:58:31 <Axman6> ah, righto
05:58:34 <ScottMichael> then i got to python which was a dream of easeof use but as i started writing bigger programs i missed static typing and after trying haskell nowit seems obvious static typing+optional declarations is the way to go
05:58:36 <Twey> The typing system figures out all the cruft for you, and you only have to talk to it when you need to.
05:58:38 <BeelsebobWork_> > (liftM2 (flip const)) [1,2,3] [4,5,6]
05:58:40 <lambdabot>   [4,5,6,4,5,6,4,5,6]
05:58:45 <ScottMichael> haskell meakes me feel like the computer is my friend AND slave
05:58:46 <Deewiant> ?ty \m k -> m >>= const k
05:58:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:59:04 <ichigo> yes, I wanted to know if it is possible to model the "duck typing" concept in haskell and code with types that are dynamic
05:59:05 <BeelsebobWork_> ScottMichael: Haskell is all about bondage and disciplin -- the ghc compiler is a dom
05:59:13 <ac> :t \m k -> (>>=) m (flip const)
05:59:14 <lambdabot> forall t a a1. (a1 -> a) -> t -> a1 -> a1
05:59:15 <BeelsebobWork_> but it's also very caring
05:59:21 <BeelsebobWork_> and makes sure you don't make mistakes
05:59:23 <quicksilver> on a bad day haskell makes me feel like the computer is smarter than me, and is sneering slightly :)
05:59:26 <subconscious> ichigo: I haven't seen anybody embed that
05:59:30 <quicksilver> but on a good day, it is as BeelsebobWork_ says.
05:59:32 <ac> :t \m k -> (>>=) m (flip const) k
05:59:34 <lambdabot> forall a a1. (a1 -> a) -> a1 -> a1
05:59:41 <Twey> ichigo: It might be possible, but no self-respecting Haskeller would want to.
05:59:42 <ac> arhg
05:59:48 <quicksilver> ichigo: you can, yes. And sometimes you want to do part of that.
06:00:01 <Twey> Haskell isn't that kind of language.  That's what Python is for.
06:00:03 <quicksilver> ichigo: haskell's typing supports 'controlled dynamism' where you specify how much dynamism you want.
06:00:13 <quicksilver> ichigo: it also supports parametric polymorphism
06:00:19 <quicksilver> which lets functions be entirely generic
06:00:21 <Twey> That's not the same as duck-typing...
06:00:25 <quicksilver> (which is a lot of what people use dynamism for)
06:00:42 <quicksilver> Twey: I know it is. But together these techniques solve many of the problems you would solve with duck typing
06:00:47 <quicksilver> it's a question of picking the right tool.
06:00:58 <quicksilver> typeclasses solved some kinds of duck-typing, too.
06:01:10 <Twey> Duck-typing in Haskell would involve checking what functions are defined over that type and then dynamically constructing a type-class for it
06:01:12 <quicksilver> Twey: I know it *isn't* that should be :)
06:03:10 <ichigo> I personally find that duck-typing is dangerous when I use it.. but I am unskilled... I've seen, however, amazing applications of dynamism to create complicated domain specific systems. The thing I don't like about those is that there doesn't seem to be a formal way of understanding those systems and their types, you learn them by experience
06:03:44 <subconscious> no documentation? :)
06:03:44 <quicksilver> I have not seen an amazing application of dynamism for which I didn't think "I can imagine the static type system which represents that"
06:03:55 <ichigo> I think it goes the other way too; I'm unskilled enough with haskell that sometimes I can't even get around the type system to solve a problem
06:03:59 <quicksilver> however, I don't claim to have seen every piece of code in the world.
06:04:16 <ichigo> but there are amazing things I've seen there too
06:04:19 <quicksilver> but in my experience "dynamic" systems in fact obey some underlying type discipline.
06:04:27 <quicksilver> it's just not enforced by the compiler.
06:04:57 <ac> @type \m k -> (>>=) m (const k)
06:04:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:05:08 <ac> ok, where does the '* -> *' kind come from?
06:05:10 <ac> that's almost correct
06:05:29 <subconscious> ac: that's the correct kind of m
06:05:39 <ac> @type (>>=)
06:05:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:05:41 <subconscious> :t (>>)
06:05:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:05:47 <subconscious> see you got it right
06:05:50 <ac> ah ok cool
06:05:59 <ac> I like my definition better :-P
06:06:03 <subconscious> you know what * -> * and other kinds mean?
06:07:15 <ac> It describes a type that has one paramater, no?
06:07:31 <subconscious> yes, specifically that parameter is also a type
06:07:41 <BONUS> a concrete type
06:07:45 <ichigo> quicksilver, yes, I feel like there should be more papers analyzing these type systems, but there aren't because people are busy "just using" them
06:08:00 <ac> subconscious: hmm... what's a type that has a parameter that's not a type?
06:08:07 <subconscious> (* -> *) -> *
06:08:11 <quicksilver> ichigo: it would be very interesting to take a large, successful python or ruby project
06:08:19 <BONUS> StateT for instance
06:08:21 <quicksilver> ichigo: and discover the type discipline which underlies it
06:08:51 <quicksilver> ichigo: might be a nice master's thesis in there for someone, if it was an interesting enough piece of code to start with.
06:08:52 <subconscious> quicksilver: I take a wild guess, STLC :)
06:09:12 <quicksilver> subconscious: that's kind of at the wrong level of abstraction.
06:09:18 <quicksilver> subconscious: trivially it will be right.
06:09:22 <subconscious> unfact it would be a first order fragment
06:09:26 <ac> subconscious: so '(* -> *) -> *' describes a type that has a parameter of a type that has a parameter?
06:09:27 <quicksilver> subconscious: but I'm more interested in the higher level patterns.
06:09:43 <subconscious> :k Mu
06:09:44 <quicksilver> subconscious: note I said 'type discipline' not 'type system'
06:09:45 <lambdabot> (* -> *) -> *
06:09:52 <subconscious> @src Mu
06:09:52 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:10:03 <ScottMichael> ichigo: ill give it to you, when ti comes to getting shit done there are loads of examples of ruby and python and so far haskell programm ers hasn't produced much
06:10:11 <ScottMichael> but hopefully that will change
06:10:24 <ScottMichael> i mainly use python.
06:10:44 <ac> subconscious: was 'Mu' supposed to answer my question? Heh.
06:10:55 <subconscious> ac, yeah :p
06:11:30 <subconscious> :t fix (In . Just)
06:11:31 <ac> That looks like some sort of infinite record type
06:11:32 <lambdabot> Mu Maybe
06:11:34 <ac> that shouldn't be allowedx
06:11:44 <subconscious> ac: I'm glad it's allowed
06:11:52 <subconscious> In (Just (In (Just (In (Just (In (Just (In (Just (...
06:11:58 <subconscious> is an element of the type
06:12:09 <ichigo> well I can imagine coding a lot of very specialized stuff in haskell that would be a pain in python... the numerical prelude, is it, has all sorts of mathematical goodness; it seems like you can represent algebras and linear spaces and other stuff that would be plain annoying to describe in other languages
06:12:09 <subconscious> so is In (Just (In Nothing))
06:12:14 <subconscious> it's the co-natural numbers!
06:12:35 <ac> arhgg, I thought you couldn't construct infinite types... and yet here's an infinite type
06:12:37 <subconscious> data Maybe a = Nothing | Just a ~mu~> data N = Z | S N
06:12:47 <BONUS> List a = Null | Cons (List a)
06:12:56 <ichigo> ScottMichael: I don't like the "getting shit done" philosophy because it doesn't write enough maths papers :D
06:12:57 <BONUS> thats also infinite but it works out well
06:16:12 <ichigo> ScottMichael: As far as haskell being used, I saw a blogging engine written in haskell and the whole concept made me feel a little wrong for some reason
06:16:52 <BONUS> although some of the things that make python so great to use come from languages like haskell
06:17:07 <humasect> =)
06:17:08 <BONUS> especially its best module, itertools, which is just a translation of some Data.List functions
06:22:16 <ac> can someone give me an example of code that produces the infinite type error that doesn't use recursion?
06:23:16 <Peaker> BONUS: I miss Pythonic things in Haskell...   Good interactive shell, decent debuggers and profilers, "batteries included", libraries/packages almost always just work "out of the box", ...
06:23:33 <ski> ac : `\x -> x x'
06:24:01 <BONUS> i agree to an extent, although i think the interactive shell is as good as python's
06:24:05 <Peaker> BONUS: TIOOWTDI is also nice :)
06:24:18 <ac> ski: that's using recursion, is it not?
06:24:30 <ski> ac : do you see any recursion in it ?
06:24:31 <Peaker> BONUS: ghci doesn't let you do anything you can do "in a file"...
06:24:39 <ac> ski: ah, right :-P
06:24:43 <Peaker> s/anything/everything (oops, covariance :)
06:24:55 <BONUS> oh yeah yo ucan't make classes and such
06:25:00 <BONUS> but i really like :info and :k and stuff
06:25:23 <BONUS> ac: \t -> t:.t
06:25:25 <BONUS> ac: \t -> t:t
06:25:28 <Peaker> BONUS: oh that reminds me of .__doc__ and help() and such, which are much more accessible in a shell, than having to go and search for it in a web browser..
06:25:43 <Peaker> Having to refer to separate documentation in Haskell is a big step backwards, IMO
06:26:23 <ac> BONUS: that would have a type of an infinitely nested list
06:26:27 <BONUS> i like just putting a module in site-packages and automatically having it work instead of messing with installing cabal
06:26:44 <BONUS> ac: no, it wouldn't have a type, because it produces a type error :)
06:26:46 <ac> BONUS: I see, there is a diference between infinite and recursive types
06:26:53 <BONUS> Occurs check: cannot construct the infinite type: a = [a]
06:27:09 <BONUS> yeah
06:27:11 <Philippa> Peaker: it'd be nice if ghci let you declare new types, yeah. I think there may be some interactions with typeclasses though
06:27:40 <Philippa> ...though there shouldn't be unless you've turned various dangerous extensions on
06:27:59 <ac> so '(* -> *) -> *' is any recursive type that uses one parameter
06:28:09 <ac> like [] for example
06:28:20 <dmwit> uh
06:28:24 <dmwit> ?k []
06:28:24 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
06:28:29 <dmwit> ?kind []
06:28:33 <lambdabot> * -> *
06:28:39 <Peaker> Philippa: I'm sure there are reasons behind all these things,  but  just speaking the mind of a Pythoneer who is trying to also get a hold on Haskell :)
06:28:59 <Philippa> the documentation thing... yeah, it's easier, I'll give you that. Hard to do well without messing things up though
06:29:32 <Philippa> it's a shame GOA seems to be tricky to get working, I think you'd like that
06:29:50 <ScottMichael> bonus: when it comes to easeof use Python beat all other languages ahnds down, not even close
06:30:07 <Philippa> and yeah. Did you get round to actually reading the lambda calculus interpreter I pasted in the end, btw?
06:30:34 <ScottMichael> peaker: u know you ahve profiling in haskell too. u think python profiling tools are good?
06:34:38 <gbacon> so what would a functional Light Bot game look like?
06:34:58 <Botje> "full of win and awesome"
06:35:07 <gbacon> or would it make a helpful monad tutorial?
06:35:09 <gbacon> Botje: :-)
06:35:35 <Philippa> gbacon: the functions'd actually take parameters, for a start
06:35:43 <dmwit> I don't think it would make a very good monad tutorial.
06:36:01 <dmwit> All of the actions in Light Bot were of type IO (), so there's no interesting sequencing.
06:37:56 <gbacon> Philippa: only need one! :-)
06:38:51 <Philippa> gbacon: function or parameter? :-)
06:43:09 <BONUS> interesting thing eariler
06:43:11 <BONUS> someone said that
06:43:12 <BONUS> for instance
06:43:19 <BONUS> Maybe isn't a type
06:43:23 <BONUS> but Maybe Int is
06:43:31 <BeelsebobWork_> BONUS: well, they're right
06:43:34 <BeelsebobWork_> Maybe is a type constructor
06:43:41 <BONUS> aha
06:43:45 <BeelsebobWork_> (not to be confused with a data constructor e.g. Just)
06:43:48 <subconscious> :k Maybe
06:43:49 <BONUS> then i had my terminology wrong yeah
06:43:49 <lambdabot> * -> *
06:43:52 <subconscious> :k Maybe Int
06:43:53 <lambdabot> *
06:43:56 <BONUS> i used to say that Maybe is a type
06:43:57 <Apocalisp> Maybe it is, Maybe it isn't
06:44:01 <BONUS> and Maybe Int is a concrete type
06:44:13 <BONUS> good to know
06:44:30 <gbacon> not to be confuuuuuuuused with the bionic, even though it does cost six million dollars, man
06:44:41 <subconscious> BONUS: It's not possible for any value in haskell x to satisfy (x :: Maybe)
06:44:54 <BONUS> yeah, values have to have types of kind *
06:45:06 <subconscious> I don't know if that means it's not a type but it seems important
06:46:19 <Philippa> <quicksilver> ichigo: the only people who say that are people who don't understand static typing. <- Not true. Dynamism != dynamic typing though, and statically typing sufficiently dynamic behaviour is still an ongoing research problem even if it's possible to know where the research'll be poking
06:46:58 <mnislaih> quicksilver: I lied before. The drift generated Parse instance uses the HuttonMeijer*Wallace* parser combinators which actually does error reporting. Highly useful for me
06:47:52 <mnislaih> now I only need Gwern to update the Drift package in Hackage so that it installs the drift-ghc script
06:48:06 <ichigo> that light-bot is a little addicting
06:48:45 <Philippa> eh. There's a big peak in difficulty around level 10. If you're really that keen, write a program to generate optimal code for each level
06:49:15 <Philippa> (12 levels in total, 10 requires you to use some serious trickery to make it work)
06:49:19 <ichigo> that'd be an interesting problem
06:50:37 <birkenfeld> given a list of values constructed with possibly different constructors, what is the best way to find out if they're all the same constructor?
06:51:02 <ichigo> Philippa: are there any more instructions or program slots that get introduced?
06:51:07 <Philippa> ichigo: nope
06:51:29 <ichigo> it seems like there are only 196 programs in the space of possible programs, then
06:52:10 * BeelsebobWork_ ponders why System.Eval.eval "map (\v -> v) [1,2,3]" [] -- produces a parse error
06:52:20 <Philippa> and for level 10 I had to start by writing the range of sensible instruction streams (modulo function calls) out as a (thankfully loopless) regex, then annotate where particular instructions could be repeated safely (which depends on the block in front of you at the time!) and run CSE across /that/
06:52:34 <Philippa> ...huh?
06:52:47 <Philippa> I make it 7^28, though many of them are stupid
06:53:03 <ichigo> oh crud
06:53:09 <ichigo> excuse me!
06:53:26 <ichigo> my brain is not thinking
06:53:30 <Philippa> you'll see what I mean about 10 when I get there, btw :-)
06:53:40 <dmwit> Level 10 is highly irregular.
06:53:57 <Philippa> dmwit: did you solve it, and did you have to do what I did or something else?
06:53:59 <dmwit> I found about five solutions that required *exactly* one more step.
06:54:01 <ichigo> I think this might be a way to introduce my little brother to programming
06:54:07 <dmwit> Philippa: I solved it.
06:54:15 <Philippa> (I eventually ended up with three calls to the same 8 instruction sequence which /never/ ran in a situation where all 8 were necessary)
06:54:24 <dmwit> s/step/empty instruction square in the main body/
06:55:04 <Beelse-YARR> Aye, I did not realise we be missing talking like pirates
06:55:06 <Beelse-YARR> @yarr
06:55:06 <lambdabot> Gangway!
06:55:11 <Philippa> ichigo: only a very basic starting point, and level 10... isn't a good idea to expose anyone who wants to be a /sane/ programmer to as a starting point - well, maybe if you want to teach them regular expressions
06:55:14 <Philippa> Beelse-YARR: d00d!
06:56:44 <JaffaCake> @arr
06:56:44 <lambdabot> Swab the deck!
06:58:58 <ichigo> bugs are hilarious
06:59:15 <ichigo> he just kinda hopped off the wrong part of the level and walked into a wall
07:11:19 <ichigo> wow, level ten is pretty screwed up
07:11:55 <Beelse-YARR> level 10?
07:12:26 <ichigo> this little webgame called lightbot
07:12:58 <dmwit> Can anybody get to level 10 in less than 109 moves?
07:13:11 <BlackyKitty> level 10 of what?
07:13:19 <dmwit> That's my best so far; and my experience with level 10 last time was so sour that I don't want to try solving it again... =P
07:13:27 <dmwit> BlackyKitty: http://www.gameroo.nl/games/light-bot
07:13:28 <lambdabot> Title: Light Bot - Gameroo
07:14:26 <Haru> hi.. is it possible to have a condition inside a condition
07:14:33 <dmwit> Absolutely.
07:14:33 <Beelse-YARR> Haru: sure, why not?
07:14:35 <Deewiant> was level 10 the one where all the lights are on lines with alternating heights?
07:14:45 <dmwit> > if (if True then 3 else 4) then 3 else 4
07:14:47 <lambdabot>       No instance for (Num Bool)
07:14:47 <lambdabot>        arising from the literal `3' at <inte...
07:14:48 <dmwit> Well...
07:14:55 <dmwit> > if (if True then True else False) then 3 else 4
07:14:57 <lambdabot>   3
07:15:09 <dmwit> Deewiant: Level 10 is the irregular one.
07:15:23 <dmwit> "organic"
07:15:44 <Deewiant> was it before or after that one?
07:16:04 <Deewiant> level 10 had two lights, then?
07:16:09 <dmwit> yeah
07:16:14 <Deewiant> ah, that one was easy :-)
07:16:21 <dmwit> bah
07:16:23 <dmwit> =P
07:16:24 <Deewiant> the one I described was 11 then, got stuck on that one
07:16:47 <dmwit> I had no trouble with any of the regular ones, but I tried 5 or 6 things before I got level 10.
07:17:15 <Haru> Beelse-YARR, erm how do i do something like http://pastebin.com/m31864aed
07:17:46 <Beelse-YARR> Haru: sure that's allowed, although it's got a damn funny type
07:18:09 <Beelse-YARR> also, those aren't statements
07:18:11 <Beelse-YARR> they're expressions
07:18:42 <dmwit> Haru: There's lots of problems there.
07:18:59 <dmwit> Haru: First: you have to wrap complex patterns in parentheses.
07:19:11 <dmwit> So, "function x (h:hs)", not "function x h:hs".
07:19:42 <Haru> dmwit, those i can manage.. i cant figure how to do the condition inside a condition though
07:19:59 <ac> so what's the consensus on terminology... is '* -> *' a type or just a type constructor?
07:20:01 <dmwit> Haru: ...but, there is no condition within a condition.
07:20:14 <Haru> | tail x == head h = statement ++ if condition then statement else []
07:20:14 <Beelse-YARR> dmwit: sure there is -- there's an if within his guard
07:20:17 <Beelse-YARR> and it's correct
07:20:23 <dmwit> ac: '* -> *' is a kind; things classified by '* -> *' are type constructors.
07:20:24 <Beelse-YARR> Haru: your syntax for that is correct
07:20:33 <Beelse-YARR> although you have several other bugs
07:20:48 <Haru> Beelse-YARR, erm.. i just wrote that to convey the idea :)
07:21:00 <Beelse-YARR> Haru: well, yes, you can do that
07:21:12 <Haru> but how ?
07:21:15 <Beelse-YARR> like that
07:21:18 <dmwit> Haru: ...just like that.
07:21:26 <Haru> if cond else?
07:21:30 <ac> dmwit: I misspoke. My question was can things classified by '* -> *' also be called types?
07:21:40 <Beelse-YARR> > let f x | x > 5 = if x == 92 then "jam" else "monkey" in f 92
07:21:42 <lambdabot>   "jam"
07:21:44 <Beelse-YARR> > let f x | x > 5 = if x == 92 then "jam" else "monkey" in f 93
07:21:46 <lambdabot>   "monkey"
07:21:49 <Beelse-YARR> > let f x | x > 5 = if x == 92 then "jam" else "monkey" in f 4
07:21:50 <lambdabot>   mueval: Prelude.read: no parse
07:21:50 <lambdabot>  mueval: "*** Exception: /tmp/91013287751703...
07:22:02 <Beelse-YARR> blimeh, mueval, that's a shit error message
07:22:07 <Beelse-YARR> fix your pattern match failures
07:22:08 <dmwit> ac: Technically, no.  But most people will understand you. ;-)
07:23:24 <Haru> Beelse-YARR, thanks a lot
07:36:34 <Beelse-YARR> does hs-plugins have severe limitations that would cause this System.Eval.eval "let x = 5 :: Int in x" [] to return Nothing, or is there something odd going on
07:40:33 <ac> Could someone give me an example of a value of type Mu?
07:41:15 <quicksilver> In (Just (In (Just (In (Just (In (Nothing))))))
07:41:21 <quicksilver> (is an example of Mu Maybe)
07:41:35 <ichigo> hah
07:41:45 <quicksilver> Mu Maybe =~ [()]
07:41:55 <ac> what's the point of Mu?
07:42:04 <quicksilver> to make people's heads explode.
07:42:06 <papermachine> Mu Maybe reminds me of a news reporter getting too excited.
07:42:29 <quicksilver> it has the same purpose as fix : to demonstrate that there is a universal recursive construct.
07:42:42 <quicksilver> Given Mu as a primitive you don't need recurse data types at all.
07:42:43 <papermachine> "This In! Just In! Just In! ... Nothing."
07:43:23 <ac> :t fix
07:43:24 <lambdabot> forall a. (a -> a) -> a
07:44:14 <Saizan> well, if you define recursive type with Mu it's easier to compose them
07:44:34 <Saizan> and you can write some recursive patterns generically
07:45:15 <Saizan> see e.g. the posts on catamorphism on comonad.com
07:45:18 <ski> cata :: Functor f => (f r -> r) -> (Mu f -> r)
07:46:01 <ski> `foldr' is more or less `cata' with `f = []'
07:46:31 <ski> er .. with `f r = Either () (a,r)'
07:46:54 <ski> (`Mu f' would then be more or less `[a]')
07:47:29 <ski> (one can s/Either ()/Maybe/ of course ..)
07:50:20 <ac> Why does it use a record?
07:50:57 <Saizan> ?src Mu
07:50:57 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
07:51:05 <Saizan> just for convenience
07:51:06 <quicksilver> just for convenient syntax.
07:51:52 <Saizan> ?type let cata f = f . fmap (cata f) . out in cata
07:51:53 <lambdabot> forall (f :: * -> *) c. (Functor f) => (f c -> c) -> Mu f -> c
07:52:00 <wjt> first person to come up with a hokey-kokey joke based on In { out :: ‚Ä¶ } gets a box of fluffy lambdas
07:52:04 <Saizan> @let cata f = f . fmap (cata f) . out in cata
07:52:04 <lambdabot>   Parse error
07:52:09 <Saizan> @let cata f = f . fmap (cata f) . out
07:52:12 <lambdabot>  Defined.
07:52:21 <EvilTerran> ?type cata
07:52:23 <lambdabot> forall (f :: * -> *) c. (Functor f) => (f c -> c) -> Mu f -> c
07:52:52 <EvilTerran> "type kata - the martial art of crushing your opponents... in the type system"
07:55:17 <Saizan> now we should define :+: and :*; and start hacking ours zygochronomorphisms
07:58:26 <Beelse-YARR> any hs-plugins players hanging about?
07:58:41 <Beelse-YARR> (who might have an idea why System.Eval.eval "x where x = 5 :: Int" [] produces Nothing)
08:01:20 <EvilTerran> that's a syntax error
08:01:31 <EvilTerran> you can't use "where" just anywhere
08:01:46 <EvilTerran> it has to be attached to a binding or a case-of expression before it
08:01:57 <EvilTerran> > x where x = 5
08:01:58 <lambdabot>   5
08:02:01 <EvilTerran> er
08:02:07 <EvilTerran> ... what?
08:02:13 <EvilTerran> > (x where x = 5)
08:02:15 <lambdabot>   mueval: Prelude.read: no parse
08:02:24 <leimy> are Monads like Las Vegas?
08:02:26 <Beelse-YARR> good point -- you can use let anywhere though
08:02:28 <leimy> What happens there stays there?
08:02:31 <EvilTerran> > (let x = 5 in x) -- you can use the let-in syntax instead
08:02:33 <lambdabot>   5
08:02:34 <Botje> leimy: pretty much.
08:02:36 <Beelse-YARR> and System.Eval.eval "let x = 5 :: Int in x" [] returns Nothing too
08:02:43 <Botje> although there's generally less gambling and robbing goin on
08:02:43 <EvilTerran> that *is* odd
08:02:45 <Beelse-YARR> Prelude NM8.Core> System.Eval.eval "let x = 5 :: Int in x" []
08:02:45 <Beelse-YARR> Nothing
08:03:06 <ski> lambdabot `where' works again ?!
08:03:09 <Beelse-YARR> also on the wierdness front...
08:03:13 <Beelse-YARR> Prelude NM8.Core> System.Eval.eval "map (\v -> v) [1,2,3]" []
08:03:13 <Beelse-YARR> <eval>:1:7: parse error on input `->'
08:03:25 <Botje> Beelse-YARR: escape the \
08:03:31 <Beelse-YARR> ahhhh!
08:03:45 <Beelse-YARR> yay, thank you Botje
08:04:00 <Botje> speak not of it, wee pirate.
08:04:05 <ski> @arr
08:04:05 <lambdabot> Swab the deck!
08:04:22 <Botje> a chest of gold an' a tavern full o' wenches shall do. yarrr!
08:05:03 * Beelse-YARR ponders why the backslash *needs* to be escaped
08:05:10 <ski> it's a string
08:05:15 <EvilTerran> > "\v"
08:05:16 <lambdabot>   "\v"
08:05:19 <Botje> because otherwise it's a virtual tab? :)
08:05:21 <EvilTerran> vertical tab
08:05:24 <ski> > length "\v"
08:05:26 <lambdabot>   1
08:05:28 <EvilTerran> virtual tab?
08:05:32 <Botje> *Vertical
08:05:35 <Beelse-YARR> oh, hang on, yes, in that specific example it does
08:05:37 <ski> > ord (head "\v")
08:05:38 <Botje> i blame ...
08:05:39 <lambdabot>   11
08:05:41 <Beelse-YARR> bugger, that'snot the bug I was looking at
08:05:41 <Botje> myself :[
08:05:46 <EvilTerran> > "\q"
08:05:48 <lambdabot>       lexical error in string/character literal at character '"'
08:05:52 <EvilTerran> there we go
08:05:59 * Botje puts on puke & snot
08:06:01 <Saizan_> Beelse-YARR: what's the type of eval?
08:06:05 <Botje> their pirate bit is pretty funny :)
08:06:20 <Beelse-YARR> Saizan_: String -> Imports -> IO (Maybe a) IIRC
08:06:26 <Beelse-YARR> (Typeable a) =>
08:06:41 <Saizan_> then you've to coerce it to the right type
08:06:50 <Beelse-YARR> hmm?
08:06:57 <Saizan_> like eval "1 :: Int" [] :: IO (Maybe Int)
08:07:06 <ski> possibly it defaults (.. to `()' ?)
08:07:10 <Saizan_> if not ghci assumes ()
08:07:12 <Saizan_> yeah
08:07:20 * BMeph would rather have a tavern full o' gold, and a chest full o' wenches, aye, matey!
08:07:21 <Beelse-YARR> Saizan_: yeh, I know, this is in a larger context
08:07:32 <Botje> BMeph: better be a big chest.
08:07:41 <Botje> otherwise you'll get midget wenches
08:07:43 <Saizan_> oh, it looked like you were trying it in ghci
08:07:48 <EvilTerran> a wench with a big chest?
08:07:50 <Botje> and they don't wench /nearly/ as good
08:07:54 <EvilTerran> ... full of gold, naturally
08:07:57 <ac> wouldn't this definition for Mu work just as well: newtype Mu t = In (t (Mu t)) -- ?
08:08:08 <subconscious> ac: as well as what?
08:08:16 <Botje> taking "heart of gold" to a new level, are we?
08:08:18 <EvilTerran> ac, not *quite* as well, because it doesn't give you the definition of "out" for free
08:08:18 <ac> newtype Mu f = In { out :: f (Mu f) }
08:08:31 <EvilTerran> although it does make the derived Show instance nicer
08:08:49 <ac> I still don't understand either one
08:09:09 <ski> ac : you might consider the simpler case of `Mu Maybe'
08:09:09 <BMeph> Botje: I was thinkin' o' me *own* chest, heh-heh, yarr!
08:09:09 <subconscious> EvilTerran: what version of GHC you have that derives a show for Mu?
08:09:20 <Saizan_> ac: if you also define out (In x) = x, it's the same
08:09:26 <Botje> arrrrrrrr!
08:09:53 <Botje> in unrelated news: i have started development on a boat trading sim
08:09:58 <Botje> in haskell, of course!
08:10:18 <Botje> perhaps there should be an option to keelhaul people on sep 19th
08:12:18 <BlackyKitty> Botje: Seriously?
08:12:35 <quicksilver> Botje: like elite, but afloat?
08:12:38 <Botje> yeah
08:12:42 <quicksilver> awesome.
08:12:50 <Botje> I've been playing a lot of "ports of call" last weekend
08:13:00 <quicksilver> elite set the bar so high that no computer game has come close in 20 years of technology since.
08:13:01 <Botje> and i need something to procrastinate my thesis with
08:13:22 * BMeph prefers socket wenches...
08:13:27 <Botje> i might do the harbor docking minigame too
08:13:46 <Botje> which is actually pretty cool, even in the original dos version :)
08:18:29 <EvilTerran> subconscious, any version, if you write "newtype Mu f = In ... deriving Show"
08:18:33 * BMeph wonders if a muslim girl would be called a "crescent wench"...
08:18:50 <subconscious> Doesn't work for me
08:18:52 <quicksilver> BMeph: only from a safe distance, I suggest.
08:19:01 <EvilTerran> subconscious, what happens?
08:19:05 <subconscious> what's the exact code?
08:19:12 <BMeph> quicksilver: ;)
08:19:14 <Botje> groan :)
08:19:15 <EvilTerran> newtype Mu f = In { out :: f (Mu f) } deriving Show
08:19:15 <BONUS> @src forM
08:19:15 <lambdabot> forM = flip mapM
08:19:16 <EvilTerran> or
08:19:22 <EvilTerran> newtype Mu f = In (f (Mu f)) deriving Show
08:19:30 <quicksilver> EvilTerran: I don't think GHC is clever enough to derive Show for Mu.
08:19:36 <EvilTerran> can't it?
08:19:38 <EvilTerran> oh well
08:19:48 <subconscious> EvilTerran: and .. these work?
08:19:59 <quicksilver> it probably deserves a bug report.
08:20:00 <EvilTerran> i thought they did, seeing as it's a newtype
08:20:17 <subconscious> EvilTerran: oh I thought you were saying they actually worked, not just guessing
08:20:18 <EvilTerran> maybe with NewtypeDeriving?
08:20:21 <quicksilver> EvilTerran: deriving can't derive polymorphically recursive instances.
08:20:38 <EvilTerran> actually, then you'd end up with a newtype-derived instance Show (f (Mu f)) => Show (Mu f)
08:20:50 <quicksilver> although this is a very strange type of polymorphic recursion.
08:20:54 <EvilTerran> which is undecidable, so that would be baaad
08:20:56 <quicksilver> It's monomorphic in Mu.
08:21:00 <quicksilver> but polymorphic in f.
08:21:09 <quicksilver> still the instance is "obvious"
08:21:12 <quicksilver> although hard to write down.
08:21:15 <Saizan_> EvilTerran: that instance works.
08:21:25 <roconnor> what is the obvious instance?
08:21:31 <roconnor> I can't even figure out how to write it.
08:21:39 <EvilTerran> Saizan_, but for, say, f = [], it'd be circular
08:21:39 <quicksilver> roconnor: we went through it a few days back.
08:21:42 <roconnor> oh
08:21:47 <quicksilver> EvilTerran's constraint is correct.
08:22:01 <roconnor> oh?
08:22:02 <ski>   instance (forall r. Show r => Show (f r)) => Show (Mu f)  -- something like this could be nice
08:22:03 <quicksilver> but if you add the contrainst forall a . Show a => Show (f a)
08:22:11 <quicksilver> and then substitute that constraint it
08:22:18 <quicksilver> you end up with Show (Mu f) in the context
08:22:20 <quicksilver> which is reducable
08:22:26 <roconnor> ski, that's what I was thinking, but couldn't figure out how to write
08:22:30 <quicksilver> but, it's not quite expressible in haskell-constraints
08:22:36 <quicksilver> so you cheat and use external functions
08:22:42 <roconnor> EvilTerran's restriction blows my mind.
08:23:17 <Saizan_> you don't need forall r. Show r => Show (f r) since 'a' is always (Mu f) in the body
08:23:22 <Saizan_> err 'r'
08:23:43 <Saizan_> roconnor: it's tying the knot in the class dictionary :)
08:26:41 <quicksilver> Saizan_: someone should wiki it.
08:26:43 <quicksilver> Saizan_: it's a neat trick.
08:31:27 <Axman6> > let f = [f] in f
08:31:29 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
08:31:29 <lambdabot>        Expect...
08:31:39 <Axman6> sure you can
08:33:33 <besiria> any HAppS tutorial, haddock is hard.
08:35:39 <quicksilver> Axman6: yes, you can, but you have to do it explicitly.
08:35:50 <quicksilver> Axman6: and use a constructor to mark the recursion point.
08:35:52 <Axman6> bah!
08:35:59 <quicksilver> otherwise if you're not careful, every term is typable.
08:36:08 <quicksilver> and that means the type-checker can't catch bugs :P
08:37:55 <dmwit> Axman6: you might be interested in http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
08:37:59 <lambdabot> Title: Gmane -- Mail To News And Back Again
08:38:05 <shapr> besiria: There's a cabal-fetchable HAppS tutorial.
08:39:01 <Beelse-YARR> http://tech.slashdot.org/article.pl?sid=08/09/19/1230237&from=rss <-- yay, SPJ made slashdot front page, talking about Haskell
08:39:06 <Axman6> > iterate (\x -> [x]) 1
08:39:06 <lambdabot> Title: Slashdot | Why Lazy Functional Programming Languages Rule
08:39:07 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
08:39:07 <lambdabot>        Expect...
08:39:12 <Axman6> -_-
08:39:22 <Axman6> oh right, that makes sense
08:39:51 <ski> Axman6 : but see `ocaml -rectypes'
08:40:04 <Axman6> hmm?
08:41:07 <quicksilver> Axman6: ocaml -rectypes does inference of infinite types like that
08:41:14 <quicksilver> if you google aroudn a bit you can find some explaining the disadvantage
08:41:24 <quicksilver> in the form of 8 simple mistakes which all correctly infer, using rectypes
08:41:35 <quicksilver> (btu would all be caught by standard inference)
08:42:42 <roconnor> if V is a vector space over F, then are polynomials V[X] a vector space over F?
08:42:55 <Cale> yes.
08:43:09 <Cale> er...
08:43:17 <Cale> What is your multiplication?
08:43:38 <roconnor> er
08:43:39 <Cale> Formally, through addition?
08:43:45 <roconnor> V is a vector space and a ring.
08:43:48 <Cale> ah
08:43:53 <Cale> Then yeah, that's fine :)
08:43:55 <roconnor> is there a name for that?
08:43:59 <Cale> An algebra.
08:44:05 <roconnor> oh?
08:44:09 <roconnor> oh ya
08:44:18 <roconnor> it's a stupid name. :)
08:44:46 <quicksilver> mathematicians always prefer to give a subtle nuance to an old word
08:44:50 <quicksilver> rather than invent a new one.
08:45:04 <quicksilver> it's much more fun that way :)
08:45:31 <ac> hah, I think this is a valid definition of (>>=) for the list Monad: (>>=) = ((.) . (.)) concat map
08:45:58 <ddarius> ac: It is.
08:46:07 <ski> s/map/(flip map)/
08:46:08 * Axman6 always likes a language which has boobies in it
08:46:09 <BONUS> what animal is that
08:46:17 <ac> @src (>>=) List
08:46:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:46:22 <shapr> BONUS: Probably a mammal
08:46:22 <ac> @src List (>>=)
08:46:23 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:46:30 <ski> @type ((.) . (.)) concat map
08:46:31 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
08:46:35 <ski> @type ((.) . (.)) concat (flip map)
08:46:36 <lambdabot> forall a a1. [a1] -> (a1 -> [a]) -> [a]
08:46:41 <Axman6> @src [] (>>=)
08:46:41 <lambdabot> xs >>= f     = concatMap f xs
08:46:46 <ski> @type (>>=)
08:46:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:46:48 <BONUS> i wish this was valid haskell: (>^_^)>
08:46:49 <ski> @type (=<<)
08:46:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:46:58 <ac> ah oops, I was going by the argument order in Tony's exercises
08:47:46 <ski> BONUS : which ?
08:47:54 <BONUS> i wonder how hard it would be to solve those tony's exercises without knowing about functors, monads, etc.
08:48:04 <Cale> BONUS: Axman6 can tell you :)
08:48:12 <roconnor> Cale: and a vector space is just a module over a field?
08:48:16 <BONUS> hehe
08:48:20 <Axman6> -_-
08:48:26 <Axman6> my head hurts
08:48:41 <BONUS> yeah cause looking at it, i just recognize the monadic and functor functions and then at the end its just implementing a State monad
08:48:52 <Peaker> ScottMichael: was away, you still here?
08:48:56 <Axman6> lack of sleep + monads and functors = large pounding headache
08:49:15 <ddarius> roconnor: Yes, maybe with slightly stronger axioms.
08:49:18 <ski> lack of monads and functors + sleep = ?
08:49:21 <ac> Axman6: heh, I better watch it. I'm running short on sleep too
08:49:38 <sw17ch> flamebait: http://tech.slashdot.org/comments.pl?sid=969527&cid=25071821
08:49:38 <Axman6> it's alsmot 2AM here
08:49:47 <lambdabot> Title: Why Lazy Functional Programming Languages Rule
08:49:48 <Axman6> and i've missed about a nights sleep in the last week
08:49:53 <Axman6> TGIF
08:49:54 <Peaker> ScottMichael: I tried profiling with ghc's profiling options, and it was extremely unfriendly, using a lot of unnecessary unexplained terminology (why do I need to look things up to understand a profiling output?), etc.  In Python, the default profiler kinda sucks, but I wrote a better one and its getting quite nice :)
08:49:59 <ac> Axman6: it's almost 9AM here, but I'm on a weird schedule as it is :-P
08:50:06 <Axman6> heh
08:50:29 <quicksilver> BONUS: if you recognise them, then the exercises aren't really interesting :P
08:50:35 <ac> Wow, I actually understand what: foo = bar . (baz .) -- means... I think
08:50:40 <Axman6> ski: a less educated Axman6
08:50:43 <Cale> I had my girlfriend do essentially the equivalent at one point, only calling things by their real names. She had few problems, but she's a mathematician. I was generally impressed by how easy she found things. I had her define map in terms of foldr, and she gave me the points-free solution. :)
08:50:52 <BONUS> although it's strange that he callls (a -> m a) -> m a -> m b (which is just reversed bind) banana and then he calls (a -> b -> c) -> m a -> m b -> m c banana2, but thats actually liftM2
08:50:56 <BONUS> quicksilver yeah
08:51:12 <Cale> Well, almost points-free :)
08:51:25 <Cale> map f = foldr ((:) . f) []
08:51:29 <Cale> that one :)
08:51:33 <BONUS> haha, nice
08:51:55 <roconnor> @pl map f = foldr ((:) . f) []
08:51:55 <lambdabot> map = flip foldr [] . ((:) .)
08:52:00 <Axman6> :t (:) . f
08:52:01 <lambdabot> forall b a. (SimpleReflect.FromExpr b, Show a) => a -> [b] -> [b]
08:52:16 <BONUS> i always write a foldr map as foldr (\x acc -> f x : acc) []
08:52:30 <quicksilver> sw17ch: HAHAHAHA
08:52:36 <BONUS> (:) . f is pretty kewl
08:52:39 <quicksilver> "Javascript is a functional language that has managed to go mainstream. Whether you would call it "pure" or not is open for debate."
08:52:43 <Cale> Yeah, it's very elegant.
08:52:43 <sw17ch> quicksilver, i figued #haskell would like that :)
08:52:46 <quicksilver> Yes. a very short debate.
08:52:48 <BONUS> hahaha
08:52:54 <quicksilver> "Javascript: is it pure? No."
08:52:54 <Axman6> lol
08:52:57 <quicksilver> end of debate.
08:52:59 <sw17ch> i see beelsebob gave him what for already
08:53:22 <BONUS> javascript a functional language, thats pretty funny
08:53:24 <quicksilver> it was a fairly skilled /.-karmawhore troll.
08:53:28 <BONUS> but javascript being pure? thats hilarious
08:53:30 <quicksilver> I recognise the type :)
08:53:33 <Cale> quicksilver: What if we pull a philosopher and redefine 'pure' in some way which makes it true?
08:53:55 <BONUS> pure = can run in a browser
08:54:12 <ac> BONUS: heh
08:54:12 <quicksilver> Cale: Sure. Let's redefine 'javascript' as 'Aston Martin Vantage' and 'pure functional language' as 'fun car to own, but a bit expensive'
08:54:21 <quicksilver> Cale: then I agree with the statement, I think.
08:54:29 <Cale> hehehe
08:54:38 <quicksilver> does that make me a philosopher? ;)
08:55:00 <ac> Axman6: which exercise are you on?
08:55:20 <Beelse-YARR> quicksilver: javascript as an aston martin vantage -- I know SquirrelFish Extreme just came out, but Javascript still isn't a quick language
08:55:23 <Cale> "This judge has it out for me... I kinda ran over his dog."  "Oh, that's horrible!"  "Well, replace 'kinda' with repeatedly'
08:55:28 <Beelse-YARR> (or rather, no interpretter for it is)
08:55:34 <Cale> "This judge has it out for me... I kinda ran over his dog."  "Oh, that's horrible!"  "Well, replace 'kinda' with 'repeatedly', and 'dog' with 'son'."
08:55:44 <micahcowan> heh
08:55:45 <Axman6> 13, but i've done some of the others after that, with a lot of help from Cale (thanks again)
08:56:18 <ac> Axman6: my answer for #6 is: furry' = banana . (unicorn .)
08:56:37 <BONUS> although re: these tony's exercises ... i cant imagine someone who doesnt know monads and functors but knows the type system so well that he can solve them without knowing monads and functors
08:56:39 <Axman6> furry' f ma = banana (unicorn.f) ma
08:56:54 <ac> Axman6: you can see how you can turn that in to what I have, right?
08:57:03 <ac> Axman6: that's what I wrote down first too
08:57:06 <ddarius> BONUS: You just stick things together.
08:57:07 * Axman6 dislikes pointfree style for many things. makes them less clear
08:57:13 <ac> Axman6: indeed
08:57:13 <quicksilver> Cale: ;)
08:57:18 <BONUS> hmm
08:57:33 <BONUS> i guess you just run the type inference engine bacwards in your head
08:57:42 * byorgey be makin' some lambda rum! arrrr!!
08:57:46 <hackage> Uploaded to hackage: emgm 0.1
08:57:49 <quicksilver> running it backwards is just showing off.
08:57:50 <Axman6> sometimes it makes a lot of sense, but i find if there's  more than one argument, it becomes unclear
08:57:54 <quicksilver> running it forward should be sufficient :)
08:58:04 <BONUS> hehe
08:58:22 <BONUS> im a composition and points free junkie, there i said it
08:58:31 <quicksilver> Axman6: I think that's a good guideline.
08:58:35 <quicksilver> (the one argument thing)
08:58:40 <Axman6> :)
08:58:43 <ac> ok, I better go to sleep
08:58:51 <Axman6> yeah, me too
08:58:58 <ac> later y'all
08:59:04 <BONUS> yeah if theres more than one argument then you get to stuff like (. (.) . (. (. (.) . map) blah . blah) .)
08:59:07 <Axman6> heh, i just had a sudden urge to say gg guys gg
08:59:07 <BONUS> hehe cya
08:59:12 <Axman6> i don't even game :|
08:59:19 <Deewiant> ?ty \blah ->  (. (.) . (. (. (.) . map) blah . blah) .)
08:59:26 <lambdabot> parse error on input `)'
08:59:29 <BONUS> that doesnt even have balanced parens
08:59:30 <BONUS> imho
08:59:33 <Deewiant> meh
08:59:59 <Deewiant> ?ty \blah ->  (. (.) . (. (. (.) . map) blah . blah))
09:00:00 <lambdabot> forall c a c1 a1 a2 b. (((a1 -> [a2]) -> a1 -> [b]) -> a2 -> b) -> (((a -> (a1 -> [a2]) -> a1 -> [b]) -> a -> c1) -> c) -> ((a2 -> b) -> c1) -> c
09:00:10 <BONUS> lol
09:00:18 <Axman6> :|
09:00:37 <Deewiant> or actually, just bracketing the original properly
09:00:38 <Deewiant> ?ty \blah ->  ((. (.) . (. (. (.) . map) . blah . blah)) .)
09:00:39 <Axman6> yeah, that's why point free style sucks in many cases
09:00:40 <lambdabot> forall c a c1 c2 a1 a2 b a3. ((((a1 -> [a2]) -> a1 -> [b]) -> c2) -> ((a1 -> [a2]) -> a1 -> [b]) -> c2) -> (a3 -> ((a -> ((a1 -> [a2]) -> a1 -> [b]) -> c2) -> a -> c1) -> c) -> a3 -> (((a2 -> b) ->
09:00:40 <lambdabot> c2) -> c1) -> c
09:00:52 <Deewiant> ?unpl \blah ->  ((. (.) . (. (. (.) . map) . blah . blah)) .)
09:00:52 <lambdabot> \ blah j y ab -> j y (\ b c -> ab (\ ah -> blah (blah (b c)) (\ e f -> map ah (e f))))
09:00:53 <Axman6> :t flip
09:00:54 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:00:58 <BONUS> but i like stuff like i dunno
09:01:00 <BONUS> pf for folds
09:01:41 <Axman6> if i can't tell where a parameter is going, it gets named and followed.
09:01:48 <Axman6> i'm like the CIA
09:02:00 <BONUS> and stuff like concatMap f = concat . map f
09:02:24 <Deewiant> concatMap = (concat .) . map
09:02:38 <BONUS> i dont like that so much :[
09:03:07 <quicksilver> Axman6: naming is a compromise
09:03:12 <quicksilver> and this applies through all parts of programming
09:03:28 <quicksilver> naming things is documentation, of a kind, and helps comprehension
09:03:30 <BONUS> my favourite style to read is liberal use of let bindings
09:03:41 <quicksilver> but naming things you only use once or twice, or thinking up stupid names, is pointless
09:03:46 <BONUS> yeah
09:03:55 <quicksilver> so you always pick the compromise which works best for you
09:04:32 <quicksilver> in "concatMap f = concat . map f" most people are helped by the informal rule "f = function"
09:04:35 <quicksilver> in their head.
09:04:43 <quicksilver> (although it's not necessary, because you can infer the type if you want to)
09:04:58 <BONUS> thats what i also like
09:05:02 <BONUS> giving functions names like f g
09:05:32 <BONUS> i got confused when i was reading the all about monads tutorial and in the code, there was a pattern match on (State x)
09:05:49 <BONUS> of course that was some time ago, but still
09:06:52 <Axman6> anyway. sleep time. goodnight all. and thanks Cale and others for your help with those damn monads
09:06:58 <Axman6> pesky little buggers
09:07:00 * Axman6 &
09:13:16 <BONUS> in module Blah (Foo(..)) where
09:13:18 <BONUS> what does the .. mean
09:13:29 <subconscious> all the constructors of Foo
09:13:56 <BONUS> ah
09:14:34 <BONUS> what if Foo's a typeclass
09:15:23 <quicksilver> all the methods, I think.
09:15:25 <Eelis> all its members
09:15:53 <BONUS> does it export the typeclass itself though
09:16:09 <kaol> http://www.computerworld.com.au/index.php/id;1974033854
09:16:14 <lambdabot> Title: Computerworld - The A-Z of Programming Languages: Haskell
09:18:29 <micahcowan> Is it really permissible to refer to JavaScript as functional, even (let alone pure)? I mean, by the same reasons he gives, Python is "functional" too AFAICT.
09:19:13 <BONUS> what are the reasons he gives
09:19:38 <BONUS> the only think functional about javascript imho is that functions are first class
09:19:50 <subconscious> micahcowan: no it's complete rubbish
09:20:32 <BONUS> but they aren't curried by default, no lambdas, not many higher order functions in there by defualt, etc
09:21:05 <micahcowan> subconscious, okay. The perils of using Wikipedia as your source! ;)
09:21:52 <ddarius> BONUS: It has lambdas.
09:22:02 <subconscious> micahcowan: Paradigm	Multi-paradigm: prototype-based, functional, imperative, scripting
09:22:06 <dons> Beelsebob: go go! fighting the slashdot dolts.
09:22:10 <subconscious> micahcowan: is that the bit you were referring to?
09:22:18 <quicksilver> the point is that javascript has lambdas and closures
09:22:20 <quicksilver> that's a fair point
09:22:28 <quicksilver> it puts it way ahead of C.
09:22:42 <quicksilver> of course, that 'everything-is-a-reference' rule makes the closures behave a bit surprisingly.
09:22:45 <ddarius> The main problem with JS in that regard is the quirky scoping
09:22:48 <BONUS> ddarius: whats the syntax for them again?
09:22:50 <quicksilver> but they work once you get past that.
09:22:51 <Beelse-YARR> dons: :D I'm having fun with it today :)
09:23:00 <ddarius> function (x) { return x; }
09:23:00 <quicksilver> function (x) { return x+1; }
09:23:05 <BONUS> ah yeah
09:23:06 <BONUS> lol
09:23:11 <quicksilver> ddarius: mine was 1 better than yours! :)
09:23:12 <micahcowan> subconscious, that's what he referred to, yeah.
09:23:13 <BONUS> totally forgot about that
09:23:25 <subconscious> micahcowan: That bit on wikipedia is fine and correct (for once)
09:23:30 <quicksilver> attaching event handlers in JS, as lambdas
09:23:33 <subconscious> micahcowan: but the general statement is rubbish
09:23:38 <sw17ch> JavaScript is a lot more functional-ly if you use prototype or jquery
09:23:44 <quicksilver> is way more pleasant than C function points
09:23:51 <quicksilver> or Java anonymous subclasses
09:23:56 <sw17ch> $R(1,10).toArray().each(function (v) { return v*2; });
09:24:01 <quicksilver> it's not much different to clever C++ template hacks
09:24:02 <sw17ch> with prototype
09:24:08 <quicksilver> although the syntax is less horidd.
09:24:10 <sw17ch> > [1..10]
09:24:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
09:24:15 <sw17ch> wait, i did that wrong
09:24:21 <sw17ch> $R(1,10).toArray().map(function (v) { return v*2; });
09:24:30 <sw17ch> > map (*2) [1..10]
09:24:31 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
09:25:38 <ScottMichael> ?src foldl
09:25:38 <lambdabot> foldl f z []     = z
09:25:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:25:48 <ScottMichael> ?src Data.List.foldl'
09:25:48 <lambdabot> Source not found. Do you think like you type?
09:26:17 <Deewiant> ?src foldl'
09:26:18 <lambdabot> foldl' f a []     = a
09:26:18 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:26:45 <Beelse-YARR> dons: did you get a pair of hs-plugins patches from me today?
09:27:20 <Beelse-YARR> I should warn you -- I accidentally left a couple of debugging prints in -- they're fairly obvious when you call eval
09:28:28 <dons> Beelse-YARR: i got the patches.
09:28:33 <Beelse-YARR> :)
09:28:56 <Botje> X marks the spot!
09:28:59 <Botje> patches ahoy!
09:29:15 <dons> Beelse-YARR: btw, another good stat, Arch Linux, a "typical" distro, has 573 haskell packages, and 522 python packages.
09:29:19 <dons> where's the library gap now :)
09:29:30 <shapr> w00h00
09:29:35 <dons> 105 ruby packages.
09:29:35 * shapr high fives dons
09:29:37 <dons> bring it on!
09:29:47 <Beelse-YARR> dons: :) that's useful amunition
09:30:11 <dons> http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=arch-haskell&SB=n&SO=a&PP=25&SeB=m&do_Orphans=
09:30:24 <sw17ch> lambadbot needs a pirate voice for today
09:30:25 <lambdabot> Title: AUR (en) - Search: arch-haskell, http://tinyurl.com/4qdgk2
09:30:35 <dons> http://aur.archlinux.org/packages.php?O=0&L=0&C=0&K=arch-haskell&SeB=m&SB=n&SO=a&PP=100&do_Search=Go
09:30:38 <dons>  is better
09:30:38 <lambdabot> Title: AUR (en) - Search: arch-haskell, http://tinyurl.com/3kv8b8
09:31:45 <shapr> @yarr
09:31:46 <lambdabot> I'll crush ye barnacles!
09:32:13 <shapr> Ye lambda lubbers!
09:32:51 <shapr> @users
09:32:51 <lambdabot> Maximum users seen in #haskell: 511, currently: 465 (91.0%), active: 19 (4.1%)
09:32:57 <shapr> w00! 511!
09:33:28 <sw17ch> avast! my curry 'as been plundered!
09:33:51 <micahcowan> Slashdot commenting must have changed quite a bit since the years-ago I last posted one. How are my comments getting a score of "2" as soon as I post them?
09:34:31 <sw17ch> micahcowan, probably because all of #haskell is hovering over the comments :P
09:35:01 * subconscious doesn't care what /. thinks
09:35:12 <shapr> Ohh, I want to look at slashdot too!
09:35:16 * EvilTerran doesn't believe that /. thinks
09:35:19 <EvilTerran> ;)
09:35:29 <sw17ch>  /. is where i go when i want to feel superior
09:36:00 <sw17ch> but then i find the one really useful comment and i feel like a n00b
09:36:09 <sw17ch> but hey, at least every one else is too
09:36:19 <EvilTerran> except that one guy
09:36:33 <sw17ch> right
09:37:25 * EvilTerran wonders how often "that one guy" is someone from #haskell
09:37:32 <shapr> Whoa Beelsebob is kickin butt on slashdot.
09:37:43 <sw17ch> EvilTerran, ^^
09:37:43 <EvilTerran> thought so :D
09:37:47 <sw17ch> hehe
09:37:52 <Beelse-YARR> shapr: :P
09:37:58 * shapr grins
09:38:08 <idnar> reading comments on Slashdot (and other sites) upsets me too much
09:38:09 <sw17ch> beelse be plunderin' their booty
09:38:26 <idnar> and almost everything interesting that's posted on Slashdot only makes it there a couple of weeks after I first hear about it
09:38:28 <micahcowan> sw17ch, yes, but literally in the result that appears after I click "Submit"? Are they really being modded faster than I see my own post result? No one can even _read_ that fast.
09:38:38 <idnar> so I generally just stay away from it
09:38:41 <micahcowan> Not that that necessarily stops /. modders...
09:39:12 <shapr> micahcowan: Are you related to John Cowan?
09:39:12 <sw17ch> micahcowan, i have no idea then :P
09:39:15 <micahcowan> idnar, yeah. But they beat the hell outta digg or youtube comments. :p
09:39:22 <idnar> micahcowan: I try not to read those either
09:39:50 <micahcowan> My dad, grand-dad, and brother are all John Cowan, but none is the one you're thinking of, shapr :)
09:39:56 <micahcowan> I've been told he hangs here periodically?
09:39:56 <shapr> oh, ok then
09:39:59 <shapr> He does
09:40:07 <EvilTerran> http://www.chrisfinke.com/addons/youtube-comment-snob/ <- relevant
09:40:12 <lambdabot> Title: YouTube Comment Snob
09:40:21 <shapr> micahcowan: He's easier to find on #swhack
09:40:28 <micahcowan> I encounter him from time to time on GNU and Unix-related MLs.
09:40:42 <shapr> jcowan is a cool guy
09:41:00 <micahcowan> Yeah, well, anyone who wrote an XML spec and other such things would have to be :)
09:41:29 <shapr> He's done a lot of neat stuff with languages of all sorts. I first encountered him in the lojban community.
09:41:37 <shapr> @users
09:41:38 <lambdabot> Maximum users seen in #haskell: 511, currently: 468 (91.6%), active: 17 (3.6%)
09:42:38 <shapr> Beelsebob: Dude, you seriously whooped up.
09:43:45 <micahcowan> Hm, maybe it's not "Score: 2" after all. Perhaps my own comments appear modded up to myself, or something, because when I look at "recent comments" on my profile, they're mostly at 1.
09:44:04 <shapr> $CLUELESS: Haskell is totally not real world. \n Beelsebob: Ever heard of Real World Haskell?
09:44:26 <shapr> micahcowan: Yeah, I think so.
09:48:02 <sw17ch> shapr: yeah, those are the ones that are making me laugh the most
09:49:17 <sw17ch> the "there aren't any libraries" -> hackage "it doesn't work well with other languages" -> FFI
09:50:17 * shapr comes up with generalized comment combinators: let slashdot = \cluelesscomment informedresponse -> ...
09:52:25 <sw17ch> let slashdot = (fileRead "/dev/urandom")
09:52:36 <sw17ch> woops
09:52:38 <sw17ch> readFile...
09:52:38 <sw17ch> dang
09:52:41 <shapr> haha
09:55:14 <Nafai> shapr: Happy Birthday yesterday!  Hope it was good!
09:55:18 <shapr> Yay!
09:55:29 <shapr> I was home sick, but I bought myself a guitar on Monday :-)
09:55:35 * shapr boings cheerfully
09:56:02 <sw17ch> > map ("Are you " ((++) . show)) [1..]
09:56:04 <lambdabot>   Couldn't match expected type `t -> a -> b'
09:56:07 <micahcowan> home sick, or homesick?
09:56:16 <sw17ch> > map (("Are you " ++) . show)) [1..]
09:56:18 <lambdabot>   mueval: Prelude.read: no parse
09:56:36 <shapr> Today I'm not at work because I was too sick. Yesterday I just left work early because I was sick.
09:56:43 <sw17ch> > map (("Are you " ++ $ show)) [1..]
09:56:45 <lambdabot>   mueval: Prelude.read: no parse
09:56:49 <sw17ch> dangitall
09:57:07 <shapr> sw17ch: Kommer du fran Alabama?
09:57:48 <sw17ch> non, je suis un Michigander
09:57:57 <shapr> Oh
09:57:59 <shapr> huh
09:58:02 <shapr> Ann Arbor?
09:58:09 <sw17ch> Grand Rapids
09:58:12 <shapr> oh neat
09:58:20 <sw17ch> in the area?
09:58:24 <shapr> Isn't that one of the firts cities that got WiMAX?
09:58:26 <shapr> Nah, I'm in Boston.
09:58:35 <shapr> I wish I had a personal info url in my username spot.
09:58:37 <shapr> I could do that ...
09:59:16 <sw17ch> shapr: haha, funny story about that...
09:59:44 <sw17ch> i worked for an ISP (startup) who wanted that
09:59:51 <micahcowan> > map (("Are you " ++) . show) [1..]
09:59:53 <lambdabot>   ["Are you 1","Are you 2","Are you 3","Are you 4","Are you 5","Are you 6","A...
09:59:54 <sw17ch> and then it didn't work
10:00:09 <Jedai> @src Array foldl
10:00:10 <lambdabot> Source not found. Are you on drugs?
10:00:11 <sw17ch> micahcowan, yeah, i'm not sure what i was thinking
10:00:14 <Jedai> @src Array fold
10:00:14 <lambdabot> Source not found. Where did you learn to type?
10:00:24 <Jedai> @src Maybe (>>=)
10:00:24 <lambdabot> (Just x) >>= k      = k x
10:00:24 <lambdabot> Nothing  >>= _      = Nothing
10:00:56 <micahcowan> @src List foldl
10:00:56 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:01:00 <sw17ch> shapr, but yes, we have wimax here
10:01:18 <sw17ch> though i don't know a single person who uses it...
10:02:15 <shapr> sw17ch: I'm jealous
10:02:35 <shapr> sw17ch: Wait what? They wanted that but it didn't work?
10:02:46 <sw17ch> shapr: the guys i worked for just didn't have the capacity
10:03:07 <shapr> It's 1-2.5Mb/sec yeah?
10:03:07 <sw17ch> (not to mention, none of us was very good at what we did... i was a freshman in college... i'm much better now :P )
10:03:11 <shapr> Per client?
10:03:12 <sw17ch> ish
10:03:24 <sw17ch> the stuff we did was most defnitely shared bandwidth
10:03:41 <sw17ch> but then again, i'm sure none of the tech is the same but the protocol
10:04:03 <roderyk> I have time-1.2.2.1 installed and after importing Data.Time.Clock I get errors about no instance of (Show UTCTime), which seems contrary to the haddock documentation. Am I doing something wrong or is there really no Show instance in the lib?
10:04:13 <shapr> Sprint is saying they'll put WiMAX in Boston as well, but they're six months behind. Rumor has it they just don't have enough bandwidth for even a small number of people using 2.5Mb/sec at the same time.
10:04:28 <sw17ch> shapr: the part that gets me is the latency
10:04:41 <shapr> wimax latency? what's different about it?
10:04:49 <sw17ch> well, just wireless latency to begin with
10:05:08 <sw17ch> especially when you travel cellular networks... it gets congested in a hurry...
10:05:09 <shapr> What flavors of wireless? wifi to gsm?
10:05:12 <sw17ch> but perhaps that's been fixed
10:05:16 <shapr> I don't know.
10:05:31 <sw17ch> shapr: i think i've expended the amount of my expertise on the subject :)
10:05:33 <roderyk> ah, checking the source shows only Eq and Ord instance.... I thought the haddock documentation was generated automatically from the source?
10:05:34 <shapr> heh
10:05:48 <sw17ch> if you watn to ask me about Motorola Canopy equipment, i'd be happy to talk about that... but ... it's been a while :)
10:05:53 <shapr> :-)
10:05:56 <shapr> I've never heard of it.
10:06:26 <BONUS_> i dont know why but i went through that Tony's exercise thing and finished it
10:06:29 <BONUS_> dont know why i just did
10:06:30 <sw17ch> shapr: it's really cool. you can have an access point that travels 10 miles with line-of-sight connections
10:06:30 <BONUS_> :[
10:06:31 <shapr> I'm pretty excited about the open source GSM implementation from the previous Burning Man.
10:06:41 <sw17ch> and if you get the backhaul setup, you can send a link over 15 miles at 20MBit/sec
10:06:48 <shapr> sw17ch: wow
10:06:53 <shapr> 20MBit??
10:06:56 <shapr> wow!
10:06:57 <sw17ch> it does 802.3 link emulation
10:07:09 <Peaker> shapr: The Burning Man festival?
10:07:23 <sw17ch> so, if you need a T3 or something between two locations, and don't want to pay for it
10:07:25 <shapr> Peaker: Yeah, they sort of had cellphone coverage for a short time...
10:07:28 <sw17ch> you can setup your own if you're close enough
10:07:42 <shapr> Peaker: Using a GNU USRP and a bunch of random hardware/software
10:07:45 <shapr> I was impressed.
10:07:51 <Peaker> cool
10:07:53 <sw17ch> does any one have an openmoko?
10:08:15 <shapr> Peaker: http://lwn.net/Articles/296949/
10:08:22 <lambdabot> Title: The OpenBTS project - an open-source GSM base station [LWN.net]
10:09:52 <marcot> Good afternoon.
10:09:59 <shapr> salut!
10:10:07 <marcot> How can I upload a darcs repository to code.haskell.org or darcs.haskell.org?
10:11:14 <dons> marcot: visit community.haskell.org and ask for an account
10:11:26 <shapr> Ooh, I should d othat.
10:11:58 <marcot> dons: thanks.
10:12:09 <shapr> Huh, I already have an account!
10:12:29 <sw17ch> shapr: parles vous francais?
10:12:32 <shapr> non, merci
10:12:36 <shapr> je ne parle pas francais!
10:12:45 <shapr> mais je taime les francaises!
10:12:48 * araujo wants a t-shirt with that "laziness keeps me pure" slogan
10:12:54 <shapr> haha
10:12:59 <shapr> araujo: That's great!
10:13:03 <dons> hehe
10:13:04 <shapr> sw17ch: talar du svenska?
10:13:10 <sw17ch> non
10:13:15 <shapr> That's especially funny for a geek...
10:13:17 <araujo> shapr, hah, SPJ interview!
10:13:18 <araujo> :-)
10:13:21 <sw17ch> I speak english and a vey small amount of french.
10:13:37 <shapr> I speak a bit of french, some british, and a decent chunk of Swedish.
10:14:06 <shapr> I tried to learn aussie at one point, but I only learn "stone the crows."
10:14:15 <shapr> Oh and strewth.
10:14:20 <daf> araujo: ha, I thought the same (re t-shirt)
10:15:36 <shapr> I can't remember my password on community.haskell.org
10:15:37 * shapr sighs
10:16:57 <smtms> shapr, may be it's an infinite list of characters
10:17:01 <shapr> Could be!
10:17:14 <shapr> I was seriously considering writing a pam plugin in Haskell yesterday.
10:17:15 <araujo> daf, ya!
10:17:24 <shapr> smtms: That's an excellent idea!
10:18:08 <daf> shapr: I hear they speak something like british in the new world too
10:18:24 <shapr> Really? Must be in the New England part.
10:18:38 <pao> I remember I've seen an artist that whose paintings are matemathical formulas... does anyone know the name?
10:18:56 <pao> %s/that//
10:19:03 <subconscious> pao: Euler
10:19:07 <daf> pao: Justin Mullins
10:19:14 <pao> subconscious: :-)
10:19:45 <pao> daf: yep! thanks :-)
10:20:31 <daf> pao: thank my electronic brain :)
10:20:44 <daf> which incidentally also turned up http://www.mightywombat.com/oldtoon.php?year=2007&id=297
10:20:51 <lambdabot> Title: Mighty Wombat Web Comic Archive :: math geek humor
10:21:37 <pao> daf: :-)
10:21:43 <pao> daf: delicious?
10:22:02 <daf> pao: yeah
10:23:06 <pao> I also remeber having seen some geeky "lambda" t-shirt...
10:23:30 <pao> daf: could you give your electronic brain a spin :-)
10:24:12 <amitprakash> how do i write this correctlty? [[x]|x<-["amit","abhi"]] && x/="amit"
10:24:39 <amitprakash> edit:  [[x]|x<-["amit","abhi"] && x/="amit"]
10:24:50 <subconscious> > [[x]|x<-["amit","abhi"] && x/="amit"]
10:24:51 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
10:24:53 <subconscious> > [[x]|x<-["amit","abhi"] , x/="amit"]
10:24:55 <lambdabot>   [["abhi"]]
10:25:20 <amitprakash> thanks.. and the bot is awesome  :)
10:25:32 <marcot> dons: in http://community.haskell.org/admin/tos.html, General Information, Entire Agreement, there's a missing )
10:25:33 <lambdabot> Title: Terms of Service
10:25:34 <daf> pao: it has failed us
10:26:06 <pao> daf: thanks anyway :-)
10:27:38 <amitprakash> so like we can say x<-list.. how do we so x\<-list?
10:28:03 <subconscious> amitprakash: To mean, x is not an element of list?
10:28:10 <amitprakash> yes
10:28:18 <amitprakash> [[x]|x<-["amit","abhi"] , x/<-["amit"]]
10:28:32 <subconscious> > [[x]|x<-["amit","abhi"] , not (x `elem` ["amit",""]]
10:28:32 <lambdabot>   mueval: Prelude.read: no parse
10:29:06 <kaol> > [[x]|x<-["amit","abhi"] , not (x `elem` ["amit",""])]
10:29:08 <lambdabot>   [["abhi"]]
10:29:44 <amitprakash> thanks a lot.. that just reduced some 5-6 lines of code to 1 :D
10:30:07 <subconscious> > let x /<- list = not (x `elem` list) in [[x]|x<-["amit","abhi"] , x /<- ["amit",""]]
10:30:09 <lambdabot>   [["abhi"]]
10:38:21 <mr_H> hi
10:38:29 <mr_H> has anyone here used happs ?
10:39:18 <dons> yeah. should be a few people
10:39:20 <dons> also in #happs
10:39:22 <Apocalisp> not a lot, but it sure looks cool
10:41:02 <mr_H> thanks dons
10:41:39 <amitprakash> h:y | last last h == head y , y<-["bat","cat","tab",talc"] , not(y `elem` h),h<-[["bat"],["cat"],["tab"],["talc"]]
10:41:42 <amitprakash> this is wrong why ?
10:42:59 <byorgey> amitprakash: the order matters
10:43:10 <amitprakash> ahh.. so what comes first?
10:43:16 <byorgey> in particular, y <- ... and h <- ... need to come before the tests where you mention them
10:43:33 <amitprakash> ahh .. thanks .. will retry
10:46:41 <amitprakash> [h:y | h<-[["bat"],["cat"],["tab"],["talc"]], y<-["bat","cat","tab",talc"]] is wrong still :S
10:47:36 <subconscious> amitprakash: What do you mean by wrong?
10:47:41 <amitprakash> it should be y:h
10:48:03 <amitprakash> > [y:h | h<-[["bat"],["cat"],["tab"],["talc"]], y<-["bat","cat","tab",talc"]]
10:48:04 <lambdabot>       lexical error in string/character literal at character '\n'
10:48:15 <Deewiant> http://www.reddit.com/r/programming/comments/72dvo/the_az_of_programming_languages_haskell/
10:48:17 <lambdabot> Title: The A-Z of Programming Languages: Haskell : programming, http://tinyurl.com/3nnpkj
10:48:20 <amitprakash> thats wrong :)
10:48:46 <byorgey> amitprakash: weird, that looks like it ought to work
10:48:58 <subconscious> > [y:h | h<-[["bat"],["cat"],["tab"],["talc"]], y<-["bat","cat","tab",talc"]]
10:49:00 <lambdabot>       lexical error in string/character literal at character '\n'
10:49:00 <byorgey> with y:h
10:49:10 <amitprakash> thought so too
10:49:21 <micahcowan> Deewiant, yeah, we've been discussing that (or more specifically, the slashdot discussion of it) for a bit :)
10:49:31 <byorgey> > [a:b | a <- [[1],[2]], b <- [3,4]]
10:49:32 <lambdabot>       No instance for (Num [[t]])
10:49:32 <lambdabot>        arising from the literal `3' at <int...
10:49:41 <byorgey> > [a:b | a <- [[1],[2]], b <- [3,4]] :: [[Int]]
10:49:42 <lambdabot>   Couldn't match expected type `Int' against inferred type `[t]'
10:50:11 <byorgey> > [b:a | a <- [[1],[2]], b <- [3,4]] :: [[Int]] -- oops
10:50:12 <lambdabot>   [[3,1],[4,1],[3,2],[4,2]]
10:50:18 <Deewiant> micahcowan: I had missed that so I thought I might as well paste it :-)
10:50:50 <amitprakash> now what did you write so differrently :)
10:50:50 <micahcowan> Well, looks like several folks have joined since that convo anyway. It's a good interview.
10:50:57 <micahcowan> 13 pages, though!
10:51:53 <dblazakis> ?info #haskell
10:51:53 <lambdabot> (# haskell)
10:52:30 <lilac> > [y:h | h<-[["bat"],["cat"],["tab"],["talc"]], y<-["bat","cat","tab","talc"]]
10:52:31 <lambdabot>   [["bat","bat"],["cat","bat"],["tab","bat"],["talc","bat"],["bat","cat"],["c...
10:52:47 <dblazakis> ?users #haskell
10:52:48 <lambdabot> Maximum users seen in #haskell: 511, currently: 485 (94.9%), active: 25 (5.2%)
10:53:31 <lilac> > [y:h | h<-[["bat"],["cat"],["tab"],["talc"]], y<-["bat","cat","tab","talc"], not (y `elem` h), last (last h) == head y]
10:53:32 <lambdabot>   [["tab","bat"],["talc","bat"],["tab","cat"],["talc","cat"],["bat","tab"],["...
10:54:23 <subconscious> @let x /<- list = not (x `elem` list)
10:54:25 <lambdabot>  Defined.
10:54:43 <BlackyKitty> Aye, how  is  e'eryone  doin'?   Gar.
10:54:45 <lilac> heh, nice
10:55:53 <lilac> > let ys = ["bat","cat","tab","talc"] in [y:h | h <- map return ys, y <- ys, y /<- h, last (last h) == head y]
10:55:54 <lambdabot>   [["tab","bat"],["talc","bat"],["tab","cat"],["talc","cat"],["bat","tab"],["...
10:56:05 <amitprakash> lilac, thanks.. i am still looking what was so differrent :)
10:56:16 <lilac> amitprakash: missing " from second talc
10:56:23 <amitprakash> ahh damn
10:56:48 <marcot> How can I use cabal to install a manpage?
10:57:03 <dcoutts> marcot: you'd have to use custom code in Setup.hs
10:57:15 <subconscious> amitprakash: something like this? http://rosettacode.org/wiki/Amb#Haskell
10:57:25 <marcot> dcoutts: ok, I'll see the doc.  Thanks.
10:57:26 <lambdabot> Title: Amb - Rosetta Code
10:57:47 <marcot> I'm trying to build Yi from darcs, and I'm getting:
10:58:06 <amitprakash> subconscious, wow.. yes :)
10:59:21 <amitprakash> lilac, the talc,bat entry in output is incorrect :P
10:59:53 <amitprakash> ah nm =_=
11:00:24 <roconnor> unless (joins w1 w2) (amb [])  === guard (joins w1 w2) ?
11:01:15 <roconnor> I like how amb is defined as id :)
11:02:06 <marcot> http://hpaste.org/10515
11:02:09 <BONUS_> this interview with SPJ is a pretty kewl read
11:02:17 <shepheb> I really enjoyed reading that
11:02:23 <BONUS_> hes a cool guy
11:02:40 <shepheb> the second-last question, about advice to students, is another great quote, from a very smart man, to prod doubters into trying FP
11:03:37 <marcot> Do you have a link for this interview?
11:03:39 <shepheb> my long-doubting roommate got forced into Erlang at Amazon, and now he's repeating back to me all the excited "isn't this awesome?!" stuff I said to him a year ago.
11:04:23 <BONUS_> http://www.computerworld.com.au/index.php/id;1974033854;fp;;fpid;;pf;1
11:04:32 <lambdabot> Title: Computerworld - The A-Z of Programming Languages: Haskell, http://tinyurl.com/4239yu
11:04:34 <Xenoblitz> Guys need some help http://hpaste.org/10516
11:05:25 <BONUS_> your indentation is off
11:05:41 <BONUS_> all the definitions in a where clause have to start at the same colum
11:05:42 <BONUS_> n
11:05:57 <shepheb> the if-then-else is broken too
11:06:03 <shepheb> the indentation, I mean
11:06:21 <Xenoblitz> weird ... notepad++ shows them as having the same indentation
11:06:24 <Xenoblitz> let me check
11:06:38 <BONUS_> it seems like you're mixing tabs and spaces
11:06:51 <BONUS_> just set it to use spaces only
11:07:37 <marcot> BONUS_: thanks.
11:08:40 <Xenoblitz> for crying out loud... it WAS the problem
11:08:43 <Xenoblitz> thanks guys
11:08:55 <Xenoblitz> btw
11:09:07 <Xenoblitz> does anyone know a good paper/book which deals about DSELs in Haskell?
11:09:15 <BONUS_> hmm dunno bout that
11:10:01 <Xenoblitz> Anyone?
11:10:06 <Xenoblitz> thanks the same BONUS
11:11:48 <MichaelGG> hey has anyone else read the Erik Meijer "Confessions of a Used Programming Language Salesman"?
11:15:31 <amitprakash> lilac, i noticed.. if for some x.. a corresponding y isnt found .. it doesnt create an answer as [x] alone.. why is that?
11:19:39 <dancor> MichaelGG: i just browsed it, i wonder what he thinks of happs
11:20:26 <amitprakash> subconscious, one last thing please http://pastebin.com/m533f263b
11:20:44 <amitprakash> thats the function i wrote with #haskell
11:20:47 <amitprakash> 's help
11:21:37 <amitprakash> the only problem being.. it eliminates all such results where no suitable y was found and hence drops all x's which dont use all the words
11:21:47 <amitprakash> how do i allow y to be [] in such case?
11:25:11 <pao_> http://hpaste.org/10517
11:25:39 <pao_> guards don't work in pattern matching + (<-), right?
11:26:14 <pao_> how do I achieve the same result of test in list comprehension in a do notation
11:26:15 <pao_> ?
11:26:45 <Deewiant> ?ty guard
11:26:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:26:49 <Deewiant> use that
11:28:12 <pao_> Deewiant: I'll try to do it :-)
11:28:17 <pao_> Deewiant: let me experiment
11:30:43 <ScottMichael> let x = Data.Map.insert "h" 1 Data.Map.empty
11:31:00 <ScottMichael> fromList [("h",1)]
11:31:07 <ScottMichael> i want to increase 1 here
11:31:11 <ScottMichael> how can i dot hat?
11:31:26 <Deewiant> ?ty M.update
11:31:27 <lambdabot> forall a k. (Ord k) => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
11:31:28 <Deewiant> ?ty M.adjust
11:31:30 <lambdabot> forall a k. (Ord k) => (a -> a) -> k -> M.Map k a -> M.Map k a
11:36:35 <ScottMichael> there is a mona din the first argument, how do i write that?
11:37:28 <SamB_XP> mona din? is that like a flaming mona lisa ?
11:37:59 <ski> (.. why flaming ?)
11:38:43 <ScottMichael> monad
11:38:53 <ScottMichael> Dmap.update w m
11:38:53 <dancor> is there a lib func that will convert like "3 days ago" to a time
11:38:56 <ScottMichael> doesnt work
11:39:22 <ski> ScottMichael> :t w
11:39:38 <mc__> dancor: I dont think its likely
11:39:44 <SamB_XP> ski: you never played Ocarina of Time?
11:40:07 <b4taylor> ski: You poor soul.
11:40:19 <ski> SamB_XP : .. i wondered if it was in reference to that (.. and i've only played it partly)
11:40:37 <BMeph> ScottMichael: Could you rephrase the question, I don't quite get what you're asking.
11:41:18 <BMeph> ScottMichael: How to write an (a -> Maybe a) function?
11:42:53 <ScottMichael> yes
11:43:21 <dancor> > M.adjust (+ 1) "h" $ M.singleton "h" 1
11:43:23 <lambdabot>   mueval: Prelude.read: no parse
11:43:25 <ScottMichael> ocarina of time == masterpiece
11:43:27 <ScottMichael> true
11:44:17 <dancor> > M.adjust (+ 1) "h" (M.singleton "h" 1)
11:44:18 <lambdabot>   mueval: Prelude.read: no parse
11:44:20 <dancor> wat
11:45:04 <dancor> > Map.singleton "h" 1
11:45:05 <lambdabot>       Failed to load interface for `Map':
11:45:05 <lambdabot>        Use -v to see a list of the ...
11:45:13 <dancor> lambdabot: don't start with me, don't you know i'm loco
11:45:54 <dancor> > Data.Map.singleton "h" 1
11:45:55 <lambdabot>   mueval: Prelude.read: no parse
11:46:40 <byorgey> ScottMichael: well, if you just wanted to add 1 to a number, you would write  \x -> x + 1, right?
11:46:42 <ScottMichael> $src Data.Map.singleton
11:46:45 <byorgey> > (\x -> x + 1) 3
11:46:47 <lambdabot>   4
11:46:51 <dancor> ScottMichael: i think to answer you question:  M.adjust (\ x -> x + 1)  is the same as  M.update (\ x -> Just (x + 1))
11:47:03 <byorgey> to make it (a -> Maybe a) instead of (a -> a), you can add a Just, like this:
11:47:13 <byorgey> > (\x -> Just (x+1)) 3
11:47:14 <lambdabot>   Just 4
11:47:18 <dancor> @src Data.Map.singleton
11:47:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:47:28 <byorgey> if you want to be a little more slick you can also write it as  Just . (+1)
11:47:35 <byorgey> > (Just . (+1)) 3
11:47:37 <lambdabot>   Just 4
11:47:43 <SamB_XP> @yow
11:47:44 <lambdabot> I just forgot my whole philosophy of life!!!
11:47:51 <SamB_XP> what the?!?>
11:48:16 <SamB_XP> aren't there supposed to be words in all caps in zippyisms ?
11:48:28 <SamB_XP> (not counting "I")
11:50:04 <dancor> SamB_XP: i found crosslang correlation supporting nocap: http://linux.duke.edu/projects/kibot/misc/rand.py
11:50:05 <ScottMichael> @src Data.Map.adjust
11:50:05 <lambdabot> Source not found. I am sorry.
11:51:56 <ScottMichael> what does in geenral stuff like (a -> a) mena when it is something ina paren? is that a function?
11:52:01 <Refried_> yes
11:52:05 <Refried_> (Scott)
11:52:15 <dancor> ScottMichael: of any type, to the same type
11:52:48 <dancor> @hoogle a -> a
11:52:49 <lambdabot> Prelude id :: a -> a
11:52:49 <lambdabot> Data.Function id :: a -> a
11:52:49 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
11:52:58 <Refried_> :t map is a good example too
11:52:59 <lambdabot> Not in scope: `is'
11:52:59 <lambdabot> Not in scope: `good'
11:52:59 <lambdabot> Not in scope: `example'
11:53:01 <dancor> @hoogle a -> b
11:53:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:53:02 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:53:02 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:53:03 <Refried_> oops
11:53:29 <idnar> :t map
11:53:30 <idnar> heh
11:53:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:53:55 <Apocalisp> @hoogle (a -> b) -> c
11:53:55 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
11:53:56 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
11:53:56 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:54:10 <Refried_> i'm having this problem with glut in ghci under windows, where when i close the gui window, i'd like it to return to the ghci prompt... but even with google i can't seem to figure it out... any tips?
11:56:14 <ScottMichael> http://hpaste.org/10518
11:56:16 <dons> woo more SPJ!
11:56:17 <dons> http://www.reddit.com/r/programming/comments/72dvo/the_az_of_programming_languages_haskell/
11:56:20 <lambdabot> Title: The A-Z of Programming Languages: Haskell : programming, http://tinyurl.com/3nnpkj
11:56:22 <ScottMichael> @src map
11:56:23 <lambdabot> map _ []     = []
11:56:23 <lambdabot> map f (x:xs) = f x : map f xs
11:56:49 <byorgey> ScottMichael: use (+1) instead of succ
11:56:57 <byorgey> succ is for things in the Enum type class
11:57:47 <byorgey> not everything in the Num type class is necessarily in Enum as well, which is why it is complaining.
11:58:07 <kaol> > succ 3.14159
11:58:08 <lambdabot>   4.14159
11:58:16 <byorgey> you could also put (Enum a, Num a) =>  in your type, but in this case it seems simpler just to use (+1).
11:58:17 <Deewiant> Char for instance is Enum but not Num
11:58:36 <Deewiant> can't think of something Num which isn't Enum though, maybe the Complex types?
11:58:45 <Deewiant> > succ (1 :+ 2)
11:58:47 <lambdabot>       No instance for (Enum (Complex t))
11:58:47 <lambdabot>        arising from a use of `succ' ...
11:58:51 <Deewiant> yeah
11:58:51 <byorgey> bingo!
11:58:58 <ScottMichael> thanks
11:59:01 <Deewiant> > (1 :+ 2) + 1
11:59:02 <lambdabot>   2.0 :+ 2.0
11:59:26 <ScottMichael> my haskellcode is much shorter than my pyhtoncode but iw rite my pythoncode in 2 seconds and my haskellcode in 10minutes lol
11:59:31 <ScottMichael> but its getting better
11:59:57 <byorgey> ScottMichael: that's to be expected while you're first learning =)
12:00:18 <BONUS_> i also came from python and now i do stuff faster in haskell
12:00:24 <BONUS_> well depends on what kind of stuff
12:00:26 <BONUS_> but generally
12:00:45 <subconscious> I came from the moon
12:00:50 <subconscious> I'm not sure where I am now
12:00:52 <sw17ch> subconscious, you too?
12:00:57 <dancor> so lua?
12:01:39 <micahcowan> ha
12:03:04 <dons> ScottMichael: yeah, takes time. my haskell's easily the fastest code i write now.
12:03:11 <dons> you just have to learn new  APIs
12:03:19 <dons> and new techniques.
12:03:29 <dons> there's big pay offs
12:03:36 <dons> ?users
12:03:36 <lambdabot> Maximum users seen in #haskell: 511, currently: 481 (94.1%), active: 28 (5.8%)
12:04:27 <arjanb> dons: btw why doesn't Data.Binary have putBytes while there's getBytes?
12:05:12 <Vq^> i came from C, my programs run slower now but they get implemented :)
12:07:53 <SamB_XP> Vq^: why would you have run programs you never finished ?
12:08:39 <dons> arjanb: hmm
12:09:14 <dons> arjanb: ah i guess no one wanted it
12:09:25 <dons> the get* stuff was demand from people writing parsers
12:09:30 <Beelsebob> well, today gave me good karma on /.
12:09:30 <Vq^> SamB_XP: has anyone made any other nontrivial C programs? :o)
12:09:31 <Beelsebob> >.<
12:09:41 <dons> Vq^: i hope they don't run too much slower..
12:10:03 <Vq^> dons: no, my Haskell has really improved the last year
12:10:10 <SamB_XP> Vq^: or do you mean your C programs segfaulted quickly ?
12:10:52 <SamB_XP> @hoogle peek
12:10:52 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
12:10:52 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
12:10:52 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
12:11:46 <amitprakash> how do i get the difference of two lists?
12:11:47 <Vq^> SamB_XP: i exaggerated a bit but there are two parts to it, it takes longer time to write in C and there are often compromises to the functionallity involved
12:12:04 <arjanb> dons: i want to read and write certain file formats, reading is going nicely but writing without a few low level functions is a bit awkward
12:12:08 <SamB_XP> main = peek nullPtr :: IO CInt
12:12:19 <subconscious> amitprakash: Maybe you could use <- and /<- that we defined?
12:12:32 <Vq^> SamB_XP: unnecessary limits because it's so much easier to do
12:12:33 <amitprakash> hmm yeah
12:12:40 <Vq^> SamB_XP: thats a nice trick :)
12:12:47 <Deewiant> > [1..10] \\ [5..8]
12:12:48 <lambdabot>   [1,2,3,4,9,10]
12:12:56 <dons> arjanb: yeah, there's only the 'primitives'
12:13:00 <SamB_XP> Vq^: you can quickly segfault in Haskell, too ;-P
12:13:09 <dons> but you can build up more complicated writing options and send us the patch
12:13:38 <Vq^> i have actually segfaulted Haskell programs
12:13:56 <subconscious> amitprakash: Did you see that you can actually use /<- literally?
12:14:01 <subconscious> > let x /<- list = not (x `elem` list) in [[x]|x<-["amit","abhi"] , x /<- ["amit",""]]
12:14:03 <lambdabot>   [["abhi"]]
12:14:06 <subconscious> amitprakash: examples ^
12:14:16 <SamB_XP> not <- though ;-P
12:14:46 <Vq^> there was some weird bug on my arch in ghc6.6 when using STM
12:15:02 <Vq^> caused a few segfaults, very tricky to put the finger on :/
12:15:04 <SamB_XP> > let x <- y = elem x y in 1 <- [0..100]
12:15:05 <lambdabot>   mueval: Prelude.read: no parse
12:15:12 <dons> try using 6.8.x
12:15:22 <dons> its about a year newer, and a year's less isues
12:15:27 <Vq^> dons: i upgraded and it has worked flawlessly since
12:15:41 <SamB_XP> @slap gwern
12:15:41 * lambdabot hits gwern with an assortment of kitchen utensils
12:15:46 <SamB_XP> lol
12:15:56 <Vq^> i haven't succedded in writing many bugs either :)
12:16:09 <Vq^> @annoy SamB_XP
12:16:09 <lambdabot> Unknown command, try @list
12:16:13 <Vq^> aw
12:16:41 <SamB_XP> @slap SamB_XP
12:16:42 * lambdabot smashes a lamp on SamB_XP's head
12:16:48 <SamB_XP> @slap lambdabot
12:16:49 * lambdabot loves lambdabot, so no slapping
12:16:54 <Vq^> hah
12:16:55 <pao> whoever has suggested guard to me ... thanks with some delay (the pc crashed :-) )
12:17:54 <SamB_XP> @get-shapr
12:17:55 <lambdabot> shapr!!
12:18:11 <SamB_XP> Vq^: that's the closest we have to @annoy ;-P
12:19:09 <Vq^> oh no, you summoned the deamon :o)
12:19:36 <SamB_XP> what daemon?
12:19:48 <SamB_XP> I didn't know shapr was a server!
12:20:36 <Vq^> i didn't write daemon
12:21:12 <SamB_XP> well, you didn't write demon either ;-P
12:21:13 <Vq^> i failed to spell any word :P
12:21:37 <Vq^> dyslectics of the world untie!
12:22:41 <SamB_XP> you seem to be missing an x
12:22:45 <marcot> dcoutts: To use Cabal to install make, I have to set the userhooks?
12:22:56 <marcot> dcoutts: Or am I in the wrong path?
12:22:59 <Vq^> SamB_XP: yeah, im not really good at anything it seems
12:23:12 <lispy> hey guys
12:23:20 <Vq^> hiya lispy
12:23:21 <lispy> how is code?
12:24:08 <SamB_XP> C++ is boring when things go well
12:24:29 <lispy> SamB_XP: heh
12:24:37 <Vq^> SamB_XP: thats unrelated to how well things go
12:24:46 <SamB_XP> Vq^: no, it isn't
12:24:47 * lispy just spent the morning reading the source code of franchise -- not impressed.
12:24:58 <SamB_XP> when things don't go well, it's instead overly interesting
12:25:55 <Vq^> SamB_XP: are you some sort of masochist?
12:25:58 <kaol> grr. I wish cyclic module deps were easier to do... the only reason I'm doing it is since I want to reuse record labels and rather import them qualified if I need both. looks like going for uglier names and putting them in the same module is the way to go.
12:26:11 <SamB_XP> Vq^: no
12:26:47 <SamB_XP> but I can't exactly complain of boredom when I'm trying to track down crazy segfaults ;-P
12:27:10 <lispy> kaol: I've always been able to factor the common bits to one module and then import that as needed
12:27:22 <Vq^> i think it gets old pretty quick :/
12:27:38 <lispy> SamB_XP: what C++ code are you working on?
12:27:56 <SamB_XP> lispy: for a class that is supposedly about data structures
12:28:08 <lispy> SamB_XP: ah, welcome to university
12:28:19 <SamB_XP> ... unfortunately, only half of the class already had C++
12:28:26 <kaol> lispy: it's not hard to do, but the namespace gets crowded.
12:28:32 <SamB_XP> and half of that half is me
12:28:33 <lispy> I remember friends of mine complaining when graph theory required C
12:28:39 <Vq^> i took such a course last spring
12:28:47 <Vq^> we got to choose our language
12:29:32 <Vq^> same teacher and same policy in the AI course im taking now, really nice
12:29:33 <syscrash> does HOOD (http://www.haskell.org/hood/) work with recent versions of GHC? I am encountering difficulty trying to make it work.
12:29:34 <lispy> The prof said students could argue to use whatever language they wanted, but in practice he started rejecting arguments on the basis that, "Using C is good for you and I'm the prof."
12:29:37 <kaol> and some of the records represent things out of a spec and it reuses what's supposed to be the records' labels. meh.
12:29:50 <SamB_XP> quiz: can anyone tell me how many students are in the class ?
12:29:56 <Beelsebob> syscrash: you may have *slightly* more success with Hat
12:30:01 <kaol> I'll need to add prefixes to the names
12:30:13 <Beelsebob> that too though is a little touch and go
12:30:18 <Beelsebob> syscrash: haskell.org/hat
12:30:21 <shapr> Wahrgh? I was summoned?
12:30:32 <Beelsebob> @getshapr?
12:30:32 <lambdabot> shapr!!
12:30:35 <shapr> whee!
12:30:37 <lispy> shapr: heya
12:30:43 <shapr> hiya!
12:30:48 <Vq^> formarn!
12:30:50 <lispy> franchise does not build on osx
12:30:52 <SamB_XP> shapr: you can see why above ;-P
12:31:01 * Beelsebob hugs shapr, just in case the summoners don't want you any more
12:31:06 <lispy> in case that was keeping anyone awake at night
12:31:16 <shapr> whee!
12:31:18 * shapr hugs Beelsebob
12:31:19 <SamB_XP> Beelsebob: oh, we never *actually* wanted him
12:31:19 <tristes_tigres> hi
12:31:23 * shapr sniffles
12:31:26 <SamB_XP> hehehe
12:31:38 <SamB_XP> (I knew you would do something like that when I said that!)
12:31:39 * Beelsebob ponders if we need an @getdons @getdcoutts and @getvariousotheropps command
12:31:40 <fnord789> Does Clemens Fruhwirth frequent #haskell? I'm interested in finding out the status of his work on Graphics.X11.Xrender
12:31:43 <Vq^> shapr: we didn't mean any disrespect, we only wanted to annoy you
12:31:47 <SamB_XP> shapr: not that we dis-wanted you
12:31:48 <shapr> hah
12:31:56 * shapr goes back to cleaning house for visitors
12:31:58 <SamB_XP> well, actually, the other one said something about you being a deamon
12:32:02 <SamB_XP> ;-P
12:32:16 <SamB_XP> shapr: can you tell me what a deamon is ?
12:32:19 <Vq^> none said that... *looking away*
12:32:28 <shapr> Not till my apartment is clean
12:32:37 * SamB_XP steals shapr's dust lambdas
12:32:55 <arjanb> dons: it turned out putByteString is what i need, i pnly got confused by the fact it doesn't do the same as the Binary instance for ByteString
12:33:08 <syscrash> hm alright, thanks Beelsebob
12:34:32 <Beelsebob> syscrash: I know a fair bit about hat's building idiosyncracies, so give me a yell if you want help -- hat's direct equiv of hood is hat-observe, but it's usually used as a gateway to the other more interesting debuggers (hat-trail, hat-detect, hat-explore and hat-anim)
12:37:57 <Beelsebob> syscrash: there is ofc also the ghci debugger, but it (a) takes rather more technical know-how to work (b) isn't always as good at showing you were the bug really is
12:38:23 <Beelsebob> it does however (a) not require tracing (b) not require your code to be Haskell 98 (or close to)
12:38:58 <SamB_XP> that is, it works on anything that GHCi works on ... which is most GHC Haskell
12:39:05 <Beelsebob> indeed
12:39:16 <SamB_XP> (but nothing that uses unboxed types)
12:39:25 <Beelsebob> oh? I didn't realise that constraint
12:39:41 <SamB_XP> well, it's not all that bad
12:39:45 <Beelsebob> no
12:39:53 <mc__> is there a tool for measuring haskell code coverage
12:39:57 <Beelsebob> yep
12:39:58 <Beelsebob> hpc
12:40:00 <lispy> mwc: HPC
12:40:03 <lispy> er
12:40:09 <lispy> mc__: it's part of ghc
12:40:15 <SamB_XP> if you use them, you had better write code that won't need much debugging ;-)
12:40:21 <mc__> great
12:40:33 <SamB_XP> (in those modules)
12:40:40 <Beelsebob> SamB_XP: hehe, actually, that's my main reason for not liking ghci debugger
12:40:51 <Beelsebob> it targets the kind of bug that haskell programmers don't write
12:40:56 <SamB_XP> hmm?
12:41:03 <Beelsebob> i.e. it targets the simple typo that more often than not the type system catches
12:41:16 <Beelsebob> it doesn't target the major logical error
12:41:21 <SamB_XP> ah
12:41:30 <Beelsebob> which things like hat-detect/hat-explore do
12:41:37 <Beelsebob> (although inefficiently)
12:45:10 <Saizan_> it's very useful if you've some call to "error" hidden somewhere
12:45:16 <Beelsebob> indeed
12:45:29 <Beelsebob> but then it's only really being used as a "give me a stack trace" utility
12:52:35 <sw17ch> does the concept of a "stack trace" work very well with ahskell?
12:53:00 <sw17ch> so much of it seems to operate without a growing stack...
12:53:27 <Heffalump> it doesn't really, but you can trace call chains
12:53:30 <Heffalump> at some overhead
12:54:04 <sw17ch> actually, i have been curious about that... how does Haskell's stack compare to the C one?
12:54:38 <sw17ch> somehow i have it in my mind that haskell doesn't use the branch-and-link instruction all that much
12:54:50 <pfo> how good are the haskell debuggers?
12:54:56 <pfo> comparable to gdb?
12:54:57 <Heffalump> pfo: awful IMO
12:55:13 <Heffalump> ghci is just about usable to track down exceptions, occasionally
12:55:16 <pfo> good lisp envs have really _nice_ debuggers imho
12:55:56 <pfo> i assumed it would be easy to write good debuggers for pure langs
12:56:17 <Beelsebob> hahahaha, someone just made an awesome response to one of my comments today
12:56:17 <subconscious> pfo: I don't think it's ever easy to write a debugger
12:56:18 <pfo> lazy eval seems to be the hard part of the debugger
12:56:42 <subconscious> pfo: Have you tried to implement one or just conjecturing?
12:56:46 <pfo> Beelsebob: ofc, but it's a well understood problem
12:57:02 <Beelsebob> pfo: lazy eval isn't a hard thing to do in a debugger at all
12:57:03 <pfo> that one should have been for subconscious
12:57:13 <Beelsebob> all you have to do is make the debugger declarative as well as the language
12:57:20 <pfo> subconscious: just looked at the priciples of dubggers for C
12:57:22 <sw17ch> Beelsebob: link?
12:57:26 <Beelsebob> the debugger should not depend on time, in the same way as the language doesn't
12:57:37 <Beelsebob> sw17ch: http://linux.slashdot.org/comments.pl?sid=969527&cid=25072625 <-- last comment
12:57:43 <lambdabot> Title: Why Lazy Functional Programming Languages Rule
12:58:12 <sw17ch> Beelsebob, that comment is gold
12:58:15 <Beelsebob> pfo: algorithmic debugging works wonderfully -- it's just a shame Haskell changes so fast no one can write one for it
12:58:18 <subconscious> Lazy Functional Programming Languages.. plural?
12:58:19 <Beelsebob> sw17ch: :D
12:58:28 <subconscious> Which other languages are we talking about?
12:58:32 <subconscious> Haskell and ...?
12:58:39 <Beelsebob> subconscious: Haskell isn't a lazy language
12:58:43 <Beelsebob> it's a non-strict language
12:59:13 <subconscious> Beelsebob: Haskell is lazy, it also has multiparameter typeclasses and unsafeCoerce
12:59:26 <Beelsebob> subconscious: no, haskell is non-strict
12:59:35 <Beelsebob> just most compilers implement non-strictenss as lazyness
12:59:39 <fnord789> Lol "not everyone who is building rails sites [blah blah blah]. we, the doers of awesome [blabbidy blah blah]"
12:59:45 <SamB_XP> Beelsebob: we are too lazy to call it that though
12:59:52 <Beelsebob> there have been some that have implemented optimistic evaluation for example though
12:59:55 <SamB_XP> it's too much typing!
12:59:56 <Beelsebob> SamB_XP: :D
13:00:27 <sw17ch> lazy -> nons<tab>
13:00:29 <subconscious> Beelsebob: I know what you're saying, being anal about the H98 and all, but this is 1) boring 2) not ##c 3) completely irrelevant to what I was asking
13:00:39 <sw17ch> yeah, even with tab completion, it's still harder to type :)
13:01:00 <Beelsebob> depends if you use a dvorak layout or not
13:01:06 <Beelsebob> non<tab> is really easy on dvora
13:01:10 <Beelsebob> dvorak*
13:01:21 <SamB_XP> subconscious: I don't think I've seen any arguments on this particular topic in ##c -- YET
13:01:54 <SamB_XP> I might be wrong about that though
13:02:22 <SamB_XP> and it's quite possible that such an argument happened while I was away ;-)
13:02:25 <subconscious> SamB_XP: I meant being anal about standards to the point that nobody is actually able to communicate
13:02:41 <SamB_XP> it's kind of important to be anal about C though
13:03:17 <SamB_XP> -- it has a tendancy to bite you in the ass if you aren't!
13:03:30 * Beelsebob notes that drinking rum every time I want to hum along with pirates of the carribean might not have been such a good plan
13:03:43 <dons> http://www.reddit.com/r/programming/comments/72f3t/improving_your_desktop_experience/  yay more xmonad blogs
13:03:45 <lambdabot> Title: Improving your desktop experience : programming, http://tinyurl.com/5xp9dt
13:04:02 <subconscious> so, What other languages than haskell is that thread about?
13:04:19 <SamB_XP> Beelsebob: won't that just make you want to hum along MORE?
13:04:29 <SamB_XP> or worse, to SING along?
13:04:33 <subconscious> why is it called "Why Lazy Functional Programming Languages Rule" and not "Why Haskell Rules"
13:04:34 <Beelsebob> SamB_XP: yeh, that seems to be the approximate effect, yes
13:04:50 <Beelsebob> subconscious: because SPJ is talking in general about lazy functional programming
13:05:07 <Beelsebob> all the points he makes apply to any lazy funcitonal language you care to invent
13:05:19 <Philippa> Beelsebob: ...don't tempt me
13:05:29 <Beelsebob> Philippa: the rum thing?
13:05:31 <Philippa> (but within reason!)
13:05:34 <sw17ch> Beelsebob, it seems every commenter forgot the title immediately
13:05:51 <Beelsebob> sw17ch: well, very true -- even SPJ forgot I think
13:05:55 <Beelsebob> he talks a lot about haskell
13:05:59 <Beelsebob> not lazy languages in general
13:06:06 <Philippa> Beelsebob: I meant the "any language I care to invent" :-)
13:06:16 <SamB_XP> Beelsebob: don't tempt Philippa to invent lazy functional languages ;-P
13:06:16 <BMeph> @quote anal
13:06:16 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
13:06:21 <Beelsebob> oh, I see
13:06:22 <BMeph> @quote anal
13:06:22 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
13:06:22 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
13:06:31 <Beelsebob> thing is, about 20 lazy functional languages are invented in here every day
13:06:38 <BMeph> @quote Sam_XP
13:06:38 <lambdabot> No quotes match. You speak an infinite deal of nothing
13:06:43 <Beelsebob> just most of them have very similar syntax and semantics to haskell
13:06:43 <SamB_XP> Beelsebob: WHAT?
13:06:45 <BMeph> @quote SamB_XP
13:06:46 <lambdabot> SamB_XP says: oh. does A/S/L mean Age/Sex/Programming Language?
13:06:47 <SamB_XP> and I missed it?
13:06:52 <Beelsebob> SamB_XP: :D
13:07:09 <SamB_XP> er, miss it almost every day?
13:07:14 <Vq^> Philippa: do you have some lazy cobol in your head wanting to get out? :o)
13:07:16 <pfo> how is one supposed to get levels for frag?
13:07:26 <Beelsebob> Vq^: BLASPHAMY!
13:07:35 <Beelsebob> get drinking more rum
13:07:37 <Philippa> pfo: the level format's the same as Quake 3's, isn't it?
13:07:52 <Vq^> Beelsebob: srry :(
13:08:00 <SamB_XP> Philippa: so what is the difference between it and Q3?
13:08:03 <sw17ch> Beelsebob, i have at least an hour until i can start drinking rum... oh no! i don't have any at home!
13:08:15 * BMeph wants to see a lazy COBOL implementation... his wife has been annoying him lately...
13:08:19 <Beelsebob> sw17ch: I deliberatly bought some on my way home
13:08:34 <sw17ch> I have some Tequila... but that is decidedly not good for me
13:08:48 <sw17ch> and rum is a far more appropriate drink for today
13:08:54 <mc__> alcohol is not good for anyone
13:08:54 <Beelsebob> I discovered a new rum that I like by buying some random stuff on the way home
13:09:03 <SamB_XP> mc__: hahaha
13:09:04 <BMeph> sw17ch: Aye, lad! ;)
13:09:10 <SamB_XP> mc__: you know that's not true
13:09:18 <Philippa> SamB_XP: pretty big. Frag's effectively a small tech demo
13:09:29 <mc__> I know it *is* true.
13:09:32 <Philippa> doesn't have all the mod hooks, for example
13:09:33 <SamB_XP> there have been studies ...
13:09:42 <BMeph> Beelsebob: Drive-by shopping, now *there's* one for the books! ;)
13:09:44 <sw17ch> me to my wife: "But why's the rum gone!!??" , my wife to me: "What?"
13:09:45 <SamB_XP> showing that moderate amounts are good for you ...
13:09:46 <dons> ?users
13:09:47 <lambdabot> Maximum users seen in #haskell: 511, currently: 483 (94.5%), active: 17 (3.5%)
13:09:56 <Beelsebob> Philippa: I was actually really rather pleasantly surprised by the OpenGL performance I got out of Haskell
13:09:59 <mc__> yeah, moderate amounts, of course
13:10:13 <mc__> but getting drunk is obviously bad
13:10:14 <Beelsebob> specifically, display lists + haskell == rather beautiful results
13:10:26 <SamB_XP> mc__: you said alcohol, though
13:10:39 <micahcowan> What do I add to, e.g., ' -e 'interact $ unlines . map (Char.toupper . reverse) . lines'
13:10:45 <pfo> Philippa: anny idea from where to get an example map to see frag in action?
13:10:45 <SamB_XP> you said it isn't good for ANYONE
13:10:47 <micahcowan> s/'/ghc/
13:10:53 <micahcowan> to make it import Data.Char first?
13:10:56 <Beelsebob> mc__: I be not worrying about drunken strunkards, if it be talk like a pirate day
13:11:30 <Beelsebob> micahcowan: tbh, just open ghci
13:11:39 <SamB_XP> Beelse-YARR: so ... why aren't you saying anything?
13:11:46 <Beelsebob> SamB_XP: that's me at work
13:11:53 <SamB_XP> Beelsebob: oh
13:11:53 <Beelsebob> (but I'm not)
13:11:58 <pfo> Philippa: solved. there was a sample level included with frag.
13:12:03 <SamB_XP> Beelsebob: so I gather
13:12:20 <mc__> apropos frag, I
13:12:24 <sw17ch> does any one play Sins of a Solar Empire?
13:12:36 <mc__> I'm planning to write a RTT in haskell
13:12:38 <pfo> sw17ch: is it a haskell based game too?
13:12:43 <Beelsebob> mc__: RTT?
13:12:45 <micahcowan> Beelsebob, really? There's no way to do it with -e? Doesn't that rather severely limit it's usefulness?
13:12:50 <mc__> real time tactics
13:12:56 <micahcowan> * its
13:12:56 <Beelsebob> micahcowan: no idea
13:13:01 <SamB_XP> what's that difference between RTT and RTS?
13:13:02 <sw17ch> pfo: no, but it's a game that could use some haskell tools for the maps/mods
13:13:05 <Beelsebob> mc__: oh -- RTS, only actually inolving strategy?
13:13:06 <mc__> like an RTS but without the resource gathering/ base building part
13:13:11 <SamB_XP> oh
13:13:11 <Beelsebob> ah, cool
13:13:21 <sw17ch> :)
13:13:28 * Beelsebob switches from liking RTSes to RTTs
13:13:30 <SamB_XP> so, you mean like one of the "no base" levels in an RTS?
13:13:42 <mc__> yeah like that
13:13:43 <Beelsebob> I hate the whole two different time scales at the same time thing
13:13:43 <sw17ch> Sins of a Solar Empire involves ... lots of stuff
13:13:48 <sw17ch> but it's hordes of fun
13:14:01 <mc__> Rush for Berlin is an RTT for example
13:14:02 <Beelsebob> SamB_XP: or with a base, but without it ever developing
13:14:16 <Beelsebob> because you know, you don't usually build things during a battle
13:14:39 <sw17ch> Sins focues  on universal domionation
13:14:40 <SamB_XP> Beelsebob: true
13:14:51 <Philippa> Beelsebob: to be fair, Quake 3 now runs reasonably fast if compiled from C to Flash...
13:15:14 <SamB_XP> so why is it called an RTT?
13:15:22 <Beelsebob> Philippa: what I mean is loading obj models with ~1,000,000 polygons in, and having them render with *really* na√Øve code at 1800fps
13:15:29 * SamB_XP still doesn't undestand the difference between tactics and strategy
13:15:37 <Beelsebob> SamB_XP: strategy is longer term
13:15:39 <SamB_XP> you can see why I'm not in the military ;-P
13:15:51 <Beelsebob> tactics is about a single battle
13:15:55 <Beelsebob> strategy is about the whole war
13:15:59 <mc__> exactly
13:15:59 <subconscious> tactics are how you prove theorems.. stategy is how you write concurrent programs ...
13:16:08 <SamB_XP> subconscious: lol
13:16:25 <Beelsebob> :D well said subconscious
13:17:51 <BMeph> micahcowan: Have you tried adding "import Data.Char;" to it already? ;)
13:18:27 <Philippa> Beelsebob: how naive is really naive?
13:18:42 <Beelsebob> Philippa: glBegin/glEnd code
13:18:46 <Beelsebob> no vertex array
13:18:51 <Beelsebob> no vertex buffer objecs
13:18:57 <Beelsebob> but it does use display lists
13:19:10 <Philippa> ...which're getting some attention these days, so that kinda nullifies the naivety
13:19:16 <Beelsebob> well no
13:19:21 <Beelsebob> nVidia have a good implementation
13:19:28 <Beelsebob> which makes them about as good as vertex arrays
13:19:39 <Beelsebob> but ATi's implementation is still crappy in comparison to VAs
13:20:07 <SamB_XP> so, strategy would be things like thinking about leveling your units ?
13:20:09 <Beelsebob> but either way, 18 billion polygons per second is really quite a lot
13:20:12 <Philippa> eh, if the verts get onto the GPU's RAM that's the big part out of the way
13:20:20 <ScottMichael> System.Random.getStdRandom (System.Random.randomR (0,1))
13:20:20 <ScottMichael> 1
13:20:26 <Philippa> SamB_XP: Strategy would involve things like production, supplies, political issues...
13:20:30 <Beelsebob> SamB_XP: yep, and thinking about building your fort, rather than just dealing with what you have and going for it
13:20:34 <ScottMichael> how do i get a random val between 0 and 1?
13:20:37 <ScottMichael> float obv...
13:20:51 <Beelsebob> Philippa: yes, but ATi's drivers don't manage to convert display lists into VA's
13:20:51 <micahcowan> BMeph, adding it to what? That's not a legal part of an expression.
13:20:54 <subconscious> > randomR (0,1) :: Float
13:20:55 <lambdabot>   Couldn't match expected type `Float'
13:20:58 <Beelsebob> so they don't all end up on the card straight away
13:21:06 <subconscious> > randomR (0,1) (mkStdGen 333) :: Float
13:21:08 <lambdabot>   Couldn't match expected type `Float'
13:21:12 <subconscious> something like that
13:21:20 <Beelsebob> > randomR (mkStdGen 333) :: IO Float
13:21:20 <BMeph> micahcowan: NM, i just tried it, myself... :(
13:21:22 <lambdabot>   Couldn't match expected type `(a, a)'
13:21:31 <Beelsebob> > randomR (0,1) (mkStdGen 333) :: IO Float
13:21:31 <Saizan_> > snd $ randomR (0,1) (mkStdGen 333) :: Float
13:21:33 <lambdabot>   Couldn't match expected type `IO Float'
13:21:33 <lambdabot>   Couldn't match expected type `Float' against inferred type `StdGen'
13:21:39 <Saizan_> > fst $ randomR (0,1) (mkStdGen 333) :: Float
13:21:41 <lambdabot>   0.85639095
13:21:49 * Saizan_ wins
13:21:54 <Beelsebob> damn you :P
13:24:33 <BMeph> SamB_XP: Strategy is placing scouts in spots so that you know where to send your main force by which death scream you hear... ;)
13:24:54 <Beelsebob> BMeph: no, that's tactics
13:25:23 <Beelsebob> strategy is building bases in places you know the enemy can't attack for a long time, and even if they can, they won't have much success
13:25:42 <Beelsebob> tactics is anything that doesn't involve a permanent presense
13:26:01 <BMeph> Beelsebob: ...yeah, it is. Fine, I'll think of another.
13:26:32 <Beelsebob> our resident artist at anygma actually has some early demos of a fekking awesome RTT
13:26:46 <dons> hey, where's the anygma blog? :)
13:26:54 <Beelsebob> dons: ohhh, that's a good idea
13:26:57 <dons> Beelsebob: is anygma coming to ICFP?
13:27:00 <Beelsebob> that's a very very good idea
13:27:12 <dons> galois' blogging now.
13:27:17 <Beelsebob> dons: not this year no, but I could certainly be encouraged to try and write something next year
13:27:21 <dons> let's get the entire commercial community talking.
13:27:23 <Philippa> as a rule, strategy in RTSes tends to revolve around resources, perhaps any massively significant chokepoints and perhaps any diplomacy issues in a FFA game
13:27:43 <Beelsebob> dons: that really is a good idea -- I'll have a chat with conal about it, I'm sure he'll be keen on it
13:27:55 <Beelsebob> I'm sure luqui will be too
13:27:58 <ScottMichael> why mkStdGen 333 ? what does 333 stand for?
13:28:04 <Beelsebob> ScottMichael: it's the random seed
13:28:08 <Beelsebob> it can be anything you like
13:28:10 <Deewiant> three hundred and thirty-three
13:28:23 <Beelsebob> (usually the current time)
13:28:26 <mc__> I'd prefer 42
13:28:38 <Beelsebob> (because it provides something that varies enough)
13:28:55 <BMeph> Strategy is design, and tactics is implementation! ;p
13:29:07 <Beelsebob> BMeph: that may be a pretty damn good explanation actually
13:29:16 <mc__> indeed
13:29:52 <Beelsebob> I've so far found *no* good RTTs
13:30:08 <Philippa> certainly you've got much bigger problems if you have to change your strategy
13:30:09 <Beelsebob> players can always see too much of the map / the map is always too small
13:30:10 <dons> Beelsebob: yeah, example: http://www.galois.com/blog/2008/09/19/galois-icfp-see-you-there/
13:30:11 <lambdabot> Title: Galois ‚Ä∫ Blog ‚Ä∫ Blog ¬ª Galois @ ICFP: See you there!
13:30:14 <mc__> Did you take a look at Rush for Berlin?
13:30:17 <dons> Beelsebob: blog + twitter + ICFP
13:30:27 <mc__> I've purchased it some weeks ago, its quite good
13:30:43 <Beelsebob> dons: blog yes, twitter I actively hate, ICFP not this year -- although I believe conal will be there
13:30:49 <dons> hehe
13:30:51 <dons> conal's on twitter.
13:31:00 <dons> it's like persistent ICR.
13:31:00 <Philippa> Beelsebob: what are you after in an RTT? Would slower movement in relation to firepower/damage done have a similar effect?
13:31:02 <dons> IRC.
13:31:33 <Philippa> with an order of magnitude or two less bandwidth
13:31:35 <Beelsebob> Philippa: what I'm after is the ability to walk about the place without being seen
13:31:37 <mc__> http://netpanzer.berlios.de/ <- an open source RTT, has no AI and the pathfinding sucks
13:31:40 <lambdabot> Title: netPanzer - An Online Multiplayer Tactical Warfare Game
13:31:41 <Beelsebob> i.e. cover actually works as cover
13:32:13 <Philippa> *nod*. So if X-Com Apocalypse's RT combat did multiplayer that'd be a tolerable starting point? Give or take all the pausing?
13:32:13 <Beelsebob> it's very hard to play the "tactics" game if everyone can see you coming
13:32:26 <Philippa> depends what kind of tactics you're looking at
13:32:39 <Beelsebob> Philippa: dunno, I've never played it
13:32:42 <Philippa> but yes, it does cut an element out
13:32:51 <Beelsebob> the closest I've seen is the ancient game carrier command
13:33:49 <Beelsebob> I guess limited vision is the entire key to the game I want
13:33:59 <mc__> fog of war?
13:34:01 <Beelsebob> I'd also like a medievil war game with limited vision
13:34:15 <Beelsebob> i.e. you can see exactly what you as the general can see
13:34:22 <Beelsebob> and you'd better have some good scouts
13:34:30 <mc__> well in Rome Total War that is the default
13:34:35 <Beelsebob> and you'd better understand the semephore (or whatever) they're talking
13:34:37 <mc__> but you can deactive it in the options
13:35:05 <Philippa> eh, if your general's not trained in it then there should be an underling who is. Means you keep out of the front line, of course
13:35:07 <Beelsebob> RTW is turn based though
13:35:21 <marcot> How do I get the source directory when making changing a cabal hook, like buildHook?
13:35:32 <Beelsebob> Philippa: yeh sure -- but if there's no scouts, you should get no info essentially
13:35:40 <mc__> Beelsebob: not the battles
13:36:15 <Beelsebob> mc__: true
13:36:55 <Philippa> Beelsebob: yep. Considered doing a mod for one of the existing RTS games?
13:37:19 <Beelsebob> Philippa: no, I've more considered working for anygma so that we can produce a product capable of making said game
13:37:24 <Philippa> one of Relic's ought to be plenty capable of it, though things seem to take more work than they ought to
13:37:24 <Beelsebob> and then building it myself
13:37:41 <Philippa> ah. The metaness trap :-)
13:37:55 <Beelsebob> (or with kim, seeing as he seems to want a very similar style of game to me)
13:39:05 <marcot> Is it currentDirectory?
13:40:15 <Philippa> *nod*. I've wanted it at times and no doubt will again
13:41:20 <Saizan_> marcot: does the hook get passed LocalBuildInfo?
13:41:30 <ScottMichael> i have a map string: val
13:41:32 <marcot> Saizan_: yes.
13:41:32 <Saizan_> marcot: the source directories should be there
13:41:43 <Saizan_> marcot: it's a big record, look at the fields
13:41:51 <marcot> Saizan_: that's where I was searching.
13:42:06 <marcot> Though I can't find it.
13:45:25 <matthew-_> @seen ivanm
13:45:25 <lambdabot> ivanm is in #gentoo-haskell, #xmonad and #haskell. I last heard ivanm speak 5h 1m 40s ago.
13:45:58 <Saizan_> marcot: it's a bit nested, see localPkgDescr ans inside that look for library or executables and their BuildInfo
13:47:29 <TomMD> @seen dcoutts
13:47:29 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 2h 47m 15s ago.
13:47:37 <TomMD> @seen dcoutts_
13:47:38 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 4h 23m ago.
13:48:14 <marcot> Saizan_: is there an easier way to get to the root dir, where the .cabal file is?
13:48:30 <TomMD> @tell dcoutts The hackage-server patch on the 17th causes upload errors for me on two separate test machines "Server error: state/blobs/incoming/new21117: openBinaryFile: resource busy (file is locked)"
13:48:30 <lambdabot> Consider it noted.
13:50:51 <ScottMichael> i have a map string: val, i want to go over the vals and check if the value is bigger than some value, if not add the previous and next one and perform the same check. whats the best way to do that? it seems like a fold/filter combo but can i do both in one step?
13:51:02 <ScottMichael> is there some function like filter until?
13:51:22 <ScottMichael> that looks for a conditiona nd as soon as it is met returns that element only?
13:51:34 <ScottMichael> i could write ine ofc
13:51:37 <TomMD> @tell dcoutts If you access the hackage-server when it doesn't have access to the DNS server it will terminate the server (after the arp requests fail to get a response) with a "getNameInfo: resource unavailable (Temporary failure in name resolution)"
13:51:37 <lambdabot> Consider it noted.
13:52:56 <Apocalisp> ?type find -- ScottMichael
13:52:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
13:53:38 <Apocalisp> > find 2 [1,2,3]
13:53:40 <lambdabot>       No instance for (Num (a -> Bool))
13:53:40 <lambdabot>        arising from the literal `2' a...
13:53:50 <Apocalisp> > find (== 2) [1,2,3]
13:53:57 <lambdabot>   Just 2
13:54:28 <Botje> @src find
13:54:33 <dibblego> > let f x = zip x (tail x) in f [0..] -- might want this too
13:54:33 <lambdabot> find p          = listToMaybe . filter p
13:54:35 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
13:54:38 <Botje> ah. composability.
13:55:53 <quicksilver> ScottMichael: just head (filter ...)
13:56:03 <quicksilver> ScottMichael: or take 1 (filter ...)
13:56:16 <quicksilver> > take 1 (filter (>5) [1..])
13:56:17 <lambdabot>   [6]
13:57:02 <Botje> WARNING: contents may fail horribly if invariants are not respected. Warranty not valid in every country except Uzbekistan. Ask for Pjotr.
13:57:16 <subconscious> heheh
13:57:25 <Botje> s/every/any/, damn.
13:57:47 <hackage> Uploaded to hackage: control-event 0.3.1
13:59:06 <ScottMichael> http://hpaste.org/10519 --dropUntil problem
13:59:35 <ScottMichael> @h dropUntil :: [[a]] -> ([a] -> Bool) -> [a]
13:59:36 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
14:00:02 <Botje> ScottMichael: if .. then x else dropuntil ...
14:00:18 <Botje> so x and the results of dropuntil must have the same type
14:00:29 <SamB_XP> how about an RTS where players can see a lot of map, but at first it only comes from a ... map!
14:01:06 <SamB_XP> (that is, a cartographic document)
14:01:21 <ScottMichael> so i must use a maybe then?
14:01:34 <SamB_XP> (which is possibly less informative than actual visuals, and likely out-of-date)
14:01:56 <Botje> ScottMichael: try returning [x] instead
14:02:11 <SamB_XP> would that make sense?
14:02:32 <jeffwheeler> What does := in gtk2hs mean? Hoogle seems to have trouble searching for it.
14:02:37 <jeffwheeler> ?hoogle :=
14:02:37 <lambdabot> Parse error:
14:02:37 <lambdabot>   --count=20 :=
14:02:37 <lambdabot>              ^
14:02:40 <lispy> hitchcock?
14:02:44 <jeffwheeler> @hoogle :=
14:02:44 <lambdabot> Parse error:
14:02:44 <lambdabot>   --count=20 :=
14:02:44 <lambdabot>              ^
14:02:48 <ScottMichael> botje i did
14:02:50 <SamB_XP> ?hoogle (:=)
14:02:50 <lambdabot> Warning: Unknown type :=
14:02:51 <lambdabot> Prelude undefined :: a
14:02:51 <lambdabot> Data.Array.Base arrEleBottom :: a
14:02:52 <lispy> ?help hitchcock
14:02:52 <lambdabot> I perform dictionary lookups via the following 13 commands:
14:02:52 <lambdabot> all-dicts ... Query all databases on dict.org
14:02:52 <lambdabot> devils ...... The Devil's Dictionary
14:02:54 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
14:02:56 <lambdabot> elements .... Elements database
14:02:58 <ScottMichael> but what if im fed an empty list?
14:02:58 <lambdabot> [9 @more lines]
14:03:01 <ScottMichael> i tried nothign
14:03:09 <SamB_XP> ?hayoo (:=)
14:03:09 <lambdabot> Unknown command, try @list
14:03:10 <ScottMichael> which compiles but has runtime error
14:03:12 <SamB_XP> awwwww
14:03:17 <ScottMichael> No instance for (Num (Maybe a))
14:03:17 <Vq^> SamB_XP: might be hard to represent depending on how distorted the map is
14:03:25 <SamB_XP> Vq^: hmm?
14:03:27 <Botje> ScottMichael: paste the code you have _now_
14:03:40 <SamB_XP> ... the map would be to scale!
14:03:50 <Vq^> SamB_XP: but don't let me stop you, it sounds like a fun idea :)
14:04:09 <Vq^> SamB_XP: are you thinking 3d-world like taspring?
14:04:12 <Botje> Vq^: getting map perspectives "right" took a long time :)
14:04:17 <SamB_XP> but might not contain as much info on elevations as one would like ...
14:04:27 <SamB_XP> hmm, I'm just full of talk actually
14:04:43 <SamB_XP> I'm not at the point where I have the slightest idea how to implement an RTS ;-)
14:04:56 <Botje> you crack open vim and get started :)
14:05:20 <Vq^> SamB_XP: you'll probably have a better idea once you have written 2 or 3
14:05:21 <SamB_XP> no, I'm pretty sure there's some napkins and/or envelopes involved before I open emacs
14:05:44 <SamB_XP> or possibly just notebooks
14:05:45 <Botje> which would be more productive: envelopes or post-it notes?
14:05:55 <skorpan> emacs
14:06:11 <SamB_XP> hmm, well, post-its are initially blank at least
14:06:18 <skorpan> so is *scratch*
14:06:30 <skorpan> well... at least if you configurate it to be so.
14:06:35 <SamB_XP> skorpan: I notice my emacs doesn't work too well with a pencil ;-)
14:06:52 <skorpan> SamB_XP: use the good old M-x pencil-mode
14:07:13 <SamB_XP> I think you mean M-x handwrite-buffer or something
14:07:27 <SamB_XP> (believe it or not ... there IS such a feature!)
14:07:46 <SamB_XP> (but it doesn't show on the screen -- only supports generating postscript)
14:08:32 <Vq^> can't you control the plotter device from emacs?
14:08:40 <sjanssen> @arr
14:08:40 <lambdabot> Yeh scurvy dog...
14:08:49 <sjanssen> @arr
14:08:49 <lambdabot> I'll crush ye barnacles!
14:08:54 <SamB_XP> Vq^: well, *maybe* it can generate plotter commands too
14:09:02 <SamB_XP> I'm sure it wouldn't be that hard to add such a feature
14:09:16 <skorpan> there's always M-x artist-mode
14:09:20 <ScottMichael> dropUntil http://hpaste.org/10521
14:09:22 <SamB_XP> but you see I haven't got a plotter and my legos are all in storage!
14:09:31 <Vq^> i have done some ISO CNC stuff with Haskell
14:09:37 <Vq^> should be easy to call from emacs :)
14:09:50 <Vq^> thought i have mostly done plasma-cutting and milling
14:10:03 <Jedai> jeffwheeler: Isn't it rather (=:) ? Because := is a data constructor which seems unlikely
14:10:14 <Jedai> @hoogle (=:)
14:10:15 <lambdabot> Warning: Unknown type =:
14:10:15 <lambdabot> Prelude undefined :: a
14:10:15 <lambdabot> Data.Array.Base arrEleBottom :: a
14:10:19 <SamB_XP> Vq^: does CNC support pencils ?
14:10:28 <SamB_XP> I dunno what tools are available in CNC
14:10:33 <jeffwheeler> I have no idea what := is; I've never seen it before.
14:10:34 <Vq^> SamB_XP: sure, i have plotted eggs for easter using CNC
14:10:35 <SamB_XP> I can't even remember what CNC stands for
14:10:44 <SamB_XP> jeffwheeler: it's an operator
14:10:45 <subconscious> jeffwheeler: A constructor
14:10:52 <SamB_XP> a constructor, yes, that too
14:11:00 <jeffwheeler> Hmm . . . why have I never needed to use it?
14:11:01 <Vq^> SamB_XP: http://www.taomc.com/gallery/eggs.htm
14:11:03 <lambdabot> Title: The Art of Motion Control : Gallery : Egg Pieces
14:11:04 <jeffwheeler> weird
14:11:07 <SamB_XP> jeffwheeler: did you ever use gtk2hs ?
14:11:08 <ScottMichael> Botje http://hpaste.org/10521
14:11:23 <Jedai> jeffwheeler: It's a syntaxic comment, every "operator" that start with : must be an infix data constructor (like (:) itself)
14:11:49 <SamB_XP> (or another library that uses the same trick?)
14:12:12 <SamB_XP> (not that you yet understand the trick ;-)
14:12:14 <jeffwheeler> Jedai: okay
14:12:19 <Jedai> jeffwheeler: I mean, even if I don't know from where it comes I can still tell you it's an infix data constructor (for exemple :+ constructs complex)
14:12:36 <jeffwheeler> Hm, alright; thanks.
14:12:42 <SamB_XP> Vq^: how does CNC work anyway?
14:12:46 <jeffwheeler> I'll look into that a bit more; thanks.
14:13:03 <SamB_XP> hmm, and how did that guy get the pens to follow the surface of the egg?
14:13:23 <SamB_XP> I don't imagine chickens keep very tight tolerances on their egg shapes ;-)
14:13:24 <Vq^> SamB_XP: the generall term CNC stands for Computer Numerical Control, it's just the control of a machine through a computer
14:13:31 <SamB_XP> Vq^: oh
14:13:39 <SamB_XP> I thought maybe it was a language too ;-)
14:13:40 <Jedai> jeffwheeler: Are you sure it isn't (=:) rather ? I know this one is quite used as an operator on "IORefs" (a synonym for writeIORef most of the time)
14:13:55 <Vq^> SamB_XP: thats just a lathe like machine (two dimensions and a spring to keep the pen on the egg)
14:14:07 <SamB_XP> Vq^: ah, a spring
14:14:13 <Vq^> SamB_XP: ISO has a standard for languages for CNC
14:14:34 <SamB_XP> that's a nice solution
14:14:44 <jeffwheeler> Jedai: not at all; in fact, it probably is. I saw it in gtk2hs code in Yi, and wasn't sure what it meant.
14:15:14 <SamB_XP> so ... do how does one specify tools to be used in a typical CNC language?
14:15:16 <Vq^> SamB_XP: i've actually done a library for generating such ISO CNC code from haskell
14:15:28 <Vq^> there is a tool-change command
14:15:45 <SamB_XP> yes, but how do you actually refer to the tools?
14:16:14 <Vq^> by integers
14:16:19 <SamB_XP> ah
14:16:26 <Vq^> then you usually have a tool table in the machine
14:16:32 <Vq^> with diameters and offsets
14:16:47 <SamB_XP> only that?
14:16:54 <Vq^> usually yes
14:17:00 <SamB_XP> what sort of offsets ?
14:17:06 <Vq^> length of the tool
14:17:11 <SamB_XP> ah.
14:17:19 <SamB_XP> and the diameter is the head diameter?
14:17:36 <Vq^> yeah, so that you can use radiuscompensation for following a countour
14:17:45 <Vq^> it's pretty primitive
14:17:53 <SamB_XP> I guess so.
14:18:01 <Vq^> thats why i generate it :)
14:18:33 <SamB_XP> so is there also a standard for operator instructions?
14:19:00 <Vq^> operator instuctions?
14:19:17 <SamB_XP> to tell the operators how to set up the machines ;-)
14:19:39 <Vq^> messages to the user you mean?
14:21:18 <SamB_XP> Vq^: well, SOMEONE has to make sure the machine actually has the right tools installed ...
14:22:10 <Vq^> nah, they just need to keep their eyes closed on the first run :o)
14:22:57 <SamB_XP> what???
14:23:21 <Vq^> theres no support for that in ISO CNC
14:23:46 <SamB_XP> well, this I gathered
14:24:05 <SamB_XP> so I figure that the operators must have to do it manually or something ...
14:24:39 <Vq^> usually you don't have that many tools and/or the code-generator knows of the tool-setting in the machine
14:25:49 <SamB_XP> hmm
14:25:51 <Vq^> as i said it's pretty primitive
14:26:18 <Vq^> but on the other hand the tools are real physical thingiemajigs that get worn out relatively quick
14:26:42 <Vq^> you still need the operator to handle tools and tool settings
14:34:36 <subconscious> @roll 1d2
14:34:36 <lambdabot> Consider it noted.
14:34:44 <dmwit> heh
14:34:45 <Vq^> hah
14:34:48 <dmwit> ?dice 1d2
14:34:49 <lambdabot> 1d2 => 1
14:35:01 <subconscious> @@ @run odd . length $ @show @yow
14:35:03 <lambdabot>   True
14:35:06 <Vq^> @roll subconscious roll roll
14:35:06 <lambdabot> Consider it noted.
14:35:42 <dmwit> ?rick roll
14:35:43 <lambdabot> Maybe you meant: dice dict rc
14:35:50 <dmwit> ?help rc
14:35:51 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
14:36:01 <dmwit> Oh, really?
14:36:10 <dmwit> ?rc /etc/init.d/mpd
14:36:10 <lambdabot> Not enough privileges
14:38:29 * SamB_XP would like to get a look at some HDR images of plasma cutting ...
14:39:32 <dmwit> SamB_XP: That sounds like a ?yow!
14:39:44 <SamB_XP> dmwit: seriously?
14:40:20 <SamB_XP> look at http://www.taomc.com/studio_machines/plasma_cutting.htm and say that again ;-P
14:40:21 <lambdabot> Title: The Art of Motion Control : Subcategory
14:40:49 <dmwit> that again
14:40:51 <dmwit> ;-)
14:42:41 * Vq^ has plasma-cut gears generated with Haskell :)
14:46:44 <SamB_XP> Vq^: yes, but did you manage to capture HDR images of the process?
14:46:46 <Vq^> you don't feel alive until you have a Haskell controlled CNC plasma in your garage ;)
14:46:53 <Vq^> no :(
14:47:03 <SamB_XP> hmm, seeing as I'm an EE I doubt I ever will ;-P
14:47:10 <ddarius> Capturing HDR images would be somewhat tricky.
14:47:16 <SamB_XP> I suppose
14:47:18 <ddarius> But you could probably capture the glow well.
14:47:35 <SamB_XP> I guess you'd need to use a low-res CCD?
14:47:51 <Vq^> SamB_XP: you could come over here and film it
14:48:00 <SamB_XP> where by "low res", I mean "relatively low well density"
14:48:24 <SamB_XP> so that the wells could hold a lot of electrons each
14:50:05 * SamB_XP doesn't suppose it's possible to store actual electrons using floating point ;-)
14:50:19 <lament> i read that as "elections"
14:50:54 <SamB_XP> yeah, I'm pretty sure that CCDs need to store electrons in unary
14:55:13 * SamB_XP still wonders how the electrons are actually counted ...
14:55:15 <IsoPallo> But the probabilities of an electron might be in floating point too...
14:56:05 <quicksilver> no, the probabilities of electrons are a true quantity
14:56:16 <quicksilver> (continuous or quantised depending on your 'religion')
14:56:27 <quicksilver> but they certainly aren't "floating point", which is a representation choice.
14:56:38 <SamB_XP> quicksilver: you assume a lot ;-)
15:01:49 <fnord123> hi all. I'm looking through the haskell-prime report to see if 'data' members will be scoped to data rather than the module but I can't see any mention of this change that I'm hopeful for. Anyone know if that's on the table?
15:03:03 <lispy> fnord123: The goal of Haskell' is to just make concrete the widely used extensions
15:03:17 <fnord123> curses
15:03:18 <lispy> fnord123: so, if it's not already an extension people use, it's probably not under consideration
15:03:41 <jsnx> fnord123: you're talking about record accessors?
15:04:01 <lispy> fnord123: they're not looking to refine so much as standardize
15:04:04 <fnord123> jsnx: yes
15:05:02 <ddarius> fnord123: In my opinion, that's not the right way to handle that.
15:05:18 <jsnx> ddarius: what is your idea?
15:05:35 <jsnx> thing.DataType.accessor
15:05:36 <jsnx> ?
15:05:39 <ddarius> jsnx: I think allowing local modules would be a more orthogonal change.
15:05:51 <jsnx> aha, interesting
15:05:53 <SamB_XP> ddarius: how would those work
15:05:56 <pfo> is there a page out there which tracks Haskell' status?
15:06:03 <SamB_XP> syntactically
15:06:04 <fnord123> I keep getting the impression that I'm doing it wrong. But mainly because I'm doing some ffi work and I have to repeat some C structures where they scope names to the struct and hence are able to repeat names often
15:06:04 <TomMD> @where haskell'
15:06:05 <lambdabot> http://hackage.haskell.org/trac/haskell-prime
15:06:06 <lispy> pfo: yes, but I don't know the url
15:06:29 <ddarius> SamB_XP: Syntactically it's easy, just allow module declarations within module declarations.
15:06:49 <lispy> fnord123: one way is to name the fields like, foo'field1, foo'field2, etc
15:06:57 <SamB_XP> ddarius: yes but how do you tell if they are supposed to be nested declarations or if they are supposed to be further module decalarations ?
15:07:02 <ddarius> I don't think there is any big gotchas with this idea, but I need to work out details and form a proposal.
15:07:29 <jsnx> ddarius: what if you used indentation?
15:07:35 <ddarius> SamB_XP: Modules use layout just like anything else.
15:07:38 <SamB_XP> i.e., how do you tell where to put the }
15:07:43 <jsnx> module A
15:07:48 <jsnx>   module A.B
15:07:51 <jsnx> hehe
15:07:54 <SamB_XP> it's really not that easy :-(
15:08:00 <ddarius> -Every- 'where' starts a block of layout including 'module Foo where'
15:08:11 <SamB_XP> ddarius: yes but what if I have ...
15:08:14 <SamB_XP> module A where
15:08:16 <SamB_XP> module B where
15:08:36 <jsnx> than that is illegal, but if you indented module B it would work
15:08:46 <jsnx> well, it's not illegal
15:08:50 <jsnx> but it's ambiguous
15:08:57 <SamB_XP> so I suddenly have to indent EVERYTHING in my module, just to nest another one in it?
15:09:00 <ddarius> SamB_XP: Then module B is in module A just like 'module A where\nx = 3' x is in module A
15:09:29 <SamB_XP> hmm.
15:09:35 <SamB_XP> seems kind of awkward :-(
15:09:43 <ddarius> SamB_XP: If you wrote a module, use layout, and don't indent the body then you won't be able to have sequential modules.
15:09:43 <ddarius> But that's your own fault.
15:10:03 <ddarius> SamB_XP: Or use explicit brackets.
15:10:27 <ddarius> SamB_XP: No, you only need to indent if you want multiple -separate- modules within a single file.
15:10:32 <SamB_XP> oh
15:10:37 <ddarius> SamB_XP: As I said with your example, module B is in module A.
15:10:37 <jsnx> so you want to allow more than one top level module per file?
15:10:43 <fnord123> lispy, I've been using foo_field1 and it feels so annoying to have to retype foo_ for each element. It just feels like I'm doing it wrong :-/
15:10:47 <ddarius> jsnx: I don't really care one way or another about that one.
15:11:04 <jsnx> ddarius: ah, say your remarks
15:11:05 <ddarius> jsnx: Haskell syntax already supports having multiple modules in a file.
15:11:10 <jsnx> s/say/saw/
15:11:15 <jsnx> ddarius: really?
15:11:25 <ddarius> jsnx: Yes.  Implementations don't.
15:11:28 <jsnx> ddarius: but the compilers don't
15:11:31 <jsnx> oh
15:11:36 <fnord123> (even annoying in vim where I can select an area and go :s/\($\w, \)/\1foo_/
15:11:50 <ddarius> The standard says absolutely nothing about "source files" so how to map modules to files is entirely up to the implementations.
15:13:56 <jsnx> ddarius: do you have a draft of your proposal up anywhere?
15:14:01 <ddarius> jsnx: No.
15:15:15 <jsnx> ddarius: as far as record accessors go, if there were local modules, they'd all become A.B.x, A.B.y, &c.?
15:15:52 <jsnx> so that it would just make it faster to put each datatype in its own module
15:16:18 <jsnx> but then you'd still have overlapping definitions, right, if you imported two datatypes with an `x` selector?
15:16:24 <ScottMichael> dropUntil []     _     = Nothing
15:16:24 <ScottMichael> dropUntil [x]     _    = x
15:16:24 <ScottMichael> dropUntil (x:xs) pred  = if pred x then x else dropUntil xs pred
15:16:29 <ScottMichael> wtf
15:16:34 <ddarius> jsnx: Indeed, except you wouldn't need a -fully- qualified name.
15:16:41 <jsnx> true
15:17:11 <ddarius> jsnx: Just import qualified.  The whole point of this approach is to leverage the existing module system.  Have the module system deal with namespace management like it is supposed to.
15:17:32 <jsnx> if you could export "partially qualified" names, that'd help
15:17:34 <ddarius> Also you can export entire modules
15:18:20 <jsnx> maybe you already can, i'm not sure
15:18:30 <ddarius> One benefit of this approach is it makes abstract data types much more lightweight.  module Foo where module Stack where { newtype Stack a = Stack [a]; push a (Stack as) = Stack (a:as); etc. }
15:18:45 <jsnx> oh yes, i agree overall
15:18:50 <fnord123> yeah I wouldn't mind module Foo ( data Foo = Foo ) --but this looks like C's old typedef struct { ...} foo; which was turned into struct foo {...}; in C99
15:19:09 <fnord123> at least it was in c++ and I /think/ you can do that in C99 now
15:20:11 <ddarius> Another benefit of this approach is that it is completely backwards compatible.
15:20:16 <jsnx> i think O'Caml has this modules-within-modules approach to ADTs
15:20:53 <ddarius> jsnx: Yes, the MLs have something like this (though more sophisticated)
15:21:28 <ddarius> I think adding local modules to Haskell would be a very simple extension, though certainly not as powerful as ML modules/functors.
15:22:28 <ddarius> It should be possible to make a mostly sound implementation as a preprocessor.
15:22:55 <ddarius> (You'll have a problem if you have 'module Foo where module Bar' and also 'module Foo.Bar'
15:22:59 <ddarius> )
15:23:21 <ddarius> If you use the obvious way of implementing this as a preprocessor.
15:23:37 <pfo> can someone explain to me why SPJ says that lazy eval has downsides too?
15:23:54 <ddarius> pfo: Because it does.  And SPJ can explain.
15:23:56 <tristes_tigres> so what's up with 6.10 /
15:23:57 <SamB_XP> pfo: I'm thinking he says that because ... lazy eval has downsides
15:23:59 <tristes_tigres> ?
15:24:22 <Heffalump> pfo: space and time overheads
15:24:30 <Heffalump> poor predictability of program performance
15:24:37 <Heffalump> space leaks
15:24:41 <Heffalump> those are the main issues
15:24:48 <Heffalump> makes debugging hard
15:24:52 <pfo> what are those space leaksy anyway?
15:25:02 <pfo> *leaks
15:25:14 <Heffalump> where a large (and potentially ever-growing) closure gets hung onto for a long time
15:25:21 <Heffalump> when it could have been evaluated earlier and collapsed
15:25:24 <SamB_XP> well, collection of related closures
15:29:34 <tristes_tigres> Heffalump: isn't there a subset of Haskell programs where lazyness is not essential ?
15:34:56 <Heffalump> I imagine so, yes
15:35:09 <Heffalump> but I suspect a lot of programs use things like the zip [1..] idiom
15:36:05 <tristes_tigres> Heffalump: suppose I am interested in space and performance issues, then I may want to turn off laziness
15:36:57 <tristes_tigres> maybe some sort of subset of Haskell for performance-critical apps ?
15:37:14 <Heffalump> or you could use ML
15:37:27 <SamB_XP> Heffalump: yes, but ... the syntax
15:37:46 <Adamant> it would be nicer to just enforce strictness in Haskell
15:37:48 <sjanssen> you could program using unboxed types exclusively
15:37:53 <dons> so you write in strict data types only.
15:37:55 <SamB_XP> hahaha
15:37:56 <dons> e.g. uvector.
15:37:58 <tristes_tigres> I don't know any ML, does it have type system similar to Haskell's
15:38:09 <thoughtpolice> no need to turn laziness off entirely, it's a nice property to have
15:38:10 <SamB_XP> oh, yeah, no typeclasses either
15:38:13 <dons> laziness is your choice.
15:38:15 <thoughtpolice> strictness and laziness are parts of your algorithm
15:38:24 <thoughtpolice> it's not a "slow vs. fast" choice
15:38:32 <Adamant> dons: I meant just using strict data types
15:38:34 <dons> most definitely.
15:38:45 <Adamant> not turning off all laziness
15:38:50 <Saizan_> without laziness you've to write all your loop as recursion..
15:38:50 <SamB_XP> well yeah, whenever we have one of those we pick "fast"
15:38:55 <Saizan_> *loops
15:39:03 <SamB_XP> it's why they don't usually put "turbo" buttons on computers anymore ;-P
15:39:19 <Adamant> I miss the turbo button
15:39:42 <Adamant> and the little 7-segment display that told you how many mhz you were going
15:39:49 <Adamant> V-Tec just kicked in you
15:39:51 <Adamant> *yo
15:40:00 <SamB_XP> you know ... it suddenly occurs to me that raytracing would have been a fantastic application for the turbo button
15:40:04 <tristes_tigres> Yes, byt whtn it's the choice between "slow and easy to program", or "fast yet algoritmically complicated"
15:40:20 <SamB_XP> tristes_tigres: that's obviously a bit different
15:40:39 <dons> its not really.
15:40:42 <dons> benchmark some things :)
15:41:09 <dons> the "lazy" stuff is subject to things like fusion, often gets to run with better space complexity (so is cache friendly) and other aspects like that.
15:41:11 <micahcowan> dons, you know that links from the comment feed are completely broken?
15:41:22 <dons> micahcowan: the feed for what?
15:41:27 <tristes_tigres> SamB_XP: lazy vs strict may be related to the choice :  "slow and easy to program", or "fast yet algoritmically complicated", no ?
15:41:40 <micahcowan> The comments RSS (or atom or whatever) feed, for RWH
15:41:45 <SamB_XP> tristes_tigres: but ... which is which ?
15:41:54 <sjanssen> tristes_tigres: lazy vs strict /= slow vs fast
15:41:58 <dons> note the lazy programs are winning the log parsing benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
15:42:08 <thoughtpolice> why does laziness mean it's always going to be slow?
15:42:10 <lambdabot> Title: sum-file benchmark | Gentoo : Intel¬Æ Pentium¬Æ 4 Computer Language Benchmarks G ..., http://tinyurl.com/o8pll
15:42:20 <micahcowan> My current process, when I want to view a new comment, is to (1) find the chapter whose name is similar to the (non-existant) page from the link, and replace the name accordingly
15:42:22 <thoughtpolice> there are benchmarks there like the btrees benchmark that get increase in performance with laziness
15:42:27 <dons> hmm micahcowan ok.
15:42:34 <micahcowan> (2) swap the #anchor and ?query, which are inverted
15:42:38 <thoughtpolice> (although they can't be submitted because they require all submissions be 'the same')
15:42:42 <dons> micahcowan: can you ping bos about it?
15:43:18 <SamB_XP> thoughtpolice: you should complain that nobody elses submissions use laziness
15:43:33 <thoughtpolice> heh
15:43:45 <micahcowan> dons, could you PM his email?
15:44:22 <tristes_tigres> thoughtpolice: by "slow" I actually mean "resource-intensive", as in, may use more memory
15:44:28 <thoughtpolice> imo I think the shootin is more interesting than the shootout, too bad it's dead
15:44:42 <SamB_XP> what's the shootin?
15:44:45 <dons> tristes_tigres: if you do it wrong.
15:44:49 <thoughtpolice> http://shootin.sourceforge.net
15:44:50 <SamB_XP> is that in a building or something ?
15:44:51 <lambdabot> Title: The shootin
15:44:54 <dons> the goal of laziness is to use *less* memory (as we see on the shootout.
15:44:59 <dons> since you can evaluate in constant space.
15:45:10 <thoughtpolice> tristes_tigres: you can have constant memory use with laziness
15:45:16 <dons> if you screw it up, you can end up using more. same as when you screw up strictness
15:45:20 <dons> its really quite simple.
15:45:31 <SamB_XP> and at the same time fiendishly complicated
15:45:34 <thoughtpolice> tristes_tigres: like I said being lazy and being strict is apart of the algorithm - they are not 'optimizations,' they don't work one way or the other.
15:46:07 <thoughtpolice> it's not an entirely black and white decision
15:46:15 <sjanssen> interestingly, lazy evaluation always performs equal or fewer operations compared to strict evaluation
15:46:22 <tristes_tigres> thoughtpolice: presumably you can have constant memory use with laziness, but you have to be careful
15:46:31 <thoughtpolice> i see no reason for a 'performance-oriented subset' of haskell, it's reasonable to have performant haskell, today
15:47:01 <dons> yes. a performance oriented set of libraries and idioms
15:47:03 <tristes_tigres> thoughtpolice: what I have in mind is that it would be nice to use haskell in embedded systems
15:47:03 <SamB_XP> sjanssen: only assymptotically
15:47:09 <dons> that's actually how we do the performance thing.
15:47:11 <dons> tristes_tigres: ah!
15:47:13 <dons> now you say.
15:47:22 <dons> so, yes, for embedded systems we might have, say, real time constraints
15:47:26 <thoughtpolice> dons: right, it's really nice to be able to take optimized libraries and 'drop them in'
15:47:31 <dons> and in this environment a domain specific language might be useful.
15:47:32 <sjanssen> SamB_XP: yeah, I'm speaking in an abstract machine sense.  Perhaps I should say reductions?
15:47:36 <dmwit> sjanssen: ...although immutable data structures always require equal or more operations than mutable ones...
15:47:50 <SamB_XP> sjanssen: oh, fine, that's true enough ;-)
15:48:16 <tristes_tigres> dons: DSL or subset of Haskell ? yes I know about quasiquoting
15:48:35 <dons> there are specific haskell-like languages for embedded systems.
15:48:35 <thoughtpolice> DSL
15:48:37 <dons> like tiger.
15:48:46 <dons> sorry, timber.
15:48:53 <dons> tiger was the C-- compiler.
15:48:53 <thoughtpolice> maybe oleg's work would be of interest if you also want safety properties
15:49:02 <dons> http://code.haskell.org/timber/
15:49:03 <lambdabot> Title: Index of /timber
15:50:53 <tristes_tigres> thoughtpolice: "Timber has strict semantics, not lazy as Haskell. "
15:51:43 <dons> right. its a language for resource constrained environments where real time constraints matter.
15:51:46 <thoughtpolice> tristes_tigres: i thought you were only talking about speed in the sense of "should be faster/fast enough," didn't know you meant e.g. where you have real-time constraints on memory/time
15:51:55 <dons> so it needs a precise ability to reason about time and space.
15:51:57 <thoughtpolice> which I certainly think is an area to be explored
15:52:18 <dons> its like using haskell where only strict data types are available
15:52:40 <thoughtpolice> (i.e. where you have an extremely scarce amount of memory, in this case, staying off the bus as much as possible is something you're going to have to do regardless, meaning you're not going to want to be lazy anyway)
15:53:21 <SamB_XP> so ... you have to walk everywhere, or do you get to take the train ?
15:53:44 <tristes_tigres> thoughtploice: yes, and  haskell doesn't have such uses in mind right now, right ?
15:53:57 <SamB_XP> tristes_tigres: should it?
15:54:29 <tristes_tigres> it's just that Haskell sometimes is justified by necessity to program for multicore chips
15:55:42 <BMeph> @remember dons> note the lazy programs are winning the log parsing benchmark, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all   thoughtpolice>  why does laziness mean it's always going to be slow?
15:55:42 <lambdabot> Done.
15:55:54 <tristes_tigres> embedded systems not rarely are multicore
15:56:10 <SamB_XP> hmm, we ought to have a special "banned GHC" entry in the shootout, where we use all the illegal tricks
15:57:04 <SamB_XP> tristes_tigres: but do the cores usually use the same ISA?
15:57:17 <tristes_tigres> it's just that I am studying Haskell as a hobby, and then have to go and do my work in plain C
15:57:41 <intoverflow> tristes_tigres: yeah, tell me about it
15:58:19 <tristes_tigres> SamB: not always
16:13:07 <tristes_tigres> Haskell type system is orthogonal to laziness
16:13:31 <thoughtpolice> BMeph: heh, in the wrong context that might make me seem stupid i think.
16:13:46 <tristes_tigres> and that ype system that seem attractive for embedded systems
16:14:12 <thoughtpolice> tristes_tigres: see oleg's paper on static resources for embedded programming for more on that
16:14:42 <tristes_tigres> thoughtpolice : which paper is that ?
16:14:57 <BMeph> thoughtpolice: Hm, not really the point of it, but I can see that. It sure looked funny having those statements coming one right after the other... ;)
16:15:08 <thoughtpolice> BMeph: heh :]
16:15:41 <thoughtpolice> tristes_tigres: http://okmij.org/ftp/Haskell/types.html#ls-resources
16:15:41 <lambdabot> Title: Haskell Programming: Types
16:15:52 <Cale> I'm not sure that laziness is necessarily the wrong model for all embedded systems, but I suppose if you're working with very hard constraints on space, it might be somewhat tricky to use any language where allocation is implicit, and determined by how the computation proceeds.
16:15:55 <ozy`> ML-family type systems are ideal for... pretty much anything that isn't systems programming
16:16:05 <SamB_XP> Cale: what about time?
16:16:05 <tristes_tigres> thoughtpolice: thatks.
16:17:24 <Cale> SamB_XP: Well, laziness usually helps with time, when used sanely.
16:18:32 <Cale> There's a bit of overhead on common architectures, but if you're designing something from the ground up, that needn't be the case :)
16:19:01 <thoughtpolice> @yarr
16:19:01 <lambdabot> This is the END for you, you gutter-crawling cur!
16:19:27 <Cale> I think it would be really cool to see a device with a reduceron in it :)
16:19:32 <thoughtpolice> necessary due to it being international talk like a pirate day
16:19:47 <humasect> @yarr
16:19:48 <lambdabot> Prepare to be boarded!
16:20:37 <tristes_tigres> @@ @yarr @girl19
16:20:37 <lambdabot>  Splice the Mainbrace!
16:21:10 <tristes_tigres> @@ @girl19 @yarr
16:21:10 <lambdabot>  well.. I never hacked Russians
16:25:04 * thoughtpolice reading the haskell article on slashdot reminds him of why he no longer reads the comments, ever
16:25:27 <dibblego> thoughtpolice, link?
16:26:21 <dons> thoughtpolice: yes.
16:26:23 <thoughtpolice> http://tech.slashdot.org/tech/08/09/19/1230237.shtml
16:26:24 <lambdabot> Title: Slashdot | Why Lazy Functional Programming Languages Rule
16:26:25 <dons> a wasteland.
16:26:36 <dons> :/
16:26:47 <x6d65> Is anyone familiar with Parsec?
16:27:01 <thoughtpolice> dons: pretty much, and most of the people there salivate profusely at the thought at any sort of MS/apple/whatever 'conspiracy to control your life'
16:27:09 <thoughtpolice> sad, many people tell me slashdot used to be the awesome back in the day
16:27:20 <humasect> keep the mind healthy by feeding it constructive , positive, challenging, interesting, and useful things~
16:29:09 <tristes_tigres> "Functional languages follow this pattern: side-effects are only permitted if there is no other way. Examples are Lisp and Scheme, but also Matlab, Mathematica and Scala"
16:29:17 <tristes_tigres> Functional MATLAB ?
16:29:26 <tristes_tigres> (Slashdot commments)
16:29:39 <tristes_tigres> would be nicd though
16:29:49 <SamB_XP> you didn't know matlab had lambda?
16:30:22 <ddarius> tristes_tigres: Here's a tip.  Don't read Slashdot.
16:30:46 <SamB_XP> but really none of those langauges seems to follow the supposed "pattern"
16:30:49 <BMeph> thoughtpolice: The really sad part is that reddit seems to be copying more from how slashdot /is/ versus how it /was/. ;|
16:31:20 <thoughtpolice> yeah.
16:31:24 <SamB_XP> you mean /. wasn't always the laughing stock of the internet?
16:31:25 <ScottMichael> http://hpaste.org/10525, type problem
16:31:41 <ddarius> BMeph: Here's a tip.  Don't read reddit.
16:31:47 <tristes_tigres> SamB : Matlab has lambda ? I suppose you could hack lambda with feval()
16:32:00 <SamB_XP> tristes_tigres: um, hello, @!
16:32:08 <thoughtpolice> "Yes, Haskell was not capable of IO (reading/writing) for years."
16:32:34 <SamB_XP> how the heck did YOU learn matlab?
16:32:38 <tristes_tigres> SamB: Ahhh, yes (sarcasm on)
16:33:04 <SamB_XP> oh, I bet you learned it in a class or something
16:33:09 <SamB_XP> that would explain it ;-)
16:33:14 <humasect> ScottMichael: type sigs will help in this kind of thing. for code like this, it will help to load what does compile/parse into ghci an :i to get the type ghc thinks it isl
16:33:29 * SamB_XP basically just poked about in the helpfile
16:33:50 <ddarius> SamB_XP: You read documentation?!  What's wrong with you?
16:34:06 <SamB_XP> uh ... I'm literate
16:34:19 <SamB_XP> also I was looking for nice ways to do things ;-)
16:34:25 <humasect> (are the parens in the right place, in 'normalize' ?)
16:35:07 <thoughtpolice> BMeph: I still hold reddit in much higher regard than slashdot though
16:35:23 <humasect> ScottMichael: $ dmap M.! start  <-  causes dmap to lose a level of []'s .. etc.
16:35:30 <ScottMichael> http://hpaste.org/10526
16:36:29 <x6d65> If I have two instances of an (Either Integer Double), how should I go about applying an arithmetic operator to them?
16:36:31 <humasect> ScottMichael: ok, try (concat w) instead of w
16:36:49 <humasect> nevermind =)
16:37:35 <humasect> you will find the true cause of the error soon enough
16:37:35 <lament> oh crap, i just realized the RWH presentation is concurrent with Oleg's talk
16:37:57 <SamB_XP> lament: hmm, well, get them both videotaped
16:38:01 <SamB_XP> and POSTED
16:39:45 <lament> oh, and they closed the registration, too :(
16:40:02 <SamB_XP> registration for what ?
16:40:26 <SamB_XP> free food?
16:40:30 <lament> the conference!@
16:40:38 <SamB_XP> oh
16:40:48 <SamB_XP> you didn't registered yet but you were going ?
16:40:49 <lament> even though the deadline was supposed to be monday
16:40:53 <lament> yeah
16:40:57 <SamB_XP> lament: flame!
16:41:07 <BMeph> Off to run errands - see you in a few hours... ;)
16:41:08 <SamB_XP> while at the same time also begging
16:41:14 <dons> you can sneak in.
16:41:29 <SamB_XP> dons: do you get official sneak-in badges?
16:42:16 * SamB_XP wonders what the point of hiberfile.sys is
16:42:17 <lament> dons: Do you know the times for DEFUN stuff? The website doesn't have them
16:42:24 <SamB_XP> er. hiberfil.sys
16:42:49 <kryptiskt> stores your RAM for hibernation
16:42:56 <dons> hmm
16:43:00 <lament> dons: nevermind, found them
16:43:11 <lament> (the DEFUN site doesn't have them but the ICFP one does)
16:43:23 <SamB_XP> kryptiskt: but ... I haven't hibernated this PC in years
16:43:30 <SamB_XP> it's a frickin desktop!
16:43:42 <SamB_XP> so why is it so damn big ?
16:44:30 <kryptiskt> SamB, it's there so it doesn't have to find all those blocks of disk when hibernating, if you disable hibernation it goes away
16:45:02 <FunctorSalad> is there some central registry for haddocks?
16:45:08 <FunctorSalad> (locally on my box)
16:45:17 <gutworth> are haskell threads green?
16:45:35 <SamB_XP> gutworth: er, well, I've never seen one, so I'm not sure
16:45:44 <Jedai> SamB_XP: Well if you suddenly wanted to hibernate, you would _need_ this space so it reserves it so you don't just use too much space to hibernate
16:45:48 <SamB_XP> but they show up in some shade of gray in the heap profiler ;-P
16:45:55 <FunctorSalad> gutworth: no, they're psychedelically multicolored
16:45:58 <gutworth> tasty
16:46:14 <gutworth> I was hoping for violet
16:46:17 <dons> ?users
16:46:18 <lambdabot> Maximum users seen in #haskell: 511, currently: 466 (91.2%), active: 18 (3.9%)
16:46:19 <Jedai> gutworth: They're user threads scheduled on top of kernel thread
16:46:43 <gutworth> ok, thanks
16:46:43 <gutworth> we were just wondering on #python :)
16:46:45 <FunctorSalad> @faq can I do violet threads in haskell?
16:46:46 <lambdabot> The answer is: Yes! Haskell can do that.
16:46:57 <Jedai> gutworth: In other word they're very lightweight and can use several cores
16:47:16 <SamB_XP> gutworth: basically, they have the advantages of both green and OS threads, unlike in Python, where you have the disadvantages of both instead ;-)
16:47:27 <ScottMichael> is there someway to type the type of a variable(or should i say let-binding?) during runtime?
16:47:31 <dons> spj interview on http://lambda-the-ultimate.org/node/3004
16:47:42 <lambdabot> Title: Simon Peyton Jones Interview | Lambda the Ultimate
16:47:46 <Jedai> SamB_XP: Wait, Python has threads ? ^^
16:47:55 <FunctorSalad> ScottMichael: like in Data.Typeable.typeOf?
16:47:57 <gutworth> Jedai: not very useful ones
16:48:13 <Jedai> gutworth: Yeah I know, I was ironic ;-)
16:48:27 <ddarius> There are sequential concurrent programs.
16:48:28 <Jedai> gutworth: Though Stackless works pretty well for certain things
16:48:40 <gutworth> indeed
16:48:53 <gutworth> although, I don't often need the darn things
16:49:05 <SamB_XP> so... how do I turn off hibernation?
16:49:17 <x6d65> If I have two instances of an (Either Integer Double), how should I go about applying an arithmetic operator to them?
16:49:33 <tristes_tigres> SamB: Lots of coffee. LOTS
16:49:46 <FunctorSalad> x6d65: case analysis?
16:49:48 <Jedai> SamB_XP: Haha ! You don't ! (Seriously I have no idea if this even possible, do you really need this space ?)
16:49:49 <dibblego> Bifunctor from category-extras perhaps?
16:49:56 <SamB_XP> tristes_tigres: won't that be bad for the motherboard?
16:50:05 <ddarius> It should only take one cup of coffee into your computer to turn off hibernation.
16:50:06 <Jedai> x6d65: either (+1) (+1)
16:50:16 <Jedai> @type either
16:50:17 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:50:24 <SamB_XP> ddarius: my plan was to leave the computer operational!
16:50:37 <tristes_tigres> SamB: it also causes leaks (me bad)
16:50:38 <kryptiskt> SamB, somewhere under System. But I can't check now as I'm on a Linux Box
16:50:48 <ddarius> SamB_XP: Now you know the benefit of comprehensive and complete requirements.
16:51:08 <Jedai> x6d65: Ok, that won't work, but whatever do you mean by "applying an arithmetic operator" to an Either ?
16:51:09 <SamB_XP> ddarius: I do?
16:51:23 <SamB_XP> I'm sure you guys could come up with an equally obnoxious suggestion still
16:51:34 <ScottMichael> (M.Map [[Char]] Float) is that really what iw ant it to be?
16:51:54 <ScottMichael> humasect: do you actually know the error?
16:52:25 <ScottMichael> this is where being able to just f******g use a print statement ina function comes in handy...
16:52:26 <x6d65> jedai: Parsec has a naturalOrFloat parser, which I'm hoping to use in combination with an ExpressionParser.
16:52:35 <Jedai> ScottMichael: This associate a list of string to a float
16:52:49 <tristes_tigres> SamB: a neighbor with BIG audio system and large collection of rap albums. No hibernation for you !
16:53:00 <humasect> ScottMichael: the expected type is what ghc figures it needs to get, the inferred is what it is actually getting. it is a split in understanding in a program, a dividing point between two halfs not yet whole.
16:53:13 <humasect> SamB: os hibernation ?
16:53:22 <SamB_XP> tristes_tigres: ... but I wanted to know how to disable it in Windows XP, not myself
16:53:34 <SamB_XP> I'm not capable of hibernating anyway!
16:53:38 <SamB_XP> I'm a human!
16:53:45 <kryptiskt> SamB, Power Options
16:54:00 <tristes_tigres> SamB: A human must hibrnate for at least 7 hours daily
16:54:22 <SamB_XP> tristes_tigres: that's not called hibernation ... and no wonder I've been feeling so lousy lately ;-)
16:54:23 <Jedai> x6d65: Do you want to handle the natural in another way than the float or would you prefer just to work in floating point arithmetic ?
16:54:24 <ddarius> tristes_tigres: That's obviously false.
16:54:25 <humasect> the earth must turn one per 24 hours.
16:54:29 <x6d65> jedai: So I think I want to transform the Either to a Num.
16:54:58 <tristes_tigres> ddarius: for a programmer the specific numbers may vary
16:55:03 <SamB_XP> kryptiskt: thanks
16:55:13 <Jedai> x6d65: Ok, then "either fromInteger id" ought to do the deed
16:55:14 <tristes_tigres> ddarius: and I DID say "human"
16:55:53 <Jedai> x6d65: it will transform your Either value into a Double.
16:56:36 * tristes_tigres wants to suggest to ScottMichael the unspeakable u*****Per*****O
16:56:41 <SamB_XP> hmm, I need a better Windows Update mirror :-(
16:56:50 <ddarius> tristes_tigres: Debug.Trace.trace
16:58:23 <tristes_tigres> ddarius: isn't that just an offspring of the unspeakable u*****Per*****O  ?
17:00:01 <FunctorSalad> ScottMichael: IIRC "assert" can be used in pure functions too if that helps
17:00:05 <ddarius> tristes_tigres: In practice, but there is no reason to import and use unsafePerformIO when there is a safer, better specified, predefined alternative.
17:00:14 <x6d65> jedai: Thanks, I had an unnecessary (fromRational . toRational) in there for the Double transformer.
17:00:24 <tristes_tigres> ddarius: Thanks for suggestion, I didn't knew of the trace
17:01:21 <Jedai> x6d65: That's why we have those "useless" function like id or flip, for use with other higher order functions :)
17:02:16 <tristes_tigres> @bot
17:02:17 <lambdabot> :)
17:03:02 <ScottMichael> yes i know the types dont match ldo but i dont see in what function i do the error. meaning in what aprt of the function
17:03:23 <x6d65> jedai: So now if I parse "10*10" I'll end up with 100.0 when I'd like to have 100.
17:03:33 <tristes_tigres> @src Debug.Trace.trace
17:03:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:03:40 <tristes_tigres> @src trace
17:03:40 <lambdabot> trace string expr = unsafePerformIO $ do
17:03:40 <lambdabot>     hPutStrLn stderr string
17:03:40 <lambdabot>     return expr
17:04:54 <x6d65> jedai: I suppose I really just want (either id id n).
17:04:54 <Jedai> x6d65: Ok, if you want to handle both integral and floating point arithmetic, it's harder work, basically you have to keep the Either value and write new operators like :
17:05:26 <Jedai> Right n <+> Right m = m + n
17:05:52 <ddarius> You can easily make a data type or newtype and make it an instance of Num to handle such things.
17:05:58 <Jedai> Left x <+> Right m = Left (x + fromInteger m)
17:06:21 <Jedai> (Left x) <+> (Left y) = Left (x + y)
17:06:38 <ScottMichael> can i ask for the types of stuff defined in where?
17:06:54 <x6d65> jedai: Shouldn't the type classes take care of that for me?
17:06:59 <Jedai> x6d65: That kind of stuff (lack a Right in the first equation, and lack an equation but you get the drift)
17:07:01 <ddarius> ScottMichael: How would you refer to them?
17:07:17 <ddarius> ScottMichael: Incidentally, Chameleon's type debugger can do roughly this.
17:07:24 <humasect> it would be a nice feature. ':t markovMap.add'
17:07:56 <Jedai> x6d65: You could write a Num instance for that but it would be a bit rough I think, I'm not sure it would work very well
17:08:05 <x6d65> jedai: stripEither = either id id
17:08:19 <ddarius> :t either id id
17:08:20 <lambdabot> forall b. Either b b -> b
17:08:21 <ScottMichael> the normalize type is general enough
17:08:30 <Jedai> x6d65: That won't typecheck, what would be the result type ?
17:08:38 <humasect> x6d65, Jedai , this may be out of place but: why not convert to appropriate type when appropriate type is needed ?
17:08:40 <ScottMichael> :t markovWalk.inner
17:08:42 <lambdabot> Not in scope: `markovWalk'
17:08:42 <lambdabot> Not in scope: `inner'
17:09:04 <x6d65> jedai: Ah, I see.
17:09:07 <ScottMichael> i cant do that it seems
17:09:13 <ScottMichael> would be very helpful
17:09:25 <ddarius> humasect: There aren't conversions between most types.
17:09:31 <ddarius> Let alone canonical ones.
17:09:31 <ScottMichael> now i have kind of a black box which is hard to pick apart and see what happens
17:10:39 <humasect> ScottMichael: it is well-factored enough, it may be time to unravel it and see the dividing point between program A.2 and program A.1 where the types clash
17:10:52 <Jedai> x6d65: You can write a Num instance for (Either Integer Double) if you want, but it's basically writing what I wrote above
17:11:08 <humasect> ddarius: what do you mean? round/truncate, realToFrac/fromIntegral
17:11:10 <Jedai> x6d65: It may be nicer to your eyes though
17:11:12 <ddarius> Jedai: Actually you can't write that in Haskell 98.
17:11:53 <lispy> ddarius: which extension(s) are required?
17:12:12 <ddarius> humasect: Which aren't conversions or canonical in all cases.  A conversion should satisfy convertBack . convertTo = id.  There are no functions Double <-> Integer that satisfy that.
17:12:17 <Jedai> ddarius: FlexibleInstances should be enough, no ?
17:12:37 <ddarius> Well, actually there is a function Double -> Integer and back that satisfies that, but it'd be mostly useless.
17:12:38 <lispy> I thought flexible instances just allows repeated types in instances
17:12:50 <ddarius> And it's certainly not canonical.
17:12:58 <humasect> ddarius: ah right, this is what i thought. but there is a 'better type' which can be dumbed down when needed. like Ratio ?
17:15:13 <ddarius> Jedai: I'm not sure.  The open world assumption means that type can lead to overlapping types.
17:16:02 <ddarius> humasect: You can use some supertype of the types you want.  E.g. Either Integer Double is a supertype of both Integer and Double.
17:16:09 <Jedai> ddarius: Sure but in practice ? I don't think it's a really good idea honestly, I would just define my own operator on that type and that would be it but well...
17:16:14 <humasect> aha..
17:16:51 <humasect> 1.2314214541 == 12314214541 / x ...
17:16:57 <ddarius> Jedai: The sensible thing to do in this case is to make a new type (either newtype Either Integer Double or, better, make a new data type).
17:18:38 <Jedai> ddarius: Right, like data MySuperNum = MInt Integer | MFloat Double and then either MInt MFloat and write your Num instance on MySuperNum
17:18:54 <x6d65> jedai: Can you explain what's going on when I type something like "20 * 20.2233" into ghci?
17:19:25 <Jedai> x6d65: The type inference determine that 20 is a float even if it looks like an integer constant
17:19:26 <ddarius> x6d65: Integer literals in Haskell e.g. 10 and parsed as fromInteger (10 :: Integer)
17:19:30 <Taral> (fromInteger 20) * (fromInteger 20.2233) and then apply defaulting.
17:19:44 <ddarius> Taral: fromRational
17:19:48 <Taral> right :D
17:19:53 <Taral> I meant that.
17:22:23 <x6d65> And yet "20 * 20" yields (Num t) => t ?
17:22:36 <Taral> only in ghci.
17:22:45 <Taral> because ghci doesn't apply full defaulting.
17:23:19 <SamB_XP> eh?
17:23:37 <SamB_XP> it's because :t doesn't do defaulting, you mean ;-)
17:23:41 <lispy> I thought it was lambdabot that had weird defaulting
17:23:48 <Taral> mhm
17:24:44 <Jedai> Taral: If you try to evaluate 20 * 20 in GHCi it evaluate to 40, so it defaults correctly, it's just that :t don't defaults
17:25:08 <Jedai> 400 I mean... :P
17:25:33 <sjanssen> x6d65: yes "20 * 20" has type Num a => a
17:25:35 <Taral> hehehe
17:26:15 <Jedai> x6d65: Because it has this type, you can do (20 * 20) * 23.54
17:26:15 <lispy> sjanssen: I think you mean Num n => n
17:26:21 <lispy> sjanssen: ;)
17:26:45 <sjanssen> x6d65: however when a type with a Num constraint must be monomorphic (due to the monomorphism restriction, printing it, etc.) numeric defaulting kicks in
17:27:18 <sjanssen> Taral: ghci actually applies extended defaulting
17:27:30 <Taral> what's that?
17:27:31 <sjanssen> > typeOf [] -- for example
17:27:33 <lambdabot>   Add a type signature
17:27:35 <sjanssen> pssh
17:27:42 <Taral> heh
17:27:46 <sjanssen> who shut off -fextended defaulting?
17:28:12 <Jedai> > show []
17:28:14 <lambdabot>   "[]"
17:28:17 <sjanssen> hmm, maybe that never worked
17:28:19 <lispy> sjanssen: talk to gwern, I think he's the main one building mueval
17:28:35 <Taral> [] :: [a] has always been the case
17:28:37 <lispy> ?index typeOf
17:28:37 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
17:28:38 <sjanssen> > [] -- or even just this
17:28:39 <lambdabot>   []
17:28:52 <sjanssen> Taral: yeah, but how does GHC choose a type that can actually be shown?
17:29:04 <Jedai> sjanssen: The show shows the extended defaulting I think
17:29:14 <Taral> [a] can be shown.
17:29:16 <sjanssen> Taral: try compiling "main = print []"
17:29:18 <Taral> hm
17:29:33 <Jedai> sjanssen: Hey that was exactly what I was writing !!!!
17:29:49 <Olathe> Quit typing what I'm typing !
17:29:52 <Taral> lol
17:30:03 <Jedai> Taral: [a] can't be shown if a is not a Show instance
17:30:07 <Taral> hmm
17:30:22 <x6d65> I'm still confused on how ghci does exactly what I'd like to do.
17:30:24 <Olathe> @type []
17:30:25 <lambdabot> forall a. [a]
17:30:46 <sjanssen> x6d65: numeric defaulting
17:30:50 <bd_> > let l = [] in (show l) ++ (show $ typeOf l)
17:30:51 <Jedai> x6d65: It don't, it does my first proposition
17:30:52 <lambdabot>   Add a type signature
17:30:57 <bd_> :|
17:31:03 <Olathe> @type (const x) $ show x where x = []
17:31:04 <lambdabot> parse error on input `where'
17:31:11 <Olathe> > (const x) $ show x where x = []
17:31:13 <lambdabot>   []
17:31:24 <Jedai> x6d65: In other words, the whole computation defaults to float arithmetic as soon as there's a float in there
17:31:24 <Olathe> @type let x = [] in (const x) $ show x
17:31:26 <lambdabot> forall a. [a]
17:31:37 <Taral> pfft.
17:31:45 <bd_> Olathe: no monomorphism restriction I guess
17:31:49 <sjanssen> does anyone else think "Who's using Haskell?" on the front page of haskell.org seems overly commercial
17:31:57 <sjanssen> it almost feels like advertisement for those companies
17:32:00 <bd_> @type let f x = (show x) `seq` x in f []
17:32:01 <lambdabot> forall a. (Show a) => [a]
17:32:05 <humasect> likely, sjanssen
17:32:10 <bd_> > typeOf $ let f x = (show x) `seq` x in f []
17:32:12 <lambdabot>   [()]
17:32:16 <bd_> here we go :)
17:32:26 <humasect> > show [()]
17:32:28 <lambdabot>   "[()]"
17:32:32 <ScottMichael> huma: http://hpaste.org/10527
17:32:34 <lispy> > fix show
17:32:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:32:46 <lispy> that always seems to break show :(
17:32:49 <x6d65> jedai: Ah, I think I misunderstood your first proposition. If there were no floats, I'd still have integers?
17:32:50 <Olathe> > fix tv
17:32:51 <lambdabot>   mueval: Prelude.read: no parse
17:32:52 <ddarius> sjanssen: And if it was, so?
17:32:54 <bd_> lispy: it's working fine :)
17:32:54 <humasect> ScottMichael: cool!
17:32:58 <Taral> @type tv
17:33:00 <lambdabot> Not in scope: `tv'
17:33:02 <Taral> ???
17:33:04 <humasect> @type fix
17:33:04 <lispy> :t break show
17:33:06 <lambdabot> forall a. (a -> a) -> a
17:33:06 <lambdabot>     Couldn't match expected type `Bool' against inferred type `String'
17:33:06 <lambdabot>       Expected type: a -> Bool
17:33:06 <lambdabot>       Inferred type: a -> String
17:33:21 <ScottMichael> huma: cool what?
17:33:24 <Olathe> Floats can be constructed from integers with a bit of effort.
17:33:25 <lispy> > tv show
17:33:26 <lambdabot>   mueval: Prelude.read: no parse
17:33:33 <humasect> ScottMichael: in the progress. i am looking at it now
17:33:38 <Jedai> x6d65: No sorry, but why don't you like the second proposition, that seems more like what you want to do (be exact where you can, do float arith anywhere you can't)
17:34:45 <sjanssen> ddarius: it doesn't seem very useful to have them on the front page
17:35:31 <Jedai> x6d65: To do exactly what GHCi does, you would have to use three phases : first build an AST of your expression, then decide of which type your operation would be based on the content of the AST and then evaluate the AST
17:35:40 <humasect> ScottMichael: so 'walk' is of infinite type .. is dropUntil changed ?
17:35:42 <humasect> @src dropUntil
17:35:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:36:03 <ScottMichael> dropUntil [x]    _     = fst x
17:36:03 <ScottMichael> dropUntil (x:xs) pred  = if pred (snd x) then fst x
17:36:03 <ScottMichael>                          else dropUntil xs pred
17:36:35 <Olathe> > let dropUntil f = dropWhile (not.f) in dropUntil (==0) $ iterate (`div` 2) 1000000
17:36:37 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:36:40 <ddarius> sjanssen: That's a different statement from the one you were making before.
17:36:41 <Jedai> x6d65: The second proposition is a little bit of a pain when writing the Num instance but then you get the best precision you can have (without rearrandging the expression or using Rationals)
17:36:58 <ScottMichael> http://hpaste.org/10528
17:37:36 <humasect> ok i will actually look closer.
17:38:04 <sjanssen> ddarius: well, I dislike it for both reasons
17:39:38 <ScottMichael> http://hpaste.org/10529
17:39:53 <ScottMichael> compiles now but : youa\"*** Exception: Map.find: element not in the map
17:39:58 <ScottMichael> which shouldnt happen
17:40:33 <Saizan_> .
17:40:47 <x6d65> jedai: I don't dislike the proposition. I guess I was just hoping that I could bring both operands under Num and let the type classes take care of it.
17:40:59 <humasect> ScottMichael: ah.. i also see no uses of 'find' there
17:41:48 <Jedai> x6d65: You seems to expect something magic to happen but I don't see exactly what, could you specify exactly what you would like to happen ?
17:43:05 <x6d65> jedai: Yes, I think I was expecting something magic to happen based on the magical way GHCi behaves.
17:43:41 <humasect> magic sometimes only lasts as long as we dont see the change from a cause to its effect.
17:45:10 <Jedai> x6d65: The problem is that what happens in GHCi (or GHC) is the result of complex (very, believe me I have been looking at it this summer) work on the Haskell AST by GHC (a very big program, especially by Haskell criteria)
17:45:31 <x6d65> jedai: Okay, that's basically what I wanted to know.
17:45:33 <Jedai> x6d65: lifting that in a casual program isn't that easy...
17:46:18 <Jedai> x6d65: Well in fact you could use Hint or other GHC API high-level interface to get exactly that behaviour for a minimal cost, is that what you want ?
17:46:40 <Jedai> x6d65: If you don't have limits on the size of your program, it may be an option
17:47:15 <x6d65> jedai: I'm basically looking for basic calculator behavior.
17:48:04 <x6d65> jedai: Ideally "2*2.5" would yield "5", "2*2.3" would yield "4.6", "2*2
17:48:08 <ddarius> x6d65: Most hand calculators treat everything as (roughly) Double.
17:48:20 <x6d65> ... would yield "4".
17:48:32 <Olathe> > 2*2.5 :: Rational
17:48:33 <lambdabot>   5%1
17:48:35 <Jedai> x6d65: You could use Rationals to get exact arithmetic
17:49:14 <Jedai> x6d65: but be advised that it don't scale very well to big computations and that some operations aren't available on Rationals
17:49:25 <Cale> Or if you need real numbers, you can use CReal, which is a simple exact real arithmetic library.
17:49:45 <Cale> > showCReal 100 (pi^2 + sqrt 2)
17:49:46 <lambdabot>   "11.28381796346245366763617972408584921388337128261773869959002911421077730...
17:50:05 <kpreid> ddarius: irrelevant curiosity: do most dinky calculators use base 2 or base 10 internally?
17:50:18 <Olathe> > showCReal 5 $ 1.1 * 10
17:50:18 <ScottMichael> f u haskell how can something so simple be so hard? it is failry ridiculous actually
17:50:20 <lambdabot>   "11.0"
17:50:21 <Jedai> kpreid: base 10
17:50:23 <Cale> > showCReal 100 (2 * 2.5)
17:50:24 <lambdabot>   "5.0"
17:50:33 <Cale> > showCReal 100 (2 * 2.4)
17:50:35 <lambdabot>   "4.8"
17:50:35 <Olathe> ScottMichael: There are plenty of languages that make it easy.
17:50:43 <sjanssen> "fail-ry ridiculous" :)
17:50:59 <Olathe> ScottMichael: Try one of those, if Haskell gets in the way.
17:51:24 <Cale> ScottMichael: what are you having trouble with?
17:52:17 <x6d65> jedai: So I could transform my (Either Integer Double) into a Rational, and go from there, converting to something else when I'm forced to abandon precision?
17:52:30 <Cale> > showCReal 100 (exp (pi * sqrt 163))
17:52:31 <lambdabot>   "262537412640768743.9999999999992500725971981856888793538563373369908627075...
17:52:53 <Jedai> x6d65: Apparently CReal is a pretty good option (has most of the operations that Rationals lack too)
17:53:01 <Olathe> > showCReal 100 (exp (0 +: pi))
17:53:03 <lambdabot>   mueval: Prelude.read: no parse
17:53:10 <Olathe> > showCReal 100 (exp (0 :+ pi))
17:53:11 <lambdabot>   Couldn't match expected type `CReal'
17:53:16 <Olathe> Lies.
17:53:34 <Jedai> Olathe: Complex aren't CReal I guess
17:53:43 <Cale> > exp (0 :+ pi) :: Complex CReal
17:53:45 <lambdabot>   (-1.0) :+ 0.0
17:53:48 <ddarius> Olathe: Complex CReal is not CReal
17:54:02 <ddarius> > exp (0 :+ (pi :: CReal))
17:54:04 <lambdabot>   (-1.0) :+ 0.0
17:54:04 <Olathe> How would you get showCReal with those ?
17:54:13 <Olathe> @src Complex
17:54:13 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
17:54:24 <Cale> Olathe: You'd have to break it into real and imaginary parts, and apply showCReal to each.
17:54:49 <Jedai> @src Complex exp
17:54:49 <lambdabot> Source not found. My pet ferret can type better than you!
17:55:00 <x6d65> jedai, Cale: Can you point me to the documentation for it?
17:55:11 <Cale> For CReal?
17:55:15 <Jedai> x6d65: Look on hackage
17:55:24 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
17:55:26 <lambdabot> Title: HackageDB: numbers-2008.4.20, http://tinyurl.com/33mfjx
17:55:29 <Olathe> > let showCComplex n (re :+ im) = showCReal n re ++ "+" ++ showCReal n im ++ "i" in showCComplex 5 $ exp (0 :+ pi)
17:55:30 <lambdabot>   "-1.0+0.0i"
17:55:34 <Cale> Click the "Data.Number.CReal" link there
17:55:43 <Olathe> > let showCComplex n (re :+ im) = showCReal n re ++ " + " ++ showCReal n im ++ "i" in showCComplex 5 $ exp (0 :+ pi)
17:55:45 <lambdabot>   "-1.0 + 0.0i"
17:55:53 <ddarius> Jedai: Both Complex and CReal are types (well the former is a type constructor)
17:56:19 <humasect> > show approxRational (10 % 21) 0.001
17:56:20 <lambdabot>   Couldn't match expected type `Ratio t1 -> t2 -> t'
17:56:30 <ScottMichael> cale: http://hpaste.org/10530, problem is, "walk" is a big black box, its hard to follow it and see where the errors occur
17:56:31 <Olathe> How do you turn a Double into a Rational ?
17:56:32 <Jedai> ddarius: Yeah I know, I was only telling that "showCReal" was unlikely to show Complexs
17:56:33 <humasect> > show $ approxRational (10 % 21) 0.001
17:56:34 <lambdabot>   "10%21"
17:57:05 <Cale> ScottMichael: okay, so let's try separating it into reasonable parts which do understandable things.
17:57:13 <humasect> > show $ approxRational (0.423141) 0.001
17:57:14 <lambdabot>   "11%26"
17:57:27 <humasect> sorry Olathe i was actually typing this without reading what you asked.
17:57:41 <Olathe> Oh, no problem.
17:57:47 <hackage> Uploaded to hackage: panda 2008.9.20
17:57:47 <hackage> Uploaded to hackage: mps 2008.9.20
17:57:57 <Cale> ScottMichael: First of all, it looks like it's concatenating a bunch of words with spaces interspersed between?
17:58:29 <Cale> ScottMichael: So the first simplification I would do is to have it return a list of the words, and apply unwords to the result afterward.
17:58:57 <ScottMichael> hmm" hello y " so it seems it cuts off the word, hence it doesn find it
17:58:58 <ScottMichael> let file = "hello you fool"
17:59:03 <Olathe> > let showCComplex n (re :+ im) = showCReal n re ++ " + " ++ showCReal n im ++ "i" in showCComplex 5 $ exp (pi :+ pi)
17:59:05 <lambdabot>   "-23.14069 + 0.0i"
17:59:38 <Cale> R.randomR (0,1) (R.mkStdGen 333) -- you should note that this is always exactly the same number
17:59:54 <Cale> > randomR (0,1) (mkStdGeg 333) :: Float
17:59:56 <lambdabot>   mueval: Prelude.read: no parse
18:00:02 <Cale> > randomR (0,1) (mkStdGen 333) :: Float
18:00:04 <lambdabot>   Couldn't match expected type `Float'
18:00:10 <Cale> hmm
18:00:21 <Cale> > fst $ randomR (0,1) (mkStdGen 333) :: Float
18:00:23 <lambdabot>   0.85639095
18:00:25 <Cale> > fst $ randomR (0,1) (mkStdGen 333) :: Float
18:00:26 <lambdabot>   0.85639095
18:00:43 <newsham> > randomRs (0,1) (mkStdGen 333) :: [Float]
18:00:45 <lambdabot>   [0.85639095,0.7673295,0.6577194,0.6140698,0.6736815,0.35931855,3.323865e-2,...
18:00:49 <Cale> So your rand isn't even pseudorandom :)
18:01:16 <humasect> there is no such thing as random, it is but an illusion or fancy trick.
18:01:27 <Olathe> What do you mean by random ?
18:01:30 <newsham> int rand() { /* value chosen by roll of unbiased die */ return 3; }
18:01:36 <humasect> 'unpredictable' ?
18:01:55 <Cale> humasect: Well, if QM is true, then there is proper randomness.
18:02:00 <x6d65> jedai: Well, thanks for all of the help and suggestions. I think I'll play around with Rationals. I'm not at all clear how I'd use CReal here.
18:02:07 <humasect> QM has the problem of observer affecting the observed
18:02:17 <newsham> cale: thats a rather philosophical view, no?
18:02:24 <newsham> if QM is true, then randomness can be used to model the universe
18:02:27 <Olathe> Oh, if unpredictableness is all you need, we have randomness.
18:02:29 <SamB_XP> > fst $ randomR (0,1) (mkStdGen 666) :: Float
18:02:29 <humasect> hehe
18:02:31 <lambdabot>   0.72550666
18:02:51 <humasect> fst $ randomR (0,1) (mkStdGen (fst $ randomR (0,1) (mkStdGen fst $ randomR (0,1) (mkStdGen ...))))
18:03:05 <newsham> physics just gives predictive models of the universe, not semantic meaning.
18:03:13 <saml> > let rand n = 0.0001/n in rand 42
18:03:14 <lambdabot>   2.380952380952381e-6
18:03:15 <Jedai> x6d65: You would convert everything to CReal and the computations would be exact as far as you ask for them to be (you can ask your calculator to show as many decimals as you want)
18:03:34 <humasect> not to worry. it is why randomization needs a seed
18:04:04 <Jedai> if the .0 at the end of integer annoys you, you could just process the output of showCReal
18:04:11 <humasect> saml =)
18:04:19 <Cale> newsham: Well okay, there is something which is indistinguishable from proper randomness in the form of which term of some formal sum we observe ourselves landing in.
18:05:07 <humasect> Cale: everything comes from somewhere. randomness can be traced back to its seed. and that seed from somewhere, and so on , and on and on...
18:05:20 <x6d65> jedai: But that wouldn't really help me with, say, "2*2.5" coming out to "5", would it?
18:05:30 <humasect> > 2.380952380952381e-6 / 0.001
18:05:32 <lambdabot>   2.380952380952381e-3
18:05:33 <ScottMichael> i dont know what i was thinking before . it is 0300 here som im tired
18:05:41 <Jedai> x6d65: It would, observe :
18:05:43 <twb> Why, when I'm not doing anything else significant on my laptop, does 'nice make' (for darcs) take sooooooo much longer than plain 'make'/
18:05:44 <ScottMichael> i am deconposing the function now to find the error
18:05:49 <ScottMichael> i will figure it out
18:05:50 <ScottMichael> thanks
18:05:55 <Cale> You can say that the observer is just entangled with the quantum system, but in each term of the sum of states, the observer has observed a definite outcome which, under repeated trials, it is impossible for the observer to distinguish from pure randomness.
18:05:57 <Jedai> > showCReal (2 * 2.5)
18:05:58 <lambdabot>       Overlapping instances for Show (CReal -> String)
18:05:58 <lambdabot>        arising from a ...
18:06:01 <Jedai> > showCReal 4 (2 * 2.5)
18:06:03 <lambdabot>   "5.0"
18:06:12 <Jedai> > showCReal 4 (2 * 2.5000000001)
18:06:14 <lambdabot>   "5.0"
18:06:15 <humasect> ScottMichael=)
18:06:22 <Jedai> Ah no.... too bad
18:06:22 <Cale> ScottMichael: Yeah, break it down into simple bits which compose to get the result you want.
18:06:43 <Jedai> x6d65: Ok, it won't really, all depends on your exigences
18:06:53 <humasect> Cale: so it just means, there is no distinguishing between observer and the observed. they are effectually inseperable. all simulations need input data
18:07:00 <Jedai> > showCReal 10 (2 * 2.5000000001)
18:07:01 <lambdabot>   "5.0000000002"
18:07:08 <newsham> what does haskell use for the infinite precision definition of pi?
18:07:09 <x6d65> jedai: Yeah, honestly it's not that important, it'd just be nice.
18:07:30 <humasect> > properFraction (5.99)
18:07:31 <lambdabot>   (5,0.9900000000000002)
18:07:42 <Jedai> x6d65: You can differentiate integers from non-integers with a arbitrary precision
18:07:44 <ddarius> @src pi
18:07:44 <lambdabot> Source not found. Sorry.
18:07:45 <Cale> newsham:   pi = 16 * atan (fromRational (1 % 5)) - 4 * atan (fromRational (1 % 239))
18:07:46 <ScottMichael> acc_list is the problem it seems
18:07:54 <Olathe> > properFraction 5.99 :: (Rational, Rational)
18:07:55 <lambdabot>       No instance for (Integral Rational)
18:07:55 <lambdabot>        arising from a use of `prope...
18:08:00 <Olathe> > properFraction 5.99 :: (Integer, Rational)
18:08:02 <lambdabot>   (5,99%100)
18:08:17 <humasect> Olathe: ah , tasty=)
18:08:38 <Cale> humasect: uh, I'm not sure if that's quite what I was trying to say, but there's a certain duality in terms of the way that you view things.
18:09:01 <x6d65> Alright, I'm off. Thanks again for the help.
18:09:35 <newsham> > showCReal 200 (exp 1)
18:09:37 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
18:10:00 <humasect> Cale: some say, there are as many experiments as there are views within it. so if there are as many experiments ars there are views by reflection, what is the original experiment, the original view? perhaps each one is the "true" and "correct" one as they have no leaks into the others.
18:10:24 <Cale> humasect: You can either look at it as the obverver becoming part of the quantum system, and the quantum state of the observer being a formal sum over all the possibilities, where in each case, what was observed is a definite result, or you can forget about the rest of the sum (if there are no other observers around which you care about), and record just one term which is the one that you got entangled with.
18:11:09 <humasect> Cale: yep =) it still 'works' as long as the view matches the experiment (observer and observed are not mixed and matched)
18:11:14 <Cale> Or any subset or projection of the terms you'd like to pick, assuming that you don't care about the rest of the information.
18:11:25 <Peaker> do you think that maybe with some hardware modifications to CPU's, "sparks" could become cheap enough that there's no worry about the granularity of parallelism?
18:12:08 * Nafai reads SPJ's latest interview
18:12:18 <SamB_XP> Peaker: heh
18:12:24 <Peaker> Nafai: yeah, it reminded me of that..
18:12:43 <SamB_XP> Peaker: I bet it's been tried ...
18:13:01 <ScottMichael> " boss represents your theory. You should the startup. "
18:13:06 <ScottMichael> guess who
18:13:14 <Cale> humasect: So if I was implementing the universe according to QM on a computer, I would have two options: use lots of space and carry around these rapidly expanding formal sums to the end of time, simulating infinitely many universes, or I could pick one at random and save on space :)
18:13:19 <Peaker> ScottMichael: You accidentally the word
18:13:41 <humasect> Cale: =) =)
18:13:46 <ScottMichael> peaker?
18:13:53 <Peaker> SamB_XP: because I know there are "network processors" that do things very differently - and can handle interrupts (including the context switch/etc) in just one clock cycle!
18:14:04 <SamB_XP> Cale: but what if you wanted to influence events ?
18:14:55 <Cale> SamB_XP: Then I suppose you'd have to keep the sums around so as to figure out which terms you'd like to keep.
18:15:19 <humasect> the only way to actually predict the weather is to have a complete 1:1 identity of all things possible and all their possibilities, and all of their things and possibilities; but yet, the actual model itself is already doing this. so ...
18:15:56 <Cale> You don't really get to influence events as such, you just get to ignore the universes which you don't like. :)
18:15:59 <newsham> "things and possibilities" sounds somewhat vague :)
18:16:06 <SamB_XP> Cale: well, yes, that's what I meant
18:16:16 <Cale> (which is something that a normal quantum observer can't really do)
18:16:22 <newsham> we've already picked the universe in which intelligent life emerges.
18:16:25 <humasect> newsham: my apologies =) all perceivable phenomena, their dependants; aka all things
18:16:34 <SamB_XP> newsham: hehe
18:16:36 <humasect> =)
18:16:48 <SamB_XP> who collapses wave functions before intelligent life emerges ;-P
18:16:48 <Cale> btw, there's a good talk on this...
18:17:02 <newsham> the universes without intelligent life are not occupied by beings arguing about the models of physics
18:17:23 <Cale> http://video.google.com/videoplay?docid=-4674461198051839963
18:17:24 <lambdabot> Title: Sidney Coleman: Quantum mechanics in your face
18:17:26 <Olathe> Oh dear.
18:17:44 <newsham> though i do find it amusing when philosophers start picking at physics models.
18:17:59 <newsham> because they're all works in progress, not suitable for a well structure belief system :)
18:18:17 <humasect> Cale: the observer can see what they like, how they like. they are not just influencing the observation, the observer and observation is the same thing, inseperable. the more detailed the observation (the more cameras/microscopes too) the more detailed the experiment .. etc. the is a monad, there somewhere
18:18:30 * Olathe goes to get the abstract philosophy antidote spray.
18:18:45 <humasect> newsham: physics models are philosophies too, and philosophers are too scientists =)
18:19:01 <ScottMichael> http://hpaste.org/10531
18:19:06 <Cale> humasect: Oh, you're referring to the fact that perception is limited? Sure, that's fine.
18:19:10 * ddarius decides to play guitar for a while.
18:19:12 <newsham> nah, i disagree.  i mean, i understand that some scientists view it that way, but i think physics provides models that predict things to varying degree of success
18:19:24 <newsham> and that, for example, QM is one of those models that has shown some usefulness
18:19:28 <ScottMichael> there it is, haskell markovchain parodymaker
18:19:34 <newsham> it doesnt imply that theres a correspondence with reality
18:19:44 <newsham> it just means that it works well for some purposes
18:19:45 <Cale> I don't believe in objective reality.
18:20:03 <humasect> newsham: they are vague enough never to fail =) what goes up , must come down ..
18:20:12 <Cale> We have observations (which are subjective), and we have models for them :)
18:20:16 <humasect> ScottMichael: excellent=)
18:20:17 <Adamant> you are objectively wrong
18:20:21 <Adamant> ;)
18:20:24 <ScottMichael> equalds roughly 15000 lines of C :)
18:20:34 <newsham> so the quesiton "Is QM 'right'" is meaningless.  its a model that works to solve some problems.
18:20:41 <humasect> ScottMichael: hehe
18:20:42 <newsham> and doesnt work to solve some other problems.
18:20:47 <Cale> newsham: Or has seemed to, anyway :)
18:20:49 <newsham> and eventually there will be a better model
18:21:06 <humasect> none of us are wrong! =)
18:21:10 <Cale> newsham: Possibly, though the word "better" is sketchy :)
18:21:10 <newsham> sure, or seems to for some amount of time we've played with it :)
18:21:35 <newsham> cale: a model that is applicable to more situations and/or is more accurate in its predictions
18:21:41 <Cale> I guess "more useful" in whatever sense you mean "useful" can work as a definition. :)
18:21:57 <ScottMichael> @src dropWhile
18:21:57 <lambdabot> Source not found. Just try something else.
18:21:59 <humasect> every view is correct. every model is accurate to how it models what it models. "it is what it is", things are what they are. nothing simpler, nothing more complicated ~
18:22:09 <newsham> ie. general relativity is more broadly applicable than classic notions of mass and time
18:22:31 <Cale> Newtonian mechanics is, for many situations, better than QM, in the sense that it is a simpler system which gets useful results in those domains. :)
18:22:41 <newsham> *nod*
18:23:12 <Cale> Of course, it can be shown to be implied by QM within an approximation in those domains, which is good. ;)
18:23:46 <SamB_XP> quite a good one, too
18:24:14 <SamB_XP> I mean, do you know what the wavelength of a brick is?
18:24:51 <newsham> never done bricks.  just baseballs
18:24:56 <Cale> But yeah, I also don't think it's meaningful to ask if QM or any scientific model is "true" in an objective absolute sense, any more than it's meaningful to ask if my coffee mug is true or false. It's just a tool which we built.
18:25:00 <SamB_XP> that'll do ;-)
18:25:23 <Cale> Either we are happy with it or we are not :)
18:26:06 <SamB_XP> it is extremely unlikely that we'll ever manage to peek at the implementation of our world
18:26:10 <newsham> i'm happy with this shirt: http://www.thenewsh.com/~newsham/IP.jpg
18:26:24 <newsham> need some haskell wear
18:26:25 <SamB_XP> I mean, if there were security problems like that, I think it'd have crashed already ;-P
18:26:32 <Cale> SamB_XP: Or, if we did, that we'd know for sure that we'd done so.
18:26:40 <SamB_XP> Cale: that too ;-)
18:27:09 <SamB_XP> ... this is of course assuming in the first place that our world is implemented in a computer ;-)
18:27:17 <Cale> hehe
18:28:12 <Cale> Even if we had a model which always gave correct predictions, it seems very unlikely to me that we could know that it would always do so.
18:30:44 <ddarius> newsham: I've wondered how your wife puts up with you.  I just assume it's a good match.
18:33:22 <newsham> ddarius: beats me
18:34:00 <newsham> i try not to question it
18:38:41 <SamB_XP> well, it looks like SP2 is actually installing this time ;-)
18:40:53 <swc> No need for an observer in the relative state formulation (many worlds interpretation)
18:41:30 <SamB_XP> swc: yeah, that was a copenhagen joke if you're referring to my comment ...
18:42:37 <swc> SamB_XP: This seems to be everyone's favorite topic :)
18:43:37 <swc> http://en.wikipedia.org/wiki/Digital_physics is a fascinating theory too
18:43:38 <lambdabot> Title: Digital physics - Wikipedia, the free encyclopedia
18:43:39 <SamB_XP> another good one is: schrodinger's human
18:44:19 <newsham> boltzmann brain?
18:45:04 <SamB_XP> (does it collapse it's own waveform if it might be dead?)
18:45:22 <newsham> oh, nope.
18:46:22 * SamB_XP thinks \BaseNamedObjects\WBEM_ESS_OPEN_FOR_BUSINESS an odd name
18:46:31 <swc> Does it have to be alive to collapse its own waveform, or does there only need to be a finite probability that it could spontaneously become alive?
18:47:22 <SamB_XP> next week: what does this have to do with the soul?
18:48:01 <swc> The is why the  MWI is so compelling, it is so much simpler and does away with all the mystic mumbo jumbo
18:48:28 <SamB_XP> or the who-knows-how-many-worlds interpretation
18:49:01 <swc> The Simulation Argument solves many issue too
18:49:15 <swc> (one-level-deep issues that is)
18:49:24 <SamB_XP> one-level-deep issues ?
18:49:51 <swc> It gets tricky when you start wondering who simulates the simulators
18:50:01 <swc> infinite regress problems
18:50:03 <SamB_XP> easy!
18:50:05 <newsham> its turtles all the way down
18:50:05 <SamB_XP> rich people do
18:50:12 <swc> hahahaha
18:50:15 <SamB_XP> only rich people can afford all that CPU
18:50:25 <ddarius> SamB: The closer you get to the Mohorovic discontinuity the weirder things get.
18:50:30 <SamB_XP> poor people can only simulate pre-simulation cultures ;-)
18:50:48 <swc> unless they access a bot net
18:50:57 <swc> we could be spam
18:51:03 <newsham> dont you think vonnegut's robot theory slices better on occam's razor?
18:51:25 <SamB_XP> robot theory?
18:51:43 <newsham> http://www.thenewsh.com/~newsham/x/literature/Robots-Letter.pdf
18:51:44 <lambdabot> Title: cache:http://www.thenewsh.com/~newsham/x/literature/Robots-Letter.pdf - Google S ...
18:52:17 <electronx> is there function to convert a string to double?
18:52:17 <newsham> in short, you're the only one real, everyone else around you is just a robot
18:52:24 <ddarius> electronx: read
18:52:30 <newsham> an experiment to see how you will react
18:52:40 <electronx> thanks
18:52:42 <SamB_XP> newsham: that doesn't sound too simple to me
18:52:47 <electronx> ?t read
18:52:47 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:52:48 <swc> that's a take on the zombie theory of mind
18:52:54 <ddarius> Who made the robots?
18:53:06 <SamB_XP> wouldn't it be easier to just make a simulation?
18:53:07 <newsham> the creator.  it says so in the letter
18:53:08 <electronx> ?type read
18:53:10 <lambdabot> forall a. (Read a) => String -> a
18:53:15 <SamB_XP> newsham: who's the letter from?
18:53:15 <pjdelport> newsham: you mean we aren't all biochemical robots?
18:53:18 <swc> who is the creator?
18:53:26 <SamB_XP> WHO IS THE CREATOR!
18:53:29 <SamB_XP> DESTROY!
18:53:31 <SamB_XP> DESTROY!
18:53:39 <newsham> samb: the guy running the simulator i guess :)
18:53:49 * SamB_XP attempts to quote Star Fox 64
18:53:54 <ddarius> pjdelport: The issue isn't whether we are biochemical or not, but whether you are all here to see how I react.
18:53:59 <newsham> (text if you dont like pdf: http://www.thenewsh.com/~newsham/x/literature/Robots-Letter.txt)
18:54:00 <swc> SamB_XP: you forgot to prefix that with CRUSH and KILL
18:54:19 <SamB_XP> swc: I don't remember the crazy bot saying that in starfox
18:54:27 <SamB_XP> hmm, I wish our n64 worked :-(
18:55:39 <SamB_XP> this one doesn't even have a good excuse to have failed like the last one -- a TV fell on the last one, with super smash brothers inside iirc ...
18:55:53 <SamB_XP> needless to say, the cart got smashed
18:56:01 <dons> spj's talk even made osnews, http://osnews.com/story/20305/The_A-Z_of_Programming_Languages_Haskell
18:56:10 <dons> so osnews, ltu, lambda the ultimate. great stuff.
18:56:11 <lambdabot> Title: The A-Z of Programming Languages: Haskell, http://tinyurl.com/4cntve
18:56:16 <newsham> smashed smashed bros.  ironic
18:56:22 <SamB_XP> but the n64 motherboard apparantly got cracked as well, since it wouldn't work after that though there was no visible damage
18:56:45 <dibblego> apparently
18:56:49 <SamB_XP> yeah, my sister was wearing headphones and got up in a hurry ...
18:56:56 <ivanm> dons: heh, yeah, I'm reading it now (on computerworld though)
18:57:10 <swc> SamB_XP, CKD -- http://www.podster.pwp.blueyonder.co.uk/fotos/tv_lisroa.jpg
18:57:32 * ddarius <3 Kurt Vonnegut
18:57:34 <SamB_XP> the TV did not appear to suffer any damage from this, either, though I hope it breaks soon so we move the good one into the living room ...
18:57:38 <swc> "Revolt Of The Androids
18:57:39 <swc> Verda the department store android returns, pursued by an alien superman sent to bring her back or destroy her. When the Robinsons win over the superman's sympathies, the CDS machine simply creates another android, stronger and totally devoted to destruction. ["Crush, Kill, Destroy!"]
18:57:52 <SamB_XP> ... it's old and blurry right now
18:59:29 <SamB_XP> but our last n64, well, one day we tried to use it but it wouldn't turn on...
18:59:42 <SamB_XP> or at least, didn't start up
18:59:44 <lispy> SamB_XP: that's a sad story.
18:59:48 <ddarius> dons: Presumably OSNews is displaying all the A-Z interviews.  LtU is, though SPJ's was singled out.
18:59:54 * lispy hands SamB_XP a lambda shaped tissue
19:00:00 <SamB_XP> so we need to get another I guess ...
19:00:07 <ddarius> Seems like a happy story to me.
19:00:11 <SamB_XP> ddarius: what?
19:00:25 <Axman6> SamB_XP: and they couldn't resuscitate it? :(
19:00:31 <ddarius> A big waste of time was crushed by an act of God.
19:00:48 <SamB_XP> Axman6: well, we didn't send it in to mario ...
19:00:58 * lispy wonders how SamB_XP's N64 story can be encoded in the type system
19:01:00 <SamB_XP> (you know, the one with the screwdriver ;-)
19:01:04 <Axman6> i guess that would only be cruel
19:01:25 * lispy suggests using the Emulator monad
19:01:27 <SamB_XP> we should send our SNES in too ...
19:01:44 <Axman6> [Just on, Just on, Just on, Nothing]
19:01:45 <SamB_XP> lispy: I think it would be cheaper to buy a new N64, honestly
19:02:10 <Axman6> i've still got my 64, with its two games :)
19:02:11 <SamB_XP> than to get all the stuff I'd need to run an n64 emulator acceptably
19:02:18 <SamB_XP> Axman6: only 2?
19:02:24 <Axman6> yeah :P
19:02:33 <Axman6> mario cart, and 1080 snowboarding
19:02:40 * lispy was hoping his hints would be taken earlier
19:02:48 <lispy> Would you mind moving the non-haskell stuff to haskell-blah please :)
19:03:01 <lispy> It's a fun discussion, but I don't see how it's on topic...
19:03:11 <swc> I'm reading that A-Z language article now.  What's the issue with adding records to Haskell?  Doesn't seem like it would be too hard.
19:03:28 <ddarius> swc: Haskell has records.
19:03:35 <Axman6> lispy: we're ... errr.. writing games in haskell for the 64
19:03:44 <lispy> Axman6: cool!
19:04:33 <Axman6> yeah...
19:04:47 <swc> ddarius: I guess I mean a richer one. From the article: "Another more minor thing was records. Haskell has a very simple record system, and there are lots of more complicated record systems about. It‚Äôs a rather complicated design space. Record systems are a place where there‚Äôs a lot of variation and it‚Äôs hard to know which is best"
19:05:06 <Axman6> who knew they used opengl, and made new 64's that look just like macbook pro's...
19:05:14 <swc> I din't realize it was such a complicate design space
19:05:24 <ddarius> swc: The last sentence tells you the problem.
19:05:29 <swc> yeah
19:05:37 <ivanm> "Now it‚Äôs used a lot in industry but typically by people who are generally flexible, and they are a generally a self selected rather bright group." <-- I think this quote of SPJ's is great
19:09:25 <Axman6> Cale: you around?
19:09:36 <Cale> Hi
19:09:51 <Axman6> first question... do you sleep? :|
19:10:07 <mapreduce> :t sleep
19:10:09 <Cale> I do, but my sleep schedule has been a bit odd lately :)
19:10:09 <lambdabot> Not in scope: `sleep'
19:10:21 <Cale> I slept for a few hours, just a short while ago.
19:10:33 <Cale> I'll be going back to sleep in a couple hours from now :)
19:10:48 <Axman6> heh, righto
19:11:41 <Cale> (I was waking up around dinnertime and going to bed in the morning, but there's a concert in the middle of the day tomorrow that I'd like to go see, so I have to flip my hours around :)
19:11:59 <Axman6> hehe
19:12:01 <ivanm> Cale: you trying out polyphasic sleep or something?
19:12:27 <Cale> No, it's just that if I don't set an alarm clock, my hours shift forward by a couple hours every day.
19:12:51 <qwr> lol... almost same here.
19:13:11 <qwr> Cale: it stops for me when i go to sleep on the morning ;)
19:13:15 <Cale> I think my body runs on a 32 hour clock or something. :)
19:13:26 <qwr> Cale: which i'll do quite soon, 5:13 here
19:13:51 <Axman6> Cale: yeah, i seem to settle down into a 28 hour day during the holidays
19:14:06 <Cale> qwr: Well, usually at that point, I start thinking I should fix things up... so I'll stay up a little longer, have a nap in the middle of the day, but wake up tired, have dinner and then go to bed at a reasonable hour.
19:16:06 <Cale> For me, the point where I start getting concerned is maybe around 7 or 8am :)
19:20:20 <qwr> ok. i just feel comfortable getting to sleep somewhere between 4 to 6... with exceptions sometimes :)
19:21:07 <qwr> but reasonable hours seem impossible - i then usually wake up after few hours of sleeping
19:21:29 <qwr> which don't make anything more normal...
19:21:36 * FunctorSalad_ wonders why runghc is way slower than doing c-c c-l, "main" in emacs
19:22:33 <Axman6> Cale: yay, figured out one of the harder problems on that thing. it ws one you'd given me quite a hand in, but i still (think) i got it :)
19:22:45 <Cale> cool :)
19:22:52 <Axman6> the apple one
19:22:57 <Axman6> apple :: (Misty m) => m a -> m (a -> b) -> m b
19:23:39 <Axman6> and it works :)
19:23:48 <Axman6> what is that function anyway?
19:23:59 <dibblego> @type ap
19:24:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:24:04 <int-e> @type flip ap
19:24:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
19:24:07 <Axman6> ah ha
19:24:24 <dibblego> @type (<*>)
19:24:26 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:25:08 <int-e> :t (<**>)
19:25:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
19:25:16 <int-e> :)
19:25:27 <newsham> ?src (<**>)
19:25:27 <lambdabot> (<**>) = liftA2 (flip ($))
19:25:57 <newsham> ?src (<*>)
19:25:58 <lambdabot> Source not found. Are you on drugs?
19:26:18 <int-e> @src liftA2
19:26:18 <jeffwheeler> I'm sure this is asked every hour, but how can I take a list, say [1, 2, 3, 4, 5, 6], and collect groups of three, like [[1, 2, 3], [4, 5, 6]]?
19:26:18 <lambdabot> liftA2 f a b = f <$> a <*> b
19:26:32 <Cale> ap [id, (+2), (*2), (^2), (2^)] [5,6]
19:26:33 <jeffwheeler> I can't seem to do it with any of the prelude functions.
19:26:34 <Cale> > ap [id, (+2), (*2), (^2), (2^)] [5,6]
19:26:35 <lambdabot>   [5,6,7,8,10,12,25,36,32,64]
19:26:39 <newsham> > splitAt 3 "this is a test here"
19:26:40 <lambdabot>   ("thi","s is a test here")
19:26:45 <newsham> thats how you can get the first split.
19:26:56 <jeffwheeler> newsham: hmm, but the rest?
19:26:59 <newsham> collecting a list of all of the splits is an unfold
19:27:17 <jeffwheeler> Hmm, I'll look at that; thanks.
19:27:23 <Axman6> f n xs = (take n xs): f n (drop n xs)
19:27:27 <newsham> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
19:27:29 <lambdabot>  Defined.
19:27:31 <Axman6> is how id do it
19:27:35 <int-e> this must be the most frequently requested list function :)
19:27:36 <newsham> > unfoldUntil null (splitAt 3) "this is a test here"
19:27:36 <Axman6> '*
19:27:37 <lambdabot>   ["thi","s i","s a"," te","st ","her","e"]
19:27:46 <Cale> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1,2,3,4,5,6,7,8]
19:27:47 <lambdabot>   [[1,2,3],[4,5,6],[7,8]]
19:27:49 <Axman6> > let f n xs = (take n xs): f n (drop n xs)
19:27:50 <lambdabot>   mueval: Prelude.read: no parse
19:28:25 <Axman6> > let f n xs = (take n xs) :(f n $ drop n xs) in f 3 [1,2,3,4,5,6,7,8]
19:28:26 <lambdabot>   [[1,2,3],[4,5,6],[7,8],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
19:28:30 <Axman6> :|
19:28:33 <int-e> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1,,8]
19:28:34 <lambdabot>   mueval: Prelude.read: no parse
19:28:51 <Axman6> > let f n xs = (take n xs) :(f n $ drop n xs); f _ [] = [] in f 3 [1,2,3,4,5,6,7,8]
19:28:52 <lambdabot>   mueval: Prelude.read: no parse
19:28:52 <lambdabot>  mueval: UnknownError "GHC reported errors a...
19:28:59 <int-e> > map (take 3) . takeWhile (not . null) . iterate (drop 3) $ [1..8]
19:29:00 <lambdabot>   [[1,2,3],[4,5,6],[7,8]]
19:29:27 <jeffwheeler> That's the same solution as Cale above; I think that's my favorite.
19:29:32 <jeffwheeler> Thanks for y'all's help.
19:29:47 <Axman6> > let f n [] = []; f n xs = (take n xs) :(f n $ drop n xs) in f 3 [1,2,3,4,5,6,7,8]
19:29:48 <lambdabot>   [[1,2,3],[4,5,6],[7,8]]
19:30:01 <dejones> dons: I love the Haskell community.  I didn't even know that a "rope data structure" existed.  :)
19:30:15 <dons> ah hehe.
19:30:21 <dons> ropes are cool.
19:30:37 <dons> trees.
19:30:38 <Axman6> what are ropes?
19:31:02 <jeffwheeler> I don't really know anything about it, but there's also an implementation for Data.ByteRope in Yi.
19:31:03 <dons> "strings" that support efficient ++
19:31:12 <Axman6> they let you climb trees?
19:31:19 <dejones> dons: Just amazes me how much I learn from #ghc, #haskell, and haskell-cafe on a daily basis!
19:31:20 <Axman6> :P
19:31:59 * Nafai hacks on some Haskell stuff again
19:32:03 <dons> well, it's the foundation of our industry. it's frankly *weird* other communities aren't active in the understanding of our business.
19:32:04 <dejones> dons: Did UNSW teach you ropes data structures in a course...?
19:32:07 <dons> nope.
19:32:20 <dejones> :)
19:32:28 <newsham> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
19:32:34 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
19:32:34 <dejones> Yah, the Haskell community is phenomenal.
19:32:41 <Axman6> dejones: dons taught UNSW about them, im sure ;)
19:32:55 <dejones> newsham: Yah, finger trees are very cool too, which I learned about from haskell-cafe.
19:33:32 <dejones> Axman6: Hehe, yea, dons is impressive.
19:34:41 <dejones> dons: We'll have to meet one of these days.  I plan to travel to Portland some time next year to visit a friend of mine that just started working at Siemens as a Security Architect.
19:35:00 <dejones> dons: I told him to go to the Galois tech talks.  He's an a applied crypto PhD graduate.  ;)
19:35:46 <dons> hmm. interesting.
19:38:10 <dejones> dons: are you working on a Friday night?
19:38:14 * dejones is..  
19:38:17 <dejones> :/
19:38:18 <dejones> heh
19:46:36 <Axman6> hmm, how is banana f (EitherLeft (Right x)) = (EitherLeft (Right x)) different to banana f r = r
19:46:51 * Nafai makes some progress with gtk2hs
19:47:41 <Axman6> or even banana f (EitherLeft r) = EitherLeft r
19:54:08 <jeffwheeler> @pl \(d, _) -> take 3 $ drop d (chars n)
19:54:09 <lambdabot> take 3 . flip drop (chars n) . fst
19:54:34 <SamB_XP> hmm, something isn't right here ... google chrome's scrollbars are missing their arrows!
19:54:43 <newsham> ax: one is applicable more often than the other?
19:55:03 <SamB_XP> maybe because I'm using a classic-style theme?
19:55:50 <Axman6> newsham: well i've already matched (EitherLeft (Left x)), and the only other thing that can be matched is (EitherLeft (Right x))
19:56:58 <newsham> ax: then possibly the same?
20:01:02 * SamB_XP wonders how to get google chrome to use his google bookmarks ...
20:01:49 <SamB_XP> I guess they don't have the google toolbar for google chrome yet ;-P
20:14:26 <Jedai> Axman6: "banana f (EitherLeft r) = EitherLeft r" reconstruct the EitherLeft, depending on the definition of the type for which EitherLeft is a data constructor, the second "EitherLeft r" could have a different type than the first (whereas this is impossible in "banana f r = r")
20:15:20 * Nafai tries to figure out how to add a keystroke listener
20:15:21 <Axman6> well if it helps, EitherLeft b a = EitherLeft (Either a b)
20:16:55 <newsham> you could do banana f x@(EitherLeft (Right x)) = x
20:17:23 <Axman6> i'm assuming one of thise x's would have to be renamed ;)
20:17:37 <newsham> err.. yes, x is a poor choice on my part
20:19:43 <Nafai> Any gtk2hs users around?
20:20:09 <Nafai> How would I add a handler on an Entry for keypresses...so I do something when the user hits Esc
20:23:12 <newsham> general gtk channel might get you more answers.
20:25:12 <SamB_XP> newsham: but in which scripting language starting with P would they be?
20:25:28 <newsham> hmm?
20:25:40 <SamB_XP> Perl? Python? PHP? Ruby?
20:26:01 <newsham> probably C.  but its not really a matter of language, so much as API
20:26:20 <SamB_XP> eww, even worse!
20:26:21 <SamB_XP> C!
20:26:52 <newsham> gtk is a C API, after all.
20:27:24 <sbahra> apo
20:27:30 <sbahra> Woops
20:27:31 <newsham> not sure, but i think you might have to alter the object's event mask, and you might not be able to do it without making a new widget
20:27:34 <SamB_XP> no it isn't
20:28:01 <SamB_XP> since when does C start with a P, anyway?
20:28:15 <ddarius> SamB_XP: Since when does Ruby start with a P?
20:28:22 <ScottMichael> the happening is one of the worst movies ever lol
20:28:29 <SamB_XP> ddarius: it's a widely accepted fact that ruby begins with a P
20:28:35 <ScottMichael> but zoe is cute
20:29:06 <SamB_XP> ... possibly related to difficulty in pronouncing LAPR?
20:30:11 <Axman6> @pl (((+) .). (+))
20:30:11 <lambdabot> ((+) .) . (+)
20:30:14 <Axman6> @unpl (((+) .). (+))
20:30:15 <lambdabot> (\ d g -> (+) (d + g))
20:31:16 <ScottMichael> ruby begins with an R are u blind?
20:31:26 <sbahra> r you blind?
20:31:32 <ScottMichael> its not puby is it?
20:31:55 <Axman6> yes, it is
20:32:01 <Axman6> what'd you think it was?
20:32:05 <ozy`> stop thinking in Cyrillic, you guys
20:32:13 <ScottMichael> setf! ironi off
20:32:16 <newsham> there's a key-press event but its probably already being used by the entry itself.  you can try connecting to it to see if you can get it
20:33:04 <Nafai> newsham: Yeah, I'm looking at that right now
20:33:05 <Nafai> Thanks
20:37:39 <electronx> i have a question about the following code
20:37:41 <electronx> myFoldl :: (a -> b -> a) -> a -> [b] -> a
20:37:41 <electronx> myFoldl f z xs = foldr step id xs z
20:37:41 <electronx>     where step x g a = g (f a x)
20:38:03 <electronx> is it the same as foldr (step id xs z)?
20:38:29 <electronx> are functions evaluated from right to left?
20:39:10 <electronx> otherwise it seems a bit mystical to me
20:40:16 <electronx> anyone?
20:41:23 <aempirei> functions have relaly high precedence
20:41:28 <aempirei> like if i do balls cocks 6
20:41:36 <aempirei> balls will try to apply to cocks
20:41:46 <aempirei> instaedl of balls (cocks 6)
20:42:17 <Saizan> foldr step id xs z === ((((foldr step) id) xs) z)
20:42:27 <Saizan> i.e. function application is left associative
20:42:32 <electronx> ok
20:42:46 <electronx> thanks
20:44:57 <Nafai> What does the @ mean in this line?
20:44:58 <Nafai> keyPressHandler button (keyEvent@(Key { eventKeyName = keyName }))
20:45:06 <dibblego> as-pattern
20:45:19 <bd_> Nafai: it means whatever matched that Key { ... } bit /also/ gets bound to keyEvent
20:46:09 <Nafai> Thanks, I vaguely remember that
20:46:18 <Nafai> It's been too long since I've written any Haskell
20:46:23 <Nafai> It just hasn't clicked yet
20:46:27 <Axman6> Nafai: y@(x:xs) = y == y@(x:xs) = x:xs
20:46:37 <Axman6> if that helps...
20:49:20 <Axman6> Cale: still around? i was wondering if you might like to give me a hand with the state part of those exercises again
20:49:29 <Cale> okay
20:50:02 <Cale> For both our sanity's sake, let's use the proper terms for things :)
20:50:15 <Axman6> heh, ok. sounds good to me
20:50:46 <Axman6> i keep catching myself calling things the proper names and using the pre defined functions like return -_-
20:51:03 <Cale> Okay, so the idea is that we're representing computations which observe and manipulate a state value of type s, and return a value of type a, by functions of type s -> (s,a)
20:51:37 <Cale> That is, they're functions from an initial state, to a final state paired with their result.
20:52:08 <Cale> We have  newtype State s a = State { runState :: s -> (s,a) }
20:52:31 <Axman6> yep, i think i get that
20:52:32 <Cale> So that the  runState  function has type  State s a -> s -> (s,a)
20:52:51 <Axman6> ah, right
20:53:09 <Cale> That is, it takes a wrapped up State s a computation and a value of type s, and 'runs' it to get a final state and result.
20:53:53 <Cale> Of course, all it's doing is applying the function, but it adds some meaning to that :)
20:54:16 <lispy> Why did the value cross the functor?
20:54:33 <lispy> (to get to the other type...)
20:54:35 <Cale> Okay, so now, (return v) is supposed to be the computation which "does nothing", and produces the value v as its result.
20:54:43 <sbahra> lispy, n1
20:55:02 * Axman6 tries something
20:55:24 <Axman6> ok, maybe not
20:55:28 <lispy> sbahra: n1?
20:55:35 <Korollary> nice one
20:56:41 <lispy> ah
20:58:27 <waynemokane> @type liftIO
20:58:28 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:58:48 <Cale> Axman6: okay, so any idea how return should look?
20:58:58 <Axman6> none at all :\
20:59:18 <Cale> Axman6: okay, well, what is its type first of all...
21:00:07 <glguy> If a .hsc file's #include <> isn't finding a file in /usr/local/include how would I add that include path when building with Cabal?
21:01:24 <Axman6> Cale: return :: s -> State s a?
21:01:29 <Cale> nope
21:01:45 <Axman6> i'm not realy sure what you're asking
21:01:48 <Cale> Our monad here is State s
21:01:49 <Axman6> l*
21:01:58 <Cale> So replace m with State s in the type of return :)
21:02:13 <Axman6> :t return
21:02:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:02:14 <Axman6> ;)
21:02:21 <Axman6> return :: s -> State s
21:02:27 <lispy> Axman6: think of it this way, you don't return state into the monad.  But you can get/set the state in the monad
21:02:27 <Cale> no
21:02:31 <Cale> m = State s
21:02:39 <Cale> So return :: a -> State s a
21:02:40 <Axman6> ah
21:02:44 <Axman6> yeah
21:03:52 <Cale> okay, and so we know that it's got to produce one of these things of type State s a
21:04:13 <Cale> The only way we presently have to do that is the data constructor   State :: (s -> (s,a)) -> State s a
21:05:06 <Cale> So most likely,  return v = State (...)
21:05:25 <Axman6> oh, we're working on unicorn. my bad
21:05:25 <Cale> What should the type of (...) be there?
21:05:31 <Axman6> heh
21:05:34 <Cale> hehe, yes
21:06:50 <Axman6> hmm
21:07:12 <Axman6> State (s -> (s,v)?
21:07:27 <Axman6> or State (v -> (v,a)
21:07:48 <Cale> Think about the type :)
21:08:11 <Axman6> State (\s -> (s,v)?
21:08:16 <dancor> can cabal express deps on binaries (not libraries) (e.g. currently lambdabot doesn't depend on mueval but it should)
21:08:29 <Cale> Axman6: well, modulo a paren, yes
21:08:40 <Axman6> heh, es
21:08:42 <Axman6> yes*
21:09:54 <Cale> Do you see how that works?
21:10:17 <Cale> Okay, now >>=
21:10:45 <Cale> (if you're good on that)
21:10:59 <Axman6> yeah, i think i do. give me a sec to think about it though ;)
21:11:32 <Axman6> ok, righto. i think i get it
21:11:50 <Cale> The computation return v is represented by the function which doesn't alter the state at all (final state is the same as initial)
21:11:56 <Cale> and the result is v
21:11:58 <waynemokane> can someone give me a good starting point or reference for doing exception handling?  like I have a bunch of functions that return Maybe Blah based on parsing data from a network connection
21:12:36 <waynemokane> also, is there a more sophisticated way to do debugging than throwing in putStr inside a do construct?
21:12:43 <dons> use the  debugger?
21:12:54 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
21:12:56 <lambdabot> Title: 3.5.ÔøΩThe GHCi Debugger, http://tinyurl.com/2orwlb
21:13:54 <waynemokane> oh sweet, looks similar to gdb
21:14:57 <dons> sort of. it's useful for exploratory debugging. there's other techniques (using -fhpc, using quickcheck, using profiling)
21:15:07 <dons> but its a good start, and certainly a tool to have in the repetoire
21:15:11 <waynemokane> dons: thanks for this info
21:15:15 <Axman6> Cale: so with state, is it basically passing around an annonymous function with some data?
21:15:34 <waynemokane> I guess I was thinking more from the perspective of, several monad tutorials talk about how debugging can be "added" to existing functions by another monadic layer
21:15:37 <Cale> It's representing state computations by functions.
21:15:48 <waynemokane> in the examples this amounted to carrying around a debugging string with each computation step
21:16:06 <Axman6> hmm, ok
21:16:14 <Cale> Axman6: This is proper functions-as-data functional programming stuff now :)
21:16:32 <dons> waynemokane: kinda, yeah, you can trace evaluation using a writer monad
21:16:35 <Axman6> got a nice analogy by any chance?
21:16:40 <Cale> Axman6: We could represent state computations using some kind of syntax tree which we then interpreted, but why, when we have functions :)
21:16:41 <dons> sort of like aspect oriented programming :)
21:17:36 <waynemokane> @help thunk
21:17:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:17:37 <Cale> Axman6: The idea here though is to build up enough stuff so that we can forget about the internal representation.
21:17:50 <Axman6> yeah
21:17:53 <Cale> Axman6: on top of return and >>=, we'll also have get and put
21:18:05 <Cale> and those will be enough to write any State computation we want.
21:18:23 <Axman6> would get return the second part of the tuple?
21:18:35 <Cale> mmm... no
21:18:39 <Cale> Which tuple? :)
21:18:52 <Axman6> the a part of (s -
21:18:59 <Axman6> the a part of (s -> (s,a))*
21:19:04 <Cale> get is a State computation, so it's a function s -> (s,a) under the covers.
21:19:19 <Cale> Well, more properly, get :: State s s
21:19:35 <Cale> So that's s -> (s,s)
21:19:41 <Cale> So which function will it be?
21:19:58 <Cale> There really aren't very many options :)
21:20:13 <Axman6> (\s -> (s,s))?
21:20:17 <Cale> right
21:20:25 <Axman6> hurray
21:20:49 <Cale> get = State (\s -> (s,s))
21:21:21 <Axman6> doesn't get need some sort of argument? :\
21:21:40 <Cale> No.
21:21:57 <EvilTerran> it might be easier to think of it while being flexible with the presence of the newtype
21:22:01 <EvilTerran> (it might not)
21:22:02 <Cale> Its purpose is to be a State computation whose result is the current state.
21:22:41 <araujo> Igloo, ping
21:23:46 <Axman6> ok, i think i mighr have some lunch and come back to this later
21:23:47 <dons> Cale, did i ask if you were coming to ICFP?
21:23:57 <waynemokane> is it fair to say that, from a novice's perspective, there is no material difference between newtype and data?
21:24:00 * dons is visiting canada for the first time.
21:24:05 <Cale> dons: Oh, where is it?
21:24:11 <dons> Victoria.
21:24:13 <SamB_XP> Cale: north of the US
21:24:20 <Cale> ah, that's like, on the other side of the country :)
21:24:21 <dons> so a bit of a hike..
21:24:23 <dons> yeah :)
21:24:34 <dons> close to portland, though, relatively.
21:24:39 <Cale> yeah
21:24:52 * SamB_XP pretends Cale was asking where canada was ;-P
21:26:30 * glguy is driving the van to Canada Sunday for ICFP :)
21:27:10 <glguy> KIDS IN THE BACK SEAT
21:27:15 <dons> hehe
21:27:18 <dons> are we there yet!?
21:27:40 <glguy> If I hear that one more time I'll take you all to the Python conference!
21:27:45 <dons> oh man.
21:27:48 <dons> we'll be good!
21:27:53 <jdrake> glguy, what is that?
21:28:06 <jdrake> I just need to know what 'that' is :-)
21:28:08 <Nafai> glguy: It could be worse! It could be JavaOne!
21:28:23 <SamB_XP> glguy: is that at the same time?
21:28:34 <SamB_XP> and isn't it a long way from canada to DC?
21:28:42 <SamB_XP> or isn't pycon always in DC?
21:28:43 <glguy> SamB_XP: no, its just the first thing that came to mind
21:29:07 <glguy> SamB_XP: isn't that like asking if the pacific ocean is far from south america?
21:29:32 <SamB_XP> glguy: uh, I'm pretty sure they abut
21:29:41 <Nafai> SamB_XP: It was in Chicago this year
21:29:45 <SamB_XP> whereas DC is not next to canada
21:30:11 <SamB_XP> hmm, can't believe I ever wanted to go to pycon ;-)
21:30:21 <Nafai> SamB_XP: It was fun the 2 years I went :)
21:30:50 <SamB_XP> yes but it's about ... Python ... why would I want to go to a con about Python ?
21:31:12 <Nafai> Any more, I dunno.
21:31:25 <Axman6> SamB_XP: to preach the one true way?
21:31:44 <SamB_XP> Axman6: hmm, are you sure they wouldn't burn me at the stake?
21:32:00 <SamB_XP> or ... poke me with pointy sticks, or something ?
21:32:06 <Axman6> they're not C guys are they?
21:32:17 <SamB_XP> or, worse, the COMFY CHAIR
21:32:24 <Axman6> oh god!
21:32:51 <SamB_XP> what were the other weapons?
21:32:59 * ddarius kicks his water over, closes his window, and gets his silk.
21:33:09 <Axman6> ....
21:33:27 <SamB_XP> Axman6: you aren't familiar with the spanish inquisition?
21:33:44 <eelco> anybody in victoria for the ICFP willing to help me preventing a jetlag?
21:34:05 <Axman6> SamB_XP: not so much
21:34:10 <Heffalump> I'll be there in about 20 hours...
21:34:17 <SamB_XP> http://people.csail.mit.edu/paulfitz/spanish/script.html
21:34:18 <lambdabot> Title: The Spanish Inquisition - Monty Python
21:34:19 <Axman6> eelco: does this involve cocain?
21:34:32 <eelco> not that i know
21:34:40 <dons> eelco: you there already?
21:34:44 <dons> for the workshops tomorrow?
21:35:10 <eelco> i was more thingking about a walk around town
21:35:10 <dons> we should start thinking about which night to have the #haskell meetup.
21:35:16 <dons> and where to have it.
21:35:32 <dons> eelco: i'm not sure who else is already in town!
21:35:42 <eelco> i'm just early, probably not going to the workshops
21:36:10 <eelco> chr1s will be here soon, he got stuck in vancouver
21:36:19 <dons> cool.
21:36:22 <eelco> and thomas van noort is already here
21:37:17 <dons> we should open up #haskell-icfp
21:37:42 <dons> join #haskell-icfp :)
21:38:13 <eelco> i also join #icfp :)
21:38:27 <eelco> man, my typing sucks
21:38:53 <eelco> i've been up way too long with way too little sleep beforehand :)
21:49:53 <waynemokane> is "fail" the proper way to put in a fatal error w/msg in a program?
21:50:05 <dons> no.
21:50:12 <dons> 'error' if you want to just terminate the program
21:50:24 <waynemokane> @type error
21:50:26 <lambdabot> forall a. [Char] -> a
21:51:01 <Axman6> > error "x" :: Int
21:51:02 <lambdabot>   mueval: Prelude.read: no parse
21:51:02 <lambdabot>  mueval: *** Exception: x
21:51:07 <Axman6> heh
21:51:52 <dons> it throws an exception, which will terminate the program if not caught.
21:52:17 <dons> you can use exitWith (ExitFailure 1) -- if you're in the IO monad
21:52:25 <dons> and want to set a specific exit condition.
21:52:27 * SamB_XP throws an electrical exception, which must be struck with the master sword in order to avoid program termination
21:54:34 <ivanm> SamB_XP: trying to blow up your computer, are you?
21:54:57 <SamB_XP> ivanm: no! I guess I should be heading to bed ...
21:55:02 <ivanm> heh
21:55:15 <ivanm> electrical exception sounded like an electrical surge, that's all..
21:57:16 <waynemokane> oopsie, forgot to flush
21:57:19 <waynemokane> @type flush
21:57:21 <lambdabot> Not in scope: `flush'
21:57:24 <waynemokane> @type hFlush
21:57:25 <lambdabot> Not in scope: `hFlush'
21:57:43 <waynemokane> bah.  I give up
21:58:02 <solrize> i really like the slides from that hyena web server talk
21:59:01 <polymorf> ok
22:02:48 <moconnor> What does "instance Fluffy ((->) t) where" mean?  I've never seen (->) before.  ghci on :t (->) gives me a syntax error.
22:03:05 <Axman6> moconnor:  (t ->)
22:03:28 <Axman6> that one is annoyingly simple ;)
22:04:30 <dmwit> (->) is the function syntax; ((->) t) is the partially-applied function syntax.
22:05:19 <Axman6> ((->) t a) == (t -> a) right?
22:06:13 <dmwit> right
22:06:22 <Axman6> excellent
22:06:46 <Axman6> > ((->) t a) == (t -> a)
22:06:48 <lambdabot>   mueval: Prelude.read: no parse
22:06:54 <Axman6> you fail lambdabot
22:08:33 <ivanm> Axman6: how is lambdabot meant to know what t and a are?
22:08:39 <ivanm> use quickcheck or something maybe
22:09:04 <Axman6> ivanm: lambdabot is _supposed_ to read minds
22:10:10 <ivanm> Axman6: they disabled that plugin after too many java, etc. programmers came in here trying to butcher haskell ;-)
22:11:00 <Axman6> public void f(x) { x = 1; x = 2;}
22:11:38 <dmwit> Axman6: It's a type, you can't use (==) on it.
22:12:00 <Axman6> i wasn't being all that serious when i tried it :)
22:12:05 <dmwit> oh, okay =)
22:12:07 <Axman6> just curious if it would actually work
22:12:22 <dmwit> > id :: ((->) a a)
22:12:23 <lambdabot>       Overlapping instances for Show (a -> a)
22:12:23 <lambdabot>        arising from a use of `s...
22:12:30 <dmwit> > (id :: ((->) a a)) 3
22:12:31 <lambdabot>   3
22:13:14 <Axman6> @src join
22:13:14 <lambdabot> join x =  x >>= id
22:13:49 <Axman6> > join [[1,2,3],[6,7,8]]
22:13:50 <lambdabot>   [1,2,3,6,7,8]
22:14:15 <Axman6> well that's quite handy
22:15:58 <humasect> @src mconcat
22:15:58 <lambdabot> Source not found. I am sorry.
22:16:34 <humasect> > concat [[1,2,3],[6,7,8]]
22:16:35 <lambdabot>   [1,2,3,6,7,8]
22:16:49 <solrize> :t id
22:16:50 <lambdabot> forall a. a -> a
22:17:05 <solrize> :t (>>=)
22:17:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:17:25 <solrize> :t join
22:17:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:17:46 <humasect> [[1,2,3],[4,5,6]] >>= \x-> [x,x+1]
22:17:52 <humasect> > [[1,2,3],[4,5,6]] >>= \x-> [x,x+1]
22:17:53 <lambdabot>       No instance for (Num [t])
22:17:53 <lambdabot>        arising from the literal `1' at <inter...
22:18:15 <humasect> > [[1,2,3],[4,5,6]] >>= \x-> [x]
22:18:17 <lambdabot>   [[1,2,3],[4,5,6]]
22:18:54 <dmwit> > [[1..3], [4..6]] >>= id >>= \x -> [x, x+1]
22:18:56 <lambdabot>   [1,2,2,3,3,4,4,5,5,6,6,7]
22:19:11 <solrize> aha, cute.  x >>= id pulls the internal lists from x and then lets the list bind operator stick them together
22:19:20 <dmwit> solrize: yeah
22:19:26 <dmwit> solrize: It's easier to see this way:
22:19:37 <dmwit> x >>= id === concatMap id === concat . map id === concat
22:19:53 <humasect> [[1,2,3],[4,5,6]] >>= fmap (++)
22:20:11 <humasect> (oops)
22:20:32 <dmwit> humasect: That will have a [[Int] -> [Int]] return type... I think.
22:20:40 <dmwit> :t [[1]] >>= fmap (++)
22:20:41 <lambdabot> forall a. (Num [a]) => [[a] -> [a]]
22:20:48 <humasect> aha
22:20:58 <dmwit> Probably not what you wanted. =)
22:21:37 <humasect> yeah=)
22:23:55 <moconnor> Axman6: I finally got it
22:24:01 <moconnor> Axman6: thanks
22:24:13 <Axman6> f.t?
22:24:16 <Axman6> or something
22:25:16 <Axman6> :t ((f .) . g)
22:25:18 <lambdabot>     Ambiguous type variable `b' in the constraints:
22:25:18 <lambdabot>       `SimpleReflect.FromExpr b'
22:25:18 <lambdabot>         arising from a use of `g' at <interactive>:1:9
22:25:27 <Axman6> :t ((f .) . g) 1 2
22:25:28 <lambdabot>     Ambiguous type variable `b' in the constraints:
22:25:28 <lambdabot>       `SimpleReflect.FromExpr b'
22:25:28 <lambdabot>         arising from a use of `g' at <interactive>:1:9
22:25:31 <Axman6> -_-
22:25:36 <humasect> @unpl ((f .) . g)
22:25:37 <lambdabot> (\ d i -> f (g d i))
22:26:01 <Axman6> i'd much rather use f $ g there :\
22:26:16 <Axman6> i don't get why anyone would use ((f .) . g)
22:26:28 <humasect> i haven't seen it in use ^_^
22:26:30 <Axman6> @unpl f $ g xy
22:26:30 <lambdabot> (f (g xy))
22:26:37 <Axman6> @pl f $ g xy
22:26:37 <lambdabot> f (g xy)
22:26:49 <Axman6> @pl f $ g x y
22:26:50 <lambdabot> f (g x y)
22:26:53 <Axman6> @unpl f $ g x y
22:26:53 <lambdabot> (f (g x y))
22:26:59 <humasect> @pl x (y (z (w .)))
22:26:59 <lambdabot> x (y (z (w .)))
22:27:07 <humasect> @unpl x (y (z (w .)))
22:27:07 <lambdabot> x (y (z (\ a d -> w (a d))))
22:27:17 <polymorf> wtf
22:28:52 <humasect> > (concat.flip.map) [1,2,3,4] $ \x-> [x,x+1]
22:28:54 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[b1]'
22:29:11 <humasect> silly .'s
22:29:48 <waynemokane> dons: are you still on?
22:32:43 <dons> waynemokane: barely.
22:33:43 <bos> wow, someone has ordered two early pregnancy tests through the RWH preorder link for Amazon.
22:33:55 <bos> and a bottle of intimate moisturiser.
22:34:00 <bos> RWH: get your fuck on!
22:34:14 <Axman6> haha
22:35:14 <dmwit> Wow, they let you see what people order through the sponsor links?
22:35:23 <dmwit> Sounds like a bit of a privacy issue, doesn't it?
22:36:03 <bos> i don't know *who* ordered them.
22:36:27 <bos> knowing that someone in the USA thinks they might be pregnant doesn't narrow the field all that much.
22:36:36 <waynemokane> dons: oops, sorry.. was afk
22:36:40 <dmwit> true =)
22:36:46 <waynemokane> dons: wondered if you could gander at my use of Text.JSON and let me know if it's sensible
22:37:02 <waynemokane> dons: I feel that I'm using it very kludging-ly
22:37:09 <waynemokane> dons: I can always paste and you can let me know later
22:37:13 <Axman6> ah, but how many people would order RWH AND think they're pregnant?
22:37:17 <Axman6> i'm guessing about 5
22:37:27 * bos is currently shrinking the 287GB Vista partition on the new laptop down to a svelte 55GB
22:38:08 * ddarius only has 60GB total
22:38:41 <Axman6> i remember back in the day when allan said i could help beta test it. that was well over a year ago :\
22:38:52 <Axman6> whoops, wrong chan
22:38:55 <humasect> i feel for the situation,ddarius , i am 80gb (minus 30gb from ipod)
22:39:31 <ddarius> humasect: I don't really have any problems even dual booting Windows XP and Linux.
22:39:41 <dons> bos, i hope they asked for separate shipping with RWH and pregnancy tests.
22:39:57 <ddarius> dons: Hopefully.
22:40:00 <ivanm> bos: surely you can shrink it down even further than that?
22:40:05 <ivanm> say, right down to 0? :p
22:40:09 <micahcowan> dons, don't worry about the separate shipping test; just pray they aren't used simultaneously. ;)
22:40:15 <humasect> ddarius: hd space is overrated =) although i never have more than 1-3gb free often, i could use a windows part again. (mac)
22:40:25 <micahcowan> ...or mixed up...
22:40:33 <ivanm> dons: well, I hope they're willing to wait a while for those pregnancy tests if they're shipping together...
22:40:35 <micahcowan> OTOH, I suppose that would result in an additional sale for you...
22:40:40 <Axman6> dons: did you hear ivanm and i both ordered our copies of RWH yesterday?
22:40:50 <dons> "how is babby formed? how RWH start shipping?"
22:41:01 <dons> Axman6: so i hear! aussie aussie!
22:41:06 <micahcowan> ivanm, hm, by then they may not need the test anymore, eh?
22:41:08 <ivanm> oi! oi!
22:41:13 <ivanm> micahcowan: exactly!
22:41:21 <Axman6> aussie! oi!
22:41:27 <dons> aussie! oi!
22:41:40 <dons> :)
22:41:40 <Axman6> aussie! aussie! aussie!
22:41:47 <dons> oi! oi! oi!
22:41:49 <dons> ok. done.
22:41:52 <dejones> dons: This should be interesting... I'm compiling GHC HEAD to link in a shared C++ library for parallel profiling.  Let's see how many build errors show up!
22:41:55 <Axman6> go team
22:42:10 <dons> dejones: scary
22:42:21 <dons> Axman6: its one of those things that once you start, you can't stop till its done.
22:42:25 <Axman6> dons: i haven't heard back from benl yet :\ but, it is a saturday, and floriade's on, and the weather's great...
22:42:32 <dons> yeah.
22:42:34 <Axman6> exactly
22:42:44 <dejones> dons: lol, yea, especially since I have no experience with linking precompiled shared libraries.  ;)
22:43:18 <ddarius> It's not like your computer is going to explode.
22:43:26 <humasect> view patterns and record updates will change a lot of this project's code, where are the nightlies ?
22:43:31 <dejones> ddarius: More afraid of my brain exploding.  :P
22:44:39 <Axman6> more important question is: where is the 6.10 :O
22:44:43 <adu> well
22:44:58 <adu> I think I have another version of 'only' ready for release
22:45:09 <dejones> Axman6: Today, SimonM said a 2-3 more weeks before 6.10.
22:45:17 <Axman6> naww
22:45:33 <dejones> adu: You've got Verizon fiber home service, how do you like it?
22:45:36 <dejones> Super fast?
22:46:01 <adu> dejones: its nice, and fast (when I'm close to the AirPort)
22:46:12 <waynemokane> dons: anyway if you get a chance, http://hpaste.org/10536  ... if you don't feel like looking at it right now, it's cool, I'll try again another day
22:47:00 <dejones> Axman6: <Saul_> When is 6.10 coming out?
22:47:00 <dejones> <Beelse-YARR> I'm very surprised that there's no free ssh client by now actually
22:47:00 <dejones> <JaffaCake> Saul_: 2-3 weeks
22:47:14 <dejones> from #ghc today.
22:47:24 <Axman6> pitty
22:47:31 <humasect> release candidate can count ~
22:47:32 <Axman6> i keps hearing it's be this week :\
22:47:36 <dejones> adu: When you're close to the airport?  Fios is mobile?
22:47:44 <humasect> Axman6: well, the page does say sept 19.
22:47:50 <dejones> Axman6: I think ICFP is causing some delay...?
22:48:26 <Axman6> dejones: guesing he means apple airport
22:48:30 <adu> dejones: no, we've got an airport hooked up to the fios router,
22:48:32 <Axman6> and, sure, maybe?
22:48:47 <adu> dejones: yes, IEEE 802.11
22:49:32 <adu> dejones: fast land-line only does so much when 90% of air traffic is error correction...
22:50:03 <Axman6> but humasect, it's sept. 20 :(
22:50:06 <adu> anyways, who wants to know the new feature in 'only'?
22:50:24 <Axman6> what's only?
22:50:40 <humasect> Axman6: yep~ ^_^
22:52:12 <adu> Axman6: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/only
22:52:18 <lambdabot> Title: HackageDB: only-0.0.4.0
22:52:49 <Axman6> adu: like grep?
22:52:54 <adu> Axman6: yes
22:52:57 <Axman6> excellent
22:53:25 <adu> Axman6: but the NEW feature is now you can search _between_ regexes, like /begin/:/end/
22:53:46 <Axman6> ah, very nice. good for html?
22:54:14 <adu> Axman6: good question, not now, maybe a later version will work with html
22:54:32 <adu> Axman6: I have a plan to abstract the "split" mechanism, so it will split recursively
22:55:01 <adu> Axman6: and I have an indexing scheme in mind, so you can refer to things by section numbers
22:55:01 <Axman6> i mean, could you not search for say /<div id="something">/:/<\/div>/?
22:55:24 <adu> Axman6: so 1.2.3 would refer to the 3rd element of the 2nd element of the 1st element in HTML mode (which doesn't exist now)
22:55:32 <adu> Axman6: sure
22:56:09 <adu> Axman6: that might only work in word mode
22:56:21 <adu> I'll upload the newst version in a sec
23:00:33 <adu> done
23:01:56 <adu> Axman6: the general algorithm is that for each match of /begin/, find the nearest match of /end/ after that and print all lines/words between them
23:06:09 <adu> Axman6: for html, you might want to use (only -l "@<div id...>@:@</div>@") because I haven't implemented escapes yet...
23:06:31 <Axman6> adu: i think something that would be useful (and probably quite hard to implement..) would be comething like /begin/:{/begin1/:/end1/}:/end/ where begin1 would be something like <[^/].*?>, so it would finc matching pairs.
23:06:49 <Axman6> but, that's just interesting, rather than a feature request :P
23:07:29 <adu> i'm not sure i understand...
23:07:37 <adu> what do the {...} mean?
23:08:00 <Axman6> well, it might be a list of things to match inside the begin and end part.
23:08:05 <L3v1> Hi all.
23:08:10 <adu> Axman6: oic
23:08:35 <adu> Axman6: that seems like a job for xpath
23:08:58 <adu> Axman6: I haven't thought about incorporating xpath, but its a good idea
23:09:13 <Axman6> so it you have <div> <p> ...<div> </div> </p> </div> it would match the second div because the other pairs haven't been closed by the time it gets to the first </div>
23:09:19 <Axman6> yeah, it would be interesting :)
23:09:23 <adu> Axman6: my 'only' goal was to implement grep, head, tail, and cut all together...
23:09:25 <dejones> adu: ahh, Apple airport.
23:09:59 <L3v1> i have some questions in `random' file access.
23:11:24 <L3v1> it is needed to read image file in `frame', so i wrote:
23:12:03 <L3v1> getPics :: Config -> FilePath -> IO [Picture]
23:13:01 <L3v1> when calls this, i dont really understand how to use the lazy feature.
23:13:12 <humasect> hGetContents ?
23:13:39 <L3v1> no. ByteString.hGet.
23:14:10 <humasect> *.hGetContents is often lazy
23:14:26 <humasect> (it keeps the file around, so as the string is read, the file is randomly accessed)
23:14:59 <L3v1> the 1st ver, i use hGetContents, but very slow, so i try to turn to hGet.
23:15:56 <humasect> hm ~ well that depends on many variables the rest of us may or may not know about
23:19:36 <L3v1> o.. i suppose that is because of many map, chop and transpose operates... but i have no idea how to simplify it.
23:20:35 <humasect> likely it is impossible to simplify as long as the problem stays the same. simplify the problem, perhaps =)
23:21:39 <adu> L3v1: maybe pl does :)
23:23:05 <L3v1> humasect: i will try it that way. thanks.
23:23:19 <L3v1> adu: what is the `pl' mean?
23:23:39 <humasect> @pl concat (map (\x-> f(g x)))
23:23:39 <lambdabot> join (map (f . g))
23:23:50 <adu> @pl (\x y -> x + y)
23:23:50 <lambdabot> (+)
23:24:27 <L3v1> o, pointless, ic.
23:25:07 <adu> sometimes taking all the variables out simplifies things, but not algorithmically...
23:25:44 <L3v1> i think i should change my implementation, to decrease the amount of data `pack' and `unpack's.
23:26:44 <humasect> ah, yep pack/unpack are expensive i recall
23:27:49 <TommyOnMac> morning
23:29:40 <L3v1> to easily analizes, i read file in pictures, check data and locate position in 16x16 pixels, judge to output in 4x4 pixels and printed out in 1x1 pixel...
23:30:53 <adu> L3v1: I've heard some talk about cursors and enumerators, you might check them out, I'm not sure which one would be faster in your situation...
23:35:36 <user317> is there a "forall" thats more specific, like for A or B?
23:35:56 <dmwit> What do you mean?
23:36:23 <user317> so i am playing around with GADT's and i want to make a list of a type but only include specific types that it can be
23:37:01 <dmwit> That's what type classes are for.
23:37:13 <dmwit> Well, type classes and existentials.
23:37:20 <user317> http://hpaste.org/10537
23:38:23 <user317> does that make any sense?
23:40:31 <humasect> t is not used anywhere
23:40:53 <user317> it wont compile without it
23:41:23 <user317> i think its used when i do "Foo One"  One is the argument thats t
23:41:55 <adu> user317: FooTwoOrLess :: FooLessThanThree f => [Foo f] -> Foo f
23:42:32 <adu> then
23:42:37 <adu> class FooLessThanThree f
23:42:43 <adu> instance FooLessThanThree One
23:42:46 <adu> instance FooLessThanThree Two
23:42:59 <user317> hmm
23:43:08 <dmwit> Note that this will constrain you to either lists of Ones or lists of Twos.
23:43:19 <user317> but not a mix of them?
23:43:28 <dmwit> If you want to mix Ones and Twos, you have to use existentials in combination with the type class idea, as I said above.
23:44:06 <adu> user317: if you want to mix them then you probably want another type
23:44:10 <user317> ok, i haven't looked a texistentials yet
23:44:30 <adu> like data ForFoo = OneForFoo One | TwoForFoo Two
23:44:48 <adu> then FooTwoOrLess :: [Foo ForFoo] -> Foo ForFoo
23:44:52 <user317> i see
23:45:25 <user317> but Foo ForFoo is different then Foo Two, which is kind of what i want
23:45:56 <adu> user317: then why not combine One and Two into the same datatype?
23:46:29 <dmwit> He's playing!
23:46:52 <user317> well, i dont know :).  i kind of wanted a way to constrain how the lists are built, so if you are building a list with any Two's in it its of type Foo Two
23:47:08 <user317> basically, i want to know the max in the list
23:47:09 <adu> user317: if you want Foo Two, then use Foo Two, if you want to combine them use Foo ForFoo
23:47:54 <adu> user317: if you want heterogeneous lists, then use HList or [Dynamic]
23:48:37 <user317> well, those are kind of different things
23:49:13 <user317> i would like a type for a list that represents the highest value in that list
23:49:16 <dmwit> user317: You might be able to get this effect with mere phantom types, rather than full GADTs.
23:49:30 <dmwit> You could imagine an interface like
23:49:31 <adu> user317:  what do you mean by "highest"?
23:49:53 <dmwit> appendOne :: One -> ListOfOnesOrTwos a -> ListOfOnesOrTwos a
23:50:03 <user317> well, highest is Three in this case, i mean, ghc doesn't know that, but I do
23:50:08 <dmwit> appendTwo :: Two -> ListOfOnesOrTwos a -> ListOfOnesOrTwos TWO
23:50:20 <dmwit> empty :: ListOfOnesOrTwos ONE
23:50:41 <dmwit> user317: ...dunno if that makes sense in your context or not.
23:51:05 <user317> hmm, yea, maybe
23:51:55 <user317> yea, i think i would need my own list constructor
23:53:53 <ttt--> If you download a package from hackage, is there a way to check if you have all the correct dependencies?
23:54:18 <user317> haskell rocks, data A = A B; data B = B A; compiles :)
23:54:24 <dmwit> ttt--: Run the configure step of the cabal install.
23:54:34 <adu> ttt--: see if "runhaskell Setup configure" complains :)
23:54:50 <dmwit> ttt--: Or, just "cabal install <package-name>" to download and install the dependencies for you. =)
23:55:22 <dmwit> ttt--: The cabal-install package is really easy to install, and it makes every subsequent hackage installation quite pleasant.
23:55:41 <adu> dmwit: i could never install "cabal-install"
23:55:42 <dmwit> (cabal-install even comes with a bootstrapper to download its own dependencies. =)
23:55:49 <ttt--> I installed yampa, but when i try to load an example, it gives: "Elevator.hs:44:26: parse error on input `->'
23:55:49 <ttt--> "
23:55:54 <dmwit> adu: Really?  Did you try bootstrap.sh?
23:56:02 <adu> dmwit: I don't remember
23:56:12 <adu> it was really hard and confusing, so I gave up
23:56:31 <dmwit> adu: You should try again; it's been polished a lot.  And if it's still confusing and hard, you should complain to the people in charge. =)
23:56:40 <adu> ok
23:57:48 <hackage> Uploaded to hackage: only 0.0.5.0
23:57:50 <ttt--> ok, i'll try with cabal-install, thanks
23:57:57 <user317> can cabal install update itself?
23:58:04 <dmwit> user317: Yes, I think so.
23:58:14 <dmwit> cabal upgrade
23:58:49 * dmwit runs "cabal help" and sees "cabal upload" -- neat!
23:59:06 <adu> dmwit: you try 'only' and I'll try cabal-install :)
23:59:20 <dmwit> adu: hmm
23:59:23 <dmwit> ?hackage only
23:59:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/only
23:59:25 <dmwit> What does only do?
23:59:33 <adu> dmwit: its like grep only better
23:59:46 <adu> dmwit: and written in haskell :)
23:59:53 <dmwit> Okay, I'll give it a shot.
