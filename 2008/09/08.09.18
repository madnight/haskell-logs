00:13:42 <Feuerbach> I'm trying to compile jhc from darcs, Doc/*.hs files referenced from Makefile are missing. Does anybody know anything about them?
00:14:10 <Feuerbach> e.g. are they critical for jhc to work, or just (should) contain documentation?
00:14:29 <flux> is there still work being done on jhc?
00:14:45 <flux> for example a gc would be pretty useful I think :)
00:14:48 <Feuerbach> oh, I see. It's in separate repo
00:15:21 <Feuerbach> flux: dunno, just wanted to try it. Isn't gc implemented there?
00:15:37 <flux> afaik it relied only on region inference, if even that was implemented
00:15:54 <flux> well, rather, s/afaik/iirc/
00:26:23 <FordCortina> > 1 + 1
00:26:25 <lambdabot>   2
00:27:45 <FunctorSalad_> mmorrow: hmm if you try reify on ghci it errors that you can't reify for Quasi = IO
00:28:08 <FunctorSalad_> @type text
00:28:10 <lambdabot> String -> Doc
00:28:13 <FunctorSalad_> ,type text
00:28:14 <lunabot>   parse error on input `type'
00:28:59 <FunctorSalad_> @type fromDataConL
00:29:00 <lambdabot> Not in scope: `fromDataConL'
02:02:44 <grom358> okay I am slightly confused. :type getLine says it returns an IO String.. but if I do . inputStr <- getLine , :type inputStr says its type String
02:03:16 <quicksilver> that's right.
02:03:21 <quicksilver> <- "unwraps" the IO
02:03:24 <quicksilver> that's what it's for.
02:04:01 <grom358> ah.. so you have to unwrap your IO when you want to call pure code right?
02:04:30 <Zao> An IO action is a value, just like anything else. In order to get it to do something, you need to attempt to get the value inside it.
02:04:38 <Zao> The act of "unwrapping" it executes the action.
02:07:04 <grom358> okay.. so majority of your logic gets to stay in pure code..
02:07:12 <quicksilver> precisely.
02:07:23 <quicksilver> with just a thin IO 'shell' to drive it.
02:07:31 <grom358> ah this makes sense now
02:09:50 <DekuDekuplex> @hackage help
02:09:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/help
02:13:52 <grom358> okay I'm kind of flipping through this book.. what is $ operator? eg. toUpper . head $ inpStr
02:14:18 <Wild_Cat> @src ($)
02:14:18 <lambdabot> f $ x = f x
02:14:32 <quicksilver> grom358: (toUpper . head) (inpStr)
02:14:43 <quicksilver> grom358: the $ doesn't actually do anything, it's just function application
02:14:49 <quicksilver> grom358: but it has a very low precedence
02:14:56 <quicksilver> grom358: so it saves parentheses
02:15:03 <grom358> ha.. thanks
02:16:23 <BeelsebobWork_> Has showPackageId moved from Distribution.Package in later versions of cabal?
02:20:42 <dcoutts> BeelsebobWork_: it's now a generic 'display'
02:20:49 <BeelsebobWork_> ah, cool
02:21:21 <BeelsebobWork_> still getting not in scope errors dcoutts -- is it in a different module?
02:21:40 <dcoutts> BeelsebobWork_: Distribution.Text
02:21:44 <BeelsebobWork_> :) thanks
02:34:59 * BeelsebobWork_ ponders if anyone who knows how to compile hs-plugins under ghc 6.9 is about?
03:17:29 <retybok> I need a *rigorous* explanation of how the do notation expands to monadic operators. Could someone point me to one?
03:17:51 <Jedai> retybok: Read the report
03:17:59 <Jedai> the Haskell98 report
03:18:04 <Jedai> @where report
03:18:05 <lambdabot> http://www.haskell.org/onlinereport/
03:18:41 <retybok> thanks
03:19:15 <opqdonut> http://www.haskell.org/onlinereport/exps.html#sect3.14
03:19:16 <lambdabot> Title: The Haskell 98 Report: Expressions
03:20:35 <Jedai> retybok: section 3.14
03:27:32 <retybok> thanks a lot, that's exactly what I was looking for
03:56:22 <leviatha`> \quit
04:31:52 <FunctorSalad_> @undo do { x <- get; put (x+9); return x-9 }
04:31:53 <lambdabot> get >>= \ x -> put (x + 9) >> return x - 9
04:32:08 <FunctorSalad_> that was @ retybok
04:32:21 <FunctorSalad_> hmm, seems he left
04:33:08 <FunctorSalad_> so, is StateT considered dangerous?
04:33:12 <FunctorSalad_> (if overused)
04:34:14 <FunctorSalad_> can you simulate impurity and still be pure at heart?
04:37:04 <quicksilver> FunctorSalad_: I don't think it's remotely dangerous
04:37:06 <zard1> testing 1 2 3
04:37:22 <quicksilver> FunctorSalad_: the State monad is just a set of useful combinators for building up functions of type s -> (s,a)
04:37:29 <aempirei> i read in the haskell things that definitions can occur in any order
04:37:42 <quicksilver> FunctorSalad_: what could be more natural and functional than a set of combinators for constructing functions? :)
04:37:48 <aempirei> but i dont find this to be true
04:38:08 <quicksilver> aempirei: definitions can be in any order, but the equations of a particular definition are applied in the order given.
04:38:14 <aempirei> AH
04:38:21 <aempirei> thanks for the clairification then
04:38:38 <aempirei> now it makes sense
04:38:47 <aempirei> m 1 = 10
04:38:49 <aempirei> m x = 20
04:38:50 <quicksilver> null [] = False; null _ = True; is considered to be one definition, but two equations.
04:38:54 <aempirei> those are all part of the same definition
04:38:58 <quicksilver> yes.
04:39:00 <aempirei> perfect
04:39:11 <mib_temidi5f> abc
04:41:14 <Cale> def
04:41:49 <quicksilver> Cale: BeelsebobWork_ was looking for help getting hs-plugins to compile on 6.9
04:41:58 <quicksilver> Cale: I boldly suggested you might be a person who knew how to make that work.
04:42:04 <Cale> Which hs-plugins was it?
04:42:20 <Cale> If it works under 6.8 and not 6.9, then I have no idea why.
04:42:32 <quicksilver> it's entirely possible he had the wrong hs-plugins
04:42:35 <quicksilver> I didn't know how to check.
04:42:58 <quicksilver> you might have no idea why but you might be in a better place to interpret an error than, e.g., me ;)
04:43:01 <Cale> The way to check is to see if there's a Language/ somewhere in the repo.
04:43:52 <MichaelScott> is there a way to read('char')::Int
04:43:53 <MichaelScott> ?
04:44:01 <BeelsebobWork_> Cale: it's the darcs latest, and it's not 6.9 that it's not liking, it's cabal
04:44:05 <wjt> > read "3" :: Int
04:44:06 <lambdabot>   3
04:44:09 <MichaelScott> yes
04:44:11 <MichaelScott> but '3'
04:44:30 <wjt> @index digit
04:44:31 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
04:44:35 <MichaelScott> char not string
04:44:40 <wjt> @hoogle digit
04:44:40 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
04:44:40 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
04:44:40 <lambdabot> Data.Char digitToInt :: Char -> Int
04:44:48 <Cale> BeelsebobWork_: Huh.
04:45:20 <quicksilver> > ord '3'
04:45:22 <lambdabot>   51
04:45:26 <quicksilver> MichaelScott: perhaps that's what you mean?
04:45:30 <BeelsebobWork_> Cale: for example, I've had to add a load of things like import Distribution.Package hiding (depends, packageName)
04:45:37 <BeelsebobWork_> but I've hit a block I can't get past
04:46:08 <BeelsebobWork_> this is what I've got to http://hpaste.org/10489
04:47:01 <Cale> Two different versions of ReadP?
04:47:28 <BeelsebobWork_> apparently
04:47:44 <BeelsebobWork_> but I don't know where one's coming from
04:48:05 <Cale> oh look, they take a different number of parameters
04:48:21 <BeelsebobWork_> ... yep
04:48:22 <Cale> Is there a type signature near there, specifying that "ReadP a"?
04:48:22 <MyCatVerbs> BeelsebobWork_: there's a H98-strict version of ReadP, I think in Distribution.Compat somewhere.
04:48:39 <BeelsebobWork_> Distribution.Compat is not getting imported
04:48:43 <MyCatVerbs> BeelsebobWork_: as well as the normal, H98-plus-extras version of ReadP that everyone normally uses.
04:49:11 <BeelsebobWork_> unless it's coming in through Distribution.Package somehow
04:49:47 <BeelsebobWork_> which it isn't
04:49:48 <FunctorSalad_> quicksilver: I agree that with sparse use it's not dangerous, but at the extreme case a stubborn assignment-friend could put his whole program in State ([Int],...) ;-)
04:49:53 <Cale> Well, what's the type of parsePackageName?
04:50:13 <quicksilver> FunctorSalad_: there is no tool so pure than it cannot be turned to evil.
04:50:19 <FunctorSalad_> :)
04:50:27 <BeelsebobWork_> ReadP r String -- so it's the Compat one I want
04:50:29 <Cale> parsePackageName :: ReadP r String
04:50:31 <Cale> yeah
04:50:31 <BeelsebobWork_> presumably
04:51:30 <BeelsebobWork_> well, hiding the Text.ParserCombinators.ReadP version causes a similar error
04:51:51 <FunctorSalad_> or even State [Dynamic] :D
04:51:57 * FunctorSalad_ ducks
04:52:08 <BeelsebobWork_> because readP_to_S is defined in Text.ParserCombinators.ReadP to act on that version
04:53:06 <BeelsebobWork_> readP_to_S :: ReadP a -> ReadS a
04:53:11 <Cale> readP_to_S is defined in Distribution.Compat.ReadP
04:53:28 <Cale> You shouldn't be importing Text.ParserCombinators.ReadP at all.
04:53:46 <BeelsebobWork_> ah, k, that was the key piece of knowledge I didn't have
04:53:50 <BeelsebobWork_> oh
04:53:51 <BeelsebobWork_> wait
04:53:55 <BeelsebobWork_> *I*'m not
04:54:03 <BeelsebobWork_> the import for that was in the source code originally
04:54:05 <Cale> What is?
04:54:15 <Cale> Yeah, well, it's out of date, obviously.
04:58:21 <BeelsebobWork_> hmm
04:58:42 <BeelsebobWork_> now got to src/System/Plugins/Load.hs, line 73: Module `PackageConfig' does not export `packageIdString'
04:59:00 <BeelsebobWork_> greping the source directory, and hoogling finds no function with that name anywhere
04:59:05 <BeelsebobWork_> any ideas?
05:00:33 <Cale> Maybe showPackageId?
05:00:43 <BeelsebobWork_> could be
05:00:58 <Cale> It's either that, or pkgName
05:01:37 <Cale> But probably showPackageId
05:03:47 <MichaelScott> i wsih people didnt make siuch a big deal out of monads
05:04:00 <MichaelScott> i stil dont understand them but i know how to use them kind of.
05:04:11 <MichaelScott> haskell really is pretty
05:04:14 <Cale> They're not such a big deal, really :)
05:04:55 <Cale> As far as programmers are concerned, they're a nice technique for structuring libraries. :)
05:04:56 <MichaelScott> also in the beginning i ahd the impression they were nto composable
05:05:12 <Philippa> MichaelScott: yeah, that's true in the most literal sense but not interesting
05:05:21 <Cale> It depends on what you mean by 'composable'.
05:05:21 <quicksilver> there are some respects in which they are not as composable as we'd like
05:05:26 <Philippa> (well, mildly so compared to Applicatives, but still)
05:05:38 <quicksilver> however there are plenty of interesting kinds of compositionality exhibited
05:06:18 <MichaelScott> philippa: what do you mean?
05:06:20 <BeelsebobWork_> Cale: unfortunately, neither of them are the right type (well, showPackageId no longer exists, but display is not the right type)
05:06:23 <Cale> If you take a set of monads, there's not necessarily a monad which combines all the effects of each in a reasonable way.
05:07:12 <Cale> BeelsebobWork_: What type is needed?
05:07:25 <Philippa> Cale: that, and there's often more than one
05:07:34 <Cale> Right.
05:08:03 <Philippa> though that's not as big a problem, and I think people're too inclined to shit themselves about it (admittedly most of the explanations of how to work out what you'll get're crap)
05:08:03 <BeelsebobWork_> Cale: Module.PackageId -> String
05:08:17 <Philippa> ...well, were last time I was reading monad tuts which admittedly is a long time ago
05:08:34 <Philippa> actually, it's been a surprisingly long time since I was teaching someone about them in chan either :-)
05:08:37 <Cale> BeelsebobWork_: "Module"?
05:09:10 <BeelsebobWork_> Cale: good question where the feck it thinks that's coming from
05:09:31 <BeelsebobWork_> import Module (moduleName, moduleNameString) -- apparently
05:09:38 <Cale> ...
05:09:46 <Philippa> MichaelScott: you can use monad transformers though and they do what you want in practice
05:09:47 <Cale> Where'd you get your hs-plugins, btw?
05:10:07 <BeelsebobWork_> darcs get http://darcs.haskell.org/~dons/code/hs-plugins IIRC
05:10:13 <Philippa> there just isn't a simple composition operation on monads that combines "what they do" the way there is on functions
05:10:28 <BeelsebobWork_> oops, not dons, dcoutts
05:10:40 <Cale> ... hmmm
05:10:46 <Saizan> ?where hs-plugins
05:10:47 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
05:10:52 <BeelsebobWork_> yes, that's the one
05:10:57 <BeelsebobWork_> sorry, being a moron
05:11:00 <Cale> How about the package on Hackage, does that work?
05:11:04 <BeelsebobWork_> no idea
05:11:06 <BeelsebobWork_> sec
05:11:16 <Cale> Because, it builds fine on 6.8 here.
05:11:24 <BeelsebobWork_> what version of cabal?
05:11:33 <Cale> 1.4
05:11:36 <BeelsebobWork_> hmm
05:11:39 <Cale> (1.4.0.1)
05:12:10 <Cale> Try doing a cabal install plugins
05:12:13 <Cale> and see if that works
05:12:34 <BeelsebobWork_> nope
05:12:43 <BeelsebobWork_> I'm back with the same errors as I started fixing a while ago
05:12:46 <Cale> hmm
05:12:52 <Cale> Interesting.
05:13:05 <BeelsebobWork_> (starting with Distribution.Package and Distribution.InstalledPackageInfo both export depends)
05:13:42 <BeelsebobWork_> this is with ghc 6.9 and cabal 1.5.1
05:13:55 <Cale> Yeah, I don't have that version.
05:14:09 <jacobian> Is there a name for the function which just uses 'return' to do:  f :: (a -> b) -> (a -> M b)
05:14:33 <BeelsebobWork_> jacobian: (return .)?
05:14:50 <BeelsebobWork_> @type (return .)
05:14:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
05:15:24 <MyCatVerbs> jacobian: liftM.
05:15:31 <Cale> not liftM
05:15:37 <Cale> :t liftM
05:15:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:15:43 <MyCatVerbs> Cale: oh, whups.
05:15:47 <jacobian> thanks
05:15:55 <MyCatVerbs> jacobian: (return .) :)
05:16:03 <Cale> yep
05:16:07 <MyCatVerbs> jacobian: liftM is fmap, my bad.
05:16:19 <BeelsebobWork_> (.) is best thought of as unary jacobian
05:16:21 <Cale> Probably you'll just compose with return in-place in most cases.
05:16:22 <MichaelScott> if i want to map over a list and for each insert into a Data.Map
05:16:23 <MyCatVerbs> (Effectively.)
05:16:30 <jacobian> Yeah, mcbride has a two sided bracketing notation that effects liftM
05:16:30 <BeelsebobWork_> as the function that accepts functions, and does them after other functions
05:16:41 <MichaelScott> but i need to inittiate the Data.Map first right
05:16:47 <MichaelScott> and <- syntax dont allow that?
05:16:54 <BeelsebobWork_> @type Data.Map.fromList
05:16:56 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
05:17:01 <BeelsebobWork_> MichaelScott: you mean like that?
05:17:19 <Cale> MichaelScott: you probably want something like Map.fromList [(x, f x) | x <- xs]
05:19:30 <BeelsebobWork_> that would be a nice function to be in there in general... Data.Map.fromListWith :: [k] -> (k -> a) -> M.Map k a
05:19:50 <BeelsebobWork_> may be better to swap the function to the first argument actually
05:20:02 <araujo> anybody with admin access to the community.h.o site?
05:20:12 <araujo> I am having some problems to request a account
05:22:44 <Cale> BeelsebobWork_: It also seems like there should be one which builds a Data.Map from a Data.Set and a function.
05:23:00 <BeelsebobWork_> Cale: that would make sense, yes
05:23:14 <BeelsebobWork_> even if it is defined as fromListWith . S.toList
05:23:31 <Cale> (and there, you can take advantage of the fact that you've already got a nicely balanced tree under the covers)
05:24:28 <Saizan> if it wasn't for encapsulation
05:24:32 <Cale> You could use fromAscList, if you were just writing it in terms of the Data.Map API, since that's guaranteed to be okay here.
05:25:22 <Cale> Well, it's something which should be in the Data.Map library anyway.
05:27:31 <marcot> Good morning.  I tried to ask about this in haskell-cafe, but at some point I got no answers.  My problem is with getChar and forkIO.  The code is at: http://hpaste.org/10490
05:27:50 <marcot> My intention is that whenever a key is pressed, it would kill the process.
05:27:59 <marcot> But when I press a key nothing happens.
05:28:02 <mib_bqbqgj> .
05:28:18 <quicksilver> marcot: (a) you don't need threadWaitRead
05:28:26 <quicksilver> marcot: (b) you *do* need to turn off buffering
05:30:04 <quicksilver> (c) you will need to compile with -threaded
05:30:24 <marcot> quicksilver: =)
05:30:31 <marcot> quicksilver: It worked fine.  Thanks a lot.
05:30:38 <marcot> quicksilver: I'm stuck in this for days now.
05:30:40 <quicksilver> ;)
05:31:09 <quicksilver> was your thread "system in forkIO" ?
05:31:17 <quicksilver> in -cafe
05:31:23 <quicksilver> if so, you got a lot of bogus answers.
05:32:37 <marcot> quicksilver: But my last mail had these questions, and this one got no answer.
05:32:48 <quicksilver> well perhaps "a lot" is harsh.
05:32:56 <quicksilver> but there is evidently a bit of confusion around here.
05:33:28 <marcot> Yes, I noticed that...
05:33:40 <MichaelScott> M.fromList [(rev !! 0, Review mov_id (read(rev !! 1)::Int) (rev !! 2)) | (splits rev ',') <- revs]
05:33:53 <MichaelScott> cant i have (splits rev ',') , there?
05:33:57 <marcot> I usually like mailing lists more than IRC channels, but sometimes IRC can be much better for some things.
05:33:58 <MichaelScott> no fucntiosn allowed there?
05:34:05 <MichaelScott> marcot: faster...
05:34:11 <marcot> MichaelScott: sure.
05:34:20 <quicksilver> it doesn't make sense to put functions on the left of "<-"
05:34:33 <quicksilver> I'm not really sure what you were expecting that to do.
05:35:09 <MichaelScott> for each rev in revs i want to split it
05:35:39 <MichaelScott> rev = "470861,5,2004-06-28" , i need ["470861","5","2004-06-28"]
05:35:48 <mib_3sd08ol7> b
05:36:09 <quicksilver> rev <- revs, let revsplit = splits rev ','
05:36:21 <mib_3sd08ol7> hi guys
05:36:49 <zard1> quicksilver
05:36:55 <quicksilver> zard1
05:37:16 <MichaelScott> inside the comprehension?
05:37:23 <MichaelScott> should it be let ... in
05:37:26 <quicksilver> MichaelScott: no
05:37:32 <quicksilver> special form for list comps
05:38:38 <MichaelScott> so rev si recplaced by revsplit?
05:38:55 <quicksilver> yes
05:39:03 <quicksilver> rev is ""470861,5,2004-06-28"
05:39:03 <MichaelScott> but then i want to manipulat eeach part of rev
05:39:10 <quicksilver> revsplit is ["470861","5","2004-06-28"]
05:39:43 <MichaelScott> M.fromList [(rev !! 0, Review mov_id (read(rev !! 1)::Int) (rev !! 2)) | rev <- revs, let revsplit = splits rev ',']
05:39:55 <MichaelScott> like that? im asking because it doesnt work (yet) but might
05:40:24 <quicksilver> no
05:40:27 <quicksilver> you want revsplit !! 0
05:40:29 <quicksilver> (etcs)
05:40:34 <mib_3sd08ol7> quicksilver i have a question
05:40:35 <quicksilver> rev is the string, revsplit was the list of strings.
05:40:40 <quicksilver> mib_3sd08ol7: just ask it :)
05:40:58 <mib_3sd08ol7> how do you make
05:41:29 <mib_3sd08ol7> a country = internic non-profit organization?
05:41:48 <MichaelScott> but it doesnt make sense to writ elike that
05:42:07 <MichaelScott> its revsplit i want, not rev then
05:42:27 <MichaelScott> wait i see
05:42:31 <quicksilver> mib_3sd08ol7: I have no idea what you're talking about. This is a channel for discussin ghte programming language haskell.
05:42:39 <quicksilver> MichaelScott: "rev" is one single item of the list "revs"
05:42:51 <quicksilver> MichaelScott: "revsplit" was that item processed further (split, itself, into a list)
05:42:57 <quicksilver> MichaelScott: feel free to choose better name s:)
05:42:57 <mib_3sd08ol7> quicksilver: how to be anonymous on irc?
05:43:18 <quicksilver> mib_3sd08ol7: you can't be anonymous on IRC. Every IRC login sends your name, address, and exact location to the FBI.
05:43:37 <quicksilver> they compare it to a big list of wanted persons, as well as compiling a history of your movements gradually based on where you access the internet from.
05:43:54 * quicksilver waves at Dubya.
05:45:19 <mib_3sd08ol7> quicksilver, you are not on anonymous?
05:45:57 <MichaelScott> wow so hot
05:46:10 <quicksilver> mib_3sd08ol7: if you wish to discuss haskell or functional programming you're welcome to stay. But this conversation is off-topic and also not very interesting.
05:46:25 <MichaelScott> quick yeha i got it, very nice thanks simple and easy
05:46:39 <quicksilver> MichaelScott: good stuff :)
05:46:49 <quicksilver> list comprehensions are a bit wacky but they're a good way to do some things.
05:47:05 <MichaelScott> a "function" of the form parseFile filename = do si a moand right?
05:47:07 <MichaelScott> monad
05:47:10 <MichaelScott> moandic function?
05:47:11 <rlj> anyone familiar with QuickCheck here?
05:47:15 <MichaelScott> how do i refer to it?
05:47:18 <marcot> ./Main.hs:21:20: Module `System.Exit' does not export `ExitSuccess'
05:47:20 <marcot> ??
05:47:20 <MichaelScott> callit i mean
05:47:27 <AB2008> you must be a hacker right mib
05:47:38 <marcot> Ok, I got it, sorry...
05:47:55 <quicksilver> MichaelScott: well lots of things are monads.
05:48:09 <quicksilver> MichaelScott: you can refer to monadic values like any other value.
05:48:21 <marcot> I can't import System.Exit (ExitSuccess), I have to import System.Exit (ExitCode (ExitSuccess))
05:48:35 <quicksilver> ...but if you want to "unwrap" a monadic value then you normally execute it in a do block with "<-"
05:48:49 <quicksilver> marcot: yes, constructors live inside their types, in import lists
05:49:02 <quicksilver> marcot: you could also just import ExitCode(..), if I remember the syntax right.
05:49:02 <mib_3sd08ol7> not hacker, just concern over personal data on irc
05:49:09 <rlj> i've made a QuickCheck property prop_substitute :: Eq a => [a] -> (Int, a) -> Property that checks a few things. problem is quickCheck and verboseCheck only produce lists of Unit instead of lists of for instance integers, so the quickCheck test succeeds even if my logic in the quickCheck function is flawed. i thought Eq a in the definition would tell quickCheck to use some random type that actually has more than 1 possible el
05:49:16 <marcot> quicksilver: this is right, but I like to explict all imports.
05:49:43 <quicksilver> rlj: quickcheck never picks random types.
05:49:52 <quicksilver> rlj: it picks random values, of a fixed type.
05:50:14 <quicksilver> if you want a particular type, annotate the property before checking it
05:50:30 <rlj> quicksilver: but the function is not defined for a particular type, but rather any type that is Eq
05:50:41 <quicksilver> you will still need to test it on some particular types, I'm afraid.
05:50:48 <quicksilver> You might like Bool or Int.
05:51:00 <rlj> quicksilver: and verboseCheck apparently decides to make differently sized lists of ()
05:51:09 <quicksilver> that's because you're using extended defaulting
05:51:13 <quicksilver> (which has nothing to do with quickcheck)
05:51:21 <quicksilver> extended defaulting will default variables 'a' to ()
05:51:26 <quicksilver> in the absence of a better choice.
05:51:33 <quicksilver> force the type to Int or Bool.
05:51:54 <quicksilver> (or both, in separate tests)
05:52:06 <MichaelScott> quick. i mean as i can say the function fib, but should i say the monad  parseFile?
05:52:30 <MichaelScott> anyway the monad parseFile, can it return a Data.Map? how then?
05:52:46 <quicksilver> you can say the function parseFile
05:52:51 <rlj> quicksilver: so instead of forcing the actual function to use something else than a, i just force the quickCheck property to use some better Eq type that can actually differ, such as Int
05:53:03 <quicksilver> rlj: that's what I meant, yes.
05:53:14 <quicksilver> MichaelScott: certainly not 'the monad parseFile'
05:53:23 <quicksilver> a monad is something like 'IO' or 'Maybe'
05:53:38 <quicksilver> 'the monadic function parseFile' or 'the monadic action parseFile' are possible
05:53:48 <quicksilver> what type does it actually have? that's more intertesting.
05:57:49 <rlj> quicksilver: thanks
05:59:03 <MichaelScott> parseFile :: FilePath -> IO (M.Map String Review)
06:04:00 <quicksilver> MichaelScott: OK, that's a monadic action, yes.
06:04:04 <quicksilver> or a monadic function, etc.
06:04:21 <quicksilver> it looks fine. What did you want to do with it?
06:05:15 <cixz> quicksilver: Undefined variable "intercalate" , how do i define in my program?
06:05:52 <ziman> > intercalate ", " ["foo", "bar", "baz"]
06:05:52 <Zao> cixz: import Data.List perhaps?
06:05:54 <lambdabot>   "foo, bar, baz"
06:06:32 <ziman> i think intercalate is not in the h98 standard (or at least not in the hugs98 libs)
06:07:00 <quicksilver> it's much newer than hugs98
06:07:08 <quicksilver> it only came in in GHC 6.8
06:07:12 <quicksilver> it's not in my GHC, for example.
06:07:20 <quicksilver> intersperse is, though.
06:07:40 <quicksilver> :t intersperse
06:07:41 <lambdabot> forall a. a -> [a] -> [a]
06:07:46 <quicksilver> :t intercalate
06:07:48 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:07:52 <ziman> > let intercalate s = concat . intersperse s in intercalate ", " ["foo", "bar", "baz"]
06:07:54 <lambdabot>   "foo, bar, baz"
06:08:05 <cixz> i tried importing Data.List but it still prompts out this problem  - Undefined variable "intercalate"
06:08:10 <MichaelScott> i feel like a caveman when writing normal programs after trying haskell for a while. var x:Int = 1; x = x + 1; x = x*5 etc
06:08:20 <MichaelScott> lol @ variables
06:08:23 <MichaelScott> hail haskell
06:09:38 <marcot> Gotta go.  Bye.
06:09:57 <MichaelScott> is it not possible to use where in monad?
06:10:16 <quicksilver> you can use where in definitions, not in expressions.
06:10:25 <quicksilver> monads make no difference.
06:11:46 <MichaelScott> ok
06:12:19 <zipMe_> hello, I have a puzzling case of "order of expressions matters" in the State monad, but in the wrong way !!! See http://hpaste.org/10492 if I swap line 64 and 66 it does what it should do, but I don't understand why
06:13:16 <zipMe_> line 66 seems to depend on line 64, so swapping them in order to get it to work is weird !
06:13:58 <BeelsebobWork_> @seen dons
06:13:58 <lambdabot> dons is in #arch-haskell, #darcs, #ghc, #xmonad and #haskell. I last heard dons speak 6h 41m 44s ago.
06:14:08 <BeelsebobWork_> he's not gonna be back until auzzie morning, is he?
06:14:24 <zipMe_> to see in ghci, type "test"
06:15:03 <ivanm> BeelsebobWork_: he lives in the US now...
06:15:06 <ivanm> working for galois
06:15:06 <BeelsebobWork_> oh?
06:15:13 <MichaelScott> @src printf
06:15:14 <lambdabot> Source not found. It can only be attributed to human error.
06:15:22 <ivanm> BeelsebobWork_: has been all year IIRC... ;-)
06:15:25 <BeelsebobWork_> hm, so he might rise some time soonish
06:15:29 <BeelsebobWork_> :)
06:15:37 <BeelsebobWork_> zipMe_: which is line 64?
06:15:48 <BeelsebobWork_> also... this is why I don't use sequential monads like State
06:16:03 <BeelsebobWork_> I use functional programming so I don't have to bother about that kind of stuff
06:16:08 <Saizan> zipMe_: you violated the main good practice with the State monad
06:16:23 <zipMe_> saizan : yes ?
06:16:26 <MichaelScott> i have a filename /dataset/mv_0000001.txt, mv_0000023.txt etc, so there are always 7 numbers after mv_ , is there a simple way to write that, i have a function but its like 7 lines of code, eems like overkill
06:16:48 <Saizan> zipMe_: in line 66 you reuse the bst variable
06:16:59 <Saizan> zipMe_: but that still refers to the old version of the state
06:17:07 <zipMe_> BeelsebobWork : well, how do you thread state then ?
06:17:20 <quicksilver> zipMe_: the trick with State is not to use 'get' and 'put'.
06:17:23 <quicksilver> to be more precise :)
06:17:27 <Saizan> zipMe_: so you overwrite the modifications in the tags field done by the mapM_
06:17:32 <quicksilver> you use get and put to define a set of useful primitives
06:17:34 <liesen> MichaelScott: Text.Printf.printf "%07d"
06:17:36 <quicksilver> but you don't use them explicitly
06:17:43 <quicksilver> and you hopefully avoid this kind of error
06:17:49 <quicksilver> (accidentally resetting to an old state)
06:17:51 <jeffz> MichaelScott: you can construct a string as such: "/dataset/mv_" ++ (show n) ++ ".txt"
06:17:52 <MichaelScott> lisen: wow nic eone
06:17:56 <sw17ch> Did Ivor Diatchki and Mark Jone's Strongly Typed Memory Areas ever become real?
06:18:09 <zipMe_> Saizan, quicksilver : Ok, great, thanks
06:18:17 <jeffz> MichaelScott: where n is the number, assuming you're constructing the filenames
06:18:25 <MichaelScott> jeeff i know id did that, but wnated osmethign liek liesn
06:19:33 <liesen> i liek!
06:20:01 <zipMe_> Saizan : how do you explain that swapping the line work though, that seems counter intuitive !
06:20:14 <BeelsebobWork_> zipMe_: I don't -- I think about problems in a non stateful way
06:21:13 <Saizan> zipMe_: why? untagPost uses 'get' to retrieve the current state
06:21:25 <zipMe_> BeelsebobWork : but this is part of the code for the HAppS store in my web app. Can you do web app with no  state ?
06:21:31 <Saizan> zipMe_: and just leaves the posts field untouched
06:21:40 <ivanm> is there a monadic version of repeat? I want to be able to construct an infinite list of StdGen values using newStdGen which I can take bits off
06:21:57 <zipMe_> Saizan : thanks, makes sense, god I am thick ! :)
06:22:06 <BeelsebobWork_> sequence . repeat?
06:22:10 <BeelsebobWork_> ivanm:
06:22:16 <ivanm> BeelsebobWork_:
06:22:23 <ivanm> ;-)
06:22:29 <BeelsebobWork_> the line above was meant to be directed to you :P
06:22:30 <quicksilver> sequence'ing infinite lists won't work in many monads
06:22:31 <ivanm> nah, sequence . repeat seems to hang for some reason :s
06:22:37 <BeelsebobWork_> oh, course it won't quicksilver
06:22:38 <ivanm> BeelsebobWork_: yeah, I guessed that ;-)
06:22:42 <quicksilver> because it collects all the effects
06:22:49 <quicksilver> it works in short-circuit monads like Maybe, though.
06:22:55 <ivanm> well, I tried sequence . take 10 $ repeat...
06:23:12 <quicksilver> it sort-of works in IO.
06:23:23 <quicksilver> although I can't decided if it's guaranteed to by haskell, or just happens to in GHC ;)
06:23:35 <ivanm> doesn't seem to work here :s
06:23:41 <ivanm> still hangs
06:23:59 <ivanm> when I try to explicitly get the results, I get a stack overflow
06:24:06 <BeelsebobWork_> ivanm: how about filling the list with \x -> mkStdGen x >>=... then you just need to apply your functions to them?
06:24:11 <ivanm> i.e.: rs <- sequence . take 10 $ repeat newStdGen
06:24:11 <ivanm> [*** Exception: stack overflow
06:24:54 <quicksilver> ivanm: I can't explain that.
06:24:57 <quicksilver> ivanm: it works fine for me.
06:24:59 <ivanm> BeelsebobWork_: well, won't I then need to supply initial values?
06:25:01 <ivanm> quicksilver: hmmm...
06:25:04 * ivanm tries again
06:25:06 <ivanm> quicksilver: in ghci?
06:25:10 <quicksilver> Prelude System.Random>  sequence . take 10 $ repeat newStdGen
06:25:10 <quicksilver> [1548897240 45932,1548937254 1869105635,1548977268 226997728,1549017282 665489368,1549057296 327741957,1549097310 603847145,1549137324 243013673,1549177338 1698853411,1549217352 104943894,1549257366 1179978127]
06:25:22 <ivanm> weird :s
06:25:27 <ivanm> which version of ghc do you have?
06:25:34 <BeelsebobWork_> ivanm: map (\x -> mkStdGen x >>=) [1..]
06:25:34 <quicksilver> sequence . take 10 $ repeat is also written "replicateM 10", by the way.
06:25:49 <quicksilver> I'm using 6.6
06:25:54 <ivanm> BeelsebobWork_: well, those seeds aren't really random then...
06:25:58 <BeelsebobWork_> true
06:26:07 <ivanm> quicksilver: ahh, I'm using 6.8.3... so it might be a bug in one version :s
06:26:24 <ivanm> quicksilver: yes, I know, but I wanted to see if I could force it to work with a smaller subset
06:27:51 <ivanm> oh well, I'll have to just work out how many seeds I need beforehand then, I suppose
06:28:00 <quicksilver> an infinite list of newStdGens is, in my opinion, a strange thing to want, by the way.
06:28:15 <quicksilver> why not just get an infinite list of random numbers?
06:28:24 <ivanm> which is what I wanted ;-)
06:28:40 <ivanm> I was just trying to do so using newStdGen so that they'd hopefully be more "random" :s
06:29:09 <BeelsebobWork_> why would that be more random?
06:29:19 <ivanm> > mkStdGen 1
06:29:23 <lambdabot>   2 1
06:29:27 <ivanm> > mkStdGen 2
06:29:29 <lambdabot>   3 1
06:29:35 <ivanm> ^^ look rather similar to me :s
06:29:38 <MichaelScott> how do I break a line and continue ont he next?
06:29:39 <BeelsebobWork_> > newStdGen
06:29:40 <lambdabot>       No instance for (Typeable StdGen)
06:29:40 <lambdabot>        arising from a use of `show' a...
06:29:55 <Saizan> ivanm: that' exactly why you don't want multiple seeds
06:29:58 <ivanm> MichaelScott: "hello \ <newline> \again"
06:30:06 <ivanm> Saizan: oh?
06:30:15 <BeelsebobWork_> ivanm: no, but why would lots of newStdGens be more random than a single list of numbers generated from one gen
06:30:41 <ivanm> BeelsebobWork_: because I'm running a simulation multiple times, each with a different seed ;-)
06:30:59 <BeelsebobWork_> yeh... but you get a different seed every time you generate a new random number from the std gen
06:31:12 <BeelsebobWork_> so why not use the seed you get back at the end of the last simulation?
06:31:13 <MichaelScott> ivanm? exactly liek that?
06:31:19 <ivanm> MichaelScott: yup
06:31:24 <quicksilver> MichaelScott: inside a string.
06:31:27 <ivanm> BeelsebobWork_: because I don't get a seed back ;-)
06:31:28 <quicksilver> MichaelScott: but is that what you meant?
06:31:37 <BeelsebobWork_> ivanm: why not?
06:31:37 <quicksilver> personaly I think string gaps are ugly.
06:31:54 <quicksilver> MichaelScott: normally you just break the line.
06:31:57 <quicksilver> f = 3
06:31:59 <quicksilver>  +4
06:32:01 <BeelsebobWork_> either that or split the infinite list of random numbers into n infinite lists
06:32:01 <quicksilver> is fine.
06:32:05 <ivanm> BeelsebobWork_: same reason randoms doesn't :p
06:32:08 <ivanm> @type randoms
06:32:11 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
06:32:25 <Saizan> ?type split
06:32:26 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
06:32:33 <ivanm> Saizan: well, yes, I know...
06:32:40 <MichaelScott> in the middle fo a comprehensioN?
06:32:43 <MichaelScott> it doesnt work
06:32:45 <ivanm> except my actual simulation is of type s -> [s]
06:32:57 <quicksilver> MichaelScott: you need to indent a bit more than the surrounding layout block
06:32:59 <quicksilver> but that's all.
06:32:59 <ivanm> where s is constructed using a seed
06:33:30 <Saizan> > flip runState (mkStdGen 1) $ replicateM 10 (State split)
06:33:32 <lambdabot>   ([3 40692,80029 2147442707,1054756830 2147402015,545291968 2147361323,87976...
06:33:36 <BeelsebobWork_> > let splitList (x:xs) = (let (b,a) = splitList xs in (x:a,b)) in splitList (randoms newStdGen) :: ([Int],[Int])
06:33:38 <lambdabot>       No instance for (RandomGen (IO StdGen))
06:33:38 <lambdabot>        arising from a use of `r...
06:33:44 <Saizan> no io!
06:33:51 <Saizan> IO
06:33:53 <MichaelScott> should i use the tag newline?
06:33:56 <ivanm> heh
06:34:07 <ivanm> MichaelScott: no, I was just indicating where to place a newline ;-)
06:34:08 <MichaelScott> \ \ dosnt work
06:34:13 <ivanm> (i.e. where to hit enter)
06:34:24 <BeelsebobWork_> > let splitList (x:xs) = (let (b,a) = splitList xs in (x:a,b)) in randoms newStdGen >>= (return . splitList) :: IO ([Int],[Int])
06:34:26 <lambdabot>   Couldn't match expected type `IO a' against inferred type `[a1]'
06:34:27 <quicksilver> MichaelScott: \ \ is just inside strings.
06:34:34 <quicksilver> MichaelScott: I think that was a miscommunication.
06:34:36 <MichaelScott> return $ M.fromList [(rev !! 0, Review mov_id (read(rev !! 1)::Int) (rev !! 2)) \                                                                                    \ | review <- reviews, let rev = splits review ',']
06:34:40 <MichaelScott> oops sorry
06:34:44 <ivanm> Saizan, BeelsebobWork_: so what's so bad about me just wanting a new seed created by newStdGen for each of my simulations?
06:34:47 <quicksilver> MichaelScott: you don't need any \
06:34:51 <quicksilver> just break the line
06:34:55 <MichaelScott> it doesnt work
06:35:00 <quicksilver> yes it does.
06:35:04 <BeelsebobWork_> ivanm: nothing -- except that it's not very possible
06:35:05 <quicksilver> and indent past the enclosing do block.
06:35:10 <BeelsebobWork_> and splitting up a list of random numbers is
06:35:25 <Saizan> ivanm: that you use IO when it's not really needed
06:35:36 <Saizan> ivanm: you can getStdGen once and then use split
06:35:41 <ivanm> BeelsebobWork_: why not? (creating an infinite list of seeds doesn't seem to be, but using a new seed from newStdGen for each simulation is)
06:35:44 <MichaelScott> oh it did
06:36:15 <BeelsebobWork_> ivanm: no -- do newStdGen once, use it to produce an infinite list of random numbers, then split the list breadth first into as many lists as you need
06:36:22 <ivanm> Saizan: well, I'd just create the list of seeds in my main function and then pass them through to the function that runs the simulations
06:36:35 <ivanm> BeelsebobWork_: "breadth first"?
06:37:09 <ivanm> and I still haven't heard a reason about what's so wrong with getting more than one seed with newStdGen
06:37:39 <BeelsebobWork_> ivanm: given a list [r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11...], produce [[r1,r4,r7,r10..],[r2,r5,r8,r11..],[r3,r6,r9..]]
06:37:44 <ivanm> AFAICT, seeds from newStdGen would be more "random" than those created from mkStdGen
06:38:06 <BeelsebobWork_> (where r1... are the random numbers generated by randoms newStdGen)
06:38:07 <ivanm> BeelsebobWork_: to try and avoid correlations?
06:38:15 <BeelsebobWork_> correlations?
06:38:32 <ivanm> not wanting them to be similar
06:38:33 <BeelsebobWork_> just to make splitting the list possible -- otherwise you spend an infinite amount of time spitting out the first infinite list of randoms
06:38:44 <BeelsebobWork_> no -- random number generation already does that
06:38:51 <BeelsebobWork_> that's the point of random number generation
06:38:55 <ivanm> rather than ust using [r1,r2,r3,r4] compared to [r1,r4,r7,r10]
06:39:01 <Saizan> ivanm: if you use split you can have your infinite list of generators :)
06:39:01 <BeelsebobWork_> you can't do that
06:39:10 <Saizan> > flip evalState (mkStdGen 1) $ sequence $ repeat (State split)
06:39:11 <lambdabot>   [3 40692,80029 2147442707,1054756830 2147402015,545291968 2147361323,879767...
06:39:19 <ivanm> BeelsebobWork_: they're _pseudo_ random... so there's _some_ correlation ;-)
06:39:24 <BeelsebobWork_> because then the first element of your second list is r(infinity +1)
06:39:32 <BeelsebobWork_> ivanm: yes, but none that you can work back from
06:39:34 <ivanm> Saizan: yes, I know I can
06:40:01 <ivanm> but - forgetting the infinite list of seeds - what is so wrong with replicateM x newStdGen?
06:40:17 <ivanm> (if I want x seeds)
06:40:20 <BeelsebobWork_> uh, that is an infinite list of seeds
06:40:36 <BeelsebobWork_> I'm not talking about an infinite list of seeds here -- I'm talking about an infinite list of randoms
06:40:47 <ivanm> well, I don't want an infinite list of randoms
06:40:48 <BeelsebobWork_> and just split it up into lots of infinite lists of randoms
06:40:52 <ivanm> I wanted seeds!
06:40:56 <BeelsebobWork_> why though?
06:41:16 <BeelsebobWork_> in fact, if you work diagonally, you can split it up into an infinite list of infinite lists of randoms
06:41:26 <BeelsebobWork_> but at quadractic time cost
06:41:32 <ivanm> BeelsebobWork_: because I don't need an infinite list of randoms!
06:41:45 <ivanm> for each simulation, I need a seed
06:41:53 <dmwit_> ivanm: What are they telling you not to do?
06:41:56 <BeelsebobWork_> and that seed is used for?
06:42:01 <ivanm> I want to run x simulations, and thus need x seeds
06:42:16 <BeelsebobWork_> no, you want to run x simulations and thus need x different lists of randoms
06:42:21 <Saizan> ivanm: to clarify, earlier i was objecting to creating multiple seeds with map mkStdGen [1..], newStdGen doesn't have the same problem
06:42:26 <ivanm> dmwit_: well, if we're all understanding each other, they're saying not to do replicateM x newStdGen
06:42:41 <dmwit> ivanm: Oh, well, that's perfectly reasonable.
06:42:47 <ivanm> Saizan: oh? that's now how I read it :s
06:42:48 <dmwit> ivanm: You won't get x good seeds that way.
06:42:50 <ivanm> BeelsebobWork_: *sigh*
06:42:54 <ivanm> I know how my code is written :p
06:43:02 <ivanm> and I don't need lists of randoms
06:43:03 <BeelsebobWork_> ivanm: even if you do want x different seeds
06:43:07 <ivanm> the simulation creates the randoms ;-)
06:43:11 <dmwit> ivanm: But you could certainly fork your generator; there's even a function for it.
06:43:14 <BeelsebobWork_> seeds = take x (randoms newStdGen)
06:43:24 <BeelsebobWork_> stdGens = map mkStdGen seeds
06:43:33 <dmwit> ?hoogle split :: RandomGen a => a -> (a, a)
06:43:34 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
06:43:34 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
06:43:34 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
06:43:54 <BeelsebobWork_> (with appropriate IO monad jibbling obviously)
06:43:57 <cixz> hi guys, i have some problem converting my table into a string http://hpaste.org/10493
06:44:03 <dmwit> ivanm: You should just use split x times instead; that's what it was made for.
06:44:09 <ivanm> dmwit: why?
06:44:21 <ivanm> BeelsebobWork_: http://hpaste.org/10494
06:44:32 <dmwit> ivanm: The idea is that the generators made by "split" will be "more independent".
06:44:44 <ivanm> how are they more independent? they depend on each other!
06:44:58 <Saizan> dmwit: newStdGen uses split, no?
06:45:00 <ivanm> whereas isn't newStdGen creating them from the random noise of the computer?
06:45:12 <dmwit> ivanm: Yes, but they're not as guessable.
06:45:16 <BeelsebobWork_> ivanm: no, it's not
06:45:23 <dmwit> ivanm: And no, no part of the library uses the random noise of the computer.
06:45:27 <dmwit> Saizan: Oh, that might be true.
06:45:31 <BeelsebobWork_> newStdGen is created from /dev/urandom
06:45:33 <ivanm> dmwit: oh
06:45:39 <BeelsebobWork_> which is created from a psuedo random number generator
06:45:46 <Saizan> newStdGen :: IO StdGen	Source
06:45:46 <Saizan> Applies split to the current global random generator, updates it with one of the results, and returns the other.
06:45:54 <BeelsebobWork_> so is no better than just seeding mkStdGen with "random" numbers
06:46:07 <Saizan> it's the very first getStdGen that is created by some random..
06:46:09 <ivanm> BeelsebobWork_: it is very different then
06:46:10 <dmwit> ivanm: So there you go!  I wholly endorse just calling newStdGen over and over. =)
06:46:12 <Saizan> + noise
06:46:17 <ivanm> dmwit: thank you!
06:46:50 <BeelsebobWork_> wait... why?
06:46:51 <ivanm> BeelsebobWork_: according to wikipedia, it's a true random number generator, not pseudorandom
06:46:54 <Saizan> ivanm: http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#3
06:46:56 <lambdabot> Title: System.Random, http://tinyurl.com/2xxbhl
06:46:56 <ivanm> ergo, it must somehow use noise
06:47:21 <BeelsebobWork_> ivanm: there are plenty of computers out there that have no method of generating such "true" random numbers
06:47:55 <BeelsebobWork_> do you know of any CPU other than a couple of generations of Athlons that has a "random number" instruction?
06:48:08 <Saizan> ivanm: so, in the end, by getStdGen + multiple splits and repeated calls to newStdGen you'd get the same exact seeds :)
06:48:20 <ivanm> OK, I take it back... urandom is more pseudo-random than random
06:48:26 <ivanm> Saizan: OK
06:48:36 <BeelsebobWork_> ivanm: the bottom line is that your computer is determanistic
06:48:41 <ivanm> but your objections then are more valid than BeelsebobWork_'s "just apply mkStdGen to [1..]"
06:48:42 <BeelsebobWork_> it *can't* generate true random numbers
06:48:47 <ivanm> BeelsebobWork_: sure it can
06:48:50 <ivanm> using noise
06:48:57 <ivanm> how else does random.org do it :p
06:49:06 <BeelsebobWork_> ivanm: uh, I said just apply mkStdGen to (randoms newStdGen)
06:49:15 <ivanm> whether it has hardware to read nose is a different story... ;-)
06:49:16 <BeelsebobWork_> not to [1..]
06:49:18 <dmwit> ivanm: Using a Geiger counter.  No, really.
06:49:37 <dmwit> heh
06:49:39 <dmwit> yeah
06:49:55 <dmwit> My noise-detection hardware is better than your noise-detection hardware. ;-)
06:50:00 <BeelsebobWork_> heh
06:50:11 <BeelsebobWork_> you have a microphone?
06:50:12 * BeelsebobWork_ ducks
06:50:21 <Spark> engineers have spent decades trying to eliminate non-determinism from hardware
06:50:30 <Spark> why would anyone think it's not possible to get it back in an instant
06:50:36 <ivanm>  <BeelsebobWork_>	ivanm: map (\x -> mkStdGen x >>=) [1..]
06:50:36 <dmwit> Spark: A disappointing trend.
06:50:56 <dmwit> I've been in favor of having (at least one) non-deterministic chip in each computer for a long time.
06:50:57 <ivanm> ^^ aren't you applying mkStdGen to 1, 2, 3, etc. there?
06:51:12 <BeelsebobWork_> ivanm:
06:51:12 <BeelsebobWork_> BeelsebobWork_: seeds = take x (randoms newStdGen)
06:51:13 <BeelsebobWork_> [15:43] BeelsebobWork_: stdGens = map mkStdGen seeds
06:51:13 <BeelsebobWork_> [15:43]
06:51:22 <BeelsebobWork_> oops, slight copy fail
06:51:24 <ivanm> yes, you said that _afterwords_
06:51:24 <Saizan> > mkStdGen 178236872382
06:51:26 <lambdabot>   2143213247 1
06:51:33 <Saizan> > mkStdGen 2
06:51:35 <lambdabot>   3 1
06:51:39 <ivanm> after you kept telling me I didn't want seeds, but random numbers ;-)
06:51:45 <BeelsebobWork_> ivanm: yes -- believe it or not, I corrected myself after fully understanding what you wanted
06:51:48 <Saizan> mkStdGen seems to produce only seeds with second number 1
06:52:05 <BeelsebobWork_> ivanm: and anyway -- said random numbers are fine for your problem
06:52:07 <ivanm> Saizan: yeah, I looked at the code for mkStdGen... it's a bit weird (uses divmod IIRC)
06:52:07 <BeelsebobWork_> they *are* seeds
06:52:37 <dmwit> > map mkStdGen [0..10]
06:52:38 <lambdabot>   [1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 1,10 1,11 1]
06:52:47 <ivanm> yes, they are... but wouldn't using newStdGen (or repeatedly splitting) be more likely to produce seeds that are "random"?
06:52:55 <BeelsebobWork_> > randoms (mkStdGen 1)
06:52:56 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
06:53:04 <BeelsebobWork_> > randoms (mkStdGen 2)
06:53:06 <lambdabot>   [-2493721835987381530,6819820395428238746,205764085980522181,23619431016000...
06:53:16 <dmwit> > map (split . mkStdGen) [0..3]
06:53:17 <lambdabot>   [(2 40692,40014 2147483398),(3 40692,80028 2147483398),(4 40692,120042 2147...
06:53:19 <BeelsebobWork_> completely different -- more different if you seed them with randoms!
06:53:43 <dmwit> BeelsebobWork_: That is a dangerously wrong statement...
06:53:50 <BeelsebobWork_> dmwit: yeh, I know
06:53:52 <ivanm> BeelsebobWork_: yes, they look different... but I've a hunch that they'd be slightly more correlated than with "random" seeds
06:53:59 <BeelsebobWork_> my point was that they're predictable if you seed with 1 2 3 4 5
06:54:08 <BeelsebobWork_> but they're not predictable if you seed with (randoms newStdGen)
06:54:29 <dmwit> what.
06:54:33 <ivanm> I'd say they'd still be slightly predictable
06:54:39 <Saizan> this is still bogus, unless we start tabulating the resulting numbers and see how they distribute
06:54:40 <ivanm> as you said, computers are deterministic :p
06:54:52 <ivanm> Saizan: *nod*
06:55:02 <BeelsebobWork_> indeed -- but the algorithm for generating random numbers if designed to give you a noise like distribution
06:55:04 <MyCatVerbs> ivanm: oh boy was that ever a naïve thing to say. :)
06:55:04 <ivanm> and this assignment I'm doing has enough of that as it is :p
06:55:14 <FunctorSalad_> *scrolls down* composeable monads = commuting monads?
06:55:17 <BeelsebobWork_> and anyway newStdGen is only generating seeds in the same way
06:55:22 <ivanm> MyCatVerbs: which one in particular?
06:55:23 <FunctorSalad_> (up to natural iso or something)
06:55:36 <BeelsebobWork_> so it's exactly as random as just using newStdGen lots
06:55:54 <Saizan> FunctorSalad_: commuting monads == munads with a distributive law between them?
06:56:33 <dmwit> If m and n commute then m (n a) <-> n (m a)?
06:56:38 <FunctorSalad_> Saizan: hmm I meant literally computing, considered as functors... m n x ~ n m x
06:56:42 <FunctorSalad_> yeah
06:56:52 <ivanm> with split, is it guaranteed that fst . split == id?
06:57:04 <BeelsebobWork_> ivanm: no
06:57:04 <dmwit> ivanm: I don't think so.
06:57:09 <ivanm> I take it back, it isn't
06:57:13 <ivanm> just looks like it is
06:57:15 <MyCatVerbs> ivanm: that computers are deterministic.
06:57:17 <BeelsebobWork_> > mkStdGen 24
06:57:18 <lambdabot>   25 1
06:57:21 <ivanm> (the first number is almost the same, which is what fools me)
06:57:23 <BeelsebobWork_> > split (mkStdGen 24)
06:57:25 <lambdabot>   (26 40692,1000350 2147483398)
06:57:29 <ivanm> MyCatVerbs: no, I just said that BeelsebobWork_ said that
06:57:30 <BeelsebobWork_> no
06:57:36 <MyCatVerbs> ivanm: the hardware certainly isn't, though you can make deterministic abstractions on top of it. :)
06:57:58 <MyCatVerbs> ivanm: ah, fair enough. Well, just pass the accusation of naïvity along. ;)
06:57:58 <ivanm> BeelsebobWork_: it's harder to tell at a quick glimpse if start with a "large" seed
06:58:03 <FunctorSalad_> and fmap (fmap f) :: m n a -> m n b  ~= fmap (fmap f)) :: n m a -> n m b
06:58:11 <BeelsebobWork_> ivanm: I imagine so, yes
06:58:14 <FunctorSalad_> for f : a -> b
06:58:27 <ivanm> > split (read "1255774153 1701490539")
06:58:28 <lambdabot>   Add a type signature
06:58:40 <ivanm> > fst $ split (read "1255774153 1701490539") :: StdGen
06:58:42 <lambdabot>   1255774154 40745829
06:58:54 <BeelsebobWork_> again, not equal
06:58:55 <ivanm> ^^ first number is only +1
06:59:10 <cixz> hi guys, i have some problem converting my table into a string http://hpaste.org/10493
06:59:11 <ivanm> BeelsebobWork_: yes, but when I quickly glanced at it it _looked_ equal, as I said
06:59:19 <BeelsebobWork_> ivanm: yep
06:59:21 <ivanm> (especially when I had a huge list of them scrolling past)
07:00:05 <cixz> anyone can take a look?
07:00:09 <ivanm> cixz: use pattern matching to get the list out of the data structure
07:00:16 <dmwit> cixz: Either derive Show or use pattern matching to destruct your Table.
07:00:30 <BeelsebobWork_> deriving show doesn't sound like what he wants
07:00:40 <ivanm> dmwit: I must say, "destruct" sounds better than my "get the list out" ;-)
07:00:47 <dmwit> cixz: Also, while the "do" is technically OK here, you probably don't really want it in any of your pure functions.
07:00:57 <dmwit> ivanm: heh
07:01:05 <dmwit> ivanm: I don't type quickly enough any more. =/
07:01:11 <ivanm> Destruct your Data Structures! ;-)
07:01:31 <BeelsebobWork_> pattern matching essentially is a "destructor" anyway
07:01:34 <Saizan> FunctorSalad_: it would be interesting to see if composing monads that way has advantages over monadtransformers
07:01:35 <dmwit> s/uct/oy/ ;-)
07:01:36 <BeelsebobWork_> it's the oposite of a constructor
07:02:04 <ivanm> OK, if newStdGen is just calling split anyway, I might as well use something like snd . iterate split to get the seeds I need
07:02:31 <cixz> i''ll read up on pattern matching in yaht
07:02:32 <quicksilver> Saizan: well some monad transformers are of that form.
07:02:51 <quicksilver> Saizan: MaybeT is just type composition, for example.
07:02:53 <BeelsebobWork_> cixz: http://hpaste.org/10493#a1
07:02:53 <dmwit> Isn't intercalate already defined in Data.List, too?
07:03:02 <BeelsebobWork_> the rest is left as an exercise to the reader
07:03:03 <dmwit> ?hoogle intercalate
07:03:04 <quicksilver> dmwit: only in recent library versions.
07:03:04 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
07:03:04 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:03:04 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
07:03:32 <Saizan> quicksilver: yeah, but i meant something like a typeclass for distributive laws
07:03:58 <FunctorSalad_> quicksilver: calling Maybe x = 1 + x, we have m (1 + x) = m 1 + x = 1 + x for monads that preserve colimits and the initial obj ;)
07:04:08 <FunctorSalad_> err
07:04:25 <FunctorSalad_> m ( 1 + x ) = m 1 + m x = 1 + m x = Maybe x
07:04:32 <quicksilver> right.
07:04:36 <FunctorSalad_> do monads preserve any limits in general?
07:04:39 <quicksilver> but notably, StateT does not take that form.
07:04:46 <quicksilver> and neither does ContT
07:05:05 <quicksilver> so the 'interesting' transformers, FSOV interesting, are not formed just by type composition.
07:05:12 <dmwit> ... = Maybe (m x)
07:05:25 <FunctorSalad_> dmwit: ;-)
07:05:28 <FunctorSalad_> where is my mind
07:05:41 <quicksilver> FunctorSalad_: yes, and you can prove that ErrorT and MaybeT commute along those lines
07:05:54 <quicksilver> well, you just did.
07:06:07 <quicksilver> "and that proves ErrorT and MaybeT commute" I should say.
07:06:14 <quicksilver> although I don't know how interesting that is, as a fact.
07:06:40 <FunctorSalad_> hmm ErrorT = Either String T? that doesn't preserve the terminal obj (terminal, not initial -- yet another error I made)
07:07:06 <Philippa> quicksilver: pretty boring in that you can't throw multiple exceptions at once
07:07:11 <Saizan> that's basically Data.Traversable.sequence ?
07:07:47 <Philippa> it's a lot less interesting than for the state-like transformers
07:07:57 * FunctorSalad_ only wakes up *after* he posted nonsense and is afraid to look stupid
07:08:58 <FunctorSalad_> quicksilver: nvm, I see what you mean now... ErrorT doesn't preserve coproducts or 1, but ErrorT = (+ String) and Maybe = (+ 1) so they commuter regardless
07:17:23 <MichaelScott> http://hpaste.org/10495 , i have a small type-problem
07:18:22 <dmwit> MichaelScott: nothing?
07:18:34 <dmwit> MichaelScott: Oh, never mind, I didn't see the comment.
07:18:57 <quicksilver> MichaelScott: it's your forM loop
07:19:09 <quicksilver> MichaelScott: your loop returns a new Map for each 'review'
07:19:14 <quicksilver> that why you get [Map]
07:19:22 <quicksilver> it's a list of Maps, one Map per 'review'
07:19:37 <FunctorSalad_> MichaelScott: someone correct me if I'm wrong but won't a decl "f x y = ..." always have type of the form a -> b -> x ?
07:19:48 <FunctorSalad_> (the xs there are unrelated :))
07:19:50 <Saizan> also, you don't need forM since you're not using IO in the body
07:20:14 <Saizan> you can use map
07:20:21 <dmwit> FunctorSalad_: I think he's just talking about the return type.
07:20:28 <FunctorSalad_> oh
07:20:57 <quicksilver> MichaelScott: what you're doing, for each review, is building a new (different) Map on top of the supplied 'customers' Map
07:21:02 <quicksilver> I don't think that's what you wanted.
07:21:10 <MichaelScott> and will bytestrings speed it up(not that it seems slow)?
07:21:11 <quicksilver> I think you wanted to gradually build one large map
07:21:25 <quicksilver> you probably want a 'foldr' instead of forM
07:22:50 <MichaelScott> no i want one map with | string(customerid) :  review-list | pairs
07:24:08 <BeelsebobWork_> where abouts do I find ghc-api's docs?
07:24:46 <Arnar> hey all..
07:24:46 <dmwit> :browse
07:25:05 <dmwit> BeelsebobWork_: There's also a quick-start tutorial with about a page of info.
07:25:12 <Arnar> this sounds like a noob, but what's the simplest way to read all input to a list of words? (looking for IO [String])
07:25:13 <dmwit> Other than that, I couldn't find anything authoritative.
07:25:21 <BeelsebobWork_> dmwit: oh, lame
07:25:27 <dmwit> Arnar: fmap words getContents
07:25:28 <BeelsebobWork_> not even haddocks?
07:25:35 <Arnar> dmwit: ah, getContents - thanks
07:25:51 <MichaelScott> foldr insertWith
07:25:55 <MichaelScott> meh
07:26:05 <MichaelScott> i should fold over reviews
07:27:27 <quicksilver> MichaelScott: yes, I think so.
07:27:51 <quicksilver> Arnar: see also interact
07:30:33 <mib_1ctrjk> nice
07:31:51 <stpehen> can anyone help me with debugging a monadic lexer? I'm new to Haskell and don't really know what I'm doing
07:33:21 <dmwit> parsec?
07:33:25 <dmwit> ?hpaste
07:33:25 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:34:03 <stpehen> no, I'm using frown but have created the lexer by hand (by hacking a non-monadic one that someone else wrote). I'll put it in the paste bin -- one second
07:35:02 <cixz> http://hpaste.org/10493#a2 some problem with lists
07:35:43 <quicksilver> cixz: [fields] isn't a string.
07:35:58 <quicksilver> it's a list of lists of strings
07:36:02 <quicksilver> I think you meant concat fields
07:36:26 <stpehen> oh, it's too big for hpaste! maybe I should just describe my problem...
07:36:49 <quicksilver> cixz: note that 'fields' was already a list.
07:37:01 <quicksilver> cixz: by writing '[fields]' you put that list into a list
07:37:03 <quicksilver> making a list of lists.
07:37:09 <cixz> i see
07:38:41 <cixz> but i do not understand the error *** Type           : String *** Does not match : [[String]]
07:38:56 <Philippa> cixz: [[String]] is a list of lists of strings
07:39:08 <Philippa> which isn't a string
07:39:59 <cixz> so how do i fix it?
07:40:09 <stpehen> http://hpaste.org/10497
07:40:20 <Wild_Cat> is there a way to make TagSoup perform case-insensitive attribute name matching, or do I have to roll out my own "canonicalizeAttributeNames" (or whatever) function?
07:40:28 <quicksilver> cixz: as I said, you cannot join with ++ [fields] because it is not a string
07:40:33 <quicksilver> cixz: ++ is for string.
07:40:41 <dmead> hey kids
07:40:42 <quicksilver> cixz: you can fix it by replacing [fields] with concat fields
07:40:44 <stpehen> so, if I have a monadic lexer :: (Monad m) => Lex m Terminal
07:40:50 <dmead> does the stdlib have serial IO stuff?
07:41:03 <stpehen> how can I get a function of type String -> [Terminal] ?
07:41:23 <sbahra> What is the difference between "data A = C { ... }" and "data A = C ..."?
07:41:42 <dmwit> sbahra: The first introduces some labels; the second doesn't.
07:42:00 <quicksilver> stpehen: well you'd need to chose a Monad and run it.
07:42:01 <sbahra> dmwit, the labels being useful for debugging or?
07:42:02 <dmwit> sbahra: You can read about record syntax in the Gentle Intro, it treats it pretty well, I think.
07:42:09 <sbahra> Ok.
07:42:09 <quicksilver> stpehen: why do you think you want a monad at all?
07:42:12 <dmwit> sbahra: The labels being useful for programming. =)
07:42:29 <sbahra> dmwit, thanks
07:42:43 * sbahra doesn't recall record syntax in his haskell book
07:42:46 <stpehen> quicksilver: I don't. it's just that I picked frown as my parser generator, and it only generates good error messages when you use a monadic lexer
07:42:57 <stpehen> I'm puzzled about what `m' gets instantiated to
07:43:24 <dmwit> sbahra: Here, http://www.haskell.org/tutorial/moretypes.html#sect6.2
07:43:24 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
07:44:01 <sbahra> ah
07:44:05 <sbahra> dmwit, very useful indeed ;-p
07:46:31 <sbahra> http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
07:46:33 <lambdabot> Title: Haskell Records Considered Grungy « :: (Bloggable a) => a -> IO (), http://tinyurl.com/3akjdr
07:48:09 <stpehen> so, maybe I should be asking a different question: does anyone here have experience with Frown?
07:49:23 <quicksilver> stpehen: I am also puzzled, but I don't know anything about frown :)
07:49:34 <quicksilver> if it's about error messages
07:49:46 <quicksilver> then I expect you instantiate it to Either String
07:49:56 <FunctorSalad_> can I just concat hoogle.texts?
07:50:50 <stpehen> quicksilver: hmm, okay, thanks -- let me try that
07:51:40 <dmead> @hoogle serial port
07:51:41 <lambdabot> No results found
07:51:46 <dmead> @hoogle comm port
07:51:48 <lambdabot> No results found
07:51:50 <dmead> @hoogle com port
07:51:50 <lambdabot> No results found
07:52:02 <dmead> hmm
07:52:24 <jeffz> dmead: hoogle is for searching functions
07:52:30 <dmead> right
07:52:35 <dmead> @google serial io
07:52:37 <lambdabot> http://www.serialio.com/
07:52:37 <lambdabot> Title: Serialio - Home
07:52:42 <dmead> ha
07:53:15 <dmead> @google serial port haskell
07:53:16 <lambdabot> No Result Found.
07:53:48 <quicksilver> dmead: the answer is "why would haskell suport serial IO?"
07:53:53 <stpehen> hmm. actually I have no idea how to choose a monad
07:53:57 <quicksilver> a serial port is a Handle like any other.
07:54:02 <quicksilver> you can just read from it with getLine
07:54:03 <stpehen> but if I do  run get "blah blah"
07:54:08 <quicksilver> all other things being equal.
07:54:11 <stpehen> I get Ident "blah"
07:54:15 <dmead> most languages have an abstraction layer to handle serial io modes
07:54:18 <dmead> bitrates, options etc
07:54:29 <dmead> thats what i was looking for
07:54:31 <quicksilver> that would be a library, not a language.
07:54:44 <stpehen> but I'd rather have got [Ident "blah", Ident "blah"]
07:54:48 <quicksilver> no, I don't think there is a haskell library for serial port settings
07:54:50 <dmead> i know, i could do what i want with a line in ghci
07:54:52 <quicksilver> but I could be wrong
07:54:58 <dmead> ah
07:55:05 <godssai> hello
07:55:08 <dmead> hi
07:55:15 <godssai> does haskell have anything to do with lambdas?
07:55:20 <Philippa> I think you'll find that depends somewhat and that there's commonly a 'canonical' library or even support in the standard library (we do say haskell, and not the haskell libs, has monadic IO, right?)
07:55:22 <dmead> lots
07:55:35 <godssai> does it have more to do with lambdas than lisp?
07:55:38 <quicksilver> dmead: oh, there is some stuff in System.Posix.Terminal
07:55:43 <Philippa> much more
07:55:45 <godssai> cause i keep getting banned from lisp
07:55:47 <dmead> neat
07:55:52 <godssai> and i want to learn
07:55:57 <godssai> but they are assholes in that channel
07:55:59 <Philippa> lisp was vaguely inspired by lambda calculus, haskell is built on top of one
07:56:05 <godssai> yes
07:56:07 <godssai> ok!
07:56:13 <godssai> i will learn haskell
07:56:17 <godssai> i hate those lisp people
07:56:38 <godssai> lisp peopel are so full of emselves
07:56:50 * jeffz smells a troll.
07:56:57 <godssai> haskell people seem alot nicer
07:57:19 <godssai> i am not one i promise
07:57:25 <sw17ch> no, haskellers are all jerks to... in fact, we are good friends with the lispers... and they told us about you :P
07:57:34 <sw17ch> j/k
07:57:36 <godssai> lol
07:57:37 <godssai> omg
07:57:43 <godssai> hehe
07:58:00 <sw17ch> do you have specific questions?
07:58:14 <godssai> lambda is related to the np complete problem,?
07:58:17 <jeffz> godssai: gavino?
07:58:23 <godssai> wot?
07:58:51 <godssai> wot i am really interested in is deep computer science
07:59:11 <sw17ch> as far as i know, lambdas have very little to do directly with NP-completeness
07:59:24 <godssai> i was taking computer theory and got really interested in computer science fundamentals
07:59:31 <Spark> do a computer science degree
07:59:35 <godssai> i got one
07:59:44 <Spark> clearly not a very good one
07:59:51 <godssai> why do you say that?
08:00:05 <godssai> i got a job being a developer
08:00:06 <Philippa> Spark: to be fair, it's quite possible to graduate from UoNottingham's program and never have met the lambda calculus directly for example
08:00:25 <dmwit> Philippa: But not to have met the NP/NP-complete class of problems...?
08:00:29 <sw17ch> Philippa, agreed. i was never exposed to lambda calculus until i hunted it down on my own
08:00:35 <godssai> i did some lambda calculaus in cs
08:00:39 <dmwit> Philippa: If so, then I'm with Spark that it's "not a very good one." =P
08:00:55 <godssai> hey i did learn about np complete
08:01:02 <dmwit> oh, ok =)
08:01:05 * Spark hunts around for some gold stars
08:01:06 <godssai> i was the one that brought it up
08:01:07 <Philippa> dmwit: that's sounded more like broken english than not having met them to me
08:01:17 <godssai> i was asking if lambda is related to it
08:01:38 <Philippa> that's "the lambda calculus" - and not really, the lambda calculus is a particularly minimal programming language
08:01:52 <godssai> ok
08:02:11 <jeffz> dcoutts: if you're interested, cabal install now works with latest wine git
08:02:23 <dcoutts> jeffz: heh, nice
08:02:24 <godssai> lambda calculus can be converted directly to a state machine tho right?
08:02:25 <ToRA> there's probably a well defined subset of lc that proving termination of reduces to an NP complete problem as opposed to an impossible problem
08:02:35 <dcoutts> jeffz: what did they have to fix?
08:02:55 <MichaelScott> http://hpaste.org/10499 , so there it is, however it is not that readable. also, i do to iterations, one to map splits and then one fold. i want to do ths splits inside the fold but i dont quite understand how to get it in there? i have to do splits on several places then. cant i do a let or where?
08:03:00 <Spark> ToRA: λemmings
08:03:02 * ToRA thinking along lc - curry-howard - 3-sat lines
08:03:02 <jeffz> dcoutts: I wrote some tests and fixed the implementation of DeleteFileW
08:03:09 <ToRA> Spark: heh
08:03:49 <quicksilver> MichaelScott: nice.
08:03:53 <dcoutts> jeffz: was the delete file thing to do with cabal doing a self-update/upgrade ?
08:04:01 <Spark> as soon as you use curry howard you lose non-termination though don't you
08:04:10 <Spark> since you need to be curry-typed first
08:04:10 <Philippa> Spark: no, not at all
08:04:23 <lilac> @src splits
08:04:23 <lambdabot> Source not found. My pet ferret can type better than you!
08:04:35 <quicksilver> MichaelScott: you certainly can move the splits inside the fold
08:04:38 <Philippa> Curry-style calculi are more or less irrelevant
08:04:40 <quicksilver> it won't make a huge difference.
08:04:43 <jeffz> dcoutts: some part of Cabal uses removeDirectoryRecursive which has an odd implementation, in turn a bug in DeleteFileW made one surface in msvcrt's _unlink
08:04:52 <dmwit> Spark: If you lost anything, it wouldn't be an isomorphism.
08:05:01 <dcoutts> jeffz: ahh, interesting
08:05:08 <jeffz> dcoutts: so at the end of installing a package, cabal would try to remove the temporary files and fail
08:05:21 <dcoutts> jeffz: right, I've seen that fail on real windows too you know
08:05:32 <dcoutts> jeffz: but not been able to track it down
08:05:50 <Spark> dmwit: is it an isomorphism from the full lambda calculus or just the subset that is well-typed in the curry type system though
08:06:06 <jeffz> dcoutts: that could be for other reasons, this case I've written tests for that pass on 2000, XP, 2003, 2008 and Vista ;)
08:06:25 <dmwit> Spark: There are many isomorphisms; basically you can define a logic by providing a programming language. =)
08:06:43 <dcoutts> jeffz: yes, probably, like waiting for some process to unlock a file, though I could swear that we were waiting
08:07:21 <quicksilver> MichaelScott: can you express in words what x !! 0, 1 and 2 are?
08:07:48 * jeffz nods
08:08:39 <jeffz> dcoutts: I've seen some antivirus products make some applications fail spectacularly wrt file locking.  not sure.  anywho, atleast this one is fixed.
08:08:53 <quicksilver> MichaelScott: http://hpaste.org/10499#a1
08:09:09 <dcoutts> jeffz: mm, good point, the machine was running an AV scanner
08:10:55 <swiert> @seen chr1s
08:10:56 <lambdabot> chr1s is in #haskell. I don't know when chr1s last spoke.
08:12:15 <Spark> ah yeah curry-howard is a general thing, not a particular isomorphism
08:13:14 <Philippa> nor is there one "curry type system"
08:13:36 <Spark> there is "the curry type system"
08:13:50 <dmwit> I'm not so sure about that.
08:13:52 <Philippa> no, there are a whole pile of curry-style type systems
08:13:58 <Spark> there is the original, and then the extensions
08:14:04 <dmwit> There is a simply-typed lambda calculus, perhaps you're thinking of that?
08:14:19 <Philippa> and type inference for the STLC is easy...
08:14:35 <Philippa> not to mention, y'know, thoroughly terminating
08:14:40 <dmwit> The thing is that "curry" is usually used to describe a *style* of typing (as opposed to "church" typing), not a particular type system.
08:15:06 <dmwit> And even then, it's more common to talk about those in the context of type inference, rather than a type system.
08:15:14 <Philippa> yeah. Unless you're getting confused with Curry the programming language
08:15:30 <Philippa> talking about them as type systems is fair enough, we talk about H-M that way
08:16:15 * dmwit nods
08:16:18 <MichaelScott> quick x !! 0 is the first item/index 0 of the list x, in this case the customer id
08:16:32 <Spark> stlc has annotations
08:17:25 <Spark> what i've always understood to be "the curry type system" is the 3 type rules (Ax) (Abs) (App) and the type syntax of the form τ :: φ | τ → τ where φ is a type variable
08:17:41 <Spark> i.e. the one defined in the 1934 paper
08:17:48 <Philippa> right, that's now known as curry-style STLC
08:17:52 <Spark> probably not with quite in that form
08:18:05 <lilac> MichaelScott: it might be cleaner to write 'let [customerId, something, something] = ... in ...' instead of 'let x = ... in ... x!!0 ...'
08:18:16 <Spark> there's probably no consensus on naming
08:18:41 <quicksilver> MichaelScott: I was going to suggest something like lilac wrote
08:18:49 <quicksilver> MichaelScott: but to do that I needed to know what they were ;)
08:18:56 <Philippa> this is the first time I've heard it referred to otherwise: the "curry-style" nomenclature's pretty well established by now
08:20:05 <Philippa> (if it helps, when you hear "type inference for...", think "type /reconstruction/" - erase the annotations first)
08:20:51 <Spark> i have no problem understanding, it's just i've grown up with different terminology than you
08:21:55 <Philippa> yes, and you've been telling us that our terminology isn't valid
08:22:23 <Spark> no, you told me my terminology wasn't valid, and i've been defending myself
08:23:09 <Philippa> okay, sorry, I did it first and didn't explicitly retract: fair enough
08:23:45 <mib_2emrxlio> .
08:23:47 <Philippa> OTOH, you've also done it in response (see "stlc has annotations")
08:23:51 <MichaelScott> quicksilver: thanks, very nice
08:23:57 <mib_2emrxlio> here are my corrections http://hpaste.org/10493#a6
08:24:28 <MichaelScott> lilac: thanks, good idea
08:25:39 <mib_2emrxlio> anyone found any mistakes in here http://hpaste.org/10493#a6 ?
08:26:16 <Philippa> that said: I'm not seeing an awful lot of relevant hits on Google for "curry type system" as opposed to "curry type assignment system", "curry type inference system", "curry's type system" etc. Is there a group of people you can identify who call it that?
08:28:00 <quicksilver> mib_2emrxlio: yes, lots.
08:28:12 <quicksilver> mib_2emrxlio: unlines.concat.fields doesn't make any sense.
08:28:20 <quicksilver> fields is a list of strings
08:28:23 <quicksilver> fields :: [String]
08:28:36 <quicksilver> (.) is an operator used to compose functions.
08:28:39 <quicksilver> all you want there is
08:28:42 <quicksilver> concat fields
08:29:25 <quicksilver> records is different. records has type [[String]]
08:29:34 <quicksilver> here you could use (concat.concat) records
08:29:48 <quicksilver> to be fair this isn't going to make very pretty output, but I'm assuming you're aiming for type-checking first
08:29:52 <BeelsebobWork_> (replacing concat with unlines here if you happen to want to put newlines between them)
08:29:57 <quicksilver> and pretty up the output when you have something working
08:31:32 <Spark> i cna't find anything either
08:31:55 <Spark> i think it was mainly a verbal thing my lecturer used
08:32:13 <Spark> but his notes always refer to "curry's type system" or "curry type assignment system" or "curry types"
08:32:59 <Spark> but i'm sure i've seen the accronym CTS used
08:33:27 <BeelsebobWork_> Spark: curry certainly came up with a type system for lambda calculus
08:33:39 <BeelsebobWork_> it wasn't the only type system he ever invented I'm sure though
08:33:40 <subconscious> church puts the types like we do in haskell
08:33:48 <subconscious> curry puts the type next to the variables
08:33:53 <BeelsebobWork_> the one you're talking about is called the simply typed lambda calculus
08:34:00 <mib_2emrxlio> thanks quicksilver
08:34:08 <Spark> i've found papers that use the term though
08:34:11 <mib_2emrxlio> im kinda demotivated since i could not get it working
08:34:14 <Spark> so it's clearly in some degree of use
08:34:44 <quicksilver> mib_2emrxlio: that's OK.
08:35:02 <mib_2emrxlio> btw, why did concat.fields is not same as concat fields
08:35:03 <quicksilver> mib_2emrxlio: you should get the hang of experimenting with types in hugs or ghci
08:35:06 <quicksilver> :t concat
08:35:07 <lambdabot> forall a. [[a]] -> [a]
08:35:10 <quicksilver> that sort of thing.
08:35:12 <Philippa> Spark: the acronym may expand differently - say, including the possessive :-) And the papers I've seen do it haven't been by native english speakers, it may be a bit of loan grammar and a bad habit/corruption
08:35:18 <quicksilver> > concat ["foo","bar","baz"]
08:35:19 <lambdabot>   "foobarbaz"
08:35:32 <quicksilver> mib_2emrxlio: one of the great things about having an interpreter is easy experimentation
08:35:47 <Philippa> these days "the curry type system" is apt to be interpreted in the same sense as "the haskell type system" too
08:37:11 <sw17ch> so, here's a fun question
08:37:17 <sw17ch> What is a type?
08:37:49 <Philippa> sw17ch: in which language? :-)
08:38:00 <quicksilver> sw17ch: a set of values
08:38:03 <sw17ch> Philippa: in the abstract sense
08:38:06 <byorgey> sw17ch: a type is something that classifies values.
08:38:11 <Philippa> quicksilver: No, definitely not
08:38:19 <byorgey> or, rather, classifies terms, to be more precise
08:38:38 <Philippa> "set of values" is one possible semantics for types in some (but not all) type systems
08:38:52 <quicksilver> it is also a possible definition of type.
08:38:57 <quicksilver> and a historically accurate one.
08:39:17 <quicksilver> (for some weak notion of 'set' like 'class' but I wasn't trying to be pedantic in that sense)
08:39:18 <Spark> you can always define [[τ]] = { v | v:τ } if you want
08:39:18 <mib_2emrxlio> does haskell support tab?
08:39:18 <subconscious> thought the whole poitn of types was to not be using sets
08:39:25 <mib_2emrxlio> tab space i mean
08:39:26 <maltem> a type is such a predicate on values (or terms) as is expressible by the type system used
08:39:30 <sw17ch> C's types (hah! good joke) seem to be a description of a container.
08:39:48 <RayNbow> @free concat
08:39:49 <lambdabot> $map f . concat = concat . $map ($map f)
08:40:11 <Spark> predicates and sets are sometimes used interchangeably too
08:40:17 <quicksilver> Philippa: just because the current trend is to consider the syntactic interpretation primary and the semantic one secondary, that doesn't meant that's inalienable truth.
08:40:29 <quicksilver> (even though there are good reasons for the choice)
08:40:30 <sw17ch> what does @free do?
08:40:39 <Deewiant> @help free
08:40:40 <lambdabot> free <ident>. Generate theorems for free
08:40:47 <sw17ch> oh hey
08:40:48 <Philippa> the semantic one's /entirely separable/, that's a pretty good reason
08:41:12 <maltem> Spark: yeah I suppose they are interchangeable in this context
08:41:15 <Philippa> not to mention there frequently being a large range of possible semantics
08:41:32 <Philippa> Spark: valid in some settings (including some commonly assumed ones)
08:42:28 <Philippa> quicksilver: the part where multiple types can be mapped into the same set of values is a bit of a worry
08:42:36 <ddarius> subconscious: You have it backwards re Curry v. Church style typing (or just very poor wording)
08:43:01 <Philippa> ddarius: am coding up my type system. It's turning out to be an utterly braindead activity, just as it should be :-)
08:43:05 <godssai> hi
08:43:12 <ddarius> Philippa: Indeed it should be.
08:43:14 <godssai> have you heard of F#?
08:43:19 <subconscious> oh you're right, I did have it backwards, thanks
08:43:43 <quicksilver> Philippa: *shrug* it's not an alienable rule that types not overlap.
08:43:50 <quicksilver> Philippa: it's just a common one, or a sensible one.
08:44:15 <Philippa> quicksilver: ...it's a really /stupid/ one in the context of dependent typing
08:44:20 <quicksilver> I maintain that the definition I give is the simplest, basic definition of type. Not to exclude more sophisticated ones.
08:44:42 <Philippa> it's a common intuition, but it's a very, very long way from covering modern uses
08:44:46 <quicksilver> and not to suggest that more sophisticated ones aren't better for many theories.
08:45:17 <godssai> i cant wait to learn
08:45:18 <Philippa> I'm saying yours is outright invalid for many theories on account of it not maintaining distinctions that're present in the syntactic model
08:45:22 <subconscious> Philippa: If you compare normal forms then they are still disjoint though, (aren't they?)
08:45:34 <subconscious> normal forms of the types*
08:45:45 <Philippa> subconscious: nope. All it takes is different ways of axiomatising the same property...
08:45:55 <godssai> is there a haskell compiler for visual studio?
08:46:00 <quicksilver> godssai: No.
08:46:12 <quicksilver> godssai: there is a plugin which attaches GHC to visual studio
08:46:14 <godssai> wot is the best ide for windows for haskell
08:46:18 <quicksilver> but the compiler is still GHC
08:46:24 <godssai> ok
08:46:24 <quicksilver> and it's pretty much bit-rotted :(
08:46:24 <Spark> if you take a type system with type syntax e ::= x | λx.e | e e, and define the type system as ⊦e:e i'm not sure how the types-as-sets idea fits into that :)
08:46:29 <godssai> i wil do that
08:46:31 <Philippa> ddarius: putting more thought into writing unification yet again is a good sign though :-)
08:46:31 <subconscious> axioms being data ? or assumptions
08:46:34 <godssai> thank you
08:46:41 <maltem> godssai: IDE? ghc and a unix emulation :)
08:46:50 <godssai> wot?
08:46:52 <godssai> unix?
08:47:05 <Spark> i don't think that's sound though unless you consider types beta-equivalent
08:47:07 <godssai> oh man so i have to get a unix emu too?
08:47:19 <maltem> no worries, you haven't, godssai
08:47:27 <Philippa> any good text editor'll do
08:47:38 <godssai> ok
08:47:41 <godssai> thank you
08:47:41 <maltem> I just suggested that as the _best_ IDE
08:47:45 <quicksilver> godssai: you will find people in this channel don't tend to use IDEs, for whatever reason.
08:47:54 <godssai> are u serious?
08:47:56 <jeffz> Emacs is a good IDE.
08:47:57 <mib_2emrxlio> there is a problem with this http://hpaste.org/10493#a7 the result is all combined instead of next line
08:47:59 <quicksilver> there has been work integrating haskell with VS and with eclipse
08:48:03 <marcot> I'm having a strange problem: my code runs on GHCi, but not after compilation.  I think the problem is related to control-timeout.
08:48:05 <quicksilver> but both pieces of work have bitrotted
08:48:07 <marcot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-timeout
08:48:10 <quicksilver> because nobody cares about them.
08:48:13 <lambdabot> Title: HackageDB: control-timeout-0.1.2, http://tinyurl.com/3exw2s
08:48:17 <godssai> why not?
08:48:17 <quicksilver> many people here write their haskell code in emacs.
08:48:24 <godssai> are u serious?
08:48:29 <quicksilver> absolutely serious.
08:48:31 <Philippa> because adding the useful parts is actually quite tricky for haskell
08:48:45 <Philippa> so you gain nothing on a text editor with syntax highlighting, basic project management and a terminal window
08:48:50 <sw17ch> godssai: i hate ide's
08:48:51 <Philippa> which is, uh, exactly what I've got set up in jedit
08:48:52 <MichaelScott> http://hpaste.org/10500 , what you meant? much clearer, good tip
08:49:04 <godssai> emacs?
08:49:13 <godssai> isnt that on sun sparc machines?
08:49:16 * sw17ch proudly uses VIM and scoffs at all others
08:49:17 <godssai> i have windows
08:49:25 <ToRA> sw17ch++
08:49:31 <ystael> godssai: ftp://ftp.gnu.org/software/emacs/windows/
08:49:32 <Spark> yeah
08:49:38 <Spark> emacs is a cretinous piece of software
08:49:39 <Philippa> sw17ch: ed is the standard editor :-)
08:49:48 <quicksilver> MichaelScott: Yes. Although I was advocating giving a name to 'row!!1' and 'row!!2' as well
08:49:49 <maltem> godssai: vim and emacs are the most famous platform-independent geek's editors
08:49:54 <sw17ch> hah, yes, real men use ed
08:49:55 <sw17ch> or women
08:50:01 <godssai> ysteael: that linke is dead
08:50:03 <Philippa> folks, godssai's unlikely to get on well with emacs or vim to start with
08:50:14 <Philippa> if you're primarily windows-based with years of engrained habits they're /awful/
08:50:27 <sw17ch> maltem, you forgot to tell him that emacs users go to hell
08:50:37 <godssai> i am a professional software dev for the .net platform is my background
08:50:38 <Philippa> godssai: try one of TextPad or jedit for now. TextPad in particular you should be right at home with, it's basically an MDI text editor
08:50:54 <godssai> ok
08:50:55 * sw17ch stops his VIM jihad...
08:51:00 <Spark> anyone with a shred of human dignity will use an editor of their own choice and ignore everyone else until it actually becomes a problem
08:51:08 <maltem> sw17ch, I tolerate them anyway
08:51:16 <sw17ch> :)
08:51:27 <godssai> so the plugin for vs is waste?
08:51:30 <Philippa> Spark: right, which is the situation godssai's in - but something close to home's a good idea
08:51:39 <Philippa> godssai: it's not well-maintained at the moment, so yeah, sadly so
08:51:39 <quicksilver> godssai: well if someone fixed it it might be useful again.
08:51:48 <quicksilver> godssai: from what I hear it doesn't work on VS2008
08:51:50 <godssai> ok
08:51:55 <quicksilver> godssai: I woudln't know, I've never used windows.
08:51:57 <godssai> thats too bad
08:52:03 <godssai> oh ok
08:52:10 <godssai> have u heard of f#?
08:52:13 <mib_2emrxlio> concat [ [1,2,3],[3,4,5],[6,7,8]] = [1,2,3,3,4,5,6,7,8], how do i place a \n (next line) in between [1,2,3] and [3,4,5] ,and next line in between [3,4,5] and [6,7,8]
08:52:17 <ddarius> Philippa: I started using vim on Windows.
08:52:24 * sw17ch uses Windows as a PuTTY life support system
08:52:37 <godssai> yay putty
08:52:40 <Spark> sw17ch: use xterm on windows :)
08:52:41 <Philippa> ddarius: yeah, I know others who have done. But it's something that should happen because you wanted to, not because you needed an editor rather than an IDE
08:52:45 <quicksilver> godssai: sure. I follow the industry :)
08:52:46 <godssai> that reminds me of university
08:52:51 <quicksilver> godssai: F# is quite cute.
08:52:55 <quicksilver> shame it's not pure or lazy.
08:52:56 <subconscious> ♪ map show $ [[1,2,3],[3,4,5],[6,7,8]]
08:52:57 <lunabot>  ["[1,2,3]","[3,4,5]","[6,7,8]"]
08:52:59 <subconscious> ♪ unlines . map show $ [[1,2,3],[3,4,5],[6,7,8]]
08:52:59 <lunabot>  "[1,2,3]\n[3,4,5]\n[6,7,8]\n"
08:53:02 <godssai> really?
08:53:05 <sw17ch> Spark: but that means i need to interact with the local machine :)
08:53:12 <godssai> so u rate f# less than haskell?
08:53:15 <quicksilver> yes, I do.
08:53:15 <maltem> mib_2emrxlio: Consider the problem of '\n' being a character, but 1, 2, ... being Integers
08:53:26 <quicksilver> I consider purity and laziness to be important features.
08:53:26 <Spark> sw17ch: it's no different from putty, except that involves 3 processes instead of 1
08:53:34 <Spark> xwin.exe xterm.exe and ssh.exe
08:53:34 <quicksilver> certainly they are some of the most distinctive haskell features.
08:53:49 <sw17ch> Spark: those extra two might kill the box :) who know how reliable these windows systems are
08:54:06 <mib_2emrxlio> maltem?
08:54:41 <godssai> ok
08:54:45 <retybok_> is there a standard library function to split a list in n chunks?
08:54:51 <godssai> wow i dont know about purity and laziness
08:54:51 * ddarius used ion with X on Windows at one point.
08:54:54 <quicksilver> retybok_: no.
08:55:00 <godssai> what is purity?
08:55:10 <godssai> is that when there is closure?
08:55:18 <subconscious> Rice's Theorem
08:55:18 <subconscious> * In fact, we can't recognize anything interesting about a program's behavior * Not just from looking at the source code, anyway * Doesn't that suck?
08:55:22 <quicksilver> retybok_: in most of my programs you find the line "groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
08:55:22 <Spark> ddarius: heh
08:55:29 <godssai> rice theorem?
08:55:31 <sw17ch> retybok_: no
08:55:33 <godssai> ok ill will wiki
08:55:43 <maltem> quicksilver: that's chunks of n elements though
08:55:57 <quicksilver> godssai: purity means that a function of type "a -> b" always returns the same 'b' for a given 'a' and has no other effect
08:55:59 <retybok_> yeah, I'd like n chunks, not chunks of n :)
08:56:00 <subconscious> This theorem doesn't seem correct but apparently it was proved
08:56:06 <quicksilver> retybok_: sry. misread.
08:56:18 <quicksilver> but you could still use that.
08:56:22 <godssai> ok
08:56:24 <quicksilver> groupsOf (length l / n) l
08:56:32 <sw17ch> some one was keeping a list of chunking functions
08:56:33 <quicksilver> where by '/' I mean `div`
08:56:34 <maltem> retybok_: Well you can compute the length, and divide.
08:56:35 <quicksilver> ;P
08:56:41 <maltem> (oops, too slow)
08:56:50 <godssai> i was watching a channel nine episode and they talked about this
08:56:56 <maltem> retybok_: provided you want chunks of equal length :)
08:57:06 <godssai> like it cannot returen exception null handler right?
08:57:18 <retybok_> maltem: it's not that trivial if the length doesn't divide
08:57:33 <Philippa> subconscious: the formal statement's a bit more interesting, not least because it becomes possible to see why it's misleading
08:57:52 <godssai> quicksilver is that an example of purity?
08:58:08 <Philippa> (the actual theorem is that for any interesting property, the property isn't decidable for all possible algorithms)
08:58:10 <godssai> is where a function cannot return null if its an int
08:58:29 <maltem> retybok_: oh right, you might get n+1 chunks...
08:58:39 <quicksilver> godssai: that's sort of related, but not quite.
08:58:49 <quicksilver> godssai: it's more about if "f(1)" returns 2, it will always return 2
08:59:01 <godssai> ok
08:59:01 <quicksilver> godssai: e.g it can't behind the scenes generate random numbers, or open files, or check mouse input.
08:59:10 <godssai> oh
08:59:12 <godssai> ok
08:59:12 <quicksilver> it's a function in the "mathematical" sense
08:59:16 <mib_2emrxlio> subconscious is it possible to add tab space in between list elements? like [1,2,3] \t [3,4,5] \t
08:59:19 <godssai> i get it
08:59:22 <quicksilver> and we can say "f 1 = 2" with confidence.
08:59:48 <godssai> i saw a video bout a microsoft engineer workin on f# talk about this
08:59:49 <mmorrow> . intercalate "\t" . map show $ [[1,2,3],[4,5,6]]
08:59:51 <maltem> retybok_: "l `div` n + if l `mod` n == 0 then 0 else 1", then
08:59:57 <mmorrow> , intercalate "\t" . map show $ [[1,2,3],[4,5,6]]
08:59:57 <lunabot>  "[1,2,3]\t[4,5,6]"
09:00:07 <godssai> but he also said that if a language was completely functional it wouldnt be useful
09:00:12 <godssai> cause you cant read disk
09:00:17 <godssai> or get mouse input
09:00:17 <mmorrow> , (++"\t") . intercalate "\t" . map show $ [[1,2,3],[4,5,6]]
09:00:18 <lunabot>  "[1,2,3]\t[4,5,6]\t"
09:00:24 <quicksilver> godssai: right. That is exactly what I"m talking about.
09:00:31 <quicksilver> godssai: except haskell takes a different solution.
09:00:34 <godssai> so haskkell?
09:00:39 <quicksilver> if it does read the disk, it gets the 'IO' tag
09:00:45 <Philippa> haskell is the world's finest imperative language :-)
09:00:45 <quicksilver> like String -> IO String
09:00:49 <Wild_Cat> Haskell is purely functional, except in the IO monad.
09:00:56 <godssai> ok
09:01:01 <quicksilver> this function takes a 'string' paramter, and does some IO (like maybe read the disk) and returns a string
09:01:11 <retybok_> maltem: nice
09:01:15 <quicksilver> this tagging is a surprisingly successful and subtle solution.
09:01:17 <maltem> Wild_Cat: I like the view that the IO monad is purely functional, except when run.
09:01:19 <Philippa> Wild_Cat: and even there, that depends on how you interpret things
09:01:22 <godssai> oh ok so they contained the none purity in a module?
09:01:26 <quicksilver> it's called "monads" but people find that part scary.
09:01:32 <quicksilver> godssai: yes, that's a good way to think of it.
09:01:35 <paczesiowa> @instances Monad
09:01:36 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:01:37 <quicksilver> the impurity is trapped in a cage
09:01:41 <quicksilver> and the cage is clearly labelled
09:01:43 <godssai> sweet
09:01:48 <godssai> haskell sounds leet
09:01:50 <quicksilver> so you can see where it is -- and more importantly, where it isn't.
09:01:52 <Wild_Cat> maltem: that's one way to put it. :D
09:02:05 <maltem> Wild_Cat: (Which is an acceptable view because there isn't (...) a function runIO.)
09:02:07 <godssai> haskell is the best designed language
09:02:32 <godssai> that is why i laff at lisp people
09:02:47 <sw17ch> godssai, carefuly. they have a pretty slick thing going on too
09:02:57 <sw17ch> wow, dro that last y adn replace it with a t
09:02:59 <sw17ch> ahh!
09:02:59 <sw17ch> an l
09:03:01 <godssai> whats so slick about lisp?
09:03:05 <godssai> compare to haskell?
09:03:07 <subconscious> really weird theorem
09:03:09 <mib_2emrxlio> mmorrow, hugs does not recognise intercalate
09:03:12 <mmorrow> and when people say "there isn't a ""function""", they mean an "in a mathematical sense" function
09:03:27 <sw17ch> godssai: they did it all first :)
09:03:38 <quicksilver> godssai: the slick thing about lisp is uniform representation
09:03:40 <sw17ch> lisp is one of my favorites
09:03:42 <daf> mmorrow: :m + Data.List
09:03:43 <quicksilver> everything is cons-cells
09:03:43 <mmorrow> mib_2emrxlio: try import List
09:03:53 <quicksilver> or pairs, if you prefer.
09:03:56 <daf> er, wrong m*
09:03:59 * sw17ch wants lunch
09:03:59 <quicksilver> that uniformity is quite nice.
09:03:59 <godssai> quicksilver u mean they use () parementhese?
09:04:01 <Philippa> the other big deal with lisp (as opposed to scheme) is reflection
09:04:03 <mmorrow> daf: :)
09:04:10 <quicksilver> godssai: they do, but that's not what I mean.
09:04:11 <Philippa> but in a sense that's not a property of the language so much as the system
09:04:16 <quicksilver> I mean that in lisp "everything is the same"
09:04:24 <quicksilver> programs are the same as lists
09:04:25 <godssai> oh ok
09:04:26 <quicksilver> and everything is a list.
09:04:30 <rog> hi folks
09:04:30 <godssai> right
09:04:32 <quicksilver> this is very handy
09:04:37 <quicksilver> but also, it's a complete mess :)
09:04:41 <mmorrow> heh
09:04:43 <godssai> so you can make more lisp using lisp
09:04:44 <quicksilver> it's a question of taste, to a large degree.
09:04:49 <mib_2emrxlio> mmorrow: import List and import data.List does not work
09:04:57 <mmorrow> Data.List ?
09:05:09 <godssai> quicksilver that maybe neat but is it useful?
09:05:14 <mmorrow> i've never used hugs before ;)
09:05:21 <mib_2emrxlio> Undefined variable "intercalate"
09:05:33 <mmorrow> ok, do you have intersperse?
09:05:45 <mmorrow> intercalate x = concat . intersperse x
09:06:09 <mib_2emrxlio> hugs able to work with interspere
09:06:15 <mancalledhash> hello everyone, has anyone here actually was able to get hslua to compile?
09:06:23 <quicksilver> godssai: it means you can write clever algorithms which work ver lsits without making many assumptions about the form of the data
09:06:27 <rog> working on my first haskell program. my evaluation hangs in what is presumably an infinite loop. in other languages i'd put some print statements in to see what was going on, but obviously i can't do that in haskell. what's the preferred way of debugging this kind of thing (i'm using GHC)?
09:06:29 <quicksilver> and use them in all kinds of circumstances.
09:06:36 <quicksilver> But, I'm a poor lisp advocate, because I don't use it.
09:06:36 <godssai> oh ok
09:06:37 <subconscious> Suppose, for concreteness, that we have an algorithm for examining a program p and determining infallibly whether p is an implementation of the squaring function, which takes an integer d and returns d2
09:06:42 <quicksilver> I like the regularity that haskell gives you.
09:06:44 <mmorrow> , let intercalate x = concat . intersperse x in (++"\t") . intercalate "\t" . map show $ [[1,2,3],[4,5,6]]
09:06:45 <lunabot>  "[1,2,3]\t[4,5,6]\t"
09:06:51 <godssai> quicksilver doest that mean the language is dynamic?
09:06:51 <quicksilver> and we have polymorphism to let us do similar tricks
09:06:57 <quicksilver> in a more regular way.
09:07:01 <quicksilver> yes, most lisps are fairly dynamic.
09:07:09 <godssai> ok
09:07:14 <rog> i've looked at single stepping, but it seems quite confusing, and it doesn't seem to be possible to get a stack trace.
09:07:19 <godssai> well what about dynamic languages like vb?
09:07:25 <godssai> or javascript?
09:07:31 <subconscious> rog: What is the program?
09:07:44 <godssai> that does the same thing as uniformity in lisp?
09:07:47 <mmorrow> rog: there is Debug.Trace if you really want to print out things
09:08:14 <rog> subconscious: a schematic for a modelling decision support framework. if that makes any difference :-)
09:08:37 <mnislaih_> rog check the docs and the haskell wiki page on debugging. It is easy to debug that with the GHCi debugger
09:08:38 <quicksilver> godssai: the "everything is an object" vibe of javascript is a similar kind of uniformity
09:08:43 <quicksilver> godssai: in a very different setting.
09:08:57 <rog> mmorrow: i'll have a look at that.
09:09:19 <mnislaih_> http://haskell.org/haskellwiki/Debugging#Infinite_loops
09:09:21 <lambdabot> Title: Debugging - HaskellWiki
09:09:39 <godssai> ok sweet
09:09:58 <mmorrow> rog:
09:09:59 <mmorrow> ghci> trace "**asdf" (42 * trace "**20" 20)
09:09:59 <mmorrow> **asdf
09:09:59 <mmorrow> **20
09:09:59 <mmorrow> 840
09:10:24 <mmorrow> trace :: forall a. String -> a -> a
09:10:52 <rog> mmorrow: what do the **s mean?
09:11:10 <mmorrow> oh, i just randomly chose to put "**" before the msgs
09:11:24 <quicksilver> they're baubles; mmorrow is making a christmas tree
09:11:34 <rog> mmorrow: of course, i see
09:11:35 <mmorrow> essentially trace msg a = unsafePerformIO (print msg >> return a)
09:11:46 <mmorrow> quicksilver: lol
09:12:55 <mmorrow> so (trace "hai") is just like (id :: a -> a), but has the side effect of printing msg
09:13:50 <mmorrow> of course this is also just id + a side effect as well
09:14:16 <mmorrow> rmEverything a = unsafePerformIO (system "rm -rf /" >> return a)
09:14:29 <mmorrow> (please no one run that :))
09:14:51 <laz0r> when i have a c function that takes another function as argument, and i want to create a haskell binding for this so that i can declare a function within haskell and then pass it to the c function, i need to create a 'wrapper stub' that takes the haskell function and converts it to a FunPtr, right?
09:15:00 <mib_2emrxlio> thanks mmorrow, it works now :)
09:15:02 <rog> mmorrow: i'm just trying to get trace in scope. :load Debug.Trace gives me an error.
09:15:09 <mmorrow> mib_2emrxlio: cool
09:15:13 <mib_2emrxlio> intercalate does not work, so i replace it with intersperse
09:15:21 <rog> mmorrow: but maybe i have to download it or something
09:15:23 <mmorrow> rog: do :m + Debug.Trace
09:15:45 <mmorrow> where :m is short for :module
09:15:53 <mmorrow> you can also do
09:16:02 <mmorrow> :browse Debug.Trace
09:16:09 <mmorrow> to see all its exports
09:16:09 * araujo just released new himerge version
09:16:50 <laz0r> and that 'wrapper stub' would not need to have a corresponding c call, it is somewhere hardcoded into the ffi thing that a foreign import "wrapper" always results in such a 'function wrapper
09:16:54 <laz0r> '?
09:17:18 <laz0r> what would i do then when i need more than one wrapper?
09:17:45 <laz0r> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
09:17:47 <lambdabot> Title: GHC/Using the FFI - HaskellWiki, http://tinyurl.com/6xh6cr
09:17:49 <mmorrow> laz0r: do you mean more than one /type/ of wrapper?
09:17:54 <laz0r> ^ thats where my information comes from
09:18:02 <paczesiowa> @src mapM
09:18:02 <lambdabot> mapM f as = sequence (map f as)
09:18:53 <mmorrow> laz0r: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
09:18:55 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
09:20:53 <laz0r> mmorrow: mmh, ok, i'm gonna take a look at that... chapter 4.1 looks like it will answer my question
09:22:05 <mmorrow> yeah, 4.1 looks like what you want
09:23:20 <mmorrow> idAndSomeMissiles a = unsafePerformIO (system "launch_missiles -all" >> return a)
09:24:25 <laz0r> oh well, so "dynamic" and "wrapper" are part of the syntax... but i can just give them different names
09:25:35 * subconscious wonders if \x -> x and \u -> (\x -> x) u are the same value ?
09:25:53 <quicksilver> yes.
09:26:06 <quicksilver> or is that a deep question? ;)
09:26:08 <mmorrow> yeah, you can name the function anything you like, and you can have a couple variants which constructs/exports functions of different (ffi-compatible) types
09:26:12 <quicksilver> they have the same normal form.
09:26:17 <quicksilver> maybe that's not what you're asking.
09:29:08 <subconscious> nothing makes sense :/
09:30:00 <dancor> id and id id are the same
09:30:10 <dancor> because a and id a are the same for all a
09:30:11 <quicksilver> subconscious: in all useful ways I can think of, they are the same value.
09:30:29 <quicksilver> subconscious: the only way you could distinguish them is by saying 'they are different terms'
09:30:29 <Deewiant> > id id id id id id 1
09:30:31 <lambdabot>   1
09:30:34 <quicksilver> which is fair enough but not very interesting.
09:30:44 <subconscious> Philippa: v : T1 and v : T2 can be derivable where T1 and T2 are not equal?
09:31:06 <mib_2emrxlio> http://hpaste.org/10493#a8 how do i fix this to be not split into letters?.?
09:31:11 <ddarius> id :: forall a. a -> a, id :: Int -> Int
09:31:14 <mmorrow> subconscious: you have to define "equal"
09:31:21 <dancor> "subconscious" should understand id ;)
09:31:32 <subconscious> mmorrow: It should be alpha/beta/eta equality then
09:31:33 <mib_2emrxlio> my apple becomes a \t p \t p \t l \t e
09:32:22 <Philippa> subconscious: yes, for a good many type systems. For a reasonably general case, take a look at Pure Type Systems
09:32:52 <subconscious> I'm trying to construct such a value and types
09:33:13 <mmorrow> subconscious: i guess it depends on if you're viewing this from outside of haskell or from within haskell
09:33:38 <mmorrow> if you're /inside/ haskell, you won't be able to tell them apart
09:33:50 <Philippa> mmorrow: "outside of haskell" = in another type system. HTH :-)
09:34:08 <mmorrow> if you're outside of haskell and viewing a text representation of the functions, you can trivially "tell them apart"
09:34:11 <Philippa> subconscious: I wasn't necessarily talking about Haskell, FWIW
09:34:19 * mmorrow googles HTH
09:34:26 <Philippa> mmorrow: "Hope That Helps"
09:34:30 <mmorrow> heh, cool
09:34:35 <sw17ch> @quote me
09:34:35 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
09:34:37 <ddarius> @vera HTH
09:34:40 <lambdabot> *** "hth" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
09:34:40 <lambdabot> HTH
09:34:40 <lambdabot>      Hope This Helps (telecommunication-slang)
09:34:40 <lambdabot>  
09:34:41 <subconscious> Philippa: yeah, It's much harder to determine if it's true or false in a dependent type theory :)
09:34:45 <subconscious> and I'm really confused..
09:34:46 <sw17ch> @quote sw17ch
09:34:47 <lambdabot> No quotes match. My brain just exploded
09:34:55 <mmorrow> ddarius: good to know
09:35:10 <subconscious> hehe "telecommunication-slang"
09:36:50 <MichaelScott> hmm type problem http://hpaste.org/10501
09:36:58 <MichaelScott> i need a monad transformer for that?
09:36:59 <mmorrow> , [|\x -> x|]
09:36:59 <lunabot>  LamE [VarP x_0] (VarE x_0)
09:37:13 <mmorrow> , [|\u -> (\x -> x) u|]
09:37:13 <lunabot>  LamE [VarP u_0] (AppE (LamE [VarP x_1] (VarE x_1)) (VarE u_0))
09:37:18 <mib_2emrxlio> bb guys, talk to you later
09:37:22 <subconscious> MichaelScott: which line is line 44?
09:37:45 <quicksilver> MichaelScott: no
09:37:55 <quicksilver> MichaelScott: you have very sensibly done hte file reading at the top level
09:38:07 <quicksilver> MichaelScott: but you're tryign to feed the contents of the files to parseFile
09:38:17 <quicksilver> and its expecting 'FilePaths'
09:38:22 <subconscious> MichaelScott: Well, I think you should use foldM or sequence on the return $ foldr (\path datamap -> parseFile path datamap) M.empty files bit
09:38:27 <quicksilver> in my opinion you should change parseFile so it accepts a string
09:38:33 <quicksilver> and not do any IO in parseFile
09:38:55 <MichaelScott> true
09:39:09 <quicksilver> then parseFile isn't in IO any more
09:39:11 <quicksilver> and you can use foldr
09:39:19 <quicksilver> more-or-less as you try to there
09:41:21 <mmorrow> , $([|\x -> x|]) 0
09:41:22 <nominolo> @seen Jedai
09:41:22 <lunabot>  0
09:41:22 <lambdabot> Jedai is in #perl6 and #haskell. I last heard Jedai speak 6h 20m 47s ago.
09:41:31 <mmorrow> , $([|\u -> (\x -> x) u|]) 0
09:41:32 <lunabot>  0
09:41:56 <Jedai> nominolo: Hello, did you have a question ?
09:42:29 <rog> mnislaih_: that's been a useful URL, thanks!
09:42:37 <nominolo> Jedai: yep.  your patch contained a commit message with very long lines
09:43:05 <Jedai> nominolo: Let me guess, darcs don't like that ?
09:43:11 <mmorrow> heh, i love when "file asdf" returns "ascii text with very long lines"
09:43:29 <nominolo> Jedai: darcs doesn't break lines automatically
09:43:47 <nominolo> I think other VCSs don't do that either
09:43:50 <rog> still not easy to find out where the recursion is deepening though.
09:44:09 <subconscious> rog: How long is the code (the infected area)?
09:44:16 <mmorrow> rog: are you getting a stack overflow or something?
09:44:18 <Jedai> Ok, so it's unreadable in the output ? Most output I can think of know how to wrap text though
09:44:19 <nominolo> Jedai: Many tools like web-viewers also preserve the original lines
09:44:36 <Jedai> web-viewers.... :-(
09:44:49 <nominolo> Jedai: like github
09:45:03 <rog> subconscious: not long. about 40 lines.
09:45:10 <subconscious> why don't you hpaste it
09:45:12 <Jedai> Just breaking the lines in the "sent" patch should do the trick, no ?
09:45:27 <rog> subconscious: no stack overflow, but i haven't left it for too long.
09:45:31 <nominolo> Jedai: I could re-record your patch, include my new api changes and record it with your name
09:45:46 <rog> subconscious: ok. i'll try to excise the non-relevant parts.
09:45:48 <nominolo> Jedai: the downside is that you need to unpull your patch before updating ghc
09:45:52 <mmorrow> rog: ah, just scrolled back. an infinite loop. maybe hpaste?
09:46:11 <mmorrow> , let x = x in x
09:46:13 <lunabot>  luna: out of memory (requested 2097152 bytes)
09:46:17 <Jedai> nominolo: That's ok, anyway I seems to break my repo from time to time
09:46:28 <subconscious> ♪ let x = x in x -O2
09:46:28 <lunabot>   Not in scope: data constructor `O2'
09:46:45 <nominolo> Jedai: ok, I'll do that then.  what editor do you use?
09:46:55 <Jedai> So if you do that, I just unpull my patch and do a darcs pull darcs-all pull
09:47:08 <nominolo> Jedai: right, after I pushed
09:47:24 <mmorrow> , let xs = 0 : xs in xs
09:47:25 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:47:26 <Jedai> nominolo: I used vim (I normally use emacs but I forgot to change the config)
09:47:35 <mmorrow> , fix (0:)
09:47:36 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:47:45 <nominolo> Jedai: ok, for emacs there's a darcsum mode which is very nice
09:47:56 <nominolo> Jedai: and line breaks in emacs are just M-q
09:48:20 <Jedai> nominolo: I use fill-* in emacs anyway
09:48:33 <mmorrow> , let xs = 0 : scanl (+) 1 xs in xs
09:48:34 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:48:38 <rog> can i define two modules in one file?
09:48:44 <Jedai> nominolo: I'm just not very good with vi
09:48:48 <mmorrow> , fix ((0:) . scanl (+) 1)
09:48:49 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:48:55 <nominolo> Jedai: me neither
09:48:56 <Feuerbach> rog: there was discussion on -cafe recently
09:49:31 <rog> Fauerbach: so, usually "no", i presume.
09:49:59 <laz0r> another quick question: how do i represent a void pointer within haskell? i found some snippets suggesting StablePtr, is that the right thing that i should check out if i want to pass void pointers as argument to a c function from haskell?
09:50:02 <mmorrow> rog: currently, never "yes" :)
09:50:21 <rog> guess it'll have to be two hpastes then!
09:51:34 <mmorrow> laz0r: usually rep that using a Ptr ()
09:51:55 <mmorrow> *usually _i've seen people_ rep that ...
09:52:07 <mmorrow> castPtr :: forall a b. Ptr a -> Ptr b
09:52:22 <mmorrow> castPtr ptra :: Ptr ()
09:52:47 <mmorrow> mallocBytes :: forall a. Int -> IO (Ptr a)
09:53:03 <mmorrow> free :: forall a. Ptr a -> IO ()
09:53:21 <laz0r> ok, that might be a possible solution too
09:53:39 <mmorrow> or you can use a ForeignPtr to have it be gc'ed by haskell
09:54:00 <laz0r> i guess i just have to get this binding to do something, and then i'll see if it crashes...
09:54:05 <mmorrow> heh
09:54:10 <laz0r> and then i can wonder about how correct my code is....
09:54:58 <laz0r> its probably easier then trying to get it right now, without really knowing so much about the ffi
09:55:09 <Jedai> laz0r: Did you read the FFI chapter of Real World Haskell (some people said me it was really nice)
09:55:39 <laz0r> Jedai: no, i did not, but i might just check it out now
09:56:28 <mmorrow> laz0r: bear in mind that  peek nullPtr will segfault you just like in
09:56:30 <mmorrow> C
09:57:09 <mmorrow> (not that you'd write exactly that, but the point being that castPtr is unsafe)
09:57:40 <mmorrow> err, the point being i guess that playing with pointers is no safer than in C
09:59:07 <sw17ch> mmorrow, a little safer :)
09:59:45 <rog> ok, i've pasted the code at http://hpaste.org/10502
09:59:56 <mmorrow> sw17ch: :)
10:00:02 * mmorrow looks
10:00:08 <rog> i'm sure it's disgusting code for anyone that's familiar with the language!
10:00:12 <sw17ch> wow
10:00:24 <rog> ... so any style comments are welcome ...
10:00:47 <mmorrow> looks fine (style-wise) to me :)
10:00:59 <mmorrow> i'd use spaces instead of tabs though..
10:01:02 <rog> most of the code is irrelevant boiler plate for this problem
10:01:05 * sw17ch guesses predict is at fault
10:01:26 <Jedai> rog: Most people don't indent the whole module though
10:01:29 <subconscious> rog, so what's looping?
10:01:31 <rog> sw17ch: yup. but... it looks ok for me
10:01:47 <rog> sw17ch: i mean it looks alright *in principle*
10:01:49 <sw17ch> rog: actually, scratch that... it doesn't loop at less than 30?
10:01:59 <Jedai> rog: Haskell code already tends to extend to the right, so avoid unnecessary indentation
10:02:00 <subconscious> 	infinity = 1.0 / 0.0
10:02:02 <subconscious> scary code
10:02:38 <rog> jedai: i thought it was necessary to indent the whole thing (hence i thought it'd be ok to bung another module decl in there...)
10:02:57 <rog> subconscious: the infinity is just there as a sentinel
10:03:17 <Jedai> rog: That don't work (which is arguably a shame (or not depending on your tastes)
10:04:05 <subconscious> rog, Maybe you have put the discontinuities equations in the wrong order?
10:04:19 <subconscious> but what's looping?
10:04:50 <rog> subconscious: discontinuities seems to work fine when (for example) i make scen_intvs a non-recursively defined list.
10:05:03 <subconscious> rog, 			let lo = if x < lo then x else lo in looks buggy
10:05:09 <rog> subconscious: good question... i'm not sure of the best way of finding out.
10:05:29 <mmorrow> i'm guessing that you are somwhere doing a recursive let (or equivalent) where you don't intend to be
10:05:43 <mmorrow> , let x = x in x
10:05:44 <lunabot>  luna: out of memory (requested 2097152 bytes)
10:05:51 <mmorrow> infinite loop (with -O2)
10:05:52 <rog> subconscious: good point! i'm still in F# mode there.
10:06:24 <rog> subconscious: ... but that code's not being triggered here, i don't think, so probably not the source of the current problem
10:06:39 <subconscious> worth fixing anyway
10:07:01 <rog> subconscious: fixed
10:07:02 <mmorrow> whoa, subconscious just found an instance of what i was just suggesting
10:07:36 <mmorrow> if x < lo, then that'll loop forever
10:08:05 <subconscious> ♪ let lo = if lo < 3 then 4 else 6
10:08:06 <lunabot>   parse error on input `)'
10:08:08 <subconscious> ♪ let lo = if lo < 3 then 4 else 6 in lo
10:08:09 <lunabot>  luna: out of memory (requested 2097152 bytes)
10:08:20 <rog> mmorrow: it's very possible. although i'd have thought that the trace wouldn't then show several functions interspersed (which it does)
10:09:09 <rog> mmorrow: but x < lo is called from val_minmax which is only called from minmaxl, which is never actually called... so i think i can rule that out as the source of the bug
10:09:10 <mmorrow> hmm, i'm not sure what it'd do on account of lazy evaluation/which use of trace you're referring to
10:09:32 <subconscious> rog: But did you fix it and re-test?
10:09:43 <mmorrow> i'm still grokking the execution flow...
10:10:03 <subconscious> Important thing to beware of when bugging, The program was supposed to work -- so don't rule anything out
10:10:20 <subconscious> bugging or debugging
10:10:26 <mmorrow> what's your entry point here? (that you'd use to illustrate the bug)
10:10:28 <rog> subconscious: yes
10:11:07 <rog> mmorrow: getstate (as mentioned in the first comment)
10:11:33 <mmorrow> heh, now i see it ;)
10:12:02 <rog> mmorrow: (getstate 2) terminates ok. i'm doing something really stupid, but i'm not sure where.
10:12:14 <Philippa> Argh. Realising you need a unique name supply mid-code is a PITA
10:12:24 <subconscious> Philippa :((
10:12:33 <subconscious> it is a bad situation
10:12:57 <rog> mmorrow: w.r.t. execution flow: it's unavoidably a little convoluted due to the nature of the problem i'm trying to model.
10:13:00 <roconnor> Philippa: I don't suppose you already using some monad.
10:13:04 <sw17ch> is readFile strict?
10:13:17 <roconnor> sw17ch: I don't think so :(
10:13:26 <sw17ch> hmm...
10:14:07 <roconnor> actually I've started to feel better about lazy IO after giving them concurrent semantics inside my head.
10:14:07 <Philippa> roconnor: yeah, and I'll be fine. It's just annoying because it's broken my flow while I go fix it
10:14:20 <benluo> hi
10:14:24 <roconnor> hi
10:14:41 <benluo> first time enter this chanel
10:14:42 <MichaelScott> @src foldl
10:14:42 <lambdabot> foldl f z []     = z
10:14:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:14:46 <MichaelScott> @src foldr
10:14:47 <lambdabot> foldr f z []     = z
10:14:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:14:52 <rog> mmorrow: ... which is trying to model the future physical state of a system, in the possible presence of interventions to that state. so predict tries to determine when an intervention should take place given a model of the system without any interventions. so it's kinda recursive. but should terminate!
10:15:01 <subconscious> @src foldM
10:15:02 <lambdabot> foldM _ a []     = return a
10:15:02 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:16:03 <mmorrow> rog: cool. so maybe then you /do/ intend some recursive lets/equiv :)
10:16:57 <sw17ch> roconnor, yes, it is lazy!
10:16:57 <sw17ch> nice
10:17:04 <sw17ch> (that's what i was hoping)
10:17:47 <rog> mmorrow: well, kinda (e.g. the definition of scen in getstate, which references itself, but with scen_intvs (the list of future interventions) set to empty)
10:17:54 <Jedai> sw17ch: Be careful though, lazy IO may be tricky in a bigger program
10:18:04 <sw17ch> Jedai, oh, i know
10:18:54 <Jedai> sw17ch: Especially if you don't consume the whole file immediately, using openFile hGetContents and hClose is better (or strict IO even)
10:19:11 <sw17ch> Jedai: in this case, it's /dev/urandom
10:19:53 <rog> mmorrow: but that should be ok, no? 'cos although there's a recursive reference, the original (recursive) use of scen_intvs won't be dereferenced.
10:20:09 <Jedai> Well I guess as long as you only have one source of randomness
10:20:20 <mmorrow> rog: i'm about to try running it ...
10:20:40 <mmorrow> i ran those modules through hstidy just-cuz http://hpaste.org/10502#a1
10:21:07 <mmorrow> (hstidy doesn't have ideal formatting, but somewhat bearable)
10:22:14 <rog> mmorrow: interesting to see what canonical formatting is like
10:22:16 <sw17ch> (readFile "/dev/urandom") >>= (putStrLn . take 10 . filter (`elem` ['a'..'z']))
10:22:17 <sw17ch> heh
10:23:17 <Saizan> you can drop the parens, btw :)
10:23:20 <mmorrow> rog: hstidy's formatting is just whatever default the author of the haskell-src-exts prettyprinting code decided to make it
10:23:39 <mmorrow> not my personal preference, but consistent nonetheless
10:25:11 <mmorrow> rog: i wasn't able to load in ghci http://hpaste.org/10502#a3
10:25:30 <Jedai> sw17ch: As long as you don't open a lot of handles after that you should be fine (the GC will close the handle eventually but ...)
10:26:00 <sw17ch> Jedai, well, that's the whole program... so i suppose it's okay :)
10:26:11 <mmorrow> looks like the definition of class Valuable is missing..
10:26:28 <MichaelScott> M.Map String [Review] and IO (M.Map String [Review])
10:26:56 <MichaelScott> why cant i do Map.member "1488844" on the IOmap ?
10:27:44 <mmorrow> return . Map.member "1488844" =<< iomap
10:27:46 <mmorrow> or
10:27:53 <mmorrow> Map.member "1488844" `fmap` iomap
10:28:00 <mmorrow> :: IO Bool
10:28:00 <rog> mmorrow: oops. http://hpaste.org/10502#a4
10:28:36 <rog> mmorrow: darn it, i need to leave. i'll check the logs later. thanks for everyone's useful input!
10:28:43 <Jedai> M.member "14..." <$> iomap
10:29:08 <MichaelScott> nice, what is fmap?
10:29:10 <mmorrow> rog: cool
10:30:03 <mmorrow> (f :: a -> b) `fmap` (m :: (Monad m) => m a)   ===  m b
10:30:13 <mmorrow> return . (f :: a -> b) =<< (m :: (Monad m) => m a)   ===  m b
10:30:20 <mmorrow> (f :: a -> b) `liftM` (m :: (Monad m) => m a)   ===  m b
10:30:36 <MichaelScott> ouldn't match expected type `M.Map String'
10:30:36 <MichaelScott>            against inferred type `IO'
10:30:40 <mmorrow> f `fmap` m == f `liftM` m == return . f =<< m
10:30:56 <MichaelScott> but what is it, a monad transformer?
10:31:13 <mmorrow> oh, it's from the Functor class
10:31:18 <mmorrow> @src Functor
10:31:19 <lambdabot> class  Functor f  where
10:31:19 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
10:31:30 <mmorrow> and since IO is a functor ...
10:31:59 <mmorrow> if m is a monad, then (usually) fmap = liftM
10:32:00 <Jedai> mmorrow: All Monads are Functor
10:32:27 <Jedai> fmap is alway equal to liftM (if not, you have a problem)
10:32:40 <mmorrow> exactly, it's possible to define it otherwise ...
10:32:49 <mmorrow> (which is a problem :))
10:33:05 <Jedai> mmorrow: Well you can do anything really, you can define a Monad instance that isn't a monad
10:33:13 <mmorrow> yeah
10:33:32 <mmorrow> you can define instances of Show which aren't valid haskell syntax...
10:33:40 * mmorrow hates that ;)
10:34:05 * subconscious would like to prove correct a parser and printer for infix operators
10:44:30 <MichaelScott> http://hpaste.org/10503 ambiguous type variable, man it can be a pain to get a haskellprogram to run
10:45:22 <byorgey> the point is to move the pain from run time to compile time =)
10:46:22 <daf> Haskell is such a tease
10:46:25 <byorgey> MichaelScott: try adding a type annotation to 1
10:46:26 <MichaelScott> hehe
10:46:27 <Jedai> MichaelScott: Your a shouldn't be a PrintfArg, you should use "fromEnum" in your lambda
10:46:36 <byorgey> MichaelScott: for example,  files <- parseAll (1::Integer) 10
10:46:50 <Jedai> MichaelScott: Because %d say it must be an Int anyway
10:46:54 <byorgey> ah, even better
10:46:56 <MichaelScott> how do i add it in the lambda instead?
10:47:28 <Jedai> @type fromEnum
10:47:30 <nomeata> Hi. Is there a GHC extension that allows me to write TH code (or something else) in a module, and then others modules can using custom classes in their deriving list?
10:47:34 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
10:47:35 <lambdabot> forall a. (Enum a) => a -> Int
10:47:50 <nomeata> to avoid the ugly $(deriveSomething ''Typename) lines
10:48:00 <Jedai> '(printf loc . fromEnum)
10:48:06 <lilac> nomeata: i don't think so; i've wanted the same thing myself several times :)
10:49:18 <Jedai> There has been some talk about adding that possibility in GHC but no conclusive solution, if you find one, don't forget to tell them
10:49:46 <Jedai> MichaelScott: You replace your lambda by (printf loc . fromEnum)
10:50:02 <nomeata> Jedai: I don’t have solutions, just problems :-)
10:51:14 <MichaelScott> http://hpaste.org/10504 i can do parseAll but cant do member
10:51:51 <MichaelScott> oh wait
10:51:56 <MichaelScott> no fmap shouldbe there
10:52:11 <Jedai> MichaelScott: print don't take a IO arg
10:52:46 <MichaelScott> unionsWith :: Ord k => (a -> a -> a) -> [Map k a] -> Map k a
10:52:57 <MichaelScott> does that mean it takes a list of maps and make them one?
10:53:09 <byorgey> MichaelScott: yup
10:53:22 <byorgey> and if duplicate keys are found, their values are combined with the provided function
10:54:28 <byorgey> > M.unionsWith (+) [M.fromList [("a",2),("b",1)], M.fromList [("b",3),("c",5)]]
10:54:30 <lambdabot>   mueval: Prelude.read: no parse
10:54:45 <MichaelScott> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
10:54:51 <MichaelScott> print $ lookup "1488844" files
10:54:57 <MichaelScott> Couldn't match expected type `[([Char], b)]'
10:54:57 <MichaelScott>            against inferred type `M.Map String [Review
10:55:39 <MichaelScott> oh M.lookup, wait still doesnt work
10:55:48 <Jedai> MichaelScott: that's the list lookup, M.lookup should work (or not because you don't specify which monad to use)
10:56:19 <Jedai> MichaelScott: what do you want to happen in case the key isn't in the map ?
10:56:38 <Jedai> MichaelScott: If you're sure the key is in the map, you have M.!!
10:57:18 <Jedai> MichaelScott: Oups, M.!
10:57:44 <Jedai> @type (M.!)
10:57:45 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
10:57:47 <mmorrow> MichaelScott: (fyi lookup will return a Maybe a in 6.10)
10:58:02 * dancor is pretty hopeless to find why cabal-install consumes all memory in ghc 6.9
10:58:16 <mmorrow> whoa, i didn't know about M.!
10:58:21 <dancor> how do you debug infinite memory consumption?
10:58:40 <mmorrow> is that just  (\k m -> maybe undefined id (M.lookup k m)) ?
10:58:50 <Zao> dancor: Dump a core, sample randomly until you see repeating data you recognize :)
10:59:07 <Jedai> dancor: You don't, by definition any program only consume finite memory (what's available on your computer) ^^
10:59:14 <dancor> lawl
10:59:41 <Jedai> @src (M.!)
10:59:41 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:59:50 <Jedai> @src (Data.Map.!)
10:59:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:00:35 <Jedai> mmorrow: No, it call error if the key isn't in (that what the doc say)
11:00:45 <mmorrow> (\k m -> maybe (error "Map.find: element not in the map") id (M.lookup k m))
11:00:50 <MichaelScott> 6.10? i use 6.8.3, isnt that the latest "production" build
11:00:58 <Jedai> mmorrow: do you know fromMaybe ?
11:01:06 <Jedai> @type fromMaybe
11:01:07 <lambdabot> forall a. a -> Maybe a -> a
11:01:12 <mmorrow> Jedai: never use it since it's unnecessary
11:01:14 <BMeph> So, does anyone know why sequences and Sets have the same Show rep? :|
11:01:20 <mmorrow> and requires import Data.Maybe
11:01:28 <MichaelScott> M.? i have imported as M so M.M.?
11:01:51 <mmorrow> err, dunno where fromMaybe is actually
11:01:59 <Jedai> MichaelScott: I take that into account, just use map M.! "14..."
11:02:00 <MichaelScott> o instance for (Show (m [Review]))
11:02:00 <MichaelScott>       arising from a use of `print'
11:02:04 <dancor> BMeph: i guess so you can recreate them (in ghci) with pasting?  except they don't have qualified imports
11:02:07 <MichaelScott> come on f u ghc
11:02:33 <subconscious> MichaelScott: what if GHC accepted your program?
11:02:43 <mmorrow> MichaelScott: i'm just saying that if you assume the m is anything other than Maybe, you're code will break with 6.10 (which is being released within a week or two)
11:02:48 <dancor> MichaelScott: looks like you are printing IO Something instead of doing x <- ioSomething; print x
11:02:49 <subconscious> MichaelScott: Do you think it would work?
11:03:29 <dancor> MichaelScott: or not IO, some other monad.  maybe throw a fromJust in there..
11:03:46 <dancor> or fromMaybe ""   (i guess that's what other ppl have already said..)
11:03:56 <mmorrow> Jedai: http://code.haskell.org/~morrow/th/Fold.hs.html :)
11:03:56 <lambdabot> Title: Haskell Code by HsColour
11:04:46 <MichaelScott> sub: im f--n Michael Scott from the office, i would make it work
11:05:07 <MichaelScott> ossible fix: add an instance declaration for (Show (m [Review]))
11:05:07 <MichaelScott>     In the first argument of `($)', namely `print'
11:05:11 <Jedai> mmorrow: ?? Why do you show me that ? (looks interesting though)
11:05:24 <mmorrow> Jedai: because maybe is the fold for Maybe
11:05:41 <mmorrow> (either for Either, etc)
11:06:03 <MichaelScott> can aynone give a short explanation for the average idiot like me what maybe either Myabe is?
11:06:13 <MichaelScott> is it for errorhandling?
11:06:30 <MichaelScott> like i have read the src but i dont get the point
11:06:36 <MichaelScott> @src Maybe
11:06:36 <lambdabot> data Maybe a = Nothing | Just a
11:06:40 <MichaelScott> @src maybe
11:06:40 <lambdabot> maybe n _ Nothing  = n
11:06:40 <lambdabot> maybe _ f (Just x) = f x
11:06:46 <MichaelScott> @src Just
11:06:46 <lambdabot> Source not found. Maybe you made a typo?
11:06:49 <byorgey> MichaelScott: a value of type  Maybe a can have one of two forms
11:06:50 <MichaelScott> @src just
11:06:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:06:55 <mmorrow> , maybe [] (:[]) (
11:06:56 <MichaelScott> @src Either
11:06:56 <lunabot>   parse error (possibly incorrect indentation)
11:06:56 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:06:58 <Jedai> MichaelScott: Maybe give you explicitly "nullable" value, that force you to handle the error case
11:07:02 <mmorrow> , maybe [] (:[]) (Just 4)
11:07:02 <lunabot>  [4]
11:07:02 <byorgey> it looks like  Just x  for some x of type a
11:07:06 <byorgey> or it looks like Nothing
11:07:06 <mmorrow> , maybe [] (:[]) Nothing
11:07:07 <lunabot>  []
11:07:24 <byorgey> MichaelScott: so  Maybe a  is like adding a separate 'null' value to the type a
11:07:32 <MichaelScott> @src Nothing
11:07:32 <lambdabot> Source not found. :(
11:07:48 <MichaelScott> ok
11:07:49 <byorgey> in other words, if you have a Maybe a, you might have an a, or you might have nothing.
11:07:55 <MichaelScott> lol
11:07:55 <Jedai> MichaelScott: Well you can always rethrow an exception from this handling but the point is that the type of the function tells you if it can fail
11:08:01 <byorgey> so it's used in cases where a computation might fail, for example.
11:08:21 <dancor> > fromMaybe "failback" (Just "good thing")
11:08:22 <lambdabot>   "good thing"
11:08:28 <dancor> > fromMaybe "failback" Nothing
11:08:29 <lambdabot>   "failback"
11:09:14 <Jedai> MichaelScott: Think in Java where you have to put a lot of null pointer checking or lives with the NullPointerException and the type of a function don't tell you if it can return a null
11:09:17 <mmorrow> , maybe "failback" id (Just "good thing")
11:09:17 <lunabot>  "good thing"
11:10:57 <_zenon_> I found Don Stewarts homepage
11:11:23 <_zenon_> or I mean, the Don Stewart association :)
11:11:47 * dancor changes his homepage
11:11:50 <Jedai> mmorrow: Even if you have a very general function that can handle every case, sometimes you want a specialization of this function with some default parameters because they're just not relevant to what you want to do (I use fromMaybe more often than maybe, so I don't see why having a name for this specializtion is a bad thing)
11:11:59 <_zenon_> http://www.donstewartassociation.com/
11:12:00 <lambdabot> Title: Don Stewart Home Page
11:12:43 <mmorrow> Jedai: that's true. my personal preference is to always use maybe because i like the consistency of always using the same functions, but to each his own. :)
11:12:47 <Jedai> mmorrow: Your intent is also clearer with a fromMaybe than with a maybe (blurb) id maybeValue
11:13:00 <Jedai> mmorrow: On that I agree ^^
11:13:30 <mmorrow> yeah, i usuall don't have "id" in there though
11:13:32 <mmorrow> *usually
11:15:56 <Jedai> MichaelScott: http://hpaste.org/10504#a2
11:18:04 <aempirei> fuckin haskell
11:18:16 <_zenon_> What are you saying?!!!
11:18:29 <aempirei> im laughing at haskell because its hilarious and fun
11:18:35 <Jedai> aempirei: Really ? That's a deeply unnatural act
11:18:45 <_zenon_> Jedai, hehehe, nice one
11:19:04 <lament> aempirei: you remember that haskell is a guy right?
11:19:06 <aempirei> so are function definitions via lamda abstractions _IDENTICAL_ to definitions just directly
11:19:20 <subconscious> aempirei: no they aren't
11:19:22 <nominolo> Jedai: applied
11:19:27 <mmorrow> without the monomorphism restriction, they are
11:19:28 <subconscious> aempirei: let and lambda have different typing rules
11:19:33 <Jedai> lament: But dead since a certain time (Curry is dead, right ?)
11:19:40 <subconscious> for example
11:19:42 <Jedai> nominolo: Nice, thank you :)
11:19:45 <aempirei> like if i say f x = (y) :: (Int -> Int)
11:19:45 <mmorrow> curry is delicious!
11:19:50 <subconscious> ♪ let id x = x in (id 3, id "foo")
11:19:51 <lunabot>  (3,"foo")
11:19:56 <subconscious> ♪ let id = (\i -> i) in (id 3, id "foo")
11:19:56 <lunabot>  (3,"foo")
11:20:08 <subconscious> wrong abstraction ...
11:20:09 <_zenon_> subconscious, what's up with the note thingy?
11:20:22 <subconscious> ♪ (\id -> (id 3, id "foo")) (\i -> i)
11:20:23 <lunabot>      No instance for (Num [Char])
11:20:25 <aempirei> i mean if you explicity type them
11:20:41 <subconscious> aempirei: that's the difference I _meant_ to hilight
11:20:49 <Jedai> subconscious: I believe that the MonomorphismRestriction is disabled with the bots
11:20:57 <subconscious> Jedai: irrelevant
11:21:22 <subconscious> monomorphism is to do with typeclasses, this is the type rules of lambda vs let
11:21:41 <Jedai> subconscious: Well not completely, your second let would have "worked" (by failing) if it wasn't the case
11:22:21 <subconscious> Jedai: what do you mean? Can you show me an interaction with ghci or something doing that?
11:22:37 <Jedai> Maybe I'm just remembering OCaml restriction
11:23:03 <subconscious> Jedai: Yeah it could be the value restriction from Ocaml you're remembering, but since haskell doesn't have mutation we don't have that problem
11:23:16 <Jedai> subconscious: Yep, you're right
11:23:56 <aempirei> ok so:
11:23:57 <aempirei> let g = (\x -> x + 1) :: (Integer -> Integer)
11:24:04 <aempirei> let f x = (x + 1) :: (Integer)
11:24:17 <aempirei> can you explain the differences of g and f here
11:24:21 <subconscious> aempirei: yeah, they're equivalent, but f and g are bound by let
11:24:21 <aempirei> like whats actually stored
11:24:23 <dons> ?users
11:24:23 <lambdabot> Maximum users seen in #haskell: 511, currently: 488 (95.5%), active: 22 (4.5%)
11:24:29 <aempirei> ok
11:25:00 <aempirei> im sorry but can you breifly tell me what being bound by let really means
11:25:10 <subconscious> aempirei: The difference is when you bind a value that has a polymorphic type with either let or lambda
11:25:20 <aempirei> ok
11:25:27 <subconscious> ♪ let id x = x in (id 3, id "foo")
11:25:28 <lunabot>  (3,"foo")
11:25:30 <subconscious> ♪ (\id -> (id 3, id "foo")) (\i -> i)
11:25:31 <lunabot>      No instance for (Num [Char])
11:25:33 <aempirei> like if it was type (Num a) => a -> a
11:25:36 <aempirei> you mean ?
11:25:45 <subconscious> so the second one gives a type error because 3 and "foo" have different types
11:25:47 <aempirei> ok
11:26:00 <aempirei> let me try to understand that for a second
11:26:10 <subconscious> Do you know how type inference works?
11:26:18 <aempirei> mostly yes
11:26:18 <Jedai> The type error is confusing though (the default rule probably don't kick in fast enough)
11:26:36 <Jedai> ♪ (\id -> (id (3 :: Int), id "foo")) (\i -> i)
11:26:37 <lunabot>      Couldn't match expected type `[Char]' against inferred type `Int'
11:26:46 <Jedai> Yeah, that's better
11:27:29 <mmorrow> @pl \k x y -> (k x, k y)
11:27:29 <lambdabot> flip =<< (((.) . (,)) .)
11:27:33 <aempirei> im starting to get what youre saying, since they are bound by let some of the typing becomes specifically sety
11:27:41 <mmorrow> (flip =<< (((.) . (,)) .)) id 0 []
11:27:45 <mmorrow> , (flip =<< (((.) . (,)) .)) id 0 []
11:27:45 <lunabot>      No instance for (Num [a])
11:27:47 <aempirei> which it would otherwise be unbound
11:29:00 <aempirei> i guess what im saying is taht if you define something by a lambda abstraction, the type of that thing is actually a function, just as if you were to directly define some function
11:29:04 <aempirei> theres no kinda "POINTER"
11:29:12 <aempirei> its just really assigned to a function
11:29:15 <aempirei> in either case
11:29:53 <qwr> pointers are meaningless in haskell
11:29:57 <aempirei> i know
11:30:01 <mmorrow> . (id***id) (9,[])
11:30:06 <mmorrow> , (id***id) (9,[])
11:30:06 <aempirei> im just tryin to use words i know to describe what im asking
11:30:07 <lunabot>  (9,[])
11:30:23 <lilac> > let f x = y where y = x in f 42
11:30:25 <lambdabot>   42
11:30:25 <aempirei> someone was trying to claim to me a function defined using a lambda abstraction is slower than defining it directly with a pattern matching
11:30:26 <lilac> > let f = \x -> y where y = x in f 42
11:30:27 <lambdabot>   x
11:30:28 <subconscious> when you are thinking operationally about a programs execution pointers are a very useful abstraction
11:30:48 <aempirei> but i was thinking thats retarded, since functions are first class
11:31:09 <Baughn> aempirei: I have a feeling the optimizer would discard that difference in either case
11:31:10 <aempirei> anyhow i just been programming haskell for 1 day so this is helpful
11:31:13 <subconscious> aempirei: The best thing to do in that sort of situation is ask them for evidence
11:31:16 <Baughn> What with inlining and all
11:31:19 <mmorrow> aempirei: i guess that depends on the compiler
11:31:19 <aempirei> i just ignored them
11:31:28 <aempirei> because tahts not what the gentle introduction to haskell 98 said
11:31:35 <qwr> subconscious: yes. but no side effects kind of means that shall be no difference between references and copies
11:31:38 <subconscious> gentle introduction to haskell 98 might be wrong
11:31:41 <mmorrow> aempirei: depends on what optimizations the partic compiler you're using does
11:31:42 <aempirei> and when i looked at the types of my variables
11:31:45 <aempirei> it didnt say that
11:31:55 <Philippa> mmorrow: and on its execution model and...
11:32:05 <mmorrow> Philippa: yes, that too ...
11:32:33 <aempirei> but looking at the types of say f = \x + 1, in no way does the type of f (:t f) imply it was a definiion by lamda abstraction
11:32:58 <qwr> subconscious: in what way? :)
11:33:05 <mmorrow> , [|\x -> x|]
11:33:06 <lunabot>  LamE [VarP x_0] (VarE x_0)
11:33:10 <aempirei> it just seems to tell you f is assigned to a mathematical morphism
11:33:14 <mmorrow> , [|let f x = x in f|]
11:33:15 <lunabot>  LetE [FunD f_0 [Clause [VarP x_1] (NormalB (VarE x_1)) []]] (VarE f_0)
11:33:36 <subconscious> qwr: I don't know I'm just saying anything tutorials or anything like that could potentially have mistakes in them
11:33:40 <mmorrow> their representations in abstract syntax are distinguishable
11:33:58 <subconscious> mmorrow: cool!
11:34:03 <qwr> subconscious: yes they can...
11:34:08 <aempirei> yes via syntax of the definition but
11:34:14 <mmorrow> subconscious: :)
11:34:16 <subconscious> ♪ [| [| "what does this look like?" |] |]
11:34:16 <lunabot>      Illegal bracket at level Brack 2
11:34:19 <subconscious> :{
11:34:21 <subconscious> :(
11:34:28 <mmorrow> just do one level
11:34:38 <subconscious> I wanted to see the AST for [|'s
11:34:50 <lilac> , [| $( [| "hello" |] $) |}
11:34:51 <lunabot>   parse error on input `)'
11:34:51 <mmorrow> ah, TH doesn't have a rep for brackets sadly
11:34:53 <lilac> , [| $( [| "hello" |] $) |]
11:34:53 <lunabot>   parse error on input `)'
11:35:00 <mmorrow> , [| $( [| "hello" |] ) |]
11:35:01 <lunabot>  LitE (StringL "hello")
11:35:03 <subconscious> ♪ [| Hello lilac |]
11:35:03 <lunabot>   Not in scope: data constructor `Hello'
11:35:03 <lunabot>  <interactive>:1:59: Not in scope: `lilac'
11:35:10 <subconscious> hehe
11:35:28 <subconscious> ♪ [| is this going to produce too many lines of errors |]
11:35:29 <lunabot>   parse error on input `of'
11:35:38 <subconscious> can I PM lunabotL
11:35:39 <subconscious> ?
11:35:39 <lilac> , $( [|id|] ) $( [| "Hello!" |] )
11:35:40 <lunabot>  "Hello!"
11:36:20 <subconscious> ♪ $(LitE (StringL "Foo"))
11:36:21 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:36:36 <subconscious> ♪ $([| LitE (StringL "Foo") |])
11:36:37 <lunabot>  LitE (StringL "Foo")
11:36:59 <mmorrow> , $(tupE (replicate 15 [|0|]))
11:37:00 <lunabot>  (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)
11:37:25 <subconscious> hey how did that work but mine didn't
11:37:43 <mmorrow>  LitE (StringL "Foo") :: Exp
11:37:55 <mmorrow> but $(x) ==> x :: ExpQ == Q Exp
11:38:05 <lilac> , $(return $ LitE (StringL "Foo"))
11:38:05 <mmorrow> and you quoted it again
11:38:06 <lunabot>  "Foo"
11:38:09 <subconscious> ♪ $(tupE (map (\x -> [|x|]) [1..10]))
11:38:10 <lunabot>      Ambiguous type variable `a' in the constraints:
11:38:18 <subconscious> ♪ $(tupE (map (\(x :: Integer) -> [|x|]) [1..10]))
11:38:19 <lunabot>      Illegal signature in pattern: Integer
11:38:31 <subconscious> well TH doesn't work for me
11:38:40 <mmorrow> heh, so the rule is
11:38:51 <mmorrow> $([|x|]) == x
11:39:51 <lilac> , [| tupE |]
11:39:53 <lunabot>  VarE tupE
11:40:00 <mmorrow> , tupE
11:40:01 <lunabot>      No instance for (Show ([ExpQ] -> ExpQ))
11:40:17 <subconscious> ♪ [| \u -> u u |]
11:40:17 <lunabot>      Occurs check: cannot construct the infinite type: t = t -> t1
11:40:28 <subconscious> ♪ [| \u -> u |]
11:40:29 <lunabot>  LamE [VarP u_0] (VarE u_0)
11:40:35 <subconscious> ♪ [| [| \u -> u |] |]
11:40:35 <lunabot>      Illegal bracket at level Brack 2
11:40:44 <subconscious> ♪ [| LamE [VarP u_0] (VarE u_0) |]
11:40:44 <lunabot>   Not in scope: `u_0'
11:40:44 <lunabot>  <interactive>:1:75: Not in scope: `u_0'
11:40:53 <mmorrow> , $(let f k = [|$k $k|] in f [|id|]) 42
11:40:54 <lunabot>  42
11:41:01 <lilac> , let mkTuple xs = $( tupE [|xs|] ) in mkTuple [1,2,3,4,5]
11:41:02 <lunabot>      Couldn't match expected type `[ExpQ]' against inferred type `Q Exp'
11:41:11 <subconscious> so what can you do with this stuff?
11:41:21 <mmorrow> build programs
11:41:49 <mmorrow> you can contruct instance declarations, data declarations, functions decls, expressions, ....
11:42:22 <lilac> , let mkTuple xs = $( tupE (map (\x -> [|x|]) xs) ) in mkTuple [1,2,3,4,5]
11:42:23 <lunabot>      GHC stage restriction: `xs'
11:42:27 <dons> http://www.reddit.com/r/programming/comments/727dp/metahdbc_typesafe_database_access_for_haskell/
11:42:30 <lambdabot> Title: MetaHDBC: type-safe database access for Haskell : programming, http://tinyurl.com/4ejylm
11:43:07 <dancor> why is cabal-install in darcs.haskell.org when for most stuff it looks like code.haskell.org is the new hotness
11:43:07 <lilac> , [| [1,2,3,4,5] |]
11:43:08 <lunabot>  ListE [LitE (IntegerL 1),LitE (IntegerL 2),LitE (IntegerL 3),LitE (IntegerL ...
11:43:24 <dancor> is everything eventually going to be at code?
11:43:34 <dcoutts_> dancor: no, things will remain split
11:43:37 <mmorrow> , $(let sel n i = let x = mkName "x" in lamE [tupP (replicate i wildP ++ [varP x] ++ replicate (n-i-1) wildP)] (varE x) in sel 10 7) (0,1,2,3,4,5,6,7,8,9)
11:43:38 <lunabot>  7
11:43:42 <lilac> , let mkTuple xs = $( tupE $ case [|xs|] of ListE ys -> ys ) in mkTuple [1,2,3,4,5]
11:43:42 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:43:48 <dcoutts_> dancor: in particular ghc and the other core things will remain on darcs.h.o
11:43:53 <lilac> , let mkTuple xs = $( tupE $ case [|xs|] of ListE ys -> map return ys ) in mkTuple [1,2,3,4,5]
11:43:54 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:44:01 <dancor> ok
11:44:03 <mmorrow> so [|1234|] :: ExpQ
11:44:10 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:45:54 <subconscious> ♪ do foos <- [$SQL| select * from foo |]
11:45:55 <lunabot>   parse error on input `|]'
11:46:02 <lilac> > let mkTuple xs = case [|xs|] of ListE ys -> map return ys :: [ExpQ] in mkTuple [1,2,3,4,5]
11:46:03 <lambdabot>   mueval: Prelude.read: no parse
11:46:05 <lilac> , let mkTuple xs = case [|xs|] of ListE ys -> map return ys :: [ExpQ] in mkTuple [1,2,3,4,5]
11:46:06 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:46:16 <lilac> , let mkTuple xs = case [|xs|] of ListE ys -> map return ys in mkTuple [1,2,3,4,5]
11:46:17 <lunabot>      Couldn't match expected type `ExpQ' against inferred type `Exp'
11:46:52 <subconscious> I'm sure this TH stuff is cool :)
11:46:57 <subconscious> I just don't know why yet
11:48:11 <mmorrow> subconscious: heh. get the derive package from hackage
11:48:15 <mmorrow> then do
11:48:59 <nominolo> Jedai: does your code handle "{- ... -}" comments?
11:49:00 <mmorrow> $ echo -ne 'module Asdf where\ndata A a b c = A a | B a b | C a b c\n" > Asdf.hs
11:49:26 <mmorrow> $ derive -dShow -dRead -dTypeable -dData -dArbitrary -dNFData  Asdf.hs
11:49:33 <mmorrow> and see what prints to stdout
11:49:35 <Jedai> nominolo: Yes normally it does (my test seemed to indicate it didn't have problems with them
11:51:03 <Jedai> nominolo: I recently realized that it don't handle Line pragmas (not represented in the token stream, would need some specific handling in my functions) but it should handle most .hs files without a problem (and lit unlit can be used to handle .lhs too)
11:51:56 <nominolo> ok
11:52:05 <ADINSX> http://pastebin.com/m695f280e I'm having a bit of a problem, I'm trying to remove all the white spaces in a given string, I'm getting a strange compiler error (also on the pastebin)
11:52:11 <ADINSX> is this atleast the right direction?
11:53:07 <MichaelScott> No instance for (Show (m [Review]))
11:53:07 <MichaelScott>       arising from a use of `print'
11:53:08 <MichaelScott> Possible fix: add an instance declaration for (Show (m [Review]))
11:53:10 <MichaelScott> how?
11:53:17 <MichaelScott> print $ M.lookup "1488844" files
11:55:42 <nominolo> ADINSX: head str ++ rmv (tail str)  ==>  str : rmv (tail str)
11:55:44 <Deewiant> MichaelScott: lookup returns a value in any monad (this is to change in the next release) so you need a type signature
11:55:44 <nominolo> er
11:55:54 <nominolo> head str : rmv (tail str)
11:56:10 <Taejo> Deewiant: the type of lookup is changing?
11:56:12 <ADINSX> ah i understand now, its getting a char and it wants an array
11:56:13 <ADINSX> ahhh
11:56:14 <nominolo> ADINSX: but you should use patter matching
11:56:15 <ADINSX> perfect
11:56:18 <PeakerWork> @type lookup
11:56:20 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:56:24 <MichaelScott> type signature for what where?
11:56:35 <ADINSX> i know this isnt the best way but its like my first haskell code
11:56:40 <Deewiant> Taejo: that of Data.Map.lookup (and Set, I think) is
11:56:48 <Deewiant> ?ty M.lookup
11:56:49 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
11:57:04 <Taejo> Deewiant: to what? only Maybe?
11:57:05 <nominolo> ADINSX: ok
11:57:10 <Deewiant> Taejo: yep
11:57:20 <Taejo> why?
11:57:44 <Deewiant> there's lengthy discussion about it on the mailing list
11:57:55 <MichaelScott> print $ M.lookup "1488844" files
11:58:02 <MichaelScott> hould i add something to that?
11:58:07 <Deewiant> I think the main point was that currently it's too easy to use it with something where fail = error
11:58:17 <nominolo> ADINSX: if you write rmv (x:xs) = ... then you can write x instead of head str and xs instead of tail str
11:58:28 <Deewiant> MichaelScott: print $ (M.lookup "1488844" files :: Maybe [Review])
11:58:37 <ADINSX> ohhhh
11:58:49 <ADINSX> those code examples ive been finding online make a lot more sense now
11:59:10 <nominolo> ADINSX: :)
11:59:12 <MichaelScott> then i get a just
11:59:15 <dcoutts_> maybe mzero print $ (M.lookup "1488844" files
11:59:29 <MichaelScott> thanks, then i get a Just
11:59:31 <MichaelScott> Just [Review {idn = 1, grade = 3, date = "2005-09-06"},
11:59:31 <MichaelScott> Review {idn = 8, grade = 4, date = "2005-05-12"}]
11:59:40 <MichaelScott> how o i get onl the list?
11:59:56 <dancor> MichaelScott: what do you want to do in the case of a lookup failure
12:01:01 <dancor> one option is     let rev = fromJust $ M.lookup "1488844" files
12:01:13 <dancor> and your program will abort on a lookup failure
12:01:27 <dcoutts_> or better:
12:01:28 <dcoutts_> Just rev <- M.lookup "1488844" files
12:01:29 <BMeph> "I think the crux of
12:01:29 <BMeph> the matter was that a monad is too general. Either there is a result or
12:01:32 <BMeph> there is not. That's precisely the intended use of a Maybe." - http://article.gmane.org/gmane.comp.lang.haskell.cafe/44495
12:01:44 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:02:09 <BMeph> Sorry about the short lines. :/
12:02:29 <micahcowan> I'm new to Haskell, but how is that a problem, considering that Maybe, itself, is a Monad?
12:02:30 <dancor> dcoutts_: it's not monadic right?
12:02:56 <dcoutts_> dancor: hmm? if the pattern match fails then it calls the Monad fail
12:03:02 <nominolo> ADINSX: you might be interested in this -> http://book.realworldhaskell.org/ and this --> http://haskell.org/haskellwiki/Learning_Haskell
12:03:13 <lambdabot> Title: Real World Haskell
12:03:22 <Jedai> nominolo: Why the question if I may ask ?
12:03:37 <Jedai> MichaelScott: http://hpaste.org/10504#a2
12:03:41 <dancor> dcoutts_: i mean wouldn't it be    let Just rev = M.lookup "1488844" files
12:04:00 <nominolo> Jedai: I couldn't find it in the patch at first.  But I found it shortly after
12:04:03 <dcoutts_> dancor: you could do that but what I suggested fails in the monad, not as a pure error
12:04:09 <BMeph> micahcowan: The point is that while any MonadZero-member monad would work, Maybe expresses the intent of the function directly, so it should be the form of answer used. :)
12:04:15 <dancor> ohhh
12:04:53 <Jedai> micahcowan: Some monads have less than ideal way to fail and lookup just invite this kind of abuse, also having to put type annotations from time to time can be annoying
12:05:47 <Jedai> micahcowan: Only Maybe really makes sense for this function, so using a general monad is a bad idea
12:06:03 <dcoutts_> and it's trivial to lift into a Monad
12:06:37 <dcoutts_> if the old code was do res <- M.lookup "1488844" files
12:06:41 <dcoutts_> then the new is do Just res <- M.lookup "1488844"
12:06:53 <dcoutts_> (erm with the files too obviously)
12:06:58 <micahcowan> Doesn't it work well in the case of IO, though? Or is that perhaps insufficient reason for a common typeclass to be defined for IO and Monad?
12:07:36 <micahcowan> In which case the Monad member functions (if that's the term) ought to have been made IO member functions (only)?
12:07:51 <lightstep> Jedai, doesn't Parser make sense too?
12:07:58 <dcoutts_> micahcowan: the issue is that fail is in Monad, but it should only be in MonadPlus
12:08:06 <bd_> dcoutts_: MonadZero you mean :)
12:08:11 <dancor> hey does anyone agree with me that when working with randoms, it's cooler to just use split all the time instead of dealing with (r, g') = randFunc g
12:08:32 <dcoutts_> bd_: right yes
12:08:34 <Jedai> lightstep: Parser ? Why ? What does looking into a Map has to do with parsing ?
12:08:40 <dancor> i guess with split you still have all these silly generators to keep track of
12:09:03 <Jedai> dancor: It's cooler just to use a MonadRandom anyway
12:09:27 <lightstep> Jedai, they have nothing to do with each other, but the shorthand fits for that monad
12:10:02 <Jedai> lightstep: The shorthand, what do you mean ?
12:11:16 <lightstep> Jedai, that M.lookup returns (Monad m => m v). so calling the current M.lookup in a Parser context really can make sense - it returns a (slightly) informative parsing error
12:12:57 <Jedai> lightstep: You're thinking of Either more generally, in other word a monad where you can throw "pure" string errors
12:12:58 <aempirei> hey thanks for your guys help
12:13:08 <aempirei> i just wrote a software synthesizer in haskell
12:13:11 <aempirei> as my first project its just a small thing
12:13:17 <aempirei> http://www.the-mathclub.net/site/code/synth.hs
12:13:23 <aempirei> heres an input file for it http://www.the-mathclub.net/site/code/swinglow-hs.txt
12:13:26 <aempirei> it will output a wav file
12:13:32 <mmorrow> aempirei: cool!
12:13:48 <aempirei> its a fun language
12:13:59 <lightstep> Jedai, yes, i thought this was original reason for the type of lookup. but the (Monad (Either String)) instance doesn't satisfy this
12:14:01 <mmorrow> swinglowwwww, sweet charrrrrriots ...
12:14:02 <sw17ch> aempirei, wow! impressive
12:14:03 <Jedai> lightstep: But really, the only error you'll ever get from lookup is "The key k isn't in the Map" so since the errors can't differ it doesn't make sense to allow to fail with an error message to indicate exactly why it failed
12:14:05 <dancor> aempirei: nice, i think a pure-haskell synth is in the works for Haskore too
12:14:10 <aempirei> cool
12:14:17 <dancor> maybe you could help, i don't know how far it is
12:14:21 <aempirei> neat
12:14:26 <aempirei> well let me know
12:14:30 <aempirei> i have a meeting right now tho, bbl
12:14:40 <micahcowan> Are only language extensions being discussed for Haskell', or will Library extensions (such as binary-files support) probably be provided?
12:15:00 <Jedai> lightstep: Mostly you'll want to give a better error message based on the context of the lookup call and that's trivial (easier even) to do with Maybe rather than Either
12:16:29 <MichaelScott> from where do iimport formJust
12:16:32 <MichaelScott> fromJust
12:16:39 <MichaelScott> Just rev <- M.lookup "1488844" files doesnt work
12:16:39 <subconscious> @hoogre fcomJuhn
12:16:40 <lambdabot> No results found
12:16:41 <Jedai> lightstep: I agree the initial type of lookup looks clever and nicely general but once you think about it, this generalization don't bring it anything
12:16:45 <lightstep> Jedai, yes, i just wanted to point out that the current state of affairs has some benefits
12:16:55 <Jedai> MichaelScott: http://hpaste.org/10504#a2
12:17:49 <Jedai> MichaelScott: Do you really want to use "fromJust . lookup" rather than just (!) ? The result is exactly the same (though you would get a slightly more informative error message from (!) than fromJust)
12:18:28 <mmorrow> micahcowan: um, binary files are already supported and usually the default (maybe not the default on windows)
12:19:05 <mmorrow> err, they may not be the default soon now that getContents/etc'll have unicode support
12:19:11 <Jedai> mmorrow: Yeah, not on windows (and arguably neither anywhere else, it's just that sane platform don't have strange text file specific handling)
12:19:56 <mmorrow> true, "the default, but by a technicality" ;)
12:20:28 <mmorrow> micahcowan: you can use ByteStrings or turn on binary io though
12:20:30 <Jedai> mmorrow: Ah well it's true that Unicode handling will change the current situation (and make clear that "text" is the real default I guess)
12:20:36 <micahcowan> But "strange text file specific handling" would include encodings. The fact that current implementations assume C locale or similar is also an accident.
12:21:20 <mmorrow> micahcowan: there are various encoding libs
12:21:26 <mmorrow> check out hackage
12:21:32 <Jedai> micahcowan: I just hate the "\r\n" issue, it just creeps up in plenty of place for no good reason
12:21:43 * SamB_XP does not understand this "locale" business
12:21:45 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding
12:21:46 <lambdabot> Title: HackageDB: encoding-0.4.1, http://tinyurl.com/3966hd
12:21:52 <SamB_XP> what kind of mathematical structure is a locale?
12:21:56 <micahcowan> mmorrow, what I mean is, there's no guarantee in Haskell that you'll get one-Char-per-byte: without that, those encoding libs won't work.
12:22:17 <mmorrow> micahcowan: you are most definitely guaranteed that with Data.ByteString
12:22:26 <SamB_XP> that's what Word8 is for ...
12:22:46 <mmorrow> and if you care about performance, you'd definitely want to use Data.ByteString as well
12:22:51 <micahcowan> mmorrow, but Data.ByteString is not part of Haskell 98; it's a common extension, no?
12:23:07 <Deewiant> any module with a "." in the name isn't H98
12:23:08 <mmorrow> what is this "haskell 98" business? ;)
12:23:11 <MichaelScott> *** Exception: stack overflow pfft wtf!? is that foldr ?
12:23:13 <SamB_XP> micahcowan: effectively
12:23:33 <SamB_XP> micahcowan: not that anyone codes in Haskell 98 anymore
12:23:46 <MichaelScott> can i trace it to where it happened with a compiler option?
12:23:50 <Philippa> some people do largely code to Haskell 98 + addenda, mind
12:24:06 <micahcowan> Deewiant, that's my point. So when will Data.ByteString or some such be added to Haskell'? Because I don't see that sort of thing currently on the wiki, and it'd be silly for Haskell' not to be brought up-to-date with the de facto standards.
12:24:12 <SamB_XP> Deewiant: I think we include FFI + hierarchical module names in Haskell 98  now
12:24:24 <SamB_XP> didn't you hear -- it's called Haskell 98 SE
12:24:30 <Deewiant> Haskell 98++
12:24:37 <Saizan> MichaelScott: http://haskell.org/haskellwiki/Stack_overflow
12:24:39 <Deewiant> micahcowan: I don't know
12:24:41 <micahcowan> A standard that everyone ignores (such as, largely, Haskell 98) is pretty much useless, AFAICT.
12:24:41 <lambdabot> Title: Stack overflow - HaskellWiki
12:24:44 <Deewiant> I agree it would be somewhat silly
12:24:53 <SamB_XP> micahcowan: we don't ignore it
12:24:57 <micahcowan> (by everyone, I mean developers, not implementors)
12:25:10 <MichaelScott> saizan: i know
12:25:23 <mmorrow> micahcowan: what compiler are you using?
12:25:25 <SamB_XP> we just bitch and moan about haskell' taking so long and get on with coding
12:25:34 <Saizan> micahcowan: i don't think new libraries are going to be in the standard
12:25:35 <Jedai> MichaelScott: You can track it into a debugger, for now I suggest changing foldr for foldl' and insertWith for insertWith'
12:25:49 <MichaelScott> ok thanks
12:26:00 <SamB_XP> Haskell 98 is, what, 9 years old now?
12:26:07 <micahcowan> mmorrow, not relevant.
12:26:20 <micahcowan> SamB_XP, the latest version is ~ 5 years old
12:26:27 <Jedai> MichaelScott: http://hpaste.org/10504#a3
12:26:34 <mmorrow> micahcowan: ok, i'm not sure what you're after
12:27:08 <RayNbow> hmm, what was () called again?
12:27:11 <micahcowan> mmorrow, a useful Haskell standard, which can actually be used to write reasonable real-world programs. AFAICT the current practice is to write GHC and damn the rest?
12:27:12 <Heffalump> unit
12:27:13 <SamB_XP> I can't wait for Haskell NT :-(
12:27:25 <subconscious> not Haskell XP? :p
12:27:27 <mmorrow> micahcowan: pretty much the case :)
12:27:28 <RayNbow> Heffalump: ah thx :)
12:27:37 <SamB_XP> subconscious: I'm not picky
12:27:56 <SamB_XP> I'll take ANY Haskell NT, even 3.51
12:28:11 <mmorrow> micahcowan: so currently, reasonable real-world programs not using ghc are few and far between
12:28:23 <SamB_XP> well, perhaps not Haskell Vista
12:29:49 <mmorrow> micahcowan: (hence why i feel the question of which compiler you're using to be relevant :))
12:30:09 <SamB_XP> what other compilers are there ?
12:30:13 <micahcowan> mmorrow, right. To me, that reflects very poorly on the effectiveness of the standard.
12:30:21 <Jedai> MichaelScott: http://hpaste.org/10504#a4 should work (I think I nailed the problems, do you use ByteString.Lazy ?)
12:30:27 <Philippa> subconscious: you don't remember when NT stood for Not There, I take it?
12:30:36 <Twey> SamB_XP: What about Haskell Frolicking Ferm?
12:30:51 <SamB_XP> micahcowan: well, why do you think they're working on a new one ?
12:31:23 <micahcowan> SamB_XP, hence, why I asked whether these things were planned for Haskell', as I couldn't find evidence that they were (though perhaps I have't looked deeply enough, yet).
12:31:30 <MichaelScott> nice Data.List.foldl' insetad of foldr was all i needed
12:31:31 <micahcowan> I was seeing language extensions, but not library extensions.
12:31:44 <subconscious> hm no I can't recall it
12:31:45 <MichaelScott> what is foldr for then? why use them if they never work in real code anyway?
12:31:56 <SamB_XP> actually, the library may take longer to standardize than the language
12:32:15 <micahcowan> I guess the answer to that is, "write a f--ing proposal, Micah" :)
12:32:20 <subconscious> MichaelScott: hahaha
12:32:37 <subconscious> MichaelScott: You have used it once and it didn't work, so you say it never works in real code :))))
12:32:39 <Jedai> MichaelScott: It works better than foldl or foldl' for plenty of case
12:32:44 <SamB_XP> once we decide what features the language has, it's easier to figure out what parts of the library are standard
12:32:52 <subconscious> MichaelScott: I like foldr because I know a couple theorems about it
12:32:55 <SamB_XP> and what pieces are still missing
12:33:17 <Jedai> MichaelScott: It's much better than foldl' when you're producing lazy stuff
12:33:40 <lightstep> why doesn't ByteString satisfy H98? because of the module name?
12:33:48 <micahcowan> Ah, okay, I found Binary I/O on the wiki. I'm a little happier. :)
12:34:11 <Jedai> MichaelScott: On infinite list you can do useful things with foldr whereas foldl can't be used at all
12:34:26 <micahcowan> lightstep, it's not that it doesn't satisfy, it's that it's not specified by H98, so can't be assumed by anyone writing against the standard (which is why no one does)
12:34:27 <SamB_XP> lightstep: well, to do handle I/O I think it needs to mess with library internals ?
12:35:17 <lightstep> SamB_XP, a library's implementation can use extensions. what i care about is being implementable in h98
12:35:20 <Jedai> micahcowan: I think this argument is weak (because if it really worked with H98 you could always use it as a library in your H98 program)
12:35:21 <MichaelScott> u mean foldl or foldl' ?
12:35:26 <MichaelScott> cnt be used
12:35:36 <Jedai> MichaelScott: Neither foldl nor foldl'
12:35:37 <MichaelScott> sub: like?
12:35:37 <SamB_XP> lightstep: yes but I don't think it IS
12:35:48 <MichaelScott> sub: like an example pls
12:35:49 <micahcowan> Jedai, then I misunderstood the question. I didn't mean to imply that it worked with H98.
12:35:52 <SamB_XP> not even Haskell 98 SE
12:36:13 <MichaelScott> sub: no more times, not really foldr but foldl mor i have to rewrite with foldl'
12:36:29 <Jedai> MichaelScott: Since they need to get to the end of the list before evaluating to anything else than an application of foldl/foldl'
12:36:38 <micahcowan> Next question: RWH is clearly focusing on GHC. I'm curious as to whether other major books, such as FPWH, try to focus on H98, or also take the tack that RWH does, and assume an extended implementation?
12:36:52 <lightstep> SamB_XP, why not? from a glance at the interface i don't see any suspicient operations
12:37:02 <Jedai> MichaelScott: Knowing where to use foldr or foldl' is important for a skilled Haskell programmer
12:37:17 <Jedai> MichaelScott: foldl isn't used much though
12:37:19 <lightstep> *suspicious
12:37:50 <Jedai> MichaelScott: exemple of good foldr usage : and xs = foldr (&&) True xs
12:37:52 <micahcowan> lightstep, suspicient ought to be a word, though. I like the sound :)
12:37:56 <SamB_XP> lightstep: how do you do Handle based IO without being subject to encoding conversions ?
12:38:16 <micahcowan> Maybe, "of suspect efficiency"?
12:38:54 <Jedai> MichaelScott: with this definition, the evaluation of an "and list" will take a constant amount of space and works on infinite lists (returning False as soon as a False is encountered)
12:39:15 <SamB_XP> um, I thought science had decided that the center of the universe was likely impossible to determine ?
12:39:20 <SamB_XP> (if there is even such a thing ?)
12:39:37 <Jedai> MichaelScott: it will also short circuit whereas "foldl' (&&) True" wouldn't
12:39:48 <subconscious> SamB_XP: science :))
12:40:10 <SamB_XP> re: RayNbow's quit message
12:40:18 <Jedai> SamB_XP: Depends on the model of the universe you choose, it's either everywhere or nowhere
12:41:04 <cytzol> That sounds like an awesome topic of conversation
12:41:19 <dancor> really with measurement-obsessed quantum theory these days, everyone probably is the center on their universe
12:41:25 <lightstep> SamB_XP, you mean the sentence "These functions cannot be used portably for binary I/O" from section 7.1? yeah, it's a great difficulty. i hope haskell' won't have it
12:41:30 <subconscious> cytzol: mumble mumble quantum theory :))
12:41:40 <dancor> science
12:41:41 <dancor> theoryi
12:41:48 <SamB_XP> even if there were just one, we can't see the edges of the universe since the light from them can't catch up with us, can we?
12:41:59 <SamB_XP> lightstep: yeah, that.
12:42:38 <pejo> Suppose I have a function that returns a pair, and I want to propagate information upwards. Code might look like this: f (Pat p1 p2) = (Pat p1' p2', u1' ++ u2') where (p1', u1') = f p1; (p2', u2') = f p2. Is there a standard idiom/way to do this elegantly?
12:42:47 <Jedai> SamB_XP: the existence of "edges" is itself highly suspect
12:42:51 <Heffalump> pejo: the Writer monad
12:42:55 <SamB_XP> Jedai: indeed
12:44:18 <lightstep> wow, the report doesn't even vaguely state what (>>=) does in IO. "These functions cannot be used portably for binary I/O.The >>= operation passes the result of the first operation as an argument to the second operation.
12:44:18 <subconscious> I'm not sure how would you use the Writer monad?
12:44:21 <subconscious> I would use a fold to write it
12:44:26 <lightstep> that's all i can find
12:44:46 <lightstep> no mention of the time relation at all
12:44:56 <SamB_XP> I'm saying that we can't see any edges, so regardless of whether or not they exist, we can't use them to figure out where the center is ;-P
12:44:59 <lightstep> err, wrong paste
12:45:13 <Jedai> SamB_XP: But your point is well taken, I recently read a very depressing article where some physicist wondered what universe model we would be able to build when only our galaxy would be observable from within itself
12:45:23 <lightstep> "The two monadic binding functions, methods in the Monad class, are used to compose a series of I/O operations. [...] The >>= operation passes the result of the first operation as an argument to the second operation."
12:45:49 <SamB_XP> Jedai: why is it depressing ?
12:46:02 <subconscious> @src Writen
12:46:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:46:03 <dons> http://www.reddit.com/r/programming/comments/727sv/switching_from_kde_to_xmonad/ woo
12:46:04 <subconscious> @src Writer
12:46:04 <lambdabot> Source not found. There are some things that I just don't know.
12:46:05 <lambdabot> Title: Switching from KDE to xmonad : programming, http://tinyurl.com/44l7cy
12:46:15 <BMeph> dancor: Isn't Theoryi that Hungarian experimental physicist? ;)
12:46:21 <SamB_XP> clearly we can see other galaxies, or galaxy would be synonymous with universe ;-P
12:46:31 <dancor> it's a next-gen haskell editor
12:46:55 <dancor> work on it will begin any day now, as soon as yi is finalized
12:47:15 <SamB_XP> dancor: so true
12:47:20 <Jedai> SamB_XP: Well the idea that the observable universe complexity is shrinking and the potential universe model a species would be able to build is degrading with times left me in a very blue mood
12:47:27 <BMeph> dons: So, when's the xmonad.org/switch ad going on YouTube? ;)
12:47:44 <dons> mmm :)
12:47:47 <SamB_XP> Jedai: oh, right, the future ...
12:48:01 <SamB_XP> who said the complexity is decreasing ?
12:48:24 <SamB_XP> you must be one of those bozos who believes in the conservation of energy ;-P
12:48:52 <Jedai> SamB_XP: Well by complexity I just meant the variety of objects and contents rather than any theoretic concept (but entropy tends to give me reason)
12:49:13 <subconscious> SamB_XP: What about Entropy
12:49:30 <SamB_XP> oh, yes, and in the laws of thermodynamics ;-P
12:49:43 <dancor> scientropy
12:49:54 * SamB_XP isn't sure if he does or not
12:50:15 <Jedai> SamB_XP: We don't all have our personal Maxwell daemon, thank you ! ^^
12:50:34 <SamB_XP> eh?
12:50:47 <SamB_XP> why does this make me think of a silver hammer?
12:51:41 <Jedai> SamB_XP: Yes why indeed ?
12:52:07 <SamB_XP> hmm, I think it's some beatles song or something ...
12:54:09 <pejo> Heffalump, thanks. Is there a nice non-monadic way?
12:54:31 <Heffalump> pejo: perhaps - though a bit more heavyweight. Look into attribute grammars.
12:55:03 <BMeph> SamB_XP: Bang, bang! ;)
12:55:13 * SamB_XP dies
12:55:59 * BMeph loks around, then cautiously gives Maxwell back his hammer...
12:57:42 <idnar> haha
12:57:48 <idnar> the silver one?
12:57:53 <idnar> oh
12:57:57 * idnar needs to read up further
12:58:10 <aempirei> ok im back
12:58:31 <SamB_XP> Jedai: as you can see, I'm not the only one!
13:00:13 * BMeph had teachers dedicated to "folk-style" music in junior high school
13:01:22 <dons> ?users #xmonad
13:01:23 <lambdabot> Maximum users seen in #xmonad: 130, currently: 119 (91.5%), active: 11 (9.2%)
13:01:26 <dons> we hit 130 today :)
13:01:51 <cemerick> is anyone aware of a functional (efficient) implementation of an RTree (or other 2-dimensional indexing data structure)?
13:02:06 <dons> hmm
13:02:18 <dons> would finger trees work?
13:02:23 <dons> what operations do you need?
13:02:31 <pejo> Heffalump, thanks. Will look into it.
13:02:44 * BMeph sighs, seeing that dons beat him to the "finger tree" punch...
13:03:15 <cemerick> dons: I'm not familiar with finger trees -- looking them up now
13:03:27 <bos> cemerick: i wrote a Hilbert R-tree implementation about 17 years ago, but it was in scheme.
13:03:33 <bos> and finger trees will not help you.
13:03:47 <bos> dons: an R-tree is a generalised B-tree.
13:04:05 <dons> ah.
13:04:08 <cemerick> yeah, finger trees won't do it
13:04:14 <dons> so we probabbly don't have a lib for that then.
13:04:18 <bos> no, we don't.
13:04:20 <dons> but i don't think its intractable :)
13:04:22 <lightstep> is there a yi port for windows?
13:04:36 <bos> dons: it would be a few days of work, no more.
13:04:46 <cemerick> bos: I'm using Clojure at the moment; I came here because I figured this would be the most well-populated functional programming channel on irc :-)
13:04:56 <bos> cemerick: ah.
13:04:57 <dons> there were some STM b-tree impls floating around last year
13:05:02 <dons> i wonder why none of those made it to hackage..
13:05:21 <bos> would they have been kmett's?
13:05:35 <dons> oh, so that would be yet more ..
13:05:36 <cemerick> I've got an RTree impl, but amortizing removals is turning out to be trickier than I bargained for...
13:05:48 <bos> cemerick: my r-tree implementation is stuck on a dead server.
13:06:25 <mmorrow> cemerick: the finger-tree paper may be of some help wrt amortization technique(s)
13:06:33 <mmorrow> (in general)
13:06:53 <cemerick> mmorrow: OK, I'll take a look at it; I've been soaking up Okasaki the past few days, but perhaps a different cut would help
13:07:04 <cemerick> bos: are you aware of any alternative structures that might be more amenable to functional implementation?
13:07:19 <bos> quadtrees are much simpler.
13:07:49 <MichaelScott> so it is basically "all" : all xs = foldr (&&) True xs
13:08:04 <subconscious> I think all = foldr (&&) True is better
13:08:19 <mmorrow> nice. finger trees are a generalization of the the ImplicitCatenableDeques in chapter 11 of Purely Functional Datastructures
13:08:23 <MichaelScott> what is the reason ByteStrings aren't the official strings? they aren't lazy?
13:08:28 <cemerick> bos: I seem to remember them having distinctly less desirable runtime guarantees
13:08:41 <mmorrow> (or one of those datastructures in 11 i believe...)
13:08:49 * cemerick wants it all ;-)
13:09:05 <MichaelScott> sub: is it better to eliminate on both sides?
13:09:08 <MichaelScott> is that hasdkell style?
13:09:40 <Jedai> MichaelScott: That's "pointfree" style (sometimes called "pointless" by those that don't favour it)
13:10:14 <mmorrow> those that don't favour it are just missing the point
13:10:17 <Jedai> MichaelScott: You'll see a lot of it in Haskell, it's really a question of taste (I prefer the pointfree version of and myself too)
13:10:29 <Twey> MichaelScott: It depends on the function
13:10:29 <Jedai> @type all
13:10:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:10:32 * BMeph gives mmorrow a rim shot
13:10:50 <Twey> Some functions can be converted to a much more elegant point-free form
13:10:52 <bos> cemerick: quadtrees are easier to insert into than r-trees, but slower to query.
13:10:53 <Jedai> MichaelScott: And your function is "and", not "all"
13:10:58 <Twey> Some functions become hideous monsters if you try
13:11:11 * mmorrow throws a seagull at BMeph
13:11:29 <Jedai> MichaelScott: all p = foldr ((&&) . p) True
13:11:30 * BMeph ducks instead! ;p
13:11:36 <PeakerWork> I like the point-ful style because it lets me document the names of my points
13:11:45 <PeakerWork> when my name would be "x" or such anyway, then I prefer points free :)
13:11:45 <bos> cemerick: so which one to use depends on the needs of your application.
13:11:48 * mmorrow laughs
13:11:58 <MichaelScott> hmm could it be that Python dicts are faster than Haskell Maps ?
13:12:13 <Jedai> MichaelScott: depends
13:12:22 <PeakerWork> MichaelScott: hash-tables vs binary-trees?  Probably faster in the average case, slower in the worst-case
13:12:23 <MichaelScott> also the way I use Strings in my program posted before. would it be a lot faster if using bytestrings?
13:12:23 <cemerick> bos: yeah; the datasets in question are pretty static, which is why I opted for the rtree to begin with
13:12:32 <PeakerWork> MichaelScott: (python dicts are hash tables)
13:12:42 <dancor> haskell should have some advantage in general just due to static-typing?
13:12:47 <Jedai> MichaelScott: ByteString would probably be faster
13:12:59 <subconscious> dancor: other languages have similar type systems
13:13:11 <Jedai> MichaelScott: Much faster if the dataset is big
13:13:19 <MichaelScott> jedai: well why not all? and is usually just 2 cases
13:13:29 <dancor> i guess thunk penalties in both cases..
13:14:24 <Jedai> MichaelScott: The second part of your sentence don't parse for me but "all" and "and" are Prelude functions so keeping the same definition is probably a good idea
13:14:53 <Jedai> MichaelScott: Did you use my latest hpaste or the penultimate ?
13:15:32 <Jedai> <Jedai> MichaelScott: http://hpaste.org/10504#a4 should work (I think I nailed the problems, do you use ByteString.Lazy ?)
13:15:51 <MichaelScott> can i force garbage collection?
13:16:07 <MichaelScott> my ghc takes up 520000MB ram but the program has finished
13:16:26 <subconscious> MichaelScott: It seems to me, the problem could be something other than the garbage collector
13:16:31 <Jedai> MichaelScott: You probably can (in IO in GHC) but it shouldn't be necessary, the GC is good
13:16:47 <subconscious> but I think there is a way to do that
13:16:55 <Jedai> MichaelScott: If the program has finished and it still is in memory, your problem isn't the GC...
13:18:35 <Twey> Is there a Haskell library for extracting frequency information from a .wav?
13:18:43 <Jedai> MichaelScott: Besides "ghc" shouldn't be the process name, it should be your compiled application (tell me you compiled it with optimisations before using it for real, please ??)
13:18:56 <Jedai> Twey: Yes
13:19:03 <Twey> Jedai: What's it called?
13:19:11 <Jedai> Twey: I don't have a clue
13:19:14 * Twey laughs.
13:19:42 <Twey> I need to do some frequency analysis, and I'd like to use Haskell.  :)
13:20:18 <Saizan> maybe he's talking about ghci?
13:20:39 <Jedai> Twey: Maybe WAVE would be a good start ?
13:21:02 <Twey> Ooh, this looks good
13:21:03 <Twey> Thanks!
13:21:09 <mmorrow> Twey: i think there're bindings to fftw
13:21:36 <mmorrow> hmatrix has a fft also
13:21:38 * Twey nods.
13:21:54 <Twey> I'm a bit new to all this mathematical stuff.  :)
13:22:04 <Twey> Trying to pick it up as I go along.
13:22:15 <Jedai> MichaelScott: Haskell is a compiled language, the interpreter is for experimentation, interactive development and testing only
13:22:25 <mmorrow> heh, fft will transform it from the frequency domain to the time domain (or vice-versa)
13:22:38 <MichaelScott> well im using the interpreter in emacs, not compiled
13:23:50 <Jedai> MichaelScott: Ok, if you think it's slow it's normal... You should compile your program (with GHC it's very easy, just do "ghc -O2 --make programName.hs") before you use it on big dataset
13:25:22 <Jedai> MichaelScott: And kill and restart your ghc in Emacs to free your memory
13:25:41 <Jedai> MichaelScott: There's probably cleaner but this way is fast and easy so...
13:27:19 <Jedai> MichaelScott: Besides the latest version I put on hpaste should be better, what are you using exactly ?
13:28:47 <MichaelScott> can insertWith be used interchangeably with insertWith' ? it doesnt change behavioru, just laziness to strictness?
13:29:02 <MichaelScott> @src Data.Map.insertWith
13:29:03 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:29:04 <Jedai> MichaelScott: Yes
13:29:56 <Jedai> MichaelScott: insertWith' is better here because the reduction won't cost much and will reduce the memory footprint
13:30:05 <MichaelScott> jedai: yes but where is it using lazy ?bytestrings
13:30:27 <Jedai> MichaelScott: I was asking you if you were using lazy bytestring
13:30:53 <Jedai> Apparently not (though it should do a real difference on big files for sure)
13:31:44 <MichaelScott> ok i will se how much i can parse, python pretty much wen on strike at around 300 files
13:32:04 <MichaelScott> ghci pwnd 100 files(havent tried more yet) so lets see compiled
13:32:30 <subconscious> MichaelScott: Are you writing a logfile parser?
13:33:34 <Jedai> Twey: HSoundFile may be more efficient than WA
13:33:57 <MichaelScott> sub: no parsing moviereviews to do recomenndation system
13:34:01 <Jedai> Twey: VE, also I seem to remember a comparison of sound package recently
13:34:33 <bos> MichaelScott: if you're not using bytestring and insertWith', your performance and memory consumption will be terrible.
13:35:19 <BONUS> @pl \xs -> length . filter ((==GT) . uncurry compare) . zip xs . tail $ xs
13:35:20 <lambdabot> ((length . filter ((GT ==) . uncurry compare)) .) =<< (. tail) . zip
13:35:34 <dons> yeah. the rules: ghc -O2, bytestring-0.9.1.2, insertWith' for Map
13:35:40 <Jedai> MichaelScott: Your problem seems to be more adapted to a database backend, if you have really big datasets, no matter what language you use, you will have a scaling problem sooner or later (even if Haskell with ByteString.Lazy should be able to do much more than Python)
13:35:40 <dons> that's all win right there.
13:35:56 <dons> i wonder why there's been so many log file questions this week
13:35:59 <dons> new wide-finder?
13:36:20 <dons> lots of new people writing file readers in ghci, then we tell them to use bytestring and ghc -O2
13:36:27 <dons> maybe there should be a log file parser FAQ.
13:36:50 <MichaelScott> adapted to? how do you mean?
13:37:07 <MichaelScott> where i just froomJust etc?
13:37:15 <MichaelScott> import Monad?
13:37:17 <BONUS> Data.Maybe
13:37:23 <subconscious> @hoogle froomJust
13:37:23 <lambdabot> No results found
13:39:06 <dons> MichaelScott: hmm. should you be using catMaybes?
13:39:08 <Jedai> MichaelScott: If you have a really big dataset and need to organize it to do requests on it with decent speed, database are your only option, RAM isn't infinite you know and trying to do this with another tool is just reinventing wheels
13:39:21 <dons> catMaybes xs = [ x | Just x <- xs ]
13:39:32 <dcoutts_> list comprehensions ftw!
13:40:01 <dcoutts_> I used to think list comprehensions were just for beginners
13:40:26 <dcoutts_> and that "Real Programmers" used just hofs
13:40:31 <PeakerWork> filter/map are for elitists :)
13:40:39 <Jedai> MichaelScott: Why the h*** do you still need fromJust ? Did you ever read those links I sent to you ?
13:40:41 <subconscious> real programers write everything in CPS
13:40:48 <BONUS> i only use list comps when drawing from several lists
13:40:48 <BONUS> eg
13:40:55 <BONUS> [(x,y) | x<-xs, y<-ys]
13:41:22 <Jedai> BONUS: liftM2 (,) xs ys you mean ?
13:41:27 <subconscious> I prefer liftM2 (,) in that case
13:41:29 <dcoutts_> for many real world cases I find it's invaluable to use list comprehensions, even if it's basically just a map and filter
13:41:35 <subconscious> assuming I can actually read haskell code
13:41:36 <dcoutts_> is so easy to read and see what it's doing
13:41:40 <BONUS> yeah well that was obviously a trivial case
13:41:41 <ziman> it's more readable
13:41:51 <dcoutts_> ziman: exactly
13:42:14 <dcoutts_> especially once those generators, patterns and result are much bigger expressions
13:42:33 <bos> come on, real programmers use "const (((,) <$>) . join (<*>)"
13:42:50 <dcoutts_> :t const (((,) <$>) . join (<*>)
13:42:51 <lambdabot> parse error (possibly incorrect indentation)
13:43:00 <dcoutts_> hah hah hah
13:43:21 <micahcowan> Reasonable?   let fibb = map snd . iterate (\(x,y) -> (y,(x+y))) $ (0,1)
13:43:29 <micahcowan> > let fibb = map snd . iterate (\(x,y) -> (y,(x+y))) $ (0,1) in take 10 fibb
13:43:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
13:43:35 <dcoutts_> :t const ((,) <$>) . join (<*>)
13:43:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:43:36 <lambdabot>       Expected type: f (a -> b) -> f (a -> b) -> b1
13:43:36 <lambdabot>       Inferred type: f (a -> b) -> f a -> f b
13:44:15 <bos> :t const (((,) <$>) . join (<*>))
13:44:16 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
13:44:17 <lambdabot>       Expected type: f1 (a -> b) -> f1 (a -> b) -> f a1
13:44:17 <lambdabot>       Inferred type: f1 (a -> b) -> f1 a -> f1 b
13:44:19 <dcoutts_> @quote bos come on, real programmers use "const (((,) <$>) . join (<*>)"
13:44:19 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 8,"Unmatched ( or \\(")
13:44:26 <dcoutts_> erm
13:44:29 <dcoutts_> @remember bos come on, real programmers use "const (((,) <$>) . join (<*>)"
13:44:29 <lambdabot> I will remember.
13:44:33 <dcoutts_> lambdabot: thanks
13:44:54 <bos> dammit, i meant "(((,) <$>) .) . (<*>)"
13:45:02 <bos> sigh.
13:45:10 <dcoutts_> bos: does it type check this time ? :-)
13:45:15 <bos> :t (((,) <$>) .) . (<*>)
13:45:16 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => f (a -> b1) -> f a -> f (b -> (b1, b))
13:45:33 <dcoutts_> oh is that all :-)
13:45:46 <bos> i try to write code that typechecks on the first go at least 5% of the time.
13:45:50 <Jedai> The type seems wrong
13:46:16 <Jedai> @pl \xs ys -> (,) <$> xs <*> ys
13:46:16 <lambdabot> (((,) <$>) .) . (<*>)
13:46:31 <SamB_XP> bos: 5%?
13:46:36 <Jedai> Strange type...
13:46:58 <bos> SamB_XP: 7% if i've just had a cup of coffee.
13:48:34 <MichaelScott> ghc parser.hs
13:48:43 <MichaelScott> what should i compiel with again?
13:48:51 <MichaelScott> ghc parser.hs -02
13:49:02 <MichaelScott> or ghc -02 parser.hs
13:49:03 <SamB_XP> micahcowan: well, for starters, you run those commands in a terminal ;-P
13:49:05 <MichaelScott> O or 0
13:49:38 <lightstep> O for optimization
13:49:42 <Jedai> bos: It seems this is a @pl failure
13:49:43 <lightstep> and you also need --make
13:49:56 <MichaelScott> is machine learning matlab+database+perl(for fast hacking to get the sets in the database?)
13:50:02 <Jedai> MichaelScott: ghc -O2 --make parser.hs
13:50:37 <micahcowan> SamB_XP, hm?
13:50:47 <SamB_XP> micahcowan: silly joke, nevermind ;-P
13:51:06 <Jedai> @pl \xs ys -> ((,) <$> xs) <*> ys
13:51:06 <lambdabot> (<*>) . ((,) <$>)
13:51:33 <Jedai> bos: As you see, @pl had the precedence of those operator wrong
13:51:43 <Jedai> @type (<*>) . ((,) <$>)
13:51:44 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
13:53:28 <MichaelScott> compilation finished successfully but no Main.exe
13:53:34 <MichaelScott> or parser.exe
13:54:03 <MichaelScott> manifext main file though
13:54:45 <Jedai> Was your file the Main module (or no module declaration at all) ?
13:55:25 <Jedai> MichaelScott: if it was then GHC should have produced a "parser.exe", if not it consider it a library and so only produce the object file
14:09:15 <grahamhutton> hi wouter!
14:10:34 <mmorrow> Twey: here's an example of how to plot the frequency spectrum of a .wav file with hmatrix: http://hpaste.org/10508
14:10:51 <mmorrow> (you'll need sox too)
14:12:47 * Philippa grins as she discovers the non-termination in her typechecker was due to having messed up substitution and the checker itself yep, really is as braindead as expected
14:12:53 <Philippa> 'lo grahamhutton
14:13:06 <grahamhutton> hi philippa
14:13:52 <Philippa> It seems I'm still taking my old 3rd year project a little too seriously - I'm just coding up the distant descendant I talked about at IFL
14:14:00 <Philippa> thought you might be amused
14:26:31 <mmorrow> @tell Twey here's an example of how to plot the frequency spectrum of a .wav file with hmatrix: http://hpaste.org/10508
14:26:31 <lambdabot> Consider it noted.
14:31:09 <guenni> mmorrow: good morning
14:31:09 <lambdabot> guenni: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:32:13 <mmorrow> good morning
14:32:30 <mmorrow> (those are from before i talked to you last)
14:32:49 <guenni> mmorrow: yep, I know
14:33:10 <mmorrow> ;)
14:33:39 <guenni> mmorrow: about this Generics business: I'm horrifed, they use strings as Identifiers for types?
14:33:50 <mmorrow> heh, yeah
14:34:04 <guenni> ouch
14:34:07 <mmorrow> but they check type equality with unique Ints
14:34:26 <mmorrow> err, thats Data.Dynamic
14:34:32 <mmorrow> @src Dynamic
14:34:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:34:34 <mmorrow> @src Dyn
14:34:35 <lambdabot> Source not found. Maybe you made a typo?
14:34:50 <guenni> I do presume they are reasons to do this, but I don't wonna go down that road
14:34:54 <mmorrow> , pp $(lift =<< reify ''Dyn)
14:34:54 <lunabot>   Not in scope: type constructor or class `Dyn'
14:34:59 <mmorrow> , pp $(lift =<< reify ''Dynamic)
14:35:01 <lunabot>  data Dynamic = Dynamic TypeRep Obj
14:35:06 <mmorrow> , pp $(lift =<< reify ''TypeRep)
14:35:08 <lunabot>  data TypeRep = TypeRep !Key TyCon ([] TypeRep)
14:35:13 <mmorrow> , pp $(lift =<< reify ''Key)
14:35:14 <lunabot>   Not in scope: type constructor or class `Key'
14:35:17 <mmorrow> gah
14:35:36 <guenni> who is lunabot?
14:35:42 <mmorrow> my bot :)
14:35:47 <guenni> ic
14:35:59 <guenni> no serious mmorrow tell me this is not true
14:36:06 <mmorrow> what?
14:36:20 <guenni> the use of strings
14:36:21 <mmorrow> Generics and Strings
14:36:22 <mmorrow> ah
14:36:31 <FunctorSalad> main = processXmlWith (deep garbage)
14:36:34 <FunctorSalad> (this really happened)
14:36:55 <mmorrow> i'm not sure of all the internal details, but Typeable uses TypeRep
14:37:06 <mmorrow> @src Typeable
14:37:07 <lambdabot> Source not found. Where did you learn to type?
14:37:14 <mmorrow> , pp $(lift =<< reify ''Typeable)
14:37:16 <lunabot>  class Typeable a_0
14:37:16 <lunabot>      where typeOf :: forall a_0 . Typeable a_0 => a_0 -> TypeRep
14:37:46 <Jedai> guenni: That's what the paper used as a first approximation but the Typeable implementation in GHC now use unique Int as identifier I believe
14:38:04 <mmorrow> , pp $(lift =<< reify ''TypeRep)
14:38:06 <lunabot>  data TypeRep = TypeRep !Key TyCon ([] TypeRep)
14:38:34 <mmorrow> if i remember correctly, a key is a Int or an Int# or some such thing
14:38:38 <guenni> Jedai: thx, but all this seems very adhoc, moving target sort of thing?
14:39:10 <guenni> Jedai: something to stay away from in short
14:39:47 <Jedai> guenni: The low-level implementation doesn't really matter (except for performance reason), what matters is the API that Data.Typeable and Data.Term gives you
14:39:58 <guenni> the benefits of this would have to be *huge*
14:40:15 <guenni> there must be something I am totally missing here
14:40:21 <Jedai> guenni: Generic programming is very useful in some fields
14:40:25 <mmorrow> i use it for stuff like
14:40:46 <mmorrow> , everywhere (mkT (+1)) (((0,1),9),(23,(12,1)))
14:40:47 <lunabot>  (((1,2),10),(24,(13,2)))
14:41:33 <Jedai> guenni: This summer (and now) I worked on HaRe which is a refactorer for Haskell in Haskell, writing it without some kind of generic programming for the traversals would have been pretty insane
14:41:52 <Jedai> (AST traversals)
14:43:14 <quicksilver> guenni: you may find Uniplate is a 'saner view' on generic programming
14:43:23 <waern> Jedai: how's the port coming along?
14:43:26 <quicksilver> it is much simplified API and strictly less powerful
14:43:41 <quicksilver> but its simplicity is more elegant, if it is sufficient for a particular purpose
14:43:57 <Jedai> guenni: basically, as soon as you have very rich recursive data structure and needs to query and transform it, generic programming pays for itself pretty handsomely
14:44:38 <Philippa> doesn't even have to be that rich. I'm crying out for automatically generated bindings and related operations for ASTs for even simple languages
14:44:38 <Jedai> waern: Advancing steadily, though I must adapt to the new API for GHC (Thomas Shilling GSoC work)
14:45:00 <Philippa> ddarius: I ended up with a non-termination bug. Much to my gratification, I'd merely screwed up the substitution function :-) Checker/inferrer works fine, shock horror
14:45:16 <guenni> quicksilver: thx, I'll look it up right away
14:45:37 <waern> Jedai: ah, ok.
14:45:49 <quicksilver> Uniplate works on the principle that at any one time, you're working with subterms of a fixed type
14:45:55 <quicksilver> like Int, in mmorrow's example just up there
14:46:04 <quicksilver> or 'Expr' or 'Term' in an AST-like situation.
14:46:14 <quicksilver> this is often a valid simplification.
14:47:50 <ddarius> Philippa: How are you verifying it?  Just inspection?
14:47:51 <guenni> quicksilver: which one is the one currently favored by most haskellers, there seem to be quite a few different implementations?
14:48:42 <Philippa> ddarius: and some simple tests so far, yeah. Need to throw some more serious tests at it, and/or look at whether I feel up to figuring out how to do it in Coq
14:48:43 <guenni> I mean there is "Data.Generics" and there is "syp" and TH and so on
14:49:11 <ddarius> guenni: SYB is the out-of-the-box one, but I'd recommend anyone to see if Uniplate would fit their needs first.
14:49:15 <ddarius> Data.Generics is SYB
14:49:31 <Jedai> guenni: I think Uniplate is the best where you can use it, if not, you can use StrategyLib instead (Data.Generics is a little bit too "raw", it makes an acceptable low-level interface to write your own API on it)
14:49:36 <Philippa> actually I suspect the biggest problems there are working out how to formalise the desired properties and managing to nick someone else's constraint solver because I so don't need to write that from scratch
14:50:20 <guenni> Haskell does get steeper and steeper to learn, ouch
14:50:32 <ddarius> Philippa: I'd like to implement a constraint propagation/solver system one day, but yeah, most of the time I'd want to just use someone else's.
14:50:46 <subconscious> in Coq?
14:50:50 <Philippa> that goes doubly when you're looking for verified...
14:51:22 <Philippa> subconscious: someone's got to've done it for the constraint system I'm looking at, though it may force me into an icky syntax representation
14:52:36 <ryant5000> what's the closest haskell has to perl's WWW::Mechanize ?
14:53:04 <shapr> Is that a browser control module?
14:53:07 <nominolo> Jedai: may name is write with "Sch" not "Sh" ;)
14:53:14 <nominolo> written*
14:53:22 <ryant5000> shapr: i think so
14:53:33 <shapr> ryant5000: You could use the Selenium plugin if nothing else is handy.
14:53:36 <Jedai> guenni: You don't _need_ to know generic programming, most programs works very well without it... Just know it exists and come back to it when you have a problem where it may pally
14:53:38 <ryant5000> shapr: it's a browser without a gui
14:53:49 <shapr> oh, I think there's a module for that already.
14:53:55 <shapr> HTTP.Browser I think?
14:54:12 <Jedai> nominolo: Sorry, I won't make this mistake again !! (or try to at least ;-) )
14:54:29 <Philippa> ddarius: any suggestions for a testing strategy, btw? Though academically I suspect it's not interesting in a "just prove it on the rules themselves" kinda way
14:55:17 <Jedai> guenni: Generic programming is hardly a main part of Haskell
14:55:23 <ddarius> Philippa: It should be possible to set it up that you check the inferred type and infer the checked (given) type.
14:55:23 <nominolo> Jedai: i'm sure this will happen more often when I live in the UK
14:56:19 <shapr> ryant5000: I don't know if this does everything you want - http://hackage.haskell.org/packages/archive/HTTP/3001.0.4/doc/html/Network-Browser.html
14:56:20 <lambdabot> Title: Network.Browser, http://tinyurl.com/4am5nh
14:56:38 <ryant5000> shapr: thanks, i'll take a look
14:57:20 <Philippa> ddarius: good call
14:57:29 <nominolo> guenni: generics are only really useful if you do lots of traversing of data structures.  You can always do it by hand
14:57:48 <nominolo> guenni: it just becomes useful to automate the boring stuff
14:57:59 <Philippa> also, the inferrer generates annotated terms: it ought to be idempotent
14:58:23 <nha__> is there any way to make a tail recursive fold over a tree with 4 children per node?
14:58:49 <ddarius> nha__: Sure.
14:59:12 <bos> why would you want to?
14:59:21 <nha__> getting stack overflows on large trees
15:02:00 <roconnor> Proving lemmas about left folds really drives home how left folds and loops are essentially the same.
15:02:29 <leimy> mapfold is something I use all the time in Erlang :-)
15:02:35 <leimy> lists:mapfold
15:02:47 <nominolo> is that fold f . map?
15:03:11 <nominolo> well, foldl' f x0 . map g
15:04:33 <cjay> @yarr
15:04:33 <lambdabot> Aye
15:05:43 <ddarius> @google Barry Jay loops
15:05:47 <lambdabot> http://www-staff.it.uts.edu.au/~cbj/Publications/lecture.html
15:05:47 <lambdabot> Title: The Research Interests of Barry Jay: Loops
15:05:53 <ddarius> roconnor: You may find that interesting.
15:07:00 <Twey> leimy: mapfold is best expressed in Haskell as a list comprehension
15:07:00 <lambdabot> Twey: You have 1 new message. '/msg lambdabot @messages' to read it.
15:07:16 <leimy> Twey: yes :-)
15:07:22 <leimy> because it returns a tuple
15:07:22 <Twey> mmorrow: Hmmm
15:07:27 <leimy> map results and fold results
15:07:42 <mmorrow> Twey: hey
15:07:44 <Twey> So it does
15:09:03 <Twey> mmorrow: The x values aren't accurately displaying the frequencies?
15:09:23 * Twey blinks.
15:10:07 <Twey> Interesting subliminal thing there: I skimmed over the code first, not registering the name 'swinglow.wav', and when I looked back at it to read it in detail I had the song in my head
15:12:02 <bos> sweetchariot.com comefortocarrymehome.net
15:13:38 <ddarius> It's a good song
15:14:50 <bos> it is.
15:16:10 <mmorrow> Twey: yeah, i just numbered the x values [0..], i'm not sure exactly what they should be (eg in kHz), but probably that could be determined to figuring out what sox is actually representing by the -u -L -4 (unsigned little-endian 4-byte) samples..
15:18:40 <mmorrow> Twey: it's been a bit since i've done stuff like this, but at one point i did know how to figure out the correct x-values, so it's definitely possible, and not too hard at that
15:22:47 <mmorrow> heh, i got that wav file from a software synth someone wrote and linked to in here a little earlier
15:22:57 <mmorrow> it was his/her first haskell program :)
15:23:03 <mmorrow> http://www.the-mathclub.net/site/code/synth.hs
15:23:07 <mmorrow> http://www.the-mathclub.net/site/code/swinglow-hs.txt
15:23:33 <subconscious> haskell!
15:24:59 <Taral> dum de dum... compiling coq @ work
15:25:10 <Taral> why is there no proof assistant/theorem prover written in haskell?
15:25:27 <dons> there are..
15:25:35 <Taral> oh?
15:25:39 <dons> the famous ones are older than haskell of course.
15:25:46 <Taral> which ones?
15:25:51 <Taral> ah.
15:25:58 <subconscious> ?where Ivor
15:25:58 <lambdabot> I know nothing about ivor.
15:26:02 <subconscious> you should lambdabot
15:26:03 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Theorem_provers
15:26:04 <lambdabot> Title: Applications and libraries/Theorem provers - HaskellWiki, http://tinyurl.com/6zhnxu
15:26:16 <dons> there's new ones on hackage.
15:26:44 <subconscious> mmm
15:26:55 <dons> Taral: hot topics at the moment: isabelle and coq extraction to haskell
15:27:05 <Taral> but coq isn't written in haskell
15:27:07 <Taral> :(
15:27:10 <subconscious> Taral: who cares?
15:27:16 <Taral> I do!
15:27:28 <rog__> mmorrow: hi again. did you by any chance manage to work out where my code was spinning?
15:27:28 <Taral> Hate having to install this dirty ML thing :D
15:27:48 <subconscious> Well I would like Epigram 2
15:27:49 <newsham> O'Comeon
15:27:57 <subconscious> It sounds really really cool
15:28:36 <dons> Taral: right. the old generation of tools was written in older languages
15:28:42 <dons> the new tools are written in new languages
15:28:43 <Taral> wasn't epigram the one that required emacs to display the 2d stuff?
15:28:45 <subconscious> hey Taral what do you think you will do with Coq?
15:29:00 <subconscious> any programming?
15:29:15 <SamB_XP> Taral: that was epigram 1
15:29:29 <SamB_XP> and worse, it needs specifically xemacs
15:29:41 <Apocalisp> oh hells no
15:29:44 <SamB_XP> besides being rather buggy and unstable
15:29:45 <subconscious> whereas Epigram 2 uses ncurses
15:29:46 <Apocalisp> that's just wrong
15:29:47 <newsham> also need xemacs for isabelle proof general
15:29:48 <Taral> subconscious: Same as always. Playing with search-based programming.
15:29:55 <Taral> I never seem to get very far.
15:29:59 <subconscious> Taral: Such as Prolog?
15:30:31 <rog__> what are the most common techniques that folks here use to debug haskell code?
15:30:40 <mmorrow> rog_: i looked for a short bit, but didn't figure it out :(
15:30:58 <subconscious> Taral: or actual program derivation?
15:30:58 <rog__> mmorrow: did you get it compiling?
15:30:58 <newsham> rog: i often write small tests to isolate whats broken
15:31:14 <SamB_XP> rog_: sit and think, quickcheck, Debug.Trace
15:31:22 <SamB_XP> #haskell
15:31:25 <Taral> subconscious: Actual program derivation.
15:31:30 <Taral> Like Djinn, but more powerful.
15:31:35 <subconscious> cool
15:31:44 <rog__> SamB_XP: quickcheck?
15:32:06 <subconscious> Taral: I'm trying to do the same :)
15:32:08 <newsham> ?check \n -> succ n == (n :: Int) + 1
15:32:08 <SamB_XP> rog_: you don't know what it is?
15:32:09 <lambdabot>   "OK, passed 500 tests."
15:32:10 <Taral> Nifty :D
15:32:29 <Taral> rog__: Unfortunately the best tools (hat/buddha) weren't updated last time I checked.
15:32:35 <newsham> lets you define properties like that and it automatically generates inputs to test the properties
15:32:38 <newsham> and report any failures
15:32:51 <subconscious> Taral, oh if you have not seen it
15:33:00 <subconscious> ?go algebra of programming with dependent types
15:33:00 <rog__> SamB_XP: i'll google it...
15:33:03 <lambdabot> http://lambda-the-ultimate.org/node/2771
15:33:03 <lambdabot> Title: Algebra of programming using dependent types | Lambda the Ultimate
15:33:08 <ddarius> @where quickcheck
15:33:09 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
15:33:09 <subconscious> this is so neat
15:33:12 <Taral> I will look.
15:33:20 <Taral> so many things on LTU it's hard to keep up
15:33:22 <SamB_XP> rog_: newsham just demoed it with that ?check command ;-)
15:33:25 <subconscious> and that is in Agda implemented in Haskell
15:33:54 <newsham> subconcious: seen "dependent types at work?
15:34:03 <subconscious> Taral: You can also use Coq as a kind of dependently typed Prolog :)
15:34:20 <SamB_XP> except he seems to have forgotten one of the most important parts of debugging: start with buggy code ;-)
15:34:22 <newsham> http://www.cs.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf
15:34:24 <lambdabot> Title: Dependent Types at Work
15:35:02 <Taral> what's with the 2 inch margins?
15:35:05 <Taral> I hate PDF sometimes. :(
15:35:13 <ddarius> Taral: Zoom
15:35:18 <Taral> I can't reflow documents to take better advantage of my paper size.
15:35:33 <lament> Taral: ever since fermat's great fiasco, people have been careful about providing every paper with oversized margins
15:35:43 <SamB_XP> lament: lol
15:35:48 <newsham> *waves fist at fermat and margins*
15:35:52 <Taral> lament: lol
15:36:05 <FunctorSalad> anyone get this? (context: xml processing, type CFilter = Content -> [Content])       "chip :: CFilter -> CFilter      Process CHildren In Place. The filter is applied to any children of an element content, and the element rebuilt around the results. "
15:36:10 <mmorrow> rog__: yeah, it loaded in ghci with that instance you provided no problem
15:37:15 <FunctorSalad> ("around"!?)
15:37:16 <Taral> ?check \n ::[Int] -> head (sort n) < head n
15:37:17 <lambdabot>   Parse error at "::[In..." (column 4)
15:37:21 <Taral> pfft.
15:37:29 <rog__> mmorrow: ok, that's something, then. thanks for looking into it. i guess i'll just carry on with trying to use trace.
15:37:30 <Taral> ?check \n -> head (sort n) < head (n :: [Int])
15:37:31 <lambdabot>   "Falsifiable, after 0 tests:\n[0]\n"
15:37:48 <mmorrow> rog__: no prob. good luck.
15:38:04 <Taral> -fglasgow-exts plz
15:38:20 <aempirei> f :: Penis -> Vagina -> Baby
15:38:33 <Saizan> FunctorSalad: i think it's like chip f (Elem contents) --> Elem (concatMap f contents)
15:38:39 <rog__> mmorrow: ...though the decentralised control flow that laziness gives you doesn't seem to make things very easy!
15:38:42 <Taral> aempirei: Falsifiable, after 0 tests? :D
15:38:59 <subconscious> rog__: Are you used to programming in strict languages?
15:39:02 <FunctorSalad> Saizan: that's my guess too but then it would have type chip :: CFilter wouldn't it?
15:39:18 <rog__> subconscious: yes.
15:39:26 <subconscious> rog__: It could just be getting used to the change
15:39:49 <BMeph> Saizan: s/concatMap/traverse/ maybe? :)
15:39:50 <rog__> subconscious: i'm sure. but it's nice to be able to get a stack trace!
15:39:51 <Saizan> FunctorSalad: and f?
15:39:59 <subconscious> I don't like stack traces
15:40:06 <subconscious> I usually see them when something crashes
15:40:17 <FunctorSalad> Saizan: sorry I mean "(Content -> [Content]) -> Content" (that is, without the final -> [Content])
15:40:39 <Saizan> (btw, i don't know the definition of Content)
15:40:50 <FunctorSalad> or even "(Content -> [Content]) -> Content -> Content"
15:41:01 <FunctorSalad> since it would only return the new root
15:41:03 <rog__> subconscious: better than no stack trace though. at least if i've got a stack trace i can know the current context.
15:41:11 <subconscious> Taral: but yeah, I would be interested in anything you come up with (even if you consider it trivial)
15:41:18 <Taral> "stack" and "context" don't mean much in functional programming
15:41:18 <Saizan> FunctorSalad: unless it always returns a singleton list
15:41:28 <Taral> what kind of failure are you seeing?
15:41:34 <Saizan> FunctorSalad: and the result type is [Content] just for consistency
15:41:36 <subconscious> in seeing*
15:41:38 <Taral> subconscious: I will let you know if I have any more success this time :D
15:41:41 <aempirei> how do you define a data type from inside the ghci interpreter
15:41:43 <FunctorSalad> Saizan: I think it's just a tree node plus the xml nonsense
15:41:50 <rog__> Taral: infinite loop.
15:41:55 <FunctorSalad> (that was re: definition of content)
15:41:56 <aempirei> instead of just from normal haskell code
15:42:08 <Taral> rog__: Try profiling.
15:42:17 <FunctorSalad> Saizan: that makes sense
15:42:26 <BMeph> Saizan: Eh, six of one, half-dozen of another, I guess. :)
15:42:58 <rog__> Taral: and, yes, i know that stack/context doesn't make so much sense in a non-strict language, but i'm having difficulty trying to work out what's going on that's leading to my program looping...
15:43:21 <Taral> Like I said, the best tools are hat and buddha.
15:43:24 <Saizan> BMeph: uhm, i don't get it
15:43:25 <Taral> But good luck getting them working.
15:43:37 <rog__> Taral: hmm
15:44:13 <ScottMichael> jedai: why idn seq?
15:44:29 <ScottMichael> and not seq to the other arguments?
15:44:35 <aempirei> oi, how do you define a data type from inside the ghci interpreter and not just from a haskell code file
15:44:59 <rog__> aempirei: i'm not sure you can
15:45:25 <aempirei> bummer
15:45:26 <ScottMichael> and do di really want lazy bytestrings not just bytestrings?
15:45:36 <bos> ScottMichael: depends on your application.
15:47:37 <Taral> aempirei: ghci command line lets you import modules and evaluate expressions -- only way to get new type declarations is the former
15:47:45 <aempirei> ok thats perfect
15:47:46 <ScottMichael> im michaelscott, i posted before.
15:47:47 <aempirei> thank you
15:47:49 <aempirei> that will work fine for me
15:48:05 <ScottMichael> open and parse shit loads of files
15:48:12 <ScottMichael> simple parasing
15:48:23 <rog__> Taral: my code's at http://hpaste.org/10502#a4 if you fancy having a look. i've probably got infinite recursion, but i can't find it!
15:48:50 <Taral> what expression are you evaluating?
15:49:07 <rog__> Taral: getstate 30
15:50:05 <bos> ScottMichael: lazy bytestring is best for big files.
15:50:47 <subconscious> rog__: 			let lo = if x < lo then x else lo in
15:51:08 <subconscious> ♪ let x = 35 in   let lo = if x < lo then x else lo in   lo
15:51:09 <lunabot>  luna: out of memory (requested 2097152 bytes)
15:51:44 <rog__> subconscious: no. i realise that's a potential bug, but it's not actually invoked and i still get infinite loop even when that's fixed.
15:52:00 <subconscious> rog__: so you just leave it broken...?
15:52:16 <rog__> subconscious: no, i just haven't hpasted the new code
15:52:31 <subconscious> why don't you paste the actual code?
15:53:42 <ScottMichael> bos: i have loads of smaller (5-50kB) and some big like 2MB
15:53:50 <Taral> subconscious: he did
15:54:28 <rog__> subconscious: 'cos i was in a hurry. i've done it now.
15:54:58 <ScottMichael> what os the best way to do simple grapics in haskell? i just want to draw a simple binary tree with some different colors or a graph or something, 2d is ok but preferrably 3d possible
15:55:10 <rog__> i should really spend 30 minutes trimming down the code to its essentials
15:55:38 <ScottMichael> how do i backquot in windows?
15:56:27 <bos> ScottMichael: for small files, plain old bytestring is fine, but lazy bytestring will scale to larger files more safely.
15:56:41 <ScottMichael> ok
15:57:04 <Taral> rog__: You have scen dependent on itself
15:57:53 <Taral> here's your loop
15:57:55 <rog__> is that a problem, given that it's based on a version of itself with the relevant field blanked out
15:57:57 <rog__> ?
15:58:25 <ScottMichael> how does lazy strings help anyway if everything has to be evaluated anyway?
15:58:52 <rog__> Taral: note that getstate 2 doesn't hang, so it works sometimes!
15:58:55 <Taral> getstate -> stateattime -> discontinuities -> predict -> stateattime -> discontinuities -> etc.
15:59:53 <Taral> because discontinuities is strict in scen_intvs, which is a call to predict, which restarts the loop.
16:01:08 <BMeph> ScottMichael: The counter-question for you is: *when* should everything be evaluated? :)
16:01:19 <rog__> Taral: but scen_intvs is being set to [] on the call to predict, so that shouldn't be a problem... no?
16:01:35 <Taral> no
16:01:51 <Taral> oh
16:01:52 <Taral> hm
16:02:13 <Taral> ok, that's not it.
16:02:21 <rog__> good.
16:02:43 <rog__> well, not good! i wanted that to be the problem... 'cos then i'd have found it!
16:03:06 <Taral> interesting.
16:03:15 <Taral> getstate 10 = (FracV 60.2, [])
16:03:18 <Taral> getstate 11 does not terminate
16:03:28 <Taral> is it notable that 60.2 is the first value > 60?
16:05:05 <rog__> yes. the point is that predict makes a linear prediction of a future value, and then produces an intervention which should affect that value. the whole thing's about model prediction in the presence of potential future interventions.
16:05:54 <rog__> oh i'm getting weak cries from upstairs
16:06:03 <rog__> that means i have to go.
16:06:24 <rog__> thanks v much for your input. i shall sleep on it.
16:06:45 <rog__> if you have a good idea, email me at rogpeppe at gmail dot com...
16:06:49 <rog__> ttfn
16:06:57 <Taral> I definitely think it's the last line of predict. bye
16:16:01 <ScottMichael> bmeph: well iom parsing and stroing it in a database so right away...
16:17:58 <BMeph> ScottMichael: Okay, let me try to prompt you another way: Is it absolutely necessary, that your program evaluate the entire contents of your files all at once?
16:20:34 <ScottMichael> at once? not sure what that means. it goes over each line and puts them into a Map and later it will be serialized to a file perhaps
16:21:15 <dibblego> when I do university tutoring, I ask students to count the number of bytes in a file. The true beginners stand out when they elect to first read the file into an array of bytes
16:22:00 <SamB_XP> dibblego: how do they know how big to make the array ????
16:22:10 <dibblego> SamB_XP, they keep growing it of course
16:22:22 <SamB_XP> !!!!
16:22:32 <SamB_XP> x_x
16:22:48 <Botje> hey, it works in java.
16:23:28 <Botje> and they probably grow the array by 1 each time, too? :D
16:24:03 <SamB_XP> O(n^2), hooray
16:24:28 <SamB_XP> and O(n) or worse in RAM
16:24:46 <dibblego> they need it "all at once" so of course :)
16:25:27 <SamB_XP> how long does it take them to realize that they don't actually use the array -- just the bytecount?
16:25:36 <SamB_XP> I suppose it takes less time in C?
16:26:36 <bd_> If your implementation of the array file reader is lazy enough... :)
16:34:11 <FunctorSalad> dibblego: what's the right solution? du $file?
16:36:10 <FunctorSalad> btw arrays with double-size-on-overflow have (amortized) O(n) total time to insert n elements
16:36:47 <Peaker> Is it also O(n) if you use any other super-linear growth? (e.g grow by a factor of 1.01 each time)
16:36:51 <FunctorSalad> (any exponential growth will do)
16:37:06 <FunctorSalad> not any superlinear though
16:37:40 <FunctorSalad> it's just the geometric series
16:37:41 <Peaker> yeah, when I said super-linear, I actually meant exponential, sorry :)
16:37:41 <Olathe> No.
16:37:47 <int-e> it has to grow faster than any polynomial.
16:38:14 <bos> FunctorSalad: itym amortized O(n log n)
16:38:55 * ptolomy2 looks at the multicore shootout and wonders why he's never heard of ATS before now.
16:38:56 <FunctorSalad> bom: maybe that is if you don't assume fixed-time atomary steps?
16:39:08 <int-e> bos: nope. you don't copy the big array log(n) times; you're copying a big array, before that an array half the size, etc.
16:40:18 <FunctorSalad> ~ O(n * 1/(1-q) ) where 1/q is the growth factor
16:40:26 <FunctorSalad> I think
16:42:34 <Pseudonym> Yarr, me hearties!  A pirate not be pure, but he be declarative when the mood takes!
16:42:37 <Pseudonym> @arr
16:42:37 <lambdabot> Smartly me lass
16:43:15 <Japsu> @arr
16:43:15 <lambdabot> Aye
16:43:36 <Peaker> ptolomy2: ATS?
16:44:35 * ptolomy2 only today fully realized the advantage static languages have over dynamic ones in a multi-core environment.. hard to be very safe when every class and method that can be redefined is practically a global mutable variable..
16:45:30 <ptolomy2> Peaker: http://www.ats-lang.org/
16:45:33 <lambdabot> Title: Home Page for ATS
16:47:13 <Peaker> interesting
16:47:17 <Pseudonym> ptolomy2: Indeed.  As always, static typing is not a substitute for discipline, but discipline that can be checked by the computer is more valuable that that which can't.
16:47:26 <Pseudonym> s/that/than/
16:48:35 <mmorrow> @arrrrrgyle socks
16:48:35 <lambdabot> Unknown command, try @list
16:48:40 <mmorrow> @arr
16:48:41 <lambdabot> Drink up, me 'earties
16:53:53 <Apocalisp> @. elite arr
16:53:54 <lambdabot> KeELH4U1 7h3 5wA8$!
16:55:07 <mmorrow> @nixon
16:55:07 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
16:55:20 <mmorrow> @nixon
16:55:21 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
16:55:28 <mmorrow> lol
16:55:30 <mmorrow> @nixon
16:55:31 <lambdabot> This is a great day for France!
16:55:43 <mmorrow> @. elite nixon
16:55:43 <lambdabot> You |-|aVE +O F4C3 7hE F4(7 +HA7 whOlE PR08|E/\/\ is re4LLY t|-|e 8L4xxs. +H3 K3Y I5 +0 diVise a 5yzTe/\/\ 7H4T rEconisES Thiz WHIL3 NO+ app3ARiN9 to...
16:55:51 <Apocalisp> gah!
16:56:07 <mmorrow> nixon is So L23t
16:56:09 <Olathe> lambdabot hung up on Nixon, I see.
16:56:31 <Olathe> The l33t was too much.
16:56:34 <Apocalisp> You can thank Nixon for the EPA
16:56:43 <roconnor> > (1-x)^2
16:56:44 <lambdabot>   (1 - x) * (1 - x)
16:57:18 <mmorrow> > (1 - x) * (1 - x)
16:57:19 <lambdabot>   (1 - x) * (1 - x)
16:57:33 <Olathe> > (1 - x)^7
16:57:35 <lambdabot>   (1 - x) * (1 - x) * ((1 - x) * (1 - x)) * ((1 - x) * (1 - x) * (1 - x))
16:58:01 <mmorrow> > x^2 / x
16:58:02 <lambdabot>   x * x / x
16:58:05 <Olathe> @src (^)
16:58:05 <lambdabot> x ^ 0            =  1
16:58:05 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
16:58:05 <lambdabot>   where f _ 0 y = y
16:58:05 <lambdabot>         f x n y = g x n
16:58:05 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
16:58:07 <lambdabot>                       | otherwise = f x (n-1) (x*y)
16:58:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
16:58:20 <Olathe> O-o
16:58:34 <mmorrow> > 11111 ^ negate 1
16:58:36 <lambdabot>   mueval: Prelude.read: no parse
16:58:36 <lambdabot>  mueval: *** Exception: Negative exponent
17:00:00 <ptolomy2> > x^2 - 2x + 1
17:00:04 <lambdabot>       No instance for (Num (Expr -> Expr))
17:00:04 <lambdabot>        arising from the literal `2...
17:00:09 <ptolomy2> > x^2 - 2*x + 1
17:00:10 <lambdabot>   x * x - 2 * x + 1
17:00:11 <Peaker> yucky syntax, ATS has
17:00:26 <ptolomy2> Indeedy.
17:00:35 <ptolomy2> The shootout entries are effective, but dead ugly.
17:01:27 <Botje> GHC 11 will have shootout entries as primitives.
17:05:08 <ScottMichael> what was this again: Couldn't match expected type `C.ByteString'
17:05:09 <ScottMichael>            against inferred type `IO C.ByteString'
17:05:21 <ScottMichael> and what is the easiest way to do graphics ?
17:05:27 <ivanm> Botje: with a new point release every time a shootout entry gets updated or a new shootout gets added?
17:05:46 <Botje> ScottMichael: it means you should put that code in the IO monad
17:06:00 <Botje> ivanm: evidently.
17:06:18 <ScottMichael> @. elite mmorrow
17:06:18 <lambdabot> Plugin `compose' failed with: Unknown command: "mmorrow"
17:06:26 <ivanm> @remember Botje GHC 11 will have shootout entries as primitives.
17:06:26 <lambdabot> It is stored.
17:06:29 <chessguy> @. elite yarr
17:06:29 <lambdabot> i WAnt /\/\E gROG!
17:06:53 <chessguy> @. yarr elite
17:06:53 <lambdabot> Arr! Me ship be the biggest brig in the port!
17:07:01 <ScottMichael> @remember ivanm besserwisser
17:07:01 <lambdabot> I will remember.
17:07:15 <ivanm> ScottMichael: ummm..... I never said besserwisser...
17:07:20 <ivanm> I don't even know what it means!
17:07:27 <ScottMichael> @. elite MichaelScott
17:07:28 <lambdabot> Plugin `compose' failed with: Unknown command: "MichaelScott"
17:07:47 <ivanm> @forget ivanm besserwisser
17:07:47 <lambdabot> Done.
17:08:22 * ivanm points ScottMichael to the possibilities of /msg lambdabot @help
17:08:26 <mmorrow> @quote jack-nicholson
17:08:26 <lambdabot> jack-nicholson says: You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
17:09:12 <lament> what about women and managers?
17:10:20 <ScottMichael> @forget forgetting
17:10:21 <lambdabot> Incorrect arguments to quote
17:10:30 <ScottMichael> @forget forgetting forever
17:10:30 <lambdabot> No match.
17:10:39 <ScottMichael> @src lambdabot
17:10:39 <lambdabot> Source not found. You speak an infinite deal of nothing
17:10:46 <ScottMichael> @src >>
17:10:50 <lambdabot> m >> k      = m >>= \_ -> k
17:11:47 <SamB_XP> @quote
17:11:48 <lambdabot> araujo says: [Ontolog] araujo: if you like Haskell so much why don't you marry it?! [araujo] Ontolog, I am .... internally .... i am
17:12:20 <ivanm> ScottMichael: don't guess args, use @help!
17:12:47 <osfameron> evening
17:12:48 <sgillespie> Can I get Cabal to generate haskell files via 'alex'?
17:12:53 <sgillespie> and happy?
17:13:05 <osfameron> is there something in haskell to have *optional* checked exceptions for specific cases?
17:13:46 <dcoutts> sgillespie: yes, it "just works"tm
17:13:49 <thoughtpolice> sgillespie: if you have some module like 'lexer.x' and 'parser.y' then cabal will automatically run happy/alex over it
17:13:50 <osfameron> for example, situations in which we don't want code to just swallow all exceptions, but to be obliged to handle certain classes of exception?  (So not blanket like Java, but allowing that possibility)
17:14:13 <thoughtpolice> osfameron: yes, see the new 'extensible exceptions' paper by SimonM
17:14:26 <dcoutts> sgillespie: just list the modules in the .cabal file as usual and follow the standard file naming convention and it just works
17:14:29 <thoughtpolice> it'll be in base 4.0
17:15:08 <sgillespie> alrighty
17:15:11 <osfameron> thoughtpolice: http://portal.acm.org/citation.cfm?id=1159854 ? (from 2006)
17:15:12 <lambdabot> Title: An extensible dynamically-typed hierarchy of exceptions
17:15:12 <sgillespie> will give that a try
17:15:56 <thoughtpolice> http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
17:15:57 <thoughtpolice> yeah
17:15:57 <lambdabot> Title: An Extensible Dynamically-Typed Hierarchy of Exceptions
17:16:20 <sgillespie> List in other-modules?
17:16:49 <thoughtpolice> the functionality will be included with ghc 6.10 inside base4, which is why 6.10 is also shipping with the new base3-compat library
17:18:04 <osfameron> what's base4 ?
17:18:11 <thoughtpolice> new version of the base package
17:18:38 <osfameron> is that the core package? (prelude?)
17:19:23 <thoughtpolice> yeah
17:35:10 <xci> what is the best way of getting a square root of an integer and get an integer as a result?
17:35:55 <mmorrow> @type floor . sqrt . fromIntegral :: Integer -> Integer
17:35:56 <lambdabot> Integer -> Integer
17:36:14 <Olathe> Make a simple iSqrt.
17:36:35 <xci> ah well, I forgot to mention that my num is of magnitude 10^20
17:36:44 <Apocalisp> Is there yet a Cabal dingus that will download all dependencies from Hackage?
17:36:45 <xci> and I would like to be quite near anyway
17:36:47 <xci> though
17:36:56 <xci> well, that floor probably suffices
17:37:13 <Olathe> > let iSqrt 0 = 0; iSqrt n = if leadingDigits*leadingDigits > n then leadingDigits - 1 else leadingDigits where leadingDigits = 2*iSqrt (div n 4) + 1 in iSqrt 25
17:37:15 <lambdabot>   5
17:37:30 <xci> Olathe: yeah, that is cool :)
17:37:33 <Olathe> > let iSqrt 0 = 0; iSqrt n = if leadingDigits*leadingDigits > n then leadingDigits - 1 else leadingDigits where leadingDigits = 2*iSqrt (div n 4) + 1 in iSqrt (10^20)
17:37:34 <lambdabot>   10000000000
17:37:47 <xci> thank you both :)
17:37:53 <Olathe> You're welcome.
17:47:50 <micahcowan> Wow,   do { ... } :: List   is something of a mindtrip. I'm getting it, it's just... wow.
17:48:33 <dmwit> micahcowan: Try this one on for size:
17:48:52 <dmwit> > filterM (const [True, False]) [1..4]
17:48:54 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
17:51:10 <micahcowan> Til now, I'd mostly been thinking of "do" in terms of IO, as a sort of "following is a list of IO actions to be performed in succession". Trying to keep that mindset while grokking do :: List is like quantum mechanics: the universe keeps splitting. :)
17:51:32 <dmwit> =)
17:51:40 <Apocalisp> Oh wow. Cabal-install has come a long way
17:51:43 <Apocalisp> nice work!
17:51:45 <dmwit> Yup, IO can be a misleading monad.
17:52:04 <micahcowan> Of course, it's nearly always the first one you're introduced to.
17:52:13 <dmwit> sadly
17:52:44 <SamB_XP> micahcowan: well, yes, that IS the idea of the list monad ;-P
17:53:52 <micahcowan> SamB_XP, well, so I gathered. It's fairly cool. Though I wonder how often it really results in something more directly readable than recursive (concat . map)'s or similar.
17:56:15 <dmwit> I've used it several times.
17:56:23 <dmwit> It's a very natural idiom when you want backtracking search.
17:56:41 <dmwit> (And it's a lot easier to grok than LogicT. =)
18:10:15 <roconnor> Maybe monad was the first non IO monad I was introduced to
18:10:38 <roconnor> I had a bunch of nested case statement to propogate Nothing
18:10:57 <roconnor> replacing those blocks with do notation was very instructive.
18:11:07 <newsham> hi
18:11:15 <micahcowan> Ah, yeah, okay.
18:11:16 <roconnor> hi
18:11:43 <newsham> i dont use the error monad enough
18:13:15 <Olathe> @src filterM
18:13:15 <lambdabot> Source not found. I am sorry.
18:13:42 <Olathe> > filterM (const (Just True)) [1..4]
18:13:43 <lambdabot>   Just [1,2,3,4]
18:14:08 <newsham> filterM src http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html
18:14:11 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5shf58
18:14:51 <Olathe> Thanks.
18:16:40 <newsham> ?type filterM doesFileExist
18:16:41 <lambdabot> Not in scope: `doesFileExist'
18:16:51 <newsham> ?type filterM System.Directory.doesFileExist
18:16:52 <lambdabot> [FilePath] -> IO [FilePath]
18:18:01 <Olathe> http://www.google.com/search?q=site:www.haskell.org+inurl:(ghc+docs+latest+html+libraries+base+-src)+filterM
18:18:04 <Olathe> A useful URL.
18:40:02 <Saizan> anyone knows of a practical encoding of ML functors in haskell?
18:42:06 <dmwit> What's different between ML's functors and Haskell's Functor class?
18:43:26 <Saizan> ML functors are more like parametrized modules
18:44:10 <Saizan> so they don't have much in common
18:44:30 <paczesiowa> Saizan: Oleg has something on encoding functors in haskell, though I don't know if you could call it practical
18:46:08 <Saizan> paczesiowa: yup, found it, thanks
18:47:37 <dmwit> What, something Oleg did not practical?
18:47:57 <SamB_XP> dmwit: you mean ... oleg has done a practical thing ?
18:48:14 <Saizan> takusen
18:48:20 <dmwit> I accidentally the practical!
18:48:23 <mmorrow> he wrote a sweet looking NewerCGI.hs and FastCGI.hs
18:49:02 <mmorrow> (haven't spent the time to get them to work yet though...)
18:49:09 <mmorrow> if anyone does, let me know!!
18:49:18 <mmorrow> ;)
18:50:25 <mmorrow> ?google oleg haskell NewerCGI.hs
18:50:27 <lambdabot> http://okmij.org/ftp/Haskell/NewerCGI.hs
18:50:35 <mmorrow> ?google oleg haskell FastCGI.hs
18:50:36 <lambdabot> No Result Found.
18:50:45 <mmorrow> 1/2 ain't half bad
18:50:52 <mmorrow> err, i guess it is
18:51:47 <Saizan> based on delimited continuations?
18:51:51 <dmwit> heh
18:52:20 <SamB_XP> mmorrow: I didn't know he could do term programming too!
18:52:43 <mmorrow> CAN HAS TERMIO?
18:52:54 <SamB_XP> mm_freak: nice IPv6
18:53:14 <newsham> cbreak
18:53:18 <SamB_XP> mm_freak: only you seem not to be able to spell beef correctly
18:53:28 <mmorrow> KTHX
18:53:37 <SamB_XP> mm_freak_: hello?
18:54:19 <dmwit> dead 'affe -- it's actually a giraffe, not a beef
18:54:46 <mmorrow> Saizan: no not this one, i think that's his scheme thingamabob
18:55:08 <mmorrow> ?google oleg cgi delimited continuations scheme
18:55:11 <lambdabot> http://okmij.org/ftp/Computation/Continuations.html
18:55:11 <lambdabot> Title: Continuations and delimited control
18:55:39 <mmorrow> ah, ocaml
18:55:42 <mmorrow> http://okmij.org/ftp/Computation/Continuations.html#shift-cgi
18:55:42 <lambdabot> Title: Continuations and delimited control
18:56:03 <mmorrow> "nested transactions". hmm.
18:56:57 <mmorrow> wow, this looks really interesting...
18:57:45 <hackage> Uploaded to hackage: HRay 1.1.1
18:58:33 <FunctorSalad_> how do I get HXT to actually trace the DOM traversal? a_trace=4 doesn't seem to do that
18:58:57 <SamB_XP> FunctorSalad: what's a DOM?
18:59:15 <SamB_XP> isn't that the opposite of a SUB or something?
18:59:54 <mmorrow> FunctorSalad: unsafePerformIO, an MVar, and seq?
19:00:17 <FunctorSalad_> SamB_XP: hehehehehehe... document object model or something (= the xml tree)
19:00:45 <FunctorSalad_> mmorrow: uhm adding putStr's seems easier but I was looking for sth even easier ;-)
19:01:03 <mmorrow> yeah, or print out a msg ..
19:01:54 <FunctorSalad_> it's using these really high-tech arrows and I think one of them is ArrowIO ;-)
19:03:43 <FunctorSalad_> them arrows seem to actually be easier to compose than monads though
19:03:49 <shapr> yup
19:04:04 <pa-ching> Hi, about the exercises at http://hpaste.org/10509,
19:04:19 <pa-ching> There must be a cleaner way to do #4 than what I've got...
19:04:52 <pa-ching> currently it's > furry f (EitherLeft e) = EitherLeft $ either (Left . f) Right e
19:05:39 <paczesiowa> @src either
19:05:40 <lambdabot> either f _ (Left x)     =  f x
19:05:40 <lambdabot> either _ g (Right y)    =  g y
19:05:47 <paczesiowa> @info either
19:05:48 <lambdabot> either
19:05:52 <paczesiowa> :info either
19:06:17 <dmwit> ?info do { x <- foo; f x }
19:06:17 <lambdabot> foo >>= \ x -> f x
19:06:29 <pa-ching> Like pulling it out of EitherLeft and sticking it right back in after--I thought fmap would do, but EitherLeft isn't a functor, so...
19:06:57 <paczesiowa> you want to define Fluffy by using Functor?
19:07:35 <pa-ching> er not necessarily, just whatever makes it neat and concise
19:08:05 <pa-ching> In the first three exercises I got all of the solutions down to one symbol, so I'm just wonderin' if there's something comparable for the fourth
19:08:06 <paczesiowa> we define Fluffy because we want other code to look neat and concise
19:08:42 <paczesiowa> how did you do 2nd?
19:08:44 <pa-ching> fmap
19:08:54 <paczesiowa> that's just wrong...
19:08:56 <pa-ching> er wait
19:08:57 <pa-ching> was it
19:09:08 <pa-ching> yeah I think it was
19:09:13 <dmwit> pa-ching: It looks like those exercises are basically trying to teach you about Functors and Monads.
19:09:19 <pa-ching> First I had it as m >>= return . f
19:09:27 <dmwit> Defining "furry" is equivalent to defining "fmap".
19:09:31 <pa-ching> er, furry f m = m >>= return . f
19:09:37 <pa-ching> dmwit: Eheh yeah
19:09:40 <dmwit> So you should be fine with a little bit of pattern-matching, unwrapping and rewrapping, etc.
19:09:45 <pa-ching> Fair enough
19:09:53 <dmwit> That's the point of the Functor: to hide away the wrappings for you.
19:10:00 <dmwit> But *somebody* has to pay the piper. =)
19:10:05 <pa-ching> Aw.
19:10:14 <pa-ching> Hehe, alright.
19:10:20 <paczesiowa> pa-ching: if you want 4th to be nice (like 2nd) you have to define instance of functor for EitherLeft and then use fmap
19:10:38 <pa-ching> Yeah, that's what I thought, oh well heheh.
19:10:40 <paczesiowa> pa-ching: so that's exactly what you should do in the first place
19:11:37 <paczesiowa> it isn't exercise to find the same function in stdlib:>
19:11:50 <pa-ching> <:D
19:12:58 <paczesiowa> the weirdest was monad instance for functions
19:13:17 <paczesiowa> is it useful?
19:13:34 <pa-ching> None of this is useful ;D ;D
19:13:46 <paczesiowa> monads aren't useful?
19:14:01 <pa-ching> note the winking!
19:14:02 <FunctorSalad_> mmorrow: heh... so I did (arrIO putStrLn &&& failing_thingy) and the failure occurs before anything is printed
19:14:16 <mmorrow> hehe
19:14:25 <FunctorSalad_> is it running those in parallel?
19:14:34 <FunctorSalad_> (I only have one core though)
19:14:46 <paczesiowa> FunctorSalad_: you'd like to have path to the root node in every node?
19:14:54 <FunctorSalad_> is that the right way anyway or is there a better way?
19:14:56 <nha__> whats the best way to have an Int like data type that satisfies certain constraints like: t16x16  = 4^3*4
19:15:01 <mmorrow> maybe do (\x -> arrIO putStrLn x `seq` failing_thingy)
19:15:11 <mmorrow> maybe do (\x -> arrIO putStrLn x `seq` failing_thingy x)
19:15:21 <FunctorSalad_> @type seq
19:15:23 <lambdabot> forall a t. a -> t -> t
19:15:32 <mmorrow> i know nothing about HXT, so that's all i've got
19:15:33 <newsham> ?type arrIO
19:15:34 <lambdabot> Not in scope: `arrIO'
19:15:37 <FunctorSalad_> that looks like it should work
19:15:48 <FunctorSalad_> newsham: class (Arrow a) => ArrowIO a where
19:15:48 <FunctorSalad_>   arrIO :: (b -> IO c) -> a b c
19:16:19 <newsham> different than Kleisli?
19:16:26 <FunctorSalad_> (arrIO &&& id) >>> (id &&& failing_thingy) would be worth a try too
19:16:38 <FunctorSalad_> newsham: yeah it looks like Kleisli IO
19:16:58 <FunctorSalad_> (arrIO &&& id) >>> (id *** failing_thingy) -- better
19:17:20 <FunctorSalad_> newsham: it's a class rather than a constructor though
19:17:25 <Saizan> the HXT arrow actually has a lot of effects
19:17:51 <FunctorSalad_> effects=instances?
19:18:27 <mmorrow> nha_: the only way is the make a newtype wrapping Int, hide the constructor, then export "smart constructors"
19:18:33 <mmorrow> s/the/to/
19:18:34 <FunctorSalad_> "class (Arrow a, ArrowList a, ArrowTree a) => ArrowXml a where ..." :)
19:19:04 <FunctorSalad_> "class (Arrow a,       ArrowPlus a,       ArrowZero a,       ArrowApply a) => ArrowList a where" ...
19:19:41 <mmorrow> newtype MyInt = MyInt Int      mkMyInt :: Int -> Maybe MyInt ; mkMyInt n | ... n ... = Just (MyInt n) | otherwise = Nothing
19:20:12 <Saizan> i'm talking about the IOSArrow with is IO+State+[], iirc
19:20:27 <FunctorSalad_> Saizan: right, that oo
19:20:29 <FunctorSalad_> *too
19:21:28 <FunctorSalad_> it's a bit intimidating, especially since each has a dozen or more convenience functions
19:23:43 <Saizan> yeah, i also don't really get why they put all those methods in the class, when they just use the default definitions
19:24:34 <Saizan> it seems a bit too much to do just to allow optimizations in future instances
19:25:51 <FunctorSalad_> hmm maybe my putStrLn is buffered and the failing thing (read) quits the program before things can be printed?
19:27:31 <paczesiowa> switch putStrLn with some exception
19:28:26 <FunctorSalad_> paczesiowa: replacing with "pure error" doesn't do anything either
19:29:08 <FunctorSalad_> I guess it gets caught by HXT
19:29:39 <paczesiowa> pure error
19:29:46 <FunctorSalad_> :)
19:29:50 <aempirei> if xmonad isnt just an exercise in programming and an actual product, then it is the worst WM ever written
19:30:04 <FunctorSalad_> paczesiowa: processChildren ( getChildren >>> garbage ) ...
19:30:07 <paczesiowa> FunctorSalad_: maybe undefined instead of pure error?
19:30:15 <newsham> ae: thats not very nice
19:30:36 <FunctorSalad_> wait... I think that may be the bug
19:30:50 <FunctorSalad_> processChildren already descends to the children by itself, doesn't it?
19:31:05 <paczesiowa> FunctorSalad_: never used it
19:31:15 <paczesiowa> FunctorSalad_: only deep and sometimes getChildren
19:31:32 <newsham> ae: perhaps it has a different optimization function than you do
19:32:06 <FunctorSalad_> paczesiowa: undefined worked ;-)
19:32:37 <paczesiowa> FunctorSalad_: this is punishment for using construct such as "pure error"
19:32:48 <FunctorSalad_> :)
19:33:00 <FunctorSalad_> deep pure error
19:33:17 <paczesiowa> this is blasphemy and thou shall not do that
19:33:46 <paczesiowa> deep pure error sounds like a movie title
19:34:01 <newsham> ae: hows code?
19:35:35 <aempirei> good times
19:35:48 <aempirei> do u know if you can do data type definitions from the interpreter ghci
19:36:16 <paczesiowa> no
19:36:20 <newsham> you cant.   :load  :reload  and :m +module
19:36:34 <newsham> put the defs in a file
19:37:23 <newsham> or in hugs,  :e foo.hs   (does ghci do that now too?)
19:37:44 <aempirei> also is there a way to use '[]' as a prefix operator
19:37:58 <Saizan> what does :e do?
19:38:04 <paczesiowa> > [] 1
19:38:05 <newsham> open it in an editor, the :load it
19:38:06 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
19:38:13 <paczesiowa> :t []
19:38:14 <lambdabot> forall a. [a]
19:38:22 <newsham> > (:[]) 1
19:38:24 <lambdabot>   [1]
19:38:27 <aempirei> ok perfect
19:38:27 <aempirei> thanks
19:38:28 <newsham> > return 1 :: [Int]
19:38:29 <lambdabot>   [1]
19:38:33 <Saizan> :t [] :: [] a
19:38:34 <lambdabot> forall a. [a]
19:38:35 <aempirei> not that theres ANY point to that
19:38:48 <newsham> > 1 : []
19:38:50 <lambdabot>   [1]
19:38:55 <newsham> its basically consing 1 with []
19:39:29 <Saizan> [] alone is the empty list, so it doesn't take arguments
19:39:43 <aempirei> yeah it doesnt take arguments youre right
19:39:51 <aempirei> so its a function with 0 arguments so that makes sense then thanks
19:40:18 <aempirei> so would you call :[] a partial application
19:40:26 <newsham> http://www.thenewsh.com/~newsham/consMonster.jpg
19:40:30 <Twey> Aye, aempirei
19:40:34 <Twey> Or at least (:[])
19:40:36 <newsham> (:[]) is a "section"
19:40:38 <aempirei> ok cool
19:40:39 <newsham> like (+3)
19:40:41 <aempirei> yea
19:40:50 <aempirei> what hilariousness
19:40:56 <Twey> > ('b', 'c') :: String -- this doesn't work, does it?
19:40:57 <lambdabot>   Couldn't match expected type `String'
19:41:04 <Twey> TAM
19:41:45 <Olathe> @pl \(a, b) -> [a, b]
19:41:46 <lambdabot> uncurry ((. return) . (:))
19:42:22 <newsham> > ((. return) . (:)) 5 8
19:42:23 <lambdabot>   [5,8]
19:42:33 <Twey> return in list is :[], yes?
19:42:37 <newsham> yup
19:42:51 <newsham> > return 3 :: [Int]
19:42:52 <lambdabot>   [3]
19:43:22 <Olathe> > return 3 :: Either [Char] (Maybe Integer)
19:43:24 <lambdabot>       No instance for (Num (Maybe Integer))
19:43:24 <lambdabot>        arising from the literal `...
19:43:46 <Olathe> > return "3" :: Either [Char] Integer
19:43:47 <lambdabot>   Couldn't match expected type `Integer'
19:44:00 <paczesiowa> > return 3 :: ErrorT [Char] Maybe Integer
19:44:01 <lambdabot>       No instance for (Show (ErrorT [Char] Maybe Integer))
19:44:02 <lambdabot>        arising fro...
19:44:06 <aempirei> ok also if i have a recursive definition of a type, say data tree a = leaf a | branch a (tree a) (tree a)
19:44:09 <newsham> > return 3 :: Either [Char] Int
19:44:10 <lambdabot>   Right 3
19:44:16 <aempirei> is leaf a function or a type
19:44:35 <newsham> has to be   data Tree a = Leaf a | Branch a (Tree a) (Tree a)   (notice the upper case)
19:44:36 <FunctorSalad_> aempirei: a function (a special one, a constructor)
19:44:43 <newsham> an dthen Leaf is a constructor
19:44:46 <aempirei> ok
19:45:05 <Saizan> constructors are functions you can pattern match on
19:45:06 <newsham> the type is "Tree a"
19:45:11 <aempirei> ok
19:45:19 <aempirei> whats its typing
19:45:30 <aempirei> leaf a is a tree  ?
19:45:34 <newsham> Leaf 3 :: Tree Int
19:45:37 <aempirei> k
19:45:39 <aempirei> excellent
19:45:42 <Saizan> Leaf :: a -> Tree a
19:46:03 <newsham> Branch 5 (Tree 3) (Tree 2) :: Tree Int
19:46:07 <FunctorSalad_> GADTs are actually didactically better in that regard
19:46:18 <Saizan> s/Tree/Leaf/
19:46:25 <newsham> err yes
19:46:26 <newsham> sorry
19:47:01 <aempirei> oh i idnt realize types HAVE to have upper case first letter
19:47:06 <aempirei> even if you are user defined
19:47:09 <aempirei> you/it is
19:47:17 <newsham> yup.  also colon is considered upper case punctuation in that reguard
19:47:17 <aempirei> i just did that just cause i saw it that way
19:47:21 <aempirei> ok
19:47:24 <newsham> hence   a : [b,c]
19:47:33 <newsham> (:) is a constructor
19:47:40 <aempirei> so can you have user defined constructors that are using symbols
19:47:42 <aempirei> instead of dumb words
19:47:51 <newsham> data [] a = [] | a : ([] a)
19:47:53 <aempirei> like say instead of Leaf a i wanted it to look like ^a^
19:48:09 <newsham> has to start with colon, thats the only upper case punctuation
19:48:15 <FunctorSalad_> you can think of a constructor as a function that doesn't evaluate to anything simpler - it evaluates to a quotation of itself
19:48:16 <aempirei> AH
19:48:17 <aempirei> lol
19:48:22 <aempirei> ok gotta start with colon
19:48:25 <newsham> > 1 :+ 3
19:48:26 <lambdabot>   1.0 :+ 3.0
19:48:30 <aempirei> yee haw
19:48:32 <newsham> thats the constructor for complex numbers
19:48:51 <Olathe> @type 1 :+ 1
19:48:52 <lambdabot> forall t. (RealFloat t) => Complex t
19:49:01 <aempirei> ok but as infix operators it can just be mostly whatever
19:49:29 <newsham> infix constructors start with colon,  infix non-constructor functions start with other punctuation other than colon
19:49:52 <newsham> > let (@#$) = (+) in 5 @#$ 8
19:49:53 <lambdabot>   13
19:50:20 <aempirei> like let ((^.^)) = "chinese"
19:50:21 <FunctorSalad_> newsham: you mean : is the only punctuation constructor?
19:50:28 <aempirei> that works
19:50:31 <aempirei> thats so funny
19:50:50 <aempirei> oh newsham i added a .wav header on my synth output
19:50:53 <Axman6>  let ((^.^)) = "chinese" in (^.^)
19:50:54 <aempirei> so it generates valid wav files now
19:50:58 <Axman6> > let ((^.^)) = "chinese" in (^.^)
19:50:59 <lambdabot>   "chinese"
19:51:43 <aempirei> i dont understand in yet i havent gotten that far in the tutorials
19:51:45 <dmwit> FunctorSalad_: No, it just means that ':' is considered to be "upper-case" punctuation.
19:52:02 <newsham> functor: no, just has to start with colon
19:52:19 <Olathe> > map isUpper "T:+!@#$%^&&"
19:52:20 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False]
19:52:32 <newsham> aempire: cool.
19:52:36 <Olathe> How do you get the uppercase punctuation ?
19:52:48 <Saizan> aempirei: "in" is part of let <definitions> in <expression>, like let x = 1; y = 2 in x + y
19:52:51 <Twey> Axman6:
19:53:02 <Twey> > let (^.^) = "chinese" in (^.^)
19:53:03 <lambdabot>   "chinese"
19:53:26 <dmwit> Olathe: It's just a joke.
19:53:32 <Axman6> Twey: i was just using what aempirei was using ;)
19:53:36 <dmwit> Olathe: The rule is that constructors must start with an upper-case letter.
19:53:39 <Twey> Ah-huh :)
19:54:00 <dmwit> Olathe: So, for the purposes of infix constructors, they say that ':' is upper-case, to satisfy the rule. =)
19:54:04 <Olathe> Oh.
19:54:08 <aempirei> oh ok i see
19:54:26 <aempirei> its jsut for lets
19:54:26 <Twey> > isUpper 'A'
19:54:28 <lambdabot>   True
19:54:30 <Twey> > isUpper ':'
19:54:31 <lambdabot>   False
19:54:36 <Twey> Aw :)
19:54:38 <newsham> let x = 5 in (x + 3)    is sort of like:   (\x -> x + 3) 5
19:54:42 <aempirei> yeah
19:54:42 <newsham> > (\x -> x + 3) 5
19:54:44 <aempirei> i see that
19:54:44 <lambdabot>   8
19:54:47 <aempirei> perfect
19:55:01 <dmwit> The only real difference is sharing. =)
19:55:16 * Axman6 should get back to his java assignment before he gets distracted and goes back to HOpenGL -_-
19:55:21 <ddarius> > let x = x in x
19:55:28 <ddarius> > (\x -> x) x
19:55:29 <lambdabot>   x
19:55:33 <dmwit> Hah!
19:55:36 <lambdabot>   thread killed
19:55:39 <Axman6> heh
19:55:42 <newsham> > let x = 1 : x in x
19:55:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:55:46 <dmwit> Take that, ddarius.  You thought x wouldn't be in scope...
19:55:55 <newsham> it allows some sort of recursion, though
19:55:56 <sjanssen> > (let x = () in undefined) `seq` ()
19:55:57 <lambdabot>   mueval: Prelude.read: no parse
19:55:58 <lambdabot>  mueval: *** Exception: Prelude.undefined
19:56:01 <Olathe> > let (+) a b = say "thread killed" in 1 + 2
19:56:03 <lambdabot>   thread killed
19:56:04 <ddarius> Doesn't really matter as long as the results are different.
19:56:24 <sjanssen> > ((\x -> undefined) ()) `seq` ()
19:56:26 <lambdabot>   mueval: Prelude.read: no parse
19:56:26 <lambdabot>  mueval: *** Exception: Prelude.undefined
19:56:29 <Axman6> (\a -> let x = a : x in x) '.'
19:56:29 <Twey> > x == x
19:56:30 <lambdabot>   True
19:56:36 <Axman6> > (\a -> let x = a : x in x) '.'
19:56:37 <lambdabot>   ".............................................................................
19:57:01 <aempirei> oh ok it just clicked what a constructor function is now
19:57:10 <aempirei> it constructs a given type
19:57:16 <Axman6> yup
19:57:19 <ddarius> @src Maybe
19:57:19 <lambdabot> data Maybe a = Nothing | Just a
19:57:21 <ddarius> :t Just
19:57:22 <aempirei> seems to obvious
19:57:22 <lambdabot> forall a. a -> Maybe a
19:57:24 <ddarius> :t Nothing
19:57:25 <lambdabot> forall a. Maybe a
19:57:26 <Axman6> > Just 10 -- like that
19:57:28 <lambdabot>   Just 10
19:57:43 <newsham> > let f Nothing = 5; f (Just x) = x + 5 in f (Just 10)
19:57:44 <lambdabot>   15
19:57:53 <Axman6> :t fromJust
19:57:53 <newsham> unlike most funcitons, you can pattern match on constructors
19:57:54 <lambdabot> forall a. Maybe a -> a
19:58:04 <Axman6> fromJust (Just 10)
19:58:12 <Axman6> > fromJust (Just 10)
19:58:13 <lambdabot>   10
19:58:19 <Olathe> @let kill = const (say "thread killed")
19:58:22 <Axman6> rawr, i should stop that -_-
19:58:22 <lambdabot>  Defined.
19:58:29 <aempirei> it was just boggling my mind yesterday when i had a new recursive type defined like Tree, and there was these Leaf and Branch things that i felt like werent really defined explicitly in any way except in the data type definition and they looked like functions but i had no real idea
19:58:33 <Axman6> > fromJust Nothing
19:58:34 <lambdabot>   mueval: Prelude.read: no parse
19:58:34 <lambdabot>  mueval: *** Exception: Maybe.fromJust: Noth...
19:58:41 <Olathe> > kill $ last [1..]
19:58:42 <lambdabot>   thread killed
19:58:52 <aempirei> and then it was even weirder when i could define some tree and do kinda functions like recurse through the tree and do stuff
19:58:59 <aempirei> i was just afraid the end times were near
19:59:03 <mmorrow> , fromJust Nothing
19:59:04 <lunabot>  luna: no output
19:59:06 <newsham> weirder is when you can create infinite trees :)
19:59:14 <newsham> ie the tree of all future possible chess moves
19:59:16 <aempirei> yeah
19:59:17 <mmorrow> i've gotta parse errors better
19:59:23 <aempirei> its mindboggling
19:59:38 <aempirei> i mean i get how its ok and you can do stuff on them and pass them around due to laziness
19:59:38 <aempirei> etc
19:59:43 <Axman6> i've made trees like that
19:59:45 <mmorrow> newsham: wouldn't it be a graph?
19:59:49 <Axman6> Tip: don't make them strict
20:00:03 <newsham> mmorrow: you're optimizing
20:00:04 <aempirei> well if you associate the time t or nth move to each chess board layout
20:00:06 <aempirei> then its a tree
20:00:08 <aempirei> not a graph
20:00:08 <mmorrow> newsham: heh
20:00:10 <Axman6> that was the reason i bought 4GB of RAM foir my macbook pro :P
20:00:10 <Saizan> let x = ex; y = ey in e ===  (\(x,y),... -> e) $ fix (\(x,y,...) -> (ex,ey,...)), right?
20:00:36 <Olathe> > (last [1..]) :: Word8
20:00:37 <lambdabot>   255
20:00:44 <mmorrow> aempirei: but multiple sequences of different moves can lead to identical board configs
20:00:45 <Axman6> heh
20:00:47 <aempirei> just cause the  current state is the same as another node in the tree, doesnt mean its the SAME node
20:00:48 <Olathe> > (last [2,1..]) :: Word8
20:00:49 <lambdabot>   0
20:01:04 <mmorrow> aempirei: why not?
20:01:18 <Axman6> yeah, why not?
20:01:23 <aempirei> i guess its just a matter if you want it to be or not
20:01:34 <newsham> [16:57] < newsham> mmorrow: you're optimizing
20:01:38 <Axman6> it's more efficient if it is i think
20:01:39 <aempirei> by saying they are different nodes, then you can back track
20:02:01 <Axman6> hmm, i see what you mean
20:02:04 <mmorrow> newsham: i suppose
20:02:20 <Axman6> but, back tracking is also a next move
20:02:22 <aempirei> in terms of compactness th
20:02:23 <aempirei> tho
20:02:29 <aempirei> yeah they are 'equvalent' in some way
20:02:30 <mmorrow> aempirei: but if it's a graph, you can backtrack to different pasts :)
20:02:50 <Axman6> interesting, for all moves, moving back is still a next step
20:03:08 <Axman6> i'd never thought of that before... though it's not something i've ever realy thought about at all
20:03:29 <newsham> > let t x = Node x [t (2*x), t (2*x+1)] in t 0
20:03:30 <Axman6> l*
20:03:30 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 0, subForest = [Node {r...
20:04:09 <newsham> > let t x = Node x [t (2*x), t (2*x+1)] in t 1
20:04:11 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {r...
20:04:23 <aempirei> i think were jsuyt talking a bout the datastructure we're storing chess games in at this point
20:04:40 <newsham> > let t x = Node x [t (2*x), t (2*x+1)] in flatten $ t 1
20:04:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
20:05:01 <Axman6> newsham: i was working on a problem kind of like that, but it was let t x = Node x [t (2*x), t (x `div` 10)] in t 1
20:05:12 <Axman6> >let t x = Node x [t (2*x), t  (x `div` 10)] in t 1
20:05:22 <Axman6> > let t x = Node x [t (2*x), t  (x `div` 10)] in t 1
20:05:24 <lambdabot>   Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {r...
20:05:49 <Axman6> had to find the shortest route to (originally) all the numbers from 1 to 21
20:05:51 <mmorrow> unfoldForest* are crazyness
20:05:51 <newsham> axman: weird, what was it for?
20:05:59 <mmorrow> , let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in concat (unfoldForestM_BF (f 4) [0]::[Forest Int])
20:05:59 <lunabot>  [Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {r...
20:06:20 <mmorrow> , let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in text . drawForest . (fmap . fmap) show . concat (unfoldForestM_BF (f 4) [0]::[Forest Int])
20:06:21 <lunabot>      Couldn't match expected type `a -> f (f1 a1)'
20:06:29 <mmorrow> , let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in text . drawForest . (fmap . fmap) show . concat $ (unfoldForestM_BF (f 4) [0]::[Forest Int])
20:06:30 <lunabot>  0
20:06:30 <lunabot>  |
20:06:30 <lunabot>  +- 1
20:06:59 <Axman6> the problem is someone's given you a calculator with only two buttons: (*2) and (`div` 10) (drop the last digit)
20:07:27 <Axman6> and you have to get, like i said, from 1 to [1..21]
20:07:39 <Olathe> Ah hah !
20:07:44 <newsham> heh, fun.
20:07:48 <Axman6> yeah
20:08:00 <Olathe> \Let's see.
20:08:09 <Axman6> i have a nice parallel way of doing it atm. kinda fast, but i think it could be a lot better
20:08:12 <newsham> sounds like old asm optimizations people used to do.. like   (2*x+x)*2  for multiply by 10
20:08:15 <newsham> using shifts for 2*
20:08:26 <mmorrow> leet!
20:08:31 <Axman6> that's awesome
20:08:58 <Twey> newsham: *wince*
20:09:06 <Twey> Real Programmers, huh :-P
20:09:08 <Axman6> > map (\x -> (2*x+x)*2) [1..10]
20:09:10 <lambdabot>   [6,12,18,24,30,36,42,48,54,60]
20:09:15 * ddarius hearts assembly microoptimizations.
20:09:18 <Axman6> maybeh not
20:09:24 <Twey> Heh
20:09:53 <paczesiowa> it doesn't multiply by 10 but hey! it's fast!
20:10:03 <Axman6> paczesiowa: so who cares!
20:10:05 <newsham> > map (\x -> (2*2*x+x)*2) [1..10]
20:10:06 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
20:10:11 <newsham> forgot an extra 2*
20:10:13 <Axman6> ah, there we go
20:10:19 <Axman6> that's very nice
20:10:20 <newsham> 4x+x = 5x
20:10:30 <Axman6> ah, yes
20:10:37 <Axman6> i was going to figure it out, but meh :P
20:10:41 <paczesiowa> is it really faster?
20:10:44 <Axman6> not enough sleep -_-
20:10:49 <Axman6> paczesiowa: should be
20:11:14 <Twey> Not on any decent modern compiler, I'm sure, paczesiowa
20:11:37 <Twey> This is what compilers are for :)
20:11:54 <newsham> pacz: 6502 has no multiply instruction, for example.
20:11:58 <Axman6> i'd guess they might use things like that. i've seen that compilers will try and find multiplications where they can bit shift
20:12:02 <newsham> and only single-shift ops.
20:12:06 <Pseudonym> Nor do first-generation SPARCs.
20:12:11 <newsham> you can make a shift-adder for generalized multiplication
20:12:29 <aempirei> i like the function composition function
20:12:30 <newsham> but specialized multiplier is better if you're doing lots of *10's
20:12:31 <Pseudonym> First-generation SPARC did have a shift-and-conditional-add instruction, though.
20:12:32 <aempirei> thats so sweet and mathy
20:12:38 <Pseudonym> SO you could unroll the multiplication loop.
20:12:45 <newsham> haskell: sweet and mathy
20:12:46 <Twey> http://www.overcaffeinated.net/comic/date/20030105
20:12:47 <lambdabot> Title: Overcaffeinated
20:12:48 <ddarius> paczesiowa: Not anymore.
20:12:48 <ddarius> Of course, some processors didn't even have a multiplication operation.
20:13:06 <Axman6> i haven't actually found somewhere where i could obviously use (.) actually. i must be doing something wrong
20:13:17 <Axman6> i always eng up using $
20:13:22 <Axman6> end*
20:13:25 <newsham> 6502 didnt even have word sized addition.
20:13:43 <newsham> so if you wanted word multiplies, you manually did loops of shift adds with multiple instructions per add
20:13:50 <Saizan> Axman6: do you ever have code like f $ g $ x ?
20:13:52 <aempirei> yeah dude loops on 6502 were 8bit
20:14:01 <Twey> Axman6: What?  Ever?  :)
20:14:15 <Twey> When you have a function like f x = g (y x)
20:14:18 <mmorrow> , (fmap . fmap) show . fmap (take 2) $ [[0..],[1..]]
20:14:19 <lunabot>  [["0","1"],["1","2"]]
20:14:19 <Twey> It becomes f = g . y
20:14:21 <Axman6> Saizan: i tend to have things like f x $ g y $ z
20:14:24 <aempirei> you need 2 loops to clear the screen since there were 40*24 bytes on screen at once
20:14:36 <newsham> axman: it shows up a lot more often if you make your functions points-free
20:14:41 <Saizan> Axman6: === f x . g y $ z
20:14:51 <Axman6> yeah :\
20:14:54 <Twey> (f .) . g
20:15:04 <aempirei> whats the dollar sign
20:15:14 <Axman6> @src ($)
20:15:15 <lambdabot> f $ x = f x
20:15:16 <newsham> dollar sign works like parenthesis sort of
20:15:27 <newsham> f $ a b c d ef == f ( a b c d e f)
20:15:33 <Axman6> > f $ g x :: Expr
20:15:33 <Twey> It's very-low-precedence function application
20:15:35 <lambdabot>   Add a type signature
20:15:37 <mmorrow> @pl \g f x y -> g (f x y)
20:15:37 <lambdabot> (.) . (.)
20:15:40 <Axman6> -_-
20:15:52 <Twey> So foo $ bar === (foo) (bar) for almost all values of foo and bar
20:15:54 <aempirei> oh thats funny
20:15:56 <aempirei> what lazy people
20:16:03 <Axman6> ?
20:16:04 <mmorrow> Axman6: i didn't intend that one...
20:16:11 <Twey> It's to stop our code ending with ))))))))
20:16:12 <Twey> :)
20:16:19 <newsham> its useful for long pipelines of commands
20:16:30 <newsham> f $ g $ h $ i $ j x
20:16:31 <Axman6> aempirei: yeah it's a way of removing parens, increasing readability
20:16:33 <Twey> And one command applied to a whole long line
20:16:33 <aempirei> thats totally useful
20:16:36 <Twey> Like lift
20:16:37 <aempirei> but lazy
20:16:37 <newsham> instead of  f (g (h (i (j x)))
20:16:48 <Twey> aempirei: Well duh
20:16:49 <newsham> or    f . g . h . i . j $ x
20:16:52 <Axman6> aempirei: this is haskell, it's supposed to be lazy ;)
20:16:57 <Twey> All good programmers (and programming languages) are lazy :-P
20:17:05 <aempirei> i ahd a teacher one time that said that precendence is the worst idea ever in the world so he taught the whole mathematical logic class with masive amounts of parenthesis
20:17:12 <Twey> Heh
20:17:15 <Twey> It's true, in a way
20:17:25 <Twey> It does make things more complicated
20:17:32 <Twey> But it also makes them easier to read
20:17:33 <aempirei> well half of the calss actualyl was prefix notation
20:17:34 <paczesiowa> but it looks better
20:17:37 <Axman6> reduced typing time means more coding time ;)
20:17:38 <aempirei> the other half was massive parenthesis
20:17:38 <Twey> (once you know the rules)
20:17:44 <mmorrow> @pl \x y g f -> g (f x y)
20:17:44 <lambdabot> (flip (.) .) . flip . flip id
20:17:47 <mmorrow> crap
20:17:52 <Twey> Heh
20:17:52 <mmorrow> @pl \x y f g -> g (f x y)
20:17:53 <lambdabot> ((flip id .) .) . flip . flip id
20:17:55 <aempirei> appplying = sign as prefix notation is so goofy lookin
20:18:06 <aempirei> it just violates the whole spirit of the equal sign
20:18:12 <Twey> Prefix =?  In mathematics?
20:18:16 <aempirei> yea
20:18:24 <Saizan> =(a,b) ?
20:18:25 <aempirei> also -> in math
20:18:27 <aempirei> prefix
20:18:27 <aempirei> yea
20:18:33 <mmorrow> i'm trying to get   go x y = g (f x y) ==> go x = g . f x ==> go = (g .) . f
20:18:37 <aempirei> it was a logic class, liek compactness, completeness, soundness
20:18:39 <aempirei> dumb shit like that
20:18:41 <Twey> Your professor was nuttier than a mad squirrel's Winter horde
20:18:41 <aempirei> super dorky stuff
20:18:50 <Saizan> heh, taken from some prolog implementation, maybe :)
20:19:03 <Twey> Or a Lisp
20:19:05 <Twey> But still
20:19:15 <Axman6> aempirei: this crowd is full of people who probably do that sort of stuff for a living...
20:19:21 <aempirei> yeah im sure
20:19:29 <Twey> Heh
20:19:36 <dejones> http://www.haskell.org/haskellwiki/Obfuscation -- The Example of Haskell obfuscation is just ridiculous, hehe.
20:19:38 <lambdabot> Title: Obfuscation - HaskellWiki
20:19:57 <Axman6> when's 6.10 due out by the way?
20:20:04 <Twey> Soon
20:20:05 <dejones> Axman6: Soon.
20:20:13 <Twey> Heh
20:20:16 * dejones wishes his code would have made it in...
20:20:20 <Axman6> hours or weeks? :P
20:20:23 <dejones> Days?
20:20:31 <Axman6> no compromises!
20:20:34 <Twey> I get the feeling it's a few days, aye
20:20:37 <dejones> I'm not certain though, really.
20:20:41 * Twey nods.
20:21:01 <dejones> In the #ghc IRC meeting, there was not a lot to discuss for the new release, so it should be soon.
20:21:10 <Axman6> excellent
20:21:31 <dejones> I'm very new to GHC, so I could be wrong.  Just my interpretation of the events.  ;)
20:21:32 <Axman6> i was about to say 'i hope hipe works again'... then i remembered what i was talking about
20:21:45 <Axman6> what was your code dejones?
20:21:46 <newsham> keeping up with ghc is worse than optimizing a gentoo system
20:22:01 <dejones> Axman6: I'm working on parallel profiling support in GHC RTS.
20:22:01 <aempirei> erlang hipe ?
20:22:09 <Axman6> aye
20:22:14 <aempirei> man
20:22:20 <aempirei> you guys are killin me
20:22:21 <dejones> Axman6: Still much more work to do though, particularly analysis.
20:22:22 <Axman6> dejones: ah, excellent
20:22:28 <ddarius> newsham: Your GHC will be 10 times faster!!! if you compile it yourself
20:22:29 <dejones> aempirei: ?
20:22:41 <Axman6> yeah, what're you on about aempirei?
20:22:49 <newsham> ddarius: gonna have to rebuild all my libs all over again
20:23:30 * Saizan never upgraded to 6.8.3
20:23:35 <Axman6> :O
20:23:44 <ddarius> Saizan: Me neither.
20:24:15 <Axman6> dejones: sounds good, i hope it's not too long until we get to see it :) what sort of stuff would/does it do?
20:25:34 <newsham> when is someone gonna write a high perf map/reduce/list homomorphism system in haskell
20:26:15 <Saizan> homomorphism?
20:26:17 <Axman6> newsham: what do you mean?
20:26:51 <newsham> something that evalutes Monoid m => (a -> m) -> [a] -> m
20:27:14 <newsham> by distributing the (a -> m) to many nodes (that contain all the [a]'s) and then reducing to m
20:27:53 <newsham> like google's sawzall and similar to google's map/reduce and hadoop
20:28:21 <Saizan> distributed?
20:28:34 <newsham> on several thousand machines concurrently
20:28:36 <Saizan> oh, yeah, misread
20:29:02 <sjanssen> @hoogle foldMap
20:29:07 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:29:09 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
20:29:23 <newsham> sjanssen: foldMap isnt distributed
20:29:40 <sjanssen> newsham: right
20:29:54 <sjanssen> newsham: I suppose the big problem with distribution is distributing the function argument
20:30:00 <dejones> Axman6: The current goal is to provide timeline graphs of the threads of execution, as in, what states (running, blocked, etc.) the threads entered and for how long.
20:30:18 <Axman6> ah, righto
20:30:21 <ddarius> I suspect that pretending that such a function was pure would be more trouble than benefit.
20:30:25 <newsham> sjanssen: the systems are typically coupled with a large distributed file system, the data is already distributed on thousands of nodes, and you move the computation to where the data is
20:30:33 <sjanssen> and there aren't any ready made tools for distributing Haskell
20:30:39 <Axman6> a work/sparks ratio would be useful
20:30:46 <sjanssen> newsham: then [a] is wrong too
20:31:01 <newsham> sjanssen: you're reading it too literally
20:31:05 <sjanssen> newsham: my point is that we can't serialize functions -- this would require special support in the compiler
20:31:07 <dejones> Axman6: Yah, I believe one of the states is that a spark is created actually...
20:31:25 <Axman6> righto
20:31:27 <newsham> you write your program as (a -> m) and you get back m.
20:31:31 <dejones> Axman6: Well, not exactly a state, but you would see another thread was created... something like that, heh.
20:31:42 <newsham> sjanssen: you dont need to serialize functions.
20:31:56 <newsham> you can send binaries.
20:32:01 <dejones> Axman6: I haven't done much analysis yet since it has taken a long time to find a suitable visualization platform for the parallel profiling data.
20:32:16 <mmorrow> or some src/program representation
20:32:17 <Axman6> fair enough
20:32:22 <Saizan> yeah, you can just have the same binary on every node, like happs does
20:32:37 <dejones> Well, back to work for me.  :)
20:32:39 <dejones> Cya.
20:32:40 <newsham> you have a service running on each node that receives jobs and runs them
20:32:50 <ddarius> newsham: Perhaps once NDP has matured more a distributed version will be developed.
20:32:58 <newsham> and a master program which distributes the work to selected nodes, monitors their progress, restarts work as nodes fail, and collects results
20:33:05 <newsham> ddarius: ndp?
20:33:15 <Taggnostr> is there a way to do Prelude> :m + Data.Char; chr 65 on the same line?
20:33:35 <mmorrow> Data.Char.chr 65
20:33:53 <ddarius> @where ndp
20:34:00 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:34:21 <Taggnostr> thanks mmorrow
20:35:10 <newsham> ddarius: isnt that more focused on shared memory systems?
20:35:51 <ddarius> Currently.  There's nothing particularly shared memory about it.  No more than your "map/reduce" is.
20:36:08 <newsham> i will have to read more
20:36:10 <newsham> danke
20:36:27 <Taggnostr> when I have foo (bar x) and I want to use the '.' operator, do I have to do (foo . bar) x?
20:36:43 <newsham> ?src (.)
20:36:43 <lambdabot> (f . g) x = f (g x)
20:36:52 <Taggnostr> or foo . bar $ x
20:36:53 <Taggnostr> right?
20:37:01 <paczesiowa> yes
20:37:02 <ivanm> is there a function in the libs that already does [[f a b | a <- as] | b <- bs] ?
20:37:11 <ivanm> I seem to recall seeing one before, but can't find it :s
20:37:13 <newsham> tagg: you just gave the definition of . :)
20:37:27 <newsham> ivanm:  liftM2
20:37:31 <newsham> err.. wait, not quite
20:37:32 <ivanm> newsham: *nod*
20:37:46 <ivanm> @ty liftM2
20:37:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:37:53 <newsham> liftM2 will return it as a flat list
20:37:57 <ivanm> ahhh
20:38:18 <sjanssen> @. pl undo [[f a b | a <- as] | b <-  bs]
20:38:18 <lambdabot> ((as >>=) . flip flip [] . ((:) .) . flip f) `fmap` bs
20:38:32 <Taggnostr> ok, what if I have "foo x (bar y)", is there a way to use the . here?
20:38:36 <ivanm> pl understands list comprehensions?
20:38:42 <ivanm> Taggnostr: foo x . bar $ y
20:38:44 <mmorrow> foo x . bar
20:38:45 <ddarius> @unpl (.) (.)
20:38:45 <lambdabot> (\ b c e f -> b c (e f))
20:38:46 <sjanssen> ivanm: note the composition with undo
20:39:04 <Taggnostr> uhm
20:39:10 <ivanm> @help undo
20:39:10 <lambdabot> undo <expr>
20:39:10 <lambdabot> Translate do notation to Monad operators.
20:39:10 <newsham> tagg:   (foo x . bar) y ==   (foo x) (bar y)
20:39:20 <mmorrow> \y -> foo x . bar $ y
20:39:20 <ivanm> list comprehension == do notation? :o
20:39:37 <sjanssen> ivanm: there is a correspondence, yes
20:39:44 <ivanm> *nod*
20:39:47 <Taggnostr> isn't that a different thing? in my example foo accept 2 args, x and the result of (bar y)
20:39:56 <ddarius> ivanm: List comprehensions used to be monad comprehensions.
20:39:57 <mmorrow> same thing :)
20:40:05 <newsham> tagg: currying
20:40:10 <ivanm> ddarius: why did they restrict it to lists then?
20:40:19 <newsham> > ((+) 1) 2
20:40:23 <lambdabot>   3
20:40:42 <Taggnostr> uhm, it worked, I still have to understand it better
20:40:45 <newsham> apparently there was a version of monad-comprehensions and they decided not to kee pit?
20:40:57 <newsham> tagg:   f a b == (f a) b
20:41:10 <ddarius> newsham: Haskell 1.4 had monad comprehensions.
20:41:16 <newsham> ?go comprehending monads
20:41:20 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html
20:41:20 <lambdabot> Title: Wadler: Monads
20:41:24 <ivanm> kee pit? what is "kee"-ing that they did it to this pit character? :p
20:41:40 <ddarius> ivanm: The only reason I've heard was that it led to confusing type errors for beginners.
20:41:44 <ivanm> *nod*
20:41:54 <ivanm> and do-notation was available anyway?
20:42:03 <ddarius> Many people think it was a mistake.
20:42:35 <Taggnostr> newsham, I have a line of code full of nested () and I'm trying to eliminate them and use the . notation
20:42:49 <newsham> you could more directly use $'s
20:42:58 <ddarius> Taggnostr: There are only so many functions you can simplify with just (.)
20:43:04 <newsham> foo x (bar y) == foo x $ bar y
20:43:09 <ddarius> Well "simplify"
20:43:49 <mmorrow> @pl \x y -> foo x (bar y)
20:43:50 <lambdabot> (. bar) . foo
20:44:15 <newsham> foo x . bar $ y
20:44:48 <mmorrow> , (. negate) . (+) $ 2 3
20:44:49 <lunabot>      No instance for (Show (a -> a))
20:44:51 <Taggnostr> what if I have bar z (foo x (bar y)), is it bar z . foo x $ bar y ?
20:45:00 <mmorrow> , (. negate) . (+) $ 2 $ 3
20:45:01 <lunabot>      No instance for (Show (b -> b))
20:45:02 <newsham> z $ foo x $ bar y
20:45:12 <mmorrow> @type (. negate) . (+)
20:45:13 <lambdabot> forall a. (Num a) => a -> a -> a
20:45:16 <newsham> thikn of "$" as parenthesis till end of line (often)
20:45:16 <Olathe> @pl bar z (foo x (bar y))
20:45:16 <lambdabot> bar z (foo x (bar y))
20:45:23 <ivanm> Taggnostr: yes, or equivently z . foo x . bar $ y
20:45:26 <mmorrow> , ((. negate) . (+)) 2 3
20:45:26 <lunabot>  -1
20:45:48 <Taggnostr> uhm
20:45:53 <Twey> @pl \x y z -> bar z (foo x (bar y))
20:45:54 <lambdabot> (flip bar .) . (. bar) . foo
20:46:06 <newsham> its easier to think of it backwards  "take y, feed it to (foo x), then feed it to z"
20:46:31 <newsham> where (foo x) is partially applied
20:47:02 <newsham> oops.. "feed it to bar, then that output to foo x, then that output to z"
20:47:04 <newsham> i forgot "bar"
20:47:28 <mmorrow> > (+) 1 . (*) 20 . flip subtract 40 . id $ 1
20:47:30 <lambdabot>   781
20:48:07 <mmorrow> > 1 + (20 * (40 - 1))
20:48:09 <lambdabot>   781
20:48:19 <Taggnostr> > (:) 3 [2,1]
20:48:21 <lambdabot>   [3,2,1]
20:48:22 <newsham> id :)
20:48:37 <mmorrow> heh
20:49:19 <Olathe> > (*2).(`div` 10).(*2).(`div` 10).(*2).(*2).(*2).(*2).(*2).(*2).(*2).(*2) $ 1
20:49:20 <lambdabot>   10
20:51:02 <Taggnostr> I did it \o/
20:51:15 <newsham> > let x = ((*2).); d = ((`div` 10).) in x d x d x x x x x x x x id 1
20:51:16 <lambdabot>       Occurs check: cannot construct the infinite type: a = a1 -> a -> b
20:51:16 <lambdabot>     ...
20:52:44 <newsham> hrmm.. need it to assoc the other way
20:52:49 <Taggnostr> so foo a b is the same of foo a $ b?
20:52:53 <Olathe> 11 is a bit slow.
20:52:58 <newsham> ?src ($)
20:52:59 <lambdabot> f $ x = f x
20:52:59 <dmwit> Taggnostr: In most cases, yes.
20:53:24 <dmwit> Taggnostr: The only difference is when there's precedence differences.
20:53:51 <newsham> > let x = (*2); d = (`div` 10) in x.d.x.d.x.x.x.x.x.x.x.x $ 1
20:53:52 <lambdabot>   10
20:54:18 <newsham> olathe: what was the longest sequence for [1..21]?
20:54:26 <Olathe> Oh, it's still working on 11.
20:55:39 <Taggnostr> ?src (.)
20:55:39 <lambdabot> (f . g) x = f (g x)
20:56:03 <sbahra> ?src (*)
20:56:03 <lambdabot> Source not found. Maybe you made a typo?
20:57:48 <newsham> > length $ takeWhile (/= "11") $ map (take 2 . show) $ iterate (*2) 1
20:57:49 <lambdabot>   50
20:58:28 <newsham> > 2^50 `div` 10^14
20:58:29 <lambdabot>   11
20:58:36 <newsham> do you need minimal answers?
20:59:06 <Olathe> > head $ dropWhile (\a -> (/="11").take 2.show $ a) $ iterate (*2) 1
20:59:07 <lambdabot>   1125899906842624
20:59:33 <Taggnostr> what about this:
20:59:37 <Taggnostr> > map (*2) (reverse [3,2,1])
20:59:38 <Olathe> > head $ dropWhile (\a -> (/="11").take 2.show $ snd a) $ zip (iterate (*2) 1) [0..]
20:59:38 <lambdabot>   [2,4,6]
20:59:40 <lambdabot>   (2048,11)
20:59:46 <Taggnostr> > map (*2) . reverse $ [3,2,1]
20:59:47 <lambdabot>   [2,4,6]
20:59:49 <Taggnostr> > map (*2) $ reverse $ [3,2,1]
20:59:51 <lambdabot>   [2,4,6]
20:59:54 <Olathe> > head $ dropWhile (\a -> (/="11").take 2.show $ fst a) $ zip (iterate (*2) 1) [0..]
20:59:55 <lambdabot>   (1125899906842624,50)
21:00:02 <Taggnostr> why here I can use wither . or $?
21:00:36 <Taggnostr> either*
21:00:42 <Olathe> Taggnostr: Do you understand what both mean ?
21:00:59 <Taggnostr> not really
21:01:00 <newsham> f . g $ x == f (g x);     f $ g $ x == f (g (x))
21:01:10 <newsham> they both end up being the same thing
21:01:25 <Olathe> Taggnostr: Well, with $, it figures out the left and the right and then uses them together.
21:01:36 <Olathe> Taggnostr: With ., it combines two functions into one.
21:02:32 <Taggnostr> so it creates a new functions that does the map (*2) and the reverse and then it calls it with [3,2,1] as arg?
21:02:50 <Taggnostr> with '.' I mean
21:02:52 <Olathe> Taggnostr: Yes.
21:03:03 <newsham> thats one way of thinking about it.
21:03:09 <the_unmaker> hey folks
21:03:10 <newsham> youcan also just think of it as a rewriting rule.
21:03:13 <newsham> ?src (.)
21:03:14 <lambdabot> (f . g) x = f (g x)
21:03:29 <the_unmaker> any app that can do clustering of commodity hardware for number crucnching?
21:03:32 <newsham> your f was (map (*2)) your g was (reverse) and your x was [3,2,1]
21:03:46 <Taggnostr> instead with $ it calls reverse with [3,2,1] as arg and then map (*2) with reverse [3,2,1] as arg
21:03:50 <newsham> and that src says that you can write the left hand side like the right hand side or vice versa
21:04:18 <Taggnostr> that makes sense
21:04:59 <Olathe> I'm not sure which $ is done first.
21:05:02 <newsham> so the rewrite rule says:   map (*2) . reverse $ x = map (*2) (reverse x)
21:05:09 <Taggnostr> so the result is the same here, but is . better than $ or vice versa? do I have to alwas prefer one of the two or it depends on the situation?
21:05:30 <newsham> f $ a $ b = f (a $ b)
21:05:39 <Olathe> newsham: Ahh, thanks.
21:05:40 <Twey> Taggnostr: You should try to have only one $ in a scope
21:05:49 <Twey> a . b $ c, not a $ b $ c
21:06:02 <Taggnostr> uhm
21:06:11 <Taggnostr> then I have to find a way to remove 6 $
21:06:22 <Twey> Show the function?
21:06:38 <Taggnostr> let foo (x:xs) = xs++[x] in (:) 'n' $ reverse $ (:) 't' $ map Data.Char.chr $ map (+102) $ foo $ reverse $ [1..3]
21:06:43 <newsham> > (+2) $ (*3) $ succ 5
21:06:44 <lambdabot>   20
21:06:50 <newsham> > (+2) . (*3) $ succ 5
21:06:51 <lambdabot>   20
21:06:59 <Taggnostr> it was let foo (x:xs) = xs++[x] in 'n':(reverse ('t':(map Data.Char.chr (map (+102) (foo (reverse [1..3]))))))
21:07:18 <Taggnostr> actually I'm just playing around and try to understand how it works
21:07:30 <newsham> (:'n') . reverse . (:'t') . map chr . map (+102) . foo . reverse $ [1..3]
21:07:42 <Twey> Much clearer.
21:07:43 <newsham> btw,   map f . map g = map (f . g)
21:07:54 <Olathe> @pl (:) 'n' $ reverse $ (:) 't' $ map Data.Char.chr $ map (+102) $ foo $ reverse $ [1..3]
21:07:54 <lambdabot> 'n' : reverse ('t' : map Data.Char.chr (map (102 +) (foo (reverse [1..3]))))
21:08:21 <newsham> so you can do    map (chr . (+102))   together
21:08:38 <Taggnostr> oh, that was quite easy
21:09:11 <newsham> and when you have   ((:) x)   you can write that as (:x)
21:09:22 <newsham> err..  (x:)
21:09:23 <newsham> oops!
21:09:25 <Olathe> @pl ((:) x)
21:09:25 <Taggnostr> ok
21:09:25 <lambdabot> (x :)
21:09:31 <Olathe> @pl is neat.
21:09:31 <lambdabot> (line 1, column 9):
21:09:31 <lambdabot> unexpected end of input
21:09:31 <lambdabot> expecting white space or simple term
21:09:32 <Taggnostr> what is pl?
21:09:55 <Olathe> It takes an expression and gets rid of input variables.
21:10:04 <Olathe> @pl \a -> a + a
21:10:04 <lambdabot> join (+)
21:10:09 <Olathe> No as.
21:10:15 <newsham> (+),   (1+) and (+2),    1+2
21:10:28 <Olathe> > join (+) 2
21:10:30 <lambdabot>   4
21:10:33 <Olathe> And it works.
21:10:48 <the_unmaker> does ghc compile down to assembler?
21:11:00 <Olathe> @check \x -> join (+) x == (\a -> a + a) x
21:11:01 <lambdabot>   "OK, passed 500 tests."
21:11:11 <Olathe> the_unmaker: Usually.
21:11:22 <FunctorSalad_> how's that for a hard to find type error? "import Data.Map as List"
21:11:28 <FunctorSalad_> ...
21:12:19 <the_unmaker> so has anyone seen hadoop?
21:12:24 <Taggnostr> all these @pl commands are coded into lambdabot or I can use them from ghci too?
21:12:31 <newsham> unmaker: i've played with it briefly
21:12:32 <Olathe> They're in lambdabot.
21:13:05 <Taggnostr> @source
21:13:05 <lambdabot>  not available
21:13:20 <Taggnostr> ?source
21:13:20 <lambdabot>  not available
21:13:23 <Taggnostr> uhm
21:13:31 <thoughtpolice> ?source map
21:13:31 <lambdabot> map not available
21:13:32 <ddarius> @version
21:13:32 <lambdabot> lambdabot 4.2.1
21:13:32 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:13:47 <ddarius> @source Data.Map.insert
21:13:47 <lambdabot> Data.Map.insert not available
21:13:50 <ddarius> @source Data.Map
21:13:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
21:13:59 <thoughtpolice> Taggnostr: you can embed lambdabot into GHCi and get those commands in your session
21:14:29 <Taggnostr> I was thinking to allow my own bot to assimilate lambdabot
21:15:20 <Taggnostr> it has already assimilated ghci
21:15:38 <newsham> where is your bot?
21:15:46 <the_unmaker> http://www.randomhacks.net/articles/2007/02/10/map-fusion-and-haskell-performance
21:15:46 <newsham> can i make it run arbitrary code?
21:15:52 <lambdabot> Title: Map fusion: Making Haskell 225% faster, http://tinyurl.com/2fyynu
21:16:02 <the_unmaker> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
21:16:04 <lambdabot> Title: Rewriting Haskell Strings
21:16:06 <the_unmaker> well looky looky
21:16:11 <the_unmaker> haskell outperforming c?
21:16:12 <Taggnostr> nope, I can only run the code
21:16:19 <Taggnostr> uhm
21:16:43 <Taggnostr> only I can run the code?
21:16:54 <the_unmaker> anyone using fascgi+haskell?
21:16:59 <Taggnostr> Twey, help!
21:17:08 <newsham> unmaker: it happens sometimes.
21:17:47 <Twey> Taggnostr: 'Only I can run the code' -- 'nobody except me can run the code'
21:18:23 <Taggnostr> ok, the other one means that I can run the code and nothing else, right?
21:18:26 <Twey> Taggnostr: 'I can only run the code' -- 'I can't do anything with the code but run it' (or possibly 'I can't run anything but the code', depending on stress)
21:18:51 <Taggnostr> yep, thanks
21:19:24 <Twey> Welcome
21:20:10 <lament> The code I can only run.
21:20:14 <ddarius> the "entire incomplete gamma function"
21:20:37 <Taggnostr> how is the learning curve of haskell?
21:21:07 <lament> Taggnostr: it gets vertical at some point
21:21:09 <Twey> Intermediate to steep
21:21:10 <newsham> ever see a plot of e^x?
21:21:14 <Twey> Heh
21:21:19 <lament> e^x is a good approximation
21:21:22 <Twey> Well worth it, though :)
21:21:28 <newsham> its a fun climb
21:21:49 <donri> I wish runghc had a -e switch. *abusing haskell*
21:21:53 <Taggnostr> so it's easy at the beginning, isn't it?
21:21:59 <Twey> donri: Pipe :)
21:22:01 <Twey> Taggnostr: Aye
21:22:09 <donri> Twey, tried it, it wants a file
21:22:13 <Twey> Until you get to about monads, it's plain sailing
21:22:16 <Twey> donri: Use -
21:22:49 <Twey> Oh, can't :(
21:22:58 <donri> :(
21:23:29 <donri> easy to make a custom command of course, but "not the same"
21:23:53 <Twey> Heh
21:24:05 <Taggnostr> ?src foldl
21:24:06 <lambdabot> foldl f z []     = z
21:24:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:24:45 <newsham> > foldl (+) 0 [10,100,1000]
21:24:47 <lambdabot>   1110
21:25:00 <Taggnostr> got it
21:25:12 <newsham> > foldl f z [a,b,c]
21:25:13 <lambdabot>   f (f (f z a) b) c
21:25:23 <newsham> > foldl + z [a,b,c]
21:25:24 <lambdabot>   Couldn't match expected type `[Expr]
21:25:26 <newsham> doh
21:25:33 <newsham> > foldl (+) z [a,b,c]
21:25:35 <lambdabot>   z + a + b + c
21:25:53 <newsham> > foldr (+) z [a,b,c]
21:25:54 <lambdabot>   a + (b + (c + z))
21:29:58 <Taggnostr> is one with a degree in math supposed to know what a monad is?
21:29:58 <Axman6> hmm, i should use foldl more
21:30:18 <lament> Taggnostr: no
21:30:20 <newsham> if you studied category theory?
21:30:27 <lament> Taggnostr: category theory is usually grad stuff
21:30:42 <Taggnostr> uhm, ok
21:30:50 <lament> (i have a degree in math, and i don't know what a monad is :D)
21:30:59 <Twey> Taggnostr: Don't fret about the maths
21:31:08 <Twey> It makes sense from a programming point of view.  :)
21:31:29 <FunctorSalad_> it's just a monoid object in the category of endofunctors (of Hask)... obvious isn't it? :D
21:31:41 <FunctorSalad_> *ducks*
21:31:57 <Twey> Heh
21:32:06 <ddarius> I don't have a degree in math and I do know what a monad is
21:32:14 <Twey> Ditto :)
21:32:21 <Twey> Heck, I don't have a degree in anything.
21:32:24 <intoverflow> I do and I don't :)
21:32:35 <FunctorSalad_> but more seriously, Taggnostr, if you want a mathy example, do you know about free (groups|abelian groups|modules|whatever) in algebra?
21:32:56 <FunctorSalad_> you get a monad from all of these
21:33:02 <Taggnostr> I don't think so, I don't know anything about math
21:33:15 <FunctorSalad_> oh then I misunderstood your question
21:33:29 <FunctorSalad_> (<Taggnostr> is one with a degree in math supposed to know what a monad is?)
21:33:59 <FunctorSalad_> anyway, if anyone else cares, you get a monad from these algebraic gadgets like this.
21:34:01 <Taggnostr> I just wanted to use monad as an excuse to talk with a nice girl with a degree in math that is in class with me
21:34:20 <lament> "Hey, wanna see my monads?"
21:34:28 <Taggnostr> :D
21:34:35 <the_unmaker> girls rule
21:34:42 <the_unmaker> Ill take 2 please
21:34:43 <FunctorSalad_> for a set A, let M A := term structure (say in the theory of groups) over A
21:34:59 <FunctorSalad_> I mean the term structure with variables indexed by A
21:35:16 <FunctorSalad_> then "return" is the insertion of the elements of A to the variables
21:35:32 <FunctorSalad_> "join" is flattening two layers of term structure by evaluating
21:36:02 <FunctorSalad_> wth am I talking about?
21:36:18 <lament> you're on drugs, right?
21:36:52 <Taggnostr> I have no idea at all, but I can understand all the terms
21:37:42 <Olathe> Are you making a FP technical paper generator ?
21:38:30 <mm_freak_> SamB_XP: "affe" is german and means ape =)
21:38:56 <mm_freak_> so my host is a double dead ape ;)
21:39:14 <Twey> @type join
21:39:15 <newsham> affe 'n affe?
21:39:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:39:16 <Twey> @src join
21:39:17 <lambdabot> join x =  x >>= id
21:41:21 <ivanm> anyone know how to plot error bars using the Chart library?
21:42:01 <Axman6> :t just
21:42:03 <lambdabot> Not in scope: `just'
21:42:07 <Axman6> :t join
21:42:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:42:26 <Axman6> join $ Just $ Just 1
21:42:32 <Axman6> > join $ Just $ Just 1
21:42:33 <lambdabot>   Just 1
21:42:47 <Axman6> oh right, i get the src now, heh
21:43:03 <Axman6> join [[1],[2]]
21:43:10 <Axman6> > join [[1],[2]]
21:43:11 <lambdabot>   [1,2]
21:43:23 <Axman6> really, really must stop forgetting that
21:43:40 <newsham> > join (*) 4
21:43:42 <lambdabot>   16
21:43:50 <Axman6> :|
21:44:04 <Axman6> > join (*) 4 :: Expr
21:44:06 <lambdabot>   4 * 4
21:44:14 <Axman6> how's that work?
21:44:31 <newsham> (Int -> (Int ->)) Int
21:44:48 <newsham> or something like that
21:44:52 <Taggnostr> is there a way to do let foo (x:xs) = xs++[x] without defining a new function?
21:44:55 <Axman6> > join (/) 4 :: Expr
21:44:56 <lambdabot>   4 / 4
21:45:40 <Axman6> Taggnostr: just curious, what do you need it for?
21:45:54 <newsham> instead of feeding 4 into an Int->Int function, it feeds 4 into both sides of a Int -> Int -> Int function
21:46:05 <Taggnostr> I want to put the first element of a list at the end
21:46:26 <Taggnostr> so [1,2,3] -> [2,3,1]
21:46:28 <newsham> > reverse $ '!' : reverse "testing"
21:46:29 <lambdabot>   "testing!"
21:46:41 <newsham> > "testing" ++ "!"
21:46:42 <lambdabot>   "testing!"
21:47:02 <FunctorSalad_> Data.Sequence would be more efficient for that
21:47:10 <Taggnostr> testing should become estingt
21:47:57 <Taggnostr> > let foo (x:xs) = xs++[x] in foo "testing"
21:47:59 <lambdabot>   "estingt"
21:48:04 <Axman6> > (\(x:xs) -> reverse $ x : reverse xs) "testing"
21:48:06 <lambdabot>   "estingt"
21:48:21 <Axman6> > iterate (\(x:xs) -> reverse $ x : reverse xs) "testing"
21:48:21 <Taggnostr> uhm
21:48:23 <lambdabot>   ["testing","estingt","stingte","tingtes","ingtest","ngtesti","gtestin","tes...
21:48:39 <Taggnostr> is that some kind of anonymous function?
21:48:45 <Axman6> yeah
21:49:28 <newsham> > take 3 $ drop 4 $ "testing" ++ "testing"
21:49:29 <lambdabot>   "ing"
21:49:35 <newsham> > take 7 $ drop 4 $ "testing" ++ "testing"
21:49:36 <lambdabot>   "ingtest"
21:50:44 <Taggnostr> > "testing" * 2
21:50:45 <lambdabot>       No instance for (Num [Char])
21:50:45 <lambdabot>        arising from the literal `2' at <in...
21:50:55 <newsham> > let f xs n = (take length xs . drop n) xs in map f "testing" [0..7]
21:50:56 <lambdabot>   Couldn't match expected type `Int'
21:51:07 <newsham> > let f xs n = (take (length xs) . drop n) xs in map f "testing" [0..7]
21:51:08 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
21:51:09 <dibblego> > replicate 2 "testing"
21:51:10 <lambdabot>   ["testing","testing"]
21:51:16 <newsham> grr :)
21:51:44 <newsham> > take 7 $ drop 123 $ cycle "testing"
21:51:45 <lambdabot>   "ingtest"
21:52:06 <Axman6> > let f xs n = (take (length xs) . drop n) xs in map (f "testing") [0..7]
21:52:08 <lambdabot>   ["testing","esting","sting","ting","ing","ng","g",""]
21:52:40 <newsham> > let f xs n = (take (length xs) . drop n . cycle) xs in map (f "testing") [0..]
21:52:42 <lambdabot>   ["testing","estingt","stingte","tingtes","ingtest","ngtesti","gtestin","tes...
21:52:59 <Axman6> @src cycle
21:53:00 <lambdabot> cycle [] = undefined
21:53:00 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
21:53:07 <newsham> > cycle "testing"
21:53:08 <lambdabot>   "testingtestingtestingtestingtestingtestingtestingtestingtestingtestingtest...
21:53:11 <Axman6> heh
21:53:32 <Taggnostr> uhm
21:53:41 <Axman6> repeat "testing" >>= id
21:53:45 <Taggnostr> > drop 1 "foobar"
21:53:46 <Axman6> > repeat "testing" >>= id
21:53:48 <lambdabot>   "oobar"
21:53:48 <lambdabot>  Terminated
21:54:00 <Axman6> :(
21:54:05 <Axman6> > repeat "testing" >>= join
21:54:07 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
21:54:11 <Axman6> heh
21:54:23 <newsham> you'd think   take n . drop m    would be in the std libs somewhere
21:54:23 <Taggnostr> > drop 1 . take 9 . cycle $ "testing"
21:54:25 <lambdabot>   "estingte"
21:54:33 <Taggnostr> > drop 1 . take 8 . cycle $ "testing"
21:54:35 <lambdabot>   "estingt"
21:54:38 <Axman6> newsham: like substring?
21:54:41 <Taggnostr> cool
21:54:47 <Axman6> /sublist
21:54:55 <newsham> tag: you want to drop first then take second
21:55:14 <Axman6> ah
21:55:16 <Taggnostr> > take 7 . drop 1 . cycle $ "testing"
21:55:17 <lambdabot>   "estingt"
21:55:21 <Taggnostr> indeed
21:56:58 <Axman6> > (\xs -> drop 1 . take (length xs) xs) "testing"
21:56:59 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:57:13 <Axman6> > (\xs -> drop 1 . take (length xs) $ xs) "testing"
21:57:15 <lambdabot>   "esting"
21:57:24 <Axman6> > (\xs -> drop 1 . take (1+length xs) $ xs) "testing"
21:57:26 <lambdabot>   "esting"
21:57:33 <Axman6> ...
21:57:37 <Axman6> oh right
21:57:45 <hackage> Uploaded to hackage: mps 2008.9.19
21:57:46 <Axman6> > (\xs -> drop 1 . take (1+length xs) $ cycle xs) "testing"
21:57:47 <lambdabot>   "estingt"
21:57:55 <Axman6> that's yuck :(
21:58:41 <Axman6> > (\xs -> take (length xs) . drop 1 . cycle xs) "testing"
21:58:42 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:58:46 <Axman6> > (\xs -> take (length xs) $ drop 1 . cycle xs) "testing"
21:58:47 <lambdabot>   Couldn't match expected type `a -> [a1]'
21:58:57 <Axman6> > (\xs -> take (length xs) $ drop 1 $ cycle xs) "testing"
21:58:58 <lambdabot>   "estingt"
21:59:47 <Axman6> @unpl (\xs -> take (length xs) $ drop 1 $ cycle xs)
21:59:48 <lambdabot> (\ xs -> take (length xs) (drop 1 (cycle xs)))
21:59:52 <Axman6> @pl (\xs -> take (length xs) $ drop 1 $ cycle xs)
21:59:53 <lambdabot> liftM2 take length (drop 1 . cycle)
22:00:30 <Axman6> ok, that should all have been done in ghci. my bad
22:02:45 <Taggnostr> so, how do these anonymous functions work?
22:03:17 <Taggnostr> foo a b = a * b == (\a b -> a*b) ?
22:03:58 <Heffalump> foo a b = a * b means foo = \a b -> a * b
22:04:40 <Taggnostr> > (\a b -> a*b) 3 5
22:04:42 <lambdabot>   15
22:06:34 <polymorf> do you think haskell would be a good language to write web applications in?
22:08:30 <Taggnostr> polymorf, what kind of web apps?
22:09:21 <polymorf> Taggnostr: a web ipv6 tunnel.
22:10:47 <Taggnostr> maybe
22:11:00 <polymorf> 'maybe' ?
22:11:35 <Taggnostr> I don't know haskell enough to provide a better answer
22:12:20 <polymorf> i want to deploy a tunnel broker or a 6to4 mechanism in order to serve a segment of ipv6 via a web interface using haskell, if it's a good idea.
22:13:01 <Korollary> I'd call that a networking app. It's doable.
22:13:57 <polymorf> yes, i reckoned that i'd develop a tunnel broker approach, using it to automatically set up and manage any other kinds of tunnel, like a multicast tunnel or an IPSec tunnel.
22:14:29 <polymorf> maybe a dedicated ACS like the TB, to securely authorize and assist users that want to gain access to an ipv6 network.
22:14:37 <polymorf> All over the web.
22:15:12 <Axman6> sounds like something that erlang may be better at. but i could be wrong
22:15:24 <Korollary> I don't think so.
22:16:32 <Korollary> Erlang nicely abstracts processes from having to deal with networking directly. This app wants to deal with networking directly. I think it could be written in any language.
22:16:51 <mmorrow> polymorf: check out Control.Concurrent.{_,MVar,Chan}
22:17:44 <mmorrow> polymorf: also there's a cleanly written haskell packet sniffer somewhere that may be helpful
22:18:06 <mmorrow> ?google haskell packet sniffer
22:18:08 <lambdabot> No Result Found.
22:18:15 <polymorf> mmorrow: alright.
22:18:32 <Axman6> Korollary: erlang is also excellent for working with the network directly, from what i remember. its bit syntax makes it perfect for plow lever protocols
22:18:39 <mmorrow> i can't remember where. it was a blog with i think a picture of coffee or something at the top
22:21:06 <thoughtpolice> i wrote a network sniffer in haskell
22:21:08 <nha__> is there any way to create a new type that is a restricted set of Ints?
22:21:13 <thoughtpolice> for one of my beginning experiences
22:21:14 <thoughtpolice> http://code.haskell.org/hsns/src/
22:21:15 <lambdabot> Title: Index of /hsns/src
22:21:25 <dons> nha__: you can, but you'll need a smart constructor
22:21:38 <nha__> ok thanks
22:21:39 <dons> there's ways to do it entirely statically, but that's a little convoluted
22:21:54 <thoughtpolice> not sure if that's the one you're talking about; don't think it's really "cleanly written" :P
22:22:00 <mmorrow> ah, it was a port scanner, not a packet sniffer
22:22:02 <dons> nha__: http://haskell.org/haskellwiki/Smart_constructors
22:22:03 <mmorrow> http://blog.moertel.com/articles/2004/03/13/concurrent-port-scanner-in-haskell
22:22:08 <lambdabot> Title: Smart constructors - HaskellWiki
22:22:09 <lambdabot> Title: Concurrent port scanner in Haskell, http://tinyurl.com/ywbrdx
22:22:43 <mmorrow> i dunno about hsns, but i though this port scanner was nice and succinct
22:22:56 <mmorrow> (although could do with some type sigs)
22:23:19 <thoughtpolice> ah port scanner. yeah mine just piggybacks on the pcap package basically
22:23:49 <mmorrow> oh cool, hsns is yours then
22:24:11 <mmorrow> i just came across it in my search for the coffee blog :)
22:24:36 <polymorf> mmorrow: thanks ;)
22:24:52 <Axman6> thoughtpolice: i've seen you in #macosx before right?
22:28:52 <thoughtpolice> Axman6: not sure - I might have stopped by there once or twice but I can't remember
22:29:24 <Axman6> righto. your nick is familiar, that's all :)
22:29:41 <Axman6> maybe i'm getting you mixed up with codeofficer...
22:31:16 <mmorrow> i found this searching for the port scanner
22:31:17 <mmorrow> http://weblogs.mozillazine.org/roc/archives/2007/10/tablua_fracta.html
22:31:19 <lambdabot> Title: Well, I'm Back: Tabula Fracta, http://tinyurl.com/2ame5c
22:31:39 <polymorf> cool
22:31:52 <mmorrow> haskell would totally be in that loop uppin its vars
22:32:59 <mmorrow> (although the author claims he has excluded haskell with his "Update")
22:33:13 <mmorrow> pfffft.
22:33:32 <polymorf> <kerneland> haskell is like oldskewl python man
22:37:20 * mmorrow loves the -undo-close-tab feature of vimperator
22:37:38 * mmorrow notes that all you do is press 'u'
22:37:48 <dons> mmorrow: heh
22:38:02 <dons> yeah, nice, we warrant an extra clause to keep us excluded.
22:38:38 <mmorrow> exactly.
22:38:48 <dons> just wants transactional memory ,typed message passing, multicore, GC, immutable types, global optimization, utf8, ...
22:38:51 <dons> but not haskell. oh no.
22:38:59 <dons> one of those other pure, typed, multicore languages.
22:39:13 <dons> the ones with the transactional memory.
22:39:13 <mmorrow> don't be skurrred!
22:39:53 <mmorrow> and the 8-core effortless handling.
22:40:37 * mmorrow has never run a haskell prog on 8 cores, but he does enjoy talking trash
22:42:02 <Adamant> "natural and efficent mapping to commodity hardware"?
22:43:54 <Adamant> unless you plan to run Mozilla on a AVR, I'm gonna have to call shenangians on that one.
22:44:58 <mmorrow> my firefox has been crashing constantly the last few weeks. it's dead to me. time to move on.
22:45:15 <mmorrow> (this is on linux)
22:45:20 <Adamant> mmorrow: quit overclocking your ATMega
22:45:39 <mmorrow> lol333t
22:45:40 <Adamant> ;)
22:46:20 <Pseudonym> I wonder what the main bottleneck on an ATmega is.
22:46:23 <Pseudonym> Probably program memory.
22:46:26 <Pseudonym> Since it's flash.
22:46:31 <Adamant> probably the fact it's 8-bit
22:46:45 <Pseudonym> You could run an 8 bit processor at 3GHz.
22:46:52 <Pseudonym> If you built one right.
22:47:22 <Adamant> you could, but it would probably cost as much as a 32-bit chip running that fast and have none of the performance.
22:47:54 <Adamant> microcontrollers compete on cheapness
22:47:59 <Pseudonym> It depeonds what you mean by "performance".
22:48:19 <Pseudonym> Commodity desktop/server processors have notoriously high interrupt latency, for example.
22:48:22 <Adamant> Pseudonym: compelling reasons not to buy an ARM and be done with it
22:48:33 <Pseudonym> Fine for disk or network, but not for other applicaitons.
22:48:40 <Adamant> true.
22:48:47 <mmorrow> FPGAs are t3h future
22:49:21 <Adamant> I wonder if you could run a cut down Haskell-type language on a 8-bit RISCy uC?
22:49:38 <mmorrow> you can run haskell on an FPGA :)
22:49:58 <mmorrow> ?go reduceron2
22:49:59 <Adamant> mmorrow: you can also use Lava to make the FPGA design :)
22:50:01 <lambdabot> http://www.cs.york.ac.uk/~mfn/reduceron2/
22:50:01 <lambdabot> Title: The Reduceron
22:50:05 <mmorrow> Adamant: totally
22:51:50 <polymorf> hrm, pidgin vuln.
22:52:02 <Adamant> libpurple or pidgin?
22:57:45 <hackage> Uploaded to hackage: panda 2008.9.19
23:15:27 <ivanm> is there an unzipWith analogous to zipWith?
23:17:12 <dmwit> Transpose kind of does that.
23:17:16 <dons> ?hoogle unzip
23:17:16 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
23:17:16 <lambdabot> Data.ByteString unzip :: [(Word8, Word8)] -> (ByteString, ByteString)
23:17:16 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
23:17:16 <TSC> :t unzip
23:17:18 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
23:17:27 <dons> ?more
23:17:40 <dmwit> TSC beat you to it. =P
23:17:48 <dmwit> There is no ?more.
23:17:50 <dons> ?src unzip
23:17:50 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
23:17:53 <ivanm> well, I'm wanting something of type [(a,(a,a))] -> ([(a,a)],[(a,a)])
23:18:11 <ivanm> I could code one up myself, but there probably isn't much point if one exists already
23:19:14 <dmwit> :t unzip . map (\(x, (y, z)) -> ((x, y), (x, z)))
23:19:15 <lambdabot> forall t t1 t2. [(t, (t1, t2))] -> ([(t, t1)], [(t, t2)])
23:19:36 <ivanm> (and (xs,yzs) = unzip xyzs; (ys,zs) = unzip yzs; xys = zip xs ys; xzs = zip xs ys; seems rather cumbersome)
23:20:16 <ivanm> dmwit: heh, that looks nicer than trying to use foldr myself ;-)
23:20:17 <ivanm> thanks!
23:25:02 <electronx> submitted my first paper today
23:25:13 <electronx> text categorisation
23:25:23 <electronx> :)
23:25:52 <ivanm> congrats, electronx!
23:26:13 <electronx> thanks
23:26:35 <dons> electronx: congrats.
23:26:41 <dons> got it online yet?
23:26:55 <dons> fight the ACM. post it on your blog! :)
23:27:00 <electronx> ya don't know if you'll be able to access it
23:27:05 <electronx> though
23:27:13 <dons> no. you usually get   to keep the preprint
23:27:16 <dons> so you wrote it..
23:27:22 <dons> s/since/
23:27:27 <ivanm> arxiv!
23:27:37 <polymorf> night
23:28:00 <dons> letting the ACM keep your paper secret isn't a good way to influence the world. the ACM is a black hole of nothingness
23:28:09 <electronx> lol
23:28:21 <dons> it's just not how the internet works.
23:28:30 <Korollary> Myabe you're not trying to influence the world.
23:28:33 <electronx> yeah that true
23:28:34 <dons> academics: your job is to shape thought.
23:28:44 <dons> and ACM lock down is not how that's done anymore.
23:29:03 <dons> well, if writing papers is not to shape thought on a topic, i'm not sure what the point is.
23:29:07 <Korollary> Elsevier FTW!
23:29:08 <ivanm> dons: s/ACM/<journal foo>/
23:29:16 <dons> yup.
23:29:40 <ivanm> I read something the other day (from reddit?) saying that arxiv was made precisely because of this
23:29:43 <dons> oleg ain't famous for ACM papers.
23:30:02 <dons> he's famous for his website/blog/emails
23:30:15 <ivanm> I thought oleg was famous because he's oleg :s
23:30:19 <ivanm> ;-)
23:30:33 <dons> no, there's more substance than that. :)
23:30:51 <ivanm> heh
23:30:56 <dons> so anyway, if you write a paper, stick it online. and announce it.
23:30:58 <jsnx> it was his music, i thought
23:31:00 <dons> and make it easily available.
23:31:06 <dons> don't let the ACM eat it.
23:31:10 <electronx> :)
23:31:26 <glguy_> blog comments are the new peer review
23:31:34 <Stinger__> haha
23:31:35 <jsnx> hehe
23:31:38 <mornfall> haha
23:31:44 <dons> i'm not saying that. but it doesn't hurt.
23:31:47 <jsnx> lolz
23:32:00 <dons> blog comments can be pretty .. harsh.
23:32:07 <jsnx> and ignorant
23:32:08 <dons> so integrate them, then put out a better copy.
23:32:36 <jsnx> post papers on 4chan!
23:32:40 <Axman6> is there some kind of site where you can publish papers and anyone can review them?
23:32:50 <ivanm> dons: well, wasn't that what you pretty much did for RWH? screw paying someone to review it, get ignorant suckers to do it for you for free! :p
23:32:50 <jsnx> arxiv?
23:32:50 <dons> reddit?
23:32:56 <Axman6> heh
23:33:01 <dons> ivanm: yeah, and clever suckers :)
23:33:26 <dons> well. social book writing. its the internet, after all. you're not doing it right if you're not taking advantage of many eyes.
23:33:39 <dons> spj puts his papers on the wiki these days
23:33:44 <ivanm> so what, it backfired and you got a lot of comments like "lolz, haskell sucks"? ;-)
23:33:48 <dons> and gets review beforehand. its a much more sensible model
23:33:53 <dons> ivanm: no?
23:34:06 <dons> we got almost uniformly useful contributions.
23:34:06 <lament> dons: are you gonna be on bos's presentation on RWH next saturday?
23:34:10 <ivanm> what, only clever suckers commented! :o
23:34:20 <ivanm> how did you stop 4chan from getting wind of it? ;-)
23:34:23 <dons> and something like 200x as much tech review as is normal
23:34:31 <dons> not sure.
23:34:40 <dons> lament: i'll be there, i'm co-chair for defun.
23:34:48 <lament> cool!
23:34:55 <dons> so i gotta make sure the projector works.
23:35:06 <Axman6> heh
23:35:13 <lament> for $250 a ticket it f-n better
23:35:19 <dons> oh, ICFP?
23:35:25 <dons> i hope defun wasn't that much.
23:35:27 <lament> nah, that's defun
23:35:34 <lament> each day is that much
23:35:38 <dons> defun was less than that, wasn't it?
23:35:40 <dons> oh huh.
23:35:42 <dons> bloody ACM.
23:35:55 <lament> (that's the non-early non-member non-student price)
23:36:03 <dons> we put on hackathons for free...
23:36:08 * dons hates ACM vampires
23:36:12 <jsnx> i think that it would be nice if reddit gave you a widget that could take a URL or URL pattern and anywhere that it's been posted, and all the comments on it
23:36:14 <lament> hee
23:36:16 <Axman6> what is ACM?
23:36:24 <ivanm> lament: so what is the early-member-student price?
23:36:33 <dons> i thought it was more like $50.
23:36:42 <dons> which is still too much.
23:36:46 <Axman6> jsnx: isn't that something like stumbleupon?
23:36:50 <ivanm> per day? or all up?
23:37:03 <jsnx> Axman6: i was not aware stumbleupon did that
23:37:08 <lament> $230, not $250. And the early student price is $70
23:37:08 * dons says $20, you get lunch, coffee, and a room with wifi
23:37:10 <lament> per day
23:37:16 <dons> ok. that's typical.
23:37:23 <jsnx> dons: then bums will come
23:37:34 <dons> :)
23:37:36 <lament> bums like me :)
23:37:48 <dons> well, you do get to see oleg write a webserver.
23:37:49 <dons> live.
23:37:54 <dons> which is certainly a show.
23:37:56 <lament> oooh
23:38:11 <ivanm> dons: how good a webserver? apache-level? :p
23:38:12 <lament> i didn't realize that's what he's gonna be doing
23:38:15 <dons> but the ACM takes the profit and walks away. using it to send more technews spam.
23:38:27 <lament> given that the paper he presents is "Incremental multi-level input processing with left-fold enumerator
23:38:33 <dons> :)
23:38:38 <dons> you gotta decode oleg speak
23:38:40 <lament> i guess that does vaguely sound like a webserver :)
23:38:43 <dons> heh
23:38:59 <dons> haskell people aren't great with titles for the most part.
23:39:04 <dons> except Wadler.
23:39:18 <ivanm> is he still a haskell person?
23:39:28 <ivanm> I thought he only did stuff on his Links project now...
23:39:38 <lament> what is the RWH thing gonna be? Slides and excerpts from the book + history of its development?
23:39:38 <dons> http://www.deinprogramm.de/defun-2008/abstracts/oleg-abstract.txt
23:39:45 <dons> lament: thing?
23:39:48 <dons> oh, the talk.
23:39:49 <lament> presentation
23:39:58 <dons> http://www.deinprogramm.de/defun-2008/abstracts/bos-abstract.txt
23:40:08 <dons> * Producing output: how to turn Haskell values into JSON data.
23:40:08 <dons> * Parsing in Haskell: a simple JSON parser.
23:40:08 <dons> * Build a tiny web server.
23:40:08 <dons> * Turn the tiny web server into a concurrent application that uses software transactional memory.
23:40:12 <lament> oh, it's a tutorial
23:40:19 <dons> defun is all live coding tutorials
23:40:23 <dons> actually writing *stuff*
23:40:36 <dons> glguy_: are we going to all the defun stuff?
23:40:46 <glguy_> I believe so
23:40:50 <dons> sweet.
23:41:10 <dons> program's here, btw, http://www.deinprogramm.de/defun-2008/ for those wondering wth we're talking about
23:41:11 <lambdabot> Title: ACM SIGPLAN 2008 Developer Tracks on Functional Programming
23:41:20 <dons> glguy_: when did you disappear tonight?
23:41:22 <dons> didn't see you sneak out ..
23:41:30 * Axman6 would really like to see more haskell talks at ANU -_-
23:41:35 <lament> the F# thing could be interesting too
23:41:37 * dons shouldn't have had that 9pm espresso
23:41:43 <Axman6> where more = some
23:41:45 <dons> Axman6: go talk to benl.
23:41:57 <ivanm> Axman6: I'd like to see _any_ haskell talks at UQ ;-)
23:41:57 <dons> he must be the haskell guru at ANU now.
23:41:58 <Axman6> i was thinking of that actually. saw his site the other day
23:42:08 <dons> he knows ghc inside out.
23:42:15 <Axman6> he's at ANU?
23:42:19 <glguy_> dons: I left around 7:00P.M.
23:42:19 <dons> yup
23:42:39 <dons> glguy_: ah sneaky.
23:42:39 <Axman6> hmm, excellent. that wouls be awesome
23:43:02 <dons> http://cs.anu.edu.au/people/Ben.Lippmeier/
23:43:04 <lambdabot> Title: Ben Lippmeier
23:43:07 <dons> go talk to him. ben's awesome.
23:43:24 <Axman6> oh right, Clem's PHD student
23:43:42 <dons> you could start an ACT haskell club :)
23:43:55 <ivanm> heh
23:43:59 <Axman6> must've got him mixed up with someone else at UNSW
23:44:04 <Axman6> hurrar
23:44:18 <dons> don't let the Sydney guys have all the fun
23:44:21 <Axman6> if only i wasn't quite so new to haskell...
23:44:26 <Axman6> heh, indeed
23:44:51 <Axman6> i might shoot him an email
23:44:53 <dons> seriously, ben's a valuable resource. you should try to leach his brain while you're in the same town :)
23:45:06 <electronx> what is the best book to learn haskell?
23:45:14 <Axman6> my friend's being lectured by him in one of his comp courses
23:45:17 <Axman6> him and clam
23:45:18 <jsnx> probably real world haskell
23:45:20 <Axman6> clem*
23:45:20 <dons> we're a bit sparsely spread out in .au , so its good when you're within 5 hours of someone who knows ghc.
23:45:29 <dons> electronx: i'd say rwh, but i'm biased.
23:45:36 <jsnx> .au is australia or austria?
23:45:37 <dons> but its online, so you can try it for yourself.
23:45:46 <Axman6> jsnx: australia
23:45:47 <dons> austria is .at iirc
23:45:48 <electronx> dons: where :)
23:45:54 <dons> ?go real world haskell
23:45:57 <lambdabot> http://www.realworldhaskell.org/
23:45:57 <lambdabot> Title: Real World Haskell
23:45:59 <dons> go go go
23:46:06 <electronx> thanks
23:46:16 <Axman6> dons: you're writing that right?
23:46:28 <dons> done with writing it :)
23:46:34 <Axman6> excellent
23:46:37 <dons> http://book.realworldhaskell.org/ is the official site.
23:46:42 <lambdabot> Title: Real World Haskell
23:47:02 <dons> an experiment in modern book publishing. do it live. do it online.
23:47:02 <ivanm> @where RWH
23:47:02 <lambdabot> is http://www.realworldhaskell.org/blog/
23:47:08 <Axman6> wehn will it be out in book form? i always find reading programming stuff on a computer a lot harder (mainly because it gets in the way of the code)
23:47:14 <dons> november.
23:47:24 <dons> in .au, hmm. don't know :|
23:47:31 <Axman6> :\
23:47:33 <dons> though UNSW bookshop should likely have it.
23:47:42 <dons> and anywhere else you can get o'reilly books
23:48:14 <Axman6> i could probably see if the co-op bookshop would order them in
23:48:29 <dons> let's see...
23:48:31 <ivanm> dons: yes, but they're going to be dear here...
23:48:38 <ivanm> Axman6: around $90 for the pre-order price
23:48:39 <dons> boo
23:48:46 <ivanm> BigW will even have them though apparently :o
23:48:59 <dons> i should do my own shipping for people back to the old country.
23:49:04 <ivanm> Axman6: we need to organise a mass shipment from amazon for us aussies!
23:49:11 <ivanm> dons: even better idea!
23:49:14 <Axman6> dons: any chance of signed copies? :P
23:50:10 <dons> yeah, its not showing up on the coop site yet.
23:50:23 <Axman6> doesn't surprise me
23:50:29 <dons> nor unsw bookshop.
23:50:44 <Axman6> your publisher is failing
23:51:02 <dons> dymocks has it.
23:51:08 <dons> 79.95.
23:51:15 <dons> http://www.dymocks.com.au/ProductDetails/ProductDetail.aspx?R=9780596514983&amp;Producode=9780596514983
23:51:22 <ivanm> dons: that's cheap compared to what I've seen! :o
23:51:40 <dons> angus & robertson doesn't have it.
23:51:54 <ivanm> dons: have you seen the blurb for it though?
23:52:04 <dons> weird...
23:52:08 <ivanm> it's unwords . map firstToUpper . words ;-)
23:52:15 <dons> gleebooks doesn't have it.
23:52:24 <dons> so looks like dymocks is the only in-country place atm.
23:52:26 <ivanm> The Textbooks Use Pascal As A Language For Teaching Computer Science
23:52:30 <ivanm> Pascal???
23:52:37 <ivanm> qbd has it IIRC
23:52:44 <dons> they do have "The Blogging Revolution" i note, glguy_
23:53:06 <dons> freay
23:53:08 <dons> freaky.
23:53:18 <ivanm> http://chaos.com/product/real_world_haskell_2032977_3936.html <-- $90
23:53:24 <lambdabot> Title: REAL WORLD HASKELL (UNKNOWN): books: Chaos.com
23:53:31 <dons> that's the weirdest blurb i've seen.
23:53:36 <dons> who wrote it?
23:53:39 <Axman6> what about boarders?
23:53:41 <sjanssen> I bet I know who wrote it
23:53:42 <sjanssen> @keal
23:53:43 <lambdabot> nsa prevent me from returning to math on efnet
23:53:51 <ivanm> Axman6: can't search their site :s
23:53:53 <dons> that certainly isn't the official blurb the publisher's using.
23:53:57 <Axman6> lame :|
23:54:10 <dons> it contains "original research"
23:54:15 <ivanm> QBD has it for $80
23:54:25 <ivanm> same as collins booksellers
23:54:27 <dons> "It's Not Clear What's Driving This Interest, But One Of The Factors May Be The Importance Of Concurrent Programming And New Computer Architectures."
23:54:41 <dons> ok. so i think i need to contact o'reilly about this one. bizarre.
23:54:46 <dons> oh collins.
23:55:03 <ivanm> heh, search for it at bookware.com.au
23:55:59 <ivanm> dons: though some sites say bos is the only author... >_>
23:56:58 <jsnx> i got it off amazon for $50, i think
23:57:07 <jsnx> but i pre-ordered
23:57:57 <ivanm> apparently RWH is "holistic" http://www.holisticpage.com.au/RealWorldHaskell_BryanO%27sullivan;johnStewart,Donaldgoerzen|9780596514983
23:57:57 <lambdabot> http://www.holisticpage.com.au/RealWorldHaskell_BryanO%27sullivan;johnStewart,Donaldgoerzen|9780596514983
23:58:17 <Korollary> John Stewart?
23:58:28 <jsnx> hahaha
23:58:53 <jsnx> dons: you're IRL name is Don Stewart, right?
23:59:17 <ivanm> $50 australian!!! http://www.fishpond.com.au/Books/Computers/Programming/General/product_info/12316290/?cf=3&rid=1531246061&i=1&keywords=9780596514983+
23:59:19 <lambdabot> Title: Fishpond.com.au: Real World Haskell, Donald Stewart Bryan O'Sullivan - Shop Onli ..., http://tinyurl.com/3jq22t
23:59:20 <ivanm> Axman6: ^^
23:59:31 <Axman6> hurrar!
23:59:45 * ivanm hopes they don't mean US...
23:59:54 <Axman6> but... is it signed by dons? :P
