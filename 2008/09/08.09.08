00:10:13 <sandbox> is there a way to get more verbose output from cabal?
00:10:43 <sandbox> quickcheck seems borked yet both versions (1.1.0.0, 2.0) appear fine from ghci.
00:23:00 <mmorrow> what does
00:23:15 <mmorrow> ghc-pkg list QuickCheck
00:23:17 <mmorrow> say?
00:23:43 <sandbox> I hid my system package and my 2.0, so just 1.1.0.0
00:23:55 <mmorrow> how is it borked?
00:24:34 <sandbox> coarbitrary isn't visible to hmatrix test stuff
00:25:26 <mmorrow> what does the .cabal file say in the build-depends: field about QuickCheck
00:25:27 <mmorrow> ?
00:25:49 <sandbox> QuickCheck
00:27:10 <mmorrow> hmm. personally i just deleted those module from the exposed-module section so i didn't have to deal with this exact issue
00:27:19 <mmorrow> i'm checking something though
00:28:14 <mmorrow> but i have a hacked-on version of hmatrix and i was doing a bunch of other things to it in addition to that...
00:29:16 <sandbox> I ended up just hacking out the tests that were bad to get the thing to build but I assumed I had screwed something up on my system
00:29:57 <mmorrow> no, something is messed up with that package wrt quickcheck. i can't remember what though.. i'm looking
00:30:18 <sandbox> thanks
00:32:19 <mmorrow> oh, actually i got it working in one version of it i have
00:32:22 <mmorrow> i just did
00:32:23 <mmorrow> QuickCheck < 2.0
00:32:31 <mmorrow> in the build-depends:
00:32:42 <sandbox> I'll try it, thanks again
00:32:46 <mmorrow> no prob
00:36:15 <sandbox> that seems to have done the trick :)
00:37:04 <mmorrow> nice
00:37:14 <mmorrow> :)
00:59:21 <mornfall> Is it possible to create two iorefs pointing to same piece of memory?
00:59:39 <mornfall> I guess IORef IOref foo ain't the best idea ever?
01:00:08 <quicksilver> why do you need two different IORefs?
01:00:14 <quicksilver> why not just have two copies of the same one?
01:00:38 <mornfall> Oh, hmm.
01:00:42 <mornfall> I might be mis-thinking.
01:01:54 <mornfall> Ah, I know.
01:01:57 <quicksilver> a <- newIORef 0; let x = a; let y = a;
01:02:11 <quicksilver> ^^ now 'x' and 'y' are "two IORefs" pointing to the same value.
01:03:10 <mornfall> I have been keeping mutable state at the wrong level. (But thanks for pointing that out...)
01:07:43 <mornfall> Oh, hmm, it's not going to fly anyway. D'oh. I really need to get used to this weird imperative language that Haskell is. ; - )
01:09:38 <mornfall> I guess ADTs aren't Storable, right?
01:10:06 <sioraiocht> mornfall: no
01:11:20 <sioraiocht> mornfall: only primitive values are
01:11:46 <sioraiocht> mornfall: what is it that you are trying to do?
01:13:14 <quicksilver> mornfall: you might want to Show/Read them or you might want to Data.Binary them.
01:13:20 <quicksilver> mornfall: but we're only guessing :)
01:13:42 <mornfall> sioraiocht: Well, implement a high-performance queue for thread communication.
01:14:06 <sioraiocht> mornfall: for threads in haskell?
01:14:11 <mornfall> sioraiocht: Aye.
01:14:31 <sioraiocht> is chan not good enough? ;)
01:14:39 <mornfall> sioraiocht: It's too general and therefore too slow.
01:14:43 <mornfall> (About 4 times too slow.)
01:14:48 <sioraiocht> fair enough
01:15:06 <mornfall> I only need one writer / one reader scenarios, so I don't need any locking to happen.
01:15:11 <sioraiocht> what about Data.Sequence?
01:15:58 <mornfall> sioraiocht: Can you concurrently add items and remove items from those?
01:16:21 <mornfall> Doesn't seem.
01:16:40 <sioraiocht> well, it's a persisent data structure..
01:16:51 <mornfall> Right. No matter.
01:17:16 <sioraiocht> you could use a mutable byte array, then
01:17:31 <sioraiocht> if you don't mind it being bounded
01:18:52 <mornfall> I mind. : - ) But I'm using a mutable array for the "chunks".
01:19:08 <sioraiocht> ah
01:19:28 <quicksilver> if your goal is high performance communication
01:19:40 <quicksilver> I'd be surprised if serialising/deserialising is a good idea
01:19:46 <quicksilver> surely it's fast to just pass a pointer :)
01:19:51 <sioraiocht> yep
01:20:11 <sioraiocht> if it needs to be copied the RTS will do it, anyway
01:20:16 <sioraiocht> probably faster than you can
01:22:07 <cads> so the notation of category theory seems to be straight up haskell..
01:22:14 <cads> eerie
01:22:37 <sioraiocht> cads: no, there's a lot more to it than that
01:23:33 <cads> yes, so far all I've grokked is a formalism for sequences
01:24:28 <cads> but it seems like category theory should be representable as haskell code?
01:24:53 <Cale> cads: Well, you could say that the notation of Haskell was influenced by the notation of category theory :)
01:25:43 <cads> very groovy
01:27:18 <Cale> But category theory is significantly more general than Haskell (since it's not really trying to be a programming language itself ;)
01:30:35 <chrisdone> I need a good little talk to listen to while on the bus today. any ideas?
02:00:17 <Myoma> @free lunch
02:00:18 <lambdabot> f . g = h . f => f (lunch g) = lunch h
02:04:58 <Twey> Hahaha, Myoma
02:08:17 <mornfall> Btw., is there a way to tell GHC to push an (IORef) write to memory? (And not keep it in registers for later flushing -- like with C's volatile...).
02:09:39 <mmorrow> mornfall: why do you want to do that?
02:10:55 <quicksilver> mornfall: seems like a strange question, that should be unobservable...
02:11:00 <mmorrow> if it has something to do with another thread, there's atomicModifyIORef or maybe use an MVar?
02:11:11 <quicksilver> in practice the data is very likely to be in memory
02:11:17 <quicksilver> since GHC doesn't use registers all that aggressively
02:11:24 <quicksilver> but hopefully future versions will change that.
02:11:42 <mmorrow> hopefully x2
02:13:06 <mornfall> quicksilver: It's observable when reading the value in another thread.
02:13:08 <sjanssen> is GHC allowed to keep IORef writes in memory?
02:13:14 <mornfall> MVar is locky.
02:13:20 <mmorrow> exactly :)
02:13:29 <mmorrow> you can atomicModifyIORef
02:13:32 <quicksilver> mornfall: don't. Just don't.
02:13:35 <sjanssen> mornfall: in practice, you probably don't have to worry about this
02:13:42 <quicksilver> mornfall: you're not allowed to use IORefs in different threads.
02:13:48 <quicksilver> (in this fashion)
02:13:52 <mmorrow> or use STM
02:13:52 <sjanssen> mornfall: but on the other hand, you're playing with fire
02:13:56 <mmorrow> heh
02:13:57 <mornfall> D'oh.
02:14:00 <quicksilver> mornfall: either find out why Chans are too slow for your purposes
02:14:03 <quicksilver> or use MVars
02:14:10 <quicksilver> or find out why they are too slow.
02:14:18 <mornfall> quicksilver: Chans are too slow because they use MVars?
02:14:35 <mornfall> And MVars are too slow because they mutex?
02:14:41 <sjanssen> mornfall: that probably isn't the real reason
02:15:00 <mmorrow> @src Chan
02:15:00 <lambdabot> Source not found. My pet ferret can type better than you!
02:15:09 <mmorrow> data Chan a = Chan (MVar (Stream a)) (MVar (Stream a))
02:15:14 <mmorrow> type Stream a = MVar (ChItem a)
02:15:18 <mmorrow> data ChItem a = ChItem a (Stream a)
02:15:23 <quicksilver> then I think you need to propose a new ultrafast synchronisation primitive, if MVars really are too slow.
02:15:35 <quicksilver> but I'm fairyl confident GHC does not give you the tools to build a new one.
02:15:42 <quicksilver> You'll need to do some RTS hacking.
02:15:54 <mornfall> quicksilver: They are decent for synchronisation, when it's needed. But no sync needed for a FIFO.
02:15:55 <quicksilver> in my experience MVars are pretty fast.
02:16:24 <quicksilver> you disagree with me only in terminology.
02:16:28 <mmorrow> me too (for anything i've tried..)
02:16:35 <quicksilver> I would describe a between-thread FIFO as a kind of synchronisation
02:16:42 <quicksilver> if you choose not to use that word, fine.
02:16:44 <mmorrow> mornfall: out of curiosity, what're you doing where an MVar is too slow?
02:16:54 <mornfall> mmorrow: between-thread FIFO.
02:17:41 <sjanssen> mornfall: hey, did you ever get a chance to benchmark TChan vs Chan?
02:17:42 <mornfall> I get 6 million items / s in C++, and less than 1.5 in GHC. That's hardly due to language overhead, is it?
02:17:53 <mmorrow> hmm, what're you sending?
02:17:59 <quicksilver> 4x is not atypical for language overhead in fact.
02:18:10 <mornfall> mmorrow: For benchmark purposes, integers.
02:18:21 <mornfall> mmorrow: In the real C++, pointers.
02:18:26 <mmorrow> oh
02:18:34 <mmorrow> Integers /= ptrs
02:18:38 <sjanssen> 4x could even be explained by unboxedness in C++ and boxedness in Haskell
02:18:38 <mmorrow> in size
02:18:51 <sjanssen> mornfall: you're actually sending Integer, or Int?
02:18:59 <mmorrow> @src Integer
02:19:00 <lambdabot> data Integer = S# Int#
02:19:00 <lambdabot>              | J# Int# ByteArray#
02:19:00 <mornfall> sjanssen: Int...
02:19:16 <Myoma> J#
02:19:25 <mmorrow> integers can be of arbitrary size
02:19:28 <Cale> Integers are effectively pointers to structures with a tag and then either a machine integer, or a machine integer size and another pointer :)
02:19:43 <mornfall> Right right, sorry for terminology.
02:19:56 <mornfall> The Haskell type I send is Int.
02:20:10 <mornfall> The C++ type is int.
02:20:14 <mmorrow> oh, that's a diff story then
02:20:40 <mmorrow> how are you implem the fifo?
02:20:45 <Cale> data Int = GHC.Base.I# GHC.Prim.Int#
02:20:49 <quicksilver> I think you're looking at more of a boxiness / language overhead than a specific locky problem.
02:21:18 <mmorrow> Cale: yeah, not a diff story by much though
02:21:50 <mornfall> mmorrow: In C++? (I'm just trying to mimick it in Haskell so far, without much extra thought...)
02:22:04 <mmorrow> in haskell
02:22:24 <mmorrow> the fifo is a single IORef?
02:22:37 <mmorrow> of what type?
02:23:19 <mornfall> For now (ConcurrentList RingBuffer)
02:23:41 <mornfall> Where RingBuffer is { read :: !Int, buffer :: MArray Int a, write :: !Int }
02:23:48 <hackage> Uploaded to hackage: panda 0.0
02:23:48 <hackage> Uploaded to hackage: mps 0.0
02:24:21 <mmorrow> what is it in c++?
02:24:28 <quicksilver> I wouldn't be all that surprised if MArray was slower than Chan ;)
02:24:35 <quicksilver> did you compare those two?
02:24:36 <mornfall> CuncurrentList is head :: IORef ConcurrentCell, tail :: IORef ConcurrentCell; ConcurrentCell is { load :: IORef a, next :: IORef ConcurrentCell }
02:24:39 <mornfall> Roughly.
02:24:47 <mornfall> quicksilver: Not yet...
02:25:22 <mmorrow> ConcurrentList is essentially a Chan with s/MVar/IORef/ it looks like
02:25:30 <mornfall> mmorrow: http://rafb.net/p/dRz0m836.html
02:25:31 <lambdabot> Title: Nopaste - No description
02:25:43 <mornfall> mmorrow: This is the "ring buffer in a list" structure from C++.
02:26:24 <purestorm> How to convert from [a] to (a,a,a,a)?
02:26:28 <mornfall> ConcurrentList then would correspond to http://rafb.net/p/jG3GLi20.html
02:26:30 <lambdabot> Title: Nopaste - No description
02:26:35 <mornfall> lambdabot: Hush.
02:26:41 <Myoma> purestorm: lots of ways
02:26:47 <sjanssen> word for the wise: if your C++ code contains the word "cacheLine" you will be disappointed when porting it to Haskell.
02:26:53 <Myoma> \[a,b,c,d] -> (a,b,c,d) seems to be the most obvious
02:27:18 <purestorm> Myoma: Any shorter way? Actually, it is an 8-tuple.
02:27:23 <mornfall> (The freehead/freetail stuff is just an allocator hint, sort of.)
02:27:32 <opqdonut> purestorm: no, there isn't really
02:27:37 <Myoma> purestorm: sure just name it, the name is shorter
02:27:45 <purestorm> OK, thx
02:27:49 <mmorrow> mornfall: cool
02:27:53 <chrisdone> can lambdabot join another channel please?
02:28:03 <chrisdone> @join #haskell
02:28:03 <lambdabot> Not enough privileges
02:28:06 <chrisdone> : (
02:28:13 <mornfall> sjanssen: So you think that FFI-ing it is a better idea, then?
02:28:48 <mmorrow> then the rts'll lose control over it (if that is an issue)
02:28:56 <sjanssen> mornfall: I'm just saying that this sort of task is not Haskell's usual domain
02:28:56 <mornfall> Well, the point with haskell is: Dons's post on -cafe got me interested in high-performance Haskell. I suspect that working in Haskell will make a lot of the stuff easier. But the performance bits seem to be actually quite hard.
02:29:35 <Cale> mornfall: well... you could always bug dons :)
02:29:37 <mornfall> (The C++ project in question contains a language interpreter, that I think would be both faster *and* neater in Haskell, as things are...)
02:29:39 <sjanssen> mornfall: I think you ought to consider approaching the problem from a different direction
02:29:59 <mornfall> sjanssen: Could be. I am just trying the edges, I'd say.
02:30:06 <quicksilver> mornfall: in your experience of your domain, how often is your 6 mill items per second the actual bottleneck?
02:30:42 <quicksilver> it could well be, for example, that your practical programs run at 500K items per second as a different bottleneck is elsewhere? and don's high-performance haskell techniques might help in that bottleneck?
02:31:21 <mornfall> quicksilver: Hard to tell in practice. In benchmarking the performance code, the overhead is about 100 % (you get about 2-fold speedup with 4-fold core increase...).
02:32:05 <mornfall> quicksilver: We generally believe that most of that is in the communication code.
02:32:32 <quicksilver> are you using C++ threads heavily?
02:32:43 <mornfall> quicksilver: One per core.
02:32:51 * quicksilver ponders
02:33:08 <mmorrow> it seems like most of the cases i've seen where haskell is beating/matching the performance of a lang with lower-level access, the haskell code is doing whatever the task is in a completely different way
02:33:31 <mmorrow> which plays to it's strengths
02:34:07 <quicksilver> well if you're going to be faster you have to do somethign different.
02:34:16 <mmorrow> yeah, very true.
02:34:29 <quicksilver> GHC is good at lightweight threading
02:34:33 <sjanssen> mornfall: are the processes that generate and consume these results pure, or are they inherently stateful in some way?
02:34:50 <quicksilver> on the other hand, GHC is poor at memory locality and therefore cache bashing.
02:34:51 <mornfall> sjanssen: Stateful, and I am not sure I can imagine a way to make them not.
02:37:11 <mornfall> Well, the whole story is: We are working on an LTL verifier. We now need a new modelling language and an interpreter for it. Now, doing that in Haskell sounds like it will save a lot of headache.
02:37:46 <quicksilver> conal, Beelsebob : well, I found a case where the nondeterminicity of my mappend showed up. I 'snapshotted' an Event against a Reactive whose rising edges coincided precisely with the Event's occurrences
02:37:46 <mornfall> It's doing automata-based verification, so generating huuuge graphs -- we look for (fair) cycles in those.
02:38:05 <mornfall> I'm not at all sure it's the right domain for Haskell. I'm just trying to evaluate.
02:38:33 <mmorrow> i'm sure you've seen this (?) http://www-i2.informatik.rwth-aachen.de/Staff/Current/stolz/rv/index.html
02:38:35 <mornfall> On the other hand, a project of that kind, with good performance, would be an awesome showcase for Haskell, I think, sort of.
02:38:39 <lambdabot> Title: Runtime Verification of Concurrent Haskell // I2, http://tinyurl.com/6n5ehx
02:38:51 <mmorrow> (i had to google LTL verifier and it was the third result)
02:39:01 <quicksilver> mornfall: sound like the kind of domain where haskell's correctness advantages would be useful, if not its performance.
02:39:15 <quicksilver> mornfall: I.e. if you have found that C++ code a bitch to debug, maybe it would have been easier in haskell.
02:39:17 <mornfall> quicksilver: Right, that's the other motivation.
02:39:19 <sjanssen> mornfall: hmm, maybe it is possible to compile your language into C that uses your ultra-fast primitive stuff?
02:39:42 <quicksilver> on the other hand, for pure performance it may be that you have reached a sweet spot with C++ in terms of cache / core coherency haskell isn't going to match.
02:39:50 <conal> quicksilver: nice catch.
02:40:20 <quicksilver> conal: good practical example of why it's better to define things with nice combinators with clear semantics.
02:40:24 <mornfall> sjanssen: I have been pondering that. But I want to explore the possibility to not do that first.
02:40:38 <quicksilver> conal: rather than exposing the implementation to too high a level and having to debug weird stuff ;)
02:40:39 <conal> quicksilver: :)
02:40:53 <mmorrow> mornfall: language-c is always there if you go that route
02:40:54 <quicksilver> but, I know how to fix my mappend, so maybe i'll do it.
02:41:06 <quicksilver> I"m not sure how long I will wish to continue with my parallel implementation
02:41:11 <quicksilver> but it's a powerful learning experience.
02:43:59 <sjanssen> mornfall: and I'm still curious about the performance of TChan in your app...
02:44:10 <mornfall> sjanssen: Right, let me finish that one.
02:44:48 <mornfall> sjanssen: 1017454/s on 2 cores, 1134571 on a single core.
02:44:50 <quicksilver> sjanssen: TCHan should be less locky, shouldn't it? and therefore possibly faster.
02:45:02 <mornfall> sjanssen: That is with -A80M
02:45:45 <sjanssen> mornfall: at any given time, how many items to you think are in the queue?
02:45:51 <mornfall> With Concurrent.Chan, I get 1628918 with same -T and 2 cores.
02:45:53 <sjanssen> s/to you/do you/
02:46:16 <mornfall> sjanssen: In the benchmark? No idea, it should be nearly empty. In practice, it'll tend to megabytes of data.
02:46:16 <quicksilver> conal: did you lose connection there?
02:46:32 <mornfall> sjanssen: Since processing the queue is CPU-intensive there.
02:46:37 <conal> quicksilver: yes.  we have a flaky connection here.
02:46:39 <sjanssen> mornfall: ah, now this is potentially very important
02:47:00 <quicksilver> conal: but, I know how to fix my mappend, so maybe i'll do it.  I"m not sure how long I will wish to continue with my parallel implementation, but it's a powerful learning experience.
02:47:31 <sjanssen> mornfall: both STM and the MVar based chans are much faster when there is some distance between the reading and writing ends, because it practically eliminates contention on those locks
02:47:31 <mornfall> sjanssen: Possibly true. You absolutely want the ends of the queue to reside on different cache lines, for mt performance.
02:47:40 <conal> quicksilver: thanks for the repeat.  i'm curious about your mappend fix.
02:47:58 <quicksilver> conal: Currently I naively block on both events and whichever one wakes up first.
02:48:12 <quicksilver> instead I plan to add to my future impl a nonblocking read primitive.
02:48:23 <sjanssen> mornfall: I wouldn't worry too much about cache lines and the like, you're too far from the hardware to capitilize on any of that
02:48:26 <quicksilver> then I will block on both, but when one wakes up, I'll nonblocking check the other
02:48:33 <quicksilver> if I get both, I'll compare times and prefer the first.
02:49:12 <conal> quicksilver: that approach sounds likely to work.
02:49:51 <quicksilver> conal: You're dead right that the fmapp'ed stuff doesn't get cached.
02:50:02 <quicksilver> I hadn't even realised that ought to be a design goal :)
02:50:06 <quicksilver> but of course, you're right.
02:50:25 <conal> quicksilver: it was easy for me to spot, since everyone seems to do it that way at first (including me)
02:50:32 <quicksilver> the "underlying" bit will still get cached but the fmap'ed function will get applied separately by each client.
02:51:02 <conal> quicksilver: depends on how the underlying bit gets constructed.
02:51:17 <quicksilver> conal: yes, if it's another fmap it doesn't ;)
02:51:26 <conal> quicksilver: exactly
02:51:27 <quicksilver> conal: only things built with 'buildFuture' are guaranteed cached.
02:51:43 <quicksilver> because buildFuture creates an MVar precisely for the caching.
02:51:55 <quicksilver> (well also for the only-call-once semantics)
02:52:08 <quicksilver> however, fmap can't create a new MVar
02:52:10 <quicksilver> it can't live in IO
02:52:12 <quicksilver> (without cheating)
02:52:24 <conal> quicksilver: exactly.  ditto for mappend and <*>
02:52:51 <conal> quicksilver: IO doesn't match the problem, semantically.
02:53:37 <quicksilver> although haskell doesn't have anywhere else for 'caching' to live.
02:53:45 <quicksilver> haskell chucks all such things into IO.
02:54:13 <conal> quicksilver: or use purely functional values, and let the language implementation handle caching.
02:54:52 <conal> quicksilver: that was my conclusion.
02:55:06 <quicksilver> conal: although there is no abstract guaranteed interface to that, so you do end up relying on GHC implementation details to make that work.
02:55:16 <quicksilver> Even if the things you rely on seem failrly natural.
02:56:18 <conal> quicksilver: i don't need a caching guarantee any more than i already get.  the compiler's job is efficient implementation of correct semantics.  that's all i'm going for.
02:56:23 <mornfall> Maybe I should instead think of how to do without channels. ; - )
02:57:36 <quicksilver> conal: I think you make some (very reasonable) assumptions about evaluation order
02:57:43 <quicksilver> conal: which go beyond what is technically guaranteed.
02:57:49 <quicksilver> conal: I might be misunderstanding though.
02:58:05 <ivanm> anyone know how I can contact the author of the hstats package? the email address on hackage keeps bouncing :ss
02:58:09 <conal> quicksilver: oh?
02:58:33 <conal> quicksilver: btw, value reuse isn't always the best choice, which afaiu is why ghc doesn't do automatic CSE.
02:59:40 <Philippa> quicksilver: presumably also about sharing?
02:59:42 <quicksilver> conal: right.
02:59:52 <quicksilver> Philippa: I think so.
03:00:04 <Philippa> see "call-by-name is a valid if stupid implementation"
03:01:35 <quicksilver> conal: your use of "unsafeReadMVar" creates what might be called "pure, yet blocking, values"
03:02:01 <quicksilver> conal: AFAIK that's not really something satisfactorily accounted for by standard (even informal) accounts of haskell semantics.
03:04:56 <conal> quicksilver: in the IO adapter stuff.  yes.
03:05:33 <quicksilver> conal: in newFuture.
03:05:46 * conal looks
03:05:48 <quicksilver> which, as far as I understand it, is the intended way to make interesting futures :)
03:06:30 <conal> quicksilver: hey.  newFuture is in the old reactive implementation, not the new one, afaict.
03:06:52 <purestorm> Hi, I'm trying to use HUnit to test some of my Parsec-based parsers. However, GHC tells me that I am missing the instance of Eq for ParseError. How can I fix thsi?
03:07:09 <quicksilver> conal: Oh. I am reading hte wrong file?
03:07:17 <quicksilver> conal: I'm reading http://code.haskell.org/reactive/reactive/src/FRP/Reactive/Future.hs
03:07:19 <lambdabot> http://tinyurl.com/5pg6sh
03:08:59 <conal> quicksilver: isn't that def commented out?
03:09:18 <conal> quicksilver: still, it reappears in the legacy (IO) adapter, which is work in progress.
03:11:20 <yitz> purestorm: is there really no Eq instance for ParseError? if so that sounds like it should be filed as a bug
03:11:22 <conal> quicksilver: and yes, i don't know how to make primitive "pure, yet blocking, values" in Haskell on top of published semantics.
03:11:43 <mmorrow> yitz: and apparently they hide the constructor as well
03:11:54 <purestorm> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec.html#t%3AParseError
03:11:56 <lambdabot> Title: Text.Parsec, http://tinyurl.com/5wya6b
03:12:00 <mmorrow> purestorm: i guess write your own instance
03:12:37 <yitz> mmorrow: if the constructor is not available it could be hard to do
03:12:39 <purestorm> mmorrow: Can't I somehow use deriving?
03:13:25 <purestorm> Hm, reading the source... What is the ! for in data declarations?
03:13:26 <quicksilver> conal: Doh. Yes, it's commented out.
03:13:34 <quicksilver> conal: my eyes didn't pick up the {-
03:13:45 <yitz> purestorm: do you need unit tests involving ParseError, or it's just a technical issue to get HUnit working with Parsec?
03:14:13 <yitz> quicksilver: you don't have colorization?
03:14:18 <conal> quicksilver: i'll get this stuff cleaned up soon, including clearing out the junk dead code and moving the testing code to another package.
03:14:20 <purestorm> I want to do (expected parser result == Right parser result) and it complains about eq missing for ParserError
03:14:41 <quicksilver> conal: OK, anyway, that is my caveat in a nutshell. Not a criticism, but it's a subtlety around "let the language implementation handle caching" is "but we pull some slight tricks to add the notion of a blocking pure value to the language implementation"
03:15:02 <quicksilver> yitz: in my editor, yes, I was viewing this directly in a web brwoser window though.
03:15:05 <sjanssen> purestorm: probably what you'll have to do is: case parser result of Left _ -> False; Right x -> x == expected
03:15:20 <conal> quicksilver: thx.  i like your summary.
03:15:24 <purestorm> Uhm, HUnit has this assertEqual function that I want to use.
03:15:38 <quicksilver> conal: and of course "blocking pure values" could lead to deadlocks if used without care.
03:15:39 <purestorm> Anyway, how do I file a bug for Parsec? Contact the maintainer directly?
03:15:47 <yitz> purestorm: ah ok, so you can hack a workaround by saying instance Eq ParserError where _ == _ = True
03:15:51 <quicksilver> conal: ideally, we set up combinators which are provably deadlock-free.
03:16:06 <yitz> purestorm: post what you wrote here to the libraries mailing list
03:16:06 <sjanssen> purestorm: the lack of an Eq instance is probably intentional (it seems ParseError is supposed to be an abstract type)
03:16:15 <conal> quicksilver: yeah.  maybe with tools like unamb and improving values
03:17:07 <purestorm> yitz: Where do I find this?
03:17:13 <yitz> sjanssen: it could be abstract, but providing neither Eq nor a way to do it yourself is very impolite
03:17:29 <mmorrow> purestorm: this seems to work (==compile) http://hpaste.org/10197
03:17:56 <mmorrow> purestorm: i tried to use stand-alone deriving, but it doesn't work since the constructor are hidden
03:17:57 <sjanssen> yitz: does it make sense to compare parse errors?
03:18:22 <yitz> purestorm: http://www.haskell.org/mailman/listinfo/libraries
03:18:23 <lambdabot> Title: Libraries Info Page
03:19:09 <yitz> sjanssen: just to say whether two are the same? why not?
03:19:20 <conal> i want to set up some kind of mailing list for reactive (which i plan to release soon).  the most obvious thing is to set up a mailman-based list on haskell.org, but i wonder -- do people really want to keep using this old-fashioned mailing list technology?  or something more modern like yahoo or google groups.
03:19:35 <conal> any thoughts/preferences?
03:19:42 <conal> (question to all)
03:19:52 <yitz> sjanssen: does it make sense to disallow using Parsec with HUnit or other libraries?
03:20:15 <sjanssen> yitz: I'm sure there's another way
03:20:41 <yitz> sjanssen: maybe the hack should be instance Eq ParseError where _ == _ = False
03:20:50 <quicksilver> conal: well personally I find mailing lists a whole lot more convenient than new fangled web stuff :)
03:20:54 <quicksilver> conal: I like my email reader.
03:21:14 <yitz> sjanssen: could be. any ideas?
03:21:18 <sjanssen> yitz: (==) should always be reflexive
03:21:44 <yitz> sjanssen: yeah, that's a bad hack, no question.
03:21:49 <sjanssen> yitz: yeah, use assertBool instead of assertEqual
03:22:05 <sjanssen> purestorm: ^^^ workaround?
03:22:08 <conal> quicksilver: thx.  i use my email reader also with yahoo & google groups.  though i like searching archives better on y&g groups.  and i like some of the other modern features, like personal profiles and polls.
03:22:42 <mgsloan> hmm, is there a good way to filter a list to a specific constructor, while pattern matching on its contents?
03:22:45 <purestorm> sjanssen: :) mmorrow Eq operator seems to do the job, too.
03:22:55 <sjanssen> yuck.
03:23:12 <Myoma> mgsloan: You wish for a filtering map?
03:23:22 <sjanssen> x /= x ftw!
03:23:31 <mgsloan> Myoma - that'd be the gist of it, yeah
03:23:41 <Myoma> > do Just x <- [Just 1, Nothing, Just 2] ; return (x+1)
03:23:42 <lambdabot>   [2,3]
03:23:46 <Myoma> this is a way
03:23:48 <hackage> Uploaded to hackage: panda 0.0.0.1
03:24:01 <yitz> purestorm: sjanssen is right, if you can work around the problem without using my horrible hack please do so
03:24:10 <mgsloan> Myoma - ooh, nice
03:24:17 <mgsloan> can that also be done with comprehensions?
03:24:20 <Myoma> @undo do Just x <- [Just 1, Nothing, Just 2] ; return (x+1)
03:24:20 <lambdabot> [Just 1, Nothing, Just 2] >>= \ a -> case a of { Just x -> return (x + 1); _ -> fail ""}
03:24:53 <mgsloan> > [x, Just x <- [Just 1, Nothing, Just 2]]
03:24:54 <lambdabot>   mueval: Prelude.read: no parse
03:25:13 <mgsloan> ﻿> [x, (Just x) <- [Just 1, Nothing, Just 2]]
03:25:23 <mmorrow> conal: i think msg board-type thingies are really great/convenient/fun, but only when people actually use the features.
03:26:07 <conal> mmorrow: yep.
03:26:33 <sjanssen> I find it hard to keep up with all discussion on message boards
03:26:42 <yitz> sjanssen: anyway, I don't see why ParserError needs to be so opaque that you can't tell if they're equal.
03:26:57 <mgsloan> for the record, yes list comprehensions do what I want very nicely :)
03:27:02 <sjanssen> yitz: yeah, it's a fair question
03:27:33 <yitz> sjanssen: and if that really is important, then that should be expressed by a providing an always-equal trivial Eq instance.
03:27:35 <conal> i've been wondering if haskellers really like mailman or are just used to it.  maybe people make new mailman lists simply because others did it before them.
03:27:39 <purestorm> sjanssen: Hm, even for ==, I need Eq?
03:27:59 <yitz> sjanssen: so as not to lock out Eq instances from anything built on it
03:28:09 <sjanssen> purestorm: yep, that's where (==) comes from
03:28:30 <purestorm> So I'm still stuck with the missing Eq instance for ParserError,right?
03:28:52 <quicksilver> conal: I don't much care if the email comes from mailman or groups as long as it arrives in my email and it doesn't butcher thread info.
03:28:54 <sjanssen> yitz: x == y = show x == show y -- would potentially work
03:29:28 <sjanssen> purestorm: not in my example, because we're using (==) on the success side of the parse, not the failure side
03:30:02 <yitz> sjanssen: ah, that's an idea
03:30:04 <conal> thanks for the feedback.  i'll ask on haskell-cafe also.
03:30:27 <mmorrow> sjanssen, purestorm: so am i understanding that you're saying this /doesn't/ work?? e1 == e2 = and $ (errorPos e1 == errorPos e2) : zipWith messageEq (errorMessages e1) (errorMessages e2)
03:30:33 <yitz> sjanssen: well I still think the best would be "deriving Eq" in the library.
03:30:55 <mmorrow> x == x  for sure there
03:31:06 <purestorm> mmorrow: I'm not saying this. I'm clueless :)
03:31:29 <sjanssen> mmorrow: heh, if the library exports all that, I withdraw my abstraction complaint :)
03:31:41 <FordCortina> im trying to understand the Epigram notation here. http://sneezy.cs.nott.ac.uk/fun/nov-07/R-star.pdf
03:31:53 <lambdabot> Title: Untitled
03:32:05 <mmorrow> yeah totally, it's like why export all this, then just omit an Eq instance? seems weird.
03:32:09 <FordCortina> does the * in R* mean something in particular in epigram?
03:32:24 <yitz> purestorm: in any case try to use sjanssen's suggestion - switch to assertBool.
03:32:37 <FordCortina> i mean... i think i understand that R is some kind of type constructor
03:32:39 <purestorm> Yeah, that seems to work.
03:32:53 <FordCortina> that takes to types X where X is some pair (a,b)
03:33:03 <FordCortina> what does the * do to it?
03:33:10 <yitz> purestorm: because even if you provide exactly the right Eq instance for ParseError, your code will become broken if that instance is ever provided by the library later on.
03:34:04 <FordCortina> s/to types/two types/
03:34:54 <mmorrow> well, i guess maybe the Eq instance is omitted because there isn't one way that's the "well, obviously" way to define equality i guess.
03:35:20 <mmorrow> by position, by message, or by both
03:36:46 <yitz> mmorrow: that happens sometimes. which is why it's a real problem that you can't control export of instances.
03:37:28 <sjanssen> mmorrow: I think it has to be by both
03:39:58 <yitz> those who argue against regulating instance exports say that it is an immutable univeral property of the universe that every instance is canonical.
03:40:25 <quicksilver> I don't say that
03:40:32 <quicksilver> I say it's required for soundness of haskell programs.
03:40:40 <quicksilver> non-canonical instances will break code.
03:40:52 <yitz> I don't believe that. But even if it's true in principle, in a practical software development environment that is bound to cause serious trouble.
03:41:22 <quicksilver> you don't believe it will break code?
03:41:26 <quicksilver> or you don't believe it will matter?
03:41:46 <quicksilver> Suppose you have one Ord instance for Foo in scope in module A
03:41:52 <quicksilver> and another in scope in module B
03:42:03 <quicksilver> and suppose a Data.Map Foo gets passed indirectly from A to B
03:42:05 <quicksilver> bang!
03:42:06 <yitz> I'll agree that intentionally using multiple instances is bad design.
03:42:57 <yitz> It will break more code not to allow suppressing instance export/import.
03:43:03 <sjanssen> purestorm: if you still care, this is my preferred solution: http://hpaste.org/10198
03:43:22 <quicksilver> yitz: you don't think my example is worrying?
03:43:47 <purestorm> sjanssen: Awesome! Thanks, you da man!
03:44:05 <yitz> quicksilver: it is. if it happens, one way to fix it is not to export one of the Ord instance.
03:44:37 <sjanssen> if that doesn't make yitz worry, swap Ord for Storable and Data.Map for Ptr
03:44:49 <yitz> sjanssen: heh
03:44:54 <quicksilver> yitz: I think we'll just have to agree to differ.
03:45:10 <quicksilver> to my mind this example makes it totally clear that the global instance property is vital for soundness.
03:45:17 <quicksilver> I don't even see anything left to discuss :)
03:45:22 <sjanssen> yitz: but is not exporting sufficient?  Not in the Map case, I think
03:45:45 <quicksilver> I'm inclined to dislike orphan instances, even, because they make it harder to guarantee the global instance property.
03:45:50 <yitz> quicksilver: here's my example. Picture two independent teams developing two different components of a software system.
03:46:29 <yitz> quicksilver: each team, thinking within their own domain, provides their own "canonical" instance for some class.
03:46:42 <sjanssen> quicksilver: my rule of thumb is that instances should only be defined in the same module as the class decl. or the data decl.  Anything else is asking for trouble
03:46:59 <quicksilver> sjanssen: yes, that's what orphan means, precisely
03:47:08 <quicksilver> sjanssen: (orphan means not with the data decl or the class decl)
03:47:27 <yitz> quicksilver: when integration time comes - nearing the deadline - it suddenly becomes known that the entire system neads to be refactored.
03:47:35 <quicksilver> rubbish.
03:47:40 <yitz> quicksilver: this scenario doesn't worry you?
03:47:44 <quicksilver> fixing that kind of problem is not a complete refactor
03:47:51 <quicksilver> it's a minor integration hurdle.
03:47:51 * sjanssen notices that all of yitz's hypothetical examples start in the same scenario :)
03:48:09 <quicksilver> and it would never even occur if people stuck to sjanssen's rule of thumb.
03:48:17 <quicksilver> whichever team develops the data type, provides the instance.
03:48:33 <quicksilver> if the other team needs an instance for a data type not-developed-by-them, they communicate with the other team.
03:48:36 <ac> is there a shorthand for: if foo then bar else return () -- ?
03:48:44 <Myoma> @src guard
03:48:44 <lambdabot> guard True  =  return ()
03:48:44 <lambdabot> guard False =  mzero
03:48:48 <sjanssen> @src when
03:48:49 <lambdabot> when p s = if p then s else return ()
03:48:52 <quicksilver> it's hardly un-natural for teams which share constraints to share libraries.
03:48:53 <yitz> sjanssen: yeah, I think that this scenario is one that was not thought of enough for Haskell
03:49:05 <yitz> sjanssen: it has a lot of consequences
03:49:18 <ac> sjanssen: thanks
03:49:49 <sjanssen> quicksilver: I suppose the problem is when both teams are clients of the same third party data type
03:49:53 <yitz> quicksilver: what happens is that one or the other will have to use newtype wrapping. and that will be very painful.
03:50:05 <yitz> sjanssen: yes that'
03:50:08 <yitz> s the idea
03:50:14 <sjanssen> (this Parsec issue, for example)
03:50:38 <yitz> sjanssen: well, almost. here an instance wasn't provided at all.
03:51:09 <quicksilver> sjanssen: then they need a company-internal thin wrapper around that.
03:51:27 <quicksilver> sjanssen: it's not that unusual to have company-internal interface libs around external resources.
03:51:36 <mmorrow> sjanssen: yeah, by both seems to be the most logical way.
03:51:40 <quicksilver> yitz: newtype wrapping very painful?
03:51:52 <quicksilver> yitz: I would rather say newtype wrapping = 15 minute search and replace job
03:52:02 <quicksilver> hardly a big issue at the end of a 6 month development cycle.
03:52:10 <yitz> quicksilver: you need to change every function that uses this type and relies on this instance
03:52:16 <quicksilver> the great thing about newtype wrappings is that any bugs will be immediately caught by the compiler.
03:52:27 <quicksilver> (if we had a working HaRe it would be 15 seconds, I guess)
03:52:43 <quicksilver> yitz: yes. That is very easy indeed to do.
03:52:49 <sjanssen> my other personal rule about instances is that there should only be an instance if there is only one morally correct choice
03:53:04 <quicksilver> I've witnessed far worse refactorings caused by separate teams than this :)
03:53:31 <quicksilver> sjanssen: My stronger rule is "There should only be a typeclass in the first place if it seems likely that there will only be one morally correct instance for each type"
03:53:47 <sjanssen> quicksilver: I dunno, Monoid is insanely useful
03:53:48 <quicksilver> sjanssen: I see typeclasses used too often when higher-order functions would be more modular and composable.
03:53:56 <yitz> quicksilver: I suppose HaRe would be another approach. Seems a lot messier to me though. Has a kind of MS Visual Studio feel to it.
03:54:17 <yitz> quicksilver: that's certainly true
03:54:24 <quicksilver> sjanssen: yes. It's not a rule I can stick to entirely honestly. Monoid is certainly very useful.
03:54:37 <quicksilver> sjanssen: but it's a guideline :)
03:54:46 <yitz> quicksilver: people coming from OO languages (like I did) tend to really abuse typeclasses at first.
03:55:06 * quicksilver nods
03:55:18 <mmorrow> i love template-haskell though ...
03:55:19 <mmorrow> ghci> putStrLn . pprint . cleanNames $ $(lift =<< reify ''ParseError)
03:55:19 <mmorrow> data ParseError = ParseError !SourcePos ([] Message)
03:55:46 <mmorrow> breaks all attempts at hiding (for better or for worse)
03:55:58 <sioraiocht> typeclass abuse: a growing problem that YOU can help stop
03:55:58 <mgsloan> hrmm, anyone know how to go from two numeric values to a Data.Ranged.Ranges.Range?  the only functions which yield ranges seem to be one singleton range and functions which go from ranges to ranges
03:56:25 <quicksilver> sioraiocht: how can I help stop it?
03:56:52 <mmorrow> put you campfire out before you leave?
03:56:53 <sioraiocht> by thwacking people on the head and letting them know that type classes are NOT java interfaces
03:56:58 <sjanssen> mgsloan: is the constructor exported?
03:57:21 <mgsloan> yes, but it goes from two Boundary types
03:57:21 <mmorrow> thwacking is such a great word
03:57:24 <Myoma> so what are they then?
03:57:25 <mgsloan> which don't seem to have constructors
03:57:48 <ziman> sioraiocht, what's the difference?
03:57:49 <yitz> sioraiocht: it's a cyclic process. 1) straight off the OO boat, overuse 2) got used to Haskell, underuse 3) read an Oleg paper, overuse 4) tried to debug Olegese, underuse. etc.
03:58:13 <sjanssen> mgsloan: Data.Ranged.Boundaries seems to export some
03:58:23 <sioraiocht> lol
03:59:21 <mgsloan> sjanssen - ah, so they do. for some reason I didn't see them.. thanks!
04:00:47 <yitz> quicksilver: have you ever developed under ISO9000 or some other controlled process?
04:01:26 <yitz> quicksilver: refactoring can be very, very painful. file forms in triplicate, figure out which documents need to be updated, etc. for each function.
04:03:00 <quicksilver> yitz: Such problems occur in all kinds of software development, it seems unreasonable to single out typeclasses as one.
04:03:11 <cjs> There was an article on trying to be agile  with processes like that.
04:03:18 <quicksilver> I've given several possible ways of avoiding the situation.
04:03:41 <quicksilver> in C++, for example, you can really fakk things up by locally subclassing a class which 'doesn't belong to your team'
04:03:49 <quicksilver> that can cause massive problems down the line.
04:03:49 <cjs> It was about building autopilot systems or something like that. Basically, you try to put off the certification stuff as late as possible.
04:03:52 <quicksilver> really this is a similar issue.
04:03:58 <yitz> quicksilver: looking at it from the pov of a project manager - any feature that propogates globally through a project and cannot be regulated locally is evil.
04:04:04 <quicksilver> instances "belong to" the datatype.
04:04:24 <quicksilver> they should either live with the datatype, or they should live in the canonical loction in your code most associated with that type.
04:04:32 <quicksilver> (your local wrapper library)
04:04:45 <quicksilver> local instances are just wrong because they lead to unsoundness.
04:04:51 <yitz> cjs: actually it can provide value if you work with it and not work around it.
04:04:55 <quicksilver> and unsoundness is a much worse problem than anoying paperwork.
04:05:29 <cjs> yitz: For well-defined problems, I'll believe you.
04:05:40 <sjanssen> yitz: you could make the "no orphans" rule part of your standard development process
04:06:02 <yitz> cjs: when I'm a passenger on an airliner, I sure hope the autopilot project was well-defined.
04:06:28 <quicksilver> Heffalump-- # If you're gonig to answer conal so negatively you owe him at least some kind of reasoning :P
04:06:31 * Myoma hopes there's people flying the thing :/
04:06:47 <cjs> yitz: By the end of it, yes.
04:07:07 <yitz> global semantic spam is a serious source of unsoundness.
04:07:13 <cjs> Hm. How can I use my brand new spiffy second core to make ghc compile faster?
04:07:29 <quicksilver> I don't believe GHC uses anything concurrent in its compile process.
04:07:37 <quicksilver> you can use make -j2 if you have independent source files
04:07:44 <quicksilver> (but that forces you to use make!!!)
04:07:48 <cjs> I use ghc --make. :-(
04:08:16 <yitz> cjs: split your modules into two makefiles. run make in two processes.
04:08:30 <quicksilver> I view the advantage of dual-core than GHC gets a whole core to itself and doesn't have to share with bloated ridiculous email and browser processes :P
04:08:34 <Myoma> why don't you just do two things at once?
04:08:41 <Myoma> one of them which isn't compiling
04:08:55 <cjs> This machine at the moment has none of those; I'm using it over a network.
04:09:00 <purestorm> Compilers are pretty sequential animals. Sadly.
04:09:39 <Myoma> making ghc --make able to do some things in parallel would be good
04:09:48 <cjs> You'd think that --make could do some stuff in parallel.
04:09:54 <sjanssen> there was actually a ghc branch where --make was parallel
04:09:56 <Myoma> I think currently it cannot
04:10:04 <Myoma> but could be hacked
04:10:17 <cjs> Ah well. But even on a single core, it's 30% faster than my laptop.
04:10:21 <sjanssen> it is mentioned in one of the GHC SMP papers, dunno if it was ever made public
04:13:06 <yitz> sjanssen: now we can start working on an IPC solution to mutually recursive modules.
04:14:00 <sjanssen> yitz: in the case of mutually recursive modules, the team with the .hs-boot file gets to write the instance :)
04:14:15 <sjanssen> (actually, I think they'd have to)
04:14:52 <yitz> sjanssen: eww. mutually recursive modules across team boundaries. what a nightmare.
04:23:49 <hackage> Uploaded to hackage: hgal 1.0.2
04:50:07 <cjs> So if I've got several definitions of foo, which takes two arguments, written out as "foo a b = ..." or whatever, is there a way for me to say "foo = bar" as the last case when bar also takes the same two arguments? (As opposed to "foo a b = bar a b".)
04:51:25 <ddarius> No
04:51:55 <quicksilver> cjs: no. I have seen that discussed once as a feature request.
04:52:00 <cjs> Too bad.
04:52:14 <quicksilver> it was concluded (if not quite by consensus) that the cost/benefit ratio doesn't justify it.
04:52:30 <quicksilver> the restriction allows early reporting of a rather obvious class of errors
04:52:37 <cjs> Hm. A quick clean recompile also tells me that I don't need it nearly as much as I thought I did. :-)
04:52:49 <quicksilver> dropping that restriction would lead to those errors becoming very obscure looking type errors
04:53:00 <quicksilver> or, in pathalogical cases, actually type-checking in an unexpected way.
04:53:37 <Myoma> "... is used to derive one expression from one or more other expressions antecedently expressed in the system"
04:53:56 <torquel> hi, is there a very simple way of getting a "call trace" on a complex Haskell program. I really want to see what function names are being evaluated in what order.
04:54:14 <Myoma> torquel: that is not how haskell works
04:54:22 <sclv> you can insert traces by hand with Debug.Trace
04:54:24 <opqdonut> torquel: ghci has a debugger
04:54:30 <opqdonut> which can give you somethin like that
04:54:32 <Myoma> there is no call trace
04:54:43 <chr1s> does anybody know what the options are for serializing functions in Haskell?
04:54:59 <quicksilver> chr1s: (a) None.
04:55:01 <sclv> Myoma: The debugger does let you get something similar however.
04:55:11 <torquel> Running ghci, is it easy to enable it?
04:55:11 <chr1s> quicksilver: yeah, that's what I guessed.
04:55:13 <sclv> but I've always found Debug.Trace to be sufficient.
04:55:17 <opqdonut> chr1s: hs-plugins kinda almost maybe
04:55:21 <quicksilver> chr1s: (b) there are some very neat hacks.
04:55:31 <chr1s> ah, show me! :D
04:56:25 <sclv> The only hack I know is to us th to reify yr. function call as a data type and serialize that?
04:56:33 <sclv> s/us/use/
04:56:39 <torquel> Is there a very good GUI for Haskell on Mac OS X these days?
04:56:39 <mdmkolbe> What is a CoState arrow? (as in http://hackage.haskell.org/packages/archive/arrows/0.4/doc/html/Control-Arrow-Transformer-CoState.html)
04:56:41 <lambdabot> Title: Control.Arrow.Transformer.CoState, http://tinyurl.com/6zhey9
04:57:04 <sclv> chr1s: why do you want to serialize anyway?
04:57:09 <ivanm> torquel: there's bindings to cocoa IIRC \
04:57:14 <mdmkolbe> torquel: GUI as in GUI toolkit for making apps for GUI as in IDE?
04:57:22 <torquel> (tried :trace expr but it shows nothing so I press Ctrl-C. Try :history but shows nothing, "not stopped at breakpoint")
04:57:25 <sclv> because if its for rpc, then look at xml-rpc too (haxr)
04:57:46 <chr1s> sclv: I'd like to build a continuation-based web-framework.
04:57:47 <mdmkolbe> s/for/or/
04:58:13 <sclv> chr1s: but you don't need to reify for that except to serialize state?
04:58:16 <chr1s> torquel: there's HOC, but that's a bit unmaintained.
04:58:33 <quicksilver> torquel: what do you mean by GUI?
04:58:35 <sclv> hmm... take a look at haxr anyway though -- its a very lightweight approach.
04:58:43 <quicksilver> (do programming languages need GUIs?)
04:58:51 <sclv> if it can serialize a function call over the wire, it can serialize a call to disk and back too.
04:58:52 <quicksilver> torquel: if you mean a GUI IDE, then the answer is no.
04:59:04 <torquel> quicksilver, editor instead of emacs
04:59:09 <sclv> i'm using something similar but even lighter weight (based on read/show)
04:59:14 <chr1s> sclv: I'll take a look at it.
04:59:22 <ivanm> torquel: there's always aquamacs! ;-)
04:59:35 <quicksilver> aquamacs-- # misguided, and very evil
04:59:41 <ivanm> quicksilver: why?
05:00:09 <quicksilver> it breaks some of the keybindings
05:00:11 <sclv> torquel: re the debugger, take a look at http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14
05:00:13 <lambdabot> Title: Haskell hacking
05:00:14 <torquel> I guess I want to have a stack trace.
05:00:17 <ivanm> quicksilver: oh...
05:00:18 <quicksilver> in an attempt ot be more consistent with teh rest of OSX
05:00:20 <quicksilver> which is misguided
05:00:31 <quicksilver> because that makes the other keybindings inconsistent.
05:01:00 <sclv> (and seriously, inserting trace calls by hand is usually more than enough!)
05:02:22 <torquel> thanks!
05:04:26 <mdmkolbe> @index zipMap
05:04:26 <lambdabot> bzzt
05:04:43 <mdmkolbe> @type zipMap
05:04:44 <lambdabot> Not in scope: `zipMap'
05:05:25 <ziman> @type zipWith
05:05:26 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:05:30 <ziman> are you looking for this?
05:06:52 <mdmkolbe> ziman: no, it turns out to be a locally defined function
05:08:34 <yitz> quicksilver: I'm using aquaemacs. there are a few emacs variable you can set that bring it back to sanity. Other things - like standard Mac-like bindings for special Mac keys, and cut paste support, make it nice.
05:09:09 <yitz> quicksilver: what's bad about aquaemacs is that it's a memory hog
05:10:26 <quicksilver> yitz: carbon emacs has cut n paste support
05:10:40 <quicksilver> yitz: and uses sane keybindings out of the box
05:10:49 <quicksilver> yitz: what special mac keys are you thinking of?
05:13:08 <guenni> does anybody here have experience with HAppS-IxSet?
05:13:45 <guenni> or something similar?
05:16:06 <yitz> quicksilver: Command-foo
05:16:28 <yitz> quicksilver: I haven't tried carbon emacs. you recommend it?
05:17:10 <trzkril> yitz: if you know and like emacs from another platform, carbon emacs is less different
05:17:13 <Svrog> is there a combinator like \f g h x -> f ((h x) g) or (f .) . (. g) . h somewhere in the standard libraries? i've just noticed i seem to be using this pattern a fair bit and i'm wondering if it's more common
05:18:01 <Svrog> err that should be \f g h -> (f .) . (. g) . h
05:18:17 <sclv> Svrog: there's an informal combinator called "dot" which is ((.).(.))
05:18:17 <Myoma> :t \f g h -> (f .) . (. g) . h
05:18:18 <lambdabot> forall c b c1 a a1. (c1 -> c) -> (a -> b) -> (a1 -> b -> c1) -> a1 -> a -> c
05:18:45 <sclv> the page on pointfree on the haskell wiki has a listing of common "invented" combinators.
05:19:16 <Svrog> oh cool
05:19:18 <quicksilver> yitz: well I use Command as Meta, in emacs
05:19:23 <quicksilver> which is the carbon default anyway
05:19:42 <quicksilver> yitz: since my mac keyboard is rather short on modifiers keys that seems to me the best choice.
05:20:24 <yitz> quicksilver: urgh. I'd have to get used to that. What's the advantage to that over alt?
05:20:47 <quicksilver> you need alt for other things
05:20:59 <quicksilver> typing the euro sign, typing the '#' sign (on a UK keyboard)
05:22:34 <Saizan> ever wanted a let-notation for applicatives? like let x = foo; y = bar; in E ==> (\x y -> E) <$> x <*> y
05:22:53 <yitz> quicksilver: ah. I don't need alt for anything like that. and cmd is good for other things.
05:23:16 <quicksilver> yitz: yes, that's fair enough. I'd much rather have one more key.
05:23:48 <quicksilver> Saizan: I don't think what you said makes sense.
05:23:54 <quicksilver> Saizan: is that ) in the wrong place?
05:24:13 <Saizan> quicksilver: no
05:24:24 <quicksilver> Saizan: then those second x and y are out of scope?
05:24:25 <chr1s> Saizan: in Applicative style, the order is relevant. using let notation it isn't.
05:24:31 <Saizan> uhm, well, pure E
05:24:36 <chr1s> Saizan: do notation would make more sense
05:24:48 <quicksilver> Saizan: maybe you meant (\x y -> E) <$> foo <*> bar ?
05:24:57 <Saizan> let x = foo; y = bar; in E ==> (\x y -> pure E) <$> foo <*> bar
05:25:00 <Saizan> right :)
05:25:03 <Saizan> sorry
05:25:48 <quicksilver> I still don't understand, actually. Can you give a vaguely concrete example?
05:25:51 <Saizan> chr1s: yeah, that would be better
05:26:06 <chr1s> do x <- foo; y <- bar; return E
05:26:44 <Saizan> quicksilver: essentially like what you would do with do-notation but without requiring >>=
05:26:47 <quicksilver> is that point that x and y occur more than once, possibly
05:26:58 <quicksilver> but you only want 'foo' and 'bar' to be "executed" once?
05:27:52 <Saizan> yeah, or if i need to mangle the arguments i might like to pattern match at the binding point or insert other pure lets
05:30:39 <quicksilver> for the more-than-once case I'm pretty sure monad notation is the way to go.
05:30:52 <quicksilver> for the pattern mangling case something intermediate might possibly be useful.
05:31:30 <quicksilver> although you might do that as let mangled_foo = mangler foo in E <$> foo <*> bar
05:31:38 <quicksilver> without needing new syntax
05:33:31 <Saizan> true
05:35:27 <Saizan> it's a bit uglier if e.g. foo returns a product type and your E expects the components as separate arguments, then you've to mangle E instead of foo
05:37:38 <quicksilver> (uncurry E)
05:37:43 <quicksilver> but I take your point.
05:38:00 <quicksilver> it does indeed get a bit messy in more complex cases.
05:40:05 <Saizan> yeah, not all product types are tuple for example :)
06:23:49 <hackage> Uploaded to hackage: vty 3.1.0
06:24:11 <Myoma> what do you call the thing before the continuatino?
06:24:15 <Myoma> continuation*
06:24:41 <Axman6> to be continued >_>
06:25:00 <quicksilver> the co-continuation, or just the "ntinuation"
06:25:19 <quicksilver> Myoma: seriously, I'm not sure what you mean. Which thing?
06:26:38 <Myoma> I suppose it's any function that takes a continuation and then may call it
06:26:59 <Myoma> a kind of launchpad
06:30:11 * EvilTerran still isn't sure how a "delimited continuation" differs from just passing a function as a parameter
06:32:27 <ddarius> EvilTerran: It doesn't... if you write your functions in continuation passing style.
06:32:45 <EvilTerran> erm
06:32:46 <EvilTerran> ok
06:32:54 <Axman6> @src Maybe (>>=)
06:32:54 <lambdabot> (Just x) >>= k      = k x
06:32:54 <lambdabot> Nothing  >>= _      = Nothing
06:33:22 <Axman6> just curious, any reason k is used there, and not the more common f?
06:33:32 <Botje> none whatsoever
06:33:55 <ddarius> The k is somewhat related to a continuation a la CPS
06:34:11 <ddarius> But obviously this is purely mnemonic.
06:34:25 <quicksilver> Myoma: I don't think there is a special name for that.
06:34:36 <Myoma> I ended up calling it a launchpad :p
06:34:38 <quicksilver> Myoma: one man's continuations are another man's callbacks.
06:34:53 <quicksilver> Myoma: the paradigm is sometimes called "inversion of control"
06:35:41 <ddarius> Indeed.  The CPS transform is a way to systematically invert control.
06:38:09 <mmorrow> @src Cont (>>=)
06:38:09 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
06:39:29 <Axman6> what sort of functions would you use with bind on lists? can't think of many times i'd be using something that would create a list of lists
06:40:01 <ddarius> Axman6: You never write nested for loops?
06:40:03 <Myoma> Axman6: id mostly, but I don't write it out
06:40:24 <Botje> > "foobar" >>= \c -> if (c == 'o') then return 'x' else return c
06:40:26 <lambdabot>   "fxxbar"
06:40:46 <dcoutts_> Axman6: list comprehensions with multiple generators
06:40:55 <dcoutts_> each <- is a concatMap, a nested list op
06:41:11 <Axman6> i'm not sure i follow
06:41:17 <Myoma> I misunderstood your question first time around ...
06:41:39 <ddarius> > do x <- [1..10]; y <- [1..10]; return $ x*y
06:41:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,...
06:41:45 <Axman6> Myoma: yeah i thought you must've missed something :P
06:41:48 <Myoma> Axman6: any _filtering map_ can be written as [a] -> [[a]]
06:41:55 <dcoutts_> foldl' f z [ e | x <- xs, y <- ys ]  is a classic nested loop
06:42:00 <mmorrow> and (id=<<) is join
06:42:05 <mmorrow> > ((id =<< replicate) =<<) [0..4]
06:42:06 <lambdabot>   [1,2,2,3,3,3,4,4,4,4]
06:42:36 <Axman6> how handeh
06:43:03 <ddarius> The "intended" perspective is a view of non-deterministic computations.  So any time you want to choose out of a set of things but don't know which you want.
06:43:48 <ddarius> However, it is also beneficial to view (lazy) lists as first-class loop sections.
06:43:57 <dcoutts_> Axman6: list comprehensions are another syntax for the list monad, so each <- is a monadic bind, which for lists is concatMap
06:44:19 <Axman6> hmm, ok
06:44:55 <Axman6> i hadn't thought of things returning the empty list, what makes a lot of sense
06:45:14 <Axman6> that*
06:45:31 <Axman6> > 2^2^2^2^2^2^2
06:45:32 <dcoutts_> and in theory a list comprehension consumed by a foldl' can all be fused into something that looks like an efficient classic imperative loop
06:45:46 <lambdabot>   thread killed
06:46:00 <BeelsebobWork> > 2^2^2^2
06:46:01 <ddarius> > do x <- [1..]; y <- [1..x]; z <- [1..y]; guard (x^2+y^2 == z^2); return (x,y,z)
06:46:05 <lambdabot>   65536
06:46:05 <lambdabot>  Terminated
06:46:16 <BeelsebobWork> > 2^2^2^2^2
06:46:22 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
06:46:32 <BeelsebobWork> > 2^2^2^2^2^2
06:46:35 <Myoma> > ((2^2)^2)^2
06:46:35 <Axman6> gets damn big, damn quick
06:46:37 <lambdabot>   256
06:46:48 <lambdabot>   thread killed
06:46:52 <ddarius> > 2^(2*2*2)
06:46:54 <lambdabot>   256
06:47:15 <Axman6> yay for hyperexponentiation
06:48:06 <BeelsebobWork> at least it isn't 2^(2^(2^(2^2))))
06:48:13 <Axman6> been running 2^2^2^2^2^2^2 for a good 25 minutes on my machine
06:48:17 <BeelsebobWork> > 2^(2^(2^2))
06:48:18 <lambdabot>   65536
06:48:24 <ddarius> Beelsebob: That is what it is.
06:48:28 <BeelsebobWork> wait... is ^ right associative?
06:48:33 <BeelsebobWork> o.O
06:48:34 <ddarius> Beelsebob: Yes
06:48:41 <ddarius> There's no reason for it to be left associative.
06:48:55 <BeelsebobWork> is there a reason for it to be right associative?
06:49:03 <ddarius> To remove brackets.
06:49:06 <Axman6> yes, powers of powers
06:49:18 <Myoma> > 3 ↑↑ 2
06:49:27 <lambdabot>  Terminated
06:49:29 <Axman6> that's the one
06:50:09 <Axman6> Myoma: problem 188 on project euler involves finding the last 8 digits of 1777 ↑↑ 1855
06:50:15 <BeelsebobWork> > Data.Set.empty ∪ (Data.Set.singleton 1)
06:50:16 <lambdabot>   mueval: Prelude.read: no parse
06:50:28 <BeelsebobWork> :(
06:50:36 <Myoma> > 3 ↑↑ 3
06:50:38 <lambdabot>   7625597484987
06:50:54 <BeelsebobWork> > 1777 ^ 1777
06:50:56 <lambdabot>   494947585549665862001834940183885957808604012779846407942297437101372447254...
06:51:02 <Svrog> does ghc have it's own version of cpp or is it using the gnu one?
06:51:02 <Myoma> > 3 ↑↑ 4
06:51:03 <BeelsebobWork> blimeh, didn't expect it to manage that
06:51:14 <Axman6> me either
06:51:17 <lambdabot>   thread killed
06:51:23 <Axman6> actually, nah, that's ok
06:51:25 <BeelsebobWork> > 1777 ^ 1777 ^ 1777
06:51:29 <BeelsebobWork> :D
06:51:40 <lambdabot>   thread killed
06:51:48 <Axman6> i'm yet to get a result for 1777↑↑3
06:51:56 <BeelsebobWork> not surprised
06:52:00 <Axman6> even 2↑↑6
06:52:29 <BeelsebobWork> so given that things on the left don't effect things on the right of multiplies, why are you not just computing the last 8 digits all along?
06:52:46 <Axman6> hmm?
06:52:53 <Axman6> that was suggested to me
06:53:16 <dmwit> A modular Num instance is pretty easy... except for (/).
06:53:37 <dmwit> Luckily, (/) isn't in Num! =D
06:53:38 <quicksilver> BeelsebobWork: I think its still quite a lot of work to do, even working module 100,000,000 isn't it?
06:53:38 * BeelsebobWork notes that the last 8 digits of 1777 ^ 1777 ^ 1777 are 65873137
06:53:42 <Deewiant> > 1777 ^ 1777
06:53:44 <lambdabot>   494947585549665862001834940183885957808604012779846407942297437101372447254...
06:54:01 <BeelsebobWork> quicksilver: well, an 8-digit number ^ 1777 computes near instantly on this machine
06:54:12 * quicksilver nods
06:54:16 <BeelsebobWork> so doing that 1800 times doesn't sound too painful to me
06:54:22 <Deewiant> > logBase 10 . fromIntegral $ 1777 ^ 1777 :: CReal
06:54:23 <lambdabot>   5774.6945592100208107984882657067143756817935
06:54:33 <quicksilver> you can push the modulo 1e8 into your repeated squares too
06:54:42 <BeelsebobWork> indeed
06:54:44 <quicksilver> I think this means you can do Int64 math instead of Integer math
06:54:44 <yitz> BeelsebobWork: you need the opposite - 1777^x where x is big.
06:54:53 <quicksilver> 1e16 fits into Int64
06:55:00 <BeelsebobWork> yitz: oh, good point
06:55:17 <yitz> 1e8 is still big, but you can use a smaller modulus. That's the trick. I've got to run. :) bye all.
06:55:22 <dmwit> yitz: But you can take (x `mod` y), where y is the cycle length of (\n -> 1777^n).
06:55:29 <Axman6> yitz: still working on it?
06:55:37 <yitz> yitz - oh - then look for a pattern so that you don'
06:55:43 <yitz> t have to do it 3000 times
06:55:47 <yitz> Axman6: I got it.
06:55:49 <BeelsebobWork> that begins to take a bit longer -- but given that you can push the mod 1e8 into the multiplies instead of the ^s, it should be computable fast
06:55:59 <yitz> got to go now, good luck.
06:56:00 <Axman6> rawr
06:56:21 <BeelsebobWork> also Axman6 I'm surprised you have been able to leave it running a long time -- mine bus errors after not long
06:56:39 <dmwit> > gcd 1777 100000000
06:56:40 <lambdabot>   1
06:56:43 <Axman6> BeelsebobWork: mine's running in <4MB RAM
06:56:45 <dmwit> ah, rats
06:57:05 * dmwit runs away
06:57:27 * quicksilver sends the rats after dmwit 
07:00:01 <dmead> let x = 2 in print (if x = then "hello" else "world")
07:00:07 <dmead> > let x = 2 in print (if x = then "hello" else "world")
07:00:08 <lambdabot>   mueval: Prelude.read: no parse
07:00:11 <dmead> curses
07:00:16 <dmead> > let x = 2; in print (if x = then "hello" else "world")
07:00:17 <lambdabot>   mueval: Prelude.read: no parse
07:00:21 <dmead> hmm
07:00:21 <Axman6> if x =?
07:00:30 <dmead> oh
07:00:30 <dmead> ah ah
07:00:36 <Twey> O.O
07:00:38 <dmead> > let x = 2; in print (if x == 2 then "hello" else "world")
07:00:39 <lambdabot>   mueval: Prelude.read: no parse
07:00:39 <lambdabot>  mueval: *** Exception: "<IO ()>"
07:00:51 <Twey> Why's that an exception?
07:01:01 <dmead> you can't use io in lambdabot
07:01:06 <Twey> Why doesn't it just show it like the old lambdabot did?  :<
07:01:14 <dmead> don't know
07:01:53 <dmead> i didn't know you could nest conditionals like that
07:01:57 <dmead> it's sorta uber useful
07:02:30 <dmwit> You didn't nest conditionals yet.
07:02:36 <quicksilver> dmead: "if" is just a tool to build expressions.
07:02:50 <quicksilver> dmwit: I believe dmead means "nest a conditional inside a more complex expression"
07:02:55 <dmwit> ah
07:03:08 <Botje> nesting expressions should be allowed to breed
07:03:10 <quicksilver> dmwit: you can put any expression anywhere you expect an expression, as it were :)
07:03:16 <quicksilver> dmead: that was meant for you, inf act
07:03:34 <quicksilver> it is this kind of easy compositionality which makes haskell makes more pleasant to use than many other languages
07:04:07 <dmead> indeed
07:04:10 <cjs> @seen dcoutts
07:04:10 <lambdabot> dcoutts is in #haskell-soc, #haskell-overflow, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard dcoutts speak 2h 32m 27s ago.
07:04:16 <dcoutts_> hia cjs
07:04:24 <cjs> Hey. Got a weird Windows one for you.
07:05:05 <cjs> If I runghc setup.hs  with "--libdir=lib/haskell", I can no longer link with the system libraries.
07:05:09 <dcoutts_> cjs: oh goody :-)
07:05:49 <dcoutts_> cjs: I'll need more context and detail
07:07:20 <cjs> Yeah, we're just working on that right now. Except the problem just mysteriously vanished.
07:07:29 <cjs> We'll find it again. :-)
07:08:23 <dcoutts_> cjs: if you find some details then file a ticket in the hackage trac
07:08:47 <dcoutts_> the more context and detail the better, attaching logs to a ticket is fine
07:09:02 <cjs> Well, lemmie paste the message first just in case it's something you can give us some further clues on to aid our research.
07:10:19 <cjs> Gah, looks like we can't reproduce it. And we lost the scrollback. Basically, it was saying that .hi files in the system libraries had a bad magic number, maybe being an old version.
07:10:49 <dcoutts_> cjs: I've seen that before and also not reproducible
07:11:25 <dcoutts_> cjs: as if it were corruption on reading the .hi files, but that seemed unlikely as the user was using zfs and checksumming
07:12:25 <cjs> Sound like someone on a Solaris box?
07:12:58 <dcoutts_> cjs: yeah, they must've been on solaris
07:13:23 <Twey> Hmn
07:13:45 <quicksilver> accidentally sharing hi files between different archs?
07:13:49 <quicksilver> nfs-mounted hi files?
07:13:51 <cjs> Hm. Well, I'll keep my eyes open for it, and see if I can think of any neat way to debug it.
07:18:38 <humasect> hello. is there a clean way to pattern match with lists, aside from (x:xs) ? for example, given "f :: [a] -> b", and "f (Data a b c) = c" .. we would get a list of all c's. for records too.
07:19:05 <humasect> what is the clean way to do it, aside from 'map (\(Data _ _ c) -> c) xs' ?
07:19:20 <quicksilver> [c | Data _ _ c <- xs]
07:19:25 <quicksilver> is one popular notation
07:19:33 <humasect> hm^_^..
07:19:40 <Deewiant> @undo [c | Data _ _ c <- xs]
07:19:41 <lambdabot> concatMap (\ b -> case b of { Data _ _ c -> [c]; _ -> []}) xs
07:19:45 <quicksilver> map getC xs is another
07:19:58 <quicksilver> you can write
07:20:01 <humasect> ouch, Deewiant , list comps look rough now =)
07:20:12 <humasect> yep quicksilver , hmm.
07:20:13 <quicksilver> blah (Data _ _ c : ds) = ....
07:20:15 <quicksilver> if you like
07:20:17 <Deewiant> that's just the desugaring :-)
07:20:19 <quicksilver> i.e. you can nest patterns.
07:20:38 <humasect> yeah Deewiant =) i will stay away until i need parallel+zip+filter+map again ^_^
07:20:48 <humasect> quicksilver: nest ?
07:20:53 <quicksilver> yes.
07:20:56 <quicksilver> blah (Data _ _ c : ds) = ....
07:21:05 <quicksilver> that is a 'Data' pattern nested inside a list (:) pattern
07:21:05 <humasect> oh, right of course
07:21:44 <humasect> data Data = (Int,Int) (Int,Int) (Int,Int,Int,Int) is a common data structure here. (actually Int=Double)
07:22:30 <humasect> the 3rd tupe is r,g,b,a .. "aOf (Data _ _ (_,_,_,a))" . it is fairly clean, right?
07:22:41 <quicksilver> sure
07:22:49 <quicksilver> be nicer to use real data types though
07:22:56 <humasect> oh?
07:22:58 <quicksilver> data Data = Data Point2D Point2D Colour4
07:23:09 <quicksilver> where data Colour4 = Colour4 Double Double Double Double
07:23:10 <quicksilver> etc.
07:23:38 <humasect> ah, right. except Point2D = (Double,Double) and similar for Colour4
07:23:47 <quicksilver> you may be interested in functional references
07:23:48 <quicksilver> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
07:24:01 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
07:24:03 <humasect> constructors for non-tuples in this case get very much in the way of clarity and consiceness of code
07:24:16 <Axman6> do data constructors like that just create structs basically?
07:24:20 <humasect> yep, indeed i am =) i will wait until 6.10 which is soon, much of my code is ready for it.
07:24:47 <humasect> in a way, Axman6, but the constructors themselves are functions
07:25:50 <humasect> quicksilver: when most of the code is operating in Point2D, it is undesireable to have littered with constructors. one of the *main* reasons i have written a more simple custom OpenGL ffi.
07:26:21 <Axman6> righto. well sleep time. g'night all
07:26:25 <humasect> good night
07:27:22 <quicksilver> humasect: custom FFI !?!!!!?????!!!!???!!!
07:27:23 <humasect> given "average :: [Point?D] -> Point?D" , there is no simple way to have "averageData :: [Data] -> Data"
07:27:39 <quicksilver> humasect: why not just a simple wrapper around existing opengl library?
07:27:43 <Axman6> and i'm going to go with quicksilver in saying that real datatypes would be much nicer
07:27:44 <humasect> quicksilver: sorry, hehe, i meant custom opengl interface.
07:27:44 <quicksilver> if you didn't like the interface.
07:27:47 <quicksilver> ah.
07:27:48 <quicksilver> ;)
07:27:55 <humasect> it does not use hopengl that is for sure
07:28:22 <humasect> Axman6: in this case, it would be uglier; such is why it is the way it is now=)
07:28:36 <Axman6>  don't think it would be
07:28:54 <humasect> more difficult to work with if there were constructors all over the place; that is where it started. now it is much better.
07:28:56 <Axman6> it would be more declaritive too
07:29:31 <humasect> there is not much difference between (a,b) and Data a b aside from having to type "Data" when it is known to be a Data.
07:29:40 <Axman6> eh, i learned from an early project that tuples aren't all that great in data types. made it very confusing
07:29:55 <quicksilver> humasect: not using hopengl seems absurd.
07:29:58 <guenni> anybody know a good intro to Generic Haskell?
07:30:04 <humasect> MyObject = *myObject = new MyObject ();   <- why not never be born at all, then? =)
07:30:08 <quicksilver> humasect: hopengl does a huge amount of (surely) useful work.
07:30:39 <humasect> quicksilver: nope =) there was a strong need for pushMatrix/popMatrix, and hopengl renames things in ways that are unintuitive for lots of heavy GL work
07:30:52 <humasect> renames/changes the whole API.
07:30:57 <quicksilver> no it doesn't
07:31:03 <quicksilver> it makes some minor changes to names in a small number of places
07:31:10 <humasect> then how come i feel this way, after using it heavily?
07:31:12 <quicksilver> and I've used it for (Relatively) heavy openGL work
07:31:27 <quicksilver> and I find it much more convenient than the C API
07:32:15 <humasect> it hides too much, there is a lot of fancy techniques in use with the GL in this project that couldn't be done in hopengl. such as, turning the depth buffer on and off, without changing the depth func. it relies on opengl's internal state for many reasins^_^
07:32:18 <humasect> *sons
07:32:26 <quicksilver> humasect: eh?
07:32:38 <quicksilver> of course you can turn the depthbuffer on/off without changing the depth func.
07:32:45 <humasect> we needed pushMatrix/popMatrix too, where hopengl hides it in unsafePreservingMatrix/preservingMatrix
07:32:59 <humasect> how ? depthFunc is a Maybe, where Nothing turns it off.
07:33:03 <quicksilver> depending what you mean by on/off
07:33:10 <quicksilver> are you trying to turn off reads or writes?
07:33:12 <humasect> glEnable/glDisable GL_DEPTH_FUNC
07:33:20 <quicksilver> reads, ok
07:33:29 <humasect> both were used (depthMask)
07:33:29 <quicksilver> well just save/restore the old value of depthFunc then
07:33:31 <quicksilver> it's not very hard :)
07:33:41 <quicksilver> I frequently save/restore all kinds of GL state
07:33:48 <quicksilver> my code contains things like
07:33:52 <humasect> what kind of gl work is it ?
07:34:19 <quicksilver> with [ lighting := Disabled, depthFunc := Nothing, currentColor := red] $ do ....
07:34:30 <Japsu> :O
07:34:33 <quicksilver> which automatically saves and restores all those parameters around the call.
07:35:09 <quicksilver> humasect: visualisation toys / gui experiments / half-finished game projects
07:35:18 <quicksilver> usual assortment of hacker's part-time entertainments.
07:35:36 <humasect> under IO ?
07:35:53 <humasect> keeping state within opengl is critical for having main functions not under IO, too
07:36:07 <quicksilver> well of course the actual rendering routines are in IO
07:36:15 <quicksilver> I keep it out of the rest of the code as much as I can be bothered
07:36:33 <quicksilver> typically ending up with pure functions which operate on some kind of application state value
07:36:53 <humasect> everything is going so much better with a simple GL.hsc with just the functions that are needed. i see no reason to depend on something that is too high level for its own good ..
07:37:21 <quicksilver> I disagree more strongly than I can clearly express.
07:37:26 <humasect> this application is performance critical, of course, the rendering code needs to remain as clear and without anything between it as much as it can.
07:37:31 <humasect> hehe
07:37:31 <quicksilver> HOpenGL is a work of art.
07:37:36 <quicksilver> of course it has warts
07:37:36 <humasect> oh, its yours?=)
07:37:38 <quicksilver> it's not perfect.
07:37:42 <quicksilver> No, it's not mine.
07:37:57 <quicksilver> working with HOpenGL is 64,000 times nicer than writing OpenGL code in C.
07:38:02 <quicksilver> and that performance point is pure FUD.
07:38:14 <quicksilver> How shall HOpenGl somehow be worse performance than your own ffi binding?
07:38:25 <humasect> i've started this project in hopengl, and everything was fixed when going to GL. then a couple of weeks ago i converted everything back to hopengl... it was a mess, and actually just the same amount of code.
07:38:37 <humasect> (actually not quite a mess, but some things couldn't be reproduced in hopengl)
07:39:10 <Svrog> i think hopengl is horrible
07:39:21 <quicksilver> Svrog: in what way?
07:39:22 <humasect> its pretty awesome for GLUT, though, which i use it for
07:39:38 <humasect> except menus, are buggy.
07:40:01 <quicksilver> humasect: I sometimes wondered if HOpenGL should export push/pop matrix
07:40:12 <quicksilver> but if that was the only problem it is trivial to ffi those two functions :)
07:40:22 <quicksilver> you can copy their internal definitions.
07:40:27 <quicksilver> why did you need that feature?
07:40:59 <humasect> just throw it into .Unsafe with other unsafe things, or so ... but really the 'safe' versions are doing too much, so most things that try to use opengl as close to 1:1 ratio as possible use always unsafe versions. long fun names
07:41:39 <humasect> if it was just an interface to opengl there is no problem to use it. but it changes it; "(bindTexture & Texture2D) n" becomes "textureBind Texture2D $= Just $ TextureObject n" ... ~_~
07:42:07 <humasect> quicksilver: in this case, for nested UI
07:42:22 <quicksilver> but nested UI is a perfect use-case for preservingMatrix, surely?
07:42:28 <humasect> the workaround was multiple unsafePreservingMatrix
07:42:32 <quicksilver> why would a nested UI have non-matching pushes and pops?
07:42:47 <humasect> thats right, hehe, it doesn't have nonmatching of course.
07:43:03 <quicksilver> ok, well if they're not non-matching, what is your issue with preservingMatrix?
07:43:15 <humasect> liftIO
07:43:43 <Svrog> well these are just my opinions but starting from the fact that it's too limited and doesn't expose all the new functionality (not talking gl3 here, but even gl2) while exposing all the legacy stuff, being a straight from c wrapper to a very low level api and even not doing that particularly well (things like the $= operator and all the explicit type signatures you have to write for no good reason), the module structure
07:43:50 <humasect> liftIO .. pushmatrix+begin drawing .. back to monad, a bunch of stuff ... back to liftIO draw rest+pop matrix
07:44:05 <Svrog> that last one is mostly a problem for documentation
07:44:09 <Svrog> its very hard to navigate
07:44:18 <quicksilver> humasect: OK if you're working in a custom monad there is a generic problem with callbacks.
07:44:27 <quicksilver> humasect: but that's fortunately solvable.
07:44:33 * humasect dislikes $= ... hopengl is an interesting specimen for overdesign
07:44:36 <Svrog> oh
07:44:36 <quicksilver> you can write preservingMatrix' which works in any monad.
07:44:48 <Svrog> also types like GLint
07:44:49 <Svrog> and GLfloat
07:44:50 <quicksilver> Svrog: What does it lack from GL2?
07:44:55 <humasect> quicksilver: yep, i see
07:44:56 <Svrog> i understand why that was done
07:44:56 <Svrog> but
07:45:00 <Taejo> @src minimumBy
07:45:00 <lambdabot> Source not found. My brain just exploded
07:45:04 <Taejo> @src Data.List.minimumBy
07:45:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:45:05 <Svrog> it just feels wrong from haskell
07:45:09 <quicksilver> I thought it was pretty much GL2-complete.
07:45:14 <humasect> i just use #type for GL.hsc
07:45:25 <Svrog> quicksilver: for example generic shader attributes
07:45:33 <Svrog> hopengl doesn't support them
07:45:44 <quicksilver> Ah, OK. I've not played with the shader stuff.
07:45:59 <Taejo> > minimumBy (compare `on` fst) [(1, 1), (1, 2)]
07:46:00 <lambdabot>   (1,1)
07:46:04 <quicksilver> expecting it to support GL3 would be a bit much, there aren't even any implementations to test it against yet :)
07:46:21 <Svrog> yeah
07:46:27 <Svrog> gl3 is a huge disappointment too
07:46:29 <quicksilver> Svrog: why don't you like the $= operator? I think it nicely unifies a large set of stateful operations.
07:46:41 <quicksilver> The documentation is indeed very poor. There is none.
07:46:42 <BeelsebobWork> gl2.2 you mean?
07:46:48 <Svrog> haha
07:46:50 <Svrog> exactly
07:46:55 <humasect> gl3 is just a beginning
07:46:58 <quicksilver> but I've not had much trouble finding what I need with grep.
07:47:18 <humasect> $= is funrefs no ?
07:47:26 <BeelsebobWork> I tend to find what I want using @google Graphics.Rendering.OpenGL functionIWant
07:47:29 <quicksilver> StateVars, Sven calls them.
07:47:37 <dmead> @hoogle getArgs
07:47:37 <lambdabot> System.Environment getArgs :: IO [String]
07:47:45 <quicksilver> I like them because they're nicely abstractable
07:47:59 <quicksilver> so you can do the with [lighting := Disabled, currentColor := red] stuff
07:48:01 <dmead> what module is getargs in?
07:48:04 <quicksilver> which is very nice and composable.
07:48:05 <dmead> system.environment?
07:48:16 <humasect> the love put into hopengl deserves to be in a UI instead
07:48:17 <BeelsebobWork> quicksilver: you have an interesting definition of compositionality
07:48:33 <humasect> hm, quicksilver
07:48:47 <humasect> dmead: as lambdabot says=)
07:48:56 <dmead> ah ah
07:49:00 <Svrog> hmm well i don't really think it unifies anything particularly - it uses up an operator that can be better used for something more worthwhile - at the same time the excessive overloading requires you to specify type signatures a lot and i think i ran into that with $= as well - can't remember now
07:49:03 <BeelsebobWork> dmead: you can get it just by importing System
07:49:05 <dmead> i need to pay attention...
07:49:20 <quicksilver> BeelsebobWork: well it gives composability, in the context of wrapping a stateful API.
07:49:31 <humasect> ugh ... vertex (Vertex3 x y (z::GLfloat)) ...
07:49:40 <humasect> vs. vertex3 (x,y,z)
07:49:44 <quicksilver> BeelsebobWork: of course a less stateful wrapper might be more composable
07:49:45 <BeelsebobWork> quicksilver: I'm not sure you can ever get composability in that context
07:49:58 <quicksilver> of course you can.
07:50:05 <humasect> quicksilver: that is the second reason=)
07:50:11 <Svrog> humasect: well gl3 was supposed to be a fresh start, after the previous fresh start with gl2 turned out to be a big failure
07:50:21 <Svrog> so gl3 is a second, even bigger failure than gl2 was
07:50:23 <humasect> Svrog: how much did graphics tech change since then?
07:50:24 <quicksilver> humasect: well that's the part I meant by making a trivial wrapper.
07:50:35 <Svrog> since when?
07:50:47 <humasect> quicksilver: oh i had to =) when i converted the project a couple weeks back. but it didn't work out
07:51:01 <quicksilver> humasect: it's trival to write v3 :: GLFloat -> GLFloat -> GLFloat -> IO (); v3 x y z= vertex $ Vertex3 x y z
07:51:05 <humasect> Svrog: what was the state of graphics tech in gl2 time , compared with now.
07:51:13 <humasect> quicksilver: yes. that is what i did. it was indeed trivial.
07:51:24 <Svrog> gl3 (and gl2 before it) was supposed to be a cleaner new api without any of the legacy stuff and functions that made sense in the early 90s
07:51:29 <BeelsebobWork> humasect: lots -- graphics cards have gone from things that you throw verticies, and lights and normals and textures and other special things at one at a time, to things that you throw a big bunch of verticies, a big bunch of normals, and then you run a program to transform them
07:51:37 <BeelsebobWork> OpenGL stil lives in the old model
07:51:46 <Svrog> yeah
07:51:48 <humasect> Svrog: so you were disappointed. that usually happens when we set our expectations
07:52:06 <BeelsebobWork> humasect: no, the OpenGL ARB set our expectations
07:52:10 <Svrog> well they failed to deliver on all counts
07:52:17 <BeelsebobWork> they gave lots of presentations showing lots of cool things that they were gonna do in GL 3
07:52:21 <BeelsebobWork> and then didn't do any of them
07:52:38 <humasect> BeelsebobWork: how can we blame our own circumstance on those things outside of it? are we thirsty because of water?
07:52:55 <Svrog> humasect: arb promised a clean new api, with a new object model, without backwards compatibility, and promised it would work with geforce fx and radeon9700s and up - shader 2 class hardware
07:53:00 <humasect> BeelsebobWork: oh, i see, but can they do them now, easier ?
07:53:03 <Svrog> none of that happened
07:53:07 <humasect> hmm
07:53:10 <BeelsebobWork> humasect: no, but we are disapointed because someone promised us pure water, and then gave us mud
07:53:16 <bos> @seen ketil
07:53:16 <lambdabot> I saw ketil leaving #haskell 54m 18s ago, and .
07:53:25 <humasect> i see how that can be disappointing
07:53:29 <Svrog> yes
07:53:48 <Svrog> and they were talking about these things before opengl 2 came out
07:53:54 <Svrog> they were already promising that stuff back then
07:53:57 <humasect> i have seen a little object model stuff in gl3, but i haven't looked much. hopengl does something about it, though doesn't it?=)
07:54:06 <Svrog> no
07:54:07 <Svrog> it doesnt
07:54:08 <humasect> maybe it is kronos' fault
07:54:12 <Svrog> it is
07:54:15 <humasect> ah =)
07:54:24 <humasect> apple should do something about it. or them and nintendo.
07:54:36 <BeelsebobWork> humasect: it is kronos' fault -- they listened to the CAD/CAM guys saying "we need an API that lets us modify individual verticies all the time"
07:54:46 <Svrog> yup
07:54:54 <BeelsebobWork> the CAD/CAM guys don't even use gl 2, let along gl 3
07:54:55 <humasect> also, the windows distribution of GHC does not come with openal, i wonder if just needing mingw is enough to get that working?
07:55:06 <BeelsebobWork> so they could have carried on in their gl 1.4 world quite happily
07:55:11 <humasect> ah so we all seen the opengl.org forums ?
07:55:21 <humasect> hehe, i see
07:55:34 <humasect> who are these cad/cam guys anyway? military?
07:55:44 <BeelsebobWork> no, people doing Computer Aided Design
07:55:49 <humasect> yep; who are they?
07:55:49 <BeelsebobWork> and Computer Aided Manufacture
07:55:56 <BeelsebobWork> people designing cars/houses etc
07:56:00 <humasect> newtek lightway, maya, these kinds of things ?
07:56:02 <BeelsebobWork> I nearly said designing horses there
07:56:04 <humasect> wave*
07:56:07 <humasect> hehe
07:56:22 <BeelsebobWork> Autocad kind of things
07:56:32 <humasect> surely they are designing horses when the need is there ... maybe places like 3dlabs ?
07:56:37 <Svrog> yeah pretty much all of those - no names were given but yeah
07:56:50 <humasect> but xsi, maya, blender,lightwave, they all use opengl2 +
07:56:53 <Svrog> cad guys, possibly 3d modeling tools developers too
07:57:25 <BeelsebobWork> humasect: in general people who want technical artists to be able to tweak individual verticies repeatedly in a very small space of time
07:57:32 <BeelsebobWork> this doesn't suit the "upload all the data then do stuff with it" model
07:57:35 <Svrog> they use some features provided by opengl 2 - their code base is likely littered with legacy opengl stuff like glVertex calls and similar
07:57:40 <quicksilver> I don't think it's so much "we want to modify individual vertices" as "we have 100 million lines of code we don't want to change"
07:57:47 <humasect> i have seen enough on the forums to blame these 'cad/cam guys' but have seen nothing about who they are. 3dlabs come to mind, as a developer of higher end kind of visualizing cards - but those also use newest tech; 3dlabs was the first hardware for opengl2 i believe
07:57:48 <Svrog> yeah
07:57:53 <BeelsebobWork> quicksilver: yeh -- so they could have just... not changed it
07:58:06 <humasect> Svrog: hehe, how can one not use glvertex ?
07:58:06 <BeelsebobWork> it's not like they actually want to use any of OpenGL 3's features anyway
07:58:12 <quicksilver> I've seen this flamewar so often I'm rather bored of it, but
07:58:16 <BeelsebobWork> humasect: buy uploading a vertex buffer
07:58:19 <Svrog> humasect: use vbos
07:58:21 <Svrog> yeah
07:58:24 <Svrog> vertex buffer objects
07:58:25 <quicksilver> I think the basic reason that GL3 wasn't what people expected
07:58:30 <quicksilver> was that NOBODY DID THE WORK
07:58:31 <humasect> and how to change those vertex buffers ?
07:58:34 <quicksilver> it's that simple.
07:58:44 <BeelsebobWork> humasect: you don't -- you then run pure functional programs on them
07:58:48 <quicksilver> designing and testing a new API is work, for real people, which has to be done and takes time.
07:58:50 <BeelsebobWork> mutation == slow on graphics cards
07:59:03 <quicksilver> and, they didn't do it.
07:59:04 <humasect> BeelsebobWork: ah, i see -- so then, to get them back, and save them, render them , etc ?
07:59:14 <quicksilver> well you keep a copy CPU-side as well
07:59:22 <quicksilver> and you just change one and re-upload
07:59:25 <quicksilver> it's not rocket science ;)
07:59:32 <humasect> so what we are saying is, the apps would be nearly 100% hardware accelerated for them to be "compliant" with new gl tech
07:59:35 <BeelsebobWork> humasect: no, you run a pure functional program that computes the position of the vertex in 2D space, and then another one that computes the colour of the pixel on the screen based on all those 2D points
07:59:52 <humasect> BeelsebobWork: no wonder its a lot of work! =)
08:00:12 <humasect> so why would they need to do that, if they don't have to. just keep calling glvertex , as the data in the document changes, the graphics do as well.
08:00:25 <humasect> no need for syncing stuff, not everone is working in 10000000 poly models
08:00:29 <quicksilver> humasect: glVertex has been deprecated.
08:00:36 <quicksilver> and thus the argument.
08:00:41 <Svrog> actually using shaders is less work (and less frustration) than using the fixed function pipeline - things are a lot more consistent
08:00:43 <quicksilver> although, the argument didn't stop them deprecating it.
08:00:44 <humasect> hm, i will miss it
08:00:44 <BeelsebobWork> quicksilver: yes, but there's no reason for them to actually use OpenGL 3
08:00:50 <BeelsebobWork> they could have carried on using OpenGL 2
08:00:54 <BeelsebobWork> or 1.4 in actual fact
08:01:00 <quicksilver> BeelsebobWork: right. But there was this absurd FUD about not being backward compatible.
08:01:09 <BeelsebobWork> quicksilver: there was? oh
08:01:10 <quicksilver> at the end of the day it's the driver authors who decide that
08:01:15 <quicksilver> not the ARB.
08:01:20 <BeelsebobWork> I thought the whole point was that it *wasn't* backwards compatible
08:01:31 <quicksilver> if the driver authors continue to expose a 1.4 API, the CAD apps are fine
08:01:34 <quicksilver> if they don't, they're not.
08:01:38 <quicksilver> but that's not ARB's decision anyway.
08:01:40 <humasect> it sounds like an argument only fps players with high expectations for getting their money's worth. sigh
08:02:06 <quicksilver> it's up to nvidia/ati/intel/apple how old an API they choose to support.
08:02:19 <humasect> quicksilver: but then CAD apps can say "1.4 compatible" etc., and so users can pick the right card
08:02:22 <Svrog> quicksilver: actually given the poor state of opengl drivers this was another reason for starting from scratch
08:02:30 <Svrog> in fact it was nvidia and ati who started work on opengl3
08:02:37 <BeelsebobWork> quicksilver: this is true -- but given that the CAD guys want it, I would find it highly unlikely that the card makers would stop supporting GL 2, at least on FireGL/QuadroFX
08:02:45 <Svrog> before arb and khronos messed things up
08:03:22 * humasect is starting to think no one knows why they are saying what they are saying, here or anywhere... things are what they are. things changes, but are still what they are. 1.4 is 1.4 , 3 is 3, dx is dx
08:04:35 <humasect> for someone to draw lines with opengl, what would they do? set up a vbo, upload to card, then program some shaders? vs. 4 lines of code? =)
08:04:55 <quicksilver> I don't really understand what happened, but I know one thing for sure. The people who spout shit on forums *definitely* don't know what happened.
08:05:03 <humasect> =)
08:05:04 * ddarius is failing to see what this has to do with Haskell.
08:05:06 <Svrog> there is no reason why that couldn't be wrapped up in some library
08:05:13 <quicksilver> ddarius: well we were talking about opengl in haskell :)
08:05:18 <quicksilver> ddarius: we slipped rather.
08:05:40 <humasect> Svrog: that is starting to sound like linux.
08:05:55 <BeelsebobWork> humasect: the point is that almost no one is going to draw 2-3 lines using OpenGL
08:06:06 <humasect> except cad/cam guys =)
08:06:20 <BeelsebobWork> no, the cad/cam guys draw fairly complex scenes
08:06:22 <humasect> hopengl does unify "object names", in a cute way
08:06:25 <BeelsebobWork> involving millions of polys
08:07:01 <kosmikus> guenni: what kind of intro are you looking for? what do you want to do with GH?
08:07:05 <humasect> then why do they need vertex3d? it is possible for graphics to become too complex we begin to forget the effect of the simple kind.
08:07:42 <humasect> play some DS .. we don't need a line to be a raytraced photon laser .. just a linear interp of pixels will do.
08:08:51 <humasect> quicksilver: what happened to your projects that never happened? i am curious of the haskell tweaks that were decided unworthy to further continue with
08:09:23 <Svrog> on an unrelated note is there a reason why ghc uses cpp in traditional mode to preprocess haskell sources? i need the concatenation operator :(
08:09:27 <quicksilver> humasect: I get bored of them and start working on something else :)
08:09:30 <humasect> the game projects; were they experiments, or something happened where they stopped, or have they fulfilled their purpose ?
08:09:54 <humasect> ahh..i feel sorry for them, then
08:09:56 <quicksilver> ;)
08:10:05 <quicksilver> often I write something just to see how it works
08:10:18 <quicksilver> I did perlin noise for marble texture generation
08:10:26 <quicksilver> and a simple isosurface triangulator
08:10:29 <ddarius> Svrog: Haskell isn't C, so running CPP over it isn't always ideal.
08:10:32 <quicksilver> just because the algorithms seemed interesting.
08:10:39 <humasect> Svrog: can you pass an anti-traditional flag , to ghc ?
08:10:53 <humasect> quicksilver: ah =) i see what you mea
08:10:54 <humasect> n
08:11:07 <Svrog> ddarius: i never said always
08:11:17 <tylere> quicksilver: try playing with pov-ray if you're into that kind of stuff ;)
08:11:21 <Svrog> there is the CPP extension
08:11:34 <ddarius> Svrog: I didn't say you did.
08:11:54 <ddarius> @google FRep
08:11:56 <lambdabot> http://www.cdfa.ca.gov/is/fflders/frep.html
08:11:56 <lambdabot> Title: CDFA > FFLDERS > Fertilizer Research and Education Program
08:12:04 <humasect> i am using cpp, because code repetition is no one's favorite eyecandy, really. "foreign import CALLCONV ... "
08:12:06 * ddarius didn't think that would work.
08:12:15 <ddarius> @google Functional Representation FRep
08:12:20 <lambdabot> http://en.wikipedia.org/wiki/Function_representation
08:12:20 <lambdabot> Title: Function representation - Wikipedia, the free encyclopedia
08:12:28 <humasect> +unsafe
08:12:47 <quicksilver> tylere: I did play with povray many years ago.
08:12:56 <quicksilver> tylere: that's what made me think the algorithm was interesting :)
08:13:29 <tylere> yea, it's been a few years since I've messed with it too
08:13:42 <humasect> i was doing a hull split algorithm the other day, never finished it. one line, then a list of lines: return convex hulls (left, right)
08:13:53 <Twey> Is it possible to write a function :: Foo -> Maybe a and then have the caller specify what type they expect?
08:13:59 <tylere> still occasionally...I find it good for quick and dirty visualisation since it's easy to generate scenes programatically
08:14:11 <ddarius> Twey: Sure.  const Nothing
08:14:16 <humasect> Twey: yep, (function f :: Maybe Int)
08:14:33 <humasect> Twey: ghc will tell you when that needs to be done
08:14:54 <Twey> Hmmm?
08:15:14 <humasect> opengl with vertex2f is good for quick and dirty, as a side note; no fancy buffers or uploading when it is not needed
08:15:21 <Twey> ddarius: That's not *quite* what I was looking for... :-P
08:15:21 <Jedai> Twey: Most of the time you don't really need to do it (because the context only leave one possibility)
08:15:42 <ddarius> Twey: Unless a is free in Foo it is the only total implementation.
08:16:22 <Twey> Well, here's what I'm doing: http://hpaste.org/10202
08:16:28 <Svrog> humasect: vertex2f can be implemented in a utility library, it should not be something driver writers have to implement
08:16:41 <chrisdone> real world haskell?
08:16:42 <Svrog> it could nicely be implemented in haskell
08:16:54 <humasect> Svrog: oh, yep thats right
08:16:56 <ddarius> Twey: You could do that with GADTs but otherwise, no you can't do that.
08:17:07 <ddarius> Twey: You could however, stick the functions into a type class.
08:17:14 <humasect> Svrog: now i understand=)
08:17:23 * Twey nods.
08:17:25 <Twey> Thanks :)
08:17:26 <ddarius> Rather stick fromJSValue into a type class.
08:17:34 <Svrog> and in fact in haskell you could do much better than vertex2f
08:17:45 <ddarius> Twey: So why not use an existing JSON library?
08:17:45 <Twey> So I'd have: instance JSValue String where ...?
08:17:51 <Twey> ddarius: Practice
08:17:57 <humasect> why can't he do that? i have some code like this.
08:18:01 <bos> @seen ketil
08:18:01 <lambdabot> I saw ketil leaving #haskell 1h 19m 4s ago, and .
08:18:19 <ddarius> Twey: Yes.
08:18:23 * Twey nods.
08:18:24 <Twey> Thanks :)
08:18:25 <humasect> Svrog=)
08:18:34 <ddarius> Well, it requires an extension to write that specifically.
08:18:38 <Twey> Oh
08:19:02 <Twey> Isn't that how functions like fromIntegral work?
08:19:03 <humasect> this code is not haskell98? that sounds crazy.
08:19:39 <ddarius> Twey: The problem is String is 1) a type synonym and 2) == [Char], only [a] is a valid head for a type class.
08:19:40 <humasect> nevermind .. except the lists and the tuples
08:19:44 <ddarius> In Haskell 98 that is.
08:20:32 <Twey> Huh
08:20:32 <ddarius> If you did pursue this route you'd need overlapping instances as while [Char] and [JSValue] and [(String, JSValue)] don't overlap, someone could add [a] later which would overlap with all of those.
08:20:35 <Twey> ddarius: So what about read?
08:20:42 <Twey> String is an instance of Read, isn't it?
08:20:47 <humasect> instance JSUnwrap JSValue v where fromJSValue :: a -> v
08:20:56 <ddarius> @src Read
08:20:56 <lambdabot> class Read a where
08:20:56 <lambdabot>   readsPrec    :: Int -> ReadS a
08:20:56 <lambdabot>   readList     :: ReadS [a]
08:20:56 <lambdabot>   readPrec     :: ReadPrec a
08:20:56 <lambdabot>   readListPrec :: ReadPrec [a]
08:21:02 <ddarius> Twey: Hacks.
08:21:04 <Twey> > read "\"Foo\"" :: String
08:21:05 <lambdabot>   "Foo"
08:21:05 <Twey> Oh.
08:21:24 <humasect> what, is haskell imperfect or something? =)
08:21:49 <Svrog> yeah - its type system isn't powerful enough :P
08:21:55 * Svrog ducks
08:22:12 <BeelsebobWork> Haskell would be great as a type system
08:22:14 * BeelsebobWork ducks
08:22:17 * humasect throws a toplevel <-
08:22:24 <ddarius> Beelsebob: See Cayenne
08:22:24 <BeelsebobWork> bad!
08:22:27 <BeelsebobWork> no top level <-
08:22:38 <ketil> @seen bos
08:22:39 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 4m 37s ago.
08:22:53 <humasect> BeelsebobWork: think of it like giving clean needles to junkies.
08:23:07 <BeelsebobWork> humasect: no -- they should go cold turkey
08:23:25 <humasect> if they are going to do it anyway, even if we tell them what they should or should not do, might as well let them do it safely
08:23:47 <humasect> eg. glut callbacks ... the only reason i have any toplevel
08:24:17 <quicksilver> why do glut callbacks require toplevel <-
08:24:22 <quicksilver> I have never found them so
08:24:35 <humasect> i don' think they require toplevel <- either.
08:24:39 <humasect> but they do however, use callbacks.
08:24:48 <quicksilver> the only times I've ever used unsafePerformIO is for throwaway readFiles
08:24:59 <quicksilver> sure. There's nothing wrong with callback is there?
08:24:59 <humasect> and what can the display :: IO () callback possibly draw ?=)
08:25:22 <quicksilver> to tidy this up we need a more carefully subdivided 'IO'
08:25:28 <quicksilver> for example display :: GL ()
08:25:34 <humasect> you can pass it an IORef , sure ... but in my case, the display callback is still set to different things.
08:25:35 <quicksilver> ^^ all it can do is draw
08:26:07 <ddarius> quicksilver: You can do that right now.
08:26:22 <humasect> imagine the body of the function :: IO () for the callback. it needs to be passed something like newIORef x >>= \r-> displayCallback $= display r , or use global state
08:27:16 <quicksilver> ddarius: hmm, yes, exactly my point.
08:27:31 <humasect> quicksilver: can IO be subdivided like that? in what way, such that it applies for the case of avoiding globally 'managed' state ?
08:27:50 <quicksilver> humasect: right, I use your first example, with a newIORef.
08:27:59 <mmorrow> this lets you pipe code into ghc: http://hpaste.org/10204
08:28:02 <quicksilver> humasect: if I can be bothered, I hide it all behind some automatic type classes
08:28:05 <mmorrow> ghc -cpp -DMAIN="`cat`" `eval 'A="\`date +%s\`.hs";echo MAIN > \$A;echo \$A;'`
08:28:06 <ddarius> Even Java programmers would do it that way.
08:28:15 <quicksilver> humasect: so that display :: MyMonad ()
08:28:36 <quicksilver> humasect: however a little bit of IORef noise in my 'main' function doesn't offend me.
08:28:59 * ddarius hardly considers it noise.
08:29:01 <humasect> there is not just display, but there is idle, and input. if any should change the ref, the others should receive the changes.
08:29:35 <humasect> quicksilver: yep, i agree. i have a certain situation where the callbacks need to be set and unset
08:29:42 <ddarius> humasect: Indeed.  And passing the IORef to all of those doesn't even add any lines to your code.
08:29:51 <humasect> ddarius: yep=)
08:30:30 <humasect> so state can be avoided when using callbacks
08:30:50 <humasect> but my case is a special one, i think
08:32:11 <ddarius> If it is, you have not yet given any indication on how it is.
08:32:14 <humasect> which cannot be helped. so aside from this, sometimes state is used, even i think much base is guilty of it
08:32:57 <humasect> random seed, unique numbers, that is all i have read of so far. i haven't looked into it. ghci is a lot of state, no?
08:33:10 <humasect> (from the perspective of the evaluation)
08:34:23 <humasect> logically, there should be no difference between toplevel and bottomlevel; they are each a different level than each other. it is just a convention for programs to start at the top, no?
08:34:48 <quicksilver> humasect: I don't set and unset the callbacks.
08:34:48 <Myoma> @keal
08:34:49 <lambdabot> the [nsa] even make light green both ways once
08:34:55 <quicksilver> humasect: I make the callback a generic dispatcher
08:35:04 <quicksilver> humasect: which can redispatch to, if you like, a 'sub-callback'
08:35:10 <quicksilver> depending on current modal state
08:35:16 <humasect> ddarius: using the GHC api, i think it needs to manage state. that i think i am sure of, but could be wrong, i have gotten smarter since writing it and haven't looked at it lately.
08:35:51 <Twey> Argh
08:36:06 <humasect> quicksilver: yep, i see =) this is what i have done for everything but display, really. there are some big chunks of this project that can use some generalising in to a metasubcallback dispatcher
08:36:13 <quicksilver> keyboardDispatch = case mode of MainMenu -> mainMenuKeybd; InGame -> inGameKbd;
08:36:22 <quicksilver> to a very rough approximation.
08:36:28 <humasect> yeah=)
08:36:33 <quicksilver> I'm currently exploring conal + BeelsebobWork's FRP work
08:36:37 <Myoma> hum........
08:36:41 <quicksilver> to see if it will improve things to refactor into a reactive model
08:36:42 <Myoma> I wish they use => instead of -> in case
08:36:58 <humasect> hmm
08:37:39 <ddarius> Myoma: Why does it matter?
08:37:43 <humasect> quicksilver: using ghc api, glut is started/stopped but the window kept alive for display. because my fan turns on if i just leave it running and eating cpu.
08:38:02 <quicksilver> humasect: yeah. ghci/glut is a problem I have never bothered to solve.
08:38:07 <Myoma> it doesn't matter
08:38:15 <Myoma> ddarius: I just think it would look better
08:38:17 <quicksilver> humasect: I use ghci to test/debug the purefly functional parts of my code
08:38:25 <quicksilver> humasect: but, when I want to actaully run the whole gui, I compile it.
08:38:35 <quicksilver> humasect: however I believe some other people have solved it ;)
08:38:52 <humasect> quicksilver: yep, i have sexily written a custom shell for it. i am so very glad it works perfectly, i love it so much. there are only a few virtual things i form strong affection for=)
08:39:06 <quicksilver> ;)
08:39:18 <humasect> quicksilver: this way i can change the code while running, effectively, but saving/loading state as well
08:39:20 <humasect> but=by
08:39:25 <quicksilver> humasect: that sonuds interesting, I would like to see that.
08:39:33 <quicksilver> have you considered uploading it somewhere?
08:40:16 <humasect> and also, on mac , all GL things must be done in the GL thread (it might be glut's fault, i never looked) so i think this is why ghci dies with glut/gl, so any gl calls are done in the glut callbacks
08:40:19 <humasect> hmm, ihaven't
08:41:07 <quicksilver> this is true of all OSes, not just the mac.
08:41:15 <humasect> ohh
08:41:26 <ddarius> Thread-safety is for losers.
08:41:33 <quicksilver> GL uses thread-local state on all three major platforms, at least.
08:41:39 <quicksilver> there is a 'supported' way to move it around though.
08:41:46 <quicksilver> you can bind to the context from another thread
08:41:52 <quicksilver> (putting a mutex around the context)
08:42:00 <quicksilver> but there isn't a haskell interface to this.
08:42:04 <humasect> ghc api makes a giant binary but very small footprint with no leaks, it was leaking a while back. reloading modules and everything works great. it would be nicer of course if more of ghci was publicized for custom shells
08:42:09 <quicksilver> AFAIK it isn't standard, actually.
08:42:57 <humasect> yep
08:44:16 <humasect> i may need to use hopengl for things other than glut (might use glfw later on. glut is terrible) like extensions on windows; they might not be exposed in some drivers, i cannot recall
08:44:43 <quicksilver> windows drivers tend not to expose anything past about 1.3, IIRC.
08:44:55 <quicksilver> glut is very very basic. It's fine if it is all you need :)
08:44:56 <humasect> with any medium to heavy use of glut, the haddock docs only tempt one toward freeglut
08:45:07 <quicksilver> I think you're better of with SDL, to be honest.
08:45:10 <quicksilver> or GTK or WX
08:45:39 <humasect> oh it is less than basic. there is no close callback; it hangs on windows. i am not sure if hopengl exposes it all, but there is no clean way to rebind menus (i get a screenfull of warnings in mac when i did it =)
08:45:43 * chrisdone was about to start a project with glut
08:45:52 <chrisdone> quicksilver: why better of with SDL?
08:46:02 <quicksilver> well for the reasons humasect has just listed, for starters
08:46:11 <quicksilver> add to that no usable joystick support
08:46:12 <humasect> well, gtk and wx i do not need, the UI is within opengl already. so a simple crossplat binding is ok. i will look at glfw at some time
08:46:14 <quicksilver> very limited mouse
08:46:24 <quicksilver> no font or image loading
08:46:25 <humasect> the mouse works great~
08:46:45 <quicksilver> limited keyboard (only basic keys such as keyboards had 20 years ago,
08:46:52 <quicksilver> also no support for 'keydown' events on modifier keys)
08:47:08 <humasect> i could not get bitmap fonts to work, but the stroke fonts are fine. except i need to replace them anyway, not entirely useable in this case (can provide screenshot)
08:47:09 <quicksilver> I mean, actually I use GLUT on many projects, but they are all toys.
08:47:29 <quicksilver> for a "real program" I would use gtk or sdl, most likely.
08:47:33 <humasect> ah, i had to hack in keydown for modifiers and double click
08:47:33 <chrisdone> oh yeah I forgot about how annoying it is to draw fonts in opengl
08:47:33 <quicksilver> I have used wx for image loading
08:47:43 <humasect> hehe, chr1s
08:47:48 <quicksilver> I also use wx for font rendering
08:48:01 <quicksilver> (rendering wx fonts into an offscreen buffer which I upload as a texture)
08:48:02 <humasect> ah i have my fonts already and a custom image format anyway
08:48:47 <humasect> ah, i can't afford the cost
08:49:17 <humasect> i am just workong on a GMA 950 right now
08:49:37 <humasect> nevermind, that is no cost
08:49:56 <humasect> wx is huge, gtk is also huge; ghc is huge enough as it is
08:50:09 <quicksilver> is wx really that big?
08:50:11 <humasect> gtk depends on at least 5 other libs, what does wx depend on ?
08:50:16 <quicksilver> nothing.
08:50:20 <quicksilver> (well wxcore, but that's part of wx)
08:50:24 <humasect> ah
08:50:30 <humasect> wx was in the decamegs
08:50:37 <quicksilver> depends on some native libs of course
08:50:40 <quicksilver> libjpeg and friends
08:50:46 <quicksilver> freetype I imagine.
08:50:54 <humasect> yea, those shouldn't be too bad, those two specificially
08:50:55 <quicksilver> but, that's all functionality I needed anyway!
08:51:04 <humasect> i think it is bigger than ghc api
08:51:09 <quicksilver> I don't particularly think wx is an obvious choice
08:51:16 <quicksilver> I had it installed for another reason
08:51:20 <humasect> sdl rocks, anyway
08:51:20 <quicksilver> so it was easy to just try and use it.
08:51:21 <chrisdone> http://hackage.haskell.org/packages/archive/SDL-gfx/0.5.2/doc/html/Graphics-UI-SDL-Primitives.html
08:51:22 <chrisdone> ^ lol wut
08:51:24 <lambdabot> Title: Graphics.UI.SDL.Primitives, http://tinyurl.com/6eb5ys
08:51:27 <quicksilver> I think SDL is the more obvious choice
08:51:29 <quicksilver> for this kind of thing
08:51:38 <quicksilver> (plus SDL_image and SDL_ttf)
08:51:42 <chrisdone> import Mind.Psychic
08:51:44 <humasect> hehe ; hey i haven't seen Lemmih around this yeat
08:52:19 <quicksilver> chrisdone: looks like a haddock bug to me.
08:52:23 <humasect> quicksilver: sdl is what i used to use, i think now might actually be a good time to start migrating this large project
08:52:42 <quicksilver> humasect: I should warn you I haven't actually used SDL in haskell
08:52:48 <quicksilver> I've used it in previous lives in other languages.
08:52:56 <humasect> SDL_gfx is for bitmapping and blitting and stuff, no?
08:53:09 <quicksilver> but it does seem the most natural thing if you "just want" decent keyboard handling, menus, and font loading.
08:53:15 <chrisdone> quicksilver: I want to make a space invaders game
08:53:16 <humasect> quicksilver: ah no problem =) i have used it a lot in others as well, and both lemmih's binding and my own for haskell
08:53:36 <humasect> quicksilver: also no problem =) menus were evolved into a full UI.
08:54:00 <quicksilver> chrisdone: I would think you could start with GLUT, i fyou like. It's probably simplest.
08:54:11 <quicksilver> chrisdone: if you write the code cleanly it will be no trouble to change to SDL later.
08:54:18 <quicksilver> you only have to change a tiny bit of plumbing.
08:54:27 <humasect> chrisdone: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL-0.5.4  (my apologies if you have found it)
08:54:28 <lambdabot> Title: HackageDB: SDL-0.5.4, http://tinyurl.com/5goped
08:54:53 <quicksilver> humasect: which binding do you currently recommend? Yours or Lemmih's ?
08:55:20 <humasect> nothing is good about glut except its simplicity (for demos etc), and its input .. hm^_^
08:55:23 <chrisdone> quicksilver: I've got GLUT at the moment, I was just going to make a generic monad/EDSL for drawing “pixels”. but you just reminded me of drawing fonts in GL which puts me off
08:55:55 <humasect> quicksilver: his bindings actually inspired a little about my GL binding, i would suggest his because they are clean and 1:1 (mine were meant to be minimal, and they were written at the time that his were early or didn't work)
08:55:56 <chrisdone> humasect: oh nice
08:56:31 <humasect> glut does fonts cleanly, i use them a lot right now. both monospace and proportional
08:56:45 <quicksilver> you mean the ugly stroke fonts?
08:56:47 <quicksilver> or what?
08:57:25 <humasect> they look nice (incoming screenshot)
08:57:28 <humasect> just hard to read in roman
08:57:41 <lilac> how does one write modular, extensible code in haskell? suppose i want a command interpreter with a number of built-in commands, i want self-contained modules defining commands, and i don't want to write an explicit list. is this possible without unsafePerformIO (or similar hacks)?
08:57:44 <chrisdone> hm, really? last time I was using GL I remember it being a lot of work to get nice looking text
08:58:00 <ddarius> lilac: Of course it is.
08:58:09 <ddarius> Why would you need unsafePerformIO?
08:58:23 <lilac> ddarius: the more interesting question is how to do it, rather than is it possible. :)
08:58:30 <Myoma> lilac: The usual monadic approach doesn't work ?
08:58:50 <Myoma> oh don't want to write a list
08:58:53 <humasect> http://img47.imageshack.us/my.php?image=picture3xm4.png
08:59:04 <lilac> Myoma: yes, that's the killer
08:59:16 <humasect> http://img47.imageshack.us/my.php?image=picture2xj8.png
08:59:21 <cjs> I think that lilac may be asking something along the lines of, "How can I create a new module, Foo, that has the correct interface for the commands, and get it linked in without having to modify any other modules?"
08:59:23 <lilac> in C++, it's easy. i have a global object whose constructor registers the command.
08:59:27 <ddarius> lilac: I would just have a Map String (IO ()) or whatever.
08:59:46 <chrisdone> humasect: smoothed but not spaced correctly??
08:59:55 <lilac> ddarius: that still requires explicitly listing all the commands, which i'd like to avoid.
08:59:57 <humasect> chrisdone: that is monospace, one moment
09:00:11 <lilac> perhaps this isn't a haskell question, and instead it's a build system question?
09:00:28 <ddarius> lilac: You're going to have to execute some code to add the commands.
09:00:35 <lilac> that is, perhaps my build system should generate some code to build the list.
09:00:50 <cjs> lilac: That's a reasonable way to go about it.
09:00:54 <ddarius> That code can just return a Map of commands it defines and then you can union them together and pass it to your command interpreter.
09:01:00 <humasect> chrisdone: it looks cleaner when proportional, but my code is under mutany changes so cannot build or execute to show you at the moment
09:01:07 <ddarius> Or you can pass in a mutable variable and they can register themselves.
09:01:13 <cjs> You only care about this at the source level, right? You don't care about linking in binary modules?
09:01:21 <chrisdone> humasect: ah, okay. thanks for the screenies anyway :)
09:01:21 <lilac> cjs: that's correct
09:01:39 <cjs> Yeah, I'd just have the build system generate the list.
09:01:41 <humasect> chrisdone: no problem=)
09:01:49 <lilac> can TH do IO? can I write a TH program which searches for .hs files?
09:01:54 <ddarius> lilac: Yes.
09:02:05 <humasect> (why does Control.Exception.catch operate differently than Prelude.catch ..)
09:02:06 <tromp> @src Enum
09:02:07 <lambdabot> class  Enum a   where
09:02:07 <lambdabot>     succ                     :: a -> a
09:02:07 <lambdabot>     pred                     :: a -> a
09:02:07 <lambdabot>     toEnum                   :: Int -> a
09:02:07 <lambdabot>     fromEnum                 :: a -> Int
09:02:09 <lambdabot> [3 @more lines]
09:02:21 <tromp> > pred False
09:02:22 <lambdabot>   mueval: Prelude.read: no parse
09:02:22 <lambdabot>  mueval: *** Exception: Prelude.Enum.Bool.pr...
09:02:26 <ddarius> humasect: Because Prelude.catch is as standard function and has specified behaviour.
09:02:46 <quicksilver> humasect: yeah, that's fine, but I prefer real truetype fonts as in http://roobarb.jellybean.co.uk/~jules/Picture%20112.png
09:02:54 <quicksilver> or http://roobarb.jellybean.co.uk/~jules/Picture%20140.png
09:02:54 <humasect> ddarius: C.E.catch is not standard, with no specified behavior ?
09:03:19 <humasect> how blurry
09:03:23 <ddarius> humasect: It is not standard and it has different specified behaviour.
09:03:39 <quicksilver> humasect: C.E.catch was written after the h98 standard was final.
09:03:49 <humasect> ahh those fonts are too blurry. i only turned on smoothing for this project because they were unreadable at that scale=)
09:03:55 <humasect> ahh, i see.
09:04:03 <quicksilver> humasect: therefore the new behaviour was given a new name.
09:04:18 <humasect> i have to use C.E.catch for ghc api, but i can use P.catch with readIO
09:04:24 <quicksilver> the fonts are primarly blurry because I deliberately render them at too large a size
09:04:31 <chrisdone> quicksilver: imho the smoothed fonts look nice but out of place with the hard pixels on the corners of the boxes?
09:04:34 <quicksilver> because I plan to display them at all kinds of sizes anyway.
09:04:49 <humasect> ooh~ so will [parts of] prelude become deprecated? can one omit prelude and just use non-prelude, right now?
09:04:57 <quicksilver> since the size is rapidly changing from frame to frame.
09:05:18 <chrisdone> quicksilver: btw that looks like a really cute album browser
09:05:23 <humasect> quicksilver: so what is it showing? =) this font was drawn at scale 0.09 and lineWidth 2
09:05:28 <quicksilver> chrisdone: yes, it's a fair point. There isn't really a neat hack for antialiasing the ends of openGL polygons
09:05:40 <ddarius> humasect: If you don't care about portability, just always use Control.Exception.catch
09:05:43 <quicksilver> chrisdone: if I turned FSAA on, they'd be smooth :)
09:05:56 <ddarius> Heck, other implementations probably just alias that to Prelude.catch so it is probably portable anyway.
09:06:18 <quicksilver> humasect: incidentally readIO + catch is code smell.
09:06:21 <chrisdone> quicksilver: ah, right. that's something I always wondered about. people send me pics of game scenes and say "isn't it beautiful" and I point to the jagged edges and look confused
09:06:23 <quicksilver> humasect: use reads and keep it pure :)
09:06:39 <humasect> ddarius: ah, good, my project goes wherever GHC does. but can one hide prelude completely, and rely on these "new" ways, all the time? for everything, if prelude doesn't have anything which non-prelude doesn't
09:06:39 <ddarius> readIO is a code smell
09:06:53 <chrisdone> quicksilver: like looking at something made from lego blocks :P
09:06:56 <humasect> quicksilver: hehe, do not worry, it is always right next to readFile/writeFile
09:06:59 <quicksilver> chrisdone: FSAA is extremely expensive.
09:07:10 <quicksilver> chrisdone: although becoming more common, these days.
09:07:24 <quicksilver> chrisdone: my laptop is perfectly capable of running the album browser with FSAA though :)
09:07:26 <chrisdone> quicksilver: that's nice to hear
09:07:32 <quicksilver> but a friend's machine with a very old graphics card is not.
09:07:39 <quicksilver> so it happens to be turned off in the source at the moment.
09:07:55 <quicksilver> chrisdone: it does play the songs too (but it cheats, using mplayer)
09:07:57 <humasect> automatic detail and prettyness is art smell.
09:07:57 <chrisdone> sure
09:07:59 <ddarius> chrisdone: Just run a tight Gaussian blur filter over the final image.
09:08:03 <chrisdone> quicksilver: and why not? :)
09:08:05 <humasect> like lense flares. art smell.
09:08:33 <chrisdone> what's “art smell”?
09:08:42 <humasect> like code smell, but for art
09:09:00 <humasect> FSAA is this
09:09:20 <ddarius> Antialiasing removes detail
09:09:21 <quicksilver> hmm. I don't really see it that way, I must admit.
09:09:36 <quicksilver> ddarius: not always.
09:09:43 <ddarius> quicksilver: True.
09:09:45 <humasect> it is like wearing glasses that make your vision fuzzy.
09:09:51 <humasect> for "better graphics"
09:10:11 <quicksilver> ddarius: if you look at the album just to the right-of-center, you can probably just about read "Paul Simon: Graceland" on the cover art itself
09:10:22 <quicksilver> ddarius: if I turned AA off on that image, you would just see black blobs.
09:10:27 <quicksilver> so in this case, AA adds detail.
09:10:28 <humasect> pretending that pixels aren't there by tricking the eyes cannot be any smart way to go about many things
09:10:37 <ddarius> I guess oversampling does technically have more information to work with.
09:10:44 <ddarius> I may retract my statement.
09:10:48 <chrisdone> true, that is an interesting property. I've noticed that with my own application fonts
09:11:03 <quicksilver> your suggestion of doing a tight gaussian blur, of course, would not add information :)
09:11:09 <ddarius> quicksilver: Indeed.
09:11:29 <chrisdone> quicksilver: I see you have the ricky gervais radio show. much respect
09:12:05 <quicksilver> humasect: have you never benefitted from good quality text AA?
09:12:06 <humasect> i turned off text antialising for emacs working with code
09:12:14 <Myoma> if you do a 640x480 image with 4x AA, it's less detailed than a 640*2x480*2 bitmap
09:12:16 <chrisdone> quicksilver: I can't read the text, I just recognised Karl's bald, round head
09:12:18 <quicksilver> try browsing web pages on the iPhone, as one exacmple.
09:12:25 <humasect> but for web pages, it is much better. for your album browser, it is also a good place to use it
09:12:28 <quicksilver> the AA there is really nice, and improves readability a lot.
09:12:37 <quicksilver> yes, I don't use AA fonts in emacs either.
09:12:48 <Myoma> 640x480 AA has more information that 640x480 non-AA though
09:12:50 <quicksilver> I have a very nice fixed font in emacs which I'm very used to and find very easy to read :)
09:13:01 <Myoma> what is the font
09:13:01 <Myoma> ?
09:13:06 <Myoma> I use luxi-mono with AA
09:13:10 <quicksilver> Actually. I'm lying through my teeth.
09:13:11 <humasect> Myoma: what? 640x480 is 640x480
09:13:18 <quicksilver> OSX is antialiasing my emacs window
09:13:23 <quicksilver> but it's doing it so well I didn't notice.
09:13:24 <humasect> quicksilver: screen meh
09:13:32 <humasect> ah.
09:13:56 <humasect> nevermind ... when i turned it off after thinking "maybe AA isn't such a good idea", things were Good again
09:14:08 <Beelsebob> Myoma: uh, no, there's no extra information in an anti-aliased image
09:14:11 <Baughn> quicksilver: Antialiasing? You're sure you don't mean sub-pixel rendering?
09:14:16 <chrisdone> quicksilver: fwuhahaha, they've slipped AA into your brain without you knowing it. thus begins your dependancy on AA
09:14:18 <quicksilver> my emacs font : http://roobarb.jellybean.co.uk/~jules/Picture%20158.png
09:14:25 <humasect> except, for these tiny lambdas and unicode symbols and such that could use AA because they are so small.=)
09:14:35 <quicksilver> Baughn: sub-pixel rendering is a kind of anti-aliasing, in my book.
09:14:37 <chrisdone> yes, that is terribly blurry compared to mine. (subpixel)
09:14:54 <quicksilver> chrisdone: of course it's designed to be viewed on an LCD with the exact characteristics of an apple LCD :)
09:14:55 <ddarius> Beelsebob: If you've oversampled a picture at 640x480x4, you will have more information.
09:15:01 <humasect> but, realise, there is nothing AA can't do which the font info couldn't do already. it should be able to render really small, using the right amount of AA -- it is the "full-screen AA" which is "smell"
09:15:16 <chrisdone> quicksilver: does that make it less blurry?
09:15:18 <Baughn> quicksilver: In any case, /screenshotting/ it never goes well
09:15:27 <Baughn> That just looks blurry
09:15:38 <quicksilver> Baughn: unless the screenshot is viewed on another screen with the same subpixel characteristics, of course.
09:15:38 <Beelsebob> ddarius: no, it'll have exactly the same amount of info -- just *different* info
09:15:44 <humasect> quicksilver: ah, yep, same with my defaults. so i went with black background, turned off AA, and things were fantastic after that. lots and lots of coding. (also, try Aquamacs)
09:15:59 <Beelsebob> instead of "what is the pixel value at exactly this point" it'll have "what is the average pixel value in this area"
09:16:12 <humasect> Baughn: those are the fonts, that is how it looks on screen.
09:16:15 <Baughn> quicksilver: True. I'm not sure, but I think yours is the reverse of mine, so that's a loss.
09:16:17 <ddarius> Beelsebob: Which can reveal more information about the scene rendered.
09:16:24 <ddarius> E.g. it can reveal fine lines.
09:16:30 <chrisdone> quicksilver: here is mine: http://chrisdone.com/tmp/Screenshot-10.png , for some reason screenshotting it does go well. I don't understand the subpixel technology
09:16:41 <quicksilver> chrisdone: it certainly doesn't look blurry to me. I can't prove if that is primarily a property of my eyes, my brain, or my screen.
09:16:43 <Beelsebob> ddarius: yes -- but at the same time it hides information -- like what the exact pixel value at various exact points is
09:16:53 <Beelsebob> see, no *more* info -- exactly the same amount -- just different info
09:17:13 <Baughn> chrisdone: Subpixel rendering takes advantage of the red, green and blue parts of a pixel not actually being in the same physical location on an LCD display
09:17:24 <ddarius> Beelsebob: Okay.  Then it comes down to what is important.
09:17:25 <Baughn> Of course it would look fine on the /same screen/ it was originally rendered for
09:17:27 <quicksilver> chrisdone: yes, that looks very slightly blurred to me, though.
09:17:28 <humasect> ok, here is mine too: http://img49.imageshack.us/my.php?image=picture4bk6.png
09:17:37 <quicksilver> chrisdone: although not unless I look closely.
09:17:43 <Baughn> quicksilver: Your screen uses BGR order, am I right?
09:17:54 <quicksilver> Baughn: I don't even know :) How can I find out?
09:18:05 <chrisdone> quicksilver: I think the bold bits look blurry even without close inspection, I'm afraid :(
09:18:08 <humasect> chrisdone: ah, that looks nice =) it is a good example of when AA is not used "automatically" and smart with the fonts.
09:18:12 <Baughn> quicksilver: Put your head very close to the screen, and look at the left and right edges of letters. :P
09:18:15 <humasect> (the whole point of TTF)
09:18:28 <Baughn> quicksilver: If sub-pixel rendering is on, the left side will look red and the right side blue
09:18:36 <humasect> Baughn: that is for [older] LCDs
09:18:41 <quicksilver> humasect: that is sharp, yes.
09:19:10 <chrisdone> humasect: sure. it's the clearest kind of font rendering I've ever had
09:19:12 <Baughn> quicksilver: Or the other way around, if it's RGB order
09:19:26 <quicksilver> Baughn: orangy on the left, bluey on the right
09:19:30 <quicksilver> using Pixie.app
09:19:37 <quicksilver> apple's pixel magnifier ;)
09:19:45 <humasect> chrisdone: its very nice. better than either of ours. ^_^
09:20:03 <quicksilver> humasect: well, on my screen, mine looks nicer than chrisdone's.
09:20:12 <Baughn> quicksilver: Eh. That's the same as mine, actually
09:20:13 <quicksilver> humasect: indicating, I think, that my screen has different characteristics to his.
09:20:15 <Baughn> Pixie's neat
09:20:31 <humasect> quicksilver: hm, what kind of screen ?
09:20:59 * ddarius is happy with his console fonts and xchat fonts.
09:21:00 <humasect> quicksilver: yours looks just like mine did when i had it turned on in emacs. (monaco 10)
09:21:22 <quicksilver> humasect: 15" MBP, about 1 year old.
09:21:32 <humasect> ah, 13" MB 1yo
09:21:51 <chrisdone> quicksilver: do your fonts look blurry or normal on the screenshot, when viewed on your screen?
09:22:30 <quicksilver> my screenshot looks crisp, yours looks slightly blurry
09:22:37 <quicksilver> humasect's looks crisp, of course.
09:23:25 <chrisdone> his appear pixelated and lacking any antialiasing. are they smooth on yours?
09:23:49 <humasect> i like chrisdone's better, x11 really has fantastic fonts for tech/coder. i also turned of AA in Terminal.app ; its like using x11 before freetype days=)
09:23:53 <BONUS> humansect: is that vim? how do you get such nice coloring
09:24:07 <BONUS> and the lambda and -> signs
09:24:10 <Deewiant> looks like emacs
09:24:11 <humasect> chrisdone: they have no AA at all, just 1 color
09:24:16 <humasect> yep it is aquamacs
09:24:19 <chrisdone> humasect: ah, oki
09:24:29 <BONUS> ah
09:24:36 <quicksilver> chrisdone: they are not antialiased, no, but it is a nice font.
09:24:54 <humasect> it is the same font as yours quicksilver , with AA off
09:25:15 * ddarius finds it rather ugly.
09:25:41 <humasect> hehe, i don't like it either; but have not bothered (until maybe right now..) to look for a better one
09:26:14 <quicksilver> I suspect there is a large aspect of taste coming into this.
09:26:21 <humasect> i would rather a font without the little curlies on lower case l and i, and the a should look more like an a
09:26:26 <quicksilver> When AA fonts first came out, I didn't like them for programming.
09:26:27 <humasect> (and less like an o)
09:26:43 <quicksilver> I never used them until I switched to carbon emacs
09:26:59 <quicksilver> which was perhaps the first time I was exposed to sub-pixel AA
09:27:10 <quicksilver> and I decided the sub-pixel stuff is, just about, better than with AA off.
09:27:24 <humasect> i tried to stick with white screen and AA fonts, but for long periods and really visualising what is going on with the code, and to work with it visually and intuitively (i don't know how . works .. but i know how to use it!) i had to switch back
09:27:34 <chrisdone> so, I'm going to try those SDL bindings
09:27:51 <Botje> yeah
09:27:59 <Botje> white screens hurt when you work at night
09:28:01 <humasect> i will change my font and then also convert this project away from glut and toward SDL.
09:28:14 <quicksilver> Botje: less so if you adjust the birghtness, perhaps?
09:28:31 <ziman> chrisdone, what's the name of the font you're using?
09:28:33 <humasect> Botje: i still prefer having a light around, but the coloring abilities are less possible with white; black shows/contrasts more colors, of course
09:28:39 <chrisdone> ziman: it's called Monaco
09:28:47 <Botje> quicksilver: then my screen sucks in the day, when there's light all around me :)
09:28:51 <chrisdone> ziman: http://www.gringod.com/2006/11/01/new-version-of-monaco-font/
09:28:52 <humasect> hehe, we are also using monaco, chrisdone
09:28:52 <lambdabot> Title: 11 GrinGod [dot] Com 23 » New Version of Monaco Font 47
09:28:54 <ziman> thanks
09:28:57 <ziman> looks quite good
09:29:05 <humasect> Botje: hehe
09:29:36 <quicksilver> Botje: my screen automatically adjusts with an ambient light sensor
09:29:40 <bos> @src groupBy
09:29:41 <lambdabot> groupBy _  []       =  []
09:29:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:29:41 <lambdabot>     where (ys,zs) = span (eq x) xs
09:29:43 <quicksilver> Botje: and it's only 1 keypress if it gets it wrong.
09:29:56 <chrisdone> I used to use the screen inversion thing with Compiz at night, but now I'm on XMonad
09:30:14 <quicksilver> humasect: I'm not sure you're right that it is the same font.
09:30:20 <quicksilver> humasect: I just turned off AA to test and now it looks horrendous
09:30:28 <quicksilver> humasect: not like yours at all.
09:30:36 <quicksilver> well it might be the same font, but not the same size.
09:30:42 <humasect> quicksilver: that might be the difference between carbon emacs and aquamacs
09:30:45 <humasect> this is size 10
09:31:49 <quicksilver> humasect: I think I'm using 'Bitstream Vera Sans Mono'
09:31:55 <quicksilver> humasect: which, admittedly is *very* like Monaco.
09:31:58 <quicksilver> But, it is not monaco.
09:31:59 <humasect> ah, because yours is under x11 ?
09:32:15 <quicksilver> I don't know how to tell.
09:32:19 <quicksilver> (No, it's not under X11)
09:32:21 <humasect> font-family says apple-monaco, pt size 100
09:32:26 <quicksilver> I don't know how to tell which font it is.
09:32:46 <humasect> customize->set faces->all faces->?-f'default'
09:33:21 <Botje> quicksilver: my screen doesn't have such a button
09:34:09 <quicksilver> humasect: apple monaco 12, apparently.
09:34:44 <humasect> hmm^_^ 12, looked like 10. maybe mine is 12
09:37:44 <humasect> http://dejavu.sourceforge.net/wiki/index.php/Main_Page
09:37:45 <lambdabot> Title: Main Page - DejaVuWiki
09:38:11 * ddarius uses Bitstream Vera Sans Mono Bold 12 for xchat.
09:38:35 <humasect> excellent =) this deja vu is like bitstream vera, i think.
09:39:19 <Myoma> What typeface do fish fear most?
09:39:23 <ddarius> (so the 'm's, when bolded, blend into solid blocks)
09:39:28 <Myoma> .. Gill Sans :p
09:40:38 <humasect> lol, ddarius
09:42:05 * chrisdone laughs
09:42:46 <chrisdone> there's salmon wrong when I'm laughing at jokes like that
09:46:13 <humasect> =)
09:49:00 <humasect> chrisdone,quicksilver,ddarius, please, tell me what you think now:  http://img124.imageshack.us/my.php?image=picture5je0.png
09:50:29 * stepcut prefers 10x20
09:51:12 <Myoma> humasect: Why do you have boxes in your code?
09:51:43 <humasect> hm, that's a good question, what are boxes in this case?
09:51:47 <humasect> [] ?
09:51:58 <mmorrow> here're some module dep graphs for a most (the one's my parser worked on due to a questionable cpp pass) of the ghc modules in ghc/compiler grouped by directory (and an overview (huge) graph). they're no edges between modules in different directories: http://code.haskell.org/~morrow/ghc/ghc-moddeps/
09:51:58 <lambdabot> Title: Index of /~morrow/ghc/ghc-moddeps
09:52:04 <humasect> i just tried this font, it looks like there is no seperation in them
09:52:14 <mmorrow> (rendered with graphviz)
09:53:21 <humasect> mmorrow: hmm,perfect! is it able to apply to any set of modules, or stuck to ghc?
09:53:24 <mapreduce> humasect: Is that in yi or emacs or what?
09:53:45 <mmorrow> humasect: /any/ :). i still have some bugs to work out though.
09:54:04 <humasect> mapreduce: aquamacs yes emacs
09:54:17 <humasect> mmorrow: you did just what i wanted to do =) =) awesome =)
09:54:23 <mapreduce> humasect: How the hell did you get lambdas to appear for \ ?
09:55:07 <Myoma> yay I found a real use for thrists :D
09:55:15 <mmorrow> humasect: coolness. i'll let you know when i get some code up somehwere :)
09:55:21 <Myoma> um..
09:55:22 <humasect> mmorrow: fantastic=) thx
09:55:27 <Myoma> as if there weren't a full paper full of uses already
09:55:39 <Myoma> oh did anybody read R* is the new [a] ?
09:56:08 <humasect> mapreduce: a little bit of emacs code, http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Unicodifying_symbols_.28Pretty_Lambda_for_Haskell-mode.29  is a start
09:56:11 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/yyqy4v
09:56:20 <mapreduce> humasect: Related to glasses-mode at all?
09:57:12 <humasect> mapreduce: hmm i am not sure, but i use other symbols too, like greek chars, and also, a bunch of mathematics ops like square root, sine, union, intersect, etc
09:57:42 <dblazakis> Myoma: what is a thrist? (google have me some stuff, but maybe you can explain more succinctly)
09:58:09 <Myoma> dblazakis, the paper is the best thing to read about it
09:58:15 <humasect> i do not know of glasses-mode , but for example when 'sqrt' becomes the sqrt character, the characters is still there for 'sqrt', it just changes how it renders and how one navigates it (it is one character until one backspaces into it, for eg.
09:58:17 <Myoma> (I mean this one http://www.opendylan.org/~gabor/Thrist-draft-2008-07-18.pdf )
09:58:20 <lambdabot> Title: Thrists: Dominoes of Data Gabor Greif gabor@mac.com 18 July, 2008 Abstract
09:59:37 <dblazakis> Myoma: cool, thanks -- what was your real use?
10:00:01 <mapreduce> humasect: I'd be interested to see whether it can do some wonders for Java code, e.g., making new F<T,U>(){public U invoke(T t){return whatever(t);}} appear as {T t => whatever(t)}
10:00:01 <humasect> i suppose a box makes a good enough []
10:00:03 <Saizan> mmorrow: cool, we could get that integrated with a dependency framework so we can rebuild the graphs icrementally if some module change imports
10:00:56 <humasect> mapreduce: sure=) if it can be regexp'd, and translated so. it can be indeed used as code folding to a simplified version
10:01:14 <mapreduce> humasect: Thanks.
10:01:24 <humasect> mapreduce: you're welcome
10:05:12 <mmorrow> Saizan: totally. this could be soo nice for seeing packages. one interesting thing is hyperlinks can be attached to nodes/edges/arrow{tails/heads} via imagemaps. so clicking on one of these links could take you to another imagemap, etc...
10:05:16 <Hanjin> How would you split a list in two, at a certain position ?
10:06:40 <mmorrow> Saizan: heh, ghc has a bunch of cycles
10:07:53 <scorch_> I have some trouble sorting a list that looks like this: [[('A', 1), ('D', 1)], [('C', 1), ('B', 1)]]. I want to sort it depending om the letters, but keeping the tuples intact. I've tried for a while with sortBy but couldn't come up with anything useful... Any ideas?
10:07:54 <mmorrow> this is a cool one http://code.haskell.org/~morrow/ghc/ghc-moddeps/compiler/hsSyn.pdf
10:07:55 <humasect> mapreduce: also i have changed * to x (highlighted) and / to divide (highlighted), and || is ^ and && is (upside down ^) . i can't wait until ghc finally accepts unicode source
10:07:57 <lambdabot> Title: cache:http://code.haskell.org/~morrow/ghc/ghc-moddeps/compiler/hsSyn.pdf - Googl ..., http://tinyurl.com/6l64m6
10:08:25 <mmorrow> or s/pdf/(png|svg|dot)/  (abusing s/// syntax)
10:08:32 <dblazakis> > splitAt 2 [1, 2, 3, 4, 5]
10:08:34 <lambdabot>   ([1,2],[3,4,5])
10:08:55 <dblazakis> Hanjin: is that what you mean?
10:09:14 <Hanjin> dblazakis: Well, the thing is that i am supposed to make my own function
10:10:18 <Hanjin> not using a predefined one
10:10:25 <humasect> scorch_: that looks sorted already.
10:10:42 <humasect> scorch_: or do you mean, to have 'C' after 'D' in the first level of the list ?
10:10:50 <humasect> sorry, after 'B'.
10:11:12 <scorch_> humasect: yes, A, B, C, D and so on
10:11:36 <dblazakis> Hanjin: i see, try writing a function to always split it at the first position then think about how you could generalize that
10:11:53 <scorch_> actually I just need to sort one vector, not the whole matrix
10:12:12 <Deewiant> > map (sortBy (comparing fst)) [[('A', 1), ('D', 1)], [('C', 1), ('B', 1)]]
10:12:13 <lambdabot>   [[('A',1),('D',1)],[('B',1),('C',1)]]
10:13:13 <humasect> :t comparing
10:13:14 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
10:13:25 <scorch_> Deewiant: heh, thanks. Just what I needed. :)
10:13:45 <Deewiant> great :-)
10:14:20 <Hanjin> dblazakis: recursion ;)
10:14:34 <Twey> Hanjin: yourOwnFunction = splitAt -- Haskell makes it easy!
10:14:59 <humasect> how do we find out the infix value of operators ?
10:14:59 <Hanjin> heh
10:15:01 <humasect> say, -
10:15:12 <ddarius> humasect: Use :info in GHC
10:15:20 <ddarius> u
10:15:25 <humasect> ah, nice, thanks
10:15:26 <Twey> i**
10:15:27 <Twey> :-P
10:15:28 <Deewiant> yourOwnFunction = liftM2 (&&&) take drop -- Haskell makes it easy!
10:15:58 <Twey> Ah!  That's it
10:16:07 <Twey> I knew it had to use liftM2 in some way
10:16:21 <Twey> liftM2 actually doesn't have anything to do with monads, does it?
10:16:31 <Deewiant> ?ty liftM2
10:16:32 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:16:36 <Twey> Oh
10:16:39 <ddarius> Twey: You could generalize it.
10:16:39 <Deewiant> :-)
10:16:41 <Twey> In ((->) e)?
10:16:42 <ddarius> :t liftA2
10:16:43 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:17:03 <ddarius> @users
10:17:04 <lambdabot> Maximum users seen in #haskell: 497, currently: 469 (94.4%), active: 17 (3.6%)
10:17:13 <Twey> Uh?
10:17:15 <Deewiant> liftM2 (++) (readFile "a") (readFile "b") -- for instance
10:17:23 <Twey> Oh, not counting itself
10:18:00 <Twey> @src (&&&)
10:18:00 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
10:18:07 <Twey> Argh
10:18:13 <Deewiant> heheh
10:18:16 <Twey> :t (&&&)
10:18:17 <Deewiant> ?ty (&&&)
10:18:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:18:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:18:20 <humasect> the higher the number, the higher the priority, for infixl ?
10:18:22 <Twey> Argh!
10:18:24 <ddarius> That's exactly the definition you'd get via adjunction.
10:18:38 <Twey> Arrows scare me
10:18:51 * Twey eyes an arrow warily.
10:19:06 <Deewiant> I just use them for functions with tuples
10:19:30 <Saizan> humasect: yes
10:19:37 <humasect> what is the infix level for regular functions? 0?
10:19:55 <humasect> . has ultra priority, and $ has none
10:20:05 <Saizan> 10
10:20:14 <humasect> ahh.. this makes sense. thanks^_^
10:20:52 <Deewiant> Twey: (f &&& g) x is (f x, g x). (f *** g) (x,y) is (f x, g y).
10:21:26 <Deewiant> (>>>) = flip (.)
10:22:08 <Twey> Oh, right.
10:22:17 <Twey> That's surprisingly simple.
10:22:36 <Deewiant> Yes, it is. :-)
10:22:38 <Twey> Hehe
10:24:29 <Myoma> replace the a with an infix ~>
10:24:48 <Deewiant> hard to do mentally
10:24:50 <Myoma> then you see much less scary, (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
10:24:54 <Myoma> don't do it mentally then
10:25:09 <Deewiant> too much bother to do it then :-P
10:25:33 <Myoma> I'm sure you could instruct a computer to do this sort of thing
10:25:43 <humasect> =)
10:26:06 <ddarius> "Myster and misery go hand in hand, so you better follow the master plan."
10:26:13 <Deewiant> I wonder, does it take it from the class declaration
10:26:45 <Deewiant> so if one were to do "class Arrow (~>) where..." would it work directly
10:27:44 <humasect> there should be a flag to reverse all infix ..
10:28:06 <humasect> hey, what is the clean way for this : (a0,a1,a2,a3) @+ (b0,b1,b2,b3) = (a0+b0,a1+b1,a2+b2,a3+b3)  curry/uncurry?
10:28:27 <ddarius> The clean way is not to use tuples
10:28:30 <Deewiant> (@+) = uncurry4 (+), if such a thing as uncurry4 existed
10:28:42 <Myoma> :t uncurry
10:28:43 <ddarius> :t uncurry4
10:28:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:28:44 <lambdabot> Not in scope: `uncurry4'
10:28:45 <humasect> that's what i thought, Deewiant =)
10:28:48 <Myoma> :t uncurry (+)
10:28:55 <Twey> Gosh
10:28:56 <lambdabot> forall a. (Num a) => (a, a) -> a
10:28:58 <Myoma> I don't beleive that would work ...
10:29:10 <humasect> > uncurry (+) (2,3)
10:29:15 <Deewiant> hmm, it probably wouldn't now that I think about it :-P
10:29:19 <Myoma> I would call it dyad4 (+)
10:29:26 <dmead> whats the ghci flag to follow imports?
10:29:27 <lambdabot>   5
10:29:28 <dmead> when doing compilation
10:29:35 <Twey> dmead: --make
10:29:36 <humasect> ddarius: not using tuples, you say?
10:29:43 * ddarius would call it (+) with an appropriate instance declaration.
10:29:46 <Twey> Wait, GHCi?
10:29:49 <dmead> even if it's a local directory import?
10:29:50 * Myoma wonders if you are doing quaternions
10:29:53 <humasect> foldl1 (+) [1,2,3,4] ?
10:29:57 <humasect> oops
10:30:11 <Myoma> humasect: Why are you summing them, that's not what you originally said
10:30:12 <ddarius> humasect: You don't want tuples anyway as I doubt you benefit from having the components be lazy.
10:30:15 <humasect> ddarius: yes, that is part of an instance=)
10:30:30 <humasect> Myoma: sorry i made a mistake, map
10:30:41 <Myoma> map now ??
10:30:52 <humasect> Myoma: if it were a list instead of tuples
10:30:55 <Myoma> zipWith
10:31:39 <cjs> Oh no. I appear to have no -N available in the list of RTS options for my programs.
10:31:51 <humasect> ddarius: what is the alternative? Data a b c d ?
10:32:01 <cjs> Would this be due to messing up the link by leaving out -threaded in some place where I needed it?
10:32:03 <humasect> cjs: -threaded ?
10:32:05 <Myoma> are you defining quaternions
10:32:10 <cjs> Or more likely my platform doesn't support it?
10:32:13 <ddarius>  V !Double !Double !Double !Double or whatever.
10:32:19 <cjs> I though I linked with -threaded, but I'll go confirm.
10:32:48 <humasect> Myoma/ddarius: they are vectors able to mix with scalars
10:33:02 <cjs> I need -threaded only during the link stage, right?
10:33:04 <Myoma> hat
10:33:05 <Myoma> what
10:33:08 <humasect> ddarius: i thought (!) is strict?
10:33:14 <Myoma> why don't you define a vector type
10:33:20 <humasect> i did/do
10:33:27 <dmead> (.text+0x429): undefined reference to `strictzm0zi3zi2_SystemziIOziStrict_readFile_closure'
10:33:29 <Myoma> I mean Vector N where N is a number
10:33:34 <dmead> i've got strict file IO installed
10:33:35 <Myoma> then you can use fmap and such on it
10:33:44 <dmead> do i need to compile their objects?
10:33:55 <humasect> hmm, yes Myoma that is the thing i was looking for, but they are very small
10:34:06 <cjs> Yeah, just a bad link somehow. Sorry for the trouble.
10:34:09 <Myoma> they being small makes this approach less worthwhile?
10:34:51 <humasect> hm no, i don't see how that would be the case, unless there is overhead .. but if they become lazy, that would be overhead removed, right ?
10:36:08 <humasect> tuples and Ptr work together nicely, i thought; which is a benefit in this application
10:37:14 <cjs> Hm. So if I've got multiple threads doing work, and I'm running my program with -N2, what does it tell me when one core is working mostly full bore and the other is 100% idle?
10:37:53 <humasect> it means `par` needs to be used, i think
10:38:25 <cjs> Even though I've got two separate threads doing processing?
10:38:43 <Twey> :t par
10:38:44 <lambdabot> forall a b. a -> b -> b
10:38:53 <Twey> What's `par`?
10:39:23 <ddarius> Twey: Between the type and the name it is pretty obvious.
10:39:24 <cjs> I'm wondering if it's telling me that i'm sending nothing but thunks down the channel from one thread to another.
10:39:43 <humasect> something about -Nx not being able to magically parallel-process any kind of code
10:39:49 <Twey> ddarius: The type isn't really helpful :-P
10:39:50 <ddarius> cjs: Explore that hypothesis.
10:39:52 <humasect> or use yield, cjs
10:39:58 <Twey> I would guess something to do with parallelism?
10:40:05 <Deewiant> Twey: par a b = b, but a may be evaluated in parallel
10:40:05 <ddarius> Twey: The type almost completely defines the behaviour.
10:40:07 <cjs> Twey: it evaluates a and b in parallel, and returns the result of evaluating b.
10:40:12 <Twey> Ahhh.
10:40:14 <Deewiant> it doesn't necessarily evaluate a
10:40:17 <humasect> it is like `seq` but for parallel
10:40:27 <Deewiant> and it's not quite like seq
10:40:31 <Twey> Hmn
10:40:39 <humasect> ah ok, i've never used either, my apologies
10:40:49 <Deewiant> I can't remember exactly why it's not like seq but I remember it's not :-P
10:40:51 <Twey> I see, so it starts evaluating a... then what happens if you try to use a whilst it's still being evaluated?
10:41:12 <Deewiant> Twey: well, what usually happens. :-P
10:41:17 <cjs> humasect: how will yield help? I've got only two threads, and I'm using -N2 on two cores: there's nothing to yield to, I would think.
10:41:21 <humasect> hm, things can get messy when instance Num desires 2 args?
10:41:46 <humasect> cjs: to yield to the other thread, nothing about cores. they are enabled, but how does it know which to do what with?
10:42:03 <humasect> throw in `par` and see what happens=)
10:42:22 <ddarius> humasect: If he is using forkIO and co, par isn't going to help him at all.
10:42:25 <cjs> Yield allows stopping the current thread to run others. However, the other is already running. So the only thread available to run is the one yielding.
10:42:45 <Twey> Deewiant: Oh, right.  Heh
10:43:35 <humasect> ok, so where is the problem then?
10:43:45 <humasect> in the runtime?
10:44:46 <cjs> Right. My simulator forksIO a trader process, and then reads a market data feed and forwards it to the trader (via a Chan). It also listens for messages coming back from the trader (on another Chan). I suspect that the trader is actually doing all of the work to even parse the messages and so on, because the simulator, at the moment, throws them away after forwarding them to the trader.
10:44:53 <ddarius> I wonder if it would be very easy to have GHC use recursive helping if it doesn't already.
10:45:36 <ddarius> cjs: Yes, it is probably spending most of its time blocked on IO.
10:46:10 <humasect> ahh i see
10:49:00 <cjs> Who knew that being lazy would be so much hard work?
10:52:18 <humasect> hehe
10:54:34 <wman> hi, anybody crossed swords with haskell-ldap (win32) ? all goes well until i try to add some attributes to the result, then it segfaults ..
11:00:35 <ddmnshs> "Барак"=~"Барак"
11:00:49 <ddmnshs> "Барак"=~"Барак"::Bool
11:01:07 <Deewiant> > "Барак"=~"Барак"
11:01:08 <lambdabot>   mueval: Prelude.read: no parse
11:02:04 <ddmnshs> does anybody know how to use regex with UTF8?
11:03:55 <ddmnshs> say we have  src<-openURL "some romanian site"
11:04:28 <ddarius> ddmnshs: Haskell Strings are lists of Chars which are Unicode codepoints.  They don't have an encoding.
11:04:39 <ddarius> ddmnshs: You need to read in the input using a proper decoder.
11:07:35 <ddmnshs> Thanks a lot/ But how to transform  list of chars to UTF8 string? I mean what library to use?
11:08:19 <Deewiant> ?hackage utf8-string -- IIRC
11:08:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string -- IIRC
11:12:30 <ddmnshs>  Noup/ It is not working in my case. If I try to use regex on UTF8 String I got an error
11:23:50 <hackage> Uploaded to hackage: terminfo 0.2.1
11:24:39 <Hanjin> dblazakis: a base case could be split 0 s = ([],[]) But i don't really understand, should i still declare split(x:xs) ?
11:28:24 <dblazakis> Hanjin: what is split 0 [1,2,3]?
11:29:49 <Hanjin> dblazakis: ([],[]) =/
11:30:05 <Deewiant> not ([],[1,2,3]) ?
11:30:09 <dblazakis> > splitAt 0 [1,2,3]
11:30:10 <Hanjin> bad base case
11:30:10 <lambdabot>   ([],[1,2,3])
11:30:30 <mikeX> hello, isn't the following function tail recursive:
11:30:34 <mikeX> len acc (x:xs) = len (acc+1) xs
11:30:35 <mikeX> len acc _ = acc
11:30:51 <Deewiant> indeed it is
11:30:52 <ddarius> mikeX: Read http://www.haskell.org/haskellwiki/Stack_overflow
11:30:53 <mikeX> when I load it in ghci and use a large enough list as argument, I get a stack overflow exception
11:30:54 <lambdabot> Title: Stack overflow - HaskellWiki
11:31:22 <Jedai> mikeX: Yeah, that's not because there is too much calls to len on the stack
11:31:51 <Botje> mikeX: that's because haskell's laziness makes (acc+1) a _HUGE_ thunk
11:32:06 <Jedai> mikeX: read ddarius link for an explanation (note that the optimiser would remove this stack overflow but GHCI don't optimize)
11:32:13 <Deewiant> (((acc+1)+1)+1...
11:32:31 <mikeX> aha, thanks a lot everyone :)
11:34:20 <Myoma> mikeX: Whether something in a lazy language is tail recursive or not isn't any indicator of the amount of stack it will use
11:35:10 <mikeX> I understand now, I'm not accustomed to lazyness
11:35:20 <BMeph_> Jedai: Wrong - er, see Botje's explanation. :)
11:35:45 <Jedai> mikeX: Myoma is exagerating, tail recursion works in Haskell as in other languages, but lazyness can have effects that are surprising to beginners
11:35:57 <Myoma> Jedai: No I am not
11:36:26 <Jedai> BMeph_: Nope, I'm right, len calls aren't what blows the stack, it's the (+) from the thunk when we finally evaluate it
11:36:52 <Jedai> Myoma: We already had this discussion... ^^
11:37:11 <Myoma> Jedai: When we talked about this before you had an incorrect definition of what a tail call _is_
11:37:22 <ben> Is there an equivalent to import qualified foo as bar for use in ghci?
11:37:31 <ddarius> ben: No
11:37:36 <Jedai> Myoma: What's your definition finally ?
11:37:51 <ben> ddarius: Thanks
11:40:49 <dblazakis> Myoma: fyi, the typesetting for the code snippets in the thrist link you gave is messed up, but the previous one is good: http://www.opendylan.org/~gabor/Thrist-draft-2008-07-15.pdf
11:40:51 <lambdabot> Title: cache:http://www.opendylan.org/~gabor/Thrist-draft-2008-07-15.pdf - Google Searc ...
11:40:57 <Myoma> Jedai: Are you actually interested ?
11:41:35 <Jedai> Myoma: Well, last time it wasn't very clear so I would like to have a clear definition, yes
11:41:44 <Myoma> Jedai: from R5RS
11:42:00 <Myoma> it's completely unambiguous and inductively defined (so it's formal in a sense)
11:44:19 <Jedai> Myoma: It's also defined on construct that aren't in Haskell
11:44:46 <Myoma> Jedai: Yes, you can easily generalize it for other syntaxes
11:45:58 <Jedai> Myoma: For example how would you classify truc p n = p n && truc p (n-1); truc _ 0 = True
11:46:08 <Jedai> Myoma: tail recursive or not ?
11:46:20 <wman> ghc uses UTF16 as internal string representation ?
11:47:05 <ddarius> Jedai: Tail recursion is a syntactic notion.  That definition is not tail recursive.
11:47:15 <Hanjin> hmm, are you allowed to write split (x:xs) n s =....
11:47:29 <Jedai> ddarius: Ok, fair I guess.
11:48:14 <Myoma> Jedai: I don't, The point I'm trying to make is that tail calls aren't relevant to lazy evaluation. It's simple to show that any tail recursive functions can be written directly (using strictness) in haskell, but tail recursion by itsself is a useless notion. We have something more general that should be considered independently
11:48:29 <dblazakis> Hanjin: not sure what you're asking, but if you can pattern match a list like that, yes
11:49:15 <ddarius> Myoma: Tail recursion is still very relevant to Haskell.
11:49:27 <Jedai> Myoma: In this case I agree with you a little bit, except that tail recursion still seems very relevant to me
11:50:16 <wman> ddarius : that it allows optimize calls into jumps, or is there something more ?
11:50:59 <Jedai> My opinion last time and now is that "lazyness" and "tail-recursion" are two different aspects that can change the use of the stack of a program and they're both relevant though orthogonal
11:51:03 <Baughn> wman: The main problem is that the haskell stack looks nothing like what you're used to
11:51:22 <Baughn> Essentially only strict computations go on there. The moment anything gets lazy, it also gets heap-allocated and run at need
11:51:34 <rwbarton> Is  fact acc n = if n == 0 then acc else fact (acc*n) (n-1)  tail recursive?  What about  fact acc n = if' (n == 0) acc (fact (acc*n) (n-1))  ?
11:51:45 <ddarius> Myoma: If we decorated all function calls with (accurate) strictness information, we could define a more general and more useful (syntactic) notion of tail recursion.
11:52:07 <Myoma> ddarius: Yes, a strict language
11:52:23 <Jedai> rwbarton: According to Myoma/ddarius definition the first definition is, the second isn't
11:52:27 <ddarius> Myoma: What are you talkingou about?
11:52:41 <Myoma> you can embed strict tail recursive functions with $!
11:52:42 <ddarius> rwbarton: The first is, the second isn't, but you do bring up a point that it is relative to what is considered "syntax."
11:52:51 <Myoma> you get the same space and time complexityoae
11:53:36 <Jedai> Myoma: right and in the first case you owe this complexity to tail recursion, in the second to the lazyness of if'
11:53:45 <ddarius> Myoma: I don't see how that is related to what I was saying.
11:54:04 <rwbarton> Given that you can't write if' in Scheme, it's unclear to me that you should carry over a definition intended for Scheme and expect it to be the right one for Haskell as well
11:54:48 <Jedai> rwbarton: That's my point of view as well but we need a clear definition here if we want to have a coherent argument so we can as well go with this one
11:55:14 <Myoma> rwbarton: The definition of tail calls and TCO are just syntactic, so we can apply them here (and many people do), I'm saying they are irrelevant notions since graph reduction should change ones intuition considerably
11:56:03 <Myoma> Jedai: We already have formal definitions, the only problem is trying to find a nail to hit with them
11:56:33 <wman> baughn: well, i haven't seen much of assembly/binary since school (Z80), so there isn't much i'm used to in this area. googling for haskell stack offered a plethora of "how to write a stack in haskell", nothing relevant. some tips for interesting reading on haskell (ghc) internals for those comming long winter evenings ?
11:56:39 <Myoma> It's not a problem that there isn't one though, because a larger class of functions operate in O(1) stack
11:57:22 <ddarius> Myoma: And I'm saying that it would be conceptually easy to extend the previous definition of "tail recursive" to another, still syntactic notion, that accurately captures the behaviour of Haskell.
11:57:47 <Jedai> Myoma: There is one, there is a large category of functions where tail recursion bring the basis of the performance (with eventually a little bit of strictness added but not always)
11:58:09 <Myoma> ddarius: A purely syntactic one? I'm not sure that's possible but it would be very interesting
11:58:47 <ddarius> I already described it, the problem is that accurately annotating the code is undecidable.
11:59:10 <Myoma> Jedai: If you add strictness, you can apply the rules that we learned programming in/thinking about strict language -- this is _confusing_ because one is not sure (regarding optimizations and such) when the rules do not apply
11:59:37 <ddarius> However, a reasonable approximation would be of good didactic use.
12:01:00 <Taejo> @unpl \x,y,z -> [x, y, z]
12:01:01 <lambdabot>  Parse error at ",y,z" (column 3)
12:01:09 <Taejo> @unpl \x,y,z -> x:y:z:[]
12:01:09 <lambdabot>  Parse error at ",y,z" (column 3)
12:01:20 <Taejo> @unpl \x y z -> x:y:z:[]
12:01:20 <lambdabot> \ x y z -> x : y : z : []
12:01:33 <Taejo> lambdabot: you fail
12:01:36 <Jedai> Myoma: A tail recursive function always perform in constant stack space, the strictness is only necessary if it will produce a thunk that will blow the stack (which is not always the case, even without strictness added)
12:01:42 <Baughn> Taejo: What? Why?
12:01:46 <Baughn> Taejo: Perhaps you meant @pl
12:01:56 <ddarius> Jedai: Again, the formal notion of "tail recursive" is purely syntactic.
12:01:57 <Taejo> oops, lol
12:02:01 <Taejo> @pl \x y z -> x:y:z:[]
12:02:01 <lambdabot> (. ((. return) . (:))) . (.) . (:)
12:02:18 <Baughn> @pl \x y z -> x:y:z
12:02:19 <lambdabot> (. (:)) . (.) . (:)
12:03:01 <Jedai> ddarius: Yes, and a "tail recursive" function by this definition never accumulate the calls to himself on the stack (the stack overflows that happen isn't due to this function, not directly)
12:03:32 <ddarius> Jedai: No.  The syntactic notion says nothing about "stack."  Tail calls in C are still tail calls.
12:03:42 <Taejo> @pl \x -> (x, f x)
12:03:42 <lambdabot> ap (,) f
12:03:53 <Taejo> @type ap
12:03:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:03:57 <Myoma> Jedai: By what you said then nothing can ever cause a stack overflow in haskell, that is why the whole TCO/tail call stuff is not a useful thinking tool for lazyness
12:03:58 <Hanjin> dblazakis: If the base case would be split 0 s = (s,[])
12:04:13 <Jedai> ddarius: I didn't say it did, I say that in Haskell (in GHC exactly), such a function wouldn't directly create a stack overflow
12:04:19 <Hanjin> what would the next step be, +n ?
12:04:36 <Taejo> @where ap
12:04:36 <lambdabot> I know nothing about ap.
12:04:42 <Jedai> Myoma: I fail to see how you deduce that form what I said
12:04:47 <Myoma> Hanjin, you can write split n s = ... (n-1) ...
12:05:08 <Myoma> Jedai: I didn't, I have known this independently for some time
12:05:37 <wman> Taejo: ap :: (Monad m) => m (a -> b) -> m a -> m b         -- Defined in Control.Monad
12:05:47 <Taejo> oh, right
12:05:47 <Jedai> Myoma: No, I fail to see how you deduce that nothing can produce a stack overflow in Haskell from what I said
12:05:53 <Taejo> I am very stupid today
12:07:28 <Myoma> Jedai: I'm just picking on what you said for you used informal descriptions to the point that make what you say is ambiguous :p
12:08:13 <ketil> @seen bos
12:08:14 <lambdabot> I saw bos leaving #haskell and #ghc 16m 59s ago, and .
12:08:20 <ketil> hrmf
12:08:54 <mc__> Is there a decent haskell 2d engine? I already googled and looked on hackage. I could not find anything promising, am I  missing something?
12:09:15 <Baughn> mc__: Yes, OpenGL is a great 2D engine. ;)
12:09:28 <Jedai> Myoma: I don't think so, what I said is very clear : a "tail-recursive" function by your definition don't produce a stack overflow in GHC by filling the stack with calls to itself. It can produce one undirectly by producing a thunk that will blow the stack, but the first result is still true
12:09:35 <mc__> hehe, I meant something more high level :)
12:10:04 <Baughn> Not for "2d engine", no. YOu'll have to be more specific
12:10:06 <wman> if you are asjking for a game library, check fungen
12:10:06 <Myoma> Jedai: You should be able to see that by the same reasoning, nothing can directly cause a stack overflow
12:10:08 <Baughn> GUI toolkit?
12:10:18 <mc__> no more like 2d game engine
12:10:22 <wman> fungen
12:10:24 <Myoma> Jedai: I say that's a useless metric and we should use a different intuition
12:10:32 <mc__> something like this for haskell http://www.goldenstudios.or.id/products/GTGE/
12:10:34 <Myoma> Jedai: Don't you agree? :)
12:10:36 <lambdabot> Title: Golden T Studios - Golden T Game Engine (GTGE)
12:10:39 <Jedai> Myoma: A non-tail-recursive function can blow the stack directly
12:10:43 <mc__> @hoogle fungen
12:10:43 <lambdabot> No results found
12:10:56 <Myoma> Jedai: yes, I agree, tail recursive or not is irrelevant
12:11:35 <Myoma> Jedai: You can blow up the stack in both different ways in both types of function, the conclusion is simple..
12:11:35 <wman> it's not cabalized yet, but i'm working on it ;-)
12:11:58 <mc__> wman: I cant find anything about fungen
12:12:21 <Jedai> Myoma: The conclusion is that you need to take into account both lazyness and tail-recursion when writing your functions...
12:12:33 <wman> how about @google fungen? third result from top http://www.cin.ufpe.br/~haskell/fungen/
12:12:36 <lambdabot> Title: FunGEn - Andre W B Furtado - 2002
12:12:57 <Myoma> Jedai: How did you get there? I don't see any indication that tail recursion is relevant
12:14:20 <wman> mc__ : but don't expect much, MLGame  or CGL are much more polished, of course, no haskell in there :-(
12:14:55 <ddarius> Myoma: If you have accurate strictness information you can easily extend the notion of "tail recursive" to a notion that appropriately captures the operational semantics.
12:16:29 <mc__> are you the guy behind fungen wman ?
12:17:51 <wman> no, just some guy using it
12:19:11 <wman> i don't know whether ithere is anybody behind it, seemed untouched for a few years, recently just some kind soul ported it to ghc 6.8.2
12:20:30 <dmead> how would i remove newlines from a string?
12:20:43 <Myoma> dmead: unwords . lines
12:20:43 <mc__> I wish I could help that project
12:20:50 <dmead> ah
12:21:29 <wman> mc__ : well, that makes us 2 already ;-)
12:21:59 <mc__> but I'm just a beginner :/
12:22:18 <dmead> > unwords . lines $ "hello \n there"
12:22:19 <lambdabot>   "hello   there"
12:22:23 <wman> mc__ : when it comes to haskell & game development, so am I ;-)))
12:22:55 <mc__> but not when it comes to haskell I suppose
12:27:06 <wman> mc__: well, try it, if you'll like it, maybe you'll want to get your hands dirty after all. i stole some graphics from gnurobbo and am on my way to another clone ;-)
12:27:48 <mc__> wman: At first I'll work through the functional programming book I've purchased
12:28:15 <tomh_-_> which book
12:29:03 <wman> there are some glitches (weird event speed-ups under win32, flickering under linux, if that's not my crappy notebook) and the sound support needs an overhaul, so no chance of getting bored
12:30:02 <mc__> fungen could use sdl
12:30:13 <mc__> it would provide sound and input handling stuff
12:30:24 <mc__> even quite fast sofware 2d stuff
12:31:29 <wman> faster than GL ? i thought about that too, but it would probably be a total re-write ....
12:36:06 <Hanjin> dblazakis : split n s = split s++[x]  xs (n-1)
12:36:13 <Hanjin> something like that?
12:36:15 <mc__> No it is probably a lot slower than OpenGL *if* there is hardware acceleration
12:38:44 <wman> mc__: seems to me that even old intel810 chipset would suffice, where are you missing acceleration ?
12:39:39 <dblazakis> Hanjin: it seems you have too many arguments on the right side
12:39:40 <mc__> wman: for example on netbsd :) I used that about 2 years ago as my main os, it does not have any 3d drivers
12:40:02 <mc__> so OpenGL gets emulated with mesa, *very* slow
12:40:46 <wman> mc__ : oh, true, i keep forgeting that there are other alternative os-ses than win32 ;-)
12:41:09 <mc__> hehe
12:43:07 <wman> well, my haskell-fu isn't probably good enough for me to try to port it, so for now i'm going to use it as it is and when (if) i'll know it inside out, i might try it (or even better, someone else will need a PhD and will do it for me ;-)
12:43:54 <mc__> haskell-fu?
12:44:54 <wman> derivative of kung-fu ;-))
12:45:08 <haskellian> is there an assert statement in haskell like in ocaml?
12:46:12 <ptolomy2> After reading Bruce Eckel's mail to haskell-cafe, I onder: What is "shared-memory concurrency"? My existing definition doesn't hold it as mutually exclusive with 'message passing concurrency'..
12:46:12 <Saizan> ?hoogle assert
12:46:13 <lambdabot> Control.Exception assert :: Bool -> a -> a
12:46:13 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
12:46:13 <lambdabot> Test.HUnit.Base class Assertable t
12:47:09 <ptolomy2> Hm, on second examination, I'm being a bit silly.
12:47:24 <ddarius> ptolomy2: It's not mutually exclusive, but message passing doesn't require a shared memory abstraction at all.
12:47:47 <bd_> they're certainly not mutually exclusive; indeed you can implement either in terms of the other (implementing shared memory with message passing is likely to be inefficient however) :)
12:49:17 <wman> just stupid question : does shared memory in this context mean destructive-updates or not necessarilly ?
12:49:33 <ptolomy2> So by "shared-memory concurrency" does he mean "multiple threads can write to same memory space but must use some form of sychronization that isn't enforced by the type system or architecture"?
12:50:26 <dblazakis> Hanjin: it might help to try to rewrite 'drop' first
12:50:34 <dblazakis> > drop 2 [1..6]
12:50:36 <lambdabot>   [3,4,5,6]
12:50:39 <ptolomy2> wman: What context?
12:50:48 <ptolomy2> wman: My question, or the question on -cafe?
12:50:52 <ddarius> ptolomy2: He means it in the normal sense, but he seems to be misinformed about the concurrency mechanisms Haskell provides.
12:50:54 <Hanjin> dblazakis: yes maybe
12:51:22 <ddarius> wman: It necessarily means destructive updates otherwise whether it was shared or not would be irrelevant.
12:51:35 <ddarius> Well, as a concurrency mechanism.
12:52:03 <ddarius> If you don't have destructive updates you get essentially par and DPH.
12:53:09 <wman> ddarius: erlang (local node only) uses both, message passing & sharing memory to avoid copying
12:53:36 <Hanjin> > map length(words "haskell is a hassle")
12:53:37 <lambdabot>   [7,2,1,6]
12:53:39 <ddarius> wman: That's purely a performance aspect without mutation.
12:54:01 <wman> yeah, that's why i asked ;-)
12:54:14 <Hanjin> > [1....]
12:54:15 <lambdabot>   mueval: Prelude.read: no parse
12:54:22 <Hanjin> :)
12:56:10 <ddarius> wman: Basically, without mutation shared-memory concurrency leads only to parallelism not actual concurrency (i.e. non-determinism) and thus is completely trivial to use.
12:57:58 * ptolomy2 finds the assessment of message passing at http://clojure.org/state accurate.
12:58:00 <lambdabot> Title: Clojure » state
13:02:56 <wman> thx, i just wondered whether the term meant a "way of life" of just implementation detail
13:02:57 <wman> "way of life" of just implementation detail -> "way of life" or just implementation detail
13:08:49 <stepcut`> is there is a spiffier (and safer) way to right this, \f (x:xs) -> x : map f xs
13:09:40 <yitz> @pl \f (x:xs) -> x : map f xs
13:09:40 <lambdabot> (`ap` tail) . (. head) . flip ((.) . (:)) . map
13:10:25 <yitz> not so spiffy
13:10:40 <sjanssen> \f xs -> foldr (\x xs g -> g x : xs f) (const []) xs id
13:10:49 <ddarius> stepcut: What behaviour do you want when the list is []?
13:11:03 <stepcut> ddarius: [] = []
13:11:11 <ddarius> Yeah, I guess that was pretty obvious.
13:11:17 <sjanssen> @type \f xs -> foldr (\x xs g -> g x : xs f) (const []) xs id
13:11:18 <lambdabot> forall a. (a -> a) -> [a] -> [a]
13:11:41 <sjanssen> > (\f xs -> foldr (\x xs g -> g x : xs f) (const []) xs id) (+1) [1, 2, 3]
13:11:42 <lambdabot>   [1,3,4]
13:12:11 * stepcut decides to stick with the two-line version
13:13:11 <ddarius> > \f -> uncurry (++) . second (map f) . splitAt 1
13:13:12 <lambdabot>       Overlapping instances for Show ((b -> b) -> [b] -> [b])
13:13:12 <lambdabot>        arising ...
13:13:27 <ddarius> > (\f -> uncurry (++) . second (map f) . splitAt 1) (+1) [1,2,3]
13:13:28 <lambdabot>   mueval: Prelude.read: no parse
13:14:07 <ddarius> :t uncons
13:14:08 <lambdabot> Not in scope: `uncons'
13:14:11 <ddarius> @index uncons
13:14:12 <lambdabot> bzzt
13:14:14 <ddarius> @hoogle uncons
13:14:15 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
13:14:15 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
13:14:15 <lambdabot> Data.ByteString.Lazy uncons :: ByteString -> Maybe (Word8, ByteString)
13:14:35 <marcot> Good afternoon
13:14:39 <yitz> ddarius: that should work and it's nice
13:15:11 <Saizan> > second
13:15:12 <lambdabot>       Overlapping instances for Show (a b c -> a (d, b) (d, c))
13:15:12 <lambdabot>        arisin...
13:15:13 <marcot> Is there a library function that works like: f ',' "abc,def,ghi" = ["abc", "def", "ghi"] ?
13:15:22 <ddarius> marcot: Nope.
13:15:30 <ddarius> You could use the regex library to do it.
13:15:49 <marcot> ddarius: thanks, I think I'll just implement it myself.
13:15:53 <ddarius> Or you could still the source to unlines.
13:16:00 <ddarius> s/still/steal
13:16:02 <ddarius> @src unlines
13:16:03 <lambdabot> unlines = concatMap (++ "\n")
13:16:07 <ddarius> Er lines
13:16:09 <ddarius> @src lines
13:16:09 <lambdabot> Source not found. My brain just exploded
13:16:24 <yitz> @src words
13:16:24 <lambdabot> words s = case dropWhile isSpace s of
13:16:24 <lambdabot>     "" -> []
13:16:24 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
13:17:47 <wman> is there something like flip for multi-parameter functions ? some way to fix ie third parameter of four-parameter function, without goung for explicit lambdas ?
13:18:06 <wman> goung -> going ;-)
13:18:38 <yitz> @pl \f x y z -> f x z y
13:18:38 <lambdabot> (flip .)
13:18:51 <ddarius> wman: You could repeatedly use flip and (.) and id, but no, any naming scheme for such a beast would be less understandable than an explicit lambda.
13:18:52 <yitz> @pl \f x y z -> f y x z
13:18:52 <lambdabot> flip
13:19:03 <yitz> @pl \f x y z -> f y z x
13:19:03 <lambdabot> flip . (flip .)
13:19:13 <dblazakis> @pl \x y -> (x, y)
13:19:13 <lambdabot> (,)
13:19:42 <ddarius> yitz: All permutations of the arguments should be expressible using just B, C, and I.
13:19:59 <ddarius> @unpl (. flip)
13:20:00 <lambdabot> (\ d g -> d (\ b c -> g c b))
13:20:15 <yitz> ddarius: you need I?
13:20:44 <ddarius> yitz: I guess you could use flip flip for I.
13:21:09 <ddarius> Or what B(BC)C ?
13:21:16 <yitz> heh
13:21:21 <ddarius> @pl (flip .) . flip
13:21:22 <lambdabot> (flip .) . flip
13:21:35 <ddarius> @unpl (flip .) . flip
13:21:36 <lambdabot> (\ j m b c -> j c m b)
13:21:52 <haskellian> http://hpaste.org/10205
13:22:09 <haskellian> help please
13:22:14 <ddarius> Ah, it is just BCC
13:22:18 <yitz> @pl \f x y z w -> f y w z x
13:22:18 <lambdabot> flip . ((flip . (flip .) . flip) .)
13:22:19 <ddarius> @unpl flip . flip
13:22:19 <haskellian> on $! and where to put assert
13:22:19 <lambdabot> (\ i b c -> i b c)
13:23:14 <ddarius> Interesting choice of variable names...
13:23:40 <yitz> @unpl flip . flip
13:23:40 <lambdabot> (\ i b c -> i b c)
13:23:44 <yitz> @unpl flip . flip
13:23:45 <lambdabot> (\ i b c -> i b c)
13:23:53 <yitz> not randomized
13:30:15 <haskellian> http://hpaste.org/10205 please
13:31:56 <FunctorSalad> what's up with MonadPlus vs. Monoid? the stdlib seems to have neither of the possible conversions
13:32:37 <FunctorSalad> namely, "(MonadPlus m) => Monoid m a" and "(Monad m, Monoid a) => Monoid m a
13:32:39 <FunctorSalad> "
13:32:51 <FunctorSalad> the last "Monoid" should be "MonadPlus"
13:33:37 <sjanssen> FunctorSalad: both of those are overlapping instances
13:33:54 <dolio> They overlap with each other, even.
13:33:59 <FunctorSalad> :)
13:34:48 <FunctorSalad> as long as people don't create conflicting MonadPlus ans Monoid structures that should be ok
13:34:55 <FunctorSalad> *and
13:35:13 <dolio> You need a different kind of typeclass constraint solver, though.
13:35:19 <dolio> One that isn't described by the Haskell 98 report.
13:38:02 <sjanssen> FunctorSalad: there are already instances that overlap
13:38:23 <sjanssen> FunctorSalad: compare the list instance and the Maybe instance, for example
13:38:42 <dolio> Oh yeah. The Maybe instances for Monoid and MonadPlus don't correspond.
13:39:00 <dolio> [] is the same, I think.
13:39:34 <dolio> Although, it won't be the same as the (Monad m, Monoid a) => Monoid (m a) one, I suspect.
13:39:45 <olsner> would it be possible to make hoogle index hackage as well as the 'standard' libraries?
13:40:03 <yitz> > Nothing `mplus` Just ()
13:40:04 <lambdabot>   Just ()
13:40:08 <yitz> > Nothing `mappend` Just ()
13:40:10 <lambdabot>   Just ()
13:40:25 <dblazakis> @pl \f x -> f x
13:40:25 <lambdabot> id
13:40:35 <dolio> > Just 1 `mappend` Just 2
13:40:36 <lambdabot>   Add a type signature
13:40:41 <dolio> > Just 1 `mappend` Just 2 :: Maybe Int
13:40:42 <lambdabot>       No instance for (Monoid Int)
13:40:42 <lambdabot>        arising from a use of `mappend' at ...
13:40:48 <dolio> ...
13:41:01 <Baughn> @src mappend
13:41:01 <lambdabot> Source not found.
13:41:04 <Baughn> @type mappend
13:41:05 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:41:10 <dolio> > Just (Product 2) `mappend` Just (Product 3)
13:41:10 <yitz> > Just "a" `mappend` Just "b"
13:41:12 <lambdabot>   Just "ab"
13:41:12 <lambdabot>  Terminated
13:41:22 <dolio> There you go.
13:41:22 <yitz> > Just "a" `mplus` Just "b"
13:41:23 <lambdabot>   Just "a"
13:41:55 <Baughn> > Just [1] `mappend` Just [2..3] `mappend` Just [0]
13:41:56 <lambdabot>   Just [1,2,3,0]
13:42:08 <dolio> > liftM2 mplus ["ab"] ["bc"]
13:42:09 <lambdabot>   ["abbc"]
13:43:44 <newsham> ?info hello world
13:43:44 <lambdabot> hello world
13:43:46 <happu> hello
13:43:55 <newsham> ?info ?info ?info
13:43:56 <lambdabot> (? info ? info)
13:44:05 <dolio> ?info do hello ; world
13:44:06 <lambdabot> hello >> world
13:44:16 <newsham> ?info > 1 + 1
13:44:17 <lambdabot> (> 1 + 1)
13:44:51 <Baughn> ?info 1+1
13:44:51 <lambdabot> 1 + 1
13:45:21 <newsham> > Sum 3 `mappend` Sum 4
13:45:22 <lambdabot>   Sum {getSum = 7}
13:46:32 <Deewiant> > GT `mappend` LT
13:46:34 <lambdabot>   GT
13:46:39 <yitz> happu: hello
13:46:59 <Baughn> @src Ordering mappend
13:46:59 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:47:04 <newsham> > Sum (Maybe 3) `mappend` Sum (Maybe 4)
13:47:05 <lambdabot>   mueval: Prelude.read: no parse
13:47:06 <Baughn> @type GT
13:47:08 <lambdabot> Ordering
13:47:16 <newsham> > Sum (Just 3) `mappend` Sum (Just 4)
13:47:17 <lambdabot>       No instance for (Num (Maybe t))
13:47:17 <lambdabot>        arising from a use of `mappend' ...
13:47:30 <wman> > repeat "hello, world ;-)"
13:47:31 <lambdabot>   ["hello, world ;-)","hello, world ;-)","hello, world ;-)","hello, world ;-)...
13:47:33 <yitz> @@ @run say . unwords . replicate 3 "?info"
13:47:34 <lambdabot>   mueval: Prelude.read: no parse
13:47:37 <newsham> > Just (Sum 3) `mappend` Just (Sum 4)
13:47:38 <lambdabot>   Just (Sum {getSum = 7})
13:47:41 <yitz> @@ @run say . unwords . replicate 3 $ "?info"
13:47:42 <lambdabot>   mueval: Prelude.read: no parse
13:47:48 <Deewiant> > `EQ` mappend `LT`
13:47:49 <lambdabot>   mueval: Prelude.read: no parse
13:47:53 <Deewiant> oops, heh
13:47:58 <Deewiant> > EQ `mappend` LT
13:47:59 <lambdabot>   LT
13:48:01 <yitz> > say . unwords . replicate 3 $ "?info"
13:48:01 <lambdabot>   mueval: Prelude.read: no parse
13:48:12 <Baughn> > LT `mappend` EQ
13:48:14 <lambdabot>   LT
13:48:14 <yitz> > say "hi"
13:48:15 <lambdabot>   mueval: Prelude.read: no parse
13:48:18 <yitz> oh
13:49:33 <dolio> Does using functions not in scope cause a "no parse" error somehow?
13:49:52 <Baughn> Yep. Mueval is a bit.. broken.
13:49:56 <Baughn> Just about any error returns that
13:50:09 <yitz> > 1/0
13:50:11 <lambdabot>   Infinity
13:50:19 <yitz> > ``div`0
13:50:20 <lambdabot>   mueval: Prelude.read: no parse
13:50:24 <yitz> > 1`div`0
13:50:25 <lambdabot>   mueval: Prelude.read: no parse
13:50:25 <lambdabot>  mueval: *** Exception: divide by zero
13:50:46 <yitz> > undefined
13:50:47 <lambdabot>   mueval: Prelude.read: no parse
13:50:47 <lambdabot>  mueval: *** Exception: Prelude.undefined
13:50:52 <dolio> Oh, is it a bad parse on the error?
13:50:59 <dolio> That'd make sense.
13:51:00 <Baughn> Yep
13:51:10 <Baughn> No-parses really should be passed through
13:51:44 <yitz> Baughn: with a little thought to security though
13:52:03 <Baughn> yitz: Eh, what's the worst that can happen?
13:52:12 <Baughn> \bot doesn't read its own output
13:52:21 <yitz> Baughn: don't know. I haven't thought it through.
13:52:54 <yitz> Baughn: can you tease ghci into producing control chars in an error message?
13:53:11 <Baughn> yitz: Even if you could, it wouldn't matter
13:53:25 <yitz> Baughn: you could send IRC commands then
13:53:30 <Baughn> Well, okay. That's true
13:53:38 <Baughn> Um, pass it through show first?
13:54:02 <dolio> I doubt it prints unescaped control characters.
13:54:09 <yitz> Baughn: or just strip control chars. and make sure to preface every line with an extra space.
13:54:11 <dolio> Since you can't really see them well.
13:54:26 <Baughn> yitz: Why a space?
13:54:32 <Baughn> Oh, commands like /quit?
13:54:33 <wman> i finished cabalizing fungen, is there some checklist i should go through, or is the hackage "package checking" web-form enough ?
13:54:45 <Baughn> Those only work for IRC client users, it's not part of the irc protocol or anything
13:54:47 <yitz> Baughn: ok, yeah, and to avoid bot loops
13:55:04 <haskellian> is this the right way to handle exceptions in haskell? http://hpaste.org/10206
13:55:19 <Baughn> yitz: Don't worry. As the spec requests, LB uses notices, not privmsgs, so it's ignored by any bots
13:55:24 <Baughn> Oh, wait...
13:55:24 <yitz> > @pl preflex zdec bwahaha
13:55:25 <lambdabot>   mueval: Prelude.read: no parse
13:55:35 <haskellian> and how can i make fibo strict? i have to add $! right? but how?
13:56:08 <yitz> > @pl let preflex zdec bwahaha = ()
13:56:09 <lambdabot>   mueval: Prelude.read: no parse
13:56:34 <yitz> > @pl preflex list
13:56:35 <lambdabot>   mueval: Prelude.read: no parse
13:56:56 <ptolomy2> Guh. I've been unsuccessful in trying to get a profiling version of Data.Bytestring working with cabal.
13:57:25 <dcoutts> ptolomy2: cabal install bytestring -p --reinstall
13:58:06 <yitz> @pl preflex zdec bwahaha
13:58:07 <lambdabot> preflex zdec bwahaha
13:58:07 <preflex>  bwahaha
13:58:12 <yitz> there we go
13:58:39 * ddarius was wondering how long that would take.
13:58:45 <dcoutts> ptolomy2: if your cabal-install doesn't have --reinstall then either upgrade cabal-install or unregister bytestring first
13:58:46 <yitz> sorry about that
13:58:49 <bos> dons: is hackage horked again?
13:58:57 <ptolomy2> dcoutts: Option not recognized, I'm guessing because it says I'm using the cabal library 1.4.0.1
13:59:20 * glguy is able to load hackage
13:59:21 <ptolomy2> because my cabal-install is 0.5.1
13:59:30 <glguy> so it at least works from the local network :)
13:59:32 <ptolomy2> hackage is really slow.
13:59:48 <dcoutts> ptolomy2: right, so either cabal install cabal-install, or use the old workaround ghc-pkg unregister --user bytestring
13:59:51 <dblazakis> @pl \f -> ((.) (map f) snd)
13:59:52 <lambdabot> (. snd) . map
14:00:03 <haskellian> http://hpaste.org/10206
14:00:04 <haskellian> come on, someone
14:00:05 <ptolomy2> ahh..
14:00:09 <yitz> ptolomy2: that's because bos just slashdotted it by mentioning it here
14:00:09 <ptolomy2> Now I'm making process.
14:00:11 <ptolomy2> "progress".
14:00:15 <ptolomy2> Thanks. :)
14:00:18 <haskellian> right wauy to do exceptions? how to make it tailrec?
14:01:17 <dcoutts> bos: seems ok to me, if a little slow
14:01:37 <ptolomy2> haskellian: What are you trying to accomplish with that code again?
14:01:40 <Twey> :t intercalate
14:01:41 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:02:05 <Twey> > intercalate "," ["foo", "bar", "baz"]
14:02:06 <lambdabot>   "foo,bar,baz"
14:02:20 <bos> it's getting blackholed at galois's router.
14:02:49 <bos> ah, back a little.
14:02:56 <glguy> The router problem is being investigated already
14:03:17 <yitz> haskellian: the problem is not the exception, it's the a+b
14:07:53 <haskellian> ptol, yitz: well fibonacci and handle exceptions correctly plus making it proper tailrecursive
14:08:05 <haskellian> ccurs check: cannot construct the infinite type:
14:08:46 <haskellian> if i add $!: fibo $! (a+b) a (n-1)
14:10:12 <dblazakis> @pl \(a,b)->(a:b)
14:10:12 <lambdabot> uncurry (:)
14:10:28 <yitz> yes, except $! doesn't associate properly for you there.
14:11:09 <yitz> let ab = a + b in ab `seq` fibo ab a (n-1)
14:12:14 <yitz> haskellian: you proabably don't need that for fibo, because fibo grows so fast that you won't recurse it enough times to get the stack overflow
14:12:23 <yitz> but that's the idea
14:12:47 <yitz> haskellian: tail recursive is usually not so important in haskell.
14:13:17 <haskellian> what do you mean? ill never use fib for n >= 1million?
14:13:30 <yitz> haskellian: right, something like that
14:13:31 <haskellian> seq = $! ?
14:13:41 <yitz> @src ($!)
14:13:41 <lambdabot> f $! x = x `seq` f x
14:14:11 <yitz> seq is the primitive, $! is built on that
14:14:18 <bd_> haskellian: usually haskell functions build up data structures, and you'll only evaluate it partially to get part of the data structure
14:15:43 <dblazakis> @pl curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:))
14:15:43 <lambdabot> curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry id >>> uncurry (:))
14:17:04 <lilac> @unpl curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry id >>> uncurry (:))
14:17:04 <lambdabot> curry ((\ e -> ((\ h k -> ((map *** head) &&& tail) h (snd k)) >>> fst) ((snd &&& (uncurry (\ b -> b))) e)) >>> (uncurry (:)))
14:17:53 <yitz> @type curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:))
14:17:53 <lambdabot> forall b. (b -> b) -> [b] -> [b]
14:17:55 <dblazakis> > curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:)) (+5) [1..10]
14:17:56 <lambdabot>       precedence parsing error
14:17:57 <lambdabot>          cannot mix `(.)' [infixr 9] and `(***...
14:18:03 <dblazakis> > curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:)) (+ 5) [1..10]
14:18:04 <lambdabot>       precedence parsing error
14:18:04 <lambdabot>          cannot mix `(.)' [infixr 9] and `(***...
14:18:25 <lilac> @type curry ((\ e -> ((\ h k -> ((map *** head) &&& tail) h (snd k)) >>> fst) ((snd &&& (uncurry (\ b -> b))) e)) >>> (uncurry (:)))
14:18:26 <lambdabot>     Couldn't match expected type `(a -> b, [a1])'
14:18:27 <lambdabot>            against inferred type `[a2]'
14:18:27 <lambdabot>       Expected type: (a -> b, [a1]) -> c'
14:18:33 <lilac> thanks, @unpl :)
14:18:37 <haskellian> but is the use of exceptions correct?
14:18:37 <haskellian> is it idiomatic to throw exceptions like that? or should i somehow try to generate a pattern match failure?
14:18:48 <yitz> (curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:))) (+5) [1..10]
14:18:52 <yitz> > (curry ((. snd) . map *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:))) (+5) [1..10]
14:18:53 <lambdabot>       precedence parsing error
14:18:53 <lambdabot>          cannot mix `(.)' [infixr 9] and `(***...
14:19:30 <dblazakis> > curry (((. snd) . map) *** head &&& tail >>> fst . snd &&& uncurry ($) >>> uncurry (:)) (+ 5) [1..10]
14:19:31 <lambdabot>       precedence parsing error
14:19:31 <lambdabot>          cannot mix `(>>>)' [infixl 9] and `(....
14:19:42 <dblazakis> > curry (((. snd) . map) *** head &&& tail >>> (fst . snd) &&& uncurry ($) >>> uncurry (:)) (+ 5) [1..10]
14:19:43 <lambdabot>   mueval: Prelude.read: no parse
14:20:06 <sjanssen> haskellian: actually, I'd change the type of your function
14:20:17 <sjanssen> haskellian: give fibt the type Word -> Integer
14:20:30 <yitz> haskellian: if you are worried about negative input, use fibo :: Integer -> Maybe Integer
14:20:44 <haskellian> lila pls
14:20:44 <haskellian> is it idiomatic to throw exceptions like that? or should i somehow try to generate a pattern match failure?
14:20:49 <yitz> or fibo :: Integer -> Either String Integer
14:21:03 <sjanssen> haskellian: the most idiomatic thing is to make the failure impossible
14:21:14 <ptolomy2> The approach taken on the updated hpaste seems fine to me.
14:21:18 <sjanssen> haskellian: so use Word, which doesn't contain negative numbers
14:21:24 <ptolomy2> though, perhaps it should be limited to MonadError
14:21:24 <olsner> can I put a parser in IO using ParsecT? how would I run IO actions in the parser in that case?
14:21:49 <olsner> oh, never mind, I found the MonadIO instance now :P
14:22:06 <sjanssen> glguy: have you considered making title/author required on hpaste?
14:22:32 <thelsdj> why not write a fib that does work for negative numbers? :)
14:23:03 <yitz> ptolomy2: not to me. that can crash your program if you unsuspectingly use the wrong monad
14:23:29 <thelsdj> while you're at it, also make it work for rational numbers
14:23:53 <yitz> thelsdj: any Num instance
14:24:09 <ptolomy2> yitz: Do you know if there are plans to resolve that for the standard libraries?
14:24:15 <Apocalisp> What is subtyping, in terms of categories?
14:24:25 <olsner> hmm, how does ParsecT and monadic actions interact with try?
14:24:32 <ptolomy2> like for Data.Map etc, which use MOnad?
14:24:39 <yitz> ptolomy2: no, "fail" as a Monad method is Haskell 98.
14:24:43 <thelsdj> http://mathworld.wolfram.com/images/eps-gif/Fibonacci_1000.gif
14:24:54 <ptolomy2> ah.
14:24:57 <ptolomy2> Shame, that.
14:25:00 <ptolomy2> idiomatic, but wrong.
14:25:00 <yitz> ptolomy2: ah, yeah, that's been proposed. I hope it goes through.
14:27:28 <nominolo> > b001
14:27:29 <lambdabot>   mueval: Prelude.read: no parse
14:27:39 <nominolo> > 0b011
14:27:39 <lambdabot>   mueval: Prelude.read: no parse
14:27:55 * Saizan likes his foldrM :: Monad m => (a -> m b -> m b) -> b -> [a] -> m b
14:28:31 <haskellian> sjanssen: word?
14:28:34 <Jaak_> @type foldM
14:28:35 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:28:42 <sjanssen> @docs Data.Word
14:28:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
14:28:48 <dolio> That's just \f -> foldr f . return
14:28:50 <sjanssen> haskellian: see what the fine manual has to say
14:29:56 <haskellian> is there a way to nest functions so that the inner one is hidden?
14:29:56 <haskellian> can i hide functions from being exported?
14:31:13 <glguy> sjanssen: I had them set as such at one point, and in testing people just put garbage in them
14:31:33 <glguy> sjanssen: so I figured if someone doesn't want to specify, it would be easier to detect that when it was blank
14:31:42 <glguy> sjanssen: for the sake of putting in a placeholder
14:32:18 <Saizan> dolio: right!
14:32:27 <sjanssen> glguy: yeah, I suppose
14:32:34 <Jaak_> > foldl (\n c -> 2*n + digitToInt c) 0 "100010"
14:32:35 <lambdabot>   34
14:33:01 <sjanssen> glguy: perhaps it should fail if the username isn't a valid #haskell nick :)
14:33:12 <sjanssen> glguy: also, is "remember me" supposed to work?
14:33:26 * ddarius laughs
14:33:42 <dolio> Saizan: Why give that another name, though? Does it save you from typing 'return' that much?
14:34:25 <thelsdj> haskellian: i believe you can nest functions using let or where
14:34:34 <Saizan> dolio: i actually have whileM :: (Monad m) => a -> [t] -> (t -> m a -> m a) -> m a which is nicer for parentheses
14:34:37 <glguy> sjanssen: sorear turned it off at some point
14:34:43 <glguy> sjanssen: There was a valid reason at the time I remember
14:34:46 <dolio> (Not saying that you don't frequently want foldr instead of the foldM types.)
14:34:59 <haskellian> http://hpaste.org/10207
14:35:20 <abuiles> Hello..  someocan can explainme why whit: fromInteger, doesnt work with length
14:35:33 <abuiles> of a Int List
14:35:36 <lilac> @pl \f (x:xs) -> x:map f xs
14:35:36 <lambdabot> (`ap` tail) . (. head) . flip ((.) . (:)) . map
14:36:49 <ptolomy2> abuiles: Could you give a link to a paste of the code?
14:36:55 <Jaak> @type \f -> zipWith ($) (id : repeat f)
14:36:56 <lambdabot> forall a. (a -> a) -> [a] -> [a]
14:37:01 <Jaak> @pl \f -> zipWith ($) (id : repeat f)
14:37:01 <lambdabot> zipWith id . (id :) . repeat
14:37:12 <ddarius> ptolomy2: You really need that?
14:37:19 <ddarius> Integer /= Int that is why it does not work.
14:37:41 <ddarius> You want fromIntegral.
14:37:43 <ptolomy2> I just didn't understand the question. I'm glad I was the only one. :)
14:37:48 <Jaak> (zipWith id . (id :) . repeat) (+1) (replicate 10 1)
14:37:49 <Jaak> > (zipWith id . (id :) . repeat) (+1) (replicate 10 1)
14:37:50 <lambdabot>   [1,2,2,2,2,2,2,2,2,2]
14:37:54 <ddarius> Alternatively, you can use genericLength
14:38:03 <abuiles> sure..
14:38:15 <abuiles> 2 secnds
14:39:30 * ptolomy2 wasn't aware that fromInteger existed.. has always used fromIntegral.
14:39:52 <abuiles> ptolomy2: http://hpaste.org/10208
14:40:03 <ddarius> ptolomy2: You should always use fromIntegral.  fromInteger is more an implementation artifact for desugaring numeric literals.
14:40:03 <dolio> fromIntegral = fromInteger . toInteger
14:40:32 <abuiles> works!
14:40:37 <abuiles> thanks
14:41:02 <dblazakis> > id *** head &&& tail $ ("wee", [1..5])
14:41:03 <lambdabot>   mueval: Prelude.read: no parse
14:41:25 <dblazakis> :t head &&& tail
14:41:26 <lambdabot> forall a. [a] -> (a, [a])
14:41:28 <abuiles> ddarious : thanks
14:41:41 <olsner> :ty ifM
14:43:39 <abuiles> ddarious: If I want to do the definition, but I don't know what the fuction give me, and I don't want to use just "a",, there is a kind of Number tipe?
14:44:47 <ddarius> abuiles: Ask what the type of your function is in GHCi.
14:45:12 <abuiles> ddarious: I can get double, or Integer as well.
14:45:13 <Botje> abuiles: closest you can get is Num a => (your type here)
14:45:31 <Botje> that says "only accept numbers where you see an a in the type"
14:46:18 <abuiles> Botje : but if the type is not define, I mean is not always the same
14:48:33 <Botje> abuiles: yes. that's okay.
14:48:42 <FunctorSalad_> how would I go about noticing whether the user is idle? selecting all x11 mouse events and keyboard events seems a bit inefficient
14:49:07 <Botje> :t let f x = x + 1 in f
14:49:08 <lambdabot> forall a. (Num a) => a -> a
14:49:11 <Botje> abuiles: see that type?
14:49:12 <FunctorSalad_> I could register a timer, but then the events will pile up in the queue, no?
14:49:33 <Botje> :t let f x = x + 1 in f in (f 1 :: Int, f 1 :: Double, f 1 :: Integer)
14:49:34 <lambdabot> parse error on input `in'
14:49:42 <Botje> :t let f x = x + 1 in  (f 1 :: Int, f 1 :: Double, f 1 :: Integer)
14:49:43 <lambdabot> (Int, Double, Integer)
14:49:47 <Botje> see? no type error
14:50:54 <ddarius> instance Num Bool where (+) = (||); negate = not; (*) = (&&); fromInteger = odd; hasEvenLength = genericLength
14:51:25 <abuiles> Botje: Im going to study your example, still is hard to asimilate to me .. hehe :)
14:51:29 <abuiles> Just a noob
14:51:33 <Botje> abuiles: that's okay.
14:51:33 <lilac> fromInteger = odd? eww. Bool != Z2
14:51:33 <abuiles> in haskell
14:51:39 <ddarius> Crap.  s/Even/Odd
14:51:51 <Botje> 23:49 < lambdabot> forall a. (Num a) => a -> a
14:51:55 <abuiles> Botje: Thanks my8
14:52:12 <Botje> that means "this is a function from a type we'll call a, to the same type. a must be a member of the Num typeclass"
14:52:30 <Botje> and the Num typeclass contains all types that behave like numbers
14:53:19 <abuiles> and,, that's what i was thinking on..
14:53:35 <abuiles> thanks..
14:54:28 <ddarius> lilac: You're right.  My definition of (+) is wrong
14:54:43 <Botje> if you do :info Num in hugs / ghc
14:54:50 <Botje> you'll all currently declared members of that typeclass
14:54:53 <ddarius> (+) = (/=)
14:56:45 <BMeph_> ddarius: Eh? False + False == True?
14:56:53 <ddarius> BMeph_: Yes.
14:57:02 <Botje> two wrongs _DO_ make a right :)
14:57:24 <BMeph_> Er, NM,  ... == False. Yeah, that works.
14:57:44 <ddarius> No, it does equal True with the latter definition.
14:58:13 <ddarius> Crap
14:58:13 <amitprakash> type term =  (Int,Int) .. is this wrong?
14:58:15 <BMeph_> ddarius: what's "hasEvenLength," and where's it used? :)
14:58:19 <dolio> > False /= False
14:58:20 <lambdabot>   False
14:58:22 <ddarius> (==)
14:58:25 <thelsdj> does Num a => a -> a mean that both a's are always the same Num instance?
14:58:36 <ddarius> Stupid involutions.
14:58:49 <geezusfreeek> amitprakash: type Term = (Int, Int)
14:58:59 <geezusfreeek> the "t" in "term" should be capital
14:59:17 <ddarius> That does fix the problem I was having with negate.
14:59:19 <amitprakash> geezusfreeek, so all defined types begin with caps?
14:59:25 <BMeph_> thelsdj: Of course! :)
14:59:48 <geezusfreeek> amitprakash: yes
15:00:07 <geezusfreeek> amitprakash: but to be clear, with the "type" keyword, you are not defining a new type, just a new name for a type
15:00:17 <Huschi> is there any library for writing png images with haskell? i found none on hackage.
15:00:29 <geezusfreeek> so Term is actually the same thing as (Int, Int), and typechecks as such
15:00:53 <geezusfreeek> Huschi: gd would be one, i believe
15:00:57 <amitprakash> geezusfreeek, ah ok
15:01:29 <ddarius> Huschi: SDL_image can likely do it.  The GUI frameworks have such functions as well.
15:01:40 <Huschi> geezusfreeek: i will look at it.
15:01:49 <Huschi> ddarius: that seems to be overkill.
15:01:56 <ddarius> Huschi: Indeed.
15:02:18 <geezusfreeek> Huschi: yeah i was right, gd will do pngs, and is pretty easy to use. it is likely that hsmagick does too
15:02:28 <BMeph_> ddarius: True is the zero? Heh-heh, that should *seriously* mess up the C-ophytes' heads. ;)
15:02:30 <geezusfreeek> and a few others
15:02:57 <geezusfreeek> BMeph_: not too much, since a lot of the standard C functions return 0 for "no error"
15:03:12 <ddarius> BMeph_: True is not the zero with my latest definition.
15:03:23 <ddarius> My earlier definitions were simply inconsistent.
15:03:34 <BMeph_> ddarius: Which "latest" defn? ;)
15:03:35 <mmorrow> fromInteger = (/=0)
15:03:44 <ddarius> However, if you changed fromInteger from odd to (/=0) you get another consistent definition.
15:03:58 <mmorrow> :)
15:04:01 <ddarius> instance Num Bool where (+) = (==); negate = not; (*) = (&&); fromInteger = odd
15:04:08 <Huschi> oops, i've closed xchat accidently. where there any more answers for me?
15:04:30 <geezusfreeek> Huschi: i had mentioned hsmagick as a possibility
15:04:39 <Huschi> geezusfreeek. ok thx.
15:05:31 <ddarius> instance Num Bool where (+) = (||); negate = not; (*) = (&&); fromInteger = (0/=) -- alternatively
15:05:48 <Huschi> what about HGL? does this work to?
15:06:04 <amitprakash> http://rafb.net/p/RrGMVi87.html gives me a Syntax error in expression (unexpected `}') when loading it in hugs.. but i think i am closing all braces
15:06:09 <lambdabot> Title: Nopaste - assign.hs
15:07:14 <BMeph_> ddarius: How does your latest defn work? Doesn't that give (fromInteger 0) + (fromInteger 0) /= (fromInteger 0)?
15:07:37 <ddarius> False || False == False
15:08:00 <ddarius> Oh the other one.
15:08:15 <mmorrow> having fromInteger = odd though doesn't give you compatibility with (+) though
15:08:20 <amitprakash> geezusfreeek, any ideas?
15:08:22 <ddarius> mmorrow: Indeed.
15:09:56 <olsner> parsec fail? unexpected "i" or "\n". expecting space, new-line, end of input, "#", "-" or "include"
15:10:16 <geezusfreeek> amitprakash: your last line makes no sense to me, and likely doesn't to the parser either
15:10:33 <geezusfreeek> this: "multipoly ((a,b):xs) ys | addpoly (multip (a,b) ys) (multipoly xs ys)"
15:10:57 <olsner> shouldn't that '|' be a '='?
15:11:03 <geezusfreeek> did you mean to use '=' instead of '|'?
15:11:05 <amitprakash> olsner, oh yes
15:11:32 <amitprakash> olsner, geezusfreeek thanks a lot.. i have understandable errors now :D
15:11:39 <geezusfreeek> good
15:11:40 <olsner> (no useful hints from anyone on my parsec problem btw?)
15:13:39 <ddarius> Wait I was right with (/=), BMeph_ was just trying to confuse me.
15:14:00 <BMeph_> ddarius: Heh, heh, heh. ;)
15:15:06 <ddarius> negate really is id though
15:15:33 <BMeph_> amitprakash: I think you want your second line of multip to start, "multip (a,b) (c,d):ys = ..."
15:16:15 <BMeph_> ddarius: That stmt, I'll accept. :)
15:16:42 <amitprakash> BMeph_, yea.. changed that
15:16:49 <ddarius> instance Num Bool where (+) = (/=); negate = id; (*) = (&&); fromInteger = odd -- final
15:17:49 <amitprakash> BMeph_, http://rafb.net/p/SDHq1m58.html
15:17:50 <lambdabot> Title: Nopaste - No description
15:17:51 <ddarius> The alternative instance isn't properly an instance because it doesn't form an additive group.
15:17:59 <amitprakash> BMeph_, am i declaring the lists wrongly?
15:20:41 <ac> bah. I spent a couple hours optimizing my cairo graphics code to draw foreground and background separately, and it still wasn't fast enough
15:20:55 <ac> but changing the antialiasing mode makes the original version plenty fast enough
15:21:42 <ac> should've tried that first
15:21:46 <amitprakash> BMeph_, nm.. figured it out
15:27:20 <mmorrow> ddarius: yeah, BMeph_ fooled me too ;)
15:30:56 <mmorrow> it's a weird case case though, because it doesn't even form an additive group.
15:33:12 <FunctorSalad_> fromInteger = odd?
15:33:47 <FunctorSalad_> oh for booleans, nvm
15:35:35 <mmorrow> (no additive group regardless of the map from Integer)
15:36:37 <FunctorSalad_> it works if you take (+) = xor though
15:36:45 <mmorrow> but that's Z_2 :)
15:36:52 <FunctorSalad_> yes ;)
15:38:26 <ddarius> But Z_2 is a field
15:38:44 <mmorrow> which means it must also be a ring
15:39:30 <guenni> mmorrow: hi
15:39:49 <mmorrow> guenni: hi, how's life?
15:39:59 <guenni> mmorrow: about that parsing problem, I managed, finally
15:40:14 <mmorrow> guenni: nice. what'd you end up doing?
15:40:27 <guenni> mmorrow: using parsec, getInput setInput etc.
15:40:48 <guenni> mmorrow: still a bit clumsy but it works
15:41:12 <mmorrow> cool. so were you doing something like getInput, chop some off, put back the rest, repeat ?
15:41:22 <guenni> mmorrow: and it did save code
15:41:26 <guenni> mmorrow: yes
15:41:46 <mmorrow> less code's always a win
15:41:50 <guenni> and getPosition and setPosition
15:41:50 <BMeph_> So, what was the original topic? :)
15:43:18 <mmorrow> guenni: yeah, for csvs/similar online parsing is totally a must..simple local, regular structure, and usually a shitload of it :)
15:43:52 <guenni> mmorrow: it took days, what a pain that was
15:43:58 <mmorrow> ha
15:44:18 <BMeph_> ddarius, mmorrow: So, what was the original topic? :)
15:45:17 <guenni> mmorrow: now I have to fiddle with Generic Haskell, another couple of days will go by until I get that
15:45:19 <mmorrow> err, about mapping Integer -> Bool
15:46:35 <guenni> mmorrow: haskell sure has one steep learning curve
15:46:38 <ddarius> BMeph_: I was thinking of things to do with genericLength.
15:46:44 <mmorrow> guenni: cool. i've used it some (Data.Generics?). this is a nice one
15:47:04 <mmorrow> > everywhere (mkT (+1)) ((0,(0,0)),0)
15:47:06 <lambdabot>   mueval: Prelude.read: no parse
15:47:09 <guenni> mmorrow: well I do suppose it's worth the effort
15:47:09 <mmorrow> wont work here
15:47:45 <guenni> mmorrow: do you know a good paper, guide to get started?
15:48:13 <mmorrow> guenni: totally. and progress is exponential in terms of what you can do with the haskell tools (eg csv parser/etc) you've built along the way, because they compose so nicely.
15:48:26 <mmorrow> guenni: on Data.Generics stuff?
15:48:33 <guenni> mmorrow: yes
15:48:56 <mmorrow> hmm. not off the top of my head, but i know a bunch of good template-haskell papers.
15:49:00 <BMeph_> @src succ
15:49:00 <lambdabot> Source not found. :(
15:49:09 <BMeph_> o.O
15:49:17 <guenni> mmorrow: is that related?
15:49:33 <mmorrow> guenni: mostly i learned the bit i know from messing around in ghci with the haddock docs open...
15:49:36 <BMeph_> ddarius: Hm, well that makes sense.
15:50:17 <Saizan> there's always the Scrap Your Boilerplate paper
15:50:52 <mmorrow> guenni: somewhat related, although different. template-haskell runs at compile time, and you essentially build programs/code with it, whereas Generics is a class Data, which allows you to traverse/fold/etc types which are made instances of it (and this is at runtime)
15:51:14 <guenni> yep, and it seems there's 3 successive versions, but which one is the one that is up to date with what's acutally used in Haskell these days?
15:51:57 <Saizan> SYB3 is syb-with-class
15:52:01 <Saizan> iirc
15:52:25 <guenni> Saizan: thx, I'll skip the others then
15:53:24 <guenni> the books that got me started with haskell are all pre yr 2000 and thus Generics were never mentioned
15:54:04 <olsner> hmm, under which circumstances does printf simply fail with "Prelude.undefined"?
15:54:25 <mmorrow> guenni: i've mostly used Data class functions + everywhere and listify. other than that, not much. it seems that template-haskell and Generics overlap on the deriving-instances/manipulating-code-as-data aspect, and i usually use template-haskell for that.
15:54:48 <guenni> mmorrow: k
15:55:43 <olsner> oh, printf returns undefined ... and apprently liftIO in parsec, or some other part of parsec, evaluates the return value
16:05:35 <mmorrow> guenni: here's some misc stuff with Generics (mostly the typereps): http://hpaste.org/10210
16:06:15 <guenni> mmorrow: thx
16:06:18 <BMeph_> mmorrow: Just wondering, but have you ever dabbled in/with attribute grammars?
16:07:00 <mmorrow> BMeph_: no, but i've read a snippet here and there about them and they seem interesting/useful.
16:07:04 <mmorrow> why?
16:09:05 <mmorrow> i got this book recently about parsing, and it's pretty comprehensive/exhaustive. i'll find it on amazon..
16:09:40 <mmorrow> and the second edition just came out this year
16:10:11 <mmorrow> nice, it's got 5 stars on amazon
16:10:12 <mmorrow> http://www.amazon.com/Parsing-Techniques-Practical-Monographs-Computer/dp/038720248X/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1220915387&sr=8-1
16:10:15 <lambdabot> http://tinyurl.com/5vxeye
16:12:57 <andrewsw-afk> /window balance
16:13:30 <andrewsw-afk> oops
16:19:46 <jberryman> I've been working on a Turing Machine program and trying to figure out if it would be a good application for monads. I'm pretty new to that concept and having trouble fitting this problem to what I understand about programming w/ monads. any ideas?
16:22:41 <BMeph_> mmorrow: Why AGs? Well, I just got started looking at them, and they seem to buttress the expressiveness of Haskell from yet another complementary angle, as do Generics, and TH.
16:22:59 <ddarius> jberryman: You could use a state monad with a zipper as the state.
16:23:24 <dmwit> A comonad might fit this application even better.
16:23:39 <ddarius> BMeph_: One has to have some reason to use backward state monads.
16:23:53 <hackage> Uploaded to hackage: graphmod 1.1
16:25:35 <Saizan> ?hackage graphmod
16:25:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphmod
16:26:45 <humasect> oh, and there it is!=)
16:27:32 <dmwit> humasect: Is that your package?
16:27:51 <humasect> i think it is dcoutts's, what he was finishing up today
16:27:51 <jberryman> ddarius & dmwit: thanks I'll do some googling
16:27:54 <dmwit> I guess not.
16:28:09 <haskellian> hmm i just realized something, haskell is intendation sensitive. not in a way that matter though, ob youd never put 2 functiond ef son the same row
16:28:38 <EvilTerran> haskellian, it's nice when people find the indentation rules non-intrusive for a change :)
16:28:40 <dmwit> humasect: It says it's by "Iavor Diatchki."
16:28:48 <humasect> ah .. dotgen is another one-hs-file "package"
16:28:56 <Pseudonym> There's really only one situation where the offside rule gets people.
16:29:11 <Pseudonym> And that's using multi-line expressions in do-notation.
16:29:20 <Pseudonym> And usually it's only the ones that involve if-then-else.
16:29:33 <ddarius> That's people failing to get the offside rule.
16:29:54 <Saizan> that's haskell-mode failing at indentation
16:29:57 <Pseudonym> That's the only place where the offside rule seems to break intuition.
16:30:21 <Pseudonym> However, there is an arbitrary decision that's been made about that in the offside rule.
16:30:38 <Pseudonym> So there's a possibility that tweaking the rule would make it fully intuition-compliant.
16:31:07 * Pseudonym believes there's a Haskell' ticket for it
16:31:20 <humasect> so what do bang patters *do* ?
16:31:20 <dmwit> There is.
16:31:31 <dmwit> humasect: They are a strictness annotation.
16:31:52 <humasect> that is what they are, indeed; but what do they do? ie. how does a def with no bangs differ from one with bangs?
16:31:55 <haskellian> oh right do-notation too
16:31:57 <ddarius> Pseudonym: People need to fix their intuition.  The rule is right.
16:32:05 * Pseudonym laughs
16:32:05 <haskellian> but as said, it is not intrusive, got me the first time but then fine
16:32:08 <dmwit> humasect: You mean in data definitions or in function definitions?
16:32:12 <dolio> They essentially insert seqs for you.
16:32:19 <dolio> Although I haven't read how they're defined, exactly.
16:32:24 <humasect> dmwit: do they act differently for each?
16:32:31 <Pseudonym> To be fair, it's something you're only ever bitten by once.
16:32:31 <dmwit> humasect: Kind of, yes.
16:32:37 <humasect> ah, that is a nice clear expression, thanks dolio
16:33:14 <dmwit> f !x = y --> f x = x `seq` y  (approximately)
16:33:15 <dolio> The ones in data definitions definitely have the effect of inserting seqs (I think that's how they're defined).
16:33:22 <humasect> the ghc docs can use some clear facts like this. "i can annotate my code with strictness.." aside from assuming a bang expression is forced eval at the spot of the bang, there is more going on
16:33:41 <humasect> dmwit: ah, hm..
16:33:57 <dmwit> data Foo = Bar !a; case x of Bar a -> y --> data Foo = Bar a; case x of Bar a -> a `seq` y  (again, approximately)
16:34:04 <dolio> 'data Foo = Bar !Baz' makes Bar x = x `seq` RealBar
16:34:04 <mmorrow> <BMeph_> mmorrow: Why AGs? Well, I just got started looking at them, and they seem to buttress the expressiveness of Haskell from yet another complementary angle, as do Generics, and TH.
16:34:25 <TomMD> humasect: bang patterns are critical for some innerloops.  pureMD5, for example, relys on them heavily.
16:34:25 <dolio> RealBar x, even.
16:34:33 <humasect> ahhh
16:34:39 <mmorrow> interesting. how so? related to haskell's excellence at pattern matching/tree manipulation/etc?
16:35:04 <humasect> x `seq` RealBar x  <-- like monads for pure code..
16:35:34 <mmorrow> that's actually how i kind of think about it
16:35:58 <humasect> mmorrow: graphmod is yours? how do i use it, it is not traversing imports ?
16:36:02 <mmorrow> essentially seq is just (>>)
16:36:07 <humasect> yeah..
16:36:34 <mmorrow> humasect: no, graphmod isn't mine. i actually just saw that too. haven't looked at the code yet though. it looks nice!
16:36:38 <dolio> seq is 'flip const' with magic. :)
16:36:47 <Saizan> except that >> is not required to force the LHS :)
16:36:49 <mmorrow> heh
16:37:02 <mmorrow> yeah, a very rough analogy
16:37:26 <EvilTerran> you could have a seq monad
16:37:27 <ac> is there an easy way to turn a function that takes a record member and returns a new one in to a function that takes a record and returns a new record?
16:37:39 <humasect> mmorrow: heh, i see; it depends on a one-hs-file "package" , and also, does not add any pretty headers like yours would.
16:38:26 <EvilTerran> newtype Seq a = Seq { runSeq :: a }; instance Monad Seq where return = Seq; Seq x >>= f = f $! x
16:38:52 <humasect> i am also interested how pureMD5 depends on strictness annotations
16:39:10 <ac> without something like: \r -> r { member = updateMember (member r) } -- ?
16:39:12 <humasect> the only one i really 'believe in' is in the case of getContents
16:39:16 <BMeph_> mmorrow: Well, since I haven't read much more than the basic propaganda stuff (Why AGs Matter, and the like), it seems like they're both  means to work around the "expression problem", just focusing on different aspects of things that OO thinking does well.
16:39:24 <nha_> whats the best way to split a StorableArray into chunks
16:39:37 <humasect> ac: functional references ... i am waiting for it too=)
16:39:38 <dolio> No. Updating is kind of a weakness of the current record syntax/system.
16:39:40 <mmorrow> i think of it like ... a >> b ensures a will be "performed" before b, and a `seq` b ensure a will be "evaluated to whnf" before b is
16:39:42 <nha_> (readonly)
16:39:48 <nha_> but out to C land
16:39:56 <ac> humasect: what do functional references have to do with that?
16:39:57 <humasect> what is whnf ?
16:40:14 <humasect> ac: that is what i thought when i was here asking the same thing you were some days/weeks ago.
16:40:41 <mmorrow> humasect: heh. yeah, graphviz has such a nice simple format/syntax.
16:40:43 * humasect waits for State.*.puts
16:42:00 <mmorrow> BMeph_: very cool, i hear you on that. so the "whole new point of view" thing then..love those.
16:42:16 <Saizan> humasect: weak head normal form, i.e. you have force the outermost constructor
16:42:20 <Saizan> forced
16:47:40 <mmorrow> BMeph_: the AGs/etc chapter is on my to-read-next list for that parsing book now :)
16:49:06 <mmorrow> this book is intense. one of those you'll never throw away, and use for reference constantly. i recommend it to anyone wanting parsing information.
16:49:08 <BMeph_> mmorrow: Yeah, I'm still in the middle of the "expression lemma" paper. Of course, I'm still in the middle of reading Lakatos' P&R, too. I'm like that, unfortunately... :\
16:49:27 <mmorrow> BMeph_: haha. me too.
16:54:29 * ddarius just started two textbooks, a technical book, and a fitness book.
16:55:13 <TomMD> ddarius: What technical book?
16:55:32 <mmorrow> http://www.amazon.com/Parsing-Techniques-Practical-Monographs-Computer/dp/038720248X/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1220915387&sr=8-1
16:55:35 <lambdabot> http://tinyurl.com/5vxeye
16:55:50 <mmorrow> 5 stars on amazon apparently. i'd agree.
16:55:50 <mgsloan> hey, is there an accepted way of representing (a -> b, b -> a), where f . g == id and g . f == id  ?
16:56:31 <ac> my problem is the duplication of the member name. And it can't be abstracted
16:57:03 <ddarius> mgsloan: A data structure that has a pair of functions.  You can't enforce the isomorphism constraint unless you wan to limit which functions you'll accept.
16:57:43 <mgsloan> right right, I mean is there some library representation of this that also has useful functions on this data structure?
16:57:55 <mmorrow> mgsloan: i like     data Iso a b = Iso (a -> b) (b -> a)        then you can do   flipIso :: Iso a b -> Iso b a   if need be for class instances or something
16:58:10 <ac> I want to write something like: modifyRec r m f = \n -> r { m = f (m r) n } -- but that just doesn't work
16:58:12 <mmorrow> (i just made the name flipIso up right now)
16:58:41 <mgsloan> right right, just wondering, as it seems like a pretty elementary concept.  isoComposition and such too
16:58:45 <dmwit> ac: Look up functional references.
16:58:54 <ddarius> TomMD: Bionanotechnology
16:58:56 <dmwit> mgsloan: No, there is no such library, though I've wanted it several times myself.
16:59:05 <dmwit> ?go functional references twan
16:59:09 <mgsloan> well we should write one :)
16:59:10 <TomMD> ddarius: ... and Haskell?
16:59:17 <lambdabot> http://www.biolreprod.org/cgi/content/full/68/6/2255
16:59:17 <lambdabot> Title: Sex Steroids in Scleractinian Coral, Euphyllia ancora: Implication in Mass Spawn ...
16:59:25 <FunctorSalad_> ...
16:59:26 <mmorrow> mgsloan: yeah, one way's pretty much as good as another wrt being able to manipulate if with syntactic convenience
16:59:34 <mmorrow> s/if/it/
16:59:45 <dmwit> mgsloan: If you could write an "instance (Iso a b, Foo a) => Foo b" for all Foo while you're at it, that would be great. =)
17:00:52 <TomMD> > foldM (\x -> print ("line: " ++ (show x))) [1..3]
17:00:53 <lambdabot>   Couldn't match expected type `b -> m a'
17:01:11 <mgsloan> ah, we'll see :) one problem of course is what if both a and b are instances of say, Show
17:01:31 <TomMD> > foldM (\x -> print ("line: " ++ (show x))) () [1..3]
17:01:32 <lambdabot>   Couldn't match expected type `b -> m a'
17:01:43 <TomMD> Grrr, right a -> [b].
17:01:46 <dmwit> TomMD: That's mapM.
17:02:02 <dmwit> > mapM (print . ("line: " ++) . show) [1..3]
17:02:03 <lambdabot>   mueval: Prelude.read: no parse
17:02:03 <lambdabot>  mueval: *** Exception: "<IO [()]>"
17:02:19 * sbahra hugs #haskell
17:02:19 <dmwit> TomMD: But for numbering lines, you might like the "nl" command. =)
17:02:20 <ac> dmwit: with functional references would you substitute a Map for a record?
17:02:30 <dmwit> ac: Definitely not.
17:02:44 <TomMD> dmwit: right, but I've found I dislike foldM as well.  I was trying to use it on a list of  a -> Maybe b functions and got annoyed.
17:02:57 <dmwit> ac: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
17:02:59 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
17:03:26 <ddarius> mgsloan: You may also want to see Pierce's language: Boomerang
17:03:58 <dons> Beelsebob: http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all
17:04:05 <lambdabot> Title: thread-ring benchmark | Ubuntu : Intel® Q6600® quad-core Computer Language Ben ..., http://tinyurl.com/5vj8bn
17:04:10 <mgsloan> it'd also be cool to be able to convert constructors to Isos
17:04:11 <dons> Beelsebob: locks the thread ring onto the first cpu
17:04:51 <ac> dmwit: thanks for the link
17:05:08 <mgsloan> ddarius - ah cool!
17:05:42 <FunctorSalad_> mgsloan: hmm we could make Hask-with-isos an instance of Control.Category maybe
17:05:48 <Jedai> zipWithM (\n s -> putStrLn $ show n ++ "  " ++ s) [1..]
17:06:06 <ddarius> dons: I was about to ask, but it seems the answer is "yes."  We completely crush the competition then.
17:06:27 <dons> ddarius: yeah. so these runtime migration/wakeup flags are useful.
17:06:32 <ddarius> Where's the ruby entry?
17:06:39 <dons> still lobbying to get the parallel lib on the shootout -- it's missing in ubuntu
17:06:45 <dons> no libHSparallel.o :(
17:06:49 <mgsloan> FunctorSalad_: ooh, looks like it. thanks for the thought
17:07:33 <Igloo> Straw poll: Who starts their Haskell modules with a blank line (or similar contentless line), and who with some actual content?
17:07:46 <TomMD> Igloo: Content!
17:07:59 <ddarius> Who starts any source file with a blank line?
17:08:02 <TomMD> ... so long as comments count.
17:08:10 <FunctorSalad_> -{# OPTIONS_GHC I guess
17:08:17 <Igloo> TomMD: As long as the comment isn't "-------------", yes
17:08:28 <TomMD> Certainly content.
17:08:33 <dolio> I start with a blank line if there's no LANGUAGE pragmas.
17:08:40 <Igloo> ddarius: Me, and at least one other GHC hacker by the look of it
17:08:43 <Jedai> Igloo: A comment or {-# LANGUAGE ... }
17:08:55 <ddarius> Igloo: What's the purpose?
17:09:10 * FunctorSalad_ can't remember {- or -{ :-(
17:09:12 <Igloo> ddarius: The purpose of the blank line? It feels cramped otherwise, I think
17:09:30 <TomMD> Use a different editor ;-)
17:09:33 <ddarius> There's plenty of room above the monitor.
17:09:40 <lament> not above mine!
17:09:50 <TomMD> Well, submariners aside.
17:09:51 <Jedai> FunctorSalad_: It's just like a nested comment {- -}
17:10:02 <Jedai> FunctorSalad_: but with a hash #
17:10:11 <mgsloan> actually, nevermind Control.Category doesn't fit Iso :/
17:10:15 <FunctorSalad_> Jedai: that much I know, but I can't remember which way nested comments go ;))
17:10:26 <mgsloan> wait yeah it does
17:10:26 <FunctorSalad_> syntax highlighting saves me though.
17:10:30 <BMeph_> dons: What's up with the mandelbrot? :)
17:10:34 * mgsloan pretty stupid
17:11:07 <Jedai> FunctorSalad_: Oh right ! In this case I don't have mnemonics (well I just worked on including comments in GHC token stream so I remember of course ... ^^ )
17:11:18 <FunctorSalad_> hehe
17:12:01 <thetallgu1> Igloo: content
17:13:15 <dibblego> is there a nub but on Ord for faster running time?
17:13:25 * FunctorSalad_ uses a content-free line generated by the mission statement generator
17:13:47 <Saizan> dibblego: not anywhere in the stdlib
17:13:52 <dibblego> ok
17:14:40 <thetallgu1> dons, igloo: is the ﻿libHSparallel.o in the original Debian packaging?
17:15:01 <Igloo> thetallgu1: I don'tt understand the question
17:15:27 <Igloo> thetallgu1: It's in its own package if that's what you mean?
17:15:44 <TomMD> Igloo: IRC history: Control.Parallel is not in Ubuntu, thus not used in the shootout.
17:16:29 <Igloo> http://packages.ubuntu.com/intrepid/libghc6-parallel-dev seems to exist
17:16:30 <lambdabot> Title: Ubuntu -- Details of package libghc6-parallel-dev in intrepid
17:16:59 <Igloo> In the intrepid universe, if that helps
17:17:14 <thetallgu1> Igloo: hmm...  it's in Hardy, too
17:17:29 <thetallgu1> so I don't understand what dons was after then.
17:18:11 <thetallgu1> maybe the package isn't installed on some machine by default?
17:22:57 <dibblego> why is the Applicative constraint on Alternative, yet no implementations seem to use it?
17:24:07 <EvilTerran> it has semantics defined in terms of Applicative, i believe
17:25:11 <mmorrow> if i have no pragmas i start with
17:25:14 <mmorrow> {-# #-}
17:25:26 <mmorrow> it parses apparently :)
17:28:57 <TomMD> darcs2rss is perl?  No wonder it isn't on Hackage - ghc has a really hard time compiling perl code ;-)
17:29:45 <pjdelport> dibblego: the alternative would be to duplicate Applicative's methods in Alternative
17:30:03 <dibblego> pjdelport, but why? it seems like an unnecessary constraint
17:30:13 <pjdelport> a la Functor fmap and Monad liftM
17:30:29 <BMeph_> See y'all in a couple...
17:31:03 <pjdelport> dibblego: if you take away the constraint, you have Monoid :)
17:31:10 <dolio> Applicative and Alternative methods are supposed to interact with each other in certain ways.
17:31:14 <dolio> Like Monad and MonadPlus.
17:31:29 <pjdelport> well, more or less
17:31:55 <dolio> Like "(m `mplus` n) >>= f = (m >>= f) `mplus` (n >>= f)" in the latter case.
17:34:29 <dolio> So probably "f <*> (m <|> n) = (f <*> m) <|> (f <*> n)"
17:35:58 <pjdelport> :t (<$> empty)
17:35:59 <lambdabot> forall a b (f :: * -> *). (Alternative f) => (a -> b) -> f b
17:36:02 <pjdelport> :t (<$> mempty)
17:36:03 <lambdabot> forall a b (f :: * -> *). (Functor f, Monoid (f a)) => (a -> b) -> f b
17:38:43 <mmorrow> @let cofix f a = f (`id` cofix f a) a
17:38:44 <lambdabot>  Defined.
17:38:57 <FunctorSalad_> :o
17:38:58 <mmorrow> @type cofix fmap
17:38:59 <lambdabot> forall t2 (f :: * -> *). (Functor f) => f (f t2 -> t2) -> f t2
17:39:24 <mmorrow> this one's on the "blow your mind page"
17:39:37 <mmorrow> as this though ^^
17:39:56 <mmorrow> (cofix fmap) [(!!5),const 3,\x ->(x!!0)+(x!!1),(*2).(!!2),length,const 17]
17:39:58 <mmorrow> > (cofix fmap) [(!!5),const 3,\x ->(x!!0)+(x!!1),(*2).(!!2),length,const 17]
17:40:00 <lambdabot>   [17,3,20,40,6,17]
17:40:50 * mmorrow 's mind is blown
17:41:00 <FunctorSalad_> let's put that on the main page. "haskell is very easy, for example to calculate the list [17,3,20,40,6,17], you simply write ..."
17:41:05 <FunctorSalad_> =)
17:41:11 <mmorrow> it just solved the spreadsheet
17:41:18 <Olathe> > sayFunc [0]
17:41:19 <lambdabot>   mueval: Prelude.read: no parse
17:41:21 <Olathe> Bah.
17:41:31 <Olathe> I'll fix that.
17:41:45 <mmorrow> excel in one line!
17:41:50 <mmorrow> oh snapp
17:42:09 <Tchakkazulu> cofix fmap = loeb?
17:42:13 <mmorrow> just need a matching one line parser
17:42:16 <mmorrow> Tchakkazulu: yes
17:42:26 <Olathe> Oh, it's still ugly right now.
17:42:32 <Olathe> I have to prettify it.
17:42:35 <mmorrow> heh
17:42:54 <Tchakkazulu> Good. Now I'll try to use that knowledge to understand cofix <_<
17:43:26 <Olathe> @src cofix
17:43:26 <lambdabot> Source not found. That's something I cannot allow to happen.
17:43:30 <FunctorSalad_> what is the identity doing there anyway?
17:43:37 <mmorrow> oh
17:43:39 <FunctorSalad_> @type `id`
17:43:40 <lambdabot> parse error on input ``'
17:43:45 <EvilTerran> FunctorSalad_, it's $
17:43:45 <FunctorSalad_> @type (`id`)
17:43:46 <mmorrow> > (`id` 4) (*2)
17:43:46 <Olathe> @type id
17:43:47 <lambdabot> parse error on input `)'
17:43:48 <lambdabot>   8
17:43:48 <lambdabot> forall a. a -> a
17:43:50 <mmorrow> > (`id` 4) (*2)
17:43:52 <lambdabot>   8
17:43:58 <EvilTerran> cofix f a = f ($ cofix f a) a
17:44:00 <mmorrow> > (`$ 4) (*2)
17:44:01 <lambdabot>   mueval: Prelude.read: no parse
17:44:03 <mmorrow> > ($ 4) (*2)
17:44:04 <lambdabot>   8
17:44:16 <EvilTerran> ?type cofixz
17:44:18 <EvilTerran> ?type cofix
17:44:18 <lambdabot> Not in scope: `cofixz'
17:44:19 <lambdabot> forall t1 t2 t. (((t1 -> t2) -> t2) -> t -> t1) -> t -> t1
17:44:30 <mmorrow> (((a -> b) -> b) -> c -> a) -> c -> a
17:46:06 <dmwit> I like this one:
17:46:18 <dmwit> :t foldr (\a ~(x, y) -> (a:y, x)) ([], [])
17:46:19 <lambdabot> forall a. [a] -> ([a], [a])
17:46:23 <FunctorSalad_> that's weird... I would think that (`id` 4) (*2) == (*2) `id` 4, which doesn't make sense to me
17:46:31 <FunctorSalad_> since id is unary
17:46:38 <dmwit> id :: (a -> a) -> (a -> a)
17:46:48 <dmwit> === id :: (a -> a) -> a -> a
17:47:00 <FunctorSalad_> hmm, ok
17:47:03 <dmwit> > (*2) `id` 4
17:47:04 <Tchakkazulu> To some, better known as ($)
17:47:05 <lambdabot>   8
17:47:07 <dmwit> FunctorSalad_: ($) = id
17:47:14 <dmwit> > (*2) $ 4
17:47:15 <lambdabot>   8
17:47:38 <FunctorSalad_> :)
17:47:41 <pjdelport> > show 42
17:47:43 <lambdabot>   "42"
17:47:48 <pjdelport> > id show 42
17:47:52 <lambdabot>   "42"
17:47:55 <dmwit> > fix show
17:47:58 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
17:48:12 <lament> hee
17:48:38 <ptolomy2> hm. I have a newtype Monad inside a module that I never export, and GHC complains that it is never used because I never name it explicitly.
17:48:42 <ptolomy2> Somewhat annoying.
17:49:09 <TomMD> ptolomy2: I don't think unused names are warned on unless you use -Wall etc.
17:49:11 <dmwit> Are you sure you're using it?
17:50:17 <Tchakkazulu> > fix error
17:50:29 <ptolomy2> I'm not using -Wall and I'm pretty sure I am using it. It is of the "Foo { unFoo :: }" form, and 'unFoo' is certainly called.
17:50:33 <lambdabot>   thread killed
17:50:56 <Olathe> > thread
17:50:58 <lambdabot>   mueval: Prelude.read: no parse
17:51:05 <dmwit> ptolomy2: Ah, but is it called from the transitive closure of your export list?
17:51:06 <Olathe> :t thread
17:51:08 <lambdabot> Not in scope: `thread'
17:51:29 <ptolomy2> hmm..
17:51:31 * ptolomy2 checks
17:51:52 <dmwit> Is there anywhere I can look up what GHC's exit codes mean?
17:53:22 <ptolomy2> Definitely used. I think I'll just type in the type signature that is already inferred that includes it to quiet GHC.
17:53:45 <eyu100> show (\x -> 3) 5
17:53:51 <dmwit> ptolomy2: You should maybe report it as a bug, too.
17:54:06 <dmwit> ptolomy2: Care to paste?  I'm interested in how you managed to fool GHC.
17:55:02 <ptolomy2> I don't think it is accurate to say I fooled GHC.
17:55:12 <ptolomy2> GHC is right; I defined a type constructor that I never used.
17:56:24 <eyu100> how do I use lambdabot
17:56:30 <dmwit> > show (\x -> 3) 5
17:56:32 <lambdabot>   Couldn't match expected type `t1 -> t'
17:56:39 <dmwit> > show $ (\x -> 3) 5
17:56:41 <lambdabot>   "3"
17:56:44 <dmwit> Or, just:
17:56:47 <dmwit> > (\x -> 3) 5
17:56:48 <FunctorSalad_> @botsnack vegetables
17:56:48 <lambdabot> :)
17:56:49 <lambdabot>   3
17:56:53 <FunctorSalad_> you need to feed it first
17:56:57 <FunctorSalad_> :)
17:57:09 <dmwit> eyu100: See also ?help, which will tell about other commands that \bot responds to.
17:57:14 <eyu100> > ?help
17:57:16 <lambdabot>       Unbound implicit parameter (?help::a)
17:57:16 <lambdabot>        arising from a use of `e_1...
17:57:18 <dmwit> ?help
17:57:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:57:23 <eyu100> ?list
17:57:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:58:24 <eyu100> > (\x -> y -> x + y) 1 2
17:58:26 <lambdabot>   mueval: Prelude.read: no parse
17:58:43 <eyu100> > (\x -> \x) 1
17:58:45 <lambdabot>   mueval: Prelude.read: no parse
17:58:48 <dmwit> > (\x -> \y -> x + y) 1 2
17:58:51 <lambdabot>   3
17:58:57 <dmwit> > (\x y -> x + y) 1 2
17:59:00 <lambdabot>   3
17:59:14 <dmwit> > (+) 1 2
17:59:16 <lambdabot>   3
17:59:23 <eyu100> > (==) 1 2
17:59:25 <lambdabot>   False
17:59:37 <eyu100> > (==) (2 + 2) (5)
17:59:39 <lambdabot>   False
17:59:47 <dmwit> > 2 + 2 == 5 -- way less parens
17:59:49 <lambdabot>   False
18:00:28 <ptolomy2> :q
18:00:32 <eyu100> > 1 / 0
18:00:36 <lambdabot>   Infinity
18:01:00 <pjdelport> > undefined / 0
18:01:02 <lambdabot>   mueval: Prelude.read: no parse
18:01:02 <lambdabot>  mueval: *** Exception: Prelude.undefined
18:01:15 <kaol> > 0 / 0
18:01:18 <lambdabot>   NaN
18:01:45 <Olathe> > (1 / 0) / (1 / 0)
18:01:49 <lambdabot>  Terminated
18:01:56 <FunctorSalad_> lol
18:01:58 <dmwit> > let toMaybe b = if b then Just x else Nothing in unfoldr (\a -> toMaybe (null a) (splitAt 2 a)) "1234567" -- isn't the condition backwards?
18:02:01 <lambdabot>   Couldn't match expected type `([a1], [a1]) -> Maybe (a, [a1])'
18:02:02 <Olathe> That's an IEEE value I'd not heard of.
18:02:17 <dmwit> > let toMaybe b x = if b then Just x else Nothing in unfoldr (\a -> toMaybe (null a) (splitAt 2 a)) "1234567" -- isn't the condition backwards?
18:02:19 <lambdabot>   []
18:02:30 <dmwit> Thought so.
18:02:49 <Olathe> > (1 / 0) / (1 / 0)
18:02:51 <lambdabot>   NaN
18:02:56 <Olathe> > (1 / 0) / (1 / 0) - (0 / 0)
18:03:00 <lambdabot>  Terminated
18:03:29 <rwbarton> > let x = (1/0)/(1/0) in x == x
18:03:31 <lambdabot>   False
18:03:45 <FunctorSalad_> > fix (^^ Infinity)
18:03:47 <lambdabot>   mueval: Prelude.read: no parse
18:05:02 <FunctorSalad_> why no parse?
18:05:14 <dolio> There's no Infinity literal.
18:05:20 <Olathe> > Infinity
18:05:22 <lambdabot>   mueval: Prelude.read: no parse
18:05:26 <dolio> And it fails to parse the error.
18:05:30 <Olathe> > fix (^^ (1/0))
18:05:31 <dmwit> > read "Infinity" :: Double -- the only way
18:05:33 <lambdabot>   Add a type signature
18:05:33 <lambdabot>  Terminated
18:05:38 <dmwit> > read "Infinity" :: Double -- the only way
18:05:41 <lambdabot>   Infinity
18:05:44 <Olathe> You add one, Mr. Type Inferencer.
18:05:54 <Olathe> > fix (^^ (1/0)) :: Double
18:05:56 <lambdabot>   Add a type signature
18:06:00 <Olathe> Oh dear.
18:06:08 <Olathe> > fix (^^ ((1::Double)/0))
18:06:10 <lambdabot>       No instance for (Integral Double)
18:06:10 <lambdabot>        arising from a use of `^^' at ...
18:06:13 <rwbarton> :t fix (^^ (1/0))
18:06:16 <lambdabot>     Ambiguous type variable `t' in the constraints:
18:06:16 <lambdabot>       `Integral t' arising from a use of `^^' at <interactive>:1:4-13
18:06:16 <lambdabot>       `Fractional t' arising from a use of `/' at <interactive>:1:9-11
18:06:18 <Olathe> > fix (^^ ((1.0::Double)/0))
18:06:19 <lambdabot>       No instance for (Integral Double)
18:06:20 <lambdabot>        arising from a use of `^^' at ...
18:06:24 <Olathe> > fix (^^ ((1.0::Double)/0.0))
18:06:26 <lambdabot>       No instance for (Integral Double)
18:06:26 <lambdabot>        arising from a use of `^^' at ...
18:06:30 <Olathe> Oh.
18:06:35 <Olathe> > fix (^ ((1.0::Double)/0.0))
18:06:37 <lambdabot>       No instance for (Integral Double)
18:06:37 <lambdabot>        arising from a use of `^' at <...
18:06:42 <rwbarton> (**)
18:06:43 <FunctorSalad_> if we take Infinity=alpeh0 the result should be 2^aleph0 unless I'm missing something
18:06:44 <Olathe> > fix (** ((1.0::Double)/0.0))
18:06:51 <Olathe> Man...
18:06:57 <dmwit> > let toMaybe b x = if b then Just x else Nothing in unfoldr (\a -> toMaybe (not $ null a) (splitAt 2 a)) "12345"
18:06:59 <lambdabot>   ["12","34","5"]
18:06:59 <lambdabot>   thread killed
18:07:05 <FunctorSalad_> (1 is a solution too though)
18:07:06 <Olathe> Why do we have 25 million operators that do the same thing, but no generic one ?
18:07:56 <dmwit> (^), (^^), and (**) do not do the same thing.
18:08:51 <dolio> @type (^)
18:08:53 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:09:09 <dolio> ^ uses repeated *
18:09:12 <dolio> @type (^^)
18:09:14 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:09:38 <FunctorSalad_> *g*
18:09:41 <dmwit> > (-1 :: Double) ^ 2
18:09:43 <lambdabot>   1.0
18:10:13 <dolio> ^^ relies on the fact that you can compute the multiplicative inverse of fractionals (for negative exponents).
18:10:14 <dmwit> One of those deals with negative numbers in some way.
18:10:20 <dmwit> yeah
18:10:37 <dolio> ^ just fails for negative exponents, since there's no division guaranteed by Num.
18:10:46 <dmwit> > (1 :: Int) ^ 2
18:10:49 <lambdabot>   1
18:10:54 <dolio> And ** uses magic floating point unit stuff. :)
18:10:54 <dmwit> > (1 :: Int) ^ (negate 2)
18:10:57 <lambdabot>   mueval: Prelude.read: no parse
18:10:57 <lambdabot>  mueval: *** Exception: Negative exponent
18:11:05 <dmwit> > (1 :: Double) ^ (negate 2)
18:11:08 <lambdabot>   mueval: Prelude.read: no parse
18:11:08 <lambdabot>  mueval: *** Exception: Negative exponent
18:11:12 <dmwit> > (1 :: Double) ^^ (negate 2)
18:11:14 <lambdabot>   1.0
18:14:27 <darrint> What's the difference between Word64 and Int64 ?
18:14:36 <dolio> Words are unsigned.
18:14:37 <allbery_b> the former is unsigned
18:15:16 <sheyll```> ahrg...why is it possible to write a function definiton like this: "f (n + 1) = ... do sth. with n". where can I find out about what kind of patterns are possible?
18:15:34 <allbery_b> http://haskell.org/onlinereport
18:15:35 <lambdabot> Title: The Haskell 98 Language Report
18:15:39 <dolio> n + k patterns are special.
18:15:50 <allbery_b> that said, n+k-patterns are ... unusual
18:15:56 <allbery_b> some people think they are a mistake
18:16:05 <rwbarton> sheyll```: it's only patterns of the form (<var> + <numeric literal>) that are weird
18:16:08 * sheyll``` dislikes special thinks
18:16:22 * dmwit too
18:16:24 <bd_> use view patterns instead :)
18:16:40 <sheyll```> hmm what are view patterns?
18:16:53 <bd_> sheyll```: they're a new feature in the next version of GHC: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
18:16:56 <bd_> (not yet released)
18:16:57 <lambdabot> Title: ViewPatterns - GHC - Trac
18:17:12 <darrint> Is there a function to encode Word64 into a big or little endian format?
18:17:20 <darrint> (for data.binary)
18:17:34 <rwbarton> sheyll```: You can pretend that 0 = Z, 1 = S Z, 2 = S (S Z), ..., and then n+k patterns become more sensible (n+1 <--> S n)
18:17:37 <FunctorSalad_> the (n+1) pattern is just for factorials
18:17:42 <FunctorSalad_> ;-)
18:17:43 <rwbarton> sheyll```: But, of course, that's not really how numbers work in Haskell.
18:17:48 <darrint> Oh shoot. Maybe if I read the docs. never mind.
18:17:53 <bd_> darrint: http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary-Put.html#4 :)
18:17:55 <lambdabot> Title: Data.Binary.Put, http://tinyurl.com/65fbl7
18:18:01 <dolio> And fibonaccis.
18:18:02 <darrint> yeah. my bad. :-)
18:18:12 <dolio> You can never have enough fibonacci definitions.
18:18:23 <FunctorSalad_> hehe
18:20:01 <Olathe> The number of Fibonacci definitions in existence at any time must be equal to a Fibonacci number.
18:20:43 <pjdelport> O(fib(n))
18:21:02 <eyu100> > putStrLn (\x -> 0 : 1 : [ a + b | (a, b) <- zip x (tail x)])
18:21:03 <lambdabot>       The lambda expression `\ x -> 0 : 1 : ...' has one argument,
18:21:03 <lambdabot>      but i...
18:21:17 <Olathe> O(fib(n)) = O(2^n), I think.
18:21:36 <rwbarton> Olathe: only in the sense that O(n) = O(n^2)
18:22:01 <sheyll```> bd_: the ViewPatterns idea seems interesting. Altough I don't find it very intuitive...
18:22:18 <pjdelport> Olathe: the recursive definition has O(fib(n)) additions, IIRC
18:22:30 <pjdelport> which is pretty nifty
18:22:31 <FunctorSalad_> do we have "url <- googleForFibonacciCode; code <- wget url; ..." yet?
18:22:46 <dolio> O(fib(n)) would be more like O(phi^n) no?
18:24:14 <sheyll```> bd_: forget what I just wrote: after finishing the article I must admit: ViewPatterns rock!!
18:24:36 <Olathe> rwbarton: It isn't the same ?
18:24:38 <eyu100> > (\x -> 0 : 1 : [ a + b | (a, b) <- zip x (tail x)])
18:24:39 <lambdabot>       Overlapping instances for Show ([a] -> [a])
18:24:39 <lambdabot>        arising from a use o...
18:25:13 <Olathe> I'd say that fib(n) is in Theta(2^n), but I could be wrong.
18:25:35 <eyu100> (\x -> x)
18:25:45 <pjdelport> well, you have to define the unit that the magnitude is measuring
18:25:52 <eyu100> > (\x -> x)
18:25:53 <lambdabot>       Overlapping instances for Show (t -> t)
18:25:53 <lambdabot>        arising from a use of `s...
18:26:23 <FunctorSalad_> Olathe: theta(phi^n) I think
18:26:43 <Olathe> Ahh.
18:26:47 * dolio can never remember which of the other ones is which.
18:27:00 <Olathe> What's the formula for fib in terms of phi ?
18:27:04 <eyu100> > 2
18:27:06 <lambdabot>   2
18:27:12 <eyu100> > "lol"
18:27:13 <lambdabot>   "lol"
18:27:26 <eyu100> > import Control.Monad
18:27:27 <lambdabot>   mueval: Prelude.read: no parse
18:27:49 <FunctorSalad_> Olathe: hmm you get it by diagonalizing the iteration matrix
18:28:01 <Olathe> Eww.
18:28:20 <pjdelport> eyu100: you can query lambdabot, by the way
18:28:22 <dolio> I tried googling it, but all you get are crackpot websites about phi and fibonacci numbers. ;)
18:29:59 <dolio> F_n = nint (phi^n / sqrt 5)
18:30:37 <Olathe> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
18:30:39 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:31:22 <rwbarton> > let phi = (1+sqrt 5) / 2 in [ round (phi^n / sqrt 5) | n <- [1.. ] ]
18:31:27 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:31:44 <eyu100> > let x = 0 : 1 : [ a + b | (a, b) <- zip x (tail x)]
18:31:45 <lambdabot>   mueval: Prelude.read: no parse
18:32:34 <eyu100> let fibs = [1..]
18:32:39 <Olathe> > let fibs = 1:1:zipWith (+) fibs (tail fibs); pows = 1:map (*2) pows in zipWith div pows fibs
18:32:40 <lambdabot>   [1,2,2,2,3,4,4,6,7,9,11,14,17,21,26,33,41,50,62,77,95,118,146,180,223,276,3...
18:32:45 <eyu100> > let fibs = [1..]
18:32:46 <lambdabot>   mueval: Prelude.read: no parse
18:32:58 <eyu100> fibs <- [1..]
18:33:00 <pjdelport> eyu100: it's an expression;  you need "let ... in ..."
18:33:16 <dons> thetallguy: yeah, debian has parallel, but ubuntu doesn't have the package
18:33:19 <eyu100> I don't know how to do that =\
18:33:32 <pjdelport> > let x = 0 : 1 : [ a + b | (a, b) <- zip x (tail x)] in x
18:33:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:33:40 <FunctorSalad_> dolio: there's one without rounding
18:33:51 <eyu100> let fibs = [1..] in fibs
18:33:52 <rwbarton> > let phi = (1+sqrt 5) / 2 in [  (phi^n - phi^(-n)) / sqrt 5) | n <- [0.. ] ]
18:33:54 <lambdabot>   mueval: Prelude.read: no parse
18:33:56 <eyu100> > let fibs = [1..] in fibs
18:33:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:34:00 <FunctorSalad_> yeah that one
18:34:00 <rwbarton> > let phi = (1+sqrt 5) / 2 in [  (phi^n - phi^^(-n)) / sqrt 5) | n <- [0.. ] ]
18:34:01 <dolio> That was the one listed on math world.
18:34:01 <lambdabot>   mueval: Prelude.read: no parse
18:34:35 <rwbarton> > let phi = (1+sqrt 5) / 2 in [  (phi^n - phi^^(-n)) / sqrt 5 | n <- [0.. ] ]
18:34:36 <lambdabot>   [0.0,0.4472135954999579,1.0,1.7888543819998317,3.0,4.919349550499537,8.0,12...
18:34:39 <rwbarton> fail
18:34:51 <eyu100> make a function defining pi...
18:34:52 <rwbarton> ah, I see. Whatever
18:34:57 <eyu100> as a series
18:35:17 <eyu100> let pi = 4 * ...
18:35:35 <eyu100> let pi = 4 * (1 - (1 / 3) + (1 / 5))
18:35:43 <eyu100> > let pi = 4 * (1 - (1 / 3) + (1 / 5)) in pi
18:35:44 <lambdabot>   3.466666666666667
18:35:56 <FunctorSalad_> > let pi = 22/7
18:35:57 <lambdabot>   mueval: Prelude.read: no parse
18:36:06 <geezusfreeek> > 22/7
18:36:07 <lambdabot>   3.142857142857143
18:36:53 <eyu100> pi = 4 - 4/3 + 4/5 - 4/7 etc.
18:37:05 <eyu100> I can't write that as a function >_<
18:37:34 <Olathe> > map (\n -> 2*n + 1) [0..]
18:37:35 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:37:38 <geezusfreeek> eyu100: why not? it may not terminate, but you could make an infinite list of improving values
18:37:42 <Olathe> > map (\n -> 4%(2*n + 1)) [0..]
18:37:43 <lambdabot>   [4%1,4%3,4%5,4%7,4%9,4%11,4%13,4%15,4%17,4%19,4%21,4%23,4%25,4%27,4%29,4%31...
18:37:46 <geezusfreeek> and then grab values at given indices
18:37:53 <Olathe> > map (\n -> 4%(2*n + 1)*(-1)^n) [0..]
18:37:55 <lambdabot>   [4%1,(-4)%3,4%5,(-4)%7,4%9,(-4)%11,4%13,(-4)%15,4%17,(-4)%19,4%21,(-4)%23,4...
18:38:15 <Olathe> > scanl (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]
18:38:16 <lambdabot>       Overlapping instances for Show ([[Ratio a]] -> [[Ratio a]])
18:38:17 <lambdabot>        aris...
18:38:22 <dmwit> scanl (+) 0
18:38:25 <Olathe> > scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]
18:38:27 <lambdabot>   [4%1,8%3,52%15,304%105,1052%315,10312%3465,147916%45045,135904%45045,249054...
18:38:33 <Olathe> scanl1++
18:38:59 <eyu100> no I'm just saying *I* can't write it
18:39:05 <eyu100> I don't really know that much Haskell
18:39:19 <dolio> Heh.
18:39:20 <dmwit> eyu100: With a bit of work, you'll get it before long.
18:39:31 <Olathe> How do you convert Ratio a -> Double ?
18:39:42 <dmwit> :t fromRational
18:39:44 <Olathe> @hoogle Ratio a -> Double
18:39:47 <Olathe> Ahh, thanks :)
18:39:49 <lambdabot> forall a. (Fractional a) => Rational -> a
18:39:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:39:57 <lambdabot> Prelude id :: a -> a
18:39:59 <lambdabot> Data.Function id :: a -> a
18:40:04 <dmwit> Olathe: Note that Rational = Ratio Integer specifically, though.
18:40:25 <Olathe> > (map fromRational $ scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]) :: [Double]
18:40:37 <Olathe> Faster !
18:40:40 <FunctorSalad_> > iterate (\x -> x - (sin x / cos x)) 3.14
18:40:41 <lambdabot>  Terminated
18:40:43 <lambdabot>   [3.14,3.1415926549364075,3.141592653589793,3.141592653589793,3.141592653589...
18:40:58 <dmwit> Wow, that converges really quickly.
18:41:09 <Olathe> > (map fromRational $ scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]) :: [Double]
18:41:11 <lambdabot>   [4.0,2.6666666666666665,3.466666666666667,2.895238095238095,3.3396825396825...
18:41:23 <Olathe> > drop 100 $ (map fromRational $ scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]) :: [Double]
18:41:25 <lambdabot>   [3.1514934010709905,3.1317889675734536,3.151301162695405,3.13197749119782,3...
18:41:31 <FunctorSalad_> dmwit: yeah, IIRC newton's iteration converges quadratically unless the derivative at the zero is zero too
18:41:31 <Olathe> Heheh
18:41:47 <Olathe> > drop 10000 $ (map fromRational $ scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]) :: [Double]
18:41:53 <dmwit> FunctorSalad_: Ohhhh, that was the iterate command.
18:42:01 <dmwit> FunctorSalad_: Never mind, that's way less impressive. =P
18:42:02 <lambdabot>   thread killed
18:42:20 <FunctorSalad_> dmwit: ^^ what did you think?
18:42:36 <dmwit> I thought that was the series approximation Olathe was working on.
18:42:41 <dmwit> I was going to be *way* impressed.
18:42:43 <FunctorSalad_> imho quadratical convergence is still impressive... number of correct digits doubles each time
18:42:45 <Olathe> Oh, no, that's a nicer one.
18:42:52 <dmwit> series approximations never get good that fast =P
18:43:11 <rwbarton> > let approxs = iterate (\x -> x - (sin x / cos x)) 3.14 in take 50 [ show (approxs !! i) !! i | i <- [0..] ]
18:43:14 <lambdabot>   mueval: Prelude.read: no parse
18:43:14 <lambdabot>  mueval: "3.141592653589793*** Exception: Pr...
18:43:15 <vininim> transcedental functions for pi is cheating, imho =P
18:43:19 <dmwit> FunctorSalad_: Yeah, but you have to "know" pi to calculate sin and cos, so it's kind of cheating.
18:43:38 <Olathe> You don't have to, if you use the lovely series for those.
18:43:39 <eyu100> > iterate (\x -> x - (sin x / cos x)) 3.1
18:43:41 <lambdabot>   [3.1,3.141616654585636,3.1415926535897887,3.141592653589793,3.1415926535897...
18:43:46 <eyu100> > iterate (\x -> x - (sin x / cos x)) 5000
18:43:48 <lambdabot>   [5000.0,5006.387642202844,5010.150542121536,5010.975441809046,5010.83945338...
18:43:55 <Olathe> > iterate (\x -> x - (sin x / cos x)) (1.0/0.0)
18:43:57 <lambdabot>   [Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,N...
18:44:01 <intoverflow> heh
18:44:05 <eyu100> > iterate (\x -> x - (sin x / cos x)) 5
18:44:07 <lambdabot>   [5.0,8.380515006246586,10.100886756729285,9.298641017727068,9.4254512142934...
18:44:14 <FunctorSalad_> dmwit: how do you use pi in calculating sin/cos?
18:44:16 <eyu100> > iterate (\x -> x - (sin x / cos x)) -111
18:44:17 <lambdabot>       No instance for (Num (a -> [a]))
18:44:17 <lambdabot>        arising from the literal `111' ...
18:44:23 <eyu100> > iterate (\x -> x - (sin x / cos x)) 0
18:44:25 <lambdabot>   [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0....
18:44:25 <FunctorSalad_> I guess it uses a lookup table
18:44:28 <eyu100> > iterate (\x -> x - (sin x / cos x)) 0.1
18:44:30 <FunctorSalad_> or something
18:44:30 <lambdabot>   [0.1,-3.3467208545052973e-4,1.249502806993999e-11,0.0,0.0,0.0,0.0,0.0,0.0,0...
18:44:33 <rwbarton> eyu100: it'll converge to some multiple of pi
18:44:38 <eyu100> oh
18:44:38 <Olathe> Eww.
18:44:39 <dmwit> FunctorSalad_: Check out the air-quotes around "know".
18:44:42 <vininim> iirc it does
18:44:43 <eyu100> > iterate (\x -> x - (sin x / cos x)) 1.5
18:44:45 <lambdabot>   [1.5,-12.60141994717172,-12.566356255118672,-12.566370614359174,-12.5663706...
18:44:51 <eyu100> > iterate (\x -> x - (sin x / cos x)) 1.8
18:44:53 <lambdabot>   [1.8,6.086261674628062,6.285770916521768,6.283185301417648,6.28318530717958...
18:45:00 <eyu100> > iterate (\x -> x - (sin x / cos x)) 2
18:45:02 <dmwit> FunctorSalad_: i.e. in some sense you have to have trigonometry knowledge to derive more trigonometry knowledge -- that's cheating
18:45:04 <lambdabot>   [2.0,4.185039863261519,2.467893674514666,3.266186277569106,3.14094391231763...
18:45:25 <Olathe> > let f n = (iterate (\x -> x - (sin x / cos x)) n) !! 1000 in f 2
18:45:27 <lambdabot>   3.141592653589793
18:45:57 <FunctorSalad_> rwbarton: can't this particular iteration diverge?
18:46:08 <Olathe> Yes.
18:46:12 <Olathe> > iterate (\x -> x - (sin x / cos x)) (1.0/0.0)
18:46:12 <rwbarton> FunctorSalad_: Oh, probably
18:46:17 <lambdabot>   [Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,N...
18:46:27 <dmwit> > iterate (\x -> x - (sin x / cos x)) (pi / 2)
18:46:31 <lambdabot>   [1.5707963267948966,-1.6331239353195368e16,-1.6331239353195368e16,-1.633123...
18:46:37 <geezusfreeek> > (scanl1 (+) . zipWith (*) (cycle [1,-1]) $ map (4%) [1,3..]) !! 100
18:46:40 <lambdabot>   830451968305093031586835172847858137121823705761010747562787642768870056465...
18:46:47 <geezusfreeek> psh
18:46:49 <dmwit> uhh
18:46:54 <dmwit> > cos (pi / 2)
18:46:58 <lambdabot>   6.123233995736766e-17
18:47:02 <dmwit> oh, heh
18:47:19 <eyu100> > 3 ** 3
18:47:22 <lambdabot>   27.0
18:47:39 <Olathe> You can do scanr1 and scanl1 to speed up that slow series.
18:47:43 <FunctorSalad_> dmwit: you can define sin as the solution to f'' = f; f 0 = 0; f 1 = 1... no trig there
18:47:43 <eyu100> > 3 ** (3 ** (3 ** 3))
18:47:47 <lambdabot>   Infinity
18:47:54 <eyu100> haha lol
18:47:54 <geezusfreeek> scanl1 (**) [2..]
18:47:57 <Olathe> > map (\n -> 2*n + 1) [0..]
18:47:59 <geezusfreeek> > scanl1 (**) [2..]
18:48:02 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
18:48:02 <lambdabot>  Terminated
18:48:02 <FunctorSalad_> dmwit: and no pi
18:48:09 <geezusfreeek> > scanl1 (**) [2..]
18:48:13 <lambdabot>   [2.0,8.0,4096.0,1.152921504606847e18,2.3485425827738333e108,Infinity,Infini...
18:48:27 <FunctorSalad_> (make that last one f' 0 = 1)
18:49:26 <geezusfreeek> > scanl1 (**) [a,b,c,d,e,f]
18:49:26 <Olathe> > let f n = factors where factors = [1,3..2*n + 1] in f 5
18:49:30 <lambdabot>   [1,3,5,7,9,11]
18:49:30 <lambdabot>  Terminated
18:49:37 <geezusfreeek> > scanl1 (**) [a,b,c,d,e,f]
18:49:39 <lambdabot>   [a,a**b,(a**b)**c,((a**b)**c)**d,(((a**b)**c)**d)**e,((((a**b)**c)**d)**e)*...
18:50:00 <FunctorSalad_> (err and f'' = -f. meh)
18:50:38 <Olathe> > let f n = zipWith (*) leftProducts rightProducts where factors = [1,3..2*n + 1] in f 5; leftProducts = scanl1 (*) factors; rightProducts = drop 1 $ scanr1 (*) factors in f 5
18:50:44 <lambdabot>  Terminated
18:50:48 <Olathe> > let f n = zipWith (*) leftProducts rightProducts where factors = [1,3..2*n + 1] in f 5; leftProducts = scanl1 (*) factors; rightProducts = drop 1 $ scanr1 (*) factors in f 5
18:50:50 <lambdabot>   mueval: Prelude.read: no parse
18:50:51 <Olathe> Bah.
18:50:55 <Olathe> > let f n = zipWith (*) leftProducts rightProducts where factors = [1,3..2*n + 1]; leftProducts = scanl1 (*) factors; rightProducts = drop 1 $ scanr1 (*) factors in f 5
18:50:59 <lambdabot>  Terminated
18:51:05 <Olathe> I'll terminate you !
18:51:25 <eyu100> # kill -SIGKILL lambdabot
18:51:26 <eyu100> =P
18:51:31 <FunctorSalad_> @vixen I'll protect you
18:51:32 <lambdabot> what's the last book you read?
18:51:43 <eyu100> @vixen lol
18:51:44 <lambdabot> are you really laughing?
18:51:49 <eyu100> @vixen lmao
18:51:49 <lambdabot> do you trust the government?
18:51:57 <eyu100> @vixen roflmfao
18:51:57 <lambdabot> Let's change the subject
18:52:31 <sbahra> @vixen Should I order Chinese food?
18:52:31 <lambdabot> whoa whoa whoa, one question at a time!
18:53:11 <geezusfreeek> @faq Can Haskell order Chinese for me?
18:53:12 <lambdabot> The answer is: Yes! Haskell can do that.
18:56:43 <Twey> > orderChinese [SpareRibs, SweetAndSourChicken, EggFriedRice]
18:56:45 <lambdabot>       Not in scope: data constructor `SweetAndSourChicken'
19:00:29 <darrint> Does ghci automatically pick up update package versions installed by cabal (after restart) ?
19:00:47 <darrint> I don't have the IsString instance of ByteString.
19:03:12 <mmorrow> darrint: you can implem your own http://hpaste.org/10211
19:04:23 <darrint> mmorrow: Ok. But the docs say I should be able to import Data.ByteString and have IsString available. Is something complicated happening?
19:05:09 <mmorrow> you must not have the newest version of ByteString which it's included in. i wouldn't recommend trying to upgrade bytestring though.
19:05:34 <mmorrow> it'll become dependency conflict hell
19:06:39 <darrint> mmorrow: How do I know I want the Char8 version?
19:06:45 <mmorrow> good thing ghc6.10'll be out in under two weeks :)
19:07:07 <mmorrow> darrint: you can write an instance for each...
19:08:11 <darrint> mmorrow: Orginally I tried using pack and got:  Couldn't match expected type `Word8' against inferred type `Char' ...
19:08:22 <goltrpoat> mmorrow:  two weeks, seriously?
19:08:25 <Olathe> > (scanl1 (+) $ map (\n -> 4%(2*n + 1)*(-1)^n) [0..]) !! 3
19:08:28 <lambdabot>   304%105
19:08:40 <Olathe> > let f n = (% (head rightProducts)) $ (4*) $ foldl' (+) 0 $ zipWith3 (\a b c -> a*b*c) (cycle [1,-1]) leftProducts rightProducts where factors = [1,3..2*n + 1]; leftProducts = scanl (*) 1 factors; rightProducts = drop 1 $ scanr (*) 1 factors in f 3
19:08:42 <lambdabot>   304%105
19:09:16 <darrint> mmorrow: Well, switching to char8 makes it go away for now. I'll live with that.
19:09:35 <mmorrow> http://hpaste.org/10211#a1
19:10:01 <mmorrow> it's only a very minor pain due to having the qualified imports/etc, but not that bad
19:10:57 <mmorrow> goltrpoat: yup. sept 19 i believe
19:11:33 <mmorrow> goltrpoat: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
19:12:23 <goltrpoat> nuts.  very cool
19:13:10 <mmorrow> darrint: in case you missed it, http://hpaste.org/10211#a1
19:13:24 <mmorrow> goltrpoat: most definitely
19:13:54 <thatsright> has anyone ever written something that converts c code to haskell code?
19:14:25 <darrint> mmorrow: I think I get it. And yay for 6.10.
19:14:51 <lambdabot> Title: Status/Releases - GHC - Trac
19:16:27 <goltrpoat> thats:  that'd be relatively easy and entirely pointless
19:16:32 <goltrpoat> so probably not
19:18:35 <mmorrow> darrint: cool.
19:20:19 <ddarius> goltrpoat: Oh come on.  You can't say that you've never wanted the low level type unsafe abstractions of C with the high level overheads and ABI incompatibilities of Haskell.
19:20:46 <ddarius> And it'll have TCO!
19:22:14 <mmorrow> totally cost-effective ostrich?
19:22:42 <dolio> Lack of tail-call optimization really bites you all over the place in C.
19:22:58 <dolio> A compiler to Haskell certainly would be a boon for that.
19:23:03 <Olathe> That's why you use goto in C.
19:23:04 <Olathe> ;)
19:25:32 <dolio> main is all you need.
19:26:39 <Adamant> sadly the programming reddit is getting increasingly less worthwhile.
19:26:54 <Adamant> or at least reading the comment section is.
19:27:02 <Olathe> I heard that the old Haskell motto was something like avoid popularity at all costs.
19:27:16 <dolio> That's because I stopped making comments. :)
19:27:19 <Olathe> Reddit is getting popular.
19:27:34 <Olathe> dolio: Ahh !
19:28:41 <Cale> I've stopped moderating the programming reddit altogether, because there's just too much worthless garbage on it now. I could manage when 10% of the articles were worthwhile...
19:29:16 <Adamant> sometimes I wonder how many people that follow The Register links know they're being trolled by a company trying desperately to get more pageviews.
19:29:31 <dolio> I've pretty much stopped visiting, too. I barely care about any of the stuff that gets posted, last I checked.
19:29:38 <Olathe> That's an interesting strategy for getting views.
19:30:05 <dolio> That and I started playing nethack, so I have something else to do during lulls in my day.
19:30:07 <Cale> Yeah. We need a new forum for nonidiotic programming links. :)
19:30:30 <Adamant> sub-Hacker News?
19:30:46 <Adamant> it's starting to get a bit formulaic but it's not actually bad yet.
19:31:09 <Olathe> You have to correct a syntax error in a Haskell snippet to post.
19:34:02 <goltrpoat> cale:  havent read reddit in weeks
19:34:05 <Adamant> Olathe: it's been Andrew Orlovski's strategy for years. find something some vocal subset of IT people like, the more the better. bash it mercilessly. Now they have Dzibua or whoever playing the same games.
19:34:28 <goltrpoat> cale:  got entirely too retarded.
19:34:37 <goltrpoat> my last 15 posts or so weren't programming related
19:35:16 <Adamant> the only outpost of sanity left on reddit is bacon.reddit.com
19:35:33 <dolio> Is that about Kevin Bacon?
19:35:40 <dolio> Or the meat?
19:35:47 <Adamant> no, the tasty portable meat snack
19:36:01 <Cale> Bacon is my favourite vegetable. ;)
19:36:15 <mmorrow> turnips are my favorite actor ::)
19:36:23 <Adamant> Cale: a born meatatarian!
19:36:31 <Adamant> (it's a lifestyle choice)
19:38:52 <Adamant> actually I figured you for a spinach man
19:39:28 <chessguy> meatatarian :)
19:39:57 <Adamant> or someone who like the vegetable ale with a K
19:42:06 <pjdelport> meat, the mobile vegetable
20:02:28 <Myoma> hello
20:02:31 <Myoma> @quote
20:02:31 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
20:02:37 <Myoma> @quote
20:02:37 <lambdabot> Wild_Cat says: [on #python] <Wild_Cat> (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
20:03:49 <dons> well, it's about 6 companies we know of, and 2 or 3 we have rumours about.
20:04:52 <dibblego> nothing like a bit of exaggerabation to make a story more appealing
20:05:22 <Myoma> @quote
20:05:22 <lambdabot> bitwize says: The combinator known as compose, Makes me extremely morose; The full stop is better, than writing it in letters, Which makes it uselessly verbose.
20:05:31 <Myoma> hehe
20:05:50 <dibblego> tehe, Scala calls it 'compose'
20:05:55 <dons> dibblego: well, i don't know if anyone is exaggerating, but i've definitely seen people repeat their mistaken impressions. they might just be teasing too, of course.
20:06:17 <dibblego> dons, I think "half the Haskell world" is an exaggerabation
20:06:37 <dons> yes, definitely. and either the writer is teasing us, or has a mistaken impression of what #haskell says
20:06:37 <geezusfreeek> is there a page to go to with all the quotes lambdabot knows listed?
20:06:44 <dons> since no one here would actually say something like that.
20:06:52 <Myoma> @quote
20:06:52 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
20:06:58 <dons> heh
20:07:01 <Myoma> world's top expert!
20:07:02 <dons> that's a cool one.
20:07:37 <geezusfreeek> @quote
20:07:37 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
20:08:14 <heatsink> @quote
20:08:15 <lambdabot> therp says: it's also invalid to say shoes are useless, just because you can't brush your teeth with it
20:08:38 <Myoma> @quote
20:08:38 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
20:08:47 <geezusfreeek> i love that one
20:10:26 <Myoma> @quote
20:10:26 <lambdabot> numerodix says: tbh: people who do haskell on their own initiative kinda creep me out :)
20:11:21 <xor__> I'm using System.Posix.Files.isSymbolicLink to test for the existence of symlinks on Mac OS X. The function returns false negatives on all symbolic links. Anyone experience this before?
20:14:46 <heatsink> xor: No, I've never tried that before.
20:15:09 <heatsink> xor: it happens for me too.
20:16:56 <xor__> So what's the deal with that?
20:17:01 <Olathe> @pl ($) $ ($)
20:17:01 <lambdabot> id
20:17:41 <dancor> equivalent of `hostname` in haskell?
20:17:59 <Olathe> @hoogle host
20:17:59 <lambdabot> No results found
20:18:03 <Olathe> :(
20:18:08 <FunctorSalad_> HSH.run "hostname"? ;-)
20:18:11 <dancor> heh
20:18:18 <Olathe> @hoogle sock
20:18:18 <lambdabot> System.Posix.Internals c_closesocket :: CInt -> IO CInt
20:18:18 <lambdabot> System.Posix.Internals s_issock :: CMode -> Bool
20:18:23 <Olathe> Oh dear
20:18:41 <dancor> also, is HSH the preferred shell-wrapper-ery
20:18:57 <heatsink> Well, I can check whether the C function `stat' does the same thing...
20:19:07 <Olathe> @hoogle dns
20:19:07 <lambdabot> package dnsrbl
20:19:07 <lambdabot> package hsdns
20:19:07 <lambdabot> package network-dns
20:19:11 <FunctorSalad_> dancor: it's a high-level thing, I like it
20:19:52 <FunctorSalad_> you can do stuff like run "cat" -|- "cat" -|- (\x -> x) -|- "cat"
20:20:00 <dons> dancor: i don't think there's a preferred one yet.
20:21:35 <heatsink> xor__, the `stat' function in C has the same behavior.
20:22:07 <FunctorSalad_> dancor: it also has a few shell functions ported to real haskell functions, maybe hostname is along them
20:22:12 <xor__> Oh..
20:22:16 <FunctorSalad_> *among
20:22:31 <xor__> I must be missing something.
20:22:46 <Draconx> heatsink, you need to use lstat if you want to stat a symbolic link.
20:22:54 <dancor> it seems odd that it doesn't take args separately but also has no escape function for args
20:22:57 <dancor> or is there one?
20:23:25 <dancor> like i want to do   HSH.run $ "ls " ++ escShellArg dir
20:23:28 <xor__> Oh. Is it because I use getFileStatus?
20:23:38 <heatsink> Draconx, I see.
20:23:52 <FunctorSalad_> dancor: the argument to run is polymorphic... you can do run ("cat",["file1","file2"])
20:24:00 <dancor> oh
20:24:46 <FunctorSalad_> the doc says that that way the shell is never involved
20:24:58 <heatsink> xor__, try getSymbolicLinkStatus
20:25:15 <heatsink> I guess that's lstat?
20:25:35 <dancor> FunctorSalad_: well, you might need escaping eventually any, for e.g. ~ ssh someHost 'ls crazyDir'
20:25:42 <dancor> s/any/\0way
20:25:50 <FunctorSalad_> dancor: true...
20:26:10 <dancor> unless it were recursively polymorphic :)
20:26:17 <xor__> Must be. Thanks.
20:27:38 <binarybandit> hem
20:27:40 <binarybandit> oops
20:28:08 <sereven> dancor: re hostname are you on Posix system? host <- getSystemID >>= return . nodeName from System.Posix.Unistd is one way
20:29:05 <dancor> sereven: ok, ya i'm on posix
20:30:13 <dons> users
20:30:15 <dons> ?users
20:30:15 <lambdabot> Maximum users seen in #haskell: 497, currently: 441 (88.7%), active: 14 (3.2%)
20:35:41 <binarybandit> ?users
20:35:42 <lambdabot> Maximum users seen in #haskell: 497, currently: 442 (88.9%), active: 14 (3.2%)
20:35:44 <binarybandit> test
20:35:46 <binarybandit> ?users
20:35:46 <lambdabot> Maximum users seen in #haskell: 497, currently: 442 (88.9%), active: 14 (3.2%)
20:35:50 * binarybandit shrugs
20:35:52 <binarybandit> op
20:35:54 <dons> ?
20:35:58 <binarybandit> oops*
20:36:00 <binarybandit> I said hem.
20:36:13 <binarybandit> I wanted to see if it would count me the call I used the command.
20:36:24 <binarybandit> But I accidentally said hem in here a few minutes ago.
20:37:44 <Myoma> @quote
20:37:44 <lambdabot> EvilTerran says: look for GNU HaltingProblem; it's still in beta, but it might do what you want
20:37:57 <Myoma> @quote
20:37:58 <lambdabot> <newsham> says: magic <- get; when (magic /= MAGIC) $ fail "bad magic"
20:38:19 <heatsink> Ah, the beauty of mysterious hacks.
20:38:50 <Olathe> @obfuscat
20:38:50 <lambdabot> Unknown command, try @list
20:39:02 <Olathe> What a woeful lack.
20:39:31 <Olathe> @quot
20:39:32 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
20:39:43 <Olathe> Heheh
20:40:14 <Olathe> @quo
20:40:14 <lambdabot> JonHarrop says: As Haskell has shown, laziness cannot be implemented efficient at all.
20:40:31 <Myoma> @duo
20:40:32 <lambdabot> Maybe you meant: bug run
20:40:35 <Myoma> @quo
20:40:35 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
20:41:07 <heatsink> @qu
20:41:07 <lambdabot> Maybe you meant: quit quote . ? @ bf bug ft id pl rc run v wn
20:41:22 <Olathe> @a
20:41:22 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask . ? @ v
20:41:30 <Olathe> @arr
20:41:30 <lambdabot> Avast!
20:41:35 <FunctorSalad_> was the quote db somehow preserved through bot's resurrections?
20:42:05 <Olathe> I think so, though maybe not all of them.
20:42:31 <davidL> @activity-full
20:42:31 <lambdabot> Not enough privileges
20:42:47 <thetallguy> dons: re: libghc6-parallel-dev, I see that we have the package built and available or Ubuntu Hardy, but that Ubuntu itself does not
20:42:47 <Myoma> @quo
20:42:48 <lambdabot> balor says: Darcs appears to ignore the law of the excluded middle (setCurrentDirectory: failed (Success))
20:43:57 <FunctorSalad_> reminds me of http://www.jonco48.com/blog/fail_20at_20failing.jpg
20:45:06 <Olathe> Hahaha
20:46:08 * BMeph|notHome recalls many times, he's tried to shut down Windows, and it sked to shut down some programs first...
20:46:18 <BMeph|notHome> s/sked/asked/
20:47:30 <Dzlk> Ha! (What happens if BSOD causes a BSOD? Infinite regress?)
20:47:44 <heatsink> Dzlk: Wouldn't that be a fixed point?
20:47:58 <Olathe> That screenshot is fake !
20:48:02 <Olathe> Fake, I tell you !
20:48:16 <Dzlk> heatsink: You're right, it would be.
20:48:22 <FunctorSalad_> is there even still a graphics mode at bsod?
20:48:34 <dons> thetallguy: oh, so that means an ubuntu user can type an apt command to get the *debian* package?
20:48:50 <Dzlk> Y bsod
20:48:51 <Olathe> There's probably just VGA or something.
20:48:54 <dons> thetallguy: my challenge is to give a simple command to the shootout guys that will give them 'parallel' on their box
20:49:00 <dons> their ubuntu hardy box
20:49:14 <FunctorSalad_> dons: I asked the opposite on #debian and got flamed ;-)
20:49:16 <heatsink> Dzlk: it would be a loop, except instead of using a branch to repeat, it would use the hardware's exception handling mechanism.
20:49:40 <dons> no flames here :)
20:49:59 <dancor> didn't dons have some vim thing or something to add type annotations to every function
20:50:01 <Olathe> Well, there are flames, but they're contained safely within IO.
20:50:39 <FunctorSalad_> dons: yes, that's really my favourite thing about haskell
20:52:59 <Dzlk> Squeak has some comical failure modes. I remember mousing over a morph generated an error dialog that somehow always popped up positioned so that you had to cross the erroring morph to dismiss it...
20:53:05 <thetallguy> dons: no, it means they could add deb.seereason.com and get it from us.
20:53:33 <thetallguy> dons: that is, build from source with all Ubuntu packages used as build dependencies.
20:54:29 <dons> thetallguy: would that be easier than wget from hackage ?
20:54:56 <thetallguy> dons: Hmm...  Well, it would be correct.
20:55:00 <thetallguy> don't know about easier
20:55:01 <greendemon> has anyone ever gotten "gcc: unrecognized option '-u'" from ghc before?
20:55:15 <heatsink> no -u
20:55:24 <thetallguy> add this line to sources.list:  deb http://deb.seereason.com/ubuntu hardy-seereason main
20:55:29 <lambdabot> Title: Index of /ubuntu
20:55:38 <thetallguy> then apt-get update; apt-get install libghc6-parallel-dev
20:55:49 <thetallguy> Yeah, I'd say it's easier
20:55:57 <rwbarton> thetallguy: Do you have a pre-built cabal executable?  ("cabal install")
20:56:12 <greendemon> I'm using ghc 6.8.3 and gcc 4.3.1
20:56:18 <thetallguy> rwbarton: only debs
20:56:26 <Dzlk> I've had "gcc: unrecognized option" errors that were from using a prebuilt ghc with an outdated gcc, but not '-u'.
20:56:28 <thetallguy> cabal always builds from source, doesn't it?
20:56:39 <rwbarton> thetallguy: Right, I mean a .deb for ubuntu that installs the cabal command-line client
20:56:54 <thetallguy> rwbarton: oh, yes, I think so
20:57:01 <greendemon> Ok, I'm using a prebuilt ghc from Fink on a mac
20:57:03 <thetallguy> rwbarton: let me check
20:57:03 <rwbarton> thetallguy: Oh, that would be sweet
20:57:23 <greendemon> It seem's to be a warning, not an error, since everything compiles and links ok as far as I can tell
20:57:32 <heatsink> What does -u do?  I've never used it.
20:57:48 <greendemon> I don't know, I haven't either
20:58:28 <greendemon> It's not stopping me from compiling or anything, but it is curious
20:58:50 <thetallguy> rwbarton: I thought we had one, but I don't see it.
20:59:10 <thetallguy> rwbarton: however, we do have a utility that does  Cabal -> Debian
20:59:19 <thetallguy> rwbarton: so I should be able to make it.
20:59:22 <rwbarton> thetallguy: Ah, no worries
20:59:42 <rwbarton> thetallguy: OK, I can take a look at that and package up what I need
21:00:17 <Dzlk> Ah. "-u SYMBOL: Pretend the symbol SYMBOL is undefined, to force linking of library modules to define it."
21:00:43 <thetallguy> cabal-debian is the package with the conversion tool
21:00:53 <Dzlk> From gcc 4.2.3 info page. Don't know what version it appeared in.
21:01:08 <thetallguy> just cd into the root and run cabal-install --debianize
21:01:31 <thetallguy> sorry, cabal-debian --debianize
21:01:42 <greendemon> hmm, I'm using gcc 4.3.1, I wonder if it's been deprecated since then?
21:05:34 <rwbarton> thetallguy: thanks.  I will take a more detailed look later
21:07:37 <dancor> how do i parse my .hs if it has ghc extensions (starts with #!.. line)
21:09:39 <thetallguy> rwbarton: uncovered a bug.
21:17:27 <mmorrow> dancor: haskell-src-exts (on hackage) has a parser that handles most extensions.
21:17:42 <mmorrow> there's also a darcs repo
21:18:16 <mmorrow> http://code.haskell.org/HSP/haskell-src-exts/
21:18:16 <thetallguy> haddock 2 has a arser that handles all the extensions now, too
21:18:16 <lambdabot> Title: Index of /HSP/haskell-src-exts
21:19:02 <thetallguy> and then there's this: http://hackage.haskell.org/trac/ghc/ticket/1886#comment
21:19:09 <lambdabot> Title: #1886 (GHC API should preserve and provide access to comments) - GHC - Trac
21:19:19 <mmorrow> thetallguy, dancor: i think it may use the ghc-api though, (which'll make your binaries 12MB/20+MB stripped/unstripped as opposed to 2MB/4MB stripped/unstripped)
21:20:27 <thetallguy> could well  be.  never measured.
21:20:44 <mmorrow> i have a hacked-together module that extracts comments+pragmas (with src locations) from .hs src files: http://code.haskell.org/~morrow/code/haskell/misc/extract-meta.hs.html
21:20:46 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/55mr3o
21:20:52 <mmorrow> fwiw
21:21:05 <mmorrow> it works though
21:21:25 <dons> wow, did anyone else see the job add for 'gamr7' on -cafe?
21:22:04 <mmorrow> no
21:22:18 <mmorrow> but that's so cryptic, i'm intrigued
21:22:31 <dons> 'job ad'  getting late.
21:22:33 <dons> gimme a sec.
21:22:53 <dons> http://www.haskell.org/pipermail/haskell-cafe/2008-September/047168.html
21:22:55 <lambdabot> Title: [Haskell-cafe] haskell job offer., http://tinyurl.com/5jr365
21:23:24 <Nafai> dons: Yeah, it sounds interesting
21:23:46 <Nafai> Sounds like a great opportunity for some Euro-Haskeller
21:23:56 <dmwit> "Like coding for 4+ hours straight." -- anybody else think 4 is a bit low for a job requirement?
21:23:58 <mmorrow> i didn't know what the 'gamr7' was at first..
21:24:17 <dons> dmwit: hehe
21:24:21 <Nafai> dmwit: Heh. :)
21:24:22 <dancor> can i get haddock documentation too when i cabal-install something?
21:24:29 <dons> dmwit: 14 hours straight would be more typical right
21:24:56 <Nafai> Too bad there aren't jobs like that advertised here in Utahh :/
21:25:13 <dons> clearly you need to move to france
21:25:37 <dmwit> gamr7.com seems down =/
21:25:39 <Nafai> Clearly
21:25:41 <dmwit> #haskell-effect
21:25:48 <Dzlk> dons: I'm not sure what 'straight' means. For most values of 'straight' it seems low, if it means without so much as a restroom break than it's a lot.
21:25:53 <dmwit> Oh, there we go.
21:25:53 <Nafai> It looked interesting when I looked at it earlier today
21:25:55 <mmorrow> heh, yeah. hardcore other that the hole 4-hours bit ;)
21:26:42 <dmwit> Wow, that is actually a really cool idea.
21:26:47 <dons> oh, up for me.
21:27:10 <mmorrow> whoa
21:28:28 <dons> nice site.
21:28:42 <mmorrow> very
21:28:47 <dmwit> "If the constraints or the [racing] track changes, the software rebuilds the secondary decors for you."  (Some grammar fixes mine.)
21:29:11 <dons> i wonder if anygma know these guys.
21:29:15 <dons> conal should talk to them.
21:31:35 <eyu100> > (+)
21:31:36 <lambdabot>       Overlapping instances for Show (a -> a -> a)
21:31:36 <lambdabot>        arising from a use ...
21:31:50 <dolio> Nice.
21:31:53 <eyu100> > \x
21:31:54 <lambdabot>   mueval: Prelude.read: no parse
21:32:00 <eyu100> let x = x in x
21:32:08 <eyu100> > let x = x in x
21:32:18 <mmorrow> i wonder how much is being done with haskell, or if they're just starting to use it.
21:32:23 <lambdabot>   thread killed
21:32:37 <dons> i just asked him.
21:32:38 <dons> we'll see.
21:32:50 <dons> i'd imagine they must be doing something already, if they want to hire someone with those skills
21:33:00 <dons> might be one project only though, of course
21:33:03 <eyu100> > let x = 2 in y
21:33:04 <lambdabot>   y
21:33:13 <eyu100> > let x = 2 in 2
21:33:13 <mmorrow> hmm
21:33:14 <lambdabot>   2
21:33:17 <eyu100> let in 2
21:33:25 <eyu100> > let in 2
21:33:26 <lambdabot>   2
21:33:31 <eyu100> > in 2
21:33:32 <lambdabot>   mueval: Prelude.read: no parse
21:33:38 <eyu100> >2
21:33:40 <eyu100> > 2
21:33:41 <lambdabot>   2
21:34:51 <dancor> can i make ghci like .hsc files?
21:36:44 <Myoma> > let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in let in ()
21:36:45 <lambdabot>   ()
21:37:49 <mmorrow> this is who designed that site: http://fullahead.org/
21:37:50 <lambdabot> Title: FullAhead / Design by Pat Heard
21:37:53 <dons> bos, you got a few more days on the padl thing
21:38:28 <dons> nice, mmorrow
21:40:20 <rwbarton> Data.ByteString.readInt + unfoldr is over twice as fast as C's scanf?!
21:40:22 <rwbarton> dons++
21:40:26 <dons> hehe
21:40:28 <dons> we try.
21:40:56 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=all
21:40:59 <lambdabot> Title: sum-file benchmark | Gentoo : Intel® Pentium® 4 Computer Language Benchmarks G ..., http://tinyurl.com/o8pll
21:41:21 <dmwit> dancor: not really
21:41:41 <Dzlk> mmorrow: even more impressive, from a cursory look it seems that all the portfolio sites render fine in Opera, too.
21:41:41 <dolio> Hey dons, have you looked at my uvector patches yet? :)
21:41:46 <dmwit> dancor: But you should be able to coerce GHC into generating real .hs files from it.
21:42:32 <mmorrow> Dzlk: heh. i just bookmarked his page like 9 times to make sure i don't lose it.
21:43:54 <dons> dolio: they're in my inbox. travelling this week, but keen to restart uvector work
21:44:38 <dolio> Okay. I've actually been pretty distracted for a while, so it hasn't really been holding me back any. But I am still waiting on them to release uvector-algorithms.
21:49:28 <dons> dolio: ok. i want to work on bytestring introduction and elimination
21:49:35 <dons> so we can hook it to decent io
21:49:41 * dons off to bed
22:01:52 <mmorrow> dolio: what's in your uvector-algos?
22:02:48 <dolio> Merge sort, intro sort/select, and some heap stuff so far.
22:03:27 <dolio> And some side bits to support those (optimal 2, 3 and 4 sorts, insertion sort...)
22:04:29 <dolio> I haven't actually worked at it in a couple weeks or so. I've been distracted by other stuff.
22:06:19 <dolio> I think I added some combinators for using them on immutable arrays easily, and doing sortBy type stuff.
22:06:27 <mmorrow> cool, i know how that goes. what's the performance, say, from list -> uvec -> uvec -> list relative to a pure list sort? (or is this even a worthwhile comparison?)
22:06:29 <dancor> Language.Haskell.Exts.Parser.parseModule still doesn't like #!
22:06:46 <dancor> how does ghc do it..
22:07:16 <dolio> I haven't tested that, actually. I've just been testing performance of sorts on mutable arrays versus C++, really.
22:07:30 <dolio> Using vector<T>.
22:07:47 <dolio> Well, vector<long> in practice.
22:07:59 <mmorrow> also, i don't recall the interface exactly. are uvectors essentially ByteString parameterized by some type? ie ForeignPtr Int Int or something
22:08:15 <mmorrow> dolio: nice.
22:09:33 <dolio> So far, my stuff is focused on the mutable arrays, which are a wrapper around MutableByteArray#.
22:09:42 <mmorrow> dancor: what is '#!' from??
22:10:22 <mmorrow> dolio: oh interesting. i've always wanted to play with those
22:11:09 <dolio> And there's type classes and type families that efficiently store both primitive and complex data in them, much like the parallel array stuff from the data parallelism work.
22:11:29 <mmorrow> dancor: ohhh, you mean (#!) :: ... ? if so, you can't have -fglasgow-exts on since that conflits with unboxed pair syntax (this happened to me last week)
22:12:05 <dancor> dmwit_: ghci doesn't seem to like the .hs that hsc2hs makes either
22:12:10 <dolio> And with sufficient inlining and specialization, everything gets unrolled to calls on MutableByteArray#s, which is pretty fast.
22:12:21 <dolio> Better than STUArray, anyhow.
22:12:27 <dancor> mmorrow: sorry, no i mean the   #!/usr/bin/env runhaskell
22:12:29 <mmorrow> dolio: oohh, very interesting. so you mean just using it as a raw memory chunk, and chopping it up yourself?
22:12:52 <mmorrow> dancor: oh, that's not valid to have in a haskell file i don't believe
22:13:18 <dolio> Well, I don't have to deal with any of that in the algorithms, but yes, that's what it eventually gets down to.
22:14:00 <dolio> The challenge with the algorithms package has been making sure the code is written such that GHC can optimize it all down nicely.
22:14:06 <mmorrow> so these type families exist already in the package?
22:14:55 <dolio> Yes. And presumably you can write instances for your own types, so they're efficiently represented.
22:15:17 <dolio> The data parallel stuff actually has work for deriving the instances automatically.
22:15:22 <dolio> Which is nice.
22:15:29 <mmorrow> coolness
22:15:44 <dancor> mmorrow: yeah.  i guess ghc prolly just does some one-off-ery
22:15:47 <mmorrow> i've gotta take a look at that
22:15:49 <dancor> and so shall i
22:16:25 <rwbarton> > (minBound :: Int) `rem` (-1)   -- weird
22:16:25 <mmorrow> ghc -e 'putStr . unlines . tail . lines =<< getContents'
22:16:26 <lambdabot>   mueval: Prelude.read: no parse
22:16:26 <lambdabot>  mueval: *** Exception: arithmetic overflow
22:17:31 <eyu100> > (minBound :: Int) `rem` (-1)
22:17:32 <lambdabot>   mueval: Prelude.read: no parse
22:17:32 <lambdabot>  mueval: *** Exception: arithmetic overflow
22:17:45 <eyu100> > tail [1, 2]
22:17:46 <lambdabot>   [2]
22:17:48 <rwbarton> > (-2983552) `rem` (-1)
22:17:49 <lambdabot>   0
22:17:52 <eyu100> > head [1, 2]
22:17:53 <lambdabot>   1
22:17:57 <eyu100> > head [1, 2, 2, 2]
22:17:58 <lambdabot>   1
22:18:29 <mmorrow> > (head&&&tail) [1..4]
22:18:30 <lambdabot>   mueval: Prelude.read: no parse
22:18:32 <eyu100> > let (\(x:xs) -> x) in [1, 2, 2]
22:18:33 <lambdabot>   mueval: Prelude.read: no parse
22:18:46 <eyu100> > (\(x:xs) -> x) [1, 2, 2]
22:18:47 <lambdabot>   1
22:19:00 <eyu100> > \
22:19:01 <lambdabot>   mueval: Prelude.read: no parse
22:19:15 <eyu100> > putStrLn "'\' is awesome"
22:19:16 <lambdabot>   mueval: Prelude.read: no parse
22:19:16 <lambdabot>  mueval: *** Exception: "<IO ()>"
22:19:26 <Myoma> > (head&&&tail) [1..4]
22:19:26 <eyu100> > "gogo \"
22:19:28 <lambdabot>       lexical error in string/character literal at character '\n'
22:19:28 <lambdabot>  Terminated
22:19:29 <Myoma> > (head&&&tail) [1..4]
22:19:31 <lambdabot>   mueval: Prelude.read: no parse
22:19:35 <Myoma> > (head &&& tail) [1..4]
22:19:36 <lambdabot>   mueval: Prelude.read: no parse
22:19:37 <eyu100> > "gogo \\"
22:19:38 <lambdabot>   "gogo \\"
22:19:43 <eyu100> > "gogo \""
22:19:44 <mmorrow> > show  '\\'
22:19:45 <lambdabot>   "gogo \""
22:19:45 <Myoma> > (Control.Arrow.head &&& Control.Arrow.tail) [1..4]
22:19:46 <lambdabot>   "'\\\\'"
22:19:47 <lambdabot>  Terminated
22:19:48 <eyu100> > "gogo \"
22:19:49 <Myoma> > (Control.Arrow.head &&& Control.Arrow.tail) [1..4]
22:19:49 <lambdabot>       lexical error in string/character literal at character '\n'
22:19:50 <lambdabot>   mueval: Prelude.read: no parse
22:19:53 <mmorrow> > (show . show)  '\\'
22:19:55 <lambdabot>   "\"'\\\\\\\\'\""
22:19:56 <Myoma> > (Control.Arrow.head &&& Control.Arrow.tail) [1..4]
22:19:58 <lambdabot>   mueval: Prelude.read: no parse
22:20:00 <mmorrow> > fix show
22:20:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:20:06 <eyu100> > \
22:20:07 <lambdabot>   mueval: Prelude.read: no parse
22:20:10 <eyu100> > \\
22:20:11 <lambdabot>   mueval: Prelude.read: no parse
22:20:12 <Myoma> > let head (x:_) = x ; tail (_:xs) = xs in (head &&& tail) [1..4]
22:20:13 <lambdabot>   mueval: Prelude.read: no parse
22:20:15 <Myoma> > let head (x:_) = x ; tail (_:xs) = xs in (head &&& tail) [1..4]
22:20:16 <lambdabot>   mueval: Prelude.read: no parse
22:20:26 <eyu100> > (\x) 5
22:20:27 <lambdabot>   mueval: Prelude.read: no parse
22:20:31 <Myoma> > let head (x:_) = x ; tail (_:xs) = xs ; (f & g) x = (f x, g x) in (head  tail) [1..4]
22:20:32 <lambdabot>   Couldn't match expected type `[t]'
22:20:34 <Myoma> > let head (x:_) = x ; tail (_:xs) = xs ; (f & g) x = (f x, g x) in (head & tail) [1..4]
22:20:35 <lambdabot>   (1,[2,3,4])
22:20:38 <mmorrow> > (head Control.Arrow.&&& tail) [0..9]
22:20:39 <lambdabot>   mueval: Prelude.read: no parse
22:21:04 <Myoma> who to report problem to
22:21:06 <Myoma> ?
22:21:15 <Myoma> 1) "no parse" is a lie and a bad error message
22:21:22 <Myoma> 2) Control.Arrow should be around
22:21:26 <rwbarton> hmm, maybe that overflow error is so that a `quotRem` b == (a `quot` b, a `rem` b)
22:22:15 * mmorrow has nightmares about "mueval: Prelude.read: no parse"
22:22:49 <mmorrow> > minBound :: Int
22:22:51 <lambdabot>   -9223372036854775808
22:22:53 <Myoma> lambdabot still gives "Terminated" it seems like the evaluator wasn't the problem
22:23:00 <Myoma> and mueval gives worse error messages ...
22:23:58 <mmorrow> Myoma: yeah, it must be trying to Prelude.read who-knows-what and doesn't bother handling the case where it gets garbage/who-knows-what
22:24:12 <rwbarton> ooh, 64-bit
22:24:13 <mmorrow> i think it's funny that instead of showing "<IO ()>"
22:24:19 <mmorrow> > print 0
22:24:21 <lambdabot>   mueval: Prelude.read: no parse
22:24:21 <lambdabot>  mueval: *** Exception: "<IO ()>"
22:24:29 <mmorrow> call error  mueval: *** Exception: "<IO ()>"
22:24:45 <mmorrow>  /with/ the value that could just as easily be shown
22:26:10 <mmorrow> rwbarton: 64bit ints are ginormous
22:26:16 <Myoma> > 2^64
22:26:18 <lambdabot>   18446744073709551616
22:26:25 <mmorrow> > 2^64-1
22:26:26 <lambdabot>   18446744073709551615
22:26:30 <mmorrow> fence-post
22:26:31 <Myoma> > 2^64+1
22:26:32 <lambdabot>   18446744073709551617
22:26:41 <mmorrow> you trickster
22:26:50 <Myoma> :))
22:26:52 <mmorrow> > 2 ^ 64 + 1 :: Int64
22:26:53 <lambdabot>   1
22:26:56 <mmorrow> hehe
22:27:59 <mmorrow> @type (&&&)
22:28:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:28:06 <mmorrow> wtf
22:28:11 <mmorrow> @type (L.&&&)
22:28:13 <lambdabot> Not in scope: `L.&&&'
22:29:00 <Myoma> oh god @type is out of since with @run
22:29:09 <Myoma> and @src hasn't been typecheckd
22:29:15 <Myoma> it's all falling apart
22:29:18 <rwbarton>  @type is totally unrelated to @run afaik
22:29:24 <Myoma> this is the end
22:29:37 <mmorrow> the world slowly crumbles.
22:29:43 <rwbarton> Oh, maybe it's only slightly unrelated
22:29:44 <dolio> @run has been replaced.
22:29:45 <lambdabot>   mueval: Prelude.read: no parse
22:29:51 <dolio> Recently.
22:29:56 <mmorrow> yeah.
22:30:32 <rwbarton> @let a &&& b = \x -> (a x, b x)
22:30:35 <lambdabot>  Defined.
22:30:36 <mmorrow> gwern's mueval which uses hint has taken plugin's place
22:30:43 <rwbarton> > head &&& tail $ [1,2,3,4]
22:30:44 <lambdabot>       Ambiguous occurrence `&&&'
22:30:44 <lambdabot>      It could refer to either `L.&&&', defin...
22:30:48 <Myoma> oh m ygod
22:30:50 <rwbarton> > head L.&&& tail $ [1,2,3,4]
22:30:51 <lambdabot>   (1,[2,3,4])
22:31:03 <Myoma> @quote end
22:31:03 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
22:31:03 <lambdabot> will stab you in the back with a mantissa
22:31:08 <Myoma> @quote .end.
22:31:08 <lambdabot> Entropy says: I agree; we need to remove Emacs' ridiculous dependency on a kernel being present
22:31:11 <Myoma> @quote .end.
22:31:11 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
22:31:11 <lambdabot>  what you just said?"
22:31:41 <Myoma> hi ski
22:31:54 <Dzlk> mueval -e '2 + 2' gives "Expression did not compile", "Time limit exceeded" in the version I cabal-installed locally.
22:32:14 <Dzlk> > 2 + 2
22:32:16 <lambdabot>   4
22:32:17 <mmorrow> i think there's a -t flag
22:32:19 <Myoma> that is ridiculous, we should rewrite mueval in ELISP
22:32:42 <dolio> No way. Xah Lee has convinced me that ELISP is not a good language.
22:32:43 <mmorrow> Myoma: bash.
22:32:51 <Myoma> hehehe
22:33:26 <Myoma> hm
22:34:40 <rwbarton> I wish there were a GHC compiler pragma to assert "this function will never throw an error"
22:34:41 <Dzlk> Hm, increasing time limit only lengthens the duration of the whatever it's doing silently between showing "Expression did not compile" and dying with time limit exceeded.
22:34:55 <rwbarton> Then the compiler could throw away any cases that led to an error being raised
22:35:32 <rwbarton> (OK, I don't really care about this, but it could help optimizing the last few percent)
22:35:35 <dolio> -ftotal-functional-programming
22:35:42 <Myoma> :D
22:37:27 <rwbarton> It would save me from having to learn about unsafeRead and remInt and so on.
22:42:40 <Myoma> > unfoldr (Just . (fst L.&&& snd) . out) $ fix (In . (,) 1)
22:42:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:43:52 <Myoma> > unfoldr (Just . out) $ fix (In . (,) 1)
22:43:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:50:54 <geezusfreeek> i'm screwed i just got back into frp again
22:52:08 <Myoma> oh the terrible quagmire
22:52:22 <BMeph> geezusfreeek: Then I'm super-screwed, 'cause I haven't gotten into FRP yet... o.O
22:52:25 <Myoma> there is no swamp deeper than FRP
22:53:03 <geezusfreeek> BMeph: i recommend you stay away until there is some more maturity in the area then ;) it's a trap
22:53:14 <BMeph> Myoma: Unless it's GPU programming to support FRP... ;p
22:54:01 <Armored_Azrael1> Hey, reading about STG machines, and have a question:
22:54:08 <Armored_Azrael1> Do they use the same memory to store the initial thunk as the updated one?
22:54:13 <Armored_Azrael1> If so, how come they have to bother differentiating between update/non-update structure, as wouldn't the one-evaluation principle hold regardless because calling the update function would just return the value on already evaluated blocks?
22:54:21 <BMeph> geezusfreeek: Uh-oh. As an undergrad in SW Engineering, I'm just the kind of guy...that gets asked to "investigate that noise"... ;)
22:55:30 <thatsright> hello
22:55:36 <ac> functional references are great
22:55:54 * BMeph gets sent off "to make a presentation on how FRP works; I'm sure it'll be easy!" =8*O
22:55:54 <dolio> They are.
22:56:28 <BMeph> ac, dolio : So, what's a dysfunctional reference? ;)
22:56:43 <BMeph> Java? 8D
22:56:49 <dolio> Sure. :)
22:56:51 <dmwit_> BMeph: Haskell's current record syntax.
22:57:11 <BMeph> dmwit_: Hmm, true dat. :|
22:57:34 <dmwit_> Armored_Azrael1: Remind me what page it's on.  I remember thinking about that when I read it, too.
22:58:46 <Myoma> ac, why
22:59:22 <Armored_Azrael1> dmwit_: pg 23-24 has the bit talking about why they have the n vs. u
22:59:37 <ac> Myoma: seems like they solve the exact problem I'm grappling with now
22:59:59 <Myoma> what is it?
23:00:10 <Myoma> ac, I do not know anything about functional references
23:00:14 <ac> which is I have a record and I want to elegantly write a bunch of functions that modify one member in that record
23:00:37 <ac> dmwit (I believe) posted a good link earlier today: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
23:00:41 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
23:00:46 <geezusfreeek> i imagine that updating the structure could possibly tell the runtime system that the thunk is now effectively immutable and hence thread safe, but i am only guessing
23:00:56 <Myoma> ac, and you are sure this is the best way
23:00:57 <Myoma> ?
23:01:07 <dmwit_> Armored_Azrael1: I think the point is that you can do away with the update sometimes.
23:01:20 <dmwit_> Armored_Azrael1: i.e. you *could* put a 'u' on every cell.
23:01:29 <dmwit_> Armored_Azrael1: And the one-evaluation principle would hold.
23:01:42 <Armored_Azrael1> dmwit_: But don't you need to call into the update to extract the value anyways?
23:01:42 <dmwit_> Armored_Azrael1: But *sometimes*, you know that cell will never be touched again.
23:01:49 <dmwit_> nope
23:01:52 <dmwit_> That's the beauty of it.
23:02:14 <Armored_Azrael1> dmwit_: Then I must have misunderstood their closure structure--I thought you had to call the function to get the data always.
23:02:18 <dmwit_> Just calculate the value -- no need to overwrite the old computation with a new, trivial computation.
23:02:31 <dmwit_> Armored_Azrael1: Yes, you have to call the function to get the value.
23:02:46 <dmwit_> Armored_Azrael1: But you don't have to write a *new* function if you don't have to update!
23:02:54 <dmwit_> i.e. it looks like this:
23:02:55 <Armored_Azrael1> oic
23:02:58 <Armored_Azrael1> I got it.
23:03:00 <dmwit_> ok, you get it =)
23:03:28 <Armored_Azrael1> I just assumed that the update was handled internal to the evaluation function, and so would be opaque to the language, but it makes sense now.
23:05:50 <Myoma> it is really annoying all these languages are getting 'closures'
23:06:07 <dolio> Have you been talking to Cale?
23:06:54 <ac> Myoma: I'm not sure of the best way for anything
23:07:22 <Cale> Some people actually know what 'closure' means :)
23:07:44 <Myoma> I am actually not so much bugged by the terminology
23:08:30 <Myoma> I do not understand why people are adding things to languages that already exist, I thought that most language design people have realized this does not work
23:09:37 <zeno_> is there a built-in for this? alwaysFalse _ = False
23:09:50 <dolio> C++ has so much other stuff already, might as well add them. :)
23:09:54 <Cale> zeno_: const False
23:10:00 <zeno_> thanks
23:10:56 <Myoma> I read some thing about adding closures to C
23:11:06 <Myoma> "It will be valuable in the war against multicore"
23:11:15 <dolio> Heh.
23:11:22 <Myoma> they want to use _closure_ in _C_ to write concurrent programs ...!
23:11:55 <Myoma> someone who looks forward to closures in a new language, instead of using one that already exists? :)
23:12:21 <dolio> The multicore language of the future has already been decided upon.
23:12:22 <dolio> F#.
23:12:24 <Myoma> all the work implementing all this could surely be used for something more.. worthewhile
23:12:35 <chrisdone> is there a function which abstracts foo f [] = [], foo f xs = f xs?
23:12:54 <chrisdone> hm, no
23:13:00 <Myoma> list nil cons [] = nil ; list nil cons (x:xs) = cons x xs
23:13:10 <Myoma> foo f = list [] (f . (:))
23:13:48 <Myoma> (f .) . (:) *
23:14:50 <chrisdone> anything that already exists?
23:15:00 * Myoma already had list in a file on her HD
23:15:06 <dolio> No.
23:15:17 <Myoma> it's not part of GHC... yet
23:15:47 <dolio> Unless you count '\f xs -> foldr (const $ f xs) []' or something.
23:16:00 <dolio> Oops, that should have an xs at the end.
23:16:48 <Myoma> > (\f xs -> foldr (const $ f xs) [] xs) (\x xs -> x:xs) [1,2,3]
23:16:50 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3]]
23:16:50 <zeno_> how about a default for this? ifTListElseNull t x = if t then x else [] (still learning my way around the libraries :)
23:17:07 <Myoma> zeno_: bool t x []
23:17:18 <Myoma> bool true false True = true ; bool true false False = false
23:17:20 <dolio> Oh, hold on.
23:17:35 <Myoma> why are all these combinators missing? :)
23:17:37 <zeno_> Myoma: ah thanks
23:17:43 <Myoma> Because there's no means to derive them automatically I suppose
23:17:47 <dolio> > (\f xs -> foldr (const . const $ f xs) [] xs) id [1,2,3]
23:17:48 <lambdabot>   [1,2,3]
23:17:57 <dolio> > (\f xs -> foldr (const . const $ f xs) [] xs) tail [1,2,3]
23:17:59 <lambdabot>   [2,3]
23:18:01 <dolio> > (\f xs -> foldr (const . const $ f xs) [] xs) tail []
23:18:03 <lambdabot>   []
23:18:11 <Myoma> oh cool dolio, I didn't know that was possible
23:18:48 <Myoma> :t (const . const $ ?f ?xs)
23:18:49 <lambdabot> forall b a b1 t. (?xs::t, ?f::t -> a) => b -> b1 -> a
23:19:03 <dolio> Reall you want 'para (const f) []'.
23:20:02 <dolio> Or something of the sort.
23:22:30 <dolio> Although a standard para wouldn't pass you the list fully formed like you'd want, same as uncons.
23:26:28 <chrisdone> @instances MonadPlus
23:26:29 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
23:30:27 <chrisdone> > let fizz f v = if v == mzero then v else f v in fizz tail ["foo","bar","mu"]
23:30:28 <lambdabot>   ["bar","mu"]
23:30:55 <chrisdone> I can't think of another mplus instances where this would be more useful than fmap, so change mzero to []
23:31:02 <chrisdone> : (
23:33:01 <Myoma> if is horribly ugly and should be removed from haskell
23:33:19 <Myoma> It's cruft inherited from ALGOL
23:33:32 <cadabra> Say I have two tuples a@(a0, a1, a2) and b@(b0, b1, b2) and I want (f a0 b0, f a1 b1, f a2 b2). Is there a shortcut for that?
23:33:40 <Myoma> cadabra: no there is not
23:33:42 <thetallguy> ﻿rwbarton: I set a build going.  Will know in the morning if it worked.
23:33:45 <chrisdone> yeah i agree
23:34:05 <Myoma> cadabra: What could be shorter than that?
23:34:22 <cadabra> Myoma: tupleMap2 f a b
23:34:33 <Myoma> cadabra: I mean the definition of tupleMap2
23:34:39 <Myoma> cadabra: It couldn't possibly be shorter
23:35:56 <cadabra> Myoma: that's right. Could tupleMap2 be built to handle n-tuples rather than just 3-tuples?
23:36:10 <Myoma> cadabra: no it couldn't
23:36:28 <Myoma> can probably define $(tupleMap 2) in TH though
23:36:36 <Myoma> but I would not recommend it
23:37:07 <Myoma> nesting tuples similar to conses works better
23:37:07 <cadabra> How come?
23:37:40 <Myoma> since you can write (a few) generic functions over them by induction
23:37:42 <Myoma> as typeclasses
23:38:14 <chrisdone> have you seen a wiki page about definitions of bool and if', and/or bool' and if''? I have my own ideas but I'd prefer to be consistent
23:39:41 <wman> hi, how strange is that your app simply stops working (freezes, then crashes without any error report at all) just after importing another module (LDAP-haskell; not that i want it imported just for kicks, but it suffices just to import it)
23:39:59 <zeno_> is there an opposite to $? e.g. x !$ y = (x) y
23:40:09 <Cale> wman: hmm
23:40:15 <Cale> wman: That is awfully strange
23:41:54 <rwbarton> zeno_: how would it differ from $?
23:42:32 <wman> happs as webserver, hdbc-odbc as datasource, runs ok. LDAP-HASKELL dependent part to pull something out of active directory, functions great. hdbc-odbc+ldap is ok, but trying to run it in an action inside happs and boom
23:42:50 <chrisdone> if' true false p = if p true then true else false  and  bool true false p v = if' p v then true v else false v ?
23:43:22 <chrisdone> uh
23:43:52 <mmorrow> (data A a_1 ... a_m = A_1 a1_i ... a1_j | .... | A_n an_i ... an_j) ===> foldA f_1 ... f_i ... f_n (A_i ai_1 ... ai_j) = f_i ai_1 ... ai_j
23:44:04 <mmorrow> chrisdone: this is what i go by
23:44:20 <zeno_> rwbarton: oh duh =p sorry
23:44:25 <mmorrow> which gives  maybe, either, list, bool, ...
23:44:31 * Myoma has written a fold generator plugin for lambdabot
23:44:39 <Myoma> it is certainly incorrect though
23:44:40 <mmorrow> really?
23:44:43 <rwbarton> so  bool false true p = if p then true else false
23:44:55 <mmorrow> is it here right now?
23:44:57 <Myoma> mmorrow: @cata data ... = ...
23:45:04 <Myoma> it's probably still on hpaste
23:45:08 <chrisdone> rwbarton: right
23:45:23 <chrisdone> wait, no?
23:45:27 <mmorrow> rwbarton: yes
23:45:28 <Myoma> mmorrow: but it wasn't correct when you use -> or some kinds of recursion so ... I don't know why I mentioned it
23:45:33 <zeno_> i just used bool True x _ = x;bool False _ x = x, should work
23:45:42 <mmorrow> yeah, same
23:45:44 <mmorrow> thing
23:45:55 <Myoma> zeno_: That's looks like a pretty awkward thing to work with
23:46:07 <chrisdone> shouldn't `bool' take functions to work on the value depending on true or false? like maybe? like fmap for bool+value? >_> ?
23:46:09 <Myoma> zeno_: Try using  bool true false True = true ; bool true false False = false  for a bit, it should curry better
23:46:22 <mmorrow> list n c [] = n ; list n c xs = c xs
23:46:23 * Myoma misuses words left and right
23:46:48 <zeno_> Myoma: ah ok, i never know how to get the right curry order!
23:46:54 <mmorrow> maybe b _ Nothing = b ; maybe _ f (Just a) = f a
23:46:54 <Myoma> zeno_: hehe
23:46:55 <chrisdone> mmorrow: we should get this on a wiki page imo
23:47:01 <mmorrow> chrisdone: we should
23:47:11 <Myoma> mmorrow: You don't find c (x:xs) = c x xs better?
23:47:35 <mmorrow> i personally prefer the other way
23:47:42 <Myoma> It's like a paragraph of TH nobody ever wrote up
23:47:49 <mmorrow> haha
23:47:50 <Myoma> writing that may be better than a wikipage
23:48:18 <mmorrow> oh, i see what you're saying. yeah. both would be ideal, but more work..
23:48:22 <mmorrow> ;)
23:48:52 <mmorrow> actually, that may be rather quick to write. hmm.
23:50:57 <dancor> can i make ghci save history between invocations
23:51:12 <Myoma> dancor: mine seems to do that automatically (maybe it's buggy?)
23:51:18 <chrisdone> Myoma: do you use “bool” instead of “if'”? cause imho “if'” could (and does?) perform that definition of “bool” you gave above, and “bool” could take functions to be applied to the value according to true or false
23:51:40 <Myoma> I mostly use bool for pointfree stuff
23:51:46 <dancor> Myoma: ghci\n  4\n  ^D\n  ghci\n  <up>
23:51:47 <chrisdone> right
23:51:49 <dancor> nothing happens
23:52:33 <Myoma> dancor: I am using 6.9.20080615 and that worked for me
23:52:36 <dancor> ok
23:52:38 <Myoma> dancor: maybe it's editline vs readline
23:53:13 <dancor> Myoma: what is editline?
23:53:26 <Myoma> some software that my version of ghci uses
23:53:45 <roconnor> ugh, why isn't (\x -> trace (show x) x) part of Debug.Trace?
23:54:00 <Myoma> :t trace
23:54:01 <lambdabot> Not in scope: `trace'
23:54:38 <chrisdone> only newbs use Debug.Trace :P
23:55:01 <roconnor> :P
23:55:44 * dancor will see what happens in 6.10 in 10 days
23:59:20 <_zenon_> Good mornin'
